/*
 * Program:	FileType.c - core application routines
 *
 * Project:	!Omni OmniClient(tm) project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@ant.co.uk
 *
 * Date:	3 November 1994
 * Last Edited:	18 November 1994
 *
 * Copyright 1994 by ANT Limited
 */

#include "Hdrs.h"
#include "kernel.h"
#include <ctype.h>


/*  Case-[in]sensitive string match against (possibly) wildcarded 's1'.
 */
static Desk_bool wildmatch(char *s1, char *s2, Desk_bool caseless)
{
  char *star = NULL;

  /* Check for problem/fast cases */
  if ((!s1) || (!s2)) return(Desk_FALSE);
  TRACE2("wildmatch: '%s' '%s'\n", s1, s2);
  if ((strlen(s1) == 0) && (strlen(s2) != 0)) return(Desk_FALSE);
  if (!strcmp(s1, "*")) return(Desk_TRUE);

  if ((star = strchr(s1, '*')) != NULL)
  {
    char p1[8];
    char p2[8];

    /* 0 or more chars to match ... */
    strncpy(p1, s1, star-s1);
    p1[star-s1] = '\0';
    strncpy(p2, s2, star-s1);
    p2[star-s1] = '\0';
    if (!wildmatch(p1, p2, caseless)) return(Desk_FALSE);
    if (!strcmp(star, "*")) return(Desk_TRUE);
    s2 = (char *) (s2 + (star-s1));
    s1 = (char *) (star + 1);
    while (*s2 != '\0')
    {
      if (wildmatch(s1, s2, caseless)) return(Desk_TRUE);
      s2++;
    }
    return(Desk_FALSE);
  }
  else
  {
    /* easy case */
    if (strlen(s1) != strlen(s2)) return(Desk_FALSE);
    while (*s1 != '\0')
    {
      if (caseless)
      {
        if ((tolower(*s1) != tolower(*s2)) && (*s1 != '?')) return(Desk_FALSE);
      }
      else
      {
        if ((*s1 != *s2) && (*s1 != '?')) return(Desk_FALSE);
      }
      s1++;
      s2++;
    }
    return(Desk_TRUE);
  }
}


/*  Free chain of filetype extensions.
 */
extern void FileType_FreeChain(void)
{
  ext_record *er = (ext_record *) ext_anchor.next;

  /* Free all items in chain */
  TRACE("FileType_FreeChain: enter\n");
  while (er)
  {
    ext_record *er_tmp = (ext_record *) er->header.next;
    Desk_LinkList_Unlink(&ext_anchor, &(er->header));
    RMAFREE(er);
    er = er_tmp;
  }

  /* Reset global anchor */
  Desk_LinkList_Init(&ext_anchor);
  TRACE("FileType_FreeChain: exit\n");
}


/*  Create a new filetype translation item.
 */
static Desk_bool CreateItem(int client_id, char *ext, int filetype, int flags)
{
  ext_record *er = NULL;

  TRACE2("CreateItem: %x '%s' ", client_id, ext);
  TRACE2("0x%x %x\n", filetype, flags);
  /* Allocate memory for record */
  if (!(er = (ext_record *) rma_alloc(sizeof(ext_record)))) return(Desk_FALSE);
  er->client_id = client_id;
  er->flags = flags;
  er->filetype = filetype;
  strncpy(er->ext, ext, 8);
  er->ext[7] = '\0';
  Desk_LinkList_AddToTail(&ext_anchor, &(er->header));
  TRACE1("CreateItem:new ext list length %d\n", Desk_LinkList_ListLength(&ext_anchor));
  return(Desk_TRUE);
}


/*  Locate a filetype item from extension or filetype.
 */
static ext_record *FindItem(int client_id, char *ext, int filetype)
{
  ext_record *er = (ext_record *) ext_anchor.next;
  int searchtype = 0;

  TRACE("FindItem: entry\n");
  if (filetype != -1) searchtype = 1;
  while (er != NULL)
  {
    TRACE1("FindItem: %x\n", (int) er);
    switch (searchtype)
    {
      case 0: if ((er->client_id == client_id) && (eflagSET(er, ext_TOTYPE)) &&
                  (wildmatch(er->ext, ext, !eflagSET(er, ext_CASE)))) return(er);
              break;
      case 1: if ((er->client_id == client_id) && (!eflagSET(er, ext_TOTYPE)) &&
                  (er->filetype == filetype)) return(er);
              break;
      default:
        break;
    }
    er = (ext_record *) er->header.next;
  }
  return(NULL);
}


/*  Load & parse filetypes file.
 */
extern void FileType_Load(void)
{
  FILE *f = fopen(app_FILES"Extensions", "r");
  char line[256];
  client_record *cr = NULL;
  client_record dummy_cr;

  /* Open failed ? no error */
  TRACE1("FileType_Load: %d\n", (int) f);
  FileType_FreeChain();
  if (f == NULL) return;
  dummy_cr.client_id = -1;

  /* Display hourglass during operation */
  Desk_Hourglass_On();

  /* Read lines from file until EOF */
  while (fgets(line, 255, f) != NULL)
  {
    char *s = NULL;
    char *ext = NULL;
    int filetype = -1;
    int flags = 0;

    /* Comment line - ignore */
    if (line[0] == '#') continue;
    if ((s = strchr(line, '#')) != NULL) *s = '\0';
    TRACE1("load: '%s'\n", line);

    /* New protocol name */
    if (!strchr(line, ','))
    {
      if ((s = strtok(line, " \n\r")) == NULL) continue;
        else strip(s);
      if ((!s) || (strlen(s) < 2)) continue;
      TRACE1("load: protocol = '%s'\n", s);
      if (!strcasecmp(s, "default"))
      {
        cr = &dummy_cr;
        TRACE("load: valid default protocol\n");
        continue;
      }
      if ((cr = ClientFind(-1, NULL, -1, s)) == NULL)
      {
        TRACE("load: invalid protocol - skipping\n");
      }
      else
      {
        TRACE("load: valid protocol\n");
      }
      continue;
    }

    /* Normal line? */
    if (!cr) continue;
    if ((s = strtok(line, ",")) == NULL) continue;
      else strip(s);
    TRACE1("load: part1 = '%s'\n", s);
    /* Filetype first ? */
    if ((s[0] == '&') || ((s[0] == '0') && ((s[1] == 'x') || (s[1] == 'X'))))
    {
      if (s[0] == '&') filetype = (int) strtoul(&s[1], NULL, 16);
        else filetype = (int) strtoul(s, NULL, 16);
    } else ext = s;
    if ((s = strtok(NULL, " ,\n\r")) == NULL) continue;
      else strip(s);
    TRACE1("load: part2 = '%s'\n", s);
    flags = 0;
    if (filetype == -1)
    {
      if (s[0] == '&') filetype = (int) strtoul(&s[1], NULL, 16);
        else filetype = (int) strtoul(s, NULL, 16);
      flags |= ext_TOTYPE;
    } else ext = s;
    if ((s = strtok(NULL, " \n\r")) != NULL)
    {
      strip(s);
      TRACE1("load: part3 = '%s'\n", s);
      if (strchr(s, 'k') || strchr(s, 'K')) flags |= ext_KEEP;
      if (strchr(s, 's') || strchr(s, 'S')) flags |= ext_SUBDIR;
      if (strchr(s, 'c') || strchr(s, 'C')) flags |= ext_CASE;
    }
    CreateItem(cr->client_id, ext, filetype, flags);
  }

  /* Close file and exit */
  Desk_Hourglass_Off();
  fclose(f);
}


/*  Translate any illegal chars in string into RISCOS-friendly ones.
 */
static void sanitise(char *s)
{
#ifdef DEBUG
  char *d = s;
#endif

  TRACE1("santise: '%s'\n", s);
  while (*s != '\0')
  {
    if (*s == '.') *s = '/';
    if (*s == ':') *s = ';';
    if (*s == '*') *s = '?';
    if (*s == '#') *s = '?';
    if (*s == '$') *s = '?';
    if (*s == '&') *s = '?';
    if (*s == '@') *s = '?';
    if (*s == '^') *s = '~';
    if (*s == '%') *s = '?';
    if (*s == ' ') *s = '_';
    if (*s == '\\') *s = '/';
    s++;
  }
  TRACE1("santise: exit '%s'\n", d);
}


/*  Convert from Client to Acorn filename/filetype.
 */
extern int FileType_ConvertToType(int client_id, char *srcname, char *dstp, char *flagsp)
{
  ext_record *er = NULL;
  client_record *cr = NULL;
  char dst[32];
  char flags[8];
  char ext[8];
  char *s = NULL;
  char sep;

  TRACE1("FileType_ConvertToType: '%s'\n", srcname);
  if (!(cr = ClientFind(client_id, NULL, -1, NULL))) return(-1);

  /* Look for protocol-specific extension separator character */
  sep = (cr->flags & flag_EXTmask) >> flag_EXTshft;
  if ((sep > 0) && (s = strrchr(srcname, sep)))
  {
    int len = s-srcname;
    /* Extension character found */
    strncpy(ext, (char *) s+1, 8);
    ext[strlen(s+1)] = '\0';
    strncpy(dst, srcname, len);
    dst[len] = '\0';
    TRACE2("Found ext: %d %d\n", ((int) s), ((int) srcname));
    TRACE2("Found ext: '%s' '%s'\n", ext, dst);
    sanitise(dst);
    er = FindItem(client_id, ext, -1);
    if (!er) er = FindItem(-1, ext, -1);
    strcpy(flags, "");

    /* Update flags */
    if (er)
    {
      TRACE2("Found Item! match on '%s' %x\n", er->ext, er->filetype);
      if (eflagSET(er, ext_KEEP))
      {
        strcat(dst, "/");
        strcat(dst, ext);
        strcat(flags, "k");
      }
      if (eflagSET(er, ext_SUBDIR)) strcat(flags, "s");
      if (eflagSET(er, ext_CASE)) strcat(flags, "c");
    }
    else
    {
      if (strlen(ext) > 0)
      {
        strcat(dst, "/");
        strcat(dst, ext);
      }
    }
  }
  else
  {
    /* No extension found, look for wildcard match */
    TRACE("No found ext:\n");
    er = FindItem(client_id, "", -1);
    if (!er) er = FindItem(-1, "", -1);
    strcpy(dst, srcname);
    strcpy(flags, "");
    sanitise(dst);
  }

  /* Return filetype, if we know one */
  if (dstp) strcpy(dstp, dst);
  if (flagsp) strcpy(flagsp, flags);
  if (er) return(er->filetype);
    else return(-1);
}


/*  Convert from Acorn to Client filename.
 */
extern void FileType_ConvertToExtension(int client_id, char *srcname, char *dstp, char *flagsp,
				int filetype)
{
  ext_record *er = NULL;
  client_record *cr = NULL;
  char dst[32];
  char flags[8];
  char ext[8];
  char sep;

  TRACE("FileType_ConvertToExtension:\n");
  if (!(cr = ClientFind(client_id, NULL, -1, NULL))) return;

  /* 'sep' is protocol-specific extension separator character */
  sep = (cr->flags & flag_EXTmask) >> flag_EXTshft;

  er = FindItem(client_id, NULL, filetype);
  if (!er) er = FindItem(-1, NULL, filetype);
  strcpy(dst, srcname);
  strcpy(flags, "");

  /* Update flags */
  if (er)
  {
    if (eflagSET(er, ext_KEEP))
    {
      sprintf(dst, "%s%c%s", dst, sep, ext);
      strcat(flags, "k");
    }
    if (eflagSET(er, ext_SUBDIR)) strcat(flags, "s");
    if (eflagSET(er, ext_CASE)) strcat(flags, "c");
  }
  if (dstp) strcpy(dstp, dst);
  if (flagsp) strcpy(flagsp, flags);
}
