/*
 * Program:	ExtLib.c - extensions library
 *
 * Project:	!Omni OmniClient(tm) project
 *
 * Author:	Nick Smith
 *              Churchill College
 *              Cambridge University
 *              Internet: nas20@cus.cam.ac.uk
 *
 * Date:	9 December 1993
 * Last Edited:	15 February 1994
 *
 * Copyright 1993,1994,1995 by Nicholas A.Smith
 */

#undef DEBUG
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "kernel.h"
#include "Hdrs.h"

#include <Desk/Event.h>
#include <Desk/Screen.h>


int  event_polldelay = -1;
/* -1 = no NULL events,
 *  0 = no Idle events (continuous)
 *  n = Idle every n cs.
 */

/*  *************************** Window_ functions ******************************
 */


/*  Popup given window as a menu
 *  Either appears as a dbox off a menu item (ie, a submenu warning message)
 *  or appears under mouse pointer.
 */
extern void Window_ShowDialogue(Desk_window_handle window, Desk_bool adjustok)
{
  Desk_wimp_point 	moveto;

  /* If the last event was a Submenu warning, then open as a dbox off menu */
  if ((Desk_Event_lastevent.type == Desk_event_SEND) &&
     (Desk_Event_lastevent.data.message.header.action == Desk_message_MENUWARNING))
  {
    moveto.x = Desk_Event_lastevent.data.message.data.menuwarn.openpos.x;
    moveto.y = Desk_Event_lastevent.data.message.data.menuwarn.openpos.y;
  }
  else
  {
    Desk_mouse_block ptr;
    Desk_window_state state;
    int height;

    /* Open under mouse pointer */
    Desk_Wimp_GetPointerInfo(&ptr);
    moveto.x = ptr.pos.x - 64;
    moveto.y = ptr.pos.y + 64;

    /* Ensure we don't obscure the iconbar */
    Desk_Wimp_GetWindowState(window, &state);
    height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
    if ((moveto.y - height) < 96) moveto.y = 96 + height;

    /* Open as a 'menu' - ie, it will not disappear when it's parent menu gets
     * removed by the Wimp.
     */
    if ((!ptr.button.data.adjust) || (adjustok))
    {
      Desk_Wimp_CreateMenu((Desk_menu_block *) window, moveto.x, moveto.y);
      return;
    }
  }

  /* Open as a 'submenu' - ie, it will disappear with an external mouse click */
  Desk_Wimp_CreateSubMenu((Desk_menu_block *) window, moveto.x, moveto.y);
}


/*  Return Desk_TRUE if given window is open.
 */
Desk_bool Window_IsOpen(Desk_window_handle w)
{
  Desk_window_state state;

  if (w == NULL) return(Desk_FALSE);
  Desk_Wimp_GetWindowState(w, &state);
  if (state.flags.data.open) return(Desk_TRUE);
    else return(Desk_FALSE);
}


/*  **************************** Time functions *******************************
 */


#define _OS_Word			0x000007
#define _Territory_ReadCurrentTimeZone	0x043048

/*  Fixed CLib time() function, that works with -ve timezone settings, etc.
 *  From original code by Anthony Frost <vulch@kernow.demon.co.uk>.
 */
extern time_t Risc_Time(time_t *place)
{
  Desk_bool carry = Desk_FALSE;
  char btime[] = "\x00\x00\x00\x00\x6A\x99\x6E\x33\x00";
  char rtime[8], ntime[8], tzname[10];
  int  diff, loop, temp, tz;

  /* Read offset from UTC to current time zone */
  Desk_SWI(0,2, _Territory_ReadCurrentTimeZone, (int *) tzname, &tz);

  /* Read real-time in 5-byte format */
  rtime[3] = 3;
  Desk_SWI(2,0, _OS_Word, 14,&rtime[3]);

  for (loop = 3; loop < 8; loop++)
  {
    temp = rtime[loop] - btime[loop] - carry;
    ntime[loop] = temp & 0xFF;
    carry = ((temp & 0x100) != 0);
  }
  diff = (*((int *) &ntime[4]));
  temp = ((diff / 100) * 256) + (((diff % 100) * 256) + ntime[3]) / 100 + tz / 100;
  if (place)
    *place = temp;
  return(temp);
}


/*  **************************** Desk_Wimp_ functions *******************************
 */


#define _Desk_Wimp_StartTask 0x0400de

/*  RISC_OSLib/DeskLib Desk_wimp_starttask doesn't return task handle.
 *  Task handle of 0 if error.
 */
extern int Wimp_NewTask(char *clicmd)
{
  _kernel_swi_regs r;
  _kernel_oserror *err;

  r.r[0]=(int) clicmd;
  err = _kernel_swi(XOS_Bit | _Desk_Wimp_StartTask, &r, &r);
  if (err) return(0);
    else return(r.r[0]);
}


#define _Desk_Wimp_TextOp	0x0400F9

/*  Return OS units width of given text string, in the current desktop font
 *  (system or anti-aliased).
 */
extern int Text_StringWidth(char *s)
{
  int width = 0;

  TRACE1("strwid: %d\n", Desk_event_wimpversion);
  if (!s) return(0);
  if (Desk_Event_wimpversion > 320)
  {
    /* RISC OS 3.5, RiscPC et al */
    Desk_SWI(3,1, _Desk_Wimp_TextOp, 1,s,0, &width);
    width += 8;
  } else width = (strlen(s) * 16) + 8;
  TRACE2("strwid: '%s' = %d ", s, strlen(s));
  TRACE1("%x\n", width);
  return(width);
}


/*  Fancy greying-out for tricky icons.
 */
extern void Icon_SetGreyShade(Desk_window_handle window, Desk_icon_handle icon, Desk_bool shade,
  int buttontype)
{
  TRACE("Icon_SetGreyShade:\n");
  if (shade)
  {
    Desk_Wimp_SetIconState(window, icon,
      (Desk_icon_BUTTONTYPE*Desk_iconbtype_NEVER) + (Desk_icon_FORECOLOUR*Desk_colour_GREY3),
      (Desk_icon_BUTTONTYPE*15) + (Desk_icon_FORECOLOUR*15));
  }
  else
  {
    Desk_Wimp_SetIconState(window, icon,
      (Desk_icon_BUTTONTYPE*buttontype) + (Desk_icon_FORECOLOUR*Desk_colour_BLACK),
      (Desk_icon_BUTTONTYPE*15) + (Desk_icon_FORECOLOUR*15));
  }
}


/*  Hack to fix indirected text icon validation strings with mouse ptr changing.
 */
extern void Icon_SetValid(Desk_window_handle window, Desk_icon_handle icon, Desk_bool shade)
{
  Desk_icon_block block;
  char *v;

  TRACE("Icon_SetValid:\n");
  Desk_Wimp_GetIconState(window, icon, &block);
  v = block.data.indirecttext.validstring;
  if (((int) v > 0) && (v[0] == 'P')) v[1] = (shade) ? 'w' : 'p';
}


/*  Copy string into new buffer.
 */
extern char *cpystr(char *s)
{
  char *buf;
  if (((int) s <= 0) || (strlen(s) == 0)) return(NULL);
  buf = heap_alloc(strlen(s)+1);
  strcpy(buf, s);
  return(buf);
}


/*  Copy string into new RMA-allocated buffer.
 */
extern char *cpyrma(char *s)
{
  char *buf;
  if (((int) s <= 0) || (strlen(s) == 0)) return(NULL);
  buf = rma_alloc(strlen(s)+1);
  strcpy(buf, s);
  return(buf);
}


/*  Strip whitespace from a string.
 */
extern char *strip(char *s)
{
  char *d = NULL;
  char *o = s;

  if (s == NULL) return(s);
  while ((*s == ' ') || (*s == '\t') || (*s == '\n') || (*s == '\r')) s++;
  d = s;
  if (strlen(s) > 0)
  {
    s = (char *) (s + strlen(s) - 1);
    while ((*s == ' ') || (*s == '\n') || (*s == '\r') || (*s == '\t')) s--;
    *(++s) = '\0';
  }
  strcpy(o, d);
  return(o);
}


/*  Error function for doing a OK/Cancel query error box.
 */
extern Desk_bool Msgs_QueryOK(int errornum, char *tag, ...)
{
  va_list 	va;
  Desk_os_error    	error;
  Desk_error_flags 	eflags;
  char 		title[32];
  int		res = 0;
  char 		buffer[256];

  if (!Desk_Msgs_Lookup(tag, buffer, 252))
    Desk_Error_ReportInternal(0, "Cannot find message for error '%s'", tag);
  else
  {
    va_start(va, tag);
    vsprintf(error.errmess, buffer, va);
    va_end(va);
    error.errnum = errornum;
    sprintf(title, "Message from %s", Desk_Event_taskname);

    eflags.value = 0x13;	/* No 'Error from ' prefix, OK & Cancel buttons */
    res = Desk_Wimp_ReportErrorR(&error, eflags.value, title);
  }
  if (res == 1) return(Desk_TRUE);
    else return(Desk_FALSE);
}

extern void Menu_Dispose(Desk_menu_ptr menu, int all)
{
  Desk_menu_item 	*item = (Desk_menu_item *) ((int) menu + sizeof(Desk_menu_block));
  int 		loop = 0;

  if (menu == NULL) return;
  if (!all)
  {
    free(menu);
    return;
  }

  do
  {
    if ((item[loop].iconflags.data.text) && (item[loop].iconflags.data.indirected) &&
        (!item[loop].iconflags.data.sprite) && (!item[loop].menuflags.data.writable))
    {
      /* Indirected, text-only item */
      free(item[loop].icondata.indirecttext.buffer);
      item[loop].icondata.indirecttext.buffer = NULL;
    }

    if (item[loop].submenu.value == -1) continue;
    if ((item[loop].submenu.value >= 0x8000) && (all == 1))
    {
      /* Submenu pointer */
      Menu_Dispose(item[loop].submenu.menu, Desk_TRUE);
      item[loop].submenu.value = -1;
    }
    loop++;
  } while (!item[loop-1].menuflags.data.last);

  free(menu);
}

extern void Event_Poll(void)
{
  if (event_polldelay >= 0)
  {
      Desk_Event_mask.data.null = 0;    /* force null events on */
  }
  if (event_polldelay <= 0)
  {
      Desk_Wimp_Poll3 (Desk_Event_mask, &Desk_Event_lastevent, &pollword);
  }
  else
  {
      Desk_Wimp_PollIdle3 (Desk_Event_mask, &Desk_Event_lastevent, Desk_Time_Monotonic()+event_polldelay, &pollword);
  }
  Desk_Event_Process (&Desk_Event_lastevent);
}
