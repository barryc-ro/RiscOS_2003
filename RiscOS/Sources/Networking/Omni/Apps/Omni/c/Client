/*
 * Program:	Client.c - core application routines
 *
 * Project:	!Omni OmniClient(tm) project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@ant.co.uk
 *
 * Date:	24 August 1994
 * Last Edited:	23 October 1994
 *
 * Copyright 1994 by ANT Limited
 */

#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <Desk/ColourTran.h>
#include <Desk/Msgs.h>
#include <Desk/Resource.h>
#include <Desk/Screen.h>
#include <Desk/Str.h>

#include <DebugLib/DebugLib.h>

#include "Client.h"
#include "Core.h"
#include "ExtLib.h"
#include "Filer.h"
#include "Heap.h"
#include "MakeError.h"

/*  Register a new Client protocol.
 */
extern client_record *ClientCreate(_kernel_swi_regs *r)
{
  client_record *cr = NULL;

  dprintf (("", "ClientCreate:create new client protocol\n"));
  if (r->r[0] <= 0)
  {
    r->r[0] = (int) MakeError(err_BADPROTOCOL);
    return(NULL);
  }
  if ((cr = ClientFind(r->r[0], NULL, -1, NULL)) != NULL) return(cr);
  cr = (client_record *) rma_alloc(sizeof(client_record));
  if (cr == NULL)
  {
    r->r[0] = (int) MakeError(err_NOMEM_REGISTRATION);
    return(NULL);
  }
  /* Menu_Close(); */
  Desk_LinkList_AddToTail(&client_anchor, &(cr->header));
  cr->client_id = r->r[0];
  cr->flags = r->r[1];
  cr->spritename = cpyrma((char *) r->r[2]);
  cr->clientname = cpyrma((char *) r->r[3]);
  cr->clientdesc = cpyrma((char *) r->r[4]);
  cr->site_id = r->r[5];
  cr->fsname = cpyrma((char *) r->r[6]);
  dprintf (("", "ClientCreate:new client list length %d\n", Desk_LinkList_ListLength(&client_anchor)));
  return(cr);
}


/*  Delete an Client protocol entry.
 */
extern void ClientDelete(client_record *cr)
{
  dprintf (("", "ClientDelete:\n"));

  if (cr == NULL) return;
  if (cr->client_id != -1)
  {
    /* Close any active protocol mounts ? */
  }
  if (taskhandle > 0)
  {
    Menu_Close();
    Desk_menu_currentopen = NULL;
  }
  Desk_LinkList_Unlink(&client_anchor, &(cr->header));
  RMAFREE(cr);
  dprintf (("", "ClientDelete:new clients list length %d\n", Desk_LinkList_ListLength(&client_anchor)));
}


/*  Return number of items in Client linked list.
 */
extern int ClientCount(void)
{
  client_record *cr = (client_record *) client_anchor.next;
  int count = 0;

  while (cr != NULL)
  {
    count++;
    cr = (client_record *) cr->header.next;
  }
  return(count);
}


/*  Find item in linked list from either client_id (name=NULL) or name.
 *  OR from menuitem (if menuitem != -1)
 */
extern client_record *ClientFind(int client_id, char *name, int menuitem, char *fsname)
{
  client_record *cr = (client_record *) client_anchor.next;
  int loop = 0;
  int searchtype = 0;

  dprintf (("", "ClientFind:\n"));
  if (name != NULL) searchtype = 1;
  if (menuitem != -1) searchtype = 2;
  if (fsname != NULL) searchtype = 3;
  while (cr != NULL)
  {
    dprintf (("", "ClientFind: %x\n", (int) cr));
    if (searchtype == 2 && flagSET(cr, flag_SPECIAL))
    {
      cr = (client_record *) cr->header.next;
      continue;
    }
    switch (searchtype)
    {
      case 0: if (cr->client_id == client_id) return(cr);
              break;
      case 1: if (!Desk_stricmp(cr->clientname, name)) return(cr);
              break;
      case 2: dprintf (("", "ClientFind: %d %d\n", menuitem, loop));
	      if (menuitem == loop) return(cr);
	      break;
      case 3: dprintf (("", "ClientFind: %s %s\n", cr->fsname, fsname));
              if (!Desk_stricmp(cr->fsname, fsname)) return(cr);
              break;
      default:
        break;
    }
    loop++;
    cr = (client_record *) cr->header.next;
  }
  return(NULL);
}


/*  Build a menu list of currently registered clients.
 *  Returns NULL if no clients registered.
 */
static char *ClientList(bool dboxes)
{
  static char menu[512];
  client_record *r = (client_record *) client_anchor.next;
  char buf[128];
  char *p;

  /* Initialise menu */
  if (r == NULL) return(NULL);

  /* Build list of client names */
  strcpy(menu, "");
  while (r != NULL)
  {
    if (flagSET(r, flag_SPECIAL))
    {
      r = (client_record *) r->header.next;
      continue;
    }
    if (dboxes) sprintf(buf, ">%s, ", r->clientname);
      else sprintf(buf, "%s%s, ", flagSET(r, flag_FS) ? "" : "~", r->clientname);
    strcat(menu, buf);
    r = (client_record *) r->header.next;
  }
  p = strrchr(menu, ',');
  if (p && !strcmp(p, ", ")) *p = '\0';
  dprintf (("", "ClientList: %s\n", menu));
  return((char *) &menu[0]);
}


/*  Build a menu of currently registered clients.
 */
extern Desk_menu_ptr ClientMakeMenu(Desk_menu_ptr oldmenu)
{
  char *menu = ClientList(Desk_FALSE);
  char tmp[32];
  char txt[32];

  /* Initialise menu */
  if (oldmenu != NULL) Menu_Dispose(oldmenu);
  /* Create menu */
  Desk_Msgs_Lookup("mhdr.icon_mo", tmp, 31);
  Desk_Msgs_Lookup("menu.icon_mo", txt, 31);
  if (menu == NULL) return(Desk_Menu_New(tmp, txt));
    else return(Desk_Menu_New(tmp, menu));
}


/*  Build an info menu of currently registered clients.
 */
extern Desk_menu_ptr ClientMakeInfoMenu(Desk_menu_ptr oldmenu)
{
  char icon[32];
  char tmp[32];
  char menu[512];
  char *m = ClientList(Desk_TRUE);

  /* Initialise menu */
  if (oldmenu != NULL) Menu_Dispose(oldmenu);
  /* Create menu */
  if (m == NULL) return(NULL);
  Desk_Msgs_Lookup("menu.icon_i", icon, 31);
  Desk_Msgs_Lookup("mhdr.icon_i", tmp, 31);
  sprintf(menu, "%s|%s", icon, m);
  dprintf (("", menu));
  return(Desk_Menu_New(tmp, menu));
}
