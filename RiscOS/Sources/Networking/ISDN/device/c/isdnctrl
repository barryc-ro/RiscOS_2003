/*	ISDNctrl Routines
	-----------------

These routines handle commands sent to ISDNctrl and pass status and
error messages back to ISDNctrl.

Fri 18th April 1997
Spaces allowed in dial string.
Give error if invalid service code is used in ATDn::s or AT&Os command.
Give error if attempt to dial when already connected
Do nothing if attempt to hang up when not connected
Removed "ERROR " from each error message and just put single one in error routine.
Implemented A answer command

Wed 23rd April 1997
Added flag to use ISDNdata for AT type commands (so we can use standard ART dialler)
Status messages (CONNECT, CLEAR etc) are printed to the screen if the ISDNctrl
stream is not open. This aids testing when usng *ISDNdial command.

Tue 29th April 1997
Spaces are now allowed within AT command string (ie between commands).

Thu 22nd May 1997
Added support for @56 in dial string (must be after :: parameter).

Moved error message strings to single #define block.

Call callback_handler directly in dial command to ensure that 
configuration messages are all processed before we send a dial message.

Made ATS command more general to allow for additional S registers.

Dial function sends configurations if called directly, so *ISDNdial may
now be used without using ATZ to set configuration.

Auto register S0 to control auto-answering (auto answer if it is non-zero).

Leading T or D in dial string is ignored (ie ATTD ATPD ATDT ATPD will all be
treated as ATD now). Note that the T or P can be given as a separate command
or as part of the dial string when using a modem.

Fixed problem with multiple ATZ commands causing problem (Omnitel don't
like configurations being changed, so we only set them once - expect Omnitel
to fix this later).

Fri 30th May 1997
CLEAR message only generated once when clear is from remote system. If we
are clearing the call we just get an ACU_CLEAR_CO, but if the remote
system cleared the call we generate the CLEAR on the ACU_CLEAR_IN and not
on the ACU_CLEAR_CO. 

Thu 19th June 1997
RING message is followed by extra parameters indicating CALLED_NUMBER and
CALLED_SUBADDRESS if they are available (eg 1234*10) and also the
service that should be used (PPP or V120) if it can be identified from the
number or the sub-address. If not no service is shown and the application
can set the service using AT&O before answering the call.

Loopback commands send configurations before performing the test.

Fri 20th June 1997
Changed flag to control when CLEAR messages are displayed. Now display CLEAR
correctly if dial attempt fails.

Mon 23rd June 1997  v1.01
Modified autoanswer code: if either local_number_ppp or local_number_v120
configuration is set then we only answer incoming calls where the called
number field matches our configuration or is blank (ie if no MSN called
number information is sent to us from the network we still answer the call).
Similarly if either local_subaddress_ppp or local_subaddress_v120 is set
then we only answer calls that matches one of the configuirations or where
no subaddress field is specified.

Tue 24th June 1997  v1.02
Fixed problem whereby we failed to respond to CLEAR from network if it was
received before a call was established. ie Network sends SETUP message, we
respond with ALER and network then sends DISCONNECT (clear). We should then
respond with a CLEAR_RS but we failed to as we had not established a service
type (V120 or PPP) and the clear_rs code failed to include a default case in
the switch. This change is made in appli.c

Tue 15th July 1997  v1.03a
If s0=-1 then we ignore incoming calls completely and don't generate RING message
or send ALERTING back to network.

Tue 22nd July 1997 v1.04
Allow multiple instances of T, t, P or p at start of dial string
(Caradon bug caused it to use ATDTT which failed with ISDN - fixed in Caradon too).

Mon 04th August 1997
CLEAR codes displayed in decimal instead of hex

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>

#include "kernel.h"
#include "swis.h"
#include "testmode.h"
#include "services.h"


/* OMNITEL includes files */

#if TEST
#define uchar char
#define FAR
#define BUFFER_DATA_LGTH 256
#else

#define SERVICES_INIT
#include "conf_srv.h"
#include "cc_int.h"
#include "acu_int.h"
#include "vs_int.h"
#include "ap_par.h"
#include "ph_int.h"
#include "ap_par.h"
#include "consts.h"		/* DEFAULT_PRIORITY_PPP and DEFAULT_PRIORITY_V120 */ 

#endif

/* Our include files: */

#include "device.h"
#include "handler.h"
#include "isdnctrl.h"
#include "driver.h"
#include "dd_int.h"

extern int isdn_callback_handler(_kernel_swi_regs *, void *);

/*	Global Variables
	----------------

*/

isdnctrl_configs configuration;			/* Structure to hold all configurations */
static int isdnctrl_echo=ISDNCTRL_ECHO_DEFAULT;	/* Local echo of ISDNctrl commands (controlled by ATE command) */
#if ISDNCTRL_LOG
static char ISDNlog[ISDNCTRL_LOGSIZE];		/* Log of ISCNctrl commands and responses for debugging */
static int ISDNlog_chars=0;			/* Characters in ISDN log */
#endif
int isdnctrl_autoanswer=AUTOANSWER_NORING;	/* Auto answer flag - corresponds to register S0. Default is
						   to never ring */
static int default_service=DTE_CHANNEL_V120;	/* Service type, default is V120 */
static int incoming_service=DTE_CHANNEL_V120;	/* Incoming service */

/*	ISDN State
	----------

We have three states: offline, dialling and connected.
This flag is used to decide when to display CLEAR messages. We only display a clear if
we are connected or dialling. If we are already offline we assume that it is a second
clear which can be safely ignored (if the remote system disconnects we receive two clear
messages - one for the remote disconnect and one for our own disconnect but we only show the
first one).
*/

#define STATE_OFFLINE	0		/* Default state, off-line */
#define STATE_DIALLING	1		/* Dialling state */
#define STATE_CONNECTED	2		/* ISDN connection established with remote system (but data
					   transfer may still not be possible */
static int isdn_state=STATE_OFFLINE;	/*  Note that this is not the same
					    as the isdn_active flag which is only set when we have a data
					    connection (ie if we dial using V120 we generate a CONNECT
					    before the V120 link is established */


#define MAX_DIAL_TIME 	50		/* Disconnect after 50s */

static int dialling_timer=0;		/* Time how long our dial operation has been ringing */


void isdnctrl_msg(char *, ...);  /* Prototype */

/*	Error Messages
	--------------

*/

#define SUPPRESS_OK	-1			/* Some commands suppress the OK message without giving error */
#define ERR_RATE	"Rate must be @56 or @64"
#define ERR_DIALBAD	"Bad dial string"	/* Too long, or not given at all */
#define ERR_BADSERVICE	"Bad service"
#define ERR_ALREADYCONN "Already connected (or dialling)"
#define ERR_DIALFAIL	"Dial failed"
#define ERR_HOOKFAIL	"Hook failed"
#define ERR_LOOPFAIL	"Loopback failed"
#define ERR_BADVAL	"Bad value"
#define ERR_BADREG	"Bad S register"
#define ERR_BADINT	"Interface must be S or U"
#define ERR_BADOP	"Operator not known"
#define ERR_BADCONF	"Configuration not recognized"
#define ERR_BADCMD	"Bad command"
#define ERR_CMDLONG	"Command too long"
#define ERR_LOOPBACK    "Loopback test failed"


/*	Display ISDNlog
	---------------

Print ISDN log to the screen.
*/

void isdnctrl_showlog(void)
{
  int i;
  
  for (i=0; i<ISDNlog_chars; i++)
    putchar(ISDNlog[i]);
}

/*	Write String to Log
	-------------------

If we fill the ISDnlog buffer then we flush it and start again from 
the beginning (this is unlikely to happen and we only need this as
a trivial debugging aid - we could wrap round if necessary and keep
buffer start and end pointers).
*/

#if ISDNCTRL_LOG

static void isdnctrl_log(char *s)
{
  int len;
  
  len=strlen(s);
  if (len>ISDNCTRL_LOGSIZE) len=ISDNCTRL_LOGSIZE;	/* Limit string to buffer size */
  if (ISDNlog_chars+len+1>=ISDNCTRL_LOGSIZE)
    ISDNlog_chars=0;
  strncpy(ISDNlog+ISDNlog_chars, s, len);		/* Copy string to our log buffer */
  ISDNlog_chars+=len;					/* Update log counter */
}

#endif


/*	External User Function to Send to Appli
	---------------------------------------

This function is used to build and send messages to the application entity.
*/
#if 0
extern void user_build_and_send_to_appli (uchar sapi, uchar code, int argc, char **argv);
#endif

/*	ACU - Automatic Calling Unit Messages
	-------------------------------------
	
The Omnitel Call Control (CC) entity provides two Service Access Points (SAPs):

ACU SAPI provides comprehensive control.
CC SAPI provides simple control for data and voice calls.

We use the ACU SAPI here and translate Hayes AT type commands into 
ACU messages. For each action we create a message buffer and use it 
to send a message to the APPLI (application) entity. 

The Appli entity understands various messages for call management, including:
	
	ACU_CONN_RQ	Connection request (dial)
	ACU_CONN_RS	Connection response (answer an incoming call)
	ACU_CLEAR_RQ	Clear the call 
	ACU_CLEAR_RS	Clear response (response to network clearing call)

For each command (message) we use prepare_message to create the message
buffer and initialise the message header. We then add the information
specific to each command and use Send_message to send the message to 
the application entity.

Note that we don't receive an immediate acknowledgment. Subsequent messages
from the ACU will indicate the progress and success or failure of the command
and we will pass these on to ISDNctrl as we receive them. As with Hayes AT
commands, we respond with an "OK" if the command has been successfully 
initiated, but that does not indicate that the command itself has been successful.

Take great care when modifying these functions. They all use macros to
access specific fields in the message and the macrocs rely on specific
variables existing (p_buffer, p_snd_msg etc).

See Omnitel Interface Guide (June 95), page 20 for ACU details.

*/

/*	Prepare to Send Message
	-----------------------
	
Prepare a message and fill in main fields.
Returns 0 if successful or non-zero if message buffers couldn't be allocated.

Note that we must use the parameter names p_snd_msg and p_buffer as the
macros rely on them being defined.
*/

#if !TEST
static int prepare_message(struct message FAR **pp_snd_msg, struct buffer FAR **pp_buffer)
{
struct message FAR *p_snd_msg;	/* Note that we must use these paramter names here as they are used in macros */
struct buffer FAR *p_buffer;
  p_snd_msg	= Alloc_msg ();
  if (p_snd_msg)
  {
    p_buffer	= Alloc_buffer ();
    if (p_buffer)
    {
      S_msg_from	= ENT_USER;	/* dummy origin entity to force OS sending */
      S_msg_to		= ENT_APPLI;	/* Local version of User entity : send the message to the Appli itself */
      S_msg_nai 	= USER_NAI;
      S_msg_conn_id 	= USER_CONN_ID;
      
      S_msg_init_link_buffer;		/* Link p_buffer to p_snd_msg */

      *pp_snd_msg=p_snd_msg;		/* Return pointers to allocated space */
      *pp_buffer=p_buffer;		
      
      return 0;
    }
    else
      Free_msg(p_snd_msg);	/* Failed to allocate p_buffer, so free the unused msg buffer */
  }
  return 1;
}
#endif

/*	Service Codes
	-------------
	
AT D command uses service codes in the range 1 to 18, to match those provided
by the Omnitel WANTA-1 Terminal Adapter. We need to translate these codes
here to match the ACU codes.

For example, the WANTA-1 DTE channel 10 is translated to ACU_V120_SERVICE.

ACU services are defined in isdn.sources.cc.h.acu_int and DTE services are defined in


Returns -1 if invalid service number used.
*/

int servicecode(int service)
{
  int code=-1;
  
#if !TEST

  switch (service)
  {
    case DTE_CHANNEL_V120 :	/*  Mono-link V.120 service : Dte channel 10 */
      code= ACU_V120_SERVICE;
      break;
    
    case DTE_CHANNEL_PPP :     /* Mono-link PPP service : Dte channel 7 */
      code = ACU_DATA_SERVICE;
      break;

    case DTE_CHANNEL_ML_PPP_SYN :  /* Multi-link Synch. PPP service : Dte channel 27 */
      code = USER_PROFILE_MPPP_SYNC;
      break;

    case DTE_CHANNEL_ML_PPP_ASYN : /* Multi-link Asynch. PPP service : Dte channel 28 */
      code = USER_PROFILE_MPPP_ASYNC;
      break;
      
#if 0
/* Debug experiment - crashes when used */
    case 56 :	/* 56k bits per second */
      code= ACU_DATA_56KBS_SERVICE;
      break;
#endif
  }

#endif
  return code;
}

/*	Check Service Code is Valid
	---------------------------
	
Service code may be specified in AT&O command or in ATD::s command.
checkservice uses servicecode() to check that the service number is
valid and returns NULL if it is or a pointer to an error string otherwise.
*/

char *checkservice(int service)
{
  char *err=NULL;
  
  if (servicecode(service)<0) err=ERR_BADSERVICE;
  return err;
}

/*	Send Omnitel Configuration
	--------------------------

Send configuration if it hasn't already been sent and flag that
we have sent it. It is important that we don't attempt to send the 
configuration more than once in this version as Omnitel do
not support it but we hope to resolve it late. 

Notes
-----
If the dial function is called without a preceeding ATZ command it is an
Omnitel requirement that the configuration settings must be sent before the
dial is started. We use the omnitel_config function to set the configurations
and then call the callback routine directly to ensure that the configuration
message (and any subsequent messages that it causes) are all executed before
the dial message. If we do not do this the dial message may be executed before
the configuration message and this can cause a serious failure.

It would be better to pass the configurations on to the Omnitel system as
soon as we receive an AT# command, but we don't do this as their current
software (22 May 97) cannot cope with subsequent configuration changes and it
needs all the configuration data before it initialises itself. However we
would still need to call the callback handler directly to ensure that the
configurations messages have all been processed before sending the dial
command (since both commands may occur on the same line, or in the same block
of text that isdnctrl receives).

There is a potential problem calling the callback handler directly. If we
were called from within an interrupt routine (ie if an interrupt handler
wrote an ATD or ATZ command to the ISDNctrl system) then we will still be in
interrupt mode and the Omnitel message handler is not guaranteed to be
re-entrant. In practice it is extremely unlikely that this will ever happen.
A multi-tasking dialler might issue a dial command within a callback, but not
within an interrupt routine.

*/

static void send_config(void)
{
  if (!configuration.sent)		/* Don't set configuration if already set */
    omnitel_config(&configuration);
  configuration.sent=TRUE;		/* Flag configuration has been sent */
  isdn_callback_handler(NULL, NULL);	/* Run callback handler to ensure all configuration messages
       					   are processed before we dial */
}


/*	Dial Number
	-----------

Execute a D (dial) command using specified service code ("2" for a V120 connection etc).

Returns NULL if dial has started succesfully or a pointer to error string if
it fails (ie we are already connected, or if dial command fails for some other
reason). Note that this function returns immediately and messages indicate
the success or failure of the dial operation will be sent to isdnctrl later.

On entry:	called_number		points to the number to dial
		calling_number		points to our calling number
		calling_subaddress	points to our calling sub-address
		service			contains the service code used
					(specified after :: in dial string or using ATO)
		rate			0 for default 64k rate or ACU_RA_56000 for 56k rate


*/

static char *cmd_dial(char *called_number, char *calling_number, char *calling_subaddress, char service, int rate)
{
  char *err=NULL;			/* Error string */

#if !TEST
  struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
  struct buffer FAR *p_buffer;		/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
  uchar FAR *	p_data;
  int numlen;
  
  send_config();		/* If configuration hasn't already been sent we must send it now */

  if (isdn_state)
    err=ERR_ALREADYCONN;
  else
  {
    dialling_timer=0;		/* Reset timer for dial operation - must be reset before dialling
    				   state is set */
    isdn_state=STATE_DIALLING;	/* Flag that we are dialling (so CLEAR messages will be generated */
  
    if (!prepare_message(&p_snd_msg, &p_buffer))	/* Prepare message (returns 0 if successful) */
    {
      S_msg_code 	= ACU_CONN_RQ;
  
      /* Build the primitive */
      p_data = Buffer_a_first_data;	/* Get data area starting address inside the buffer */
  
      /* Specific action follows */
  
      Memset_far((char FAR *) p_data, 0, Acu_conn_rq_size);
      
      Acu_conn_rq_service = servicecode(service);
      S_msg_sapi 	= USER_ACU_SAPI;		/* Always use same SAPI for all services now (was different in the past) */	
     
#if 0  

/* This code was made obsolete by the 56k fix */
      switch (Acu_conn_rq_service)
      {
        case ACU_DATA_SERVICE:
          break;
      		
        case ACU_V120_SERVICE:
          Acu_conn_rq_user_rate	= ACU_RA_19200;
          Acu_conn_rq_syn_asyn	= ACU_ASYN;
          Acu_conn_rq_stop_bits	= ACU_STOP_BIT_1;
          Acu_conn_rq_data_bits	= ACU_DATA_BIT_8;
          Acu_conn_rq_parity	= ACU_NO_PARITY; 
          break;
      			
         default:
           break;    	  
      } 
#endif
  
      Acu_conn_rq_ph_rate	= rate;			/* rate is 0 for default 64k or ACU_RA_56000 */

      Acu_conn_rq_data_chani_nb	= 0;
      Acu_conn_rq_data_chani	= 0;
  
      Acu_conn_rq_charging_rq	= OFF;
      Acu_conn_rq_transfer_rq	= OFF;
      Acu_conn_rq_identification_denied_rq	= OFF;
  
      Acu_conn_rq_ph_num_size	= Strcpy_far ((char FAR *)Acu_conn_rq_a_ph_num, (char FAR *)called_number,  ACU_MX_SZ_CALLED_NB)  - 1;
      Acu_conn_rq_called_nb_type  = ACU_NB_TYPE_UNKNOWN;

      /* Copy calling number field */                                                                                        
      numlen			=  Strcpy_far ((char FAR *)Acu_conn_rq_a_calling_nb, (char FAR *)calling_number,  ACU_MX_SZ_CALLING_NB)  - 1;
      /* Append calling sub-address field */
      Acu_conn_rq_a_calling_nb[numlen++]='*';	/* Separator after number before sub-address */
      Acu_conn_rq_a_calling_nb[numlen]='\0';
      Acu_conn_rq_calling_nb_size= numlen+
                                   Strcpy_far ((char FAR *)Acu_conn_rq_a_calling_nb+numlen, (char FAR *)calling_subaddress,  ACU_MX_SZ_CALLING_NB-numlen)  - 1;


      Acu_conn_rq_uui_size	= 0;
      Acu_conn_rq_facility_size	= 0;
  
      Buffer_data_size =  Acu_conn_rq_size + Acu_conn_rq_ph_num_size+1 + Acu_conn_rq_calling_nb_size+1 + Acu_conn_rq_uui_size+1+ Acu_conn_rq_facility_size+1;
  
      /* Send the message */
      Send_message (p_snd_msg); p_snd_msg = P_NIL;
    }
    else
    {
      err=ERR_DIALFAIL;
    }
  }
#endif
  return err;
}

/*	Clear Call
	----------

Execute a H0 (hook) command.
Send a message to clear the call or do nothing if we are not connected.

*/

char *cmd_hook(void)
{
  char *err=NULL;			/* Error string */

#if !TEST
  struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
  struct buffer FAR *p_buffer;		/*   we don't corrupt the global one */
  uchar FAR *p_data;

  if (isdn_state==STATE_OFFLINE)		/* Do nothing if we are off-line*/
    return err;

  if (!prepare_message(&p_snd_msg, &p_buffer))	/* Prepare message (returns 0 if successful) */
  {
    S_msg_code 	= ACU_CLEAR_RQ;
    S_msg_sapi 	= USER_ACU_SAPI;		/* ACU clear request */

    /* Build the primitive */
    p_data = Buffer_a_first_data;	/* Get data area starting address inside the buffer */

    Memset_far((char FAR *)p_data, 0, Acu_clear_rq_size);

    Acu_clear_rq_cause	    = 0;	/* 0 defaults to "Normal Clearing" (16) cause value */
    Acu_clear_rq_uui_size   = 0;
    Acu_clear_rq_facility_size = 0;
    Buffer_data_size =  Acu_clear_rq_size + Acu_clear_rq_uui_size+1 + Acu_clear_rq_facility_size+1;

    /* Send the message */
    Send_message (p_snd_msg); p_snd_msg = P_NIL;
  }
  else
    err=ERR_HOOKFAIL;
#endif

  return err;
}


/*	Answer Incoming Call
	--------------------

Execute an A (answer) command.

*/

static char *cmd_answer(int servicecode)
{
  char *err=NULL;			/* Error string */

#if !TEST
  struct message FAR *p_snd_msg;	/* local pointer to the message and */
  struct buffer FAR *p_buffer;		/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
  uchar FAR *	p_data;

  send_config();			/* Ensure configurations have been sent before answering */
  if (isdn_state)			/* Can't answer call if already connected or dialling */
    err=ERR_ALREADYCONN;		/*  as we only have one call context and one data stream */
  else if (!prepare_message(&p_snd_msg, &p_buffer))	/* Prepare message (returns 0 if successful) */
  {
    S_msg_code 	= ACU_CONN_RS;
    S_msg_sapi 	= USER_ACU_SAPI;		/* ACU connect response */

    /* Build the primitive */
    p_data = Buffer_a_first_data;	/* Get data area starting address inside the buffer */

    /* Specific action follows */


    Memset_far((char FAR *)p_data, 0, Acu_conn_rs_size);

    Acu_conn_rs_service       = servicecode;
    Acu_conn_rs_uui_size      = 0;
    Acu_conn_rs_facility_size = 0;
    
    Buffer_data_size = Acu_conn_rs_size + Acu_conn_rs_uui_size+1 + Acu_conn_rs_facility_size+1;

    /* Send the message */
    Send_message (p_snd_msg); p_snd_msg = P_NIL;
  }
#endif
  return err;
}

#if 0
/*	Respond to Clear
	----------------

Respond to a clear message from the network.
We don't need to do this explicitly as it is handled
in appli.c
*/

static char *cmd_clearresponse(void)
{
  char *err=NULL;			/* Error string */

#if !TEST

  struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
  struct buffer FAR *p_buffer;		/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
  uchar FAR *	p_data;

  if (!prepare_message(&p_snd_msg, &p_buffer))	/* Prepare message (returns 0 if successful) */
  {
    S_msg_code 	= ACU_CLEAR_RS;			/* ACU connect request */
    S_msg_sapi 	= USER_ACU_SAPI;	

    /* Build the primitive */
    p_data = Buffer_a_first_data;	/* Get data area starting address inside the buffer */

    /* Specific action follows */
    
    Memset_far((char FAR *)p_data, 0, Acu_clear_rs_size);

    Acu_clear_rs_uui_size	   = 0;

    Acu_clear_rs_facility_size = 0;

    Buffer_data_size = Acu_clear_rs_size + Acu_clear_rs_uui_size+1 + Acu_clear_rs_facility_size+1;

    /* Send the message */
    Send_message (p_snd_msg); p_snd_msg = P_NIL;
  }
#endif
  return err;
}
#endif

/*	Loop B channel
	--------------

Execute an s141 or s142 command to enable loopback testing on first or second B channel respectively.

chan_id is 1 or 2.
*/

char *cmd_loop_b_chan(char chan_id, char activate)
{
  char *err=NULL;			/* Error string */

#if !TEST
  struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
  struct buffer FAR *p_buffer;		/*   we don't corrupt the global one */
  uchar FAR *p_data;

  send_config();			/* Ensure configurations have been sent before answering */


  if (!prepare_message(&p_snd_msg, &p_buffer))	/* Prepare message (returns 0 if successful) */
  {
	S_msg_code 	= ACU_TEST_RQ;          /* Test management primitive */
	S_msg_sapi 	= USER_ACU_SAPI;

	/* Build the primitive */
	p_data = Buffer_a_first_data;	/* Get data area starting address inside the buffer */

	if (activate) {             /* activate or clear loop back */
		Acu_test_action					= ACU_RQ_ACTIVATE;
	} else {
		Acu_test_action					= ACU_RQ_CLEAR;
	}
	Acu_test_b_chan_loop_back_nb	= chan_id ;	/* must be 1 or 2 */

	Acu_test_code  		= ACU_TEST_B_CHAN_LOOP_BACK;
	Buffer_data_size =  Acu_test_size;

	/* Send the message */
	Send_message (p_snd_msg); p_snd_msg = P_NIL;
  }
  else
	err=ERR_LOOPFAIL;
#endif

  return err;
}

/*==========================================================================*/
 

/*	Return Message to ISDNctrl
	--------------------------

Error messages and status reports are sent to the dialler via ISDNctrl.

isdnctrl_msg can be used like printf with %d, %c, %s sequences etc.
\r\n is appended to the string (CR and LF).

Resulting string *MUST* fit in string array of MAXCTRLMSG characters.

Does nothing if ISDNctrl stream is not open.
*/

void isdnctrl_msg(char *fmtstring, ...)
{
  va_list args;
  int bytes, sent;
  char buffer[MAXCTRLMSG];
  int cmdstream;

  va_start(args, fmtstring);
  vsprintf(buffer, fmtstring, args);
  va_end(args);

  bytes=strlen(buffer);
  if (streams[ISDNDATARX].open && streams[ISDNDATARX].special[ISDNDATA_CTRLFIELD]==0) 
    cmdstream=ISDNDATARX;	/* Use ISDNdata device for AT commands */
  else
    cmdstream=ISDNCTRLRX; 	/* Use ISDNctrl device for AT commands */

#if ISDNCTRL_LOG
  isdnctrl_log(buffer);		/* Record string in ISDNctrl log */
#endif
  if (streams[cmdstream].open)
    sent=Buffer_InsertBlock(&bufferman_call, streams[cmdstream].bufferman_id, (uchar *) buffer, &bytes);
  else
    printf(buffer);  /* ISDNctrl stream is not open so print response to screen (for *ISDNdial etc) */
}

void isdnctrl_newline()
{
  isdnctrl_msg("\r\n");
}

/*	Parse String Parameter
	----------------------

On entry:	p points to string parameter in command line string.
		s points to buffer of length MAXLEN
		
On exit: 	returns 0 if successful or non-zero if string is too long.
		string parameter is copied to s 
		p is advanced to point at first non-numeric character

The string parameter may be inside quotes (in which case the quotes will not be
included in the returned string). If no quotes are used the rest of the line is
regarded as the parameter.

*/

static int param_string(char **p, char *s, int MAXLEN)
{
  int i;
  int quoted;

  if ((quoted=(**p=='\"')), quoted) (*p)++;
  
  /* Scan string while we reach the terminator which is \0 or if we are inside quotes, a terminating quote */
  for (i=0; !(**p=='\0' || (quoted && **p=='\"')); i++, (*p)++)
    if (i<MAXLEN) s[i]=**p;
  if (quoted) (*p)++;

  if (i<MAXLEN) s[i]='\0';
  return i>=MAXLEN;
}


/*	Parse Numeric Parameter: Return Decimal Number
	----------------------------------------------

On entry p points to parameter in command line string.
On exit: p is advanced to point at first non-numeric character
Returns value of integer read, or default if no number found.
*/

static int param_number(char **p, int def)
{
  int value=0;
  int usedefault=1;

  while (isdigit(**p))
  {
    value=value*10+ **p - '0';
    (*p)++;
    usedefault=0;
  }

  if (usedefault)
    return def;
  else
    return value;
}

/*	Parse Numeric Parameter: Return String
	--------------------------------------

On entry:	p points to dial string parameter in command line string.
		s points to buffer of length MAXLEN
		
On exit: 	returns 0 if successful or non-zero if numeric string is null or too long.
		number string is copied to s 
		p is advanced to point at first non-numeric character

The dial will comprise digits 0-9.
If any other characters are found they will be regarded as terminating
characters and not included in the dial string.


*/

static int param_numberstring(char **p, char *s, int MAXLEN)
{
  int i;

  for (i=0; isdigit(**p); i++, (*p)++)
    if (i<MAXLEN) s[i]=**p;

  if (i<MAXLEN) s[i]='\0';
  return i==0 || i>=MAXLEN;
}


/*	Parse Dial String Parameter
	---------------------------

On entry:	p points to dial string parameter in command line string.
		s points to buffer of length MAXLEN
		
On exit: 	returns 0 if successful or non-zero if numeric string is null or too long.
		dial string is copied to s 
		p is advanced to point at first non-numeric character


Parse the dial string and return it in a buffer suitable for passing to 
the Omnitel cc entity. Note that the cc entity handles * and & but not ::
or @ parameters.

The dial will comprise digits 0-9, spaces, and optionally one * and one &
character (used for specifying sub-address and second number respetively).
A leading T or P character will be ignored (these are often used in modem
dial strings to indicate Tone or Pulse dialling).

Note that the dial string must not contain commas or # 
(although these characters may occur in modem dial strings).

If any other characters are found, or if a second * or a second & is found
they will be regarded as terminating characters and not included in the dial
string. It is up to the caller to process subsequent parameters ("@56" or 
"::service").

*/

static int param_dialstring(char **p, char *s, int MAXLEN)
{
  int i;
  int foundstar=FALSE;	/* Flag whether we have found a * yet */
  int foundamp=FALSE;	/* Flag whether we have found an & yet */
  
  if (toupper(**p)=='P' || toupper(**p)=='T')
    (*p)++;		/* Skip leading P or T in dial string (indicate Tone or Pulse dialling on modems) */
  
  for (i=0; isdigit(**p) || **p==' ' || (!foundamp && (foundamp=(**p=='&'))==TRUE) || (!foundstar && (foundstar=(**p=='*'))==TRUE); i++, (*p)++ )
    if (i<MAXLEN) s[i]=**p;

  if (i<MAXLEN) s[i]='\0';
  return i==0 || i>=MAXLEN;
}


/*	Parse Token in Command String
	-----------------------------
	
On entry:	*p points into command string
		token points at token string

On exit:	Returns TRUE and advances *p over the token if the token string exactly 
		matches then next few characters in the	command string otherwise returns FALSE
		
Comparison is case-insensitive.		
*/

static int token(char **cmd, char *token)
{
  char *p;
  
  p=*cmd;
  while (toupper(*p)==toupper(*token) && *p!='\0')	/* Case insensitive comparison */
    p++, token++;
    
  if (*token=='\0')			/* Match found if first different character is \0 in token string */
  {
    *cmd=p;				/* Update command pointer over the token */
    return TRUE;
  }
  return FALSE;
}


/*	Test For Number or Subaddress Match
	-----------------------------------

On entry:	Called number and subaddress given in incoming:

			number*subaddress
			
		eg	123456*10	Number and sub-address
			123456		Just number
			*10		Just sub-address
			
On exit:	Returns TRUE if we should respond to call.

We answer the call if number_matches and subaddress_matches.

number_matches if both of our LOCAL_NUMBER configs are empty or called
number is empty or if the called number is the same as either LOCAL_NUMBER
configuration.

Similarly, subaddress_matches if both of our LOCAL_SUBADDRESS configs are 
empty or the called sub-address is empty or if the called sub-address is
the same as either LOCAL_SUBADDRESS configuration.

Note that we will always generate RING and ALERT if the called number
and called sub-address are empty, or if the configurations are all empty.
*/

int call_matches(char *incoming)
{
  int number_matches, subaddress_matches;
  char *incoming_sub;	/* Pointer to sub-address in incoming number */
  int number_len;	/* Length of incoming number field (excluding *subaddr part)  */
  char incoming_number[ISDNCTRL_MAX_NUMBER+1];
  int i=0;
  

  incoming_sub=strstr(incoming, "*");	/* Point to * in number/sub-address string */
  if (incoming_sub)			/* Set length of main number */
    number_len=incoming_sub-incoming;	/* Length up to * if present */
  else
    number_len=strlen(incoming);	/* Length of whole string if no * */

  if (number_len<ISDNCTRL_MAX_NUMBER)	/* If number is correct size copy it to our buffer */
    for (i=0; i<number_len; i++)
      incoming_number[i]=incoming[i];
    incoming_number[i]='\0';

  isdnctrl_msg("Number: %s", incoming_number);
  if (incoming_sub) isdnctrl_msg("sub: %s", incoming_sub); 
  isdnctrl_newline();
  
  /* Always match number if both of our local number configs are empty or incoming number field is empty
    (or just contains a sub-address) */
  if ( (*configuration.local_number_ppp=='\0' 
       && *configuration.local_number_v120=='\0'
       && *configuration.local_number_mppp_syn=='\0'
       && *configuration.local_number_mppp_asyn=='\0'
     ) || number_len==0)
    number_matches=TRUE;
  else
     number_matches= (  strcmp( (char *) configuration.local_number_ppp, incoming)==0
       		    || strcmp( (char *) configuration.local_number_v120, incoming)==0
       		     || strcmp( (char *) configuration.local_number_mppp_syn, incoming)==0
       		     || strcmp( (char *) configuration.local_number_mppp_asyn, incoming)==0
       		     );

  /* Always match sub-address if no sub-address was received or if eiher of our sub-address fields is empty */
  if ((*configuration.local_subaddress_ppp=='\0' && *configuration.local_subaddress_v120=='\0') || incoming_sub==NULL)
    subaddress_matches=TRUE;
  else
    subaddress_matches= (  strcmp( (char *) configuration.local_subaddress_ppp,  incoming_sub+1)==0
       		        || strcmp( (char *) configuration.local_subaddress_v120, incoming_sub+1)==0
       		        || strcmp( (char *) configuration.local_subaddress_mppp_syn, incoming_sub+1)==0
       		        || strcmp( (char *) configuration.local_subaddress_mppp_asyn, incoming_sub+1)==0
       		         );
                                   
  return number_matches && subaddress_matches;
}


/*	Message from Call Control (CC) Entity
	-------------------------------------

The appli.c file calls this routine when it receives a message from the Omnitel 
Call Control (CC) entity.

       isdnctrl_process_cc_msg(p_rcv_msg, Ap_service)

We decode the message here and generate a suitable message to send
to the ISDNctrl stream (CONNECT, CLEAR etc). We want to decode the message
in

Note that several Omnitel macros are used which expect certain variables
to exist (eg p_rcv_msg). It is important to retain these variable names,
otherwise the macros will not work!

For example:
  #define R_msg_code	X_msg_code (p_rcv_msg)
  #define R_a_data	X_a_data (p_rcv_msg)
  #define X_msg_code(p)	p -> code
 
*/

#if !TEST
void isdnctrl_process_cc_msg(struct message FAR *p_rcv_msg, struct buffer FAR *p_buffer, uchar service)
{
  uchar FAR *p_data;
  static char incoming_called_number[MAX_INCOMING_CALLED_NUMBER+2];

  p_data = R_a_data;	/* Note R_a_data is macro operating on p_rcv_msg */

  switch (R_msg_code)
  {
    case ACU_CONN_IN:	/* Incoming call: ring */
        isdnctrl_msg("RING");

        if (Acu_conn_in_called_nb_size>0)  /* Macro operating on p_data or p_rcv_msg */
        {
          int i;
          
          isdnctrl_msg(" ");
          /* Output each char in number/sub-address string up to max length */
          for (i=0; i<Acu_conn_in_called_nb_size; i++)
            isdnctrl_msg("%c", *(Acu_conn_in_a_called_nb+i));
          if (Acu_conn_in_called_nb_size<MAX_INCOMING_CALLED_NUMBER)
          {
            strncpy(incoming_called_number, Acu_conn_in_a_called_nb, Acu_conn_in_called_nb_size);
            incoming_called_number[Acu_conn_in_called_nb_size]='\0';
          }
          else
            *incoming_called_number='\0';
        }
          
        switch (service)
        {
          case ACU_V120_SERVICE: 
            isdnctrl_msg(", V120");
            incoming_service=DTE_CHANNEL_V120;
            break;
            
          case ACU_DATA_SERVICE:
            isdnctrl_msg(", PPP"); 
            incoming_service=DTE_CHANNEL_PPP;
            break;

          case USER_PROFILE_MPPP_SYNC:
            isdnctrl_msg(", MPPP SYNC"); 
            incoming_service=DTE_CHANNEL_ML_PPP_SYN;
            break;
            
          case USER_PROFILE_MPPP_ASYNC:
            isdnctrl_msg(", MPPP ASYNC"); 
            incoming_service=DTE_CHANNEL_ML_PPP_ASYN;
            break;
            
          default:
            incoming_service=default_service;	/* Can't determine service from called number or sub-address, so use default */
        }
        isdnctrl_newline();
	break;

    case ACU_CONN_CO:	/* Call connected: */
    switch (service) 
    {
      case ACU_DATA_SERVICE :
      case USER_PROFILE_MPPP_SYNC :
      case USER_PROFILE_MPPP_ASYNC :
      /*  Don't generate a message here - isdndata_connected will do that for us
      isdnctrl_msg("ISDN");  
      isdnctrl_newline();
      */
      break;

      case ACU_V120_SERVICE :
      default:
      /* Indicate that we have ISDN connection for V120, but don't generate CONNECT until
         V120 is up and running */
      isdnctrl_msg("ISDN V120");
      isdnctrl_newline();
      break;
    }
    isdn_state=STATE_CONNECTED;
    break;

  /* Handle a CLEAR message:
  
     When the CLEAR is the consequence of a local clearing (ATH), we
     receive an ACU_CLEAR_CO only . When the disconnection comes from the
     network, we receive an ACU_CLEAR_IN message which contains the
     network clearing cause. It is the one we should display
     (Acu_clear_in_network_cause). The application answers by an ACU_CLEAR_RS
     and then we receive an ACU_CLEAR_CO 
     
     We handle this by using an isdnctrl_connected flag which indicates whether we
     last generated a CONNECT or a CLEAR message. It will generally follow the behaviour
     of the isdndata_connected flag but it indicates what messages we have generated so
     it will lag behind slightly.
  */
  
  case ACU_CLEAR_IN:   
  case ACU_CLEAR_CO:
    /* Generate a CLEAR message if we haven't already generated one. If we are clearing
       the call we just get an ACU_CLEAR_CO, but if the remote system cleared the call
       we generate the CLEAR on the ACU_CLEAR_IN and not on the ACU_CLEAR_CO */
    if (isdn_state != STATE_OFFLINE)
    {
      isdnctrl_msg("CLEAR %d", Acu_clear_co_network_cause);
      isdnctrl_newline();
    }
    isdn_state = STATE_OFFLINE;
    break;

  /* Receive call progress indication */
  case ACU_PROGRESS_IN:
    isdnctrl_msg("PROGRESS %c", Acu_progress_in_event);
    isdnctrl_newline();
    break;

  /* Receive alert indication : that's all folks! */
  case ACU_ALERT_IN:
    isdnctrl_msg("ALERT %c", Acu_alert_in_alert);
    isdnctrl_newline();

    if (Acu_alert_in_alert=='R'  && isdnctrl_autoanswer>0)	/* Incoming alert (ringing) */
      cmd_answer(servicecode(incoming_service));	/* Auto answer if register S0 is non-zero */
    break;
  
  case ACU_TEST_CO:
  
    if (Acu_test_action == ACU_CO_ACK) {
	    isdnctrl_msg("OK");
    } else {
	    isdnctrl_msg(ERR_LOOPBACK);  
    } 
    isdnctrl_newline();
    break;
  }
}
#endif


/*	ISDNctrl Timer
	--------------

Timer function called every n cs and used by ISDNctrl to force a hangup
if call is not answered.
*/

void isdnctrl_timer()
{
  if (isdn_state==STATE_DIALLING)
  {
   if (++dialling_timer>MAX_DIAL_TIME*1000/TIMER_SYSTEM_TICK)	/* Timeout when ticks reaches MAX_DIAL_TIME * ticks per second */
    {
      cmd_hook();		/* Force a hang up */
      dialling_timer=0;		/* Reset counter in case timer event occurs again
				   before hang up occurs */
    }
  }
}


/*	List Current Configurations
	---------------------------


List the current configuration settings to the ISDNctrl stream.
This is primarily for debugging.
*/

void config_list()
{
  int channel;
  
  isdnctrl_msg("Configurations:");
  isdnctrl_newline();
  isdnctrl_msg("  INTERFACE:            %c", configuration.interface); isdnctrl_newline();
  isdnctrl_msg("  COUNTRY:              %d", configuration.country);   isdnctrl_newline();
  isdnctrl_msg("  OPERATOR:             %d", configuration.operator);  isdnctrl_newline();
  isdnctrl_msg("  LOCAL_NUMBER_PPP:     %s", configuration.local_number_ppp); isdnctrl_newline();
  isdnctrl_msg("  LOCAL_NUMBER_V120:    %s", configuration.local_number_v120); isdnctrl_newline();
  isdnctrl_msg("  LOCAL_SUBADDRESS_PPP: %s", configuration.local_subaddress_ppp); isdnctrl_newline();
  isdnctrl_msg("  LOCAL_SUBADDRESS_V120:%s", configuration.local_subaddress_v120); isdnctrl_newline();
  /*  PRIORITY configurations are no longer used:
  isdnctrl_msg("  PRIORITY_PPP:         %d", configuration.priority_ppp); isdnctrl_newline();
  isdnctrl_msg("  PRIORITY_V120:        %d", configuration.priority_v120); isdnctrl_newline(); */
    
  for (channel=0; channel<2; channel++)
  {
    isdnctrl_msg("  CALLING_NUMBER%d:      %s", channel+1, configuration.calling_number[channel]);
    isdnctrl_newline();
    isdnctrl_msg("  CALLING_SUBADDRESS%d:  %s", channel+1, configuration.calling_subaddress[channel]);
    isdnctrl_newline();
    isdnctrl_msg("  SPID%d:                %s", channel+1, configuration.spid[channel]);
    isdnctrl_newline();
  }
}

/*	Execute ISDNctrl Command
	------------------------

A command line has been sent to ISDNctrl, so execute it.
All errors and status messages are sent back to ISDNctrl.
Command line is terminated with \0 and may contain more than one command.
Command line should start with "AT" (upper or lower case).
Multiple commands may be given on the same line.

If the whole command line is executed successfully an "OK" message is
normalled returned (via ISDNctrl). If a command generates an error an
error will be returned and subsequent commands will be ignored.

Some special commands start an action and don't acknowledge the command
with an OK. For example, ATS141=1 starts a loopback test and the test will
itself generate an "OK" or a "ERROR Loopback failed" message.

*/

static void isdnctrl_cmdline(char *cmd)
{
  char dialstring[MAXDIALSTRING];	/* Dial string */
  char *err=NULL;			/* Pointer to error string */
  int rate=0;				/* ISDN rate. Use default unless @56 given in dial command */

  /* printf("cmd: %s\n", cmd); */

  if ( toupper(*cmd++)=='A' && toupper(*cmd++)=='T') /* Skip over AT */
  {
    while (*cmd && !err)
      switch (toupper(*cmd++))
      {
      case '?':
        {
          char test[50];
          param_string(&cmd, test, 50);
          isdnctrl_msg("%c", call_matches(test) ? 'Y' : 'N');
          isdnctrl_newline();
          break;
        }
      case 'T':  /* Select tone dialling - ignore */
      case 'P':  /* Select pulse dialling - ignore */
      case ' ':  /* Ignore spaces in AT command string */
        break;

      case 'A':	 /* Answer incoming call*/
/* FK : changed default_service to incoming_service */      
        err=cmd_answer(servicecode(incoming_service));
        break;

      case 'D':  /* Dial command */
        while (toupper(*cmd)=='T' || toupper(*cmd)=='P') cmd++;
        if (param_dialstring(&cmd, dialstring, MAXDIALSTRING)==0)
        {
          int service=default_service;
          
          if (token(&cmd,"::")) 
          {
            service=param_number(&cmd, DTE_CHANNEL_V120);	/* Look for service code (not sent as part of the dial string) */
            err=checkservice(service);		/* Check service code if valid */
          }

          if (token(&cmd,"@"))
          {
            switch (param_number(&cmd, -1))
            {
              case 56:rate=ACU_RA_56000; break;	/* 56K, so tell ACU to use 56K */
              case 64:rate=0; break;		/* 64K is default rate */
	      default:err=ERR_RATE; break;	/* No other rates are allowed */
	    }
          }
          
          if (err==NULL)
            err=cmd_dial(dialstring, (char *) configuration.calling_number[0], 
                (char *) configuration.calling_subaddress[0], service, rate);
        }
        else
          err=ERR_DIALBAD;
        break;

      case 'H':  /* Hook command */
        if (param_number(&cmd, 0) == 0)
        {
          err=cmd_hook();
        }
        break;
      
      case 'E':  /* Local echo command: E0 disables echo, E1 enables echo */
        isdnctrl_echo=(param_number(&cmd, 0));  /* E comand by itself disables echo */
        break;
      
      case 'Z':  /* Set values from configuration commands */
	send_config();
        break;

      case 'S':				/* Pseudo S registers */
      {
        int reg, value;			/* S register number and value */
    	reg=param_number(&cmd, -1);	/* Get register number */
        if (reg>=0 && *cmd++=='=')
        {
          value=param_number(&cmd, -1);	/* New value */
          switch (reg)
          {
            case 0:
              if (value>=-1)
                isdnctrl_autoanswer=value;	/* -1=don't ring, 0=don't auto-answer, >0 answer immediately */
              else
	        err = ERR_BADVAL;
              break;
              
            case 141: case 142:
              if ((value == 0) || (value == 1))			/* ON or OFF */
              {
	        err = cmd_loop_b_chan (reg-140, value);		/* Chan 1 for 141 or chan 2 for 142 */
	        if (err==NULL) err=(char *) SUPPRESS_OK;	/* Suppress OK when starting loopback test */
	      }
	      else
	        err = ERR_BADVAL;
	      break;
	      
	     default: err=ERR_BADREG;
	  }
	}
      }
      break;
      
      case '#':
        if (token(&cmd, "INTERFACE=")) 
        {
          switch (toupper(*cmd))
          {
            case 'U': configuration.interface='U'; cmd++; break;	/* Select U interface */
            case 'S': configuration.interface='S'; cmd++; break;	/* Select S interface */
            default:err=ERR_BADINT;
          }
        }
        else 
        if (token(&cmd, "COUNTRY=")) configuration.country=param_number(&cmd, COUNTRY_DEFAULT);
        else 
        if (token(&cmd, "OPERATOR=")) 
        {
          int val;
          val=param_number(&cmd, OPERATOR_DEFAULT);
          if (val>0 && val<MX_OPERATOR_NB)
            configuration.operator=val;
          else
            err=ERR_BADOP;
        }
        else
	/* PRIORITY configurations are no longer used
        if (token(&cmd, "PRIORITY_V120=")) configuration.priority_v120=param_number(&cmd, 10);
        else 
        if (token(&cmd, "PRIORITY_PPP=")) configuration.priority_ppp=param_number(&cmd, 10);
        else 
        */
        if (token(&cmd, "LOCAL_NUMBER_PPP=")) param_numberstring(&cmd, (char *) configuration.local_number_ppp, ISDNCTRL_MAX_NUMBER);
        else
        if (token(&cmd, "LOCAL_SUBADDRESS_PPP=")) param_numberstring(&cmd, (char *) configuration.local_subaddress_ppp, ISDNCTRL_MAX_SUBADDRESS);
        else
        if (token(&cmd, "LOCAL_NUMBER_V120=")) param_numberstring(&cmd, (char *) configuration.local_number_v120, ISDNCTRL_MAX_NUMBER);
        else
        if (token(&cmd, "LOCAL_SUBADDRESS_V120=")) param_numberstring(&cmd, (char *) configuration.local_subaddress_v120, ISDNCTRL_MAX_SUBADDRESS);
        else
        if (token(&cmd, "CALLING_NUMBER1=")) param_numberstring(&cmd, (char *) configuration.calling_number[0], ISDNCTRL_MAX_NUMBER);
        else
        if (token(&cmd, "CALLING_SUBADDRESS1=")) param_string(&cmd, (char *) configuration.calling_subaddress[0], ISDNCTRL_MAX_SUBADDRESS);
        else
        if (token(&cmd, "SPID1=")) param_string(&cmd, (char *) configuration.spid[0], ISDNCTRL_MAX_SPID);
        else
        if (token(&cmd, "CALLING_NUMBER2=")) param_numberstring(&cmd, (char *) configuration.calling_number[1], ISDNCTRL_MAX_NUMBER);
        else
        if (token(&cmd, "CALLING_SUBADDRESS2=")) param_string(&cmd, (char *) configuration.calling_subaddress[1], ISDNCTRL_MAX_SUBADDRESS);
        else
        if (token(&cmd, "SPID2=")) param_string(&cmd, (char *) configuration.spid[1], ISDNCTRL_MAX_SPID);
        else
        if (token(&cmd, "?")) config_list();  /* List configuration */
        else
          err=ERR_BADCONF;
        break;

      case '&':  /* Extended AT command */
        if (toupper(*cmd++)=='O')
        {
          default_service=param_number(&cmd, DTE_CHANNEL_V120);
          err=checkservice(default_service);		/* Check defaultservice code if valid */
          break;
        }
        /* Drop through into Bad cmd routine: */
        
      default:
        err=ERR_BADCMD;
        break;
      }
    switch ((int) err)
    {
      case SUPPRESS_OK:
        break;			/* Suppress OK for some commands */
      case NULL:
        isdnctrl_msg("OK"); 
        isdnctrl_newline();
        break;
      default:
        isdnctrl_msg("ERROR ");	/* Precede all error messages with "ERROR " */
        isdnctrl_msg(err); 
        isdnctrl_newline();
    }
  }
}


/*	Data Sent to ISDNctrl Device
	----------------------------

Read characters from the specified stream and build command line in cmd
buffer until we receive a cr or newline character when we execute the
command line.

Empty lines do nothing.

Delete and Backspace delete the last character.

An error will be generated and sent to ISDNctrl immediately if the
command line is too long or a bad command is given. Other status and
error messages will be issued when the ISDN system returns a message
indicating the call progress.

*/

void isdncmds(int cmdstream)
{
  static char cmd[MAXCMDLENGTH];
  static int count;
  int newchar;

  while ( streams[cmdstream].open && (newchar=Buffer_RemoveByte(&bufferman_call, streams[cmdstream].bufferman_id)) !=-1)
  {
    if (newchar=='\n' || newchar=='\r')
    {
      if (isdnctrl_echo) isdnctrl_newline();
      if (count>=MAXCMDLENGTH)
      {
        isdnctrl_msg("ERROR " ERR_CMDLONG);	/* Return "line too long" error */
        isdnctrl_newline();
      }
      else
      {
        cmd[count++]='\0';			/* Terminate command with \0 char */
        isdnctrl_cmdline(cmd);
      }
      count=0;  /* Reset count ready for next command */
    }
    else
    {
      if (isdnctrl_echo) isdnctrl_msg("%c",newchar);  /* Local echo of ISDNctrl commands */
      if (newchar==8 || newchar==127)	/* Delete last char on Ctrl-H or DELETE */
      {
        if (count>0) count--;
      }
      else
        if (count<MAXCMDLENGTH) cmd[count++]=newchar;  /* Add character to command buffer */
    }
  }
}


/*	Initialise ISDNctrl
	-------------------

Called at module initialisation.
Set up default configurations.

*/

void isdnctrl_init(void)
{
  int channel;

#ifdef VARIANT_US
  configuration.interface= 'U';			/* Interface type S or U */
#else
  configuration.interface= 'S';			/* Interface type S or U */
#endif
  configuration.country=COUNTRY_DEFAULT;	/* Country code - see services.h */
  configuration.operator= OPERATOR_DEFAULT;	/* Operator code - see services.h */
  for (channel=0; channel<2; channel++)
  {
    *configuration.calling_number[channel]='\0';	/* Our number */
    *configuration.calling_subaddress[channel]='\0';	/* Our sub-address */
    *configuration.spid[channel]='\0';			/* SPID for US operators */
  }
  *configuration.local_number_ppp='\0';
  *configuration.local_number_v120='\0';
  *configuration.local_number_mppp_syn='\0';
  *configuration.local_number_mppp_asyn='\0';
  
  *configuration.local_subaddress_ppp='\0';
  *configuration.local_subaddress_v120='\0';
  *configuration.local_subaddress_mppp_syn='\0';
  *configuration.local_subaddress_mppp_asyn='\0';

  /* PRIORITY configurations are being dropped - DO NOT USE */
  configuration.priority_v120 = DEFAULT_PRIORITY_V120;
  configuration.priority_ppp = DEFAULT_PRIORITY_PPP;
  configuration.sent=FALSE;			/* Flag configuration not sent to Omnitel routines yet */  
}

