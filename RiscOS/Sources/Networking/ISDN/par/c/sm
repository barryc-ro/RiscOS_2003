
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - sm.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *     sm  - implements the entry point of the OMNITEL-BRICKS
 *           System Management entity.
 *
 *     sm_init - implements the initialization of the OMNITEL-BRICKS
 *           entities by sending init message to the layer managers.
 *
 *     sm_entity_in_cfg_descriptor - checks an entity is in the
 *           configuration descriptors table.
 *
 *     sm_trf_cfg_update_value - implements the loading of
 *           configuration update values from a received data block.
 *
 *     sm_init_send - implements the building and sending of a
 *           configuration message to a layer management entity.
 *
 *     sm_resource_congestion - implements the processing of
 *           a resource congestion event.
 *
 *     sm_send_info - implements the sending of the environment
 *           parameters (compile-time and services).
 *
 *     sm_retransmit - implements the retransmission of a received
 *           message with a new primitive code and to a given entity.
 *
 *     sm_copy_received_msg_and_send - implements the copy of the
 *           received message and send it to the destination entity.
 *
 *     sm_var_init - init of SM entity's global variables.
 *
 *     sm_init_update_par - sm_move_update_par - sm_set_update_par
 *           Update simple management functions.
 *
 *     sm_report_init - initialize SM structures for reporting
 *     sm_set_report_in - process a SM_SET_REPORT_IN message
 *     sm_report_in - process a SM_REPORT_IN message
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    SM Entity (System Management)                    |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "sm.h"

/*--------------------------------------------------------------------------*/

                    /* Preliminay compatibility checks */

#ifndef CONFIG_UPDATE_MANAGEMENT
#	define CONFIG_UPDATE_MANAGEMENT	    OFF
#endif

#ifndef API_INIT_CONFIG
#	define API_INIT_CONFIG			    OFF
#endif

#ifndef APPLI_RESET_CONFIG
#	define APPLI_RESET_CONFIG			    OFF
#endif

#ifndef API_CONFIG_UPDATE_MANAGEMENT
#	define API_CONFIG_UPDATE_MANAGEMENT	OFF
#else
#   if (API_CONFIG_UPDATE_MANAGEMENT == ON) && (CONFIG_UPDATE_MANAGEMENT == OFF)
       Parameters inconsistency !
#   endif
#endif

/*--------------------------------------------------------------------------*/

                    /* Variables declaration */

			/* Copyright */

CONST 	char 			sm_copyright[]	= "Copyright (c) 1989 - 1993 by OMNITEL SA - All Rights Reserved";
CONST 	char 			sm_licence[]	= LICENSE_NBER;

			/* Global data */

		Entity_common(sm);          			        /* SM entity common */

static 	uchar			sm_init_flag;					/* init flag initialized to OFF */
static	uchar			sm_non_automatic_tei_ent_id;	/* Entity registered for the non-automatic TEI control */

			/* configuration management */

static	uchar			sm_config_wait_entity_id;		/* config wait fot SM_SET_CONFIG_CO from entity ID  */
static	uchar			sm_config_nb;					/* number of configuration messages sent */
static	uchar			sm_config_ret_code;				/* return code */
static	ent_id_t    	sm_config_confirm_to;			/* entity Id for configuration confirmation */

#if API_CONFIG_UPDATE_MANAGEMENT == ON /* { */

		struct queue_mgt sm_set_config_rq;
        uchar            sm_api_config_update;
        uchar            sm_api_config_cause;           /* saved config error cause */
        uchar            sm_api_config_diag;            /* saved config error diagnostic */

#endif /* } */

			/* compilation parameters structure */

static	CONST struct compile_param compile_param = {

		C_COMPILER,								/* compiler   : TC , MSC, IT, LA , IC86, MT68, CC, C_TMS320 */
		OS,										/* OS         : MS_DOS, VRTX, UNIX, PSOS , RTC86, AMX, MTR86 */
		OM_CPU,									/* Target CPU : INTEL(1 & 2), MOTOROLA (1 & 2), SPARC, AMD29000, TMS320*/

		EQUIPMENT,								/* equipment : TE (terminal) or NT2 (network termination 2) */
		OPTIMIZATION,							/* optimization : SPEED, SIZE, MIXED */
		ASSERT,									/* assert test ON or OFF */
		MESSAGE_CACHE,							/* message cache ON or OFF */
		BUFFER_CACHE,							/* buffer cache ON or OFF */
		TIMER_IT,								/* timer IT handler (ON) or timer process (OFF) */
		TIMER_CELL_CACHE,						/* timer cell cache */
		BLOCK_COUNTING,							/* block counting facilities : ON or OFF */
		MESSAGE_CONG_CONTROL,					/* congestion control ON or OFF */
		BUFFER_CONG_CONTROL,					/* congestion control ON or OFF */
		MESSAGE_AUDIT,							/* message audit ON or OFF */
		MESSAGE_SEND_DATA, 						/* Information data in message */

#		if MESSAGE_AUDIT == ON
			MESSAGE_AUDIT_SIZE,					/* size of the message audit array */
			MESSAGE_AUDIT_DATA_LGTH, 			/* size of the message or buffer data to store in the audit array */
#		endif

};

/*--------------------------------------------------------------------------*/

                    /* Macros definition */

	/* Event for update parameter management */

#ifndef	Cfg_event_update_par
#	define Cfg_event_update_par()	CONTINUE
#endif

	/* If not defined defines standard update ID */

#ifndef UPDATE_START_CONFIG_ID
#	define UPDATE_START_CONFIG_ID		0
#endif

#ifndef UPDATE_STOP_CONFIG_ID
#	define UPDATE_STOP_CONFIG_ID		1
#endif

#ifndef UPDATE_TEI_ID
#	define UPDATE_TEI_ID				200
#endif

	/*
		p_config is a table of configuration descriptor
		ended by a ENT_NIL value.
	*/

			/* Implicit configuration descriptor access Macro's */

				/* p_p_descriptor = current descriptor pointer address */

				/* p_i            = address of an index mark */

#ifndef Sm_load_first_p_config_descriptor
#	define Sm_load_first_p_config_descriptor(p_p_descriptor, p_i)	*p_p_descriptor = (struct config_descriptor FAR *)&p_config [0]
#	define Sm_load_next_p_config_descriptor(p_p_descriptor, p_i)  	++*p_p_descriptor
#endif

#ifndef	Sm_power_on
#	define	Sm_power_on()
#endif

#ifndef	Sm_power_off
#	define	Sm_power_off()
#endif

/*--------------------------------------------------------------------------*/

                    /* local function prototyping */

#if NEW_FCT_STYLE == ON
	void	sm_report_in			(void);
	void	sm_report_init			(void);
	void	sm_set_report_in		(void);
#else
	void	sm_report_in			();
	void	sm_report_init			();
	void	sm_set_report_in		();
#endif

#if API_CONFIG_UPDATE_MANAGEMENT == ON

#   if NEW_FCT_STYLE == ON

    void sm_process_config_rq       (void);
    void sm_send_api_config_confirm (void);
    void sm_process_next_config_rq  (void);

#   else

    void sm_process_config_rq       ();
    void sm_send_api_config_confirm ();
    void sm_process_next_config_rq  ();

#   endif

#endif

#if APPLI_RESET_CONFIG == ON

#   if NEW_FCT_STYLE == ON

	void sm_appli_save_update_par		(uchar FAR *p_data, ushort data_size);
	void sm_appli_load_update_par		(void);
	void sm_appli_stop_rq 			(void);
	uchar sm_appli_stop_send 		(uchar to);
	uchar sm_appli_stop_co 			(void);
	void sm_appli_reset_config_rq		(void);
	uchar sm_appli_reset_config_send	(uchar to);
	uchar sm_appli_reset_config_co 		(void);
#   else
	void sm_appli_save_update_par		();
	void sm_appli_load_update_par		();
	void sm_appli_stop_rq 			();
	uchar sm_appli_stop_send 		();
	uchar sm_appli_stop_co 			();
	void sm_appli_reset_config_rq		();
	uchar sm_appli_reset_config_send	();
	uchar sm_appli_reset_config_co 		();
#   endif

#endif /* APPLI_RESET_CONFIG == ON */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	sm - implements the main function of the SM entity.

Usage            	uchar sm (p_msg);
						struct message FAR *p_msg;

Return value    	OK or NOK

Description     	sm implements the receiving of an external event for
					the SM entity and the dispatching of this event for
					processing.

Common constants and declarations : services.h

Common objects : current message pointers.

*--------------------------------------------------------------------------*/

uchar sm (p_msg)
	struct message 	FAR *p_msg;
{
	uchar 			FAR *p_data;

#if CONFIG_UPDATE_MANAGEMENT == ON

	uint				 update_id;
	uchar				 val_type;

#   if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)
	    uchar			 tei[2];		/* 2 for Length + value */
#   endif

#endif

	p_rcv_msg = p_msg;
	p_snd_msg = P_NIL;

#	if APPLI_RESET_CONFIG == ON

process_first_message:

#	endif

	p_buffer  = R_msg_p_buffer;
	p_data	  = R_a_data;

		/* SM Init message ? */

	if (sm_init_flag == OFF) {

			/* First message received by SM */

			/* Read the confirmation entity ID */

		if (R_data_size > 0) {
			sm_config_confirm_to = *p_data++;
		}

#		if CONFIG_UPDATE_MANAGEMENT == ON

#			ifdef Cfg_set_update_par

					/* Reserve and reset memory for the SM RAM management */

				if (sm_init_update_par () != OK) {
					Trap (TRAP_SM_INIT_UPDATE_PAR, "init_update_par");
				}

					/* The received message contained configuration update values ? */
				sm_trf_cfg_update_value (p_data, p_data + R_data_size);

#			endif

#		endif

			/*
				Initialize reporting data structures
			*/

		sm_report_init ();

			/*--------------------------------*/
			/* SM "before configuration" hook */
			/*--------------------------------*/

#		ifdef Sm_hook_before_config

			if (Sm_hook_before_config (p_rcv_msg) != OK) {
				Trap (TRAP_SM_HOOK_BEFORE_CONFIG, "Sm_hook_before_config");
			}

#		endif

			/*
				Start the configuration cycle
				by sending SM_SET_CONFIG_RQ messages.
			*/
		switch (sm_init (SM_CONFIG_INIT_FIRST)) {

			case STOP :

					/* No more configuration message to be sent */

				sm_init_flag 				= ON;
				sm_non_automatic_tei_ent_id = ENT_NIL;
				break;

			case CONTINUE : /* Wait for SM_SET_CONFIG_CO */

				sm_init_flag = CONTINUE;
				break;
		}

		goto sm_exit;

	} else if (sm_init_flag == CONTINUE) {

			/* Resuming of the configuration by an SM_SET_CONFIG_CO message ? */

		if ((sm_config_wait_entity_id == R_msg_from) &&
			(R_msg_code == SM_SET_CONFIG_CO)
		   ) {

				/* Decrement the counter of SM_SET_CONFIG_RQ sent */

			if (sm_config_nb != 0) {
				sm_config_nb--;
			}

				/* Signal the configuration stop to the update management. */

			if (Confirm_ret_code != OK) {
				sm_config_ret_code = NOK;
			}

			if (Confirm_ret_code != OK) {

					/*
					   Cause and Diagnostic may be available in
					   'Confirm_cause' and 'Confirm_diagnostic' fields.
					   Refer to the concerned Entity's Interface-Guide
					   for more details upon their possible values.
					*/

				Trap (TRAP_SM_SET_CONFIG_CO, "sm:CONFIG_CO");
			}


				/*
					Continue the configuration cycle
					by sending SM_SET_CONFIG_RQ messages.
				*/

			switch (sm_init (SM_CONFIG_INIT_CONTINUE)) {

				case STOP :

						/* No more configuration message to be sent */

					if (sm_config_nb == 0) {

							/*
								The last SM_SET_CONFIG_CO has been received,
								and no other configuration has been sent:
								the configuration cycle is now completed
							*/

#						if CONFIG_UPDATE_MANAGEMENT == ON

#							ifdef Cfg_set_update_par
								Cfg_set_update_par (UPDATE_STOP_CONFIG_ID, &sm_config_ret_code);
#							endif

#						endif

							/*-------------------------------*/
							/* SM "after configuration" hook */
							/*-------------------------------*/

#						ifdef Sm_hook_after_config

							if (Sm_hook_after_config (p_rcv_msg) != OK) {
								Trap (TRAP_SM_HOOK_AFTER_CONFIG, "Sm_hook_after_config");
							}

#						endif

					}

					sm_init_flag 				= ON;
					sm_non_automatic_tei_ent_id = ENT_NIL;
					break;

				case CONTINUE : /* Wait for SM_SET_CONFIG_CO */
					break;
			}

			goto sm_exit;

		}

	}

		/*--------------------- OUT OF CONFIGURATION -----------------------*/

		/* Event for update parameter management ? */

	if (Cfg_event_update_par () == CONTINUE) {

			/* Process the incoming event */

		if ((R_msg_from == ENT_STS) && (R_msg_code != SM_SET_CONFIG_CO)) {
			goto process_user_message;
		}

			/*-----------------------*/
			/* SM "any message" hook */
			/*-----------------------*/

#		ifdef Sm_hook_any_msg

			if (Sm_hook_any_msg (p_rcv_msg) == STOP) {
				goto sm_exit;
			}

#		endif

			/* Process the message */

		switch (R_msg_code) {

#			if APPLI_RESET_CONFIG == ON
		
				case SM_RESET_CONFIG_RQ :
						/* save update parameters structure */

					sm_appli_save_update_par (p_data, R_data_size);

						/* send all SM_STOP_RQ  */
						
 					sm_appli_stop_rq ();
					break;		
#			endif

				/* Resource congestion : start */

#			if API_INIT_CONFIG == ON

				case SM_SET_CONFIG_RQ :
					sm_retransmit (SM_SET_CONFIG_RQ, (ent_id_t)R_msg_inf0);
					break;

#           endif

#			if API_CONFIG_UPDATE_MANAGEMENT == ON

				case SM_SET_CONFIG_RQ :
					sm_process_config_rq ();
					break;

#			endif

			case SM_BUSY_IN :
				sm_resource_congestion (SM_BUSY_RQ);
				break;

				/* Resource congestion : clear */

			case SM_CLEAR_BUSY_IN :
				sm_resource_congestion (SM_CLEAR_BUSY_RQ);
				break;

				/* NA power ON (coming from MPH) */

			case SM_NA_POWER_ON_IN :
				Sm_power_on ();
				sm_copy_received_msg_and_send (SM_NA_POWER_ON_RQ, ENT_MNS);
				sm_retransmit                 (SM_NA_POWER_ON_RQ, ENT_MDL);
				break;

				/* NA power OFF (coming from MPH) */

			case SM_NA_POWER_OFF_IN :
				Sm_power_off ();
				sm_copy_received_msg_and_send (SM_NA_POWER_OFF_RQ, ENT_MNS);
				sm_retransmit                 (SM_NA_POWER_OFF_RQ, ENT_MDL);
				break;

				/* information requested by an entity */

			case SM_INFO_IN :
				sm_send_info ();
				break;

#			if (DL_LAPB == ON) || (DL_V120 == ON)|| (DL_LAPF == ON)

				case SM_DL_ATTACH_SAPI_IN :
					Dl_ass_from = R_msg_from;
					sm_retransmit (SM_DL_ATTACH_SAPI_RQ, ENT_MDL);
					break;

				case SM_DL_DETACH_SAPI_IN :
					Dl_ass_from = R_msg_from;
					sm_retransmit (SM_DL_DETACH_SAPI_RQ, ENT_MDL);
					break;

				case SM_DL_SAPI_CO :
					sm_retransmit (SM_DL_SAPI_RS, Dl_ass_from);
					break;

#			endif

				/* Set configuration done */

			case SM_SET_CONFIG_CO :

					/*
						Signal the configuration stop
						to the update management.
					*/

				if (Confirm_ret_code != OK) {
					sm_config_ret_code = NOK;
				}

					/* Decrement the counter of SM_SET_CONFIG_RQ sent */

				if ((sm_config_nb != 0) && (--sm_config_nb == 0)) {

						/*
							The last SM_SET_CONFIG_CO has been received,
							and no other configuration has been sent:
							the configuration cycle is now completed
						*/

#					if CONFIG_UPDATE_MANAGEMENT == ON

#						ifdef Cfg_set_update_par
							Cfg_set_update_par (UPDATE_STOP_CONFIG_ID, &sm_config_ret_code);
#						endif

#					endif

						/*-------------------------------*/
						/* SM "after configuration" hook */
						/*-------------------------------*/

#					ifdef Sm_hook_after_config

							if (Sm_hook_after_config (p_rcv_msg) != OK) {
								Trap (TRAP_SM_HOOK_AFTER_CONFIG, "Sm_hook_after_config");
							}

#					endif

						/* configuration confirmation */

					if (sm_send_config_confirm () == OK) {
						break;
					}

#			        if API_CONFIG_UPDATE_MANAGEMENT == ON
						sm_send_api_config_confirm ();
						sm_process_next_config_rq ();
#                   endif

				}

#				if API_INIT_CONFIG == ON

					if (sm_entity_in_cfg_descriptor (R_msg_from) == OFF) {
						sm_retransmit (SM_SET_CONFIG_CO, ENT_API);
						break;
					}

#				endif

				if (Confirm_ret_code != OK) {

#		            if API_CONFIG_UPDATE_MANAGEMENT == ON
						sm_api_config_cause = Confirm_cause;
						sm_api_config_diag  = Confirm_diagnostic;
						break;
#                   endif

						/*
						   Cause and Diagnostic may be available in
						   'Confirm_cause' and 'Confirm_diagnostic' fields.
						   Refer to the concerned Entity's Interface-Guide
						   for more details upon their possible values.
						*/

					Trap (TRAP_SM_SET_CONFIG_CO, "sm:CONFIG_CO");
				}

				break;

				/* Reset configuration done */

			case SM_RESET_CONFIG_CO :

#				if APPLI_RESET_CONFIG == ON

					if (sm_appli_reset_config_co () == STOP) {

							/* load saved parameters */

						sm_appli_load_update_par ();

							/* re-init SM init flag */

						sm_init_flag = OFF;
						goto process_first_message;
					}  

#				endif	
				break;

				/* Init done */

			case SM_INIT_CO :
				break;

				/* Stop done */

			case SM_STOP_CO :

#				if APPLI_RESET_CONFIG == ON

					if (sm_appli_stop_co () == STOP) {
						sm_appli_reset_config_rq ();
					}  
#				endif	

				break;

#			if SIMULATION == ON

					/*
						information requested by SM itself just to
						provide a trace : ignore the message.
					*/

				case SM_INFO_RS :
				   break;

#			endif

				/* Report indication */

			case SM_SET_REPORT_IN :
				sm_set_report_in ();
				break;

			case SM_REPORT_IN :
				sm_report_in ();				/* SM_REPORT_IN generic processing */

					/*-------------------*/
					/* SM_REPORT_IN hook */
					/*-------------------*/

#				ifdef Sm_hook_sm_report_in
					Sm_hook_sm_report_in (p_rcv_msg);
#				endif

				break;

			case SM_INFO_CO :
				break;

#		if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

			/*------------------- Non-automatic TEI management -------------------

				   operator entity				SM				  	MDL
				   ----------------             --                  ---

					SM_TEI_REG_IN   ---->  registration

					SM_TEI_IN 		---->  SM_DL_TEI_RQ 	---->

					SM_TEI_RS 		<----  SM_DL_TEI_CO 	<----

					SM_TEI_RQ		<----  SM_DL_DLCI_IN    <----

			*/

				/***************************************************************/
				/*															   */
				/* R_msg_inf0 = NIL (return code) or fonction code			   */
				/* R_msg_inf1 = SAPI or DL_SAPI_NIL if no DL assignment to do  */
				/* R_msg_inf2 = TEI or DL_TEI_NIL (revalid the previous TEI)   */
				/* R_msg_inf3 = CES if used									   */
				/*															   */
				/***************************************************************/

				/* Data Link TEI management (coming from MDL) */

			case SM_DL_DLCI_IN :

					/* All the SAPI/CES to MPH */

				sm_copy_received_msg_and_send (SM_DL_DLCI_RQ, ENT_MPH);

					/* Only signalling SAPI to MNS */

				if (R_msg_inf1 == DL_SAPI_SIG) {
					sm_copy_received_msg_and_send (SM_DL_DLCI_RQ, ENT_MNS);
				}

				if ((sm_non_automatic_tei_ent_id != ENT_NIL) &&
					(R_msg_inf0 == DL_TEI_REMOVAL) &&
					(R_msg_inf2 < 63)) {

					sm_retransmit (SM_TEI_RQ, sm_non_automatic_tei_ent_id);
				}

				break;

				/* Non-automatic TEI management */

			case SM_DL_TEI_CO :

				if (R_msg_inf0 == OK) {

#				if CONFIG_UPDATE_MANAGEMENT == ON

#					ifdef Cfg_set_update_par

						if ((tei [1] = R_msg_inf2) != DL_TEI_NIL) {		/* TEI value */
							tei [0] = 1;								/* value size */
							Cfg_set_update_par (UPDATE_TEI_ID, (uchar FAR *)&tei);
						}

#					endif

#				endif

				}

				if (sm_non_automatic_tei_ent_id != ENT_NIL) {
					sm_retransmit (SM_TEI_RS, sm_non_automatic_tei_ent_id);

				}

				break;

				/* Entity registration for non-automatic TEI management */

			case SM_TEI_REG_IN :
				sm_non_automatic_tei_ent_id = R_msg_from;
				break;

				/* Relaying a new non-automatic TEI assignment */

			case SM_TEI_IN :
				sm_retransmit (SM_DL_TEI_RQ, ENT_MDL);
				break;

				/*--------------------------------------------------------------*/

#		endif /* } (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) */

				/* MIP Manual routing confirm */

			case SM_MIP_MAN_ROUT_CO :
				break;

				/* Configuration update management */

					/* PUT an update parameter and send back a confirmation */

			case SM_PUT_UPDATE_PAR_IN :

#				if CONFIG_UPDATE_MANAGEMENT == ON

#					ifdef Cfg_set_update_par

						Update_return_code = Cfg_set_update_par (Update_id, Update_a_data);

#					else

						Update_return_code = NOK;

#					endif

#				else

					Update_return_code = NOK;

#				endif

				sm_retransmit (SM_PUT_UPDATE_PAR_RS, R_msg_from);
				break;

					/* Get an update parameter */

			case SM_GET_UPDATE_PAR_IN :

#			if CONFIG_UPDATE_MANAGEMENT == ON

#				ifdef Cfg_move_update_par

					update_id 	= Update_id;			/* requested update ID */
					val_type	= Update_val_type;

					if (p_buffer == P_NIL) {

						if ((p_buffer = Alloc_buffer ()) == P_NIL) {
							R_msg_data_size = 0;
							sm_retransmit (SM_GET_UPDATE_PAR_RS, R_msg_from);
							break;

						}

					} else {

						Buffer_header_init;
					}

					p_data 				= Buffer_a_first_data;
					Update_return_code	= OK;
					Update_id 			= update_id;
					Update_val_type 	= val_type;

					if (val_type == UPDATE_INITIAL_VALUE) {

						Update_data_length	= Cfg_move_config_par (Update_id, Update_a_value, Buffer_data_lgth);

					} else {

						Update_data_length	= Cfg_move_update_par (Update_id, Update_a_value, Buffer_data_lgth);
					}

					Buffer_data_size 	= UPDATE_SIZE + Update_data_length;
					R_msg_init_link_buffer;			/* link the buffer to the received message */

#				else

					Update_return_code	= NOK;

#				endif

#			else

				Update_return_code	= NOK;

#			endif

				sm_retransmit (SM_GET_UPDATE_PAR_RS, R_msg_from);
				break;


			default :
			process_user_message:

					/*--------------------------------*/
					/* SM "unrecognised message" hook */
					/*--------------------------------*/

#				ifdef Sm_process_user_msg

						/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
						/*                                  */
						/*             WARNING:             */
						/*                                  */
						/* the message must be freed before */
						/* exiting from the macro call      */
						/*                                  */
						/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

					Sm_process_user_msg (p_rcv_msg);
					p_rcv_msg = P_NIL;

#				endif

				break;

		}

	}

sm_exit:
		/* Free the remaining messages if necessary */

	Free_msg (p_rcv_msg);
	Free_msg (p_snd_msg);

		/* Return */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             sm_init

Usage            uchar sm_init (code);

					- uchar code:
						- SM_CONFIG_INIT_FIRST    when SM runs for the first
						time,
						- SM_CONFIG_INIT_CONTINUE when SM had to wait for the
						SM_SET_CONFIG_CO message before sending the next
						configuration.

Description      sm_init implements the initialization of the OMNITEL-BRICKS
				 entities by sending SM_SET_CONFIG_RQ messages to the layer
				 managers.


Return value    return code = STOP     : all configuration messages listed in
										 the configuration table have been sent.
							= CONTINUE : some messages remain to be sent.

common constants and declarations : services.h

common : message/buffer pointers.

*--------------------------------------------------------------------------*/

	static	struct config_descriptor FAR *sm_p_config_descriptor;
	static  uint						  sm_save_i;

uchar sm_init (code)
	uchar		code;		/* SM_CONFIG_INIT_FIRST or SM_CONFIG_INIT_CONTINUE */
{
	struct config_descriptor FAR *p_config_descriptor;
	uint						  i;


		/* Prepare return code for STOP_CONFIG */

	sm_config_ret_code 	= OK;

	if (code == SM_CONFIG_INIT_FIRST) {

			/* Start of configuration */

		sm_config_nb 	= 0;	/* Initialize the counter of SM_SET_CONFIG_RQ sent */

#		if SIMULATION == ON

				/*
				   Under simulation, the System Management entity sends a
				   SM_INFO_IN to itself in order to output all services and
				   compile-time parameters to the screen or the output file.
				*/

			if (p_snd_msg == P_NIL) {
				p_snd_msg = Alloc_msg ();
			}

				/* Load the message header */

			S_msg_from 		= ENT_SM;			/* from System Management entity */
			S_msg_to 		= ENT_SM;			/*  to  System Management entity */
			S_msg_nai 		= NAI_NIL;			/* null network access ID */
			S_msg_sapi 		= SAPI_NIL;			/* SAPI = NIL */
			S_msg_add		= ADD_NIL;			/* address = NIL */
			S_msg_code 		= SM_INFO_IN;		/* primitive code */

				/* Send the message and the optional linked buffer */

			Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;

#		endif

#		if CONFIG_UPDATE_MANAGEMENT == ON

#			ifdef Cfg_set_update_par

				/*
					Signal the configuration start
					to the update management.
				*/

				Cfg_set_update_par (UPDATE_START_CONFIG_ID, P_NIL);

#			endif

#		endif

		Sm_load_first_p_config_descriptor (&p_config_descriptor, &i);

	} else {

		p_config_descriptor	= sm_p_config_descriptor;
		i 					= sm_save_i;

	}

	for ( ; (p_config_descriptor != P_NIL) && (Config_entity_id != ENT_NIL);
		Sm_load_next_p_config_descriptor (&p_config_descriptor, &i)) {

		if ( (Entity_in_system (Config_entity_id) == ON) &&
			 (sm_init_send (Config_entity_id, Config_address, Config_size, Config_p_update) != OK) ) {
			Trap (TRAP_SM_INIT, "sm_init");
		}

		if (Config_wait_flag == ON) {

				/* Save the working context */

			sm_config_wait_entity_id 	= Config_entity_id;

			Sm_load_next_p_config_descriptor (&p_config_descriptor, &i);

			sm_p_config_descriptor 		= p_config_descriptor;
			sm_save_i					= i;

				/*
					wait for SM_SET_CONFIG_CO before sending the next
					configuratin message
				*/

			return (CONTINUE);
		}

	}

		/* Return STOP */

	return (STOP);
}

/*-------------------------------------------------------------------------*/

#if SIMULATION == ON

uchar	sm_services_init ()
{

#	if ASSERT == ON

		uchar perf;

			/*
			 * Save performance flag which may have been
			 * modify thru run-time simulation command 's=O'.
			 */

		perf = performance;

			/* Init the services */

		services_var_init ();
		Services_init ((struct i_service *)&i_service);

			/* Set back performance */

		performance = perf;

#	else
			/* Init the services */

		services_var_init ();
		Services_init ((struct i_service *)&i_service);

#	endif

		/* Init the IT services */

#	ifdef IT_STACK_MSG_LOW_MARK
		it_var_init ();
		It_init ((struct it_init FAR *) &it_init_data);
#	endif

	return (OK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             sm_entity_in_cfg_descriptor - implements the test to
				 detect if the primitive received is coming from an
				 entity configured by SM.

Usage            uchar sm_entity_in_cfg_descriptor (ent_id_t entity);

Description      The configuraion descriptor table is scanned to test
				 matching of entity id.


Return value    return code = ON  entity in configuration descriptor table,
							= OFF else.

common constants and declarations : services.h

common : message/buffer pointers.

*--------------------------------------------------------------------------*/

#if	API_INIT_CONFIG == ON

uchar sm_entity_in_cfg_descriptor (entity)
	ent_id_t entity;
{

	struct config_descriptor FAR *p_config_descriptor;
	uint						  i;

	Sm_load_first_p_config_descriptor (&p_config_descriptor, &i);

	for ( ; (p_config_descriptor != P_NIL) && (Config_entity_id != ENT_NIL);
		 Sm_load_next_p_config_descriptor (&p_config_descriptor, &i)) {

		if (entity == Config_entity_id) {
			return (ON);
		}
	}

	return (OFF);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             sm_trf_cfg_update_value - implements the loading of
				 configuration update values from a received data block.

Usage            uchar sm_trf_cfg_update_value (p_data, p_end_data);
					p_data 		: pointer on the start of the data,
					p_end_data  : pointer on the end of the data.

					p_data ---->    | ent_co_id |
									| 		update_Id 	| size | .. value ... |
									| 		update_Id 	| size | .. value ... |
									| 		update_Id 	| size | .. value ... |
									| 		update_Id 	| size | .. value ... |
					p_end_data -->


Return value    return code = OK
							= NOK

common constants and declarations : services.h

common : message/buffer pointers.

*--------------------------------------------------------------------------*/

#if CONFIG_UPDATE_MANAGEMENT == ON /* { */

#	ifdef Cfg_set_update_par

uchar	sm_trf_cfg_update_value (p_data, p_end_data)
	uchar	FAR *p_data;    	/* start data address */
	uchar	FAR *p_end_data;	/* end data address */
{
	ushort		 update_id;		/* update ID */
	uchar		 data_size;		/* data size */

		/* Loop while end of data */

	while (p_data + 3 < p_end_data) {

			/* Extract the update-id (2 bytes) */

		update_id 	 = (*p_data++) * 256;
		update_id 	+=  *p_data++;

			/* Extract the update-size (1 byte) */

		if ((data_size = *p_data) != 0) {

				/* Save the update value */

			Cfg_set_update_par (update_id, (uchar FAR *)p_data);

		}

			/* Set p_data to the next update entry */

		p_data += data_size + PARAM_LENGTH_SIZE;
	}

	return (OK);
}

#	endif

#endif /* } CONFIG_UPDATE_MANAGEMENT == ON */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_init_send - implements the building and sending of a
							   configuration message to a layer management
							   entity.

Usage           uchar sm_init_send (to, uchar FAR *p_config, size);
					- uchar		to 			: destination entity,
					- uchar FAR *p_config 	: configuration address,
					- ushort	size 		: configuration size.

Related
functions usage ();


Description :	implements the building of a SM_SET_CONFIG_RQ message from
				the configuration structure p_config and the message
				sending to the layer management entity.

Return : return code = OK	done
					 = NOK  not done

Common constants and declarations : ctx_ext.h

Common objects :  message and buffer context.

*--------------------------------------------------------------------------*/

uchar sm_init_send (to, p_config, size, p_cfg_update)
	uchar					 to;			/* destination entity */
	uchar	 			FAR	*p_config;		/* configuration structure address */
	ushort					 size;			/* configuration structure size */
	struct cfg_update	FAR *p_cfg_update;	/* configuration update list */
{

		/* Id buffer length OK ? */

	if (size > Buffer_data_lgth) {
		return (NOK);
	}

		/* Buffer allocation */

	if (Buffer_alloc == P_NIL) {
		return (NOK);
	}

		/* Init buffer header */

	Buffer_data_size = size;

		/* Move objects to the buffer */

	Memcpy_far ((char FAR *)Buffer_a_start_data, (char FAR *)p_config, (ushort)size);

		/* Update the buffer data config */

#	if CONFIG_UPDATE_MANAGEMENT == ON
		sm_config_update (p_config, p_cfg_update);
#	endif

		/* Allocate a message if not already done */

	if (p_snd_msg == P_NIL) {
		p_snd_msg = Alloc_msg ();
	}

		/* Load the message header */

	S_msg_from 		= ENT_SM;			/* from System Management entity */
	S_msg_to 		= to;				/* to the layer Management entity */
	S_msg_nai 		= NAI_NIL;			/* null network access ID */
	S_msg_sapi 		= SAPI_NIL;			/* SAPI = NIL */
	S_msg_add		= ADD_NIL;			/* address = NIL */
	S_msg_code 		= SM_SET_CONFIG_RQ;	/* primitive code */

		/* Link the current buffer to the message if needful */

	S_msg_init_link_buffer;

		/* Send the message and the optional linked buffer */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;

		/* Increment the number of SM_SET_CONFIG_RQ messages pending */

	sm_config_nb++;

		/* Return */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_send_config_confirm

Usage           uchar sm_send_config_confirm ();

Description :	implements the building and sending of an SM_SET_CONFIG_CO
				message to the entity registered in the first message
				received by SM.

Return : 		OK : the message has been sent correctly.
				NOK: the message cannot be sent
					 (the destination entity does not exist).

Common constants and declarations :

Common objects :  message and buffer context.

*--------------------------------------------------------------------------*/

uchar sm_send_config_confirm ()
{
	uchar FAR *p_data;

		/* configuration confirmation */

	if (Entity_in_system (sm_config_confirm_to) == ON) {

			/* Allocate a message if not already done */

		if (p_snd_msg == P_NIL) {
			p_snd_msg = Alloc_msg ();
		}

		p_data 			= S_msg_a_first_data;
		*p_data 		= sm_config_ret_code;
		S_msg_data_size = 1;

			/* Load the message header */

		S_msg_from 		= ENT_SM;				/* from System Management entity */
		S_msg_to 		= sm_config_confirm_to;	/* to the layer Management entity */
		S_msg_nai 		= NAI_NIL;				/* null network access ID */
		S_msg_sapi 		= SAPI_NIL;				/* SAPI = NIL */
		S_msg_add		= ADD_NIL;				/* address = NIL */
		S_msg_code 		= SM_SET_CONFIG_CO;		/* primitive code */

			/* Send the message */

		Send_message (p_snd_msg); p_snd_msg = P_NIL;

		return (OK);
	}

	return (NOK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_resource_congestion - implements the processing of
										 a resource congestion event.

Usage           void sm_resource_congestion (uchar primitive_code);
					- primitive_code : code of the event to dispatch.

Description :	sm_resource congestion implements the sending of the
				resource congestion events to the layer management
				entities.

Common constants and declarations : System composition.

Common objects : message context.

*--------------------------------------------------------------------------*/

void sm_resource_congestion (primitive_code)
	code_t				 primitive_code;		/* primitive code to send */
{
	ushort				 x;
	struct	message FAR *p_msg;

	for (x = 0; x <= (ushort)Ed_x_max; x++) {

		if (((primitive_code == SM_BUSY_RQ) 	  && (Entity_congestion_flag (Ed_x_to_entity_id (x), ON)  == ON)) ||
			((primitive_code == SM_CLEAR_BUSY_RQ) && (Entity_congestion_flag (Ed_x_to_entity_id (x), OFF) == ON))
		   ) {
				/* Allocate a message or reuse the receive message */

			if (p_rcv_msg != P_NIL) {
				p_msg 		= p_rcv_msg;
				p_rcv_msg 	= P_NIL;

			} else {

				if ((p_msg = Alloc_msg ()) == P_NIL) {
					break;
				}
			}

				/* Load the message */

			L_msg_from 		= ENT_SM;
			L_msg_to		= Ed_x_to_entity_id (x);
			L_msg_nai		= NAI_NIL;
			L_msg_sapi		= SAPI_NIL;
			L_msg_add		= ADD_NIL;
			L_msg_code		= primitive_code;

				/* Send the message to the MDL entity */

			Send_message (p_msg);

		} /* end if */

	} /* end for */

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_send_info - implements the sending of the environment
							   parameters (compile-time and services).

Usage           void sm_send_info (void);

Related
functions usage void sm_retransmit (code_t code, ent_id_t to);
				void sm_get_info (p_info);

Common constants and declarations : services.h

Common objects : server context.

*--------------------------------------------------------------------------*/

void sm_send_info ()
{
	uchar						FAR *p_data; 				/* data pointer */
	uchar							 i;						/* index */
	ushort		 				 	 data_size;				/* data size */
	struct config_descriptor 	FAR *p_config_descriptor;	/* descriptor pointer */
	uchar						     profile;				/* profile (ON) or factory parameters (OFF) */
	uchar							 system_flag;			/* system flag : TRUE or FALSE */

		/* Set incoming data context */

	data_size 	= R_data_size;
	p_data 		= R_a_data;

		/* Allocate a buffer if not already done */

	Buffer_alloc_reused;									/* re-use the received buffer if any */
	R_msg_init_link_buffer;									/* link the buffer to the received message */
	Buffer_data_offset = BUFFER_HEADER_SIZE;

	system_flag = TRUE;

	if (data_size == SM_INFO_SIZE) {

		if (Sm_info_ent_id != ENT_NIL) {

			for (Sm_load_first_p_config_descriptor (&p_config_descriptor, &i);
				 (p_config_descriptor != P_NIL) && (Config_entity_id != ENT_NIL);
				 Sm_load_next_p_config_descriptor (&p_config_descriptor, &i)) {

				if (Config_entity_id == Sm_info_ent_id) {
					profile = Sm_info_profile;

					Memcpy_far ((char FAR *)Buffer_a_first_data,
								(char FAR *)Config_address,
								(ushort)Config_size);

					Buffer_data_size = Config_size;

					if (profile == ON) {

							/* Update the buffer data config */

#						if CONFIG_UPDATE_MANAGEMENT == ON
							sm_config_update (Config_address, Config_p_update);
#						endif
					}

					system_flag = FALSE;
					break;

				}

			}

		}

	}

	if (system_flag) {

			/* Get the information requested through a common function */

		sm_get_info ((uchar FAR *) Buffer_a_first_data);
		Buffer_data_size = Rnd_sizeof(struct i_service) + Rnd_sizeof(struct compile_param);

	}


		/* Send back the message to the origination entity */

	sm_retransmit (SM_INFO_RS, R_msg_from);
}

/*--------------------------------------------------------------------------*/

#if CONFIG_UPDATE_MANAGEMENT == ON /* { */

#	ifdef Cfg_move_update_par

void sm_config_update (p_config, p_cfg_update)
	uchar				 		FAR *p_config;		/* data config pointer */
	struct cfg_update 			FAR *p_cfg_update;  /* Update descriptor */
{

	uchar		 		 	 	  	 i;				/* index */
	uchar						FAR *p_data;

		if (p_cfg_update != P_NIL) {

			for (i = 0; Cfg_update_id (i) != UPDATE_ID_NIL; i++) {

				if ((p_data = Cfg_update_p_val (i)) != P_NIL) {
					Cfg_move_update_par (Cfg_update_id (i), (uchar FAR *) ((uint)(p_data - p_config) + Buffer_a_start_data), Cfg_update_length (i));
				}

			}

		}

}

#	endif

#endif /* } CONFIG_UPDATE_MANAGEMENT == ON */

/*--------------------------------------------------------------------------*/

void sm_get_info (p_info)
	uchar FAR * p_info;
{
		/* get the i_service structure */

	p_info += Read_i_services ((struct i_service *)p_info);

		/* get the compilation parameters */

	Memcpy_far((char FAR *)p_info, (char FAR *)&compile_param, Rnd_sizeof(struct compile_param));
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_retransmit - implements the retransmission of a received
				message with a new primitive code and to a given entity

Usage           void sm_retransmit (code_t code, ent_id_t to);
					- code : new primitive code,
					- to   : destination entity Id.
Related
functions usage void Send_message();

Common constants and declarations : services.h

Common objects : server context.

*--------------------------------------------------------------------------*/

void sm_retransmit (code, to)
	code_t		code;					/* primitive code */
	ent_id_t    to;						/* destination entity */
{

	if (Entity_in_system (to) == ON) {
		R_msg_from	= ENT_SM;				/* origination */
		R_msg_to	= to;					/* destination */

		R_msg_code	= code;					/* primitive code */

		Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_copy_received_msg_and_send - implements the copy of the
				received message and send it to the destination entity.

Usage           void sm_copy_received_msg_and_send (code_t code, ent_id_t to);
					- code : new primitive code,
					- to   : destination entity Id.
Related
functions usage void Send_message();

Common constants and declarations : services.h

Common objects : server context.

*--------------------------------------------------------------------------*/

void sm_copy_received_msg_and_send (code, to)
	code_t		code;					/* primitive code */
	ent_id_t    to;						/* destination entity */
{

	if (Entity_in_system (to) == ON) {

			/* Save the current received message in a new one (send) */

		S_msg_alloc;

		Memcpy_far ((char FAR *)p_snd_msg, (char FAR *)p_rcv_msg, (ushort)(MESSAGE_HEADER_SIZE + R_msg_data_size));

			/* Send the message */

		S_msg_code 	= code;
		S_msg_from 	= ENT_SM;
		S_msg_to	= to;

		Send_message (p_snd_msg); p_snd_msg = P_NIL;
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				sm_var_init - init of SM entity's global variables.

Usage            	void sm_var_init ();

Return value :		void

*---------------------------------------------------------------------------*/

void sm_var_init ()
{
	sm_init_flag				= OFF;
	sm_config_wait_entity_id 	= ENT_NIL;

#if API_CONFIG_UPDATE_MANAGEMENT == ON /* { */

	sm_set_config_rq.p_first    =
	sm_set_config_rq.p_last     = P_NIL;

	sm_api_config_update        = OFF;

#endif /* } */

#if OM_CODE_TYPE == OM_PIC

    	      /* init configuration descriptors */

    pic_init_config_descriptors();

#endif

}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				sm_init_update_par

					Computes the size of the SM RAM memory, reserves and
					resets it.

Usage            	uchar sm_init_update_par ();

Return value :		OK/NOK

*---------------------------------------------------------------------------*/

#if CONFIG_UPDATE_MANAGEMENT == ON	/* { */

uchar sm_init_update_par ()
{
	uint							 size;						/* size of the memory */
	struct mem_param_descriptor FAR *p_mem_param_descriptor;	/* memory parameter descriptor */

		/* 1. Reserve fields for SM RAM management */

	size                   = P_REL_ADD_FIRST_PARAM;

		/* 2. Add needed size out of the 'p_mem_param[]' table */

	p_mem_param_descriptor = (struct mem_param_descriptor FAR *)&p_mem_param [0];

	while (Mem_param_id != UPDATE_ID_NIL) {
		 size += Mem_param_size;
		 ++p_mem_param_descriptor;
	}

		/* 3. Reserve and reset total SM RAM memory */

	return (sm_mem_init (size));
}

#endif /* } CONFIG_UPDATE_MANAGEMENT == ON */

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				sm_set_update_par

					Writes an update value into the SM RAM memory, using
					packing algorithms depending on the representation given
					by the 'p_mem_param[]' table.

Usage            	uchar sm_set_update_par (uint update_id,
											 uchar FAR *p_update);
						update_id: update id,
						p_update : address of the update command 'size' field:

					*                   p_update----+
					*                               |
					*                               V
					*   |                    |               |           |
					*   | update-id (2bytes) | size (1 byte) | value.... |
					*   |                    |               |           |


Return value :		OK/NOK

*---------------------------------------------------------------------------*/

#if CONFIG_UPDATE_MANAGEMENT == ON	/* { */

uchar sm_set_update_par (update_id, p_update)
	ushort		 					 update_id;					/* Update Id */
	uchar						FAR	*p_update;					/* parameter address : length + value */
{
	uint							 p_rel_add;					/* relative address */
	struct mem_param_descriptor FAR *p_mem_param_descriptor;	/* memory parameter descriptor */
	uchar							 profile;					/* profile number */
	uchar							 upd_size;				/* parameter length */
	uchar						FAR	*p_upd_val;					/* parameter value address */
	uchar							 uchar_var;					/* 'char' variable' */
	ushort							 ushort_var;				/* 'short' variable' */
	uint							 uint_var;					/* 'int' variable' */
	ulong							 ulong_var;					/* 'long' variable' */
	uchar							 i;
	uchar							 j;

	switch (update_id) {

			/* Reserved update-ids */

		case UPDATE_START_CONFIG_ID :
			break;

		case UPDATE_STOP_CONFIG_ID :

			if (*p_update == NOK) {
				profile = PROFILE_NIL;
				return (sm_mem_write (P_REL_ADD_PROFILE, &profile, PROFILE_SIZE, OFF));
			}

			break;

		case UPDATE_SELECT_PROFILE_ID :
			return (sm_mem_write (P_REL_ADD_PROFILE,
								  p_update + sizeof (((struct sm_update *)P_NIL)-> data_length),
								  PROFILE_SIZE, OFF));

		case UPDATE_STORE_PROFILE_ID :
			break;

			/* Not reserved update-id: */

		default :

				/*
					Search the Update ID in the list and
					compute its relative position in the memory.
				*/

				/* Skip reserved fields in the SM RAM memory */

			p_rel_add              	= P_REL_ADD_FIRST_PARAM;

				/* Get address of the first update-id description in 'p_mem_param[]' */

			p_mem_param_descriptor 	= (struct mem_param_descriptor FAR *)&p_mem_param [0];

				/* Get update size */

			upd_size				= *p_update;

				/* Get address of update value */

			p_upd_val				= p_update + PARAM_LENGTH_SIZE;

				/* Search for the update id in the 'p_mem_param[]' table */

			while ((Mem_param_id != UPDATE_ID_NIL) &&
				   (Mem_param_id != update_id)) {
				p_rel_add += Mem_param_size;
				++p_mem_param_descriptor;
			}

			if (Mem_param_id != UPDATE_ID_NIL) {

					/*
						Found: process value according to the given
						'representation', used to pack the data so that it
						takes less room in the SM RAM.
					*/

				switch (Mem_param_repr) {

							/*-------------------------------------------
								String of bytes:
								----------------
								no packing is computed.
							*/

					default:
					case MEM_PARAM_BYTE_STRING:

						if (upd_size > Mem_param_size) {

								/*
									The given update is too large:
									ignore the update command
								*/

							return (NOK);
						}

							/*
								Write update size and value in the SM RAM:
								try to write the value first to be sure that
								the SM RAM is large enough, then write the size
							*/

							/* 1. Write update value in the SM RAM */

						if (sm_mem_write (p_rel_add + PARAM_LENGTH_SIZE, p_upd_val, upd_size, ON) != OK) {
							return (NOK);
						}

							/* 2. And write update size in the SM RAM */

						return (sm_mem_write (p_rel_add, p_update, PARAM_LENGTH_SIZE, OFF));

							/*-------------------------------------------
								String of packed digits:
								------------------------
								pack the digits into bytes: two digits per byte.
							*/

					case MEM_PARAM_PACKED_DIGIT_STRING:

						if (upd_size == 0) {

								/* Empty string: write FF to specify that it is present */

							uchar_var	= 0xFF;
							return (sm_mem_write (p_rel_add, (uchar FAR *)&uchar_var, PARAM_LENGTH_SIZE, OFF));
						}

							/* Compute useful update size, without terminating '\0' */
							/* That is, the actual number of digits */

						for (i = 0; i < upd_size; ++i) {

							if (p_upd_val [i] == '\0') {
								upd_size	= i;
								break;
							}
						}

							/* Check size */

						if (Mem_param_size < Stored_packed_digits_sizeof (upd_size)) {

								/*
									The given update is too large:
									ignore the update command
								*/

							return (NOK);
						}

							/* Compute first byte */

						if (upd_size == 0) {
							ushort_var	= Byte_from_nibbles (upd_size + 1, 0xF);
							i 			= 1;

						} else if ((upd_size + 1) <= 0x0C) {
							ushort_var  = Byte_from_nibbles (upd_size + 1, Sm_asc_digit_to_nibble (p_upd_val [0]));
							i 			= 1;

						} else {

							ushort_var	= Byte_from_nibbles (0x0E - ((upd_size + 1) & 1), ((upd_size + 1) - 0x0D) / 2);
							i			= 0;
						}

							/* write packed digits, two digits per byte */

						for (j = 1; i < upd_size; ++i, ++j) {

							if (i == upd_size - 1) {
								uchar_var   = Byte_from_nibbles (Sm_asc_digit_to_nibble (p_upd_val [i]),
																 0x0F);
							} else {
								uchar_var	= Byte_from_nibbles (Sm_asc_digit_to_nibble (p_upd_val [i]),
																 Sm_asc_digit_to_nibble (p_upd_val [i + 1]));
								++i;
							}

							sm_mem_write (p_rel_add + j, (uchar FAR *)&uchar_var, 1, ON);
						}

							/* Finally, write first byte */

						uchar_var	= ushort_var;

						return (sm_mem_write (p_rel_add, (uchar FAR *)&uchar_var, 1, OFF));

							/*-------------------------------------------
								Integer in range [0..253]:
								--------------------------
							*/

					case MEM_PARAM_INTEGER_0_FD:

						if (upd_size == 0) {

								/* Empty string: write FF to specify that it is present */

							uchar_var	= 0xFF;
							return (sm_mem_write (p_rel_add, (uchar FAR *)&uchar_var, PARAM_LENGTH_SIZE, OFF));
						}

						if (upd_size == sizeof (ulong)) {
							Memcpy_far ((char FAR *)&ulong_var, (char FAR *)p_upd_val, sizeof (ulong));
							uchar_var	= (uchar)ulong_var;

						} else if (upd_size == sizeof (uint)) {
							Memcpy_far ((char FAR *)&uint_var, (char FAR *)p_upd_val, sizeof (uint));
							uchar_var	= (uchar)uint_var;

						} else if (upd_size == sizeof (ushort)) {
							Memcpy_far ((char FAR *)&ushort_var, (char FAR *)p_upd_val, sizeof (ushort));
							uchar_var	= (uchar)ushort_var;

						} else if (upd_size == sizeof (uchar)) {
							Memcpy_far ((char FAR *)&uchar_var, (char FAR *)p_upd_val, sizeof (uchar));

						} else { 		/* process like a char */
							Memcpy_far ((char FAR *)&uchar_var, (char FAR *)p_upd_val + upd_size - 1, sizeof (uchar));
							upd_size		= sizeof (uchar);
						}

							/* Convert 'natural' representation to 'stored' representation */

						if (uchar_var > 0xFD) {
							return (NOK);
						}

						uchar_var	= Nat_to_int_0_FD (uchar_var);

							/* Write byte */

						return (sm_mem_write (p_rel_add, (uchar FAR *)&uchar_var, 1, OFF));

							/*-------------------------------------------
								Integer in range [0..62023]:
								----------------------------
							*/

					case MEM_PARAM_INTEGER_0_FDFF:

						if (upd_size == 0) {
							ushort_var	= (ushort)(~0);
							return (sm_mem_write (p_rel_add,
												  (uchar FAR *)&ushort_var,
												  sizeof (short), OFF));
						}

						if (upd_size == sizeof (ulong)) {
							Memcpy_far ((char FAR *)&ulong_var, (char FAR *)p_upd_val, sizeof (ulong));
							ushort_var	= ulong_var;

						} else if (upd_size == sizeof (uint)) {
							Memcpy_far ((char FAR *)&uint_var, (char FAR *)p_upd_val, sizeof (uint));
							ushort_var	= uint_var;

						} else if (upd_size == sizeof (ushort)) {
							Memcpy_far ((char FAR *)&ushort_var, (char FAR *)p_upd_val, sizeof (ushort));

						} else if (upd_size == sizeof (uchar)) {
							Memcpy_far ((char FAR *)&uchar_var, (char FAR *)p_upd_val, sizeof (uchar));
							ushort_var	= uchar_var;

						} else if (upd_size < sizeof (ushort)) { 		/* process like a char */
							Memcpy_far ((char FAR *)&uchar_var, (char FAR *)p_upd_val + upd_size - 1, sizeof (uchar));
							ushort_var		= uchar_var;
							upd_size		= sizeof (uchar);

						} else { 		/* process like a short */
							Memcpy_far ((char FAR *)&ushort_var, (char FAR *)p_upd_val + upd_size - sizeof (short), sizeof (ushort));
							upd_size		= sizeof (ushort);
						}

							/* Convert 'natural' representation to 'stored' representation */

						if (ushort_var > 0xFDFF) {
							return (NOK);
						}

						ushort_var	= Nat_to_int_0_FDFF (ushort_var);

							/* Write two bytes */

						return (sm_mem_write (p_rel_add, (uchar FAR *)&ushort_var, 2, OFF));

				} /* end switch */

			} /* end if */

			return (NOK);

	} /* end switch */

	return (OK);
}

#endif /* } CONFIG_UPDATE_MANAGEMENT == ON */

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				sm_move_update_par

					Reads an update value from the SM RAM memory
					previously stored using 'sm_set_update_par()'

Usage            	uchar sm_move_update_par (uint update_id,
											  uchar FAR *p_update,
											  short max_size);
						update_id: update id,
						p_update : address of the update command 'size' field:
						max_size : maximum retrieved size

					*                   p_update----+
					*                               |
					*                               V
					*   |                    |               |           |
					*   | update-id (2bytes) | size (1 byte) | value.... |
					*   |                    |               |           |


Return value :		size of the retrieved update value.

*---------------------------------------------------------------------------*/

#if CONFIG_UPDATE_MANAGEMENT == ON	/* { */

uchar sm_move_update_par (update_id, p_update, max_size)
	ushort		 					 update_id;				/* update ID */
	uchar						FAR	*p_update;				/* return address */
	ushort		 					 max_size;				/* parameter max size */
{
	uint							 p_rel_add;             /* relative address */
	struct mem_param_descriptor FAR *p_mem_param_descriptor;/* memory descriptor current pointer */
	uchar							 param_size;			/* memory parameter size */
	uchar		 					 profile;			 	/* current profile */
	uchar							 first_octet;			/* first stored byte */
	uchar							 format_integer;		/* ON if integer to format */
	char							 char_var;				/* 'char' variable' */
	short							 short_var;				/* 'short' variable' */
	int								 int_var;				/* 'int' variable' */
	long							 long_var;				/* 'long' variable' */
	uchar							 left_nibble;
	uchar							 right_nibble;
	uchar							 i;


	if (max_size == 0) {
		return (0);
	}
		/* Read the current profile value */

	if (sm_mem_read (&profile, P_REL_ADD_PROFILE, PROFILE_SIZE) == NOK) {
		return (0);
	}

		/* If NIL return NULL value */

	if (profile == PROFILE_NIL) {
		return (0);
	}

		/* Skip reserved fields in the SM RAM memory */

	p_rel_add              	= P_REL_ADD_FIRST_PARAM;

		/* Get address of the first update-id description in 'p_mem_param[]' */

	p_mem_param_descriptor 	= (struct mem_param_descriptor FAR *)&p_mem_param [0];

		/* Search for the update id in the 'p_mem_param[]' table */

	while ((Mem_param_id != UPDATE_ID_NIL) &&
		   (Mem_param_id != update_id)) {
		p_rel_add += Mem_param_size;
		++p_mem_param_descriptor;
	}

	if (Mem_param_id != UPDATE_ID_NIL) {

		format_integer	= OFF;

		switch (Mem_param_repr) {

			default:
			case MEM_PARAM_BYTE_STRING:			/* String of bytes */

					/* Read stored size */

				if (sm_mem_read (&param_size, p_rel_add, PARAM_LENGTH_SIZE) == OK) {

					/* Read the parameter value if the size is OK */

					if ((param_size != 0) && (param_size != 0xFF) &&
						(param_size <= max_size)) {

						sm_mem_read (p_update, p_rel_add + PARAM_LENGTH_SIZE, param_size);

							/* Return the actual size */

						return (param_size);
					}
				}

				return (0);

			case MEM_PARAM_PACKED_DIGIT_STRING:	/* String of packed digits */

					/* Read first octet */

				if (sm_mem_read (&first_octet, p_rel_add, 1) != OK) {
					return (0);
				}

				if ((first_octet == 0) || (first_octet == 0xFF)) {
					return (0);
				}

					/* Compute number of digits stored (without terminating '\0') */

				left_nibble		= Left_nibble (first_octet);
				right_nibble	= Right_nibble (first_octet);

				if (left_nibble <= 0x0C) {
					param_size	= left_nibble;

				} else if (left_nibble == 0x0F) {
					return (0);		/* reserved for future use */

				} else if (right_nibble < 0x0F) {
					param_size	= left_nibble + 2 * right_nibble;

				} else {
					return (0);		/* reserved for future use */
				}

				if (param_size == 0) {
					return (0);
				}

				if (param_size > max_size) {
					return (0);
				}

				--param_size;

				if (param_size == 0) {
					i	= 0;

				} else if ((param_size + 1) <= 0x0C) {	/* 'short' representation */
					i	= 1;
					*p_update++ = Sm_nibble_to_asc_digit (right_nibble);

				} else {
					i	= 0;
				}

				for ( ; i < param_size; ++i) {
					sm_mem_read (&first_octet, ++p_rel_add, 1);
					left_nibble		= Left_nibble (first_octet);
					right_nibble	= Right_nibble (first_octet);
					*p_update++		= Sm_nibble_to_asc_digit (left_nibble);

					if (++i < param_size) {
						*p_update++	= Sm_nibble_to_asc_digit (right_nibble);
					}

				} /* end for */

				*p_update	= '\0';

					/* Return number of bytes (with terminating '\0') */

				return (1 + param_size);

			case MEM_PARAM_INTEGER_0_FD:		/* Integer in 0..253 */

					/* Read first octet */

				if (sm_mem_read (&first_octet, p_rel_add, 1) != OK) {
					return (0);
				}

				if ((first_octet == 0) || (first_octet == 0xFF)) {
					return (0);
				}

					/* Convert from stored representation to 'natural' representation */

				long_var		= Int_0_FD_to_nat (first_octet);

					/* Convert 'natural' representation, according to max_size */
					/* No 'switch' for portability */

				format_integer	= ON;

				if (max_size == sizeof (char)) {
					char_var	= (char) long_var;

				} else if (max_size == sizeof (short)) {
					short_var	= (short) long_var;

				} else if (max_size == sizeof (int)) {
					int_var	= (int) long_var;

				} else if (max_size == sizeof (long)) {
					;

				} else {							/* Process like a char */
					max_size 	= sizeof (char);
					char_var	= (char) long_var;
				}

				break;

			case MEM_PARAM_INTEGER_0_FDFF:		/* Integer in 0..62023 */

					/* Read the stored value */

				sm_mem_read ((uchar FAR *)&short_var, p_rel_add, sizeof (short));

					/* Check if stored value is empty */

				if ((short_var == 0) || (short_var == (short)(~0))) {
					return (0);
				}

					/* Convert from stored representation to 'natural' representation */

				long_var		= Int_0_FDFF_to_nat (short_var);

					/* Convert 'natural' representation, according to max_size */
					/* No 'switch' for portability */

				format_integer	= ON;

				if (max_size == sizeof (char)) {
					char_var	= (char) long_var;

				} else if (max_size == sizeof (short)) {
					short_var	= (short) long_var;

				} else if (max_size == sizeof (int)) {
					int_var	= (int) long_var;

				} else if (max_size == sizeof (long)) {
					;

				} else if (max_size < sizeof (short)) {	/* Process like a char */
					max_size 	= sizeof (char);
					char_var	= (char) long_var;

				} else {									/* Process like a short */
					max_size 	= sizeof (short);
					short_var	= (short) long_var;
				}

				break;

		} /* end switch */

		if (format_integer == ON) {

			if (max_size == sizeof (char)) {
				Memcpy_far ((char FAR *)p_update, &char_var, sizeof (char));

			} else if (max_size == sizeof (short)) {
				Memcpy_far ((char FAR *)p_update, (char FAR *)&short_var, sizeof (short));

			} else if (max_size == sizeof (int)) {
				Memcpy_far ((char FAR *)p_update, (char FAR *)&int_var, sizeof (int));

			} else if (max_size == sizeof (long)) {
				Memcpy_far ((char FAR *)p_update, (char FAR *)&long_var, sizeof (long));

			} else {
				max_size	= 0;		/* Should not happen */
			}

			return (max_size);

		} /* end if 'format integer' */

		return (0);						/* Should not happen */

	} /* end if */

		/* Return NULL value */

	return (0);
}

#endif /* } CONFIG_UPDATE_MANAGEMENT == ON */

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				sm_move_config_par

					Reads an update value from the SM RAM memory
					previously stored using 'sm_set_config_par()'

Usage            	uchar sm_move_config_par (uint update_id,
											  uchar FAR *p_update,
											  short max_size);
						update_id: update id,
						p_update : address of the update command 'size' field:
						max_size : maximum retrieved size

					*                   p_update----+
					*                               |
					*                               V
					*   |                    |               |           |
					*   | update-id (2bytes) | size (1 byte) | value.... |
					*   |                    |               |           |


Return value :		size of the retrieved update value.

*---------------------------------------------------------------------------*/

#if CONFIG_UPDATE_MANAGEMENT == ON	/* { */

uchar sm_move_config_par (update_id, p_update, max_size)
	ushort		 					update_id;				/* update ID */
	uchar						FAR	*p_update;				/* return address */
	ushort		 					max_size;				/* parameter max size */
{
	struct config_descriptor 	FAR *p_config_descriptor;
	struct cfg_update			FAR *p_cfg_update;			/* configuration update list */
	uchar							 param_size;			/* memory parameter size */
	uchar		 		 	 	  	 i,j;					/* index */
	uchar						FAR *p_data;

	Sm_load_first_p_config_descriptor (&p_config_descriptor, &i);

	for ( ; (p_config_descriptor != P_NIL) && (Config_entity_id != ENT_NIL);
		 Sm_load_next_p_config_descriptor (&p_config_descriptor, &i)) {

		if ((p_cfg_update = Config_p_update) != P_NIL) {

				/*
					An update list exists for this configuration:
					process all occurencies of the update-id in the list
				*/

			for (j = 0; Cfg_update_id (j) != UPDATE_ID_NIL; j++) {

				if (Cfg_update_id (j) == update_id) {

						/* Found one occurency of the update-id in the list */

					if ((p_data = Cfg_update_p_val (j)) != P_NIL) {

						if (((param_size = Cfg_update_length (j)) != 0) && (param_size != 0xFF) &&
							(param_size <= max_size)) {

								/* Transfer the configuration value */

							Memcpy_far ((char FAR *)p_update, (char FAR *)p_data, (uint)param_size);

								/* Return the transfered size */

							return (param_size);

						} else {

							return (0);
						}

					} else {

							/* no configuration field address is given */

						return (0);
					}

				}

			}

		}

	}

		/* Not found */

	return (0);
}

#endif /* } CONFIG_UPDATE_MANAGEMENT == ON */

/*--------------------------------------------------------------------------*/
/*						SM_REPORT_IN processing								*/
/*--------------------------------------------------------------------------*/

#ifndef SM_MAX_NB_TRIGGERS
#	define	SM_MAX_NB_TRIGGERS	1
#endif

struct sm_trigger_list {
	short			nb_triggers;	/* number of triggers defined below */

	struct sm_trigger {
		ent_id_t	to_entity;		/* entity to which to forward report. 0 or ENT_NIL : no entity */

		uchar		report_type;	/* report type (REPORT_TYPE_EVENT, etc.) 0: all types */
		ent_id_t	from_entity;	/* reporting entity. 0 or ENT_NIL : all reporting entities */
		nai_t		from_nai;		/* reporting nai. NAI_NIL : all network accesses */
		sapi_t		from_sapi;		/* reporting SAPI. SAPI_NIL : all SAPs */
		add_t		from_add;		/* reporting connection id. ADD_NIL : all connections */
	} trigger [SM_MAX_NB_TRIGGERS];
};

#define	Sm_nb_triggers				(sm_p_trigger_list -> nb_triggers)

#define	Sm_trig_report_type			(p_sm_trigger -> report_type)
#define	Sm_trig_to_entity			(p_sm_trigger -> to_entity)
#define	Sm_trig_from_entity			(p_sm_trigger -> from_entity)
#define	Sm_trig_from_nai			(p_sm_trigger -> from_nai)
#define	Sm_trig_from_sapi			(p_sm_trigger -> from_sapi)
#define	Sm_trig_from_add			(p_sm_trigger -> from_add)

struct sm_trigger_list FAR *		sm_p_trigger_list;	/* SM trigger list */


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_report_init - initialize SM reporting data structures

Usage           void sm_report_init (void)

Common objects :

*--------------------------------------------------------------------------*/

void sm_report_init ()
{
	sm_p_trigger_list	= (struct sm_trigger_list FAR *) Mem_alloc (Rnd_sizeof (struct sm_trigger_list), PID_VL);
	if (sm_p_trigger_list == P_NIL) {
		return;
	}
	Memset_far ((char FAR *)sm_p_trigger_list, 0, Rnd_sizeof (struct sm_trigger_list));
	Sm_nb_triggers	= SM_MAX_NB_TRIGGERS;

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_set_report_in - process a SM_SET_REPORT_IN message

Usage           void sm_set_report_in (void)

Common objects : p_rcv_msg points to the SM_SET_REPORT_IN message
				 The message is left unchanged.

*--------------------------------------------------------------------------*/

void sm_set_report_in ()
{
	short 					 i;
	short 					 i_free;
	short 					 i_identical;
	struct sm_trigger FAR 	*p_sm_trigger;
	uchar FAR				*p_data;

	p_data      = R_a_data;

	i_free      =
	i_identical = -1;

	for (i = 0; i < Sm_nb_triggers; ++i) {
		p_sm_trigger = &sm_p_trigger_list->trigger [i];

			/* Look for a free record */

		if ((Sm_trig_to_entity == 0) ||
			(Sm_trig_to_entity == ENT_NIL)) {

			if (i_free == -1) {
				i_free	= i;			/* Free record found */
			}

			continue;
		}

			/* Look for an identical record */

		if ((Sm_trig_to_entity   == Sm_set_report_forward_entity) &&
			(Sm_trig_report_type == Sm_set_report_report_type) &&
			(Sm_trig_from_entity == Sm_set_report_origination_entity) &&
			(Sm_trig_from_nai    == Sm_set_report_origination_nai) &&
			(Sm_trig_from_sapi   == Sm_set_report_origination_sapi) &&
			(Sm_trig_from_add    == Sm_set_report_origination_add)) {

			if (i_identical == -1) {
				i_identical	= i;			/* Identical record found */
			}

		}

	} /* end for */

	if (Sm_set_report_processing == ON) {	/* start a trigger */
											/*-----------------*/
		if (i_identical == -1) { 	/* no identical record already exists */

			if (i_free != -1) {		/* a free_record exists */
				p_sm_trigger	    = &sm_p_trigger_list->trigger [i_free];

				Sm_trig_to_entity 	= Sm_set_report_forward_entity;
				Sm_trig_report_type = Sm_set_report_report_type;
				Sm_trig_from_entity = Sm_set_report_origination_entity;
				Sm_trig_from_nai	= Sm_set_report_origination_nai;
				Sm_trig_from_sapi 	= Sm_set_report_origination_sapi;
				Sm_trig_from_add 	= Sm_set_report_origination_add;
			}

		}

	} else {								/* stop a trigger */
											/*----------------*/
		if (i_identical != -1) { 			/* an identical record exists */
			Sm_trig_to_entity 	= ENT_NIL;	/* disable trigger */
		}

	}

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_report_in - process a SM_REPORT_IN message

Usage           void sm_report_in (void)

Common objects : p_rcv_msg points at the SM_REPORT_IN message
				 The message is left unchanged by the routine

*--------------------------------------------------------------------------*/

void sm_report_in ()
{
	short 					 i;
	struct sm_trigger FAR 	*p_sm_trigger;
	uchar FAR				*p_data;

	p_data = R_a_data;

	for (i = 0; i < Sm_nb_triggers; ++i) {
		p_sm_trigger = &sm_p_trigger_list->trigger [i];

		if ((Sm_trig_to_entity == 0) ||
			(Sm_trig_to_entity == ENT_NIL)) {
			continue;
		}

		if (!  ((Sm_trig_from_entity == 0) ||
				(Sm_trig_from_entity == ENT_NIL) ||
				(Sm_trig_from_entity == R_msg_from))) {
			continue;
		}

		if (!  ((Sm_trig_from_nai == NAI_NIL) ||
				(Sm_trig_from_nai == R_msg_nai))) {
			continue;
		}

		if (!  ((Sm_trig_from_sapi == SAPI_NIL) ||
				(Sm_trig_from_sapi == R_msg_sapi))) {
			continue;
		}

		if (!  ((Sm_trig_from_add == ADD_NIL) ||
				(Sm_trig_from_add == R_msg_add))) {
			continue;
		}

		if (!  ((Sm_trig_report_type == 0) ||
				(Sm_trig_report_type == Sm_report_report_type))) {
			continue;
		}

			/* Match found: forward a copy of the message, if reasonable */

		if (Congestion_busy) {
			break;
		}

		sm_copy_received_msg_and_send (R_msg_code, Sm_trig_to_entity);

	} /* end for */

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_process_config_rq - process a SM_SET_CONFIG_RQ message

Usage           void sm_process_config_rq (void)

Common objects : p_rcv_msg points at the message
				 The message is left unchanged by the routine

*--------------------------------------------------------------------------*/

#if API_CONFIG_UPDATE_MANAGEMENT == ON /* { */

void sm_process_config_rq ()
{

	struct	message FAR *p_msg;
	uchar           FAR	*p_data;

	if (p_rcv_msg != P_NIL) {

			/* save the message in requested config FIFO */

		Fifo_put_msg (&(sm_set_config_rq.p_first), &(sm_set_config_rq.p_last), p_rcv_msg);
		p_rcv_msg = P_NIL;
	}

	if (sm_api_config_update == OFF) {
		sm_api_config_update = ON;

			/* reset previous error */

		sm_api_config_cause = 0;
		sm_api_config_diag  = 0;

			/* load message to analyse */

		p_msg  = sm_set_config_rq.p_first;
		p_data = L_a_data;

			/* The received message may contain configuration update values */

		sm_trf_cfg_update_value (p_data, p_data + L_data_size);

			/* check hardware and consistency */

#       ifdef Sm_check_config_rq

			if (Sm_check_config_rq () == NOK) {

					/* reject the configuration request */

				sm_config_ret_code  = NOK;
				sm_api_config_cause = 0;
				sm_api_config_diag  = ENT_SM;
				sm_send_api_config_confirm ();
				return;
			}

#       endif

			/* load default buffers and apply updates */

		switch (sm_init (SM_CONFIG_INIT_FIRST)) {

			case STOP :
				break;

			case CONTINUE : /* Wait for SM_SET_CONFIG_CO */
				sm_init_flag = CONTINUE;
				break;
		}


	}

}

#endif /* } API_CONFIG_UPDATE_MANAGEMENT == ON */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_send_api_config_confirm - send a SM_SET_CONFIG_CO message
				to the API.

Usage           void sm_send_api_config_confirm (void)

Common objects : p_rcv_msg points at the received message,
				 sm_set_config_rq FIFO queue.

*--------------------------------------------------------------------------*/

#if API_CONFIG_UPDATE_MANAGEMENT == ON /* { */

void sm_send_api_config_confirm ()
{

	uchar FAR				*p_data;

	if (sm_api_config_update == ON) {

		sm_api_config_update = OFF;

		Fifo_get_msg       (&(sm_set_config_rq.p_first),
							&(sm_set_config_rq.p_last),
							p_snd_msg);

			/* release the buffer */

		Free_buffer        (S_msg_p_buffer);
		S_msg_p_buffer     = P_NIL;

			/* Load the confirmation structure */

		p_data 			   = S_msg_a_first_data;
		Confirm_ret_code   = sm_config_ret_code;
		Confirm_cause      = sm_api_config_cause;
		Confirm_diagnostic = sm_api_config_diag;
		S_msg_data_size    = sizeof (struct confirm);

			/* Load the message header */

		S_msg_from 		   = ENT_SM;
		S_msg_to 		   = ENT_API;
		S_msg_code         = SM_SET_CONFIG_CO;

		Send_message       (p_snd_msg);
		p_snd_msg          = P_NIL;

	}

}

#endif /* } API_CONFIG_UPDATE_MANAGEMENT == ON */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_process_next_config_rq - process next pending
				configuration requested by the API.

Usage           void sm_process_next_config_rq (void)

Common objects : sm_set_config_rq FIFO queue.

*--------------------------------------------------------------------------*/

#if API_CONFIG_UPDATE_MANAGEMENT == ON /* { */

void sm_process_next_config_rq ()
{

	if (sm_set_config_rq.p_first != P_NIL) {
		Free_msg (p_rcv_msg);
		p_rcv_msg = P_NIL;
		sm_process_config_rq ();
	}

}

#endif /* } API_CONFIG_UPDATE_MANAGEMENT == ON */

#if APPLI_RESET_CONFIG == ON

struct buffer FAR 	*p_buffer_appli_update;	/* buffer pointer containing update configuration */
uchar 			 sm_appli_nb;           

void sm_appli_save_update_par (p_data, data_size)
uchar FAR *p_data;
ushort data_size;
{
	p_buffer = Alloc_buffer();
	
	if (p_buffer != P_NIL) {
        	Memcpy_far ((char FAR *)Buffer_a_first_data,  
        		    (char FAR *)p_data,
        		    (uint)data_size);  
		Buffer_data_size = data_size;
		p_buffer_appli_update = p_buffer;
	}
}

void sm_appli_load_update_par ()
{
uchar FAR *p_data;
	
	p_buffer = p_buffer_appli_update;

	if (R_msg_p_buffer != P_NIL) {
		Free_buffer (R_msg_p_buffer);
	}  
	R_msg_init_link_buffer;		/* link the saved buffer to the received message */
}

void sm_appli_stop_rq ()
{

	struct config_descriptor FAR *p_config_descriptor;
	uint						  i;


		/* Prepare return code for STOP_CONFIG */

	sm_appli_nb 		= 0;

			/* Start of configuration */

	Sm_load_first_p_config_descriptor (&p_config_descriptor, &i);


	for ( ; (p_config_descriptor != P_NIL) && (Config_entity_id != ENT_NIL);

		 Sm_load_next_p_config_descriptor (&p_config_descriptor, &i)) {

		if ( (Entity_in_system (Config_entity_id) == ON) &&
			 (sm_appli_stop_send (Config_entity_id) != OK) ) {

			Trap (TRAP_SM_INIT, "sm_appli_stop");

		}

			/* Update the number of STOP messages sent */

		sm_appli_nb++;

	}
}

uchar sm_appli_stop_co ()
{
	if (sm_appli_nb == 99) {
		return (CONTINUE);
	}

	if (--sm_appli_nb == 0) {
		return (STOP);
			/* temporary : some entities don't send a confirm !*/
 	} else if (R_msg_from == ENT_MDL) {
 	  	sm_appli_nb = 99;
		return (STOP);

 	} else {  
		return (CONTINUE);

 	}     
}  

void sm_appli_reset_config_rq ()
{
	struct config_descriptor FAR *p_config_descriptor;
	uint			      i;


		/* Prepare return code for STOP_CONFIG */

	sm_appli_nb 		= 0;

			/* Start of configuration */

	Sm_load_first_p_config_descriptor (&p_config_descriptor, &i);


	for ( ; (p_config_descriptor != P_NIL) && (Config_entity_id != ENT_NIL);

		 Sm_load_next_p_config_descriptor (&p_config_descriptor, &i)) {

		if ( (Entity_in_system (Config_entity_id) == ON) &&
			 (sm_appli_reset_config_send (Config_entity_id) != OK) ) {

			Trap (TRAP_SM_INIT, "sm_appli_reset_config");

		}

			/* Update the number of STOP messages sent */

		sm_appli_nb++;

	}

}
/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			sm_init_send - implements the building and sending of a
							   configuration message to a layer management
							   entity.

Usage           uchar sm_init_send (to, uchar FAR *p_config, size);
					- uchar		to 			: destination entity,
					- uchar FAR *p_config 	: configuration address,
					- ushort	size 		: configuration size.

Related
functions usage ();


Description :	implements the building of a SM_SET_CONFIG_RQ message from
				the configuration structure p_config and the message
				sending to the layer management entity.

Return : return code = OK	done
					 = NOK  not done

Common constants and declarations : ctx_ext.h

Common objects :  message and buffer context.

*--------------------------------------------------------------------------*/

uchar sm_appli_stop_send (to)
	uchar		 to;			/* destination entity */
{

		/* Allocate a message if not already done */

	if (p_snd_msg == P_NIL) {
		p_snd_msg = Alloc_msg ();
	}
	if (p_snd_msg != P_NIL) { 

		/* Load the message header */

		S_msg_from 		= ENT_SM;			/* from System Management entity */
		S_msg_to 		= to;				/* to the layer Management entity */
		S_msg_nai 		= 0;				/* null network access ID */
		S_msg_sapi 		= SAPI_NIL;			/* SAPI = NIL */
		S_msg_add		= ADD_NIL;			/* address = NIL */
		S_msg_code 		= SM_STOP_RQ;			/* primitive code */


			/* Send the message and the optional linked buffer */

		Send_message (p_snd_msg); p_snd_msg = P_NIL; 
		return(OK);
	} else {
		return(NOK);
	
	}  
}

uchar sm_appli_reset_config_send (to)
	uchar		 to;			/* destination entity */
{

		/* Allocate a message if not already done */

	if (p_snd_msg == P_NIL) {
		p_snd_msg = Alloc_msg ();
	}
	if (p_snd_msg != P_NIL) { 

		/* Load the message header */

		S_msg_from 		= ENT_SM;			/* from System Management entity */
		S_msg_to 		= to;				/* to the layer Management entity */
		S_msg_nai 		= 0;				/* Nai 0 */
		S_msg_sapi 		= SAPI_NIL;			/* SAPI = NIL */
		S_msg_add		= ADD_NIL;			/* address = NIL */
		S_msg_code 		= SM_RESET_CONFIG_RQ;		/* primitive code */


			/* Send the message and the optional linked buffer */

		Send_message (p_snd_msg); p_snd_msg = P_NIL; 
		return(OK);
	} else {
		return(NOK);
	
	}  
}

uchar sm_appli_reset_config_co ()
{
	if (--sm_appli_nb == 0) {
		return (STOP);

 	} else {
		return (CONTINUE);

 	}     
}  

#endif /* APPLI_RESET_CONFIG == ON */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			 sm_load_p_config_descriptor - load a configuration
											   descriptor

Usage			 void sm_load_p_config_descriptor	(
						struct config_descriptor FAR ** p_p_descriptor,
						uchar							i)
						p_p_descriptor	: address of variable to update,
										  pointer to configuration descriptor
						i				: index of the configuration
										  descriptor to load (0 : first)

Description		load a configuration descriptor

Return value	none

*--------------------------------------------------------------------------*/

uchar		sm_cfg_i_prom;

void sm_load_p_config_descriptor (p_p_descriptor, i)
struct config_descriptor FAR **	p_p_descriptor;
uchar					i;
{
	struct config_descriptor    FAR *p_config_descriptor;
	uchar			      	 j, k;
	struct ph_d_config  	    FAR *p_ph_d_config;
    	struct ph_d_na_config       FAR *p_ph_d_na_config;  /* Na configuration pointer */

	struct ph_b_config  	    FAR *p_ph_b_config;
    	struct ph_b_config_na       FAR *p_ph_b_na_config;  /* Na configuration pointer */
	struct ph_b_config_chan     FAR *p_ph_b_chan_config;

    	if (i == 0) {
    	    sm_cfg_i_prom = 0;
    	}
	p_config_descriptor = t_config [sm_cfg_i_prom];

	/*
	 *	Build configuration structure descriptor, according to
	 *	current build state, DCE parameters and source configuration entity
	 */
	/* Standard building state */
	/*-------------------------*/
	switch (Config_entity_id) {

	default:  /* other entities */

			/* Copy source descriptor address into destination descriptor address */
			/*--------------------------------------------------------------------*/
		*p_p_descriptor	= p_config_descriptor;	++sm_cfg_i_prom;
		break;

    	case ENT_MPH_D :
    	    p_ph_d_config = (struct ph_d_config FAR *) Config_address;

    	    for (j = 0; j < Ph_d_config_na_nb; j++) {
		p_ph_d_na_config = Ph_d_config_a_na(j);

    	    	Ph_d_config_isac_base_add += (long)(isdn_card_EASI_address
    	    	    	    	    	   + ISDN_CARD_SLOT_OFFSET (isdn_card_slot_number));
#		if PH_D_U == ON
    	    		Ph_d_config_iec_base_add += (long)(isdn_card_EASI_address
    	    	    	    	    	   + ISDN_CARD_SLOT_OFFSET (isdn_card_slot_number));
#		endif    	    	    	    	    	   
    	    }

    	    *p_p_descriptor	= p_config_descriptor;	++sm_cfg_i_prom;
    	    break;

    	case ENT_MPH_B :
    	    p_ph_b_config = (struct ph_b_config FAR *) Config_address;

    	    for (j = 0; j < Ph_b_config_na_nb; j++) {

		p_ph_b_na_config = Ph_b_config_a_na(j);

		for (k = 0; k < Ph_b_config_chan_nb; k++) {
		    p_ph_b_chan_config 		= Ph_b_config_a_chan (k);
    	    	    Ph_b_config_base_address += (long) (isdn_card_EASI_address
    	    	    	    	    	      + ISDN_CARD_SLOT_OFFSET (isdn_card_slot_number));
    	    	}
    	    }

	    *p_p_descriptor	= p_config_descriptor;	++sm_cfg_i_prom;
    	    break;

	}
}



/*EOF*/
