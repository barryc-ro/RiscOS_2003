
/*--------------------------------------------------------------------------*
 *                      M O D U L E     H E A D E R
 *
 * filename - net_ie.ni1
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the meta description of all the information
 * elements and the integrity constraints associated to.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

/*
*
*Table structures :
*----------------
*
*        tabl_item   TABL_ITEM                                    uchar
*        ==========================                             ============
*        | tabl_id | size | p_val |---------------------------->|   val    |
*        --------------------------  tabl_yy      ============  ------------
*        |         |      |       |-------------->|   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |          |  |          |
*        --------------------------
*        |         |      |       |
*        --------------------------
*        |         |      |       |
*
*
*    tabx_item   TABX_ITEM                   tabx_list                uchar
*    =================================     =================        =========
*    | tabl_id | size | list pointer |---->| tabl_id | size|------->| x_val |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------
*    |         |      |              |
*
*/

/*-------------------------------------------------------------------------*/

	/*
		Initialization constants of ie internal structure
		used by SPDU received processing.
	*/

		/*  Bearer capability (BC) */

CONST   struct  i_bc    df_spdu_ni1_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
};

		/* Call state (CALL_STATE) */

CONST   struct  i_call_state    df_spdu_ni1_i_call_state = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
};

        /*  Called party number and subaddress (CALLED_NB, CALLED_SUB_ADD) */

CONST   struct  i_called_nb  df_spdu_ni1_i_called_nb = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL
};

CONST   struct  i_called_sub_add    df_spdu_ni1_i_called_sub_add = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Calling party number (CALLING_NB) */

CONST   struct  i_calling_nb    df_spdu_ni1_i_calling_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
    A_NIL
};

        /* calling party subaddress (CALLING_SUB_ADD) */

CONST   struct  i_calling_sub_add   df_spdu_ni1_i_calling_sub_add = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL
};

		/* Cause (CAUSE) */

CONST   struct  i_cause  df_spdu_ni1_i_cause = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Channel identification (CHAN_ID) */

CONST   struct  i_chan_id   df_spdu_ni1_i_chan_id = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL
};

		/* Connected number (CONN_NB) */

CONST   struct  i_conn_nb   df_spdu_ni1_i_conn_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Endpoint Identifier (ENDPOINT_ID) */

CONST   struct  i_endpoint_id df_spdu_ni1_i_endpoint_id = {
    BYTE_VAL_NIL,
    INTERPRETER_0,
    BYTE_VAL_NIL
};

		/* Feature activation (FEATURE_ACT) */

CONST   struct  i_feature_act   df_spdu_ni1_i_feature_act = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

        /* Feature indication (FEATURE_IND) */

CONST   struct  i_feature_ind   df_spdu_ni1_i_feature_ind = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

		/* High layer compatibility (HLC) */

CONST   struct  i_hlc   df_spdu_ni1_i_hlc = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Information request (INFORMATION_RQ) */

CONST   struct  i_information_rq    df_spdu_ni1_i_information_rq = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* Keypad facility (KEYPAD) */

CONST   struct  i_keypad    df_spdu_ni1_i_keypad = {
    0,
    A_NIL
};

        /* Low layer compatibility (LLC) */

CONST   struct  i_llc   df_spdu_ni1_i_llc = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

        /* Notification indicator (NOTIF_IND) */

CONST   struct  i_notif_ind  df_spdu_ni1_i_notif_ind = {
    BYTE_VAL_NIL,
    0,
    P_NIL

};

		/* Original called party number (O_CALLED_NB) */

CONST   struct  i_o_called_nb    df_spdu_ni1_i_o_called_nb = {
	NB_UNKNOWN,
	PLAN_UNKNOWN,
	PRES_ALLOWED,
	USER_PROVIDED,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Progress indicator (PROGRESS_IND) */

CONST   struct  i_progress_ind  df_spdu_ni1_i_progress_ind = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

        /* Redirecting number (REDIR_NB) */

CONST   struct  i_redir_nb  df_spdu_ni1_i_redir_nb = {
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Redirection number (REDIRECTION_NB) */

CONST   struct  i_redirection_nb    df_spdu_ni1_i_redirection_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
};

        /* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_spdu_ni1_i_restart_ind = {
    BYTE_VAL_NIL
};

        /* Service profile identification (SPID) */

CONST   struct  i_spid  df_spdu_ni1_i_spid = {
    0,
    0,
    A_NIL
};

        /*  Signal (SIGNAL) */

CONST   struct  i_signal    df_spdu_ni1_i_signal = {
    BYTE_VAL_NIL
};

		/* Transit network selection (TRANSIT_NET_SEL) */

CONST   struct  i_transit_net_sel   df_spdu_ni1_i_transit_net_sel = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
	A_NIL
};

		/* codeset 5 : Operator System Access (OS_ACCSS) */

CONST   struct  i_os_accss  df_spdu_ni1_i_os_accss = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

		/* codeset 5 : Display (DISPLAY_TXT) */

CONST   struct  i_display   df_spdu_ni1_i_display = {
	DISPLAY_TYPE_NORMAL,
	0,
	A_NIL
};

		/* codeset 6 : Call appearance (CALL_APPEARANCE) */

CONST   struct  i_call_appear   df_spdu_ni1_i_call_appear = {
    BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

        /* codeset 6 : Protocol version control (PROT_VER_CTRL) */

CONST   struct  i_prot_ver_ctrl df_spdu_ni1_i_prot_ver_ctrl = {
    VERSION_RS_N_U,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

/*=========================================================================*/

    /*
        Initialization constants of the ie internal structure
        used by SSDU received processing.
    */

        /*  Bearer capability (BC) */

CONST   struct  i_bc    df_ssdu_ni1_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    RA_56KBS,           /* Optional field */
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
};

        /* Call state (CALL_STATE) */

CONST   struct  i_call_state    df_ssdu_ni1_i_call_state = {
    BYTE_VAL_NIL,       /* Mandatory field */
    BYTE_VAL_NIL,
};

		/*  Called party number and subaddress (CALLED_NB, CALLED_SUB_ADD) */

CONST   struct  i_called_nb  df_ssdu_ni1_i_called_nb = {
    BYTE_VAL_NIL,       /* Mandatory field */
    BYTE_VAL_NIL,       /* Mandatory field */
    0,
    A_NIL
};

CONST   struct  i_called_sub_add    df_ssdu_ni1_i_called_sub_add = {
    BYTE_VAL_NIL,       /* Mandatory field */
    BYTE_VAL_NIL,       /* Mandatory field */
	BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Calling party number (CALLING_NB) */

CONST   struct  i_calling_nb    df_ssdu_ni1_i_calling_nb = {
	NB_UNKNOWN,
	PLAN_UNKNOWN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
    A_NIL
};

        /* calling party subaddress (CALLING_SUB_ADD) */

CONST   struct  i_calling_sub_add   df_ssdu_ni1_i_calling_sub_add = {
    BYTE_VAL_NIL,       /* Mandatory field */
    BYTE_VAL_NIL,       /* Mandatory field */
    BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Cause (CAUSE) */

CONST   struct  i_cause  df_ssdu_ni1_i_cause = {
    BYTE_VAL_NIL,       /* Mandatory field */
    LOCATION_USER,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,       /* Mandatory field */
	BYTE_VAL_NIL,       /* Mandatory field */
    BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Channel identification (CHAN_ID) */

CONST   struct  i_chan_id   df_ssdu_ni1_i_chan_id = {
    INT_ID_IMPLICIT,
    INT_TYPE_BRI,
    CHAN_PREF,
	NOT_D_CHAN,
    AS_INDICATED,
    BYTE_VAL_NIL,
    CODING_STD_CCITT,
    CHAN_NUMBER,
    B_CHAN,
    BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Connected number (CONN_NB) */

CONST   struct  i_conn_nb   df_ssdu_ni1_i_conn_nb = {
	NB_UNKNOWN,
	PLAN_UNKNOWN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};


		/* Feature activation (FEATURE_ACT) */

CONST   struct  i_feature_act   df_ssdu_ni1_i_feature_act = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

        /* Feature indication (FEATURE_IND) */

CONST   struct  i_feature_ind   df_ssdu_ni1_i_feature_ind = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL
};

        /* High layer compatibility (HLC) */

CONST   struct  i_hlc   df_ssdu_ni1_i_hlc = {
    CODING_STD_CCITT,
    INTER_CCITT_CEPT,
    PRESENTATION_PROFIL,
    BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

        /* Information request (INFORMATION_RQ) */

CONST   struct  i_information_rq    df_ssdu_ni1_i_information_rq = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Keypad facility (KEYPAD) */

CONST   struct  i_keypad    df_ssdu_ni1_i_keypad = {
	0,
	A_NIL
};

		/* Low layer compatibility (LLC) */

CONST   struct  i_llc   df_ssdu_ni1_i_llc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	OUT_BAND_NOT_POSSIBLE,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Notification indicator (NOTIF_IND) */

CONST   struct  i_notif_ind  df_ssdu_ni1_i_notif_ind = {
	BYTE_VAL_NIL,
	0,
	P_NIL

};

		/* Original called party number (O_CALLED_NB) */

CONST   struct  i_o_called_nb    df_ssdu_ni1_i_o_called_nb = {
	NB_UNKNOWN,
	PLAN_UNKNOWN,
	PRES_ALLOWED,
	USER_PROVIDED,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Progress indicator (PROGRESS_IND) */

CONST   struct  i_progress_ind  df_ssdu_ni1_i_progress_ind = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

        /* Redirecting number (REDIR_NB) */

CONST   struct  i_redir_nb  df_ssdu_ni1_i_redir_nb = {
    NB_UNKNOWN,
    PLAN_UNKNOWN,
	PRES_ALLOWED,
	USER_PROVIDED,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Redirection number (REDIRECTION_NB) */

CONST   struct  i_redirection_nb    df_ssdu_ni1_i_redirection_nb = {
	PLAN_UNKNOWN,
	NB_UNKNOWN,
	0,
	A_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_ssdu_ni1_i_restart_ind = {
	RI_ALL_INTERFACES
};

		/* Service profile identification (SPID) */

CONST   struct  i_spid  df_ssdu_ni1_i_spid = {
	0,
    0,
	A_NIL
};

		/*  Signal (SIGNAL) */

CONST   struct  i_signal    df_ssdu_ni1_i_signal = {
	BYTE_VAL_NIL        /* Mandatory field */
};

		/* Transit network selection (TRANSIT_NET_SEL) */

CONST   struct  i_transit_net_sel   df_ssdu_ni1_i_transit_net_sel = {
	NATIONAL_NETWORK_ID_TYPE,
	CARRIER_ID_CODE,
	3,
	A_NIL
};

		/* codeset 5 : Operator System Access (OS_ACCSS) */

CONST   struct  i_os_accss  df_ssdu_ni1_i_os_accss = {
	SERVICE_TYPE_UNSPECIFIED,
	BYTE_VAL_NIL
};

		/* codeset 5 : Display (DISPLAY_TXT) */

CONST   struct  i_display   df_ssdu_ni1_i_display = {
	DISPLAY_TYPE_NORMAL,
	0,
	A_NIL
};

		/* codeset 6 : Call appearance (CALL_APPEARANCE) */

CONST   struct  i_call_appear   df_ssdu_ni1_i_call_appear = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* codeset 6 : Protocol version control (PROT_VER_CTRL) */

CONST   struct  i_prot_ver_ctrl df_ssdu_ni1_i_prot_ver_ctrl = {
	VERSION_QUERY_U_N,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

/*=========================================================================*/

				/*-------------------------------*/
				/* TABLES : list of valid values */
				/*-------------------------------*/

					/* Assignor/Assignee (ie LLC) */

CONST   uchar NI1_ASSIGN_S[] = {
	DEFAULT_ASSIGNEE,
	ASSIGNOR_ONLY,
	};

					/* In-band/Out_band negotiation (ie LLC) */

CONST   uchar NI1_BAND_S[] = {
    TSC,
    LL0,
    };

                    /* Layer 1 protocol identifier (ie BC) */

CONST   uchar NI1_BC_PROTOCOL_ID_1_S[] = {
    PROTOCOL_ID_1_V110,
    PROTOCOL_ID_1_G711_u,
    PROTOCOL_ID_1_7KHZ,
    };

                    /* Cause class (ie CAUSE) */

CONST   uchar NI1_C_C_S[]={
    C_C_NORMAL_EVENT_0,
    C_C_NORMAL_EVENT,
    C_C_RESOURCE_UNAVAILABLE,
    C_C_SERVICE_NOT_AVAILABLE,
    C_C_SERVICE_NOT_IMPLEMENTED,
    C_C_INVALID_MESSAGE,
    C_C_PROTOCOL_ERROR,
    C_C_INTERWORKING,
    };

                    /* Automata call state values (ie CALL_STATE) */

CONST   uchar NI1_CALL_STATE_VAL_S[] = {
    STATE_NULL_0,
	STATE_CALL_INIT_1,
    STATE_OVERLAP_SENDING_2,
    STATE_OUTGOING_CALL_PROC_3,
    STATE_CALL_DELIVERED_4,
    STATE_CALL_PRESENT_6,
    STATE_CALL_RECEIVED_7,
    STATE_CONNECT_REQUEST_8,
    STATE_INCOMING_CALL_PROC_9,
    STATE_ACTIVE_10,
    STATE_DISCONNECT_REQUEST_11,
    STATE_DISCONNECT_INDICATION_12,
    STATE_RELEASE_REQUEST_19,
    STATE_CALL_INDEPENDENT_31,
    };

                    /* Coding standard (ie CAUSE) */

CONST   uchar NI1_CAUSE_CODING_STD_S[] = {
    CODING_STD_CCITT,
    CODING_STD_SPF,
    };

                    /* Channel interface ID (ie CHAN_ID) */


CONST   uchar NI1_CHAN_INT_S[] = {
    INT_ID_IMPLICIT,
    INT_ID_EXPLICIT,
    };

                    /* Channel interface ID value (ie CHAN_ID) */


CONST   uchar NI1_CHAN_INT_VALUE_S[] = {
    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
    25,26,27,28,29,30,31
    };

					/* Channel number (CHAN_ID) */

CONST   uchar NI1_CHAN_NUMBER_S[] = {
    1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
    17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
};

					/* D-channel indicator (ie CHAN_ID) */

CONST   uchar NI1_D_CHAN_S[] = {
    D_CHAN,
    NOT_D_CHAN,
    };
                    /* Preferred/exclusive (ie CHAN_ID) */

CONST   uchar NI1_CHAN_PREF_EXCL_S[] = {
    CHAN_PREF,
    CHAN_EXCL,
	};

					/* Display type (ie DISPLAY) */

CONST	uchar	NI1_DISPLAY_TYPE_S[] = {
	DISPLAY_UNKNOWN,
	DISPLAY_CALLING_PARTY,
	DISPLAY_CONNECTED_PARTY,
	DISPLAY_O_CALLED_PARTY,
	};
					/* Display associated info (ie DISPLAY) */

CONST	uchar	NI1_ASSOC_INFO_S[] = {
	ASSOC_INFO_UNDEFINED,
	ASSOC_INFO_REQUESTED,
	ASSOC_INFO_INCLUDED,
	};

					/* Coding standard (ie HLC, LLC, PROGRESS_IND) */

CONST   uchar NI1_CODING_STD_S[] = {
	CODING_STD_CCITT,
	CODING_STD_RESERVED,
	CODING_STD_NATIONAL,
	CODING_STD_SPF,
	};

					/* Data bit format (ie LLC) */

CONST   uchar NI1_DATA_BIT_S[] = {
	DATA_BIT_UNUSED,
	DATA_BIT_5,
	DATA_BIT_7,
	DATA_BIT_8,
	};

					/* Duplex/half-duplex (ie LLC) */

CONST   uchar NI1_DUPLEX_S[] = {
	HALF_DUPLEX,
	FULL_DUPLEX,
	};


CONST   uchar NI1_FLOW_CONTROL_RX_S[] = {
    FLOW_CAN_ACCEPT_DATA,
    FLOW_CANNOT_ACCEPT_DATA,
    };

                    /* Flow control on Transmission (Tx) (ie LLC) */

CONST   uchar NI1_FLOW_CONTROL_TX_S[] = {
    FLOW_NOT_RQ_TX_DATA,
    FLOW_RQ_TX_DATA,
    };

					/* Rate adaption header/no header (ie LLC) */

CONST   uchar NI1_HEADER_S[] = {
    HEADER_NOT_INCLUDED,
    HEADER_INCLUDED,
    };

                    /* Information request indicator (ie INFORMATION_RQ) */

CONST   uchar NI1_INFO_IND_S[] = {
    INFO_RQ_COMPLETED,
    PROMPT_FOR_ADD_INFO,
    };

					/* Information type (ie INFORMATION_RQ) */

CONST   uchar NI1_INFO_TYPE_S[] = {
	INFO_TYPE_UNDEFINED,
	INFO_TYPE_TERMINAL_ID,
	};

					/* Information specific (ie INFORMATION_RQ) */

CONST	uchar NI1_INFO_SPECIF_S[] = {
	SPECIF_DIALED_NB,
	SPECIF_CALLING_NB,
	SPECIF_CONN_NB,
	SPECIF_REDIRECTING_NB,
	SPECIF_REDIRECTION_NB,
	SPECIF_REDIRECTING_NB_NO_IND,
	SPECIF_REDIRECTION_NB_NO_IND,
	SPECIF_INFO_DENIED,
	SPECIF_INFO_NOT_AVAILABLE,
	};
					/* Interface type (ie CHAN_ID) */

CONST   uchar NI1_INT_TYPE_S[] = {
	INT_TYPE_BRI,
	INT_TYPE_PRI,
	};

					/* Intermediate rate (V110) (ie LLC) */

CONST   uchar NI1_INTER_RATE_S[] = {
	INTER_RA_UNUSED,
	INTER_RA_8KBS,
	INTER_RA_16KBS,
	INTER_RA_32KBS,
	};

                    /* Interpreter flag in Endpoint ID */

CONST   uchar NI1_INTERPRETER_S[] = {
    INTERPRETER_0,
    INTERPRETER_1,
    };

                    /* Logical Link Identifier negotiation (ie LLC) */

CONST   uchar NI1_LLI_S[] = {
    DEFAULT_LLI,
    FULL_PROTOCOL_LLI,
    };

                    /* Cause location (ie CAUSE) */

CONST   uchar NI1_LOCATION_S[] = {
    LOCATION_USER,
	LOCATION_PR_NET_LOC_USER,
	LOCATION_PU_NET_LOC_USER,
	LOCATION_TRANSIT_NET,
	LOCATION_PU_NET_REMOTE_USER,
	LOCATION_PR_NET_REMOTE_USER,
	LOCATION_INTERNATIONAL_NET,
	LOCATION_NET_NTWK_POINT
    };

                    /* Modem type (ie LLC) */

CONST   uchar NI1_MODEM_S[] = {
    MODEM_RESERVED,
    MODEM_V21,
    MODEM_V22,
    MODEM_V22_BIS,
    MODEM_V23,
    MODEM_V26,
    MODEM_V26_BIS,
    MODEM_V26_TER,
    MODEM_V27,
    MODEM_V27_BIS,
    MODEM_V27_TER,
    MODEM_V29,
    MODEM_V32,
	MODEM_V35,
    };

                    /* Multi frame establishment support in Data Link (ie LLC) */

CONST   uchar NI1_MULTI_FRAME_S[] = {
    MULTI_FRAME_NOT_SUPPORTED,
    MULTI_FRAME_SUPPORTED,
    };

					/* Numbering plan (ie CALLED_NB) */

CONST   uchar NI1_NB_PLAN_S[] = {
    PLAN_UNKNOWN,
	PLAN_ISDN,
	PLAN_DATA,
	PLAN_PRIVATE,
	};

					/* Numbering type (ie CALLED_NB) */

CONST   uchar NI1_NB_TYPE_S[] = {
	NB_UNKNOWN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
	NB_NET_SPF,
	NB_SUBSCRIBER,
	NB_ABBREVIATED,
	};

                    /* In-band negotiation (V110 or V120) (ie LLC) */

CONST   uchar NI1_NEGOTIATION_S[] = {
    NEGOTIATION_IN_BAND,
    NEGOTIATION_NOT_IN_BAND,
    };

                    /* Network independent clock (NIC) (ie LLC) */

CONST   uchar NI1_NIC_RX_S[] = {
    NIC_ACCEPT_DATA,
    NIC_NOT_ACCEPT_DATA,
    };

                    /* Network independent clock (NIC) (ie LLC) */

CONST   uchar NI1_NIC_TX_S[] = {
    NIC_RQ_TX_DATA,
    NIC_NOT_RQ_TX_DATA,
    };

                    /* Notification indicator description (ie NOTIF_IND) */

CONST   uchar NI1_NOTIF_IND_DESCR_S[] = {
    CONN_CONF_FAC_CONTROLLER,
	CONN_CONF_FAC_CONFEREE,
    TWO_PARTY_CALL,
    CONF_FAC_RELEASED,
    CONN_TO_EMS,
    CONN_TO_AC,
    REMOTE_PARTY_DISC,
    BRIDGED_CALL,
    CALL_NO_LONGER_BRIDGED,
    RET_HELD_CALL,
    NO_LONGER_CONN_TO_AC,
	CALL_DIVERTED,
	CONF_BRIDGE_FULL,
	CONF_BRIDGE_PORT_AVAILABLE,
	CALL_IS_WAITING,
	CALL_INFO_EVENT,
	USER_BRIDGED_ONTO_CALL,
    CALL_ON_HOLD,
    PRIVACY_ENABLED,
    PRIVACY_DISABLED,
    CALL_RET_FROM_HOLD,
    };

                    /* Mode of operation (ie LLC) */

CONST   uchar NI1_OP_MODE_S[] = {
    BIT_TRANSPARENT,
    PROTOCOL_SENSITIVE,
    };

                    /* Out-band negotiation indicator (ie LLC) */

CONST   uchar NI1_OUT_BAND_NEG_S[] =    {
    OUT_BAND_POSSIBLE,
    OUT_BAND_NOT_POSSIBLE,
    };

                    /* Parity format (ie LLC) */

CONST   uchar NI1_PARITY_S[] = {
    ODD,
    EVEN,
    NO_PARITY,
    FORCED_TO_0,
    FORCED_TO_1,
    };

                    /* Presentation indicator (ie CALLING_NB,
                        CONN_NB, REDIR_NB & REDIRECTION_NB) */

CONST   uchar NI1_PRES_IND_S[] = {
	PRES_ALLOWED,
	PRES_RESTRICTED,
	PRES_NOT_AVAILABLE,
	PRES_RESERVED
    };

                    /* Layer 1 protocol identifier (ie LLC) */

CONST   uchar NI1_PROTOCOL_ID_LLC_1_S[] = {
    PROTOCOL_ID_1_V110,
    PROTOCOL_ID_1_G711_u,
    PROTOCOL_ID_1_G711_A,
    PROTOCOL_ID_1_G721,
    PROTOCOL_ID_1_7KHZ,
    PROTOCOL_ID_1_VIDEO,
    PROTOCOL_ID_1_RA_NON_CCITT,
    PROTOCOL_ID_1_V120,
    PROTOCOL_ID_1_X31,
    };

                    /* Layer 2 protocol identifier (ie LLC) */

CONST   uchar NI1_PROTOCOL_ID_LLC_2_S[] = {
    PROTOCOL_ID_2_ISO_1745,
    PROTOCOL_ID_2_Q921,
    PROTOCOL_ID_2_X25_LL,
    PROTOCOL_ID_2_X25_ML,
    PROTOCOL_ID_2_T71,
    PROTOCOL_ID_2_HDLC_ARM,
    PROTOCOL_ID_2_HDLC_NRM,
    PROTOCOL_ID_2_HDLC_ABM,
	PROTOCOL_ID_2_LAN_LLC,
    PROTOCOL_ID_2_X75_SLP,
	};

                    /* Layer 3 protocol identifier (ie LLC)*/

CONST   uchar NI1_PROTOCOL_ID_LLC_3_S[] = {
    PROTOCOL_ID_3_Q931,
    PROTOCOL_ID_3_X25_PL,
    PROTOCOL_ID_3_ISO_8208,
    PROTOCOL_ID_3_ISO_8348,
    PROTOCOL_ID_3_ISO_8473,
	PROTOCOL_ID_3_T70,
    };

                    /* Reason for redirection (ie REDIR_NB & REDIRECTION_NB) */

CONST   uchar NI1_REASON_REDIR_S[] = {
    R_UNKNOWN,
	R_CALL_FORWARDING_BUSY,
    R_CALL_FORWARDING_NO_REPLY,
    R_CALL_TRANSFER,
    R_CALL_PICKUP,
    R_CALL_FORWARDING_UNCONDITIONAL,
    };

                    /* Screening indicator (ie CALLING_NB,
                        CONN_NB, REDIR_NB & REDIRECTION_NB) */

CONST   uchar NI1_SCREEN_IND_S[] = {
    USER_PROVIDED,
    USER_PASSED,
    USER_FAILED,
    NETWORK_PROVIDED,
    };

                    /* Signal values (ie SIGNAL) */

CONST   uchar NI1_SIGNAL_VAL_S[] = {
    DIAL_ON,
    RING_BACK_ON,
    NET_CONGEST_ON,
    BUSY_ON,
    TONES_OFF,
    PATTERN_0,
	PATTERN_2,
	PATTERN_3,
	PATTERN_4,
	PATTERN_6,
	ALERTING_OFF,
	RECALL_DIAL_TONE_ON,
	BARGE_IN_ON,
	INCOMING_ADD_CALL,
	PRIORITY_ADD_CALL,
	EXPENSIVE_ROUTE_WARNING,
	};

					/* Status indicator (ie FEATURE_IND) */

CONST   uchar NI1_STATUS_IND_S[] = {
    STAT_DEACTIVATED,
    STAT_ACTIVATED,
    STAT_PROMPT,
	STAT_PENDING,
	};

                    /* Stop bit format (ie LLC) */

CONST   uchar NI1_STOP_BIT_S[] = {
    STOP_BIT_UNUSED,
    STOP_BIT_1,
    STOP_BIT_1_5,
    STOP_BIT_2,
    };

                    /* Information structure (ie LLC) */

CONST   uchar NI1_STRUCTURE_S[] = {
    STRUCTURE_DEFAULT,
    STRUCTURE_8KHZ_INT,
    STRUCTURE_SDU_INT,
    STRUCTURE_UNSTRUCTURED,
    };

                    /* Subaddress odd/even indicator (ie CALLED & CALLING _SUB_ADD) */

CONST   uchar NI1_SUB_ADD_IND_S[] = {
    SUB_ADD_ODD,
    SUB_ADD_EVEN,
    };

                    /* Subaddress type (ie CALLED & CALLING _SUB_ADD) */

CONST   uchar NI1_SUB_ADD_TYPE_S[] = {
    SUB_ADD_OSI,
    SUB_ADD_USER,
	};

					/* Asynchronous/synchronous (ie LLC) */

CONST   uchar NI1_SYN_ASYN_S[] =    {
    SYN,
    ASYN,
    };

                    /* Teleservices according to CCITT standard (ie HLC) */

CONST   uchar NI1_TELESERVICE_CCITT_S[] = {
	TELEPHONY,
	FAX_3,
    FAX_4,
    MIXED_MODE,
    PROCESSABLE_FORM,
    TELETEX,
    VIDEOTEX,
    TELEX,
    MHS,
    OSI,
    MAINTENANCE,        /* = HLC_NOT_AVAILABLE_1 */
    MANAGEMENT,         /* = HLC_NOT_AVAILABLE_2 */
    HLC_RESERVED,
    };

                    /* Teleservices which may be extended (ie HLC) */

CONST   uchar NI1_TELESERVICE_EXT_S[] = {
    MAINTENANCE,
    MANAGEMENT,
    };

                    /* Information transfer capability (ie BC) */

CONST   uchar NI1_TRF_CAP_BC_S []  ={
    TRF_CAP_SPEECH,
    TRF_CAP_UNRESTRICTED,
    TRF_CAP_RESTRICTED,
    TRF_CAP_3_1_AUDIO,
    TRF_CAP_7_AUDIO,
    };

                    /* Information transfer capability (ie LLC) */

CONST   uchar NI1_TRF_CAP_LLC_S []  ={
	TRF_CAP_SPEECH,
	TRF_CAP_UNRESTRICTED,
    TRF_CAP_RESTRICTED,
    TRF_CAP_3_1_AUDIO,
    TRF_CAP_7_AUDIO,
    TRF_CAP_VIDEO,
    };

                    /* Information transfer mode (ie LLC) */

CONST   uchar NI1_TRF_MODE_S[] = {
	TRF_MODE_CIRCUIT,
    TRF_MODE_PACKET,
    };

                    /* Type of Access (ie OS_ACCSS) */

CONST   uchar NI1_TYPE_ACCSS_S[] = {
    ACCSS_TYPE_PU_PRINC_DEF,
    ACCSS_TYPE_PU_ALTERNATE,
    ACCSS_TYPE_PR_PRINCIPAL,
    };

                    /* User rate (V110 & V120) (ie LLC) */

CONST   uchar NI1_USER_RATE_S[] =   {
    RA_E_BITS,
    RA_0_6KBS,
    RA_1_2KBS,
    RA_2_4KBS,
    RA_3_6KBS,
    RA_4_8KBS,
    RA_7_2KBS,
    RA_8KBS,
    RA_9_6KBS,
    RA_14_4KBS,
    RA_16KBS,
    RA_19_2KBS,
    RA_32KBS,
    RA_48KBS,
    RA_56KBS,
    RA_64KBS,
    RA_0_1345KBS,
	RA_0_100KBS,
	RA_0_75_1_2KBS,
	RA_1_2_0_75KBS,
	RA_0_050KBS,
	RA_0_075KBS,
	RA_0_110KBS,
	RA_0_150KBS,
	RA_0_200KBS,
	RA_0_300KBS,
	RA_12KBS,
	};

					/* Version code (ie PROT_VER_CTRL) */

CONST   uchar NI1_VERSION_S[] = {
	NT_STIMULUS,
	NT_MFT,
	NT_TRF,
	NT_AUSTRALIA,
	};


				/* O_CALLED_NB */

CONST	uchar NI1_O_REDIR_REASON_S[] = {
	R_UNKNOWN,
	R_CALL_FORWARDING_BUSY,
	R_CALL_FORWARDING_NO_REPLY,
	R_CALL_TRANSFER,
	R_CALL_PICKUP,
	R_CALL_FORWARDING_UNCONDITIONAL,
	};

CONST	uchar NI1_CFNR_S[] = {
	CFNR_FALSE,
	CFNR_TRUE
	};


CONST	uchar NI1_REDIR_COUNTER_S[] = {
	0,1,2,3,4,5
	};

					/* PROGRESS_IND */

CONST	uchar NI1_PROGRESS_LOC_S[] = {
	PROGRESS_LOC_PR_LOCAL_USER,
	PROGRESS_LOC_PU_LOCAL_USER,
	PROGRESS_LOC_TRANSIT_NET,
	PROGRESS_LOC_PU_REMOTE_USER,
	PROGRESS_LOC_PR_REMOTE_USER,
	PROGRESS_LOC_INTERNATIONAL,
	PROGRESS_BEYONG_IWP,
	};

				/* RESTART_IND */

CONST	uchar NI1_RESTART_IND_S[] = {
	RI_INDICATED_CHANNEL,
	RI_SINGLE_INTERFACE,
	RI_ALL_INTERFACES,
	};


				/* TRANSIT_NET_SEL */

CONST	uchar NI1_NET_ID_TYPE_S[] = {
	USER_SPECIFIED_TYPE,
	NATIONAL_NETWORK_ID_TYPE,
	};

CONST	uchar NI1_NET_ID_PLAN_S[] = {
	UNKNOWN_PLAN,
	CARRIER_ID_CODE,
	USER_SPECIFIED_ID_CODE,
	};

/*=========================================================================*/

    /* Tables selected according to another value (indexed tables) */

        /* Cause value  according to the class */

            /* Normal event - class 000 */

CONST   uchar NI1_C_V_NORMAL_EVENT_0_S[] = {
            C_C_NORMAL_EVENT_0,
            C_V_UNASSIGNED_NUMBER_1,
            C_V_NO_ROUTE_TO_TRANSIT_NET_2,
            C_V_NO_ROUTE_TO_DEST_3,
            C_V_CHAN_UNACCEPTABLE_6,
            };

            /* Normal event - class 000 for network specific coding standard */

CONST   uchar NI1_C_V_NORMAL_EVENT_0_SPF_S[] = {
            C_C_NORMAL_EVENT_0,
			C_V_VACANT_CODE_1,
			C_V_PREFIX_1_DIALED_IN_ERROR_3,
			C_V_PREFIX_1_NOT_DIALED_4,
			C_V_CALL_PROCEEDING_8,
			};

            /* Normal event - class 001 */

CONST   uchar NI1_C_V_NORMAL_EVENT_S[] = {
            C_C_NORMAL_EVENT,
            C_V_NORMAL_CLEARING_16,
            C_V_USER_BUSY_17,
            C_V_NO_USER_RESPONDING_18,
            C_V_NO_ANSWER_19,
            C_V_CALL_REJECT_21,
            C_V_NUMBER_CHANGED_22,
			C_V_DEST_OUT_OF_ORDER_27,
            C_V_INVALID_NUMBER_FORMAT_28,
			C_V_FACILITY_REJECT_29,
            C_V_RESPONSE_TO_STATUS_ENQUIRY_30,
            C_V_NORMAL_UNSPECIFIED_31,
            };

            /* Resource not available */

CONST   uchar NI1_C_V_RESOURCE_UNAVAILABLE_S[] ={
            C_C_RESOURCE_UNAVAILABLE,
            C_V_NO_CIRCUIT_AVAILABLE_34,
            C_V_NETWORK_TEMPORARY_FAILURE_41,
            C_V_NETWORK_CONGESTION_42,
            C_V_ACCESS_INFORMATION_DISCARDED_43,
            C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44,
            C_V_RESOURCE_UNAVAILABLE_UNSPECIFIED_47,
            };

            /* Service not available */

CONST   uchar NI1_C_V_SERVICE_NOT_AVAILABLE_S[] = {
			C_C_SERVICE_NOT_AVAILABLE,
			C_V_REQUESTED_FAC_NOT_SUBSCRIBED_50,
			C_V_INCOMING_CALLS_BARRED_54,
			C_V_BC_NOT_AUTHORIZED_57,
			C_V_BC_NOT_PRESENTLY_AVAILABLE_58,
			C_V_SERVICE_NOT_AVAILABLE_63,
			};

			/* Service not available for network specific coding standard */

CONST   uchar NI1_C_V_SRV_NOT_AVAIL_SPF_S[] = {
			C_C_SERVICE_NOT_AVAILABLE,
            C_V_BC_INCOMPATIBLE_WITH_SERVICE_51,
            C_V_SERVICE_OPERATION_VIOLATED_53,
            };

            /* Service not implemented */

CONST   uchar NI1_C_V_SERVICE_NOT_IMPLEMENTED_S[] = {
            C_C_SERVICE_NOT_IMPLEMENTED,
            C_V_BC_NOT_IMPLEMENTED_65,
			C_V_REQUESTED_FAC_NOT_IMPLEMENTED_69,
            C_V_ONLY_RESTRICTED_INFO_BEARER_70,
			C_V_SERVICE_NOT_IMPLEMENTED_UNSPECIFIED_79,
            };

            /* Invalid message */

CONST   uchar NI1_C_V_INVALID_MESSAGE_S[] = {
            C_C_INVALID_MESSAGE,
            C_V_INVALID_CALL_REF_81,
            C_V_IDENTIFIED_CHANNEL_NOT_EXIST_82,
            C_V_INCOMPATIBLE_DESTINATION_88,
            C_V_INVALID_MESSAGE_UNSPECIFIED_95,
            };

            /* Protocol error */

CONST   uchar NI1_C_V_PROTOCOL_ERROR_S[] = {
            C_C_PROTOCOL_ERROR,
            C_V_MANDATORY_IE_MISSING_96,
            C_V_MESSAGE_TYPE_NON_EXISTENT_97,
            C_V_NON_EXISTENT_IE_99,
            C_V_INVALID_IE_CONTENT_100,
            C_V_MESSAGE_NOT_COMPATIBLE_101,
            C_V_RECOVERY_ON_TIMER_EXPIRY_102,
            C_V_PROTOCOL_ERROR_UNSPECIFIED_111,
            };

            /* Interworking */

CONST   uchar NI1_C_V_INTERWORKING_S[] = {
            C_C_INTERWORKING,
            C_V_INTERWORKING_UNSPECIFIED_127,
            };

                    /* Progress description CCITT (ie PROGRESS_IND) */

CONST   uchar NI1_PROGRESS_DESCRIPTION_CCITT_S[] = {
    CODING_STD_CCITT,
    PROGRESS_DESCR_NON_END_TO_END_ISDN,
    PROGRESS_DESCR_NON_ISDN_DEST,
    PROGRESS_DESCR_NON_ISDN_ORIG,
    PROGRESS_DESCR_IN_BAND_NOW,
    };

                    /* Progress description specific (ie PROGRESS_IND) */

CONST   uchar NI1_PROGRESS_DESCRIPTION_SPF_S[] = {
    CODING_STD_SPF,
    PROGRESS_DESCR_DELAY_AT_CALLED,
    };

                    /* Information transfer rate (ie LLC) according to transfer mode */

CONST   uchar NI1_TRF_RATE_CIRCUIT_S[] = {
    TRF_MODE_CIRCUIT,
    TRF_RATE_64KBS,
    TRF_RATE_2x64KBS,
    TRF_RATE_384KBS,
    TRF_RATE_1536KBS,
    TRF_RATE_1920KBS,
    };

CONST   uchar NI1_TRF_RATE_PACKET_S[] = {
    TRF_MODE_PACKET,
    TRF_RATE_PACKET_MODE,
    };

                    /* Channel selection according to interface type (ie CHAN_ID) */

CONST   uchar NI1_CHAN_SEL_BRI_S[] = {
            INT_TYPE_BRI,
            NO_CHAN,
            B1_CHAN,
            B2_CHAN,
            ANY_CHAN,
            };

CONST   uchar NI1_CHAN_SEL_PRI_S[] = {
            INT_TYPE_PRI,
            NO_CHAN,
            AS_INDICATED,
            };

/*-------------------------------------------------------------------------*/

		/*
            Meta description of the information elements.
            This description is  used to check an information element
            inside a message and to store its value into  the internal
            structure.
            In the other way it is used to generate the information element of
            a message from the internal structure.
        */

#define NS_INCLUDE_IE_META_FUNCTION		ON		/* include prototypes of functions inside mp_ie.ni1 */

#include "ni1.mp_ie"  /* include IE meta-programs */

/*--------------------------------------------------------------------------*
					 F U N C T I O N    H E A D E R

Name            ni1_bc_5_spdu - implements the processing of the Bearer
							capability (BC) IE of a SPDU message to be sent.

Usage           uchar ni1_bc_5_spdu ();

Return value :  bc_spdu returns = OK valid data,
								= NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar ni1_bc_4ab_spdu ()
{
	ie_if_flag = ON;	/* octets 4a and 4b may be present */

	if ((direction			== TO_D_CHANNEL)			&&
		(I_(bc,structure)	== STRUCTURE_DEFAULT)		&&
		(I_(bc,config)		== CONFIG_POINT_TO_POINT)	&&
		(I_(bc,est)			== EST_DEMAND)				&&
		(I_(bc,symmetry)	== BIDIRECTIONAL_SYMMETRY)	&&
		(I_(bc,dest_rate)	== I_(bc,trf_rate))) {

		/* default values for octets 4a and 4b : they are omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar ni1_bc_4b_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 4b may be present */

	if ((direction			== TO_D_CHANNEL)			&&
		(I_(bc,symmetry)	== BIDIRECTIONAL_SYMMETRY)	&&
		(I_(bc,dest_rate)	== I_(bc,trf_rate))) {

		/* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

uchar ni1_bc_5_spdu ()
{
    ie_if_flag = ON;    /* (default value) : octet 5 may be present */

    if (direction == TO_D_CHANNEL) {

        if (I_(bc,protocol_id_1) == BYTE_VAL_NIL) {

                /* octet 5 is missing */

            ie_if_flag = OFF;
        }
    }

    return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_calling_nb_spdu - implements the specific processing of
								a calling number Information Element (IE).

Usage           uchar ni1_calling_nb_spdu ();

Return value :  ni1_calling_nb_spdu returns OK
                                        NOK

common constants and declarations : ns.h net_i_s.h

common objects : internal data structure i_calling_nb, ie spdu context.
                        - direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

uchar ni1_calling_nb_spdu ()
{

        /* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;        /* in general case, process octet 3a */

	if ((direction == TO_D_CHANNEL) &&
		((I_(calling_nb,pres) == PRES_ALLOWED) &&
		 (I_(calling_nb,screen_ind) == USER_PROVIDED)
		)
	   ) {
		ie_if_flag = OFF;   /* default values used : omit octet 3a */
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_cause_spdu - implements the specific processing of a cause
                             Information Element (IE).

Usage           uchar ni1_cause_spdu ();

Return value :  ni1_cause_spdu returns OK
									NOK

common constants and declarations : ns.h net_i_s.h

common objects : internal data structure i_cause, ie  spdu context.
                        - direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

uchar ni1_cause_spdu ()
{
    uchar   class_val;              /* cause class & value */

    class_val = C_v (I_cause_class, I_cause_val);

    if (direction == FROM_D_CHANNEL) {

      if (! Eo_ie) {

        switch (class_val) {

			case C_v (C_C_PROTOCOL_ERROR,           C_V_MANDATORY_IE_MISSING_96)        :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_NON_EXISTENT_IE_99)             :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_INVALID_IE_CONTENT_100)         :

            case C_v (C_C_PROTOCOL_ERROR,           C_V_MESSAGE_TYPE_NON_EXISTENT_97)   :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_MESSAGE_NOT_COMPATIBLE_101)     :

				return (r_exec_spdu_ie ((uchar *) &NI1_DIAG_P));

            default :
                return (NOK);
        }

      } else {

        switch (class_val) {
            case C_v (C_C_PROTOCOL_ERROR,           C_V_MANDATORY_IE_MISSING_96)        :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_NON_EXISTENT_IE_99)             :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_INVALID_IE_CONTENT_100)         :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_MESSAGE_TYPE_NON_EXISTENT_97)   :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_MESSAGE_NOT_COMPATIBLE_101)     :
                return (NOK);

            default :
				return (OK);
        }
      }

    } else {            /* TO D CHANNEL side */

        switch (class_val) {
            case C_v (C_C_PROTOCOL_ERROR,           C_V_MANDATORY_IE_MISSING_96)        :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_NON_EXISTENT_IE_99)             :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_INVALID_IE_CONTENT_100)         :

            case C_v (C_C_PROTOCOL_ERROR,           C_V_MESSAGE_TYPE_NON_EXISTENT_97)   :
            case C_v (C_C_PROTOCOL_ERROR,           C_V_MESSAGE_NOT_COMPATIBLE_101)     :

              if (I_(cause,diag_lgth) != 0) {
                return (s_exec_spdu_ie ((uchar *) &NI1_DIAG_P));
              } else {
                return (NOK);
              }

			default :       /* diagnostic is ignored */
                break;
        }

    }

    return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name        ni1_chan_id_check - Test if interface type in chan_id IE and in
                            configuration are the same. If not return error.

Usage       uchar ni1_chan_id_check();

Return value :  ni1_chan_id_check returns = OK  valid data,
                                     = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar ni1_chan_id_check ()
{
	if (direction == FROM_D_CHANNEL) {

		if (I_(chan_id,int_type) == INT_TYPE_BRI) {
			if (Na_type != BRI) return (NOK);
		} else {
			if (Na_type != PRI) return (NOK);
		}

	}
	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N    H E A D E R

Name            ni1_conn_nb_spdu - implements the specific processing of
								a conn number Information Element (IE).

Usage           uchar ni1_conn_nb_spdu ();

Return value :  ni1_conn_nb_spdu returns OK
									 NOK

common constants and declarations : ns.h net_i_s.ni1

common objects : internal data structure i_conn_nb, ie spdu context.
						- direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

uchar ni1_conn_nb_spdu ()
{

		/* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;        /* in general case, process octet 3a */

	if ((direction == TO_D_CHANNEL) &&
		((I_(conn_nb,pres) == PRES_ALLOWED) &&
		 (I_(conn_nb,screen_ind) == USER_PROVIDED)
        )
       ) {
        ie_if_flag = OFF;   /* default values used : omit octet 3a */
    }

    return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_feature_act_ext - allows the processing of the #3a octet.

Usage           uchar ni1_feature_act_ext ();

Return value :  ni1_feature_act_ext returns OK.

*--------------------------------------------------------------------------*/

uchar ni1_feature_act_ext ()
{
    ie_if_flag = ON;            /* octet 3a may be present */

	if ((direction == TO_D_CHANNEL) &&
        (I_(feature_act,feature_nb_ext) == BYTE_VAL_NIL)) {
        ie_if_flag = OFF;
    }
    return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_feature_act_range - check feature identifiers range

Usage           uchar ni1_feature_act_range ();

Return value :  ni1_feature_act_range returns   OK or NOK

*--------------------------------------------------------------------------*/

uchar ni1_feature_act_range ()
{
    if (((I_(feature_act,feature_nb) <= 64) && (I_(feature_act,feature_nb) > 0)) &&
        ( ((I_(feature_act,feature_nb_ext) <= 64) && (I_(feature_act,feature_nb_ext) > 0)) ||
            (I_(feature_act,feature_nb_ext) == BYTE_VAL_NIL)
        )) {
        return (OK);
    } else {
        return (NOK);
    }
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_feature_ind_ext - allows the processing of the #3a octet.

Usage           uchar ni1_feature_ind_ext ();

Return value :  ni1_feature_ind_ext returns OK.

*--------------------------------------------------------------------------*/

uchar ni1_feature_ind_ext ()
{
	ie_if_flag = ON;            /* octet 3a may be present */

	if ((direction == TO_D_CHANNEL) &&
        (I_(feature_ind,feature_nb_ext) == BYTE_VAL_NIL)) {
        ie_if_flag = OFF;
    }
	return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_feature_ind_range - check feature identifiers range

Usage           uchar ni1_feature_ind_range ();

Return value :  ni1_feature_ind_range returns   OK or NOK

*--------------------------------------------------------------------------*/

uchar ni1_feature_ind_range ()
{
    if (((I_(feature_ind,feature_nb) <= 64) && (I_(feature_ind,feature_nb) > 0)) &&
        ( ((I_(feature_ind,feature_nb_ext) <= 64) && (I_(feature_ind,feature_nb_ext) > 0)) ||
            (I_(feature_ind,feature_nb_ext) == BYTE_VAL_NIL)
        )) {
        return (OK);
    } else {
        return (NOK);
    }
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            llc_spdu - implements the processing of the low layer
                            compatibility (LLC) IE of a received SPDU
                            message and of SPDU message to be sent.

Usage           uchar llc_spdu ();

Return value :  llc_spdu returns = OK valid data,
                                 = NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar ni1_llc_4ab_spdu ()
{
    ie_if_flag = ON;    /* octets 4a and 4b may be present */

	if ((direction          == TO_D_CHANNEL)            &&
        (I_(llc,structure)  == STRUCTURE_DEFAULT)       &&
        (I_(llc,config)     == CONFIG_POINT_TO_POINT)   &&      /* forced value anyway */
        (I_(llc,est)        == EST_DEMAND)              &&      /* forced value anyway */
        (I_(llc,symmetry)   == BIDIRECTIONAL_SYMMETRY)  &&      /* forced value anyway */
        (I_(llc,dest_rate)  == I_(llc,trf_rate))) {

        /* default values for octets 4a and 4b : they are omitted */

        ie_if_flag = OFF;
    }

    return (OK);
}

/*--------------------------------------------------------------------------*/

uchar ni1_llc_4b_spdu ()
{
    ie_if_flag = ON;    /* (default value) : octet 4b may be present */

	if ((direction          == TO_D_CHANNEL)            &&
        (I_(llc,symmetry)   == BIDIRECTIONAL_SYMMETRY)  &&      /* forced value anyway */
        (I_(llc,dest_rate)  == I_(llc,trf_rate))) {

        /* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
    }

    return (OK);
}

/*--------------------------------------------------------------------------*/

#define Get_layer_id()  Extract (5,Mask(2))

uchar ni1_llc_5_spdu ()
{
    ie_if_flag = ON;    /* (default value) : octet 5 may be present */

        /* if I_llc_protocol_id_1 == BYTE_VAL_NIL -> octet 5 is missing */

	if (direction == TO_D_CHANNEL) {

        if (I_(llc,protocol_id_1) == BYTE_VAL_NIL) {

                /* octet 5 is missing */

            ie_if_flag = OFF;
        }

    } else {

        uchar ie_octet;

        ie_octet = Get_ie_octet;

        if (Get_layer_id () != LAYER_ID_1) {

                /* It is NOT Octet 5 (layer 1) */

            ie_if_flag = OFF;
        }

    }

    return (OK);
}

/*--------------------------------------------------------------------------*/

uchar ni1_llc_6_spdu ()
{
    ie_if_flag = ON;    /* (default value) : octet 6 may be present */

        /* if I_llc_layer_id_2 == BYTE_VAL_NIL -> octet 6 is missing */

	if (direction == TO_D_CHANNEL) {

            /* octet 6 must be present if PACKET MODE */

        if (I_(llc,protocol_id_2) == BYTE_VAL_NIL) {

            /* octet 6 is missing */

            if (I_(llc,trf_mode) == TRF_MODE_PACKET) return (NOK);

            ie_if_flag = OFF;
        }

    } else {

        uchar ie_octet;

        ie_octet = Get_ie_octet;

        if (Get_layer_id () != LAYER_ID_2) {

                /* It is NOT Octet 6 (layer 2) */

            ie_if_flag = OFF;
        }
	}

    return (OK);
}

/*--------------------------------------------------------------------------*/

uchar ni1_llc_7_spdu ()
{
    ie_if_flag = ON;    /* (default value) : octet 7 may be present */

        /* if I_llc_layer_id_3 == BYTE_VAL_NIL -> octet 7 is missing */

	if (direction == TO_D_CHANNEL) {

        if (I_(llc,protocol_id_3) == BYTE_VAL_NIL) {

                /* octet 7 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_3) {

				/* It is NOT Octet 7 (layer 3) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N    H E A D E R

Name            ni1_o_called_nb_spdu - implements the specific processing of
								a o_called number Information Element (IE).

Usage           uchar ni1_o_called_nb_spdu ();

Return value :  ni1_o_called_nb_spdu returns OK
										NOK

common constants and declarations : ns.h net_i_s.h

common objects : internal data structure i_o_called_nb, ie spdu context.
                        - direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

uchar ni1_o_called_nb_spdu ()
{

        /* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;        /* in general case, process octet 3a */

	if (direction == TO_D_CHANNEL) {

		if ((I_(o_called_nb,pres) == PRES_ALLOWED) &&
			(I_(o_called_nb,screen_ind) == USER_PROVIDED)) {

			if ((I_(o_called_nb,reason) == BYTE_VAL_NIL)&&
				(I_(o_called_nb,cfnr) == BYTE_VAL_NIL)	&&
				(I_(o_called_nb,redir_counter) == BYTE_VAL_NIL)) {

					 /*
					  * default values used and octets 3b,c,d are missing
					  *	--> omit octet 3a
					  */

				ie_if_flag = OFF;

			}
		}
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_redir_nb_spdu - implements the specific processing of
                                a conn number Information Element (IE).

Usage           uchar ni1_redir_nb_spdu ();

Return value :  ni1_redir_nb_spdu returns   OK
                                        NOK

common constants and declarations : ns.h net_i_s.h

common objects : internal data structure i_redir_nb, ie spdu context.
                        - direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

uchar ni1_redir_nb_spdu ()
{

		/* if default values are used for octet 3a, it shall be omitted. */

    ie_if_flag = ON;        /* in general case, process octet 3a */

	if ((direction == TO_D_CHANNEL) &&
		((I_(redir_nb,pres) == PRES_ALLOWED) &&
		 (I_(redir_nb,screen_ind) == USER_PROVIDED)
        )
       ) {
        ie_if_flag = OFF;   /* default values used : omit octet 3a */
    }

    return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N    H E A D E R

Name            ni1_redirection_nb_spdu - implements the specific processing of
                                a conn number Information Element (IE).

Usage           uchar ni1_redirection_nb_spdu ();

Return value :  ni1_redirection_nb_spdu returns OK
                                            NOK

common constants and declarations : ns.h net_i_s.h

common objects : internal data structure i_redirection_nb, ie spdu context.
                        - direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

uchar ni1_redirection_nb_spdu ()
{

        /* if default values are used for octet 3a, it shall be omitted. */

    ie_if_flag = ON;        /* in general case, process octet 3a */

	if ((direction == TO_D_CHANNEL) &&
		((I_(redirection_nb,pres) == PRES_ALLOWED) &&
		 (I_(redirection_nb,screen_ind) == USER_PROVIDED)
        )
	   ) {
        ie_if_flag = OFF;   /* default values used : omit octet 3a */
	}

    return (OK);
}

/*--------------------------------------------------------------------------*
                     F U N C T I O N    H E A D E R

Name            ni1_call_appear_ext - allows the processing of the #3a octet.

Usage           uchar ni1_call_appear_ext ();

Return value :  ni1_call_appear_ext returns OK.

*--------------------------------------------------------------------------*/

uchar ni1_call_appear_ext ()
{
    ie_if_flag = ON;            /* octet 3a may be present */

	if ((direction == TO_D_CHANNEL) &&
        (I_(call_appear,call_appear_id_2) == BYTE_VAL_NIL)) {
		ie_if_flag = OFF;
    }
    return (OK);
}

/*-------------------------------------------------------------------------*/

#define Ns_ni1_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_ni1_end_table_or_function		};
#define Ns_ni1_tab_tabl_entry(idx, tab)		Ns_tab_tabl_entry (idx, tab),
#define Ns_ni1_tabx_list_entry(tab)			Ns_tabx_list_entry (tab),
#define Ns_ni1_tab_tabx_entry(idx, tab)		Ns_tab_tabx_entry (idx, tab),

#define Ns_ni1_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx)	\
			Ns_tab_ie_entry (codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, 0),

#define Ns_ni1_tab_ie_msg_header			{CODESET_NIL, MESSAGE_HEADER, (uchar *)A_NIL, sizeof(struct i_message_header), (uchar *)Pic_address (&i_message_header), (uchar *)A_NIL, (uchar *)A_NIL, 1, 0},

#include "ni1.tab_ie"		/* include other Tables describing the IEs */

#define NI1_MX_TABL (sizeof(NI1_TAB_TABL)/sizeof (struct tabl))
CONST   uchar   ni1_size_tab_tabl = NI1_MX_TABL;

#define NI1_MX_TABX (sizeof(NI1_TAB_TABX)/sizeof (struct tabx))
CONST   uchar   ni1_size_tab_tabx = NI1_MX_TABX;

CONST   uchar   ni1_size_tab_ie = Rnd_sizeof (NI1_TAB_IE) / IE_ELEM_SIZE;   /* maximum number of item in the table */

/*-------------------------------------------------------------------------*/

#if OM_CODE_TYPE == OM_PIC /* PIC used{ */

#undef Ns_ni1_table_or_function
#undef Ns_ni1_end_table_or_function
#undef Ns_ni1_tab_tabl_entry
#undef Ns_ni1_tabx_list_entry
#undef Ns_ni1_tab_tabx_entry
#undef Ns_ni1_tab_ie_entry
#undef Ns_ni1_tab_ie_msg_header

#define Ns_ni1_table_or_function(str, tab)	i_pic = 0;						\
											{								\
												struct str FAR	*p_table;	\
												p_table = tab;

#define Ns_ni1_end_table_or_function		}

#define Ns_ni1_tab_tabl_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_val, (uchar *)tab);
#define Ns_ni1_tabx_list_entry(tab)			Pic_init_struct_array_next (p_table,  p_val, (uchar	*)tab);
#define Ns_ni1_tab_tabx_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_tab, (struct tabx_list *)tab);

#define Ns_ni1_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx)	\
	Pic_init_struct_array (p_table,  i_pic, p_prog, (uchar	*)mp_a);		\
	Pic_init_struct_array (p_table,  i_pic, p_i_struct, (uchar	*)i_str);	\
	Pic_init_struct_array (p_table,  i_pic, p_init_spdu, (uchar	*)df_spdu);	\
	Pic_init_struct_array_next (p_table,  p_init_ssdu, (uchar	*)df_ssdu);

#define Ns_ni1_tab_ie_msg_header		Ns_ni1_tab_ie_entry (0, 0, P_NIL, &i_message_header, P_NIL, P_NIL, 0)

		/*	Function used to initialize address fields in Tables above */


void pic_init_ns_ni1_ie ()
{
	uchar	i_pic;			/* current index */

#	include "ni1.tab_ie"
}

#endif /* end of PIC used} */


/*EOF*/
