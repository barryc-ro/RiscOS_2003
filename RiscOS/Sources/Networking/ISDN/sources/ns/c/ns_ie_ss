
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_ie_ss.c
 *
 * $Revision$
 *
 * $Date$
 *
 *		This file contains the functions that implement the processing
 *		of the IEs specific to Supplementary Services :
 *		FACILITY, EXTENDED FACILITY, NOTIFICATION INDICATOR.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "ns.h"

#if NS_SUPP_SERVICES == ON /*{*/

#include "isdn.h"
#include "asn1_int.h"
#include "ns_mac.h"

#if ASN1_OPTIONAL_USED == OFF
#	error 'ASN1_OPTIONAL_USED' must be set to ON in 'asn1_par.h'!
#endif

#if F_ETS == ON		/* European specific operations (described in ETS) are used currently only in ETSI variant */
#	define NS_USE_EUROPE_OPERATION		ON
#else
#	define NS_USE_EUROPE_OPERATION		OFF
#endif

	/*	European specific Supplementary Services : if NS_USE_EUROPE_OPERATION parameter is set
		to OFF, all associated coding is not necessary -> reset specific SS flag */

#if NS_USE_EUROPE_OPERATION == OFF
#	undef NS_SS_ECT
#	define NS_SS_ECT						OFF
#	undef NS_SS_EXPL_CHAN_RESERVATION
#	define NS_SS_EXPL_CHAN_RESERVATION		OFF
#	undef NS_SS_FREEPHONE
#	define NS_SS_FREEPHONE					OFF
#	undef NS_SS_MALICIOUS_CALL_ID
#	define NS_SS_MALICIOUS_CALL_ID			OFF
#	undef NS_SS_AOC_S
#	define NS_SS_AOC_S						OFF
#	undef NS_SS_AOC_D
#	define NS_SS_AOC_D						OFF
#	undef NS_SS_AOC_E
#	define NS_SS_AOC_E						OFF
#	undef NS_SS_CUG
#	define NS_SS_CUG						OFF
#	undef NS_SS_3_PARTY					
#	define NS_SS_3_PARTY					OFF
#	undef NS_SS_CONFERENCE
#	define NS_SS_CONFERENCE					OFF
#	undef NS_SS_USER_USER_EXP
#	define NS_SS_USER_USER_EXP				OFF
#endif

/*==========================================================================

			- definition of types used for Supplementary Services -
*/

typedef uchar		ns_ss_op_val_t;			/* type for operation values (in Invoke and ReturnResult components) */

typedef uchar		ns_ss_err_id_t;			/* type for error interface identifiers */
typedef uchar		ns_ss_err_val_t;		/* type for error values (in ReturnError component) */

typedef uchar		ns_ss_pb_t;				/* type for problem values (in Reject component) */

/*==========================================================================

		- declaration of internal data structures for facility component -
*/

struct i_ss_fac_comp {
	uchar				component_tag;			/* type of component : Invoke / Returnresult / ReturnError / Reject */
	uchar				inv_id_presence;		/* presence of Invoke Identifier (Reject component) or
													presence of operation/error specific data (argument / result / parameter) */
	ns_ss_inv_id_t		invoke_id;				/* invoke Identifier */
	uchar				lk_id_or_res_presence;	/* presence of linked Identifier in Invoke component or of operation data in Result component (OPTIONAL) */
	ns_ss_inv_id_t		lk_id;					/* linked Identifier */
	uchar				problem_tag;			/* type of problem : General / Invoke / ReturnResult / ReturnError */
	ns_ss_pb_t			problem;				/* identifier of problem */
	ns_ss_op_id_t		op_err_identifier;		/* NS interface identifier of operation or error contained in the component */
#	if F_QSI == ON
		/* Q-SIG specific data */
	uchar				apdu_type;						/* type of APDU = RoseAPDU / DseBegin / DseEnd / DseContinue / DseAbort */
	uchar				orig_dialog_or_abort_info_sz;	/* size of originationDialogID string or UserAbortInformation string (in AbortPDU) */
	uchar				destination_dialog_sz;			/* size of destinationDialogID string */
	uchar				abort_cause_or_comp_nb;			/* P_AbortCause inside AbortPDU or number of RoseAPDUs (components) contained inside DseAPDU (RemoteOperationsPortion) */
	uchar FAR			*p_orig_dialog_or_abort_info;	/* pointer to originationDialogID string or UserAbortInformation string (in AbortPDU) */
	uchar FAR			*p_destination_dialog;			/* pointer to destinationDialogID string */
#	endif
};

#define I_ss_fac_comp_tag				p_ns_fac_component -> component_tag
#define I_ss_fac_is_inv_id_here			p_ns_fac_component -> inv_id_presence
#define I_ss_fac_is_op_err_data			p_ns_fac_component -> inv_id_presence
#define I_ss_fac_invoke_id				p_ns_fac_component -> invoke_id
#define I_ss_fac_is_lk_id_here			p_ns_fac_component -> lk_id_or_res_presence
#define I_ss_fac_is_result_here			p_ns_fac_component -> lk_id_or_res_presence
#define I_ss_fac_linked_id				p_ns_fac_component -> lk_id
#define I_ss_fac_problem_tag			p_ns_fac_component -> problem_tag
#define I_ss_fac_problem				p_ns_fac_component -> problem
#define I_ss_fac_op_err_id				p_ns_fac_component -> op_err_identifier

#if F_QSI == ON
#	define I_ss_fac_apdu_type			p_ns_fac_component -> apdu_type
#	define I_ss_fac_orig_abort_sz		p_ns_fac_component -> orig_dialog_or_abort_info_sz
#	define I_ss_fac_dest_sz				p_ns_fac_component -> destination_dialog_sz
#	define I_ss_fac_cause_or_nb			p_ns_fac_component -> abort_cause_or_comp_nb
#	define I_ss_fac_p_orig_abort		p_ns_fac_component -> p_orig_dialog_or_abort_info
#	define I_ss_fac_p_dest				p_ns_fac_component -> p_destination_dialog
#endif 

	/* table of all facility components received in a SPDU (in 1 or more FACILITY IEs) */

struct i_ss_fac_comp 		ns_fac_components		[NS_MX_FAC_COMPONENTS];

uchar						ns_x_ss_fac_comp;			/* current index in facility component table */
struct i_ss_fac_comp FAR	*p_ns_fac_component;		/* pointer to current internal component data */

uchar						ns_i_ss_clause_nb; 			/* number of instances of an operation/error clause stored */
ushort						ns_i_ss_clause_interval;	/* interval between adjacent internal structures used for data storage of repeated clauses */

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_reset_ss_ie_i - reset the internal Supplementary Services context.

Usage           void	ns_reset_ss_ie_i (void);

Description     ns_reset_ss_ie_i implements the (re-)initialisation of the
				variables used to describe the content of the internal IE
				data structures used for Supplementary Services.

Return value    None

*--------------------------------------------------------------------------*/

void ns_reset_ss_ie_i ()
{
		/* reset the current index in facility component table */

	ns_x_ss_fac_comp = 0;
}

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_ss_i_op_err_clause_nb - search the number of instances of
				an operation/error clause stored into internal array of components.

Usage           void ns_ss_i_op_err_clause_nb (uchar tag, ns_ss_op_id_t op_err_id);
						- tag : tag of component to search,
						- op_err_id : identifier of operation or error to search.

Description     ns_ss_i_op_err_clause_nb counts inside internal component list
				the number of times a given type of component is found with the
				same operation or error ID (corresponding to a clause for an
				operation (ARGUMENT or RESULT) or for an error (PARAMETER)).

*--------------------------------------------------------------------------*/

void ns_ss_i_op_err_clause_nb (tag, op_err_id)
	uchar			tag;			/* tag of component to search */
	ns_ss_op_id_t	op_err_id;		/* NS interface identifier of operation or error to search */
{
	uchar			i;				/* current loop index */

	ns_i_ss_clause_nb = 0;
	for (i = 0; i < ns_x_ss_fac_comp; i++) {

		if ((ns_fac_components [i].component_tag == tag) &&
			(ns_fac_components [i].op_err_identifier == op_err_id)) {

			ns_i_ss_clause_nb++;
        }
	}
}

/*==========================================================================

			- definitions for tag process (class + form + nb)
*/

#define FAC_LINKED_ID_TAG								G_5 (0,0,0,0,0)			/* linked-ID tag */

#define Ns_tag_from_class_form_nb(class, form, nb)		(uchar)((class << 6) + (form << 5) + nb)

		/* table of all component tags : Invoke / ReturnResult / ReturnError / Reject */

CONST_ARRAY uchar FAC_COMPONENT_TAG_TAB[] = {

	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, FAC_INVOKE),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, FAC_RETURN_RESULT),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, FAC_RETURN_ERROR),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, FAC_REJECT)
};

#define SIZE_FAC_COMPONENT_TAG_TAB		sizeof(FAC_COMPONENT_TAG_TAB)

		/* table of all problem tags : General / Invoke / ReturnResult / ReturnError */

CONST_ARRAY uchar FAC_PROBLEM_TAG_TAB[] = {

	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, REJ_GENERAL_PB_TAG),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, REJ_INVOKE_PB_TAG),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, REJ_RET_RESULT_PB_TAG),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, REJ_RET_ERROR_PB_TAG)
};

#define SIZE_FAC_PROBLEM_TAG_TAB		sizeof(FAC_PROBLEM_TAG_TAB)

#if F_QSI == ON

		/* Q-SIG specific tags for beginning of the two first parts inside Facility IE */

#define QSI_NET_FAC_EXTENSION_TAG			10			/* NetworkFacilityExtension */
#define QSI_INTERPRETATION_APDU_TAG			11			/* InterpretationApdu */

#endif

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_check_get_tag - search given tag value in list of values.

Usage           uchar ns_check_get_tag (uchar CONST FAR *p_list, uchar list_size, uchar value, uchar FAR *p_tag_nb);
						- p_list : pointer to list of values to scan,
						- list_size : number of values in list,
						- value : value to search,
						- p_tag_nb : pointer where to store tag Nb.

Return value    OK if value found in list, NOK else.
				p_tag_nb pointer is used to return the Tag Nb matching
				found value (bits 0 to 4 of value).

*--------------------------------------------------------------------------*/

uchar ns_check_get_tag (p_list, list_size, value, p_tag_nb)
	uchar CONST FAR		*p_list;		/* pointer to list of values */
	uchar				list_size;		/* number of values in list */
	uchar				value;			/* value to search in list */
	uchar	FAR			*p_tag_nb;		/* pointer where to store Tag Nb */
{
#	if ASSERT == ON

		if ((p_list == P_NIL) || (p_tag_nb == P_NIL)) {

			Trap (TRAP_NO_TABLE_AVAILABLE, "ns_check_get_tag");
			return (NOK);
		}

#	endif

	while (list_size-- > 0) {

		if (value == *p_list++) {

				/* value is found -> return tag nb (5 least significant bits) */

			*p_tag_nb = Get_bits (value, 0, 5);
			return (OK);
		}
	}

		/* value not found in table */

	return (NOK);
}

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_decode_asn1_lgth - decodes "length field" in ASN1 encoded
				data and returns corresponding length.

Name            ns_encode_asn1_lgth - encodes "length field" of ASN1 data
				on exactly 2 octets.

Usage           ushort ns_decode_asn1_lgth (void);
				void ns_encode_asn1_lgth (uchar FAR *p_data, uchar length);

Return value    ns_decode_asn1_lgth : decoded data length or BAD_ASN1_LGTH (0xFFFF)
				if error or overflow or NS_ASN1_INDEFINITE_LGTH (0xFFFE) if length
				is of indefinite form.

Common objects	p_ie pointer.

*--------------------------------------------------------------------------*/

#define MX_ASN1_LGTH_SHORT_FORM			127
#define BAD_ASN1_LGTH					(ushort)(~0)
#define NS_ASN1_INDEFINITE_LGTH			(BAD_ASN1_LGTH - 1)

#define NS_ASN1_END_OF_CONTENT_SIZE		2
#define NS_ASN1_END_OF_CONTENT_VAL		G_8 (0,0,0,0,0,0,0,0)

ushort ns_decode_asn1_lgth ()
{
	uchar	length_octets_lgth;			/* current number of octets in the LENGTH OCTETS field */
	ushort	length;						/* current length */

	if (*p_ie <= MX_ASN1_LGTH_SHORT_FORM) {

			/* short form : length is data itself on 1 octet */

		length = (ushort)(*p_ie);
		p_ie++;

		return (length);
	}

		/* long form : 1 initial octet whose 7 least significant bits
			indicate the number of subsequent octets */

	length_octets_lgth = Get_bits((*p_ie), 0, 7);
	p_ie++;

	if (length_octets_lgth == 0) {	/* length is of indefinite form (0x80) */

		return (NS_ASN1_INDEFINITE_LGTH);
	}

	length = 0;

	while ((length_octets_lgth > 0) && (*p_ie == 0)) {

			/* read the first null octets until not null or end of length field */

		p_ie++;
		length_octets_lgth--;
	}

	if (length_octets_lgth == 0) {

			/* all the octets are null -> length = 0 */

		return (0);
	}

	if (length_octets_lgth > sizeof (ushort)) {

			/* the length is too high to be encoded with an unsigned short */

		return (BAD_ASN1_LGTH);
	}

		/* compute length */

	while (length_octets_lgth-- > 0) {

		length = (length * (ushort)256) + *p_ie;
		p_ie++;
	}

	return (length);
}

	/* -=-=-=-=-=-=-=-=-=-=- */

void ns_encode_asn1_lgth (p_data, length)
	uchar FAR	*p_data;		/* pointer to data where to encode length */
	uchar		length;			/* length to be encoded */
{
	*p_data++ = 0x81;			/* first octet : Bit 8 = 1 (long form), Bits 7 to 1 = number of subsequent octets in length (1) */
	*p_data++ = length;			/* subsequent octet = Length itself */
}

	/* ANS1 specific macro to encode an INTEGER value */

#define Asn1_encode_integer			ber_encode_integer

/*==========================================================================

			- operation and error internal description -
*/

	/*	description associated with each "Type field" in ASN1 meta-program
		for which a storage context is used by ASN1 mechanism :
			- ASN1 meta-program address + number of the field in meta-program,
			- type and address of internal value
			- repetition number, next instance internal location and next entry in Table
				for lists of values (type inside a SEQUENCE OF Type)
	*/

struct ns_asn1_store_desc {

	uchar CONST FAR		*p_pc;				/* ASN1 meta-program pointer */
	uchar				field_nb;			/* number of the field in meta-program associated with this storage context */
	uchar				type;				/* associated type : a particular value identifying the internal type used to store the value */
	uchar	FAR			*p_struct;			/* pointer to internal structure field where to store decoded value */
	ushort				instance_interval;	/* number of octets between current and next internal data location
												for 2 instances of the same item (used for types in an ASN1 SEQUENCE OF) */
	uchar				repeat_nb;			/* maximum number of repetitions for a field (in a list as SEQUENCE OF) */
	uchar				next_entry;			/* next entry to be read in description Table : used for lists of values of different fields associated with same (p_pc, field_nb) */
	uchar				optional_x;			/* index of first optional indicator in 'ns_asn1_optional_indicators' array or 255 if Mandatory */
};

#define Ns_ss_ctx_list_p_pc				p_ns_ss_ctx_list -> p_pc
#define Ns_ss_ctx_list_field_nb			p_ns_ss_ctx_list -> field_nb
#define Ns_ss_ctx_list_type				p_ns_ss_ctx_list -> type
#define Ns_ss_ctx_list_p_struct			p_ns_ss_ctx_list -> p_struct
#define Ns_ss_ctx_list_interval			p_ns_ss_ctx_list -> instance_interval
#define Ns_ss_ctx_list_repeat_nb		p_ns_ss_ctx_list -> repeat_nb
#define Ns_ss_ctx_list_next_entry		p_ns_ss_ctx_list -> next_entry
#define Ns_ss_ctx_list_optional_x		p_ns_ss_ctx_list -> optional_x

		/* structures used to store values according to ASN1 type */

struct ns_asn1_string {				/* OCTET STRING / CharacterString types */
	uchar		size;
	uchar FAR	*p_string;			/* address of string or P_NIL if no coding */
};

	/*	possible values of 'type' field : indicates what type is used in internal structure
		to store data value : it may be one of the structures above or a simple type as uchar */

#define NS_SS_INT_TYPE_ASN1_STRING			2				/* 'ns_asn1_string' structure used */
#define NS_SS_INT_TYPE_UCHAR				4				/* unsigned char used and 0xFF if value not provided */
#define NS_SS_INT_TYPE_CHAR					5				/* char used and -0x80 if value not provided */
#define NS_SS_INT_TYPE_USHORT				6				/* unsigned short used and 0xFFFF if value not provided */
#define NS_SS_INT_TYPE_SHORT				7				/* short used and -0x8000 if value not provided */
#define NS_SS_INT_TYPE_ULONG				8				/* unsigned long used and 0xFFFFFFFF if value not provided */
#define NS_SS_INT_TYPE_LONG					9				/* long used and -0x80000000 if value not provided */
#define NS_SS_INT_TYPE_BOOLEAN				10				/* BOOLEAN type : unsigned char used and 0xFF if value not provided */
#define NS_SS_INT_TYPE_BIT_STRING			11				/* 'ns_asn1_string' structure used for BIT STRING ASN1 Type */
#define NS_SS_CHOICE_INDEX					20				/* index ("field_nb") in an ASN1 CHOICE Meta-program : it indicates which type field has been chosen */
#define NS_SS_SEQUENCE_OF_NB				21				/* number of instances in an ASN1 SEQUENCE-OF Meta-program : it indicates how many instances of a type have been processed in a list */

#define NS_SS_INT_TYPE_ANY					NS_SS_INT_TYPE_ASN1_STRING	/* 'ns_asn1_string' structure used for ASN1 type "ANY" */

			/* operation description */

struct ns_ss_operation {
	ns_ss_op_id_t						identifier;			/* identifier of operation used at NS interface */
	uchar								tag;				/* tag of operation value : INTEGER or OBJECT IDENTIFIER */
	ns_ss_op_val_t						value;				/* operation value : it is the INTEGER itself or the identifier of the node in OBJECT IDENTIFIER tree */
	uchar CONST FAR						*p_argument_prog;	/* pointer to ASN1 description meta-program for operation ARGUMENT */
	struct ns_asn1_store_desc CONST FAR	*p_arg_ctx_list;	/* list of all storage contexts to be used for ASN1 decoding of ARGUMENT */
	uchar CONST FAR						*p_result_prog;		/* pointer to ASN1 description meta-program for operation RESULT */
	struct ns_asn1_store_desc CONST FAR	*p_res_ctx_list;	/* list of all storage contexts to be used for ASN1 decoding of RESULT */

#	if NEW_FCT_STYLE == ON
		uchar			(*ssdu_fct)	(uchar FAR *p_start, ushort offset);	/* function to process operation content in SSDU */
#	else
		uchar			(*ssdu_fct)	();
#	endif
};

#define Ns_ss_op_id						p_ns_ss_operation -> identifier
#define Ns_ss_op_tag					p_ns_ss_operation -> tag
#define Ns_ss_op_value					p_ns_ss_operation -> value
#define Ns_ss_op_p_arg_prog				p_ns_ss_operation -> p_argument_prog
#define Ns_ss_op_arg_ctx_list			p_ns_ss_operation -> p_arg_ctx_list
#define Ns_ss_op_p_result_prog			p_ns_ss_operation -> p_result_prog
#define Ns_ss_op_result_ctx_list		p_ns_ss_operation -> p_res_ctx_list
#define Ns_ss_op_ssdu_fct				p_ns_ss_operation -> ssdu_fct

			/* error description */

struct ns_ss_error {
	ns_ss_op_id_t						identifier;			/* identifier of error used at NS interface */
	uchar								tag;				/* tag of error value : INTEGER or OBJECT IDENTIFIER */
	ns_ss_err_val_t						value;				/* error value : it is the INTEGER itself or the identifier of the node in OBJECT IDENTIFIER tree */
};

#define Ns_ss_err_id					p_ns_ss_error -> identifier
#define Ns_ss_err_tag					p_ns_ss_error -> tag
#define Ns_ss_err_value					p_ns_ss_error -> value

		/* description of an entry in common table for all countries */

struct ns_ss_op_err_tab {
	ushort								country;			/* country code */
	struct ns_ss_operation CONST FAR	*p_op_tab;			/* pointer to table of all operations in the country */
	uchar								op_tab_size;		/* number of operations in the table */
	struct ns_ss_error CONST FAR		*p_err_tab;			/* pointer to table of all errors in the country */
	uchar								err_tab_size;		/* number of errors in the table */
	struct asn1_obj_id_node	CONST FAR	*p_obj_id_list;		/* pointer to OBJECT IDENTIFIER tree */
	asn1_node_id_t						obj_id_nb;			/* number of nodes in the tree */
};

#define Ns_ss_op_err_country			p_ns_ss_op_err_tab -> country
#define Ns_ss_operation_table			p_ns_ss_op_err_tab -> p_op_tab
#define Ns_ss_operation_tab_sz			p_ns_ss_op_err_tab -> op_tab_size
#define Ns_ss_error_table				p_ns_ss_op_err_tab -> p_err_tab
#define Ns_ss_error_tab_sz				p_ns_ss_op_err_tab -> err_tab_size
#define Ns_ss_p_obj_id_list				p_ns_ss_op_err_tab -> p_obj_id_list
#define Ns_ss_obj_id_nb					p_ns_ss_op_err_tab -> obj_id_nb

/*==========================================================================*/

	/* ASN1 Meta-programs for common ASN1 types :
		INTEGER, ENUMERATED, NULL, OCTET STRING, BOOLEAN and OBJECT IDENTIFIER */

D_ASN1_TYPE_START		(NS_SS_INTEGER_P)
D_ASN1_TYPE_END

ASN1_TYPE_START			(NS_SS_INTEGER_P)
	ASN1_INTEGER,
	ASN1_TYPE_NO_FIELD
ASN1_TYPE_END

	/*-=-=-=-=-=-*/

D_ASN1_TYPE_START		(NS_SS_ENUMERATED_P)
D_ASN1_TYPE_END

ASN1_TYPE_START			(NS_SS_ENUMERATED_P)
	ASN1_ENUMERATED,
	ASN1_TYPE_NO_FIELD
ASN1_TYPE_END

	/*-=-=-=-=-=-*/

D_ASN1_TYPE_START		(NS_SS_NULL_P)
D_ASN1_TYPE_END

ASN1_TYPE_START			(NS_SS_NULL_P)
	ASN1_NULL,
	ASN1_TYPE_NO_FIELD
ASN1_TYPE_END

	/*-=-=-=-=-=-*/

D_ASN1_TYPE_START		(NS_SS_OCTET_STRING_P)
D_ASN1_TYPE_END

ASN1_TYPE_START			(NS_SS_OCTET_STRING_P)
	ASN1_OCTET_STRING,
	ASN1_TYPE_NO_FIELD
ASN1_TYPE_END

	/*-=-=-=-=-=-*/

D_ASN1_TYPE_START		(NS_SS_BOOLEAN_P)
D_ASN1_TYPE_END

ASN1_TYPE_START			(NS_SS_BOOLEAN_P)
	ASN1_BOOLEAN,
	ASN1_TYPE_NO_FIELD
ASN1_TYPE_END

	/*-=-=-=-=-=-*/

D_ASN1_TYPE_START		(NS_SS_OBJECT_IDENTIFIER_P)
D_ASN1_TYPE_END

ASN1_TYPE_START			(NS_SS_OBJECT_IDENTIFIER_P)
	ASN1_OBJECT_IDENTIFIER,
	ASN1_TYPE_NO_FIELD
ASN1_TYPE_END

		/*	number of ASN1 storage contexts needed for analyse of
			OPERATION/ERROR VALUE meta-program : 1 for choice index
			+ 1 for INTEGER value + 1 for OBJECT IDENTIFIER value
		*/

#define NS_ASN1_CTX_NB_OP_ERR_VAL		3

	/*-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/*	list of all ASN1 meta-program storage description structures currently used
		to process ASN1 encoding or decoding. For each operation or error clause
		(ARGUMENT, RESULT or PARAMETER), the sum obtained by adding the numbers
		of contexts necessary for each field of the clause (given in clause storage description
		Table by "repeat_nb + 1") must be less than or equal to NS_MX_ASN1_STORE_DESC. */

#define NS_MX_ASN1_STORE_DESC		113

#if NS_SS_DIVERSION == ON

#	if F_QSI == ON
#		if NS_MX_ASN1_STORE_DESC < (NS_DIV_MX_INT_RESULT * 13 + 1)
#			undef NS_MX_ASN1_STORE_DESC
#			define NS_MX_ASN1_STORE_DESC	(NS_DIV_MX_INT_RESULT * 13 + 1)
#		endif
#	endif

#	if NS_MX_ASN1_STORE_DESC < (NS_DIV_MX_INT_RESULT * 12 + 1)
#		undef NS_MX_ASN1_STORE_DESC
#		define NS_MX_ASN1_STORE_DESC	(NS_DIV_MX_INT_RESULT * 12 + 1)
#	endif

#	if NS_MX_ASN1_STORE_DESC < (NS_DIV_MX_USER_NUMBERS * 3 + 1)
#		undef NS_MX_ASN1_STORE_DESC
#		define NS_MX_ASN1_STORE_DESC	(NS_DIV_MX_USER_NUMBERS * 3 + 1)
#	endif

#endif

asn1_store_t	ns_asn1_tab_store_info[NS_MX_ASN1_STORE_DESC];

	/*	List of presence indicators for instances of Types Marked OPTIONAL inside ASN1 SEQUENCE type.
		34 indicators may be necessary to process Advice Of Charge in EUROPE for AOCEChargingUnit operation
		whose argument contains following optional fields :
			'recordedUnitsList' (32 indicators) + aOCEBillingId (1) + chargingAssociation (1) */

#define NS_MX_ASN1_OPTIONAL_IND		35

#if NS_SS_DIVERSION == ON

#	if F_QSI == ON
#		if NS_MX_ASN1_OPTIONAL_IND < (NS_DIV_MX_INT_RESULT * 4)

#			undef NS_MX_ASN1_OPTIONAL_IND
#			define NS_MX_ASN1_OPTIONAL_IND	(NS_DIV_MX_INT_RESULT * 4)

#		endif
#	endif

#	if NS_MX_ASN1_OPTIONAL_IND < (NS_DIV_MX_INT_RESULT * 2)

#		undef NS_MX_ASN1_OPTIONAL_IND
#		define NS_MX_ASN1_OPTIONAL_IND	(NS_DIV_MX_INT_RESULT * 2)

#	endif
#endif

uchar	ns_asn1_optional_indicators		[NS_MX_ASN1_OPTIONAL_IND];

/*==========================================================================

			- Country specific operation and error description -
*/

#include "eur.ns_ss"			/* EUROPE specific */

#if F_QSI == ON
#	include "qsi.ns_ss"			/* Q-SIG specific */
#endif

	/*
		WARNING: 'pic_init_ns_ss_ie' function must be 
		in conformance with this Table (see below).
	*/

PIC_CONST_ARRAY struct ns_ss_op_err_tab	NS_SS_OPERATION_ERROR_TAB[] = {
/*	country		p_op_tab				op_tab_size
				p_err_tab				err_tab_size
				p_obj_id_list			obj_id_nb */

#if NS_USE_EUROPE_OPERATION == ON
	{EUROPE,	Pic_address (EUROPE_OPERATION_TAB),		Ns_tab_item_nb (EUROPE_OPERATION_TAB),
				Pic_address (EUROPE_ERROR_TAB),			Ns_tab_item_nb (EUROPE_ERROR_TAB),
				Pic_address (NS_EUROPE_OBJ_ID_TREE),	NS_EUROPE_OBJ_ID_NB},
#endif

#if F_QSI == ON
	{EUROPE,	Pic_address (NS_QSI_OPERATION_TAB),		Ns_tab_item_nb (NS_QSI_OPERATION_TAB),
				Pic_address (NS_QSI_ERROR_TAB),			Ns_tab_item_nb (NS_QSI_ERROR_TAB),
				Pic_address (NS_QSI_OBJ_ID_TREE),		NS_QSI_OBJ_ID_NB}
#endif

};

#define NS_SS_SIZE_OP_ERR_TAB		Ns_tab_item_nb	(NS_SS_OPERATION_ERROR_TAB)

struct ns_ss_op_err_tab CONST FAR	*p_ns_ss_op_err_tab;		/* pointer to current instance in common table */

struct ns_ss_operation CONST FAR	*p_ns_ss_operation;			/* pointer to current operation description */
struct ns_ss_error CONST FAR		*p_ns_ss_error;				/* pointer to current error description */
struct ns_asn1_store_desc CONST FAR	*p_ns_ss_ctx_list;			/* list of all storage contexts to be used for ASN1 decoding and associated internal value address */

		/*	ASN1 description of type for operation/error value.
			It matches following ASN1 description :
				VALUE CHOICE {
					localValue INTEGER,
					globalValue OBJECT IDENTIFIER
				}
		*/

D_ASN1_TYPE_START		(NS_SS_OP_ERR_VAL_P)
	D_ASN1_TYPE_FIELD_NB	(2)
D_ASN1_TYPE_END

ASN1_TYPE_START			(NS_SS_OP_ERR_VAL_P)
	NS_ASN1_CHOICE
	ASN1_TYPE_FIELD_NB		(2)
	ASN1_TYPE_FIELD			(NS_SS_INTEGER_P)
	ASN1_TYPE_LAST_FIELD	(NS_SS_OBJECT_IDENTIFIER_P)
ASN1_TYPE_END

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_get_country_op_err_tab - search given country table
				for operations and errors in common Table .

Usage           void ns_get_country_op_err_tab (ushort country);

Return value    None.

Common objects	p_ns_ss_op_err_tab current pointer used to return found instance,
				common table NS_SS_OPERATION_ERROR_TAB.

*--------------------------------------------------------------------------*/

void ns_get_country_op_err_tab (country)
	ushort	country;		/* country to search */
{
	uchar	i;		/* loop index */

		/* initialize current pointer to table */

	p_ns_ss_op_err_tab = NS_SS_OPERATION_ERROR_TAB;

#	if (NS_USE_EUROPE_OPERATION == ON) && (F_QSI == ON)

			/*	If both European and Q-SIG specific operations are used, first entry in common
				Table is to be skipped when processing Q-SIG variant (this entry is for European
				specific operations and both entries are associated with EUROPE country) */

		if (Na_network == qsi) {

			p_ns_ss_op_err_tab++;
		}

#	endif
		/* search in Table */

	for (i = 0; i < NS_SS_SIZE_OP_ERR_TAB; i++) {

		if (country == Ns_ss_op_err_country) {

				/* value is found -> return */

			return;
		}

		p_ns_ss_op_err_tab++;
	}

		/* value not found in table */

	p_ns_ss_op_err_tab = P_NIL;
	return;
}

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_decode_ss_op_err_val - implements the decoding of an
				operation or error value and the associated clause (ARGUMENT,
				RESULT or PARAMETER) according to the description in country
				specific table.

Name            ns_encode_ss_op_err_val - implements the encoding of an
				operation or error value and the associated clause (ARGUMENT,
				RESULT or PARAMETER) according to the description in country
				specific table.

Usage           uchar ns_decode_ss_op_err_val (uchar FAR *p_end, uchar flag);
Usage           uchar ns_encode_ss_op_err_val (uchar flag);
						- p_end : pointer to end of data to decode,
						- flag : flag indicating what is to be decoded.

Return value    OK if operation or error is found in table and decoding/encoding
				of the clause (ARGUMENT/RESULT/PARAMETER) succeeds, NOK else.

Common objects	common and country specific tables for operations and errors,
				ns_asn1_tab_store_info array of storage contexts for ASN1 decoding,
				global pointers : p_facility_component, p_ns_ss_op_err_tab,
				p_ns_ss_operation, p_ns_ss_error, p_ns_ss_ctx_list.

*--------------------------------------------------------------------------*/

#define NS_FLAG_OPERATION_ARGUMENT		1		/* decode ARGUMENT clause of OPERATION */
#define NS_FLAG_OPERATION_RESULT		2		/* decode RESULT clause of OPERATION */
#define NS_FLAG_ERROR_PARAMETER			3		/* decode PARAMETER clause of ERROR */

#if NEW_FCT_STYLE == ON
	void	ns_ss_i_op_err_clause_nb		(uchar tag, ns_ss_op_id_t op_err_id);
#else
	void	ns_ss_i_op_err_clause_nb		();
#endif
	uchar	ns_ss_get_internal_value		(Void_parm);
	void	ns_ss_init_internal_op			(Void_parm);

	/* -=-=-=-=-=-=-=-=-=- */

uchar ns_decode_ss_op_err_val (p_end, flag)
	uchar FAR	*p_end;		/* pointer to end of data to be decoded */
	uchar		flag;		/* flag indicating what clause is to be decoded */
{
	uchar								i, j;				/* loop indexes */
	asn1_store_ctx_t FAR				*p_store_ctx;		/* pointer to current storage context */
	asn1_store_ctx_t FAR				*p_previous_ctx;	/* pointer to previous storage context */
	uchar								tag;				/* tag of OPERATION or ERROR */
	ulong								op_err_value;		/* decoded value of OPERATION or ERROR */
	uchar								tab_size;			/* size of country specific table to scan (for OPERATION or ERROR) */
	uchar CONST FAR						*p_prog;			/* pointer to ASN1 meta-program to analyse */
	struct ns_asn1_store_desc CONST FAR	*p_sav_ctx_list;	/* saved list of all storage contexts to be used for ASN1 decoding */

	for (i = 0; i < NS_ASN1_CTX_NB_OP_ERR_VAL; i++) {

			/* get storage context from storage description structure */

		p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + i);

			/* init the context */

		Asn1_init_store_ctx		(p_store_ctx);

			/* store the meta-program pointer into the description structure */

		ns_asn1_tab_store_info[i].p_pc			= (uchar FAR *)&NS_SS_OP_ERR_VAL_P;
		ns_asn1_tab_store_info[i].field_nb		= i;
	}

		/* decode OPERATION/ERROR value check resulting data length */

	if (asn1_decoding_start ((uchar FAR *)&NS_SS_OP_ERR_VAL_P,
							 &p_ie, p_end + 1, NS_ASN1_CTX_NB_OP_ERR_VAL,
							 ns_asn1_tab_store_info) == 0) {

		return (NOK);
	}

		/* get first storage context in table : it is the CHOICE index */

	p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info);

	if (Asn1_get_stored_size (p_store_ctx) == 0) {

			/* first "type" in NS_SS_OP_ERR_VAL_P CHOICE description = INTEGER */

		tag = FAC_INTEGER_TAG;
		p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + 1);

	} else {

		tag = FAC_OBJECT_ID_TAG;
		p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + 2);
	}

		/* get value identifying current operation or error */

	op_err_value = Asn1_get_stored_size (p_store_ctx);
	p_prog = P_NIL;

	switch (flag) {

		case NS_FLAG_OPERATION_ARGUMENT :
		case NS_FLAG_OPERATION_RESULT :

			tab_size = Ns_ss_operation_tab_sz;

			if ((p_ns_ss_operation = Ns_ss_operation_table) == P_NIL) {

				return (NOK);
			}

			for (i = 0; i < tab_size; i++, p_ns_ss_operation++) {

				if ((Ns_ss_op_tag == tag) && ((ulong)Ns_ss_op_value == op_err_value)) {

					/* operation found in table -> store operation identifier,
						set meta-program pointer and pointer to list of
						storage contexts to be used according to the flag */

					I_ss_fac_op_err_id = Ns_ss_op_id;

					if (flag == NS_FLAG_OPERATION_ARGUMENT) {

						p_prog = Ns_ss_op_p_arg_prog;
						p_sav_ctx_list = p_ns_ss_ctx_list = Ns_ss_op_arg_ctx_list;
						ns_ss_i_op_err_clause_nb (FAC_INVOKE, I_ss_fac_op_err_id);

					} else {

						p_prog = Ns_ss_op_p_result_prog;
						p_sav_ctx_list = p_ns_ss_ctx_list = Ns_ss_op_result_ctx_list;
						ns_ss_i_op_err_clause_nb (FAC_RETURN_RESULT, I_ss_fac_op_err_id);
					}

					break;
				}
			}

			break;

		case NS_FLAG_ERROR_PARAMETER :

			tab_size = Ns_ss_error_tab_sz;

			if ((p_ns_ss_error = Ns_ss_error_table) == P_NIL) {

				return (NOK);
			}

			for (i = 0; i < tab_size; i++, p_ns_ss_error++) {

				if ((Ns_ss_err_tag == tag) && (Ns_ss_err_value == op_err_value)) {

					/* error found in table -> store error identifier
						only 1 error may contain PARAMETER data : Q-SIG specific error "Unspecified"
						in this case, set meta-program pointer and pointer to list of storage contexts to be used
					 */

					I_ss_fac_op_err_id = Ns_ss_err_id;

#					if F_QSI == ON
					if (I_ss_fac_op_err_id == SS_ERR_QSI_UNSPECIFIED) {

						p_prog = (uchar FAR *)&NS_SS_QSI_EXTENSION_P;
						p_sav_ctx_list = p_ns_ss_ctx_list = NS_QSI_CTX_LIST_UNSPECIFIED;
					}
#					endif
					ns_ss_i_op_err_clause_nb (FAC_RETURN_ERROR, I_ss_fac_op_err_id);
					break;
				}
			}

			break;
	}

	if (i == tab_size) {

			/* decoded operation or error value was not in country table */

		return (NOK);
	}

	if ((p_prog == P_NIL) || (p_ns_ss_ctx_list == P_NIL)) {

		/* no clause specified in OPERATION or ERROR -> nothing more to do */

		return (OK);
	}

	if ((p_ie == p_end) ||
		((*p_ie == NS_ASN1_END_OF_CONTENT_VAL) && (p_ie[1] == NS_ASN1_END_OF_CONTENT_VAL))) {

		/* no other data in component -> store 'No data' information, reset pointer
			to list of storage contexts and nothing more to do */

        I_ss_fac_is_op_err_data = ABSENT;
		p_ns_ss_ctx_list = P_NIL;
		return (OK);
	}

	I_ss_fac_is_op_err_data = PRESENT;

		/* 	If first entry in Table indicates P_NIL, the entry is used to indicate
			 - maximum number of instances allowed for the operation clause and
			 - interval between adjacent internal structures used for data storage */

	if (Ns_ss_ctx_list_p_pc == P_NIL) {

		i = Ns_ss_ctx_list_repeat_nb;	/* get number of instances allowed */
		p_ns_ss_ctx_list++;				/* skip first entry */

	} else {

		i = 1;	/* no repetition allowed -> number of instances allowed is 1 */
	}

		/* check that number of instances found does not exceed maximum allowed */

	if (ns_i_ss_clause_nb >= i) {

    	return (NOK);
	}

		/* initialise all storage contexts to be used by ASN1 decoding mechanism
			and decode ARGUMENT or RESULT or PARAMETER clause */

	for (i = 0; Ns_ss_ctx_list_p_pc != P_NIL; p_ns_ss_ctx_list++) {

		/*	reset pointer to previous context if it is a new Meta-program field (pair (p_pc, field_nb))
			processed (the first one or a field different from previous one) */

		if ((i == 0) ||
			(ns_asn1_tab_store_info[i - 1].p_pc != Ns_ss_ctx_list_p_pc) ||
			(ns_asn1_tab_store_info[i - 1].field_nb != Ns_ss_ctx_list_field_nb)) {

			p_previous_ctx = P_NIL;
		}

		for (j = 0; j < (Ns_ss_ctx_list_repeat_nb + 1); i++, j++) {

			if (i >= NS_MX_ASN1_STORE_DESC) {

					/* global storage description array is too small for number
						of contexts specified for the current operation or error */

				Trap (TRAP_NS_SS_INCONSISTENCY, "ns_decode_ss_op_err_val");
				return (NOK);
			}

				/* get storage context from storage description structure */

			p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + i);

				/* init current context, link it to previous one and update previous one */

			Asn1_init_store_ctx		(p_store_ctx);
			if (p_previous_ctx != P_NIL) {

				Asn1_link_store_ctx		(p_previous_ctx, p_store_ctx);
			}
			p_previous_ctx = p_store_ctx;

				/* store the meta-program pointer into the description structure */

			ns_asn1_tab_store_info[i].p_pc			= (uchar FAR *)(Ns_ss_ctx_list_p_pc);
			ns_asn1_tab_store_info[i].field_nb		= Ns_ss_ctx_list_field_nb;
		}

			/* initialize optional indicators if necessary */

		if (Ns_ss_ctx_list_optional_x != 255) {

			for (j = 0; j < (Ns_ss_ctx_list_repeat_nb + 1); j++) {

				ns_asn1_optional_indicators [Ns_ss_ctx_list_optional_x + j] = ASN1_OPTIONAL_NOT_PROCESSED;
			}
        }
	}

		/* restore pointer to list of contexts */

	p_ns_ss_ctx_list = p_sav_ctx_list;

		/* decode OPERATION/ERROR clause and check resulting data length */

	if (asn1_decoding_start ((uchar FAR *)p_prog, &p_ie, p_end + 1, i, ns_asn1_tab_store_info) == 0) {

		return (NOK);
	}

	return (OK);
}

	/* -=-=-=-=-=-=-=-=-=- */

uchar ns_encode_ss_op_err_val (flag)
	uchar		flag;		/* flag indicating what clause is to be decoded */
{
	uchar								i;					/* loop indexes */
	asn1_store_ctx_t FAR				*p_store_ctx;		/* pointer to current storage context */
	uchar								tag;				/* tag of OPERATION or ERROR */
	ns_ss_op_val_t						op_err_value;		/* value of OPERATION or ERROR to be encoded */
	uchar								tab_size;			/* size of country specific table to scan (for OPERATION or ERROR) */
	uchar CONST FAR						*p_prog;			/* pointer to ASN1 meta-program to analyse */

	p_spdu_end = p_ie + 255;	/* set pointer to end of IE (maximum IE length is 255) */
	p_prog = P_NIL;
	p_ns_ss_ctx_list = P_NIL;

		/* search current operation or error identifier in Table */

	switch (flag) {

		case NS_FLAG_OPERATION_ARGUMENT :
		case NS_FLAG_OPERATION_RESULT :

			tab_size = Ns_ss_operation_tab_sz;

			if ((p_ns_ss_operation = Ns_ss_operation_table) == P_NIL) {

				return (NOK);
			}

			for (i = 0; i < tab_size; i++, p_ns_ss_operation++) {

				if (I_ss_fac_op_err_id == Ns_ss_op_id) {

					/* operation found in table -> store operation tag and value, set meta-program
						pointer and pointer to list of storage contexts to be used according to the flag */

					tag = Ns_ss_op_tag;
					op_err_value = Ns_ss_op_value;

					if (flag == NS_FLAG_OPERATION_ARGUMENT) {

						p_prog = Ns_ss_op_p_arg_prog;
						p_ns_ss_ctx_list = Ns_ss_op_arg_ctx_list;
						ns_ss_i_op_err_clause_nb (FAC_INVOKE, I_ss_fac_op_err_id);

					} else {

						p_prog = Ns_ss_op_p_result_prog;
						p_ns_ss_ctx_list = Ns_ss_op_result_ctx_list;
						ns_ss_i_op_err_clause_nb (FAC_RETURN_RESULT, I_ss_fac_op_err_id);
					}

					break;
				}
			}

			break;

		case NS_FLAG_ERROR_PARAMETER :

			tab_size = Ns_ss_error_tab_sz;

			if ((p_ns_ss_error = Ns_ss_error_table) == P_NIL) {

				return (NOK);
			}

			for (i = 0; i < tab_size; i++, p_ns_ss_error++) {

				if (I_ss_fac_op_err_id == Ns_ss_err_id) {

					/* error found in table -> store error tag and value
						only 1 error may contain PARAMETER data : Q-SIG specific error "Unspecified"
						in this case, set meta-program pointer and pointer to list of storage contexts to be used
					 */

					tag = Ns_ss_err_tag;
					op_err_value = Ns_ss_err_value;

#					if F_QSI == ON
					if (I_ss_fac_op_err_id == SS_ERR_QSI_UNSPECIFIED) {

						p_prog = (uchar FAR *)&NS_SS_QSI_EXTENSION_P;
						p_ns_ss_ctx_list = NS_QSI_CTX_LIST_UNSPECIFIED;
					}
#					endif

					ns_ss_i_op_err_clause_nb (FAC_RETURN_ERROR, I_ss_fac_op_err_id);
					break;
				}
			}

			break;
	}

	if (i == tab_size) {	/* operation or error identifier is not in country table : it should not happen for it has aleary been checked before */

		return (NOK);
	}

	for (i = 0; i < 2; i++) {	/* 2 storage contexts necessary : 1 for choice index + 1 for value */

		ns_asn1_tab_store_info[i].p_pc = (uchar FAR *)&NS_SS_OP_ERR_VAL_P;	/* store the meta-program pointer into the description structure */
	}

	ns_asn1_tab_store_info[0].field_nb = 0;		/* first Type field_nb = 0 in CHOICE : for choice index context */

		/* get storage context from storage description structure and initialize it */

	p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info);
	Asn1_init_store_ctx		(p_store_ctx);

		/*	store the choice index into the "size" of the context : 0 for INTEGER,
			1 for OBJECT IDENTFIER, corresponding to the NS_SS_OP_ERR_VAL_P ASN1 meta-program */

	if (tag == FAC_INTEGER_TAG) {

		Asn1_store_value	(p_store_ctx, 0, P_NIL);
		ns_asn1_tab_store_info[1].field_nb = 1;

	} else {

		Asn1_store_value	(p_store_ctx, 1, P_NIL);
		ns_asn1_tab_store_info[1].field_nb = 2;
	}

		/* get storage context from storage description structure, initialize it and store operation or error value */

	p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + 1);
	Asn1_init_store_ctx		(p_store_ctx);
	Asn1_store_value		(p_store_ctx, (ulong)op_err_value, P_NIL);

	if (tag == FAC_INTEGER_TAG) {	/* INTEGER : "coding_flag" in context is used for sign */

		Asn1_get_store_flag	(p_store_ctx) = ASN1_CODING_POSITIVE;

	} else {	/* OBJECT IDENTIFIER : "coding_flag" in context is used for nb of appended sub-identifiers (0) */

		Asn1_get_store_flag	(p_store_ctx) = 0;
	}

		/* encode OPERATION/ERROR value */

	if (asn1_encoding_start ((uchar FAR *)&NS_SS_OP_ERR_VAL_P,
							 &p_ie, p_spdu_end, 2,
							 ns_asn1_tab_store_info) == 0) {

		return (NOK);
	}

	if ((p_prog == P_NIL) || (p_ns_ss_ctx_list == P_NIL) || (I_ss_fac_is_op_err_data == ABSENT)) {

		/* no clause specified in OPERATION or ERROR or no specific data -> nothing more to do */

		return (OK);
	}

		/*	initialize all storage contexts to be used by ASN1 encoding mechanism
			and store values from internal data */

	i = ns_ss_get_internal_value ();

		/* encode OPERATION/ERROR clause and check resulting data length */

	if (asn1_encoding_start ((uchar FAR *)p_prog, &p_ie, p_spdu_end, i, ns_asn1_tab_store_info) == 0) {

		return (NOK);
	}

	return (OK);
}

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_ss_store_internal_value - implements the internal storage
				of values decoded by ASN1 mechanism that shall be transmitted
				at NS interface.

Name            ns_ss_get_internal_value - implements the reading of internal
				values and the filling of ASN1 storage contexts to be used
				by ASN1 encoder.

Name			ns_ss_init_internal_op - implements the initialization of
				internal values before filling them with SSDU data.

Usage           void ns_ss_store_internal_value (void);
				uchar ns_ss_get_internal_value (void);
				void ns_ss_init_internal_op (void);

Return value	ns_ss_get_internal_value : total number of storage contexts
				used, to be passed to ASN1 encoder (inside common array
				'ns_asn1_tab_store_info').

Common objects	p_ns_ss_ctx_list pointer, ns_asn1_tab_store_info array of
				storage contexts for ASN1 decoding, internal structures
				for ASN1 decoded values.

*--------------------------------------------------------------------------*/

void ns_ss_store_internal_value ()
{
	uchar								i, repeat_x;			/* loop index and repetition index */
	uchar								cur_entry;				/* current entry in Table (used for repeated sequence) */
	asn1_store_ctx_t FAR				*p_store_ctx;			/* current storage context pointer */
	char								int_char_value;			/* current INTEGER value whose internal type is char */
	short								int_short_value;		/* current INTEGER value whose internal type is short */
	long								int_long_value;			/* current INTEGER value whose internal type is long */
	uchar FAR							*p_internal_data;		/* pointer to internal data location */
	struct ns_asn1_store_desc CONST FAR	*p_sav_ctx_list;		/* saved pointer to list of storage descriptions for current operation or error process */

	if (p_ns_ss_ctx_list == P_NIL) {

			/* nothing to do */

		return;
	}

		/* save pointer to list of storage descriptions for current operation or error clause */

	p_sav_ctx_list = p_ns_ss_ctx_list;
	cur_entry = 0;

		/* 	If first entry in Table indicates P_NIL, the entry is used to indicate
			 - maximum number of instances allowed for the operation clause and
			 - interval between adjacent internal structures used for data storage */

	if (Ns_ss_ctx_list_p_pc == P_NIL) {

		ns_i_ss_clause_interval = Ns_ss_ctx_list_interval * ns_i_ss_clause_nb; 
		p_ns_ss_ctx_list++;				/* skip first entry */

	} else {

		ns_i_ss_clause_interval = 0; 
	}

		/* scan list of all storage descriptions for current operation or error clause */

	while (Ns_ss_ctx_list_p_pc != P_NIL) {

		/* search storage description structure associated with "Type field" of meta-program ((p_pc, field_nb)) */

		for (i = 0; i < NS_MX_ASN1_STORE_DESC; i++) {

			if ((ns_asn1_tab_store_info[i].p_pc == Ns_ss_ctx_list_p_pc) &&
				(ns_asn1_tab_store_info[i].field_nb == Ns_ss_ctx_list_field_nb)) {

					/* get storage context from storage description structure */

				p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + i);
				break;
			}
		}

		if (i >= NS_MX_ASN1_STORE_DESC) {

			/* "type field" specified for opeartion or error process not found in global storage description array */

			Trap (TRAP_NS_SS_INCONSISTENCY, "ns_ss_store_internal_value");
			return;
		}

		repeat_x = 0;

#		if ASSERT == ON
			/*	check consistency of Table : pointer to internal data location must not be NIL
				and interval between 2 instance values must not be null if repetition is possible */

			if ((Ns_ss_ctx_list_p_struct == P_NIL) ||
				((Ns_ss_ctx_list_repeat_nb != 0) && (Ns_ss_ctx_list_interval == 0))) {

				Trap (TRAP_NS_SS_INCONSISTENCY, "ns_ss_store_internal_value");
				return;
			}
#		endif

		/*	process current repetition sequence :
			-> 1 instance of current internal field if repetition number (n) is null,
					else
			-> (n+1) instances of current internal field if "next_entry" is current entry itself,
			-> (n+1) times : 1 instance of internal fields, one following each other according
					to each "next_entry" field
		*/

		while (TRUE) {

			if (p_store_ctx == P_NIL) {		/* check pointer to storage context is not null */

				Trap (TRAP_NS_SS_INCONSISTENCY, "ns_ss_store_internal_value");
				return;
			}

			/*	use 'i' variable as current optional indicator : a field is optional if optional_x
				index in Table is not 255 : if so, it is the index of the optional indicator in
				common array for the first instance of the type -> get current indicator and process
				only if 'PRESENT' is indicated */

			if (Ns_ss_ctx_list_optional_x != 255) {

				i = ns_asn1_optional_indicators [Ns_ss_ctx_list_optional_x + repeat_x];

			} else {

				i = ASN1_OPTIONAL_PRESENT;
			}

				/*	get pointer to internal data location using "p_struct" and "interval" fields
					(they indicate the address of first instance data location and the number
					of octets between 2 adjacent instance locations) */

			p_internal_data = Ns_ss_ctx_list_p_struct + ns_i_ss_clause_interval + (Ns_ss_ctx_list_interval * repeat_x);

				/* process storage according to "internal type" specified in Table */

			switch (Ns_ss_ctx_list_type) {

				case NS_SS_INT_TYPE_ASN1_STRING :
#				if F_QSI == ON
				case NS_SS_INT_TYPE_BIT_STRING :	/* BIT STRING Type : used only in Q-SIG specific operations */
#				endif

						/*	type is a string : coding flag indicates if decoding
							has been processed successfully -> check also the data size */

					if ((i == ASN1_OPTIONAL_PRESENT) &&
						(Asn1_get_store_flag (p_store_ctx) == ASN1_DECODED_VALUE) &&
						(Asn1_get_stored_size (p_store_ctx) <= (uchar)(~0))) {

							/* store the value (size + address) into internal structure and copy string into indirect buffer */

						int_short_value = (ushort)(Asn1_get_stored_size (p_store_ctx));
						((struct ns_asn1_string FAR *)p_internal_data) -> size = (uchar)int_short_value;
						((struct ns_asn1_string FAR *)p_internal_data) -> p_string = p_ind_buffer;
#						if F_QSI == ON	/* BIT STRING Type : used only in Q-SIG specific operations */
						if (Ns_ss_ctx_list_type == NS_SS_INT_TYPE_BIT_STRING) {

							int_short_value++;	/* 'size' field in context does not take into account first octet for 'number of unused bits' */
						}
#						endif
						Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)(Asn1_get_stored_address (p_store_ctx)), (uchar)int_short_value);
						p_ind_buffer += (uchar)int_short_value;

					} else {	/* no decoding -> set null length and NIL address */

						((struct ns_asn1_string FAR *)p_internal_data) -> size = 0;
						((struct ns_asn1_string FAR *)p_internal_data) -> p_string = P_NIL;
					}

					break;

				case NS_SS_SEQUENCE_OF_NB :

					/*	number of types processed in a list (ASN1 SEQUENCE OF Meta-program) :
						it is provided in "size" field of ASN1 storage context. If it is too
						high or not decoded, set number to 0 */

					if ((i != ASN1_OPTIONAL_PRESENT) ||
						(Asn1_get_store_flag (p_store_ctx) != ASN1_DECODED_VALUE) ||
						(Asn1_get_stored_size (p_store_ctx) > (uchar)(~0))) {

						*p_internal_data = 0;

					} else {

						*p_internal_data = (uchar)(Asn1_get_stored_size (p_store_ctx));
					}

					break;

				case NS_SS_CHOICE_INDEX :
				case NS_SS_INT_TYPE_BOOLEAN :

					/*	index ("field_nb") in an ASN1 CHOICE Meta-program or BOOLEAN : it is provided in "size" field
						of ASN1 storage context. If it is too high or not decoded, set number to 255 */

					if ((i != ASN1_OPTIONAL_PRESENT) ||
						(Asn1_get_store_flag (p_store_ctx) != ASN1_DECODED_VALUE) ||
						(Asn1_get_stored_size (p_store_ctx) > (uchar)(~0))) {

						*p_internal_data = 255;

					} else {

						*p_internal_data = (uchar)(Asn1_get_stored_size (p_store_ctx));
					}

					break;

				/*	FOR ALL FOLLOWING TYPES, ASN1 Type is INTEGER or ENUMERATED : coding flag is the
					sign of decoded integer or ASN1_NO_CODING_DONE if no decoding has been processed
					and "size" field of ASN1 storage context is the integer value.
					Check the sign and value according to the internal type and store the integer value
					if it is valid, else store value indicating 'NOT PROVIDED'. */

				case NS_SS_INT_TYPE_UCHAR :

					if ((i == ASN1_OPTIONAL_PRESENT) &&
						(Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_POSITIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0xFF)) {

						*p_internal_data = (uchar)(Asn1_get_stored_size (p_store_ctx));

					} else {	/* integer not provided or not compatible with unsigned char */

						*p_internal_data = NS_SS_INT_UCHAR_NOT_PROVIDED;
					}

					break;

				case NS_SS_INT_TYPE_CHAR :

					int_char_value = NS_SS_INT_CHAR_NOT_PROVIDED;
					if (i == ASN1_OPTIONAL_PRESENT) {

						if ((Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_POSITIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0x7F)) {

							int_char_value = (char)(Asn1_get_stored_size (p_store_ctx));

						} else if ((Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_NEGATIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0x80)) {

							int_char_value = (uchar)(Asn1_get_stored_size (p_store_ctx)) * (-1);
						}
					}

					*((char FAR *)p_internal_data) = int_char_value;
					break;

				case NS_SS_INT_TYPE_USHORT :

					if ((i == ASN1_OPTIONAL_PRESENT) &&
						(Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_POSITIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0xFFFF)) {

						*((ushort FAR *)p_internal_data) = (ushort)(Asn1_get_stored_size (p_store_ctx));

					} else {	/* integer not provided or not compatible with unsigned short */

						*((ushort FAR *)p_internal_data) = NS_SS_INT_USHORT_NOT_PROVIDED;
					}

					break;

				case NS_SS_INT_TYPE_SHORT :

					int_short_value = NS_SS_INT_SHORT_NOT_PROVIDED;
					if (i == ASN1_OPTIONAL_PRESENT) {

						if ((Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_POSITIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0x7FFF)) {

							int_short_value = (short)(Asn1_get_stored_size (p_store_ctx));

						} else if ((Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_NEGATIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0x8000)) {

							int_short_value = (ushort)(Asn1_get_stored_size (p_store_ctx)) * (-1);
						}
					}

					*((short FAR *)p_internal_data) = int_short_value;
					break;

				case NS_SS_INT_TYPE_ULONG :

					if ((i == ASN1_OPTIONAL_PRESENT) &&
						(Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_POSITIVE)) {

						*((ulong FAR *)p_internal_data) = Asn1_get_stored_size (p_store_ctx);

					} else {	/* integer not provided or not compatible with unsigned long */

						*((ulong FAR *)p_internal_data) = NS_SS_INT_ULONG_NOT_PROVIDED;
					}

					break;

				case NS_SS_INT_TYPE_LONG :

					int_long_value = NS_SS_INT_LONG_NOT_PROVIDED;
					if (i == ASN1_OPTIONAL_PRESENT) { 

						if ((Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_POSITIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0x7FFFFFFFL)) {

							int_long_value = (long)(Asn1_get_stored_size (p_store_ctx));

						} else if ((Asn1_get_store_flag (p_store_ctx) == ASN1_CODING_NEGATIVE) && (Asn1_get_stored_size (p_store_ctx) <= 0x80000000L)) {

							int_long_value = (ulong)(Asn1_get_stored_size (p_store_ctx)) * (-1);
						}
					}

					*((long FAR *)p_internal_data) = int_long_value;
					break;

			} /* end of process according to "internal type" */

				/*	increment repetition counter if the whole repetition sequence has been processed
					(next entry indicated is lower than or equal to current one in Table) */

			if (Ns_ss_ctx_list_next_entry <= cur_entry) {

				repeat_x++;
			}

				/* if maximum number of repetitions is reached, stop storage of current field */

			if (repeat_x > Ns_ss_ctx_list_repeat_nb) {

				break;
			}

				/* update current entry and pointer in description Table using "next_entry" field */

			cur_entry = Ns_ss_ctx_list_next_entry;
			p_ns_ss_ctx_list = p_sav_ctx_list + cur_entry;

				/*	get next storage context only if current one has been used for this instance by
					ASN1 decoder (type is mandatory or optional indicator in common array was "present") */

			if (i == ASN1_OPTIONAL_PRESENT) {

				p_store_ctx = Asn1_get_next_store_ctx (p_store_ctx);
			}

		} /* end of current repetition sequence */

		p_ns_ss_ctx_list++;			/* next entry in clause description Table */
		cur_entry++;

	} /* end of "while (Ns_ss_ctx_list_p_pc != P_NIL)" */

	return;
}

	/* -=-=-=-=-=-=-=-=-=-=-=-=- */

uchar ns_ss_get_internal_value ()
{
	uchar								i, repeat_x;			/* loop index and repetition index */
	uchar								cur_entry;				/* current entry in Table (used for repeated sequence) */
    uchar								optional_x;				/* current index in array of optional indicators */
    uchar								optional_ind;			/* current optional indicator */
	asn1_store_ctx_t FAR				*p_store_ctx;			/* current storage context pointer */
	char								int_char_value;			/* current INTEGER value whose internal type is char */
	short								int_short_value;		/* current INTEGER value whose internal type is short */
	long								int_long_value;			/* current INTEGER value whose internal type is long */
	uchar FAR							*p_internal_data;		/* pointer to internal data location */
	struct ns_asn1_store_desc CONST FAR	*p_sav_ctx_list;		/* saved pointer to list of storage descriptions for current operation or error process */

		/* save pointer to list of storage descriptions for current operation or error clause */

	p_sav_ctx_list = p_ns_ss_ctx_list;
	i = cur_entry = 0;

		/* 	If first entry in Table indicates P_NIL, the entry is used to indicate
			 - maximum number of instances allowed for the operation clause and
			 - interval between adjacent internal structures used for data storage */

	if (Ns_ss_ctx_list_p_pc == P_NIL) {

		ns_i_ss_clause_interval = Ns_ss_ctx_list_interval * ns_i_ss_clause_nb;
		p_ns_ss_ctx_list++;				/* skip first entry */

	} else {

		ns_i_ss_clause_interval = 0;
	}

		/* scan list of all storage descriptions for current operation or error clause */

	while (Ns_ss_ctx_list_p_pc != P_NIL) {

		repeat_x = 0;
		optional_x = Ns_ss_ctx_list_optional_x;

#		if ASSERT == ON
			/*	check consistency of Table : pointer to internal data location must not be NIL
				and interval between 2 instance values must not be null if repetition is possible */

			if ((Ns_ss_ctx_list_p_struct == P_NIL) ||
				((Ns_ss_ctx_list_repeat_nb != 0) && (Ns_ss_ctx_list_interval == 0))) {

				Trap (TRAP_NS_SS_INCONSISTENCY, "ns_ss_get_internal_value");
				return (0);
			}
#		endif

		/*	process current repetition sequence :
			-> 1 instance of current internal field if repetition number (n) is null,
					else
			-> (n+1) instances of current internal field if "next_entry" is current entry itself,
			-> (n+1) times : 1 instance of internal fields, one following each other according
					to each "next_entry" field
		*/

		while (TRUE) {

				/*	get pointer to internal data location using "p_struct" and "interval" fields
					(they indicate the address of first instance data location and the number
					of octets between 2 adjacent instance locations) */

			p_internal_data = Ns_ss_ctx_list_p_struct + ns_i_ss_clause_interval + (Ns_ss_ctx_list_interval * repeat_x);

			if (i >= NS_MX_ASN1_STORE_DESC) {

				/* "type field" specified for opeartion or error process not found in global storage description array */

				Trap (TRAP_NS_SS_INCONSISTENCY, "ns_ss_get_internal_value");
				return (0);
			}

				/* get storage context from storage description structure */

			p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + i);
			Asn1_init_store_ctx	(p_store_ctx);
			optional_ind = ASN1_OPTIONAL_PRESENT;

				/* process according to "internal type" specified in Table */

			switch (Ns_ss_ctx_list_type) {

				case NS_SS_INT_TYPE_ASN1_STRING :
#				if F_QSI == ON
				case NS_SS_INT_TYPE_BIT_STRING :	/* BIT STRING Type : used only in Q-SIG specific operations */
#				endif

						/*	type is a string : use "size" and "address" fields */

					Asn1_get_stored_size (p_store_ctx) = ((struct ns_asn1_string FAR *)p_internal_data) -> size;
					Asn1_get_stored_address (p_store_ctx) = ((struct ns_asn1_string FAR *)p_internal_data) -> p_string;

					if (((struct ns_asn1_string FAR *)p_internal_data) -> p_string == P_NIL) {

						if (((struct ns_asn1_string FAR *)p_internal_data) -> size == 255) {

							optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */

						} else if (((struct ns_asn1_string FAR *)p_internal_data) -> size != 0) {

							optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
						}
                    }
					break;

				case NS_SS_SEQUENCE_OF_NB :

					/*	number of types processed in a list (ASN1 SEQUENCE OF Meta-program) :
						set it in "size" field of ASN1 storage context */

					if (*p_internal_data == 255) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */
					}

					if (*p_internal_data == 254) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}

					Asn1_get_stored_size (p_store_ctx) = *p_internal_data;
					break;

				case NS_SS_CHOICE_INDEX :
                case NS_SS_INT_TYPE_BOOLEAN :

					/*	index ("field_nb") in an ASN1 CHOICE Meta-program or BOOLEAN :
						set it in "size" field of ASN1 storage context */

					if (*p_internal_data == 255) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */
					}

					if (*p_internal_data == 254) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}

					Asn1_get_stored_size (p_store_ctx) = *p_internal_data;
					break;

				/*	FOR ALL FOLLOWING TYPES, ASN1 Type is INTEGER or ENUMERATED : coding flag is
					the sign of integer or ASN1_NO_CODING_DONE and "size" field is the value.
					set sign according to the internal type and set integer value in "size"
					field. if value indicates 'NOT PROVIDED', update optional_ind */

				case NS_SS_INT_TYPE_UCHAR :

					if (*p_internal_data == NS_SS_INT_UCHAR_NOT_PROVIDED) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */
					}

					if (*p_internal_data == (NS_SS_INT_UCHAR_NOT_PROVIDED - 1)) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}

					Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_POSITIVE;
					Asn1_get_stored_size (p_store_ctx) = *p_internal_data;
					break;

				case NS_SS_INT_TYPE_CHAR :

					int_char_value = *((char FAR *)p_internal_data);

					if (int_char_value == NS_SS_INT_CHAR_NOT_PROVIDED) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */

					} else if (int_char_value < 0) {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_NEGATIVE;
						Asn1_get_stored_size (p_store_ctx) = (ulong)(int_char_value * (-1));

					} else {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_POSITIVE;
						Asn1_get_stored_size (p_store_ctx) = (ulong)int_char_value;
					}

					if (int_char_value == (NS_SS_INT_CHAR_NOT_PROVIDED + 1)) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}
					break;

				case NS_SS_INT_TYPE_USHORT :

					if (*((ushort FAR *)p_internal_data) == NS_SS_INT_USHORT_NOT_PROVIDED) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */

					} else {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_POSITIVE;
						Asn1_get_stored_size (p_store_ctx) = *((ushort FAR *)p_internal_data);
					}

					if (*((ushort FAR *)p_internal_data) == (NS_SS_INT_USHORT_NOT_PROVIDED - 1)) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}
					break;

				case NS_SS_INT_TYPE_SHORT :

					int_short_value = *((short FAR *)p_internal_data);

					if (int_short_value == NS_SS_INT_SHORT_NOT_PROVIDED) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */

					} else if (int_short_value < 0) {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_NEGATIVE;
						Asn1_get_stored_size (p_store_ctx) = (ulong)(int_short_value * (-1));

					} else {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_POSITIVE;
						Asn1_get_stored_size (p_store_ctx) = (ulong)int_short_value;
					}

					if (int_short_value == (NS_SS_INT_SHORT_NOT_PROVIDED + 1)) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}
					break;

				case NS_SS_INT_TYPE_ULONG :

					if (*((ulong FAR *)p_internal_data) == NS_SS_INT_ULONG_NOT_PROVIDED) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */

					} else {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_POSITIVE;
						Asn1_get_stored_size (p_store_ctx) = *((ulong FAR *)p_internal_data);
					}

					if (*((ulong FAR *)p_internal_data) == (NS_SS_INT_ULONG_NOT_PROVIDED - 1)) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}
					break;

				case NS_SS_INT_TYPE_LONG :

					int_long_value = *((long FAR *)p_internal_data);

					if (int_long_value == NS_SS_INT_LONG_NOT_PROVIDED) {

						optional_ind = ASN1_OPTIONAL_NOT_PROCESSED;	/* no process */

					} else if (int_long_value < 0) {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_NEGATIVE;
						Asn1_get_stored_size (p_store_ctx) = (ulong)(int_long_value * (-1));

					} else {

						Asn1_get_store_flag (p_store_ctx) = ASN1_CODING_POSITIVE;
						Asn1_get_stored_size (p_store_ctx) = (ulong)int_long_value;
					}

					if (int_long_value == (NS_SS_INT_LONG_NOT_PROVIDED + 1)) {

						optional_ind = ASN1_OPTIONAL_ABSENT;	/* no value but Mark it ABSENT in optional array */
					}
					break;

			} /* end of process according to "internal type" */

			/*	a field is optional if optional_x index in Table is not 255 : if so, it is the index
				of the optional indicator in common array for the first instance of the type -> get current indicator */

			if (Ns_ss_ctx_list_optional_x != 255) {

				if (optional_ind != ASN1_OPTIONAL_NOT_PROCESSED) {

					ns_asn1_optional_indicators [optional_x++] = optional_ind;
				}

			} else if (optional_ind == ASN1_OPTIONAL_ABSENT) {

				optional_ind = ASN1_OPTIONAL_PRESENT;	/* 'ABSENT' has no meaning if Type is not optional -> reset it to 'PRESENT' */
			}

			/*	if value is provided : put "Type field" of meta-program ((p_pc, field_nb)) in storage
				description structure, increment index in common array for storage context (for next one)
				and link context to previous one if necessary (same "Tyep field" for both contexts) */

			if (optional_ind == ASN1_OPTIONAL_PRESENT) {

				ns_asn1_tab_store_info[i].p_pc = (uchar FAR *)Ns_ss_ctx_list_p_pc;
				ns_asn1_tab_store_info[i].field_nb = Ns_ss_ctx_list_field_nb;

				if ((i != 0) &&
					(ns_asn1_tab_store_info[i - 1].p_pc == (uchar FAR *)Ns_ss_ctx_list_p_pc) &&
					(ns_asn1_tab_store_info[i - 1].field_nb == Ns_ss_ctx_list_field_nb)) {

					ns_asn1_tab_store_info[i - 1].store_ctx.p_next = p_store_ctx;
				}

				i++;
			}

				/*	increment repetition counter if the whole repetition sequence has been processed
					(next entry indicated is lower than or equal to current one in Table) */

			if (Ns_ss_ctx_list_next_entry <= cur_entry) {

				repeat_x++;
			}

				/* if maximum number of repetitions is reached, stop reading values of current field */

			if ((Ns_ss_ctx_list_repeat_nb == 0) ||
				(repeat_x > Ns_ss_ctx_list_repeat_nb)) {

				break;
			}

				/* update current entry and pointer in description Table using "next_entry" field */

			cur_entry = Ns_ss_ctx_list_next_entry;
			p_ns_ss_ctx_list = p_sav_ctx_list + cur_entry;

		} /* end of current repetition sequence */

		p_ns_ss_ctx_list++;			/* next entry in clause description Table */
		cur_entry++;

	} /* end of "while (Ns_ss_ctx_list_p_pc != P_NIL)" */

	return (i);
}

	/* -=-=-=-=-=-=-=-=-=-=-=-=- */

void ns_ss_init_internal_op ()
{
	uchar		repeat_x;				/* repetition counter */
	uchar FAR	*p_internal_data;		/* pointer to internal data location */

		/* 	If first entry in Table indicates P_NIL, the entry is used to indicate
			 - maximum number of instances allowed for the operation clause and
			 - interval between adjacent internal structures used for data storage */

	if (Ns_ss_ctx_list_p_pc == P_NIL) {

		ns_i_ss_clause_interval = Ns_ss_ctx_list_interval * ns_i_ss_clause_nb;
		p_ns_ss_ctx_list++;				/* skip first entry */

	} else {

		ns_i_ss_clause_interval = 0;
	}

		/* scan list of all storage descriptions for current operation or error clause */

	while (Ns_ss_ctx_list_p_pc != P_NIL) {

			/*	process current repetition sequence : (n+1) instances of current internal field (n = repetition number) */

		for (repeat_x = 0; repeat_x <= Ns_ss_ctx_list_repeat_nb; repeat_x++) {

				/*	get pointer to internal data location using "p_struct" and "interval" fields
					(they indicate the address of first instance data location and the number
					of octets between 2 adjacent instance locations) */

			p_internal_data = Ns_ss_ctx_list_p_struct + ns_i_ss_clause_interval + (Ns_ss_ctx_list_interval * repeat_x);

				/* init value according to "internal type" specified in Table */

			switch (Ns_ss_ctx_list_type) {

				case NS_SS_INT_TYPE_ASN1_STRING :
#				if F_QSI == ON
				case NS_SS_INT_TYPE_BIT_STRING :	/* BIT STRING Type : used only in Q-SIG specific operations */
#				endif

						/*	"size" field = 255,  "p_string" field = NIL */

					((struct ns_asn1_string FAR *)p_internal_data) -> size = 255; 
					((struct ns_asn1_string FAR *)p_internal_data) -> p_string = P_NIL; 
					break;

				case NS_SS_SEQUENCE_OF_NB :
				case NS_SS_CHOICE_INDEX :
                case NS_SS_INT_TYPE_BOOLEAN :

					/*	index ("field_nb") in an ASN1 CHOICE Meta-program = 255 or
						number of types processed in a list (ASN1 SEQUENCE OF) = 255
						or BOOLEAN = 255 */

					*p_internal_data = 255;
					break;

				case NS_SS_INT_TYPE_UCHAR :

					*p_internal_data = NS_SS_INT_UCHAR_NOT_PROVIDED; 
					break;

				case NS_SS_INT_TYPE_CHAR :

					*(char FAR *)p_internal_data = NS_SS_INT_CHAR_NOT_PROVIDED;
					break;

				case NS_SS_INT_TYPE_USHORT :

					*(ushort FAR *)p_internal_data = NS_SS_INT_USHORT_NOT_PROVIDED;
					break;

				case NS_SS_INT_TYPE_SHORT :

					*(short FAR *)p_internal_data = NS_SS_INT_SHORT_NOT_PROVIDED;
					break;

				case NS_SS_INT_TYPE_ULONG :

					*(ulong FAR *)p_internal_data = NS_SS_INT_ULONG_NOT_PROVIDED;
					break;

				case NS_SS_INT_TYPE_LONG :

					*(long FAR *)p_internal_data = NS_SS_INT_LONG_NOT_PROVIDED;
					break;

			} /* end of init according to "internal type" */

		} /* end of current repetition sequence */

		p_ns_ss_ctx_list++;			/* next entry in clause description Table */

	} /* end of "while (Ns_ss_ctx_list_p_pc != P_NIL)" */
}

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            ns_ss_fac_comp_in_ssdu - implements the encoding of a
				FACILITY component to be sent in a ssdu from internal data.

Name            ns_ss_fac_comp_from_ssdu - implements the storage of a
				FACILITY component received in a ssdu into internal data.

Usage           uchar ns_ss_fac_comp_in_ssdu (uchar last_flag);
Usage           uchar ns_ss_fac_comp_from_ssdu (void);

Return value	ns_ss_fac_comp_in_ssdu : OK if component is valid, NOK else.
				ns_ss_fac_comp_from_ssdu : NOK if component is not valid, else
				STOP if it is the last component in Facility IE, CONTINUE else.

common objects : internal data structure i_facility, ie ssdu context,
				 global pointers : p_ns_fac_component, p_ns_ss_op_err_tab.

*--------------------------------------------------------------------------*/

uchar ns_ss_fac_comp_in_ssdu (last_flag)
	uchar			last_flag;			/* flag indicating if component is the last one in IE */
{
	uchar	FAR		*p_fac_data;		/* pointer to current facility data inside SSDU */
	uchar			i;					/* loop index */

#	if NEW_FCT_STYLE == ON
		uchar			(*p_op_content_fct)	(uchar FAR *p_start, ushort offset);	/* pointer to function specific for operation content process */
#	else
		uchar			(*p_op_content_fct)	();
#	endif

	p_op_content_fct = FCT_NIL;										/* init pointer to function */
	p_fac_data	= p_ssdu_val;										/* init pointer to store facility data */
	p_ssdu_val	+= Rnd_sizeof (struct ns_ss_fac_comp);				/* set p_ssdu_val pointer to next data */

	if (p_ssdu_val >= p_ssdu_end) {

		p_ssdu_val = p_fac_data;
		return (NOK);
	}

	Ns_ss_fac_comp_tag	= I_ss_fac_comp_tag;						/* component tag */

	if (I_ss_fac_comp_tag == FAC_REJECT) {

		Ns_ss_fac_is_inv_id_here = I_ss_fac_is_inv_id_here;			/* presence of Invoke identifier */

	} else {	/* presence of Linked identifier or of operation data in result (same internal and interface fields) */

		Ns_ss_fac_is_lk_id_here = I_ss_fac_is_lk_id_here;
	}

	Ns_ss_fac_invoke_id = I_ss_fac_invoke_id;						/* Invoke identifier */

	if (I_ss_fac_comp_tag == FAC_REJECT) {	/* Reject component */

		Ns_ss_fac_problem_tag = I_ss_fac_problem_tag;				/* type of problem */
		Ns_ss_fac_problem = I_ss_fac_problem;						/* identifier of problem */
		Ns_ss_fac_comp_data_offset = OFFSET_NIL;					/* no other data in Reject component */

	} else if ((I_ss_fac_comp_tag == FAC_RETURN_RESULT) && (I_ss_fac_is_result_here == ABSENT)) {

		Ns_ss_fac_comp_data_offset = OFFSET_NIL;					/* no other data in ReturnResult component */

	} else {

		Ns_ss_fac_linked_id = I_ss_fac_linked_id;					/* Linked identifier */
		Ns_ss_fac_op_err_id = I_ss_fac_op_err_id;					/* NS interface identifier of operation or error */

			/* search NS interface identifier of operation or error in country specific Table */

		if (I_ss_fac_comp_tag == FAC_RETURN_ERROR) {	/* ReturnError component */

			if ((p_ns_ss_error = Ns_ss_error_table) == P_NIL) {

				return (NOK);
			}

			for (i = 0; i < Ns_ss_error_tab_sz; i++, p_ns_ss_error++) {

				if (I_ss_fac_op_err_id == Ns_ss_err_id) {	/* error found in Table */

					/* only 1 error may contain PARAMETER data : Q-SIG specific error "Unspecified"
						in this case, set pointer to function to process error content */

#					if F_QSI == ON
					if (I_ss_fac_op_err_id == SS_ERR_QSI_UNSPECIFIED) {

						p_op_content_fct = ns_ssdu_err_qsi_unspecified;
					}
#					endif
					break;
				}
			}

			if (i == Ns_ss_error_tab_sz) {

				return (NOK);		/* error not found in Table */
			}

		} else {	/* Invoke or ReturnResult component */

			if ((p_ns_ss_operation = Ns_ss_operation_table) == P_NIL) {

				return (NOK);
			}

			for (i = 0; i < Ns_ss_operation_tab_sz; i++, p_ns_ss_operation++) {

				if (I_ss_fac_op_err_id == Ns_ss_op_id) {	/* operation found in Table */

					p_op_content_fct = Ns_ss_op_ssdu_fct;	/* get pointer to content process function */
					break;
				}
			}

			if (i == Ns_ss_operation_tab_sz) {

				return (NOK);		/* operation not found in Table */
			}
		}

		if ((p_op_content_fct == FCT_NIL) || (I_ss_fac_is_op_err_data == ABSENT)) {

			Ns_ss_fac_comp_data_offset = OFFSET_NIL;	/* no other data in component */

		} else {

			Ns_ss_fac_comp_data_offset = (ushort)(p_ssdu_val - p_fac_data);
			ns_ss_i_op_err_clause_nb (I_ss_fac_comp_tag, I_ss_fac_op_err_id);

			i = p_op_content_fct (p_fac_data, 0);		/* process function specific to operation or error and get return code */

				/* return code may be : NOK -> an error is found, OK -> no error in data, other -> no data */

			if (i == NOK) {

				return (NOK);
			}

			if (i != OK) {

				Ns_ss_fac_comp_data_offset = OFFSET_NIL;	/* no other data in component : reset offset */
			}

			p_ssdu_val	= (uchar FAR *)Round ((long)p_ssdu_val);	/* Structure alignment */
		}
	}

		/* load offset of next component in IE */

	if (last_flag == ON) {

		Ns_ss_fac_next_comp_offset = OFFSET_NIL;

	} else {

		if ((p_ssdu_val - p_fac_data) <= (ushort)(~0)) {	/* Load offset value */

			Ns_ss_fac_next_comp_offset = (ushort)(p_ssdu_val - p_fac_data);

		} else {

			Trap (TRAP_NS_SSDU_IE_OFFSET_OVERFLOW, "ns_ss_facility_in_ssdu");
			return (NOK);
		}
	}

	return (OK);
}

	/* -=-=-=-=-=-=-=-=- */

uchar ns_ss_fac_comp_from_ssdu ()
{
	uchar	FAR		*p_fac_data;		/* pointer to current facility data inside SSDU */
	uchar			i;					/* loop index */

#	if NEW_FCT_STYLE == ON
		uchar			(*p_op_content_fct)	(uchar FAR *p_start, ushort offset);	/* pointer to function specific for operation content process */
#	else
		uchar			(*p_op_content_fct)	();
#	endif

	p_op_content_fct = FCT_NIL;										/* init pointer to function */
	p_fac_data	= p_ssdu_val;										/* init pointer to store facility data */

	switch (Ns_ss_fac_comp_tag) {	/* check component tag */

		case FAC_INVOKE :
		case FAC_RETURN_RESULT :

				/* presence of Linked identifier or of operation data in result (same internal and interface fields) */

			I_ss_fac_is_lk_id_here = Ns_ss_fac_is_lk_id_here;
			I_ss_fac_linked_id = Ns_ss_fac_linked_id;				/* Linked identifier */

		case FAC_RETURN_ERROR :

			I_ss_fac_op_err_id = Ns_ss_fac_op_err_id;				/* NS interface identifier of operation or error */
			break;

		case FAC_REJECT :

			I_ss_fac_is_inv_id_here = Ns_ss_fac_is_inv_id_here;		/* presence of Invoke identifier */
			I_ss_fac_problem_tag = Ns_ss_fac_problem_tag;			/* type of problem */
			I_ss_fac_problem = Ns_ss_fac_problem;					/* identifier of problem */

			if (Ns_ss_fac_comp_data_offset != OFFSET_NIL) {		/* no other data in Reject component */

				return (NOK);
			}

			break;

		default :

			return (NOK);
	}

	I_ss_fac_comp_tag = Ns_ss_fac_comp_tag;			/* store component tag */
	I_ss_fac_invoke_id = Ns_ss_fac_invoke_id;		/* store Invoke identifier */

		/* search NS interface identifier of operation or error in country specific Table */

	if (I_ss_fac_comp_tag == FAC_RETURN_ERROR) {	/* ReturnError component */

		if ((p_ns_ss_error = Ns_ss_error_table) == P_NIL) {

			return (NOK);
		}

		for (i = 0; i < Ns_ss_error_tab_sz; i++, p_ns_ss_error++) {

			if (I_ss_fac_op_err_id == Ns_ss_err_id) {	/* error found in Table */

				/* only 1 error may contain PARAMETER data : Q-SIG specific error "Unspecified"
					in this case, set pointer to function to process error content */

#				if F_QSI == ON
				if (I_ss_fac_op_err_id == SS_ERR_QSI_UNSPECIFIED) {

					p_op_content_fct = ns_ssdu_err_qsi_unspecified;
				}
#				endif
				break;
			}
		}

		if (i == Ns_ss_error_tab_sz) {

			return (NOK);		/* error not found in Table */
		}

	} else if ((I_ss_fac_comp_tag == FAC_INVOKE) ||
			   ((I_ss_fac_comp_tag == FAC_RETURN_RESULT) && (I_ss_fac_is_result_here == PRESENT))) {

			/* Invoke or ReturnResult (with operation data) component */

		if ((p_ns_ss_operation = Ns_ss_operation_table) == P_NIL) {

			return (NOK);
		}

		for (i = 0; i < Ns_ss_operation_tab_sz; i++, p_ns_ss_operation++) {

			if (I_ss_fac_op_err_id == Ns_ss_op_id) {	/* operation found in Table */

				p_op_content_fct = Ns_ss_op_ssdu_fct;	/* get pointer to content process function */

				if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* get storage description Table to initialize internal structure */

					p_ns_ss_ctx_list = Ns_ss_op_arg_ctx_list;

				} else {

					p_ns_ss_ctx_list = Ns_ss_op_result_ctx_list;
				}
				break;
			}
		}

		if (i == Ns_ss_operation_tab_sz) {

			return (NOK);		/* operation not found in Table */
		}
	}

	if (p_op_content_fct == FCT_NIL) {

		if (Ns_ss_fac_comp_data_offset != OFFSET_NIL) {	/* other data in component but no function to process it -> Return NOK */

			return (NOK);
		}

	} else {	/* process function specific to operation or error */

		ns_ss_i_op_err_clause_nb (I_ss_fac_comp_tag, I_ss_fac_op_err_id);

		if (p_ns_ss_ctx_list != P_NIL) {

				/* 	If first entry in Table indicates P_NIL, the entry is used to indicate
					 - maximum number of instances allowed for the operation clause and
					 - interval between adjacent internal structures used for data storage */

			if (Ns_ss_ctx_list_p_pc == P_NIL) {

				i = Ns_ss_ctx_list_repeat_nb;	/* get number of instances allowed */

			} else {

				i = 1;	/* no repetition allowed -> number of instances allowed is 1 */
			}

				/* check that number of instances found does not exceed maximum allowed */

			if (ns_i_ss_clause_nb >= i) {

				return (NOK);
			}

			ns_ss_init_internal_op ();	/* initialize internal structures used to store operation data */
		}

		if (Ns_ss_fac_comp_data_offset == OFFSET_NIL) {

			I_ss_fac_is_op_err_data = ABSENT;

		} else {

			I_ss_fac_is_op_err_data = PRESENT;
		}

		if (p_op_content_fct (p_fac_data, Ns_ss_fac_comp_data_offset) == NOK) {

			return (NOK);
		}
	}

	if (Ns_ss_fac_next_comp_offset == OFFSET_NIL) {	/* this is the last component in Facility IE */

		return (STOP);

	} else { /* another component follows */

		p_fac_data += Ns_ss_fac_next_comp_offset;	/* get data location of next component */

		if ((p_fac_data < p_ssdu_val) || (p_fac_data > p_ssdu_end)) {

				/* next component data is after end of SSDU or before end of current component ! */

			return (NOK);
		}

		p_ssdu_val = p_fac_data;	/* update SSDU pointer to next component data using offset */
		return (CONTINUE);
	}
}

/*==========================================================================

			- Local function prototype declarations -
*/

#if NEW_FCT_STYLE == ON
	void	ns_reset_ss_ie_i 				(void);
	uchar	ns_check_get_tag 				(uchar CONST FAR *p_list, uchar list_size, uchar value, uchar FAR *p_tag_nb);
	ushort	ns_decode_asn1_lgth 			(void);
	void	ns_encode_asn1_lgth				(uchar FAR *p_data, uchar length);
	void 	ns_get_country_op_err_tab		(ushort country);
	uchar	ns_decode_ss_op_err_val			(uchar FAR *p_end, uchar flag);
	uchar	ns_encode_ss_op_err_val			(uchar flag);
	void	ns_ss_store_internal_value		(void);
	uchar	ns_ss_fac_comp_in_ssdu			(uchar last_flag);
	uchar	ns_ss_fac_comp_from_ssdu		(void);

		/* in ANS1 library */

	uchar 	Asn1_encode_integer 			(ulong value, uchar sign, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
#else
	void	ns_reset_ss_ie_i 				();
	uchar	ns_check_get_tag 				();
	ushort	ns_decode_asn1_lgth 			();
	void	ns_encode_asn1_lgth				();
	void 	ns_get_country_op_err_tab		();
	uchar	ns_decode_ss_op_err_val			();
	uchar	ns_encode_ss_op_err_val			();
	void	ns_ss_store_internal_value		();
	uchar	ns_ss_fac_comp_in_ssdu			();
	uchar	ns_ss_fac_comp_from_ssdu		();

		/* in ANS1 library */

	uchar 	Asn1_encode_integer 			();
#endif

/*==========================================================================

			- Network specific functions -
*/

#if F_ETS == ON
#	include "ets.net_iess"
#endif

#if F_QSI == ON
#	include "qsi.net_iess"
#endif

/*-------------------------------------------------------------------------*/

#if OM_CODE_TYPE == OM_PIC /* PIC used{ */

#undef Ns_eur_table_or_function
#undef Ns_eur_end_table_or_function
#undef Ns_ss_store_desc_entry
#undef Ns_ss_op_tab_entry

#if F_QSI == ON
#	undef Ns_qsi_table_or_function
#	undef Ns_qsi_end_table_or_function
#endif

#undef NS_ASN1_SEQUENCE
#undef NS_ASN1_SEQUENCE_OF
#undef NS_ASN1_SET_OF
#undef NS_ASN1_CHOICE
#undef NS_ASN1_NUMERIC_STRING
#undef NS_ASN1_IA5_STRING

#undef D_ASN1_TYPE_START
#undef D_ASN1_TYPE_FIELD_NB
#undef D_ASN1_TYPE_END

#undef ASN1_TYPE_START
#undef ASN1_TYPE_IDENT
#undef ASN1_TYPE_NO_FIELD
#undef ASN1_TYPE_FIELD_NB
#undef ASN1_TYPE_FIELD
#undef ASN1_TYPE_LAST_FIELD
#undef ASN1_TYPE_OPTIONAL_FIELD
#undef ASN1_TYPE_OPT_LAST_FIELD
#undef ASN1_TYPE_END

#define Ns_eur_table_or_function(str, tab)	i_pic = 0;						\
											{								\
												struct str FAR	*p_table;	\
												p_table = tab;

#define Ns_eur_end_table_or_function		}

#if F_QSI == ON
#	define Ns_qsi_table_or_function(str, tab)	Ns_eur_table_or_function(str, tab)
#	define Ns_qsi_end_table_or_function			Ns_eur_end_table_or_function
#endif

#define Ns_ss_store_desc_entry(mp_a, f_nb, type, p_str, i_inter, rep, next,opt)	\
	Pic_init_struct_array (p_table,  i_pic, p_pc, mp_a);						\
	Pic_init_struct_array_next (p_table,  p_struct, p_str);

#define Ns_ss_op_tab_entry(if_id, tag, val, p_arg, p_ctx_arg, p_res, p_ctx_res, ssdu_fct)	\
	Pic_init_struct_array (p_table,  i_pic, p_argument_prog, p_arg);						\
	Pic_init_struct_array (p_table,  i_pic, p_arg_ctx_list, p_ctx_arg);						\
	Pic_init_struct_array (p_table,  i_pic, p_result_prog, p_res);							\
	Pic_init_struct_array_next (p_table,  p_res_ctx_list, p_ctx_res);

#define NS_ASN1_SEQUENCE
#define NS_ASN1_SEQUENCE_OF
#define NS_ASN1_SET_OF
#define NS_ASN1_CHOICE
#define NS_ASN1_NUMERIC_STRING
#define NS_ASN1_IA5_STRING

#define D_ASN1_TYPE_START(type)
#define D_ASN1_TYPE_FIELD_NB(nb)
#define D_ASN1_TYPE_END

#define ASN1_TYPE_START(type)					{									\
													struct type FAR *p_asn1_mp;		\
													p_asn1_mp = &type;

#define ASN1_TYPE_IDENT(type_id, impl, class, tag_nb)

#define ASN1_TYPE_NO_FIELD
#define ASN1_TYPE_FIELD_NB(nb)						p_asn1_type_field = &(p_asn1_mp -> next_p_pc_tab[0]);

#define ASN1_TYPE_FIELD(name)						p_asn1_type_field -> p_pc = (uchar FAR *)&name;\
													p_asn1_type_field -> opt_ind_list = P_NIL;	\
													p_asn1_type_field++;

#define ASN1_TYPE_LAST_FIELD(name)					p_asn1_type_field -> p_pc = (uchar FAR *)&name;\
													p_asn1_type_field -> opt_ind_list = P_NIL;

#define ASN1_TYPE_OPTIONAL_FIELD(name, i_list)		p_asn1_type_field -> p_pc = (uchar FAR *)&name;\
													p_asn1_type_field -> opt_ind_list = i_list;	\
													p_asn1_type_field++;

#define ASN1_TYPE_OPT_LAST_FIELD(name, i_list)		p_asn1_type_field -> p_pc = (uchar FAR *)&name;\
													p_asn1_type_field -> opt_ind_list = i_list;

#define ASN1_TYPE_END							};

		/*	Function used to initialize address fields in Tables */

void pic_init_ns_ss_ie ()
{
	uchar							i_pic;					/* current index */
	struct asn1_optional_type FAR	*p_asn1_type_field;		/* pointer to current Type field inside ASN1 meta-program */

		/* init common Table 'NS_SS_OPERATION_ERROR_TAB' defined above */

	i_pic = 0;

#	if NS_USE_EUROPE_OPERATION == ON
		Pic_init_struct_array (NS_SS_OPERATION_ERROR_TAB, 0, p_op_tab, EUROPE_OPERATION_TAB);
		Pic_init_struct_array (NS_SS_OPERATION_ERROR_TAB, 0, p_err_tab, EUROPE_ERROR_TAB);
		Pic_init_struct_array (NS_SS_OPERATION_ERROR_TAB, 0, p_obj_id_list, NS_EUROPE_OBJ_ID_TREE);
        i_pic++;
#	endif

#	if F_QSI == ON
		Pic_init_struct_array (NS_SS_OPERATION_ERROR_TAB, i_pic, p_op_tab, NS_QSI_OPERATION_TAB);
		Pic_init_struct_array (NS_SS_OPERATION_ERROR_TAB, i_pic, p_err_tab, NS_QSI_ERROR_TAB);
		Pic_init_struct_array (NS_SS_OPERATION_ERROR_TAB, i_pic, p_obj_id_list, NS_QSI_OBJ_ID_TREE);
#	endif

		/* init common ASN1 Meta-program structure used for operation value type */

	ASN1_TYPE_START			(NS_SS_OP_ERR_VAL_P)
		NS_ASN1_CHOICE
		ASN1_TYPE_FIELD_NB		(2)
		ASN1_TYPE_FIELD			(NS_SS_INTEGER_P)
		ASN1_TYPE_LAST_FIELD	(NS_SS_OBJECT_IDENTIFIER_P)
	ASN1_TYPE_END

		/* init specific Tables and ASN1 Meta-program structures */

#	include "eur.ns_sstab"

#	if F_QSI == ON
#		include "qsi.ns_sstab"
#	endif 

};

#endif /* end of PIC used} */


#endif /* NS_SUPP_SERVICES == ON} */

/* EOF */
