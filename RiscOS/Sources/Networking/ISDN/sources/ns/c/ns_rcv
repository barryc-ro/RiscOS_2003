
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_rcv.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *        ns_rcv - implements the processing of a message addressed to
 *		  the Network Signalling entity.
 *
 *        ns_establish_dl - implements the test of the Link Connection
 *		  state and if necessary requests the establishment of it.
 *
 *        ns_reassembly_process - implements the message segmentation
 *		  reassembly function.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "ns.h"
#include "isdn.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#include "ctx_ext.h"

extern	uchar					error_type;			/* type of the current error */
extern	struct message		FAR *p_msg_broadcast;	/* pointer on message to broadcast on the different INTERFACE nai's (AT9 SPID purpose) */
extern	ces_t					saved_ces;			/* saved ces (for broadcast message diffusion) */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_rcv - implements the processing of a message adressed
						 to the NS entity.

Usage           uchar ns_rcv (void);

Description     implements the receiving of a message adressed to the NS
				entity. The processing of the mesage is done according to
				the origination entity and to the message code (event_id).
				If the message is coming from the network or from the user
				it is syntaxically and semantically checked.

				The return code of the function is used to indicate if
				the message has been entirely processed of if the next step
				of the processing should be called.

Return value    return code = CONTINUE	valid message continue the processing,
							= STOP		message completly processed by ns_rcv,
							= NOK 		erroneous SPDU or SSDU.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar ns_rcv ()
{
	ushort 				 i;						/* temporary loop index */
	uchar				 ti_dl_flag;			/* timer associated to DLCI flag */
	nai_t				 nai;					/* NAI */
	code_t				 code;					/* primitive code */
	struct nsna FAR		*p_nsna_sav;			/* temporary pointer on NA context */
	struct buffer FAR	*p_buffer_tmp;			/* temporary pointer on buffer structure */

#	if RESET_CONFIG == ON
		struct nsna		FAR	*p_na_prior;		/* NA prior pointer */
		struct call		FAR *p_call_sav;		/* call pointer backup */
#	endif

#	if (NS_RESTART_PROCEDURE == ON) || (NS_MAINTENANCE_CAPABILITY == ON) || (RESET_CONFIG == ON)
		uchar			FAR	*p_data;
#	endif

	i_entity_origination = R_msg_from;
	code				 = R_msg_code;
	nai					 = R_msg_nai;

	if ((i_entity_origination == ENT_DL) || (i_entity_origination == ENT_DL_D)) {

#		if NS_MAINTENANCE_CAPABILITY == ON

			ns_get_ctx_d_chan_bearer (R_msg_nai);

			if ((ret_code = ns_get_nfas_nai (&nai)) != OK) {

				return (ret_code);
			}

#		endif

			/*
				Access to the INTERFACE NA corresponding to the dl_nai
				and the CES.
			*/

		if (Ns_access_dl_na (nai, (p_msg_broadcast == P_NIL) ? R_msg_ces : saved_ces) == NOK) {
			return (NOK);
		}

		if (R_msg_ces == DL_CES_BROADCAST) {

				/*
					Duplicate the message in order to send it
					to other terminals if any.
				*/

			p_nsna_sav = p_nsna;

			if ((Na_type == BRI) &&
				(ns_access_dl_next_na (nai, saved_ces) == OK)) {

#				if NS_TYPE_BRI == ON

						/* Copy the received message if not already done */

					p_msg_broadcast = Alloc_msg ();
					Memcpy_far ((char FAR *)p_msg_broadcast, (char FAR *)p_rcv_msg, (R_msg_data_offset + R_msg_data_size));

					if (p_buffer != P_NIL) {
						p_buffer_tmp	= Alloc_buffer ();
						Memcpy_far ((char FAR *)p_buffer_tmp, (char FAR *)p_buffer, (Buffer_data_offset + Buffer_data_size));
						p_msg_broadcast -> p_buff = p_buffer_tmp;
					}

						/* Record the next ces to be used */

					saved_ces = Na_dl_ces;

#				endif

			} else {

					/* Reset the saved message pointer */

				p_msg_broadcast = P_NIL;
			}

			p_nsna = p_nsna_sav;	/* Restore context on previously found context */

		}

			/* Reset nai parameter with the NS INTERFACE nai */

		nai = Nai;

	} else

#		if RESET_CONFIG == ON

			if ( (i_entity_origination == ENT_MNS) &&
				 (code == MNS_RESET_CONFIG_RQ)) {

					/* no access needed */

			} else

#		endif

	{
			/* access to the INTERFACE na */

		if (ns_access_na (nai) != OK) {

			if ((i_entity_origination != ENT_MNS) &&
				(i_entity_origination != ENT_TI)) {

					/* interface user entity */

				error_set (ERR_U_NAI, 0, 0);
				return (NOK);

			} else {

					/* message from MNS or from TI : stop processing */

				return (STOP);
			}

		}

#		if NS_MAINTENANCE_CAPABILITY == ON

				/*
				 * The primitive does not come DL.
				 * Update the NFAS related flags.
				 */

			ns_nfas = OFF;

			if (Na_nfas == ON) {
				Ns_access_d_chan_ctx (Na_d_channel_ctx);
				Nfas_nai_line = R_msg_nai;
				ns_nfas = ON;
			}

#		endif

	}

#	if ONE_NETWORK == OFF

			/* Update NS Na data context pointers */

		ns_build_p_table ();

#	endif

#	if NS_MAINTENANCE_CAPABILITY == ON

			/*
			 * Warning !
			 * Ns_filter needs the Na_network to be up to date.
			 * So, in case we may have multiple networks,
			 * it must be called after the ns_build_p_table routine.
			 * This routine is to be called even if the ns_nfas
			 * is OFF because that case might be the NFAS_TSP case.
			 */

		if (Ns_filter (R_msg_code,0) != CONTINUE) {
			return (STOP);
		}

#	endif

	if (i_entity_origination == ENT_MNS) {

		switch (code) {

			case MNS_CLEAR_BUSY_RQ :

				if (!Ctx_backup_exist) return (STOP);

				switch (Ctx_backup_event) {

					case DL_REL_IN 	:
					case DL_EST_IN 	:

							/*
							  Is the Network Access ID valid ?
								no 	---> error,
								yes ---> p_nsna points on the current NA ocurrence.
							*/

						if (ns_access_na (Ctx_backup_nai) == NOK) {

							return (NOK);
						}

#						if ONE_NETWORK != ON

								/* Update NS Na data context pointers */

							ns_build_p_table ();

#						endif

							/* Set DL context pointer p_nsdl */

						if (Ns_access_dl_ces (Ctx_backup_ces) == NOK) {

							if (error_set (ERR_N_CES, 0, 0) == FATAL) {
								return (NOK);
							}

						}

						if ((Lc_state != LC_ESTABLISHED) ||
							((Lc_state == LC_ESTABLISHED) && (Ctx_backup_event == DL_EST_IN))) {
							R_msg_from		= Ctx_backup_entity;
							R_msg_code		= code 		= Ctx_backup_event;
							R_msg_nai		= nai		= Ctx_backup_nai;
							R_msg_ces		= Ctx_backup_ces;

							if ((Ctx_backup_event == DL_EST_IN) &&
								(Ctx_backup_action == ACTION_RESET)) {

								/*
								 * Force the LC_RELEASED state
								 * in order to continue the process.
								 */

								Lc_state	= LC_RELEASED;

							} else {

								/*
								 * Force the LC_ESTABLISED state
								 * in order to continue the process.
								 */

								Lc_state	= LC_ESTABLISHED;
							}

							break;
						}

					default :
						return (STOP);

				}

				break;

		}
	}

		/* DISPATCH ACCORDING TO THE ORIGINATION ENTITY */

	switch (R_msg_from) {

		/*------------------------------------------------------------------*
		*																	*
		*		FROM LAYER 4 or CALL CONTROL ENTITY							*
		*																	*
		*-------------------------------------------------------------------*/

		case ENT_CC :
		default :

				/* Congestion busy ? yes set a message error */

			if ((Congestion_busy == ON) &&
				((code == NS_CONN_RQ) || (code == NS_RESUME_RQ))
			   ) {

				if (error_set (ERR_U_CONGESTION_BUSY, 0, 0) == FATAL) {
					return (NOK);
				}
			}

					/*
					   Is the connect ID valid ?
					   if valid set the p_call pointer on the call context.
					*/

			if (R_msg_conn_id != CONN_ID_MANAGEMENT) {

				if (ns_access_conn_id (ANY_CALL, R_msg_conn_id) == NOK) {
					error_set (ERR_U_CALL_CONN_ID_UNKNOWN, 0, 0);
					return (NOK);
				}

					/* Is it a CONN_IN redirection request ? */

				if (code == NS_REDIR_CONN_RQ) {

						/*
							Redirect the NS_CONN_IN sent back by ENT_CC to
							the new upper entity, and register it in the call
							context.
						*/

					Call_upper_ent	= (ent_id_t)R_msg_inf0;

					R_msg_from 		= ENT_NS;
					R_msg_to 		= Call_upper_ent;
					R_msg_code 		= NS_CONN_IN;

					Send_message (p_rcv_msg), p_rcv_msg = P_NIL;

					return (STOP);
				}

					/* Get the primitive code : SSDU ID */

				ssdu_id = event_id = code;	/* the primitive code is the event ID */

					/* Is the SSDU ID known in the network interface ? */

				if (Access_tab_ssdu (Search_key_ssdu (ssdu_id)) == X_SSDU_NIL) {

					if (error_set (ERR_U_SSDU_CODE, ssdu_id, 0) == FATAL) {
						return (NOK);
					}

				}

					/* Dispatch according to the primitive code */

				switch (ssdu_id) {

						/*
						   No call context previously allocated to the connection
						   call :
								- Connect Request primitive,
								- Resume Request primitive,
								- Facility Registration Request primitive (not allowed
                                on NT-side in Point-to-Multipoint configuration);
						*/

					case  NS_SPF_REGISTRATION_RQ 	:

						if ((Na_fct == FG_NT_TE) && (Na_connection_pmp)) {

							error_set (ERR_U_SSDU_UNEXPECTED, ssdu_id, 0);
							return (NOK);
						}

					case  NS_CONN_RQ 				:
					case  NS_RESUME_RQ 				:

						if ( ! ((Call_state == STATE_NIL) || (Call_state == STATE_WAIT_DL))) {
							error_set (ERR_U_CALL_CONN_ID_ALREADY_USED, 0, 0);
							p_call = P_NIL; 						/* no call context */
							return (NOK);
						}

						if (Call_state == STATE_NIL) {

								/*
								   Allocate a context if connection ID is valid
								   and context available.
								   Init the context to the NULL state.
								*/


							error_type = ERR_U_NO_CALL_CTX_AVAILABLE;

							if (allocate_call (OUTGOING_CALL, R_msg_conn_id) == NOK) {

								if (error_set (error_type, 0, 0) == FATAL) {
									return (NOK);
								}

							}

						}

							/* Is the network access connected ? */

						if (Na_status == OFF) {

								/* Clear the request : NS_CLEAR_CO */

								/* Set the i_call_ref */

							I_call_ref 		= Call_ref;
							Set_call_ref_not_nil ();

								/* Init the IE internal list */

							Reset_internal_ie ();

								/* Class and Value into a cause IE */

							set_i_cause (C_C_NA_FAILURE, C_V_NA_DISCONNECTED, P_NIL);

								/* Send the NS_CLEAR_CO primitive to the Call Control entity */

							Send_to_call_control (NS_CLEAR_CO);

								/* Free the Call context and return STOP */

							call_clear ();

							return (STOP);

						}

#						if NS_MAINTENANCE_CAPABILITY == ON

							if (ns_nfas == ON) {
								nfas_insert (Call_ref, Nai);
							}

#						endif

							/* Is the DL connection established ? */

						switch (ns_establish_dl ()) {

								/* Not established ---> wait */

							case STOP :
								return (STOP);

								/* Connection already waiting for DL establishment */

							case NOK :
								error_set (ERR_U_CALL_CONN_ID_ALREADY_USED, 0, 0);
								p_call = P_NIL; 						/* no call context */
								return (NOK);

								/* DL established --> continue */

							case CONTINUE :
								break;
						}

						break;

						/* Init object occurrences from configuration structure */

					default :

#						if NS_RESTART_PROCEDURE == ON

								/*
								 * If the internal call clearing is used
								 * during a RESTART phase, ignore any
								 * NS_RESTART_RQ.
								 */

							if ((Na_internal_restart == ON) && (ssdu_id == NS_RESTART_RQ)) {

								return (STOP);

							} else

#						endif

						{
								/* Call context shall already exist */

							if (Call_state == STATE_NIL) {

								if (error_set (ERR_U_NON_EXISTENT_CALL, 0, 0) == FATAL) {
									return (NOK);
								}

							}

						}

							/* Linked Data link */

						if (Call_ces != DL_CES_NIL) {

#							if NS_MAINTENANCE_CAPABILITY == ON

								if (ns_nfas == ON) {

									p_nsdl = Nfas_dl_p_active_d_chan;

								} else {

									if (Ns_access_dl_ces (Call_ces) == NOK) {
										Trap (TRAP_NO_CES, "ns_rcv");
									}
								}

#							else

								if (Ns_access_dl_ces (Call_ces) == NOK) {
									Trap (TRAP_NO_CES, "ns_rcv");
								}

#							endif


							/*	If The Link Connection associated with the call is not established,
								postpone the processing of the SSDU until it is established. */

							if (Call_state == STATE_WAIT_DL) {

								ns_in_queue_cc (); p_buffer = P_NIL;
								return (STOP);
							}
						}

						break;

				}

					/*  Call reference into internal call reference */

				I_call_ref		= Call_ref;
				Set_call_ref_not_nil ();

			} else {		/* CONN_ID_MANAGEMENT used */

					/* Get the primitive code : SSDU ID */

				ssdu_id = event_id = code;	/* the primitive code is the event ID */

					/* Is the SSDU ID known in the network interface ? */

				if (Access_tab_ssdu (Search_key_ssdu (ssdu_id)) == X_SSDU_NIL) {

					if (error_set (ERR_U_SSDU_CODE, ssdu_id, 0) == FATAL) {
						return (NOK);
					}

				}

				switch (ssdu_id) {

#					if NS_RESTART_PROCEDURE == ON

						case NS_RESTART_RS :

							if (Spdu_param_restart_procedure == ON) {

#								if NS_MAINTENANCE_CAPABILITY == ON

									if (ns_nfas == ON) {

										p_nsdl = Nfas_dl_p_active_d_chan;

									} else {

										Ns_access_dl_ces (Na_dl_ces);
									}

#								else

									Ns_access_dl_ces (Na_dl_ces);

#								endif


								I_call_ref		= 1;
								Set_call_ref_not_nil ();
							}

							break;

#					endif

					case NS_FAC_RQ  :

						if (Net_param_fac_rq_conn_id_mgt == ON) {

							Ns_access_dl_ces (Na_dl_ces);
							Set_call_ref_nil ();

						} else {

							error_set (ERR_U_SSDU_UNEXPECTED, ssdu_id, 0);
							return (NOK);
						}

						break;

					case NS_NOTIFY_RQ  :


						if (Net_param_notify_rq_conn_id_mgt == ON) {

							Ns_access_dl_ces (Na_dl_ces);
							Set_call_ref_nil ();

						} else {

							error_set (ERR_U_SSDU_UNEXPECTED, ssdu_id, 0);
							return (NOK);
						}

						break;

					case NS_INFO_RQ  :

						if (Net_param_info_rq_conn_id_mgt == ON) {

							Ns_access_dl_ces (Na_dl_ces);
							Set_call_ref_nil ();
							break;
						}

					default :

						/* Reject this SSDU */

						error_set (ERR_U_SSDU_UNEXPECTED, ssdu_id, 0);
						return (NOK);
				}

			}

				/*
				   Check (syntaxic and semantic) the integrity of the
				   Signaling Service Data Unit (SSDU) and load the internal
				   data structure according to the received SSDU.
				   If invalid SSDU send a reject message to the Layer 4
				   Signalling entity.

				   If valid return CONTINUE to continue the processing.
				*/

			p_ssdu		= R_a_data;				/* ie offset pointer */
			p_ssdu_end	= p_ssdu + ((p_buffer == P_NIL) ? Message_data_lgth : Buffer_data_lgth);

			return (r_ssdu ());

	   /*-------------------------------------------------------------------*
		*																	*
		*						FROM DATA LINK ENTITY						*
		*																	*
		*-------------------------------------------------------------------*/

/*

			   STATE TRANSITION DIAGRAM FOR SEQUENCES OF PRIMITIVES
							   AT A POINT-TO-POINT

							 ___________
							 | DL_U_DA  |
							 | RQ/IN    |
			  DL_REL_IN      ___________V__   DL_REL_CO
			|-------------->|      LC      |<----------------|
			|	|-----------|   RELEASED   |                 |
			|	|DL_EST_RQ 	----------------                 |
			|	|			  D	|D |D ^	                     |
			|	|			  L |L |L |		                 |
DL_EST_IN   |	|			  E |E |R |			             |    DL_EST_IN
	 _______|___v__ 	      S |S |E |             	   __|_________
	|     LC       |          T |T |L |    DL_U_DA_ ------|   AWAITING |
	| ESTABLISHED  |          C |I |I |    RQ/IN    ----->|   RELEASE  |
	 --------------           O |N |N |              	   -------------
			^   | DL_EST_CO     |  |  |                       ^    DL_REL_IN
			|   |               |  |  |                       |
			|   |    DL_U_DA    |  |  | DL_DA_                |
			|	|	 RQ/IN  ____V__V__|_RQ/IN     DL_DA_RQ/IN |
			|	---------->|     LC       |-------------------
			---------------| ESTABLISHED  |
			DL_EST_RQ	    --------------
						DL_EST_IN		DL_EST_CO

*/

		case ENT_DL_D 	:
		case ENT_DL 	:

				/* Set DL context pointer p_nsdl */

			if (Ns_access_dl_ces (R_msg_ces) == NOK) {

				if (error_set (ERR_N_CES, 0, 0) == FATAL) {
					return (NOK);
				}

			}

				/* DL inactivity timer management : DL activity */

			ns_dl_timer_activity ();

				/* If broadcast only DL_U_DA_IN */

			if ((R_msg_ces == DL_CES_BROADCAST) && (code != DL_U_DA_IN)) {
				Trap (TRAP_NS_BROADCAST, "ns_rcv");
			}

			event_id = EV_NIL; 		/* implicit action = do nothing */

				/* Dispatch according to the DL primitive code */

			switch (code) {

		/* ------------- DL-ESTABLISHMENT-CONFIRM -------------------*/

				case DL_EST_CO :

					Dl_rc 	= 0; 					/* reset dl retry count */
					Dl_tei	= (uchar)R_msg_inf0;	/* Load TEI value */


						/* Switch according to the Link Connection state */

					switch (Lc_state) {

							/*
							   Link Connection Awaiting establishment
							   or released.
							*/

						case LC_RELEASED :
						case LC_AWAITING_EST :

								/* set state = established */

							Lc_state = LC_ESTABLISHED;

								/* Endpoint Intialization procedure */

							Ns_ei (DL_EST_CO, Dl_ces);


								/* Data Link reset */

#							if EQUIPMENT == TE
								csc_dl_reset ();
#							else

								if (Na_fct == FG_NT_TE) {
									csc_dl_reset_n ();

								} else {

									csc_dl_reset ();
								}

#							endif


							break;

								/* Link Connection established */

						case LC_ESTABLISHED :
							break;

								/* Unexpected event */

						case LC_AWAITING_REL:

#							if ASSERT == ON
								Trap (TRAP_LC_INCONSISTENCY, "ns_rcv");
#							else
								break;
#							endif

					} /* lc_state */

					p_call = P_NIL;

					ret_code = STOP;
					break;

			/*----------------- DL-ESTABLISH-INDICATION ---------------*/

				case DL_EST_IN :

					Dl_tei	= (uchar)R_msg_inf0;	/* Load TEI value */
					Dl_rc 	= 0;					/* reset retry count */

						/* Switch according to the Link Connection state */

					switch (Lc_state) {

							/* Link Connection released */

						case LC_RELEASED :
							Lc_state = LC_ESTABLISHED;

#							if NS_SEGMENTATION == ON

									/* Reassembly process */

								if (Spdu_param_segmentation == ON) {
									ns_reassembly_process (code);
								}

#							endif

								/*
									Circuit switched call processing of a
									data link reset.
								*/

#							if EQUIPMENT == TE
								csc_dl_reset ();
#							else

								if (Na_fct == FG_NT_TE) {
									csc_dl_reset_n ();

								} else {

									csc_dl_reset ();
								}

#							endif

							break;

							/* Link Connection reinitialized */

						case LC_ESTABLISHED :

#							if NS_SEGMENTATION == ON

									/* Reassembly process */

								if (Spdu_param_segmentation == ON) {
									ns_reassembly_process (code);
								}

#							endif

								/*
								   Circuit switched call processing of a
								   data link reinit.
								*/

#							if EQUIPMENT == TE
								Csc_dl_reinit ();
#							else

								if (Na_fct == FG_NT_TE) {
									Csc_dl_reinit_n ();

								} else {

									Csc_dl_reinit ();
								}

#							endif

							break;

							/*
							   Link Connection awaiting
							   release, or awaiting establish.
							*/

						case LC_AWAITING_EST :
						case LC_AWAITING_REL :
							break;

					} /* lc_state */

					p_call = P_NIL;
					ret_code = STOP;

					break;


			/*------------------ DL-RELEASE-INDICATE ---------------------*/

				case DL_REL_IN :

						/* Switch according to the Link Connection state */

					switch (Lc_state) {

							/*
							   LC awaiting establish or established :
							   ---> data link failure.
							*/

						case LC_AWAITING_EST :
						case LC_ESTABLISHED :
							Lc_state = LC_RELEASED;		/* LC released */

#							if NS_SEGMENTATION == ON

									/* Reassembly process */

								if (Spdu_param_segmentation == ON) {
									ns_reassembly_process (code);
								}

#							endif

								/*
								   Circuit switched call processing of a
								   Data Link failure.
								*/

#							if EQUIPMENT == TE
								csc_dl_failure ();
#							else

								if (Na_fct == FG_NT_TE) {
									csc_dl_failure_n ();

								} else {

									csc_dl_failure ();
								}

#							endif

							Ns_ei (DL_REL_IN, Dl_ces);

							break;

							/* Awaiting release or already released */

						case LC_AWAITING_REL :
						case LC_RELEASED:
							break;

					} /* lc_state */

						/* Reset the current call pointer and DL pointer */

					p_call = P_NIL;

					Stop_dl_timer (T3DL);

					ret_code = STOP;

					break;


		/*------------- DL-UNACKNOWLEDGED-DATA-INDICATION ----------------*/

		/*-------------------- DL-DATA-INDICATION ------------------------*/

				case DL_U_DA_IN :

						/* Ignore UI frame if not on broadcast connection */

					if (Dl_ces != DL_CES_BROADCAST) {
						ret_code = STOP;
						break;
					}

				case DL_DA_IN   :

					switch (Lc_state) {

						case LC_RELEASED :
						case LC_AWAITING_EST :
						case LC_AWAITING_REL :
							ret_code = STOP;
							break;

						case LC_ESTABLISHED :
							break;

					}

#					if NS_SEGMENTATION == ON

							/* Reassembly process */

						if (Spdu_param_segmentation == ON) {

							if (ns_reassembly_process (code) == STOP) {
								ret_code = STOP;
								break;
							}
						}

#					endif

						/* If system congestion the UI is ignored */

					if ((code == DL_U_DA_IN) && (Congestion_busy == ON)) {
						ret_code = STOP;
						break;
					}

						/* Incoming SPDU */

#					if NS_SEGMENTATION == ON

						if ((Spdu_param_segmentation == ON) && (Dl_p_spdu_end != P_NIL)) {
							p_spdu 		= Dl_a_spdu;
							p_spdu_end 	= Dl_p_spdu_end;

						} else {

#					endif

						if ((p_buffer = R_msg_p_buffer) == P_NIL) {

							if (R_msg_data_size == 0) {
								ret_code = STOP;
								break;
							}

							p_spdu		= R_msg_a_start_data;
							p_spdu_end	= R_msg_a_end_data;

						} else {

							if (Buffer_data_size == 0) {
								ret_code = STOP;
								break;
							}

							p_spdu		= Buffer_a_start_data;
							p_spdu_end	= Buffer_a_end_data;
						}

#					if NS_SEGMENTATION == ON

						}

#					endif

						/* Switch according to the protocol discriminator */

					if (
						((protocol_discr = *p_spdu) == Spdu_param_net_protocol_discriminator)

#						if NS_MAINTENANCE_CAPABILITY == ON
																				||
							((protocol_discr == PROTOCOL_DISCR_MAINT_ATT_CUST) 	||
							 (protocol_discr == PROTOCOL_DISCR_MAINT_NATIONAL))

#						endif

						) {

							/*
								Check the consistency of the received spdu message
								and load the internal data structure.
							*/

							/*	Return */

						if (r_spdu () != OK) {
							ret_code = NOK;
							break;

						} else {
							ret_code = CONTINUE;
							break;

						}

					} else {

#						if NS_EVENT_REPORT == ON

							/* Send the timer event to MNS */

							ns_send_mns_event (NS_EVENT_PROTOCOL_ID, protocol_discr);

#						endif

							/* Ignore the SPDU */

						ret_code = STOP;
						break;

					}


			/*-------------------- DL-RELEASE-CONFIRM --------------------*/

				case DL_REL_CO :

					switch (Lc_state) {

						case LC_AWAITING_REL :
							Lc_state = LC_RELEASED;

								/*
								   Test if it is usefull to reopen and
								   do it if necessary.
								*/

							if ((Dl_first_dl != P_NIL) || (Dl_first_cc != P_NIL)) {

								if (NS_MX_DL_RETRY != 0) {

									if (Dl_rc++ != NS_MX_DL_RETRY) {
										Send_to_dl (DL_EST_RQ, Dl_ces);
										Lc_state = LC_AWAITING_EST;

									} else {

											/* Clear all the pending call */

#										if EQUIPMENT == TE
											csc_clear_all_call ();
#										else

											if (Na_fct == FG_NT_TE) {
												csc_clear_all_call_n ();

											} else {

												csc_clear_all_call ();
											}

#										endif

									}	/* End if ... else */

								} else {

										/* Clear all the pending call */

#									if EQUIPMENT == TE
											csc_clear_all_call ();
#									else
										if (Na_fct == FG_NT_TE) {
											csc_clear_all_call_n ();

										} else {

											csc_clear_all_call ();
										}

#									endif

								}

							}	/* End if */

							break;

						default :
							break;			/* ignored */

					}

						/* Reset the current call pointer and DL pointer */

					p_call	= P_NIL;

					Stop_dl_timer (T3DL);
					ns_stop_all_dlci_timers ();

					ret_code = STOP;
					break;

			/*------------------ DL-COMMITMENT-CONFIRM ----------------*/

				case DL_COMMIT_CO :

					switch (Lc_state) {

						case LC_RELEASED :
						case LC_AWAITING_EST :
						case LC_AWAITING_REL :
							break;

						case LC_ESTABLISHED :

#							if NS_TYPE_BRI == ON

								if ((Dl_call_count == 0) && (Na_type == BRI)) {
									Send_to_dl (DL_REL_RQ, Dl_ces);
									Lc_state = LC_AWAITING_REL;
								}

#							endif

								/* DL timer OFF */

							Stop_dl_timer (T3DL);
							break;

					}

					ret_code = STOP;
					break;

			/*--------------------------------------------------------*/

				default : /* r_msg_code */

					Trap (TRAP_DL_CODE, "ns_rcv");

			} /* r_msg_code */

#			if NS_D_BACKUP == ON

					/* Update D channel status */

				 if ((code != DL_DA_IN) && (code != DL_U_DA_IN)) {

						/*
						 * Do the D channel Backup procedures
						 * for DL primitives which does NOT contain
						 * any data.
						 * The DL_DA_IN and DL_U_DA_IN will be processed
						 * in the circuit_switched_call () routine.
						 */

					Ns_bkp_proc (code, i_entity_origination);
				 }

#			endif

			return (ret_code);

		/*------------------------------------------------------------------*
		*                                                                   *
		*                       FROM NS LAYER MANAGEMENT                    *
		*                                                                   *
		*-------------------------------------------------------------------*/

		case ENT_MNS :

			switch (code) {

					/* Reset NA configuration */

#				if RESET_CONFIG == ON

					case MNS_RESET_CONFIG_RQ :

						p_data             = R_msg_a_start_data;
						R_msg_data_size    = sizeof (struct confirm);

						Confirm_ret_code   = NOK;			/* default */
						Confirm_diagnostic = ENT_NS;		/* in NS entity */

						p_na_prior = P_NIL;

						ns_access_first_na ();

						while (p_nsna != P_NIL) {

							if (Nai == nai) {

#								if NS_MAINTENANCE_CAPABILITY == ON

										/* Update the NFAS table */

									ns_update_nfas (Nai);

#								endif

									/* Scan all the call contexts of the current NA */

								ns_access_first_call ();

								while (Call_current_exist) {

										/* Save the current p_call */

									p_call_sav = p_call;

										/* Release all call resources (saved SPDU, timers, ...) */

									call_clear ();

										/* Restore previous context */

									p_call = p_call_sav;

										/* Set p_call to the next call context if any */

									ns_access_next_call ();

										/* Free the call context */

									Mem_free ((char FAR *)p_call_sav->p_blk, PID_VL);
								}

									/* Scan all the DL connections of the NA */

								ns_free_dl_ctx ();

#								if OPTIMIZATION == SPEED
									Mem_free ((char FAR *)Na_call_ref_p_tab, 	PID_VL);
									Mem_free ((char FAR *)Na_conn_p_tab, 		PID_VL);
#								endif

									/* Update the NA link */

								if (p_na_prior == P_NIL) {
									p_ns_tree = Next (Node_from_p (p_nsna));

								} else {

									Next (Node_from_p (p_na_prior)) = Next (Node_from_p (p_nsna));
								}

									/* Decrement the nb of time the specification is used */

								ns_dec_net_idx (Na_network);

#								if OPTIMIZATION == SPEED

										/* Reset direct access table */

									p_nsna_tab[nai] = P_NIL;

#								endif

									/* Reset access table used for multiplexing */

								Nsna_ces_key (Na_dl_nai, Na_dl_ces) = P_NIL;


									/* Free the NA memory */

								Mem_free ((char FAR *)Na_p_blk,	PID_VL);

									/* Confirm configuration reset */

								Confirm_ret_code = OK;
								break;	/* exit NA loop */

							}

								/* next NA */

							p_na_prior = p_nsna;
							ns_access_next_na ();

						} /* while (p_nsna != P_NIL) */

							/* Send the confirmation */

						ns_retransmit (MNS_RESET_CONFIG_CO, ENT_MNS);

							/* End process */

						return (STOP);

#				endif

				case MNS_REF_RQ :
					break;

				case MNS_DL_DLCI_RQ :
					Ns_ei (MNS_DL_DLCI_RQ, Na_dl_ces);
					break;

					/* Power ON or OFF */

				case MNS_NA_POWER_ON_RQ :
				case MNS_NA_POWER_OFF_RQ :
					Ns_ei (code, Na_dl_ces);

						/* Load Network access status */

					if (code == MNS_NA_POWER_ON_RQ) {
						Na_status = ON;

					} else {

						Na_status = OFF;
					}

					break;

#				if NS_RESTART_PROCEDURE == ON /* { */

							/* Stop an access requested */

					case MNS_RESTART_RQ :

							/* set p_ssdu and p_data pointers to start of data */

						if ((p_buffer = R_msg_p_buffer) == P_NIL) {

							p_data = p_ssdu = R_msg_a_start_data;

						} else {

							p_data = p_ssdu = Buffer_a_start_data;
						}

						if ((Spdu_param_restart_procedure == ON) &&
							(Na_connection == POINT_TO_POINT)) {

								/* Set DL context pointer p_nsdl */

							Ns_access_dl_ces (Na_dl_ces);

								/* Set the event ID with primitive code */

							event_id = MNS_RESTART_RQ;

								/* init direction and set implicit value for Restart Indicator */

							direction = TO_CALL_CONTROL;
							ie_implicit_val_x (CODESET_0, RESTART_IND, 0);

								/* init ie instance index for further use */

							i_ie_x = 0;

								/* if data size is not null -> check data
									and store them into internal structure */

							if (((R_msg_p_buffer == P_NIL) && (R_msg_data_size != 0)) ||
								((R_msg_p_buffer != P_NIL) && (Buffer_data_size != 0))) {

								/* data size is not null -> check restart class */

								switch (Mns_restart_class) {

									case RI_SINGLE_INTERFACE :
									case RI_ALL_INTERFACES :
									case RI_INDICATED_CHANNEL :

											/* restart class is valid -> store it */

										I_restart_ind_class = Mns_restart_class;
										break;

									default :

											/* Return MNS_RESTART_CO with error ("bad restart class") and do nothing else */

										ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_CLASS);
										return (STOP);
								}
							}

								/* store Restart Indicator */

							set_ie_i (CODESET_0, RESTART_IND);

							Dl_rest_class = I_restart_ind_class;

							/* if restart class indicates 'B-Channel' ->
								check B-Channel Nb provided and if valid
								store Chanel-ID IE with implicit values */

							if (I_restart_ind_class == RI_INDICATED_CHANNEL) {

								/* Channel Nb :
									1 or 2 for Basic Rate interface,
									1 to 15 and 17 to 31 for Primary rate interface
								*/

								if (Mns_restart_b_chan_nb == 0) {

										/* Return MNS_RESTART_CO with error ("bad Channel Nb") and do nothing else */

									ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_CHAN_NB);
									return (STOP);
								}

								if (Na_type == BRI) {

									if (Mns_restart_b_chan_nb > 2) {

											/* Return MNS_RESTART_CO with error ("bad Channel Nb") and do nothing else */

										ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_CHAN_NB);
										return (STOP);
									}

								} else {

									if ((Mns_restart_b_chan_nb == Spdu_param_d_channel) ||
										(Mns_restart_b_chan_nb > Spdu_param_mx_b_channel)) {

											/* Return MNS_RESTART_CO with error ("bad Channel Nb") and do nothing else */

										ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_CHAN_NB);
										return (STOP);
									}
								}

								ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
								set_ie_i (CODESET_0, CHAN_ID);

									/* store B-channel Nb into DL context */

								Dl_rest_chan_nb = Mns_restart_b_chan_nb;
							}

#							if NS_MAINTENANCE_CAPABILITY == ON

								if (I_restart_ind_class == RI_SINGLE_INTERFACE) {

									ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
									I_(chan_id,int_id) 		= INT_ID_EXPLICIT;
									I_(chan_id,int_id_val)	= Mns_restart_interface;
								}

#							endif

								/* Call reference NIL is initialized by default */

							return (CONTINUE);

						} else {

								/* Return MNS_RESTART_CO with error ("restart procedures not implemented") and do nothing else */

							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_NOT_IMPLEMENTED);
							return (STOP);
						}

#				endif /* NS_RESTART_PROCEDURE = ON} */

#				if NS_MAINTENANCE_CAPABILITY == ON /* { */

					case MNS_SERVICE_RQ :

						p_ssdu = p_data	= R_a_data;

						if (Net_param_nfas_support == ON) {

								/* Set DL context pointer p_nsdl */

							Ns_access_dl_ces (Na_dl_ces);

								/*
								 * Set Global Call Ref with length = 1
								 * even if PRI is used.
								 */

							I_call_ref		= 0;
							I_call_ref_lgth	= 1;
							event_id 		= MNS_SERVICE_RQ;
							direction 		= FROM_CALL_CONTROL;

							return (CONTINUE);

						} else {
								/* D/B Channel management is not supported */

							ns_send_mns_service (I_MANAGEMENT_NOT_SUPPORTED, Mns_service_int_id, BYTE_VAL_NIL);
						}

						return (STOP);

#				endif /* } */

				default :
					Trap (TRAP_MNS_CODE, "ns_rcv");
			}

			return (STOP);

		/*------------------------------------------------------------------*
		*																	*
		*						FROM TIMER PROCESS							*
		*																	*
		*-------------------------------------------------------------------*/

		case ENT_TI :

#			if NS_MAINTENANCE_CAPABILITY == ON

					/* Save the Nai */

				ns_cc_int_id = Nai;

#			endif

			ti_dl_flag = FALSE;

				/* Relate to a CALL object or to a DL object ? */

			switch (code) {

				case TI_DL :

						/* Set DL context pointer p_nsdl */

					if (Ns_access_dl_ces (R_msg_ces) == NOK) {
						Trap (TRAP_TIMER_CES_UNKNOWN, "ns_rcv");
					}
						/* DL timer */

					ns_dl_timer_expiry ();

						/* Return and STOP */

					return (STOP);

#				if NS_T309 == ON

					case TI_DL_EST :

							/* Set DL context pointer p_nsdl */

						if (Ns_access_dl_ces (R_msg_ces) == NOK) {
							Trap (TRAP_TIMER_CES_UNKNOWN, "ns_rcv");
						}


							/*
								Is the time-out valid ? (timer state = ON and
								sequence number correct). If invalid, set event to NIL
								(nothing to do).
							*/

						if (Valid_dl_time_out (T3_DL_EST)) {

								/* Set timer state to OFF */

							State_dl_timer (T3_DL_EST) = OFF;
						}

						if ((Lc_state == LC_RELEASED) && (Dl_call_count > 0)) {

							Start_dl_timer	(T3_DL_EST);
							Send_to_dl		(DL_EST_RQ, Dl_ces);

							Lc_state = LC_AWAITING_EST;
						}

							/* Return and STOP */

						return (STOP);

#				endif	/* NS_T309 */

				case TI_SPID :
					i = TSPID;
					ti_dl_flag = TRUE;	/* set DL timer */
					break;

#				if NS_SEGMENTATION == ON

						/* segmentation reassembly timer */

					case TI_314 :

							/* Set DL context pointer p_nsdl */

						if (Ns_access_dl_ces (R_msg_ces) == NOK) {
							Trap (TRAP_TIMER_CES_UNKNOWN, "ns_rcv");
						}

						if (Valid_dl_time_out (T314)) {

								/* Segmentation reassembly timer */

							ns_reassembly_process (code);

						}
								/* Return and STOP */

						return (STOP);

#				endif

#				if NS_RESTART_PROCEDURE == ON

					case TI_316 :
						i = T316;
						ti_dl_flag = TRUE;	/* set DL timer */
						break;

					case TI_317 :
						i = T317;
						ti_dl_flag = TRUE;	/* set DL timer */
						break;

#				endif


#				if NS_MAINTENANCE_CAPABILITY == ON

					case TI_3DW :
						i = T3DW;
						ti_dl_flag = TRUE;
						break;

					case TI_3MB :
						i = T3MB;
						ti_dl_flag = TRUE;
						break;
#				endif

#				if NS_D_BACKUP == ON

					case TI_321 :
						i = T321;
						ti_dl_flag = TRUE;
						break;

					case TI_SRV :
						i = TSRV;
						ti_dl_flag = TRUE;
						break;
#				endif

#				if EQUIPMENT == NT2

					case TI_304I :
					case TI_308I :
					case TI_310I :

						if (Ns_access_dl_ces (Int_ces (R_msg_ces)) == NOK) {
							Trap (TRAP_NO_CES, "ns_rcv");
						}

						if (ns_access_call_ref (I_call_ref = Int_call_ref (R_msg_add)) == NOK) {
							Trap (TRAP_TIMER_CONN_ID_UNKNOWN, "ns_rcv");
						}

						Set_call_ref_not_nil ();

							/*
							   Is the time-out always valid ? (timer state
							   is ON and sequence number correct). If invalid,
							   set event to NIL (nothing to do).
							*/

						event_id = (Valid_int_time_out (R_msg_add)) ? code : EV_NIL;

							/* set timer state to OFF and release it */

						Release_int_timer (R_msg_add);
						break;

#				endif

				default :
							/* Call timer */

						/* Is the connect ID valid ? */

					if (ns_access_conn_id (ANY_CALL, R_msg_conn_id) == NOK) {
						Trap (TRAP_TIMER_CONN_ID_UNKNOWN, "ns_rcv");
					}

						/*
							Is the CALL CONNECTION valid ?
							no ---> ignore the time-out.
						*/

					if (Call_state == STATE_NIL) {
						return (STOP);
					}

						/* Set the linked Data Link Connection Endpoint */

					if (Call_ces != DL_CES_NIL) {

						if (Ns_access_dl_ces (Call_ces) == NOK) {
							Trap (TRAP_NO_CES, "ns_rcv");
						}

					} else {

						if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
							Trap (TRAP_NO_CES, "ns_rcv");
						}
					}

						/* Init I_call_ref */

					I_call_ref		= Call_ref;
					Set_call_ref_not_nil ();

						/* Access to the event ID code */

					for (i = 0; ; ) {

						if (code == Ti_ev_id (i)) {

								/*
								   Is the time-out valid ? (timer state = ON and
								   sequence number correct). If invalid, set event to NIL
								   (nothing to do).
								*/

							if (Valid_call_time_out (i)) {
								event_id = code;

									/* set timer state to OFF */

								State_timer_ns (i) = OFF;

							} else {

								event_id = EV_NIL;
							}

							break;
						}

						if (++i == MX_CALL_TIMER) {
							Trap (TRAP_TI_CODE, "ns_rcv");
						}

					}

					break;

			}

			if (ti_dl_flag == TRUE) {

					/* Set DL context pointer p_nsdl */

				if (Ns_access_dl_ces (R_msg_ces) == NOK) {
					Trap (TRAP_TIMER_CES_UNKNOWN, "ns_rcv");
				}

				Set_call_ref_not_nil ();

					/*
					   Is the time-out valid ? (timer state
					   is ON and sequence number correct). If invalid,
					   set event to NIL (nothing to do).
					*/

				if (Valid_dl_time_out (i)) {
					event_id = code;

						/* set timer state to OFF */

					State_dl_timer (i) = OFF;

				} else {

					event_id = EV_NIL;
				}

			}

#			if NS_EVENT_REPORT == ON

					/* Send the timer event to MNS */

				ns_send_mns_event (NS_EVENT_TIMER, event_id);

#			endif

			break;

	}

	return (CONTINUE);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_establish_dl - implements the test of the Link Connection
				state and if necessary requests the establishment of it.

Usage           uchar ns_establish_dl (void);

Return value    return code = CONTINUE	continue the processing,
							= STOP		wait for DL establishment,
							= NOK       the call state is errored.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar ns_establish_dl ()
{
	ces_t		ces;


#	if EQUIPMENT == TE
		ces = Na_dl_ces;
#	else

			/*
			   If NT2 terminal side, BRI access (S0) continue
			   (sending of a broadcast message).
			*/

		if ((Na_fct == FG_NT_TE) && (Na_connection_pmp)) {
			return (CONTINUE);

		} else {

			ces = Na_dl_ces;
		}

#	endif

#	if NS_MAINTENANCE_CAPABILITY == ON /* { */

	  /* Search for a DL context */

	if (ns_nfas == ON) {

		p_nsdl = Nfas_dl_p_active_d_chan;

	} else {

		if (Ns_access_dl_ces (ces) == NOK) {
			Trap (TRAP_NO_CES, "ns_establish_dl");
		}
	}

#	else /* } { */

		  /* Search for a DL context */

		if (Ns_access_dl_ces (ces) == NOK) {
			Trap (TRAP_NO_CES, "ns_establish_dl");
		}

#	endif /* } */

	Call_ces = ces;

		/* Switch according to the Link Connection (LC) state */

	switch (Lc_state) {

		case LC_AWAITING_EST :
		case LC_AWAITING_REL :
		case LC_RELEASED :

			if (Call_state == STATE_NULL_0) {

					/*
					   Postpone the processing of the SPDU until the Link
					   Connection established;
					*/
				ns_in_queue_cc (); p_buffer = P_NIL;

			} else {

				return (NOK);
			}


			if (Lc_state == LC_RELEASED) {
				ns_snd_dl (DL_EST_RQ, ces);
				Lc_state = LC_AWAITING_EST;
			}

				/*  wait for establishment */

			Call_state = STATE_WAIT_DL;
			return (STOP);

			/*
				The Link Connection is already established,
				continue the process of the SSDU.
			*/

		case LC_ESTABLISHED :
			Call_state = STATE_NULL_0;
			break;

	}

	return (CONTINUE);
}

#if NS_SEGMENTATION == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_reassembly_process - implements the message segmentation
				reassembly function.

Usage           uchar ns_reassembly_process (event_id);
					- event_id : event to process (DL or TI event);

Return value    return code = CONTINUE	continue the processing,
							= STOP		wait for DL establishment,
							= NOK       the call state is errored.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar ns_reassembly_process (event_id)
	code_t		 event_id;		/* Event to process */
{
	ushort       data_size;		/* SPDU message data size */
	uchar		 header_size;	/* SPDU message header size */
	uchar	FAR	*p_data;		/* SPDU message data pointer */
	uchar 	FAR *p_spdu_id;		/* SPDU message type pointer */

		/* Init p_data, p_ie data pointer and data size */

	p_data		= R_a_data;
	p_ie 		= p_data + 1;
	data_size 	= R_data_size;

		/* Message segment reassembly */

	switch (Dl_reassembly_state) {

			/*--------------------- NULL STATE -----------------------*/

		case REASSEMBLY_NULL_STATE :

				/* Only DL DATA INDICATION */

			if ((event_id == DL_U_DA_IN) || (event_id == DL_DA_IN)) {

				A:
					/* Check the SPDU minimum length */

				if (data_size >= (int)(Spdu_param_spdu_lgth_min)) {

						/*
						   Call reference length according to network access
						   rate interface.
						   Init i_call_ref (internal call reference value).
						*/

					I_call_ref_lgth = R_call_ref_lgth;

					if (data_size >= (int)(PROTOCOL_DISCR_SIZE 	+
										   CALL_REF_LGTH_SIZE 	+
										   I_call_ref_lgth 		+
										   MSG_TYPE_SIZE_MIN 	+
										   IE_SEGMENTED_LGTH)) {

						if  ( ! (Is_call_ref_nil) ) {

								/* Load internal call reference */

							i_call_ref_load (I_call_ref_lgth);
						}

						p_spdu_id	= p_ie;

						if (*p_ie++ == SEGMENT) {

							if ((*p_ie++ == SEGMENTED)                   			&&
								(*p_ie++ == IE_SEGMENTED_LGTH)              		&&
								(First_segment_indicator == FIRST_SEGMENT) 			&&
								((Dl_segment_remaining = Segment_remaining) != 0)   &&
								(Dl_segment_remaining <= MX_SEGMENT)
							   ) {

								++p_ie;

								if (Ext_0_1 == 0) {

										/* Save the call reference */

									Dl_call_ref = I_call_ref;

										/* Restore the message type */

									*p_spdu_id = Dl_spdu_id = Segmented_message_type;

										/*
											Copy the received message without
											the SEGMENTED IE to the internal
											spdu buffer.
										*/

											/* Header */

									header_size = (uchar)(p_spdu - p_data + 1);
									Memcpy_far ((char FAR *)Dl_a_spdu, (char FAR *)p_data, (int)header_size);
									Dl_p_spdu_end = Dl_a_spdu + header_size;

											/* IE's */

									data_size -= (ushort)(++p_ie - p_data);
									Memcpy_far ((char FAR *)Dl_p_spdu_end, (char FAR *)p_ie, (int)data_size);
									Dl_p_spdu_end += data_size;

										/* Start timer T314 */

									Start_dl_timer (T314);

										/* State : Receiving segmented message */

									Dl_reassembly_state = REASSEMBLY_RECEIVING_STATE;

									return (STOP);

								}

							}

							ns_reassembly_discard ();
							return (STOP);
						}

					}

				}

			}

			break;

				/*----------------- RECEIVING STATE ------------------*/

		case REASSEMBLY_RECEIVING_STATE :

			switch (event_id) {

					/* DL DATA INDICATION */

				case DL_U_DA_IN :
				case DL_DA_IN   :

						/* Check the SPDU minimum length */

					if (data_size >= (int)(Spdu_param_spdu_lgth_min)) {

							/*
							   Call reference length according to network access
							   rate interface.
							   Init i_call_ref (internal call reference value).
							*/

						I_call_ref_lgth = R_call_ref_lgth;

						if (data_size >= (int)(PROTOCOL_DISCR_SIZE 	+
											   CALL_REF_LGTH_SIZE 	+
											   I_call_ref_lgth 		+
											   MSG_TYPE_SIZE_MIN	+
											   IE_SEGMENTED_LGTH)) {

							if  ( ! (Is_call_ref_nil) ) {

									/* Load internal call reference */

								i_call_ref_load (I_call_ref_lgth);
							}

							if (I_call_ref == Dl_call_ref) {

									/* Segmented IE ? */

								if (*p_ie++ == SEGMENTED) {

										/* Check the IE segmented integrity */

									if (*p_ie++ == IE_SEGMENTED_LGTH) {

										if ((First_segment_indicator != FIRST_SEGMENT) 	&&
											(Segment_remaining 		 == --Dl_segment_remaining)
										   ) {

											++p_ie;

											if ((Ext_0_1 == 0) &&
												(Segmented_message_type == Dl_spdu_id)
											   ) {

												if (Dl_segment_remaining != 0) {
													Start_dl_timer (T314);
													Dl_reassembly_state = REASSEMBLY_RECEIVING_STATE;
													return (STOP);

												} else {

													Stop_dl_timer (T314);
													Dl_reassembly_state = REASSEMBLY_NULL_STATE;

														/*
															Copy the message
															to the internal
															spdu buffer.
														*/

													data_size = (ushort)(p_ie - p_data);

													Memcpy_far ((char FAR *)Dl_a_spdu, (char FAR *)p_ie, (int)data_size);

													Dl_p_spdu_end += data_size;

													return (CONTINUE);

												}

											}

										}

									}

								}

							}

							Stop_dl_timer (T314);
							ns_reassembly_discard ();
							Dl_reassembly_state = REASSEMBLY_NULL_STATE;
							return (STOP);
						}

					}

					Stop_dl_timer (T314);
					ns_reassembly_discard ();
					p_ie = p_data + 1;
					goto A;

					/* TIMER T314 expired */

				case TI_314 :
					ns_reassembly_discard ();
					Dl_reassembly_state = REASSEMBLY_NULL_STATE;
					return (STOP);

					/* All other DL primitives */

				default :
					Stop_dl_timer (T314);
					ns_reassembly_discard ();
					goto A;
			}

	}

	return (CONTINUE);
}

/*--------------------------------------------------------------------------*/

void ns_reassembly_discard ()
{

		/* Discard accumulated segments */

	Dl_p_spdu_end = P_NIL;

		/* Notify NS management */

	error_set (ERR_N_REASSEMBLY, 0, 0);
}

#endif

/*EOF*/

