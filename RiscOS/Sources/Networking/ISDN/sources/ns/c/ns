
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		ns_audit_in - implements the management of the NS audit array.
 *
 *      ns  - implements the main function of the Network Signalling entity
 *
 *		ns_config - implements the configuration of the NS entity from the
 *				   MNS_SET_CONFIG_RQ message containing the configuration
 *                 structure.
 *
 *		ns_var_init - init of NS entity's global variables.
 *
 *		ns_build_par_table - init of NS network parameter table.
 *
 *		ns_build_p_table - init of NS network table.
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "ns.h"
#include "isdn.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#if REVISION_STRING == ON
#	include "rev.ns"
#endif

		/* Copyright */

CONST char 	ns_copyright[]	= "Copyright (c) 1989/96 by OMNITEL SA - All Rights Reserved";
CONST char 	ns_licence[]	= LICENSE_NBER;

		/* NS init flag */

uchar				ns_init_flag;


		/* Network Signalling object context */

struct accss_nsna_ces 	FAR 	*p_nsna_ces_tab;		/* NS na access table */

#if OPTIMIZATION == SPEED
	struct	nsna	FAR *FAR *p_nsna_tab;		/* access table */
#endif

struct 	node 		FAR *p_ns_tree;				/* tree address */
struct 	nsna 		FAR *p_nsna;				/* current pointer on Network Access object */
struct	nsdl		FAR *p_nsdl;				/* current pointer on data link object */
struct 	call 		FAR *p_call;				/* current pointer on Call object */
struct 	ctx_backup	FAR *p_ctx_backup;			/* backup context in case of congestion */


		/* Common variables : NS context */

Entity_common (ns);							/* common NS entity variables */

uchar					ie_if_flag;			/* booleen flag between C and metalanguage */

				/* SPDU common */

uchar				FAR	*p_spdu;			/* pointer on the begining of the SPDU data */
uchar				FAR	*p_spdu_end;		/* pointer on the end of the SPDU data */
uchar					spdu_id;       		/* current SPDU ID (message type) */

				/* SSDU common */

uchar				FAR	*p_ssdu;			/* pointer on the begining of the SSDU data */
uchar 				FAR	*p_ssdu_val;		/* current ssdu value position (store action) */
uchar				FAR	*p_ssdu_end;		/* pointer on the end of the SSDU data */
uchar 					ssdu_id;			/* current SSDU ID (primitive code) */

				/* IE common */

uchar 				FAR	*p_ie;				/* current pointer inside the current Information Element */
uchar 				FAR	*p_ie_end;			/* pointer on the end of the current Information Element */
uchar					ie_codeset;			/* current IE codeset */
uchar					ie_id;				/* current IE ID */
ushort					i_ie_offset;		/* size of the internal data structure of the current IE */
uchar					ns_ie_tsp_checking;	/* check transparent IE */

uchar					drc;				/* dummy ret code to avoid a compilation warning. Used when the function return is not used. */
uchar					ns_net_idx;			/* Number of implemented networks */
uchar					select_op;			/* Current selected operator */
ces_t					saved_ces;			/* saved ces (for broadcast message diffusion) */
uchar					nb_status_sent;		/* nb STATUS to the line for the current received message */

#if NS_MAINTENANCE_CAPABILITY == ON
	uchar				ns_nfas;			/* NFAS */
	uchar				ns_nfas_group_nb;
	nai_t				ns_cc_int_id;		/* CC interface Id */
#endif

struct message		FAR *p_msg_broadcast;	/* pointer on message to broadcast on the different INTERFACE nai's (AT9 SPID purpose) */

#if NS_IE_TSP_IN == ON

	struct buffer	FAR *p_buffer_q931;		/* buffer where is stored q931 trace */

#endif

struct ns_status_var	ns_status_var;		/* variables used to send a STATUS message */

		/* Constants */

#define USER_T304P			(60 * SECOND)	/* TR6 T304	point to point */
#define USER_T304MP			(20 * SECOND)	/* TR6 T304	point to multipoint */
#define USER_T305P			(30 * SECOND)	/* TR6 T305	point to point */
#define USER_T305MP			 (4 * SECOND)	/* TR6 T305	point to multipoint */

#define	DEMO_APPLI			OFF				/* to know how to define ns_state */

#if F_AT4 == ON
#	include "at4.net_indx"
#	include "at4.net_tim"
#endif

#if F_AT5 == ON
#	include "at5.net_indx"
#	include "at5.net_tim"
#endif

#if F_AT9 == ON
#	include "at9.net_indx"
#	include "at9.net_tim"
#endif

#if F_BIP == ON
#	include "bip.net_indx"
#	include "bip.net_tim"
#endif

#if F_AU1 == ON
#	include "au1.net_indx"
#	include "au1.net_tim"
#endif

#if F_BV1 == ON
#	include "bv1.net_indx"
#	include "bv1.net_tim"
#endif

#if F_BT2 == ON
#	include "bt2.net_indx"
#	include "bt2.net_tim"
#endif

#if F_TR6 == ON
#	include "tr6.net_indx"
#	include "tr6.net_tim"
#endif

#if F_ETS == ON
#	include "ets.net_indx"
#	include "ets.net_tim"
#endif

#if F_A17 == ON
#	include "a17.net_indx"
#	include "a17.net_tim"
#endif

#if F_A11 == ON
#	include "a11.net_indx"
#	include "a11.net_tim"
#endif

#if F_E10 == ON
#	include "e10.net_indx"
#	include "e10.net_tim"
#endif

#if F_VN2 == ON
#	include "vn2.net_indx"
#	include "vn2.net_tim"
#endif

#if F_VN3 == ON
#	include "vn3.net_indx"
#	include "vn3.net_tim"
#endif

#if F_VN6 == ON
#	include "vn6.net_indx"
#	include "vn6.net_tim"
#endif

#if F_KDD == ON
#	include "kdd.net_indx"
#	include "kdd.net_tim"
#endif

#if F_NI1 == ON
#	include "ni1.net_indx"
#	include "ni1.net_tim"
#endif

#if F_NI2 == ON
#	include "ni2.net_indx"
#	include "ni2.net_tim"
#endif

#if F_DMS == ON
#	include "dms.net_indx"
#	include "dms.net_tim"
#endif

#if F_NTT == ON
#	include "ntt.net_indx"
#	include "ntt.net_tim"
#endif

#if F_SWD == ON
#	include "swd.net_indx"
#	include "swd.net_tim"
#endif

#if F_QSI == ON
#	include "qsi.net_indx"
#	include "qsi.net_tim"
#endif

#if F_HKT == ON
#	include "hkt.net_indx"
#	include "hkt.net_tim"
#endif

#include "ns_fct.h"

/*------------------------------------------------------------------------*/

#if DEMO_APPLI == ON
	extern uchar	ns_state;			/* state of the current call, defined in the appli. */
#else
	uchar			ns_state;			/* state of the current call */
#endif

#if NS_AUDIT == ON

struct ns_audit {
		long		system_time;		/* system time for time stamping */
		nai_t		nai;				/* network access ID */
		call_ref_t	ref;				/* call reference */
		uchar		last_event;			/* last received event */
		uchar		state;				/* NS state */
		uchar		sub_state;			/* NS sub-state */
		uchar		lc_state;			/* Link Connection state */
		conn_id_t	conn_id;			/* call connection ID */
		uchar		rel_flag;			/* release sequence flag */
		uchar		n308;				/* n308 retry counter */
} ns_audit_tab[NS_MX_AUDIT];

short	x_ns_audit;						/* current index */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ns_audit_in - implements the management of the NS audit
								 array used to store the NS context after
								 receiving an event.

Usage            	void ns_audit_in (void);

Return value : void

Common constants and declarations : ns.h

Common objects : current context pointers (p_nsna and p_call)

*--------------------------------------------------------------------------*/

void ns_audit_in ()
{

	if (Call_current_exist) {

			/* Get and store system time */

		ns_audit_tab[x_ns_audit].system_time 	= System_time ();

			/* Copy last received event ID */

		ns_audit_tab[x_ns_audit].last_event = event_id;

			/* Copy from the current call context */

		ns_audit_tab[x_ns_audit].nai 		= Nai;				/* network access ID */
		ns_audit_tab[x_ns_audit].conn_id 	= Call_conn_id;		/* connection ID */
		ns_audit_tab[x_ns_audit].ref		= Call_ref;			/* call reference */
		ns_audit_tab[x_ns_audit].state		= Call_state;		/* state of the current call */
		ns_audit_tab[x_ns_audit].sub_state	= Call_sub_state;	/* sub-state of the current call */
		ns_audit_tab[x_ns_audit].rel_flag	= Call_rel_flag;	/* release sequence flag */
		ns_audit_tab[x_ns_audit].n308		= N308;				/* retry counter n308 */

			/* Data link info */

		if (Dl_current_exist) {
			ns_audit_tab[x_ns_audit].lc_state = Lc_state;		/* state of the Data Link connection */
		}

			/* Next entry */

		x_ns_audit = ((++x_ns_audit >= NS_MX_AUDIT) ? 0 : x_ns_audit);

	}
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ns - implements the main fuction of the NS entity.

Usage            	uchar ns (p_msg);
						- struct message FAR *p_msg;

Related
functions usage		uchar ns_rcv ();
					void circuit_switched_call ();
					uchar error_condition (uchar code);

Description     	ns implements the receiving of an external event for
					the NS entity and the dispatching of this event for
					processing.

Return value : OK or NOK

Common constants and declarations : ns.h

Common objects : current message pointers to nsna and call context.

*--------------------------------------------------------------------------*/

/*

									-----------------------------------
				   p_rcv_msg ----->	| from DL_D entity : DL_XXX_IN/CO |
				--------------		|	   CC   entity : NS_XXX_RQ/RS |
	p_na ----->	|  NA/CALL	 |      |	   TI   entity : TI_XXX       |
	p_call----> |  OBJECTS   |      -----------------------------------
				--------------	     	           |
					 Œ                             |
					 |                             |
					 |                             |
---------------------v-----------------------------v-----------------------
|							                 STOP                         |
|									       -----------------------------> |
|	                -------------------    |        -----------------     |
|		            |    ns_rcv       |-----        |               |     |
|	               	|                 |    CONTINUE | circuit_      |     |
|>- reset var ----> |process received |------------>|     switched_ |---> |
|		            |   messages      |-----        |        call   |     |
|		            -------------------    |        -----------------     |
|							 			   | ERROR         Œ              |
|							 			   | CODE          |              |
|							 	   --------v--------       |              |
|							 	   | error_handler |--------              |
|		N  S                       |               |   CONTINUE           |
|							 	   -----------------                      |
|							 	           |  STOP                        |
|							               -----------------------------> |
---------------------------------------------------------------------------
													  |
									------------------v----------------
				   p_snd_msg ------>|  to  DL_D entity : DL_XXX_IN/RS |
									|	   CC   entity : NS_XXX_IN/RS |
									----------------------------------

*/

uchar ns (p_msg)
	struct message 		FAR *p_msg;				/* pointer on received message */
{
	struct ns_config	FAR	*p_ns_config;		/* configuration pointer */
	struct ctx_backup	FAR *p_ctx;

	p_rcv_msg = p_msg;
	p_buffer  = R_msg_p_buffer;
	p_snd_msg = P_NIL;

		/* NS SET CONFIG message */

	if ((R_msg_code == MNS_SET_CONFIG_RQ) && (R_msg_from == ENT_MNS)) {
		p_ns_config	= (struct ns_config FAR *)R_a_data;

		if ((Ns_config_cause = ns_config (p_ns_config)) == NS_CFG_OK)  {
			Ns_config_ret_code = OK;
			ns_init_flag       = ON;				/* set init done */

		} else {

			Ns_config_ret_code = NOK;
		}

			/* Send back a the received message to the MNS : init done */

		Ns_config_diagnostic	= ENT_NS;		/* in NS entity */

			/* Send back the confirm message to MNS */

		ns_retransmit (MNS_SET_CONFIG_CO, ENT_MNS);

			/* Free the remaining messages if necessary */

		Free_msg (p_snd_msg);
		return (OK);

	} else {

		if (ns_init_flag == OFF ) {

				/* Init not done ---> requeue the incoming message */

			Send_message (p_rcv_msg); p_rcv_msg = P_NIL;
			return (OK);
		}

	}

		/* Init the saved ces */

	saved_ces = DL_CES_SIG;

	do {

			/* Process the received message */

		ns_process ();

		if (Ctx_backup_exist) {

			if (Dl_backup == ON)  break;

				/*
				 * The backup process is done.
				 * Free the related context.
				 * Get the new one.
				 */

			Lifo_get_object (p_ctx_backup, p_ctx);
			Mem_free ((char FAR *)p_ctx, PID_VL);

			if (Ctx_backup_exist) {

					/*
					 * Another backup context is found.
					 * Process it.
					 */

				R_msg_from	= ENT_MNS;
				R_msg_to	= ENT_NS;
				R_msg_code	= MNS_CLEAR_BUSY_RQ;

				p_buffer  	= P_NIL;
				p_snd_msg 	= P_NIL;

#				if NS_IE_TSP_IN == ON
					p_buffer_q931 = P_NIL;
#				endif

				continue;
			}

		}
			/* Free the remaining messages if necessary */

		Free_msg (p_rcv_msg);
		Free_msg (p_snd_msg);

#		if NS_IE_TSP_IN == ON

			p_buffer_q931 = P_NIL;

#		endif

		if (p_msg_broadcast != P_NIL) {
			p_rcv_msg 		= p_msg_broadcast;
			p_buffer  		= R_msg_p_buffer;
			p_snd_msg 		= P_NIL;

		} else {

			break;
		}


	} while (TRUE);

	return (OK);

}

/*------------------------------------------------------------------------*/

void ns_process ()
{

		/* Reset error stack */

	Error_reset 	();

		/* Reset p_call and p_nsdl context pointers and the call reference */

	p_call			= P_NIL;
	p_nsdl			= P_NIL;

#	if NS_IE_TSP_IN == ON

		p_buffer_q931 = P_NIL;

#	endif

	I_call_ref		= CALL_REF_NIL;		/* default conn_id is CONN_ID MANAGMNT */
	I_call_ref_lgth	= CALL_REF_NIL;		/* default call_ref is CALL_REF_NIL */

		/* Reset the common variables */

	spdu_id			= SPDU_NIL;
	ssdu_id			= SSDU_NIL;
	ie_codeset		= CODESET_NIL;
	ie_id			= IE_NIL;
	i_ie_x			= 0;
	nb_status_sent	= 0;

	Ns_spdu_processed		= OFF;
	Ns_status_to_send		= OFF;
	Ns_status_p_first_msg	= P_NIL;
	Ns_status_p_last_msg	= P_NIL;

		/*
		   Reset the list of IE present in
		   the internal structures ie_i.
		*/

	Reset_internal_ie ();

		/*
			Process the incoming event message sent to the Network
			Signalling entity (NS) and check the message integrity.
		*/

	ret_code = ns_rcv ();


#	if NS_D_BACKUP == ON

            /*
             * The current active DL context may have been
             * modified.
             * Update the backup context.
             */

        ns_update_bkp_dl_ctx ();

#	endif

		/* One more test error */

	if (Error_nb () != 0) {
		ret_code = NOK;
	}

		/* Reset current IE instance */

	i_ie_x = 0;

		/* Switch according to the return code */

	switch (ret_code) {

			/*
			   Continue by processing the circuit switched
			   call automata.
			*/

		case CONTINUE 	:
		case OK 		:

            if (!Na_current_exist) break;

#			if EQUIPMENT == TE
				Circuit_switched_call ();
#			else

				if (Na_fct == FG_NT_TE) {
					Circuit_switched_call_n ();

				} else if (Na_fct == FG_NT_NET) {

					Circuit_switched_call ();
				}

#			endif

#			if NS_D_BACKUP == ON

					/*
                     * The current active DL context may have been
                     * modified.
                     * Update the backup context.
                     */

				ns_update_bkp_dl_ctx ();

#			endif

			break;

			/*
			   Complete processing is done,
			   next message.
		   */

		case STOP :
			break;

			/*
			   Erroneous message ---> process the error
			   handler procedure.
			*/

		case NOK :

				/* If fatal error, next message */

			ns_sort_error_stack ();

			if (Error_handler () == STOP) {

#				if NS_TYPE_BRI == ON

						/* No need to broadcast a bad spdu */

					if (Na_type == BRI) {
						Free_msg (p_msg_broadcast);
						p_msg_broadcast = P_NIL;
					}

#				endif

				break;
			}

				/*
				   Non fatal error ---> continue with processing
				   of the message by calling the circuit switched
				   call automata.
				*/

            if (!Na_current_exist) break;

#			if EQUIPMENT == TE
				Circuit_switched_call ();
#			else

				if (Na_fct == FG_NT_TE) {
					Circuit_switched_call_n ();

				} else if (Na_fct == FG_NT_NET) {

					Circuit_switched_call ();
				}

#			endif

#			if NS_D_BACKUP == ON

					/*
					 * The current active DL context may have been
					 * modified.
					 * Update the backup context.
					 */

				ns_update_bkp_dl_ctx ();

#			endif

			break;

	}

	Ns_spdu_processed = ON;		/* SPDU is processed -> set flag to ON */

		/* Is there any STATUS message to send ? */

	if (Ns_status_to_send == ON) {

		send_state (Ns_status_cause_class, Ns_status_cause_val, Ns_status_cause_diag);
	}

		/* Is there any other messages to send ? -> search in NS internal fifo */


	while (Ns_status_p_first_msg != P_NIL) {

		Fifo_get_msg (&(Ns_status_p_first_msg), &(Ns_status_p_last_msg), p_snd_msg);

			/* send message and reset message and buffer pointers */

		Send_message (p_snd_msg);
	}

	p_snd_msg = P_NIL; p_buffer = P_NIL;

#	if ASSERT == ON

		if ((Ns_status_p_first_msg != P_NIL) || (Ns_status_p_last_msg != P_NIL)) {

			Trap (TRAP_NS_FIFO, "ns_process");
		}

#	endif

	ns_state = 0;

	if (Call_current_exist) {
    	ns_state = Call_state;
	}

#	if NS_IE_TSP_IN == ON

			/* Free useless p_buffer_q931. */

		Free_buffer (p_buffer_q931), p_buffer_q931 = P_NIL;

#	endif

#	if NS_SIM_ANALYSER == ON

			/* Print the current na & call context */

		pr_ns_state ();

#	endif

		/* Store NS current state in NS FIFO */

#	if NS_AUDIT == ON

#		if ASSERT == ON

			if (performance == OFF) {
				ns_audit_in ();
			}

#		else

			ns_audit_in ();

#		endif

#	endif


}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ns_config - implements the configuration of the object (NA
				 and CALL) of the NS entity from the NS_SET_CONFIG_RQ message
				 coming from the MNS.

Usage            uchar ns_config (struct ns_config FAR *p_ns_config);
					- p_ns_config : pointer on the configuration data.

Description     ns_config implements :
					- the building of the NS access tables,
					- the building of the NS objects (NA and CALL),
					- the configuration of the NS entity objects.

Return value    return code = OK  configuration done,
							= NOK configuration not done.

common constants and declarations : ns.h

common : p_nsna, p_call and the message/buffer pointers.

*--------------------------------------------------------------------------*/

#if (SIMULATION == ON)

	extern uint ns_t309;

#endif

uchar ns_config (p_ns_config)
	struct ns_config 	FAR	*p_ns_config;			/* pointer on the configuration structure */
{
	ushort 					 i, j;					/* temporary index */
	struct i_ns_na 		FAR	*p_ns_config_na;		/* pointer on na inside the configuration structure */

#	if (NS_MAINTENANCE_CAPABILITY != ON) || ((NS_SPID == ON) && (NS_TYPE_BRI == ON))
		struct nsdl		FAR	*p_nsdl_save;			/* save p_nsdl */
#	endif

				/* - Initialize the NS objects */

	if ((ret_code = ns_build_object (p_ns_config)) != OK) {
		return (ret_code);
	}

	if (ns_init_flag == OFF) {

			/* Reset operator indexes */

		ns_reset_op_idx ();
	}

			/* ----------- NA loop --------------- */

	for (i = 0; i < Ns_config_na_nb; i++) {

			/* - 1 - build the object structures */

		p_ns_config_na	= Ns_config_na_a (i);		/* current na pointer inside the configuration buffer */

		if (ns_access_na (Ns_config_nai) == NOK) {
			return (NS_CFG_ERR_NAI);
		}


			/* Set in Na context, the nai for DL interface */

		Na_dl_nai = Ns_config_dl_nai;

		if (ns_check_network (Ns_config_na_operator, Ns_config_operator, Ns_config_na_country, Ns_config_country) == NOK) {
			Trap (TRAP_NS_INIT, "ns_config - Bad Network selection.");
		}

#		if ONE_NETWORK == ON

			if (i == 0) {

					/* Build only once */

				if (ns_build_net_table (select_op) == NOK) {
					return (NS_CFG_ERR_BUILD_NET_TABLE);
				}

				if (ns_build_p_table () == NOK) {
					return (NS_CFG_ERR_BUILD_P_TABLE);
				}
			}

#		else

			if (ns_build_net_table (select_op) == NOK) {
				return (NS_CFG_ERR_BUILD_NET_TABLE);
			}

			if (ns_build_p_table () == NOK) {
				return (NS_CFG_ERR_BUILD_P_TABLE);
			}

#		endif

#		if SIMULATION == ON

			ns_build_simul_table (Na_network);

#		endif

			/*
			   - 2 - build the NS access tables and/or check if the NS
						 description tables are consistent.
			*/

		ns_build_check_tab ();

			/* Init na occurrence */

		Na_type = Ns_config_type;       		/* rate interface type (BRI or PRI) */

		if (Na_type == BRI) {
			Na_restart_crl	= Spdu_param_call_ref_lgth_bri;

		} else {

			Na_restart_crl	= Spdu_param_call_ref_lgth_pri;
		}

			/* Check functional grouping */

		switch (Na_fct = Ns_config_fct) {

#			if EQUIPMENT == NT2

				case FG_NT_TE  :
				case FG_NT_NET :
						break;

#			else

				case FG_TE_NET :
				case FG_TE_NT  :
					break;

#			endif

			default :
				Trap (TRAP_NS_FG, "ns_config");

		}

			/* Connection type if any (1TR6) */

		Na_connection = POINT_TO_POINT;

        if (Na_type == BRI) {
            Na_connection = Ns_config_connection == 0 ? POINT_TO_MULTIPOINT : Ns_config_connection;
        }

			/* Subscription option (ATT) */

		Na_subscription = Ns_config_subscription;

			/*
			   Init call TI_VAL array : change only the non-zero
			   configuration values.
			*/

		if (MX_CALL_TIMER > NS_MX_CALL_TIMER) {
			Trap (TRAP_NS_INIT, "ns_config - Bad Call Timer indexes.");
		}

		for (j = 0; j < MX_CALL_TIMER; j++) {

			if (Ns_config_call_ti_val (j) != 0) {
				Ti_val (j) = Ns_config_call_ti_val (j);

			} else {

				switch (Na_fct) {

					case FG_TE_NET :
					case FG_TE_NT  :
					case FG_NT_NET :

						if (Net_param_cfg_type_timer_dependance != ON) {
							Ti_val (j) = Ti_df_val_u (j);

						} else {

							switch (Ti_ev_id (j)) {

								case TI_304 :

									if (Na_connection == POINT_TO_POINT) {
										Ti_val (j) = USER_T304P;

									} else {

										Ti_val (j) = USER_T304MP;
									}

									break;

								case TI_305 :

									if (Na_connection == POINT_TO_POINT) {
										Ti_val (j) = USER_T305P;

									} else {

										Ti_val (j) = USER_T305MP;
									}

									break;

								default :

									Ti_val (j) = Ti_df_val_u (j);

							}

						}

						break;

#					if EQUIPMENT == NT2

						case FG_NT_TE :
							Ti_val (j) = Ti_df_val_n (j);
							break;

#					endif

				} /* end switch */

			} /* end else */

		} /* end for */

			/* DL timer value */

		if (MX_DLCI_TIMER > NS_MX_DLCI_TIMER) {
			Trap (TRAP_NS_INIT, "ns_config - Bad Dlci Timer indexes.");
		}

		for (j = 0; j < MX_DLCI_TIMER; j++) {

			if (Ns_config_dl_ti_val (j) != 0) {
				Ti_dl_val (j) = Ns_config_dl_ti_val (j);

			} else {

				switch (Na_fct) {

					case FG_TE_NET :
					case FG_TE_NT  :
					case FG_NT_NET :
						Ti_dl_val (j) = Ti_dl_df_val_u (j);
						break;

#					if EQUIPMENT == NT2

						case FG_NT_TE :
							Ti_dl_val (j) = Ti_dl_df_val_n (j);
							break;

#					endif

				} /* end switch */

			} /* end else */

		} /* end for */

				/* Timer consistancy */

#		if SIMULATION == ON

			Na_T309_option		= (uchar)ns_t309;			/* NS timer T309 option simulation flag */

#		else

			Na_T309_option		= Ns_config_T309_option;	/* NS timer T309 option */

#		endif

#		if NS_T309 == ON

			if (T309 == TI_NOT_IMPLEMENTED) {
				Na_T309_option	= OFF;						/* NS timer T309 option forced to OFF if not allowed. */
			}

#		endif

#		if NS_SEGMENTATION == ON

			if ((T314 == TI_NOT_IMPLEMENTED) && (Spdu_param_segmentation == ON)) {
				Trap (TRAP_NS_INIT, "ns_config - segmentation should be OFF.");
			}

#		endif

			/* Call parameters */

		Incoming_call_nb 	= Ns_config_incoming_call_nb;	/* number of incomong call context */
		Outgoing_call_nb 	= Ns_config_outgoing_call_nb;	/* number of outgoing call context */
		Mixed_call_nb 		= Ns_config_mixed_call_nb;		/* number of mixedd call context */

			/* CALL loop */

		ns_access_first_call ();

		while (Call_current_exist) {

			Call_state 			= STATE_NIL;	/* init call state */
			Call_save_spdu		= P_NIL;		/* empty */

#			if EQUIPMENT == NT2
				if (Na_fct == FG_NT_TE) {		/* !!! This test is necessary : 'ces_setup' field does not exist in FG_NT_NET */

					Call_ces_setup	= DL_CES_SIG;	/* init CES of SETUP to avoid bad use in case of DL connection failure */
				}
#			endif

			ns_access_next_call ();

		} /* End of CALL loop */

			/* DL loop */

		Ns_access_first_dl ();

		while (Dl_current_exist) {

				/* Empty queues DL and CC */

			Dl_first_dl = Dl_last_dl = Dl_first_cc = Dl_last_cc = P_NIL;				/* no waiting message */

				/* Reset call counter */

			Dl_call_count = 0;

				/* Allocate timers and reset states */

			if (Dl_ces != DL_CES_BROADCAST) {

				Dl_button_internal = OFF;

				for (j = 0; j < MX_DLCI_TIMER; j++) {

					if ((Dl_timer_id (j) = Timer_alloc (ENT_NS, Nai, SAPI_NIL, Dl_ces)) == TIMER_ID_NIL) {

							/*
								Saturation :
								- release the previously allocated timer cell,
								- return NOK.
							*/

						ns_release_dlci_timers ();

						return (NS_CFG_ERR_DL_TIMER);
					}

					Dl_timer_state (j)	= OFF;
					Dl_timer_sn	(j)		= 0;

				}

			}

				/* Reset retry count */

			Dl_rc = 0;

			if (Dl_ces == DL_CES_BROADCAST) {
				Lc_state = LC_ESTABLISHED;

			} else {

					/* Endpoint Initialization status */

				Dl_ei_state = EI_STATE_DOWN;

					/*
					   Establish the data link status according to
					   the network access type.
					*/

				if (Na_type == BRI) {					/* BRI : the data link is established at each usage */
					Lc_state 	= LC_RELEASED;
					Memcpy_far	(Dl_a_spid,	Ns_config_a_spid, NS_MX_SZ_SPID+1);
					Dl_chan_sel	= Ns_config_channel_nb;

				} else {

#					if NS_MAINTENANCE_CAPABILITY == ON

							/* By default, no channel management */

						Dl_p_chan_mgt = P_NIL;

#					else

						p_nsdl_save	= p_nsdl;
						Send_to_dl 	(DL_EST_RQ, Na_dl_ces);	/* send to DL_D */
						p_nsdl		= p_nsdl_save;
						Lc_state 	= LC_AWAITING_EST; 		/* set state : awaiting establishment */

#					endif

				}

				Dl_rest_state	= STATE_REST_0;

			}

#			if NS_SEGMENTATION == ON

					/* Segmenter reassembly initialization */

				if (Spdu_param_segmentation == ON) {
					Dl_reassembly_state 	= REASSEMBLY_NULL_STATE;
					Dl_p_spdu_end 			= P_NIL;
				}

#			endif

#			if NS_SPID == ON

				if ((Na_type == BRI) && (Na_connection_pmp) &&
					(*Ns_config_a_spid != SPID_NIL)) {

#					if NS_TYPE_BRI == ON

						if ((Dl_ces != DL_CES_BROADCAST) && (ns_init_flag == ON)) {

								/* Reconfiguration case */

							p_nsdl_save	= p_nsdl;
							ns_snd_dl 	(DL_EST_RQ, Na_dl_ces);
							p_nsdl 		= p_nsdl_save;
							Lc_state 	= LC_AWAITING_EST;
							Dl_ei_state = EI_STATE_AWAIT_EST;
						}

#					endif

				}

#			endif

			Ns_access_next_dl ();

		} /* End of DL loop */

			/* Set NA acces status to POWER ON */

		Na_status = ON;

			/* Set transparent IE flag */

		ns_ie_tsp_checking = Ns_config_ie_tsp_checking;



	} /* End of NA loop */

#	if NS_MAINTENANCE_CAPABILITY == ON

		if ((ret_code = ns_nfas_config (p_ns_config)) != NS_CFG_OK) {
			return (ret_code);
		}

		if ((ret_code = ns_nfas_send_dl_est (p_ns_config)) != NS_CFG_OK) {
			return (ret_code);
		}

#	endif

#	if ASSERT == ON

		/* check the call reference type according to spdu parameters structure */

		if ((sizeof (call_ref_t) < Spdu_param_call_ref_lgth_pri) ||
			(sizeof (call_ref_t) < Spdu_param_call_ref_lgth_bri)
		   ) {
		   Trap (TRAP_CALL_REF_TYPE, "ns_config");
		}

#	endif


#	if NS_SIM_ANALYSER == ON
		pr_ns_object ();
#	endif

		/* Return OK */

	return (NS_CFG_OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_var_init - init of NS entity's global variables.

Usage            	void ns_var_init ();

Return value :		void

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

void ns_var_init ()
{

	ns_init_flag			= OFF;
	p_ns_tree				= P_NIL;
	p_ctx_backup			= P_NIL;
	ns_state				= 0;

	p_msg_broadcast			= P_NIL;
	p_nsna_ces_tab			= P_NIL;

#	if OPTIMIZATION == SPEED
		p_nsna_tab			= P_NIL;
#	endif

#	if NS_AUDIT == ON
		x_ns_audit			= 0;
#	endif

#	if NS_MAINTENANCE_CAPABILITY == ON
		p_ns_d_chan_status		= P_NIL;
		p_ns_d_chan_status_start= P_NIL;
		ns_nfas_group_nb		= 0;
#	endif

#	if OM_CODE_TYPE == OM_PIC

			/* initialize any reference to an address in arrays */

		pic_init_ns_t_operator_var();
		pic_init_ns_net_ie ();
		pic_init_ns_net_spdu ();
		pic_init_ns_net_ssdu ();

				/* initialize any reference to an address in meta-programs */

		pic_init_ns_net_meta_ie ();
		pic_init_ns_net_meta_ssdu ();

#	endif
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_build_par_table - init of NS network parameter table.

Usage            	void ns_build_par_table ();

Return value :		void

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

void ns_build_par_table ()

{

#if F_AT4 == ON
		at4_build_par	();
#endif

#if F_AT5 == ON
		at5_build_par	();
#endif

#if F_AT9 == ON
		at9_build_par	();
#endif

#if F_BIP == ON
		bip_build_par	();
#endif

#if F_AU1 == ON
		au1_build_par	();
#endif

#if F_BT2 == ON
		bt2_build_par	();
#endif

#if F_BV1 == ON
		bv1_build_par	();
#endif

#if F_DMS == ON
		dms_build_par	();
#endif

#if F_ETS == ON
		ets_build_par	();
#endif

#if F_A17 == ON
		a17_build_par	();
#endif

#if F_A11 == ON
		a11_build_par	();
#endif

#if F_E10 == ON
		e10_build_par	();
#endif

#if F_KDD == ON
		kdd_build_par	();
#endif

#if F_NI1 == ON
		ni1_build_par	();
#endif

#if F_NI2 == ON
		ni2_build_par	();
#endif

#if F_NTT == ON
		ntt_build_par	();
#endif

#if F_QSI == ON
		qsi_build_par	();
#endif

#if F_HKT == ON
		hkt_build_par	();
#endif

#if F_SWD == ON
		swd_build_par	();
#endif

#if F_TR6 == ON
		tr6_build_par	();
#endif

#if F_VN2 == ON
		vn2_build_par	();
#endif

#if F_VN3 == ON
		vn3_build_par	();
#endif

#if F_VN6 == ON
		vn6_build_par	();
#endif

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_build_p_table - init of NS network table.

Usage            	uchar ns_build_p_table ();

Return value :		OK/NOK

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

uchar ns_build_p_table ()
{
	uchar		na_network;					/* current NA operator */

		/* set current operator */

	na_network = Na_network;

	p_net_param				= (uchar FAR 					*)	Spf_param			(na_network);
	p_void_fct_table		= (struct void_fct_table 		*)	Spf_void_fct		(na_network);
	p_uchar_fct_table		= (struct uchar_fct_table 		*)	Spf_uchar_fct		(na_network);
	p_uchar_fct_2u_table	= (struct uchar_fct_2u_table	*)	Spf_uchar_fct_2u	(na_network);
	p_uchar_fct_2p_table	= (struct uchar_fct_2p_table	*)	Spf_uchar_fct_2p	(na_network);
	p_uchar_fct_4p_table	= (struct uchar_fct_4p_table	*)	Spf_uchar_fct_4p	(na_network);

	p_tab_error 			= (uchar FAR 					*)	tab_error			[na_network];
	p_tab_spdu 				= (struct spdu 			 		*)	tab_spdu			[na_network];
	p_tab_spdu_param		= (struct spdu_param	 		*)	tab_spdu_param 		[na_network];
	p_tab_net_proc_param	= (struct net_proc_param 		*)	tab_net_proc_param	[na_network];
	p_tab_ssdu 				= (struct ssdu 					*)	tab_ssdu			[na_network];
	p_tab_ie				= (struct ie 					*)	tab_ie				[na_network];
	p_tab_tabl				= (struct tabl 					*)	tab_tabl			[na_network];
	p_tab_tabx				= (struct tabx 					*)	tab_tabx			[na_network];
	p_tab_ti_call			= (struct ns_timer 				*)	tab_ti_call			[na_network];	/* timer event ID table */
	p_tab_ti_dlci			= (struct ns_timer 				*)	tab_ti_dlci			[na_network];	/* timer event ID table */
	p_tab_timer_idx			= (uchar FAR 	   				*)	tab_timer_idx		[na_network];	/* timer index for timers called in the kernel */

#	if EQUIPMENT == NT2
		p_tab_ti_int		= (struct ns_timer 				*)	tab_ti_int			[na_network];	/* internal timer event ID table */
#	endif

#	if OPTIMIZATION == SPEED
		p_x_tab_ssdu		= (uchar FAR					*)	x_tab_ssdu			[na_network];
		p_x_tab_spdu		= (uchar FAR					*)	x_tab_spdu			[na_network];
		p_x_tab_ie			= (struct hcod					*)	x_tab_ie			[na_network];
#	endif

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_nfas_config - init of NFAS table.

Usage            	uchar ns_nfas_config (p_ns_config);

Return value :		NS_CFG_OK, NS_CFG_ERR_xxx

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar ns_nfas_config (p_ns_config)
	struct ns_config FAR *p_ns_config;
{

	uchar i,j,k,state, nfas_group_id;
	struct i_ns_na FAR *p_ns_config_na;
	struct nsdl FAR *p_active_dl;

			/* ----------- NA loop --------------- */

	for (i = 0; i < Ns_config_na_nb; i++) {

		p_ns_config_na	= Ns_config_na_a (i);		/* current na pointer inside the configuration buffer */

		if (ns_access_na (Ns_config_nai) == NOK) {
			return (NS_CFG_ERR_NAI);
		}

			/* NFAS applies for PRI only */

		if (Na_type != PRI) {

				/* Reset the ns_nfas flag */

			Na_nfas = OFF;
			continue;
		}

		if (ns_access_dl_ces (DL_CES_SIG) == NOK) {
			return (NOK);
		}

#		if ONE_NETWORK == OFF

				/* Update NS Na data context pointers */

			ns_build_p_table ();

#		endif

			/* Check is NFAS is supported */

		if (Net_param_nfas_support == OFF) {

				/* Reset the ns_nfas flag */

			Na_nfas = OFF;
			continue;

		}
			/* Set the maintenance type. */

		Na_maint_type = Ns_config_nfas_mode;

			/* Allocate the channel contexts for DL */

		if ((Dl_p_chan_mgt = (struct dl_chan_mgt FAR *)Mem_alloc (Rnd_sizeof (struct dl_chan_mgt), PID_VL)) == P_NIL) {
			return (NS_CFG_ERR_MEMORY_FULL);
		}

			/* No B channel to be restarted for now */

		Dl_b_chan_restart_nb = 0;

			/* Update the table managing the B channels states */

		state = MAINT_STATE_B_OOS_NE;

		if ((Na_network == dms) ||
			(Na_network == ni2)) {

			state = MAINT_STATE_B_IS;
		}

		for (j = 0; j < NS_MX_NFAS_NAI; j++) {

			for (k = 0; k < NS_MX_B_CHAN; k++) {
				Dl_b_chan_mode_int (j, k) = state;
			}
		}

		if (Na_network == dms) {
			Dl_d_chan_state = MAINT_STATE_INB;
		}

			/* DL init method (Manual/Automatic) */

		Na_dl_init = Ns_config_dl_init;

			/*
			 * Build a NFAS table only if :
			 *
			 *	-1- NFAS_X is selected, or
			 *	-2- NFAS_TSP is selected with the Backup D channel procedure.
			 */

		if ((Ns_config_nfas_mode == NFAS_X) ||
			((Ns_config_nfas_mode == NFAS_TSP) && (Ns_config_d_bck == ON))) {

			if (ns_get_nfas_group (&nfas_group_id) != OK) {

				return (NS_CFG_ERR_NFAS_GROUPS);
			}

			Nfas_nai_mode = Ns_config_nfas_mode;
			Na_nfas = ON;

				/*
				 * This Na is a D channel bearer.
				 */

			Na_d_channel_type = NS_D_CHAN_ACTIVE;
			Na_d_channel_ctx  = nfas_group_id;

			Nfas_nai_active_d_chan		= Nai;
			Nfas_cfg_nai_active_d_chan	= Nai;
			Nfas_nai_p_active_d_chan 	= p_nsna;
			Nfas_dl_p_active_d_chan  	= p_nsdl;

			if (Na_network == dms) {

				if (Na_dl_init == DL_INIT_MANUAL) {
					Nfas_active_d_chan_status = MAINT_STATE_INB;		/* Initial state is INB */

				} else {
					Nfas_active_d_chan_status = MAINT_STATE_OOS;		/* Initial state is OOS */
				}

			} else {

				Nfas_active_d_chan_status = MAINT_STATE_IS;		/* Active D channel is IN of service */

			}

			Nfas_nai_d_chan_backup_act	  = Ns_config_d_bck;

			p_active_dl = Na_first_p_dl;

#			if NS_D_BACKUP == ON

				if (Ns_config_d_bck == ON) {

					if (Na_network == dms) {

						if (Na_dl_init == DL_INIT_MANUAL) {
							Nfas_backup_d_chan_status = MAINT_STATE_INB;	/* Initial state is INB */

						} else {
							Nfas_backup_d_chan_status = MAINT_STATE_MB;	/* Initial state is OOS */
						}

					} else {

						Nfas_active_d_chan_status	= MAINT_STATE_OOS;		/* Active D channel is OUT of service (Overwrite the previous value) */
						Nfas_backup_d_chan_status	= MAINT_STATE_OOS;      /* Backup D channel is OUT of service */
					}

					Nfas_cfg_nai_backup_d_chan	= Ns_config_d_bck_nai;	/* NFAS Nai for backup procedure */
					Nfas_nai_backup_d_chan		= Ns_config_d_bck_nai;

					if (Ns_config_nfas_mode == NFAS_X) {
						Na_maint_type = NFAS_X_BKP;

					} else {

						Na_maint_type = NFAS_TSP_BKP;
					}
				}

#			endif


				/* Build a NFAS call reference access table */
				/* The Call Reference gives the CC Nai */


			Nfas_tab_size = NS_MX_B_CHAN * (Ns_config_nfas_number + 1);

            if (Nfas_a_tab != P_NIL) {
            	Mem_free ((char FAR *)Nfas_a_tab, PID_VL);
            }

			if ((Nfas_a_tab = (struct nfas_tab FAR *)Mem_alloc (Rnd_sizeof (struct nfas_tab) * Nfas_tab_size, PID_VL)) == P_NIL) {
				return (NS_CFG_ERR_MEMORY_FULL);
			}

			if (Ns_config_nfas_number > NS_MX_NFAS_NAI) {
				return (NS_CFG_ERR_NFAS_NAI_NB);
			}

			for (j = 0; j < Nfas_tab_size; j++) {

				Nfas_p_tab(j).cc_nai= NAI_NIL;
				Nfas_p_tab(j).cr 	= 0;
			}

				/*
				 * Build the NFAS group
				 * -> List the Na managed by the D channel bearer.
				 */

			if (Ns_config_nfas_mode == NFAS_TSP) {

						/* Only 1 ctx : the Backup D channel */

				Nfas_nai_assoc_list_nb_nai = 1;

			} else {

				Nfas_nai_assoc_list_nb_nai = Ns_config_nfas_number;
			}

			for (j = 0; j < Nfas_nai_assoc_list_nb_nai; j++) {

					/*
					 * For each Nai managed by the current D channel
					 * bearer, record the group it belongs to,
					 * and if it is used for D channel backup
					 * purpose.
					 */

				if (ns_access_na (Ns_config_nfas_nai (j)) == NOK) {
					return (NS_CFG_ERR_NAI);
				}

				Na_nfas 			= ON;
				Na_d_channel_ctx	= nfas_group_id;
				Na_d_channel_type	= NS_D_CHAN_NIL;

#				if (NS_D_BACKUP == ON)

					if (j == 0) {

							/*
							 * The backup D channel bearer is the first
							 * Nai specified in the list.
							 */

						if (Ns_config_d_bck == ON) {

							Na_d_channel_type = NS_D_CHAN_BCK;
						}
					}

#				endif

				if (Na_d_channel_type == NS_D_CHAN_NIL) {

						/*
						 * We don't need to attach a specific DL context.
						 * Instead, we use the Dl context attached to the
						 * Active D channel.
						 * The Backup D channel must have its own DL context.
						 */

					if (ns_free_dl_ctx () != OK) {

							/* Should never happen ... */

						return (NOK);
					}

					Na_first_p_dl= p_active_dl;
				}

				Nfas_nai_assoc_list (j) = Nai;

			}

				/* Mark the D channel bearer itself (used in csc_dl_failure) */

			Nfas_nai_assoc_list (j) = Nfas_nai_active_d_chan;

		}

	}

	return (NS_CFG_OK);
}

#endif /* } NS_MAINTENANCE_CAPABILITY */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_nfas_send_dl_est - requires a DL establisment.

Usage            	uchar ns_nfas_send_dl_est (p_ns_config);

Return value :		NS_CFG_OK, NS_CFG_ERR_xxx

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar ns_nfas_send_dl_est (p_ns_config)
	struct ns_config 	FAR	*p_ns_config;			/* pointer on the configuration structure */
{
	ushort 					 i;						/* temporary index */
	struct i_ns_na 		FAR	*p_ns_config_na;		/* pointer on na inside the configuration structure */
	struct nsdl			FAR	*p_nsdl_save;			/* save p_nsdl */


			/* ----------- NA loop --------------- */

	for (i = 0; i < Ns_config_na_nb; i++) {

		p_ns_config_na	= Ns_config_na_a (i);		/* current na pointer inside the configuration buffer */

		if (ns_access_na (Ns_config_nai) == NOK) {
			return (NS_CFG_ERR_NAI);
		}

			/* NFAS applies for PRI only */

		if (Na_type != PRI) {
			continue;
		}

		if (ns_access_dl_ces (DL_CES_SIG) == NOK) {
			return (NOK);
		}

		if (Na_nfas == OFF) {

			if (Na_dl_init == DL_INIT_AUTO) {

					/* No NFAS involved, send the DL_EST_RQ as usual */

				p_nsdl_save	= p_nsdl;
				Send_to_dl 	(DL_EST_RQ, Na_dl_ces);	/* send to DL_D */
				p_nsdl		= p_nsdl_save;
				Lc_state 	= LC_AWAITING_EST; 		/* set state : awaiting establishment */

				if (Dl_p_chan_mgt != P_NIL) {

						/* Move to OOS */

					Dl_d_chan_state = MAINT_STATE_OOS;
				}


			} else {

				Lc_state 	= LC_ESTABLISHED;
			}

			continue;
		}

		Ns_access_d_chan_ctx (Na_d_channel_ctx);

		if (Na_d_channel_type != NS_D_CHAN_ACTIVE) {

				/* The Nai bears the Backup D channel ? */

#			if NS_D_BACKUP == ON

					/* Yes, save the DL and Na context */

				if (Na_d_channel_type == NS_D_CHAN_BCK) {

					Nfas_dl_p_backup_d_chan = p_nsdl;
					Nfas_nai_p_backup_d_chan= p_nsna;
					Lc_state 				= LC_RELEASED;

					if (Dl_p_chan_mgt != P_NIL) {

							/*
							 * Should never happen.
							 */

						Mem_free ((char FAR *) Dl_p_chan_mgt, PID_VL);
					}

					Dl_p_chan_mgt = Nfas_dl_p_active_d_chan -> p_dl_chan_mgt;

				}

#			endif

				/*
				 * The Nai does not bear a D channel
				 * --> don't ask for a DL connection.
				 */

		} else {

				/*
				 * The Na is bearing the D channel,
				 * Save the DL and Na context and
				 * send a DL_EST_RQ unless it requires a MANUAL command.
				 */


			if (Na_dl_init == DL_INIT_AUTO) {
				p_nsdl_save	= p_nsdl;
				Send_to_dl 	(DL_EST_RQ, Na_dl_ces);

				p_nsdl	= p_nsdl_save;
				Lc_state= LC_AWAITING_EST;

			} else {

				Lc_state= LC_RELEASED;
			}
		}
	}

	return (NS_CFG_OK);
}

#endif /* } NS_MAINTENANCE_CAPABILITY */

/*EOF*/
