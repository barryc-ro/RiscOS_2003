
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_spdu.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *        r_spdu - implements the processing of a received SPDU message.
 *
 *        r_spdu_ie - implements the processing of the Information Elements
 *        of a received message.
 *
 *        s_spdu - implements the creation of a spdu message for sending.
 *
 *        s_spdu_ie - implements the creation of the Information Elements of a
 *        sending message.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "ns.h"
#include "isdn.h"

#if C_COMPILER == TC
#   pragma hdrstop
#endif

#include "ctx_ext.h"

		/* external declaration */

extern	uchar	bc_teleservice_compatibility;	/* BC/HLC compatibility checking */


		/* Relative address calculation */

#define Relative_add            (ns_offset_t)(p_ie - p_spdu)


		/* Local fonction declarations */

#if NEW_FCT_STYLE == ON
	uchar   s_spdu_ie                       (struct spdu_ie *p_spdu_ie, struct spdu_ie_so *p_spdu_ie_so);
	uchar   s_spdu_ie_so                    (struct spdu_ie_so *p_spdu_ie_so, uchar next_codeset);
	uchar   r_spdu_ie                       (struct spdu_ie *p_spdu_ie, struct spdu_ie_so *p_spdu_ie_so, uchar codeset);
	uchar   r_spdu_ie_so                    (struct spdu_ie_so *p_spdu_ie_so);
	uchar   r_spdu_ie_so_check_mandatory    (struct spdu_ie_so *p_spdu_ie_so);
	uchar   check_ie                        (uchar ie_codeset, uchar ie_id);
	uchar   is_ie_comprehension_required    (uchar spdu_ie_ident, uchar codeset);

#	if (NS_SUPP_SERVICES == ON) && (F_ETS == ON)
		void	ns_ss_extended_fac_to_fac	(void);
#	endif

#else
	uchar   s_spdu_ie                       ();
	uchar   s_spdu_ie_so                    ();
	uchar   r_spdu_ie                       ();
	uchar   r_spdu_ie_so                    ();
	uchar   r_spdu_ie_so_check_mandatory    ();
	uchar   check_ie                        ();
	uchar   is_ie_comprehension_required    ();

#	if (NS_SUPP_SERVICES == ON) && (F_ETS == ON)
		void	ns_ss_extended_fac_to_fac	();
#	endif

#endif

/*==========================================================================*

			- Network SPDU information element descriptions -
*/

#if F_AT4 == ON
#	include "at4.net_spdu"
#endif

#if F_AT5 == ON
#	include "at5.net_spdu"
#endif

#if F_AT9 == ON
#	include "at9.net_spdu"
#endif

#if F_BIP == ON
#	include "bip.net_spdu"
#endif

#if F_AU1 == ON
#	include "au1.net_spdu"
#endif

#if F_BV1 == ON
#	include "bv1.net_spdu"
#endif

#if F_BT2 == ON
#	include "bt2.net_spdu"
#endif

#if F_TR6 == ON
#	include "tr6.net_spdu"
#endif

#if F_ETS == ON
#	include "ets.net_spdu"
#endif

#if F_A17 == ON
#	include "a17.net_spdu"
#endif

#if F_A11 == ON
#	include "a11.net_spdu"
#endif

#if F_E10 == ON
#	include "e10.net_spdu"
#endif

#if F_VN2 == ON
#	include "vn2.net_spdu"
#endif

#if F_VN3 == ON
#	include "vn3.net_spdu"
#endif

#if F_VN6 == ON
#	include "vn6.net_spdu"
#endif

#if F_KDD == ON
#	include "kdd.net_spdu"
#endif

#if F_NI1 == ON
#	include "ni1.net_spdu"
#endif

#if F_NI2 == ON
#	include "ni2.net_spdu"
#endif

#if F_DMS == ON
#	include "dms.net_spdu"
#endif

#if F_NTT == ON
#	include "ntt.net_spdu"
#endif

#if F_SWD == ON
#	include "swd.net_spdu"
#endif

#if F_QSI == ON
#	include "qsi.net_spdu"
#endif

#if F_HKT == ON
#	include "hkt.net_spdu"
#endif


/*=========================================================================*/

/*
*
*                 SPDU message structure
*                  spdu_msg
*    p_spdu ---> __________________________
*                | protocol discriminator |
*                |------------------------|
*                |    call reference      |
*                |------------------------|
*                |    SPDU message ID     |
* p_ie_start --->|------------------------|
*                |        IE's            |
*                |                        |
* p_spdu_end --->--------------------------
*
*                    Analyse and creation of a SPDU message
*
*                             -=-=-=-
*
*                           ----------------
*                           |  NET SPDU    |
*                           |    model     |
*                           ----------------
*                                  |
*                                  |
*      --------------       -------v-------
*      |   SPDU     | ----->|  r_spdu     | ------> internal IE
*      |  MESSAGE   |<----- |  s_spdu     |<------   structures
*      --------------       ---------------
*
*SPDU model description :
*----------------------
*
*            spdu    tab_spdu
*    =====================================================
*    | id | event_id | u_n | n_u | type | p_ie | p_ie_SO |
*    |----|----------|-----|-----|------|------|---------|
*    |    |          |     |     |      |  X-------   X-------------------
*    |----|----------|-----|-----|------|------|  |      |               |
*    |    |          |     |     |      |      |  |      |               |
*    |----|----------|-----|-----|------|------|- | -----|               |
*    |    |          |     |     |      |      |  |      |               |
*                                                 |                      |
*                            spdu_ie              |                      |
*            =====================================v====================  |
*            | id | codeset | u_n | n_u | type | lgth_mini |lgth_maxi |  |
*            |----|---------|-----|-----|------|-----------|----------|  |
*            |    |         |     |     |      |           |          |  |
*            |----|---------|-----|-----|------|-----------|----------|  |
*            |    |         |     |     |      |           |          |  |
*            |----|---------|-----|-----|------|-----------|----------|  |
*            |    |         |     |     |      |           |          |  |
*            ----------------                                            |
*                       |                                                |
*                       |                                                |
*                       -------> tab_ie                                  |
*                                                     --------------------
*                                          spdu_ie_so |
*                                        =============v===========
*                                        | id | u_n | n_u | type |
*                                        |----|-----|-----|------|
*                                        |    |     |     |      |
*                                        |----|-----|-----|------|
*                                        |    |     |     |      |
*                                        |----|-----|-----|------|
*                                        |    |     |     |      |
*
*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            r_spdu - implements the syntaxical and semantical processing
				of a received SPDU message.

Usage           uchar r_spdu (void);

Related
functions usage uchar r_spdu_ie (struct spdu_ie *p_spdu_ie);
						- p_spdu_ie : pointer on the IE table model.

Description     r_spdu implements the analyse of a received SPDU message
				to check its integrity and to load the the IE internal
				structures.
				The SPDU model is used to check the received message.

Return value    returns a code  = OK valid SPDU message.
								= NOK invalid SPDU message.

Common constants and declarations : ns.h

Common objects : p_spdu     points on the begining of the received message (inside),
				 p_spdu_end points on the end of the received message (outside).

*--------------------------------------------------------------------------*/

/*

						   ---------------------
						   |     NET SPDU      |---------
						   |    message model  |        |
						   ---------------------        |
									  |                 |
									  |                 |
		 --------------       --------v------           |
		 |   SPDU     |------>|    r_spdu   |           |
		 |  MESSAGE   |       | for each IE |           |
		 --------------       --------|------           |
								spdu ie list pointer    |
									  |             ----v-------------
							----------v---------    |    NET SPDU    |
							|   r_spdu_ie      |<---|    IE lists    |
							|         |        |    |   |            |
							----------|---------    ----|-------------
								 IE meta-program        |
									  |             ----v-------------
							----------v----------   |    NET SPDU    |
							|   exec_spdu_ie    |<--|    IE list     |
							|         |         |   |   |            |
							----------|----------   ----|-------------
									  |                 |
									  |                 v
									  ----------------->internal    ie_xxxx
														structure

*/

uchar r_spdu ()
{
	ushort				i;						/* SPDU model array index */
	uchar				call_ref_lgth;			/* length of the call reference */
	uchar		FAR	*	p_ie_start;				/* IE start pointer */
	ushort				data_size;				/* SPDU size */
	uchar				ext_msg_type	= OK;	/* escape to national specific message type error detection flag */

#	if NS_IE_TSP_IN == ON

		struct buffer FAR *p_buffer_sav;		/* backup buffer */

#	endif

		/* Init direction */

	direction = FROM_D_CHANNEL;

		/* Check the SPDU minimum length */

	if ((data_size = (ushort)(p_spdu_end - p_spdu)) < (ushort)(Spdu_param_spdu_lgth_min)) {

		if (error_set (ERR_N_SPDU_LGTH, 0, 0) == FATAL) {
			return (NOK);
		}
	}

		/* Init message header internal structure with protocol dicriminator */

#   if MESSAGE_HEADER_IE == ON
		i_message_header.protocol_discr = *p_spdu;
#   endif

		/*
		   Init p_ie current pointer on the data following
		   the spdu header.
		*/

	p_ie = p_spdu + 1;

		/*
		   Call reference length according to network access
		   rate interface.
		   Init i_call_ref (internal call reference value).
		*/

	I_call_ref_lgth = call_ref_lgth = R_call_ref_lgth;

		/* Check again the minimum SPDU size */

	if (data_size < (ushort)(PROTOCOL_DISCR_SIZE + CALL_REF_LGTH_SIZE +
							 MSG_TYPE_SIZE_MIN + I_call_ref_lgth)) {

		if (error_set (ERR_N_SPDU_LGTH, 0, 0) == FATAL) {
			return (NOK);
		}
	}

#	if NS_IE_TSP_IN == ON

			/* Save current context */

		p_buffer_sav = p_buffer;

			/* Alloc a buffer, and store the IEs in it */

		Buffer_alloc;
		Buffer_header_init;

		Memcpy_far ((char FAR *)Buffer_a_start_data, (char FAR *)p_spdu, data_size);

		Buffer_data_size = data_size;

			/* Save current p_buffer into p_buffer_q931 */

		p_buffer_q931 = p_buffer;

			/* Restore context */

		p_buffer = p_buffer_sav;

#	endif

	if (Na_type == BRI) {

#		if NS_TYPE_BRI == ON

			if ((call_ref_lgth < Spdu_param_call_ref_lgth_bri_min) || (call_ref_lgth > Spdu_param_call_ref_lgth_bri_max)) {

				if (error_set (ERR_N_CALL_REF_LGTH, 0, Relative_add) == FATAL) {

						/* Catch the expected spdu id before leaving and calling the error handler */

					spdu_id = *(p_spdu + Spdu_param_spdu_lgth_min - 1);
					return (NOK);
				}

			}

#		endif

	} else {

#		if NS_TYPE_PRI == ON

			if ((call_ref_lgth < Spdu_param_call_ref_lgth_pri_min) || (call_ref_lgth > Spdu_param_call_ref_lgth_pri_max)) {

				if (error_set (ERR_N_CALL_REF_LGTH, 0, Relative_add) == FATAL) {

						/* Catch the expected spdu id before leaving and calling the error handler */

					spdu_id = *(p_spdu + Spdu_param_spdu_lgth_min - 1);
					return (NOK);
				}

			}

#		endif

	}

	if  ( ! (Is_call_ref_nil) ) {

			/* Load internal call reference and test call reference PAD */

		if (i_call_ref_load (call_ref_lgth) == NOK) {

			if (error_set (ERR_N_CALL_REF_PAD, 0, Relative_add) == FATAL) {
				return (NOK);
			}

		}

		spdu_id = *p_ie;

			/* Is there an additional spdu id ? */

		if ( (spdu_id == ADDITIONAL_SPDU) && (Spdu_param_msg_type_mx_lgth > 1) ) {

				/* skip the first octet (escape) */

			spdu_id = *++p_ie;

				/* specific spdu type shall have bit 7 of octet 2 set to '1' */

			if (Get_bits (spdu_id, 7, 1) != G_1 (1)) {
				ext_msg_type = NOK;
			}

		}

			/* Check if global call reference */

		if ((I_call_ref_without_ces >> 1) == CALL_REF_GLOBAL_VAL) {

			if (error_set (ERR_N_CALL_REF_GLOBAL, spdu_id, Relative_add) == FATAL) {
				return (NOK);
			}

		}

#       if EQUIPMENT == TE

			if (spdu_id == SETUP) {

				if ((Na_connection_pmp) &&
					(Dl_ces != DL_CES_BROADCAST)) {

					if (error_set (ERR_N_BROADCAST, 0, Relative_add) == FATAL) {
						return (NOK);
					}

				}

			} else {

				if ((spdu_id != MAN_INFO) && (Dl_ces == DL_CES_BROADCAST)) {

					if (error_set (ERR_N_BROADCAST, 0, Relative_add) == FATAL) {
						return (NOK);
					}
				}
			}

#       else

			switch (Na_fct) {

					/* Network side */

				case FG_NT_TE :

					if (Dl_ces == DL_CES_BROADCAST) {

						if (error_set (ERR_N_BROADCAST, 0, Relative_add) == FATAL) {
							return (NOK);
						}

					}

					break;

					/* User side */

				default :

					if (spdu_id == SETUP) {

						if ((Na_connection_pmp) &&
							(Dl_ces != DL_CES_BROADCAST)) {

							if (error_set (ERR_N_BROADCAST, 0, Relative_add) == FATAL) {
								return (NOK);
							}

						}

					} else {

						if ((spdu_id != MAN_INFO) && (Dl_ces == DL_CES_BROADCAST)) {

							if (error_set (ERR_N_BROADCAST, 0, Relative_add) == FATAL) {
								return (NOK);
							}

						}

					}

					break;

			}

#       endif

			/*
			   Detect the call reference errors according to the SPDU ID
			   and init the current p_call pointer if the context does
			   not already exist.
			*/

		switch (spdu_id) {

				/*
					RELEASE COMPLETE SPDU message :
					 if the call reference is not recognized
					 --> stop the processing.
				*/

			case REL_COMP :
			case REL :

				if (ns_access_call_ref (I_call_ref) == NOK) {

					if (error_set (ERR_N_CALL_REF_UNKNOWN, 0, Relative_add) == FATAL) {

						if (spdu_id == REL_COMP) {
							event_id = DA_REL_COMP;
							Ns_ei (EV_NO_USID_TID, Na_dl_ces);
						}
					}

					return (NOK);
				}

				switch (Call_state) {

					case STATE_DISCONNECT_REQUEST_11 :
					case STATE_DISCONNECT_INDICATION_12 :
					case STATE_RELEASE_REQUEST_19 :
						Call_rel_flag = OFF;        /* not first message of the release sequence */
						break;

					default :
						Call_rel_flag = ON;         /* first message of the release sequence */
						break;

				}

				break;

				/*
					SETUP SPDU message :
					  if the call reference already exists --> fatal error.
				*/

			case SETUP :

#           if (EQUIPMENT == NT2) || (NS_SUPP_SERVICES == ON)
				case REG :
#           endif

#           if EQUIPMENT == NT2
				case RES :
#           endif

				if (Is_call_ref_outgoing_call) {

						/* Outgoing call ref flag on incoming call : error */

#                   if EQUIPMENT == TE

						if (error_set (ERR_N_CALL_REF_FLAG, 0, Relative_add) == FATAL) {
							return (NOK);
						}

#                   else

						if (ns_access_call_ref (I_call_ref) == OK) {

							if (Call_ces == DL_CES_NIL) {

								if (error_set (ERR_N_CALL_REF_FLAG_MULTIPOINT, 0, Relative_add) == FATAL) {
									return (NOK);
								}

							} else {

								if (error_set (ERR_N_CALL_REF_FLAG_POINT_TO_POINT, 0, Relative_add) == FATAL) {
									return (NOK);
								}

							}

						} else {

							if (error_set (ERR_N_CALL_REF_FLAG_NO_CALL, 0, Relative_add) == FATAL) {
								return (NOK);
							}

						}

#                   endif

				}

				if (ns_access_call_ref (I_call_ref) == OK) {

					if (error_set (ERR_N_CALL_REF_ALREADY_KNOWN, 0, Relative_add) == FATAL) {
						return (NOK);
					}

				}

					/* init 'bc_teleservice_compatibility' variable */

				bc_teleservice_compatibility = OK;
				break;

			case STATUS :
			case TR6_STATUS :

#               if EQUIPMENT == NT2

					if (((I_call_ref_without_ces >> 1) != CALL_REF_GLOBAL_VAL) ||
						(Spdu_param_call_ref_global_not_meaningful == ON)) {

						if (ns_access_call_ref (I_call_ref) == NOK) {

							if (error_set (ERR_N_STATUS_CALL_REF, 0, Relative_add) == FATAL) {
								return (NOK);
							}

						} else {

                        		/* call ref is allocated */

							if (Call_ces == DL_CES_NIL) {

								if (Call_ces_status == DL_CES_NIL) {
									Call_ces_status = Dl_ces;

								} else {

									Call_ces_status = DL_CES_NIL;
								}
							}
						}

					} /* end of not global call reference */

#               else	/* TE side */

					if (((I_call_ref_without_ces >> 1) != CALL_REF_GLOBAL_VAL) ||
						(Spdu_param_call_ref_global_not_meaningful == ON)) {

						if (ns_access_call_ref (I_call_ref) == NOK) {

							if (error_set (ERR_N_STATUS_CALL_REF, 0, Relative_add) == FATAL) {
								return (NOK);
							}

						}

					}

#               endif

				break;

			case K_SETUP		:

				if (ns_access_call_ref (I_call_ref) == OK) {

					if (error_set (ERR_N_CALL_REF_ALREADY_KNOWN, 0, Relative_add) == FATAL) {
						return (NOK);
					}
				}

				break;

			case MAN_INFO       :
				break;

			case RESTART        :
			case RESTART_ACK    :

#				if NS_RESTART_PROCEDURE == ON

					if (Spdu_param_restart_procedure == ON) {

						if (Spdu_param_call_ref_global_not_meaningful == ON) {

							if ((I_call_ref_without_ces >> 1) != CALL_REF_GLOBAL_VAL) {

								/*
								 * We received a RESTART or RESTART_ACK on call ref
								 * which is not the CALL_REF_GLOBAL, and those
								 * messages may be received on that call ref,
								 * so we try to access the current call reference.
								 */

								if (ns_access_call_ref (I_call_ref) == NOK) {

									if (error_set (ERR_N_CALL_REF_UNKNOWN, 0, Relative_add) == FATAL) {
										return (NOK);
									}
								}

							}

						} else {

								/*
								 * Call ref global have a specific meaning.
								 * Thus, RESTART or RESTART_ACK must be
								 * received on that call ref.
								 */

							if ((I_call_ref_without_ces >> 1) != CALL_REF_GLOBAL_VAL) {

								if (error_set (ERR_N_CALL_REF_UNKNOWN, 0, Relative_add) == FATAL) {
									return (NOK);
								}
							}
						}

					} else {

						if (error_set (ERR_N_SPDU_TYPE, 0, Relative_add) == FATAL) {
							return (NOK);
						}

					}

					Na_restart_crl = I_call_ref_lgth;

#				else

					if (error_set (ERR_N_SPDU_TYPE, 0, Relative_add) == FATAL) {
						return (NOK);
					}

#				endif

				break;

#			if NS_MAINTENANCE_CAPABILITY == ON

				 case MAINT_SERVICE :
				 case MAINT_SERVICE_ACK :

					if ((protocol_discr == PROTOCOL_DISCR_MAINT_ATT_CUST) 	||
						(protocol_discr == PROTOCOL_DISCR_MAINT_NATIONAL)) {

							/* Must use the global call ref */

						if ((I_call_ref_without_ces >> 1) != CALL_REF_GLOBAL_VAL) {

							if (error_set (ERR_N_CALL_REF_UNKNOWN, 0, Relative_add) == FATAL) {
								return (NOK);
							}
						}

						break;

					}

						/*
						 * Process the default is the protocol discriminator
						 * is not a maintenance one.
						 */

#			endif

					/*
					   Others SPDU messages :
						 if the call reference is not recognized ---> fatal error.
					*/

			default :

				if (ns_access_call_ref (I_call_ref) == NOK) {

					if (error_set (ERR_N_CALL_REF_UNKNOWN, 0, Relative_add) == FATAL) {
						return (NOK);
					}

				}
				break;

		}   /* end of switch */

	} else {    /* call ref lgth == 0 */

#       if MESSAGE_HEADER_IE == ON
			i_message_header.call_ref_lgth = CALL_REF_NIL;
			i_message_header.call_ref_flag = 0;
			i_message_header.call_ref_val  = (call_ref_t) 0;
#       endif

		spdu_id = *(++p_ie);

		if (error_set (ERR_N_CALL_REF_DUMMY, spdu_id, Relative_add) == FATAL) {
			return (NOK);
		}

	}

			/* Load the message type into the message header IE internal structure */

#   if MESSAGE_HEADER_IE == ON
		i_message_header.message_type = spdu_id;
#   endif


		/*
			Ensure that the spdu type was properly coded in case of national
			escape coding.
		*/

	if (ext_msg_type == OK) {

			/*
			   Find the SPDU message ID (type) entry in the model
			   table (tab_spdu).
			*/

		if ((i = Access_tab_spdu (Search_key_spdu (spdu_id))) != X_SPDU_NIL) {

				/* If access type and direction not from D channel --> not found */

			if ( (Na_type & Spdu_access_type (i)) &&
				 (Received_from_d_channel (Spdu_u_n (i), Spdu_n_u (i)))
			   ) {

					/*
					   OK SPDU ID matches :
						- set p_ie on the first  IE element,
						- put Message_header IE into the present IEs list,
						- then process the IE 's according to the IE model of the
						  SPDU message ID. If the IE are ordered only according
						  to the IE ID one pass is made, else one pass by existing
						  codeset is made.
					*/

				p_ie_start = ++p_ie;

#   	        if MESSAGE_HEADER_IE == ON

						/* Put Message_header into the present IEs list */

					set_ie_i (CODESET_NIL, MESSAGE_HEADER);
#	           endif

				if (Spdu_param_ie_codeset_order_meaningful == OFF) {
					r_spdu_ie (Spdu_p_ie (i), Spdu_p_ie_so(i), CODESET_NIL);

				} else {

						/* Process the Information Elements codeset by codeset */

					r_spdu_ie (Spdu_p_ie (i), Spdu_p_ie_so (i), CODESET_0);

					p_ie = p_ie_start;
					r_spdu_ie (Spdu_p_ie (i), Spdu_p_ie_so (i), CODESET_5);

					p_ie = p_ie_start;
					r_spdu_ie (Spdu_p_ie (i), Spdu_p_ie_so (i), CODESET_6);

					p_ie = p_ie_start;
					r_spdu_ie (Spdu_p_ie (i), Spdu_p_ie_so (i), CODESET_7);

				}

					/*
					   Init event identifier from spdu model
					   (for the automaton processing).
					*/

				event_id = Spdu_event_id (i);

#				if (NS_SUPP_SERVICES == ON) && (F_ETS == ON)
					ns_ss_extended_fac_to_fac ();	/* change possible Extended Facility IE into Facility IE */
#				endif

					/* If an error has occurred return NOK else OK. */

				if (Error_nb () == 0) {
					return (OK);

				} else {

					return (NOK);
				}

			}

		}

	}

		/*
		   SDPU ID not found or not right direction in the model table
		   --> error :
						initialize the error diagnostic flag with
						the erroneous SPDU ID.
		*/

	if (error_set (ERR_N_SPDU_TYPE, spdu_id, Relative_add) == FATAL) {
		return (NOK);

	} else {

		return (OK);
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            r_spdu_ie - implements the processing of the Information
							elements of a received message acording to all
							the codeset or only one codeset. In this case
							the next processing codeset is prepared.

Usage           uchar r_spdu_ie (struct spdu_ie *p_spdu_ie, codeset);

						- p_spdu_ie points on the IE model of the SPDU
						  message ID.

						- codeset : codeset to process, if CODESET_NIL
						  process all the codesets.

Related
functions usage uchar exec_spdu ie (uchar ie_codeset, uchar ie_id);
							- ie_codeset    : IE codeset,
							- ie_id     : IE ID.

Description     r_spdu_ie implements the analyse of the Information Elements
				of a received message according to the corresponding
				IE table model. The processing is done in only one pass if
				the codeset parameter is set to CODESET NIL. In the others
				case one codeset is processed and the next one is prepared.

Return value    returns = OK valid IE's.
						# OK invalid IE's.

Common constants and declarations : ns.h

Common objects : - spdu_id SPDU message ID,
				 - p_spdu points on the SPDU data,
				 - p_spdu_end points on the end of the SPDU data,
				 - p_ind_spdu points the starting of the indirect buffer,
				   the internal list is empty.
				 - codeset next : next codeset to process, if CODESET_NIL
				   no more processing.

*--------------------------------------------------------------------------*/

uchar r_spdu_ie (p_spdu_ie, p_spdu_ie_so, codeset)
	struct spdu_ie      *p_spdu_ie;                 /* pointer on the IE model */
	struct spdu_ie_so   *p_spdu_ie_so;              /* pointer on the IE SO model */
	uchar                codeset;                   /* codeset to process in the SPDU */
{
	uchar                ie_codeset_implicit;       /* implicit codeset */
	uchar                flag_ie_found;             /* flag IE found */
	uchar                spdu_ie_id_old;            /* previous IE ID */
	ushort               ie_lgth;                   /* IE data length */
	uchar                skip;                      /* skip IE flag */
	struct spdu_ie      *p_spdu_ie_save;            /* save current pointer on the IE model */
	struct spdu_ie      *p_spdu_ie_start;           /* save initial pointer on the IE model */
	struct spdu_ie      *p_spdu_ie_local;			/* save current pointer on the IE model for local process */
	uchar                ie_err_code;               /* used to store the error code of an ie content error */
	uchar                ie_type;	               	/* ie type (OP, MD, EX)*/
	uchar                nb_error_sav;              /* saved error counter */
	uchar				 m_ie_type;					/* model ie type */

#	if NS_RESTART_PROCEDURE == ON
		uchar			 restart_ind_found;			/* restart ind found */
#	endif

/*
*   SPDU processing :
*
*        Parallele scanning of the def table and the spdu message.
*        p_ie points the first IE of the spdu message.
*        p_spdu_ie points the first IE entry in the spdu_ie modele.
*
*              _____________                      _____________
*p_spdu_ie --->|           |              p_ie -->|           |
*              |-----------|                      |           |
*              |-----------|                      |-----------|
*              |-----------|                      |-----------|
*              |-----------|                      |           |
*              |-----------|                      |           |
*              |-----------|                      |-----------|
*              |-----------|                      |           |
*              |-----------|                      |-----------|
*              |-----------|                      |           |
*              |-----------|                      |           |
*              -------------       p_spdu_end --> -------------
*
*/

#if NS_RESTART_PROCEDURE == ON

	restart_ind_found = FALSE;

#endif

/*  Verify the spdu validity and call the ad hoc function */

	p_spdu_ie_start = p_spdu_ie;

		/* Init implicit codeset to code 0 */

	ie_codeset_implicit = ie_codeset = CODESET_0;

		/* Init ie_id value */

	ie_id = spdu_ie_id_old = IE_MINI;

		/* init IE repetition index */

	i_ie_x = 0;

		/* While end of incoming SPDU buffer is not reached */

	while (p_ie < p_spdu_end) {

		ie_id = *p_ie;

			/* Single Octet (SO) format ? */

		if (So_ie_flag == IE_FORMAT_SO) {

				/* Single Octet IE processing */

			switch (So_ie_1_id) {

				case SHIFT :

					switch (So_ie_1_lock) {

						case LOCKING_SHIFT:

							if (Spdu_param_ie_locking_shift == ON) {
								ie_codeset_implicit = ie_codeset = So_ie_1_codeset;

							} else {

									/* Locking shift not allowed -> set an error if not already done */

								if ((codeset == CODESET_NIL) || (codeset == CODESET_0)) {

									if (error_set (ERR_N_IE_UNKNOWN, ie_id, CODESET_SO) == FATAL) {
										return (NOK);
									}
								}
							}

							break;

						case NON_LOCKING_SHIFT:

							if (Spdu_param_ie_non_locking_shift == ON) {
								ie_codeset = So_ie_1_codeset;

							} else {

									/* Non locking shift not allowed : error */

								if ((codeset == CODESET_NIL) || (codeset == CODESET_0)) {

									if (error_set (ERR_N_IE_UNKNOWN, ie_id, CODESET_SO) == FATAL) {
										return (NOK);
									}
								}
							}

							break;
					}

					break;

				default :

						/* SPDU codeset filtering */

					if ((codeset == CODESET_NIL) || (codeset == ie_codeset)) {

						if (r_spdu_ie_so (p_spdu_ie_so) != OK) {
							return (NOK);
						}
					}

					ie_codeset = ie_codeset_implicit;
			}

			++p_ie;     /* next IE */

		} else {

				/* SPDU codeset filtering */

			if ((codeset == CODESET_NIL) || (codeset == ie_codeset)) {

				/* Variable Length (VL) IE processing */

					/* Is the IE ID valid ? */

				if (check_ie (ie_codeset, ie_id) == NOK) {

					if ((Net_param_ie_comprehension_required == ON) &&
						(is_ie_comprehension_required (Vl_ie_id, ie_codeset) == OK)) {

						if (error_set (ERR_N_IE_M_MISSING, ie_id, ie_codeset) == FATAL) {
							return (NOK);
						}

					} else {

						if (error_set (ERR_N_IE_UNKNOWN, ie_id, ie_codeset) == FATAL) {
							return (NOK);
						}

					}

						/* next IE in the received spdu */

					++p_ie;
					p_ie += *p_ie + 1;

						/* Set ie_codeset to implicit ie_codeset */

					ie_codeset  = ie_codeset_implicit;

					continue;

				}

				skip = OFF;

					/* Set IE length and pointer on the next SPDU IE */

				if ((ie_lgth = *(++p_ie)) == 0) {       /* if the IE length is null ? */
					skip = ON;                          /* if so the IE is absent --> skip it */
				}

				p_ie_end    = ++p_ie + ie_lgth;         /* p_ie_end points on the next IE
														   and p_ie points on the IE content */
				ie_lgth     += 2;                       /* total IE length */

					/* Skip the current IE ? */

				if ((Spdu_param_null_lgth_ie_ignored == OFF) || (skip == OFF)) {

						/*
						   In sequence or allowed duplicated IE
						   --> process the information Element.
						*/

					p_spdu_ie_save  = p_spdu_ie;
					flag_ie_found   = ON;

						/* if a codeset is needed, search for it */

					while ((M_ie_id != IE_NIL) && (codeset != CODESET_NIL) && (codeset != M_ie_codeset)) {

							/* Next element in the model table */

						p_spdu_ie++;

					}

					nb_error_sav = nb_error;

					while ((M_ie_id != IE_NIL) && (M_ie_id <= ie_id)) {

						i_ie_x = 0;

						if ((Received_from_d_channel (M_ie_u_n, M_ie_n_u)) &&
							((codeset == CODESET_NIL) || (codeset == M_ie_codeset)) ) {

							flag_ie_found   = OFF;

								/*
								   Compare information element id in current
								   buffer and in model, if equal than compare
								   direction and codeset.
								*/

							if ((M_ie_id == ie_id) && (M_ie_codeset == ie_codeset)) {

									/*
									   Equal, verify length compatibility.
									   if incompatible --> error.
									*/

								flag_ie_found   = ON;

									/* Skip the IE processing if duplicated and no more allowed  */

								if ((i_ie_x = nb_ie_i (ie_codeset, ie_id)) < M_ie_repetition) {

									m_ie_type = M_ie_type;

#									if NS_RESTART_PROCEDURE == ON

										if ((spdu_id == RESTART) && (Spdu_param_restart_procedure == ON)) {

											if (ie_id == CHAN_ID) {

												/*
												 * CHAN_ID was included by the network,
												 * so it is MD.
												 */

												m_ie_type = MD;
											}

											if (ie_id == RESTART_IND) {
												restart_ind_found = TRUE;
											}
										}

#									endif

									ie_type = Ie_type (spdu_id, ie_id, m_ie_type);

									if (ie_type == MD) {

											/* Mandatory IE */

										ie_err_code = ERR_N_IE_M_CONTENT;

										if (ie_lgth  < M_ie_mini_lgth) {

											if (error_set (ERR_N_IE_M_TOO_SHORT, ie_id, ie_codeset) == FATAL) {
												return (NOK);
											}

											break;                      /* ignore the erroneous IE */

										} else if ((ie_lgth  > (ushort)(M_ie_maxi_lgth + NS_MX_ADDITIONAL_OCTET)) ||
												 (p_ie_end > p_spdu_end)) {

											if (error_set (ERR_N_IE_M_TOO_LONG, ie_id, ie_codeset) == FATAL) {
												return (NOK);
											}

											break;                      /* ignore the erroneous IE */
										}

									} else {

										if (ie_type == OP) {

												/* Optional IE */

											ie_err_code = ERR_N_IE_O_CONTENT;

											if ((ie_lgth < M_ie_mini_lgth) ||
												(ie_lgth > (ushort)(M_ie_maxi_lgth + NS_MX_ADDITIONAL_OCTET)) ||
												 (p_ie_end > p_spdu_end)
											   ) {

												if (error_set (ERR_N_IE_O_LGTH, ie_id, ie_codeset) == FATAL) {
													return (NOK);
												}

												break;                      /* ignore the erroneous IE */

											}

										} else {

												/* Exclude IE */

											if (error_set (ERR_N_IE_UNKNOWN, ie_id, ie_codeset) == FATAL) {
												return (NOK);
											}

											break;                      /* ignore the erroneous IE */
										}

									}

										/*
										   - execute IE checking and convertion,
										   - p_ie point on the current ie content,
										   - p_ie_end point on the end of the current ie,
										   - ie_err_code  = error type (content).

											Init the internal data structure
											with implicit values.
										*/

									ie_implicit_val_x (ie_codeset, ie_id, i_ie_x);

										/*
										   Skip the IE checking only if null length,
										   else process the checking.
										*/

									if (skip == ON) {

											/* add the ie_id in the internal list. */

										set_ie_i (ie_codeset, ie_id);

									} else {

											/* Process the SPDU IE content */

										if ((exec_spdu_ie (ie_codeset, ie_id, i_ie_x) == OK)) {

												/*
												   Valid IE : add ie_id
												   item to the internal list.
												*/

											set_ie_i (ie_codeset, ie_id);

										} else {

												/*
												   Is the error non-fatal ?
												   if so ignore the IE,
												   if not return NOK.
												*/

											if (error_set (ie_err_code, ie_id, ie_codeset) == FATAL) {
												return (NOK);
											}

										}

									}   /* endif skip */

								}   /* endif one more repeated ie allowed */

							} else {    /* spdu_id or codeset doesn't match */

									/*
									   Absent element. Is it mandatory ?
									   if so --> error.
									*/

								if (Ie_type (spdu_id, M_ie_id, M_ie_type) == MD) {

									if (error_set (ERR_N_IE_M_MISSING, M_ie_id, M_ie_codeset) == FATAL) {
										return (NOK);
									}

								}

							}

								/*
									If the IE is already repeated or
									will be repeated in the SPDU, check
									the maximum repetition allowed.
								*/

							if ((flag_ie_found == ON) &&
								(
								  (i_ie_x != 0)  ||
								  (
									(p_ie_end  < p_spdu_end) &&
									(*p_ie_end == ie_id)
								  )
								)
							   ) {

								if (i_ie_x >= M_ie_repetition) {

										/* Too many repetitions */

									if (error_set (ERR_N_IE_REPEATED, M_ie_id, M_ie_codeset) == FATAL) {
										return (NOK);
									}

								}

									/*
										If the element will be repeated once
										again, do not increment the model table
										pointer : process the next repetition
									*/

								if ((p_ie_end  < p_spdu_end) && (*p_ie_end == ie_id)) {
									break;
								}

							}

						}

							/* Next element in the model table */

						p_spdu_ie++;

					}   /*
						   End of while (M_ie_id <= ie_id) or end
						   of model table.
						*/

					if ((nb_error_sav == nb_error) &&
						(is_ie_i (ie_codeset, ie_id) != PRESENT)) {

							/* Unknown ie type or Out-of-Sequence */

							/* Look for the ie_id into the Model table to */
							/* see if it is out of sequence or not */

						p_spdu_ie_local = p_spdu_ie;    /* save current pointer */

						for (p_spdu_ie = p_spdu_ie_start; p_spdu_ie != p_spdu_ie_local; p_spdu_ie++) {

							if ((M_ie_id == ie_id) && (Received_from_d_channel (M_ie_u_n, M_ie_n_u))) {

#								if NS_RESTART_PROCEDURE == ON

									if (Spdu_param_restart_procedure == ON) {

										if ((ie_id == CHAN_ID) && (restart_ind_found == TRUE)) {

											if (error_set (ERR_N_IE_M_MISSING, ie_id, ie_codeset) == FATAL) {
												return (NOK);
											}
										}
									}

#								endif

								if (error_set (ERR_N_IE_OUT_OF_SEQUENCE, ie_id, ie_codeset) == FATAL) {
									return (NOK);
								}

								break;
							}

						}

						if (p_spdu_ie == p_spdu_ie_local) {

							if (error_set (ERR_N_IE_UNKNOWN, ie_id, ie_codeset) == FATAL) {
								return (NOK);
							}
						}

							/*
							   - skip the element,
							   - restart the scanning at the previous point,
							   - and restore the ie_id context.
							*/

						p_spdu_ie   = p_spdu_ie_save;
						ie_id   = spdu_ie_id_old;
					}

				}   /* End if skip == OFF */

			} else { /* if codeset filtering ... */

					/* set p_ie_end to the next IE */

				p_ie_end = p_ie + *(p_ie + 1) + 2;	/* '+ 2' for IE Id and lgth octets */

			}

				/*
				   Point to the next information element
				   in the current buffer.
				*/

			p_ie = p_ie_end;

				/* Set ie_codeset to implicit ie_codeset */

			ie_codeset  = ie_codeset_implicit;

			spdu_ie_id_old  = ie_id;

		}   /* if ... else  ... */

	}  /*   End of while (p_ie < p_spdu_end)  */

		/* re-init current IE repetition index */

	i_ie_x = 0;

		 /* Are there others mandatory information elements in the models ? */

	for ( ; M_ie_id != IE_NIL ; p_spdu_ie++) {

			/* If so --> error */

		if ((Received_from_d_channel (M_ie_u_n, M_ie_n_u)) &&
			(Ie_type (spdu_id, M_ie_id, M_ie_type) == MD) &&
			((codeset == CODESET_NIL) || (M_ie_codeset == codeset))
		   ) {

			if (error_set (ERR_N_IE_M_MISSING, M_ie_id, M_ie_codeset) == FATAL) {
				return (NOK);
			}

		}

	}

	if (r_spdu_ie_so_check_mandatory (p_spdu_ie_so) == OK) {
		return (OK);

	} else {

		return (NOK);
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name        ie_comprehension_rq

Description Check if the IE is "comprehension required".
			IE is "comprehension required" if IE id is from codeset 0 and
			coded 0000xxxx and reserved also.

Return      OK  :   if IE is from "comprehension required" type,
			NOK :   if not.

Usage       uchar is_ie_comprehension_required (uchar spdu_ie_ident, uchar codeset)
*---------------------------------------------------------------------------*/

uchar is_ie_comprehension_required (spdu_ie_ident, codeset)
	uchar   spdu_ie_ident;
	uchar 	codeset;
{

		/*
			"is_ie_comprehension_required" is called AFTER having checked
			that the IE id is NOT in the expected IE id model list,
			so its code is reserved. If more, this IE id is coded 0000xxx,
			and it is from codeset 0 then IE is "comprehension_required".
		*/

		/* Tests if bits 4->7 from IE id are null */

	if ((codeset == CODESET_0) && (Get_bits (spdu_ie_ident, 4, 4) == 0)) return (OK);

	return (NOK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            s_spdu - implements the creation of a SPDU message from
						 the internal IE structures.

Usage           uchar s_spdu (uchar spdu_id, ushort FAR *p_size);
					- spdu_id : SPDU message ID (type),
					- p_size  : SPDU size location.

Related
functions usage uchar s_ie (struct spdu_ie *p_spdu_ie);
					- p_spdu_ie : pointer on the IE table that describes
								   the IE element of the SPDU message.

Description     is_spdu mplements the creation of the SPDU message header
				and call the execution of the IE fields creation.

Return value    return code = OK valid message is created - p_ie points the
								 end of the SPDU data (outside).
							# OK no valid message created - error code.

Common constants and declarations : ns.h

Common objects : p_spdu points on the SPDU data location (inside).

*--------------------------------------------------------------------------*/
/*

						   ---------------------
						   |     NET SPDU      |---------
						   |    message model  |        |
						   ---------------------        |
									  |                 |
									  |                 |
		 --------------       --------v------           |
		 |   SPDU     |       |    s_spdu   |           |
		 |  MESSAGE   |<------| for each IE |           |
		 --------------       --------|------           |
								spdu ie list            |
									  |             ----v-------------
							----------v---------    |    NET SPDU    |
							|   s_spdu_ie      |<---|    IE list     |
							|         |        |    |   |            |
							----------|---------    ----|-------------
								 IE meta-program        |
									  |             ----v-------------
							----------v---------    |    NET SPDU    |
							|   exec_spdu_ie   |<---|    IE list     |
							|                  |    |   |            |
							----------Œ---------    ----|-------------
									  |                 |
									  |                 v
									  ----------------- internal    ie_xxxx
														structure

*/

uchar s_spdu (v_spdu_id, p_size)
	uchar                    v_spdu_id;     /* SPDU message ID to create */
	ushort              FAR *p_size;        /* SPDU size location */
{
	ushort                   i;             /* tab_spdu current index */
	uchar                    call_ref_lgth; /* call reference length */

		/* Init direction */

	direction = TO_D_CHANNEL;

		/* p_spdu points the SPDU location */

		/* Set p_ie pointer on the protocol discriminator field */

	p_ie = p_spdu;

		/*
		   Create the message header (spdu_msg structure) :
			- protocol discriminator,
			- call reference.
		*/

#if NS_MAINTENANCE_CAPABILITY == ON

	if (protocol_discr != Spdu_param_net_protocol_discriminator) {

			/* The maintenance protocol is required */

		S_protocol_discriminator_load (protocol_discr);

	} else {

			/* The protocol discriminator is the usual one */

		S_protocol_discriminator_load (Spdu_param_net_protocol_discriminator);
	}

#else

	S_protocol_discriminator_load (Spdu_param_net_protocol_discriminator);

#endif

	if (Is_call_ref_nil) {
		Put_inc_ie_octet (CALL_REF_NIL);

	} else {

		if (Call_current_exist) {
			call_ref_lgth = Call_ref_lgth;

		} else {

			call_ref_lgth = I_call_ref_lgth;
		}

		spdu_call_ref_load (call_ref_lgth);
	}

		/* Search SPDU message ID (type) in the modele tab_spdu */

	if ((i = Access_tab_spdu (Search_key_spdu (v_spdu_id))) != X_SPDU_NIL) {

#       if ASSERT == ON

			if ( ! (Sent_to_d_channel (Spdu_u_n (i), Spdu_n_u (i)))) {
				Trap (TRAP_S_SPDU, "s_spdu");
			}

#       endif

		switch (v_spdu_id) {

			case REL_COMP :
			case REL      :

				if (Call_current_exist) {

					switch (Call_state) {

						case STATE_DISCONNECT_REQUEST_11    :
						case STATE_DISCONNECT_INDICATION_12 :
						case STATE_RELEASE_REQUEST_19       :
							Call_rel_flag = OFF;        /* not first message of the release sequence */
							break;

						default :
							Call_rel_flag = ON;         /* first message of the release sequence */
							break;
					}

				}

				break;

			case SETUP :

					/* init 'bc_teleservice_compatibility' variable */

				bc_teleservice_compatibility = OK;
				break;
		}

			/*
				In case of 2 octets length SPDU type, add the first octet
				(escape to national specific messages)
			*/

		if ((Get_bits (v_spdu_id, 7, 1) == G_1 (1)) && (Spdu_param_msg_type_mx_lgth > 1) ) {
			*(p_ie++) = ADDITIONAL_SPDU;
		}

		*(p_ie++) = spdu_id = v_spdu_id;

			/*
			   p_spdu_ie points on the IE list which shall describe how to
			   build the SPDU message.
				- process the IE list to create the message.
			*/

			/* Error ---> return with NOK code */

		if ((s_spdu_ie (Spdu_p_ie (i), Spdu_p_ie_so (i)) != OK) || (Error_nb () != 0)) {
			return (NOK);
		}

			/* Store the SPDU size */

		*p_size = (ushort)(p_ie - p_spdu);

			/* Valid message ---> normal return / p_ie points the SPDU data end */

		return (OK);

	}

		/* Unknown SPDU_ID ---> fatal error ---> Trap */

	return (ERR_N_SPDU_TYPE);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            s_spdu_ie - implements the creation of the IE part
							of a SPDU    message.

Usage           uchar s_spdu_ie (struct spdu_ie *p_spdu_ie);
						 - p_spdu_ie : pointer on the IE list of the SPDU
										message type to create.

Related
functions usage uchar exec_spdu_ie (uchar ie_codeset, uchar ie_id);
						- ie_codeset    : IE codeset,
						- ie_id         : IE ID.

Description     s_ie implements the execution of the IE table model
				in order to create the SPDU message.

Return value    returns code = OK valid message,
							 # OK invalid message - error code is returned.

Common constants and declarations : ns.h

Common objects :

*--------------------------------------------------------------------------*/

uchar s_spdu_ie (p_spdu_ie, p_spdu_ie_so)
	struct spdu_ie      *p_spdu_ie;                 /* pointer on the IE list */
	struct spdu_ie_so   *p_spdu_ie_so;              /* pointer on the IE SO list */
{
	uchar                implicit_spdu_ie_codeset;  /* implicit codeset */
	uchar                x_ie;                      /* IE occurences loop counter */
	uchar				 ie_type;					/* IE type (MD,OP,EX) */
	uchar				 nb_ie_instance;			/* number of repeated IE in internal structure */

		/* Set implicit codeset to codeset 0 */

	implicit_spdu_ie_codeset = ie_codeset = CODESET_0;

		/*
		   Scan the IE list and if the direction is user to network
		   create the IE field in the message area (p_ie)if the
		   internal IE structure is loaded.
		*/

	for ( ; M_ie_id != IE_NIL; p_spdu_ie++) {

			/* init IE repetition index */

		i_ie_x = 0;

			/* IE needed for the direction */

		if (Sent_to_d_channel (M_ie_u_n, M_ie_n_u)) {

			ie_type = Ie_type (spdu_id, M_ie_id, M_ie_type);

				/*
					Is the internal corresponding IE structure on
					or is the IE mandatory ?
				*/

			if ((nb_ie_instance = nb_ie_i (M_ie_codeset, M_ie_id)) == 0) {

						/*
						   If IE not present and mandatory force the
						   implicit values.
						*/

				if (ie_type == MD) {
					ie_implicit_val_x (M_ie_codeset, M_ie_id, 0);
					nb_ie_instance++;

				} else {

						/* IE not present and not mandatory ---> next IE */

					continue;
				}

			} else {	/* if PRESENT ... */

				if (nb_ie_instance > M_ie_repetition) {

						/* ignore extra instances */

					nb_ie_instance = M_ie_repetition;
				}
			}

				/* IE shall be eXcluded from the message */

			if (ie_type == EX) {

				continue;			/* ----> next IE */
			}

				/* process all the occurences of the IE */

			for (x_ie = 0; x_ie < nb_ie_instance; x_ie++) {

					/*
					   Generate the ie - is the codeset not equal to the
					   implicit codeset ?
					   if so, create a single octet SHIFT element.
					*/

				if (M_ie_codeset != implicit_spdu_ie_codeset) {

					if (Spdu_param_ie_non_locking_shift == ON) {

							/*
							   non-locking shift allowed :
							   just load a non-locking shift in the message.
							*/

						So_ie_1_load (M_ie_codeset, NON_LOCKING_SHIFT, SHIFT, IE_FORMAT_SO);

					} else {
							/*
							   non-locking shift not allowed :
							   set the new codeset implicit value
							   process the single-octet IEs that belong
							   to lower codesets than next to be processed
							   and load a locking shift in the message.
							*/

						implicit_spdu_ie_codeset = M_ie_codeset;

						if (s_spdu_ie_so (p_spdu_ie_so, implicit_spdu_ie_codeset) != OK) {

							return (NOK);
						}

						ie_codeset = implicit_spdu_ie_codeset;
						So_ie_1_load (M_ie_codeset, LOCKING_SHIFT, SHIFT, IE_FORMAT_SO);
					}

					p_ie++;
				}

					/* Load the IE ID in the message */

				*(p_ie++) = M_ie_id;

					/* Execute the IE field generation and return if not OK */

				if ((ret_code = exec_spdu_ie (M_ie_codeset, M_ie_id, x_ie)) != OK) {
					return (ret_code);
				}

			}   /* End for (all occurences of the IE) */

		}   /* End if (Sent_to_d_channel) */

	}   /* End for  IE table */

		/* re-init IE repetition index */

	i_ie_x = 0;

	if (s_spdu_ie_so (p_spdu_ie_so, CODESET_NIL) != OK) {
		return (NOK);

	} else {

			/* end of IE tables ---> return OK */

		return (OK);
	}
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            s_spdu_ie_so, r_spdu_ie_so and r_spdu_ie_so_check_mandatory -
				implements the treatment of Single Octet IE.
					- provide in the SPDU,
					- extraction from a SPDU,
					- checks the presence of Mandatory SO IE from the Model
					  in received internal list.

Usage           uchar   s_spdu_ie_so    (struct spdu_ie_so  *p_spdu_ie_so, uchar next_codeset);
				uchar   r_spdu_ie_so    (struct spdu_ie_so  *p_spdu_ie_so);
				uchar   r_spdu_ie_so_check_mandatory    (struct spdu_ie_so  *p_spdu_ie_so);
					- p_spdu_ie_so : pointer on the SO IE list of the SPDU.

Return value :  OK or NOK if fatal error encountered.

Common constants and declarations : ns.h

Common objects : internal IE and SPDU current context
				 ie_codeset is the current codeset.

*--------------------------------------------------------------------------*/

uchar r_spdu_ie_so (p_spdu_ie_so)
	struct spdu_ie_so   *p_spdu_ie_so;          /* pointer on the IE SO model */
{
	uchar                so_ie_id;				/* internal IE IDentifier */
	uchar	FAR			*save_p_ie;				/* saved p_ie pointer */
	uchar				 ie_type;				/* IE type (MD,OP,EX) */

		/* 2 types of single-octet IEs :
		 *	- Type 1 : IE ID is given with bits 5, 6 and 7 that are different
		 *	from 010 (IE_ID_SO) -> we represent the IE ID with octet value
		 *	0 B7 B6 B5 0 0 0 where Bi is the value of bit number i,
		 *
		 *	- Type 2 : IE ID is given with bits 1 to 7 -> the same value is
		 *	used to represent these IE IDs.
		 *
		 *	Both types are distinguished using bits 5, 6 and 7 (So_ie_1_id)
		 *	and so_ie_id contains the representation of the IE ID.
		 */

	so_ie_id = (So_ie_1_id == IE_ID_SO) ? So_ie_2_id : ((*p_ie) & 0x70);

	if (p_spdu_ie_so == A_NIL) {

		if (error_set (ERR_N_IE_UNKNOWN, so_ie_id, ie_codeset + CODESET_SO) == FATAL) {
			return (NOK);

		} else {

			return (OK);
		}

	}

	for (;M_so_ie_id != IE_NIL; p_spdu_ie_so++) {

		if (Received_from_d_channel (M_so_ie_u_n, M_so_ie_n_u)) {

			if ((M_so_ie_id == so_ie_id) && (M_so_ie_codeset == ie_codeset)) {

            		/* get IE type and if it is EXcluded process it as unknown */

				ie_type = Ie_type (spdu_id, so_ie_id, M_so_ie_type);

				if (ie_type == EX) {

                	break;
                }

					/* Process ie_id content only if it is a Type 1 IE (Type 2 IEs have no content) */

				if (So_ie_1_id != IE_ID_SO) {

					ie_implicit_val_x (ie_codeset + CODESET_SO, so_ie_id, 0);
					p_ie_end = p_ie + 1;
					save_p_ie = p_ie;

					if (exec_spdu_ie (ie_codeset + CODESET_SO, so_ie_id, 0) != OK) {

						if (error_set ((uchar)((ie_type == MD) ? ERR_N_IE_M_CONTENT : ERR_N_IE_O_CONTENT), so_ie_id, ie_codeset + CODESET_SO) == FATAL) {

							return (NOK);
						}
					}

						/* restore p_ie pointer */

					p_ie = save_p_ie;
				}

					/* add ie_id to the internal list */

				set_ie_i (ie_codeset + CODESET_SO, so_ie_id);
				return (OK);

			} /* (IE ID = Model ID) && (IE codeset = Model codeset) */

		} /* Received from D Channel */
	}

	if (error_set (ERR_N_IE_UNKNOWN, so_ie_id, ie_codeset + CODESET_SO) == FATAL) {
		return (NOK);

	} else {

		return (OK);
	}

}

/*-------------------------------------------------------------------------*/

uchar r_spdu_ie_so_check_mandatory (p_spdu_ie_so)
	struct spdu_ie_so   *p_spdu_ie_so;          /* pointer on the IE SO model */
{

	if (p_spdu_ie_so != A_NIL) {

		for (;M_so_ie_id != IE_NIL; p_spdu_ie_so++) {

			if (Received_from_d_channel (M_so_ie_u_n, M_so_ie_n_u)) {

					/* Check the mandatory SPDU IE presence in the IE internal list */

				if ((Ie_type (spdu_id, M_so_ie_id, M_so_ie_type) == MD) &&
					(is_ie_i (M_so_ie_codeset + CODESET_SO, M_so_ie_id) == ABSENT)) {

					if (error_set (ERR_N_IE_M_MISSING, M_so_ie_id, M_so_ie_codeset + CODESET_SO) == FATAL) {
						return (NOK);
					}

				} /* if Mandatory and Absent */

			} /* Received from D Channel */
		}
	}

	return (OK);
}

/*-------------------------------------------------------------------------*/

uchar s_spdu_ie_so (p_spdu_ie_so, next_codeset)
	struct spdu_ie_so   *p_spdu_ie_so;  /* pointer on the IE SO model */
	uchar				next_codeset;	/* codeset of next variable-length IE to be sent */
{
	uchar               presence;       /* IE presence indicator */

		/*
		   Scan the IE SO list and if the direction is user to network
		   create the IE field in the message area (p_ie) if the
		   internal IE structure is loaded.
		*/

	if (p_spdu_ie_so != A_NIL) {

		for ( ; M_so_ie_id != IE_NIL; p_spdu_ie_so++) {

			/*	codeset filtering : process all the single-octet IEs
				that belong to codeset greater or equal than current one
				and inferior to next codeset (if not NIL) */

			if ((M_so_ie_codeset >= ie_codeset) &&
				(M_so_ie_codeset < next_codeset)) {

					/* IE needed for the direction */

				if (Sent_to_d_channel (M_so_ie_u_n, M_so_ie_n_u)) {

						/*
							Is the internal corresponding IE structure on
							or is the IE mandatory ?
						*/

					if (((presence = is_ie_i (M_so_ie_codeset + CODESET_SO, M_so_ie_id)) == PRESENT) ||
						(Ie_type (spdu_id, M_so_ie_id, M_so_ie_type) == MD)) {

							/*
							   Generate the ie - is the codeset not equal
							   to the previous one ?
							   if so, create a single octet SHIFT element.
							*/

						if (M_so_ie_codeset != ie_codeset) {

							if (Spdu_param_ie_non_locking_shift == ON) {

									/*
									   non-locking shift allowed :
									   just load a non-locking shift in the message.
									*/

								So_ie_1_load (M_so_ie_codeset, NON_LOCKING_SHIFT, SHIFT, IE_FORMAT_SO);

							} else {
									/*
									   non-locking shift not allowed :
									   set the new codeset implicit value
									   and load a locking shift in the message.
									*/

								ie_codeset = M_so_ie_codeset;
								So_ie_1_load (M_so_ie_codeset, LOCKING_SHIFT, SHIFT, IE_FORMAT_SO);
							}

							p_ie++;
						}

						So_ie_2_load (M_so_ie_id, IE_FORMAT_SO);

						if (Get_bits ((M_so_ie_id), 4, 3) != IE_ID_SO) {

							/* it is a Type 1 IE : process its content */

							if (presence == ABSENT) {
								ie_implicit_val_x (M_so_ie_codeset + CODESET_SO, M_so_ie_id, 0);
							}

								/* p_ie shall be incremented in exec function
									to skip the length -> decrement it before */

							p_ie--;

							if (exec_spdu_ie (M_so_ie_codeset + CODESET_SO, M_so_ie_id, 0) != OK) {

								return (NOK);
							}

						} else {

							Inc_p_ie (1);
						}
					}

				} /* End if (Sent_to_d_channel) */

			}   /* End codeset filtering */

		}   /* End for IE SO table */

	}   /* End if (SO in model) */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_build_spdu_table - init of NS network table.

Usage            	void ns_build_spdu_table ();

Return value :		void

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

void ns_build_spdu_table ()

{

#if F_AT4 == ON
	if (at4 != NIL) {
		tab_spdu			[at4] 	= (struct spdu *)			&AT4_TAB_SPDU;
		tab_spdu_param		[at4] 	= (struct spdu_param *)		&AT4_SPDU_PARAM;
		tab_net_proc_param	[at4] 	= (struct net_proc_param *)	&AT4_NET_PROC_PARAM;
	}
#endif

#if F_AT5 == ON
	if (at5 != NIL) {
		tab_spdu			[at5] 	= (struct spdu *)			&AT5_TAB_SPDU;
		tab_spdu_param		[at5] 	= (struct spdu_param *)		&AT5_SPDU_PARAM;
		tab_net_proc_param	[at5] 	= (struct net_proc_param *)	&AT5_NET_PROC_PARAM;
	}
#endif

#if F_AT9 == ON
	if (at9 != NIL) {
		tab_spdu			[at9] 	= (struct spdu *)			&AT9_TAB_SPDU;
		tab_spdu_param		[at9] 	= (struct spdu_param *)		&AT9_SPDU_PARAM;
		tab_net_proc_param	[at9] 	= (struct net_proc_param *)	&AT9_NET_PROC_PARAM;
	}
#endif

#if F_BIP == ON
	if (bip != NIL) {
		tab_spdu			[bip] 	= (struct spdu *)			&BIP_TAB_SPDU;
		tab_spdu_param		[bip] 	= (struct spdu_param *)		&BIP_SPDU_PARAM;
		tab_net_proc_param	[bip] 	= (struct net_proc_param *)	&BIP_NET_PROC_PARAM;
	}
#endif

#if F_AU1 == ON
	if (au1 != NIL) {
		tab_spdu			[au1] 	= (struct spdu *)			&AU1_TAB_SPDU;
		tab_spdu_param		[au1] 	= (struct spdu_param *)		&AU1_SPDU_PARAM;
		tab_net_proc_param	[au1] 	= (struct net_proc_param *)	&AU1_NET_PROC_PARAM;
	}
#endif

#if F_BT2 == ON
	if (bt2 != NIL) {
		tab_spdu			[bt2] 	= (struct spdu *)			&BT2_TAB_SPDU;
		tab_spdu_param		[bt2] 	= (struct spdu_param *)		&BT2_SPDU_PARAM;
		tab_net_proc_param	[bt2] 	= (struct net_proc_param *)	&BT2_NET_PROC_PARAM;
	}
#endif

#if F_BV1 == ON
	if (bv1 != NIL) {
		tab_spdu			[bv1] 	= (struct spdu *)			&BV1_TAB_SPDU;
		tab_spdu_param		[bv1] 	= (struct spdu_param *)		&BV1_SPDU_PARAM;
		tab_net_proc_param	[bv1] 	= (struct net_proc_param *)	&BV1_NET_PROC_PARAM;
	}
#endif

#if F_DMS == ON
	if (dms != NIL) {
		tab_spdu			[dms] 	= (struct spdu *)			&DMS_TAB_SPDU;
		tab_spdu_param		[dms] 	= (struct spdu_param *)		&DMS_SPDU_PARAM;
		tab_net_proc_param	[dms] 	= (struct net_proc_param *)	&DMS_NET_PROC_PARAM;
	}
#endif

#if F_ETS == ON
	if (ets != NIL) {
		tab_spdu			[ets] 	= (struct spdu *)			&ETS_TAB_SPDU;
		tab_spdu_param		[ets] 	= (struct spdu_param *)		&ETS_SPDU_PARAM;
		tab_net_proc_param	[ets] 	= (struct net_proc_param *)	&ETS_NET_PROC_PARAM;
	}
#endif

#if F_A17 == ON
	if (a17 != NIL) {
		tab_spdu			[a17] 	= (struct spdu *)			&A17_TAB_SPDU;
		tab_spdu_param		[a17] 	= (struct spdu_param *)		&A17_SPDU_PARAM;
		tab_net_proc_param	[a17] 	= (struct net_proc_param *)	&A17_NET_PROC_PARAM;
	}
#endif

#if F_A11 == ON
	if (a11 != NIL) {
		tab_spdu			[a11] 	= (struct spdu *)			&A11_TAB_SPDU;
		tab_spdu_param		[a11] 	= (struct spdu_param *)		&A11_SPDU_PARAM;
		tab_net_proc_param	[a11] 	= (struct net_proc_param *)	&A11_NET_PROC_PARAM;
	}
#endif

#if F_E10 == ON
	if (e10 != NIL) {
		tab_spdu			[e10] 	= (struct spdu *)			&E10_TAB_SPDU;
		tab_spdu_param		[e10] 	= (struct spdu_param *)		&E10_SPDU_PARAM;
		tab_net_proc_param	[e10] 	= (struct net_proc_param *)	&E10_NET_PROC_PARAM;
	}
#endif

#if F_KDD == ON
	if (kdd != NIL) {
		tab_spdu			[kdd] 	= (struct spdu *)			&KDD_TAB_SPDU;
		tab_spdu_param		[kdd] 	= (struct spdu_param *)		&KDD_SPDU_PARAM;
		tab_net_proc_param	[kdd] 	= (struct net_proc_param *)	&KDD_NET_PROC_PARAM;
	}
#endif

#if F_NI1 == ON
	if (ni1 != NIL) {
		tab_spdu			[ni1] 	= (struct spdu *)			&NI1_TAB_SPDU;
		tab_spdu_param		[ni1] 	= (struct spdu_param *)		&NI1_SPDU_PARAM;
		tab_net_proc_param	[ni1] 	= (struct net_proc_param *)	&NI1_NET_PROC_PARAM;
	}
#endif

#if F_NI2 == ON
	if (ni2 != NIL) {
		tab_spdu			[ni2] 	= (struct spdu *)			&NI2_TAB_SPDU;
		tab_spdu_param		[ni2] 	= (struct spdu_param *)		&NI2_SPDU_PARAM;
		tab_net_proc_param	[ni2] 	= (struct net_proc_param *)	&NI2_NET_PROC_PARAM;
	}
#endif

#if F_NTT == ON
	if (ntt != NIL) {
		tab_spdu			[ntt] 	= (struct spdu *)			&NTT_TAB_SPDU;
		tab_spdu_param		[ntt] 	= (struct spdu_param *)		&NTT_SPDU_PARAM;
		tab_net_proc_param	[ntt] 	= (struct net_proc_param *)	&NTT_NET_PROC_PARAM;
	}
#endif

#if F_SWD == ON
	if (swd != NIL) {
		tab_spdu			[swd] 	= (struct spdu *)			&SWD_TAB_SPDU;
		tab_spdu_param		[swd] 	= (struct spdu_param *)		&SWD_SPDU_PARAM;
		tab_net_proc_param	[swd] 	= (struct net_proc_param *)	&SWD_NET_PROC_PARAM;
	}
#endif

#if F_TR6 == ON
	if (tr6 != NIL) {
		tab_spdu			[tr6] 	= (struct spdu *)			&TR6_TAB_SPDU;
		tab_spdu_param		[tr6] 	= (struct spdu_param *)		&TR6_SPDU_PARAM;
		tab_net_proc_param	[tr6] 	= (struct net_proc_param *)	&TR6_NET_PROC_PARAM;
	}
#endif

#if F_VN2 == ON
	if (vn2 != NIL) {
		tab_spdu			[vn2] 	= (struct spdu *)			&VN2_TAB_SPDU;
		tab_spdu_param		[vn2] 	= (struct spdu_param *)		&VN2_SPDU_PARAM;
		tab_net_proc_param	[vn2] 	= (struct net_proc_param *)	&VN2_NET_PROC_PARAM;
	}
#endif

#if F_VN3 == ON
	if (vn3 != NIL) {
		tab_spdu			[vn3] 	= (struct spdu *)			&VN3_TAB_SPDU;
		tab_spdu_param		[vn3] 	= (struct spdu_param *)		&VN3_SPDU_PARAM;
		tab_net_proc_param	[vn3] 	= (struct net_proc_param *)	&VN3_NET_PROC_PARAM;
	}
#endif

#if F_VN6 == ON
	if (vn6 != NIL) {
		tab_spdu			[vn6] 	= (struct spdu *)			&VN6_TAB_SPDU;
		tab_spdu_param		[vn6] 	= (struct spdu_param *)		&VN6_SPDU_PARAM;
		tab_net_proc_param	[vn6] 	= (struct net_proc_param *)	&VN6_NET_PROC_PARAM;
	}
#endif

#if F_QSI == ON
	if (qsi != NIL) {
		tab_spdu			[qsi] 	= (struct spdu *)			&QSI_TAB_SPDU;
		tab_spdu_param		[qsi] 	= (struct spdu_param *)		&QSI_SPDU_PARAM;
		tab_net_proc_param	[qsi] 	= (struct net_proc_param *)	&QSI_NET_PROC_PARAM;
	}
#endif

#if F_HKT == ON
	if (hkt != NIL) {
		tab_spdu			[hkt] 	= (struct spdu *)			&HKT_TAB_SPDU;
		tab_spdu_param		[hkt] 	= (struct spdu_param *)		&HKT_SPDU_PARAM;
		tab_net_proc_param	[hkt] 	= (struct net_proc_param *)	&HKT_NET_PROC_PARAM;
	}
#endif

}


/*EOF*/
