
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_proc.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		allocate_call_ref,
 *		remove_call_ref		- implements the allocation and removal of a
 *								call-reference.
 *
 *		allocate_call,
 *		call_clear			- implement the allocation and release of a call
 *								context.
 *
 *		ns_init_timer,
 *		ns_release_call_timers,
 *		ns_release_dlci_timers	- implement the allocation and liberation of
 *                              the timer resources needed by a call/DLCI.
 *
 *		ns_stop_all_timers		- stops all the active timer of a call.
 *
 *		ns_stop_all_dlci_timers	- stops all the active timer associated with DLCI
 *								except the internal DL timer.
 *
 *		ns_unexpected_ev	- implements the processing of an unexpected event.
 *
 *		ns_action_to_cc, ns_action_to_dl - implements the centralized
 *							  processing of the NS automaton.
 *
 *		go_to_state_19      - implements the default actions to be taken in
 *						      order to reach the state 19.
 *
 *		ns_in_queue,
 *		ns_out_queue,
 *		ns_discard_queue	- are functions which manages the message queues
 *								of a network access context (NS).
 *
 *		find_tabl			- implements the search of a field value in a list
 *								of octet constants called a table.
 *
 *		find_tabx			- implements the search of a field value in a set
 *								of tables selected according to their first
 *								value.
 *
 *		check_convert		- implements the checking and the conversion
 *								of an array of octet according to a code an
 *								a restriction condition.
 *
 *		check_ie			- implements the checking of the validity of an
 *								IE ID.
 *
 *		ie_implicit_val		- init an internal structure with its implicit
 *								values.
 *
 *		reset_multi_point_context,
 *		release_alerting,
 *		test_alerting		- implement the processing the multipoint
 *								information.
 *
 *		save_ie_cause,
 *		load_ie_cause,
 *		save_ie_uui,
 *		load_ie_uui,
 *		save_ie_spf_fac,
 *		load_spf_fac		- implements the storage and reloading of IE data
 *								context for multipoint processing.
 *
 *		i_call_ref_load and spdu_call_ref_load - implements the call
 *		reference extraction from a SPDU and the call reference
 *		loading in a SPDU to and from the internal call reference
 *		value i_call_reference.
 *
 *      ns_send_mns_event - implements the building and sending of
 *		an event message to MNS.
 *
 *      ns_send_mns_status - implements the building and sending of
 *		a status message to MNS.
 *
 *      ns_send_mns_service - implements the building and sending of
 *		a SERVICE message to MNS.
 *
 *		ns_send_mns_restart - implements the building and sending of
 *				a restart confirmation message to MNS.
 *
 *		disc_cause_error - set the cause #100 or #96 in the RELEASE message
 *		that was previously received in a DISCONNECT msg.
 *
 *		ns_save_call_cause - save the cause IE with the diagnostic inside
 *		the call context to be able to send the same cause.
 *
 *		ns_save_context - NS saves the current context because
 *						a congestion occured.
 *
 *		ns_get_network - from the operator and the country,
 *		returns the according network.
 *
 *		ns_get_net_idx - get index for current network.
 *
 *		ns_check_network - check network operator consistancy
 *
 *		ns_build_net_table - init of NS network table.
 *
 *		ns_reset_op_idx  - reset the operator indexes.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "ns.h"
#include "isdn.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#include "ctx_ext.h"

uchar error_type;		/* current error type */

#if (NS_MAINTENANCE_CAPABILITY == ON)

	extern	uchar	ie_end_found;					/* end of IE flag */
	extern 	uchar	ie_optional_octet;  			/* ON = optional octet group */

#	if NEW_FCT_STYLE == ON
		uchar 	r_exec_spdu_ie		(uchar *p_pc);
#	else
		uchar 	r_exec_spdu_ie		();
#	endif

#endif

/*--------------------------------------------------------------------------*
				 L O C A L   F U N C T I O N   P R O T O T Y P E S
*--------------------------------------------------------------------------*/

#if EQUIPMENT == NT2
	void	release_call_int_timer	(Void_parm);
	uchar	alloc_int_process		(Void_parm);
	uchar	find_int_timer 			(Void_parm);
#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            allocate_call_ref and remove_call_ref - implements the
				allocation of a new call reference and the removal of
				a previously allocated call-reference.

Usage           call_ref_t allocate_call_ref ();

Description     allocate_call_ref implements the allocation of a new call-
				reference to a new call.
				The new call-reference is obtained by incrementing the
				call-reference base of the network access context and then
				searching if it is already used. If so retry one more.
				this method must always converged.

Return value    allocate_call_ref returns a new allocated call_ref.
				remove_call_ref  returns void.

Common constants and declarations : ns.h

Common objects  NA current context

*--------------------------------------------------------------------------*/

call_ref_t allocate_call_ref ()
{
	call_ref_t           call_reference;	/* temporary alocated call-ref */
	struct  call 	FAR	*sav_p_call;        /* save call current pointer */

#	if NS_MAINTENANCE_CAPABILITY == ON

		struct  nsna 	FAR	*p_nsna_sav;        /* save call current pointer */

		if (ns_nfas == ON) {

				/*
				 * The call reference must be computed using the
				 * contexts of the Na which was designated at config
				 * time to bear the Active D channel.
				 * This must be done to avoid duplicated call ref between
				 * that Na and a Backup recently moved to the Active
				 * state.
				 */

			p_nsna_sav	= p_nsna;

			if (Nai != Nfas_cfg_nai_active_d_chan) {

					/*
					 * Here is the case when the Backup Na
					 * has become the Active Na.
					 */

				p_nsna	= Nfas_nai_p_active_d_chan;
			}
		}

#	endif

		/* Loop until new call-reference is allocated */

	for ( ; ; ) {

			/* Calculate a new call reference value */

		do {

			Call_ref_nber_next ();

				/* Load call reference base from NA according to rate interface */

			if (Na_type == BRI) {
				call_reference = Call_ref_nber & Mask ((Spdu_param_call_ref_lgth_bri * 8));

			} else {

				call_reference = Call_ref_nber & Mask ((Spdu_param_call_ref_lgth_pri * 8));
			}

		} while (call_reference == CALL_REF_GLOBAL_VAL);

			/* Search a duplicate */

		sav_p_call = p_call;                        /* save current call pointer */

		if (ns_access_call_ref (call_reference) == NOK) {
			p_call = sav_p_call;

#			if NS_MAINTENANCE_CAPABILITY == ON

				if (ns_nfas == ON) {
					p_nsna = p_nsna_sav;
				}

#			endif

			return (call_reference);
		}

		p_call = sav_p_call;

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            allocate_call and call_clear - implement the call context
				management of the NS entity.

Usage           uchar allocate_call (uchar way, conn_id_t conn_id);
					- way     : Outgoing call, Incoming call,
					- conn_id : only for outgoing call.

				void call_clear (); release of a call context.

Related
functions usage call_ref_t allocate_call_ref (); allocate call-reference

Description     allocate_call for outgoing call scans the outgoing reserved
				call contexts and after the mixed contexts to match with the
				conn_id.

				allocate_call for incoming call scans the incoming call
				contexts and the mixed contexts to find a free context.

				the allocated context is then initialized :
					- timers are allocated to the call,
					- call_state to NULL,
					- call_reference is allocated if outgoing call,
					- call_count is incremented.

Return value    OK  : call is allocated,
				NOK : no call context, or allocation error.

Common constants and declarations ns.h

Common objects : call contexts

*--------------------------------------------------------------------------*/

uchar allocate_call (way, conn_id)
	uchar           way;            /* Incoming, Outgoing or Mixed call */
	conn_id_t       conn_id;        /* connection ID */
{
	int             call_nb;        /* number of call to process */
	uchar			initial_way;	/* initial 'way' value */

	initial_way = way;

	switch (way) {

		case OUTGOING_CALL :

			if (ns_access_conn_id (way, conn_id) == OK) {

				if (Call_state == STATE_NIL) {
					return (call_init (allocate_call_ref (), initial_way));

				} else {

					return (NOK);
				}

			}

			way = MIXED_CALL;

		case MIXED_CALL :

			if (ns_access_conn_id (way, conn_id) == OK) {

				if (Call_state == STATE_NIL) {
					return (call_init (allocate_call_ref (), initial_way));
				}

			}

			return (NOK);

		case INCOMING_CALL :

				/*
				   Incoming call : search for a free call context
				   first into the incoming context and then
				   into the mixed context.
				*/

			call_nb = Incoming_call_nb;
			Ns_access_first_incoming_call ();

			while (--call_nb >= 0) {

				if (Call_state == STATE_NIL) {      /* if the context is free allocate it */

					if (call_init (I_call_ref, initial_way) == NOK) {
						p_call = P_NIL;
						return (NOK);
					}

					return (OK);
				}

				ns_access_next_call ();
			}

				/*
					Incoming call context saturation  --->
					try into mixed call contexts using the prior thread.
				*/

			call_nb = Mixed_call_nb;
			Ns_access_last_mixed_call ();

			while (--call_nb >= 0) {

				if (Call_state == STATE_NIL) {      /* free ? */

					if (call_init (I_call_ref, initial_way) == OK) {
						return (OK);
					}

					break;
				}

				ns_access_prior_call ();
			}

				/* Incoming and mixed resource saturation */

			p_call = P_NIL;
			return (NOK);

	}

	return (OK);

}

/*--------------------------------------------------------------------------*/

uchar call_init (call_ref, call_way)
	call_ref_t      call_ref;           	/* call reference value */
	uchar			call_way;				/* call way (Outgoing/Incoming) */
{

	if (ns_init_timer () == NOK) {
		p_call		= P_NIL;
		error_type  = ERR_U_NO_TIMER_AVAILABLE;
		return (NOK);                       /* timer saturation --> reject the call */
	}

		/* OK enter the NULL state */

	Call_state              = STATE_NULL_0;
	Call_sub_state          = SUB_STATE_NULL_0;

#	if NS_HOLD_RETRIEVE == ON
		Call_hold_aux_state	= NS_AUX_STATE_IDLE;		
#	endif

		/* Init call-reference and insert in the access table */

	Call_ref                = call_ref;

#	if OPTIMIZATION == SPEED
		call_ref_insert (call_ref, p_call);
#	endif

		/*
			Register the upper entity id.
			Default for incoming calls is ENT_CC.
		*/

	Call_upper_ent			= (call_way == OUTGOING_CALL) ? R_msg_from : ENT_CC;

	if (call_way == OUTGOING_CALL) {
		Call_ref_lgth = ((Na_type == BRI) ? Spdu_param_call_ref_lgth_bri : Spdu_param_call_ref_lgth_pri);
	}

	if (call_way == INCOMING_CALL) {
		Call_ref_lgth = I_call_ref_lgth;
	}

		/* Reset the call flags */

	Call_fac_rq             = OFF;
	Call_rel_flag           = OFF;
	Call_keypad_in_setup    = OFF;

	Call_disc_m_ie_error    = ERR_NIL;
	Call_progress_descr     = 0;
		/* Set to ON the UUI and USER FACILITY flags */

	Call_uui_rq				= ON;
	Call_user_fac_rq		= ON;

		/* Reset retry counter */

	Rc						= 0;

		/* Init chan_id selection flag */

	Call_chan_id_sel		= BYTE_VAL_NIL;

		/* Init Data link CES */

#   if EQUIPMENT == TE

		if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
			Trap (TRAP_NO_CES, "call_init");
		}

		Call_ces			= Na_dl_ces;
		Dl_call_count++;

#   else

		if ((Na_connection == POINT_TO_MULTIPOINT) && (Na_fct == FG_NT_TE)) {

				/* DL context already accessed for incoming calls */

			if (call_way != INCOMING_CALL) {

				if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
					Trap (TRAP_NO_CES, "call_init");
				}

				Set_int_ces_state (STATE_0_I);
				Call_ces        = DL_CES_NIL;
			}

		} else {

			if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
				Trap (TRAP_NO_CES, "call_init");
			}

			Call_ces        = Na_dl_ces;
			Dl_call_count++;
		}

		Call_ces_connect = NIL;

#   endif

#	if NS_EVENT_REPORT == ON

			/* Send the event to MNS */

		ns_send_mns_event (NS_EVENT_CALL_SETUP, 0);

#	endif

		/* Return  OK */

	return (OK);

}

/*-------------------------------------------------------------------------*/

void call_clear ()
{
	if (Call_current_exist) {

#		if NS_EVENT_REPORT == ON

				/* Send the event to MNS */

			ns_send_mns_event (NS_EVENT_CALL_RELEASE, 0);

#		endif

		   /*
			  - release the current save SPDU if any,
			  - release the call-reference,
			  - release the timer,
			  - set the call state to STATE_NIL,
			  - decrement the call count, if no more
				call and if Basic Rate Interface release
				the Data Link.
		   */

		Release_saved_spdu ();

#   	if OPTIMIZATION == SPEED
			call_ref_remove ();
#   	endif

			/* Release all the CALL timers */

		ns_release_call_timers ();

			/* Decrement the DL call counter */

		if (Dl_current_exist) {

			Dl_button_internal = OFF;
			Dl_button_user 	   = 0;

			if (Dl_button_p_call  != P_NIL) {
				Dl_button_p_call   = P_NIL;
			}

#           if EQUIPMENT == TE

					/* If waiting for DL remove from the queue */

				if (Call_state == STATE_WAIT_DL) {
					ns_remove_queue_cc (Call_conn_id);
				}

				if (Dl_call_count > 0) {
					--Dl_call_count;
				}

#           else

				if (Call_ces != DL_CES_NIL) {

					if (Dl_call_count > 0) {
						--Dl_call_count;
					}

				}

				if (Net_param_internal_timers == ON) {
					release_call_int_timer ();
				}

#           endif

				/* Start the DL TIMER */

			ns_dl_timer_activity ();
		}

			/* Null state */

		Call_state  = STATE_NIL;

#		if NS_MAINTENANCE_CAPABILITY == ON

			if (ns_nfas == ON) {
				nfas_remove ();
			}

#		endif

		p_call      = P_NIL;

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_init_timer and ns_release_call_timers - implement the allocation
				and liberation of the timer resources needed by a call.

				ns_stop_all_timers		- stops all the active timers of a call.
				ns_stop_all_dlci_timers	- stops all the active timers associated
										with DLCI.

Usage           uchar	ns_init_timer			();
				void	ns_release_call_timers  ();
				void	ns_release_dlci_timers	();
				void	ns_stop_all_timers		();
				void	ns_stop_all_dlci_timers	();


Related
functions usage uchar FAR *Timer_alloc (nai_t nai, sapi_t sapi,
										conn_id_t conn_id, timer_index);

				void Timer_free (uchar timer_index);

Description     ns_init_timer implements the allocation of timer resources
				to a call and initialized the current values of the timer
				and of the current call context.

				ns_release_call_timers implements the release of the timer resources
				previously allocated.

Return value    ns_init_timer returns = OK  no saturation
								   = NOK timer resource saturation

Common constants and declarations : ns.h

Common objects  : call current context

*--------------------------------------------------------------------------*/

#if OPTIMIZATION != SPEED

void ns_start_timer (timer_x)
	uchar	timer_x;
{
	Start_call_timer (timer_x);
}

void ns_restart_timer (timer_x)
	uchar	timer_x;
{
	Start_call_timer (timer_x);
}

void ns_stop_timer (timer_x)
	uchar	timer_x;
{
	Stop_call_timer (timer_x);
}

#endif

/*-------------------------------------------------------------------------*/

uchar ns_init_timer ()
{
	uchar   i; /* timer index */

		/*
		  For all the timer needed by a call :
			- allocate a timer cell and store its value into the call context,
			- set state to OFF into the call context,
			- init the sequence number of the call context;
		*/

	for (i = 0; i < NB_CALL_TIMER; i++) {

		if ((Ti_id (i) = Timer_alloc (ENT_NS, Nai, 0, Call_conn_id)) == TIMER_ID_NIL) {

				/*
					Saturation :
					- release the previously allocated timer cell,
					- return NOK.
				*/

			ns_release_call_timers ();

			return (NOK);
		}

		Ti_state (i) = OFF;         /* timer state = OFF */
		Ti_sn (i)    = 0;           /* init sequence number */

		/* Initialise the timer id for timers which may run simulteanously */

		Ti_idx (i) = MX_CALL_TIMER;
	}

	return (OK);

}

/*-------------------------------------------------------------------------*/

void ns_release_call_timers ()
{
	uchar   i;  /* index */

	for (i = 0; i < NB_CALL_TIMER; i++) {

		if (Ti_id (i) != TIMER_ID_NIL) {

			if (Ti_state (i) == ON) {
				Stop_timer_ns (Ti_idx (i));
			}

			Timer_free (Ti_id (i));
			Ti_id (i) = TIMER_ID_NIL;
		}

	}

}

/*-------------------------------------------------------------------------*/

void ns_release_dlci_timers ()
{
	uchar i;

	for (i = 0; i < MX_DLCI_TIMER; i++) {

		Timer_free (Dl_timer_id (i));
		Dl_timer_id (i) = TIMER_ID_NIL;
	}

}

/*-------------------------------------------------------------------------*/

void ns_stop_all_timers ()
{
	uchar i;	/* index */

	for (i = 0; i < NB_CALL_TIMER; i++) {

		if (Ti_state (i) == ON) {
			Stop_timer_ns (Ti_idx (i));
		}

	}

}

/*-------------------------------------------------------------------------*/

void ns_stop_all_dlci_timers ()
{
	uchar i = 1;	/* index */

	while (i < MX_DLCI_TIMER) {

		if (State_dl_timer (i) == ON) {
			Stop_dl_timer (i);
		}

		i++;
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_unexpected_ev - implements the processing of an
				unexpected event received in any state into the NS entity.

Usage           void ns_unexpected_ev ();

Description     call the error condition handler with the error cause.

Return value    returns void

common constants and declarations : ns.h

*--------------------------------------------------------------------------*/

void ns_unexpected_ev ()
{

	switch (R_msg_from) {

		case ENT_DL_D :
		case ENT_DL :
			error_set (ERR_N_SPDU_UNEXPECTED, spdu_id, 0);
			break;

		case ENT_TI :
			Trap (TRAP_NS_ERROR,"Timer expiry not implemented");
			break;

		default :
			error_set (ERR_U_SSDU_UNEXPECTED, R_msg_code, 0);
			break;
	}

	ns_sort_error_stack ();

	Error_handler ();
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_action_to_cc -
				ns_action_to_dl - implements the centralized processing
					of the NS automaton.

Usage			void ns_action_to_cc (stop_ti, start_ti, event, new_state);
				void ns_action_to_dl (stop_ti, start_ti, event, new_state);

Description
				uchar	stop_ti;	NS timer to be stopped
				uchar	start_ti;	NS timer to be started
				uchar	event;		Event to be sent
				uchar	new_state;	New state after action process.

Common constants and declarations   : ns.h

Common objects : call current context

*--------------------------------------------------------------------------*/

void ns_action_to_cc (stop_ti, start_ti, event, new_state)
	uchar	stop_ti;
	uchar	start_ti;
	uchar	event;
	uchar	new_state;
{

	if (stop_ti != T3_NIL)	{
		Stop_timer_ns	(stop_ti);
	}

	Send_to_call_control (event);

	if (start_ti != T3_NIL)	{
		Start_timer_ns	(start_ti);
	}

	Set_state (new_state);
}

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

void ns_action_to_dl (stop_ti, start_ti, event, new_state)
	uchar	stop_ti;
	uchar	start_ti;
	uchar	event;
	uchar	new_state;
{

	if (stop_ti != T3_NIL)	{
		Stop_timer_ns	(stop_ti);

	}

	Send_to_d_channel (event);

	if (start_ti != T3_NIL)	{
		Start_timer_ns	(start_ti);
	}

	Set_state (new_state);
}

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

void go_to_state_19 (start_ti)
	uchar	start_ti;
{
	N308 = 0;
	Start_timer_ns (start_ti);
	Release_saved_spdu ();
	Send_to_d_channel_and_save_spdu (REL);
	Set_state (STATE_RELEASE_REQUEST_19);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_in_queue_xx, ns_out_queue_xx, ns_discard_queue_xx,
				are functions which manages the message queues of a
				network access context (NS) awaiting for the DL
				establishment.

					xx = cc incoming SSDU queue,
					xx = dl outgoing DL_DA_RQ queue.

Usage           void    ns_in_queue_xx      ();
				uchar   out_queue_xx        ();
				void    discard_queue_xx    ();

				If xx == dl the p_snd_msg common pointer is used to manipulate the
				message address.

				If xx == cc the p_rcv_msg common pointer is used to manipulate the
				message address.

Description     The queues are organized by network accesses as
				follow :

				  na                      prior
				na_first <---> message <----> message <---> .... <---> message.
									 next                            Œ
																	 |
				na_last ----------------------------------------------

				Manipulations are :

					- adding an element at the end of the queue (in_queue).

					- accepting a message from the top of the queue (out_queue).

					- clearing the queue (discard_queue).

Common constants and declarations : ns.h

Common objects : na current context.

*--------------------------------------------------------------------------*/

void ns_in_queue_cc ()
{

	if (Dl_last_cc == P_NIL) {
		Next (p_rcv_msg)    = Prior (p_rcv_msg) = P_NIL;
		Dl_first_cc         = Dl_last_cc        = p_rcv_msg;

	} else {

		Next (p_rcv_msg)    = P_NIL;
		Prior (p_rcv_msg)   = Dl_last_cc;
		Next (Dl_last_cc)   = p_rcv_msg;
		Dl_last_cc          = p_rcv_msg;
	}

	p_rcv_msg = P_NIL;
}

/*-------------------------------------------------------------------------*/

uchar ns_out_queue_cc ()
{
	if ( (p_rcv_msg = Dl_first_cc) == P_NIL ) {
		return (NOK);
	}

	if (Next (Dl_first_cc) == P_NIL) {
		Dl_first_cc = Dl_last_cc = P_NIL;

	} else {

		Prior (Next (Dl_first_cc)) = P_NIL;
		Dl_first_cc = Next (p_rcv_msg);
	}

	return (OK);

}

/*-------------------------------------------------------------------------*/

void ns_discard_queue_cc ()
{
	struct message FAR *p_msg, FAR *p_old;  /* temporary message pointers */

	for (p_msg = Dl_first_cc; p_msg != P_NIL;) {
		p_old           = p_msg;
		p_msg           = Next (p_old);
		Free_msg        (p_old);
	}

	Dl_first_cc = Dl_last_cc = P_NIL;
}

/*-------------------------------------------------------------------------*/

void ns_remove_queue_cc (conn_id)
	conn_id_t   		conn_id;
{
	struct message FAR *p_msg, FAR *p_old, FAR *p_prior;    /* temporary message pointers */
	uchar               lib;                                /* liberation flag */

	for (p_msg = Dl_first_cc; p_msg != P_NIL;) {

		lib = (L_msg_conn_id == conn_id) ? ON : OFF;

		p_old   = p_msg;

		p_msg   = Next (p_old);
		p_prior = Prior (p_old);

		if (lib == ON) {

				/* Update the queue */

			if (p_prior == P_NIL) {
				Dl_first_cc		= p_msg;

			} else {

				Next (p_prior)	= p_msg;
			}

			if (p_msg == P_NIL) {
				Dl_last_cc = p_prior;

			} else {

				Prior (p_msg) = p_prior;
			}

			Free_msg (p_old);
		}

	}

}

/*-------------------------------------------------------------------------*/

void ns_in_queue_dl ()
{

	if (Dl_last_dl == P_NIL) {
		Next (p_snd_msg)    = Prior (p_snd_msg) = P_NIL;
		Dl_first_dl         = Dl_last_dl        = p_snd_msg;

	} else {

		Next (p_snd_msg)    = P_NIL;
		Prior (p_snd_msg)   = Dl_last_dl;
		Next (Dl_last_dl)   = p_snd_msg;
		Dl_last_dl          = p_snd_msg;
	}

	p_snd_msg = P_NIL;
}

/*-------------------------------------------------------------------------*/

uchar ns_out_queue_dl ()
{
	if ( (p_snd_msg = Dl_first_dl) == P_NIL ) {
		return (NOK);
	}

	if (Next (Dl_first_dl) == P_NIL) {
		Dl_first_dl = Dl_last_dl = P_NIL;

	} else {

		Prior (Next (Dl_first_dl)) = P_NIL;
		Dl_first_dl = Next (p_snd_msg);
	}

	return (OK);

}

/*-------------------------------------------------------------------------*/

void ns_discard_queue_dl ()
{
	struct message FAR *p_msg, FAR *p_old;  /* temporary message pointers */

	for (p_msg = Dl_first_dl; p_msg != P_NIL;) {
		p_old = p_msg;
		p_msg = Next (p_old);
		Free_msg (p_old);
	}

	Dl_first_dl = Dl_last_dl = P_NIL;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            find_tabl - implements the search of a field value in a list of
							octet constants called a table.

Usage           uchar find_tabl (uchar field, uchar tabl_id);
						- field   : field value to compare,
						- tabl_id : table ID.

Return value    returns = OK   found
						= NOK  not found

Common objects : tab_tabl

*--------------------------------------------------------------------------*/

uchar find_tabl (field, tabl_id)
	register uchar      field;          /* field value */
	register uchar      tabl_id;        /* table ID */

{
	register int        tabl_lgth;      /* table length */
	register uchar      *p_val;         /* pointer on the table of uchar contants */
	uchar               x_tab;          /* table index */

		/* Access to the table TABL_ITEM using tabl_id */

	if ((x_tab = Access_tab_tabl (Search_key_tab_tabl (tabl_id))) == X_TABL_NIL) {
		return (NOK);
	}

	if ((p_val = Tabl_p_list_val (x_tab)) == P_NIL) {
		Trap (TRAP_NO_TABLE_AVAILABLE, "find_tabl");
	}

		/* Scanning of the table of values until matching */

	tabl_lgth   = Tabl_size (x_tab);

	while (--tabl_lgth >= 0) {

		if (field == *p_val++) {
			return (OK);
		}

	}

	return (NOK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            find_tabx - implements the search of a field value in a set of
							tables selected according to their first value.

Usage           uchar find_tabx (uchar field, uchar tabl_id, uchar xval);
						- field   : field value to compare,
						- tabl_id : set table ID,
						- xval : octet used to select the table.

Return value    return  = OK   found
						= NOK  not found

Common objects : tab_tabx

*--------------------------------------------------------------------------*/

uchar find_tabx (field, tabl_id, x_val)
	register uchar       field;			/* value to search */
	register uchar       tabl_id;       /* set table ID */
	register uchar       x_val;         /* value used to select the table in the set */
{
	register int         tabx_lgth;     /* table length */
	register uchar      *p_val;         /* current pointer on the table constants */
	struct tabx_list    *p_list_tab;    /* pointer on the set table structure */
	uchar                x_tab;         /* table index */

		/* Access to the table TABX_ITEM using tabl_id */

	if ((x_tab = Access_tab_tabx (Search_key_tabx (tabl_id))) == X_TABX_NIL) {
		return (NOK);
	}

	if ((p_list_tab = Tabx_p_list_tab (x_tab)) == P_NIL) {
		Trap (TRAP_NO_TABLE_AVAILABLE, "find_tabx");
	}

		/* Scanning of the list of table value until x_val matching with the first value */

	tabx_lgth   = Tabx_size (x_tab);

	while (--tabx_lgth >= 0) {

			/* Scan the tabl header to find the valid table */

		if (x_val == *(p_val = p_list_tab -> p_val)) {

				/* OK - found, scan the table of values until field matching */

			tabx_lgth   = p_list_tab -> size;

			while (--tabx_lgth > 0) {

				if (field == *(++p_val)) {
					return (OK);
				}

			}

			return (NOK);

		}

		p_list_tab++;

	}

	return (NOK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            check_convert - implements the checking and the conversion
								of an array of octet according to a code an
								a restriction condition.

Usage           uchar check_convert (uchar uchar FAR *p_to, uchar FAR *p_from,
									 uint lgth, uchar code, uchar restriction);

						- p_to        : pointer on the destination area,
						- p_from      : pointer on the source area,
						- lgth        : length in octet of the area,
						- code        : alphabet code,
						- restriction : code of the restriction.

Related
functions usage Isdigit ();
				Isascii ();

Return value    returns = OK    valid
						= NOK   invalid

Common objects : direction

*--------------------------------------------------------------------------*/

	/* Text check and convert to ASCII if necessary */

uchar check_convert (p_to, p_from, lgth, code, restriction)
	register uchar 	FAR	*p_to;			/* destination pointer */
	register uchar 	FAR	*p_from;		/* origination pointer */
	register int		 lgth;			/* length of the area */
	uchar				 code;			/* alphabet code */
	register uchar		 restriction;	/* restriction code */
{
	register uchar		 charac;		/* current character */

#	if ASSERT == ON

		if ((p_from == P_NIL) || (p_to == P_NIL)) {
			return (NOK);
		}

#	endif

	switch (code) {

		case IA5 :

			while (--lgth  >= 0 ) {
				charac = *p_to++ = *p_from++;

				switch (restriction) {

					case DIGIT_E :

						if ((charac == D_STAR) || (charac == D_NUMBER)) {
							break;
						}

					case DIGIT :

						if (Isdigit (charac)) {
							break;
						}

						return (NOK);

					case ANY_CHAR :

						if (Isascii (charac)) {
							break;
						}

						return (NOK);

					default :
						break;

				}

			}

			if (direction == FROM_D_CHANNEL) {

					/* Set end of literal array ("C" convention) */

				*p_to = '\0';

			}

			break;

		case BINARY :
			Memcpy_far ((char FAR *)p_to, (char FAR *)p_from, lgth);
			break;

		case TABLE :

				/* checks according to a given table */

			while (--lgth  >= 0 ) {

				charac = *p_to++ = *p_from++;

					/* parameter 'restriction' contains the table id where
						are stored the valid values */

				if (find_tabl (charac, restriction) != OK)  {
					return (NOK);
				}

			}

				/* Set end of literal array */

			*p_to = '\0';
			break;

		default :
			break;

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            check_ie - implements the checking of the validity of an
						   IE ID.

Usage           check_ie (uchar codeset, uchar ie_id);
						- codeset : IE codeset,
						- ie_id   : IE ID.

Return value    returns = OK found
						= NOK not found

Common objects : ie

*--------------------------------------------------------------------------*/

uchar check_ie (v_codeset, v_ie_id)
	uchar   v_codeset;
	uchar   v_ie_id;
{

	if (Access_tab_ie (Search_key_ie (v_codeset, v_ie_id)) != X_IE_NIL) {
		return (OK);
	}

	return (NOK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ie_implicit_val - implements the loading of an IE internal
								  structure with its implicit values.

Usage           void ie_implicit_val (codeset, ie_id, repetition);
							- codeset   : codeset,
							- ie_id     : IE ID,
							- repetition: number of structures to initialize.

Related
functions usage void Memcpy_far (char FAR *to, char FAR *from, uint size);
				void Memset_far (char FAR *to, char c, uint size);

Return value    void

Common constants and declarations : ns.h

Common objects :    direction, ie_i table

*--------------------------------------------------------------------------*/

void ie_implicit_val (v_codeset, v_ie_id, repetition)
	uchar                   v_codeset;      /* codeset */
	uchar                   v_ie_id;        /* IE ID */
	uchar                   repetition;     /* number of the IE internal struture to initialize */
{
	uchar                   i;              /* ie_i index */

	for (i = 0; i < repetition; i++) {
		ie_implicit_val_x (v_codeset, v_ie_id, i);
	}

}

/*-------------------------------------------------------------------------*/

void ie_implicit_val_x (v_codeset, v_ie_id, x_ie)
	uchar                    v_codeset;		/* codeset */
	uchar                    v_ie_id;       /* IE ID */
	uchar                    x_ie;          /* range of the ie occurence to initialize */
{
	uchar                    i;             /* ie_i index */
	uchar                   *p_df;          /* pointer on the default structure */

		/*
			Initialize the IE internal structures with the implicit
			values :
				- search in the (codeset , IE ID ) in the ie table,
				- initialize the the internal structure if pointer to it non NIL,
				- if NIL set the internal data structure to NIL.
		*/

	if ((i = Access_tab_ie (Search_key_ie (v_codeset, v_ie_id))) != X_IE_NIL) {

			/* Check repetition count consistency */

		if (x_ie > Ie_mx_repetition(i)) {
			Trap (TRAP_MX_REPETITION, "ie_implicit_val_x");
		}

			/* Get default structure address and store it in p_df pointer */

		if (direction == FROM_D_CHANNEL) {
			p_df = Ie_p_init_spdu (i);

		} else {

			p_df = Ie_p_init_ssdu (i);
		}

		if ((p_df != A_NIL) && (Ie_p_i_struct (i) != A_NIL)) {

				/* Set implicit values */

			Memcpy_far ((char FAR *)(Ie_p_i_struct (i) + (Ie_i_size (i)) * x_ie), (char FAR *)p_df, Ie_i_size (i));

		} else {

				/* Set NULL values */

			Memset_far ((char FAR *)(Ie_p_i_struct (i) + (Ie_i_size (i)) * x_ie), VAL_NIL, Ie_i_size (i));
		}

	}

}

#if EQUIPMENT == NT2 /* { */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            reset_multi_point_context, release_alerting, test_alerting
				implement the processing the multipoint information.

Usage           void reset_multipoint_context ();

				void release_alerting (uchar ie_flag);
					- ie_flag : ON or OFF.

				uchar test_alerting ()

Return value :  test_alerting returns = OK  condition OK,
									  = NOK condition NOK.

Common constants and declarations : ns.h

Common objects : call context.

*--------------------------------------------------------------------------*/

void reset_multipoint_context ()
{
	register uchar  i;				/* index */

	Call_sub_state			= N6;
	Call_ces_cause			=
	Call_ces_uui			=

#	if NS_SPF_FACILITY == ON
		Call_ces_spf_fac	=
#   endif

	Call_ces_called_nb		=
	Call_ces_called_sub_add	=
	Call_ces_status			= DL_CES_NIL;

	for (i = 0; i < DL_MX_DLCEP; i++) {
		Call_alert(i) 			= OFF;
		Call_int_ces_state (i)	= STATE_0_I;
	}
}

/*-------------------------------------------------------------------------*/

void release_alerting (ie_flag)
	uchar       		ie_flag;	/* ON : use current cause, OFF : forced cause */
{
	register    uchar   i;          /* index */

		/* Cause forced ? */

	if (ie_flag == OFF) {
		Reset_internal_ie   ();
		set_i_cause         (C_C_NORMAL_EVENT, C_V_CALL_REJECT_21, P_NIL);
	}

		/* Send RELEASE to all not kept terminals */

	for (i = 0; i < DL_MX_DLCEP; i++) {

		if ((Call_alert (i) == ON) && (Ces_from_x (i) != Call_ces)) {
			Ns_access_dl_ces    (Ces_from_x(i));
			Send_to_d_channel   (REL);
		}

	}

}

/*-------------------------------------------------------------------------*/

uchar test_alerting ()
{
	register uchar  i;              /* index */
	uchar           nb = 0;         /* number of alert SPDU received */
	uchar           found = OFF;    /* found flag */

	for (i = 0; i < DL_MX_DLCEP; i++) {

		if (Call_alert(i) == ON) {
			nb++;

			if (Ces_from_x (i) == Dl_ces) {
				found = ON;
			}

		}

	}

	if ((nb == 1) && (found == ON)) {
		return (OK);

	} else {

		return (NOK);
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            save_ie_cause, load_ie_cause, save_ie_uui, load_ie_uui,
				save_ie_spf_fac, load_spf_fac - implements the storage
				and reloading of IE data context for multipoint processing.

Usage           void save_ie_cause  (void);
				void load_ie_cause  (void);
				void save_ie_uui    (void);
				void load_ie_uui    (void);
				void save_spf_fac   (void);
				void load_spf_fac   (void);

Description :   the IE internal data are stored and restored temporary in
				the ad hoc call reserved area (using a move).

Common constants and declarations : ns.h, ie_i_s.h

Common objects : call context, internal data structure.

*--------------------------------------------------------------------------*/

void save_ie_cause ()
{
	if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {
		Call_ces_cause = Dl_ces;
		Memcpy_far ((char FAR *)Call_a_cause, (char FAR *)i_cause, sizeof (struct i_cause));
	}
}

void load_ie_cause ()
{
	if (Call_ces_cause  != DL_CES_NIL) {
		Memcpy_far ((char FAR *)i_cause, (char FAR *)Call_a_cause, sizeof (struct i_cause));
		set_ie_i (CODESET_0, CAUSE);
	}
}

/*-------------------------------------------------------------------------*/

void save_ie_uui ()
{

	if (is_ie_i (CODESET_0, UUI) == PRESENT) {

		save_ie_cause ();

		Call_ces_uui = Dl_ces;
		Memcpy_far ((char FAR *)Call_a_uui, (char FAR *)i_uui, sizeof (struct i_uui));
		Memcpy_far ((char FAR *)Call_uui_p_info, (char FAR *)i_uui[0].p_info, i_uui[0].lgth);
	}

}

void load_ie_uui ()
{

	load_ie_cause ();

	if (Call_ces_uui  != DL_CES_NIL) {
		Memcpy_far ((char FAR *)i_uui, (char FAR *)Call_a_uui, sizeof (struct i_uui));
		i_uui[0].p_info = p_ind_buffer;
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)Call_a_uui_info, i_uui[0].lgth);
		set_ie_i (CODESET_0, UUI);
	}

}

#if NS_SPF_FACILITY == ON /* { */

	/*-------------------------------------------------------------------------*/

	void save_ie_spf_fac ()
	{

		if (is_ie_i (CODESET_0, SPF_FAC) == PRESENT) {
			Call_ces_spf_fac = Dl_ces;
			Memcpy_far ((char FAR *)Call_a_spf_fac, (char FAR *)i_spf_fac, sizeof (struct i_spf_fac));
		}

		if (is_ie_i (CODESET_0, CALLED_NB) == PRESENT) {
			Call_ces_called_nb = Dl_ces;
			Memcpy_far ((char FAR *)Call_a_called_nb, (char FAR *)i_called_nb, sizeof (struct i_called_nb));
		}

		if (is_ie_i (CODESET_0, CALLED_SUB_ADD) == PRESENT) {
			Call_ces_called_sub_add = Dl_ces;
			Memcpy_far ((char FAR *)Call_a_called_sub_add, (char FAR *)i_called_sub_add, sizeof (struct i_called_sub_add));
		}

	}

	/*-------------------------------------------------------------------------*/

	void load_ie_spf_fac ()
	{

		if (Call_ces_spf_fac  != DL_CES_NIL) {
			Memcpy_far ((char FAR *)i_spf_fac, (char FAR *)Call_a_spf_fac, sizeof (struct i_spf_fac));
			set_ie_i (CODESET_0, SPF_FAC);
		}

		if (Call_ces_called_nb  != DL_CES_NIL) {
			Memcpy_far ((char FAR *)i_called_nb, (char FAR *)Call_a_called_nb, sizeof (struct i_called_nb));
			set_ie_i (CODESET_0, CALLED_NB);
		}

		if (Call_ces_called_sub_add  != DL_CES_NIL) {
			Memcpy_far ((char FAR *)i_called_sub_add, (char FAR *)Call_a_called_sub_add, sizeof (struct i_called_sub_add));
			set_ie_i (CODESET_0, CALLED_SUB_ADD);
		}

	}

#endif		/* NS_SPF_FACILITY } */

#endif		/* EQUIMENT  == NT2 } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_dl_timer_activity ns_dl_timer_expiry - implements the
				management of the Data Link inactivity timer.

Usage           void ns_dl_timer_activity   (void);
				void ns_dl_timer_expiry     (void);

Description :   if the timer management is valid the ns_dl_timer_activity
				stop the timer and resart it if no call is established on
				the DL connection.

				If the timer expiry and no call is established on the DL
				connection the DL_COMMIT_RQ message is sent to DL. The
				DL_COMMIT_CO message will released the DL connection if
				necessary

Common constants and declarations : ns.h,

Common objects :p_ns_dl points the nsdl context.

*--------------------------------------------------------------------------*/

void ns_dl_timer_activity ()
{

#if NS_TYPE_BRI == ON

		/* DL inactivity timer management */

	if ((Na_type == BRI) && (Dl_ces != DL_CES_BROADCAST)) {

#       if EQUIPMENT == TE

#           if NS_RELEASE_DL == ON

				if (State_dl_timer (T3DL) == ON) {
					Stop_dl_timer (T3DL);
				}

				if (Dl_call_count == 0) {
					Start_dl_timer (T3DL);
				}

#           endif

#       else

			if (Na_fct == FG_NT_TE) {

				if (State_dl_timer (T3DL) == ON) {
					Stop_dl_timer (T3DL);
				}

				if (Dl_call_count == 0) {
					Start_dl_timer (T3DL);
				}

			} else {

#               if NS_RELEASE_DL == ON

					if (State_dl_timer (T3DL) == ON) {
						Stop_dl_timer (T3DL);
					}

					if (Dl_call_count == 0) {
						Start_dl_timer (T3DL);
					}

#				endif

			}

#       endif

	}

#endif

}

/*-------------------------------------------------------------------------*/

void ns_dl_timer_expiry ()
{

		/* Is the time-out valid and the Data Link active ? */

	if (Valid_dl_time_out (T3DL)){

			/* Reset the time-out flag */

		State_dl_timer (T3DL) = OFF;

		switch (Lc_state) {

			case LC_ESTABLISHED :

					/* Start the reset sequence of the Data link */

				if  (Dl_call_count == 0) {
					Send_to_dl (DL_COMMIT_RQ, Dl_ces);
				}

				break;

			case LC_RELEASED :
				break;

			case LC_AWAITING_EST :
			case LC_AWAITING_REL :
				Start_dl_timer (T3DL);
				break;

		}

	}

}

#if EQUIPMENT == NT2

#define BAD_IDX					(uchar)255

/*-------------------------------------------------------------------------*/

void release_call_int_timer ()
{
	uchar   i = 0;  /* index */

	do {

		if ((Int_timer_id (i) != P_NIL) && (Int_call_ref (i) == I_call_ref)) {
			Release_int_timer (i);
		}

	} while (++i < MX_INT_PROC);

}

/*-----------------------------------------------------------------------*/

void start_int_timer (timer_id, sn)
	uchar timer_id;
	uchar sn;
{
	uchar int_proc_idx;

	int_proc_idx = alloc_int_process ();

#	if ASSERT == ON

		if (int_proc_idx == BAD_IDX) {
			Trap (TRAP_MX_INT_SATURATION, "Start_int_timer");
		}

#	endif

	if ((Int_timer_id (int_proc_idx) = Timer_alloc (ENT_NS, Nai, SAPI_NIL, int_proc_idx)) == TIMER_ID_NIL) {
		Trap (TRAP_MX_INT_SATURATION, "Alloc_timer");
	}

	Timer_start (Int_timer_id (int_proc_idx), Ti_int_val (timer_id),
				Int_timer_sn (int_proc_idx) = sn, Ti_int_ev_id (timer_id));
	Int_timer_state (int_proc_idx)	= ON;
	Int_ces (int_proc_idx)			= Dl_ces;
	Int_call_ref (int_proc_idx)		= I_call_ref;

#	if SIMULATION == ON
		Int_timer_idx (int_proc_idx)= timer_id;	/* to be able to print the timer id */
#	endif

}

/*-----------------------------------------------------------------------*/

void stop_int_timer ()
{
	uchar 	int_proc_idx;

	if ((int_proc_idx = find_int_timer ()) != BAD_IDX) {
		Timer_stop (Int_timer_id (int_proc_idx));
		Release_int_timer (int_proc_idx);
	}
}

/*-----------------------------------------------------------------------*/

uchar alloc_int_process ()
{
	uchar i = 0;        /* loop index */

	do {

		if (Int_timer_id (i) == P_NIL) return (i);

	} while (++i < MX_INT_PROC);

	return (BAD_IDX);
}
/*-----------------------------------------------------------------------*/

uchar find_int_timer ()
{
	uchar i = 0;		/* loop index */

	do {

		if ((Int_timer_id (i) != P_NIL) &&
			(Int_ces (i) == Dl_ces)	&&
			(Int_call_ref (i) == I_call_ref)) return (i);

	} while (++i < MX_INT_PROC);

	return (BAD_IDX);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			i_call_ref_load and spdu_call_ref_load - implements the call
				reference extraction from a SPDU and the call reference
				loading in a SPDU to and from the internal call reference
				value i_call_reference.

Usage           void 	spdu_call_ref_load	(uchar lgth);
				uchar   i_call_ref_load		(uchar lgth);
					- lgth : length of the call reference.

Return value : i_call_ref_load : pad check = OK or NOK

Common constants and declarations : dl.h

Common objects : internal call reference and SPDU current context.

*--------------------------------------------------------------------------*/

void spdu_call_ref_load (lgth)
	uchar	lgth;					/* length of the call reference */
{
	Put_inc_ie_octet (lgth);
	Put_inc_ie_octet ((uchar)(((I_call_ref & Mask (1)) << 7) + ((I_call_ref >> 1) & Mask (7))));

	while (--lgth != 0) {
		Put_inc_ie_octet ((uchar)(I_call_ref >> (lgth * 8)));
	}
}

/*-------------------------------------------------------------------------*/

uchar i_call_ref_load (lgth)
	uchar	lgth;							/* length of the call reference */
{
	uchar pad_check = OK;
	uchar call_ref_flag, msb,lsb;

		/* Call reference pad checking */

#	if MESSAGE_HEADER_IE == ON
		i_message_header.call_ref_lgth		= Get_ie_octet & Mask(4);
#	endif

	if (((Get_inc_ie_octet >> 4) & Mask (4)) != 0) {
		pad_check = NOK;
	}

#	if MESSAGE_HEADER_IE == ON
		i_message_header.call_ref_flag		= Get_ie_octet >> 7;
		i_message_header.call_ref_val		= Get_ie_octet & Mask(7);
		i_message_header.call_ref_val_ext	= 0;
#	endif

		/* Get the call reference flag */

	call_ref_flag = (Get_ie_octet >> 7) ^ 1;

	if (Na_type == PRI) {

		if (Spdu_param_call_ref_lgth_pri_max > 1) {

			if (lgth == 1) {
				msb = 0;
				lsb = Get_inc_ie_octet & Mask (7);

			} else {

				msb = ((Get_inc_ie_octet & Mask (7)) << 1);
				lsb = Get_inc_ie_octet;
			}

			I_call_ref = ((call_ref_t)lsb << 8) + msb + call_ref_flag;

		} else {

			lsb = ((Get_inc_ie_octet & Mask (7)) << 1);
			I_call_ref = lsb + call_ref_flag;
		}

	} else {

		lsb = ((Get_inc_ie_octet & Mask (7)) << 1);
		I_call_ref = lsb + call_ref_flag;

	}


#	if NS_TYPE_PRI == ON

		if ((Spdu_param_call_ref_lgth_pri_max > 1) && (Na_type == PRI)) {

			if ((I_call_ref_without_ces >> 1) != CALL_REF_GLOBAL_VAL) {
				I_call_ref_lgth = Spdu_param_call_ref_lgth_pri_max;
			}
		}

#	endif

#	if EQUIPMENT == NT2

	/*
	 *  Internal call ref shall take into account the DL CES for incoming
	 *  calls because the same call ref may be used on different DL connections
	 *
	 *      outgoing calls : internal call ref = call ref,
	 *
	 *                                           --------------------
	 *      incoming calls : internal call ref = | CES |	call ref|
	 *                                           --------------------
	 *                                              |
	 *                                              v
	 *                                            octet 4
	 *
	 *  the name "call ref" above is a value built from received call ref flag and value
	 */

		if (Na_fct == FG_NT_TE) {

			if (!Is_call_ref_outgoing_call) {

				Ns_concat_ces_and_call_ref (R_msg_ces);
			}
		}

#	endif

	return (pad_check);
}

#if NS_EVENT_REPORT == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_send_mns_event - implements the building and sending of
				an event message to MNS.

Usage           uchar ns_send_mns_event (event_type, event_code);
					- event_type : event type,
					- event_code : event code.

Common constants and declarations : ns.h

Common objects :	current CALL contexts
					message current context

*--------------------------------------------------------------------------*/

void ns_send_mns_event (event_type, event_code)
	uchar				 event_type;		/* event type */
	uchar				 event_code;		/* event code */
{
	uchar			FAR *p_data;			/* data pointer */
	struct message	FAR *p_msg;    			/* current snd message pointer */
	struct message	FAR *p_snd_msg_save;    /* save current snd message pointer */
	struct buffer	FAR *p_buff;			/* current bufer pointer */

		/* Build the event message and send it */

	p_msg 	= P_NIL;
	p_buff 	= P_NIL;

	Prepare_data_to_send (p_msg, p_buff, Mns_event_size, p_data);

	if (p_data != P_NIL) {

			/* Load the event message */

		Mns_event_entity_origination	= ENT_NS;
		Mns_event_report_type			= REPORT_TYPE_EVENT;

		Mns_event_type					= event_type;
		Mns_event_code					= event_code;

		if (p_call != P_NIL) {
			Mns_event_call_state		= Call_state;
			Mns_event_call_direction	= Call_type;

		} else {

			Mns_event_call_state		= STATE_NULL_0;
		}

#		if NS_SPID == ON

			Mns_event_usid = 0;
            Mns_event_tid  = 0;

	        if (event_type == NS_EVENT_SPID_OK) {

            	if (Dl_current_exist) {

                	Mns_event_usid = Dl_usid;
                	Mns_event_tid  = Dl_tid;
                }
            }

#		endif

			/* Send the event message to MNS */

		p_snd_msg_save					= p_snd_msg;
		p_snd_msg						= p_msg;
		ns_snd_mns 						(MNS_EVENT_IN);
		p_snd_msg 						= p_snd_msg_save;
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_send_mns_status - implements the building and sending of
				a status message to MNS.

Usage           uchar ns_send_mns_status ();

Common constants and declarations : ns.h

Common objects :	current CALL contexts, internal structures,
					message current context

*--------------------------------------------------------------------------*/

void ns_send_mns_status ()
{
	uchar			FAR *p_data;			/* data pointer */
	struct message	FAR *p_msg;    			/* current message pointer */
	struct message	FAR *p_snd_msg_save;    /* save current snd message pointer */
	struct buffer	FAR *p_buff;			/* current bufer pointer */

		/* Build the event message and send it */

	p_msg 	= P_NIL;
	p_buff 	= P_NIL;

	Prepare_data_to_send (p_msg, p_buff, Mns_status_size, p_data);

	if (p_data != P_NIL) {

		i_ie_x = 0;

			/* Load the event message */

		Mns_status_entity_origination 	= ENT_NS;
		Mns_status_report_type			= REPORT_TYPE_STATUS;

		Mns_status_tei              	= Dl_tei;

		Mns_status_call_ref        		= I_call_ref;

		Mns_status_location				= I_cause_location;
		Mns_status_cause_class			= I_cause_class;
		Mns_status_cause_val			= I_cause_val;

		if (I_cause_p_diagnostic != P_NIL) {

			Mns_status_diagnostic		= I_cause_diagnostic;

		} else {

			Mns_status_diagnostic		= DIAGNOSTIC_NIL;
		}

		Mns_status_call_state			= I_call_state_val;
		p_snd_msg_save					= p_snd_msg;
		p_snd_msg						= p_msg;
		ns_snd_mns (MNS_STATUS_IN);
		p_snd_msg 						= p_snd_msg_save;
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_send_mns_restart - implements the building and sending of
				a restart confirmation message to MNS.

Usage           void ns_send_mns_restart (uchar report_type, uchar restart_class, uchar chan_nb, uchar error_type);
					- report_type : type of report,
					- restart_class : restart class,
					- chan_nb : B-Channel Nb,
					- error_type : type of error.

Common constants and declarations : ns.h

Common objects :	message current context

*--------------------------------------------------------------------------*/

#if NS_RESTART_PROCEDURE == ON /* { */

void ns_send_mns_restart (report_type, restart_class, chan_nb, error_type)
	uchar				 report_type;		/* type of report */
	uchar				 restart_class;		/* restart class */
	uchar				 chan_nb;			/* B-Channel Nb */
	uchar				 error_type;		/* type of error */
{
	uchar			FAR *p_data;			/* data pointer */
	struct message	FAR *p_msg;    			/* current snd message pointer */
	struct message	FAR *p_snd_msg_save;    /* save current snd message pointer */
	struct buffer	FAR *p_buff;			/* current bufer pointer */

		/* Build the restart message and send it */

	p_msg 	= P_NIL;
	p_buff 	= P_NIL;

	Prepare_data_to_send (p_msg, p_buff, Mns_restart_size, p_data);

	if (p_data != P_NIL) {

			/* Load the event message */

		Mns_restart_ent_origination		= ENT_NS;
		Mns_restart_report_type			= report_type;

		if (report_type == OK) {

			Mns_restart_class			= restart_class;
			Mns_restart_b_chan_nb		= chan_nb;

		} else {

			Mns_restart_error_type		= error_type;
		}

#		if NS_MAINTENANCE_CAPABILITY == ON

            if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {
            
                if (I_(chan_id,int_id_val) != BYTE_VAL_NIL) {

                    Mns_restart_interface = I_(chan_id,int_id_val);

                } else {

                    Mns_restart_interface = Nai;
                }

            } else {
                    Mns_restart_interface = Nai;
            }

#		endif
			/* Send the RESTART_CO message to MNS */

		p_snd_msg_save					= p_snd_msg;
		p_snd_msg						= p_msg;
		ns_snd_mns 						(MNS_RESTART_CO);
		p_snd_msg 						= p_snd_msg_save;
	}
}

#endif /* NS_RESTART_PROCEDURE == ON} */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_send_mns_service - implements the building and sending of
				a service confirmation message to MNS.

Usage           void ns_send_mns_service (uchar error_type);
					- error_type : type of error.

Common constants and declarations : ns.h

Common objects :	message current context

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

void ns_send_mns_service (error, nai, chan_id)
	uchar				error;				/* type of error */
	nai_t				nai;				/* Nai */
	uchar				chan_id;
{
	uchar			FAR *p_data;			/* data pointer */
	struct message	FAR *p_msg;    			/* current snd message pointer */
	struct message	FAR *p_snd_msg_save;    /* save current snd message pointer */
	struct buffer	FAR *p_buff;			/* current bufer pointer */

		/* Build the restart message and send it */

	p_msg 	= P_NIL;
	p_buff 	= P_NIL;

	Prepare_data_to_send (p_msg, p_buff, Mns_service_size, p_data);

	if (L_msg_p_buffer != P_NIL) {
		Buffer_data_offset += sizeof (ushort);

	} else {

		L_msg_data_offset  += sizeof (ushort);
	}

	p_data = L_a_data;

	if (p_data != P_NIL) {

		Mns_service_error 		= error;
		Mns_service_action_type	= I_MAINTENANCE;

		if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

			if (I_(chan_id,int_id_val) != BYTE_VAL_NIL) {

				Mns_service_int_id = I_(chan_id,int_id_val);

			} else {

				Mns_service_int_id = nai;
			}

			Mns_service_b_chan  = chan_id;

		} else {

			Mns_service_int_id = nai;

		}

		Mns_service_pref	= I_(change_status, preference);
		Mns_service_status  = I_(change_status, status);

			/* Send the MNS_SERVICE_CO message to MNS */

		p_snd_msg_save					= p_snd_msg;
		p_snd_msg						= p_msg;
		ns_snd_mns 						(MNS_SERVICE_CO);
		p_snd_msg 						= p_snd_msg_save;
	}
}

#endif /* NS_MAINTENANCE_CAPABILITY == ON} */

/*-------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            disc_cause_error -
				When a DISC msg was received with an invalid cause,
				whatever is the cause in the CLEAR_RS from Call Control,
				the REL message must contain the cause #100 or #96

Usage           uchar disc_cause_error ();

Common constants and declarations : ns.h

Common objects :	current CALL contexts, internal structures,
					message current context

*--------------------------------------------------------------------------*/

uchar diag;						/* diagnostic to be stored */

uchar disc_cause_error ()
{

	uchar val;

	diag = CAUSE;

	switch (Call_disc_m_ie_error) {

		case ERR_N_IE_M_MISSING	:
			val = C_V_MANDATORY_IE_MISSING_96;
			break;

		case ERR_N_IE_M_CONTENT	:
		case ERR_N_IE_M_TOO_LONG:
			val = C_V_INVALID_IE_CONTENT_100;
			break;

		case ERR_NIL			:
		default					:
			return (NOK);
	}


	if (is_ie_i(CODESET_0, CAUSE) == ABSENT) {
		set_i_cause (C_C_PROTOCOL_ERROR, val, (char *)&diag);

	} else {

		I_(cause,cause_class)	= C_C_PROTOCOL_ERROR;
		I_(cause,cause_val)		= val;
		I_(cause,diag_lgth)		= 1;
		I_(cause,p_diagnostic)	= &diag;
	}

	return (OK);
}

/*-------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ns_save_call_cause - save the cause IE with the diagnostic
				inside the call context to be able to send the same cause
				if needed.

Usage           void ns_save_call_cause (void);

Common constants and declarations : ns.h

Common objects :	current CALL contexts, internal structures,
					message current context

*--------------------------------------------------------------------------*/

void ns_save_call_cause ()
{
	struct i_cause	FAR		*p_save_cause;		/* current pointer to cause internal structure */

		/* set current pointer into call context */

	p_save_cause = Call_a_saved_cause;

		/* copy cause into call context */

	Memcpy_far ((char FAR *) p_save_cause, (char FAR *) &i_cause[0], I_cause_size);

	if ((p_save_cause -> diag_lgth) > NS_MX_SZ_SAVE_DIAG) {

			/* diagnostic is too long to be saved -> do not save it */

		p_save_cause -> diag_lgth = 0;
		p_save_cause -> p_diagnostic = P_NIL;
	}

		/* test length  of diagnostic */

	if ((p_save_cause -> diag_lgth) != 0) {

			/* length not null -> save diagnostic into call context array */

		Memcpy_far ((char FAR *) Call_a_saved_diag, (char FAR *) (p_save_cause -> p_diagnostic), (p_save_cause -> diag_lgth));
		p_save_cause -> p_diagnostic = Call_a_saved_diag;
	}
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_save_context - NS saves the current context because
										a congestion occured.

Usage            	void ns_save_context (event, entity, action);

Return value :		None.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

void ns_save_context (event, entity, action)
	uchar event;
	ent_id_t entity;
	uchar action;

{
	struct ctx_backup FAR *p_ctx;

	if (Dl_current_exist) {

		if (Dl_backup == OFF) {
			Dl_backup = ON;

				/* Build a backup context */

			if ((p_ctx = (struct ctx_backup FAR *)Mem_alloc (Rnd_sizeof (struct ctx_backup), PID_VL)) == P_NIL) {
				return;
			}

			Lifo_put_object (p_ctx_backup, p_ctx);

			Ctx_backup_event		= event;
			Ctx_backup_ces			= Call_ces;
			Ctx_backup_entity		= entity;
			Ctx_backup_nai			= Nai;
			Ctx_backup_action		= action;
		}
	}
}

/****************************************************************************
 *						MULTI NETWORK MANAGEMENT							*
 ****************************************************************************/

	extern	uchar ns_net_idx;
	extern	uchar select_op;
			uchar ns_operator;		/* To check the consistency of the config. */

#if SIMULATION == ON

	extern uchar param_net_op;

#	if NEW_FCT_STYLE == ON
		void get_simul_net_op (uchar nai, ushort FAR *na_country, uchar FAR *na_op);
#	else
		void get_simul_net_op ();
#	endif

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_get_network - from the operator and the country,
									returns the according network.

Usage            	uchar ns_get_network ();

Return value :		the network identifier.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

#define MX_COUNTRY_NET_OP	8

struct country_net {
	ushort country;
	uchar  op[MX_COUNTRY_NET_OP];
};

CONST_ARRAY struct country_net t_ns_country_net[] = {

/* country		default op	other1		other2		other3 		other4		other5 		other 6 	other 7 */

{AUSTRALIA,		{AUSTEL_1,	ETSI}},
{BELGIUM,		{BG_V1,		ETSI,		FT_VN6}},
{FRANCE,		{FT_VN3,	FT_VN2,		FT_VN6}},
{GERMANY,		{DT_1TR6,	ETSI}},
{JAPAN,			{NTT,		KDD}},
{SWEDEN,		{SWD_TVKT,	ETSI}},
{UK,			{ETSI,		BT_ISDN2}},
{USA,			{NT_DMS100,	N_ISDN1,	N_ISDN2,	ATT_5E5,	ATT_5E9,	ATT_5E10, BELLCORE_PRI, ATT_4ESS}},
{HONG_KONG,		{HK_TEL, 	ETSI}},
{EUROPE,		{ETSI,		ECMA_QSIG,	FT_VN6}},
{SOUTH_AFRICA,	{ETSI}},
{COUNTRY_NIL,   {CTU_CDS,	CTU_BS}},
{0},

};

	/*
		Table giving the address of the variable used to identify the
		operators.

		WARNING: the order must fit the definitions given in services.h
		and 'pic_init_ns_t_operator_var' function must be in conformance
        with this Table (see below).
	*/

uchar * PIC_CONST t_ns_operator_var[] = {
	P_NIL,
	Pic_address	(&vn2),
	Pic_address	(&vn3),
	Pic_address	(&vn6),
	Pic_address	(&tr6),
	Pic_address	(&bt2),
	Pic_address	(&at5),
	Pic_address	(&at9),
	Pic_address	(&dms),
	Pic_address	(&ntt),
	Pic_address	(&kdd),
	Pic_address	(&ets),
	Pic_address	(&bv1),
	Pic_address	(&ni1),
	Pic_address	(&swd),
	Pic_address	(&au1),
	Pic_address	(&qsi),
	Pic_address	(&hkt),
	P_NIL,		/* 'drv' not implemented yet */
	Pic_address	(&bip),
	Pic_address	(&ni2),
	Pic_address	(&a17),
	Pic_address	(&a11),
	Pic_address	(&e10),
	Pic_address	(&at4),
};

#if OM_CODE_TYPE == OM_PIC

void pic_init_ns_t_operator_var()
{

	Pic_init_index ();

	Pic_index++;	/* first entry is P_NIL */
	Pic_init_array (t_ns_operator_var, &vn2);
	Pic_init_array (t_ns_operator_var, &vn3);
	Pic_init_array (t_ns_operator_var, &vn6);
	Pic_init_array (t_ns_operator_var, &tr6);
	Pic_init_array (t_ns_operator_var, &bt2);
	Pic_init_array (t_ns_operator_var, &at5);
	Pic_init_array (t_ns_operator_var, &at9);
	Pic_init_array (t_ns_operator_var, &dms);
	Pic_init_array (t_ns_operator_var, &ntt);
	Pic_init_array (t_ns_operator_var, &kdd);
	Pic_init_array (t_ns_operator_var, &ets);
	Pic_init_array (t_ns_operator_var, &bv1);
	Pic_init_array (t_ns_operator_var, &ni1);
	Pic_init_array (t_ns_operator_var, &swd);
	Pic_init_array (t_ns_operator_var, &au1);
	Pic_init_array (t_ns_operator_var, &qsi);
	Pic_init_array (t_ns_operator_var, &hkt);
	Pic_index++;	/* P_NIL entry, 'drv' not implemented yet */
	Pic_init_array (t_ns_operator_var, &bip);
	Pic_init_array (t_ns_operator_var, &ni2);
	Pic_init_array (t_ns_operator_var, &a17);
	Pic_init_array (t_ns_operator_var, &a11);
	Pic_init_array (t_ns_operator_var, &e10);
	Pic_init_array (t_ns_operator_var, &at4);
}

#endif

uchar ns_get_network (op, country)
	uchar	op;
	ushort	country;
{
	CONST struct country_net	*p_country_net;
	uchar						i;

		/* Search for the 'country' in the 't_ns_country_net' table */

	p_country_net = (struct country_net *)&t_ns_country_net [0];

	while ((p_country_net -> country != 0) && (p_country_net -> country != country)) {

		p_country_net++;
	}

	if (p_country_net -> country == 0) {

			/* country not found : select the ns_par.h one */

		country = NS_COUNTRY;
		op      = NS_OPERATOR;

	} else {

			/* Search for the operator in the list */

		i=0;

		do {

			if (p_country_net -> op[i] == op) break;

			i++;

		} while (! ((i == MX_COUNTRY_NET_OP) || (p_country_net -> op[i] == 0)));

		if ((i == MX_COUNTRY_NET_OP) || (p_country_net -> op[i] == 0)) {

				/* operator not found : force default one */

			op = p_country_net -> op[0];

		}

	}

	select_op = op;

	if (*(t_ns_operator_var[op]) == NIL) {
		*(t_ns_operator_var[op]) = ns_get_net_idx (op);

	}

#	if RESET_CONFIG == ON

			/* Increment the nb of times a specifciation has been chosen */

		Net_table_nb_time (select_op)++;

#	endif

	return (*(t_ns_operator_var[op]));
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_get_net_idx -

Usage            	uchar ns_get_net_idx (op);

Return value :		current network index

*--------------------------------------------------------------------------*/

uchar ns_get_net_idx (op)
	uchar op;
{

	uchar ret_net_idx;								/* return code */

#	if RESET_CONFIG == ON
		uchar x_op;									/* loop index */
#	endif

	if (Net_table_presence (op) == OFF) {
		Trap (TRAP_NS_INIT, "ns_get_net_idx - OPERATOR was not compiled.");
	}

#	if RESET_CONFIG == ON

			/* Is there one index no more used ? (due to reset config) */

		x_op = 1;

		do {

			if ((Net_table_config (x_op) == ON) 	&&
				(Net_table_nb_time (x_op) == 0)) {

					/* Reset the 'config done' flag for the old one */

				Net_table_config (x_op)	= OFF;

					/* Reset the 'config done' flag for current one (op) */

				Net_table_config (op)		= OFF;

					/* Set the available network index */

				ret_net_idx	= Net_table_idx (x_op);

					/* Reset the 'net_idx' flag */

				Net_table_idx (x_op) = NIL;

				break;
			}

			x_op++;

		} while (x_op < MX_OPERATOR_NB);

			/* Previous search failed ? */

		if (x_op == MX_OPERATOR_NB) {

				/*
				 * - Yes.
				 * Allocate a new net_idx which must be different from
				 * those already in use.
				 */

			ns_net_idx = 1;

			do {

				x_op = 1;

				do {

					if ((Net_table_config (x_op) == ON) 	&&
						(Net_table_nb_time (x_op) > 0)) {

							/* This 'x_op' is in use */

						if (ns_net_idx == Net_table_idx (x_op)) {

								/*
								 * net_idx is already used
								 *	--> Get another one.
								 */

							break;
						}
					}

				} while (++x_op < MX_OPERATOR_NB);

				if (x_op == MX_OPERATOR_NB) {

						/*
						 * We did not find a index wich equals
						 * 'net_idx' --> We keep it.
						 */

					break;
				}

					/* Try another net_idx */

			} while (++ns_net_idx < MX_OPERATOR_NB);

			ret_net_idx = ns_net_idx;
		}

#	else

		ret_net_idx = ++ns_net_idx;

#	endif

	if (ret_net_idx > NETWORK_NB) {
		Trap (TRAP_NS_INIT, "ns_get_net_idx - NETWORK_NB was not set properly.");
	}

	Net_table_idx (op) = ret_net_idx;

	return (ret_net_idx);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_dec_net_idx -

Usage            	uchar ns_dec_net_idx (net_idx);

Return value :		OK/NOK

*--------------------------------------------------------------------------*/

#if RESET_CONFIG == ON

uchar ns_dec_net_idx (net_idx)
	uchar net_idx;
{

	uchar i;

	i = 1;

	do {

		if (Net_table_idx (i) == net_idx) {

				/* Decrement the nb of times the specification is used */

			if (Net_table_nb_time (i) > 0) {
				Net_table_nb_time (i)--;
			}

			if (Net_table_nb_time (i) == 0) {

					/*
					 * That specification is no longer in use,
					 * reset its index.
					 */

				*(t_ns_operator_var[i]) = NIL;

#				if ONE_NETWORK == ON

						/* Reset the 'net_idx' */

					ns_net_idx = NIL;

						/* Reset the 'operator' for ns_check_network function */

					ns_operator	= NO_OPERATOR_DEFINED;

#				endif
			}

			return (OK);
		}

	} while (++i < MX_OPERATOR_NB);


	return (NOK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_check_network - check network operator consistancy

Usage            	uchar ns_check_na_network (ns_net, na_net);

Return value :		OK/NOK

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

uchar ns_check_network (na_op, ns_op, na_country, ns_country)
	uchar	na_op;
	uchar	ns_op;
	ushort	na_country;
	ushort	ns_country;
{

#	if (SIMULATION == ON)

		if (param_net_op == ON) {

				/*
				 * Get country/specif as indicated in the
				 * simulator command line.
				 */

			get_simul_net_op (Nai, &na_country, &na_op);

			if (na_country == NIL) {
				return (NOK);
			}
		}

#	endif

	if (na_country == NIL) {

		if (ns_country == NIL) {

			/*
			 * No country was specified in the NA and NS config,
			 * => set the default value.
			 */

			na_country	= NS_COUNTRY;

		} else {

			/*
			 * No country was specified at the NA level,
			 * => set the NS value.
			 */

			na_country = ns_country;
		}
	}

	if (na_op == NIL) {

		if (ns_op == NIL) {

			/*
			 * No operator was specified in the NA and NS config,
			 * => set the default value.
			 */

			na_op = NS_OPERATOR;

		} else {

			/*
			 * No operator was specified at the NA level.
			 * => Set na_op to ns_op.
			 */

			na_op = ns_op;
		}
	}

	Na_network	= ns_get_network (na_op, na_country);
	Na_country	= na_country;

#	if ONE_NETWORK == ON

		if ((ns_operator != NO_OPERATOR_DEFINED) && (ns_operator != select_op)) {

			/*
			 * 2 different networks were set in the config.
			 * This is prohibited since ONE_NETWORK was set to ON.
			 */

			Trap (TRAP_NS_INIT, "ns_check_network - All Nai must have the same OPERATOR.");
		}

			/*
			 * select_op was initialized in ns_get_network function.
			 * Save it in the 'operator' variable.
			 */

		ns_operator = select_op;

#	endif

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_build_net_table - init of NS network table.

Usage            	uchar ns_build_net_table ();

Return value :		OK/NOK

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

uchar ns_build_net_table (net)
	uchar net;
{

	if (Net_table_config (net) == OFF) {
		ns_build_par_table		();				/* ns.c */
		ns_build_error_table	();				/* ns_err.c */
		ns_build_spdu_table		();				/* ns_spdu.c */
		ns_build_ssdu_table_1	();				/* ns_ssdu1.c */
		ns_build_ssdu_table_2	();				/* ns_ssdu2.c */
		ns_build_ie_table_1		();				/* ns_ie_1.c */
		ns_build_ie_table_2		();				/* ns_ie_2.c */
		ns_build_ie_table_4		();				/* ns_ie_4.c */
		ns_build_ie_table_5		();				/* ns_ie_5.c */
		ns_build_ie_table_6		();				/* ns_ie_6.c */

		Net_table_config (net) = ON;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_reset_op_idx  - reset the operator indexes.

Usage            	uchar ns_reset_op_idx  ();

Return value :		none.

Common constants and declarations : ns_fct.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

void ns_reset_op_idx  ()
{

	uchar i;

	swd	= 							/* index for SWD_TVKT	operator */
	bv1	= 							/* index for BG_V1		operator */
	au1	=                   		/* index for AUSTEL_1	operator */
	tr6	= 							/* index for DT_1TR6	operator */
	vn2	= 							/* index for FT_VN2		operator */
	vn3	= 							/* index for FT_VN3		operator */
	vn6	= 							/* index for FT_VN6		operator */
	ets	= 							/* index for ETSI		operator */
	at5	= 							/* index for ATT_5E5	operator */
	at4	= 							/* index for ATT_4E4	operator */
	at9	= 							/* index for ATT_5E9	operator */
	bip	= 							/* index for BELLCORE	operator */
	bt2	= 							/* index for BT_ISDN2	operator */
	dms	= 							/* index for NT_DMS100	operator */
	kdd	= 							/* index for KDD 		operator */
	ni1	= 							/* index for N_ISDN1	operator */
	ni2	= 							/* index for N_ISDN2	operator */
	ntt	= 							/* index for NTT		operator */
	hkt =							/* index for HK_TEL		operator */
	a17	= 							/* index for CTU_CTS			 */
	a11	= 							/* index for CTU_BS				 */
	qsi	= NIL;						/* index for ECMA_QSIG	operator */

	for (i = 0; i < MX_OPERATOR_NB; i++) {
		Net_table_config(i)		= OFF;
		Net_table_idx (i)		= NIL;
		Net_table_nb_time(i)	= 0;
	}

	ns_net_idx	= NIL;
	ns_operator	= NO_OPERATOR_DEFINED;	/* to save the Na_network in order to check the consistancy of the config. */
	select_op	= NIL;


}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_free_dl_ctx -

Usage            	uchar ns_free_dl_ctx ()

Return value :		OK.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

uchar ns_free_dl_ctx ()
{
	struct nsdl FAR *p_nsdl_sav;


		/* Scan all the DL connections of the NA */

	Ns_access_first_dl ();

	while (Dl_current_exist) {

			/* Save the current nsdl context */

		p_nsdl_sav = p_nsdl;

			/* Free related timers */

		ns_release_dlci_timers ();

			/* Get the next context if any */

		Ns_access_next_dl ();

#		if NS_MAINTENANCE_CAPABILITY == ON

			if (p_nsdl_sav -> p_dl_chan_mgt != P_NIL) {
				Mem_free ((char FAR *)p_nsdl_sav -> p_dl_chan_mgt, PID_VL);
            }
            
#		endif

			/* Free the context */

		Mem_free ((char FAR *)p_nsdl_sav ->p_blk, PID_VL);
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_update_nfas -

Usage            	void ns_update_nfas (nai_t nai);

Return value :		None.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/
#if (RESET_CONFIG == ON) && (NS_MAINTENANCE_CAPABILITY == ON) /* { */

void ns_update_nfas (nai)
	nai_t nai;
{
	uchar i,j;

	if (Na_nfas == OFF) return;

	switch (Na_d_channel_type) {

		case NS_D_CHAN_NIL :

			Ns_access_d_chan_ctx (Na_d_channel_ctx);

			if (Nfas_nai_active_d_chan == NAI_NIL) {

					/*
					 * The Nai bearing the active D channel has
					 * already been removed.
					 */

				return;
			}

			i = 0;

			do {

					/* Find the Nai in the list */

				if (Nfas_nai_assoc_list (i) == nai) {

						/*
						 * Found.
						 * Remove it from the list and drag
						 * all other Nais back of 1 place.
						 */

					for (j = i; j < Nfas_nai_assoc_list_nb_nai - 1; j++) {

						Nfas_nai_assoc_list (j) = Nfas_nai_assoc_list (j+1);
					}

						/* Mark the new end of the table */

					Nfas_nai_assoc_list (j) = NAI_NIL;

						/* Update the number of Nais in the list */

					Nfas_nai_assoc_list_nb_nai--;

					break;
				}

				i++;

			} while (i < Nfas_nai_assoc_list_nb_nai);

			break;

		case NS_D_CHAN_BCK :

			Ns_access_d_chan_ctx (Na_d_channel_ctx);

			if (Nfas_nai_active_d_chan == NAI_NIL) {

					/*
					 * The Nai bearing the active D channel has
					 * already beeen removed.
					 */

				return;
			}

				/* The D backup is in first place */

			if (Nfas_nai_assoc_list (0) == nai) {

				Nfas_nai_assoc_list (0) = NAI_NIL;

					/* No more D channel backup feature */

				Nfas_nai_d_chan_backup_act = OFF;

					/*
					 * Drag all other Nais back of 1 place.
					 */

				for (i = 0; i < Nfas_nai_assoc_list_nb_nai - 1; i++) {

					Nfas_nai_assoc_list (i) = Nfas_nai_assoc_list (i+1);
				}

					/* Mark the new end of the table */

				Nfas_nai_assoc_list (i) = NAI_NIL;

					/* Update the number of Nais in the list */

				Nfas_nai_assoc_list_nb_nai--;

			}

			break;

		case NS_D_CHAN_ACTIVE :

				/* The D channel is active */

			Ns_access_d_chan_ctx (Na_d_channel_ctx);
			Nfas_nai_active_d_chan = NAI_NIL;
			ns_nfas_group_nb--;

            	/*
                 * Free the H-code table.
                 */

            if (Nfas_a_tab != P_NIL) {
            	Mem_free ((char FAR *)Nfas_a_tab, PID_VL);
            }

			if (ns_nfas_group_nb == 0) {

            		/*
                     * There is no more NFAS groups in existance,
                     * we may now clear the whole chain of NFAS
                     * contexts.
                     */

				Mem_free ((char FAR *)p_ns_d_chan_status_start, PID_VL);
				p_ns_d_chan_status_start = P_NIL;
			}

			break;


	}
}

#endif	/* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				- ns_get_nfas_group

Usage            	uchar ns_get_nfas_group (uchar FAR *nfas_group_id)

Return value :		OK/NOK

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar ns_get_nfas_group (nfas_group_id)
	uchar FAR *nfas_group_id;
{

	uchar i = 0;

	do {

		Ns_access_d_chan_ctx (i);

		if (Nfas_nai_active_d_chan == NAI_NIL) {

				/*
				 * That group is available
				 */

			ns_nfas_group_nb++;
			*nfas_group_id = i;

			return (OK);
		}

		i++;

	} while (i < NS_MX_NFAS_GROUPS);

	return (NOK);
}

#endif /* } */


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_get_nfas_nai -
						Get the CC nai according the call reference
						received on the active D channel.

Usage            	uchar ns_get_nfas_nai (uchar FAR *nai)

Return value :		OK/NOK/STOP and set the nai value in the nai variable.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/
#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar ns_get_nfas_nai (nai)
	uchar FAR *nai;
{
	uchar i, ie_x, code, call_ref_lgth;


	if ((R_msg_code != DL_DA_IN) && (R_msg_code != DL_U_DA_IN)) {
		return (OK);
	}

		/* Get the pointer to the SPDU */

	if ((p_buffer = R_msg_p_buffer) == P_NIL) {

		if (R_msg_data_size == 0) {
			return (STOP);
		}

		p_spdu		= R_msg_a_start_data;
		p_spdu_end	= R_msg_a_end_data;

	} else {

		if (Buffer_data_size == 0) {
			return (STOP);
		}

		p_spdu		= Buffer_a_start_data;
		p_spdu_end	= Buffer_a_end_data;
	}

	if (ns_nfas == OFF) {

			/*
			 * No NFAS, the nai is the received one
			 * from DL.
			 */

		*nai = R_msg_nai;
		return (OK);
	}

	*nai = Nfas_nai_line;

		/* Get call ref length */

	p_ie = p_spdu + 1;

	I_call_ref_lgth = call_ref_lgth = R_call_ref_lgth;

	if (i_call_ref_load (I_call_ref_lgth) == NOK) {

		if (error_set (ERR_N_CALL_REF_PAD, 0, 1) == FATAL) {
			return (NOK);
		}

	}

	code = p_spdu[call_ref_lgth+2];

	switch (code) {

		case SETUP :

				/*
				 * Check if we have a NFAS Transparent mode.
				 */

			if (Nfas_nai_mode == NFAS_TSP) {

				*nai = Nfas_nai_line;

				if (Nfas_nai_d_chan_backup_act == OFF) {
					nfas_insert (I_call_ref_without_ces, *nai);
					return (OK);
				}

#				if NS_D_BACKUP == ON

						/*
						 * NFAS TSP with D channel Backup.
						 */

					if (Nfas_nai_line == Nfas_cfg_nai_backup_d_chan) {

							/*
							 * The Nai is the one that was originally
							 * designated to be the Backup D channel.
							 * Because we are in TSP mode, we must
							 * set the current Nai to the Nai that
							 * was originally designated to be bear the
							 * Active D channel.
							 */

						*nai = Nfas_cfg_nai_active_d_chan;
					}

#				endif


				nfas_insert (I_call_ref_without_ces, *nai);
				return (OK);

			}

				/*
				 * We have a SETUP, look for the channel Id.
				 */

			p_ie = (R_a_data + I_call_ref_lgth + 2 + 1);

			while ((*p_ie != CHAN_ID) && (p_ie < p_spdu_end)) {

					/* Get IE length */

				if (So_ie_flag == IE_FORMAT_SO) {

						/* Single octet IE, length is 1 */

					i = 1;

				} else {

						/* Multi octet IE, length is given by *p_ie. */

					i = *p_ie;
				}

					/* Skip the entire IE */

				p_ie += i;

			}


				/*
				 * The following code needs a valid Nai pointer to know
				 * what switch variant we are ruuning.
				 * Assuming that ALL network variants managed by the NFAS
				 * are identical, we set the current Na to the one
				 * bearing the active D channel.
				 */

			p_nsna = Nfas_nai_p_active_d_chan;

			if (p_ie < p_spdu_end) {

					/* CHAN_ID found ! */
					/* Execute the CHAN_ID meta program */

				ie_x = Access_tab_ie (Search_key_ie (CODESET_0, CHAN_ID));

					/* Get CHAN ID length */

				i = p_ie [1];

					/* set p_ie to the data start (skipping the length --> +2) */

				p_ie = p_ie + 2;

					/* set p_ie_end to the data end */

				p_ie_end = p_ie + i;

					/* Execute the meta_program */

				ie_optional_octet	= OFF;
				ie_end_found		= OFF;
				direction			= FROM_D_CHANNEL;

				if ((ret_code = r_exec_spdu_ie (Ie_p_prog (ie_x))) == OK) {

						/* Access the Nai =  the Interface Identifer */

					if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {

						ns_cc_int_id = *nai = I_(chan_id, int_id_val);

					} else {

						ns_cc_int_id = *nai = Nfas_nai_line;
					}

				}

				nfas_insert (I_call_ref_without_ces, *nai);

			} else {

					/*
					 * No CHAN_ID ...
					 */
			}

			break;

		default :

			if ((Is_call_ref_nil) ||
				((I_call_ref_without_ces >> 1) == CALL_REF_GLOBAL_VAL)) {

					/*
					 * Call reference is DUMMY or GLOBAL,
					 * Access the Nai from the line.
					 */

					if (ns_access_na (R_msg_nai) == NOK) {
						error_set (ERR_N_CALL_REF_UNKNOWN, 0, 0);

							/*
							 * Set the Na and Dl context to the line context
							 */

						p_nsna = Nfas_nai_p_active_d_chan;
						p_nsdl = Nfas_dl_p_active_d_chan;
						return (NOK);
					}

			} else {

					/*
					 * We have the call ref, now access the Na.
					 * The ns_access_na () is done in ns_access_nfas ().
					 */

				if (ns_access_nfas (I_call_ref_without_ces) == NOK) {
					error_set (ERR_N_CALL_REF_UNKNOWN, 0, 0);

						/*
						 * Set the Na and Dl context to the line context
						 */

					p_nsna = Nfas_nai_p_active_d_chan;
					p_nsdl = Nfas_dl_p_active_d_chan;
					return (NOK);

				}
			}

			ns_cc_int_id = *nai = Nai;

			break;
	}

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_get_ctx_d_chan_bearer -

Usage            	uchar ns_get_ctx_d_chan_bearer (uchar nai)

Return value :		None.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/
void ns_get_ctx_d_chan_bearer (nai)
	nai_t nai;
{

	uchar i;

			/* The 'nai' is a D channel bearer (maybe backup) */

	if ((R_msg_from == ENT_DL_D) ||
		(R_msg_from == ENT_DL)) {

		for (i = 0; i < ns_nfas_group_nb; i++) {

			Ns_access_d_chan_ctx (i);

			if ((Nfas_nai_active_d_chan == nai)

#				if NS_D_BACKUP == ON

					|| ((Nfas_nai_d_chan_backup_act == ON) && (Nfas_nai_backup_d_chan == nai))

#				endif

			) {

				if ((Nfas_nai_mode == NFAS_TSP) &&
					(Nfas_nai_d_chan_backup_act == OFF)) {
				   ns_nfas = OFF;

				} else {

						/* That Nai is supporting the NFAS */

					ns_nfas			= ON;
					Nfas_nai_line = nai;
				}

				return;
			}
		}
			/* That Nai is not having the NFAS support */

		ns_nfas = OFF;
	}
}


#endif /* } NS_MAINTENANCE_CAPABILITY */

#if NS_D_BACKUP /* { */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_nfas_stop_309 -

Usage            	uchar ns_nfas_stop_309 ()

Return value :		OK.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/

void ns_nfas_stop_309 ()
{

	uchar i;
	struct nsna FAR *p_nsna_sav;
	struct nsdl FAR *p_nsdl_sav;

	p_nsna_sav = p_nsna;
	p_nsdl_sav = p_nsdl;

		/*
		 * Access to all the Nais managed by the current D channel
		 * bearer,
		 */

	for (i = 0; i < Nfas_nai_assoc_list_nb_nai + 1; i++) {

		if (ns_access_na (Nfas_nai_assoc_list(i)) == NOK) {
			return;
		}

			/*
			   Scan all the call contexts of the NA
			   if a message is waiting for
			   connection establishment released it.
			   then process the call according to its state .
			*/

		ns_access_first_call ();

		while (Call_current_exist) {

			switch (Call_state) {

					/* State NULL */

				case STATE_NIL 		:
				case STATE_NULL_0 	:
					break;					/* nothing to do */

#				if NS_T309 == ON

						/* Call in active state */

					case STATE_ACTIVE_10 :

						if (Na_T309_option == ON) {

								/* Network access connected ? */

							if (Na_status == ON) {

								if (State_timer_ns (T309) == ON) {
									Stop_timer_ns (T309);

								}

								if (ns_nfas == ON) {
									I_call_ref = Call_ref;
									Send_to_d_channel (STATUS_ENQ);
								}
							}

						}

						break;
#				endif

			} /* End switch Call_state */

			ns_access_next_call ();

		} /* End for */

	}

		/* Reset the contexts */

	p_nsna = p_nsna_sav;
	p_nsdl = p_nsdl_sav;

}

#endif /* } NS_D_BACKUP */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ns_update_bkp_dl_ctx -

Usage            	ns_update_bkp_dl_ctx ()

Return value :		OK.

Common constants and declarations : ns.h

Common objects : NS global variables.

*--------------------------------------------------------------------------*/
#if NS_D_BACKUP /* { */

void ns_update_bkp_dl_ctx ()

{

		/*
         * For now, this routine updates the restart procedure environment
         * only. In the future, some more updates may be performed.
         */

    if (Nfas_nai_d_chan_backup_act == ON) {

        if ((Nfas_context_exist) && (Dl_current_exist)){

            if (p_nsdl == Nfas_dl_p_active_d_chan) {

                if (Nfas_dl_p_backup_d_chan != P_NIL) {

                	Nfas_dl_p_backup_d_chan -> rest_state	= Dl_rest_state;
                	Nfas_dl_p_backup_d_chan -> rest_ack 	= Dl_rest_ack;
                	Nfas_dl_p_backup_d_chan -> rest_rs		= Dl_rest_resp;
                	Nfas_dl_p_backup_d_chan -> rest_class	= Dl_rest_class;
                	Nfas_dl_p_backup_d_chan -> rest_b_chan_nb= Dl_rest_chan_nb;
                	Nfas_dl_p_backup_d_chan -> rest_int_id	= Dl_rest_int_id;
                }

            } else {

                if (p_nsdl == Nfas_dl_p_backup_d_chan) {

                    if (Nfas_dl_p_active_d_chan != P_NIL) {

                        Nfas_dl_p_active_d_chan -> rest_state	= Dl_rest_state;
                        Nfas_dl_p_active_d_chan -> rest_ack 	= Dl_rest_ack;
                        Nfas_dl_p_active_d_chan -> rest_rs		= Dl_rest_resp;
                        Nfas_dl_p_active_d_chan -> rest_class	= Dl_rest_class;
                        Nfas_dl_p_active_d_chan -> rest_b_chan_nb= Dl_rest_chan_nb;
                        Nfas_dl_p_active_d_chan -> rest_int_id	= Dl_rest_int_id;
                    }
                }
            }
        }
	}
}

#endif /* } */

/*EOF*/
