
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_ss.eur
 *
 * $Revision$
 *
 * $Date$
 *
 *		This file contains the descriptions of all OPERATIONs and ERRORs
 *		used for Supplementary Services in EUROPE.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|														|*/
/*[]---------------------------------------------------[]*/

	/* definitions of some ASN1 types described in ETS 300 196 (other ones are in ns_sstab.eur)
	 * ---------------------------------------------------------------------------------------- */

		/* BasicService ::= ENUMERATED {allServices(0), speech(1), unrestrictedDigitalInformation(2),
		 *		audio3k1Hz(3), unrestrictedDigitalInformationWithTonesAndAnnouncements(4),
		 *		telephony3k1Hz(32), teletex(33), telefaxGroup4Class1(34), videotexSyntaxBased(35),
		 *		videotelephony(36), telefaxGroup2-3(37), telephony7kHz(38)}
		 */

#define NS_SS_BASIC_SERVICE_P		NS_SS_ENUMERATED_P

#if (NS_SS_DIVERSION == ON) || (NS_SS_ECT == ON) || (NS_SS_CCBS == ON) || ((F_QSI == ON) && (NS_SS_CALL_TRANSFER == ON)) /* Types used in Diversion, ECT, CCBS and Q-SIG Call Transfer SS{ */

		/* PresentationAllowedIndicator ::= BOOLEAN */

#define NS_SS_PRESENT_ALLOW_IND_P		NS_SS_BOOLEAN_P

		/* ScreeningIndicator ::= ENUMERATED {userProvidedNotScreened(0), userProvidedVerifiedAndPassed(1), userProvidedVerifiedAndFailed(2), networkProvided(3)} */

#define NS_SS_SCREENING_IND_P			NS_SS_ENUMERATED_P

		/* NSAPSubaddress ::= OCTET STRING (SIZE (1..20)) */

#define NS_SS_NSAP_SUBADD_P		NS_SS_OCTET_STRING_P

		/*-=-=-=-=-=-*/

#define NS_SS_SUBADD_INFO_P		NS_SS_OCTET_STRING_P
#define NS_SS_ODDCOUNT_P		NS_SS_BOOLEAN_P

		/* list of presence indicators for instances of 'oddCountIndicator' inside PartySubaddress */

#define Party_subadd_odd_count		ns_asn1_optional_indicators

		/* list of presence indicators for instances of 'PartySubaddress' inside Address */

#define Party_subadd_in_add		(ns_asn1_optional_indicators + 2)

		/* list of presence indicators for instances of 'PartySubaddress' inside AddressScreened */

#define Party_subadd_in_scr_add		(ns_asn1_optional_indicators + 2)

#endif /* end of DIVERSION or ECT or CCBS or CALL TRANSFER supported} */

/*==========================================================================*/

		/*	Closed User Group SS (CUG)
		 * --------------------------- */

#if NS_SS_CUG == ON		/* Closed User Group SS supported{ */

		/* lists of presence indicators for instances of Types Marked OPTIONAL or DEFAULT inside ASN1 SEQUENCE type */

#define Cug_call_out_access_rq		ns_asn1_optional_indicators				/* 'outgoingAccessRequest' inside CUGCallOperationType : 1 indicator */
#define Cug_call_index				(ns_asn1_optional_indicators + 1)		/* 'outgoingAccessRequest' inside CUGCallOperationType : 1 indicator */

		/*	Operation for CUG SS : CUGCallOperationType
		 * -------------------------------------------- */

			/* operation value (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_CUG_CALL					2		/* CUGCallOperation */

			/* internal data for CUGCallOperationType operation ARGUMENT */

struct	ns_op_cug_call {
	uchar	out_access_rq;			/* outgoingAccessRequest : BOOLEAN */
	ushort	cug_index;				/* cUgIndex : INTEGER (0..32767) */

} ns_op_cug_call [NS_SS_MAX_CUG];

	/* functions used to process CUGCallOperationType operation content in SSDU */

uchar ns_ssdu_op_cug_call (p_start, offset)
	uchar FAR				*p_start;			/* pointer to start of component */
	ushort					offset;				/* offset of data in received SSDU */
{
	uchar FAR				*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

			/* only ARGUMENT clause is defined : only Invoke component is allowed */

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (OK);	/* there is no data in operation : possible for all parameters are optional */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_cug_call[ns_i_ss_clause_nb].out_access_rq = Ns_cug_call_out_access_rq;
		ns_op_cug_call[ns_i_ss_clause_nb].cug_index = Ns_cug_call_index;

	} else {	/* to CALL CONTROL */

		Ns_cug_call_out_access_rq = ns_op_cug_call[ns_i_ss_clause_nb].out_access_rq;
		Ns_cug_call_index = ns_op_cug_call[ns_i_ss_clause_nb].cug_index;
		p_ssdu_val += Rnd_sizeof (struct ns_cug_call_arg);
	}

	return (OK);
}

#endif /* end of "Closed User Group SS supported"} */

/*==========================================================================*/

		/*	Advice Of Charge SS, including 3 services : AOC-S (at call set-up time),
		 *	AOC-D (during the call), AOC-E (at the end of the call)
		 *	implementation of general AOC ASN1 types (with ASN1 meta-programs)
		 * ------------------------------------------------------------------ */

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)	/* AOC service supported{ */

		/* lists of presence indicators for instances of Types Marked OPTIONAL inside ASN1 SEQUENCE type */

#define Aocd_billing_id_presence	ns_asn1_optional_indicators			/* 'aOCDBillingId' inside AOCDCurrencyInfo and AOCDChargingUnitInfo Types : 1 indicator */
#define Aoce_billing_id_presence	ns_asn1_optional_indicators			/* 'aOCEBillingId' inside AOCECurrencyInfo and AOCEChargingUnitInfo Types : 1 indicator */

	/* 'chargingAssociation' inside AOCECurrencyInfo and AOCEChargingUnitInfo Types :
		after BillingId indicator, 1 indicator */

#define Aoce_charg_assoc_presence	(ns_asn1_optional_indicators + 1)

	/* 'recordedTypeOfUnits' inside RecordedUnits Type : after BillingId
		and chargingAssociation indicators, NS_AOC_MX_RECORDED_UNITS indicators */

#define Aoc_type_of_unit_presence	(ns_asn1_optional_indicators + 2)

	/* 'dGranularity' inside DurationCurrency Type : NS_AOC_MX_AOCS_CURRENCY_INFO indicators */

#define Aoc_dgranularity_presence	ns_asn1_optional_indicators

		/* 		same data type as RecordedCurrency :
		 * FlatRateCurrency ::= SEQUENCE {fRCurrency [1] Currency,
		 *								  fRAmount [2] Amount}
		 */

#define NS_AOC_FLAT_RATE_CURRENCY_P		NS_AOC_RECORDED_CURRENCY_P

		/* dChargingType is the same data type as vRVolumeUnit */

#define NS_AOC_DCHARGING_TYPE_P		NS_AOC_RVOLUME_UNIT_P

#endif	/* end of AOC service supported} */

#if (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)	/* AOC-D or AOC-E SS supported{ */

		/* typeofChargingInfo is the same data type as Scale */

#define NS_AOCD_TYPE_OF_CHARG_INFO_P	NS_AOC_SCALE_MULTIPLIER_P

		/* aOCDBillingId is the same data type as vRVolumeUnit */

#define NS_AOCD_BILLING_ID_P			NS_AOC_RVOLUME_UNIT_P

#endif	/* end of AOC-D or AOC-E SS supported} */

#if NS_SS_AOC_E == ON	/* AOC-E SS supported{ */

		/* recordedCurrency is the same data type in AOCD and AOCE Types */

#define NS_AOCE_RECORDED_CURRENCY_P		NS_AOCD_RECORDED_CURRENCY_P

		/* aOCEBillingId is the same data type as Scale */

#define NS_AOCE_BILLING_ID_P			NS_AOC_SCALE_MULTIPLIER_P

		/* freeOfCharge is the same data type in AOCD and AOCE Types */

#define NS_AOCE_FREE_OF_CHARGE_P		NS_AOCD_FREE_OF_CHARGE_P

		/* recordedUnitsList is the same data type in AOCD and AOCE Types */

#define NS_AOCE_RECORDED_UNIT_LIST_P	NS_AOCD_RECORDED_UNIT_LIST_P

#if (NS_SS_INTERACTIONS == ON) && ((NS_SS_DIVERSION == ON) || (NS_SS_ECT == ON))	/* SS interactions and (Diversion or ECT SS) supported */

		/* IdentificationOfCharge operation ARGUMENT = ChargingAssociation */

#define NS_INTER_ID_OF_CHARG_ARG_P		NS_AOC_CHARGING_ASSOCIATION_P

#endif	/* end of SS interactions and (Diversion or ECT SS) supported */

#endif	/* end of AOC-E SS supported} */

		/*	Operations for AOC SS : ChargingRequest, AOCSCurrency, AOCSSpecialArr,
		 *	AOCDCurrency, AOCDChargingUnit, AOCECurrency and AOCEChargingunit
		 * ------------------------------------------------------------------ */

			/* operation values (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_CHARGING_RQ				30		/* Charging Request */
#define NS_OP_VAL_AOCS_CURRENCY				31		/* AOC-S given in currency units */
#define NS_OP_VAL_AOCS_SPECIAL_ARR			32		/* AOC-S for special charging arrangement */
#define NS_OP_VAL_AOCD_CURRENCY				33		/* AOC-D given in currency units */
#define NS_OP_VAL_AOCD_CHARGING_UNIT		34		/* AOC-D given in charging units */
#define NS_OP_VAL_AOCE_CURRENCY				35		/* AOC-E given in currency units */
#define NS_OP_VAL_AOCE_CHARGING_UNIT		36		/* AOC-E given in charging units */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)

	/* ChargingRequest operation : ARGUMENT */

uchar	ns_aoc_op_charging_case [NS_SS_MAX_AOC_CHARGING_RQ];		/* ChargingCase : ENUMERATED {0, 1, 2} */

	/* ChargingRequest operation : RESULT */

struct ns_i_aocs_currency_info {			/* AOCSCurrencyInfo internal data structure */
	uchar					charged_item;					/* chargedItem : ENUMERATED {0, 1, 2, 3, 4} */
	uchar					currency_info_type;				/* type of currency info provided in the CHOICE Type (durationCurrency, freeOfCharge, ...) */
	uchar					special_charging_code;			/* specialChargingCode : INTEGER (1..10) */
	struct ns_asn1_string	currency;						/* Currency string (IA5 characters) */
	ulong					amount;							/* currencyAmount inside Amount : INTEGER(0..16777215) */
	uchar					amount_multiplier;				/* multiplier inside Amount : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
	uchar					volume_unit_or_charg_type;		/* vRVolumeUnit inside VolumeRateCurrency : ENUMERATED {0, 1, 2} or
															   dChargingType inside DurationCurrency : ENUMERATED {0, 1} */
	ulong					length_of_time_unit;			/* lengthOfTimeUnit inside dTime : INTEGER (0..16777215) */
	uchar					scale;							/* scale inside dTime : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
	ulong					granularity_lg_time_u;			/* lengthOfTimeUnit inside dGranularity : INTEGER (0..16777215) */
	uchar					granularity_scale;				/* scale inside dGranularity : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
};

struct	ns_aoc_op_charging_rq {
	uchar						result_type;					/* index of chosen type in RESULT (CHOICE) */
	uchar						aocs_special_arr_info;			/* AOCSSpecialArrInfo in RESULT : INTEGER (1..10) */
	uchar						aocs_cur_info_nb;				/* number of AOCSCurrencyInfo in AOCSCurrencyInfoList in RESULT */
	struct ns_i_aocs_currency_info	aocs_cur_info_list[NS_AOC_MX_AOCS_CURRENCY_INFO];		/* AOCSCurrencyInfoList in RESULT : SEQUENCE SIZE (1..10) OF AOCSCurrencyInfo */

} ns_aoc_op_charging_rq;

#endif

#if NS_SS_AOC_S == ON

	/* AOCSCurrency operation : ARGUMENT */

struct	ns_op_aocs_currency {
	uchar						arg_type;						/* index of chosen type in ARGUMENT (CHOICE) */
	uchar						info_nb;						/* number of AOCSCurrencyInfo in AOCSCurrencyInfoList in RESULT */
	struct ns_i_aocs_currency_info	info_list[NS_AOC_MX_AOCS_CURRENCY_INFO];	/* AOCSCurrencyInfoList in RESULT : SEQUENCE SIZE (1..10) OF AOCSCurrencyInfo */

} ns_op_aocs_currency;

	/* AOCSSpecialArr operation : ARGUMENT */

struct	ns_op_aocs_special_arr {
	uchar	arg_type;				/* index of chosen type in ARGUMENT (CHOICE) */
	uchar	special_arr_info;		/* AOCSSpecialArrInfo : INTEGER (1..10) */

} ns_op_aocs_special_arr;

#endif

#if (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)

struct ns_i_recorded_units {	/* RecordedUnits internal data structure */
	uchar	type_of_unit;				/* recordedTypeOfUnits : INTEGER (1..16) */
	uchar	number_availability;		/* index of chosen type in CHOICE (notAvailable or number of units) */
	ulong	number_of_units;			/* recordedNumberOfUnits : INTEGER (0..16777215) */
};

#endif

#if NS_SS_AOC_D == ON

	/* AOCDCurrency operation : ARGUMENT */

struct	ns_op_aocd_currency {
	uchar					arg_type;						/* index of chosen type in ARGUMENT (CHOICE) */
	uchar					type_of_charging;				/* type of charging information (in specificCurrency) : ENUMERATED {0, 1} */
	struct ns_asn1_string	currency;						/* Currency string (IA5 characters) */
	ulong					amount;							/* currencyAmount inside Amount : INTEGER(0..16777215) */
	uchar					amount_multiplier;				/* multiplier inside Amount : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
	uchar					billing_id;						/* AOCD Billing ID (in specificCurrency) : ENUMERATED {0, 1, 2} or 255 if absent */

} ns_op_aocd_currency;

	/* AOCDChargingUnit operation : ARGUMENT */

struct	ns_op_aocd_charging_unit {
	uchar						arg_type;					/* index of chosen type in ARGUMENT (CHOICE) */
	uchar						type_of_charging;			/* type of charging information (in specificChargingUnits) : ENUMERATED {0, 1} */
	uchar						billing_id;					/* AOCD Billing ID (in specificChargingUnits) : ENUMERATED {0, 1, 2} or 255 if absent */
	uchar						unit_nb;					/* number of RecordedUnits in recordedUnitsList */
	struct ns_i_recorded_units	recorded_units_list[NS_AOC_MX_RECORDED_UNITS];	/* recordedUnitsList in specificChargingUnits : SEQUENCE SIZE (1..32) OF RecordedUnits */

} ns_op_aocd_charging_unit;

#endif

#if NS_SS_AOC_E == ON

	/* AOCECurrency operation : ARGUMENT */

struct	ns_op_aoce_currency {
	uchar					arg_type;						/* index of chosen type in ARGUMENT (CHOICE) */
	uchar					charg_type;						/* index of chosen type in AOCECurrencyInfo CHOICE (freeOfCharge or specificCurrency) */
	struct ns_asn1_string	currency;						/* Currency string (IA5 characters) */
	ulong					amount;							/* currencyAmount inside Amount : INTEGER(0..16777215) */
	uchar					amount_multiplier;				/* multiplier inside Amount : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
	uchar					billing_id;						/* AOCE Billing ID (in specificCurrency) : ENUMERATED {0, 1, 2, 3, 4, 5, 6, 7} or 255 if absent */
	uchar					charg_assoc_type;				/* index of chosen type in ChargingAssociation or 255 if absent */
	short					charg_identifier;				/* chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767) */
	uchar					party_nb_type;					/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) */
	uchar					type_of_nb;						/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	struct ns_asn1_string	number_digits;					/* NumberDigits string inside PartyNumber */

} ns_op_aoce_currency;

	/* AOCEChargingUnit operation : ARGUMENT */

struct	ns_op_aoce_charging_unit {
	uchar						arg_type;					/* index of chosen type in ARGUMENT (CHOICE) */
	uchar						charg_type;					/* index of chosen type in AOCEChargingUnitInfo CHOICE (freeOfCharge or specificChargingUnits) */
	uchar						billing_id;					/* AOCE Billing ID (in specificChargingUnits) : ENUMERATED {0, 1, 2, 3, 4, 5, 6, 7} or 255 if absent */
	uchar						charg_assoc_type;			/* index of chosen type in ChargingAssociation or 255 if absent */
	short						charg_identifier;			/* chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767) */
	uchar						party_nb_type;				/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) */
	uchar						type_of_nb;					/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	struct ns_asn1_string		number_digits;				/* NumberDigits string inside PartyNumber */
	uchar						unit_nb;					/* number of RecordedUnits in recordedUnitsList */
	struct ns_i_recorded_units	recorded_units_list[NS_AOC_MX_RECORDED_UNITS];	/* recordedUnitsList in specificChargingUnits : SEQUENCE SIZE (1..32) OF RecordedUnits */

} ns_op_aoce_charging_unit;

#if (NS_SS_INTERACTIONS == ON) && ((NS_SS_DIVERSION == ON) || (NS_SS_ECT == ON))	/* SS interactions and (Diversion or ECT SS) supported */

		/* IdentificationOfCharge operation : ARGUMENT */

struct	ns_op_inter_id_of_charg {
	uchar						charg_assoc_type;			/* index of chosen type in ChargingAssociation */
	short						charg_identifier;			/* chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767) */
	uchar						party_nb_type;				/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) */
	uchar						type_of_nb;					/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	struct ns_asn1_string		number_digits;				/* NumberDigits string inside PartyNumber */

} ns_op_inter_id_of_charg;

#endif	/* end of SS interactions and (Diversion or ECT SS) supported */

#endif

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)	/* AOC service supported{ */

	/* ChargingRequest operation ARGUMENT : ChargingCase::= ENUMERATED {chargingInformationAtCallSetup(0), chargingDuringACall(1), ChargingAtTheEndOfACall(2)} */

#define NS_AOC_CHARGING_REQUEST_ARG_P			NS_SS_ENUMERATED_P

#endif	/* end of AOC Service supported} */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* process of AOCSCurrencyInfoList inside operations */

#if NEW_FCT_STYLE == ON

#	if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)
		uchar	ns_ssdu_aocs_cur_info_list	(uchar FAR *p_start, ushort offset, struct ns_i_aocs_currency_info FAR *p_content, uchar FAR *p_nb);
#	endif

#	if (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)
		uchar	ns_ssdu_aoc_recorded_u_list	(uchar FAR *p_start, ushort offset, struct ns_i_recorded_units FAR *p_content, uchar FAR *p_nb);
#	endif
#else

#	if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)
		uchar	ns_ssdu_aocs_cur_info_list	();
#	endif

#	if (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)
		uchar	ns_ssdu_aoc_recorded_u_list	();
#	endif
#endif

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)	/* AOC supported{ */

uchar ns_ssdu_aocs_cur_info_list (p_start, offset, p_content, p_nb)
	uchar FAR							*p_start;			/* pointer to start of component */
	ushort								offset;						/* offset of first AOCSCurrencyInfo instance in received SSDU */
	struct ns_i_aocs_currency_info FAR	*p_content;					/* pointer to AOCSCurrencyInfo internal data */
	uchar FAR							*p_nb;						/* pointer to internal data location for number of instances */
{
	uchar FAR							*p_next;					/* pointer to next data location for "p_ssdu_val" */
	uchar								size;						/* current size */
	struct ns_i_aocs_currency_info FAR	*p_spec_ch_code;			/* pointer to AOCSCurrencyInfo internal data for current instance of "special_charging_code" */
	struct ns_i_aocs_currency_info FAR	*p_duration_cur;			/* pointer to AOCSCurrencyInfo internal data for current instance of fields inside "Duration_currency" only */
	struct ns_i_aocs_currency_info FAR	*p_volume_charg_t_cur;		/* pointer to AOCSCurrencyInfo internal data for current instance of "volumeUnit" or "ChargingType" */
	struct ns_i_aocs_currency_info FAR	*p_specific_cur;			/* pointer to AOCSCurrencyInfo internal data for current instance of other fields inside "specific_currency" */

		/* process all instances of AOCSCurrencyInfo in list */

	if (direction == FROM_CALL_CONTROL) {

		while (offset != OFFSET_NIL) {

			if (*p_nb >= NS_AOC_MX_AOCS_CURRENCY_INFO) {

				return (NOK);	/* too many AOCSCurrencyInfo instances */
			}

			p_next = p_start + offset;						/* get content of current AOCSCurrencyInfo */

			if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

				return (NOK);	/* component data is after end of SSDU or before start of component ! */
			}

			p_ssdu_val = p_next;		/* update SSDU pointer to analyse AOCSCurrencyInfo content */

			p_content -> charged_item = Ns_aocs_curr_charg_item;
			p_content -> currency_info_type = Ns_aocs_curr_info_type;

			switch (Ns_aocs_curr_info_type) {

				case NS_AOCS_FREE_OF_CHARGE :
				case NS_AOCS_INFO_NOT_AVAIL :

					break;	/* no other parameter */

				case NS_AOCS_SPECIAL_CHARGING_CODE :	/* 1 parameter = special charging code */

					p_content -> special_charging_code = Ns_aocs_curr_sp_charg_code;
					break;

				case NS_AOCS_DURATION_CURR_INFO :

					p_content -> length_of_time_unit = Ns_aocs_curr_lg_time_unit;
					p_content -> scale = Ns_aocs_curr_time_scale;

					if ((Ns_aocs_curr_granul_lg_time_u == NS_SS_INT_ULONG_NOT_PROVIDED) || (Ns_aocs_curr_granul_scale == NS_SS_INT_UCHAR_NOT_PROVIDED)) {

						p_content -> granularity_scale = (NS_SS_INT_UCHAR_NOT_PROVIDED - 1);
						p_content -> granularity_lg_time_u = (NS_SS_INT_ULONG_NOT_PROVIDED - 1);

					} else {

						p_content -> granularity_lg_time_u = Ns_aocs_curr_granul_lg_time_u;
						p_content -> granularity_scale = Ns_aocs_curr_granul_scale;
					}

				case NS_AOCS_VOLUME_RATE_CURR_INFO :

					p_content -> volume_unit_or_charg_type = Ns_aocs_curr_volume_unit;

				case NS_AOCS_FLAT_RATE_CURR_INFO :

					p_content -> amount = Ns_aocs_curr_amount;
					p_content -> amount_multiplier = Ns_aocs_curr_amount_multip;
					p_content -> currency.size = size = Ns_aocs_currency_str_size;
					p_content -> currency.p_string = p_ind_buffer;

						/* currency string : at the end of the structure -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_aocs_currency_first_str), size);
					p_ind_buffer += size;
					break;

				default :

					return (NOK);
			}

			offset = Ns_aocs_next_curr_info;	/* get content of next AOCSCurrencyInfo */
			(*p_nb)++;							/* increment number of AOCSCurrencyInfo */
			p_content++;						/* get next AOCSCurrencyInfo internal structure */
		}

	} else {	/* to CALL CONTROL */

		offset = (ushort)(*p_nb);			/* use 'offset' as counter of number of instances */
		p_spec_ch_code = p_content;				/* init pointer for "special_charging_code" */
		p_duration_cur = p_content;				/* init pointer for fields inside "Duration_currency" only */
		p_volume_charg_t_cur = p_content;		/* init pointer for "volumeUnit" or "ChargingType" */
		p_specific_cur = p_content;				/* init pointer for other fields inside "specific_currency" */

		while (offset-- > 0) {

			Ns_aocs_curr_charg_item = p_content -> charged_item;		/* "charged_item" always present */
			Ns_aocs_curr_info_type = p_content -> currency_info_type;	/* "type of currency info" always present */
			Ns_aocs_currency_str_size = size = 0;
			p_next = &(Ns_aocs_currency_first_str);		/* set pointer to end of structure inside SSDU */

				/* set parameters into SSDU according to type of currency info */

			switch (Ns_aocs_curr_info_type) {

				case NS_AOCS_FREE_OF_CHARGE :		/* free of Charge : no other parameter in currency info */
				case NS_AOCS_INFO_NOT_AVAIL :		/* currency information not available : no other parameter in currency info */

					break;

				case NS_AOCS_SPECIAL_CHARGING_CODE :		/* specialChargingCode : only 1 other parameter = special_charging_code */

					Ns_aocs_curr_sp_charg_code = p_spec_ch_code -> special_charging_code;
					p_spec_ch_code++;	/* update pointer for next instance */
					break;

				case NS_AOCS_DURATION_CURR_INFO :		/* specific currency : durationCurrency : process all parameters below (all "case" below) */

					Ns_aocs_curr_lg_time_unit = p_duration_cur -> length_of_time_unit;
					Ns_aocs_curr_time_scale = p_duration_cur -> scale;
					Ns_aocs_curr_granul_lg_time_u = p_duration_cur -> granularity_lg_time_u;
					Ns_aocs_curr_granul_scale = p_duration_cur -> granularity_scale;
					p_duration_cur++;	/* update pointer for next instance */

				case NS_AOCS_VOLUME_RATE_CURR_INFO :		/* specific currency : volumeRateCurrency */

					Ns_aocs_curr_volume_unit = p_volume_charg_t_cur -> volume_unit_or_charg_type;
					p_volume_charg_t_cur++;	/* update pointer for next instance */

				case NS_AOCS_FLAT_RATE_CURR_INFO :		/* specific currency : flatRateCurrency */

					Ns_aocs_curr_amount = p_specific_cur -> amount;
					Ns_aocs_curr_amount_multip = p_specific_cur -> amount_multiplier;
					Ns_aocs_currency_str_size = size = p_specific_cur -> currency.size;

							/* currency string : at the end of the structure */

					Memcpy_far ((char FAR *)p_next, (char FAR *)(p_specific_cur -> currency.p_string), size);
					p_specific_cur++;	/* update pointer for next instance */
					break;
			}

			p_next += size;
			p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */

			if (offset == 0) {

				Ns_aocs_next_curr_info = OFFSET_NIL;

			} else {

				Ns_aocs_next_curr_info = (ushort)(p_next - p_start);
			}

			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			p_content++;			/* get next AOCSCurrencyInfo internal structure */
		}
	}

	return (OK);
}

		/* ChargingRequest operation */

uchar ns_ssdu_op_charging_rq (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR							*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_aoc_op_charging_case[ns_i_ss_clause_nb] = Ns_aoc_charg_rq_case;
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		ns_aoc_op_charging_rq.aocs_cur_info_nb = 0;		/* init number of AOCSCurrencyInfo */

		ns_aoc_op_charging_rq.result_type = Ns_aoc_charg_rq_res_type;
		switch (Ns_aoc_charg_rq_res_type) {

			case NS_AOC_CHARGING_INFO_FOLLOWS :

				return (OK);	/* no other data */

			case NS_AOCS_SPECIAL_ARR_INFO :

				ns_aoc_op_charging_rq.aocs_special_arr_info = Ns_aoc_charg_rq_res_sp_arr_inf;
				return (OK);	/* no other data */

			case NS_AOCS_CURRENCY_INFO_RQ :

				break;	/* list of AocsCurrencyInfo instances processed hereafter */

			default :		/* bad type of result */

				return (NOK);
		}

		if ((offset = Ns_aoc_charg_rq_res_first_cur) == OFFSET_NIL) {

			return (NOK);	/* there should be at least one AOCSCurrencyInfo in list */
		}

			/* process AOCSCurrencyInfoList */

		return (ns_ssdu_aocs_cur_info_list (p_start, offset, &(ns_aoc_op_charging_rq.aocs_cur_info_list [0]),
											&(ns_aoc_op_charging_rq.aocs_cur_info_nb)));

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_aoc_charg_rq_case = ns_aoc_op_charging_case[ns_i_ss_clause_nb];
			p_ssdu_val += Rnd_sizeof (struct ns_aoc_charging_rq_arg);
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_aoc_charg_rq_res_type		= ns_aoc_op_charging_rq.result_type;
		Ns_aoc_charg_rq_res_sp_arr_inf	= ns_aoc_op_charging_rq.aocs_special_arr_info;
		p_next = p_ssdu_val + Rnd_sizeof (struct ns_aoc_charging_rq_res);

		if (ns_aoc_op_charging_rq.aocs_cur_info_nb == 0) {

			Ns_aoc_charg_rq_res_first_cur = OFFSET_NIL;

		} else {

			Ns_aoc_charg_rq_res_first_cur = (ushort)(p_next - p_start);
		}

		p_ssdu_val = p_next;											/* update current SSDU value pointer */

			/* process AOCSCurrencyInfoList */

		ns_ssdu_aocs_cur_info_list (p_start, 0, &(ns_aoc_op_charging_rq.aocs_cur_info_list [0]),
									&(ns_aoc_op_charging_rq.aocs_cur_info_nb));
	}

	return (OK);
}

#endif	/* end of AOC supported} */

#if NS_SS_AOC_S == ON	/* AOC-S SS supported{ */

		/* AOCSCurrency operation */

uchar ns_ssdu_op_aocs_currency (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_aocs_currency.info_nb = 0;		/* init number of AOCSCurrencyInfo */
		ns_op_aocs_currency.arg_type = Ns_aocs_cur_arg_type;

		switch (Ns_aocs_cur_arg_type) {

			case NS_AOCS_CHARG_NOT_AVAIL :

				return (OK);	/* no other data */

			case NS_AOCS_CURRENCY_INFO :

				break;	/* list of AocsCurrencyInfo instances processed hereafter */

			default :		/* bad type of result */

				return (NOK);
		}



		if ((offset = Ns_aocs_cur_arg_first_cur) == OFFSET_NIL) {

			return (NOK);	/* there should be at least one AOCSCurrencyInfo in list */
		}

			/* process AOCSCurrencyInfoList */

		return (ns_ssdu_aocs_cur_info_list (p_start, offset, &(ns_op_aocs_currency.info_list [0]),
											&(ns_op_aocs_currency.info_nb)));

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_aocs_cur_arg_type = ns_op_aocs_currency.arg_type;
		p_next = p_ssdu_val + Rnd_sizeof (struct ns_aocs_currency_arg);

		if (ns_op_aocs_currency.info_nb == 0) {

			Ns_aocs_cur_arg_first_cur = OFFSET_NIL;

		} else {

			Ns_aocs_cur_arg_first_cur = (ushort)(p_next - p_start);
		}

		p_ssdu_val = p_next;										/* update current SSDU value pointer */

			/* process AOCSCurrencyInfoList */

		ns_ssdu_aocs_cur_info_list (p_start, 0, &(ns_op_aocs_currency.info_list [0]),
									&(ns_op_aocs_currency.info_nb));
	}

	return (OK);
}

		/* AOCSSpecialArr operation */

uchar ns_ssdu_op_aocs_special_arr (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR							*p_next;			/* pointer to next data location for "p_ssdu_val" */

		/* only ARGUMENT clause is defined : it should be an Invoke component */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_aocs_special_arr_type > NS_AOCS_SP_ARR_INFO) {	/* check type of ARGUMENT in CHOICE */

			return (NOK);
		}

		ns_op_aocs_special_arr.arg_type = Ns_aocs_special_arr_type;

		if (Ns_aocs_special_arr_type == NS_AOCS_SP_ARR_INFO) {

			ns_op_aocs_special_arr.special_arr_info = Ns_aocs_special_arr_info;
		}

	} else {	/* to CALL CONTROL */

		Ns_aocs_special_arr_type = ns_op_aocs_special_arr.arg_type;
		Ns_aocs_special_arr_info = ns_op_aocs_special_arr.special_arr_info;
		p_ssdu_val += Rnd_sizeof (struct ns_aocs_special_arr_arg);
	}

	return (OK);
}

#endif	/* end of AOC-S SS supported} */

#if NS_SS_AOC_D == ON	/* AOC-D SS supported{ */

		/* AOCDCurrency operation */

uchar ns_ssdu_op_aocd_currency (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_aocd_currency.arg_type = Ns_aocd_curr_arg_type;

		switch (Ns_aocd_curr_arg_type) {

			case NS_AOCD_CHARGE_NOT_AVAILABLE :
			case NS_AOCD_CURR_FREE_OF_CHARGE :

				return (OK);	/* no other data */

			case NS_AOCD_SPECIFIC_CURRENCY :

				break;	/* specificCurrency processed hereafter */

			default :		/* bad type of result */

				return (NOK);
		}

		ns_op_aocd_currency.type_of_charging = Ns_aocd_curr_info_type;
		ns_op_aocd_currency.amount = Ns_aocd_curr_amount;
		ns_op_aocd_currency.amount_multiplier = Ns_aocd_curr_amount_multip;
		if (Ns_aocd_curr_billing_id == NS_SS_INT_UCHAR_NOT_PROVIDED) {

			ns_op_aocd_currency.billing_id = (NS_SS_INT_UCHAR_NOT_PROVIDED - 1);

		} else {

			ns_op_aocd_currency.billing_id = Ns_aocd_curr_billing_id;
		}

		ns_op_aocd_currency.currency.size = size = Ns_aocd_currency_str_size;
		ns_op_aocd_currency.currency.p_string = p_ind_buffer;

			/* currency string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_aocd_currency_first_str), size);
		p_ind_buffer += size;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_aocd_curr_arg_type = ns_op_aocd_currency.arg_type;

		if (Ns_aocd_curr_arg_type != NS_AOCD_SPECIFIC_CURRENCY) {	/* no other data */

			Ns_aocd_currency_str_size = 0;
			p_ssdu_val += Rnd_sizeof (struct ns_aocd_currency_arg);
			return (OK);
		}

			/* type of information is specificCurrency */

		Ns_aocd_curr_info_type = ns_op_aocd_currency.type_of_charging;
		Ns_aocd_curr_amount = ns_op_aocd_currency.amount;
		Ns_aocd_curr_amount_multip = ns_op_aocd_currency.amount_multiplier;
		Ns_aocd_curr_billing_id = ns_op_aocd_currency.billing_id;
		Ns_aocd_currency_str_size = size = ns_op_aocd_currency.currency.size;

				/* currency string : at the end of the structure */

		p_next = &(Ns_aocd_currency_first_str);
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_aocd_currency.currency.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif	/* end of AOC-D SS supported} */

#if (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)	/* AOC-D or AOC-E SS supported{ */

		/* process of RecordedUnitsList inside operations */

uchar ns_ssdu_aoc_recorded_u_list (p_start, offset, p_content, p_nb)
	uchar FAR							*p_start;			/* pointer to start of component */
	ushort								offset;				/* offset of first RecordedUnits instance in received SSDU */
	struct ns_i_recorded_units FAR		*p_content;			/* pointer to RecordedUnits internal data */
	uchar FAR							*p_nb;				/* pointer to internal data location for number of instances */
{
	uchar FAR							*p_next;			/* pointer to next data location for "p_ssdu_val" */
	struct ns_i_recorded_units FAR		*p_nb_of_u;			/* pointer to RecordedUnits internal data for current instance of "type_of_unit" */

		/* process all instances of RecordedUnits in list */

	if (direction == FROM_CALL_CONTROL) {

		while (offset != OFFSET_NIL) {	/* process all instances of RecordedUnit in list */

			if (*p_nb >= NS_AOC_MX_RECORDED_UNITS) {

				return (NOK);	/* too many RecordedUnit instances */
			}

			p_next = p_start + offset;						/* get content of current recorded unit */

			if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

				return (NOK);	/* component data is after end of SSDU or before start of component ! */
			}

			p_ssdu_val = p_next;		/* update SSDU pointer to analyse content of recorded unit */

			if (Ns_aoc_type_of_unit == NS_SS_INT_UCHAR_NOT_PROVIDED) {

				p_content -> type_of_unit = (NS_SS_INT_UCHAR_NOT_PROVIDED - 1);

			} else {

				p_content -> type_of_unit = Ns_aoc_type_of_unit;
			}

			if (Ns_aoc_number_of_units == NS_SS_INT_ULONG_NOT_PROVIDED) {	/* number not provided -> not available */

				p_content -> number_availability = 1;	/* index of notAvailable in NS_AOC_RECORDED_NB_OF_U_P Meta-program */

			} else {	/* number provided -> available */

				p_content -> number_availability = 0;	/* index of recordedNumberOfUnits in NS_AOC_RECORDED_NB_OF_U_P Meta-program */
				p_content -> number_of_units = Ns_aoc_number_of_units;
			}

			(*p_nb)++;							/* increment number of RecordedUnits */
			p_content++;						/* get next RecordedUnit internal structure */
			offset = Ns_aoc_next_unit_info;		/* get content of next RecordedUnit */
		}

	} else {	/* to CALL CONTROL */

		offset = (ushort)(*p_nb);		/* use 'offset' as counter of number of instances */
		p_nb_of_u = p_content;				/* init pointer for current instance of "type_of_unit" */
		while (offset-- > 0) {

			Ns_aoc_type_of_unit = p_content -> type_of_unit;

			if (p_content -> number_availability != 0) {	/* number not provided -> not available */

				Ns_aoc_number_of_units = NS_SS_INT_ULONG_NOT_PROVIDED;

			} else {	/* number provided -> available */

				Ns_aoc_number_of_units = p_nb_of_u -> number_of_units;
                p_nb_of_u++;
			}

			p_next = p_ssdu_val + Rnd_sizeof (struct ns_aoc_recorded_unit);

			if (offset == 0) {

				Ns_aoc_next_unit_info = OFFSET_NIL;

			} else {

				Ns_aoc_next_unit_info = (ushort)(p_next - p_start);
			}

			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			p_content++;			/* get next RecordedUnits internal structure */
		}
	}

	return (OK);
}

#endif	/* end of AOC-D or AOC-E SS supported} */

#if NS_SS_AOC_D == ON	/* AOC-D SS supported{ */

		/* AOCDChargingUnit operation */

uchar ns_ssdu_op_aocd_charging_unit (p_start, offset)
	uchar FAR					*p_start;			/* pointer to start of component */
	ushort						offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_aocd_charging_unit.unit_nb = 0;		/* init number of RecordedUnits */
		ns_op_aocd_charging_unit.arg_type = Ns_aocd_charg_u_arg_type;

		switch (Ns_aocd_charg_u_arg_type) {

			case NS_AOCD_CHARGING_NOT_AVAILABLE :
			case NS_AOCD_FREE_OF_CHARGE :

				return (OK);	/* no other data */

			case NS_AOCD_SPECIFIC_CHARGING_UNIT :

				break;	/* specificChargingUnit processed hereafter */

			default :		/* bad type of result */

				return (NOK);
		}

		ns_op_aocd_charging_unit.type_of_charging = Ns_aocd_charg_u_info_type;
		if (Ns_aocd_charg_u_billing_id == NS_SS_INT_UCHAR_NOT_PROVIDED) {

			ns_op_aocd_charging_unit.billing_id = (NS_SS_INT_UCHAR_NOT_PROVIDED - 1);

		} else {

			ns_op_aocd_charging_unit.billing_id = Ns_aocd_charg_u_billing_id;
		}

			/* process recordedUnitsList */

		if ((offset = Ns_aocd_charg_u_first_unit) == OFFSET_NIL) {

			return (NOK);	/* there should be at least one RecordedUnit in list */
		}

		return (ns_ssdu_aoc_recorded_u_list (p_start, offset, &(ns_op_aocd_charging_unit.recorded_units_list [0]),
											 &(ns_op_aocd_charging_unit.unit_nb)));

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_aocd_charg_u_arg_type = ns_op_aocd_charging_unit.arg_type;

		if (Ns_aocd_charg_u_arg_type != NS_AOCD_SPECIFIC_CHARGING_UNIT) {	/* no other data */

			Ns_aocd_charg_u_first_unit = OFFSET_NIL;
			p_ssdu_val += Rnd_sizeof (struct ns_aocd_charging_unit_arg);
			return (OK);
		}

			/* type of information is specificChargingUnits */

		Ns_aocd_charg_u_info_type = ns_op_aocd_charging_unit.type_of_charging;
		Ns_aocd_charg_u_billing_id = ns_op_aocd_charging_unit.billing_id;

		p_next = p_ssdu_val + Rnd_sizeof (struct ns_aocd_charging_unit_arg);

		if (ns_op_aocd_charging_unit.unit_nb == 0) {

			Ns_aocd_charg_u_first_unit = OFFSET_NIL;

		} else {

			Ns_aocd_charg_u_first_unit = (ushort)(p_next - p_start);
		}

		p_ssdu_val = p_next;										/* update current SSDU value pointer */

			/* process recordedUnitsList */

		ns_ssdu_aoc_recorded_u_list (p_start, 0, &(ns_op_aocd_charging_unit.recorded_units_list [0]),
									 &(ns_op_aocd_charging_unit.unit_nb));
	}

	return (OK);
}

#endif	/* end of AOC-D SS supported} */

#if NS_SS_AOC_E == ON	/* AOC-E SS supported{ */

		/* AOCECurrency operation */

uchar ns_ssdu_op_aoce_currency (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR				*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar					size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		switch (Ns_aoce_curr_arg_type) {

			case NS_AOCE_CHARGE_NOT_AVAILABLE :

				ns_op_aoce_currency.arg_type = 0;	/* index in CHOICE for chargeNotAvailable */
				return (OK);	/* no other data */

			case NS_AOCE_CURR_FREE_OF_CHARGE :	/* freeOfCharge : ChargingAssociation processed hereafter */

				ns_op_aoce_currency.charg_type = 0;	/* index in AOCECurrencyInfo CHOICE */
				size = 0;	/* set size of Currency string (meaningless) to 0 to avoid further mis-use */
				break;

			case NS_AOCE_SPECIFIC_CURRENCY :

				ns_op_aoce_currency.charg_type = 1;	/* index in AOCECurrencyInfo CHOICE */
				size = Ns_aoce_currency_str_size;	/* set size of Currency string */
				break;	/* specificCurrency processed hereafter */

			default :		/* bad type of result */

				return (NOK);
		}

		ns_op_aoce_currency.arg_type = 1;	/* index in CHOICE indicating 'AOCECurrencyInfo' */

			/* process ChargingAssociation */

		ns_op_aoce_currency.charg_assoc_type = Ns_aoce_curr_charg_assoc_type;
		switch (Ns_aoce_curr_charg_assoc_type) {

			case 255 :	/* chargingAssociation is not provided */

				ns_op_aoce_currency.charg_assoc_type = 254;	/* set it to 254 so that it is marked 'ABSENT' in array of optional indicators */
				break;

			case NS_AOCE_ASSOC_CHARG_ID :		/* type is chargeIdentifier : process only charg_identifier */

				ns_op_aoce_currency.charg_identifier = Ns_aoce_curr_charg_id;
				break;

			case NS_AOCE_ASSOC_CHARG_NUMBER :	/* type is chargeNumber */

				if (Ns_aoce_curr_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_aoce_currency.party_nb_type = Ns_aoce_curr_party_nb_type;
				ns_op_aoce_currency.type_of_nb = Ns_aoce_curr_type_of_nb;
				ns_op_aoce_currency.number_digits.size = Ns_aoce_curr_nb_digits_size;

					/*  NumberDigits string : at the end of the structure, after currency string -> copy it into indirect buffer */

				ns_op_aoce_currency.number_digits.p_string = &(Ns_aoce_currency_first_str) + size;
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)ns_op_aoce_currency.number_digits.p_string, Ns_aoce_curr_nb_digits_size);
				ns_op_aoce_currency.number_digits.p_string = p_ind_buffer;
				p_ind_buffer += Ns_aoce_curr_nb_digits_size;
				break;

			default :		/* bad type of chargingAssociation */

				return (NOK);
		}

		if (ns_op_aoce_currency.charg_type == 0) {

			return (OK);	/* type is freeOfCharge : no other data */
		}

			/* type is specificCurrency */

		ns_op_aoce_currency.amount = Ns_aoce_curr_amount;
		ns_op_aoce_currency.amount_multiplier = Ns_aoce_curr_amount_multip;
		if (Ns_aoce_curr_billing_id == NS_SS_INT_UCHAR_NOT_PROVIDED) {

			ns_op_aoce_currency.billing_id = (NS_SS_INT_UCHAR_NOT_PROVIDED - 1);

		} else {

			ns_op_aoce_currency.billing_id = Ns_aoce_curr_billing_id;
		}

		ns_op_aoce_currency.currency.size = size;
		ns_op_aoce_currency.currency.p_string = p_ind_buffer;

			/* currency string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_aoce_currency_first_str), size);
		p_ind_buffer += size;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (ns_op_aoce_currency.arg_type == 0) {	/* index in CHOICE for chargeNotAvailable */

			Ns_aoce_curr_arg_type = NS_AOCE_CHARGE_NOT_AVAILABLE;
			p_ssdu_val++;
			p_ssdu_val = (uchar FAR *)Round ((long)p_ssdu_val);		/* Structure alignment */
			return (OK);	/* no other data */
		}

			/* process ChargingAssociation parameters */

		Ns_aoce_curr_charg_assoc_type = ns_op_aoce_currency.charg_assoc_type;
		Ns_aoce_curr_charg_id = ns_op_aoce_currency.charg_identifier;
		Ns_aoce_curr_party_nb_type = ns_op_aoce_currency.party_nb_type;
		Ns_aoce_curr_type_of_nb = ns_op_aoce_currency.type_of_nb;
		Ns_aoce_curr_nb_digits_size = ns_op_aoce_currency.number_digits.size;
		p_next = &(Ns_aoce_currency_first_str);

		if (ns_op_aoce_currency.charg_type == 1) {

			Ns_aoce_curr_arg_type = NS_AOCE_SPECIFIC_CURRENCY;		/* specificCurrency */
			Ns_aoce_curr_amount = ns_op_aoce_currency.amount;
			Ns_aoce_curr_amount_multip = ns_op_aoce_currency.amount_multiplier;
			Ns_aoce_curr_billing_id = ns_op_aoce_currency.billing_id;

					/* currency string : at the end of the structure */

			Ns_aoce_currency_str_size = size = ns_op_aoce_currency.currency.size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_aoce_currency.currency.p_string, size);
			p_next += size;

		} else {

			Ns_aoce_currency_str_size = 0;
			Ns_aoce_curr_arg_type = NS_AOCE_CURR_FREE_OF_CHARGE;	/* freeOfCharge */
		}

			/*  NumberDigits string : at the end of the structure, after currency string,
				present only if type of ChargingAssociation is 'chargeNumber' */

		if (Ns_aoce_curr_charg_assoc_type == NS_AOCE_ASSOC_CHARG_NUMBER) {

			Ns_aoce_curr_nb_digits_size = size = ns_op_aoce_currency.number_digits.size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_aoce_currency.number_digits.p_string, size);
			p_next += size;

		} else {

			Ns_aoce_curr_nb_digits_size = 0;
		}

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* AOCEChargingUnit operation */

uchar ns_ssdu_op_aoce_charging_unit (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		switch (Ns_aoce_charg_u_arg_type) {

			case NS_AOCE_CHARGING_NOT_AVAILABLE :

				ns_op_aoce_charging_unit.arg_type = 0;	/* index in CHOICE for chargeNotAvailable */
				return (OK);	/* no other data */

			case NS_AOCE_FREE_OF_CHARGE :	/* freeOfCharge : ChargingAssociation processed hereafter */

				ns_op_aoce_charging_unit.charg_type = 0;	/* index in AOCEChargingUnitInfo CHOICE */
				break;

			case NS_AOCE_SPECIFIC_CHARGING_UNIT :

				ns_op_aoce_charging_unit.charg_type = 1;	/* index in AOCEChargingUnitInfo CHOICE */
				break;	/* specificChargingUnits processed hereafter */

			default :		/* bad type of result */

				return (NOK);
		}

		ns_op_aoce_charging_unit.arg_type = 1;	/* index in CHOICE indicating 'AOCEChargingUnitInfo' */

			/* process ChargingAssociation */

		ns_op_aoce_charging_unit.charg_assoc_type = Ns_aoce_charg_u_assoc_type;
		switch (Ns_aoce_charg_u_assoc_type) {

			case 255 :	/* chargingAssociation is not provided */

				ns_op_aoce_charging_unit.charg_assoc_type = 254;	/* set it to 254 so that it is marked 'ABSENT' in array of optional indicators */
				break;

			case NS_AOCE_ASSOC_CHARG_ID :		/* type is chargeIdentifier : process only charg_identifier */

				ns_op_aoce_charging_unit.charg_identifier = Ns_aoce_charg_u_charg_id;
				break;

			case NS_AOCE_ASSOC_CHARG_NUMBER :	/* type is chargeNumber */

				if (Ns_aoce_charg_u_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_aoce_charging_unit.party_nb_type = Ns_aoce_charg_u_party_nb_type;
				ns_op_aoce_charging_unit.type_of_nb = Ns_aoce_charg_u_type_of_nb;
				ns_op_aoce_charging_unit.number_digits.size = size = Ns_aoce_charg_u_nb_digits_size;
				ns_op_aoce_charging_unit.number_digits.p_string = p_ind_buffer;

					/* NumberDigits string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_aoce_charg_u_first_dig), size);
				p_ind_buffer += size;
				break;

			default :		/* bad type of chargingAssociation */

				return (NOK);
		}

		if (ns_op_aoce_charging_unit.charg_type == 0) {

			return (OK);	/* type is freeOfCharge : no other data */
		}

			/* type is specificChargingUnits */

		if (Ns_aoce_charg_u_billing_id == NS_SS_INT_UCHAR_NOT_PROVIDED) {

			ns_op_aoce_charging_unit.billing_id = (NS_SS_INT_UCHAR_NOT_PROVIDED - 1);

		} else {

			ns_op_aoce_charging_unit.billing_id = Ns_aoce_charg_u_billing_id;
		}

			/* process recordedUnitsList */

		ns_op_aoce_charging_unit.unit_nb = 0;		/* init number of RecordedUnits */

		if ((offset = Ns_aoce_charg_u_first_unit) == OFFSET_NIL) {

			return (NOK);	/* there should be at least one RecordedUnit in list */
		}

		return (ns_ssdu_aoc_recorded_u_list (p_start, offset, &(ns_op_aoce_charging_unit.recorded_units_list [0]),
											 &(ns_op_aoce_charging_unit.unit_nb)));

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (ns_op_aoce_charging_unit.arg_type == 0) {	/* index in CHOICE for chargeNotAvailable */

			Ns_aoce_charg_u_arg_type = NS_AOCE_CHARGING_NOT_AVAILABLE;
			p_ssdu_val++;
			p_ssdu_val = (uchar FAR *)Round ((long)p_ssdu_val);		/* Structure alignment */
			return (OK);	/* no other data */
		}

			/* process ChargingAssociation parameters */

		Ns_aoce_charg_u_assoc_type = ns_op_aoce_charging_unit.charg_assoc_type;
		Ns_aoce_charg_u_charg_id = ns_op_aoce_charging_unit.charg_identifier;
		Ns_aoce_charg_u_party_nb_type = ns_op_aoce_charging_unit.party_nb_type;
		Ns_aoce_charg_u_type_of_nb = ns_op_aoce_charging_unit.type_of_nb;
		p_next = &(Ns_aoce_charg_u_first_dig);

		if (ns_op_aoce_charging_unit.charg_type == 1) {

			Ns_aoce_charg_u_arg_type = NS_AOCE_SPECIFIC_CHARGING_UNIT;		/* specificChargingUnits */
			Ns_aoce_charg_u_billing_id = ns_op_aoce_charging_unit.billing_id;

		} else {

			Ns_aoce_charg_u_arg_type = NS_AOCE_FREE_OF_CHARGE;	/* freeOfCharge */
		}

			/*  NumberDigits string : at the end of the structure, present only if type of ChargingAssociation is 'chargeNumber' */

		if (Ns_aoce_charg_u_assoc_type == NS_AOCE_ASSOC_CHARG_NUMBER) {

			Ns_aoce_charg_u_nb_digits_size = size = ns_op_aoce_charging_unit.number_digits.size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_aoce_charging_unit.number_digits.p_string, size);
			p_next += size;

		} else {

			Ns_aoce_charg_u_nb_digits_size = 0;
		}

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */

		if (Ns_aoce_charg_u_arg_type != NS_AOCE_SPECIFIC_CHARGING_UNIT) {	/* no other data */

			Ns_aoce_charg_u_first_unit = OFFSET_NIL;
			p_ssdu_val = p_next;	/* update SSDU pointer */
			return (OK);
		}

			/* type of information is specificChargingUnits */

		if (ns_op_aoce_charging_unit.unit_nb == 0) {

			Ns_aoce_charg_u_first_unit = OFFSET_NIL;

		} else {

			Ns_aoce_charg_u_first_unit = (ushort)(p_next - p_start);
		}

		p_ssdu_val = p_next;		/* update current SSDU value pointer */

			/* process recordedUnitsList */

		ns_ssdu_aoc_recorded_u_list (p_start, 0, &(ns_op_aoce_charging_unit.recorded_units_list [0]),
									 &(ns_op_aoce_charging_unit.unit_nb));
	}

	return (OK);
}

#if (NS_SS_INTERACTIONS == ON) && ((NS_SS_DIVERSION == ON) || (NS_SS_ECT == ON))	/* SS interactions and (Diversion or ECT SS) supported{ */

		/* IdentificationOfCharge operation */

uchar ns_ssdu_op_inter_id_of_charg (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_inter_id_of_charg.charg_assoc_type = Ns_inter_id_charg_assoc_type;
		switch (Ns_inter_id_charg_assoc_type) {

			case NS_AOCE_ASSOC_CHARG_ID :		/* type is chargeIdentifier : process only charg_identifier */

				ns_op_inter_id_of_charg.charg_identifier = Ns_inter_id_charg_id;
				break;

			case NS_AOCE_ASSOC_CHARG_NUMBER :	/* type is chargeNumber */

				if (Ns_inter_id_charg_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_inter_id_of_charg.party_nb_type = Ns_inter_id_charg_p_nb_type;
				ns_op_inter_id_of_charg.type_of_nb = Ns_inter_id_charg_type_of_nb;
				ns_op_inter_id_of_charg.number_digits.size = size = Ns_inter_id_charg_nb_sz;
				ns_op_inter_id_of_charg.number_digits.p_string = p_ind_buffer;
					/* NumberDigits string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_inter_id_charg_first_nb), size);
				p_ind_buffer += size;
				break;

			default :		/* bad type of chargingAssociation */

				return (NOK);
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_inter_id_charg_assoc_type = ns_op_inter_id_of_charg.charg_assoc_type;
		Ns_inter_id_charg_id = ns_op_inter_id_of_charg.charg_identifier;
		Ns_inter_id_charg_p_nb_type = ns_op_inter_id_of_charg.party_nb_type;
		Ns_inter_id_charg_type_of_nb = ns_op_inter_id_of_charg.type_of_nb;
		p_next = &(Ns_inter_id_charg_first_nb);

			/*  NumberDigits string : at the end of the structure, present only if type of ChargingAssociation is 'chargeNumber' */

		if (Ns_inter_id_charg_assoc_type == NS_AOCE_ASSOC_CHARG_NUMBER) {

			Ns_inter_id_charg_nb_sz = size = ns_op_inter_id_of_charg.number_digits.size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_inter_id_of_charg.number_digits.p_string, size);
			p_next += size;

		} else {

			Ns_inter_id_charg_nb_sz = 0;
		}

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;		/* update current SSDU value pointer */
	}

	return (OK);
}

#endif	/* end of "SS interactions and (Diversion or ECT SS) supported"} */

#endif	/* end of AOC-E SS supported} */

/*==========================================================================*/

		/*	Diversion SS, including 4 services : Call Forwarding Unconditional (CFU),
		 *	Call Forwarding Busy (CFB), Call Forwarding No Reply (CFNR), Call Deflection (CD)
		 *	implementation of general Diversion ASN1 types (with ASN1 meta-programs)
		 * ------------------------------------------------------------------ */

#if NS_SS_DIVERSION == ON /* { */

		/* lists of presence indicators for instances of Types Marked OPTIONAL (or DEFAULT) inside ASN1 SEQUENCE type */

#define Div_interog_basic_service		ns_asn1_optional_indicators					/* 'basicService' inside InterrogationDiversion ARGUMENT : 1 indicator */

#define Div_info_s_user_subadd			(ns_asn1_optional_indicators + 3)			/* 'servedUserSubaddress' inside DiversionInformation ARGUMENT : 1 indicator */
#define Div_info_calling_add			(ns_asn1_optional_indicators + 4)			/* 'callingAddress' inside DiversionInformation ARGUMENT : 1 indicator */
#define Div_info_orig_called_nb			(ns_asn1_optional_indicators + 5)			/* 'originalCalledNr' inside DiversionInformation ARGUMENT : 1 indicator */
#define Div_info_last_nb				(ns_asn1_optional_indicators + 6)			/* 'lastDivertingNr' inside DiversionInformation ARGUMENT : 1 indicator */
#define Div_info_last_reason			(ns_asn1_optional_indicators + 7)			/* 'lastDivertingReason' inside DiversionInformation ARGUMENT : 1 indicator */
#define Div_info_user_info				(ns_asn1_optional_indicators + 8)			/* 'userInfo' inside DiversionInformation ARGUMENT : 1 indicator */

#define Call_defl_pres_allow_to_u		(ns_asn1_optional_indicators + 1)			/* 'presentationAllowedDivertedToUser' inside CallDeflection ARGUMENT : 1 indicator */

#define Call_reroute_subsc_option		(ns_asn1_optional_indicators + 3)			/* 'subscriptionOption' inside CallRerouteing ARGUMENT : 1 indicator */
#define Call_reroute_calling_subadd		(ns_asn1_optional_indicators + 4)			/* 'callingPartySubaddress' inside CallRerouteing ARGUMENT : 1 indicator */

#define Div_leg_info1_diverted_to_nb	ns_asn1_optional_indicators					/* 'divertedToNumber' inside DivertingLegInformation1 ARGUMENT : 1 indicator */

#define Div_leg_info2_diverting_nr		ns_asn1_optional_indicators					/* 'divertingNr' inside DivertingLegInformation2 ARGUMENT : 1 indicator */
#define Div_leg_info2_orig_called_nr	(ns_asn1_optional_indicators + 1)			/* 'originalCalledNr' inside DivertingLegInformation2 ARGUMENT : 1 indicator */

		/* DiversionReason ::= ENUMERATED {unknown(0), cfu(1), cfb(2), cfnr(3), cdAlerting(4), cdImmediate(5)} */

#define NS_DIVERSION_REASON_P		NS_SS_ENUMERATED_P

		/* Procedure ::= ENUMERATED {cfu(0), cfb(1), cfnr(2)} */

#define NS_DIV_PROCEDURE_P			NS_SS_ENUMERATED_P

		/* SubscriptionOption ::= ENUMERATED {noNotification(0), NotificationWithoutDivertedToNr(1), NotificationWithDivertedToNr(2)} */

#define NS_DIV_SUBSCR_OPTION_P		NS_SS_ENUMERATED_P

		/* DiversionCounter ::= INTEGER (1..5) */

#define NS_DIV_COUNTER_P			NS_SS_INTEGER_P

	/* list of presence indicators for instances of 'PartySubaddress' inside forwardedToAddress :
		NS_DIV_MX_INT_RESULT indicators after indicators used for oddCountIndicator inside PartySubaddress */

#define Party_subadd_in_int_res_add		(ns_asn1_optional_indicators + NS_DIV_MX_INT_RESULT)

		/*	Operations for Diversion SS
		 * ---------------------------- */

			/* operation values (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_ACT_DIVERSION				7			/* activation Diversion */
#define NS_OP_VAL_DEA_DIVERSION				8			/* deactivation Diversion */
#define NS_OP_VAL_ACT_STAT_NOTIF_DIV		9			/* activation Status Notification Diversion */
#define NS_OP_VAL_DEACT_STAT_NOTIF_DIV		10			/* deactivation Status Notification Diversion */
#define NS_OP_VAL_INTEROG_DIVERSION			11			/* interrogation Diversion */
#define NS_OP_VAL_INTEROG_SERVED_U_NB		17			/* interrogate Served User Numbers */
#define NS_OP_VAL_DIVERSION_INFO			12			/* diversion Information */
#define NS_OP_VAL_CALL_DEFLECTION			13			/* call Deflection */
#define NS_OP_VAL_CALL_REROUTING			14			/* call Rerouting */
#define NS_OP_VAL_DIVERTING_LEG_INFO_1		18			/* diverting Leg Information 1 */
#define NS_OP_VAL_DIVERTING_LEG_INFO_2		15			/* diverting Leg Information 2 */
#define NS_OP_VAL_DIVERTING_LEG_INFO_3		19			/* diverting Leg Information 3 */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

	/* ActivationDiversion operation : ARGUMENT */

struct	ns_op_div_activation {
	uchar						procedure;					/* procedure in ARGUMENT : ENUMERATED {0, 1, 2} */
	uchar						basic_service;				/* basicService in ARGUMENT : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38} */
	uchar						forw_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside forwardedToAddress */
	uchar						forw_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside forwardedToAddress) */
	struct ns_asn1_string		forw_number_digits;			/* NumberDigits string in PartyNumber inside forwardedToAddress */
	uchar						forw_sub_add_type;			/* index of chosen type in PartySubaddress or 255 if absent (inside forwardedToAddress) */
	uchar						forw_sub_add_odd_count;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside forwardedToAddress) */
	struct ns_asn1_string		forw_sub_address;			/* string in PartySubaddress inside forwardedToAddress */
	uchar						served_user_nr_type;		/* index of chosen type in ServedUserNr (individualNumber, allNumbers) */
	uchar						srv_u_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserNr */
	uchar						srv_u_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr) */
	struct ns_asn1_string		srv_u_number_digits;		/* NumberDigits string in PartyNumber inside servedUserNr */

#if F_QSI == ON	/* Q-SIG specific data : used for ActivateDiversionQ operation */
	uchar						activ_u_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside activatingUserNr */
	uchar						activ_u_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside activatingUserNr) */
	struct ns_asn1_string		activ_u_number_digits;		/* NumberDigits string in PartyNumber inside activatingUserNr */
	struct ns_asn1_string		extension;					/* extension string */
#endif

} ns_op_div_activation;

	/* DeactivationDiversion operation : ARGUMENT */

struct	ns_op_div_deactivation {
	uchar						procedure;					/* procedure in ARGUMENT : ENUMERATED {0, 1, 2} */
	uchar						basic_service;				/* basicService in ARGUMENT : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38} */
	uchar						served_user_nr_type;		/* index of chosen type in ServedUserNr (individualNumber, allNumbers) */
	uchar						srv_u_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserNr */
	uchar						srv_u_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr) */
	struct ns_asn1_string		srv_u_number_digits;		/* NumberDigits string in PartyNumber inside servedUserNr */

#if F_QSI == ON	/* Q-SIG specific data : used for DeactivateDiversionQ operation */
	uchar						dea_u_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside deactivatingUserNr */
	uchar						dea_u_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside deactivatingUserNr) */
	struct ns_asn1_string		dea_u_number_digits;		/* NumberDigits string in PartyNumber inside deactivatingUserNr */
	struct ns_asn1_string		extension;					/* extension string */
#endif

} ns_op_div_deactivation;

	/*	InterrogationDiversion operation : ARGUMENT = same as in DeactivationDiversion operation
		except that basic service is optional (DEFAULT allServices) */

struct ns_op_div_deactivation	ns_op_div_interrogation;

	/*	InterrogationDiversion operation : RESULT = IntResultList */

struct	ns_op_div_interrogation_res {
	uchar					int_result_nb;				/* number of IntResult in IntResultList */
	uchar					procedure[NS_DIV_MX_INT_RESULT];				/* procedure in IntResult : ENUMERATED {0, 1, 2} */
	uchar					basic_service[NS_DIV_MX_INT_RESULT];			/* basicService in IntResult : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38} */
	uchar					served_user_nr_type[NS_DIV_MX_INT_RESULT];		/* index of chosen type in ServedUserNr inside IntResult (individualNumber, allNumbers) */
	uchar					forw_sub_add_type[NS_DIV_MX_INT_RESULT];		/* index of chosen type in PartySubaddress or 255 if absent (inside forwardedToAddress) */
	uchar					forw_sub_add_odd_count[NS_DIV_MX_INT_RESULT];	/* oddCountIndicator in PartySubaddress or 255 if absent (inside forwardedToAddress) */
	uchar					party_nb_type[NS_DIV_MX_INT_RESULT * 2];		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserNr and inside forwardedToAddress */
	uchar					type_of_nb[NS_DIV_MX_INT_RESULT * 2];			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr and inside forwardedToAddress) */
	struct ns_asn1_string	forw_sub_address[NS_DIV_MX_INT_RESULT];			/* string in PartySubaddress inside forwardedToAddress */
	struct ns_asn1_string	number_digits[NS_DIV_MX_INT_RESULT * 2];		/* NumberDigits string in PartyNumber inside servedUserNr and inside forwardedToAddress */

#if F_QSI == ON	/* Q-SIG specific data : used for InterrogateDiversionQ operation. 'served_user_nr_type' field above is used for "remoteEnabled" values */
	struct ns_asn1_string	extension[NS_DIV_MX_INT_RESULT];				/* extension string in IntResult */
#endif

} ns_op_div_interrogation_res;

	/* InterrogateServedUserNumbers operation : RESULT = ServedUserNumberList */

#if NS_USE_EUROPE_OPERATION == ON

struct	ns_op_div_interog_s_u_nb {
	uchar					nb_of_party_nb;									/* number of PartyNumber in ServedUserNumberList */
	uchar					party_nb_type[NS_DIV_MX_USER_NUMBERS];			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) */
	uchar					type_of_nb[NS_DIV_MX_USER_NUMBERS];				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	struct ns_asn1_string	number_digits[NS_DIV_MX_USER_NUMBERS];			/* NumberDigits string in PartyNumber */

} ns_op_div_interog_s_u_nb;

	/* DiversionInformation operation : ARGUMENT */

struct	ns_op_div_information {
	uchar					reason;						/* diversion reason in ARGUMENT : ENUMERATED {0, 1, .. , 5} */
	uchar					basic_service;				/* basicService in ARGUMENT : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38} */
	uchar					srv_u_sub_add_type;			/* index of chosen type in PartySubaddress or 255 if absent (inside servedUserSubaddress) */
	uchar					srv_u_sub_add_odd_count;	/* oddCountIndicator in PartySubaddress or 255 if absent (inside servedUserSubaddress) */
	struct ns_asn1_string	srv_u_sub_address;			/* string in PartySubaddress inside servedUserSubaddress */
	uchar					calling_a_presented_type;	/* index of chosen type in PresentedAddressScreened (presentationAllowedAddress .. presentationRestrictedAddress) inside callingAddress */
	uchar					calling_a_screening_ind;	/* ScreeningIndicator in AddressScreened inside callingAddress : ENUMERATED {0, 1, 2, 3} */
	uchar					calling_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside callingAddress */
	uchar					calling_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside callingAddress) */
	struct ns_asn1_string	calling_number_digits;		/* NumberDigits string in PartyNumber inside callingAddress */
	uchar					calling_sub_add_type;		/* index of chosen type in PartySubaddress or 255 if absent (inside callingAddress) */
	uchar					calling_sub_add_odd_count;	/* oddCountIndicator in PartySubaddress or 255 if absent (inside callingAddress) */
	struct ns_asn1_string	calling_sub_address;		/* string in PartySubaddress inside callingAddress */
	uchar					orig_presented_nb_type;		/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside originalCalledNr */
	uchar					orig_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside originalCalledNr */
	uchar					orig_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originalCalledNr) */
	struct ns_asn1_string	orig_number_digits;			/* NumberDigits string in PartyNumber inside originalCalledNr */
	uchar					last_presented_nb_type;		/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside lastDivertingNr */
	uchar					last_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside lastDivertingNr */
	uchar					last_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside lastDivertingNr) */
	struct ns_asn1_string	last_number_digits;			/* NumberDigits string in PartyNumber inside lastDivertingNr */
	uchar					last_divert_reason;			/* last diverting reason in ARGUMENT : ENUMERATED {0, 1, .. , 5} or 255 if absent */
	struct ns_asn1_string	q931_user_info;				/* Q931 User Info IE string */

} ns_op_div_information;

	/* CallDeflection operation : ARGUMENT */

struct	ns_op_div_deflection {
	uchar						party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside deflectionAddress */
	uchar						type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside deflectionAddress) */
	struct ns_asn1_string		number_digits;			/* NumberDigits string in PartyNumber inside deflectionAddress */
	uchar						sub_add_type;			/* index of chosen type in PartySubaddress or 255 if absent (inside deflectionAddress) */
	uchar						sub_add_odd_count;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside deflectionAddress) */
	struct ns_asn1_string		sub_address;			/* string in PartySubaddress inside deflectionAddress */
	uchar						pres_allow_div_to_user;	/* presentationAllowedDivertedToUser or 255 if absent */

} ns_op_div_deflection;

#endif

	/* CallRerouteing operation : ARGUMENT */

struct	ns_op_div_rerouteing {
	uchar					reason;						/* rerouteing reason in ARGUMENT : ENUMERATED {0, 1, .. , 5} */
	uchar					counter;					/* rerouteing counter in ARGUMENT : INTEGER (1..5) */
	uchar					called_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside calledAddress */
	uchar					called_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside calledAddress) */
	struct ns_asn1_string	called_number_digits;		/* NumberDigits string in PartyNumber inside calledAddress */
	uchar					called_sub_add_type;		/* index of chosen type in PartySubaddress or 255 if absent (inside calledAddress) */
	uchar					called_sub_add_odd_count;	/* oddCountIndicator in PartySubaddress or 255 if absent (inside calledAddress) */
	struct ns_asn1_string	called_sub_address;			/* string in PartySubaddress inside calledAddress */
	struct ns_asn1_string	q931_ie;					/* Q931 IE string */
	uchar					subscription_option;		/* subscriptionOption in ARGUMENT : ENUMERATED {0, 1, 2} or 255 if absent */
	uchar					last_presented_nb_type;		/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside lastRerouteingNr */
	uchar					last_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside lastRerouteingNr */
	uchar					last_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside lastRerouteingNr) */
	struct ns_asn1_string	last_number_digits;			/* NumberDigits string in PartyNumber inside lastRerouteingNr */
	uchar					calling_sub_add_type;		/* index of chosen type in PartySubaddress or 255 if absent (inside callingPartySubaddress) */
	uchar					calling_sub_add_odd_count;	/* oddCountIndicator in PartySubaddress or 255 if absent (inside callingPartySubaddress) */
	struct ns_asn1_string	calling_sub_address;		/* string in PartySubaddress inside callingPartySubaddress */

#if F_QSI == ON	/* Q-SIG specific data : used for CallRerouting operation in Q-SIG */
	struct ns_asn1_string	calling_number_digits;		/* NumberDigits string in PartyNumber inside callingNumber */
	struct ns_asn1_string	orig_number_digits;			/* NumberDigits string in PartyNumber inside originalCalledNr */
	struct ns_asn1_string	calling_name_data;			/* NameData string inside callingName */
	struct ns_asn1_string	redir_name_data;			/* NameData string in NameSet inside redirectingName */
	struct ns_asn1_string	orig_name_data;				/* NameData string in NameSet inside originalCalledName */
	struct ns_asn1_string	extension;					/* extension string */
	uchar					calling_presented_nb_type;	/* index of chosen type in PresentedNumberScreened (presentationAllowedNumber .. presentationRestrictedNumber) inside callingNumber */
	uchar					calling_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside callingNumber */
	uchar					calling_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside callingNumber) */
	uchar					calling_screening_ind;		/* ScreeningIndicator in PresentedNumberScreened inside callingNumber : ENUMERATED {0, 1, 2, 3} */
	uchar					orig_presented_nb_type;		/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside originalCalledNr */
	uchar					orig_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside originalCalledNr */
	uchar					orig_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originalCalledNr) */
	uchar					calling_name_type;			/* index of chosen type in Name inside callingName */
	uchar					name_character[3];			/* CharacterSet in NameSet : inside callingName, redirectingName and originalCalledName */
#endif

} ns_op_div_rerouteing;

	/* DivertingLegInformation1 operation : ARGUMENT */

struct	ns_op_div_leg_info_1 {
	uchar					reason;						/* diversion reason in ARGUMENT : ENUMERATED {0, 1, .. , 5} */
	uchar					subscription_option;		/* subscriptionOption in ARGUMENT : ENUMERATED {0, 1, 2} */
	uchar					presented_nb_type;			/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside divertedToNumber */
	uchar					party_nb_type;				/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside divertedToNumber */
	uchar					type_of_nb;					/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertedToNumber) */
	struct ns_asn1_string	number_digits;				/* NumberDigits string in PartyNumber inside divertedToNumber */

#if F_QSI == ON	/* Q-SIG specific data : used for DivertingLegInformation1 operation in Q-SIG */
	struct ns_asn1_string	extension;					/* extension string */
#endif

} ns_op_div_leg_info_1;

	/* DivertingLegInformation2 operation : ARGUMENT */

struct	ns_op_div_leg_info_2 {
	uchar					counter;					/* diversion counter in ARGUMENT : INTEGER (1..5) */
	uchar					reason;						/* diversion reason in ARGUMENT : ENUMERATED {0, 1, .. , 5} */
	uchar					div_presented_nb_type;		/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside divertingNr */
	uchar					div_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside divertingNr */
	uchar					div_type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertingNr) */
	struct ns_asn1_string	div_number_digits;			/* NumberDigits string in PartyNumber inside divertingNr */
	uchar					orig_presented_nb_type;		/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside originalCalledNr */
	uchar					orig_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside originalCalledNr */
	uchar					orig_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originalCalledNr) */
	struct ns_asn1_string	orig_number_digits;			/* NumberDigits string in PartyNumber inside originalCalledNr */

#if F_QSI == ON	/* Q-SIG specific data : used for DivertingLegInformation2 operation in Q-SIG */
	struct ns_asn1_string	redir_name_data;			/* NameData string in NameSet inside redirectingName */
	struct ns_asn1_string	orig_name_data;				/* NameData string in NameSet inside originalCalledName */
	struct ns_asn1_string	extension;					/* extension string */
	uchar					name_character[2];			/* CharacterSet in NameSet : inside redirectingName and originalCalledName */
#endif

} ns_op_div_leg_info_2;

	/* DivertingLegInformation3 operation : ARGUMENT */

uchar	ns_op_div_leg_info_3;							/* ARGUMENT = presentationAllowedIndicator : BOOLEAN */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* ActivationStatusNotificationDiv operation ARGUMENT : same as in ActivationDiversion operation */

#define NS_ACT_STAT_NOTIF_DIV_ARG_P			NS_ACTIVATION_DIV_ARG_P

	/* DeactivationStatusNotificationDiv operation ARGUMENT : same as in DeactivationDiversion operation */

#define NS_DEA_STAT_NOTIF_DIV_ARG_P			NS_DEACTIVATION_DIV_ARG_P

	/* InterrogationDiversion operation RESULT : IntResultList */

#define NS_INTEROG_DIV_RES_P		NS_DIV_INT_RESULT_LIST_P

	/* InterrogateServedUserNumbers operation RESULT : ServedUserNumberList */

#define NS_INTEROG_S_USER_NB_RES_P	NS_DIV_SERVED_USER_NB_LIST_P

	/* CallRerouteing operation ARGUMENT : SEQUENCE {
													rerouteingReason DiversionReason,
													calledAddress Address,
													rerouteingCounter DiversionCounter,
													q931InfoElement Q931InformationElement,
													lastRerouteingNr [1] PresentedNumberUnscreened,
													subscriptionOption [2] SubscriptionOption DEFAULT noNotification,
													callingPartySubaddress [3] PartySubaddress OPTIONAL} */

#define NS_REROUTE_LAST_NR_P		NS_DIV_INFO_ORIG_CALLED_NB_P

	/* DivertingLegInformation2 operation ARGUMENT : SEQUENCE {
														diversionCounter DiversionCounter,
														diversionReason DiversionReason,
														divertingNr [1] PresentedNumberUnscreened OPTIONAL,
														originalCalledNr [2] PresentedNumberUnscreened OPTIONAL} */

#define NS_DIV_LEG2_DIVERTING_NR_P		NS_DIV_INFO_ORIG_CALLED_NB_P
#define NS_DIV_LEG2_ORIG_CALLED_NR_P	NS_DIV_INFO_LAST_NB_P

	/* DivertingLegInformation3 operation ARGUMENT : PresentationAllowedIndicator */

#define NS_DIVERTING_LEG_INFO3_ARG_P		NS_SS_PRESENT_ALLOW_IND_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Tables used to decode and store data of ARGUMENT and RESULT clauses :
		! STORAGE CONTEXTS FOR DIFFERENT INTERNAL FIELDS BUT ASSOCIATED WITH SAME
		(P_PC, FIELD_NB) PAIR MUST BE ADJACENT IN TABLES */

	/* ActivationStatusNotificationDiv operation : same clauses as in ActivationDiversion operation */

#define NS_ARG_CTX_LIST_ACT_ST_NOT_DIV			NS_ARG_CTX_LIST_ACTIV_DIV

	/* DeactivationStatusNotificationDiv operation : same clauses as in DeactivationDiversion operation */

#define NS_ARG_CTX_LIST_DEA_ST_NOT_DIV			NS_ARG_CTX_LIST_DEACTIV_DIV

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* ActivationDiversion operation */

#if NS_USE_EUROPE_OPERATION == ON

uchar ns_ssdu_op_activation_div (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if ((Ns_act_div_forw_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
			(Ns_act_div_s_u_nb_type > NS_SS_DIV_MX_S_USER_NB_TYPE)) {

			return (NOK);	/* bad type of PartyNumber or bad type of servedUserNr */
		}

		ns_op_div_activation.procedure = Ns_act_div_procedure;
		ns_op_div_activation.basic_service = Ns_act_div_basic_service;
		ns_op_div_activation.forw_party_nb_type = Ns_act_div_forw_party_nb_type;

		if ((ns_op_div_activation.forw_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_activation.forw_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_activation.forw_type_of_nb = Ns_act_div_forw_type_of_nb;
		}

		ns_op_div_activation.forw_number_digits.size = size = Ns_act_div_forw_nb_size;
		ns_op_div_activation.forw_number_digits.p_string = p_ind_buffer;

			/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_act_div_first_str);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_act_div_forw_sa_type != 255) {	/* subaddress is present */

			if (Ns_act_div_forw_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_div_activation.forw_sub_add_type = Ns_act_div_forw_sa_type;
			ns_op_div_activation.forw_sub_add_odd_count = (Ns_act_div_forw_sa_odd_count == 255) ? 254 : Ns_act_div_forw_sa_odd_count;
			ns_op_div_activation.forw_sub_address.size = size = Ns_act_div_forw_sa_size;
			ns_op_div_activation.forw_sub_address.p_string = p_ind_buffer;

				/* PartySubaddress string : at the end of the structure, after PartyNumber string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

			ns_op_div_activation.forw_sub_add_type = 254;
			ns_op_div_activation.forw_sub_address.size = 254;
			ns_op_div_activation.forw_sub_address.p_string = P_NIL;
		}

		ns_op_div_activation.served_user_nr_type = Ns_act_div_s_u_nb_type;
		if (Ns_act_div_s_u_nb_type == NS_SS_DIV_SERVED_USER_IND_NB) {

				/* individual served user number -> process PartyNumber */

			if (Ns_act_div_s_u_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_div_activation.srv_u_party_nb_type = Ns_act_div_s_u_party_nb_type;

			if ((ns_op_div_activation.srv_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
				(ns_op_div_activation.srv_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

				ns_op_div_activation.srv_u_type_of_nb = Ns_act_div_s_u_type_of_nb;
			}

			ns_op_div_activation.srv_u_number_digits.size = size = Ns_act_div_s_u_nb_size;
			ns_op_div_activation.srv_u_number_digits.p_string = p_ind_buffer;

				/* servedUserNr string : at the end of the structure, after forwardedToAddress string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((ns_op_div_activation.forw_party_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(ns_op_div_activation.forw_party_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/*	type of PartyNumber in forwardedToAddress is nor 'Public' neither 'Private'
					-> the 'Type of Number' field is meaningless, the one stored into internal
					data is in fact the 'Type of Number' for next PartyNumber : in servedUserNr */

			ns_op_div_activation.srv_u_type_of_nb = ns_op_div_activation.forw_type_of_nb;
		}

		Ns_act_div_procedure = ns_op_div_activation.procedure;
		Ns_act_div_basic_service = ns_op_div_activation.basic_service;
		Ns_act_div_forw_party_nb_type = ns_op_div_activation.forw_party_nb_type;
		Ns_act_div_forw_type_of_nb = ns_op_div_activation.forw_type_of_nb;
		Ns_act_div_forw_sa_type = ns_op_div_activation.forw_sub_add_type;
		Ns_act_div_forw_sa_odd_count = ns_op_div_activation.forw_sub_add_odd_count;
		Ns_act_div_s_u_nb_type = ns_op_div_activation.served_user_nr_type;
		Ns_act_div_s_u_party_nb_type = ns_op_div_activation.srv_u_party_nb_type;
		Ns_act_div_s_u_type_of_nb = ns_op_div_activation.srv_u_type_of_nb;
		p_next = &(Ns_act_div_first_str);		/* set current pointer to first string octet */

			/* PartyNumber string : at the end of the structure */
		Ns_act_div_forw_nb_size = size = ns_op_div_activation.forw_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.forw_number_digits.p_string, size);
		p_next += size;

			/* PartySubaddress string : at the end of the structure, after PartyNumber string */
		Ns_act_div_forw_sa_size = size = ns_op_div_activation.forw_sub_address.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.forw_sub_address.p_string, size);
		p_next += size;

			/* servedUserNr string : at the end of the structure, after forwardedToAddress string */
		Ns_act_div_s_u_nb_size = size = ns_op_div_activation.srv_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.srv_u_number_digits.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* DeactivationDiversion operation */

uchar ns_ssdu_op_deactivation_div (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_dea_div_s_u_nb_type > NS_SS_DIV_MX_S_USER_NB_TYPE) {

			return (NOK);	/* bad type of servedUserNr */
		}

		ns_op_div_deactivation.procedure = Ns_dea_div_procedure;
		ns_op_div_deactivation.basic_service = Ns_dea_div_basic_service;
		ns_op_div_deactivation.served_user_nr_type = Ns_dea_div_s_u_nb_type;

		if (Ns_dea_div_s_u_nb_type == NS_SS_DIV_SERVED_USER_IND_NB) {

				/* individual served user number -> process PartyNumber */

			if (Ns_dea_div_s_u_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_div_deactivation.srv_u_party_nb_type = Ns_dea_div_s_u_party_nb_type;

			if ((ns_op_div_deactivation.srv_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
				(ns_op_div_deactivation.srv_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

				ns_op_div_deactivation.srv_u_type_of_nb = Ns_dea_div_s_u_type_of_nb;
			}

			ns_op_div_deactivation.srv_u_number_digits.size = size = Ns_dea_div_s_u_nb_size;
			ns_op_div_deactivation.srv_u_number_digits.p_string = p_ind_buffer;

				/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_dea_div_first_str), size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_dea_div_procedure = ns_op_div_deactivation.procedure;
		Ns_dea_div_basic_service = ns_op_div_deactivation.basic_service;
		Ns_dea_div_s_u_nb_type = ns_op_div_deactivation.served_user_nr_type;
		Ns_dea_div_s_u_party_nb_type = ns_op_div_deactivation.srv_u_party_nb_type;
		Ns_dea_div_s_u_type_of_nb = ns_op_div_deactivation.srv_u_type_of_nb;
		p_next = &(Ns_dea_div_first_str);		/* set current pointer to first string octet */

			/* servedUserNr string : at the end of the structure */
		Ns_dea_div_s_u_nb_size = size = ns_op_div_deactivation.srv_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_deactivation.srv_u_number_digits.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

	/* ActivationStatusNotificationDiv operation : same clauses as in ActivationDiversion operation */

#define ns_ssdu_op_act_stat_notif_div			ns_ssdu_op_activation_div

	/* DeactivationStatusNotificationDiv operation : same clauses as in DeactivationDiversion operation */

#define ns_ssdu_op_dea_stat_notif_div			ns_ssdu_op_deactivation_div

	/*	InterrogationDiversion operation */

uchar ns_ssdu_op_interog_div (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */
	uchar				index;				/* current index */
	uchar				party_nb_x;			/* current index for PartyNumber */
	uchar				type_of_nb_x;		/* current index for TypeOfNumber inside PartyNumber */
	uchar				odd_count_x;		/* current index for OddCountIndicator inside PartySubaddress */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {

				/* ReturnResult component -> process RESULT clause */

			odd_count_x = type_of_nb_x = party_nb_x = index = 0;			/* initialize current indexes */
			ns_op_div_interrogation_res.int_result_nb = 0;					/* init number of IntResult */

			while (offset != OFFSET_NIL) {

				if (ns_op_div_interrogation_res.int_result_nb >= NS_DIV_MX_INT_RESULT) {

					return (NOK);	/* too many IntResult instances */
				}

				p_next = p_start + offset;						/* get content of current IntResult */

				if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

					return (NOK);	/* component data is after end of SSDU or before start of component ! */
				}

				p_ssdu_val = p_next;		/* update SSDU pointer to analyse IntResult content */

				if ((Ns_int_res_div_forw_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
					(Ns_int_res_div_s_u_nb_type > NS_SS_DIV_MX_S_USER_NB_TYPE)) {

					return (NOK);	/* bad type of PartyNumber or bad type of servedUserNr */
				}

				ns_op_div_interrogation_res.procedure[index] = Ns_int_res_div_procedure;
				ns_op_div_interrogation_res.basic_service[index] = Ns_int_res_div_basic_service;
				ns_op_div_interrogation_res.served_user_nr_type[index] = Ns_int_res_div_s_u_nb_type;
				p_next = &(Ns_int_res_div_first_str);

				if (Ns_int_res_div_s_u_nb_type == NS_SS_DIV_SERVED_USER_IND_NB) {

						/* individual served user number -> process PartyNumber */

					if (Ns_int_res_div_s_u_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

						return (NOK);	/* bad type of PartyNumber */
					}

						/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

					if ((Ns_int_res_div_s_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
						(Ns_int_res_div_s_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

						ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++] = Ns_int_res_div_s_u_type_of_nb;
					}

					ns_op_div_interrogation_res.party_nb_type[party_nb_x] = Ns_int_res_div_s_u_party_nb_type;
					ns_op_div_interrogation_res.number_digits[party_nb_x].size = size = Ns_int_res_div_s_u_nb_size;
					ns_op_div_interrogation_res.number_digits[party_nb_x++].p_string = p_ind_buffer;

						/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */
				}

					/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

				if ((Ns_int_res_div_forw_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
					(Ns_int_res_div_forw_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

					ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++] = Ns_int_res_div_forw_type_of_nb;
				}

				ns_op_div_interrogation_res.party_nb_type[party_nb_x] = Ns_int_res_div_forw_party_nb_type;
				ns_op_div_interrogation_res.number_digits[party_nb_x].size = size = Ns_int_res_div_forw_nb_size;
				ns_op_div_interrogation_res.number_digits[party_nb_x++].p_string = p_ind_buffer;

					/* PartyNumber string : at the end of the structure, after servedUserNr string -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

				if (Ns_int_res_div_forw_sa_type != 255) {	/* subaddress is present */

					if (Ns_int_res_div_forw_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

						return (NOK);	/* bad type of PartySubaddress */
					}

					if (Ns_int_res_div_forw_sa_type == NS_SS_PARTY_SA_USER_SPECIF) {

						ns_op_div_interrogation_res.forw_sub_add_odd_count[odd_count_x++] = (Ns_int_res_div_forw_sa_odd_count == 255) ? 254 : Ns_int_res_div_forw_sa_odd_count;
					}

					ns_op_div_interrogation_res.forw_sub_add_type[index] = Ns_int_res_div_forw_sa_type;
					ns_op_div_interrogation_res.forw_sub_address[index].size = size = Ns_int_res_div_forw_sa_size;
					ns_op_div_interrogation_res.forw_sub_address[index].p_string = p_ind_buffer;

						/* PartySubaddress string : at the end of the structure, after PartyNumber string and servedUserNr string -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */

				} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

					ns_op_div_interrogation_res.forw_sub_add_type[index] = 254;
					ns_op_div_interrogation_res.forw_sub_address[index].size = 254;
					ns_op_div_interrogation_res.forw_sub_address[index].p_string = P_NIL;
				}

				offset = Ns_int_res_div_next;					/* get content of next IntResult */
				ns_op_div_interrogation_res.int_result_nb++;	/* increment number of IntResult */
				index++;									/* get next IntResult internal structure */
			}

			return (OK);
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_dea_div_s_u_nb_type > NS_SS_DIV_MX_S_USER_NB_TYPE) {

			return (NOK);	/* bad type of servedUserNr */
		}

		ns_op_div_interrogation.procedure = Ns_dea_div_procedure;
		ns_op_div_interrogation.basic_service = (Ns_dea_div_basic_service == 255) ? 254 : Ns_dea_div_basic_service;
		ns_op_div_interrogation.served_user_nr_type = Ns_dea_div_s_u_nb_type;

		if (Ns_dea_div_s_u_nb_type == NS_SS_DIV_SERVED_USER_IND_NB) {

				/* individual served user number -> process PartyNumber */

			if (Ns_dea_div_s_u_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_div_interrogation.srv_u_party_nb_type = Ns_dea_div_s_u_party_nb_type;
			ns_op_div_interrogation.srv_u_type_of_nb = Ns_dea_div_s_u_type_of_nb;
			ns_op_div_interrogation.srv_u_number_digits.size = size = Ns_dea_div_s_u_nb_size;
			ns_op_div_interrogation.srv_u_number_digits.p_string = p_ind_buffer;

				/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_dea_div_first_str), size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			offset = (ushort)(ns_op_div_interrogation_res.int_result_nb);		/* use 'offset' as counter of number of instances */

			if (offset == 0) {

				return (STOP);	/* no data */
			}

			odd_count_x = type_of_nb_x = party_nb_x = index = 0;			/* initialize current indexes */

			while (offset-- > 0) {

				Ns_int_res_div_procedure = ns_op_div_interrogation_res.procedure[index];
				Ns_int_res_div_basic_service = ns_op_div_interrogation_res.basic_service[index];
				Ns_int_res_div_s_u_nb_type = ns_op_div_interrogation_res.served_user_nr_type[index];
				p_next = &(Ns_int_res_div_first_str);		/* set current pointer to first string octet */

                size = 0;
				if (Ns_int_res_div_s_u_nb_type == NS_SS_DIV_SERVED_USER_IND_NB) {

							/* individual served user number -> process PartyNumber */

					Ns_int_res_div_s_u_party_nb_type = ns_op_div_interrogation_res.party_nb_type[party_nb_x];

						/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

					if ((Ns_int_res_div_s_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
						(Ns_int_res_div_s_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

						Ns_int_res_div_s_u_type_of_nb = ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++];
					}

						/* servedUserNr string : at the end of the structure */
					size = ns_op_div_interrogation_res.number_digits[party_nb_x].size;
					Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation_res.number_digits[party_nb_x].p_string, size);
					p_next += size;
					party_nb_x++;
				}
				Ns_int_res_div_s_u_nb_size = size;

				Ns_int_res_div_forw_party_nb_type = ns_op_div_interrogation_res.party_nb_type[party_nb_x];

					/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

				if ((Ns_int_res_div_forw_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
					(Ns_int_res_div_forw_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

					Ns_int_res_div_forw_type_of_nb = ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++];
				}

					/* PartyNumber string : at the end of the structure, after servedUserNr string */
				Ns_int_res_div_forw_nb_size = size = ns_op_div_interrogation_res.number_digits[party_nb_x].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation_res.number_digits[party_nb_x].p_string, size);
				p_next += size;
				party_nb_x++;

				Ns_int_res_div_forw_sa_type = ns_op_div_interrogation_res.forw_sub_add_type[index];
				if (Ns_int_res_div_forw_sa_type == NS_SS_PARTY_SA_USER_SPECIF) {

					Ns_int_res_div_forw_sa_odd_count = ns_op_div_interrogation_res.forw_sub_add_odd_count[odd_count_x++];
				}

					/* PartySubaddress string : at the end of the structure, after servedUserNr and PartyNumber strings */
				Ns_int_res_div_forw_sa_size = size = ns_op_div_interrogation_res.forw_sub_address[index].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation_res.forw_sub_address[index].p_string, size);
				p_next += size;

				p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */

				if (offset == 0) {

					Ns_int_res_div_next = OFFSET_NIL;

				} else {

					Ns_int_res_div_next = (ushort)(p_next - p_start);
				}

				p_ssdu_val = p_next;	/* update current SSDU value pointer */
				index++;			/* get next IntResult internal structure */
			}

			return (OK);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_dea_div_procedure = ns_op_div_interrogation.procedure;
		Ns_dea_div_basic_service = ns_op_div_interrogation.basic_service;
		Ns_dea_div_s_u_nb_type = ns_op_div_interrogation.served_user_nr_type;
		Ns_dea_div_s_u_party_nb_type = ns_op_div_interrogation.srv_u_party_nb_type;
		Ns_dea_div_s_u_type_of_nb = ns_op_div_interrogation.srv_u_type_of_nb;
		p_next = &(Ns_dea_div_first_str);		/* set current pointer to first string octet */

			/* servedUserNr string : at the end of the structure */
		Ns_dea_div_s_u_nb_size = size = ns_op_div_interrogation.srv_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation.srv_u_number_digits.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

	/* InterrogateServedUserNumbers operation */

uchar ns_ssdu_op_interog_s_u_nb_div (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */
	uchar				index;				/* current index */
	uchar				type_of_nb_x;		/* current index for TypeOfNumber inside PartyNumber */

	type_of_nb_x = index = 0;						/* initialize current indexes */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag != FAC_RETURN_RESULT) {	/* Invoke component -> process ARGUMENT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* ReturnResult component -> process RESULT clause */

		ns_op_div_interog_s_u_nb.nb_of_party_nb = 0;	/* init number of PartyNumber */

		while (offset != OFFSET_NIL) {

			if (ns_op_div_interog_s_u_nb.nb_of_party_nb >= NS_DIV_MX_USER_NUMBERS) {

				return (NOK);	/* too many PartyNumber instances */
			}

			p_next = p_start + offset;						/* get content of current PartyNumber */

			if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

				return (NOK);	/* component data is after end of SSDU or before start of component ! */
			}

			p_ssdu_val = p_next;		/* update SSDU pointer to analyse IntResult content */

			if (Ns_div_interog_s_u_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

				/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

			if ((Ns_div_interog_s_u_party_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
				(Ns_div_interog_s_u_party_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

				ns_op_div_interog_s_u_nb.type_of_nb[type_of_nb_x++] = Ns_div_interog_s_u_type_of_nb;
			}

			ns_op_div_interog_s_u_nb.party_nb_type[index] = Ns_div_interog_s_u_party_nb_t;
			ns_op_div_interog_s_u_nb.number_digits[index].size = size = Ns_div_interog_s_u_nb_size;
			ns_op_div_interog_s_u_nb.number_digits[index].p_string = p_ind_buffer;

				/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
			p_next = &(Ns_div_interog_s_u_first_nb);
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

			offset = Ns_div_interog_s_u_next_nb;			/* get content of next PartyNumber */
			ns_op_div_interog_s_u_nb.nb_of_party_nb++;		/* increment number of PartyNumber */
			index++;										/* get next PartyNumber internal structure */
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag != FAC_RETURN_RESULT) {	/* Invoke component -> process ARGUMENT clause : empty */

			return (STOP);	/* no data */
		}

			/* ReturnResult component -> process RESULT clause */

		offset = (ushort)(ns_op_div_interog_s_u_nb.nb_of_party_nb);		/* use 'offset' as counter of number of instances */

		if (offset == 0) {

			return (STOP);	/* no data */
		}

		while (offset-- > 0) {

			Ns_div_interog_s_u_party_nb_t = ns_op_div_interog_s_u_nb.party_nb_type[index];

				/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

			if ((Ns_div_interog_s_u_party_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
				(Ns_div_interog_s_u_party_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

				Ns_div_interog_s_u_type_of_nb = ns_op_div_interog_s_u_nb.type_of_nb[type_of_nb_x++];
			}

				/* PartyNumber string : at the end of the structure, after servedUserNr string */
			p_next = &(Ns_div_interog_s_u_first_nb);		/* set current pointer to first string octet */
			Ns_div_interog_s_u_nb_size = size = ns_op_div_interog_s_u_nb.number_digits[index].size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interog_s_u_nb.number_digits[index].p_string, size);
			p_next += size;
			p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */

			if (offset == 0) {

				Ns_div_interog_s_u_next_nb = OFFSET_NIL;

			} else {

				Ns_div_interog_s_u_next_nb = (ushort)(p_next - p_start);
			}

			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			index++;				/* get next IntResult internal structure */
		}
	}

	return (OK);
}

	/* DiversionInformation operation */

uchar ns_ssdu_op_div_information (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_information.reason = Ns_info_div_reason;
		ns_op_div_information.basic_service = Ns_info_div_basic_service;
		p_next = &(Ns_info_div_first_str);

		if (Ns_info_div_srv_u_sa_type != 255) {

			if (Ns_info_div_srv_u_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_div_information.srv_u_sub_add_type = Ns_info_div_srv_u_sa_type;

			if (Ns_info_div_srv_u_sa_type == NS_SS_PARTY_SA_USER_SPECIF) {

				ns_op_div_information.srv_u_sub_add_odd_count = (Ns_info_div_srv_u_sa_odd_count == 255) ? 254 : Ns_info_div_srv_u_sa_odd_count;
			}

			ns_op_div_information.srv_u_sub_address.p_string = p_ind_buffer;
			ns_op_div_information.srv_u_sub_address.size = size = Ns_info_div_srv_u_sa_size;
				/* servedUserSubaddress string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			ns_op_div_information.srv_u_sub_add_type = 254;
			ns_op_div_information.srv_u_sub_address.size = 254;
		}

		ns_op_div_information.calling_a_presented_type = Ns_info_div_calling_a_type;
		switch (Ns_info_div_calling_a_type) {

			case 255 :	/* callingAddress is absent */

				ns_op_div_information.calling_a_presented_type = 254;
				break;

			case NS_SS_PRES_ADD_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_ADD :	/* callingAddress type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_ADD :
			case NS_SS_PRES_RESTRICTED_ADD :	/* callingAddress type is AddressScreened */

				ns_op_div_information.calling_a_screening_ind = Ns_info_div_calling_a_scr_ind;

				if (Ns_info_div_calling_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_information.calling_party_nb_type = Ns_info_div_calling_nb_type;

				if ((ns_op_div_information.calling_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
					(ns_op_div_information.calling_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

					ns_op_div_information.calling_type_of_nb = Ns_info_div_calling_t_of_nb;
				}

				ns_op_div_information.calling_number_digits.size = size = Ns_info_div_calling_nb_size;
				ns_op_div_information.calling_number_digits.p_string = p_ind_buffer;
					/* calling number string : at the end of the structure, after servedUserSubaddress string  -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

				if (Ns_info_div_calling_sa_type != 255) {

					if (Ns_info_div_calling_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

						return (NOK);	/* bad type of PartySubaddress */
					}

					ns_op_div_information.calling_sub_add_type = Ns_info_div_calling_sa_type;
					ns_op_div_information.calling_sub_add_odd_count = (Ns_info_div_calling_sa_odd_count == 255) ? 254 : Ns_info_div_calling_sa_odd_count;
					ns_op_div_information.calling_sub_address.p_string = p_ind_buffer;
					ns_op_div_information.calling_sub_address.size = size = Ns_info_div_calling_sa_size;
						/* calling subaddress string : after servedUserSubaddress and calling number strings -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */

				} else {

					ns_op_div_information.calling_sub_add_type = 254;
					ns_op_div_information.calling_sub_address.size = 254;
				}

				break;

			default :

				return (NOK);		/* bad type of PresentedAddressScreened */
		}

		ns_op_div_information.orig_presented_nb_type = Ns_info_div_orig_pres_type;
		switch (Ns_info_div_orig_pres_type) {

			case 255 :	/* original called nb is absent */

				ns_op_div_information.orig_presented_nb_type = 254;
                break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* originalCalledNr type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* originalCalledNr type is PartyNumber */

				if (Ns_info_div_orig_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_information.orig_party_nb_type = Ns_info_div_orig_nb_type;

				if ((ns_op_div_information.orig_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
					(ns_op_div_information.orig_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

					ns_op_div_information.orig_type_of_nb = Ns_info_div_orig_t_of_nb;
				}

				ns_op_div_information.orig_number_digits.size = size = Ns_info_div_orig_nb_size;
				ns_op_div_information.orig_number_digits.p_string = p_ind_buffer;
					/* original called number string : after servedUserSubaddress and calling address strings -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

		ns_op_div_information.last_presented_nb_type = Ns_info_div_last_pres_type;
		switch (Ns_info_div_last_pres_type) {

			case 255 :	/* last diverting nb is absent */

				ns_op_div_information.last_presented_nb_type = 254;
				break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* lastDivertingNr type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* lastDivertingNr type is PartyNumber */

				if (Ns_info_div_last_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_information.last_party_nb_type = Ns_info_div_last_nb_type;
				ns_op_div_information.last_type_of_nb = Ns_info_div_last_t_of_nb;
				ns_op_div_information.last_number_digits.size = size = Ns_info_div_last_nb_size;
				ns_op_div_information.last_number_digits.p_string = p_ind_buffer;
					/* last diverting number string : after servedUserSubaddress, calling address and original number strings -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

		ns_op_div_information.last_divert_reason = (Ns_info_div_last_reason == 255) ? 254 : Ns_info_div_last_reason;
		size = Ns_info_div_q931_user_info_sz;
		if (size == 0) {

			ns_op_div_information.q931_user_info.size = 254;

		} else {

			ns_op_div_information.q931_user_info.size = size;
			ns_op_div_information.q931_user_info.p_string = p_ind_buffer;
				/* Q931 User Info string : after servedUserSubaddress, calling address,
					originalCalledNr and lastDivertingNr strings -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

	} else {	/* to CALL CONTROL */

		Ns_info_div_reason = ns_op_div_information.reason;
		Ns_info_div_basic_service = ns_op_div_information.basic_service;
		p_next = &(Ns_info_div_first_str);

		Ns_info_div_srv_u_sa_type = ns_op_div_information.srv_u_sub_add_type;
		if (Ns_info_div_srv_u_sa_type != 255) {

			if (Ns_info_div_srv_u_sa_type == NS_SS_PARTY_SA_NSAP) {

            		/* NSAP Subaddress : 'OddCountIndicator' is meaningless, the value stored is in fact the one for next 'OddCountIndicator' field */

				ns_op_div_information.calling_sub_add_odd_count = ns_op_div_information.srv_u_sub_add_odd_count;
			}

			Ns_info_div_srv_u_sa_odd_count = ns_op_div_information.srv_u_sub_add_odd_count;
			Ns_info_div_srv_u_sa_size = size = ns_op_div_information.srv_u_sub_address.size;
				/* servedUserSubaddress string : at the end of the structure */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_information.srv_u_sub_address.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

				/* ServedUserSubaddress absent : 'OddCountIndicator' is meaningless, the value stored is in fact the one for next 'OddCountIndicator' field */

			ns_op_div_information.calling_sub_add_odd_count = ns_op_div_information.srv_u_sub_add_odd_count;
			Ns_info_div_srv_u_sa_size = 0;
		}

		Ns_info_div_calling_a_type = ns_op_div_information.calling_a_presented_type;
		Ns_info_div_calling_nb_size = 0;
		Ns_info_div_calling_sa_size = 0;
		switch (Ns_info_div_calling_a_type) {

			case NS_SS_PRES_ADD_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_ADD :

				/* callingAddress type is NULL : no other data, stored data are in fact the ones for next PartyNumber fields */

				ns_op_div_information.last_party_nb_type = ns_op_div_information.orig_party_nb_type;
				ns_op_div_information.orig_party_nb_type = ns_op_div_information.calling_party_nb_type;
				ns_op_div_information.last_type_of_nb = ns_op_div_information.orig_type_of_nb;
				ns_op_div_information.orig_type_of_nb = ns_op_div_information.calling_type_of_nb;
				ns_op_div_information.last_number_digits.size = ns_op_div_information.orig_number_digits.size;
				ns_op_div_information.last_number_digits.p_string = ns_op_div_information.orig_number_digits.p_string;
				ns_op_div_information.orig_number_digits.size = ns_op_div_information.calling_number_digits.size;
				ns_op_div_information.orig_number_digits.p_string = ns_op_div_information.calling_number_digits.p_string;
				break;

			case NS_SS_PRES_ALLOWED_ADD :
			case NS_SS_PRES_RESTRICTED_ADD :	/* callingAddress type is AddressScreened */

				Ns_info_div_calling_a_scr_ind = ns_op_div_information.calling_a_screening_ind;
				Ns_info_div_calling_nb_type = ns_op_div_information.calling_party_nb_type;
				Ns_info_div_calling_t_of_nb = ns_op_div_information.calling_type_of_nb;

				if ((Ns_info_div_calling_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
					(Ns_info_div_calling_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

						/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

					ns_op_div_information.last_type_of_nb = ns_op_div_information.orig_type_of_nb;
					ns_op_div_information.orig_type_of_nb = ns_op_div_information.calling_type_of_nb;
				}

				Ns_info_div_calling_nb_size = size = ns_op_div_information.calling_number_digits.size;
					/* calling number string : at the end of the structure, after servedUserSubaddress string */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_information.calling_number_digits.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */

				Ns_info_div_calling_sa_type = ns_op_div_information.calling_sub_add_type;
				if (Ns_info_div_calling_sa_type != 255) {

					Ns_info_div_calling_sa_odd_count = ns_op_div_information.calling_sub_add_odd_count;
					Ns_info_div_calling_sa_size = size = ns_op_div_information.calling_sub_address.size;
						/* calling subaddress string : after servedUserSubaddress and calling number strings */
					Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_information.calling_sub_address.p_string, size);
					p_next += size;				/* update pointer to current string inside SSDU */
				}
				break;
		}

		Ns_info_div_orig_pres_type = ns_op_div_information.orig_presented_nb_type;
		Ns_info_div_orig_nb_size = 0;
		switch (Ns_info_div_orig_pres_type) {

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :

					/* originalCalledNr type is NULL : no other data, stored data are in fact the ones for next PartyNumber fields */

				ns_op_div_information.last_party_nb_type = ns_op_div_information.orig_party_nb_type;
				ns_op_div_information.last_type_of_nb = ns_op_div_information.orig_type_of_nb;
				ns_op_div_information.last_number_digits.size = ns_op_div_information.orig_number_digits.size;
				ns_op_div_information.last_number_digits.p_string = ns_op_div_information.orig_number_digits.p_string;
				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* originalCalledNr type is PartyNumber */

				Ns_info_div_orig_nb_type = ns_op_div_information.orig_party_nb_type;

				if ((Ns_info_div_orig_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
					(Ns_info_div_orig_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

						/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

					ns_op_div_information.last_type_of_nb = ns_op_div_information.orig_type_of_nb;
				}

				Ns_info_div_orig_t_of_nb = ns_op_div_information.orig_type_of_nb;
				Ns_info_div_orig_nb_size = size = ns_op_div_information.orig_number_digits.size;
					/* original called number string : after servedUserSubaddress and calling address strings */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_information.orig_number_digits.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */
				break;
		}

		Ns_info_div_last_pres_type = ns_op_div_information.last_presented_nb_type;
		Ns_info_div_last_nb_size = 0;
		if ((Ns_info_div_last_pres_type == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_info_div_last_pres_type == NS_SS_PRES_RESTRICTED_NB)) {

				/* lastDivertingNr type is PartyNumber */

			Ns_info_div_last_nb_type = ns_op_div_information.last_party_nb_type;
			Ns_info_div_last_t_of_nb = ns_op_div_information.last_type_of_nb;
			Ns_info_div_last_nb_size = size = ns_op_div_information.last_number_digits.size;
				/* last diverting number string : after servedUserSubaddress, calling address and original number strings */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_information.last_number_digits.p_string, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_info_div_last_reason = ns_op_div_information.last_divert_reason;

		Ns_info_div_q931_user_info_sz = size = ns_op_div_information.q931_user_info.size;
			/* Q931 User Info string : after servedUserSubaddress, calling address,
				originalCalledNr and lastDivertingNr strings */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_information.q931_user_info.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CallDeflection operation */

uchar ns_ssdu_op_div_deflection (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_div_defl_party_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber or bad type of servedUserNr */
		}

		ns_op_div_deflection.pres_allow_div_to_user = Ns_div_defl_pres_allow_to_u;
		ns_op_div_deflection.party_nb_type = Ns_div_defl_party_nb_type;
		ns_op_div_deflection.type_of_nb = Ns_div_defl_type_of_nb;
		ns_op_div_deflection.number_digits.size = size = Ns_div_defl_nb_size;
		ns_op_div_deflection.number_digits.p_string = p_ind_buffer;

			/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_div_defl_first_str);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_div_defl_sa_type != 255) {	/* subaddress is present */

			if (Ns_div_defl_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_div_deflection.sub_add_type = Ns_div_defl_sa_type;
			ns_op_div_deflection.sub_add_odd_count = (Ns_div_defl_sa_odd_count == 255) ? 254 : Ns_div_defl_sa_odd_count;
			ns_op_div_deflection.sub_address.size = size = Ns_div_defl_sa_size;
			ns_op_div_deflection.sub_address.p_string = p_ind_buffer;

				/* PartySubaddress string : at the end of the structure, after PartyNumber string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */

		} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

			ns_op_div_deflection.sub_add_type = 254;
			ns_op_div_deflection.sub_address.size = 254;
			ns_op_div_deflection.sub_address.p_string = P_NIL;
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_div_defl_pres_allow_to_u = ns_op_div_deflection.pres_allow_div_to_user;
		Ns_div_defl_party_nb_type = ns_op_div_deflection.party_nb_type;
		Ns_div_defl_type_of_nb = ns_op_div_deflection.type_of_nb;
		Ns_div_defl_sa_type = ns_op_div_deflection.sub_add_type;
		Ns_div_defl_sa_odd_count = ns_op_div_deflection.sub_add_odd_count;
		p_next = &(Ns_div_defl_first_str);		/* set current pointer to first string octet */

			/* PartyNumber string : at the end of the structure */
		Ns_div_defl_nb_size = size = ns_op_div_deflection.number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_deflection.number_digits.p_string, size);
		p_next += size;

			/* PartySubaddress string : at the end of the structure, after PartyNumber string */
		Ns_div_defl_sa_size = size = ns_op_div_deflection.sub_address.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_deflection.sub_address.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

	/* CallRerouteing operation */

uchar ns_ssdu_op_div_reroute (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_rerouteing.reason = Ns_div_rerout_reason;
		ns_op_div_rerouteing.counter = Ns_div_rerout_counter;
		p_next = &(Ns_div_rerout_first_str);

		if (Ns_div_rerout_called_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_div_rerouteing.called_party_nb_type = Ns_div_rerout_called_nb_type;

		if ((ns_op_div_rerouteing.called_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_rerouteing.called_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_rerouteing.called_type_of_nb = Ns_div_rerout_called_t_of_nb;
		}

		ns_op_div_rerouteing.called_number_digits.size = size = Ns_div_rerout_called_nb_size;
		ns_op_div_rerouteing.called_number_digits.p_string = p_ind_buffer;
			/* called number string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_div_rerout_called_sa_type != 255) {

			if (Ns_div_rerout_called_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			if (Ns_div_rerout_called_sa_type == NS_SS_PARTY_SA_USER_SPECIF) {

				ns_op_div_rerouteing.called_sub_add_odd_count = (Ns_div_rerout_called_sa_odd_count == 255) ? 254 : Ns_div_rerout_called_sa_odd_count;
			}

			ns_op_div_rerouteing.called_sub_add_type = Ns_div_rerout_called_sa_type;
			ns_op_div_rerouteing.called_sub_address.p_string = p_ind_buffer;
			ns_op_div_rerouteing.called_sub_address.size = size = Ns_div_rerout_called_sa_size;
				/* called subaddress string : after called number string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			ns_op_div_rerouteing.called_sub_add_type = 254;
			ns_op_div_rerouteing.called_sub_address.size = 254;
		}

		ns_op_div_rerouteing.q931_ie.size = size = Ns_div_rerout_q931_ie_sz;
		ns_op_div_rerouteing.q931_ie.p_string = p_ind_buffer;
			/* Q931 IE string : after called number and subaddress strings -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_rerouteing.last_presented_nb_type = Ns_div_rerout_last_pres_type;
		switch (Ns_div_rerout_last_pres_type) {

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* lastRerouteingNr type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* lastRerouteingNr type is PartyNumber */

				if (Ns_div_rerout_last_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_rerouteing.last_party_nb_type = Ns_div_rerout_last_nb_type;
				ns_op_div_rerouteing.last_type_of_nb = Ns_div_rerout_last_t_of_nb;
				ns_op_div_rerouteing.last_number_digits.size = size = Ns_div_rerout_last_nb_size;
				ns_op_div_rerouteing.last_number_digits.p_string = p_ind_buffer;
					/* lastRerouteingNr string : after called address and Q931 IE strings -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

		ns_op_div_rerouteing.subscription_option = (Ns_div_rerout_subscription == 255) ? 254 : Ns_div_rerout_subscription;
		if (Ns_div_rerout_calling_sa_type != 255) {

			if (Ns_div_rerout_calling_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_div_rerouteing.calling_sub_add_type = Ns_div_rerout_calling_sa_type;
			ns_op_div_rerouteing.calling_sub_add_odd_count = (Ns_div_rerout_calling_sa_odd_count == 255) ? 254 : Ns_div_rerout_calling_sa_odd_count;
			ns_op_div_rerouteing.calling_sub_address.p_string = p_ind_buffer;
			ns_op_div_rerouteing.calling_sub_address.size = size = Ns_div_rerout_calling_sa_size;
				/*	callingPartySubaddress string : at the end of the structure, after lastRerouteingNr,
					called address and Q931 IE strings -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			ns_op_div_rerouteing.calling_sub_add_type = 254;
			ns_op_div_rerouteing.calling_sub_address.size = 254;
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_div_rerout_reason = ns_op_div_rerouteing.reason;
		Ns_div_rerout_counter = ns_op_div_rerouteing.counter;
		p_next = &(Ns_div_rerout_first_str);

		Ns_div_rerout_called_nb_type = ns_op_div_rerouteing.called_party_nb_type;
		Ns_div_rerout_called_t_of_nb = ns_op_div_rerouteing.called_type_of_nb;

		if ((Ns_div_rerout_called_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(Ns_div_rerout_called_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

			ns_op_div_rerouteing.last_type_of_nb = ns_op_div_rerouteing.called_type_of_nb;
		}

		Ns_div_rerout_called_nb_size = size = ns_op_div_rerouteing.called_number_digits.size;
			/* called number string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.called_number_digits.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_div_rerout_called_sa_size = 0;
		Ns_div_rerout_called_sa_type = ns_op_div_rerouteing.called_sub_add_type;
		if (Ns_div_rerout_called_sa_type != 255) {

			if (Ns_div_rerout_called_sa_type == NS_SS_PARTY_SA_NSAP) {

					/* NSAP Subaddress : 'OddCountIndicator' is meaningless, the value stored is in fact the one for next 'OddCountIndicator' field */

				ns_op_div_rerouteing.calling_sub_add_odd_count = ns_op_div_rerouteing.called_sub_add_odd_count;
			}

			Ns_div_rerout_called_sa_odd_count = ns_op_div_rerouteing.called_sub_add_odd_count;
			Ns_div_rerout_called_sa_size = size = ns_op_div_rerouteing.called_sub_address.size;
				/* called subaddress string : after called number string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.called_sub_address.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

				/* Called Subaddress absent : 'OddCountIndicator' is meaningless, the value stored is in fact the one for next 'OddCountIndicator' field */

			ns_op_div_rerouteing.calling_sub_add_odd_count = ns_op_div_rerouteing.called_sub_add_odd_count;
		}

		Ns_div_rerout_q931_ie_sz = size = ns_op_div_rerouteing.q931_ie.size;
			/* Q931 IE string : after called number and subaddress strings */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.q931_ie.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_div_rerout_last_pres_type = ns_op_div_rerouteing.last_presented_nb_type;
		Ns_div_rerout_last_nb_size = 0;
		if ((Ns_div_rerout_last_pres_type == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_div_rerout_last_pres_type == NS_SS_PRES_RESTRICTED_NB)) {

				/* lastRerouteingNr type is PartyNumber */

			Ns_div_rerout_last_nb_type = ns_op_div_rerouteing.last_party_nb_type;
			Ns_div_rerout_last_t_of_nb = ns_op_div_rerouteing.last_type_of_nb;
			Ns_div_rerout_last_nb_size = size = ns_op_div_rerouteing.last_number_digits.size;
				/* lastRerouteingNr string : after called address and Q931 IE strings */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.last_number_digits.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_div_rerout_subscription = ns_op_div_rerouteing.subscription_option;

		Ns_div_rerout_calling_sa_type = ns_op_div_rerouteing.calling_sub_add_type;
		if (Ns_div_rerout_calling_sa_type != 255) {

			Ns_div_rerout_calling_sa_odd_count = ns_op_div_rerouteing.calling_sub_add_odd_count;
			Ns_div_rerout_calling_sa_size = size = ns_op_div_rerouteing.calling_sub_address.size;
				/* callingPartySubaddress string : after called address, Q931 IE and lastRerouteingNr strings */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.calling_sub_address.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			Ns_div_rerout_calling_sa_size = 0;
		}

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

	/* DivertingLegInformation1 operation */

uchar ns_ssdu_op_div_leg_info_1 (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_leg_info_1.reason = Ns_div_leg_inf1_reason;
		ns_op_div_leg_info_1.subscription_option = Ns_div_leg_inf1_subscription;

		ns_op_div_leg_info_1.presented_nb_type = Ns_div_leg_inf1_pres_type;
		switch (Ns_div_leg_inf1_pres_type) {

			case 255 :	/* divertedToNumber is absent */

				ns_op_div_leg_info_1.presented_nb_type = 254;
				ns_op_div_leg_info_1.party_nb_type = 254;
				ns_op_div_leg_info_1.type_of_nb = 254;
				ns_op_div_leg_info_1.number_digits.size = 254;
				break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* divertedToNumber type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* divertedToNumber type is PartyNumber */

				if (Ns_div_leg_inf1_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				p_next = &(Ns_div_leg_inf1_nb_str);
				ns_op_div_leg_info_1.party_nb_type = Ns_div_leg_inf1_nb_type;
				ns_op_div_leg_info_1.type_of_nb = Ns_div_leg_inf1_t_of_nb;
				ns_op_div_leg_info_1.number_digits.size = size = Ns_div_leg_inf1_nb_size;
				ns_op_div_leg_info_1.number_digits.p_string = p_ind_buffer;
					/* divertedToNumber string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

	} else {	/* to CALL CONTROL */

		Ns_div_leg_inf1_reason = ns_op_div_leg_info_1.reason;
		Ns_div_leg_inf1_subscription = ns_op_div_leg_info_1.subscription_option;
		Ns_div_leg_inf1_pres_type = ns_op_div_leg_info_1.presented_nb_type;
		Ns_div_leg_inf1_nb_type = ns_op_div_leg_info_1.party_nb_type;
		Ns_div_leg_inf1_t_of_nb = ns_op_div_leg_info_1.type_of_nb;
		size = 0;
		p_next = &(Ns_div_leg_inf1_nb_str);

		if ((Ns_div_leg_inf1_pres_type == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_div_leg_inf1_pres_type == NS_SS_PRES_RESTRICTED_NB)) {

			size = ns_op_div_leg_info_1.number_digits.size;
				/* divertedToNumber string : at the end of the structure */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_1.number_digits.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_div_leg_inf1_nb_size = size;

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

	/* DivertingLegInformation2 operation */

uchar ns_ssdu_op_div_leg_info_2 (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_leg_info_2.counter = Ns_div_leg_inf2_counter;
		ns_op_div_leg_info_2.reason = Ns_div_leg_inf2_reason;

		p_next = &(Ns_div_leg_inf2_nb_str);
		ns_op_div_leg_info_2.div_presented_nb_type = Ns_div_leg_inf2_div_pres_type;
		switch (Ns_div_leg_inf2_div_pres_type) {

			case 255 :	/* divertingNr is absent */

				ns_op_div_leg_info_2.div_presented_nb_type = 254;
				ns_op_div_leg_info_2.div_party_nb_type = 254;
				ns_op_div_leg_info_2.div_type_of_nb = 254;
				ns_op_div_leg_info_2.div_number_digits.size = 254;
				break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* divertingNr type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* divertingNr type is PartyNumber */

				if (Ns_div_leg_inf2_div_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_leg_info_2.div_party_nb_type = Ns_div_leg_inf2_div_nb_type;

				if ((ns_op_div_leg_info_2.div_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
					(ns_op_div_leg_info_2.div_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

					ns_op_div_leg_info_2.div_type_of_nb = Ns_div_leg_inf2_div_t_of_nb;
				}

				ns_op_div_leg_info_2.div_number_digits.size = size = Ns_div_leg_inf2_div_nb_size;
				ns_op_div_leg_info_2.div_number_digits.p_string = p_ind_buffer;
					/* divertingNr string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

		ns_op_div_leg_info_2.orig_presented_nb_type = Ns_div_leg_inf2_orig_pres_type;
		switch (Ns_div_leg_inf2_orig_pres_type) {

			case 255 :	/* originalCalledNr is absent */

				ns_op_div_leg_info_2.orig_presented_nb_type = 254;
				ns_op_div_leg_info_2.orig_party_nb_type = 254;
				ns_op_div_leg_info_2.orig_type_of_nb = 254;
				ns_op_div_leg_info_2.orig_number_digits.size = 254;
				break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* originalCalledNr type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* originalCalledNr type is PartyNumber */

				if (Ns_div_leg_inf2_orig_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_leg_info_2.orig_party_nb_type = Ns_div_leg_inf2_orig_nb_type;
				ns_op_div_leg_info_2.orig_type_of_nb = Ns_div_leg_inf2_orig_t_of_nb;
				ns_op_div_leg_info_2.orig_number_digits.size = size = Ns_div_leg_inf2_orig_nb_size;
				ns_op_div_leg_info_2.orig_number_digits.p_string = p_ind_buffer;
					/* originalCalledNr string : at the end of the structure, after divertingNr string -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

	} else {	/* to CALL CONTROL */

		Ns_div_leg_inf2_counter = ns_op_div_leg_info_2.counter;
		Ns_div_leg_inf2_reason = ns_op_div_leg_info_2.reason;
		Ns_div_leg_inf2_div_pres_type = ns_op_div_leg_info_2.div_presented_nb_type;
		Ns_div_leg_inf2_div_nb_type = ns_op_div_leg_info_2.div_party_nb_type;
		Ns_div_leg_inf2_div_t_of_nb = ns_op_div_leg_info_2.div_type_of_nb;
		size = 0;
		p_next = &(Ns_div_leg_inf2_nb_str);

		switch (Ns_div_leg_inf2_div_pres_type) {

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :

					/* divertingNr type is NULL : no other data, stored data are in fact the ones for next PartyNumber fields */

				ns_op_div_leg_info_2.orig_party_nb_type = ns_op_div_leg_info_2.div_party_nb_type;
				ns_op_div_leg_info_2.orig_type_of_nb = ns_op_div_leg_info_2.div_type_of_nb;
				ns_op_div_leg_info_2.orig_number_digits.size = ns_op_div_leg_info_2.div_number_digits.size;
				ns_op_div_leg_info_2.orig_number_digits.p_string = ns_op_div_leg_info_2.div_number_digits.p_string;
				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* divertingNr type is PartyNumber */

				if ((Ns_div_leg_inf2_div_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
					(Ns_div_leg_inf2_div_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

						/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

					ns_op_div_leg_info_2.orig_type_of_nb = ns_op_div_leg_info_2.div_type_of_nb;
				}

				size = ns_op_div_leg_info_2.div_number_digits.size;
					/* divertingNr string : at the end of the structure */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_2.div_number_digits.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */
				break;
		}

		Ns_div_leg_inf2_div_nb_size = size;

		Ns_div_leg_inf2_orig_pres_type = ns_op_div_leg_info_2.orig_presented_nb_type;
		Ns_div_leg_inf2_orig_nb_type = ns_op_div_leg_info_2.orig_party_nb_type;
		Ns_div_leg_inf2_orig_t_of_nb = ns_op_div_leg_info_2.orig_type_of_nb;
		size = 0;

		if ((Ns_div_leg_inf2_orig_pres_type == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_div_leg_inf2_orig_pres_type == NS_SS_PRES_RESTRICTED_NB)) {

			size = ns_op_div_leg_info_2.orig_number_digits.size;
				/* originalCalledNr string : at the end of the structure, after divertingNr string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_2.orig_number_digits.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_div_leg_inf2_orig_nb_size = size;

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

	/* DivertingLegInformation3 operation */

uchar ns_ssdu_op_div_leg_info_3 (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_leg_info_3 = Ns_div_leg_inf3_pres_allow;

	} else {	/* to CALL CONTROL */

		Ns_div_leg_inf3_pres_allow = ns_op_div_leg_info_3;
		p_ssdu_val += Rnd_sizeof (struct ns_div_leg_info_3_arg);
	}

	return (OK);
}

#endif

#endif /* end of "NS_SS_DIVERSION = ON"} */

/*==========================================================================*/

		/* Explicit Channel Reservation
		 * ---------------------------- */

#if NS_SS_EXPL_CHAN_RESERVATION == ON	/* Explicit Channel Reservation function supported{ */

			/* operation values (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_EXP_CH_RES_CREATE			20		/* Explicit Reservation Creation Control */
#define NS_OP_VAL_EXP_CH_RES_MANAGE			21		/* Explicit Reservation Management */
#define NS_OP_VAL_EXP_CH_RES_CANCEL			22		/* Explicit Reservation Cancel */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

			/* operation internal data : argument + result */

	/* ExplicitReservationCreationControl operation : ARGUMENT */

uchar	ns_op_ch_res_control_opt;		/* controlOption : ENUMERATED {0, 1, 2} */

	/* ExplicitReservationCreationControl operation : RESULT */

char	ns_op_ch_res_create_ind;		/* ReservationIndicator : INTEGER (-128..127) */

	/* ExplicitReservationManagement operation : ARGUMENT */

char	ns_op_ch_res_manage_ind;		/* ReservationIndicator : INTEGER (-128..127) */

	/* ExplicitReservationCancel operation : ARGUMENT */

char	ns_op_ch_res_cancel_ind;		/* ReservationIndicator : INTEGER (-128..127) */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* ExplicitReservationCreationControl operation ARGUMENT : ENUMERATED {noReservationRequired(0),
				ReservationRequiredWithReservationIndicator(1), ReservationRequiredWithoutReservationIndicator(2)} */

#define NS_EXP_CH_RES_CREATE_ARG_P		NS_SS_ENUMERATED_P

	/*	ExplicitReservationCreationControl operation RESULT =
		ExplicitReservationManagement operation ARGUMENT =
		ExplicitReservationCancel operation ARGUMENT = INTEGER (-128..127) */

#define NS_EXP_CH_RES_CREATE_RES_P		NS_SS_INTEGER_P
#define NS_EXP_CH_RES_MANAGE_ARG_P		NS_SS_INTEGER_P
#define NS_EXP_CH_RES_CANCEL_ARG_P		NS_SS_INTEGER_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* ExplicitReservationCreationControl operation */

uchar ns_ssdu_op_exp_ch_res_create (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (OK);	/*  no data */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_op_ch_res_control_opt = Ns_exp_ch_res_create_option;
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		ns_op_ch_res_create_ind = Ns_exp_ch_res_indicator;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_exp_ch_res_create_option = ns_op_ch_res_control_opt;
			p_ssdu_val += Rnd_sizeof (struct ns_exp_ch_res_create_arg);
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_exp_ch_res_indicator = ns_op_ch_res_create_ind;
		p_ssdu_val += Rnd_sizeof (struct ns_exp_ch_res_all_op);
	}

	return (OK);
}

		/*	ExplicitReservationManagement operation */

uchar ns_ssdu_op_exp_ch_res_manage (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (OK);	/*  no data */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (NOK);	/* there is data in operation but there should not be */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */
		ns_op_ch_res_manage_ind = Ns_exp_ch_res_indicator;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_exp_ch_res_indicator = ns_op_ch_res_manage_ind;
		p_ssdu_val += Rnd_sizeof (struct ns_exp_ch_res_all_op);
	}

	return (OK);
}

		/*	ExplicitReservationCancel operation */

uchar ns_ssdu_op_exp_ch_res_cancel (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (OK);	/*  no data */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (NOK);	/* there is data in operation but there should not be */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */
		ns_op_ch_res_cancel_ind = Ns_exp_ch_res_indicator;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_exp_ch_res_indicator = ns_op_ch_res_cancel_ind;
		p_ssdu_val += Rnd_sizeof (struct ns_exp_ch_res_all_op);
	}

	return (OK);
}

#endif /* end of "Explicit Channel Reservation function supported"} */

/*==========================================================================*/

		/*	Three-Party SS (3PTY)
		 * ---------------------- */

#if NS_SS_3_PARTY == ON		/* Three-Party SS supported{ */

			/* operation values (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_3_PARTY_BEGIN				4		/* begin3PTY */
#define NS_OP_VAL_3_PARTY_END				5		/* end3PTY */

		/* no operation specific data for both operations (ARGUMENT and RESULT are empty) */

#endif /* end of "Three-Party SS supported"} */

/*==========================================================================*/

		/* Conference call, add-on SS (CONF)
		 * --------------------------------- */

#if NS_SS_CONFERENCE == ON	/* Conference call SS supported{ */

		/* lists of presence indicators for instances of Types Marked OPTIONAL (or DEFAULT) inside ASN1 SEQUENCE type */

#define Conf_begin_party_id		ns_asn1_optional_indicators		/* 'PartyId' inside BeginCONF RESULT : 1 indicator */

		/* PartyId ::= INTEGER (0..127) */

#define NS_CONF_PARTY_ID_P			NS_SS_INTEGER_P

		/* ConferenceId ::= INTEGER (0..127) */

#define NS_CONF_CONFERENCE_ID_P		NS_SS_INTEGER_P

		/* ConfSize ::= INTEGER (0..127) */

#define NS_CONF_CONF_SIZE_P			NS_SS_INTEGER_P

			/* operation values (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_CONF_BEGIN				40		/* begin CONF */
#define NS_OP_VAL_CONF_ADD					41		/* add CONF */
#define NS_OP_VAL_CONF_SPLIT				42		/* split CONF */
#define NS_OP_VAL_CONF_DROP					43		/* drop CONF */
#define NS_OP_VAL_CONF_ISOLATE				44		/* isolate CONF */
#define NS_OP_VAL_CONF_REATTACH				45		/* reattach CONF */
#define NS_OP_VAL_CONF_PARTY_DISC			46		/* party DISC */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

			/* operation internal data : argument + result */

	/* BeginCONF operation : ARGUMENT */

uchar	ns_op_conf_begin_size;		/* ConfSize : INTEGER (0..127) */

	/* BeginCONF operation : RESULT */

struct ns_op_conf_begin_res {
	uchar	conf_id;				/* ConferenceId in RESULT : INTEGER (0..127) */
	uchar	party_id;				/* PartyId in RESULT : INTEGER (0..127) */

} ns_op_conf_begin_res;

	/* AddCONF operation : ARGUMENT */

uchar	ns_op_conf_add_conf_id;		/* ConferenceId : INTEGER (0..127) */

	/* AddCONF operation : RESULT */

uchar	ns_op_conf_add_party_id;	/* PartyId : INTEGER (0..127) */

	/* SplitCONF operation : ARGUMENT (same as BeginCONF RESULT) */

struct ns_op_conf_begin_res		ns_op_conf_split_arg;

	/* DropCONF operation : ARGUMENT */

uchar	ns_op_conf_drop_party_id;	/* PartyId : INTEGER (0..127) */

	/* IsolateCONF operation : ARGUMENT */

uchar	ns_op_conf_isolate_party_id;	/* PartyId : INTEGER (0..127) */

	/* ReattachCONF operation : ARGUMENT */

uchar	ns_op_conf_reattach_party_id;	/* PartyId : INTEGER (0..127) */

	/* PartyDISC operation : ARGUMENT */

uchar	ns_op_conf_partydisc_party_id;	/* PartyId : INTEGER (0..127) */

#if NS_SS_INTERACTIONS == ON	/* Supplementary service interactions */

	/*	IdentifyConferee operation ARGUMENT */

uchar	ns_op_inter_id_conf_party_id;	/* PartyId : INTEGER (0..127) */

#endif		/* end of Supplementary service interactions */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* BeginCONF operation ARGUMENT = ConfSize */

#define NS_CONF_BEGIN_ARG_P				NS_CONF_CONF_SIZE_P

	/* AddCONF operation ARGUMENT = ConferenceId */

#define NS_CONF_ADD_ARG_P				NS_CONF_CONFERENCE_ID_P

	/*	AddCONF operation RESULT = DropCONF operation ARGUMENT =
		IsolateCONF operation ARGUMENT = ReattachCONF operation ARGUMENT =
		PartyDISC operation ARGUMENT = PartyId */

#define NS_CONF_ADD_RES_P				NS_CONF_PARTY_ID_P
#define NS_CONF_DROP_ARG_P				NS_CONF_PARTY_ID_P
#define NS_CONF_ISOLATE_ARG_P			NS_CONF_PARTY_ID_P
#define NS_CONF_REATTACH_ARG_P			NS_CONF_PARTY_ID_P
#define NS_CONF_PARTY_DISC_ARG_P		NS_CONF_PARTY_ID_P

#if NS_SS_INTERACTIONS == ON	/* Supplementary service interactions */

	/*	IdentifyConferee operation ARGUMENT = PartyID */

#define NS_INTER_ID_CONF_ARG_P			NS_CONF_PARTY_ID_P

#endif		/* end of Supplementary service interactions */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* BeginCONF operation */

uchar ns_ssdu_op_conf_begin (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> ARGUMENT clause may be empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (RESULT clause not empty) */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_op_conf_begin_size = Ns_conf_begin_conf_size;
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		ns_op_conf_begin_res.conf_id = Ns_conf_begin_conf_id;
		ns_op_conf_begin_res.party_id = Ns_conf_begin_party_id;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_conf_begin_conf_size = ns_op_conf_begin_size;
			p_ssdu_val += Rnd_sizeof (struct ns_conf_begin_arg);
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_conf_begin_conf_id = ns_op_conf_begin_res.conf_id;
		Ns_conf_begin_party_id = ns_op_conf_begin_res.party_id;
		p_ssdu_val += Rnd_sizeof (struct ns_conf_begin_res);
	}

	return (OK);
}

		/* AddCONF operation */

uchar ns_ssdu_op_conf_add (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_op_conf_add_conf_id = Ns_conf_add_conf_id;
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		ns_op_conf_add_party_id = Ns_conf_party_id;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_conf_add_conf_id = ns_op_conf_add_conf_id;
			p_ssdu_val += Rnd_sizeof (struct ns_conf_add_arg);
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_conf_party_id = ns_op_conf_add_party_id;
		p_ssdu_val += Rnd_sizeof (struct ns_conf_add_res_or_other_arg);
	}

	return (OK);
}

		/*	same function for following operations :
				- SplitCONF,
				- DropCONF,
				- IsolateCONF,
				- ReattachCONF,
				- PartyDISC.
		*/

uchar ns_ssdu_op_conf_other (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		switch (I_ss_fac_op_err_id) {		/* store ARGUMENT according to operation ID */

			case NS_OP_CONF_DROP :		/* drop CONF */

				ns_op_conf_drop_party_id = Ns_conf_party_id;
				break;

			case NS_OP_CONF_ISOLATE :		/* isolate CONF */

				ns_op_conf_isolate_party_id = Ns_conf_party_id;
				break;

			case NS_OP_CONF_REATTACH :		/* reattach CONF */

				ns_op_conf_reattach_party_id = Ns_conf_party_id;
				break;

			case NS_OP_CONF_PARTY_DISC :		/* party DISC */

				ns_op_conf_partydisc_party_id = Ns_conf_party_id;
				break;

#			if NS_SS_INTERACTIONS == ON
				case NS_OP_INTERACT_ID_CONFEREE :	/* IdentifyConferee */

					ns_op_inter_id_conf_party_id = Ns_conf_party_id;
					break;
#			endif

			case NS_OP_CONF_SPLIT :		/* split CONF */

				ns_op_conf_split_arg.conf_id = Ns_conf_split_conf_id;
				ns_op_conf_split_arg.party_id = Ns_conf_split_party_id;
				break;
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		switch (I_ss_fac_op_err_id) {		/* store ARGUMENT according to operation ID */

			case NS_OP_CONF_DROP :		/* drop CONF */

				Ns_conf_party_id = ns_op_conf_drop_party_id;
				break;

			case NS_OP_CONF_ISOLATE :		/* isolate CONF */

				Ns_conf_party_id = ns_op_conf_isolate_party_id;
				break;

			case NS_OP_CONF_REATTACH :		/* reattach CONF */

				Ns_conf_party_id = ns_op_conf_reattach_party_id;
				break;

			case NS_OP_CONF_PARTY_DISC :		/* party DISC */

				Ns_conf_party_id = ns_op_conf_partydisc_party_id;
				break;

#			if NS_SS_INTERACTIONS == ON
				case NS_OP_INTERACT_ID_CONFEREE :	/* IdentifyConferee */

					Ns_conf_party_id = ns_op_inter_id_conf_party_id;
					break;
#			endif

			case NS_OP_CONF_SPLIT :		/* split CONF */

				Ns_conf_split_conf_id = ns_op_conf_split_arg.conf_id;
				Ns_conf_split_party_id = ns_op_conf_split_arg.party_id;
				p_ssdu_val += Rnd_sizeof (struct ns_conf_split_arg);
				return (OK);
		}

		p_ssdu_val += Rnd_sizeof (struct ns_conf_add_res_or_other_arg);
	}

	return (OK);
}

#endif /* end of Conference call SS supported} */

/*==========================================================================*/

		/*	User-to-User Signalling SS (UUS) (defined in ETS 300 102)
		 * ---------------------------------------------------------- */

#if NS_SS_USER_USER_EXP == ON	/* explicit requests for User-to-User Signalling SS supported{ */

		/*	Operation for UUS SS : UUS Request
		 * ----------------------------------- */

			/* operation value (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_UUS_RQ				1	

			/* operation internal data : argument + result */

			/* UserUserService operation ARGUMENT */

struct	ns_op_uus_rq {
	uchar	service;				/* type of service requested :  1, 2 or 3 */
	uchar	preferred;				/* preferred indicator : TRUE/FALSE */

} ns_op_uus_rq [NS_SS_MAX_UUS_RQ];

#if (NS_SS_INTERACTIONS == ON) && (NS_SS_DIVERSION == ON)	/* Diversion SS and SS interactions supported */

	/*	UUSRequest operation ARGUMENT = UserUserService operation ARGUMENT */

struct	ns_op_uus_rq	ns_op_interact_uus_rq; 

#endif

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/*	UUSRequest operation ARGUMENT = UserUserService operation ARGUMENT */

#define NS_INTER_UUS_RQ_ARG_P			NS_UUS_RQ_OP_ARG_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

uchar ns_ssdu_op_uus_rq (p_start, offset)
	uchar FAR				*p_start;			/* pointer to start of component */
	ushort					offset;				/* offset of data in received SSDU */
{
	uchar FAR				*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

#		if (NS_SS_INTERACTIONS == ON) && (NS_SS_DIVERSION == ON)

			/* Diversion SS and SS interactions supported : 2 possible operations 
				-> store ARGUMENT according to operation ID */

			if (I_ss_fac_op_err_id == NS_OP_INTERACT_UUS_RQ) {

				ns_op_interact_uus_rq.service = Ns_uus_rq_service;
				ns_op_interact_uus_rq.preferred = Ns_uus_rq_preferred;
				return (OK);
			}

#		endif

		ns_op_uus_rq[ns_i_ss_clause_nb].service = Ns_uus_rq_service;
		ns_op_uus_rq[ns_i_ss_clause_nb].preferred = Ns_uus_rq_preferred;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

#		if (NS_SS_INTERACTIONS == ON) && (NS_SS_DIVERSION == ON)

			/* Diversion SS and SS interactions supported : 2 possible operations
				-> store ARGUMENT according to operation ID */

			if (I_ss_fac_op_err_id == NS_OP_INTERACT_UUS_RQ) {

				Ns_uus_rq_service = ns_op_interact_uus_rq.service;
				Ns_uus_rq_preferred = ns_op_interact_uus_rq.preferred;
				p_ssdu_val += Rnd_sizeof (struct ns_op_uus_rq);
				return (OK);
			}

#		endif

		Ns_uus_rq_service = ns_op_uus_rq[ns_i_ss_clause_nb].service;
		Ns_uus_rq_preferred = ns_op_uus_rq[ns_i_ss_clause_nb].preferred;
		p_ssdu_val += Rnd_sizeof (struct ns_op_uus_rq);
	}

	return (OK);
}

#endif	/* end of "explicit requests for User-to-User Signalling SS supported"} */

/*==========================================================================*/

		/*	Explicit Call Transfer SS (ECT)
		 * -------------------------------- */

#if NS_SS_ECT == ON			/* Explicit Call Transfer supported{ */

		/* lists of presence indicators for instances of Types Marked OPTIONAL inside ASN1 SEQUENCE type */

#define Ect_inform_redir_nb			ns_asn1_optional_indicators		/* 'redirectionNumber' inside EctInform ARGUMENT : 1 indicator */

		/* LinkId ::= INTEGER (1..127) */

#define NS_ECT_LINK_ID_P			NS_SS_INTEGER_P

		/* CallTransferIdentity ::= INTEGER (-128..127) */

#define NS_ECT_CALL_TRF_ID_P		NS_SS_INTEGER_P

		/* LoopResult ::= ENUMERATED (insufficientInformation(0), noLoopExists(1), simultaneousTransfer(2)) */

#define NS_ECT_LOOP_RES_P			NS_SS_ENUMERATED_P

			/* operation values (used in Facility IE inside SPDUs) :
				only 1 is a "localvalue", defined with INTEGER type
				others are "globalvalue", defined with OBJECT IDENTIFIER type
					see above (OBJECT IDENTIFIER TREE)
			*/

#define NS_OP_VAL_ECT_EXECUTE			6		/* ectExecute */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

			/* operation internal data : argument + result */

	/* EctInform operation : ARGUMENT */

struct ns_op_ect_inform_arg {
	uchar					status;						/* Information status : ALERTING / ACTIVE */
	uchar					redir_presented_nb_type;	/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside redirectionNumber */
	uchar					redir_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside redirectionNumber */
	uchar					redir_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside redirectionNumber) */
	struct ns_asn1_string	redir_number_digits;		/* NumberDigits string in PartyNumber inside redirectionNumber */

} ns_op_ect_inform_arg;

	/* EctLinkIdRequest operation : RESULT */

uchar	ns_op_ect_lk_id_rq_link;	/* Link ID : INTEGER (1..127) */

	/* EctLoopTest operation : ARGUMENT */

char	ns_op_ect_loop_test_call_id;	/* Call Transfer Identity : INTEGER (-128..127) */

	/* EctLoopTest operation : RESULT */

uchar	ns_op_ect_loop_test_res;	/* Loop Result : ENUMERATED {0, 1, 2} */

	/* ExplicitEctExecute operation : ARGUMENT */

uchar	ns_op_ect_exp_exec_link;	/* Link ID : INTEGER (1..127) */

	/* SubaddressTransfer operation : ARGUMENT */

struct ns_op_ect_subadd_trf_arg {
	uchar					trf_sa_type;			/* index of chosen type in PartySubaddress (inside transferredToSubaddress) */
	uchar					trf_sa_odd_count;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside transferredToSubaddress) */
	struct ns_asn1_string	trf_sa;					/* string in PartySubaddress inside transferredToSubaddress */

} ns_op_ect_subadd_trf_arg;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* EctLinkIdRequest operation RESULT = LinkId */

#define NS_ECT_LINK_ID_RQ_RES_P			NS_ECT_LINK_ID_P

	/* EctLoopTest operation ARGUMENT = CallTransferIdentity */

#define NS_ECT_LOOP_TEST_ARG_P			NS_ECT_CALL_TRF_ID_P

	/* EctLoopTest operation RESULT = LoopResult */

#define NS_ECT_LOOP_TEST_RES_P			NS_ECT_LOOP_RES_P

	/* ExplicitEctExecute operation ARGUMENT = LinkId */

#define NS_ECT_EXP_EXECUTE_ARG_P		NS_ECT_LINK_ID_P

	/* SubaddressTransfer operation ARGUMENT = PartySubaddress */

#define NS_ECT_SUBADD_TRF_ARG_P			NS_SS_PARTY_SUBADDRESS_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* EctInform operation */

uchar ns_ssdu_op_ect_inform (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (ARGUMENT clause not empty) */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_ect_inform_arg.status = Ns_ect_info_status;

		ns_op_ect_inform_arg.redir_presented_nb_type = Ns_ect_info_pres_nb_type;
		switch (Ns_ect_info_pres_nb_type) {

			case 255 :	/* redirection nb is absent */

				ns_op_ect_inform_arg.redir_presented_nb_type = 254;
				break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/*  type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* redirectionNumber type is PartyNumber */

				if (Ns_ect_info_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_ect_inform_arg.redir_party_nb_type = Ns_ect_info_p_nb_type;
				ns_op_ect_inform_arg.redir_type_of_nb = Ns_ect_info_type_of_nb;
				ns_op_ect_inform_arg.redir_number_digits.size = size = Ns_ect_info_nb_sz;
				ns_op_ect_inform_arg.redir_number_digits.p_string = p_ind_buffer;

					/* redirection number string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_ect_info_first_nb), size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_ect_info_status = ns_op_ect_inform_arg.status;
		Ns_ect_info_pres_nb_type = ns_op_ect_inform_arg.redir_presented_nb_type;
		Ns_ect_info_p_nb_type = ns_op_ect_inform_arg.redir_party_nb_type;
		Ns_ect_info_type_of_nb = ns_op_ect_inform_arg.redir_type_of_nb;
		Ns_ect_info_nb_sz = size = 0;

		switch (Ns_ect_info_pres_nb_type) {

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* redirectionNumber type is PartyNumber */

				Ns_ect_info_nb_sz = size = ns_op_ect_inform_arg.redir_number_digits.size;
					/* redirectionNumber string : at the end of the structure */
				Memcpy_far ((char FAR *)&(Ns_ect_info_first_nb), (char FAR *)ns_op_ect_inform_arg.redir_number_digits.p_string, size);
				break;
		}

		p_ssdu_val = &(Ns_ect_info_first_nb);
		p_ssdu_val += size;
	}

	return (OK);
}

		/* EctLinkIdRequest operation */

uchar ns_ssdu_op_ect_lk_id_rq (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> ARGUMENT clause is empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (RESULT clause not empty) */
		}

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> ARGUMENT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* ReturnResult component -> process RESULT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_ect_lk_id_rq_link = Ns_ect_lk_id_rq_link;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause : empty */

			return (STOP);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_ect_lk_id_rq_link = ns_op_ect_lk_id_rq_link;
		p_ssdu_val += Rnd_sizeof (struct ns_ect_lk_id_rq_res);
	}

	return (OK);
}

		/* EctLoopTest operation */

uchar ns_ssdu_op_ect_loop_test (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_op_ect_loop_test_call_id = Ns_ect_loop_test_call_id;
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		ns_op_ect_loop_test_res = Ns_ect_loop_test_result;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_ect_loop_test_call_id = ns_op_ect_loop_test_call_id;
			p_ssdu_val += Rnd_sizeof (struct ns_ect_loop_test_arg);
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_ect_loop_test_result = ns_op_ect_loop_test_res;
		p_ssdu_val += Rnd_sizeof (struct ns_ect_loop_test_res);
	}

	return (OK);
}

		/* ExplicitEctExecute operation */

uchar ns_ssdu_op_ect_exp_exec (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (ARGUMENT clause not empty) */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_ect_exp_exec_link = Ns_ect_explicit_exec_link_id;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_ect_explicit_exec_link_id = ns_op_ect_exp_exec_link;
		p_ssdu_val += Rnd_sizeof (struct ns_ect_explicit_exec_arg);
	}

	return (OK);
}

		/* SubaddressTransfer operation */

uchar ns_ssdu_op_ect_subadd_trf (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (ARGUMENT clause not empty) */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_ect_trf_subadd_type > NS_SS_MX_PARTY_SA_TYPE) {

			return (NOK);	/* bad type of PartySubaddress */
		}

		ns_op_ect_subadd_trf_arg.trf_sa_type = Ns_ect_trf_subadd_type;

		if (Ns_ect_trf_subadd_type == NS_SS_PARTY_SA_USER_SPECIF) {

			ns_op_ect_subadd_trf_arg.trf_sa_odd_count = (Ns_ect_trf_subadd_odd_c == 255) ? 254 : Ns_ect_trf_subadd_odd_c;
		}

		ns_op_ect_subadd_trf_arg.trf_sa.p_string = p_ind_buffer;
		ns_op_ect_subadd_trf_arg.trf_sa.size = size = Ns_ect_trf_subadd_sz;
			/* transferredToSubaddress string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_ect_trf_subadd_first), size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_ect_trf_subadd_type = ns_op_ect_subadd_trf_arg.trf_sa_type;
		Ns_ect_trf_subadd_odd_c = ns_op_ect_subadd_trf_arg.trf_sa_odd_count;
		Ns_ect_trf_subadd_sz = size = ns_op_ect_subadd_trf_arg.trf_sa.size;

			/* transferredToSubaddress string : at the end of the structure */
		Memcpy_far ((char FAR *)&(Ns_ect_trf_subadd_first), (char FAR *)ns_op_ect_subadd_trf_arg.trf_sa.p_string, size);
		p_ssdu_val = &(Ns_ect_trf_subadd_first);
		p_ssdu_val += size;
	}

	return (OK);
}

#endif	/* end of Explicit Call Transfer supported} */

/*==========================================================================*/

		/*	Malicious Call Identification SS (MCID)
		 * ---------------------------------------- */

#if NS_SS_MALICIOUS_CALL_ID == ON	/* Malicious Call ID SS supported{ */

			/* operation value (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_MCID_REQUEST				3		/* mCIDRequest */

		/* no operation specific data for operation (ARGUMENT and RESULT are empty) */

#endif /* end of "Malicious Call ID SS supported"} */

/*==========================================================================*/

		/*	Freephone SS (FPH)
		 * ------------------- */

#if NS_SS_FREEPHONE == ON		/* Freephone supported{ */

		/* lists of presence indicators for instances of Types Marked OPTIONAL inside ASN1 SEQUENCE type */

#define Fph_monitor_queue_id		ns_asn1_optional_indicators		/* 'queueIdentity' inside Monitor-T-FPH ARGUMENT : 1 indicator */
#define Fph_call_t_called_nb		ns_asn1_optional_indicators		/* 'calledFreephoneNr' inside Call-T-FPH ARGUMENT : 1 indicator */

		/* FPHReference ::= INTEGER (0..127) */

#define NS_SS_FPH_REFERENCE_P		NS_SS_INTEGER_P

		/* QueueIdentity ::= INTEGER (0..127) */

#define NS_SS_FPH_QUEUE_ID_P		NS_SS_INTEGER_P

			/* operation values (used in Facility IE inside SPDUs) :
				all are "globalvalue", defined with OBJECT IDENTIFIER type
					see above (OBJECT IDENTIFIER TREE)
			*/

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

			/* operation internal data : argument + result */

	/* CallFPH operation : ARGUMENT (optional) */

struct ns_op_fph_call_arg {
	uchar					party_nb_type;				/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) */
	uchar					type_of_nb;					/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	struct ns_asn1_string	number_digits;				/* NumberDigits string inside PartyNumber */

} ns_op_fph_call_arg;

	/* Monitor-T-FPH operation : ARGUMENT */

struct ns_op_fph_monitor_t_arg {
	struct ns_asn1_string	q931_ie;					/* Q931 IE string */
	struct ns_asn1_string	s_u_number_digits;			/* NumberDigits string inside servedUserDestination */
	uchar					s_u_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserDestination */
	uchar					s_u_type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	uchar					queue_id;					/* queue identity : INTEGER (0..127) or 255 if absent */

} ns_op_fph_monitor_t_arg;

	/* Free-T-FPH operation : ARGUMENT */

struct ns_op_fph_free_t_arg {
	struct ns_asn1_string	s_u_number_digits;			/* NumberDigits string inside servedUserDestination */
	uchar					s_u_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserDestination */
	uchar					s_u_type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	uchar					fph_ref;					/* FPH reference : INTEGER (0..127) */

} ns_op_fph_free_t_arg;

	/* Call-T-FPH operation : ARGUMENT */

struct ns_op_fph_call_t_arg {
	struct ns_asn1_string	number_digits;				/* NumberDigits string inside calledFreephoneNr */
	uchar					party_nb_type;				/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside calledFreephoneNr */
	uchar					type_of_nb;					/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	uchar					fph_ref;					/* FPH reference : INTEGER (0..127) */

} ns_op_fph_call_t_arg;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* CallFPH operation ARGUMENT = PartyNumber */

#define NS_FPH_CALL_ARG_P				NS_SS_PARTY_NUMBER_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* CallFPH operation */

uchar ns_ssdu_op_fph_call (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (OK);	/*  no data */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_fph_call_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_fph_call_arg.party_nb_type = Ns_fph_call_party_nb_t;
		ns_op_fph_call_arg.type_of_nb = Ns_fph_call_type_of_nb;
		ns_op_fph_call_arg.number_digits.size = size = Ns_fph_call_nb_sz;
		ns_op_fph_call_arg.number_digits.p_string = p_ind_buffer;
			/* called freephone number string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_fph_call_first_nb), size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if ((I_ss_fac_comp_tag == FAC_RETURN_RESULT) ||	/* ReturnResult component -> process RESULT clause : empty */
			(ns_op_fph_call_arg.party_nb_type == 255)) {	/* ... or Invoke component empty */

			return (STOP);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_fph_call_party_nb_t = ns_op_fph_call_arg.party_nb_type;
		Ns_fph_call_type_of_nb = ns_op_fph_call_arg.type_of_nb;
		Ns_fph_call_nb_sz = size = ns_op_fph_call_arg.number_digits.size;
			/* called freephone number string : at the end of the structure */
		Memcpy_far ((char FAR *)&(Ns_fph_call_first_nb), (char FAR *)ns_op_fph_call_arg.number_digits.p_string, size);

		p_ssdu_val = &(Ns_fph_call_first_nb);
		p_ssdu_val += size;
	}

	return (OK);
}

		/* Monitor-T-FPH operation */

uchar ns_ssdu_op_fph_monitor_t (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (ARGUMENT clause not empty) */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_fph_monitor_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_fph_monitor_t_arg.queue_id = (Ns_fph_monitor_queue_id == 255) ? 254 : Ns_fph_monitor_queue_id;

		p_next = &(Ns_fph_monitor_first_str);			/* set pointer to end of structure inside SSDU */

		ns_op_fph_monitor_t_arg.q931_ie.size = size = Ns_fph_monitor_q931_ie_sz;
		ns_op_fph_monitor_t_arg.q931_ie.p_string = p_ind_buffer;
			/* Q931 IE string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to SSDU data */

		ns_op_fph_monitor_t_arg.s_u_party_nb_type = Ns_fph_monitor_party_nb_t;
		ns_op_fph_monitor_t_arg.s_u_type_of_nb = Ns_fph_monitor_type_of_nb;
		ns_op_fph_monitor_t_arg.s_u_number_digits.size = size = Ns_fph_monitor_nb_sz;
		ns_op_fph_monitor_t_arg.s_u_number_digits.p_string = p_ind_buffer;
			/* servedUserDestination number string : at the end of the structure, after Q931 IE string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_fph_monitor_queue_id = ns_op_fph_monitor_t_arg.queue_id;
		Ns_fph_monitor_party_nb_t = ns_op_fph_monitor_t_arg.s_u_party_nb_type;
		Ns_fph_monitor_type_of_nb = ns_op_fph_monitor_t_arg.s_u_type_of_nb;

		p_next = &(Ns_fph_monitor_first_str);	/* set pointer to end of structure inside SSDU */

			/* Q931 IE string : at the end of the structure */
		Ns_fph_monitor_q931_ie_sz = size = ns_op_fph_monitor_t_arg.q931_ie.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_fph_monitor_t_arg.q931_ie.p_string, size);
		p_next += size;				/* update pointer to SSDU data */

			/* servedUserDestination number string : at the end of the structure, after Q931 IE string */
		Ns_fph_monitor_nb_sz = size = ns_op_fph_monitor_t_arg.s_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_fph_monitor_t_arg.s_u_number_digits.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* Free-T-FPH operation */

uchar ns_ssdu_op_fph_free_t (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (ARGUMENT clause not empty) */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_fph_free_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_fph_free_t_arg.s_u_party_nb_type = Ns_fph_free_party_nb_t;
		ns_op_fph_free_t_arg.s_u_type_of_nb = Ns_fph_free_type_of_nb;
		ns_op_fph_free_t_arg.fph_ref = Ns_fph_free_fph_ref;

		ns_op_fph_free_t_arg.s_u_number_digits.size = size = Ns_fph_free_nb_sz;
		ns_op_fph_free_t_arg.s_u_number_digits.p_string = p_ind_buffer;
			/* servedUserDestination number string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_fph_free_first_nb), size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_fph_free_party_nb_t = ns_op_fph_free_t_arg.s_u_party_nb_type;
		Ns_fph_free_type_of_nb = ns_op_fph_free_t_arg.s_u_type_of_nb;
		Ns_fph_free_fph_ref = ns_op_fph_free_t_arg.fph_ref;

		p_next = &(Ns_fph_free_first_nb);	/* set pointer to end of structure inside SSDU */

			/* servedUserDestination number string : at the end of the structure */
		Ns_fph_free_nb_sz = size = ns_op_fph_free_t_arg.s_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_fph_free_t_arg.s_u_number_digits.p_string, size);
		p_next += size;				/* update pointer to SSDU data */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* Call-T-FPH operation */

uchar ns_ssdu_op_fph_t_call (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

				return (OK);	/*  no data */
			}

			return (NOK);	/* there is no data but there should be (ARGUMENT clause not empty) */
		}

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause is empty */

			return (NOK);	/* there is data but there should not */
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_fph_call_t_arg.fph_ref = Ns_fph_call_t_fph_ref;

		if (Ns_fph_call_t_party_nb_t == 255) {

				/* called freephone number is absent */

			ns_op_fph_call_t_arg.party_nb_type = 254;
			ns_op_fph_call_t_arg.type_of_nb = 254;
			ns_op_fph_call_t_arg.number_digits.size = 254;
			return (OK);
		}

		if (Ns_fph_call_t_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_fph_call_t_arg.party_nb_type = Ns_fph_call_t_party_nb_t;
		ns_op_fph_call_t_arg.type_of_nb = Ns_fph_call_t_type_of_nb;

		ns_op_fph_call_t_arg.number_digits.size = size = Ns_fph_call_t_nb_sz;
		ns_op_fph_call_t_arg.number_digits.p_string = p_ind_buffer;
			/* called freephone number string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_fph_call_t_first_nb), size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_fph_call_t_fph_ref = ns_op_fph_call_t_arg.fph_ref;
		Ns_fph_call_t_party_nb_t = ns_op_fph_call_t_arg.party_nb_type;
		Ns_fph_call_t_type_of_nb = ns_op_fph_call_t_arg.type_of_nb;

		p_next = &(Ns_fph_call_t_first_nb);	/* set pointer to end of structure inside SSDU */

			/* servedUserDestination number string : at the end of the structure */
		Ns_fph_call_t_nb_sz = size = ns_op_fph_call_t_arg.number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_fph_call_t_arg.number_digits.p_string, size);
		p_next += size;				/* update pointer to SSDU data */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif	/* end of Freephone supported} */

/*==========================================================================*/

		/*	Completion of Calls to Busy Subscriber SS (CCBS)
		 * ------------------------------------------------- */

#if NS_SS_CCBS == ON		/* Completion of Calls to Busy Subscriber supported{ */

#if NS_USE_EUROPE_OPERATION == ON /* only used in EUROPEAN specific operations{ */

		/* lists of presence indicators for instances of Types Marked OPTIONAL inside ASN1 SEQUENCE type */

#define Ccbs_ref_in_interog_arg		ns_asn1_optional_indicators			/* 'cCBSReference' inside CCBSInterrogate ARGUMENT : 1 indicator */
#define Ccbs_nb_in_interog_arg		(ns_asn1_optional_indicators + 1)	/* 'partyNumberOfA' inside CCBSInterrogate ARGUMENT : 1 indicator */

	/* 'PartySubaddress' inside CallInformation : 10 (= 2*NS_CCBS_MX_CALL_INFO) indicators
		after indicators (10) used for oddCountIndicator inside PartySubaddress */

#define Ccbs_subadd_in_call_info	(ns_asn1_optional_indicators + 10)

	/* 'callDetails' inside CCBSInterrogate RESULT : 1 indicator
		after indicators (10 + 10) used for oddCountIndicator and PartySubaddress */

#define Ccbs_detail_in_interog_res	(ns_asn1_optional_indicators + 20)

	/* in CCBS-T-Request ARGUMENT :
			- 2 indicators for OddcountIndicator inside PartySubaddress (0 and 1)
			- 2 indicators for PartySubaddress inside Address (2 and 3)
			- 1 indicator for retentionSupported (4)
			- 1 indicator for presentationAllowedIndicator (5)
			- 1 indicator for originatingAddress (6) */

#define Ccbs_t_rq_retention			(ns_asn1_optional_indicators + 4)	/* 'retentionSupported' inside CCBS-T-Request ARGUMENT : 1 indicator */
#define Ccbs_t_rq_pres_allow		(ns_asn1_optional_indicators + 5)	/* 'presentationAllowedIndicator' inside CCBS-T-Request ARGUMENT : 1 indicator */
#define Ccbs_t_rq_pres_origin		(ns_asn1_optional_indicators + 6)	/* 'originatingAddress' inside CCBS-T-Request ARGUMENT : 1 indicator */

		/* CCBSReference ::= INTEGER (0..127) */

#define NS_SS_CCBS_REFERENCE_P		NS_SS_INTEGER_P

		/* CallLinkageID ::= INTEGER (0..127) */

#define NS_SS_CCBS_CALL_LK_ID_P		NS_SS_INTEGER_P

		/* CCBSEraseReason ::= ENUMERATED {normal-unspecified(0), t-CCBS2-timeout(1), t-CCBS3-timeout(2), basic-call-failed(3)} */

#define NS_SS_CCBS_ERASE_REAS_P		NS_SS_ENUMERATED_P

		/* RecallMode ::= ENUMERATED {globalRecall(0), specificRecall(1)} */

#define NS_SS_CCBS_RECALL_MODE_P	NS_SS_ENUMERATED_P

			/* operation values (used in Facility IE inside SPDUs) :
				all are "globalvalue", defined with OBJECT IDENTIFIER type
					see above (OBJECT IDENTIFIER TREE)
			*/

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

			/* operation internal data : argument + result */

	/* CallInfoRetain operation : ARGUMENT */

uchar ns_op_ccbs_call_info_lk_id;				/* call linkage ID = INTEGER (0..127) */

	/* EraseCallLinkageID operation : ARGUMENT */

uchar ns_op_ccbs_erase_call_lk_id;				/* call linkage ID = INTEGER (0..127) */

	/* CCBSDeactivate operation : ARGUMENT */

uchar ns_op_ccbs_deactivate_ref;				/* CCBS reference = INTEGER (0..127) */

	/* CCBSCall operation : ARGUMENT */

uchar ns_op_ccbs_call_ref;						/* CCBS reference = INTEGER (0..127) */

	/* CCBSStopAlerting operation : ARGUMENT */

uchar ns_op_ccbs_stop_alert_ref;				/* CCBS reference = INTEGER (0..127) */

	/* CCBSRequest operation : ARGUMENT */

uchar ns_op_ccbs_request_lk_id;					/* call linkage ID = INTEGER (0..127) */

	/* CCBSRequest operation : RESULT */

struct ns_op_ccbs_request_res {
	uchar	recall_mode;						/* recall mode = ENUMERATED {0, 1} */
	uchar	reference;							/* CCBS reference = INTEGER (0..127) */

} ns_op_ccbs_request_res;

#endif	/* end of "NS_USE_EUROPE_OPERATION == ON} */

	/* CCBSStatusRequest operation : ARGUMENT */

struct ns_op_ccbs_status_rq_arg {
	struct ns_asn1_string	q931_ie;			/* Q931 IE string */
	uchar					recall_mode;		/* recall mode = ENUMERATED {0, 1} */
	uchar					reference;			/* CCBS reference = INTEGER (0..127) */

} ns_op_ccbs_status_rq_arg;

#if NS_USE_EUROPE_OPERATION == ON /* only used in EUROPEAN specific operations{ */

	/* CCBSStatusRequest operation : RESULT */

uchar ns_op_ccbs_status_rq_res;					/* BOOLEAN : free = TRUE / busy = FALSE */

	/* CCBSRemoteUserFree operation : ARGUMENT */

struct ns_op_ccbs_remote_free_arg {
	struct ns_asn1_string	q931_ie;			/* Q931 IE string */
	struct ns_asn1_string	number_digits;		/* NumberDigits string in PartyNumber inside addressOfB */
	struct ns_asn1_string	sub_address;		/* PartySubaddress string inside addressOfB */
	uchar					recall_mode;		/* recall mode = ENUMERATED {0, 1} */
	uchar					reference;			/* CCBS reference = INTEGER (0..127) */
	uchar					party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside addressOfB */
	uchar					type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside addressOfB) */
	uchar					sub_add_type;		/* index of chosen type in PartySubaddress or 255 if absent (inside addressOfB) */
	uchar					sub_add_odd_c;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside addressOfB) */

} ns_op_ccbs_remote_free_arg;

	/* CCBSBFree operation : ARGUMENT (same as in CCBSRemoteUserFree operation) */

struct ns_op_ccbs_remote_free_arg	ns_op_ccbs_bfree_arg;

	/* CCBSErase operation : ARGUMENT */

struct ns_op_ccbs_erase_arg {
	struct ns_asn1_string	q931_ie;			/* Q931 IE string */
	struct ns_asn1_string	number_digits;		/* NumberDigits string in PartyNumber inside addressOfB */
	struct ns_asn1_string	sub_address;		/* PartySubaddress string inside addressOfB */
	uchar					recall_mode;		/* recall mode = ENUMERATED {0, 1} */
	uchar					reference;			/* CCBS reference = INTEGER (0..127) */
	uchar					party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside addressOfB */
	uchar					type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside addressOfB) */
	uchar					sub_add_type;		/* index of chosen type in PartySubaddress or 255 if absent (inside addressOfB) */
	uchar					sub_add_odd_c;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside addressOfB) */
	uchar					reason;				/* erase reason = ENUMERATED {0, 1, 2, 3} */

} ns_op_ccbs_erase_arg;

	/* CCBSInterrogate operation : ARGUMENT */

struct ns_op_ccbs_interog_arg {
	struct ns_asn1_string	number_digits;		/* NumberDigits string in PartyNumber inside partyNumberOfA */
	uchar					reference;			/* CCBS reference = INTEGER (0..127) or 255 if absent */
	uchar					party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside partyNumberOfA */
	uchar					type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside partyNumberOfA) */

} ns_op_ccbs_interog_arg;

	/* CCBSInterrogate operation : RESULT */

struct ns_op_ccbs_interog_res {
	struct ns_asn1_string	number_digits[NS_CCBS_MX_CALL_INFO];		/* NumberDigits strings in PartyNumber inside addressOfB */
	struct ns_asn1_string	q931_ie[NS_CCBS_MX_CALL_INFO];				/* Q931 IE strings */
	struct ns_asn1_string	sub_address[NS_CCBS_MX_CALL_INFO * 2];		/* strings in PartySubaddress inside addressOfB and subAddressOfA */
	uchar					recall_mode;								/* recall mode = ENUMERATED {0, 1} */
	uchar					call_info_nb;								/* number of CallInformation in callDetails */
	uchar					reference[NS_CCBS_MX_CALL_INFO];			/* CCBS reference = INTEGER (0..127) */
	uchar					party_nb_type[NS_CCBS_MX_CALL_INFO];		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside addressOfB */
	uchar					type_of_nb[NS_CCBS_MX_CALL_INFO];			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside addressOfB) */
	uchar					sub_add_type[NS_CCBS_MX_CALL_INFO * 2];		/* index of chosen type in PartySubaddress or 255 if absent (inside addressOfB and subAddressOfA) */
	uchar					sub_add_odd_c[NS_CCBS_MX_CALL_INFO * 2];	/* oddCountIndicator in PartySubaddress or 255 if absent (inside addressOfB and subAddressOfA) */

} ns_op_ccbs_interog_res;

#endif	/* end of "NS_USE_EUROPE_OPERATION == ON} */

	/* CCBS-T-Request operation : ARGUMENT */

struct ns_op_ccbs_t_rq_arg {
	struct ns_asn1_string	q931_ie;			/* Q931 IE string */
	struct ns_asn1_string	dest_nb_digits;		/* NumberDigits string in PartyNumber inside destinationaddress */
	struct ns_asn1_string	dest_sub_add;		/* PartySubaddress string inside destinationaddress */
	struct ns_asn1_string	orig_nb_digits;		/* NumberDigits string in PartyNumber inside originatingaddress */
	struct ns_asn1_string	orig_sub_add;		/* PartySubaddress string inside originatingaddress */

#if F_QSI == ON	/* Q-SIG specific data : used for CcbsRequest and CcnrRequest operations */
	struct ns_asn1_string	extension;			/* extension string */
	uchar					presented_nbA_type;	/* index of chosen type in PresentedNumberUnscreened (presentationAllowedNumber .. presentationRestrictedNumber) inside numberA */
	/* 'retention' is used for 'can-retain-service' value and 'pres_allow' for 'retain-sig-connection' value */
#	endif

	uchar					retention;			/* retention supported = BOOLEAN or 255 if absent */
	uchar					pres_allow;			/* presentationAllowedIndicator : TRUE/FALSE or 255 if absent */
	uchar					dest_party_nb_t;	/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside destinationaddress */
	uchar					dest_t_of_nb;		/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside destinationaddress) */
	uchar					dest_sa_type;		/* index of chosen type in PartySubaddress or 255 if absent (inside destinationaddress) */
	uchar					dest_sa_odd_c;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside destinationaddress) */
	uchar					orig_party_nb_t;	/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside originatingAddress */
	uchar					orig_t_of_nb;		/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originatingAddress) */
	uchar					orig_sa_type;		/* index of chosen type in PartySubaddress or 255 if absent (inside originatingAddress) */
	uchar					orig_sa_odd_c;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside originatingAddress) */

} ns_op_ccbs_t_rq_arg;

#if NS_USE_EUROPE_OPERATION == ON /* only used in EUROPEAN specific operations{ */

	/* CCBS-T-Request operation : RESULT */

uchar ns_op_ccbs_t_rq_retention;				/* retention supported = BOOLEAN */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/*	CallInfoRetain operation ARGUMENT =
		EraseCallLinkageID operation ARGUMENT =
		CCBSRequest operation ARGUMENT =
		CallLinkageID */

#define NS_CCBS_CALL_INFO_RET_ARG_P		NS_SS_CCBS_CALL_LK_ID_P
#define NS_CCBS_ERASE_CALL_LK_ARG_P		NS_SS_CCBS_CALL_LK_ID_P
#define NS_CCBS_REQUEST_ARG_P			NS_SS_CCBS_CALL_LK_ID_P

	/*	CCBSDeactivate operation ARGUMENT =
		CCBSCall operation ARGUMENT =
		CCBSStopAlerting operation ARGUMENT =
		CCBSReference */

#define NS_CCBS_DEACTIVATE_ARG_P		NS_SS_CCBS_REFERENCE_P
#define NS_CCBS_CALL_ARG_P				NS_SS_CCBS_REFERENCE_P
#define NS_CCBS_STOP_ALERT_ARG_P		NS_SS_CCBS_REFERENCE_P

	/*	CCBSStatusRequest operation RESULT = BOOLEAN */

#define NS_CCBS_STAT_RQ_RES_P			NS_SS_BOOLEAN_P

	/* CCBSBFree operation ARGUMENT = CCBSRemoteUserFree operation ARGUMENT */

#define NS_CCBS_BFREE_ARG_P				NS_CCBS_REMOTE_FREE_ARG_P

	/* CCBS-T-Request operation RESULT = BOOLEAN */

#define NS_CCBS_T_RQ_RES_P				NS_SS_BOOLEAN_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* CallInfoRetain and EraseCallLinkageID operations */

uchar ns_ssdu_op_ccbs_info_eras_lk (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		switch (I_ss_fac_op_err_id) {		/* store ARGUMENT according to operation ID */

			case NS_OP_CCBS_CALL_INFO_RETAIN :		/* CallInfoRetain */

				ns_op_ccbs_call_info_lk_id = Ns_ccbs_call_inf_erase_lk_id;
				break;

			case NS_OP_CCBS_ERASE_CALL_LK_ID :		/* EraseCallLinkageID */

				ns_op_ccbs_erase_call_lk_id = Ns_ccbs_call_inf_erase_lk_id;
				break;
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		switch (I_ss_fac_op_err_id) {		/* store ARGUMENT according to operation ID */

			case NS_OP_CCBS_CALL_INFO_RETAIN :		/* CallInfoRetain */

				Ns_ccbs_call_inf_erase_lk_id = ns_op_ccbs_call_info_lk_id;
				break;

			case NS_OP_CCBS_ERASE_CALL_LK_ID :		/* EraseCallLinkageID */

				Ns_ccbs_call_inf_erase_lk_id = ns_op_ccbs_erase_call_lk_id;
				break;
		}

		p_ssdu_val += Rnd_sizeof (struct ns_ccbs_call_inf_eras_lk_arg);
	}

	return (OK);
}

		/* CCBSDeactivate, CCBSCall and CCBSStopAlerting operations */

uchar ns_ssdu_op_ccbs_dea_call_stop (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		switch (I_ss_fac_op_err_id) {		/* store ARGUMENT according to operation ID */

			case NS_OP_CCBS_DEACTIVATE :		/* CCBSDeactivate */

				ns_op_ccbs_deactivate_ref = Ns_ccbs_dea_call_stop_al_ref;
				break;

			case NS_OP_CCBS_CALL :		/* CCBSCall */

				ns_op_ccbs_call_ref = Ns_ccbs_dea_call_stop_al_ref;
				break;

			case NS_OP_CCBS_STOP_ALERTING :		/* CCBSStopAlerting */

				ns_op_ccbs_stop_alert_ref = Ns_ccbs_dea_call_stop_al_ref;
				break;
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		switch (I_ss_fac_op_err_id) {		/* store ARGUMENT according to operation ID */

			case NS_OP_CCBS_DEACTIVATE :		/* CCBSDeactivate */

				Ns_ccbs_dea_call_stop_al_ref = ns_op_ccbs_deactivate_ref;
				break;

			case NS_OP_CCBS_CALL :		/* CCBSCall */

				Ns_ccbs_dea_call_stop_al_ref = ns_op_ccbs_call_ref;
				break;

			case NS_OP_CCBS_STOP_ALERTING :		/* CCBSStopAlerting */

				Ns_ccbs_dea_call_stop_al_ref = ns_op_ccbs_stop_alert_ref;
				break;
		}

		p_ssdu_val += Rnd_sizeof (struct ns_ccbs_dea_call_stop_al_arg);
	}

	return (OK);
}

		/* CCBSRequest operation */

uchar ns_ssdu_op_ccbs_request (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_op_ccbs_request_lk_id = Ns_ccbs_rq_arg_lk_id;
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		ns_op_ccbs_request_res.recall_mode = Ns_ccbs_rq_res_recall_m;
		ns_op_ccbs_request_res.reference = Ns_ccbs_rq_res_ref;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_ccbs_rq_arg_lk_id = ns_op_ccbs_request_lk_id;
			p_ssdu_val += Rnd_sizeof (struct ns_ccbs_request_arg);
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_ccbs_rq_res_recall_m = ns_op_ccbs_request_res.recall_mode;
		Ns_ccbs_rq_res_ref = ns_op_ccbs_request_res.reference;
		p_ssdu_val += Rnd_sizeof (struct ns_ccbs_request_res);
	}

	return (OK);
}

		/* CCBSStatusRequest operation */

uchar ns_ssdu_op_ccbs_stat_rq (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_op_ccbs_status_rq_arg.recall_mode = Ns_ccbs_stat_rq_recall_m;
			ns_op_ccbs_status_rq_arg.reference = Ns_ccbs_stat_rq_ref;

			ns_op_ccbs_status_rq_arg.q931_ie.size = size = Ns_ccbs_stat_rq_ie_sz;
			ns_op_ccbs_status_rq_arg.q931_ie.p_string = p_ind_buffer;
				/* Q931 IE string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_ccbs_stat_rq_first_ie), size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		ns_op_ccbs_status_rq_res = Ns_ccbs_stat_rq_res_free;

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_ccbs_stat_rq_recall_m = ns_op_ccbs_status_rq_arg.recall_mode;
			Ns_ccbs_stat_rq_ref = ns_op_ccbs_status_rq_arg.reference;

            p_next = &(Ns_ccbs_stat_rq_first_ie);
			Ns_ccbs_stat_rq_ie_sz = size = ns_op_ccbs_status_rq_arg.q931_ie.size;
				/* Q931 IE string : at the end of the structure */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_status_rq_arg.q931_ie.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
			p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_ccbs_stat_rq_res_free = ns_op_ccbs_status_rq_res;
		p_ssdu_val += Rnd_sizeof (struct ns_ccbs_status_rq_res);
	}

	return (OK);
}

		/* CCBSRemoteUserFree and CCBSBFree operations */

uchar ns_ssdu_op_ccbs_free (p_start, offset)
	uchar FAR								*p_start;		/* pointer to start of component */
	ushort									offset;	 		/* offset of data in received SSDU */
{
	uchar FAR								*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar									size;			/* current size */
	struct ns_op_ccbs_remote_free_arg FAR	*p_i_data;		/* pointer to internal data */

		/* set pointer to internal data according to operation */

	if (I_ss_fac_op_err_id == NS_OP_CCBS_REMOTE_U_FREE) {

		p_i_data = &ns_op_ccbs_remote_free_arg;

	} else {

		p_i_data = &ns_op_ccbs_bfree_arg;
	}

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_ccbs_free_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		p_i_data -> recall_mode = Ns_ccbs_free_recall_m;
		p_i_data -> reference = Ns_ccbs_free_ref;
		p_i_data -> party_nb_type = Ns_ccbs_free_party_nb_t;
		p_i_data -> type_of_nb = Ns_ccbs_free_type_of_nb;
		p_i_data -> number_digits.size = size = Ns_ccbs_free_nb_sz;
		p_i_data -> number_digits.p_string = p_ind_buffer;

			/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_ccbs_free_first_nb);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_ccbs_free_sa_type != 255) {	/* subaddress is present */

			if (Ns_ccbs_free_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			p_i_data -> sub_add_type = Ns_ccbs_free_sa_type;
			p_i_data -> sub_add_odd_c = (Ns_ccbs_free_sa_odd_c == 255) ? 254 : Ns_ccbs_free_sa_odd_c;
			p_i_data -> sub_address.size = size = Ns_ccbs_free_sa_sz;
			p_i_data -> sub_address.p_string = p_ind_buffer;

				/* PartySubaddress string : at the end of the structure, after PartyNumber string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

			p_i_data -> sub_add_type = 254;
			p_i_data -> sub_address.size = 254;
			p_i_data -> sub_address.p_string = P_NIL;
		}

		p_i_data -> q931_ie.size = size = Ns_ccbs_free_ie_sz;
		p_i_data -> q931_ie.p_string = p_ind_buffer;
			/* Q931 IE string : at the end of the structure, after PartyNumber and PartySubaddress strings -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_ccbs_free_recall_m = p_i_data -> recall_mode;
		Ns_ccbs_free_ref = p_i_data -> reference;
		Ns_ccbs_free_party_nb_t = p_i_data -> party_nb_type;
		Ns_ccbs_free_type_of_nb = p_i_data -> type_of_nb;
		Ns_ccbs_free_sa_type = p_i_data -> sub_add_type;
		Ns_ccbs_free_sa_odd_c = p_i_data -> sub_add_odd_c;

			/* PartyNumber string : at the end of the structure */
		p_next = &(Ns_ccbs_free_first_nb);
		Ns_ccbs_free_nb_sz = size = p_i_data -> number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_i_data -> number_digits.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */

			/* PartySubaddress string : at the end of the structure, after PartyNumber string */
		Ns_ccbs_free_sa_sz = size = p_i_data -> sub_address.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_i_data -> sub_address.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */

			/* Q931 IE string : at the end of the structure, after PartyNumber and PartySubaddress strings */
		Ns_ccbs_free_ie_sz = size = p_i_data -> q931_ie.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_i_data -> q931_ie.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CCBSErase operation */

uchar ns_ssdu_op_ccbs_erase (p_start, offset)
	uchar FAR				*p_start;			/* pointer to start of component */
	ushort					offset;				/* offset of data in received SSDU */
{
	uchar FAR				*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar					size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_ccbs_erase_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_ccbs_erase_arg.recall_mode = Ns_ccbs_erase_recall_m;
		ns_op_ccbs_erase_arg.reference = Ns_ccbs_erase_ref;
		ns_op_ccbs_erase_arg.reason = Ns_ccbs_erase_reason;
		ns_op_ccbs_erase_arg.party_nb_type = Ns_ccbs_erase_party_nb_t;
		ns_op_ccbs_erase_arg.type_of_nb = Ns_ccbs_erase_type_of_nb;
		ns_op_ccbs_erase_arg.number_digits.size = size = Ns_ccbs_erase_nb_sz;
		ns_op_ccbs_erase_arg.number_digits.p_string = p_ind_buffer;

			/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_ccbs_erase_first_nb);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_ccbs_erase_sa_type != 255) {	/* subaddress is present */

			if (Ns_ccbs_erase_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_ccbs_erase_arg.sub_add_type = Ns_ccbs_erase_sa_type;
			ns_op_ccbs_erase_arg.sub_add_odd_c = (Ns_ccbs_erase_sa_odd_c == 255) ? 254 : Ns_ccbs_erase_sa_odd_c;
			ns_op_ccbs_erase_arg.sub_address.size = size = Ns_ccbs_erase_sa_sz;
			ns_op_ccbs_erase_arg.sub_address.p_string = p_ind_buffer;

				/* PartySubaddress string : at the end of the structure, after PartyNumber string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

			ns_op_ccbs_erase_arg.sub_add_type = 254;
			ns_op_ccbs_erase_arg.sub_address.size = 254;
			ns_op_ccbs_erase_arg.sub_address.p_string = P_NIL;
		}

		ns_op_ccbs_erase_arg.q931_ie.size = size = Ns_ccbs_erase_ie_sz;
		ns_op_ccbs_erase_arg.q931_ie.p_string = p_ind_buffer;
			/* Q931 IE string : at the end of the structure, after PartyNumber and PartySubaddress strings -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_ccbs_erase_recall_m = ns_op_ccbs_erase_arg.recall_mode;
		Ns_ccbs_erase_ref = ns_op_ccbs_erase_arg.reference;
		Ns_ccbs_erase_reason = ns_op_ccbs_erase_arg.reason;
		Ns_ccbs_erase_party_nb_t = ns_op_ccbs_erase_arg.party_nb_type;
		Ns_ccbs_erase_type_of_nb = ns_op_ccbs_erase_arg.type_of_nb;
		Ns_ccbs_erase_sa_type = ns_op_ccbs_erase_arg.sub_add_type;
		Ns_ccbs_erase_sa_odd_c = ns_op_ccbs_erase_arg.sub_add_odd_c;

			/* PartyNumber string : at the end of the structure */
		p_next = &(Ns_ccbs_erase_first_nb);
		Ns_ccbs_erase_nb_sz = size = ns_op_ccbs_erase_arg.number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)(ns_op_ccbs_erase_arg.number_digits.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */

			/* PartySubaddress string : at the end of the structure, after PartyNumber string */
		Ns_ccbs_erase_sa_sz = size = ns_op_ccbs_erase_arg.sub_address.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)(ns_op_ccbs_erase_arg.sub_address.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */

			/* Q931 IE string : at the end of the structure, after PartyNumber and PartySubaddress strings */
		Ns_ccbs_erase_ie_sz = size = ns_op_ccbs_erase_arg.q931_ie.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)(ns_op_ccbs_erase_arg.q931_ie.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

	/* CCBSInterrogate operation */

uchar ns_ssdu_op_ccbs_interog (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* current size */
	uchar				index;				/* current index */
	uchar				type_of_nb_x;		/* current index for TypeOfNumber inside PartyNumber */
	uchar				sub_add_x;			/* current index for PartySubaddress */
	uchar				odd_count_x;		/* current index for OddCountIndicator inside PartySubaddress */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be (no clause is empty) */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			ns_op_ccbs_interog_arg.reference = (Ns_ccbs_interog_ref == 255) ? 254 : Ns_ccbs_interog_ref;

			if (Ns_ccbs_interog_party_nb_t != 255) {	/* partyNumberOfA is present */

				if (Ns_ccbs_interog_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_ccbs_interog_arg.party_nb_type = Ns_ccbs_interog_party_nb_t;
				ns_op_ccbs_interog_arg.type_of_nb = Ns_ccbs_interog_type_of_nb;
				ns_op_ccbs_interog_arg.number_digits.size = size = Ns_ccbs_interog_nb_sz;
				ns_op_ccbs_interog_arg.number_digits.p_string = p_ind_buffer;
					/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
				p_next = &(Ns_ccbs_interog_first_nb);
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */

			} else {	/* no partyNumberOfA -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

				ns_op_ccbs_interog_arg.party_nb_type = 254;
				ns_op_ccbs_interog_arg.number_digits.size = 254;
				ns_op_ccbs_interog_arg.number_digits.p_string = P_NIL;
			}

			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		odd_count_x = sub_add_x = type_of_nb_x = index = 0;		/* initialize current indexes */
		ns_op_ccbs_interog_res.call_info_nb = 0;				/* init number of CallInformation */
		offset = Ns_ccbs_interog_first_info;

		ns_op_ccbs_interog_res.recall_mode = Ns_ccbs_interog_recall_m;

		while (offset != OFFSET_NIL) {	/* loop on instances of CallInformation */

			if (ns_op_ccbs_interog_res.call_info_nb >= NS_CCBS_MX_CALL_INFO) {

				return (NOK);	/* too many CallInformation instances */
			}

			p_next = p_start + offset;		/* get content of current CallInformation */

			if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

				return (NOK);	/* component data is after end of SSDU or before start of component ! */
			}

			p_ssdu_val = p_next;		/* update SSDU pointer to analyse CallInformation content */

			if (Ns_ccbs_call_info_B_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_ccbs_interog_res.reference[index] = Ns_ccbs_call_info_ref;
			p_next = &(Ns_ccbs_call_info_first_nb);

				/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

			if ((Ns_ccbs_call_info_B_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
				(Ns_ccbs_call_info_B_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

				ns_op_ccbs_interog_res.type_of_nb[type_of_nb_x++] = Ns_ccbs_call_info_B_t_of_nb;
			}

			ns_op_ccbs_interog_res.party_nb_type[index] = Ns_ccbs_call_info_B_p_nb_t;

				/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
			ns_op_ccbs_interog_res.number_digits[index].size = size = Ns_ccbs_call_info_B_nb_sz;
			ns_op_ccbs_interog_res.number_digits[index].p_string = p_ind_buffer;
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

			if (Ns_ccbs_call_info_B_sa_t != 255) {	/* subaddress is present */

				if (Ns_ccbs_call_info_B_sa_t > NS_SS_MX_PARTY_SA_TYPE) {

					return (NOK);	/* bad type of PartySubaddress */
				}

				if (Ns_ccbs_call_info_B_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

					ns_op_ccbs_interog_res.sub_add_odd_c[odd_count_x++] = (Ns_ccbs_call_info_B_sa_odd_c == 255) ? 254 : Ns_ccbs_call_info_B_sa_odd_c;
				}

				ns_op_ccbs_interog_res.sub_add_type[sub_add_x] = Ns_ccbs_call_info_B_sa_t;

					/* PartySubaddress string : at the end of the structure, after PartyNumber string -> copy it into indirect buffer */
				ns_op_ccbs_interog_res.sub_address[sub_add_x].size = size = Ns_ccbs_call_info_B_sa_sz;
				ns_op_ccbs_interog_res.sub_address[sub_add_x++].p_string = p_ind_buffer;
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

			} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

				ns_op_ccbs_interog_res.sub_add_type[sub_add_x++] = 254;
			}

				/* Q931 IE string : after PartyNumber and PartySubaddress strings -> copy it into indirect buffer */
			ns_op_ccbs_interog_res.q931_ie[index].size = size = Ns_ccbs_call_info_ie_sz;
			ns_op_ccbs_interog_res.q931_ie[index].p_string = p_ind_buffer;
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

			if (Ns_ccbs_call_info_A_sa_t != 255) {	/* subaddress is present */

				if (Ns_ccbs_call_info_A_sa_t > NS_SS_MX_PARTY_SA_TYPE) {

					return (NOK);	/* bad type of PartySubaddress */
				}

				if (Ns_ccbs_call_info_A_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

					ns_op_ccbs_interog_res.sub_add_odd_c[odd_count_x++] = (Ns_ccbs_call_info_A_sa_odd_c == 255) ? 254 : Ns_ccbs_call_info_A_sa_odd_c;
				}

				ns_op_ccbs_interog_res.sub_add_type[sub_add_x] = Ns_ccbs_call_info_A_sa_t;

					/* PartySubaddress string : after Q931 IE string -> copy it into indirect buffer */
				ns_op_ccbs_interog_res.sub_address[sub_add_x].size = size = Ns_ccbs_call_info_A_sa_sz;
				ns_op_ccbs_interog_res.sub_address[sub_add_x++].p_string = p_ind_buffer;
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

			} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

				ns_op_ccbs_interog_res.sub_add_type[sub_add_x++] = 254;
			}

			offset = Ns_ccbs_next_call_info;				/* get content of next CallInformation */
			ns_op_ccbs_interog_res.call_info_nb++;			/* increment number of CallInformation */
			index++;										/* get next CallInformation internal data */

		} /* end of loop on CallInformation instances */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			Ns_ccbs_interog_ref = ns_op_ccbs_interog_arg.reference;

			Ns_ccbs_interog_party_nb_t = ns_op_ccbs_interog_arg.party_nb_type;
			Ns_ccbs_interog_type_of_nb = ns_op_ccbs_interog_arg.type_of_nb;

				/* PartyNumber string : at the end of the structure */
			p_next = &(Ns_ccbs_interog_first_nb);
			Ns_ccbs_interog_nb_sz = size = ns_op_ccbs_interog_arg.number_digits.size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)(ns_op_ccbs_interog_arg.number_digits.p_string), size);
			p_next += size;				/* update pointer to current string inside SSDU */
			p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_ccbs_interog_recall_m = ns_op_ccbs_interog_res.recall_mode;
		offset = (ushort)(ns_op_ccbs_interog_res.call_info_nb);			/* use 'offset' as counter of number of instances */
		p_next = p_ssdu_val + Rnd_sizeof (struct ns_ccbs_interog_res);	/* update pointer to location of first CallInformation instance */

		if (offset == 0) {

			Ns_ccbs_interog_first_info = OFFSET_NIL;

		} else {

			Ns_ccbs_interog_first_info = (ushort)(p_next - p_start);
		}

		p_ssdu_val = p_next;	/* update current SSDU value pointer */

		odd_count_x = sub_add_x = type_of_nb_x = index = 0;		/* initialize current indexes */

		while (offset-- > 0) {	/* loop on CallInformation instances */

			p_next = &(Ns_ccbs_call_info_first_nb);		/* set current pointer to first string octet */
			Ns_ccbs_call_info_ref = ns_op_ccbs_interog_res.reference[index];
			Ns_ccbs_call_info_B_p_nb_t = ns_op_ccbs_interog_res.party_nb_type[index];

				/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

			if ((Ns_ccbs_call_info_B_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
				(Ns_ccbs_call_info_B_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

				Ns_ccbs_call_info_B_t_of_nb = ns_op_ccbs_interog_res.type_of_nb[type_of_nb_x++];
			}

				/* PartyNumber string : at the end of the structure */
			Ns_ccbs_call_info_B_nb_sz = size = ns_op_ccbs_interog_res.number_digits[index].size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_interog_res.number_digits[index].p_string, size);
			p_next += size;

			Ns_ccbs_call_info_B_sa_t = ns_op_ccbs_interog_res.sub_add_type[index * 2];
			if (Ns_ccbs_call_info_B_sa_t != 255) {	/* subaddress is present */

				if (Ns_ccbs_call_info_B_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

					Ns_ccbs_call_info_B_sa_odd_c = ns_op_ccbs_interog_res.sub_add_odd_c[odd_count_x++];
				}

					/* PartySubaddress string : at the end of the structure, after PartyNumber string */
				Ns_ccbs_call_info_B_sa_sz = size = ns_op_ccbs_interog_res.sub_address[sub_add_x].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_interog_res.sub_address[sub_add_x].p_string, size);
				p_next += size;
				sub_add_x++;

			} else {	/* no subaddress */

				Ns_ccbs_call_info_B_sa_sz = 0;
			}

				/* Q931 IE string : after PartyNumber and PartySubaddress strings */
			Ns_ccbs_call_info_ie_sz = size = ns_op_ccbs_interog_res.q931_ie[index].size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_interog_res.q931_ie[index].p_string, size);
			p_next += size;

			Ns_ccbs_call_info_A_sa_t = ns_op_ccbs_interog_res.sub_add_type[(index * 2) + 1];
			if (Ns_ccbs_call_info_A_sa_t != 255) {	/* subaddress is present */

				if (Ns_ccbs_call_info_A_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

					Ns_ccbs_call_info_A_sa_odd_c = ns_op_ccbs_interog_res.sub_add_odd_c[odd_count_x++];
				}

					/* PartySubaddress string : at the end of the structure, after Q931 IE string */
				Ns_ccbs_call_info_A_sa_sz = size = ns_op_ccbs_interog_res.sub_address[sub_add_x].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_interog_res.sub_address[sub_add_x].p_string, size);
				p_next += size;
				sub_add_x++;

			} else {	/* no subaddress */

				Ns_ccbs_call_info_A_sa_sz = 0;
			}

			p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */

			if (offset == 0) {

				Ns_ccbs_next_call_info = OFFSET_NIL;

			} else {

				Ns_ccbs_next_call_info = (ushort)(p_next - p_start);
			}

			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			index++;			/* get next CallInformation internal structure */

		} /* end of loop on CallInformation instances */
	}

	return (OK);
}

	/* CCBS-T-Request operation */

uchar ns_ssdu_op_ccbs_t_rq (p_start, offset)
	uchar FAR				*p_start;			/* pointer to start of component */
	ushort					offset;				/* offset of data in received SSDU */
{
	uchar FAR				*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar					size;				/* current size */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> RESULT clause may be empty */

				return (OK);	/* no data */
			}

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			ns_op_ccbs_t_rq_retention = Ns_ccbs_t_rq_res_retention;
			return (OK);
		}

			/* Invoke component -> process ARGUMENT clause */

		ns_op_ccbs_t_rq_arg.retention = (Ns_ccbs_t_rq_retention == 255) ? 254 : Ns_ccbs_t_rq_retention;
		ns_op_ccbs_t_rq_arg.pres_allow = (Ns_ccbs_t_rq_pres_allow == 255) ? 254 : Ns_ccbs_t_rq_pres_allow;

		if (Ns_ccbs_t_rq_dest_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

			/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

		if ((Ns_ccbs_t_rq_dest_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
			(Ns_ccbs_t_rq_dest_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_ccbs_t_rq_arg.dest_t_of_nb = Ns_ccbs_t_rq_dest_t_of_nb;
		}

		ns_op_ccbs_t_rq_arg.dest_party_nb_t = Ns_ccbs_t_rq_dest_p_nb_t;
		ns_op_ccbs_t_rq_arg.dest_nb_digits.size = size = Ns_ccbs_t_rq_dest_nb_sz;
		ns_op_ccbs_t_rq_arg.dest_nb_digits.p_string = p_ind_buffer;
			/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_ccbs_t_rq_first_nb);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_ccbs_t_rq_dest_sa_t != 255) {	/* subaddress is present */

			if (Ns_ccbs_t_rq_dest_sa_t > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_ccbs_t_rq_arg.dest_sa_type = Ns_ccbs_t_rq_dest_sa_t;

			if (Ns_ccbs_t_rq_dest_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

				ns_op_ccbs_t_rq_arg.dest_sa_odd_c = (Ns_ccbs_t_rq_dest_sa_odd_c == 255) ? 254 : Ns_ccbs_t_rq_dest_sa_odd_c;
			}

			ns_op_ccbs_t_rq_arg.dest_sub_add.size = size = Ns_ccbs_t_rq_dest_sa_sz;
			ns_op_ccbs_t_rq_arg.dest_sub_add.p_string = p_ind_buffer;
				/* PartySubaddress string : at the end of the structure, after PartyNumber string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* no subaddress -> set internal value so that types are marked 'ABSENT' in array of optional indicators */

			ns_op_ccbs_t_rq_arg.dest_sa_type = 254;
		}

		ns_op_ccbs_t_rq_arg.q931_ie.size = size = Ns_ccbs_t_rq_q931_ie_sz;
		ns_op_ccbs_t_rq_arg.q931_ie.p_string = p_ind_buffer;
			/* Q931 IE string : after PartyNumber and PartySubaddress strings */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_ccbs_t_rq_orig_p_nb_t == 255) {	/* no originatingAddress */

			ns_op_ccbs_t_rq_arg.orig_party_nb_t = 254;
			return (OK);
		}

		if (Ns_ccbs_t_rq_orig_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_ccbs_t_rq_arg.orig_party_nb_t = Ns_ccbs_t_rq_orig_p_nb_t;
		ns_op_ccbs_t_rq_arg.orig_t_of_nb = (Ns_ccbs_t_rq_orig_t_of_nb == 255) ? 254 : Ns_ccbs_t_rq_orig_t_of_nb;
		ns_op_ccbs_t_rq_arg.orig_nb_digits.size = size = Ns_ccbs_t_rq_orig_nb_sz;
		ns_op_ccbs_t_rq_arg.orig_nb_digits.p_string = p_ind_buffer;
			/* originating number string : after Q931 IE, PartyNumber and PartySubaddress strings */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_ccbs_t_rq_orig_sa_t != 255) {	/* subaddress is present */

			if (Ns_ccbs_t_rq_orig_sa_t > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_ccbs_t_rq_arg.orig_sa_type = Ns_ccbs_t_rq_orig_sa_t;

			if (Ns_ccbs_t_rq_orig_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

				ns_op_ccbs_t_rq_arg.orig_sa_odd_c = (Ns_ccbs_t_rq_orig_sa_odd_c == 255) ? 254 : Ns_ccbs_t_rq_orig_sa_odd_c;
			}

			ns_op_ccbs_t_rq_arg.orig_sub_add.size = size = Ns_ccbs_t_rq_orig_sa_sz;
			ns_op_ccbs_t_rq_arg.orig_sub_add.p_string = p_ind_buffer;
				/* originating subaddress string : after originating number string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */

		} else {	/* no subaddress -> set internal value so that types are marked 'ABSENT' in array of optional indicators */

			ns_op_ccbs_t_rq_arg.orig_sa_type = 254;
		}

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			Ns_ccbs_t_rq_res_retention = ns_op_ccbs_t_rq_retention;
			p_ssdu_val += Rnd_sizeof (struct ns_ccbs_t_rq_res);
			return (OK);
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_ccbs_t_rq_retention = ns_op_ccbs_t_rq_arg.retention;
		Ns_ccbs_t_rq_pres_allow = ns_op_ccbs_t_rq_arg.pres_allow;
		Ns_ccbs_t_rq_dest_p_nb_t = ns_op_ccbs_t_rq_arg.dest_party_nb_t;

			/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

		if ((Ns_ccbs_t_rq_dest_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
			(Ns_ccbs_t_rq_dest_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

			Ns_ccbs_t_rq_dest_t_of_nb = ns_op_ccbs_t_rq_arg.dest_t_of_nb;
			Ns_ccbs_t_rq_orig_t_of_nb = ns_op_ccbs_t_rq_arg.orig_t_of_nb;

		} else {	/* In this case, first 'Type of Number' stored (for 'destination') is in fact the second one (for 'originating') */

			Ns_ccbs_t_rq_orig_t_of_nb = ns_op_ccbs_t_rq_arg.dest_t_of_nb;
		}

		Ns_ccbs_t_rq_dest_nb_sz = size = ns_op_ccbs_t_rq_arg.dest_nb_digits.size;
			/* PartyNumber string : at the end of the structure */
		p_next = &(Ns_ccbs_t_rq_first_nb);
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_t_rq_arg.dest_nb_digits.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_ccbs_t_rq_dest_sa_t = ns_op_ccbs_t_rq_arg.dest_sa_type;
		if (Ns_ccbs_t_rq_dest_sa_t != 255) {	/* subaddress is present */

			if (Ns_ccbs_t_rq_dest_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

				Ns_ccbs_t_rq_dest_sa_odd_c = ns_op_ccbs_t_rq_arg.dest_sa_odd_c;

			} else {	/* In this case, first 'oddCountIndicator' stored (for 'destination') is in fact the second one (for 'originating') */

				ns_op_ccbs_t_rq_arg.orig_sa_odd_c = ns_op_ccbs_t_rq_arg.dest_sa_odd_c;
			}

			Ns_ccbs_t_rq_dest_sa_sz = size = ns_op_ccbs_t_rq_arg.dest_sub_add.size;
				/* PartySubaddress string : at the end of the structure, after PartyNumber string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_t_rq_arg.dest_sub_add.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* no subaddress : 'destination' fields stored are in fact the ones for 'originating' */

			Ns_ccbs_t_rq_dest_sa_sz = 0;
			ns_op_ccbs_t_rq_arg.orig_sa_odd_c = ns_op_ccbs_t_rq_arg.dest_sa_odd_c;
			ns_op_ccbs_t_rq_arg.orig_sub_add.size = ns_op_ccbs_t_rq_arg.dest_sub_add.size;
			ns_op_ccbs_t_rq_arg.orig_sub_add.p_string = ns_op_ccbs_t_rq_arg.dest_sub_add.p_string;
		}

		Ns_ccbs_t_rq_q931_ie_sz = size = ns_op_ccbs_t_rq_arg.q931_ie.size;
			/* Q931 IE string : after PartyNumber and PartySubaddress strings */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_t_rq_arg.q931_ie.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_ccbs_t_rq_orig_p_nb_t = ns_op_ccbs_t_rq_arg.orig_party_nb_t;
		if (Ns_ccbs_t_rq_orig_p_nb_t == 255) {	/* no originatingAddress */

			Ns_ccbs_t_rq_orig_nb_sz = 0;
			Ns_ccbs_t_rq_orig_sa_sz = 0;

		} else {

			Ns_ccbs_t_rq_orig_nb_sz = size = ns_op_ccbs_t_rq_arg.orig_nb_digits.size;
				/* originating number string : after Q931 IE, PartyNumber and PartySubaddress strings */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_t_rq_arg.orig_nb_digits.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */

			Ns_ccbs_t_rq_orig_sa_t = ns_op_ccbs_t_rq_arg.orig_sa_type;
			if (Ns_ccbs_t_rq_orig_sa_t == 255) {	/* no subaddress */

				Ns_ccbs_t_rq_orig_sa_sz = 0;

			} else {

				Ns_ccbs_t_rq_orig_sa_odd_c = ns_op_ccbs_t_rq_arg.orig_sa_odd_c;
				Ns_ccbs_t_rq_orig_sa_sz = size = ns_op_ccbs_t_rq_arg.orig_sub_add.size;
					/* originating subaddress string : after originating number string */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_ccbs_t_rq_arg.orig_sub_add.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */
			}
		}

		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif	/* end of "NS_USE_EUROPE_OPERATION == ON} */

#endif	/* end of "Completion of Calls to Busy Subscriber supported"} */

/*==========================================================================*/

		/* operations specific to supplementary Service interactions
		 * --------------------------------------------------------- */

#if NS_SS_INTERACTIONS == ON	/* Supplementary service interactions{ */

			/* operation values (used in Facility IE inside SPDUs) */

#define NS_OP_VAL_INTERACT_ID_CHARG			37		/* IdentificationOfCharge : interaction between AOC and (Diversion (CFB/CFU/CFNR/CD) or ECT) SS */
#define NS_OP_VAL_INTERACT_ID_CONF			49		/* IdentifyConferee : interaction between CONF and (TP or HOLD or UUS or ECT) SS */
#define NS_OP_VAL_INTERACT_UUS_RQ			66		/* UUSRequest : interaction between UUS and Diversion (CFB/CFU/CFNR/CD) SS */

#endif	/* end of Supplementary service interactions} */

/*==========================================================================

			- EUROPE specific Table describing the OBJECT IDENTIFIER tree :
		it contains all the nodes in the tree, all the "son" nodes of a given
		node are contiguous in the table. For example, if a node A has 3 son
		nodes S1, S2 and S3, an entry in the table describing A shall be
			{A_index, A_UPPER_index, label, 3, S1_index} and there shall be
			at place in table indicated by S_index, 3 consecutive entries :
			{S1_index, A_index, label1, .., ..}
			{S2_index, A_index, label2, .., ..}
			{S3_index, A_index, label3, .., ..}
*/

	/* OBJECT IDENTIFIERs are only used for Explicit Call Transfer, Freephone and CCBS SS */

#if (NS_SS_ECT == ON) || (NS_SS_FREEPHONE == ON) || (NS_SS_CCBS == ON)

	/*	following nodes are described :

			eCTOID ::= {ccitt identified-organization etsi(0) 369 operations-and-errors(1)}
			fPHOID ::= {ccitt identified-organization etsi(0) 210 operations-and-errors(1)}
			cCBSOID ::= {ccitt identified-organization etsi(0) 359 operations-and-errors(1)}
			cCBS-T-OID ::= {ccitt identified-organization etsi(0) 359 private-networks-operations-and-errors(2)}

			explicitEctExecute ::= {eCTOID explicitEctExecute-operation(1)}
			requestSubaddress ::= {eCTOID requestSubaddress-operation(2)}
			subaddressTransfer ::= {eCTOID subaddressTransfer-operation(3)}
			ectLinkIdRequest ::= {eCTOID ectLinkIdRequest-operation(4)}
			ectInform ::= {eCTOID ectInform-operation(5)}
			ectLoopTest ::= {eCTOID ectLoopTest-operation(6)}
			linkIdNotAssignedByNetwork ::= {eCTOID linkIdNotAssignedByNetwork-error(21)}

			callFPH ::= {fPHOID callFPH-operation(1)}
			monitor-T-FPH ::= {fPHOID monitor-T-FPH-operation(2)}
			free-T-FPH ::= {fPHOID free-T-FPH-operation(3)}
			call-T-FPH ::= {fPHOID call-T-FPH-operation(4)}

			callInfoRetain ::= {cCBSOID 1}
			cCBSRequest ::= {cCBSOID 2}
			cCBSDeactivate ::= {cCBSOID 3}
			cCBSInterrogate ::= {cCBSOID 4}
			cCBSErase ::= {cCBSOID 5}
			cCBSRemoteUserFree ::= {cCBSOID 6}
			cCBSCall ::= {cCBSOID 7}
			cCBSStatusRequest ::= {cCBSOID 8}
			cCBSBFree ::= {cCBSOID 9}
			eraseCallLinkageID ::= {cCBSOID 10}
			cCBSStopAlerting ::= {cCBSOID 11}
			invalidCallLinkageID ::= {cCBSOID 20}
			invalidCCBSReference ::= {cCBSOID 21}
			longTermDenial ::= {cCBSOID 22}
			shortTermDenial ::= {cCBSOID 23}
			cCBSIsAlreadyActivated ::= {cCBSOID 24}
			alreadyAccepted ::= {cCBSOID 25}
			outgoingCCBSQueuefull ::= {cCBSOID 26}
			callFailureReasonNotBusy ::= {cCBSOID 27}
			notReadyForCall ::= {cCBSOID 28}

			cCBS-T-Request ::= {cCBS-T-OID 1}
			cCBS-T-Call ::= {cCBS-T-OID 2}
			cCBS-T-Suspend ::= {cCBS-T-OID 3}
			cCBS-T-Resume ::= {cCBS-T-OID 4}
			cCBS-T-RemoteUserFree ::= {cCBS-T-OID 5}
			cCBS-T-Available ::= {cCBS-T-OID 6}
			longTermDenial ::= {cCBS-T-OID 20}
			shortTermDenial ::= {cCBS-T-OID 21}
	*/

#define NS_OBJ_ID_CCITT					1
#define NS_OBJ_ID_IDENTIFIED_ORG		2
#define NS_OBJ_ID_ETSI					3
#define NS_OBJ_ID_ETS_300_369			4
#define NS_OBJ_ID_ETS_300_210			5
#define NS_OBJ_ID_ETS_300_359			6
#define NS_OBJ_ID_ECT_OID				7

#define NS_OP_VAL_ECT_EXP_EXEC			(NS_OBJ_ID_ECT_OID + 1)
#define NS_OP_VAL_ECT_RQ_SUBADD			(NS_OBJ_ID_ECT_OID + 2)
#define NS_OP_VAL_ECT_SUBADD_TRF        (NS_OBJ_ID_ECT_OID + 3)
#define NS_OP_VAL_ECT_LK_ID_RQ          (NS_OBJ_ID_ECT_OID + 4)
#define NS_OP_VAL_ECT_INFORM            (NS_OBJ_ID_ECT_OID + 5)
#define NS_OP_VAL_ECT_LOOP_TEST         (NS_OBJ_ID_ECT_OID + 6)
#define NS_ERR_VAL_ECT_LK_ID_NOT_ASS    (NS_OBJ_ID_ECT_OID + 7)

#define NS_OBJ_ID_FPH_OID				15

#define NS_OP_VAL_FPH_CALL				(NS_OBJ_ID_FPH_OID + 1)
#define NS_OP_VAL_FPH_MONITOR_T         (NS_OBJ_ID_FPH_OID + 2)
#define NS_OP_VAL_FPH_FREE_T			(NS_OBJ_ID_FPH_OID + 3)
#define NS_OP_VAL_FPH_CALL_T            (NS_OBJ_ID_FPH_OID + 4)

#define NS_OBJ_ID_CCBS_OID				20
#define NS_OBJ_ID_CCBS_T_OID			21

#define NS_OP_VAL_CCBS_CALL_INFO_RET	(NS_OBJ_ID_CCBS_OID + 2)
#define NS_OP_VAL_CCBS_RQ				(NS_OBJ_ID_CCBS_OID + 3)
#define NS_OP_VAL_CCBS_DEACTIVATE		(NS_OBJ_ID_CCBS_OID + 4)
#define NS_OP_VAL_CCBS_INTERROGATE		(NS_OBJ_ID_CCBS_OID + 5)
#define NS_OP_VAL_CCBS_ERASE			(NS_OBJ_ID_CCBS_OID + 6)
#define NS_OP_VAL_CCBS_REMOTE_FREE		(NS_OBJ_ID_CCBS_OID + 7)
#define NS_OP_VAL_CCBS_CALL				(NS_OBJ_ID_CCBS_OID + 8)
#define NS_OP_VAL_CCBS_STATUS_RQ		(NS_OBJ_ID_CCBS_OID + 9)
#define NS_OP_VAL_CCBS_BFREE			(NS_OBJ_ID_CCBS_OID + 10)
#define NS_OP_VAL_CCBS_ERASE_LK_ID		(NS_OBJ_ID_CCBS_OID + 11)
#define NS_OP_VAL_CCBS_STOP_ALERTING	(NS_OBJ_ID_CCBS_OID + 12)
#define NS_ERR_VAL_CCBS_INV_LK_ID		(NS_OBJ_ID_CCBS_OID + 13)
#define NS_ERR_VAL_CCBS_INV_REF			(NS_OBJ_ID_CCBS_OID + 14)
#define NS_ERR_VAL_CCBS_LONG_DENIAL		(NS_OBJ_ID_CCBS_OID + 15)
#define NS_ERR_VAL_CCBS_SHORT_DENIAL	(NS_OBJ_ID_CCBS_OID + 16)
#define NS_ERR_VAL_CCBS_ALREADY_ACT		(NS_OBJ_ID_CCBS_OID + 17)
#define NS_ERR_VAL_CCBS_ALREADY_ACC		(NS_OBJ_ID_CCBS_OID + 18)
#define NS_ERR_VAL_CCBS_OUT_Q_FULL		(NS_OBJ_ID_CCBS_OID + 19)
#define NS_ERR_VAL_CCBS_FAIL_NOT_B		(NS_OBJ_ID_CCBS_OID + 20)
#define NS_ERR_VAL_CCBS_NOT_READY		(NS_OBJ_ID_CCBS_OID + 21)

#define NS_OP_VAL_CCBS_T_RQ				(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 1)
#define NS_OP_VAL_CCBS_T_CALL			(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 2)
#define NS_OP_VAL_CCBS_T_SUSP			(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 3)
#define NS_OP_VAL_CCBS_T_RES			(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 4)
#define NS_OP_VAL_CCBS_T_REM_FREE		(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 5)
#define NS_OP_VAL_CCBS_T_AVAIL			(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 6)
#define NS_ERR_VAL_CCBS_T_L_DENIAL		(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 7)
#define NS_ERR_VAL_CCBS_T_S_DENIAL		(NS_OBJ_ID_CCBS_T_OID + NS_OBJ_SON_NB_CCBS_OID + 8)

#define NS_OBJ_SON_NB_CCITT				1
#define NS_OBJ_SON_NB_IDENT_ORG			1
#define NS_OBJ_SON_NB_ETSI				3
#define NS_OBJ_SON_NB_ETS_300_369		1
#define NS_OBJ_SON_NB_ECT_OID			7
#define NS_OBJ_SON_NB_ETS_300_210		1
#define NS_OBJ_SON_NB_FPH_OID			4
#define NS_OBJ_SON_NB_ETS_300_359		2
#define NS_OBJ_SON_NB_CCBS_OID			20
#define NS_OBJ_SON_NB_CCBS_T_OID		8

struct asn1_obj_id_node CONST_ARRAY NS_EUROPE_OBJ_ID_TREE[] = {
/* 	current node index 				upper node index			label	first son node index		number of son nodes */

	{ASN1_OBJ_ID_ROOT,				ASN1_OBJ_ID_NIL,			0, 		NS_OBJ_ID_CCITT,			1},
	{NS_OBJ_ID_CCITT,				ASN1_OBJ_ID_ROOT,			0, 		NS_OBJ_ID_IDENTIFIED_ORG,	NS_OBJ_SON_NB_CCITT},
	{NS_OBJ_ID_IDENTIFIED_ORG,		NS_OBJ_ID_CCITT,			4, 		NS_OBJ_ID_ETSI, 			NS_OBJ_SON_NB_IDENT_ORG},
	{NS_OBJ_ID_ETSI,				NS_OBJ_ID_IDENTIFIED_ORG,	0, 		NS_OBJ_ID_ETS_300_369, 		NS_OBJ_SON_NB_ETSI},
	{NS_OBJ_ID_ETS_300_369,			NS_OBJ_ID_ETSI,				369,	NS_OBJ_ID_ECT_OID, 			NS_OBJ_SON_NB_ETS_300_369},
	{NS_OBJ_ID_ETS_300_210,			NS_OBJ_ID_ETSI,				210,	NS_OBJ_ID_FPH_OID, 			NS_OBJ_SON_NB_ETS_300_210},
	{NS_OBJ_ID_ETS_300_359,			NS_OBJ_ID_ETSI,				359,	NS_OBJ_ID_CCBS_OID, 		NS_OBJ_SON_NB_ETS_300_359},

	{NS_OBJ_ID_ECT_OID,				NS_OBJ_ID_ETS_300_369,		1,		NS_OP_VAL_ECT_EXP_EXEC, 	NS_OBJ_SON_NB_ECT_OID},
	{NS_OP_VAL_ECT_EXP_EXEC,		NS_OBJ_ID_ECT_OID, 			1,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_ECT_RQ_SUBADD,		NS_OBJ_ID_ECT_OID,			2,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_ECT_SUBADD_TRF,		NS_OBJ_ID_ECT_OID,			3,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_ECT_LK_ID_RQ,		NS_OBJ_ID_ECT_OID,			4,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_ECT_INFORM,			NS_OBJ_ID_ECT_OID,			5,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_ECT_LOOP_TEST,		NS_OBJ_ID_ECT_OID,			6,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_ECT_LK_ID_NOT_ASS,	NS_OBJ_ID_ECT_OID,			21,		0,							ASN1_OBJ_ID_NO_SON_NODE},

	{NS_OBJ_ID_FPH_OID,				NS_OBJ_ID_ETS_300_210,		1,		NS_OP_VAL_FPH_CALL, 		NS_OBJ_SON_NB_FPH_OID},
	{NS_OP_VAL_FPH_CALL,			NS_OBJ_ID_FPH_OID, 			1,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_FPH_MONITOR_T,		NS_OBJ_ID_FPH_OID, 			2,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_FPH_FREE_T,			NS_OBJ_ID_FPH_OID, 			3,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_FPH_CALL_T,			NS_OBJ_ID_FPH_OID, 			4,		0,							ASN1_OBJ_ID_NO_SON_NODE},

	{NS_OBJ_ID_CCBS_OID,			NS_OBJ_ID_ETS_300_359,		1,		NS_OP_VAL_CCBS_CALL_INFO_RET,	NS_OBJ_SON_NB_CCBS_OID},
	{NS_OBJ_ID_CCBS_T_OID,			NS_OBJ_ID_ETS_300_359,		2,		NS_OP_VAL_CCBS_T_RQ,		NS_OBJ_SON_NB_CCBS_T_OID},

	{NS_OP_VAL_CCBS_CALL_INFO_RET,	NS_OBJ_ID_CCBS_OID, 		1,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_RQ,				NS_OBJ_ID_CCBS_OID, 		2,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_DEACTIVATE,		NS_OBJ_ID_CCBS_OID, 		3,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_INTERROGATE,	NS_OBJ_ID_CCBS_OID, 		4,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_ERASE,			NS_OBJ_ID_CCBS_OID, 		5,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_REMOTE_FREE,	NS_OBJ_ID_CCBS_OID, 		6,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_CALL,			NS_OBJ_ID_CCBS_OID, 		7,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_STATUS_RQ,		NS_OBJ_ID_CCBS_OID, 		8,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_BFREE,			NS_OBJ_ID_CCBS_OID, 		9,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_ERASE_LK_ID,	NS_OBJ_ID_CCBS_OID, 		10,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_STOP_ALERTING,	NS_OBJ_ID_CCBS_OID, 		11,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_INV_LK_ID,		NS_OBJ_ID_CCBS_OID, 		20,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_INV_REF,		NS_OBJ_ID_CCBS_OID, 		21,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_LONG_DENIAL,	NS_OBJ_ID_CCBS_OID, 		22,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_SHORT_DENIAL,	NS_OBJ_ID_CCBS_OID, 		23,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_ALREADY_ACT,	NS_OBJ_ID_CCBS_OID, 		24,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_ALREADY_ACC,	NS_OBJ_ID_CCBS_OID, 		25,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_OUT_Q_FULL,	NS_OBJ_ID_CCBS_OID, 		26,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_FAIL_NOT_B,	NS_OBJ_ID_CCBS_OID, 		27,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_NOT_READY,		NS_OBJ_ID_CCBS_OID, 		28,		0,							ASN1_OBJ_ID_NO_SON_NODE},

	{NS_OP_VAL_CCBS_T_RQ,			NS_OBJ_ID_CCBS_T_OID, 		1,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_T_CALL,			NS_OBJ_ID_CCBS_T_OID, 		2,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_T_SUSP,			NS_OBJ_ID_CCBS_T_OID, 		3,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_T_RES,			NS_OBJ_ID_CCBS_T_OID, 		4,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_T_REM_FREE,		NS_OBJ_ID_CCBS_T_OID, 		5,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_CCBS_T_AVAIL,		NS_OBJ_ID_CCBS_T_OID, 		6,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_T_L_DENIAL,	NS_OBJ_ID_CCBS_T_OID, 		20,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_CCBS_T_S_DENIAL,	NS_OBJ_ID_CCBS_T_OID, 		21,		0,							ASN1_OBJ_ID_NO_SON_NODE},

};

#define NS_EUROPE_OBJ_ID_NB		Ns_tab_item_nb (NS_EUROPE_OBJ_ID_TREE)

#else

#define NS_EUROPE_OBJ_ID_TREE		P_NIL
#define NS_EUROPE_OBJ_ID_NB			0		

#endif

/*==========================================================================

				INCLUDE ns_sstab.eur FILE containing :
			- Descriptions of ASN1 Types (with ASN1 Meta-programs)
			- Tables of descriptions of list of storage contexts
			- EUROPE specific table for operations
*/

	/* define Macros used in ns_sstab.eur */

#define Ns_eur_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_eur_end_table_or_function		};

#define Ns_ss_store_desc_entry(p_pc, f_nb, type, p_str, i_inter, rep, next, opt)		\
	{Pic_address (p_pc), f_nb, type, Pic_address (p_str), i_inter, rep, next, opt},

#define Ns_ss_op_tab_entry(if_id, tag, val, p_arg, p_ctx_arg, p_res, p_ctx_res, ssdu_fct)	\
	{if_id, tag, val, Pic_address (p_arg), Pic_address (p_ctx_arg), Pic_address (p_res), Pic_address (p_ctx_res), ssdu_fct},

#define NS_ASN1_SEQUENCE				ASN1_SEQUENCE,
#define NS_ASN1_SEQUENCE_OF				ASN1_SEQUENCE_OF,
#define NS_ASN1_SET_OF					ASN1_SET_OF,
#define NS_ASN1_CHOICE					ASN1_CHOICE,
#define NS_ASN1_NUMERIC_STRING			ASN1_NUMERIC_STRING,
#define NS_ASN1_IA5_STRING				ASN1_IA5_STRING,

#if OM_CODE_TYPE == OM_PIC	/* PIC used : redefine some ASN1 Macros used for ASN1 Meta-programs */

#	undef ASN1_TYPE_START
#	undef ASN1_TYPE_FIELD
#	undef ASN1_TYPE_OPTIONAL_FIELD
#	undef ASN1_TYPE_LAST_FIELD
#	undef ASN1_TYPE_OPT_LAST_FIELD

#	define ASN1_TYPE_START(type)						struct type type = {
#	define ASN1_TYPE_FIELD(name)						{P_NIL, P_NIL},
#	define ASN1_TYPE_OPTIONAL_FIELD(name, ind_list)		{P_NIL, P_NIL},
#	define ASN1_TYPE_LAST_FIELD(name)					{P_NIL, P_NIL}}
#	define ASN1_TYPE_OPT_LAST_FIELD(name, ind_list)		{P_NIL, P_NIL}}

#endif

#include "eur.ns_sstab"

/*==========================================================================

			- EUROPE specific table for errors -
*/

#if NS_USE_EUROPE_OPERATION == ON

CONST_ARRAY struct ns_ss_error		EUROPE_ERROR_TAB[] = {
/*	interface identifier			tag					value */

	{SS_ERR_NOT_SUBSCRIBED,			FAC_INTEGER_TAG,	SS_ERR_NOT_SUBSCRIBED},
	{SS_ERR_NOT_AVAILABLE,			FAC_INTEGER_TAG,	SS_ERR_NOT_AVAILABLE},
	{SS_ERR_NOT_IMPLEMENTED,		FAC_INTEGER_TAG,	SS_ERR_NOT_IMPLEMENTED},
	{SS_ERR_INVALID_SERVED_NB,		FAC_INTEGER_TAG,	SS_ERR_INVALID_SERVED_NB},
	{SS_ERR_INVALID_CALL_STATE,		FAC_INTEGER_TAG,	SS_ERR_INVALID_CALL_STATE},
	{SS_ERR_SERVICE_NOT_PROVIDED,	FAC_INTEGER_TAG,	SS_ERR_SERVICE_NOT_PROVIDED},
	{SS_ERR_NOT_INCOMING_CALL,		FAC_INTEGER_TAG,	SS_ERR_NOT_INCOMING_CALL},
	{SS_ERR_INTERAC_NOT_ALLOWED,	FAC_INTEGER_TAG,	SS_ERR_INTERAC_NOT_ALLOWED},
	{SS_ERR_RESOURCE_UNAVAILABLE,	FAC_INTEGER_TAG,	SS_ERR_RESOURCE_UNAVAILABLE},

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)
	{SS_ERR_AOC_NO_CH_INF_AVAIL,	FAC_INTEGER_TAG,	SS_ERR_AOC_NO_CH_INF_AVAIL},
#endif

#if NS_SS_CUG == ON
	{SS_ERR_CUG_INV_OR_UNREG_INDEX,	FAC_INTEGER_TAG,	SS_ERR_CUG_INV_OR_UNREG_INDEX},
	{SS_ERR_CUG_RQ_SRV_VIOL_CONSTR,	FAC_INTEGER_TAG,	SS_ERR_CUG_RQ_SRV_VIOL_CONSTR},
	{SS_ERR_CUG_OUT_CALL_BARRED,	FAC_INTEGER_TAG,	SS_ERR_CUG_OUT_CALL_BARRED},
	{SS_ERR_CUG_INC_CALL_BARRED,	FAC_INTEGER_TAG,	SS_ERR_CUG_INC_CALL_BARRED},
	{SS_ERR_CUG_USER_NOT_MEMBER,	FAC_INTEGER_TAG,	SS_ERR_CUG_USER_NOT_MEMBER},
	{SS_ERR_CUG_FAC_SUB_CL_INCONS,	FAC_INTEGER_TAG,	SS_ERR_CUG_FAC_SUB_CL_INCONS},
#endif

#if NS_SS_DIVERSION == ON
	{SS_ERR_INV_DIVERTED_TO_NB,		FAC_INTEGER_TAG,	SS_ERR_INV_DIVERTED_TO_NB},
	{SS_ERR_DIV_SPECIAL_SERV_NB,	FAC_INTEGER_TAG,	SS_ERR_DIV_SPECIAL_SERV_NB},
	{SS_ERR_DIV_TO_SERVED_USER_NB,	FAC_INTEGER_TAG,	SS_ERR_DIV_TO_SERVED_USER_NB},
	{SS_ERR_DIV_INC_CALL_ACC,		FAC_INTEGER_TAG,	SS_ERR_DIV_INC_CALL_ACC},
	{SS_ERR_DIV_NB_EXCEEDED,		FAC_INTEGER_TAG,	SS_ERR_DIV_NB_EXCEEDED},
	{SS_ERR_DIV_NOT_ACTIVATED,		FAC_INTEGER_TAG,	SS_ERR_DIV_NOT_ACTIVATED},
	{SS_ERR_DIV_RQ_ALREADY_ACC,		FAC_INTEGER_TAG,	SS_ERR_DIV_RQ_ALREADY_ACC},
#endif

#if NS_SS_EXPL_CHAN_RESERVATION == ON
	{SS_ERR_CH_RES_MX_NB_OF_RES,	FAC_INTEGER_TAG,	SS_ERR_CH_RES_MX_NB_OF_RES},
	{SS_ERR_CH_RES_NO_RES_INV_IND,	FAC_INTEGER_TAG,	SS_ERR_CH_RES_NO_RES_INV_IND},
	{SS_ERR_CH_RES_UNWANTED_RES,	FAC_INTEGER_TAG,	SS_ERR_CH_RES_UNWANTED_RES},
	{SS_ERR_CH_RES_IMPLICIT_USED,	FAC_INTEGER_TAG,	SS_ERR_CH_RES_IMPLICIT_USED},
#endif

#if NS_SS_CONFERENCE == ON
	{SS_ERR_CONF_ILL_CONF_ID,		FAC_INTEGER_TAG,	SS_ERR_CONF_ILL_CONF_ID},
	{SS_ERR_CONF_ILL_PARTY_ID,		FAC_INTEGER_TAG,	SS_ERR_CONF_ILL_PARTY_ID},
	{SS_ERR_CONF_PARTY_NB_EXCEED,	FAC_INTEGER_TAG,	SS_ERR_CONF_PARTY_NB_EXCEED},
	{SS_ERR_CONF_NOT_ACTIVE,		FAC_INTEGER_TAG,	SS_ERR_CONF_NOT_ACTIVE},
	{SS_ERR_CONF_NOT_ALLOWED,		FAC_INTEGER_TAG,	SS_ERR_CONF_NOT_ALLOWED},
#endif

#if NS_SS_USER_USER_EXP == ON
	{SS_ERR_UUS_NET_REJECT,			FAC_INTEGER_TAG,	SS_ERR_UUS_NET_REJECT},
	{SS_ERR_UUS_USER_REJECT,		FAC_INTEGER_TAG,	SS_ERR_UUS_USER_REJECT},
#endif

#if NS_SS_ECT == ON
	{SS_ERR_ECT_LK_ID_NOT_ASSIG,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_ECT_LK_ID_NOT_ASS},
#endif

#if NS_SS_CCBS == ON
	{SS_ERR_CCBS_INV_CALL_LK_ID,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_INV_LK_ID},
	{SS_ERR_CCBS_INV_REFERENCE,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_INV_REF},
	{SS_ERR_CCBS_LONG_DENIAL,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_LONG_DENIAL},
	{SS_ERR_CCBS_SHORT_DENIAL,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_SHORT_DENIAL},
	{SS_ERR_CCBS_ALREADY_ACTIV,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_ALREADY_ACT},
	{SS_ERR_CCBS_ALREADY_ACCEPT,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_ALREADY_ACC},
	{SS_ERR_CCBS_OUT_QUEUE_FULL,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_OUT_Q_FULL},
	{SS_ERR_CCBS_CALL_FAIL_NOT_B,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_FAIL_NOT_B},
	{SS_ERR_CCBS_NOT_READY,			FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_NOT_READY},

	{SS_ERR_CCBS_T_LONG_DENIAL,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_T_L_DENIAL},
	{SS_ERR_CCBS_T_SHORT_DENIAL,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_CCBS_T_S_DENIAL},
#endif
};

#endif

/* EOF */
