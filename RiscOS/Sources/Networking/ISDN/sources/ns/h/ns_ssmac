
/*-----------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_ssmac.h
 *
 * $Revision$
 *
 * $Date$
 *
 * 		Implements the macros used to access to the structures of the
 *		Call Control primitives specific to the SUPPLEMENTARY SERVICES.
 *
 *-----------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef NS_SS_MAC_H
#	define NS_SS_MAC_H

				/* Common macros used to simplify the next ones */

		/* Structure alignment of interface value pointer */

#define Align_struct_ns_p_ss_val()	ns_int_ctx.p__ss_data = (uchar FAR *)Round ((long)(ns_int_ctx.p__ss_data))
#define Align_struct_ns_p_val()		ns_int_ctx.p__val = (uchar FAR *)Round ((long)(ns_int_ctx.p__val))

#define Set_ns_fac_val(val_id, val) ((struct ns_ss_fac_comp FAR *)ns_int_ctx.p__ss_data) -> val_id = val

/*-------------------------------------------------------------------------*/

		/*  MACROS USED TO ACCESS A VALUE OR AN ADDRESS INSIDE FACILITY COMPONENT :
				'Get_ie (...)' MACRO MUST BE CALLED BEFORE to check the presence of IE.

			1) First Macro to be called is Isdn_get_ss_first_component (not Q-SIG).
			   Q-SIG variant : first Macro to be called is Isdn_get_fac_first_apdu_qsi.

			1b) Q-SIG variant only :
				then type of APDU is given by '*ns_int_ctx.p__ss_data'.
				If type is ROSEApdu, 'Isdn_get_first_rose_comp_qsi' is to be called,
				then read component, processing from 2) below.
				If type is DSEApdu, 'Isdn_get_ss_dse_apdu_val_qsi' can be called to
				read each field of DseAPDU (inside 'ns_ss_qsi_dse_apdu' structure),
				in particular to read number of components inside DseAPDU ('component_nb')
				and offset for following component ('first_comp_offset'). if offset is
				OFFSET_NIL, this is the end of IE : all content is read, else
				'Isdn_get_first_dse_comp_qsi' is to be called and continue from 2) below
				if number of components is not null (components contained in DseAPDU) or
				continue from 1b) again if it is null (all DseAPDU content is read :
				next APDU).

			2) Then 'Isdn_get_ss_comp_val' can be called to read each field of component

			3) Then 'Isdn_ss_is_op_data' to know if operation specific data is present.
			   If so, 'Isdn_get_ss_a_op_data' to get data address and 1 or more Macro(s)
			   to read fields specific to operation.

			4) Then 'Isdn_ss_is_next_component' to know if another component is present and
			   'Isdn_get_ss_next_component' to be able to read it. Macros used to read a
			   component can now be called again ( 2) and 3) above).
			   Q-SIG variant : The next data to be read may be a complete APDU if type of
			   APDU given in 1b) before was ROSEApdu or if it was DSeAPDU and all components
			   have been read according to the number of components read in 1b : in this case,
			   process from 1b) above to read next APDU. If Type was DseAPDU and all components
			   have not yet been read (nb of components > 1), process from 2) above to read
			   next component contained in DseAPDU.
		*/

			/*
			   Isdn_get_ss_first_component

					INPUT :
						- pr		= primitive code identifier,
						- ie		= information element identifier.

					COMMON CONTEXT :
						- ns_int_ctx.p__offset = points on the offset area.
				*/

#define Isdn_get_ss_first_component(pr,ie)	ns_int_ctx.p__ss_data = (uchar FAR *)&(P_start_val_ns (pr,ie) -> component)

			/*
			   Isdn_get_ss_comp_val

					INPUT :
						- val_id	= value identifier (inside 'component' structure).

					COMMON CONTEXT :
						- ns_int_ctx.p__ss_data = points on currenct component inside IE value,

					OUTPUT : component value.
				*/

#define Isdn_get_ss_comp_val(val_id)	((struct ns_ss_fac_comp FAR *)ns_int_ctx.p__ss_data) -> val_id

			/*
			   Isdn_ss_is_op_data : expression TRUE if operation specific data
					is present in the component or FALSE if no data.

					COMMON CONTEXT :
						- ns_int_ctx.p__ss_data = points on current component inside IE value.
				*/

#define Isdn_ss_is_op_data()		(Isdn_get_ss_comp_val (component_data_offset) != OFFSET_NIL)

			/*
			   Isdn_get_ss_a_op_data : update value pointer to address of operation specific data.

					COMMON CONTEXT :
						- ns_int_ctx.p__offset = points on the offset area,
						- ns_int_ctx.p__ss_data = points on currenct component inside IE value,
				*/

#define Isdn_get_ss_a_op_data()		ns_int_ctx.p__val = ns_int_ctx.p__ss_data + (Isdn_get_ss_comp_val (component_data_offset))

			/*
			   Isdn_ss_is_next_component : expression TRUE if another component
					is present in the IE or FALSE if no more component.

					COMMON CONTEXT :
						- ns_int_ctx.p__ss_data = points on current component inside IE value.
				*/

#define Isdn_ss_is_next_component()		(Isdn_get_ss_comp_val (next_component_offset) != OFFSET_NIL)

			/*
			   Isdn_get_ss_next_component

					COMMON CONTEXT :
						- ns_int_ctx.p__offset = points on the offset area,
						- ns_int_ctx.p__ss_data = points on current component inside IE value.
				*/

#define Isdn_get_ss_next_component()	ns_int_ctx.p__ss_data += (Isdn_get_ss_comp_val (next_component_offset))

/*-------------------------------------------------------------------------*/

		/*  MACROS USED TO STORE FACILITY COMPONENTS :
				'Isdn_xx_store_facility' MACRO MUST BE CALLED BEFORE

			0) Q-SIG variant only :
			First Macro to be called is one among the 6 following ones :
			Isdn_qsi_store_fac_rose_apdu, Isdn_qsi_store_fac_dse_apdu,
			Isdn_qsi_store_fac_dse_BEGIN, Isdn_qsi_store_fac_dse_END,
			Isdn_qsi_store_fac_dse_CONTI, Isdn_qsi_store_fac_dse_ABORT.
			Then, if type of APDU is ROSEApdu, storing process is to be continued
			from 1) below. If type is DSEApdu :
			- if it contains no component and if it is the last APDU (no more data) :
			'Isdn_set_qsi_last_dse_comp' macro is to be called and storing is over,
			- if it contains 1 or more component(s) :
			'Isdn_set_qsi_next_dse_comp' macro is to be called and storing process is
			to be continued from 1) below,
			- if it contains no component but it is not the last APDU :
			'Isdn_set_qsi_next_dse_comp' macro is to be called and storing process is
			to be continued from 0) above (process of next APDU).

			1) First (or next) Macro to be called is one among the 5 following ones :
			Store_ns_fac_component, Store_ns_fac_invoke_comp, Store_ns_fac_retresult_comp
			Store_ns_fac_reterror_comp, Store_ns_fac_reject_comp.

			2) Then 1 or more Macro(s) specific to operation or Store_ns_fac_no_op_data if no operation data,

			3) Then Set_ns_last_component if no more component in Facility IE or
			Set_ns_to_next_component if there are other components, whose storing
			to be processing from 1) above (not Q-SIG).
			Q-SIG variant to store next components : if Type of APDU stored is ROSEApdu,
			next data is a complete APDU to be stored from 0) above. If type is DSEApdu,
			storing is to be continued from 0) above if it is the last component contained
			in DseAPDU (according to the 'number of components' stored in 0) ),
			else from 1) above (following component inside DseAPDU).
		*/

#define Store_ns_fac_component(tag, inv_lk_id_res_pres, inv, link, op_err_pb)	\
			Set_ns_fac_val (component_tag, tag);								\
			Set_ns_fac_val (inv_or_lk_id_or_res_presence, inv_lk_id_res_pres);	\
			Set_ns_fac_val (invoke_id, inv);									\
			Set_ns_fac_val (lk_id_or_pb_tag, link);								\
			Set_ns_fac_val (op_err_pb_identifier, op_err_pb);					\
			ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Rnd_sizeof (struct ns_ss_fac_comp);	\
			Set_ns_fac_val (component_data_offset, (ushort)((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data))

			/*
			   Store_ns_fac_invoke_comp : store an Invoke component

					INPUT :
						- lk_id_pres = presence of Linked identifier (PRESENT/ABSENT),
						- inv = Invoke identifier (short),
						- link = Linked identifier (short),
						- op_id	= NS interface operation identifier.
			*/

#define Store_ns_fac_invoke_comp(lk_id_pres, inv, link, op_id)		\
			Store_ns_fac_component (FAC_INVOKE, lk_id_pres, inv, link, op_id)

			/*
			   Store_ns_fac_retresult_comp : store a ReturnResult component

					INPUT :
						- op_pres = presence of operation data (PRESENT/ABSENT),
						- inv = Invoke identifier (short),
						- op_id	= NS interface operation identifier.
			*/

#define Store_ns_fac_retresult_comp(op_pres, inv, op_id)			\
			Store_ns_fac_component (FAC_RETURN_RESULT, op_pres, inv, 0, op_id)

			/*
			   Store_ns_fac_reterror_comp : store a ReturnError component

					INPUT :
						- inv = Invoke identifier (short),
						- err_id = NS interface error identifier.
			*/

#define Store_ns_fac_reterror_comp(inv, err_id)						\
			Store_ns_fac_component (FAC_RETURN_ERROR, ABSENT, inv, 0, err_id)

			/*
			   Store_ns_fac_reject_comp : store a Reject component

					INPUT :
						- inv_id_pres = presence of Invoke identifier (PRESENT/ABSENT),
						- inv = Invoke identifier (short),
						- pb_tag = tag (type) of problem,
						- pb_val = problem value.
			*/

#define Store_ns_fac_reject_comp(inv_id_pres, inv, pb_tag, pb_val)	\
			Store_ns_fac_component (FAC_REJECT, inv_id_pres, inv, pb_tag, pb_val)

		/* Store_ns_fac_no_op_data : THIS MACRO MUST BE CALLED if component has no operation data */

#define Store_ns_fac_no_op_data()	Set_ns_fac_val (component_data_offset, OFFSET_NIL)

		/* Set_ns_last_component : THIS MACRO MUST BE CALLED for last component in Facility IE */

#define Set_ns_last_component()		Set_ns_fac_val (next_component_offset, OFFSET_NIL)

		/* Set_ns_to_next_component : THIS MACRO MUST BE CALLED AFTER ALL COMPONENT DATA
			is stored to store another component in Facility IE */

#define Set_ns_to_next_component()																							\
			Align_struct_ns_p_val();																						\
			Set_ns_fac_val (next_component_offset, (ushort)((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data));	\
			ns_int_ctx.p__ss_data = ns_int_ctx.p__val

/*-------------------------------------------------------------------------*/

			/*  Macros used to store facility data specific to operation : they are
				based on the operation specific structures defined in ns_ssint.h */

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)	/* AOC service supported{ */

		/*
		   Store_ns_aoc_charg_rq_arg : store data for ARGUMENT of AOC ChargingRequest operation

				INPUT : case = charging case.
		*/

#define Store_ns_aoc_charg_rq_arg(case)		\
			((struct ns_aoc_charging_rq_arg FAR *)ns_int_ctx.p__val) -> charging_case = case;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_aoc_charging_rq_arg)

		/*
		   Store_ns_aoc_charg_rq_not_cur : store RESULT of AOC ChargingRequest operation
				different from list of currency info (type is not AOCSCurrencyInfoList).

				INPUT :
					- type = type of charging information,
					- special_arr = SpecialArrInfo (meaningful only if type is AOCSSpecialArrInfo).
		*/

#define Store_ns_aoc_charg_rq_not_cur(type, special_arr)		\
			((struct ns_aoc_charging_rq_res FAR *)ns_int_ctx.p__val) -> result_type = type;		\
			((struct ns_aoc_charging_rq_res FAR *)ns_int_ctx.p__val) -> aocs_special_arr_info = special_arr;	\
			((struct ns_aoc_charging_rq_res FAR *)ns_int_ctx.p__val) -> aocs_first_cur_info = OFFSET_NIL;		\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_aoc_charging_rq_res)

		/*
		   Store_ns_aoc_charg_rq_currency : store RESULT of AOC ChargingRequest operation
				which is a list of 1 or more currency info (type is AOCSCurrencyInfoList).

				no INPUT : data is to be provided with next Macro.
		*/

#define Store_ns_aoc_charg_rq_currency()		\
	((struct ns_aoc_charging_rq_res FAR *)ns_int_ctx.p__val) -> result_type = NS_AOCS_CURRENCY_INFO_RQ;	\
	((struct ns_aoc_charging_rq_res FAR *)ns_int_ctx.p__val) -> aocs_first_cur_info = (ushort)(((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data) + Rnd_sizeof (struct ns_aoc_charging_rq_res));	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_aoc_charging_rq_res)

		/*
		   Store_ns_aocs_currency_info : store 1 instance of AOCS currency info (AOCSCurrencyInfo structure).

				INPUT :
					- ch_item = chargedItem (0..4),
					- cur_type = type of currency info provided,
					- spec_ch_code = specialChargingCode (1..10),
					- amount_ = currencyAmount inside Amount (0..16777215),
					- amount_mul = multiplier inside Amount : (0..6),
					- volume_u_ch_type = vRVolumeUnit inside VolumeRateCurrency (0..2) or dChargingType inside DurationCurrency (0..1),
					- lg_time_u = lengthOfTimeUnit inside dTime (0..16777215),
					- scale_ = scale inside dTime (0..6),
					- gr_lg_time_u = lengthOfTimeUnit inside dGranularity (0..16777215) or 0xFFFFFFFF if not present,
					- gr_scale = scale inside dGranularity : ENUMERATED {0, 1, 2, 3, 4, 5, 6} or 255 if not present,
					- cur_sz = size of Currency string,
					- p_cur = address of Currency string.
		*/

#define Store_ns_aocs_currency_info(ch_item, cur_type, spec_ch_code, amount_, amount_mul, volume_u_ch_type, lg_time_u, scale_, gr_lg_time_u, gr_scale, cur_sz, p_cur)	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> charged_item = ch_item;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> currency_info_type = cur_type;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> special_charging_code = spec_ch_code;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> amount = amount_;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> amount_multiplier = amount_mul;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> volume_unit_or_charg_type = volume_u_ch_type;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> length_of_time_unit = lg_time_u;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> scale = scale_;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> granularity_lg_time_u = gr_lg_time_u;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> granularity_scale = gr_scale;	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> currency_size = cur_sz;	\
	Memcpy_far ((char FAR *)(&(((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> first_currency_oct)), (char FAR *)(p_cur), cur_sz)

		/*
		   Set_ns_last_aocs_cur_info : store end of AOCS currency info : It must be called
				after last instance in list.

		   Set_ns_next_aocs_cur_info : it must be called before storing next instance of AOCS currency info.
		*/

#define Set_ns_last_aocs_cur_info()		\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> next_currency_info = OFFSET_NIL;	\
	ns_int_ctx.p__val = &(((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> first_currency_oct) + ((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> currency_size

#define Set_ns_next_aocs_cur_info()		\
	ns_int_ctx.p__offset = &(((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> first_currency_oct) + ((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> currency_size;	\
	ns_int_ctx.p__offset = (uchar FAR *)Round ((long)(ns_int_ctx.p__offset));	\
	((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> next_currency_info = (ushort)((ulong)ns_int_ctx.p__offset - (ulong)ns_int_ctx.p__ss_data);	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset;	\
	ns_int_ctx.p__offset = ns_int_ctx.p__start

#if NS_SS_AOC_S == ON

		/* Store_ns_aocs_currency_not_av : store ARGUMENT of AOCSCurrency operation : chargeNotAvailable. */

#define Store_ns_aocs_currency_not_av()		\
			((struct ns_aocs_currency_arg FAR *)ns_int_ctx.p__val) -> type = NS_AOCS_CHARG_NOT_AVAIL;	\
			((struct ns_aocs_currency_arg FAR *)ns_int_ctx.p__val) -> first_cur_info = OFFSET_NIL;		\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_aocs_currency_arg)

		/*
		   Store_ns_aocs_currency_list : store ARGUMENT of AOCSCurrency operation
				which is a list of 1 or more currency info (type is AOCSCurrencyInfoList).

				no INPUT : data is to be provided with next Macro.
		*/

#define Store_ns_aocs_currency_list()		\
	((struct ns_aocs_currency_arg FAR *)ns_int_ctx.p__val) -> type = NS_AOCS_CURRENCY_INFO;	\
	((struct ns_aocs_currency_arg FAR *)ns_int_ctx.p__val) -> first_cur_info = (ushort)(((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data) + Rnd_sizeof (struct ns_aocs_currency_arg));	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_aocs_currency_arg)

		/*
		   Store_ns_aocs_special_arr : store ARGUMENT of AOCSSpecialArr operation :

				INPUT :
					- ch_type = type of charging information,
					- special_arr = SpecialArrInfo (meaningful only if type is AOCSSpecialArrInfo).
		*/

#define Store_ns_aocs_special_arr(ch_type, special_arr)		\
			((struct ns_aocs_special_arr_arg FAR *)ns_int_ctx.p__val) -> type = ch_type;			\
			((struct ns_aocs_special_arr_arg FAR *)ns_int_ctx.p__val) -> arr_info = special_arr;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_aocs_special_arr_arg)

#endif

#if NS_SS_AOC_D == ON

		/*
		   Store_ns_aocd_currency_not_spfc : store ARGUMENT of AOCDCurrency operation which is
				not a specific currency info (type is chargeNotAvailable or freeOfCharge).

				INPUT :
					- type = type of ARGUMENT.
		*/

#define Store_ns_aocd_currency_not_spfc(type)	\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> arg_type = type;	\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> currency_size = 0;	\
	ns_int_ctx.p__val = &(((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> first_currency_oct)

		/*
		   Store_ns_aocd_currency_spfc : store ARGUMENT of AOCDCurrency operation which is
				a specific currency info (type is specificCurrency inside AOCDCurrencyInfo).

				INPUT :
					- ch_type = type of charging information (inside specificCurrency),
					- bill_id = AOCD Billing ID (in specificCurrency) : ENUMERATED {0, 1, 2} or 255 if absent,
					- amount_ = currencyAmount inside Amount (0..16777215),
					- amount_mul = multiplier inside Amount : (0..6),
					- cur_sz = size of Currency string,
					- p_cur = address of Currency string.
		*/

#define Store_ns_aocd_currency_spfc(ch_type, bill_id, amount_, amount_mul, cur_sz, p_cur)	\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCD_SPECIFIC_CURRENCY;	\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> type_of_charging = ch_type;		\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> billing_id = bill_id;				\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> amount = amount_;					\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> amount_multiplier = amount_mul;	\
	((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> currency_size = cur_sz;			\
	Memcpy_far ((char FAR *)(&(((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> first_currency_oct)), (char FAR *)(p_cur), cur_sz);\
	ns_int_ctx.p__val = &(((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> first_currency_oct) + cur_sz

		/*
		   Store_ns_aocd_charg_u_not_spfc : store ARGUMENT of AOCDChargingUnit operation which is
				not a specific charging unit info (type is chargeNotAvailable or freeOfCharge).

				INPUT :
					- type = type of ARGUMENT.
		*/

#define Store_ns_aocd_charg_u_not_spfc(type)	\
	((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> arg_type = type;	\
	((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_recorded_unit = OFFSET_NIL;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_aocd_charging_unit_arg)

		/*
		   Store_ns_aocd_charg_u_spfc : store ARGUMENT of AOCDChargingUnit operation which is
				a specific charging unit info (type is specificChargingUnits inside AOCDChargingUnitInfo).

				INPUT :
					- ch_type = type of charging information (inside specificChargingUnit),
					- bill_id = AOCD Billing ID (in specificChargingUnit) : ENUMERATED {0, 1, 2} or 255 if absent.
				data in list of recorded units is to be provided with next Macros.
		*/

#define Store_ns_aocd_charg_u_spfc(ch_type, bill_id)	\
	((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCD_SPECIFIC_CHARGING_UNIT;	\
	((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> type_of_charging = ch_type;		\
	((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> billing_id = bill_id;			\
	((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_recorded_unit = (ushort)(((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data) + Rnd_sizeof (struct ns_aocd_charging_unit_arg));	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_aocd_charging_unit_arg)

#endif

#if (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)

		/*
		   Store_ns_aoc_recorded_unit : store 1 instance of recorded unit info (RecordedUnits structure).

				INPUT :
					- u_type = recordedTypeOfUnits : INTEGER (1..16) or 255 if absent,
					- u_nb = recordedNumberOfUnits : INTEGER (0..16777215) or NS_SS_INT_ULONG_NOT_PROVIDED (0xFFFFFFFF) if not available.
		*/

#define Store_ns_aoc_recorded_unit(u_type, u_nb)	\
	((struct ns_aoc_recorded_unit FAR *)ns_int_ctx.p__val) -> type_of_unit = u_type;	\
	((struct ns_aoc_recorded_unit FAR *)ns_int_ctx.p__val) -> number_of_units = u_nb

		/*
		   Set_ns_last_aoc_recorded_u : store end of recorded unit info : It must be called
				after last instance in list.

		   Set_ns_next_aoc_recorded_u : it must be called before storing next instance of recorded unit info.
		*/

#define Set_ns_last_aoc_recorded_u()	\
	((struct ns_aoc_recorded_unit FAR *)ns_int_ctx.p__val) -> next_unit_info = OFFSET_NIL;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_aoc_recorded_unit)

#define Set_ns_next_aoc_recorded_u()	\
	((struct ns_aoc_recorded_unit FAR *)ns_int_ctx.p__val) -> next_unit_info = (ushort)(((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data) + Rnd_sizeof (struct ns_aoc_recorded_unit));	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_aoc_recorded_unit)

#endif

#if NS_SS_AOC_E == ON

		/*
		   Store_ns_aoce_currency_not_av : store ARGUMENT of AOCECurrency operation : chargeNotAvailable
		*/

#define Store_ns_aoce_currency_not_av()		\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCE_CHARGE_NOT_AVAILABLE;	\
	ns_int_ctx.p__val++

		/*
		   Store_ns_aoce_currency_free : store ARGUMENT of AOCECurrency operation : freeOfCharge

				INPUT :
					- ch_assoc = type of ChargingAssociation or 255 if absent.
					- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
					- party_type = type of PartyNumber,
					- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
					- p_nb = address of NumberDigits string.
		*/

#define Store_ns_aoce_currency_free(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb)	\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCE_CURR_FREE_OF_CHARGE;	\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> charg_assoc_type = ch_assoc;	\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> charg_identifier = ch_id;		\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_type;	\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = nb_type;			\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> currency_size = 0;			\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;		\
	Memcpy_far ((char FAR *)(&(((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> first_currency_oct)), (char FAR *)(p_nb), nb_sz);\
	ns_int_ctx.p__val = &(((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> first_currency_oct) + nb_sz

		/*
		   Store_ns_aoce_currency_spfc : store ARGUMENT of AOCECurrency operation which is
				a specific currency info (type is specificCurrency inside AOCECurrencyInfo).

				INPUT :
					- ch_assoc = type of ChargingAssociation or 255 if absent.
					- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
					- party_type = type of PartyNumber,
					- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
					- p_nb = address of NumberDigits string.
					- bill_id = AOCE Billing ID (in specificCurrency) : ENUMERATED {0, .. , 7} or 255 if absent,
					- amount_ = currencyAmount inside Amount (0..16777215),
					- amount_mul = multiplier inside Amount : (0..6),
					- cur_sz = size of Currency string,
					- p_cur = address of Currency string.
		*/

#define Store_ns_aoce_currency_spfc(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb, bill_id, amount_, amount_mul, cur_sz, p_cur)	\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCE_SPECIFIC_CURRENCY;	\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> charg_assoc_type = ch_assoc;		\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> charg_identifier = ch_id;			\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_type;		\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = nb_type;				\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;			\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> billing_id = bill_id;				\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> amount = amount_;					\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> amount_multiplier = amount_mul;	\
	((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> currency_size = cur_sz;			\
	Memcpy_far ((char FAR *)(&(((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> first_currency_oct)), (char FAR *)(p_cur), cur_sz);\
	ns_int_ctx.p__val = &(((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> first_currency_oct) + cur_sz;	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);					\
	ns_int_ctx.p__val += nb_sz

		/*
		   Store_ns_aoce_charg_u_not_av : store ARGUMENT of AOCEChargingUnit operation : chargeNotAvailable
		*/

#define Store_ns_aoce_charg_u_not_av()		\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCE_CHARGING_NOT_AVAILABLE;	\
	ns_int_ctx.p__val++

		/*
		   Store_ns_aoce_charg_u_free : store ARGUMENT of AOCEChargingUnit operation : freeOfCharge

				INPUT :
					- ch_assoc = type of ChargingAssociation or 255 if absent.
					- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
					- party_type = type of PartyNumber,
					- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
					- p_nb = address of NumberDigits string.
		*/

#define Store_ns_aoce_charg_u_free(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb)	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCE_FREE_OF_CHARGE;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_recorded_unit = OFFSET_NIL;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> charg_assoc_type = ch_assoc;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> charg_identifier = ch_id;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_type;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = nb_type;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;	\
	Memcpy_far ((char FAR *)(&(((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit)), (char FAR *)(p_nb), nb_sz);\
	ns_int_ctx.p__val = &(((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit) + nb_sz

		/*
		   Store_ns_aoce_charg_u_spfc : store ARGUMENT of AOCEChargingUnit operation which is
				a specific charging unit info (type is specificChargingUnits inside AOCEChargingUnitInfo).

				INPUT :
					- ch_assoc = type of ChargingAssociation or 255 if absent.
					- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
					- party_type = type of PartyNumber,
					- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
					- p_nb = address of NumberDigits string.
					- bill_id = AOCE Billing ID (in specificChargingUnits) : ENUMERATED {0, .. , 7} or 255 if absent.
				data in list of recorded units is to be provided with Macros above, as for AOC-D
		*/

#define Store_ns_aoce_charg_u_spfc(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb, bill_id)	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> arg_type = NS_AOCE_SPECIFIC_CHARGING_UNIT;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> charg_assoc_type = ch_assoc;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> charg_identifier = ch_id;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_type;	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = nb_type;		\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;		\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> billing_id = bill_id;		\
	Memcpy_far ((char FAR *)(&(((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit)), (char FAR *)(p_nb), nb_sz);\
	ns_int_ctx.p__offset = &(((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit) + nb_sz;	\
	ns_int_ctx.p__offset = (uchar FAR *)Round ((long)(ns_int_ctx.p__offset));	\
	((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_recorded_unit = (ushort)((ulong)ns_int_ctx.p__offset - (ulong)ns_int_ctx.p__ss_data);	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset;	\
	ns_int_ctx.p__offset = ns_int_ctx.p__start

#endif

#endif	/* end of AOC service supported} */

#if NS_SS_CUG == ON		/* Closed User Group SS supported{ */

		/*
		   Store_ns_cug_call : store ARGUMENT of CUGCallOperation operation :

				INPUT :
					- outg_access_rq = outgoingAccessRequest (TRUE/FALSE or 0xFF if not present),
					- index = cUgIndex ((0..32767) or 0xFFFF if not present).
		*/

#define Store_ns_cug_call(outg_access_rq, index)		\
			((struct ns_cug_call_arg FAR *)ns_int_ctx.p__val) -> out_access_rq = outg_access_rq;	\
			((struct ns_cug_call_arg FAR *)ns_int_ctx.p__val) -> cug_index = index;					\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_cug_call_arg)

#endif /* end of "Closed User Group SS supported"} */

		/*
		   Store_ns_qsi_tsp_extension : store list of octets to be copied transparently into SPDU
				may be used for :
					- PARAMETER of "Unspecified" error
					- RESULT of ActivateDiversionQ operation
					- RESULT of DeactivateDiversionQ operation
					- RESULT of CheckRestriction operation
					- RESULT of CallRerouting operation
					- ARGUMENT of CfnrDivertedLegFailed operation
					- ARGUMENT of CallTransferIdentify operation
					- ARGUMENT of CallTransferAbandon operation
					- RESULT of CallTransferInitiate operation
					- RESULT of CallTransferSetup operation
					- RESULT of PathReplaceSetup and PathReplaceRetain operations
					- ARGUMENT and RESULT of CallOfferRequest operation
					- RESULT of doNotDisturbDeactivateQ operation
					- ARGUMENT and RESULT of doNotDisturbOvrExecuteQ operation
					- ARGUMENT and RESULT of CcPathReserve operation
					- ARGUMENT of CcRingout, CcSuspend and CcResume operations

				INPUT :
					- ext_sz = size of "extension" string,
					- p_ext = address of "extension" string.
		*/

#define Store_ns_qsi_tsp_extension(ext_sz, p_ext)		\
	((struct ns_qsi_transparent_extension FAR *)ns_int_ctx.p__val) -> size = ext_sz;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_transparent_extension FAR *)ns_int_ctx.p__val) -> first_oct);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);			\
	ns_int_ctx.p__val += ext_sz

#if NS_SS_NAME_IDENT == ON		/* Name Identification SS supported{ */

		/*
		   Store_ns_qsi_name_ident : store ARGUMENT of all operations for Name Identification SS :
									 CallingName, CalledName, ConnectedName, BusyName

				INPUT :
					- name_t = Type of Name (namePresentationAllowedSimple .. nameNotAvailable),
					- name_char = CharacterSet inside Name or meaningless,
					- name_size = size of nameData string inside Name,
					- p_name = pointer to nameData string inside Name,
					- ext_size = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_name_ident(name_t, name_char, name_size, p_name, ext_size, p_ext)		\
	((struct ns_qsi_name_ident_arg FAR *)ns_int_ctx.p__val) -> name_type = name_t;			\
	((struct ns_qsi_name_ident_arg FAR *)ns_int_ctx.p__val) -> name_character = name_char;	\
	((struct ns_qsi_name_ident_arg FAR *)ns_int_ctx.p__val) -> name_sz = name_size;			\
	((struct ns_qsi_name_ident_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_size;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_name_ident_arg FAR *)ns_int_ctx.p__val) -> first_str);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_name), name_size);			\
	ns_int_ctx.p__val += name_size;															\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_size);			\
	ns_int_ctx.p__val += ext_size														

#endif /* end of "Name Identification SS supported"} */

#if NS_SS_DIVERSION == ON		/* Diversion SS supported{ */

		/*
		   Store_ns_div_activation : store ARGUMENT of ActivationDiversion operation :

				INPUT :
					- proc = procedure : ENUMERATED {0, 1, 2},
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- f_party_nb_t = type of PartyNumber inside forwardedToAddress,
					- f_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside forwardedToAddress),
					- f_nb_sz = size of NumberDigits string in PartyNumber inside forwardedToAddress,
					- p_f_nb = address of PartyNumber string inside forwardedToAddress,
					- f_sa_t = type of PartySubaddress or 255 if absent inside forwardedToAddress,
					- f_sa_odd_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside forwardedToAddress),
					- f_sa_sz = size of PartySubaddress string inside forwardedToAddress,
					- p_f_sa = address of PartySubaddress string inside forwardedToAddress,
					- s_u_nr_t = type of servedUserNr (individualNumber, allNumbers),
					- s_u_party_nb_t = type of PartyNumber inside servedUserNr,
					- s_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr),
					- s_u_nb_sz = size of NumberDigits string in PartyNumber inside servedUserNr,
					- p_s_u_nb = address of PartyNumber string inside servedUserNr.
		*/

#define Store_ns_div_activation(proc, srv, f_party_nb_t, f_t_of_nb, f_nb_sz, p_f_nb, f_sa_t, f_sa_odd_c, f_sa_sz, p_f_sa, s_u_nr_t, s_u_party_nb_t, s_u_t_of_nb, s_u_nb_sz, p_s_u_nb)\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> procedure = proc;						\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> basic_service = srv;					\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> forw_party_nb_type = f_party_nb_t;		\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> forw_type_of_nb = f_t_of_nb;			\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> forw_nb_digits_size = f_nb_sz;			\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> forw_sub_add_type = f_sa_t;			\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> forw_sub_add_odd_count = f_sa_odd_c;	\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> forw_sub_address_size = f_sa_sz;		\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> served_user_nr_type = s_u_nr_t;		\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> srv_u_party_nb_type = s_u_party_nb_t;	\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> srv_u_type_of_nb = s_u_t_of_nb;		\
	((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> srv_u_nb_digits_size = s_u_nb_sz;		\
	Memcpy_far ((char FAR *)(&(((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit)), (char FAR *)(p_f_nb), f_nb_sz);\
	ns_int_ctx.p__val = &(((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit) + f_nb_sz;	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_f_sa), f_sa_sz);							\
	ns_int_ctx.p__val += f_sa_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_s_u_nb), s_u_nb_sz);						\
	ns_int_ctx.p__val += s_u_nb_sz

		/*
		   Store_ns_div_deactivation : store ARGUMENT of DeactivationDiversion operation :

				INPUT :
					- proc = procedure : ENUMERATED {0, 1, 2},
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- s_u_nr_t = type of servedUserNr (individualNumber, allNumbers),
					- s_u_party_nb_t = type of PartyNumber inside servedUserNr,
					- s_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr),
					- s_u_nb_sz = size of NumberDigits string in PartyNumber inside servedUserNr,
					- p_s_u_nb = address of PartyNumber string inside servedUserNr.
		*/

#define Store_ns_div_deactivation(proc, srv, s_u_nr_t, s_u_party_nb_t, s_u_t_of_nb, s_u_nb_sz, p_s_u_nb)		\
	((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> procedure = proc;						\
	((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> basic_service = srv;						\
	((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> served_user_nr_type = s_u_nr_t;			\
	((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> srv_u_party_nb_type = s_u_party_nb_t;	\
	((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> srv_u_type_of_nb = s_u_t_of_nb;			\
	((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> srv_u_nb_digits_size = s_u_nb_sz;		\
	Memcpy_far ((char FAR *)(&(((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit)), (char FAR *)(p_s_u_nb), s_u_nb_sz);\
	ns_int_ctx.p__val = &(((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit) + s_u_nb_sz

	/* ActivationStatusNotificationDiv operation ARGUMENT : same as in ActivationDiversion operation */

#define Store_ns_div_act_stat_notif			Store_ns_div_activation

	/* DeactivationStatusNotificationDiv operation ARGUMENT : same as in DeactivationDiversion operation */

#define Store_ns_div_dea_stat_notif			Store_ns_div_deactivation

#define Store_ns_div_interog_arg			Store_ns_div_deactivation

		/*
			RESULT of InterrogationDiversion operation : it is a list of IntResult instances.

			Store_ns_div_int_result : store 1 instance of IntResult inside RESULT 

				INPUT :
					- proc = procedure : ENUMERATED {0, 1, 2},
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- f_party_nb_t = type of PartyNumber inside forwardedToAddress,
					- f_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside forwardedToAddress),
					- f_nb_sz = size of NumberDigits string in PartyNumber inside forwardedToAddress,
					- p_f_nb = address of PartyNumber string inside forwardedToAddress,
					- f_sa_t = type of PartySubaddress or 255 if absent inside forwardedToAddress,
					- f_sa_odd_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside forwardedToAddress),
					- f_sa_sz = size of PartySubaddress string inside forwardedToAddress,
					- p_f_sa = address of PartySubaddress string inside forwardedToAddress,
					- s_u_nr_t = type of servedUserNr (individualNumber, allNumbers),
					- s_u_party_nb_t = type of PartyNumber inside servedUserNr,
					- s_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr),
					- s_u_nb_sz = size of NumberDigits string in PartyNumber inside servedUserNr,
					- p_s_u_nb = address of PartyNumber string inside servedUserNr.
		*/

#define Store_ns_div_int_result(proc, srv, f_party_nb_t, f_t_of_nb, f_nb_sz, p_f_nb, f_sa_t, f_sa_odd_c, f_sa_sz, p_f_sa, s_u_nr_t, s_u_party_nb_t, s_u_t_of_nb, s_u_nb_sz, p_s_u_nb)\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> procedure = proc;						\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> basic_service = srv;					\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> forw_party_nb_type = f_party_nb_t;		\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> forw_type_of_nb = f_t_of_nb;			\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> forw_nb_digits_size = f_nb_sz;			\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> forw_sub_add_type = f_sa_t;				\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> forw_sub_add_odd_count = f_sa_odd_c;	\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> forw_sub_address_size = f_sa_sz;		\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> served_user_nr_type = s_u_nr_t;			\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> srv_u_party_nb_type = s_u_party_nb_t;	\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> srv_u_type_of_nb = s_u_t_of_nb;			\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> srv_u_nb_digits_size = s_u_nb_sz;		\
	ns_int_ctx.p__offset = &(((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> first_nb_digit);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_s_u_nb), s_u_nb_sz);		\
	ns_int_ctx.p__offset += s_u_nb_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_f_nb), f_nb_sz);			\
	ns_int_ctx.p__offset += f_nb_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_f_sa), f_sa_sz);			\
	ns_int_ctx.p__offset += f_sa_sz;														\
	ns_int_ctx.p__offset = (uchar FAR *)Round ((long)(ns_int_ctx.p__offset))

		/*
		   Set_ns_last_div_interog_res : store end of InterrogationDiversion RESULT :
				It must be called after last instance in list.

		   Set_ns_next_div_interog_res : it must be called before storing next instance of
				IntResult in InterrogationDiversion RESULT.
		*/

#define Set_ns_last_div_interog_res()		\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> next_int_result = OFFSET_NIL;	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset;														 	\
	ns_int_ctx.p__offset = ns_int_ctx.p__start

#define Set_ns_next_div_interog_res()		\
	((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> next_int_result = (ushort)((ulong)ns_int_ctx.p__offset - (ulong)ns_int_ctx.p__ss_data);	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset

		/*
			RESULT of InterrogateServedUserNumbers operation : it is a list of PartyNumber instances.

			Store_ns_div_interog_s_u_nb : store 1 instance of PartyNumber inside RESULT

				INPUT :
					- party_nb_t = type of PartyNumber,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of NumberDigits string in PartyNumber,
					- p_nb = address of PartyNumber string.
		*/

#define Store_ns_div_interog_s_u_nb(party_nb_t, t_of_nb, nb_sz, p_nb)	\
	((struct ns_interog_s_u_nb_div_res FAR *)ns_int_ctx.p__val) -> party_nb_type = party_nb_t;	\
	((struct ns_interog_s_u_nb_div_res FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_interog_s_u_nb_div_res FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;		\
	ns_int_ctx.p__offset = &(((struct ns_interog_s_u_nb_div_res FAR *)ns_int_ctx.p__val) -> first_nb_digit);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_nb), nb_sz);					\
	ns_int_ctx.p__offset += nb_sz;																\
	ns_int_ctx.p__offset = (uchar FAR *)Round ((long)(ns_int_ctx.p__offset))

		/*
		   Set_ns_last_div_interog_s_u_nb : store end of InterrogateServedUserNumbers RESULT :
				It must be called after last instance in list.

		   Set_ns_next_div_interog_s_u_nb : it must be called before storing next instance of
				PartyNumber in InterrogateServedUserNumbers RESULT.
		*/

#define Set_ns_last_div_interog_s_u_nb()		\
	((struct ns_interog_s_u_nb_div_res FAR *)ns_int_ctx.p__val) -> next_party_nb = OFFSET_NIL;	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset;													\
	ns_int_ctx.p__offset = ns_int_ctx.p__start

#define Set_ns_next_div_interog_s_u_nb()		\
	((struct ns_interog_s_u_nb_div_res FAR *)ns_int_ctx.p__val) -> next_party_nb = (ushort)((ulong)ns_int_ctx.p__offset - (ulong)ns_int_ctx.p__ss_data);	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset

		/*
		   store ARGUMENT of DiversionInformation operation : 3 Macros. ALL 3 MUST BE CALLED.

		   - Store_ns_div_info_1
				INPUT :
					- reason_ = diversion reason : ENUMERATED {0, 1, .. , 5},
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- srv_u_sa_t = type of PartySubaddress or 255 if absent (inside servedUserSubaddress),
					- srv_u_sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside servedUserSubaddress),
					- calling_a_pres_t = type of PresentedAddressScreened inside callingAddress or 255 if absent,
					- calling_a_scr_ind = ScreeningIndicator inside callingAddress : ENUMERATED {0, 1, 2, 3},
					- calling_party_nb_t = type of PartyNumber inside callingAddress,
					- calling_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside callingAddress),
					- calling_sa_t = type of PartySubaddress or 255 if absent (inside callingAddress),
					- calling_sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside callingAddress).

		   - Store_ns_div_info_2
				INPUT :
					- orig_pres_nb_t = type of PresentedNumberUnscreened inside originalCalledNr or 255 if absent,
					- orig_party_nb_t = type of PartyNumber inside originalCalledNr,
					- orig_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originalCalledNr),
					- last_pres_nb_t = type of PresentedNumberUnscreened inside lastDivertingNr or 255 if absent,
					- last_party_nb_t = type of PartyNumber inside lastDivertingNr,
					- last_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside lastDivertingNr),
					- last_div_reason = last diverting reason : ENUMERATED {0, 1, .. , 5} or 255 if absent.

		   - Store_ns_div_info_3 : It must be called after both Macros above.
				INPUT :
					- srv_u_sa_sz = size of PartySubaddress string inside servedUserSubaddress,
					- calling_nb_sz = size of PartyNumber string inside callingAddress,
					- calling_sa_sz = size of PartySubaddress string inside callingAddress,
					- orig_nb_sz = size of PartyNumber string inside originalCalledNr,
					- last_nb_sz = size of PartyNumber string inside lastDivertingNr,
					- user_info_sz = size of Q931 User Info IE string,
					- p_srv_u_sa = address of PartySubaddress string inside servedUserSubaddress,
					- p_calling_nb = address of PartyNumber string inside callingAddress,
					- p_calling_sa = address of PartySubaddress string inside callingAddress,
					- p_orig_nb = address of PartyNumber string inside originalCalledNr,
					- p_last_nb = address of PartyNumber string inside lastDivertingNr,
					- p_user_info = address of Q931 User Info IE string.
		*/

#define Store_ns_div_info_1(reason_, srv, srv_u_sa_t, srv_u_sa_odd_c, calling_a_pres_t, calling_a_scr_ind, calling_party_nb_t, calling_t_of_nb, calling_sa_t, calling_sa_odd_c)\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> reason = reason_;							\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> basic_service = srv;						\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_sub_add_type = srv_u_sa_t;			\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_sub_add_odd_count = srv_u_sa_odd_c;	\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_a_presented_type = calling_a_pres_t;\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_a_screening_ind = calling_a_scr_ind;\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_party_nb_type = calling_party_nb_t;	\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_type_of_nb = calling_t_of_nb;		\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_add_type = calling_sa_t;		\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_add_odd_count = calling_sa_odd_c

#define Store_ns_div_info_2(orig_pres_nb_t, orig_party_nb_t, orig_t_of_nb, last_pres_nb_t, last_party_nb_t, last_t_of_nb,last_div_reason)\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> orig_presented_nb_type = orig_pres_nb_t;	\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> orig_party_nb_type = orig_party_nb_t;		\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> orig_type_of_nb = orig_t_of_nb;				\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> last_presented_nb_type = last_pres_nb_t;	\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> last_party_nb_type = last_party_nb_t;		\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> last_type_of_nb = last_t_of_nb;				\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> last_divert_reason = last_div_reason

#define Store_ns_div_info_3(srv_u_sa_sz, calling_nb_sz, calling_sa_sz, orig_nb_sz, last_nb_sz, user_info_sz, p_srv_u_sa, p_calling_nb, p_calling_sa, p_orig_nb, p_last_nb, p_user_info)\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_sub_address_sz = srv_u_sa_sz;			\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_number_digits_sz = calling_nb_sz;	\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_address_sz = calling_sa_sz;		\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> orig_number_digits_sz = orig_nb_sz;			\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> last_number_digits_sz = last_nb_sz;			\
	((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> q931_user_info_sz = user_info_sz;			\
	ns_int_ctx.p__val = &(((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_srv_u_sa), srv_u_sa_sz);					\
	ns_int_ctx.p__val += srv_u_sa_sz;	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_calling_nb), calling_nb_sz);				\
	ns_int_ctx.p__val += calling_nb_sz;	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_calling_sa), calling_sa_sz);				\
	ns_int_ctx.p__val += calling_sa_sz;	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_orig_nb), orig_nb_sz);						\
	ns_int_ctx.p__val += orig_nb_sz;	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_last_nb), last_nb_sz);						\
	ns_int_ctx.p__val += last_nb_sz;	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_user_info), user_info_sz);					\
	ns_int_ctx.p__val += user_info_sz

		/*
		   Store_ns_div_deflection : store ARGUMENT of CallDeflection operation :

				INPUT :
					- pres_allow = presentationAllowedDivertedToUser : TRUE/FALSE or 255 if absent,
					- party_nb_t = type of PartyNumber inside deflectionAddress,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside deflectionAddress),
					- nb_sz = size of NumberDigits string in PartyNumber inside deflectionAddress,
					- sa_t = type of PartySubaddress or 255 if absent inside deflectionAddress,
					- sa_odd_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside deflectionAddress),
					- sa_sz = size of PartySubaddress string inside deflectionAddress,
					- p_nb = address of PartyNumber string inside deflectionAddress,
					- p_sa = address of PartySubaddress string inside deflectionAddress.
		*/

#define Store_ns_div_deflection(pres_allow, party_nb_t, t_of_nb, nb_sz, sa_t, sa_odd_c, sa_sz, p_nb, p_sa)	\
	((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> pres_allow_div_to_user = pres_allow;			\
	((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_nb_t;					\
	((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;						\
	((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;						\
	((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> sub_add_type = sa_t;							\
	((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> sub_add_odd_count = sa_odd_c;				\
	((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> sub_address_size = sa_sz;					\
	ns_int_ctx.p__val = &(((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);								\
	ns_int_ctx.p__val += nb_sz;																				\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);								\
	ns_int_ctx.p__val += sa_sz

		/*
		   store ARGUMENT of CallRerouteing operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_div_reroute_1
				INPUT :
					- reas = rerouteing reason : ENUMERATED {0, 1, .. , 5},
					- count = rerouteing counter : INTEGER (1..5),
					- called_p_nb_t = type of PartyNumber inside calledAddress,
					- called_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside calledAddress),
					- called_sa_t = type of PartySubaddress or 255 if absent (inside calledAddress),
					- called_sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside calledAddress),
					- subs = subscriptionOption : ENUMERATED {0, 1, 2} or 255 if absent,
					- last_pres_nb_t = type of PresentedNumberUnscreened inside lastRerouteingNr,
					- last_p_nb_t = type of PartyNumber inside lastRerouteingNr,
					- last_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside lastRerouteingNr),
					- calling_sa_t = type of PartySubaddress or 255 if absent (inside callingPartySubaddress),
					- calling_sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside callingPartySubaddress).

		   - Store_ns_div_reroute_2 : It must be called after Macro above.
				INPUT :
					- called_nb_sz = size of PartyNumber string inside calledAddress,
					- called_sa_sz = size of PartySubaddress string inside calledAddress,
					- q931_ie_sz_ = size of Q931 IE string,
					- last_nb_sz = size of PartyNumber string inside lastRerouteingNr,
					- calling_sa_sz = size of PartySubaddress string inside callingPartySubaddress,
					- p_called_nb = address of PartyNumber string inside calledAddress,
					- p_called_sa = address of PartySubaddress string inside calledAddress,
					- p_q931_ie = address of Q931 IE string,
					- p_last_nb = address of PartyNumber string inside lastRerouteingNr,
					- p_calling_sa = address of PartySubaddress string inside callingPartySubaddress.
		*/

#define Store_ns_div_reroute_1(reas, count, called_p_nb_t, called_t_of_nb, called_sa_t, called_sa_odd_c, subs, last_pres_nb_t, last_p_nb_t, last_t_of_nb, calling_sa_t, calling_sa_odd_c)	\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> reason = reas;								\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> counter = count;								\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> called_party_nb_type = called_p_nb_t;		\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> called_type_of_nb = called_t_of_nb;			\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> called_sub_add_type = called_sa_t;			\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> called_sub_add_odd_count = called_sa_odd_c;	\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> subscription_option = subs;					\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> last_presented_nb_type = last_pres_nb_t;		\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> last_party_nb_type = last_p_nb_t;			\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> last_type_of_nb = last_t_of_nb;				\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_add_type = calling_sa_t;			\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_add_odd_count = calling_sa_odd_c

#define Store_ns_div_reroute_2(called_nb_sz, called_sa_sz, q931_ie_sz_, last_nb_sz, calling_sa_sz, p_called_nb, p_called_sa, p_q931_ie, p_last_nb, p_calling_sa)	\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> called_number_digits_sz = called_nb_sz;	\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> called_sub_address_sz = called_sa_sz;	\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> q931_ie_sz = q931_ie_sz_;				\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> last_number_digits_sz = last_nb_sz;		\
	((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_address_sz = calling_sa_sz;	\
	ns_int_ctx.p__val = &(((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_called_nb), called_nb_sz);				\
	ns_int_ctx.p__val += called_nb_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_called_sa), called_sa_sz);				\
	ns_int_ctx.p__val += called_sa_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_q931_ie), q931_ie_sz_);					\
	ns_int_ctx.p__val += q931_ie_sz_;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_last_nb), last_nb_sz);					\
	ns_int_ctx.p__val += last_nb_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_calling_sa), calling_sa_sz);			\
	ns_int_ctx.p__val += calling_sa_sz

		/*
		   Store_ns_div_info_leg_1 : store ARGUMENT of DivertingLegInformation1 operation

				INPUT :
					- reas = diversion reason : ENUMERATED {0, 1, .. , 5},
					- subs = subscriptionOption : ENUMERATED {0, 1, 2},
					- pres_nb_t = type of PresentedNumberUnscreened inside divertedToNumber or 255 if absent,
					- party_nb_t = type of PartyNumber inside divertedToNumber,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertedToNumber),
					- nb_sz = size of NumberDigits string in PartyNumber inside divertedToNumber,
					- p_nb = address of PartyNumber string inside divertedToNumber.
		*/

#define Store_ns_div_info_leg_1(reas, subs, pres_nb_t, party_nb_t, t_of_nb, nb_sz, p_nb)		\
	((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> reason = reas;					\
	((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> subscription_option = subs;		\
	((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> presented_nb_type = pres_nb_t;	\
	((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_nb_t;		\
	((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;			\
	((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> number_digits_sz = nb_sz;		\
	ns_int_ctx.p__val = &(((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);					\
	ns_int_ctx.p__val += nb_sz

		/*
		   Store_ns_div_info_leg_2 : store ARGUMENT of DivertingLegInformation2 operation

				INPUT :
					- count = diversion counter : INTEGER (1..5),
					- reas = diversion reason : ENUMERATED {0, 1, .. , 5},
					- d_pres_nb_t = type of PresentedNumberUnscreened inside divertingNr or 255 if absent,
					- d_p_nb_t = type of PartyNumber inside divertingNr,
					- d_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertingNr),
					- d_nb_sz = size of NumberDigits string in PartyNumber inside divertingNr,
					- o_pres_nb_t = type of PresentedNumberUnscreened inside originalCalledNr or 255 if absent,
					- o_p_nb_t = type of PartyNumber inside originalCalledNr,
					- o_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originalCalledNr),
					- o_nb_sz = size of NumberDigits string in PartyNumber inside originalCalledNr,
					- p_d_nb = address of divertingNr string,
					- p_o_nb = address of originalCalledNr string.
		*/

#define Store_ns_div_info_leg_2(count, reas, d_pres_nb_t, d_p_nb_t, d_t_of_nb, d_nb_sz, o_pres_nb_t, o_p_nb_t, o_t_of_nb, o_nb_sz, p_d_nb, p_o_nb)	\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> counter = count;							\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> reason = reas;							\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_presented_nb_type = d_pres_nb_t;		\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_party_nb_type = d_p_nb_t;			\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_type_of_nb = d_t_of_nb;				\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_number_sz = d_nb_sz;					\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_presented_nb_type = o_pres_nb_t;	\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_party_nb_type = o_p_nb_t;			\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_type_of_nb = o_t_of_nb;				\
	((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_number_sz = o_nb_sz;				\
	ns_int_ctx.p__val = &(((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_d_nb), d_nb_sz);						\
	ns_int_ctx.p__val += d_nb_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_o_nb), o_nb_sz);						\
	ns_int_ctx.p__val += o_nb_sz

		/*
		   Store_ns_div_info_leg_3 : store ARGUMENT of DivertingLegInformation3 operation

				INPUT : pres_allow = presentationAllowedIndicator : TRUE/FALSE.
		*/

#define Store_ns_div_info_leg_3(pres_allow)		\
			((struct ns_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> pres_allow_ind = pres_allow;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_div_leg_info_3_arg)

			/*** Q-SIG specific operations ***/

		/*
		   store ARGUMENT of ActivateDiversionQ operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_div_activate_1
				INPUT :
					- proc = procedure : ENUMERATED {0, 1, 2},
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- party_nb_t = type of PartyNumber inside divertedToAddress,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertedToAddress),
					- sa_t = type of PartySubaddress or 255 if absent inside divertedToAddress,
					- sa_odd_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside divertedToAddress),
					- s_u_party_nb_t = type of PartyNumber inside servedUserNr,
					- s_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr),
					- a_u_party_nb_t = type of PartyNumber inside activatingUserNr,
					- a_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside activatingUserNr).

		   - Store_ns_qsi_div_activate_2 : It must be called after Macro above.
				INPUT :
					- nb_sz = size of NumberDigits string in PartyNumber inside divertedToAddress,
					- p_nb = address of PartyNumber string inside divertedToAddress,
					- sa_sz = size of PartySubaddress string inside divertedToAddress,
					- p_sa = address of PartySubaddress string inside divertedToAddress,
					- s_u_nb_sz = size of NumberDigits string in PartyNumber inside servedUserNr,
					- p_s_u_nb = address of PartyNumber string inside servedUserNr,
					- a_u_nb_sz = size of NumberDigits string in PartyNumber inside activatingUserNr,
					- p_a_u_nb = address of PartyNumber string inside activatingUserNr,
					- ext_sz = size of extension string,
					- p_ext = address of extension string.
		*/

#define Store_ns_qsi_div_activate_1(proc, srv, party_nb_t, t_of_nb, sa_t, sa_odd_c, s_u_party_nb_t, s_u_t_of_nb, a_u_party_nb_t, a_u_t_of_nb)\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> procedure = proc;						\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> basic_service = srv;					\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> div_party_nb_type = party_nb_t;		\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> div_type_of_nb = t_of_nb;				\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> div_sub_add_type = sa_t;				\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> div_sub_add_odd_count = sa_odd_c;		\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_party_nb_type = s_u_party_nb_t;	\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_type_of_nb = s_u_t_of_nb;		\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> activ_u_party_nb_type = a_u_party_nb_t;\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> activ_u_type_of_nb = a_u_t_of_nb

#define Store_ns_qsi_div_activate_2(nb_sz, p_nb, sa_sz, p_sa, s_u_nb_sz, p_s_u_nb, a_u_nb_sz, p_a_u_nb, ext_sz, p_ext)\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> div_nb_digits_size = nb_sz;			\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> div_sub_address_size = sa_sz;			\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_nb_digits_size = s_u_nb_sz;		\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> activ_u_nb_digits_size = a_u_nb_sz;	\
	((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;				\
	ns_int_ctx.p__val = &(((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);							\
	ns_int_ctx.p__val += nb_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);							\
	ns_int_ctx.p__val += sa_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_s_u_nb), s_u_nb_sz);					\
	ns_int_ctx.p__val += s_u_nb_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_a_u_nb), a_u_nb_sz);					\
	ns_int_ctx.p__val += a_u_nb_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);							\
	ns_int_ctx.p__val += ext_sz																		

		/*
		   Store_ns_qsi_div_deactivate : store ARGUMENT of DeactivateDiversionQ operation  

				INPUT :
					- proc = procedure : ENUMERATED {0, 1, 2},
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- s_u_party_nb_t = type of PartyNumber inside servedUserNr,
					- s_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr),
					- d_u_party_nb_t = type of PartyNumber inside deactivatingUserNr,
					- d_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside deactivatingUserNr).
					- s_u_nb_sz = size of NumberDigits string in PartyNumber inside servedUserNr,
					- p_s_u_nb = address of PartyNumber string inside servedUserNr,
					- d_u_nb_sz = size of NumberDigits string in PartyNumber inside deactivatingUserNr,
					- p_d_u_nb = address of PartyNumber string inside deactivatingUserNr,
					- ext_sz = size of extension string,
					- p_ext = address of extension string.
		*/

#define Store_ns_qsi_div_deactivate(proc, srv, s_u_party_nb_t, s_u_t_of_nb, d_u_party_nb_t, d_u_t_of_nb, s_u_nb_sz, p_s_u_nb, d_u_nb_sz, p_d_u_nb, ext_sz, p_ext)\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> procedure = proc;						\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> basic_service = srv;					\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_party_nb_type = s_u_party_nb_t;	\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_type_of_nb = s_u_t_of_nb;			\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> dea_u_party_nb_type = d_u_party_nb_t;	\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> dea_u_type_of_nb = d_u_t_of_nb;			\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_nb_digits_size = s_u_nb_sz;		\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> dea_u_nb_digits_size = d_u_nb_sz;		\
	((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;				\
	ns_int_ctx.p__val = &(((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_s_u_nb), s_u_nb_sz);				\
	ns_int_ctx.p__val += s_u_nb_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_d_u_nb), d_u_nb_sz);				\
	ns_int_ctx.p__val += d_u_nb_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);						\
	ns_int_ctx.p__val += ext_sz																		

	/* InterrogateDiversionQ operation ARGUMENT : same as in DeactivateDiversionQ operation */

		/*
			RESULT of InterrogateDiversionQ operation : it is a list of IntResult instances.

			Store_ns_qsi_div_int_result : store 1 instance of IntResult inside RESULT

				INPUT :
					- s_u_p_nb_t = type of PartyNumber inside servedUserNr,
					- s_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr),
					- s_u_nb_sz = size of NumberDigits string in PartyNumber inside servedUserNr,
					- p_s_u_nb = address of PartyNumber string inside servedUserNr,
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- proc = procedure : ENUMERATED {0, 1, 2},
					- p_nb_t = type of PartyNumber inside divertedToAddress,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertedToAddress),
					- nb_sz = size of NumberDigits string in PartyNumber inside divertedToAddress,
					- p_nb = address of PartyNumber string inside divertedToAddress,
					- sa_t = type of PartySubaddress or 255 if absent inside divertedToAddress,
					- sa_odd_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside divertedToAddress),
					- sa_sz = size of PartySubaddress string inside divertedToAddress,
					- p_sa = address of PartySubaddress string inside divertedToAddress,
					- remote = remoteEnabled,
					- ext_sz = size of "extension" string,
					- p_ext = address of "extension" string. 
		*/

#define Store_ns_qsi_div_int_result(s_u_p_nb_t, s_u_t_of_nb, s_u_nb_sz, p_s_u_nb, srv, proc, p_nb_t, t_of_nb, nb_sz, p_nb, sa_t, sa_odd_c, sa_sz, p_sa, remote, ext_sz, p_ext)\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> srv_u_party_nb_type = s_u_p_nb_t;	\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> srv_u_type_of_nb = s_u_t_of_nb;	\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> srv_u_nb_digits_size = s_u_nb_sz;	\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> basic_service = srv;				\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> procedure = proc;					\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> div_party_nb_type = p_nb_t;		\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> div_type_of_nb = t_of_nb;			\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> div_nb_digits_size = nb_sz;		\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> div_sub_add_type = sa_t;			\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> div_sub_add_odd_count = sa_odd_c;	\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> div_sub_address_size = sa_sz;		\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> remote_enabled = remote;			\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;			\
	ns_int_ctx.p__offset = &(((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_s_u_nb), s_u_nb_sz);	\
	ns_int_ctx.p__offset += s_u_nb_sz;													\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_nb), nb_sz);			\
	ns_int_ctx.p__offset += nb_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_sa), sa_sz);			\
	ns_int_ctx.p__offset += sa_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_ext), ext_sz);		\
	ns_int_ctx.p__offset += ext_sz;														\
	ns_int_ctx.p__offset = (uchar FAR *)Round ((long)(ns_int_ctx.p__offset))

		/*
		   Set_ns_qsi_last_div_inter_res : store end of InterrogateDiversionQ RESULT :
				It must be called after last instance in list.

		   Set_ns_qsi_next_div_inter_res : it must be called before storing next instance of
				IntResult in InterrogateDiversionQ RESULT.
		*/

#define Set_ns_qsi_last_div_inter_res()		\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> next_int_result = OFFSET_NIL;	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset;														 	\
	ns_int_ctx.p__offset = ns_int_ctx.p__start

#define Set_ns_qsi_next_div_inter_res()		\
	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> next_int_result = (ushort)((ulong)ns_int_ctx.p__offset - (ulong)ns_int_ctx.p__ss_data);	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset

		/*
		   Store_ns_qsi_div_chk_rest : store ARGUMENT of CheckRestriction operation

				INPUT :
					- srv = basicService : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38},
					- s_u_party_nb_t = type of PartyNumber inside servedUserNr,
					- s_u_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr),
					- party_nb_t = type of PartyNumber inside divertedToNr,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertedToNr),
					- s_u_nb_sz = size of NumberDigits string in PartyNumber inside servedUserNr,
					- p_s_u_nb = address of PartyNumber string inside servedUserNr,
					- nb_sz = size of NumberDigits string in PartyNumber inside divertedToNr,
					- p_nb = address of PartyNumber string inside divertedToNr,
					- ext_sz = size of extension string,
					- p_ext = address of extension string.
		*/

#define Store_ns_qsi_div_chk_rest(srv, s_u_party_nb_t, s_u_t_of_nb, party_nb_t, t_of_nb, s_u_nb_sz, p_s_u_nb, nb_sz, p_nb, ext_sz, p_ext)\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> basic_service = srv;					\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_party_nb_type = s_u_party_nb_t;	\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_type_of_nb = s_u_t_of_nb;		\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> div_party_nb_type = party_nb_t;		\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> div_type_of_nb = t_of_nb;				\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> srv_u_nb_digits_size = s_u_nb_sz;		\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> div_nb_digits_size = nb_sz;			\
	((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;				\
	ns_int_ctx.p__val = &(((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_s_u_nb), s_u_nb_sz);					\
	ns_int_ctx.p__val += s_u_nb_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);							\
	ns_int_ctx.p__val += nb_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);							\
	ns_int_ctx.p__val += ext_sz

		/*
		   store ARGUMENT of CallRerouting operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_div_rerout_1
				INPUT :
					- reas = rerouting reason : ENUMERATED {0, 1, .. , 5},
					- count = rerouting counter : INTEGER (1..15),
					- p_nb_t = type of PartyNumber inside calledAddress,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside calledAddress),
					- sa_t = type of PartySubaddress or 255 if absent (inside calledAddress),
					- sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside calledAddress),
					- subs = subscriptionOption : ENUMERATED {0, 1, 2},
					- last_pres_t = type of PresentedNumberUnscreened inside lastReroutingNr,
					- last_p_nb_t = type of PartyNumber inside lastReroutingNr,
					- last_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside lastReroutingNr),
					- calling_sa_t = type of PartySubaddress or 255 if absent (inside callingPartySubaddress),
					- calling_sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside callingPartySubaddress),
					- calling_pres_t = type of PresentedNumberScreened inside callingNumber,
					- calling_p_nb_t = type of PartyNumber inside callingNumber,
					- calling_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside callingNumber),
					- calling_scr = ScreeningIndicator or meaningless inside callingNumber : ENUMERATED {0, 1, 2, 3},
					- calling_nm_t = type of Name inside callingName or 255 if absent,
					- calling_ch = characterSet inside callingName or 255 if absent,
					- orig_pres_t = type of PresentedNumberUnscreened inside originalCalledNr,
					- orig_p_nb_t = type of PartyNumber inside originalCalledNr,
					- orig_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originalCalledNr),
					- redir_ch = characterSet inside redirectingName or 255 if absent,
					- orig_ch = characterSet inside originalCalledName or 255 if absent,

		   - Store_ns_qsi_div_rerout_2 : It must be called after Macro above.
				INPUT :
					- nb_sz = size of PartyNumber string inside calledAddress,
					- p_nb = pointer to PartyNumber string inside calledAddress,
					- sa_sz = size of PartySubaddress string inside calledAddress,
					- p_sa = pointer to PartySubaddress string inside calledAddress,
					- ie_sz = size of Q-SIG IE string,
					- p_ie = pointer to Q-SIG IE string,
					- last_sz = size of PartyNumber string inside lastReroutingNr,
					- p_last = pointer to PartyNumber string inside lastReroutingNr,
					- calling_sa_sz = size of PartySubaddress string inside callingPartySubaddress,
					- p_calling_sa = pointer to PartySubaddress string inside callingPartySubaddress,
					- calling_nb_sz = size of PartyNumber string inside callingNumber,
					- p_calling_nb = pointer to PartyNumber string inside callingNumber,
					- nm_sz = size of NameData string inside callingName,
					- p_nm = pointer to NameData string inside callingName,
					- orig_sz = size of PartyNumber string inside originalCalledNr,
					- p_orig = pointer to PartyNumber string inside originalCalledNr,
					- redir_sz = size of NameData string inside redirectingName,
					- p_redir = pointer to NameData string inside redirectingName,
					- orig_nm_sz = size of NameData string inside originalCalledName,
					- p_orig_nm = pointer to NameData string inside originalCalledName,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_div_rerout_1(reas, count, p_nb_t, t_of_nb, sa_t, sa_odd_c, subs, last_pres_t, last_p_nb_t, last_t_of_nb, calling_sa_t, calling_sa_odd_c, calling_pres_t, calling_p_nb_t, calling_t_of_nb, calling_scr, calling_nm_t, calling_ch, orig_pres_t, orig_p_nb_t, orig_t_of_nb, redir_ch, orig_ch)\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> reason = reas;								\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> counter = count;								\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> called_party_nb_type = p_nb_t;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> called_type_of_nb = t_of_nb;					\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> called_sub_add_type = sa_t;					\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> called_sub_add_odd_count = sa_odd_c;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> subscription_option = subs;					\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> last_presented_nb_type = last_pres_t;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> last_party_nb_type = last_p_nb_t;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> last_type_of_nb = last_t_of_nb;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_add_type = calling_sa_t;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_add_odd_count = calling_sa_odd_c;	\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_presented_nb_type = calling_pres_t;	\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_party_nb_type = calling_p_nb_t;		\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_type_of_nb = calling_t_of_nb;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_screening_ind = calling_scr;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_name_type = calling_nm_t;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_name_character = calling_ch;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> orig_presented_nb_type = orig_pres_t;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> orig_party_nb_type = orig_p_nb_t;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> orig_type_of_nb = orig_t_of_nb;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> redir_name_character = redir_ch;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> orig_name_character = orig_ch


#define Store_ns_qsi_div_rerout_2(nb_sz, p_nb, sa_sz, p_sa, ie_sz, p_ie, last_sz, p_last, calling_sa_sz, p_calling_sa, calling_nb_sz, p_calling_nb, nm_sz, p_nm, orig_sz, p_orig, redir_sz, p_redir, orig_nm_sz, p_orig_nm, ext_sz, p_ext)\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> called_number_digits_sz = nb_sz;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> called_sub_address_sz = sa_sz;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> qsig_ie_sz = ie_sz;						\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> last_number_digits_sz = last_sz;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_sub_address_sz = calling_sa_sz;	\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_number_digits_sz = calling_nb_sz;	\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> calling_name_sz = nm_sz;					\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> orig_number_digits_sz = orig_sz;			\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> redir_name_sz = redir_sz;					\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> orig_name_sz = orig_nm_sz;				\
	((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;					\
	ns_int_ctx.p__val = &(((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);								\
	ns_int_ctx.p__val += nb_sz;																				\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);								\
	ns_int_ctx.p__val += sa_sz;																				\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ie), ie_sz);								\
	ns_int_ctx.p__val += ie_sz;																				\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_last), last_sz);							\
	ns_int_ctx.p__val += last_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_calling_sa), calling_sa_sz);				\
	ns_int_ctx.p__val += calling_sa_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_calling_nb), calling_nb_sz);				\
	ns_int_ctx.p__val += calling_nb_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nm), nm_sz);								\
	ns_int_ctx.p__val += nm_sz;																				\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_orig), orig_sz);							\
	ns_int_ctx.p__val += orig_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_redir), redir_sz);							\
	ns_int_ctx.p__val += redir_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_orig_nm), orig_nm_sz);						\
	ns_int_ctx.p__val += orig_nm_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);								\
	ns_int_ctx.p__val += ext_sz

		/*
		   Store_ns_qsi_div_info_leg_1 : store ARGUMENT of DivertingLegInformation1 operation

				INPUT :
					- reas = diversion reason : ENUMERATED {0, 1, .. , 5},
					- subs = subscriptionOption : ENUMERATED {0, 1, 2},
					- pres_nb_t = type of PresentedNumberUnscreened inside divertedToNumber or 255 if absent,
					- party_nb_t = type of PartyNumber inside divertedToNumber,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertedToNumber),
					- nb_sz = size of NumberDigits string in PartyNumber inside divertedToNumber,
					- p_nb = address of PartyNumber string inside divertedToNumber,
					- ext_sz = size of extension string,
					- p_ext = address of extension string.
		*/

#define Store_ns_qsi_div_info_leg_1(reas, subs, pres_nb_t, party_nb_t, t_of_nb, nb_sz, p_nb, ext_sz, p_ext)\
	((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> reason = reas;					\
	((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> subscription_option = subs;		\
	((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> presented_nb_type = pres_nb_t;	\
	((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_nb_t;		\
	((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;			\
	((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> number_digits_sz = nb_sz;		\
	((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;			\
	ns_int_ctx.p__val = &(((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);						\
	ns_int_ctx.p__val += nb_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);						\
	ns_int_ctx.p__val += ext_sz

		/*
		   store ARGUMENT of DivertingLegInformation2 operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_div_leg_2_a
				INPUT :
					- reas = diversion reason : ENUMERATED {0, 1, .. , 5},
					- count = diversion counter : INTEGER (1..15),
					- d_pres_t = type of PresentedNumberUnscreened inside divertingNr or 255 if absent,
					- d_p_nb_t = type of PartyNumber inside divertingNr,
					- d_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertingNr),
					- o_pres_t = type of PresentedNumberUnscreened inside originalCalledNr or 255 if absent,
					- o_p_nb_t = type of PartyNumber inside originalCalledNr,
					- o_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originalCalledNr),
					- redir_ch = characterSet inside redirectingName or 255 if absent,
					- orig_ch = characterSet inside originalCalledName or 255 if absent.

		   - Store_ns_qsi_div_leg_2_b
				INPUT :
					- div_sz = size of divertingNr string,
					- p_div = pointer to divertingNr string,
					- orig_sz = size of originalCalledNr string,
					- p_orig = pointer to originalCalledNr string,
					- redir_sz = size of redirectingName string,
					- p_redir = pointer to redirectingName string,
					- orig_nm_sz = size of originalCalledName string,
					- p_orig_nm = pointer to originalCalledName string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_div_leg_2_a(reas, count, d_pres_t, d_p_nb_t, d_t_of_nb, o_pres_t, o_p_nb_t, o_t_of_nb, redir_ch, orig_ch)\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> counter = count;					\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> reason = reas;					\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_presented_nb_type = d_pres_t;\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_party_nb_type = d_p_nb_t;	\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_type_of_nb = d_t_of_nb;		\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_presented_nb_type = o_pres_t;\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_party_nb_type = o_p_nb_t;	\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_type_of_nb = o_t_of_nb;		\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> redir_name_character = redir_ch;	\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_name_character = orig_ch

#define Store_ns_qsi_div_leg_2_b(div_sz, p_div, orig_sz, p_orig, redir_sz, p_redir, orig_nm_sz, p_orig_nm, ext_sz, p_ext)\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> div_number_sz = div_sz;			\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_number_sz = orig_sz;		\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> redir_name_sz = redir_sz;		\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> orig_name_sz = orig_nm_sz;		\
	((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;			\
	ns_int_ctx.p__val = &(((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> first_str);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_div), div_sz);						\
	ns_int_ctx.p__val += div_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_orig), orig_sz);					\
	ns_int_ctx.p__val += orig_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_redir), redir_sz);					\
	ns_int_ctx.p__val += redir_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_orig_nm), orig_nm_sz);				\
	ns_int_ctx.p__val += orig_nm_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);						\
	ns_int_ctx.p__val += ext_sz

		/*
		   Store_ns_qsi_div_info_leg_3 : store ARGUMENT of DivertingLegInformation3 operation

				INPUT :
					- pres = presentationAllowedIndicator : TRUE/FALSE,
					- redir_char = CharacterSet inside redirectionName,
					- redir_sz = size of NameData string inside redirectionName,
					- p_redir = pointer to NameData string inside redirectionName,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_div_info_leg_3(pres, redir_char, redir_sz, p_redir, ext_sz, p_ext)					\
	((struct ns_qsi_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> pres_allow_ind = pres;				\
	((struct ns_qsi_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> redir_name_character = redir_char;	\
	((struct ns_qsi_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> redir_name_sz = redir_sz;			\
	((struct ns_qsi_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;				\
	ns_int_ctx.p__val = &(((struct ns_qsi_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> first_str);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_redir), redir_sz);						\
	ns_int_ctx.p__val += redir_sz;																		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);							\
	ns_int_ctx.p__val += ext_sz

#endif /* end of "Diversion SS supported"} */

#if NS_SS_EXPL_CHAN_RESERVATION == ON	/* Explicit Channel Reservation function supported{ */

		/*
		   Store_ns_chan_res_create_arg : store ARGUMENT of ExplicitReservationCreationControl operation :

				INPUT :
					- control = controlOption : ENUMERATED {0, 1, 2}.
		*/

#define Store_ns_chan_res_create_arg(control)		\
	((struct ns_exp_ch_res_create_arg FAR *)ns_int_ctx.p__val) -> control_option = control;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_exp_ch_res_create_arg)

		/*
		   Store_ns_chan_res_create_res : store RESULT of ExplicitReservationCreationControl operation,
		   Store_ns_chan_res_manage_arg : store ARGUMENT of ExplicitReservationManagement operation,
		   Store_ns_chan_res_cancel_arg : store ARGUMENT of ExplicitReservationCancel operation :

				INPUT :
					- indicator = ReservationIndicator : INTEGER (-128..127).
		*/

#define Store_ns_chan_res_create_res(indicator)		\
	((struct ns_exp_ch_res_all_op FAR *)ns_int_ctx.p__val) -> reservation_ind = indicator;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_exp_ch_res_all_op)

#define Store_ns_chan_res_manage_arg		Store_ns_chan_res_create_res
#define Store_ns_chan_res_cancel_arg		Store_ns_chan_res_create_res

#endif /* end of "Explicit Channel Reservation function supported"} */

#if NS_SS_CONFERENCE == ON	/* Conference call SS supported{ */

		/*
		   Store_ns_conf_begin_arg : store ARGUMENT of BeginCONF operation :

				INPUT :
					- conf_sz = conf_size : INTEGER (0..127).
		*/

#define Store_ns_conf_begin_arg(conf_sz)		\
	((struct ns_conf_begin_arg FAR *)ns_int_ctx.p__val) -> conf_size = conf_sz;		\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_conf_begin_arg)

		/*
		   Store_ns_conf_begin_res : store RESULT of BeginCONF operation
		   Store_ns_conf_split_arg : store ARGUMENT of SplitCONF operation :

				INPUT :
					- cf_id = ConferenceId : INTEGER (0..127),
					- p_id = PartyId : INTEGER (0..127) or 255 if absent
						(may be absent only in BeginCONF RESULT).
		*/

#define Store_ns_conf_begin_res(cf_id, p_id)		\
	((struct ns_conf_begin_res FAR *)ns_int_ctx.p__val) -> conf_id = cf_id;		\
	((struct ns_conf_begin_res FAR *)ns_int_ctx.p__val) -> party_id = p_id;		\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_conf_begin_res)

#define Store_ns_conf_split_arg		Store_ns_conf_begin_res

		/*
		   Store_ns_conf_add_arg : store ARGUMENT of AddCONF operation :

				INPUT :
					- cf_id = ConferenceId : INTEGER (0..127).
		*/

#define Store_ns_conf_add_arg(cf_id)		\
	((struct ns_conf_add_arg FAR *)ns_int_ctx.p__val) -> conf_id = cf_id;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_conf_add_arg)

		/*
		   Store_ns_conf_add_res : store RESULT of AddCONF operation
		   Store_ns_conf_other_op_arg : store ARGUMENT of DropCONF, IsolateCONF,
										ReattachCONF, PartyDISC
										or IdentifyConferee operations :

				INPUT :
					- p_id = PartyId : INTEGER (0..127).
		*/

#define Store_ns_conf_add_res	Store_ns_conf_other_op_arg

#define Store_ns_conf_other_op_arg(p_id)		\
	((struct ns_conf_add_res_or_other_arg FAR *)ns_int_ctx.p__val) -> party_id = p_id;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_conf_add_res_or_other_arg)

#endif /* end of Conference call SS supported} */

#if NS_SS_USER_USER_EXP == ON	/* explicit requests for User-to-User Signalling SS supported{ */

		/*
		   Store_ns_uus_rq_arg : store ARGUMENT of UserUserService and UUSRequest operations :

				INPUT :
					- serv = type of service (1, 2, 3),
					- pref = preferred indicator (TRUE/FALSE).
		*/

#define Store_ns_uus_rq_arg(serv, pref)		\
			((struct ns_uus_rq_arg FAR *)ns_int_ctx.p__val) -> service = serv;		\
			((struct ns_uus_rq_arg FAR *)ns_int_ctx.p__val) -> preferred = pref;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_uus_rq_arg)

#endif	/* end of "explicit requests for User-to-User Signalling SS supported"} */

#if NS_SS_ECT == ON			/* Explicit Call Transfer supported{ */

		/*
		   Store_ns_ect_inform_arg : store ARGUMENT of EctInform operation :

				INPUT :
					- stat = Information status : ALERTING / ACTIVE,
					- pres_nb_type = type of PresentedNumberUnscreened inside redirection number or 255 if absent,
					- p_nb_type = type of PartyNumber inside redirection number,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of redirection number string,
					- p_nb = address of redirection number.
		*/

#define Store_ns_ect_inform_arg(stat, pres_nb_type, p_nb_type, t_of_nb, nb_sz, p_nb)	\
	((struct ns_ect_inform_arg FAR *)ns_int_ctx.p__val) -> status = stat;							\
	((struct ns_ect_inform_arg FAR *)ns_int_ctx.p__val) -> redir_presented_nb_type = pres_nb_type;	\
	((struct ns_ect_inform_arg FAR *)ns_int_ctx.p__val) -> redir_party_nb_type = p_nb_type;			\
	((struct ns_ect_inform_arg FAR *)ns_int_ctx.p__val) -> redir_type_of_nb = t_of_nb;				\
	((struct ns_ect_inform_arg FAR *)ns_int_ctx.p__val) -> redir_nb_digits_sz = nb_sz;				\
	ns_int_ctx.p__val = &(((struct ns_ect_inform_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);						\
	ns_int_ctx.p__val += nb_sz																		

		/*
		   Store_ns_ect_lk_id_rq_res : store RESULT of EctLinkIdRequest operation :

				INPUT :
					- lk_id = Link ID : INTEGER (1..127).
		*/

#define Store_ns_ect_lk_id_rq_res(lk_id)		\
			((struct ns_ect_lk_id_rq_res FAR *)ns_int_ctx.p__val) -> link_id = lk_id;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ect_lk_id_rq_res)

		/*
		   Store_ns_ect_loop_test_arg : store ARGUMENT of EctLoopTest operation :

				INPUT :
					- call_id = Call Transfer Identity : INTEGER (-128..127).
		*/

#define Store_ns_ect_loop_test_arg(call_id)		\
			((struct ns_ect_loop_test_arg FAR *)ns_int_ctx.p__val) -> call_trf_id = call_id;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ect_loop_test_arg)

		/*
		   Store_ns_ect_loop_test_res : store RESULT of EctLoopTest operation :

				INPUT :
					- loop_res = loop result : ENUMERATED {0, 1, 2}.
		*/

#define Store_ns_ect_loop_test_res(loop_res)		\
			((struct ns_ect_loop_test_res FAR *)ns_int_ctx.p__val) -> loop_result = loop_res;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ect_loop_test_res)

		/*
		   Store_ns_ect_exp_exec_arg : store ARGUMENT of ExplicitEctExecute operation :

				INPUT :
					- lk_id = Link ID : INTEGER (1..127).
		*/

#define Store_ns_ect_exp_exec_arg(lk_id)		\
			((struct ns_ect_explicit_exec_arg FAR *)ns_int_ctx.p__val) -> link_id = lk_id;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ect_explicit_exec_arg)

		/*
		   Store_ns_ect_sa_trf_arg : store ARGUMENT of SubaddressTransfer operation :

				INPUT :
					- sa_type = type of PartySubaddress inside transferred-to subaddress,
					- sa_odd_c = oddCountIndicator in transferred-to subaddress,
					- sa_sz = size of transferred-to subaddress string,
					- p_sa = address of transferred-to subaddress.
		*/

#define Store_ns_ect_sa_trf_arg(sa_type, sa_odd_c, sa_sz, p_sa)		\
	((struct ns_ect_subadd_trf_arg FAR *)ns_int_ctx.p__val) -> trf_sub_add_type = sa_type;			\
	((struct ns_ect_subadd_trf_arg FAR *)ns_int_ctx.p__val) -> trf_sub_add_odd_count = sa_odd_c;	\
	((struct ns_ect_subadd_trf_arg FAR *)ns_int_ctx.p__val) -> trf_sub_address_sz = sa_sz;			\
	ns_int_ctx.p__val = &(((struct ns_ect_subadd_trf_arg FAR *)ns_int_ctx.p__val) -> first_sub_add);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);						\
	ns_int_ctx.p__val += sa_sz

#endif	/* end of "Explicit Call Transfer supported"} */

#if (NS_SS_CALL_TRANSFER == ON) || (NS_SS_PATH_REPLACEMENT == ON)	/* Call Transfer SS or Path Replacement ANF supported{ */

		/*
		   Store_ns_qsi_trf_ident_res : store RESULT of CallTransferIdentify operation :

				INPUT :
					- call_id_sz = size of callIdentity string,
					- p_call_id = address of callIdentity string,
					- party_nb_t = type of PartyNumber inside reroutingNumber,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless inside reroutingNumber,
					- nb_sz = size of reroutingNumber string,
					- p_nb = address of reroutingNumber string,
					- ext_sz = size of extension string,
					- p_ext = address of extension string.
		*/

#define Store_ns_qsi_trf_ident_res(call_id_sz, p_call_id, party_nb_t, t_of_nb, nb_sz, p_nb, ext_sz, p_ext)	\
	((struct ns_qsi_trf_identify_res FAR *)ns_int_ctx.p__val) -> call_identity_size = call_id_sz;		\
	((struct ns_qsi_trf_identify_res FAR *)ns_int_ctx.p__val) -> rerout_party_nb_type = party_nb_t;		\
	((struct ns_qsi_trf_identify_res FAR *)ns_int_ctx.p__val) -> rerout_type_of_nb = t_of_nb;			\
	((struct ns_qsi_trf_identify_res FAR *)ns_int_ctx.p__val) -> rerout_nb_size = nb_sz;				\
	((struct ns_qsi_trf_identify_res FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;				\
	ns_int_ctx.p__val = &(((struct ns_qsi_trf_identify_res FAR *)ns_int_ctx.p__val) -> first_nb_digit);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_call_id), call_id_sz);					\
	ns_int_ctx.p__val += call_id_sz;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);							\
	ns_int_ctx.p__val += nb_sz;																			\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);							\
	ns_int_ctx.p__val += ext_sz

		/*
		   Store_ns_qsi_trf_init_arg : store ARGUMENT of CallTransferInitiate operation
			same as RESULT of CallTransferIdentify operation
		*/

#define Store_ns_qsi_trf_init_arg		Store_ns_qsi_trf_ident_res

		/*
		   Store_ns_qsi_trf_setup_arg : store ARGUMENT of CallTransferSetup operation

				INPUT :
					- call_id_sz = size of callIdentity string,
					- p_call_id = address of callIdentity string,
					- ext_sz = size of extension string,
					- p_ext = address of extension string.
		*/

#define Store_ns_qsi_trf_setup_arg(call_id_sz, p_call_id, ext_sz, p_ext)	\
	((struct ns_qsi_trf_setup_arg FAR *)ns_int_ctx.p__val) -> call_identity_size = call_id_sz;		\
	((struct ns_qsi_trf_setup_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;				\
	ns_int_ctx.p__val = &(((struct ns_qsi_trf_setup_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_call_id), call_id_sz);				\
	ns_int_ctx.p__val += call_id_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);						\
	ns_int_ctx.p__val += ext_sz

#endif	/* end of "Call Transfer SS or Path Replacement ANF supported"} */

#if NS_SS_CALL_TRANSFER == ON /* Call Transfer SS supported{ */

		/*
		   store ARGUMENT of CallTransferActive operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_trf_active_1

				INPUT :
					- pres_t = type of PresentedAddressScreened inside connectedAddress,
					- p_nb_t = type of PartyNumber inside connectedAddress,
					- t_of_nb = Type of number inside connectedAddress,
					- scr = ScreeningIndicator inside connectedAddress : ENUMERATED {0, 1, 2, 3},
					- sa_t = type of PartySubaddress inside connectedAddress,
					- sa_o_c = oddCountIndicator in PartySubaddress inside connectedAddress,
					- nm_t = Type of Name inside connectedName or 255 if absent,
					- char = CharacterSet inside connectedName.

		   - Store_ns_qsi_trf_active_2

				INPUT :
					- nb_sz = size of PartyNumber string inside connectedAddress,
					- p_nb = pointer to PartyNumber string inside connectedAddress,
					- sa_sz = size of PartySubaddress string inside connectedAddress,
					- p_sa = pointer to PartySubaddress string inside connectedAddress,
					- ie_sz = size of Q-SIG IE string,
					- p_ie = pointer to Q-SIG IE string,
					- nm_sz = size of nameData string inside connectedName : in range [1..50] or 0 if absent,
					- p_nm = pointer to nameData string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_trf_active_1(pres_t, p_nb_t, t_of_nb, scr, sa_t, sa_o_c, nm_t, char)	\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> presented_add_type = pres_t;	\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_t;		\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> screening_ind = scr;			\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> sub_add_type = sa_t;			\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> sub_add_odd_count = sa_o_c;	\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> name_type = nm_t;			\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> name_character = char

#define Store_ns_qsi_trf_active_2(nb_sz, p_nb, sa_sz, p_sa, ie_sz, p_ie, nm_sz, p_nm, ext_sz, p_ext)	\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> number_digits_sz = nb_sz;	\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> sub_address_sz = sa_sz;		\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> qsig_ie_sz = ie_sz;			\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> name_sz = nm_sz;				\
	((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;		\
	ns_int_ctx.p__val = &(((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);				\
	ns_int_ctx.p__val += nb_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);				\
	ns_int_ctx.p__val += sa_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ie), ie_sz);				\
	ns_int_ctx.p__val += ie_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nm), nm_sz);				\
	ns_int_ctx.p__val += nm_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

		/*
		   store ARGUMENT of CallTransferComplete operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_trf_complete_1

				INPUT :
					- end_des = endDesignation,
					- pres_t = type of PresentedNumberScreened inside redirectionNumber,
					- p_nb_t = type of PartyNumber inside redirectionNumber,
					- t_of_nb = Type of number inside redirectionNumber,
					- scr = ScreeningIndicator inside redirectionNumber : ENUMERATED {0, 1, 2, 3},
					- nm_t = Type of Name inside redirectionName or 255 if absent,
					- char = CharacterSet inside redirectionName,
					- stat = callStatus or 255 if absent.

		   - Store_ns_qsi_trf_complete_2

				INPUT :
					- nb_sz = size of PartyNumber string inside redirectionNumber,
					- p_nb = pointer to PartyNumber string inside redirectionNumber,
					- ie_sz = size of Q-SIG IE string,
					- p_ie = pointer to Q-SIG IE string,
					- nm_sz = size of nameData string inside redirectionName : in range [1..50] or 0 if absent,
					- p_nm = pointer to nameData string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_trf_complete_1(end_des, pres_t, p_nb_t, t_of_nb, scr, nm_t, char, stat)\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> end_designation = end_des;	\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> presented_nb_type = pres_t;\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_t;	\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> screening_ind = scr;		\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> name_type = nm_t;			\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> name_character = char;		\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> call_status = stat

#define Store_ns_qsi_trf_complete_2(nb_sz, p_nb, ie_sz, p_ie, nm_sz, p_nm, ext_sz, p_ext)	\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> number_digits_sz = nb_sz;	\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> qsig_ie_sz = ie_sz;		\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> name_sz = nm_sz;			\
	((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);				\
	ns_int_ctx.p__val += nb_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ie), ie_sz);				\
	ns_int_ctx.p__val += ie_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nm), nm_sz);				\
	ns_int_ctx.p__val += nm_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

		/*
		   store ARGUMENT of CallTransferUpdate operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_trf_update_1

				INPUT :
					- pres_t = type of PresentedNumberScreened inside redirectionNumber,
					- p_nb_t = type of PartyNumber inside redirectionNumber,
					- t_of_nb = Type of number inside redirectionNumber,
					- scr = ScreeningIndicator inside redirectionNumber : ENUMERATED {0, 1, 2, 3},
					- nm_t = Type of Name inside redirectionName or 255 if absent,
					- char = CharacterSet inside redirectionName.

		   - Store_ns_qsi_trf_update_2

				INPUT :
					- nb_sz = size of PartyNumber string inside redirectionNumber,
					- p_nb = pointer to PartyNumber string inside redirectionNumber,
					- nm_sz = size of nameData string inside redirectionName : in range [1..50] or 0 if absent,
					- p_nm = pointer to nameData string,
					- ie_sz = size of Q-SIG IE string,
					- p_ie = pointer to Q-SIG IE string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_trf_update_1(pres_t, p_nb_t, t_of_nb, scr, nm_t, char)		\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> presented_nb_type = pres_t;	\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_t;		\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> screening_ind = scr;			\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> name_type = nm_t;			\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> name_character = char		

#define Store_ns_qsi_trf_update_2(nb_sz, p_nb, nm_sz, p_nm, ie_sz, p_ie, ext_sz, p_ext)	\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> number_digits_sz = nb_sz;	\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> name_sz = nm_sz;				\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> qsig_ie_sz = ie_sz;			\
	((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;		\
	ns_int_ctx.p__val = &(((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);				\
	ns_int_ctx.p__val += nb_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nm), nm_sz);				\
	ns_int_ctx.p__val += nm_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ie), ie_sz);				\
	ns_int_ctx.p__val += ie_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

		/*
		   Store_ns_qsi_trf_subadd_arg : store ARGUMENT of SubaddressTransfer operation

				INPUT :
					- sa_t = type of PartySubaddress inside redirectionSubaddress,
					- sa_o_c = oddCountIndicator in PartySubaddress inside redirectionSubaddress,
					- sa_sz = size of redirectionSubaddress string,
					- p_sa = pointer to redirectionSubaddress string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_trf_subadd_arg(sa_t, sa_o_c, sa_sz, p_sa, ext_sz, p_ext)				\
	((struct ns_qsi_trf_subadd_arg FAR *)ns_int_ctx.p__val) -> sub_add_type = sa_t;			\
	((struct ns_qsi_trf_subadd_arg FAR *)ns_int_ctx.p__val) -> sub_add_odd_count = sa_o_c;	\
	((struct ns_qsi_trf_subadd_arg FAR *)ns_int_ctx.p__val) -> sub_address_sz = sa_sz;		\
	((struct ns_qsi_trf_subadd_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;		\
	ns_int_ctx.p__val = &(((struct ns_qsi_trf_subadd_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);				\
	ns_int_ctx.p__val += sa_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

#endif /* end of "Call Transfer SS supported"} */

#if (NS_SS_CALL_OFFER == ON) || (NS_SS_DO_NOT_DISTURB == ON) || (NS_SS_CALL_INTRUSION == ON) /* { */

		/*
		   Store_ns_qsi_path_retain_arg : store ARGUMENT of PathRetain or ServiceAvailable operation

				INPUT :
					- srv_unused = number of unused bits at the end of serviceList string,
					- srv_sz = size of serviceList string,
					- p_srv = pointer to serviceList string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_path_retain_arg(srv_unused, srv_sz, p_srv, ext_sz, p_ext)	\
	((struct ns_qsi_path_service_arg FAR *)ns_int_ctx.p__val) -> service_unused_bits = srv_unused;\
	((struct ns_qsi_path_service_arg FAR *)ns_int_ctx.p__val) -> service_size = srv_sz;		\
	((struct ns_qsi_path_service_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_path_service_arg FAR *)ns_int_ctx.p__val) -> first_str);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_srv), srv_sz);				\
	ns_int_ctx.p__val += srv_sz;															\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

#endif /* end of "Call Offer or Do Not Disturb or Call Intrusion SS supported"} */

#if NS_SS_DO_NOT_DISTURB == ON	/* Do Not Disturb SS supported{ */

		/*
		   Store_ns_qsi_dnd_activ_arg : store ARGUMENT of doNotDisturbActivateQ
										or doNotDisturbDeactivateQ operation

				INPUT :
					- srv = basic service,
					- party_nb_t = type of PartyNumber inside servedUserNr,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless inside servedUserNr,
					- nb_sz = size of servedUserNr string,
					- p_nb = pointer to servedUserNr string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_dnd_activ_arg(srv, party_nb_t, t_of_nb, nb_sz, p_nb, ext_sz, p_ext)	\
	((struct ns_qsi_dnd_activate_arg FAR *)ns_int_ctx.p__val) -> basic_service = srv;		\
	((struct ns_qsi_dnd_activate_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_nb_t;\
	((struct ns_qsi_dnd_activate_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_qsi_dnd_activate_arg FAR *)ns_int_ctx.p__val) -> nb_size = nb_sz;			\
	((struct ns_qsi_dnd_activate_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_dnd_activate_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);				\
	ns_int_ctx.p__val += nb_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

		/*
		   Store_ns_qsi_dnd_activ_res : with 'status' field
		   Store_ns_qsi_dnd_activ_no_st : without 'status' field
			store RESULT of doNotDisturbActivateQ or doNotDisturbInterrogateQ operation
            List of instances in status (if present) is stored with macros below.

				INPUT :
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_dnd_activ_res(ext_sz, p_ext)	\
	((struct ns_qsi_dnd_activate_res FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	ns_int_ctx.p__offset = &(((struct ns_qsi_dnd_activate_res FAR *)ns_int_ctx.p__val) -> first_str);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__offset += ext_sz;														\
	ns_int_ctx.p__offset = (uchar FAR *)Round ((long)(ns_int_ctx.p__offset));	\
	((struct ns_qsi_dnd_activate_res FAR *)ns_int_ctx.p__val) -> status_offset = (ushort)((ulong)ns_int_ctx.p__offset - (ulong)ns_int_ctx.p__ss_data);	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset;	\
	ns_int_ctx.p__offset = ns_int_ctx.p__start

#define Store_ns_qsi_dnd_activ_no_st(ext_sz, p_ext)	\
	((struct ns_qsi_dnd_activate_res FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	((struct ns_qsi_dnd_activate_res FAR *)ns_int_ctx.p__val) -> status_offset = OFFSET_NIL;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_dnd_activate_res FAR *)ns_int_ctx.p__val) -> first_str);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz;														\

		/*
		   Store_ns_qsi_dnd_status : store 1 instance in status inside RESULT of
					doNotDisturbActivateQ or doNotDisturbInterrogateQ operation

				INPUT :
					- basic_srv = basic service,
					- protect = dnd protection level.
		*/

#define Store_ns_qsi_dnd_status(basic_srv, protect)	\
	((struct ns_qsi_dnd_status_instance FAR *)ns_int_ctx.p__val) -> basic_service = basic_srv;	\
	((struct ns_qsi_dnd_status_instance FAR *)ns_int_ctx.p__val) -> protect_level = protect

		/*
		   Set_ns_qsi_last_dnd_status : store end of 'status' field : It must be called
				after last instance in list.

		   Set_ns_qsi_next_dnd_status : it must be called before storing next instance in status field.
		*/

#define Set_ns_qsi_last_dnd_status()	\
	((struct ns_qsi_dnd_status_instance FAR *)ns_int_ctx.p__val) -> next_instance = OFFSET_NIL;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_qsi_dnd_status_instance)

#define Set_ns_qsi_next_dnd_status()	\
	((struct ns_qsi_dnd_status_instance FAR *)ns_int_ctx.p__val) -> next_instance = (ushort)((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data + Rnd_sizeof (struct ns_qsi_dnd_status_instance));\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_qsi_dnd_status_instance)

		/*
		   Store_ns_qsi_dnd_inter_arg : store ARGUMENT of doNotDisturbInterrogateQ operation

				INPUT :
					- party_nb_t = type of PartyNumber inside servedUserNr,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless inside servedUserNr,
					- nb_sz = size of servedUserNr string,
					- p_nb = pointer to servedUserNr string,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_dnd_inter_arg(party_nb_t, t_of_nb, nb_sz, p_nb, ext_sz, p_ext)	\
	((struct ns_qsi_dnd_interog_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = party_nb_t;	\
	((struct ns_qsi_dnd_interog_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_qsi_dnd_interog_arg FAR *)ns_int_ctx.p__val) -> nb_size = nb_sz;			\
	((struct ns_qsi_dnd_interog_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_dnd_interog_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);				\
	ns_int_ctx.p__val += nb_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

		/*
		   Store_ns_qsi_dnd_over_arg : store ARGUMENT of doNotDisturbOverrideQ operation

				INPUT :
					- cap_level = capability level,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_dnd_over_arg(cap_level, ext_sz, p_ext)		\
	((struct ns_qsi_dnd_override_arg FAR *)ns_int_ctx.p__val) -> capability_level = cap_level;	\
	((struct ns_qsi_dnd_override_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;		\
	ns_int_ctx.p__val = &(((struct ns_qsi_dnd_override_arg FAR *)ns_int_ctx.p__val) -> first_str);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);					\
	ns_int_ctx.p__val += ext_sz

#endif /* end of "Do Not Disturb SS supported"} */

#if NS_SS_CALL_INTRUSION == ON	/* Call intrusion SS supported{ */

		/*
		   Store_ns_qsi_ci_request_arg : store ARGUMENT of CallIntrusionRequest operation
		   Store_ns_qsi_ci_request_res : store RESULT of CallIntrusionRequest operation
		   Store_ns_qsi_ci_getcipl : store ARGUMENT of CallIntrusionGetCIPL operation

				INPUT :
					- level = capability level or unwanted user status or protection level,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_ci_request_arg(level, ext_sz, p_ext)	\
	((struct ns_qsi_ci_request_get_cipl FAR *)ns_int_ctx.p__val) -> level_or_status = level;	\
	((struct ns_qsi_ci_request_get_cipl FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_ci_request_get_cipl FAR *)ns_int_ctx.p__val) -> first_str);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);					\
	ns_int_ctx.p__val += ext_sz

#define Store_ns_qsi_ci_request_res		Store_ns_qsi_ci_request_arg
#define Store_ns_qsi_ci_getcipl			Store_ns_qsi_ci_request_arg

#endif	/* end of "Call intrusion SS supported"} */

#if NS_SS_FREEPHONE == ON		/* Freephone supported{ */

		/*
		   Store_ns_fph_call_arg : store ARGUMENT of CallFPH operation :

				INPUT :
					- p_nb_type = type of PartyNumber (= called freephone number),
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of called freephone number string,
					- p_nb = address of called freephone number string.
		*/

#define Store_ns_fph_call_arg(p_nb_type, t_of_nb, nb_sz, p_nb)	\
	((struct ns_fph_call_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_type;				\
	((struct ns_fph_call_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;					\
	((struct ns_fph_call_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;				\
	ns_int_ctx.p__val = &(((struct ns_fph_call_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);					\
	ns_int_ctx.p__val += nb_sz

		/*
		   Store_ns_fph_monitor_t_arg : store ARGUMENT of Monitor-T-FPH operation :

				INPUT :
					- q931_ie_sz_ = size of Q931 IE string,
					- p_nb_type = type of PartyNumber inside servedUserDestination,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of servedUserDestination number string,
					- queue_id = queue identity : INTEGER (0..127) or 255 if absent,
					- p_q931_ie = address of Q931 IE string,
					- p_nb = address of servedUserDestination number string.
		*/

#define Store_ns_fph_monitor_t_arg(q931_ie_sz_, p_nb_type, t_of_nb, nb_sz, queue_id, p_q931_ie, p_nb)	\
	((struct ns_fph_monitor_t_arg FAR *)ns_int_ctx.p__val) -> q931_ie_sz = q931_ie_sz_;					\
	((struct ns_fph_monitor_t_arg FAR *)ns_int_ctx.p__val) -> s_u_party_nb_type = p_nb_type;			\
	((struct ns_fph_monitor_t_arg FAR *)ns_int_ctx.p__val) -> s_u_type_of_nb = t_of_nb;					\
	((struct ns_fph_monitor_t_arg FAR *)ns_int_ctx.p__val) -> s_u_nb_digits_size = nb_sz;				\
	((struct ns_fph_monitor_t_arg FAR *)ns_int_ctx.p__val) -> queue_identity = queue_id;				\
	ns_int_ctx.p__val = &(((struct ns_fph_monitor_t_arg FAR *)ns_int_ctx.p__val) -> first_str_oct);		\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_q931_ie), q931_ie_sz_);					\
	ns_int_ctx.p__val += q931_ie_sz_;																	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);							\
	ns_int_ctx.p__val += nb_sz

		/*
		   Store_ns_fph_free_t_arg : store ARGUMENT of Free-T-FPH operation :

				INPUT :
					- p_nb_type = type of PartyNumber inside servedUserDestination,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of servedUserDestination number string,
					- fph_ref = FPH reference : INTEGER (0..127),
					- p_nb = address of servedUserDestination number string.
		*/

#define Store_ns_fph_free_t_arg(p_nb_type, t_of_nb, nb_sz, fph_ref, p_nb)						\
	((struct ns_fph_free_t_arg FAR *)ns_int_ctx.p__val) -> s_u_party_nb_type = p_nb_type;		\
	((struct ns_fph_free_t_arg FAR *)ns_int_ctx.p__val) -> s_u_type_of_nb = t_of_nb;			\
	((struct ns_fph_free_t_arg FAR *)ns_int_ctx.p__val) -> s_u_nb_digits_size = nb_sz;			\
	((struct ns_fph_free_t_arg FAR *)ns_int_ctx.p__val) -> fph_reference = fph_ref;				\
	ns_int_ctx.p__val = &(((struct ns_fph_free_t_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);					\
	ns_int_ctx.p__val += nb_sz

		/*
		   Store_ns_fph_call_t_arg : store ARGUMENT of Call-T-FPH operation :

				INPUT :
					- p_nb_type = type of PartyNumber (= called freephone number) or 255 if absent,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of called freephone number string,
					- fph_ref = FPH reference : INTEGER (0..127),
					- p_nb = address of called freephone number string.
		*/

#define Store_ns_fph_call_t_arg(p_nb_type, t_of_nb, nb_sz, fph_ref, p_nb)						\
	((struct ns_fph_call_t_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_type;			\
	((struct ns_fph_call_t_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;				\
	((struct ns_fph_call_t_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;				\
	((struct ns_fph_call_t_arg FAR *)ns_int_ctx.p__val) -> fph_reference = fph_ref;				\
	ns_int_ctx.p__val = &(((struct ns_fph_call_t_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);					\
	ns_int_ctx.p__val += nb_sz

#endif	/* end of "Freephone supported"} */

#if NS_SS_CCBS == ON		/* Completion of Calls to Busy Subscriber supported{ */

		/*
		   Store_ns_ccbs_info_ret_arg : store ARGUMENT of CallInfoRetain operation :
		   Store_ns_ccbs_eras_lk_id_arg : store ARGUMENT of EraseCallLinkageID operation :

				INPUT :
					- lk_id = call linkage ID : INTEGER (0..127).
		*/

#define Store_ns_ccbs_info_ret_arg(lk_id)		\
			((struct ns_ccbs_call_inf_eras_lk_arg FAR *)ns_int_ctx.p__val) -> linkage_id = lk_id;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_call_inf_eras_lk_arg)

#define Store_ns_ccbs_eras_lk_id_arg	Store_ns_ccbs_info_ret_arg

		/*
		   Store_ns_ccbs_dea_arg : store ARGUMENT of CCBSDeactivate operation :
		   Store_ns_ccbs_call_arg : store ARGUMENT of CCBSCall operation :
		   Store_ns_ccbs_stop_alert_arg : store ARGUMENT of CCBSStopAlerting operation :

				INPUT :
					- ref = CCBS reference : INTEGER (0..127).
		*/

#define Store_ns_ccbs_dea_arg(ref)		\
			((struct ns_ccbs_dea_call_stop_al_arg FAR *)ns_int_ctx.p__val) -> reference = ref;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_dea_call_stop_al_arg)

#define Store_ns_ccbs_call_arg			Store_ns_ccbs_dea_arg
#define Store_ns_ccbs_stop_alert_arg	Store_ns_ccbs_dea_arg

		/*
		   Store_ns_ccbs_rq_arg : store ARGUMENT of CCBSRequest operation :

				INPUT :
					- lk_id = call linkage ID : INTEGER (0..127).
		*/

#define Store_ns_ccbs_rq_arg(lk_id)		\
			((struct ns_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> linkage_id = lk_id;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_request_arg)

		/*
		   Store_ns_ccbs_rq_res : store RESULT of CCBSRequest operation :

				INPUT :
					- recall_m = recall mode : ENUMERATED {0, 1},
					- ref = CCBS reference : INTEGER (0..127).
		*/

#define Store_ns_ccbs_rq_res(recall_m, ref)	\
			((struct ns_ccbs_request_res FAR *)ns_int_ctx.p__val) -> recall_mode = recall_m;	\
			((struct ns_ccbs_request_res FAR *)ns_int_ctx.p__val) -> reference = ref;			\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_request_res)

		/*
		   Store_ns_ccbs_stat_rq_arg : store ARGUMENT of CCBSStatusRequest operation :

				INPUT :
					- recall_m = recall mode : ENUMERATED {0, 1},
					- ref = CCBS reference : INTEGER (0..127),
					- q931_ie_sz_ = size of Q931 IE string,
					- p_q931_ie = address of Q931 IE string.
		*/

#define Store_ns_ccbs_stat_rq_arg(recall_m, ref, q931_ie_sz_, p_q931_ie)	\
	((struct ns_ccbs_status_rq_arg FAR *)ns_int_ctx.p__val) -> recall_mode = recall_m;		\
	((struct ns_ccbs_status_rq_arg FAR *)ns_int_ctx.p__val) -> reference = ref;				\
	((struct ns_ccbs_status_rq_arg FAR *)ns_int_ctx.p__val) -> q931_ie_sz = q931_ie_sz_;	\
	ns_int_ctx.p__val = &(((struct ns_ccbs_status_rq_arg FAR *)ns_int_ctx.p__val) -> first_ie_oct);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_q931_ie), q931_ie_sz_);		\
	ns_int_ctx.p__val += q931_ie_sz_

		/*
		   Store_ns_ccbs_stat_rq_res : store RESULT of CCBSStatusRequest operation :

				INPUT :
					- free_ : TRUE = free, FALSE = busy.
		*/

#define Store_ns_ccbs_stat_rq_res(free_)	\
			((struct ns_ccbs_status_rq_res FAR *)ns_int_ctx.p__val) -> free = free_;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_status_rq_res)

		/*
		   Store_ns_ccbs_r_free_arg : store ARGUMENT of CCBSRemoteUserFree operation :
		   Store_ns_ccbs_bfree_arg : store ARGUMENT of CCBSBFree operation :

				INPUT :
					- recall_m = recall mode : ENUMERATED {0, 1},
					- ref = CCBS reference : INTEGER (0..127),
					- p_nb_t = type of PartyNumber inside addressOfB,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside addressOfB),
					- sa_t = type of PartySubaddress or 255 if absent inside addressOfB,
					- sa_odd_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside addressOfB),
					- nb_sz = size of NumberDigits string inside addressOfB,
					- sa_sz = size of PartySubaddress string inside addressOfB,
					- ie_sz = size of Q931 IE string,
					- p_nb = pointer to NumberDigits string inside addressOfB,
					- p_sa = pointer to PartySubaddress string inside addressOfB,
					- p_ie = pointer to Q931 IE string.
		*/

#define Store_ns_ccbs_r_free_arg(recall_m, ref, p_nb_t, t_of_nb, sa_t, sa_odd_c, nb_sz, sa_sz, ie_sz, p_nb, p_sa, p_ie)\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> recall_mode = recall_m;		\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> reference = ref;				\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_t;		\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;		\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> sub_add_type = sa_t;			\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> sub_add_odd_count = sa_odd_c;\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> sub_address_size = sa_sz;	\
	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> q931_ie_sz = ie_sz;			\
	ns_int_ctx.p__val = &(((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);		\
	ns_int_ctx.p__val += nb_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);		\
	ns_int_ctx.p__val += sa_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ie), ie_sz);		\
	ns_int_ctx.p__val += ie_sz

#define Store_ns_ccbs_bfree_arg		Store_ns_ccbs_r_free_arg

		/*
		   Store_ns_ccbs_erase_arg : store ARGUMENT of CCBSErase operation :

				INPUT :
					- recall_m = recall mode : ENUMERATED {0, 1},
					- ref = CCBS reference : INTEGER (0..127),
					- reas = erase reason : ENUMERATED {0, 1, 2, 3},
					- p_nb_t = type of PartyNumber inside addressOfB,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside addressOfB),
					- sa_t = type of PartySubaddress or 255 if absent inside addressOfB,
					- sa_odd_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside addressOfB),
					- nb_sz = size of NumberDigits string inside addressOfB,
					- sa_sz = size of PartySubaddress string inside addressOfB,
					- ie_sz = size of Q931 IE string,
					- p_nb = pointer to NumberDigits string inside addressOfB,
					- p_sa = pointer to PartySubaddress string inside addressOfB,
					- p_ie = pointer to Q931 IE string.
		*/

#define Store_ns_ccbs_erase_arg(recall_m, ref, reas, p_nb_t, t_of_nb, sa_t, sa_odd_c, nb_sz, sa_sz, ie_sz, p_nb, p_sa, p_ie)\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> recall_mode = recall_m;		\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> reference = ref;				\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> reason = reas;				\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_t;		\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;		\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> sub_add_type = sa_t;			\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> sub_add_odd_count = sa_odd_c;\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> sub_address_size = sa_sz;	\
	((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> q931_ie_sz = ie_sz;			\
	ns_int_ctx.p__val = &(((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);		\
	ns_int_ctx.p__val += nb_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_sa), sa_sz);		\
	ns_int_ctx.p__val += sa_sz;														\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ie), ie_sz);		\
	ns_int_ctx.p__val += ie_sz

		/*
		   Store_ns_ccbs_interog_arg : store ARGUMENT of CCBSInterrogate operation :

				INPUT :
					- ref = CCBS reference : INTEGER (0..127) or 255 if absent,
					- p_nb_t = type of PartyNumber inside partyNumberOfA or 255 if absent,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside partyNumberOfA),
					- nb_sz = size of NumberDigits string inside partyNumberOfA,
					- p_nb = pointer to NumberDigits string inside partyNumberOfA.
		*/

#define Store_ns_ccbs_interog_arg(ref, p_nb_t, t_of_nb, nb_sz, p_nb)	\
	((struct ns_ccbs_interog_arg FAR *)ns_int_ctx.p__val) -> reference = ref;			\
	((struct ns_ccbs_interog_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_t;	\
	((struct ns_ccbs_interog_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;		\
	((struct ns_ccbs_interog_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;	\
	ns_int_ctx.p__val = &(((struct  ns_ccbs_interog_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);			\
	ns_int_ctx.p__val += nb_sz

		/*
		   Store_ns_ccbs_interog_no_det : store RESULT of CCBSInterrogate operation containing
           									no callDetail (0 instance of CallInformation).

				INPUT :
					- recall_m = recall mode : ENUMERATED {0, 1}.
		*/

#define Store_ns_ccbs_interog_no_det(recall_m)	\
	((struct ns_ccbs_interog_res FAR *)ns_int_ctx.p__val) -> recall_mode = recall_m;		\
	((struct ns_ccbs_interog_res FAR *)ns_int_ctx.p__val) -> first_call_info = OFFSET_NIL;	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_interog_res)

		/*
		   Store_ns_ccbs_interog_detail : store RESULT of CCBSInterrogate operation containing
											callDetails (1 or more instance(s) of CallInformation).

				INPUT :
					- recall_m = recall mode : ENUMERATED {0, 1}.

				data in list of call information is to be provided with next Macros.
		*/

#define Store_ns_ccbs_interog_detail(recall_m)	\
	((struct ns_ccbs_interog_res FAR *)ns_int_ctx.p__val) -> recall_mode = recall_m;	\
	((struct ns_ccbs_interog_res FAR *)ns_int_ctx.p__val) -> first_call_info = (ushort)(((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data) + Rnd_sizeof (struct ns_ccbs_interog_res));	\
	ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_interog_res)

		/*
		   Store_ns_ccbs_call_info : store 1 instance of CallInformation.

				INPUT :
					- ref = CCBS reference = INTEGER (0..127),
					- B_p_nb_t = type of PartyNumber inside addressOfB,
					- B_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside addressOfB),
					- B_nb_sz = size of NumberDigits string inside addressOfB,
					- B_sa_t = type of PartySubaddress or 255 if absent inside addressOfB,
					- B_sa_o_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside addressOfB),
					- B_sa_sz = size of PartySubaddress string inside addressOfB,
					- ie_sz = size of Q931 IE string,
					- A_sa_t = type of PartySubaddress or 255 if absent inside subAddressOfA,
					- A_sa_o_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside subAddressOfA),
					- A_sa_sz = size of PartySubaddress string inside subAddressOfA,
					- p_B_nb = pointer to NumberDigits string inside addressOfB,
					- p_B_sa = pointer to PartySubaddress string inside addressOfB,
					- p_ie = pointer to Q931 IE string,
					- p_A_sa = pointer to PartySubaddress string inside subAddressOfA.
		*/

#define Store_ns_ccbs_call_info(ref, B_p_nb_t, B_t_of_nb, B_nb_sz, B_sa_t, B_sa_o_c, B_sa_sz, ie_sz, A_sa_t, A_sa_o_c, A_sa_sz, p_B_nb, p_B_sa, p_ie, p_A_sa)\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> reference = ref;						\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfB_party_nb_type = B_p_nb_t;		\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfB_type_of_nb = B_t_of_nb;			\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfB_nb_digits_size = B_nb_sz;		\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfB_sub_add_type = B_sa_t;			\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfB_sub_add_odd_count = B_sa_o_c;	\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfB_sub_address_size = B_sa_sz;		\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> q931_ie_sz = ie_sz;					\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfA_sub_add_type = A_sa_t;			\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfA_sub_add_odd_count = A_sa_o_c;	\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> OfA_sub_address_size = A_sa_sz;		\
	ns_int_ctx.p__offset = &(((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_B_nb), B_nb_sz);				\
	ns_int_ctx.p__offset += B_nb_sz;															\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_B_sa), B_sa_sz);				\
	ns_int_ctx.p__offset += B_sa_sz;															\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_ie), ie_sz);					\
	ns_int_ctx.p__offset += ie_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__offset), (char FAR *)(p_A_sa), A_sa_sz);				\
	ns_int_ctx.p__offset += A_sa_sz;															\
	ns_int_ctx.p__offset = (uchar FAR *)Round ((long)(ns_int_ctx.p__offset))

		/*
		   Set_ns_last_ccbs_call_info : It must be called after storing last instance
		   								of CallInformation in list.

		   Set_ns_next_ccbs_call_info : it must be called before storing next instance
										of CallInformation in list.
		*/

#define Set_ns_last_ccbs_call_info()		\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> next_call_info = OFFSET_NIL;	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset;														 	\
	ns_int_ctx.p__offset = ns_int_ctx.p__start

#define Set_ns_next_ccbs_call_info()		\
	((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> next_call_info = (ushort)((ulong)ns_int_ctx.p__offset - (ulong)ns_int_ctx.p__ss_data);	\
	ns_int_ctx.p__val = ns_int_ctx.p__offset

		/*
		   store ARGUMENT of CCBS-T-Request operation : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_ccbs_t_rq_arg_1
				INPUT :
					- ret = retention supported : TRUE / FALSE or 255,
					- pres = presentationAllowedindicator : TRUE / FALSE or 255,
					- d_p_nb_t = type of PartyNumber inside destinationAddress,
					- d_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside destinationAddress),
					- d_sa_t = type of PartySubaddress or 255 if absent (inside destinationAddress),
					- d_sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside destinationAddress),
					- o_p_nb_t = type of PartyNumber inside originatingAddress,
					- o_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside originatingAddress),
					- o_sa_t = type of PartySubaddress or 255 if absent (inside originatingAddress),
					- o_sa_odd_c = oddCountIndicator : TRUE/FALSE or 255 if absent (inside originatingAddress).

		   - Store_ns_ccbs_t_rq_arg_2 : It must be called after Macro above.
				INPUT :
					- d_nb_sz = size of PartyNumber string inside destinationAddress,
					- d_sa_sz = size of PartySubaddress string inside destinationAddress,
					- ie_sz = size of Q931 IE string,
					- o_nb_sz = size of PartyNumber string inside originatingAddress,
					- o_sa_sz = size of PartySubaddress string inside originatingAddress,
					- p_d_nb = pointer to PartyNumber string inside destinationAddress,
					- p_d_sa = pointer to PartySubaddress string inside destinationAddress,
					- p_ie = pointer to Q931 IE string,
					- p_o_nb = pointer to PartyNumber string inside originatingAddress,
					- p_o_sa = pointer to PartySubaddress string inside originatingAddress.
		*/

#define Store_ns_ccbs_t_rq_arg_1(ret, pres, d_p_nb_t, d_t_of_nb, d_sa_t, d_sa_odd_c, o_p_nb_t, o_t_of_nb, o_sa_t, o_sa_odd_c)\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> retention_supp = ret;					\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> pres_allow_ind = pres;				\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> dest_party_nb_type = d_p_nb_t;		\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> dest_type_of_nb = d_t_of_nb;			\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> dest_sub_add_type = d_sa_t;			\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> dest_sub_add_odd_count = d_sa_odd_c;	\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> orig_party_nb_type = o_p_nb_t;		\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> orig_type_of_nb = o_t_of_nb;			\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> orig_sub_add_type = o_sa_t;			\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> orig_sub_add_odd_count = o_sa_odd_c

#define Store_ns_ccbs_t_rq_arg_2(d_nb_sz, d_sa_sz, ie_sz, o_nb_sz, o_sa_sz, p_d_nb, p_d_sa, p_ie, p_o_nb, p_o_sa)\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> dest_nb_digits_size = d_nb_sz;	\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> dest_sub_address_size = d_sa_sz;	\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> q931_ie_sz = ie_sz;				\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> orig_nb_digits_size = o_nb_sz;	\
	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> orig_sub_address_size = o_sa_sz;	\
	ns_int_ctx.p__val = &(((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> first_nb_digit);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_d_nb), d_nb_sz);			\
	ns_int_ctx.p__val += d_nb_sz;															\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_d_sa), d_sa_sz);			\
	ns_int_ctx.p__val += d_sa_sz;															\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ie), ie_sz);				\
	ns_int_ctx.p__val += ie_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_o_nb), o_nb_sz);			\
	ns_int_ctx.p__val += o_nb_sz;															\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_o_sa), o_sa_sz);			\
	ns_int_ctx.p__val += o_sa_sz

		/*
		   Store_ns_ccbs_t_rq_res : store RESULT of CCBS-T-Request operation :

				INPUT :
					- ret = retention supported : TRUE / FALSE.
		*/

#define Store_ns_ccbs_t_rq_res(ret)	\
			((struct ns_ccbs_t_rq_res FAR *)ns_int_ctx.p__val) -> retention_supp = ret;	\
			ns_int_ctx.p__val += Rnd_sizeof (struct ns_ccbs_t_rq_res)

			/*** Q-SIG specific operations ***/

		/*
		   store ARGUMENT of CcbsRequest or CcnrRequest operations : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_ccbs_rq_arg_1
				INPUT :
					- pres_nb_t = type of PresentedNumberUnscreened inside numberA,
					- A_p_nb_t = type of PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside numberA,
					- A_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside numberA),
					- B_p_nb_t = type of PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside numberB,
					- B_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside numberB),
					- A_sa_t = type of PartySubaddress or 255 if absent (inside subaddrA),
					- A_sa_o_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside subaddrA),
					- B_sa_t = type of PartySubaddress or 255 if absent (inside subaddrB),
					- B_sa_o_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside subaddrB),
					- ret_srv = can-retain-service : TRUE/FALSE or 255 if absent,
					- ret_sig = retain-sig-connection : TRUE/FALSE or 255 if absent.

		   - Store_ns_qsi_ccbs_rq_arg_2
				INPUT :
					- A_nb_sz = size of PartyNumber string inside numberA,
					- p_A_nb = pointer to PartyNumber string inside numberA,
					- B_nb_sz = size of PartyNumber string inside numberB,
					- p_B_nb = pointer to PartyNumber string inside numberB,
					- srv_sz = size of service (QSIG IE) string,
					- p_srv = pointer to service (QSIG IE) string,
					- A_sa_sz = size of PartySubaddress string inside subaddrA,
					- p_A_sa = pointer to PartySubaddress string inside subaddrA,
					- B_sa_sz = size of PartySubaddress string inside subaddrB,
					- p_B_sa = pointer to PartySubaddress string inside subaddrB,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_ccbs_rq_arg_1(pres_nb_t, A_p_nb_t, A_t_of_nb, B_p_nb_t, B_t_of_nb, A_sa_t, A_sa_o_c, B_sa_t, B_sa_o_c, ret_srv, ret_sig)\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_presented_nb_type = pres_nb_t;\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_party_nb_type = A_p_nb_t;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_type_of_nb = A_t_of_nb;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_party_nb_type = B_p_nb_t;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_type_of_nb = B_t_of_nb;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_sub_add_type = A_sa_t;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_sub_add_odd_count = A_sa_o_c;\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_sub_add_type = B_sa_t;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_sub_add_odd_count = B_sa_o_c;\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> can_retain_service = ret_srv;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> retain_sig_connection = ret_sig

#define Store_ns_qsi_ccbs_rq_arg_2(A_nb_sz, p_A_nb, B_nb_sz, p_B_nb, srv_sz, p_srv, A_sa_sz, p_A_sa, B_sa_sz, p_B_sa, ext_sz, p_ext)\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_number_digits_sz = A_nb_sz;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_number_digits_sz = B_nb_sz;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> service_sz = srv_sz;			\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_sub_address_sz = A_sa_sz;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_sub_address_sz = B_sa_sz;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;		\
	ns_int_ctx.p__val = &(((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_A_nb), A_nb_sz);				\
	ns_int_ctx.p__val += A_nb_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_B_nb), B_nb_sz);				\
	ns_int_ctx.p__val += B_nb_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_srv), srv_sz);					\
	ns_int_ctx.p__val += srv_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_A_sa), A_sa_sz);				\
	ns_int_ctx.p__val += A_sa_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_B_sa), B_sa_sz);				\
	ns_int_ctx.p__val += B_sa_sz;																\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);					\
	ns_int_ctx.p__val += ext_sz

		/*
		   store ARGUMENT of CcCancel or CcExecPossible operations of type fullArg : 2 Macros. BOTH MUST BE CALLED.

		   - Store_ns_qsi_cc_cnc_exec_full
				INPUT :
					- A_p_nb_t = type of PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside numberA,
					- A_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside numberA),
					- B_p_nb_t = type of PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside numberB,
					- B_t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside numberB),
					- A_sa_t = type of PartySubaddress or 255 if absent (inside subaddrA),
					- A_sa_o_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside subaddrA),
					- B_sa_t = type of PartySubaddress or 255 if absent (inside subaddrB),
					- B_sa_o_c = oddCountIndicator in PartySubaddress : TRUE/FALSE or 255 if absent (inside subaddrB).

		   - Store_ns_qsi_ccbs_rq_arg_2 : see above
		*/


#define Store_ns_qsi_cc_cnc_exec_full(A_p_nb_t, A_t_of_nb, B_p_nb_t, B_t_of_nb, A_sa_t, A_sa_o_c, B_sa_t, B_sa_o_c)\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_presented_nb_type = NS_QSI_CC_OPTIONAL_FULL_ARG;\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_party_nb_type = A_p_nb_t;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_type_of_nb = A_t_of_nb;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_party_nb_type = B_p_nb_t;	\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_type_of_nb = B_t_of_nb;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_sub_add_type = A_sa_t;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_sub_add_odd_count = A_sa_o_c;\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_sub_add_type = B_sa_t;		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> B_sub_add_odd_count = B_sa_o_c

		/*
		   Store_ns_qsi_cc_cnc_exec_ext : store ARGUMENT of CcCancel and CcExecPossible operations
											of type extArg (contains only extension)

				INPUT :
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_cc_cnc_exec_ext(ext_sz, p_ext)		\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> A_presented_nb_type = NS_QSI_CC_OPTIONAL_EXT_ARG;\
	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;	\
	ns_int_ctx.p__val = &(((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);				\
	ns_int_ctx.p__val += ext_sz

		/*
		   Store_ns_qsi_ccbs_rq_res : store RESULT of CcbsRequest and CcnrRequest operations

				INPUT :
					- no_path_r = no-path-reservation : TRUE/FALSE or 255 if absent,
					- retain_srv = retain-service : TRUE/FALSE or 255 if absent,
					- ext_sz = size of extension string,
					- p_ext = pointer to extension string.
		*/

#define Store_ns_qsi_ccbs_rq_res(no_path_r, retain_srv, ext_sz, p_ext)	\
	((struct ns_qsi_ccbs_request_res FAR *)ns_int_ctx.p__val) -> no_path_reservation = no_path_r;	\
	((struct ns_qsi_ccbs_request_res FAR *)ns_int_ctx.p__val) -> retain_service = retain_srv; 		\
	((struct ns_qsi_ccbs_request_res FAR *)ns_int_ctx.p__val) -> extension_size = ext_sz;			\
	ns_int_ctx.p__val = &(((struct ns_qsi_ccbs_request_res FAR *)ns_int_ctx.p__val) -> first_str);	\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_ext), ext_sz);						\
	ns_int_ctx.p__val += ext_sz

#endif	/* end of "Completion of Calls to Busy Subscriber supported"} */

#if NS_SS_INTERACTIONS == ON	/* Supplementary service interactions{ */

#if (NS_SS_AOC_E == ON)	&& ((NS_SS_DIVERSION == ON) || (NS_SS_ECT == ON))	/* AOC-E SS and (Diversion or ECT SS) supported */

		/*
		   Store_ns_id_of_charge_arg : store ARGUMENT of IdentificationOfCharge operation :

				INPUT :
					- assoc_t = type of ChargingAssociation,  
					- charg_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
					- p_nb_t = type of PartyNumber,
					- t_of_nb = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
					- nb_sz = size of NumberDigits string inside PartyNumber,
					- p_nb = pointer to NumberDigits string.
		*/

#define Store_ns_id_of_charge_arg(assoc_t, charg_id, p_nb_t, t_of_nb, nb_sz, p_nb)	\
	((struct ns_interact_id_of_charge_arg FAR *)ns_int_ctx.p__val) -> charg_assoc_type = assoc_t;	\
	((struct ns_interact_id_of_charge_arg FAR *)ns_int_ctx.p__val) -> charg_identifier = charg_id;	\
	((struct ns_interact_id_of_charge_arg FAR *)ns_int_ctx.p__val) -> party_nb_type = p_nb_t;		\
	((struct ns_interact_id_of_charge_arg FAR *)ns_int_ctx.p__val) -> type_of_nb = t_of_nb;			\
	((struct ns_interact_id_of_charge_arg FAR *)ns_int_ctx.p__val) -> nb_digits_size = nb_sz;		\
	ns_int_ctx.p__val = &(((struct ns_interact_id_of_charge_arg FAR *)ns_int_ctx.p__val) -> first_nb_dig);\
	Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_nb), nb_sz);						\
	ns_int_ctx.p__val += nb_sz

#endif	/* end of AOC-E SS and (Diversion or ECT SS) supported */

#endif	/* end of Supplementary service interactions} */

/*-------------------------------------------------------------------------*/

			/*  Macros used to access a value in data specific to operation : they are
				based on the operation specific structures defined in ns_ssint.h */

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)	/* AOC service supported{ */

		/*
		   Isdn_get_aoc_charg_rq_case : ARGUMENT of AOC ChargingRequest operation

				OUTPUT : charging case.
		*/

#define Isdn_get_aoc_charg_rq_case()	\
			((struct ns_aoc_charging_rq_arg FAR *)ns_int_ctx.p__val) -> charging_case

		/*
		   Isdn_get_aoc_charg_rq_res : RESULT of AOC ChargingRequest operation

				INPUT : val_id	= value identifier (inside 'ns_aoc_charging_rq_res' structure).
		*/

#define Isdn_get_aoc_charg_rq_res(val_id)	((struct ns_aoc_charging_rq_res FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_aoc_ch_rq_cur_info : get location of first AOCS Currency info inside
				RESULT of AOC ChargingRequest operation. ! THIS MACRO MUST BE CALLED
				AFTER READING ALL PARAMETERS IN RESULT.
		*/

#define Isdn_set_to_aoc_ch_rq_cur_info()		\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + ((struct ns_aoc_charging_rq_res FAR *)ns_int_ctx.p__val) -> aocs_first_cur_info

		/*
		   Isdn_get_aocs_cur_info : AOCS Currency Info inside RESULT of ChargingRequest operation
													or inside ARGUMENT of AOCSCurrency operation

				INPUT : val_id	= value identifier (inside 'ns_aocs_currency_info' structure).

			Isdn_get_aocs_a_cur_str : address of first octet of AOCS Currency string.
		*/

#define Isdn_get_aocs_cur_info(val_id)		((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> val_id
#define Isdn_get_aocs_a_cur_str()			&(Isdn_get_aocs_cur_info (first_currency_oct))

		/*
		   Isdn_set_to_next_aoc_cur_info : get location of next AOCS Currency info instance.
				! THIS MACRO MUST BE CALLED AFTER READING ALL PARAMETERS in current instance.
		*/

#define Isdn_set_to_next_aoc_cur_info()		\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + ((struct ns_aocs_currency_info FAR *)ns_int_ctx.p__val) -> next_currency_info

#if NS_SS_AOC_S == ON

		/*
		   Isdn_get_aocs_cur_arg : ARGUMENT of AOCSCurrency operation

				INPUT : val_id	= value identifier (inside 'ns_aocs_currency_arg' structure).
		*/

#define Isdn_get_aocs_cur_arg(val_id)	\
			((struct ns_aocs_currency_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_aocs_cur_info : get location of first AOCS Currency info inside
				ARGUMENT of AOCSCurrency operation. ! THIS MACRO MUST BE CALLED
				AFTER READING ALL PARAMETERS IN ARGUMENT.
		*/

#define Isdn_set_to_aocs_cur_info()		\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + ((struct ns_aocs_currency_arg FAR *)ns_int_ctx.p__val) -> first_cur_info

		/*
		   Isdn_get_aocs_special_arr : ARGUMENT of AOCSSpecialArr operation

				INPUT : val_id	= value identifier (inside 'ns_aocs_special_arr_arg' structure).
		*/

#define Isdn_get_aocs_special_arr(val_id)	\
			((struct ns_aocs_special_arr_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif

#if NS_SS_AOC_D == ON

		/*
		   Isdn_get_aocd_cur_arg : ARGUMENT of AOCDCurrency operation

				INPUT : val_id	= value identifier (inside 'ns_aocd_currency_arg' structure).
		*/

#define Isdn_get_aocd_cur_arg(val_id)	\
			((struct ns_aocd_currency_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_aocd_charg_u_arg : ARGUMENT of AOCDChargingUnit operation

				INPUT : val_id	= value identifier (inside 'ns_aocd_charging_unit_arg' structure).
		*/

#define Isdn_get_aocd_charg_u_arg(val_id)	\
			((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_aocd_recorded_u : get location of first recorded unit inside
				ARGUMENT of AOCDChargingUnit operation. ! THIS MACRO MUST BE CALLED
				AFTER READING ALL PARAMETERS IN ARGUMENT.
		*/

#define Isdn_set_to_aocd_recorded_u()	\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + ((struct ns_aocd_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_recorded_unit

#endif

#if (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)

		/*
		   Isdn_get_aoc_recorded_u : recorded unit inside ARGUMENT of AOCDChargingUnit
															or AOCEChargingUnit operation

				INPUT : val_id	= value identifier (inside 'ns_aoc_recorded_unit' structure).
		*/

#define Isdn_get_aoc_recorded_u(val_id)		((struct ns_aoc_recorded_unit FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_next_aoc_rec_u : get location of next recorded unit.
				! THIS MACRO MUST BE CALLED AFTER READING ALL PARAMETERS in current unit.
		*/

#define Isdn_set_to_next_aoc_rec_u()	\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + ((struct ns_aoc_recorded_unit FAR *)ns_int_ctx.p__val) -> next_unit_info

#endif

#if NS_SS_AOC_E == ON

		/*
		   Isdn_get_aoce_cur_arg : ARGUMENT of AOCECurrency operation

				INPUT : val_id	= value identifier (inside 'ns_aoce_currency_arg' structure).
		*/

#define Isdn_get_aoce_cur_arg(val_id)	\
			((struct ns_aoce_currency_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_aoce_charg_u_arg : ARGUMENT of AOCEChargingUnit operation

				INPUT : val_id	= value identifier (inside 'ns_aoce_charging_unit_arg' structure).
		*/

#define Isdn_get_aoce_charg_u_arg(val_id)	\
			((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_aoce_recorded_u : get location of first recorded unit inside
				ARGUMENT of AOCEChargingUnit operation. ! THIS MACRO MUST BE CALLED
				AFTER READING ALL PARAMETERS IN ARGUMENT.
		*/

#define Isdn_set_to_aoce_recorded_u()	\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + ((struct ns_aoce_charging_unit_arg FAR *)ns_int_ctx.p__val) -> first_recorded_unit

#endif

#endif	/* end of AOC service supported} */

#if NS_SS_CUG == ON

		/*
		   Isdn_get_cug_call_arg : ARGUMENT of CUGCallOperation operation

				INPUT : val_id	= value identifier (inside 'ns_cug_call_arg' structure).
		*/

#define Isdn_get_cug_call_arg(val_id)		((struct ns_cug_call_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif

		/*
		   Isdn_get_qsi_tsp_extension : get list of octets (size, octets) copied transparently from SPDU
				may be used in Q-SIG for :
					- PARAMETER of "Unspecified" error
					- RESULT of ActivateDiversionQ operation
					- RESULT of DeactivateDiversionQ operation
					- RESULT of CheckRestriction operation
					- RESULT of CallRerouting operation
					- ARGUMENT of CfnrDivertedLegFailed operation
					- ARGUMENT of CallTransferIdentify operation
					- ARGUMENT of CallTransferAbandon operation
					- RESULT of CallTransferInitiate operation
					- RESULT of CallTransferSetup operation
					- RESULT of PathReplaceSetup and PathReplaceRetain operations
					- ARGUMENT and RESULT of CallOfferRequest operation
					- RESULT of doNotDisturbDeactivateQ operation
					- ARGUMENT and RESULT of doNotDisturbOvrExecuteQ operation
					- ARGUMENT and RESULT of CcPathReserve operation
					- ARGUMENT of CcRingout, CcSuspend and CcResume operations

				INPUT : val_id	= value identifier (inside 'ns_qsi_transparent_extension' structure).
		*/

#define Isdn_get_qsi_tsp_extension(val_id)		((struct ns_qsi_transparent_extension FAR *)ns_int_ctx.p__val) -> val_id

#if NS_SS_NAME_IDENT == ON		/* Name Identification SS supported{ */

		/*
		   Isdn_get_qsi_name_ident : ARGUMENT of all operations for Name Identification SS :
		   							 CallingName, CalledName, ConnectedName, BusyName

				INPUT : val_id	= value identifier (inside 'ns_qsi_name_ident_arg' structure).
		*/

#define Isdn_get_qsi_name_ident(val_id)		((struct ns_qsi_name_ident_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif /* end of "Name Identification SS supported"} */

#if NS_SS_DIVERSION == ON		/* Diversion SS supported{ */

		/*
		   Isdn_get_div_activation : ARGUMENT of ActivationDiversion operation :

				INPUT : val_id	= value identifier (inside 'ns_activation_diversion_arg' structure).
		*/

#define Isdn_get_div_activation(val_id)		((struct ns_activation_diversion_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_div_deactivation : ARGUMENT of DeactivationDiversion operation :

				INPUT : val_id	= value identifier (inside 'ns_deactivation_diversion_arg' structure).
		*/

#define Isdn_get_div_deactivation(val_id)		((struct ns_deactivation_diversion_arg FAR *)ns_int_ctx.p__val) -> val_id

	/* ActivationStatusNotificationDiv operation ARGUMENT : same as in ActivationDiversion operation */

#define Isdn_get_div_act_stat_notif				Isdn_get_div_activation

	/* DeactivationStatusNotificationDiv operation ARGUMENT : same as in DeactivationDiversion operation */

#define Isdn_get_div_dea_stat_notif				Isdn_get_div_deactivation

	/* InterrogationDiversion operation ARGUMENT : same as in DeactivationDiversion operation */

#define Isdn_get_div_interog_arg				Isdn_get_div_deactivation

		/*
		   Isdn_get_div_interog_res : RESULT of InterrogationDiversion operation
						(it is a list of IntResult instances)

				INPUT : val_id	= value identifier (inside 'ns_diversion_int_result' structure).
		*/

#define Isdn_get_div_interog_res(val_id)		((struct ns_interrogation_diversion_res FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_next_div_int_res : get location of next IntResult instance inside list.
				! THIS MACRO MUST BE CALLED AFTER READING ALL PARAMETERS in current IntResult.
		*/

#define Isdn_set_to_next_div_int_res()		\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Isdn_get_div_interog_res (next_int_result)

		/*
		   Isdn_get_div_interog_s_u_nb : RESULT of InterrogateServedUserNumbers operation
						(it is a list of PartyNumber instances)

				INPUT : val_id	= value identifier (inside 'ns_interog_s_u_nb_div_res' structure).
		*/

#define Isdn_get_div_interog_s_u_nb(val_id)		((struct ns_interog_s_u_nb_div_res FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_next_div_int_s_u_nb : get location of next PartyNumber instance inside list.
				! THIS MACRO MUST BE CALLED AFTER READING ALL PARAMETERS in current PartyNumber.
		*/

#define Isdn_set_to_next_div_int_s_u_nb()		\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Isdn_get_div_interog_s_u_nb (next_party_nb)

		/*
		   Isdn_get_div_info : ARGUMENT of DiversionInformation operation

				INPUT : val_id	= value identifier (inside 'ns_information_div_arg' structure).
		*/

#define Isdn_get_div_info(val_id)		((struct ns_information_div_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_div_deflection : ARGUMENT of CallDeflection operation

				INPUT : val_id	= value identifier (inside 'ns_deflection_div_arg' structure).
		*/

#define Isdn_get_div_deflection(val_id)		((struct ns_deflection_div_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_div_rerouteing : ARGUMENT of CallRerouteing operation

				INPUT : val_id	= value identifier (inside 'ns_rerouteing_div_arg' structure).
		*/

#define Isdn_get_div_rerouteing(val_id)		((struct ns_rerouteing_div_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_div_leg_inf1 : ARGUMENT of DivertingLegInformation1 operation

				INPUT : val_id	= value identifier (inside 'ns_div_leg_info_1_arg' structure).
		*/

#define Isdn_get_div_leg_inf1(val_id)		((struct ns_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_div_leg_inf2 : ARGUMENT of DivertingLegInformation2 operation

				INPUT : val_id	= value identifier (inside 'ns_div_leg_info_2_arg' structure).
		*/

#define Isdn_get_div_leg_inf2(val_id)		((struct ns_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_div_leg_inf3_pres_all : ARGUMENT of DivertingLegInformation3 operation

				OUTPUT : presentationAllowedIndicator.
		*/

#define Isdn_get_div_leg_inf3_pres_all()	((struct ns_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> pres_allow_ind

			/*** Q-SIG specific operations ***/

		/*
		   Isdn_get_qsi_div_activate : ARGUMENT of ActivateDiversionQ operation :

				INPUT : val_id	= value identifier (inside 'ns_qsi_activate_div_arg' structure).
		*/

#define Isdn_get_qsi_div_activate(val_id)		((struct ns_qsi_activate_div_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_div_deactivate : ARGUMENT of DeactivateDiversionQ operation :

				INPUT : val_id	= value identifier (inside 'ns_qsi_dea_div_arg' structure).
		*/

#define Isdn_get_qsi_div_deactivate(val_id)		((struct ns_qsi_dea_div_arg FAR *)ns_int_ctx.p__val) -> val_id

	/* InterrogateDiversionQ operation ARGUMENT : same as in DeactivateDiversionQ operation */

#define Isdn_get_qsi_div_interog_arg			Isdn_get_qsi_div_deactivate

		/*
		   Isdn_get_qsi_div_interog_res : RESULT of InterrogateDiversionQ operation
						(it is a list of IntResult instances)

				INPUT : val_id	= value identifier (inside 'ns_qsi_diversion_int_result' structure).
		*/

#define Isdn_get_qsi_div_interog_res(val_id)	((struct ns_qsi_diversion_int_result FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_qsi_set_to_next_div_int_res : get location of next IntResult instance inside list.
				! THIS MACRO MUST BE CALLED AFTER READING ALL PARAMETERS in current IntResult.
		*/

#define Isdn_qsi_set_to_next_div_int_res()		\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Isdn_get_qsi_div_interog_res (next_int_result)

		/*
		   Isdn_get_qsi_div_chk_rest : ARGUMENT of CheckRestriction operation :

				INPUT : val_id	= value identifier (inside 'ns_qsi_chk_rest_div_arg' structure).
		*/

#define Isdn_get_qsi_div_chk_rest(val_id)		((struct ns_qsi_chk_rest_div_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_div_rerouting : ARGUMENT of CallRerouting operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_rerouting_div_arg' structure).
		*/

#define Isdn_get_qsi_div_rerouting(val_id)		((struct ns_qsi_rerouting_div_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_div_leg_info_1 : ARGUMENT of DivertingLegInformation1 operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_div_leg_info_1_arg' structure).
		*/

#define Isdn_get_qsi_div_leg_info_1(val_id)		((struct ns_qsi_div_leg_info_1_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_div_leg_info_2 : ARGUMENT of DivertingLegInformation2 operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_div_leg_info_2_arg' structure).
		*/

#define Isdn_get_qsi_div_leg_info_2(val_id)		((struct ns_qsi_div_leg_info_2_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_div_leg_info_3 : ARGUMENT of DivertingLegInformation3 operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_div_leg_info_3_arg' structure).
		*/

#define Isdn_get_qsi_div_leg_info_3(val_id)		((struct ns_qsi_div_leg_info_3_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif /* end of "Diversion SS supported"} */

#if NS_SS_EXPL_CHAN_RESERVATION == ON	/* Explicit Channel Reservation function supported{ */

		/*
		   Isdn_get_chan_res_create_arg : ARGUMENT of ExplicitReservationCreationControl operation

				OUTPUT : controlOption.
		*/

#define Isdn_get_chan_res_create_arg()		((struct ns_exp_ch_res_create_arg FAR *)ns_int_ctx.p__val) -> control_option

		/*
		   Isdn_get_chan_res_create_res : RESULT of ExplicitReservationCreationControl operation
		   Isdn_get_chan_res_manage_arg : ARGUMENT of ExplicitReservationManagement operation
		   Isdn_get_chan_res_cancel_arg : ARGUMENT of ExplicitReservationCancel operation

				OUTPUT : ReservationIndicator.
		*/

#define Isdn_get_chan_res_create_res()		((struct ns_exp_ch_res_all_op FAR *)ns_int_ctx.p__val) -> reservation_ind

#define Isdn_get_chan_res_manage_arg		Isdn_get_chan_res_create_res
#define Isdn_get_chan_res_cancel_arg		Isdn_get_chan_res_create_res

#endif /* end of "Explicit Channel Reservation function supported"} */

#if NS_SS_CONFERENCE == ON	/* Conference call SS supported{ */

		/*
		   Isdn_get_conf_begin_arg : ARGUMENT of BeginCONF operation

				OUTPUT : ConfSize.
		*/

#define Isdn_get_conf_begin_arg()		((struct ns_conf_begin_arg FAR *)ns_int_ctx.p__val) -> conf_size

		/*
		   Isdn_get_conf_begin_res : RESULT of BeginCONF operation
		   Isdn_get_conf_split_arg : ARGUMENT of SplitCONF operation

				INPUT : val_id	= value identifier (inside 'ns_conf_begin_res' structure).
		*/

#define Isdn_get_conf_begin_res(val_id)		((struct ns_conf_begin_res FAR *)ns_int_ctx.p__val) -> val_id

#define Isdn_get_conf_split_arg				Isdn_get_conf_begin_res

		/*
		   Isdn_get_conf_add_arg : ARGUMENT of AddCONF operation 

				OUTPUT : ConferenceId.
		*/

#define Isdn_get_conf_add_arg()		((struct ns_conf_add_arg FAR *)ns_int_ctx.p__val) -> conf_id

		/*
		   Isdn_get_conf_add_res : RESULT of AddCONF operation
		   Isdn_get_conf_other_op_arg : ARGUMENT of DropCONF, IsolateCONF,
										ReattachCONF, PartyDISC 
										or IdentifyConferee operations :

				OUTPUT : PartyId.  
		*/

#define Isdn_get_conf_add_res				Isdn_get_conf_other_op_arg

#define Isdn_get_conf_other_op_arg()		((struct ns_conf_add_res_or_other_arg FAR *)ns_int_ctx.p__val) -> party_id

#endif /* end of Conference call SS supported} */

#if NS_SS_USER_USER_EXP == ON	/* explicit requests for User-to-User Signalling SS supported{ */

		/*
		   Isdn_get_uus_rq_arg : ARGUMENT of UserUserService and UUSRequest operations :

				INPUT : val_id	= value identifier (inside 'ns_uus_rq_arg' structure).
		*/

#define Isdn_get_uus_rq_arg(val_id)		((struct ns_uus_rq_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif	/* end of "explicit requests for User-to-User Signalling SS supported"} */

#if NS_SS_ECT == ON			/* Explicit Call Transfer supported{ */

		/*
		   Isdn_get_ect_inform_arg : ARGUMENT of EctInform operation

				INPUT : val_id	= value identifier (inside 'ns_ect_inform_arg' structure).
		*/

#define Isdn_get_ect_inform_arg(val_id)		((struct ns_ect_inform_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_ect_lk_id_rq_res : RESULT of EctLinkIdRequest operation

				OUTPUT : Link ID
		*/

#define Isdn_get_ect_lk_id_rq_res()		((struct ns_ect_lk_id_rq_res FAR *)ns_int_ctx.p__val) -> link_id

		/*
		   Isdn_get_ect_loop_test_arg : ARGUMENT of EctLoopTest operation

				OUTPUT : Call Transfer Identity
		*/

#define Isdn_get_ect_loop_test_arg()	((struct ns_ect_loop_test_arg FAR *)ns_int_ctx.p__val) -> call_trf_id

		/*
		   Isdn_get_ect_loop_test_res : RESULT of EctLoopTest operation

				OUTPUT : loop result
		*/

#define Isdn_get_ect_loop_test_res()	((struct ns_ect_loop_test_res FAR *)ns_int_ctx.p__val) -> loop_result

		/*
		   Isdn_get_ect_exp_exec_arg : ARGUMENT of ExplicitEctExecute operation

				OUTPUT : Link ID
		*/

#define Isdn_get_ect_exp_exec_arg()		((struct ns_ect_explicit_exec_arg FAR *)ns_int_ctx.p__val) -> link_id

		/*
		   Isdn_get_ect_sa_trf_arg : ARGUMENT of SubaddressTransfer operation

				INPUT : val_id	= value identifier (inside 'ns_ect_subadd_trf_arg' structure).
		*/

#define Isdn_get_ect_sa_trf_arg(val_id)		((struct ns_ect_subadd_trf_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif	/* end of "Explicit Call Transfer supported"} */

#if (NS_SS_CALL_TRANSFER == ON) || (NS_SS_PATH_REPLACEMENT == ON)	/* Call Transfer SS or Path Replacement ANF supported{ */

		/*
		   Isdn_get_qsi_trf_ident_res : RESULT of CallTransferIdentify operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_trf_identify_res' structure).
		*/

#define Isdn_get_qsi_trf_ident_res(val_id)		((struct ns_qsi_trf_identify_res FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_trf_init_arg : ARGUMENT of CallTransferInitiate, PathReplacePropose
			and PathReplaceRetain operations = same as RESULT of CallTransferIdentify operation
		*/

#define Isdn_get_qsi_trf_init_arg(val_id)		Isdn_get_qsi_trf_ident_res(val_id)		

		/*
		   Isdn_get_qsi_trf_setup_arg : ARGUMENT of CallTransferSetup and PathReplaceSetup operations

				INPUT : val_id	= value identifier (inside 'ns_qsi_trf_setup_arg' structure).
		*/

#define Isdn_get_qsi_trf_setup_arg(val_id)		((struct ns_qsi_trf_setup_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif /* end of "NS_SS_CALL_TRANSFER = ON or NS_SS_PATH_REPLACEMENT == ON"} */

#if NS_SS_CALL_TRANSFER == ON /* Call Transfer SS supported{ */

		/*
		   Isdn_get_qsi_trf_active_arg : ARGUMENT of CallTransferActive operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_trf_active_arg' structure).
		*/

#define Isdn_get_qsi_trf_active_arg(val_id)		((struct ns_qsi_trf_active_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_trf_complete_arg : ARGUMENT of CallTransferComplete operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_trf_complete_arg' structure).
		*/

#define Isdn_get_qsi_trf_complete_arg(val_id)		((struct ns_qsi_trf_complete_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_trf_update_arg : ARGUMENT of CallTransferUpdate operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_trf_update_arg' structure).
		*/

#define Isdn_get_qsi_trf_update_arg(val_id)		((struct ns_qsi_trf_update_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_trf_subadd_arg : ARGUMENT of SubaddressTransfer operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_trf_subadd_arg' structure).
		*/

#define Isdn_get_qsi_trf_subadd_arg(val_id)		((struct ns_qsi_trf_subadd_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif /* end of "Call Transfer SS supported"} */

#if (NS_SS_CALL_OFFER == ON) || (NS_SS_DO_NOT_DISTURB == ON) || (NS_SS_CALL_INTRUSION == ON) /* { */

		/*
		   Isdn_get_qsi_path_retain_arg : ARGUMENT of PathRetain operation
		   Isdn_get_qsi_srv_avail_arg : ARGUMENT of ServiceAvailable operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_path_service_arg' structure).
		*/

#define Isdn_get_qsi_path_retain_arg(val_id)		((struct ns_qsi_path_service_arg FAR *)ns_int_ctx.p__val) -> val_id

#define Isdn_get_qsi_srv_avail_arg					Isdn_get_qsi_path_retain_arg

#endif /* end of "Call Offer or Do Not Disturb or Call Intrusion SS supported"} */

#if NS_SS_DO_NOT_DISTURB == ON	/* Do Not Disturb SS supported{ */

		/*
		   Isdn_get_qsi_dnd_activ_arg : ARGUMENT of doNotDisturbActivateQ operation
										ARGUMENT of doNotDisturbDeactivateQ operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_dnd_activate_arg' structure).
		*/

#define Isdn_get_qsi_dnd_activ_arg(val_id)		((struct ns_qsi_dnd_activate_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_dnd_activ_res : RESULT of doNotDisturbActivateQ operation
										RESULT of doNotDisturbInterrogateQ operation
		   		List of instances in status (if any) may be read with macros below.

				INPUT : val_id	= value identifier (inside 'ns_qsi_dnd_activate_res' structure).
		*/

#define Isdn_get_qsi_dnd_activ_res(val_id)		((struct ns_qsi_dnd_activate_res FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_qsi_first_dnd_stat : get location of first instance in status inside
				RESULT of doNotDisturbActivateQ or doNotDisturbInterrogateQ operation.
				! THIS MACRO MUST BE CALLED AFTER READING ALL OTHER PARAMETERS IN RESULT.
		*/

#define Isdn_set_to_qsi_first_dnd_stat()	\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Isdn_get_qsi_dnd_activ_res (status_offset)

		/*
		   Isdn_get_qsi_dnd_status : 1 instance in status inside RESULT of
							doNotDisturbActivateQ or doNotDisturbInterrogateQ operation.

				INPUT : val_id	= value identifier (inside 'ns_qsi_dnd_status_instance' structure).
		*/

#define Isdn_get_qsi_dnd_status(val_id)		((struct ns_qsi_dnd_status_instance FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_qsi_next_dnd_stat : get location of next instance in status.
				! THIS MACRO MUST BE CALLED AFTER READING ALL PARAMETERS in current instance.
		*/

#define Isdn_set_to_qsi_next_dnd_stat()	\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Isdn_get_qsi_dnd_status (next_instance)

		/*
		   Isdn_get_qsi_dnd_inter_arg : ARGUMENT of doNotDisturbInterrogateQ operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_dnd_interog_arg' structure).
		*/

#define Isdn_get_qsi_dnd_inter_arg(val_id)		((struct ns_qsi_dnd_interog_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_dnd_over_arg : ARGUMENT of doNotDisturbOverrideQ operation

				INPUT : val_id	= value identifier (inside 'ns_qsi_dnd_override_arg' structure).
		*/

#define Isdn_get_qsi_dnd_over_arg(val_id)		((struct ns_qsi_dnd_override_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif /* end of "Do Not Disturb SS supported"} */

#if NS_SS_CALL_INTRUSION == ON	/* Call intrusion SS supported{ */

		/*
		   Isdn_get_qsi_ci_request : ARGUMENT or RESULT of CallIntrusionRequest operation :
		   Isdn_get_qsi_ci_getcipl : ARGUMENT of CallIntrusionGetCIPL operation :

				INPUT : val_id	= value identifier (inside 'ns_qsi_ci_request_get_cipl' structure).
		*/

#define Isdn_get_qsi_ci_request(val_id)			((struct ns_qsi_ci_request_get_cipl FAR *)ns_int_ctx.p__val) -> val_id

#define Isdn_get_qsi_ci_getcipl					Isdn_get_qsi_ci_request

#endif	/* end of "Call intrusion SS supported"} */

#if NS_SS_FREEPHONE == ON		/* Freephone supported{ */

		/*
		   Isdn_get_fph_call_arg : ARGUMENT of CallFPH operation :

				INPUT : val_id	= value identifier (inside 'ns_fph_call_arg' structure).
		*/

#define Isdn_get_fph_call_arg(val_id)			((struct ns_fph_call_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_fph_monitor_t_arg : ARGUMENT of Monitor-T-FPH operation :

				INPUT : val_id	= value identifier (inside 'ns_fph_monitor_t_arg' structure).
		*/

#define Isdn_get_fph_monitor_t_arg(val_id)		((struct ns_fph_monitor_t_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_fph_free_t_arg : ARGUMENT of Free-T-FPH operation :

				INPUT : val_id	= value identifier (inside 'ns_fph_free_t_arg' structure).
		*/

#define Isdn_get_fph_free_t_arg(val_id)			((struct ns_fph_free_t_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_fph_call_t_arg : ARGUMENT of Call-T-FPH operation :

				INPUT : val_id	= value identifier (inside 'ns_fph_call_t_arg' structure).
		*/

#define Isdn_get_fph_call_t_arg(val_id)			((struct ns_fph_call_t_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif	/* end of "Freephone supported"} */

#if NS_SS_CCBS == ON		/* Completion of Calls to Busy Subscriber supported{ */

		/*
		   Isdn_get_ccbs_info_ret_arg : ARGUMENT of CallInfoRetain operation :
		   Isdn_get_ccbs_eras_lk_id_arg : ARGUMENT of EraseCallLinkageID operation :

				OUTPUT : call linkage ID
		*/

#define Isdn_get_ccbs_info_ret_arg()	((struct ns_ccbs_call_inf_eras_lk_arg FAR *)ns_int_ctx.p__val) -> linkage_id

#define Isdn_get_ccbs_eras_lk_id_arg	Isdn_get_ccbs_info_ret_arg

		/*
		   Isdn_get_ccbs_dea_arg : ARGUMENT of CCBSDeactivate operation :
		   Isdn_get_ccbs_call_arg : ARGUMENT of CCBSCall operation :
		   Isdn_get_ccbs_stop_alert_arg : ARGUMENT of CCBSStopAlerting operation :

				OUTPUT : CCBS reference
		*/

#define Isdn_get_ccbs_dea_arg()			((struct ns_ccbs_dea_call_stop_al_arg FAR *)ns_int_ctx.p__val) -> reference

#define Isdn_get_ccbs_call_arg			Isdn_get_ccbs_dea_arg
#define Isdn_get_ccbs_stop_alert_arg	Isdn_get_ccbs_dea_arg

		/*
		   Isdn_get_ccbs_rq_arg : ARGUMENT of CCBSRequest operation :

				OUTPUT : call linkage ID
		*/

#define Isdn_get_ccbs_rq_arg()	((struct ns_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> linkage_id

		/*
		   Isdn_get_ccbs_rq_res : RESULT of CCBSRequest operation :

				INPUT : val_id	= value identifier (inside 'ns_ccbs_request_res' structure).
		*/

#define Isdn_get_ccbs_rq_res(val_id)	((struct ns_ccbs_request_res FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_ccbs_stat_rq_arg : ARGUMENT of CCBSStatusRequest operation :

				INPUT : val_id	= value identifier (inside 'ns_ccbs_status_rq_arg' structure).
		*/

#define Isdn_get_ccbs_stat_rq_arg(val_id)	((struct ns_ccbs_status_rq_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_ccbs_stat_rq_res : RESULT of CCBSStatusRequest operation :

				OUTPUT : free/busy indicator
		*/

#define Isdn_get_ccbs_stat_rq_res()	((struct ns_ccbs_status_rq_res FAR *)ns_int_ctx.p__val) -> free

		/*
		   Isdn_get_ccbs_r_free_arg : ARGUMENT of CCBSRemoteUserFree operation :
		   Isdn_get_ccbs_bfree_arg : ARGUMENT of CCBSBFree operation :

				INPUT : val_id	= value identifier (inside 'ns_ccbs_b_remote_free_arg' structure).
		*/

#define Isdn_get_ccbs_r_free_arg(val_id)	((struct ns_ccbs_b_remote_free_arg FAR *)ns_int_ctx.p__val) -> val_id

#define Isdn_get_ccbs_bfree_arg		Isdn_get_ccbs_r_free_arg

		/*
		   Isdn_get_ccbs_erase_arg : ARGUMENT of CCBSErase operation :

				INPUT : val_id	= value identifier (inside 'ns_ccbs_erase_arg' structure).
		*/

#define Isdn_get_ccbs_erase_arg(val_id)		((struct ns_ccbs_erase_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_ccbs_interog_arg : ARGUMENT of CCBSInterrogate operation :

				INPUT : val_id	= value identifier (inside 'ns_ccbs_interog_arg' structure).
		*/

#define Isdn_get_ccbs_interog_arg(val_id)		((struct ns_ccbs_interog_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_ccbs_interog_res : RESULT of CCBSInterrogate operation :

				INPUT : val_id	= value identifier (inside 'ns_ccbs_interog_res' structure).
		*/

#define Isdn_get_ccbs_interog_res(val_id)		((struct ns_ccbs_interog_res FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_first_ccbs_call : get location of first call information inside
				RESULT of CCBSInterrogate operation. ! THIS MACRO MUST BE CALLED
				AFTER READING ALL PARAMETERS IN RESULT.
		*/

#define Isdn_set_to_first_ccbs_call()	\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Isdn_get_ccbs_interog_res (first_call_info)

		/*
		   Isdn_get_ccbs_call_info : call information inside RESULT of
										CCBSInterrogate operation (CallInformation)

				INPUT : val_id	= value identifier (inside 'ns_ccbs_call_info' structure).
		*/

#define Isdn_get_ccbs_call_info(val_id)		((struct ns_ccbs_call_info FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_set_to_next_ccbs_call : get location of next call information.
				! THIS MACRO MUST BE CALLED AFTER READING ALL PARAMETERS in current unit.
		*/

#define Isdn_set_to_next_ccbs_call()	\
	ns_int_ctx.p__val = ns_int_ctx.p__ss_data + Isdn_get_ccbs_call_info (next_call_info)

		/*
		   Isdn_get_ccbs_t_rq_arg : ARGUMENT of CCBS-T-Request operation :

				INPUT : val_id	= value identifier (inside 'ns_ccbs_t_rq_arg' structure).
		*/

#define Isdn_get_ccbs_t_rq_arg(val_id)	((struct ns_ccbs_t_rq_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_ccbs_t_rq_res : RESULT of CCBS-T-Request operation :

				OUTPUT : retention suppported
		*/

#define Isdn_get_ccbs_t_rq_res()	((struct ns_ccbs_t_rq_res FAR *)ns_int_ctx.p__val) -> retention_supp

		/*
		   Isdn_get_qsi_ccbs_rq_arg : ARGUMENT of CcbsRequest, CcnrRequest, CcCancel and CcExecPossible operations

				INPUT : val_id	= value identifier (inside 'ns_qsi_ccbs_request_arg' structure).
		*/

#define Isdn_get_qsi_ccbs_rq_arg(val_id)	((struct ns_qsi_ccbs_request_arg FAR *)ns_int_ctx.p__val) -> val_id

		/*
		   Isdn_get_qsi_ccbs_rq_res : RESULT of CcbsRequest and CcnrRequest operations

				INPUT : val_id	= value identifier (inside 'ns_qsi_ccbs_request_res' structure).
		*/

#define Isdn_get_qsi_ccbs_rq_res(val_id)	((struct ns_qsi_ccbs_request_res FAR *)ns_int_ctx.p__val) -> val_id

#endif	/* end of "Completion of Calls to Busy Subscriber supported"} */

#if NS_SS_INTERACTIONS == ON	/* Supplementary service interactions{ */

#if (NS_SS_AOC_E == ON)	&& ((NS_SS_DIVERSION == ON) || (NS_SS_ECT == ON))	/* AOC-E SS and (Diversion or ECT SS) supported */

		/*
		   Isdn_get_id_of_charge_arg : ARGUMENT of IdentificationOfCharge operation :

				INPUT : val_id	= value identifier (inside 'ns_interact_id_of_charge_arg' structure).
		*/

#define Isdn_get_id_of_charge_arg(val_id)	((struct ns_interact_id_of_charge_arg FAR *)ns_int_ctx.p__val) -> val_id

#endif	/* end of AOC-E SS and (Diversion or ECT SS) supported */

#endif	/* end of Supplementary service interactions} */

#endif	/* end of "ifndef NS_SS_MAC_H" */

/*EOF*/

