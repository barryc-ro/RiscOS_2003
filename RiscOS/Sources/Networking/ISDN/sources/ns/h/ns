
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns.h
 *
 * $Revision$
 *
 * $Date$
 *
 * Header implementing the common declaration of the Network Signalling
 * entity NS and of the layer management MNS.
 *
 * Content :	- General common variables
 *				- Information element internal structures
 *				- Trap management
 *				- General macros
 *				- Timers management
 *				- Call access tables (for speed optimization)
 *				- Segmentation management
 *				- Network access management
 *				- Data link management
 *				- Call connection management
 *				- Event management
 *				- Error management
 *				- IE management
 *				- Metaprogram language management
 *				- SSDU management
 *				- SPDU management
 *				- External declarations and prototypes
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "services.h"								/* SERVICES header */
#include "ns_int.h"									/* NS upper interface */
#include "dl_int.h"									/* DL upper interface */
#include "ns_i_s.h"									/* NS internal structures */

/*-------------------------------------------------------------------------*/

						/*
						 * For compatibility purpose,
						 * if a flag is unknown, define it to OFF.
						 */

#ifndef F_A17
#	define F_A17						OFF
#endif
#ifndef F_A11
#	define F_A11						OFF
#endif
#ifndef F_AT4
#	define F_AT4						OFF
#endif
#ifndef F_AT5
#	define F_AT5						OFF
#endif
#ifndef F_AT9
#	define F_AT9						OFF
#endif
#ifndef F_AU1
#	define F_AU1						OFF
#endif
#ifndef F_BIP
#	define F_BIP						OFF
#endif
#ifndef F_BT2
#	define F_BT2						OFF
#endif
#ifndef F_BV1
#	define F_BV1						OFF
#endif
#ifndef F_DMS
#	define F_DMS						OFF
#endif
#ifndef F_DRV
#	define F_DRV						OFF
#endif
#ifndef F_ETS
#	define F_ETS						OFF
#endif
#ifndef F_E10
#	define F_E10						OFF
#endif
#ifndef F_HKT
#	define F_HKT						OFF
#endif
#ifndef F_KDD
#	define F_KDD						OFF
#endif
#ifndef F_NI1
#	define F_NI1						OFF
#endif
#ifndef F_NI2
#	define F_NI2						OFF
#endif
#ifndef F_NTT
#	define F_NTT						OFF
#endif
#ifndef F_QSI
#	define F_QSI						OFF
#endif
#ifndef F_SWD
#	define F_SWD						OFF
#endif
#ifndef F_TR6
#	define F_TR6						OFF
#endif
#ifndef F_VN2
#	define F_VN2						OFF
#endif
#ifndef F_VN3
#	define F_VN3						OFF
#endif
#ifndef F_VN6
#	define F_VN6						OFF
#endif

#ifndef MX_PCS_USER
#	define	MX_PCS_USER					1
#endif
#ifndef MX_USER_PCS
#	define	MX_USER_PCS					1
#endif
#ifndef NS_IE_TSP_OUT
#	define	NS_IE_TSP_OUT				OFF
#endif
#ifndef NS_IE_TSP_IN
#	define	NS_IE_TSP_IN				OFF
#endif
#ifndef MX_PRECEDENCE_LEVEL
#	define	MX_PRECEDENCE_LEVEL			1
#endif
#ifndef	MX_TRAVELING_CLASS_MARK
#	define	MX_TRAVELING_CLASS_MARK		1
#endif
#ifndef	MX_USER_ENTERED_CODE
#	define	MX_USER_ENTERED_CODE		1
#endif
#ifndef	MX_CHANGE_STATUS
#	define	MX_CHANGE_STATUS			1
#endif
#ifndef NS_MAINTENANCE_CAPABILITY
#	define	NS_MAINTENANCE_CAPABILITY	OFF
#endif

#undef MX_ENDPOINT_ID
#define	MX_ENDPOINT_ID					2

#ifndef	TI_DL_EST_VAL
#	define TI_DL_EST_VAL				(1  * SECOND)
#endif

#ifndef NS_D_BACKUP
#	define	NS_D_BACKUP					OFF
#endif

/*-------------------------------------------------------------------------*/

	/*
	 * General types used in prototypes
	 * They could already be defined in services.h
	 */

#if NEW_FCT_STYLE == ON
#	ifndef Void_parm
#		define Void_parm	void
#	endif
#else
#	ifndef Void_parm
#		define Void_parm
#	endif
#endif

/*-------------------------------------------------------------------------*/

	/* GENERAL DEFINITIONS for PIC (Position Independent Code) */

#define Ns_tab_tabl_entry(idx, tab)		{idx, sizeof(tab), (uchar *)Pic_address (tab)}
#define Ns_tabx_list_entry(tab)			{sizeof(tab), (uchar *)Pic_address (tab)}
#define Ns_tab_tabx_entry(idx, tab)		{idx, sizeof(tab) / sizeof(struct tabx_list), (struct tabx_list *)Pic_address (tab)}
#define Ns_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off)	{codes, ie, (uchar *)Pic_address (mp_a), sizeof (struct i_str), (uchar *)Pic_address (i_str), (uchar *)Pic_address (df_spdu), (uchar *)Pic_address (df_ssdu), mx, off}
#define Ns_tab_spdu_entry(pr, ev, u_n, n_u, usa, t_ie, t_so_ie)			{pr, ev, u_n, n_u, usa, Pic_address (t_ie), Pic_address (t_so_ie)}
#define Ns_tab_spdu_maint_e(pr, ev, u_n, n_u, usa, t_ie, t_so_ie, prot)	{pr, ev, u_n, n_u, usa, Pic_address (t_ie), Pic_address (t_so_ie), prot}
#define Ns_tab_ssdu_ie_entry(codes, ie, pr, o_m, mp_a)			{codes, ie, pr, o_m, (uchar *)Pic_address (mp_a)}
#define Ns_tab_ssdu_ie_mx_entry(codes, ie, pr, o_m, mp_a, mx)	{codes, ie, pr, o_m, (uchar *)Pic_address (mp_a), mx}

#if EQUIPMENT == TE
#	define Ns_tab_ssdu_entry(pr, u_n, p_ie, nb_ie)						{pr, u_n, (struct ssdu_ie *)Pic_address (p_ie), nb_ie}
#else
#	define Ns_tab_ssdu_entry(pr, u_n, p_ie, nb_ie, p_nt_ie, nb_nt_ie)	{pr, u_n, (struct ssdu_ie *)Pic_address (p_ie), nb_ie, (struct ssdu_ie *)Pic_address (p_nt_ie), nb_nt_ie}
#endif

/*-------------------------------------------------------------------------*/

						/* NS GENERAL COMMON VARIABLES */

#if SIMULATION == OFF

#	define	event_id		event_id_ns				/* event identifier */
#	define	ret_code		ret_code_ns				/* return code */
#	define 	p_snd_msg		p_snd_msg_ns			/* pointer on the current message to send if any */
#	define 	p_rcv_msg		p_rcv_msg_ns			/* pointer on the current received message if any */
#	define 	p_buffer		p_buffer_ns				/* pointer on the curent buffer if any */
#	define 	p_buffer_end	p_buffer_end_ns			/* pointers on the end of the current buffer if any */
#	define 	os_err			os_err_ns				/* OS error code */

#endif

#define	Set_err(a,b)		b

		/* Network dependent procedure parameters (ON/OFF and 'value' table) */

struct net_proc_param {
	uchar		config_type_timer_dependance;		/* timers values depend from the configuration type (POINT_TO_POINT or POINT_TO_MULTIPOINT) */
	uchar		ie_comprehension_required;			/* IE "comprehension required" test are needed */
	uchar		send_state_cause_filter;			/* the sending a STATUS message is filtered according cause value */
	uchar		ns_dl_failure_int_call_clear;		/* clear internal call when data link failure */

#	if EQUIPMENT == NT2
		uchar	internal_timers;					/* internal timers implemented */
#	endif

#	if NS_MAINTENANCE_CAPABILITY == ON
		uchar		nfas_support;					/* NFAS support */
#	endif

	uchar		info_rq_conn_id_mgt;				/* NS_INFO_RQ primitive is acccepted with conn ID set to CONN_ID_MANAGEMENT (for dummy call ref) */
	uchar		fac_rq_conn_id_mgt;					/* NS_FAC_RQ primitive is acccepted with conn ID set to CONN_ID_MANAGEMENT (for dummy call ref) */
	uchar		notify_rq_conn_id_mgt;				/* NS_NOTIFY_RQ primitive is acccepted with conn ID set to CONN_ID_MANAGEMENT (for dummy call ref) */
};

#define	Net_param_cfg_type_timer_dependance		(Tab_net_proc_param[0].config_type_timer_dependance)
#define	Net_param_ie_comprehension_required		(Tab_net_proc_param[0].ie_comprehension_required)
#define	Net_param_send_state_cause_filter		(Tab_net_proc_param[0].send_state_cause_filter)
#define Net_param_ns_dl_failure_int_call_clear	(Tab_net_proc_param[0].ns_dl_failure_int_call_clear)

#if EQUIPMENT == NT2
#	define	Net_param_internal_timers			(Tab_net_proc_param[0].internal_timers)
#endif

#if NS_MAINTENANCE_CAPABILITY == ON
#	define Net_param_nfas_support				(Tab_net_proc_param[0].nfas_support)
#endif

#define Net_param_info_rq_conn_id_mgt			(Tab_net_proc_param[0].info_rq_conn_id_mgt)
#define Net_param_fac_rq_conn_id_mgt			(Tab_net_proc_param[0].fac_rq_conn_id_mgt)
#define Net_param_notify_rq_conn_id_mgt			(Tab_net_proc_param[0].notify_rq_conn_id_mgt)

#define In_range_strict_h(val,l,h)  ((l > h) ? ((l <= val)  || (val < h))   : ((l <= val)   && (val < h)))

			/* LIFO manipulation using the p_next location. */

#define Lifo_put_object(p_lifo_first, p_object) \
	p_object -> p_next = p_lifo_first;          \
	p_lifo_first    = p_object

#define Lifo_get_object(p_lifo_first, p_object) \
	if ((p_object = p_lifo_first) !=  P_NIL) {  \
		p_lifo_first = (p_object) -> p_next;    \
	}

			/* number of items in a Table (any Type of item) */

#define Ns_tab_item_nb(tab_id)					(sizeof (tab_id) / sizeof (tab_id[0]))

/*==========================================================================

				- Network information element descriptions -
							Internal Structures
*/

#define I_(ie,field)	((((struct Paste(i_,ie) FAR *)&Paste(i_,ie)[0]) + i_ie_x) -> field)

#if MESSAGE_HEADER_IE == ON

		/* Message header IEs internal structure definition */

	struct i_message_header {
		uchar		protocol_discr;
		uchar		call_ref_lgth;
		uchar		call_ref_flag;
		uchar		call_ref_val;
		uchar		call_ref_val_ext;		/* for PRI access */
		uchar		message_type;
	};

	extern struct i_message_header	i_message_header;

#endif

	/* SIZING CONSTANTS */

#if EQUIPMENT == NT2
	typedef	unsigned long				call_ref_t;	/* call reference internal type for (call ref, ces) */
#else
	typedef	unsigned int				call_ref_t;	/* call reference internal type for call ref only */
#endif

#define MX_IND_BUFFER_SIZE				260			/* maximum size of internal indirect buffer */

extern uchar 							drc;		/* dummy ret code to avoid a compilation warning. Used when the function return is not used. */

/*=========================================================================*/

						/* TRAP MANAGEMENT */

			/*
			   TRAP code : trap function is called if and inconsistancy
						   is detected inside the sofware, generally due
						   to a bug. Trap function must freeze the
						   situation and dump it to some permanent support
						   in order to fix the bug.
			*/

#define TRAP_CC_CODE					301			/* abnormal code in message coming from CC */
#define TRAP_MNS_CODE					302			/* abnormal code in message comming from  MNS */
#define TRAP_IE_INCONSISTENCY			303			/* IE code inconsistency */
#define TRAP_R_EXEC						304			/* inconsistency in r_exec code */
#define TRAP_NS_INIT					305			/* error in initialization of NS */
#define TRAP_SPDU						306			/* inconsistent internal data to create a spdu message */
#define TRAP_MX_REPETITION				307			/* inconsistency in the number of repeated IE */
#define TRAP_LC_INCONSISTENCY			308			/* reveived event not consistent with the Link Connection state */
#define TRAP_UNKNOWN_CALL_STATE			309			/* unknown call state or auxiliary call state in NS entity */
#define TRAP_SSDU						310			/* inconsistent ssdu (internal structure) */
#define TRAP_NS_ERR_UNEXPECTED  		311			/* unexpected error code in error condition handling procedure */
#define TRAP_NS_ERR_ENTITY				312			/* origination entity unexpected in error condition handling procedure */
#define TRAP_NS_RCVE_TI					313			/* invalid TIme out message */
#define TRAP_IE_TYPE					314			/* no processing for the IE conditional type in ie_type_eval() */
#define TRAP_TAB_SPDU_INCONSISTENCY		315			/* inconsistency for access to tab_spdu */
#define TRAP_TAB_SSDU_INCONSISTENCY		316			/* inconsistency for access to tab_ssdu */
#define TRAP_TAB_IE_INCONSISTENCY		317			/* inconsistency for access to tab_ie */
#define TRAP_TAB_TABL_UNORDERED			318			/* unordered tab_tabl */
#define TRAP_TAB_TABX_UNORDERED			319			/* unordered tab_tabx */
#define TRAP_X_IE_SATURATION			320			/* overflow area saturated in x_tab_ie */
#define TRAP_STATE_NO_CALL				321			/* no current call in the switch state */
#define TRAP_TIMER_CONN_ID_UNKNOWN		322			/* NS has received a time-out message with an unknown ID */
#define TRAP_S_SPDU						323			/* SPDU not to send */
#define TRAP_NS_FG						324			/* functional grouping and equipment option incompatible */
#define TRAP_NO_SAVED_SPDU				325			/* no SPDU buffer previously saved */
#define TRAP_ALREADY_SAVED_SPDU			326			/* a saved SPDU buffer already exist in the Call context */
#define TRAP_NS_BROADCAST				327			/* abnormal primitive code in a broadcast connection */
#define TRAP_NO_CES						328			/* no available ces */
#define TRAP_DL_CODE					329			/* abnormal code in message comming from DL */
#define TRAP_SKIP_LEVEL					330			/* skip level error */
#define TRAP_TIMER_CES_UNKNOWN			331			/* timer message received with an unknown CES */
#define TRAP_NO_TABLE_AVAILABLE			332			/* there is no table available for the given table id (tab_tabl or tab_tabx tables) */
#define TRAP_EI_STATE					333			/* unknown Endpoint Initialization state */
#define TRAP_CALL_REF_TYPE				334			/* call reference type inconstency */
#define TRAP_MX_INT_SATURATION			335			/* no more place in internal process (NT2) context for timer allocation */
#define TRAP_NS_TOO_LONG_IE				336			/* IE is too long for one segment */
	/* !!! TRAP_NS_DATA_AREA_TOO_SMALL = 337 : defined in ns_mac.h -> used at NS interface */
#define TRAP_NS_FIFO					338			/* inconsistency during NS internal fifo manipulation */
#define TRAP_NS_SS_INCONSISTENCY		339			/* inconsistency in Supplementary Services description */
#define TRAP_NS_ERROR					399			/* unknown NS error or inconsistence in error description */

/*-------------------------------------------------------------------------*/

						/* NS MACRO'S */

			/* IE access macro's */

#define Inc_get_ie_octet							(*(++p_ie))
#define Get_inc_ie_octet    						(*(p_ie++))
#define Get_ie_octet    							(*p_ie)
#define Get_p_ie									(p_ie)

#define Set_p_ie(xx)								p_ie = xx
#define Inc_p_ie(xx)								p_ie += xx
#define Dec_p_ie(xx)								p_ie -= xx
#define Remainder_ie_octet							(p_ie_end - p_ie)
#define Eo_ie										(p_ie == p_ie_end)  /* test End of IE */

#define Put_ie_octet(xx)							*p_ie = xx
#define Put_inc_ie_octet(xx)						*p_ie++ = xx
#define Put_ie_field(p, lgth, field)				*p_ie = ( (*p_ie & ( (uchar)(~((lgth)<<(p)) ) ) ) | ( ((field)&(lgth)) << (p) ) )

#define	Reset_ext_bit(xx)							((xx) &= 0x7F)
#define	Set_ext_bit(xx)								((xx) |= 0x80)

			/* Send macro's */

#define USE_SAVED_SPDU								'U'
#define SAVE_SPDU									'S'
#define DO_NOT_SEND									'N'

#define Send_to_dl(prim_code, ces)					ns_snd_dl (prim_code, ces)			/* send a primitive to DL_D entity */

#define Send_to_call_control(ssdu_id)				ns_snd_cc (ssdu_id)					/* send to Call Control entity (CC) */

#if NS_HOLD_RETRIEVE == ON
#	define Ns_send_hold_ret_abort_in(cause)			ns_snd_hold_ret_abort_user (cause)		/* send ABORT indication to upper entity */
#endif

#define Send_to_d_channel(spdu_id)					ns_snd_da (spdu_id, OFF, 0)			/* send to D channel using LAPD */
#define Send_to_d_channel_proto(spdu_id, proto)		ns_snd_da (spdu_id, OFF, proto)		/* send to D channel using LAPD on a specific protocol discriminator */
#define Send_to_d_channel_and_save_spdu(spdu_id)	ns_snd_da (spdu_id, SAVE_SPDU, 0)	/* send and save */
#define Send_to_d_channel_and_stop_spdu(spdu_id)	ns_snd_da (spdu_id, DO_NOT_SEND, 0)
#define Send_saved_spdu_to_d_channel(spdu_id)   	ns_snd_da (spdu_id, USE_SAVED_SPDU, 0)/* send saved spdu */

#define Release_saved_spdu()						Free_buffer (Call_save_spdu); \
													Call_save_spdu = P_NIL

			/* Transmit direction */

#define TO_D_CHANNEL				10				/* to D channel */
#define FROM_D_CHANNEL				11				/* from D channel */

#define TO_CALL_CONTROL				12				/* to call control application */
#define FROM_CALL_CONTROL			13				/* from call control application */

			/* Test of direction according to the equipment and its function */

#if EQUIPMENT == NT2

#	define Received_from_d_channel(u_n, n_u) 				\
		(((Na_fct == FG_NT_TE)  && (FG_TE_NT & u_n)) || 	\
		 ((Na_fct == FG_NT_NET) && (FG_NT_NET & n_u)))

#	define Sent_to_d_channel(u_n, n_u) 						\
		(((Na_fct == FG_NT_TE)  && (FG_TE_NT & n_u)) || 	\
		 ((Na_fct == FG_NT_NET) && (FG_NT_NET & u_n)))

#	define Received_from_call_control(u_n, n_u) 			\
		(((Na_fct == FG_NT_NET) && (FG_NT_NET & u_n)) ||	\
		 ((Na_fct == FG_NT_TE)  && (FG_TE_NT & n_u)))

#	define Sent_to_call_control(u_n, n_u) 					\
		(((Na_fct == FG_NT_TE)  && (FG_TE_NT & n_u)) || 	\
		 ((Na_fct == FG_NT_NET) && (FG_NT_NET & u_n)))

#	define Spdu_to_network() 	((Na_fct == FG_NT_NET) ^ (direction == FROM_D_CHANNEL))
#	define Spdu_to_user() 		!Spdu_to_network ()

#else	/* TE */

#	define Received_from_d_channel(u_n, n_u)		(Na_fct & n_u)

#	define Sent_to_d_channel(u_n, n_u)				(Na_fct & u_n)

#	define Received_from_call_control(u_n, n_u)		(Na_fct & u_n)

#	define Sent_to_call_control(u_n, n_u)			(Na_fct & n_u)

#	define Spdu_to_network() 						(direction == TO_D_CHANNEL)
#	define Spdu_to_user() 							!Spdu_to_network ()

#endif

			/* User to network and network to user functional groups */

#if EQUIPMENT == TE
#	define U_N_ALL				FG_TE_NET+FG_TE_NT
#	define N_U_ALL				FG_TE_NET+FG_TE_NT
#else
#	define U_N_ALL				FG_TE_NT+FG_NT_NET
#	define N_U_ALL				FG_TE_NT+FG_NT_NET
#endif

/*-------------------------------------------------------------------------*/

					/* TIMER MANAGEMENT */

			/* CONSTANTS */

#define MX_N303							2			/* maximum SETUP message sent */
#define MX_N308							2			/* maximum number of retry for time out T308 */
#define MX_N313							2			/* maximum number of retry for time out T313 */

			/* Call timer table macros (event id and default values) */

#define Ti_ev_id(x)						Ti_call[x].event_id
#define Ti_df_val_u(x)					Ti_call[x].u_value
#define Ti_df_val_n(x)					Ti_call[x].n_value
#define	Ti_ev_idx(x)					Ti_call[x].index

			/* Timer macro's for optimization */

#if OPTIMIZATION == SPEED
#	define Start_timer_ns(timer_x)		Start_call_timer 	(timer_x)
#	define Restart_timer_ns(timer_x)	Start_call_timer 	(timer_x)
#	define Stop_timer_ns(timer_x)		Stop_call_timer 	(timer_x)

#else

#	define Start_timer_ns(timer_x)		ns_start_timer		(timer_x)
#	define Restart_timer_ns(timer_x)	ns_start_timer  	(timer_x)
#	define Stop_timer_ns(timer_x)		ns_stop_timer 		(timer_x)
#endif

			/* Timer state access */

#define State_timer_ns(xx)				Ti_state(Ti_ev_idx(xx))

	/*-----------------------------------------------------*/

			/* Start timer */

#define Start_call_timer(xx)    		Timer_start (Ti_id(Ti_ev_idx(xx)), Ti_val(xx),		\
										++(Ti_sn(Ti_ev_idx(xx))), Ti_ev_id(xx)); Ti_state(Ti_ev_idx(xx)) = ON; Ti_idx(Ti_ev_idx(xx))=xx

			/* Restart timer = start timer */

#define Restart_call_timer(xx)			Start_call_timer(xx)

			/* Stop timer */

#define Stop_call_timer(xx)				Timer_stop (Ti_id(Ti_ev_idx(xx))); Ti_state(Ti_ev_idx(xx)) = OFF

#define Valid_call_time_out(xx)			(Ti_state(Ti_ev_idx(xx)) == ON) && (R_msg_inf0 == Ti_sn(Ti_ev_idx(xx)))


					/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

			/* Used in the kernel to distinguish the timer index */

#if NS_T309 == ON
#	define	T309_IDX					0
#	define	T309_OFFSET					0
#else
#	define	T309_OFFSET					-1
#endif

#if NS_SEGMENTATION == ON
#	define	T314_IDX					(T309_OFFSET	+ 1)
#	define	T314_OFFSET					T314_IDX
#else
#	define	T314_OFFSET					T309_OFFSET
#endif

#if NS_RESTART_PROCEDURE == ON
#	define	T316_IDX					(T314_OFFSET	+ 1)
#	define	T317_IDX					(T316_IDX		+ 1)
#	define	T317_OFFSET					T317_IDX
#else
#	define	T317_OFFSET					T314_OFFSET
#endif

#define 	TSPID_IDX					(T317_OFFSET	+ 1)
#define		TSPID_OFFSET				TSPID_IDX

#define		T321_IDX					(TSPID_OFFSET	+ 1)
#define		TSRV_IDX					(TSPID_OFFSET	+ 2)
#define		T3M1_IDX					TSRV_IDX
#define		T3DW_IDX					(TSPID_OFFSET	+ 3)
#define		T3MB_IDX					(TSPID_OFFSET	+ 4)
#define		TNFAS_OFFSET				T3MB_IDX

#define	TI_NOT_IMPLEMENTED				255
#define	TI_EOT							0

#define T309							Tab_timer_idx[T309_IDX]
#define	T314                            Tab_timer_idx[T314_IDX]
#define	T316                            Tab_timer_idx[T316_IDX]
#define	T317                            Tab_timer_idx[T317_IDX]
#define TSPID							Tab_timer_idx[TSPID_IDX]
#define T321							Tab_timer_idx[T321_IDX]
#define TSRV							Tab_timer_idx[TSRV_IDX]
#define T3M1							TSRV
#define T3DW							Tab_timer_idx[T3DW_IDX]
#define T3MB							Tab_timer_idx[T3MB_IDX]

#define T3_NIL							255		/* no timer action */

	/*-----------------------------------------------------*/


			/* DLCI timer management */

		/* Start DL timer */

#define Start_dl_timer(x) 		Timer_start (Dl_timer_id(x), Ti_dl_val(x),\
								++(Dl_timer_sn(x)), Ti_dl_ev_id(x)); Dl_timer_state(x) = ON

#define Restart_dl_timer(x)		Start_dl_timer(x)

		/* Stop DL timer */

#define Stop_dl_timer(x)		Timer_stop (Dl_timer_id(x)); Dl_timer_state(x) = OFF

		/* Timer DL state access */

#define State_dl_timer(x)		Dl_timer_state (x)

		/* Check DL timer event validity according to the sequence number */

#define Valid_dl_time_out(x)	(Dl_timer_state (x) == ON) && (R_msg_inf0 == Dl_timer_sn (x))

struct ns_timer {
	timer_val_t			n_value;					/* Network side value */
	timer_val_t			u_value;					/* User side value */
	uchar				event_id;					/* Event ID */
	uchar				index;						/* Index */
};

		/* DL timer table macros (event id and default values) */

#define Ti_dl_ev_id(x)			Ti_dlci[x].event_id
#define Ti_dl_df_val_u(x)		Ti_dlci[x].u_value
#define Ti_dl_df_val_n(x)		Ti_dlci[x].n_value

			/* Stop CALL and DLCI timers */

#define Stop_call_and_dlci_timer()	ns_stop_all_timers ();	\
									ns_stop_all_dlci_timers ()

		/* Internal timers management */

struct internal {
	struct timer	int_timer;
	call_ref_t		call_reference;
	uchar			ces;

#	if SIMULATION == ON
		uchar		ti_idx;
#	endif

};

		/* Start INTernal timer */

#define Start_int_timer(x)		start_int_timer (x,0)
#define Restart_int_timer(x,sn)	start_int_timer (x,sn)

		/* Stop INTernal timer */

#define Stop_int_timer(x)		stop_int_timer ()
#define Release_int_timer(xx)	Int_timer_state (xx) = OFF; 	\
								Timer_free (Int_timer_id (xx)); \
								Int_timer_id (xx) = TIMER_ID_NIL

		/* Internal table macros (event id and default values) */

#define Ti_int_ev_id(x)			Ti_int[x].event_id
#define Ti_int_val(x)			Ti_int[x].n_value

#define Valid_int_time_out(x)	(Int_timer_state (x) == ON) && (Int_timer_sn (x) == R_msg_inf0)

/*-------------------------------------------------------------------------*/

#if OPTIMIZATION == SPEED

					/* CALL REFERENCE ACCESS TABLE */

	struct call_ref_tab {
		struct call FAR *	p_call;							/* pointer to call reference */
	};

					/* CONNECTION ID ACCESS TABLE */

	struct conn_tab {
		struct call FAR *	p_call;							/* pointer to call reference */
	};

#endif

#define	NS_MX_B_CHAN					32
#define	NS_MX_B_CHAN_T1					24
#define	NS_MX_B_CHAN_E1					31

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

					/* CC NAI ACCESS TABLE THRU THE CALL REF */

	struct nfas_tab {
		nai_t				cc_nai;							/* Nai to be shown at the NS interface */
		call_ref_t			cr;								/* Call ref */
	};

	extern uchar			ns_nfas;						/* NFAS */
	extern uchar			ns_nfas_group_nb;
	extern nai_t			ns_cc_int_id;					/* CC interface Id */

#	define S_msg_cc_int_id	S_msg_inf0

					/* D channel status */

	struct ns_d_chan_status {
		uchar				nfas_mode;						/* Nfas mode : NFAS_X, NFAS_TSP */
		nai_t				line_nai;						/* Nai on which the message is received from DL */
		nai_t				nai_active_d;					/* Nai bearing the active D channel currently in use */
		nai_t				nai_cfg_active_d;				/* Nai bearing the active D channel selected in the configuration */
		uchar				active_d_status;				/* Status of the active D channel */
		struct nsdl FAR *	p_nsdl_active_d_chan;			/* pointer to the DL context bearing the active D channel */
		struct nsna FAR *	p_active_d_chan;				/* pointer to the Nai bearing the Active D channel */
		struct nfas_tab FAR *p_nfas_tab;
		ushort				nfas_tab_size;
		uchar				assoc_nb;						/* Number of associations */
		nai_t				nai_list[NS_MX_NFAS_NAI + 1];	/* Nais managed by this D channel (+1 to add the D channel bearer itself) */
		uchar				nai_bck_act;					/* Backup activation (ON/OFF) */

#		if NS_D_BACKUP == ON
			nai_t				nai_backup_d;				/* Nai bearing the active D channel for backup use */
			nai_t				nai_cfg_backup_d;			/* Nai bearing the backup D channel selected in the configuration  */
			uchar				backup_d_status;			/* Status of the backup D channel */
			struct nsdl FAR *	p_nsdl_backup_d_chan;		/* pointer to the DL context bearing the backup D channel */
			struct nsna FAR *	p_backup_d_chan;			/* pointer to the Nai bearing the Backup D channel */
#		endif
	};

#	define	Nfas_nai_line				p_ns_d_chan_status -> line_nai
#	define	Nfas_nai_active_d_chan		p_ns_d_chan_status -> nai_active_d
#	define	Nfas_nai_backup_d_chan		p_ns_d_chan_status -> nai_backup_d
#	define	Nfas_cfg_nai_active_d_chan	p_ns_d_chan_status -> nai_cfg_active_d
#	define	Nfas_cfg_nai_backup_d_chan	p_ns_d_chan_status -> nai_cfg_backup_d
#	define	Nfas_active_d_chan_status	p_ns_d_chan_status -> active_d_status
#	define	Nfas_backup_d_chan_status	p_ns_d_chan_status -> backup_d_status
#	define	Nfas_nai_p_active_d_chan	p_ns_d_chan_status -> p_active_d_chan
#	define	Nfas_nai_p_backup_d_chan    p_ns_d_chan_status -> p_backup_d_chan
#	define	Nfas_dl_p_active_d_chan		p_ns_d_chan_status -> p_nsdl_active_d_chan
#	define	Nfas_dl_p_backup_d_chan    	p_ns_d_chan_status -> p_nsdl_backup_d_chan
#	define	Nfas_nai_assoc_list_nb_nai	p_ns_d_chan_status -> assoc_nb
#	define	Nfas_nai_assoc_list(x)		p_ns_d_chan_status -> nai_list[x]
#	define	Nfas_nai_d_chan_backup_act	p_ns_d_chan_status -> nai_bck_act
#	define	Nfas_a_tab					p_ns_d_chan_status -> p_nfas_tab
#	define	Nfas_p_tab(x)				p_ns_d_chan_status -> p_nfas_tab[x]
#	define	Nfas_tab_size				p_ns_d_chan_status -> nfas_tab_size
#	define	Nfas_nai_mode				p_ns_d_chan_status -> nfas_mode

#	define	Ns_access_d_chan_ctx(x)		p_ns_d_chan_status = p_ns_d_chan_status_start + x
#	define	Nfas_context_exist			(p_ns_d_chan_status != P_NIL)

	extern struct ns_d_chan_status	FAR *p_ns_d_chan_status;
	extern struct ns_d_chan_status	FAR *p_ns_d_chan_status_start;

#define	NS_D_CHAN_NIL					0				/* No D channel on that link */
#define	NS_D_CHAN_ACTIVE				1				/* The D channel is active */
#define	NS_D_CHAN_BCK					2				/* The D channel may be used as backup D channel */

#define	NO_NFAS							0				/* No NFAS at all */
#define	NFAS_TSP						1				/* No multiplexing at NS interface for the NFAS, No D channel Backup */
#define	NFAS_X							2				/* Multiplexing done at NS interface for the NFAS, No D channel Backup */
#define	NFAS_TSP_BKP					3				/* No multiplexing at NS interface for the NFAS , D channel Backup */
#define	NFAS_X_BKP						4				/* Multiplexing done at NS interface for the NFAS, D channel Backup */

#define	MAINT_ACTION_MAINTENANCE		0
#define	MAINT_ACTION_AUDIT				1


	struct ns_maint {
		uchar   b_chan_nb;								/* Number of impacted B channels */
		uchar	action;									/* Action to be taken on the channels */
		uchar	last_value_sent;						/* Last value sent in a SERVICE */
	};

	struct dl_chan_mgt {
		uchar					d_chan_state;			/* D channel state */
		uchar					rc_2;					/* retry counter */
		ushort					nb_chan_restart;		/* Number of B channels to be restarted */
		uchar					nb_nai_restart;			/* Number of Nais to be restarted */
		struct ns_maint 		maint[NS_MX_NFAS_NAI+1];/* Maintenance */
		uchar					chan_mode[NS_MX_NFAS_NAI+1][NS_MX_B_CHAN];/* channel mode */
	};


#endif /* } */


/*-------------------------------------------------------------------------*/

					/* MESSAGE SEGMENTATION */

#define MX_SEGMENT					8					/* Default maximum number of messages segment */
#define N201						260					/* maximum length of DL frames */

			/* Segmented IE description */

#define IE_SEGMENTED_LGTH 			2					/* IE segmented length */

			/* Segment indicator field */

#define SEGMENT_INDICATOR_POSITION	7					/* segment indicator position */
#define SEGMENT_INDICATOR_LENGTH	1					/* segment indicator length */

#define First_segment_indicator		(uchar)((*p_ie >> SEGMENT_INDICATOR_POSITION) & Mask (SEGMENT_INDICATOR_LENGTH))

#define FIRST_SEGMENT				G_1 (1)
#define SUBSEQUENT_SEGMENT			G_1 (0)

			/* segment remaining field */                 
														  
#define SEGMENT_REMAINING_POSITION	0					/* segment reamining position */
#define SEGMENT_REMAINING_LENGTH	7					/* segment remain length */

#define Segment_remaining			(uchar)(*p_ie & Mask (SEGMENT_REMAINING_LENGTH))
#define Segmented_message_type		(uchar)(*p_ie & Mask (SEGMENT_REMAINING_LENGTH))

			/* Extension bit */

#define Ext_0_1						(uchar)((*p_ie >> EXT_POSITION) & Mask (EXT_LGTH))

/*-------------------------------------------------------------------------*/

					/* NS : NETWORK ACCESS MANAGEMENT */

struct nsna {
	nai_t 				nai;							/* network access identifier */
	nai_t				dl_nai;							/* access to be sent to DL */
	add_t				dl_ces;							/* DL ces */
	uchar				status;							/* NA status / access power ON or OFF */
	uchar 				type;							/* type of network access */
	uchar				fct;							/* functional grouping type */
	uchar				ti_309;							/* NS timer T309 option */
	uchar				connection;						/* connection type */
	uchar				subscription;					/* subscription code */
	struct nsdl FAR		*first_p_dl;					/* pointer to first nsdl object */
	add_t 				call_outgoing_nb;				/* number of outgoing call context */
	add_t				call_incoming_nb;				/* number of incoming call context */
	add_t				call_mixed_nb;					/* number of mixed call context */
	struct call FAR		*p_incoming_call;				/* pointer to the first incoming call context */
	struct call FAR		*p_first_mixed_call;			/* pointer to the first mixed call context */
	struct call FAR		*p_last_mixed_call;				/* pointer to the last mixed call context */
	call_ref_t			call_ref_nber;					/* call_ref current modulo for call ref assignment : left bit reserve for call ref flag */
	timer_val_t			ti_call_value[NS_MX_CALL_TIMER];/* call timer values */
	timer_val_t			ti_dl_value[NS_MX_DLCI_TIMER];	/* Dl timer value */
	uchar				network;						/* carrier */
	ushort				country;						/* country */
	uchar 				restart_crl;					/* call ref length on incoming restart message */

#	if NS_RESTART_PROCEDURE == ON
		uchar				internal_restart;			/* ON : restart has been performed inrernally without any help from another entity (CC) / OFF : NS needs that help */
#	endif

#	if NS_MAINTENANCE_CAPABILITY == ON
		uchar			dl_init;						/* Manual or automatic DL activation */
		uchar			nfas;							/* ON : This Nai belongs to a NFAS group */
		uchar			maint_type;						/* NFAS_TSP, NFAS_TSP_BKP, NFAS_X, NFAS_X_BKP, NO_NFAS */
		uchar			d_chan_type;					/* D channel type : ACTIVE/BACKUP */
		uchar			d_chan_ctx;						/* Index giving the right D channel context */
#	endif

#	if EQUIPMENT == NT2
		struct internal		int_proc[MX_INT_PROC];		/* individual processes context (timer, ces, call ref) */
#	endif

#	if OPTIMIZATION == SPEED
		struct call_ref_tab FAR *call_ref_p_tab;		/* call reference access table */
		ushort				call_ref_tab_size;			/* size of the call reference table */

		struct conn_tab		FAR *conn_p_tab;			/* table for acess thru connection Id */
		ushort				conn_tab_size;				/* size of the connection Id table*/
#	endif

	uchar				FAR	*p_blk;						/* memory block pointer */
};


		/* Access Na table. Given a Dl Na and a Dl ces, find the pointer to the Ns Na */

struct  accss_nsna_ces {
	struct nsna FAR *   ces[DL_MX_DLCEP-1];			/* contain a pointer to Ns Na context (-1 : DL_CES_BROADCAST is excluded) */
};

#define	Nsna_ces_key(dl_nai, dl_ces) 				p_nsna_ces_tab[(dl_nai)].ces[(dl_ces)-1]

				/* Access to current NA values using p_nsna pointer */

#define Nai 										p_nsna -> nai
#define Na_dl_nai									p_nsna -> dl_nai
#define	Na_dl_ces									p_nsna -> dl_ces
#define	Na_network									p_nsna -> network
#define	Na_country									p_nsna -> country
#define Na_status									p_nsna -> status
#define Na_type										p_nsna -> type
#define Na_fct										p_nsna -> fct
#define	Na_T309_option								p_nsna -> ti_309
#define Na_connection								p_nsna -> connection

#define Na_subscription								p_nsna -> subscription
#define Na_subscription_x(service)					(Na_subscription & service)
#define Na_subscription_key							Na_subscription_x (KEY_OPTION)
#define Na_subscription_tm							Na_subscription_x (TM_OPTION)
#define Na_subscription_fco_hcdt					Na_subscription_x (FCO_HCDT_OPTION)


#define Na_first_p_dl								p_nsna -> first_p_dl
#define Call_ref_nber								p_nsna -> call_ref_nber
#define Incoming_call_nb							p_nsna -> call_incoming_nb
#define Outgoing_call_nb							p_nsna -> call_outgoing_nb
#define Mixed_call_nb								p_nsna -> call_mixed_nb

#define P_first_incoming_call						p_nsna -> p_incoming_call
#define P_first_mixed_call							p_nsna -> p_first_mixed_call
#define P_last_mixed_call							p_nsna -> p_last_mixed_call

#define Ns_access_first_outgoing_call()				ns_access_first_call ()
#define Ns_access_first_incoming_call()				p_call = P_first_incoming_call
#define Ns_access_first_mixed_call()				p_call = P_first_mixed_call
#define Ns_access_last_mixed_call()					p_call = P_last_mixed_call

#define Ti_val(xx)									p_nsna -> ti_call_value[xx]
#define Ti_dl_val(xx)								p_nsna -> ti_dl_value[xx]

#define	Na_restart_crl								p_nsna -> restart_crl
#define	Na_internal_restart							p_nsna -> internal_restart

#define Na_current_exist							(p_nsna != P_NIL)

#if NS_MAINTENANCE_CAPABILITY == ON
#	define	Na_dl_init								p_nsna -> dl_init
#	define	Na_nfas									p_nsna -> nfas
#	define	Na_maint_type							p_nsna -> maint_type
#	define	Na_d_channel_type						p_nsna -> d_chan_type
#	define	Na_d_channel_ctx						p_nsna -> d_chan_ctx
#endif

#if EQUIPMENT == NT2
#	define Na_int_proc(xx)							(p_nsna -> int_proc[xx])
#	define Int_timer_id(xx)							Na_int_proc(xx).int_timer.id
#	define Int_timer_state(xx)						Na_int_proc(xx).int_timer.state
#	define Int_timer_sn(xx)							Na_int_proc(xx).int_timer.sn
#	define Int_call_ref(xx)							Na_int_proc(xx).call_reference
#	define Int_ces(xx)								Na_int_proc(xx).ces
#	define Int_timer_idx(xx)						Na_int_proc(xx).ti_idx
#endif

#if OPTIMIZATION == SPEED

#	define Na_call_ref_p_tab						p_nsna -> call_ref_p_tab
#	define Na_call_ref_tab_size						p_nsna -> call_ref_tab_size

#	define Na_conn_p_tab							p_nsna -> conn_p_tab
#	define Na_conn_tab_size							p_nsna -> conn_tab_size

#endif

#define Na_p_blk									p_nsna -> p_blk

#define	Na_connection_pmp							(Na_connection == POINT_TO_MULTIPOINT)

			/* Access Macro */

#define Ns_access_dl_na(nai, ces)					ns_access_dl_na (nai, ces)

/*-------------------------------------------------------------------------*/

				/* DL : DATA LINK MANAGEMENT */

#define MX_SPDU_LGTH			(N201+ (N201 - (IE_SEGMENTED_LGTH + 4)) * (MX_SEGMENT-1))	/* maximum size of a SPDU */

#define	NS_MX_BUTTON_NB			8						/* No more than 8 different buttons (Voice Supplementary services) */


struct nsdl {
	ces_t						ces;					/* Connection Enpoint ID : CES */
	uchar						tei;					/* assign TEI */
	uchar 						lc_state;				/* status of the signaling acknowledged Link Connection */
	uchar 						dl_rc;					/* data link restablishment retry count */
	uchar						call_count;				/* number of current call using the DL */
	uchar						usid;					/* USID : User Select ID */
	uchar						tid;					/* TID  : Terminal ID */
	uchar						ei_state;				/* Endpoint Initialization state */
	uchar						ei_orig;				/* Endpoint Initialization origination */
	uchar						rest_state;				/* Restart state */
	uchar						rest_ack;				/* Restart acknowledged by Network side */
	uchar						rest_rs;				/* Restart acknowledged by User side */
	uchar						rest_class;				/* Restart indicator class */
	uchar						rest_b_chan_nb;			/* B-channel Nb restarted */
	uchar						rc;						/* retry counter */
	uchar						backup;					/* backup flag */
	struct timer 				timer [NS_MX_DLCI_TIMER];	/* no call on a DL timer */
	struct queue_mgt 			queue_dl;				/* queue of DL_DA_RQ message to send awaiting for the DL establishment */
	struct queue_mgt 			queue_cc;				/* queue of received SSDU message awaiting for the DL establishment */
	char						spid [NS_MX_SZ_SPID+1];	/* SPID : Service Profile ID */
	uchar						chan_sel;				/* channel selection */

	uchar						button_net;				/* Button provided by the network */
	uchar						button_user;			/* Button provided by the user */
	uchar						internal_rq;			/* Button is requested by the user (ON/OFF) */
	uchar		FAR *			button_p_call;			/* Call context pending */


#	if NS_SEGMENTATION == ON
		uchar					reassembly_state;		/* segmenter reassembly state */
		uchar					spdu_id;				/* current message type */
		call_ref_t				call_ref;				/* current call reference */
		uchar					segment_remaining;		/* number of remaining segment */
		uchar				FAR *p_spdu_end;			/* current pointer on the end of the received message */
		uchar					spdu [MX_SPDU_LGTH];	/* used to store received message */
#	endif

#	if NS_MAINTENANCE_CAPABILITY == ON
		uchar					rest_int_id;			/* Interface Id */
		struct dl_chan_mgt FAR 	*p_dl_chan_mgt;
#	endif

	uchar					FAR *p_blk;					/* Memory block pointer */

};

#define SPID_NIL				0						/* no Service Profile ID */

			/* Access to current DL values using p_nsdl pointer */

#define Dl_ces					p_nsdl -> ces
#define Dl_tei					p_nsdl -> tei
#define Lc_state				p_nsdl -> lc_state
#define Dl_rc					p_nsdl -> dl_rc
#define Dl_call_count			p_nsdl -> call_count
#define Dl_chan_sel				p_nsdl -> chan_sel

#define Dl_usid					p_nsdl -> usid
#define Dl_tid					p_nsdl -> tid
#define Dl_ei_state				p_nsdl -> ei_state
#define Dl_ei_orig				p_nsdl -> ei_orig
#define Dl_rest_state			p_nsdl -> rest_state
#define Dl_rest_ack				p_nsdl -> rest_ack
#define Dl_rest_resp			p_nsdl -> rest_rs
#define Dl_rest_class			p_nsdl -> rest_class
#define Dl_rest_chan_nb			p_nsdl -> rest_b_chan_nb
#define N316					p_nsdl -> rc
#define N321					p_nsdl -> rc
#define	Dl_backup				p_nsdl -> backup
#define Dl_timer_id(xx)			p_nsdl -> timer[xx].id
#define Dl_timer_state(xx)		p_nsdl -> timer[xx].state
#define Dl_timer_sn(xx)			p_nsdl -> timer[xx].sn
#define Dl_first_dl				p_nsdl -> queue_dl.p_first
#define Dl_last_dl				p_nsdl -> queue_dl.p_last
#define Dl_first_cc				p_nsdl -> queue_cc.p_first
#define Dl_last_cc				p_nsdl -> queue_cc.p_last
#define Dl_current_exist		(p_nsdl != P_NIL)
#define Dl_a_spid				&(p_nsdl -> spid[0])
#define Dl_is_spid_nil			((p_nsdl -> spid[0]) == SPID_NIL)
#define Dl_p_blk				p_nsdl -> p_blk

#if NS_SEGMENTATION == ON
#	define 	Dl_reassembly_state	p_nsdl -> reassembly_state
#	define 	Dl_spdu_id  		p_nsdl -> spdu_id
#	define 	Dl_call_ref			p_nsdl -> call_ref
#	define 	Dl_segment_remaining p_nsdl -> segment_remaining
#	define 	Dl_p_spdu_end		p_nsdl -> p_spdu_end
#	define 	Dl_a_spdu 			&(p_nsdl -> spdu [0])

		/* Reassembly state value */

#	define REASSEMBLY_NULL_STATE		0
#	define REASSEMBLY_RECEIVING_STATE	1

#endif

#define	Dl_button_net			p_nsdl -> button_net
#define	Dl_button_user			p_nsdl -> button_user
#define	Dl_button_internal		p_nsdl -> internal_rq
#define Dl_button_p_call		p_nsdl -> button_p_call

#if NS_MAINTENANCE_CAPABILITY == ON
#	define	Dl_rest_int_id			p_nsdl -> rest_int_id
#	define	Dl_p_chan_mgt			p_nsdl -> p_dl_chan_mgt
#	define 	NSRV					Dl_p_chan_mgt -> rc_2
#	define	Dl_d_chan_state			Dl_p_chan_mgt -> d_chan_state
#	define	Dl_b_chan_mode(xx)		Dl_p_chan_mgt -> chan_mode[0][xx]
#	define	Dl_b_chan_mode_int(x,y)	Dl_p_chan_mgt -> chan_mode[x][y]
#	define	Dl_serv_last_value(xx)	Dl_p_chan_mgt -> maint[xx].last_value_sent
#	define	Dl_b_chan_restart_nb	Dl_p_chan_mgt -> nb_chan_restart
#	define	Dl_b_chan_maint_nb(xx)	Dl_p_chan_mgt -> maint[xx].b_chan_nb
#	define	Dl_maint_action(xx)		Dl_p_chan_mgt -> maint[xx].action
#	define	Dl_nai_restart_nb		Dl_p_chan_mgt -> nb_nai_restart
#endif

#define	MAINT_ACTION_NIL				0
#define	MAINT_ACTION_SERVICE_SENT		1

#define Dl_restart_reset()		Dl_rest_state = STATE_REST_0;	\
								Dl_rest_ack = Dl_rest_resp = OFF; \
								Na_internal_restart = OFF

			/* Access functions */

#define Ns_access_dl_ces(ces)	ns_access_dl_ces (ces)
#define Ns_access_first_dl()	p_nsdl = Na_first_p_dl
#define Ns_access_next_dl()		ns_access_next_dl ()

#define Ces_from_x(xx)			(xx)
#define x_from_ces(ces)			(ces)

			/*  Link Connection state wiew from layer 3 */

#define LC_ESTABLISHED			'E'					/* link connection established */
#define LC_RELEASED				'R'					/* link connection released */
#define LC_AWAITING_EST			'W'					/* link connection awaiting estabish */
#define LC_AWAITING_REL			'w'					/* link connection awaiting release */

			/* Endpoint Initialization states */

#define EI_STATE_DOWN			'D'					/* powered down */
#define EI_STATE_NOT_INIT		'N'					/* not initialized */
#define EI_STATE_P_INIT			'P'					/* endpoint initialization procedure not supported */
#define EI_STATE_M_INIT			'M'					/* initialization done */
#define EI_STATE_AWAIT_ASSIGN	'A'					/* CPE has requested a TEI and is awaiting a response */
#define EI_STATE_AWAIT_EST		'E'					/* CPE has requested layer 2 establishment and is awaiting a response */
#define EI_STATE_AWAIT_INIT		'I'					/* CPE has sent its initialization and is awaiting a response */
#define EI_STATE_INIT			'T'					/* CPE has successfully completed initialization and has received EID */
#define EI_STATE_NOT_INIT		'N'					/* switch answered to the initialization with cause #100 (invalid SPID) */
#define EI_STATE_NOT_SUPPORTED	'S'					/* switch answered to the initialization with cause #99 */

			/* context backup in case of congestion */

struct	ctx_backup {
	struct ctx_backup FAR *		p_next;					/* next instance location */
	nai_t                       nai;                    /* network access identifier */
	add_t                       ces;                    /* address */
	uchar                       action;					/* action being in progress */
	uchar                       event;                  /* event */
	ent_id_t                    entity;                 /* origin of the message (entity identifier) */
};

#define Ctx_backup_next         p_ctx_backup -> p_next
#define Ctx_backup_nai          p_ctx_backup -> nai
#define Ctx_backup_ces          p_ctx_backup -> ces
#define Ctx_backup_action		p_ctx_backup -> action
#define Ctx_backup_event        p_ctx_backup -> event
#define Ctx_backup_entity       p_ctx_backup -> entity

#define Ctx_backup_exist		(p_ctx_backup != P_NIL)

#define	ACTION_REINIT			0
#define	ACTION_RESET			1
#define	ACTION_FAILURE			2

/*-------------------------------------------------------------------------*/

				/* NS : CALL CONNECTION MANAGEMENT */

#if EQUIPMENT == NT2

		/* Temporary data for multipoint configuration */

#define NS_MX_SZ_UUI			128				/* Maximum size for UUI */

	struct call_temp {
		uchar					int_state[DL_MX_DLCEP]; /* internal state of the ces */

		uchar					ces_status;			/* STATUS received (Ces) or not (CES_NIL) */
		uchar					ces_connect;		/* ces of the CONNECT */

		uchar					alert[DL_MX_DLCEP]; /* ALERT or CONNECT_ACK message received */

		uchar					ces_setup;			/* ces on which call was established (BROADCAST or normal one) */
		uchar					setup_ack;			/* Nb of setup ack received on all ces */

		ces_t					ces_cause;			/* origination ces or CES_NIL */
		struct i_cause			call_cause;			/* cause */

		ces_t					ces_uui;			/* origination ces or CES_NIL */
		struct i_uui			call_uui;			/* user to user information */
		uchar					uui_info[NS_MX_SZ_UUI+2];/* UUI content */

#		if NS_SPF_FACILITY == ON
			ces_t				ces_spf_fac;		/* origination ces or CES_NIL */
			struct i_spf_fac	call_spf_fac;		/* specific facility */
#		endif

		ces_t					ces_called_nb;		/* origination ces or CES_NIL */
		struct i_called_nb		call_called_nb;		/* called number */

		ces_t					ces_called_sub_add;	/* origination ces or CES_NIL */
		struct i_called_sub_add	call_called_sub_add;/* called subaddress */

	};

#endif

			/* CALL */

#define NS_MX_SZ_SAVE_DIAG			4			/* maximum size of cause diagnostic to be saved */

struct call {
	conn_id_t					conn_id;							/* connection identifier */
	uchar 						call_type;							/* call context type (outgoing, incoming, mixed) */
	call_ref_t					reference;							/* call reference */
	uchar						ref_lgth;							/* call reference length */
	ces_t						ces;								/* CES of the DL connection endpoint */
	uchar 						state;								/* call state */
	uchar						sub_state;							/* call sub-state */
	ent_id_t					upper_ent;							/* current upper entity id */
	uchar 						rc;									/* retry counter */
	uchar   					rel_flag;							/* release flag */
	uchar						fac_rq;								/* facility request flag */
	uchar						uui_rq;								/* user-to-user facility request flag */
	uchar						ui_count;							/* user-to-user facility message counter */
	uchar						user_fac_rq;						/* user facility request flag */
	uchar						chan_id_sel;						/* value of selection field in chan_id IE */
	struct timer 				timer[NB_CALL_TIMER];				/* timer management table */
	uchar						current_timer_idx[NB_CALL_TIMER];	/* management table for the index of timers in progress */
	struct buffer FAR * 		save_spdu;							/* saved buffer address of an SPDU */
	uchar						keypad_in_setup;					/* keypad present in setup (AT5) */
	uchar						bc_trf_cap;							/* Bearer Capability Transfer Capability contained in the SETUP message */
	uchar						progress_descr;						/* saved progress descriptor value for T310 handling */
	uchar						en_bloc_flag;						/* en-bloc/overlap sending/receiving flag : ON/OFF */
	uchar						disc_m_ie_error;					/* disconnect mandatory IE error : error code value */
	struct i_cause				saved_cause;						/* cause IE backup */
	uchar						saved_diag[NS_MX_SZ_SAVE_DIAG];		/* cause diagnostic backup */
	uchar						channel_id;
	uchar 						sel_call_appear;					/* selected call appearance */
	uchar						permanence;							/* circuit permanence : not permanent, semi-permanent */

#	if NS_HOLD_RETRIEVE == ON
		uchar					hold_aux_state;						/* auxiliary state associated with Hold/Retrieve procedures */
#	endif

	uchar					FAR *p_blk;								/* Memory block pointer */

#	if EQUIPMENT == NT2
		uchar					queue;								/* call has been queued (ON) or not (OFF) */
		struct call_temp 		call_temp;							/* temporary area used to save IE values */
#	endif

		/*
			!!! WARNING !!!

			The 'call_temp' field MUST BE the LAST in this structure
			because of memory allocation optimization done during
			configuration.
		*/

};

			/* Access to current CALL values using p_call pointer */

#define Call_conn_id				p_call -> conn_id
#define Call_type					p_call -> call_type
#define Call_ref 					p_call -> reference
#define Call_ref_lgth				p_call -> ref_lgth
#define Call_state      			(p_call -> state)
#define Call_sub_state				p_call -> sub_state
#define Call_upper_ent				p_call -> upper_ent
#define Call_ces					p_call -> ces
#define Call_fac_rq					p_call -> fac_rq
#define Call_uui_rq					p_call -> uui_rq
#define Call_ui_count				p_call -> ui_count
#define Call_ui_u_count				((p_call -> ui_count) >> 4)
#define Call_ui_n_count				((p_call -> ui_count) & Mask(4))
#define Inc_ui_u_count()			(p_call -> ui_count) += 16
#define Inc_ui_n_count()			(p_call -> ui_count) ++
#define Call_user_fac_rq			p_call -> user_fac_rq
#define Call_rel_flag				p_call -> rel_flag
#define Call_chan_id_sel			p_call -> chan_id_sel
#define Ti_state(xx)				p_call -> timer[xx].state
#define Ti_id(xx)					p_call -> timer[xx].id
#define Ti_sn(xx)					p_call -> timer[xx].sn
#define Ti_idx(xx)					p_call -> current_timer_idx[xx]
#define N308						p_call -> rc
#define N303						p_call -> rc
#define N313						p_call -> rc
#define Rc							p_call -> rc
#define Call_save_spdu				p_call -> save_spdu
#define Call_current_exist			(p_call != P_NIL)
#define Call_keypad_in_setup		p_call -> keypad_in_setup
#define Call_bc_trf_cap				(p_call -> bc_trf_cap)
#define Call_progress_descr			p_call -> progress_descr
#define Call_service_type			Call_bc_trf_cap		/* AT5 */
#define Call_en_bloc_flag			p_call -> en_bloc_flag
#define Call_disc_m_ie_error		p_call -> disc_m_ie_error
#define Call_a_saved_cause			&(p_call -> saved_cause)
#define Call_a_saved_diag			&(p_call -> saved_diag[0])
#define Call_chan_id				p_call -> channel_id
#define	Call_sel_call_appear		p_call -> sel_call_appear
#define	Call_permanence				p_call -> permanence

#if NS_HOLD_RETRIEVE == ON
#	define	Call_hold_aux_state		p_call -> hold_aux_state
#endif

#define Call_p_blk					p_call -> p_blk

#if EQUIPMENT == NT2

#	define Call_int_state			p_call -> call_temp.int_state[Dl_ces]
#	define Call_int_ces_state(ces)	p_call -> call_temp.int_state[ces]
#	define Set_int_ces_state(s)		Call_int_state = s

		/* Available internal states */

#	define	STATE_0_I				0
#	define	STATE_7_I				7
#	define	STATE_8_I				8
#	define	STATE_9_I				9
#	define	STATE_19_I				19
#	define	STATE_25_I				25

#	define Call_ces_status			p_call -> call_temp.ces_status
#	define Call_ces_connect			p_call -> call_temp.ces_connect

#	define Call_alert(ces)			p_call -> call_temp.alert[ces]
#	define Call_ces_setup			p_call -> call_temp.ces_setup
#	define Call_setup_ack			p_call -> call_temp.setup_ack

#	define Call_ces_cause			p_call -> call_temp.ces_cause
#	define Call_ces_uui				p_call -> call_temp.ces_uui
#	define Call_ces_spf_fac			p_call -> call_temp.ces_spf_fac
#	define Call_ces_called_nb		p_call -> call_temp.ces_called_nb
#	define Call_ces_called_sub_add	p_call -> call_temp.ces_called_sub_add

#	define Call_a_cause				&(p_call -> call_temp.call_cause)
#	define Call_a_uui				&(p_call -> call_temp.call_uui)
#	define Call_uui_p_info			p_call	 -> call_temp.call_uui.p_info
#	define Call_a_spf_fac			&(p_call -> call_temp.call_spf_fac)
#	define Call_a_called_nb			&(p_call -> call_temp.call_called_nb)
#	define Call_a_called_sub_add	&(p_call -> call_temp.call_called_sub_add)

#	define Call_a_uui_info			&(p_call -> call_temp.uui_info[0])

#	define Set_dl_ctx_status()		Ns_access_dl_ces (Call_ces_status)
#	define Set_dl_ctx_uui()			Ns_access_dl_ces (Call_ces_uui)
#	define Set_dl_ctx_spf_fac()		Ns_access_dl_ces (Call_ces_spf_fac)

#	define Set_alert()				Call_alert (x_from_ces (Dl_ces)) = ON;

#	define	Call_queued				p_call ->queue

#endif

			/* Call reference not initialized or Null Length Call Ref */

#define CALL_REF_NIL				0

			/* Set state macro : When Hold and Retrieve functions are used, a change of call state
				may cause actions to be processed : call a network-specific function */

#if NS_HOLD_RETRIEVE == ON
#	define Set_state(s)				Call_state = s;		\
									Ns_call_state_change ()
#else
#	define Set_state(s)				Call_state = s
#endif

			/* Macro's */

#define Reset_internal_ie()			reset_ie_i ()

#define Save_cause()				ns_save_call_cause ()
#define Restore_cause()				Memcpy_far ((char FAR *) &i_cause[0], (char FAR *) Call_a_saved_cause, I_cause_size)

			/* Call Sub State */

#define SUB_STATE_NULL_0			0

			/* N6 sub-state */

#define N6							'0'
#define N6_REL_COMP					'1'
#define N6_REL_UUI					'2'
#define N6_REL_SPF_FAC				'3'

			/* US-specific sub-states */

#if (F_AT5 == ON) || (F_AT9 == ON) || (F_NI1 == ON) || (F_NI2 == ON) || (F_E10 == ON)
#	define SUB_STATE_30				30				/* waiting for a response to a HOLD RQ */
#	define SUB_STATE_31				31				/* waiting for a response to a TRANS RQ */
#	define SUB_STATE_32				32				/* waiting for a response to a CONF RQ */
#	define SUB_STATE_33				33				/* waiting for a response to a RECONN RQ */
#	define SUB_STATE_34				34				/* waiting for a DISC */
#	define SUB_STATE_35				35				/* waiting for a response to a DROP RQ */
#	define SUB_STATE_36				36				/* waiting for a RECONN RQ */
#	define SUB_STATE_40				40				/* waiting for a RECONN RQ in KEY SYSTEM */
#	define SUB_STATE_41				41				/* waiting for a response to a HOLD RQ in KEY SYSTEM */
#	define SUB_STATE_42				42				/* waiting for a response to a RECONN RQ in KEY SYSTEM */
#endif

#if (F_AT5 == ON) || (F_E10 == ON)
#	if (AT5_KEY_SYSTEM_FEATURE == ON) || (F_E10 == ON)
#		define Sub_state_call_on_hold()	((Na_subscription_key != OFF) ? SUB_STATE_40 : SUB_STATE_36)
#		define Sub_state_hold_rq()		((Na_subscription_key != OFF) ? SUB_STATE_41 : SUB_STATE_30)
#		define Sub_state_reconn_rq()	((Na_subscription_key != OFF) ? SUB_STATE_42 : SUB_STATE_33)
#	else
#		define Sub_state_call_on_hold()	SUB_STATE_36
#		define Sub_state_hold_rq()		SUB_STATE_30
#		define Sub_state_reconn_rq()	SUB_STATE_33
#	endif
#endif

			/* NTT-specific sub states */

#if (F_NTT == ON)
#	define SUB_STATE_HOLD_RQ		1				/* waiting for a response to a HOLD RQ */
#	define SUB_STATE_HELD			2				/* waiting for a RECONN RQ */
#	define SUB_STATE_RECONN_RQ		3				/* waiting for a response to a RECONN RQ */
#endif

			/* Supplementary services sub-state */

#define SUB_STATE_CALL_INDEPENDENT	250				/* sub-state indicating that a NS context is allocated for a
														supplementary service independent of a call (bearer-independent) */

		/* service type */

#if (F_AT5 == ON)
#	define AT5_SERVICE_VOICE		1				/* used in ATT_5E5 */
#	define AT5_SERVICE_DATA			2				/* used in ATT_5E5 */
#endif

#if (F_E10 == ON)
#	define E10_SERVICE_VOICE		1				/* used in ATT_5E10 */
#	define E10_SERVICE_DATA			2				/* used in ATT_5E10 */
#endif

		/* USER-TO-USER SIGNALLING CONSTANTS */

#define MX_UI_COUNT					2				/* will allow a 2 USER INFO message in service #2 */

		/* call permanence values */

#define NS_NOT_PERMANENT_CIRCUIT	255				/* standard call permanence value */
#define NS_SEMI_PERMANENT_CIRCUIT	1				/* semi-permanent circuit */

		/* auxiliary states associated with the Hold/Retrieve procedures */

#if NS_HOLD_RETRIEVE == ON
#	define NS_AUX_STATE_IDLE		'0'				/* Idle */
#	define NS_AUX_STATE_HOLD_RQ		'A'				/* Hold Request : a request has been made for the Hold function */
#	define NS_AUX_STATE_HOLD_IN		'a'				/* Hold Indication : a request has been received for the Hold function */
#	define NS_AUX_STATE_HELD		'1'				/* Call Held : the call is held */
#	define NS_AUX_STATE_RET_RQ		'B'				/* Retrieve Request : a request has been made for the Retrieve function */
#	define NS_AUX_STATE_RET_IN		'b'				/* Retrieve Indication : a request has been received for the Retrieve function */
#endif

/*-------------------------------------------------------------------------*/

						/* NS : EVENT MANAGEMENT */

		/* Call establishment spdu event */

#define DA_ALERT					'a'				/* alerting */
#define DA_CALL_PROC				'b'				/* call proceeding */
#define DA_CONN						'c'				/* connect */
#define DA_CONN_ACK 				'd'				/* connect acknowledge */
#define DA_SETUP					'e'				/* setup */
#define DA_SETUP_ACK				'f'				/* setup acknowledge */
#define DA_ROUTED_CALL 				'g'				/* routed call VN2 */
#define DA_PROGRESS					'*'				/* progress */

		/* Call information phase spdu event */

#define DA_RES						'h'				/* resume */
#define DA_RES_ACK					'i'				/* resume acknowledge */
#define DA_RES_REJ					'j'				/* resume reject */
#define DA_SUSP						'k'				/* suspend */
#define DA_SUSP_ACK					'l'				/* suspend acknowledge */
#define DA_SUSP_REJ					'm'				/* suspend reject */
#define DA_USER_INFO				'n'				/* user information */

		/* Clear call spdu event */

#define DA_DISC						'q'				/* disconnect */
#define DA_REL						'r'				/* release */
#define DA_REL_COMP					's'				/* release complete */

		/* Miscellaneous spdu event */

#define DA_INFO						'o'				/* information */
#define DA_REG						'p'				/* registration */
#define DA_NOTIFY					't'				/* notify */
#define DA_REG_ACK					'u'				/* registration acknowledge */
#define DA_REG_REJ					'v'				/* registration reject */
#define DA_SEG_MSG					'v'				/* segmented message ETSI */
#define DA_CON_CON					'w'				/* congestion control */
#define DA_FAC						'x'				/* facility */
#define DA_FAC_ACK					'y'				/* facility acknowledge */
#define DA_FAC_REJ					'z'				/* facility reject */
#define DA_STATUS					'%'				/* status */
#define DA_RESTART					'+'				/* restart */
#define DA_RESTART_ACK				'-'				/* restart acknowledge */
#define DA_STATUS_ENQ				'/'				/* status enquiry */
#define DA_DETACH					'2'				/* detach (TR6) */

#define DA_MAINT_SERVICE			'2'				/* service (maintenance) */
#define DA_MAINT_SERVICE_ACK		'3'				/* service acknowledge (maintenance) */

				/** defined in NS_INT.H

		DA_CONF						'2'				conference
		DA_CONF_ACK					'3'				conference acknowledge
		DA_CONF_REJ					'4'				conference reject
		DA_TRANS					'5'				transfer
		DA_TRANS_ACK				'6'				transfer acknowledge
		DA_TRANS_REJ				'7'				transfer reject
		DA_ASSOC					'8'				associated
		DA_ASSOC_ACK				'9'				associated acknowledge
		DA_DROP						'i'				drop
		DA_DROP_ACK					'j'				drop acknowledge
		DA_DROP_REJ					'k'				drop reject
		DA_RECONN					'v'				reconnect
		DA_RECONN_ACK				'w'				reconnect acknowledge
		DA_RECONN_REJ				'x'				reconnect reject
		DA_REDIR					'z'				redirect
		DA_FACILITY					'2'				facility (NTT)
		DA_HOLD						NS_EXT + 'h'	hold
		DA_HOLD_ACK					NS_EXT + 'i'	hold acknowledge
		DA_HOLD_REJ					NS_EXT + 'j'	hold reject

				**/

/*----- 1TR6 specific events - NOT_IMPLEMENTED -------*/

	/* Protocol discriminator N0 */

#define DA_CANCEL					'3'				/* facility cancel */
#define DA_CANC_ACK					'4'				/* cancel acknowledge */
#define DA_CANC_REJ					'5'				/* cancel reject */

	/* Protocol discriminator N1 :  */

#define DA_CANC_IND					'g'				/* cancel indication */
#define DA_CLOSE					't'				/* close */
#define DA_CLOSE_ACK				'6'				/* close acknowledge */
#define DA_FAC_INFO					'7'				/* facility information */
#define DA_FAC_STATUS				'8'				/* facility status */
#define DA_INFO_ACK					'9'				/* information acknowledge */
#define DA_INFO_REJ					'+'				/* information reject */
#define DA_REG_IND					'-'				/* registration indication */
#define DA_STATUS_ACK				'$'				/* status acknowledge */
#define DA_STATUS_REJ				'/'				/* status reject */

/*----- AT5 specific events -------*/

#define DA_MAN_INFO					'y'				/* management info */

/*----- AT5/9 specific events (Endpoint Initialization) -------*/

#define EV_INIT_RQ					'1'				/* Initialization request */
#define EV_ASSIGN_USID_TID			'2'				/* Assign USID-TID */
#define EV_NO_USID_TID				'3'				/* Message without USID-TID */
#define EV_USER_ACTION				'4'				/* User Action */
#define EV_USER_ASSIGN_SPID			'5'				/* User Action */
#define EV_BROADCAST_WITH_USID_TID	'6'				/* Broadcast message with USID-TID */
#define EV_NOT_BROADCAST_WITH_USID_TID	'7'			/* Broadcast message with USID-TID */
#define EV_ACK_USID_TID				'8'				/* Acknowledge USID-TID */
#define EV_REJECT					'9'				/* Reject USID-TID */
#define EV_GET						'G'				/* Get */
#define EV_SET						'S'				/* Set */
#define EV_REJECT_SPID_100			'0'				/* Invalid SPID IE */

/*----- DMS100 & N_ISDN1/2 or Hold/Retrieve specific events -------*/

#define DA_RET						NS_EXT + 'k'	/* retrieve */
#define DA_RET_ACK					NS_EXT + 'l'	/* retrieve acknowledge */
#define DA_RET_REJ					NS_EXT + 'm'	/* retrieve reject */

#define DA_K_HOLD					'z'				/* key hold */
#define DA_K_SETUP					'g'				/* key setup */
#define DA_K_SETUP_ACK				'p'				/* key setup acknowledge */
#define DA_K_REL					'u'				/* key release */

/*------ Internal events (NETWORK SIDE ONLY) ----------------*/

#if EQUIPMENT == NT2

		/*
			Global -> Individual : RQ
			Individual -> Global : IND
		*/

#	define	INT_ALERT_RQ				200			/* Alerting request  */
#	define	INT_ALERT_IN				201			/* Alerting indication  */
#	define	INT_CONN_RQ					202			/* Connect request */
#	define	INT_CONN_IN					203			/* Connect indication */
#	define	INT_CALL_PROC_RQ			204			/* Call proceeding request */
#	define	INT_CALL_PROC_IN			205			/* Call proceeding indication */
#	define	INT_SETUP_ACK_RQ			206			/* Setup acknowledge request */
#	define	INT_END_PROCESS				207			/* End process */
#	define	INT_REL_RQ					208			/* Release request */
#	define	INT_REL_IN					209			/* Release indication */
#	define	INT_INFO_RQ					210			/* Information request */
#	define	INT_INFO_IN					211			/* Information indication */
#	define	INT_PROGRESS_IN				212			/* Progress indication */
#	define	INT_REL_COMP_IN				213			/* Release complete indication */

#endif

/*-------------------------------------------------------------------------*/

						/* NS : ERROR MANAGEMENT */

			/* Error type */

#define FATAL								0		/* must be 0 because it is used as an error priority level */
#define NON_FATAL							'N'
#define IGNORED								'I'
#define CONDITIONAL							'C'

#define Error_nb()							nb_error
#define Error_reset()						nb_error = 0; ns_fatal_error_flag = OFF

extern uchar	ns_fatal_error_flag;		/* Fatal error flag ON/OFF */
extern uchar	nb_status_sent;				/* nb STATUS to the line for the current received message */

		/* structure used to send STATUS */

struct ns_status_var {
	uchar					spdu_processed;		/* flag indicating if received SPDU is processed */
	uchar					status_to_send;		/* flag indicating if a STATUS message is to be sent */
	struct message	FAR 	*p_first_msg;		/* pointer to first message to be sent after STATUS message */
	struct message	FAR 	*p_last_msg;		/* pointer to last message to be sent after STATUS message */
	uchar					cause_class;		/* cause class to put into STATUS message */
	uchar					cause_val;			/* cause value to put into STATUS message */
	uchar					cause_diag;			/* cause diagnostic to put into STATUS message */
};

#define Ns_spdu_processed			ns_status_var.spdu_processed
#define Ns_status_to_send			ns_status_var.status_to_send
#define Ns_status_p_first_msg		ns_status_var.p_first_msg
#define Ns_status_p_last_msg		ns_status_var.p_last_msg
#define Ns_status_cause_class		ns_status_var.cause_class
#define Ns_status_cause_val			ns_status_var.cause_val
#define Ns_status_cause_diag		ns_status_var.cause_diag

/*-------------------------------------------------------------------------*/

						/* NS : IE MANAGEMENT */

		/* IE type */

#define MD									'M'		/* Mandatory IE type */
#define OP									'O'		/* Optional IE type */
#define EX									'X' 	/* eXclude IE type */
#define CD									'C'		/* Conditional IE type needing special treatment */

		/* Macro used to evaluate the IE type */

#define	Ie_type(spdu_id_p, ie_id_p, ie_type_p) \
					((ie_type_p == CD) ? \
					 Ie_type_eval (spdu_id_p, ie_id_p) :\
					 ie_type_p)

		/* IE Codeset Definition */

#define CODESET_LGTH			3
#define CODESET_0 				G_3 (0,0,0)					/* CCITT */
#define CODESET_5				G_3 (1,0,1)					/* CEPT */
#define CODESET_6				G_3 (1,1,0)					/* national */
#define CODESET_7				G_3 (1,1,1)					/* user specific */

#define CODESET_SO				G_4 (1,1,1,1)				/* single octet IE in codeset 0 - fictive codeset */
#define CODESET_S5				(CODESET_SO + CODESET_5)	/* single octet IE in codeset 5 - fictive codeset */
#define CODESET_S6				(CODESET_SO + CODESET_6)	/* single octet IE in codeset 6 - fictive codeset */
#define CODESET_S7				(CODESET_SO + CODESET_7)	/* single octet IE in codeset 7 - fictive codeset */

#define CODESET_MINI			CODESET_0			/* codeset mini */
#define CODESET_MAXI			CODESET_7			/* codeset maxi */

#define CODESET_NIL				255					/* codeset NIL */

		/*  IE ID */

#define IE_ID_LGTH				7

				/* =-= Single Octet (SO) IE IDentifier in codeset 0 =-= */

#define MORE_DATA  			G_7 (0,1,0, 0,0,0,0)	/* more data or sending complete */
#define SENDING_COMPLETE	G_7 (0,1,0, 0,0,0,1)	/* sending complete */
#define REPEAT_IND			G_7 (1,0,1, 0,0,0,0)	/* repeat indicator */
#define CONGEST_LEVEL		G_7 (0,1,1, 0,0,0,0)	/* congestion level */

				/* =-= Codeset 0 IE =-= */

#define SEGMENTED			G_7 (0,0,0, 0,0,0,0)	/* segmented message */
#define BC					G_7 (0,0,0, 0,1,0,0)	/* bearer capability */
#define CAUSE				G_7 (0,0,0, 1,0,0,0)	/* cause */
#define CONN_NB				G_7 (0,0,0, 1,1,0,0)	/* connected address (codeset 5 for BV1) */
#define EXTENDED_FAC		G_7 (0,0,0, 1,1,0,1)	/* extended facility (for supplementary services) */
#define CALL_ID				G_7 (0,0,1, 0,0,0,0)	/* call identity */
#define CALL_STATE			G_7 (0,0,1, 0,1,0,0)	/* call state */
#define CHAN_ID				G_7 (0,0,1, 1,0,0,0)	/* channel identification */
#define FACILITY			G_7 (0,0,1, 1,1,0,0)	/* facility */
#define PROGRESS_IND		G_7 (0,0,1, 1,1,1,0)	/* progress indicator */
#define SPF_FAC				G_7 (0,1,0, 0,0,0,0)	/* network-specific facility */
#define TE_CAP				G_7 (0,1,0, 0,1,0,0)	/* AT5 terminal capabilities */
#define NOTIF_IND			G_7 (0,1,0, 0,1,1,1)	/* notification indicator */
#define DISPLAY				G_7 (0,1,0, 1,0,0,0)	/* display */
#define DATE_TIME			G_7 (0,1,0, 1,0,0,1)	/* date and time */
#define KEYPAD				G_7 (0,1,0, 1,1,0,0)	/* keypad */
#define INFORMATION_RQ		G_7 (0,1,1, 0,0,1,0)	/* AT9/DMS100/HK_TEL information request */
#define SIGNAL				G_7 (0,1,1, 0,1,0,0)	/* signal */
#define SWITCHHOOK			G_7 (0,1,1, 0,1,1,0)	/* switchhook */
#define FEATURE_ACT			G_7 (0,1,1, 1,0,0,0)	/* feature activation (codeset 6 for AT5) */
#define FEATURE_IND			G_7 (0,1,1, 1,0,0,1)	/* feature indication (codeset 6 for AT5) */
#define SPID				G_7 (0,1,1, 1,0,1,0)	/* DMS100 endpoint identifier */
#define ENDPOINT_ID			G_7 (0,1,1, 1,0,1,1)	/* endpoint identifier */

#define CALLING_NB			G_7 (1,1,0, 1,1,0,0)	/* calling party number */
#define CALLING_SUB_ADD		G_7 (1,1,0, 1,1,0,1)	/* calling party subaddress */
#define CALLED_NB			G_7 (1,1,1, 0,0,0,0)	/* called party number */
#define CALLED_SUB_ADD		G_7 (1,1,1, 0,0,0,1)	/* called party subaddress */
#define O_CALLED_NB			G_7 (1,1,1, 0,0,1,1)	/* (DMS) original called party number */
#define REDIR_NB			G_7 (1,1,1, 0,1,0,0)	/* redirecting number */
#define REDIRECTION_NB		G_7 (1,1,1, 0,1,1,0)	/* redirection number */
#define TRANSIT_NET_SEL 	G_7 (1,1,1, 1,0,0,0)	/* transit network selection */
#define RESTART_IND			G_7 (1,1,1, 1,0,0,1)	/* restart indicator */
#define LLC					G_7 (1,1,1, 1,1,0,0)	/* low layer compatibility */
#define HLC					G_7 (1,1,1, 1,1,0,1)	/* high layer compatibility */
#define UUI					G_7 (1,1,1, 1,1,1,0)	/* user-user */
#define ESCAPE				G_7 (1,1,1, 1,1,1,1)	/* escape for extension */

#define	QSI_CONN_NB			G_7 (1,0,0, 1,1,0,0)	/* connected address */
#define	QSI_CONN_SUB_ADD	G_7 (1,0,0, 1,1,0,1)	/* connected sub address */
#define	CONNECTED_NB		G_7 (1,0,0, 1,1,0,0)	/* connected address */
#define	CONNECTED_SUB_ADD	G_7 (1,0,0, 1,1,0,1)	/* connected sub address */

				/* =-= Codeset 5 IE =-= */

#define	PRECEDENCE_LEVEL	G_7 (1,0,0, 0,0,0,1)	/* Precedence level information */
#define OS_ACCSS			G_7 (0,0,1, 1,1,0,1)	/* Operator system access */
#define DISPLAY_TXT			G_7 (0,1,0, 1,0,1,0)	/* display text */

#define CONN_SUB_ADD		G_7 (0,0,0, 1,1,0,1)	/* BV1 connected sub address */
#define ADVICE_CHARGE		G_7 (0,0,1, 1,0,1,0)	/* BV1/SWD charging information */

#define	TRANSIT_COUNTER		G_7	(0,1,1, 0,0,0,1)	/* transit counter */
#define	PARTY_CATEGORY		G_7	(0,1,1, 0,0,1,0)	/* party category */

				/* =-= Codeset 6 IE =-=*/

#define USER_MODE			G_7 (0,1,0, 0,1,0,0)	/* VN user mode */
#define	USER_PCS			G_7 (1,1,1, 0,1,1,0)	/* VN User Information to PCS */
#define	PCS_USER			G_7 (1,1,1, 0,1,1,1)	/* VN PCS to User Information */
#define USER_FAC			G_7 (1,1,1, 1,0,1,0)	/* VN user facility */

#define SERVICE_IND			G_7 (0,0,0, 0,0,0,1)	/* TR6 service indicator */

#define CHARGING_INFO		G_7 (0,0,0, 0,0,1,0)	/* TR6 charging information */
#define DATE				G_7 (0,0,0, 0,0,1,1)	/* TR6 date */
#define FAC_SELECT			G_7 (0,0,0, 0,1,0,1)	/* TR6 facility select */
#define FAC_STAT			G_7 (0,0,0, 0,1,1,0)	/* TR6 facility status */
#define CALLED_STATUS		G_7 (0,0,0, 0,1,1,1)	/* TR6 called status */
#define ADD_ATTRIB			G_7 (0,0,0, 1,0,0,0)	/* TR6 additional transmition attributes */

#define NTT_ADVICE_CHARGE	G_7 (0,0,0, 0,0,0,1)	/* NTT charging information */

#define ASSOC_TYPE			G_7 (0,1,0, 0,0,0,1)	/* AT5 associated type */
#define SEL_CALL_APPEAR		G_7 (0,1,0, 0,0,1,0)	/* AT5 selected call appearance */
#define ORI_CALL_APPEAR		G_7 (0,1,0, 0,0,1,1)	/* AT5 origination call appearance */
#define DEST_CALL_APPEAR	G_7 (0,1,0, 0,1,0,1)	/* AT5 destination call appearance */

#define AT5_ENDPOINT_ID		G_7 (0,1,0, 0,1,1,0)	/* AT5 endpoint identifier */
#define E10_ENDPOINT_ID		G_7 (0,1,0, 0,1,1,0)	/* E10 endpoint identifier */

#define KEYPAD_CON			G_7 (0,1,1, 0,0,1,0)	/* AT5 keypad control */
#define OTHER_CALL_REF		G_7 (0,1,1, 0,1,1,1)	/* AT5 other call reference */
#define ADJUNCT_CON			G_7 (0,1,1, 1,0,1,0)	/* AT5 adjunct control */
#define DISPLAY_CON			G_7 (0,1,1, 1,0,1,1)	/* AT5 display control */
#define DISPLAY_FLD			G_7 (0,1,1, 1,1,0,0)	/* AT5 display field */
#define MANAGMNT			G_7 (1,1,1, 1,0,1,0)	/* AT5 management */

#define PROT_VER_CTRL		G_7 (0,1,1, 1,1,1,0)	/* DSM100 protocol version control */
#define CLOSED_USER_GROUP	G_7 (1,0,0, 0,0,0,1)	/* DSM100 closed user group */
#define REVERSE_CHARG_IND	G_7 (1,0,0, 0,0,1,0)	/* DSM100 reverse charging indication */
#define REDIR_SUB_ADD		G_7 (1,1,1, 0,1,0,1)	/* redirecting subaddress */
#define CALL_APPEAR			G_7 (1,1,1, 1,0,1,1)	/* call appearance */

#define	USER_ENTERED_CODE	G_7 (0,0,0, 0,0,1,0)	/* AT10 User entered code */
#define	TRAVELING_CLASSMARK	G_7 (0,0,0, 1,0,0,0)	/* AT10 Traveling classmark */

				/* =-= Codeset 7 IE =-=*/

#define	CREDIT_CARD_NB		G_7 (0,0,0, 1,1,0,0)	/* credit card information */
#define	AIRCRAFT_INFO		G_7 (0,0,0, 1,1,0,1)	/* aircraft information (A11) */
#define	CREDIT_CARD_STATUS	G_7 (0,0,0, 1,1,0,1)	/* credit card status */
#define	QUEUE_INFO			G_7 (0,0,0, 1,1,1,0)	/* queue information */
#define	QUEUE_REQUEST		G_7 (0,0,0, 1,1,1,1)	/* queue request */
#define	ROUTE_SELECT		G_7 (0,0,1, 1,1,1,1)	/* route select */
#define	DTMF_2_DIALING		G_7 (0,1,0, 1,1,0,0)	/* Dual Tone MultiFrequency secondary dialing */

	/* Packet communications IE (not implemented) ETSI */

#define INF_RATE			G_7 (1,0,0, 0,0,0,0)	/* information rate */
#define E_T_E_DLY			G_7 (1,0,0, 0,0,1,0)	/* end-to-end transit delay */
#define TRANSIT_DLY_SEL		G_7 (1,0,0, 0,0,1,1)	/* transit delay selection and indicator */
#define PACKET_LBP			G_7 (1,0,0, 0,1,0,0)	/* packet layer binary parameters */
#define PACKET_LWS			G_7 (1,0,0, 0,1,0,1)	/* packet layer window size */
#define PACKET_SIZE			G_7 (1,0,0, 0,1,1,0)	/* packet size */

	/* Management information element */

#define	CHANGE_STATUS		G_7 (0,0,0, 0,0,0,1)	/* Change status */

	/* fictitious IE for SPF_FACILITY (SSDU side) */

#define SERVICE_ID			G_7 (1,1,1, 1,1,1,1)	/* service identifier */


#define MESSAGE_HEADER		G_8(1,0,0,0,0,0,0,0)	/* pseudo-IE "message header parameters" */

#define IE_NIL				G_8(1,1,1,1,1,1,1,1)	/* ie null value */
#define IE_MINI				SEGMENTED				/* ie minimum value */
#define IE_MAXI				ESCAPE	                /* IE maximum value */

		/* IE structure table description */

struct ie {
	uchar 			codeset;						/* ie codeset */
	uchar 			ident;							/* ie id inside the codeset */
	uchar 			*p_prog;						/* program sequence address */
	ushort 			i_size;							/* size of the internal structure */
	uchar 			*p_i_struct;					/* address of the internal structure */
	uchar 			*p_init_spdu;					/* address of the implicit constant values used receiving a SPDU */
	uchar 			*p_init_ssdu;					/* address of the implicit constant values used receiving a SSDU */
	uchar			mx_repetition;					/* maximum number of repeated IE in a SPDU message */
	ushort			tsp_data_offset;
};

#define IE_ELEM_SIZE			Rnd_sizeof (struct ie)

		/*
		   Access to the ie table elements using
		   the table tab_ie and an ie index.
		*/

#define Ie_codeset(xx) 			Tab_ie[xx].codeset
#define Ie_ident(xx)			Tab_ie[xx].ident
#define Ie_p_prog(xx)			Tab_ie[xx].p_prog
#define Ie_i_size(xx)			Tab_ie[xx].i_size
#define Ie_p_i_struct(xx)		Tab_ie[xx].p_i_struct
#define Ie_p_init_spdu(xx)		Tab_ie[xx].p_init_spdu
#define Ie_p_init_ssdu(xx)		Tab_ie[xx].p_init_ssdu
#define Ie_mx_repetition(xx) 	Tab_ie[xx].mx_repetition
#define	Ie_tsp_data_offset(xx)	Tab_ie[xx].tsp_data_offset

			/* Rem :
				ie_x 	= IE index in the 'struct ie' table,
				i_ie_x	= IE repetition value.
			*/

#define	Ie_p_tsp_data(ie_x, i_ie_x)	*((char **)(Ie_p_i_struct (ie_x) + (Ie_tsp_data_offset (ie_x) + (Ie_i_size (ie_x)) * i_ie_x)))


#define X_IE_NIL				255
#define Ie_key(vh, vl)			(((vh) << 8) + (vl))

#define Search_key_tab_ie(xx)				Ie_key (Ie_codeset (xx), Ie_ident (xx))
#define Search_key_ie(xx_codeset, xx_ie_id) Ie_key (xx_codeset, xx_ie_id)

#define Access_tab_ie(key)		ns_access_tab_ie(key)

#if OPTIMIZATION == SPEED

			/* IE hash-coding access */

#	define SIZE_X_IE_MAIN		199					/* prime number */

#	define SIZE_X_IE_OVERFLOW	(SIZE_X_IE_MAIN/5)

#	define MINI_SEARCH_KEY_IE	Search_key_ie (CODESET_MINI, IE_MINI)

#	define X_IE_LINK_NIL		0

#	define Hcod_ie(key)			(((key) & Mask (8)) - IE_MINI) % SIZE_X_IE_MAIN

#endif

#define 	PR   				1					/* present element */
#define     MI					0					/* missing element , just for initialization */

/*-------------------------------------------------------------------------*/

					/* NS : META-LANGUAGE MANAGEMENT */

	/* CONSTANT */

#define MX_SKIP_LEVEL			6					/* skip maximum level */

	/* Interpreter program codes */

		/* Condition codes */

#define I_IF					0					/* comparison with i_xxx[j].yyy Internal structure IE field */
#define N_IF					1					/* Normal comparison with a variable (e.g. ie_if_flag) */

#define EQ						0					/* equal */
#define NE	 					1           		/* not equal */

#define IN						EQ					/* for tables */
#define NOT_IN					NE

		/* Instruction code */

#define INST_TABL 				1					/* verify in a table of values */
#define INST_TABX				2					/* verify in a list of tables according to an index value */
#define INST_EXT_1				3					/* no more extension octet */
#define INST_EXT_0_1			4					/* more extension octet possible */
#define INST_PAD				5					/* padding field */
#define INST_IF_VAL				6					/* IF instruction : skip following instruction
													until ENDIF or END if the value is EQ to a constant */
#define INST_END_IF				7					/* end of an IF block */
#define INST_TEXT				8					/* verify an array of octets to be a text */
#define INST_VAL				9					/* verify a value to be equal to a constant */
#define INST_END				10					/* end of the instruction sequence */
#define INST_IF_TABL			11					/* the IF condition is that a value is or is not
													inside a table of value */
#define INST_START 				12					/* start of the instruction sequence */
#define INST_FUNCT				13					/* call a specific function */
#define INST_END_OCTET			14					/* end of the current octet without extension bit */
#define INST_OPTIONAL_OCTET		15					/* end of the current octet without extension bit */
#define INST_ANY_VAL			16					/* any value : no check */
#define INST_ELSE				17					/* ELSE : process the following instructions
													thru the next END_IF instruction */
		/* Text code verification */

#define IA5						1					/* text is International Alphabet n 5 */
#define BINARY					2					/* text is any bit pattern */
#define TABLE					3					/* text is any character listed */

		/* Text  limitation */

#define ANY_CHAR				1					/* all char codes are valid */
#define DIGIT					2					/* only digit codes are valid */
#define DIGIT_E					3					/* only digit codes and # * are valid */
#define ANY_OCTET				4					/* any pattern available */

		/* Table structure */

#define X_TABL_NIL				0					/* null tab index */

struct tabl {
	uchar 			id;								/* table identifier */
	uchar 			size;							/* number of value in the table */
	uchar 			*p_list_val;					/* address of the list of values */
};

#define Tabl_ident(xx)								Tab_tabl[xx].id
#define Tabl_size(xx)								Tab_tabl[xx].size
#define Tabl_p_list_val(xx)							Tab_tabl[xx].p_list_val

#define T_NIL					0

		/* Macro used to access to the tab_tabl table */

#define Access_tab_tabl(xx)							(((xx) > Size_tab_tabl) ? X_TABL_NIL : (xx))
#define Search_key_tabl(tabl_id)					tabl_id
#define Search_key_tab_tabl(xx)         			Tabl_ident (xx)

		/* Indexed table */

struct tabx {
	uchar 			id;		 						/* table identifier */
	uchar 			size;							/* number of table in the list of table */
	struct 			tabx_list *p_list_tab;			/* address of the list of table */
};

#define Tabx_ident(xx)								Tab_tabx[xx].id
#define Tabx_size(xx)								Tab_tabx[xx].size
#define Tabx_p_list_tab(xx)							Tab_tabx[xx].p_list_tab

		/* Macro used to access to the tab_tabx table */

#define Access_tab_tabx(xx)							((xx) > Size_tab_tabx ? X_TABX_NIL : xx)
#define Search_key_tabx(tabl_id)					(tabl_id)
#define Search_key_tab_tabx(xx)         			Tabx_ident (xx)

#define X_TABX_NIL									0	/* null tab index */

		/* List of table for indexed table */

struct tabx_list {
	uchar 			size;							/* number of value in the table */
	uchar 			*p_val;							/* address of the list of values */
};

/*-------------------------------------------------------------------------*/

						/* NS : SSDU MANAGEMENT */

			/* SSDU IE model description */

struct ssdu_ie {
	uchar 			codeset;						/* codeset */
	uchar 			id;								/* IE ID */
	uchar  			add;							/* is the IE present in the SSDU ? (possible no external
													   representation for an IE */
	uchar 			type;							/* Mandatory or Optional */
	uchar 			*p_prog;						/* Meta program start address */
	uchar			repetition;						/* maximum number of repeated IE instances
													   in the SSDU */
};

		/*
		   Macro used to access the ssdu_ie values thru the
		   p_ssdu_ie current pointer.
		*/

#define Ssdu_ie_codeset			((struct ssdu_ie *)p_ssdu_ie) -> codeset
#define Ssdu_ie_id				((struct ssdu_ie *)p_ssdu_ie) -> id
#define Ssdu_ie_add				((struct ssdu_ie *)p_ssdu_ie) -> add
#define Ssdu_ie_type			((struct ssdu_ie *)p_ssdu_ie) -> type
#define Ssdu_ie_p_prog			((struct ssdu_ie *)p_ssdu_ie) -> p_prog
#define Ssdu_ie_repetition		((((struct ssdu_ie *)p_ssdu_ie) -> repetition == 0) ? 1 : ((struct ssdu_ie *)p_ssdu_ie) -> repetition)

	/* empty SSDU IE for the SSDU primitives with no additional IE */

#define SSDU_IE_NIL 			{0, 0, MI}

		/* SSDU model description */

struct ssdu {
	uchar 			ident;							/* primitive ID */
	uchar			usage;							/* usage of the primitive */
	struct ssdu_ie 	*p_ie;							/* address of the IE table model */
	uchar 			ie_size_v;						/* number of entry in the IE table model */

#	if EQUIPMENT == NT2
		struct ssdu_ie 	*p_net_ie;					/* FG_NT_TE : address of the IE table model */
		uchar 			net_ie_size_v;				/* FG_NT_TE : number of entry in the IE table model */
#	endif

};

#define SSDU_ELEM_SIZE			Rnd_sizeof (struct ssdu)

		/* Macro access thru an index of the  table tab_ssdu[] */

#define Ssdu_ident(xx)			Tab_ssdu[xx].ident
#define Ssdu_usage(xx)			Tab_ssdu[xx].usage
#define Ssdu_p_ie(xx)			Tab_ssdu[xx].p_ie
#define Ssdu_ie_size(xx)		Tab_ssdu[xx].ie_size_v
#define Ssdu_p_net_ie(xx)		Tab_ssdu[xx].p_net_ie
#define Ssdu_net_ie_size(xx)	Tab_ssdu[xx].net_ie_size_v

#define Search_key_tab_ssdu(xx)		Ssdu_ident (xx)
#define Search_key_ssdu(xx_ssdu)	((uchar)(xx_ssdu))

#define X_SSDU_NIL				255					/* NIL index */

#if OPTIMIZATION == SPEED

							/* HASH-CODING MANAGEMENT */

	struct	hcod	{
		uchar	x_access;
		uchar	x_link;
	};

		/* SSDU hash-code access table : without overflow */

#	define	SIZE_X_SSDU			(SSDU_MAXI - SSDU_MINI + 1)

#	define MINI_SEARCH_KEY_SSDU	Search_key_ssdu (SSDU_MINI)
#	define MAXI_SEARCH_KEY_SSDU	Search_key_ssdu (SSDU_MAXI)

#	define Hcod_ssdu(key)		((key) - MINI_SEARCH_KEY_SSDU)

#	define Access_tab_ssdu(key)	(((key) < MINI_SEARCH_KEY_SSDU) ? X_SSDU_NIL :\
								((key) > MAXI_SEARCH_KEY_SSDU) ? X_SSDU_NIL :\
								X_tab_ssdu [Hcod_ssdu (key)])
#else

#	define Access_tab_ssdu(key)	ns_access_tab_ssdu(key)

#endif	/* SPEED */

/*-------------------------------------------------------------------------*/

						/* NS : SPDU MANAGEMENT */

			/* SPDU parameters description */

struct spdu_param {
	uchar	net_protocol_discriminator;				/* protocol discriminator */
	uchar	call_ref_lgth_bri;						/* BRI call reference length for outgoing call */
	uchar	call_ref_lgth_bri_min;					/* BRI call reference minimum length for checking incoming SPDU */
	uchar	call_ref_lgth_bri_max;					/* BRI call reference maximum length for checking incoming SPDU */
	uchar	call_ref_lgth_pri;						/* PRI call reference length for outgoing call */
	uchar	call_ref_lgth_pri_min;					/* PRI call reference mimimum length for checking incoming SPDU */
	uchar	call_ref_lgth_pri_max;					/* PRI call reference maximum length for checking incoming SPDU */
	uchar	ie_codeset_order_meaningful;			/* Information Element ordered by IE ID only (regardless to the codeset - OFF) or by IE ID within each codeset (ON) */
	uchar	ie_locking_shift;						/* use of single octet IE with locking shift allowed or not (ON or OFF) */
	uchar	ie_non_locking_shift;					/* use of single octet IE with non locking shift allowed or not (ON or OFF) */
	uchar	null_lgth_ie_ignored;					/* null length IE means that it is missing (ON) or not (OFF) */
	uchar	msg_type_mx_lgth;						/* spdu message type maximum length */
	uchar	call_ref_global_not_meaningful;			/* Global call reference is treated as a normal call reference */
	uchar	segmentation_activation;				/* NS segmentation is implemented (ON) or not (OFF) */
	uchar	restart_procedure;						/* NS restart procedures are implemented (ON) or not (OFF) */
	uchar	mx_dl_retry;							/* maximum number of restablish Data Link retry */
	uchar	d_channel;								/* D channel */
	uchar	mx_b_channel;							/* maximum number of B channels */
};

#define Spdu_param_net_protocol_discriminator		Tab_spdu_param[0].net_protocol_discriminator
#define Spdu_param_call_ref_lgth_bri				Tab_spdu_param[0].call_ref_lgth_bri
#define Spdu_param_call_ref_lgth_bri_min			Tab_spdu_param[0].call_ref_lgth_bri_min
#define Spdu_param_call_ref_lgth_bri_max			Tab_spdu_param[0].call_ref_lgth_bri_max
#define Spdu_param_call_ref_lgth_pri				Tab_spdu_param[0].call_ref_lgth_pri
#define Spdu_param_call_ref_lgth_pri_min			Tab_spdu_param[0].call_ref_lgth_pri_min
#define Spdu_param_call_ref_lgth_pri_max			Tab_spdu_param[0].call_ref_lgth_pri_max
#define Spdu_param_ie_codeset_order_meaningful		Tab_spdu_param[0].ie_codeset_order_meaningful
#define Spdu_param_ie_locking_shift    				Tab_spdu_param[0].ie_locking_shift
#define Spdu_param_ie_non_locking_shift				Tab_spdu_param[0].ie_non_locking_shift
#define Spdu_param_null_lgth_ie_ignored				Tab_spdu_param[0].null_lgth_ie_ignored
#define Spdu_param_msg_type_mx_lgth					Tab_spdu_param[0].msg_type_mx_lgth
#define Spdu_param_call_ref_global_not_meaningful	Tab_spdu_param[0].call_ref_global_not_meaningful
#define Spdu_param_segmentation						Tab_spdu_param[0].segmentation_activation
#define Spdu_param_restart_procedure				Tab_spdu_param[0].restart_procedure
#define Spdu_param_d_channel						Tab_spdu_param[0].d_channel
#define Spdu_param_mx_b_channel						Tab_spdu_param[0].mx_b_channel

#define PROTOCOL_DISCR_SIZE							1
#define CALL_REF_LGTH_SIZE							1
#define MSG_TYPE_SIZE_MIN							1
#define Spdu_param_spdu_lgth_min					PROTOCOL_DISCR_SIZE + CALL_REF_LGTH_SIZE + (Na_type == BRI ? Spdu_param_call_ref_lgth_bri_min : Spdu_param_call_ref_lgth_pri_min) + MSG_TYPE_SIZE_MIN

			/* SPDU message model description */

struct spdu {
	uchar 			ident;							/* SPDU ID */
	uchar 			event_id;						/* automata event ID generated */
	uchar 			u_n;							/* User to Network direction (list of functional grouping) */
	uchar  			n_u;							/* Network to User direction (list of functional grouping) */
	uchar 			access_type;					/* access type : PRI, BRI, PRI+BRI */
	struct	spdu_ie *p_ie;							/* pointer on the IE model array */
	struct	spdu_ie_so *p_ie_so;					/* pointer on the IE SO model array */

#	if NS_MAINTENANCE_CAPABILITY == ON
		uchar		protocol;						/* protocol discriminator */
#	endif

};

#define SPDU_ELEM_SIZE			Rnd_sizeof (struct spdu)

		/* Access */

#define	Spdu_ident(xx)			Tab_spdu[xx].ident
#define Spdu_event_id(xx)   	Tab_spdu[xx].event_id
#define Spdu_u_n(xx)			Tab_spdu[xx].u_n
#define Spdu_n_u(xx)			Tab_spdu[xx].n_u
#define Spdu_access_type(xx)	Tab_spdu[xx].access_type
#define Spdu_p_ie(xx)			Tab_spdu[xx].p_ie
#define Spdu_p_ie_so(xx)		Tab_spdu[xx].p_ie_so
#define Spdu_protocol(xx)		(Tab_spdu[xx].protocol == 0) ? Spdu_param_net_protocol_discriminator : Tab_spdu[xx].protocol

#define Search_key_spdu(xx_spdu)	((uchar)(xx_spdu))		/* !!! ANY CHANGE OF THIS MACRO SHOULD CAUSE A CHANGE IN MACRO 'Access_tab_spdu' */
#define Search_key_tab_spdu(xx)		Spdu_ident(xx)

#define X_SPDU_NIL				255

#if OPTIMIZATION == SPEED


			/* Hash-code access table : without overflow */

#	define SIZE_X_SPDU			(SPDU_MAXI - SPDU_MINI + 1)

#	define MINI_SEARCH_KEY_SPDU	Search_key_spdu (SPDU_MINI)		/* !!! ANY CHANGE OF THIS MACRO SHOULD CAUSE A CHANGE IN MACRO 'Access_tab_spdu' */
#	define MAXI_SEARCH_KEY_SPDU	Search_key_spdu (SPDU_MAXI)

#	define Hcod_spdu(key)		((key) - MINI_SEARCH_KEY_SPDU)

	/*
	 * When Maintenance is ON, that algorithm does not work anymore,
	 * because we need to take care of the protocol discriminator.
	 */

#	if NS_MAINTENANCE_CAPABILITY == OFF

#		if SPDU_MINI == 0	/* in fact it should be MINI_SEARCH_KEY_SPDU but does not compile */
#			define Access_tab_spdu(key)	(((key) > MAXI_SEARCH_KEY_SPDU) ? X_SPDU_NIL :\
								X_tab_spdu [Hcod_spdu (key)])
#		else
#			define Access_tab_spdu(key)	(((key) < MINI_SEARCH_KEY_SPDU) ? X_SPDU_NIL :\
								((key) > MAXI_SEARCH_KEY_SPDU) ? X_SPDU_NIL :\
								X_tab_spdu [Hcod_spdu (key)])
#		endif

#	else

#		define Access_tab_spdu(key)	ns_access_tab_spdu(key)

#	endif

#else

#	define Access_tab_spdu(key)	ns_access_tab_spdu(key)

#endif	/* SPEED */

	/* Information Element model item description */

struct spdu_ie {
	uchar 			id;								/* IE ID */
	uchar 			codeset;						/* IE codeset */
	uchar 			u_n;							/* User to Network direction (list of functional grouping) */
	uchar 			n_u;							/* Network to User direction (list of functional grouping) */
	uchar 			type;							/* Mandory or Optional IE */
	uchar 			lgth_mini;						/* IE minimum length */
	uchar 			lgth_maxi;						/* IE maximum length */
	uchar			repetition;						/* maximum number of repetition */
};

	/* Macro access to the IE model thru a current pointer p_spdu_ie */

#define M_ie_id					p_spdu_ie -> id
#define M_ie_codeset			p_spdu_ie -> codeset
#define M_ie_u_n				p_spdu_ie -> u_n
#define M_ie_n_u				p_spdu_ie -> n_u
#define M_ie_type				p_spdu_ie -> type
#define M_ie_mini_lgth			p_spdu_ie -> lgth_mini
#define M_ie_maxi_lgth			p_spdu_ie -> lgth_maxi
#define M_ie_repetition 		p_spdu_ie -> repetition

	/* Information Element Single Octet model item description */

struct spdu_ie_so {
	uchar 			id;								/* IE ID */
	uchar 			codeset;						/* IE codeset */
	uchar 			u_n;							/* User to Network direction (list of functional grouping) */
	uchar 			n_u;							/* Network to User direction (list of functional grouping) */
	uchar 			type;							/* Mandory or Optional IE */
};

	/* Macro access to the IE SO model thru a current pointer p_spdu_ie_so */

#define M_so_ie_id				p_spdu_ie_so -> id
#define M_so_ie_codeset			p_spdu_ie_so -> codeset
#define M_so_ie_u_n				p_spdu_ie_so -> u_n
#define M_so_ie_n_u				p_spdu_ie_so -> n_u
#define M_so_ie_type			p_spdu_ie_so -> type

	/* Code for init_ie_i function */

#define SSDU_ID					'S'
#define SPDU_ID					'P'

/*==========================================================================*/

						/* SPDU MESSAGE DESCRIPTION */

		/* Message description (Signalling Protocol Data Unit description) */

			/* Protocol discriminator */

					/* R_xxxx read value */

#define R_protocol_discriminator					*p_ie

					/* S_xxx store value */

#define S_protocol_discriminator_load(val)			*(p_ie++)	= (val)

					/* Constants */

#define PROTOCOL_DISCRIMINATOR_I451		G_8 (0,0,0,0,1,0,0,0)	/* I.451 protocol discriminator */
#define PROTOCOL_DISCRIMINATOR_N0		G_8 (0,1,0,0,0,0,0,0)	/* german N0 protocol discriminator */
#define PROTOCOL_DISCRIMINATOR_N1		G_8 (0,1,0,0,0,0,0,1)	/* german N1 protocol discriminator */
#define PROTOCOL_DISCR_MAINTENANCE		G_8 (0,0,0,0,0,0,1,1)	/* Maintenance protocol discriminator */
#define PROTOCOL_DISCR_MAINT_ATT_CUST	G_8 (0,0,0,0,0,0,1,1)	/* AT&T Custom maintenance protocol discriminator */
#define PROTOCOL_DISCR_MAINT_NATIONAL	G_8 (0,1,0,0,0,0,1,1)	/* National maintenance protocol discriminator */

			/* Call reference flag values */

#define CALL_REF_GLOBAL_VAL			0				/* global call reference value */
#define CALL_REF_GLOBAL_LGTH		1				/* global call reference length */

#define CALL_REF_FLAG_POSITION		7				/* position of the call reference flag */

#define CALL_REF_FLAG_SND_ORIG		0				/* the message is sent FROM the side
													that originates the call reference */

#define CALL_REF_FLAG_SND_NOT_ORIG	1				/* the message is sent TO the side
													that originates the call reference */

#define CALL_REF_FLAG_RCV_ORIG		1				/* the receiver message side is the
													originator of the call */

#define CALL_REF_FLAG_RCV_NOT_ORIG	0				/* the receiver message side is not
													the originator of the call */

#define R_call_ref_lgth				((*p_ie) & Mask (4))

					/* Internal call reference access */

#define I_call_ref					i_call_ref
#define I_call_ref_lgth				i_call_ref_lgth

#define I_call_ref_sav				i_call_ref_sav
#define I_call_ref_lgth_sav			i_call_ref_lgth_sav

#define I_call_ref_flag				(uchar)(i_call_ref & Mask (1))

#define Is_call_ref_outgoing_call	(I_call_ref_flag == (CALL_REF_FLAG_RCV_ORIG ^ 1))

#define Is_call_ref_nil				(I_call_ref_lgth == CALL_REF_NIL)

#define Is_call_ref_global			((I_call_ref_lgth == CALL_REF_GLOBAL_LGTH) && ((I_call_ref_without_ces == CALL_REF_GLOBAL_VAL))

#define Set_call_ref_nil()			I_call_ref_lgth	= CALL_REF_NIL
#define Set_call_ref_not_nil()		I_call_ref_lgth	= (Call_current_exist) ? ((Na_type == BRI) ? 1 : 2) : (Na_restart_crl)

#define Call_ref_nber_next()		Call_ref_nber += 2

#if EQUIPMENT == NT2

#	define Ns_concat_ces_and_call_ref(ces)		I_call_ref += ((call_ref_t)ces << (8*(sizeof(call_ref_t) - 1)))

#	define I_call_ref_without_ces				(I_call_ref & ((call_ref_t)(~0L) >> 8))

#else

#	define I_call_ref_without_ces				I_call_ref

#endif

#define	Ns_get_actual_cr_val(cr)				(cr & 0xFFFF)	/* The call reference value uses the 2 low bytes */

					/* Call reference access thru Hcod table */

#define Call_ref_hcode(call_ref, tab_size)			(int)((call_ref_t)(call_ref) % (tab_size))

#if NS_MAINTENANCE_CAPABILITY == ON
#	define	Nfas_hcode(call_ref, tab_size)			(int)((call_ref_t)(call_ref) % (tab_size))
#endif

								/* Constants */

					/* Message type (spdu identifier) */

#define NSDU_LGTH		8							/* message type field length */

#define ADDITIONAL_SPDU	G_8 (0,0,0,0, 0,0,0,0)		/* additional spdu id */

						/* Call establishment messages */

#define ALERT 			G_8 (0,0,0,0, 0,0,0,1)		/* alerting */
#define CALL_PROC		G_8 (0,0,0,0, 0,0,1,0)		/* call proceeding */
#define CONN			G_8 (0,0,0,0, 0,1,1,1)		/* connect */
#define CONN_ACK 		G_8 (0,0,0,0, 1,1,1,1)		/* connect acknowledge */
#define PROGRESS		G_8 (0,0,0,0, 0,0,1,1)		/* progress */
#define SETUP			G_8 (0,0,0,0, 0,1,0,1)		/* setup */
#define SETUP_ACK		G_8 (0,0,0,0, 1,1,0,1)		/* setup acknowledge */
#define ROUTED_CALL 	G_8 (0,0,0,0, 0,0,1,1)		/* (vn2) appel achemine (routed call) */

						/* Call information phase messages */

#define RES				G_8 (0,0,1,0, 0,1,1,0)		/* resume */
#define RES_ACK			G_8 (0,0,1,0, 1,1,1,0)		/* resume acknowledge */
#define RES_REJ			G_8 (0,0,1,0, 0,0,1,0)		/* resume reject */
#define SUSP			G_8 (0,0,1,0, 0,1,0,1)		/* suspend */
#define SUSP_ACK		G_8 (0,0,1,0, 1,1,0,1)		/* suspend acknowledge */
#define SUSP_REJ		G_8 (0,0,1,0, 0,0,0,1)		/* suspend reject */
#define USER_INFO		G_8 (0,0,1,0, 0,0,0,0)		/* user info */
#define HOLD			G_8 (0,0,1,0, 0,1,0,0)		/* hold */
#define HOLD_ACK		G_8 (0,0,1,0, 1,0,0,0)		/* hold acknowledge */
#define HOLD_REJ		G_8 (0,0,1,1, 0,0,0,0)		/* hold reject */
#define RET				G_8 (0,0,1,1, 0,0,0,1)		/* retrieve */
#define RET_ACK			G_8 (0,0,1,1, 0,0,1,1)		/* retrieve acknowledge */
#define RET_REJ			G_8 (0,0,1,1, 0,1,1,1)		/* retrieve reject */

#define K_HOLD			G_8 (1,1,1,1, 1,0,1,1)		/* key hold */
#define K_REL			G_8 (1,1,1,1, 1,1,0,0)		/* key release */
#define K_SETUP			G_8 (1,1,1,1, 1,1,0,1)		/* key setup */
#define K_SETUP_ACK		G_8 (1,1,1,1, 1,1,1,0)		/* key setup acknowledge */

						/* Call clearing messages */

#define DETACH			G_8 (0,1,0,0, 0,0,0,0)		/* detach (TR6) */
#define DISC			G_8 (0,1,0,0, 0,1,0,1)		/* disconnect */
#define REL				G_8 (0,1,0,0, 1,1,0,1)		/* release */
#define REL_COMP		G_8 (0,1,0,1, 1,0,1,0)		/* release complete */
#define RESTART			G_8 (0,1,0,0, 0,1,1,0)		/* restart */
#define RESTART_ACK 	G_8 (0,1,0,0, 1,1,1,0)		/* restart acknowledge */

						/* Miscellaneous messages */

#define FAC				G_8 (0,1,1,0, 0,0,1,0)		/* facility */
#define CANC_ACK		G_8 (0,1,1,0, 1,1,1,0)		/* cancel acknowledge (TR6) */
#define CANC_REJ		G_8 (0,1,1,0, 0,1,1,1)		/* cancel reject (TR6) */
#define SEGMENT			G_8 (0,1,1,0, 0,0,0,0)		/* segment */
#define NOTIFY			G_8 (0,1,1,0, 1,1,1,0)		/* notify */
#define CANCEL			G_8 (0,1,1,0, 0,1,1,0)		/* facility cancel (TR6) */
#define REG				G_8 (0,1,1,0, 0,1,0,0)		/* registration */
#define REG_ACK			G_8 (0,1,1,0, 1,1,0,0)		/* registration acknowledge */
#define STATUS_ENQ		G_8 (0,1,1,1, 0,1,0,1)		/* status enquiry */
#define CON_CON			G_8 (0,1,1,1, 1,0,0,1)		/* congestion control */
#define INFO			G_8 (0,1,1,1, 1,0,1,1)		/* information */
#define STATUS			G_8 (0,1,1,1, 1,1,0,1)		/* status */

		/* Messages with maintenenance protocol discriminator */

#define MAINT_SERVICE		G_8 (0,0,0,0, 1,1,1,1)		/* service for maintenance */
#define MAINT_SERVICE_ACK	G_8 (0,0,0,0, 0,1,1,1)		/* service acknowldge for maintenance */

		/* additional message types (ATT_5E5) */

#define CONF			G_8 (1,0,0,1, 0,0,0,0)		/* conference */
#define CONF_ACK		G_8 (1,0,0,1, 0,0,0,1)		/* conference acknowledge */
#define CONF_REJ		G_8 (1,0,0,1, 0,0,1,0)		/* conference reject */
#define TRANS			G_8 (1,0,0,1, 0,0,1,1)		/* transfer */
#define TRANS_ACK		G_8 (1,0,0,1, 0,1,0,0)		/* transfer acknowledge */
#define TRANS_REJ		G_8 (1,0,0,1, 0,1,0,1)		/* transfer reject */
#define ASSOC			G_8 (1,0,0,1, 0,1,1,0)		/* associated */
#define ASSOC_ACK		G_8 (1,0,0,1, 0,1,1,1)		/* associated acknowledge */
#define DROP			G_8 (1,0,0,1, 1,0,0,0)		/* drop */
#define DROP_ACK		G_8 (1,0,0,1, 1,0,0,1)		/* drop acknowledge */
#define DROP_REJ		G_8 (1,0,0,1, 1,0,1,0)		/* drop reject */
#define REDIR			G_8 (1,0,1,1, 0,0,0,1)		/* redirect */
#define MAN_INFO		G_8 (1,1,1,1, 0,1,1,1)		/* management info */

	/* Associated with protocol discriminator N0 (TR6) */

#define REG_IND			G_8 (0,1,1,0, 0,0,0,1)		/* register indication */
#define CANC_IND		G_8 (0,1,1,0, 0,0,1,0)		/* cancel indication */
#define FAC_STATUS		G_8 (0,1,1,0, 0,0,1,1)		/* facility status */
#define STATUS_ACK		G_8 (0,1,1,0, 0,1,0,0)		/* status acknowledge */
#define STATUS_REJ		G_8 (0,1,1,0, 0,1,0,1)		/* status reject */
#define FAC_INFO		G_8 (0,1,1,0, 0,1,1,0)		/* facility information */
#define INFO_ACK		G_8 (0,1,1,0, 0,1,1,1)		/* information acknowmedge */
#define INFO_REJ		G_8 (0,1,1,0, 1,0,0,0)		/* information reject */
#define CLOSE			G_8 (0,1,1,1, 0,1,0,1)		/* close */
#define CLOSE_ACK		G_8 (0,1,1,1, 0,1,1,1)		/* close acknowledge */

	/*
		message types with same name but different code value
		according to the network ID :
	*/

				/* France Telecom VN2-VN3 */

#define FT_FAC			FAC							/* facility */
#define FT_FAC_ACK		G_8 (0,1,1,0, 1,0,1,0)		/* facility acknowledge */
#define FT_FAC_REJ		G_8 (0,1,1,1, 0,0,1,0)		/* facility reject (VN2) */
#define FT_REG_REJ		G_8 (0,1,1,1, 0,1,0,0)		/* registration reject */

#define NTT_FAC			FAC							/* facility */
#define NTT_RECONN		G_8 (0,0,1,1, 0,0,0,1)		/* reconnect */
#define NTT_RECONN_ACK	G_8 (0,0,1,1, 0,0,1,1)		/* reconnect acknowledge */
#define NTT_RECONN_REJ	G_8 (0,0,1,1, 0,1,1,1)		/* reconnect reject */

				/* TR6 - Associated with protocol discriminator N1 */

#define TR6_FAC			G_8 (0,1,1,0, 0,0,0,0)		/* facility */
#define TR6_STATUS		G_8 (0,1,1,0, 0,0,1,1)		/* status */
#define TR6_FAC_REJ		G_8 (0,1,1,0, 0,1,0,1)		/* facility reject */
#define TR6_FAC_ACK		G_8 (0,1,1,0, 1,0,0,0)		/* facility acknowledge */
#define TR6_CON_CON		G_8 (0,1,1,0, 1,0,0,1)		/* congestion control */
#define TR6_INFO		G_8 (0,1,1,0, 1,1,0,1)		/* information */
#define TR6_REG_REJ		G_8 (0,1,1,0, 1,1,1,1)		/* registration reject */

				/* AT5 */

#define AT5_HOLD		G_8 (1,0,0,1, 1,0,1,1)		/* hold */
#define AT5_HOLD_ACK	G_8 (1,0,0,1, 1,1,0,0)		/* hold acknowledge */
#define AT5_HOLD_REJ	G_8 (1,0,0,1, 1,1,0,1)		/* hold reject */
#define AT5_RECONN		G_8 (1,0,0,1, 1,1,1,0)		/* reconnect */
#define AT5_RECONN_ACK	G_8 (1,0,0,1, 1,1,1,1)		/* reconnect acknowledge */
#define AT5_RECONN_REJ	G_8 (1,0,1,1, 0,0,0,0)		/* reconnect reject */

				/* E10 */

#define E10_HOLD		G_8 (1,0,0,1, 1,0,1,1)		/* hold */
#define E10_HOLD_ACK	G_8 (1,0,0,1, 1,1,0,0)		/* hold acknowledge */
#define E10_HOLD_REJ	G_8 (1,0,0,1, 1,1,0,1)		/* hold reject */
#define E10_RECONN		G_8 (1,0,0,1, 1,1,1,0)		/* reconnect */
#define E10_RECONN_ACK	G_8 (1,0,0,1, 1,1,1,1)		/* reconnect acknowledge */
#define E10_RECONN_REJ	G_8 (1,0,1,1, 0,0,0,0)		/* reconnect reject */

#define SPDU_NIL    	G_8 (1,1,1,1, 1,1,1,1)		/* SPDU ID NIL */

#define SPDU_MINI		0							/* minimum value */

#define SPDU_MAXI		K_SETUP_ACK					/* maximum value */

#if NS_SIM_BUILDER == ON

			/* Hexadecimal coding of the messages' content */

#	define DA_HEXA_CODING			'>'

			/* SPDU error codes */

#	define SPDU_ID_UNKNOWN			G_8 (1,1,1,1,1,1,1,1)
#	define DA_SPDU_ID_UNKNOWN		'!'

			/* SPDU perturbation error codes */

#	define ERROR_PROTOCOL_DISCR		'A' 			/* protocol discriminator */
#	define ERROR_CALL_REF_LGTH		'B'				/* call reference length */
#	define ERROR_CALL_REF_PAD		'C'				/* call reference padding */
#	define ERROR_MESSAGE_LGTH		'D'				/* SPDU length */
#	define ERROR_IE_M_LGTH			'E'				/* mandatory Information Element length */
#	define ERROR_IE_M_CONTENT		'F'				/* mandatory Information Element content */
#	define ERROR_IE_M_MISSING		'G'				/* missing mandatory Information Element */
#	define ERROR_IE_O_LGTH			'H'				/* optional Information Element length */
#	define ERROR_IE_O_CONTENT		'I'				/* optional Information Element content */
#	define ERROR_IE_SEQUENCE		'J'				/* out of sequence Information Element */
#	define ERROR_IE_UNKNOWN			'K'				/* unknown information Element */

#endif

/*-------------------------------------------------------------------------*/

						/* NS : SPDU IE DESCRIPTION */

		/* Information elements */

#define Init_r_ie()				i_tab_ie[0] = IE_NIL
#define Init_s_ie()				i_tab_ie[0] = IE_NIL

			/* Field extension bit constants */

#define EXT_POSITION			7					/* position in an octet of the extension bit */
#define EXT_LGTH				1					/* length of the extension bit */

#define EXT_CONTINUE			G_1 (0)				/* the sequence of fields continue on next octet */
#define EXT_LAST				G_1 (1)				/* last octet of the sequence of fields */

			/* Categories of information element */

#define IE_FORMAT_LGTH			1					/* information element category bit length */
#define IE_FORMAT_SO 			G_1 (1)				/* single octet information element category value */
#define IE_FORMAT_VL			G_1 (0)				/* variable length information element categoty value */

			/* Single octet information element format */

				/* Single octet access macros using p_ie pointer */

#define So_ie_1_codeset 		Get_bits (*p_ie, 0, 3)
#define So_ie_1_lock 			Get_bits (*p_ie, 3, 1)
#define So_ie_1_id				Get_bits (*p_ie, 4, 3)

#define So_ie_1_load(codeset, lock, id, flag) *p_ie = \
								(((((((flag) << 3) + (id)) << 1) + \
								(lock)) << 3) + (codeset))

#define So_ie_2_id				Get_bits (*p_ie, 0, 7)
#define So_ie_2_load(id, flag)	*p_ie = (((flag) << 7) + (id))

#define So_ie_flag				Get_bits (*p_ie, 7, 1)

				/* Single octet ie identifier */

#define SHIFT					G_3 (0,0,1)			/* shift identifier */
#define IE_ID_SO				G_3 (0,1,0)			/* single octet IE */
#define CONGESTION_LEVEL		G_3 (0,1,1)			/* congestion level */
#define REPETITION_IND			G_3	(1,0,1)			/* repetition indicator */

				/* Shift element */

#define LOCKING_SHIFT			G_1 (0)				/* locking shift information element */
#define NON_LOCKING_SHIFT		G_1 (1)				/* non-locking shift information element */

			/* Variable length information element */

struct vl_ie {
	uchar			id;								/* IE ID */
	uchar			length;   						/* length of the content of information element ( octets) */
};

				/* Access to variable length information element value */

#define Vl_ie_id 				((struct vl_ie FAR *)p_ie) -> id
#define Vl_ie_length    		((struct vl_ie FAR *)p_ie) -> length
#define VL_IE_HEADER_LGTH 		sizeof(struct vl_ie)	/* ie header length */

				/* IE error constant */

#define IE_ERR_SIZE				'S'

/*-------------------------------------------------------------------------*/

				/* NS : Macro for indirection tables */

#define	Ns_prim						p_tab_ns_prim
#define	Ti_ref						p_tab_ti_ref
#define	Ti_ns_prim					p_tab_ti_ns_prim
#define	Ti_call						p_tab_ti_call
#define	Ti_dlci						p_tab_ti_dlci
#define	Ti_dl_ref					p_tab_ti_dl_ref
#define	Ti_int						p_tab_ti_int
#define	Tab_timer_idx				p_tab_timer_idx
#define	Table_error					p_tab_error
#define	Tab_ssdu					p_tab_ssdu
#define	Tab_spdu					p_tab_spdu
#define	X_tab_spdu					p_x_tab_spdu
#define	X_tab_ssdu					p_x_tab_ssdu
#define	X_tab_ie					p_x_tab_ie
#define	Tab_spdu_param				p_tab_spdu_param
#define	Tab_net_proc_param			p_tab_net_proc_param
#define	Tab_tabl					p_tab_tabl
#define	Tab_tabx					p_tab_tabx
#define	Tab_ie						p_tab_ie

/*-------------------------------------------------------------------------*/

	/* TABLES ID FOR THE LISTS OF NETWORK SPECIFIC PARAMETERS AND FUNCTIONS */

					/* Constants */

#define	NO_OPERATOR_DEFINED				255
#define	MX_NETWORK_NB					(NETWORK_NB + 1)

/*------------------------------------------------------------------------*/

		/*
		 * ONE_NETWORK :
		 *	- When set to ON, means that this version is equivalant to a
		 *		single network version. For every Nai the NETWORK OPERATOR
		 *		must be the same. It can be one of those for which the flag
		 *		has been set to ON in NS_PAR.H file.
		 *	- When set to OFF, means that, for any Nai,	you can select
		 *		at config time one of the NETWORK OPERATORS for which
		 *		the flag has been set to ON in NS_PAR.H file.
		 *
		 */

#if NETWORK_NB == 1
#	define	ONE_NETWORK					ON
#else
#	define	ONE_NETWORK					OFF
#endif

/*------------------------------------------------------------------------*/
					/* Access */

#define	Get_idx(xx)						xx

					/* Parameters ID */

#define	P_MX_DL_RETRY					0
#define	P_MX_ADDITIONAL_OCTET			1
#define	P_MX_SIZE_SSDU					2
#define	P_MX_SIZE_SPDU					3
#define	P_TIMER_IDX_T308				4
#define	P_SIZE_TAB_IE					5
#define	P_SIZE_TAB_TABL					6
#define	P_SIZE_TAB_TABX					7
#define	P_MX_CALL_TIMER					8
#define	P_MX_DLCI_TIMER					9

#define	MX_PARAM						11

#define	NS_MX_DL_RETRY					Net_param_val(Get_idx(P_MX_DL_RETRY))
#define	NS_MX_ADDITIONAL_OCTET          Net_param_val(Get_idx(P_MX_ADDITIONAL_OCTET))
#define	Size_tab_ssdu					Net_param_val(Get_idx(P_MX_SIZE_SSDU))
#define	Size_tab_spdu					Net_param_val(Get_idx(P_MX_SIZE_SPDU))
#define	T308							Net_param_val(Get_idx(P_TIMER_IDX_T308))
#define	Size_tab_ie						Net_param_val(Get_idx(P_SIZE_TAB_IE))
#define	Size_tab_tabl					Net_param_val(Get_idx(P_SIZE_TAB_TABL))
#define	Size_tab_tabx					Net_param_val(Get_idx(P_SIZE_TAB_TABX))
#define	MX_CALL_TIMER					Net_param_val(Get_idx(P_MX_CALL_TIMER))
#define	MX_DLCI_TIMER					Net_param_val(Get_idx(P_MX_DLCI_TIMER))

					/* Table ID */

#define F_NIL							0

#define	F_VOID_CSC_DL_REINIT			0
#define	F_VOID_CSC_DL_REINIT_N			1

#if SIMULATION == ON
#	define	F_VOID_NET_BUILD_PDU_NS		2
#	define	F_VOID_AUTOMATA_1			3
#	define	F_VOID_PR_SPDU_ID			4
#	define	MX_VOID_FCT_BEFORE_HOLD		5
#else
#	define	MX_VOID_FCT_BEFORE_HOLD		2
#endif

#if NS_HOLD_RETRIEVE == ON
#	define	F_VOID_CALL_STATE_CHG		MX_VOID_FCT_BEFORE_HOLD
#	define	MX_VOID_FCT_NB				(MX_VOID_FCT_BEFORE_HOLD + 1)
#else
#	define	MX_VOID_FCT_NB				MX_VOID_FCT_BEFORE_HOLD
#endif

#define	F_UCHAR_CSC						0
#define F_UCHAR_ERROR_HANDLER			1
#define	F_UCHAR_CSC_N					2
#define	MX_UCHAR_FCT_NB					3

#define	F_UCHAR_2U_IE_TYPE_EVAL			0
#define	F_UCHAR_2U_ERR_LEVEL_EVAL		1
#define	MX_UCHAR_FCT_2U					2

#define	F_UCHAR_2P_NS_EI				0

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

#	define	F_UCHAR_2P_FILTER      		1
#	define	F_UCHAR_2P_BKP_MAINT_PROC  	2

#endif /* } */

#define	MX_UCHAR_FCT_2P					3


#if SIMULATION == ON
#	define	F_UCHAR_4P_CC_LOAD_NS_TEST	0
#endif

#define	MX_UCHAR_FCT_4P					1

#define	Put_fct(a,b)					{b}

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Macro definition for the call of the network specific function */

		/*
		 * 					! WARNING !
		 *
		 * When a routine is not being used by ALL the different
		 * switch variants, we must implement the case where this routine
		 * is defined with FCT_NIL. In that case, the macro
		 * must not call FCT_NIL (may runs  into a crash for some machines),
		 * but instead, the macro must return a default value.
		 * (See Ns_ei routine)
		 */

#define Net_build_pdu_ns()			(Exec_void_fct 	(F_VOID_NET_BUILD_PDU_NS))
#define Automata_1()				(Exec_void_fct 	(F_VOID_AUTOMATA_1))
#define Pr_spdu_id()				(Exec_void_fct 	(F_VOID_PR_SPDU_ID))
#define Csc_dl_reinit()				(Exec_void_fct 	(F_VOID_CSC_DL_REINIT))
#define Csc_dl_reinit_n()			(Exec_void_fct 	(F_VOID_CSC_DL_REINIT_N))

#if NS_HOLD_RETRIEVE == ON
#	define Ns_call_state_change()	if (Void_fct (F_VOID_CALL_STATE_CHG) != FCT_NIL) { Exec_void_fct 	(F_VOID_CALL_STATE_CHG);} 
#endif

#define	Circuit_switched_call()		(drc = (Exec_uchar_fct		(F_UCHAR_CSC)))
#define	Circuit_switched_call_n()	(drc = (Exec_uchar_fct		(F_UCHAR_CSC_N)))
#define Error_handler()				(drc = (Exec_uchar_fct		(F_UCHAR_ERROR_HANDLER)))

#define	Ie_type_eval(a,b)			(drc = (Exec_uchar_fct_2u	(F_UCHAR_2U_IE_TYPE_EVAL,a,b)))
#define	Error_level_eval(a,b)		(drc = ((Uchar_fct_2u 		(F_UCHAR_2U_ERR_LEVEL_EVAL) != FCT_NIL) ? Exec_uchar_fct_2u	(F_UCHAR_2U_ERR_LEVEL_EVAL,a,b) : NON_FATAL))

#define	Cc_load_ns_test(a,b,c,d)	(drc = (Exec_uchar_fct_4p	(F_UCHAR_4P_CC_LOAD_NS_TEST,a,b,c,d)))

#define Ns_ei(a,b)					(drc = ((Uchar_fct_2p		(F_UCHAR_2P_NS_EI)	!= FCT_NIL)	? Exec_uchar_fct_2p	(F_UCHAR_2P_NS_EI,a,b)	: 0))
#define Ns_filter(a,b)				(drc = ((Uchar_fct_2p		(F_UCHAR_2P_FILTER)	!= FCT_NIL)	? Exec_uchar_fct_2p	(F_UCHAR_2P_FILTER,a,b)	: CONTINUE))
#define Ns_bkp_proc(a,b)			(drc = ((Uchar_fct_2p		(F_UCHAR_2P_BKP_MAINT_PROC)!= FCT_NIL)? Exec_uchar_fct_2p	(F_UCHAR_2P_BKP_MAINT_PROC,a,b): OK))

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

			/*	 NS : Macro for network specific functions */

struct void_fct_table {
	void	(*fct)	(Void_parm);
};

#define Void_fct(fct_key)					p_void_fct_table[fct_key].fct
#define Exec_void_fct(fct_key)				p_void_fct_table[fct_key].fct()
#define Idx_void(fct_key)					p_void_fct_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct uchar_fct_table {
	uchar	(*fct)	(Void_parm);
};


#define Uchar_fct(fct_key)					p_uchar_fct_table[fct_key].fct
#define Exec_uchar_fct(fct_key)				p_uchar_fct_table[fct_key].fct()
#define Idx_uchar(fct_key)					p_uchar_fct_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct uchar_fct_2p_table {

#	if NEW_FCT_STYLE == ON
		uchar	(*fct)	(code_t p1, ces_t p2);
#	else
		uchar	(*fct)	();
#	endif

};

#define Uchar_fct_2p(fct_key)				p_uchar_fct_2p_table[fct_key].fct
#define Exec_uchar_fct_2p(fct_key,p1,p2)	p_uchar_fct_2p_table[fct_key].fct(p1,p2)
#define Idx_uchar_2p(fct_key)				p_uchar_fct_2p_table[fct_key].idx

struct uchar_fct_2u_table {

#	if NEW_FCT_STYLE == ON
		uchar	(*fct)	(uchar p1, uchar p2);
#	else
		uchar	(*fct)	();
#	endif

};

#define Uchar_fct_2u(fct_key)				p_uchar_fct_2u_table[fct_key].fct
#define Exec_uchar_fct_2u(fct_key,p1,p2)	p_uchar_fct_2u_table[fct_key].fct(p1,p2)
#define Idx_uchar_2u(fct_key)				p_uchar_fct_2u_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct uchar_fct_4p_table {

#	if NEW_FCT_STYLE == ON
		uchar	(*fct)	(code_t p1, nai_t p2, sapi_t p3, conn_id_t p4);
#	else
		uchar	(*fct)	();
#	endif

};

#define Uchar_fct_4p(fct_key)				p_uchar_fct_4p_table[fct_key].fct
#define Exec_uchar_fct_4p(fct_key,a,b,c,d)	p_uchar_fct_4p_table[fct_key].fct(a,b,c,d)
#define Idx_uchar_4p(fct_key)				p_uchar_fct_4p_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#define	Net_param_val(xx)				(p_net_param[xx])

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/


struct param_fct_table {
	uchar FAR		*param;				/* array of specific parameters */
	uchar FAR		*v_f_tab;			/* void function without parameter */
	uchar FAR		*u_f_tab;			/* uchar function without parameter */
	uchar FAR		*u_f_2u_tab;		/* uchar function whth 2 uchar parameters */
	uchar FAR		*u_f_2p_tab;		/* uchar function whth 2 parameters */
	uchar FAR		*u_f_4p_tab;		/* uchar function whth 4 parameters */
};

#define	Spf_param(net_id)				t_ns_net_spf_param_fct[net_id].param
#define	Spf_void_fct(net_id)			t_ns_net_spf_param_fct[net_id].v_f_tab
#define	Spf_uchar_fct(net_id)			t_ns_net_spf_param_fct[net_id].u_f_tab
#define	Spf_uchar_fct_2u(net_id)		t_ns_net_spf_param_fct[net_id].u_f_2u_tab
#define	Spf_uchar_fct_2p(net_id)		t_ns_net_spf_param_fct[net_id].u_f_2p_tab
#define	Spf_uchar_fct_4p(net_id)		t_ns_net_spf_param_fct[net_id].u_f_4p_tab

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Table describing the compiled networks */

struct ns_net_presence {

#	if SIMULATION == ON
		uchar	operator_idx;
		char	p_text[4];
#	endif

	uchar		presence;

};

#define	Net_table_presence(op)			T_NS_NET_PRESENCE[op].presence

#if SIMULATION == ON
#	define	Net_table_p_text(op)		T_NS_NET_PRESENCE[op].p_text
#endif

#if SIMULATION == ON
#	define Put_ns_net_presence(op_idx, net, p_text)	{op_idx, p_text, net}
#else
#	define Put_ns_net_presence(op_idx, net, p_text)	{net}
#endif

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Table used to know what networks have been configured */

struct ns_net_config {
	uchar	config;						/* ON/OFF */
	uchar	idx;						/* ets, vn6, ni2, ... */
	uchar	nb_time;					/* nb of time a operator was selected */
};

extern struct ns_net_config t_ns_net_config[];

#define	Net_table_config(op)			t_ns_net_config[op].config
#define	Net_table_idx(op)				t_ns_net_config[op].idx
#define	Net_table_nb_time(op)			t_ns_net_config[op].nb_time

/*-------------------------------------------------------------------------*/

						/* NS : EXTERNAL DECLARATIONS */

					/* Constants and data configuration */

	extern struct accss_nsna_ces 	FAR 	*p_nsna_ces_tab;		/* NS na access table */

#if OPTIMIZATION == SPEED
	extern struct nsna 				FAR 	* FAR *p_nsna_tab;		/* NS na access table */
	extern struct node 				FAR 	*p_ns_tree;				/* tree start address */
#else
	extern struct node 				FAR 	*p_ns_tree;				/* tree start address */
#endif

/*-------------------------------------------------------------------------*/

			/* Multi networking extern management */

extern CONST struct ns_timer			*p_tab_ti_call;
extern CONST struct ns_timer			*p_tab_ti_dlci;
extern CONST uchar FAR					*p_tab_timer_idx;
extern CONST struct ns_timer			*p_tab_ti_int;
extern CONST uchar FAR	 				*p_tab_error;

extern CONST_ARRAY struct ns_timer		*tab_ti_call	[MX_NETWORK_NB];
extern CONST_ARRAY struct ns_timer		*tab_ti_dlci	[MX_NETWORK_NB];
extern CONST_ARRAY uchar FAR			*tab_timer_idx	[MX_NETWORK_NB];
extern CONST_ARRAY struct ns_timer		*tab_ti_int		[MX_NETWORK_NB];
extern CONST_ARRAY uchar FAR			*tab_error		[MX_NETWORK_NB];

extern CONST	 	struct ie			*p_tab_ie;
extern CONST	 	struct tabl			*p_tab_tabl;
extern CONST	 	struct tabx			*p_tab_tabx;

extern CONST_ARRAY struct ie			*tab_ie			[MX_NETWORK_NB];
extern CONST_ARRAY struct tabl			*tab_tabl		[MX_NETWORK_NB];
extern CONST_ARRAY struct tabx			*tab_tabx		[MX_NETWORK_NB];

extern CONST	struct spdu				*p_tab_spdu;
extern CONST_ARRAY struct spdu			*tab_spdu		[MX_NETWORK_NB];

extern CONST		struct ssdu			*p_tab_ssdu;
extern CONST_ARRAY struct ssdu			*tab_ssdu		[MX_NETWORK_NB];

#if OPTIMIZATION == SPEED
	extern uchar			FAR 		*p_x_tab_spdu;
	extern uchar			FAR 		*p_x_tab_ssdu;
	extern struct	hcod				*p_x_tab_ie;

	extern uchar						x_tab_spdu	[MX_NETWORK_NB][SIZE_X_SPDU];
	extern uchar						x_tab_ssdu	[MX_NETWORK_NB][SIZE_X_SSDU];
	extern struct	hcod				x_tab_ie	[MX_NETWORK_NB][SIZE_X_IE_MAIN + SIZE_X_IE_OVERFLOW];
#endif

extern struct spdu_param       	FAR 	*p_tab_spdu_param;
extern struct net_proc_param   	FAR 	*p_tab_net_proc_param;

extern struct spdu_param   	    FAR 	*tab_spdu_param		[MX_NETWORK_NB];
extern struct net_proc_param 	FAR 	*tab_net_proc_param	[MX_NETWORK_NB];

extern struct void_fct_table			*p_void_fct_table;		/* pointer on void functions without parameters */
extern struct uchar_fct_table			*p_uchar_fct_table;		/* pointer on uchar functions without parameters */
extern struct uchar_fct_2u_table		*p_uchar_fct_2u_table;	/* pointer on uchar functions with 2 uchar parameters */
extern struct uchar_fct_2p_table		*p_uchar_fct_2p_table;	/* pointer on uchar functions with 2 parameters */
extern struct uchar_fct_4p_table		*p_uchar_fct_4p_table;	/* pointer on uchar functions with 4 parameters */
extern uchar FAR						*p_net_param;           /* pointer on array of specific parameters */
extern struct ctx_backup		FAR		*p_ctx_backup;          /* backup context in case of congestion */

#if NS_IE_TSP_IN == ON

	extern struct buffer 		FAR 	*p_buffer_q931;			/* buffer where is stored q931 trace */

#endif

/*-------------------------------------------------------------------------*/

					/* Pointers to current objects */

extern struct nsna 				FAR 	*p_nsna;		/* network access context */
extern struct nsdl				FAR		*p_nsdl;		/* data link context */
extern struct call 				FAR 	*p_call;		/* call context */



extern struct param_fct_table			t_ns_net_spf_param_fct[];	/* table which contains for each network, the network specific parameters and function addresses */

					/* Variables */

extern uchar 							spdu_id;				/* current SPDU message ID */
extern uchar							ssdu_id;				/* current SSDU ID */
extern uchar							ie_codeset;				/* current IE codeset */
extern uchar							ie_id;					/* current IE ID */
extern uchar							direction;				/* direction of the message */
extern uchar							ie_if_flag;				/* booleen flag between C and metalanguage */
extern uchar 							nb_error;				/* number of error */
extern uchar							ns_ie_tsp_checking;		/* check transparent IE */

extern uchar				   			swd;					/* index for SWD_TVKT	operator */
extern uchar				   			bv1;					/* index for BG_V1		operator */
extern uchar				   			au1;                    /* index for AUSTEL_1	operator */
extern uchar				   			tr6;                    /* index for DT_1TR6	operator */
extern uchar				   			vn2;                    /* index for FT_VN2		operator */
extern uchar				   			vn3;                    /* index for FT_VN3		operator */
extern uchar				   			vn6;                    /* index for FT_VN6		operator */
extern uchar				   			ets;                    /* index for ETSI		operator */
extern uchar				   			at4;                    /* index for ATT_4E4	operator */
extern uchar				   			at5;                    /* index for ATT_5E5	operator */
extern uchar				   			at9;                    /* index for ATT_5E9	operator */
extern uchar				   			bip;                    /* index for BELLCORE	operator */
extern uchar				   			bt2;                    /* index for BT_ISDN2	operator */
extern uchar				   			dms;                    /* index for NT_DMS100	operator */
extern uchar				   			kdd;                    /* index for KDD 		operator */
extern uchar				   			ni1;                    /* index for N_ISDN1	operator */
extern uchar				   			ni2;                    /* index for N_ISDN2	operator */
extern uchar				   			ntt;                    /* index for NTT		operator */
extern uchar							qsi;					/* index for ECMA_QSIG	operator */
extern uchar							hkt;					/* index for HK_TEL		operator */
extern uchar				   			a17;                    /* index for CTU_CDS			 */
extern uchar				   			a11;                    /* index for CTU_BS				 */
extern uchar				   			e10;                    /* index for ATT_5E10			 */

extern struct ns_net_presence	CONST	T_NS_NET_PRESENCE[];

					/* Pointers on the SPDU data */

extern uchar	FAR						*p_spdu;				/* pointer on the SPDU data (inside) */
extern uchar	FAR						*p_spdu_end;			/* pointer on the end of the spdu data (outside) */

					/* Pointers on the SSDU data */

extern uchar	FAR						*p_ssdu;					/* pointer on the SSDU data */
extern uchar	FAR						*p_ssdu_val;				/* pointer on the current value of the SSDU */
extern uchar	FAR						*p_ssdu_end;				/* pointer on the end of the ssdu data (outside) */

					/* Pointers to ie locations */

extern uchar 	FAR						*p_ie;					/* current location */
extern uchar 	FAR						*p_ie_end;				/* end of the curent ie */

extern ent_id_t							i_entity_origination;	/* origination entity load in ns_rcv function */

extern uchar							protocol_discr;			/* protocol_discriminator */
extern call_ref_t						i_call_ref;				/* call reference internal value */
extern uchar							i_call_ref_lgth;		/* call reference length */

extern call_ref_t						i_call_ref_sav;			/* saved call reference */
extern uchar							i_call_ref_lgth_sav;	/* saved call reference length */

extern uchar							i_ie_x;					/* internal data structure current index */

					/* Internal buffer used to store indirect data */

extern 	uchar 							ind_buffer[];			/* buffer used to store array in pool */
extern 	uchar 							*p_ind_buffer;			/* current pointer to the ind_buffer */

extern	struct ctx_backup  				ctx_backup;				/* backup context in case of congestion */

extern	struct ns_status_var			ns_status_var;			/* variables used to send a STATUS message */

/*-------------------------------------------------------------------------*/

						/* MNS and NS : FUNCTION DECLARATIONS */

#if NEW_FCT_STYLE == ON

		/* NS entity services */

	uchar 			ns_config				(struct ns_config FAR *p_ns_config);
	void			ns_audit_in				(void);
	void			ns_process				(void);

		/* NS receive event message */

	uchar 			ns_rcv					(void);
	uchar 			ns_reassembly_process 	(code_t event_id);
	void 			ns_reassembly_discard 	(void);
	uchar			ns_establish_dl			(void);

		/* Circuit switched call */

	void			csc_clear_all_call		(void);
	void			csc_dl_reset			(void);
	void			csc_dl_failure			(void);
	void			ns_process_queue 		(void);

#	if EQUIPMENT == NT2

			/* Circuit switched call */

		void		csc_clear_all_call_n    (void);
		void		csc_dl_reset_n          (void);
		void		csc_dl_reinit_n         (void);
		void		csc_dl_failure_n        (void);

#	endif

	void			ns_action_to_dl			(uchar stop_ti, uchar start_ti, uchar event, uchar new_state);
	void			ns_action_to_cc			(uchar stop_ti, uchar start_ti, uchar event, uchar new_state);

	void			go_to_state_19			(uchar start_ti);

		/* Internal IE content list management */

	void			reset_ie_i				(void);
	uchar			set_ie_i 				(uchar codeset_p, uchar id_ie_p);
	uchar			nb_ie_i  				(uchar codeset_p, uchar id_ie_p);
	uchar 			is_ie_i  				(uchar codeset_p, uchar id_ie_p);
	uchar			discard_ie_i			(register uchar codeset, register uchar ie_id);
	void			save_ie_i 				(void);
	void			roll_back_ie_i 			(void);
	void			set_i_cause				(uchar cause_class, uchar value, char FAR * p_diagnostic);
	void			set_i_state				(uchar state);


		/* Send from NS or MNS */

	uchar			ns_snd_cc_q931_ie		(void);
	void 			ns_snd_dl       		(uchar dl_code, uchar ces);
	void 			ns_snd_cc	        	(uchar ns_code);
	void 			ns_snd_mns	        	(uchar mns_code);
	void 			ns_err_cc           	(uchar err_code, uchar p);
	void 			ns_snd_da           	(uchar da_spdu_id, uchar flag, uchar protocol);
	void 			send_state          	(uchar cause_class, uchar val, uchar diagnostic);
	void 			send_release			(uchar rel, uchar cause_class, uchar val, uchar diagnostic);
	void			send_err_to_user		(uchar err_code, uchar diagnostic_1, uchar diagnostic_2, ent_id_t user_entity);
	void			ns_retransmit			(code_t code, ent_id_t to);
	uchar 			ns_segmenter_process 	(uchar	FAR *p_in, ushort data_size);
	void 			ns_send_mns_event 		(uchar event_type, uchar event_code);
	void 			ns_send_mns_status		(void);

#	if NS_RESTART_PROCEDURE == ON
		void		ns_send_mns_restart		(uchar report_type, uchar cause_class, uchar chan_nb, uchar error_type);
#	endif

#	if NS_HOLD_RETRIEVE == ON
		void		ns_snd_hold_ret_abort_user	(uchar cause);
#	endif

		/* Call resource allocation */

	call_ref_t		allocate_call_ref		(void);
	void			remove_call_ref			(void);
	uchar 			allocate_call			(uchar way, conn_id_t conn_id);
	void 			free_call				(void);
	void			call_clear				(void);
	void			ns_stop_all_timers		(void);
	void			ns_stop_all_dlci_timers	(void);
	uchar			call_init				(call_ref_t call_ref, uchar call_way);

		/* Queue management */

	void			ns_in_queue_cc     		(void);
	uchar			ns_out_queue_cc    		(void);
	void			ns_discard_queue_cc		(void);
	void			ns_remove_queue_cc		(conn_id_t conn_id);

	void			ns_in_queue_dl     		(void);
	uchar			ns_out_queue_dl    		(void);
	void			ns_discard_queue_dl		(void);

		/* NS timer function */

	void 			ns_start_timer 			(uchar timer_x);
	void 			ns_restart_timer 		(uchar timer_x);
	void 			ns_stop_timer 			(uchar timer_x);
	uchar 			ns_init_timer  			(void);
	void 			ns_release_call_timers	(void);
	void 			ns_release_dlci_timers	(void);
	void			ns_dl_timer_activity	(void);
	void			ns_dl_timer_expiry		(void);

		/* Unexpected event */

	void 			ns_unexpected_ev		(void);

		/* NS object acccess functions */

	uchar 			ns_access_na       		(nai_t nai);
	uchar			ns_access_dl_na			(nai_t dl_nai, ces_t ces);
	uchar			ns_access_dl_next_na	(nai_t dl_nai, ces_t ces);
	void 			ns_access_first_na 		(void);
	void 			ns_access_next_na 		(void);
	uchar			ns_access_dl_ces		(ces_t ces);
	uchar 			ns_access_conn_id  		(uchar type, conn_id_t conn_id);
	uchar 			ns_access_call_ref 		(call_ref_t call_ref);
	uchar			ns_access_call_ctx		(uchar call_ctx_id);
	void			ns_access_next_dl		(void);
	void			ns_access_first_call	(void);
	void			ns_access_next_call 	(void);
	void			ns_access_prior_call	(void);

	uchar			ns_build_object			(struct ns_config FAR *p_ns_config);

		/* NS table access functions */

	uchar			ns_access_tab_spdu		(uchar search_key);

#	if OPTIMIZATION != SPEED
		uchar		ns_access_tab_ssdu		(uchar search_key);
#	else
		uchar		call_ref_insert			(call_ref_t call_ref,struct call FAR *p_call);
		uchar		call_ref_remove			(void);
#	endif

	uchar			ns_access_tab_ie		(short search_key);
	uchar			ns_check_network		(uchar na_op, uchar ns_op, ushort na_country, ushort ns_country);
	void			ns_build_check_tab		(void);

		/* Error handler */

	uchar 			error_set     			(uchar code_error, uchar diagnostic_1, uchar diagnostic_2);
	void			ns_sort_error_stack		(void);

		/* SPDU processing */

	uchar 			s_spdu       			(uchar spdu_id, ushort FAR *p_size);
	uchar 			r_spdu       			(void);
	uchar			exec_spdu_ie 			(uchar codeset, uchar ie_id,uchar nb_ie);
	void			spdu_call_ref_load 		(uchar lgth);
	uchar			i_call_ref_load			(uchar lgth);

		/* SSDU processing */

	uchar 			s_ssdu					(uchar ssdu_id, ushort FAR *p_size);
	uchar 			r_ssdu					(void);

	void 			ie_implicit_val			(uchar codeset, uchar ie_id, uchar repetition);
	void			ie_implicit_val_x		(uchar codeset, uchar ie_id, uchar repetition);

		/* General functions */

	uchar			disc_cause_error		(void);
	void			ns_save_call_cause		(void);
	uchar 			find_tabl				(uchar field, uchar tabl_id);
	uchar 			find_tabx				(uchar field, uchar tabl_id, uchar x_val);

#	if EQUIPMENT == NT2
		void		reset_multipoint_context(void);
		void		release_alerting		(uchar ie_flag);
		uchar		test_alerting			(void);
		void		save_ie_cause			(void);
		void		load_ie_cause			(void);
		void		save_ie_uui				(void);
		void 		load_ie_uui				(void);
		void		save_ie_spf_fac			(void);
		void		load_ie_spf_fac			(void);
		void		start_int_timer			(uchar timer_id, uchar sn);
		void		stop_int_timer			(void);
#	endif

	void    		pr_ns_object    		(void);
	void 			pr_ns_state 			(void);
	void  			pr_error_code		 	(void);

	uchar 			ns_build_net_table		(uchar net);
	uchar 			ns_build_p_table		(void);
	void 			ns_build_simul_table	(uchar network);
	void 			ns_build_error_table	(void);
	void 			ns_build_param_table	(void);
	void			ns_build_ie_table_1		(void);
	void			ns_build_ie_table_2		(void);
	void			ns_build_ie_table_4		(void);
	void			ns_build_ie_table_5		(void);
	void			ns_build_ie_table_6		(void);
	void 			ns_build_ssdu_table_1	(void);
	void 			ns_build_ssdu_table_2	(void);
	void 			ns_build_spdu_table		(void);
	void 			ns_build_par_table		(void);

#	if NS_SIM_BUILDER == ON
		uchar		mg_call_ref				(void);
		void		mg_call_origination		(void);
		void		mg_spdu_id				(void);
		void		mg_ns_hexa				(void);
		void		pr_dl_to_n_code			(void);
#	endif


		/* Miscellaneous */

	uchar 			ns_get_net_idx			(uchar op);
	uchar           ns_dec_net_idx         	(uchar net_idx);
	uchar			ns_get_network			(uchar op, ushort country);
	void			ns_reset_op_idx			(void);
	void			ns_save_context 		(uchar event, ent_id_t entity, uchar action);
	uchar			ns_free_dl_ctx			(void);

#	if NS_MAINTENANCE_CAPABILITY == ON
		uchar 		ns_get_nfas_nai 		(uchar FAR *nai);
		uchar 		nfas_insert 			(call_ref_t call_ref, nai_t cc_nai_insert);
		uchar 		nfas_remove 			(void);
		uchar 		ns_access_nfas 			(call_ref_t call_ref);
		void 		csc_dl_failure_nfas 	(void);
		void 		ns_nfas_stop_309 		(void);
		void		ns_get_ctx_d_chan_bearer(nai_t nai);
		uchar 		ns_nfas_config 			(struct ns_config FAR *p_ns_config);
		uchar 		ns_nfas_send_dl_est 	(struct ns_config FAR *p_ns_config);
		void 		ns_send_mns_service 	(uchar error, nai_t nai, uchar chan_id);
		void		ns_update_nfas 			(nai_t nai);
		uchar 		ns_get_nfas_group 		(uchar FAR *nfas_group_id);
		void		ns_update_bkp_dl_ctx 	(void);
#	endif

		/* load of variable addresses inside constants (arrays, meta-programs) (used for PIC) */

#	if OM_CODE_TYPE == OM_PIC
		void		pic_init_ns_t_operator_var		(void);
		void		pic_init_ns_net_ie				(void);
		void		pic_init_ns_net_spdu			(void);
		void		pic_init_ns_net_ssdu			(void);
		void		pic_init_ns_net_meta_ie			(void);
		void		pic_init_ns_net_meta_ssdu		(void);
#	endif

#endif

	/* Function declarations */

#if NEW_FCT_STYLE == OFF

		/* NS entity services */

	uchar 			ns_config 				();
	void			ns_audit_in				();
	void			ns_process				();
	void			ns_process_queue 		();

		/* NS receive event message */

	uchar			ns_rcv 					();
	uchar 			ns_reassembly_process 	();
	void 			ns_reassembly_discard 	();
	uchar			ns_establish_dl			();

		/* Circuit switched call */

	void			csc_clear_all_call    	();
	void			csc_dl_reset          	();
	void			csc_dl_failure        	();

#	if EQUIPMENT == NT2

			/* Circuit switched call */

		void		csc_clear_all_call_n    ();
		void		csc_dl_reset_n          ();
		void		csc_dl_reinit_n         ();
		void		csc_dl_failure_n        ();

#	endif

	void			ns_action_to_dl			();
	void			ns_action_to_cc			();

	void			go_to_state_19			();

		/* Internal IE content list management */

	void			reset_ie_i				();
	uchar			set_ie_i				();
	uchar 			is_ie_i					();
	uchar			nb_ie_i					();
	uchar 			discard_ie_i			();
	void			save_ie_i				();
	void			roll_back_ie_i			();
	void			set_i_cause				();
	void			set_i_state				();

		/* Send from NS  or MNS */

	uchar			ns_snd_cc_q931_ie		();
	void 			ns_snd_dl				();
	void 			ns_snd_cc				();
	void 			ns_snd_mns				();
	void 			ns_err_cc				();
	void 			ns_snd_da				();
	void 			send_state				();
	void 			send_release			();
	void			send_err_to_user		();
	void			ns_retransmit			();
	uchar 			ns_segmenter_process 	();
	void 			ns_send_mns_event 		();
	void 			ns_send_mns_status		();

#	if NS_RESTART_PROCEDURE == ON
		void		ns_send_mns_restart		();
#	endif

#	if NS_HOLD_RETRIEVE == ON
		void		ns_snd_hold_ret_abort_user	();
#	endif

		/* Call resource allocation */

	call_ref_t		allocate_call_ref		();
	uchar 			allocate_call			();
	void			remove_call_ref     	();
	void 			free_call				();
	void			call_clear				();
	void			ns_stop_all_timers		();
	void			ns_stop_all_dlci_timers	();
	uchar			call_init				();

		/* Queue management */

	void			ns_in_queue_cc			();
	uchar			ns_out_queue_cc			();
	void			ns_discard_queue_cc		();
	void			ns_remove_queue_cc		();

	void			ns_in_queue_dl			();
	uchar			ns_out_queue_dl			();
	void			ns_discard_queue_dl		();

		/* NS timer function */

	void 			ns_start_timer 			();
	void 			ns_restart_timer 		();
	void 			ns_stop_timer 			();
	uchar 			ns_init_timer			();
	void 			ns_release_call_timers	();
	void 			ns_release_dlci_timers	();
	void			ns_dl_timer_activity	();
	void			ns_dl_timer_expiry		();

		/* Unexpected event */

	void 			ns_unexpected_ev		();

		/* NS object acccess function */

	uchar 			ns_access_na			();
	uchar			ns_access_dl_na			();
	uchar			ns_access_dl_next_na	();
	void 			ns_access_first_na 		();
	void 			ns_access_next_na 		();
	uchar			ns_access_dl_ces		();
	uchar 			ns_access_conn_id		();
	uchar 			ns_access_call_ref		();
	uchar			ns_access_call_ctx		();
	void			ns_access_next_dl		();
	void			ns_access_first_call	();
	void			ns_access_next_call 	();
	void			ns_access_prior_call	();
	uchar			ns_build_object			();

		/* NS table access functions */

	uchar			ns_access_tab_spdu		();

#	if OPTIMIZATION != SPEED
		uchar		ns_access_tab_ssdu		();
#	else
		uchar		call_ref_insert			();
		uchar		call_ref_remove			();
#	endif

	uchar			ns_access_tab_ie		();
	uchar			ns_check_network		();
	void			ns_build_check_tab		();

		/* Error handler */

	uchar 			error_set				();
	void			ns_sort_error_stack		();

		/* SPDU processing */

	uchar 			s_spdu					();
	uchar 			r_spdu					();
	uchar			exec_spdu_ie			();
	void			spdu_call_ref_load		();
	uchar			i_call_ref_load			();

		/* SSDU processing */

	uchar 			s_ssdu					();
	uchar 			r_ssdu					();

	void 			ie_implicit_val			();
	void			ie_implicit_val_x		();

		/* General functions */

	uchar			disc_cause_error		();
	void			ns_save_call_cause		();
	uchar 			find_tabl				();
	uchar 			find_tabx				();

#	if EQUIPMENT == NT2
		void		reset_multipoint_context();
		void		release_alerting		();
		uchar		test_alerting			();
		void		save_ie_cause			();
		void		load_ie_cause			();
		void		save_ie_uui				();
		void 		load_ie_uui				();
		void		save_ie_spf_fac			();
		void		load_ie_spf_fac			();
		void		start_int_timer			();
		void		stop_int_timer			();
#	endif

	void    		pr_ns_object    		();
	void 			pr_ns_state 			();
	void  			pr_error_code 			();

	uchar 			ns_build_net_table		();
	uchar 			ns_build_p_table		();
	void 			ns_build_simul_table	();
	void 			ns_build_error_table	();
	void 			ns_build_param_table	();
	void			ns_build_ie_table_1		();
	void			ns_build_ie_table_2		();
	void			ns_build_ie_table_4		();
	void			ns_build_ie_table_5		();
	void			ns_build_ie_table_6		();
	void 			ns_build_ssdu_table_1	();
	void 			ns_build_ssdu_table_2	();
	void 			ns_build_spdu_table		();
	void 			ns_build_par_table		();

#	if NS_SIM_BUILDER == ON
		uchar		mg_call_ref				();
		void		mg_call_origination		();
		void		mg_spdu_id				();
		void		mg_ns_hexa				();
		void		pr_dl_to_n_code			();
#	endif

		/* Miscellaneous */

	uchar 			ns_get_net_idx			();
	uchar           ns_dec_net_idx         	();
	uchar			ns_get_network			();
	void			ns_reset_op_idx			();
	void			ns_save_context 		();
	uchar			ns_free_dl_ctx			();

#	if NS_MAINTENANCE_CAPABILITY == ON
		uchar 		ns_get_nfas_nai 		();
		uchar 		nfas_insert 			();
		uchar 		nfas_remove 			();
		uchar 		ns_access_nfas 			();
		void 		csc_dl_failure_nfas	 	();
		void 		ns_nfas_stop_309 		();
		void		ns_get_ctx_d_chan_bearer();
		uchar 		ns_nfas_config 			();
		uchar 		ns_nfas_send_dl_est 	();
		void 		ns_send_mns_service 	();
		void		ns_update_nfas 			();
		uchar 		ns_get_nfas_group 		();
		void		ns_update_bkp_dl_ctx 	();
#	endif

		/* load of variable addresses inside constants (arrays, meta-programs) (used for PIC) */

#	if OM_CODE_TYPE == OM_PIC
		void		pic_init_ns_t_operator_var		();
		void		pic_init_ns_net_ie				();
		void		pic_init_ns_net_spdu			();
		void		pic_init_ns_net_ssdu			();
		void		pic_init_ns_net_meta_ie			();
		void		pic_init_ns_net_meta_ssdu		();
#	endif

#endif


/*=========================================================================*/

/*EOF*/

