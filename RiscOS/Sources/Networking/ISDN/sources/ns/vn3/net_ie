/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_ie.vn3
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the meta description of all the FRANCE TELECOM VN3 information
 * element and the integrity constraints associated to them.
 *
 *
 *
 *	VN3 SPECIFIC FUNCTIONS :
 *  ----------------------
 *
 * vn3_bc_spdu - implements the specific processing of a BC
 * Information Element (IE).
 *
 * vn3_cause_spdu - implements the specific processing of a cause
 * Information Element (IE).
 *
 * vn3_llc_spdu - implements the processing of the low layer
 * compatibility (LLC) IE of a received SPDU
 * message and of a 'to send' SPDU message.
 *
 * vn3_spf_fac - implements the processing of a specific facility
 * IE (received in a SPDU message or to send in a SPDU message).
 *
 * vn3_uui_spdu - implements the specific processing of a
 * user to user Information Element (IE).
 *
 * vn3_chan_id_spdu - implements the specific processing of a
 * channel Id Information Element (IE) received from the D channel.
 *
 * vn3_chan_id_to_d_spdu - implements the specific processing of a
 * channel Id Information Element (IE) to be sent to the D channel.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/
/*

Table structures :
----------------

		tabl_item   TABL_ITEM                                    uchar
		==========================                             ============
		| tabl_id | size | p_val |---------------------------->|   val    |
		--------------------------	tabl_yy 	 ============  ------------
		|         |      |       |-------------->|   val    |  |   val    |
		--------------------------               ------------  ------------
		|         |      |       |               |   val    |  |   val    |
		--------------------------               ------------  ------------
		|         |      |       |               |          |  |          |
		--------------------------
		|         |      |       |
		--------------------------
		|         |      |       |


	tabx_item	TABX_ITEM                   tabx_list                uchar
	=================================     =================        =========
	| tabl_id | size | list pointer |---->| tabl_id | size|------->| x_val |
	---------------------------------     -----------------        ---------
	|         |      |              |     |         |     |        |  val  |
	---------------------------------     -----------------        ---------
	|         |      |              |     |         |     |        |  val  |
	---------------------------------
	|         |      |              |

*/

/*-------------------------------------------------------------------------*/

	/*
		Initialization constants of ie internal structure
		used by SPDU received processing.
	*/

		/*  Bearer capability (BC) */

CONST	struct i_bc df_spdu_vn3_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* Cause (CAUSE) */

CONST	struct i_cause df_spdu_vn3_i_cause = {
	CODING_STD_CCITT,
	LOCATION_NET_NTWK_POINT,
	BYTE_VAL_NIL,
	C_C_NORMAL_EVENT,
	C_V_NORMAL_CLEARING_16,
	0,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST	struct i_chan_id df_spdu_vn3_i_chan_id = {
	INT_ID_IMPLICIT,
	INT_TYPE_BRI,
	CHAN_EXCL,
	D_CHAN,
	ANY_CHAN,
	BYTE_VAL_NIL,
	CODING_STD_CCITT,
	BYTE_VAL_NIL,
	B_CHAN,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Call identification (CALL_ID) */

CONST	struct i_call_id df_spdu_vn3_i_call_id = {
	BYTE_VAL_NIL,
	0,
	A_NIL,
};

		/* Call State (CALL_STATE) */

CONST	struct i_call_state df_spdu_vn3_i_call_state = {
	BYTE_VAL_NIL,
	STATE_NIL,
};

		/* Display (DISPLAY) */

CONST	struct i_display df_spdu_vn3_i_display = {
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Keypayd (KEYPAD) */

CONST	struct i_keypad df_spdu_vn3_i_keypad = {
	BYTE_VAL_NIL,
	A_NIL,
};

#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST	struct i_spf_fac df_spdu_vn3_i_spf_fac = {
	FAC_NETWORK_ID_LGTH,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

#endif

		/*  Called party number and subaddress (CALLED_NB CALLED_SUB_ADD) */

CONST	struct i_called_nb df_spdu_vn3_i_called_nb = {
	BLOC_SENDING,
	PLAN_PRIVATE,
	0,
	A_NIL,
};


CONST	struct i_called_sub_add df_spdu_vn3_i_called_sub_add = {
	SUB_ADD_OSI,
	BYTE_VAL_NIL,
	FORMAT_IA5,
	0,
	A_NIL,
};

		/* Restart indicator (RESTART_IND) */

CONST	struct i_restart_ind	df_spdu_vn3_i_restart_ind = {
	RI_ALL_INTERFACES,
};

		/* Low layer compatibility (LLC) */

CONST	struct i_llc df_spdu_vn3_i_llc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	OUT_BAND_NOT_POSSIBLE,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,

	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,

	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,

	LAYER_ID_2,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,

	LAYER_ID_3,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* High layer compatibility (HLC) */

CONST	struct i_hlc df_spdu_vn3_i_hlc = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	PRESENTATION_PROFIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* Calling party number (CALLING_NB) */

CONST	struct i_calling_nb df_spdu_vn3_i_calling_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL,
};

		/* calling party subaddress (CALLING_SUB_ADD) */

CONST	struct i_calling_sub_add df_spdu_vn3_i_calling_sub_add = {
	SUB_ADD_OSI,
	BYTE_VAL_NIL,
	FORMAT_IA5,
	0,
	A_NIL,
};

		/* User mode working (USER_MODE) */

CONST	struct i_user_mode df_spdu_vn3_i_user_mode = {
	CODING_STD_NATIONAL,
	NATIONAL_FUNCTIONAL_MODE,
};

		/* User to user information (UUI) */

CONST	struct i_uui df_spdu_vn3_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL,
};

		/* Progress indicator (PROGRESS_IND) */

CONST	struct i_progress_ind df_spdu_vn3_i_progress_ind = {
	CODING_STD_CCITT,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* User to user facility (USER_FAC) */

CONST	struct i_user_fac df_spdu_vn3_i_user_fac = {
	PROTOCOL_DISCR_MESSAGING,
	0,
	A_NIL,
};

		/* Congestion level (CONGEST_LEVEL) */

CONST   struct  i_congest_level	 df_spdu_vn3_i_congest_level = {
	RECEIVER_READY
};

		/* Date/time (DATE_TIME) */

CONST   struct  i_date_time	 df_spdu_vn3_i_date_time = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

CONST 	struct i_facility	df_spdu_vn3_i_facility = {
	BYTE_VAL_NIL,
};

		/* Notification indicator (NOTIF_IND) */

CONST   struct  i_notif_ind	 df_spdu_vn3_i_notif_ind = {
	USER_SUSPENDED,
	0,
	P_NIL

};
		/*  Signal (SIGNAL) */

CONST   struct  i_signal	df_spdu_vn3_i_signal = {
	DIAL_ON
};

		/* Redirecting number (REDIR_NB) */

CONST   struct  i_redir_nb  df_spdu_vn3_i_redir_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL,
};


/*-------------------------------------------------------------------------*/

	/*
		Initialization constants of the ie internal structure
		used by SSDU received processing.
	*/

		/*  Bearer capability (BC) */

CONST	struct i_bc df_ssdu_vn3_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_1,
	PROTOCOL_ID_1_G711_A,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* Cause (CAUSE) */

CONST	struct i_cause df_ssdu_vn3_i_cause = {
	CODING_STD_CCITT,
	LOCATION_USER,
	BYTE_VAL_NIL,
	C_C_NORMAL_EVENT,
	C_V_NORMAL_CLEARING_16,
	0,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST	struct i_chan_id df_ssdu_vn3_i_chan_id = {
	INT_ID_IMPLICIT,
	INT_TYPE_BRI,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	ANY_CHAN,
	BYTE_VAL_NIL,
	CODING_STD_CCITT,
	BYTE_VAL_NIL,
	B_CHAN,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Call identification (CALL_ID) */

CONST	struct i_call_id df_ssdu_vn3_i_call_id = {
	BYTE_VAL_NIL,
	0,
	A_NIL,
};

		/* Call State (CALL_STATE) */

CONST	struct i_call_state df_ssdu_vn3_i_call_state = {
	BYTE_VAL_NIL,
	STATE_NIL,
};

		/* Display (DISPLAY) */

CONST	struct i_display df_ssdu_vn3_i_display = {
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Keypayd (KEYPAD) */

CONST	struct i_keypad df_ssdu_vn3_i_keypad = {
	BYTE_VAL_NIL,
	A_NIL,
};

#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST	struct i_spf_fac df_ssdu_vn3_i_spf_fac = {
	FAC_NETWORK_ID_LGTH,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

#endif

		/*  Called party number and subaddress (CALLED_NB CALLED_SUB_ADD) */

CONST	struct i_called_nb df_ssdu_vn3_i_called_nb = {
	BLOC_SENDING,
	PLAN_PRIVATE,
	0,
	A_NIL,
};


CONST	struct i_called_sub_add df_ssdu_vn3_i_called_sub_add = {
	SUB_ADD_OSI,
	BYTE_VAL_NIL,
	FORMAT_IA5,
	0,
	A_NIL,
};

		/* Restart indicator (RESTART_IND) */

CONST	struct i_restart_ind	df_ssdu_vn3_i_restart_ind = {
	RI_ALL_INTERFACES,
};

		/* Low layer compatibility (LLC) */

CONST	struct i_llc df_ssdu_vn3_i_llc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	OUT_BAND_NOT_POSSIBLE,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,

	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,

	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,

	LAYER_ID_2,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,

	LAYER_ID_3,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* High layer compatibility (HLC) */

CONST	struct i_hlc df_ssdu_vn3_i_hlc = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	PRESENTATION_PROFIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* Calling party number (CALLING_NB) */

CONST	struct i_calling_nb df_ssdu_vn3_i_calling_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL,
};

		/* calling party subaddress (CALLING_SUB_ADD) */

CONST	struct i_calling_sub_add df_ssdu_vn3_i_calling_sub_add = {
	SUB_ADD_OSI,
	BYTE_VAL_NIL,
	FORMAT_IA5,
	0,
	A_NIL,
};

		/* User mode working (USER_MODE) */

CONST	struct i_user_mode df_ssdu_vn3_i_user_mode = {
	CODING_STD_NATIONAL,
	NATIONAL_FUNCTIONAL_MODE,
};

		/* User to user information (UUI) */

CONST	struct i_uui df_ssdu_vn3_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL,
};

		/* Progress indicator (PROGRESS_IND) */

CONST	struct i_progress_ind df_ssdu_vn3_i_progress_ind = {
	CODING_STD_CCITT,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/* User to user facility (USER_FAC) */

CONST	struct i_user_fac df_ssdu_vn3_i_user_fac = {
	PROTOCOL_DISCR_MESSAGING,
	0,
	A_NIL,
};

		/* Congestion level (CONGEST_LEVEL) */

CONST   struct  i_congest_level	 df_ssdu_vn3_i_congest_level = {
	RECEIVER_READY
};

		/* Date/time (DATE_TIME) */

CONST   struct  i_date_time	 df_ssdu_vn3_i_date_time = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

CONST 	struct i_facility	df_ssdu_vn3_i_facility = {
	BYTE_VAL_NIL,
};

		/* Notification indicator (NOTIF_IND) */

CONST   struct  i_notif_ind	 df_ssdu_vn3_i_notif_ind = {
	USER_SUSPENDED,
	0,
	P_NIL

};
		/*  Signal (SIGNAL) */

CONST   struct  i_signal	df_ssdu_vn3_i_signal = {
	DIAL_ON
};

		/* Redirecting number (REDIR_NB) */

CONST   struct  i_redir_nb  df_ssdu_vn3_i_redir_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL,
};


/*=========================================================================*/

				/* TABLES : list of valid values */

					/* Information transfer capability */

CONST	uchar VN3_TRF_CAP_S[] 	={
			TRF_CAP_SPEECH,
			TRF_CAP_UNRESTRICTED,
			TRF_CAP_3_1_AUDIO,
			TRF_CAP_7_AUDIO,
};

		/* Cause class */

CONST	uchar VN3_C_C_S[]={

			C_C_NORMAL_EVENT_0,
			C_C_NORMAL_EVENT,
			C_C_RESOURCE_UNAVAILABLE,
			C_C_SERVICE_NOT_AVAILABLE,
			C_C_SERVICE_NOT_IMPLEMENTED,
			C_C_INVALID_MESSAGE,
			C_C_PROTOCOL_ERROR,
			C_C_INTERWORKING,
};

		/* Preferred/exclusive */

CONST	uchar VN3_CHAN_PREF_EXCL_S[] = {
			CHAN_PREF,
			CHAN_EXCL,
};


		/* Interface type */

CONST	uchar VN3_INT_TYPE_S[] = {
			INT_TYPE_BRI,
			INT_TYPE_PRI,
};

		/* Channel number */

CONST	uchar VN3_CHAN_NUMBER_S[] = {
			1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
			17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
};

		/* Numbering type */

CONST	uchar VN3_CALLED_NB_TYPE_S[] = {
			OVERLAP_SENDING,
			BLOC_SENDING,
};

			/* Numbering plan */

CONST	uchar VN3_CALLED_NB_PLAN_S[] = {
			PLAN_UNKNOWN,
			PLAN_ISDN,
			PLAN_PRIVATE,
};

		/* Subaddress type */

CONST	uchar VN3_SUB_ADD_TYPE_S[] = {
			SUB_ADD_OSI,
			SUB_ADD_USER,
};

		/* Coding standard */

CONST	uchar VN3_CODING_STD_S[] = {
			CODING_STD_CCITT,
			CODING_STD_RESERVED,
			CODING_STD_NATIONAL,
			CODING_STD_SPF,
};

		/* Information transfer capability - 2 */

CONST	uchar VN3_TRF_CAP_2_S[] = {
			TRF_CAP_SPEECH,
			TRF_CAP_UNRESTRICTED,
			TRF_CAP_3_1_AUDIO,
			TRF_CAP_7_AUDIO,
};

		/* Information transfer mode */

CONST	uchar VN3_TRF_MODE_S[] = {
			TRF_MODE_CIRCUIT,
			TRF_MODE_PACKET,
};

		/* Information transfer rate */

CONST	uchar VN3_TRF_RATE_CIRCUIT_S[] = {
			TRF_MODE_CIRCUIT,
			TRF_RATE_64KBS,
			TRF_RATE_2x64KBS,
};

CONST	uchar VN3_TRF_RATE_PACKET_S[] = {
			TRF_MODE_PACKET,
			TRF_RATE_PACKET_MODE,
};

		/* Information  structure */

CONST	uchar VN3_STRUCTURE_S[] = {
			STRUCTURE_DEFAULT,
			STRUCTURE_8KHZ_INT,
			STRUCTURE_SDU_INT,
};

		/* Layer 1 protocol identifier */

CONST	uchar VN3_PROTOCOL_ID_1_S[] = {
			PROTOCOL_ID_1_V110,
			PROTOCOL_ID_1_G711_A,
			PROTOCOL_ID_1_G721,
			PROTOCOL_ID_1_7KHZ,
			PROTOCOL_ID_1_RA_NON_CCITT,
			PROTOCOL_ID_1_V120,
			PROTOCOL_ID_1_X31,
};

		/* Layer 2 protocol identifier */

CONST	uchar VN3_PROTOCOL_ID_2_S[] = {
			PROTOCOL_ID_2_ISO_1745,
			PROTOCOL_ID_2_Q921,
			PROTOCOL_ID_2_X25_LL,
			PROTOCOL_ID_2_X25_ML,
			PROTOCOL_ID_2_T71,
			PROTOCOL_ID_2_HDLC_ARM,
			PROTOCOL_ID_2_HDLC_NRM,
			PROTOCOL_ID_2_HDLC_ABM,
			PROTOCOL_ID_2_LAN_LLC,
			PROTOCOL_ID_2_X75_SLP,
};

		/* Layer 3 protocol identifier */

CONST	uchar VN3_PROTOCOL_ID_3_S[] = {
			PROTOCOL_ID_3_Q931,
			PROTOCOL_ID_3_X25_PL,
			PROTOCOL_ID_3_ISO_8208,
			PROTOCOL_ID_3_ISO_8348,
			PROTOCOL_ID_3_ISO_8473,
			PROTOCOL_ID_3_T70,
};

		/* In-band or out-band negotiation (V110) */

CONST	uchar VN3_NEGOTIATION_S[] =	{
			NEGOTIATION_IN_BAND,
			NEGOTIATION_NOT_IN_BAND,
};

		/* Asynchronous/synchronous */

CONST	uchar VN3_SYN_ASYN_S[] = 	{
			SYN,
			ASYN,
};

		/* User rate (V110) */

CONST	uchar VN3_USER_RATE_S[] =	{
			RA_0_6KBS,
			RA_1_2KBS,
			RA_2_4KBS,
			RA_3_6KBS,
			RA_4_8KBS,
			RA_7_2KBS,
			RA_8KBS,
			RA_9_6KBS,
			RA_14_4KBS,
			RA_16KBS,
			RA_19_2KBS,
			RA_32KBS,
			RA_48KBS,
			RA_56KBS,
			RA_0_1345KBS,
			RA_0_100KBS,
			RA_0_75_1_2KBS,
			RA_1_2_0_75KBS,
			RA_0_050KBS,
			RA_0_075KBS,
			RA_0_110KBS,
			RA_0_150KBS,
			RA_0_200KBS,
			RA_0_300KBS,
			RA_12KBS,
			RA_E_BITS,
			RA_38_4_KBS_NO_ETSI,
			RA_64KBS,
			RA_38_4KBS,
			RA_57_6KBS,
};

		/* Intermediate rate (V110) */

CONST	uchar VN3_INTER_RATE_S[] = {
			INTER_RA_UNUSED,
			INTER_RA_8KBS,
			INTER_RA_16KBS,
			INTER_RA_32KBS,
};

		/* Network independent clock (NIC) */

CONST	uchar VN3_NIC_S[] = {
			NIC_RQ_TX_DATA,
			NIC_NOT_RQ_TX_DATA,
};


		/* Flow control on Transmission (Tx) */

CONST	uchar VN3_FLOW_CONTROL_TX_S[] = {
			FLOW_NOT_RQ_TX_DATA,
			FLOW_RQ_TX_DATA,
};


		/* Flow control on Reception (Rx) */

CONST	uchar VN3_FLOW_CONTROL_RX_S[] = {
			FLOW_CAN_ACCEPT_DATA,
			FLOW_CANNOT_ACCEPT_DATA,
};

		/* Duplex/half-duplex */

CONST	uchar VN3_DUPLEX_S[] = {
			FULL_DUPLEX,
			HALF_DUPLEX,
};

		/* Modem type */

CONST	uchar VN3_MODEM_S[] = {
			FT_MODEM_RESERVED,
			FT_MODEM_V21,
			FT_MODEM_V22,
			FT_MODEM_V22_BIS,
			FT_MODEM_V23,
			FT_MODEM_V26,
			FT_MODEM_V26_BIS,
			FT_MODEM_V26_TER,
			FT_MODEM_V27,
			FT_MODEM_V27_BIS,
			FT_MODEM_V27_TER,
			FT_MODEM_V29,
			FT_MODEM_V32,
};

		/* Interpretation */

CONST	uchar VN3_INTERPRETATION_S[] = {
			INTER_NATIONAL,
			INTER_CCITT_CEPT,
};

		/* Address control type */

CONST	uchar VN3_SCREEN_IND_S[] = {
			USER_PROVIDED,
			USER_PASSED,
			USER_FAILED,
			NETWORK_PROVIDED,
};

			/* Calling number type */

CONST	uchar VN3_CALLING_NB_TYPE_S[] = {
			NB_UNKNOWN,
			NB_NATIONAL,
			NB_INTERNATIONAL,
			NB_SUBSCRIBER,
};

		/* Redirection number type (ie REDIR_NB) */

CONST	uchar VN3_REDIR_NB_TYPE_S[] = {
			NB_NATIONAL,
			NB_INTERNATIONAL,
};

		/* Calling presentation indicator (ie CALLING_NB) */

CONST	uchar VN3_CALLING_NB_PRES_S[] = {
			PRES_ALLOWED,
			PRES_RESTRICTED,
			PRES_NOT_AVAILABLE,
			PRES_RESERVED,
};
			/* REdirection nb presentation indicator (ie REDIR_NB) */

CONST	uchar VN3_REDIR_NB_PRES_S[] = {
			PRES_ALLOWED,
			PRES_RESTRICTED,
};

			/* Calling plan type */

CONST	uchar VN3_CALLING_NB_PLAN_S[] = {
			PLAN_UNKNOWN,
			PLAN_ISDN,
			PLAN_PRIVATE,
};

			/* User to user information protocol discriminator */

CONST	uchar VN3_UUI_PROTOCOL_DISCR_S[] = {
			PROTOCOL_DISCR_IA5,
			PROTOCOL_DISCR_NT2,
			PROTOCOL_DISCR_TRANSGROUP,
};

			/* User protocol discriminator */

CONST	uchar VN3_USER_PROTOCOL_DISCR_S[] = {
			PROTOCOL_DISCR_NT2,
			PROTOCOL_DISCR_MESSAGING,
			PROTOCOL_DISCR_TRANSGROUP,
};

				/* Progress description (ie PROGRESS_IND) */

CONST	uchar VN3_PROGRESS_DESCRIPTION_S[] = {
			PROGRESS_DESCR_NON_END_TO_END_ISDN,
			PROGRESS_DESCR_NON_ISDN_DEST,
			PROGRESS_DESCR_NON_ISDN_ORIG,
			PROGRESS_DESCR_CALL_RETURNED_ISDN,
			PROGRESS_DESCR_IN_BAND_NOW,
};

		/* Progress location (ie PROGRESS_IND) */

CONST	uchar VN3_PROGRESS_LOCATION_S[] = {
			PROGRESS_LOC_USER,
			PROGRESS_LOC_PR_LOCAL_USER,
			PROGRESS_LOC_PU_LOCAL_USER,
			PROGRESS_LOC_PU_REMOTE_USER,
			PROGRESS_LOC_PR_REMOTE_USER,
			PROGRESS_LOC_INTERNATIONAL,
			PROGRESS_BEYONG_IWP,
};

		/* Automata call state values */

CONST	uchar VN3_CALL_STATE_VAL_S[] = {
			STATE_NULL_0,
			STATE_CALL_INIT_1,
			STATE_OVERLAP_SENDING_2,
			STATE_OUTGOING_CALL_PROC_3,
			STATE_CALL_DELIVERED_4,
			STATE_CALL_PRESENT_6,
			STATE_CALL_RECEIVED_7,
			STATE_CONNECT_REQUEST_8,
			STATE_INCOMING_CALL_PROC_9,
			STATE_ACTIVE_10,
			STATE_DISCONNECT_REQUEST_11,
			STATE_DISCONNECT_INDICATION_12,
			STATE_SUSPEND_REQUEST_15,
			STATE_RESUME_REQUEST_17,
			STATE_RELEASE_REQUEST_19,
			STATE_REGISTRATION_REQUEST_254,

			STATE_REST_1,
			STATE_REST_2,
};

		/* Stop bit format */

CONST	uchar VN3_STOP_BIT_S[] = {
			STOP_BIT_1,
			STOP_BIT_1_5,
			STOP_BIT_2,
};

		/* Data bit format */

CONST	uchar VN3_DATA_BIT_S[] = {
			DATA_BIT_5,
			DATA_BIT_7,
			DATA_BIT_8,
};

		/* Parity format */

CONST	uchar VN3_PARITY_S[] = {
			ODD,
			EVEN,
			NO_PARITY,
			FORCED_TO_0,
			FORCED_TO_1,
};

		/* Network specific facility action */

CONST	uchar VN3_SPF_FAC_ACTION_S[] = {
			FT_SPF_FAC_RQ_ACTIVATE,
			FT_SPF_FAC_RQ_CLEAR,
			FT_SPF_FAC_RQ_ENQUIRY,
};

		/* Network specific facility code */

CONST	uchar VN3_SPF_FAC_CODE_S[] = {
			FT_SPF_FAC_CALL_FORWARDING,
			FT_SPF_FAC_CALL_DEFLECTION,
			FT_SPF_FAC_CHARGING,
			FT_SPF_FAC_CHARGING_TOTAL,
			FT_SPF_FAC_HOLD,
			FT_SPF_FAC_RETRIEVE,
			FT_SPF_FAC_ALTERNATE,
			FT_SPF_FAC_TRF,
			FT_SPF_FAC_THREE_PARTY,
			FT_SPF_FAC_IDENTIFICATION_DENIED,
			FT_SPF_FAC_MALICIOUS_CALL_ID,
};

		/* Restart indicator class */

CONST	uchar VN3_RESTART_IND_CLASS_S[] = {
			RI_INDICATED_CHANNEL,
			RI_SINGLE_INTERFACE,
			RI_ALL_INTERFACES,
};

		/* cause location */


CONST	uchar VN3_CAUSE_LOCATION_S[] = {
			LOCATION_USER,
			LOCATION_PR_NET_LOC_USER,
			LOCATION_PU_NET_LOC_USER,
			LOCATION_TRANSIT_NET,
			LOCATION_PU_NET_REMOTE_USER,
			LOCATION_PR_NET_REMOTE_USER,
			LOCATION_INTERNATIONAL_NET,
			LOCATION_NET_NTWK_POINT,
};


		/* Congestion level (ie CONGEST_LEVEL) */

CONST	uchar VN3_CONGEST_LEVEL_S[] = {
			RECEIVER_READY,
			RECEIVER_NOT_READY,
};

		/* Notification indicator description (ie NOTIF_IND) */

CONST	uchar VN3_NOTIF_IND_DESCR_S[] = {
			USER_SUSPENDED,
			USER_RESUMED,
			DELAY_AT_SETUP,
			BEARER_SERVICE_CHANGE,
			THREE_CONF_ESTABLISHED,
			THREE_CONF_END,
			CONF_NEW_MEMBER,
			CONF_ISOLATION,
			CONF_RETURN,
			CONF_MEMBER_ISOLATION,
			CONF_MEMBER_RETURN,
			CONF_MEMBER_PRIVATE_CONVERSATION,
			CONF_MEMBER_EXIT,
			CONF_SUSPENDED,
			CALL_IS_WAITING,
			ACTIVE_CALL_FORWARDING,
			ALERT_WITH_FORWARDED_CALL,
			ACTIVE_FORWARDED_CALL,
			REMOTE_HOLD,
			REMOTE_HOLD_REL,
			CALL_IS_FORWARDED,
};


		/* Out-band negotiation indicator (ie LLC) */

CONST	uchar VN3_OUT_BAND_NEG_S[] =	{
			OUT_BAND_POSSIBLE,
			OUT_BAND_NOT_POSSIBLE,
};

		/* Signal values (ie SIGNAL) */

CONST	uchar VN3_SIGNAL_VAL_S[] = {
			DIAL_ON,
			RING_BACK_ON,
			INTERCEPT_ON,
			NET_CONGEST_ON,
			BUSY_ON,
			CONFIRM_ON,
			ANSWER_ON,
			CALL_WAITING_ON,
			OFF_HOOK_WARNING_ON,
			TONES_OFF,
			PATTERN_0,
			PATTERN_1,
			PATTERN_2,
			PATTERN_3,
			PATTERN_4,
			PATTERN_5,
			PATTERN_6,
			PATTERN_7,
			ALERTING_OFF,
};

/*=========================================================================*/

	/* Tables selected according to another value (indexed tables) */


		/* Cause value  according to the class */

			/* Normal event */


CONST	uchar VN3_C_V_NORMAL_EVENT_0_S[] = {
			C_C_NORMAL_EVENT_0,
			C_V_UNASSIGNED_NUMBER_1,
			C_V_NO_ROUTE_TO_TRANSIT_NET_2,
			C_V_NO_ROUTE_TO_DEST_3,
			C_V_CHAN_UNACCEPTABLE_6,
			C_V_AWARDED_7,
};


CONST	uchar VN3_C_V_NORMAL_EVENT_S[] = {
			C_C_NORMAL_EVENT,
			C_V_NORMAL_CLEARING_16,
			C_V_USER_BUSY_17,
			C_V_NO_USER_RESPONDING_18,
			C_V_FACILITY_NOT_REGISTERED_19,
			C_V_CALL_REJECT_21,
			C_V_NUMBER_CHANGED_22,
			C_V_NUMBER_NOT_ASSIGNED_24,
			C_V_NON_SELECTED_USER_CLEARING_26,
			C_V_DEST_OUT_OF_ORDER_27,
			C_V_INVALID_NUMBER_FORMAT_28,
			C_V_FACILITY_REJECT_29,
			C_V_RESPONSE_TO_STATUS_ENQUIRY_30,
			C_V_NORMAL_UNSPECIFIED_31,
};


			/* Resource not available */

CONST	uchar VN3_C_V_RESOURCE_UNAVAILABLE_S[] ={
			C_C_RESOURCE_UNAVAILABLE,
			C_V_NO_CIRCUIT_AVAILABLE_34,
			C_V_NETWORK_OUT_OF_ORDER_38,
			C_V_NETWORK_TEMPORARY_FAILURE_41,
			C_V_NETWORK_CONGESTION_42,
			C_V_ACCESS_INFORMATION_DISCARDED_43,
			C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44,
			C_V_RESOURCE_UNAVAILABLE_UNSPECIFIED_47,
};

			/* Service not available */

CONST	uchar VN3_C_V_SERVICE_NOT_AVAILABLE_S[] = {
			C_C_SERVICE_NOT_AVAILABLE,
			C_V_QUALITY_OF_SERVICE_UNAVAILABLE_49,
			C_V_REQUESTED_FAC_NOT_SUBSCRIBED_50,
			C_V_BC_NOT_AUTHORIZED_57,
			C_V_BC_NOT_PRESENTLY_AVAILABLE_58,
			C_V_CALL_RESTRICTION_59,
			C_V_TRANSFER_REJECTED_60,
			C_V_SERVICE_NOT_SUBSCRIBED_62,
			C_V_SERVICE_NOT_AVAILABLE_63,
};

			/* Service not implemented */

CONST	uchar VN3_C_V_SERVICE_NOT_IMPLEMENTED_S[] = {
			C_C_SERVICE_NOT_IMPLEMENTED,
			C_V_BC_NOT_IMPLEMENTED_65,
			C_V_CHANNEL_TYPE_NOT_IMPLEMENTED_66,
			C_V_REQUESTED_FAC_NOT_IMPLEMENTED_69,
			C_V_ONLY_RESTRICTED_INFO_BEARER_70,
			C_V_SERVICE_NOT_IMPLEMENTED_UNSPECIFIED_79,
};

			/* Invalid message */

CONST	uchar VN3_C_V_INVALID_MESSAGE_S[] = {
			C_C_INVALID_MESSAGE,
			C_V_INVALID_CALL_REF_81,
			C_V_IDENTIFIED_CHANNEL_NOT_EXIST_82,
			C_V_SUSPENDED_CALL_BUT_CALL_ID_NOT_EXIST_83,
			C_V_CALL_ID_IN_USE_84,
			C_V_NO_CALL_SUSPENDED_85,
			C_V_CALL_HAVING_CALL_ID_CLEARED_86,
			C_V_INCOMPATIBLE_DESTINATION_88,
			C_V_INVALID_TRANSIT_NETWORK_SELECTION_91,
			C_V_INVALID_FACILITY_PARAMETER_92,
			C_V_INVALID_MESSAGE_UNSPECIFIED_95,
};

			/* Protocol error */

CONST	uchar VN3_C_V_PROTOCOL_ERROR_S[] = {
			C_C_PROTOCOL_ERROR,
			C_V_MANDATORY_IE_MISSING_96,
			C_V_MESSAGE_TYPE_NON_EXISTENT_97,
			C_V_MESSAGE_STATE_INCONSISTENCY_98,
			C_V_NON_EXISTENT_IE_99,
			C_V_INVALID_IE_CONTENT_100,

#			if EQUIPMENT == NT2
				C_V_MESSAGE_NOT_COMPATIBLE_101,
#			endif

			C_V_RECOVERY_ON_TIMER_EXPIRY_102,
			C_V_INCORRECT_MANDATORY_IE_LGTH_103,
			C_V_PROTOCOL_ERROR_UNSPECIFIED_111,
};

			/* Interworking */

CONST	uchar VN3_C_V_INTERWORKING_S[] = {
			C_C_INTERWORKING,
			C_V_BC_OUT_OF_ORDER_113,
			C_V_END_TO_END_XMIT_IMPOSSIBLE_114,
			C_V_CONVERSATION_MODE_ON_126,
			C_V_INTERWORKING_UNSPECIFIED_127,
};

			/* Channel selection according to interface type */

CONST	uchar VN3_CHAN_SEL_BRI_S[] = {
			INT_TYPE_BRI,
			NO_CHAN,
			B1_CHAN,
			B2_CHAN,
			ANY_CHAN,
};

CONST	uchar VN3_CHAN_SEL_PRI_S[] = {
			INT_TYPE_PRI,
			NO_CHAN,
			AS_INDICATED,
			ANY_CHAN,
};

		/* Teleservice selection according the coding standard */

CONST	uchar VN3_TELESERVICE_CCITT_S[] = {
	CODING_STD_CCITT,
		TELEPHONY,
		FAX_3,
		MIXED_MODE,
		PROCESSABLE_FORM,
		FAX_4,
		TELETEX,
		VIDEOTEX,
		VIDEOTEX_INTERNATIONAL_CONNECTION,
		TELEX,
		CCITT_7,
		OSI,
		AUDIOVISUAL_F_720,
		MAINTENANCE,		/* = HLC_NOT_AVAILABLE_1 */
		MANAGEMENT,			/* = HLC_NOT_AVAILABLE_2 */
		HLC_RESERVED,
};

				/* National = FRANCE TELECOM */

CONST	uchar VN3_TELESERVICE_NATIONAL_S[] = {
	CODING_STD_NATIONAL,
		INTERWORKING,
		AUDIOGRAPHIE,
		AUDIOVIDEOTEX,
		NON_NORMALISE,
};

/*-------------------------------------------------------------------------*/

		/*
		   Meta description of the information elements.
		   This description is	used to check an information element
		   inside a message and to store its value into  the internal
		   structure.
		   In the other way it is used to generate the information element of
		   a message from the internal structure.
		*/

#define NS_INCLUDE_IE_META_FUNCTION		ON		/* include prototypes of functions inside mp_ie.vn3 */

#include "vn3.mp_ie"  /* include IE meta-programs */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name        	vn3_bc_teleservice_compatibility -
				BC/Teleservice Compatibility checking function : checks if
				the BC Transfer Capability value may be compatible with
				the Teleservice (HLC) value.

Usage			uchar vn3_bc_teleservice_compatibility ();

Return value :  OK  if the BC may be compatible with the Teleservice.
				NOK if the BC and the Teleservice are actually NOT compatible.

Common constants and declarations : ns.h net_i_s.h

Common objects : 'i_bc' and 'i_hlc' internal data structures;
				 'bc_teleservice_compatibility' global var updated with
				 return value.

*--------------------------------------------------------------------------*/

uchar vn3_bc_teleservice_compatibility ()
{

	switch (i_bc[0].trf_cap) {

		case TRF_CAP_UNRESTRICTED :
		case TRF_CAP_7_AUDIO   :
		case TRF_CAP_VIDEO     :

			switch (i_hlc[0].teleservice) {

				case TELEPHONY :
				case FAX_3     :
					bc_teleservice_compatibility = NOK;
					break;
			}

			break;

		case TRF_CAP_SPEECH :

			switch (i_hlc[0].teleservice) {

				case TELEPHONY :
				case NON_NORMALISE :
				case INTERWORKING :
					break;

				default :
					bc_teleservice_compatibility = NOK;
					break;

			}

			break;

		case TRF_CAP_3_1_AUDIO :

			switch (i_hlc[0].teleservice) {

				case TELEPHONY :
				case FAX_3     :
				case NON_NORMALISE :
					break;

				default :
					bc_teleservice_compatibility = NOK;
					break;

			}

			break;

	}

	return (bc_teleservice_compatibility);
}

/*---------- Calling party number (CALLING_NB) */

uchar vn3_calling_nb_spdu ()
{

		/* if the message is sent to the network, then octet 3a shall be omitted. */

	ie_if_flag = Spdu_to_network() ? OFF : ON;

	return (OK);
}

/*---------- Cause (CAUSE) */

	/* ---------------PROVISOIRE COMPATIBILITE VN2 ----------------------*/

uchar vn3_cause_location_spdu ()
{

	if (direction == TO_D_CHANNEL) {
		i_cause[0].cause_loc = LOCATION_INTERNATIONAL_NET;
	}

	return (OK);
}

/*-------------------------------------------------------------------------*/

#define Ns_vn3_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_vn3_end_table_or_function		};
#define Ns_vn3_tab_tabl_entry(idx, tab)		Ns_tab_tabl_entry (idx, tab),
#define Ns_vn3_tabx_list_entry(tab)			Ns_tabx_list_entry (tab),
#define Ns_vn3_tab_tabx_entry(idx, tab)		Ns_tab_tabx_entry (idx, tab),

#define Ns_vn3_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx)	\
			Ns_tab_ie_entry (codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, 0),

#define Ns_vn3_tab_ie_no_i_str(codes, ie, mx)	{codes, ie, A_NIL, 0, A_NIL, A_NIL, A_NIL, mx, 0},
#define Ns_vn3_tab_ie_msg_header			{CODESET_NIL, MESSAGE_HEADER, (uchar *)A_NIL, sizeof(struct i_message_header), (uchar *)Pic_address (&i_message_header), (uchar *)A_NIL, (uchar *)A_NIL, 1, 0},

#include "vn3.tab_ie"		/* include other Tables describing the IEs */

#define VN3_MX_TABL (Rnd_sizeof(VN3_TAB_TABL)/Rnd_sizeof (struct tabl))
CONST	uchar	vn3_size_tab_tabl = VN3_MX_TABL;

#define VN3_MX_TABX (Rnd_sizeof(VN3_TAB_TABX)/Rnd_sizeof (struct tabx))
CONST	uchar	vn3_size_tab_tabx = VN3_MX_TABX;

CONST	uchar	vn3_size_tab_ie = Rnd_sizeof (VN3_TAB_IE) / IE_ELEM_SIZE;	/* maximum number of item in the table */

/*==========================================================================*

	 SPECIFIC PROCEDURES  : called when the meta description cannot
	 -------------------    solve the integrity problem. The direction
							parameter indicates the origination
							of the SPDU message (D CHANNEL or APPLI).

	 FROM_D_CHANNEL common context :p_ie points the current position in
	 -----------------------------	the SPDU message.

									p_ie_end points the end of the IE
									in the SPDU message.

									p_ind_buffer points the current free
									location in the ind_buffer.

	TO_D_CHANNEL common context :	p_ie points the current location of the
	--------------------------- 	SPDU message to generate.

*==========================================================================*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_bc_spdu - implements the specific processing of a BC
								 Information Element (IE).

Usage           uchar vn3_bc_spdu ();

Return value : 	vn3_bc_spdu returns OK
									NOK

Common constants and declarations : ns.h vn3_i_s.h

Common objects : internal data structure i_bc, ie  spdu context.

*--------------------------------------------------------------------------*/

uchar vn3_bc_spdu ()
{
	uchar	ie_octet;

	if (direction == FROM_D_CHANNEL) {

			/* Ignore extra information at the end of the BC IE */

		if (Eo_ie) {
			return (OK);

		} else {

			while ( ! Eo_ie) {
				ie_octet = Get_ie_octet;
				Inc_p_ie(1);
			}


			if (Extract (EXT_POSITION, EXT_LGTH) != EXT_LAST) {
				return (NOK);
			}

		}

	}

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_cause_spdu - implements the specific processing of a cause
								 Information Element (IE).

Usage           uchar vn3_cause_spdu ();

Return value : 	vn3_cause_spdu returns OK
								   NOK

Common constants and declarations : ns.h vn3_i_s.h

Common objects : internal data structure i_cause, ie  spdu context.

*--------------------------------------------------------------------------*/

				/* IE cause */

uchar vn3_cause_spdu ()
{
	uchar	class_val;			/* cause class & value */

	class_val = C_v (I_cause_class, I_cause_val);

	if (direction == FROM_D_CHANNEL) {

					/* Is SPDU ID = STATUS ? */

		if (spdu_id == STATUS) {

			switch (class_val) {

				case C_v (C_C_INVALID_MESSAGE,	C_V_INVALID_MESSAGE_UNSPECIFIED_95)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MANDATORY_IE_MISSING_96)		:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MESSAGE_TYPE_NON_EXISTENT_97)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MESSAGE_STATE_INCONSISTENCY_98)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_NON_EXISTENT_IE_99)				:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_INVALID_IE_CONTENT_100)			:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MESSAGE_NOT_COMPATIBLE_101)		:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_RECOVERY_ON_TIMER_EXPIRY_102)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_INCORRECT_MANDATORY_IE_LGTH_103):
					return (r_exec_spdu_ie ((uchar *)&VN3_DIAGNOSTIC_SPDU));

				default :

					if (! Eo_ie) {
						return (NOK);
					}

					I_cause_p_diagnostic	= P_NIL;
					I_cause_diag_lgth		= 0;
					return (OK);
			}

		} else {

			if (! Eo_ie) {
				return (r_exec_spdu_ie ((uchar *)&VN3_DIAGNOSTIC_SPDU));
			}

			I_cause_p_diagnostic	= P_NIL;
			I_cause_diag_lgth		= 0;

			return (OK);
		}

	} else {

				/* TO D CHANNEL side */

		if (spdu_id == STATUS) {

			switch (class_val) {

				case C_v (C_C_INVALID_MESSAGE,	C_V_INVALID_MESSAGE_UNSPECIFIED_95)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MANDATORY_IE_MISSING_96)		:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MESSAGE_TYPE_NON_EXISTENT_97)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MESSAGE_STATE_INCONSISTENCY_98)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_NON_EXISTENT_IE_99)				:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_INVALID_IE_CONTENT_100)			:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_MESSAGE_NOT_COMPATIBLE_101)		:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_RECOVERY_ON_TIMER_EXPIRY_102)	:
				case C_v (C_C_PROTOCOL_ERROR,	C_V_INCORRECT_MANDATORY_IE_LGTH_103):
					return (s_exec_spdu_ie ((uchar *)&VN3_DIAGNOSTIC_SPDU));
			}

		}

		return (OK);
	}

}

#define	Get_modem_value()				Get_bits (*p_ie,0,6)
#define	First_modem_user_specific_value G_6 (1,1,0,0,0,0)

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_llc_spdu - implements the processing of the low layer
							   compatibility (LLC) IE of a received SPDU
							   message and of a 'to send' SPDU message.

Usage           uchar vn3_llc_spdu ();

Return value : 	vn3_llc_spdu returns = OK valid data,
									 = NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar vn3_llc_check_modem ()
{

	uchar field;

		/* If Octet is skip return OK */

	if (I_(llc, duplex) == BYTE_VAL_NIL) return (OK);

	if (direction == FROM_D_CHANNEL) {

		field = Get_modem_value ();

		if ((find_tabl (field, VN3_T_MODEM) != OK)) {

			/*
				Modem value from network is not within the
				modem table. May be it is a user specific value.
				If so, value is >= G_6 (1,1,0,0,0,0)
			*/

			if (field < First_modem_user_specific_value) {
				return (NOK);
			}

			I_(llc,modem) = field;
		}
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_llc_spdu - implements the processing of the low layer
							   compatibility (LLC) IE of a received SPDU
							   message and of a 'to send' SPDU message.

Usage           uchar vn3_llc_spdu ();

Return value : 	vn3_llc_spdu returns = OK valid data,
									 = NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar vn3_llc_4a_spdu ()
{

	ie_if_flag = ON;	/* (default value) : octets 4a and 4b may be present */

	if ((direction == TO_D_CHANNEL) &&
		(I_llc_structure	 == STRUCTURE_DEFAULT) &&
		(I_llc_configuration == CONFIG_POINT_TO_POINT) &&
		(I_llc_est			 == EST_DEMAND) &&
		(I_llc_symmetry		 == BIDIRECTIONAL_SYMMETRY) &&
		(I_llc_dest_rate	 == I_llc_trf_rate)) {

			/* default values for octets 4a and 4b : they are omitted */

		ie_if_flag = OFF;
	}

	return (OK);

}

uchar vn3_llc_4b_spdu ()
{

	ie_if_flag = ON;	/* (default value) : octet 4b may be present */

	if ((direction == TO_D_CHANNEL) &&
		(I_llc_symmetry	 == BIDIRECTIONAL_SYMMETRY) &&
		(I_llc_dest_rate == I_llc_trf_rate)) {

			/* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);

}

uchar vn3_llc_3a_spdu ()
{

	ie_if_flag = ON;	/* (default value) : octet 3a may be present */

	if ((direction == TO_D_CHANNEL) &&
		(I_llc_out_band_neg == OUT_BAND_NOT_POSSIBLE)) {

			/* default value for octet 3a : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);

}

#define Get_layer_id()	Extract (5,Mask(2))

uchar vn3_llc_5_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 5 may be present */

		/* if I_llc_protocol_id_1 == BYTE_VAL_NIL -> octet 5 is missing */

	if (direction == TO_D_CHANNEL) {

		if (I_(llc,protocol_id_1) == BYTE_VAL_NIL) {

				/* octet 5 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_1) {

				/* It is NOT Octet 5 (layer 1) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

uchar vn3_llc_spdu ()
{

	if (direction == FROM_D_CHANNEL) {

				/* FROM D CHANNEL side */

		switch (I_llc_protocol_id_1) {

			case PROTOCOL_ID_1_V110 :
			case PROTOCOL_ID_1_RA_NON_CCITT :
				ret_code = r_exec_spdu_ie ((uchar *)&VN3_V110_SPDU);
				break;

			case PROTOCOL_ID_1_V120 :
				ret_code = r_exec_spdu_ie ((uchar *)&VN3_V120_SPDU);
				break;

			default :
				ret_code = OK;
				break;

		}

		if (ret_code != OK) return (ret_code);

		return (r_exec_spdu_ie ((uchar *)&VN3_LLC_P_2));

	} else {

			/* TO D CHANNEL side */

		switch (I_llc_protocol_id_1) {

			case PROTOCOL_ID_1_V110 :
			case PROTOCOL_ID_1_RA_NON_CCITT :
				ret_code = s_exec_spdu_ie ((uchar *)&VN3_V110_SPDU);
				break;

			case PROTOCOL_ID_1_V120 :
				ret_code = s_exec_spdu_ie ((uchar *)&VN3_V120_SPDU);
				break;

			default :

					/* Set previous EXT bit to 1 */

				Dec_p_ie (1);
				Put_ie_field ((uchar)EXT_POSITION, (uchar)EXT_LGTH, (uchar)EXT_LAST);
				Inc_p_ie (1);

				ret_code = OK;
				break;

		}

		if (ret_code != OK) return (ret_code);

			/* If V110 or V120 do not send octet 6 and 7 */

		if ((I_llc_protocol_id_1 == PROTOCOL_ID_1_V110) ||
			(I_llc_protocol_id_1 == PROTOCOL_ID_1_V120)
		   ) {
			return (OK);

		} else {

			return (s_exec_spdu_ie ((uchar *)&VN3_LLC_P_2));
		}

	}

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_spf_fac - implements the processing of a specific facility
							  IE (received in a SPDU message or to send in a
							  SPDU message).

Usage           uchar vn3_spf_fac ();

Return value : 	vn3_spf_fac returns = OK	valid data,
								= NOK   invalid data if fatal error.

common constants and declarations :	isdn.h

*--------------------------------------------------------------------------*/

uchar vn3_spf_fac_spdu ()
{

#if NS_SPF_FACILITY == OFF
	return (NOK);
#else

	uchar 		n;			/* facility code */
	uchar 		i;			/* loop index */
	long		x;			/* temporary variable */


	if (direction == FROM_D_CHANNEL) {

					/* FROM D CHANNEL side */

			/*
				Structure of the specification field :
					service code*bloc[#]
			*/

			/* Decode service code */

				/* First decimal digit */

		if ((Get_ie_octet < D_0) || (Get_ie_octet > D_9)) {
			return (NOK);
		}

		n = (Get_ie_octet - D_0) * 10;

				/* Next decimal digit */

		if ((Inc_get_ie_octet < D_0) || (Get_ie_octet > D_9)) {
			return (NOK);
		}

		I_spf_fac_code = (n += (Get_ie_octet - D_0)); /* binary code in the internal data structure */

		if (Inc_get_ie_octet == START_OF_BLOCK) {

			Inc_p_ie(1);

			switch (n) {

					/* Call forwarding with called number or nothing */

				case FT_SPF_FAC_CALL_FORWARDING :
					I_spf_fac_info_lgth = (uchar)(Remainder_ie_octet - 1);

					if (Get_ie_octet != END_OF_SPECIFICATION) {

						if (check_convert ((uchar FAR *)p_ind_buffer,
										   Get_p_ie,
										   I_spf_fac_info_lgth,
										   IA5,
										   DIGIT) == NOK) {
							return (NOK);

						} else {

							I_spf_fac_p_fac	= p_ind_buffer;
							p_ind_buffer			+= I_spf_fac_info_lgth + 1;
							Inc_p_ie (I_spf_fac_info_lgth);
							if (Get_inc_ie_octet != END_OF_SPECIFICATION) return (NOK);
						}

					} else {

						Inc_p_ie (1);	/* to skip the END_OF_SPECIFICATION byte */
					}

					break;

						/* Teletax */

				case FT_SPF_FAC_CHARGING :
				case FT_SPF_FAC_CHARGING_TOTAL :
					I_spf_fac_tax = Get_inc_ie_octet;

					for (i = 0, x = 1; i < (uchar)CHARGING_LGTH - 1; i++) {
						x = x << 8;
						I_spf_fac_tax += x * Get_inc_ie_octet;
					}

					break;


				case FT_SPF_FAC_THREE_PARTY :
					break;

				default :
					return (NOK);

			}

		} else {

			if (Get_inc_ie_octet != END_OF_SPECIFICATION) return (NOK);
		}


			/* Check end of IE */

		if (!Eo_ie) return (NOK);

			/* Check if the facility is consistent with the SPDU ID ? */

		switch (spdu_id) {

				/* CALL PROCEEDING */

			case CALL_PROC :
				if (I_spf_fac_code != FT_SPF_FAC_CALL_FORWARDING) return (NOK);
				I_spf_fac_action = FT_SPF_FAC_IN_TX;
				break;

				/* DISCONNECT / RELEASE */

			case DISC :
			case REL :
				if (I_spf_fac_code != FT_SPF_FAC_CHARGING_TOTAL) return (NOK);
				I_spf_fac_action = FT_SPF_FAC_IN_TX;
				break;

				/* INFORMATION */

			case INFO :

				switch (I_spf_fac_code) {

					case FT_SPF_FAC_CHARGING :
					case FT_SPF_FAC_CHARGING_TOTAL :
						I_spf_fac_action = FT_SPF_FAC_IN_TX;
						break;

					case FT_SPF_FAC_THREE_PARTY :
						I_spf_fac_action = FT_SPF_FAC_CO_ACK;
						break;

					default :
						return (NOK);

				}
				break;

				/* REGISTRATION ACKNOWLEDGEMENT */

			case REG_ACK :
				if (I_spf_fac_code != FT_SPF_FAC_CALL_FORWARDING) return (NOK);
				I_spf_fac_action = FT_SPF_FAC_CO_ACK;
				break;

				/* REGISTRATION REJECT */

			case FT_REG_REJ :
				if (I_spf_fac_code != FT_SPF_FAC_CALL_FORWARDING) 	return (NOK);
				I_spf_fac_action = FT_SPF_FAC_CO_REJ;
				break;

				/* FACILITY ACKNOWLEDGEMENT */

			case FT_FAC_ACK :

				switch (I_spf_fac_action) {

					case FT_SPF_FAC_CALL_FORWARDING :
						I_spf_fac_action = FT_SPF_FAC_CO_ACK;
						break;

					default :
						return (NOK);

				}
				break;

				/* FACILITY REJECT */

			case FT_FAC_REJ :

				switch (I_spf_fac_action) {

					case FT_SPF_FAC_CALL_FORWARDING :
						I_spf_fac_action = FT_SPF_FAC_CO_REJ;
						break;

					default :
						return (NOK);

				}
				break;

		}

		Set_p_ie (p_ie_end);

	} else {

				/* TO D CHANNEL side */

		switch (I_spf_fac_action) {

			case FT_SPF_FAC_RQ_ACTIVATE :
				Put_inc_ie_octet (PREFIX_ACTIVATE);
				break;

			case FT_SPF_FAC_RQ_CLEAR :
				Put_inc_ie_octet (PREFIX_CLEAR);
				break;

			case FT_SPF_FAC_RQ_ENQUIRY :
				Put_inc_ie_octet (PREFIX_ENQUIRY_1);
				Put_inc_ie_octet (PREFIX_ENQUIRY_2);
				break;

		}

			/* Transfer the code : 2 decimal digit */

		Put_inc_ie_octet (D_0 + (I_spf_fac_code / 10));
		Put_inc_ie_octet (D_0 + (I_spf_fac_code % 10));


			/* Transfer the block (called number) if any */

		if (I_spf_fac_p_fac != P_NIL) {
			Put_inc_ie_octet (START_OF_BLOCK);

			if (check_convert (Get_p_ie,
							   (uchar FAR *)I_spf_fac_p_fac,
							   I_spf_fac_info_lgth,
							   IA5,
							   DIGIT
							  ) == NOK) {

#						if ASSERT == ON
							Error_intern ();
#						endif

			}

			Inc_p_ie (I_spf_fac_info_lgth);

		}
			/* Add end of specifications */

		Put_inc_ie_octet (END_OF_SPECIFICATION);

	}


			/* Return */

		return (OK);

#endif

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_uui_spdu - implements the specific processing of a
							   user to user Information Element (IE).

Usage           uchar vn3_uui_spdu ();

Return value : 	vn3_uui_spdu returns OK  : valid
									 NOK : invalid - fatal error.

Common constants and declarations : ns.h net_i_s.h

Common objects : internal data structure i_uui, ie  spdu context.

*--------------------------------------------------------------------------*/

uchar vn3_uui_spdu ()
{

	if (direction == FROM_D_CHANNEL) {

				/* FROM D CHANNEL side */

		if (I_uui_protocol_discr == PROTOCOL_DISCR_IA5) {
			return(r_exec_spdu_ie ((uchar *)&VN3_UUI_IA5_SPDU));

		} else {

			return (r_exec_spdu_ie((uchar *)&VN3_UUI_TNA_SPDU));
		}

	} else {

				/* TO D CHANNEL side */

		if (I_uui_protocol_discr == PROTOCOL_DISCR_IA5) {
			return(s_exec_spdu_ie ((uchar *)&VN3_UUI_IA5_SPDU));

		} else {

			return (s_exec_spdu_ie((uchar *)&VN3_UUI_TNA_SPDU));
		}

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_chan_id_spdu - implements the specific processing
				of a channel Id Information Element (IE) received from the
				D channel : checks the Interface Type field.

Usage           uchar vn3_chan_id_spdu ();

Return value : 	OK  : valid
				NOK : invalid - fatal error.

Common constants and declarations : ns.h net_i_s.h

Common objects : internal data structure i_chan_id, ie  spdu context.

*--------------------------------------------------------------------------*/

uchar vn3_chan_id_spdu ()
{
	if (direction == FROM_D_CHANNEL) {

		if (I_chan_id_int_type == INT_TYPE_BRI) {

			if (Na_type != BRI) {
				return (NOK);
			}

		} else {

			if (Na_type != PRI) {
				return (NOK);
			}

		}

	}

		/* Process PRI type chan_id */

	if (I_(chan_id,int_type) != INT_TYPE_BRI) {

		if ((I_(chan_id,chan_sel) == NO_CHAN) ||
			(I_(chan_id,chan_sel) == ANY_CHAN)) {
			ie_optional_octet = ON;
		}

		if (direction == FROM_D_CHANNEL) {
			return (r_exec_spdu_ie ((uchar *)&VN3_CHAN_ID_PRI_P));

		} else {

			return (s_exec_spdu_ie ((uchar *)&VN3_CHAN_ID_PRI_P));
		}

	}

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn3_chan_id_to_d_spdu - implements the specific processing
				of a channel Id Information Element (IE) to be sent to the
				D channel : forces the Interface Type field according to
				the NA configuration.

Usage           uchar vn3_chan_id_to_d_spdu ();

Return value : 	OK  : valid
				NOK : invalid - fatal error.

Common constants and declarations : ns.h net_i_s.h

Common objects : internal data structure i_chan_id, ie  spdu context.

*--------------------------------------------------------------------------*/

uchar vn3_chan_id_to_d_spdu ()
{
	if (direction == TO_D_CHANNEL) {
		I_chan_id_int_type = (Na_type == BRI) ? INT_TYPE_BRI : INT_TYPE_PRI;
	}

	return (OK);
}
/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		vn3_restart_spdu - check if presence of CHAN ID IE is compulsory or forbidden.

Usage		uchar vn3_restart_spdu ();

Return value :  vn3_restart_spdu returns = OK   valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar vn3_restart_spdu ()
{

	if (is_ie_i (CODESET_0, CHAN_ID) == ABSENT) {
		return (OK);

	} else {

		if (I_restart_ind_class == RI_INDICATED_CHANNEL) {
			return (OK);
		}

	}

	return (NOK);
}

/*-------------------------------------------------------------------------*/

#if OM_CODE_TYPE == OM_PIC /* PIC used{ */

#undef Ns_vn3_table_or_function
#undef Ns_vn3_end_table_or_function
#undef Ns_vn3_tab_tabl_entry
#undef Ns_vn3_tabx_list_entry
#undef Ns_vn3_tab_tabx_entry
#undef Ns_vn3_tab_ie_entry
#undef Ns_vn3_tab_ie_no_i_str
#undef Ns_vn3_tab_ie_msg_header

#define Ns_vn3_table_or_function(str, tab)	i_pic = 0;						\
											{								\
												struct str FAR	*p_table;	\
												p_table = tab;

#define Ns_vn3_end_table_or_function		}

#define Ns_vn3_tab_tabl_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_val, (uchar *)tab);
#define Ns_vn3_tabx_list_entry(tab)			Pic_init_struct_array_next (p_table,  p_val, (uchar	*)tab);
#define Ns_vn3_tab_tabx_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_tab, (struct tabx_list *)tab);

#define Ns_vn3_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx)	\
	Pic_init_struct_array (p_table,  i_pic, p_prog, (uchar	*)mp_a);		\
	Pic_init_struct_array (p_table,  i_pic, p_i_struct, (uchar	*)i_str);	\
	Pic_init_struct_array (p_table,  i_pic, p_init_spdu, (uchar	*)df_spdu);	\
	Pic_init_struct_array_next (p_table,  p_init_ssdu, (uchar	*)df_ssdu);

#define Ns_vn3_tab_ie_no_i_str(codes, ie, mx)	Ns_vn3_tab_ie_entry (0, 0, P_NIL, P_NIL, P_NIL, P_NIL, 0)

#define Ns_vn3_tab_ie_msg_header		Ns_vn3_tab_ie_entry (0, 0, P_NIL, &i_message_header, P_NIL, P_NIL, 0)

		/*	Function used to initialize address fields in Tables above */

void pic_init_ns_vn3_ie ()
{
	uchar	i_pic;			/* current index */

#	include "vn3.tab_ie"
}

#endif /* end of PIC used} */


/*EOF*/
