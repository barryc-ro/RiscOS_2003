/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_ie.at5
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the meta description of all the ATT_5E5 information
 * element and the integrity constraints associated to them.
 *
 *
 *
 *  ATT_5E5 SPECIFIC FUNCTIONS :
 *  ----------------------------
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/
/*
*
*Table structures :
*----------------
*
*        tabl_item   TABL_ITEM                                    uchar
*        ==========================                             ============
*        | tabl_id | size | p_val |---------------------------->|   val    |
*        --------------------------  tabl_yy      ============  ------------
*        |         |      |       |-------------->|   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |          |  |          |
*        --------------------------
*        |         |      |       |
*        --------------------------
*        |         |      |       |
*
*
*    tabx_item   TABX_ITEM                   tabx_list                uchar
*    =================================     =================        =========
*    | tabl_id | size | list pointer |---->| tabl_id | size|------->| x_val |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------
*    |         |      |              |
*
*/

/*-------------------------------------------------------------------------*/

    /*
        Initialization constants of ie internal structure
        used by SPDU received processing.
    */


        /* Call state               (CALL_STATE) */

CONST   struct  i_call_state    df_spdu_at5_i_call_state = {
    BYTE_VAL_NIL,
    STATE_NULL_0,
};

        /*  Called party number     (CALLED_NB) */

CONST   struct  i_called_nb     df_spdu_at5_i_called_nb = {
    NB_LOCAL,
    PLAN_ISDN,
    BYTE_VAL_NIL,
    A_NIL,
};

        /* Calling party number     (CALLING_NB) */

CONST   struct  i_calling_nb    df_spdu_at5_i_calling_nb = {
    NB_LOCAL,
    PLAN_ISDN,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL,
};

        /* Cause                    (CAUSE) */

CONST   struct  i_cause     df_spdu_at5_i_cause = {
    CODING_STD_CCITT,
    LOCATION_USER,
    BYTE_VAL_NIL,
    C_C_NORMAL_EVENT,
    C_V_NORMAL_CLEARING_16,
    BYTE_VAL_NIL,
    0,
    A_NIL,
};

        /* Channel identification   (CHAN_ID) */

CONST   struct  i_chan_id   df_spdu_at5_i_chan_id = {
    INT_ID_IMPLICIT,
    INT_TYPE_BRI,
    CHAN_PREF,
    NOT_D_CHAN,
    ANY_CHAN,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL
};

        /* Endpoint identifier      (AT5_ENDPOINT_ID) */

CONST   struct  i_endpoint_id   df_spdu_at5_i_endpoint_id = {
    USID_ALL,
    INTERPRETER_0,
    TID_ALL,
};

        /* Keypad                   (KEYPAD) */

CONST   struct  i_keypad    df_spdu_at5_i_keypad = {
    0,
    A_NIL,
};

        /* Progress indicator       (PROGRESS_IND) */

CONST   struct  i_progress_ind  df_spdu_at5_i_progress_ind = {
    CODING_STD_CCITT,
    PROGRESS_LOC_USER,
    PROGRESS_DESCR_NON_END_TO_END_ISDN,
};

        /* Signal                   (SIGNAL) */

CONST   struct  i_signal    df_spdu_at5_i_signal = {
    TONES_OFF,
};

        /* Terminal capabilities    (TE_CAP) */

CONST   struct  i_te_cap    df_spdu_at5_i_te_cap = {
    CODING_STD_CCITT,
    TYPE_2_STIMULUS,
};

        /*  Bearer capability       (BC) */

CONST   struct  i_bc    df_spdu_at5_i_bc = {
    CODING_STD_CCITT,
    TRF_CAP_SPEECH,
    TRF_MODE_CIRCUIT,
    TRF_RATE_64KBS,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    LAYER_ID_1,
    PROTOCOL_ID_1_G711_u,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    RA_56KBS,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    1,                      /* layer nb */
    BYTE_VAL_NIL,
    LAYER_ID_3,
    PROTOCOL_ID_3_X25_PL,
};

        /* Low Layer Compatibility  (LLC) */

CONST   struct  i_llc   df_spdu_at5_i_llc = {
    CODING_STD_CCITT,
    TRF_CAP_UNRESTRICTED,
    BYTE_VAL_NIL,
    TRF_MODE_CIRCUIT,
    TRF_RATE_64KBS,
    STRUCTURE_DEFAULT,
    CONFIG_POINT_TO_POINT,
    EST_DEMAND,
    BIDIRECTIONAL_SYMMETRY,
    TRF_RATE_64KBS,
    LAYER_ID_1,
    PROTOCOL_ID_1_RA_I461,
    SYN,
    BYTE_VAL_NIL,
    RA_56KBS,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    1,                      /* layer nb */
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    LAYER_ID_3,
    PROTOCOL_ID_3_X25_PL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
};

/*-------- SPDU messages not used in Basic Services --------*/

#if AT5_SUPPLEMENTARY_SERVICES == ON

        /* Switchhook           (SWITCHHOOK) */

CONST   struct  i_switchhook    df_spdu_at5_i_switchhook = {
    HOOK_ON,
};

        /* Restart indicator    (RESTART_IND) */

CONST   struct  i_restart_ind   df_spdu_at5_i_restart_ind = {
    BYTE_VAL_NIL,
};

        /* User to user information (UUI) */

CONST   struct  i_uui   df_spdu_at5_i_uui = {
    PROTOCOL_DISCR_Q931,
    BYTE_VAL_NIL,
    A_NIL,
};

        /* Associated type (ASSOC_TYPE) */

CONST   struct  i_assoc_type    df_spdu_at5_i_assoc_type = {
    BYTE_VAL_NIL,
};

        /* Selected Call Appearance (SEL_CALL_APPEAR) */

CONST   struct  i_sel_call_appear   df_spdu_at5_i_sel_call_appear = {
    1,
};

        /* Origination Call Appearance (ORI_CALL_APPEAR) */

CONST   struct  i_ori_call_appear   df_spdu_at5_i_ori_call_appear = {
    1,
};

        /* Destination Call Appearance (DEST_CALL_APPEAR) */

CONST   struct  i_dest_call_appear  df_spdu_at5_i_dest_call_appear = {
    1,
};

        /* Keypad Control (KEYPAD_CON) */

CONST   struct  i_keypad_con    df_spdu_at5_i_keypad_con = {
    CALL_REF_NOT_NULL,
};

        /* Other Call Reference (OTHER_CALL_REF) */

CONST   struct  i_other_call_ref    df_spdu_at5_i_other_call_ref = {
    1
};

        /* Feature activation (FEATURE_ACT) */

CONST   struct  i_feature_act   df_spdu_at5_i_feature_act = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BUTTON_TYPE_UNKNOWN,
    MODULE_0,
    FEATURE_NUMBER_STATUS,
    1,
};

        /* Feature indication (FEATURE_IND) */

CONST   struct  i_feature_ind   df_spdu_at5_i_feature_ind = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BUTTON_TYPE_UNKNOWN,
    MODULE_0,
    FEATURE_NUMBER_STATUS,
};

        /* Adjunct control (ADJUNCT_CON) */

CONST   struct  i_adjunct_con   df_spdu_at5_i_adjunct_con = {
    ADJUNCT_OFF,
};

        /* Display control (DISPLAY_CON) */

CONST   struct  i_display_con   df_spdu_at5_i_display_con = {
    DISPLAY_NORMAL,
};

        /* Display field (DISPLAY_FLD) */

CONST   struct  i_display_fld   df_spdu_at5_i_display_fld = {
    DISPLAY_NORMAL,
    DISPLAY_SUBMODE_DIRECT,
    CALL_APPEAR_ID,
    0,
    A_NIL,
};

#endif
		/* Display (DISPLAY) */

CONST   struct  i_display   df_spdu_at5_i_display = {
	BYTE_VAL_NIL,
    0,
    A_NIL,
};

        /* Management (MANAGMNT) */

CONST   struct  i_managmnt  df_spdu_at5_i_managmnt = {
    PROTOCOL_DISCR_ATT_ISDN_MAN,
    SYN,
};


/*=========================================================================*/

    /*
        Initialization constants of the ie internal structure
        used by SSDU received processing.
    */

        /* Call state (CALL_STATE) */

CONST   struct  i_call_state    df_ssdu_at5_i_call_state = {
    BYTE_VAL_NIL,
    STATE_NULL_0,
};

        /*  Called party number (CALLED_NB) */

CONST   struct  i_called_nb     df_ssdu_at5_i_called_nb = {
    NB_LOCAL,
    PLAN_ISDN,
    BYTE_VAL_NIL,
    A_NIL,
};

        /* Calling party number (CALLING_NB) */

CONST   struct  i_calling_nb    df_ssdu_at5_i_calling_nb = {
    NB_LOCAL,
    PLAN_ISDN,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL,
};

        /* Cause (CAUSE) */

CONST   struct  i_cause     df_ssdu_at5_i_cause = {
    CODING_STD_CCITT,
    LOCATION_USER,
    BYTE_VAL_NIL,
    C_C_NORMAL_EVENT,
    C_V_NORMAL_CLEARING_16,
    BYTE_VAL_NIL,
    0,
    A_NIL,
};

        /* Channel identification (CHAN_ID) */

CONST   struct  i_chan_id   df_ssdu_at5_i_chan_id = {
    INT_ID_IMPLICIT,
    INT_TYPE_BRI,
    CHAN_PREF,
    NOT_D_CHAN,
    ANY_CHAN,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    0,
    A_NIL,
};

        /* Endpoint identifier (AT5_ENDPOINT_ID) */

CONST   struct  i_endpoint_id   df_ssdu_at5_i_endpoint_id = {
    USID_ALL,
    INTERPRETER_0,
    TID_ALL,
};

        /* Keypad (KEYPAD) */

CONST   struct  i_keypad    df_ssdu_at5_i_keypad = {
    0,
    A_NIL,
};

        /* Progress indicator (PROGRESS_IND) */

CONST   struct  i_progress_ind  df_ssdu_at5_i_progress_ind = {
    CODING_STD_CCITT,
    PROGRESS_LOC_USER,
    PROGRESS_DESCR_NON_END_TO_END_ISDN,
};

        /* Signal (SIGNAL) */

CONST   struct  i_signal    df_ssdu_at5_i_signal = {
    TONES_OFF,
};

        /* Terminal capabilities (TE_CAP) */

CONST   struct  i_te_cap    df_ssdu_at5_i_te_cap = {
    CODING_STD_CCITT,
    TYPE_2_STIMULUS,
};

        /*  Bearer capability (BC) */

CONST   struct  i_bc    df_ssdu_at5_i_bc = {
    CODING_STD_CCITT,
    TRF_CAP_SPEECH,
    TRF_MODE_CIRCUIT,
    TRF_RATE_64KBS,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    LAYER_ID_1,
    PROTOCOL_ID_1_G711_u,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    RA_56KBS,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    1,                      /* layer nb */
    BYTE_VAL_NIL,
    LAYER_ID_3,
    PROTOCOL_ID_3_X25_PL,
};

        /* Low Layer Compatibility (LLC) */

CONST   struct  i_llc   df_ssdu_at5_i_llc = {
    CODING_STD_CCITT,
    TRF_CAP_UNRESTRICTED,
    BYTE_VAL_NIL,
    TRF_MODE_CIRCUIT,
    TRF_RATE_64KBS,
    STRUCTURE_DEFAULT,
    CONFIG_POINT_TO_POINT,
    EST_DEMAND,
    BIDIRECTIONAL_SYMMETRY,
    TRF_RATE_64KBS,
    LAYER_ID_1,
    PROTOCOL_ID_1_RA_I461,
    SYN,
    BYTE_VAL_NIL,
    RA_56KBS,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    1,                      /* layer nb */
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    LAYER_ID_3,
    PROTOCOL_ID_3_X25_PL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
};

/*-------- SSDU messages not used in Basic Services --------*/

#if AT5_SUPPLEMENTARY_SERVICES == ON


        /* Switchhook           (SWITCHHOOK) */

CONST   struct  i_switchhook    df_ssdu_at5_i_switchhook = {
    HOOK_ON,
};

        /* Restart indicator    (RESTART_IND) */

CONST   struct  i_restart_ind   df_ssdu_at5_i_restart_ind = {
    BYTE_VAL_NIL,
};

        /* User to user information (UUI) */

CONST   struct  i_uui   df_ssdu_at5_i_uui = {
    PROTOCOL_DISCR_Q931,
    BYTE_VAL_NIL,
    A_NIL,
};

        /* Associated type (ASSOC_TYPE) */

CONST   struct  i_assoc_type    df_ssdu_at5_i_assoc_type = {
    BYTE_VAL_NIL,
};

        /* Selected Call Appearance (SEL_CALL_APPEAR) */

CONST   struct  i_sel_call_appear   df_ssdu_at5_i_sel_call_appear = {
    1,
};

        /* Origination Call Appearance (ORI_CALL_APPEAR) */

CONST   struct  i_ori_call_appear   df_ssdu_at5_i_ori_call_appear = {
    1,
};

        /* Destination Call Appearance (DEST_CALL_APPEAR) */

CONST   struct  i_dest_call_appear  df_ssdu_at5_i_dest_call_appear = {
    1,
};

        /* Keypad Control (KEYPAD_CON) */

CONST   struct  i_keypad_con    df_ssdu_at5_i_keypad_con = {
    CALL_REF_NOT_NULL,
};

        /* Other Call Reference (OTHER_CALL_REF) */

CONST   struct  i_other_call_ref    df_ssdu_at5_i_other_call_ref = {
    1,
};

        /* Feature activation (FEATURE_ACT) */

CONST   struct  i_feature_act   df_ssdu_at5_i_feature_act = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BUTTON_TYPE_UNKNOWN,
    MODULE_0,
    FEATURE_NUMBER_STATUS,
    1,
};

        /* Feature indication (FEATURE_IND) */

CONST   struct  i_feature_ind   df_ssdu_at5_i_feature_ind = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BUTTON_TYPE_UNKNOWN,
    MODULE_0,
    FEATURE_NUMBER_STATUS,
};

        /* Adjunct control (ADJUNCT_CON) */

CONST   struct  i_adjunct_con   df_ssdu_at5_i_adjunct_con = {
    ADJUNCT_OFF,
};

        /* Display control (DISPLAY_CON) */

CONST   struct  i_display_con   df_ssdu_at5_i_display_con = {
	DISPLAY_NORMAL,
};

		/* Display field (DISPLAY_FLD) */

CONST   struct  i_display_fld   df_ssdu_at5_i_display_fld = {
	DISPLAY_NORMAL,
	DISPLAY_SUBMODE_DIRECT,
	CALL_APPEAR_ID,
	0,
	A_NIL,
};

#endif

		/* Display (DISPLAY) */

CONST   struct  i_display   df_ssdu_at5_i_display = {
	BYTE_VAL_NIL,
    0,
    A_NIL,
};

		/* Management (MANAGMNT) */

CONST   struct  i_managmnt  df_ssdu_at5_i_managmnt = {
    PROTOCOL_DISCR_ATT_ISDN_MAN,
    SYN,
};


/*=========================================================================*/

                /* TABLES : list of valid values */

                    /* Adjunct control */

CONST   uchar ADJUNCT_VAL_AT5_S[] = {
                        ADJUNCT_ON,
                        ADJUNCT_OFF,
                        };

                    /* Associated status */

CONST   uchar ASSOC_STATUS_AT5_S[] = {
                        SETUP_STATUS,
                        CONNECT_STATUS,
                        HOLD_STATUS,
                        RECONNECT_STATUS,
                        EXCLUSION_STATUS,
                        CONNECT_DENIED_STATUS,
                        CLEARING_DENIED_STATUS,
                        };

                    /* Button type for activation */

CONST   uchar BUTTON_TYPE_ACT_AT5_S[]  = {
                        BUTTON_TYPE_UNKNOWN,
                        CALL_APPEAR_BUTTON,
                        FEATURE_BUTTON,
                        };

                    /* Button type indication */

CONST   uchar BUTTON_TYPE_IND_AT5_S[]  = {
                        BUTTON_TYPE_UNKNOWN,
                        CALL_APPEAR_BUTTON,
                        FEATURE_BUTTON,
                        NON_APPLICABLE,
                        };

                    /* Cause class */

CONST   uchar C_C_AT5_S[]  = {
                        C_C_NORMAL_EVENT_0,
                        C_C_NORMAL_EVENT,
                        C_C_RESOURCE_UNAVAILABLE,
                        C_C_SERVICE_NOT_AVAILABLE,
                        C_C_SERVICE_NOT_IMPLEMENTED,
                        C_C_INVALID_MESSAGE,
                        C_C_PROTOCOL_ERROR,
                        C_C_INTERWORKING,
                        };

                    /* Call reference flag */

CONST   uchar CALL_REF_FLAG_AT5_S[]  = {
                        CALL_REF_FLAG_ORI,
                        CALL_REF_FLAG_DEST,
                        };

                    /* Call reference type */

CONST   uchar CALL_REF_TYPE_AT5_S[]  = {
                        CALL_REF_NULL,
                        CALL_REF_NOT_NULL,
                        };

                    /* Automata call state values */

CONST   uchar CALL_STATE_VAL_AT5_S[]  = {
    /* 0 */             STATE_NULL_0,
    /* 1 */             STATE_CALL_INIT_1,
    /* 2 */             STATE_OVERLAP_SENDING_2,
    /* 3 */             STATE_OUTGOING_CALL_PROC_3,
    /* 4 */             STATE_CALL_DELIVERED_4,
    /* 7 */             STATE_CALL_RECEIVED_7,
    /* 8 */             STATE_CONNECT_REQUEST_8,
    /* 9 */             STATE_INCOMING_CALL_PROC_9,
    /* 10 */            STATE_ACTIVE_10,
    /* 11 */            STATE_DISCONNECT_REQUEST_11,
    /* 12 */            STATE_DISCONNECT_INDICATION_12,
    /* 19 */            STATE_RELEASE_REQUEST_19,
                        };

                    /* Channel type (ie CHAN_ID) */

CONST   uchar CHAN_TYPE_AT5_S[] = {
                        B_CHAN,
                        H0_CHAN,
                        H11_CHAN,
                        H12_CHAN,
                    };

                    /* Preferred/exclusive */

CONST   uchar CHAN_PREF_EXCL_AT5_S[]  = {
                        CHAN_PREF,
                        CHAN_EXCL,
                        };

                    /* Interface type (ie CHAN_ID) */

CONST   uchar AT5_INT_TYPE_S[] = {
                        INT_TYPE_BRI,
                        INT_TYPE_PRI,
                        };

                    /* Coding standard */

CONST   uchar CODING_STD_AT5_S[]  = {
                        CODING_STD_CCITT,
                        CODING_STD_RESERVED,
                        CODING_STD_NATIONAL,
                        CODING_STD_SPF,
                        };

                    /* Display Control Mode */

CONST   uchar DISPLAY_CON_MODE_AT5_S[]  = {
                        DISPLAY_NO_CHANGE,
                        DISPLAY_NORMAL,
                        DISPLAY_INSPECT,
                        DISPLAY_MISC_DISPLAY_INFO,
                        DISPLAY_MSG_RETRIEVAL,
                        DISPLAY_ELECTRONIC_DIR_QUERY,
                        };

                    /* Display Field Mode */

CONST   uchar DISPLAY_FLD_MODE_AT5_S[]  = {
                        DISPLAY_NORMAL,
                        DISPLAY_INSPECT,
                        DISPLAY_MISC_DISPLAY_INFO,
                        DISPLAY_MSG_RETRIEVAL,
                        DISPLAY_ELECTRONIC_DIR_QUERY,
                        };

                    /* Display Field Type */

CONST   uchar DISPLAY_FLD_TYPE_AT5_S[]  = {
                        CALL_APPEAR_ID,
                        CALLED_PARTY_ID,
                        CALLING_PARTY_ID,
                        CALLED_PARTY_NAME,
                        CALLING_PARTY_NAME,
                        ORIGINATING_PERMISSIONS,
                        ISDN_CALL_ID,
                        MISC_CALL_INFO,
                        ENTIRE_DISPLAY,
                        DATE_TIME_OF_DAY,
                        };

                    /* Display Submode */

CONST   uchar DISPLAY_SUBMODE_AT5_S[]  = {
                        DISPLAY_NO_SUBMODE,
                        DISPLAY_SUBMODE_DIRECT,
                        DISPLAY_SUBMODE_REDIRECTED,
                        };

                    /* Feature Meaning */

CONST   uchar FEATURE_MEANING_AT5_S[]  = {
                        FEATURE_MEANING_RESERVED,
                        FEATURE_MEANING_TURN_ALL_OFF,
                        };

                    /* Hook value */

CONST   uchar HOOK_VAL_AT5_S[]  = {
                        HOOK_ON,
                        HOOK_OFF,
                        };

                    /* Interpreter flag in Endpoint ID */

CONST   uchar INTERPRETER_AT5_S[]  = {
                        INTERPRETER_0,
                        INTERPRETER_1,
                        };

                    /* Number of Layer-protocol fields */

CONST   uchar LAYER_NB_AT5_S[]  = {
                        0,
                        1,
                        2,
                        };

                    /* Rate Adaptation Layer 1 protocol identifier for LLC IE */

CONST   uchar LLC_PROTOCOL_ID_1_RA_AT5_S[]  = {
                        PROTOCOL_ID_1_RA_I461,
                        PROTOCOL_ID_1_RA_NON_CCITT,
                        };

                    /* Cause location */

CONST   uchar LOCATION_AT5_S[]  = {
                        LOCATION_USER,
                        LOCATION_PR_NET_LOC_USER,
                        LOCATION_PU_NET_LOC_USER,
                        LOCATION_TRANSIT_NET,
                        LOCATION_PU_NET_REMOTE_USER,
                        LOCATION_PR_NET_REMOTE_USER,
                        LOCATION_INTERNATIONAL_NET,
                        };

CONST   uchar MAN_ERR_CODE_AT5_S[]  = {
                        MAN_ERR_UNSPECIFIED,
                        MAN_ERR_PROTOCOL_VIOLATION,
                        MAN_ERR_UNRECOGNIZED_OPERATION,
                        MAN_ERR_NON_SYN_NOT_SUPPORTED,
                        };
                    /* Module number */

CONST   uchar MODULE_NB_AT5_S[]  = {
                        MODULE_0,
                        MODULE_1,
                        MODULE_2,
                        MODULE_3,
                        MODULE_4,
                        MODULE_5,
                        MODULE_6,
                        MODULE_7,
                        };

                    /* Numbering plan */

CONST   uchar NB_PLAN_AT5_S[]  = {
                        PLAN_UNKNOWN,
                        PLAN_ISDN,
                        PLAN_PRIVATE,
                        };

                    /* Numbering type */

CONST   uchar NB_TYPE_AT5_S[]  = {
                        NB_UNKNOWN,
                        NB_INTERNATIONAL,
                        NB_NATIONAL,
                        NB_LOCAL,
                        NB_EXTENSION,
                        };

                    /* Operation class (MANAGMNT) */

CONST   uchar OP_CLASS_AT5_S[]  = {
                        UNCONFIRMED_OPERATION,
                        CONFIRMED_OPERATION,
                        RETURN_RESULT,
                        RETURN_RESULT_CONTINUED,
                        RETURN_ERROR,
                        REJECT,
                        };

                    /* Progress description */

CONST   uchar PROGRESS_DESCRIPTION_AT5_S[]  = {
                        PROGRESS_DESCR_NON_END_TO_END_ISDN,
                        PROGRESS_DESCR_NON_ISDN_DEST,
                        PROGRESS_DESCR_NON_ISDN_ORIG,
                        PROGRESS_DESCR_CALL_RETURNED_ISDN,
                        PROGRESS_DESCR_IN_BAND_NOW,
                        };

                    /* Progress location */

CONST   uchar PROGRESS_LOCATION_AT5_S[]  = {
                        PROGRESS_LOC_USER,
                        PROGRESS_LOC_PR_LOCAL_USER,
                        PROGRESS_LOC_PU_LOCAL_USER,
                        PROGRESS_LOC_TRANSIT_NET,
                        PROGRESS_LOC_PU_REMOTE_USER,
						PROGRESS_LOC_PR_REMOTE_USER,
						PROGRESS_BEYONG_IWP
                        };

                    /* Signal values */

CONST   uchar SIGNAL_VAL_AT5_S[]  = {
                        DIAL_ON,
                        RING_BACK_ON,
                        INTERCEPT_ON,
                        NET_CONGEST_ON,
                        BUSY_ON,
                        CONFIRM_ON,
                        ANSWER_ON,
                        CALL_WAITING_ON,
                        OFF_HOOK_WARNING_ON,
                        RECALL_DIAL_ON,
                        BUSY_VERIFY_ON,
                        ERROR_ON,
                        STUTTER_DIAL_ON,
                        EXPENSIVE_ROUTED_ON,
                        TONES_OFF,
                        PATTERN_0,
                        PATTERN_1,
                        PATTERN_2,
                        PATTERN_3,
                        PATTERN_4,
                        PATTERN_5,
                        PATTERN_6,
                        ALERTING_OFF,
                        UNSPECIFIED_TONE,
                        };

CONST   uchar STATUS_TYPE_AT5_S[]  = {
                        FEATURE_NUMBER_STATUS,
                        FEATURE_BUTTON_STATUS,
                        MULTIPLE_BUTTON_STATUS,
                        MAINTENANCE_STATUS,
                        };

                    /* Information  structure */

CONST   uchar STRUCTURE_AT5_S[]  = {
                        STRUCTURE_DEFAULT,
                        STRUCTURE_8KHZ_INT,
                        STRUCTURE_SDU_INT,
                        STRUCTURE_UNSTRUCTURED,
                        };

                    /* Symmetry */

CONST   uchar SYMMETRY_AT5_S[]  = {
                        BIDIRECTIONAL_SYMMETRY,
                        BIDIRECTIONAL_ASYMMETRY,
                        UNIDIRECTIONAL_ORIG_DEST,
                        UNIDIRECTIONAL_DEST_ORIG,
                        };

                    /* Asynchronous/synchronous */

CONST   uchar SYN_ASYN_AT5_S[]  = {
                        SYN,
                        ASYN,
                        };

                    /* Information transfer capability */

CONST   uchar TRF_CAP_AT5_S []  ={
                        TRF_CAP_SPEECH,
                        TRF_CAP_UNRESTRICTED,
                        TRF_CAP_RESTRICTED,
                        TRF_CAP_3_1_AUDIO,
                        };

                    /* Information transfer mode */

CONST   uchar TRF_MODE_AT5_S[]  = {
                        TRF_MODE_CIRCUIT,
                        TRF_MODE_PACKET,
                        };

                    /* User rate (V110) */

CONST   uchar USER_RATE_AT5_S[]  = {
                        RA_UNDEFINED,
                        RA_0_6KBS,
                        RA_1_2KBS,
                        RA_2_4KBS,
                        RA_3_6KBS,
                        RA_4_8KBS,
                        RA_7_2KBS,
                        RA_8KBS,
                        RA_9_6KBS,
                        RA_14_4KBS,
                        RA_16KBS,
                        RA_19_2KBS,
                        RA_32KBS,
                        RA_48KBS,
                        RA_56KBS,
                        };

/*=========================================================================*/

    /* Tables selected according to another value (indexed tables) */


        /* Cause value  according to the class */

            /* Normal event - class 000 */

CONST   uchar C_V_NORMAL_EVENT_0_AT5_S[]  = {
            C_C_NORMAL_EVENT_0,
            C_V_UNASSIGNED_NUMBER_1,
            C_V_NO_ROUTE_TO_TRANSIT_NET_2,
            };

            /* Normal event - class 001 */

CONST   uchar C_V_NORMAL_EVENT_AT5_S[]  = {
            C_C_NORMAL_EVENT,
            C_V_NORMAL_CLEARING_16,
            C_V_USER_BUSY_17,
			C_V_NO_USER_RESPONDING_18,
			C_V_NO_ANSWER_19,
            C_V_CALL_REJECT_21,
            C_V_NUMBER_CHANGED_22,
            C_V_INCOMPLETE_INFO_28,
            C_V_FACILITY_REJECT_29,
            C_V_RESPONSE_TO_STATUS_ENQUIRY_30,
            C_V_NORMAL_UNSPECIFIED_31,
            };

            /* Resource not available */

CONST   uchar C_V_RESOURCE_UNAVAILABLE_AT5_S[]  ={
            C_C_RESOURCE_UNAVAILABLE,
            C_V_NO_CIRCUIT_AVAILABLE_34,
            C_V_NETWORK_TEMPORARY_FAILURE_41,
            C_V_NETWORK_CONGESTION_42,
            C_V_ACCESS_INFORMATION_DISCARDED_43,
            };

            /* Service not available */

CONST   uchar C_V_SERVICE_NOT_AVAILABLE_AT5_S[]  = {
            C_C_SERVICE_NOT_AVAILABLE,
            C_V_REQUESTED_FAC_NOT_SUBSCRIBED_50,
            C_V_OUTGOING_CALLS_BARRED_52,
            C_V_INCOMING_CALLS_BARRED_54,
            C_V_BC_NOT_PRESENTLY_AVAILABLE_58,
                        };

            /* Service not implemented */

CONST   uchar C_V_SERVICE_NOT_IMPLEMENTED_AT5_S[]  = {
            C_C_SERVICE_NOT_IMPLEMENTED,
            C_V_BC_NOT_IMPLEMENTED_65,
            C_V_CHANNEL_TYPE_NOT_IMPLEMENTED_66,
            C_V_REQUESTED_FAC_NOT_IMPLEMENTED_69,
            };

            /* Invalid message */

CONST   uchar C_V_INVALID_MESSAGE_AT5_S[]  = {
            C_C_INVALID_MESSAGE,
            C_V_INVALID_CALL_REF_81,
            C_V_IDENTIFIED_CHANNEL_NOT_EXIST_82,
            C_V_INVALID_DIGIT_NB_85,
            C_V_INCOMPATIBLE_DESTINATION_88,
            C_V_INVALID_TRANSIT_NETWORK_SELECTION_91,
            };

            /* Protocol error */

CONST   uchar C_V_PROTOCOL_ERROR_AT5_S[]  = {
            C_C_PROTOCOL_ERROR,
            C_V_MANDATORY_IE_MISSING_96,
            C_V_MESSAGE_TYPE_NON_EXISTENT_97,
            C_V_MESSAGE_STATE_INCONSISTENCY_98,
            C_V_INVALID_IE_CONTENT_100,
            C_V_RECOVERY_ON_TIMER_EXPIRY_102,
            C_V_PROTOCOL_ERROR_UNSPECIFIED_111,
            };

            /* Interworking */

CONST   uchar C_V_INTERWORKING_AT5_S[]  = {
            C_C_INTERWORKING,
            C_V_INTERWORKING_UNSPECIFIED_127,
            };

/*-------------------------------------------------------------------------*/

            /* Information transfer rate according to the transfer mode */

CONST   uchar TRF_RATE_CIRCUIT_AT5_S[]  = {
                        TRF_MODE_CIRCUIT,
                        TRF_RATE_64KBS,
                        };

CONST   uchar TRF_RATE_PACKET_AT5_S[]  = {
                        TRF_MODE_PACKET,
                        TRF_RATE_PACKET_MODE,
                        };

/*-------------------------------------------------------------------------*/

			/* Layer identifier list for BC according to the transfer mode */

CONST   uchar LAYER_ID_CIRCUIT_AT5_S[]  = {
						TRF_MODE_CIRCUIT,
						LAYER_ID_1,
						};

CONST   uchar LAYER_ID_PACKET_AT5_S[]  = {
						TRF_MODE_PACKET,
						LAYER_ID_2,
						LAYER_ID_3,
						};

/*-------------------------------------------------------------------------*/

			/* Layer 1 protocol identifier for BC IE */

CONST   uchar BC_PROTOCOL_ID_1_AT5_S[]  = {
						LAYER_ID_1,
						PROTOCOL_ID_1_RA_I461,
						PROTOCOL_ID_1_G711_u,
						};

			/* Layer 2 protocol identifier for BC IE */

CONST   uchar BC_PROTOCOL_ID_2_AT5_S[]  = {
						LAYER_ID_2,
						PROTOCOL_ID_2_Q921,
						PROTOCOL_ID_2_X25_LL,
						};

			/* Layer 3 protocol identifier for BC IE */

CONST   uchar BC_PROTOCOL_ID_3_AT5_S[]  = {
						LAYER_ID_3,
						PROTOCOL_ID_3_X25_PL,
						};

/*-------------------------------------------------------------------------*/

			/* Layer 1 protocol identifier for LLC IE */

CONST   uchar LLC_PROTOCOL_ID_1_AT5_S[]  = {
                        LAYER_ID_1,
                        PROTOCOL_ID_1_RA_I461,
                        PROTOCOL_ID_1_G711_u,
                        PROTOCOL_ID_1_G711_A,
                        PROTOCOL_ID_1_G721,
                        PROTOCOL_ID_1_RA_NON_CCITT,
                        };

            /* Layer 2 protocol identifier for LLC IE */

CONST   uchar LLC_PROTOCOL_ID_2_AT5_S[]  = {
                        LAYER_ID_2,
                        PROTOCOL_ID_2_UNDEFINED,
                        PROTOCOL_ID_2_Q921,
                        PROTOCOL_ID_2_X25_LL,
                        };

            /* Layer 3 protocol identifier for LLC IE */

CONST   uchar LLC_PROTOCOL_ID_3_AT5_S[]  = {
                        LAYER_ID_3,
                        PROTOCOL_ID_3_UNDEFINED,
                        PROTOCOL_ID_3_Q931,
                        PROTOCOL_ID_3_X25_PL,
                        };

/*-------------------------------------------------------------------------*/
            /* Operation type for unconfirmed class */

CONST   uchar OP_TYPE_UNCONFIRMED_AT5_S[]  = {
                        UNCONFIRMED_OPERATION,
                        OP_TYPE_EV_REPORT,
                        };

            /* Operation type for confirmed class */

CONST   uchar OP_TYPE_CONFIRMED_AT5_S[]  = {
                        CONFIRMED_OPERATION,
                        OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for return result class */

CONST   uchar OP_TYPE_RETURN_RESULT_AT5_S[]  = {
                        RETURN_RESULT,
                        OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for return result continued class */

CONST   uchar OP_TYPE_RETURN_RESULT_2_AT5_S[]  = {
                        RETURN_RESULT_CONTINUED,
						OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for return error class */

CONST   uchar OP_TYPE_RETURN_ERROR_AT5_S[]  = {
                        RETURN_ERROR,
                        OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for reject class */

CONST   uchar OP_TYPE_REJECT_AT5_S[]  = {
                        REJECT,
                        OP_TYPE_DEFAULT,
                        };

/*-------------------------------------------------------------------------*/

            /* Management code for operation type = Action */

CONST   uchar MAN_CODE_ACTION_AT5_S[]  = {
                        OP_TYPE_ACTION,
                        MAN_CODE_ACTIVATE_LOOPBACK,
                        MAN_CODE_DEACTIVATE_LOOPBACK,
                        MAN_CODE_INIT_ERR_REPORTING,
                        MAN_CODE_TERMINATE_ERR_REPORTING,
                        MAN_CODE_DIAG_TEST,
                        MAN_CODE_RESET,
                        };

            /* Management code for operation type = Event report */

CONST   uchar MAN_CODE_EV_REPORT_AT5_S[]  = {
                        OP_TYPE_EV_REPORT,
                        MAN_CODE_INIT_RQ,
                        MAN_CODE_ENDPOINT_SERVICE_STATE,
                        MAN_CODE_ACTIVATE_LOOPBACK,
                        MAN_CODE_DEACTIVATE_LOOPBACK,
                        MAN_CODE_ERROR_REPORT,
                        MAN_CODE_DIAG_TEST_REPORT,
                        MAN_CODE_THRESHOLD_ALARM,
                        };

            /* Management code for operation type = Get */

CONST   uchar MAN_CODE_GET_AT5_S[]  = {
                        OP_TYPE_GET,
                        MAN_CODE_SERVICE_PROFILE_INFO,
                        MAN_CODE_ADD_INFO,
                        MAN_CODE_CALL_STATUS_INFO,
                        MAN_CODE_EQUIPMENT_INFO,
                        MAN_CODE_PERIPHERAL_INFO,
                        MAN_CODE_INTERFACE_INFO,
                        MAN_CODE_COUNTER_INFO,
                        };

            /* Management code for operation type = Set */

CONST   uchar MAN_CODE_SET_AT5_S[]  = {
                        OP_TYPE_SET,
                        MAN_CODE_SERVICE_PROFILE_INFO,
                        MAN_CODE_ADD_INFO,
                        MAN_CODE_CALL_STATUS_INFO,
                        MAN_CODE_EQUIPMENT_INFO,
                        MAN_CODE_PERIPHERAL_INFO,
                        MAN_CODE_INTERFACE_INFO,
                        MAN_CODE_COUNTER_INFO,
                        };

                    /* Channel selection according to interface type (ie CHAN_ID) */

CONST   uchar AT5_CHAN_SEL_BRI_S[] = {
                        INT_TYPE_BRI,
                        NO_CHAN,
                        B1_CHAN,
                        B2_CHAN,
                        ANY_CHAN,
                        };

CONST   uchar AT5_CHAN_SEL_PRI_S[] = {
                        INT_TYPE_PRI,
                        NO_CHAN,
                        AS_INDICATED,
                        CHAN_RESERVED,
                        ANY_CHAN,
                        };

/*-------------------------------------------------------------------------*/

        /*
           Meta description of the information elements.
           This description is  used to check an information element
           inside a message and to store its value into  the internal
           structure.
           In the other way it is used to generate the information element of
           a message from the internal structure.
        */


#define NS_INCLUDE_IE_META_FUNCTION		ON		/* include prototypes of functions inside mp_ie.at5 */

#include "at5.mp_ie"  /* include IE meta-programs */

uchar at5_chan_id_spdu ()
{

	if (direction == FROM_D_CHANNEL) {

		if (I_(chan_id,int_type) == INT_TYPE_BRI) {

			if (Na_type != BRI) return (NOK);

		} else {

			if (Na_type != PRI) return (NOK);
		}

	}

		/* Process PRI type chan_id */

	if (I_(chan_id,int_type) != INT_TYPE_BRI) {

		if ((I_(chan_id,chan_sel) == NO_CHAN) ||
			(I_(chan_id,chan_sel) == ANY_CHAN)) {
			ie_optional_octet = ON;
		}

		if (direction == FROM_D_CHANNEL) {
			return (r_exec_spdu_ie ((uchar *)&AT5_CHAN_ID_PRI_P));

		} else {

			return (s_exec_spdu_ie ((uchar *)&AT5_CHAN_ID_PRI_P));
		}

	}

	return (OK);

}

uchar at5_keypad_spdu ()
{
		/* Set the Call_keypad_in_setup flag if SETUP SPDU */

	if ((Call_current_exist) && (spdu_id == SETUP)) {

		Call_keypad_in_setup = ON;
	}

	return (OK);
}

/*-------------------------------------------------------------------------*/
uchar at5_bc_layer_nb_spdu ()
{

    ie_if_flag = OFF;

    if (direction == FROM_D_CHANNEL) {

            /* FROM D CHANNEL : set layer_nb to '2' if not end of BC IE */

        if (! Eo_ie) {
            I_(bc,Layer_nb) = 2;
            ie_if_flag = ON;
        }

    } else {
            /* TO D CHANNEL : continue the ie processing if layer_nb == 2 */

        if (I_(bc,Layer_nb) == 2) {
            ie_if_flag = ON;
        }
    }

    return (OK);
}

uchar at5_bc_is_layer_spdu ()
{

    ie_if_flag = ON;

    if (direction == TO_D_CHANNEL) {

        if (I_(bc,Layer_nb) == 0) {
            ie_if_flag = OFF;
        }

    } else {

        if (! Eo_ie) {
            I_(bc,Layer_nb) = 1;

        } else {

            I_(bc,Layer_nb) = 0;
            ie_if_flag = OFF;
        }
    }

    return (OK);
}

/*-------------------------------------------------------------------------*/

uchar at5_llc_4a_spdu ()
{

    ie_if_flag = ON;    /* (default value) : octets 4a and 4b may be present */

    if ((direction == TO_D_CHANNEL) &&
        (I_(llc,structure) == STRUCTURE_DEFAULT ||
        (I_(llc,structure) == STRUCTURE_8KHZ_INT        && I_(llc,trf_mode) == TRF_MODE_CIRCUIT) ||
        (I_(llc,structure) == STRUCTURE_SDU_INT         && I_(llc,trf_mode) == TRF_MODE_PACKET)) &&
        (I_(llc,symmetry)  == BIDIRECTIONAL_SYMMETRY)   &&
        (I_(llc,dest_rate) == I_(llc,trf_rate))) {

        /* default values for octets 4a and 4b : they are omitted */

        ie_if_flag = OFF;
    }

    return (OK);

}

uchar at5_llc_4b_spdu ()
{

    ie_if_flag = ON;    /* (default value) : octet 4b may be present */

    if ((direction == TO_D_CHANNEL) &&
        (I_(llc,symmetry) == BIDIRECTIONAL_SYMMETRY) &&
        (I_(llc,dest_rate) == I_(llc,trf_rate))) {

        /* default values for octet 4b : it is omitted */

        ie_if_flag = OFF;
    }

    return (OK);

}

uchar at5_llc_spdu()
{

        /* check the integrity between transfer capability and transfer rate. */

    if ( (I_(llc,trf_cap) == TRF_CAP_RESTRICTED) && (I_(llc,trf_rate) != TRF_RATE_64KBS) ) {
        return (NOK);
    }

        /* set default values in i_llc according to the structure and
           transfer mode fields (for incoming SPDU only). */

    if (direction == FROM_D_CHANNEL) {

            /* set default information transfer rate in octet 4b. */

        I_(llc,dest_rate) = I_(llc,trf_rate);

            /* if default structure integrity then set the right default value. */

        if (I_(llc,structure) == STRUCTURE_DEFAULT) {

            if (I_(llc,trf_mode) == TRF_MODE_PACKET) {
                I_(llc,structure) = STRUCTURE_SDU_INT;

            } else {

                I_(llc,structure) = STRUCTURE_8KHZ_INT;
            }
        }
    }

    return (OK);
}

uchar at5_llc_layer_nb_spdu ()
{

    ie_if_flag = OFF;

    if (direction == FROM_D_CHANNEL) {

            /* FROM D CHANNEL : set layer_nb to '2' if not end of BC IE */

        if (ie_end_found == OFF) {
            I_(llc,Layer_nb) = 2;
            ie_if_flag = ON;
        }

    } else {

            /* TO D CHANNEL : continue the ie processing if layer_nb == 2 */

        if (I_(llc,Layer_nb) == 2) {
            ie_if_flag = ON;
        }
    }

    return (OK);
}
/*-------------------------------------------------------------------------*/

uchar at5_spdu_man_parameters ()
{

    uchar   last_param_id           = 0;                    /* last parameter id backup up */
    uchar   recognized_parameter    = OFF;                  /* to know if at least one parameter has been recognized */
    uchar   counter                 = I_man_param_counter;  /* local counter */

    if (direction == FROM_D_CHANNEL) {
        I_man_param_counter = 0;        /* initialize the parameter counter */

        if (Eo_ie) {

                /* if there is no param, then process the message */

            recognized_parameter = ON;
        }

        while (!Eo_ie) {
            I_man_param_id = Get_bits (Get_ie_octet, 0, 7);

                /* check parameters sequence order */

            if (I_man_param_id <= last_param_id) {
                return (NOK);

            } else {

                last_param_id = I_man_param_id;
            }

            if (Get_bits (Get_inc_ie_octet, EXT_POSITION, EXT_LGTH) == EXT_LAST) {
                I_man_param_lgth = Get_inc_ie_octet;

                switch (I_man_param_id) {

                    case PARAM_SPID :
                        if (check_convert ( (uchar FAR *) I_man_param_a_spid,
                                            (uchar FAR *) Get_p_ie,
                                            I_man_param_lgth,
                                            IA5, ANY_CHAR
                                          ) != OK ) return (NOK);
                        p_ie += I_man_param_lgth;
                        recognized_parameter = ON;          /* to know that one parameter has been recognized */
                        break;

                    case PARAM_ENDPOINT_ID :
                        I_man_param_usid (I_man_param_counter)  = Get_inc_ie_octet;
                        I_man_param_tid (I_man_param_counter)   = Get_bits (Get_ie_octet, 0, 7);
                        I_man_param_esf (I_man_param_counter)   = Get_bits (Get_inc_ie_octet, 7, 1);
                        recognized_parameter = ON;          /* to know that one parameter has been recognized */
                        break;

                    default :

                            /* ignore parameter and point on the next one */

                        Inc_p_ie (I_man_param_lgth);
                        break;

                }

                I_man_param_counter++;
            }

        }

        if (recognized_parameter == OFF) {
            return (NOK);
        }

    } else {

		I_man_param_counter = 0;

        while (counter > I_man_param_counter) {
            *p_ie = 0;
            Put_ie_field (0, 7, I_man_param_id);

                /* check parameters sequence order */

            if (I_man_param_id <= last_param_id) {
                return (NOK);

            } else {

                last_param_id = I_man_param_id;
            }

            switch (I_man_param_id) {

                case PARAM_SPID :
                    Put_ie_field (EXT_POSITION, EXT_LGTH, EXT_LAST);
                    Inc_p_ie (1);
                    Put_inc_ie_octet (I_man_param_lgth);

                    if (check_convert ( (uchar FAR *) Get_p_ie,
                                        (uchar FAR *) I_man_param_a_spid,
                                        I_man_param_lgth,
                                        IA5, ANY_CHAR
                                      ) != OK ) return (NOK);
                    Inc_p_ie (I_man_param_lgth);
                    break;

                case PARAM_ENDPOINT_ID :
                    Put_ie_field (EXT_POSITION, EXT_LGTH, EXT_LAST);
                    Inc_p_ie (1);
                    Put_inc_ie_octet (I_man_param_lgth);
					Put_inc_ie_octet (I_man_param_usid (I_man_param_counter));
/*					Put_ie_field (0, 7, I_man_param_tid (I_man_param_counter)); */
					*p_ie = I_man_param_tid (I_man_param_counter);
					Put_ie_field (7, 1, I_man_param_esf (I_man_param_counter));
                    Inc_p_ie (1);
                    break;

                default :

                        /* ignore parameter content for the moment */

                    Put_ie_field (EXT_POSITION, EXT_LGTH, EXT_LAST);
                    Inc_p_ie (1);
                    break;

            }
            I_man_param_counter++;

        }

    }

    return (OK);
}

/*-------------------------------------------------------------------------*/

#define Ns_at5_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_at5_end_table_or_function		};
#define Ns_at5_tab_tabl_entry(idx, tab)		Ns_tab_tabl_entry (idx, tab),
#define Ns_at5_tabx_list_entry(tab)			Ns_tabx_list_entry (tab),
#define Ns_at5_tab_tabx_entry(idx, tab)		Ns_tab_tabx_entry (idx, tab),

#define Ns_at5_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx)	\
			Ns_tab_ie_entry (codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, 0),

#define Ns_at5_tab_ie_no_i_str(codes, ie, mx)	{codes, ie, A_NIL, 0, A_NIL, A_NIL, A_NIL, mx, 0},
#define Ns_at5_tab_ie_msg_header			{CODESET_NIL, MESSAGE_HEADER, (uchar *)A_NIL, sizeof(struct i_message_header), (uchar *)Pic_address (&i_message_header), (uchar *)A_NIL, (uchar *)A_NIL, 1, 0},

#include "at5.tab_ie"		/* include other Tables describing the IEs */

#define AT5_MX_TABL (Rnd_sizeof(AT5_TAB_TABL)/Rnd_sizeof (struct tabl))
CONST   uchar   at5_size_tab_tabl = AT5_MX_TABL;

#define AT5_MX_TABX (Rnd_sizeof(AT5_TAB_TABX)/Rnd_sizeof (struct tabx))
CONST   uchar   at5_size_tab_tabx = AT5_MX_TABX;

CONST   uchar   at5_size_tab_ie = Rnd_sizeof (AT5_TAB_IE) / IE_ELEM_SIZE;   /* maximum number of item in the table */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if AT5_SUPPLEMENTARY_SERVICES == ON /*{*/

#   if NEW_FCT_STYLE == ON
        uchar   at5_check_1_254_spdu    (uchar FAR * p_i_field);
        uchar   at5_check_sca_spdu      (uchar FAR * p_i_field);
#   else
        uchar   at5_check_1_254_spdu    ();
        uchar   at5_check_sca_spdu      ();
#   endif

/*------------------------------------------------------------------------*/

uchar   at5_dest_call_appear_spdu ()        /* test for value between 1 and 254 */
{
    return (at5_check_1_254_spdu (&(I_dest_call_appear_button_nb)));

}

/*------------------------------------------------------------------------*/

uchar   at5_feature_act_spdu ()             /* test for value between 1 and 254 */
{
    return (at5_check_1_254_spdu (&(I_feature_act_button_nb)));
}

/*------------------------------------------------------------------------*/

uchar   at5_feature_ind_init_spdu ()        /* init flag for MBS */
{
    I_feature_ind_i_flag = ON;
    I_feature_ind_i_counter_spdu = 0;
    return (OK);
}

/*------------------------------------------------------------------------*/

uchar   at5_feature_ind_spdu ()
{
    switch (I_feature_ind_status_type) {

        case FEATURE_NUMBER_STATUS :

            if ((Get_ie_octet == 0) || (Get_ie_octet == 253) || (Get_ie_octet == 255)) return (NOK);
            I_feature_ind_feature_spdu = Get_inc_ie_octet;

                /* implicit check : indicatore is coded 000 */

            switch (Get_ie_octet) {
                case STATUS_ACTIVATED :
                case STATUS_DEACTIVATED :
                case STATUS_PENDING :
                case STATUS_LOCAL_HOLD :
                case STATUS_REMOTE_HOLD :
                case STATUS_CONFIRMED :
                case STATUS_ALREADY_IN_RQ_STATE :
                case STATUS_REJECTED :
                    I_feature_ind_status_spdu = Get_inc_ie_octet;
                    break;
                default :
                    return (NOK);
            }

            if (Eo_ie) return (OK);
            if (++I_feature_ind_i_counter_spdu >= 84)   return (NOK);
            return (at5_feature_ind_spdu ());

        case FEATURE_BUTTON_STATUS :

            if (at5_check_1_254_spdu (&(I_feature_ind_feature_spdu)) != OK) return (NOK);

            switch (Get_bits (Get_ie_octet,5,3)) {
                case INDICATOR_0 :
                case INDICATOR_1 :
                case INDICATOR_2 :
                case INDICATOR_3 :
                    I_feature_ind_indicator_spdu = Get_bits (Get_ie_octet,5,3);
                    break;
                default :
                    return (NOK);
            }

            switch (Get_bits(Get_ie_octet,0,5)) {
                case STATUS_ACTIVATED :
                case STATUS_DEACTIVATED :
                case STATUS_PENDING :
                case STATUS_LOCAL_HOLD :
                case STATUS_REMOTE_HOLD :
                case STATUS_CONFIRMED :
                case STATUS_ALREADY_IN_RQ_STATE :
                case STATUS_REJECTED :
                    I_feature_ind_status_spdu = Get_bits (Get_ie_octet,0,5);
                    Inc_p_ie (1);
                    break;
                default :
                    return (NOK);
            }

            if (Eo_ie) return (OK);
            if (++I_feature_ind_i_counter_spdu >= 84)   return (NOK);
            return (at5_feature_ind_spdu ());

        case MULTIPLE_BUTTON_STATUS :

            if (I_feature_ind_i_flag == ON) {
                I_feature_ind_i_flag = OFF;
                if (at5_check_1_254_spdu (&(I_feature_ind_starting_feature)) != OK) return (NOK);
                if (at5_check_1_254_spdu (&(I_feature_ind_number_of_button)) != OK) return (NOK);
            }

            I_feature_ind_status_spdu = Get_inc_ie_octet;

            if (Eo_ie) return (OK);
            if (++I_feature_ind_i_counter_spdu >= 252)  return (NOK);
            return (at5_feature_ind_spdu ());

        case MAINTENANCE_STATUS :
			return (r_exec_spdu_ie ((uchar *)&AT5_FEATURE_IND_MS_SPDU));

        default :
            return (NOK);
    }
}

/*------------------------------------------------------------------------*/

uchar   at5_ori_call_appear_spdu ()         /* test for value between 1 and 254 */
{
    return (at5_check_1_254_spdu (&(I_ori_call_appear_button_nb)));
}

/*------------------------------------------------------------------------*/

uchar   at5_sel_call_appear_spdu ()         /* test for value between 0 and 254 from D channel */
{

	struct call FAR *p_call_sav;

	ret_code = (at5_check_sca_spdu  (&(I_sel_call_appear_button_nb)));

	if (ret_code == OK) {

		Dl_button_net 		= I_sel_call_appear_button_nb;
		p_call_sav = p_call;

		if (Dl_button_p_call != P_NIL) {

				/* Get the saved call */

			p_call = (struct call FAR *) Dl_button_p_call;

				/* Reset the button table */

			Dl_button_p_call = P_NIL;

				/* Send the previous SETUP */

			Send_saved_spdu_to_d_channel (SETUP);

				/* The saved SPDU is no more useful */

			Release_saved_spdu ();

				/*
				 * The network ackowledged our "button" request
				 * so T300 may be stoped
				 */

			Stop_timer_ns (AT5_T300);

				/* Start 303 */

			Start_timer_ns (AT5_T303);

				/* Go to State 1 */

			Set_state (STATE_CALL_INIT_1);

				/* p_call is useless */

			p_call = P_NIL;

		}

		p_call = p_call_sav;
	}

	return (ret_code);

}

/*------------------------------------------------------------------------*/

uchar   at5_check_1_254_spdu (p_i_field)    /* test for value between 1 and 254 */
	uchar FAR * p_i_field;
{
	uchar   code;           /* code */

	if (direction == FROM_D_CHANNEL) {

		code = Get_inc_ie_octet;

		if (code > 0 && code < 255) {
			*p_i_field = code;
            return (OK);

        } else {

            return (NOK);
        }

    } else {

            /* from CALL_CONTROL - check done at the receipt of the ssdu */

        if ((*p_i_field == 0) || (*p_i_field == 255)) return (NOK);
        Put_inc_ie_octet (*p_i_field);
        return (OK);
    }

}

/*------------------------------------------------------------------------*/

uchar   at5_check_sca_spdu (p_i_field)
    uchar FAR * p_i_field;
{
    uchar   code;           /* code */

    if (direction == FROM_D_CHANNEL) {

        code = Get_inc_ie_octet;

        if (code < 255) {       /* network may send Null Call Appearance */
            *p_i_field = code;
            return (OK);

        } else {

            return (NOK);
        }

    } else {

            /* from CALL_CONTROL - check done at the receipt of the ssdu */

        if ((*p_i_field == 0) || (*p_i_field == 255)) return (NOK);
        Put_inc_ie_octet (*p_i_field);
        return (OK);
    }

}

/*------------------------------------------------------------------------*/

uchar at5_call_ref_to_conn_id ()
{
    struct call *p_save_call;
    uchar        lgth;
    uchar        ret = OK;

        /* save internal call reference */

    I_call_ref_sav      = I_call_ref;
    I_call_ref_lgth_sav = I_call_ref_lgth;
    p_save_call         = p_call;
    I_call_ref          = CALL_REF_NIL;     /* default conn_id is CONN_ID MANAGMNT */

        /*
           Call reference length according to network access rate interface.
           Init i_call_ref (internal call reference value).
        */

    Dec_p_ie(1);                /* position to call reference length */
    I_call_ref_lgth = Get_inc_ie_octet;

    if (Na_type == BRI) {

        if ((I_call_ref_lgth < Spdu_param_call_ref_lgth_bri_min) || (I_call_ref_lgth > Spdu_param_call_ref_lgth_bri_max)) {
            ret     = NOK;
        }

    } else {

        if ((I_call_ref_lgth < Spdu_param_call_ref_lgth_pri_min) || (I_call_ref_lgth > Spdu_param_call_ref_lgth_pri_max)) {
            ret     = NOK;
        }

    }

    if  ( !(Is_call_ref_nil) && (ret == OK) ) {

            /* Load internal call reference */

        lgth    = I_call_ref_lgth;
        I_call_ref = ((Get_ie_octet >> 7) ^ 1) + ((Get_ie_octet & Mask (7)) << 1);
        Inc_p_ie (1);

        while (--lgth != 0) {
            I_call_ref += Get_inc_ie_octet << (lgth * 8);
        }

#	if EQUIPMENT == NT2

	/*
		Internal call ref takes into account the DL CES for incoming calls
		because the same call ref may be used on different DL connections.
	*/

		if (Na_fct == FG_NT_TE) {

			if (!Is_call_ref_outgoing_call) {

				Ns_concat_ces_and_call_ref (R_msg_ces);
			}
		}

#	endif

            /* search actif call with call reference */

        if ( (ret = ns_access_call_ref (I_call_ref)) == OK) {

                /* load associated Conn_id if actif call found */

            I_other_call_ref_conn_id = Call_conn_id;
        }
    }

        /* restore call context */

    p_call = p_save_call;

        /* restore internal call reference */

    I_call_ref      = I_call_ref_sav;
	I_call_ref_lgth = I_call_ref_lgth_sav;
	return (ret);
}

#endif      /* SUPPLEMEMENTARY_SERVICES} */

/*-------------------------------------------------------------------------*/

#if OM_CODE_TYPE == OM_PIC /* PIC used{ */

#undef Ns_at5_table_or_function
#undef Ns_at5_end_table_or_function
#undef Ns_at5_tab_tabl_entry
#undef Ns_at5_tabx_list_entry
#undef Ns_at5_tab_tabx_entry
#undef Ns_at5_tab_ie_entry
#undef Ns_at5_tab_ie_no_i_str
#undef Ns_at5_tab_ie_msg_header

#define Ns_at5_table_or_function(str, tab)	i_pic = 0;						\
											{								\
												struct str FAR	*p_table;	\
												p_table = tab;

#define Ns_at5_end_table_or_function		}

#define Ns_at5_tab_tabl_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_val, (uchar *)tab);
#define Ns_at5_tabx_list_entry(tab)			Pic_init_struct_array_next (p_table,  p_val, (uchar	*)tab);
#define Ns_at5_tab_tabx_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_tab, (struct tabx_list *)tab);

#define Ns_at5_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx)	\
	Pic_init_struct_array (p_table,  i_pic, p_prog, (uchar	*)mp_a);		\
	Pic_init_struct_array (p_table,  i_pic, p_i_struct, (uchar	*)i_str);	\
	Pic_init_struct_array (p_table,  i_pic, p_init_spdu, (uchar	*)df_spdu);	\
	Pic_init_struct_array_next (p_table,  p_init_ssdu, (uchar	*)df_ssdu);

#define Ns_at5_tab_ie_no_i_str(codes, ie, mx)	Ns_at5_tab_ie_entry (0, 0, P_NIL, P_NIL, P_NIL, P_NIL, 0)

#define Ns_at5_tab_ie_msg_header		Ns_at5_tab_ie_entry (0, 0, P_NIL, &i_message_header, P_NIL, P_NIL, 0)

		/*	Function used to initialize address fields in Tables above */

void pic_init_ns_at5_ie ()
{
	uchar	i_pic;			/* current index */

#	include "at5.tab_ie"
}

#endif /* end of PIC used} */


/*EOF*/
