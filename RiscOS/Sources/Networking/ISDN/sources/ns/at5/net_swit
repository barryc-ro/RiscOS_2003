
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_swit.at5
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s) ATT_5E5 switch :
 *
 *      csc_dl_reinit			- implement an unexpected data link reinit.
 *
 *		circuit_switched_call	- implements the processing of the call
 *		                          control procedures.
 *
 *		fco_hcdt				- implements supplementary services
 *                                procedures.
 *
 *      ns_ei 					- implements the endpoint initialization
 *                                procedure for the ATT 5E5 control of
 *                                maintenance actions.
 *
 *		circuit_switched_call_n - implements the processing of the call
 *		                          control procedures (network side).
 *
 *		send_mim				- load the MIE i_managmnt internal structure
 *								  and then send the MIM.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

						/*----------------*/
						/*                */
						/*   USER SIDE    */
						/*                */
						/*----------------*/


					/* FUNCTIONS DECLARATION */

#if NEW_FCT_STYLE == ON
	uchar send_mim				(uchar);
	uchar access_i_man_param	(uchar);
#else
	uchar send_mim				();
	uchar access_i_man_param	();
#endif

#if NEW_FCT_STYLE == ON
	void	at5_u0						(void);
	void	at5_u1						(void);
	void	at5_u2						(void);
	void	at5_u3						(void);
	void	at5_u4						(void);
	void	at5_u6						(void);
	void	at5_u7						(void);
	void	at5_u8						(void);
	void	at5_u9						(void);
	void	at5_u10						(void);
	void	at5_u11						(void);
	void	at5_u12						(void);
	void	at5_u19						(void);
	void	at5_csc_dl_reinit			(void);
	uchar	at5_circuit_switched_call	(void);
	uchar	at5_error_handler			(void);
	uchar	at5_ns_ei					(code_t p1, ces_t p2);
	uchar	at5_match_usid_tid 			(uchar usid, uchar tid, uchar interp);
#else
	void	at5_u0						();
	void	at5_u1						();
	void	at5_u2						();
	void	at5_u3						();
	void	at5_u4						();
	void	at5_u6						();
	void	at5_u7						();
	void	at5_u8						();
	void	at5_u9						();
	void	at5_u10						();
	void	at5_u11						();
	void	at5_u12						();
	void	at5_u19						();
	void	at5_csc_dl_reinit			();
	uchar	at5_circuit_switched_call	();
	uchar	at5_error_handler			();
	uchar	at5_ns_ei					();
	uchar	at5_match_usid_tid 			();
#endif


					/* LOCAL MACROS */


#define	Rcv_dl_code			R_msg_inf0

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	at5_csc_dl_reinit () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN).

Usage           	void at5_csc_dl_reinit ();

Related
functions usage		void send_state (uchar class, uchar value, uchar diagnostic);

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA

*--------------------------------------------------------------------------*/

void at5_csc_dl_reinit ()
{
	/* nothing to do */
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            circuit_switched_call - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage          	uchar circuit_switched_call ();

Related
functions usage void u0 .... u19 ()

Description     circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value    uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

/*                                CLEARING PROCEDURES
*
*       TE                         NT/NETWORK                        TE
* _________________             _________________            _________________
* |               |             |               |            |               |
* |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
* |==========>....|------------>|.......|.....  |            |               |
* | start T305    |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
* |<===========...|<------------|...    |    ...|----------->|...===========>|
* |  stop T305  . |             |start T308     |            |    NS_CLEAR_RS|
* |             . | DA_DISC_COMP|     start T305|     REL    |  .<===========|
* |             ..|------------>|       |    ...|<-----------|...  start T308|
* |               |             |       |    .  |            |               |
* |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
* |               |             |       |    ...|----------->|...===========>|
* |               |             |       |       |            |     stop T308 |
* |---------------|             |---------------|            |---------------|
*
*/

uchar at5_circuit_switched_call ()
{

		/*
			Information messages used with the null call reference
			for terminal management
		*/

	if (Is_call_ref_nil) {

		switch (event_id) {

#			if (AT5_SUPPLEMENTARY_SERVICES == ON) && (AT5_TERMINAL_MANAGEMENT == ON)

			case DA_INFO :

				if (Na_subscription_tm != OFF) {

					Send_to_call_control (NS_SPF_FACILITY_CO);

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case NS_INFO_RQ :

				if (Na_subscription_tm != OFF) {

					if (is_ie_i (CODESET_0, SWITCHHOOK) == PRESENT) {

						if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
							Trap (TRAP_NO_CES, "ns_snd_dl");
						}

						Dl_button_internal	= ON;
						Dl_button_user 		= BYTE_VAL_NIL;
					}

					if (is_ie_i (CODESET_6, FEATURE_ACT) == PRESENT) {

						if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
							Trap (TRAP_NO_CES, "ns_snd_dl");
						}

						Dl_button_internal	= ON;
						Dl_button_user 		= I_feature_act_button_nb;
					}

					Send_to_d_channel (INFO);

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#			endif

			default :
				return (NOK);
		}

	}

		/*
			ENDPOINT INITIALIZATION PROCEDURES
		*/

	switch (i_entity_origination) {

		case ENT_DL_D :			/* from network event */

			if (event_id == DA_MAN_INFO) {

					/* Set MIM event ID */

				if	( (I_man_op_class	== UNCONFIRMED_OPERATION)	&&
					  (I_man_op_type	== OP_TYPE_EV_REPORT)		&&
					  (I_man_code		== MAN_CODE_INIT_RQ) )		{
					Ns_ei (EV_INIT_RQ, Na_dl_ces);				/* call to Endpoint Initialization Procedure */
				} else

				if ( (I_man_op_class	== CONFIRMED_OPERATION)	&&
					 (I_man_op_type		== OP_TYPE_SET)			&&
					 (I_man_code		== MAN_CODE_ADD_INFO) )	{
					Ns_ei (EV_ASSIGN_USID_TID, Na_dl_ces);		/* call to Endpoint Initialization Procedure */
				} else

				if ( (I_man_op_class	== REJECT)	&&
					 (I_man_op_type		== OP_TYPE_DEFAULT) )	{
					Ns_ei (EV_REJECT, Na_dl_ces);				/* call to Endpoint Initialization Procedure */

				} else

				if ( (I_man_op_class	== CONFIRMED_OPERATION)	&&
					 (I_man_op_type		== OP_TYPE_GET) )	{
					Ns_ei (EV_GET, Na_dl_ces);				/* call to Endpoint Initialization Procedure */

				} else {

					Ns_ei (EV_NO_USID_TID, Na_dl_ces);
				}

				return (OK);

			}

			if (is_ie_i (CODESET_6, AT5_ENDPOINT_ID) == ABSENT) {

					/* Any message with no USID-TID */

				if (Ns_ei (EV_NO_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			} else if (Dl_ces == DL_CES_BROADCAST) {

					/* Any broadcast message with USID-TID */

				if (Ns_ei (EV_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			} else {

					/* Any broadcast message with USID-TID */

				if (Ns_ei (EV_NOT_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			}
			break;

		case ENT_CC :		/* from user event */

				/* User action */

			if (Ns_ei (EV_USER_ACTION, DL_CES_SIG) != CONTINUE) {
				return (OK);
			}
			break;

		default :
			break;

	}


					/* 1 - EVENT DRIVEN PROCESSING  */

	switch (event_id) {

							/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

		case DA_STATUS :
			return (OK);

							/* SETUP */

		case DA_SETUP :

			if (allocate_call (INCOMING_CALL, 0) == NOK) {
				Reset_internal_ie ();
				set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
				Send_to_d_channel (REL_COMP);
				return (OK);
			}

			break;

							/* DISCONNECT */

		case DA_DISC :

			switch (Call_state) {

				case STATE_DISCONNECT_REQUEST_11 :
					Stop_timer_ns (AT5_T305);
					break;

				case STATE_DISCONNECT_INDICATION_12 :
				case STATE_RELEASE_REQUEST_19 :
					ns_unexpected_ev ();
					break;

				default :
					ns_stop_all_timers ();
					Send_to_call_control (NS_CLEAR_IN);			/* send NS clear to Call Control */
					Set_state (STATE_DISCONNECT_INDICATION_12);	/* enter disconnect request state */
			}

			return (OK);

							/* RELEASE */

		case DA_REL :

			switch (Call_state) {

				case STATE_RELEASE_REQUEST_19 :
					ns_unexpected_ev ();
					break;

				default :
					Send_to_call_control (NS_CLEAR_CO);		/* send NS clear confirm to Call Control */
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);			/* send the Release Complete Message to network */
					call_clear ();							/* free call context */
			}
			return (OK);

							/* RELEASE COMPLETE */

		case DA_REL_COMP :
			Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Call Control */
			call_clear ();									/* free call context */
			return (OK);

							/* STATUS */

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			set_i_state (Call_state);
			Send_to_d_channel (STATUS);
			return (OK);

							/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			switch (Call_state) {

				case STATE_WAIT_DL :
					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					return (OK);

				case STATE_CALL_PRESENT_6 :

					if (! ((is_ie_i (CODESET_0, CAUSE) == PRESENT) &&
						   (I_cause_class == C_C_NORMAL_EVENT)     &&
						   (I_cause_val   == C_V_NO_ANSWER_19))
					   ) {

						Send_to_d_channel (REL_COMP);
					}

					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					break;

				case STATE_DISCONNECT_INDICATION_12 :
					disc_cause_error ();
					Stop_timer_ns  (AT5_T300);
					go_to_state_19 (AT5_T308);
					break;

#			if AT5_SUPPLEMENTARY_SERVICES == ON

				case SUB_STATE_34 :
					ns_unexpected_ev ();
					break;

#				if AT5_KEY_SYSTEM_FEATURE == ON

				case STATE_OUTGOING_CALL_PROC_3 :
				case STATE_CALL_DELIVERED_4 :
				case STATE_ACTIVE_10 :

					if (Na_subscription_key != OFF) {
						Call_sub_state = Call_state;
					}

#				endif

#			endif

				default :
					ns_stop_all_timers ();

					if (is_ie_i (CODESET_0, CAUSE) == ABSENT) {
						ie_implicit_val_x (CODESET_0, CAUSE, 0);	/* init implicit value */
					}

					Save_cause ();									/* to send the RELEASE if T305 expire */
					Send_to_d_channel (DISC);						/* send a DISCONNECT message */
					Start_timer_ns	(AT5_T305);								/* start T305 */
					Set_state (STATE_DISCONNECT_REQUEST_11); 		/* enter the Disconnect Request state */

			}

			return (OK);

	} /* End switch (event_id) */

/*.........................................................................*/

						/* 2 - STATE DRIVEN PROCESSING */

			/*
					 Switch according to the call state :

			   Dispatch to the function that processes the state except if
			   it is a clearing event not received  in an exceptional condition.
			   In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "at5_circuit_switched_call");
	}

	switch (Call_state) {

			/* Null state (u0) */

		case STATE_NULL_0 :
		case STATE_WAIT_DL :
			at5_u0 ();
			break;

			/* Call initiated (u1) */

		case STATE_CALL_INIT_1 :
			at5_u1 ();
			break;

			/* Overlap sending (u2) */

		case STATE_OVERLAP_SENDING_2 :
			at5_u2 ();
			break;

			/* Outgoing call proceeding (u3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			at5_u3 ();
			break;

			/* Call delivered (u4) */

		case STATE_CALL_DELIVERED_4 :
			at5_u4 ();
			break;

			/* Pseudo Call present - fictive state (u6) */

		case STATE_CALL_PRESENT_6 :
			at5_u6 ();
			break;

			/* Call received (u7) */

		case STATE_CALL_RECEIVED_7 :
			at5_u7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			at5_u8 ();
			break;

			/* Incoming call proceeding (u9) */

		case STATE_INCOMING_CALL_PROC_9 :
			at5_u9 ();
			break;

			/*  Active (u10) */

		case STATE_ACTIVE_10 :
			at5_u10 ();
			break;

			/* Disconnect request (u11) */

		case STATE_DISCONNECT_REQUEST_11 :
			at5_u11 ();
			break;

			/* Disconnect indication (u12) */

		case STATE_DISCONNECT_INDICATION_12 :
			at5_u12 ();
			break;

			/* Release request (u19) */

		case STATE_RELEASE_REQUEST_19 :
			at5_u19 ();
			break;

#		if AT5_SUPPLEMENTARY_SERVICES == ON

		case SUB_STATE_34 :
			ns_unexpected_ev ();
			break;

#		endif

			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "at5_circuit_switched_call");

	}

	return (OK);

}

#if AT5_SUPPLEMENTARY_SERVICES == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            fco_hcdt -	implements flexible call offering and HCDT
							services procedures.
Usage           void fco_hcdt (void);

Return value    no return code

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

void fco_hcdt ()
{
	uchar error_flag = ON;

	if (Na_subscription_fco_hcdt != OFF) {

		switch (event_id) {

			case NS_SPF_FACILITY_RQ :

				switch (I_service_id) {

					case DA_HOLD :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (AT5_HOLD);
							Call_sub_state = Sub_state_hold_rq ();
							error_flag = OFF;
						}
						break;

					case DA_RECONN :

						if (Call_sub_state == Sub_state_call_on_hold ()) {
							Send_to_d_channel (AT5_RECONN);
							Call_sub_state = Sub_state_reconn_rq ();
							error_flag = OFF;
						}
						break;

					case DA_DROP :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (DROP);
							Call_sub_state = SUB_STATE_35;
							error_flag = OFF;
						}
						break;

					case DA_CONF :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (CONF);
							Call_sub_state = SUB_STATE_32;
							error_flag = OFF;
						}
						break;

					case DA_TRANS :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (TRANS);
							Call_sub_state = SUB_STATE_31;
							error_flag = OFF;
						}
						break;

					default :
						break;
				}
				break;

			case DA_HOLD_ACK :

				if ((Call_state == STATE_ACTIVE_10)  ||
					(Call_sub_state == SUB_STATE_31) ||
					(Call_sub_state == SUB_STATE_32) ||
					(Call_sub_state == Sub_state_hold_rq ())) {
					Call_sub_state = Sub_state_call_on_hold ();
					I_service_id = DA_HOLD_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					error_flag = OFF;
				}
				break;

			case DA_HOLD_REJ :

				if ((Call_state == STATE_ACTIVE_10)  ||
					(Call_sub_state == SUB_STATE_31) ||
					(Call_sub_state == SUB_STATE_32) ||
					(Call_sub_state == Sub_state_hold_rq ())) {
					I_service_id = DA_HOLD_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_RECONN_ACK :

				if (Call_sub_state == Sub_state_reconn_rq ()) {
					I_service_id = DA_RECONN_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_RECONN_REJ :

				if (Call_sub_state == Sub_state_reconn_rq ()) {
					I_service_id = DA_RECONN_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = Sub_state_call_on_hold ();
					error_flag = OFF;
				}
				break;

			case DA_TRANS_ACK :

				if (Call_sub_state == SUB_STATE_31) {
					I_service_id = DA_TRANS_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Set_state (SUB_STATE_34);
					error_flag = OFF;
				}
				break;

			case DA_TRANS_REJ :

				if (Call_sub_state == SUB_STATE_31) {
					I_service_id = DA_TRANS_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state =SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_CONF_ACK :

				if (Call_sub_state == SUB_STATE_32) {
					I_service_id = DA_CONF_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);

					if (I_other_call_ref_conn_id != Call_conn_id) {
						Set_state (SUB_STATE_34);

					} else {

						Call_sub_state = SUB_STATE_NULL_0;
					}

					error_flag = OFF;
				}

				break;

			case DA_CONF_REJ :

				if (Call_sub_state == SUB_STATE_32) {
					I_service_id = DA_CONF_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state =SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_DROP_ACK :
			case DA_DROP_REJ :

				if (Call_sub_state == SUB_STATE_35) {
					I_service_id = DA_DROP_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

#			if AT5_KEY_SYSTEM_FEATURE == ON

			case DA_ASSOC :

				if (Na_subscription_key != OFF) {

					switch (I_assoc_type_status) {

						case SETUP_STATUS :

							if ((Call_state == STATE_NULL_0) && (Call_ces == DL_CES_BROADCAST)) {
								Set_state (STATE_OUTGOING_CALL_PROC_3);
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;

						case EXCLUSION_STATUS :

							if (((Call_state == STATE_OUTGOING_CALL_PROC_3) ||
								 (Call_state == STATE_CALL_DELIVERED_4) ||
								 (Call_state == STATE_ACTIVE_10)
								) &&
								((Call_sub_state == SUB_STATE_NULL_0) ||
								 (Call_sub_state == Sub_state_hold_rq ())
								)
							   ) {
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;


						case CONNECT_STATUS :

							if (((Call_state == STATE_CALL_RECEIVED_7) ||
								 (Call_state == STATE_CONNECT_REQUEST_8) ||
								 (Call_state == STATE_INCOMING_CALL_PROC_9) ||
								 (Call_state == STATE_DISCONNECT_REQUEST_11)
								) &&
								(Call_sub_state == SUB_STATE_NULL_0)
							   ) {
								Set_state (STATE_ACTIVE_10);
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;


						case CLEARING_DENIED_STATUS :

							if ((Call_state == STATE_DISCONNECT_REQUEST_11) &&
								((Call_sub_state == STATE_OUTGOING_CALL_PROC_3) ||
								 (Call_sub_state == STATE_CALL_DELIVERED_4) ||
								 (Call_sub_state == STATE_ACTIVE_10)
								)
							   ) {
								Set_state (Call_sub_state);
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;


						case HOLD_STATUS :
						case RECONNECT_STATUS :

							if (((Call_state == STATE_OUTGOING_CALL_PROC_3) ||
								 (Call_state == STATE_CALL_DELIVERED_4) ||
								 (Call_state == STATE_ACTIVE_10)
								) &&
								((Call_sub_state == Sub_state_call_on_hold ()) ||
								 (Call_sub_state == Sub_state_reconn_rq ())
								)
							   ) {
								error_flag = OFF;
							}
							break;

						default :
							break;

					}

					if (error_flag == OFF) {
						I_service_id = DA_ASSOC;
						set_ie_i (CODESET_0, SERVICE_ID);
						Send_to_call_control (NS_SPF_FACILITY_CO);

						if (I_assoc_type_status == SETUP_STATUS) {
							Reset_internal_ie ();
							Send_to_d_channel (ASSOC_ACK);
						}

					}

				} else {

						/* Key System not suscribed */

					ns_unexpected_ev ();
				}

				break;

#			endif

			default :
				break;
		}

	}

	if (error_flag == ON) {
		ns_unexpected_ev ();
	}

}

#endif


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            at5_ns_ei - implements the endpoint initialization procedure
				for the ATT 5E5 control of maintenance actions.

Usage           uchar ns_ei (void);

Return value    return code = CONTINUE	continue the processing,
							= STOP		wait for DL establishment,
							= NOK       the call state is errored.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar at5_ns_ei (ei_event, ces)
	code_t	ei_event;	/* Endpoint Initialization Event */
	ces_t	ces;		/* CES */
{
	uchar i;

	if ((! Dl_current_exist) ||
		(Dl_ces == DL_CES_BROADCAST)) {

		if (Ns_access_dl_ces (ces) == NOK) {

#		if ASSERT == ON
			Trap (TRAP_NO_CES, "at5_ns_ei");
#		else
				return (NOK);
#		endif

		}
	}

					/* STATE DRIVEN AUTOMATON */

	switch (Dl_ei_state) {

				/* Power down */

		case EI_STATE_DOWN :

			switch (ei_event) {

				case MNS_NA_POWER_ON_RQ :
					Dl_ei_state = EI_STATE_NOT_INIT;

						/* TEI should be initialized from now */

					break;
			}

			break;

				/* Not initialized */

		case EI_STATE_NOT_INIT :
		case EI_STATE_AWAIT_EST :

			switch (ei_event) {

				case MNS_DL_DLCI_RQ :

					if ((Rcv_dl_code == DL_TEI_ASSIGNMENT) &&
						( Lc_state == LC_RELEASED )) {
						ns_snd_dl (DL_EST_RQ, ces);
					}
					break;

				case DL_EST_CO :							/* Layer 2 established */
				case EV_INIT_RQ :
				case EV_USER_ACTION :
				case EV_USER_ASSIGN_SPID :
					send_mim (EV_INIT_RQ);
					break;

				case EV_BROADCAST_WITH_USID_TID :
					send_mim (EV_INIT_RQ);
					return (STOP);

					/* Network support Endpoint Initialization */

				case EV_ASSIGN_USID_TID :

					if ((i = access_i_man_param (PARAM_ENDPOINT_ID)) == PARAM_NOT_FOUND) return (NOK);
					Dl_usid = I_man_param_usid (i);				/* load the USID */
					Dl_tid	= I_man_param_tid (i);				/* load the TID */
					Dl_ei_state = EI_STATE_M_INIT;

#					if NS_EVENT_REPORT == ON

							/* Send the event to MNS */

						ns_send_mns_event (NS_EVENT_SPID_OK, 0);

#					endif

					send_mim (EV_ACK_USID_TID);
					break;

					/* Network does not support Endpoint Initialization */

				case EV_REJECT :							/* in a MIM */
					Dl_ei_state = EI_STATE_P_INIT;

#					if NS_EVENT_REPORT == ON

							/* Send the event to MNS */

						ns_send_mns_event (NS_EVENT_SPID_NOK, 0);

#					endif

					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				case EV_NO_USID_TID :

					if (event_id == DA_REL_COMP) {
						Dl_ei_state = EI_STATE_P_INIT;

					} else {

						send_mim (EV_INIT_RQ);
					}

					break;

			}

			break;

				/* P-initialized (Point to point) */

		case EI_STATE_P_INIT :

			switch (ei_event) {

				case EV_INIT_RQ :
					send_mim (EV_INIT_RQ);
					break;

				case EV_ASSIGN_USID_TID :

					if ((i = access_i_man_param (PARAM_ENDPOINT_ID)) == PARAM_NOT_FOUND) return (NOK);
					Dl_usid = I_man_param_usid (i);				/* load the USID */
					Dl_tid	= I_man_param_tid (i);				/* load the TID */
					Dl_ei_state = EI_STATE_M_INIT;
					send_mim (EV_ACK_USID_TID);

#					if NS_EVENT_REPORT == ON

							/* Send the event to MNS */

						ns_send_mns_event (NS_EVENT_SPID_OK, 0);

#					endif

					break;

				case EV_NOT_BROADCAST_WITH_USID_TID :
				case EV_BROADCAST_WITH_USID_TID :
					send_mim (EV_INIT_RQ);
					return (STOP);

				case EV_NO_USID_TID :
				case EV_USER_ACTION :
				case EV_USER_ASSIGN_SPID :
					break;

				case MNS_DL_DLCI_RQ :

					if (R_msg_inf0 == DL_TEI_REMOVAL) {
						Dl_ei_state = EI_STATE_NOT_INIT;
					}
					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

			}

			break;

				/* M-initialized (Multipoint) */

		case EI_STATE_M_INIT :

			switch (ei_event) {

				case EV_INIT_RQ:
				case EV_USER_ASSIGN_SPID :
					send_mim (EV_INIT_RQ);
					break;

				case EV_ASSIGN_USID_TID :

					if ((i = access_i_man_param (PARAM_ENDPOINT_ID)) == PARAM_NOT_FOUND) return (NOK);
					Dl_usid = I_man_param_usid (i);				/* load the USID */
					Dl_tid	= I_man_param_tid (i);				/* load the TID */
					send_mim (EV_ACK_USID_TID);
					break;

				case MNS_DL_DLCI_RQ :

					if (R_msg_inf0 == DL_TEI_REMOVAL) {
						Dl_ei_state = EI_STATE_NOT_INIT;
					}
					break;

				case EV_BROADCAST_WITH_USID_TID :
				case EV_NOT_BROADCAST_WITH_USID_TID :

					if (at5_match_usid_tid (I_endpoint_id_usid, I_endpoint_id_tid, I_endpoint_id_interp) == FALSE) {
						return (STOP);
					}

					break;

				case EV_NO_USID_TID :
				case EV_USER_ACTION :
					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				case EV_GET :
					send_mim (EV_GET);
					break;
			}

			break;

		default :

#			if ASSERT == ON
				Trap (TRAP_EI_STATE, "at5_ns_ei");
#			endif

			break;

	}

	return (CONTINUE);
}

/*------------------------------------------------------------------------*/

uchar send_mim (event)

	uchar event;
{
	uchar		i;					/* local index */
	call_ref_t	saved_i_call_ref;	/* saved call reference */

	switch (event) {

		case EV_INIT_RQ :

			if (Dl_is_spid_nil) return (OK);

				/* load SPID in internal structure */

			I_man_param_counter 	= 0;
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= UNCONFIRMED_OPERATION;
			I_man_op_type			= OP_TYPE_EV_REPORT;
			I_man_code				= MAN_CODE_INIT_RQ;
			I_man_param_id			= PARAM_SPID;
			i = Strcpy_far	 		((char FAR *) I_man_param_a_spid,
									 (char FAR *) Dl_a_spid,
									 AT5_MX_SZ_SPID+1);

			if (I_man_param_spid (i-1) == 0) i--;

			I_man_param_lgth		= i;
			I_man_param_counter 	= 1;
			break;

		case EV_ACK_USID_TID :
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= RETURN_RESULT;
			I_man_op_type			= OP_TYPE_SET;
			I_man_code				= MAN_CODE_ADD_INFO;
			I_man_param_counter 	= 0;
			I_man_param_id			= PARAM_ENDPOINT_ID;
			I_man_param_lgth		= 2;
			I_man_param_usid(0)		= Dl_usid;
			I_man_param_tid(0)		= Dl_tid;
			I_man_param_counter 	= 1;
			break;

		case EV_REJECT :
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= REJECT;
			I_man_op_type			= OP_TYPE_DEFAULT;
			I_man_code				= MAN_ERR_UNSPECIFIED;
			I_man_param_counter 	= 0;		/* no parameter returned */
			break;

		case EV_GET :
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= RETURN_RESULT;
			I_man_op_type			= OP_TYPE_GET;
			I_man_param_counter 	= 0;		/* no parameter returned */
			break;

		default :
			return (NOK);

	}
		/* save the IE list (if any) and the internal call reference */

	save_ie_i ();
	Reset_internal_ie ();
	saved_i_call_ref = I_call_ref;

		/* for calls not established yet ( including responses to messages
		   with global call reference ) , force the call reference to global */

	if ((!Call_current_exist) ||
		(Call_current_exist && (Call_state == STATE_NULL_0))) {
		I_call_ref = CALL_REF_GLOBAL_VAL;
	}

	Set_call_ref_not_nil ();
	set_ie_i (CODESET_6, MANAGMNT);
	Send_to_d_channel (MAN_INFO);

		/* restore IE list and internal call reference */

	roll_back_ie_i ();
	I_call_ref = saved_i_call_ref;

	return (OK);
}

/*------------------------------------------------------------------------*/

uchar access_i_man_param (param)
	uchar param;
{
	uchar counter = 0;

	while (I_(managmnt,param_id[counter]) != param) {

		if (++counter >= I_(managmnt,param_counter)) {
			return (PARAM_NOT_FOUND);
		}

	}

	return (counter);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name           	at5_match_usid_tid - implements TID/USID checking.

Usage           uchar at5_match_usid_tid (usid, tid, interp);

Return value    none.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar at5_match_usid_tid (usid, tid, interp)
	uchar usid;
	uchar tid;
	uchar interp;
{

	if (usid == AT5_USID_ALL) return (TRUE);

	if (usid == Dl_usid) {

			/* USID matches */

		if (tid == BYTE_VAL_NIL) {

				/* No TID was included */

			return (TRUE);

		}

		if (interp == INTERPRETER_0) {

				/*
				 * Terminal is selected if it is assigned the indicated TID
				 * and USID value, or if tid equals TID_ALL.
				 */


			if ((tid == Dl_tid) || (tid == AT5_TID_ALL)) {
				 return (TRUE);
			}

		} else {

				/*
				 * Terminal is selected if it is not assigned the indicated
				 * TID but it is assigned the USID, or tid equals TID_ALL.
				 */


			if ((tid != Dl_tid) || (tid == AT5_TID_ALL)) {
				 return (TRUE);
			}

		}
	}

	return (FALSE);
}

#if EQUIPMENT == NT2

#if NEW_FCT_STYLE == ON
	void	at5_n0						(void);
	void	at5_n1						(void);
	void	at5_n2						(void);
	void	at5_n3						(void);
	void	at5_n4						(void);
	void	at5_n6						(void);
	void	at5_n7						(void);
	void	at5_n8						(void);
	void	at5_n9						(void);
	void	at5_n10						(void);
	void	at5_n11						(void);
	void	at5_n12						(void);
	void	at5_n19						(void);
#else
	void	at5_n0						();
	void	at5_n1						();
	void	at5_n2						();
	void	at5_n3						();
	void	at5_n4						();
	void	at5_n6						();
	void	at5_n7						();
	void	at5_n8						();
	void	at5_n9						();
	void	at5_n10						();
	void	at5_n11						();
	void	at5_n12						();
	void	at5_n19						();
#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	at5_csc_dl_reinit_n () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN).

Usage           	void at5_csc_dl_reinit_n ();

Related
functions usage		void send_state (uchar class, uchar value, uchar diagnostic);

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

void at5_csc_dl_reinit_n ()
{
	/* nothing to do */
}

/*--------------------------------------------------------------------------*/

/*                                CLEARING PROCEDURES
*
*       TE                         NT/NETWORK                        TE
* _________________             _________________            _________________
* |               |             |               |            |               |
* |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
* |==========>....|------------>|.......|.....  |            |               |
* | start T305    |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
* |<===========...|<------------|...    |    ...|----------->|...===========>|
* |  stop T305  . |             |start T308     |            |    NS_CLEAR_RS|
* |             . | DA_DISC_COMP|   start T305  |     REL    |  .<===========|
* |             ..|------------>|       |    ...|<-----------|...  start T308|
* |               |             |       |    .  |            |               |
* |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
* |               |             |       |    ...|----------->|...===========>|
* |               |             |       |       |            |     stop T308 |
* |---------------|             |---------------|            |---------------|
*
*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            at5_circuit_switched_call_n - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage          	uchar at5_circuit_switched_call_n ();

Related
functions usage void at5_n0 .... at5_n254 ()

Description     at5_circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value    uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

uchar at5_circuit_switched_call_n ()
{

		/*
			Information messages used with the null call reference
			for terminal management
		*/

	if (Is_call_ref_nil) {

		switch (event_id) {

#			if (AT5_SUPPLEMENTARY_SERVICES == ON) && (AT5_TERMINAL_MANAGEMENT == ON)

			case DA_INFO :

				if (Na_subscription_tm != OFF) {
					Send_to_call_control (NS_SPF_FACILITY_CO);

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case NS_INFO_RQ :

				if (Na_subscription_tm != OFF) {
					Send_to_d_channel (INFO);

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#			endif

			default :
				return (NOK);
		}

	}

		/*
			ENDPOINT INITIALIZATION PROCEDURES
		*/

	switch (i_entity_origination) {

		case ENT_DL_D :			/* from network event */

			if (event_id == DA_MAN_INFO) {

					/* Set MIM event ID */

				if	( (I_man_op_class	== UNCONFIRMED_OPERATION)	&&
					  (I_man_op_type	== OP_TYPE_EV_REPORT)		&&
					  (I_man_code		== MAN_CODE_INIT_RQ) )		{
					Ns_ei (EV_INIT_RQ, Na_dl_ces);				/* call to Endpoint Initialization Procedure */
				} else

				if ( (I_man_op_class	== CONFIRMED_OPERATION)	&&
					 (I_man_op_type		== OP_TYPE_SET)			&&
					 (I_man_code		== MAN_CODE_ADD_INFO) )	{
					Ns_ei (EV_ASSIGN_USID_TID, Na_dl_ces);		/* call to Endpoint Initialization Procedure */
				} else

				if ( (I_man_op_class	== REJECT)	&&
					 (I_man_op_type		== OP_TYPE_DEFAULT) )	{
					Ns_ei (EV_REJECT, Na_dl_ces);				/* call to Endpoint Initialization Procedure */

				} else {

					Ns_ei (EV_NO_USID_TID, Na_dl_ces);
				}

				return (OK);

			}

			if (is_ie_i (CODESET_6, AT5_ENDPOINT_ID) == ABSENT) {

					/* Any message with no USID-TID */

				if (Ns_ei (EV_NO_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			} else if (Dl_ces == DL_CES_BROADCAST) {

					/* Any broadcast message with USID-TID */

				if (Ns_ei (EV_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			} else {

					/* Any broadcast message with USID-TID */

				if (Ns_ei (EV_NOT_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			}
			break;

		case ENT_CC :		/* from user event */

				/* User action */

			if (Ns_ei (EV_USER_ACTION, DL_CES_SIG) != CONTINUE) {
				return (OK);
			}
			break;

		default :
			break;

	}


					/* 1 - EVENT DRIVEN PROCESSING  */

	switch (event_id) {

							/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

		case DA_STATUS :
			return (OK);

							/* SETUP */

		case DA_SETUP :

			if (allocate_call (INCOMING_CALL, 0) == NOK) {
				Reset_internal_ie ();
				set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
				Send_to_d_channel (REL_COMP);
				return (OK);
			}

			break;

							/* DISCONNECT */

		case DA_DISC :

			switch (Call_state) {

				case STATE_DISCONNECT_INDICATION_12 :
					Stop_timer_ns (AT5_T305);
					break;

				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					ns_unexpected_ev ();
					break;

				default :
					ns_stop_all_timers ();
					Send_to_call_control (NS_CLEAR_IN);			/* send NS clear to Call Control */
					Set_state (STATE_DISCONNECT_REQUEST_11);	/* enter disconnect request state */
			}

			return (OK);

							/* RELEASE */

		case DA_REL :

			switch (Call_state) {

				case STATE_RELEASE_REQUEST_19 :
					ns_unexpected_ev ();
					break;

				default :
					Send_to_call_control (NS_CLEAR_CO);		/* send NS clear confirm to Call Control */
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);			/* send the Release Complete Message to network */
					call_clear ();							/* free call context */
			}
			return (OK);

							/* RELEASE COMPLETE */

		case DA_REL_COMP :
			Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Call Control */
			call_clear ();									/* free call context */
			return (OK);

							/* STATUS */

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			set_i_state (Call_state);
			Send_to_d_channel (STATUS);
			return (OK);

							/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			switch (Call_state) {

				case STATE_WAIT_DL :
					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					return (OK);

				case STATE_CALL_INIT_1 :

					if (! ((is_ie_i (CODESET_0, CAUSE) == PRESENT) &&
						   (I_cause_class == C_C_NORMAL_EVENT)     &&
						   (I_cause_val   == C_V_NO_ANSWER_19))
					   ) {

						Send_to_d_channel (REL_COMP);
					}

					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

#			if AT5_SUPPLEMENTARY_SERVICES == ON

				case SUB_STATE_34 :
					ns_unexpected_ev ();
					break;

#				if AT5_KEY_SYSTEM_FEATURE == ON

				case STATE_OUTGOING_CALL_PROC_3 :
				case STATE_CALL_DELIVERED_4 :
				case STATE_ACTIVE_10 :

					if (Na_subscription_key != OFF) {
						Call_sub_state = Call_state;
					}

#				endif

#			endif

				default :
					ns_stop_all_timers ();

					if (is_ie_i (CODESET_0, CAUSE) == ABSENT) {
						ie_implicit_val_x (CODESET_0, CAUSE, 0);	/* init implicit value */
					}

					Save_cause ();									/* to send the RELEASE if T305 expire */
					Send_to_d_channel (DISC);						/* send a DISCONNECT message */
					Start_timer_ns	(AT5_T305);								/* start T305 */
					Set_state (STATE_DISCONNECT_INDICATION_12); 		/* enter the Disconnect Request state */

			}

			return (OK);

	} /* End switch (event_id) */

/*.........................................................................*/

						/* 2 - STATE DRIVEN PROCESSING */

			/*
					 Switch according to the call state :

			   Dispatch to the function that processes the state except if
			   it is a clearing event not received  in an exceptional condition.
			   In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "at5_circuit_switched_call");
	}

	switch (Call_state) {

			/* Null state (u0) */

		case STATE_NULL_0 :
		case STATE_WAIT_DL :
			at5_n0 ();
			break;

			/* Call initiated (u1) */

		case STATE_CALL_INIT_1 :
			at5_n1 ();
			break;

			/* Overlap sending (u2) */

		case STATE_OVERLAP_SENDING_2 :
			at5_n2 ();
			break;

			/* Outgoing call proceeding (u3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			at5_n3 ();
			break;

			/* Call delivered (u4) */

		case STATE_CALL_DELIVERED_4 :
			at5_n4 ();
			break;

			/* Pseudo Call present - fictive state (u6) */

		case STATE_CALL_PRESENT_6 :
			at5_n6 ();
			break;

			/* Call received (u7) */

		case STATE_CALL_RECEIVED_7 :
			at5_n7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			at5_n8 ();
			break;

			/* Incoming call proceeding (u9) */

		case STATE_INCOMING_CALL_PROC_9 :
			at5_n9 ();
			break;

			/*  Active (u10) */

		case STATE_ACTIVE_10 :
			at5_n10 ();
			break;

			/* Disconnect request (u11) */

		case STATE_DISCONNECT_REQUEST_11 :
			at5_n11 ();
			break;

			/* Disconnect indication (u12) */

		case STATE_DISCONNECT_INDICATION_12 :
			at5_n12 ();
			break;

			/* Release request (u19) */

		case STATE_RELEASE_REQUEST_19 :
			at5_n19 ();
			break;

#		if AT5_SUPPLEMENTARY_SERVICES == ON

		case SUB_STATE_34 :
			ns_unexpected_ev ();
			break;

#		endif

			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "at5_circuit_switched_call");

	}

	return (OK);

}

#endif


/*EOF*/
