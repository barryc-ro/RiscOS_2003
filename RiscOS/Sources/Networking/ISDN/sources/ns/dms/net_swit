
/*--------------------------------------------------------------------------*
 *						M O D U L E		H E A D E R
 *
 * filename - net_switch.dms
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *      dms_csc_dl_reinit - implement an unexpected data link reinit.
 *
 *		dms_circuit_switched_call - implements the processing of the call
 *								  control procedures.
 *
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#if NEW_FCT_STYLE == ON
	void	dms_u0						(void);
	void	dms_u1						(void);
	void	dms_u2						(void);
	void	dms_u3						(void);
	void	dms_u4						(void);
	void	dms_u6						(void);
	void	dms_u7						(void);
	void	dms_u8						(void);
	void	dms_u9						(void);
	void	dms_u10						(void);
	void	dms_u11						(void);
	void	dms_u12						(void);
	void	dms_u19						(void);
	void	dms_csc_dl_reinit			(void);
	uchar	dms_circuit_switched_call	(void);
	uchar	dms_error_handler			(void);
	uchar	dms_ns_ei					(code_t p1, ces_t p2);
	void	dms_send_init 				(void);
	uchar	dms_match_usid_tid 			(uchar usid, uchar tid, uchar interp);
	uchar	dms_bkp_maint_proc			(code_t p1, nai_t p2);
	uchar	dms_b_chan_maint			(code_t p1);
	uchar	dms_layer3_failure			(void);
	uchar 	dms_switch_d_channel 		(code_t code);
	void 	dms_send_service 			(nai_t line_nai, uchar ack);
	uchar 	dms_single_d_chan_maint 	(code_t code);
	void 	dms_restart_maint 			(code_t code);
#else
	void	dms_u0						();
	void	dms_u1						();
	void	dms_u2						();
	void	dms_u3						();
	void	dms_u4						();
	void	dms_u6						();
	void	dms_u7						();
	void	dms_u8						();
	void	dms_u9						();
	void	dms_u10						();
	void	dms_u11						();
	void	dms_u12						();
	void	dms_u19						();
	void	dms_csc_dl_reinit			();
	uchar	dms_circuit_switched_call	();
	uchar	dms_error_handler			();
	uchar	dms_ns_ei					();
	void	dms_send_init 				();
	uchar	dms_match_usid_tid 			();
	uchar 	dms_bkp_maint_proc 			();
	uchar	dms_b_chan_maint			();
	uchar	dms_layer3_failure			();
	uchar 	dms_switch_d_channel 		();
	void 	dms_send_service 			();
	uchar 	dms_single_d_chan_maint		();
	void 	dms_restart_maint 			();
#endif


			/* Local macro definitons */

#define	Rcv_dl_code			R_msg_inf0

						/*--------------*/
						/*				*/
						/*	USER SIDE	*/
						/*				*/
						/*--------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_csc_dl_reinit () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN).

Usage           	void dms_csc_dl_reinit ();

Related
functions usage		void send_state (uchar class, uchar value, uchar diagnostic);

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA

*--------------------------------------------------------------------------*/

void dms_csc_dl_reinit ()
{
	/* nothing to do */
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			dms_circuit_switched_call - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage		  	uchar dms_circuit_switched_call ();

Related
functions usage void dms_u0 .... dms_u19 ()

Description	 dms_circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value	uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

/*                                CLEARING PROCEDURES
*
*		TE                         NT/NETWORK                        TE
* _________________             _________________            _________________
* |               |             |               |            |               |
* |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
* |==========>....|------------>|.......|.....  |            |               |
* | start T305    |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
* |<===========...|<------------|...    |    ...|----------->|...===========>|
* |  stop T305  . |             |start T308     |            |    NS_CLEAR_RS|
* |             . | DA_DISC_COMP|   start T305  |     REL    |  .<===========|
* |             ..|------------>|       |    ...|<-----------|...  start T308|
* |               |             |       |    .  |            |               |
* |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
* |               |             |       |    ...|----------->|...===========>|
* |               |             |       |       |            |     stop T308 |
* |---------------|             |---------------|            |---------------|
*/

uchar dms_circuit_switched_call ()
{

#	if (NS_RESTART_PROCEDURE == ON) || (NS_MAINTENANCE_CAPABILITY == ON)
		uchar	FAR *p_data;
		uchar		chan_id;
		nai_t		int_id;
#	endif

/*.........................................................................*/

	if ((Na_type == BRI) && (Na_connection == POINT_TO_MULTIPOINT)) {

#		if NS_TYPE_BRI == ON

				/*	ENDPOINT INITIALIZATION PROCEDURES	*/

			switch (i_entity_origination) {

				case ENT_DL_D :

						/* INFO PDU on call reference nil */

					if ((Is_call_ref_nil) && (event_id == DA_INFO)) {

						if (is_ie_i (CODESET_0, ENDPOINT_ID) == PRESENT) {

								/* Switch assigns an EID */

							Ns_ei (EV_ASSIGN_USID_TID, Na_dl_ces);		/* call to Endpoint Initialization Procedure */
							return (CONTINUE);

						} else {

							if ((is_ie_i (CODESET_0, INFORMATION_RQ) == PRESENT) &&
								(I_(information_rq, info_ind) == PROMPT_FOR_ADD_INFO)) {

								/* Initialization is requested by the switch */

								Ns_ei (EV_INIT_RQ, Na_dl_ces);				/* call to Endpoint Initialization Procedure */

									/* Update origination AFTER having called Ns_ei () */

								Dl_ei_orig = FROM_D_CHANNEL;

								return (CONTINUE);
							}
						}

						if ((is_ie_i (CODESET_0, CAUSE) == PRESENT) &&
							(I_cause_class == C_C_PROTOCOL_ERROR)) {

							if (I_cause_val == C_V_NON_EXISTENT_IE_99) {

									/* Switch does not support initialization */

								Ns_ei (EV_REJECT, Na_dl_ces);

#								if NS_EVENT_REPORT == ON

										/* Send the event to MNS */

									ns_send_mns_event (NS_EVENT_SPID_NOK, 0);

#								endif
							}

							if (I_cause_val == C_V_INVALID_IE_CONTENT_100) {

									/* Bad SPID */

								Ns_ei (EV_REJECT_SPID_100, Na_dl_ces);

#								if NS_EVENT_REPORT == ON

										/* Send the event to MNS */

									ns_send_mns_event (NS_EVENT_SPID_NOK, 0);

#								endif
							}
						}

						return (CONTINUE);

					}

						/* other messages */

					if (is_ie_i (CODESET_0, ENDPOINT_ID) == ABSENT) {

							/* Any message with no USID-TID */

						if (Ns_ei (EV_NO_USID_TID, Na_dl_ces) != CONTINUE) {
							return (OK);
						}

					} else {

							/* USID-TID provided */

						if (event_id == DA_SETUP) {

								/* broadcast message with USID-TID */

							if (Ns_ei (EV_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
								return (OK);
							}

						} else {

								/* Any not broadcast message with USID-TID */

							if (Ns_ei (EV_NOT_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
								return (OK);
							}
						}

					}

					break;

				case ENT_CC :		/* from user event */

						/* User action */

					if (Ns_ei (EV_USER_ACTION, Na_dl_ces) != CONTINUE) {
						set_i_cause (C_C_DATA_LINK_FAILURE,C_V_DL_TERMINAL_NOT_INIT, P_NIL);
						Send_to_call_control(NS_CLEAR_CO);
						call_clear ();
						return (OK);
					}

					break;

				case ENT_TI :

					if (event_id == TI_SPID) {
						Ns_ei (TI_SPID, Na_dl_ces);


#						if NS_EVENT_REPORT == ON

							if (Dl_ei_orig == TO_D_CHANNEL) {

								ns_send_mns_event (NS_EVENT_SPID_NOK, 0);
							}

#						endif

						return (OK);
					}

					break;

				default :
					break;

			}

#		endif

	}

	if (i_entity_origination == ENT_MNS) {


		switch (event_id) {

#			if NS_RESTART_PROCEDURE == ON /* { */

				case MNS_RESTART_RQ :

						/* authorized only on Primary rate interface in u -> n direction */

					if (Na_type == BRI) {

							/* Return MNS_RESTART_CO with error ("restart procedures not implemented") and do nothing else */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_NOT_IMPLEMENTED);
						return (STOP);
					}

						/* set current data pointer using p_ssdu pointer */

					p_data = p_ssdu;

#					if NS_MAINTENANCE_CAPABILITY == OFF

						if (Dl_rest_state == STATE_REST_0) {


							if (Dl_call_count == 0) {

									/* Return MNS_RESTART_CO and do nothing else */

								ns_send_mns_restart (OK, I_restart_ind_class, Mns_restart_b_chan_nb, 0);
								return (OK);

							} else {

								ns_unexpected_ev ();
							}

						}

#					else

						if (ns_nfas == ON) {

							p_nsdl = Nfas_dl_p_active_d_chan;
						}

	 					Dl_rest_class = I_restart_ind_class;
                        
#					endif

					if (I_restart_ind_class != RI_ALL_INTERFACES) {

						I_chan_id_d_chan 	= NOT_D_CHAN;	/* B-Channel indicated */
						I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */
						I_chan_id_int_type 	= INT_TYPE_PRI;
						I_chan_id_chan_sel 	= AS_INDICATED;	/* Channel Number as indicated in following octets */
						I_chan_id_nb_map 	= CHAN_NUMBER;	/* Format of following octets = simply the B-Channel number */
						I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

#						if NS_MAINTENANCE_CAPABILITY == ON

							Dl_rest_int_id	= Nai;

							if (Nfas_nai_active_d_chan != Mns_restart_interface) {
								I_chan_id_int_id 	= INT_ID_EXPLICIT;
								I_chan_id_int_id_val= Mns_restart_interface;
								Dl_rest_int_id		= Mns_restart_interface;
							}

#						endif

						if (I_restart_ind_class == RI_INDICATED_CHANNEL) {
							I_chan_id_chan_nb   = Mns_restart_b_chan_nb;	/* channel number */
						} else {

							I_(chan_id,chan_sel) = NO_CHAN;
							set_ie_i (CODESET_0, CHAN_ID);
						}
					}

					if (I_restart_ind_class == RI_ALL_INTERFACES) {
						csc_clear_all_call ();
						Na_internal_restart = ON;
					}

					Send_to_call_control (NS_RESTART_IN);	/* on CONN_ID_MANAGEMENT */
					Start_dl_timer (DMS_T317);
					Set_call_ref_not_nil ();

					Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
					N316 = 0;
					Start_dl_timer (DMS_T316);
					Dl_rest_state = STATE_REST_1;
					break;

#			endif /* } */

#			if NS_MAINTENANCE_CAPABILITY == ON /* { */

				case MNS_SERVICE_RQ :

						/* Set p_data pointers to start of data */

					p_data = p_ssdu;

					I_(change_status, preference) 	= Mns_service_pref;
					I_(change_status, status) 		= Mns_service_status;

					switch (Mns_service_pref) {

						case I_PREF_D_CHANNEL :
							return (dms_bkp_maint_proc (MNS_SERVICE_RQ, Nai));

						case I_PREF_B_CHANNEL :
							I_(change_status, preference) = PREF_B_CHANNEL;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= AS_INDICATED;			/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;			/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_type	= B_CHAN;				/* B-Channel number */
							I_chan_id_chan_nb 	= Mns_service_b_chan;	/* channel number */
							break;

						case I_PREF_INTERFACE :
							I_(change_status, preference) = PREF_INTERFACE;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= AS_INDICATED;			/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;			/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_nb 	= 1;					/* channel number (first B channel) */
							break;
					}

						/* Set the 2 IEs */

					set_ie_i (CODESET_0, CHAN_ID);
					set_ie_i (CODESET_0, CHANGE_STATUS);

					dms_b_chan_maint (MNS_SERVICE_RQ);

					break;

#				endif /* } */

#				if ASSERT == ON

				default :
					Trap (TRAP_MNS_CODE, "dms_circuit_switched_call");

#				endif

		}

		return (OK);
	}

					/* 1 - EVENT DRIVEN PROCESSING  */

	switch (event_id) {

						/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

						/* SETUP : allocate a call context */

		case DA_SETUP :

			if (allocate_call (INCOMING_CALL, 0) != OK) {

#				if NS_TYPE_PRI == ON

					if (Na_type == PRI) {
						Reset_internal_ie ();
						set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
						Send_to_d_channel (REL_COMP);
					}

#				endif

				return (OK);
			}

#			if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON) /* { */

				if (Na_type == PRI) {

						/* B channel must be IS or OOS NE */

					chan_id = (I_chan_id_chan_nb) & 0x7f;

						/*
						 * Get the interface Id
						 */

					int_id = Nai;

					if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

						if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {
							int_id = I_(chan_id, int_id_val);
						}

						if (Dl_b_chan_mode_int (int_id, chan_id) != CHANNEL_IN_SERVICE) {
							Reset_internal_ie ();
							set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44, P_NIL);
							Send_to_d_channel (REL_COMP);
							call_clear ();
							return (OK);
						}
					}

				}

#			endif /* } */

			break;

						/* DISCONNECT */

		case DA_DISC :
			Call_fac_rq	= OFF;

			switch (Call_state) {

				case STATE_DISCONNECT_REQUEST_11 :
					Stop_timer_ns (DMS_T305);
					Send_to_call_control (NS_CLEAR_IN);				/* send NS clear to Layer 4 */
					Reset_internal_ie ();

					if (disc_cause_error () == NOK) {
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
					}

					Send_to_d_channel_and_save_spdu (REL);
					N308 = 0;
					Set_state (STATE_RELEASE_REQUEST_19);
					Start_timer_ns (DMS_T308);
					break;

				case STATE_DISCONNECT_INDICATION_12 :
					ns_unexpected_ev ();
					break;

				case STATE_RELEASE_REQUEST_19 :

					if (Na_type == PRI) {
						ns_unexpected_ev ();
						break;
					}
					break;

				case STATE_CALL_PRESENT_6 :

					if (Na_type == BRI) {
						ns_unexpected_ev ();
						break;
					}

				default :

					if (Call_state == STATE_CALL_INIT_1) {
						Release_saved_spdu ();
					}

					ns_stop_all_timers ();
					Send_to_call_control (NS_CLEAR_IN);				/* send NS clear to Layer 4 */
					Set_state (STATE_DISCONNECT_INDICATION_12);		/* enter disconnect indication state */
					break;
			}

			return (OK);

						/* RELEASE */

		case DA_REL :

			switch (Call_state) {

				case STATE_CALL_INIT_1 :
					Release_saved_spdu ();
					ns_stop_all_timers ();
					Call_fac_rq = OFF;
					Send_to_call_control (NS_CLEAR_CO);					/* send NS clear confirm to Layer 4 */
					Send_to_d_channel (REL_COMP);						/* send the Release Complete Message to network */
					call_clear ();
					break;

				case STATE_RELEASE_REQUEST_19 :

					ns_stop_all_timers ();
					Call_fac_rq = OFF;
					Send_to_call_control (NS_CLEAR_CO);					/* send NS clear confirm to Layer 4 */
					Reset_internal_ie ();
					set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);

					if (Na_type == BRI) {
						Send_to_d_channel (REL_COMP);						/* send the Release Complete Message to network */
					}

					call_clear ();
					return (OK);

				case STATE_CALL_PRESENT_6 :

					if (Na_type == BRI) {
						ns_unexpected_ev ();
						break;
					}

				default :
					ns_stop_all_timers ();
					Call_fac_rq = OFF;
					Send_to_call_control (NS_CLEAR_CO);					/* send NS clear confirm to Layer 4 */
					Reset_internal_ie ();
					set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
					Send_to_d_channel (REL_COMP);						/* send the Release Complete Message to network */
					call_clear ();
					return (OK);
			}

			return (OK);

						/* RELEASE COMPLETE */

		case DA_REL_COMP :
			Call_fac_rq	= OFF;
			Send_to_call_control (NS_CLEAR_CO);					/* send NS clear confirm to Layer 4 */
			call_clear ();										/* free call context */
			return (OK);

						/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			if (	(is_ie_i (CODESET_0, CAUSE) == PRESENT) 		&&
					(I_cause_class == C_C_RESOURCE_UNAVAILABLE)     &&
					(I_cause_val   == C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44)
			   ) {

				Send_to_call_control (NS_CLEAR_CO);

				if (Na_type == PRI) {
					Send_to_d_channel (REL_COMP);
				}

				call_clear ();
				return (OK);
			}

			switch (Call_state) {

				case STATE_CALL_PRESENT_6 :

					if (! ((is_ie_i (CODESET_0, CAUSE) == PRESENT) &&
						   (I_cause_class == C_C_NORMAL_EVENT)     &&
						   (I_cause_val   == C_V_NO_ANSWER_19))
					   ) {

						Send_to_d_channel (REL_COMP);
					}


				case STATE_WAIT_DL :
					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					return (OK);

						/* User is in en-bloc sending and refuse previous NS_SETUP_ACK_IN */

				case STATE_OVERLAP_SENDING_2 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :
					ns_stop_all_timers ();
					Send_to_d_channel_and_save_spdu (REL);		/* send a RELease message */
					N308 = 0;
					Start_timer_ns (DMS_T308);					/* start T308 */
					Set_state (STATE_RELEASE_REQUEST_19);		/* enter the Release Request state */
					break;

				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					break;

				case STATE_DISCONNECT_INDICATION_12 :
					disc_cause_error ();
					Stop_timer_ns  (DMS_T300);
					go_to_state_19 (DMS_T308);
					break;

				case STATE_CALL_INIT_1 :
					Release_saved_spdu ();						/* saved setup no more useful */

					/* process the default */

				default :
					ns_stop_all_timers ();
					Save_cause ();								/* to send the RELEASE if T305 expire */
					Send_to_d_channel (DISC);					/* send a DISCONNECT message */
					Start_timer_ns (DMS_T305);					/* start T305 */
					Set_state (STATE_DISCONNECT_REQUEST_11);	/* enter the Disconnect Request state */
					break;

			}

			return (OK);

						/* INFO */

		case DA_INFO :

			if (Call_current_exist) {

				switch (Call_state) {

					case STATE_CALL_INIT_1 :
					case STATE_CALL_PRESENT_6 :
						ns_unexpected_ev ();
						break;

						/* In state 19, the INFO message may be ignored */

					case STATE_RELEASE_REQUEST_19 :
						break;

					default :
						Send_to_call_control (NS_INFO_IN);

				}


			} else {

				Send_to_call_control (NS_INFO_IN);
			}

			return (OK);

						/* NS INFORMATION REQUEST */

		case  NS_INFO_RQ :

			if (Call_current_exist) {

				switch (Call_state) {

					case STATE_CALL_PRESENT_6 :
					case STATE_RELEASE_REQUEST_19 :
						ns_unexpected_ev ();
						break;

					case STATE_OVERLAP_SENDING_2 :
						Send_to_d_channel (INFO);
						break;

					default :

						if (is_ie_i (CODESET_0, CALLED_NB) == PRESENT) {
							ns_unexpected_ev ();

						} else {

							Send_to_d_channel (INFO);
						}

				}


			} else {

				Send_to_d_channel (INFO);
			}

			return (OK);

						/* STATUS */

		case DA_STATUS :

			if (Call_current_exist) {

				if (I_call_state_val == STATE_NULL_0) {
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();

				} else {

					if (Call_state != I_call_state_val) {
						Reset_internal_ie ();
						send_release (REL_COMP,C_C_PROTOCOL_ERROR, C_V_MESSAGE_NOT_COMPATIBLE_101, spdu_id);
						call_clear ();
					}
				}
			}

			return (OK);

						/* STATUS_ENQ */

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_state (Call_state);
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			Send_to_d_channel (STATUS);
			return (OK);

#		if NS_RESTART_PROCEDURE == ON /* { */

			case TI_316 :

				if (Dl_rest_state == STATE_REST_1) {

					if (++N316 == DMS_MX_N316) {

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_316);
						Dl_restart_reset ();

					} else {

						Set_call_ref_not_nil ();

							/* store Restart Indicator with value saved in DL context */

						set_ie_i (CODESET_0, RESTART_IND);
						I_restart_ind_class = Dl_rest_class;

						if (I_restart_ind_class != RI_ALL_INTERFACES) {

								/* store Channel-ID */

							ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
							set_ie_i (CODESET_0, CHAN_ID);

							I_chan_id_d_chan 	= NOT_D_CHAN;		/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;		/* Exclusive */
							I_chan_id_int_type  = INT_TYPE_PRI;		/* PRI */

#							if NS_MAINTENANCE_CAPABILITY == ON

								if (Dl_rest_int_id != Nai) {
									I_chan_id_int_id 	= INT_ID_EXPLICIT;
									I_chan_id_int_id_val= Dl_rest_int_id;
								}

#							endif

							if (I_restart_ind_class == RI_SINGLE_INTERFACE) {
								I_chan_id_chan_sel  = NO_CHAN;			/* No channel */

							} else {
								I_chan_id_chan_sel  = AS_INDICATED;		/* Channel Number as indicated in following octets */
								I_chan_id_chan_type	= B_CHAN;			/* B-Channel number */
								I_chan_id_chan_nb   = Dl_rest_chan_nb;	/* channel number */

							}
						}

						Send_to_d_channel (RESTART);			/* with CALL_REF_GLOBAL */
						Restart_dl_timer (DMS_T316);
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case TI_317 :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

					if (Nfas_nai_mode == NFAS_TSP) {

						if (ns_access_na (Nfas_cfg_nai_active_d_chan) != OK) {
							return (NOK);
						}
					}

#				endif


				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
						Dl_restart_reset ();
						break;

					default :

						ns_unexpected_ev ();
				}

				return (OK);

			case DA_RESTART :

#				if NS_MAINTENANCE_CAPABILITY == ON
					dms_restart_maint (DA_RESTART);
#				else

					if (Dl_rest_state == STATE_REST_0) {
						Start_dl_timer (DMS_T317);
						Set_call_ref_nil ();		/* to use CONN_ID_MANAGEMENT */
						Send_to_call_control (NS_RESTART_IN);
						Dl_rest_state = STATE_REST_2;

					} else {

						ns_unexpected_ev ();
					}

#				endif

				return (OK);

			case DA_RESTART_ACK :

#				if NS_MAINTENANCE_CAPABILITY == ON
					dms_restart_maint (DA_RESTART_ACK);
#				else

					if (Dl_rest_state == STATE_REST_1) {

						Stop_dl_timer (DMS_T316);

						if (Dl_rest_resp == ON) {

							ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
							Dl_restart_reset ();

						} else {

							Dl_rest_ack = ON;
						}

					} else {

						ns_unexpected_ev ();
					}

#				endif

				return (OK);

			case NS_RESTART_RS :

#				if NS_MAINTENANCE_CAPABILITY == ON
					dms_restart_maint (NS_RESTART_RS);
#				else

					Stop_dl_timer (DMS_T317);
					switch (Dl_rest_state) {

						case STATE_REST_1 :

							if (Dl_rest_ack == ON) {

								ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
								Dl_restart_reset ();

							} else {

								Dl_rest_resp = ON;
							}

							break;

						case STATE_REST_2 :

							Set_call_ref_not_nil ();
							Send_to_d_channel (RESTART_ACK);
							Dl_restart_reset ();
							break;

						default :

							ns_unexpected_ev ();
					}

#				endif

				return (OK);

			case NS_RESTART_RQ :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

#				endif

				if (Dl_rest_state != STATE_REST_0) {

					call_clear ();

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#		endif /* RESTART_PROCEDURE = ON} */

#		if NS_MAINTENANCE_CAPABILITY == ON

			case TI_321 :
			case TI_3DW :
			case TI_3MB :
			case TI_3M1 :
			case DA_MAINT_SERVICE :
			case DA_MAINT_SERVICE_ACK :

            	if ((i_entity_origination == ENT_TI) &&(event_id == TI_303)) {
                	break;
                } else {
					dms_bkp_maint_proc (event_id, Nai);
					return (OK);
                }

#		endif

	} /* End switch (event_id) */

/*.........................................................................*/

					/* 2 - STATE DRIVEN PROCESSING */

			/*
					 Switch according to the call state :

				Dispatch to the function that processes the state except if
				it is a clearing event not received  in an exceptional condition.
				In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "dms_circuit_switched_call");
	}

#	if NS_MAINTENANCE_CAPABILITY == ON

			/*
             * Make sure the DL context is the active one when
             * enterring automaton.
             */
             
		if ((ns_nfas == ON) && (Nfas_context_exist)) {
		    p_nsdl = Nfas_dl_p_active_d_chan;
        }

#	endif

	switch (Call_state) {

			/* Null state (u0) */

		case STATE_NULL_0 :
		case STATE_WAIT_DL :
			dms_u0 ();
			break;

			/* Call initiated (u1) */

		case STATE_CALL_INIT_1 :
			dms_u1 ();
			break;

			/* Overlap sending (u2) */

		case STATE_OVERLAP_SENDING_2 :
			dms_u2 ();
			break;

			/* Outgoing call proceeding (u3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			dms_u3 ();
			break;

			/* Call delivered (u4) */

		case STATE_CALL_DELIVERED_4 :
			dms_u4 ();
			break;

			/* Call present (u6) */

		case STATE_CALL_PRESENT_6 :
			dms_u6 ();
			break;

			/* Call received (u7) */

		case STATE_CALL_RECEIVED_7 :
			dms_u7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			dms_u8 ();
			break;

			/* Incoming call proceeding state (u9) */

		case STATE_INCOMING_CALL_PROC_9 :
			dms_u9 ();
			break;

			/*  Active (u10) */

		case STATE_ACTIVE_10 :
			dms_u10 ();
			break;

			/* Disconnect request (u11) */

		case STATE_DISCONNECT_REQUEST_11 :
			dms_u11 ();
			break;

			/* Disconnect indication (u12) */

		case STATE_DISCONNECT_INDICATION_12 :
			dms_u12 ();
			break;

			/* Release request (u19) */

		case STATE_RELEASE_REQUEST_19 :
			dms_u19 ();
			break;

			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "dms_circuit_switched_call");

	}

	return (OK);
}

#if EQUIPMENT == NT2


						/*-------------------*/
						/*                   */
						/*   NETWORK SIDE    */
						/*                   */
						/*-------------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dms_circuit_switched_call_n - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage          	uchar dms_circuit_switched_call_n ();

Related
functions usage void n0 .... n19 ();

Description     dms_circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value    uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	void	dms_n0						(void);
	void	dms_n1						(void);
	void	dms_n2						(void);
	void	dms_n3						(void);
	void	dms_n4						(void);
	void	dms_n6						(void);
	void	dms_n7						(void);
	void	dms_n8						(void);
	void	dms_n9						(void);
	void	dms_n10						(void);
	void	dms_n11						(void);
	void	dms_n12						(void);
	void	dms_n19						(void);
	void	dms_csc_dl_reinit_n			(void);
	uchar	dms_circuit_switched_call_n	(void);
#else
	void	dms_n0						();
	void	dms_n1						();
	void	dms_n2						();
	void	dms_n3						();
	void	dms_n4						();
	void	dms_n6						();
	void	dms_n7						();
	void	dms_n8						();
	void	dms_n9						();
	void	dms_n10						();
	void	dms_n11						();
	void	dms_n12						();
	void	dms_n19						();
	void	dms_csc_dl_reinit_n			();
	uchar	dms_circuit_switched_call_n	();
#endif

/*                                CLEARING PROCEDURES
*
*       TE                         NT/NETWORK                        TE
* _________________             _________________            _________________
* |               |             |               |            |               |
* |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
* |==========>....|------------>|.......|.....  |            |               |
* | start T305    |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
* |<===========...|<------------|...    |    ...|----------->|...===========>|
* |  stop T305  . |             |start T308     |            |    NS_CLEAR_RS|
* |             . | DA_DISC_COMP|   start T305  |     REL    |  .<===========|
* |             ..|------------>|       |    ...|<-----------|...  start T308|
* |               |             |       |    .  |            |               |
* |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
* |               |             |       |    ...|----------->|...===========>|
* |               |             |       |       |            |     stop T308 |
* |---------------|             |---------------|            |---------------|
*
*/

uchar dms_circuit_switched_call_n ()
{

#	if (NS_RESTART_PROCEDURE == ON) || (NS_MAINTENANCE_CAPABILITY == ON)
		uchar	FAR *p_data;
		uchar		chan_id;
		nai_t		int_id;
#	endif


/*.........................................................................*/

	if (i_entity_origination == ENT_MNS) {

		switch (event_id) {

#			if NS_RESTART_PROCEDURE == ON /* { */

				case MNS_RESTART_RQ :

						/* authorized only on Primary rate interface in u -> n direction */

					if (Na_type == BRI) {

							/* Return MNS_RESTART_CO with error ("restart procedures not implemented") and do nothing else */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_NOT_IMPLEMENTED);
						return (STOP);
					}

						/* set current data pointer using p_ssdu pointer */

					p_data = p_ssdu;

#					if NS_MAINTENANCE_CAPABILITY == OFF

						if (Dl_rest_state == STATE_REST_0) {


							if (Dl_call_count == 0) {

									/* Return MNS_RESTART_CO and do nothing else */

								ns_send_mns_restart (OK, I_restart_ind_class, Mns_restart_b_chan_nb, 0);
								return (OK);

							} else {

								ns_unexpected_ev ();
							}

						}

#					else

						if (ns_nfas == ON) {

							p_nsdl = Nfas_dl_p_active_d_chan;
						}

	 					Dl_rest_class = I_restart_ind_class;
                        
#					endif

					if (I_restart_ind_class != RI_ALL_INTERFACES) {

						I_chan_id_d_chan 	= NOT_D_CHAN;	/* B-Channel indicated */
						I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */
						I_chan_id_int_type 	= INT_TYPE_PRI;
						I_chan_id_chan_sel 	= AS_INDICATED;	/* Channel Number as indicated in following octets */
						I_chan_id_nb_map 	= CHAN_NUMBER;	/* Format of following octets = simply the B-Channel number */
						I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

#						if NS_MAINTENANCE_CAPABILITY == ON

							Dl_rest_int_id	= Nai;

							if (Nfas_nai_active_d_chan != Mns_restart_interface) {
								I_chan_id_int_id 	= INT_ID_EXPLICIT;
								I_chan_id_int_id_val= Mns_restart_interface;
								Dl_rest_int_id		= Mns_restart_interface;
							}

#						endif

						if (I_restart_ind_class == RI_INDICATED_CHANNEL) {
							I_chan_id_chan_nb   = Mns_restart_b_chan_nb;	/* channel number */
						} else {

							I_(chan_id,chan_sel) = NO_CHAN;
							set_ie_i (CODESET_0, CHAN_ID);
						}
					}

					if (I_restart_ind_class == RI_ALL_INTERFACES) {
						csc_clear_all_call ();
						Na_internal_restart = ON;
					}

					Send_to_call_control (NS_RESTART_IN);	/* on CONN_ID_MANAGEMENT */
					Start_dl_timer (DMS_T317);
					Set_call_ref_not_nil ();

					Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
					N316 = 0;
					Start_dl_timer (DMS_T316);
					Dl_rest_state = STATE_REST_1;
					break;

#			endif /* } */

#			if NS_MAINTENANCE_CAPABILITY == ON /* { */

				case MNS_SERVICE_RQ :

						/* Set p_data pointers to start of data */

					p_data = p_ssdu;

					I_(change_status, preference) 	= Mns_service_pref;
					I_(change_status, status) 		= Mns_service_status;

					switch (Mns_service_pref) {

						case I_PREF_D_CHANNEL :
							return (dms_bkp_maint_proc (MNS_SERVICE_RQ, Nai));

						case I_PREF_B_CHANNEL :
							I_(change_status, preference) = PREF_B_CHANNEL;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= AS_INDICATED;			/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;			/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_type	= B_CHAN;				/* B-Channel number */
							I_chan_id_chan_nb 	= Mns_service_b_chan;	/* channel number */
							break;

						case I_PREF_INTERFACE :
							I_(change_status, preference) = PREF_INTERFACE;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= AS_INDICATED;			/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;			/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_nb 	= 1;					/* channel number (first B channel) */
							break;
					}

						/* Set the 2 IEs */

					set_ie_i (CODESET_0, CHAN_ID);
					set_ie_i (CODESET_0, CHANGE_STATUS);

					dms_b_chan_maint (MNS_SERVICE_RQ);

					break;

#				endif /* } */

#				if ASSERT == ON

				default :
					Trap (TRAP_MNS_CODE, "dms_circuit_switched_call");

#				endif

		}

		return (OK);
	}

#	if NS_TYPE_BRI == ON

        if ((Na_type == BRI) && (Na_connection_pmp == ON) && (i_entity_origination == ENT_DL_D)) {

            if (Call_current_exist) {

                if (Call_state > STATE_CALL_PRESENT_6) {

                        /*
                         * When the a Termainal has already answered the
                         * outgoing call with an ALERT,
                         * all other answers must be cleared.
                         */

                    if (Call_ces_setup != Dl_ces) {

                    	if (event_id != DA_REL_COMP) {
                            Reset_internal_ie ();
                            set_i_cause (C_C_INVALID_MESSAGE, C_V_INVALID_CALL_REF_81, P_NIL);
                            Send_to_d_channel (REL_COMP);
                        }

                        return (OK);
                    }
                }
            }
        }

#	endif

					/* 1 - EVENT DRIVEN PROCESS */

	switch (event_id) {

							/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

							/* SETUP : allocate a call context */

		case DA_SETUP :

			if (allocate_call (INCOMING_CALL, 0) == NOK) {
				Reset_internal_ie ();
				set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_CONGESTION_42, P_NIL);
				Send_to_d_channel (REL_COMP);
				return (OK);
			}

#			if NS_MAINTENANCE_CAPABILITY == ON /* { */

				if (Na_type == PRI) {

						/* B channel must be IS or OOS NE */

					chan_id = (I_chan_id_chan_nb) & 0x7f;

						/*
						 * Get the interface Id
						 */

					int_id = Nai;

					if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

						if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {
							int_id = I_(chan_id, int_id_val);
						}

						if ((Dl_b_chan_mode_int (int_id, chan_id) != MAINT_STATE_B_IS) &&
							(Dl_b_chan_mode_int (int_id, chan_id) != MAINT_STATE_B_OOS_NE)) {
							Reset_internal_ie ();
							set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
							Send_to_d_channel (REL_COMP);
							call_clear ();
							return (OK);
						}
					}

				}

#			endif /* } */

			break;

							/* DISCONNECT */

		case DA_DISC :
			Call_fac_rq		= OFF;

			switch (Call_state) {

				case STATE_CALL_RECEIVED_7 :

					ns_action_to_cc (DMS_T301, DMS_T300, NS_CLEAR_IN,
														 STATE_DISCONNECT_REQUEST_11);

					break;


				case STATE_CONNECT_REQUEST_8 :

					ns_action_to_cc (T3_NIL, DMS_T300, NS_CLEAR_IN,
													   STATE_DISCONNECT_REQUEST_11);
					break;

				case STATE_INCOMING_CALL_PROC_9 :

					ns_action_to_cc (DMS_T310, DMS_T300, NS_CLEAR_IN,
														 STATE_DISCONNECT_REQUEST_11);
					break;

				case STATE_DISCONNECT_INDICATION_12 :
					Stop_timer_ns (DMS_T305);
					Reset_internal_ie ();
					go_to_state_19 (DMS_T308);
					break;


				case STATE_RELEASE_REQUEST_19 :
						/* no process */
					break;


				case STATE_NULL_0 :
				case STATE_CALL_PRESENT_6 :
				case STATE_DISCONNECT_REQUEST_11 :
					ns_unexpected_ev ();
					break;

				default :
					ns_stop_all_timers ();
					ns_action_to_cc (T3_NIL, DMS_T300, NS_CLEAR_IN,
													   STATE_DISCONNECT_REQUEST_11);
					break;

			}

			return (OK);

							/* - RELEASE */

		case DA_REL :
			Call_fac_rq 	= OFF;

			switch (Call_state) {

				case STATE_NULL_0 :
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);					/* send the Release Complete Message to network */
					call_clear ();									/* free call context */
					break;

				case STATE_CALL_PRESENT_6 :
				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :

					Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);
					call_clear ();
					break;

				default :
					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Layer 4 */
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);					/* send the Release Complete Message to network */
					call_clear ();									/* free call context */
					break;

			}

			return (OK);


						/* - RELEASE COMPLETE */

		case DA_REL_COMP :

			Call_fac_rq	= OFF;

			switch (Call_state) {

				case STATE_NULL_0 :

					/* no process */

					break;

				case STATE_CALL_INIT_1 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_PRESENT_6 :
				case STATE_INCOMING_CALL_PROC_9 :

					if (Call_ces_setup != DL_CES_BROADCAST) {
						Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
						call_clear ();
                    }

					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :

					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear to Layer 4 */
					call_clear ();
					break;

				default :
					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Layer 4 */
					call_clear ();									/* free call context */
					break;

			}

			return (OK);

						/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			switch (Call_state) {

				case STATE_NULL_0 :
				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_INIT_1 :
					Send_to_d_channel (REL_COMP);
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

				case STATE_CALL_PRESENT_6 :

                	if (Call_ces_setup != DL_CES_BROADCAST) {

                        Stop_timer_ns (DMS_T303);

                        ns_action_to_dl (T3_NIL, DMS_T305, DISC,
                                                           STATE_DISCONNECT_INDICATION_12);

                    } else {

                       	Send_to_call_control (NS_CLEAR_CO);
                       	call_clear ();
                    }

					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :

					ns_action_to_dl (T3_NIL, DMS_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);

					break;

				case STATE_INCOMING_CALL_PROC_9 :
					Stop_timer_ns (DMS_T310);
					ns_action_to_dl (T3_NIL, DMS_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);
					break;

				default :
					ns_stop_all_timers ();
					Save_cause ();									/* to send the RELEASE if DMS_T305 expire */
					ns_action_to_dl (T3_NIL, DMS_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);
					break;

			}

			return (OK);

						/* INFO */

		case DA_INFO :

        	if (!Call_current_exist) {

            		/*
                     * Send a NS_INFO_IN on CONN_ID_MANAGEMENT
                     */

				Send_to_call_control (NS_INFO_IN);			/* send NS info to Layer 4 */

                return (OK);
            }
            
			switch (Call_state) {

				case STATE_NULL_0 :
				case STATE_CALL_INIT_1 :
				case STATE_CALL_PRESENT_6 :
					ns_unexpected_ev ();
					break;

				case STATE_OVERLAP_SENDING_2 :
					Send_to_call_control (NS_INFO_IN);
					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :

					Send_to_call_control (NS_INFO_IN);
					break;

				default :
					Send_to_call_control (NS_INFO_IN);
					break;

			}

			return (OK);

						/* STATUS */

		case DA_STATUS :

			if (Call_current_exist) {

				if (Call_state == STATE_RELEASE_REQUEST_19) {

					if (I_call_state_val == STATE_NULL_0) {
						Call_fac_rq	= OFF;
						Send_to_call_control (NS_CLEAR_CO);						/* send NS clear confirm to Layer 4 */
						call_clear ();											/* free call context */

					} else {

						if (C_v (I_cause_class, I_cause_val) ==
							C_v (C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30)) {
						}

					}

				} else {

					if (C_v (I_cause_class, I_cause_val) ==
						C_v (C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30)) {
					}

					if (Call_state != I_call_state_val) {

						if ((I_cause_class == C_C_PROTOCOL_ERROR)				&&
							((I_cause_val == C_V_MANDATORY_IE_MISSING_96)		||
							 (I_cause_val == C_V_MESSAGE_TYPE_NON_EXISTENT_97)	||
							 (I_cause_val == C_V_NON_EXISTENT_IE_99)			||
							 (I_cause_val == C_V_INVALID_IE_CONTENT_100)))	{
							Call_fac_rq	= OFF;
							Send_to_d_channel (REL_COMP);
							Send_to_call_control (NS_CLEAR_CO);
							call_clear ();
						}

					}

				}

			}

#			if NS_RESTART_PROCEDURE == ON /* { */

				else {		/* NON CALL-ASSOCIATED */

					switch (Dl_rest_state) {

						case STATE_REST_0 :
							break;

						case STATE_REST_1 :

							if (I_call_state_val != STATE_REST_2) {
								ns_stop_all_dlci_timers ();
								ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_STATE_INCOMP);
								Dl_restart_reset ();
							}

							break;

						case STATE_REST_2 :

							if (I_call_state_val != STATE_REST_1) {
								ns_snd_mns (MNS_RESTART_IN);
							}

							break;

					}
				}

#			endif /* RESTART_PROCEDURE = ON} */

			return (OK);

						/* NS INFORMATION REQUEST */

		case  NS_INFO_RQ :

			if (!Call_current_exist) {

            	if (Ns_access_dl_ces (I_(endpoint_id, ces)) == OK) {

					if ((is_ie_i (CODESET_0, CAUSE) == PRESENT) ||
                    	(is_ie_i (CODESET_0, INFORMATION_RQ) == PRESENT)) {
						discard_ie_i (CODESET_0, ENDPOINT_ID);
                    }

					Send_to_d_channel (INFO);
                }

				return (OK);
            }

			switch (Call_state) {

				case STATE_CALL_PRESENT_6 :
					/* no process */
					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :

					/* else default case */

				default :
					Send_to_d_channel (INFO);
					break;
			}

			return (OK);

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_state (Call_state);
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			Send_to_d_channel (STATUS);
			return (OK);

						/* NS_STATUS_ENQ_RQ */

		case NS_STATUS_ENQ_RQ :

			Send_to_d_channel (STATUS_ENQ);
			return (OK);


#		if NS_RESTART_PROCEDURE == ON /* { */

			case TI_316 :

				if (Dl_rest_state == STATE_REST_1) {

					if (++N316 == DMS_MX_N316) {

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_316);
						Dl_restart_reset ();

					} else {

						Set_call_ref_not_nil ();

							/* store Restart Indicator with value saved in DL context */

						set_ie_i (CODESET_0, RESTART_IND);
						I_restart_ind_class = Dl_rest_class;

						if (I_restart_ind_class != RI_ALL_INTERFACES) {

								/* store Channel-ID */

							ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
							set_ie_i (CODESET_0, CHAN_ID);

							I_chan_id_d_chan 	= NOT_D_CHAN;		/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;		/* Exclusive */
							I_chan_id_int_type  = INT_TYPE_PRI;		/* PRI */

#							if NS_MAINTENANCE_CAPABILITY == ON

								if (Dl_rest_int_id != Nai) {
									I_chan_id_int_id 	= INT_ID_EXPLICIT;
									I_chan_id_int_id_val= Dl_rest_int_id;
								}

#							endif

							if (I_restart_ind_class == RI_SINGLE_INTERFACE) {
								I_chan_id_chan_sel  = NO_CHAN;			/* No channel */

							} else {
								I_chan_id_chan_sel  = AS_INDICATED;		/* Channel Number as indicated in following octets */
								I_chan_id_chan_type	= B_CHAN;			/* B-Channel number */
								I_chan_id_chan_nb   = Dl_rest_chan_nb;	/* channel number */

							}
						}

						Send_to_d_channel (RESTART);			/* with CALL_REF_GLOBAL */
						Restart_dl_timer (DMS_T316);
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case TI_317 :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

					if (Nfas_nai_mode == NFAS_TSP) {

						if (ns_access_na (Nfas_cfg_nai_active_d_chan) != OK) {
							return (NOK);
						}
					}

#				endif


				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
						Dl_restart_reset ();
						break;

					default :

						ns_unexpected_ev ();
				}

				return (OK);

			case DA_RESTART :

#				if NS_MAINTENANCE_CAPABILITY == ON
					dms_restart_maint (DA_RESTART);
#				else

					if (Dl_rest_state == STATE_REST_0) {
						Start_dl_timer (DMS_T317);
						Set_call_ref_nil ();		/* to use CONN_ID_MANAGEMENT */
						Send_to_call_control (NS_RESTART_IN);
						Dl_rest_state = STATE_REST_2;

					} else {

						ns_unexpected_ev ();
					}

#				endif

				return (OK);

			case DA_RESTART_ACK :

#				if NS_MAINTENANCE_CAPABILITY == ON
					dms_restart_maint (DA_RESTART_ACK);
#				else

					if (Dl_rest_state == STATE_REST_1) {

						Stop_dl_timer (DMS_T316);

						if (Dl_rest_resp == ON) {

							ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
							Dl_restart_reset ();

						} else {

							Dl_rest_ack = ON;
						}

					} else {

						ns_unexpected_ev ();
					}

#				endif

				return (OK);

			case NS_RESTART_RS :

#				if NS_MAINTENANCE_CAPABILITY == ON
					dms_restart_maint (NS_RESTART_RS);
#				else

					Stop_dl_timer (DMS_T317);

					switch (Dl_rest_state) {

						case STATE_REST_1 :

							if (Dl_rest_ack == ON) {

								ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
								Dl_restart_reset ();

							} else {

								Dl_rest_resp = ON;
							}

							break;

						case STATE_REST_2 :

							Set_call_ref_not_nil ();
							Send_to_d_channel (RESTART_ACK);
							Dl_restart_reset ();
							break;

						default :

							ns_unexpected_ev ();
					}

#				endif

				return (OK);

			case NS_RESTART_RQ :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

#				endif

				if (Dl_rest_state != STATE_REST_0) {

					call_clear ();

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#		endif /* RESTART_PROCEDURE = ON} */

#		if NS_MAINTENANCE_CAPABILITY == ON

			case TI_321 :
			case TI_3DW :
			case TI_3MB :
			case TI_3M1 :
			case DA_MAINT_SERVICE :
			case DA_MAINT_SERVICE_ACK :
            
            	if ((i_entity_origination == ENT_TI) &&(event_id == TI_303)) {
                	break;
                } else {
					dms_bkp_maint_proc (event_id, Nai);
					return (OK);
                }

#		endif

	} /* End switch (event_id) */


/*.........................................................................*/

				/* 2 - STATE DRIVEN PROCESS */

			/*
					 Switch according to the call state :

			   Dispatch to the function that processes the state except if
			   it is a clearing event not received  in an exceptional condition.
			   In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "dms_circuit_switched_call_n");
	}

#	if NS_MAINTENANCE_CAPABILITY == ON

			/*
             * Make sure the DL context is the active one when
             * enterring automaton.
             */
             
		if ((ns_nfas == ON) && (Nfas_context_exist)) {
		    p_nsdl = Nfas_dl_p_active_d_chan;
        }

#	endif

	switch (Call_state) {

			/* Null state (n0) */

		case STATE_NULL_0 :
			dms_n0 ();
			break;

			/* Call initiated (n1) */

		case STATE_CALL_INIT_1 :
			dms_n1 ();
			break;

			/* Overlap sending (n2) */

		case STATE_OVERLAP_SENDING_2 :
			dms_n2 ();
			break;

			/* Outgoing call proceeding (n3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			dms_n3 ();
			break;

			/* Call delivered (n4) */

		case STATE_CALL_DELIVERED_4 :
			dms_n4 ();
			break;

			/* Call present (n6) */

		case STATE_CALL_PRESENT_6 :
			dms_n6 ();
			break;

			/* Call received (n7) */

		case STATE_CALL_RECEIVED_7 :
			dms_n7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			dms_n8 ();
			break;

			/* Incoming call proceeding (n9) */

		case STATE_INCOMING_CALL_PROC_9 :
			dms_n9 ();
			break;

			/*  Active (n10) */

		case STATE_ACTIVE_10 :
			dms_n10 ();
			break;

			/* Disconnect request (n11) */

		case STATE_DISCONNECT_REQUEST_11 :
			dms_n11 ();
			break;

			/* Disconnect indication (n12) */

		case STATE_DISCONNECT_INDICATION_12 :
			dms_n12 ();
			break;

			/* Release request (n19) */

		case STATE_RELEASE_REQUEST_19 :
			dms_n19 ();
			break;


			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "dms_circuit_switched_call_n");

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_csc_dl_reinit_n () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN).

Usage           	void dms_csc_dl_reinit_n ();

Related
functions usage		void send_state (uchar class, uchar value, uchar diagnostic);

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

void dms_csc_dl_reinit_n ()
{
	/* nothing to do */
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dms_ns_ei - implements the endpoint initialization procedure
				for the DMS100 control of maintenance actions.

Usage           uchar ns_ei (void);

Return value    return code = CONTINUE	continue the processing,
							= STOP		wait for DL establishment,
							= NOK       the call state is errored.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar dms_ns_ei (ei_event, ces)
	code_t	ei_event;	/* Endpoint Initialization Event */
	ces_t	ces;		/* CES */
{

#if NS_TYPE_BRI == ON

		/* Meaningless for PRImary rate */

	if (Na_type == PRI) return (OK);

		/* Meaningless for BRI in POINt to POINT configuration */

	if ((Na_type == BRI) && (Na_connection == POINT_TO_POINT)) return (OK);

	if ((! Dl_current_exist) ||
		(Dl_ces == DL_CES_BROADCAST)) {
		Ns_access_dl_ces (ces);
	}

					/* STATE DRIVEN AUTOMATON */

	switch (Dl_ei_state) {

				/* Power down */

		case EI_STATE_DOWN :

			if (ei_event == MNS_NA_POWER_ON_RQ) {

				Dl_ei_state = EI_STATE_AWAIT_ASSIGN;

				/* TEI should be initialized from now */

			} else {

				return (STOP);
			}

			break;


		case EI_STATE_AWAIT_ASSIGN :

			switch (ei_event) {

				case MNS_DL_DLCI_RQ :

						/* Tei assigned */

					if ((Rcv_dl_code == DL_TEI_ASSIGNMENT) &&
						( Lc_state == LC_RELEASED )) {
						ns_snd_dl (DL_EST_RQ, ces);
						Lc_state = LC_AWAITING_EST;
					}

					Dl_ei_state = EI_STATE_AWAIT_EST;

						/* Tei denied.
						 * SM has already sent a TEI_RQ
						 */

					if (Rcv_dl_code == DL_TEI_REMOVAL) {
						break;
					}

					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				default :
					return (STOP);
			}

			break;

		case EI_STATE_AWAIT_EST :

			switch (ei_event) {

					/* Layer 2 established */

				case DL_EST_CO :
					Dl_ei_orig = TO_D_CHANNEL;
					dms_send_init ();
					Dl_ei_state = EI_STATE_AWAIT_INIT;
					break;


				case DL_REL_IN :
					ns_snd_dl (DL_EST_RQ, ces);
					Lc_state = LC_AWAITING_EST;
					break;

						/* Tei remove */

				case MNS_DL_DLCI_RQ :

					if (Rcv_dl_code == DL_TEI_REMOVAL) {
						Dl_ei_state = EI_STATE_AWAIT_ASSIGN;
					}

					break;

				case EV_NO_USID_TID :	/* it must be a SETUP */
				case EV_BROADCAST_WITH_USID_TID :

						/* process received message */

					break;

					/* Power OFF */

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				default :

					return (STOP);
			}

			break;


		case EI_STATE_AWAIT_INIT  :

			switch (ei_event) {

				case EV_INIT_RQ :

						/* Switch requests initialization */

					dms_send_init ();
					Dl_ei_state = EI_STATE_AWAIT_INIT;
					break;

					/* Network supports Endpoint Initialization */

				case EV_ASSIGN_USID_TID :
					Stop_dl_timer (TSPID);
					Dl_usid = I_(endpoint_id, usid);			/* load the USID */
					Dl_tid	= I_(endpoint_id, tid);				/* load the TID */
					Dl_ei_state = EI_STATE_INIT;

#					if NS_EVENT_REPORT == ON

							/* Send the event to MNS */

						ns_send_mns_event (NS_EVENT_SPID_OK, 0);

#					endif

						/* Process the waiting queue */

					ns_process_queue ();

					break;

				case EV_REJECT_SPID_100 :
					Stop_dl_timer (TSPID);

						/* Switch rejection due to bad SPID IE */

					Dl_ei_state = EI_STATE_NOT_INIT;
					break;

				case EV_REJECT :
					Stop_dl_timer (TSPID);

						/* Switch does not support initialization */

					Dl_ei_state = EI_STATE_NOT_SUPPORTED;
					break;

				case EV_NO_USID_TID :

						/* process message */

					return (CONTINUE);

				case EV_BROADCAST_WITH_USID_TID :

						/* Discard received message */

					return (STOP);

				case EV_USER_ASSIGN_SPID :
					dms_send_init ();
					break;

				case EV_USER_ACTION :
				case DL_EST_IN :
				case DL_EST_CO :
					break;

				case DL_REL_IN :
					ns_snd_dl (DL_EST_RQ, ces);
					Lc_state = LC_AWAITING_EST;
					break;

				case MNS_DL_DLCI_RQ :

					if (Rcv_dl_code == DL_TEI_REMOVAL) {
						Stop_dl_timer (TSPID);
						Dl_ei_state = EI_STATE_AWAIT_ASSIGN;
					}
					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				case TI_SPID :

					if (Dl_ei_orig == TO_D_CHANNEL) {
						dms_send_init ();

					} else {

						Dl_ei_state = EI_STATE_INIT;

#						if NS_EVENT_REPORT == ON

								/* Send the event to MNS */

							ns_send_mns_event (NS_EVENT_SPID_OK, 0);

#						endif
					}

					break;

				default :
					return (STOP);

			}

			break;


		case EI_STATE_INIT :

			switch (ei_event) {

				case EV_INIT_RQ :

						/* Switch requests initialization */

					dms_send_init ();
					break;

				case EV_REJECT_SPID_100 :
					Stop_dl_timer (TSPID);

						/* Switch rejection due to bad SPID IE */

					Dl_ei_state = EI_STATE_NOT_INIT;
					break;

					/* Network supports Endpoint Initialization */

				case EV_ASSIGN_USID_TID :
					Stop_dl_timer (TSPID);
					Dl_usid = I_(endpoint_id, usid);			/* load the USID */
					Dl_tid	= I_(endpoint_id, tid);				/* load the TID */

						/* Process the waiting queue */

					ns_process_queue ();

					break;

				case EV_REJECT :
					Stop_dl_timer (TSPID);

						/* Switch does not support initialization */

					Dl_ei_state = EI_STATE_NOT_SUPPORTED;
					break;

				case EV_NO_USID_TID :
					break;

				case EV_BROADCAST_WITH_USID_TID :
				case EV_NOT_BROADCAST_WITH_USID_TID :

						/*
						 * If any message with on matching USID/TID
						 * discard message.
						 */

					if (dms_match_usid_tid (I_endpoint_id_usid, I_endpoint_id_tid, I_endpoint_id_interp) == FALSE) {
						return (STOP);
					}

					break;

				case EV_USER_ASSIGN_SPID :
					dms_send_init ();
					Dl_ei_state = EI_STATE_AWAIT_INIT;
					break;

				case EV_USER_ACTION :
				case DL_EST_IN :
				case DL_EST_CO :
					break;

				case DL_REL_IN :

					if ((Dl_backup == OFF) && (Lc_state != LC_AWAITING_EST)) {
						ns_snd_dl (DL_EST_RQ, ces);
						Lc_state = LC_AWAITING_EST;
					}

					break;

				case MNS_DL_DLCI_RQ :

					if (Rcv_dl_code == DL_TEI_REMOVAL) {
						Dl_ei_state = EI_STATE_AWAIT_ASSIGN;
					}
					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				case TI_SPID :

					if (Dl_ei_orig == TO_D_CHANNEL) {
						dms_send_init ();

					} else {

						Dl_ei_state = EI_STATE_INIT;

#						if NS_EVENT_REPORT == ON

								/* Send the event to MNS */

							ns_send_mns_event (NS_EVENT_SPID_OK, 0);

#						endif
					}

					break;

				default :

					return (STOP);
			}

			break;


		case EI_STATE_NOT_INIT :

			switch (ei_event) {

				case EV_INIT_RQ :

						/* Switch requests initialization */

					dms_send_init ();
					Dl_ei_state = EI_STATE_AWAIT_INIT;
					break;

				case EV_USER_ASSIGN_SPID :
					dms_send_init ();
					Dl_ei_state = EI_STATE_AWAIT_INIT;
					break;

				case EV_USER_ACTION :

						/* No action */

					return (STOP);

				case EV_NO_USID_TID :

						/* Process message */

					break;

				case EV_BROADCAST_WITH_USID_TID :

						/* No action */

					return (STOP);

				case DL_REL_IN :
					ns_snd_dl (DL_EST_RQ, ces);
					Lc_state = LC_AWAITING_EST;
					break;

						/* Tei remove */

				case MNS_DL_DLCI_RQ :

					if (Rcv_dl_code == DL_TEI_REMOVAL) {
						Dl_ei_state = EI_STATE_AWAIT_ASSIGN;
					}
					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;


				default :
					return (STOP);
			}

			break;


		case EI_STATE_NOT_SUPPORTED :

			switch (ei_event) {

				case EV_USER_ASSIGN_SPID :
				case DL_EST_IN :
				case DL_EST_CO :

						/* No action */

					return (STOP);

				case DL_REL_IN :
					ns_snd_dl (DL_EST_RQ, ces);
					Lc_state = LC_AWAITING_EST;
					break;

				case EV_USER_ACTION :
					return (CONTINUE);

				case MNS_DL_DLCI_RQ :

					if (Rcv_dl_code == DL_TEI_REMOVAL) {
						Dl_ei_state = EI_STATE_AWAIT_ASSIGN;
					}

					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				default :
					return (STOP);
			}

			break;

		default :

#			if ASSERT == ON
				Trap (TRAP_EI_STATE, "dms_ns_ei");
#			endif

			break;

	}

#	endif

	return (CONTINUE);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dms_send_init - implements the endpoint initialization procedure
				for the DMS100 control of maintenance actions.

Usage           void dms_send_init (void);

Return value    none.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

void dms_send_init ()
{

#if NS_TYPE_BRI == ON

	uchar i;

		/* Meaningless for PRImary rate */

	if (Na_type == PRI) return;

		/* Meaningless for BRI in POINt to POINT configuration */

	if ((Na_type == BRI) && (Na_connection == POINT_TO_POINT)) return;

		/* If no SPID to be load, nothing to do. */

	if (Dl_is_spid_nil) return;


		/* Copy SPID string in the generic tempo pointer */

	i = Strcpy_far	((char FAR *) p_ind_buffer,
					 (char FAR *) Dl_a_spid,
					 DMS_MX_SZ_SPID+1);

		/* load SPID in internal structure */

	I_(spid, lgth)		= i-1;
	I_(spid, p_spid)	= p_ind_buffer;

	Reset_internal_ie ();

		/* Store SPID Information Element in the message */

	set_ie_i			(CODESET_0, SPID);

		/* Set call reference nil */

	Set_call_ref_nil	();

		/* Send INFO message to the network. */

	Send_to_d_channel	(INFO);

	Start_dl_timer		(TSPID);

#endif

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dms_match_usid_tid - implements TID/USID checking.

Usage           uchar dms_match_usid_tid (usid, tid, interp);

Return value    none.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar dms_match_usid_tid (usid, tid, interp)
	uchar usid;
	uchar tid;
	uchar interp;
{

	if (nb_ie_i (CODESET_0, ENDPOINT_ID) > 1) {

			/*
			 * In case of repetition, ensure the second instance did not
			 * specify a 'broadcast' usid. If yes, return TRUE.
			 */

		if (i_endpoint_id[1].usid == USID_ALL) return (TRUE);
	}


	if (usid == USID_ALL) return (TRUE);

	if (usid == Dl_usid) {

			/* USID matches */

		if (tid == BYTE_VAL_NIL) {

				/* No TID was included */

			return (TRUE);

		}

		if (interp == INTERPRETER_0) {

				/*
				 * Terminal is selected if it is assigned the indicated TID
				 * and USID value, or if tid equals TID_ALL.
				 */


			if ((tid == Dl_tid) || (tid == TID_ALL)) {
				 return (TRUE);
			}

		} else {

				/*
				 * Terminal is selected if it is not assigned the indicated
				 * TID but it is assigned the USID, or tid equals TID_ALL.
				 */


			if ((tid != Dl_tid) || (tid == TID_ALL)) {
				 return (TRUE);
			}

		}
	}

	return (FALSE);
}

/*-------------------------------------------------------------------------*/

						/*----------------------*/
						/*                   	*/
						/*   D channel backup	*/
						/*	   Maintenance		*/
						/*						*/
						/*	  procedures		*/
						/*						*/
						/*----------------------*/


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_bkp_maint_proc () -

Usage           	uchar dms_proc_filter (code, nai);
					Note : nai is not used.


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar dms_bkp_maint_proc (code, nai)
	code_t	code;
	nai_t	nai;

{

	uchar FAR *p_data;

#if NS_D_BACKUP == ON /* { */

	uchar 		FAR *p_line_d_chan_state;
	uchar 		FAR *p_other_d_chan_state;

	struct nsdl FAR *p_line_nsdl, *p_other_nsdl;
	struct nsna FAR *p_line_nsna, *p_other_nsna;

	uchar d_chan_found;
	nai_t int_id;

#endif /* } */


		/* B or D channel management ? */

	switch (code) {

		case DA_MAINT_SERVICE :
		case DA_MAINT_SERVICE_ACK :

			if (I_(chan_id, d_chan) == NOT_D_CHAN) {

					/* B chanel management */

				return (dms_b_chan_maint (code));

			}

			break;

			/*
			 * B chanel management for MNS/ENT_TI :
			 * Already processed in the circuit_swithed_call ().
			 */

	}

		/* D channel management */


#	if NS_D_BACKUP == OFF /* { */

			/*
			 * This code implements the SINGLE D channel management.
			 */

		return (dms_single_d_chan_maint (code));

#	else	/* }{ */


		if (ns_nfas == OFF) {

				/*
				 * This code implements the SINGLE D channel management.
				 */

			return (dms_single_d_chan_maint (code));
		}


			/*
			 * This code implements the D channel Backup.
			 */

		d_chan_found = FALSE;
		p_data 		 = p_ssdu;

		if (code == MNS_SERVICE_RQ) {
			int_id = Mns_service_int_id;

		} else {

			int_id = Nai;
		}

		if (int_id == Nfas_nai_active_d_chan) {
			p_line_d_chan_state  = (uchar FAR *)&Nfas_active_d_chan_status;
			p_other_d_chan_state = (uchar FAR *)&Nfas_backup_d_chan_status;
			p_line_nsdl			 = Nfas_dl_p_active_d_chan;
			p_nsna				 = p_line_nsna = Nfas_nai_p_active_d_chan;
			p_other_nsna		 = Nfas_nai_p_backup_d_chan;
			p_nsdl		   		 = Nfas_dl_p_active_d_chan;
			p_other_nsdl   		 = Nfas_dl_p_backup_d_chan;
			d_chan_found   	 	 = TRUE;
		}

		if (int_id == Nfas_nai_backup_d_chan) {
			p_line_d_chan_state  = (uchar FAR *)&Nfas_backup_d_chan_status;
			p_other_d_chan_state = (uchar FAR *)&Nfas_active_d_chan_status;
			p_line_nsdl			 = Nfas_dl_p_backup_d_chan;
			p_nsna			 	 = p_line_nsna = Nfas_nai_p_backup_d_chan;
			p_other_nsna		 = Nfas_nai_p_active_d_chan;
			p_nsdl		   		 = Nfas_dl_p_backup_d_chan;
			p_other_nsdl   		 = Nfas_dl_p_active_d_chan;
			d_chan_found   		 = TRUE;
		}


		if (d_chan_found == FALSE) {
			ns_send_mns_service (I_WRONG_NAI,Mns_service_int_id, I_chan_id_chan_nb);
			return (STOP);
		}

		switch (*p_line_d_chan_state) {

			case MAINT_STATE_IS :

				switch (code) {

					case DA_MAINT_SERVICE :
						dms_send_service (Nfas_nai_line, ON);
						break;

					case DL_REL_IN :
						dms_layer3_failure ();
						break;

					case MNS_SERVICE_RQ :
						ns_send_mns_service (I_NO_ACTION, Mns_service_int_id, I_chan_id_chan_nb);
						break;
				}

				break;

			case MAINT_STATE_OOS :

				switch (code) {

					case DL_EST_CO :
					case DL_EST_IN :
						Stop_dl_timer (DMS_T3DW);
						Lc_state = LC_ESTABLISHED;

							/*
							 * When a layer 2 is established on a D-channel
							 * and the other is not in the IS, WAIT or STBY,
							 * Layer 3 establishment begins.
							 * Send a SERVICE (IS).
							 * Start T321.
							 */

						if ((*p_other_d_chan_state != MAINT_STATE_IS)	&&
							(*p_other_d_chan_state != MAINT_STATE_WAIT) &&
							(*p_other_d_chan_state != MAINT_STATE_STBY)) {

							dms_send_service (Nfas_nai_line, OFF);
							Start_dl_timer (DMS_T321);
							*p_line_d_chan_state = MAINT_STATE_WAIT;

						} else {

							*p_line_d_chan_state   = MAINT_STATE_STBY;
						}

						break;

					case DL_REL_IN :
						dms_layer3_failure ();
						break;

					case TI_3DW :

							/* Resend to DL a DL_EST_RQ */

						Send_to_dl (DL_EST_RQ, DL_CES_SIG);
						Lc_state = LC_AWAITING_EST;

							/* Start T3DW */

						Start_dl_timer (DMS_T3DW);

						break;

					case MNS_SERVICE_RQ :
						ns_send_mns_service (I_NO_ACTION, Mns_service_int_id, I_chan_id_chan_nb);
						break;
				}

				break;

			case MAINT_STATE_MOOS :

				switch (code) {

					case MNS_SERVICE_RQ :

						switch (Mns_service_status) {

							case MAINT_STATE_OOS :

									/* Send to DL a DL_EST_RQ */

								Send_to_dl (DL_EST_RQ, DL_CES_SIG);
								Lc_state = LC_AWAITING_EST;

									/* Start T3DW */

								Start_dl_timer (DMS_T3DW);

									/* Move to OOS */

								*p_line_d_chan_state = MAINT_STATE_OOS;

								if (Nai != Nfas_nai_line) {

									ns_access_na (Nfas_nai_line);
								}

								ns_send_mns_service (OK,Mns_service_int_id, I_chan_id_chan_nb);
								break;

							case MAINT_STATE_INB :
								*p_line_d_chan_state = Mns_service_status;
								set_ie_i (CODESET_0, CHANGE_STATUS);

								if (Nai != Nfas_nai_line) {

									ns_access_na (Nfas_nai_line);
								}

								ns_send_mns_service (OK,Mns_service_int_id, I_chan_id_chan_nb);
								break;

						}

						break;
				}

				break;

			case MAINT_STATE_INB :

				if (code == MNS_SERVICE_RQ) {

					if (Nai != Nfas_nai_line) {

						ns_access_na (Nfas_nai_line);
					}

					*p_line_d_chan_state = MAINT_STATE_MOOS;
					set_ie_i (CODESET_0, CHANGE_STATUS);
					ns_send_mns_service (OK,Mns_service_int_id, I_chan_id_chan_nb);
				}

				break;

			case MAINT_STATE_STBY :

				switch (code) {

					case DA_MAINT_SERVICE :

						if ((Nfas_nai_line == Nfas_nai_backup_d_chan) &&
							(I_(change_status, status) == CHANNEL_IN_SERVICE)) {
							dms_switch_d_channel (DA_MAINT_SERVICE);
						}

						break;

					case MNS_SERVICE_RQ :
						ns_send_mns_service (I_NO_ACTION, Mns_service_int_id, I_chan_id_chan_nb);
						break;

				}

				break;

			case MAINT_STATE_MB :

				switch (code) {

					case TI_3MB :

						if (Lc_state != LC_ESTABLISHED) {

							Send_to_dl (DL_EST_RQ, DL_CES_SIG);
							Lc_state = LC_AWAITING_EST;
							Start_dl_timer (DMS_T3DW);
							*p_line_d_chan_state   = MAINT_STATE_OOS;

						} else {

							*p_line_d_chan_state   = MAINT_STATE_STBY;

						}

						break;

					case MNS_SERVICE_RQ :
						ns_send_mns_service (I_NO_ACTION, Mns_service_int_id, I_chan_id_chan_nb);
						break;
				}

				break;

			case MAINT_STATE_WAIT :

				switch (code) {

					case DA_MAINT_SERVICE :
					case DA_MAINT_SERVICE_ACK :

							/* Stop T321 */

						Stop_dl_timer (DMS_T321);

							/*
							 * If the other D channel is in the MB state,
							 * 	- stop T3MB,
							 *	- move the other D channel to the OOS state,
							 *	- attempt to establish layer 2 on the other D channel.
							 */

						if (*p_other_d_chan_state == MAINT_STATE_MB) {

							p_nsdl = p_other_nsdl;
							p_nsna = p_other_nsna;
							Stop_dl_timer  (DMS_T3MB);
							Start_dl_timer (DMS_T3DW);

							if (Lc_state != LC_ESTABLISHED) {
								Send_to_dl (DL_EST_RQ, DL_CES_SIG);
								Lc_state 			  = LC_AWAITING_EST;
							}

							*p_other_d_chan_state = MAINT_STATE_OOS;
							p_nsdl 				  = p_line_nsdl;
							p_nsna 				  = p_line_nsna;
						}

							/*
							 * If the message received is SERVICE,
							 * send back a SERVICE_ACK (IS).
							 */

						if (code == DA_MAINT_SERVICE) {
							dms_send_service (Nfas_nai_line, ON);
						}


							/*
							 * Switch Active/Backup D channels.
							 */

						if (int_id != Nfas_nai_active_d_chan) {
							dms_switch_d_channel (code);

						} else {

							*p_line_d_chan_state = MAINT_STATE_IS;
							ns_nfas_stop_309 ();

						}

						break;

					case NS_RESTART_RS :
						*p_line_d_chan_state = MAINT_STATE_IS;
						break;

					case DL_REL_IN :
						dms_layer3_failure ();
						break;

					case TI_321 :

						if ((*p_other_d_chan_state == MAINT_STATE_STBY) ||
							(*p_other_d_chan_state == MAINT_STATE_OOS)) {

							dms_switch_d_channel (TI_321);

						} else {

							Start_dl_timer (DMS_T3DW);
							Send_to_dl (DL_EST_RQ, DL_CES_SIG);
							Lc_state = LC_AWAITING_EST;
							*p_line_d_chan_state = MAINT_STATE_OOS;
						}

						break;

					case MNS_SERVICE_RQ :
						ns_send_mns_service (I_NO_ACTION, Mns_service_int_id, I_chan_id_chan_nb);
						break;

				}

				break;
		}

		return (OK);

#	endif /* } */

}

#endif /* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_filter () -

Usage           	uchar dms_filter (code, nai);
					Note : nai is not used.


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar dms_filter (code, nai)
	code_t		code;
	nai_t		nai;
{
	uchar 	d_chan_state;

	nai		+= nai;

	switch (R_msg_from) {

		case ENT_CC :
			return (CONTINUE);

		case ENT_DL :
		case ENT_DL_D :

				/*
				 * The filtering will be performed below.
				 */

			break;

		default :
			return (CONTINUE);
	}


					/* DL filter */

	if (Ns_access_dl_ces (DL_CES_SIG) == NOK) {
		return (STOP);
	}

	if (ns_nfas == OFF) {

		d_chan_state = Dl_d_chan_state;

	} else {

		if (Nfas_nai_line == Nfas_nai_active_d_chan) {
			d_chan_state = Nfas_active_d_chan_status;

		}

#		if NS_D_BACKUP == ON

			if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

				d_chan_state = Nfas_backup_d_chan_status;
			}

#		endif

	}

	switch (code) {

		case DL_EST_IN :
		case DL_EST_CO :

				/*
				 * While in the INB state, attemps to establish layer 2
				 * are rejected. (4-150)
				 */

			if ((d_chan_state == MAINT_STATE_INB)	||
				(d_chan_state == MAINT_STATE_MB)	||
				(d_chan_state == MAINT_STATE_MOOS)) {

				Send_to_dl (DL_REL_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_REL;
				return (STOP);
			}

			break;

	}

	return (CONTINUE);
}

#endif /* } NS_MAINTENANCE_CAPABILITY*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_single_d_chan_maint () -

Usage           	uchar dms_single_d_chan_maint (code);


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar dms_single_d_chan_maint (code)
	code_t code;
{

	uchar FAR *p_data;

	p_data = p_ssdu;

	switch (Dl_d_chan_state) {

		case MAINT_STATE_IS :

			switch (code) {

				case MNS_SERVICE_RQ :

					switch (Mns_service_status) {

						case MAINT_STATE_MOOS :

								/* Send to DL a DL_REL_RQ */

							Send_to_dl (DL_REL_RQ, DL_CES_SIG);
							Lc_state = LC_AWAITING_REL;

								/* Start T3DW */

							Start_dl_timer (DMS_T3DW);

								/* Move to MOOS */

							Dl_d_chan_state = MAINT_STATE_MOOS;

							break;

					}

					break;

				case DL_REL_IN :

						/* Start T3DW */

					Start_dl_timer (DMS_T3DW);
					Dl_d_chan_state = MAINT_STATE_OOS;
					break;
			}

			break;

		case MAINT_STATE_OOS :

			switch (code) {

				case MNS_SERVICE_RQ :

					switch (Mns_service_status) {

						case MAINT_STATE_MOOS :

								/* Start T3DW */

							Start_dl_timer (DMS_T3DW);

								/* Move to OOS */

							Dl_d_chan_state = MAINT_STATE_MOOS;

							break;

					}

					break;

				case NS_RESTART_RS :
					Dl_d_chan_state = MAINT_STATE_IS;
					break;

				case DL_EST_CO :
					Stop_dl_timer (DMS_T3DW);
					break;

				case TI_3DW :

						/* Resend to DL a DL_EST_RQ */

					Send_to_dl (DL_EST_RQ, DL_CES_SIG);
					Lc_state = LC_AWAITING_EST;

						/* Start T3DW */

					Start_dl_timer (DMS_T3DW);

					break;
			}

			break;

		case MAINT_STATE_MOOS :

			switch (code) {

				case MNS_SERVICE_RQ :

					switch (Mns_service_status) {

						case MAINT_STATE_OOS :

								/* Send to DL a DL_EST_RQ */

							Send_to_dl (DL_EST_RQ, DL_CES_SIG);
							Lc_state = LC_AWAITING_EST;

								/* Start T3DW */

							Start_dl_timer (DMS_T3DW);

								/* Move to OOS */

							Dl_d_chan_state = MAINT_STATE_OOS;

							break;

						case MAINT_STATE_INB :
							Dl_d_chan_state = Mns_service_status;
							set_ie_i (CODESET_0, CHANGE_STATUS);
							ns_send_mns_service (OK,Mns_service_int_id, I_chan_id_chan_nb);
							break;

					}

					break;

				case TI_3DW :

						/* Ignore */

					break;
			}


			break;

		case MAINT_STATE_INB :

			if (code == MNS_SERVICE_RQ) {

				Dl_d_chan_state = MAINT_STATE_MOOS;
				set_ie_i (CODESET_0, CHANGE_STATUS);
				ns_send_mns_service (OK,Mns_service_int_id, I_chan_id_chan_nb);
			}

			break;
	}

	return (OK);
}


#endif /* } NS_MAINTENANCE_CAPABILITY*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_b_chan_maint () -

Usage           	uchar dms_b_chan_maint (code);


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON	/* { */

uchar dms_b_chan_maint (code)
	code_t	 code;
{

	nai_t int_id;
	uchar b_chan, b_chan_state, b_chan_max, send_service_co;


	send_service_co = ON;
	int_id 			= Nai;
	b_chan			= BYTE_VAL_NIL;

		/*
		 * Get the interface Id
		 */

	if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

		if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {
			int_id = I_(chan_id, int_id_val);
		}

		if (I_chan_id_chan_sel != NO_CHAN) {

				/* A specific B channel is used */

			b_chan = I_chan_id_chan_nb;
			b_chan = Reset_ext_bit (b_chan);
		}
	}

	b_chan_max = NS_MX_B_CHAN_T1 - 1;

#	if NS_D_BACKUP == ON

		if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

			if ((int_id != Nfas_nai_active_d_chan) && (int_id != Nfas_nai_backup_d_chan)) {

				b_chan_max = NS_MX_B_CHAN_T1;
			}
		}

#	endif

	switch (code) {

		case DA_MAINT_SERVICE :

			if (b_chan != BYTE_VAL_NIL) {

				b_chan_state = Dl_b_chan_mode_int (int_id, b_chan);

				if (Dl_b_chan_mode_int (int_id, b_chan) == I_(change_status, status)) {
					send_service_co = OFF;
				}

				Dl_b_chan_mode_int (int_id, b_chan) = I_(change_status, status);

			} else {

					/* No B channel indicated (should never happen) */

				send_service_co = OFF;
			}

				/* Send back a SERVICE_ACK */

			Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINTENANCE);

			if (send_service_co == ON) {

					/* Send the information to the applciation */

				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK, int_id, I_chan_id_chan_nb);
			}

			break;

		case DA_MAINT_SERVICE_ACK :

			if (b_chan != BYTE_VAL_NIL) {

				b_chan_state = Dl_b_chan_mode_int (int_id, b_chan);

				if (Dl_b_chan_mode_int (int_id, b_chan) == I_(change_status, status)) {
					send_service_co = OFF;
				}

				Dl_b_chan_mode_int (int_id, b_chan) = I_(change_status, status);

			} else {

					/* No B channel indicated (should never happen) */

				send_service_co = OFF;
			}


			Stop_dl_timer (DMS_T3M1);

			if (send_service_co == ON) {

					/* Send the information to the applciation */

				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK, int_id, I_chan_id_chan_nb);
			}

				/*
				 * If we are in the process of sending multiple
				 * RESTART or SERVICE to the line, check if
				 * this procedure is completed.
				 */

			if (Dl_b_chan_restart_nb > 0) 	{

				if (b_chan_state == MAINT_STATE_B_OOS_FE_REST) {

						/*
						 * The MAINT_SERVICE_ACK we just received
						 * completed the process of adding this B channel
						 * to service.
						 * Continue the process for the other B channels
						 * by initiating a RESTART for the next B channel.
						 */


					if (b_chan < b_chan_max) {

							/* Process next B channel */

						b_chan++;
					}

					Dl_rest_chan_nb = b_chan;

					I_chan_id_chan_nb = b_chan;
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_REST;
					I_(restart_ind, restart_class) 		= RI_INDICATED_CHANNEL;

					set_ie_i (CODESET_0, RESTART_IND);

					Set_call_ref_nil ();
					Send_to_call_control (NS_RESTART_IN);			/* on CONN_ID_MANAGEMENT */

					Start_dl_timer (DMS_T317);

					Set_call_ref_not_nil ();
					Send_to_d_channel (RESTART);					/* with CALL_REF_GLOBAL */

					N316 = 0;
					Start_dl_timer (DMS_T316);
					Dl_rest_state = STATE_REST_1;
				}

				if (b_chan_state == MAINT_STATE_B_OOS_MAINT_NE) {

						/*
						 * The MAINT_SERVICE_ACK we just received
						 * completed the process of removing this B channel
						 * to service.
						 * Continue the process for the other B channels
						 * by initiating a SERVICE for the next B channel.
						 */

					if (b_chan < b_chan_max) {

							/* Process next B channel */

						Dl_b_chan_restart_nb--;
						b_chan++;
						I_chan_id_chan_nb = b_chan;
						I_(change_status, status) = CHANNEL_OUT_OF_SERVICE;
						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_MAINT_NE;
						I_call_ref		= 1;
						Set_call_ref_not_nil ();
						Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINTENANCE);
					}
				}
			}

			break;

		case MNS_SERVICE_RQ :

			switch (I_(change_status, preference)) {

				case PREF_B_CHANNEL :

					if (I_(change_status, status) == CHANNEL_IN_SERVICE) {

							/*
							 * Initiate a RESTART procedure for
							 * that B channel.
							 */

						if (Dl_b_chan_restart_nb < b_chan_max) 	{
							Dl_b_chan_restart_nb++;
						}

						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_REST;
						I_(restart_ind, restart_class) 		= RI_INDICATED_CHANNEL;

					} else {

						Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINTENANCE);

					}

					break;

				case PREF_INTERFACE :

					if (I_(change_status, status) == CHANNEL_IN_SERVICE) {

							/*
							 * Initiate a RESTART procedure for
							 * each B channel of the interface.
							 */

						Dl_b_chan_restart_nb = b_chan_max;
						b_chan = 1;
						I_chan_id_chan_nb 	= 1;
						I_chan_id_chan_type = B_CHAN;
						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_REST;
						I_(restart_ind, restart_class) 		= RI_INDICATED_CHANNEL;

					} else {

							/*
							 * Initiate a SERVICE (IS) procedure for
							 * each B channel of the interface.
							 */

						I_(change_status, preference) 		= PREF_CHANNEL;
						Dl_b_chan_restart_nb 		  		= b_chan_max;
						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_MAINT_NE;

						Start_dl_timer (DMS_T3M1);
						Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINTENANCE);
					}

					break;
			}

			if (I_(change_status, status) == CHANNEL_IN_SERVICE) {

				Dl_rest_chan_nb = b_chan;

				set_ie_i (CODESET_0, RESTART_IND);

				Set_call_ref_nil ();
				Send_to_call_control (NS_RESTART_IN);			/* on CONN_ID_MANAGEMENT */

				Start_dl_timer (DMS_T317);

				Set_call_ref_not_nil ();
				Send_to_d_channel (RESTART);					/* with CALL_REF_GLOBAL */

				N316 = 0;
				Start_dl_timer (DMS_T316);
				Dl_rest_state = STATE_REST_1;
			}

			break;

		case NS_RESTART_RS :
		case DA_RESTART_ACK :

				/*
				 * Restart procedure is done.
				 * Send back a SERVICE.
				 */

			if (Dl_b_chan_restart_nb > 0) 	{
				Dl_b_chan_restart_nb--;
			}

			I_(change_status, preference) 	= PREF_B_CHANNEL;
			I_(change_status, status) 		= CHANNEL_IN_SERVICE;
			set_ie_i (CODESET_0, CHANGE_STATUS);
			set_ie_i (CODESET_0, CHAN_ID);

			Start_dl_timer (DMS_T3M1);
			Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINTENANCE);

			break;

		case TI_3M1 :
			break;
	}

	return (OK);
}

#endif	/* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_send_service () -

Usage           	uchar dms_send_service (line_nai, ack);

						ACK = ON --> Send a SERVICE_ACK

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

#if NS_D_BACKUP /* { */

void dms_send_service (line_nai, ack)
	nai_t line_nai;
	uchar ack;
{
	uchar FAR *p_data;

		/* The SERVICE/ACK is used for the D channel only. */

	spdu_id = MAINT_SERVICE;

	if (ack == ON) {

			/*
			 * Send the SERVICE_ACK message.
			 */

		spdu_id = MAINT_SERVICE_ACK;
	}

		/* Allocate a buffer */

	Buffer_alloc_reused;

		/* Initialize the buffer header */

	Buffer_data_offset	+= DL_MX_FRAME_HEADER;

		/* Set the SPDU pointer */

	p_data = Buffer_a_start_data;

	*p_data++ = PROTOCOL_DISCR_MAINTENANCE;

	*p_data++ = 1;					/* Call ref length */
	*p_data++ = 0;                  /* Call ref is GLOBAL */
	*p_data++ = spdu_id;		    /* spdu type */

	*p_data++ = CHANGE_STATUS;
	*p_data++ = 1;					/* length */
	*p_data++ = 0xC0;				/* D channel in service */

	*p_data++ = CHAN_ID;
	*p_data++ = 1;					/* length */
	*p_data++ = 0xAC;				/* No channel is included */

	Buffer_data_size = (ushort)(p_data - Buffer_a_start_data);

		/*
		   Allocate a message.
		   Transfer data information into the message if possible
		   and release the buffer;
		   If not possible link the buffer to the message.
		*/

	p_snd_msg = Msg_or_buffer (p_buffer, DL_MX_FRAME_HEADER);
	p_buffer  = S_msg_p_buffer;

		/* Init the message header with the address information */

	S_msg_from 		= ENT_NS;				/* from NS entity */
	S_msg_to 		= ENT_DL_D;				/* to Data Link LAPD entity */
	S_msg_nai 		= line_nai;				/* DL NA ID */
	S_msg_sapi 		= DL_SAPI_SIG;			/* SAP ID Signalling */
	S_msg_ces 		= DL_CES_SIG;			/* CES */

		/* Load the primitive code */

	S_msg_code 		= DL_DA_RQ;				/* primitive code */

	Send_message (p_snd_msg), p_snd_msg = P_NIL, p_buffer  = P_NIL;

}

#endif /* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_layer3_failure () -

Usage           	uchar dms_layer3_failure ();


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/
#if NS_D_BACKUP /* { */

uchar dms_layer3_failure ()
{

	switch (Nfas_backup_d_chan_status) {

		case MAINT_STATE_STBY :
		case MAINT_STATE_OOS :

				/*
				 * If the Backup D channel is STBY or OOS,
				 * 	- start T3MB,
				 *	- move the active D channel to MB,
				 *	- do the D channel switch over if the backup D channel
				 *	  is in the STBY state.
				 */

			Stop_dl_timer (DMS_T3DW);

			p_nsdl = Nfas_dl_p_active_d_chan;

			Start_dl_timer (DMS_T3MB);
			Nfas_active_d_chan_status = MAINT_STATE_MB;

			if (Nfas_backup_d_chan_status == MAINT_STATE_STBY) {
				p_nsdl = Nfas_dl_p_backup_d_chan;
				dms_send_service (Nfas_nai_backup_d_chan, OFF);
				Start_dl_timer (DMS_T321);
				Nfas_backup_d_chan_status = MAINT_STATE_WAIT;
			}

			break;

		default :

				/*
				 * Send a DL_EST_RQ,
				 * Start T3DW,
				 * Move to OOS.
				 */

			if (Lc_state != LC_AWAITING_EST) {
				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (DMS_T3DW);
			}

			Nfas_active_d_chan_status = MAINT_STATE_OOS;
			break;
	}

	return (OK);
}

#endif /* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_switch_d_channel () -

Usage           	uchar dms_switch_d_channel (code);


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/
#if NS_D_BACKUP /* { */

uchar dms_switch_d_channel (code)
	code_t code;
{
	struct nsna FAR *p_na_sav;
	struct nsdl FAR *p_dl_sav;
	nai_t			nai_sav;

	if (code == DA_MAINT_SERVICE) {

			/* Send back SERVICE_ACK */

		dms_send_service (Nfas_nai_line, ON);
	}

	p_na_sav = Nfas_nai_p_active_d_chan;
	nai_sav  = Nfas_nai_active_d_chan;
	p_dl_sav = Nfas_dl_p_active_d_chan;

		/*
		 * The previous Backup D channel
		 * becomes the new Active one.
		 */

	Nfas_nai_p_active_d_chan  = Nfas_nai_p_backup_d_chan;
	Nfas_dl_p_active_d_chan	  = Nfas_dl_p_backup_d_chan;
	Nfas_nai_p_backup_d_chan  = p_na_sav;
	Nfas_dl_p_backup_d_chan   = p_dl_sav;

	Nfas_nai_active_d_chan	  = Nfas_nai_backup_d_chan;
	Nfas_nai_backup_d_chan	  = nai_sav;

	if (code == DA_MAINT_SERVICE) {
		Nfas_backup_d_chan_status = MAINT_STATE_MB;
		Nfas_active_d_chan_status = MAINT_STATE_IS;

	} else {

		Nfas_backup_d_chan_status = Nfas_active_d_chan_status;
		Nfas_active_d_chan_status = MAINT_STATE_IS;
	}

	p_nsdl = Nfas_dl_p_backup_d_chan;

	if (code != DA_MAINT_SERVICE_ACK) {

			/* Start T3MB for the Backup */

		Start_dl_timer (DMS_T3MB);
	}

		/* Stop all T309 */

	ns_nfas_stop_309 ();

		/*
		 * Stop all DL timers on the new active D channel.
		 */

	p_nsna = Nfas_nai_p_active_d_chan;
	p_nsdl = Nfas_dl_p_active_d_chan;
	ns_stop_all_dlci_timers	();

	return (OK);
}

#endif /* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	dms_restart_maint () -

Usage           	uchar dms_restart_maint (code;

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/
#if NS_MAINTENANCE_CAPABILITY == ON /* { */

void dms_restart_maint (code)
	code_t code;
{
	uchar i, int_id;


	switch (code) {

		case DA_RESTART :

			if ((ns_nfas == OFF) ||
				((ns_nfas == ON) && (Nfas_nai_mode == NFAS_TSP))) {

				Start_dl_timer (DMS_T317);
				Dl_rest_state = STATE_REST_2;
				Set_call_ref_nil ();

					/* If TSP, the Na must be the Cfg_na */

				if ((ns_nfas == ON) && (Nfas_nai_mode == NFAS_TSP)) {

					if (ns_access_na (Nfas_cfg_nai_active_d_chan) != OK) {
						return;
					}

				}

				Send_to_call_control (NS_RESTART_IN);

				Dl_b_chan_restart_nb += 1;

				if (I_restart_ind_class == RI_ALL_INTERFACES) {
					csc_clear_all_call ();
					Na_internal_restart = ON;
				}

				return;
			}

				/*
				 * Only one channel is indicated : the lowest NxDS0 Channel.
				 * The upper entity must clear ALL the calls.
				 */


			Start_dl_timer (DMS_T317);
			Dl_rest_state = STATE_REST_2;
			Dl_rest_class = I_restart_ind_class;

			switch (I_restart_ind_class) {

				case RI_ALL_INTERFACES :

							/*
							 * Access to all the Nais managed by the current D channel
							 * bearer,
							 */

					for (i = 0; i < Nfas_nai_assoc_list_nb_nai + 1; i++) {

						if (ns_access_na (Nfas_nai_assoc_list(i)) == NOK) {
							return;
						}

						Set_call_ref_nil ();
						Send_to_call_control (NS_RESTART_IN);
						Dl_b_chan_restart_nb += 1;

						if (I_restart_ind_class == RI_ALL_INTERFACES) {
							csc_clear_all_call ();
							Na_internal_restart = ON;
						}
					}

					break;

				case RI_SINGLE_INTERFACE :

					if (I_(chan_id, int_id) == INT_ID_IMPLICIT) {

							/* Check that the int_id_val is the Active D channel */

						int_id = Nai;

					} else {

						int_id = I_(chan_id, int_id_val);

						if (ns_access_na (int_id) == NOK) {
							return;
						}
					}

					Set_call_ref_nil ();
					Send_to_call_control (NS_RESTART_IN);
					Dl_b_chan_restart_nb += 1;

					break;

				case RI_INDICATED_CHANNEL :

					if (I_(chan_id, int_id) == INT_ID_IMPLICIT) {

							/* Check that the int_id_val is the Active D channel */

						int_id = Nai;

					} else {

						int_id = I_(chan_id, int_id_val);

						if (ns_access_na (int_id) == NOK) {
							return;
						}
					}

					Set_call_ref_nil ();
					Send_to_call_control (NS_RESTART_IN);
					Dl_b_chan_restart_nb += 1;
					break;
			}

			break;

		case NS_RESTART_RS :

        	if (ns_nfas == ON) {

                if (ns_access_na (Nfas_nai_active_d_chan) != OK) {
                    return;
                }

            }

			switch (Dl_rest_state) {

				case STATE_REST_1 :
					Stop_dl_timer (DMS_T317);

					if (Dl_rest_ack == ON) {

						ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
						Dl_restart_reset ();

					} else {

						Dl_rest_resp = ON;
					}

					dms_b_chan_maint (NS_RESTART_RS);
					break;

				case STATE_REST_2 :

					if (Dl_b_chan_restart_nb > 0) {
						Dl_b_chan_restart_nb--;

					}

						/*
						 * Send a RESTART_ACK if
						 *	-1- Class is not ALL_INTERFACES
						 *	-2- or Class is ALL INTERFACES and no more
						 * 		RESTART_RS are expected.
						 */

					if (Dl_rest_class != RI_ALL_INTERFACES) {
						Set_call_ref_not_nil ();
						Send_to_d_channel (RESTART_ACK);
						dms_bkp_maint_proc (NS_RESTART_RS, Nai);
					}

					if ((Dl_rest_class == RI_ALL_INTERFACES) &&
						(Dl_b_chan_restart_nb == 0)) {
						Set_call_ref_not_nil ();
						Send_to_d_channel (RESTART_ACK);
						dms_bkp_maint_proc (NS_RESTART_RS, Nai);
					}

					if (Dl_b_chan_restart_nb == 0) {
						Stop_dl_timer (DMS_T317);
						Dl_restart_reset ();
					}

					break;

				default :

					ns_unexpected_ev ();
			}

			break;

		case DA_RESTART_ACK :

			Stop_dl_timer (DMS_T316);

			if (Nfas_nai_mode != NFAS_TSP) {

				if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

					if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {

						if (ns_access_na (I_(chan_id, int_id_val)) == NOK) {
							return;
						}
					}
				}
			}

			ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
			Dl_restart_reset ();
			break;
	}
}

#endif /* } */

/*EOF*/
