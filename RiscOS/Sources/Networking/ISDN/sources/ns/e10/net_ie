
/*--------------------------------------------------------------------------*
 *						M O D U L E		H E A D E R
 *
 * filename - net_ie.e10
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the meta description of all the information
 * elements and the integrity constraints associated to.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

/*
*
*Table structures :
*----------------
*
*        tabl_item   TABL_ITEM                                    uchar
*        ==========================                             ============
*        | tabl_id | size | p_val |---------------------------->|   val    |
*        --------------------------  tabl_yy      ============  ------------
*        |         |      |       |-------------->|   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |          |  |          |
*        --------------------------
*        |         |      |       |
*        --------------------------
*        |         |      |       |
*
*
*    tabx_item   TABX_ITEM                   tabx_list                uchar
*    =================================     =================        =========
*    | tabl_id | size | list pointer |---->| tabl_id | size|------->| x_val |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------
*    |         |      |              |
*
*/

/*-------------------------------------------------------------------------*/

	/*
		Initialization constants of ie internal structure
		used by SPDU received processing.
	*/

		/*  Bearer capability (BC) */

CONST	struct  i_bc	df_spdu_e10_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	PROTOCOL_ID_3_X25_PL,
};

		/* Call state (CALL_STATE) */

CONST	struct  i_call_state	df_spdu_e10_i_call_state = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/*  Called party number and subaddress (CALLED_NB, CALLED_SUB_ADD) */

CONST	struct  i_called_nb	 df_spdu_e10_i_called_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Calling party number (CALLING_NB) */

CONST	struct  i_calling_nb	df_spdu_e10_i_calling_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};


		/* Cause (CAUSE) */

CONST	struct  i_cause	 df_spdu_e10_i_cause = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST	struct  i_chan_id	df_spdu_e10_i_chan_id = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};


		/* Low layer compatibility (LLC) */

CONST	struct  i_llc	df_spdu_e10_i_llc = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST   struct  i_spf_fac   df_spdu_e10_i_spf_fac = {
	1,
	NATIONAL_NETWORK_ID_TYPE,
	CARRIER_ID_CODE,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	FAC_VAL_6_BITS,
	FAC_SERVICE,
	FAC_INWATS,
};

#endif

		/* Progress indicator (PROGRESS_IND) */

CONST	struct  i_progress_ind  df_spdu_e10_i_progress_ind = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};


		/* User entered code (USER_ENTERED_CODE) */

CONST   struct  i_user_entered_code   df_spdu_e10_i_user_entered_code = {
	UC_ANY,
	0,
	P_NIL
};

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/*					Basic rate specific Information Elements				*/
/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if NS_TYPE_BRI == ON /* { */

CONST   struct  i_called_sub_add	df_spdu_e10_i_called_sub_add = {
	SUB_ADD_OSI,
	SUB_ADD_EVEN,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Keypad                   (KEYPAD) */

CONST   struct  i_keypad    df_spdu_e10_i_keypad = {
	0,
	A_NIL,
};

		/*  Signal (SIGNAL) */

CONST	struct  i_signal	df_spdu_e10_i_signal = {
	BYTE_VAL_NIL
};

		/* Terminal capabilities    (TE_CAP) */

CONST   struct  i_te_cap    df_spdu_e10_i_te_cap = {
	CODING_STD_CCITT,
	TYPE_2_STIMULUS,
};

		/* Management (MANAGMNT) */

CONST   struct  i_managmnt  df_spdu_e10_i_managmnt = {
	PROTOCOL_DISCR_ATT_ISDN_MAN,
	SYN,
};

		/* Endpoint identifier      (E10_ENDPOINT_ID) */

CONST   struct  i_endpoint_id   df_spdu_e10_i_endpoint_id = {
	USID_ALL,
	INTERPRETER_0,
	TID_ALL,
};

#endif /* } */

#if (NS_TYPE_BRI == ON) && (E10_SUPPLEMENTARY_SERVICES == ON) /* { */


		/* Switchhook           (SWITCHHOOK) */

CONST   struct  i_switchhook    df_spdu_e10_i_switchhook = {
	HOOK_ON,
};

		/* Associated type (ASSOC_TYPE) */

CONST   struct  i_assoc_type    df_spdu_e10_i_assoc_type = {
	BYTE_VAL_NIL,
};

		/* Selected Call Appearance (SEL_CALL_APPEAR) */

CONST   struct  i_sel_call_appear   df_spdu_e10_i_sel_call_appear = {
	1,
};

		/* Origination Call Appearance (ORI_CALL_APPEAR) */

CONST   struct  i_ori_call_appear   df_spdu_e10_i_ori_call_appear = {
	1,
};

		/* Destination Call Appearance (DEST_CALL_APPEAR) */

CONST   struct  i_dest_call_appear  df_spdu_e10_i_dest_call_appear = {
	1,
};

		/* Keypad Control (KEYPAD_CON) */

CONST   struct  i_keypad_con    df_spdu_e10_i_keypad_con = {
	CALL_REF_NOT_NULL,
};

		/* Other Call Reference (OTHER_CALL_REF) */

CONST   struct  i_other_call_ref    df_spdu_e10_i_other_call_ref = {
	1
};

		/* Feature activation (FEATURE_ACT) */

CONST   struct  i_feature_act   df_spdu_e10_i_feature_act = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BUTTON_TYPE_UNKNOWN,
	MODULE_0,
	FEATURE_NUMBER_STATUS,
	1,
};

		/* Feature indication (FEATURE_IND) */

CONST   struct  i_feature_ind   df_spdu_e10_i_feature_ind = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BUTTON_TYPE_UNKNOWN,
	MODULE_0,
	FEATURE_NUMBER_STATUS,
};

		/* Adjunct control (ADJUNCT_CON) */

CONST   struct  i_adjunct_con   df_spdu_e10_i_adjunct_con = {
	ADJUNCT_OFF,
};

        /* Display control (DISPLAY_CON) */

CONST   struct  i_display_con   df_spdu_e10_i_display_con = {
    DISPLAY_NORMAL,
};

		/* Display field (DISPLAY_FLD) */

CONST   struct  i_display_fld   df_spdu_e10_i_display_fld = {
    DISPLAY_NORMAL,
	DISPLAY_SUBMODE_DIRECT,
	CALL_APPEAR_ID,
	0,
	A_NIL,
};

#endif /* } */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/*					Primary rate specific Information Elements				*/
/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if NS_TYPE_PRI == ON /* { */

		/*  Change status (CHANGE_STATUS) */

CONST	struct  i_change_status	df_spdu_e10_i_change_status = {
	PREF_INTERFACE,
	CHANNEL_IN_SERVICE,
};

		/* Connected number (CONN_NB) */

CONST	struct  i_conn_nb	df_spdu_e10_i_conn_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};

		/* facilities (FACILITY) */

CONST   struct  i_facility   df_spdu_e10_i_facility = {
	FAC_SUPPLEMENTARY,
	FAC_LGTH_FORMAT,

	{	FAC_CONTEXT_SPECIFIC,
		FAC_CONSTRUCTOR,
		FAC_INVOKE,
		14
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_INVOKE_ID_TAG,
		1,
		A_NIL
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_OP_VAL_TAG,
		FAC_OP_VAL_LGTH,
		OP_VAL_UUI
	},

	{	FAC_UNIVERSAL,
		FAC_CONSTRUCTOR,
		FAC_SEQUENCE_TAG,
		6
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_SERVICE_TAG,
		FAC_SERVICE_LGTH,
		SERVICE_1
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_PREF_TAG,
		FAC_PREF_LGTH,
		PREFERRED_TRUE
	}

};

		/* Precedence level (PRECEDENCE_LEVEL) */

CONST	struct  i_precedence_level  df_spdu_e10_i_precedence_level = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	P_NIL,
	P_NIL
};

		/* Redirecting number (REDIR_NB) */

CONST	struct  i_redir_nb	df_spdu_e10_i_redir_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_spdu_e10_i_restart_ind = {
	RI_ALL_INTERFACES
};

		/* Traveling classmark (TRAVELING_CLASSMARK) */

CONST	struct  i_traveling_classmark	df_spdu_e10_i_traveling_classmark = {
	CODING_STD_NATIONAL,
	REQUIRED_VALUE,
	0,
	0,
	NO_PREFERENCE,
	P_NIL
};

		/* User to user information (UUI) */

CONST   struct  i_uui   df_spdu_e10_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL
};

#endif /* } */

/*=========================================================================*/

	/*
		Initialization constants of the ie internal structure
		used by SSDU received processing.
	*/

		/*  Bearer capability (BC) */

CONST	struct  i_bc	df_ssdu_e10_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	RA_56KBS,			/* Optional field */
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	PROTOCOL_ID_3_X25_PL,
};

		/* Call state (CALL_STATE) */

CONST	struct  i_call_state	df_ssdu_e10_i_call_state = {
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,
};

		/*  Called party number and subaddress (CALLED_NB, CALLED_SUB_ADD) */

CONST	struct  i_called_nb	 df_ssdu_e10_i_called_nb = {
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Calling party number (CALLING_NB) */

CONST	struct  i_calling_nb	df_ssdu_e10_i_calling_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};

		/* Cause (CAUSE) */

CONST	struct  i_cause	 df_ssdu_e10_i_cause = {
	CODING_STD_CCITT,
	LOCATION_USER,
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST	struct  i_chan_id	df_ssdu_e10_i_chan_id = {
	INT_ID_IMPLICIT,
	INT_TYPE_BRI,
	CHAN_PREF,
	NOT_D_CHAN,
	ANY_CHAN,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL,
};


		/* Low layer compatibility (LLC) */

CONST   struct  i_llc   df_ssdu_e10_i_llc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	OUT_BAND_NOT_POSSIBLE,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};


#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST   struct  i_spf_fac   df_ssdu_e10_i_spf_fac = {
	1,
	NATIONAL_NETWORK_ID_TYPE,
	CARRIER_ID_CODE,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	FAC_VAL_6_BITS,
	FAC_SERVICE,
	FAC_INWATS,
};

#endif

		/* User entered code (USER_ENTERED_CODE) */

CONST   struct  i_user_entered_code   df_ssdu_e10_i_user_entered_code = {
	UC_ANY,
	0,
	P_NIL
};

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/*					Basic rate specific Information Elements				*/
/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if NS_TYPE_BRI == ON /* { */

CONST   struct  i_called_sub_add	df_ssdu_e10_i_called_sub_add = {
	SUB_ADD_OSI,
	SUB_ADD_EVEN,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Keypad (KEYPAD) */

CONST   struct  i_keypad    df_ssdu_e10_i_keypad = {
	0,
	A_NIL,
};

		/* Terminal capabilities    (TE_CAP) */

CONST   struct  i_te_cap    df_ssdu_e10_i_te_cap = {
	CODING_STD_CCITT,
	TYPE_2_STIMULUS,
};

		/* Management (MANAGMNT) */

CONST   struct  i_managmnt  df_ssdu_e10_i_managmnt = {
	PROTOCOL_DISCR_ATT_ISDN_MAN,
	SYN,
};
		/* Endpoint identifier (E10_ENDPOINT_ID) */

CONST   struct  i_endpoint_id   df_ssdu_e10_i_endpoint_id = {
	USID_ALL,
	INTERPRETER_0,
	TID_ALL,
};

#endif /* } */

#if (NS_TYPE_BRI == ON) && (E10_SUPPLEMENTARY_SERVICES == ON) /* { */

		/* Switchhook           (SWITCHHOOK) */

CONST   struct  i_switchhook    df_ssdu_e10_i_switchhook = {
	HOOK_ON,
};

		/* Associated type (ASSOC_TYPE) */

CONST   struct  i_assoc_type    df_ssdu_e10_i_assoc_type = {
	BYTE_VAL_NIL,
};

		/* Selected Call Appearance (SEL_CALL_APPEAR) */

CONST   struct  i_sel_call_appear   df_ssdu_e10_i_sel_call_appear = {
	1,
};

		/* Origination Call Appearance (ORI_CALL_APPEAR) */

CONST   struct  i_ori_call_appear   df_ssdu_e10_i_ori_call_appear = {
	1,
};

        /* Destination Call Appearance (DEST_CALL_APPEAR) */

CONST   struct  i_dest_call_appear  df_ssdu_e10_i_dest_call_appear = {
    1,
};

		/* Keypad Control (KEYPAD_CON) */

CONST   struct  i_keypad_con    df_ssdu_e10_i_keypad_con = {
    CALL_REF_NOT_NULL,
};

        /* Other Call Reference (OTHER_CALL_REF) */

CONST   struct  i_other_call_ref    df_ssdu_e10_i_other_call_ref = {
    1,
};

        /* Feature activation (FEATURE_ACT) */

CONST   struct  i_feature_act   df_ssdu_e10_i_feature_act = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BUTTON_TYPE_UNKNOWN,
    MODULE_0,
    FEATURE_NUMBER_STATUS,
    1,
};

        /* Feature indication (FEATURE_IND) */

CONST   struct  i_feature_ind   df_ssdu_e10_i_feature_ind = {
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
    BYTE_VAL_NIL,
	BUTTON_TYPE_UNKNOWN,
    MODULE_0,
    FEATURE_NUMBER_STATUS,
};

        /* Adjunct control (ADJUNCT_CON) */

CONST   struct  i_adjunct_con   df_ssdu_e10_i_adjunct_con = {
    ADJUNCT_OFF,
};

        /* Display control (DISPLAY_CON) */

CONST   struct  i_display_con   df_ssdu_e10_i_display_con = {
	DISPLAY_NORMAL,
};

		/* Display field (DISPLAY_FLD) */

CONST   struct  i_display_fld   df_ssdu_e10_i_display_fld = {
	DISPLAY_NORMAL,
	DISPLAY_SUBMODE_DIRECT,
	CALL_APPEAR_ID,
	0,
	A_NIL,
};


#endif /* } */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/*					Primary rate specific Information Elements				*/
/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if NS_TYPE_PRI == ON /* { */

		/*  Change status (CHANGE_STATUS) */

CONST	struct  i_change_status	df_ssdu_e10_i_change_status = {
	PREF_INTERFACE,
	CHANNEL_IN_SERVICE,
};


		/* Connected number (CONN_NB) */

CONST	struct  i_conn_nb	df_ssdu_e10_i_conn_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};

		/* facilities (FACILITY) */

CONST   struct  i_facility   df_ssdu_e10_i_facility = {
	FAC_SUPPLEMENTARY,
	FAC_LGTH_FORMAT,

	{	FAC_CONTEXT_SPECIFIC,
		FAC_CONSTRUCTOR,
		FAC_INVOKE,
		14
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_INVOKE_ID_TAG,
		1,
		A_NIL
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_OP_VAL_TAG,
		FAC_OP_VAL_LGTH,
		OP_VAL_UUI
	},

	{	FAC_UNIVERSAL,
		FAC_CONSTRUCTOR,
		FAC_SEQUENCE_TAG,
		6
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_SERVICE_TAG,
		FAC_SERVICE_LGTH,
		SERVICE_1
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_PREF_TAG,
		FAC_PREF_LGTH,
		PREFERRED_TRUE
	}

};

		/* Precedence level (PRECEDENCE_LEVEL) */

CONST	struct  i_precedence_level  df_ssdu_e10_i_precedence_level = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	P_NIL,
	P_NIL
};

		/* Redirecting number (REDIR_NB) */

CONST	struct  i_redir_nb	df_ssdu_e10_i_redir_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	BYTE_VAL_NIL,
	0,
	A_NIL
};


	/* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_ssdu_e10_i_restart_ind = {
	RI_ALL_INTERFACES
};


	/* Transit network selection (TRANSIT_NET_SEL) */

CONST	struct  i_transit_net_sel	df_ssdu_e10_i_transit_net_sel = {
	NATIONAL_NETWORK_ID_TYPE,
	CARRIER_ID_CODE,
	0,
	A_NIL
};

	/* Traveling classmark (TRAVELING_CLASSMARK) */

CONST	struct  i_traveling_classmark	df_ssdu_e10_i_traveling_classmark = {
	CODING_STD_NATIONAL,
	REQUIRED_VALUE,
	0,
	0,
	NO_PREFERENCE,
	P_NIL
};

	/* User to user information (UUI) */

CONST   struct  i_uui   df_ssdu_e10_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL
};

#endif /* } */


/*=========================================================================*/

				/*-------------------------------*/
				/* TABLES : list of valid values */
				/*-------------------------------*/

					/* Assignor/Assignee (ie LLC) */

CONST	uchar E10_ASSIGN_S[] = {
	DEFAULT_ASSIGNEE,
	ASSIGNOR_ONLY,
	};

					/* In-band/Out_band negotiation (ie LLC) */

CONST	uchar E10_BAND_S[] = {
	TSC,
	LL0,
	};


					/* Transfert mode (ie LLC) */

CONST	uchar E10_TRF_MODE_S[] = {
	TRF_MODE_CIRCUIT,
	TRF_MODE_PACKET,
	};

				/* Layer 1 protocol identifier (ie BC) */

CONST	uchar E10_BC_PROTOCOL_ID_1_S[] = {
	PROTOCOL_ID_1_V110,
	PROTOCOL_ID_1_G711_u,
	};


					/* Cause class (ie CAUSE) */

CONST	uchar E10_C_C_S[]={
	C_C_NORMAL_EVENT_0,
	C_C_NORMAL_EVENT,
	C_C_RESOURCE_UNAVAILABLE,		/* Network congestion */
	C_C_SERVICE_NOT_AVAILABLE,
	C_C_SERVICE_NOT_IMPLEMENTED,
	C_C_INVALID_MESSAGE,
	C_C_PROTOCOL_ERROR,
	C_C_INTERWORKING,
	};

					/* Automata call state values (ie CALL_STATE) */

CONST	uchar E10_CALL_STATE_VAL_S[] = {
	STATE_NULL_0,
	STATE_CALL_INIT_1,
	STATE_OVERLAP_SENDING_2,
	STATE_OUTGOING_CALL_PROC_3,
	STATE_CALL_DELIVERED_4,
	STATE_CALL_PRESENT_6,
	STATE_CALL_RECEIVED_7,
	STATE_CONNECT_REQUEST_8,
	STATE_INCOMING_CALL_PROC_9,
	STATE_ACTIVE_10,
	STATE_DISCONNECT_REQUEST_11,
	STATE_DISCONNECT_INDICATION_12,
	STATE_TONE_ACTIVE_18,
	STATE_RELEASE_REQUEST_19,

	STATE_REST_1,
	STATE_REST_2,
	};

					/* Coding standard (ie CAUSE) */

CONST	uchar E10_CODING_STD_CAUSE_S[] = {
	CODING_STD_CCITT,
	CODING_STD_SPF,
	};
					/* Coding standard (ie PROGRESS_IND) */

CONST	uchar E10_CODING_STD_PROGRESS_S[] = {
	CODING_STD_CCITT,
	CODING_STD_NATIONAL,
	CODING_STD_SPF,
	};

					/* Preferred/exclusive (ie CHAN_ID) */

CONST	uchar E10_CHAN_PREF_EXCL_S[] = {
	CHAN_PREF,
	CHAN_EXCL,
	};

					/* D-channel indicator (ie CHAN_ID) */

CONST	uchar E10_D_CHAN_S[] = {
	D_CHAN,
	NOT_D_CHAN,
	};

					/* Channel interface ID (ie CHAN_ID) */

CONST	uchar E10_CHAN_INT_S[] = {
	INT_ID_IMPLICIT,
	INT_ID_EXPLICIT,
	};

					/* Channel interface ID value (ie CHAN_ID) */

CONST	uchar E10_CHAN_INT_VAL_S[] = {
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
	23,24
	};
					/* Coding standard (ie LLC) */

CONST	uchar E10_CODING_STD_S[] = {
	CODING_STD_CCITT,
	CODING_STD_RESERVED,
	CODING_STD_NATIONAL,
	CODING_STD_SPF,
	};

					/* Data bit format (ie LLC) */

CONST	uchar E10_DATA_BIT_S[] = {
	DATA_BIT_UNUSED,
	DATA_BIT_5,
	DATA_BIT_7,
	DATA_BIT_8,
	};

					/* Duplex/half-duplex (ie LLC) */

CONST	uchar E10_DUPLEX_S[] = {
	HALF_DUPLEX,
	FULL_DUPLEX,
	};

					/* Flow control on Reception (Rx) (ie LLC) */

CONST	uchar E10_FLOW_CONTROL_RX_S[] = {
	FLOW_CAN_ACCEPT_DATA,
	FLOW_CANNOT_ACCEPT_DATA,
	};

					/* Flow control on Transmission (Tx) (ie LLC) */

CONST	uchar E10_FLOW_CONTROL_TX_S[] = {
	FLOW_NOT_RQ_TX_DATA,
	FLOW_RQ_TX_DATA,
	};

					/* Rate adaption header/no header (ie LLC) */

CONST	uchar E10_HEADER_S[] = {
	HEADER_NOT_INCLUDED,
	HEADER_INCLUDED,
	};

					/* Interface type (ie CHAN_ID) */

CONST	uchar E10_INT_TYPE_S[] = {
	INT_TYPE_BRI,
	INT_TYPE_PRI,
	};

					/* Intermediate rate (V110) (ie LLC) */

CONST	uchar E10_INTER_RATE_S[] = {
	INTER_RA_UNUSED,
	INTER_RA_8KBS,
	INTER_RA_16KBS,
	INTER_RA_32KBS,
	};

					/* Logical Link Identifier negotiation (ie LLC) */

CONST	uchar E10_LLI_S[] = {
	DEFAULT_LLI,
	FULL_PROTOCOL_LLI,
	};

					/* Cause location (ie CAUSE) */

CONST	uchar E10_LOCATION_S[] = {
	LOCATION_USER,
	LOCATION_PR_NET_LOC_USER,
	LOCATION_NETWORK,
	LOCATION_TRANSIT_NET,
	LOCATION_REMOTE_LOCAL_NETWORK,
	LOCATION_REMOTE_PRIVATE_NETWORK,
	LOCATION_INTERNATIONAL_NET,
	LOCATION_NET_NTWK_POINT,
	};

					/* Modem type (ie LLC) */

CONST	uchar E10_MODEM_S[] = {
	MODEM_RESERVED,
	MODEM_V21,
	MODEM_V22,
	MODEM_V22_BIS,
	MODEM_V23,
	MODEM_V26,
	MODEM_V26_BIS,
	MODEM_V26_TER,
	MODEM_V27,
	MODEM_V27_BIS,
	MODEM_V27_TER,
	MODEM_V29,
	MODEM_V32,
	MODEM_V35,
	};

					/* Multi frame establishment support in Data Link (ie LLC) */

CONST	uchar E10_MULTI_FRAME_S[] = {
	MULTI_FRAME_NOT_SUPPORTED,
	MULTI_FRAME_SUPPORTED,
	};

					/* In-band negotiation (V110 or V120) (ie LLC) */

CONST	uchar E10_NEGOTIATION_S[] = {
	NEGOTIATION_IN_BAND,
	NEGOTIATION_NOT_IN_BAND,
	};

					/* Network independent clock (NIC) (ie LLC) */

CONST	uchar E10_NIC_RX_S[] = {
	NIC_ACCEPT_DATA,
	NIC_NOT_ACCEPT_DATA,
	};

					/* Network independent clock (NIC) (ie LLC) */

CONST	uchar E10_NIC_TX_S[] = {
	NIC_RQ_TX_DATA,
	NIC_NOT_RQ_TX_DATA,
	};


					/* Mode of operation (ie LLC) */

CONST	uchar E10_OP_MODE_S[] = {
	BIT_TRANSPARENT,
	PROTOCOL_SENSITIVE,
	};

					/* Out-band negotiation indicator (ie LLC) */

CONST	uchar E10_OUT_BAND_NEG_S[] =	{
	OUT_BAND_POSSIBLE,
	OUT_BAND_NOT_POSSIBLE,
	};

					/* Parity format (ie LLC) */

CONST	uchar E10_PARITY_S[] = {
	ODD,
	EVEN,
	NO_PARITY,
	FORCED_TO_0,
	FORCED_TO_1,
	};


					/* Progress description (ie PROGRESS_IND) */

CONST	uchar E10_PROGRESS_IND_DESCR_S[] = {
	PROGRESS_DESCR_NON_END_TO_END_ISDN,
	PROGRESS_DESCR_NON_ISDN_DEST,
	PROGRESS_DESCR_NON_ISDN_ORIG,
	PROGRESS_DESCR_CALL_RETURNED_ISDN,
	PROGRESS_DESCR_IN_BAND_NOW,
	PROGRESS_DESCR_DELAY_AT_CALLED,
	};

					/* Layer 1 protocol identifier (ie LLC) */

CONST	uchar E10_PROTOCOL_ID_LLC_1_S[] = {
	PROTOCOL_ID_1_V110,
	PROTOCOL_ID_1_G711_u,
	PROTOCOL_ID_1_G711_A,
	PROTOCOL_ID_1_G721,
	PROTOCOL_ID_1_7KHZ,
	PROTOCOL_ID_1_VIDEO,
	PROTOCOL_ID_1_RA_NON_CCITT,
	PROTOCOL_ID_1_V120,
	PROTOCOL_ID_1_X31,
	};

					/* Layer 2 protocol identifier (ie LLC) */

CONST	uchar E10_PROTOCOL_ID_LLC_2_S[] = {
	PROTOCOL_ID_2_ISO_1745,
	PROTOCOL_ID_2_Q921,
	PROTOCOL_ID_2_X25_LL,
	PROTOCOL_ID_2_X25_ML,
	PROTOCOL_ID_2_T71,
	PROTOCOL_ID_2_HDLC_ARM,
	PROTOCOL_ID_2_HDLC_NRM,
	PROTOCOL_ID_2_HDLC_ABM,
	PROTOCOL_ID_2_LAN_LLC,
	PROTOCOL_ID_2_X75_SLP,
	};

					/* Layer 3 protocol identifier (ie LLC) */

CONST	uchar E10_PROTOCOL_ID_LLC_3_S[] = {
	PROTOCOL_ID_3_Q931,
	PROTOCOL_ID_3_X25_PL,
	PROTOCOL_ID_3_ISO_8208,
	PROTOCOL_ID_3_ISO_8348,
	PROTOCOL_ID_3_ISO_8473,
	PROTOCOL_ID_3_T70,
	};


					/* Stop bit format (ie LLC) */

CONST	uchar E10_STOP_BIT_S[] = {
	STOP_BIT_UNUSED,
	STOP_BIT_1,
	STOP_BIT_1_5,
	STOP_BIT_2,
	};

					/* Information structure (ie LLC) */

CONST	uchar E10_STRUCTURE_S[] = {
	STRUCTURE_DEFAULT,
	STRUCTURE_8KHZ_INT,
	STRUCTURE_SDU_INT,
	STRUCTURE_UNSTRUCTURED,
	};

					/* Asynchronous/synchronous (ie LLC) */

CONST	uchar E10_SYN_ASYN_S[] =	{
	SYN,
	ASYN,
	};

					/* Information transfer capability (ie BC) */

CONST	uchar E10_TRF_CAP_BC_S []  ={
	TRF_CAP_SPEECH,
	TRF_CAP_UNRESTRICTED,
	TRF_CAP_RESTRICTED,
	TRF_CAP_3_1_AUDIO,
	};

					/* Information transfer capability (ie LLC) */

CONST	uchar E10_TRF_CAP_LLC_S []  ={
	TRF_CAP_SPEECH,
	TRF_CAP_UNRESTRICTED,
	TRF_CAP_RESTRICTED,
	TRF_CAP_3_1_AUDIO,
	TRF_CAP_7_AUDIO,
	TRF_CAP_VIDEO,
	};


					/* Numbering plan (ie CALLED_NB, CALLING_NB) */

CONST	uchar E10_NB_PLAN_S[] = {
	PLAN_UNKNOWN,
	PLAN_ISDN,
	PLAN_PRIVATE,
	PLAN_TELEPHONE
	};

					/* Numbering type (ie CALLED_NB) */

CONST	uchar E10_NB_TYPE_S[] = {
	NB_UNKNOWN,
	NB_NATIONAL,
	NB_INTERNATIONAL,
	NB_LOCAL,
	NB_NET_SPF,
	};


					/* Calling presentation indicator (ie CALLING_NB) */

CONST	uchar E10_CALLING_NB_PRES_S[] = {
	PRES_ALLOWED,
	PRES_RESTRICTED,
	PRES_NOT_AVAILABLE,
	PRES_RESERVED,
	};

					/* User rate (V110 & V120) (ie LLC) */

CONST	uchar E10_USER_RATE_S[] =	{
	RA_E_BITS,
	RA_0_6KBS,
	RA_1_2KBS,
	RA_2_4KBS,
	RA_3_6KBS,
	RA_4_8KBS,
	RA_7_2KBS,
	RA_8KBS,
	RA_9_6KBS,
	RA_14_4KBS,
	RA_16KBS,
	RA_19_2KBS,
	RA_32KBS,
	RA_48KBS,
	RA_56KBS,
	RA_64KBS,
	RA_0_1345KBS,
	RA_0_100KBS,
	RA_0_75_1_2KBS,
	RA_1_2_0_75KBS,
	RA_0_050KBS,
	RA_0_075KBS,
	RA_0_110KBS,
	RA_0_150KBS,
	RA_0_200KBS,
	RA_0_300KBS,
	RA_12KBS,
	};

				/* Multuplier for BC in case of n*64 kb/s option */

CONST	uchar E10_T_MULTIPLIER_S[] = {
	2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24
	};


					/* Information transfer rate (ie BC) */

CONST	uchar E10_TRF_RATE_S[] = {
	TRF_RATE_64KBS,
	TRF_RATE_384KBS,
	TRF_RATE_1536KBS,
	TRF_RATE_MULTI_RATE,
};

					/* Length of network identification */

CONST	uchar E10_NET_ID_LGTH_S[] = {
	0,
	4,
	5
};
		/* Facility coding value for net spf facility (SPF_FAC) */

CONST	uchar E10_FAC_CODE_S[] = {
	FAC_INWATS,
	FAC_OUTWATS,
	FAC_FOREIGN_EXCHANGE,
	FAC_TIE_TRUNK,

};

CONST	uchar E10_PARAMETER_BINARY_S[] = {
	SPF_FAC_PARAMETER,
	SPF_FAC_BINARY,
};

CONST	uchar E10_FAC_SERV_FEAT_S[] = {
	FAC_SERVICE,
	FAC_FEATURE
};


		/* User code type (USER_ENTERED_CODE) */

CONST	uchar E10_CODE_TYPE_S[] = {
	UC_ANY,
	UC_ACCOUNT_CODE,
	UC_LOGIN_DIGITS,
	UC_SUBSCRIBER_ID,
	UC_AUTHO_CODE
};

					/* Screening indicator (ie CALLING_NB) */

CONST	uchar E10_SCREEN_IND_S[] = {
	USER_PROVIDED,
	USER_PASSED,
	USER_FAILED,
	NETWORK_PROVIDED,
	};

		/* Nb Map (ie CHAN_ID) */

CONST	uchar E10_NB_MAP_S[] = {
	CHAN_NUMBER,
	CHAN_MAP,
	};

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/*						Basic rate specific Values							*/
/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if NS_TYPE_BRI == ON /* { */

					/* Number of Layer-protocol fields */

CONST   uchar LAYER_NB_E10_S[]  = {
	0,
	1,
	2,
};
					/* Subaddress odd/even indicator (ie CALLED_SUB_ADD) */

CONST	uchar E10_SUB_ADD_IND_S[] = {
	SUB_ADD_ODD,
	SUB_ADD_EVEN,
	};

					/* Subaddress type (ie CALLED_SUB_ADD) */

CONST	uchar E10_SUB_ADD_TYPE_S[] = {
	SUB_ADD_OSI,
	SUB_ADD_USER,
};

					/* Signal values (ie SIGNAL) */

CONST	uchar E10_SIGNAL_VAL_S[] = {
	DIAL_ON,
	RING_BACK_ON,
	INTERCEPT_ON,
	NET_CONGEST_ON,
	BUSY_ON,
	CONFIRM_ON,
	ANSWER_ON,
	CALL_WAITING_ON,
	OFF_HOOK_WARNING_ON,
	CUSTOM_ON,
	RECALL_DIAL_ON,
	BUSY_VERIFY_ON,
	ERROR_ON,
	STUTTER_DIAL_ON,
	EXPENSIVE_ROUTED_ON,
	TONES_OFF,
	PATTERN_0,
	PATTERN_1,
	PATTERN_2,
	PATTERN_3,
	PATTERN_4,
	PATTERN_5,
	PATTERN_6,
	PATTERN_7,
	ALERTING_OFF,
	SIGNAL_RESERVED,
	ZIPTONE,
	UNSPECIFIED_TONE,
	TONES_OFF,
	ALERTING_OFF,
	RECALL_DIAL_TONE_ON,
	BARGE_IN_ON,
	INCOMING_ADD_CALL,
	PRIORITY_ADD_CALL,
	EXPENSIVE_ROUTE_WARNING,
};

CONST   uchar MAN_ERR_CODE_E10_S[]  = {
						MAN_ERR_UNSPECIFIED,
						MAN_ERR_PROTOCOL_VIOLATION,
						MAN_ERR_UNRECOGNIZED_OPERATION,
						MAN_ERR_NON_SYN_NOT_SUPPORTED,
						};
					/* Module number */

CONST   uchar MODULE_NB_E10_S[]  = {
						MODULE_0,
						MODULE_1,
						MODULE_2,
						MODULE_3,
						MODULE_4,
						MODULE_5,
						MODULE_6,
						MODULE_7,
						};

					/* Operation class (MANAGMNT) */

CONST   uchar OP_CLASS_E10_S[]  = {
						UNCONFIRMED_OPERATION,
						CONFIRMED_OPERATION,
						RETURN_RESULT,
						RETURN_RESULT_CONTINUED,
						RETURN_ERROR,
						REJECT,
						};

CONST   uchar STATUS_TYPE_E10_S[]  = {
						FEATURE_NUMBER_STATUS,
						FEATURE_BUTTON_STATUS,
						MULTIPLE_BUTTON_STATUS,
						MAINTENANCE_STATUS,
						};

					/* Interpreter flag in Endpoint ID */

CONST   uchar INTERPRETER_E10_S[]  = {
						INTERPRETER_0,
						INTERPRETER_1,
						};



#endif /* } */

#if (NS_TYPE_BRI == ON) && (E10_SUPPLEMENTARY_SERVICES == ON) /* { */

					/* Adjunct control */

CONST   uchar ADJUNCT_VAL_E10_S[] = {
						ADJUNCT_ON,
						ADJUNCT_OFF,
						};

					/* Associated status */

CONST   uchar ASSOC_STATUS_E10_S[] = {
						SETUP_STATUS,
						CONNECT_STATUS,
						HOLD_STATUS,
						RECONNECT_STATUS,
						EXCLUSION_STATUS,
						CONNECT_DENIED_STATUS,
                        CLEARING_DENIED_STATUS,
                        };

                    /* Button type for activation */

CONST   uchar BUTTON_TYPE_ACT_E10_S[]  = {
                        BUTTON_TYPE_UNKNOWN,
                        CALL_APPEAR_BUTTON,
						FEATURE_BUTTON,
                        };

					/* Button type indication */

CONST   uchar BUTTON_TYPE_IND_E10_S[]  = {
                        BUTTON_TYPE_UNKNOWN,
						CALL_APPEAR_BUTTON,
                        FEATURE_BUTTON,
                        NON_APPLICABLE,
                        };

					/* Display Control Mode */

CONST   uchar DISPLAY_CON_MODE_E10_S[]  = {
                        DISPLAY_NO_CHANGE,
                        DISPLAY_NORMAL,
                        DISPLAY_INSPECT,
                        DISPLAY_MISC_DISPLAY_INFO,
                        DISPLAY_MSG_RETRIEVAL,
                        DISPLAY_ELECTRONIC_DIR_QUERY,
                        };

                    /* Display Field Mode */

CONST   uchar DISPLAY_FLD_MODE_E10_S[]  = {
                        DISPLAY_NORMAL,
                        DISPLAY_INSPECT,
                        DISPLAY_MISC_DISPLAY_INFO,
                        DISPLAY_MSG_RETRIEVAL,
                        DISPLAY_ELECTRONIC_DIR_QUERY,
                        };

                    /* Display Field Type */

CONST   uchar DISPLAY_FLD_TYPE_E10_S[]  = {
						CALL_APPEAR_ID,
                        CALLED_PARTY_ID,
                        CALLING_PARTY_ID,
                        CALLED_PARTY_NAME,
                        CALLING_PARTY_NAME,
                        ORIGINATING_PERMISSIONS,
                        ISDN_CALL_ID,
                        MISC_CALL_INFO,
                        ENTIRE_DISPLAY,
                        DATE_TIME_OF_DAY,
                        };

                    /* Display Submode */

CONST   uchar DISPLAY_SUBMODE_E10_S[]  = {
                        DISPLAY_NO_SUBMODE,
						DISPLAY_SUBMODE_DIRECT,
						DISPLAY_SUBMODE_REDIRECTED,
						};

					/* Feature Meaning */

CONST   uchar FEATURE_MEANING_E10_S[]  = {
						FEATURE_MEANING_RESERVED,
						FEATURE_MEANING_TURN_ALL_OFF,
						};

					/* Hook value */

CONST   uchar HOOK_VAL_E10_S[]  = {
						HOOK_ON,
						HOOK_OFF,
						};


					/* Call reference type */

CONST   uchar CALL_REF_TYPE_E10_S[]  = {
						CALL_REF_NULL,
						CALL_REF_NOT_NULL,
						};

#endif /* } */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/*						Primary rate specific Values						*/
/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if NS_TYPE_PRI == ON /* { */

		/* User to user information protocol discriminator (ie UUI) */

CONST	uchar E10_UUI_PROTOCOL_DISCR_S[] = {
	PROTOCOL_DISCR_USER_SPF,
	PROTOCOL_DISCR_OSI,
	PROTOCOL_DISCR_X244,
	PROTOCOL_DISCR_SYSTEM_MANAGEMENT,
	PROTOCOL_DISCR_IA5,
	PROTOCOL_DISCR_V120,
	PROTOCOL_DISCR_Q931,
	};

		/* Restriction level (TRAVELING_CLASSMARK) */

CONST	uchar E10_FAC_RESTR_LEVEL_S[] = {
	0,1,2,3,4,5,6,7
};

		/* Satellite Hop Counter (TRAVELING_CLASSMARK) */

CONST	uchar E10_SATELLITE_HOP_S[] = {
	0,1,2,3,4,5,6,7,8,9
};

		/* End-to-end ISDN (TRAVELING_CLASSMARK) */

CONST	uchar E10_CONNECTIVITY_S[] = {
	NO_PREFERENCE,
	NO_END_TO_END_ISDN_REQUIRED,
	NO_END_TO_END_ISDN_PREFERRED,
};


		/* Change status values (CHANGE_STATUS) */

CONST	uchar E10_CHANGE_STATUS_S[] = {
	CHANNEL_IN_SERVICE,
	CHANNEL_MAINTENANCE,
	CHANNEL_OUT_OF_SERVICE,
};

		/* Coding standard (ie PRECEDENCE_LEVEL) */

CONST	uchar E10_CODING_STD_PRECEDENCE_S[] = {
	CODING_STD_CCITT,
	CODING_STD_NATIONAL,
	};


		/* Reason for redirection (ie REDIR_NB) */

CONST	uchar E10_REASON_REDIR_S[] = {
	R_UNKNOWN,
	R_CALL_FORWARDING_BUSY,
	R_CALL_FORWARDING_NO_REPLY,
	R_CALL_FORWARDING_DTE_OUT,
	R_CALL_FORWARDING_BY_CALLED,
	R_CALL_FORWARDING_UNCONDITIONAL,
	};

		/* Precedence level (PRECEDENCE_LEVEL) */

CONST	uchar E10_PRECEDENCE_S[] = {
	L_FLASH_OVERRIDE,
	L_FLASH,
	L_IMMEDIATE,
	L_PRIORITY,
	L_ROUTINE,
};

		/* Change value (PRECEDENCE_LEVEL) */

CONST	uchar E10_CHANGE_VALUE_S[] = {
	CHANGED_AT_NET_BOUNDARIES,
	NOT_CHANGED_AT_NET_BOUNDARIES,
};

		/* LFB indicators (PRECEDENCE_LEVEL) */

CONST	uchar E10_LFB_S[] = {
	LFB_ALLOWED,
	LFB_NOT_ALLOWED,
	LFB_PATH_RESERVED,
};

		/* Restart indicator class (ie RESTART_IND) */

CONST	uchar E10_RESTART_IND_CLASS_S[] = {
	RI_INDICATED_CHANNEL,
	RI_SINGLE_INTERFACE,
	RI_ALL_INTERFACES,
	};

#endif /* } */

/*=========================================================================*/

	/* Tables selected according to another value (indexed tables) */

		/* Cause value  according to the class */

			/* Normal event - class 000 */

CONST	uchar E10_C_V_NORMAL_EVENT_0_S[] = {
	C_C_NORMAL_EVENT_0,
	C_V_UNASSIGNED_NUMBER_1,
	C_V_NO_ROUTE_TO_TRANSIT_NET_2,
	C_V_NO_ROUTE_TO_DEST_3,
	C_V_PREEMPTION_8,
	C_V_CIRCUIT_RESERVED_FOR_REUSE_9,
};

			/* Normal event - class 001 */

CONST	uchar E10_C_V_NORMAL_EVENT_S[] = {
	C_C_NORMAL_EVENT,
	C_V_NORMAL_CLEARING_16,
	C_V_USER_BUSY_17,
	C_V_NO_USER_RESPONDING_18,
	C_V_NO_ANSWER_19,
	C_V_CALL_REJECT_21,
	C_V_NUMBER_CHANGED_22,
	C_V_DEST_OUT_OF_ORDER_27,
	C_V_INVALID_NUMBER_FORMAT_28,
	C_V_FACILITY_REJECT_29,
	C_V_RESPONSE_TO_STATUS_ENQUIRY_30,
	C_V_NORMAL_UNSPECIFIED_31
};

			/* Resource not available */

CONST	uchar E10_C_V_RESOURCE_UNAVAILABLE_S[] ={
	C_C_RESOURCE_UNAVAILABLE,
	C_V_NO_CIRCUIT_AVAILABLE_34,
	C_V_CALL_QUEUED_35,
	C_V_NETWORK_TEMPORARY_FAILURE_41,
	C_V_NETWORK_CONGESTION_42,
	C_V_ACCESS_INFORMATION_DISCARDED_43,
	C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44,
	C_V_PRECEDENCE_CALL_BLOCKED_46,
	C_V_RESOURCE_UNAVAILABLE_UNSPECIFIED_47

};

			/* Service not available */

CONST	uchar E10_C_V_SERVICE_NOT_AVAILABLE_S[] = {
	C_C_SERVICE_NOT_AVAILABLE,
	C_V_REQUESTED_FAC_NOT_SUBSCRIBED_50,
	C_V_OUTGOING_CALLS_BARRED_52,
	C_V_INCOMING_CALLS_BARRED_54,
	C_V_BC_NOT_AUTHORIZED_57,
	C_V_BC_NOT_PRESENTLY_AVAILABLE_58,
	C_V_SERVICE_NOT_AVAILABLE_63,
};

			/* Service not implemented */

CONST	uchar E10_C_V_SERVICE_NOT_IMPLEMENTED_S[] = {
	C_C_SERVICE_NOT_IMPLEMENTED,
	C_V_BC_NOT_IMPLEMENTED_65,
	C_V_CHANNEL_TYPE_NOT_IMPLEMENTED_66,
	C_V_REQUESTED_FAC_NOT_IMPLEMENTED_69,
};

			/* Invalid message */

CONST	uchar E10_C_V_INVALID_MESSAGE_S[] = {
	C_C_INVALID_MESSAGE,
	C_V_INVALID_CALL_REF_81,
	C_V_IDENTIFIED_CHANNEL_NOT_EXIST_82,
	C_V_INCOMPATIBLE_DESTINATION_88,
	C_V_INVALID_TRANSIT_NETWORK_SELECTION_91,
};

			/* Protocol error */

CONST	uchar E10_C_V_PROTOCOL_ERROR_S[] = {
	C_C_PROTOCOL_ERROR,
	C_V_MANDATORY_IE_MISSING_96,
	C_V_MESSAGE_TYPE_NON_EXISTENT_97,
	C_V_MESSAGE_STATE_INCONSISTENCY_98,
	C_V_INVALID_IE_CONTENT_100,
	C_V_MESSAGE_NOT_COMPATIBLE_101,
	C_V_RECOVERY_ON_TIMER_EXPIRY_102,
	C_V_PROTOCOL_ERROR_UNSPECIFIED_111,
};

			/* Interworking */

CONST	uchar E10_C_V_INTERWORKING_S[] = {
	C_C_INTERWORKING,
	C_V_INTERWORKING_UNSPECIFIED_127,
};

/*-------------------------------------------------------------------------*/

					/* Channel selection according to interface type (ie CHAN_ID) */

CONST	uchar E10_CHAN_SEL_BRI_S[] = {
	INT_TYPE_BRI,
	NO_CHAN,
	B1_CHAN,
	B2_CHAN,
	ANY_CHAN,
};

CONST	uchar E10_CHAN_SEL_PRI_S[] = {
	INT_TYPE_PRI,
	NO_CHAN,
	AS_INDICATED,
	CHAN_RESERVED,
	ANY_CHAN,
};


CONST	uchar E10_REDIR_PLAN_UNKNOWN_S[] = {
	PLAN_UNKNOWN,
	NB_UNKNOWN,
};

CONST	uchar E10_REDIR_PLAN_ISDN_S[] = {
	PLAN_ISDN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
};

CONST	uchar E10_REDIR_PLAN_PRIVATE_S[] = {
	PLAN_PRIVATE,
	NB_ABBREVIATED,
};

CONST	uchar E10_REDIR_PLAN_DATA_S[] = {
	PLAN_DATA,
	NB_ABBREVIATED,
};

/*-------------------------------------------------------------------------*/
					/* Information transfer rate (ie LLC) according to transfer mode */

CONST	uchar E10_LLC_TRF_RATE_CIRCUIT_S[] = {
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	TRF_RATE_2x64KBS,
	TRF_RATE_384KBS,
	TRF_RATE_1536KBS,
	TRF_RATE_1920KBS,
	};

CONST	uchar E10_LLC_TRF_RATE_PACKET_S[] = {
	TRF_MODE_PACKET,
	TRF_RATE_PACKET_MODE,
	};

/*-------------------------------------------------------------------------*/

CONST	uchar E10_BINARY_S[] = {
	SPF_FAC_BINARY,
	ATT_BINARY_VPN,
	ATT_BINARY_MEGACOM_800,
	ATT_BINARY_MEGACOM,
	ATT_BINARY_INWATS,
	ATT_BINARY_WATS,
	ATT_BINARY_OPERATOR_LOCAL,
	ATT_BINARY_OPERATOR_DEFAULT,
	ATT_BINARY_ACCUNET,
	ATT_BINARY_LONG_DISTANCE,
	ATT_BINARY_INTERNATIONAL_800,
	ATT_BINARY_E_TANDEM_NET,
	ATT_BINARY_PRIVATE_VIRTUAL_NET,
	ATT_BINARY_DIAL_IT_MULTIQUEST,
	ATT_BINARY_NATIONAL_INWATS,
	ATT_BINARY_NATIONAL_OUTWATS,
	};


CONST	uchar E10_PARAMETER_S[] = {
	SPF_FAC_PARAMETER,
	ATT_PARAM_WATS,
	ATT_PARAM_NATIONAL_OUTWATS,
	ATT_PARAM_FOREIGN_EXCHANGE,
	ATT_PARAM_TIE_TRUNK,

	};

#if NS_TYPE_BRI == ON /* { */

/*-------------------------------------------------------------------------*/


			/* Layer 1 protocol identifier for BC IE */

CONST   uchar BC_PROTOCOL_ID_1_E10_S[]  = {
						LAYER_ID_1,
						PROTOCOL_ID_1_RA_I461,
						PROTOCOL_ID_1_G711_u,
						};

			/* Layer 2 protocol identifier for BC IE */

CONST   uchar BC_PROTOCOL_ID_2_E10_S[]  = {
						LAYER_ID_2,
						PROTOCOL_ID_2_X25_LL,
						};

			/* Layer 3 protocol identifier for BC IE */

CONST   uchar BC_PROTOCOL_ID_3_E10_S[]  = {
						LAYER_ID_3,
						PROTOCOL_ID_3_X25_PL,
						};

/*-------------------------------------------------------------------------*/

			/* Layer identifier list for BC according to the transfer mode */

CONST   uchar LAYER_ID_CIRCUIT_E10_S[]  = {
						TRF_MODE_CIRCUIT,
						LAYER_ID_1,
						};

CONST   uchar LAYER_ID_PACKET_E10_S[]  = {
						TRF_MODE_PACKET,
						LAYER_ID_2,
						LAYER_ID_3,
						};

/*-------------------------------------------------------------------------*/
            /* Operation type for unconfirmed class */

CONST   uchar OP_TYPE_UNCONFIRMED_E10_S[]  = {
                        UNCONFIRMED_OPERATION,
                        OP_TYPE_EV_REPORT,
                        };

            /* Operation type for confirmed class */

CONST   uchar OP_TYPE_CONFIRMED_E10_S[]  = {
                        CONFIRMED_OPERATION,
                        OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for return result class */

CONST   uchar OP_TYPE_RETURN_RESULT_E10_S[]  = {
                        RETURN_RESULT,
                        OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for return result continued class */

CONST   uchar OP_TYPE_RETURN_RESULT_2_E10_S[]  = {
                        RETURN_RESULT_CONTINUED,
                        OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for return error class */

CONST   uchar OP_TYPE_RETURN_ERROR_E10_S[]  = {
                        RETURN_ERROR,
                        OP_TYPE_ACTION,
                        OP_TYPE_GET,
                        OP_TYPE_SET,
                        };

            /* Operation type for reject class */

CONST   uchar OP_TYPE_REJECT_E10_S[]  = {
						REJECT,
						OP_TYPE_DEFAULT,
						};

/*-------------------------------------------------------------------------*/

            /* Management code for operation type = Action */

CONST   uchar MAN_CODE_ACTION_E10_S[]  = {
                        OP_TYPE_ACTION,
                        MAN_CODE_ACTIVATE_LOOPBACK,
                        MAN_CODE_DEACTIVATE_LOOPBACK,
                        MAN_CODE_INIT_ERR_REPORTING,
                        MAN_CODE_TERMINATE_ERR_REPORTING,
                        MAN_CODE_DIAG_TEST,
                        MAN_CODE_RESET,
                        };

            /* Management code for operation type = Event report */

CONST   uchar MAN_CODE_EV_REPORT_E10_S[]  = {
                        OP_TYPE_EV_REPORT,
                        MAN_CODE_INIT_RQ,
                        MAN_CODE_ENDPOINT_SERVICE_STATE,
                        MAN_CODE_ACTIVATE_LOOPBACK,
                        MAN_CODE_DEACTIVATE_LOOPBACK,
                        MAN_CODE_ERROR_REPORT,
                        MAN_CODE_DIAG_TEST_REPORT,
                        MAN_CODE_THRESHOLD_ALARM,
                        };

            /* Management code for operation type = Get */

CONST   uchar MAN_CODE_GET_E10_S[]  = {
                        OP_TYPE_GET,
                        MAN_CODE_SERVICE_PROFILE_INFO,
                        MAN_CODE_ADD_INFO,
                        MAN_CODE_CALL_STATUS_INFO,
                        MAN_CODE_EQUIPMENT_INFO,
						MAN_CODE_PERIPHERAL_INFO,
                        MAN_CODE_INTERFACE_INFO,
                        MAN_CODE_COUNTER_INFO,
                        };

            /* Management code for operation type = Set */

CONST   uchar MAN_CODE_SET_E10_S[]  = {
                        OP_TYPE_SET,
                        MAN_CODE_SERVICE_PROFILE_INFO,
                        MAN_CODE_ADD_INFO,
                        MAN_CODE_CALL_STATUS_INFO,
                        MAN_CODE_EQUIPMENT_INFO,
                        MAN_CODE_PERIPHERAL_INFO,
                        MAN_CODE_INTERFACE_INFO,
                        MAN_CODE_COUNTER_INFO,
                        };

#endif /* } */

/*-------------------------------------------------------------------------*/

		/*
			Meta description of the information elements.
			This description is  used to check an information element
			inside a message and to store its value into  the internal
			structure.
			In the other way it is used to generate the information element of
			a message from the internal structure.
		*/

#define NS_INCLUDE_IE_META_FUNCTION		ON		/* include prototypes of functions inside mp_ie.e10 */

#include "e10.mp_ie"  /* include IE meta-programs */

/*-------------------------------------------------------------------------*/

uchar e10_calling_nb_spdu ()
{

		/* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;		/* in general case, process octet 3a */

	if ((direction == TO_D_CHANNEL) &&
		(I_calling_nb_presentation == PRES_ALLOWED) &&
		(I_calling_nb_screen_ind   == USER_PROVIDED)
	   ) {
		ie_if_flag = OFF;	/* default values used : omit octet 3a */
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name		e10_chan_id_check  - Test if interface type in chan_id IE and in
							configuration are the same. If not return error.

Usage		uchar e10_chan_id_check ();

Return value :  e10_chan_id_check  returns = OK	valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar e10_chan_id_check  ()
{

#if (NS_MAINTENANCE_CAPABILITY == ON) && (NS_TYPE_PRI == ON)
	struct nsna FAR *p_sav;
#endif

	if (direction == FROM_D_CHANNEL) {

		if (I_chan_id_int_type == INT_TYPE_BRI) {
			if (Na_type != BRI) return (NOK);
			if (I_(chan_id, d_chan) == D_CHAN) return (NOK);

		} else {

			if (Na_type != PRI) return (NOK);
		}

	}

		/* Process PRI type chan_id */

#	if NS_TYPE_PRI == ON /* { */

		if (I_(chan_id,int_type) != INT_TYPE_BRI) {

			if (direction == TO_D_CHANNEL) {

				if (I_(chan_id,chan_sel) == NO_CHAN) {
					return (OK);
				}

			} else {

				if ((I_(chan_id,chan_sel) == NO_CHAN) ||
					(I_(chan_id,chan_sel) == ANY_CHAN)) {
					ie_optional_octet = ON;
				}
			}

			if (direction == FROM_D_CHANNEL) {

#				if NS_MAINTENANCE_CAPABILITY == ON

						/*
						 * Check if the interface Id is valid.
						 * We don't need to do that if the
						 * NFAS TSP was selected because in that
						 * case, we have no idea of what are the interfaces
						 * the application is dealing with.
						 *
						 * if ns_nfas in OFF, we have TSP and no D channel Backup.
						 * if ns_nfas in ON, we still may have a TSP (with D channel backup)
						 */

					if (ns_nfas == ON) {

							/* Check if we have a TSP mode */

						if ((Na_maint_type != NFAS_TSP_BKP) &&
							(Na_maint_type != NO_NFAS)) {

								/*
								 * No TSP mode --> check the int_id.
								 */

							p_sav = p_nsna;

							if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {

								if (ns_access_na (I_(chan_id, int_id_val)) == NOK) {
									p_nsna = p_sav;
									return (NOK);
								}
							}

							p_nsna = p_sav;
						}
					}

#				endif

				return (r_exec_spdu_ie ((uchar *)&E10_CHAN_ID_PRI_P));

			} else {

				return (s_exec_spdu_ie ((uchar *)&E10_CHAN_ID_PRI_P));
			}

		}

#	endif /* } */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			llc_spdu - implements the processing of the low layer
							compatibility (LLC) IE of a received SPDU
							message and of SPDU message to be sent.

Usage			uchar llc_spdu ();

Return value :  llc_spdu returns = OK valid data,
								 = NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar e10_llc_4ab_spdu ()
{
	ie_if_flag = ON;	/* octets 4a and 4b may be present */

	if ((direction			== TO_D_CHANNEL)			&&
		(i_llc[0].structure == STRUCTURE_DEFAULT)		&&
		(i_llc[0].config	== CONFIG_POINT_TO_POINT)	&&		/* forced value anyway */
		(i_llc[0].est		== EST_DEMAND)				&&		/* forced value anyway */
		(i_llc[0].symmetry	== BIDIRECTIONAL_SYMMETRY)	&&		/* forced value anyway */
		(i_llc[0].dest_rate == i_llc[0].trf_rate)) {

		/* default values for octets 4a and 4b : they are omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar e10_llc_4b_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 4b may be present */

	if ((direction		 == TO_D_CHANNEL)			&&
		(i_llc[0].symmetry	 == BIDIRECTIONAL_SYMMETRY)	&&		/* forced value anyway */
		(i_llc[0].dest_rate == i_llc[0].trf_rate)) {

		/* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

#define Get_layer_id()	Extract (5,Mask(2))

uchar e10_llc_5_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 5 may be present */

		/* if I_llc_protocol_id_1 == BYTE_VAL_NIL -> octet 5 is missing */

	if (direction == TO_D_CHANNEL) {

		if (i_llc[0].protocol_id_1 == BYTE_VAL_NIL) {

				/* octet 5 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_1) {

				/* It is NOT Octet 5 (layer 1) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar e10_llc_6_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 6 may be present */

		/* if I_llc_layer_id_2 == BYTE_VAL_NIL -> octet 6 is missing */

	if (direction == TO_D_CHANNEL) {

			/* octet 6 must be present if PACKET MODE */

		if (i_llc[0].protocol_id_2 == BYTE_VAL_NIL) {

			/* octet 6 is missing */

			if (i_llc[0].trf_mode == TRF_MODE_PACKET) return (NOK);

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_2) {

				/* It is NOT Octet 6 (layer 2) */

			ie_if_flag = OFF;
		}
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar e10_llc_7_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 7 may be present */

		/* if I_llc_layer_id_3 == BYTE_VAL_NIL -> octet 7 is missing */

	if (direction == TO_D_CHANNEL) {

		if (i_llc[0].protocol_id_3 == BYTE_VAL_NIL) {

				/* octet 7 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_3) {

				/* It is NOT Octet 7 (layer 3) */

			ie_if_flag = OFF;
		}
	}

	return (OK);
}

#if NS_SPF_FACILITY == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		e10_spf_fac_spdu - implements the processing of the specific facility
						  IE (received or to be sent in a SPDU message).

Usage	   uchar e10_spf_fac_spdu ();

Return value :  e10_spf_fac_spdu returns = OK   valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar e10_spf_fac_spdu ()
{

	if (direction == TO_D_CHANNEL) {

		if (check_convert (	(uchar FAR *) Get_p_ie,
							I_spf_fac_a_net_id,
							I_spf_fac_net_id_lgth,
							IA5, ANY_CHAR
						  ) != OK ) return (NOK);
	} else {

		if (check_convert (	I_spf_fac_a_net_id,
							(uchar FAR *) Get_p_ie,
							I_spf_fac_net_id_lgth,
							IA5, ANY_CHAR
						  ) != OK ) return (NOK);

	}

	Inc_p_ie (I_spf_fac_net_id_lgth-2);

	return (OK);

}

#endif

/****************************************************************************/
/*					Basic Rate specific IES meta programms					*/
/****************************************************************************/

#if NS_TYPE_BRI == ON /* { */

uchar e10_bc_layer_nb_spdu ()
{

	ie_if_flag = OFF;

	if (direction == FROM_D_CHANNEL) {

            /* FROM D CHANNEL : set layer_nb to '2' if not end of BC IE */

        if (! Eo_ie) {
            I_(bc,Layer_nb) = 2;
            ie_if_flag = ON;
        }

    } else {
            /* TO D CHANNEL : continue the ie processing if layer_nb == 2 */

        if (I_(bc,Layer_nb) == 2) {
            ie_if_flag = ON;
        }
    }

    return (OK);
}

uchar e10_bc_is_layer_spdu ()
{

    ie_if_flag = ON;

    if (direction == TO_D_CHANNEL) {

        if (I_(bc,Layer_nb) == 0) {
            ie_if_flag = OFF;
        }

    } else {

		if (! Eo_ie) {
			I_(bc,Layer_nb) = 1;

		} else {

			I_(bc,Layer_nb) = 0;
			ie_if_flag = OFF;
		}
	}

	return (OK);
}

uchar e10_keypad_spdu ()
{

	if (Call_current_exist) {

            /* Set the Call_keypad_in_setup flag if SETUP SPDU */

        Call_keypad_in_setup = ((spdu_id == SETUP) ? ON : Call_keypad_in_setup);
	}
    
	return (OK);
}

/*-------------------------------------------------------------------------*/

uchar e10_spdu_man_parameters ()
{

	uchar   last_param_id           = 0;                    /* last parameter id backup up */
	uchar   recognized_parameter    = OFF;                  /* to know if at least one parameter has been recognized */
	uchar   counter                 = I_man_param_counter;  /* local counter */

	if (direction == FROM_D_CHANNEL) {
		I_man_param_counter = 0;        /* initialize the parameter counter */

		if (Eo_ie) {

                /* if there is no param, then process the message */

            recognized_parameter = ON;
        }

        while (!Eo_ie) {
            I_man_param_id = Get_bits (Get_ie_octet, 0, 7);

                /* check parameters sequence order */

            if (I_man_param_id <= last_param_id) {
                return (NOK);

            } else {

                last_param_id = I_man_param_id;
            }

            if (Get_bits (Get_inc_ie_octet, EXT_POSITION, EXT_LGTH) == EXT_LAST) {
                I_man_param_lgth = Get_inc_ie_octet;

				switch (I_man_param_id) {

					case PARAM_SPID :
                        if (check_convert ( (uchar FAR *) I_man_param_a_spid,
											(uchar FAR *) Get_p_ie,
                                            I_man_param_lgth,
                                            IA5, ANY_CHAR
                                          ) != OK ) return (NOK);
                        recognized_parameter = ON;          /* to know that one parameter has been recognized */
                        p_ie += I_man_param_lgth;
                        break;

                    case PARAM_ENDPOINT_ID :
                        I_man_param_usid (I_man_param_counter)  = Get_inc_ie_octet;
                        I_man_param_tid (I_man_param_counter)   = Get_bits (Get_ie_octet, 0, 7);
                        I_man_param_esf (I_man_param_counter)   = Get_bits (Get_inc_ie_octet, 7, 1);
                        recognized_parameter = ON;          /* to know that one parameter has been recognized */
                        break;

                    default :

                            /* ignore parameter and point on the next one */

                        Inc_p_ie (I_man_param_lgth);
                        break;

                }

                I_man_param_counter++;
            }

        }

        if (recognized_parameter == OFF) {
            return (NOK);
        }

    } else {

		I_man_param_counter = 0;

        while (counter > I_man_param_counter) {
            *p_ie = 0;
            Put_ie_field (0, 7, I_man_param_id);

                /* check parameters sequence order */

            if (I_man_param_id <= last_param_id) {
				return (NOK);

			} else {

                last_param_id = I_man_param_id;
            }

            switch (I_man_param_id) {

                case PARAM_SPID :
                    Put_ie_field (EXT_POSITION, EXT_LGTH, EXT_LAST);
                    Inc_p_ie (1);
                    Put_inc_ie_octet (I_man_param_lgth);

                    if (check_convert ( (uchar FAR *) Get_p_ie,
                                        (uchar FAR *) I_man_param_a_spid,
                                        I_man_param_lgth,
                                        IA5, ANY_CHAR
                                      ) != OK ) return (NOK);
                    Inc_p_ie (I_man_param_lgth);
                    break;

                case PARAM_ENDPOINT_ID :
                    Put_ie_field (EXT_POSITION, EXT_LGTH, EXT_LAST);
                    Inc_p_ie (1);
                    Put_inc_ie_octet (I_man_param_lgth);
					Put_inc_ie_octet (I_man_param_usid (I_man_param_counter));
					*p_ie = I_man_param_tid (I_man_param_counter);
					Put_ie_field (7, 1, I_man_param_esf (I_man_param_counter));
                    Inc_p_ie (1);
                    break;

                default :

                        /* ignore parameter content for the moment */

                    Put_ie_field (EXT_POSITION, EXT_LGTH, EXT_LAST);
                    Inc_p_ie (1);
                    break;

            }
            I_man_param_counter++;

		}

	}

	return (OK);
}

#endif /* } */

/****************************************************************************/
/*					Primary Rate specific IES meta programms				*/
/****************************************************************************/

#if NS_TYPE_PRI == ON /* { */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			bc_xxx_spdu - implements the processing of the Bearer
						   capability (BC) IE of a received SPDU
						   message and of a SPDU message to be sent.

Usage			uchar bc_xxx_spdu ();

Return value :  bc_xxx_spdu returns	= OK valid data,
									= NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar e10_bc_4ab_spdu ()
{
	ie_if_flag = ON;	/* octets 4a and 4b may be present */

	if (direction == TO_D_CHANNEL) {

			/* 'dest_rate' must be equal to 'trf_rate' */

		I_(bc,dest_rate) = I_(bc,trf_rate);

		if (I_(bc, trf_rate) == TRF_RATE_MULTI_RATE) {

				/* default values for octets 4a and 4b : they are omitted */

			ie_if_flag = OFF;

		} else {


			if ((I_(bc,structure)	== STRUCTURE_DEFAULT)		&&
				(I_(bc,config)		== CONFIG_POINT_TO_POINT)	&&
				(I_(bc,est)			== EST_DEMAND)				&&
				(I_(bc,symmetry)	== BIDIRECTIONAL_SYMMETRY)) {

					/* default values for octets 4a and 4b : they are omitted */

				ie_if_flag = OFF;
			}
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar e10_bc_4b_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 4b may be present */

	if ((direction			== TO_D_CHANNEL)			&&
		(I_(bc,symmetry)	== BIDIRECTIONAL_SYMMETRY)) {

		/* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar e10_bc_5_spdu ()
{

	ie_if_flag = ON;

	if (direction == TO_D_CHANNEL) {

		if (I_(bc, protocol_id_1) == BYTE_VAL_NIL) {

			/* octet 5 is missing */

			ie_if_flag = OFF;
		}
	}

	return (OK);
}

uchar e10_chk_change_status ()
{

	if (direction == FROM_D_CHANNEL) {

		if (protocol_discr == PROTOCOL_DISCR_MAINT_NATIONAL) {

			if (I_(change_status, preference != PREF_D_CHANNEL)) {

				return (NOK);
			}

			if (I_(change_status, status != CHANNEL_IN_SERVICE)) {

				return (NOK);
			}
		}
	}

	return (OK);
}

/*-------------------------------------------------------------------------*/

uchar e10_conn_nb_spdu ()
{

		/* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;		/* in general case, process octet 3a */

	if ((direction == TO_D_CHANNEL) &&
		(I_(conn_nb,pres) == PRES_ALLOWED) &&
		(I_(conn_nb,screen_ind)   == USER_PROVIDED)
	   ) {
		ie_if_flag = OFF;	/* default values used : omit octet 3a */
	}

	return (OK);
}

/*-------------------------------------------------------------------------*/

uchar e10_redir_nb_spdu ()
{

		/* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;		/* in general case, process octet 3a */

	if ((direction 				== TO_D_CHANNEL) &&
		(I_(redir_nb,pres)		== PRES_ALLOWED) &&
		(I_(redir_nb,screen_ind)== USER_PROVIDED)
	   ) {
		ie_if_flag = OFF;	/* default values used : omit octet 3a */
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		e10_restart_spdu - check if presence of CHAN ID IE is compulsory or forbidden.

Usage		uchar e10_restart_spdu ();

Return value :  e10_restart_spdu returns = OK   valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar e10_restart_spdu ()
{

	if (is_ie_i (CODESET_0, CHAN_ID) == ABSENT) {
		return (OK);

	} else {

		if (I_restart_ind_class != RI_ALL_INTERFACES) {
			return (OK);
		}

	}

	return (NOK);
}

#endif /* } */

/*-------------------------------------------------------------------------*/

	/*
	 * This routine must be defined after the 2 meta programs
	 */

uchar e10_bc_spdu ()
{

	if (direction == FROM_D_CHANNEL) {

#		if NS_TYPE_BRI == ON

			if (Na_type == BRI) return (r_exec_spdu_ie ((uchar *)&E10_BC_BRI_P));

#		endif

#		if NS_TYPE_PRI == ON

			if (Na_type == PRI) return (r_exec_spdu_ie ((uchar *)&E10_BC_PRI_P));

#		endif

	} else {

#		if NS_TYPE_BRI == ON

			if (Na_type == BRI) return (s_exec_spdu_ie ((uchar *)&E10_BC_BRI_P));

#		endif

#		if NS_TYPE_PRI == ON

			if (Na_type == PRI) return (s_exec_spdu_ie ((uchar *)&E10_BC_PRI_P));

#		endif
	}

	return (NOK);
}

/*-------------------------------------------------------------------------*/

#define Ns_e10_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_e10_end_table_or_function		};
#define Ns_e10_tab_tabl_entry(idx, tab)		Ns_tab_tabl_entry (idx, tab),
#define Ns_e10_tabx_list_entry(tab)			Ns_tabx_list_entry (tab),
#define Ns_e10_tab_tabx_entry(idx, tab)		Ns_tab_tabx_entry (idx, tab),

#define Ns_e10_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off)	\
			Ns_tab_ie_entry (codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off),

#define Ns_e10_tab_ie_msg_header			{CODESET_NIL, MESSAGE_HEADER, (uchar *)A_NIL, sizeof(struct i_message_header), (uchar *)Pic_address (&i_message_header), (uchar *)A_NIL, (uchar *)A_NIL, 1, 0},

#include "e10.tab_ie"		/* include other Tables describing the IEs */

#define E10_MX_TABL (sizeof(E10_TAB_TABL)/sizeof (struct tabl))
CONST	uchar	e10_size_tab_tabl = E10_MX_TABL;

#define E10_MX_TABX (sizeof(E10_TAB_TABX)/sizeof (struct tabx))
CONST	uchar	e10_size_tab_tabx = E10_MX_TABX;

CONST	uchar	e10_size_tab_ie = Rnd_sizeof (E10_TAB_IE) / IE_ELEM_SIZE;	/* maximum number of item in the table */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if (NS_TYPE_BRI == ON) && (E10_SUPPLEMENTARY_SERVICES == ON) /* { */

#   if NEW_FCT_STYLE == ON
		uchar   e10_check_1_254_spdu    (uchar FAR * p_i_field);
		uchar   e10_check_sca_spdu      (uchar FAR * p_i_field);
#   else
		uchar   e10_check_1_254_spdu    ();
		uchar   e10_check_sca_spdu      ();
#   endif

/*------------------------------------------------------------------------*/

uchar   e10_dest_call_appear_spdu ()        /* test for value between 1 and 254 */
{
	return (e10_check_1_254_spdu (&(I_dest_call_appear_button_nb)));

}

/*------------------------------------------------------------------------*/

uchar   e10_feature_act_spdu ()             /* test for value between 1 and 254 */
{
	return (e10_check_1_254_spdu (&(I_feature_act_button_nb)));
}

/*------------------------------------------------------------------------*/

uchar   e10_feature_ind_init_spdu ()        /* init flag for MBS */
{
    I_feature_ind_i_flag = ON;
    I_feature_ind_i_counter_spdu = 0;
    return (OK);
}

/*------------------------------------------------------------------------*/

uchar   e10_feature_ind_spdu ()
{
    switch (I_feature_ind_status_type) {

        case FEATURE_NUMBER_STATUS :

            if ((Get_ie_octet == 0) || (Get_ie_octet == 253) || (Get_ie_octet == 255)) return (NOK);
            I_feature_ind_feature_spdu = Get_inc_ie_octet;

				/* implicit check : indicatore is coded 000 */

            switch (Get_ie_octet) {
                case STATUS_ACTIVATED :
                case STATUS_DEACTIVATED :
                case STATUS_PENDING :
                case STATUS_LOCAL_HOLD :
                case STATUS_REMOTE_HOLD :
                case STATUS_CONFIRMED :
                case STATUS_ALREADY_IN_RQ_STATE :
                case STATUS_REJECTED :
                    I_feature_ind_status_spdu = Get_inc_ie_octet;
                    break;
                default :
                    return (NOK);
            }

            if (Eo_ie) return (OK);
            if (++I_feature_ind_i_counter_spdu >= 84)   return (NOK);
			return (e10_feature_ind_spdu ());

        case FEATURE_BUTTON_STATUS :

			if (e10_check_1_254_spdu (&(I_feature_ind_feature_spdu)) != OK) return (NOK);

            switch (Get_bits (Get_ie_octet,5,3)) {
                case INDICATOR_0 :
				case INDICATOR_1 :
                case INDICATOR_2 :
                case INDICATOR_3 :
                    I_feature_ind_indicator_spdu = Get_bits (Get_ie_octet,5,3);
                    break;
                default :
                    return (NOK);
            }

            switch (Get_bits(Get_ie_octet,0,5)) {
                case STATUS_ACTIVATED :
                case STATUS_DEACTIVATED :
                case STATUS_PENDING :
                case STATUS_LOCAL_HOLD :
                case STATUS_REMOTE_HOLD :
                case STATUS_CONFIRMED :
                case STATUS_ALREADY_IN_RQ_STATE :
                case STATUS_REJECTED :
					I_feature_ind_status_spdu = Get_bits (Get_ie_octet,0,5);
                    Inc_p_ie (1);
                    break;
                default :
                    return (NOK);
            }

            if (Eo_ie) return (OK);
            if (++I_feature_ind_i_counter_spdu >= 84)   return (NOK);
			return (e10_feature_ind_spdu ());

        case MULTIPLE_BUTTON_STATUS :

            if (I_feature_ind_i_flag == ON) {
                I_feature_ind_i_flag = OFF;
				if (e10_check_1_254_spdu (&(I_feature_ind_starting_feature)) != OK) return (NOK);
				if (e10_check_1_254_spdu (&(I_feature_ind_number_of_button)) != OK) return (NOK);
            }

            I_feature_ind_status_spdu = Get_inc_ie_octet;

            if (Eo_ie) return (OK);
            if (++I_feature_ind_i_counter_spdu >= 252)  return (NOK);
			return (e10_feature_ind_spdu ());

        case MAINTENANCE_STATUS :
			return (r_exec_spdu_ie ((uchar *)&E10_FEATURE_IND_MS_SPDU));

        default :
            return (NOK);
    }
}

/*------------------------------------------------------------------------*/

uchar   e10_ori_call_appear_spdu ()         /* test for value between 1 and 254 */
{
	return (e10_check_1_254_spdu (&(I_ori_call_appear_button_nb)));
}

/*------------------------------------------------------------------------*/

uchar   e10_sel_call_appear_spdu ()         /* test for value between 0 and 254 from D channel */
{

	struct call FAR *p_call_sav;

	ret_code = (e10_check_sca_spdu  (&(I_sel_call_appear_button_nb)));

	if (ret_code == OK) {

		Dl_button_net 		= I_sel_call_appear_button_nb;
		p_call_sav = p_call;

		if (Dl_button_p_call != P_NIL) {

				/* Get the saved call */

			p_call = (struct call FAR *) Dl_button_p_call;

				/* Reset the button table */

			Dl_button_p_call = P_NIL;

				/* Send the previous SETUP */

			Send_saved_spdu_to_d_channel (SETUP);

				/* The saved SPDU is no more useful */

			Release_saved_spdu ();

				/*
				 * The network ackowledged our "button" request
				 * so T300 may be stoped
				 */

			Stop_timer_ns (E10_T300);

				/* Start 303 */

			Start_timer_ns (E10_T303);

				/* Go to State 1 */

			Set_state (STATE_CALL_INIT_1);

				/* p_call is useless */

			p_call = P_NIL;

		}

		p_call = p_call_sav;
	}

	return (ret_code);

}

/*------------------------------------------------------------------------*/

uchar   e10_check_1_254_spdu (p_i_field)    /* test for value between 1 and 254 */
	uchar FAR * p_i_field;
{
	uchar   code;           /* code */

	if (direction == FROM_D_CHANNEL) {

		code = Get_inc_ie_octet;

		if (code > 0 && code < 255) {
			*p_i_field = code;
            return (OK);

        } else {

			return (NOK);
        }

    } else {

            /* from CALL_CONTROL - check done at the receipt of the ssdu */

        if ((*p_i_field == 0) || (*p_i_field == 255)) return (NOK);
        Put_inc_ie_octet (*p_i_field);
        return (OK);
    }

}

/*------------------------------------------------------------------------*/

uchar   e10_check_sca_spdu (p_i_field)
    uchar FAR * p_i_field;
{
    uchar   code;           /* code */

    if (direction == FROM_D_CHANNEL) {

        code = Get_inc_ie_octet;

        if (code < 255) {       /* network may send Null Call Appearance */
            *p_i_field = code;
            return (OK);

        } else {

            return (NOK);
        }

    } else {

            /* from CALL_CONTROL - check done at the receipt of the ssdu */

        if ((*p_i_field == 0) || (*p_i_field == 255)) return (NOK);
        Put_inc_ie_octet (*p_i_field);
        return (OK);
    }

}

/*------------------------------------------------------------------------*/

uchar e10_call_ref_to_conn_id ()
{
    struct call *p_save_call;
    uchar        lgth;
    uchar        ret = OK;

        /* save internal call reference */

    I_call_ref_sav      = I_call_ref;
    I_call_ref_lgth_sav = I_call_ref_lgth;
    p_save_call         = p_call;
    I_call_ref          = CALL_REF_NIL;     /* default conn_id is CONN_ID MANAGMNT */

        /*
           Call reference length according to network access rate interface.
           Init i_call_ref (internal call reference value).
		*/

    Dec_p_ie(1);                /* position to call reference length */
    I_call_ref_lgth = Get_inc_ie_octet;

    if (Na_type == BRI) {

        if ((I_call_ref_lgth < Spdu_param_call_ref_lgth_bri_min) || (I_call_ref_lgth > Spdu_param_call_ref_lgth_bri_max)) {
            ret     = NOK;
        }

    } else {

        if ((I_call_ref_lgth < Spdu_param_call_ref_lgth_pri_min) || (I_call_ref_lgth > Spdu_param_call_ref_lgth_pri_max)) {
            ret     = NOK;
        }

    }

    if  ( !(Is_call_ref_nil) && (ret == OK) ) {

            /* Load internal call reference */

        lgth    = I_call_ref_lgth;
        I_call_ref = ((Get_ie_octet >> 7) ^ 1) + ((Get_ie_octet & Mask (7)) << 1);
        Inc_p_ie (1);

		while (--lgth != 0) {
            I_call_ref += Get_inc_ie_octet << (lgth * 8);
        }

#	if EQUIPMENT == NT2

	/*
		Internal call ref takes into account the DL CES for incoming calls
		because the same call ref may be used on different DL connections.
	*/

		if (Na_fct == FG_NT_TE) {

			if (!Is_call_ref_outgoing_call) {

				Ns_concat_ces_and_call_ref (R_msg_ces);
			}
		}

#	endif

			/* search actif call with call reference */

		if ( (ret = ns_access_call_ref (I_call_ref)) == OK) {

				/* load associated Conn_id if actif call found */

			I_other_call_ref_conn_id = Call_conn_id;
		}
	}

		/* restore call context */

	p_call = p_save_call;

		/* restore internal call reference */

	I_call_ref      = I_call_ref_sav;
	I_call_ref_lgth = I_call_ref_lgth_sav;
	return (ret);
}

#endif      /* } TYPE_BRI */

/*-------------------------------------------------------------------------*/

#if OM_CODE_TYPE == OM_PIC /* PIC used{ */

#undef Ns_e10_table_or_function

#undef Ns_e10_end_table_or_function
#undef Ns_e10_tab_tabl_entry
#undef Ns_e10_tabx_list_entry
#undef Ns_e10_tab_tabx_entry
#undef Ns_e10_tab_ie_entry
#undef Ns_e10_tab_ie_msg_header

#define Ns_e10_table_or_function(str, tab)	i_pic = 0;						\
											{								\
												struct str FAR	*p_table;	\
												p_table = tab;

#define Ns_e10_end_table_or_function		}

#define Ns_e10_tab_tabl_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_val, (uchar *)tab);
#define Ns_e10_tabx_list_entry(tab)			Pic_init_struct_array_next (p_table,  p_val, (uchar	*)tab);
#define Ns_e10_tab_tabx_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_tab, (struct tabx_list *)tab);

#define Ns_e10_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off)	\
	Pic_init_struct_array (p_table,  i_pic, p_prog, (uchar	*)mp_a);			\
	Pic_init_struct_array (p_table,  i_pic, p_i_struct, (uchar	*)i_str);		\
	Pic_init_struct_array (p_table,  i_pic, p_init_spdu, (uchar	*)df_spdu);		\
	Pic_init_struct_array_next (p_table,  p_init_ssdu, (uchar	*)df_ssdu);

#define Ns_e10_tab_ie_msg_header		Ns_e10_tab_ie_entry (0, 0, P_NIL, &i_message_header, P_NIL, P_NIL, 0, 0)

		/*	Function used to initialize address fields in Tables above */


void pic_init_ns_e10_ie ()
{
	uchar	i_pic;			/* current index */

#	include "e10.tab_ie"
}

#endif /* end of PIC used} */


/*EOF*/
