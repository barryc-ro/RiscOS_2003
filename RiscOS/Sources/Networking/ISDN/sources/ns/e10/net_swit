
/*--------------------------------------------------------------------------*
 *						M O D U L E		H E A D E R
 *
 * filename - net_switch.e10
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *      e10_csc_dl_reinit 			- implement an unexpected data link reinit.
 *
 *		e10_circuit_switched_call	- implements the processing of the call
 *								  		control procedures.
 *
 *
 *		e10_circuit_switched_call_n - implements the processing of the call
 *										control procedures.
 *
 *		e10_send_init				- send a SPID to the network on
 *										call ref nil.
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#if NEW_FCT_STYLE == ON
	void	e10_u0						(void);
	void	e10_u1						(void);
	void	e10_u2						(void);
	void	e10_u3						(void);
	void	e10_u4						(void);
	void	e10_u6						(void);
	void	e10_u7						(void);
	void	e10_u8						(void);
	void	e10_u9						(void);
	void	e10_u10						(void);
	void	e10_u11						(void);
	void	e10_u12						(void);
	void	e10_u19						(void);
	void	e10_csc_dl_reinit			(void);
	void	e10_send_init 				(void);
	uchar	e10_circuit_switched_call	(void);
	uchar	e10_error_handler			(void);
	uchar	e10_bkp_maint_proc			(code_t p1, nai_t p2);
	uchar 	e10_custom_maint_proc 		(code_t code, nai_t ent_from);
	uchar 	e10_national_bkp_proc 		(code_t code, nai_t ent_from);
	uchar 	e10_national_bkp_filter		(code_t code);
	uchar 	e10_filter					(code_t p1, nai_t p2);
	void 	e10_set_b_chan_state 		(uchar chan_id, uchar restart_class, uchar b_chan_state, uchar int_id);

#	if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON) && (NS_RESTART_PROCEDURE == ON) /* { */
		uchar 	e10_maint_national		 (code_t code);
		void	e10_restart_n_pri 		 (void);
#	endif

#else
	void	e10_u0						();
	void	e10_u1						();
	void	e10_u2						();
	void	e10_u3						();
	void	e10_u4						();
	void	e10_u6						();
	void	e10_u7						();
	void	e10_u8						();
	void	e10_u9						();
	void	e10_u10						();
	void	e10_u11						();
	void	e10_u12						();
	void	e10_u19						();
	void	e10_csc_dl_reinit			();
	void	e10_send_init 				();
	uchar	e10_circuit_switched_call	();
	uchar	e10_error_handler			();
	uchar	e10_bkp_maint_proc			();
	uchar 	e10_custom_maint_proc 		();
	uchar 	e10_national_bkp_proc 		();
	uchar 	e10_national_bkp_filter		();
	uchar 	e10_filter					();
	void 	e10_set_b_chan_state 		();

#	if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON) && (NS_RESTART_PROCEDURE == ON) /* { */
		uchar 	e10_maint_national		();
		void	e10_restart_n_pri 		();
#	endif

#endif

#if NS_TYPE_BRI == ON

#	if NEW_FCT_STYLE == ON
		uchar e10_send_mim				(uchar);
		uchar e10_access_i_man_param	(uchar);
		uchar e10_ns_ei					(code_t p1, ces_t p2);
		uchar e10_match_usid_tid 		(uchar usid, uchar tid, uchar interp);
#	else
		uchar e10_send_mim				();
		uchar e10_access_i_man_param	();
		uchar e10_ns_ei					();
		uchar e10_match_usid_tid 		();
#	endif

#define	Rcv_dl_code						R_msg_inf0

#endif

						/*--------------*/
						/*				*/
						/*	USER SIDE	*/
						/*				*/
						/*--------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	e10_csc_dl_reinit () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN).

Usage           	void e10_csc_dl_reinit ();

Related
functions usage		void e10_csc_dl_reinit ();

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA

*--------------------------------------------------------------------------*/

void e10_csc_dl_reinit ()
{
	/* nothing to do */
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			e10_circuit_switched_call - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage		  	uchar e10_circuit_switched_call ();

Related
functions usage void e10_u0 .... e10_u19 ()

Description	 e10_circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value	uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

/*                                CLEARING PROCEDURES
*
*		TE                         NT/NETWORK                        TE
* _________________             _________________            _________________
* |               |             |               |            |               |
* |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
* |==========>....|------------>|.......|.....  |            |               |
* | start T305    |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
* |<===========...|<------------|...    |    ...|----------->|...===========>|
* |  stop T305  . |             |start T308     |            |    NS_CLEAR_RS|
* |             . | DA_DISC_COMP|   start T305  |     REL    |  .<===========|
* |             ..|------------>|       |    ...|<-----------|...  start T308|
* |               |             |       |    .  |            |               |
* |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
* |               |             |       |    ...|----------->|...===========>|
* |               |             |       |       |            |     stop T308 |
* |---------------|             |---------------|            |---------------|
*/

uchar e10_circuit_switched_call ()
{

#if (NS_RESTART_PROCEDURE == ON) || (NS_MAINTENANCE_CAPABILITY == ON)
	uchar	chan_id;
	uchar	FAR *p_data;
	nai_t	int_id;
#endif

#if NS_TYPE_BRI == ON /* { */

		/*
			Information messages used with the null call reference
			for terminal management
		*/

#	if E10_SUPPLEMENTARY_SERVICES == ON /* { */

		if (Is_call_ref_nil) {

			switch (event_id) {

				case DA_INFO :

					if (Na_subscription_tm != OFF) {

						Send_to_call_control (NS_SPF_FACILITY_CO);

					} else {

						ns_unexpected_ev ();
					}

					return (OK);

				case NS_INFO_RQ :

					if (Na_subscription_tm != OFF) {

						if (is_ie_i (CODESET_0, SWITCHHOOK) == PRESENT) {

							if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
								Trap (TRAP_NO_CES, "ns_snd_dl");
							}

							Dl_button_internal	= ON;
							Dl_button_user 		= BYTE_VAL_NIL;
						}

						if (is_ie_i (CODESET_6, FEATURE_ACT) == PRESENT) {

							if (Ns_access_dl_ces (Na_dl_ces) == NOK) {
								Trap (TRAP_NO_CES, "ns_snd_dl");
							}

							Dl_button_internal	= ON;
							Dl_button_user 		= I_feature_act_button_nb;
						}

						Send_to_d_channel (INFO);

					} else {

						ns_unexpected_ev ();
					}

					return (OK);
			}

		}

#	endif /* } */

		/*
			ENDPOINT INITIALIZATION PROCEDURES
		*/

	switch (i_entity_origination) {

		case ENT_DL_D :			/* from network event */

			if (event_id == DA_MAN_INFO) {

					/* Set MIM event ID */

				if	( (I_man_op_class	== UNCONFIRMED_OPERATION)	&&
					  (I_man_op_type	== OP_TYPE_EV_REPORT)		&&
					  (I_man_code		== MAN_CODE_INIT_RQ) )		{
					Ns_ei (EV_INIT_RQ, Na_dl_ces);				/* call to Endpoint Initialization Procedure */
				} else

				if ( (I_man_op_class	== CONFIRMED_OPERATION)	&&
					 (I_man_op_type		== OP_TYPE_SET)			&&
					 (I_man_code		== MAN_CODE_ADD_INFO) )	{
					Ns_ei (EV_ASSIGN_USID_TID, Na_dl_ces);		/* call to Endpoint Initialization Procedure */
				} else

				if ( (I_man_op_class	== REJECT)	&&
					 (I_man_op_type		== OP_TYPE_DEFAULT) )	{
					Ns_ei (EV_REJECT, Na_dl_ces);				/* call to Endpoint Initialization Procedure */

				} else

				if ( (I_man_op_class	== CONFIRMED_OPERATION)	&&
					 (I_man_op_type		== OP_TYPE_GET) )	{
					Ns_ei (EV_GET, Na_dl_ces);				/* call to Endpoint Initialization Procedure */

				} else {

					Ns_ei (EV_NO_USID_TID, Na_dl_ces);
				}

				return (OK);

			}

			if (is_ie_i (CODESET_6, E10_ENDPOINT_ID) == ABSENT) {

					/* Any message with no USID-TID */

				if (Ns_ei (EV_NO_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			} else if (Dl_ces == DL_CES_BROADCAST) {

					/* Any broadcast message with USID-TID */

				if (Ns_ei (EV_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			} else {

					/* Any broadcast message with USID-TID */

				if (Ns_ei (EV_NOT_BROADCAST_WITH_USID_TID, Na_dl_ces) != CONTINUE) {
					return (OK);
				}

			}
			break;

		case ENT_CC :		/* from user event */

				/* User action */

			if (Ns_ei (EV_USER_ACTION, DL_CES_SIG) != CONTINUE) {
				return (OK);
			}
			break;

		case ENT_TI :

			if (event_id == TI_SPID) {

				return (OK);
			}

			break;

		default :
			break;

	}

#endif /* } BRI */

/*.........................................................................*/

	if (i_entity_origination == ENT_MNS) {

		switch (event_id) {

#			if NS_RESTART_PROCEDURE == ON /* { */

				case MNS_RESTART_RQ :

						/* authorized only on Primary rate interface */

					if (Na_type == BRI) {

							/* Return MNS_RESTART_CO with error ("restart procedures not implemented") and do nothing else */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_NOT_IMPLEMENTED);
						return (STOP);
					}

					p_data = p_ssdu;

#					if NS_MAINTENANCE_CAPABILITY == OFF

						if (Dl_rest_state == STATE_REST_0) {


							if (Dl_call_count == 0) {

									/* Return MNS_RESTART_CO and do nothing else */

								ns_send_mns_restart (OK, I_restart_ind_class, Mns_restart_b_chan_nb, 0);
								return (OK);

							} else {

								ns_unexpected_ev ();
							}

						}

#					else

						if (ns_nfas == ON) {

							p_nsdl = Nfas_dl_p_active_d_chan;
						}

	 					Dl_rest_class = I_restart_ind_class;
                        
#					endif


#					if NS_TYPE_PRI == ON /* { */

							/* set current data pointer using p_ssdu pointer */

						if (I_restart_ind_class != RI_ALL_INTERFACES) {

							I_chan_id_d_chan 	= NOT_D_CHAN;	/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;
							I_chan_id_chan_sel 	= AS_INDICATED;	/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;	/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

#							if NS_MAINTENANCE_CAPABILITY == ON

								Dl_rest_int_id	= Nai;

								if (Nfas_nai_active_d_chan != Mns_restart_interface) {
									I_chan_id_int_id 	= INT_ID_EXPLICIT;
									I_chan_id_int_id_val= Mns_restart_interface;
									Dl_rest_int_id		= Mns_restart_interface;
								}

#							endif

							if (I_restart_ind_class == RI_INDICATED_CHANNEL) {
								I_chan_id_a_chan_number  = p_ind_buffer++;			/* save data into indirect buffer */
								*I_chan_id_a_chan_number = Mns_restart_b_chan_nb;	/* channel number */
							} else {

								I_(chan_id,chan_sel) = NO_CHAN;
								set_ie_i (CODESET_0, CHAN_ID);
							}
						}

						if (I_restart_ind_class == RI_ALL_INTERFACES) {
							csc_clear_all_call ();
							Na_internal_restart = ON;
						}

#						if NS_MAINTENANCE_CAPABILITY == ON
							e10_set_b_chan_state (Mns_restart_b_chan_nb, I_restart_ind_class, MAINT_STATE_B_OOS_FE_ACK, Mns_restart_interface);
#						endif

						Send_to_call_control (NS_RESTART_IN);	/* on CONN_ID_MANAGEMENT */
						Start_dl_timer (E10_T317);
						Set_call_ref_not_nil ();

						if (I_chan_id_a_chan_number != A_NIL) {

							/* Set the extension bit to 1 in the chan_nb field before sending SPDU */

							Set_ext_bit (*I_chan_id_a_chan_number);
						}

						Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
						N316 = 0;
						Start_dl_timer (E10_T316);
						Dl_rest_state = STATE_REST_1;

#					endif /* } */

					break;

#			endif /* } */

#			if (NS_MAINTENANCE_CAPABILITY == ON) /* { */

				case MNS_SERVICE_RQ :

						/* Set p_data pointers to start of data */

					p_data = p_ssdu;

					I_(change_status, preference) 	= Mns_service_pref;
					I_(change_status, status) 		= Mns_service_status;

					switch (Mns_service_pref) {

						case I_PREF_D_CHANNEL :

							if (Mns_service_action_type == I_MAINTENANCE) {

									/* No D channel maintenance */

								ns_send_mns_service (I_D_MANAGEMENT_NOT_SUPPORTED, Mns_service_int_id, BYTE_VAL_NIL);
								return (OK);
							}

							I_(change_status, preference) = PREF_INTERFACE;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= NO_CHAN;				/* Channel Number as indicated in following octets */

							break;

						case I_PREF_B_CHANNEL :
							I_(change_status, preference) = PREF_B_CHANNEL;

							I_chan_id_int_id	= INT_ID_EXPLICIT;		/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= AS_INDICATED;			/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;			/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_type = B_CHAN;				/* B-Channel number */
							I_chan_id_chan_number_lgth = 1;				/* 1 Channel number */

							I_chan_id_a_chan_number = p_ind_buffer++;	/* save data into indirect buffer */
							Set_ext_bit (Mns_service_b_chan);
							*I_chan_id_a_chan_number = Mns_service_b_chan;	/* channel number */

							break;

						case I_PREF_INTERFACE :
							I_(change_status, preference) = PREF_INTERFACE;

							I_chan_id_int_id	= INT_ID_EXPLICIT;		/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= NO_CHAN;				/* Channel Number as indicated in following octets */
							break;
					}

						/* Set the 2 IEs */

					set_ie_i (CODESET_0, CHAN_ID);
					set_ie_i (CODESET_0, CHANGE_STATUS);

					e10_bkp_maint_proc (R_msg_code, i_entity_origination);

					break;

#				endif /* } */

#				if ASSERT == ON

				default :
					Trap (TRAP_MNS_CODE, "e10_circuit_switched_call");

#				endif

		}

		return (OK);

	}

					/* 1 - EVENT DRIVEN PROCESSING  */

	switch (event_id) {

						/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

						/* SETUP : allocate a call context */

		case DA_SETUP :

			if (allocate_call (INCOMING_CALL, 0) != OK) {
				Reset_internal_ie ();
				set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
				Send_to_d_channel (REL_COMP);
				return (OK);
			}

#			if NS_MAINTENANCE_CAPABILITY == ON

				if (Na_type == PRI) {

						/* B channel must be IS or OSS NE */

					chan_id = (*I_chan_id_a_chan_number) & 0x7f;

						/*
						 * Get the interface Id
						 */

					int_id = Nai;

					if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

						if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {
							int_id = I_(chan_id, int_id_val);
						}

					}

					if ((Dl_b_chan_mode_int (int_id, chan_id) != MAINT_STATE_B_IS) &&
						(Dl_b_chan_mode_int (int_id, chan_id) != MAINT_STATE_B_OOS_NE)) {

						Reset_internal_ie ();
						set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
						Send_to_d_channel (REL_COMP);
						call_clear ();
						return (OK);
					}

				}

#			endif

			break;

						/* DISCONNECT */

		case DA_DISC :

			switch (Call_state) {

				case STATE_DISCONNECT_REQUEST_11 :

#					if NS_TYPE_PRI == ON

						if (Na_type == PRI) {

							Stop_timer_ns (E10_T305);
							Send_to_call_control (NS_CLEAR_IN);
							Reset_internal_ie ();

							if (disc_cause_error () == NOK) {
								set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
							}

							go_to_state_19 (E10_T308);
						}

#					endif

					break;

				case STATE_DISCONNECT_INDICATION_12 :
				case STATE_RELEASE_REQUEST_19 :
					break;

				case STATE_CONNECT_REQUEST_8 :
					Release_saved_spdu ();			/* saved CONN no more useful */

				default :
					ns_stop_all_timers ();
					Send_to_call_control (NS_CLEAR_IN);
					Set_state (STATE_DISCONNECT_INDICATION_12);
					break;

			}

			return (OK);

						/* RELEASE */

		case DA_REL :

			Send_to_call_control (NS_CLEAR_CO);
			Reset_internal_ie ();
			set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);

			if ((Na_type == PRI) ||
				((Na_type == BRI) && (Call_state != STATE_RELEASE_REQUEST_19))) {
				Send_to_d_channel (REL_COMP);
			}

			call_clear ();
			return (OK);

						/* RELEASE COMPLETE */

		case DA_REL_COMP :

			Send_to_call_control (NS_CLEAR_CO);
			call_clear ();							/* free call context */
			return (OK);

						/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			switch (Call_state) {

				case STATE_WAIT_DL :
					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					break;

#				if NS_TYPE_BRI == ON

					case STATE_CALL_PRESENT_6 :

						if (! ((is_ie_i (CODESET_0, CAUSE) == PRESENT) &&
							   (I_cause_class == C_C_NORMAL_EVENT)     &&
							   (I_cause_val   == C_V_NO_ANSWER_19)	   &&
							   (p_nsdl != P_NIL)					   &&
							   (Dl_ei_state   == EI_STATE_M_INIT))
						   ) {

							Send_to_d_channel (REL_COMP);
						}

						Reset_internal_ie ();
						Send_to_call_control (NS_CLEAR_CO);
						call_clear ();
						break;

					case SUB_STATE_34 :
						ns_unexpected_ev ();
						break;

					case STATE_OUTGOING_CALL_PROC_3 :
					case STATE_CALL_DELIVERED_4 :
					case STATE_ACTIVE_10 :

						if (Na_type == BRI) {

							if (Na_subscription_key != OFF) {
								Call_sub_state = Call_state;
							}
						}

						ns_stop_all_timers ();
						Save_cause ();								/* to send the RELEASE if T305 expire */
						Send_to_d_channel (DISC);					/* send a DISCONNECT message */
						Start_timer_ns (E10_T305);					/* start T305 */
						Set_state (STATE_DISCONNECT_REQUEST_11);	/* enter the Disconnect Request state */
						break;

#				endif

				case STATE_DISCONNECT_INDICATION_12 :
					disc_cause_error ();
					Stop_timer_ns  (E10_T300);
					go_to_state_19 (E10_T308);
					break;

				case STATE_CALL_INIT_1 :
					Release_saved_spdu ();						/* saved setup no more useful */

					if (   (is_ie_i (CODESET_0, CAUSE) == PRESENT) 		&&
						   (I_cause_class == C_C_RESOURCE_UNAVAILABLE)  &&
						   (I_cause_val   == C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44)&&
						   (Na_type == BRI)) {
						Reset_internal_ie ();
						Send_to_call_control (NS_CLEAR_CO);
						call_clear ();
						break;
					}

					/* process the default */

				default :
					ns_stop_all_timers ();
					Save_cause ();								/* to send the RELEASE if T305 expire */
					Send_to_d_channel (DISC);					/* send a DISCONNECT message */
					Start_timer_ns (E10_T305);					/* start T305 */
					Set_state (STATE_DISCONNECT_REQUEST_11);	/* enter the Disconnect Request state */
					break;

			}

			return (OK);

						/* STATUS */

		case DA_STATUS :

			if (Call_current_exist) {

				switch (I_call_state_val) {

					case STATE_NULL_0 :
					case STATE_RELEASE_REQUEST_19 :
						Send_to_call_control (NS_CLEAR_CO);
						call_clear ();
						break;

					case STATE_DISCONNECT_REQUEST_11 :
						Stop_timer_ns (E10_T305);
						Send_to_call_control (NS_CLEAR_IN);
						Reset_internal_ie ();

						if (disc_cause_error () == NOK) {
							set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
						}

						go_to_state_19 (E10_T308);
						break;

					case STATE_DISCONNECT_INDICATION_12 :
						Send_to_call_control (NS_CLEAR_CO);
						Reset_internal_ie ();
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
						Send_to_d_channel (REL_COMP);
						call_clear ();
						break;

					default :

						if (Call_state != I_call_state_val) {

							Send_to_call_control (NS_CLEAR_IN);
							Reset_internal_ie ();

							if (disc_cause_error () == NOK) {
								set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
							}

							go_to_state_19 (E10_T308);
						}

						break;

				}

			}

#			if (NS_RESTART_PROCEDURE == ON) && (NS_TYPE_PRI == ON) /* { */

				else {		/* NON CALL-ASSOCIATED */

					switch (Dl_rest_state) {

						case STATE_REST_0 :
							break;

						case STATE_REST_1 :

							if (I_call_state_val != STATE_REST_2) {
								ns_stop_all_dlci_timers ();
								ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_STATE_INCOMP);
								Dl_restart_reset ();
							}

							break;

						case STATE_REST_2 :

							if (I_call_state_val != STATE_REST_1) {
								ns_snd_mns (MNS_RESTART_IN);
							}

							break;
					}
				}

#			endif /* RESTART_PROCEDURE = ON} */

			return (OK);

						/* STATUS_ENQ */

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_state (Call_state);
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			Send_to_d_channel (STATUS);
			return (OK);

#		if (NS_RESTART_PROCEDURE == ON) && (NS_TYPE_PRI == ON) /* { */

			case TI_316 :

				if (Dl_rest_state == STATE_REST_1) {

					if (++N316 == E10_MX_N316) {

							/* Update B channel(s) state */

#						if NS_MAINTENANCE_CAPABILITY == ON

							if (I_chan_id_a_chan_number != P_NIL) {
								e10_set_b_chan_state (*I_chan_id_a_chan_number, I_restart_ind_class, MAINT_STATE_B_OOS_FE_REST, Dl_rest_int_id);
							} else {
								e10_set_b_chan_state (0, I_restart_ind_class, MAINT_STATE_B_OOS_FE_REST, Dl_rest_int_id);
							}

#						endif

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_316);
						Dl_restart_reset ();

					} else {

						Set_call_ref_not_nil ();

							/* store Restart Indicator with value saved in DL context */

						set_ie_i (CODESET_0, RESTART_IND);
						I_restart_ind_class = Dl_rest_class;

						if (I_restart_ind_class != RI_ALL_INTERFACES) {

								/* store Channel-ID */

							ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
							set_ie_i (CODESET_0, CHAN_ID);

							I_chan_id_d_chan 	= NOT_D_CHAN;	/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;	/* PRI */

#							if NS_MAINTENANCE_CAPABILITY == ON

								if (Dl_rest_int_id != Nai) {
									I_chan_id_int_id 	= INT_ID_EXPLICIT;
									I_chan_id_int_id_val= Dl_rest_int_id;
								}

#							endif

							if (I_restart_ind_class == RI_SINGLE_INTERFACE) {

								I_chan_id_chan_sel 	= NO_CHAN;	/* No Channel */

							} else {
								I_chan_id_chan_sel 	= AS_INDICATED;	/* Channel Number as indicated in following octets */
	                            I_chan_id_nb_map 	= CHAN_NUMBER;	/* Format of following octets = simply the B-Channel number */
                                I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */
                                I_chan_id_a_chan_number = p_ind_buffer++;			/* save data into indirect buffer */
                                *I_chan_id_a_chan_number = Dl_rest_chan_nb;	/* channel number */
                                Set_ext_bit (*I_chan_id_a_chan_number);		/* Set the extension bit to 1 in the chan_nb field before sending SPDU */
                            }
						}

						Send_to_d_channel (RESTART);			/* with CALL_REF_GLOBAL */
						Restart_dl_timer (E10_T316);
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case TI_317 :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

					if (Nfas_nai_mode == NFAS_TSP) {

						if (ns_access_na (Nfas_cfg_nai_active_d_chan) != OK) {
							return (NOK);
						}
					}

#				endif

				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
						Dl_restart_reset ();
						break;

					default :

#						if NS_MAINTENANCE_CAPABILITY == ON

							e10_bkp_maint_proc (R_msg_code, i_entity_origination);

#						else
							ns_unexpected_ev ();
#						endif
				}

				return (OK);

			case DA_RESTART :

#				if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON)

					return (e10_maint_national (DA_RESTART));

#				else

					if (Dl_rest_state == STATE_REST_0) {

						Start_dl_timer (E10_T317);
						Set_call_ref_nil ();		/* to use CONN_ID_MANAGEMENT */
						Send_to_call_control (NS_RESTART_IN);
						Dl_rest_state = STATE_REST_2;

					} else {

						ns_unexpected_ev ();
					}

					return (OK);

#				endif

			case DA_RESTART_ACK :

#				if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON)

					return (e10_maint_national (DA_RESTART_ACK));

#				else

					if (Dl_rest_state == STATE_REST_1) {

						Stop_dl_timer (E10_T316);

						if (Dl_rest_resp == ON) {

							ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
							Dl_restart_reset ();


						} else {

							Dl_rest_ack = ON;
						}

					} else {

						ns_unexpected_ev ();
					}

					return (OK);

#				endif

			case NS_RESTART_RS :

#				if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON)

					return (e10_maint_national (NS_RESTART_RS));

#				else

					Stop_dl_timer (E10_T317);

					switch (Dl_rest_state) {

						case STATE_REST_1 :

							if (Dl_rest_ack == ON) {

								ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
								Dl_restart_reset ();

							} else {

								Dl_rest_resp = ON;
							}

							break;

						case STATE_REST_2 :

							Set_call_ref_not_nil ();
							Send_to_d_channel (RESTART_ACK);
							Dl_restart_reset ();
							break;

						default :

							ns_unexpected_ev ();
					}

					return (OK);

#				endif

			case NS_RESTART_RQ :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

#				endif

				if (Dl_rest_state != STATE_REST_0) {

					call_clear ();

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#		endif /* NS_RESTART_PROCEDURE == ON} */

#		if NS_MAINTENANCE_CAPABILITY == ON

			case TI_321 :
			case TI_SRV :
			case DA_MAINT_SERVICE :
			case DA_MAINT_SERVICE_ACK :

            	if ((i_entity_origination == ENT_TI) && (event_id == TI_303)) {
                	break;
                } else {
					e10_bkp_maint_proc (R_msg_code, i_entity_origination);
					return (OK);
                }
#		endif

	} /* End switch (event_id) */

/*.........................................................................*/

					/* 2 - STATE DRIVEN PROCESSING */

			/*
					 Switch according to the call state :

				Dispatch to the function that processes the state except if
				it is a clearing event not received  in an exceptional condition.
				In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "e10_circuit_switched_call");
	}

#	if NS_MAINTENANCE_CAPABILITY == ON

			/*
             * Make sure the DL context is the active one when
             * enterring automaton.
             */

		if ((ns_nfas == ON) && (Nfas_context_exist)) {
		    p_nsdl = Nfas_dl_p_active_d_chan;
        }

#	endif

	switch (Call_state) {

			/* Null state (u0) */

		case STATE_NULL_0 :
		case STATE_WAIT_DL :
			e10_u0 ();
			break;

			/* Call initiated (u1) */

		case STATE_CALL_INIT_1 :
			e10_u1 ();
			break;

#		if NS_TYPE_BRI == ON

				/* Overlap sending (u2) */

			case STATE_OVERLAP_SENDING_2 :
				e10_u2 ();
				break;
#		endif

			/* Outgoing call proceeding (u3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			e10_u3 ();
			break;

			/* Call delivered (u4) */

		case STATE_CALL_DELIVERED_4 :
			e10_u4 ();
			break;

			/* Call present (u6) */

		case STATE_CALL_PRESENT_6 :
			e10_u6 ();
			break;

			/* Call received (u7) */

		case STATE_CALL_RECEIVED_7 :
			e10_u7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			e10_u8 ();
			break;

			/* Incoming call proceeding state (u9) */

		case STATE_INCOMING_CALL_PROC_9 :
			e10_u9 ();
			break;

			/*  Active (u10) */

		case STATE_ACTIVE_10 :
			e10_u10 ();
			break;

			/* Disconnect request (u11) */

		case STATE_DISCONNECT_REQUEST_11 :
			e10_u11 ();
			break;

			/* Disconnect indication (u12) */

		case STATE_DISCONNECT_INDICATION_12 :
			e10_u12 ();
			break;

			/* Release request (u19) */

		case STATE_RELEASE_REQUEST_19 :
			e10_u19 ();
			break;

			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "e10_circuit_switched_call");

	}

	return (OK);
}

#if (NS_TYPE_BRI == ON) && (E10_SUPPLEMENTARY_SERVICES == ON) /* { */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            e10_fco_hcdt -	implements flexible call offering and HCDT
							services procedures.
Usage           void e10_fco_hcdt (void);

Return value    no return code

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

void e10_fco_hcdt ()
{
	uchar error_flag = ON;

	if (Na_type == PRI) {
		ns_unexpected_ev ();
		return;
	}

	if (Na_subscription_fco_hcdt != OFF) {

		switch (event_id) {

			case NS_SPF_FACILITY_RQ :

				switch (I_service_id) {

					case DA_HOLD :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (E10_HOLD);
							Call_sub_state = Sub_state_hold_rq ();
							error_flag = OFF;
						}
						break;

					case DA_RECONN :

						if (Call_sub_state == Sub_state_call_on_hold ()) {
							Send_to_d_channel (E10_RECONN);
							Call_sub_state = Sub_state_reconn_rq ();
							error_flag = OFF;
						}
						break;

					case DA_DROP :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (DROP);
							Call_sub_state = SUB_STATE_35;
							error_flag = OFF;
						}
						break;

					case DA_CONF :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (CONF);
							Call_sub_state = SUB_STATE_32;
							error_flag = OFF;
						}
						break;

					case DA_TRANS :

						if (Call_sub_state == SUB_STATE_NULL_0) {
							Send_to_d_channel (TRANS);
							Call_sub_state = SUB_STATE_31;
							error_flag = OFF;
						}
						break;

					default :
						break;
				}
				break;

			case DA_HOLD_ACK :

				if ((Call_state == STATE_ACTIVE_10)  ||
					(Call_sub_state == SUB_STATE_31) ||
					(Call_sub_state == SUB_STATE_32) ||
					(Call_sub_state == Sub_state_hold_rq ())) {
					Call_sub_state = Sub_state_call_on_hold ();
					I_service_id = DA_HOLD_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					error_flag = OFF;
				}
				break;

			case DA_HOLD_REJ :

				if ((Call_state == STATE_ACTIVE_10)  ||
					(Call_sub_state == SUB_STATE_31) ||
					(Call_sub_state == SUB_STATE_32) ||
					(Call_sub_state == Sub_state_hold_rq ())) {
					I_service_id = DA_HOLD_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_RECONN_ACK :

				if (Call_sub_state == Sub_state_reconn_rq ()) {
					I_service_id = DA_RECONN_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_RECONN_REJ :

				if (Call_sub_state == Sub_state_reconn_rq ()) {
					I_service_id = DA_RECONN_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = Sub_state_call_on_hold ();
					error_flag = OFF;
				}
				break;

			case DA_TRANS_ACK :

				if (Call_sub_state == SUB_STATE_31) {
					I_service_id = DA_TRANS_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Set_state (SUB_STATE_34);
					error_flag = OFF;
				}
				break;

			case DA_TRANS_REJ :

				if (Call_sub_state == SUB_STATE_31) {
					I_service_id = DA_TRANS_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state =SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_CONF_ACK :

				if (Call_sub_state == SUB_STATE_32) {
					I_service_id = DA_CONF_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);

					if (I_other_call_ref_conn_id != Call_conn_id) {
						Set_state (SUB_STATE_34);

					} else {

						Call_sub_state = SUB_STATE_NULL_0;
					}

					error_flag = OFF;
				}

				break;

			case DA_CONF_REJ :

				if (Call_sub_state == SUB_STATE_32) {
					I_service_id = DA_CONF_REJ;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state =SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_DROP_ACK :
			case DA_DROP_REJ :

				if (Call_sub_state == SUB_STATE_35) {
					I_service_id = DA_DROP_ACK;
					set_ie_i (CODESET_0, SERVICE_ID);
					Send_to_call_control (NS_SPF_FACILITY_CO);
					Call_sub_state = SUB_STATE_NULL_0;
					error_flag = OFF;
				}
				break;

			case DA_ASSOC :

				if (Na_subscription_key != OFF) {

					switch (I_assoc_type_status) {

						case SETUP_STATUS :

							if ((Call_state == STATE_NULL_0) && (Call_ces == DL_CES_BROADCAST)) {
								Set_state (STATE_OUTGOING_CALL_PROC_3);
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;

						case EXCLUSION_STATUS :

							if (((Call_state == STATE_OUTGOING_CALL_PROC_3) ||
								 (Call_state == STATE_CALL_DELIVERED_4) ||
								 (Call_state == STATE_ACTIVE_10)
								) &&
								((Call_sub_state == SUB_STATE_NULL_0) ||
								 (Call_sub_state == Sub_state_hold_rq ())
								)
							   ) {
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;


						case CONNECT_STATUS :

							if (((Call_state == STATE_CALL_RECEIVED_7) ||
								 (Call_state == STATE_CONNECT_REQUEST_8) ||
								 (Call_state == STATE_INCOMING_CALL_PROC_9) ||
								 (Call_state == STATE_DISCONNECT_REQUEST_11)
								) &&
								(Call_sub_state == SUB_STATE_NULL_0)
							   ) {
								Set_state (STATE_ACTIVE_10);
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;


						case CLEARING_DENIED_STATUS :

							if ((Call_state == STATE_DISCONNECT_REQUEST_11) &&
								((Call_sub_state == STATE_OUTGOING_CALL_PROC_3) ||
								 (Call_sub_state == STATE_CALL_DELIVERED_4) ||
								 (Call_sub_state == STATE_ACTIVE_10)
								)
							   ) {
								Set_state (Call_sub_state);
								Call_sub_state = Sub_state_call_on_hold ();
								error_flag = OFF;
							}
							break;


						case HOLD_STATUS :
						case RECONNECT_STATUS :

							if (((Call_state == STATE_OUTGOING_CALL_PROC_3) ||
								 (Call_state == STATE_CALL_DELIVERED_4) ||
								 (Call_state == STATE_ACTIVE_10)
								) &&
								((Call_sub_state == Sub_state_call_on_hold ()) ||
								 (Call_sub_state == Sub_state_reconn_rq ())
								)
							   ) {
								error_flag = OFF;
							}
							break;

						default :
							break;

					}

					if (error_flag == OFF) {
						I_service_id = DA_ASSOC;
						set_ie_i (CODESET_0, SERVICE_ID);
						Send_to_call_control (NS_SPF_FACILITY_CO);

						if (I_assoc_type_status == SETUP_STATUS) {
							Reset_internal_ie ();
							Send_to_d_channel (ASSOC_ACK);
						}

					}

				} else {

						/* Key System not suscribed */

					ns_unexpected_ev ();
				}

				break;

			default :
				break;
		}

	}

	if (error_flag == ON) {
		ns_unexpected_ev ();
	}

}

#endif /* } */

#if NS_TYPE_BRI == ON /* { */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            e10_ns_ei - implements the endpoint initialization procedure
				for the ATT 5E10 control of maintenance actions.

Usage           uchar ns_ei (void);

Return value    return code = CONTINUE	continue the processing,
							= STOP		wait for DL establishment,
							= NOK       the call state is errored.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar e10_ns_ei (ei_event, ces)
	code_t	ei_event;	/* Endpoint Initialization Event */
	ces_t	ces;		/* CES */
{
	uchar i;

	if ((! Dl_current_exist) ||
		(Dl_ces == DL_CES_BROADCAST)) {

		if (Ns_access_dl_ces (ces) == NOK) {

#		if ASSERT == ON
			Trap (TRAP_NO_CES, "e10_ns_ei");
#		else
				return (NOK);
#		endif

		}
	}

					/* STATE DRIVEN AUTOMATON */

	switch (Dl_ei_state) {

				/* Power down */

		case EI_STATE_DOWN :

			switch (ei_event) {

				case MNS_NA_POWER_ON_RQ :
					Dl_ei_state = EI_STATE_NOT_INIT;

						/* TEI should be initialized from now */

					break;
			}

			break;

				/* Not initialized */

		case EI_STATE_NOT_INIT :
		case EI_STATE_AWAIT_EST :

			switch (ei_event) {

				case MNS_DL_DLCI_RQ :

					if ((Rcv_dl_code == DL_TEI_ASSIGNMENT) &&
						( Lc_state == LC_RELEASED )) {
						ns_snd_dl (DL_EST_RQ, ces);
					}
					break;

				case DL_EST_CO :							/* Layer 2 established */
				case EV_INIT_RQ :
				case EV_USER_ACTION :
				case EV_USER_ASSIGN_SPID :
					e10_send_mim (EV_INIT_RQ);
					break;

				case EV_BROADCAST_WITH_USID_TID :
					e10_send_mim (EV_INIT_RQ);
					return (STOP);

					/* Network support Endpoint Initialization */

				case EV_ASSIGN_USID_TID :

					Stop_dl_timer (TSPID);
					if ((i = e10_access_i_man_param (PARAM_ENDPOINT_ID)) == PARAM_NOT_FOUND) return (NOK);
					Dl_usid = I_man_param_usid (i);				/* load the USID */
					Dl_tid	= I_man_param_tid (i);				/* load the TID */
					Dl_ei_state = EI_STATE_M_INIT;

#					if NS_EVENT_REPORT == ON

							/* Send the event to MNS */

						ns_send_mns_event (NS_EVENT_SPID_OK, 0);

#					endif

					e10_send_mim (EV_ACK_USID_TID);
					break;

					/* Network does not support Endpoint Initialization */

				case EV_REJECT :							/* in a MIM */
					Stop_dl_timer (TSPID);
					Dl_ei_state = EI_STATE_P_INIT;

#					if NS_EVENT_REPORT == ON

							/* Send the event to MNS */

						ns_send_mns_event (NS_EVENT_SPID_NOK, 0);

#					endif

					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

				case EV_NO_USID_TID :

					if (event_id == DA_REL_COMP) {
						Dl_ei_state = EI_STATE_P_INIT;

					} else {

						e10_send_mim (EV_INIT_RQ);
					}

					break;

			}

			break;

				/* P-initialized (Point to point) */

		case EI_STATE_P_INIT :

			switch (ei_event) {

				case EV_INIT_RQ :
					e10_send_mim (EV_INIT_RQ);
					break;

				case EV_ASSIGN_USID_TID :

					Stop_dl_timer (TSPID);
					if ((i = e10_access_i_man_param (PARAM_ENDPOINT_ID)) == PARAM_NOT_FOUND) return (NOK);
					Dl_usid = I_man_param_usid (i);				/* load the USID */
					Dl_tid	= I_man_param_tid (i);				/* load the TID */
					Dl_ei_state = EI_STATE_M_INIT;
					e10_send_mim (EV_ACK_USID_TID);

#					if NS_EVENT_REPORT == ON

							/* Send the event to MNS */

						ns_send_mns_event (NS_EVENT_SPID_OK, 0);

#					endif

					break;

				case EV_NOT_BROADCAST_WITH_USID_TID :
				case EV_BROADCAST_WITH_USID_TID :
					e10_send_mim (EV_INIT_RQ);
					return (STOP);

				case EV_NO_USID_TID :
				case EV_USER_ACTION :
				case EV_USER_ASSIGN_SPID :
					break;

				case MNS_DL_DLCI_RQ :

					if (R_msg_inf0 == DL_TEI_REMOVAL) {
						Stop_dl_timer (TSPID);
						Dl_ei_state = EI_STATE_NOT_INIT;
					}
					break;

				case MNS_NA_POWER_OFF_RQ :
					Dl_ei_state = EI_STATE_DOWN;
					break;

			}

			break;

				/* M-initialized (Multipoint) */

		case EI_STATE_M_INIT :

			switch (ei_event) {

				case EV_INIT_RQ:
				case EV_USER_ASSIGN_SPID :
					e10_send_mim (EV_INIT_RQ);
					break;

				case EV_ASSIGN_USID_TID :

					if ((i = e10_access_i_man_param (PARAM_ENDPOINT_ID)) == PARAM_NOT_FOUND) return (NOK);
					Dl_usid = I_man_param_usid (i);				/* load the USID */
					Dl_tid	= I_man_param_tid (i);				/* load the TID */
					e10_send_mim (EV_ACK_USID_TID);
					break;

				case MNS_DL_DLCI_RQ :

					if (R_msg_inf0 == DL_TEI_REMOVAL) {
						Stop_dl_timer (TSPID);
						Dl_ei_state = EI_STATE_NOT_INIT;
					}
					break;

				case EV_BROADCAST_WITH_USID_TID :
				case EV_NOT_BROADCAST_WITH_USID_TID :

					if (e10_match_usid_tid (I_endpoint_id_usid, I_endpoint_id_tid, I_endpoint_id_interp) == FALSE) {
						return (STOP);
					}

					break;

				case EV_NO_USID_TID :
				case EV_USER_ACTION :
					break;

				case MNS_NA_POWER_OFF_RQ :
					Stop_dl_timer (TSPID);
					Dl_ei_state = EI_STATE_DOWN;
					break;

				case EV_GET :
					e10_send_mim (EV_GET);
					break;
			}

			break;

		default :

#			if ASSERT == ON
				Trap (TRAP_EI_STATE, "e10_ns_ei");
#			endif

			break;

	}

	return (CONTINUE);
}

/*------------------------------------------------------------------------*/

uchar e10_send_mim (event)

	uchar event;
{
	uchar		i;					/* local index */
	call_ref_t	saved_i_call_ref;	/* saved call reference */

	switch (event) {

		case EV_INIT_RQ :

			if (Dl_is_spid_nil) return (OK);

			if (State_dl_timer (TSPID) == ON) return (OK);

				/* load SPID in internal structure */

			I_man_param_counter 	= 0;
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= UNCONFIRMED_OPERATION;
			I_man_op_type			= OP_TYPE_EV_REPORT;
			I_man_code				= MAN_CODE_INIT_RQ;
			I_man_param_id			= PARAM_SPID;
			i = Strcpy_far	 		((char FAR *) I_man_param_a_spid,
									 (char FAR *) Dl_a_spid,
									 E10_MX_SZ_SPID+1);

			if (I_man_param_spid (i-1) == 0) i--;

			I_man_param_lgth		= i;
			I_man_param_counter 	= 1;
			break;

		case EV_ACK_USID_TID :
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= RETURN_RESULT;
			I_man_op_type			= OP_TYPE_SET;
			I_man_code				= MAN_CODE_ADD_INFO;
			I_man_param_counter 	= 0;
			I_man_param_id			= PARAM_ENDPOINT_ID;
			I_man_param_lgth		= 2;
			I_man_param_usid(0)		= Dl_usid;
			I_man_param_tid(0)		= Dl_tid;
			I_man_param_counter 	= 1;
			break;

		case EV_REJECT :
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= REJECT;
			I_man_op_type			= OP_TYPE_DEFAULT;
			I_man_code				= MAN_ERR_UNSPECIFIED;
			I_man_param_counter 	= 0;		/* no parameter returned */
			break;

		case EV_GET :
			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= RETURN_RESULT;
			I_man_op_type			= OP_TYPE_GET;
			I_man_param_counter 	= 0;		/* no parameter returned */
			break;

		default :
			return (NOK);

	}
		/* save the IE list (if any) and the internal call reference */

	save_ie_i ();
	Reset_internal_ie ();
	saved_i_call_ref = I_call_ref;

		/* for calls not established yet ( including responses to messages
		   with global call reference ) , force the call reference to global */

	if ((!Call_current_exist) ||
		(Call_current_exist && (Call_state == STATE_NULL_0))) {
		I_call_ref = CALL_REF_GLOBAL_VAL;
	}

	Set_call_ref_not_nil ();
	set_ie_i (CODESET_6, MANAGMNT);
	Send_to_d_channel (MAN_INFO);

		/* restore IE list and internal call reference */

	roll_back_ie_i ();
	I_call_ref = saved_i_call_ref;

	return (OK);
}

/*------------------------------------------------------------------------*/

uchar e10_access_i_man_param (param)
	uchar param;
{
	uchar counter = 0;

	while (I_(managmnt,param_id[counter]) != param) {

		if (++counter >= I_(managmnt,param_counter)) {
			return (PARAM_NOT_FOUND);
		}

	}

	return (counter);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name           	e10_match_usid_tid - implements TID/USID checking.

Usage           uchar e10_match_usid_tid (usid, tid, interp);

Return value    none.

Common constants and declarations : ns.h

Common objects :	current NA, DL and CALL contexts
					message current context

*--------------------------------------------------------------------------*/

uchar e10_match_usid_tid (usid, tid, interp)
	uchar usid;
	uchar tid;
	uchar interp;
{

	if (usid == E10_USID_ALL) return (TRUE);

	if (usid == Dl_usid) {

			/* USID matches */

		if (tid == BYTE_VAL_NIL) {

				/* No TID was included */

			return (TRUE);

		}

		if (interp == INTERPRETER_0) {

				/*
				 * Terminal is selected if it is assigned the indicated TID
				 * and USID value, or if tid equals TID_ALL.
				 */


			if ((tid == Dl_tid) || (tid == E10_TID_ALL)) {
				 return (TRUE);
			}

		} else {

				/*
				 * Terminal is selected if it is not assigned the indicated
				 * TID but it is assigned the USID, or tid equals TID_ALL.
				 */


			if ((tid != Dl_tid) || (tid == E10_TID_ALL)) {
				 return (TRUE);
			}

		}
	}

	return (FALSE);
}

#endif /* } */

#if EQUIPMENT == NT2


						/*-------------------*/
						/*                   */
						/*   NETWORK SIDE    */
						/*                   */
						/*-------------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            e10_circuit_switched_call_n - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage          	uchar e10_circuit_switched_call_n ();

Related
functions usage void n0 .... n19 ();

Description     e10_circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value    uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	void	e10_n0						(void);
	void	e10_n1						(void);
	void	e10_n3						(void);
	void	e10_n4						(void);
	void	e10_n6						(void);
	void	e10_n7						(void);
	void	e10_n8						(void);
	void	e10_n9						(void);
	void	e10_n10						(void);
	void	e10_n11						(void);
	void	e10_n12						(void);
	void	e10_n19						(void);
	void	e10_csc_dl_reinit_n			(void);
	uchar	e10_circuit_switched_call_n	(void);
	uchar 	e10_build_endpoint_rq 		(void);
#else
	void	e10_n0						();
	void	e10_n1						();
	void	e10_n3						();
	void	e10_n4						();
	void	e10_n6						();
	void	e10_n7						();
	void	e10_n8						();
	void	e10_n9						();
	void	e10_n10						();
	void	e10_n11						();
	void	e10_n12						();
	void	e10_n19						();
	void	e10_csc_dl_reinit_n			();
	uchar	e10_circuit_switched_call_n	();
	uchar 	e10_build_endpoint_rq 		();
#endif

/*                                CLEARING PROCEDURES
*
*       TE                         NT/NETWORK                        TE
* _________________             _________________            _________________
* |               |             |               |            |               |
* |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
* |==========>....|------------>|.......|.....  |            |               |
* | start T305    |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |               |             |  .    |    .  |            |               |
* |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
* |<===========...|<------------|...    |    ...|----------->|...===========>|
* |  stop T305  . |             |start T308     |            |    NS_CLEAR_RS|
* |             . | DA_DISC_COMP|   start T305  |     REL    |  .<===========|
* |             ..|------------>|       |    ...|<-----------|...  start T308|
* |               |             |       |    .  |            |               |
* |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
* |               |             |       |    ...|----------->|...===========>|
* |               |             |       |       |            |     stop T308 |
* |---------------|             |---------------|            |---------------|
*
*/

uchar e10_circuit_switched_call_n ()
{

#if (NS_RESTART_PROCEDURE == ON) || (NS_MAINTENANCE_CAPABILITY == ON)
	uchar	chan_id;
	uchar	FAR *p_data;
	nai_t	int_id;
#endif

#if NS_TYPE_BRI == ON /* { */

		/*
			Information messages used with the null call reference
			for terminal management
		*/

	if (Is_call_ref_nil) {

		switch (event_id) {

#			if (E10_SUPPLEMENTARY_SERVICES == ON) && (E10_TERMINAL_MANAGEMENT == ON)

			case DA_INFO :

				if (Na_subscription_tm != OFF) {
					Send_to_call_control (NS_SPF_FACILITY_CO);

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case NS_INFO_RQ :

				if (Na_subscription_tm != OFF) {
					Send_to_d_channel (INFO);

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#			endif

		}

	}

		/*
			ENDPOINT INITIALIZATION PROCEDURES
		*/

	switch (i_entity_origination) {

		case ENT_DL_D :			/* from network event */

			if (event_id == DA_MAN_INFO) {

            	if (e10_access_i_man_param (PARAM_SPID) != PARAM_NOT_FOUND) {
	            	Set_call_ref_nil ();
    	            Reset_internal_ie ();
        	        set_ie_i (CODESET_0, SPID);
					Send_to_call_control (NS_INFO_IN);
                }

                return (OK);
            }

            break;
	}

#endif /* } */


/*.........................................................................*/

	if (i_entity_origination == ENT_MNS) {

		switch (event_id) {

#			if NS_RESTART_PROCEDURE == ON /* { */

				case MNS_RESTART_RQ :

						/* authorized only on Primary rate interface */

					if (Na_type == BRI) {

							/* Return MNS_RESTART_CO with error ("restart procedures not implemented") and do nothing else */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_NOT_IMPLEMENTED);
						return (STOP);
					}

					p_data = p_ssdu;

#					if NS_MAINTENANCE_CAPABILITY == OFF

						if (Dl_rest_state == STATE_REST_0) {


							if (Dl_call_count == 0) {

									/* Return MNS_RESTART_CO and do nothing else */

								ns_send_mns_restart (OK, I_restart_ind_class, Mns_restart_b_chan_nb, 0);
								return (OK);

							} else {

								ns_unexpected_ev ();
							}

						}

#					else

						if (ns_nfas == ON) {

							p_nsdl = Nfas_dl_p_active_d_chan;
						}

	 					Dl_rest_class = I_restart_ind_class;

#					endif

#					if NS_TYPE_PRI == ON /* { */

							/* set current data pointer using p_ssdu pointer */

						if (I_restart_ind_class != RI_ALL_INTERFACES) {

							I_chan_id_d_chan 	= NOT_D_CHAN;	/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;
							I_chan_id_chan_sel 	= AS_INDICATED;	/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;	/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

#							if NS_MAINTENANCE_CAPABILITY == ON

								Dl_rest_int_id	= Nai;

								if (Nfas_nai_active_d_chan != Mns_restart_interface) {
									I_chan_id_int_id 	= INT_ID_EXPLICIT;
									I_chan_id_int_id_val= Mns_restart_interface;
									Dl_rest_int_id		= Mns_restart_interface;
								}

#							endif

							if (I_restart_ind_class == RI_INDICATED_CHANNEL) {
								I_chan_id_a_chan_number  = p_ind_buffer++;			/* save data into indirect buffer */
								*I_chan_id_a_chan_number = Mns_restart_b_chan_nb;	/* channel number */
							} else {

								I_(chan_id,chan_sel) = NO_CHAN;
								set_ie_i (CODESET_0, CHAN_ID);
							}
						}

						if (I_restart_ind_class == RI_ALL_INTERFACES) {
							csc_clear_all_call ();
							Na_internal_restart = ON;
						}

#						if NS_MAINTENANCE_CAPABILITY == ON
							e10_set_b_chan_state (Mns_restart_b_chan_nb, I_restart_ind_class, MAINT_STATE_B_OOS_FE_ACK, Mns_restart_interface);
#						endif

						Send_to_call_control (NS_RESTART_IN);	/* on CONN_ID_MANAGEMENT */
						Start_dl_timer (E10_T317);
						Set_call_ref_not_nil ();

						if (I_chan_id_a_chan_number != A_NIL) {

							/* Set the extension bit to 1 in the chan_nb field before sending SPDU */

							Set_ext_bit (*I_chan_id_a_chan_number);
						}

						Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
						N316 = 0;
						Start_dl_timer (E10_T316);
						Dl_rest_state = STATE_REST_1;

#					endif /* } */

					break;

#			endif /* } */

#			if NS_MAINTENANCE_CAPABILITY == ON /* { */

				case MNS_SERVICE_RQ :

						/* Set p_data pointers to start of data */

					p_data = p_ssdu;

					I_(change_status, preference) 	= Mns_service_pref;
					I_(change_status, status) 		= Mns_service_status;

					switch (Mns_service_pref) {

						case I_PREF_D_CHANNEL :

							if (Mns_service_action_type == I_MAINTENANCE) {

									/* No D channel maintenance */

								ns_send_mns_service (I_D_MANAGEMENT_NOT_SUPPORTED, Mns_service_int_id, BYTE_VAL_NIL);
								return (OK);
							}

							I_(change_status, preference) = PREF_INTERFACE;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= NO_CHAN;				/* Channel Number as indicated in following octets */

							break;

						case I_PREF_B_CHANNEL :
							I_(change_status, preference) = PREF_B_CHANNEL;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= AS_INDICATED;			/* Channel Number as indicated in following octets */
							I_chan_id_nb_map 	= CHAN_NUMBER;			/* Format of following octets = simply the B-Channel number */
							I_chan_id_chan_type = B_CHAN;				/* B-Channel number */
							I_chan_id_chan_number_lgth = 1;				/* 1 Channel number */

							I_chan_id_a_chan_number = p_ind_buffer++;	/* save data into indirect buffer */
							Set_ext_bit (Mns_service_b_chan);
							*I_chan_id_a_chan_number = Mns_service_b_chan;	/* channel number */

							break;

						case I_PREF_INTERFACE :
							I_(change_status, preference) = PREF_INTERFACE;

							I_chan_id_int_id	= INT_ID_EXPLICIT;	/* B-Channel indicated */
							I_chan_id_int_id_val= Mns_service_int_id;	/* B-Channel indicated */
							I_chan_id_d_chan 	= NOT_D_CHAN;			/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;			/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;         /* PRI */
							I_chan_id_chan_sel 	= NO_CHAN;				/* Channel Number as indicated in following octets */
							break;
					}

						/* Set the 2 IEs */

					set_ie_i (CODESET_0, CHAN_ID);
					set_ie_i (CODESET_0, CHANGE_STATUS);

					e10_bkp_maint_proc (R_msg_code, i_entity_origination);

					break;

#				endif /* } */

#				if ASSERT == ON

				default :
					Trap (TRAP_MNS_CODE, "e10_circuit_switched_call");

#				endif

		}

		return (OK);

	}

#	if NS_TYPE_BRI == ON

        if ((Na_type == BRI) && (Na_connection_pmp == ON) && (i_entity_origination == ENT_DL_D)) {

            if (Call_current_exist) {

                if (Call_state > STATE_CALL_PRESENT_6) {

                        /*
                         * When the a Termainal has already answered the
                         * outgoing call with an ALERT,
                         * all other answers must be cleared.
                         */

                    if (Call_ces_setup != Dl_ces) {

                    	if (event_id != DA_REL_COMP) {
                            Reset_internal_ie ();
                            set_i_cause (C_C_INVALID_MESSAGE, C_V_INVALID_CALL_REF_81, P_NIL);
                            Send_to_d_channel (REL_COMP);
                        }

                        return (OK);
                    }
                }
            }
        }

#	endif

					/* 1 - EVENT DRIVEN PROCESS */


	switch (event_id) {

							/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

							/* SETUP : allocate a call context */

		case DA_SETUP :

			if (allocate_call (INCOMING_CALL, 0) == NOK) {
				Reset_internal_ie ();
				set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_CONGESTION_42, P_NIL);
				Send_to_d_channel (REL_COMP);
				return (OK);
			}

#			if NS_MAINTENANCE_CAPABILITY == ON /* { */

				if (Na_type == PRI) {

						/* B channel must be IS or OOS NE */

					chan_id = (*I_chan_id_a_chan_number) & 0x7f;

						/*
						 * Get the interface Id
						 */

					int_id = Nai;

					if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

						if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {
							int_id = I_(chan_id, int_id_val);
						}

						if ((Dl_b_chan_mode_int (int_id, chan_id) != MAINT_STATE_B_IS) &&
							(Dl_b_chan_mode_int (int_id, chan_id) != MAINT_STATE_B_OOS_NE)) {
							Reset_internal_ie ();
							set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
							Send_to_d_channel (REL_COMP);
							call_clear ();
							return (OK);
						}
					}

				}

#			endif /* } */

			break;

							/* DISCONNECT */

		case DA_DISC :
			Call_fac_rq		= OFF;

			switch (Call_state) {

				case STATE_CALL_RECEIVED_7 :

					ns_action_to_cc (T3_NIL, E10_T300, NS_CLEAR_IN,
														 STATE_DISCONNECT_REQUEST_11);

					break;


				case STATE_CONNECT_REQUEST_8 :

					ns_action_to_cc (T3_NIL, E10_T300, NS_CLEAR_IN,
													   STATE_DISCONNECT_REQUEST_11);
					break;

				case STATE_INCOMING_CALL_PROC_9 :

					ns_action_to_cc (E10_T310, E10_T300, NS_CLEAR_IN,
														 STATE_DISCONNECT_REQUEST_11);
					break;

				case STATE_DISCONNECT_INDICATION_12 :
					Stop_timer_ns (E10_T305);
					Reset_internal_ie ();
					go_to_state_19 (E10_T308);
					break;


				case STATE_RELEASE_REQUEST_19 :
						/* no process */
					break;


				case STATE_NULL_0 :
				case STATE_CALL_PRESENT_6 :
				case STATE_DISCONNECT_REQUEST_11 :
					ns_unexpected_ev ();
					break;

				default :
					ns_stop_all_timers ();
					ns_action_to_cc (T3_NIL, E10_T300, NS_CLEAR_IN,
													   STATE_DISCONNECT_REQUEST_11);
					break;

			}

			return (OK);

							/* - RELEASE */

		case DA_REL :
			Call_fac_rq 	= OFF;

			switch (Call_state) {

				case STATE_NULL_0 :
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);					/* send the Release Complete Message to network */
					call_clear ();									/* free call context */
					break;

				case STATE_CALL_PRESENT_6 :
				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :

					Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
					Reset_internal_ie ();
					set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
					Send_to_d_channel (REL_COMP);
					call_clear ();
					break;

				default :
					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Layer 4 */
					Reset_internal_ie ();
					set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
					Send_to_d_channel (REL_COMP);					/* send the Release Complete Message to network */
					call_clear ();									/* free call context */
					break;

			}

			return (OK);


						/* - RELEASE COMPLETE */

		case DA_REL_COMP :

			Call_fac_rq	= OFF;

			switch (Call_state) {

				case STATE_NULL_0 :

					/* no process */

					break;

				case STATE_CALL_INIT_1 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_PRESENT_6 :
				case STATE_INCOMING_CALL_PROC_9 :

					if (Call_ces_setup != DL_CES_BROADCAST) {
						Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
						call_clear ();
                    }

					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :

					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear to Layer 4 */
					call_clear ();
					break;

				default :
					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Layer 4 */
					call_clear ();									/* free call context */
					break;

			}

			return (OK);

						/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			switch (Call_state) {

				case STATE_NULL_0 :
				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_INIT_1 :
					Send_to_d_channel (REL_COMP);
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

				case STATE_CALL_PRESENT_6 :

                	if (Call_ces_setup != DL_CES_BROADCAST) {

                        Stop_timer_ns (E10_T303);

                        ns_action_to_dl (T3_NIL, E10_T305, DISC,
                                                           STATE_DISCONNECT_INDICATION_12);

                    } else {

                       	Send_to_call_control (NS_CLEAR_CO);
                       	call_clear ();
                    }

					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :

					ns_action_to_dl (T3_NIL, E10_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);

					break;

				case STATE_INCOMING_CALL_PROC_9 :
					Stop_timer_ns (E10_T310);
					ns_action_to_dl (T3_NIL, E10_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);
					break;

#				if NS_TYPE_BRI == ON

					case SUB_STATE_34 :
						ns_unexpected_ev ();
						break;

					case STATE_OUTGOING_CALL_PROC_3 :
					case STATE_CALL_DELIVERED_4 :
					case STATE_ACTIVE_10 :

						if (Na_subscription_key != OFF) {
							Call_sub_state = Call_state;
						}
#				endif

				default :
					ns_stop_all_timers ();
					Save_cause ();									/* to send the RELEASE if E10_T305 expire */
					ns_action_to_dl (T3_NIL, E10_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);
					break;

			}

			return (OK);

						/* INFO */

		case DA_INFO :

        	if (!Call_current_exist) return (OK);
            
			switch (Call_state) {

				case STATE_NULL_0 :
				case STATE_CALL_INIT_1 :
				case STATE_CALL_PRESENT_6 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :

					Send_to_call_control (NS_INFO_IN);
					break;

				default :
					Send_to_call_control (NS_INFO_IN);
					break;

			}

			return (OK);

						/* STATUS */

		case DA_STATUS :

			if (Call_current_exist) {

				if (Call_state == STATE_RELEASE_REQUEST_19) {

					if (I_call_state_val == STATE_NULL_0) {
						Call_fac_rq	= OFF;
						Send_to_call_control (NS_CLEAR_CO);						/* send NS clear confirm to Layer 4 */
						call_clear ();											/* free call context */

					} else {

						if (C_v (I_cause_class, I_cause_val) ==
							C_v (C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30)) {
						}

					}

				} else {

					if (C_v (I_cause_class, I_cause_val) ==
						C_v (C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30)) {
					}

					if (Call_state != I_call_state_val) {

						if ((I_cause_class == C_C_PROTOCOL_ERROR)				&&
							((I_cause_val == C_V_MANDATORY_IE_MISSING_96)		||
							 (I_cause_val == C_V_MESSAGE_TYPE_NON_EXISTENT_97)	||
							 (I_cause_val == C_V_NON_EXISTENT_IE_99)			||
							 (I_cause_val == C_V_INVALID_IE_CONTENT_100)))	{
							Call_fac_rq	= OFF;
							Send_to_d_channel (REL_COMP);
							Send_to_call_control (NS_CLEAR_CO);
							call_clear ();
						}

					}

				}
			}

#			if (NS_RESTART_PROCEDURE == ON) && (NS_TYPE_PRI == ON) /* { */

				else {		/* NON CALL-ASSOCIATED */

					switch (Dl_rest_state) {

						case STATE_REST_0 :
							break;

						case STATE_REST_1 :

							if (I_call_state_val != STATE_REST_2) {
								ns_stop_all_dlci_timers ();
								ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_STATE_INCOMP);
								Dl_restart_reset ();
							}

							break;

						case STATE_REST_2 :

							if (I_call_state_val != STATE_REST_1) {
								ns_snd_mns (MNS_RESTART_IN);
							}

							break;
					}
				}

#			endif /* RESTART_PROCEDURE = ON} */

			return (OK);

						/* NS INFORMATION REQUEST */

		case  NS_INFO_RQ :

#			if NS_TYPE_BRI == ON

                if (!Call_current_exist) {

                    return (e10_build_endpoint_rq ());
                }
                
#			endif

			switch (Call_state) {

				case STATE_CALL_PRESENT_6 :
					/* no process */
					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :

					/* else default case */

				default :
					Send_to_d_channel (INFO);
					break;
			}

			return (OK);

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_state (Call_state);
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			Send_to_d_channel (STATUS);
			return (OK);

						/* NS_STATUS_ENQ_RQ */

		case NS_STATUS_ENQ_RQ :

			Send_to_d_channel (STATUS_ENQ);
			return (OK);

#		if (NS_RESTART_PROCEDURE == ON) && (NS_TYPE_PRI == ON) /* { */

			case TI_316 :

				if (Dl_rest_state == STATE_REST_1) {

					if (++N316 == E10_MX_N316) {

							/* Update B channel(s) state */

#						if NS_MAINTENANCE_CAPABILITY == ON

							if (I_chan_id_a_chan_number != P_NIL) {
								e10_set_b_chan_state (*I_chan_id_a_chan_number, I_restart_ind_class, MAINT_STATE_B_OOS_FE_REST, Dl_rest_int_id);
							} else {
								e10_set_b_chan_state (0, I_restart_ind_class, MAINT_STATE_B_OOS_FE_REST, Dl_rest_int_id);
							}

#						endif

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_316);
						Dl_restart_reset ();

					} else {

						Set_call_ref_not_nil ();

							/* store Restart Indicator with value saved in DL context */

						set_ie_i (CODESET_0, RESTART_IND);
						I_restart_ind_class = Dl_rest_class;

						if (I_restart_ind_class != RI_ALL_INTERFACES) {

								/* store Channel-ID */

							ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
							set_ie_i (CODESET_0, CHAN_ID);

							I_chan_id_d_chan 	= NOT_D_CHAN;	/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */
							I_chan_id_int_type 	= INT_TYPE_PRI;	/* PRI */

#							if NS_MAINTENANCE_CAPABILITY == ON

								if (Dl_rest_int_id != Nai) {
									I_chan_id_int_id 	= INT_ID_EXPLICIT;
									I_chan_id_int_id_val= Dl_rest_int_id;
								}

#							endif

							if (I_restart_ind_class == RI_SINGLE_INTERFACE) {

								I_chan_id_chan_sel 	= NO_CHAN;	/* No Channel */

							} else {
								I_chan_id_chan_sel 	= AS_INDICATED;	/* Channel Number as indicated in following octets */
	                            I_chan_id_nb_map 	= CHAN_NUMBER;	/* Format of following octets = simply the B-Channel number */
                                I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */
                                I_chan_id_a_chan_number = p_ind_buffer++;			/* save data into indirect buffer */
                                *I_chan_id_a_chan_number = Dl_rest_chan_nb;	/* channel number */
                                Set_ext_bit (*I_chan_id_a_chan_number);		/* Set the extension bit to 1 in the chan_nb field before sending SPDU */
                            }
						}

						Send_to_d_channel (RESTART);			/* with CALL_REF_GLOBAL */
						Restart_dl_timer (E10_T316);
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case TI_317 :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

					if (Nfas_nai_mode == NFAS_TSP) {

						if (ns_access_na (Nfas_cfg_nai_active_d_chan) != OK) {
							return (NOK);
						}
					}

#				endif

				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
						Dl_restart_reset ();
						break;

					default :

#						if NS_MAINTENANCE_CAPABILITY == ON

							e10_bkp_maint_proc (R_msg_code, i_entity_origination);

#						else
							ns_unexpected_ev ();
#						endif
				}

				return (OK);

			case DA_RESTART :

#				if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON)

					return (e10_maint_national (DA_RESTART));

#				else

					if (Dl_rest_state == STATE_REST_0) {

						Start_dl_timer (E10_T317);
						Set_call_ref_nil ();		/* to use CONN_ID_MANAGEMENT */
						Send_to_call_control (NS_RESTART_IN);
						Dl_rest_state = STATE_REST_2;

					} else {

						ns_unexpected_ev ();
					}

					return (OK);

#				endif

			case DA_RESTART_ACK :

#				if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON)

					return (e10_maint_national (DA_RESTART_ACK));

#				else

					if (Dl_rest_state == STATE_REST_1) {

						Stop_dl_timer (E10_T316);

						if (Dl_rest_resp == ON) {

							ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
							Dl_restart_reset ();


						} else {

							Dl_rest_ack = ON;
						}

					} else {

						ns_unexpected_ev ();
					}

					return (OK);

#				endif

			case NS_RESTART_RS :

#				if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON)

					return (e10_maint_national (NS_RESTART_RS));

#				else

					Stop_dl_timer (E10_T317);

					switch (Dl_rest_state) {

						case STATE_REST_1 :

							if (Dl_rest_ack == ON) {

								ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
								Dl_restart_reset ();

							} else {

								Dl_rest_resp = ON;
							}

							break;

						case STATE_REST_2 :

							Set_call_ref_not_nil ();
							Send_to_d_channel (RESTART_ACK);
							Dl_restart_reset ();
							break;

						default :

							ns_unexpected_ev ();
					}

					return (OK);

#				endif

			case NS_RESTART_RQ :

#				if NS_D_BACKUP == ON

					if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == ON)) {

						p_nsdl = Nfas_dl_p_active_d_chan;
					}

#				endif

				if (Dl_rest_state != STATE_REST_0) {

					call_clear ();

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#		endif /* NS_RESTART_PROCEDURE == ON} */

#		if NS_MAINTENANCE_CAPABILITY == ON

			case TI_321 :
			case TI_SRV :
			case DA_MAINT_SERVICE :
			case DA_MAINT_SERVICE_ACK :

            	if ((i_entity_origination == ENT_TI) && (event_id == TI_303)) {
                	break;
                } else {
					e10_bkp_maint_proc (R_msg_code, i_entity_origination);
					return (OK);
                }
#		endif

	} /* End switch (event_id) */

/*.........................................................................*/

				/* 2 - STATE DRIVEN PROCESS */

			/*
					 Switch according to the call state :

			   Dispatch to the function that processes the state except if
			   it is a clearing event not received  in an exceptional condition.
			   In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "e10_circuit_switched_call_n");
	}

#	if NS_MAINTENANCE_CAPABILITY == ON

			/*
             * Make sure the DL context is the active one when
             * enterring automaton.
             */

		if ((ns_nfas == ON) && (Nfas_context_exist)) {
		    p_nsdl = Nfas_dl_p_active_d_chan;
        }

#	endif

	switch (Call_state) {

			/* Null state (n0) */

		case STATE_NULL_0 :
			e10_n0 ();
			break;

			/* Call initiated (n1) */

		case STATE_CALL_INIT_1 :
			e10_n1 ();
			break;

			/* Outgoing call proceeding (n3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			e10_n3 ();
			break;

			/* Call delivered (n4) */

		case STATE_CALL_DELIVERED_4 :
			e10_n4 ();
			break;

			/* Call present (n6) */

		case STATE_CALL_PRESENT_6 :
			e10_n6 ();
			break;

			/* Call received (n7) */

		case STATE_CALL_RECEIVED_7 :
			e10_n7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			e10_n8 ();
			break;

			/* Incoming call proceeding (n9) */

		case STATE_INCOMING_CALL_PROC_9 :
			e10_n9 ();
			break;

			/*  Active (n10) */

		case STATE_ACTIVE_10 :
			e10_n10 ();
			break;

			/* Disconnect request (n11) */

		case STATE_DISCONNECT_REQUEST_11 :
			e10_n11 ();
			break;

			/* Disconnect indication (n12) */

		case STATE_DISCONNECT_INDICATION_12 :
			e10_n12 ();
			break;

			/* Release request (n19) */

		case STATE_RELEASE_REQUEST_19 :
			e10_n19 ();
			break;


			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "e10_circuit_switched_call_n");

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	e10_csc_dl_reinit_n () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN).

Usage           	void e10_csc_dl_reinit_n ();


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

void e10_csc_dl_reinit_n ()
{


}

#endif

/*-------------------------------------------------------------------------*/

						/*----------------------*/
						/*                   	*/
						/*   D channel backup	*/
						/*	   Maintenance		*/
						/*						*/
						/*	  procedures		*/
						/*						*/
						/*----------------------*/

/*-------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	void	e10_national_bkp_is_stby 	(code_t code);
	void	e10_national_bkp_mb_wait 	(code_t code);
	void	e10_national_bkp_wait_mb 	(code_t code);
	void	e10_national_bkp_is_oos 	(code_t code);
	void	e10_national_bkp_oos_wait	(code_t code);
	void	e10_national_bkp_oos_oos	(code_t code);

	void	e10_custom_is	 			(nai_t int_id, uchar b_chan, uchar action);
	void	e10_custom_is_ack 			(nai_t int_id, uchar b_chan);
	void	e10_custom_osne 			(nai_t int_id, uchar b_chan);
	void	e10_custom_osfe_ack 		(nai_t int_id, uchar b_chan);
	void	e10_custom_osfe		 		(nai_t int_id, uchar b_chan, uchar action);
	void 	e10_maint_ack_1 			(nai_t int_id, uchar b_chan);
	void 	e10_maint_ack_2 			(nai_t int_id, uchar b_chan);
	void	e10_custom_undef 			(nai_t int_id);

#else
	void	e10_custom_is	 			();
	void	e10_custom_is_ack 			();
	void	e10_national_bkp_is_stby 	();
	void	e10_national_bkp_mb_wait 	();
	void	e10_national_bkp_wait_mb 	();
	void	e10_national_bkp_is_oos 	();
	void	e10_national_bkp_oos_wait	();
	void	e10_national_bkp_oos_oos	();

	void	e10_custom_osne 			();
	void	e10_custom_osfe_ack 		();
	void	e10_custom_osfe		 		();
	void 	e10_maint_ack_1 			();
	void 	e10_maint_ack_2 			();
	void	e10_custom_undef 			();

#	endif

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	e10_bkp_maint_proc () -

Usage           	uchar e10_bkp_maint_proc (code, nai);
					Note : nai is not used.


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

uchar e10_bkp_maint_proc (code, ent_from)
	code_t	code;
	nai_t	ent_from;

{
	uchar b_chan_mgt = OFF;
	uchar FAR *p_data;

	switch (ent_from) {

		case ENT_DL :
		case ENT_DL_D :

			if ((code != DL_DA_IN) && (code != DL_U_DA_IN)) {

				if (ns_nfas == OFF) return (OK);

			}

			if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

				if (I_(chan_id, d_chan) == NOT_D_CHAN) {
					b_chan_mgt = ON;
				}
			}

			break;

		case ENT_MNS :

			p_data = p_ssdu;

				/* - MNS_SERVICE_RQ - */

			if (Mns_service_pref != I_PREF_D_CHANNEL) {

				b_chan_mgt = ON;

			}

			break;

		case ENT_TI :

			if (code == TI_317) {

				b_chan_mgt = ON;
			}

			break;

	}

	switch (b_chan_mgt) {

		case ON :
			return (e10_custom_maint_proc (code, ent_from));

#		if NS_D_BACKUP == ON

			case OFF :
				return (e10_national_bkp_proc (code, ent_from));
#		endif
	}

	return (OK);
}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

uchar e10_custom_maint_proc (code, ent_from)
	code_t	code;
	nai_t	ent_from;
{
	uchar b_chan_state, b_chan, int_id;
	uchar FAR *p_data;

		/*
		 * This routine manages the B channel states.
		 * The D channels states are not managable when
		 * using the CUSTOM protocol.
		 *
		 * When enterring this routine, p_nsna points to the CC Nai
		 * context except if the message is SERVICE/ACK.
		 *
		 * The CUSTOM protocol uses from DL : DL_U_DA_IN and DL_DA_IN only.
		 *
		 * The expected primitives are :
		 *
		 *		- TI_317,
		 *		- DA_MAINT_SERVICE, DA_MAINT_SERVICE_ACK,
		 *		- MNS_SERVICE_RQ.
		 */


		/* Do some filtering */

	switch (ent_from) {

		case ENT_DL_D :
		case ENT_DL :

			switch (code) {

				case DL_DA_IN :
				case DL_U_DA_IN :
					break;

				default :
					return (OK);
			}

			break;
	}

		/* Set DL context pointer p_nsdl */

	Ns_access_dl_ces (Na_dl_ces);

	int_id = Nai;

	if (R_msg_from == ENT_TI) {
		b_chan_state= MAINT_STATE_B_UNDEF;

	} else {

			/*
			 * -1- Get the interface Id
			 */

		if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

					/*
					 * Check that the information is fpr the
					 * B channels.
					 */
			if (I_chan_id_d_chan == D_CHAN) {

					/* Wrong protocol discriminator. Ignore */

				return (OK);

			}

			if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {
				int_id = I_(chan_id, int_id_val);
			}

		}

			/*
			 * -2- Access the "int_id" Nai for messages coming from DL.
			 */

		if (direction == FROM_D_CHANNEL) {

				/* - DA_MAINT_SERVICE, DA_MAINT_SERVICE_ACK - */

				/* Select the right CC Nai */

			if (ns_nfas == ON) {

				if ((Na_maint_type != NFAS_TSP_BKP) &&
					(Na_maint_type != NO_NFAS)) {

					if (ns_access_na (int_id) == NOK) {

							/*
							 * Should never happen because the int_id
							 * has beeen checked in net_ie.at4.
							 */

						return (OK);
					}

				} else {

					if (ns_access_na (Nfas_cfg_nai_active_d_chan) != OK) {
						return (NOK);
					}

				}

			}

		}

			/*
			 * -3- Get the B channel.
			 *	We use the CHANGE_STATUS which is MANDATORY at both
			 *	interfaces (CC and DL).
			 *	If ALL B channels are impacted, set b_chan_state to UNDEF.
			 *	If only one is chosen, set b_chan to the  B channel Id
			 *	and b_chan_state to the current state.
			 */

		if (I_(change_status, preference) == PREF_B_CHANNEL) {

				/* A specific B channel is used */

			b_chan 		 = *I_chan_id_a_chan_number;
			b_chan 		 = Reset_ext_bit (b_chan);
			b_chan_state = Dl_b_chan_mode_int (int_id, b_chan);

		} else {

				/* Any B channel is concerned */

			b_chan_state = MAINT_STATE_B_UNDEF;
		}

	}

	switch (b_chan_state) {

		case MAINT_STATE_B_IS :
			p_data = p_ssdu;
			e10_custom_is (int_id, b_chan, Mns_service_action_type);
			break;

		case MAINT_STATE_B_IS_ACK :
			e10_custom_is_ack (int_id, b_chan);
			break;

		case MAINT_STATE_B_OOS_NE :
			e10_custom_osne (int_id, b_chan);
			break;

		case MAINT_STATE_B_OOS_FE_ACK :
			e10_custom_osfe_ack (int_id, b_chan);
			break;

		case MAINT_STATE_B_OOS_FE :
			p_data = p_ssdu;
			e10_custom_osfe (int_id, b_chan, Mns_service_action_type);
			break;

		case MAINT_STATE_B_MAINT_FE_ACK :
		case MAINT_STATE_B_IS_MAINT_NE_ACK :
		case MAINT_STATE_B_OOS_MAINT_NE_ACK :
			e10_maint_ack_1 (int_id, b_chan);
			break;

		case MAINT_STATE_B_MAINT_FE :
		case MAINT_STATE_B_IS_MAINT_NE :
		case MAINT_STATE_B_OOS_MAINT_NE :
			e10_maint_ack_2 (int_id, b_chan);
			break;

		case MAINT_STATE_B_UNDEF :
			e10_custom_undef (int_id);
			break;
	}

	return (OK);

}

#endif /* } */

#if NS_D_BACKUP == ON /* { */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

uchar e10_national_bkp_proc (code, ent_from)
	code_t	code;
	nai_t	ent_from;
{

	ushort state;

	ent_from += ent_from;

		/*
		 * This routine manages the D channel states.
		 * The B channels states are not managable when
		 * using the NATIONAL protocol.
		 */

	if (ns_nfas == OFF) return (OK);

	if (Nfas_nai_d_chan_backup_act == OFF) {

		return (OK);
	}

		/*
		 * -1- Get the interface Id
		 */

	if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

				/*
				 * Check that the information is fpr the
				 * B channels.
				 */
		if (I_chan_id_d_chan != D_CHAN) {

				/* Wrong protocol discriminator. Ignore */

			return (OK);

		}

	}

		/*
		 * When enterring this routine, p_nsna points to the CC Nai
		 * context.
		 */

	state = ((ushort)Nfas_active_d_chan_status << 8) + Nfas_backup_d_chan_status;

	switch (state) {

		case MAINT_STATE_IS_STBY :
		case MAINT_STATE_STBY_IS :
			e10_national_bkp_is_stby (code);
			break;

		case MAINT_STATE_MB_WAIT :
			e10_national_bkp_mb_wait (code);
			break;

		case MAINT_STATE_WAIT_MB :
			e10_national_bkp_wait_mb (code);
			break;

		case MAINT_STATE_IS_OOS :
		case MAINT_STATE_OOS_IS :
			e10_national_bkp_is_oos (code);
			break;

		case MAINT_STATE_OOS_WAIT :
			e10_national_bkp_oos_wait (code);
			break;

		case MAINT_STATE_OOS_OOS :
			e10_national_bkp_oos_oos (code);
			break;
	}

	return (OK);
}

#endif /* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	e10_filter () -

Usage           	uchar e10_filter (code, nai);
					Note : nai is not used.


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

uchar e10_filter (code, nai)
	code_t		code;
	nai_t		nai;
{
	nai		+= nai;

	switch (R_msg_from) {

		case ENT_CC :
			return (CONTINUE);

		case ENT_DL :
		case ENT_DL_D :

				/*
				 * The filtering will be performed below.
				 */

			break;

		default :
			return (CONTINUE);
	}

		/*
		 * Do the layer 2 filtering only if :
		 *	- nfas is ON
		 * 	- backup is ON
		 */

	if (ns_nfas == OFF) {
		return (CONTINUE);
	}

#	if NS_D_BACKUP == ON

		if ((ns_nfas == ON) && (Nfas_nai_d_chan_backup_act == OFF)) {

			return (CONTINUE);
		}

		return (e10_national_bkp_filter (code));


#	else

		return (CONTINUE);

#	endif

}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#if NS_D_BACKUP == ON /* { */

uchar e10_national_bkp_filter (code)
	code_t		code;
{
	ushort state;
	uchar filter, protocol, msg, crl;

	uchar FAR *p_data;
	p_data = R_a_data;

	filter = CONTINUE;

		/* Do some filtering according the current state */

	state = ((ushort)Nfas_active_d_chan_status << 8) + Nfas_backup_d_chan_status;

	switch (state) {

		case MAINT_STATE_IS_STBY :

			switch (code) {

				case DL_U_DA_IN :
				case DL_DA_IN :

					protocol= p_data [0];
					crl		= p_data [1];
					msg		= p_data [2 + crl];

					if ((protocol == PROTOCOL_DISCR_MAINT_ATT_CUST) ||
						(protocol == PROTOCOL_DISCR_MAINT_NATIONAL)) {

						filter = STOP;

						if ((msg == MAINT_SERVICE) ||
							(msg == MAINT_SERVICE_ACK)) {

							filter = CONTINUE;
						}

					} else {

						if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

							filter = STOP;
						}
					}

					break;

				case DL_EST_IN :
					filter = STOP;
					break;
			}

			break;


		case MAINT_STATE_OOS_WAIT :

			switch (code) {

				case DL_EST_IN :

					if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

						filter = STOP;
					}

					break;

				case DL_REL_IN :

					if (Nfas_nai_line == Nfas_nai_active_d_chan) {

						filter = STOP;
					}

					break;
			}

			break;

		case MAINT_STATE_OOS_OOS :
			break;

		case MAINT_STATE_OOS_IS :
		case MAINT_STATE_IS_OOS :

			switch (code) {

				case DL_EST_IN :

					if (Nfas_nai_line == Nfas_nai_active_d_chan) {

						filter = STOP;
					}

					break;

				case DL_U_DA_IN :
				case DL_DA_IN :

					if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

						filter = STOP;
					}

					break;

				case DL_EST_CO :

					if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

						p_nsdl = Nfas_dl_p_backup_d_chan;

							/* Stop T3_DL_EST */

						Stop_dl_timer (T3_DL_EST);

							/* Update the D channel states */

						Nfas_active_d_chan_status	= MAINT_STATE_IS;
						Nfas_backup_d_chan_status	= MAINT_STATE_STBY;
						Lc_state = LC_ESTABLISHED;
						filter	 = STOP;

					}

					break;

				case DL_REL_IN :

					if (Nfas_nai_line == Nfas_nai_backup_d_chan) {
						p_nsdl	= Nfas_dl_p_backup_d_chan;
						Lc_state= LC_RELEASED;
						filter	= STOP;
					}

					break;
			}

			break;

		case MAINT_STATE_MB_WAIT :

			switch (code) {

				case DL_DA_IN :

					protocol= p_data [0];
					crl		= p_data [1];
					msg		= p_data [2 + crl];

					if ((protocol == PROTOCOL_DISCR_MAINT_ATT_CUST) ||
						(protocol == PROTOCOL_DISCR_MAINT_NATIONAL)) {

						if ((msg == MAINT_SERVICE) ||
							(msg == MAINT_SERVICE_ACK)) {

							filter = CONTINUE;
						}

					} else {

						filter = STOP;
					}

					break;

				case DL_U_DA_IN :
				case DL_EST_IN :

						/* Ignore */

					filter = STOP;
					break;

				case DL_REL_IN :

					if (Nfas_nai_line == Nfas_nai_active_d_chan) {

							/* Ignore */

						filter = STOP;
					}

					break;
			}

			break;

		case MAINT_STATE_WAIT_MB :

			switch (code) {

				case DL_DA_IN :

					protocol= p_data [0];
					crl		= p_data [1];
					msg		= p_data [2 + crl];

					if ((protocol == PROTOCOL_DISCR_MAINT_ATT_CUST) ||
						(protocol == PROTOCOL_DISCR_MAINT_NATIONAL)) {

						if ((msg == MAINT_SERVICE) ||
							(msg == MAINT_SERVICE_ACK)) {

							filter = CONTINUE;
						}

					} else {

						filter = STOP;
					}

					break;

				case DL_U_DA_IN :
				case DL_EST_IN :

						/* Ignore */

					filter = STOP;
					break;

				case DL_REL_IN :

					if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

							/* Ignore */

						filter = STOP;
					}

					break;
			}

	}

	return (filter);
}

#endif /* NS_D_BACKUP } */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#endif /* } NS_MAINTENANCE_CAPABILITY */

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

void e10_set_b_chan_state (chan_id, restart_class, b_chan_state, int_id)
	uchar chan_id;
	uchar restart_class;
	uchar b_chan_state;
	uchar int_id;

{
	uchar i, j;


		/* Reset the flag of the channel Id */

	Reset_ext_bit (chan_id);

	if (restart_class == RI_INDICATED_CHANNEL) {

		Dl_b_chan_mode_int (int_id, chan_id)= b_chan_state;

	} else {

		if (ns_nfas == ON) {

				/*
				 * We don't need to care about the ALL versus SINGLE
				 * interface because we sent 1 NS_RESTART_IN per
				 * Nai controlled by the active D channel.
				 */

				/* All B channels are concerned */

			for (i = 0; i < NS_MX_B_CHAN; i++) {
				Dl_b_chan_mode_int (int_id, i)= b_chan_state;
			}

		} else {

				/*
				 * Transparent mode.
				 *
				 * We need to care about the ALL versus SINGLE
				 * interface because we sent only 1 NS_RESTART_IN for
				 * the entire set of Nais controlled by the active D channel.
				 */

			if (restart_class == RI_ALL_INTERFACES) {

				for (i = 0; i < NS_MX_NFAS_NAI; i++) {

						/* All B channels are concerned */

					for (j = 0; j < NS_MX_B_CHAN; j++) {

						Dl_b_chan_mode_int (i, j) = b_chan_state;
					}
				}

			} else {

					/* All B channels are concerned */

				for (i = 0; i < NS_MX_B_CHAN; i++) {
					Dl_b_chan_mode_int (int_id, i)= b_chan_state;
				}

			}
		}
	}

}

#endif /* } */

/*------------------------------------------------------------------------*/

#if (NS_TYPE_PRI == ON) && (NS_MAINTENANCE_CAPABILITY == ON) && (NS_RESTART_PROCEDURE == ON) /* { */

uchar e10_maint_national (code)
	code_t code;
{

	uchar i, b_state, int_id;

		/*
		 * This routine manages the Maintenance aspect of
		 * the NATIONAL protocol.
		 */

	int_id = Nai;

	if (I_restart_ind_class != RI_ALL_INTERFACES) {

        if (I_(chan_id, int_id) == INT_ID_IMPLICIT) {

                /* Check that the int_id_val is the Active D channel */

            int_id = Nai;

        } else {

            int_id = I_(chan_id, int_id_val);

        }

    }

	if (I_restart_ind_class == RI_INDICATED_CHANNEL) {

		i = *I_chan_id_a_chan_number;
		i = Reset_ext_bit (i);
        b_state = Dl_b_chan_mode_int (int_id, i);

	} else {

			/* This should never happen from the network !!! */

		b_state = BYTE_VAL_NIL;

	}

	switch (code) {

		case DA_RESTART :

			Dl_rest_class = I_restart_ind_class;

			switch (b_state) {

				case MAINT_STATE_B_OOS_FE_REST :

			   /*
				* If OOS FE-RESTART state, send a RESTART_ACK,
				* and resend a RESTART, start 316.
				*/

			   /*------------------------------------------------*/

					   /* -1- Retransmit a RESTART_ACK */

				   *(R_a_data + I_call_ref_lgth + 2) = RESTART_ACK;

					   /* Reset call ref flag */

				   Set_ext_bit (*(R_a_data + 2));

					   /* Send the message */

				   ns_retransmit (DL_DA_RQ, ENT_DL_D);

			   /*------------------------------------------------*/

					   /* -2- Send a RESTART message */

				   Set_call_ref_not_nil ();

					   /* store Restart Indicator with value saved in DL context */

				   set_ie_i (CODESET_0, RESTART_IND);
				   I_restart_ind_class = RI_INDICATED_CHANNEL;

					   /* store Channel-ID */

				   direction = TO_D_CHANNEL;

				   ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
				   set_ie_i (CODESET_0, CHAN_ID);

				   I_chan_id_d_chan = NOT_D_CHAN;		/* B-Channel indicated */
				   I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */

				   I_chan_id_int_type = INT_TYPE_PRI;
				   I_chan_id_chan_sel = AS_INDICATED;	/* Channel Number as indicated in following octets */
				   I_chan_id_nb_map = CHAN_NUMBER;		/* Format of following octets = simply the B-Channel number */
				   I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

				   I_chan_id_a_chan_number = p_ind_buffer++;			/* save data into indirect buffer */
				   *I_chan_id_a_chan_number = i;			/* channel number */
				   Set_ext_bit (*I_chan_id_a_chan_number);	/* Set the extension bit to 1 in the chan_nb field before sending SPDU */

				   Send_to_d_channel (RESTART);			/* with CALL_REF_GLOBAL */
				   Restart_dl_timer (E10_T316);
				   Dl_rest_state = STATE_REST_1;

			   /*------------------------------------------------*/

				   /* -3- Update B channel state */

				   e10_set_b_chan_state (i, I_restart_ind_class, MAINT_STATE_B_OOS_FE_ACK, int_id);

				   break;

			   case MAINT_STATE_B_OOS_FE_ACK :

						/* Retransmit a RESTART_ACK */

					*(R_a_data + I_call_ref_lgth + 2) = RESTART_ACK;

						/* Reset call ref flag */

					Set_ext_bit (*(R_a_data + 2));

						/* Send the message */

					ns_retransmit (DL_DA_RQ, ENT_DL_D);
					break;

			   default :

					e10_restart_n_pri ();
					break;

		   }	/* swith B channel state */

		   break;

		case DA_RESTART_ACK :

			if (I_restart_ind_class != RI_INDICATED_CHANNEL) {

				Dl_b_chan_restart_nb = 0;
				e10_set_b_chan_state (0, I_restart_ind_class, MAINT_STATE_B_IS, int_id);

			} else {

				switch (Dl_b_chan_mode_int (int_id, i)) {

					case MAINT_STATE_B_OOS_FE_ACK :

							 /* Update B channel(s) state */

						if (I_chan_id_a_chan_number != P_NIL) {
							e10_set_b_chan_state (*I_chan_id_a_chan_number, I_restart_ind_class, MAINT_STATE_B_IS, int_id);
						} else {
							e10_set_b_chan_state (0, I_restart_ind_class, MAINT_STATE_B_IS, int_id);
						}
						break;

					default :
						return (NOK);
				}

			}

			Stop_dl_timer (E10_T316);

			if (Nfas_nai_mode != NFAS_TSP) {

				if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {

					if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {

						if (ns_access_na (I_(chan_id, int_id_val)) == NOK) {
							return (OK);
						}
					}
				}
			}

			ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
			Dl_restart_reset ();

			break;

		case NS_RESTART_RS :

			switch (Dl_rest_state) {

				case STATE_REST_1 :
					Stop_dl_timer (E10_T317);

					if (Dl_rest_ack == ON) {

						ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
						Dl_restart_reset ();

							/* Update B channel(s) state */

						if (I_chan_id_a_chan_number != P_NIL) {
							e10_set_b_chan_state (*I_chan_id_a_chan_number, I_restart_ind_class, MAINT_STATE_B_IS, int_id);
						} else {
							e10_set_b_chan_state (0, I_restart_ind_class, MAINT_STATE_B_IS, int_id);
						}

					} else {

						Dl_rest_resp = ON;
					}

					break;

				case STATE_REST_2 :

						/* Update B channel(s) state */

					if (I_chan_id_a_chan_number != P_NIL) {
						e10_set_b_chan_state (*I_chan_id_a_chan_number, I_restart_ind_class, MAINT_STATE_B_IS, int_id);
					} else {
						e10_set_b_chan_state (0, I_restart_ind_class, MAINT_STATE_B_IS, int_id);
					}

					if (Dl_b_chan_restart_nb > 0) {
						Dl_b_chan_restart_nb--;

					}

						/*
						 * Send a RESTART_ACK if
						 *	-1- Class is not ALL_INTERFACES
						 *	-2- or Class is ALL INTERFACES and no more
						 * 		RESTART_RS are expected.
						 */

					if (Dl_rest_class != RI_ALL_INTERFACES) {
						Set_call_ref_not_nil ();
						Send_to_d_channel (RESTART_ACK);
					}

					if ((Dl_rest_class == RI_ALL_INTERFACES) &&
						(Dl_b_chan_restart_nb == 0)) {
						Set_call_ref_not_nil ();
						Send_to_d_channel (RESTART_ACK);
					}

					if (Dl_b_chan_restart_nb == 0) {
						Stop_dl_timer (E10_T317);
						Dl_restart_reset ();
					}
					break;

				default :

					ns_unexpected_ev ();
			}

			return (OK);


	}	/* switch code */


	return (OK);
}

/*--------------------------------------------------------------------------*/
void e10_restart_n_pri ()
{
	struct nsna FAR *p_nsna_sav;

	uchar i, int_id;

	if (I_chan_id_a_chan_number != P_NIL) {
		Reset_ext_bit (*I_chan_id_a_chan_number);
	}

	if ((ns_nfas == OFF) ||
		((ns_nfas == ON) && (Nfas_nai_mode == NFAS_TSP))) {

		Start_dl_timer (E10_T317);
		Dl_rest_state = STATE_REST_2;
		Set_call_ref_nil ();

			/* If TSP, the Na must be the Cfg_na */

		if ((ns_nfas == ON) && (Nfas_nai_mode == NFAS_TSP)) {

			if (ns_access_na (Nfas_cfg_nai_active_d_chan) != OK) {
				return;
			}

		}

		Send_to_call_control (NS_RESTART_IN);
		Dl_b_chan_restart_nb++;

		if (I_restart_ind_class == RI_ALL_INTERFACES) {
			csc_clear_all_call ();
			Na_internal_restart = ON;
		}

		return;
	}

		/*
		 * Only one channel is indicated : the lowest NxDS0 Channel.
		 * The upper entity must clear ALL the calls.
		 */


	Start_dl_timer (E10_T317);
	Dl_rest_state = STATE_REST_2;

	switch (I_restart_ind_class) {

		case RI_ALL_INTERFACES :

			p_nsna_sav = p_nsna;

					/*
					 * Access to all the Nais managed by the current D channel
					 * bearer,
					 */

			for (i = 0; i < Nfas_nai_assoc_list_nb_nai + 1; i++) {

				if (ns_access_na (Nfas_nai_assoc_list(i)) == NOK) {
					return;
				}

				Set_call_ref_nil ();
				Send_to_call_control (NS_RESTART_IN);
				e10_set_b_chan_state (0, I_restart_ind_class, MAINT_STATE_B_OOS_FE_REST, Nai);
				Dl_b_chan_restart_nb++;
			}

				/* Save how many RETSART_IN we just have sent */

			Dl_nai_restart_nb = Nfas_nai_assoc_list_nb_nai + 1;

				/* The lowest NxDS0 channel state is MAINT_STATE_B_OOS_FE_ACK */

			p_nsna = p_nsna_sav;

			Dl_b_chan_mode_int (Nai, 1)= MAINT_STATE_B_OOS_FE_ACK;

			if (I_restart_ind_class == RI_ALL_INTERFACES) {
				csc_clear_all_call ();
				Na_internal_restart = ON;
			}

			break;

		case RI_SINGLE_INTERFACE :

			if (I_(chan_id, int_id) == INT_ID_IMPLICIT) {

					/* Check that the int_id_val is the Active D channel */

				int_id = Nai;

			} else {

				int_id = I_(chan_id, int_id_val);

				if (ns_access_na (int_id) == NOK) {
					return;
				}
			}

			Dl_b_chan_restart_nb++;
			Dl_nai_restart_nb = 1;
			Set_call_ref_nil ();
			Send_to_call_control (NS_RESTART_IN);

			break;

		case RI_INDICATED_CHANNEL :

			if (I_(chan_id, int_id) == INT_ID_IMPLICIT) {

					/* Check that the int_id_val is the Active D channel */

				int_id = Nai;

			} else {

				int_id = I_(chan_id, int_id_val);

				if (ns_access_na (int_id) == NOK) {
					return;
				}
			}

			Set_call_ref_nil ();
			Send_to_call_control (NS_RESTART_IN);
			Dl_nai_restart_nb = 1;
			Dl_b_chan_restart_nb++;
			break;
	}
}

void e10_restart_lowest ()
{
	struct nsna FAR *p_nsna_sav;

	uchar i;

		/*
		 * Only one channel is indicated : the lowest NxDS0 Channel.
		 * The upper entity must clear ALL the calls.
		 */

	Dl_b_chan_restart_nb = 1;
	I_restart_ind_class  = RI_ALL_INTERFACES;

	Start_dl_timer (E10_T317);
	Dl_rest_state = STATE_REST_2;

	p_nsna_sav = p_nsna;

			/*
			 * Access to all the Nais managed by the current D channel
			 * bearer,
			 */

	for (i = 0; i < Nfas_nai_assoc_list_nb_nai + 1; i++) {

		if (ns_access_na (Nfas_nai_assoc_list(i)) == NOK) {
			return;
		}

		Set_call_ref_nil ();
		Send_to_call_control (NS_RESTART_IN);
		e10_set_b_chan_state (*I_chan_id_a_chan_number, I_restart_ind_class, MAINT_STATE_B_OOS_FE_REST, Nai);
	}

		/* Save how many RETSART_IN we just have sent */

	Dl_nai_restart_nb = Nfas_nai_assoc_list_nb_nai + 1;

		/* The lowest NxDS0 channel state is MAINT_STATE_B_OOS_FE_ACK */

	p_nsna = p_nsna_sav;

	Dl_b_chan_mode_int (Nai, *I_chan_id_a_chan_number)= MAINT_STATE_B_OOS_FE_ACK;
}

#endif /* } */

#if NS_MAINTENANCE_CAPABILITY == ON /* { */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	e10_audit () -

Usage           	uchar e10_audit (int_id, b_chan);

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

Return code :		OK : a NS_SERVICE_CO has been sent
					NOK: No NS_SERVICE_CO has been sent
*--------------------------------------------------------------------------*/
uchar e10_audit (int_id, b_chan)
	nai_t int_id;
	uchar b_chan;
{
	uchar current_state, ret_code;

	ret_code = NOK;

	current_state = Dl_b_chan_mode_int (int_id, b_chan);

		/*
		 * Check if the channel is in use.
		 * A channel is in use if :
		 *	- a call is upon the channel
		 *	- Maintenance action is in progress
		 *	- A B channel is waiting for a SERV_ACK.
		 */

	if ((Is_call_upon_B_chan (int_id, b_chan))	 		||
		(Is_maint_in_progress (int_id, b_chan))			||
		(Is_B_chan_state_wait_for_ack (current_state))) {

			/*
			 * The B channel is in use --> Nothing to do.
			 */


		return (NOK);
	}

	switch (current_state) {

		case MAINT_STATE_B_IS :
		case MAINT_STATE_B_IS_MAINT_NE :

				/* Update the status field to be sent back */

			I_(change_status, status) = CHANNEL_IN_SERVICE;

				/* Send back a MAINT_SERVICE */

			Send_to_d_channel_proto	(MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);

			if (State_dl_timer (E10_T317) == OFF) {

					/* Start DL timer T317 */

				Start_dl_timer (E10_T317);
			}

				/* Update current B channel state */

			Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_IS_ACK;
			ret_code = CONTINUE;
			break;

		case MAINT_STATE_B_OOS_MAINT_NE :
		case MAINT_STATE_B_OOS_NE :

				/* Update the status field to be sent back */

			I_(change_status, status) = CHANNEL_OUT_OF_SERVICE;

				/* Send back a MAINT_SERVICE, DON'T start T317 */

			Send_to_d_channel_proto	(MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);

				/* Update current B channel state */

			Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_NE;

			Set_call_ref_not_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ret_code = OK;
			break;

		case MAINT_STATE_B_OOS_FE :
		case MAINT_STATE_B_MAINT_FE :

				/* Update the status field to be sent back */

			I_(change_status, status) = CHANNEL_OUT_OF_SERVICE;

				/* Send back a MAINT_SERVICE */

			Send_to_d_channel_proto	(MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);

			if (State_dl_timer (E10_T317) == OFF) {

					/* Start DL timer T317 */

				Start_dl_timer (E10_T317);
			}

				/* Update current B channel state */

			Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_ACK;
			break;

	}

	return (ret_code);
}

#endif /* } */

#if NS_TYPE_BRI == ON

uchar e10_build_endpoint_rq ()
{
	if (is_ie_i (CODESET_6, E10_ENDPOINT_ID) == ABSENT) return  (OK);

    if (Ns_access_dl_ces (I_(endpoint_id, ces)) == OK) {

    	if (is_ie_i (CODESET_0, INFORMATION_RQ) == PRESENT) {

        		/* Build the Request of the USID/TID */

			I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
			I_man_trans_ref			= SYN;
			I_man_op_class			= UNCONFIRMED_OPERATION;
			I_man_op_type			= OP_TYPE_EV_REPORT;
			I_man_code				= MAN_CODE_INIT_RQ;
			I_man_param_counter 	= 0;
			I_man_param_lgth		= 0;

        } else {

            if (is_ie_i (CODESET_0, CAUSE) == ABSENT) {

                    /* Build the USID/TID */

                I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
                I_man_trans_ref			= SYN;
                I_man_op_class			= CONFIRMED_OPERATION;
                I_man_op_type			= OP_TYPE_SET;
                I_man_code				= MAN_CODE_ADD_INFO;
                I_man_param_counter 	= 0;
                I_man_param_id			= PARAM_ENDPOINT_ID;
                I_man_param_lgth		= 2;
                I_man_param_usid(0)		= I_(endpoint_id, usid);
                I_man_param_tid(0)		= I_(endpoint_id, tid);
                I_man_param_counter 	= 1;

            } else {

            		/* Build a REJECT */

                I_man_protocol_discr	= PROTOCOL_DISCR_ATT_ISDN_MAN;
                I_man_trans_ref			= SYN;
                I_man_op_class			= REJECT;
                I_man_op_type			= OP_TYPE_DEFAULT;
                I_man_code				= MAN_CODE_ADD_INFO;
                I_man_param_counter 	= 0;
                I_man_param_lgth		= 0;
            }
        }
    }

    discard_ie_i (CODESET_0, ENDPOINT_ID);
    Set_call_ref_not_nil ();
    set_ie_i (CODESET_6, MANAGMNT);
    Send_to_d_channel (MAN_INFO);

    return (OK);
}

#endif
/*EOF*/
