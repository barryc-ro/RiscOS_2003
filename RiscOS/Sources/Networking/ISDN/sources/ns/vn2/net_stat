
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_state.vn2
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s) : state driven automata for France Telecom VN2.
 *
 *        vn2_u0 to vn2_u254 - user side - implements the processing of an event
 *                     according to the state of the call (u0 to u254).
 *
 *        n0 to n254 - network side - implements the processing of an event
 *                     according to the state of the call (n0 to n254).
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

						/*----------------*/
						/*                */
						/*   USER SIDE    */
						/*       U        */
						/*----------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             vn2_u0 to vn2_u254 - user side - implements the processing of an
							  event according to the call state.

Usage            void vn2_uxx (void);

Related
functions usage void Stop_timer (uchar x_timer);

				void Start_timer (uchar x_timer);
						- x_timer : timer index.

				void Send_to_d_channel (uchar spdu_id);
						- spdu_id : spdu message type (ID).

				void Send_to_call_control (uchar ssdu_id);
						- ssdu_id : ssdu primitive code (ID).

				void Set_state (uchar call_state);
						- call_state : state of the call.

				void call_clear (void);

				void ns_unexpected_ev (void);

Return value    void

Common constants and declarations : ns.h

Common objects : call and na object, internal data structure.

*-------------------------------------------------------------------------*/

		/* STATE_NULL_0 */

		/* Null state */

			/*
			   No call exists : used when a call context is
			   allocated to a call or a registration.
			*/

void vn2_u0 ()
{

	switch (event_id) {

		case DA_SETUP:

				/* No available channel ? */

			if ((is_ie_i (CODESET_0, CHAN_ID) == PRESENT) && (i_chan_id[0].d_chan == NO_CHAN)) {

					/*
						Is there others current calls on the NA ?
						if not and no UUI send a RELEASE COMPLETE
						to the network.
					 */

				Ns_access_dl_ces (DL_CES_SIG);

				if ((Dl_call_count == 0) && (is_ie_i (CODESET_0, UUI) != PRESENT)) {
					Reset_internal_ie ();
					set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, (char FAR *) &Call_state);
					Send_to_d_channel (REL_COMP);
					call_clear ();
					break;
				}

			}

				/* UUI protocol */

			if (is_ie_i (CODESET_0, UUI) == ABSENT) {
				Call_uui_rq = OFF;

			} else {

				Call_uui_rq = ON;
				Call_ui_count = 0;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_6, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

			Send_to_call_control (NS_CONN_IN);
			Start_timer_ns (VN2_T300);
			Set_state (STATE_CALL_PRESENT_6);
			break;

		case NS_CONN_RQ :

				/* UUI protocol */

			if (is_ie_i (CODESET_0, UUI) == ABSENT) {
				Call_uui_rq = OFF;

			} else {

				Call_uui_rq = ON;
				Call_ui_count = 0;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_6, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

			Send_to_d_channel (SETUP);
			Start_timer_ns (VN2_T303);
			Set_state (STATE_CALL_INIT_1);
			break;

		case NS_RESUME_RQ :
			Send_to_d_channel (RES);
			Start_timer_ns (VN2_T319);
			Set_state (STATE_RESUME_REQUEST_17);
			break;

		case NS_SPF_REGISTRATION_RQ :
			Send_to_d_channel (REG);
			Start_timer_ns (VN2_T399);
			Set_state (STATE_REGISTRATION_REQUEST_254);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_INIT_1 */

		/* Call initialization state */

			/*
			   This state exists for an outgoing call, as a result of  user
			   action requesting call establishment from the network.
			*/

void vn2_u1 ()
{
	switch (event_id) {

		case DA_CALL_PROC :
			Stop_timer_ns (VN2_T303);
			Send_to_call_control (NS_CALL_PROC_IN);
			Start_timer_ns (VN2_T310);
			Set_state (STATE_OUTGOING_CALL_PROC_3);
			break;

		case DA_SETUP_ACK :
			Stop_timer_ns (VN2_T303);
			Send_to_call_control (NS_SETUP_ACK_IN);
			Start_timer_ns (VN2_T304);
			Set_state (STATE_OVERLAP_SENDING_2);
			break;

		case TI_303 :
			set_i_cause (C_C_TIMER, C_V_T303, (char FAR *) &Call_state);
			Send_to_call_control (NS_CLEAR_CO);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_SENDING_2 */

		/* Overlap sending state */

			/*
			   This state exists for an outgoing call when the user has
			   received acknowledgement of the call establishment request
			   which permits the user to send additional call information
			   to the network in overlap mode.
			*/


void vn2_u2 ()
{
	switch (event_id) {

		case DA_CALL_PROC :
			Stop_timer_ns (VN2_T304);
			Send_to_call_control (NS_CALL_PROC_IN);
			Start_timer_ns (VN2_T310);
			Set_state (STATE_OUTGOING_CALL_PROC_3);
			break;

		case TI_304 :
			set_i_cause (C_C_PROTOCOL_ERROR,
						 C_V_RECOVERY_ON_TIMER_EXPIRY_102,
						 P_NIL);
			Save_cause ();				/* to send the RELEASE if T305 expires */
			Send_to_d_channel (DISC);
			Start_timer_ns (VN2_T305);
			Set_state (STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_PROC */

		/* Outgoing call proceeding state */

			/*
			   This state exists for an outgoing call when the user
			   has received acknowledgement that the network has received
			   all call information necessary to effect call establishment.
			*/

void vn2_u3 ()
{
	switch (event_id) {

		case DA_ALERT :

				/* UUI protocol */

			if (is_ie_i (CODESET_0, UUI) == ABSENT) {
				Call_uui_rq = OFF;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_6, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

			Stop_timer_ns (VN2_T310);
			Send_to_call_control (NS_ALERT_IN);
			Set_state (STATE_CALL_DELIVERED_4);
			break;

		case DA_ROUTED_CALL :
			Stop_timer_ns (VN2_T310);
			Send_to_call_control (NS_ROUTED_CALL_IN);

			if ((is_ie_i (CODESET_0, CAUSE) == PRESENT) && (i_cause[0].cause_class == INTERWORKING)) {

				switch (i_cause[0].cause_val) {

					case C_V_END_TO_END_XMIT_IMPOSSIBLE_114 :
						Send_to_call_control (NS_CONN_CO);
						break;

					case C_V_CONVERSATION_MODE_ON_126 :
						Send_to_call_control (NS_CONN_CO);
						break;

					default :
						break;

				}

			}
			break;

		case DA_CONN :

				/* UUI protocol */

			if (is_ie_i (CODESET_0, UUI) == ABSENT) {
				Call_uui_rq = OFF;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_6, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

			Stop_timer_ns (VN2_T310);
			Send_to_call_control (NS_CONN_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		case TI_310 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, P_NIL);
			Save_cause ();							/* to send the RELEASE if T305 expire */
			Send_to_d_channel (DISC);
			Start_timer_ns (VN2_T305);
			Set_state (STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_DELIVERED_4 */

		/* Call delivered state */

			/*
			   This state exists for an outgoing call when the calling user
			   has received an indication that the remote user alerting has
			   been initiated.
			*/

void vn2_u4 ()
{
	switch (event_id) {

		case NS_USER_INFO_RQ :

			if (Call_ui_u_count < (uint)MX_UI_COUNT) {
				Inc_ui_u_count ();
				Send_to_d_channel (USER_INFO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case DA_CONN :
			Send_to_call_control (NS_CONN_CO);
			Reset_internal_ie ();
			Set_state (STATE_ACTIVE_10);
			break;

		case DA_USER_INFO :

			if (Call_ui_u_count < (uint)MX_UI_COUNT) {
				Inc_ui_u_count ();
				Send_to_call_control (NS_USER_INFO_IN);

			} else {

				ns_unexpected_ev ();
			}

			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_PRESENT_6 */

		/* Call present state */

			/*
			   This state exists for an incoming call when the user
			   has received a call establishment request but not yet
			   responded.
			*/

void vn2_u6()
{
	switch (event_id) {

		case NS_ALERT_RQ :

				/* First response to SETUP */

				/* UUI protocol */

			if (is_ie_i (CODESET_0, UUI) == PRESENT) {

				if (Call_uui_rq == OFF) {
					send_err_to_user (ERR_U_UUI_PROTOCOL, UUI, 0, Call_upper_ent);
					break;

				}

			} else {

				Call_uui_rq = OFF;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_6, USER_FAC) == PRESENT) {

				if (Call_user_fac_rq == OFF) {
					send_err_to_user (ERR_U_USER_FAC_PROTOCOL, USER_FAC, 0, Call_upper_ent);
					break;

				}

			} else {
				Call_user_fac_rq = OFF;
			}

			Stop_timer_ns (VN2_T300);
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_RECEIVED_7);
			break;

		case NS_CONN_RS :

				/* First response to SETUP */

				/* UUI protocol */

			if (is_ie_i (CODESET_0, UUI) == PRESENT) {

				if (Call_uui_rq == OFF) {
					send_err_to_user (ERR_U_UUI_PROTOCOL, UUI, 0, Call_upper_ent);
					break;

				}

			} else {

				Call_uui_rq = OFF;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_6, USER_FAC) == PRESENT) {

				if (Call_fac_rq == OFF) {
					send_err_to_user (ERR_U_USER_FAC_PROTOCOL, USER_FAC, 0, Call_upper_ent);
					break;

				}

			} else {

				Call_fac_rq = OFF;
			}

			Stop_timer_ns (VN2_T300);
			Send_to_d_channel (CONN);
			Start_timer_ns (VN2_T313);
			Set_state (STATE_CONNECT_REQUEST_8);
			break;

		case TI_300 :

#			if NS_TYPE_PRI == ON

				if (Na_type == PRI) {
					set_i_cause (C_C_INVALID_MESSAGE, C_V_INCOMPATIBLE_DESTINATION_88, P_NIL);
					Send_to_d_channel (REL_COMP);
					Reset_internal_ie ();
				}

#			endif

			set_i_cause (C_C_TIMER, C_V_T300, (char FAR *) &Call_state);
			Send_to_call_control (NS_CLEAR_CO);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

		}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_RECEIVED_7 */

		/* Call received state */

			/*
			   This state exists for an incomming call when the user has
			   indicated alerting but not yet answered.
			*/

void vn2_u7 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			Send_to_d_channel (CONN);
			Start_timer_ns (VN2_T313);
			Set_state (STATE_CONNECT_REQUEST_8);
			break;

		case NS_USER_INFO_RQ :

			if (Call_ui_u_count < (uint)MX_UI_COUNT) {
				Inc_ui_u_count ();
				Send_to_d_channel (USER_INFO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case DA_USER_INFO :

			if (Call_ui_u_count < (uint)MX_UI_COUNT) {
				Inc_ui_u_count ();
				Send_to_call_control (NS_USER_INFO_IN);

			} else {

				ns_unexpected_ev ();
			}

			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CONNECT_REQUEST_8 */

		/* Connect request state */

			/*
			   This state exists for an incoming call when the user
			   has answered the call and is waiting to be awarded.
			*/

void vn2_u8 ()
{
	switch (event_id) {

		case DA_CONN_ACK :
			Stop_timer_ns (VN2_T313);
			Send_to_call_control (NS_CONN_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		case TI_313 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, P_NIL);
			Save_cause ();				/* to send the RELEASE if T305 expire */

			Start_timer_ns (VN2_T305);
			Set_state (STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_INCOMING_CALL_PROCEEDING */

		/* Incoming call proceeding state */

			/*
			   This state exists for an incoming call when the user has
			   sent acknowlegdement that the user has received all call
			   information necessary to effect call establishment.
			*/

void vn2_u9 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			Send_to_d_channel (CONN);
			Set_state (STATE_CONNECT_REQUEST_8);
			break;

		case NS_ALERT_RQ :
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_RECEIVED_7);
			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_ACTIVE_10 */

		/* Active state */

			/*
			   This state exists if an incoming call when the user has
			   received an ackknowledgement from the network that the user
			   has been awarded the call. This state exists for an outgoing
			   call when the user has received an indication that the remote
			   user has answered the call.
			*/

void vn2_u10 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;


		case NS_SUSPEND_RQ :
			Send_to_d_channel (SUSP);
			Start_timer_ns (VN2_T318);
			Set_state (STATE_SUSPEND_REQUEST_15);
			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		case TI_309 :

			if (Na_T309_option == ON) {
				set_i_cause (C_C_TIMER, C_V_T309, (char FAR *) &Call_state);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();

			} else {

				ns_unexpected_ev ();
			}

			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_REQUEST_11 */

		/* Disconnect request state */

			/*
			   This state exists when the user has requested the network
			   to clear the end-to-end connection (if any) and is waiting
			   for a response.
			*/

void vn2_u11 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		 case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}
			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		 case TI_305 :
			Restore_cause ();	/* send saved cause of the previous DISC */
			set_ie_i (CODESET_0, CAUSE);
			Send_to_d_channel_and_save_spdu (REL);
			Start_timer_ns (VN2_T308);
			N308 = 0;
			Set_state (STATE_RELEASE_REQUEST_19);
			break;

		 default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_INDICATION_12 */

		/* Disconnect indication state */

			/*
			   This state exists when the user has received an invitation
			   to disconnect because the network has disconnected the
			   end-to-end connection (if any).
			*/

void vn2_u12 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Stop_timer_ns (VN2_T300);
			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		case NS_CLEAR_RS :
			Send_to_d_channel_and_save_spdu (REL);
			N308 = 0;
			Start_timer_ns (VN2_T308);
			Set_state (STATE_RELEASE_REQUEST_19);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE SUSPEND_REQUEST */

		/* Suspend request state */

			/*
			   This state exists  after the user has requested the network
			   to suspend the call and is waiting for a response.
			*/

void vn2_u15 ()
{
	switch (event_id) {

		case DA_SUSP_ACK :
			Send_to_call_control (NS_SUSPEND_CO);
			call_clear ();
			break;

		case DA_SUSP_REJ :
			Stop_timer_ns (VN2_T318);
			Send_to_call_control (NS_SUSPEND_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		case TI_318 :
			set_i_cause (C_C_TIMER, C_V_T318, P_NIL);
			Send_to_call_control (NS_SUSPEND_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RESUME_REQUEST_17 */

		/* Resume request state */

			/*
			   This state exists  after the user has requested the network
			   to resume a previously suspend call and is waiting for a
			   response.
			*/

void vn2_u17 ()
{
	switch (event_id) {

		case DA_RES_ACK :
			Stop_timer_ns (VN2_T319);
			Send_to_call_control (NS_RESUME_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		case DA_RES_REJ :
			Send_to_call_control (NS_RESUME_CO);
			call_clear ();
			break;


		case TI_319 :
			set_i_cause (C_C_TIMER, C_V_T319, (char FAR *) &Call_state);
			Send_to_call_control (NS_RESUME_CO);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RELEASE_REQUEST_19 */

		/* Release request state */

			/*
			   This state exists when the user has requested the network
			   to release and is waiting for a response.
			*/

void vn2_u19 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		case TI_308 :

			if (++N308 < MX_N308) {
				Send_saved_spdu_to_d_channel (REL);
				Restart_timer_ns (VN2_T308);

			} else {

				set_i_cause (C_C_TIMER, C_V_T308, (char FAR *) &Call_state);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}

			break;

		case NS_CLEAR_RS :
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_REGISTRATION_REQUEST_254 */

		/* A registration resquest has been sent. */

void vn2_u254 ()
{
	switch (event_id) {

		case DA_REG_ACK :
		case DA_REG_REJ :
			Send_to_call_control (NS_SPF_REGISTRATION_CO);
			call_clear ();
			break;

		case TI_399 :
			set_i_cause (C_C_TIMER, C_V_T399, (char FAR *) &Call_state);
			Send_to_call_control (NS_SPF_REGISTRATION_CO);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

						/*-------------------*/
						/*                   */
						/*   NETWORK SIDE    */
						/*        N          */
						/*-------------------*/

#if EQUIPMENT == NT2

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             vn2_n0 to vn2_n254 - network side - implements the processing of an
							  event according to the call state.

Usage            void vn2_nxx (void);

Related
functions usage void Stop_timer_ns (uchar x_timer);

				void Start_timer_ns (uchar x_timer);
						- x_timer : timer index.

				void Send_to_d_channel (uchar spdu_id);
						- spdu_id : spdu message type (ID).

				void Send_to_call_control (uchar ssdu_id);
						- ssdu_id : ssdu primitive code (ID).

				void Set_state (uchar call_state);
						- call_state : state of the call.

				void call_clear (void);

				void ns_unexpected_ev (void);

Return value    void

Common constants and declarations : ns.h

Common objects : call and na object, internal data structure.

*-------------------------------------------------------------------------*/

		/* STATE_NULL_0 */

		/* Null state */

			/*
			   No call exists : used when a call context is
			   allocated to a call or a registration.
			*/

void vn2_n0 ()
{

	switch (event_id) {

		case DA_SETUP :
			Call_ref = i_call_ref;
			Call_ces = Dl_ces;
			Send_to_call_control (NS_CONN_IN);
			Start_timer_ns (VN2_T300);
			Set_state (STATE_CALL_INIT_1);
			break;

		case DA_RES :
			Send_to_call_control (NS_RESUME_IN);
			Start_timer_ns (VN2_T300);
			Set_state (STATE_RESUME_REQUEST_17);
			break;

		case DA_REG :
			Send_to_call_control (NS_SPF_REGISTRATION_IN);
			Start_timer_ns (VN2_T300);
			Set_state (STATE_REGISTRATION_REQUEST_254);
			break;

		case NS_CONN_RQ :

#			if EQUIPMENT == TE
				Send_to_d_channel (SETUP);
				Start_timer_ns (VN2_T303);
				Set_state (STATE_CALL_PRESENT_6);

#			else
				if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {

#					if NS_TYPE_BRI == ON

						Send_to_d_channel_and_save_spdu (SETUP);
						Start_timer_ns (VN2_T303);
						N303 = 0;
						reset_multipoint_context ();
						Set_state (STATE_CALL_PRESENT_6);

#					endif

				} else {

					Send_to_d_channel (SETUP);
					Start_timer_ns (VN2_T303);
					Set_state (STATE_CALL_PRESENT_6);
				}

#			endif

			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_INIT_1 */

		/* Call initialization state */

			/*
			   This state exists for an outgoing call, as a result of  user
			   action requesting call establishment from the network.
			*/

void vn2_n1 ()
{
	switch (event_id) {

		case NS_SETUP_ACK_RQ :
			Stop_timer_ns (VN2_T300);
			Send_to_d_channel (SETUP_ACK);
			Start_timer_ns (VN2_T302);
			Set_state (STATE_OVERLAP_SENDING_2);
			break;

		case NS_CALL_PROC_RQ :
			Stop_timer_ns (VN2_T300);
			Send_to_d_channel (CALL_PROC);
			Set_state (STATE_OUTGOING_CALL_PROC_3);
			break;

		case TI_300 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, (char FAR *) &Call_state);
			Send_to_d_channel_and_save_spdu (REL);
			N308 = 0;
			Start_timer_ns (VN2_T308);
			Set_state (STATE_RELEASE_REQUEST_19);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_SENDING_2 */

		/* Overlap sending state */

			/*
			   This state exists for an outgoing call when the user has
			   received acknowledgement of the call establishment request
			   which permits the user to send additional call information
			   to the network in overlap mode.
			*/


void vn2_n2 ()
{
	switch (event_id) {

		case NS_CALL_PROC_RQ :
			Stop_timer_ns (VN2_T302);
			Send_to_d_channel (CALL_PROC);
			Start_timer_ns (VN2_T310);
			Set_state (STATE_OUTGOING_CALL_PROC_3);
			break;

		case TI_302 :
			set_i_cause (C_C_NORMAL_EVENT, C_V_INVALID_NUMBER_FORMAT_28, P_NIL);
			Save_cause ();							/* to send the RELEASE if T305 expire */
			Send_to_d_channel (DISC);
			Send_to_call_control (NS_CLEAR_IN);
			Start_timer_ns (VN2_T305);
			Set_state (STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OUTGOING_CALL_PROC_3 */

		/* Outgoing call proceeding state */

			/*
			   This state exists for an outgoing call when the user
			   has received acknowledgement that the network has received
			   all call information necessary to effect call establishment.
			*/

void vn2_n3 ()
{
	switch (event_id) {

		case NS_ALERT_RQ :
			Stop_timer_ns (VN2_T310);
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_DELIVERED_4);
			break;

		case NS_ROUTED_CALL_RQ :
			Stop_timer_ns (VN2_T310);
			Send_to_d_channel (ROUTED_CALL);
			break;

		case NS_CONN_RS :
			Stop_timer_ns (VN2_T310);
			Send_to_d_channel (CONN);
			Set_state (STATE_ACTIVE_10);
			break;

		case TI_310 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, P_NIL);
			Send_to_d_channel_and_save_spdu (REL);
			N308 = 0;
			Start_timer_ns (VN2_T308);
			Set_state (STATE_RELEASE_REQUEST_19);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_DELIVERED_4 */

		/* Call delivered state */

			/*
			   This state exists for an outgoing call when the calling user
			   has received an indication that the remote user alerting has
			   been initiated.
			*/

void vn2_n4 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			Send_to_d_channel (CONN);
			Set_state (STATE_ACTIVE_10);
			break;

		case DA_USER_INFO :
			Send_to_call_control (NS_USER_INFO_IN);
			break;

		case NS_USER_INFO_RQ :
			Send_to_d_channel (USER_INFO);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_PRESENT_6 */

		/* Call present state */

			/*
			   This state exists for an incoming call when the user
			   has received a call establishment request but not yet
			   responded.
			*/

void vn2_n6 ()
{
		/* Point to multipoint configuration */

	if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {

#		if NS_TYPE_BRI == ON

			Call_ces = DL_CES_NIL;

			switch (event_id) {

					/* RELEASE */

				case DA_REL :

					if (is_ie_i (CODESET_0, UUI) == PRESENT) {

							/* RELEASE and UUI */

						if ((Call_sub_state == N6_REL_UUI) || (Call_sub_state == N6_REL_SPF_FAC)) {
							Reset_internal_ie ();
							set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
							Send_to_d_channel (REL_COMP);

						} else {

							save_ie_uui ();
							Call_sub_state = N6_REL_UUI;
						}

					} else if (is_ie_i (CODESET_0, SPF_FAC) == PRESENT) {

							/*  RELEASE and SPECIFIC FACILITY (Transfer) */

						if (Call_sub_state == N6_REL_SPF_FAC) {
							Reset_internal_ie ();
							set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_TRANSFER_REJECTED_60, P_NIL);
							Send_to_d_channel (REL_COMP);

						} else {

							save_ie_spf_fac ();

							if (Call_sub_state == N6_REL_UUI) {
								Set_dl_ctx_uui ();
								Reset_internal_ie ();
								set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
								Send_to_d_channel (REL_COMP);
							}

							Call_sub_state = N6_REL_SPF_FAC;

						}

					} else {

						/* RELEASE */

						if (Call_sub_state == N6) {
							save_ie_cause ();
							Call_sub_state = N6_REL_COMP;
						}

						Send_to_d_channel (REL_COMP);
					}

					break;

					/* CALL PROCESSING */

				case DA_CALL_PROC :
					Stop_timer_ns (VN2_T303);
					Release_saved_spdu ();
					Send_to_call_control (NS_CALL_PROC_IN);
					Start_timer_ns (VN2_T310);
					Set_alert ();
					Set_state (STATE_INCOMING_CALL_PROC_9);
					break;

					/* ALERT */

				case DA_ALERT :
					Stop_timer_ns (VN2_T303);
					Release_saved_spdu ();
					Send_to_call_control (NS_ALERT_IN);
					Set_alert ();

					if (Call_sub_state == N6_REL_UUI) {
						Set_dl_ctx_uui ();
						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
						Send_to_d_channel (REL_COMP);

					} else if (Call_sub_state == N6_REL_SPF_FAC) {

						Set_dl_ctx_spf_fac ();
						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
						Send_to_d_channel (REL_COMP);
					}

					Set_state (STATE_CALL_RECEIVED_7);
					break;

					/* CONNECTION */

				case DA_CONN :
					Stop_timer_ns (VN2_T303);
					Release_saved_spdu ();
					Send_to_call_control (NS_CONN_CO);

					if (Call_sub_state == N6_REL_UUI) {
						Set_dl_ctx_uui ();
						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
						Send_to_d_channel (REL_COMP);

					} else if (Call_sub_state == N6_REL_SPF_FAC) {

						Set_dl_ctx_spf_fac ();
						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
						Send_to_d_channel (REL_COMP);
					}

					Start_timer_ns (VN2_T300);
					Set_state (STATE_CONNECT_REQUEST_8);
					break;

				case NS_CLEAR_RQ :

					if (Call_sub_state == N6_REL_UUI) {
						Set_dl_ctx_uui ();
						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
						Send_to_d_channel (REL_COMP);

					} else if (Call_sub_state == N6_REL_SPF_FAC) {

						Set_dl_ctx_spf_fac ();
						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
						Send_to_d_channel (REL_COMP);
					}

					call_clear ();
					break;

					/* T303 EXPIRY */

				case TI_303 :

					switch (Call_sub_state) {

						case N6:

							if (++N303 != MX_N303) {
								Send_saved_spdu_to_d_channel (SETUP);
								Start_timer_ns (VN2_T303);
							} else {

								if (Call_ces_status != DL_CES_NIL) {
									set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, P_NIL);
									Set_dl_ctx_status ();
								}

								set_i_cause (C_C_NORMAL_EVENT, C_V_NO_USER_RESPONDING_18, (char FAR *) &Call_state);
								Send_to_call_control (NS_CLEAR_CO);
								call_clear ();

							}
							break;

						case N6_REL_COMP :
							load_ie_cause ();
							Send_to_call_control (NS_CLEAR_CO);
							call_clear ();
							break;

						case N6_REL_UUI :
							load_ie_uui ();
							Send_to_call_control (NS_CLEAR_CO);
							Set_dl_ctx_uui ();
							Reset_internal_ie ();
							Send_to_d_channel (REL_COMP);
							call_clear ();
							break;

						case N6_REL_SPF_FAC :
							set_i_cause (C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
							load_ie_spf_fac ();
							Send_to_call_control (NS_CLEAR_CO);
							Set_dl_ctx_spf_fac ();
							Reset_internal_ie ();
							Send_to_d_channel (REL_COMP);
							call_clear ();
							break;

					}

					break;

				default :
					ns_unexpected_ev ();
					break;

			}

#		endif

	} else {

		/* Point to point configuration */

		switch (event_id) {

			case DA_CALL_PROC :
				Stop_timer_ns (VN2_T303);
				Release_saved_spdu ();
				Send_to_call_control (NS_CALL_PROC_IN);
				Start_timer_ns (VN2_T310);
				Set_state (STATE_INCOMING_CALL_PROC_9);
				break;

			case DA_ALERT :
				Stop_timer_ns (VN2_T303);
				Release_saved_spdu ();
				Send_to_call_control (NS_ALERT_IN);
				Set_state (STATE_CALL_RECEIVED_7);
				break;

			case DA_CONN :
				Stop_timer_ns (VN2_T303);
				Release_saved_spdu ();
				Send_to_call_control (NS_CONN_CO);
				Start_timer_ns (VN2_T300);
				Set_state (STATE_CONNECT_REQUEST_8);
				break;

			case TI_303 :
				set_i_cause (C_C_NORMAL_EVENT, C_V_NO_USER_RESPONDING_18, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
				break;

			default :
				ns_unexpected_ev ();
				break;

		}

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_RECEIVED_7 */

		/* Call received state */

			/*
			   This state exists for an incomming call when the user has
			   indicated alerting but not yet answered.
			*/

void vn2_n7 ()
{

		/* Point to Multipoint configuration */

	if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {

#		if NS_TYPE_BRI == ON

			switch (event_id) {

					/* RELEASE */

				case DA_REL :

					if (is_ie_i (CODESET_0, UUI) == PRESENT) {

							/* RELEASE and UUI */

						if (test_alerting () == OK) {
							Send_to_call_control (NS_CLEAR_CO);
							Reset_internal_ie ();
							Send_to_d_channel (REL_COMP);
							call_clear ();

						} else {

							Reset_internal_ie ();
							set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
							Send_to_d_channel (REL_COMP);
						}

					} else if (is_ie_i (CODESET_0, SPF_FAC) == PRESENT) {

							/*  RELEASE and SPECIFIC FACILITY (Transfer) */

						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_TRANSFER_REJECTED_60, P_NIL);
						Send_to_d_channel (REL_COMP);

					} else  {

							/* RELEASE */

						Send_to_d_channel (REL_COMP);
					}

					break;

					/* ALERT */

				case DA_ALERT :
					Set_alert ();
					break;

					/* CONNECT */

				case DA_CONN :
					Send_to_call_control (NS_CONN_CO);
					Call_ces = Dl_ces;
					release_alerting (OFF);
					Start_timer_ns (VN2_T300);
					Set_state (STATE_CONNECT_REQUEST_8);
					break;

					/* NS CLEAR REQUEST */

				case NS_CLEAR_RQ :
	/*JLD JS*/      Call_ces = DL_CES_NIL;
					release_alerting (ON);
					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

				case NS_USER_INFO_RQ :
					Send_to_d_channel (USER_INFO);
					break;

				case DA_USER_INFO :
					Send_to_call_control (NS_USER_INFO_IN);
					break;

				default :
					ns_unexpected_ev ();
					break;

			}

#		endif

	} else {

			/* Point to point configuration */

		switch (event_id) {

			case DA_REL :
				break;

			case NS_CLEAR_RQ :
				Send_to_d_channel (REL);
				call_clear ();
				break;

				/* CONNECT */

			case DA_CONN :
				Send_to_call_control (NS_CONN_CO);
				Start_timer_ns (VN2_T300);
				Set_state (STATE_CONNECT_REQUEST_8);
				break;

			case NS_USER_INFO_RQ :
				Send_to_d_channel (USER_INFO);
				break;

			case DA_USER_INFO :
				Send_to_call_control (NS_USER_INFO_IN);
				break;

			default :
				ns_unexpected_ev ();
				break;

		}

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CONNECT_REQUEST_8 */

		/* Connect request state */

			/*
			   This state exists for an incoming call when the user
			   has answered the call and is waiting to be awarded.
			*/

void vn2_n8 ()
{

		/* Point to Multipoint configuration */

	if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {

#		if NS_TYPE_BRI == ON

			switch (event_id) {

				case DA_REL :

					if (is_ie_i (CODESET_0, UUI) == PRESENT) {

							/* RELEASE and UUI */

						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);

					} else if (is_ie_i (CODESET_0, SPF_FAC) == PRESENT) {

							/*  RELEASE and SPECIFIC FACILITY (Transfer) */

						Reset_internal_ie ();
						set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_TRANSFER_REJECTED_60, P_NIL);
					}

						/* RELEASE */

					Send_to_d_channel (REL_COMP);
					break;

				case DA_ALERT :
				case DA_CONN :
					Reset_internal_ie	();
					set_i_cause	(C_C_NORMAL_EVENT, C_V_CALL_REJECT_21, P_NIL);
					Send_to_d_channel (REL);
					break;

				case NS_CLEAR_RQ :
					Send_to_d_channel (REL);
					call_clear ();
					break;

				case NS_CONN_RS :
					Stop_timer_ns (VN2_T300);
					Send_to_d_channel (CONN_ACK);
					Set_state (STATE_ACTIVE_10);
					break;

				case TI_300 :
					set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, (char FAR *) &Call_state);
					Save_cause ();							/* to send the RELEASE if T305 expire */
					Send_to_d_channel (DISC);
					Start_timer_ns (VN2_T305);
					Set_state (STATE_DISCONNECT_REQUEST_11);
					break;

				default :
					ns_unexpected_ev ();
					break;

			}

#		endif

	} else {

		/* Point to point configuration */

		switch (event_id) {

			case NS_CONN_RS :
				Stop_timer_ns (VN2_T300);
				Send_to_d_channel (CONN_ACK);
				Set_state (STATE_ACTIVE_10);
				break;

			case TI_300 :
				set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, (char FAR *) &Call_state);
				Save_cause ();							/* to send the RELEASE if T305 expire */
				Send_to_d_channel (DISC);
				Start_timer_ns (VN2_T305);
				Set_state (STATE_DISCONNECT_REQUEST_11);
				break;

			default :
				ns_unexpected_ev ();
				break;

		}

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_INCOMING_CALL_PROCEEDING */

		/* Incoming call proceeding state */

			/*
			   This state exists for an incoming call when the user has
			   sent acknowlegdement that the user has received all call
			   information necessary to effect call establishment.
			*/

void vn2_n9 ()
{
	switch (event_id) {

		case DA_ALERT :
			Stop_timer_ns (VN2_T310);
			Send_to_call_control (NS_ALERT_IN);
			Set_state (STATE_CALL_RECEIVED_7);
			break;

		case DA_CONN :
			Stop_timer_ns (VN2_T310);
			Send_to_call_control (NS_CONN_CO);
			Start_timer_ns (VN2_T300);
			Set_state (STATE_CONNECT_REQUEST_8);
			break;

		case TI_300 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, (char FAR *) &Call_state);
			Save_cause ();							/* to send the RELEASE if T305 expire */
			Send_to_d_channel (DISC);
			Start_timer_ns (VN2_T305);
			Set_state (STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_ACTIVE_10 */

		/* Active state */

			/*
			   This state exists if an incoming call when the user has
			   received an ackknowledgement from the network that the user
			   has been awarded the call. This state exists for an outgoing
			   call when the user has received an indication that the remote
			   user has answered the call.
			*/

void vn2_n10 ()
{

		/* Point to Multipoint configuration */

	if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {

#		if NS_TYPE_BRI == ON

			switch (event_id) {

				case DA_REL :

						/* Point to Multipoint configuration */

					if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {

						if (is_ie_i (CODESET_0, UUI) == PRESENT) {

								/* RELEASE and UUI */

							Reset_internal_ie ();
							set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_UUI_NOT_TRANSMITTED_49, P_NIL);
						} else if (is_ie_i (CODESET_0, SPF_FAC) == PRESENT) {

								/*  RELEASE and SPECIFIC FACILITY (Transfer) */

							Reset_internal_ie ();
							set_i_cause	(C_C_SERVICE_NOT_AVAILABLE, C_V_TRANSFER_REJECTED_60, P_NIL);
						}

							/* RELEASE */

						Send_to_d_channel (REL_COMP);

					} else {

						/* Point to point */

						Send_to_call_control (NS_CLEAR_IN);
						Send_to_d_channel_and_save_spdu (REL);
						N308 = 0;
						Start_timer_ns (VN2_T308);
						Set_state (STATE_RELEASE_REQUEST_19);
					}

					break;

				case DA_ALERT :
				case DA_CONN :

						/* Point to Multipoint configuration */

					if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {
						Reset_internal_ie ();
						set_i_cause (C_C_NORMAL_EVENT, C_V_CALL_REJECT_21, P_NIL);
						Send_to_d_channel (REL);

					} else {

							/* Point to point */

						ns_unexpected_ev ();
					}

					break;

				case NS_SPF_FACILITY_RS :

					if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
						Send_to_d_channel (FT_FAC_ACK);

					} else {

						Send_to_d_channel (FT_FAC_REJ);
					}

					break;

				case DA_SUSP :
					Send_to_call_control (NS_SUSPEND_IN);
					Start_timer_ns (VN2_T300);
					Set_state (STATE_SUSPEND_REQUEST_15);
					break;

				case DA_FAC :
					Send_to_call_control (NS_SPF_FACILITY_IN);
					break;


				case TI_309 :

					if (Na_T309_option == ON) {

						if (Lc_state != LC_ESTABLISHED) {
							Send_to_dl (DL_REL_RQ, Call_ces);
							call_clear ();
						}


					} else {

						ns_unexpected_ev ();
					}

					break;

				default :
					ns_unexpected_ev ();
					break;

			}

#		endif

	}


}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_REQUEST_11 */

		/* Disconnect request state */

			/*
			   This state exists when the user has requested the network
			   to clear the end-to-end connection (if any) and is waiting
			   for a response.
			*/

void vn2_n11 ()
{
	switch (event_id) {

		case NS_CLEAR_RS :
			break;

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case TI_305 :
			Restore_cause ();	/* send saved cause of the previous DISC */
			set_ie_i (CODESET_0, CAUSE);
			Send_to_d_channel_and_save_spdu (REL);
			N308 = 0;
			Start_timer_ns (VN2_T308);
			Set_state (STATE_RELEASE_REQUEST_19);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_INDICATION_12 */

		/* Disconnect indication state */

			/*
			   This state exists when the user has received an invitation
			   to disconnect because the network has disconnected the
			   end-to-end connection (if any).
			*/

void vn2_n12 ()
{
	switch (event_id) {

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case NS_CLEAR_RS :
			Stop_timer_ns (VN2_T300);

		case TI_300 :
			Send_to_d_channel_and_save_spdu (REL);
			N308 = 0;
			Start_timer_ns (VN2_T308);
			Set_state (STATE_RELEASE_REQUEST_19);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE SUSPEND_REQUEST */

		/* Suspend request state */

			/*
			   This state exists  after the user has requested the network
			   to suspend the call and is waiting for a response.
			*/

void vn2_n15 ()
{
	switch (event_id) {

		case NS_SUSPEND_RS :

			if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {
				Stop_timer_ns (VN2_T300);
				Send_to_d_channel (SUSP_REJ);
				Set_state (STATE_ACTIVE_10);

			} else {

				Send_to_d_channel (SUSP_ACK);
				call_clear ();
			}

			break;


		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case TI_300 :
			set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, (char FAR *) &Call_state);
			Send_to_d_channel (SUSP_REJ);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE LOCAL_SUSPEND */

		/* Local suspend state */

			/*
			   This state exists  after the the network has acknowledged
			   positively a request from the user to suspend the call.
			*/

void vn2_n16 ()
{
	ns_unexpected_ev ();
}

/*-------------------------------------------------------------------------*/

		/* STATE_RESUME_REQUEST_17 */

		/* Resume request state */

			/*
			   This state exists  after the user has requested the network
			   to resume a previously suspend call and is waiting for a
			   response.
			*/

void vn2_n17 ()
{
	switch (event_id) {

		case NS_RESUME_RS :

			if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {
				Send_to_d_channel (RES_REJ);
				call_clear ();

			} else {

				Stop_timer_ns (VN2_T300);
				Send_to_d_channel (RES_ACK);
				Set_state (STATE_ACTIVE_10);
			}

			break;

		case TI_300 :
			set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, (char FAR *) &Call_state);
			Send_to_d_channel (SUSP_REJ);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RELEASE_REQUEST_19 */

		/* Release request state */

			/*
			   This state exists when the user has requested the network
			   to release and is waiting for a response.
			*/

void vn2_n19 ()
{
	switch (event_id) {

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case TI_308 :

			if (++N308 < MX_N308) {
				Send_saved_spdu_to_d_channel (REL);
				Restart_timer_ns (VN2_T308);

			} else {

				set_i_cause (C_C_TIMER, C_V_T308, (char FAR *) &Call_state);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_REGISTRATION_REQUEST_254 */

		/* A registration resquest has been received. */

void vn2_n254 ()
{
	switch (event_id) {

		case NS_SPF_REGISTRATION_RS :

			if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {
				Send_to_d_channel (FT_REG_REJ);

			} else {

				Send_to_d_channel (REG_ACK);
			}

			call_clear ();
			break;

		case TI_300 :
			set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, (char FAR *) &Call_state);
			Send_to_d_channel (FT_REG_REJ);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

#endif

/*EOF*/
