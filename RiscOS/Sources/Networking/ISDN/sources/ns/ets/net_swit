
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_switch.ets
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *        ets_csc_dl_reinit - implement an unexpected data link reinit.
 *
 *        ets_circuit_switched_call - implements the processing of the call
 *		                          control procedures.
 *
 *        ets_circuit_switched_call_n - implements the processing of the call
 *		                            control procedures.
 *
 *        ets_hold_retrieve_process - implements the control of
 *									Hold and Retrieve functions
 *
 *        ets_call_state_change - implements the actions to be done when
 *				a change of call state occurs. 
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

		/* Functions prototypes */

	void	ets_u0						(Void_parm);
	void	ets_u1						(Void_parm);
	void	ets_u2						(Void_parm);
	void	ets_u3						(Void_parm);
	void	ets_u4						(Void_parm);
	void	ets_u6						(Void_parm);
	void	ets_u7						(Void_parm);
	void	ets_u8						(Void_parm);
	void	ets_u9						(Void_parm);
	void	ets_u10						(Void_parm);
	void	ets_u11						(Void_parm);
	void	ets_u12						(Void_parm);
	void	ets_u15						(Void_parm);
	void	ets_u17						(Void_parm);
	void	ets_u19						(Void_parm);
	void	ets_u25						(Void_parm);
	void	ets_csc_dl_reinit			(Void_parm);
	uchar	ets_circuit_switched_call	(Void_parm);
	uchar	ets_error_handler			(Void_parm);
	void	ets_internal_process		(Void_parm);
	uchar	ets_nb_other_active_ces		(Void_parm);
	uchar	ets_nb_active_ces			(Void_parm);

#if NS_HOLD_RETRIEVE == ON
	uchar	ets_hold_call_state_allowed	(Void_parm);
	uchar	ets_hold_retrieve_process	(Void_parm);
#endif

#if NEW_FCT_STYLE == ON
	void	ets_send_to_ces		 		(uchar ev_id, uchar ie_flag, uchar my_ces);
	void	ets_send_to_other_ces 		(uchar ev_id, uchar ie_flag);
#else
	void	ets_send_to_ces		 		();
	void	ets_send_to_other_ces 		();
#endif

						/*----------------*/
						/*                */
						/*   USER SIDE    */
						/*                */
						/*----------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	ets_csc_dl_reinit () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN)
									   for ETSI implementation.

Usage           	void ets_csc_dl_reinit ();

Related
functions usage		void send_state (uchar class, uchar value, uchar diagnostic);

Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA

*--------------------------------------------------------------------------*/

void ets_csc_dl_reinit ()
{

	ns_access_first_call ();

	while (Call_current_exist) {

		if (Call_state != STATE_NIL) {
			I_call_ref = Call_ref;
			Set_call_ref_not_nil ();

			if ((Call_state == STATE_OVERLAP_SENDING_2) ||
				(Call_state == STATE_OVERLAP_RECEIVING_25)) {
				ns_stop_all_timers ();
				set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, P_NIL);
				Send_to_d_channel (DISC);
				Set_state (STATE_DISCONNECT_REQUEST_11);
				Start_timer_ns (ETS_T305);
			}

#			if NS_SUPP_SERVICES == ON

			else if (Call_state == STATE_CALL_INDEPENDENT_31) {

				set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, P_NIL);
				Send_to_d_channel (REL_COMP);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}

#			endif
		}

		ns_access_next_call ();
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ets_circuit_switched_call - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage          	uchar ets_circuit_switched_call ();

Related
functions usage void u0 .... u254 ()

Description     ets_circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value    uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

/*								CLEARING PROCEDURES

	   TE                         NT/NETWORK                        TE
 _________________             _________________            _________________
 |               |             |               |            |               |
 |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
 |==========>....|------------>|.......|.....  |            |               |
 | start T305    |			   |  .    |    .  |            |               |
 |               |             |  .    |    .  |            |               |
 |               |             |  .    |    .  |            |               |
 |               |             |  .    |    .  |            |               |
 |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
 |<===========...|<------------|...    |    ...|----------->|...===========>|
 |  stop T305  . |             |start T308     |            |    NS_CLEAR_RS|
 |             . | DA_REL_COMP |     start T305|     REL    |  .<===========|
 |             ..|------------>|       |    ...|<-----------|...  start T308|
 |               |             |       |    .  |            |               |
 |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
 |               |             |       |    ...|----------->|...===========>|
 |               |             |       |       |            |     stop T308 |
 |---------------|             |---------------|            |---------------|

*/

uchar ets_circuit_switched_call ()
{

#	if NS_RESTART_PROCEDURE == ON
		uchar	FAR *p_data;
#	endif

					/* 1 - EVENT DRIVEN PROCESSING  */

	if (i_entity_origination == ENT_MNS) {

#		if NS_RESTART_PROCEDURE == ON

			switch (event_id) {

				case MNS_RESTART_RQ :

					if (Dl_rest_state == STATE_REST_0) {

							/* set current data pointer using p_ssdu pointer */

						p_data = p_ssdu;

						if (I_restart_ind_class == RI_INDICATED_CHANNEL) {

							I_chan_id_d_chan = NOT_D_CHAN;		/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */

							if (Na_type == BRI) {

								/* Basic Rate */

								I_chan_id_int_type = INT_TYPE_BRI;
								I_chan_id_chan_sel = Mns_restart_b_chan_nb;	/* B1_CHAN or B2_CHAN */

							} else {

								/* Primary Rate */

								I_chan_id_int_type = INT_TYPE_PRI;
								I_chan_id_chan_sel = AS_INDICATED;	/* Channel Number as indicated in following octets */
								I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

								I_chan_id_a_chan_number = p_ind_buffer++;			/* save data into indirect buffer */
								*I_chan_id_a_chan_number = Mns_restart_b_chan_nb;	/* channel number */
							}
						}

						if (I_restart_ind_class == RI_ALL_INTERFACES) {
							csc_clear_all_call ();
							Na_internal_restart = ON;
						}

						Send_to_call_control (NS_RESTART_IN);	/* on CONN_ID_MANAGEMENT */
						Start_dl_timer (ETS_T317);
						Set_call_ref_not_nil ();

						if (I_chan_id_a_chan_number != A_NIL) {

							/* Set the extension bit to 1 in the chan_nb field before sending SPDU */

							Set_ext_bit (*I_chan_id_a_chan_number);
						}

						Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
						N316 = 0;
						Start_dl_timer (ETS_T316);
						Dl_rest_state = STATE_REST_1;

					} else {

						ns_unexpected_ev ();
					}

					break;

#				if ASSERT == ON

				default :
					Trap (TRAP_MNS_CODE, "ets_circuit_switched_call");

#				endif

			}

#		endif

		return (OK);
	}

	switch (event_id) {

						/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

						/* SETUP : allocate a call context */

		case DA_SETUP :

#		if NS_SUPP_SERVICES == ON
		case DA_REG :
#		endif

			if (allocate_call (INCOMING_CALL, 0) != OK) {
				Reset_internal_ie ();
				set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34, P_NIL);
				Send_to_d_channel (REL_COMP);
				return (OK);
			}
			break;

						/* DISCONNECT */

		case DA_DISC :
			Call_fac_rq	= OFF;

			switch (Call_state) {

				case STATE_RELEASE_REQUEST_19 :
					break;

				case STATE_CALL_INIT_1 :
				case STATE_DISCONNECT_INDICATION_12 :

#				if NS_SUPP_SERVICES == ON
					case STATE_CALL_INDEPENDENT_31 :
#				endif
					ns_unexpected_ev ();
					break;

				case STATE_DISCONNECT_REQUEST_11 :
					ns_stop_all_timers ();							/* Timers 305 and maybe 322 */
					Send_to_call_control (NS_CLEAR_IN);				/* send NS clear to Layer 4 */
					Reset_internal_ie ();

					if (disc_cause_error () == NOK) {
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
					}

					go_to_state_19 (ETS_T308);
					break;

				default :
					ns_stop_all_timers ();
					Send_to_call_control (NS_CLEAR_IN);				/* send NS clear to Layer 4 */
					Set_state (STATE_DISCONNECT_INDICATION_12);		/* enter disconnect indication state */
					break;

			}

			return (OK);

						/* RELEASE */

		case DA_REL :
			Call_fac_rq = OFF;
			Send_to_call_control (NS_CLEAR_CO);

			switch (Call_state) {

				case STATE_RELEASE_REQUEST_19 :
					break;

				default :

					Reset_internal_ie ();
					set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
					Send_to_d_channel (REL_COMP);					/* send the Release Complete Message to network */
					break;

			}

			call_clear ();
			return (OK);

						/* RELEASE COMPLETE */

		case DA_REL_COMP :
			Call_fac_rq	= OFF;
			Send_to_call_control (NS_CLEAR_CO);						/* send NS clear confirm to Layer 4 */
			call_clear ();											/* free call context */
			return (OK);

						/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			switch (Call_state) {

				case STATE_CALL_PRESENT_6 :

					if (! ((is_ie_i (CODESET_0, CAUSE) == PRESENT) &&
						   (I_cause_class == C_C_NORMAL_EVENT)     &&
						   (I_cause_val   == C_V_NO_ANSWER_19))
					   ) {

						Send_to_d_channel (REL_COMP);
					}

				case STATE_NULL_0 :
				case STATE_WAIT_DL :
					Reset_internal_ie ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

				case STATE_RESUME_REQUEST_17 :
				case STATE_SUSPEND_REQUEST_15 :
					ns_unexpected_ev ();
					break;

				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					break;

				case STATE_DISCONNECT_INDICATION_12 :
					disc_cause_error ();
					Stop_timer_ns  (ETS_T300);
					go_to_state_19 (ETS_T308);
					break;

#				if NS_SUPP_SERVICES == ON
					case STATE_CALL_INDEPENDENT_31 :
						go_to_state_19 (ETS_T308);
						break;
#				endif

				case STATE_CALL_INIT_1 :
					Release_saved_spdu ();							/* saved setup no more useful */

					/* process the default */

				default :
					ns_stop_all_timers ();
					Save_cause ();									/* to send the RELEASE if T305 expire */
					if ((is_ie_i (CODESET_0, CAUSE) == PRESENT) &&
						(I_cause_class == C_C_NORMAL_EVENT_0) &&
						(I_cause_val   == C_V_CHAN_UNACCEPTABLE_6)) {

						/* 5.3.2 d)
							Unsuccessful termination of the B-channel selection procedure is accomplished
							by sending RELEASE message containing cause #6 "channel unacceptable" */

						go_to_state_19 (ETS_T308);

					} else {

						Send_to_d_channel (DISC);						/* send a DISCONNECT message */
						Start_timer_ns (ETS_T305);							/* start T305 */
						Set_state (STATE_DISCONNECT_REQUEST_11);		/* enter the Disconnect Request state */
					}

					break;

			}

			return (OK);

						/* INFO */

		case DA_INFO :

			switch (Call_state) {

				case STATE_CALL_INIT_1 :
				case STATE_CALL_PRESENT_6 :
				case STATE_RESUME_REQUEST_17 :
#				if NS_SUPP_SERVICES == ON
					case STATE_CALL_INDEPENDENT_31 :
#				endif

					ns_unexpected_ev ();
					break;

				case STATE_OVERLAP_RECEIVING_25 :
					Send_to_call_control (NS_INFO_IN);

					if (is_ie_i (CODESET_SO, SENDING_COMPLETE) == ABSENT) {
						Restart_timer_ns (ETS_T302);
					}
					break;

					/* In state 19, the INFO message may be ignored */

				case STATE_RELEASE_REQUEST_19 :
					break;

				default :

					if (is_ie_i (CODESET_0, CALLED_NB) == PRESENT) {
						ns_unexpected_ev ();

					} else {

						Send_to_call_control (NS_INFO_IN);
					}

			}

			return (OK);

						/* NS INFORMATION REQUEST */

		case  NS_INFO_RQ :

			switch (Call_state) {

				case STATE_CALL_PRESENT_6 :
				case STATE_SUSPEND_REQUEST_15 :
				case STATE_RESUME_REQUEST_17 :
				case STATE_RELEASE_REQUEST_19 :
				case STATE_CALL_INDEPENDENT_31 :
					ns_unexpected_ev ();
					break;

				case STATE_OVERLAP_SENDING_2 :

					if (is_ie_i (CODESET_SO, SENDING_COMPLETE) == ABSENT) {
						Restart_timer_ns (ETS_T304);
					}
					Send_to_d_channel (INFO);
					break;

				default :

					if (is_ie_i (CODESET_0, CALLED_NB) != PRESENT) {
						Send_to_d_channel (INFO);
					}

			}

			return (OK);

						/* STATUS */

		case DA_STATUS :

			if (Call_current_exist) {

				if (I_call_state_val == STATE_NULL_0) {
					Call_fac_rq	= OFF;
					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Layer 4 */
					call_clear ();									/* free call context */

				} else {

					if (C_v (I_cause_class, I_cause_val) ==
						C_v (C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30)) {

						Stop_timer_ns (ETS_T322);
					}

					if ((Call_state != I_call_state_val) &&
						(Call_state != STATE_RELEASE_REQUEST_19)) {

						if ((I_cause_class == C_C_PROTOCOL_ERROR)				&&
							((I_cause_val == C_V_MANDATORY_IE_MISSING_96)		||
							 (I_cause_val == C_V_MESSAGE_TYPE_NON_EXISTENT_97)	||
							 (I_cause_val == C_V_NON_EXISTENT_IE_99)			||
							 (I_cause_val == C_V_INVALID_IE_CONTENT_100)))	{
							Call_fac_rq	= OFF;
							Send_to_d_channel (REL_COMP);
							Send_to_call_control (NS_CLEAR_CO);
							call_clear ();
						}
					}
				}
			}

#			if NS_RESTART_PROCEDURE == ON /* { */

			else {		/* NON CALL-ASSOCIATED */

				switch (Dl_rest_state) {

					case STATE_REST_0 :
						break;

					case STATE_REST_1 :

						if (I_call_state_val != STATE_REST_2) {
							ns_stop_all_dlci_timers ();
							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_STATE_INCOMP);
							Dl_restart_reset ();
						}

						break;

					case STATE_REST_2 :

						if (I_call_state_val != STATE_REST_1) {
							ns_snd_mns (MNS_RESTART_IN);
						}

						break;
				}
			}

#			endif /* RESTART_PROCEDURE = ON} */

			return (OK);

						/* STATUS_ENQ */

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_state (Call_state);
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			Send_to_d_channel (STATUS);
			return (OK);

						/* NS_STATUS_ENQ_RQ */

		case NS_STATUS_ENQ_RQ :

			if (State_timer_ns (ETS_T322) == OFF) {
				Send_to_d_channel (STATUS_ENQ);
				Start_timer_ns (ETS_T322);
			}
			return (OK);

		case TI_322 :		/* implementation dependent */

			if (i_entity_origination == ENT_TI) {
				return (OK);

			} else {

				break;
			}

#		if NS_RESTART_PROCEDURE == ON /* { */

			case TI_316 :

				if (Dl_rest_state == STATE_REST_1) {

					if (++N316 == ETS_MX_N316) {

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_316);
						Dl_restart_reset ();

					} else {

						Set_call_ref_not_nil ();

							/* store Restart Indicator with value saved in DL context */

						set_ie_i (CODESET_0, RESTART_IND);
						I_restart_ind_class = Dl_rest_class;

						if (I_restart_ind_class == RI_INDICATED_CHANNEL) {

								/* store Channel-ID */

							ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
							set_ie_i (CODESET_0, CHAN_ID);

							I_chan_id_d_chan = NOT_D_CHAN;		/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */

							if (Na_type == BRI) {

								/* Basic Rate */

								I_chan_id_int_type = INT_TYPE_BRI;
								I_chan_id_chan_sel = Dl_rest_chan_nb;	/* B1_CHAN or B2_CHAN */

							} else {

								/* Primary Rate */

								I_chan_id_int_type = INT_TYPE_PRI;
								I_chan_id_chan_sel = AS_INDICATED;	/* Channel Number as indicated in following octets */
								I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

								I_chan_id_a_chan_number = p_ind_buffer++;			/* save data into indirect buffer */
								*I_chan_id_a_chan_number = Dl_rest_chan_nb;	/* channel number */
								Set_ext_bit (*I_chan_id_a_chan_number);		/* Set the extension bit to 1 in the chan_nb field before sending SPDU */
							}
						}

						Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
						Restart_dl_timer (ETS_T316);
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case TI_317 :

				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
						Dl_restart_reset ();
						break;

					default :

						ns_unexpected_ev ();
				}

				return (OK);

			case DA_RESTART :

				if (Dl_rest_state == STATE_REST_0) {

					Start_dl_timer (ETS_T317);
					Set_call_ref_nil ();		/* to use CONN_ID_MANAGEMENT */
					Send_to_call_control (NS_RESTART_IN);
					Dl_rest_state = STATE_REST_2;

					if (I_restart_ind_class == RI_ALL_INTERFACES) {
						csc_clear_all_call ();
						Na_internal_restart = ON;
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case DA_RESTART_ACK :

				if (Dl_rest_state == STATE_REST_1) {

					Stop_dl_timer (ETS_T316);

					if (Dl_rest_resp == ON) {

						ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
						Dl_restart_reset ();

					} else {

						Dl_rest_ack = ON;
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case NS_RESTART_RS :

				Stop_dl_timer (ETS_T317);
				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

						Set_call_ref_not_nil ();
						Send_to_d_channel (RESTART_ACK);
						Dl_restart_reset ();
						break;

					default :

						ns_unexpected_ev ();
				}

				return (OK);

			case NS_RESTART_RQ :

				if (Dl_rest_state != STATE_REST_0) {

					call_clear ();

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#		endif /* NS_RESTART_PROCEDURE == ON} */

#		if NS_SUPP_SERVICES == ON

			case DA_FAC :
				Send_to_call_control (NS_FAC_IN);
				return (OK);

			case NS_FAC_RQ :

				if ((Call_current_exist) && (Call_state == STATE_CALL_PRESENT_6)) {

					ns_unexpected_ev ();

				} else {

					Send_to_d_channel (FAC);
				}

				return (OK);

			case DA_NOTIFY :
				Send_to_call_control (NS_NOTIFY_IN);
				return (OK);

			case NS_NOTIFY_RQ :

				/*	NOTIFY message may not be sent with dummy call ref in user-to-network direction.
					It may be sent by the user only after the first response to SETUP message has been sent or received.
				*/

				if ((Call_current_exist) && (Call_state != STATE_CALL_INIT_1) && (Call_state != STATE_CALL_PRESENT_6)) {

					Send_to_d_channel (NOTIFY);

				} else {

					ns_unexpected_ev ();
				}

				return (OK);
#		endif

	} /* End switch (event_id) */

#	if NS_HOLD_RETRIEVE == ON

			/* Is event related to Hold/Retrieve procedure ?
				-> if not, function shall return CONTINUE */

		if (ets_hold_retrieve_process () != CONTINUE) {

			return (OK);	/* Yes : event is processed -> stop */
		}

#	endif

/*.........................................................................*/

					/* 2 - STATE DRIVEN PROCESSING */

			/*
					 Switch according to the call state :

			   Dispatch to the function that processes the state except if
			   it is a clearing event not received  in an exceptional condition.
			   In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "ets_circuit_switched_call");
	}

	switch (Call_state) {

			/* Null state (u0) */

		case STATE_NULL_0 :
		case STATE_WAIT_DL :
			ets_u0 ();
			break;

			/* Call initiated (u1) */

		case STATE_CALL_INIT_1 :
			ets_u1 ();
			break;

			/* Overlap sending (u2) */

		case STATE_OVERLAP_SENDING_2 :
			ets_u2 ();
			break;

			/* Outgoing call proceeding (u3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			ets_u3 ();
			break;

			/* Call delivered (u4) */

		case STATE_CALL_DELIVERED_4 :
			ets_u4 ();
			break;

			/* Call present (u6) */

		case STATE_CALL_PRESENT_6 :
			ets_u6 ();
			break;

			/* Call received (u7) */

		case STATE_CALL_RECEIVED_7 :
			ets_u7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			ets_u8 ();
			break;

			/* Incoming call proceeding state (u9) */

		case STATE_INCOMING_CALL_PROC_9 :
			ets_u9 ();
			break;

			/*  Active (u10) */

		case STATE_ACTIVE_10 :
			ets_u10 ();
			break;

			/* Disconnect request (u11) */

		case STATE_DISCONNECT_REQUEST_11 :
			ets_u11 ();
			break;

			/* Disconnect indication (u12) */

		case STATE_DISCONNECT_INDICATION_12 :
			ets_u12 ();
			break;

			/* Suspend request (u15) */

		case STATE_SUSPEND_REQUEST_15 :
			ets_u15 ();
			break;

			/* Resume request (u17) */

		case STATE_RESUME_REQUEST_17 :
			ets_u17 ();
			break;

			/* Release request (u19) */

		case STATE_RELEASE_REQUEST_19 :
			ets_u19 ();
			break;

			/* Overlap receiving (u25) */

		case STATE_OVERLAP_RECEIVING_25 :
			ets_u25 ();
			break;

#		if NS_SUPP_SERVICES == ON

			/*	Bearer Independent Transport (u31) : all allowed messages are processed above
				(FACILITY, RELEASE, RELEASE COMPLETE, STATUS, STATUS ENQUIRY) -> unexpected message */

			case STATE_CALL_INDEPENDENT_31 :
				ns_unexpected_ev ();
				break;

#		endif 

			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "ets_circuit_switched_call");

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			ets_hold_call_state_allowed - tests if Hold and Retrieve
				functions are allowed in current call state as described
				in subclause 7.2.1.1 of Recommendation ETS 300 196.

Name			ets_hold_retrieve_process - implements the processing of
				the sequence of messages and services primitives associated
				with the control of Hold and Retrieve functions as described
				in the section 7 and annex A of Recommendation ETS 300 196.

Name			ets_call_state_change - implements the actions to be done when
				a change of call state occurs. These actions are related to Hold
				and Retrieve functions when they are in use and when they are not
				allowed in new call state.

Usage			uchar ets_hold_call_state_allowed ();

Usage			uchar ets_hold_retrieve_process ();

Usage			void ets_call_state_change ();

Return value	ets_hold_call_state_allowed returns OK if Hold and Retrieve functions
				are allowed in currenct call state, NOK else.

				ets_hold_retrieve_process returns OK when the event is related to Hold or
				Retrieve functions and has been processed, CONTINUE when the event is not
				related to Hold or Retrieve functions.

Common constants and declarations : ns.h

Common objects	call current context, message current context.

*--------------------------------------------------------------------------*/

#if NS_HOLD_RETRIEVE == ON /* { */

uchar ets_hold_call_state_allowed ()
{

		/* The Hold and Retrieve functions may only be invoked in following call states :
			Outgoing Call Proceeding (U3, N3), Call Delivered (U4, N4), Active (U10, N10),
				and, if a point-to-point configuration exists,
			Call Received (U7, N7), Connect Request (U8, N8), Incoming Call Proceeding (U9, N9).
            	See subclause 7.2.1.1 of Recommendation ETS 300 196.
		*/

	switch (Call_state) {

		case STATE_OUTGOING_CALL_PROC_3:
		case STATE_CALL_DELIVERED_4 :
		case STATE_ACTIVE_10 :

			return (OK);

		case STATE_CALL_RECEIVED_7 :
		case STATE_CONNECT_REQUEST_8 :
		case STATE_INCOMING_CALL_PROC_9 :

			if (Na_connection == POINT_TO_POINT) {

				return (OK);
			}

            	/* Point-to-Multipoint configuration : not allowed call states -> process in 'default' */

		default :

			return (NOK);
	}
}

	/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */

uchar ets_hold_retrieve_process ()
{

	if (i_entity_origination == ENT_TI) {

		switch (event_id) {

			case NS_TI_HOLD :

					/* Timer T-HOLD expiry :
						- if auxiliary call state is not Hold Request, ignore (it should not happen),
						- else enter the Idle auxiliary state and inform upper entity */

				if (Call_hold_aux_state == NS_AUX_STATE_HOLD_RQ) {

					set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "HOL");
					Send_to_call_control (NS_HOLD_CO);
					Call_hold_aux_state = NS_AUX_STATE_IDLE;
				}

				break;

			case NS_TI_RET :

					/* Timer T-RETRIEVE expiry :
						- if auxiliary call state is not Retrieve Request, ignore (it should not happen),
						- else enter the Call Held auxiliary state and inform upper entity */

				if (Call_hold_aux_state == NS_AUX_STATE_RET_RQ) {

					set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "RET");
					Send_to_call_control (NS_RET_CO);
					Call_hold_aux_state = NS_AUX_STATE_HELD;
				}

				break;

				/* event is not related to Hold/Retrieve procedure -> continue to process in 'circuit_switched_call' */

			default :

				return (CONTINUE);
		}

		return (OK);
	}

	switch (event_id) {

		case DA_HOLD :

				/* receipt of HOLD SPDU : process according to call state and auxiliary call state */

			switch (Call_hold_aux_state) {

				case NS_AUX_STATE_IDLE :	/* Idle */

					if (ets_hold_call_state_allowed () == NOK) {

						if ((Call_state == STATE_DISCONNECT_INDICATION_12) || (Call_state == STATE_RELEASE_REQUEST_19)) {

							return (OK);	/* in call state (U12, N12)or (U19, N19) -> ignore the message */
						}

						break;	/* Hold function is not allowed in current call state -> send HOLD REJECT */
					}

						/* call state is allowed -> enter the Hold Indication auxiliary state and inform upper entity */

					Send_to_call_control (NS_HOLD_IN);
					Call_hold_aux_state = NS_AUX_STATE_HOLD_IN;
					return (OK);

				case NS_AUX_STATE_HOLD_RQ :		/* Hold Request : collision -> priority is given to the network initiated Hold function */

#					if EQUIPMENT == NT2
						if (Na_fct == FG_NT_TE) {

							return (OK);		/* Network side : ignore message */
						}
#					endif

						/* User side : stop timer T-HOLD, enter the Hold Indication auxiliary state and inform upper entity */

					Stop_timer_ns (ETS_T_HOLD);
					Send_to_call_control (NS_HOLD_IN);
					Call_hold_aux_state = NS_AUX_STATE_HOLD_IN;
					return (OK);
			}

				/*	Hold function is not allowed in current auxiliary state or call state ->
					send HOLD REJECT message with cause #101 and remain in the same state */

			Reset_internal_ie ();
			set_i_cause	(C_C_PROTOCOL_ERROR, C_V_MESSAGE_NOT_COMPATIBLE_101, P_NIL);
			Send_to_d_channel (HOLD_REJ);
			break;

		case DA_HOLD_ACK :
		case DA_HOLD_REJ :

				/* receipt of HOLD-ACKNOWLEDGE or HOLD-REJECT SPDU : process according to auxiliary call state */

			if (Call_hold_aux_state != NS_AUX_STATE_HOLD_RQ) {

				ns_unexpected_ev ();

			} else {

					/* stop timer T-HOLD, inform upper entity and enter the Call Held auxiliary
						state (ACKNOWLEDGE) or the Idle auxiliary state (REJECT) */

				Stop_timer_ns (ETS_T_HOLD);
				Send_to_call_control (NS_HOLD_CO);

				if (event_id == DA_HOLD_ACK) {

					Call_hold_aux_state = NS_AUX_STATE_HELD;

				} else {

					Call_hold_aux_state = NS_AUX_STATE_IDLE;
				}
			}

			break;

		case DA_RET :

				/* receipt of RETRIEVE SPDU : process according to auxiliary call state */

			switch (Call_hold_aux_state) {

				case NS_AUX_STATE_RET_RQ :	/* Retrieve Request : collision -> priority is given to the network initiated Retrieve function */

#					if EQUIPMENT == NT2
						if (Na_fct == FG_NT_TE) {

							return (OK);		/* Network side : ignore message */
						}
#					endif

						/* User side : stop timer T-RETRIEVE, enter the Retrieve Indication auxiliary state and inform upper entity */

					Stop_timer_ns (ETS_T_RET);

						/* continue to process in next 'case' -> no 'break' */

				case NS_AUX_STATE_HELD :	/* Call Held */

						/* enter the Retrieve Indication auxiliary state and inform upper entity */

					Send_to_call_control (NS_RET_IN);
					Call_hold_aux_state = NS_AUX_STATE_RET_IN;
					return (OK);
			}

				/*	Retrieve function is not allowed in current auxiliary call state ->
					send RETRIEVE REJECT message with cause #101 and remain in the same state */

			Reset_internal_ie ();
			set_i_cause	(C_C_PROTOCOL_ERROR, C_V_MESSAGE_NOT_COMPATIBLE_101, P_NIL);
			Send_to_d_channel (RET_REJ);
			break;

		case DA_RET_ACK :
		case DA_RET_REJ :

				/* receipt of RETRIEVE-ACKNOWLEDGE or RETRIEVE-REJECT SPDU : process according to auxiliary call state */

			if (Call_hold_aux_state != NS_AUX_STATE_RET_RQ) {

				ns_unexpected_ev ();

			} else {

					/* stop timer T-RETRIEVE, inform upper entity and enter the Idle auxiliary
						state (ACKNOWLEDGE) or the Call Held auxiliary state (REJECT) */

				Stop_timer_ns (ETS_T_RET);
				Send_to_call_control (NS_RET_CO);

				if (event_id == DA_RET_ACK) {

					Call_hold_aux_state = NS_AUX_STATE_IDLE;

				} else {

					Call_hold_aux_state = NS_AUX_STATE_HELD;
				}
			}

			break;

		case NS_HOLD_RQ :

				/* Hold Request from upper entity -> process according to call state and auxiliary call state */

			if ((Call_hold_aux_state == NS_AUX_STATE_IDLE) && (ets_hold_call_state_allowed () == OK)) {

					/* start timer T-HOLD, enter the Hold Request auxiliary state and send HOLD message */

				Send_to_d_channel (HOLD);
				Call_hold_aux_state = NS_AUX_STATE_HOLD_RQ;
				Start_timer_ns (ETS_T_HOLD);

			} else {

				ns_unexpected_ev ();	/* The Hold function shall only be invoked in the Idle auxiliary state and the call states specified */
			}

			break;

		case NS_HOLD_RS :

				/*	Hold Response from upper entity -> process according to auxiliary call state and presence of Cause IE */

			if (Call_hold_aux_state == NS_AUX_STATE_HOLD_IN) {

					/* Is the Cause IE contained in received NS_HOLD_RS primitive ?
						- Yes : Hold function is not permitted -> enter the Idle auxiliary state and send HOLD-REJECT message
						- No : Hold function is permitted -> enter the Call Held auxiliary state and send HOLD-ACKNOWLEDGE message
					*/

				if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {

					Send_to_d_channel (HOLD_REJ);
					Call_hold_aux_state = NS_AUX_STATE_IDLE;

				} else {

					Send_to_d_channel (HOLD_ACK);
					Call_hold_aux_state = NS_AUX_STATE_HELD;
				}

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_RET_RQ :

				/* Retrieve Request from upper entity -> process according to auxiliary call state */

			if (Call_hold_aux_state == NS_AUX_STATE_HELD) {

					/* start timer T-RETRIEVE, enter the Retrieve Request auxiliary state and send RETRIEVE message */

				Send_to_d_channel (RET);
				Call_hold_aux_state = NS_AUX_STATE_RET_RQ;
				Start_timer_ns (ETS_T_RET);

			} else {

				ns_unexpected_ev ();	/* The RETRIEVE message shall only be sent in the Call Held auxiliary state */
			}

			break;

		case NS_RET_RS :

				/*	Retrieve Response from upper entity -> process according to auxiliary call state and presence of Cause IE */

			if (Call_hold_aux_state == NS_AUX_STATE_RET_IN) {

					/* Is the Cause IE contained in received NS_RET_RS primitive ?
						- Yes : Retrieve function is not permitted -> enter the Call Held auxiliary state and send RETRIEVE-REJECT message
						- No : Retrieve function is permitted -> enter the Idle auxiliary state and send RETRIEVE-ACKNOWLEDGE message
					*/

				if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {

					Send_to_d_channel (RET_REJ);
					Call_hold_aux_state = NS_AUX_STATE_HELD;

				} else {

					Send_to_d_channel (RET_ACK);
					Call_hold_aux_state = NS_AUX_STATE_IDLE;
				}

			} else {

				ns_unexpected_ev ();
			}

			break;

			/* event is not related to Hold/Retrieve procedure -> continue to process in 'circuit_switched_call' */

		default :

			return (CONTINUE);
	}

	return (OK);
}

	/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */

void ets_call_state_change ()
{

	if ((Call_hold_aux_state == NS_AUX_STATE_IDLE) || (ets_hold_call_state_allowed () == OK)) {

			/*	Hold and Retrieve functions are not in use or they are 
				allowed in new call state is allowed : nothing to do */

		return;
	}

		/*	Hold or Retrieve function is in use but a transition to a 
			call state in which they are not allowed has just occurred */

	if (Call_state != STATE_DISCONNECT_INDICATION_12) {

		/*	In all cases the call shall enter the Idle auxiliary state. For a call in the
			Hold Request or Retrieve Request auxiliary state, the appropiate timer shall be stopped */

		switch (Call_hold_aux_state) {

			case NS_AUX_STATE_RET_RQ :

				Stop_timer_ns (ETS_T_RET);
				break;

			case NS_AUX_STATE_HOLD_RQ :

				Stop_timer_ns (ETS_T_HOLD);
				break;
		}

		Ns_send_hold_ret_abort_in (NS_ABORT_CAUSE_CALL_ST_CHG);		/* send ABORT indication to upper entity */
		Call_hold_aux_state = NS_AUX_STATE_IDLE;

	} else {

		/*	The call has just entered the (U12, N12) state : for a call in the Hold Request
			auxiliary state, timer T-HOLD shall be stopped. For a call in the Hold Request or
			Hold Indication auxiliary state, the call shall enter the Idle auxiliary state.
			Otherwise, no action shall be taken. */

		switch (Call_hold_aux_state) {

			case NS_AUX_STATE_HOLD_RQ :

				Stop_timer_ns (ETS_T_HOLD);
				break;

			case NS_AUX_STATE_HOLD_IN :

				break;

			default :		/* Call Held / Retrieve Request / Retrieve Indication -> no action */

				return;
		}

		Ns_send_hold_ret_abort_in (NS_ABORT_CAUSE_CALL_ST_CHG);		/* send ABORT indication to upper entity */
		Call_hold_aux_state = NS_AUX_STATE_IDLE;
	}
}

#endif /* end of NS_HOLD_RETRIEVE == ON} */

#if EQUIPMENT == NT2

	void ets_n0		(Void_parm);
	void ets_n1		(Void_parm);
	void ets_n2		(Void_parm);
	void ets_n3		(Void_parm);
	void ets_n4		(Void_parm);
	void ets_n6		(Void_parm);
	void ets_n7		(Void_parm);
	void ets_n8		(Void_parm);
	void ets_n9		(Void_parm);
	void ets_n10	(Void_parm);
	void ets_n11	(Void_parm);
	void ets_n12	(Void_parm);
	void ets_n15	(Void_parm);
	void ets_n16	(Void_parm);
	void ets_n17	(Void_parm);
	void ets_n19	(Void_parm);
	void ets_n22	(Void_parm);
	void ets_n25	(Void_parm);
	void ets_n0i	(Void_parm);
	void ets_n7i	(Void_parm);
	void ets_n8i	(Void_parm);
	void ets_n9i	(Void_parm);
	void ets_n19i	(Void_parm);
	void ets_n25i	(Void_parm);

#define Ets_send_to_all_ces(ev_id, ie_flag)			ets_send_to_other_ces (ev_id, ie_flag); \
													ets_send_to_ces (ev_id, ie_flag, Call_ces)	/* send to all terminals ev_id. Flag = OFF for specific cause */

						/*-------------------*/
						/*                   */
						/*   NETWORK SIDE    */
						/*                   */
						/*-------------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ets_circuit_switched_call_n - implements the processing of
				the sequence of messages and services primitives associated
				with the control of circuit-switched connections.

Usage          	uchar ets_circuit_switched_call_n ();

Related
functions usage void n0 .... n254 () ; n0i(), n7i(), n8i(), n9i(), n19i, n25i()

Description     ets_circuit_switched_call implements the processing of a received
				event according to the event (event driven) or to the state
				of the current call (state driven).

Return value    uchar = OK  the event processing is correctly done,
					  = NOK the event processing is not correctly done.

Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

/*								CLEARING PROCEDURES

	   TE                         NT/NETWORK                        TE
 _________________             _________________            _________________
 |               |             |               |            |               |
 |NS_CLEAR_RQ    |   DA_DISC   |       |       |            |               |
 |==========>....|------------>|.......|.....  |            |               |
 | start T305    |			   |  .    |    .  |            |               |
 |               |             |  .    |    .  |            |               |
 |               |             |  .    |    .  |            |               |
 |               |             |  .    |    .  |            |               |
 |NS_CLEAR_CO    |   DA_REL    |  .    |    .  |   DA_DISC  |    NS_CLEAR_IN|
 |<===========...|<------------|...    |    ...|----------->|...===========>|
 |  stop T305  . |             |start T308	   |            |    NS_CLEAR_RS|
 |             . | DA_REL_COMP |   start T305  |     REL    |  .<===========|
 |             ..|------------>|       |    ...|<-----------|...  start T308|
 |               |             |       |    .  |            |               |
 |               |             |       |    .  | DA_REL_COMP|    NS_CLEAR_CO|
 |               |             |       |    ...|----------->|...===========>|
 |               |             |       |       |            |     stop T308 |
 |---------------|             |---------------|            |---------------|

*/

uchar ets_circuit_switched_call_n ()
{

#	if NS_RESTART_PROCEDURE == ON
		uchar	FAR *p_data;
#	endif

/*
					if (multipoint) {

						if (from d_channel) {
				1 - 		INTERNAL PROCESSING 	(Individual process)
						}
					}

				2 - EVENT DRIVEN PROCESSING 	(Global process)
				3 - STATE DRIVEN PROCESSING		(Global process)

					if (multipoint) {

						if (from call control) {
				4 - 		INTERNAL PROCESSING 	(Individual process)
						}
					}
*/


/*.........................................................................*/

	if (Na_connection == POINT_TO_MULTIPOINT) {

					/* 1 - INTERNAL PROCESS */

		if ((i_entity_origination == ENT_DL_D) || (i_entity_origination == ENT_TI)) {
			ets_internal_process ();
		}

		if (i_entity_origination == ENT_CC) {

			if ((Call_current_exist) && (Call_ces_connect != NIL)) {
				Ns_access_dl_ces (Call_ces_connect);
			}
		}
	}

/*.........................................................................*/

					/* 2 - EVENT DRIVEN PROCESS */


	if (i_entity_origination == ENT_MNS) {

		switch (event_id) {

#			if NS_RESTART_PROCEDURE == ON /* { */

				case MNS_RESTART_RQ :

					if (Dl_rest_state == STATE_REST_0) {

							/* set current data pointer using p_ssdu pointer */

						p_data = p_ssdu;

						if (Dl_call_count == 0) {

								/* Return MNS_RESTART_CO and do nothing else */

							ns_send_mns_restart (OK, I_restart_ind_class, Mns_restart_b_chan_nb, 0);
							return (OK);
						}

						if (I_restart_ind_class == RI_INDICATED_CHANNEL) {

							I_chan_id_d_chan = NOT_D_CHAN;		/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */

							if (Na_type == BRI) {

								/* Basic Rate */

								I_chan_id_int_type = INT_TYPE_BRI;
								I_chan_id_chan_sel = Mns_restart_b_chan_nb;	/* B1_CHAN or B2_CHAN */

							} else {

								/* Primary Rate */

								I_chan_id_int_type = INT_TYPE_PRI;
								I_chan_id_chan_sel = AS_INDICATED;	/* Channel Number as indicated in following octets */
								I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */
								I_chan_id_a_chan_number = p_ind_buffer++;			/* save data into indirect buffer */
								*I_chan_id_a_chan_number = Mns_restart_b_chan_nb;	/* channel number */
							}
						}

						if (I_restart_ind_class == RI_ALL_INTERFACES) {
							csc_clear_all_call ();
							Na_internal_restart = ON;
						}

						Send_to_call_control (NS_RESTART_IN);	/* on CONN_ID_MANAGEMENT */
						Start_dl_timer (ETS_T317);
						Set_call_ref_not_nil ();

						if (I_chan_id_a_chan_number != A_NIL) {

							/* Set the extension bit to 1 in the chan_nb field before sending SPDU */

							Set_ext_bit (*I_chan_id_a_chan_number);
						}

						Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
						N316 = 0;
						Start_dl_timer (ETS_T316);
						Dl_rest_state = STATE_REST_1;

					} else {

						ns_unexpected_ev ();
					}

					break;

#			endif /* RESTART_PROCEDURE = ON} */

#			if ASSERT == ON

				default :
					Trap (TRAP_MNS_CODE, "circuit_switched_call_n");

#			endif

		} /* end "switch (event_id)" */

		return (OK);
	}

	switch (event_id) {

							/* EV_NIL : do nothing */

		case EV_NIL :
			return (OK);

							/* SETUP : allocate a call context */

		case DA_SETUP :
		case DA_RES :

#		if NS_SUPP_SERVICES == ON
		case DA_REG :
#		endif

			if (allocate_call (INCOMING_CALL, 0) == NOK) {
				Reset_internal_ie ();
				set_i_cause	(C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_CONGESTION_42, P_NIL);
				Send_to_d_channel (REL_COMP);
				return (OK);
			}
			break;

							/* DISCONNECT */

		case DA_DISC :
			Call_fac_rq		= OFF;

			switch (Call_state) {

				case STATE_CALL_RECEIVED_7 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Reset_internal_ie ();
						set_i_state (STATE_CALL_PRESENT_6);
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
						Send_to_d_channel (STATUS);

					} else {

						ns_action_to_cc (ETS_T301, ETS_T300, NS_CLEAR_IN,
															 STATE_DISCONNECT_REQUEST_11);
					}

					break;


				case STATE_CONNECT_REQUEST_8 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Reset_internal_ie ();
						set_i_state (STATE_CALL_PRESENT_6);
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
						Send_to_d_channel (STATUS);

					} else {

						ns_action_to_cc (T3_NIL, ETS_T300, NS_CLEAR_IN,
														   STATE_DISCONNECT_REQUEST_11);
					}

					break;

				case STATE_INCOMING_CALL_PROC_9 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Reset_internal_ie ();
						set_i_state (STATE_CALL_PRESENT_6);
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
						Send_to_d_channel (STATUS);

					} else {

						ns_action_to_cc (ETS_T310, ETS_T300, NS_CLEAR_IN,
															 STATE_DISCONNECT_REQUEST_11);
					}

					break;

				case STATE_DISCONNECT_INDICATION_12 :
					Stop_timer_ns (ETS_T305);
					Reset_internal_ie ();
					go_to_state_19 (ETS_T308);
					break;


				case STATE_RELEASE_REQUEST_19 :
						/* no process */
					break;

				case STATE_OVERLAP_RECEIVING_25 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Reset_internal_ie ();
						set_i_state (STATE_CALL_PRESENT_6);
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
						Send_to_d_channel (STATUS);

					} else {

						ns_action_to_cc (ETS_T304, ETS_T300, NS_CLEAR_IN,
															 STATE_DISCONNECT_REQUEST_11);
					}

					break;


				case STATE_NULL_0 :
				case STATE_CALL_PRESENT_6 :
				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_SUSPEND_REQUEST_15 :
				case STATE_CALL_ABORT_22 :
#				if NS_SUPP_SERVICES == ON
					case STATE_CALL_INDEPENDENT_31 :
#				endif
					ns_unexpected_ev ();
					break;

				default :
					ns_stop_all_timers ();
					ns_action_to_cc (T3_NIL, ETS_T300, NS_CLEAR_IN,
													   STATE_DISCONNECT_REQUEST_11);
					break;

			}

			return (OK);

							/* - RELEASE */

		case DA_REL :
			Call_fac_rq 	= OFF;

			switch (Call_state) {

				case STATE_NULL_0 :
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);					/* send the Release Complete Message to network */
					call_clear ();									/* free call context */
					break;

				case STATE_CALL_PRESENT_6 :
				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :
				case STATE_OVERLAP_RECEIVING_25 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Reset_internal_ie ();
						Send_to_d_channel (REL_COMP);

					} else {

						Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
						Reset_internal_ie ();
						Send_to_d_channel (REL_COMP);
						call_clear ();
					}

					break;

				case STATE_SUSPEND_REQUEST_15 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_ABORT_22 :
					/* no process */
					return (OK);

				default :
					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Layer 4 */
					Reset_internal_ie ();
					Send_to_d_channel (REL_COMP);					/* send the Release Complete Message to network */
					call_clear ();									/* free call context */
					break;

			}

			return (OK);


						/* - RELEASE COMPLETE */

		case DA_REL_COMP :

			Call_fac_rq	= OFF;

			switch (Call_state) {

				case STATE_NULL_0 :

					/* no process */

					break;

				case STATE_CALL_INIT_1 :
				case STATE_SUSPEND_REQUEST_15 :
				case STATE_RESUME_REQUEST_17 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_PRESENT_6 :
				case STATE_INCOMING_CALL_PROC_9 :
				case STATE_OVERLAP_RECEIVING_25 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						save_ie_cause ();

						if (Call_state == STATE_CALL_PRESENT_6) {
							Call_sub_state = N6_REL_COMP;

						} else {

							Call_sub_state = N6;
						}

					} else {

						Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
						call_clear ();
					}

					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :

					if (Call_ces_setup != DL_CES_BROADCAST) {
						Send_to_call_control (NS_CLEAR_CO);				/* send NS clear to Layer 4 */
						call_clear ();
					}

					break;

				case STATE_CALL_ABORT_22 :
					/* no process */
					return (OK);

				default :
					Send_to_call_control (NS_CLEAR_CO);				/* send NS clear confirm to Layer 4 */
					call_clear ();									/* free call context */
					break;

			}

			return (OK);

						/* NS CLEAR REQUEST */

		case NS_CLEAR_RQ :

			switch (Call_state) {

				case STATE_NULL_0 :
				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_RELEASE_REQUEST_19 :
					ns_unexpected_ev ();
					break;

				case STATE_CALL_INIT_1 :
					Send_to_d_channel (REL_COMP);
					Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
					call_clear ();
					break;

				case STATE_CALL_PRESENT_6 :
					Release_saved_spdu ();								/* saved setup no more useful */
					Stop_timer_ns (ETS_T303);

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Send_to_call_control (NS_CLEAR_IN);				/* send NS clear to Layer 4 */
						Set_state (STATE_CALL_ABORT_22);

					} else {

						ns_action_to_dl (T3_NIL, ETS_T305, DISC,
														   STATE_DISCONNECT_INDICATION_12);
					}

					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Ets_send_to_all_ces (REL, ON);						/* send a REL with cause #26 to all ces which responded with ALERT */

						if (State_timer_ns (ETS_T312) == ON) {
							ns_action_to_cc (ETS_T301, T3_NIL, NS_CLEAR_IN,
															   STATE_CALL_ABORT_22);
						} else {

							Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
							call_clear ();
						}

					} else {

						ns_action_to_dl (T3_NIL, ETS_T305, DISC,
														   STATE_DISCONNECT_INDICATION_12);
					}

					break;

				case STATE_INCOMING_CALL_PROC_9 :
				case STATE_OVERLAP_RECEIVING_25 :

					if (Call_state == STATE_OVERLAP_RECEIVING_25) {
						save_ie_cause ();
						Stop_timer_ns (ETS_T304);

					} else {

						Stop_timer_ns (ETS_T310);
					}

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Ets_send_to_all_ces (REL, OFF);						/* send a REL with cause #26 to all ces which responded with ALERT */

						if (State_timer_ns (ETS_T312) == ON) {
							ns_action_to_cc (ETS_T301, T3_NIL, NS_CLEAR_IN,
															   STATE_CALL_ABORT_22);
						} else {

							Send_to_call_control (NS_CLEAR_CO);			/* send NS clear to Layer 4 */
							call_clear ();
						}

					} else {

						ns_action_to_dl (T3_NIL, ETS_T305, DISC,
														   STATE_DISCONNECT_INDICATION_12);
					}

					break;

#				if NS_SUPP_SERVICES == ON
					case STATE_CALL_INDEPENDENT_31 :
						go_to_state_19 (ETS_T308);
						break;
#				endif

				default :
					ns_stop_all_timers ();
					Save_cause ();									/* to send the RELEASE if ETS_T305 expire */
					ns_action_to_dl (T3_NIL, ETS_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);
					break;

			}

			return (OK);

							/* INFO */

		case DA_INFO :

			switch (Call_state) {

				case STATE_NULL_0 :
				case STATE_CALL_INIT_1 :
				case STATE_CALL_PRESENT_6 :
				case STATE_SUSPEND_REQUEST_15 :
				case STATE_RESUME_REQUEST_17 :
				case STATE_CALL_ABORT_22 :
#				if NS_SUPP_SERVICES == ON
					case STATE_CALL_INDEPENDENT_31 :
#				endif
					ns_unexpected_ev ();
					break;

				case STATE_OVERLAP_SENDING_2 :
					Send_to_call_control (NS_INFO_IN);
					Start_timer_ns (ETS_T302);
					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :
				case STATE_OVERLAP_RECEIVING_25 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Reset_internal_ie ();
						set_i_state (STATE_CALL_PRESENT_6);
						set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
						Send_to_d_channel (STATUS);

					} else {

						Send_to_call_control (NS_INFO_IN);
					}

					break;

				default :
					Send_to_call_control (NS_INFO_IN);
					break;

			}

			return (OK);

								/* STATUS */

		case DA_STATUS :

			if (Call_current_exist) {

				if (Call_state == STATE_RELEASE_REQUEST_19) {

					if (I_call_state_val == STATE_NULL_0) {
						Call_fac_rq	= OFF;
						Send_to_call_control (NS_CLEAR_CO);						/* send NS clear confirm to Layer 4 */
						call_clear ();											/* free call context */

					} else {

						if (C_v (I_cause_class, I_cause_val) ==
							C_v (C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30)) {
							Stop_timer_ns (ETS_T322);
						}

					}

				} else {

					if (C_v (I_cause_class, I_cause_val) ==
						C_v (C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30)) {
						Stop_timer_ns (ETS_T322);
					}

					if (Call_state != I_call_state_val) {

						if ((I_cause_class == C_C_PROTOCOL_ERROR)				&&
							((I_cause_val == C_V_MANDATORY_IE_MISSING_96)		||
							 (I_cause_val == C_V_MESSAGE_TYPE_NON_EXISTENT_97)	||
							 (I_cause_val == C_V_NON_EXISTENT_IE_99)			||
							 (I_cause_val == C_V_INVALID_IE_CONTENT_100)))	{
							Call_fac_rq	= OFF;
							Send_to_d_channel (REL_COMP);
							Send_to_call_control (NS_CLEAR_CO);
							call_clear ();
						}

					}

				}
			}

#			if NS_RESTART_PROCEDURE == ON /* { */

			else {		/* NON CALL-ASSOCIATED */

				switch (Dl_rest_state) {

					case STATE_REST_0 :
						break;

					case STATE_REST_1 :

						if (I_call_state_val != STATE_REST_2) {
							ns_stop_all_dlci_timers ();
							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_STATE_INCOMP);
							Dl_restart_reset ();
						}

						break;

					case STATE_REST_2 :

						if (I_call_state_val != STATE_REST_1) {
							ns_snd_mns (MNS_RESTART_IN);
						}

						break;
				}
			}

#			endif /* RESTART_PROCEDURE = ON} */

			return (OK);

								/* NS INFORMATION REQUEST */

		case  NS_INFO_RQ :

			switch (Call_state) {

				case STATE_CALL_PRESENT_6 :
					/* no process */
					break;

				case STATE_SUSPEND_REQUEST_15 :
				case STATE_RESUME_REQUEST_17 :
				case STATE_CALL_ABORT_22 :
#				if NS_SUPP_SERVICES == ON
					case STATE_CALL_INDEPENDENT_31 :
#				endif
					ns_unexpected_ev ();
					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :
				case STATE_OVERLAP_RECEIVING_25 :

					if (Call_ces_setup == DL_CES_BROADCAST) {
						Ets_send_to_all_ces (INFO, ON);
						break;
					}

					/* else default case */

				default :
					Send_to_d_channel (INFO);
					break;
			}

			return (OK);

		case DA_STATUS_ENQ :
			Reset_internal_ie ();
			set_i_state (Call_state);
			set_i_cause	(C_C_NORMAL_EVENT, C_V_RESPONSE_TO_STATUS_ENQUIRY_30, P_NIL);
			Send_to_d_channel (STATUS);
			return (OK);

						/* NS_STATUS_ENQ_RQ */

		case NS_STATUS_ENQ_RQ :

			if (State_timer_ns (ETS_T322) == OFF) {
				Send_to_d_channel (STATUS_ENQ);
				Start_timer_ns (ETS_T322);
			}
			return (OK);

		case TI_322 :		/* implementation dependent */

			if (i_entity_origination == ENT_TI) {

				return (OK);

			} else {

				break;
			}

		case TI_312 :		/* no process */

			switch (Call_state) {
				case STATE_CALL_PRESENT_6 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_ACTIVE_10 :
				case STATE_DISCONNECT_REQUEST_11 :
				case STATE_DISCONNECT_INDICATION_12 :
				case STATE_SUSPEND_REQUEST_15 :
				case STATE_RELEASE_REQUEST_19 :
					break;

				case STATE_CALL_RECEIVED_7 :
				case STATE_INCOMING_CALL_PROC_9 :
				case STATE_OVERLAP_RECEIVING_25 :

					if (ets_nb_active_ces () == 0) {

							/* no more ces able to proceed */

						load_ie_cause ();
						Send_to_call_control (NS_CLEAR_CO);
						call_clear ();
					}
					break;

				case STATE_CALL_ABORT_22 :
					load_ie_cause ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;

				default :
					ns_unexpected_ev ();

			}

			return (OK);

#		if NS_RESTART_PROCEDURE == ON /* { */

			case TI_316 :

				if (Dl_rest_state == STATE_REST_1) {

					if (++N316 == ETS_MX_N316) {

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_316);
						Dl_restart_reset ();

					} else {

						Set_call_ref_not_nil ();

							/* store Restart Indicator with value saved in DL context */

						set_ie_i (CODESET_0, RESTART_IND);
						I_restart_ind_class = Dl_rest_class;

						if (I_restart_ind_class == RI_INDICATED_CHANNEL) {

								/* store Channel-ID */

							ie_implicit_val_x (CODESET_0, CHAN_ID, 0);
							set_ie_i (CODESET_0, CHAN_ID);

							I_chan_id_d_chan = NOT_D_CHAN;		/* B-Channel indicated */
							I_chan_id_pref_excl = CHAN_EXCL;	/* Exclusive */

							if (Na_type == BRI) {

								/* Basic Rate */

								I_chan_id_int_type = INT_TYPE_BRI;
								I_chan_id_chan_sel = Dl_rest_chan_nb;	/* B1_CHAN or B2_CHAN */

							} else {

								/* Primary Rate */

								I_chan_id_int_type = INT_TYPE_PRI;
								I_chan_id_chan_sel = AS_INDICATED;	/* Channel Number as indicated in following octets */
								I_chan_id_chan_number_lgth = 1;		/* 1 Channel number */

								I_chan_id_a_chan_number = p_ind_buffer++;			/* save data into indirect buffer */
								*I_chan_id_a_chan_number = Dl_rest_chan_nb;	/* channel number */
								Set_ext_bit (*I_chan_id_a_chan_number);		/* Set the extension bit to 1 in the chan_nb field before sending SPDU */
							}
						}

						Send_to_d_channel (RESTART);	/* with CALL_REF_GLOBAL */
						Restart_dl_timer (ETS_T316);
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case TI_317 :

				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

							/* Return MNS_RESTART_CO with error */

						ns_send_mns_restart (REPORT_TYPE_ERROR, 0, 0, NS_RESTART_ERR_TI_317);
						Dl_restart_reset ();
						break;

					default :

						ns_unexpected_ev ();
				}

				return (OK);

			case DA_RESTART :

				if (Dl_rest_state == STATE_REST_0) {

					Start_dl_timer (ETS_T317);
					Set_call_ref_nil ();		/* to use CONN_ID_MANAGEMENT */
					Send_to_call_control (NS_RESTART_IN);
					Dl_rest_state = STATE_REST_2;

					if (I_restart_ind_class == RI_ALL_INTERFACES) {
						csc_clear_all_call ();
						Na_internal_restart = ON;
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case DA_RESTART_ACK :

				if (Dl_rest_state == STATE_REST_1) {

					Stop_dl_timer (ETS_T316);

					if (Dl_rest_resp == ON) {

						ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
						Dl_restart_reset ();

					} else {

						Dl_rest_ack = ON;
					}

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

			case NS_RESTART_RS :

				Stop_dl_timer (ETS_T317);

				switch (Dl_rest_state) {

					case STATE_REST_1 :

						if (Dl_rest_ack == ON) {

							ns_send_mns_restart (OK, I_restart_ind_class, 0, 0);
							Dl_restart_reset ();

						} else {

							Dl_rest_resp = ON;
						}

						break;

					case STATE_REST_2 :

						Set_call_ref_not_nil ();
						Send_to_d_channel (RESTART_ACK);
						Dl_restart_reset ();
						break;

					default :

						ns_unexpected_ev ();
				}

				return (OK);

			case NS_RESTART_RQ :

				if (Dl_rest_state != STATE_REST_0) {

					call_clear ();

				} else {

					ns_unexpected_ev ();
				}

				return (OK);

#		endif /* NS_RESTART_PROCEDURE == ON} */

		case DA_CONN :
		case INT_CONN_IN :
		case NS_CONN_RS :

			if (Call_ces_connect == NIL) {

				Call_ces_connect = Dl_ces;
			}

			break;

#		if NS_SUPP_SERVICES == ON

			case DA_NOTIFY :
				Send_to_call_control (NS_NOTIFY_IN);
				return (OK);

			case NS_NOTIFY_RQ :

				/*	Bearer-related NOTIFY message may be sent by the network only after
					the first response to SETUP message has been sent or received. */

				if ((Call_current_exist) && ((Call_state == STATE_CALL_INIT_1) || (Call_state == STATE_CALL_PRESENT_6))) {

					ns_unexpected_ev ();

				} else {

					Send_to_d_channel (NOTIFY);
				}

				return (OK);

			case DA_FAC :
				Send_to_call_control (NS_FAC_IN);
				return (OK);

			case NS_FAC_RQ :

				if ((Call_current_exist) && (Call_state == STATE_CALL_PRESENT_6)) {

					ns_unexpected_ev ();

				} else {

					Send_to_d_channel (FAC);
				}

				return (OK);
#		endif

	} /* End switch (event_id) */

#	if NS_HOLD_RETRIEVE == ON

			/* Is event related to Hold/Retrieve procedure ?
				-> if not, function shall return CONTINUE */

		if (ets_hold_retrieve_process () != CONTINUE) {

			return (OK);	/* Yes : event is processed -> stop */
		}

#	endif

/*.........................................................................*/

				/* 3 - STATE DRIVEN PROCESS */

			/*
					 Switch according to the call state :

			   Dispatch to the function that processes the state except if
			   it is a clearing event not received  in an exceptional condition.
			   In this case the event is processed independently of the call state.
			*/

	if (! Call_current_exist) {
		Trap (TRAP_STATE_NO_CALL, "ets_circuit_switched_call_n");
	}

	switch (Call_state) {

			/* Null state (n0) */

		case STATE_NULL_0 :
			ets_n0 ();
			break;

			/* Call initiated (n1) */

		case STATE_CALL_INIT_1 :
			ets_n1 ();
			break;

			/* Overlap sending (n2) */

		case STATE_OVERLAP_SENDING_2 :
			ets_n2 ();
			break;

			/* Outgoing call proceeding (n3) */

		case STATE_OUTGOING_CALL_PROC_3 :
			ets_n3 ();
			break;

			/* Call delivered (n4) */

		case STATE_CALL_DELIVERED_4 :
			ets_n4 ();
			break;

			/* Call present (n6) */

		case STATE_CALL_PRESENT_6 :
			ets_n6 ();
			break;

			/* Call received (n7) */

		case STATE_CALL_RECEIVED_7 :
			ets_n7 ();
			break;

			/* Connect request (u8) */

		case STATE_CONNECT_REQUEST_8 :
			ets_n8 ();
			break;

			/* Incoming call proceeding (n9) */

		case STATE_INCOMING_CALL_PROC_9 :
			ets_n9 ();
			break;

			/*  Active (n10) */

		case STATE_ACTIVE_10 :
			ets_n10 ();
			break;

			/* Disconnect request (n11) */

		case STATE_DISCONNECT_REQUEST_11 :
			ets_n11 ();
			break;

			/* Disconnect indication (n12) */

		case STATE_DISCONNECT_INDICATION_12 :
			ets_n12 ();
			break;

			/* Suspend request (n15) */

		case STATE_SUSPEND_REQUEST_15 :
			ets_n15 ();
			break;

			/* Resume request (n17) */

		case STATE_RESUME_REQUEST_17 :
			ets_n17 ();
			break;

			/* Release request (n19) */

		case STATE_RELEASE_REQUEST_19 :
			ets_n19 ();
			break;

			/* CALL ABORT (n22) */

		case STATE_CALL_ABORT_22 :
			ets_n22 ();
			break;

			/* Overlap receiving (n25) */

		case STATE_OVERLAP_RECEIVING_25 :
			ets_n25 ();
			break;

#		if NS_SUPP_SERVICES == ON

			/*	Bearer Independent Transport (n31) : all allowed messages are processed above
				(FACILITY, RELEASE, RELEASE COMPLETE, STATUS, STATUS ENQUIRY) -> unexpected message */

			case STATE_CALL_INDEPENDENT_31 :
				ns_unexpected_ev ();
				break;

#		endif 

			/* Unknown state --> Trap */

		default :
			Trap (TRAP_UNKNOWN_CALL_STATE, "ets_circuit_switched_call_n");

	}

/*.........................................................................*/


	if (Na_connection == POINT_TO_MULTIPOINT) {

					/* 4 - INTERNAL PROCESS */

		if (i_entity_origination == ENT_CC) {
			ets_internal_process ();
		}
	}

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ets_internal_process - (for individual terminals in multipoint
					configuration only)
Usage          	uchar ets_internal_process ();


Common constants and declarations : ns.h

Common objects	call current context,
				message current context.

*--------------------------------------------------------------------------*/

void ets_internal_process ()
{

	switch (event_id) {

		case DA_STATUS :
		case DA_STATUS_ENQ :

			/*	these events may be received in any call state :
				they are processed in circuit-switched-call-n() */

			return;
	}

	if (Call_current_exist && Dl_current_exist) {

			/* Internal state are meaningful for outgoing calls only */

		if (Call_ces_setup != DL_CES_BROADCAST) return;

		switch (Call_int_state) {

			case STATE_0_I :
				ets_n0i ();
				break;

			case STATE_7_I :
				ets_n7i ();
				break;

			case STATE_8_I :
				ets_n8i ();
				break;

			case STATE_9_I :
				ets_n9i ();
				break;

			case STATE_19_I :
				ets_n19i ();
				break;

			case STATE_25_I :
				ets_n25i ();
				break;

			default :

				/* Unknown state --> Trap */

				Trap (TRAP_UNKNOWN_CALL_STATE, "ets_circuit_switched_call_n");
				break;
		}

		switch (event_id) {	/* shall be done after the state-specific treatment */

			case INT_REL_RQ :
				Stop_int_timer  (CURRENT_INT_TIMER);
				Start_int_timer (ETS_T308I);
				Send_to_d_channel_and_save_spdu (REL);
				Set_int_ces_state (STATE_19_I);
				event_id = EV_NIL;
				break;
		}
	}

}

/*-------------------------------------------------------------------------*/

void ets_send_to_ces (ev_id, ie_flag, the_ces)

	uchar 		ev_id;				/* event_id */
	uchar       ie_flag;            /* ON : use current cause, OFF : forced cause */
	uchar		the_ces;
{
	switch (ev_id) {

		case REL :

			if (Call_int_ces_state(the_ces) == STATE_19_I) {

				/* do not send RELEASE if individual process is in state 19 */

				break;
			}
				/* Cause forced ? */

			if (ie_flag == OFF) {
				Reset_internal_ie   ();
				set_i_cause         (C_C_NORMAL_EVENT, C_V_NON_SELECTED_USER_CLEARING_26, P_NIL);
			}

				/* Send RELEASE to the terminal on the_ces */

			Ns_access_dl_ces    (Ces_from_x (the_ces));
			Stop_int_timer 		(CURRENT_INT_TIMER);
			Start_int_timer		(ETS_T308I);
			Send_to_d_channel   (REL);
			Set_int_ces_state 	(STATE_19_I);

		break;

		case INFO :
			Send_to_d_channel (INFO);
			break;
	}
}

/*-------------------------------------------------------------------------*/

void ets_send_to_other_ces (ev_id, ie_flag)

	uchar 		ev_id;				/* event_id */
	uchar       ie_flag;            /* ON : use current cause, OFF : forced cause */
{
	register    uchar the_ces;		/* index */

	for (the_ces = 0; the_ces < DL_MX_DLCEP; the_ces++) {

		if ((Ces_from_x (the_ces) != Call_ces) &&
			(Call_int_ces_state(the_ces) != STATE_0_I)) {

			ets_send_to_ces (ev_id, ie_flag, the_ces);
		}
	}

		/* Restore initial dl context */

	Ns_access_dl_ces (Call_ces);
}

/*-------------------------------------------------------------------------*/

uchar ets_nb_other_active_ces ()
{
	uchar	the_ces;	/* index */
	uchar	active_ces;	/* nb of terminal with Call_alert == ON except the one on current ces */

	active_ces = 0;

	for (the_ces = 0; the_ces < DL_MX_DLCEP; the_ces++) {

		if ((Call_alert (the_ces) == ON) && (Ces_from_x (the_ces) != Dl_ces)) {
			active_ces++;
		}
	}

	return (active_ces);
}

/*-------------------------------------------------------------------------*/

uchar ets_nb_active_ces ()
{
	uchar	the_ces;	/* index */
	uchar	active_ces;	/* nb of terminal with Call_alert == ON */

	active_ces = 0;

	for (the_ces = 0; the_ces < DL_MX_DLCEP; the_ces++) {

		if (Call_alert (the_ces) == ON) {
			active_ces++;
		}
	}

	return (active_ces);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            	ets_csc_dl_reinit_n () - implements the circuit switched call
									   circuit process after an unexpected
									   restart of the data link (DL_EST_IN).

Usage           	void ets_csc_dl_reinit_n ();


Common constants and declarations : ns.h

Common objects :    all the call contexts of the current NA, and the
					current DL context.

*--------------------------------------------------------------------------*/

void ets_csc_dl_reinit_n ()
{

	ns_access_first_call ();

	while (Call_current_exist) {

			/* Only the Call using the current DL */

		if (Call_ces == Dl_ces) {

			switch (Call_state) {


				case STATE_OVERLAP_SENDING_2 	:
				case STATE_OVERLAP_RECEIVING_25 :
					ns_stop_all_timers ();
					set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, P_NIL);
					Send_to_d_channel (DISC);
					Set_state (STATE_DISCONNECT_INDICATION_12);
					Start_timer_ns (ETS_T305);

#				if NS_SUPP_SERVICES == ON

					case STATE_CALL_INDEPENDENT_31 :

						set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, P_NIL);
						Send_to_d_channel (REL_COMP);
						Send_to_call_control (NS_CLEAR_CO);
						call_clear ();
						break;
#				endif

				default :
					break;


			}

		}

		ns_access_next_call ();
	}

}

#endif

/*EOF*/

