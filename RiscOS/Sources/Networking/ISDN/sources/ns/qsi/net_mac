/*-------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_mac.qsi
 *
 * $Revision$
 *
 * $Date$
 *
 * Header source, implementing the ISDN_BRICKS macro interface.
 *
 *------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/


/*------------------------------------------------------------------------*/


			/*
			  Isdn_init_qsi_ctx_???? = initialization of the common context
									 used by a primitive macro :

					INPUT :
						- pr 	 = primitive ID,
						- p_off  = pointer to the offset area,

			*/

#if NS_IE_TSP_OUT == ON
#	define Isdn_init_qsi_ctx_rq_rs_tsp(pr, p_off, data_lg)	Isdn_init_ctx_rq_rs_tsp(Paste(qsi_,pr), p_off, data_lg)
#endif

#define Isdn_init_qsi_ctx_rq_rs(pr, p_off)	Isdn_init_ctx_rq_rs(Paste(qsi_,pr), p_off)
#define Isdn_init_qsi_ctx_in_co(p_off)		Isdn_init_ctx_in_co(p_off)

/*------------------------------------------------------------------------*/

#define	Get_ie_qsi(pr,ie)					Get_ie 			(Paste(qsi_,pr), Paste (qsi_, ie))
#define	Isdn_get_val_qsi(pr,ie,fld)			Isdn_get_val	(Paste(qsi_,pr), Paste (qsi_, ie), fld)
#define Isdn_p_str_qsi(pr,ie,fld)			Isdn_p_str		(Paste(qsi_,pr), Paste (qsi_, ie), fld)
#define	Isdn_lgth_str_qsi(pr,ie,fld)		Isdn_lgth_str	(Paste(qsi_,pr), Paste (qsi_, ie), fld)
#define	Isdn_mx_lgth_str_qsi(pr,ie,fld)		Isdn_mx_lgth_str(Paste(qsi_,pr), Paste (qsi_, ie), fld)
#define	P_start_val_ns_qsi(pr,ie)			P_start_val_ns	(Paste(qsi_,pr), Paste (qsi_, ie))
#define	P_val_ns_qsi(ie)					P_val_ns		(Paste(qsi_,ie))
#define Set_offset_qsi(pr,ie)				Set_offset		(Paste(qsi_,pr),Paste(qsi_,ie))
#define	Set_next_ie_qsi(ie)					Set_next_ie		(Paste(qsi_,ie))
#define	Set_val_qsi(ie,fld,val)				Set_val			(Paste(qsi_,ie), fld, val)
#define	Set_val_nil_qsi(ie)					Set_val_nil		(Paste(qsi_,ie))
#define Set_str_qsi(ie, lv, p_str, mx_sz)	Set_str			(Paste(qsi_,ie), lv, p_str, mx_sz)
#define Set_mem_qsi(ie, lv, p_mem, sz)		Set_mem			(Paste(qsi_,ie), lv, p_mem, sz)
#define Set_to_next_ie_instance_qsi(pr,ie)	Set_to_next_ie_instance (Paste(qsi_,pr), Paste (qsi_, ie))
#define Get_remaining_ie_instance_nb_qsi(pr,ie,p_ie)	Get_remaining_ie_instance_nb (Paste(qsi_,pr), Paste (qsi_, ie), p_ie)

#if MESSAGE_HEADER_IE == ON
#	define Message_header_offset_qsi	ns_offset_t qsi_message_header;
#else
#	define Message_header_offset_qsi
#endif

#if NS_IE_TSP_OUT == ON
#	define Set_ns_offset_tsp_qsi(pr,ie)		Set_ns_offset_tsp	(Paste(qsi_,pr),Paste(qsi_,ie))
#	define Set_mem_eob_qsi(ie,lv,p_mem,sz)	Set_mem_eob		(Paste(qsi_,ie), lv, p_mem, sz)
#endif

/*------------------------------------------------------------------------*/
				/*
				   MACROs and DECLARATIONS used to access the Network
				   Signalling entity (NS) from the user Layer 4 Signalling
				   entity (L4S).
				*/

		/* Structures of the offset area of each primitive interfaces */

		/******************************************************
		**     Each offset is a relative pointer on the      **
		**     data of an IE element                         **
		******************************************************/

/*================   	CALL  ESTABLISHMENT  MESSAGES    =================*/

		/* NS_ALERT_RQ */

struct off_ns_qsi_te_alert_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_party_category;		/* party category */
};

typedef struct off_ns_qsi_te_alert_rq		off_ns_qsi_alert_rq;
typedef struct off_ns_qsi_te_alert_rq		off_ns_qsi_net_alert_in;

		/* NS_ALERT_IN */

struct off_ns_qsi_te_alert_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_party_category;		/* party category */
};

typedef struct off_ns_qsi_te_alert_in		off_ns_qsi_net_alert_rq;
typedef struct off_ns_qsi_te_alert_in		off_ns_qsi_alert_in;

		/* NS_CALL_PROC_RQ */

struct off_ns_qsi_te_call_proc_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID */
};

typedef struct off_ns_qsi_te_call_proc_rq	off_ns_qsi_call_proc_rq;
typedef struct off_ns_qsi_te_call_proc_rq	off_ns_qsi_net_call_proc_in;

		/* NS_CALL_PROC_IN */

struct off_ns_qsi_te_call_proc_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID */
};

typedef struct off_ns_qsi_te_call_proc_in	off_ns_qsi_net_call_proc_rq;
typedef struct off_ns_qsi_te_call_proc_in	off_ns_qsi_call_proc_in;

		/* NS_CONN_RQ */

struct off_ns_qsi_te_conn_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_sending_complete;	/* sending complete */
	ns_offset_t qsi_bc;					/* bearer capability */
	ns_offset_t qsi_chan_id;			/* channel ID */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_calling_nb;			/* calling number */
	ns_offset_t qsi_conn_sub_add;		/* connected sub-address */
	ns_offset_t qsi_calling_sub_add;	/* calling sub-address */
	ns_offset_t qsi_called_nb;			/* called number */
	ns_offset_t qsi_called_sub_add;		/* called sub-address */
	ns_offset_t qsi_llc;				/* low layer compatibility */
	ns_offset_t qsi_hlc;				/* high layer compability */
	ns_offset_t qsi_transit_counter;	/* transit counter */
	ns_offset_t qsi_party_category;		/* party category */
};

typedef struct off_ns_qsi_te_conn_rq		off_ns_qsi_conn_rq;
typedef struct off_ns_qsi_te_conn_rq		off_ns_qsi_net_conn_in;

		/* NS_CONN_IN */

struct off_ns_qsi_te_conn_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_sending_complete;	/* sending complete */
	ns_offset_t qsi_bc;					/* bearer capability */
	ns_offset_t qsi_chan_id;			/* channel ID */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_calling_nb;			/* calling number */
	ns_offset_t qsi_conn_sub_add;		/* connected sub-address */
	ns_offset_t qsi_calling_sub_add;	/* calling sub-address */
	ns_offset_t qsi_called_nb;			/* called number */
	ns_offset_t qsi_called_sub_add;		/* called sub-address */
	ns_offset_t qsi_llc;				/* low layer compatibility */
	ns_offset_t qsi_hlc;				/* high layer compability */
	ns_offset_t qsi_transit_counter;	/* transit counter */
	ns_offset_t qsi_party_category;		/* party category */
};

typedef struct off_ns_qsi_te_conn_in		off_ns_qsi_net_conn_rq;
typedef struct off_ns_qsi_te_conn_in		off_ns_qsi_conn_in;

		/* NS_CONN_RS (CONN) */

struct off_ns_qsi_te_conn_rs {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID included for support of Annex D */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_conn_nb;			/* connected number */
	ns_offset_t qsi_conn_sub_add;		/* connected sub-address */
	ns_offset_t qsi_llc;				/* low layer capability */
	ns_offset_t qsi_party_category;		/* party category */
};

typedef struct off_ns_qsi_te_conn_rs		off_ns_qsi_conn_rs;
typedef struct off_ns_qsi_te_conn_rs		off_ns_qsi_net_conn_co;

		/* NS_CONN_CO (CONN or CONN_ACK) */

struct off_ns_qsi_te_conn_co {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID included for support of Annex D */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_conn_nb;			/* connected number */
	ns_offset_t qsi_conn_sub_add;		/* connected sub-address */
	ns_offset_t qsi_llc;				/* low layer capability */
	ns_offset_t qsi_party_category;		/* party category */
};

typedef struct off_ns_qsi_te_conn_co		off_ns_qsi_net_conn_rs;
typedef struct off_ns_qsi_te_conn_co		off_ns_qsi_conn_co;

		/* NS_PROGRESS_RQ */

struct off_ns_qsi_te_progress_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_cause;				/* cause */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
};

typedef struct off_ns_qsi_te_progress_rq	off_ns_qsi_progress_rq;
typedef struct off_ns_qsi_te_progress_rq	off_ns_qsi_net_progress_in;

		/* NS_PROGRESS_IN */

struct off_ns_qsi_te_progress_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_cause;				/* cause */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_progress_ind;		/* progress indicator */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
};

typedef struct off_ns_qsi_te_progress_in	off_ns_qsi_net_progress_rq;
typedef struct off_ns_qsi_te_progress_in	off_ns_qsi_progress_in;

		/* NS_SETUP_ACK_RQ */

struct off_ns_qsi_te_setup_ack_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID */
};

typedef struct off_ns_qsi_te_setup_ack_rq	off_ns_qsi_setup_ack_rq;
typedef struct off_ns_qsi_te_setup_ack_rq	off_ns_qsi_net_setup_ack_in;

		/* NS_SETUP_ACK_IN */

struct off_ns_qsi_te_setup_ack_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel ID */
};

typedef struct off_ns_qsi_te_setup_ack_in	off_ns_qsi_net_setup_ack_rq;
typedef struct off_ns_qsi_te_setup_ack_in	off_ns_qsi_setup_ack_in;

/*=====================    CALL  CLEARING  MESSAGES    =======================*/

		/* NS_CLEAR_RQ */

struct off_ns_qsi_te_clear_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_cause;				/* cause */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
};

typedef struct off_ns_qsi_te_clear_rq		off_ns_qsi_clear_rq;
typedef struct off_ns_qsi_te_clear_rq		off_ns_qsi_net_clear_in;

		/* NS_CLEAR_IN */

struct off_ns_qsi_te_clear_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_cause;				/* cause */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
};

typedef struct off_ns_qsi_te_clear_in		off_ns_qsi_net_clear_rq;
typedef struct off_ns_qsi_te_clear_in		off_ns_qsi_clear_in;

		/* NS_CLEAR_RS */

struct off_ns_qsi_te_clear_rs {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_cause;				/* cause */
	ns_offset_t qsi_facility;			/* facility */
};

typedef struct off_ns_qsi_te_clear_rs		off_ns_qsi_clear_rs;
typedef struct off_ns_qsi_te_clear_rs		off_ns_qsi_net_clear_co;

		/* NS_CLEAR_CO */

struct off_ns_qsi_te_clear_co {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_cause;				/* cause */
	ns_offset_t qsi_facility;			/* facility */
};

typedef struct off_ns_qsi_te_clear_co		off_ns_qsi_net_clear_rs;
typedef struct off_ns_qsi_te_clear_co		off_ns_qsi_clear_co;

/*====================    	MISCELLANEOUS  MESSAGES    =======================*/

		/* NS_INFO_RQ */

struct off_ns_qsi_te_info_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_sending_complete;	/* sending complete */
	ns_offset_t qsi_called_nb;			/* called number */
};

typedef struct off_ns_qsi_te_info_rq		off_ns_qsi_info_rq;
typedef struct off_ns_qsi_te_info_rq		off_ns_qsi_net_info_in;

		/* NS_INFO_IN */

struct off_ns_qsi_te_info_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_sending_complete;	/* sending complete */
	ns_offset_t qsi_called_nb;			/* called number */
};

typedef struct off_ns_qsi_te_info_in		off_ns_qsi_net_info_rq;
typedef struct off_ns_qsi_te_info_in		off_ns_qsi_info_in;

		/* NS_RESTART_RQ */

struct off_ns_qsi_te_restart_rq {
	Message_header_offset_qsi				/* message header parameters */

#	if MESSAGE_HEADER_IE != ON
		ns_offset_t ie_nil;					/* or no IE */
#	endif

};

typedef struct off_ns_qsi_te_restart_rq		off_ns_qsi_restart_rq;
typedef struct off_ns_qsi_te_restart_rq		off_ns_qsi_net_restart_in;

		/* NS_RESTART_RS */

struct off_ns_qsi_te_restart_rs {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel identifier */
	ns_offset_t qsi_restart_ind;		/* restart indicator */
};

typedef struct off_ns_qsi_te_restart_rs		off_ns_qsi_restart_rs;
typedef struct off_ns_qsi_te_restart_rs		off_ns_qsi_net_restart_co;

		/* NS_RESTART_IN */

struct off_ns_qsi_te_restart_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel identifier */
	ns_offset_t qsi_restart_ind;		/* restart indicator */
};

typedef struct off_ns_qsi_te_restart_in		off_ns_qsi_net_restart_rq;
typedef struct off_ns_qsi_te_restart_in		off_ns_qsi_restart_in;

		/* NS_RESTART_CO */

struct off_ns_qsi_te_restart_co {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_chan_id;			/* channel identifier */
	ns_offset_t qsi_restart_ind;		/* restart indicator */
};
typedef struct off_ns_qsi_te_restart_co		off_ns_qsi_net_restart_rs;
typedef struct off_ns_qsi_te_restart_co		off_ns_qsi_restart_co;

		/* NS_STATUS_ENQ_RQ */

struct off_ns_qsi_te_status_enq_rq {
	Message_header_offset_qsi			/* message header parameters */

#	if MESSAGE_HEADER_IE != ON
		ns_offset_t ie_nil;					/* or no IE */
#	endif

};

typedef struct off_ns_qsi_te_status_enq_rq	off_ns_qsi_status_enq_rq;
typedef struct off_ns_qsi_te_status_enq_rq	off_ns_qsi_net_status_enq_in;

		/* NS_FAC_RQ */

struct off_ns_qsi_te_fac_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_calling_nb;			/* calling number */
	ns_offset_t qsi_called_nb;			/* called number */
};

typedef struct off_ns_qsi_te_fac_rq			off_ns_qsi_fac_rq;
typedef struct off_ns_qsi_te_fac_rq			off_ns_qsi_net_fac_in;

		/* NS_FAC_CO */

struct off_ns_qsi_te_fac_co {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_facility;			/* facility */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
	ns_offset_t qsi_calling_nb;			/* calling number */
	ns_offset_t qsi_called_nb;			/* called number */
};

typedef struct off_ns_qsi_te_fac_co			off_ns_qsi_net_fac_rs;
typedef struct off_ns_qsi_te_fac_co			off_ns_qsi_fac_co;

		/* NS_NOTIFY_RQ */

struct off_ns_qsi_te_notify_rq {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
};

typedef struct off_ns_qsi_te_notify_rq		off_ns_qsi_notify_rq;
typedef struct off_ns_qsi_te_notify_rq		off_ns_qsi_net_notify_in;

		/* NS_NOTIFY_IN */

struct off_ns_qsi_te_notify_in {
	Message_header_offset_qsi			/* message header parameters */
	ns_offset_t qsi_notif_ind;			/* notify indicator */
};

typedef struct off_ns_qsi_te_notify_in		off_ns_qsi_net_notify_rq;
typedef struct off_ns_qsi_te_notify_in		off_ns_qsi_notify_in;

		/******************************************************
		**    DESCRIPTION of the value of an IE.             **
		**    ---------------------------------              **
		**    EACH ENTRY SHALL BE IN ACCORDANCE WITH THE     **
		**    CORRESPONDING SSDU IE META-PROGRAM             **
		**			                                         **
		******************************************************/

		/* Bearer Capability (BC) */

struct val_ns_qsi_bc {
	Next_instance_offset
	ie_val		coding_std;				/* coding standard */
	ie_val		trf_cap;				/* information transfer capability */
	ie_val		trf_rate;				/* information transfer rate */
	ie_val		protocol_id_1;			/* user information layer 1 protocol */
	ie_val		syn_asyn;				/* synchronous/asynchronous */
	ie_val		negotiation;			/* negotiation */
	ie_val		user_rate;				/* user rate */
	ie_val		inter_rate;				/* intermediate rate */
	ie_val		nic_tx;					/* network independent clock (NIC) on Transmission (Tx) */
	ie_val		nic_rx;					/* network independent clock (NIC) on Reception (Rx) */
	ie_val		fc_tx;					/* flow control on Transmission (Tx) */
	ie_val		fc_rx;					/* flow control on Reception (Rx) */
	ie_val		hdr;					/* rate adaption header included or not */
	ie_val		multi_frame;			/* multiple frame establishement support in DL */
	ie_val		op_mode;				/* mode of operation */
	ie_val		lli_negot;				/* logical link identifier negotiation */
	ie_val		assign;					/* assignor/assignee */
	ie_val		band_negot;				/* in-band/out-band negotiation */
	ie_val		stop_bit;				/* number of stop bits */
	ie_val		data_bit;				/* number of data bits */
	ie_val		parity;					/* number of parity bit */
	ie_val		duplex;					/* duplex mode */
	ie_val		modem;					/* modem type */
	ie_val		protocol_id_2;			/* user information layer 2 protocol */
	ie_val		protocol_id_3;			/* user information layer 3 protocol */

};

		/* Called party number (CALLED_NB) */

struct val_ns_qsi_called_nb {
	Next_instance_offset
	ie_val   	nb_type;				/* numbering type */
	ie_val	 	plan_id;				/* numbering plan ID */
	ie_array 	nb[QSI_MX_SZ_CALLED_NB+2];	/* called number digits */
};

		/* Called party subaddress (CALLED_SUB_ADD) */

struct val_ns_qsi_called_sub_add {
	Next_instance_offset
	ie_val		sub_add_type;			/* called subaddress type */
	ie_val		odd_even_ind;			/* odd/even indicator */
	ie_array 	sub_add[QSI_MX_SZ_CALLED_SUB_ADD+2];	/* sub-add information */
};

		/* Calling party number (CALLING_NB) */

struct val_ns_qsi_calling_nb {
	Next_instance_offset
	ie_val  	nb_type;				/* numbering type */
	ie_val		plan_id;				/* numbering plan ID */
	ie_val		pres;					/* presentation indicator */
	ie_val		screen_ind;				/* screening indicator */
	ie_array 	nb[QSI_MX_SZ_CALLING_NB+2];	/* calling number digits */
};

		/* Calling party subaddress (CALLING_SUB_ADD) */

struct val_ns_qsi_calling_sub_add {
	Next_instance_offset
	ie_val  	sub_add_type;			/* calling subaddress type */
	ie_val		odd_even_ind;			/* odd/even indicator */
	ie_array 	sub_add[QSI_MX_SZ_CALLING_SUB_ADD+2];	/* sub-add information */
};

		/* Cause (CAUSE) */

struct val_ns_qsi_cause {
	Next_instance_offset
	ie_val		cause_loc;				/* location */
	ie_val 		cause_class;			/* cause class field */
	ie_val		cause_val;				/* cause value field */
	ie_array	cause_diag[QSI_MX_SZ_CAUSE_DIAG+2];	/* diagnostics */
};

		/* Channel ID (CHAN_ID) */

struct val_ns_qsi_chan_id {
	Next_instance_offset
	ie_val 		int_type;				/* interface type */
	ie_val 		pref_excl;				/* preferred or exclusive channel */
	ie_val		d_chan;					/* D-channel indicator */
	ie_val 		chan_sel;				/* information channel selection */
	ie_array	chan_nb[QSI_MX_SZ_CHAN_ID+2];	/* channel number */
};

		/* Connected party number (CONN_NB) */

struct val_ns_qsi_conn_nb {
	Next_instance_offset
	ie_val  	nb_type;				/* numbering type */
	ie_val		plan_id;				/* numbering plan ID */
	ie_val		pres;					/* presentation indicator */
	ie_val		screen_ind;				/* screening indicator */
	ie_array 	nb[QSI_MX_SZ_CONN_NB+2];	/* conn number digits */
};

		/* Connected party subaddress (CONN_SUB_ADD) */

struct val_ns_qsi_conn_sub_add {
	Next_instance_offset
	ie_val  	sub_add_type;			/* conn subaddress type */
	ie_val		odd_even_ind;			/* odd/even indicator */
	ie_array 	sub_add[QSI_MX_SZ_CONN_SUB_ADD+2];	/* sub-add information */
};

		/* High Layer Compatibility (HLC) */

struct val_ns_qsi_hlc {
	Next_instance_offset
	ie_val		coding_std;					/* coding standard */
	ie_val		teleservice;				/* high layer characteristics identification */
	ie_val		ext_teleservice;			/* extended high layer characteristics identification */
};

		/* Low Layer Compatibility (LLC) */

struct val_ns_qsi_llc {
	Next_instance_offset
	ie_val		coding_std;				/* coding standard */
	ie_val		trf_cap;				/* information transfer capability */
	ie_val		out_band_neg;			/* out-band negotiation */
	ie_val		trf_mode;				/* transfer mode */
	ie_val		trf_rate;				/* information transfer rate */
	ie_val		structure;				/* structure */
	ie_val		dest_rate;				/* destination rate */
	ie_val		protocol_id_1;			/* user information layer 1 protocol */
	ie_val		syn_asyn;				/* synchronous/asynchronous */
	ie_val		negotiation;			/* negotiation */
	ie_val		user_rate;				/* user rate */
	ie_val		inter_rate;				/* intermediate rate */
	ie_val		nic_tx;					/* network independent clock on transmission (Tx) */
	ie_val		nic_rx;					/* network independent clock on reception (Rx) */
	ie_val		fc_tx;					/* flow control on transmission (Tx) */
	ie_val		fc_rx;					/* flow control on reception (Rx) */
	ie_val		hdr;					/* rate adaption header included or not */
	ie_val		multi_frame;			/* multiple frame establishement support in DL */
	ie_val		op_mode;				/* mode of operation */
	ie_val		lli_negot;				/* logical link identifier negotiation */
	ie_val		assign;					/* assignor/assignee */
	ie_val		band_negot;				/* in-band/out-band negotiation */
	ie_val		stop_bit;				/* number of stop bits */
	ie_val		data_bit;				/* number of data bits excluding parity if present */
	ie_val		parity;					/* parity information */
	ie_val		duplex;					/* duplex mode */
	ie_val		modem;					/* modem type */
	ie_val		protocol_id_2;			/* user layer 2 protocol information */
	ie_val		option_2;				/* optional layer 2 protocol information */
	ie_val		protocol_id_3;			/* user information layer 3 protocol */
	ie_val		option_3;				/* optional layer 3 protocol information */
};

		/* Progress indicator (PROGRESS_IND) */

struct val_ns_qsi_progress_ind {
	Next_instance_offset
	ie_val		coding_std;				/* coding standard */
	ie_val		progress_loc;			/* location */
	ie_val		progress_descr;			/* progress description */
};

		/* Restart indicator (RESTART_IND) */

struct val_ns_qsi_restart_ind {
	Next_instance_offset
	ie_val		restart_class;			/* class */
};

		/* Party category (PARTY_CATEGORY) */

struct val_ns_qsi_party_category {
	Next_instance_offset
	ie_val		category;               /* party category */
};

		/* Transit counter (TRANSIT_COUNTER) */

struct val_ns_qsi_transit_counter {
	Next_instance_offset
	ie_val		count;					/* transit count */
};

#if NS_SUPP_SERVICES == OFF

struct val_ns_qsi_facility {
	Next_instance_offset
	ie_array info[QSI_MX_SZ_FACILITY+2];
};

#else

struct val_ns_qsi_facility {
	Next_instance_offset
	ushort					size;				/* total size of Facility IE in SSDU */

		/*	NetworkFacilityExtension : if first field 'nfe_source' is BYTE_VAL_NIL,
		 *	it is absent and all other fields until 'nfe_dest_add_sz' are not significant.
		 *	The values for 'Type of PartyNumber' and 'Type of Number' fields are defined
		 *	in ns_ssint.h file : they are the same as for ETSI supplementary services and
		 *	'Type of Number' is meaningless if 'Type of PartyNumber' is not "PUBLIC" or "PRIVATE".
		 */
	uchar					nfe_source;			/* type of source entity inside NetworkFacilityExtension */
	uchar					nfe_source_p_nb_t;	/* type of PartyNumber in source entity address inside NetworkFacilityExtension */
	uchar					nfe_source_t_of_nb;	/* type of Number in source entity address inside NetworkFacilityExtension */
	uchar					nfe_source_add_sz;	/* size of source entity address string inside NetworkFacilityExtension */
	uchar					nfe_dest;			/* type of destination entity inside NetworkFacilityExtension */
	uchar					nfe_dest_p_nb_t;	/* type of PartyNumber in destination entity address inside NetworkFacilityExtension */
	uchar					nfe_dest_t_of_nb;	/* type of Number in destination entity address inside NetworkFacilityExtension */
	uchar					nfe_dest_add_sz;	/* size of destination entity address size inside NetworkFacilityExtension */

	uchar					interpretation;		/* InterpretationApdu or BYTE_VAL_NIL if absent */
	uchar					component_nb;		/* total number of components in IE : 1 for each RoseAPDU (that is not itself included in a DseAPDU), n for each DseAPDU */
	ushort					first_apdu_offset;	/* offset of first APDU contained in Facility IE */
	uchar					nfe_first_add;		/* first digit of source entity address inside NetworkFacilityExtension */
	/*	Here are :
		1) strings contained in address of source and destination entities inside NetworkFacilityExtension,

		2) data specific to each APDU, starting at location indicated by "first_apdu_offset" :
			- first octet indicates "type of APDU" = RoseAPDU or DseAPDU
			- structure of data is "ns_ss_qsi_rose_apdu" or "ns_ss_qsi_dse_apdu" according to type of APDU
	*/
};

struct ns_ss_qsi_rose_apdu {
	uchar					apdu_type;						/* type of APDU = RoseAPDU */
	struct ns_ss_fac_comp	component;                  	/* common data of component as described in ns_ssint.h */
};

struct ns_ss_qsi_dse_apdu {
	uchar					apdu_type;						/* type of APDU = DseAPDU */
	uchar					dse_pdu_type;					/* type of DseAPDU = Begin / End / Continue / Abort */
	uchar					orig_dialog_or_abort_info_sz;	/* size of originationDialogID string or UserAbortInformation string (in AbortPDU) */
	uchar					destination_dialog_sz;			/* size of destinationDialogID string */
	uchar					p_abort_cause;					/* P_AbortCause inside AbortPDU or meaningless */
	uchar					component_nb;					/* number of RoseAPDUs (components) contained inside DseAPDU (RemoteOperationsPortion) */
	ushort					first_comp_offset;				/* offset of first component (RoseAPDU) inside DseAPDU or 0 */
	uchar					first_str;						/* first octet of first dialogID string inside DseAPDU */
};

#endif

struct val_ns_qsi_notif_ind {
	Next_instance_offset
	ie_val		notif_descr;
	ie_array    info[QSI_MX_SZ_NOTIF_IND+2];
};

#if NS_IE_TSP_OUT == ON

			/* Definitions for compilation purpose only */

	struct val_ns_qsi_sending_complete {
		Next_instance_offset
		ie_val	unused;
	};


#endif

/*=========================================================================*/

							/* Information Elements (IE) */




		/*
		   Isdn_qsi_store_bc : store the bearer capability information
							   element :

				INPUT :
					- pr			= primitive ID,
					- coding_		= coding standard,
					- trf_cap_		= information transfer capability,
					- trf_rate_		= information transfer rate,
					- protocol_id_1_= user information layer 1 protocol,
					- syn_asyn_		= synchronous/asynchronous,
					- negotiation_	= negotiation,
					- user_rate_	= user rate,
					- inter_rate_	= intermediate rate,
					- nic_tx_		= network independent clock (NIC) on Transmission (Tx),
					- nic_rx_		= network independent clock (NIC) on Reception (Rx),
					- fc_tx_		= flow control on Transmission (Tx),
					- fc_rx_		= flow control on Reception (Rx),
					- hdr_			= rate adaption header included or not,
					- multi_frame_	= multiple frame establishement support in DL,
					- op_mode_		= mode of operation,
					- lli_negot_	= logical link identifier negotiation,
					- assign_		= assignor/assignee,
					- band_negot_	= in-band/out-band negotiation,
					- stop_bit_		= number of stop bits,
					- data_bit_		= number of data bits,
					- parity_		= number of parity bit,
					- duplex_		= duplex mode,
					- modem_		= modem type,
					- protocol_id_2_= user information layer 2 protocol,
					- protocol_id_3_= user information layer 3 protocol,

		*/

#define Isdn_qsi_store_bc(pr, coding_, trf_cap_, trf_rate_, protocol_id_1_, syn_asyn_, negotiation_, user_rate_, inter_rate_, nic_tx_, nic_rx_, fc_tx_, fc_rx_, hdr_, multi_frame_,	op_mode_, lli_negot_, assign_, band_negot_, stop_bit_, data_bit_, parity_, duplex_, modem_, protocol_id_2_, protocol_id_3_) \
			Set_offset_qsi	(pr,	bc);										\
			Set_val_qsi		(bc,	coding_std,		coding_);					\
			Set_val_qsi		(bc,	trf_cap,		trf_cap_);					\
			Set_val_qsi		(bc,	trf_rate,		trf_rate_);					\
			Set_val_qsi		(bc,	protocol_id_1,	protocol_id_1_);			\
			Set_val_qsi		(bc,	syn_asyn,		syn_asyn_);					\
			Set_val_qsi		(bc,	negotiation,	negotiation_);				\
			Set_val_qsi		(bc,	user_rate,		user_rate_);				\
			Set_val_qsi		(bc,	inter_rate,		inter_rate_);				\
			Set_val_qsi		(bc,	nic_tx,			nic_tx_);					\
			Set_val_qsi		(bc,	nic_rx,			nic_rx_);					\
			Set_val_qsi		(bc,	fc_tx,			fc_tx_);					\
			Set_val_qsi		(bc,	fc_rx,			fc_rx_);					\
			Set_val_qsi		(bc,	hdr,			hdr_);						\
			Set_val_qsi		(bc,	multi_frame,	multi_frame_);				\
			Set_val_qsi		(bc,	op_mode,		op_mode_);					\
			Set_val_qsi		(bc,	lli_negot,		lli_negot_);				\
			Set_val_qsi		(bc,	assign,			assign_);					\
			Set_val_qsi		(bc,	band_negot,		band_negot_);				\
			Set_val_qsi		(bc,	stop_bit,		stop_bit_);					\
			Set_val_qsi		(bc,	data_bit,		data_bit_);					\
			Set_val_qsi		(bc,	parity,			parity_);					\
			Set_val_qsi		(bc,	duplex,			duplex_);					\
			Set_val_qsi		(bc,	modem,			modem_);					\
			Set_val_qsi		(bc,	protocol_id_2,	protocol_id_2_);			\
			Set_val_qsi		(bc,	protocol_id_3,	protocol_id_3_);			\
			Set_next_ie_qsi	(bc)

/*-------------------------------------------------------------------------*/
		/*
		   Isdn_qsi_store_bc_CONNECTIONLESS : store the bearer capability information
												in a connectionless manner

				INPUT :
					- pr			= primitive ID,
		*/

#define Isdn_qsi_store_bc_CONNECTIONLESS(pr)							\
			Set_offset_qsi	(pr,	bc);								\
			Set_val_nil_qsi	(bc);										\
			Set_val_qsi		(bc,	coding_std,		CODING_STD_ECMA);	\
			Set_val_qsi		(bc,	trf_cap,		TRF_CAP_UNRESTRICTED);			\
			Set_val_qsi		(bc,	trf_rate,		TRF_RATE_INDEP_SIG_CONNECTION);	\
			Set_next_ie_qsi	(bc)

/*-------------------------------------------------------------------------*/
		/*
		   Isdn_qsi_store_bc_not_V110 : store the bearer capability information
										element for non V110 rate adaption :

				INPUT :
					- pr			= primitive ID,
					- trf_cap_		= information transfer capability,
					- protocol_id_1_= protocol id 1
					- protocol_id_2_= user information layer 2 protocol,
					- protocol_id_3_= user information layer 3 protocol,

		*/

#define Isdn_qsi_store_bc_not_V110(pr, trf_cap_, protocol_id_1_, protocol_id_2_, protocol_id_3_) \
	Isdn_qsi_store_bc	(pr,			CODING_STD_CCITT,					\
						trf_cap_,		TRF_RATE_64KBS,	protocol_id_1_,						\
						BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
						BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
						BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,       \
						BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
						BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
						BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
						BYTE_VAL_NIL,	protocol_id_2_,	protocol_id_3_)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_called_nb : called number IE

					INPUT :
						- pr				= primitive ID,
						- nb_type_			= numbering type,
						- plan_id_			= numbering plan,
						- nb_				= address of the literal string.
			*/

#define Isdn_qsi_store_called_nb(pr, nb_type_, plan_id_, nb_)					\
		Set_offset_qsi	(pr,		called_nb);										\
		Set_val_qsi		(called_nb,	nb_type,	nb_type_);							\
		Set_val_qsi		(called_nb,	plan_id,	plan_id_);							\
		Set_str_qsi		(called_nb,	nb,			nb_,		QSI_MX_SZ_CALLED_NB+1)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_called_sub_add : called sub-address IE

					INPUT :
						- pr			= primitive ID,
						- sub_add_type_	= subaddress type,
						- odd_even_ind_	= odd/even indicator,
						- sub_add_		= address of the literal string.

			*/

#define Isdn_qsi_store_called_sub_add(pr, sub_add_type_, odd_even_ind_,	sub_add_) \
		Set_offset_qsi	(pr,				called_sub_add);						\
		Set_val_qsi		(called_sub_add,	sub_add_type,	sub_add_type_);			\
		Set_val_qsi		(called_sub_add,	odd_even_ind,	odd_even_ind_);			\
		Set_str_qsi		(called_sub_add,	sub_add,		sub_add_, QSI_MX_SZ_CALLED_SUB_ADD+1)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_calling_nb : store calling number IE

					INPUT :
						- pr 				= primitive ID,
						- nb_type_		   	= numbering type,
						- plan_id_			= numbering plan ID,
						- pres_				= presentation indicator,
						- screen_ind_    	= screening indicator,
						- nb_				= pointer on the calling number literal string.
			*/

#define Isdn_qsi_store_calling_nb(pr, nb_type_, plan_id_, pres_, screen_ind_, nb_)	\
		Set_offset_qsi	(pr,			calling_nb);								\
		Set_val_qsi		(calling_nb,	nb_type, 		nb_type_);					\
		Set_val_qsi		(calling_nb,	plan_id, 		plan_id_);					\
		Set_val_qsi		(calling_nb,	pres,			pres_);						\
		Set_val_qsi		(calling_nb,	screen_ind, 	screen_ind_);				\
		Set_str_qsi		(calling_nb,	nb, 			nb_, QSI_MX_SZ_CALLING_NB+1)

/*-------------------------------------------------------------------------*/

			/*
				  Isdn_qsi_calling_sub_add : calling sub-address IE

						INPUT :
						- pr			= primitive ID,
						- sub_add_type_	= subaddress type,
						- odd_even_ind_	= odd/even indicator,
						- sub_add_		= address of the literal string.


			*/

#define Isdn_qsi_store_calling_sub_add(pr, sub_add_type_, odd_even_ind_, sub_add_) \
		Set_offset_qsi	(pr,				calling_sub_add);						\
		Set_val_qsi		(calling_sub_add,	sub_add_type, 	sub_add_type_);			\
		Set_val_qsi		(calling_sub_add,	odd_even_ind,	odd_even_ind_);			\
		Set_str_qsi		(calling_sub_add,	sub_add,		sub_add_, QSI_MX_SZ_CALLING_SUB_ADD+1)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_conn_nb : store conn number IE

					INPUT :
						- pr 				= primitive ID,
						- nb_type_		   	= numbering type,
						- plan_id_			= numbering plan ID,
						- pres_				= presentation indicator,
						- screen_ind_    	= screening indicator,
						- nb_				= pointer on the conn number literal string.
			*/

#define Isdn_qsi_store_conn_nb(pr, nb_type_, plan_id_, pres_, screen_ind_, nb_)	\
		Set_offset_qsi	(pr,			conn_nb);								\
		Set_val_qsi		(conn_nb,	nb_type, 		nb_type_);					\
		Set_val_qsi		(conn_nb,	plan_id, 		plan_id_);					\
		Set_val_qsi		(conn_nb,	pres,			pres_);						\
		Set_val_qsi		(conn_nb,	screen_ind, 	screen_ind_);				\
		Set_str_qsi		(conn_nb,	nb, 			nb_, QSI_MX_SZ_CONN_NB+1)

/*-------------------------------------------------------------------------*/

			/*
				  Isdn_qsi_conn_sub_add : conn sub-address IE

						INPUT :
						- pr			= primitive ID,
						- sub_add_type_	= subaddress type,
						- odd_even_ind_	= odd/even indicator,
						- sub_add_		= address of the literal string.


			*/

#define Isdn_qsi_store_conn_sub_add(pr, sub_add_type_, odd_even_ind_, sub_add_) \
		Set_offset_qsi	(pr,				conn_sub_add);						\
		Set_val_qsi		(conn_sub_add,	sub_add_type, 	sub_add_type_);			\
		Set_val_qsi		(conn_sub_add,	odd_even_ind,	odd_even_ind_);			\
		Set_str_qsi		(conn_sub_add,	sub_add,		sub_add_, QSI_MX_SZ_CONN_SUB_ADD+1)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_cause : cause IE

					INPUT :
						- pr			= primitive ID,
						- cause_loc_	= cause location,
						- cause_class_	= cause class,
						- cause_val_	= cause value,
						- cause_diag_	= cause diagnostic.

			*/

#define Isdn_qsi_store_cause(pr, cause_loc_, cause_class_, cause_val_, cause_diag_) \
		Set_offset_qsi	(pr,	cause);												\
		Set_val_qsi		(cause,	cause_loc,	cause_loc_);							\
		Set_val_qsi		(cause,	cause_class,cause_class_);							\
		Set_val_qsi		(cause,	cause_val,	cause_val_);							\
		Set_str_qsi		(cause,	cause_diag,	cause_diag_, QSI_MX_SZ_CAUSE_DIAG+1)

/*-------------------------------------------------------------------------*/
			/*
				 Isdn_qsi_store_chan_id_PRI : store channel ID IE

					INPUT :
						- pr 			= primitive ID,
						- pref_excl_	= preferred channel,
						- nb_			= channel number.
			*/

#define Isdn_qsi_store_chan_id_PRI(pr, pref_excl_, nb_) \
		Set_offset_qsi	(pr,		chan_id);							\
		Set_val_qsi		(chan_id,	int_type,	INT_TYPE_PRI);			\
		Set_val_qsi		(chan_id,	pref_excl,	pref_excl_);			\
		Set_val_qsi		(chan_id,	d_chan,		NOT_D_CHAN);			\
		Set_val_qsi		(chan_id,	chan_sel,	AS_INDICATED);			\
		Set_str_qsi		(chan_id,	chan_nb,	nb_, QSI_MX_SZ_CHAN_ID+1)


			/*
				 Isdn_qsi_store_chan_id_NO_CHAN : store channel ID IE
					without any channel (for connectionless mode use)

					INPUT :
						- pr 			= primitive ID,
			*/

#define Isdn_qsi_store_chan_id_NO_CHAN(pr)						\
		Set_offset_qsi	(pr,		chan_id);					\
		Set_val_qsi		(chan_id,	int_type,	INT_TYPE_PRI);	\
		Set_val_qsi		(chan_id,	pref_excl,	CHAN_EXCL);		\
		Set_val_qsi		(chan_id,	d_chan,		D_CHAN);		\
		Set_val_qsi		(chan_id,	chan_sel,	NO_CHAN);		\
		Set_str_qsi		(chan_id,	chan_nb,	P_NIL, 1)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_hlc : high layer compatibility for
										non-CCITT coding standard

					INPUT :
						- pr		= primitive ID,
						- std		= coding standard,
						- tele      = teleservice,
						- ext_tele	= extended teleservice.
			*/

#define Isdn_qsi_store_hlc(pr, std, tele, ext_tele)								\
		Set_offset_qsi	(pr,	hlc);												\
		Set_val_qsi		(hlc,	coding_std,			std);							\
		Set_val_qsi		(hlc,	teleservice,		tele);							\
		Set_val_qsi		(hlc,	ext_teleservice,	ext_tele);						\
		Set_next_ie_qsi	(hlc)

			/*
				Isdn_qsi_store_hlc_CCITT : high layer compatibility for
										CCITT coding standard

					INPUT :
						- pr		= primitive ID,
						- tele      = teleservice,
						- ext_tele	= extended teleservice.
			*/

#define Isdn_qsi_store_hlc_CCITT(pr, tele, ext_tele)							\
		Isdn_qsi_store_hlc	(pr, CODING_STD_CCITT, tele, ext_tele)

/*-------------------------------------------------------------------------*/

			/*
			   Isdn_qsi_store_llc : low layer compatibility

			   First definition : in one part :

					INPUT :
						- pr			= primitive ID,
						- coding_std_	= coding standard,
						- trf_cap_		= information transfer capability,
						- out_neg		= out band negotiation,
						- trf_mode_		= transfer mode,
						- trf_rate_		= information transfer rate,
						- structure_	= structure,
						- dest_rate_	= destination rate,
						- protocol_id_1_= user information layer 1 protocol,
						- syn_asyn_		= synchronous/asynchronous,
						- negotiation_	= negotiation,
						- user_rate_	= user rate,
						- inter_rate_	= intermediate rate,
						- nic_tx_		= network independent clock (NIC) on Transmission (Tx),
						- nic_rx_		= network independent clock (NIC) on Reception (Rx),
						- fc_tx_		= flow control on Transmission (Tx),
						- fc_rx_		= flow control on Reception (Rx),
						- hdr_			= rate adaption header included or not,
						- multi_frame_	= multiple frame establishement support in DL,
						- op_mode_		= mode of operation,
						- lli_negot_	= logical link identifier negotiation,
						- assign_		= assignor/assignee,
						- band_negot_	= in-band/out-band negotiation,
						- stop_bit_		= number of stop bits,
						- data_bit_		= number of data bits,
						- parity_		= number of parity bit,
						- duplex_		= duplex mode,
						- modem_		= modem type,
						- protocol_id_2_= user information layer 2 protocol,
						- option_2_		= optional layer 2 protocol information,
						- protocol_id_3_= user information layer 3 protocol,
						- option_3_		= optional layer 3 protocol information.
			*/

#define Isdn_qsi_store_llc(pr,coding_std_, trf_cap_, out_neg, trf_mode_, trf_rate_, structure_, dest_rate_,	protocol_id_1_,	syn_asyn_, negotiation_, user_rate_, inter_rate_, nic_tx_, nic_rx_, fc_tx_,	fc_rx_,	hdr_, multi_frame_,	op_mode_, lli_negot_, assign_, band_negot_, stop_bit_, data_bit_, parity_, duplex_,	modem_,	protocol_id_2_,	option_2_, protocol_id_3_, option_3_) \
		Set_offset_qsi	(pr,	llc);										\
		Set_val_qsi		(llc,	coding_std,		coding_std_);				\
		Set_val_qsi		(llc,	trf_cap,		trf_cap_);					\
		Set_val_qsi		(llc,	out_band_neg,	out_neg);					\
		Set_val_qsi		(llc,	trf_mode,		trf_mode_);					\
		Set_val_qsi		(llc,	trf_rate,		trf_rate_);					\
		Set_val_qsi		(llc,	structure,		structure_);				\
		Set_val_qsi		(llc,	dest_rate,		dest_rate_);				\
		Set_val_qsi		(llc,	protocol_id_1,	protocol_id_1_);			\
		Set_val_qsi		(llc,	syn_asyn,		syn_asyn_);					\
		Set_val_qsi		(llc,	negotiation,	negotiation_);				\
		Set_val_qsi		(llc,	user_rate,		user_rate_);				\
		Set_val_qsi		(llc,	inter_rate,		inter_rate_);				\
		Set_val_qsi		(llc,	nic_tx,			nic_tx_);					\
		Set_val_qsi		(llc,	nic_rx,			nic_rx_);					\
		Set_val_qsi		(llc,	fc_tx,			fc_tx_);					\
		Set_val_qsi		(llc,	fc_rx,			fc_rx_);					\
		Set_val_qsi		(llc,	hdr,			hdr_);						\
		Set_val_qsi		(llc,	multi_frame,	multi_frame_);				\
		Set_val_qsi		(llc,	op_mode,		op_mode_);					\
		Set_val_qsi		(llc,	lli_negot,		lli_negot_);				\
		Set_val_qsi		(llc,	assign,			assign_);					\
		Set_val_qsi		(llc,	band_negot,		band_negot_);				\
		Set_val_qsi		(llc,	stop_bit,		stop_bit_);					\
		Set_val_qsi		(llc,	data_bit,		data_bit_);					\
		Set_val_qsi		(llc,	parity,			parity_);					\
		Set_val_qsi		(llc,	duplex,			duplex_);					\
		Set_val_qsi		(llc,	modem,			modem_);					\
		Set_val_qsi		(llc,	protocol_id_2,	protocol_id_2_);			\
		Set_val_qsi		(llc,	option_2,		option_2_);					\
		Set_val_qsi		(llc,	protocol_id_3,	protocol_id_3_);			\
		Set_val_qsi		(llc,	option_3,		option_3_);					\
		Set_next_ie_qsi	(llc)



			/*--------------------------------------------*/


			/*
			   Isdn_qsi_store_llc : low layer compatibility

			   Second definition : DIVIDED IN 2 PARTS for compilers which
			   do not accept so many parameters in macros :

					Isdn_qsi_store_llc_1_4 : octet 1 to octet 4 included,

						INPUT :
							- pr			= primitive ID,
							- coding_std_	= coding standard,
							- trf_cap_		= information transfer capability,
							- out_neg		= out band negotiation,
							- trf_mode_		= transfer mode,
							- trf_rate_		= information transfer rate,
							- structure_	= structure,
							- dest_rate_	= destination rate,

					Isdn_qsi_store_llc_5_7 : octet 5 to octet 7 included,

						- protocol_id_1_= user information layer 1 protocol,
						- syn_asyn_		= synchronous/asynchronous,
						- negotiation_	= negotiation,
						- user_rate_	= user rate,
						- inter_rate_	= intermediate rate,
						- nic_tx_		= network independent clock (NIC) on Transmission (Tx),
						- nic_rx_		= network independent clock (NIC) on Reception (Rx),
						- fc_tx_		= flow control on Transmission (Tx),
						- fc_rx_		= flow control on Reception (Rx),
						- hdr_			= rate adaption header included or not,
						- multi_frame_	= multiple frame establishement support in DL,
						- op_mode_		= mode of operation,
						- lli_negot_	= logical link identifier negotiation,
						- assign_		= assignor/assignee,
						- band_negot_	= in-band/out-band negotiation,
						- stop_bit_		= number of stop bits,
						- data_bit_		= number of data bits,
						- parity_		= number of parity bit,
						- duplex_		= duplex mode,
						- modem_		= modem type,
						- protocol_id_2_= user information layer 2 protocol,
						- option_2_		= optional layer 2 protocol information,
						- protocol_id_3_= user information layer 3 protocol,
						- option_3_		= optional layer 3 protocol information.
			*/

#define Isdn_qsi_store_llc_1_4(pr,coding_std_, trf_cap_, out_neg, trf_mode_, trf_rate_, structure_, dest_rate_)\
		Set_offset_qsi	(pr,	llc);										\
		Set_val_qsi		(llc,	coding_std,		coding_std_);				\
		Set_val_qsi		(llc,	trf_cap,		trf_cap_);					\
		Set_val_qsi		(llc,	out_band_neg,	out_neg);					\
		Set_val_qsi		(llc,	trf_mode,		trf_mode_);					\
		Set_val_qsi		(llc,	trf_rate,		trf_rate_);					\
		Set_val_qsi		(llc,	structure,		structure_);				\
		Set_val_qsi		(llc,	dest_rate,		dest_rate_)

#define Isdn_qsi_store_llc_5_7(protocol_id_1_,	syn_asyn_, negotiation_, user_rate_, inter_rate_, nic_tx_, nic_rx_, fc_tx_,	fc_rx_,	hdr_, multi_frame_,	op_mode_, lli_negot_, assign_, band_negot_, stop_bit_, data_bit_, parity_, duplex_,	modem_,	protocol_id_2_,	option_2_, protocol_id_3_, option_3_) \
		Set_val_qsi		(llc,	protocol_id_1,	protocol_id_1_);			\
		Set_val_qsi		(llc,	syn_asyn,		syn_asyn_);					\
		Set_val_qsi		(llc,	negotiation,	negotiation_);				\
		Set_val_qsi		(llc,	user_rate,		user_rate_);				\
		Set_val_qsi		(llc,	inter_rate,		inter_rate_);				\
		Set_val_qsi		(llc,	nic_tx,			nic_tx_);					\
		Set_val_qsi		(llc,	nic_rx,			nic_rx_);					\
		Set_val_qsi		(llc,	fc_tx,			fc_tx_);					\
		Set_val_qsi		(llc,	fc_rx,			fc_rx_);					\
		Set_val_qsi		(llc,	hdr,			hdr_);						\
		Set_val_qsi		(llc,	multi_frame,	multi_frame_);				\
		Set_val_qsi		(llc,	op_mode,		op_mode_);					\
		Set_val_qsi		(llc,	lli_negot,		lli_negot_);				\
		Set_val_qsi		(llc,	assign,			assign_);					\
		Set_val_qsi		(llc,	band_negot,		band_negot_);				\
		Set_val_qsi		(llc,	stop_bit,		stop_bit_);					\
		Set_val_qsi		(llc,	data_bit,		data_bit_);					\
		Set_val_qsi		(llc,	parity,			parity_);					\
		Set_val_qsi		(llc,	duplex,			duplex_);					\
		Set_val_qsi		(llc,	modem,			modem_);					\
		Set_val_qsi		(llc,	protocol_id_2,	protocol_id_2_);			\
		Set_val_qsi		(llc,	option_2,		option_2_);					\
		Set_val_qsi		(llc,	protocol_id_3,	protocol_id_3_);			\
		Set_val_qsi		(llc,	option_3,		option_3_);					\
		Set_next_ie_qsi	(llc)


			/*--------------------------------------------*/


			/*
			   Isdn_qsi_store_llc_V110 : low layer compatibility for
											V110 rate adaption :

					INPUT :
						- pr			= primitive ID,
						- coding_std_	= coding standard,
						- trf_cap_		= information transfer capability,
						- out_neg		= out band negotiation,
						- trf_mode_		= transfer mode,
						- trf_rate_		= information transfer rate,
						- structure_	= structure,
						- dest_rate_	= destination rate,
						- syn_asyn_		= synchronous/asynchronous,
						- negotiation_	= negotiation,
						- user_rate_	= user rate,
						- inter_rate_	= intermediate rate,
						- nic_tx_		= network independent clock (NIC) on Transmission (Tx),
						- nic_rx_		= network independent clock (NIC) on Reception (Rx),
						- fc_tx_		= flow control on Transmission (Tx),
						- fc_rx_		= flow control on Reception (Rx),
						- stop_bit_		= number of stop bits,
						- data_bit_		= number of data bits,
						- parity_		= number of parity bit,
						- duplex_		= duplex mode,
						- modem_		= modem type,
						- protocol_id_2_= user information layer 2 protocol,
						- protocol_id_3_= user information layer 3 protocol,

			*/

#define Isdn_qsi_store_llc_V110(pr, coding_std_, trf_cap_, out_neg, trf_mode_, trf_rate_, structure_, dest_rate_, syn_asyn_, negotiation_, user_rate_, inter_rate_, nic_tx_, nic_rx_, fc_tx_, fc_rx_, stop_bit_, data_bit_, parity_, duplex_, modem_, protocol_id_2_, protocol_id_3_) \
		Isdn_qsi_store_llc_1_4(pr,			coding_std_,	trf_cap_,			\
							out_neg,		trf_mode_,		trf_rate_,			\
							structure_,		dest_rate_);						\
		Isdn_qsi_store_llc_5_7(PROTOCOL_ID_1_V110,	syn_asyn_,	negotiation_,	\
							user_rate_,		inter_rate_,	nic_tx_,			\
							nic_rx_,		fc_tx_,			fc_rx_,				\
							BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
							BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
							stop_bit_,		data_bit_,		parity_,			\
							duplex_,		modem_,			protocol_id_2_,		\
							BYTE_VAL_NIL,	protocol_id_3_,	BYTE_VAL_NIL)


			/*--------------------------------------------*/


			/*
			   Isdn_qsi_store_llc_V120 : low layer compatibility for
											V120 rate adaption :

					INPUT :
						- pr			= primitive ID,
						- coding_std_	= coding standard,
						- trf_cap_		= information transfer capability,
						- out_neg		= out band negotiation,
						- trf_mode_		= transfer mode,
						- trf_rate_		= information transfer rate,
						- structure_	= structure,
						- dest_rate_	= destination rate,
						- syn_asyn_		= synchronous/asynchronous,
						- negotiation_	= negotiation,
						- user_rate_	= user rate,
						- hdr_			= rate adaption header included or not,
						- multi_frame_	= multiple frame establishement support in DL,
						- op_mode_		= mode of operation,
						- lli_negot_	= logical link identifier negotiation,
						- assign_		= assignor/assignee,
						- band_negot_	= in-band/out-band negotiation,
						- stop_bit_		= number of stop bits,
						- data_bit_		= number of data bits,
						- parity_		= number of parity bit,
						- duplex_		= duplex mode,
						- modem_		= modem type,
						- protocol_id_2_= user information layer 2 protocol,
						- protocol_id_3_= user information layer 3 protocol,

			*/

#define Isdn_qsi_store_llc_V120(pr, coding_std_, trf_cap_, out_neg, trf_mode_, trf_rate_, structure_, dest_rate_, syn_asyn_, negotiation_, user_rate_, hdr_, multi_frame_, op_mode_, lli_negot_, assign_, band_negot_, stop_bit_, data_bit_, parity_, duplex_, modem_, protocol_id_2_, protocol_id_3_) \
		Isdn_qsi_store_llc_1_4(pr,			coding_std_,	trf_cap_,			\
							out_neg,		trf_mode_,		trf_rate_,			\
							structure_,		dest_rate_);						\
		Isdn_qsi_store_llc_5_7(PROTOCOL_ID_1_V120,								\
							syn_asyn_,		negotiation_,	user_rate_,			\
							BYTE_VAL_NIL,	BYTE_VAL_NIL,	BYTE_VAL_NIL,		\
							BYTE_VAL_NIL,	BYTE_VAL_NIL,	hdr_,				\
							multi_frame_,	op_mode_,		lli_negot_,			\
							assign_,		band_negot_,	stop_bit_,			\
							data_bit_,		parity_,		duplex_,			\
							modem_,			protocol_id_2_, BYTE_VAL_NIL,		\
							protocol_id_3_	BYTE_VAL_NIL)



/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_progress_ind : progress indicator

					INPUT :
						- pr				= primitive ID,
						- coding_std_		= coding standard,
						- progress_loc_		= location,
						- progress_descr_	= description.

			*/

#define Isdn_qsi_store_progress_ind(pr, coding_std_, progress_loc_, progress_descr_) \
		Set_offset_qsi	(pr,			progress_ind);								\
		Set_val_qsi		(progress_ind,	coding_std,		coding_std_);				\
		Set_val_qsi		(progress_ind,	progress_loc,	progress_loc_);				\
		Set_val_qsi		(progress_ind,	progress_descr,	progress_descr_);			\
		Set_next_ie_qsi	(progress_ind)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_restart_ind : restart indicator

					INPUT :
						- pr	= primitive ID,
						- class_= class.

			*/

#define Isdn_qsi_store_restart_ind(pr, class_)									\
		Set_offset_qsi	(pr,			restart_ind);								\
		Set_val_qsi		(restart_ind,	restart_class,	class_);					\
		Set_next_ie_qsi	(restart_ind)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_party_category : party category

					INPUT :
						- pr	= primitive ID,
						- category_		= category.

			*/

#define Isdn_qsi_store_party_category(pr, category_)					\
		Set_offset_qsi	(pr,		party_category);						\
		Set_val_qsi		(party_category,		category,		category_);	\
		Set_next_ie_qsi	(party_category)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_transit_counter : party category

					INPUT :
						- pr	= primitive ID,
						- count_		= count.

			*/

#define Isdn_qsi_store_transit_counter(pr, count_)						\
		Set_offset_qsi	(pr,		transit_counter);						\
		Set_val_qsi		(transit_counter,		count,		count_);		\
		Set_next_ie_qsi	(transit_counter)

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_sending_complete : sending complete

					INPUT :
						- pr		= primitive ID,

			*/

#define Isdn_qsi_store_sending_complete(pr)	\
		Set_offset_qsi	(pr,				sending_complete)


/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_facility : qsig facility IE

					INPUT :
						- pr		= primitive ID,
						- info_		= address of the literal info string.
						- fac_sz_	= actual facility size
			*/

#if NS_SUPP_SERVICES == OFF

#define Isdn_qsi_store_facility(pr, info_, fac_sz_)			\
		Set_offset_qsi	(pr,				facility);		\
		Set_mem_qsi		(facility,	info,	info_, fac_sz_)

#else	/* NS_SUPP_SERVICES = ON{ */

			/*
				Isdn_qsi_store_facility : qsig facility IE

					INPUT :
						- pr			= primitive ID,

							NetworkFacilityExtension parameters :
						- nfe_s_ent		= type of source entity,
						- nfe_s_p_nb_t	= type of PartyNumber in source entity address,
						- nfe_s_t_of_nb	= type of Number in source entity address,
						- nfe_s_sz		= size of source entity address string,
						- nfe_p_s_add	= pointer to source entity address,
						- nfe_d_ent		= type of destination entity,
						- nfe_d_p_nb_t	= type of PartyNumber in destination entity address,
						- nfe_d_t_of_nb	= type of Number in destination entity address,
						- nfe_d_sz		= size of destination entity address size,
						- nfe_p_d_add	= pointer to destination entity address,

						- inter			= InterpretationApdu.

					Values for 'Type of PartyNumber' and 'Type of Number' fields are the ones
					defined in ns_ssint.h file. 'Type of Number' is meaningless
					if 'Type of PartyNumber' is neither "PUBLIC" nor "PRIVATE".
			*/

#define Isdn_qsi_store_facility(pr, nfe_s_ent, nfe_s_p_nb_t, nfe_s_t_of_nb, nfe_s_sz, nfe_p_s_add, nfe_d_ent, nfe_d_p_nb_t, nfe_d_t_of_nb, nfe_d_sz, nfe_p_d_add, inter)	\
		Set_offset_qsi	(pr,		facility);							\
		Set_val_qsi		(facility,	nfe_source,			nfe_s_ent);		\
		Set_val_qsi		(facility,	nfe_source_p_nb_t,	nfe_s_p_nb_t);	\
		Set_val_qsi		(facility,	nfe_source_t_of_nb,	nfe_s_t_of_nb);	\
		Set_val_qsi		(facility,	nfe_source_add_sz,	nfe_s_sz);		\
		Set_val_qsi		(facility,	nfe_dest,			nfe_d_ent);		\
		Set_val_qsi		(facility,	nfe_dest_p_nb_t,	nfe_d_p_nb_t);	\
		Set_val_qsi		(facility,	nfe_dest_t_of_nb,	nfe_d_t_of_nb);	\
		Set_val_qsi		(facility,	nfe_dest_add_sz,	nfe_d_sz);		\
		Set_val_qsi		(facility,	interpretation,		inter);			\
		ns_int_ctx.p__ss_data = (uchar FAR *)&(((P_val_ns_qsi (facility))ns_int_ctx.p__val) -> nfe_first_add);	\
		Memcpy_far ((char FAR *)(ns_int_ctx.p__ss_data), (char FAR *)(nfe_p_s_add), nfe_s_sz);	\
		ns_int_ctx.p__ss_data += nfe_s_sz;								\
		Memcpy_far ((char FAR *)(ns_int_ctx.p__ss_data), (char FAR *)(nfe_p_d_add), nfe_d_sz);	\
		ns_int_ctx.p__ss_data += nfe_d_sz;								\
		Align_struct_ns_p_ss_val	();									\
		Set_val_qsi		(facility,	first_apdu_offset,	(ushort)(((ulong)ns_int_ctx.p__ss_data - (ulong)ns_int_ctx.p__val)))

#define Isdn_qsi_store_fac_rose_apdu()					\
		*(ns_int_ctx.p__ss_data) = QSI_ROSE_APDU_TAG;	\
		ns_int_ctx.p__ss_data = (uchar FAR *)&(((struct ns_ss_qsi_rose_apdu FAR *)ns_int_ctx.p__ss_data) -> component)

#define Isdn_qsi_store_fac_dse_apdu(pdu, orig_sz, dest_sz, comp_nb, p_orig, p_dest)			\
		*(ns_int_ctx.p__ss_data) = QSI_DSE_APDU_TAG;										\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> dse_pdu_type = pdu;		\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> orig_dialog_or_abort_info_sz = orig_sz;	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> destination_dialog_sz = dest_sz;	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> p_abort_cause = BYTE_VAL_NIL;	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> component_nb = comp_nb;	\
		ns_int_ctx.p__val = &(((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> first_str);	\
		Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_orig), orig_sz);		\
		ns_int_ctx.p__val += orig_sz;														\
		Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_dest), dest_sz);		\
		ns_int_ctx.p__val += dest_sz;														\
		Align_struct_ns_p_val	();															\

#define Isdn_qsi_store_fac_dse_BEGIN(orig_sz, comp_nb, p_orig)	\
			Isdn_qsi_store_fac_dse_apdu (QSI_DSE_BEGIN_PDU_TAG, orig_sz, 0, comp_nb, p_orig, P_NIL)

#define Isdn_qsi_store_fac_dse_END(dest_sz, comp_nb, p_dest)	\
			Isdn_qsi_store_fac_dse_apdu (QSI_DSE_END_PDU_TAG, 0, dest_sz, comp_nb, P_NIL, p_dest)

#define Isdn_qsi_store_fac_dse_CONTI(orig_sz, dest_sz, comp_nb, p_orig, p_dest)	\
			Isdn_qsi_store_fac_dse_apdu(QSI_DSE_CONTINUE_PDU_TAG, orig_sz, dest_sz, comp_nb, p_orig, p_dest)

#define Isdn_qsi_store_fac_dse_ABORT(dest_sz, cause, info_sz, p_dest, p_info)				\
		*(ns_int_ctx.p__ss_data) = QSI_DSE_APDU_TAG;										\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> dse_pdu_type = QSI_DSE_ABORT_PDU_TAG;	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> orig_dialog_or_abort_info_sz = info_sz;	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> destination_dialog_sz = dest_sz;	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> p_abort_cause = cause;	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> component_nb = 0;		\
		ns_int_ctx.p__val = &(((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> first_str);	\
		Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_dest), dest_sz);		\
		ns_int_ctx.p__val += dest_sz;														\
		Memcpy_far ((char FAR *)(ns_int_ctx.p__val), (char FAR *)(p_info), info_sz);		\
		ns_int_ctx.p__val += info_sz;														\
		Align_struct_ns_p_val	();															\

#define Isdn_set_qsi_last_dse_comp()	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> first_comp_offset = OFFSET_NIL

#define Isdn_set_qsi_next_dse_comp()	\
		((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> first_comp_offset = (ushort)((ulong)ns_int_ctx.p__val - (ulong)ns_int_ctx.p__ss_data);	\
		ns_int_ctx.p__ss_data = ns_int_ctx.p__val

#define Isdn_get_fac_first_apdu_qsi(pr)	\
		ns_int_ctx.p__ss_data = (uchar FAR *)P_start_val_ns_qsi (pr, facility);	\
		ns_int_ctx.p__ss_data += ((P_val_ns_qsi (facility))ns_int_ctx.p__ss_data) -> first_apdu_offset

#define Isdn_get_first_rose_comp_qsi()	\
		ns_int_ctx.p__ss_data = (uchar FAR *)&(((struct ns_ss_qsi_rose_apdu FAR *)ns_int_ctx.p__ss_data) -> component)

#define Isdn_get_ss_dse_apdu_val_qsi(val_id)	((struct ns_ss_qsi_dse_apdu FAR *)ns_int_ctx.p__ss_data) -> val_id

#define Isdn_get_first_dse_comp_qsi()		\
		ns_int_ctx.p__ss_data += Isdn_get_ss_dse_apdu_val_qsi (first_comp_offset)

#endif	/* end of "NS_SUPP_SERVICES = ON"} */

/*-------------------------------------------------------------------------*/

			/*
				Isdn_qsi_store_notif_ind : notification indicator

					INPUT :
						- pr	= primitive ID,
						- descr	= description.
						- info_ = extra information
						- sz_	= size of extra info

			*/

#define Isdn_qsi_store_notif_ind(pr, descr, info_, sz_)			\
		Set_offset_qsi	(pr,		notif_ind);					\
		Set_val_qsi		(notif_ind,	notif_descr,	descr);		\
		Set_mem_qsi		(notif_ind,	info,	info_, sz_)

/*-------------------------------------------------------------------------*/
/*						Q931 (TRANSPARENT) IE ENCODING							   */
/*-------------------------------------------------------------------------*/

#if NS_IE_TSP_OUT == ON

#	define	Isdn_qsi_store_bc_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, bc);						\
		Set_mem_eob_qsi	(bc, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_BC_TSP) ? 1 + QSI_MX_SZ_BC_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_called_nb_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, called_nb);						\
		Set_mem_eob_qsi	(called_nb, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CALLED_NB_TSP) ? 1 + QSI_MX_SZ_CALLED_NB_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_calling_nb_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, calling_nb);						\
		Set_mem_eob_qsi	(calling_nb, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CALLING_NB_TSP) ? 1 + QSI_MX_SZ_CALLING_NB_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_conn_nb_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, conn_nb);						\
		Set_mem_eob_qsi	(conn_nb, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CONN_NB_TSP) ? 1 + QSI_MX_SZ_CONN_NB_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_called_sub_add_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, called_sub_add);						\
		Set_mem_eob_qsi	(called_sub_add, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CALLED_SUB_ADD_TSP) ? 1 + QSI_MX_SZ_CALLED_SUB_ADD_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_calling_sub_add_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, calling_sub_add);						\
		Set_mem_eob_qsi	(calling_sub_add, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CALLING_SUB_ADD_TSP) ? 1 + QSI_MX_SZ_CALLING_SUB_ADD_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_conn_sub_add_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, conn_sub_add);						\
		Set_mem_eob_qsi	(conn_sub_add, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CONN_SUB_ADD_TSP) ? 1 + QSI_MX_SZ_CONN_SUB_ADD_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_cause_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, cause);						\
		Set_mem_eob_qsi	(cause, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CAUSE_TSP) ? 1 + QSI_MX_SZ_CAUSE_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_chan_id_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, chan_id);						\
		Set_mem_eob_qsi	(chan_id, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_CHAN_ID_TSP) ? 1 + QSI_MX_SZ_CHAN_ID_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_facility_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, facility);						\
		Set_mem_eob_qsi	(facility, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_FACILITY_TSP) ? 1 + QSI_MX_SZ_FACILITY_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_hlc_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, hlc);						\
		Set_mem_eob_qsi	(hlc, tsp_data, p_data_,(p_data_[0] > QSI_MX_SZ_HLC_TSP) ? 1 + QSI_MX_SZ_HLC_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_llc_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, llc);						\
		Set_mem_eob_qsi	(llc, tsp_data,p_data_, (p_data_[0] > QSI_MX_SZ_LLC_TSP) ? 1 + QSI_MX_SZ_LLC_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_notif_ind_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, notif_ind);						\
		Set_mem_eob_qsi	(notif_ind, tsp_data,p_data_, (p_data_[0] > QSI_MX_SZ_NOTIF_IND_TSP) ? 1 + QSI_MX_SZ_NOTIF_IND_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_progress_ind_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, progress_ind);						\
		Set_mem_eob_qsi	(progress_ind, tsp_data,p_data_, (p_data_[0] > QSI_MX_SZ_PROGRESS_IND_TSP) ? 1 + QSI_MX_SZ_PROGRESS_IND_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_restart_ind_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, restart_ind);						\
		Set_mem_eob_qsi	(restart_ind, tsp_data,p_data_, (p_data_[0] > QSI_MX_SZ_RESTART_IND_TSP) ? 1 + QSI_MX_SZ_RESTART_IND_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_party_categ_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, party_category);						\
		Set_mem_eob_qsi	(party_category, tsp_data,p_data_, (p_data_[0] > QSI_MX_SZ_PARTY_CATEG_TSP) ? 1 + QSI_MX_SZ_PARTY_CATEG_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#	define	Isdn_qsi_store_transit_c_tsp(pr, p_data_)				\
		Set_ns_offset_tsp_qsi	(pr, transit_counter);						\
		Set_mem_eob_qsi	(transit_counter, tsp_data,p_data_, (p_data_[0] > QSI_MX_SZ_TRANSIT_COUNTER_TSP) ? 1 + QSI_MX_SZ_TRANSIT_COUNTER_TSP : 1 + p_data_[0]);\
		Skip_ns_tsp_ie	()

#endif

/*EOF*/


