
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_ie_ss.qsi
 *
 * $Revision$
 *
 * $Date$
 *
 *		Q-SIG specific functions that implement the decoding and encoding
 *		of the IEs specific to Supplementary Services :
 *		FACILITY, NOTIFICATION INDICATOR.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

		/* table of all PDU tags inside DseAPDU : Begin / End / Continue / Abort */

CONST_ARRAY uchar QSI_DSE_APDU_TAG_TAB[] = {

	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_BEGIN_PDU_TAG),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_END_PDU_TAG),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_CONTINUE_PDU_TAG),
	Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_ABORT_PDU_TAG)
};

#define SIZE_QSI_DSE_APDU_TAG_TAB		sizeof(QSI_DSE_APDU_TAG_TAB)

		/* definitions of tags for types inside DSeAPDU */

#define QSI_DSE_ORIG_DIALOG_ID_TAG		G_5 (0,0,0,0,0)			/* OriginationDialogID */
#define QSI_DSE_DEST_DIALOG_ID_TAG		G_5 (0,0,0,0,1)			/* DestinationDialogID */
#define QSI_DSE_P_ABORT_CAUSE_TAG		G_5 (0,0,0,1,0)			/* P-AbortCause */
#define QSI_DSE_USER_ABORT_INFO_TAG		G_5 (0,0,0,1,1)			/* UserAbortInformation */
#define QSI_DSE_REMOTE_PORTION_TAG		G_5 (0,0,1,0,0)			/* RemoteOperationsPortion */

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            qsi_facility_spdu - implements the decoding or encoding
				of a FACILITY IE received or to be sent in a spdu.

Usage           uchar	qsi_facility_spdu (void);

Return value	OK / NOK

common objects : internal data structure i_facility, ie spdu context,
				 direction (FROM or TO D_CHANNEL), ns_fac_components array,
				 global pointers : p_ns_fac_component, p_ns_ss_op_err_tab.

*--------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	uchar	qsi_fac_component_from_spdu		(uchar FAR *p_end);
	uchar	qsi_fac_component_to_spdu		(void);
#else
	uchar	qsi_fac_component_from_spdu		();
	uchar	qsi_fac_component_to_spdu		();
#endif

uchar qsi_facility_spdu ()
{
	uchar						ie_octet;					/* current IE octet */
	ushort						length;						/* current length of SEQUENCE in component */
	uchar	FAR					*p_end_dse_apdu;			/* pointer to end of DseAPDU */
	uchar	FAR					*p_dse_remote_op_lgth;		/* pointer to length location of RemoteOperationsPortion inside DseAPDU */
	uchar						i;							/* loop index */
	asn1_store_ctx_t FAR		*p_store_ctx;				/* pointer to current storage context */
	asn1_store_ctx_t FAR		*p_previous_ctx;			/* pointer to previous storage context */

		/* get country specific tables for operations + errors + Object Identifiers */

	ns_get_country_op_err_tab (Na_country);

	if (p_ns_ss_op_err_tab == P_NIL) {

		return (NOK);	/* no Table found -> no supplementary service in current country */
	}

		/*	pass the table of OBJECT IDENTIFIERs (pointer to table + number
			of entries in table) onto the ASN1 mechanism before decoding or encoding */

	Asn1_set_obj_id_lists	(Ns_ss_obj_id_nb, Ns_ss_p_obj_id_list, P_NIL);

	if (direction == FROM_D_CHANNEL) {		/* FROM the D CHANNEL */

			/* Is there a NetworkFacilityExtension ? */

		ns_qsi_fac_start[i_ie_x].nfe_source		= BYTE_VAL_NIL;
		ns_qsi_fac_start[i_ie_x].interpretation	= BYTE_VAL_NIL;

		if (Get_ie_octet == Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_NET_FAC_EXTENSION_TAG)) {

				/* Yes : process it */

			p_ns_ss_ctx_list = (struct ns_asn1_store_desc CONST FAR	*)NS_SS_QSI_CTX_LIST_NFE;
			p_ns_ss_ctx_list++;	/* skip first entry used for repetition */  

				/* initialize optional indicators */

			ns_asn1_optional_indicators [0] = ns_asn1_optional_indicators [1] = ASN1_OPTIONAL_NOT_PROCESSED;

				/* initialise all storage contexts to be used by ASN1 decoding mechanism */

			for (i = 0; Ns_ss_ctx_list_p_pc != P_NIL; p_ns_ss_ctx_list++, i++) {

				/*	reset pointer to previous context if it is a new Meta-program field (pair (p_pc, field_nb))
					processed (the first one or a field different from previous one) */

				if ((i == 0) ||
					(ns_asn1_tab_store_info[i - 1].p_pc != Ns_ss_ctx_list_p_pc) ||
					(ns_asn1_tab_store_info[i - 1].field_nb != Ns_ss_ctx_list_field_nb)) {

					p_previous_ctx = P_NIL;
				}

				if (i >= NS_MX_ASN1_STORE_DESC) {

						/* global storage description array is too small */

					Trap (TRAP_NS_SS_INCONSISTENCY, "qsi_facility_spdu");
					return (NOK);
				}

					/* get storage context from storage description structure */

				p_store_ctx = Asn1_get_p_store_ctx	(ns_asn1_tab_store_info + i);

					/* init current context, link it to previous one and update previous one */

				Asn1_init_store_ctx		(p_store_ctx);
				if (p_previous_ctx != P_NIL) {

					Asn1_link_store_ctx		(p_previous_ctx, p_store_ctx);
				}
				p_previous_ctx = p_store_ctx;

					/* store the meta-program pointer into the description structure */

				ns_asn1_tab_store_info[i].p_pc		= (uchar FAR *)(Ns_ss_ctx_list_p_pc);
				ns_asn1_tab_store_info[i].field_nb	= Ns_ss_ctx_list_field_nb;
			}

				/* decode and check resulting data length */

			if (asn1_decoding_start ((uchar FAR *)&NS_SS_QSI_NET_FAC_EXTENS_P, &p_ie, p_ie_end + 1, i, ns_asn1_tab_store_info) == 0) {

				return (NOK);
			}

				/* store values decoded by ASN1 mechanism into internal structures */

			p_ns_ss_ctx_list = (struct ns_asn1_store_desc CONST FAR	*)NS_SS_QSI_CTX_LIST_NFE;
			ns_i_ss_clause_nb = i_ie_x;
			ns_ss_store_internal_value ();

		}	/* end of NetworkFacilityExtension process */

			/* Is there an InterpretationApdu ? */

		if (Get_ie_octet == Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_INTERPRETATION_APDU_TAG)) {

				/* Yes : process it */

			p_ie++;		/* skip Tag */

			if (ns_decode_asn1_lgth () != 1) {		

				return (NOK);	/* length should be 1 */
			}

			ie_octet = Get_inc_ie_octet;

			if (Get_bits (ie_octet, 7, 1) == 1) {

				return (NOK);	/* InterpretationApdu should be a positive integer */
			}

			ns_qsi_fac_start[i_ie_x].interpretation	= ie_octet;

		} /* end of InterpretationApdu process */

			/* one or more elements of type ComponentPart */

		if (p_ie >= p_ie_end) {

        	return (NOK);	/* there should be at least 1 ComponentPart */
		}

		I_facility_first_comp_x = ns_x_ss_fac_comp;
		I_facility_component_nb = 0;

        	/* analyse until end of IE */

		while (p_ie < p_ie_end) {

			if (ns_x_ss_fac_comp >= NS_MX_FAC_COMPONENTS) {

				return (NOK);
			}

			p_ns_fac_component = &(ns_fac_components[ns_x_ss_fac_comp]);

				/* check APDU tag */

			I_ss_fac_apdu_type = QSI_ROSE_APDU_TAG;		/* init Type of APDU to "RoseApdu" */

			if (ns_check_get_tag (QSI_DSE_APDU_TAG_TAB, SIZE_QSI_DSE_APDU_TAG_TAB,
								  Get_ie_octet, &(I_ss_fac_apdu_type)) == OK) {

					/* it is a DseAPDU : skip Tag and check length (SEQUENCE) */

				p_ie++;
				length = ns_decode_asn1_lgth ();
				if (length == NS_ASN1_INDEFINITE_LGTH) {

					p_end_dse_apdu = p_ie_end;
					i = 1;		/* use 'i' variable as flag indicating Length of Indefinite Form */

				} else {

					if ((length == BAD_ASN1_LGTH) || (p_ie + length > p_ie_end)) {

						return (NOK);
					}

					p_end_dse_apdu = p_ie + length;
					i = 0;		/* use 'i' variable as flag indicating Length of Indefinite Form */
				}

					/*	process according to type of DseAPDU : use 'ie_octet' variable
						to store the local tag that should be found in data */

				switch (I_ss_fac_apdu_type) {

					case QSI_DSE_BEGIN_PDU_TAG :	/* DialogBeginPDU : it should contain OriginationDialogID */
					case QSI_DSE_CONTINUE_PDU_TAG :	/* DialogContinuePDU : it should contain OriginationDialogID and DestinationDialogID */

						ie_octet = QSI_DSE_ORIG_DIALOG_ID_TAG;
						break;

					case QSI_DSE_END_PDU_TAG :	/* DialogEndPDU : it should contain DestinationDialogID */
					case QSI_DSE_ABORT_PDU_TAG :	/* DialogAbortPDU : it should contain DestinationDialogID */

						ie_octet = QSI_DSE_DEST_DIALOG_ID_TAG;
						break;
				}

					/* check Tag and length of DialogID (OCTET STRING) */

				if ((Get_inc_ie_octet != Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, ie_octet)) ||
					((length = ns_decode_asn1_lgth ()) > QSI_MX_DSE_DIALOG_ID_SZ) ||
					(p_ie + length > p_end_dse_apdu)) {

					return (NOK);
				}

					/* store dialog ID into internal data, copy string into internal buffer and update pointers */

				if (ie_octet == QSI_DSE_ORIG_DIALOG_ID_TAG) {

					I_ss_fac_orig_abort_sz	= (uchar)length;
					I_ss_fac_p_orig_abort	= p_ind_buffer;

				} else {

					I_ss_fac_dest_sz	= (uchar)length;
					I_ss_fac_p_dest		= p_ind_buffer;
				}

				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_ie, (uchar)length);
				p_ie += (uchar)length;
				p_ind_buffer += (uchar)length;

				if (I_ss_fac_apdu_type == QSI_DSE_CONTINUE_PDU_TAG) {

						/* DialogContinuePDU : it should contain DestinationDialogID */

					if ((Get_inc_ie_octet != Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_DSE_DEST_DIALOG_ID_TAG)) ||
						((length = ns_decode_asn1_lgth ()) > QSI_MX_DSE_DIALOG_ID_SZ) ||
						(p_ie + length > p_end_dse_apdu)) {

						return (NOK);
					}

						/* store DestinationDialogID into internal data, copy string into internal buffer and update pointers */

					I_ss_fac_dest_sz	= (uchar)length;
					I_ss_fac_p_dest		= p_ind_buffer;
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_ie, (uchar)length);
					p_ie += (uchar)length;
					p_ind_buffer += (uchar)length;
				}

				if (I_ss_fac_apdu_type == QSI_DSE_ABORT_PDU_TAG) {

						/* DialogAbortPDU : it should contain either P-AbortCause or UserAbortInformation */

					ie_octet = Get_inc_ie_octet;
					if (ie_octet == Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_DSE_P_ABORT_CAUSE_TAG)) {

							/* P-AbortCause is included : it is an integer in range [0..127]
								and end of DseAPDU should be reached -> check and store it */

						if (((length = ns_decode_asn1_lgth ()) != 1) ||
							((i == 0) && (p_ie + 1 != p_end_dse_apdu))) {

							return (NOK);
						}

						if ((I_ss_fac_cause_or_nb = Get_inc_ie_octet) > 127) {

							return (NOK);
						}

						I_ss_fac_orig_abort_sz = 0;

					} else {

						if (ie_octet != Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_USER_ABORT_INFO_TAG)) {

							return (NOK);	/* unexpected tag inside DialogAbortPDU */
						}

							/* UserAbortInformation is included : it is an integer in range [0..127]
								and end of DseAPDU should be reached -> check and store it */

						I_ss_fac_cause_or_nb = BYTE_VAL_NIL;

						if (((length = ns_decode_asn1_lgth ()) == BAD_ASN1_LGTH) ||
							((i == 0) && (p_ie + length != p_end_dse_apdu))) {

							return (NOK);
						}

						/* store UserAbortInformation into internal data, copy string into internal buffer and update pointers */

						I_ss_fac_orig_abort_sz = (uchar)length;
						I_ss_fac_p_orig_abort = p_ind_buffer;
						Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_ie, (uchar)length);
						p_ie += (uchar)length;
						p_ind_buffer += (uchar)length;
					}

						/* update number of components, current index and pointer to internal data */

					ns_x_ss_fac_comp++;
					p_ns_fac_component++;
					I_facility_component_nb++;

				} else {

						/* DialogBeginPDU, DialogContinuePDU or DialogEndPDU : it may contain RemoteOperationsPortion */

					I_ss_fac_cause_or_nb = 0;		/* init number of components (= RoseAPDU) in DseAPDU */

					if (i == 1) {

							/* indefinite form length : if p_ie points to End-Of-Content octets, end of DseAPDU is reached */

						if ((p_ie + NS_ASN1_END_OF_CONTENT_SIZE) > p_end_dse_apdu) {

							return (NOK);
						}

						for (ie_octet = 0; ie_octet < NS_ASN1_END_OF_CONTENT_SIZE; ie_octet++) {

							if (p_ie[ie_octet] != NS_ASN1_END_OF_CONTENT_VAL) {

								break;
							}
						}

						if (ie_octet == NS_ASN1_END_OF_CONTENT_SIZE) {	/* end of content is indicated */

							p_ie += NS_ASN1_END_OF_CONTENT_SIZE;	/* skip End-Of-Content octets */
							i = 0;									/* reset flag for Indefinite Form Length for further use */
							p_end_dse_apdu = p_ie;					/* update current pointer */
						}
					}

					if (p_ie == p_end_dse_apdu) {

							/* end of DseAPDU is reached : no RemoteOperationsPortion -> update
								number of components, current index and pointer to internal data */

						ns_x_ss_fac_comp++;
						p_ns_fac_component++;
						I_facility_component_nb++;

					} else {

							/* end of DseAPDU is not reached : it should contain RemoteOperationsPortion
								-> check tag and Length (SEQUENCE OF) */

						ie_octet = Get_inc_ie_octet;
						length = ns_decode_asn1_lgth ();
						if (length == NS_ASN1_INDEFINITE_LGTH) {

							i += 2;	/* Use second Bit of 'i' to store Indefinite Form flag */
						}

						if ((ie_octet != Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_REMOTE_PORTION_TAG)) ||
							(length == BAD_ASN1_LGTH) ||
							((i == 0) && (p_ie + length != p_end_dse_apdu))) {

							return (NOK);
						}

						if (i == 1) {

								/*	Length of DseAPDU was of Indefinite Form but not Length
									of RemoteOperationsPortion -> use the last one to update pointer */

							p_end_dse_apdu = p_ie + length;

							if (p_end_dse_apdu > p_ie_end) {

                            	return (NOK);
							}
						}

							/* use 'p_dse_remote_op_lgth' variable to get the location of "number of components" */

						p_dse_remote_op_lgth = &(I_ss_fac_cause_or_nb);

							/* process list (SEQUENCE OF) of RoseAPDUs (= ETSI component) */

						while (p_ie < p_end_dse_apdu) {

							if (ns_x_ss_fac_comp >= NS_MX_FAC_COMPONENTS) {

								return (NOK);
							}

							p_ns_fac_component = &(ns_fac_components[ns_x_ss_fac_comp]);

							if (qsi_fac_component_from_spdu (p_end_dse_apdu) == NOK) {

								return (NOK);
							}

								/* set Type of APDU to "RoseApdu" except for first component in DseAPDU */

							if (*p_dse_remote_op_lgth != 0) {

								I_ss_fac_apdu_type = QSI_ROSE_APDU_TAG;
							}

								/*	increment number of RoseAPDUs in DseAPDU, number of components
									in Facility IE and update current index and pointer to internal data */

							(*p_dse_remote_op_lgth)++;
							ns_x_ss_fac_comp++;
							p_ns_fac_component++;
							I_facility_component_nb++;

							if (i >= 2) {

									/* indefinite form length : if p_ie points to End-Of-Content octets, end of RemoteOperationsPortion is reached */

								if ((p_ie + NS_ASN1_END_OF_CONTENT_SIZE) > p_end_dse_apdu) {

									return (NOK);
								}

								for (ie_octet = 0; ie_octet < NS_ASN1_END_OF_CONTENT_SIZE; ie_octet++) {

									if (p_ie[ie_octet] != NS_ASN1_END_OF_CONTENT_VAL) {

										break;
									}
								}

								if (ie_octet == NS_ASN1_END_OF_CONTENT_SIZE) {	/* end of content is indicated */

									p_ie += NS_ASN1_END_OF_CONTENT_SIZE;	/* skip End-Of-Content octets */
									i -= 2;									/* update flag for Indefinite Form Length for further use */
									p_end_dse_apdu = p_ie;					/* update current pointer */
								}
							}

						} /* end of list of RoseAPDUs */
					}
				}

					/* end of DseAPDU */

				if (i == 1) {

						/* DseAPDU is decoded : p_ie should point to the End-Of-Content octets of the DseAPDU */

					if ((p_ie + NS_ASN1_END_OF_CONTENT_SIZE) > p_ie_end) {

						return (NOK);
					}

					for (ie_octet = 0; ie_octet < NS_ASN1_END_OF_CONTENT_SIZE; ie_octet++) {

						if (*p_ie++ != NS_ASN1_END_OF_CONTENT_VAL) {

							return (NOK);
						}
					}
				}

			} else {	/* RoseAPDU */

				/* process RoseAPDU (= ETSI component) */

				if (qsi_fac_component_from_spdu (p_ie_end) == NOK) {

					return (NOK);
				}

				ns_x_ss_fac_comp++;
				p_ns_fac_component++;
				I_facility_component_nb++;
			}

		}	/* end of analyse until end of IE */

	} else {		/* TO the D CHANNEL */

		p_spdu_end = p_ie + 255;										/* set pointer to end of IE (maximum IE length is 255) */
		ns_x_ss_fac_comp = I_facility_first_comp_x;						/* get index in common array of first component in Facility IE */
		p_ns_fac_component = &(ns_fac_components[ns_x_ss_fac_comp]);	/* get pointer to common component data */

		if ((ns_x_ss_fac_comp + I_facility_component_nb) > NS_MX_FAC_COMPONENTS) {

				/* nb of components stored in i_facility is too high : it should not happen for it has been checked during SSDU process */

			return (NOK);
		}

			/* Is there a NetworkFacilityExtension ? */

		if (ns_qsi_fac_start[i_ie_x].nfe_source != BYTE_VAL_NIL) {

				/* Yes : process it */

			p_ns_ss_ctx_list = (struct ns_asn1_store_desc CONST FAR	*)NS_SS_QSI_CTX_LIST_NFE;
			ns_i_ss_clause_nb = i_ie_x;

			/*	initialize all storage contexts to be used by ASN1 encoding mechanism
				and store values from internal data */

			i = ns_ss_get_internal_value ();

				/* encode OPERATION/ERROR clause and check resulting data length */

			if (asn1_encoding_start ((uchar FAR *)&NS_SS_QSI_NET_FAC_EXTENS_P, &p_ie, p_spdu_end, i, ns_asn1_tab_store_info) == 0) {

				return (NOK);
			}

		}	/* end of NetworkFacilityExtension process */

			/* Is there an InterpretationApdu ? */

		if ((i = ns_qsi_fac_start[i_ie_x].interpretation) != BYTE_VAL_NIL) {

				/* Yes : process it */

			*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_INTERPRETATION_APDU_TAG);
			Asn1_encode_integer ((ulong)i, ASN1_CODING_POSITIVE, &p_ie, p_spdu_end);
		}

			/* process all components stored into internal structure */

		ie_octet = I_facility_component_nb; 
		while (ie_octet > 0) {

			if (I_ss_fac_apdu_type == QSI_ROSE_APDU_TAG) {	/* RoseAPDU */

					/* process RoseAPDU (= ETSI component) */

				if (qsi_fac_component_to_spdu () == NOK) {

					return (NOK);
				}

				ns_x_ss_fac_comp++;
				p_ns_fac_component++;		/* get next component internal structure */
                ie_octet--;

			} else {	/* DseAPDU */

					/* put tag (class, form, nb) of DseAPDU into SPDU, set pointer to length location and skip length */

				*p_ie++ = Ns_tag_from_class_form_nb	(FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, I_ss_fac_apdu_type);
				p_end_dse_apdu = p_ie;
				p_ie += 2;

				if (I_ss_fac_apdu_type == QSI_DSE_ABORT_PDU_TAG) {

						/* DialogAbortPDU : DestinationDialogID and Abort cause or Information */

					if ((p_ie + I_ss_fac_dest_sz + 2) > p_spdu_end) {

						return (NOK);	/* SPDU is too small to contain string */
					}

						/* copy DestinationDialogID string into SPDU */
					*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_DSE_DEST_DIALOG_ID_TAG);
					*p_ie++ = I_ss_fac_dest_sz;
					Memcpy_far ((char FAR *)p_ie, (char FAR *)(I_ss_fac_p_dest), I_ss_fac_dest_sz);
					p_ie += I_ss_fac_dest_sz;

					if ((i = I_ss_fac_cause_or_nb) != BYTE_VAL_NIL) {

							/* P-AbortCause is included : it is an integer in range -> put it into SPDU */

						*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_DSE_P_ABORT_CAUSE_TAG);
						Asn1_encode_integer ((ulong)i, ASN1_CODING_POSITIVE, &p_ie, p_spdu_end);

					} else {

							/* UserAbortInformation is included -> copy string into SPDU */

						if ((p_ie + I_ss_fac_orig_abort_sz + 2) > p_spdu_end) {

							return (NOK);	/* SPDU is too small to contain string */
						}

						*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_USER_ABORT_INFO_TAG);
						*p_ie++ = I_ss_fac_orig_abort_sz;
						Memcpy_far ((char FAR *)p_ie, (char FAR *)(I_ss_fac_p_orig_abort), I_ss_fac_orig_abort_sz);
						p_ie += I_ss_fac_orig_abort_sz;
					}

                    i = 0;	/* reset i : it is used hereafter as 'Nb of components inside DseAPDU' */

				} else {

						/* DialogBeginPDU or DialogEndPDU or DialogContinuePDU : there may be
							OriginationDialogID, DestinationDialogID and RemoteOperationsPortion */

					if (I_ss_fac_orig_abort_sz != 0) {

						if ((p_ie + I_ss_fac_orig_abort_sz + 2) > p_spdu_end) {

							return (NOK);	/* SPDU is too small to contain string */
						}

							/* copy OriginationDialogID string into SPDU */
						*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_DSE_ORIG_DIALOG_ID_TAG);
						*p_ie++ = I_ss_fac_orig_abort_sz;
						Memcpy_far ((char FAR *)p_ie, (char FAR *)(I_ss_fac_p_orig_abort), I_ss_fac_orig_abort_sz);
						p_ie += I_ss_fac_orig_abort_sz;
					}

					if (I_ss_fac_dest_sz != 0) {

						if ((p_ie + I_ss_fac_dest_sz + 2) > p_spdu_end) {

							return (NOK);	/* SPDU is too small to contain string */
						}

							/* copy DestinationDialogID string into SPDU */
						*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, QSI_DSE_DEST_DIALOG_ID_TAG);
						*p_ie++ = I_ss_fac_dest_sz;
						Memcpy_far ((char FAR *)p_ie, (char FAR *)(I_ss_fac_p_dest), I_ss_fac_dest_sz);
						p_ie += I_ss_fac_dest_sz;
					}

					i = I_ss_fac_cause_or_nb;	/* 'i' is used hereafter as 'Nb of components inside DseAPDU' */
				}

				if (i != 0) {

						/* put tag (class, form, nb) of DseAPDU into SPDU, set pointer to length location and skip length */

					*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, QSI_DSE_REMOTE_PORTION_TAG);
					p_dse_remote_op_lgth = p_ie;
					p_ie += 2;

						/* process list of RoseAPDU (= ETSI component) */

					while (i-- > 0) {

						if (qsi_fac_component_to_spdu () == NOK) {

							return (NOK);
						}

						ns_x_ss_fac_comp++;
						p_ns_fac_component++;		/* get next component internal structure */
						ie_octet--;
					}

						/* put length of RemoteOperationsPortions (inside DseAPDU) into SPDU */

					length = (ushort)((ulong)p_ie - (ulong)p_dse_remote_op_lgth - 2);

					if (length > 255) {

						return (NOK);
					}

					ns_encode_asn1_lgth (p_dse_remote_op_lgth, (uchar)length);

				} else {	/* no component inside DseAPDU (RemoteOperationsPortion is absent) */

					ns_x_ss_fac_comp++;
					p_ns_fac_component++;		/* get next component internal structure */
					ie_octet--;
				}

					/* put length of DseAPDU into SPDU */

				length = (ushort)((ulong)p_ie - (ulong)p_end_dse_apdu - 2);

				if (length > 255) {

					return (NOK);
				}

				ns_encode_asn1_lgth (p_end_dse_apdu, (uchar)length);
			}

		}	/* end of loop on components stored into internal structure */
	}

	return (OK);
}

	/* -=-=-=-=-=-=-=-=-=-=- */

uchar qsi_fac_component_from_spdu (p_end)
	uchar FAR		*p_end;						/* pointer to end of data */
{
	uchar			ie_octet;					/* current IE octet */
    uchar			indefinite_lgth;			/* flag indicating if length(s) is(are) of indefinite form */
	ushort			length;						/* current length of SEQUENCE in component */
	uchar FAR		*p_end_component;			/* pointer to end of component */

	p_ns_ss_ctx_list = P_NIL;		/* reset global pointer to list of storage descriptions to avoid mis-use */

		/* get first octet of component */

	ie_octet = Get_inc_ie_octet;

		/* check component tag */

	if (ns_check_get_tag (FAC_COMPONENT_TAG_TAB, SIZE_FAC_COMPONENT_TAG_TAB,
						  ie_octet, &(I_ss_fac_comp_tag)) == NOK) {

		return (NOK);
	}

		/* check component length (SEQUENCE) */

	length = ns_decode_asn1_lgth ();
	if (length == NS_ASN1_INDEFINITE_LGTH) {

		p_end_component = p_end;
		indefinite_lgth = 1;

	} else {

		if ((length == BAD_ASN1_LGTH) || (p_ie + length > p_end)) {

			return (NOK);
		}

		p_end_component = p_ie + length;
		indefinite_lgth = 0;
	}

	ie_octet = Get_inc_ie_octet;

		/* get and check Invoke ID (Tag, Length, Value) */

	if (ie_octet == Ns_tag_from_class_form_nb (FAC_UNIVERSAL, FAC_PRIMITIVE, FAC_INTEGER_TAG)) {

		if (((length = ns_decode_asn1_lgth ()) > 2) ||
			(p_ie + length > p_end_component)) {

			return (NOK);
		}

		ie_octet = Get_inc_ie_octet;

		if (I_ss_fac_comp_tag == FAC_REJECT) {

			I_ss_fac_is_inv_id_here = PRESENT;
		}

		I_ss_fac_invoke_id = ie_octet & Mask (7);

		if (Get_bits (ie_octet, 7, 1) == 1) {

			I_ss_fac_invoke_id -= 128;
		}

		if (length == 2) {

			I_ss_fac_invoke_id = I_ss_fac_invoke_id * 256 + Get_inc_ie_octet;
		}

	} else {

			/* Invoke ID may be omitted in RejectComponent only : tag is NULL */

		if ((I_ss_fac_comp_tag != FAC_REJECT) ||
			(ie_octet != Ns_tag_from_class_form_nb (FAC_UNIVERSAL, FAC_PRIMITIVE, FAC_NULL_TAG)))
		{
			return (NOK);
		}

		I_ss_fac_is_inv_id_here = ABSENT;

		if (Get_inc_ie_octet != 0) {

			return (NOK);
		}
	}

	ie_octet = Get_ie_octet;

	switch (I_ss_fac_comp_tag) {

		case FAC_INVOKE :

				/* get and check possible Linked ID */

			if (ie_octet == Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, FAC_LINKED_ID_TAG)) {

					/* set p_ie pointer to begin of length field */

				p_ie++;

				if (((length = ns_decode_asn1_lgth ()) > 2) ||
					(p_ie + length > p_end_component)) {

					return (NOK);
				}

				ie_octet = Get_inc_ie_octet;

				I_ss_fac_is_lk_id_here = PRESENT;
				I_ss_fac_linked_id = ie_octet & Mask (7);

				if (Get_bits (ie_octet, 7, 1) == 1) {

					I_ss_fac_linked_id -= 128;
				}

				if (length == 2) {

					I_ss_fac_linked_id = I_ss_fac_linked_id * 256 + Get_inc_ie_octet;
				}

			} else {

				I_ss_fac_is_lk_id_here = ABSENT;
			}

				/* decode OPERATION value and ARGUMENT clause */

			if (ns_decode_ss_op_err_val (p_end_component, NS_FLAG_OPERATION_ARGUMENT) == NOK) {

				return (NOK);
			}

			break;

		case FAC_RETURN_RESULT :

			if (indefinite_lgth == 1) {

					/* indefinite form length : if p_ie points to End-Of-Content octets, end of component is reached */

				if ((p_ie + NS_ASN1_END_OF_CONTENT_SIZE) > p_end_component) {

					return (NOK);
				}

				for (indefinite_lgth = 0; indefinite_lgth < NS_ASN1_END_OF_CONTENT_SIZE; indefinite_lgth++) {

					if (p_ie[indefinite_lgth] != NS_ASN1_END_OF_CONTENT_VAL) {

						break;
					}
				}

				if (indefinite_lgth == NS_ASN1_END_OF_CONTENT_SIZE) {	/* end of content is indicated */

					p_ie += NS_ASN1_END_OF_CONTENT_SIZE;	/* skip End-Of-Content octets */
					indefinite_lgth = 0;					/* reset flag for further use */
					p_end_component = p_ie;					/* update current pointer */

				} else {	/* end of component is not reached */

					indefinite_lgth = 1;		/* restore flag for further use */
				}
			}

			if (p_ie == p_end_component) {

					/* end of component is reached, other fields are optional */

				I_ss_fac_is_result_here = ABSENT;
				break;
			}

			if (ie_octet != Ns_tag_from_class_form_nb (FAC_UNIVERSAL, FAC_CONSTRUCTOR, FAC_SEQUENCE_TAG)) {

				return (NOK);
			}

			p_ie++;		/* set p_ie pointer to begin of length field */
			I_ss_fac_is_result_here = PRESENT;

				/* check length of SEQUENCE in component */

			length = ns_decode_asn1_lgth ();

			if (length == NS_ASN1_INDEFINITE_LGTH) {

				indefinite_lgth += 2;	/* Use second Bit to store Indefinite Form flag */
			}

			if ((length == BAD_ASN1_LGTH) ||
				((indefinite_lgth == 0) && (p_ie + length != p_end_component))) {

				return (NOK);
			}

				/* decode OPERATION value and RESULT clause */

			if (ns_decode_ss_op_err_val (p_end_component, NS_FLAG_OPERATION_RESULT) == NOK) {

				return (NOK);
			}

			if (indefinite_lgth >= 2) {

					/* SEQUENCE in component is decoded : p_ie should point to the End-Of-Content octets of the SEQUENCE */

				if ((p_ie + NS_ASN1_END_OF_CONTENT_SIZE) > p_end_component) {

					return (NOK);
				}

				for (ie_octet = 0; ie_octet < NS_ASN1_END_OF_CONTENT_SIZE; ie_octet++) {

					if (*p_ie++ != NS_ASN1_END_OF_CONTENT_VAL) {

						return (NOK);
					}
				}

				indefinite_lgth -= 2;		/* update flag for further use */
			}

			break;

		case FAC_RETURN_ERROR :

				/* decode ERROR value and PARAMETER clause */

			if (ns_decode_ss_op_err_val (p_end_component, NS_FLAG_ERROR_PARAMETER) == NOK) {

				return (NOK);
			}

			break;

		case FAC_REJECT :

				/* check problem tag */

			if (ns_check_get_tag (FAC_PROBLEM_TAG_TAB, SIZE_FAC_PROBLEM_TAG_TAB,
								  ie_octet, &(I_ss_fac_problem_tag)) == NOK) {

				return (NOK);
			}

			p_ie++;		/* set p_ie pointer to begin of length field */
			if (((length = ns_decode_asn1_lgth ()) != 1) ||
				((indefinite_lgth == 0) && (p_ie + length != p_end_component))) {

				return (NOK);
			}

			ie_octet = Get_inc_ie_octet;
			I_ss_fac_problem = ie_octet;
			break;
	}

	if (indefinite_lgth == 1) {

			/* facility component is decoded : p_ie should point to the End-Of-Content octets of the component */

		if ((p_ie + NS_ASN1_END_OF_CONTENT_SIZE) > p_end_component) {

			return (NOK);
		}

		for (ie_octet = 0; ie_octet < NS_ASN1_END_OF_CONTENT_SIZE; ie_octet++) {

			if (*p_ie++ != NS_ASN1_END_OF_CONTENT_VAL) {

				return (NOK);
			}
		}

		p_end_component = p_ie;
	}

	if (p_ie != p_end_component) {

			/* facility component is decoded : p_ie should point to the end of the component (after)
				-> if not, length of the component is inconsistent with data structure */

		return (NOK);
	}

		/* store values decoded by ASN1 mechanism into internal structures */

	ns_ss_store_internal_value ();

		/* increment current variables used for FACILITY and analyse next component if any */

	return (OK);
}

	/* -=-=-=-=-=-=-=-=-=-=- */

uchar qsi_fac_component_to_spdu ()
{
	uchar FAR	*p_component_lgth;			/* pointer to location of component length */
	uchar FAR	*p_sequence_lgth;			/* pointer to location of SEQUENCE length */
	ushort		length;						/* current length of SEQUENCE in component */

		/* put tag (class, form, nb) of component into SPDU */

	*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_CONSTRUCTOR, I_ss_fac_comp_tag);
	p_component_lgth = p_ie;		/* set p_component_lgth to location of component length (to be computed) */
	p_ie++;			/* skip length */

	if (I_ss_fac_comp_tag != FAC_REJECT) {

		if ((I_ss_fac_comp_tag != FAC_RETURN_RESULT) || (I_ss_fac_is_result_here == PRESENT)) {

			p_ie++;		/* skip length : maximum value is 255 coded on 2 octets (ASN1 coding) */
		}
	}

	if ((I_ss_fac_comp_tag != FAC_REJECT) || (I_ss_fac_is_inv_id_here == PRESENT)) {

			/* Invoke identifier is present : encode it (type is INTEGER (UNIVERSAL)), 'length' is used for unsigned value */

		*p_ie++ = Ns_tag_from_class_form_nb (FAC_UNIVERSAL, FAC_PRIMITIVE, FAC_INTEGER_TAG);

		if (I_ss_fac_invoke_id < 0) {

			length = (ushort)(I_ss_fac_invoke_id * (-1));
			Asn1_encode_integer ((ulong)length, ASN1_CODING_NEGATIVE, &p_ie, p_ie + 5);

		} else {

			length = (ushort)(I_ss_fac_invoke_id);
			Asn1_encode_integer ((ulong)length, ASN1_CODING_POSITIVE, &p_ie, p_ie + 5);
		}

	} else {

			/* Invoke identifier is absent : NULL value is to be encoded (in Reject component) -> Tag + Length = 0 */

		*p_ie++ = Ns_tag_from_class_form_nb (FAC_UNIVERSAL, FAC_PRIMITIVE, FAC_NULL_TAG);
		*p_ie++ = 0;
	}

	switch (I_ss_fac_comp_tag) {	/* process according to component tag */

		case FAC_REJECT :

				/* set problem (tag, length, value) in SPDU and total length of component */

			*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, I_ss_fac_problem_tag);
			Asn1_encode_integer ((ulong)I_ss_fac_problem, ASN1_CODING_POSITIVE, &p_ie, p_ie + 5);
			*p_component_lgth = (uchar)((ulong)p_ie - (ulong)p_component_lgth - 1);
			p_component_lgth = P_NIL;
			break;

		case FAC_INVOKE :

			if (I_ss_fac_is_lk_id_here == PRESENT) {	/* set Linked ID in SPDU if it is present */

				*p_ie++ = Ns_tag_from_class_form_nb (FAC_CONTEXT_SPECIFIC, FAC_PRIMITIVE, FAC_LINKED_ID_TAG);

				if (I_ss_fac_linked_id < 0) {

					length = (ushort)(I_ss_fac_linked_id * (-1));
					Asn1_encode_integer ((ulong)length, ASN1_CODING_NEGATIVE, &p_ie, p_ie + 5);

				} else {

					length = (ushort)(I_ss_fac_linked_id);
					Asn1_encode_integer ((ulong)length, ASN1_CODING_POSITIVE, &p_ie, p_ie + 5);
				}
			}

				/* encode OPERATION value and ARGUMENT clause */

			if (ns_encode_ss_op_err_val (NS_FLAG_OPERATION_ARGUMENT) == NOK) {

				return (NOK);
			}

			break;

		case FAC_RETURN_RESULT :

			if (I_ss_fac_is_result_here != PRESENT) {

				/*	no operation data provided (optional) : end of component is reached
					-> set total length of component */

				*p_component_lgth = (uchar)((ulong)p_ie - (ulong)p_component_lgth - 1);
				p_component_lgth = P_NIL;
				break;
			}

				/* put SEQUENCE flag into SPDU, set pointer to length location and skip length */

			*p_ie++ = Ns_tag_from_class_form_nb (FAC_UNIVERSAL, FAC_CONSTRUCTOR, FAC_SEQUENCE_TAG);
			p_sequence_lgth = p_ie;
			p_ie += 2;

				/* encode OPERATION value and RESULT clause */

			if (ns_encode_ss_op_err_val (NS_FLAG_OPERATION_RESULT) == NOK) {

				return (NOK);
			}

				/* compute length of sequence and set it in SPDU (on 2 octets) */

			length = (ushort)((ulong)p_ie - (ulong)p_sequence_lgth - 2);
			if (length > 255) {

				return (NOK);
			}

			ns_encode_asn1_lgth (p_sequence_lgth, (uchar)length);
			break;

		case FAC_RETURN_ERROR :

				/* encode ERROR value and PARAMETER clause */

			if (ns_encode_ss_op_err_val (NS_FLAG_ERROR_PARAMETER) == NOK) {

				return (NOK);
			}

			break;

	} /* end of switch on component tag */

		/* if not already done, compute total length of component and set it in SPDU (on 2 octets) */

	if (p_component_lgth != P_NIL) {

		length = (ushort)((ulong)p_ie - (ulong)p_component_lgth - 2);

		if (length > 255) {

			return (NOK);
		}

		ns_encode_asn1_lgth (p_component_lgth, (uchar)length);
	}

	return (OK);
}

/*=========================================================================*
					 F U N C T I O N   H E A D E R

Name            qsi_facility_ssdu - implements the decoding or encoding of a
				FACILITY IE received or to be sent in a ssdu.

Usage           uchar	qsi_facility_ssdu (void);

Return value	OK / NOK

common objects : internal data structure i_facility, ie ssdu context,
				 direction (FROM or TO CALL CONTROL), ns_fac_components array,
				 global pointers : p_ns_fac_component, p_ns_ss_op_err_tab.

*--------------------------------------------------------------------------*/

uchar qsi_facility_ssdu ()
{
	uchar				i;							/* loop index */
	uchar				size;						/* size of current string */
	uchar FAR			*p_fac_start;				/* pointer to start of Facility IE inside SSDU */
	uchar FAR			*p_first_comp;				/* pointer to first component data inside Facility IE */

		/* get country specific tables for operations and errors */

	ns_get_country_op_err_tab (Na_country);

	if (p_ns_ss_op_err_tab == P_NIL) {

		return (NOK);		/* no Table found -> no supplementary service in current country */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (ns_x_ss_fac_comp >= NS_MX_FAC_COMPONENTS) {

			return (NOK);	/* number of facility components in SSDU is too high */
		}

		p_ns_fac_component = &(ns_fac_components[ns_x_ss_fac_comp]);	/* set pointer to common component data */
		I_facility_first_comp_x = ns_x_ss_fac_comp;						/* store index in common array of first component in Facility IE */

			/* set current pointer to first component inside facility data */

		p_ssdu_val 	-= sizeof (ns_offset_t);
#		if NS_IE_TSP_OUT == ON
			p_ssdu_val -= SIZEOF_TSP_OFFSET;
#		endif

		p_fac_start = p_ssdu_val;

			/* get data for NetworkFacilityExtension and InterpretationAPDU from SSDU */

		ns_qsi_fac_start[i_ie_x].nfe_source = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source;

		if (((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source != BYTE_VAL_NIL) {

				/* NetworkFacilityExtension is present */

			p_ssdu_val = &(((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_first_add);
			ns_qsi_fac_start[i_ie_x].nfe_source_t_of_nb = BYTE_VAL_NIL;
			if (((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_p_nb_t == BYTE_VAL_NIL) {

				ns_qsi_fac_start[i_ie_x].nfe_source_p_nb_t = 254;
				ns_qsi_fac_start[i_ie_x].nfe_source_add.size = 255;
				ns_qsi_fac_start[i_ie_x].nfe_source_add.p_string = P_NIL;

			} else {	/* source entity adress is present */

				if (((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* Bad type of PartyNumber in address of source entity */
				}

				ns_qsi_fac_start[i_ie_x].nfe_source_p_nb_t = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_p_nb_t;
				if ((ns_qsi_fac_start[i_ie_x].nfe_source_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
					(ns_qsi_fac_start[i_ie_x].nfe_source_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

					ns_qsi_fac_start[i_ie_x].nfe_source_t_of_nb = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_t_of_nb;
				}

					/* source entity address string : at the end of the 'val_ns_qsi_facility' structure */
				ns_qsi_fac_start[i_ie_x].nfe_source_add.size = size = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_add_sz;
				ns_qsi_fac_start[i_ie_x].nfe_source_add.p_string = p_ind_buffer;
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_ssdu_val, size);
				p_ssdu_val += size;
				p_ind_buffer += size;
			}

			ns_qsi_fac_start[i_ie_x].nfe_dest = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest;
			if (((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_p_nb_t == BYTE_VAL_NIL) {

				ns_qsi_fac_start[i_ie_x].nfe_dest_p_nb_t = 254;
				ns_qsi_fac_start[i_ie_x].nfe_dest_t_of_nb = BYTE_VAL_NIL;
				ns_qsi_fac_start[i_ie_x].nfe_dest_add.size = 255;
				ns_qsi_fac_start[i_ie_x].nfe_dest_add.p_string = P_NIL;

			} else {	/* destination entity adress is present */

				if (((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* Bad type of PartyNumber in address of destination entity */
				}

				ns_qsi_fac_start[i_ie_x].nfe_dest_p_nb_t = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_p_nb_t;
				ns_qsi_fac_start[i_ie_x].nfe_dest_t_of_nb = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_t_of_nb;

					/* destination entity address string : at the end of the 'val_ns_qsi_facility' structure, after source entity address */
				ns_qsi_fac_start[i_ie_x].nfe_dest_add.size = size = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_add_sz;
				ns_qsi_fac_start[i_ie_x].nfe_dest_add.p_string = p_ind_buffer;
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_ssdu_val, size);
				p_ind_buffer += size;
			}
        }

		ns_qsi_fac_start[i_ie_x].interpretation = ((struct val_ns_qsi_facility FAR *)p_fac_start) -> interpretation;
		I_facility_component_nb = 0;

			/* get location of first APDU inside Facility IE */

		p_ssdu_val = p_fac_start + ((struct val_ns_qsi_facility FAR *)p_fac_start) -> first_apdu_offset;

			/* loop on all APDUs in Facility IE */

		while (TRUE) {  

				/* first octet is the Type of APDU : RoseAPDU or DseAPDU */

			if (*p_ssdu_val == QSI_ROSE_APDU_TAG) {	/* RoseAPDU */

				I_ss_fac_apdu_type = QSI_ROSE_APDU_TAG;

					/* set pointers to first component inside facility data */

				p_first_comp = (uchar FAR *)&(((struct ns_ss_qsi_rose_apdu FAR *)p_ssdu_val) -> component);
				p_ssdu_val = p_first_comp;

					/* process component stored into internal structure : 'size' is used here as "last component indicator" */

				i = ns_ss_fac_comp_from_ssdu ();	/* process of current component */

				if (i == NOK) {

					return (NOK);	/* component is invalid -> Return NOK */
				}

				if (I_ss_fac_comp_tag == FAC_REJECT) {	/* Reject component : check the type and identifier of problem */

					if (I_ss_fac_problem_tag > REJ_RET_ERROR_PB_TAG) {

						return (NOK);
					}
				}

					/* component is valid -> increment current index and number of components stored */

				ns_x_ss_fac_comp++;
				I_facility_component_nb++;

				if (i == STOP) {	/* this is the last component -> Return OK */

					return (OK);
				}

				if (ns_x_ss_fac_comp >= NS_MX_FAC_COMPONENTS) {

					return (NOK);	/* number of facility components in SSDU is too high */
				}

				p_ns_fac_component++;		/* get internal data location of next component */

			} else {	/* DseAPDU */

				if (*p_ssdu_val != QSI_DSE_APDU_TAG) {

					return (NOK);		/* Bad type of APDU */
				}

				I_ss_fac_apdu_type = ((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> dse_pdu_type;
				I_ss_fac_cause_or_nb = ((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> component_nb;
				I_ss_fac_orig_abort_sz = ((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> orig_dialog_or_abort_info_sz;
				I_ss_fac_dest_sz = ((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> destination_dialog_sz;

					/* set pointer to end of structure inside SSDU in order to copy strings */

				p_first_comp = &(((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> first_str);

				switch (I_ss_fac_apdu_type) {

					case QSI_DSE_ABORT_PDU_TAG :

						if (I_ss_fac_cause_or_nb != 0) {

							return (NOK);	/* number of components should be null */
						}

						I_ss_fac_cause_or_nb = ((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> p_abort_cause;
                        size = 0;		/* init 'size' for further use (as component counter) */

						if ((I_ss_fac_cause_or_nb != BYTE_VAL_NIL) && (I_ss_fac_orig_abort_sz != 0)) {

							return (NOK);	/* both 'P-AbortCause' and 'UserAbortInformation' fields are not permitted */
						}

							/* first dialogID string : at the end of the 'ns_ss_qsi_dse_apdu' structure */
						I_ss_fac_p_dest = p_ind_buffer;
						Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_first_comp, I_ss_fac_dest_sz);
						p_first_comp += I_ss_fac_dest_sz;
						p_ind_buffer += I_ss_fac_dest_sz;
						break;

					case QSI_DSE_BEGIN_PDU_TAG :

						if (I_ss_fac_dest_sz != 0) {

							return (NOK);	/* no destinationDialogID in BeginPDU */
						}

						break;

					case QSI_DSE_END_PDU_TAG :

						if (I_ss_fac_orig_abort_sz != 0) {

							return (NOK);	/* no originationDialogID in EndPDU */
						}

						break;

					case QSI_DSE_CONTINUE_PDU_TAG :

						break;

					default :	/* Bad type of DsePDU */

						return (NOK);
				}

					/* first dialogID string (or second string for AbortPDU) : at the end of the 'ns_ss_qsi_dse_apdu' structure */
				I_ss_fac_p_orig_abort = p_ind_buffer;
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_first_comp, I_ss_fac_orig_abort_sz);
				p_first_comp += I_ss_fac_orig_abort_sz;
				p_ind_buffer += I_ss_fac_orig_abort_sz;

				if (I_ss_fac_apdu_type != QSI_DSE_ABORT_PDU_TAG) {

						/* second string(if any) : at the end of the structure, after first dialogID string */
					I_ss_fac_p_dest = p_ind_buffer;
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_first_comp, I_ss_fac_dest_sz);
					p_ind_buffer += I_ss_fac_dest_sz;
					size = I_ss_fac_cause_or_nb;	/* use 'size' as component counter */
				}

				if (((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> first_comp_offset == OFFSET_NIL) {

						/*	This is the last component in SSDU -> check that there is no component
							in current DseAPDU ('nb of components' should be null) and return OK */

					if (size != 0) {

						return (NOK);
					}

					ns_x_ss_fac_comp++;
					I_facility_component_nb++;
					return (OK);
				}

					/* set pointers to first component inside DSeAPDU data (or to next APDU) */

				p_first_comp = p_ssdu_val + ((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> first_comp_offset;
				p_ssdu_val = p_first_comp;

				if (size == 0) {	/* no component in current DseAPDU -> next APDU */

					ns_x_ss_fac_comp++;
					I_facility_component_nb++;
					p_ns_fac_component++;		/* get internal data location of next component */
				}

					/* process all components in DseAPDU (inside RemoteOperationsPortion) */

				while (size-- > 0) {

					i = ns_ss_fac_comp_from_ssdu ();	/* process of current component */

					if (i == NOK) {

						return (NOK);	/* component is invalid -> Return NOK */
					}

					if (I_ss_fac_comp_tag == FAC_REJECT) {	/* Reject component : check the type and identifier of problem */

						if (I_ss_fac_problem_tag > REJ_RET_ERROR_PB_TAG) {

							return (NOK);
						}
					}

						/* component is valid -> increment current index and number of components stored */

					ns_x_ss_fac_comp++;
					I_facility_component_nb++;

					if (i == STOP) {	/* this is the last component */

						if (size != 0) {	/* 'Nb of components' specified in DseAPDU is not consistent with component data */

							return (NOK);
						}

						return (OK);	/* end of Facility IE -> Return OK */
					}

					if (ns_x_ss_fac_comp >= NS_MX_FAC_COMPONENTS) {

						return (NOK);	/* number of facility components in SSDU is too high */
					}

					p_ns_fac_component++;		/* get internal data location of next component */

				}	/* end of process of components in current DseAPDU */
			}

		} /* end of loop on all APDUs in Facility IE */

	} else {		/* TO CALL CONTROL */

		ns_x_ss_fac_comp = I_facility_first_comp_x;						/* get index in common array of first component in Facility IE */
		p_ns_fac_component = &(ns_fac_components[ns_x_ss_fac_comp]);	/* get pointer to common component data */

		if ((ns_x_ss_fac_comp + I_facility_component_nb) > NS_MX_FAC_COMPONENTS) {

				/* nb of components stored in i_facility is too high : it should not happen for it has been checked during SPDU process */

			return (NOK);
		}

			/* set current pointer to start of facility data */

		p_ssdu_val 	-= sizeof (ns_offset_t);
#		if NS_IE_TSP_OUT == ON
			p_ssdu_val -= SIZEOF_TSP_OFFSET;
#		endif

		p_fac_start = p_ssdu_val;
		p_ssdu_val = &(((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_first_add);

			/* put data for NetworkFacilityExtension and InterpretationAPDU into SSDU */

		((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source = ns_qsi_fac_start[i_ie_x].nfe_source;

		if (((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source != BYTE_VAL_NIL) {

				/* NetworkFacilityExtension is present */

			switch (ns_qsi_fac_start[i_ie_x].nfe_source_p_nb_t) {

				default :

						/* PartyNumber is present but is neither "Public" nor "Private" : 'Type of Number' is
							meaningless and the value stored for Source Address is in fact the one for Destination Address */

					ns_qsi_fac_start[i_ie_x].nfe_dest_t_of_nb = ns_qsi_fac_start[i_ie_x].nfe_source_t_of_nb;
                    ns_qsi_fac_start[i_ie_x].nfe_source_t_of_nb = 255;
                    break;

				case NS_SS_PARTY_NB_PUBLIC :
				case NS_SS_PARTY_NB_PRIVATE :
				case 255 :

					break;
			}

			((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_p_nb_t = ns_qsi_fac_start[i_ie_x].nfe_source_p_nb_t;
			((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_t_of_nb = ns_qsi_fac_start[i_ie_x].nfe_source_t_of_nb;
			((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_source_add_sz = size = ns_qsi_fac_start[i_ie_x].nfe_source_add.size;

				/* source entity address string : at the end of the 'val_ns_qsi_facility' structure */
			Memcpy_far ((char FAR *)p_ssdu_val, (char FAR *)(ns_qsi_fac_start[i_ie_x].nfe_source_add.p_string), size);
			p_ssdu_val += size;

			((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest = ns_qsi_fac_start[i_ie_x].nfe_dest;
			((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_p_nb_t = ns_qsi_fac_start[i_ie_x].nfe_dest_p_nb_t;
			((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_t_of_nb = ns_qsi_fac_start[i_ie_x].nfe_dest_t_of_nb;
			((struct val_ns_qsi_facility FAR *)p_fac_start) -> nfe_dest_add_sz = size = ns_qsi_fac_start[i_ie_x].nfe_dest_add.size;

				/* destination entity address string : at the end of the structure, after source entity address string */
			Memcpy_far ((char FAR *)p_ssdu_val, (char FAR *)(ns_qsi_fac_start[i_ie_x].nfe_dest_add.p_string), size);
			p_ssdu_val += size;
		}

		((struct val_ns_qsi_facility FAR *)p_fac_start) -> interpretation = ns_qsi_fac_start[i_ie_x].interpretation;
		((struct val_ns_qsi_facility FAR *)p_fac_start) -> component_nb = i = I_facility_component_nb;

		p_ssdu_val = (uchar FAR *)Round ((long)p_ssdu_val);		/* Structure alignment inside SSDU */

			/* set offset indicating location of first APDU inside SSDU */

		((struct val_ns_qsi_facility FAR *)p_fac_start) -> first_apdu_offset = (ushort)((ulong)p_ssdu_val - (ulong)p_fac_start);

			/* loop on all APDUs in Facility IE */

		while (i > 0) {

				/* first octet is the Type of APDU : RoseAPDU or DseAPDU */

			if (I_ss_fac_apdu_type == QSI_ROSE_APDU_TAG) {	/* RoseAPDU */

				*p_ssdu_val = QSI_ROSE_APDU_TAG;

					/* set pointers to first component inside facility data */

				p_first_comp = (uchar FAR *)&(((struct ns_ss_qsi_rose_apdu FAR *)p_ssdu_val) -> component);
				p_ssdu_val = p_first_comp;

					/* process component stored into internal structure : 'size' is used here as "last component indicator" */

				size = (i == 1) ? ON : OFF;
				if (ns_ss_fac_comp_in_ssdu (size) == NOK) {

					return (NOK);
				}

				ns_x_ss_fac_comp++;
				p_ns_fac_component++;
				i--;

			} else {	/* DseAPDU */

				*p_ssdu_val = QSI_DSE_APDU_TAG;
				((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> dse_pdu_type = I_ss_fac_apdu_type;
				((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> component_nb = I_ss_fac_cause_or_nb;
				((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> p_abort_cause = BYTE_VAL_NIL;

					/* set pointer to end of structure inside SSDU in order to copy strings */

				p_first_comp = &(((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> first_str);

				switch (I_ss_fac_apdu_type) {

					case QSI_DSE_ABORT_PDU_TAG :

						((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> p_abort_cause = I_ss_fac_cause_or_nb;
						I_ss_fac_cause_or_nb = 0;	/* re-init for further use */
						((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> component_nb = 0;
							/* first dialogID string : at the end of the 'ns_ss_qsi_dse_apdu' structure */
						Memcpy_far ((char FAR *)p_first_comp, (char FAR *)(I_ss_fac_p_dest), I_ss_fac_dest_sz);
						p_first_comp += I_ss_fac_dest_sz;
						break;

					case QSI_DSE_BEGIN_PDU_TAG :

						I_ss_fac_dest_sz = 0;
						break;

					case QSI_DSE_END_PDU_TAG :

						I_ss_fac_orig_abort_sz = 0;
						break;
				}

				((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> orig_dialog_or_abort_info_sz = I_ss_fac_orig_abort_sz;
				((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> destination_dialog_sz = I_ss_fac_dest_sz;

					/* first dialogID string (or second string for AbortPDU) : at the end of the 'ns_ss_qsi_dse_apdu' structure */
				Memcpy_far ((char FAR *)p_first_comp, (char FAR *)(I_ss_fac_p_orig_abort), I_ss_fac_orig_abort_sz);
				p_first_comp += I_ss_fac_orig_abort_sz;

				if (I_ss_fac_apdu_type != QSI_DSE_ABORT_PDU_TAG) {

						/* second string(if any) : at the end of the structure, after first dialogID string */
					Memcpy_far ((char FAR *)p_first_comp, (char FAR *)(I_ss_fac_p_dest), I_ss_fac_dest_sz);
					p_first_comp += I_ss_fac_dest_sz;
				}

				p_first_comp = (uchar FAR *)Round ((long)p_first_comp);		/* Structure alignment inside SSDU */

					/*	if no RoseAPDU in current DseAPDU, update current variables
						indicating thet this component has been processed */

				if ((size = I_ss_fac_cause_or_nb) == 0) {

					ns_x_ss_fac_comp++;
					p_ns_fac_component++;
					i--;
				}

					/* set offset indicating location of first component inside DseAPDU */

				if (i == 0) {

					((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> first_comp_offset = OFFSET_NIL;

				} else {

					((struct ns_ss_qsi_dse_apdu FAR *)p_ssdu_val) -> first_comp_offset = (ushort)((ulong)p_first_comp - (ulong)p_ssdu_val);
				}

				p_ssdu_val = p_first_comp;		/* update current SSDU value pointer */

				if (size != 0) {

						/* process list of components stored into internal structures and related to current DseAPDU */

					if (size > i) {

                    	return (NOK);	/* total number of components in IE is inconsistent with number of components in current DseAPDU */
					}

					while (size-- > 0) {

						if (ns_ss_fac_comp_in_ssdu ((i == 1) ? ON :OFF) == NOK) {

							return (NOK);
						}

						ns_x_ss_fac_comp++;
						p_ns_fac_component++;
						i--;
					}
				}

			} /* end of DseAPDU */

		} /* end of loop on all APDUs in Facility IE */

			/* set total size inside facility IE and return OK */

		((struct val_ns_qsi_facility FAR *)p_fac_start) -> size = (ushort)((ulong)p_ssdu_val - (ulong)p_fac_start);
		return (OK);

	}	/* end of direction = TO CALL CONTROL */
}


/* EOF */
