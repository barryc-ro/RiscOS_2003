
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ns_ss.qsi
 *
 * $Revision$
 *
 * $Date$
 *
 *		This file contains the descriptions of all OPERATIONs and ERRORs
 *		used for Supplementary Services in Q-SIG.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|														|*/
/*[]---------------------------------------------------[]*/

		/* Common internal data for Facility IE specific to Q-SIG
		 * ------------------------------------------------------ */

struct ns_qsi_fac_start {
		/* NetworkFacilityExtension : absent if nfe_source = BYTE_VAL_NIL */
	struct ns_asn1_string	nfe_source_add;	/* source entity address string inside NetworkFacilityExtension */
	struct ns_asn1_string	nfe_dest_add;	/* destination entity address size inside NetworkFacilityExtension */

	uchar		nfe_source;			/* type of source entity inside NetworkFacilityExtension */
	uchar		nfe_source_p_nb_t;	/* type of PartyNumber in source entity address inside NetworkFacilityExtension */
	uchar		nfe_source_t_of_nb;	/* type of Number in source entity address inside NetworkFacilityExtension */
	uchar		nfe_dest;			/* type of destination entity inside NetworkFacilityExtension */
	uchar		nfe_dest_p_nb_t;	/* type of PartyNumber in destination entity address inside NetworkFacilityExtension */
	uchar		nfe_dest_t_of_nb;	/* type of Number in destination entity address inside NetworkFacilityExtension */

	uchar		interpretation;		/* InterpretationApdu or BYTE_VAL_NIL if absent */

} ns_qsi_fac_start [MX_FACILITY];

/*==========================================================================*/

	/* definitions for general ASN1 types (with ASN1 meta-programs)
	 * ------------------------------------------------------------ */

		/* list of presence indicators for instances of 'CharacterSet' inside NameSet */

#define Qsi_character_in_name_set		(ns_asn1_optional_indicators + 3)

		/* NameData ::= OCTET STRING (SIZE (1..50)) */

#define NS_SS_QSI_NAME_DATA_P			NS_SS_OCTET_STRING_P

		/* CharacterSet ::= INTEGER {unknown(0), iso8859-1(1),t-61(2)}(1..255) */

#define NS_SS_QSI_CHARACTER_SET_P		NS_SS_INTEGER_P

/*==========================================================================*/

	/* functions used to process transparent "extension" in SSDU used in many operations */

#if NEW_FCT_STYLE == ON
	uchar	ns_ssdu_op_qsi_tsp_extension	(struct ns_asn1_string FAR *p_i_data);
#else
	uchar	ns_ssdu_op_qsi_tsp_extension	();
#endif

uchar ns_ssdu_op_qsi_tsp_extension (p_i_data)
	struct ns_asn1_string FAR		*p_i_data;			/* pointer to internal data location */
{
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		p_i_data -> size = size = Ns_qsi_tsp_extension_sz;
		p_i_data -> p_string = p_ind_buffer;
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)&(Ns_qsi_tsp_first_extension), size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		Ns_qsi_tsp_extension_sz = size = p_i_data -> size;
		p_ssdu_val = &(Ns_qsi_tsp_first_extension);		/* set current pointer to first string octet */
		Memcpy_far ((char FAR *)p_ssdu_val, (char FAR *)(p_i_data -> p_string), size);
		p_ssdu_val += size;
		p_ssdu_val = (uchar FAR *)Round ((long)p_ssdu_val);		/* Structure alignment inside SSDU */
	}

	return (OK);
}

	/*** error internal data (PARAMETER clause) : only for "Unspecified" error ***/

struct ns_asn1_string	ns_err_qsi_unspecified;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* function used to process error content in SSDU : only for "Unspecified" error */

uchar ns_ssdu_err_qsi_unspecified (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (OK);	/* no data */
		}

		p_ssdu_val = p_start + offset;					/* get error content location */
	}

	return (ns_ssdu_op_qsi_tsp_extension (&ns_err_qsi_unspecified));
}

/*==========================================================================*/

		/*	Name Identification SS, including 2 services : Calling Name Identification
		 *	Presentation (SS-CNIP), Connected Name Identification Presentation (SS-CONP)
		 * ----------------------------------------------------------------------------- */

#if NS_SS_NAME_IDENT == ON /* { */

		/* lists of presence indicators for instances of Types Marked OPTIONAL (or DEFAULT) inside ASN1 SEQUENCE type */

#define Qsi_name_id_extension			ns_asn1_optional_indicators				/* 'extension' inside all operation ARGUMENT : 1 indicator */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument */

struct	ns_op_qsi_name_ident {
	struct ns_asn1_string	name;						/* NameData string inside Name */
	struct ns_asn1_string	extension;					/* extension string */
	uchar					name_type;					/* type of Name */
	uchar					character;					/* CharacterSet inside Name */
	uchar					choice_index;				/* index of chosen type in global CHOICE between Name and SEQUENCE :
															this index is set internally according to presence of "extension" */
};

struct ns_op_qsi_name_ident		ns_op_qsi_calling_name_id;			/* CallingName operation ARGUMENT */
struct ns_op_qsi_name_ident		ns_op_qsi_called_name_id;			/* CalledName operation ARGUMENT */
struct ns_op_qsi_name_ident		ns_op_qsi_connected_name_id;		/* ConnectedName operation ARGUMENT */
struct ns_op_qsi_name_ident		ns_op_qsi_busy_name_id;				/* BusyName operation ARGUMENT */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* function used to process operation content in SSDU */

uchar ns_ssdu_op_qsi_name_ident (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar							size;			/* size of current string */
	struct ns_op_qsi_name_ident FAR	*p_i_data;		/* pointer to internal data location */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	switch (I_ss_fac_op_err_id) {	/* set internal data pointer according to operation ID */

		case NS_OP_QSI_CALLING_NAME_ID :	/* calling Name */

			p_i_data = &ns_op_qsi_calling_name_id;
			break;

		case NS_OP_QSI_CALLED_NAME_ID :		/* called Name */

			p_i_data = &ns_op_qsi_called_name_id;
			break;

		case NS_OP_QSI_CONNECTED_NAME_ID :	/* connected Name */

			p_i_data = &ns_op_qsi_connected_name_id;
			break;

		case NS_OP_QSI_BUSY_NAME_ID :	/* busy Name */

			p_i_data = &ns_op_qsi_busy_name_id;
			break;
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_qsi_name_ident_type > NS_SS_QSI_MX_NAME_TYPE) {

        	return (NOK);	/* bad type of Name */
		}

		p_i_data -> name_type = Ns_qsi_name_ident_type;
		p_next = &(Ns_qsi_name_ident_first_str);

		if (Ns_qsi_name_ident_type != NS_SS_QSI_NAME_NOT_AVAIL) {	/* Name includes a string */

			p_i_data -> character = (Ns_qsi_name_ident_char == 255) ? 254 : Ns_qsi_name_ident_char;
			p_i_data -> name.size = size = Ns_qsi_name_ident_size;
			p_i_data -> name.p_string = p_ind_buffer;
				/* Name string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		size = Ns_qsi_name_ident_ext_size;
		if (size == 0) {	/* no "extension" -> choose first Type in CHOICE = Name */

			p_i_data -> choice_index = 0;

		} else {	/* "extension" is present -> choose second Type in CHOICE = SEQUENCE */

			p_i_data -> choice_index = 1;
			p_i_data -> extension.size = size;
			p_i_data -> extension.p_string = p_ind_buffer;
				/* extension string : at the end of the structure, after Name string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
		}

	} else {	/* to CALL CONTROL */

		Ns_qsi_name_ident_type = p_i_data -> name_type;
		p_next = &(Ns_qsi_name_ident_first_str);
		Ns_qsi_name_ident_char = p_i_data -> character;
		Ns_qsi_name_ident_size = size = p_i_data -> name.size;
			/* Name string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_i_data -> name.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_name_ident_ext_size = size = p_i_data -> extension.size;
			/* extension string : at the end of the structure, after Name string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_i_data -> extension.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif /* end of "NS_SS_NAME_IDENT = ON"} */

/*==========================================================================*/

		/*	Diversion SS, including 4 services : Call Forwarding Unconditional (CFU),
		 *	Call Forwarding Busy (CFB), Call Forwarding No Reply (CFNR), Call Deflection (CD)
		 * ------------------------------------------------------------------ */

#if NS_SS_DIVERSION == ON /* { */

		/* lists of presence indicators for instances of Types Marked OPTIONAL (or DEFAULT) inside ASN1 SEQUENCE type */

#define Qsi_div_activate_extension		(ns_asn1_optional_indicators + 1)		/* 'extension' inside ActivateDiversionQ ARGUMENT : 1 indicator */
#define Qsi_div_dea_extension			ns_asn1_optional_indicators				/* 'extension' inside DeactivateDiversionQ ARGUMENT : 1 indicator */
#define Qsi_div_interog_service			ns_asn1_optional_indicators				/* 'basic_service' inside InterrogateDiversionQ ARGUMENT : 1 indicator */
#define Qsi_div_interog_extension		(ns_asn1_optional_indicators + 1)		/* 'extension' inside InterrogateDiversionQ ARGUMENT : 1 indicator */
#define Qsi_div_chk_rest_extension		ns_asn1_optional_indicators				/* 'extension' inside CheckRestriction ARGUMENT : 1 indicator */

			/* inside CallRerouting ARGUMENT :
				- 2 indicators (0 and 1) for 'OddCountIndicator' in SubAddress (in calledAddress and callingPartySubaddress)
				- 1 indicator (2) for 'Subaddress' in Address (in calledAddress)
				- 3 indicators (3, 4 and 5) for 'CharacterSet' in NameSet
				- 1 indicator (6) for 'callingPartySubaddress' in ARGUMENT
				- 1 indicator (7) for 'callingName' in ARGUMENT
				- 1 indicator (8) for 'originalCalledNumber' in ARGUMENT
				- 1 indicator (9) for 'redirectingName' in ARGUMENT
				- 1 indicator (10) for 'originalCalledName' in ARGUMENT
				- 1 indicator (11) for 'extension' in ARGUMENT
			*/
#define Qsi_div_rerout_calling_sa		(ns_asn1_optional_indicators + 6)
#define Qsi_div_rerout_calling_nm		(ns_asn1_optional_indicators + 7)
#define Qsi_div_rerout_orig_nb			(ns_asn1_optional_indicators + 8)
#define Qsi_div_rerout_redir_nm			(ns_asn1_optional_indicators + 9)
#define Qsi_div_rerout_orig_nm			(ns_asn1_optional_indicators + 10)
#define Qsi_div_rerout_extension		(ns_asn1_optional_indicators + 11)

#define Qsi_div_leg_1_extension			ns_asn1_optional_indicators				/* 'extension' inside DivertingLegInformation1 ARGUMENT : 1 indicator */

#define Qsi_div_leg_2_diverting_nb		ns_asn1_optional_indicators				/* 'divertingNr' inside DivertingLegInformation2 ARGUMENT : 1 indicator */
#define Qsi_div_leg_2_orig_nb			(ns_asn1_optional_indicators + 1)		/* 'originalCalledNr' inside DivertingLegInformation2 ARGUMENT : 1 indicator */
#define Qsi_div_leg_2_redir_name		(ns_asn1_optional_indicators + 2)		/* 'redirectingName' inside DivertingLegInformation2 ARGUMENT : 1 indicator */
#define Qsi_div_leg_2_orig_name			(ns_asn1_optional_indicators + 5)		/* 'originalCalledName' inside DivertingLegInformation2 ARGUMENT : 1 indicator */
#define Qsi_div_leg_2_extension			(ns_asn1_optional_indicators + 6)		/* 'extension' inside DivertingLegInformation2 ARGUMENT : 1 indicator */

#define Qsi_div_leg_3_redir_name		ns_asn1_optional_indicators				/* 'redirectionName' inside DivertingLegInformation3 ARGUMENT : 1 indicator */
#define Qsi_div_leg_3_extension			(ns_asn1_optional_indicators + 1)		/* 'extension' inside DivertingLegInformation3 ARGUMENT : 1 indicator */

	/* list of presence indicators in IntResultList (for InterrogateDiversionQ operation RESULT) :
			- NS_DIV_MX_INT_RESULT indicators for instances of 'remoteEnabled'
				after indicators for 'PartySubaddress' in divertedToAddress
			- NS_DIV_MX_INT_RESULT indicators for instances of 'extension'
				after indicators for 'remoteEnabled'
	*/

#define Qsi_div_int_res_remote_enab		(ns_asn1_optional_indicators + (NS_DIV_MX_INT_RESULT * 2))
#define Qsi_div_int_res_extension		(ns_asn1_optional_indicators + (NS_DIV_MX_INT_RESULT * 3))

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

	/* ActivateDiversionQ operation : RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_div_activate_res;

	/* DeactivateDiversionQ operation : RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_div_dea_res;

	/* CheckRestriction operation : ARGUMENT */

struct	ns_op_qsi_div_check_rest {
	uchar						basic_service;				/* basicService in ARGUMENT : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38} */
	uchar						srv_u_party_nb_type;		/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserNr */
	uchar						srv_u_type_of_nb;			/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr) */
	struct ns_asn1_string		srv_u_number_digits;		/* NumberDigits string in PartyNumber inside servedUserNr */
	uchar						div_party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside divertedToNr */
	uchar						div_type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside divertedToNr) */
	struct ns_asn1_string		div_number_digits;			/* NumberDigits string in PartyNumber inside divertedToNr */
	struct ns_asn1_string		extension;					/* extension string */

} ns_op_qsi_div_check_rest;

	/* CheckRestriction operation : RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_div_chk_rst_res;

	/* CallRerouting operation : RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_div_rerouting_res;

	/* DivertingLegInformation3 operation : ARGUMENT */

struct	ns_op_qsi_div_leg_info_3 {
	struct ns_asn1_string	redir_name;					/* NameData string inside redirectionName */
	struct ns_asn1_string	extension;					/* extension string */
	uchar					redir_character;			/* CharacterSet inside redirectionName */
	/* presentationAllowedIndicator field is stored in variable 'ns_op_div_leg_info_3' (used for EUROPE) */
} ns_op_qsi_div_leg_info_3;

	/* CfnrDivertedLegFailed operation : ARGUMENT -> Transparent */

struct ns_asn1_string	ns_op_qsi_div_leg_fail_arg;

#if (NS_SS_INTERACTIONS == ON) && ((NS_SS_CALL_OFFER == ON) || (NS_SS_CALL_INTRUSION == ON))

	/* Supplementary service interactions between Call Forwarding Busy and Call offer or Call intrusion */

struct ns_asn1_string	ns_op_qsi_cfb_override_arg;		/* CfbOverride operation : ARGUMENT -> Transparent */

#endif

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* ActivateDiversionQ operation */

uchar ns_ssdu_op_qsi_activate_div (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_activate_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((Ns_qsi_act_div_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
			(Ns_qsi_act_div_s_u_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
			(Ns_qsi_act_div_a_u_p_nb_type > NS_SS_MX_PARTY_NB_TYPE)) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_div_activation.procedure = Ns_qsi_act_div_procedure;
		ns_op_div_activation.basic_service = Ns_qsi_act_div_basic_service;
		ns_op_div_activation.forw_party_nb_type = Ns_qsi_act_div_p_nb_type;

		if ((ns_op_div_activation.forw_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_activation.forw_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_activation.forw_type_of_nb = Ns_qsi_act_div_type_of_nb;
		}

		ns_op_div_activation.forw_number_digits.size = size = Ns_qsi_act_div_nb_size;
		ns_op_div_activation.forw_number_digits.p_string = p_ind_buffer;

			/* PartyNumber string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_qsi_act_div_first_str);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_qsi_act_div_sa_type != 255) {	/* subaddress is present */

			if (Ns_qsi_act_div_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_div_activation.forw_sub_add_type = Ns_qsi_act_div_sa_type;
			ns_op_div_activation.forw_sub_add_odd_count = (Ns_qsi_act_div_sa_odd_count == 255) ? 254 : Ns_qsi_act_div_sa_odd_count;
			ns_op_div_activation.forw_sub_address.size = size = Ns_qsi_act_div_sa_size;
			ns_op_div_activation.forw_sub_address.p_string = p_ind_buffer;

				/* PartySubaddress string : at the end of the structure, after PartyNumber string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

			ns_op_div_activation.forw_sub_add_type = 254;
			ns_op_div_activation.forw_sub_address.size = 254;
			ns_op_div_activation.forw_sub_address.p_string = P_NIL;
		}

		ns_op_div_activation.srv_u_party_nb_type = Ns_qsi_act_div_s_u_p_nb_type;
		ns_op_div_activation.srv_u_number_digits.size = size = Ns_qsi_act_div_s_u_nb_size;
		ns_op_div_activation.srv_u_number_digits.p_string = p_ind_buffer;

		if ((ns_op_div_activation.srv_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_activation.srv_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_activation.srv_u_type_of_nb = Ns_qsi_act_div_s_u_type_of_nb;
		}

			/* servedUserNr string : at the end of the structure, after divertedToAddress string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_activation.activ_u_party_nb_type = Ns_qsi_act_div_a_u_p_nb_type;
		ns_op_div_activation.activ_u_number_digits.size = size = Ns_qsi_act_div_a_u_nb_size;
		ns_op_div_activation.activ_u_number_digits.p_string = p_ind_buffer;

		if ((ns_op_div_activation.activ_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_activation.activ_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_activation.activ_u_type_of_nb = Ns_qsi_act_div_a_u_type_of_nb;
		}

			/* activatingUserNr string : at the end of the structure, after servedUserNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_activation.extension.size = size = Ns_qsi_act_div_extension_size;
		ns_op_div_activation.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure, after activatingUserNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_activate_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((ns_op_div_activation.forw_party_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(ns_op_div_activation.forw_party_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/*	type of PartyNumber in divertedToAddress is nor 'Public' neither 'Private'
					-> the 'Type of Number' field is meaningless, the one stored into internal
					data is in fact the 'Type of Number' for next PartyNumber : in servedUserNr */

			ns_op_div_activation.activ_u_type_of_nb = ns_op_div_activation.srv_u_type_of_nb;
			ns_op_div_activation.srv_u_type_of_nb = ns_op_div_activation.forw_type_of_nb;
		}

		if ((ns_op_div_activation.srv_u_party_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(ns_op_div_activation.srv_u_party_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/*	type of PartyNumber in servedUserNr is nor 'Public' neither 'Private'
					-> the 'Type of Number' field is meaningless, the one stored into internal
					data is in fact the 'Type of Number' for next PartyNumber : in activatingUserNr */

			ns_op_div_activation.activ_u_type_of_nb = ns_op_div_activation.srv_u_type_of_nb;
		}

		Ns_qsi_act_div_procedure = ns_op_div_activation.procedure;
		Ns_qsi_act_div_basic_service = ns_op_div_activation.basic_service;
		Ns_qsi_act_div_p_nb_type = ns_op_div_activation.forw_party_nb_type;
		Ns_qsi_act_div_type_of_nb = ns_op_div_activation.forw_type_of_nb;
		Ns_qsi_act_div_sa_type = ns_op_div_activation.forw_sub_add_type;
		Ns_qsi_act_div_sa_odd_count = ns_op_div_activation.forw_sub_add_odd_count;
		Ns_qsi_act_div_s_u_p_nb_type = ns_op_div_activation.srv_u_party_nb_type;
		Ns_qsi_act_div_s_u_type_of_nb = ns_op_div_activation.srv_u_type_of_nb;
		Ns_qsi_act_div_a_u_p_nb_type = ns_op_div_activation.activ_u_party_nb_type;
		Ns_qsi_act_div_a_u_type_of_nb = ns_op_div_activation.activ_u_type_of_nb;
		p_next = &(Ns_qsi_act_div_first_str);		/* set current pointer to first string octet */

			/* PartyNumber string : at the end of the structure */
		Ns_qsi_act_div_nb_size = size = ns_op_div_activation.forw_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.forw_number_digits.p_string, size);
		p_next += size;

			/* PartySubaddress string : at the end of the structure, after PartyNumber string */
		Ns_qsi_act_div_sa_size = size = ns_op_div_activation.forw_sub_address.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.forw_sub_address.p_string, size);
		p_next += size;

			/* servedUserNr string : at the end of the structure, after divertedToAddress string */
		Ns_qsi_act_div_s_u_nb_size = size = ns_op_div_activation.srv_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.srv_u_number_digits.p_string, size);
		p_next += size;

			/* activatingUserNr string : at the end of the structure, after servedUserNr string */
		Ns_qsi_act_div_a_u_nb_size = size = ns_op_div_activation.activ_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.activ_u_number_digits.p_string, size);
		p_next += size;

			/* extension string : at the end of the structure, after activatingUserNr string */
		Ns_qsi_act_div_extension_size = size = ns_op_div_activation.extension.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_activation.extension.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* DeactivateDiversionQ operation */

uchar ns_ssdu_op_qsi_dea_div (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_dea_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((Ns_qsi_dea_div_s_u_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
			(Ns_qsi_dea_div_d_u_p_nb_type > NS_SS_MX_PARTY_NB_TYPE)) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_div_deactivation.procedure = Ns_qsi_dea_div_procedure;
		ns_op_div_deactivation.basic_service = Ns_qsi_dea_div_basic_service;
		ns_op_div_deactivation.srv_u_party_nb_type = Ns_qsi_dea_div_s_u_p_nb_type;
		ns_op_div_deactivation.srv_u_number_digits.size = size = Ns_qsi_dea_div_s_u_nb_size;
		ns_op_div_deactivation.srv_u_number_digits.p_string = p_ind_buffer;

		if ((ns_op_div_deactivation.srv_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_deactivation.srv_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_deactivation.srv_u_type_of_nb = Ns_qsi_dea_div_s_u_type_of_nb;
		}

			/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_qsi_dea_div_first_str);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_deactivation.dea_u_party_nb_type = Ns_qsi_dea_div_d_u_p_nb_type;
		ns_op_div_deactivation.dea_u_number_digits.size = size = Ns_qsi_dea_div_d_u_nb_size;
		ns_op_div_deactivation.dea_u_number_digits.p_string = p_ind_buffer;

		if ((ns_op_div_deactivation.dea_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_deactivation.dea_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_deactivation.dea_u_type_of_nb = Ns_qsi_dea_div_d_u_type_of_nb;
		}

			/* deactivatingUserNr string : at the end of the structure, after servedUserNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_deactivation.extension.size = size = Ns_qsi_dea_div_extension_size;
		ns_op_div_deactivation.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure, after deactivatingUserNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_dea_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((ns_op_div_deactivation.srv_u_party_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(ns_op_div_deactivation.srv_u_party_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/*	type of PartyNumber in servedUserNr is nor 'Public' neither 'Private'
					-> the 'Type of Number' field is meaningless, the one stored into internal
					data is in fact the 'Type of Number' for next PartyNumber : in deactivatingUserNr */

			ns_op_div_deactivation.dea_u_type_of_nb = ns_op_div_deactivation.srv_u_type_of_nb;
		}

		Ns_qsi_dea_div_procedure = ns_op_div_deactivation.procedure;
		Ns_qsi_dea_div_basic_service = ns_op_div_deactivation.basic_service;
		Ns_qsi_dea_div_s_u_p_nb_type = ns_op_div_deactivation.srv_u_party_nb_type;
		Ns_qsi_dea_div_s_u_type_of_nb = ns_op_div_deactivation.srv_u_type_of_nb;
		Ns_qsi_dea_div_d_u_p_nb_type = ns_op_div_deactivation.dea_u_party_nb_type;
		Ns_qsi_dea_div_d_u_type_of_nb = ns_op_div_deactivation.dea_u_type_of_nb;
		p_next = &(Ns_qsi_dea_div_first_str);		/* set current pointer to first string octet */

			/* servedUserNr string : at the end of the structure */
		Ns_qsi_dea_div_s_u_nb_size = size = ns_op_div_deactivation.srv_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_deactivation.srv_u_number_digits.p_string, size);
		p_next += size;

			/* deactivatingUserNr string : at the end of the structure, after servedUserNr string */
		Ns_qsi_dea_div_d_u_nb_size = size = ns_op_div_deactivation.dea_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_deactivation.dea_u_number_digits.p_string, size);
		p_next += size;

			/* extension string : at the end of the structure, after deactivatingUserNr string */
		Ns_qsi_dea_div_extension_size = size = ns_op_div_deactivation.extension.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_deactivation.extension.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* InterrogateDiversionQ operation */

uchar ns_ssdu_op_qsi_interog_div (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */
	uchar				index;				/* current index */
	uchar				party_nb_x;			/* current index for PartyNumber */
	uchar				type_of_nb_x;		/* current index for TypeOfNumber inside PartyNumber */
	uchar				odd_count_x;		/* current index for OddCountIndicator inside PartySubaddress */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

				/* ReturnResult component -> process RESULT clause */

			odd_count_x = type_of_nb_x = party_nb_x = index = 0;			/* initialize current indexes */
			ns_op_div_interrogation_res.int_result_nb = 0;					/* init number of IntResult */

			while (offset != OFFSET_NIL) {

				if (ns_op_div_interrogation_res.int_result_nb >= NS_DIV_MX_INT_RESULT) {

					return (NOK);	/* too many IntResult instances */
				}

				p_next = p_start + offset;						/* get content of current IntResult */

				if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

					return (NOK);	/* component data is after end of SSDU or before start of component ! */
				}

				p_ssdu_val = p_next;		/* update SSDU pointer to analyse IntResult content */

				if ((Ns_qsi_int_res_div_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) ||
					(Ns_qsi_int_res_div_s_u_p_nb_t > NS_SS_MX_PARTY_NB_TYPE)) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_interrogation_res.procedure[index] = Ns_qsi_int_res_div_procedure;
				ns_op_div_interrogation_res.basic_service[index] = Ns_qsi_int_res_div_service;
				ns_op_div_interrogation_res.served_user_nr_type[index] = (Ns_qsi_int_res_div_remote_e == 255) ? 254 : Ns_qsi_int_res_div_remote_e;
				p_next = &(Ns_qsi_int_res_div_first_str);

					/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

				if ((Ns_qsi_int_res_div_s_u_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
					(Ns_qsi_int_res_div_s_u_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

					ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++] = Ns_qsi_int_res_div_s_u_t_of_nb;
				}

				ns_op_div_interrogation_res.party_nb_type[party_nb_x] = Ns_qsi_int_res_div_s_u_p_nb_t;
				ns_op_div_interrogation_res.number_digits[party_nb_x].size = size = Ns_qsi_int_res_div_s_u_nb_sz;
				ns_op_div_interrogation_res.number_digits[party_nb_x++].p_string = p_ind_buffer;
					/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

					/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

				if ((Ns_qsi_int_res_div_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
					(Ns_qsi_int_res_div_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

					ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++] = Ns_qsi_int_res_div_t_of_nb;
				}

				ns_op_div_interrogation_res.party_nb_type[party_nb_x] = Ns_qsi_int_res_div_p_nb_t;
				ns_op_div_interrogation_res.number_digits[party_nb_x].size = size = Ns_qsi_int_res_div_nb_sz;
				ns_op_div_interrogation_res.number_digits[party_nb_x++].p_string = p_ind_buffer;
					/* PartyNumber string : at the end of the structure, after servedUserNr string -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

				if (Ns_qsi_int_res_div_sa_t != 255) {	/* subaddress is present */

					if (Ns_qsi_int_res_div_sa_t > NS_SS_MX_PARTY_SA_TYPE) {

						return (NOK);	/* bad type of PartySubaddress */
					}

					if (Ns_qsi_int_res_div_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

						ns_op_div_interrogation_res.forw_sub_add_odd_count[odd_count_x++] = (Ns_qsi_int_res_div_sa_odd_c == 255) ? 254 : Ns_qsi_int_res_div_sa_odd_c;
					}

					ns_op_div_interrogation_res.forw_sub_add_type[index] = Ns_qsi_int_res_div_sa_t;
					ns_op_div_interrogation_res.forw_sub_address[index].size = size = Ns_qsi_int_res_div_sa_sz;
					ns_op_div_interrogation_res.forw_sub_address[index].p_string = p_ind_buffer;
						/* PartySubaddress string : at the end of the structure, after PartyNumber string and servedUserNr string -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */

				} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

					ns_op_div_interrogation_res.forw_sub_add_type[index] = 254;
					ns_op_div_interrogation_res.forw_sub_address[index].size = 254;
					ns_op_div_interrogation_res.forw_sub_address[index].p_string = P_NIL;
				}

				if (Ns_qsi_int_res_div_ext_sz != 0) {

					ns_op_div_interrogation_res.extension[index].size = size = Ns_qsi_int_res_div_ext_sz;
					ns_op_div_interrogation_res.extension[index].p_string = p_ind_buffer;
						/* PartySubaddress string : at the end of the structure, after PartyNumber string and servedUserNr string -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */

				} else {	/* no subaddress -> set internal values so that types are marked 'ABSENT' in array of optional indicators */

					ns_op_div_interrogation_res.extension[index].size = 254;
					ns_op_div_interrogation_res.extension[index].p_string = P_NIL;
				}

				offset = Ns_qsi_int_res_div_next;					/* get content of next IntResult */
				ns_op_div_interrogation_res.int_result_nb++;	/* increment number of IntResult */
				index++;									/* get next IntResult internal structure */
			}

			return (OK);
		}

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

			/* Invoke component -> process ARGUMENT clause */

		if ((Ns_qsi_dea_div_s_u_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
			(Ns_qsi_dea_div_d_u_p_nb_type > NS_SS_MX_PARTY_NB_TYPE)) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_div_interrogation.procedure = Ns_qsi_dea_div_procedure;
		ns_op_div_interrogation.basic_service = (Ns_qsi_dea_div_basic_service == 255) ? 254 : Ns_qsi_dea_div_basic_service;
		ns_op_div_interrogation.srv_u_party_nb_type = Ns_qsi_dea_div_s_u_p_nb_type;
		ns_op_div_interrogation.srv_u_number_digits.size = size = Ns_qsi_dea_div_s_u_nb_size;
		ns_op_div_interrogation.srv_u_number_digits.p_string = p_ind_buffer;

		if ((ns_op_div_interrogation.srv_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_interrogation.srv_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_interrogation.srv_u_type_of_nb = Ns_qsi_dea_div_s_u_type_of_nb;
		}

			/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_qsi_dea_div_first_str);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_interrogation.dea_u_party_nb_type = Ns_qsi_dea_div_d_u_p_nb_type;
		ns_op_div_interrogation.dea_u_number_digits.size = size = Ns_qsi_dea_div_d_u_nb_size;
		ns_op_div_interrogation.dea_u_number_digits.p_string = p_ind_buffer;

		if ((ns_op_div_interrogation.dea_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_interrogation.dea_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_interrogation.dea_u_type_of_nb = Ns_qsi_dea_div_d_u_type_of_nb;
		}

			/* interrogatingUserNr string : at the end of the structure, after servedUserNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_interrogation.extension.size = size = Ns_qsi_dea_div_extension_size;
		ns_op_div_interrogation.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure, after interrogatingUserNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			offset = (ushort)(ns_op_div_interrogation_res.int_result_nb);		/* use 'offset' as counter of number of instances */

			if (offset == 0) {

				return (STOP);	/* no data */
			}

			odd_count_x = type_of_nb_x = party_nb_x = index = 0;			/* initialize current indexes */

			while (offset-- > 0) {

				Ns_qsi_int_res_div_procedure = ns_op_div_interrogation_res.procedure[index];
				Ns_qsi_int_res_div_service = ns_op_div_interrogation_res.basic_service[index];
				Ns_qsi_int_res_div_remote_e = ns_op_div_interrogation_res.served_user_nr_type[index];
				p_next = &(Ns_qsi_int_res_div_first_str);		/* set current pointer to first string octet */

				Ns_qsi_int_res_div_s_u_p_nb_t = ns_op_div_interrogation_res.party_nb_type[party_nb_x];

					/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

				if ((Ns_qsi_int_res_div_s_u_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
					(Ns_qsi_int_res_div_s_u_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

					Ns_qsi_int_res_div_s_u_t_of_nb = ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++];
				}

					/* servedUserNr string : at the end of the structure */
				Ns_qsi_int_res_div_s_u_nb_sz = size = ns_op_div_interrogation_res.number_digits[party_nb_x].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation_res.number_digits[party_nb_x].p_string, size);
				p_next += size;
				party_nb_x++;
				Ns_qsi_int_res_div_p_nb_t = ns_op_div_interrogation_res.party_nb_type[party_nb_x];

					/* 'Type Of Number' field is meaningless if PartyNumber is nor 'Public' neither 'Private' */

				if ((Ns_qsi_int_res_div_p_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
					(Ns_qsi_int_res_div_p_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

					Ns_qsi_int_res_div_t_of_nb = ns_op_div_interrogation_res.type_of_nb[type_of_nb_x++];
				}

					/* PartyNumber string : at the end of the structure, after servedUserNr string */
				Ns_qsi_int_res_div_nb_sz = size = ns_op_div_interrogation_res.number_digits[party_nb_x].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation_res.number_digits[party_nb_x].p_string, size);
				p_next += size;
				party_nb_x++;

				Ns_qsi_int_res_div_sa_t = ns_op_div_interrogation_res.forw_sub_add_type[index];
				if (Ns_qsi_int_res_div_sa_t == NS_SS_PARTY_SA_USER_SPECIF) {

					Ns_qsi_int_res_div_sa_odd_c = ns_op_div_interrogation_res.forw_sub_add_odd_count[odd_count_x++];
				}

					/* PartySubaddress string : at the end of the structure, after servedUserNr and PartyNumber strings */
				Ns_qsi_int_res_div_sa_sz = size = ns_op_div_interrogation_res.forw_sub_address[index].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation_res.forw_sub_address[index].p_string, size);
				p_next += size;

					/* PartySubaddress string : at the end of the structure, after servedUserNr and PartyNumber strings */
				Ns_qsi_int_res_div_ext_sz = size = ns_op_div_interrogation_res.extension[index].size;
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation_res.extension[index].p_string, size);
				p_next += size;
				p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */

				if (offset == 0) {

					Ns_qsi_int_res_div_next = OFFSET_NIL;

				} else {

					Ns_qsi_int_res_div_next = (ushort)(p_next - p_start);
				}

				p_ssdu_val = p_next;	/* update current SSDU value pointer */
				index++;			/* get next IntResult internal structure */
			}

			return (OK);
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((ns_op_div_interrogation.srv_u_party_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(ns_op_div_interrogation.srv_u_party_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/*	type of PartyNumber in servedUserNr is nor 'Public' neither 'Private'
					-> the 'Type of Number' field is meaningless, the one stored into internal
					data is in fact the 'Type of Number' for next PartyNumber : in interrogatingUserNr */

			ns_op_div_interrogation.dea_u_type_of_nb = ns_op_div_interrogation.srv_u_type_of_nb;
		}

		Ns_qsi_dea_div_procedure = ns_op_div_interrogation.procedure;
		Ns_qsi_dea_div_basic_service = ns_op_div_interrogation.basic_service;
		Ns_qsi_dea_div_s_u_p_nb_type = ns_op_div_interrogation.srv_u_party_nb_type;
		Ns_qsi_dea_div_s_u_type_of_nb = ns_op_div_interrogation.srv_u_type_of_nb;
		Ns_qsi_dea_div_d_u_p_nb_type = ns_op_div_interrogation.dea_u_party_nb_type;
		Ns_qsi_dea_div_d_u_type_of_nb = ns_op_div_interrogation.dea_u_type_of_nb;
		p_next = &(Ns_qsi_dea_div_first_str);		/* set current pointer to first string octet */

			/* servedUserNr string : at the end of the structure */
		Ns_qsi_dea_div_s_u_nb_size = size = ns_op_div_interrogation.srv_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation.srv_u_number_digits.p_string, size);
		p_next += size;

			/* interrogatingUserNr string : at the end of the structure, after servedUserNr string */
		Ns_qsi_dea_div_d_u_nb_size = size = ns_op_div_interrogation.dea_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation.dea_u_number_digits.p_string, size);
		p_next += size;

			/* extension string : at the end of the structure, after interrogatingUserNr string */
		Ns_qsi_dea_div_extension_size = size = ns_op_div_interrogation.extension.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_interrogation.extension.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CheckRestriction operation */

uchar ns_ssdu_op_qsi_chk_rst_div (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_chk_rst_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((Ns_qsi_chk_div_s_u_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
			(Ns_qsi_chk_div_p_nb_type > NS_SS_MX_PARTY_NB_TYPE)) {

			return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_qsi_div_check_rest.basic_service = Ns_qsi_chk_div_basic_service;
		ns_op_qsi_div_check_rest.srv_u_party_nb_type = Ns_qsi_chk_div_s_u_p_nb_type;
		ns_op_qsi_div_check_rest.srv_u_number_digits.size = size = Ns_qsi_chk_div_s_u_nb_size;
		ns_op_qsi_div_check_rest.srv_u_number_digits.p_string = p_ind_buffer;

		if ((ns_op_qsi_div_check_rest.srv_u_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_qsi_div_check_rest.srv_u_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_qsi_div_check_rest.srv_u_type_of_nb = Ns_qsi_chk_div_s_u_type_of_nb;
		}

			/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
		p_next = &(Ns_qsi_chk_div_first_str);
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_qsi_div_check_rest.div_party_nb_type = Ns_qsi_chk_div_p_nb_type;
		ns_op_qsi_div_check_rest.div_number_digits.size = size = Ns_qsi_chk_div_nb_size;
		ns_op_qsi_div_check_rest.div_number_digits.p_string = p_ind_buffer;

		if ((ns_op_qsi_div_check_rest.div_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_qsi_div_check_rest.div_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_qsi_div_check_rest.div_type_of_nb = Ns_qsi_chk_div_type_of_nb;
		}

			/* divertedToNr string : at the end of the structure, after servedUserNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_qsi_div_check_rest.extension.size = size = Ns_qsi_chk_div_extension_size;
		ns_op_qsi_div_check_rest.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure, after divertedToNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_chk_rst_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		if ((ns_op_qsi_div_check_rest.srv_u_party_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(ns_op_qsi_div_check_rest.srv_u_party_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/*	type of PartyNumber in servedUserNr is nor 'Public' neither 'Private'
					-> the 'Type of Number' field is meaningless, the one stored into internal
					data is in fact the 'Type of Number' for next PartyNumber : in divetedToNr */

			ns_op_qsi_div_check_rest.div_type_of_nb = ns_op_qsi_div_check_rest.srv_u_type_of_nb;
		}

		Ns_qsi_chk_div_basic_service = ns_op_qsi_div_check_rest.basic_service;
		Ns_qsi_chk_div_s_u_p_nb_type = ns_op_qsi_div_check_rest.srv_u_party_nb_type;
		Ns_qsi_chk_div_s_u_type_of_nb = ns_op_qsi_div_check_rest.srv_u_type_of_nb;
		Ns_qsi_chk_div_p_nb_type = ns_op_qsi_div_check_rest.div_party_nb_type;
		Ns_qsi_chk_div_type_of_nb = ns_op_qsi_div_check_rest.div_type_of_nb;
		p_next = &(Ns_qsi_chk_div_first_str);		/* set current pointer to first string octet */

			/* servedUserNr string : at the end of the structure */
		Ns_qsi_chk_div_s_u_nb_size = size = ns_op_qsi_div_check_rest.srv_u_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_div_check_rest.srv_u_number_digits.p_string, size);
		p_next += size;

			/* divertedToNr string : at the end of the structure, after servedUserNr string */
		Ns_qsi_chk_div_nb_size = size = ns_op_qsi_div_check_rest.div_number_digits.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_div_check_rest.div_number_digits.p_string, size);
		p_next += size;

			/* extension string : at the end of the structure, after divertedToNr string */
		Ns_qsi_chk_div_extension_size = size = ns_op_qsi_div_check_rest.extension.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_div_check_rest.extension.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CallRerouting operation */

uchar ns_ssdu_op_qsi_rerouting_div (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */
    uchar							character_x;		/* index for "characterSet" fields */

    character_x = 0;		/* init index for "characterSet" fields */
	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_rerouting_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		ns_op_div_rerouteing.reason = Ns_qsi_rerout_reason;
		ns_op_div_rerouteing.counter = Ns_qsi_rerout_counter;
		ns_op_div_rerouteing.subscription_option = Ns_qsi_rerout_subscription;
		p_next = &(Ns_qsi_rerout_first_str);

		if ((Ns_qsi_rerout_called_nb_type > NS_SS_MX_PARTY_NB_TYPE) ||
			(Ns_qsi_rerout_last_pres_t > NS_SS_MX_PRES_NB_TYPE) ||
			(Ns_qsi_rerout_calling_pres_t > NS_SS_MX_PRES_NB_TYPE) || 
			((Ns_qsi_rerout_orig_pres_t > NS_SS_MX_PRES_NB_TYPE) && (Ns_qsi_rerout_orig_pres_t != 255))) {

			return (NOK);	/* bad type of PartyNumber or PresentedNumberUnscreened or PresentedNumberScreened */
		}

		ns_op_div_rerouteing.called_party_nb_type = Ns_qsi_rerout_called_nb_type;
		if ((ns_op_div_rerouteing.called_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
			(ns_op_div_rerouteing.called_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

			ns_op_div_rerouteing.called_type_of_nb = (Ns_qsi_rerout_called_t_of_nb == 255) ? 254 : Ns_qsi_rerout_called_t_of_nb;
		}

		ns_op_div_rerouteing.called_number_digits.size = size = Ns_qsi_rerout_called_nb_size;
		ns_op_div_rerouteing.called_number_digits.p_string = p_ind_buffer;
			/* called number string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_qsi_rerout_called_sa_type != 255) {

			if (Ns_qsi_rerout_called_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			if (Ns_qsi_rerout_called_sa_type == NS_SS_PARTY_SA_USER_SPECIF) {

				ns_op_div_rerouteing.called_sub_add_odd_count = (Ns_qsi_rerout_called_sa_odd_c == 255) ? 254 : Ns_qsi_rerout_called_sa_odd_c;
			}

			ns_op_div_rerouteing.called_sub_add_type = Ns_qsi_rerout_called_sa_type;
			ns_op_div_rerouteing.called_sub_address.p_string = p_ind_buffer;
			ns_op_div_rerouteing.called_sub_address.size = size = Ns_qsi_rerout_called_sa_size;
				/* called subaddress string : after called number string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			ns_op_div_rerouteing.called_sub_add_type = 254;
			ns_op_div_rerouteing.called_sub_address.size = 254;
		}

		ns_op_div_rerouteing.q931_ie.size = size = Ns_qsi_rerout_ie_sz;
		ns_op_div_rerouteing.q931_ie.p_string = p_ind_buffer;
			/* Q-SIG IE string : after called number and subaddress strings -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_div_rerouteing.last_presented_nb_type = Ns_qsi_rerout_last_pres_t;
		if ((Ns_qsi_rerout_last_pres_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_rerout_last_pres_t == NS_SS_PRES_RESTRICTED_NB)) {

				/* lastReroutingNr type is PartyNumber */

			if (Ns_qsi_rerout_last_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_div_rerouteing.last_party_nb_type = Ns_qsi_rerout_last_nb_type;
			if ((ns_op_div_rerouteing.last_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
				(ns_op_div_rerouteing.last_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

				ns_op_div_rerouteing.last_type_of_nb = (Ns_qsi_rerout_last_t_of_nb == 255) ? 254 : Ns_qsi_rerout_last_t_of_nb;
			}

			ns_op_div_rerouteing.last_number_digits.size = size = Ns_qsi_rerout_last_nb_size;
			ns_op_div_rerouteing.last_number_digits.p_string = p_ind_buffer;
				/* lastReroutingNr string : after Q-SIG IE string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		if (Ns_qsi_rerout_calling_sa_type != 255) {

			if (Ns_qsi_rerout_calling_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			ns_op_div_rerouteing.calling_sub_add_type = Ns_qsi_rerout_calling_sa_type;
			ns_op_div_rerouteing.calling_sub_add_odd_count = (Ns_qsi_rerout_calling_sa_odd_c == 255) ? 254 : Ns_qsi_rerout_calling_sa_odd_c;
			ns_op_div_rerouteing.calling_sub_address.p_string = p_ind_buffer;
			ns_op_div_rerouteing.calling_sub_address.size = size = Ns_qsi_rerout_calling_sa_size;
				/*	callingPartySubaddress string : after lastReroutingNr string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			ns_op_div_rerouteing.calling_sub_add_type = 254;
			ns_op_div_rerouteing.calling_sub_address.size = 254;
		}

		ns_op_div_rerouteing.calling_presented_nb_type = Ns_qsi_rerout_calling_pres_t;
		if ((Ns_qsi_rerout_calling_pres_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_rerout_calling_pres_t == NS_SS_PRES_RESTRICTED_NB)) {

				/* callingNumber type is PartyNumber */

			if (Ns_qsi_rerout_calling_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_div_rerouteing.calling_screening_ind = Ns_qsi_rerout_calling_scr_ind;
			ns_op_div_rerouteing.calling_party_nb_type = Ns_qsi_rerout_calling_nb_type;
			if ((ns_op_div_rerouteing.calling_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
				(ns_op_div_rerouteing.calling_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

				ns_op_div_rerouteing.calling_type_of_nb = (Ns_qsi_rerout_calling_t_of_nb == 255) ? 254 : Ns_qsi_rerout_calling_t_of_nb;
			}

			ns_op_div_rerouteing.calling_number_digits.size = size = Ns_qsi_rerout_calling_nb_size;
			ns_op_div_rerouteing.calling_number_digits.p_string = p_ind_buffer;
				/* callingNumber string : after callingPartySubaddress string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		if (Ns_qsi_rerout_calling_nm_type != 255) {

			if (Ns_qsi_rerout_calling_nm_type > NS_SS_QSI_MX_NAME_TYPE) {

				return (NOK);	/* bad type of Name */
			}

			ns_op_div_rerouteing.calling_name_type = Ns_qsi_rerout_calling_nm_type;
			if ((Ns_qsi_rerout_calling_nm_type == NS_SS_QSI_NAME_ALLOWED_EXT) ||
				(Ns_qsi_rerout_calling_nm_type == NS_SS_QSI_NAME_RESTRICT_EXT)) {	/* "Extended" Name : includes a 'characterSet' */

				ns_op_div_rerouteing.name_character[character_x++] = (Ns_qsi_rerout_calling_nm_char == 255) ? 254 : Ns_qsi_rerout_calling_nm_char;
			}

			if (Ns_qsi_rerout_calling_nm_type != NS_SS_QSI_NAME_NOT_AVAIL) {	/* Name includes a string */

				ns_op_div_rerouteing.calling_name_data.size = size = Ns_qsi_rerout_calling_nm_size;
				ns_op_div_rerouteing.calling_name_data.p_string = p_ind_buffer;
					/* callingNumber string : after callingPartySubaddress string -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */
			}

		} else {

			ns_op_div_rerouteing.calling_name_type = 254;
			ns_op_div_rerouteing.calling_name_data.size = 254;
		}

		ns_op_div_rerouteing.orig_presented_nb_type = (Ns_qsi_rerout_orig_pres_t == 255) ? 254 : Ns_qsi_rerout_orig_pres_t;
		if ((Ns_qsi_rerout_orig_pres_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_rerout_orig_pres_t == NS_SS_PRES_RESTRICTED_NB)) {

				/* originalCalledNr type is PartyNumber */

			if (Ns_qsi_rerout_orig_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_div_rerouteing.orig_party_nb_type = Ns_qsi_rerout_orig_nb_type;
			ns_op_div_rerouteing.orig_type_of_nb = (Ns_qsi_rerout_orig_t_of_nb == 255) ? 254 : Ns_qsi_rerout_orig_t_of_nb;
			ns_op_div_rerouteing.orig_number_digits.size = size = Ns_qsi_rerout_orig_nb_size;
			ns_op_div_rerouteing.orig_number_digits.p_string = p_ind_buffer;
				/* originalCalledNr string : after callingName string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		if (Ns_qsi_rerout_redir_nm_size != 0) {

			ns_op_div_rerouteing.name_character[character_x++] = (Ns_qsi_rerout_redir_nm_char == 255) ? 254 : Ns_qsi_rerout_redir_nm_char;
			ns_op_div_rerouteing.redir_name_data.size = size = Ns_qsi_rerout_redir_nm_size;
			ns_op_div_rerouteing.redir_name_data.p_string = p_ind_buffer;
				/* redirectingName string : after originalCalledNr string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			ns_op_div_rerouteing.redir_name_data.size = 254;
		}

		if (Ns_qsi_rerout_orig_nm_size != 0) {

			ns_op_div_rerouteing.name_character[character_x] = (Ns_qsi_rerout_orig_nm_char == 255) ? 254 : Ns_qsi_rerout_orig_nm_char;
			ns_op_div_rerouteing.orig_name_data.size = size = Ns_qsi_rerout_orig_nm_size;
			ns_op_div_rerouteing.orig_name_data.p_string = p_ind_buffer;
				/* originalCalledName string : after redirectingName string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			ns_op_div_rerouteing.orig_name_data.size = 254;
		}

		ns_op_div_rerouteing.extension.size = size = Ns_qsi_rerout_ext_size;
		ns_op_div_rerouteing.extension.p_string = p_ind_buffer;
			/* extension string : after originalCalledName string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_rerouting_res));
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_qsi_rerout_reason = ns_op_div_rerouteing.reason;
		Ns_qsi_rerout_counter = ns_op_div_rerouteing.counter;
		Ns_qsi_rerout_subscription = ns_op_div_rerouteing.subscription_option;
		p_next = &(Ns_qsi_rerout_first_str);
		Ns_qsi_rerout_called_nb_type = ns_op_div_rerouteing.called_party_nb_type;
		Ns_qsi_rerout_called_t_of_nb = ns_op_div_rerouteing.called_type_of_nb;

		if ((Ns_qsi_rerout_called_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
			(Ns_qsi_rerout_called_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

				/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

			ns_op_div_rerouteing.orig_type_of_nb = ns_op_div_rerouteing.calling_type_of_nb;
			ns_op_div_rerouteing.calling_type_of_nb = ns_op_div_rerouteing.last_type_of_nb;
			ns_op_div_rerouteing.last_type_of_nb = ns_op_div_rerouteing.called_type_of_nb;
		}

		Ns_qsi_rerout_called_nb_size = size = ns_op_div_rerouteing.called_number_digits.size;
			/* called number string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.called_number_digits.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_rerout_called_sa_size = 0;
		Ns_qsi_rerout_called_sa_type = ns_op_div_rerouteing.called_sub_add_type;
		if (Ns_qsi_rerout_called_sa_type != 255) {

			if (Ns_qsi_rerout_called_sa_type == NS_SS_PARTY_SA_NSAP) {

					/* NSAP Subaddress : 'OddCountIndicator' is meaningless, the value stored is in fact the one for next 'OddCountIndicator' field */

				ns_op_div_rerouteing.calling_sub_add_odd_count = ns_op_div_rerouteing.called_sub_add_odd_count;
			}

			Ns_qsi_rerout_called_sa_odd_c = ns_op_div_rerouteing.called_sub_add_odd_count;
			Ns_qsi_rerout_called_sa_size = size = ns_op_div_rerouteing.called_sub_address.size;
				/* called subaddress string : after called number string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.called_sub_address.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

				/* Called Subaddress absent : 'OddCountIndicator' is meaningless, the value stored is in fact the one for next 'OddCountIndicator' field */

			ns_op_div_rerouteing.calling_sub_add_odd_count = ns_op_div_rerouteing.called_sub_add_odd_count;
		}

		Ns_qsi_rerout_ie_sz = size = ns_op_div_rerouteing.q931_ie.size;
			/* Q-SIG IE string : after called number and subaddress strings */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.q931_ie.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_rerout_last_pres_t = ns_op_div_rerouteing.last_presented_nb_type;
		Ns_qsi_rerout_last_nb_size = 0;
		switch (Ns_qsi_rerout_last_pres_t) {

			default :

				/* lastReroutingNr type is NULL : no other data, stored data are in fact the ones for next PartyNumber fields */

				ns_op_div_rerouteing.orig_party_nb_type = ns_op_div_rerouteing.calling_party_nb_type;
				ns_op_div_rerouteing.calling_party_nb_type = ns_op_div_rerouteing.last_party_nb_type;
				ns_op_div_rerouteing.orig_type_of_nb = ns_op_div_rerouteing.calling_type_of_nb;
				ns_op_div_rerouteing.calling_type_of_nb = ns_op_div_rerouteing.last_type_of_nb;
				ns_op_div_rerouteing.orig_number_digits.size = ns_op_div_rerouteing.calling_number_digits.size;
				ns_op_div_rerouteing.orig_number_digits.p_string = ns_op_div_rerouteing.calling_number_digits.p_string;
				ns_op_div_rerouteing.calling_number_digits.size = ns_op_div_rerouteing.last_number_digits.size;
				ns_op_div_rerouteing.calling_number_digits.p_string = ns_op_div_rerouteing.last_number_digits.p_string;
				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* lastReroutingNr type is PartyNumber */

				Ns_qsi_rerout_last_nb_type = ns_op_div_rerouteing.last_party_nb_type;
				Ns_qsi_rerout_last_t_of_nb = ns_op_div_rerouteing.last_type_of_nb;
				if ((Ns_qsi_rerout_last_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
					(Ns_qsi_rerout_last_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

						/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

					ns_op_div_rerouteing.orig_type_of_nb = ns_op_div_rerouteing.calling_type_of_nb;
					ns_op_div_rerouteing.calling_type_of_nb = ns_op_div_rerouteing.last_type_of_nb;
				}

				Ns_qsi_rerout_last_nb_size = size = ns_op_div_rerouteing.last_number_digits.size;
					/* lastReroutingNr string : after Q-SIG IE string */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.last_number_digits.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */
				break;
		}

		Ns_qsi_rerout_calling_sa_type = ns_op_div_rerouteing.calling_sub_add_type;
		if (Ns_qsi_rerout_calling_sa_type != 255) {

			Ns_qsi_rerout_calling_sa_odd_c = ns_op_div_rerouteing.calling_sub_add_odd_count;
			Ns_qsi_rerout_calling_sa_size = size = ns_op_div_rerouteing.calling_sub_address.size;
				/* callingPartySubaddress string : after lastRerouteingNr string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.calling_sub_address.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {

			Ns_qsi_rerout_calling_sa_size = 0;
		}

		Ns_qsi_rerout_calling_pres_t = ns_op_div_rerouteing.calling_presented_nb_type;
		Ns_qsi_rerout_calling_nb_size = 0;
		switch (Ns_qsi_rerout_calling_pres_t) {

			default :

				/* callingNumber type is NULL : no other data, stored data are in fact the ones for next PartyNumber fields */

				ns_op_div_rerouteing.orig_party_nb_type = ns_op_div_rerouteing.calling_party_nb_type;
				ns_op_div_rerouteing.orig_type_of_nb = ns_op_div_rerouteing.calling_type_of_nb;
				ns_op_div_rerouteing.orig_number_digits.size = ns_op_div_rerouteing.calling_number_digits.size;
				ns_op_div_rerouteing.orig_number_digits.p_string = ns_op_div_rerouteing.calling_number_digits.p_string;
				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* callingNumber type is PartyNumber */

				Ns_qsi_rerout_calling_nb_type = ns_op_div_rerouteing.calling_party_nb_type;
				Ns_qsi_rerout_calling_scr_ind = ns_op_div_rerouteing.calling_screening_ind;
				Ns_qsi_rerout_calling_t_of_nb = ns_op_div_rerouteing.calling_type_of_nb;
				if ((Ns_qsi_rerout_calling_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
					(Ns_qsi_rerout_calling_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

						/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

					ns_op_div_rerouteing.orig_type_of_nb = ns_op_div_rerouteing.calling_type_of_nb;
				}

				Ns_qsi_rerout_calling_nb_size = size = ns_op_div_rerouteing.calling_number_digits.size;
					/* callingNumber string : after callingPartySubaddress string */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.calling_number_digits.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */
				break;
		}

		Ns_qsi_rerout_calling_nm_type = ns_op_div_rerouteing.calling_name_type;
		Ns_qsi_rerout_calling_nm_size = 0;
		switch (Ns_qsi_rerout_calling_nm_type) {

			case NS_SS_QSI_NAME_NOT_AVAIL :

				/* callingName type is NULL : no other data, stored data are in fact the ones for next NameSet fields */

				ns_op_div_rerouteing.orig_name_data.size = ns_op_div_rerouteing.redir_name_data.size;
				ns_op_div_rerouteing.orig_name_data.p_string = ns_op_div_rerouteing.redir_name_data.p_string;
				ns_op_div_rerouteing.redir_name_data.size = ns_op_div_rerouteing.calling_name_data.size;
				ns_op_div_rerouteing.redir_name_data.p_string = ns_op_div_rerouteing.calling_name_data.p_string;
				break;

			case NS_SS_QSI_NAME_ALLOWED_EXT :
			case NS_SS_QSI_NAME_RESTRICT_EXT :

					/* "Extended" Name : includes a 'characterSet' */

				Ns_qsi_rerout_calling_nm_char = ns_op_div_rerouteing.name_character[character_x++];
				break;
		}

		if ((Ns_qsi_rerout_calling_nm_type != 255) &&
			(Ns_qsi_rerout_calling_nm_type != NS_SS_QSI_NAME_NOT_AVAIL)) {	/* Name includes a string */

			Ns_qsi_rerout_calling_nm_size = size = ns_op_div_rerouteing.calling_name_data.size;
				/* callingName string : after callingNumber string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.calling_name_data.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_qsi_rerout_orig_pres_t = ns_op_div_rerouteing.orig_presented_nb_type;
		Ns_qsi_rerout_orig_nb_size = 0;
		if ((Ns_qsi_rerout_orig_pres_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_rerout_orig_pres_t == NS_SS_PRES_RESTRICTED_NB)) {	/* originalCalledNr type is PartyNumber */

			Ns_qsi_rerout_orig_nb_type = ns_op_div_rerouteing.orig_party_nb_type;
			Ns_qsi_rerout_orig_t_of_nb = ns_op_div_rerouteing.orig_type_of_nb;
			Ns_qsi_rerout_orig_nb_size = size = ns_op_div_rerouteing.orig_number_digits.size;
				/* originalCalledNr string : after callingName string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.orig_number_digits.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_qsi_rerout_redir_nm_size = size = ns_op_div_rerouteing.redir_name_data.size;
		if (size != 0) {	/* redirectingName is present */

			Ns_qsi_rerout_redir_nm_char = ns_op_div_rerouteing.name_character[character_x++];
				/* redirectingName string : after originalCalledNr string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.redir_name_data.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_qsi_rerout_orig_nm_char = ns_op_div_rerouteing.name_character[character_x];
		Ns_qsi_rerout_orig_nm_size = size = ns_op_div_rerouteing.orig_name_data.size;
			/* originalCalledName string : after redirectingName string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.orig_name_data.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

			/* extension string : after originalCalledName string */
		Ns_qsi_rerout_ext_size = size = ns_op_div_rerouteing.extension.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_rerouteing.extension.p_string, size);
		p_next += size;
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* DivertingLegInformation1 operation */

uchar ns_ssdu_op_qsi_div_leg_1 (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_leg_info_1.reason = Ns_qsi_leg_inf1_reason;
		ns_op_div_leg_info_1.subscription_option = Ns_qsi_leg_inf1_subscription;
		ns_op_div_leg_info_1.presented_nb_type = Ns_qsi_leg_inf1_pres_type;
		p_next = &(Ns_qsi_leg_inf1_nb_str);

		if (Ns_qsi_leg_inf1_pres_type > NS_SS_MX_PRES_NB_TYPE) {

			return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

		if ((Ns_qsi_leg_inf1_pres_type == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_leg_inf1_pres_type == NS_SS_PRES_RESTRICTED_NB)) {	/* nominatedNr type is PartyNumber */

			if (Ns_qsi_leg_inf1_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_div_leg_info_1.party_nb_type = Ns_qsi_leg_inf1_nb_type;
			ns_op_div_leg_info_1.type_of_nb = Ns_qsi_leg_inf1_t_of_nb;
			ns_op_div_leg_info_1.number_digits.size = size = Ns_qsi_leg_inf1_nb_size;
			ns_op_div_leg_info_1.number_digits.p_string = p_ind_buffer;
				/* nominatedNr string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		ns_op_div_leg_info_1.extension.size = size = Ns_qsi_leg_inf1_ext_size;
		ns_op_div_leg_info_1.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure, after nominatedNr string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		Ns_qsi_leg_inf1_reason = ns_op_div_leg_info_1.reason;
		Ns_qsi_leg_inf1_subscription = ns_op_div_leg_info_1.subscription_option;
		Ns_qsi_leg_inf1_pres_type = ns_op_div_leg_info_1.presented_nb_type;
		Ns_qsi_leg_inf1_nb_type = ns_op_div_leg_info_1.party_nb_type;
		Ns_qsi_leg_inf1_t_of_nb = ns_op_div_leg_info_1.type_of_nb;
		size = 0;
		p_next = &(Ns_qsi_leg_inf1_nb_str);

		if ((Ns_qsi_leg_inf1_pres_type == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_leg_inf1_pres_type == NS_SS_PRES_RESTRICTED_NB)) {

			size = ns_op_div_leg_info_1.number_digits.size;
				/* nominatedNr string : at the end of the structure */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_1.number_digits.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_qsi_leg_inf1_nb_size = size;
		Ns_qsi_leg_inf1_ext_size = size = ns_op_div_leg_info_1.extension.size;
			/* extension string : at the end of the structure, after nominatedNr string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_1.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* DivertingLegInformation2 operation */

uchar ns_ssdu_op_qsi_div_leg_2 (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */
	uchar				character_x;		/* index for 'CharacterSet' fields */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	character_x = 0;		/* init index for 'CharacterSet' fields */
	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_leg_info_2.counter = Ns_qsi_leg_inf2_counter;
		ns_op_div_leg_info_2.reason = Ns_qsi_leg_inf2_reason;

		p_next = &(Ns_qsi_leg_inf2_first_str);
		ns_op_div_leg_info_2.div_presented_nb_type = Ns_qsi_leg_inf2_div_pres_type;
		switch (Ns_qsi_leg_inf2_div_pres_type) {

			case 255 :	/* divertingNr is absent */

				ns_op_div_leg_info_2.div_presented_nb_type = 254;
				ns_op_div_leg_info_2.div_party_nb_type = 254;
				ns_op_div_leg_info_2.div_type_of_nb = 254;
				ns_op_div_leg_info_2.div_number_digits.size = 254;
				break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* divertingNr type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* divertingNr type is PartyNumber */

				if (Ns_qsi_leg_inf2_div_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_leg_info_2.div_party_nb_type = Ns_qsi_leg_inf2_div_nb_type;

				if ((ns_op_div_leg_info_2.div_party_nb_type == NS_SS_PARTY_NB_PUBLIC) ||
					(ns_op_div_leg_info_2.div_party_nb_type == NS_SS_PARTY_NB_PRIVATE)) {

					ns_op_div_leg_info_2.div_type_of_nb = Ns_qsi_leg_inf2_div_t_of_nb;
				}

				ns_op_div_leg_info_2.div_number_digits.size = size = Ns_qsi_leg_inf2_div_nb_size;
				ns_op_div_leg_info_2.div_number_digits.p_string = p_ind_buffer;
					/* divertingNr string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

		ns_op_div_leg_info_2.orig_presented_nb_type = Ns_qsi_leg_inf2_orig_pres_type;
		switch (Ns_qsi_leg_inf2_orig_pres_type) {

			case 255 :	/* originalCalledNr is absent */

				ns_op_div_leg_info_2.orig_presented_nb_type = 254;
				ns_op_div_leg_info_2.orig_party_nb_type = 254;
				ns_op_div_leg_info_2.orig_type_of_nb = 254;
				ns_op_div_leg_info_2.orig_number_digits.size = 254;
				break;

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :	/* originalCalledNr type is NULL : no other data */

				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* originalCalledNr type is PartyNumber */

				if (Ns_qsi_leg_inf2_orig_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_div_leg_info_2.orig_party_nb_type = Ns_qsi_leg_inf2_orig_nb_type;
				ns_op_div_leg_info_2.orig_type_of_nb = Ns_qsi_leg_inf2_orig_t_of_nb;
				ns_op_div_leg_info_2.orig_number_digits.size = size = Ns_qsi_leg_inf2_orig_nb_size;
				ns_op_div_leg_info_2.orig_number_digits.p_string = p_ind_buffer;
					/* originalCalledNr string : at the end of the structure, after divertingNr string -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_next += size;				/* update pointer to current string inside SSDU */
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				break;

			default :

				return (NOK);		/* bad type of PresentedNumberUnscreened */
		}

		if (Ns_qsi_leg_inf2_redir_nm_size == 0) {	/* redirectingName is absent */

			ns_op_div_leg_info_2.redir_name_data.size = 254;

		} else {	/* redirectingName is present */

			ns_op_div_leg_info_2.name_character[character_x++] = (Ns_qsi_leg_inf2_redir_nm_char == 255) ? 254 : Ns_qsi_leg_inf2_redir_nm_char;
			ns_op_div_leg_info_2.redir_name_data.size = size = Ns_qsi_leg_inf2_redir_nm_size;
			ns_op_div_leg_info_2.redir_name_data.p_string = p_ind_buffer;
				/* redirectingName string : at the end of the structure, after originalCalledNr string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_next += size;				/* update pointer to current string inside SSDU */
			p_ind_buffer += size;		/* update pointer to indirect buffer */
		}

		if (Ns_qsi_leg_inf2_orig_nm_size == 0) {	/* originalCalledName is absent */

			ns_op_div_leg_info_2.orig_name_data.size = 254;

		} else {	/* originalCalledName is present */

			ns_op_div_leg_info_2.name_character[character_x] = (Ns_qsi_leg_inf2_orig_nm_char == 255) ? 254 : Ns_qsi_leg_inf2_orig_nm_char;
			ns_op_div_leg_info_2.orig_name_data.size = size = Ns_qsi_leg_inf2_orig_nm_size;
			ns_op_div_leg_info_2.orig_name_data.p_string = p_ind_buffer;
				/* originalCalledName string : at the end of the structure, after redirectingName string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_next += size;				/* update pointer to current string inside SSDU */
			p_ind_buffer += size;		/* update pointer to indirect buffer */
		}

		ns_op_div_leg_info_2.extension.size = size = Ns_qsi_leg_inf2_ext_size;
		ns_op_div_leg_info_2.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure, after originalCalledName string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		Ns_qsi_leg_inf2_counter = ns_op_div_leg_info_2.counter;
		Ns_qsi_leg_inf2_reason = ns_op_div_leg_info_2.reason;
		Ns_qsi_leg_inf2_div_pres_type = ns_op_div_leg_info_2.div_presented_nb_type;
		Ns_qsi_leg_inf2_div_nb_type = ns_op_div_leg_info_2.div_party_nb_type;
		Ns_qsi_leg_inf2_div_t_of_nb = ns_op_div_leg_info_2.div_type_of_nb;
		size = 0;
		p_next = &(Ns_qsi_leg_inf2_first_str);

		switch (Ns_qsi_leg_inf2_div_pres_type) {

			case NS_SS_PRES_NB_RESTRICTED :
			case NS_SS_PRES_NOT_AVAIL_INTER_NB :

					/* divertingNr type is NULL : no other data, stored data are in fact the ones for next PartyNumber fields */

				ns_op_div_leg_info_2.orig_party_nb_type = ns_op_div_leg_info_2.div_party_nb_type;
				ns_op_div_leg_info_2.orig_type_of_nb = ns_op_div_leg_info_2.div_type_of_nb;
				ns_op_div_leg_info_2.orig_number_digits.size = ns_op_div_leg_info_2.div_number_digits.size;
				ns_op_div_leg_info_2.orig_number_digits.p_string = ns_op_div_leg_info_2.div_number_digits.p_string;
				break;

			case NS_SS_PRES_ALLOWED_NB :
			case NS_SS_PRES_RESTRICTED_NB :	/* divertingNr type is PartyNumber */

				if ((Ns_qsi_leg_inf2_div_nb_type != NS_SS_PARTY_NB_PUBLIC) &&
					(Ns_qsi_leg_inf2_div_nb_type != NS_SS_PARTY_NB_PRIVATE)) {

						/* 'Type of Nb' meaningless : the one stored is in fact the one for next PartyNumber */

					ns_op_div_leg_info_2.orig_type_of_nb = ns_op_div_leg_info_2.div_type_of_nb;
				}

				size = ns_op_div_leg_info_2.div_number_digits.size;
					/* divertingNr string : at the end of the structure */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_2.div_number_digits.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */
				break;
		}

		Ns_qsi_leg_inf2_div_nb_size = size;

		Ns_qsi_leg_inf2_orig_pres_type = ns_op_div_leg_info_2.orig_presented_nb_type;
		Ns_qsi_leg_inf2_orig_nb_type = ns_op_div_leg_info_2.orig_party_nb_type;
		Ns_qsi_leg_inf2_orig_t_of_nb = ns_op_div_leg_info_2.orig_type_of_nb;
		size = 0;

		if ((Ns_qsi_leg_inf2_orig_pres_type == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_leg_inf2_orig_pres_type == NS_SS_PRES_RESTRICTED_NB)) {

			size = ns_op_div_leg_info_2.orig_number_digits.size;
				/* originalCalledNr string : at the end of the structure, after divertingNr string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_2.orig_number_digits.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_qsi_leg_inf2_orig_nb_size = size;
		Ns_qsi_leg_inf2_redir_nm_size = size = ns_op_div_leg_info_2.redir_name_data.size;

		if (size != 0) {	/* redirectingName is present */

			Ns_qsi_leg_inf2_redir_nm_char = ns_op_div_leg_info_2.name_character[character_x++];
				/* redirectingName string : at the end of the structure, after originalCalledNr string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_2.redir_name_data.p_string, size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_qsi_leg_inf2_orig_nm_char = ns_op_div_leg_info_2.name_character[character_x];
		Ns_qsi_leg_inf2_orig_nm_size = size = ns_op_div_leg_info_2.orig_name_data.size;
			/* originalCalledName string : at the end of the structure, after redirectingName string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_2.orig_name_data.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_leg_inf2_ext_size = size = ns_op_div_leg_info_2.extension.size;
			/* extension string : at the end of the structure, after originalCalledName string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_div_leg_info_2.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* DivertingLegInformation3 operation */

uchar ns_ssdu_op_qsi_div_leg_3 (p_start, offset)
	uchar FAR			*p_start;			/* pointer to start of component */
	ushort				offset;				/* offset of data in received SSDU */
{
	uchar FAR			*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar				size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component is allowed */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		return (NOK);
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		ns_op_div_leg_info_3 = Ns_qsi_leg_inf3_pres_allow;
		ns_op_qsi_div_leg_info_3.redir_character = (Ns_qsi_leg_inf3_redir_char == 255) ? 254 : Ns_qsi_leg_inf3_redir_char;
		p_next = &(Ns_qsi_leg_inf3_first_str);

		size = Ns_qsi_leg_inf3_redir_size;
		if (size == 0) {	/* redirectionName is absent */

			ns_op_qsi_div_leg_info_3.redir_name.size = 254;

		} else {	/* redirectionName is present */

			ns_op_qsi_div_leg_info_3.redir_name.size = size;
			ns_op_qsi_div_leg_info_3.redir_name.p_string = p_ind_buffer;
				/* redirectionName string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
        }

		ns_op_qsi_div_leg_info_3.extension.size = size = Ns_qsi_leg_inf3_ext_size;
		ns_op_qsi_div_leg_info_3.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure, after redirectionName string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		Ns_qsi_leg_inf3_pres_allow = ns_op_div_leg_info_3;
		Ns_qsi_leg_inf3_redir_char = ns_op_qsi_div_leg_info_3.redir_character;
		p_next = &(Ns_qsi_leg_inf3_first_str);
		Ns_qsi_leg_inf3_redir_size = size = ns_op_qsi_div_leg_info_3.redir_name.size;
			/* redirectionName string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_div_leg_info_3.redir_name.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_leg_inf3_ext_size = size = ns_op_qsi_div_leg_info_3.extension.size;
			/* extension string : at the end of the structure, after redirectionName string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_div_leg_info_3.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CfnrDivertedLegFailed and CfbOverride operations */

uchar ns_ssdu_op_qsi_leg_fail_div (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data in operation but there should not be */
			}

			return (OK);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause : empty */

			return (STOP);	/* no data */
		}

			/* Invoke component -> process ARGUMENT clause */
	}

#	if (NS_SS_INTERACTIONS == ON) && ((NS_SS_CALL_OFFER == ON) || (NS_SS_CALL_INTRUSION == ON))
		/* Supplementary service interactions between Call Forwarding Busy and Call offer or Call intrusion */

		if (I_ss_fac_op_err_id == NS_OP_QSI_CFB_OVERRIDE) {	/* cfbOverride */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_cfb_override_arg));
		}
#	endif

	return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_div_leg_fail_arg));
}

#endif /* end of "NS_SS_DIVERSION = ON"} */

/*==========================================================================*/

		/*	Call Transfer SS
		 * ----------------- */

#if (NS_SS_CALL_TRANSFER == ON) || (NS_SS_PATH_REPLACEMENT == ON) /* { */

		/* lists of presence indicators for instances of Types Marked OPTIONAL (or DEFAULT) inside ASN1 SEQUENCE type */

#define Qsi_trf_ident_extension			ns_asn1_optional_indicators		/* 'extension' inside CallTransferIdentify RESULT : 1 indicator */
#define Qsi_trf_setup_extension			ns_asn1_optional_indicators		/* 'extension' inside CallTransferSetup ARGUMENT : 1 indicator */

		/* CallIdentity ::= NumericString (SIZE(1..4)) -> same data type as NumberDigits */

#define NS_QSI_TRF_CALL_IDENTITY_P			NS_SS_NUMBER_DIGITS_P

		/* operation internal data */

	/* CallTransferIdentify operation : RESULT */

struct ns_op_qsi_trf_identify_res {
	struct ns_asn1_string		call_identity;			/* NumberDigits string inside callIdentity */
	struct ns_asn1_string		rerouting_nb;			/* NumberDigits string in PartyNumber inside reroutingNumber */
	struct ns_asn1_string		extension;				/* extension string */
	uchar						party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside reroutingNumber */
	uchar						type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside reroutingNumber) */
};

	/* CallTransferSetup operation : ARGUMENT */

struct ns_op_qsi_trf_setup_arg {
	struct ns_asn1_string		call_identity;			/* NumberDigits string inside callIdentity */
	struct ns_asn1_string		extension;				/* extension string */
};

#endif /* end of "NS_SS_CALL_TRANSFER = ON or NS_SS_PATH_REPLACEMENT == ON"} */

#if NS_SS_CALL_TRANSFER == ON /* { */

		/* lists of presence indicators for instances of Types Marked OPTIONAL (or DEFAULT) inside ASN1 SEQUENCE type */

#define Qsi_trf_active_ie				(ns_asn1_optional_indicators + 4)	/* 'basicCallInfoElements' inside CallTransferActive ARGUMENT : 1 indicator */
#define Qsi_trf_active_name				(ns_asn1_optional_indicators + 5)	/* 'connectedName' inside CallTransferActive ARGUMENT : 1 indicator */
#define Qsi_trf_active_extension		(ns_asn1_optional_indicators + 6)	/* 'extension' inside CallTransferActive ARGUMENT : 1 indicator */

#define Qsi_trf_complete_ie				ns_asn1_optional_indicators			/* 'basicCallInfoElements' inside CallTransferComplete ARGUMENT : 1 indicator */
#define Qsi_trf_complete_name			(ns_asn1_optional_indicators + 1)	/* 'redirectionName' inside CallTransferComplete ARGUMENT : 1 indicator */
#define Qsi_trf_complete_status			(ns_asn1_optional_indicators + 2)	/* 'callStatus' inside CallTransferComplete ARGUMENT : 1 indicator */
#define Qsi_trf_complete_extension		(ns_asn1_optional_indicators + 4)	/* 'extension' inside CallTransferComplete ARGUMENT : 1 indicator */

#define Qsi_trf_update_ie				ns_asn1_optional_indicators			/* 'basicCallInfoElements' inside CallTransferUpdate ARGUMENT : 1 indicator */
#define Qsi_trf_update_name				(ns_asn1_optional_indicators + 1)	/* 'redirectionName' inside CallTransferUpdate ARGUMENT : 1 indicator */
#define Qsi_trf_update_extension		(ns_asn1_optional_indicators + 2)	/* 'extension' inside CallTransferUpdate ARGUMENT : 1 indicator */

#define Qsi_trf_subadd_extension		(ns_asn1_optional_indicators + 1)	/* 'extension' inside SubaddressTransfer ARGUMENT : 1 indicator */

	/* CallTransferInitiate operation ARGUMENT : same data type as CallTransferIdentify operation RESULT */

#define NS_QSI_INITIATE_TRF_ARG_P			NS_QSI_IDENTIFY_TRF_RES_P

		/* CallStatus ::= ENUMERATED{answered(0), alerting(1)} */

#define NS_QSI_TRF_CALL_STATUS_P			NS_SS_ENUMERATED_P

		/* EndDesignation ::= ENUMERATED{primaryEnd(0), secondaryEnd(1)} */

#define NS_QSI_TRF_END_DESIGN_P				NS_SS_ENUMERATED_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

	/* CallTransferIdentify operation : ARGUMENT -> Transparent */

struct ns_asn1_string	ns_op_qsi_trf_identify_arg;

	/* CallTransferIdentify operation : RESULT */

struct ns_op_qsi_trf_identify_res	ns_op_qsi_trf_identify_res;

	/* CallTransferAbandon operation : ARGUMENT -> Transparent */

struct ns_asn1_string	ns_op_qsi_trf_abandon_arg;

	/* CallTransferInitiate operation : ARGUMENT = same as CallTransferIdentify RESULT */

struct ns_op_qsi_trf_identify_res	ns_op_qsi_trf_initiate_arg;

	/* CallTransferInitiate operation : RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_trf_initiate_res;

	/* CallTransferSetup operation : ARGUMENT */

struct ns_op_qsi_trf_setup_arg	ns_op_qsi_trf_setup_arg;

	/* CallTransferSetup operation : RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_trf_setup_res;

	/* CallTransferActive operation : ARGUMENT */

struct ns_op_qsi_trf_active_arg {
	struct ns_asn1_string		connected_nb;			/* NumberDigits string in PartyNumber inside connectedAddress */
	struct ns_asn1_string		sub_add;				/* PartySubaddress string inside connectedAddress */
	struct ns_asn1_string		ie;						/* basicCallInfoElements string */
	struct ns_asn1_string		name;					/* NameData string inside connectedName */
	struct ns_asn1_string		extension;				/* extension string */
	uchar						presented_add_type;		/* index of chosen type in PresentedAddressScreened (presentationAllowedAddress .. presentationRestrictedAddress) inside connectedAddress */
	uchar						screening_ind;			/* ScreeningIndicator in AddressScreened inside connectedAddress : ENUMERATED {0, 1, 2, 3} */
	uchar						party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside connectedAddress */
	uchar						type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside connectedAddress) */
	uchar						sub_add_type;			/* index of chosen type in PartySubaddress or 255 if absent (inside connectedAddress) */
	uchar						sub_add_odd_count;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside connectedAddress) */
	uchar						name_type;				/* type of Name inside connectedName */
	uchar						character;				/* CharacterSet inside connectedName */

} ns_op_qsi_trf_active_arg;

	/* CallTransferComplete operation : ARGUMENT */

struct ns_op_qsi_trf_complete_arg {
	struct ns_asn1_string		redir_nb;				/* NumberDigits string in PartyNumber inside redirectionNumber */
	struct ns_asn1_string		ie;						/* basicCallInfoElements string */
	struct ns_asn1_string		name;					/* NameData string inside redirectionName */
	struct ns_asn1_string		extension;				/* extension string */
	uchar						presented_nb_type;		/* index of chosen type in PresentedNumberScreened (presentationAllowedNumber .. presentationRestrictedNumber) inside redirectionNumber */
	uchar						screening_ind;			/* ScreeningIndicator in NumberScreened inside redirectionNumber : ENUMERATED {0, 1, 2, 3} */
	uchar						party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside redirectionNumber */
	uchar						type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside redirectionNumber) */
	uchar						end_designation;		/* endDesignation */
	uchar						call_status;			/* callStatus or 255 if absent */
	uchar						name_type;				/* type of Name inside redirectionName */
	uchar						character;				/* CharacterSet inside redirectionName */

} ns_op_qsi_trf_complete_arg;

	/* CallTransferUpdate operation : ARGUMENT */

struct ns_op_qsi_trf_update_arg {
	struct ns_asn1_string		redir_nb;				/* NumberDigits string in PartyNumber inside redirectionNumber */
	struct ns_asn1_string		ie;						/* basicCallInfoElements string */
	struct ns_asn1_string		name;					/* NameData string inside redirectionName */
	struct ns_asn1_string		extension;				/* extension string */
	uchar						presented_nb_type;		/* index of chosen type in PresentedNumberScreened (presentationAllowedNumber .. presentationRestrictedNumber) inside redirectionNumber */
	uchar						screening_ind;			/* ScreeningIndicator in NumberScreened inside redirectionNumber : ENUMERATED {0, 1, 2, 3} */
	uchar						party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside redirectionNumber */
	uchar						type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside redirectionNumber) */
	uchar						name_type;				/* type of Name inside redirectionName */
	uchar						character;				/* CharacterSet inside redirectionName */

} ns_op_qsi_trf_update_arg;

	/* SubaddressTransfer operation : ARGUMENT */

struct ns_op_qsi_trf_subadd_arg {
	struct ns_asn1_string		redir_sub_add;			/* PartySubaddress string inside redirectionSubaddress */
	struct ns_asn1_string		extension;				/* extension string */
	uchar						sub_add_type;			/* index of chosen type in PartySubaddress (inside redirectionSubaddress) */
	uchar						sub_add_odd_count;		/* oddCountIndicator in PartySubaddress or 255 if absent (inside redirectionSubaddress) */

} ns_op_qsi_trf_subadd_arg;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* CallTransferIdentify operation */

uchar ns_ssdu_op_qsi_trf_identify (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_trf_identify_arg));
		}

			/* ReturnResult component -> process RESULT clause */

		if (Ns_qsi_trf_ident_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

        	return (NOK);	/* bad type of PartyNumber */
		}

		ns_op_qsi_trf_identify_res.party_nb_type = Ns_qsi_trf_ident_p_nb_type;
		ns_op_qsi_trf_identify_res.type_of_nb = Ns_qsi_trf_ident_type_of_nb;
		p_next = &(Ns_qsi_trf_ident_first_nb);

		ns_op_qsi_trf_identify_res.call_identity.size = size = Ns_qsi_trf_ident_call_id_sz;
		ns_op_qsi_trf_identify_res.call_identity.p_string = p_ind_buffer;
			/* callIdentity string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_qsi_trf_identify_res.rerouting_nb.size = size = Ns_qsi_trf_ident_nb_sz;
		ns_op_qsi_trf_identify_res.rerouting_nb.p_string = p_ind_buffer;
			/* reroutingNumber string : after callIdentity string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_qsi_trf_identify_res.extension.size = size = Ns_qsi_trf_ident_ext_sz;
		ns_op_qsi_trf_identify_res.extension.p_string = p_ind_buffer;
			/* extension string : after reroutingNumber string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_trf_identify_arg));
		}

			/* ReturnResult component -> process RESULT clause */

		Ns_qsi_trf_ident_p_nb_type = ns_op_qsi_trf_identify_res.party_nb_type;
		Ns_qsi_trf_ident_type_of_nb = ns_op_qsi_trf_identify_res.type_of_nb;
		p_next = &(Ns_qsi_trf_ident_first_nb);

		Ns_qsi_trf_ident_call_id_sz = size = ns_op_qsi_trf_identify_res.call_identity.size;
			/* callIdentity string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_identify_res.call_identity.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_ident_nb_sz = size = ns_op_qsi_trf_identify_res.rerouting_nb.size;
			/* reroutingNumber string : after callIdentity string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_identify_res.rerouting_nb.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_ident_ext_sz = size = ns_op_qsi_trf_identify_res.extension.size;
			/* extension string : after reroutingNumber string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_identify_res.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CallTransferAbandon operation */

uchar ns_ssdu_op_qsi_trf_abandon (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */

		/* only ARGUMENT clause is defined : only Invoke component may contain data */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		if (offset != OFFSET_NIL) {

			return (NOK);	/* there is data in operation but there should not be */
		}

		return (STOP);	/* no data */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */
	}

	return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_trf_abandon_arg));
}

		/* CallTransferActive operation */

uchar ns_ssdu_op_qsi_trf_active (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component may contain data */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		if (offset != OFFSET_NIL) {

			return (NOK);	/* there is data in operation but there should not be */
		}

		return (STOP);	/* no data */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		p_next = &(Ns_qsi_trf_active_first_str);
		ns_op_qsi_trf_active_arg.presented_add_type = Ns_qsi_trf_active_pres_add_t;
		if (Ns_qsi_trf_active_pres_add_t > NS_SS_MX_PRES_ADD_TYPE) {

			return (NOK);		/* bad type of PresentedAddressScreened */
		}

		if ((Ns_qsi_trf_active_pres_add_t == NS_SS_PRES_ALLOWED_ADD) ||
			(Ns_qsi_trf_active_pres_add_t == NS_SS_PRES_RESTRICTED_ADD)) {	/* connectedAddress type is AddressScreened */

			if (Ns_qsi_trf_active_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_qsi_trf_active_arg.screening_ind = Ns_qsi_trf_active_scr_ind;
			ns_op_qsi_trf_active_arg.party_nb_type = Ns_qsi_trf_active_p_nb_t;
			ns_op_qsi_trf_active_arg.type_of_nb = (Ns_qsi_trf_active_t_of_nb == 255) ? 254 : Ns_qsi_trf_active_t_of_nb;
			ns_op_qsi_trf_active_arg.connected_nb.size = size = Ns_qsi_trf_active_nb_sz;
			ns_op_qsi_trf_active_arg.connected_nb.p_string = p_ind_buffer;
				/* connected number string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

			if (Ns_qsi_trf_active_sa_t != 255) {

				if (Ns_qsi_trf_active_sa_t > NS_SS_MX_PARTY_SA_TYPE) {

					return (NOK);	/* bad type of PartySubaddress */
				}

				ns_op_qsi_trf_active_arg.sub_add_type = Ns_qsi_trf_active_sa_t;
				ns_op_qsi_trf_active_arg.sub_add_odd_count = (Ns_qsi_trf_active_sa_odd_c == 255) ? 254 : Ns_qsi_trf_active_sa_odd_c;
				ns_op_qsi_trf_active_arg.sub_add.p_string = p_ind_buffer;
				ns_op_qsi_trf_active_arg.sub_add.size = size = Ns_qsi_trf_active_sa_sz;
					/* connected subaddress string : after connected number string -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

			} else {

				ns_op_qsi_trf_active_arg.sub_add_type = 254;
				ns_op_qsi_trf_active_arg.sub_add.size = 254;
			}
		}

		size = Ns_qsi_trf_active_ie_sz;
		if (size == 0) {	/* Q-SIG IE is absent */

			ns_op_qsi_trf_active_arg.ie.size = 254;

		} else {	/* Q-SIG IE is present */

			ns_op_qsi_trf_active_arg.ie.size = size;
			ns_op_qsi_trf_active_arg.ie.p_string = p_ind_buffer;
				/* Q-SIG IE string : after connected address strings -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

        size = 0;
		if (Ns_qsi_trf_active_name_t != 255) {

			if (Ns_qsi_trf_active_name_t > NS_SS_QSI_MX_NAME_TYPE) {

				return (NOK);	/* bad type of Name */
			}

			ns_op_qsi_trf_active_arg.name_type = Ns_qsi_trf_active_name_t;
			if (Ns_qsi_trf_active_name_t != NS_SS_QSI_NAME_NOT_AVAIL) {	/* Name includes a string */

				ns_op_qsi_trf_active_arg.character = (Ns_qsi_trf_active_name_char == 255) ? 254 : Ns_qsi_trf_active_name_char;
				size = Ns_qsi_trf_active_name_sz;
				if (size != 0) {	/* NameData is absent */

					ns_op_qsi_trf_active_arg.name.size = size;
					ns_op_qsi_trf_active_arg.name.p_string = p_ind_buffer;
						/* NameData string : after Q-SIG IE string -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */
				}
			}
		}

		if (size == 0) {	/* NameData is absent */

			ns_op_qsi_trf_active_arg.name_type = 254;
			ns_op_qsi_trf_active_arg.name.size = 254;
		}

		ns_op_qsi_trf_active_arg.extension.size = size = Ns_qsi_trf_active_ext_sz;
		ns_op_qsi_trf_active_arg.extension.p_string = p_ind_buffer;
			/* extension string : after NameData string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		p_next = &(Ns_qsi_trf_active_first_str);
		Ns_qsi_trf_active_pres_add_t = ns_op_qsi_trf_active_arg.presented_add_type;
		Ns_qsi_trf_active_scr_ind = ns_op_qsi_trf_active_arg.screening_ind;
		Ns_qsi_trf_active_p_nb_t = ns_op_qsi_trf_active_arg.party_nb_type;
		Ns_qsi_trf_active_t_of_nb = ns_op_qsi_trf_active_arg.type_of_nb;
		Ns_qsi_trf_active_nb_sz = size = ns_op_qsi_trf_active_arg.connected_nb.size;
			/* connected number string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_active_arg.connected_nb.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_active_sa_t = ns_op_qsi_trf_active_arg.sub_add_type;
		Ns_qsi_trf_active_sa_odd_c = ns_op_qsi_trf_active_arg.sub_add_odd_count;
		Ns_qsi_trf_active_sa_sz = size = ns_op_qsi_trf_active_arg.sub_add.size;
			/* connected subaddress string : after connected number string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_active_arg.sub_add.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_active_ie_sz = size = ns_op_qsi_trf_active_arg.ie.size;
			/* Q-SIG IE string : after connected address strings */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_active_arg.ie.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_active_name_t = ns_op_qsi_trf_active_arg.name_type;
		Ns_qsi_trf_active_name_char = ns_op_qsi_trf_active_arg.character;
		Ns_qsi_trf_active_name_sz = size = ns_op_qsi_trf_active_arg.name.size;
			/* NameData string : after Q-SIG IE string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_active_arg.name.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_active_ext_sz = size = ns_op_qsi_trf_active_arg.extension.size;
			/* extension string : after NameData string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_active_arg.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CallTransferComplete operation */

uchar ns_ssdu_op_qsi_trf_complete (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component may contain data */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		if (offset != OFFSET_NIL) {

			return (NOK);	/* there is data in operation but there should not be */
		}

		return (STOP);	/* no data */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		p_next = &(Ns_qsi_trf_complete_first_str);
		ns_op_qsi_trf_complete_arg.end_designation = Ns_qsi_trf_complete_end_desig;
		ns_op_qsi_trf_complete_arg.call_status = (Ns_qsi_trf_complete_call_stat == 255) ? 254 : Ns_qsi_trf_complete_call_stat;
		ns_op_qsi_trf_complete_arg.presented_nb_type = Ns_qsi_trf_complete_pres_nb_t;
		if (Ns_qsi_trf_complete_pres_nb_t > NS_SS_MX_PRES_NB_TYPE) {

			return (NOK);		/* bad type of PresentedAddressScreened */
		}

		if ((Ns_qsi_trf_complete_pres_nb_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_trf_complete_pres_nb_t == NS_SS_PRES_RESTRICTED_NB)) {	/* redirectionNumber type is NumberScreened */

			if (Ns_qsi_trf_complete_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_qsi_trf_complete_arg.screening_ind = Ns_qsi_trf_complete_scr_ind;
			ns_op_qsi_trf_complete_arg.party_nb_type = Ns_qsi_trf_complete_p_nb_t;
			ns_op_qsi_trf_complete_arg.type_of_nb = (Ns_qsi_trf_complete_t_of_nb == 255) ? 254 : Ns_qsi_trf_complete_t_of_nb;
			ns_op_qsi_trf_complete_arg.redir_nb.size = size = Ns_qsi_trf_complete_nb_sz;
			ns_op_qsi_trf_complete_arg.redir_nb.p_string = p_ind_buffer;
				/* redirection number string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		size = Ns_qsi_trf_complete_ie_sz;
		if (size == 0) {	/* Q-SIG IE is absent */

			ns_op_qsi_trf_complete_arg.ie.size = 254;

		} else {	/* Q-SIG IE is present */

			ns_op_qsi_trf_complete_arg.ie.size = size;
			ns_op_qsi_trf_complete_arg.ie.p_string = p_ind_buffer;
				/* Q-SIG IE string : after redirection number string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

        size = 0;
		if (Ns_qsi_trf_complete_name_t != 255) {

			if (Ns_qsi_trf_complete_name_t > NS_SS_QSI_MX_NAME_TYPE) {

				return (NOK);	/* bad type of Name */
			}

			ns_op_qsi_trf_complete_arg.name_type = Ns_qsi_trf_complete_name_t;
			if (Ns_qsi_trf_complete_name_t != NS_SS_QSI_NAME_NOT_AVAIL) {	/* Name includes a string */

				ns_op_qsi_trf_complete_arg.character = (Ns_qsi_trf_complete_name_char == 255) ? 254 : Ns_qsi_trf_complete_name_char;
				size = Ns_qsi_trf_complete_name_sz;
				if (size != 0) {	/* NameData is absent */

					ns_op_qsi_trf_complete_arg.name.size = size;
					ns_op_qsi_trf_complete_arg.name.p_string = p_ind_buffer;
						/* NameData string : after Q-SIG IE string -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */
				}
			}
		}

		if (size == 0) {	/* NameData is absent */

			ns_op_qsi_trf_complete_arg.name_type = 254;
			ns_op_qsi_trf_complete_arg.name.size = 254;
		}

		ns_op_qsi_trf_complete_arg.extension.size = size = Ns_qsi_trf_complete_ext_sz;
		ns_op_qsi_trf_complete_arg.extension.p_string = p_ind_buffer;
			/* extension string : after NameData string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		p_next = &(Ns_qsi_trf_complete_first_str);
		Ns_qsi_trf_complete_end_desig = ns_op_qsi_trf_complete_arg.end_designation;
		Ns_qsi_trf_complete_call_stat = ns_op_qsi_trf_complete_arg.call_status;
		Ns_qsi_trf_complete_pres_nb_t = ns_op_qsi_trf_complete_arg.presented_nb_type;
		Ns_qsi_trf_complete_scr_ind = ns_op_qsi_trf_complete_arg.screening_ind;
		Ns_qsi_trf_complete_p_nb_t = ns_op_qsi_trf_complete_arg.party_nb_type;
		Ns_qsi_trf_complete_t_of_nb = ns_op_qsi_trf_complete_arg.type_of_nb;
		Ns_qsi_trf_complete_nb_sz = size = ns_op_qsi_trf_complete_arg.redir_nb.size;
			/* redirection number string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_complete_arg.redir_nb.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_complete_ie_sz = size = ns_op_qsi_trf_complete_arg.ie.size;
			/* Q-SIG IE string : after redirection number string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_complete_arg.ie.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_complete_name_t = ns_op_qsi_trf_complete_arg.name_type;
		Ns_qsi_trf_complete_name_char = ns_op_qsi_trf_complete_arg.character;
		Ns_qsi_trf_complete_name_sz = size = ns_op_qsi_trf_complete_arg.name.size;
			/* NameData string : after Q-SIG IE string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_complete_arg.name.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_complete_ext_sz = size = ns_op_qsi_trf_complete_arg.extension.size;
			/* extension string : after NameData string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_complete_arg.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CallTransferUpdate operation */

uchar ns_ssdu_op_qsi_trf_update (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component may contain data */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		if (offset != OFFSET_NIL) {

			return (NOK);	/* there is data in operation but there should not be */
		}

		return (STOP);	/* no data */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		p_next = &(Ns_qsi_trf_update_first_str);
		ns_op_qsi_trf_update_arg.presented_nb_type = Ns_qsi_trf_update_pres_nb_t;
		if (Ns_qsi_trf_update_pres_nb_t > NS_SS_MX_PRES_NB_TYPE) {

			return (NOK);		/* bad type of PresentedAddressScreened */
		}

		if ((Ns_qsi_trf_update_pres_nb_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_trf_update_pres_nb_t == NS_SS_PRES_RESTRICTED_NB)) {	/* redirectionNumber type is NumberScreened */

			if (Ns_qsi_trf_update_p_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			ns_op_qsi_trf_update_arg.screening_ind = Ns_qsi_trf_update_scr_ind;
			ns_op_qsi_trf_update_arg.party_nb_type = Ns_qsi_trf_update_p_nb_t;
			ns_op_qsi_trf_update_arg.type_of_nb = (Ns_qsi_trf_update_t_of_nb == 255) ? 254 : Ns_qsi_trf_update_t_of_nb;
			ns_op_qsi_trf_update_arg.redir_nb.size = size = Ns_qsi_trf_update_nb_sz;
			ns_op_qsi_trf_update_arg.redir_nb.p_string = p_ind_buffer;
				/* redirection number string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

        size = 0;
		if (Ns_qsi_trf_update_name_t != 255) {

			if (Ns_qsi_trf_update_name_t > NS_SS_QSI_MX_NAME_TYPE) {

				return (NOK);	/* bad type of Name */
			}

			ns_op_qsi_trf_update_arg.name_type = Ns_qsi_trf_update_name_t;
			if (Ns_qsi_trf_update_name_t != NS_SS_QSI_NAME_NOT_AVAIL) {	/* Name includes a string */

				ns_op_qsi_trf_update_arg.character = (Ns_qsi_trf_update_name_char == 255) ? 254 : Ns_qsi_trf_update_name_char;
				size = Ns_qsi_trf_update_name_sz;
				if (size != 0) {	/* NameData is absent */

					ns_op_qsi_trf_update_arg.name.size = size;
					ns_op_qsi_trf_update_arg.name.p_string = p_ind_buffer;
						/* NameData string : after redirection number string -> copy it into indirect buffer */
					Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
					p_ind_buffer += size;		/* update pointer to indirect buffer */
					p_next += size;				/* update pointer to current string inside SSDU */
				}
			}
		}

		if (size == 0) {	/* NameData is absent */

			ns_op_qsi_trf_update_arg.name_type = 254;
			ns_op_qsi_trf_update_arg.name.size = 254;
		}

		size = Ns_qsi_trf_update_ie_sz;
		if (size == 0) {	/* Q-SIG IE is absent */

			ns_op_qsi_trf_update_arg.ie.size = 254;

		} else {	/* Q-SIG IE is present */

			ns_op_qsi_trf_update_arg.ie.size = size;
			ns_op_qsi_trf_update_arg.ie.p_string = p_ind_buffer;
				/* Q-SIG IE string : after NameData string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		ns_op_qsi_trf_update_arg.extension.size = size = Ns_qsi_trf_update_ext_sz;
		ns_op_qsi_trf_update_arg.extension.p_string = p_ind_buffer;
			/* extension string : after Q-SIG IE string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		p_next = &(Ns_qsi_trf_update_first_str);
		Ns_qsi_trf_update_pres_nb_t = ns_op_qsi_trf_update_arg.presented_nb_type;
		Ns_qsi_trf_update_scr_ind = ns_op_qsi_trf_update_arg.screening_ind;
		Ns_qsi_trf_update_p_nb_t = ns_op_qsi_trf_update_arg.party_nb_type;
		Ns_qsi_trf_update_t_of_nb = ns_op_qsi_trf_update_arg.type_of_nb;
		Ns_qsi_trf_update_nb_sz = size = ns_op_qsi_trf_update_arg.redir_nb.size;
			/* redirection number string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_update_arg.redir_nb.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_update_name_t = ns_op_qsi_trf_update_arg.name_type;
		Ns_qsi_trf_update_name_char = ns_op_qsi_trf_update_arg.character;
		Ns_qsi_trf_update_name_sz = size = ns_op_qsi_trf_update_arg.name.size;
			/* NameData string : after redirection number string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_update_arg.name.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_update_ie_sz = size = ns_op_qsi_trf_update_arg.ie.size;
			/* Q-SIG IE string : after NameData string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_update_arg.ie.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_update_ext_sz = size = ns_op_qsi_trf_update_arg.extension.size;
			/* extension string : after Q-SIG IE string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_update_arg.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* SubaddressTransfer operation */

uchar ns_ssdu_op_qsi_trf_subadd (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component may contain data */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		if (offset != OFFSET_NIL) {

			return (NOK);	/* there is data in operation but there should not be */
		}

		return (STOP);	/* no data */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_qsi_trf_subadd_sa_t > NS_SS_MX_PARTY_SA_TYPE) {

			return (NOK);	/* bad type of PartySubaddress */
		}

		p_next = &(Ns_qsi_trf_subadd_first_str);
		ns_op_qsi_trf_subadd_arg.sub_add_type = Ns_qsi_trf_subadd_sa_t;
		ns_op_qsi_trf_subadd_arg.sub_add_odd_count = (Ns_qsi_trf_subadd_sa_odd_c == 255) ? 254 : Ns_qsi_trf_subadd_sa_odd_c;
		ns_op_qsi_trf_subadd_arg.redir_sub_add.p_string = p_ind_buffer;
		ns_op_qsi_trf_subadd_arg.redir_sub_add.size = size = Ns_qsi_trf_subadd_sa_sz;
			/* redirection subaddress string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		ns_op_qsi_trf_subadd_arg.extension.size = size = Ns_qsi_trf_subadd_ext_sz;
		ns_op_qsi_trf_subadd_arg.extension.p_string = p_ind_buffer;
			/* extension string : after redirection subaddress string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		p_next = &(Ns_qsi_trf_subadd_first_str);
		Ns_qsi_trf_subadd_sa_t = ns_op_qsi_trf_subadd_arg.sub_add_type;
		Ns_qsi_trf_subadd_sa_odd_c = ns_op_qsi_trf_subadd_arg.sub_add_odd_count;
		Ns_qsi_trf_subadd_sa_sz = size = ns_op_qsi_trf_subadd_arg.redir_sub_add.size;
			/* redirection subaddress string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_subadd_arg.redir_sub_add.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_subadd_ext_sz = size = ns_op_qsi_trf_subadd_arg.extension.size;
			/* extension string : after redirection subaddress string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_trf_subadd_arg.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif /* end of "NS_SS_CALL_TRANSFER = ON"} */

/*==========================================================================*/

		/*	Path Replacement ANF (Additional Network Feature)
		 * -------------------------------------------------- */

#if NS_SS_PATH_REPLACEMENT == ON /* { */

	/*	PathReplacePropose operation ARGUMENT = PathReplaceRetain operation ARGUMENT :
		same data type as CallTransferIdentify operation RESULT */

#define NS_QSI_PROPOSE_PTHR_ARG_P			NS_QSI_IDENTIFY_TRF_RES_P
#define NS_QSI_RETAIN_PTHR_ARG_P			NS_QSI_IDENTIFY_TRF_RES_P

	/* PathReplaceSetup operation ARGUMENT : same data type as CallTransferSetup operation ARGUMENT */

#define NS_QSI_SETUP_PTHR_ARG_P				NS_QSI_SETUP_TRF_ARG_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

	/* PathReplacePropose operation : ARGUMENT */

struct ns_op_qsi_trf_identify_res	ns_op_qsi_pthr_propose_arg;

	/* PathReplaceSetup operation : ARGUMENT */

struct ns_op_qsi_trf_setup_arg		ns_op_qsi_pthr_setup_arg;

	/* PathReplaceSetup operation : RESULT -> Transparent */

struct ns_asn1_string				ns_op_qsi_pthr_setup_res;

	/* PathReplaceRetain operation : ARGUMENT */

struct ns_op_qsi_trf_identify_res	ns_op_qsi_pthr_retain_arg;

	/* PathReplaceRetain operation : RESULT -> Transparent */

struct ns_asn1_string				ns_op_qsi_pthr_retain_res;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */


#define ns_ssdu_op_qsi_pthr_propose		ns_ssdu_op_qsi_trf_initiate		/* PathReplacePropose operation */
#define ns_ssdu_op_qsi_pthr_retain		ns_ssdu_op_qsi_trf_initiate		/* PathReplaceRetain operation */
#define ns_ssdu_op_qsi_pthr_setup		ns_ssdu_op_qsi_trf_setup		/* PathReplaceSetup operation */

#endif /* end of "NS_SS_PATH_REPLACEMENT = ON"} */

#if (NS_SS_CALL_TRANSFER == ON) || (NS_SS_PATH_REPLACEMENT == ON) /* { */

		/* CallTransferInitiate, PathReplacePropose and PathReplaceRetain operations */

uchar ns_ssdu_op_qsi_trf_initiate (p_start, offset)
	uchar FAR								*p_start;		/* pointer to start of component */
	ushort									offset;			/* offset of data in received SSDU */
{
	uchar FAR								*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar									size;			/* size of current string */
	struct ns_op_qsi_trf_identify_res FAR	*p_i_data;		/* pointer to internal data location */

	if (I_ss_fac_comp_tag == FAC_INVOKE) {

		switch (I_ss_fac_op_err_id) {	/* set internal data pointer according to operation ID */

#			if NS_SS_CALL_TRANSFER == ON
			case NS_OP_QSI_TRF_INITIATE :	/* CallTransferInitiate operation */

				p_i_data = &ns_op_qsi_trf_initiate_arg;
				break;
#			endif

#			if NS_SS_PATH_REPLACEMENT == ON
			case NS_OP_QSI_PTHR_PROPOSE :	/* PathReplacePropose operation */

				p_i_data = &ns_op_qsi_pthr_propose_arg;
				break;

			default :	/* PathReplaceRetain operation */

				p_i_data = &ns_op_qsi_pthr_retain_arg;
				break;
#			endif
		}
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

#			if NS_SS_PATH_REPLACEMENT == ON
			if ((I_ss_fac_comp_tag == FAC_RETURN_RESULT) && (I_ss_fac_op_err_id == NS_OP_QSI_PTHR_PROPOSE)) {

				return (OK);	/* no data : only allowed for RESULT clause of PathReplacePropose operation */
			}
#			endif

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

#			if NS_SS_CALL_TRANSFER == ON
				if (I_ss_fac_op_err_id == NS_OP_QSI_TRF_INITIATE) {	/* CallTransferInitiate operation */

					return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_trf_initiate_res));
				}
#			endif

#			if NS_SS_PATH_REPLACEMENT == ON
				if (I_ss_fac_op_err_id == NS_OP_QSI_PTHR_PROPOSE) {	/* PathReplacePropose operation */

					return (NOK);	/* there is data in operation but there should not be */
				}

						/* PathReplaceRetain operation */
				return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_pthr_retain_res));
#			endif
		}

			/* Invoke component -> process ARGUMENT clause */

		if (Ns_qsi_trf_ident_p_nb_type > NS_SS_MX_PARTY_NB_TYPE) {

			return (NOK);	/* bad type of PartyNumber */
		}

		p_i_data -> party_nb_type = Ns_qsi_trf_ident_p_nb_type;
		p_i_data -> type_of_nb = Ns_qsi_trf_ident_type_of_nb;
		p_next = &(Ns_qsi_trf_ident_first_nb);

		p_i_data -> call_identity.size = size = Ns_qsi_trf_ident_call_id_sz;
		p_i_data -> call_identity.p_string = p_ind_buffer;
			/* callIdentity string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		p_i_data -> rerouting_nb.size = size = Ns_qsi_trf_ident_nb_sz;
		p_i_data -> rerouting_nb.p_string = p_ind_buffer;
			/* reroutingNumber string : after callIdentity string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		p_i_data -> extension.size = size = Ns_qsi_trf_ident_ext_sz;
		p_i_data -> extension.p_string = p_ind_buffer;
			/* extension string : after reroutingNumber string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

#			if NS_SS_CALL_TRANSFER == ON
				if (I_ss_fac_op_err_id == NS_OP_QSI_TRF_INITIATE) {	/* CallTransferInitiate operation */

					return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_trf_initiate_res));
				}
#			endif

#			if NS_SS_PATH_REPLACEMENT == ON
				if (I_ss_fac_op_err_id == NS_OP_QSI_PTHR_PROPOSE) {	/* PathReplacePropose operation */

					return (STOP);	/* no data */
				}

						/* PathReplaceRetain operation */
				return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_pthr_retain_res));
#			endif
		}

			/* Invoke component -> process ARGUMENT clause */

		Ns_qsi_trf_ident_p_nb_type = p_i_data -> party_nb_type;
		Ns_qsi_trf_ident_type_of_nb = p_i_data -> type_of_nb;
		p_next = &(Ns_qsi_trf_ident_first_nb);

		Ns_qsi_trf_ident_call_id_sz = size = p_i_data -> call_identity.size;
			/* callIdentity string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_i_data -> call_identity.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_ident_nb_sz = size = p_i_data -> rerouting_nb.size;
			/* reroutingNumber string : after callIdentity string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_i_data -> rerouting_nb.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_ident_ext_sz = size = p_i_data -> extension.size;
			/* extension string : after reroutingNumber string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_i_data -> extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CallTransferSetup and PathReplaceSetup operations */

uchar ns_ssdu_op_qsi_trf_setup (p_start, offset)
	uchar FAR							*p_start;		/* pointer to start of component */
	ushort								offset;			/* offset of data in received SSDU */
{
	uchar FAR							*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar								size;			/* size of current string */
	struct ns_op_qsi_trf_setup_arg FAR	*p_i_data;		/* pointer to internal data location */

	if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* set internal data pointer according to operation ID */

#		if NS_SS_CALL_TRANSFER == ON
			if (I_ss_fac_op_err_id == NS_OP_QSI_TRF_SETUP) {	/* CallTransferSetup operation */

				p_i_data = &ns_op_qsi_trf_setup_arg;
			}
#		endif

#		if NS_SS_PATH_REPLACEMENT == ON
			if (I_ss_fac_op_err_id == NS_OP_QSI_PTHR_SETUP) {	/* PathReplaceSetup operation */

				p_i_data = &ns_op_qsi_pthr_setup_arg;
			}
#		endif
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

#			if NS_SS_CALL_TRANSFER == ON
				if (I_ss_fac_op_err_id == NS_OP_QSI_TRF_SETUP) {	/* CallTransferSetup operation */

					return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_trf_setup_res));
				}
#			endif

#			if NS_SS_PATH_REPLACEMENT == ON
							/* PathReplaceSetup operation */
				return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_pthr_setup_res));
#			endif
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = &(Ns_qsi_trf_setup_first_nb);
		p_i_data -> call_identity.size = size = Ns_qsi_trf_setup_call_id_sz;
		p_i_data -> call_identity.p_string = p_ind_buffer;
			/* callIdentity string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		p_i_data -> extension.size = size = Ns_qsi_trf_setup_ext_sz;
		p_i_data -> extension.p_string = p_ind_buffer;
			/* extension string : after reroutingNumber string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

#			if NS_SS_CALL_TRANSFER == ON
				if (I_ss_fac_op_err_id == NS_OP_QSI_TRF_SETUP) {	/* CallTransferSetup operation */

					return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_trf_setup_res));
				}
#			endif

#			if NS_SS_PATH_REPLACEMENT == ON
							/* PathReplaceSetup operation */
				return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_pthr_setup_res));
#			endif
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = &(Ns_qsi_trf_setup_first_nb);
		Ns_qsi_trf_setup_call_id_sz = size = p_i_data -> call_identity.size;
			/* callIdentity string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_i_data -> call_identity.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_trf_setup_ext_sz = size = p_i_data -> extension.size;
			/* extension string : after callIdentity string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_i_data -> extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif /* end of "NS_SS_CALL_TRANSFER = ON or NS_SS_PATH_REPLACEMENT == ON"} */

/*==========================================================================*/

		/*	Call Offer SS
		 * -------------- */

#if (NS_SS_CALL_OFFER == ON) || (NS_SS_DO_NOT_DISTURB == ON) || (NS_SS_CALL_INTRUSION == ON) /* { */

	/* operation internal data : argument + result */

	/* PathRetain operation : ARGUMENT */

struct ns_op_qsi_path_retain_arg {
	struct ns_asn1_string	service_list;				/* serviceList string */
	struct ns_asn1_string	extension;					/* extension string */
	uchar					choice_index;				/* index of chosen type in global CHOICE between serviceList and extendedServiceList :
															this index is set internally according to presence of "extension" */
};

struct ns_op_qsi_path_retain_arg	ns_op_qsi_path_retain_arg;

	/* ServiceAvailable operation : ARGUMENT */

struct ns_op_qsi_path_retain_arg	ns_op_qsi_service_avail_arg;

	/* CallOfferRequest operation : ARGUMENT and RESULT -> Transparent */

#if NS_SS_CALL_OFFER == ON
struct ns_asn1_string	ns_op_qsi_co_request_arg;
struct ns_asn1_string	ns_op_qsi_co_request_res;
#endif

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* PathRetain and ServiceAvailable operations */

uchar ns_ssdu_op_qsi_path_service (p_start, offset)
	uchar FAR								*p_start;		/* pointer to start of component */
	ushort									offset;			/* offset of data in received SSDU */
{
	uchar FAR								*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar									size;			/* size of current string */
	struct ns_op_qsi_path_retain_arg FAR	*p_i_data;		/* pointer to internal data location */

		/* only ARGUMENT clause is defined : only Invoke component may contain data */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		if (offset != OFFSET_NIL) {

			return (NOK);	/* there is data in operation but there should not be */
		}

		return (STOP);	/* no data */
	}

		/* set internal data pointer according to operation ID */

	if (I_ss_fac_op_err_id == NS_OP_QSI_PATH_RETAIN) {

		p_i_data = &ns_op_qsi_path_retain_arg;	/* PathRetain operation */

	} else {

		p_i_data = &ns_op_qsi_service_avail_arg;	/* ServiceAvailable operation */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (Ns_qsi_path_service_unused > NS_SS_QSI_CO_MX_UNUSED_BITS) {

			return (NOK);	/* bad number of unused bits in service list string */
		}

		p_next = &(Ns_qsi_path_service_first_str);

		p_i_data -> service_list.size = size = Ns_qsi_path_service_srv_size;
		p_i_data -> service_list.p_string = p_ind_buffer;
			/* serviceList string : at the end of the structure -> copy it into indirect buffer
				with adding first octet which is the number of unused bits at the end of the string */
		*p_ind_buffer++ = Ns_qsi_path_service_unused;
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		size = Ns_qsi_path_service_ext_size;
		if (size == 0) {	/* no "extension" -> choose first Type in CHOICE = serviceList */

			p_i_data -> choice_index = 0;

		} else {	/* "extension" is present -> choose second Type in CHOICE = extendedServiceList */

			p_i_data -> choice_index = 1;
			p_i_data -> extension.size = size;
			p_i_data -> extension.p_string = p_ind_buffer;
				/* extension string : after serviceList string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
		}

	} else {	/* to CALL CONTROL */

		p_next = &(Ns_qsi_path_service_first_str);
			/* first octet of serviceList string is the number of unused bits at the end of the string */
		Ns_qsi_path_service_unused = *(p_i_data -> service_list.p_string);

		Ns_qsi_path_service_srv_size = size = p_i_data -> service_list.size;
			/* serviceList string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_i_data -> service_list.p_string + 1), size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_path_service_ext_size = size = p_i_data -> extension.size;
			/* extension string : after serviceList string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_i_data -> extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* CallOfferRequest operation */

#if NS_SS_CALL_OFFER == ON

uchar ns_ssdu_op_qsi_co_request (p_start, offset)
	uchar FAR							*p_start;		/* pointer to start of component */
	ushort								offset;			/* offset of data in received SSDU */
{
	uchar FAR							*p_next;		/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */
	}

	if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

		return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_co_request_res));
	}

		/* Invoke component -> process ARGUMENT clause */

	return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_co_request_arg));
}

#endif

#endif /* end of "NS_SS_CALL_OFFER = ON or NS_SS_DO_NOT_DISTURB = ON or NS_SS_CALL_INTRUSION = ON"} */

/*==========================================================================*/

		/*	Do Not Disturb (DND) and Do Not Disturb Override (DNDO) SS
		 *	implementation of general ASN1 types (with ASN1 meta-programs)
		 * --------------------------------------------------------------- */

#if (NS_SS_DO_NOT_DISTURB == ON) || (NS_SS_CALL_INTRUSION == ON)

		/* presence indicator for Type Marked OPTIONAL inside ASN1 SEQUENCE type */

#define Qsi_dnd_override_extension		ns_asn1_optional_indicators			/* 'extension' inside DoNotDisturbOverride ARGUMENT : 1 indicator */

		/* DNDOCapabilityLevel ::= ENUMERATED{overrideLowProt(1), overrideMediumProt(2), overrideHighProt(3)} */

#define NS_QSI_DNDO_CAP_LEVEL_P			NS_SS_ENUMERATED_P

struct ns_op_qsi_dnd_override_arg {
	struct ns_asn1_string	extension;				/* extension string */
	uchar					capability_level;		/* dndoCapabilityLevel */

};

#endif

#if NS_SS_DO_NOT_DISTURB == ON /* { */

#define Qsi_dnd_activ_arg_extension		ns_asn1_optional_indicators			/* 'extension' inside DoNotDisturbActivate ARGUMENT : 1 indicator */

#define Qsi_dnd_protect_level			ns_asn1_optional_indicators			/* 'dndProtectionLevel' in status inside DoNotDisturbActivate RESULT : NS_SS_QSI_MX_DND_STATUS indicators */
#define Qsi_dnd_activ_status			(ns_asn1_optional_indicators + NS_SS_QSI_MX_DND_STATUS)	/* 'status' inside DoNotDisturbActivate RESULT : 1 indicator */
#define Qsi_dnd_activ_extension			(ns_asn1_optional_indicators + NS_SS_QSI_MX_DND_STATUS + 1)	/* 'extension' inside DoNotDisturbActivate RESULT : 1 indicator */

#define Qsi_dnd_interog_extension		ns_asn1_optional_indicators			/* 'extension' inside DoNotDisturbInterrogate ARGUMENT : 1 indicator */

		/* DNDProtectionLevel ::= ENUMERATED{lowProtection(0), mediumProtection(1), highProtection(2), fullProtection(3)} */

#define NS_QSI_DND_PROTECT_LEVEL_P		NS_SS_ENUMERATED_P

	/* DoNotDisturbDeactivate operation ARGUMENT : same data type as DoNotDisturbActivate operation ARGUMENT */

#define NS_QSI_DEA_DND_ARG_P			NS_QSI_ACTIVATE_DND_ARG_P

	/* DoNotDisturbInterrogate operation RESULT : same data type as DoNotDisturbActivate operation RESULT */

#define NS_QSI_INTEROG_DND_RES_P		NS_QSI_ACTIVATE_DND_RES_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

	/* DoNotDisturbActivate operation : ARGUMENT */

struct ns_op_qsi_dnd_activate_arg {
	struct ns_asn1_string	served_user_nb;			/* NumberDigits string in PartyNumber inside servedUserNr */
	struct ns_asn1_string	extension;				/* extension string */
	uchar					basic_service;			/* basicService in ARGUMENT : ENUMERATED {0, 1, .. , 4, 32, 33, .. , 38} */
	uchar					party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserNr */
	uchar					type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr) */

} ns_op_qsi_dnd_activate_arg;

	/* DoNotDisturbActivate operation : RESULT */

struct ns_op_qsi_dnd_activate_res {
	struct ns_asn1_string	extension;									/* extension string */
	uchar					status_nb;									/* number of (basic service + protection level) in status */
	uchar					basic_service[NS_SS_QSI_MX_DND_STATUS];		/* basicService in status */
	uchar					protect_level[NS_SS_QSI_MX_DND_STATUS];		/* dndProtectionLevel in status */

} ns_op_qsi_dnd_activate_res;

	/* DoNotDisturbDeactivate operation : ARGUMENT */

struct ns_op_qsi_dnd_activate_arg	ns_op_qsi_dnd_dea_arg;

	/* DoNotDisturbDeactivate operation : RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_dnd_dea_res;

	/* DoNotDisturbInterrogate operation : ARGUMENT */

struct ns_op_qsi_dnd_interog_arg {
	struct ns_asn1_string	served_user_nb;			/* NumberDigits string in PartyNumber inside servedUserNr */
	struct ns_asn1_string	extension;				/* extension string */
	uchar					party_nb_type;			/* index of chosen type in PartyNumber (unknownPartyNumber .. nationalStandardPartyNumber) inside servedUserNr */
	uchar					type_of_nb;				/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless (inside servedUserNr) */

} ns_op_qsi_dnd_interog_arg;

	/* DoNotDisturbInterrogate operation : RESULT */

struct ns_op_qsi_dnd_activate_res	ns_op_qsi_dnd_interog_res;

	/* DoNotDisturbOverride operation : ARGUMENT */

struct ns_op_qsi_dnd_override_arg	ns_op_qsi_dnd_override_arg;

	/* DoNotDisturbOvrExecute operation : ARGUMENT and RESULT -> Transparent */

struct ns_asn1_string	ns_op_qsi_dndo_exec_arg;
struct ns_asn1_string	ns_op_qsi_dndo_exec_res;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* DoNotDisturbActivate, DoNotDisturbDeactivate and DoNotDisturbInterrogate operations */

#define ns_ssdu_op_qsi_dnd_dea		ns_ssdu_op_qsi_dnd_activate
#define ns_ssdu_op_qsi_dnd_inter	ns_ssdu_op_qsi_dnd_activate

uchar ns_ssdu_op_qsi_dnd_activate (p_start, offset)
	uchar FAR								*p_start;		/* pointer to start of component */
	ushort									offset;			/* offset of data in received SSDU */
{
	uchar FAR								*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar									size;			/* size of current string */
	uchar									index;			/* current index */
	struct ns_op_qsi_dnd_activate_arg FAR	*p_arg_data;	/* pointer to internal ARGUMENT data location */
	struct ns_op_qsi_dnd_activate_res FAR	*p_res_data;	/* pointer to internal RESULT data location */

	if (I_ss_fac_comp_tag == FAC_INVOKE) {

			/* set internal ARGUMENT data pointer according to operation ID */

		if (I_ss_fac_op_err_id == NS_OP_QSI_DND_DEACTIVATE) {	/* DoNotDisturbDeactivate operation */

			p_arg_data = &ns_op_qsi_dnd_dea_arg;

		} else {

			p_arg_data = &ns_op_qsi_dnd_activate_arg;
		}

	} else {

			/* set internal RESULT data pointer according to operation ID */

		if (I_ss_fac_op_err_id == NS_OP_QSI_DND_ACTIVATE) {	/* DoNotDisturbActivate operation */

			p_res_data = &ns_op_qsi_dnd_activate_res;

		} else {

			p_res_data = &ns_op_qsi_dnd_interog_res;
		}
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			if (I_ss_fac_op_err_id == NS_OP_QSI_DND_INTERROGATE) {	/* DoNotDisturbInterrogate operation */

				if (Ns_qsi_dnd_inter_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				ns_op_qsi_dnd_interog_arg.party_nb_type = Ns_qsi_dnd_inter_party_nb_t;
				ns_op_qsi_dnd_interog_arg.type_of_nb = Ns_qsi_dnd_inter_type_of_nb;
				p_next = &(Ns_qsi_dnd_inter_first_nb);
				ns_op_qsi_dnd_interog_arg.served_user_nb.size = size = Ns_qsi_dnd_inter_nb_sz;
				ns_op_qsi_dnd_interog_arg.served_user_nb.p_string = p_ind_buffer;
					/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

				ns_op_qsi_dnd_interog_arg.extension.size = size = Ns_qsi_dnd_inter_ext_sz;
				ns_op_qsi_dnd_interog_arg.extension.p_string = p_ind_buffer;

			} else {	/* DoNotDisturbActivate or DoNotDisturbDeactivate operation */

				if (Ns_qsi_dnd_activ_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

					return (NOK);	/* bad type of PartyNumber */
				}

				p_arg_data -> basic_service = Ns_qsi_dnd_activ_basic_srv;
				p_arg_data -> party_nb_type = Ns_qsi_dnd_activ_party_nb_t;
				p_arg_data -> type_of_nb = Ns_qsi_dnd_activ_type_of_nb;
				p_next = &(Ns_qsi_dnd_activ_first_nb);
				p_arg_data -> served_user_nb.size = size = Ns_qsi_dnd_activ_nb_sz;
				p_arg_data -> served_user_nb.p_string = p_ind_buffer;
					/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				p_next += size;				/* update pointer to current string inside SSDU */

				p_arg_data -> extension.size = size = Ns_qsi_dnd_activ_ext_sz;
				p_arg_data -> extension.p_string = p_ind_buffer;
			}

				/* extension string : after servedUserNr string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		if (I_ss_fac_op_err_id == NS_OP_QSI_DND_DEACTIVATE) {	/* DoNotDisturbDeactivate operation */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_dnd_dea_res));
		}

			/* DoNotDisturbActivate or DoNotDisturbInterrogate operation */

		p_next = &(Ns_qsi_dnd_act_res_first_str);
		p_res_data -> extension.size = size = Ns_qsi_dnd_act_res_ext_sz;
		p_res_data -> extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

		index = 0;									/* initialize current index */
		offset = Ns_qsi_dnd_act_res_status;			/* get content of first instance in status */

		while (offset != OFFSET_NIL) {

			if (index >= NS_SS_QSI_MX_DND_STATUS) {

				return (NOK);	/* too many instances */
			}

			p_next = p_start + offset;						/* get content of current IntResult */

			if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

				return (NOK);	/* component data is after end of SSDU or before start of component ! */
			}

			p_ssdu_val = p_next;		/* update SSDU pointer to analyse IntResult content */

			p_res_data -> basic_service[index] = Ns_qsi_dnd_status_basic_srv;
			p_res_data -> protect_level[index++] = (Ns_qsi_dnd_status_protect_l == 255) ? 254 : Ns_qsi_dnd_status_protect_l;
			offset = Ns_qsi_dnd_status_next;	/* get content of next instance */
		}

		p_res_data -> status_nb = (index == 0) ? 254 : index;	/* number of instances in status */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

			if (I_ss_fac_op_err_id == NS_OP_QSI_DND_INTERROGATE) {	/* DoNotDisturbInterrogate operation */

				Ns_qsi_dnd_inter_party_nb_t = ns_op_qsi_dnd_interog_arg.party_nb_type;
				Ns_qsi_dnd_inter_type_of_nb = ns_op_qsi_dnd_interog_arg.type_of_nb;
				p_next = &(Ns_qsi_dnd_inter_first_nb);
				Ns_qsi_dnd_inter_nb_sz = size = ns_op_qsi_dnd_interog_arg.served_user_nb.size;
					/* servedUserNr string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_dnd_interog_arg.served_user_nb.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */

				Ns_qsi_dnd_inter_ext_sz = size = ns_op_qsi_dnd_interog_arg.extension.size;
					/* extension string : after servedUserNr string */
				Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_dnd_interog_arg.extension.p_string, size);

			} else {	/* DoNotDisturbActivate or DoNotDisturbDeactivate operation */

				Ns_qsi_dnd_activ_basic_srv = p_arg_data -> basic_service;
				Ns_qsi_dnd_activ_party_nb_t = p_arg_data -> party_nb_type;
				Ns_qsi_dnd_activ_type_of_nb = p_arg_data -> type_of_nb;
				p_next = &(Ns_qsi_dnd_activ_first_nb);
				Ns_qsi_dnd_activ_nb_sz = size = p_arg_data -> served_user_nb.size;
					/* servedUserNr string : at the end of the structure */
				Memcpy_far ((char FAR *)p_next, (char FAR *)p_arg_data -> served_user_nb.p_string, size);
				p_next += size;				/* update pointer to current string inside SSDU */

				Ns_qsi_dnd_activ_ext_sz = size = p_arg_data -> extension.size;
					/* extension string : after servedUserNr string */
				Memcpy_far ((char FAR *)p_next, (char FAR *)p_arg_data -> extension.p_string, size);
			}

			p_next += size;				/* update pointer to current string inside SSDU */
			p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			return (OK);
		}

			/* ReturnResult component -> process RESULT clause */

		if (I_ss_fac_op_err_id == NS_OP_QSI_DND_DEACTIVATE) {	/* DoNotDisturbDeactivate operation */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_dnd_dea_res));
		}

			/* DoNotDisturbActivate or DoNotDisturbInterrogate operation */

		p_next = &(Ns_qsi_dnd_act_res_first_str);
		Ns_qsi_dnd_act_res_ext_sz = size = p_res_data -> extension.size;
			/* extension string : after servedUserNr string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_res_data -> extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */

		offset = (ushort)(p_res_data -> status_nb);	/* use 'offset' as counter of number of instances */

		if (offset == 0) {

			Ns_qsi_dnd_act_res_status = OFFSET_NIL;	/* no status in RESULT */
			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			return (OK);
		}

		Ns_qsi_dnd_act_res_status = (ushort)(p_next - p_start);
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
		index = 0;	/* initialize current index */
		while (offset-- > 0) {

			Ns_qsi_dnd_status_basic_srv = p_res_data -> basic_service[index];
			Ns_qsi_dnd_status_protect_l = p_res_data -> protect_level[index];
			p_next += Rnd_sizeof (struct ns_qsi_dnd_status_instance);
			if (offset == 0) {

				Ns_qsi_dnd_status_next = OFFSET_NIL;

			} else {

				Ns_qsi_dnd_status_next = (ushort)(p_next - p_start);
			}

			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			index++;			/* get next instance internal structure */
		}
	}

	return (OK);
}

		/* DoNotDisturbOverride operation */

uchar ns_ssdu_op_qsi_dnd_override (p_start, offset)
	uchar FAR						*p_start;			/* pointer to start of component */
	ushort							offset;				/* offset of data in received SSDU */
{
	uchar FAR						*p_next;			/* pointer to next data location for "p_ssdu_val" */
	uchar							size;				/* size of current string */

		/* only ARGUMENT clause is defined : only Invoke component may contain data */

	if (I_ss_fac_comp_tag != FAC_INVOKE) {

		if (offset != OFFSET_NIL) {

			return (NOK);	/* there is data in operation but there should not be */
		}

		return (STOP);	/* no data */
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		p_next = &(Ns_qsi_dnd_over_first_str);
		ns_op_qsi_dnd_override_arg.capability_level = Ns_qsi_dnd_over_capability;
		ns_op_qsi_dnd_override_arg.extension.size = size = Ns_qsi_dnd_over_ext_sz;
		ns_op_qsi_dnd_override_arg.extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		p_next = &(Ns_qsi_dnd_over_first_str);
		Ns_qsi_dnd_over_capability = ns_op_qsi_dnd_override_arg.capability_level;
		Ns_qsi_dnd_over_ext_sz = size = ns_op_qsi_dnd_override_arg.extension.size;
			/* extension string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_dnd_override_arg.extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

		/* DoNotDisturbOvrExecute operation */

uchar ns_ssdu_op_qsi_dnd_ovr_exec (p_start, offset)
	uchar FAR							*p_start;		/* pointer to start of component */
	ushort								offset;			/* offset of data in received SSDU */
{
	uchar FAR							*p_next;		/* pointer to next data location for "p_ssdu_val" */

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */
	}

	if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

		return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_dndo_exec_res));
	}

		/* Invoke component -> process ARGUMENT clause */

	return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_dndo_exec_arg));
}

#endif /* end of "NS_SS_DO_NOT_DISTURB = ON"} */

/*==========================================================================*/

		/* Call Completion SS, including 2 services : Call Completion
		 * to Busy Subscriber (CCBS), Call Completion on No Reply (CCNR)
		 * ------------------------------------------------------------- */

#if NS_SS_CCBS == ON	/* { */

		/* lists of presence indicators for instances of Types Marked OPTIONAL (or DEFAULT) inside ASN1 SEQUENCE type */

#define Qsi_ccbs_rq_subadd_a			(ns_asn1_optional_indicators + 2)	/* 'subaddrA' inside CcbsRequest ARGUMENT : 1 indicator */
#define Qsi_ccbs_rq_subadd_b			(ns_asn1_optional_indicators + 3)	/* 'subaddrB' inside CcbsRequest ARGUMENT : 1 indicator */
#define Qsi_ccbs_rq_can_ret_srv			(ns_asn1_optional_indicators + 4)	/* 'can-retain-service' inside CcbsRequest ARGUMENT : 1 indicator */
#define Qsi_ccbs_rq_ret_sig_conn		(ns_asn1_optional_indicators + 5)	/* 'retain-sig-connection' inside CcbsRequest ARGUMENT : 1 indicator */
#define Qsi_ccbs_rq_extension			(ns_asn1_optional_indicators + 6)	/* 'extension' inside CcbsRequest ARGUMENT : 1 indicator */

#define Qsi_ccbs_rq_path_reserv			ns_asn1_optional_indicators			/* 'no-path-reservation' inside CcbsRequest RESULT : 1 indicator */
#define Qsi_ccbs_rq_res_ret_srv			(ns_asn1_optional_indicators + 1)	/* 'retain-service' inside CcbsRequest RESULT : 1 indicator */
#define Qsi_ccbs_rq_res_extension		(ns_asn1_optional_indicators + 2)	/* 'extension' inside CcbsRequest RESULT : 1 indicator */

#define Qsi_ccbs_optional_subadd_a		(ns_asn1_optional_indicators + 2)	/* 'subaddrA' inside CcOptionalArg : 1 indicator */
#define Qsi_ccbs_optional_subadd_b		(ns_asn1_optional_indicators + 3)	/* 'subaddrB' inside CcOptionalArg : 1 indicator */
#define Qsi_ccbs_optional_extension		(ns_asn1_optional_indicators + 4)	/* 'extension' inside CcOptionalArg : 1 indicator */

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

	/* CcnrRequest operation : ARGUMENT and RESULT */

struct ns_op_ccbs_t_rq_arg			ns_op_qsi_ccnr_request_arg;
struct ns_op_ccbs_status_rq_arg		ns_op_qsi_ccnr_request_res;

	/* CcCancel and CcExecPossible operations : ARGUMENT
		2 internal structures are necessary for 'extension' according to type of ARGUMENT */

struct ns_op_ccbs_t_rq_arg			ns_op_qsi_cc_cancel_arg;
struct ns_asn1_string				ns_op_qsi_cc_cancel_ext;

struct ns_op_ccbs_t_rq_arg			ns_op_qsi_cc_exec_possib_arg;
struct ns_asn1_string				ns_op_qsi_cc_exec_possib_ext;

	/* CcPathReserve operation : ARGUMENT and RESULT */

struct ns_asn1_string	ns_op_qsi_cc_path_reserve_arg;
struct ns_asn1_string	ns_op_qsi_cc_path_reserve_res;

	/* CcRingout operation : ARGUMENT */

struct ns_asn1_string	ns_op_qsi_cc_ringout;

	/* CcSuspend operation : ARGUMENT */

struct ns_asn1_string	ns_op_qsi_cc_suspend;

	/* CcResume operation : ARGUMENT */

struct ns_asn1_string	ns_op_qsi_cc_resume;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* CcbsRequest, CcnrRequest CcCancel and CcExecPossible operations */

uchar ns_ssdu_op_qsi_ccbs_rq (p_start, offset)
	uchar FAR								*p_start;		/* pointer to start of component */
	ushort									offset;			/* offset of data in received SSDU */
{
	uchar FAR								*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar							        size;			/* size of current string */
	struct ns_op_ccbs_t_rq_arg FAR			*p_arg_data;	/* pointer to internal ARGUMENT data location */
	struct ns_op_ccbs_status_rq_arg FAR		*p_res_data;	/* pointer to internal RESULT data location */

	 /* 'ns_op_ccbs_status_rq_arg' structure is used for the operation RESULT internal content with :
			- 'recall_mode' = no-path-reservation value
			- 'reference' = retain-service value
			- 'q931_ie'  = extension string */

		/* set internal data pointer according to operation ID */

	if (I_ss_fac_comp_tag == FAC_INVOKE) {

		switch (I_ss_fac_op_err_id) {

			case NS_OP_QSI_CCBS_RQ : /* CcbsRequest */

				p_arg_data = &ns_op_ccbs_t_rq_arg;
				break;

			case NS_OP_QSI_CCNR_RQ : /* CcnrRequest */

				p_arg_data = &ns_op_qsi_ccnr_request_arg;
				break;

			case NS_OP_QSI_CC_CANCEL : /* CcCancel */

				p_arg_data = &ns_op_qsi_cc_cancel_arg;
				break;

			default : /* CcExecPossible */

				p_arg_data = &ns_op_qsi_cc_exec_possib_arg;
				break;
		}

	} else {

		if ((I_ss_fac_op_err_id == NS_OP_QSI_CC_CANCEL) ||
			(I_ss_fac_op_err_id == NS_OP_QSI_CC_EXEC_POSSIBLE)) {	/* CcCancel or CcExecPossible : RESULT is empty */

			if (offset != OFFSET_NIL) {

				return (NOK);	/* there is data but there should not be */
			}

            return (STOP);	/* no data */
		}

		if (I_ss_fac_op_err_id == NS_OP_QSI_CCBS_RQ) { /* CcbsRequest */

			p_res_data = &ns_op_ccbs_status_rq_arg;

		} else { /* CcnrRequest */

			p_res_data = &ns_op_qsi_ccnr_request_res;
		}
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			p_res_data -> recall_mode = (Ns_qsi_ccbs_rq_res_no_path_r == 255) ? 254 : Ns_qsi_ccbs_rq_res_no_path_r;
			p_res_data -> reference = (Ns_qsi_ccbs_rq_res_retain_srv == 255) ? 254 : Ns_qsi_ccbs_rq_res_retain_srv;
			p_next = &(Ns_qsi_ccbs_rq_res_first_str);
				/* extension string : at the end of the structure -> copy it into indirect buffer */
			p_res_data -> q931_ie.size = size = Ns_qsi_ccbs_rq_res_ext_sz;
			p_res_data -> q931_ie.p_string = p_ind_buffer;
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			return (OK);
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = &(Ns_qsi_ccbs_rq_first_nb);
		p_arg_data -> presented_nbA_type = Ns_qsi_ccbs_rq_A_pres_nb_t;
		if ((I_ss_fac_op_err_id == NS_OP_QSI_CC_CANCEL) ||
			(I_ss_fac_op_err_id == NS_OP_QSI_CC_EXEC_POSSIBLE)) {	/* CcCancel or CcExecPossible */

			if (Ns_qsi_cc_cncel_exec_arg_type == NS_QSI_CC_OPTIONAL_EXT_ARG) {
				/* type of ARGUMENT is extArg : only extension parameter(size + string) is relevant */

				size = Ns_qsi_ccbs_rq_ext_sz;
				if (I_ss_fac_op_err_id == NS_OP_QSI_CC_CANCEL) {

					ns_op_qsi_cc_cancel_ext.size = size;
					ns_op_qsi_cc_cancel_ext.p_string = p_ind_buffer;

				} else {

					ns_op_qsi_cc_exec_possib_ext.size = size;
					ns_op_qsi_cc_exec_possib_ext.p_string = p_ind_buffer;
				}
					/* extension string : at the end of the structure -> copy it into indirect buffer */
				Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
				p_ind_buffer += size;		/* update pointer to indirect buffer */
				return (OK);
			}

			if (Ns_qsi_cc_cncel_exec_arg_type != NS_QSI_CC_OPTIONAL_FULL_ARG) {

				return (NOK);	/* bad type of ARGUMENT */
			}
				/* type is fullArg : all parameters in ARGUMENT are relevant */
		}

		if ((Ns_qsi_ccbs_rq_A_pres_nb_t > NS_SS_MX_PRES_NB_TYPE) ||
			(Ns_qsi_ccbs_rq_B_party_nb_t > NS_SS_MX_PARTY_NB_TYPE)) {

			return (NOK);	/* bad type of PresentedNumberUnscreened or of PartyNumber */
		}

		if ((Ns_qsi_ccbs_rq_A_pres_nb_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_ccbs_rq_A_pres_nb_t == NS_SS_PRES_RESTRICTED_NB) ||
			(I_ss_fac_op_err_id == NS_OP_QSI_CC_CANCEL) ||
			(I_ss_fac_op_err_id == NS_OP_QSI_CC_EXEC_POSSIBLE)) {
				/* numberA type is PartyNumber */

			if (Ns_qsi_ccbs_rq_A_party_nb_t > NS_SS_MX_PARTY_NB_TYPE) {

				return (NOK);	/* bad type of PartyNumber */
			}

			p_arg_data -> dest_party_nb_t = Ns_qsi_ccbs_rq_A_party_nb_t;

			if ((Ns_qsi_ccbs_rq_A_party_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
				(Ns_qsi_ccbs_rq_A_party_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

				p_arg_data -> dest_t_of_nb = (Ns_qsi_ccbs_rq_A_t_of_nb == 255) ? 254 : Ns_qsi_ccbs_rq_A_t_of_nb;
			}

			p_arg_data -> dest_nb_digits.size = size = Ns_qsi_ccbs_rq_A_nb_sz;
			p_arg_data -> dest_nb_digits.p_string = p_ind_buffer;
				/* numberA string : at the end of the structure -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		p_arg_data -> orig_party_nb_t = Ns_qsi_ccbs_rq_B_party_nb_t;
		p_arg_data -> orig_t_of_nb = (Ns_qsi_ccbs_rq_B_t_of_nb == 255) ? 254 : Ns_qsi_ccbs_rq_B_t_of_nb;
		p_arg_data -> orig_nb_digits.size = size = Ns_qsi_ccbs_rq_B_nb_sz;
		p_arg_data -> orig_nb_digits.p_string = p_ind_buffer;
			/* numberB string : after numberA string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		p_arg_data -> q931_ie.size = size = Ns_qsi_ccbs_rq_service_sz;
		p_arg_data -> q931_ie.p_string = p_ind_buffer;
			/* service string : after numberB string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */
		p_next += size;				/* update pointer to current string inside SSDU */

		if (Ns_qsi_ccbs_rq_A_sa_type != 255) {	/* subaddrA is present */

			if (Ns_qsi_ccbs_rq_A_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			p_arg_data -> dest_sa_type = Ns_qsi_ccbs_rq_A_sa_type;
			if (Ns_qsi_ccbs_rq_A_sa_type == NS_SS_PARTY_SA_USER_SPECIF) {

				p_arg_data -> dest_sa_odd_c = (Ns_qsi_ccbs_rq_A_sa_odd_c == 255) ? 254 : Ns_qsi_ccbs_rq_A_sa_odd_c;
			}

			p_arg_data -> dest_sub_add.size = size = Ns_qsi_ccbs_rq_A_sa_sz;
			p_arg_data -> dest_sub_add.p_string = p_ind_buffer;
				/* subaddrA string : after service string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* subaddrB is absent */

			p_arg_data -> dest_sa_type = 254;
			p_arg_data -> dest_sub_add.size = 254;
		}

		if (Ns_qsi_ccbs_rq_B_sa_type != 255) {	/* subaddrA is present */

			if (Ns_qsi_ccbs_rq_B_sa_type > NS_SS_MX_PARTY_SA_TYPE) {

				return (NOK);	/* bad type of PartySubaddress */
			}

			p_arg_data -> orig_sa_type = Ns_qsi_ccbs_rq_B_sa_type;
			p_arg_data -> orig_sa_odd_c = (Ns_qsi_ccbs_rq_B_sa_odd_c == 255) ? 254 : Ns_qsi_ccbs_rq_B_sa_odd_c;
			p_arg_data -> orig_sub_add.size = size = Ns_qsi_ccbs_rq_B_sa_sz;
			p_arg_data -> orig_sub_add.p_string = p_ind_buffer;
				/* subaddrB string : after subaddrA string -> copy it into indirect buffer */
			Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
			p_ind_buffer += size;		/* update pointer to indirect buffer */
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* subaddrB is absent */

			p_arg_data -> orig_sa_type = 254;
			p_arg_data -> orig_sub_add.size = 254;
		}

		p_arg_data -> retention = (Ns_qsi_ccbs_rq_can_ret_srv == 255) ? 254 : Ns_qsi_ccbs_rq_can_ret_srv;
		p_arg_data -> pres_allow = (Ns_qsi_ccbs_rq_ret_sig == 255) ? 254 : Ns_qsi_ccbs_rq_ret_sig;

		p_arg_data -> extension.size = size = Ns_qsi_ccbs_rq_ext_sz;
		p_arg_data -> extension.p_string = p_ind_buffer;
			/* extension string : after subaddrB string -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if (I_ss_fac_comp_tag == FAC_RETURN_RESULT) {	/* ReturnResult component -> process RESULT clause */

			Ns_qsi_ccbs_rq_res_no_path_r = p_res_data -> recall_mode;
			Ns_qsi_ccbs_rq_res_retain_srv = p_res_data -> reference;
			p_next = &(Ns_qsi_ccbs_rq_res_first_str);
				/* extension string : at the end of the structure */
			Ns_qsi_ccbs_rq_res_ext_sz = size = p_res_data -> q931_ie.size;
			Memcpy_far ((char FAR *)p_next, (char FAR *)(p_res_data -> q931_ie.p_string), size);
			p_next += size;				/* update pointer to current string inside SSDU */
			p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
			p_ssdu_val = p_next;	/* update current SSDU value pointer */
			return (OK);
		}

			/* Invoke component -> process ARGUMENT clause */

		p_next = &(Ns_qsi_ccbs_rq_first_nb);
		Ns_qsi_ccbs_rq_A_pres_nb_t = p_arg_data -> presented_nbA_type;
		if ((I_ss_fac_op_err_id == NS_OP_QSI_CC_CANCEL) ||
			(I_ss_fac_op_err_id == NS_OP_QSI_CC_EXEC_POSSIBLE)) {	/* CcCancel or CcExecPossible */

			if (Ns_qsi_cc_cncel_exec_arg_type == NS_QSI_CC_OPTIONAL_EXT_ARG) {
				/* type of ARGUMENT is extArg : only extension parameter(size + string) is relevant */

				if (I_ss_fac_op_err_id == NS_OP_QSI_CC_CANCEL) {

					size = ns_op_qsi_cc_cancel_ext.size;
						/* extension string : at the end of the structure */
					Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_cc_cancel_ext.p_string, size);

				} else {

					size = ns_op_qsi_cc_exec_possib_ext.size;
						/* extension string : at the end of the structure */
					Memcpy_far ((char FAR *)p_next, (char FAR *)ns_op_qsi_cc_exec_possib_ext.p_string, size);
				}

				Ns_qsi_ccbs_rq_ext_sz = size;
				p_next += size;				/* update pointer to current string inside SSDU */
				p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
				p_ssdu_val = p_next;	/* update current SSDU value pointer */
				return (OK);
			}
				/* type is fullArg : all parameters in ARGUMENT are relevant */
		}

		if ((Ns_qsi_ccbs_rq_A_pres_nb_t == NS_SS_PRES_ALLOWED_NB) ||
			(Ns_qsi_ccbs_rq_A_pres_nb_t == NS_SS_PRES_RESTRICTED_NB) ||
			(I_ss_fac_op_err_id == NS_OP_QSI_CC_CANCEL) ||
			(I_ss_fac_op_err_id == NS_OP_QSI_CC_EXEC_POSSIBLE)) {
				/* numberA type is PartyNumber */

			Ns_qsi_ccbs_rq_A_party_nb_t = p_arg_data -> dest_party_nb_t;
			if ((Ns_qsi_ccbs_rq_A_party_nb_t == NS_SS_PARTY_NB_PUBLIC) ||
				(Ns_qsi_ccbs_rq_A_party_nb_t == NS_SS_PARTY_NB_PRIVATE)) {

				Ns_qsi_ccbs_rq_A_t_of_nb = p_arg_data -> dest_t_of_nb;

			} else { /* 'Type of Nb' field is meaningless -> the one stored is in fact for numberB */

				p_arg_data -> orig_t_of_nb = p_arg_data -> dest_t_of_nb;
			}

			Ns_qsi_ccbs_rq_A_nb_sz = size = p_arg_data -> dest_nb_digits.size;
				/* numberA string : at the end of the structure */
			Memcpy_far ((char FAR *)p_next, (char FAR *)(p_arg_data -> dest_nb_digits.p_string), size);
			p_next += size;				/* update pointer to current string inside SSDU */

		} else {	/* numberA type is NULL -> the internal values stored are in fact the ones for numberB */

			p_arg_data -> orig_party_nb_t = p_arg_data -> dest_party_nb_t;
			p_arg_data -> orig_t_of_nb = p_arg_data -> dest_t_of_nb;
			p_arg_data -> orig_nb_digits.size = p_arg_data -> dest_nb_digits.size;
			p_arg_data -> orig_nb_digits.p_string = p_arg_data -> dest_nb_digits.p_string;
		}

		Ns_qsi_ccbs_rq_B_party_nb_t = p_arg_data -> orig_party_nb_t;
		Ns_qsi_ccbs_rq_B_t_of_nb = p_arg_data -> orig_t_of_nb;
		Ns_qsi_ccbs_rq_B_nb_sz = size = p_arg_data -> orig_nb_digits.size;
			/* numberB string : after numberA string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_arg_data -> orig_nb_digits.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_ccbs_rq_service_sz = size = p_arg_data -> q931_ie.size;
			/* service string : after numberB string */
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_arg_data -> q931_ie.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */

		Ns_qsi_ccbs_rq_A_sa_type = p_arg_data -> dest_sa_type;
		if (Ns_qsi_ccbs_rq_A_sa_type != 255) {	/* subaddrA is present */

			Ns_qsi_ccbs_rq_A_sa_odd_c = p_arg_data -> dest_sa_odd_c;
			Ns_qsi_ccbs_rq_A_sa_sz = size = p_arg_data -> dest_sub_add.size;
				/* subaddrA string : after service string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)(p_arg_data -> dest_sub_add.p_string), size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		if (Ns_qsi_ccbs_rq_A_sa_type != NS_SS_PARTY_SA_USER_SPECIF) {	/* no 'oddCountIndicator' in subaddrA -> the one stored is in fact the one for subaddrB */

			p_arg_data -> orig_sa_odd_c = p_arg_data -> dest_sa_odd_c;
		}

		Ns_qsi_ccbs_rq_B_sa_type = p_arg_data -> orig_sa_type;
		if (Ns_qsi_ccbs_rq_B_sa_type != 255) {	/* subaddrA is present */

			Ns_qsi_ccbs_rq_B_sa_odd_c = p_arg_data -> orig_sa_odd_c;
			Ns_qsi_ccbs_rq_B_sa_sz = size = p_arg_data -> orig_sub_add.size;
				/* subaddrA string : after service string */
			Memcpy_far ((char FAR *)p_next, (char FAR *)(p_arg_data -> orig_sub_add.p_string), size);
			p_next += size;				/* update pointer to current string inside SSDU */
		}

		Ns_qsi_ccbs_rq_can_ret_srv = p_arg_data -> retention;
		Ns_qsi_ccbs_rq_ret_sig = p_arg_data -> pres_allow;
			/* extension string : after subaddrB string */
		Ns_qsi_ccbs_rq_ext_sz = size = p_arg_data -> extension.size;
		Memcpy_far ((char FAR *)p_next, (char FAR *)(p_arg_data -> extension.p_string), size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif	/* end of "NS_SS_CCBS = ON"} */

/*==========================================================================*/

		/* Call Intrusion SS
		 * ----------------- */

#if NS_SS_CALL_INTRUSION == ON	/* { */

	/*	CallIntrusionRequest operation ARGUMENT = CallIntrusionRequest operation RESULT =
		CallIntrusionGetCIPL operation RESULT : same data type as DoNotDisturbOverride operation ARGUMENT */

#define NS_QSI_CI_REQUEST_ARG_P			NS_QSI_OVERRIDE_DNDO_ARG_P
#define NS_QSI_CI_REQUEST_RES_P			NS_QSI_OVERRIDE_DNDO_ARG_P
#define NS_QSI_CI_GET_CIPL_RES_P		NS_QSI_OVERRIDE_DNDO_ARG_P

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* operation internal data : argument + result */

	/* CallIntrusionrequest operation : ARGUMENT and RESULT */

struct ns_op_qsi_dnd_override_arg	ns_op_qsi_ci_request_arg;
struct ns_op_qsi_dnd_override_arg	ns_op_qsi_ci_request_res;

	/* CallIntrusionGetCIPL operation : ARGUMENT */

struct ns_asn1_string	ns_op_qsi_ci_get_cipl_arg;

	/* CallIntrusionGetCIPL operation : RESULT */

struct ns_op_qsi_dnd_override_arg	ns_op_qsi_ci_get_cipl_res;

	/* CallIntrusionForcedRelease operation : ARGUMENT and RESULT */

struct ns_asn1_string	ns_op_qsi_ci_forced_rel_arg;
struct ns_asn1_string	ns_op_qsi_ci_forced_rel_res;

	/* CallIntrusionIsolate operation : ARGUMENT and RESULT */

struct ns_asn1_string	ns_op_qsi_ci_isolate_arg;
struct ns_asn1_string	ns_op_qsi_ci_isolate_res;

	/* CallIntrusionWOBRequest operation : ARGUMENT and RESULT */

struct ns_asn1_string	ns_op_qsi_ci_wob_rq_arg;
struct ns_asn1_string	ns_op_qsi_ci_wob_rq_res;

	/* CallIntrusionCompleted operation : ARGUMENT */

struct ns_asn1_string	ns_op_qsi_ci_completed_arg;

		/*-=-=-=-=-=-=-=--=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* functions used to process operation content in SSDU */

		/* callIntrusionRequest and callIntrusionGetCIPL operations */

uchar ns_ssdu_op_qsi_ci_rq_get_cipl (p_start, offset)
	uchar FAR								*p_start;		/* pointer to start of component */
	ushort									offset;			/* offset of data in received SSDU */
{
	uchar FAR								*p_next;		/* pointer to next data location for "p_ssdu_val" */
	uchar									size;			/* size of current string */
	struct ns_op_qsi_dnd_override_arg FAR	*p_i_data;		/* pointer to internal data location */

	if (I_ss_fac_op_err_id == NS_OP_QSI_CI_RQ) {	/* callIntrusionRequest */

		if (I_ss_fac_comp_tag == FAC_INVOKE) {

			p_i_data = &ns_op_qsi_ci_request_arg;

		} else {

			p_i_data = &ns_op_qsi_ci_request_res;
		}

	} else {	/* callIntrusionGetCIPL */

		p_i_data = &ns_op_qsi_ci_get_cipl_res;
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */

		if ((I_ss_fac_op_err_id != NS_OP_QSI_CI_RQ) &&
			(I_ss_fac_comp_tag == FAC_INVOKE)) {	/* ARGUMENT of callIntrusionGetCIPL operation */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_ci_get_cipl_arg));
		}

		p_next = &(Ns_qsi_ci_rq_get_first_str);
		p_i_data -> capability_level = Ns_qsi_ci_rq_get_level_status;
		p_i_data -> extension.size = size = Ns_qsi_ci_rq_get_ext_sz;
		p_i_data -> extension.p_string = p_ind_buffer;
			/* extension string : at the end of the structure -> copy it into indirect buffer */
		Memcpy_far ((char FAR *)p_ind_buffer, (char FAR *)p_next, size);
		p_ind_buffer += size;		/* update pointer to indirect buffer */

	} else {	/* to CALL CONTROL */

		if ((I_ss_fac_op_err_id != NS_OP_QSI_CI_RQ) &&
			(I_ss_fac_comp_tag == FAC_INVOKE)) {	/* ARGUMENT of callIntrusionGetCIPL operation */

			return (ns_ssdu_op_qsi_tsp_extension (&ns_op_qsi_ci_get_cipl_arg));
		}

		p_next = &(Ns_qsi_ci_rq_get_first_str);
		Ns_qsi_ci_rq_get_level_status = p_i_data -> capability_level;
		Ns_qsi_ci_rq_get_ext_sz = size = p_i_data -> extension.size;
			/* extension string : at the end of the structure */
		Memcpy_far ((char FAR *)p_next, (char FAR *)p_i_data -> extension.p_string, size);
		p_next += size;				/* update pointer to current string inside SSDU */
		p_next = (uchar FAR *)Round ((long)p_next);		/* Structure alignment inside SSDU */
		p_ssdu_val = p_next;	/* update current SSDU value pointer */
	}

	return (OK);
}

#endif	/* end of "NS_SS_CALL_INTRUSION = ON"} */

	/*	CcPathReserve, CcRingout, CcSuspend, CcResume, CallIntrusionIsolate, CallIntrusionForcedRelease,
		CallIntrusionWOBRequest and CallIntrusionCompleted operations */

#if (NS_SS_CCBS == ON) || (NS_SS_CALL_INTRUSION == ON)	/* { */

uchar ns_ssdu_op_qsi_ccbs_ci_op (p_start, offset)
	uchar FAR					*p_start;		/* pointer to start of component */
	ushort						offset;			/* offset of data in received SSDU */
{
	uchar FAR					*p_next;		/* pointer to next data location for "p_ssdu_val" */
	struct ns_asn1_string FAR	*p_i_data;		/* pointer to internal data location */

	if (I_ss_fac_comp_tag == FAC_INVOKE) {	/* Invoke component -> process ARGUMENT clause */

		switch (I_ss_fac_op_err_id) {	/* set internal data pointer according to operation ID */

#			if NS_SS_CCBS == ON
			case NS_OP_QSI_CC_PATH_RESERVE :	/* CcPathReserve operation */
				p_i_data = &ns_op_qsi_cc_path_reserve_arg;
				break;

			case NS_OP_QSI_CC_RINGOUT :	/* CcRingout operation */
				p_i_data = &ns_op_qsi_cc_ringout;
				break;

			case NS_OP_QSI_CC_SUSPEND :	/* CcSuspend operation */
				p_i_data = &ns_op_qsi_cc_suspend;
				break;

			case NS_OP_QSI_CC_RESUME :	/* CcResume operation */
				p_i_data = &ns_op_qsi_cc_resume;
				break;
#			endif

#			if NS_SS_CALL_INTRUSION == ON
			case NS_OP_QSI_CI_ISOLATE :	/* callIntrusionIsolate */
				p_i_data = &ns_op_qsi_ci_isolate_arg;
				break;

			case NS_OP_QSI_CI_FORCED_REL :	/* callIntrusionForcedRelease */
				p_i_data = &ns_op_qsi_ci_forced_rel_arg;
				break;

			case NS_OP_QSI_CI_WOB_RQ :	/* callIntrusionWOBRequest */
				p_i_data = &ns_op_qsi_ci_wob_rq_arg;
				break;

			case NS_OP_QSI_CI_COMPLETED :	/* callIntrusionCompleted */
				p_i_data = &ns_op_qsi_ci_completed_arg;
				break;
#			endif
		}

	} else {	/* ReturnResult component -> process RESULT clause */

		switch (I_ss_fac_op_err_id) {	/* set internal data pointer according to operation ID */

#			if NS_SS_CCBS == ON
			case NS_OP_QSI_CC_PATH_RESERVE :	/* CcPathReserve operation */
				p_i_data = &ns_op_qsi_cc_path_reserve_res;
				break;
#			endif

#			if NS_SS_CALL_INTRUSION == ON
			case NS_OP_QSI_CI_ISOLATE :	/* callIntrusionIsolate */
				p_i_data = &ns_op_qsi_ci_isolate_res;
				break;

			case NS_OP_QSI_CI_FORCED_REL :	/* callIntrusionForcedRelease */
				p_i_data = &ns_op_qsi_ci_forced_rel_res;
				break;

			case NS_OP_QSI_CI_WOB_RQ :	/* callIntrusionWOBRequest */
				p_i_data = &ns_op_qsi_ci_wob_rq_res;
				break;
#			endif

			default :	/* RESULT is empty for other operations */

				if (offset != OFFSET_NIL) {

					return (NOK);	/* there is data in operation but there should not be */
				}

				return (STOP);	/* no data */
		}
	}

	if (direction == FROM_CALL_CONTROL) {

		if (offset == OFFSET_NIL) {

			return (NOK);	/* there is no data in operation but there should be */
		}

		p_next = p_start + offset;						/* get operation content location */

		if ((p_next < p_ssdu_val) || (p_next > p_ssdu_end)) {

			return (NOK);	/* component data is after end of SSDU or before start of component ! */
		}

		p_ssdu_val = p_next;		/* update SSDU pointer to analyse operation content */
	}

	return (ns_ssdu_op_qsi_tsp_extension (p_i_data));
}

#endif	/* end of "NS_SS_CCBS = ON or NS_SS_CALL_INTRUSION = ON"} */

/*==========================================================================

			- Q-SIG specific Table describing the OBJECT IDENTIFIER tree :
		it contains all the nodes in the tree, all the "son" nodes of a given
		node are contiguous in the table. For example, if a node A has 3 son
		nodes S1, S2 and S3, an entry in the table describing A shall be
			{A_index, A_UPPER_index, label, 3, S1_index} and there shall be
			at place in table indicated by S_index, 3 consecutive entries :
			{S1_index, A_index, label1, .., ..}
			{S2_index, A_index, label2, .., ..}
			{S3_index, A_index, label3, .., ..}
*/

	/*	following nodes are described :

			ptn ::= {iso(1) identified-organization(3) icd-ecma(12) private-isdn(9)}

			pathRetain ::= {ptn path-retain(41)}
			serviceAvailable ::= {ptn service-available(42)}
			temporaryUnavailable ::= {ptn 1000}
			notAuthorized ::= {ptn 1007}
			notBusy ::= {ptn 1009}
			unspecified ::= {ptn 1008}

			callingName ::= {ptn calling-name(0)}
			calledName ::= {ptn called-name(1)}
			connectedName ::= {ptn connected-name(2)}
			busyName ::= {ptn busy-name(3)}

			activateDiversionQ ::= {ptn 15}
			deactivateDiversionQ ::= {ptn 16}
			interrogateDiversionQ ::= {ptn 17}
			checkRestriction ::= {ptn 18}
			callRerouting ::= {ptn 19}
			divertingLegInformation1 ::= {ptn 20}
			divertingLegInformation2 ::= {ptn 21}
			divertingLegInformation3 ::= {ptn 22}
			cfnrDivertedLegFailed ::= {ptn 23}

			callTransferIdentify ::= {ptn ct-identify(7)}
			callTransferAbandon ::= {ptn ct-abandon(8)}
			callTransferInitiate ::= {ptn ct-initiate(9)}
			callTransferSetup ::= {ptn ct-setup(10)}
			callTransferActive ::= {ptn ct-active(11)}
			callTransferComplete ::= {ptn ct-complete(12)}
			callTransferUpdate ::= {ptn ct-update(13)}
			subaddressTransfer ::= {ptn subaddress-transfer(14)}
			invalidReroutingNumber ::= {ptn 1004}
			unrecognizedCallIdentity ::= {ptn 1005}
			establishmentFailure ::= {ptn 1006}

			pathReplacePropose ::= {ptn pr-propose(4)}
			pathReplaceSetup ::= {ptn pr-setup(5)}
			pathReplaceRetain ::= {ptn pr-retain(6)}
			collision ::= {ptn 1001}
			criteriaPermanentlyUnachievable ::= {ptn 1002}
			criteriaTemporarilyUnachievable ::= {ptn 1003}

			callOfferRequest ::= {ptn co-request(34)}

			doNotDistubActivateQ ::= {ptn dnd-activate-q(35)}
			doNotDistubDeactivateQ ::= {ptn dnd-deactivate-q(36)}
			doNotDistubInterrogateQ ::= {ptn dnd-interrogate-q(37)}
			doNotDistubOverrideQ ::= {ptn dndo-q(38)}
			doNotDistubOvrExecuteQ ::= {ptn dndo-execute-q(39)}

			ccbsRequest ::= {ptn ccbs-request(40)}
			ccnrRequest ::= {ptn ccnr-request(27)}
			ccCancel ::= {ptn cc-cancel(28)}
			ccExecPossible ::= {ptn cc-exec-possible(29)}
			ccPathReserve ::= {ptn cc-path-reserve(30)}
			ccRingout ::= {ptn cc-ringout(31)}
			ccSuspend ::= {ptn cc-suspend(32)}
			ccResume ::= {ptn cc-resume(33)}
			shortTermRejection ::= {ptn 1010}
			longTermRejection ::= {ptn 1011}
			remoteUserBusyAgain ::= {ptn 1012}
			failureToMatch ::= {ptn 1013}
			failedDueToInterworking ::= {ptn 1014}

			callIntrusionRequest ::= {ptn ci-request(43)}
			callIntrusionGetCIPL ::= {ptn ci-getCIPL(44)}
			callIntrusionIsolate ::= {ptn ci-isolate(45)}
			callIntrusionForcedRelease ::= {ptn ci-forcedRelease(46)}
			callIntrusionWOBRequest ::= {ptn ci-WOB(47)}
			callIntrusionCompleted ::= {ptn ci-completed(48)}

			cfbOverride ::= {ptn cfb-override(49)}
	*/

#define NS_OBJ_ID_QSI_ISO					1
#define NS_OBJ_ID_QSI_IDENTIFIED_ORG		2
#define NS_OBJ_ID_QSI_ICD_ECMA				3
#define NS_OBJ_ID_QSI_PRIVATE_ISDN			4

#define NS_OP_VAL_QSI_PATH_RETAIN			(NS_OBJ_ID_QSI_PRIVATE_ISDN + 1)
#define NS_OP_VAL_QSI_SERVICE_AVAIL			(NS_OBJ_ID_QSI_PRIVATE_ISDN + 2)
#define NS_ERR_VAL_QSI_TMP_UNAV				(NS_OBJ_ID_QSI_PRIVATE_ISDN + 3)
#define NS_ERR_VAL_QSI_NOT_AUTHORIZ			(NS_OBJ_ID_QSI_PRIVATE_ISDN + 4)
#define NS_ERR_VAL_QSI_NOT_BUSY				(NS_OBJ_ID_QSI_PRIVATE_ISDN + 5)
#define NS_ERR_VAL_QSI_UNSPECIFIED			(NS_OBJ_ID_QSI_PRIVATE_ISDN + 6)

#if NS_SS_NAME_IDENT == ON
#define NS_OP_VAL_QSI_NAME_CALLING			(NS_ERR_VAL_QSI_UNSPECIFIED + 1)
#define NS_OP_VAL_QSI_NAME_CALLED			(NS_ERR_VAL_QSI_UNSPECIFIED + 2)
#define NS_OP_VAL_QSI_NAME_CONNECTED		(NS_ERR_VAL_QSI_UNSPECIFIED + 3)
#define NS_OP_VAL_QSI_NAME_BUSY				(NS_ERR_VAL_QSI_UNSPECIFIED + 4)
#define NS_OBJ_NB_IN_NAME_ID_SS				4

#else
#define NS_OBJ_NB_IN_NAME_ID_SS				0
#endif

#if NS_SS_DIVERSION == ON
#define NS_OP_VAL_QSI_DIV_ACTIVATE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 1)
#define NS_OP_VAL_QSI_DIV_DEACTIVATE		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 2)
#define NS_OP_VAL_QSI_DIV_INTERROG			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 3)
#define NS_OP_VAL_QSI_DIV_CHECK_REST		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 4)
#define NS_OP_VAL_QSI_DIV_REROUTING			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 5)
#define NS_OP_VAL_QSI_DIV_LEG_INFO1			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 6)
#define NS_OP_VAL_QSI_DIV_LEG_INFO2			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 7)
#define NS_OP_VAL_QSI_DIV_LEG_INFO3			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 8)
#define NS_OP_VAL_QSI_DIV_CFNR_FAIL			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + 9)
#define NS_OBJ_NB_IN_DIVERSION_SS			9

#else
#define NS_OBJ_NB_IN_DIVERSION_SS			0
#endif

#if NS_SS_CALL_TRANSFER == ON
#define NS_OP_VAL_QSI_TRF_IDENTIFY			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 1)
#define NS_OP_VAL_QSI_TRF_ABANDON			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 2)
#define NS_OP_VAL_QSI_TRF_INITIATE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 3)
#define NS_OP_VAL_QSI_TRF_SETUP				(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 4)
#define NS_OP_VAL_QSI_TRF_ACTIVE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 5)
#define NS_OP_VAL_QSI_TRF_COMPLETE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 6)
#define NS_OP_VAL_QSI_TRF_UPDATE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 7)
#define NS_OP_VAL_QSI_TRF_SUBADD			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 8)
#define NS_ERR_VAL_QSI_TRF_INV_NB			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 9)
#define NS_ERR_VAL_QSI_TRF_UNREC_ID			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 10)
#define NS_ERR_VAL_QSI_TRF_EST_FAIL			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + 11)
#define NS_OBJ_NB_IN_TRANSFER_SS			11

#else
#define NS_OBJ_NB_IN_TRANSFER_SS			0
#endif

#if NS_SS_PATH_REPLACEMENT == ON
#define NS_OP_VAL_QSI_PTHR_PROPOSE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + 1)
#define NS_OP_VAL_QSI_PTHR_SETUP			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + 2)
#define NS_OP_VAL_QSI_PTHR_RETAIN			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + 3)
#define NS_ERR_VAL_QSI_PTHR_COLLISION		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + 4)
#define NS_ERR_VAL_QSI_PTHR_P_UNACH			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + 5)
#define NS_ERR_VAL_QSI_PTHR_T_UNACH			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + 6)
#define NS_OBJ_NB_IN_PATH_REPLACE			6

#else
#define NS_OBJ_NB_IN_PATH_REPLACE			0
#endif

#if NS_SS_CALL_OFFER == ON
#define NS_OP_VAL_QSI_CO_REQUEST			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + 1)
#define NS_OBJ_NB_IN_CALL_OFFER_SS			1

#else
#define NS_OBJ_NB_IN_CALL_OFFER_SS			0
#endif

#if NS_SS_DO_NOT_DISTURB == ON
#define NS_OP_VAL_QSI_DND_ACTIVATE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + 1)
#define NS_OP_VAL_QSI_DND_DEACTIVATE		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + 2)
#define NS_OP_VAL_QSI_DND_INTEROG			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + 3)
#define NS_OP_VAL_QSI_DND_OVERRIDE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + 4)
#define NS_OP_VAL_QSI_DND_OVER_EXEC			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + 5)
#define NS_OBJ_NB_IN_DND_SS					5

#else
#define NS_OBJ_NB_IN_DND_SS					0
#endif

#if NS_SS_CCBS == ON
#define NS_OP_VAL_QSI_CCBS_REQUEST			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 1)
#define NS_OP_VAL_QSI_CCNR_REQUEST			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 2)
#define NS_OP_VAL_QSI_CC_CANCEL				(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 3)
#define NS_OP_VAL_QSI_CC_EXEC_POSSIB		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 4)
#define NS_OP_VAL_QSI_CC_PATH_RES			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 5)
#define NS_OP_VAL_QSI_CC_RINGOUT			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 6)
#define NS_OP_VAL_QSI_CC_SUSPEND			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 7)
#define NS_OP_VAL_QSI_CC_RESUME				(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 8)
#define NS_ERR_VAL_QSI_CC_SHORT_REJ			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 9)
#define NS_ERR_VAL_QSI_CC_LONG_REJ			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 10)
#define NS_ERR_VAL_QSI_CC_REMOTE_BUSY		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 11)
#define NS_ERR_VAL_QSI_CC_FAIL_MATCH		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 12)
#define NS_ERR_VAL_QSI_CC_FAIL_INTERW		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + 13)
#define NS_OBJ_NB_IN_CCBS_SS				13

#else
#define NS_OBJ_NB_IN_CCBS_SS				0
#endif

#if NS_SS_CALL_INTRUSION == ON
#define NS_OP_VAL_QSI_CI_REQUEST			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + 1)
#define NS_OP_VAL_QSI_CI_GET_CIPL			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + 2)
#define NS_OP_VAL_QSI_CI_ISOLATE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + 3)
#define NS_OP_VAL_QSI_CI_FORCED_REL			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + 4)
#define NS_OP_VAL_QSI_CI_WOB_REQUEST		(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + 5)
#define NS_OP_VAL_QSI_CI_COMPLETED			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + 6)
#define NS_OBJ_NB_IN_CALL_INTRUS_SS			6

#else
#define NS_OBJ_NB_IN_CALL_INTRUS_SS			0
#endif

#if (NS_SS_INTERACTIONS == ON) && (NS_SS_DIVERSION == ON) && ((NS_SS_CALL_OFFER == ON) || (NS_SS_CALL_INTRUSION == ON))
#define NS_OP_VAL_QSI_CFB_OVERRIDE			(NS_ERR_VAL_QSI_UNSPECIFIED + NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + NS_OBJ_NB_IN_CALL_INTRUS_SS + 1)
#define NS_OBJ_NB_IN_SS_INTERACT			1

#else
#define NS_OBJ_NB_IN_SS_INTERACT			0
#endif

#define NS_OBJ_SON_NB_QSI_ISO				1
#define NS_OBJ_SON_NB_QSI_IDENT_ORG			1
#define NS_OBJ_SON_NB_QSI_ECMA				3
#define NS_OBJ_SON_NB_QSI_PTN				(NS_OBJ_NB_IN_NAME_ID_SS + NS_OBJ_NB_IN_DIVERSION_SS + NS_OBJ_NB_IN_TRANSFER_SS + NS_OBJ_NB_IN_PATH_REPLACE + NS_OBJ_NB_IN_CALL_OFFER_SS + NS_OBJ_NB_IN_DND_SS + NS_OBJ_NB_IN_CCBS_SS + NS_OBJ_NB_IN_CALL_INTRUS_SS + NS_OBJ_NB_IN_SS_INTERACT + 6)

struct asn1_obj_id_node CONST_ARRAY NS_QSI_OBJ_ID_TREE[] = {
/* 	current node index 				upper node index			label	first son node index			number of son nodes */

	{ASN1_OBJ_ID_ROOT,				ASN1_OBJ_ID_NIL,				0, 	NS_OBJ_ID_QSI_ISO,				1},
	{NS_OBJ_ID_QSI_ISO,				ASN1_OBJ_ID_ROOT,				1, 	NS_OBJ_ID_QSI_IDENTIFIED_ORG,	NS_OBJ_SON_NB_QSI_ISO},
	{NS_OBJ_ID_QSI_IDENTIFIED_ORG,	NS_OBJ_ID_QSI_ISO,				3, 	NS_OBJ_ID_QSI_ICD_ECMA, 		NS_OBJ_SON_NB_QSI_IDENT_ORG},
	{NS_OBJ_ID_QSI_ICD_ECMA,		NS_OBJ_ID_QSI_IDENTIFIED_ORG,	12, NS_OBJ_ID_QSI_PRIVATE_ISDN, 	NS_OBJ_SON_NB_QSI_ECMA},
	{NS_OBJ_ID_QSI_PRIVATE_ISDN,	NS_OBJ_ID_QSI_ICD_ECMA,			9,	NS_OP_VAL_QSI_PATH_RETAIN, 		NS_OBJ_SON_NB_QSI_PTN},

	{NS_OP_VAL_QSI_PATH_RETAIN,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	41,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_SERVICE_AVAIL,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	42,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_TMP_UNAV,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1000,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_NOT_AUTHORIZ,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1007,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_NOT_BUSY,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1009,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_UNSPECIFIED,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1008,	0,							ASN1_OBJ_ID_NO_SON_NODE},

#if NS_SS_NAME_IDENT == ON
	{NS_OP_VAL_QSI_NAME_CALLING,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	0,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_NAME_CALLED,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_NAME_CONNECTED,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	2,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_NAME_BUSY,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	3,		0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_DIVERSION == ON
	{NS_OP_VAL_QSI_DIV_ACTIVATE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	15,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_DEACTIVATE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	16,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_INTERROG,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	17,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_CHECK_REST,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	18,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_REROUTING,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	19,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_LEG_INFO1,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	20,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_LEG_INFO2,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	21,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_LEG_INFO3,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	22,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DIV_CFNR_FAIL,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	23,		0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_CALL_TRANSFER == ON
	{NS_OP_VAL_QSI_TRF_IDENTIFY,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	7,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_TRF_ABANDON,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	8,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_TRF_INITIATE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	9,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_TRF_SETUP,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	10,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_TRF_ACTIVE,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	11,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_TRF_COMPLETE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	12,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_TRF_UPDATE,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	13,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_TRF_SUBADD,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	14,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_TRF_INV_NB,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1004,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_TRF_UNREC_ID,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1005,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_TRF_EST_FAIL,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1006,	0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_PATH_REPLACEMENT == ON
	{NS_OP_VAL_QSI_PTHR_PROPOSE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	4,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_PTHR_SETUP,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	5,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_PTHR_RETAIN,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	6,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_PTHR_COLLISION,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1001,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_PTHR_P_UNACH,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1002,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_PTHR_T_UNACH,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1003,	0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_CALL_OFFER == ON
	{NS_OP_VAL_QSI_CO_REQUEST,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	34,		0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_DO_NOT_DISTURB == ON
	{NS_OP_VAL_QSI_DND_ACTIVATE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	35,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DND_DEACTIVATE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	36,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DND_INTEROG,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	37,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DND_OVERRIDE,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	38,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_DND_OVER_EXEC,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	39,		0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_CCBS == ON
	{NS_OP_VAL_QSI_CCBS_REQUEST,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	40,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CCNR_REQUEST,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	27,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CC_CANCEL,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	28,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CC_EXEC_POSSIB,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	29,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CC_PATH_RES,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	30,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CC_RINGOUT,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	31,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CC_SUSPEND,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	32,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CC_RESUME,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	33,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_CC_SHORT_REJ,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1010,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_CC_LONG_REJ,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1011,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_CC_REMOTE_BUSY,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1012,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_CC_FAIL_MATCH,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1013,	0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_ERR_VAL_QSI_CC_FAIL_INTERW,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	1014,	0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_CALL_INTRUSION == ON
	{NS_OP_VAL_QSI_CI_REQUEST,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	43,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CI_GET_CIPL,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	44,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CI_ISOLATE,		NS_OBJ_ID_QSI_PRIVATE_ISDN, 	45,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CI_FORCED_REL,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	46,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CI_WOB_REQUEST,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	47,		0,							ASN1_OBJ_ID_NO_SON_NODE},
	{NS_OP_VAL_QSI_CI_COMPLETED,	NS_OBJ_ID_QSI_PRIVATE_ISDN, 	48,		0,							ASN1_OBJ_ID_NO_SON_NODE},
#endif

#if NS_SS_INTERACTIONS == ON
#	if (NS_SS_DIVERSION == ON) && ((NS_SS_CALL_OFFER == ON) || (NS_SS_CALL_INTRUSION == ON))
		{NS_OP_VAL_QSI_CFB_OVERRIDE,NS_OBJ_ID_QSI_PRIVATE_ISDN, 	49,		0,							ASN1_OBJ_ID_NO_SON_NODE},
#	endif
#endif
};

#define NS_QSI_OBJ_ID_NB		Ns_tab_item_nb (NS_QSI_OBJ_ID_TREE)

/*==========================================================================

				INCLUDE ns_sstab.qsi FILE containing :
			- Descriptions of ASN1 Types (with ASN1 Meta-programs)
			- Tables of descriptions of list of storage contexts
			- Q-SIG specific table for operations
*/

	/* define Macros used in ns_sstab.qsi */

#define Ns_qsi_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_qsi_end_table_or_function		};

#define Ns_ss_store_desc_entry(p_pc, f_nb, type, p_str, i_inter, rep, next, opt)		\
	{Pic_address (p_pc), f_nb, type, Pic_address (p_str), i_inter, rep, next, opt},

#define Ns_ss_op_tab_entry(if_id, tag, val, p_arg, p_ctx_arg, p_res, p_ctx_res, ssdu_fct)	\
	{if_id, tag, val, Pic_address (p_arg), Pic_address (p_ctx_arg), Pic_address (p_res), Pic_address (p_ctx_res), ssdu_fct},

#if OM_CODE_TYPE == OM_PIC	/* PIC used : redefine some ASN1 Macros used for ASN1 Meta-programs */

#	undef ASN1_TYPE_START
#	undef ASN1_TYPE_FIELD
#	undef ASN1_TYPE_OPTIONAL_FIELD
#	undef ASN1_TYPE_LAST_FIELD
#	undef ASN1_TYPE_OPT_LAST_FIELD

#	define ASN1_TYPE_START(type)						struct type type = {
#	define ASN1_TYPE_FIELD(name)						{P_NIL, P_NIL},
#	define ASN1_TYPE_OPTIONAL_FIELD(name, ind_list)		{P_NIL, P_NIL},
#	define ASN1_TYPE_LAST_FIELD(name)					{P_NIL, P_NIL}}
#	define ASN1_TYPE_OPT_LAST_FIELD(name, ind_list)		{P_NIL, P_NIL}}

#endif

#include "qsi.ns_sstab"

/*==========================================================================

			- Q-SIG specific table for errors -
*/

CONST_ARRAY struct ns_ss_error		NS_QSI_ERROR_TAB[] = {
/*	interface identifier			tag					value				p_parameter_prog p_par_ctx_list ssdu_fct */

	{SS_ERR_NOT_SUBSCRIBED,			FAC_INTEGER_TAG,	SS_ERR_NOT_SUBSCRIBED},
	{SS_ERR_NOT_AVAILABLE,			FAC_INTEGER_TAG,	SS_ERR_NOT_AVAILABLE},
	{SS_ERR_NOT_IMPLEMENTED,		FAC_INTEGER_TAG,	SS_ERR_NOT_IMPLEMENTED},
	{SS_ERR_INVALID_SERVED_NB,		FAC_INTEGER_TAG,	SS_ERR_INVALID_SERVED_NB},
	{SS_ERR_INVALID_CALL_STATE,		FAC_INTEGER_TAG,	SS_ERR_INVALID_CALL_STATE},
	{SS_ERR_SERVICE_NOT_PROVIDED,	FAC_INTEGER_TAG,	SS_ERR_SERVICE_NOT_PROVIDED},
	{SS_ERR_NOT_INCOMING_CALL,		FAC_INTEGER_TAG,	SS_ERR_NOT_INCOMING_CALL},
	{SS_ERR_INTERAC_NOT_ALLOWED,	FAC_INTEGER_TAG,	SS_ERR_INTERAC_NOT_ALLOWED},
	{SS_ERR_RESOURCE_UNAVAILABLE,	FAC_INTEGER_TAG,	SS_ERR_RESOURCE_UNAVAILABLE},
	{SS_ERR_QSI_UNSPECIFIED,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_UNSPECIFIED},
	{SS_ERR_QSI_TMP_NOT_AVAIL,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_TMP_UNAV},
	{SS_ERR_QSI_NOT_AUTH,			FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_NOT_AUTHORIZ},
	{SS_ERR_QSI_NOT_BUSY,			FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_NOT_BUSY},

#if (NS_SS_AOC_S == ON) || (NS_SS_AOC_D == ON) || (NS_SS_AOC_E == ON)
	{SS_ERR_AOC_NO_CH_INF_AVAIL,	FAC_INTEGER_TAG,	SS_ERR_AOC_NO_CH_INF_AVAIL},
#endif

#if NS_SS_CUG == ON
	{SS_ERR_CUG_INV_OR_UNREG_INDEX,	FAC_INTEGER_TAG,	SS_ERR_CUG_INV_OR_UNREG_INDEX},
	{SS_ERR_CUG_RQ_SRV_VIOL_CONSTR,	FAC_INTEGER_TAG,	SS_ERR_CUG_RQ_SRV_VIOL_CONSTR},
	{SS_ERR_CUG_OUT_CALL_BARRED,	FAC_INTEGER_TAG,	SS_ERR_CUG_OUT_CALL_BARRED},
	{SS_ERR_CUG_INC_CALL_BARRED,	FAC_INTEGER_TAG,	SS_ERR_CUG_INC_CALL_BARRED},
	{SS_ERR_CUG_USER_NOT_MEMBER,	FAC_INTEGER_TAG,	SS_ERR_CUG_USER_NOT_MEMBER},
	{SS_ERR_CUG_FAC_SUB_CL_INCONS,	FAC_INTEGER_TAG,	SS_ERR_CUG_FAC_SUB_CL_INCONS},
#endif

#if NS_SS_DIVERSION == ON
	{SS_ERR_INV_DIVERTED_TO_NB,		FAC_INTEGER_TAG,	SS_ERR_INV_DIVERTED_TO_NB},
	{SS_ERR_DIV_SPECIAL_SERV_NB,	FAC_INTEGER_TAG,	SS_ERR_DIV_SPECIAL_SERV_NB},
	{SS_ERR_DIV_TO_SERVED_USER_NB,	FAC_INTEGER_TAG,	SS_ERR_DIV_TO_SERVED_USER_NB},
	{SS_ERR_DIV_INC_CALL_ACC,		FAC_INTEGER_TAG,	SS_ERR_DIV_INC_CALL_ACC},
	{SS_ERR_DIV_NB_EXCEEDED,		FAC_INTEGER_TAG,	SS_ERR_DIV_NB_EXCEEDED},
	{SS_ERR_DIV_NOT_ACTIVATED,		FAC_INTEGER_TAG,	SS_ERR_DIV_NOT_ACTIVATED},
	{SS_ERR_DIV_RQ_ALREADY_ACC,		FAC_INTEGER_TAG,	SS_ERR_DIV_RQ_ALREADY_ACC},
#endif

#if NS_SS_CONFERENCE == ON
	{SS_ERR_CONF_ILL_CONF_ID,		FAC_INTEGER_TAG,	SS_ERR_CONF_ILL_CONF_ID},
	{SS_ERR_CONF_ILL_PARTY_ID,		FAC_INTEGER_TAG,	SS_ERR_CONF_ILL_PARTY_ID},
	{SS_ERR_CONF_PARTY_NB_EXCEED,	FAC_INTEGER_TAG,	SS_ERR_CONF_PARTY_NB_EXCEED},
	{SS_ERR_CONF_NOT_ACTIVE,		FAC_INTEGER_TAG,	SS_ERR_CONF_NOT_ACTIVE},
	{SS_ERR_CONF_NOT_ALLOWED,		FAC_INTEGER_TAG,	SS_ERR_CONF_NOT_ALLOWED},
#endif

#if NS_SS_USER_USER_EXP == ON
	{SS_ERR_UUS_NET_REJECT,			FAC_INTEGER_TAG,	SS_ERR_UUS_NET_REJECT},
	{SS_ERR_UUS_USER_REJECT,		FAC_INTEGER_TAG,	SS_ERR_UUS_USER_REJECT},
#endif

#if NS_SS_CALL_TRANSFER == ON
	{SS_ERR_QSI_TRF_INV_NB,			FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_TRF_INV_NB},
	{SS_ERR_QSI_TRF_UNREC_ID,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_TRF_UNREC_ID},
	{SS_ERR_QSI_TRF_EST_FAIL,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_TRF_EST_FAIL},
#endif

#if NS_SS_PATH_REPLACEMENT == ON
	{SS_ERR_QSI_PTHR_COLLISION,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_PTHR_COLLISION},
	{SS_ERR_QSI_PTHR_CR_P_UNACH,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_PTHR_P_UNACH},
	{SS_ERR_QSI_PTHR_CR_T_UNACH,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_PTHR_T_UNACH},
#endif

#if NS_SS_CCBS == ON
	{SS_ERR_QSI_CC_SHORT_REJECT,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_CC_SHORT_REJ},
	{SS_ERR_QSI_CC_LONG_REJECT,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_CC_LONG_REJ},
	{SS_ERR_QSI_CC_REMOTE_BUSY,		FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_CC_REMOTE_BUSY},
	{SS_ERR_QSI_CC_FAIL_TO_MATCH,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_CC_FAIL_MATCH},
	{SS_ERR_QSI_CC_FAILED_INTERW,	FAC_OBJECT_ID_TAG,	NS_ERR_VAL_QSI_CC_FAIL_INTERW},
#endif
};

/* EOF */
