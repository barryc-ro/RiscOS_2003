
/*--------------------------------------------------------------------------*
 *						M O D U L E		H E A D E R
 *
 * filename - net_ie.ni2
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the meta description of all the information
 * elements and the integrity constraints associated to.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

/*
*
*Table structures :
*----------------
*
*        tabl_item   TABL_ITEM                                    uchar
*        ==========================                             ============
*        | tabl_id | size | p_val |---------------------------->|   val    |
*        --------------------------  tabl_yy      ============  ------------
*        |         |      |       |-------------->|   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |   val    |  |   val    |
*        --------------------------               ------------  ------------
*        |         |      |       |               |          |  |          |
*        --------------------------
*        |         |      |       |
*        --------------------------
*        |         |      |       |
*
*
*    tabx_item   TABX_ITEM                   tabx_list                uchar
*    =================================     =================        =========
*    | tabl_id | size | list pointer |---->| tabl_id | size|------->| x_val |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------     -----------------        ---------
*    |         |      |              |     |         |     |        |  val  |
*    ---------------------------------
*    |         |      |              |
*
*/

/*-------------------------------------------------------------------------*/

	/*
		Initialization constants of ie internal structure
		used by SPDU received processing.
	*/

		/*  Bearer capability (BC) */

CONST	struct  i_bc	df_spdu_ni2_i_bc = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	PROTOCOL_ID_3_X25_PL,
};

		/* Call state (CALL_STATE) */

CONST	struct  i_call_state	df_spdu_ni2_i_call_state = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/*  Called party number and subaddress (CALLED_NB, CALLED_SUB_ADD) */

CONST	struct  i_called_nb	 df_spdu_ni2_i_called_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

CONST	struct  i_called_sub_add	df_spdu_ni2_i_called_sub_add = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Calling party number (CALLING_NB) */

CONST	struct  i_calling_nb	df_spdu_ni2_i_calling_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* calling party subaddress (CALLING_SUB_ADD) */

CONST	struct  i_calling_sub_add	df_spdu_ni2_i_calling_sub_add = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Cause (CAUSE) */

CONST	struct  i_cause	 df_spdu_ni2_i_cause = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST	struct  i_chan_id	df_spdu_ni2_i_chan_id = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/*  Change status (CHANGE_STATUS) */

CONST	struct  i_change_status	df_spdu_ni2_i_change_status = {
	PREF_D_CHANNEL,
	CHANNEL_IN_SERVICE,
};

		/* Endpoint Identifier (ENDPOINT_ID) */

CONST	struct  i_endpoint_id df_spdu_ni2_i_endpoint_id = {
	BYTE_VAL_NIL,
	INTERPRETER_0,
	BYTE_VAL_NIL
};

		/* Feature activation (FEATURE_ACT) : only sent */

		/* Feature indication (FEATURE_IND) */

CONST	struct  i_feature_ind	df_spdu_ni2_i_feature_ind = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* High layer compatibility (HLC) */

CONST	struct  i_hlc	df_spdu_ni2_i_hlc = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Information request (INFORMATION_RQ) */

CONST	struct  i_information_rq	df_spdu_ni2_i_information_rq = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Keypad facility (KEYPAD) never received from network */

		/* Low layer compatibility (LLC) */

CONST	struct  i_llc	df_spdu_ni2_i_llc = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST   struct  i_spf_fac   df_spdu_ni2_i_spf_fac = {
	1,
	NATIONAL_NETWORK_ID_TYPE,
	CARRIER_ID_CODE,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	FAC_VAL_6_BITS,
	FAC_SERVICE,
	FAC_INWATS,
};

#endif

		/* Notification indicator (NOTIF_IND) */

CONST	struct  i_notif_ind	 df_spdu_ni2_i_notif_ind = {
	BYTE_VAL_NIL,
	0,
	P_NIL

};

		/* Progress indicator (PROGRESS_IND) */

CONST	struct  i_progress_ind  df_spdu_ni2_i_progress_ind = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Redirecting number (REDIR_NB) */

CONST	struct  i_redir_nb	df_spdu_ni2_i_redir_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* redirecting subaddress (REDIR_SUB_ADD) */

CONST	struct  i_redir_sub_add	df_spdu_ni2_i_redir_sub_add = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* redirecting subaddress (codeset 6, REDIR_SUB_ADD) */

CONST	struct  i_redir_sub_add_net_spf	df_spdu_ni2_i_redir_sub_add_net_spf = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Redirection number (REDIRECTION_NB) */

CONST	struct  i_redirection_nb	df_spdu_ni2_i_redirection_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL,
};

		/* Redirection number (codeset 6, REDIRECTION_NB) */

CONST	struct  i_redirection_nb_net_spf	df_spdu_ni2_i_redirection_nb_net_spf = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL,
};

		/* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_spdu_ni2_i_restart_ind = {
	RI_ALL_INTERFACES
};

		/* Service profile identification (SPID) never received from network */

		/*  Signal (SIGNAL) */

CONST	struct  i_signal	df_spdu_ni2_i_signal = {
	BYTE_VAL_NIL
};

		/* Transit network selection (TRANSIT_NET_SEL) never received from network */

		/* codeset 5 : Operator System Access (OS_ACCSS) never received from network */

		/* codeset 5 : Display (DISPLAY_TXT) */

CONST   struct  i_display   df_spdu_ni2_i_display = {
	DISPLAY_TYPE_NORMAL,
	0,
	A_NIL
};

		/* codeset 6 : Call appearance (CALL_APPEARANCE) */

CONST	struct  i_call_appear	df_spdu_ni2_i_call_appear = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* User to user information (UUI) */

CONST   struct  i_uui   df_spdu_ni2_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL
};

/*=========================================================================*/

	/*
		Initialization constants of the ie internal structure
		used by SSDU received processing.
	*/

		/*  Bearer capability (BC) */

CONST	struct  i_bc	df_ssdu_ni2_i_bc = {
	CODING_STD_CCITT,
	BYTE_VAL_NIL,		/* Mandatory field */
	TRF_MODE_CIRCUIT,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_1,			/* Optional field */
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	RA_56KBS,			/* Optional field */
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	PROTOCOL_ID_3_X25_PL,
};

		/* Call state (CALL_STATE) */

CONST	struct  i_call_state	df_ssdu_ni2_i_call_state = {
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,
};

		/*  Called party number and subaddress (CALLED_NB, CALLED_SUB_ADD) */

CONST	struct  i_called_nb	 df_ssdu_ni2_i_called_nb = {
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,
	0,
	A_NIL
};

CONST	struct  i_called_sub_add	df_ssdu_ni2_i_called_sub_add = {
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,		/* Mandatory field */
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Calling party number (CALLING_NB) */

CONST	struct  i_calling_nb	df_ssdu_ni2_i_calling_nb = {
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};

		/* calling party subaddress (CALLING_SUB_ADD) */

CONST	struct  i_calling_sub_add	df_ssdu_ni2_i_calling_sub_add = {
	SUB_ADD_USER,
	BYTE_VAL_NIL,		/* Mandatory field */
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Cause (CAUSE) */

CONST	struct  i_cause	 df_ssdu_ni2_i_cause = {
	CODING_STD_CCITT,
	LOCATION_USER,
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,		/* Mandatory field */
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST	struct  i_chan_id	df_ssdu_ni2_i_chan_id = {
	INT_ID_IMPLICIT,
	INT_TYPE_BRI,
	CHAN_PREF,
	NOT_D_CHAN,
	ANY_CHAN,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL,
};

		/*  Change status (CHANGE_STATUS) */

CONST	struct  i_change_status	df_ssdu_ni2_i_change_status = {
	PREF_D_CHANNEL,
	CHANNEL_IN_SERVICE,
};

		/* Feature activation (FEATURE_ACT) */

CONST	struct  i_feature_act	df_ssdu_ni2_i_feature_act = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Feature indication (FEATURE_IND) : only received by the user */

		/* High layer compatibility (HLC) */

CONST	struct  i_hlc	df_ssdu_ni2_i_hlc = {
	CODING_STD_CCITT,
	INTER_CCITT_CEPT,
	PRESENTATION_PROFIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Information request (INFORMATION_RQ) not sent by the user */

		/* Keypad facility (KEYPAD) */

CONST	struct  i_keypad	df_ssdu_ni2_i_keypad = {
	0,
	A_NIL
};

		/* Low layer compatibility (LLC) */

CONST	struct  i_llc	df_ssdu_ni2_i_llc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	OUT_BAND_NOT_POSSIBLE,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Notification indicator (NOTIF_IND) not sent by the user */

		/* Progress indicator (PROGRESS_IND) not sent by the user */

		/* Redirecting number (REDIR_NB) not sent by the user */

		/* redirecting subaddress (REDIR_SUB_ADD) */

		/* Redirection number (REDIRECTION_NB) not sent by the user */

		/* Service profile identification (SPID) */

		/* redirecting subaddress (REDIR_SUB_ADD) */

CONST	struct  i_redir_sub_add	df_ssdu_ni2_i_redir_sub_add = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* redirecting subaddress (codeset 6, REDIR_SUB_ADD) */

CONST	struct  i_redir_sub_add_net_spf	df_ssdu_ni2_i_redir_sub_add_net_spf = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

CONST	struct  i_spid	df_ssdu_ni2_i_spid = {
	0,
    0,
	A_NIL
};

#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST   struct  i_spf_fac   df_ssdu_ni2_i_spf_fac = {
	1,
	NATIONAL_NETWORK_ID_TYPE,
	CARRIER_ID_CODE,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	FAC_VAL_6_BITS,
	FAC_SERVICE,
	FAC_INWATS,
};

#endif

		/*  Signal (SIGNAL) not sent by the user */

		/* Transit network selection (TRANSIT_NET_SEL) */

CONST	struct  i_transit_net_sel	df_ssdu_ni2_i_transit_net_sel = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* codeset 5 : Operator System Access (OS_ACCSS) */

CONST	struct  i_os_accss	df_ssdu_ni2_i_os_accss = {
	SERVICE_TYPE_UNSPECIFIED,
	BYTE_VAL_NIL
};

		/* Display (DISPLAY_TXT) : never sent by the user */

		/* codeset 6 : Call appearance (CALL_APPEARANCE) */

CONST	struct  i_call_appear	df_ssdu_ni2_i_call_appear = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_ssdu_ni2_i_restart_ind = {
	RI_ALL_INTERFACES
};


		/* User to user information (UUI) */

CONST   struct  i_uui   df_ssdu_ni2_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL
};

/*=========================================================================*/

				/*-------------------------------*/
				/* TABLES : list of valid values */
				/*-------------------------------*/

					/* Assignor/Assignee (ie LLC) */

CONST	uchar NI2_ASSIGN_S[] = {
	DEFAULT_ASSIGNEE,
	ASSIGNOR_ONLY,
	};

					/* In-band/Out_band negotiation (ie LLC) */

CONST	uchar NI2_BAND_S[] = {
	TSC,
	LL0,
	};


					/* Transfert mode (ie BC/LLC) */

CONST	uchar NI2_TRF_MODE_S[] = {
	TRF_MODE_CIRCUIT,
	TRF_MODE_PACKET,
	};

					/* Information transfer rate (ie BC) according to transfer mode */

CONST	uchar NI2_BC_TRF_RATE_S[] = {
	TRF_RATE_64KBS,
	TRF_RATE_384KBS,
	TRF_RATE_1536KBS,
	TRF_RATE_MULTI_RATE,
};

				/* Layer 1 protocol identifier (ie BC) */

CONST	uchar NI2_BC_PROTOCOL_ID_1_S[] = {
	PROTOCOL_ID_1_V110,
	PROTOCOL_ID_1_G711_u,
	};

				/* Layer 2 protocol identifier (ie BC) */

CONST	uchar NI2_BC_PROTOCOL_ID_2_S[] = {
	PROTOCOL_ID_2_Q921,
	PROTOCOL_ID_2_X25_LL,
	};

					/* Cause class (ie CAUSE) */

CONST	uchar NI2_C_C_S[]={
	C_C_NORMAL_EVENT_0,
	C_C_NORMAL_EVENT,
	C_C_RESOURCE_UNAVAILABLE,		/* Network congestion */
	C_C_SERVICE_NOT_AVAILABLE,
	C_C_SERVICE_NOT_IMPLEMENTED,
	C_C_INVALID_MESSAGE,
	C_C_PROTOCOL_ERROR,
	C_C_INTERWORKING,
	};

					/* Cause class network specific (ie CAUSE) */

CONST	uchar NI2_C_C_NET_S[]={
	C_C_NORMAL_EVENT_0,
	C_C_NORMAL_EVENT,
	C_C_SERVICE_NOT_AVAILABLE,
	C_C_PROTOCOL_ERROR,
	};

			/* Normal event - class 000 for national specific coding standard */

CONST	uchar NI2_C_V_NORMAL_EVENT_0_NAT_S[] = {
	C_V_VACANT_CODE_4,
	C_V_PREFIX_0_DIALED_IN_ERROR_8,
	C_V_PREFIX_1_DIALED_IN_ERROR_9,
	C_V_PREFIX_1_NOT_DIALED_10,
	C_V_EXCESSIVE_DIGITS_CALL_PROCEEDING_11,
	};


					/* Automata call state values (ie CALL_STATE) */

CONST	uchar NI2_CALL_STATE_VAL_S[] = {
	STATE_NULL_0,
	STATE_CALL_INIT_1,
	STATE_OVERLAP_SENDING_2,
	STATE_OUTGOING_CALL_PROC_3,
	STATE_CALL_DELIVERED_4,
	STATE_CALL_PRESENT_6,
	STATE_CALL_RECEIVED_7,
	STATE_CONNECT_REQUEST_8,
	STATE_INCOMING_CALL_PROC_9,
	STATE_ACTIVE_10,
	STATE_DISCONNECT_REQUEST_11,
	STATE_DISCONNECT_INDICATION_12,
	STATE_RELEASE_REQUEST_19,
	STATE_REST_1,
	STATE_REST_2,
	};

					/* Coding standard (ie CAUSE, PROGRESS_IND) */

CONST	uchar NI2_CAUSE_CODING_STD_S[] = {
	CODING_STD_CCITT,
	CODING_STD_NATIONAL,
	CODING_STD_SPF,
	};

					/* Preferred/exclusive (ie CHAN_ID) */

CONST	uchar NI2_CHAN_PREF_EXCL_S[] = {
	CHAN_PREF,
	CHAN_EXCL,
	};

					/* D-channel indicator (ie CHAN_ID) */

CONST	uchar NI2_D_CHAN_S[] = {
	NOT_D_CHAN,
	D_CHAN,
	};

					/* Coding standard (ie HLC, LLC) */

CONST	uchar NI2_CODING_STD_S[] = {
	CODING_STD_CCITT,
	CODING_STD_RESERVED,
	CODING_STD_NATIONAL,
	CODING_STD_SPF,
	};

					/* Data bit format (ie LLC) */

CONST	uchar NI2_DATA_BIT_S[] = {
	DATA_BIT_UNUSED,
	DATA_BIT_5,
	DATA_BIT_7,
	DATA_BIT_8,
	};

					/* Duplex/half-duplex (ie LLC) */

CONST	uchar NI2_DUPLEX_S[] = {
	HALF_DUPLEX,
	FULL_DUPLEX,
	};

					/* Flow control on Reception (Rx) (ie LLC) */

CONST	uchar NI2_FLOW_CONTROL_RX_S[] = {
	FLOW_CAN_ACCEPT_DATA,
	FLOW_CANNOT_ACCEPT_DATA,
	};

					/* Flow control on Transmission (Tx) (ie LLC) */

CONST	uchar NI2_FLOW_CONTROL_TX_S[] = {
	FLOW_NOT_RQ_TX_DATA,
	FLOW_RQ_TX_DATA,
	};

					/* Rate adaption header/no header (ie LLC) */

CONST	uchar NI2_HEADER_S[] = {
	HEADER_NOT_INCLUDED,
	HEADER_INCLUDED,
	};

					/* Information request indicator (ie INFORMATION_RQ) */

CONST	uchar NI2_INFO_IND_S[] = {
	INFO_RQ_COMPLETED,
	PROMPT_FOR_ADD_INFO,
	};

					/* Information type (ie INFORMATION_RQ) */

CONST	uchar NI2_INFO_TYPE_S[] = {
	INFO_TYPE_UNDEFINED,
	INFO_TYPE_AUTHORIZATION_CODE,
	INFO_TYPE_ADDRESS_DIGITS,
	INFO_TYPE_TERMINAL_ID,
	};

					/* Interface type (ie CHAN_ID) */

CONST	uchar NI2_INT_TYPE_S[] = {
	INT_TYPE_BRI,
	INT_TYPE_PRI,
	};

					/* Channel interface ID (ie CHAN_ID) */

CONST	uchar NI2_CHAN_INT_S[] = {
	INT_ID_IMPLICIT,
	INT_ID_EXPLICIT,
	};

					/* Channel interface ID value (ie CHAN_ID) */

CONST	uchar NI2_CHAN_INT_VAL_S[] = {
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
	23,24,25,26,27
	};

					/* Nb Map (ie CHAN_ID) */

CONST	uchar NI2_NB_MAP_S[] = {
	CHAN_NUMBER,
	CHAN_MAP,
	};

					/* Intermediate rate (V110) (ie LLC) */

CONST	uchar NI2_INTER_RATE_S[] = {
	INTER_RA_UNUSED,
	INTER_RA_8KBS,
	INTER_RA_16KBS,
	INTER_RA_32KBS,
	};

					/* Interpreter flag in Endpoint ID */

CONST	uchar NI2_INTERPRETER_S[] = {
	INTERPRETER_0,
	INTERPRETER_1,
	};

					/* Logical Link Identifier negotiation (ie LLC) */

CONST	uchar NI2_LLI_S[] = {
	DEFAULT_LLI,
	FULL_PROTOCOL_LLI,
	};

					/* Cause location (ie CAUSE, PROGRESS_IND) */

CONST	uchar NI2_LOCATION_S[] = {
	LOCATION_USER,
	LOCATION_PR_NET_LOC_USER,
	LOCATION_PU_NET_LOC_USER,
	LOCATION_TRANSIT_NET,
	LOCATION_PU_NET_REMOTE_USER,
	LOCATION_PR_NET_REMOTE_USER,
	LOCATION_INTERNATIONAL_NET,
	LOCATION_NET_NTWK_POINT,
	};

					/* Modem type (ie LLC) */

CONST	uchar NI2_MODEM_S[] = {
	MODEM_RESERVED,
	MODEM_V21,
	MODEM_V22,
	MODEM_V22_BIS,
	MODEM_V23,
	MODEM_V26,
	MODEM_V26_BIS,
	MODEM_V26_TER,
	MODEM_V27,
	MODEM_V27_BIS,
	MODEM_V27_TER,
	MODEM_V29,
	MODEM_V32,
	MODEM_V35,
	};

					/* Multi frame establishment support in Data Link (ie LLC) */

CONST	uchar NI2_MULTI_FRAME_S[] = {
	MULTI_FRAME_NOT_SUPPORTED,
	MULTI_FRAME_SUPPORTED,
	};

					/* In-band negotiation (V110 or V120) (ie LLC) */

CONST	uchar NI2_NEGOTIATION_S[] = {
	NEGOTIATION_IN_BAND,
	NEGOTIATION_NOT_IN_BAND,
	};

					/* Network independent clock (NIC) (ie LLC) */

CONST	uchar NI2_NIC_RX_S[] = {
	NIC_ACCEPT_DATA,
	NIC_NOT_ACCEPT_DATA,
	};

					/* Network independent clock (NIC) (ie LLC) */

CONST	uchar NI2_NIC_TX_S[] = {
	NIC_RQ_TX_DATA,
	NIC_NOT_RQ_TX_DATA,
	};

					/* Notification indicator description (ie NOTIF_IND) */

CONST	uchar NI2_NOTIF_IND_DESCR_S[] = {
	SERVICE_PROFILE_UPDATE,
	USER_BRIDGED_ONTO_CALL,
	ACB_MONITORING_DISCONTINUED,
	CALL_ON_HOLD,
	MONITORED_USER_IDLE,
	REMOTE_HOLD,
	REMOTE_HOLD_REL,
	CALL_IS_FORWARDED,
	PRIVACY_ENABLED,
	PRIVACY_DISABLED,
	CALL_RET_FROM_HOLD,
	};

					/* Mode of operation (ie LLC) */

CONST	uchar NI2_OP_MODE_S[] = {
	BIT_TRANSPARENT,
	PROTOCOL_SENSITIVE,
	};

					/* Out-band negotiation indicator (ie LLC) */

CONST	uchar NI2_OUT_BAND_NEG_S[] =	{
	OUT_BAND_POSSIBLE,
	OUT_BAND_NOT_POSSIBLE,
	};

					/* Parity format (ie LLC) */

CONST	uchar NI2_PARITY_S[] = {
	ODD,
	EVEN,
	NO_PARITY,
	FORCED_TO_0,
	FORCED_TO_1,
	};


					/* Progress description (ie PROGRESS_IND) */

CONST	uchar NI2_PROGRESS_IND_DESCR_S[] = {
	PROGRESS_DESCR_NON_END_TO_END_ISDN,
	PROGRESS_DESCR_NON_ISDN_DEST,
	PROGRESS_DESCR_NON_ISDN_ORIG,
	PROGRESS_DESCR_IN_BAND_NOW,
	PROGRESS_DESCR_DELAY_AT_CALLED,
	};

					/* Layer 1 protocol identifier (ie LLC) */

CONST	uchar NI2_PROTOCOL_ID_LLC_1_S[] = {
	PROTOCOL_ID_1_V110,
	PROTOCOL_ID_1_G711_u,
	PROTOCOL_ID_1_G711_A,
	PROTOCOL_ID_1_G721,
	PROTOCOL_ID_1_7KHZ,
	PROTOCOL_ID_1_VIDEO,
	PROTOCOL_ID_1_RA_NON_CCITT,
	PROTOCOL_ID_1_V120,
	PROTOCOL_ID_1_X31,
	};

					/* Layer 2 protocol identifier (ie LLC) */

CONST	uchar NI2_PROTOCOL_ID_LLC_2_S[] = {
	PROTOCOL_ID_2_ISO_1745,
	PROTOCOL_ID_2_Q921,
	PROTOCOL_ID_2_X25_LL,
	PROTOCOL_ID_2_X25_ML,
	PROTOCOL_ID_2_T71,
	PROTOCOL_ID_2_HDLC_ARM,
	PROTOCOL_ID_2_HDLC_NRM,
	PROTOCOL_ID_2_HDLC_ABM,
	PROTOCOL_ID_2_LAN_LLC,
	PROTOCOL_ID_2_X75_SLP,
	};

					/* Layer 3 protocol identifier (ie LLC)*/

CONST	uchar NI2_PROTOCOL_ID_LLC_3_S[] = {
	PROTOCOL_ID_3_Q931,
	PROTOCOL_ID_3_X25_PL,
	PROTOCOL_ID_3_ISO_8208,
	PROTOCOL_ID_3_ISO_8348,
	PROTOCOL_ID_3_ISO_8473,
	PROTOCOL_ID_3_T70,
	};

					/* Reason for redirection (ie REDIR_NB) */

CONST	uchar NI2_REASON_REDIR_S[] = {
	R_UNKNOWN,
	R_CALL_FORWARDING_BUSY,
	R_CALL_FORWARDING_NO_REPLY,
	R_CALL_FORWARDING_DTE_OUT,
	R_CALL_FORWARDING_BY_CALLED,
	R_CALL_FORWARDING_UNCONDITIONAL,
	};

					/* Signal values (ie SIGNAL) */

CONST	uchar NI2_SIGNAL_VAL_S[] = {
	DIAL_ON,
	RING_BACK_ON,
	NET_CONGEST_ON,
	BUSY_ON,
	CONFIRM_ON,
	CALL_WAITING_ON,
	TONES_OFF,
	PATTERN_0,
	PATTERN_1,
	PATTERN_2,
	PATTERN_3,
	PATTERN_4,
	ALERTING_OFF,

	RECALL_DIAL_TONE_ON,
	BARGE_IN_ON,
	INCOMING_ADD_CALL,
	PRIORITY_ADD_CALL,
	EXPENSIVE_ROUTE_WARNING,
	};

					/* Status indicator (ie FEATURE_IND) */

CONST	uchar NI2_STATUS_IND_S[] = {
	STAT_DEACTIVATED,
	STAT_ACTIVATED,
	STAT_PROMPT,
	STAT_PENDING,
	};

					/* Stop bit format (ie LLC) */

CONST	uchar NI2_STOP_BIT_S[] = {
	STOP_BIT_UNUSED,
	STOP_BIT_1,
	STOP_BIT_1_5,
	STOP_BIT_2,
	};

					/* Information structure (ie LLC) */

CONST	uchar NI2_STRUCTURE_S[] = {
	STRUCTURE_DEFAULT,
	STRUCTURE_8KHZ_INT,
	STRUCTURE_SDU_INT,
	STRUCTURE_UNSTRUCTURED,
	};

					/* Subaddress odd/even indicator (ie CALLED & CALLING _SUB_ADD) */

CONST	uchar NI2_SUB_ADD_IND_S[] = {
	SUB_ADD_ODD,
	SUB_ADD_EVEN,
	};

					/* Subaddress type (ie CALLED & CALLING _SUB_ADD) */

CONST	uchar NI2_SUB_ADD_TYPE_S[] = {
	SUB_ADD_OSI,
	SUB_ADD_USER,
	};

					/* Asynchronous/synchronous (ie LLC) */

CONST	uchar NI2_SYN_ASYN_S[] =	{
	SYN,
	ASYN,
	};

					/* Restart indicator class (ie RESTART_IND) */

CONST	uchar NI2_RESTART_IND_CLASS_S[] = {
	RI_INDICATED_CHANNEL,
	RI_SINGLE_INTERFACE,
	RI_ALL_INTERFACES,
	};

					/* Teleservices according to CCITT standard (ie HLC) */

CONST	uchar NI2_TELESERVICE_CCITT_S[] = {
	TELEPHONY,
	FAX_3,
	FAX_4,
	MIXED_MODE,
	PROCESSABLE_FORM,
	TELETEX,
	VIDEOTEX,
	TELEX,
	MHS,
	OSI,
	MAINTENANCE,		/* = HLC_NOT_AVAILABLE_1 */
	MANAGEMENT,			/* = HLC_NOT_AVAILABLE_2 */
	AUDIOVISUAL_F_720,
	HLC_RESERVED,
	};

					/* Teleservices which may be extended (ie HLC) */

CONST	uchar NI2_TELESERVICE_EXT_S[] = {
	MAINTENANCE,
	MANAGEMENT,
	};

					/* Transit network plan (ie TRANSIT_NET_SEL) */

CONST	uchar NI2_TRANSIT_NET_PLAN_S[] = {
	UNKNOWN_PLAN,
	CARRIER_ID_CODE,
	USER_SPECIFIED_ID_CODE,
	};

					/* Transit network type (ie TRANSIT_NET_SEL) */

CONST	uchar NI2_TRANSIT_NET_TYPE_S[] = {
	USER_SPECIFIED_TYPE,
	NATIONAL_NETWORK_ID_TYPE,
	};

					/* Information transfer capability (ie BC) */

CONST	uchar NI2_TRF_CAP_BC_S []  ={
	TRF_CAP_SPEECH,
	TRF_CAP_UNRESTRICTED,
	TRF_CAP_3_1_AUDIO,
	};

					/* Information transfer capability (ie LLC) */

CONST	uchar NI2_TRF_CAP_LLC_S []  ={
	TRF_CAP_SPEECH,
	TRF_CAP_UNRESTRICTED,
	TRF_CAP_RESTRICTED,
	TRF_CAP_3_1_AUDIO,
	TRF_CAP_7_AUDIO,
	TRF_CAP_VIDEO,
	};

					/* Type of Access (ie OS_ACCSS) */

CONST	uchar NI2_TYPE_ACCSS_S[] = {
	ACCSS_TYPE_PU_PRINC_DEF,
	ACCSS_TYPE_PU_ALTERNATE,
	};


					/* Numbering plan (ie CALLED_NB) */

CONST	uchar NI2_CALLED_NB_PLAN_S[] = {
	PLAN_UNKNOWN,
	PLAN_ISDN,
	PLAN_PRIVATE,
	};


					/* Numbering plan (ie REDIR_NB) */

CONST	uchar NI2_REDIRECTION_NB_PLAN_S[] = {
	PLAN_ISDN,
	PLAN_PRIVATE,
	};


					/* Calling presentation indicator (ie CALLING_NB) */

CONST	uchar NI2_CALLING_NB_PRES_S[] = {
	PRES_ALLOWED,
	PRES_RESTRICTED,
	PRES_NOT_AVAILABLE,
	PRES_RESERVED,
	};
					/* Numbering plan (ie CALLING_NB) */

CONST	uchar NI2_CALLING_NB_PLAN_S[] = {
	PLAN_UNKNOWN,
	PLAN_ISDN,
	PLAN_PRIVATE,
	};
					/* Numbering plan (ie REDIR_NB) */

CONST	uchar NI2_REDIR_NB_PLAN_S[] = {
	PLAN_UNKNOWN,
	PLAN_ISDN,
	PLAN_DATA,
	PLAN_PRIVATE,
	};


					/* User rate (V110 & V120) (ie LLC) */

CONST	uchar NI2_USER_RATE_S[] =	{
	RA_E_BITS,
	RA_0_6KBS,
	RA_1_2KBS,
	RA_2_4KBS,
	RA_3_6KBS,
	RA_4_8KBS,
	RA_7_2KBS,
	RA_8KBS,
	RA_9_6KBS,
	RA_14_4KBS,
	RA_16KBS,
	RA_19_2KBS,
	RA_32KBS,
	RA_48KBS,
	RA_56KBS,
	RA_64KBS,
	RA_0_1345KBS,
	RA_0_100KBS,
	RA_0_75_1_2KBS,
	RA_1_2_0_75KBS,
	RA_0_050KBS,
	RA_0_075KBS,
	RA_0_110KBS,
	RA_0_150KBS,
	RA_0_200KBS,
	RA_0_300KBS,
	RA_12KBS,
	};

		/* Multuplier for BC or LLC in case of n*64 kb/s option */

CONST	uchar NI2_T_MULTIPLIER_S[] = {
	2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24
	};


		/* Facility coding value for net spf facility (SPF_FAC) */

CONST	uchar NI2_FAC_CODE_S[] = {
	FAC_INWATS,
	FAC_OUTWATS,
	FAC_FOREIGN_EXCHANGE,
	FAC_TIE_TRUNK,

};
		/* User to user information protocol discriminator (ie UUI) */

CONST	uchar NI2_UUI_PROTOCOL_DISCR_S[] = {
	PROTOCOL_DISCR_USER_SPF,
	PROTOCOL_DISCR_OSI,
	PROTOCOL_DISCR_X244,
	PROTOCOL_DISCR_SYSTEM_MANAGEMENT,
	PROTOCOL_DISCR_IA5,
	PROTOCOL_DISCR_V120,
	PROTOCOL_DISCR_Q931,
	};

/*=========================================================================*/

	/* Tables selected according to another value (indexed tables) */

		/* Cause value  according to the class */

			/* Normal event - class 000 */

CONST	uchar NI2_C_V_NORMAL_EVENT_0_S[] = {
	C_C_NORMAL_EVENT_0,
	C_V_UNASSIGNED_NUMBER_1,
	C_V_NO_ROUTE_TO_TRANSIT_NET_2,
	C_V_NO_ROUTE_TO_DEST_3,
	C_V_CHAN_UNACCEPTABLE_6,
	C_V_AWARDED_7,
};

			/* Normal event - class 000 for network specific coding standard */

CONST	uchar NI2_C_V_NORMAL_EVENT_0_NET_S[] = {
	C_C_NORMAL_EVENT_0,
	C_V_CALL_PROCEEDING_8,
	C_V_SERVICE_DENIED_13
};


			/* Normal event - class 001 */

CONST	uchar NI2_C_V_NORMAL_EVENT_S[] = {
	C_C_NORMAL_EVENT,
	C_V_NORMAL_CLEARING_16,
	C_V_USER_BUSY_17,
	C_V_NO_USER_RESPONDING_18,
	C_V_NO_ANSWER_19,
	C_V_CALL_REJECT_21,
	C_V_DEST_OUT_OF_ORDER_27,
	C_V_INVALID_NUMBER_FORMAT_28,
	C_V_FACILITY_REJECT_29,
	C_V_RESPONSE_TO_STATUS_ENQUIRY_30,
	C_V_NORMAL_UNSPECIFIED_31,

};

			/* Normal event - class 001 for network specific coding standard */

CONST	uchar NI2_C_V_NORMAL_EVENT_1_NET_S[] = {
	C_C_NORMAL_EVENT,
	C_V_SPECIAL_INTERCEPT_ANNOUNCEMT_28,
	C_V_SPC_INT_ANN_UNDEFINED_CODE_29,
	C_V_SPC_INT_ANN_NB_UNASSIGNED_30,
	C_V_SPC_INT_ANN_CALL_BLOCKED_31,
};

			/* Resource not available */

CONST	uchar NI2_C_V_RESOURCE_UNAVAILABLE_S[] ={
	C_C_RESOURCE_UNAVAILABLE,
	C_V_NO_CIRCUIT_AVAILABLE_34,
	C_V_NETWORK_TEMPORARY_FAILURE_41,
	C_V_NETWORK_CONGESTION_42,
	C_V_ACCESS_INFORMATION_DISCARDED_43,
	C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44,
};

			/* Service not available */

CONST	uchar NI2_C_V_SERVICE_NOT_AVAILABLE_S[] = {
	C_C_SERVICE_NOT_AVAILABLE,
	C_V_REQUESTED_FAC_NOT_SUBSCRIBED_50,
	C_V_BC_NOT_AUTHORIZED_57,
	C_V_SERVICE_NOT_AVAILABLE_63,
};

			/* Service not available for network specific coding standard */

CONST	uchar NI2_C_V_SERVICE_NOT_AVAILABLE_NET_S[] = {
	C_C_SERVICE_NOT_AVAILABLE,
	C_V_BC_INCOMPATIBLE_WITH_SERVICE_51,
	C_V_SERVICE_OPERATION_VIOLATED_53,
};

			/* Service not implemented */

CONST	uchar NI2_C_V_SERVICE_NOT_IMPLEMENTED_S[] = {
	C_C_SERVICE_NOT_IMPLEMENTED,
	C_V_BC_NOT_IMPLEMENTED_65,
	C_V_REQUESTED_FAC_NOT_IMPLEMENTED_69,
};

			/* Invalid message */

CONST	uchar NI2_C_V_INVALID_MESSAGE_S[] = {
	C_C_INVALID_MESSAGE,
	C_V_INVALID_CALL_REF_81,
	C_V_INCOMPATIBLE_DESTINATION_88,
};

			/* Invalid message for network specific coding standard */

CONST	uchar NI2_C_V_INVALID_MESSAGE_NET_S[] = {
	C_C_INVALID_MESSAGE,
	C_V_SEGMENTATION_ERROR_90,
	C_V_REASSEMBLY_ERROR_91,
};
			/* Protocol error */

CONST	uchar NI2_C_V_PROTOCOL_ERROR_S[] = {
	C_C_PROTOCOL_ERROR,
	C_V_MANDATORY_IE_MISSING_96,
	C_V_MESSAGE_TYPE_NON_EXISTENT_97,
	C_V_NON_EXISTENT_IE_99,
	C_V_INVALID_IE_CONTENT_100,
	C_V_MESSAGE_NOT_COMPATIBLE_101,
	C_V_RECOVERY_ON_TIMER_EXPIRY_102,
	C_V_PROTOCOL_ERROR_UNSPECIFIED_111,
};

			/* Interworking */

CONST	uchar NI2_C_V_INTERWORKING_S[] = {
	C_C_INTERWORKING,
	C_V_INTERWORKING_UNSPECIFIED_127,
};

/*-------------------------------------------------------------------------*/

					/* Information transfer rate (ie BC) according to transfer mode */

CONST	uchar NI2_BC_TRF_RATE_CIRCUIT_S[] = {
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	TRF_RATE_384KBS,
	TRF_RATE_1536KBS,
	TRF_RATE_MULTI_RATE,
};

					/* Information transfer rate (ie LLC) according to transfer mode */

CONST	uchar NI2_TRF_RATE_CIRCUIT_S[] = {
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	TRF_RATE_2x64KBS,
	TRF_RATE_384KBS,
	TRF_RATE_1536KBS,
	TRF_RATE_1920KBS,
	TRF_RATE_MULTI_RATE,
};

CONST	uchar NI2_TRF_RATE_PACKET_S[] = {
	TRF_MODE_PACKET,
	TRF_RATE_PACKET_MODE,
};

/*-------------------------------------------------------------------------*/

					/* Channel selection according to interface type (ie CHAN_ID) */

CONST	uchar NI2_CHAN_SEL_BRI_S[] = {
	INT_TYPE_BRI,
	NO_CHAN,
	B1_CHAN,
	B2_CHAN,
	ANY_CHAN,
};

CONST	uchar NI2_CHAN_SEL_PRI_S[] = {
	INT_TYPE_PRI,
	AS_INDICATED,
	NO_CHAN
};

/*-------------------------------------------------------------------------*/

CONST	uchar NI2_REDIRECTION_PLAN_ISDN_S[] = {
	PLAN_ISDN,
	NB_NATIONAL,
	NB_LOCAL,
};

CONST	uchar NI2_REDIRECTION_PLAN_PRIVATE_S[] = {
	PLAN_ISDN,
	NB_NET_SPF,
	NB_ABBREVIATED,
};

CONST	uchar NI2_CALLED_PLAN_UNKNOWN_S[] = {
	PLAN_UNKNOWN,
	NB_UNKNOWN,
};

CONST	uchar NI2_CALLED_PLAN_ISDN_S[] = {
	PLAN_ISDN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
	NB_LOCAL,
};

CONST	uchar NI2_CALLED_PLAN_PRIVATE_S[] = {
	PLAN_PRIVATE,
	NB_NET_SPF,
	NB_ABBREVIATED,
};

CONST	uchar NI2_CALLING_PLAN_UNKNOWN_S[] = {
	PLAN_UNKNOWN,
	NB_UNKNOWN,
};

CONST	uchar NI2_CALLING_PLAN_ISDN_S[] = {
	PLAN_ISDN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
	NB_LOCAL,
};

CONST	uchar NI2_CALLING_PLAN_PRIVATE_S[] = {
	PLAN_PRIVATE,
	NB_LOCAL,
	NB_ABBREVIATED,
};

CONST	uchar NI2_REDIR_PLAN_UNKNOWN_S[] = {
	PLAN_UNKNOWN,
	NB_UNKNOWN,
};

CONST	uchar NI2_REDIR_PLAN_ISDN_S[] = {
	PLAN_ISDN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
	NB_LOCAL,
};

CONST	uchar NI2_REDIR_PLAN_PRIVATE_S[] = {
	PLAN_PRIVATE,
	NB_ABBREVIATED,
	NB_SUBSCRIBER
};

CONST	uchar NI2_REDIR_PLAN_DATA_S[] = {
	PLAN_DATA,
	NB_ABBREVIATED,
};

/*-------------------------------------------------------------------------*/

CONST	uchar NI2_CALLING_PRES_ALLOWED_S [] = {
	PRES_ALLOWED,
	USER_PROVIDED,
	USER_PASSED,
	USER_FAILED,
	NETWORK_PROVIDED,
};

CONST	uchar NI2_CALLING_PRES_RESTRICTED_S [] = {
	PRES_RESTRICTED,
	USER_PROVIDED,
	USER_PASSED,
	USER_FAILED,
	NETWORK_PROVIDED,
};

CONST	uchar NI2_CALLING_PRES_NOT_AVAIL_S [] = {
	PRES_NOT_AVAILABLE,
	NETWORK_PROVIDED,
};

/*-------------------------------------------------------------------------*/

		/*
			Meta description of the information elements.
			This description is  used to check an information element
			inside a message and to store its value into  the internal
			structure.
			In the other way it is used to generate the information element of
			a message from the internal structure.
		*/

#define NS_INCLUDE_IE_META_FUNCTION		ON		/* include prototypes of functions inside mp_ie.ni2 */

#include "ni2.mp_ie"  /* include IE meta-programs */

/*--------------------------------------------------------------------------*/

uchar ni2_octet_5 ()
{
	ie_if_flag = ON;

	if (direction == TO_D_CHANNEL) {

		if (I_(bc, protocol_id_1) == BYTE_VAL_NIL) {

				/* octet 5 is missing */

			ie_if_flag = OFF;
		}
	}

	return (OK);
}

						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/

uchar ni2_bc_check_multi_spdu ()
{

	if (direction == FROM_D_CHANNEL) {

			/* Multi-rate service is available in BC for PRImary rate only */

		if ((Na_type == BRI) && (I_(bc, trf_rate) == TRF_RATE_MULTI_RATE)) {

			return (NOK);
		}
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

#if 0

	/*	ISDN Number shall have at least 7 digits :
		It is a Bellcore requirement but it is not
		implemented in many US PABX */

uchar ni2_check_length ()
{

#	if NS_TYPE_PRI == ON

		if (Na_type == PRI) {

			if (direction == FROM_D_CHANNEL) {

				if ((I_(called_nb, plan_id) == PLAN_ISDN) &&
					(I_(called_nb, lgth) < 7)) {

					return (NOK);
				}
			}

		}

#	endif

	return (OK);

}

#endif	/* end of #if 0 */

uchar ni2_called_nb_spdu ()
{
	ie_if_flag = ON;

	if (Na_type == PRI) {
		ie_if_flag = OFF;
	}


	return (OK);
}

/*-------------------------------------------------------------------------*/
uchar ni2_calling_nb_spdu ()
{

		/* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;		/* in general case, process octet 3a */

	if (Na_type == PRI) return (OK);

#	if NS_TYPE_BRI == ON

		if ((direction == TO_D_CHANNEL) &&
			(I_calling_nb_presentation == PRES_ALLOWED) &&
			(I_calling_nb_screen_ind   == USER_PROVIDED)
		   ) {
			ie_if_flag = OFF;	/* default values used : omit octet 3a */
		}

#	endif

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			ni2_cause_spdu - implements the specific processing of a cause
							 Information Element (IE).

Usage			uchar ni2_cause_spdu ();

Return value :  ni2_cause_spdu returns	OK
									NOK

common constants and declarations : ns.h net_i_s.h

common objects : internal data structure i_cause, ie spdu context.
						- direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

uchar ni2_cause_spdu ()
{
	uchar	class_val;				/* cause class & value */

	class_val = C_v (I_(cause,cause_class), I_(cause,cause_val));

	if (I_(cause, coding_std) == CODING_STD_CCITT) {

		switch (class_val) {
			case C_v (C_C_RESOURCE_UNAVAILABLE,	C_V_ACCESS_INFORMATION_DISCARDED_43):
			case C_v (C_C_PROTOCOL_ERROR,		C_V_MANDATORY_IE_MISSING_96)		:
			case C_v (C_C_PROTOCOL_ERROR,		C_V_MESSAGE_TYPE_NON_EXISTENT_97)	:
			case C_v (C_C_PROTOCOL_ERROR,		C_V_NON_EXISTENT_IE_99)				:
			case C_v (C_C_PROTOCOL_ERROR,		C_V_INVALID_IE_CONTENT_100)			:
			case C_v (C_C_PROTOCOL_ERROR,		C_V_MESSAGE_NOT_COMPATIBLE_101)		:

				if (direction == FROM_D_CHANNEL) {

						/* FROM the D CHANNEL side */

					if (! Eo_ie) {

						if (r_exec_spdu_ie ((uchar *)&NI2_DIAG_P) != OK) {
							return (NOK);
						}

					}

				} else {			/* TO D CHANNEL side */

					if (I_(cause,diag_lgth) != 0) {

						if (s_exec_spdu_ie ((uchar *)&NI2_DIAG_P) != OK) {
							return (NOK);
						}

					}

				}

				break;

			default :

					/* No diagnostic should be included */

				if (I_(cause,diag_lgth) != 0) {
					return (NOK);
				}
		}

	} else {

	   if ( (I_(cause, coding_std) == CODING_STD_SPF) &&
			(class_val == C_v (C_C_SERVICE_NOT_AVAILABLE, C_V_SERVICE_OPERATION_VIOLATED_53))) {

				/* Network specific cause #53 */

		   switch (I_(cause,diag_lgth)) {

			   case 0 :
				   break;

			   case 1 :

				   switch (I_cause_diagnostic) {

					   case SHORT_TERM_DENIAL	:
					   case LONG_TERM_DENIAL	:
						   return (OK);

					   default :
						   return (NOK);
					}

			   default :
				   return (NOK);
		   }
	   }

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name		ni2_chan_id_check  - Test if interface type in chan_id IE and in
							configuration are the same. If not return error.

Usage		uchar ni2_chan_id_check ();

Return value :  ni2_chan_id_check  returns = OK	valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar ni2_chan_id_check  ()
{
#if NS_MAINTENANCE_CAPABILITY == ON
	struct nsna FAR *p_sav;
#endif

	if (direction == FROM_D_CHANNEL) {

		if (I_chan_id_int_type == INT_TYPE_BRI) {
			if (Na_type != BRI) return (NOK);
			if (I_(chan_id, d_chan) == D_CHAN) return (NOK);

		} else {

			if (Na_type != PRI) return (NOK);

#			if NS_MAINTENANCE_CAPABILITY == OFF

					/* D channel indicator allowed for PRI only */

				if (I_(chan_id, d_chan) == D_CHAN) return (NOK);

#			endif
		}

	}

		/* Process PRI type chan_id */

	if (I_(chan_id,int_type) != INT_TYPE_BRI) {

		if (direction == TO_D_CHANNEL) {

			if (I_(chan_id,chan_sel) == NO_CHAN) {
				return (OK);
			}

		} else {

			if ((I_(chan_id,chan_sel) == NO_CHAN) ||
				(I_(chan_id,chan_sel) == ANY_CHAN)) {
				ie_optional_octet = ON;
			}
		}

		if (direction == FROM_D_CHANNEL) {

#			if NS_MAINTENANCE_CAPABILITY == ON

					/*
					 * Check if the interface Id is valid.
					 * We don't need to do that if the
					 * NFAS TSP was selected because in that
					 * case, we have no idea of what are the interfaces
					 * the application is dealing with.
					 *
					 * if ns_nfas in OFF, we have TSP and no D channel Backup.
					 * if ns_nfas in ON, we still may have a TSP (with D channel backup)
					 */

				if (ns_nfas == ON) {

						/* Check if we have a TSP mode */

				if ((I_(chan_id,chan_sel) == NO_CHAN) ||
					(I_(chan_id,chan_sel) == ANY_CHAN)) {

							/*
							 * No TSP mode --> check the int_id.
							 */

						p_sav = p_nsna;

						if (I_(chan_id, int_id) == INT_ID_EXPLICIT) {

							if (ns_access_na (I_(chan_id, int_id_val)) == NOK) {
								p_nsna = p_sav;
								return (NOK);
							}
						}

						p_nsna = p_sav;
					}
				}

#			endif

			return (r_exec_spdu_ie ((uchar *)&NI2_CHAN_ID_PRI_P));

		} else {

			return (s_exec_spdu_ie ((uchar *)&NI2_CHAN_ID_PRI_P));
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			llc_spdu - implements the processing of the low layer
							compatibility (LLC) IE of a received SPDU
							message and of SPDU message to be sent.

Usage			uchar llc_spdu ();

Return value :  llc_spdu returns = OK valid data,
								 = NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/
uchar ni2_llc_3a_spdu ()
{

	ie_if_flag = ON;	/* (default value) : octet 3a may be present */

	if ((direction == TO_D_CHANNEL) &&
		(i_llc[0].out_band_neg == OUT_BAND_NOT_POSSIBLE)) {

			/* default value for octet 3a : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);

}


uchar ni2_llc_4ab_spdu ()
{
	ie_if_flag = ON;	/* octets 4a and 4b may be present */

	if (direction == TO_D_CHANNEL) {

		if (i_llc[0].trf_rate == TRF_RATE_MULTI_RATE) {

			ie_if_flag = OFF;

		} else {

			if ((i_llc[0].structure == STRUCTURE_DEFAULT)		&&
				(i_llc[0].config	== CONFIG_POINT_TO_POINT)	&&		/* forced value anyway */
				(i_llc[0].est		== EST_DEMAND)				&&		/* forced value anyway */
				(i_llc[0].symmetry	== BIDIRECTIONAL_SYMMETRY)	&&		/* forced value anyway */
				(i_llc[0].dest_rate == i_llc[0].trf_rate)) {

					/* default values for octets 4a and 4b : they are omitted */

				ie_if_flag = OFF;
			}
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar ni2_llc_4b_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 4b may be present */

	if ((direction		 == TO_D_CHANNEL)			&&
		(i_llc[0].symmetry	 == BIDIRECTIONAL_SYMMETRY)	&&		/* forced value anyway */
		(i_llc[0].dest_rate == i_llc[0].trf_rate)) {

		/* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

#define Get_layer_id()	Extract (5,Mask(2))

uchar ni2_llc_5_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 5 may be present */

		/* if I_llc_protocol_id_1 == BYTE_VAL_NIL -> octet 5 is missing */

	if (direction == TO_D_CHANNEL) {

		if (i_llc[0].protocol_id_1 == BYTE_VAL_NIL) {

				/* octet 5 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_1) {

				/* It is NOT Octet 5 (layer 1) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar ni2_llc_6_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 6 may be present */

		/* if I_llc_layer_id_2 == BYTE_VAL_NIL -> octet 6 is missing */

	if (direction == TO_D_CHANNEL) {

			/* octet 6 must be present if PACKET MODE */

		if (i_llc[0].protocol_id_2 == BYTE_VAL_NIL) {

			/* octet 6 is missing */

			if (i_llc[0].trf_mode == TRF_MODE_PACKET) return (NOK);

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_2) {

				/* It is NOT Octet 6 (layer 2) */

			ie_if_flag = OFF;
		}
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar ni2_llc_7_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 7 may be present */

		/* if I_llc_layer_id_3 == BYTE_VAL_NIL -> octet 7 is missing */

	if (direction == TO_D_CHANNEL) {

		if (i_llc[0].protocol_id_3 == BYTE_VAL_NIL) {

				/* octet 7 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_3) {

				/* It is NOT Octet 7 (layer 3) */

			ie_if_flag = OFF;
		}
	}

	return (OK);
}

#if NS_SPF_FACILITY == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		ni2_spf_fac_spdu - implements the processing of the specific facility
						  IE (received or to be sent in a SPDU message).

Usage	   uchar ni2_spf_fac_spdu ();

Return value :  ni2_spf_fac_spdu returns = OK   valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar ni2_spf_fac_spdu ()
{

	if (direction == TO_D_CHANNEL) {

		if (check_convert (	(uchar FAR *) Get_p_ie,
							I_spf_fac_a_net_id,
							I_spf_fac_net_id_lgth,
							IA5, ANY_CHAR
						  ) != OK ) return (NOK);
	} else {

		if (check_convert (	I_spf_fac_a_net_id,
							(uchar FAR *) Get_p_ie,
							I_spf_fac_net_id_lgth,
							IA5, ANY_CHAR
						  ) != OK ) return (NOK);

	}

	Inc_p_ie (I_spf_fac_net_id_lgth-1);

	return (OK);

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name		ni2_progress_ind_check - check PROGRESS_IND IE coding

Usage		uchar ni2_progress_ind_check ();

Return value :  ni2_progress_ind_check returns	= OK	valid data,
											= NOK  invalid data.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar ni2_progress_ind_check ()
{


	if (Na_type == BRI) {

#		if NS_TYPE_BRI == ON

			if ((I_(progress_ind,progress_loc) == LOCATION_TRANSIT_NET) ||
				(I_(progress_ind,progress_descr) == PROGRESS_DESCR_DELAY_AT_CALLED)) {

					/* ensure the coding standard is National Specific */

				if (I_(progress_ind,coding_std) != CODING_STD_NATIONAL) {
					return (NOK);
				}

			}

			if (I_(progress_ind,progress_loc) == LOCATION_INTERNATIONAL_NET) {

					/* ensure the coding standard is Network Specific */

				if (I_(progress_ind,coding_std) != CODING_STD_SPF) {
					return (NOK);
				}

			}

#		endif

	}

	return (OK);
}

uchar ni2_redir_spdu ()
{

	if (I_(redir_nb, pres) == PRES_RESERVED) return (NOK);

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		ni2_restart_spdu - check if presence of CHAN ID IE is compulsory or forbidden.

Usage		uchar ni2_restart_spdu ();

Return value :  ni2_restart_spdu returns = OK   valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar ni2_restart_spdu ()
{

	if (is_ie_i (CODESET_0, CHAN_ID) == ABSENT) {
		return (OK);

	} else {

		if (I_restart_ind_class != RI_ALL_INTERFACES) {
			return (OK);
		}

	}

	return (NOK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			ni2_call_appear_ext - allows the processing of the #3a octet.

Usage			uchar ni2_call_appear_ext ();

Return value :  ni2_call_appear_ext returns OK.

*--------------------------------------------------------------------------*/

uchar ni2_call_appear_ext ()
{
	ie_if_flag = ON;			/* octet 3a may be present */

	if ((direction == TO_D_CHANNEL) &&
		(I_(call_appear,call_appear_id_2) == BYTE_VAL_NIL)) {
		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			ni2_spid - 

Usage			uchar ni2_spid ();

Return value :  ni2_spid returns OK.

*--------------------------------------------------------------------------*/
uchar ni2_spid ()
{

	if ((direction == FROM_D_CHANNEL) &&
		(Na_fct == FG_NT_TE)) {

       	I_(spid, ces) = Dl_ces;
    }

    return (OK);
}

/*-------------------------------------------------------------------------*/

#define Ns_ni2_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_ni2_end_table_or_function		};
#define Ns_ni2_tab_tabl_entry(idx, tab)		Ns_tab_tabl_entry (idx, tab),
#define Ns_ni2_tabx_list_entry(tab)			Ns_tabx_list_entry (tab),
#define Ns_ni2_tab_tabx_entry(idx, tab)		Ns_tab_tabx_entry (idx, tab),

#define Ns_ni2_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off)	\
			Ns_tab_ie_entry (codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off),

#define Ns_ni2_tab_ie_msg_header			{CODESET_NIL, MESSAGE_HEADER, (uchar *)A_NIL, sizeof(struct i_message_header), (uchar *)Pic_address (&i_message_header), (uchar *)A_NIL, (uchar *)A_NIL, 1, 0},

#include "ni2.tab_ie"		/* include other Tables describing the IEs */

#define NI2_MX_TABL (sizeof(NI2_TAB_TABL)/sizeof (struct tabl))
CONST	uchar	ni2_size_tab_tabl = NI2_MX_TABL;

#define NI2_MX_TABX (sizeof(NI2_TAB_TABX)/sizeof (struct tabx))
CONST	uchar	ni2_size_tab_tabx = NI2_MX_TABX;

CONST	uchar	ni2_size_tab_ie = Rnd_sizeof (NI2_TAB_IE) / IE_ELEM_SIZE;	/* maximum number of item in the table */

/*-------------------------------------------------------------------------*/

#if OM_CODE_TYPE == OM_PIC /* PIC used{ */

#undef Ns_ni2_table_or_function

#undef Ns_ni2_end_table_or_function
#undef Ns_ni2_tab_tabl_entry
#undef Ns_ni2_tabx_list_entry
#undef Ns_ni2_tab_tabx_entry
#undef Ns_ni2_tab_ie_entry
#undef Ns_ni2_tab_ie_msg_header

#define Ns_ni2_table_or_function(str, tab)	i_pic = 0;						\
											{								\
												struct str FAR	*p_table;	\
												p_table = tab;

#define Ns_ni2_end_table_or_function		}

#define Ns_ni2_tab_tabl_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_val, (uchar *)tab);
#define Ns_ni2_tabx_list_entry(tab)			Pic_init_struct_array_next (p_table,  p_val, (uchar	*)tab);
#define Ns_ni2_tab_tabx_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_tab, (struct tabx_list *)tab);

#define Ns_ni2_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off)	\
	Pic_init_struct_array (p_table,  i_pic, p_prog, (uchar	*)mp_a);			\
	Pic_init_struct_array (p_table,  i_pic, p_i_struct, (uchar	*)i_str);		\
	Pic_init_struct_array (p_table,  i_pic, p_init_spdu, (uchar	*)df_spdu);		\
	Pic_init_struct_array_next (p_table,  p_init_ssdu, (uchar	*)df_ssdu);

#define Ns_ni2_tab_ie_msg_header		Ns_ni2_tab_ie_entry (0, 0, P_NIL, &i_message_header, P_NIL, P_NIL, 0, 0)

		/*	Function used to initialize address fields in Tables above */


void pic_init_ns_ni2_ie ()
{
	uchar	i_pic;			/* current index */

#	include "ni2.tab_ie"
}

#endif /* end of PIC used} */


/*EOF*/
