
/*--------------------------------------------------------------------------*
 *					   M O D U L E   H E A D E R
 *
 * filename - net_ie.vn6
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the meta description of all the information
 * elements and the integrity constraints associated to.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/
/*

Table structures :
----------------

		tabl_item   TABL_ITEM									uchar
		==========================                             ============
		| tabl_id | size | p_val |---------------------------->|   val    |
		--------------------------  tabl_yy      ============  ------------
		|         |      |       |-------------->|   val    |  |   val    |
		--------------------------               ------------  ------------
		|         |      |       |               |   val    |  |   val    |
		--------------------------               ------------  ------------
		|         |      |       |               |          |  |          |
		--------------------------
		|         |      |       |
		--------------------------
		|         |      |       |


	tabx_item   TABX_ITEM                   tabx_list                uchar
	=================================     =================        =========
	| tabl_id | size | list pointer |---->| tabl_id | size|------->| x_val |
	---------------------------------     -----------------        ---------
	|         |      |              |     |         |     |        |  val  |
	---------------------------------     -----------------        ---------
	|         |      |              |     |         |     |        |  val  |
	---------------------------------
	|         |      |              |

*/


	/*
		Initialization constants of ie internal structure
		used by SPDU received processing.
	*/

		/* Advide of charge (ADVICE_CHARGE) */

CONST	struct i_advice_charge	df_spdu_vn6_i_advice_charge = {
	FREE_OF_CHARGE,
	BYTE_VAL_NIL,
	A_NIL,
	CODING_STD_NATIONAL,
	NATIONAL_STD,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};
		/*  Bearer capability (BC) */

CONST   struct  i_bc	df_spdu_vn6_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	BYTE_VAL_NIL,

};

		/*  Called party number and subaddress (CALLED_NB, CALLED_SUB_ADD) */

CONST   struct  i_called_nb	 df_spdu_vn6_i_called_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	0,
	A_NIL
};

CONST   struct  i_called_sub_add	df_spdu_vn6_i_called_sub_add = {
	SUB_ADD_OSI,
	SUB_ADD_EVEN,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Calling party number (CALLING_NB) */

CONST   struct  i_calling_nb	df_spdu_vn6_i_calling_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};

		/* calling party subaddress (CALLING_SUB_ADD) */

CONST   struct  i_calling_sub_add   df_spdu_vn6_i_calling_sub_add = {
	SUB_ADD_OSI,
	SUB_ADD_EVEN,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Call identity (CALL_ID) */

CONST   struct  i_call_id   df_spdu_vn6_i_call_id = {
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Call state (CALL_STATE) */

CONST   struct  i_call_state	df_spdu_vn6_i_call_state = {
	CODING_STD_CCITT,
	STATE_NULL_0
};

		/* Cause (CAUSE) */

CONST   struct  i_cause	 df_spdu_vn6_i_cause = {
	CODING_STD_CCITT,
	LOCATION_USER,
	RECOMMENDATION_Q931,
	C_C_NORMAL_EVENT,
	C_V_NORMAL_CLEARING_16,
	0,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST   struct  i_chan_id   df_spdu_vn6_i_chan_id = {
	INT_ID_IMPLICIT,
	INT_TYPE_BRI,
	CHAN_PREF,
	D_CHAN,
	ANY_CHAN,
	BYTE_VAL_NIL,
	CODING_STD_CCITT,
	CHAN_NUMBER,
	B_CHAN,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Congestion level (CONGEST_LEVEL) */

CONST   struct  i_congest_level	 df_spdu_vn6_i_congest_level = {
	RECEIVER_READY
};

		/* Date/time (DATE_TIME) */

CONST   struct  i_date_time	 df_spdu_vn6_i_date_time = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Display (DISPLAY) */

CONST   struct  i_display   df_spdu_vn6_i_display = {
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* facilities (FACILITY) */

CONST   struct  i_facility   df_spdu_vn6_i_facility = {
	FAC_SUPPLEMENTARY,
	FAC_LGTH_FORMAT,

	{	FAC_CONTEXT_SPECIFIC,
		FAC_CONSTRUCTOR,
		FAC_INVOKE,
		14
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_INVOKE_ID_TAG,
		1,
		A_NIL
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_OP_VAL_TAG,
		FAC_OP_VAL_LGTH,
		OP_VAL_UUI
	},

	{	FAC_UNIVERSAL,
		FAC_CONSTRUCTOR,
		FAC_SEQUENCE_TAG,
		6
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_SERVICE_TAG,
		FAC_SERVICE_LGTH,
		SERVICE_1
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_PREF_TAG,
		FAC_PREF_LGTH,
		PREFERRED_TRUE
	}

};

		/* High layer compatibility (HLC) */

CONST   struct  i_hlc   df_spdu_vn6_i_hlc = {
	CODING_STD_CCITT,
	INTER_CCITT_CEPT,
	PRESENTATION_PROFIL,
	TELEPHONY,
	BYTE_VAL_NIL
};

		/* Keypad facility (KEYPAD) */

CONST   struct  i_keypad	df_spdu_vn6_i_keypad = {
	0,
	A_NIL
};

		/* Low layer compatibility (LLC) */

CONST   struct  i_llc   df_spdu_vn6_i_llc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	OUT_BAND_NOT_POSSIBLE,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Notification indicator (NOTIF_IND) */

CONST   struct  i_notif_ind	 df_spdu_vn6_i_notif_ind = {
	USER_SUSPENDED,
	0,
	P_NIL
};

		/* Progress indicator (PROGRESS_IND) */

CONST   struct  i_progress_ind  df_spdu_vn6_i_progress_ind = {
	CODING_STD_CCITT,
	PROGRESS_LOC_PU_LOCAL_USER,
	PROGRESS_DESCR_NON_END_TO_END_ISDN
};

		/* User to user facility (USER_FAC) */

CONST	struct i_user_fac df_spdu_vn6_i_user_fac = {
	PROTOCOL_DISCR_MESSAGING,
	0,
	A_NIL,
};

		/* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_spdu_vn6_i_restart_ind = {
	RI_ALL_INTERFACES
};

		/*  Signal (SIGNAL) */

CONST   struct  i_signal	df_spdu_vn6_i_signal = {
	DIAL_ON
};

#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST   struct  i_spf_fac   df_spdu_vn6_i_spf_fac = {
	0,
	USER_SPECIFIED_TYPE,
	UNKNOWN_PLAN,
};

#endif

		/* User mode working (USER_MODE) */

CONST	struct i_user_mode df_spdu_vn6_i_user_mode = {
	CODING_STD_NATIONAL,
	NATIONAL_FUNCTIONAL_MODE,
};

		/* Transit network selection (TRANSIT_NET_SEL) */

CONST   struct  i_transit_net_sel   df_spdu_vn6_i_transit_net_sel = {
	USER_SPECIFIED_TYPE,
	UNKNOWN_PLAN,
	0,
	A_NIL
};

		/* User to user information (UUI) */

CONST   struct  i_uui   df_spdu_vn6_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL
};

		/* User to PCS information (USER_PCS) */

CONST   struct  i_user_pcs   df_spdu_vn6_i_user_pcs = {
	PROTOCOL_DISCR_TRANSGROUP,
	0,
	A_NIL
};

		/* PCS to USER information (PCS_USER) */

CONST   struct  i_pcs_user   df_spdu_vn6_i_pcs_user = {
	PROTOCOL_DISCR_TRANSGROUP,
	0,
	A_NIL
};

		/* Redirecting number (REDIR_NB) */

CONST	struct  i_redir_nb	df_spdu_vn6_i_redir_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

/*-------------------------------------------------------------------------

		Initialization constants for packet communications IEs
					( NOT IMPLEMENTED )

-------------------------------------------------------------------------*

		Information rate (INF_RATE)

CONST   struct  i_inf_rate  df_spdu_vn6_i_inf_rate = {
	BYTE_VAL_NIL
};

		End-to-end transit delay (E_T_E_TRANSIT_DLY)

CONST   struct  i_e_t_e_transit_dly	 df_spdu_vn6_i_e_t_e_transit_dly = {
	BYTE_VAL_NIL
};

		Transit delay selection and indication (TRANSIT_DLY_SEL)

CONST   struct  i_transit_dly_sel   df_spdu_vn6_i_transit_dly_sel = {
	BYTE_VAL_NIL
};

		Packet layer binary parameters (PACKET_LBP)

CONST   struct  i_packet_lbp	df_spdu_vn6_i_packet_lbp = {
	BYTE_VAL_NIL
};

		Packet layer window size (PACKET_LWS)

CONST   struct  i_packet_lws	df_spdu_vn6_i_packet_lws = {
	BYTE_VAL_NIL
};

		Packet size (PACKET_SIZE)

CONST   struct  i_packet_size   df_spdu_vn6_i_packet_size = {
	BYTE_VAL_NIL
};

*=========================================================================*/

	/*
		Initialization constants of the ie internal structure
		used by SSDU received processing.
	*/

		/* Advide of charge (ADVICE_CHARGE) */

CONST	struct i_advice_charge	df_ssdu_vn6_i_advice_charge = {
	FREE_OF_CHARGE,
	BYTE_VAL_NIL,
	A_NIL,
	CODING_STD_NATIONAL,
	NATIONAL_STD,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
};

		/*  Bearer capability (BC) */

CONST   struct  i_bc	df_ssdu_vn6_i_bc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	BYTE_VAL_NIL,

};

		/*  Called party number and subaddress (CALLED_NB CALLED_SUB_ADD) */

CONST   struct  i_called_nb	 df_ssdu_vn6_i_called_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	0,
	A_NIL
};

CONST   struct  i_called_sub_add	df_ssdu_vn6_i_called_sub_add = {
	SUB_ADD_OSI,
	SUB_ADD_EVEN,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Calling party number (CALLING_NB) */

CONST   struct  i_calling_nb	df_ssdu_vn6_i_calling_nb = {
	NB_NATIONAL,
	PLAN_ISDN,
	PRES_ALLOWED,
	USER_PROVIDED,
	0,
	A_NIL
};

		/* calling party subaddress (CALLING_SUB_ADD) */

CONST   struct  i_calling_sub_add   df_ssdu_vn6_i_calling_sub_add = {
	SUB_ADD_OSI,
	SUB_ADD_EVEN,
	FORMAT_IA5,
	0,
	A_NIL
};

		/* Call identity (CALL_ID) */

CONST   struct  i_call_id   df_ssdu_vn6_i_call_id = {
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Call state (CALL_STATE) */

CONST   struct  i_call_state	df_ssdu_vn6_i_call_state = {
	CODING_STD_CCITT,
	STATE_NULL_0
};

		/* Cause (CAUSE) */

CONST   struct  i_cause	 df_ssdu_vn6_i_cause = {
	CODING_STD_CCITT,
	LOCATION_PU_NET_LOC_USER,
	RECOMMENDATION_Q931,
	C_C_NORMAL_EVENT,
	C_V_NORMAL_CLEARING_16,
	0,
	0,
	A_NIL
};

		/* Channel identification (CHAN_ID) */

CONST   struct  i_chan_id   df_ssdu_vn6_i_chan_id = {
	INT_ID_IMPLICIT,
	INT_TYPE_BRI,
	CHAN_PREF,
	D_CHAN,
	ANY_CHAN,
	BYTE_VAL_NIL,
	CODING_STD_CCITT,
	CHAN_NUMBER,
	B_CHAN,
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* Congestion level (CONGEST_LEVEL) */

CONST   struct  i_congest_level	 df_ssdu_vn6_i_congest_level = {
	RECEIVER_READY
};

		/* Date/time (DATE_TIME) */

CONST   struct  i_date_time	 df_ssdu_vn6_i_date_time = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Display (DISPLAY) */

CONST   struct  i_display   df_ssdu_vn6_i_display = {
	BYTE_VAL_NIL,
	0,
	A_NIL
};

		/* facilities (FACILITY) */

CONST   struct  i_facility   df_ssdu_vn6_i_facility = {
	FAC_SUPPLEMENTARY,
	FAC_LGTH_FORMAT,

	{	FAC_CONTEXT_SPECIFIC,
		FAC_CONSTRUCTOR,
		FAC_INVOKE,
		14
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_INVOKE_ID_TAG,
		1,
		A_NIL
	},

	{	FAC_UNIVERSAL,
		FAC_PRIMITIVE,
		FAC_OP_VAL_TAG,
		FAC_OP_VAL_LGTH,
		OP_VAL_UUI
	},

	{	FAC_UNIVERSAL,
		FAC_CONSTRUCTOR,
		FAC_SEQUENCE_TAG,
		6
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_SERVICE_TAG,
		FAC_SERVICE_LGTH,
		SERVICE_1
	},

	{	FAC_CONTEXT_SPECIFIC,
		FAC_PRIMITIVE,
		FAC_PREF_TAG,
		FAC_PREF_LGTH,
		PREFERRED_TRUE
	},

};

		/* High layer compatibility (HLC) */

CONST   struct  i_hlc   df_ssdu_vn6_i_hlc = {
	CODING_STD_CCITT,
	INTER_CCITT_CEPT,
	PRESENTATION_PROFIL,
	TELEPHONY,
	BYTE_VAL_NIL
};

		/* Keypad facility (KEYPAD) */

CONST   struct  i_keypad	df_ssdu_vn6_i_keypad = {
	0,
	A_NIL
};

		/* Low layer compatibility (LLC) */

CONST   struct  i_llc   df_ssdu_vn6_i_llc = {
	CODING_STD_CCITT,
	TRF_CAP_UNRESTRICTED,
	OUT_BAND_NOT_POSSIBLE,
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	STRUCTURE_DEFAULT,
	CONFIG_POINT_TO_POINT,
	EST_DEMAND,
	BIDIRECTIONAL_SYMMETRY,
	TRF_RATE_64KBS,
	LAYER_ID_1,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_2,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	LAYER_ID_3,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL
};

		/* Notification indicator (NOTIF_IND) */

CONST   struct  i_notif_ind	 df_ssdu_vn6_i_notif_ind = {
	USER_SUSPENDED,
	0,
	P_NIL

};

		/* Progress indicator (PROGRESS_IND) */

CONST   struct  i_progress_ind  df_ssdu_vn6_i_progress_ind = {
	CODING_STD_CCITT,
	PROGRESS_LOC_USER,
	PROGRESS_DESCR_NON_END_TO_END_ISDN
};

		/* User to user facility (USER_FAC) */

CONST	struct i_user_fac df_ssdu_vn6_i_user_fac = {
	PROTOCOL_DISCR_MESSAGING,
	0,
	A_NIL,
};

		/* Restart indicator (RESTART_IND) */

CONST   struct  i_restart_ind   df_ssdu_vn6_i_restart_ind = {
	RI_ALL_INTERFACES
};

		/*  Signal (SIGNAL) */

CONST   struct  i_signal	df_ssdu_vn6_i_signal = {
	DIAL_ON
};

#if NS_SPF_FACILITY == ON

		/* Network specific facilities (SPF_FAC) */

CONST   struct  i_spf_fac   df_ssdu_vn6_i_spf_fac = {
	0,
	USER_SPECIFIED_TYPE,
	UNKNOWN_PLAN,
};

#endif

		/* User mode working (USER_MODE) */

CONST	struct i_user_mode df_ssdu_vn6_i_user_mode = {
	CODING_STD_NATIONAL,
	NATIONAL_FUNCTIONAL_MODE,
};

		/* Transit network selection (TRANSIT_NET_SEL) */

CONST   struct  i_transit_net_sel   df_ssdu_vn6_i_transit_net_sel = {
	USER_SPECIFIED_TYPE,
	UNKNOWN_PLAN,
	0,
	A_NIL
};

		/* User to user information (UUI) */

CONST   struct  i_uui   df_ssdu_vn6_i_uui = {
	PROTOCOL_DISCR_IA5,
	0,
	A_NIL
};

		/* User to PCS information (USER_PCS) */

CONST   struct  i_user_pcs   df_ssdu_vn6_i_user_pcs = {
	PROTOCOL_DISCR_TRANSGROUP,
	0,
	A_NIL
};

		/* PCS to USER information (PCS_USER) */

CONST   struct  i_pcs_user   df_ssdu_vn6_i_pcs_user = {
	PROTOCOL_DISCR_TRANSGROUP,
	0,
	A_NIL
};

		/* Redirecting number (REDIR_NB) */

CONST	struct  i_redir_nb	df_ssdu_vn6_i_redir_nb = {
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	BYTE_VAL_NIL,
	0,
	A_NIL
};


/*-------------------------------------------------------------------------

		Initialization constants for packet communications IEs
					( NOT IMPLEMENTED )

-------------------------------------------------------------------------*

		Information rate (INF_RATE)

CONST   struct  i_inf_rate  df_ssdu_vn6_i_inf_rate = {
	BYTE_VAL_NIL
};

		End-to-end transit delay (E_T_E_TRANSIT_DLY)

CONST   struct  i_e_t_e_transit_dly	 df_ssdu_vn6_i_e_t_e_transit_dly = {
	BYTE_VAL_NIL
};

		Transit delay selection and indication (TRANSIT_DLY_SEL)

CONST   struct  i_transit_dly_sel   df_ssdu_vn6_i_transit_dly_sel = {
	BYTE_VAL_NIL
};

		Packet layer binary parameters (PACKET_LBP)

CONST   struct  i_packet_lbp	df_ssdu_vn6_i_packet_lbp = {
	BYTE_VAL_NIL
};

		Packet layer window size (PACKET_LWS)

CONST   struct  i_packet_lws	df_ssdu_vn6_i_packet_lws = {
	BYTE_VAL_NIL
};

		Packet size (PACKET_SIZE)

CONST   struct  i_packet_size   df_ssdu_vn6_i_packet_size = {
	BYTE_VAL_NIL
};

*=========================================================================*/

				/*-------------------------------*/
				/* TABLES : list of valid values */
				/*-------------------------------*/

					/* Charging type */

CONST	uchar VN6_CHARGING_TYPE_S[] = {
	FREE_OF_CHARGE,
	CHARGE_ON_DURATION,
	CHARGE_ON_ANSWER,
	CHARGE_INCREMENT,
	SUB_TOTAL_CHARGE,
};

					/* Charging period */

CONST	uchar VN6_CHARGING_PERIOD_S[] = {
	CHARGING_PERIOD_0_1_S,
	CHARGING_PERIOD_1_S,
	CHARGING_PERIOD_10_S,
	CHARGING_PERIOD_60_S,
};

					/* Assignor/Assignee (ie LLC) */

CONST	uchar VN6_ASSIGN_S[] = {
	DEFAULT_ASSIGNEE,
	ASSIGNOR_ONLY,
	};

					/* In-band/Out_band negotiation (ie LLC) */

CONST	uchar VN6_BAND_S[] = {
	TSC,
	LL0,
	};

					/* Automata call state values (ie CALL_STATE) */

CONST	uchar VN6_CALL_STATE_VAL_S[] = {
	STATE_NULL_0,
	STATE_CALL_INIT_1,
	STATE_OVERLAP_SENDING_2,
	STATE_OUTGOING_CALL_PROC_3,
	STATE_CALL_DELIVERED_4,
	STATE_CALL_PRESENT_6,
	STATE_CALL_RECEIVED_7,
	STATE_CONNECT_REQUEST_8,
	STATE_INCOMING_CALL_PROC_9,
	STATE_ACTIVE_10,
	STATE_DISCONNECT_REQUEST_11,
	STATE_DISCONNECT_INDICATION_12,
	STATE_SUSPEND_REQUEST_15,
	STATE_RESUME_REQUEST_17,
	STATE_RELEASE_REQUEST_19,
#   if EQUIPMENT == NT2
	STATE_CALL_ABORT_22,
#   endif
	STATE_OVERLAP_RECEIVING_25,
	STATE_REST_1,
	STATE_REST_2,
	};

					/* Numbering type (ie CALLED_NB) */

CONST	uchar VN6_CALLED_NB_TYPE_S[] = {
	NB_UNKNOWN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
	NB_NET_SPF,
	NB_SUBSCRIBER,
	NB_ABBREVIATED,
	NB_EXTENSION,
	OVERLAP_SENDING,
	};

					/* Numbering plan (ie CALLED_NB) */

CONST	uchar VN6_CALLED_NB_PLAN_S[] = {
	PLAN_UNKNOWN,
	PLAN_ISDN,
	PLAN_DATA,
	PLAN_TELEX,
	PLAN_NATIONAL,
	PLAN_PRIVATE,
	PLAN_RESERVED,
	};

					/* Numbering type (ie CALLING_NB) */

CONST	uchar VN6_CALLING_NB_TYPE_S[] = {
	NB_UNKNOWN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
	NB_NET_SPF,
	NB_SUBSCRIBER,
	NB_EXTENSION,
	};

					/* Numbering plan (ie CALLING_NB) */

CONST	uchar VN6_CALLING_NB_PLAN_S[] = {
	PLAN_UNKNOWN,
	PLAN_ISDN,
	PLAN_DATA,
	PLAN_TELEX,
	PLAN_NATIONAL,
	PLAN_PRIVATE,
	PLAN_RESERVED,
	};

					/* Numbering plan (ie REDIR_NB) */

CONST	uchar VN6_REDIR_NB_PLAN_S[] = {
	PLAN_ISDN,
	PLAN_PRIVATE,
	PLAN_UNKNOWN
	};

					/* Numbering type (ie REDIR_NB) */

CONST	uchar VN6_REDIR_NB_TYPE_S[] = {
	NB_UNKNOWN,
	NB_INTERNATIONAL,
	NB_NATIONAL,
	NB_NET_SPF,
	NB_SUBSCRIBER,
	};


					/* Calling presentation indicator (ie CALLING_NB) */

CONST	uchar VN6_CALLING_NB_PRES_S[] = {
	PRES_ALLOWED,
	PRES_RESTRICTED,
	PRES_NOT_AVAILABLE,
	PRES_RESERVED,
	};

					/* Channel number (ie CAUSE) */

CONST	uchar VN6_CHAN_NUMBER_S[] = {
	1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
	};

					/* Channel type (ie CHAN_ID) */

CONST	uchar VN6_CHAN_TYPE_S[] = {
	B_CHAN,
	H0_CHAN,
	H11_CHAN,
	H12_CHAN,
	};

					/* Preferred/exclusive (ie CHAN_ID) */

CONST	uchar VN6_CHAN_PREF_EXCL_S[] = {
	CHAN_PREF,
	CHAN_EXCL,
	};

					/* Coding standard (ie BC, CALL_STATE, CAUSE, CHAN_ID, LLC, PROGRESS_IND) */

CONST	uchar VN6_CODING_STD_S[] = {
	CODING_STD_CCITT,
	CODING_STD_RESERVED,
	CODING_STD_NATIONAL,
	CODING_STD_SPF,
	};

					/* Congestion level (ie CONGEST_LEVEL) */

CONST	uchar VN6_CONGEST_LEVEL_S[] = {
	RECEIVER_READY,
	RECEIVER_NOT_READY,
	};

					/* D-channel indicator (ie CHAN_ID) */

CONST	uchar VN6_D_CHAN_S[] = {
	D_CHAN,
	NOT_D_CHAN,
	};

					/* Data bit format (ie BC & LLC) */

CONST	uchar VN6_DATA_BIT_S[] = {
	DATA_BIT_UNUSED,
	DATA_BIT_5,
	DATA_BIT_7,
	DATA_BIT_8,
	};

					/* Duplex/half-duplex (ie BC & LLC) */

CONST	uchar VN6_DUPLEX_S[] = {
	HALF_DUPLEX,
	FULL_DUPLEX,
	};

					/* Flow control on Reception (Rx) (ie BC & LLC) */

CONST	uchar VN6_FLOW_CONTROL_RX_S[] = {
	FLOW_CAN_ACCEPT_DATA,
	FLOW_CANNOT_ACCEPT_DATA,
	};

					/* Flow control on Transmission (Tx) (ie BC & LLC) */

CONST	uchar VN6_FLOW_CONTROL_TX_S[] = {
	FLOW_NOT_RQ_TX_DATA,
	FLOW_RQ_TX_DATA,
	};

					/* Rate adaption header/no header (ie LLC) */

CONST	uchar VN6_HEADER_S[] = {
	HEADER_NOT_INCLUDED,
	HEADER_INCLUDED,
	};

					/* Interface type (ie CHAN_ID) */

CONST	uchar VN6_INT_TYPE_S[] = {
	INT_TYPE_BRI,
	INT_TYPE_PRI,
	};

					/* Intermediate rate (V110) (ie BC & LLC) */

CONST	uchar VN6_INTER_RATE_S[] = {
	INTER_RA_UNUSED,
	INTER_RA_8KBS,
	INTER_RA_16KBS,
	INTER_RA_32KBS,
	};

					/* Interpretation (ie HLC) (not used - further study) */

CONST	uchar VN6_INTERPRETATION_S[] = {
	INTER_CCITT_CEPT,
	INTER_NATIONAL,
	};

					/* Layer identifier (ie CAUSE, for BC diagnostic) */

CONST	uchar VN6_LAYER_ID_S[] = {
	LAYER_ID_1,
	LAYER_ID_2,
	LAYER_ID_3,
	};

					/* Logical Link Identifier negotiation (ie LLC) */

CONST	uchar VN6_LLI_S[] = {
	DEFAULT_LLI,
	FULL_PROTOCOL_LLI,
	};

					/* Cause location (ie CAUSE) */

CONST	uchar VN6_LOCATION_S[] = {
	LOCATION_USER,
	LOCATION_PR_NET_LOC_USER,
	LOCATION_PU_NET_LOC_USER,
	LOCATION_TRANSIT_NET,
	LOCATION_PU_NET_REMOTE_USER,
	LOCATION_PR_NET_REMOTE_USER,
	LOCATION_INTERNATIONAL_NET,
	LOCATION_NET_NTWK_POINT,
	};

					/* Modem type (ie BC & LLC) */

CONST	uchar VN6_MODEM_S[] = {
	MODEM_RESERVED,
	MODEM_V21,
	MODEM_V22,
	MODEM_V22_BIS,
	MODEM_V23,
	MODEM_V26,
	MODEM_V26_BIS,
	MODEM_V26_TER,
	MODEM_V27,
	MODEM_V27_BIS,
	MODEM_V27_TER,
	MODEM_V29,
	MODEM_V32,
	MODEM_V35,
	};

					/* message type (ie CAUSE) */

CONST	uchar VN6_MSG_TYPE_S[] = {
	ALERT,
	CALL_PROC,
	CONN,
	CONN_ACK,
	PROGRESS,
	SETUP,
	SETUP_ACK,
	RESTART,
	RESTART_ACK,
	RES,
	RES_ACK,
	RES_REJ,
	SUSP,
	SUSP_ACK,
	SUSP_REJ,
	USER_INFO,
	DISC,
	REL,
	REL_COMP,
	SEGMENT,
	CON_CON,
	INFO,
	FAC,
	NOTIFY,
	STATUS,
	STATUS_ENQ,
	};

					/* Multi frame establishment support in Data Link (ie LLC) */

CONST	uchar VN6_MULTI_FRAME_S[] = {
	MULTI_FRAME_NOT_SUPPORTED,
	MULTI_FRAME_SUPPORTED,
	};

					/* In-band negotiation (V110 or V120) (ie BC & LLC) */

CONST	uchar VN6_NEGOTIATION_S[] = {
	NEGOTIATION_IN_BAND,
	NEGOTIATION_NOT_IN_BAND,
	};

						/* network identification plan (ie TRANSIT_NET_SEL & SPF_FAC) */

CONST	uchar VN6_NET_ID_PLAN_S[] = {
	UNKNOWN_PLAN,
	CARRIER_ID_CODE,
	DATA_NETWORK_ID_CODE,
	};

						/* type of network identification (ie TRANSIT_NET_SEL & SPF_FAC) */

CONST	uchar VN6_NET_ID_TYPE_S[] = {
	USER_SPECIFIED_TYPE,
	NATIONAL_NETWORK_ID_TYPE,
	INTERNATIONAL_NETWORK_ID_TYPE,
	};

					/* Network independent clock (NIC) (ie BC & LLC) */

CONST	uchar VN6_NIC_RX_S[] = {
	NIC_ACCEPT_DATA,
	NIC_NOT_ACCEPT_DATA,
	};

					/* Network independent clock (NIC) (ie BC & LLC) */

CONST	uchar VN6_NIC_TX_S[] = {
	NIC_RQ_TX_DATA,
	NIC_NOT_RQ_TX_DATA,
	};

					/* Notification indicator description (ie NOTIF_IND) */

CONST	uchar VN6_NOTIF_IND_DESCR_S[] = {
	USER_SUSPENDED,
	USER_RESUMED,
	};

					/* Mode of operation (ie LLC) */

CONST	uchar VN6_OP_MODE_S[] = {
	BIT_TRANSPARENT,
	PROTOCOL_SENSITIVE,
	};

					/* Out-band negotiation indicator (ie LLC) */

CONST	uchar VN6_OUT_BAND_NEG_S[] =	{
	OUT_BAND_POSSIBLE,
	OUT_BAND_NOT_POSSIBLE,
	};

					/* Parity format (ie BC & LLC) */

CONST	uchar VN6_PARITY_S[] = {
	ODD,
	EVEN,
	NO_PARITY,
	FORCED_TO_0,
	FORCED_TO_1,
	};

					/* Progress description (ie PROGRESS_IND) */

CONST	uchar VN6_PROGRESS_DESCRIPTION_S[] = {
	PROGRESS_DESCR_NON_END_TO_END_ISDN,
	PROGRESS_DESCR_NON_ISDN_DEST,
	PROGRESS_DESCR_NON_ISDN_ORIG,
	PROGRESS_DESCR_CALL_RETURNED_ISDN,
	PROGRESS_DESCR_IN_BAND_NOW,
	};

					/* Progress location (ie PROGRESS_IND) */

CONST	uchar VN6_PROGRESS_LOCATION_S[] = {
	PROGRESS_LOC_USER,
	PROGRESS_LOC_PR_LOCAL_USER,
	PROGRESS_LOC_PU_LOCAL_USER,
	PROGRESS_LOC_PU_REMOTE_USER,
	PROGRESS_LOC_PR_REMOTE_USER,
	PROGRESS_LOC_INTERNATIONAL,
	PROGRESS_BEYONG_IWP,
	};

					/* Layer 1 protocol identifier (ie LLC) */

CONST	uchar VN6_PROTOCOL_ID_LLC_1_S[] = {
	PROTOCOL_ID_1_V110,
	PROTOCOL_ID_1_G711_u,
	PROTOCOL_ID_1_G711_A,
	PROTOCOL_ID_1_G721,
	PROTOCOL_ID_1_7KHZ,
	PROTOCOL_ID_1_VIDEO,
	PROTOCOL_ID_1_RA_NON_CCITT,
	PROTOCOL_ID_1_V120,
	PROTOCOL_ID_1_X31,
	};

					/* Layer 2 protocol identifier (ie LLC) */

CONST	uchar VN6_PROTOCOL_ID_LLC_2_S[] = {
	PROTOCOL_ID_2_ISO_1745,
	PROTOCOL_ID_2_Q921,
	PROTOCOL_ID_2_X25_LL,
	PROTOCOL_ID_2_X25_ML,
	PROTOCOL_ID_2_T71,
	PROTOCOL_ID_2_HDLC_ARM,
	PROTOCOL_ID_2_HDLC_NRM,
	PROTOCOL_ID_2_HDLC_ABM,
	PROTOCOL_ID_2_LAN_LLC,
	PROTOCOL_ID_2_X75_SLP,
	};

					/* Layer 3 protocol identifier (ie LLC)*/

CONST	uchar VN6_PROTOCOL_ID_LLC_3_S[] = {
	PROTOCOL_ID_3_Q931,
	PROTOCOL_ID_3_X25_PL,
	PROTOCOL_ID_3_ISO_8208,
	PROTOCOL_ID_3_ISO_8348,
	PROTOCOL_ID_3_ISO_8473,
	PROTOCOL_ID_3_T70,
	};

					/* Cause recommandation (ie CAUSE) */

CONST	uchar VN6_RECOMMENDATION_S[] = {
	RECOMMENDATION_Q931,
	RECOMMENDATION_X21,
	RECOMMENDATION_X25,
	};

					/* Reason for redirection (ie REDIR_NB) */

CONST	uchar VN6_REASON_REDIR_S[] = {
	R_UNKNOWN,
	R_CALL_FORWARDING_BUSY,
	R_CALL_FORWARDING_NO_REPLY,
	R_CALL_FORWARDING_BY_CALLED,
	R_CALL_FORWARDING_UNCONDITIONAL,
	};

					/* Restart indicator class (ie RESTART_IND) */

CONST	uchar VN6_RESTART_IND_CLASS_S[] = {
	RI_INDICATED_CHANNEL,
	RI_SINGLE_INTERFACE,
	RI_ALL_INTERFACES,
	};

					/* Screening indicator (ie CALLING_NB) */

CONST	uchar VN6_SCREEN_IND_S[] = {
	USER_PROVIDED,
	USER_PASSED,
	NETWORK_PROVIDED,
	};

					/* Signal values (ie SIGNAL) */

CONST	uchar VN6_SIGNAL_VAL_S[] = {
	DIAL_ON,
	RING_BACK_ON,
	INTERCEPT_ON,
	NET_CONGEST_ON,
	BUSY_ON,
	CONFIRM_ON,
	ANSWER_ON,
	CALL_WAITING_ON,
	OFF_HOOK_WARNING_ON,
	TONES_OFF,
	PATTERN_0,
	PATTERN_1,
	PATTERN_2,
	PATTERN_3,
	PATTERN_4,
	PATTERN_5,
	PATTERN_6,
	PATTERN_7,
	ALERTING_OFF,
	};

					/* Status/condition (ie CAUSE) */

CONST	uchar VN6_STATUS_CONDITION_S[] = {
	COND_UNKNOWN,
	COND_PERMANENT,
	COND_TRANSIENT,
	};

					/* Stop bit format (ie BC & LLC) */

CONST	uchar VN6_STOP_BIT_S[] = {
	STOP_BIT_UNUSED,
	STOP_BIT_1,
	STOP_BIT_1_5,
	STOP_BIT_2,
	};

					/* Information structure (ie BC & LLC) */

CONST	uchar VN6_STRUCTURE_S[] = {
	STRUCTURE_DEFAULT,
	STRUCTURE_8KHZ_INT,
	STRUCTURE_SDU_INT,
	STRUCTURE_UNSTRUCTURED,
	};

					/* Subaddress odd/even indicator (ie CALLED & CALLING _SUB_ADD) */

CONST	uchar VN6_SUB_ADD_IND_S[] = {
	SUB_ADD_ODD,
	SUB_ADD_EVEN,
	};

					/* Subaddress type (ie CALLED & CALLING _SUB_ADD) */

CONST	uchar VN6_SUB_ADD_TYPE_S[] = {
	SUB_ADD_OSI,
	SUB_ADD_USER,
	};

					/* Asynchronous/synchronous (ie BC & LLC) */

CONST	uchar VN6_SYN_ASYN_S[] =	{
	SYN,
	ASYN,
	};

					/* Teleservices according to CCITT standard (ie HLC) */

CONST	uchar VN6_TELESERVICE_CCITT_S[] = {
	TELEPHONY,
	FAX_3,
	FAX_4,
	MIXED_MODE,
	PROCESSABLE_FORM,
	TELETEX,
	VIDEOTEX,
	TELEX,
	MHS,
	OSI,
	MAINTENANCE,		/* = HLC_NOT_AVAILABLE_1 */
	MANAGEMENT,			/* = HLC_NOT_AVAILABLE_2 */
	HLC_RESERVED,
	};


					/* Information transfer capability (ie BC) */

CONST	uchar VN6_TRF_CAP_BC_S []  ={
	TRF_CAP_SPEECH,
	TRF_CAP_UNRESTRICTED,
	TRF_CAP_RESTRICTED,
	TRF_CAP_3_1_AUDIO,
	TRF_CAP_7_AUDIO,
	TRF_CAP_VIDEO,
	};

					/* Information transfer capability (ie LLC) */

CONST	uchar VN6_TRF_CAP_LLC_S []  ={
	TRF_CAP_SPEECH,
	TRF_CAP_UNRESTRICTED,
	TRF_CAP_RESTRICTED,
	TRF_CAP_3_1_AUDIO,
	TRF_CAP_7_AUDIO,
	TRF_CAP_VIDEO,
	};

					/* Information transfer mode (ie BC & LLC) */

CONST	uchar VN6_TRF_MODE_S[] = {
	TRF_MODE_CIRCUIT,
	TRF_MODE_PACKET,
	};

					/* User rate (V110 & V120) (ie BC & LLC) */

CONST	uchar VN6_USER_RATE_S[] =   {
	RA_E_BITS,
	RA_0_6KBS,
	RA_1_2KBS,
	RA_2_4KBS,
	RA_3_6KBS,
	RA_4_8KBS,
	RA_7_2KBS,
	RA_8KBS,
	RA_9_6KBS,
	RA_14_4KBS,
	RA_16KBS,
	RA_19_2KBS,
	RA_32KBS,
	RA_48KBS,
	RA_56KBS,
	RA_64KBS,
	RA_0_1345KBS,
	RA_0_100KBS,
	RA_0_75_1_2KBS,
	RA_1_2_0_75KBS,
	RA_0_050KBS,
	RA_0_075KBS,
	RA_0_110KBS,
	RA_0_150KBS,
	RA_0_200KBS,
	RA_0_300KBS,
	RA_12KBS,
	};

				/* User protocol discriminator */

CONST	uchar VN6_USER_PROTOCOL_DISCR_S[] = {
	PROTOCOL_DISCR_NT2,
	PROTOCOL_DISCR_MESSAGING,
	PROTOCOL_DISCR_TRANSGROUP,
};

				/* User protocol discriminator for USER/PCS */

CONST	uchar VN6_USER_PCS_PROTOCOL_DISCR_S[] = {
	PROTOCOL_DISCR_TRANSGROUP,
	PROTOCOL_DISCR_PUBLIPHONE,
	PROTOCOL_DISCR_CALL_ROUTING,
};

				/* User to user information protocol discriminator (ie UUI) */

CONST	uchar VN6_UUI_PROTOCOL_DISCR_S[] = {
	PROTOCOL_DISCR_USER_SPF,
	PROTOCOL_DISCR_OSI,
	PROTOCOL_DISCR_X244,
	PROTOCOL_DISCR_SYSTEM_MANAGEMENT,
	PROTOCOL_DISCR_IA5,
	PROTOCOL_DISCR_V120,
	PROTOCOL_DISCR_Q931,
	};

		/* Network specific facility action */

CONST	uchar VN6_SPF_FAC_ACTION_S[] = {
	FT_SPF_FAC_RQ_ACTIVATE,
	FT_SPF_FAC_RQ_CLEAR,
	FT_SPF_FAC_RQ_ENQUIRY,
};

		/* Network specific facility code */

CONST	uchar VN6_SPF_FAC_CODE_S[] = {
	FT_SPF_FAC_CALL_FORWARDING,
	FT_SPF_FAC_CALL_DEFLECTION,
	FT_SPF_FAC_CHARGING,
	FT_SPF_FAC_CHARGING_TOTAL,
	FT_SPF_FAC_HOLD,
	FT_SPF_FAC_RETRIEVE,
	FT_SPF_FAC_ALTERNATE,
	FT_SPF_FAC_TRF,
	FT_SPF_FAC_THREE_PARTY,
	FT_SPF_FAC_IDENTIFICATION_DENIED,
	FT_SPF_FAC_MALICIOUS_CALL_ID,
	FT_SPF_FAC_SUP_SERV_INVOKE_CHARGING
};

/*=========================================================================*/

	/* Tables selected according to another value (indexed tables) */

					/* Channel selection according to interface type (ie CHAN_ID) */

CONST	uchar VN6_CHAN_SEL_BRI_S[] = {
			INT_TYPE_BRI,
			NO_CHAN,
			B1_CHAN,
			B2_CHAN,
			ANY_CHAN,
			};

CONST	uchar VN6_CHAN_SEL_PRI_S[] = {
			INT_TYPE_PRI,
			NO_CHAN,
			AS_INDICATED,
			CHAN_RESERVED,
			ANY_CHAN,
			};

					/* Information transfer rate (ie BC & LLC) according to transfer mode */

CONST	uchar VN6_TRF_RATE_CIRCUIT_S[] = {
	TRF_MODE_CIRCUIT,
	TRF_RATE_64KBS,
	TRF_RATE_2x64KBS,
	TRF_RATE_384KBS,
	TRF_RATE_1536KBS,
	TRF_RATE_1920KBS,
	};

CONST	uchar VN6_TRF_RATE_PACKET_S[] = {
	TRF_MODE_PACKET,
	TRF_RATE_PACKET_MODE,
	};

					/* Layer 1 protocol identifier (ie BC) */

CONST	uchar VN6_PROTOCOL_ID_BC_1_S[] = {
	LAYER_ID_1,
	PROTOCOL_ID_1_V110,
	PROTOCOL_ID_1_G711_A,
	PROTOCOL_ID_1_G721,
	PROTOCOL_ID_1_7KHZ,
	PROTOCOL_ID_1_VIDEO,
	PROTOCOL_ID_1_RA_NON_CCITT,
	PROTOCOL_ID_1_X31,
	};

					/* Layer 2 protocol identifier (ie BC) */

CONST	uchar VN6_PROTOCOL_ID_BC_2_S[] = {
	LAYER_ID_2,
	PROTOCOL_ID_2_Q921,
	PROTOCOL_ID_2_X25_LL,
	};

					/* Layer 3 protocol identifier (ie BC) */

CONST	uchar VN6_PROTOCOL_ID_BC_3_S[] = {
	LAYER_ID_3,
	PROTOCOL_ID_3_Q931,
	PROTOCOL_ID_3_X25_PL,
	};

/*-------------------------------------------------------------------------*/

		/*
		   Meta description of the information elements.
		   This description is  used to check an information element
		   inside a message and to store its value into  the internal
		   structure.
		   In the other way it is used to generate the information element of
		   a message from the internal structure.
		*/

#define NS_INCLUDE_IE_META_FUNCTION		ON		/* include prototypes of functions inside mp_ie.vn6 */

#include "vn6.mp_ie"  /* include IE meta-programs */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name        	vn6_bc_teleservice_compatibility -
				BC/Teleservice Compatibility checking function : checks if
				the BC Transfer Capability value may be compatible with
				the Teleservice (HLC) value.

Usage			uchar vn6_bc_teleservice_compatibility ();

Return value :  OK  if the BC may be compatible with the Teleservice.
				NOK if the BC and the Teleservice are actually NOT compatible.

Common constants and declarations : ns.h net_i_s.h

Common objects : 'i_bc' and 'i_hlc' internal data structures;
				 'bc_teleservice_compatibility' global var updated with
				 return value.

*--------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	uchar vn6_bc_teleservice_compatibility (void);
#else
	uchar vn6_bc_teleservice_compatibility ();
#endif

uchar vn6_bc_teleservice_compatibility ()
{

		/* no compatibility checking may be made at this point if it is a specific non-CCITT HLC */

	if (i_hlc[0].coding_std != CODING_STD_CCITT) {

    	return (OK);
	}

	switch (i_bc[0].trf_cap) {

		case TRF_CAP_UNRESTRICTED :
		case TRF_CAP_7_AUDIO   :
		case TRF_CAP_VIDEO     :

			switch (i_hlc[0].teleservice) {

				case TELEPHONY :
				case FAX_3     :
					bc_teleservice_compatibility = NOK;
					break;
			}

			break;

		case TRF_CAP_SPEECH :

			switch (i_hlc[0].teleservice) {

				case TELEPHONY :
				case NON_NORMALISE :
				case INTERWORKING :
					break;

				default :
					bc_teleservice_compatibility = NOK;
					break;

			}

			break;

		case TRF_CAP_3_1_AUDIO :

			switch (i_hlc[0].teleservice) {

				case TELEPHONY :
				case FAX_3     :
				case NON_NORMALISE :
					break;

				default :
					bc_teleservice_compatibility = NOK;
					break;

			}

			break;

	}

	return (bc_teleservice_compatibility);
}

/*-------------------------------------------------------------------------*/

uchar vn6_calling_nb_spdu ()
{

		/* if default values are used for octet 3a, it shall be omitted. */

	ie_if_flag = ON;		/* in general case, process octet 3a */

	if ((direction == TO_D_CHANNEL) &&
		(I_calling_nb_presentation == PRES_ALLOWED) &&
		(I_calling_nb_screen_ind   == USER_PROVIDED)
	   ) {
		ie_if_flag = OFF;	/* default values used : omit octet 3a */
	}

	return (OK);
}
/*-------------------------------------------------------------------------*/

uchar vn6_facility_dcod_spdu ()
{

	switch (Na_country) {

			/*
			 * List here the country which have different
			 * facility IE descriptions.
			 * For each of them, invoke the right decoding function.
			 */

		case EUROPE :
		default :

			if (direction == FROM_D_CHANNEL) {

				return (r_exec_spdu_ie ((uchar *)&VN6_DF_FACILITY_P));

			} else {

				return (s_exec_spdu_ie ((uchar *)&VN6_DF_FACILITY_P));
			}

	}

}

#if NS_SPF_FACILITY == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		vn6_spf_fac_spdu - implements the processing of the specific facility
						  IE (received or to be sent in a SPDU message).

Usage	  		uchar vn6_spf_fac_spdu ();

Return value :  vn6_spf_fac_spdu returns = OK   valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar vn6_spf_fac_spdu ()
{

	if (direction == TO_D_CHANNEL) {

		if (check_convert (	(uchar FAR *) Get_p_ie,
							I_spf_fac_a_net_id,
							I_spf_fac_net_id_lgth,
							IA5, ANY_CHAR
						  ) != OK ) return (NOK);
	} else {

		if (check_convert (	I_spf_fac_a_net_id,
							(uchar FAR *) Get_p_ie,
							I_spf_fac_net_id_lgth,
							IA5, ANY_CHAR
						  ) != OK ) return (NOK);
	}

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn6_get_spf_fac_spdu -

Usage           uchar vn6_get_spf_fac_spdu ();

Return value : 	vn6_get_spf_fac_spdu returns = OK	valid data,
								= NOK   invalid data if fatal error.

common constants and declarations :	isdn.h

*--------------------------------------------------------------------------*/

uchar vn6_get_spf_fac_spdu ()
{

	uchar 		n;			/* facility code */
	uchar 		i;			/* loop index */
	long		x;			/* temporary variable */


#	if EQUIPMENT == NT2

		if (Na_fct == FG_NT_TE) return (vn6_get_spf_fac_spdu_net ());

#	endif

	if (direction == FROM_D_CHANNEL) {

					/* FROM D CHANNEL side */

			/*
				Structure of the specification field :
					service code*bloc[#]
			*/

			/* Decode service code */

				/* First decimal digit */

		if ((Get_ie_octet < D_0) || (Get_ie_octet > D_9)) {
			return (NOK);
		}

		n = (Get_ie_octet - D_0) * 10;

				/* Next decimal digit */

		if ((Inc_get_ie_octet < D_0) || (Get_ie_octet > D_9)) {
			return (NOK);
		}

		I_(spf_fac, code) = (n += (Get_ie_octet - D_0)); /* binary code in the internal data structure */

		if (Inc_get_ie_octet == START_OF_BLOCK) {

			Inc_p_ie(1);

			switch (n) {

					/* Call forwarding with called number or nothing */

				case FT_SPF_FAC_CALL_FORWARDING :
					I_spf_fac_info_lgth = (uchar)(Remainder_ie_octet - 1);

					if (Get_ie_octet != END_OF_SPECIFICATION) {

						if (check_convert ((uchar FAR *)p_ind_buffer,
										   Get_p_ie,
										   I_spf_fac_info_lgth,
										   IA5,
										   DIGIT) == NOK) {
							return (NOK);


						} else {

							I_spf_fac_p_fac	= p_ind_buffer;
							p_ind_buffer			+= I_spf_fac_info_lgth + 1;
							Inc_p_ie (I_spf_fac_info_lgth);
							if (Get_inc_ie_octet != END_OF_SPECIFICATION) return (NOK);
						}

					} else {
						Inc_p_ie (1);	/* to skip the END_OF_SPECIFICATION byte */
					}

					break;

						/* Teletax */

				case FT_SPF_FAC_CHARGING :
				case FT_SPF_FAC_CHARGING_TOTAL :
				case FT_SPF_FAC_SUP_SERV_INVOKE_CHARGING :
					I_spf_fac_tax = Get_inc_ie_octet;

					for (i = 0, x = 1; i < (uchar)CHARGING_LGTH - 1; i++) {
						x = x << 8;
						I_spf_fac_tax += x * Get_inc_ie_octet;
					}

					break;

				case FT_SPF_FAC_THREE_PARTY :
					break;

				default :
					return (NOK);

			}

		} else {

			if (Get_inc_ie_octet != END_OF_SPECIFICATION) return (NOK);
		}


			/* Check end of IE */

		if (!Eo_ie) return (NOK);

			/* Check if the facility is consistent with the SPDU ID ? */

		switch (spdu_id) {

				/* CALL PROCEEDING */

			case CALL_PROC :
				if (I_(spf_fac, code) != FT_SPF_FAC_CALL_FORWARDING) return (NOK);
				I_(spf_fac, action) = FT_SPF_FAC_IN_TX;
				break;

				/* DISCONNECT / RELEASE */

			case DISC :
			case REL :

				if ((I_(spf_fac, code) != FT_SPF_FAC_CHARGING_TOTAL) &&
					(I_(spf_fac, code) != FT_SPF_FAC_SUP_SERV_INVOKE_CHARGING)) {
						return (NOK);
				}

				I_(spf_fac, action) = FT_SPF_FAC_IN_TX;
				break;

				/* INFORMATION */

			case INFO :

				switch (I_(spf_fac, code)) {

					case FT_SPF_FAC_CHARGING :
					case FT_SPF_FAC_CHARGING_TOTAL :
						I_(spf_fac, action) = FT_SPF_FAC_IN_TX;
						break;

					case FT_SPF_FAC_THREE_PARTY :
						I_(spf_fac, action) = FT_SPF_FAC_CO_ACK;
						break;

					default :
						return (NOK);

				}
				break;

				/* REGISTRATION ACKNOWLEDGEMENT */

			case REG_ACK :
				if (I_(spf_fac, code) != FT_SPF_FAC_CALL_FORWARDING) return (NOK);
				I_(spf_fac, action) = FT_SPF_FAC_CO_ACK;
				break;

				/* REGISTRATION REJECT */

			case FT_REG_REJ :
				if (I_(spf_fac, code) != FT_SPF_FAC_CALL_FORWARDING) 	return (NOK);
				I_(spf_fac, action) = FT_SPF_FAC_CO_REJ;
				break;

				/* FACILITY ACKNOWLEDGEMENT */

			case FT_FAC_ACK :

				switch (I_(spf_fac, action)) {

					case FT_SPF_FAC_CALL_FORWARDING :
						I_(spf_fac, action) = FT_SPF_FAC_CO_ACK;
						break;

					default :
						return (NOK);

				}
				break;

				/* FACILITY REJECT */

			case FT_FAC_REJ :

				switch (I_(spf_fac, action)) {

					case FT_SPF_FAC_CALL_FORWARDING :
						I_(spf_fac, action) = FT_SPF_FAC_CO_REJ;
						break;

					default :
						return (NOK);

				}
				break;

		}

		Set_p_ie (p_ie_end);

	} else {

				/* TO D CHANNEL side */

		switch (I_(spf_fac, action)) {

			case FT_SPF_FAC_RQ_ACTIVATE :
				Put_inc_ie_octet (PREFIX_ACTIVATE);
				break;

			case FT_SPF_FAC_RQ_CLEAR :
				Put_inc_ie_octet (PREFIX_CLEAR);
				break;

			case FT_SPF_FAC_RQ_ENQUIRY :
				Put_inc_ie_octet (PREFIX_ENQUIRY_1);
				Put_inc_ie_octet (PREFIX_ENQUIRY_2);
				break;

		}

			/* Transfer the code : 2 decimal digit */

		Put_inc_ie_octet (D_0 + (I_(spf_fac, code) / 10));
		Put_inc_ie_octet (D_0 + (I_(spf_fac, code) % 10));


			/* Transfer the block (called number) if any */

		if (I_spf_fac_p_fac != P_NIL) {
			Put_inc_ie_octet (START_OF_BLOCK);

			if (check_convert (Get_p_ie,
							   (uchar FAR *)I_spf_fac_p_fac,
							   I_spf_fac_info_lgth,
							   IA5,
							   DIGIT
							  ) == NOK) {

#						if ASSERT == ON
							Error_intern ();
#						endif

			}

			Inc_p_ie (I_spf_fac_info_lgth);

		}
			/* Add end of specifications */

		Put_inc_ie_octet (END_OF_SPECIFICATION);

	}
			/* Return */

	return (OK);
}

#if EQUIPMENT == NT2

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn6_get_spf_fac_spdu_net -

Usage           uchar vn6_get_spf_fac_spdu_net ();

Return value : 	vn6_get_spf_fac_spdu_net returns = OK	valid data,
								= NOK   invalid data if fatal error.

common constants and declarations :	isdn.h

*--------------------------------------------------------------------------*/

uchar vn6_get_spf_fac_spdu_net ()
{

	uchar 		n;			/* facility code */

	if (direction == FROM_D_CHANNEL) {

					/* FROM D CHANNEL side */

			/*
				Structure of the specification field :
					Prefixe service_code*bloc[#]
			*/

			/* Check Prefixe code */

		if (Get_ie_octet == D_NUMBER) {
			I_(spf_fac, action) = FT_SPF_FAC_RQ_CLEAR;
			Inc_p_ie (1);

		} else {

			if (Get_ie_octet == D_STAR) {
				I_(spf_fac, action) = FT_SPF_FAC_RQ_ACTIVATE;
				Inc_p_ie (1);

				if (Get_ie_octet == D_NUMBER) {
					I_(spf_fac, action) = FT_SPF_FAC_RQ_ENQUIRY;
					Inc_p_ie (1);
				}
			}

		}

			/* Decode service code */

				/* First decimal digit */

		if ((Get_ie_octet < D_0) || (Get_ie_octet > D_9)) {
			return (NOK);
		}

		n = (Get_inc_ie_octet - D_0) * 10;

				/* Next decimal digit */

		if ((Get_ie_octet < D_0) || (Get_ie_octet > D_9)) {
			return (NOK);
		}

		I_(spf_fac, code) = (n += (Get_ie_octet - D_0)); /* binary code in the internal data structure */

		if (Inc_get_ie_octet == START_OF_BLOCK) {

			Inc_p_ie(1);

			switch (n) {

					/* Call forwarding with called number or nothing */

				case FT_SPF_FAC_CALL_FORWARDING :

					I_spf_fac_info_lgth = (uchar)(Remainder_ie_octet - 1);

					I_spf_fac_info_lgth = (uchar)(Remainder_ie_octet - 1);

					if (Get_ie_octet != END_OF_SPECIFICATION) {

						if (check_convert ((uchar FAR *)p_ind_buffer,
										   Get_p_ie,
										   I_spf_fac_info_lgth,
										   IA5,
										   DIGIT) == NOK) {
							return (NOK);

						} else {

							I_spf_fac_p_fac	= p_ind_buffer;
							p_ind_buffer			+= I_spf_fac_info_lgth + 1;
							Inc_p_ie (I_spf_fac_info_lgth);
							if (Get_inc_ie_octet != END_OF_SPECIFICATION) return (NOK);
						}

					} else {

						Inc_p_ie (1);	/* to skip the END_OF_SPECIFICATION byte */
					}

					break;

				case FT_SPF_FAC_THREE_PARTY 	:
				case FT_SPF_FAC_CALL_DEFLECTION	:
				case FT_SPF_FAC_CHARGING        :
				case FT_SPF_FAC_CHARGING_TOTAL  :
				case FT_SPF_FAC_HOLD            :
				case FT_SPF_FAC_RETRIEVE        :
				case FT_SPF_FAC_ALTERNATE       :
				case FT_SPF_FAC_TRF             :
				case FT_SPF_FAC_IDENTIFICATION_DENIED :
				case FT_SPF_FAC_MALICIOUS_CALL_ID     :
				case FT_SPF_FAC_SUP_SERV_INVOKE_CHARGING :

						Inc_p_ie (1);	/* to skip the END_OF_SPECIFICATION byte */

					break;


				default :
					return (NOK);

			}

		} else {

			if (Get_inc_ie_octet != END_OF_SPECIFICATION) return (NOK);
		}


			/* Check end of IE */

		if (!Eo_ie) return (NOK);

			/* Check if the facility is consistent with the SPDU ID ? */

		switch (spdu_id) {

				/* SETUP */

			case SETUP :

				switch (I_(spf_fac, code)) {

					case FT_SPF_FAC_CHARGING :
					case FT_SPF_FAC_IDENTIFICATION_DENIED :
						break;

					default :
						return (NOK);
				}

				break;

				/* RELEASE */

			case REL :
				if (I_(spf_fac, code) != FT_SPF_FAC_CALL_DEFLECTION) return (NOK);
				break;

				/* REGISTRATION */

			case REG :
				if (I_(spf_fac, code) != FT_SPF_FAC_CALL_FORWARDING) return (NOK);
				break;

			default :

				return (NOK);

		}




		Set_p_ie (p_ie_end);



	} else {


			/* Transfer the code : 2 decimal digit */

		Put_inc_ie_octet (D_0 + (I_(spf_fac, code) / 10));
		Put_inc_ie_octet (D_0 + (I_(spf_fac, code) % 10));

		switch (I_(spf_fac, code)) {

			case FT_SPF_FAC_CHARGING :
			case FT_SPF_FAC_CHARGING_TOTAL :
			case FT_SPF_FAC_SUP_SERV_INVOKE_CHARGING :
				*p_ie++ = START_OF_BLOCK;
				*p_ie++ = (uchar)(I_(spf_fac, tax) & Mask (8));
				*p_ie++ = (uchar)((I_(spf_fac, tax) >> 8) & Mask (8));
				*p_ie++ = (uchar)((I_(spf_fac, tax) >> 16)& Mask (8));
				return (OK);
		}


			/* Transfer the block (called number) if any */

		if (I_spf_fac_p_fac != P_NIL) {
			Put_inc_ie_octet (START_OF_BLOCK);


			if (check_convert (Get_p_ie,
					   (uchar FAR *)I_spf_fac_p_fac,
					   I_spf_fac_info_lgth,
					   IA5,
					   DIGIT
					  ) == NOK) {

#						if ASSERT == ON
					Error_intern ();
#						endif

			}

			Inc_p_ie (I_spf_fac_info_lgth);

		}
			/* Add end of specifications */

		Put_inc_ie_octet (END_OF_SPECIFICATION);

	}
			/* Return */

	return (OK);
}

#endif	/* Equipment == NT2 */

#endif	/* NS_SPF_FACILITY == ON */

uchar vn6_advice_of_charge_dcod_spdu ()
{

	switch (Na_country) {

			/*
			 * List here the country which have different
			 * facility IE descriptions.
			 * For each of them, invoke the right decoding function.
			 */

		case EUROPE :
		default :

			if (direction == FROM_D_CHANNEL) {

				return (r_exec_spdu_ie ((uchar FAR *)&VN6_DF_ADVICE_CHARGE_P));

			} else {

				return (s_exec_spdu_ie ((uchar FAR *)&VN6_DF_ADVICE_CHARGE_P));
			}
	}
}

uchar vn6_df_advice_ch_3a_b_spdu ()
{
	if (direction == FROM_D_CHANNEL) {

			/* test if octet 3B is present (test extension bit of octet 3a)
				and set 'ie_if_flag' variable to ON if so */

		if (Ext_0_1 == EXT_CONTINUE) {

			ie_if_flag = ON;

		} else {

			ie_if_flag = OFF;
		}

	} else {

			/* test if octet 3B is present (test Charging period multiplier)
				and set 'ie_if_flag' variable to ON if so */

		if (I_(advice_charge, charge_period_m) == BYTE_VAL_NIL) {

			ie_if_flag = OFF;

		} else {

			ie_if_flag = ON;
		}
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			bc_spdu - implements the processing of the Bearer
						   capability (BC) IE of a received SPDU
						   message and of a SPDU message to be sent.

Usage			uchar bc_spdu ();

Return value :  bc_spdu returns	= OK valid data,
								= NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar vn6_bc_4ab_spdu ()
{
	ie_if_flag = ON;	/* octets 4a and 4b may be present */

	if ((direction			== TO_D_CHANNEL)			&&
		(I_(bc,structure)	== STRUCTURE_DEFAULT)		&&
		(I_(bc,config)		== CONFIG_POINT_TO_POINT)	&&
		(I_(bc,est)			== EST_DEMAND)				&&
		(I_(bc,symmetry)	== BIDIRECTIONAL_SYMMETRY)	&&
		(I_(bc,dest_rate)	== I_(bc,trf_rate))) {

		/* default values for octets 4a and 4b : they are omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar vn6_bc_4b_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 4b may be present */

	if ((direction			== TO_D_CHANNEL)			&&
		(I_(bc,symmetry)	== BIDIRECTIONAL_SYMMETRY)	&&
		(I_(bc,dest_rate)	== I_(bc,trf_rate))) {

		/* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

#define Get_layer_id()	Extract (5,Mask(2))

uchar vn6_bc_5_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 5 may be present */

		/* if I_bc_layer_id_1 == BYTE_VAL_NIL -> octet 5 is missing */

	if (direction == TO_D_CHANNEL) {

		if (I_(bc,protocol_id_1) == BYTE_VAL_NIL) {

				/* octet 5 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_1) {

				/* It is NOT Octet 5 (layer 1) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar vn6_bc_6_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 6 may be present */

		/* if I_bc_layer_id_2 == BYTE_VAL_NIL -> octet 6 is missing */

	if (direction == TO_D_CHANNEL) {

		/* octet 6 must be present if PACKET MODE */

		if (I_(bc,protocol_id_2) == BYTE_VAL_NIL) {

			/* octet 6 is missing */

			if (I_(bc,trf_mode == TRF_MODE_PACKET)) return (NOK);

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_2) {

				/* It is NOT Octet 6 (layer 2) */

				/* octet 6 must be present if PACKET MODE */

			if (I_(bc,trf_mode == TRF_MODE_PACKET)) return (NOK);

			ie_if_flag = OFF;
		}

	}


	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar vn6_bc_7_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 7 may be present */

		/* if I_bc_layer_id_3 == BYTE_VAL_NIL -> octet 7 is missing */

	if (direction == TO_D_CHANNEL) {

		if (I_(bc,protocol_id_3) == BYTE_VAL_NIL) {

			/* octet 7 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_3) {

				/* It is NOT Octet 7 (layer 3) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			vn6_cause_spdu - implements the specific processing of a cause
							 Information Element (IE).

Usage		   uchar vn6_cause_spdu ();

Return value :  vn6_cause_spdu returns OK
								   NOK

common constants and declarations : ns.h net_i_s.h

common objects : internal data structure i_cause, ie  spdu context.
						- direction = FROM or TO D_CHANNEL side.

*--------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	uchar	check_ie		(uchar spdu_ie_codeset, uchar spdu_ie_id);
#else
	uchar	check_ie		();
#endif

uchar vn6_cause_spdu ()
{
	uchar   class_val;				/* cause class & value */
	uchar	ie_codeset;				/* codeset */
	uchar	ie_codeset_implicit;	/* implicit codeset */

	ie_codeset_implicit =
	ie_codeset          = CODESET_0;

	class_val = C_v (I_cause_class, I_cause_val);

	if (direction == FROM_D_CHANNEL) {

				/* FROM the D CHANNEL side */

	  if (! Eo_ie) {

		switch (class_val) {

			case C_v (C_C_NORMAL_EVENT_0, C_V_NO_ROUTE_TO_TRANSIT_NET_2)			:

				switch (Get_ie_octet) {

						/* no check done on the received IE contained in the diagnostic */

					case TRANSIT_NET_SEL :
					case SPF_FAC :
						return (r_exec_spdu_ie ((uchar *)&VN6_DIAG_P));

					default :

							/* not allowed IE */

						return (NOK);
				}

			case C_v (C_C_SERVICE_NOT_IMPLEMENTED,	C_V_CHANNEL_TYPE_NOT_IMPLEMENTED_66)	:

				if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_CHAN_TYPE) != OK) {
					return (NOK);

				} else {

					*(I_cause_p_diagnostic	= p_ind_buffer++) = I_cause_tmp;
					I_cause_diag_lgth		= 1;
				}
				break;

			case C_v (C_C_INVALID_MESSAGE, C_V_IDENTIFIED_CHANNEL_NOT_EXIST_82)	:

				if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_CHAN_NB) != OK) {
					return (NOK);

				} else {

					*(I_cause_p_diagnostic	= p_ind_buffer++) = I_cause_tmp;
					I_cause_diag_lgth		= 1;
				}

				break;

			case C_v (C_C_INVALID_MESSAGE, C_V_CALL_HAVING_CALL_ID_CLEARED_86)	 	:
				*(I_cause_p_diagnostic	= p_ind_buffer++) = Get_ie_octet;
				I_cause_diag_lgth		= 1;
				return (r_exec_spdu_ie ((uchar *)&VN6_DIAG_CAUSE));

			case C_v (C_C_RESOURCE_UNAVAILABLE,		C_V_ACCESS_INFORMATION_DISCARDED_43)	:
			case C_v (C_C_INVALID_MESSAGE,			C_V_INCOMPATIBLE_DESTINATION_88)		:
			case C_v (C_C_PROTOCOL_ERROR,			C_V_MANDATORY_IE_MISSING_96)			:
			case C_v (C_C_PROTOCOL_ERROR,			C_V_NON_EXISTENT_IE_99)					:
			case C_v (C_C_PROTOCOL_ERROR,			C_V_INVALID_IE_CONTENT_100)				:
				I_cause_p_diagnostic	= p_ind_buffer;
				Memcpy_far ((char FAR *) I_cause_p_diagnostic, (char FAR *) Get_p_ie, (uchar)Remainder_ie_octet);
				p_ind_buffer += (I_cause_diag_lgth	= (uchar)Remainder_ie_octet);

				do {

					if (So_ie_flag == IE_FORMAT_SO) {

							/* Single Octet IE processing */

						switch (So_ie_1_id) {

							case SHIFT :

								switch (So_ie_1_lock) {

									case LOCKING_SHIFT :

										if (Spdu_param_ie_locking_shift == ON) {
											ie_codeset_implicit = ie_codeset = So_ie_1_codeset;

										} else {
												/* locking shift not allowed : error */

											return (NOK);
										}

										break;

									case NON_LOCKING_SHIFT :

										if (Spdu_param_ie_non_locking_shift == ON) {
											ie_codeset = So_ie_1_codeset;

										} else {
												/* non locking shift not allowed : error */

											return (NOK);
										}
										break;

								}
								break;

							case CONGESTION_LEVEL :
								break;

							case IE_ID_SO :

								if (check_ie (CODESET_SO, Get_ie_octet - 0x80) != OK) return (NOK);
								break;
						}

					} else {

						if (check_ie (ie_codeset, Get_ie_octet) != OK) return (NOK);
						ie_codeset = ie_codeset_implicit;
					}

					Inc_p_ie (1);

				} while (!Eo_ie);

				break;

			case C_v (C_C_NORMAL_EVENT,	C_V_NUMBER_CHANGED_22)					:
				return (r_exec_spdu_ie ((uchar *)&VN6_DIAG_P));

			case C_v (C_C_SERVICE_NOT_AVAILABLE,	C_V_BC_NOT_AUTHORIZED_57)				:
			case C_v (C_C_SERVICE_NOT_AVAILABLE,	C_V_BC_NOT_PRESENTLY_AVAILABLE_58)		:
			case C_v (C_C_SERVICE_NOT_IMPLEMENTED,	C_V_BC_NOT_IMPLEMENTED_65)				:
				I_cause_p_diagnostic	= p_ind_buffer;
				Memcpy_far ((char FAR *) I_cause_p_diagnostic, (char FAR *) Get_p_ie, (uchar)Remainder_ie_octet);
				p_ind_buffer += (I_cause_diag_lgth	= (uchar)Remainder_ie_octet);

				do {

					switch (Get_inc_ie_octet) {

						case TRF_CAP_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_TRF_CAP) != OK) {
								return (NOK);
							}
							break;

						case TRF_MODE_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_TRF_MODE) != OK) {
								return (NOK);
							}
							break;

						case TRF_RATE_FLD :
						case DEST_RATE_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_TRF_RATE) != OK) {
								return (NOK);
							}
							break;

						case STRUCTURE_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_STRUCTURE) != OK) {
								return (NOK);
							}
							break;

						case CONFIG_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_CONFIG) != OK) {
								return (NOK);
							}
							break;

						case EST_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_EST) != OK) {
								return (NOK);
							}
							break;

						case SYMMETRY_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_SYMMETRY) != OK) {
								return (NOK);
							}
							break;

						case LAYER_ID_FLD :

							if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_LAYER_ID) != OK) {
								return (NOK);
							}
							break;

						default :
							return (NOK);
					}

				} while (!Eo_ie);

				break;


			case C_v (C_C_NORMAL_EVENT,				C_V_FACILITY_REJECT_29)					:
			case C_v (C_C_SERVICE_NOT_AVAILABLE,	C_V_REQUESTED_FAC_NOT_SUBSCRIBED_50)	:
			case C_v (C_C_SERVICE_NOT_IMPLEMENTED,	C_V_REQUESTED_FAC_NOT_IMPLEMENTED_69)	:

					/* Facility identification (Network dependent) */

				return (r_exec_spdu_ie ((uchar *)&VN6_DIAG_P));

			case C_v (C_C_NORMAL_EVENT,				C_V_CALL_REJECT_21)						:
				return (r_exec_spdu_ie ((uchar *)&VN6_DIAG_P));

			case C_v (C_C_NORMAL_EVENT_0,			C_V_UNASSIGNED_NUMBER_1)				:
			case C_v (C_C_NORMAL_EVENT_0,			C_V_NO_ROUTE_TO_DEST_3)					:
			case C_v (C_C_NORMAL_EVENT,				C_V_NORMAL_CLEARING_16)					:
			case C_v (C_C_SERVICE_NOT_AVAILABLE,	C_V_QUALITY_OF_SERVICE_UNAVAILABLE_49)	:

				if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_CONDITION) != OK) return (NOK);
				*(I_cause_p_diagnostic	= p_ind_buffer++) = I_cause_tmp;
				I_cause_diag_lgth		= 1;
				break;

			case C_v (C_C_INVALID_MESSAGE,			C_V_INVALID_MESSAGE_UNSPECIFIED_95)		:
			case C_v (C_C_PROTOCOL_ERROR,			C_V_MESSAGE_TYPE_NON_EXISTENT_97)		:
			case C_v (C_C_PROTOCOL_ERROR,			C_V_MESSAGE_STATE_INCONSISTENCY_98)		:
			case C_v (C_C_PROTOCOL_ERROR,			C_V_MESSAGE_NOT_COMPATIBLE_101)			:

				if (r_exec_spdu_ie ((uchar *)&VN6_DIAG_MSG) != OK) return (NOK);
				*(I_cause_p_diagnostic	= p_ind_buffer++) = I_cause_tmp;
				I_cause_diag_lgth		= 1;
				break;

			case C_v (C_C_PROTOCOL_ERROR,			C_V_RECOVERY_ON_TIMER_EXPIRY_102)		:
				return (r_exec_spdu_ie ((uchar *)&VN6_DIAG_TIMER));

			default :
				I_cause_diag_lgth		= 0;
				I_cause_p_diagnostic	= P_NIL;
				return (NOK);
		}


	  } else {

		I_cause_diag_lgth		= 0;
		I_cause_p_diagnostic	= P_NIL;
		return (OK);

	  }

	}
				/* TO D CHANNEL side */
	else {

	  if (I_cause_diag_lgth != 0) {

		switch (class_val) {
			case C_v (C_C_NORMAL_EVENT_0,			C_V_UNASSIGNED_NUMBER_1)				:
			case C_v (C_C_NORMAL_EVENT,				C_V_NORMAL_CLEARING_16)					:
			case C_v (C_C_SERVICE_NOT_AVAILABLE,	C_V_QUALITY_OF_SERVICE_UNAVAILABLE_49)	:
				I_cause_tmp =  *I_cause_p_diagnostic - '0';
				return (s_exec_spdu_ie ((uchar *)&VN6_DIAG_CONDITION));

			case C_v (C_C_RESOURCE_UNAVAILABLE,		C_V_ACCESS_INFORMATION_DISCARDED_43)	:
			case C_v (C_C_PROTOCOL_ERROR,   		C_V_MANDATORY_IE_MISSING_96)			:
			case C_v (C_C_PROTOCOL_ERROR,   		C_V_NON_EXISTENT_IE_99)					:
			case C_v (C_C_PROTOCOL_ERROR,   		C_V_INVALID_IE_CONTENT_100)				:
				Memcpy_far ((char FAR *) Get_p_ie, (char FAR *) I_cause_p_diagnostic, I_cause_diag_lgth);
				Inc_p_ie (I_cause_diag_lgth);
				break;

			case C_v (C_C_PROTOCOL_ERROR,   		C_V_MESSAGE_TYPE_NON_EXISTENT_97)   	:
			case C_v (C_C_PROTOCOL_ERROR,   		C_V_MESSAGE_STATE_INCONSISTENCY_98) 	:
			case C_v (C_C_PROTOCOL_ERROR,			C_V_MESSAGE_NOT_COMPATIBLE_101)			:
				Put_inc_ie_octet (*I_cause_p_diagnostic);
				break;

			case C_v (C_C_NORMAL_EVENT,				C_V_FACILITY_REJECT_29)					:
			case C_v (C_C_SERVICE_NOT_AVAILABLE,	C_V_REQUESTED_FAC_NOT_SUBSCRIBED_50)	:
			case C_v (C_C_SERVICE_NOT_IMPLEMENTED,	C_V_REQUESTED_FAC_NOT_IMPLEMENTED_69)	:

					/* Facility identification (Network dependent) */

				return (s_exec_spdu_ie ((uchar *)&VN6_DIAG_P));

			case C_v (C_C_PROTOCOL_ERROR,			C_V_RECOVERY_ON_TIMER_EXPIRY_102)		:
				return (s_exec_spdu_ie ((uchar *)&VN6_DIAG_TIMER));

			default :
				break;
		}

	  }

	}

	return (OK);
}

uchar vn6_mode_circuit ()
{
	I_cause_tmp = TRF_MODE_CIRCUIT;
	return (OK);
}

uchar vn6_cause_3a_spdu ()
{
	ie_if_flag = ON;	/* octet 3a may be present */

	if (direction == TO_D_CHANNEL &&
		I_cause_recommend == RECOMMENDATION_Q931) {
		ie_if_flag = OFF;
	}

	return (OK);

}

/*------------------------------------------------------------------------*/

		/*
		   Test if interface type in chan_id IE and in
		   configuration are the same. If not return error.
		*/

uchar vn6_chan_id_spdu ()
{

	if (direction == FROM_D_CHANNEL) {

		if (I_(chan_id,int_type) == INT_TYPE_BRI) {

			if (Na_type != BRI) return (NOK);

		} else {

			if (Na_type != PRI) return (NOK);
		}

	}

		/* Process PRI type chan_id */

	if (I_(chan_id,int_type) != INT_TYPE_BRI) {

			/*	if 'channel selection' field is not "As indicated in following octets"
				there are no more octets in Channel ID, else octets 3.2 and 3.3 are present */

		if (I_(chan_id,chan_sel) == AS_INDICATED) {

			if (direction == FROM_D_CHANNEL) {
				return (r_exec_spdu_ie ((uchar *)&VN6_CHAN_ID_PRI_P));

			} else {

				return (s_exec_spdu_ie ((uchar *)&VN6_CHAN_ID_PRI_P));
			}
		}
	}

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			llc_spdu - implements the processing of the low layer
						   compatibility (LLC) IE of a received SPDU
						   message and of SPDU message to be sent.

Usage		   uchar llc_spdu ();

Return value :  llc_spdu returns = OK valid data,
								 = NOK invalid data and fatal error.

*--------------------------------------------------------------------------*/

uchar vn6_llc_3a_spdu ()
{

	ie_if_flag = ON;	/* (default value) : octet 3a may be present */

	if ((direction == TO_D_CHANNEL) &&
		(i_llc[0].out_band_neg == OUT_BAND_NOT_POSSIBLE)) {

			/* default value for octet 3a : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);

}

/*--------------------------------------------------------------------------*/

uchar vn6_llc_4ab_spdu ()
{
	ie_if_flag = ON;	/* octets 4a and 4b may be present */

	if ((direction			== TO_D_CHANNEL)			&&
		(I_(llc,structure)	== STRUCTURE_DEFAULT)		&&
		(I_(llc,config)		== CONFIG_POINT_TO_POINT)	&&		/* forced value anyway */
		(I_(llc,est)		== EST_DEMAND)				&&		/* forced value anyway */
		(I_(llc,symmetry)	== BIDIRECTIONAL_SYMMETRY)	&&		/* forced value anyway */
		(I_(llc,dest_rate)	== I_(llc,trf_rate))) {

		/* default values for octets 4a and 4b : they are omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar vn6_llc_4b_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 4b may be present */

	if ((direction		 	== TO_D_CHANNEL)			&&
		(I_(llc,symmetry)	== BIDIRECTIONAL_SYMMETRY)	&&		/* forced value anyway */
		(I_(llc,dest_rate)	== I_(llc,trf_rate))) {

		/* default values for octet 4b : it is omitted */

		ie_if_flag = OFF;
	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar vn6_llc_5_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 5 may be present */

		/* if I_llc_protocol_id_1 == BYTE_VAL_NIL -> octet 5 is missing */

	if (direction == TO_D_CHANNEL) {

		if (I_(llc,protocol_id_1) == BYTE_VAL_NIL) {

				/* octet 5 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_1) {

				/* It is NOT Octet 5 (layer 1) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar vn6_llc_6_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 6 may be present */

		/* if I_llc_layer_id_2 == BYTE_VAL_NIL -> octet 6 is missing */

	if (direction == TO_D_CHANNEL) {

			/* octet 6 must be present if PACKET MODE */

		if (I_(llc,protocol_id_2) == BYTE_VAL_NIL) {

			/* octet 6 is missing */

			if (I_(llc,trf_mode) == TRF_MODE_PACKET) return (NOK);

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_2) {

				/* It is NOT Octet 6 (layer 2) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*/

uchar vn6_llc_7_spdu ()
{
	ie_if_flag = ON;	/* (default value) : octet 7 may be present */

		/* if I_llc_layer_id_3 == BYTE_VAL_NIL -> octet 7 is missing */

	if (direction == TO_D_CHANNEL) {

		if (I_(llc,protocol_id_3) == BYTE_VAL_NIL) {

				/* octet 7 is missing */

			ie_if_flag = OFF;
		}

	} else {

		uchar ie_octet;

		ie_octet = Get_ie_octet;

		if (Get_layer_id () != LAYER_ID_3) {

				/* It is NOT Octet 7 (layer 3) */

			ie_if_flag = OFF;
		}

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		vn6_restart_spdu - check if presence of CHAN ID IE is compulsory or forbidden.

Usage		uchar vn6_restart_spdu ();

Return value :  vn6_restart_spdu returns = OK   valid data,
									 = NOK  invalid data if fatal error.

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar vn6_restart_spdu ()
{

	if (is_ie_i (CODESET_0, CHAN_ID) == ABSENT) {
		return (OK);

	} else {

		if (I_restart_ind_class == RI_INDICATED_CHANNEL) {
			return (OK);
		}

	}

	return (NOK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name		vn6_progress_ind_spdu - save the progress indicator into the call
			context for T310 timer management (it must not be started if
			the progress indicator indicates that interworking with a
			non-ISDN network occured (values #1 or #2).

Usage		uchar vn6_progress_ind_spdu ();

Return value :  OK

common constants and declarations : isdn.h

*--------------------------------------------------------------------------*/

uchar vn6_progress_ind_spdu ()
{
		/* save the progress descrition into the call context */

	if (Call_current_exist) {

		Call_progress_descr = I_(progress_ind, progress_descr);
	}

	return (OK);
}

/*-------------------------------------------------------------------------*/

#define Ns_vn6_table_or_function(str, tab)	PIC_CONST_ARRAY struct str tab[] = {
#define Ns_vn6_end_table_or_function		};
#define Ns_vn6_tab_tabl_entry(idx, tab)		Ns_tab_tabl_entry (idx, tab),
#define Ns_vn6_tabx_list_entry(tab)			Ns_tabx_list_entry (tab),
#define Ns_vn6_tab_tabx_entry(idx, tab)		Ns_tab_tabx_entry (idx, tab),

#define Ns_vn6_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off)	\
			Ns_tab_ie_entry (codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off),

#define Ns_vn6_tab_ie_no_i_str(codes, ie, mx)	{codes, ie, A_NIL, 0, A_NIL, A_NIL, A_NIL, mx, 0},
#define Ns_vn6_tab_ie_msg_header			{CODESET_NIL, MESSAGE_HEADER, (uchar *)A_NIL, sizeof(struct i_message_header), (uchar *)Pic_address (&i_message_header), (uchar *)A_NIL, (uchar *)A_NIL, 1, 0},

#include "vn6.tab_ie"		/* include other Tables describing the IEs */

#define VN6_MX_TABL (sizeof(VN6_TAB_TABL)/sizeof (struct tabl))
CONST   uchar   vn6_size_tab_tabl = VN6_MX_TABL;

#define VN6_MX_TABX (sizeof(VN6_TAB_TABX)/sizeof (struct tabx))
CONST   uchar   vn6_size_tab_tabx = VN6_MX_TABX;

CONST	uchar	vn6_size_tab_ie = Rnd_sizeof (VN6_TAB_IE) / IE_ELEM_SIZE;	/* maximum number of item in the table */

/*-------------------------------------------------------------------------*/

#if OM_CODE_TYPE == OM_PIC /* PIC used{ */

#undef Ns_vn6_table_or_function
#undef Ns_vn6_end_table_or_function
#undef Ns_vn6_tab_tabl_entry
#undef Ns_vn6_tabx_list_entry
#undef Ns_vn6_tab_tabx_entry
#undef Ns_vn6_tab_ie_entry
#undef Ns_vn6_tab_ie_no_i_str
#undef Ns_vn6_tab_ie_msg_header

#define Ns_vn6_table_or_function(str, tab)	i_pic = 0;						\
											{								\
												struct str FAR	*p_table;	\
												p_table = tab;

#define Ns_vn6_end_table_or_function		}

#define Ns_vn6_tab_tabl_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_val, (uchar *)tab);
#define Ns_vn6_tabx_list_entry(tab)			Pic_init_struct_array_next (p_table,  p_val, (uchar	*)tab);
#define Ns_vn6_tab_tabx_entry(idx, tab)		Pic_init_struct_array (p_table, idx, p_list_tab, (struct tabx_list *)tab);

#define Ns_vn6_tab_ie_entry(codes, ie, mp_a, i_str, df_spdu, df_ssdu, mx, off)	\
	Pic_init_struct_array (p_table,  i_pic, p_prog, (uchar	*)mp_a);			\
	Pic_init_struct_array (p_table,  i_pic, p_i_struct, (uchar	*)i_str);		\
	Pic_init_struct_array (p_table,  i_pic, p_init_spdu, (uchar	*)df_spdu);		\
	Pic_init_struct_array_next (p_table,  p_init_ssdu, (uchar	*)df_ssdu);

#define Ns_vn6_tab_ie_no_i_str(codes, ie, mx)	Ns_vn6_tab_ie_entry (0, 0, P_NIL, P_NIL, P_NIL, P_NIL, 0, 0)

#define Ns_vn6_tab_ie_msg_header		Ns_vn6_tab_ie_entry (0, 0, P_NIL, &i_message_header, P_NIL, P_NIL, 0, 0)

		/*	Function used to initialize address fields in Tables above */

void pic_init_ns_vn6_ie ()
{
	uchar	i_pic;			/* current index */

#	include "vn6.tab_ie"
}

#endif /* end of PIC used} */


/*EOF*/

