/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - net_state.vn6
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *        u0 to u25 - user side - implements the processing of an event
 *                     according to the state of the call (u0 to u254).
 *
 *        n0 to n25 - network side - implements the processing of an event
 *                     according to the state of the call (n0 to n254).
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

						/*----------------*/
						/*                */
						/*   USER SIDE    */
						/*       U        */
						/*----------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             vn6_u0 to vn6_u25 - user side - implements the processing of an
							  event according to the call state.

Usage            void uxx (void);

Related
functions usage void Stop_timer_ns (uchar x_timer);

				void Start_timer_ns (uchar x_timer);
						- x_timer : timer index.

				void Send_to_d_channel (uchar spdu_id);
						- spdu_id : spdu message type (ID).

				void Send_to_call_control (uchar ssdu_id);
						- ssdu_id : ssdu primitive code (ID).

				void Set_state (uchar call_state);
						- call_state : state of the call.

				void call_clear (void);

				void ns_unexpected_ev (void);

Return value    void

Common constants and declarations : ns.h

Common objects : call and na object, internal data structure.

*-------------------------------------------------------------------------*/

		/* STATE_NULL_0 */

		/* Null state */

			/*
			   No call exists : used when a call context is
			   allocated to a call
			*/

void vn6_u0 ()
{

	switch (event_id) {

		case DA_SETUP:
			Send_to_call_control (NS_CONN_IN);

			if (is_ie_i (CODESET_SO, SENDING_COMPLETE) == ABSENT) {
				Call_en_bloc_flag = OFF;

			} else {

				Call_en_bloc_flag = ON;
			}

			if (is_ie_i (CODESET_0, UUI) == ABSENT) {
				Call_uui_rq = OFF;

			} else {

				Call_uui_rq = ON;
				Call_ui_count = 0;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_0, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

            	/* save progress descriptor */

			if (is_ie_i (CODESET_0, PROGRESS_IND) == PRESENT) {

				Call_progress_descr = I_(progress_ind, progress_descr);
			}

			Set_state (STATE_CALL_PRESENT_6);
			Start_timer_ns (VN6_T300);
			break;

		case NS_CONN_RQ :
			Send_to_d_channel_and_save_spdu (SETUP);

			if (is_ie_i (CODESET_SO, SENDING_COMPLETE) == ABSENT) {
				Call_en_bloc_flag = OFF;

			} else {

				Call_en_bloc_flag = ON;
			}

			if (is_ie_i (CODESET_0, UUI) == ABSENT) {
				Call_uui_rq = OFF;

			} else {

				Call_uui_rq = ON;
				Call_ui_count = 0;
			}

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_0, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

			Set_state (STATE_CALL_INIT_1);
			Start_timer_ns (VN6_T303);
			break;

		case NS_RESUME_RQ :

				/* assume the interface type is Basic */

			if (Na_type == BRI) {
				ns_action_to_dl (T3_NIL, VN6_T318, RES,
												   STATE_RESUME_REQUEST_17);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_REGISTRATION_RQ :
			Send_to_d_channel (REG);
			Start_timer_ns (VN6_T399);
			Set_state (STATE_REGISTRATION_REQUEST_254);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_INIT_1 */

		/* Call initialization state */

			/*
			   This state exists for an outgoing call, as a result of user
			   action requesting call establishment from the network.
			*/

void vn6_u1 ()
{
	switch (event_id) {

		case DA_CALL_PROC :
			Release_saved_spdu ();		/* saved setup no more useful */

				/*
					ETS 300-102-1, Table 9.2, note 4:
					Do not start T310 if interworking occured
				*/

			if ((Call_progress_descr == PROGRESS_DESCR_NON_END_TO_END_ISDN) ||
				(Call_progress_descr == PROGRESS_DESCR_NON_ISDN_DEST)) {
				ns_action_to_cc (VN6_T303, T3_NIL,   NS_CALL_PROC_IN,
													 STATE_OUTGOING_CALL_PROC_3);
			} else {

				ns_action_to_cc (VN6_T303, VN6_T310, NS_CALL_PROC_IN,
													 STATE_OUTGOING_CALL_PROC_3);
			}
			break;

		case DA_SETUP_ACK :

#if 0 /* This is the normal case which implies problems with some equipments */

			if (Call_en_bloc_flag == OFF) {
				Release_saved_spdu ();		/* saved setup no more useful */
				ns_action_to_cc (VN6_T303, VN6_T304, NS_SETUP_ACK_IN,
													 STATE_OVERLAP_SENDING_2);
			} else {

					/*
						Some networks send SETUP_ACK for international calls
						even if the SETUP was in BLOC_SENDING mode to force
						the TE to stop T303 to avoid SETUP retransmission
						if the call establishment takes too long time.
						Of course, a CALL_PROC would be much better !
					*/

				Stop_timer_ns (VN6_T303);
				ns_unexpected_ev ();
			}

#else /* SETUP_ACK always accepted */

			Release_saved_spdu ();		/* saved setup no more useful */
			ns_action_to_cc (VN6_T303, VN6_T304, NS_SETUP_ACK_IN,
													 STATE_OVERLAP_SENDING_2);
#endif
			break;

		case DA_ALERT :
			Release_saved_spdu ();		/* saved setup no more useful */
			ns_action_to_cc (VN6_T303, T3_NIL, NS_ALERT_IN,
											   STATE_CALL_DELIVERED_4);
			break;

		case DA_CONN :
			Release_saved_spdu ();			/* saved setup no more useful */
			ns_action_to_cc (VN6_T303, T3_NIL, NS_CONN_CO,
											   STATE_ACTIVE_10);
			break;

		case TI_303 :

			if (++N303 < MX_N303) {
				Send_saved_spdu_to_d_channel (SETUP);
				Restart_timer_ns (VN6_T303);

			} else {

				set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "303");
				Send_to_d_channel (REL_COMP);
				Reset_internal_ie ();
				set_i_cause (C_C_TIMER, C_V_T303, (char FAR *) &(Call_state));
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_SENDING_2 */

		/* Overlap sending state */

			/*
			   This state exists for an outgoing call when the user has
			   received acknowledgement of the call establishment request
			   which permits the user to send additional call information
			   to the network in overlap mode.
			*/


void vn6_u2 ()
{
	switch (event_id) {

		case DA_CALL_PROC :

				/*
					ETS 300-102-1, Table 9.2, note 4:
					Do not start T310 if interworking occured
				*/

			if ((Call_progress_descr == PROGRESS_DESCR_NON_END_TO_END_ISDN) ||
				(Call_progress_descr == PROGRESS_DESCR_NON_ISDN_DEST)) {
				ns_action_to_cc (VN6_T304, T3_NIL,   NS_CALL_PROC_IN,
													 STATE_OUTGOING_CALL_PROC_3);
			} else {

				ns_action_to_cc (VN6_T304, VN6_T310, NS_CALL_PROC_IN,
													 STATE_OUTGOING_CALL_PROC_3);
			}
			break;

		case DA_PROGRESS :

				/* PROGRESS_IND IE is mandatory and so present */

			if (I_progress_ind_description != PROGRESS_DESCR_IN_BAND_NOW) {
				Stop_timer_ns (VN6_T304);		/* only in case of interworking */
			}
			Send_to_call_control (NS_PROGRESS_IN);
			break;

		case DA_ALERT :
			ns_action_to_cc (VN6_T304, T3_NIL, NS_ALERT_IN,
											   STATE_CALL_DELIVERED_4);
			break;

		case DA_CONN :
			ns_action_to_cc (VN6_T304, T3_NIL, NS_CONN_CO,
											   STATE_ACTIVE_10);
			break;

		case TI_304 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "304");
			Save_cause ();					/* to send the RELEASE if T305 expire */
			ns_action_to_dl (T3_NIL, VN6_T305, DISC,
											   STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OUTGOING_CALL_PROC_3 */

		/* Outgoing call proceeding state */

			/*
			   This state exists for an outgoing call when the user
			   has received acknowledgement that the network has received
			   all call information necessary to effect call establishment.
			*/

void vn6_u3 ()
{
	switch (event_id) {

		case DA_ALERT :

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_0, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

			ns_action_to_cc (VN6_T310, T3_NIL, NS_ALERT_IN,
											   STATE_CALL_DELIVERED_4);
			break;

		case DA_CONN :

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_0, USER_FAC) == ABSENT) {
				Call_user_fac_rq = OFF;
			}

			ns_action_to_cc (VN6_T310, T3_NIL, NS_CONN_CO,
											   STATE_ACTIVE_10);
			break;

		case DA_PROGRESS :

				/* PROGRESS_IND IE is mandatory and so present */

			if (I_progress_ind_description != PROGRESS_DESCR_IN_BAND_NOW) {
				Stop_timer_ns (VN6_T310);		/* only in case of interworking */
			}
			Send_to_call_control (NS_PROGRESS_IN);
			break;

		case TI_310 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "310");
			Save_cause ();						/* to send the RELEASE if T305 expire */
			ns_action_to_dl (T3_NIL, VN6_T305, DISC,
											   STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_DELIVERED_4 */

		/* Call delivered state */

			/*
			   This state exists for an outgoing call when the calling user
			   has received an indication that the remote user alerting has
			   been initiated.
			*/

void vn6_u4 ()
{
	switch (event_id) {

		case DA_CONN :
			Send_to_call_control (NS_CONN_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		case NS_USER_INFO_RQ :

			if (Call_ui_u_count < (uint)MX_UI_COUNT) {
				Inc_ui_u_count ();
				Send_to_d_channel (USER_INFO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case DA_USER_INFO :

			if (Call_ui_n_count < (uint)MX_UI_COUNT) {
				Inc_ui_n_count ();
				Send_to_call_control (NS_USER_INFO_IN);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case DA_PROGRESS :
			Send_to_call_control (NS_PROGRESS_IN);
			break;

		default :
			ns_unexpected_ev ();
			break;
	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_PRESENT_6 */

		/* Call present state */

			/*
			   This state exists for an incoming call when the user
			   has received a call establishment request but not yet
			   responded.
			*/

void vn6_u6()
{
	switch (event_id) {

		case NS_ALERT_RQ :

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_0, USER_FAC) == PRESENT) {

				if (Call_user_fac_rq == OFF) {
					send_err_to_user (ERR_U_USER_FAC_PROTOCOL, USER_FAC, 0, Call_upper_ent);
					break;

				}


			} else {

				Call_user_fac_rq = OFF;
			}

			ns_action_to_dl (VN6_T300, T3_NIL, ALERT,
											   STATE_CALL_RECEIVED_7);
			break;

		case NS_CONN_RS :

				/* USER FACILITY protocol */

			if (is_ie_i (CODESET_0, USER_FAC) == PRESENT) {

				if (Call_fac_rq == OFF) {
					send_err_to_user (ERR_U_USER_FAC_PROTOCOL, USER_FAC, 0, Call_upper_ent);
					break;

				}


			} else {

				Call_fac_rq = OFF;
			}

			ns_action_to_dl (VN6_T300, VN6_T313, CONN,
												 STATE_CONNECT_REQUEST_8);
			break;

		case NS_SETUP_ACK_RQ :

			if (Call_en_bloc_flag == OFF) {
				ns_action_to_dl (VN6_T300, VN6_T302, SETUP_ACK,
													 STATE_OVERLAP_RECEIVING_25);

			} else {

				ns_unexpected_ev ();
			}
			break;

		case NS_CALL_PROC_RQ :
			ns_action_to_dl (VN6_T300, T3_NIL, CALL_PROC,
											   STATE_INCOMING_CALL_PROC_9);
			break;

		case TI_300 :
			Reset_internal_ie ();
			set_i_cause (C_C_TIMER, C_V_T300, (char FAR *) &(Call_state));
			Send_to_call_control (NS_CLEAR_CO);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_RECEIVED_7 */

		/* Call received state */

			/*
			   This state exists for an incomming call when the user has
			   indicated alerting but not yet answered.
			*/

void vn6_u7 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			ns_action_to_dl (T3_NIL, VN6_T313, CONN,
											   STATE_CONNECT_REQUEST_8);
			break;

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		case NS_USER_INFO_RQ :

			if (Call_ui_u_count < (uint)MX_UI_COUNT) {
				Inc_ui_u_count ();
				Send_to_d_channel (USER_INFO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case DA_USER_INFO :

			if (Call_ui_n_count < (uint)MX_UI_COUNT) {
				Inc_ui_n_count ();
				Send_to_call_control (NS_USER_INFO_IN);

			} else {

				ns_unexpected_ev ();
			}

			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CONNECT_REQUEST_8 */

		/* Connect request state */

			/*
			   This state exists for an incoming call when the user
			   has answered the call and is waiting to be awarded.
			*/

void vn6_u8 ()
{
	switch (event_id) {

		case DA_CONN_ACK :
			ns_action_to_cc (VN6_T313, T3_NIL, NS_CONN_CO,
											   STATE_ACTIVE_10);
			break;

		case TI_313 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "313");
			Save_cause ();			/* to send the RELEASE if T305 expires */
			ns_action_to_dl (T3_NIL, VN6_T305, DISC,
											   STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_INCOMING_CALL_PROC_9 */

		/* Incoming call proceeding state */

			/*
			   This state exists for an incoming call when the user has
			   sent acknowlegdement that the user has received all call
			   information necessary to effect call establishment.
			*/

void vn6_u9 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			ns_action_to_dl (T3_NIL, VN6_T313, CONN,
											   STATE_CONNECT_REQUEST_8);
			break;

		case NS_ALERT_RQ :
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_RECEIVED_7);
			break;

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_ACTIVE_10 */

		/* Active state */

			/*
			   This state exists if an incoming call when the user has
			   received an acknowledgement from the network that the user
			   has been awarded the call. This state exists for an outgoing
			   call when the user has received an indication that the remote
			   user has answered the call.
			*/

void vn6_u10 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SUSPEND_RQ :

				/* Assume the interface type is Basic rate */

			if (Na_type == BRI) {
				ns_action_to_dl (T3_NIL, VN6_T319, SUSP,
												   STATE_SUSPEND_REQUEST_15);
			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		case DA_NOTIFY :
			Send_to_call_control (NS_NOTIFY_IN);
			break;

		case NS_NOTIFY_RQ :
			Send_to_d_channel (NOTIFY);
			break;

#		if NS_T309 == ON

			case TI_309 :
				set_i_cause (C_C_NORMAL_EVENT, C_V_DEST_OUT_OF_ORDER_27, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
				break;

#		endif

		case NS_USER_INFO_RQ :
			Send_to_d_channel (USER_INFO);
			break;

		case DA_USER_INFO :
			Send_to_call_control (NS_USER_INFO_IN);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_REQUEST_11 */

		/* Disconnect request state */

			/*
			   This state exists when the user has requested the network
			   to clear the end-to-end connection (if any) and is waiting
			   for a response.
			*/

void vn6_u11 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		case DA_NOTIFY :
			Send_to_call_control (NS_NOTIFY_IN);
			break;

		 case TI_305 :
			Restore_cause ();	/* send saved cause of the previous DISC */
			set_ie_i (CODESET_0, CAUSE);
			go_to_state_19 (VN6_T308);
			break;

		 default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_INDICATION_12 */

		/* Disconnect indication state */

			/*
			   This state exists when the user has received an invitation
			   to disconnect because the network has disconnected the
			   end-to-end connection (if any).
			*/

void vn6_u12 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Stop_timer_ns (VN6_T300);
			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;

		case NS_CLEAR_RS :
			disc_cause_error ();
			go_to_state_19 (VN6_T308);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_SUSPEND_REQUEST_15 */

		/* Suspend request state */

			/*
			   This state exists  after the user has requested the network
			   to suspend the call and is waiting for a response.
			*/

void vn6_u15 ()
{
	switch (event_id) {

		case DA_SUSP_ACK :
			Send_to_call_control (NS_SUSPEND_CO);
			call_clear ();
			break;

		case DA_SUSP_REJ : 			/* cause #84 should be received */
			ns_action_to_cc (VN6_T319, T3_NIL, NS_SUSPEND_CO,
											   STATE_ACTIVE_10);
			break;

		case DA_NOTIFY :
			Send_to_call_control (NS_NOTIFY_IN);
			break;

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;


		case TI_319 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "319");
			Send_to_call_control (NS_SUSPEND_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RESUME_REQUEST_17 */

		/* Resume request state */

			/*
			   This state exists  after the user has requested the network
			   to resume a previously suspend call and is waiting for a
			   response.
			*/

void vn6_u17 ()
{
	switch (event_id) {

		case DA_RES_ACK :
			ns_action_to_cc (VN6_T318, T3_NIL, NS_RESUME_CO,
											   STATE_ACTIVE_10);
			break;

		case DA_RES_REJ :
			Send_to_call_control (NS_RESUME_CO);
			call_clear ();
			break;

		case TI_318 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "318");
			Send_to_call_control (NS_RESUME_CO);
			go_to_state_19 (VN6_T308);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RELEASE_REQUEST */

		/* Release request state */

			/*
			   This state exists when the user has requested the network
			   to release and is waiting for a response.
			*/

void vn6_u19 ()
{
	switch (event_id) {

		case DA_FAC_ACK :
		case DA_FAC_REJ :

			if (Call_fac_rq == ON) {
				Call_fac_rq = OFF;
				Send_to_call_control (NS_SPF_FACILITY_CO);

			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_SPF_FACILITY_RQ :

			if (Call_fac_rq == ON) {
				ns_unexpected_ev ();
			}

			Send_to_d_channel (FT_FAC);
			Call_fac_rq = ON;
			break;


		case NS_CLEAR_RS :
			break;

		case TI_308 :

			if (++N308 < MX_N308) {
				Send_saved_spdu_to_d_channel (REL);
				Restart_timer_ns (VN6_T308);

			} else {

				set_i_cause (C_C_TIMER, C_V_T308, (char FAR *) &(Call_state));
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_RECEIVING_25 */

		/* Overlap receiving */

			/*
			   This state exits for an incoming call when the user
			   has acknowledged the call establishment request from
			   the network and is prepared to received additional call
			   information (if any) in overlap mode.
			*/

void vn6_u25 ()
{
	switch (event_id) {

		case NS_CALL_PROC_RQ :
			ns_action_to_dl (VN6_T302, T3_NIL, CALL_PROC,
											   STATE_INCOMING_CALL_PROC_9);
			break;

		case NS_ALERT_RQ :
			ns_action_to_dl (VN6_T302, T3_NIL, ALERT,
											   STATE_CALL_RECEIVED_7);
			break;

		case NS_CONN_RS :
			ns_action_to_dl (VN6_T302, VN6_T313, CONN,
												 STATE_CONNECT_REQUEST_8);
			break;

		case NS_PROGRESS_RQ :
			Stop_timer_ns (VN6_T302);
			Send_to_d_channel (PROGRESS);
			break;

		case TI_302 :
			set_i_cause (C_C_NORMAL_EVENT, C_V_INVALID_NUMBER_FORMAT_28, P_NIL);
			Save_cause ();			/* to send the RELEASE if T305 expires */
			ns_action_to_dl (T3_NIL, VN6_T305, DISC,
											   STATE_DISCONNECT_REQUEST_11);
			break;

		default :
			ns_unexpected_ev ();
			break;
	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_REGISTRATION_REQUEST_254 */

		/* A registration resquest has been sent. */

void vn6_u254 ()
{
	switch (event_id) {

		case DA_REG_ACK :
		case DA_REG_REJ :
			Send_to_call_control (NS_SPF_REGISTRATION_CO);
			call_clear ();
			break;

		case TI_399 :
			set_i_cause (C_C_TIMER, C_V_T399, (char FAR *) &Call_state);
			Send_to_call_control (NS_SPF_REGISTRATION_CO);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}
/*-------------------------------------------------------------------------*/

#if EQUIPMENT == NT2

#define Vn6_send_to_all_ces(ev_id, ie_flag)			vn6_send_to_other_ces (ev_id, ie_flag); \
													vn6_send_to_ces (ev_id, ie_flag, Call_ces)	/* send to all terminals ev_id. Flag = OFF for specific cause */


#if NEW_FCT_STYLE == ON
	void	vn6_send_to_ces		 		(uchar ev_id, uchar ie_flag, uchar my_ces);
	void	vn6_send_to_other_ces 		(uchar ev_id, uchar ie_flag);
	uchar	vn6_nb_other_active_ces		(void);
#else
	void	vn6_send_to_ces		 		();
	void	vn6_send_to_other_ces 		();
	uchar	vn6_nb_other_active_ces		();
#endif

						/*----------------*/
						/*-------------------*/
						/*                   */
						/*   NETWORK SIDE    */
						/*        N          */
						/*-------------------*/


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             n0 to n254 - network side - implements the processing of an
							  event according to the call state.

Usage            void uxx (void);

Related
functions usage void Stop_timer_ns (VN6_uchar x_timer);

				void Start_timer_ns (VN6_uchar x_timer);
						- x_timer : timer index.

				void Send_to_d_channel (uchar spdu_id);
						- spdu_id : spdu message type (ID).

				void Send_to_call_control (uchar ssdu_id);
						- ssdu_id : ssdu primitive code (ID).

				void Set_state (uchar call_state);
						- call_state : state of the call.

				void call_clear (void);

				void ns_unexpected_ev (void);

Return value    void

Common constants and declarations : ns.h

Common objects : call and na object, internal data structure.

*-------------------------------------------------------------------------*/

		/* STATE_NULL */

		/* Null state */

			/*
			   No call exists : used when a call context is
			   allocated to a call or a registration.
			*/

void vn6_n0 ()
{

	switch (event_id) {

		case DA_SETUP:
			Call_ref = i_call_ref;
			Call_ces = Dl_ces;
			Call_ces_setup =Dl_ces;
			Call_sub_state = N6;

				/* increment DL call counter in Point-to-multipoint only
					(already done in point-to-point in call_init()) */

			if (Na_connection == POINT_TO_MULTIPOINT) {

				Dl_call_count++;
			}

			ns_action_to_cc (T3_NIL, VN6_T300, NS_CONN_IN,
											   STATE_CALL_INIT_1);
			break;

		case DA_RES :
			ns_action_to_cc (T3_NIL, VN6_T300, NS_RESUME_IN,
											   STATE_RESUME_REQUEST_17);
			break;

		case NS_CONN_RQ :
			N303 = 0;
			Start_timer_ns (VN6_T303);

			if (Na_connection == POINT_TO_MULTIPOINT) {
				reset_multipoint_context ();
				Start_timer_ns (VN6_T312);
				Send_to_d_channel_and_save_spdu (SETUP);
				Call_setup_ack = 0;

			} else {

				Send_to_d_channel_and_save_spdu (SETUP);
			}

			if (Call_ces == DL_CES_NIL) {
				Call_ces_setup = DL_CES_BROADCAST;

			} else {

				Call_ces_setup = Dl_ces;
			}

			Call_ces_connect = NIL;

			Set_state (STATE_CALL_PRESENT_6);
			break;

		case INT_REL_COMP_IN :
				Call_alert (Dl_ces) = OFF;
			break;

		case NS_NOTIFY_RQ :
			/* no process */
			break;

		case DA_REG :
			Send_to_call_control (NS_SPF_REGISTRATION_IN);
			Call_ces = Dl_ces;
			Start_timer_ns (VN6_T300);
			Set_state (STATE_REGISTRATION_REQUEST_254);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_INIT_1 */

		/* Call initialization state */

			/*
			   This state exists for an outgoing call, as a result of  user
			   action requesting call establishment from the network.
			*/

void vn6_n1 ()
{
	switch (event_id) {

		case NS_CALL_PROC_RQ :
			ns_action_to_dl (VN6_T300, T3_NIL, CALL_PROC,
											   STATE_OUTGOING_CALL_PROC_3);
			break;

		case NS_SETUP_ACK_RQ :
			ns_action_to_dl (VN6_T300, VN6_T302, SETUP_ACK,
												 STATE_OVERLAP_SENDING_2);
			break;

/*$ missing events in ETS 300-102-2 SDLs !!! */

		case NS_CONN_RS :
			ns_action_to_dl (VN6_T300, T3_NIL, CONN,
											   STATE_ACTIVE_10);
			break;

		case NS_ALERT_RQ:
			ns_action_to_dl (VN6_T300, T3_NIL, ALERT,
											   STATE_CALL_DELIVERED_4);
			break;

/*$ end of missing events */

		case TI_300 :
			set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_CONGESTION_42, P_NIL);
			Send_to_call_control (NS_CLEAR_CO);
			Send_to_d_channel (REL_COMP);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_SENDING */

		/* Overlap sending state */

			/*
			   This state exists for an outgoing call when the user has
			   received acknowledgement of the call establishment request
			   which permits the user to send additional call information
			   to the network in overlap mode.
			*/


void vn6_n2 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			ns_action_to_dl (VN6_T302, T3_NIL, CONN,
											   STATE_ACTIVE_10);
			break;

		case NS_CALL_PROC_RQ :
			ns_action_to_dl (VN6_T302, T3_NIL, CALL_PROC,
											   STATE_OUTGOING_CALL_PROC_3);
			break;

		case NS_ALERT_RQ:
			ns_action_to_dl (VN6_T302, T3_NIL, ALERT,
											   STATE_CALL_DELIVERED_4);
			break;

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		case TI_302 :
/*$*/		set_i_cause (C_C_NORMAL_EVENT, C_V_INVALID_NUMBER_FORMAT_28, P_NIL);
			Save_cause ();									/* to send the RELEASE if T305 expire */
			Send_to_call_control (NS_CLEAR_IN);

			ns_action_to_dl (T3_NIL, VN6_T305, DISC,
											   STATE_DISCONNECT_INDICATION_12);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OUTGOING_CALL_PROC */

		/* Outgoing call proceeding state */

			/*
			   This state exists for an outgoing call when the user
			   has received acknowledgement that the network has received
			   all call information necessary to effect call establishment.
			*/

void vn6_n3 ()
{
	switch (event_id) {

		case NS_ALERT_RQ :
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_DELIVERED_4);
			break;

		case NS_CONN_RS :
			Send_to_d_channel (CONN);
			Set_state (STATE_ACTIVE_10);
			break;

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_DELIVERED */

		/* Call delivered state */

			/*
			   This state exists for an outgoing call when the calling user
			   has received an indication that the remote user alerting has
			   been initiated.
			*/

void vn6_n4 ()
{
	switch (event_id) {

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		case NS_CONN_RS :
			Send_to_d_channel (CONN);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_PRESENT_6 */

		/* Call present state */

			/*
			   This state exists for an incoming call when the user
			   has received a call establishment request but not yet
			   responded.
			*/

void vn6_n6 ()
{

	if (Call_ces_setup == DL_CES_BROADCAST) {

		switch (event_id) {

			case INT_REL_COMP_IN :
				save_ie_cause ();
				Call_alert (Dl_ces) = OFF;
				break;

			case DA_CONN :
				Release_saved_spdu ();
				ns_action_to_cc (VN6_T303, VN6_T300, NS_CONN_CO,
													 STATE_CONNECT_REQUEST_8);
				Call_ces = Dl_ces;
				break;

			case INT_CALL_PROC_IN :
				ns_action_to_cc (VN6_T303, VN6_T310, NS_CALL_PROC_IN,
													 STATE_INCOMING_CALL_PROC_9);
				break;

			case INT_ALERT_IN :
				Release_saved_spdu ();
				ns_action_to_cc (VN6_T303, VN6_T301, NS_ALERT_IN,
													 STATE_CALL_RECEIVED_7);
				break;

			case DA_SETUP_ACK :
				Release_saved_spdu ();
				ns_action_to_cc (VN6_T303, VN6_T304, NS_SETUP_ACK_IN,
													 STATE_OVERLAP_RECEIVING_25);
				break;

			case TI_303 :

				if (++N303 != MX_N303) {

					switch (Call_sub_state) {

						case N6 :
							Send_saved_spdu_to_d_channel (SETUP);
							Start_timer_ns (VN6_T303);
							Restart_timer_ns (VN6_T312);
							break;

						case N6_REL_COMP :
							Release_saved_spdu ();
							load_ie_cause ();
							Send_to_call_control (NS_CLEAR_IN);
							Set_state (STATE_CALL_ABORT_22);
							break;
					}

				} else {	/* N303 == MX_N303 */

					Release_saved_spdu ();
					load_ie_cause ();
					Send_to_call_control (NS_CLEAR_IN);
					Set_state (STATE_CALL_ABORT_22);

				}

				break;

			default :
				ns_unexpected_ev ();
				break;


		}	/* end switch event_id */

	} else {

		switch (event_id) {

			case DA_SETUP_ACK :
				Release_saved_spdu ();
				ns_action_to_cc (VN6_T303, VN6_T304, NS_SETUP_ACK_IN,
													 STATE_OVERLAP_RECEIVING_25);
				break;

			case DA_CALL_PROC :
				Release_saved_spdu ();
				ns_action_to_cc (VN6_T303, VN6_T310, NS_CALL_PROC_IN,
													 STATE_INCOMING_CALL_PROC_9);
				break;

			case DA_ALERT :
				Release_saved_spdu ();
				ns_action_to_cc (VN6_T303, VN6_T301, NS_ALERT_IN,
													 STATE_CALL_RECEIVED_7);
				break;

			case DA_CONN :
				Release_saved_spdu ();
				ns_action_to_cc (VN6_T303, VN6_T300, NS_CONN_CO,
													 STATE_CONNECT_REQUEST_8);
				Call_ces = Dl_ces;
				break;

			case TI_303 :

				if (++N303 != MX_N303) {
					Send_saved_spdu_to_d_channel (SETUP);
					Start_timer_ns (VN6_T303);

				} else {

					set_i_cause (C_C_NORMAL_EVENT, C_V_NO_USER_RESPONDING_18, P_NIL);
					Send_to_call_control (NS_CLEAR_IN);

					ns_action_to_dl (T3_NIL, VN6_T305, DISC,
													   STATE_DISCONNECT_INDICATION_12);
				}

				break;

			default :
				ns_unexpected_ev ();
				break;


		}

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_RECEIVED */

		/* Call received state */

			/*
			   This state exists for an incomming call when the user has
			   indicated alerting but not yet answered.
			*/

void vn6_n7 ()
{

	if (Call_ces_setup == DL_CES_BROADCAST) {

		switch (event_id) {

			case INT_REL_COMP_IN :
				Call_alert (Dl_ces) = OFF;
				break;

			case DA_CONN :
				Call_ces = Dl_ces;
				ns_action_to_cc (VN6_T301, VN6_T300, NS_CONN_CO,
													 STATE_CONNECT_REQUEST_8);
				break;

			case DA_SETUP_ACK :
				/* no process (already done at the corresponding state_xx_I) */
				break;

			case DA_CALL_PROC :
				/* no process (already done at the corresponding state_xx_I) */
				break;

			case INT_PROGRESS_IN :
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case INT_INFO_IN :
				Send_to_call_control (NS_INFO_IN);
				break;

			case INT_REL_IN :

				if ((vn6_nb_other_active_ces () > 0) ||
					(State_timer_ns (VN6_T312) == ON)) {
					save_ie_cause ();
					return;
				}

					/* no more ces able to proceed and no timer T312 */

				load_ie_cause ();
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
				break;

			case DA_ALERT :
				Set_alert ();
				break;

			case INT_CALL_PROC_IN :
			case INT_ALERT_IN :
					/* no process */
				break;

			case INT_CONN_IN :
				Call_ces = Dl_ces;
				ns_action_to_cc (VN6_T301, VN6_T300, NS_CONN_CO,
													 STATE_CONNECT_REQUEST_8);
				break;

			case DA_PROGRESS :
				Reset_internal_ie ();
				set_i_state (STATE_CALL_PRESENT_6);
				set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
				Send_to_d_channel (STATUS);
				break;

			case TI_301 :

				/*	If the network has received an ALERTING message but does not
					receive a CONNECT or DISCONNECT message before T301 expiry,
					it shall initiate clearing procedures towards the calling user
					with cause #19 "user alerting, no answer" and towards called user(s)
					with cause #102 "recovery on timer expiry". */

				set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "301");
				Vn6_send_to_all_ces (REL, ON);			/* send a REL to all ces which have responded */

				Reset_internal_ie ();
				set_i_cause (C_C_NORMAL_EVENT, C_V_NO_ANSWER_19, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);		/* send NS clear to Layer 4 */
				call_clear ();
				break;

			default :
				ns_unexpected_ev ();
				break;

		}

	}

		/* SETUP was not broadcast */

	else {

		switch (event_id) {

			case DA_CONN :
				ns_action_to_cc (VN6_T301, VN6_T300, NS_CONN_CO,
													 STATE_CONNECT_REQUEST_8);
				break;

			case DA_PROGRESS :
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case TI_301 :

				/*	If the network has received an ALERTING message but does not
					receive a COONECT or DISCONNECT message before T301 expiry,
					it shall initiate clearing procedures towards the calling user
					with cause #19 "user alerting, no answer" and towards called user
					with cause #102 "recovery on timer expiry". */

				set_i_cause (C_C_NORMAL_EVENT, C_V_NO_ANSWER_19, P_NIL);
				Send_to_call_control (NS_CLEAR_IN);

				Reset_internal_ie ();
				set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "301");
				Save_cause ();									/* to send the RELEASE if T305 expire */
				ns_action_to_dl (T3_NIL, VN6_T305, DISC,
												   STATE_DISCONNECT_INDICATION_12);
				break;

			default :
				ns_unexpected_ev ();
				break;

		}

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CONNECT_REQUEST */

		/* Connect request state */

			/*
			   This state exists for an incoming call when the user
			   has answered the call and is waiting to be awarded.
			*/

void vn6_n8 ()
{
	if (Call_ces_setup == DL_CES_BROADCAST) {

		switch (event_id) {

			case INT_REL_COMP_IN :
				Call_alert (Dl_ces) = OFF;
				break;

			case DA_ALERT :
			case DA_CONN :
			case DA_SETUP_ACK :
			case DA_CALL_PROC :
				Stop_int_timer (VN6_T304I);
				Reset_internal_ie	();
/*$*/			set_i_cause	(C_C_NORMAL_EVENT, C_V_CALL_REJECT_21, P_NIL);
				Send_to_d_channel (REL);
				break;

			case INT_CALL_PROC_IN :
			case INT_ALERT_IN :
			case INT_CONN_IN :
				/* no process */
				break;

			case INT_REL_IN :

				if (Dl_ces == Call_ces) {
					Vn6_send_to_all_ces (REL, OFF);

					if (State_timer_ns (VN6_T312) == ON) {
						Send_to_call_control (NS_CLEAR_IN);
						Set_state (STATE_CALL_ABORT_22);

					} else {

						Send_to_call_control (NS_CLEAR_CO);
						call_clear ();
					}

					return;
				}

				/* else no process */

				break;

			case NS_CONN_RS :
				Stop_timer_ns (VN6_T300);
				Call_ces = Dl_ces;
				Send_to_d_channel (CONN_ACK);
				Set_int_ces_state (STATE_0_I);
				vn6_send_to_other_ces (REL, OFF);
				Set_state (STATE_ACTIVE_10);
				break;

			case INT_INFO_IN :
				Send_to_call_control (NS_INFO_IN);
				break;

			case INT_PROGRESS_IN :
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case TI_300 :
				set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, P_NIL);
				Save_cause ();									/* to send the RELEASE if T305 expire */
				Send_to_call_control (NS_CLEAR_IN);

				ns_action_to_dl (T3_NIL, VN6_T305, DISC,
												   STATE_DISCONNECT_INDICATION_12);
				break;

			default :
				ns_unexpected_ev ();
				break;

		}

	} else {

		switch (event_id) {

			case NS_CONN_RS :
				ns_action_to_dl (VN6_T300, T3_NIL, CONN_ACK,
												   STATE_ACTIVE_10);
				break;

			case TI_300 :
				set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, P_NIL);
				Save_cause ();									/* to send the RELEASE if T305 expire */
				Send_to_call_control (NS_CLEAR_IN);

				ns_action_to_dl (T3_NIL, VN6_T305, DISC,
												   STATE_DISCONNECT_INDICATION_12);
				break;

			default :
				ns_unexpected_ev ();
				break;

		}

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_INCOMING_CALL_PROCEEDING */

		/* Incoming call proceeding state */

			/*
			   This state exists for an incoming call when the user has
			   sent acknowlegdement that the user has received all call
			   information necessary to effect call establishment.
			*/

void vn6_n9 ()
{

	if (Call_ces_setup == DL_CES_BROADCAST) {

		switch (event_id) {

			case DA_FAC :
				Send_to_call_control (NS_SPF_FACILITY_IN);
				break;

			case DA_ALERT :
			case INT_ALERT_IN :
				ns_action_to_cc (VN6_T310, VN6_T301, NS_ALERT_IN,
													 STATE_CALL_RECEIVED_7);
				break;

			case DA_CALL_PROC :
				/* no process (already done at the corresponding STATE_0_I) */
				break;

			case DA_CONN :
				Stop_timer_ns (VN6_T310);
				Send_to_call_control (NS_CONN_CO);
				Start_timer_ns (VN6_T300);
				Call_ces = Dl_ces;
				Set_state (STATE_CONNECT_REQUEST_8);
				break;

			case INT_CONN_IN :
				Stop_timer_ns (VN6_T310);
				Send_to_call_control (NS_CONN_CO);
				Set_state (STATE_CONNECT_REQUEST_8);
				break;

			case INT_REL_COMP_IN :
				Call_alert (Dl_ces) = OFF;
				break;

			case INT_CALL_PROC_IN :
				/* no process */
				break;

			case DA_PROGRESS :
				Stop_timer_ns (VN6_T310);
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case DA_SETUP_ACK:
/*$*/			send_state (C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, DIAGNOSTIC_NIL);
				break;

			case INT_INFO_IN :
				Send_to_call_control (NS_INFO_IN);
				break;

			case INT_PROGRESS_IN :
				Stop_timer_ns (VN6_T310);
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case TI_310 :
				Vn6_send_to_all_ces (REL, OFF);

				if (State_timer_ns (VN6_T312) == ON) {
					Send_to_call_control (NS_CLEAR_IN);
					Set_state (STATE_CALL_ABORT_22);

				} else {

					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
				}

				break;

		}       /* end switch */

	} else {    /* ces was not broadcast */

		switch (event_id) {

			case DA_ALERT :
				ns_action_to_cc (VN6_T310, VN6_T301, NS_ALERT_IN,
													 STATE_CALL_RECEIVED_7);
				break;

			case DA_CONN :
				ns_action_to_cc (VN6_T310, VN6_T300, NS_CONN_CO,
													 STATE_CONNECT_REQUEST_8);
				break;

			case DA_PROGRESS :
				Stop_timer_ns (VN6_T310);
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case TI_310 :
				set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "310");
				Send_to_call_control (NS_CLEAR_IN);

				ns_action_to_dl (T3_NIL, VN6_T305, DISC,
												   STATE_DISCONNECT_INDICATION_12);
				break;

			default :
				ns_unexpected_ev ();
				break;
		}
	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_ACTIVE */

		/* Active state */

			/*
			   This state exists if an incoming call when the user has
			   received an ackknowledgement from the network that the user
			   has been awarded the call. This state exists for an outgoing
			   call when the user has received an indication that the remote
			   user has answered the call.
			*/

void vn6_n10 ()
{

	switch (event_id) {

		case DA_CONN_ACK :
			/* no process */
			break;

		case DA_SUSP :

			if (Na_type == BRI) {
				ns_action_to_cc (T3_NIL, VN6_T300, NS_SUSPEND_IN,
												   STATE_SUSPEND_REQUEST_15);
			} else {

				ns_unexpected_ev ();
			}

			break;

		case NS_NOTIFY_RQ :
			Send_to_d_channel (NOTIFY);
			break;

		case DA_NOTIFY :
			Send_to_call_control (NS_NOTIFY_IN);
			break;


		case INT_REL_COMP_IN :

			if (Call_ces_setup == DL_CES_BROADCAST) {
				Call_alert (Dl_ces) = OFF;
			}

#			if ASSERT == ON

				else {
					Trap (TRAP_NS_BROADCAST, "n10 -> INT_REL_COMP_IN");
				}

#			endif

			break;

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

#		if NS_T309 == ON
			case TI_309 :
				set_i_cause (C_C_NORMAL_EVENT, C_V_DEST_OUT_OF_ORDER_27, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
				break;
#		endif

		default :
			ns_unexpected_ev ();
			break;

	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_REQUEST */

		/* Disconnect request state */

			/*
			   This state exists when the user has requested the network
			   to clear the end-to-end connection (if any) and is waiting
			   for a response.
			*/

void vn6_n11 ()
{

	switch (event_id) {

		case NS_CLEAR_RS :
			Stop_timer_ns (VN6_T300);
			disc_cause_error ();
			go_to_state_19 (VN6_T308);
			break;

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case INT_REL_COMP_IN :

			Call_alert (Dl_ces) = OFF;

			if (Call_ces_connect == Dl_ces) {
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}

			break;


		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case TI_300 :

			if (disc_cause_error () == NOK) {
				set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
			}

			go_to_state_19 (VN6_T308);
			break;

		default :
			ns_unexpected_ev ();
			break;
	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_INDICATION */

		/* Disconnect indication state */

			/*
			   This state exists when the user has received an invitation
			   to disconnect because the network has disconnected the
			   end-to-end connection (if any).
			*/

void vn6_n12 ()
{
	switch (event_id) {

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case INT_REL_COMP_IN :

			Call_alert (Dl_ces) = OFF;

			if (Call_ces_connect == Dl_ces) {
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}

			break;

		case TI_305 :
			go_to_state_19 (VN6_T308);
			break;

		case NS_CLEAR_RS :
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE SUSPEND_REQUEST */

		/* Suspend request state */

			/*
			   This state exists  after the user has requested the network
			   to suspend the call and is waiting for a response.
			*/

void vn6_n15 ()
{
	switch (event_id) {

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case NS_SUSPEND_RS :
			Stop_timer_ns (VN6_T300);

			if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {
				Send_to_d_channel (SUSP_REJ);
				Set_state (STATE_ACTIVE_10);

			} else {

				Send_to_d_channel (SUSP_ACK);
				call_clear ();
			}

			break;

		case NS_NOTIFY_RQ :
			Send_to_d_channel (NOTIFY);
			break;

		case TI_300 :
			set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, P_NIL);
			Send_to_d_channel (SUSP_REJ);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RESUME_REQUEST_17 */

		/* Resume request state */

			/*
			   This state exists  after the user has requested the network
			   to resume a previously suspend call and is waiting for a
			   response.
			*/

void vn6_n17 ()
{
	switch (event_id) {

		case NS_RESUME_RS :
			Stop_timer_ns (VN6_T300);

			if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {
				Send_to_d_channel (RES_REJ);
				call_clear ();

			} else {

				Send_to_d_channel (RES_ACK);
				Set_state (STATE_ACTIVE_10);
			}

			break;

		case TI_300 :
			set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, P_NIL);
			Send_to_d_channel (SUSP_REJ);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RELEASE_REQUEST */

		/* Release request state */

			/*
			   This state exists when the user has requested the network
			   to release and is waiting for a response.
			*/

void vn6_n19 ()
{
	switch (event_id) {

		case NS_SPF_FACILITY_RS :

			if (is_ie_i (CODESET_0, CAUSE) != PRESENT) {
				Send_to_d_channel (FT_FAC_ACK);

			} else {

				Send_to_d_channel (FT_FAC_REJ);
			}

			break;

		case DA_FAC :
			Send_to_call_control (NS_SPF_FACILITY_IN);
			break;

		case INT_REL_COMP_IN :

			if (Call_ces_setup == DL_CES_BROADCAST) {
				Call_alert (Dl_ces) = OFF;

				if (Call_ces_connect == Dl_ces) {
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
				}
			}

			break;

		case INT_INFO_IN :

			if (Call_ces_setup == DL_CES_BROADCAST) {
				Send_to_call_control (NS_INFO_IN);
			}

#			if ASSERT == ON

				else {
					Trap (TRAP_NS_BROADCAST, "n10 -> INT_INFO_IN");
				}

#			endif

			break;

		case TI_308 :
			if (++N308 < MX_N308) {
				Send_saved_spdu_to_d_channel (REL);
				Restart_timer_ns (VN6_T308);

			} else {

				set_i_cause (C_C_TIMER, C_V_T308, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}

			break;

		case NS_CLEAR_RS :

			break;		/* ignore */

		default :
			ns_unexpected_ev ();
			break;
	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_ABORT*/
		/* Call abort */

			/*
				This state exists only when setup was broadcast
			*/

void vn6_n22 ()
{

	if (Call_ces_setup == DL_CES_BROADCAST) {

		switch (event_id) {

			case DA_ALERT :
			case DA_CONN :
			case DA_CALL_PROC :
			case DA_SETUP_ACK :
			case NS_CLEAR_RS :
				break;

			case INT_REL_COMP_IN :
				Call_alert (Dl_ces) = OFF;

				if (vn6_nb_other_active_ces () == 0) {

						/* no more ces able to proceed */

					load_ie_cause ();
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
				}

				break;

			default :
				ns_unexpected_ev ();
				break;
		}
	}

#	if ASSERT == ON

		else {
			Trap (TRAP_NS_BROADCAST, "n10 -> INT_INFO_IN");
	}

#	endif


}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_RECEIVING */

		/* Overlap receiving */

			/*
			   This state exits for an incoming call when the user
			   has acknowledged the call establishment request from
			   the network and is prepared to received additional call
			   information (if any) in overlap mode.
			*/

void vn6_n25 ()
{
	if (Call_ces_setup == DL_CES_BROADCAST) {

		switch (event_id) {

			case DA_SETUP_ACK :

				if (Call_setup_ack > MX_INT_PROC) {
					Start_int_timer (VN6_T308I);
					Send_to_d_channel_and_save_spdu (REL);
					Set_int_ces_state (STATE_19_I);

				} else {

					Start_int_timer (VN6_T304I);
					Set_int_ces_state (STATE_25_I);
					Send_to_d_channel (INFO);
				}

				break;

			case NS_SETUP_ACK_RQ :
				Stop_timer_ns (VN6_T304);
/*$*/			Vn6_send_to_all_ces (INFO, ON);
				Start_timer_ns (VN6_T304);
				break;

			case INT_ALERT_IN :
				Stop_timer_ns (VN6_T304);
				Send_to_call_control (NS_ALERT_IN);
				Start_timer_ns (VN6_T301);
				Set_state (STATE_CALL_RECEIVED_7);
				break;

			case INT_REL_COMP_IN :
				Call_alert (Dl_ces) = OFF;
				break;

			case INT_CALL_PROC_IN :
				Stop_timer_ns (VN6_T304);
				Send_to_call_control (NS_CALL_PROC_IN);
				Start_timer_ns (VN6_T310);
				Set_state (STATE_INCOMING_CALL_PROC_9);
				break;

			case INT_CONN_IN  :
				Stop_timer_ns (VN6_T304);
				Send_to_call_control (NS_CONN_CO);
				Set_state (STATE_CONNECT_REQUEST_8);
				break;

			case INT_INFO_IN :
				Send_to_call_control (NS_INFO_IN);
				break;

			case INT_PROGRESS_IN :
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case INT_REL_IN :

				if ((vn6_nb_other_active_ces () > 0) ||
					(State_timer_ns (VN6_T312) == ON)) {
					save_ie_cause ();
					return;
				}

				load_ie_cause ();
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
				break;

			case DA_ALERT :
				Stop_timer_ns (VN6_T304);
				Send_to_call_control (NS_ALERT_IN);
				Start_timer_ns (VN6_T301);
				Set_state (STATE_CALL_RECEIVED_7);
				break;

			case DA_CONN :
				Stop_timer_ns (VN6_T304);
				Send_to_call_control (NS_CONN_CO);
				Set_state (STATE_CONNECT_REQUEST_8);
				break;

			case DA_PROGRESS :
				Reset_internal_ie ();
				set_i_state (STATE_CALL_PRESENT_6);
				set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
				Send_to_d_channel (STATUS);
				break;

			case DA_CALL_PROC :
				ns_action_to_cc (VN6_T304, VN6_T310, NS_CALL_PROC_IN,
													 STATE_INCOMING_CALL_PROC_9);
				break;

			case TI_304 :
				Vn6_send_to_all_ces (REL, OFF);
				load_ie_cause ();

				if (State_timer_ns (VN6_T312) == ON) {
					Send_to_call_control (NS_CLEAR_IN);
					Set_state (STATE_CALL_ABORT_22);

				} else {

					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
				}

				break;

		}

	} else {	/* ces was not broadcast */

		switch (event_id) {

			case NS_INFO_RQ :
				Send_to_d_channel (INFO);
				Restart_timer_ns (VN6_T304);
				break;

			case DA_ALERT :
				ns_action_to_cc (VN6_T304, VN6_T301, NS_ALERT_IN,
													 STATE_CALL_RECEIVED_7);
				break;

			case DA_CONN :
				ns_action_to_cc (VN6_T304, VN6_T300, NS_CONN_CO,
													 STATE_CONNECT_REQUEST_8);
				break;

			case DA_PROGRESS :
				Send_to_call_control (NS_PROGRESS_IN);
				break;

			case DA_CALL_PROC :
				ns_action_to_cc (VN6_T304, VN6_T310, NS_CALL_PROC_IN,
													 STATE_INCOMING_CALL_PROC_9);
				break;

			case TI_304 :
				set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "304");
				Send_to_call_control (NS_CLEAR_IN);

				ns_action_to_dl (T3_NIL, VN6_T305, DISC,
												   STATE_DISCONNECT_INDICATION_12);
				break;
		}

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_REGISTRATION_REQUEST_254 */

		/* A registration resquest has been received. */

void vn6_n254 ()
{
	switch (event_id) {

		case NS_SPF_REGISTRATION_RS :

			if (is_ie_i (CODESET_0, CAUSE) == PRESENT) {
				Send_to_d_channel (FT_REG_REJ);

			} else {

				Send_to_d_channel (REG_ACK);
			}

			call_clear ();
			break;

		case TI_300 :
			set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, (char FAR *) &Call_state);
			Send_to_d_channel (FT_REG_REJ);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}
/*==============  INTERNAL STATE FOR INDIVIDUAL TERMINALS	============*/
/*==============			MULTIPOINT ONLY					============*/

		/* STATE_NULL */

			/*
			   No call exists : used when a call context is
			   allocated to a call or a registration.
			*/

void vn6_n0i ()
{

	switch (event_id) {

		case DA_ALERT :

			Release_saved_spdu ();							/* saved setup no more useful */
			Dl_call_count++;

			if ((Call_state == STATE_CONNECT_REQUEST_8) ||
				(Call_state == STATE_CALL_ABORT_22)) {
				event_id = INT_REL_RQ;

			} else {

				Set_int_ces_state (STATE_7_I);
				Call_alert (Dl_ces) = ON;
				event_id = INT_ALERT_IN;
			}

			break;

		case DA_SETUP_ACK :

			Release_saved_spdu ();							/* saved setup no more useful */
			Dl_call_count++;

			if ((Call_state == STATE_CONNECT_REQUEST_8) ||
				(Call_state == STATE_CALL_ABORT_22)) {
				event_id = INT_REL_RQ;

			} else {

				Start_int_timer (VN6_T304I);
				Call_setup_ack++;
				Set_int_ces_state (STATE_25_I);
			}

			break;

		case DA_CALL_PROC :

			Release_saved_spdu ();							/* saved setup no more useful */
			Dl_call_count++;

			if ((Call_state == STATE_CONNECT_REQUEST_8) ||
				(Call_state == STATE_CALL_ABORT_22)) {
				event_id = INT_REL_RQ;

			} else {

				Start_int_timer (VN6_T310I);
				Set_int_ces_state (STATE_9_I);
				event_id = INT_CALL_PROC_IN;
			}

			break;

		case DA_CONN :

			Release_saved_spdu ();							/* saved setup no more useful */
			Dl_call_count++;

			if ((Call_state == STATE_CONNECT_REQUEST_8) ||
				(Call_state == STATE_CALL_ABORT_22)) {
				event_id = INT_REL_RQ;

			} else {

				Set_int_ces_state (STATE_8_I);
			}

			break;

		case DA_REL :
			Send_to_d_channel (REL_COMP);
		case DA_REL_COMP :
			event_id = INT_REL_COMP_IN;
			break;

		default :
				/*	Other primitives : process only the SPDU received from network (other events are processed elsewhere)
					This internal state can result from
						1) first response of a terminal
						2) response of the selected terminal (that has already sent CONNECT so that internal state has been reset)
						In first case, the primitive is UNEXPECTED (all expected primitives are the ones above)
						In second case, the primitive is to be processed by global call process (continue)
					Both cases are distinguished using the ces on which the CONNECT was received if any (Call_ces_connect)
				*/

			if (i_entity_origination == ENT_DL_D) {

				if ((Call_ces_connect == NIL) || (Call_ces_connect != Dl_ces)) {

					ns_unexpected_ev ();		/* unexpected primitive */
					event_id = EV_NIL;			/* reset event ID to stop process */
				}
			}

			break;
	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_RECEIVED */

		/* Call received state */

			/*
			   This state exists for an incomming call when the user has
			   indicated alerting but not yet answered.
			*/

void vn6_n7i ()
{
	switch (event_id) {

		case DA_DISC :
			event_id = INT_REL_IN;
			Send_to_d_channel_and_save_spdu (REL);
			Start_int_timer (VN6_T308I);
			Set_int_ces_state (STATE_19_I);
			Call_alert (Dl_ces) = OFF;
			break;

		case DA_REL_COMP :
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_REL :
			Send_to_d_channel (REL_COMP);
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_CONN :
			Set_int_ces_state (STATE_8_I);
			break;

		case INT_INFO_RQ :
			Send_to_d_channel (INFO);
				break;

		case DA_PROGRESS :
			event_id = INT_PROGRESS_IN;
			break;

		case DA_INFO :
			event_id = INT_INFO_IN;
			break;

		default :
				/*	Other primitives : process only the SPDU received from network
					(other events are processed elsewhere). They are UNEXPECTED
					(all expected primitives are the ones above) */

			if (i_entity_origination == ENT_DL_D) {

				ns_unexpected_ev ();		/* unexpected primitive */
				event_id = EV_NIL;			/* reset event ID to stop process */
			}

			break;
	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_CONNECT_REQUEST */

		/* Connect request state */

			/*
			   This state exists for an incoming call when the user
			   has answered the call and is waiting to be awarded.
			*/

void vn6_n8i ()
{
	switch (event_id) {

		case DA_DISC :
			event_id = INT_REL_IN;
			Send_to_d_channel_and_save_spdu (REL);
			Start_int_timer (VN6_T308I);
			Set_int_ces_state (STATE_19_I);
			Call_alert (Dl_ces) = OFF;
			break;

		case DA_REL_COMP :
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_REL :
			Send_to_d_channel (REL_COMP);
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case INT_END_PROCESS :
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case INT_INFO_RQ :
			Send_to_d_channel (INFO);
			break;

		case DA_INFO :
			event_id = INT_INFO_IN;
			break;
	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_INCOMING_CALL_PROCEEDING */

		/* Incoming call proceeding state */

			/*
			   This state exists for an incoming call when the user has
			   sent acknowlegdement that the user has received all call
			   information necessary to effect call establishment.
			*/

void vn6_n9i () {

	switch (event_id) {

		case DA_DISC :
			Stop_int_timer (VN6_T310I);
			event_id = INT_REL_IN;
			Send_to_d_channel_and_save_spdu (REL);
			Start_int_timer (VN6_T308I);
			Set_int_ces_state (STATE_19_I);
			Call_alert (Dl_ces) = OFF;
			break;

		case TI_310I :
			event_id = INT_REL_IN;
			Send_to_d_channel_and_save_spdu (REL);
			Start_int_timer (VN6_T308I);
			Set_int_ces_state (STATE_19_I);
			break;

		case DA_REL_COMP :
			Stop_int_timer (VN6_T310I);
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_REL :
			Stop_int_timer (VN6_T310I);
			Send_to_d_channel (REL_COMP);
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_ALERT :
			Stop_int_timer (VN6_T310I);
			event_id = INT_ALERT_IN;
			Set_int_ces_state (STATE_7_I);
			Call_alert (Dl_ces) = ON;
			break;

		case DA_CONN :
			Stop_int_timer (VN6_T310I);
			event_id = INT_CONN_IN;
			Set_int_ces_state (STATE_8_I);
			break;

		case INT_INFO_RQ :
			Send_to_d_channel (INFO);
			break;

		case DA_INFO :
			event_id = INT_INFO_IN;
			break;

		case DA_PROGRESS :
			Stop_int_timer (VN6_T310I);
			event_id = INT_PROGRESS_IN;
			break;

		default :
				/*	Other primitives : process only the SPDU received from network
					(other events are processed elsewhere). They are UNEXPECTED
					(all expected primitives are the ones above) */

			if (i_entity_origination == ENT_DL_D) {

				ns_unexpected_ev ();		/* unexpected primitive */
				event_id = EV_NIL;			/* reset event ID to stop process */
			}

			break;
	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_RELEASE_REQUEST */

		/* Release request state */

			/*
			   This state exists when the user has requested the network
			   to release and is waiting for a response.
			*/

void vn6_n19i ()
{
	switch (event_id) {

		case DA_REL_COMP :
			Stop_int_timer (VN6_T308I);
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_REL :
			Stop_int_timer (VN6_T308I);
			Send_to_d_channel (REL_COMP);
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_DISC :
			/* no process */
			break;

		case TI_308I :

			if (++R_msg_inf0 < MX_N308) {
				set_i_cause         (C_C_NORMAL_EVENT, C_V_NON_SELECTED_USER_CLEARING_26, P_NIL);
				Send_to_d_channel   (REL);
				Restart_int_timer	(VN6_T308I, R_msg_inf0);
				event_id = EV_NIL;	/* no more actions */

			} else {

				event_id = INT_REL_COMP_IN;
				Set_int_ces_state (STATE_0_I);

				if (Dl_call_count > 0) {

					Dl_call_count--;
				}
			}

			ns_dl_timer_activity ();
			break;

		case DA_INFO :
				/* no process */
			break;

	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_RECEIVING */

		/* Overlap receiving */

			/*
			   This state exits for an incoming call when the user
			   has acknowledged the call establishment request from
			   the network and is prepared to received additional call
			   information (if any) in overlap mode.
			*/

void vn6_n25i ()
{
	switch (event_id) {

		case INT_INFO_RQ :
			Stop_int_timer (VN6_T304I);
			Send_to_d_channel (INFO);
			Start_int_timer (VN6_T304I);
			break;

		case DA_ALERT :
			Stop_int_timer (VN6_T304I);
			event_id = INT_ALERT_IN;
			Set_int_ces_state (STATE_7_I);
			Call_alert (Dl_ces) = ON;
			break;

		case DA_CONN :
			Stop_int_timer (VN6_T304I);
			event_id = INT_CONN_IN;
			Set_int_ces_state (STATE_8_I);
			break;

		case DA_CALL_PROC :
			Stop_int_timer (VN6_T304I);
			event_id = INT_CALL_PROC_IN;
			Start_int_timer (VN6_T310I);
			Set_int_ces_state (STATE_9_I);
			break;

		case DA_PROGRESS :
			Stop_int_timer (VN6_T304I);
			event_id = INT_PROGRESS_IN;
			break;

		case DA_REL :
			Stop_int_timer (VN6_T304I);
			Send_to_d_channel (REL_COMP);
			event_id = INT_REL_COMP_IN;
			Set_int_ces_state (STATE_0_I);

			if (Dl_call_count > 0) {

				Dl_call_count--;
			}

			ns_dl_timer_activity ();
			break;

		case DA_REL_COMP :
		case DA_DISC :
			Stop_int_timer (VN6_T304I);

				/* no 'break' -> continue to process in 'case' below */

		case TI_304I :
			event_id = INT_REL_IN;
			Send_to_d_channel_and_save_spdu (REL);
			Start_int_timer (VN6_T308I);
			Set_int_ces_state (STATE_19_I);
			break;
	}

}

#endif

/*EOF*/

