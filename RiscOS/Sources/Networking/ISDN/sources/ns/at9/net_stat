
/*--------------------------------------------------------------------------*
 *						M O D U L E		H E A D E R
 *
 * filename - net_state.at9
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		u0 to u19 - user side - implements the processing of an event
 *					 according to the state of the call (u0 to u254).
 *
 *		n0 to n19 - network side - implements the processing of an event
 *					 according to the state of the call (n0 to n254).
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Network Signalling (NS) Entity                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/


#if AT9_SUPPLEMENTARY_SERVICES == ON

#	if NEW_FCT_STYLE == ON
		void at9_supp_services_switch (void);
#	else
		void at9_supp_services_switch ();
#	endif

#endif
						/*--------------*/
						/*				*/
						/*	USER SIDE	*/
						/*		U		*/
						/*--------------*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N	H E A D E R

Name			 u0 to u254 - user side - implements the processing of an
							  event according to the call state.

Usage			void uxx (void);

Related
functions usage void Stop_timer_ns (uchar x_timer);

				void Start_timer_ns (uchar x_timer);
						- x_timer : timer index.

				void Send_to_d_channel (uchar spdu_id);
						- spdu_id : spdu message type (ID).

				void Send_to_call_control (uchar ssdu_id);
						- ssdu_id : ssdu primitive code (ID).

				void Set_state (uchar call_state);
						- call_state : state of the call.

				void call_clear (void);

				void ns_unexpected_ev (void);

Return value	void

Common constants and declarations : ns.h

Common objects : call and na object, internal data structure.

*-------------------------------------------------------------------------*/

		/* STATE_NULL_0 */

		/* Null state */

			/*
				No call exists : used when a call context is
				allocated to a call
			*/

void at9_u0 ()
{

	switch (event_id) {

		case DA_SETUP:
			Call_chan_id_sel	= I_(chan_id,	chan_sel);	/* CHAN_ID is mandatory and so present */
			Call_bc_trf_cap		= I_(bc,		trf_cap);	/* BC is mandatory and so present */
			Send_to_call_control (NS_CONN_IN);
			Set_state (STATE_CALL_PRESENT_6);
			Start_timer_ns (AT9_T300);
			break;

		case NS_CONN_RQ :

			if (is_ie_i (CODESET_0, CHAN_ID) == PRESENT) {
				Call_chan_id_sel = I_(chan_id, chan_sel);

			} else {

				Call_chan_id_sel = ANY_CHAN;
			}

			Call_bc_trf_cap		= I_(bc,		trf_cap);	/* BC is mandatory and so present */
			Send_to_d_channel_and_save_spdu (SETUP);
			Set_state (STATE_CALL_INIT_1);
			N303 = 0;
			Start_timer_ns (AT9_T303);
			break;


		default :

#			if AT9_SUPPLEMENTARY_SERVICES == ON

				at9_supp_services_switch ();

#			else

				ns_unexpected_ev ();

#			endif

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_INIT_1 */

		/* Call initialization state */

			/*
				This state exists for an outgoing call, as a result of user
				action requesting call establishment from the network.
			*/

void at9_u1 ()
{
	switch (event_id) {

		case DA_CALL_PROC :				/* call is in en-bloc sending mode */
			Release_saved_spdu ();		/* saved setup no more useful */
			Stop_timer_ns (AT9_T303);
			Start_timer_ns (AT9_T310);
			Send_to_call_control (NS_CALL_PROC_IN);
			Set_state (STATE_OUTGOING_CALL_PROC_3);
			break;

		case DA_SETUP_ACK :				/* call is in overlap sending mode */
			Release_saved_spdu ();		/* saved setup no more useful */
			Stop_timer_ns (AT9_T303);
			Send_to_call_control (NS_SETUP_ACK_IN);
			Set_state (STATE_OVERLAP_SENDING_2);
			break;

		case DA_PROGRESS :

			if (Na_type == BRI) {
				Send_to_call_control (NS_PROGRESS_IN);

			} else {

				ns_unexpected_ev ();

			}

			break;

		case TI_303 :

			if ((Na_type == PRI) && (++N303 < MX_N303)) {
				Send_saved_spdu_to_d_channel (SETUP);
				Restart_timer_ns (AT9_T303);

			} else {

				set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, DIAGNOSTIC_NIL);
				Send_to_d_channel (REL_COMP);
				Reset_internal_ie ();
				set_i_cause (C_C_TIMER, C_V_T303, DIAGNOSTIC_NIL);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_SENDING_2 */

		/* Overlap sending state */

			/*
				This state exists for an outgoing call when the user has
				received acknowledgement of the call establishment request
				which permits the user to send additional call information
				to the network in overlap mode.
			*/

void at9_u2 ()
{
	switch (event_id) {

		case DA_ALERT :
			Send_to_call_control (NS_ALERT_IN);
			Set_state (STATE_CALL_DELIVERED_4);
			break;

		case DA_CALL_PROC :
			Send_to_call_control (NS_CALL_PROC_IN);
			Start_timer_ns (AT9_T310);
			Set_state (STATE_OUTGOING_CALL_PROC_3);
			break;

		case DA_CONN :
			Send_to_call_control (NS_CONN_CO);
			Reset_internal_ie ();
			Send_to_d_channel (CONN_ACK);		/* optional */
			Set_state (STATE_ACTIVE_10);
			break;

		case DA_PROGRESS :
			Send_to_call_control (NS_PROGRESS_IN);
			break;

		default :
			ns_unexpected_ev ();
			break;
	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OUTGOING_CALL_PROC_3 */

		/* Outgoing call proceeding state */

			/*
				This state exists for an outgoing call when the user
				has received acknowledgement that the network has received
				all call information necessary to effect call establishment.
			*/

void at9_u3 ()
{
	switch (event_id) {

		case DA_ALERT :
			Stop_timer_ns (AT9_T310);
			Send_to_call_control (NS_ALERT_IN);
			Set_state (STATE_CALL_DELIVERED_4);
			break;

		case DA_CONN :
			Stop_timer_ns (AT9_T310);
			Send_to_call_control (NS_CONN_CO);
			Reset_internal_ie ();
			Send_to_d_channel (CONN_ACK);		/* optional */
			Set_state (STATE_ACTIVE_10);
			break;

		case DA_PROGRESS :

				/* PROGRESS_IND IE is mandatory and so present */

			if (I_progress_ind_description != PROGRESS_DESCR_IN_BAND_NOW) {
				Stop_timer_ns (AT9_T310);		/* only in case of interworking */
			}

			Send_to_call_control (NS_PROGRESS_IN);

			if (Na_type == PRI) {
				Set_state (STATE_CALL_DELIVERED_4);
			}

			break;

		case TI_310 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, DIAGNOSTIC_NIL);
			ns_action_to_dl (T3_NIL, AT9_T305, DISC,
											   STATE_DISCONNECT_REQUEST_11);
			break;


		default :

#			if AT9_SUPPLEMENTARY_SERVICES == ON

				at9_supp_services_switch ();

#			else

				ns_unexpected_ev ();

#			endif

			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_DELIVERED_4 */

		/* Call delivered state */

			/*
				This state exists for an outgoing call when the calling user
				has received an indication that the remote user alerting has
				been initiated.
			*/

void at9_u4 ()
{
	switch (event_id) {

		case DA_CONN :
			Send_to_call_control (NS_CONN_CO);
			Reset_internal_ie ();
			Send_to_d_channel (CONN_ACK);		/* optional */
			Set_state (STATE_ACTIVE_10);
			break;

		case DA_PROGRESS :
			Send_to_call_control (NS_PROGRESS_IN);
			break;

		case TI_310 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, DIAGNOSTIC_NIL);
			ns_action_to_dl (T3_NIL, AT9_T305, DISC,
											   STATE_DISCONNECT_REQUEST_11);
			break;

		default :

#			if AT9_SUPPLEMENTARY_SERVICES == ON

				at9_supp_services_switch ();

#			else

				ns_unexpected_ev ();

#			endif

			break;
	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_PRESENT_6 */

		/* Call present state */

			/*
				This state exists for an incoming call when the user
				has received a call establishment request but not yet
				responded.
			*/

void at9_u6()
{
	switch (event_id) {

		/* case DA_SETUP is managed in error_handler : SETUP ignored */

		case NS_ALERT_RQ :
			Stop_timer_ns (AT9_T300);
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_RECEIVED_7);
			break;

		case NS_CONN_RS :
			Stop_timer_ns (AT9_T300);
			Send_to_d_channel_and_save_spdu (CONN);

			if (Na_type == PRI) {
				N313 = 0;
				Start_timer_ns (AT9_T313);
			}

			Set_state (STATE_CONNECT_REQUEST_8);
			break;

		case NS_CALL_PROC_RQ :
			Stop_timer_ns (AT9_T300);

				/* this message shall include a CHAN_ID with Exclusive
					B channel indicated */

			Send_to_d_channel (CALL_PROC);
			Set_state (STATE_INCOMING_CALL_PROC_9);
			break;

		case TI_300 :
			set_i_cause (C_C_INVALID_MESSAGE, C_V_INCOMPATIBLE_DESTINATION_88, P_NIL);
			Send_to_d_channel (REL_COMP);
			Reset_internal_ie ();

			set_i_cause (C_C_TIMER, C_V_T300, P_NIL);
			Send_to_call_control (NS_CLEAR_CO);
			call_clear ();
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_RECEIVED_7 */

		/* Call received state */

			/*
				This state exists for an incomming call when the user has
				indicated alerting but not yet answered.
			*/

void at9_u7 ()
{
	switch (event_id) {

		/* case DA_SETUP is managed in error_handler : SETUP ignored */

		case NS_CONN_RS :
			Send_to_d_channel_and_save_spdu (CONN);

			if (Na_type == PRI) {
				N313 = 0;
				Start_timer_ns (AT9_T313);
			}

			Set_state (STATE_CONNECT_REQUEST_8);
			break;

		default :

#			if AT9_SUPPLEMENTARY_SERVICES == ON

				at9_supp_services_switch ();

#			else

				ns_unexpected_ev ();

#			endif

			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CONNECT_REQUEST_8 */

		/* Connect request state */

			/*
				This state exists for an incoming call when the user
				has answered the call and is waiting to be awarded.
			*/

void at9_u8 ()
{
	switch (event_id) {

		/* case DA_SETUP is managed in error_handler : SETUP ignored */

		case DA_CONN_ACK :
			Release_saved_spdu ();		/* saved CONN no more useful */
			Stop_timer_ns (AT9_T313);
			Send_to_call_control (NS_CONN_CO);
			Set_state (STATE_ACTIVE_10);
			break;

		case TI_313 :

#			if NS_TYPE_PRI == ON

				if (Na_type == PRI) {

					Release_saved_spdu ();		/* saved CONN no more useful */
					set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, DIAGNOSTIC_NIL);
					ns_action_to_dl (T3_NIL, AT9_T305, DISC,
												   STATE_DISCONNECT_REQUEST_11);
					break;
				}

#			endif

		default :

#			if AT9_SUPPLEMENTARY_SERVICES == ON

				at9_supp_services_switch ();

#			else

				ns_unexpected_ev ();

#			endif

			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_INCOMING_CALL_PROC_9 */

		/* Incoming call proceeding state */

			/*
				This state exists for an incoming call when the user has
				sent acknowlegdement that the user has received all call
				information necessary to effect call establishment.
			*/

void at9_u9 ()
{
	switch (event_id) {

		/* case DA_SETUP is managed in error_handler : SETUP ignored */

		case NS_CONN_RS :
			Send_to_d_channel_and_save_spdu (CONN);

			if (Na_type == PRI) {
				N313 = 0;
				Start_timer_ns (AT9_T313);
			}

			Set_state (STATE_CONNECT_REQUEST_8);
			break;

		case NS_ALERT_RQ :
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_RECEIVED_7);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_ACTIVE_10 */

		/* Active state */

			/*
				This state exists if an incoming call when the user has
				received an acknowledgement from the network that the user
				has been awarded the call. This state exists for an outgoing
				call when the user has received an indication that the remote
				user has answered the call.
			*/

void at9_u10 ()
{
	switch (event_id) {

		case DA_PROGRESS :

			if (Na_type == BRI) {
				Send_to_call_control (NS_PROGRESS_IN);

			} else {

				ns_unexpected_ev ();

			}

			break;

#		if NS_T309 == ON

			case TI_309 :

				if (Na_T309_option == ON) {
					set_i_cause (C_C_RESOURCE_UNAVAILABLE, C_V_NETWORK_TEMPORARY_FAILURE_41, P_NIL);
					Send_to_call_control (NS_CLEAR_CO);
					call_clear ();
					break;
				}

#		endif

		default :

#			if AT9_SUPPLEMENTARY_SERVICES == ON

				at9_supp_services_switch ();

#			else

				ns_unexpected_ev ();

#			endif

			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_REQUEST_11 */

		/* Disconnect request state */

			/*
				This state exists when the user has requested the network
				to clear the end-to-end connection (if any) and is waiting
				for a response.
			*/

void at9_u11 ()
{
	switch (event_id) {

		 case TI_305 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, DIAGNOSTIC_NIL);
			go_to_state_19 (AT9_T308);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_INDICATION_12 */

		/* Disconnect indication state */

			/*
				This state exists when the user has received an invitation
				to disconnect because the network has disconnected the
				end-to-end connection (if any).
			*/

void at9_u12 ()
{
	switch (event_id) {

		case NS_CLEAR_RS :
			disc_cause_error ();
			N308 = 0;
			Start_timer_ns (AT9_T308);
			Release_saved_spdu ();
			Send_to_d_channel (REL);
			Set_state (STATE_RELEASE_REQUEST_19);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RELEASE_REQUEST */

		/* Release request state */

			/*
				This state exists when the user has requested the network
				to release and is waiting for a response.
			*/

void at9_u19 ()
{
	switch (event_id) {

		case NS_CLEAR_RS :		/* ignored (collision) */
			break;

		case TI_308 :

			if (++N308 < MX_N308) {
				set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, DIAGNOSTIC_NIL);
				Send_to_d_channel (REL);
				Restart_timer_ns (AT9_T308);

			} else {
				set_i_cause (C_C_TIMER, C_V_T308, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}

			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

#if EQUIPMENT == NT2


						/*-------------------*/
						/*                   */
						/*   NETWORK SIDE    */
						/*        N          */
						/*-------------------*/


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             n0 to n19 - network side - implements the processing of an
							  event according to the call state.

Usage            void nxx (void);

Related
functions usage void Stop_timer_ns (uchar x_timer);

				void Start_timer_ns (uchar x_timer);
						- x_timer : timer index.

				void Send_to_d_channel (uchar spdu_id);
						- spdu_id : spdu message type (ID).

				void Send_to_call_control (uchar ssdu_id);
						- ssdu_id : ssdu primitive code (ID).

				void Set_state (uchar call_state);
						- call_state : state of the call.

				void call_clear (void);

				void ns_unexpected_ev (void);

Return value    void

Common constants and declarations : ns.h

Common objects : call and na object, internal data structure.

*-------------------------------------------------------------------------*/

		/* STATE_NULL */

		/* Null state */

			/*
			   No call exists : used when a call context is
			   allocated to a call or a registration.
			*/

void at9_n0 ()
{

	switch (event_id) {

		case DA_SETUP:
			Call_bc_trf_cap		= I_(bc,		trf_cap);	/* BC is mandatory and so present */
			ns_action_to_cc (AT9_T300, T3_NIL, NS_CONN_IN,
											   STATE_CALL_INIT_1);
			break;

		case NS_CONN_RQ :
			N303 = 0;
			Call_bc_trf_cap		= I_(bc, trf_cap);	/* BC is mandatory and so present */
			Start_timer_ns (AT9_T303);
			Send_to_d_channel_and_save_spdu (SETUP);
			Call_ces_setup = Dl_ces;
			Set_state (STATE_CALL_PRESENT_6);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_INIT_1 */

		/* Call initialization state */

			/*
			   This state exists for an outgoing call, as a result of  user
			   action requesting call establishment from the network.
			*/

void at9_n1 ()
{
	switch (event_id) {

		case NS_CALL_PROC_RQ :
			ns_action_to_dl (AT9_T300, T3_NIL, CALL_PROC,
											   STATE_OUTGOING_CALL_PROC_3);
			break;

		case NS_SETUP_ACK_RQ :
			ns_action_to_dl (AT9_T300, AT9_T302, SETUP_ACK,
												 STATE_OVERLAP_SENDING_2);
			break;

		case NS_CONN_RS :
			ns_action_to_dl (AT9_T300, T3_NIL, CONN,
											   STATE_ACTIVE_10);
			break;

		case NS_ALERT_RQ:
			ns_action_to_dl (AT9_T300, T3_NIL, ALERT,
											   STATE_CALL_DELIVERED_4);
			break;

		case TI_300 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, P_NIL);
			Send_to_call_control (NS_CLEAR_CO);
			go_to_state_19 (AT9_T308);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OVERLAP_SENDING */

		/* Overlap sending state */

			/*
			   This state exists for an outgoing call when the user has
			   received acknowledgement of the call establishment request
			   which permits the user to send additional call information
			   to the network in overlap mode.
			*/


void at9_n2 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			ns_action_to_dl (AT9_T302, T3_NIL, CONN,
											   STATE_ACTIVE_10);
			break;

		case NS_CALL_PROC_RQ :
			ns_action_to_dl (AT9_T302, T3_NIL, CALL_PROC,
											   STATE_OUTGOING_CALL_PROC_3);
			break;

		case NS_ALERT_RQ:
			ns_action_to_dl (AT9_T302, T3_NIL, ALERT,
											   STATE_CALL_DELIVERED_4);
			break;

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		case TI_302 :
/*$*/		set_i_cause (C_C_NORMAL_EVENT, C_V_INVALID_NUMBER_FORMAT_28, P_NIL);
			Save_cause ();									/* to send the RELEASE if T305 expire */
			Send_to_call_control (NS_CLEAR_IN);

			ns_action_to_dl (T3_NIL, AT9_T305, DISC,
											   STATE_DISCONNECT_INDICATION_12);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_OUTGOING_CALL_PROC */

		/* Outgoing call proceeding state */

			/*
			   This state exists for an outgoing call when the user
			   has received acknowledgement that the network has received
			   all call information necessary to effect call establishment.
			*/

void at9_n3 ()
{
	switch (event_id) {

		case NS_ALERT_RQ :
			Send_to_d_channel (ALERT);
			Set_state (STATE_CALL_DELIVERED_4);
			break;

		case NS_CONN_RS :
			Send_to_d_channel (CONN);
			Set_state (STATE_ACTIVE_10);
			break;

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_DELIVERED */

		/* Call delivered state */

			/*
			   This state exists for an outgoing call when the calling user
			   has received an indication that the remote user alerting has
			   been initiated.
			*/

void at9_n4 ()
{
	switch (event_id) {

		case NS_PROGRESS_RQ :
			Send_to_d_channel (PROGRESS);
			break;

		case NS_CONN_RS :
			Send_to_d_channel (CONN);
			Set_state (STATE_ACTIVE_10);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_PRESENT_6 */

		/* Call present state */

			/*
			   This state exists for an incoming call when the user
			   has received a call establishment request but not yet
			   responded.
			*/

void at9_n6 ()
{

	switch (event_id) {

		case DA_CALL_PROC :
			Release_saved_spdu ();
			ns_action_to_cc (AT9_T303, AT9_T310, NS_CALL_PROC_IN,
												 STATE_INCOMING_CALL_PROC_9);
			break;

		case DA_ALERT :
			Release_saved_spdu ();
			ns_action_to_cc (AT9_T303, AT9_T301, NS_ALERT_IN,
												 STATE_CALL_RECEIVED_7);
			break;

		case DA_CONN :
			Release_saved_spdu ();
			ns_action_to_cc (AT9_T303, AT9_T300, NS_CONN_CO,
												 STATE_CONNECT_REQUEST_8);
			break;

		case TI_303 :

			if (++N303 != MX_N303) {
				Send_saved_spdu_to_d_channel (SETUP);
				Start_timer_ns (AT9_T303);

			} else {

				set_i_cause (C_C_NORMAL_EVENT, C_V_NO_USER_RESPONDING_18, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);

				ns_action_to_dl (T3_NIL, AT9_T305, DISC,
												   STATE_DISCONNECT_INDICATION_12);
			}

			break;

		default :
			ns_unexpected_ev ();
			break;


	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_CALL_RECEIVED */

		/* Call received state */

			/*
			   This state exists for an incomming call when the user has
			   indicated alerting but not yet answered.
			*/

void at9_n7 ()
{

	switch (event_id) {

		case DA_CONN :
			ns_action_to_cc (AT9_T301, AT9_T300, NS_CONN_CO,
												 STATE_CONNECT_REQUEST_8);
			break;

		case DA_PROGRESS :
			Send_to_call_control (NS_PROGRESS_IN);
			break;

		case TI_301 :
			break;

		default :
			ns_unexpected_ev ();
			break;

	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_CONNECT_REQUEST */

		/* Connect request state */

			/*
			   This state exists for an incoming call when the user
			   has answered the call and is waiting to be awarded.
			*/

void at9_n8 ()
{
	switch (event_id) {

		case NS_CONN_RS :
			ns_action_to_dl (AT9_T300, T3_NIL, CONN_ACK,
											   STATE_ACTIVE_10);
			break;

		case TI_300 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_PROTOCOL_ERROR_UNSPECIFIED_111, P_NIL);
			Save_cause ();									/* to send the RELEASE if T305 expire */
			Send_to_call_control (NS_CLEAR_IN);

			ns_action_to_dl (T3_NIL, AT9_T305, DISC,
											   STATE_DISCONNECT_INDICATION_12);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_INCOMING_CALL_PROCEEDING */

		/* Incoming call proceeding state */

			/*
			   This state exists for an incoming call when the user has
			   sent acknowlegdement that the user has received all call
			   information necessary to effect call establishment.
			*/

void at9_n9 ()
{

	switch (event_id) {

		case DA_ALERT :
			ns_action_to_cc (AT9_T310, AT9_T301, NS_ALERT_IN,
												 STATE_CALL_RECEIVED_7);
			break;

		case DA_CONN :
			ns_action_to_cc (AT9_T310, AT9_T300, NS_CONN_CO,
												 STATE_CONNECT_REQUEST_8);
			break;

		case DA_PROGRESS :
			Stop_timer_ns (AT9_T310);
			Send_to_call_control (NS_PROGRESS_IN);
			break;

		case TI_310 :
			set_i_cause (C_C_PROTOCOL_ERROR, C_V_RECOVERY_ON_TIMER_EXPIRY_102, "310");
			Send_to_call_control (NS_CLEAR_IN);

			ns_action_to_dl (T3_NIL, AT9_T305, DISC,
											   STATE_DISCONNECT_INDICATION_12);
			break;

		default :
			ns_unexpected_ev ();
			break;
	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_ACTIVE */

		/* Active state */

			/*
			   This state exists if an incoming call when the user has
			   received an ackknowledgement from the network that the user
			   has been awarded the call. This state exists for an outgoing
			   call when the user has received an indication that the remote
			   user has answered the call.
			*/

void at9_n10 ()
{

	switch (event_id) {

		case DA_CONN_ACK :
			/* no process */
			break;

		default :
			ns_unexpected_ev ();
			break;

	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_REQUEST */

		/* Disconnect request state */

			/*
			   This state exists when the user has requested the network
			   to clear the end-to-end connection (if any) and is waiting
			   for a response.
			*/

void at9_n11 ()
{

	switch (event_id) {

		case NS_CLEAR_RS :
			Stop_timer_ns (AT9_T300);
			go_to_state_19 (AT9_T308);
			break;

		case TI_300 :

			if (disc_cause_error () == NOK) {
				set_i_cause	(C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16, P_NIL);
			}

			go_to_state_19 (AT9_T308);
			break;

		default :
			ns_unexpected_ev ();
			break;
	}
}

/*-------------------------------------------------------------------------*/

		/* STATE_DISCONNECT_INDICATION */

		/* Disconnect indication state */

			/*
			   This state exists when the user has received an invitation
			   to disconnect because the network has disconnected the
			   end-to-end connection (if any).
			*/

void at9_n12 ()
{
	switch (event_id) {

		case TI_305 :
			go_to_state_19 (AT9_T308);
			break;

		default :
			ns_unexpected_ev ();
			break;

	}

}

/*-------------------------------------------------------------------------*/

		/* STATE_RELEASE_REQUEST */

		/* Release request state */

			/*
			   This state exists when the user has requested the network
			   to release and is waiting for a response.
			*/

void at9_n19 ()
{
	switch (event_id) {

		case TI_308 :
			if (++N308 < MX_N308) {
				Send_saved_spdu_to_d_channel (REL);
				Restart_timer_ns (AT9_T308);

			} else {

				set_i_cause (C_C_TIMER, C_V_T308, P_NIL);
				Send_to_call_control (NS_CLEAR_CO);
				call_clear ();
			}

			break;

		case NS_CLEAR_RS :

			break;		/* ignore */

		default :
			ns_unexpected_ev ();
			break;
	}
}

#endif

#if AT9_SUPPLEMENTARY_SERVICES == ON

void at9_supp_services_switch ()
{

	uchar err_flag;

	err_flag = ON;			/* reset error flag */

	switch (event_id) {

		case DA_NOTIFY :

			switch (Call_state) {

				case STATE_OUTGOING_CALL_PROC_3 :
				case STATE_CALL_DELIVERED_4 :
				case STATE_ACTIVE_10 :

					switch (Call_sub_state) {

						case SUB_STATE_NULL_0 :
						case SUB_STATE_40 :
						case SUB_STATE_42 :
							Send_to_call_control (NS_NOTIFY_IN);
							err_flag = OFF;
							break;
					}
			}

			break;

		case NS_HOLD_RQ :

			switch (Call_state) {
				case STATE_OUTGOING_CALL_PROC_3 :
				case STATE_CALL_DELIVERED_4 :
				case STATE_ACTIVE_10 :

					if (Call_sub_state == SUB_STATE_NULL_0) {
						Send_to_d_channel (HOLD);
						Call_sub_state = SUB_STATE_41;
						err_flag = OFF;
					}
			}

			break;

		case DA_HOLD_ACK :
		case DA_HOLD_REJ :

			switch (Call_state) {
				case STATE_OUTGOING_CALL_PROC_3 :
				case STATE_CALL_DELIVERED_4 :
				case STATE_ACTIVE_10 :

					if (Call_sub_state == SUB_STATE_41) {
						Send_to_call_control (NS_HOLD_CO);
						Call_sub_state = SUB_STATE_40;
						err_flag = OFF;

					} else if (Call_sub_state == SUB_STATE_30) {

						Send_to_call_control (NS_HOLD_CO);

						if (event_id == DA_HOLD_ACK) {
							Call_sub_state = SUB_STATE_36;

						} else {

							Call_sub_state = SUB_STATE_NULL_0;
						}

						err_flag = OFF;
					}
			}

			break;

		case DA_HOLD :

			if (Call_state == STATE_ACTIVE_10) {
				Send_to_call_control (NS_HOLD_IN);
				err_flag = OFF;

			}

			break;


		case NS_HOLD_RS :

			if (Call_state == STATE_ACTIVE_10) {

				if (is_ie_i (CODESET_0, CAUSE)) {
					Send_to_d_channel (HOLD_REJ);

				} else {

					Send_to_d_channel (HOLD_ACK);
				}

				err_flag = OFF;

			}

			break;

		case NS_RET_RQ :

			switch (Call_state) {
				case STATE_OUTGOING_CALL_PROC_3 :
				case STATE_CALL_DELIVERED_4 :
				case STATE_ACTIVE_10 :

					if (Call_sub_state == SUB_STATE_40) {
						Send_to_d_channel (RET);
						Call_sub_state = SUB_STATE_42;
						err_flag = OFF;

					} else if (Call_sub_state == SUB_STATE_36) {

						Send_to_d_channel (RET);
						Call_sub_state = SUB_STATE_33;
						err_flag = OFF;
					}
			}

			return;

		case DA_RET_ACK :
		case DA_RET_REJ :

			switch (Call_state) {
				case STATE_OUTGOING_CALL_PROC_3 :
				case STATE_CALL_DELIVERED_4 :
				case STATE_ACTIVE_10 :

					if (Call_sub_state == SUB_STATE_42) {
						Send_to_call_control (NS_RET_CO);
						err_flag = OFF;
						Call_sub_state = SUB_STATE_40;
					}

					break;
			}

			break;

		case DA_K_SETUP :

			if (Call_state == STATE_NULL_0) {
				Send_to_call_control (NS_K_SETUP_IN);
				Send_to_d_channel (K_SETUP_ACK);
				Call_sub_state = SUB_STATE_40;
				Set_state (STATE_OUTGOING_CALL_PROC_3);
				err_flag = OFF;
			}

			break;

		case DA_K_HOLD :

			switch (Call_state) {

				case STATE_CALL_RECEIVED_7 :
				case STATE_CONNECT_REQUEST_8 :
				case STATE_INCOMING_CALL_PROC_9 :
				case STATE_DISCONNECT_REQUEST_11 :
					Send_to_call_control (NS_K_HOLD_IN);
					Call_sub_state = SUB_STATE_40;
					Set_state (STATE_ACTIVE_10);
					err_flag = OFF;
					break;
			}

			break;

		case DA_K_REL :

			Call_sub_state = SUB_STATE_40;
			Send_to_call_control (NS_K_REL_IN);
			err_flag = OFF;
			break;
	}

	if (err_flag == ON) {

			/* An error occured */

		ns_unexpected_ev ();
	}
}

#endif

/*-------------------------------------------------------------------------*/

						/*----------------------*/
						/*                   	*/
						/*   D channel backup	*/
						/*						*/
						/*----------------------*/


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             at9_national_bkp_xxxx

Usage            void at9_national_bkp_xxxx (code);

Return value    void

Common constants and declarations : ns.h

Common objects : call and na object, internal data structure.

*-------------------------------------------------------------------------*/

#	if NEW_FCT_STYLE == ON
		void 	at9_send_service_national 	(nai_t line_nai, uchar ack);
#	else
		void 	at9_send_service_national 	();
#	endif

#if NS_D_BACKUP == ON /* { */

/*-------------------------------------------------------------------------*/

void at9_national_bkp_oos_oos (code)
	code_t	code;
{
	struct nsna FAR *p_nsna_sav;
	struct nsdl FAR *p_nsdl_sav;

		/*
		 * When enterring this routine, p_nsna points to the CC Nai
		 * context.
		 */

	switch (code) {

		case TI_321 :

				/* Abnormal event */

			break;

		case DL_EST_CO :
		case DL_EST_IN :

				/* Stop T3_DL_EST */

			Stop_dl_timer (T3_DL_EST);

				/* Send a MAINT_SERVICE message */

			at9_send_service_national (Nfas_nai_line, OFF);

				/*
				 * Start T321 on the Nai bearing
				 * the active D channel
				 */

			p_nsna_sav	= p_nsna;
			p_nsdl_sav	= p_nsdl;

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {

				p_nsna	= Nfas_nai_p_active_d_chan;
				p_nsdl	= Nfas_dl_p_active_d_chan;

			} else {

				p_nsna	= Nfas_nai_p_backup_d_chan;
				p_nsdl	= Nfas_dl_p_backup_d_chan;
			}

			N321 = 0;
			Start_dl_timer (T321);
			Lc_state = LC_ESTABLISHED;

			p_nsna		= p_nsna_sav;
			p_nsdl		= p_nsdl_sav;

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {
				Nfas_active_d_chan_status	= MAINT_STATE_WAIT;
				Nfas_backup_d_chan_status	= MAINT_STATE_MB;

			} else {

				Nfas_active_d_chan_status	= MAINT_STATE_OOS;
				Nfas_backup_d_chan_status	= MAINT_STATE_WAIT;
			}

			break;

		case DL_REL_IN :

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {
				p_nsdl = Nfas_dl_p_backup_d_chan;
				p_nsna = Nfas_nai_p_backup_d_chan;
				Send_to_dl 	(DL_EST_RQ, Na_dl_ces);
				Lc_state= LC_AWAITING_EST;
			}

			break;

		case DL_COMMIT_CO :
			Send_to_dl (DL_REL_RQ, DL_CES_SIG);
			Lc_state = LC_AWAITING_REL;
			break;

		default :

				/* Ignore */

			break;

	}
}
/*-------------------------------------------------------------------------*/

void at9_national_bkp_is_stby (code)
	code_t	code;
{
	switch (code) {

		case TI_SRV :

			if (++NSRV < AT9_MX_TSRV) {

					/* Restart timer SRV */

				Start_dl_timer (TSRV);

					/* Send A SERV (IS) on the Active D channel */

				at9_send_service_national (Nfas_nai_active_d_chan, OFF);

				break;
			}


				/* Send A SERV (IS) on the Backup D channel */

			at9_send_service_national (Nfas_nai_backup_d_chan, OFF);

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_WAIT;
			break;

		case DL_REL_IN :

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {

					/*
					 * We received a REL_IN on the Active D channel.
					 * Switch to the backup D channel.
					 */

				p_nsdl = Nfas_dl_p_backup_d_chan;
				p_nsna = Nfas_nai_p_backup_d_chan;

					/* Start T321 on Backup D channel */

				Start_dl_timer (T321);

					/*
					 * Start 309 (should be done in
					 * nfas_csc_dl_failure),
					 * Send a SERVICE message on the Backup D channel.
					 */


				at9_send_service_national (Nfas_nai_backup_d_chan, OFF);

					/* Update the D channels states */

				Nfas_active_d_chan_status	= MAINT_STATE_MB;
				Nfas_backup_d_chan_status	= MAINT_STATE_WAIT;

			} else {

					/* Establish layer 2 for the Backup D channel */

				p_nsna	= Nfas_nai_p_backup_d_chan;
				p_nsdl	= Nfas_dl_p_backup_d_chan;

					Send_to_dl 	(DL_EST_RQ, DL_CES_SIG);/* send to DL_D */
					Lc_state 	= LC_AWAITING_EST; 		/* set state : awaiting establishment */
					Start_dl_timer (T3_DL_EST);

				p_nsna	= Nfas_nai_p_active_d_chan;
				p_nsdl	= Nfas_dl_p_active_d_chan;

					/* Update the D channels states */

				Nfas_active_d_chan_status	= MAINT_STATE_IS;
				Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			}

			break;

		case DL_DA_IN :

			if (*p_spdu == PROTOCOL_DISCRIMINATOR_I451) {
				break;
			}

			switch (p_spdu[I_call_ref_lgth+2]) {

				case MAINT_SERVICE :

					protocol_discr = PROTOCOL_DISCR_MAINT_NATIONAL;

					if (Nfas_nai_line == Nfas_nai_active_d_chan) {

							/* Send back a SERVICE_ACK */

						at9_send_service_national (Nfas_nai_active_d_chan, ON);

					} else {

							/* Send a SERVICE on the Active D channel */

						at9_send_service_national (Nfas_nai_active_d_chan, OFF);

					}

					break;

				case MAINT_SERVICE_ACK :
					NSRV = 0;
					break;
			}

			break;
	}
}

/*-------------------------------------------------------------------------*/

void at9_national_bkp_mb_wait (code)
	code_t	code;
{
	switch (code) {

		case DL_DA_IN :

			if (*p_spdu == PROTOCOL_DISCRIMINATOR_I451) {
				break;
			}


			if (Nfas_nai_line != Nfas_nai_backup_d_chan) {

					/* Ignore */

				return;
			}

			switch (p_spdu[I_call_ref_lgth+2]) {

				case MAINT_SERVICE :

					protocol_discr = PROTOCOL_DISCR_MAINT_NATIONAL;

						/* Send back a SERVICE_ACK */

					at9_send_service_national (Nfas_nai_active_d_chan, ON);

						/* Process as for MAINT_SERV_ACK */

				case MAINT_SERVICE_ACK :

					p_nsna = Nfas_nai_p_active_d_chan;
					p_nsdl = Nfas_dl_p_active_d_chan;

						/* Stop TSRV on Active Nai */

					Stop_dl_timer (AT9_TSRV);

					p_nsna = Nfas_nai_p_backup_d_chan;
					p_nsdl = Nfas_dl_p_backup_d_chan;

						/*
						 * The previous Backup D channel
						 * becomes the new Active one.
						 */

					Nfas_nai_p_backup_d_chan = Nfas_nai_p_active_d_chan;
					Nfas_dl_p_backup_d_chan  = Nfas_dl_p_active_d_chan;
					Nfas_nai_p_active_d_chan = p_nsna;
					Nfas_dl_p_active_d_chan	 = p_nsdl;
					Nfas_nai_backup_d_chan	 = Nfas_nai_active_d_chan;
					Nfas_nai_active_d_chan	 = Nai;

						/* Establish layer 2 for the Backup D channel */

					p_nsna	= Nfas_nai_p_backup_d_chan;
					p_nsdl	= Nfas_dl_p_backup_d_chan;

						Send_to_dl 	(DL_EST_RQ, DL_CES_SIG);/* send to DL_D */
						Lc_state 	= LC_AWAITING_EST; 		/* set state : awaiting establishment */
						Start_dl_timer (T3_DL_EST);

					p_nsna	= Nfas_nai_p_active_d_chan;
					p_nsdl	= Nfas_dl_p_active_d_chan;

						/*
						 * Stop T321 on the Nai bearing
						 * the active D channel
						 */

					Stop_dl_timer (T321);

						/* Stop Timer 309 */

					ns_nfas_stop_309 ();

						/* Update the D channels states */

					Nfas_active_d_chan_status	= MAINT_STATE_IS;
					Nfas_backup_d_chan_status	= MAINT_STATE_OOS;

					if (State_dl_timer (AT9_TSRV) == OFF) {

							/* Start TSRV */

						NSRV = 0;

						if (Na_fct != FG_NT_TE) {
							Start_dl_timer (AT9_TSRV);
						}
					}

					break;
			}

			break;

		case DL_REL_IN :

			if (Nfas_nai_line != Nfas_nai_backup_d_chan) {

					/* Ignore */

				return;
			}

				/* Stop T321 */

			Stop_dl_timer (T321);

				/* Re-establish layer 2 for the active D channel */

			p_nsna = Nfas_nai_p_active_d_chan;
			p_nsdl = Nfas_dl_p_active_d_chan;

				/*
				 * It could already have been done in the csc_dl_failure ()
				 * routine. Don't do it twice ...
				 */

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);

			}

				/* Establish layer 2 for the backup D channel */

			p_nsdl = Nfas_dl_p_backup_d_chan;
			p_nsna = Nfas_nai_p_backup_d_chan;

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);

			}

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			break;

		case TI_321 :

			if (++N321 < AT9_MX_T321) {

					/* Send a MAINT_SERVICE message */

				at9_send_service_national (Nfas_nai_backup_d_chan, OFF);

					/* Restart timer 321 */

				Start_dl_timer (T321);
				break;
			}

			p_nsdl = Nfas_dl_p_backup_d_chan;
			p_nsna = Nfas_nai_p_backup_d_chan;

				/* Disconnect layer 2 */

			Send_to_dl (DL_COMMIT_RQ, DL_CES_SIG);

				/* Establish layer 2 for the Active D channel */

			p_nsdl = Nfas_dl_p_active_d_chan;
			p_nsna = Nfas_nai_p_active_d_chan;

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);
			}

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			break;

   }
}

/*-------------------------------------------------------------------------*/

void at9_national_bkp_wait_mb (code)
	code_t	code;
{
	switch (code) {

		case DL_DA_IN :

			if (*p_spdu == PROTOCOL_DISCRIMINATOR_I451) {
				break;
			}

			if (Nfas_nai_line != Nfas_nai_active_d_chan) {

					/* Ignore */

				return;
			}

			switch (p_spdu[I_call_ref_lgth+2]) {

				case MAINT_SERVICE :

					protocol_discr = PROTOCOL_DISCR_MAINT_NATIONAL;

						/* Send back a SERVICE_ACK */

					at9_send_service_national (Nfas_nai_active_d_chan, ON);

						/* Process as for MAINT_SERV_ACK */

				case MAINT_SERVICE_ACK :

						/* Establish layer 2 for the Backup D channel */

					p_nsna	= Nfas_nai_p_backup_d_chan;
					p_nsdl	= Nfas_dl_p_backup_d_chan;

						Send_to_dl 	(DL_EST_RQ, DL_CES_SIG);/* send to DL_D */
						Lc_state 	= LC_AWAITING_EST; 		/* set state : awaiting establishment */
						Start_dl_timer (T3_DL_EST);

					p_nsna	= Nfas_nai_p_active_d_chan;
					p_nsdl	= Nfas_dl_p_active_d_chan;

						/*
						 * Stop T321 on the Nai bearing
						 * the active D channel
						 */

					Stop_dl_timer (T321);

						/* Stop Timer 309 */

					ns_nfas_stop_309 ();

						/* Update the D channels states */

					Nfas_active_d_chan_status	= MAINT_STATE_IS;
					Nfas_backup_d_chan_status	= MAINT_STATE_OOS;

					if (State_dl_timer (AT9_TSRV) == OFF) {

							/* Start TSRV */

						NSRV = 0;
						if (Na_fct != FG_NT_TE) {
							Start_dl_timer (AT9_TSRV);
						}
					}

					break;
			}

			break;

		case DL_REL_IN :

				/* Stop T321 */

			Stop_dl_timer (T321);

				/* Re-establish layer 2 for the active D channel */

			p_nsdl = Nfas_dl_p_active_d_chan;

				/*
				 * It could already have been done in the csc_dl_failure ()
				 * routine. Don't do it twice ...
				 */

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);

			}

				/* Establish layer 2 for the backup D channel */

			p_nsdl = Nfas_dl_p_backup_d_chan;
			p_nsna = Nfas_nai_p_backup_d_chan;

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);

			}

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			break;


		case TI_321 :

			if (++N321 < AT9_MX_T321) {

					/* Send a MAINT_SERVICE message */

				at9_send_service_national (Nfas_nai_active_d_chan, OFF);

					/* Restart timer 321 */

				Start_dl_timer (T321);
				break;
			}

				/* Disconnect layer 2 */

			Send_to_dl (DL_COMMIT_RQ, DL_CES_SIG);

				/* Establish layer 2 for the backup D channel */

			p_nsdl = Nfas_dl_p_backup_d_chan;
			p_nsna = Nfas_nai_p_backup_d_chan;

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);
			}

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			break;

		default :

				/* Ignore */

			break;

	}
}

/*-------------------------------------------------------------------------*/

void at9_national_bkp_is_oos (code)
	code_t	code;
{

	switch (code) {

		case DL_EST_IN :

				/*
				 * Warning !
				 * The diagrams show a layer 2 protocol inconsistancy.
				 * When in the LC_AWAITING_EST state,
				 * the diagrams allows a DL_EST_IN.
				 * That should not happen.
				 */

				/* Stop T3_DL_EST */

			Stop_dl_timer (T3_DL_EST);

			if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

				if (Lc_state ==  LC_AWAITING_EST) {

					Lc_state = LC_ESTABLISHED;
				}

					/* Update the D channel states */

				Nfas_active_d_chan_status	= MAINT_STATE_IS;
				Nfas_backup_d_chan_status	= MAINT_STATE_STBY;
			}

			break;

		case DL_EST_CO :

			if (Nfas_nai_line == Nfas_nai_backup_d_chan) {

					/* Stop T3_DL_EST */

				Stop_dl_timer (T3_DL_EST);

					/* Update the D channel states */

				Nfas_active_d_chan_status	= MAINT_STATE_IS;
				Nfas_backup_d_chan_status	= MAINT_STATE_STBY;

			}
			break;

		case DL_REL_IN :

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {


					/* Re-establish layer 2 for the active D channel */

				p_nsdl = Nfas_dl_p_active_d_chan;

					/*
					 * It could already have been done in the csc_dl_failure ()
					 * routine. Don't do it twice ...
					 */

				if (Lc_state != LC_AWAITING_EST) {

						/* OK, let's do it */

					Send_to_dl (DL_EST_RQ, DL_CES_SIG);
					Lc_state = LC_AWAITING_EST;
					Start_dl_timer (T3_DL_EST);

				}

					/* Establish layer 2 for the backup D channel */

				p_nsdl = Nfas_dl_p_backup_d_chan;
				p_nsna = Nfas_nai_p_backup_d_chan;

				if (Lc_state != LC_AWAITING_EST) {

						/* OK, let's do it */

					Send_to_dl (DL_EST_RQ, DL_CES_SIG);
					Lc_state = LC_AWAITING_EST;
					Start_dl_timer (T3_DL_EST);

				}

					/* Update the D channels states */

				Nfas_active_d_chan_status	= MAINT_STATE_OOS;
				Nfas_backup_d_chan_status	= MAINT_STATE_OOS;

			}

			break;

		case DL_REL_CO :
			break;

		case DL_DA_IN :

			if (*p_spdu == PROTOCOL_DISCRIMINATOR_I451) {
				break;
			}

				/*
				 * Process only if the message is sent on the
				 * Active D channel.
				 */

			if (Nfas_nai_line == Nfas_nai_backup_d_chan) return;

			switch (p_spdu[I_call_ref_lgth+2]) {

				case MAINT_SERVICE :

					protocol_discr = PROTOCOL_DISCR_MAINT_NATIONAL;

						/* Send back a SERVICE_ACK */

					at9_send_service_national (Nfas_nai_active_d_chan, ON);

						/* Process as for MAINT_SERVICE_ACK */

				case MAINT_SERVICE_ACK :

						/* Stop Tserve timer */

					Stop_dl_timer (AT9_TSRV);
					break;
			}

			break;

		case TI_321 :
		case TI_309 :

				/* Unexpected events */

			break;


		case TI_SRV :

			if (++NSRV < AT9_MX_TSRV) {

					/* Restart timer SRV */

				Start_dl_timer (TSRV);

					/* Establish layer 2 for the backup D channel */

				p_nsdl = Nfas_dl_p_backup_d_chan;
				p_nsna = Nfas_nai_p_backup_d_chan;

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);

				break;

			}

				/* Remove the Active D channel */

			Lc_state = LC_RELEASED;

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			break;
	}
}

/*-------------------------------------------------------------------------*/

void at9_national_bkp_oos_wait (code)
	code_t	code;
{

	switch (code) {

		case DL_DA_IN :

			if (*p_spdu == PROTOCOL_DISCRIMINATOR_I451) {
				break;
			}

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {

					/* Ignore */

				return;
			}

			switch (p_spdu[I_call_ref_lgth+2]) {

				case MAINT_SERVICE :

					protocol_discr = PROTOCOL_DISCR_MAINT_NATIONAL;

						/* Send back a SERVICE_ACK */

					at9_send_service_national (Nfas_nai_active_d_chan, ON);

						/* Process as for MAINT_SERV_ACK */

				case MAINT_SERVICE_ACK :

						/* Stop TSRV on Active Nai */


					Stop_dl_timer (AT9_TSRV);

						/*
						 * Switch Active / Passive Nai.
						 * p_nsna currently points to the Backup Nai.
						 */

					Nfas_nai_p_backup_d_chan	= Nfas_nai_p_active_d_chan;
					Nfas_dl_p_backup_d_chan		= Nfas_dl_p_active_d_chan;
					Nfas_nai_p_active_d_chan	= p_nsna;
					Nfas_dl_p_active_d_chan		= p_nsdl;

					Nfas_nai_active_d_chan		= Nai;

							/* Establish layer 2 for the new Backup D channel */

					p_nsna	= Nfas_nai_p_backup_d_chan;
					p_nsdl	= Nfas_dl_p_backup_d_chan;
					Nfas_nai_backup_d_chan		= Nai;

						Send_to_dl 	(DL_EST_RQ, DL_CES_SIG);/* send to DL_D */
						Lc_state 	= LC_AWAITING_EST; 		/* set state : awaiting establishment */
						Start_dl_timer (T3_DL_EST);

					p_nsna	= Nfas_nai_p_active_d_chan;
					p_nsdl	= Nfas_dl_p_active_d_chan;

						/*
						 * Stop T321 on the Nai bearing
						 * the active D channel
						 */

					Stop_dl_timer (T321);

						/* Stop Timer 309 */

					ns_nfas_stop_309 ();

						/* Update the D channels states */

					Nfas_active_d_chan_status	= MAINT_STATE_IS;
					Nfas_backup_d_chan_status	= MAINT_STATE_OOS;

					if (State_dl_timer (AT9_TSRV) == OFF) {

							/* Start TSRV */

						NSRV = 0;
						if (Na_fct != FG_NT_TE) {
							Start_dl_timer (AT9_TSRV);
						}
					}

					break;
			}

			break;

		case DL_REL_IN :

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {
				break;
			}

				/* Stop T321 */

			Stop_dl_timer (T321);

				/* Re-establish layer 2 for the active D channel */

			p_nsdl = Nfas_dl_p_active_d_chan;
			p_nsna = Nfas_nai_p_active_d_chan;

				/*
				 * It could already have been done in the csc_dl_failure ()
				 * routine. Don't do it twice ...
				 */

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);

			}

				/* Establish layer 2 for the backup D channel */

			p_nsdl = Nfas_dl_p_backup_d_chan;
			p_nsna = Nfas_nai_p_backup_d_chan;

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);

			}

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			break;


		case DL_EST_IN :
		case DL_EST_CO :

			if (Nfas_nai_line == Nfas_nai_active_d_chan) {

					/* Stop T3_DL_EST */

				Stop_dl_timer (T3_DL_EST);

					/* Send a MAINT_SERVICE message */

				at9_send_service_national (Nfas_nai_active_d_chan, OFF);

					/* Start 321 */

				Start_dl_timer (T321);

					/* Disconnect layer 2 */

				p_nsdl = Nfas_dl_p_backup_d_chan;
				p_nsna = Nfas_nai_p_backup_d_chan;

				Send_to_dl (DL_COMMIT_RQ, DL_CES_SIG);

					/* Update the D channels states */

				Nfas_active_d_chan_status	= MAINT_STATE_WAIT;
				Nfas_backup_d_chan_status	= MAINT_STATE_MB;

			}

			break;


		case TI_321 :

			if (++N321 < AT9_MX_T321) {

					/* Send a MAINT_SERVICE message */

				at9_send_service_national (Nfas_nai_backup_d_chan, OFF);

					/* Restart timer 321 */

				Start_dl_timer (T321);
				break;
			}

				/* Disconnect layer 2 */

			Send_to_dl (DL_COMMIT_RQ, DL_CES_SIG);

				/* Establish layer 2 for the active D channel */

			p_nsdl = Nfas_dl_p_active_d_chan;
			p_nsna = Nfas_nai_p_active_d_chan;

			if (Lc_state != LC_AWAITING_EST) {

					/* OK, let's do it */

				Send_to_dl (DL_EST_RQ, DL_CES_SIG);
				Lc_state = LC_AWAITING_EST;
				Start_dl_timer (T3_DL_EST);
			}

				/* Update the D channels states */

			Nfas_active_d_chan_status	= MAINT_STATE_OOS;
			Nfas_backup_d_chan_status	= MAINT_STATE_OOS;
			break;

		default :

				/* Ignore */

			break;

	}
}

#endif /* } NS_D_BACKUP */

/*-------------------------------------------------------------------------*/

#if NS_D_BACKUP /* { */

void at9_send_service_national (line_nai, ack)
	nai_t line_nai;
	uchar ack;
{
	uchar FAR *p_data;

		/* The SERVICE/ACK is used for the D channel only. */

	if (ack == ON) {


			/*
			 * Send the SERVICE_ACK message.
			 */

		Send_to_d_channel_proto	(MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_NATIONAL);
		return;

	}

		/* Allocate a buffer */

	Buffer_alloc_reused;

		/* Initialize the buffer header */

	Buffer_data_offset	+= DL_MX_FRAME_HEADER;

		/* Set the SPDU pointer */

	p_data = Buffer_a_start_data;

	*p_data++ = PROTOCOL_DISCR_MAINT_NATIONAL;

	*p_data++ = 1;					/* Call ref length */
	*p_data++ = 0;                  /* Call ref is GLOBAL */
	*p_data++ = MAINT_SERVICE;      /* spdu type */

	*p_data++ = CHANGE_STATUS;
	*p_data++ = 1;					/* length */
	*p_data++ = 0xC0;				/* D channel in service */

	*p_data++ = CHAN_ID;
	*p_data++ = 1;					/* length */
	*p_data++ = 0xAC;				/* No channel is included */

	Buffer_data_size = (ushort)(p_data - Buffer_a_start_data);

		/*
		   Allocate a message.
		   Transfer data information into the message if possible
		   and release the buffer;
		   If not possible link the buffer to the message.
		*/

	p_snd_msg = Msg_or_buffer (p_buffer, DL_MX_FRAME_HEADER);

	p_buffer  = S_msg_p_buffer;

		/* Init the message header with the address information */

	S_msg_from 		= ENT_NS;				/* from NS entity */
	S_msg_to 		= ENT_DL_D;				/* to Data Link LAPD entity */
	S_msg_nai 		= line_nai;				/* DL NA ID */
	S_msg_sapi 		= DL_SAPI_SIG;			/* SAP ID Signalling */
	S_msg_ces 		= DL_CES_SIG;			/* CES */

		/* Load the primitive code */

	S_msg_code 		= DL_DA_RQ;				/* primitive code */

	Send_message (p_snd_msg), p_snd_msg = P_NIL, p_buffer  = P_NIL;

}

#endif /* } */

/*-------------------------------------------------------------------------*/

						/*--------------------------*/
						/*                   		*/
						/*   Maintenance procedures	*/
						/*							*/
						/*--------------------------*/

#if NEW_FCT_STYLE == ON
	uchar	at9_audit (nai_t int_id, uchar b_chan);
#else
	uchar	at9_audit ();
#endif


#if NS_MAINTENANCE_CAPABILITY == ON /* { */

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_custom_is (int_id, b_chan, action)
	nai_t int_id;
	uchar b_chan;
	uchar action;
{

	uchar send_service_co;
	struct nsna FAR *p_na_sav;

	send_service_co = ON;

	switch (event_id) {

		case MNS_SERVICE_RQ :

			if (action == MAINT_ACTION_AUDIT) {
				at9_audit (int_id, b_chan);
				return;
			}

				/* Update the B channel state */

			if (I_(change_status, status) == CHANNEL_OUT_OF_SERVICE) {

				Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_NE;

					/*
					 * Send a MAINT_SERVICE.
					 * The primitive comes from CC, so we have to
					 * select the Active D channel, unless we are
					 * using the TSP mode without D channel Backup.
					 */

				p_na_sav = p_nsna;

				if (ns_nfas == ON) {
					p_nsna = Nfas_nai_p_active_d_chan;
					p_nsdl = Nfas_dl_p_active_d_chan;
				}

				Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);

					/* Send a NS_SERVICE_CO to the application */

				p_nsna = p_na_sav;
				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

			}

			break;

		case DA_MAINT_SERVICE :

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					send_service_co = OFF;
					break;

				case CHANNEL_MAINTENANCE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_MAINT_FE;
					break;

				case CHANNEL_OUT_OF_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE;
					break;

			}

			if (send_service_co == ON) {

					/* Send a NS_SERVICE_CO to the application */

				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
			}

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}
				/* Send back a SERVICE_ACK */

			I_call_ref_lgth = 1;
			Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);


			break;

	}

}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_custom_is_ack (int_id, b_chan)
	nai_t int_id;
	uchar b_chan;
{
	struct nsna FAR *p_na_sav;

	switch (event_id) {

		case MNS_SERVICE_RQ :

				/* Update the B channel state */

			if (I_(change_status, status) == CHANNEL_OUT_OF_SERVICE) {

				Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_NE;

					/*
					 * Send a MAINT_SERVICE.
					 * The primitive comes from CC, so we have to
					 * select the Active D channel, unless we are
					 * using the TSP mode without D channel Backup.
					 */

				p_na_sav = p_nsna;

				if (ns_nfas == ON) {
					p_nsna = Nfas_nai_p_active_d_chan;
					p_nsdl = Nfas_dl_p_active_d_chan;
				}

				Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);


					/* Send a NS_SERVICE_CO to the application */

				p_nsna = p_na_sav;
				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

			}

			break;

		case DA_MAINT_SERVICE_ACK :

				/* Only 1 B channel is impacted */

			if (Dl_b_chan_maint_nb (int_id) > 0) {
				Dl_b_chan_maint_nb (int_id)--;
			}

			if (Dl_b_chan_maint_nb (int_id) == 0) {

					/* Start DL timer T317 */

				Stop_dl_timer (AT9_T317);
			}

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_IS;
					break;

				case CHANNEL_MAINTENANCE :
				case CHANNEL_OUT_OF_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE;
					break;

			}

				/* Send a NS_SERVICE_CO to the application */

			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
			break;

		case DA_MAINT_SERVICE :

				/* Only 1 B channel is impacted */

			if (Dl_b_chan_maint_nb (int_id) > 0) {
				Dl_b_chan_maint_nb (int_id)--;
			}

			if (Dl_b_chan_maint_nb (int_id) == 0) {

					/* Start DL timer T317 */

				Stop_dl_timer (AT9_T317);
			}

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_IS;
					break;

				case CHANNEL_MAINTENANCE :
				case CHANNEL_OUT_OF_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE;
					break;

			}

				/* Send a NS_SERVICE_CO to the application */

			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

				/* Send back a MAINT_SERVICE_ACK */

			I_call_ref_lgth = 1;
			Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

			break;

	}

}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_custom_osne (int_id, b_chan)
	nai_t int_id;
	uchar b_chan;
{

		/* Out of service Near End state */

	switch (event_id) {

		case MNS_SERVICE_RQ :

				/* Update the B channel state */

			if (I_(change_status, status) == CHANNEL_IN_SERVICE) {

				Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_ACK;

			} else {

					/* CHANNEL_MAINTENANCE */

				Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_MAINT_NE_ACK;
			}

				/* Only 1 B channel is impacted */

			Dl_b_chan_maint_nb (int_id)++;

			if (State_dl_timer (AT9_T317) == OFF) {

					/*
					 * Only 1 timer 317 per D channel ...
					 * So only 1 T317 for all the interfaces
					 * managed by the D channel
					 */


					/* Start DL timer T317 */

				Start_dl_timer (AT9_T317);
			}

				/* Record the type of action being made */

			Dl_maint_action (int_id) = MAINT_ACTION_SERVICE_SENT;

				/*
				 * Send a MAINT_SERVICE.
				 * The primitive comes from CC, so we have to
				 * select the Active D channel, unless we are
				 * using the TSP mode without D channel Backup.
				 */

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

			Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);
			break;

		case DA_MAINT_SERVICE :

				/* Update the status field to be sent back */


			if (I_(change_status, status) == CHANNEL_IN_SERVICE) {

				I_(change_status, status) = MAINT_STATE_B_IS;

				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
				I_call_ref_lgth = 1;

			} else {

				I_(change_status, status) = MAINT_STATE_B_OOS_NE;
			}

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}
				/* Send back a MAINT_SERV_ACK */

			I_call_ref_lgth = 1;
			Send_to_d_channel_proto	(MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

			break;

	}

}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_custom_osfe_ack (int_id, b_chan)
	nai_t int_id;
	uchar b_chan;
{

		/* Out of service Far End waiting for Acknowledge state */

	switch (event_id) {

		case MNS_SERVICE_RQ :

				/* Update the B channel state */

			if (I_(change_status, status) == CHANNEL_IN_SERVICE) {

				Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_ACK;

			} else {

					/* CHANNEL_MAINTENANCE */

				Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_MAINT_NE_ACK;
			}

				/* Only 1 B channel is impacted */

			Dl_b_chan_maint_nb (int_id)++;

			if (State_dl_timer (AT9_T317) == OFF) {

					/*
					 * Only 1 timer 317 per D channel ...
					 * So only 1 T317 for all the interfaces
					 * managed by the D channel
					 */


					/* Start DL timer T317 */

				Start_dl_timer (AT9_T317);
			}

				/* Record the type of action being made */

			Dl_maint_action (int_id) = MAINT_ACTION_SERVICE_SENT;

				/*
				 * Send a MAINT_SERVICE.
				 * The primitive comes from CC, so we have to
				 * select the Active D channel, unless we are
				 * using the TSP mode without D channel Backup.
				 */

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

			Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);
			break;

		case DA_MAINT_SERVICE :

				/* Only 1 B channel is impacted */

			if (Dl_b_chan_maint_nb (int_id) > 0) {
				Dl_b_chan_maint_nb (int_id)--;
			}

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_IS;
					break;

				case CHANNEL_MAINTENANCE :
				case CHANNEL_OUT_OF_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE;
					break;
			}

				/*
				 * Stop T317 only if all B channels have been
				 * processed.
				 */

			if (Dl_b_chan_maint_nb (int_id) == 0) {

					/* Stop DL timer T317 */

				Stop_dl_timer (AT9_T317);
			}

				/* Send a NS_SERVICE_CO to the application */

			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

				/* Send back a SERVICE_ACK */

			I_call_ref_lgth = 1;
			Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

			break;

		case DA_MAINT_SERVICE_ACK :

				/* Only 1 B channel is impacted */

			if (Dl_b_chan_maint_nb (int_id) > 0) {
				Dl_b_chan_maint_nb (int_id)--;
			}

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_IS;
					break;

				case CHANNEL_MAINTENANCE :
				case CHANNEL_OUT_OF_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE;
					break;
			}

				/*
				 * Stop T317 only if all B channels have been
				 * processed.
				 */

			if (Dl_b_chan_maint_nb (int_id) == 0) {

					/* Stop DL timer T317 */

				Stop_dl_timer (AT9_T317);
			}

				/* Send a NS_SERVICE_CO to the application */

			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
			break;
	}

}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_custom_osfe (int_id, b_chan, action)
	nai_t int_id;
	uchar b_chan;
	uchar action;
{

	uchar start_317, send_service_co;
	struct nsna FAR *p_na_sav;

		/* Out of service Far End state */

	start_317 		= ON;
	send_service_co = OFF;

	switch (event_id) {

		case MNS_SERVICE_RQ :

			if (action == MAINT_ACTION_AUDIT) {

					/* Update the B channel state */

				Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_ACK;

			} else {

					/* Update the B channel state */

				switch (I_(change_status, status)) {

					case CHANNEL_IN_SERVICE :
						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE_ACK;
						break;

					case CHANNEL_MAINTENANCE :
						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_MAINT_FE_ACK;
						break;

					case CHANNEL_OUT_OF_SERVICE :
						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_NE;
						start_317 		= OFF;
						send_service_co = ON;
						break;
				}

			}

			if (start_317 == ON) {

					/* Only 1 B channel is impacted */

				Dl_b_chan_maint_nb (int_id)++;

				if (State_dl_timer (AT9_T317) == OFF) {

						/*
						 * Only 1 timer 317 per D channel ...
						 * So only 1 T317 for all the interfaces
						 * managed by the D channel
						 */


						/* Start DL timer T317 */

					Start_dl_timer (AT9_T317);
				}

					/* Record the type of action being made */

				Dl_maint_action (int_id) = MAINT_ACTION_SERVICE_SENT;
			}

				/*
				 * Send a MAINT_SERVICE.
				 * The primitive comes from MNS, so we have to
				 * select the Active D channel, unless we are
				 * using the TSP mode without D channel Backup.
				 */

			p_na_sav = p_nsna;

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

			Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);

			if (send_service_co == ON) {

					/* Send a NS_SERVICE_CO to the application */

				p_nsna = p_na_sav;
				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
			}

			break;

		case DA_MAINT_SERVICE :

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_IS;
					break;

				case CHANNEL_MAINTENANCE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_MAINT_FE;
					break;

				case CHANNEL_OUT_OF_SERVICE :
					Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE;
					break;

			}

				/* Send a NS_SERVICE_CO to the application */

			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

				/* Send back a SERVICE_ACK */

			I_call_ref_lgth = 1;
			Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

			break;

	}

}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_maint_ack_1 (int_id, b_chan)
	nai_t int_id;
	uchar b_chan;
{

	uchar current_state, ret_code;

	current_state	= Dl_b_chan_mode_int (int_id, b_chan);
	ret_code		= NOK;

	switch (event_id) {

		case DA_MAINT_SERVICE :

				/* Only 1 B channel is impacted */

			if (Dl_b_chan_maint_nb (int_id) > 0) {
				Dl_b_chan_maint_nb (int_id)--;
			}

				/*
				 * Stop T317 only if all B channels have been
				 * processed.
				 */

			if (Dl_b_chan_maint_nb (int_id) == 0) {

					/* Stop DL timer T317 */

				Stop_dl_timer (AT9_T317);
			}

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_MAINTENANCE :

						/* Update B channel state */

					Dl_b_chan_mode_int (int_id, b_chan) = B_chan_state_cancel_ack (current_state);

						/* Send a NS_SERVICE_CO to the application */

					Set_call_ref_nil ();
					Send_to_call_control (NS_SERVICE_CO);
					ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

					if (ns_nfas == ON) {
						p_nsna = Nfas_nai_p_active_d_chan;
						p_nsdl = Nfas_dl_p_active_d_chan;
					}

						/* Send back a SERVICE_ACK (MAINT) */

					I_call_ref_lgth = 1;
					Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

					break;

				case CHANNEL_IN_SERVICE :
				case CHANNEL_OUT_OF_SERVICE :

					switch (current_state) {

						case MAINT_STATE_B_IS_MAINT_NE_ACK :

							I_(change_status, status) = CHANNEL_IN_SERVICE;

								/* Perform the audit */


							if (at9_audit (int_id, b_chan) == NOK) {

									/*
									 * No NS_SERVICE_CO has been sent.
									 * Send one.
									 */

								Set_call_ref_nil ();
								Send_to_call_control (NS_SERVICE_CO);
								ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
							}

							if (ns_nfas == ON) {
								p_nsna = Nfas_nai_p_active_d_chan;
								p_nsdl = Nfas_dl_p_active_d_chan;
							}

								/* Send back a SERVICE_ACK (IS) */

							I_call_ref_lgth = 1;
							Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

							break;

						case MAINT_STATE_B_OOS_MAINT_NE_ACK :

							I_(change_status, status) = CHANNEL_OUT_OF_SERVICE;

								/* Perform the audit */

							if (at9_audit (int_id, b_chan) == NOK) {

									/*
									 * No NS_SERVICE_CO has been sent.
									 * Send one.
									 */

								Set_call_ref_nil ();
								Send_to_call_control (NS_SERVICE_CO);
								ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
							}

							if (ns_nfas == ON) {
								p_nsna = Nfas_nai_p_active_d_chan;
								p_nsdl = Nfas_dl_p_active_d_chan;
							}

								/* Send back a SERVICE_ACK (OOS) */

							I_call_ref_lgth = 1;
							Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);


							break;

						case MAINT_STATE_B_MAINT_FE_ACK :

							I_(change_status, status) = CHANNEL_OUT_OF_SERVICE;

								/* Update B channel state */

							Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_MAINT_FE;

								/* Send a NS_SERVICE_CO to the application */

							Set_call_ref_nil ();
							Send_to_call_control (NS_SERVICE_CO);
							ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

							if (ns_nfas == ON) {
								p_nsna = Nfas_nai_p_active_d_chan;
								p_nsdl = Nfas_dl_p_active_d_chan;
							}

								/* Send back a SERVICE_ACK (OOS) */

							I_call_ref_lgth = 1;
							Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);


							break;
					}

					break;
			}


			break;

		case DA_MAINT_SERVICE_ACK :

				/* Only 1 B channel is impacted */

			if (Dl_b_chan_maint_nb (int_id) > 0) {
				Dl_b_chan_maint_nb (int_id)--;
			}

				/*
				 * Stop T317 only if all B channels have been
				 * processed.
				 */

			if (Dl_b_chan_maint_nb (int_id) == 0) {

					/* Stop DL timer T317 */

				Stop_dl_timer (AT9_T317);
			}

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_MAINTENANCE :
					Dl_b_chan_mode_int (int_id, b_chan) = B_chan_state_cancel_ack (current_state);
					break;

				case CHANNEL_IN_SERVICE :
				case CHANNEL_OUT_OF_SERVICE :
					ret_code = at9_audit (int_id, b_chan);
					break;
			}

			if (ret_code == NOK) {

					/* Send a NS_SERVICE_CO to the application */

				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);
			}

			break;


	}
}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_maint_ack_2 (int_id, b_chan)
	nai_t int_id;
	uchar b_chan;
{

	uchar current_state, cc_state;
	struct nsna FAR *p_na_sav;

	current_state	= Dl_b_chan_mode_int (int_id, b_chan);

	switch (event_id) {

		case DA_MAINT_SERVICE :

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_MAINTENANCE :

					if (current_state != MAINT_STATE_B_OOS_MAINT_NE) {
						current_state = MAINT_STATE_B_MAINT_FE;
						cc_state	  = CHANNEL_MAINTENANCE;
					} else {
						current_state = MAINT_STATE_B_OOS_MAINT_NE;
						cc_state	  = CHANNEL_OUT_OF_SERVICE;
					}

					Dl_b_chan_mode_int (int_id, b_chan) = current_state;
					I_(change_status, status) 			= cc_state;

						/* Send a NS_SERVICE_CO */

					Set_call_ref_nil ();
					Send_to_call_control (NS_SERVICE_CO);
					ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

					if (ns_nfas == ON) {
						p_nsna = Nfas_nai_p_active_d_chan;
						p_nsdl = Nfas_dl_p_active_d_chan;
					}

						/* Send back a SERVICE_ACK (MAINT) */

					I_call_ref_lgth = 1;
					Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

					break;

				case CHANNEL_OUT_OF_SERVICE :

					I_(change_status, status) = CHANNEL_OUT_OF_SERVICE;

					if (current_state == MAINT_STATE_B_OOS_MAINT_NE) {
						current_state =	MAINT_STATE_B_OOS_NE;
						cc_state	  = CHANNEL_OUT_OF_SERVICE;
					} else {
						current_state =	MAINT_STATE_B_OOS_FE;
						cc_state	  = CHANNEL_OUT_OF_SERVICE;
					}

					Dl_b_chan_mode_int (int_id, b_chan) = current_state;
					I_(change_status, status) 			= cc_state;

						/* Send a NS_SERVICE_CO */

					Set_call_ref_nil ();
					Send_to_call_control (NS_SERVICE_CO);
					ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

					if (ns_nfas == ON) {
						p_nsna = Nfas_nai_p_active_d_chan;
						p_nsdl = Nfas_dl_p_active_d_chan;
					}
						/* Send back a SERVICE_ACK (OOS) */

					I_call_ref_lgth = 1;
					Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

					break;

				case CHANNEL_IN_SERVICE :

					if (current_state == MAINT_STATE_B_OOS_MAINT_NE) {

						I_(change_status, status) = CHANNEL_OUT_OF_SERVICE;

							/*
							 * Send a NS_SERVICE_CO.
							 */

						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_NE;
						Set_call_ref_nil ();
						Send_to_call_control (NS_SERVICE_CO);
						ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

						if (ns_nfas == ON) {
							p_nsna = Nfas_nai_p_active_d_chan;
							p_nsdl = Nfas_dl_p_active_d_chan;
						}

							/* Send back a SERVICE_ACK (OOS) */

						I_call_ref_lgth = 1;
						Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);


					} else {

						I_(change_status, status) = CHANNEL_IN_SERVICE;
							/*
							 * Send a NS_SERVICE_CO.
							 */

						Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_IS;
						Set_call_ref_nil ();
						Send_to_call_control (NS_SERVICE_CO);
						ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

						if (ns_nfas == ON) {
							p_nsna = Nfas_nai_p_active_d_chan;
							p_nsdl = Nfas_dl_p_active_d_chan;
						}

							/* Send back a SERVICE_ACK (OOS) */

						I_call_ref_lgth = 1;
						Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);

					}

					break;

			}


			break;

		case MNS_SERVICE_RQ :

				/* Update the B channel state */

			if (I_(change_status, status) != CHANNEL_OUT_OF_SERVICE) {

					/*
					 * Ignore.
					 */

				break;
			}

			Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_NE;

				/*
				 * Send a MAINT_SERVICE.
				 * The primitive comes from MNS, so we have to
				 * select the Active D channel, unless we are
				 * using the TSP mode without D channel Backup.
				 */

			p_na_sav = p_nsna;

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

			Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);

				/*
				 * Send a NS_SERVICE_CO to the application.
				 */

			p_nsna = p_na_sav;
			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

			break;

	}
}

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

void at9_custom_undef (int_id)
	nai_t int_id;
{

	uchar i, j, b_chan, state, send_service_co;
	struct nsna FAR *p_na_sav;

		/*
		 * This routine is called when an entire
		 * interface is impacted.
		 */

	send_service_co = OFF;

	switch (event_id) {

		case TI_317 :

			switch (Dl_maint_action (int_id)) {
				default :
				case MAINT_ACTION_SERVICE_SENT :

						/* Prepare a channel Id for CC */

					I_chan_id_d_chan			= NOT_D_CHAN;		/* B-Channel indicated */
					I_chan_id_pref_excl			= CHAN_EXCL;		/* Exclusive */
					I_chan_id_int_type			= INT_TYPE_PRI;     /* PRI line */
					I_chan_id_chan_sel			= AS_INDICATED;		/* Channel Number as indicated in following octets */
					I_chan_id_nb_map			= CHAN_NUMBER;		/* Format of following octets = simply the B-Channel number */
					I_chan_id_chan_number_lgth	= 0;				/* 0 Channel number yet */
					I_chan_id_a_chan_number 	= p_ind_buffer;		/* save data into indirect buffer */					I_(chan_id, int_id) 		= INT_ID_EXPLICIT;	/* Interface Id is explicit */
					I_(chan_id, int_id_val)		= int_id;			/* Interface Id value */

					j = 0;

					for (i = 0; i < NS_MX_B_CHAN_T1; i++) {

						b_chan = (i+1);

						switch (Dl_b_chan_mode_int (int_id, b_chan)) {

							case MAINT_STATE_B_OOS_FE_ACK :
							case MAINT_STATE_B_IS_ACK :

									/*
									 * Mark OOS FE the B channels belonging to
									 * this interface which are not active.
									 */

								I_chan_id_a_chan_number[j++] = b_chan;
								I_chan_id_chan_number_lgth++;
								Dl_b_chan_mode_int (int_id, b_chan) = MAINT_STATE_B_OOS_FE;
								break;

							case MAINT_STATE_B_IS_MAINT_NE_ACK :
							case MAINT_STATE_B_OOS_MAINT_NE_ACK :
							case MAINT_STATE_B_MAINT_FE_ACK :

									/* Process the Audit */

								at9_audit (int_id, b_chan);
								break;

						} /* Switch */

					}

					if (I_chan_id_chan_number_lgth != 0) {

							/* Update p_ind_buffer */

						p_ind_buffer += I_chan_id_chan_number_lgth;

							/* At least, 1 B channel is not IS */

						set_ie_i (CODESET_0, CHAN_ID);

						I_(change_status, status)		= CHANNEL_OUT_OF_SERVICE;
						I_(change_status, preference)	= PREF_B_CHANNEL;

						set_ie_i (CODESET_0, CHANGE_STATUS);

						Set_call_ref_nil ();
						Send_to_call_control (NS_SERVICE_CO);
						ns_send_mns_service (OK,int_id, *I_chan_id_a_chan_number);

					}

					break;
			}

			break;

		case MNS_SERVICE_RQ :

				/* Update the B channel state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					state = MAINT_STATE_B_OOS_FE_ACK;
					break;
				case CHANNEL_MAINTENANCE :
					state = MAINT_STATE_B_OOS_MAINT_NE_ACK;
					break;
				case CHANNEL_OUT_OF_SERVICE :
					state = MAINT_STATE_B_OOS_NE;
					send_service_co = ON;
					break;
			}

			for (i = 0; i < NS_MX_B_CHAN_T1; i++) {
				b_chan = (i+1);
				Dl_b_chan_mode_int (int_id, b_chan) = state;

			}

			if (Is_B_chan_state_wait_for_ack (state)) {

					/* The entire interface is impacted */

				Dl_b_chan_maint_nb (int_id) = 23;

				if (State_dl_timer (AT9_T317) == OFF) {

						/*
						 * Only 1 timer 317 per D channel ...
						 * So only 1 T317 for all the interfaces
						 * managed by the D channel
						 */


						/* Start DL timer T317 */

					Start_dl_timer (AT9_T317);
				}
			}

				/* Record the type of action being made */

			Dl_maint_action (int_id) = MAINT_ACTION_SERVICE_SENT;

				/*
				 * Send a MAINT_SERVICE.
				 * The primitive comes from CC, so we have to
				 * select the Active D channel, unless we are
				 * using the TSP mode without D channel Backup.
				 */

			p_na_sav = p_nsna;

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

			Send_to_d_channel_proto (MAINT_SERVICE, PROTOCOL_DISCR_MAINT_ATT_CUST);

			if (send_service_co == ON) {

					/* Send a NS_SERVICE_CO to the application */

				p_nsna = p_na_sav;
				Set_call_ref_nil ();
				Send_to_call_control (NS_SERVICE_CO);
				ns_send_mns_service (OK,int_id, 0);
			}

			break;

		case DA_MAINT_SERVICE :

			Dl_b_chan_maint_nb (int_id) = 0;

				/* Update the B channels state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					state = MAINT_STATE_B_IS;
					break;

				case CHANNEL_MAINTENANCE :
				case CHANNEL_OUT_OF_SERVICE :
					state = MAINT_STATE_B_OOS_FE;
					break;
			}

				/* Stop DL timer T317 */

			Stop_dl_timer (AT9_T317);

			for (i = 0; i < NS_MX_B_CHAN_T1; i++) {
				b_chan = (i+1);
				Dl_b_chan_mode_int (int_id, b_chan) = state;

			}

				/* Send a NS_SERVICE_CO to the application */

			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, 0);

			if (ns_nfas == ON) {
				p_nsna = Nfas_nai_p_active_d_chan;
				p_nsdl = Nfas_dl_p_active_d_chan;
			}

				/* Send back a SERVICE_ACK */

			I_call_ref_lgth = 1;
			Send_to_d_channel_proto (MAINT_SERVICE_ACK, PROTOCOL_DISCR_MAINT_ATT_CUST);
			break;

		case DA_MAINT_SERVICE_ACK :

			Dl_b_chan_maint_nb (int_id) = 0;

				/* Update the B channels state */

			switch (I_(change_status, status)) {

				case CHANNEL_IN_SERVICE :
					state = MAINT_STATE_B_IS;
					break;

				case CHANNEL_MAINTENANCE :
				case CHANNEL_OUT_OF_SERVICE :
					state = MAINT_STATE_B_OOS_FE;
					break;
			}

				/* Stop DL timer T317 */

			Stop_dl_timer (AT9_T317);

			for (i = 0; i < NS_MX_B_CHAN_T1; i++) {
				b_chan = (i+1);
				Dl_b_chan_mode_int (int_id, b_chan) = state;
			}

				/* Send a NS_SERVICE_CO to the application */

			Set_call_ref_nil ();
			Send_to_call_control (NS_SERVICE_CO);
			ns_send_mns_service (OK,int_id, 0);
			break;
	}
}

#endif /* } */


/*EOF*/
