/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - appli.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *	appli					-	Application entity entry point.
 *
 *	ap_config				-	configuration function.
 *
 *	ap_call_init			-	call context initialisation.
 *	ap_call_clear			-	call context clearing.
 *	ap_access_call			-	access to a particular call context.
 *	ap_access_nai			-	access to a particular nai context.
 *	ap_access_term_id		-	access to a particular VS terminal context.
 *
 *	ap_process_sm_msg		-	processes a message coming from SM entity.
 *	ap_process_cc_msg		-	processes a message coming from CC entity.
 *	ap_process_vs_msg		-	processes a message coming from VS entity.
 *	ap_process_user_msg		-	processes a message coming from User pseudo-entity.
 *	ap_process_mppp_msg		-	processes a message coming from Multi-link PPP entity.
 *
 *	ap_build_and_send_to_cc	-	builds and sends a message to CC.
 *	ap_build_acu_conn_rq	-	builds an ACU_CONN_RQ message.
 *	ap_build_acu_conn_rs	-	builds an ACU_CONN_RS message.
 *	ap_build_acu_clear_rq	-	builds an ACU_CLEAR_RQ message.
 *	ap_build_acu_clear_rs	-	builds an ACU_CLEAR_RS message.
 *
 *	user_build_and_send_to_appli - builds and sends a message to the Appli.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|														|*/
/*|	 ISDN-BRICKS										|*/
/*|														|*/
/*|	 Copyright (c) 1992 by OMNITEL SA					|*/
/*|	 All Rights Reserved.								|*/
/*|														|*/
/*[]---------------------------------------------------[]*/

#include "services.h"
#include "cc_int.h"
#include "acu_int.h"
#include "isdn.h"
#include "vs_int.h"
#include "ap_par.h"
#include "ph_d_int.h"
#include "dd_int.h"

#if MULTILINK_PPP_SUPPORT == ON
#    include "mppp_int.h"
#endif

    /* RISC OS system includes */

#if OS == RISC_OS
#   include "stdio.h"
#   include "kernel.h"
#   include "swis.h"
#endif

/*-------------------------------------------------------------------------*/

		/* Internal Application structures */

struct ap_call_ctx {

	nai_t		nai;		/* NAI value */
	sapi_t		sapi;		/* call sapi */
	add_t		conn_id;	/* Call conn-id */
	add_t		term_id;	/* Terminal ID (for V.120) */
    	uchar		chani;	    	/* channel identifier */
	uchar		service;	/* Current service requested */
	ent_id_t	cc_entity;	/* Call control entity : ENT_CC or ENT_MPPP */
	ent_id_t	ph_entity;	/* Physical layer entity : ENT_PH_B or ENT_MPPP */
	uchar		call_state;	/* Current call state */
	sapi_t		ph_sapi;	/* PH sapi */
	add_t		data_chani;	/* Data Channel id */
	uchar		ph_state;	/* PH state */
	uchar		v120_state;	/* AP V120 state */
	uchar		nb_calls;	/* # of calls processed */

};

	/* Macros to have access to these contexts thru p_ap_call_ctx pointer */

#define Ap_call_nai		p_ap_call_ctx -> nai
#define Ap_call_sapi		p_ap_call_ctx -> sapi
#define Ap_call_conn_id		p_ap_call_ctx -> conn_id
#define Ap_call_term_id		p_ap_call_ctx -> term_id
#define Ap_call_chani	    	p_ap_call_ctx -> chani
#define Ap_service		p_ap_call_ctx -> service
#define Ap_cc_entity		p_ap_call_ctx -> cc_entity
#define Ap_call_state		p_ap_call_ctx -> call_state
#define Ap_ph_sapi		p_ap_call_ctx -> ph_sapi
#define Ap_data_chani		p_ap_call_ctx -> data_chani
#define Ap_ph_state		p_ap_call_ctx -> ph_state
#define Ap_ph_entity		p_ap_call_ctx -> ph_entity
#define Ap_v120_state		p_ap_call_ctx -> v120_state
#define Ap_call_nb		p_ap_call_ctx -> nb_calls

	/* Basic Call states definitions */

#define STATE_IDLE			0
#define STATE_NULL			0
#define STATE_OUTGOING			3
#define STATE_INCOMING			6
#define STATE_OUTGOING_ACTIVE		10
#define STATE_INCOMING_ACTIVE		11
#define STATE_ACTIVE			STATE_OUTGOING_ACTIVE
#define STATE_INCOMING_CLEARING		12
#define STATE_OUTGOING_CLEARING		19
#define STATE_BUSY			20

/*-------------------------------------------------------------------------*/

		/* Global variables */

		/*
			1- Entity's global message/buffer pointers
		*/
#       define  event_id            event_id_appli       /* event identifier */
#       define  ret_code            ret_code_appli       /* return code */
#       define  p_snd_msg           p_snd_msg_appli      /* pointer on the current message to send if any */
#       define  p_rcv_msg           p_rcv_msg_appli      /* pointer on the current received message if any */
#       define  p_buffer            p_buffer_appli       /* pointer on the curent buffer if any */
#       define  p_buffer_end        p_buffer_end_appli   /* pointers on the end of the current buffer if any */
#       define  os_err              os_err_appli         /* OS error code */
		Entity_common         (appli);            /* APPLI entity common variables */

		/*
			2- Entity's global Table of call contexts
		*/

struct ap_call_ctx t_ap_call_ctx [AP_CALL_CTX_NB];

	/* Global call context pointer */

struct ap_call_ctx FAR *p_ap_call_ctx;

	/* Dummy call context used to avoid spurrious access */

struct ap_call_ctx ap_call_ctx_dummy;

/*-------------------------------------------------------------------------*/

		/* Function prototypes */

#	if NEW_FCT_STYLE == ON
		uchar	ap_config					(void);
		void	ap_call_init				(nai_t nai, add_t conn_id);
		void	ap_call_clear				(void);
		void	ap_process_sm_msg			(void);
		void	ap_process_cc_msg			(void);
		void	ap_process_vs_msg			(void);
		void	ap_process_user_msg			(void);
		void	ap_process_ph_msg			(void);
#		if MULTILINK_PPP_SUPPORT == ON
			void	ap_process_mppp_msg			(void);
			void	ap_retransmit_sig_to_mppp 	(code_t code);
			void	ap_retransmit_ph_to_mppp 	(code_t code);
#		endif			
		void	ap_build_and_send_to_cc		(code_t code);
		ushort	ap_build_acu_conn_rq		(uchar FAR *p_data);
		ushort	ap_build_acu_conn_rs		(uchar FAR *p_data);
		ushort	ap_build_acu_clear_rq		(uchar FAR *p_data);
		ushort	ap_build_acu_clear_rs		(uchar FAR *p_data);
		uchar	ap_access_call				(nai_t nai, add_t conn_id);
		uchar	ap_access_nai				(nai_t nai);
		uchar	ap_access_term_id			(nai_t term_id);
	    	void ap_retransmit_to_cc (code_t code);
	    	void ap_retransmit_to_sm (code_t code);
	    	void ap_retransmit_to_vs (code_t code);
    		void ap_retransmit_to_ph (code_t code);
    		void ap_retransmit_to_mppp (code_t code);
		void ap_send_vs_init_rq 	 (void);
		void ap_send_vs_stop_rq 	 (void);
		void ap_send_acu_alert_rq 	 (void);
		void ap_send_acu_clear_rs 	 (void);
		void ap_send_acu_clear_rq 	 (uchar cause);
		extern void user_build_and_send_to_appli	(code_t code, nai_t nai, add_t conn_id);
		extern struct buffer FAR *ap_ppp_asyn_encode 	(struct buffer FAR *p_in_buffer);
		extern struct buffer FAR *ap_ppp_asyn_decode 	(struct buffer FAR *p_in_buffer);
		extern uchar ap_ppp_asyn_init 			(void);
		extern void ap_ppp_asyn_start 			(void);
		extern void ap_ppp_asyn_stop 			(void);
#	else
		uchar	ap_config					();
		void	ap_call_init				();
		void	ap_call_clear				();
		void	ap_process_sm_msg			();
		void	ap_process_cc_msg			();
		void	ap_process_vs_msg			();
		void	ap_process_user_msg			();
		void	ap_process_ph_msg			();
#		if MULTILINK_PPP_SUPPORT == ON
			void	ap_process_mppp_msg		();
			void	ap_retransmit_sig_to_mppp 	();
			void	ap_retransmit_ph_to_mppp 	();
#		endif			
		void	ap_build_and_send_to_cc		();
		ushort	ap_build_acu_conn_rq		();
		ushort	ap_build_acu_conn_rs		();
		ushort	ap_build_acu_clear_rq		();
		ushort	ap_build_acu_clear_rs		();
		uchar	ap_access_call				();
		uchar	ap_access_nai				();
		uchar	ap_access_term_id			();
    		void ap_retransmit_to_cc 			();
   		void ap_retransmit_to_sm 			();
	    	void ap_retransmit_to_vs 			();
    		void ap_retransmit_to_ph 			();
    		void ap_retransmit_to_mppp 			();
		void ap_send_vs_init_rq 	 		();
		void ap_send_vs_stop_rq 	 		();
		void ap_send_acu_alert_rq 	 		();
		void ap_send_acu_clear_rs 	 		();
		void ap_send_acu_clear_rq 	 		();
		extern void user_build_and_send_to_appli	();
		extern void user_build_and_send_to_appli	();
		extern struct buffer FAR *ap_ppp_asyn_encode 	();
		extern struct buffer FAR *ap_ppp_asyn_decode 	();
		extern uchar ap_ppp_asyn_init 			();
		extern void ap_ppp_asyn_start 			();
		extern void ap_ppp_asyn_stop 			();
#	endif


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            appli - implements an Application entity entry point.

Usage           uchar appli (p_msg);

*--------------------------------------------------------------------------*/

uchar appli (p_msg)
	struct message FAR *p_msg;		/* local pointer on received message */
{

		/* Init the entity pointers */

		/*
			copy the local pointer into the global received message pointer
			so that we can access to it in every other C file
		*/

	p_rcv_msg 	= p_msg;

		/* Get the pointer to its linked buffer if any */

	p_buffer 	= R_msg_p_buffer;

		/* Initialise the pointer to a message to sent to P_NIL */

	p_snd_msg 	= P_NIL;


		/* Process the received message */

	switch (R_msg_from) {

			/* Message coming from SM entity */

		case ENT_SM :
			ap_process_sm_msg ();
			break;

			/* Message coming from CC entity */

		case ENT_CC :
			ap_process_cc_msg ();
			break;

			/* Message coming from VS entity (V120 PAD entity) */

		case ENT_VS :
			ap_process_vs_msg ();
			break;

			/* Message coming from PH entity */

		case ACU_PH_ENTITY :
   			ap_process_ph_msg ();
			break;

			/* Message coming from User-pseudo entity */

		case ENT_USER :
			ap_process_user_msg ();
			break;

#		if MULTILINK_PPP_SUPPORT == ON			
			case ENT_MPPP :
				ap_process_mppp_msg ();
				break;
#		endif

		default :
			break;

	}

		/* Free the received message if necessary */

	Free_msg (p_rcv_msg);

		/* Return */

	return (OK);

}

/*==========================================================================*/

	/*-=-=-=-=-=-=-=-=-=-=-=-=*/
	/*                        */
	/* Message from SM entity */
	/*                        */
	/*-=-=-=-=-=-=-=-=-=-=-=-=*/

void ap_process_sm_msg ()
{
  	uchar FAR * p_data;
  	
  	p_data = R_a_data;
  	
	switch (R_msg_code) {

		case SM_SET_CONFIG_RQ:

				/*
					Upon receipt of the configuration message from SM,
					initialise the application entity's contexts.
				*/

			ret_code = ap_config ();

#			if AP_PPP_CONVERSION == ON

				if (ret_code != OK) {
					Trace_string(" ap_ppp_asyn_init : NOK\n");  
				}  

#			endif
			Confirm_ret_code = ret_code;			
    	    	    	ap_retransmit_to_sm (SM_SET_CONFIG_CO);
			break;

		case SM_RESET_CONFIG_RQ:
			
			if ((ret_code = ap_access_nai (R_msg_nai)) == OK) {
	    	    	    	ap_retransmit_to_sm (SM_RESET_CONFIG_CO);
			
			}
			break;
			
		case SM_STOP_RQ:

			if ((ret_code = ap_access_nai (R_msg_nai)) == OK) {
				ap_call_clear ();
			}
#			if AP_PPP_CONVERSION == ON
				ap_ppp_asyn_stop ();	
#			endif
    	    	    	ap_retransmit_to_sm (SM_STOP_CO);
			break;
		
		case SM_SET_CONFIG_CO :
				/* end of configuration process :	 */
				/*  enable ISDN it. as last as possible  */
Trace_string("Isdn_card_it_enable \n");
			Isdn_card_it_enable (); /* enable ISDN interrupts as late as possible */
			
				/* inform ISDNCTRL */
				
			break;


	}

}

	/*-=-=-=-=-=-=-=-=-=-=-=-=*/
	/*                        */
	/* Message from CC entity */
	/*                        */
	/*-=-=-=-=-=-=-=-=-=-=-=-=*/

void ap_process_cc_msg ()
{
    	uchar FAR *p_data;
  	char incoming_called_address[CC_MX_SZ_CALLED_NB + CC_MX_SZ_CALLED_SUB_ADD+2];

		/* Access to the proper call context */

	if (ap_access_nai (R_msg_nai) == NOK) {
Trace_string("Undefined Call context for nai ");Trace_int(R_msg_nai);Trace('\n');
			/* Undefined Call context : process here some error */

		return;
	}

    	p_data = R_a_data;
	
	    /* Very simple state machine... */

	switch (R_msg_code) {
		
			/* Receive Incoming call indication : answer */

		case ACU_CONN_IN:
		
			Ap_call_conn_id = R_msg_conn_id;
          		
          		if (Acu_conn_in_called_nb_size < (CC_MX_SZ_CALLED_NB + CC_MX_SZ_CALLED_SUB_ADD+2)) {
 				strncpy(incoming_called_address, Acu_conn_in_a_called_nb, Acu_conn_in_called_nb_size);
            			incoming_called_address[Acu_conn_in_called_nb_size]='\0';
          		} else {
            			*incoming_called_address='\0';
        		}
 			
 			if (isdnctrl_autoanswer!=AUTOANSWER_NORING && call_matches (incoming_called_address)) {
 			
				Ap_call_state = STATE_INCOMING;
				
					/* select service according to DTE channel associated */
				
				switch (Acu_conn_in_service_list_id) {
					case DTE_CHANNEL_PPP :	/* 7 */
						Ap_service = ACU_DATA_SERVICE;
						break;

					case DTE_CHANNEL_V120 :	/* 10 */
						Ap_service = ACU_V120_SERVICE;
						break;

					case DTE_CHANNEL_ML_PPP_SYN :	/* 27 */
					Trace_string ("Ap_service = USER_PROFILE_MPPP_SYNC\n");
						Ap_service = USER_PROFILE_MPPP_SYNC;
						break;


					case DTE_CHANNEL_ML_PPP_ASYN :	/* 28 */
					Trace_string ("Ap_service = USER_PROFILE_MPPP_ASYNC\n");
						Ap_service = USER_PROFILE_MPPP_ASYNC;
						break;

					default :	/* service is compatible */
				
					  		/* service will be sent in the ACU_CONN_RS */
						  		 
						Ap_service = ACU_NO_SERVICE;	
						break;				
				}  
 				ap_send_acu_alert_rq ();    /* send ALERT_RQ to CC */
			
 			} else {  /* isdnctrl_autoanswer!=AUTOANSWER_NORING 
 				&& call_matches (incoming_called_address) */
 				
 				Ap_call_state = STATE_OUTGOING_CLEARING;
 				Ap_service = ACU_NO_SERVICE;
				ap_send_acu_clear_rq (19);    /* incompatible address */
 				return;	           /* don't call isdnctrl */
 			}    
			break;

			/*
				Receive Incoming call confirmation :
				the call is now active.

			*/

		case ACU_CONN_CO:
Trace_string("B channel : ");Trace_int(Acu_conn_co_data_chani);Trace('\n');

			if ( Ap_call_state == STATE_OUTGOING) {
				Ap_call_state = STATE_OUTGOING_ACTIVE;
			} else {
				Ap_call_state = STATE_INCOMING_ACTIVE;

			}  	
    	    	    	
    	    	    	Ap_call_chani = R_msg_add;
    	    	    	Ap_data_chani = Acu_conn_co_data_chani;

    	    	    	switch (Ap_service) {
    	    	    		case ACU_DATA_SERVICE :

#					if AP_PPP_CONVERSION == ON
						ap_ppp_asyn_start ();	
#					endif
					isdndata_activated (0, Min (1532, Buffer_data_lgth));

    	    	    			break;

				case ACU_V120_SERVICE :
    	    	    			ap_send_vs_init_rq ();
    	    	    			break;

    	    	    		case USER_PROFILE_MPPP_ASYNC :

#					if AP_PPP_CONVERSION == ON
						ap_ppp_asyn_start ();	
						isdndata_activated (0, Min (1532, Buffer_data_lgth));
#					else
						isdndata_activated (MPPP_DATA_HEADER_SIZE, 
						Min (1532, Buffer_data_lgth - MPPP_DATA_HEADER_SIZE));
#					endif

    	    	    			break;
    	    	    				/* don't need to convert data in Synchronous PPP mode */

							case USER_PROFILE_MPPP_SYNC :
					isdndata_activated (MPPP_DATA_HEADER_SIZE,
					Min (1532, Buffer_data_lgth - MPPP_DATA_HEADER_SIZE));
								break;

				default :
								break;
						}
			break;

			/* Receive Incoming call clearing indication : response to it */
			
		case ACU_CLEAR_IN:
			Ap_call_state = STATE_INCOMING_CLEARING;
			ap_send_acu_clear_rs ();
			break;
			
			
			/* Receive call clearing confirmation : that's all folks! */

		case ACU_CLEAR_CO:

						if ((Ap_call_state == STATE_OUTGOING_ACTIVE)
						   || (Ap_call_state == STATE_INCOMING_ACTIVE)
						   || (Ap_call_state == STATE_OUTGOING_CLEARING)
						   || (Ap_call_state == STATE_INCOMING_CLEARING)) {

				/* Clear the call context */

							switch (Ap_service) {
								case ACU_DATA_SERVICE :
								case USER_PROFILE_MPPP_SYNC :
								case USER_PROFILE_MPPP_ASYNC :

#						if AP_PPP_CONVERSION == ON
							ap_ppp_asyn_stop ();
#						endif

									break;

					case ACU_V120_SERVICE :
									ap_send_vs_stop_rq ();
									break;

					default :
									break;
							}
						}

			isdndata_deactivated ();
			ap_call_clear ();
			break;

				/* Receive call progress indication */

		case ACU_PROGRESS_IN:
			break;

			/* Receive alert indication : that's all folks! */

		case ACU_ALERT_IN:
				break;

		case ACU_TEST_CO:
				break;

	}
	isdnctrl_process_cc_msg(p_rcv_msg, p_buffer, Ap_service);
}

void ap_process_vs_msg ()
{
    	uchar FAR *p_data;
    	ushort	   data_size;
  

		/* Access to the proper call context */

	if (ap_access_term_id (R_msg_nai) == NOK) {

			/* Undefined Call context : process here some error */

		return;
	}

	p_data = R_a_data;
	data_size = R_data_size;
	
	
		/* Process the event received from PH */

    	switch (R_msg_code) {

    	    case VS_INIT_CO :
		
		if (Vs_init_ret_code == OK) {		
		    isdndata_activated (V120_HOLE_SIZE, DEF_V120_FRAME_SIZE);

		} else {      /* VS INIT failed */

    		    Ap_call_state = STATE_OUTGOING_CLEARING;
    		    	
    		    	/* no cause for that event */
    		    	
		    ap_send_acu_clear_rq (0);
		}  
		break;
		
    	    case VS_DA_IN :
		isdndata_receive (p_data, (int)data_size);
	    	break;
	    	
    	    case VS_SIGNAL_IN :
	    	break;

                                      /* VS BUSY INDICATION */
    	    case VS_BUSY_IN :
		isdndata_tx_flowcontrol (ON);	
	    	break;

				/* VS CLEAR BUSY INDICATION */	
    	    case VS_CLEAR_BUSY_IN :
		isdndata_tx_flowcontrol (OFF);	
	    	break;
			
   	    default :
    	    	break;
    	}
}


	/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
	/*                                 */
	/* Message from User-pseudo entity */
	/*                                 */
	/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

void ap_process_user_msg ()
{
	uchar FAR *p_data;

#	if AP_PPP_CONVERSION == ON
		struct buffer FAR *p_out_buffer;
#	endif	
		/* Access to the proper call context */

	if (ap_access_nai (R_msg_nai) == NOK) {
Trace_string( "Undefined Call context \n");

			/* Undefined Call context : process here some error */

		return;
	}
	p_data = R_a_data;
	
    	switch (R_msg_sapi) {
    	
    		case USER_ACU_SAPI :
		    Ap_call_sapi = R_msg_sapi;
			    	
			/* Build and send the received event to CC */

	    	    switch (R_msg_code) {

    		    	case ACU_CONN_RQ :

				/* The call context must be free */

			    switch (Ap_call_state) {

			    /* The call context is free: send ACU_CONN_RQ */

				case STATE_NULL:
					Ap_service = Acu_conn_rq_service;
					switch (Ap_service) {
						case ACU_V120_SERVICE :
		    	    	    		case ACU_DATA_SERVICE :
							Ap_cc_entity = ENT_CC;
							Ap_ph_entity = ENT_PH_B;
							break;

#						if MULTILINK_PPP_SUPPORT == ON

		    	    	    			case USER_PROFILE_MPPP_SYNC :
    	    			    			case USER_PROFILE_MPPP_ASYNC :
								Ap_cc_entity = ENT_MPPP;
								Ap_ph_entity = ENT_MPPP;
								break;			
#						endif								
					}
					  
					Ap_call_conn_id = R_msg_conn_id;
    	    	    			ap_retransmit_to_cc (ACU_CONN_RQ);
			    		Ap_call_state = STATE_OUTGOING;
			    		break;

					/*
						An incoming call is is beeing established, so assume
						that the event stands for ACU_CONN_RS (means that we
						have only 1 event for both incoming and outgoing call
						requests).
					*/

				case STATE_INCOMING:
			    		ap_retransmit_to_cc (ACU_CONN_RS);
			    		Ap_call_state = STATE_INCOMING_ACTIVE;
			    		break;

					/* Otherwise ignore the event */

		    	    }
		    	    break;

			case ACU_CONN_RS :
					/* Only available if an incoming call is beeing established */

		    		if (Ap_call_state == STATE_INCOMING) {
		    		  		/* 
		    		  		set service associated to the DTE channel 
		    		  		*/	
					if (Ap_service != ACU_NO_SERVICE) {
						Acu_conn_rs_service = Ap_service;

                                        } else {	/* service was not selected by CC */
                                        		/* the user chooses it */
						Ap_service = Acu_conn_rs_service;
                                        
                                        }  

					switch (Ap_service) {
						case ACU_V120_SERVICE :
		    	    	    		case ACU_DATA_SERVICE :
							Ap_cc_entity = ENT_CC;
							Ap_ph_entity = ENT_PH_B;
							break;

#						if MULTILINK_PPP_SUPPORT == ON

		    	    	    			case USER_PROFILE_MPPP_SYNC :
    	    			    			case USER_PROFILE_MPPP_ASYNC :
								Ap_cc_entity = ENT_MPPP;
								Ap_ph_entity = ENT_MPPP;
								break;			
#						endif								
					}
					  
					ap_retransmit_to_cc (ACU_CONN_RS);
				}

		    		break;

			case ACU_CLEAR_RQ :

		    		switch (Ap_call_state) {

				/* The call context is free: ignore the request */

					case STATE_NULL:
		    	    			break;

					/*
						The call is beeing cleared: assume the event stands
						for ACU_CLEAR_RS (means that we have only 1 event for
						both incoming and outgoing call clearing requests).
					*/

					case STATE_INCOMING_CLEARING:
    					    ap_retransmit_to_cc (ACU_CLEAR_RS);
					    break;

					default:
			    		    Ap_call_state = STATE_OUTGOING_CLEARING;
			    		    ap_retransmit_to_cc (ACU_CLEAR_RQ);
			    		    break;

		    		}
    		    		break;

			case ACU_CLEAR_RS :

		    		if (Ap_call_state == STATE_INCOMING_CLEARING) {
					ap_retransmit_to_cc (ACU_CLEAR_RS);
		    		}

		    		break;
		    		
			case ACU_TEST_RQ :
				ap_retransmit_to_cc (ACU_TEST_RQ);
		    		break;

	    	    }
		    break;	/* case USER_ACU_SAPI :*/

    		case USER_DATA_SAPI :

			/* Build and send the received event to PH */

	    	    switch (R_msg_code) {

    		    	case PH_DA_RQ :

    	    	    	    switch (Ap_service) {
				case ACU_V120_SERVICE :
  		    		    ap_retransmit_to_vs (VS_DA_RQ);
    	    	    		    break;

			        default :
    	    	    		case ACU_DATA_SERVICE :

#					if MULTILINK_PPP_SUPPORT == ON
	    	    	    			case USER_PROFILE_MPPP_ASYNC :
#					endif		    		    

					if (Ap_ph_state == STATE_ACTIVE) {
					
							/* convert PPP async. data to sync. frames */

#						if AP_PPP_CONVERSION == ON
							p_out_buffer = ap_ppp_asyn_decode (R_msg_p_buffer);

							if (p_out_buffer == P_NIL) {
								break;
						
							} else {  
							  
								Free_buffer (R_msg_p_buffer);
								R_msg_p_buffer = p_out_buffer;
								p_buffer = R_msg_p_buffer; 
							}  
#						endif

  		    		        	ap_retransmit_to_ph (PH_DA_RQ);

    		    		    	}

    	    	    		    break; 	/* case USER_PROFILE_MPPP_ASYNC */
						/* case ACU_DATA_SERVICE        */
						
					/* no conversion necessary with Async. PPP data */

#				if MULTILINK_PPP_SUPPORT == ON

	    	    	    		case USER_PROFILE_MPPP_SYNC :

						if (Ap_ph_state == STATE_ACTIVE) {
  			    		        	ap_retransmit_to_ph (PH_DA_RQ);

    		    			    	}
#				endif				
    			    	break;
    	    	    	
    	    	    	    }  /* switch (Ap_service) { */
    	    	    	    break;
    	    	    
    		    	case PH_BUSY_RQ :
    	    	    	    switch (Ap_service) {
			        default :
    	    	    		case ACU_DATA_SERVICE :

#				if MULTILINK_PPP_SUPPORT == ON
	    	    	    		case USER_PROFILE_MPPP_SYNC :
    		    	    		case USER_PROFILE_MPPP_ASYNC :
#				endif
		    		    
		    		    if (Ap_ph_state == STATE_ACTIVE) {

		    		        ap_retransmit_to_ph (PH_BUSY_RQ);
    		    		    }
    	    	    		    break;

				case ACU_V120_SERVICE :
  		    		    ap_retransmit_to_vs (VS_BUSY_RQ);
    	    	    		    break;
    	    	    	
    	    	    	    }  
    	    	    	    break;
    	    	    
    		    	case PH_CLEAR_BUSY_RQ :
    	    	    	    switch (Ap_service) {
			        default :
    	    	    		case ACU_DATA_SERVICE :

#				if MULTILINK_PPP_SUPPORT == ON
	    	    	    		case USER_PROFILE_MPPP_SYNC :
    		    	    		case USER_PROFILE_MPPP_ASYNC :
#				endif
		    		    
		    		    if (Ap_ph_state == STATE_BUSY) {

		        		ap_retransmit_to_ph (PH_CLEAR_BUSY_RQ);
    		    		    }
    	    	    		    break;


				case ACU_V120_SERVICE :
  		    		    ap_retransmit_to_vs (VS_CLEAR_BUSY_RQ);
    	    	    		    break;
    	    	    	
    	    	    	    }  
    	    	    	    break;
    	    	    
    	    		default :
    	    	    	    break;
    	    	    }
                    break;	/* case USER_DATA_SAPI : */

#		if MULTILINK_PPP_SUPPORT == ON	/* { */
 
    	    	    	case USER_EXT_EVENTS_SAPI:
     				R_msg_from	= ENT_APPLI;
    				R_msg_to	= ENT_MPPP;
        			R_msg_sapi 	= MPPP_SAPI_EXT_EVENTS;
    				R_msg_add 	= 0;
					
				Trace_string ("\nAppli sending MPPP EXT Event (");
				Trace (R_msg_code);
				Trace_string (")");
					
					/* Send the message */

    				Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;
    				break;
   	    	    			
 #		endif	/* MULTILINK_PPP_SUPPORT case USER_BOD_SAPI } */       
                
	} 	/*    	switch (R_msg_sapi) {  */
	
                    
}

void ap_process_ph_msg ()
{
    	uchar FAR *p_data;
    	ushort	   data_size;

#	if AP_PPP_CONVERSION == ON
		struct buffer FAR *p_out_buffer;
#	endif	
  

		/* Access to the proper call context */

	if (ap_access_nai (R_msg_nai) == NOK) {


			/* Undefined Call context : process here some error */

		return;
	}

	p_data = R_a_data;
	data_size = R_data_size;
	
	
		/* Process the event received from PH */

    	switch (R_msg_code) {

    	    case PH_DA_IN :
    	    	    switch (Ap_service) {

   	    	    	case ACU_DATA_SERVICE :

#			    if MULTILINK_PPP_SUPPORT == ON
    		    	        case USER_PROFILE_MPPP_ASYNC :
#			    endif

#			    if AP_PPP_CONVERSION == ON

			        p_out_buffer = ap_ppp_asyn_encode (R_msg_p_buffer);

				if (p_out_buffer != P_NIL) {
				    Free_buffer (R_msg_p_buffer);
				    R_msg_p_buffer	= p_out_buffer;
				    p_out_buffer 	= P_NIL; 
				    p_data		= R_a_data;
				    data_size	= R_data_size;
					
					/* send to PPP only correctly encoded data */

				    isdndata_receive (p_data, (int)data_size);

				}

#				else
  	    
				    isdndata_receive (p_data, (int)data_size);
#				endif
		    		
		    		break;

#			if MULTILINK_PPP_SUPPORT == ON
				
				/* no conversion in Synchronous PPP mode */
				
	    	    	    case USER_PROFILE_MPPP_SYNC :
			        isdndata_receive (p_data, (int)data_size);
		    	        break;
#			endif
				
		    } /* switch (Ap_service) { */
		    break;
	    	
    	    case PH_ACT_IN :
			
			/* set PH state to active */
				
		Ap_ph_state = STATE_ACTIVE;
		
			/* store PH sapi in context */

                Ap_ph_sapi	= R_msg_sapi;
	    	break;

    	    case PH_DEA_IN :
			
			/* reset PH state to null */
				
		Ap_ph_state = STATE_NULL;
	    	break;

    	    case PH_BUSY_IN :
			
			/* set PH state to BUSY */
				
		Ap_ph_state = STATE_BUSY;
	    	break;
	    	
    	    case PH_CLEAR_BUSY_IN :
			
			/* reset PH state to ACTIVE */
				
		Ap_ph_state = STATE_ACTIVE;
	    	break;

   	    default :
    	    	break;
    	}
}

	/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
	/*                                    */
	/* Message from Multilink PPP entity  */
	/*                                    */
	/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if MULTILINK_PPP_SUPPORT == ON

	/* This array contains the link references we can use in Drop-Requests */
	
#define MX_LINKS	3
sppp_ref_t	link_ref_tab[MX_LINKS];	

void ap_process_mppp_msg ()
{
	uchar 		i;
	sppp_ref_t	link_ref;
	ulong		link_speed;
	uchar	FAR    *p_data;
  		
	switch (R_msg_sapi) {
		case MPPP_SAPI_SIG :
	  
  			/* Signalling messages */
  			  
	  		R_msg_sapi = ACU_SAPI;

	  		if (R_msg_code == ACU_CONN_CO) {
	  	  
	  		  	/* Reset the link references table */
	  	  	
	  		    for (i=0;i<MX_LINKS;i++) {
	  	        	link_ref_tab[i]  = SPPP_REF_NIL;
	  	   	    }
	  		}
			ap_process_cc_msg ();
			break;

		case MPPP_SAPI_SIG_MGT :
		
		  		/* Signalling management messages */
	  		
		  	R_msg_sapi = ACU_SAPI_MGT;
	  		ap_process_cc_msg ();
	        	break;

		case MPPP_SAPI_DATA_SYNC :
		case MPPP_SAPI_DATA_ASYN :
	  
		  	if (R_msg_code == MPPP_ERROR_IN) {
	  	
		  		p_data	= R_a_data;
	        		link_ref    = Mppp_addr_sppp_ref;
	  	   		Trace_string ("\nMPPP_ERROR_IN(ref=");
	  	    		Trace_int(link_ref);
	  	    		Trace_string (",cause=");
	  	   		Trace_int(Mppp_error_in_cause);
	  	    		Trace_string (",diag=");
	  	    		Trace_int(Mppp_error_in_diag);
	  	    		Trace_string (")");
	            
	  		}
				/* Data transfer messages */
				  			  
			ap_process_ph_msg ();
	                break;

		case MPPP_SAPI_EXT_EVENTS :
	  		p_data	= R_a_data;
	        	link_ref = Mppp_addr_sppp_ref;
	  	
	  		if (R_msg_code == MPPP_EXT_ERROR_IN) {
	  	  
	  		    Trace_string ("\nMPPP_EXT_ERROR_IN(ref=");
	  		    Trace_int(link_ref);
	  		    Trace_string (",cause=");
	  		    Trace_int(Mppp_ext_error_in_cause);
	  		    Trace_string (",diag=");
	  		    Trace_int(Mppp_ext_error_in_diag);
	  		    Trace_string (")");
	  		    break;
	  		}
	  		
	  		if ((R_msg_code == MPPP_EXT_ADD_LINK_IN) || (R_msg_code == MPPP_EXT_ADD_LINK_CO)) {
	  	   
	  		    if (R_msg_code == MPPP_EXT_ADD_LINK_IN) {
	  		        link_speed = Mppp_ext_add_link_in_speed;
	  		    	Trace_string ("\nMPPP_EXT_ADD_LINK_IN(ref=");
	  		    } else {
	  		      	link_speed = Mppp_ext_add_link_co_speed;
	  		        Trace_string ("\nMPPP_EXT_ADD_LINK_CO(ref=");
	  		    }
	  	    
	  		    Trace_int(link_ref);
	  		    Trace_string (",speed=");
	  		    Trace_int(link_speed);
	  		    Trace_string (")");
	  	    
	  		   	/* Store this new member link reference */
	  	   	
	  		    for (i=0; i<MX_LINKS;i++) {
	  	        	if (link_ref_tab[i] == SPPP_REF_NIL) {
	  	        	    link_ref_tab[i] = link_ref;
	  	        	    break;
	  	        	}
	  	    	    }
	  		    break;
	  	        }
		  	
		  	if ((R_msg_code == MPPP_EXT_DROP_LINK_IN) || (R_msg_code == MPPP_EXT_DROP_LINK_CO)) {
	  	   	  	    
	  	    		if (R_msg_code == MPPP_EXT_DROP_LINK_IN) {
	  	    			Trace_string ("\nMPPP_EXT_DROP_LINK_IN(ref=");
	  	    		} else {
	  	    		  	Trace_string ("\nMPPP_EXT_DROP_LINK_CO(ref=");
	  	    		}
	  	    		Trace_int(link_ref);
	  	    		Trace_string (")");
	  	    		
	  	    
	  	   			/* Clear this member link reference */
	  	   	
	  	    		for (i=0; i<MX_LINKS;i++) {
	  	        		if (link_ref_tab[i] == link_ref) {
	  	        		    link_ref_tab[i] = SPPP_REF_NIL;
	  	        		    break;
	  	        		}
	  	    		}
	  	                break;
	  	        }
	  	                
		default :
			break;  		
	}  	
}

#endif /*  MULTILINK_PPP_SUPPORT  } */

/*==========================================================================*/

	/*-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
	/*                           */
	/* Context-related functions */
	/*                           */
	/*-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

uchar ap_access_call (nai, conn_id)
	nai_t nai;
	add_t conn_id;
{
	uchar x_ctx;	/* Call contexts index */

	p_ap_call_ctx = &t_ap_call_ctx[0];
	x_ctx         = 0;

	while (x_ctx < AP_CALL_CTX_NB) {

		if ((Ap_call_nai == nai) && (Ap_call_conn_id == conn_id)) {

				/*
					Found the context :
					- p_ap_call_ctx points to the found context
					- Return OK,
				*/

			return (OK);
		}

		p_ap_call_ctx++;
		x_ctx++;
	}

		/*
			Context not found :
			- Make p_ap_call_ctx point to a dummy context so that we won't
			crash the memory if there is some 'unprotected' call access...
			- Return NOK,
		*/

	p_ap_call_ctx = &ap_call_ctx_dummy;

	return (NOK);

}

uchar ap_access_nai (nai)
	nai_t nai;
{
	uchar x_ctx;	/* Call contexts index */

	p_ap_call_ctx = &t_ap_call_ctx[0];
	x_ctx         = 0;

	while (x_ctx < AP_CALL_CTX_NB) {

		if (Ap_call_nai == nai) {

				/*
					Found the context :
					- p_ap_call_ctx points to the found context
					- Return OK,
				*/

			return (OK);
		}

		p_ap_call_ctx++;
		x_ctx++;
	}

		/*
			Context not found :
			- Make p_ap_call_ctx point to a dummy context so that we won't
			crash the memory if there is some 'unprotected' call access...
			- Return NOK,
		*/

	p_ap_call_ctx = &ap_call_ctx_dummy;

	return (NOK);

}

uchar ap_access_term_id (term_id)
	nai_t term_id;
{
	uchar x_ctx;	/* Call contexts index */

	p_ap_call_ctx = &t_ap_call_ctx[0];
	x_ctx         = 0;

	while (x_ctx < AP_CALL_CTX_NB) {

		if (Ap_call_term_id == term_id) {

				/*
					Found the context :
					- p_ap_call_ctx points to the found context
					- Return OK,
				*/

			return (OK);
		}

		p_ap_call_ctx++;
		x_ctx++;
	}

		/*
			Context not found :
			- Make p_ap_call_ctx point to a dummy context so that we won't
			crash the memory if there is some 'unprotected' call access...
			- Return NOK,
		*/

	p_ap_call_ctx = &ap_call_ctx_dummy;

	return (NOK);

}

/*---------------*/

void ap_call_init (nai, conn_id)
	nai_t nai;
	add_t conn_id;
{

		/* Initialise the call context */

	if (ap_access_call (nai, conn_id) == NOK) {

			/* Wrong call context... */

		return;
	}

		/* Initialise the context */

	Ap_call_state	= STATE_NULL;
        Ap_call_sapi 	= SAPI_NIL;
	Ap_ph_state	= STATE_NULL;
    	Ap_call_chani	= ADD_NIL;
	Ap_call_nb	= 0;
	Ap_call_term_id	= USER_TERM_ID;  
	return;

}

/*---------------*/

void ap_call_clear ()
{
		/* Re-initialise the context */

	Ap_call_state	= STATE_NULL;
        Ap_call_sapi 	= SAPI_NIL;
	Ap_ph_state	= STATE_NULL;
    	Ap_call_chani	= ADD_NIL;
	Ap_call_nb	= 0;
	Ap_call_term_id	= USER_TERM_ID;  

}

/*---------------*/

uchar ap_config ()
{
	nai_t nai;
	add_t conn_id;

		/* Initialise the application contexts */

	p_ap_call_ctx = &t_ap_call_ctx[0];

		/* nai loop */

	for (nai = 0; nai < AP_MX_NAI; nai++) {

			/* conn_id loop */

		for (conn_id = 0; conn_id < AP_MX_CONN_ID; conn_id++) {

				/* Init the call context keys */

			Ap_call_nai	= nai;
		        Ap_call_sapi 	= SAPI_NIL;
			Ap_call_conn_id	= conn_id;
    	    	    	Ap_call_chani	= ADD_NIL;
			
				/* Init the context itself */

			Ap_call_state	= STATE_NULL;
			Ap_call_nb	= 0;
			Ap_call_term_id	= USER_TERM_ID;  

				/* next context */

			p_ap_call_ctx++;

		}

	}

		/*
			- Make p_ap_call_ctx point to a dummy context so that we won't
			crash the memory if there is some 'unprotected' call access...
			- Return.
		*/

	p_ap_call_ctx = &ap_call_ctx_dummy;

#	if AP_PPP_CONVERSION == ON
		ret_code = ap_ppp_asyn_init ();
		return (ret_code);
#	else
		return (OK);
#	endif 


}

void ap_send_vs_init_rq (void)
{
	uchar			 call_direction;

	struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
	struct buffer FAR *p_buffer;	/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
	uchar FAR *	p_data;
	uchar FAR *	p_profile;

		/* Allocate a message */

	p_snd_msg	= Alloc_msg ();
	p_buffer	= Alloc_buffer ();

	S_msg_from	= ENT_APPLI;	
	S_msg_to	= ENT_VS;
	S_msg_code 	= VS_INIT_RQ;
	S_msg_nai 	= Ap_call_term_id;
	S_msg_sapi 	= SAPI_NIL;
	S_msg_conn_id 	= Ap_data_chani;

		/* Link the buffer to the message */

	S_msg_init_link_buffer;

		/* Build the primitive */

	p_data = Buffer_a_first_data;		/* Get data area starting address inside the buffer */
	Memset_far ((char FAR *)p_data, 0, Sizeof_vs_init);
	
	switch (Ap_call_state) {
		default :
		case STATE_OUTGOING_ACTIVE :
			call_direction		= VS_CALL_OUTGOING;
			break;
			
		case STATE_INCOMING_ACTIVE :
			call_direction		= VS_CALL_INCOMING;
			break;
	}  

	
		/* start s7 timer : to do later  */
	
	Vs_init_nai		= Ap_call_nai;
	Vs_init_chan_id		= Ap_data_chani;
	Vs_init_sapi		= SAPI_NIL;
	Vs_init_ces		= 1;
	Vs_init_lli		= 256;
	Vs_init_direction	= call_direction;
	p_profile = (uchar FAR *) Vs_init_a_profile_id;
	*p_profile++ = 'V';
	*p_profile++ = '0';
	*p_profile++ = '\0';
	p_profile = (uchar FAR *) Vs_init_a_servprof_id;
	*p_profile++ = 'V';
	*p_profile++ = '0';
	*p_profile++ = '\0';
	Vs_init_v42b_resp_timer_val = 500 * M_SCD;

		/* other V42 parameters are set to 0 */	
	
		/* Update buffer data size field */

	Buffer_data_size = Sizeof_vs_term_start_rq;

		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
 
}


void ap_send_vs_stop_rq (void)
{

	struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
	struct buffer FAR *p_buffer;	/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
	uchar FAR *	p_data;

		/* Allocate a message */

	p_snd_msg	= Alloc_msg ();
	p_buffer	= Alloc_buffer ();

	S_msg_from	= ENT_APPLI;	
	S_msg_to	= ENT_VS;
	S_msg_code 	= VS_STOP_RQ;
	S_msg_nai 	= Ap_call_term_id;
	S_msg_sapi 	= SAPI_NIL;
	S_msg_conn_id 	= Ap_data_chani;

		/* Link the buffer to the message */

	S_msg_init_link_buffer;

		/* Build the primitive */

	p_data = Buffer_a_first_data;		/* Get data area starting address inside the buffer */
	Memset_far ((char FAR *)p_data, 0, Sizeof_vs_term_stop_rq);
	Vs_term_stop_rq_nai	= Ap_call_nai;
	Vs_term_stop_rq_chan_id	= Ap_data_chani;
	Vs_term_stop_rq_cause	= VS_STOP_CAUSE_ORIGINATED;
	
		/* Update buffer data size field */

	Buffer_data_size = Sizeof_vs_term_stop_rq;

Trace_string ("\nSending_VS_STOP_RQ");

		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
 
}

void ap_send_acu_alert_rq (void)
{

	struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
	struct buffer FAR *p_buffer;	/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
	uchar FAR *	p_data;

		/* Allocate a message */

	p_snd_msg	= Alloc_msg ();
	p_buffer	= Alloc_buffer ();

	S_msg_from	= ENT_APPLI;
		
	switch (Ap_service) {
		case ACU_DATA_SERVICE :
		case ACU_V120_SERVICE :
		default:			/* This line added to ISDN v1.02 to ensure that we respond to CLEAR
						    received from network before a connection has been established. */
			S_msg_to	= ENT_CC;
			S_msg_sapi 	= ACU_SAPI;
			break;

#		if MULTILINK_PPP_SUPPORT == ON
			case USER_PROFILE_MPPP_SYNC :
			case USER_PROFILE_MPPP_ASYNC :
				S_msg_to	= ENT_MPPP;
				S_msg_sapi 	= MPPP_SAPI_SIG;
				break;
#		endif
	}  

	S_msg_code 	= ACU_ALERT_RQ;
	S_msg_nai 	= Ap_call_nai;
	S_msg_conn_id 	= Ap_call_conn_id;

		/* Link the buffer to the message */

	S_msg_init_link_buffer;

		/* Build the primitive */

	p_data = Buffer_a_first_data;		/* Get data area starting address inside the buffer */
	Memset_far ((char FAR *)p_data, 0, Acu_alert_rq_size);
	Buffer_data_size = Acu_alert_rq_size;
	
		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
 
}

void ap_send_acu_clear_rs (void)
{

	struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
	struct buffer FAR *p_buffer;	/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
	uchar FAR *	p_data;

		/* Allocate a message */

	p_snd_msg	= Alloc_msg ();
	p_buffer	= Alloc_buffer ();

	S_msg_from	= ENT_APPLI;
		
	switch (Ap_service) {
		case ACU_DATA_SERVICE :
		case ACU_V120_SERVICE :
		default:			/* This line added to ISDN v1.02 to ensure that we respond to CLEAR
						    received from network before a connection has been established. */
			S_msg_to	= ENT_CC;
			S_msg_sapi 	= ACU_SAPI;
			break;

#		if MULTILINK_PPP_SUPPORT == ON
			case USER_PROFILE_MPPP_SYNC :
			case USER_PROFILE_MPPP_ASYNC :
				S_msg_to	= ENT_MPPP;
				S_msg_sapi 	= MPPP_SAPI_SIG;
				break;
#		endif
	}  

	S_msg_code 	= ACU_CLEAR_RS;
	S_msg_nai 	= Ap_call_nai;
	S_msg_conn_id 	= Ap_call_conn_id;

		/* Link the buffer to the message */

	S_msg_init_link_buffer;

		/* Build the primitive */

	p_data = Buffer_a_first_data;		/* Get data area starting address inside the buffer */
	Memset_far ((char FAR *)p_data, 0, Acu_clear_rs_size);
	Buffer_data_size = Acu_clear_rs_size;
	
		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
 
}

void ap_send_acu_clear_rq (uchar cause)
{

	struct message FAR *p_snd_msg;	/* local pointer to the message, so that */
	struct buffer FAR *p_buffer;	/* local pointer to the buffer, so that */
					/* we don't corrupt the global one */
	uchar FAR *	p_data;

		/* Allocate a message */

	p_snd_msg	= Alloc_msg ();
	p_buffer	= Alloc_buffer ();

	S_msg_from	= ENT_APPLI;	

	switch (Ap_service) {
		case ACU_DATA_SERVICE :
		case ACU_V120_SERVICE :
		default :
			S_msg_to	= ENT_CC;
			S_msg_sapi 	= ACU_SAPI;
			break;

#		if MULTILINK_PPP_SUPPORT == ON
    	    		case USER_PROFILE_MPPP_SYNC :
      	    		case USER_PROFILE_MPPP_ASYNC :
				S_msg_to	= ENT_MPPP;
				R_msg_sapi 	= MPPP_SAPI_SIG;
				break;
#		endif
	}  
	S_msg_code 	= ACU_CLEAR_RQ;
	S_msg_nai 	= Ap_call_nai;
	S_msg_conn_id 	= Ap_call_conn_id;

		/* Link the buffer to the message */

	S_msg_init_link_buffer;

		/* Build the primitive */

	p_data = Buffer_a_first_data;		/* Get data area starting address inside the buffer */
	Memset_far ((char FAR *)p_data, 0, Acu_clear_rq_size);
	Acu_clear_rq_cause = cause;
	Buffer_data_size = Acu_clear_rq_size;
	
		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
 
}

/*==========================================================================*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name    ap_retransmit_to_cc - retransmit message received from user entity
		to the CC entity.

	
Usage	void ap_retransmit_to_cc (code_t code);
	
		- code   : message code to be built by the Appli entity:
			- ACU_CONN_RQ
			- ACU_CONN_RS
			- ACU_CLEAR_RQ
			- ACU_CLEAR_RS
			- ACU_TEST_RQ
*--------------------------------------------------------------------------*/


/*==========================================================================*/

void ap_retransmit_to_cc (code)
	code_t	code;
{
    R_msg_from		= ENT_APPLI;
    R_msg_to 		= Ap_cc_entity; /* call control entity  : ENT_CC or ENT_MPPP */
    R_msg_code 		= code;

    switch (code) {
        
        case ACU_TEST_RQ :	/* management primitive */

        	if (Ap_cc_entity == ENT_CC) {
	        	R_msg_sapi 	= ACU_SAPI_MGT;
    			R_msg_conn_id	= Ap_call_conn_id;
	        } else {
	        	R_msg_sapi 	= MPPP_SAPI_SIG_MGT;
   
	        }  	
		break;

	default :		/* normal ACU primitive */
	
        	if (Ap_cc_entity == ENT_CC) {
			R_msg_sapi 	= ACU_SAPI;
    			R_msg_conn_id	= Ap_call_conn_id;
	        } else {
	        	R_msg_sapi 	= MPPP_SAPI_SIG;
   
	        }  	
		break;
    }  
		/* Send the message */

    Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;

}

/*==========================================================================*/

void ap_retransmit_to_vs (code)
	code_t	code;
{
    R_msg_from		= ENT_APPLI;
    R_msg_to 		= ENT_VS;
    R_msg_code 		= code;
    R_msg_nai 		= Ap_call_term_id;
    R_msg_sapi 		= SAPI_NIL;
    R_msg_conn_id	= Ap_data_chani;

		/* Send the message */

    Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;

}

/*==========================================================================*/

void ap_retransmit_to_sm (code)
	code_t	code;
{
    R_msg_from		= ENT_APPLI;
    R_msg_to 		= ENT_SM;
    R_msg_code 		= code;

		/* Send the message */

    Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;

}
/*==========================================================================*/

void ap_retransmit_to_ph (code)
	code_t	code;
{
    R_msg_from	= ENT_APPLI;
    R_msg_to 	= Ap_ph_entity;
    R_msg_code 	= code;

    if (Ap_ph_entity == ENT_PH_B) {
    	R_msg_sapi 	= Ap_ph_sapi;
    	R_msg_add 	= Ap_data_chani;
    
    } else {
#   	if AP_PPP_CONVERSION == ON
        	R_msg_sapi 	= MPPP_SAPI_DATA_SYNC;
#   	else
        	R_msg_sapi 	= MPPP_SAPI_DATA_ASYNC;
#   	endif
    	R_msg_add 	= 0;
   
    }  

		/* Send the message */

    Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;

}


/*EOF*/
