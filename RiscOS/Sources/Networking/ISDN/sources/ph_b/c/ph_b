
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ph_b.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *         ph_b - implements the PHysical B channel entity in ISDN-BRICKS
 *         for SIEMENS HSCX.
 *
 *         ph_b_config - implements the configuration and the
 *         initialization of the PH entity.
 *
 *         ph_b_build_object - implements the building of the ph_b
 *         SIEMENS entity objects.
 *
 *         ph_b_retransmit - implements the retansmission of a
 *         received message to another entity with another primitive
 *         code.
 *
 *         ph_b_access_nai, chani - implements the access to the PH B
 *         data structures using NAI, CHANI.
 *
 *         ph_b_access_first_/next_nai - implements the access to
 *         the PH B data structures using NAI.
 *
 *         ph_b_start_xmit - implements the test of the transmit queue
 *         and if needed the initialization of a transmission when the
 *         transmitter is not busy.
 *
 *         ph_b_clear_xmt - implements the clearing of a message
 *         in the XMIT waiting queue.
 *
 *         ph_b_discard_xmt - implements the clearing of the XMIT
 *         waiting FIFO.
 *
 *         ph_b_mark_fc_inc - ph_b_mark_fc_dec implements the
 *		   management of the outgoing flow control.
 *
 *         ph_b_init - implements the initialization of a B channel
 *         using a HSCX component.
 *
 *         ph_b_stop - implements the stopping of a B channel
 *         using a HSCX component.
 *
 *		   ph_b_var_init - init of PH_B entity's global variables.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    Siemens HSCX for B-channels Driver               |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/


/*

							S E R V E U R S
							===============

	|                                                           |
	|   ---------------------          ----------------------   |
	|   |                   |          |                    |   |
	|   |                   |--------->|                    |   |
	|   |       MDL         |          |        DL          |   |
	|   |                   |<---------|                    |   |
	|   |                   |          |                    |   |
	|   |                   |          |                    |   |
	|   ---------------------          ----------------------   |
	|                                       |           ^       |
	|                                       |PH_DA_RQ   |       |
	|                                       |           |       |
	|                                       |   PH_DA_IN|       |
	|                                       |           |       |
	|                                       |PH_CLEAR_RQ|       |
	|                                       v           |       |
	|   ----------------------          ----------------------  |
	|   |                    |          | ------------------ |  |
	|   |                    |--------->| |     PH_B       |<--------
	|   |     MPH_B          |          | ------------------ |  |   |
	|   |                    |          |        ^           |  |   |
	|   |                    |          |        |           |  |   |
	|   |                    |          |        v           |  |   |
	|   |                    |          | ------------------ |  |   |
	|   |                    |<---------| |     DRV        | |  |   |
	|   |                    |          | ------------------ |  |   |
	|   ----------------------          |---------------------  |   |
	|                                    |      ^               |   |
	|                               ------      |PH_IT_XMIT_IN  |   |
	|                              |            |PH_IT_RCV_IN   |   |
	|                              |            |PH_IT_START_WD_IN  |           |
	|                            | v|FIFO       |               |   |
	|                            |--|           |               |   |
	=============================|--|===========|================   |
								 |--|           |                   |
								  -- ---        |                   |
										|       |                   v
										v       |
			Interrupt--> ------------------------               IT STACKS
						| ---------------------- |
						| |                    | |                 |   |
						| |      PH_B_IT       | |  Message stack  |---|
						| |                    | |    <------      |---|
						| ----------^----------- |    ------->     |---|
						|           |            |                  ---
						| ----------|----------- |
						| |                    | |
						| |    chip DRIVER     | |  Buffer stack   |   |
						| |                    | |    <------      |---|
						| ---------------------- |    ------>      |---|
						|                        |                 |---|
						 ------------------------                   ---

*/

#define ENTITY ENT_PH_B

#include "ph_b.h"

#if REVISION_STRING == ON
#	include "rev.ph_b_s"
#endif

CONST char  ph_b_copyright[]    = "Copyright (c) 1990 - 1991 by OMNITEL SA - All Rights Reserved";
CONST char  ph_b_licence[]      = LICENSE_NBER;

		/* External global data */

	External_common;

		/* Common variables */

								 Entity_common (ph_b);  /* PH entity common variables */
	struct node     FAR         *p_ph_b_top_node;       /* PH B tree structure */
	struct peitab   FAR *FAR    *p_tab_peitab_a;        /* PH B PEITAB pointer table HSCX A */
	struct peitab   FAR *FAR    *p_tab_peitab_b;        /* PH B PEITAB pointer table HSCX B */

#   if OPTIMIZATION == SPEED
		struct ph_b_na_object FAR *FAR *p_ph_b_na_tab;			/* NA access index table */
#   endif

#   if PH_B_AUDIT == ON
		ushort                   ph_b_s_fifo_counter;   /* TX FIFO counter */
#   endif

/*--------------------------------------------------------------------------*/

#if PH_B_TX_WATCHDOG_TIMER == ON

			/* PH CHANEL timer event ID */

	CONST_ARRAY uchar           PH_B_TI_EV_ID[] = {TI_199};
#endif

/*--------------------------------------------------------------------------*/

						/* PH context pointer */

	struct ph_b_na_object   FAR *p_ph_b_na;
	struct ph_b_chan_object FAR *p_ph_b_chan;

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ph_b - implements the PH_B entity for an SIEMENS HSCX using
					   the SIEMENS Low Level Device Driver.

Usage           uchar ph_b (struct message FAR *p_msg);
					- p_msg : message to process by the PH_B entity.

Return value :  returns = OK
						= NOK

common constants and declarations : ph_b.h

common objects : p_rcv_msg, p_snd_msg, p_buffer pointers.

*---------------------------------------------------------------------------*/

uchar ph_b (p_msg)
	struct message          FAR *p_msg;         /* pointer on received message */
{
	uchar   FAR                 *p_data;        /* data pointer */

#	if PH_B_TX_WATCHDOG_TIMER == ON
		struct message		FAR *p_xmit_msg;    /* pointer on xmit message */
#	endif

	struct peitab           FAR *p_peitab;      /* PEITAB channel pointer */
	it_mask_t                    old_mask;      /* IT old Mask */
	struct ph_b_config      FAR *p_ph_b_config; /* Configuration pointer */

#	if RESET_CONFIG == ON
		struct ph_b_na_object FAR *p_na_prior;  /* NA prior pointer */
#	endif

#	if OPTIMIZATION != SPEED
		uchar                    i;             /* index */
#	endif

	ushort                       frame_size;    /* frame size */

	struct buffer			FAR *p_buff;		/* local buffer pointer */

	nai_t					     nai;			/* received NAI */
	sapi_t						 sapi;			/* received SAPI */
	add_t						 chani;			/* received CHANI */

		/* Init entity pointers */

	p_rcv_msg   = p_msg;
	p_buffer    = R_msg_p_buffer;
	p_snd_msg   = P_NIL;

	nai			= R_msg_nai;
	sapi		= R_msg_sapi;
	chani		= R_msg_chani;

	p_data      = R_a_data;
	event_id    = R_msg_code;

		/* Dispatcher : from entity */

	switch (R_msg_from) {

			/* From MPH B */

		case ENT_MPH_B :

				/* Dispatcher : event code */

			switch (event_id) {

					/* Init requested from MPH B entity */

				case MPH_B_SET_CONFIG_RQ :

						/* Configuration */

					p_ph_b_config           = (struct ph_b_config FAR *)p_data;
					Ph_b_config_ret_code    = ph_b_config (p_ph_b_config);

						/* Retransmit set congig confirm to MPH B */

					ph_b_retransmit (ENT_MPH_B, MPH_B_SET_CONFIG_CO);
					break;

						/* B channel init request */

				case MPH_B_INIT_RQ :

					if (ph_b_access_chani (nai, chani) == OK) {

						if ((Mph_b_activation_mode == B_MODE_DATA_HDLC) ||
							(Mph_b_activation_mode == B_MODE_DATA_V110) ||
							(Mph_b_activation_mode == B_MODE_DATA_TRANSPARENT)) {

							ph_b_init (Ph_b_a_peitab, (struct mph_b_init FAR *)p_data, chani);

								/* Send PH_B_ACT_IN */

							p_buff 	= P_NIL;

							Prepare_data_to_send (p_snd_msg, p_buff, Ph_b_act_size, p_data);

							if (p_data != P_NIL) {

									/* Load the data */

#								if PH_B_TX_DONE == ON

									Ph_b_act_tx_done = ON;
#								else

									Ph_b_act_tx_done = OFF;
#								endif

								Ph_b_act_layer_3_ent_id = Ph_b_layer_3_ent_id;

									/* Send the message */

								ph_b_transmit (Ph_b_ent_up, PH_B_ACT_IN);
							}

						}

							/* INIT confirm to MPH */

						ph_b_retransmit  	(ENT_MPH_B, MPH_B_INIT_CO);
					}

					break;

						/* B channel stop request */

				case MPH_B_STOP_RQ :

					if (ph_b_access_chani   (nai, chani) == OK) {

						if ((Mph_b_activation_mode == B_MODE_DATA_HDLC) ||
							(Mph_b_activation_mode == B_MODE_DATA_V110) ||
							(Mph_b_activation_mode == B_MODE_DATA_TRANSPARENT)) {

							ph_b_transmit       (Ph_b_ent_up, PH_B_DEA_IN);
							ph_b_stop           (Ph_b_a_peitab);
							ph_b_retransmit     (ENT_MPH_B, MPH_B_STOP_CO);

						}
					}

					break;

						/* Reset configuration request */

#				if RESET_CONFIG == ON

					case MPH_B_RESET_CONFIG_RQ :

						p_na_prior = P_NIL;

						for (ph_b_access_first_na (); p_ph_b_na != P_NIL; ph_b_access_next_na ()) {

							if (Ph_b_nai == nai) {

#	                           if OPTIMIZATION == SPEED

										/* Reset index table */

									p_ph_b_na_tab [Ph_b_nai] = P_NIL;
#	                           endif


									/* No more IT path */

								for ( i = 0; i < PH_BRI_MX_CHANI; i++) {
									p_ph_b_chan = Ph_b_a_chan (i);

									p_tab_peitab_a [Ph_b_hscx_id] = P_NIL;
									p_tab_peitab_b [Ph_b_hscx_id] = P_NIL;
								}

									/* Update the NA link */

								if (p_na_prior == P_NIL) {
									p_ph_b_top_node = (((struct node FAR *)p_ph_b_na) - 1) -> p_next;

								} else {

									(((struct node FAR *)p_na_prior) - 1) -> p_next =  (((struct node FAR *)p_ph_b_na) - 1) -> p_next;
								}

									/* Free the timer cells associated to the NA */

#								if PH_B_TX_WATCHDOG_TIMER == ON
									Timer_free (Ti_id (T199));
#								endif

									/* And free the NA memory block */

								Mem_free ((char FAR *)Ph_b_p_mem_blk, PID_VL);
								break;
							}

							p_na_prior = p_ph_b_na;

						}

							/* send back a confirm to MPH */

						Confirm_ret_code = OK;
						ph_b_retransmit (ENT_MPH_B, MPH_RESET_CONFIG_CO);
						break;

#				endif

				default :
					break;

			}
			break;

			/* From PH_B interrupt entity  */

		case ENT_PH_B_IT :

				/* Set context pointer */

			if (ph_b_access_chani (nai, chani) == OK) {

				p_peitab = Ph_b_a_peitab;

					/* Dispatcher : event code */

				switch (event_id) {

						/* XMIT done */

					case PH_B_IT_XMIT_IN :

#                       if PH_B_TX_WATCHDOG_TIMER == ON

								/* Stop the TX watchdog timer */

							if (Ti_state (T199) == ON) {
								Stop_timer (T199);
							}

#                       endif

							/* If commitment required return PH_B_COMMIT_CO */

						It_disable_hscx (old_mask);

						if (Ph_b_wait_commit_flag) {

							if (Ph_b_p_it_xmt_first == P_NIL) {
								Ph_b_wait_commit_flag = FALSE;
								It_enable_hscx  (old_mask);

									/* Empty FIFO --> return commit CO */

								ph_b_transmit		(Ph_b_ent_up, PH_B_COMMIT_CO);

							} else {

								It_enable_hscx  (old_mask);
							}

						} else {

							It_enable_hscx (old_mask);
						}

#						if PH_B_TX_DONE == OFF

							if (R_msg_lib == ON) {
								Free_msg (p_rcv_msg);
							}

							p_rcv_msg   = P_NIL;
							p_buffer    = P_NIL;

#						else

							ph_b_retransmit (Ph_b_ent_up, PH_B_TX_DONE_IN);
#						endif

						break;

						/* Receive done */

					case PH_B_IT_RCV_IN :

						if (Buffer_data_size != 0) {

#							if (MESSAGE_SEND_DATA == ON) && (PH_B_FC == OFF)

									/* Data received hold in a message : transfer */

								if (Buffer_data_size + p_peitab -> pt_rx_offset <= Message_data_lgth) {

										/* Copy data from the buffer to the message */

									R_msg_header_init;
									R_msg_p_buffer		= P_NIL;
									R_msg_data_size		= Buffer_data_size;
									R_msg_data_offset  += p_peitab -> pt_rx_offset;

									Memcpy_far ((char FAR *)R_msg_a_start_data, (char FAR *)Buffer_a_start_data, Buffer_data_size);

										/* Deallocate the buffer */

									Free_buffer (p_buffer);
									p_buffer = P_NIL;
								}

#                   	    endif

								/* Send to the DL_B entity */

							ph_b_retransmit (Ph_b_ent_up, PH_B_DA_IN);

						}
						break;

						/* Persistent deactivation */

					case PH_B_IT_DEA_IN :

							/* Retransmit to the DL_B entity */

						ph_b_retransmit (Ph_b_ent_up, PH_B_DEA_IN);

							/* Discard FIFO */

						ph_b_discard_xmt ();
						break;

#                   if PH_B_TX_WATCHDOG_TIMER == ON

						case PH_B_IT_START_WD_IN :

								/* Start the TX watchdog timer */

							Start_timer (T199);
							Ph_b_p_xmit_msg = *(struct message FAR *FAR *)p_data;
							break;
#                   endif

					default :
						break;

				}

			}
			break;

#       if PH_B_TX_WATCHDOG_TIMER == ON

				/* Timer expiry : clear the current TX and the TX FIFO */

			case ENT_TI :

				if (ph_b_access_chani (nai, chani) == OK) {

					p_peitab = Ph_b_a_peitab;

					if (Valid_time_out (T199)) {
						State_timer (T199) = OFF;

						It_read_first_xmt (p_xmit_msg, old_mask);

						if (p_xmit_msg == Ph_b_p_xmit_msg) {
							hscx_reset_tx_channel (p_peitab);
						}

					}

				}

				break;

#       endif


			/* From upper entity */

		default :


				/* Interface synchronization request (at the entity level) */

			if (event_id == PH_B_INT_SYNC_RQ) {
					ph_b_retransmit		(R_msg_from, PH_B_INT_SYNC_CO);
					break;
			}

				/* Set context pointer */

			if (ph_b_access_chani (nai, chani) == OK) {

				if (Ph_b_ent_up == R_msg_from) {

					p_peitab = Ph_b_a_peitab;

						/* Dispatcher : event code */

					switch (event_id) {

							/* Send frame request */

						case PH_B_DA_RQ :

#						if PH_B_STREAM == ON

								/* If streaming mode --> discard the frame */

							if ( ! Stream) {

#						endif

#	                   		   	if ASSERT == ON

										/* Is the frame size OK */

									if (((frame_size = R_data_size) == 0) || (frame_size > Buffer_data_lgth)) {
										Trap (TRAP_FRAME_SIZE_ERROR, "ph_b");
									}

#	                    	    endif

									/* If mode HDLC not activated ---> ignore */

								if (Ph_b_init_mode == B_MODE_DATA_HDLC) {

										/* Queue the new incoming Data request */

									It_put_xmt (p_rcv_msg, old_mask); p_rcv_msg = P_NIL, p_buffer = P_NIL;

										/* If the transmitter busy ---> return */

									It_disable_hscx (old_mask);

									if (Transmitter_busy) {
										It_enable_hscx (old_mask);
										break;
									}

									It_enable_hscx (old_mask);

										/* Start the transfer */

									ph_b_start_xmit (ENT_PH_B, p_ph_b_chan);
								}

#						if PH_B_STREAM == ON

							}

#						endif

								/* Return to entity dispatcher */

							break;

							/* Clear the XMIT queue and release the message */

						case PH_B_CLEAR_RQ :
							p_msg = *(struct message FAR *FAR *)p_data;
							ph_b_clear_xmt (p_msg);
							break;

							/* Activation requested */

						case PH_B_ACT_RQ :

#							if PH_B_FC == ON

								It_disable ();

									if (R_data_size >= Ph_b_act_size) {


										Ph_b_p_ph_fc_tx = Ph_b_act_p_ph_fc_tx;
										Ph_b_p_ph_fc_rx = Ph_b_act_p_ph_fc_rx;

									} else {

											/* No PH flow control (for frame relay) */

										Ph_b_p_ph_fc_tx = Ph_b_p_ph_fc_rx = P_NIL;
									}

								It_enable ();

#							endif

#							if PH_B_STREAM == ON

									/* Reset old mode */

								ph_b_stream_reset (p_peitab);

									/* Set new mode */

								if (R_data_size == Ph_b_act_size) {

											/* Init the streaming mode */

										ph_b_stream_init (p_peitab, Ph_b_act_x_ph_stream, Ph_b_act_p_ph_stream);

								} else {

									Stream = FALSE;
								}

#							endif

							if ((Ph_b_init_mode == B_MODE_DATA_HDLC) ||
								(Ph_b_init_mode == B_MODE_DATA_TRANSPARENT)) {

									/* Send PH_B_ACT_IN */

								p_data	= P_NIL;
								p_buff 	= P_NIL;

								Prepare_data_to_send (p_snd_msg, p_buff, Ph_b_act_size, p_data);

								if (p_data != P_NIL) {

										/* Load the data */

#									if PH_B_TX_DONE == ON

										Ph_b_act_tx_done 	= ON;

#									else

										Ph_b_act_tx_done 	= OFF;
#									endif

									Ph_b_act_layer_3_ent_id = Ph_b_layer_3_ent_id;

										/* Send the message */

									ph_b_transmit (Ph_b_ent_up, PH_B_ACT_IN);
								}

							} else {

								ph_b_retransmit (Ph_b_ent_up, PH_B_DEA_IN);
							}


#							if PH_B_FC == ON

								It_disable ();
									Ph_b_relay_fc_init_count (Ph_b_p_ph_fc_tx);
								It_enable ();

#							endif

							break;

							/* Deactivation requested */

						case PH_B_DEA_RQ :

							if (Ph_b_init_mode == B_MODE_DATA_HDLC) {

#								if PH_B_STREAM == ON

										/* Reset the stream mode */

									ph_b_stream_reset (p_peitab);

#								endif

								ph_b_retransmit     (Ph_b_ent_up, PH_B_DEA_IN);
								ph_b_stop           (Ph_b_a_peitab);
							}
							break;

#						if PH_B_FC == ON

								/* Flow control management */

							case PH_B_BUSY_RQ :
								Ph_b_in_fc_state = BUSY;
								break;

							case PH_B_CLEAR_BUSY_RQ :
								Ph_b_in_fc_state = FREE;
								break;

#						endif

							/* Commitment request */

						case PH_B_COMMIT_RQ :
							It_disable_hscx (old_mask);

							if (Ph_b_p_it_xmt_first == P_NIL) {
								It_enable_hscx  (old_mask);

									/* Empty FIFO --> return commit CO */

								ph_b_retransmit		(Ph_b_ent_up, PH_B_COMMIT_CO);

							} else {

								Ph_b_wait_commit_flag = TRUE;
								It_enable_hscx (old_mask);
							}
							break;

							/* Unexpected message : ignored */

						default :
							break;

					}

#	               if PH_B_AUDIT == ON
						It_disable_hscx (old_mask);
							It_xmt_check (ph_b_s_fifo_counter, Ph_b_p_it_xmt_first, Ph_b_p_it_xmt_last, TRAP_TX_FIFO_ERROR, "ph_b");
						It_enable_hscx (old_mask);
#	               endif

				}
			}
			break;

	}

		/* Message and buffer stacks management */

	It_stack_mgt ();

		/* Free the remaining messages if necessary */

	if (p_rcv_msg != P_NIL) {

		if (R_msg_lib == ON) {
			Free_msg (p_rcv_msg);

		} else {

			Msg_reset_in_ph_fifo_mark (p_rcv_msg);
		}

	}

	Free_msg (p_snd_msg);

		/* Entity return */

	return (OK);
}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_config - implements the configuration and the
				 initialization of the PH B entity.

Usage            void ph_b_config (p_ph_b_config)
					- p_ph_b_config : data configuration pointer.

common constants and declarations  ph_b.h

common :

*---------------------------------------------------------------------------*/

uchar ph_b_config (p_ph_b_config)
	struct ph_b_config  FAR *p_ph_b_config;
{
	nai_t                       i;                      /* nai index */
	add_t                       j;                      /* chani index */
	struct ph_b_config_na   FAR *p_ph_b_na_config;
	struct ph_b_config_chan FAR *p_ph_b_chan_config;
	struct peitab           FAR *p_peitab;              /* PEITAB channel pointer */
	it_mask_t                    old_mask;              /* IT old mask */

#	if PH_B_STREAM == ON
		uchar				FAR *p_first_block;
		uchar					 k;
#	endif

		/* NA_NB validity */

	if (Ph_b_config_na_nb > PH_B_CONFIG_MX_NA) {
		return (NOK);
	}

		/* Build the object tree structures */

	if (ph_b_build_object (p_ph_b_config) == NOK) {
		return (NOK);
	}

		/* For each NAI */

	for (i = 0; i < Ph_b_config_na_nb; i++) {

		p_ph_b_na_config        = Ph_b_config_a_na (i);

		if (ph_b_access_nai (Ph_b_config_nai) == NOK) {
			return (NOK);
		}

#		if PH_B_STREAM == ON

			p_first_block = (uchar FAR *)p_ph_b_na + Ph_b_size;

#		endif

			/* For each channel of the network access */

		for (j = 0; j < Ph_b_config_chan_nb; j++) {
			p_ph_b_chan      	 		= Ph_b_a_chan (j);
			p_ph_b_chan_config 	 		= Ph_b_config_a_chan (j);
			Ph_b_hscx_id        		= Ph_b_config_hscx_id;
			Ph_b_congestion				= Ph_b_config_congestion;
			Ph_b_layer_3_ent_id		 	= ENT_NIL;
			Ph_b_wait_commit_flag 		= FALSE;

#			if PH_B_FC == ON
				Ph_b_out_fc_low_mark	= Ph_b_config_out_fc_low_mark;
				Ph_b_out_fc_high_mark 	= Ph_b_config_out_fc_high_mark;

				Ph_b_out_fc_state 		= FREE;
				Ph_b_in_fc_state 		= FREE;
#			endif

				/* Init Channel parameters */

			Ph_b_ts_tx          		= Ph_b_config_ts_tx;
			Ph_b_ts_rx          		= Ph_b_config_ts_rx;

				/* Init the HSCX peitab  */

			p_peitab          	  		= Ph_b_a_peitab;

			p_peitab -> it_mask 		= Ph_b_config_it_mask;

			hscx_init_peitab (p_peitab, (IO_PORT)Ph_b_config_base_address, Ph_b_config_delta_address);

#			if PH_B_STREAM == ON

			{

				uchar	FAR *p_block;

				if (Ph_b_config_stream_flag == ON) {
					Stream_rx_p_first_block	= (struct block_header FAR *)p_first_block;
					Stream_rx_block_nb 		= ((Ph_b_config_stream_block_nb 	== 0) ? PH_B_STREAM_BLOCK_NB 		: Ph_b_config_stream_block_nb);
					Stream_rx_block_size	= ((Ph_b_config_stream_block_size  	== 0) ? PH_B_STREAM_BLOCK_SIZE  	: Ph_b_config_stream_block_size);

					if ((Stream_rx_block_size < PH_B_FIFO_SIZE) ||
						((Stream_rx_block_size & 1) != 0)) {
						return (NOK);
					}

						/* Load the block header */

					for (k = 0, p_block = p_first_block; k < Stream_rx_block_nb; k++, p_block += Block_header_size + Stream_rx_block_size) {
						Block_rx_status	   	= OFF;
						Block_p_next_block 	= (struct block_header FAR *)(p_block + Block_header_size + Stream_rx_block_size);
					}

					p_block -= Block_header_size + Stream_rx_block_size;
					Block_p_next_block 	= (struct block_header FAR *)p_first_block;
				}

			}

#			endif

#           if PH_B_TX_WATCHDOG_TIMER == ON

					/* Timer T199 : TX watch dog timer */

				Ti_val (T199)   = (Ph_b_config_ti_199 == 0) ? PH_B_T199_I : Ph_b_config_ti_199;
				Ti_state (T199) = OFF;

				if ((Ti_id (T199) = Timer_alloc (ENT_PH_B, Ph_b_nai, PH_SAPI_B, X_to_chani (j))) == P_NIL) {
					return (NOK);
				}

#           endif

				/* Load Rx offset */

			p_peitab -> pt_rx_offset = Ph_b_config_rx_offset;

				/* Init TX FIFO pointers */

			It_disable_hscx (old_mask);
				Ph_b_p_it_xmt_first =
				Ph_b_p_it_xmt_last  = P_NIL;

					/* Flow control management */

				Ph_b_mark_fc_reset ();

			It_enable_hscx (old_mask);

				/* IT PEITAB pointers */

			if (X_to_chani (j) == 1) {
				p_tab_peitab_a [Ph_b_hscx_id] = p_peitab;

			} else {

				p_tab_peitab_b [Ph_b_hscx_id] = p_peitab;
			}

				/* Reset HSCX */

			hscx_reset (p_peitab);

#			if PH_B_STREAM == ON

				p_first_block += (Stream_rx_block_nb) *
								 ((Block_header_size + Stream_rx_block_size));

#			endif

		}

			/* Load channel A --> B and B --> A pointers */

		p_tab_peitab_a [Ph_b_config_hscx_id] -> a_peitab = p_tab_peitab_b [Ph_b_config_hscx_id];
		p_tab_peitab_b [Ph_b_config_hscx_id] -> a_peitab = p_tab_peitab_a [Ph_b_config_hscx_id];
	}


		/* Set IT management */

	It_stack_mgt ();

	return (OK);
}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ph_b_build_object - implements the building of the ph_b
									SIEMENS entity objects.

Usage           ph_b_build_object (struct ph_b_config FAR *p_ph_b_config);
					- p_ph_b_config : pointer on the data configuration.

Description     ph_b_build_object implements the building of the physical B
				objects (na, cjhan) on an aray structure allocated inside
				the Variable Length partition memory :

						   | (p_ph_b_top_node
						   v
					na --> na --> na ..... --> na
						   [chan chan]

				Each occurrence of object is initialized to NIL value.

Return value    uchar return code = OK  done
								  = NOK failed

Common constants and declarations : ph_b.h, ph_b_int.h

Common objects :

*---------------------------------------------------------------------------*/

uchar ph_b_build_object (p_ph_b_config)
	struct ph_b_config  FAR *p_ph_b_config;         /* pointer on the configuration data */
{
	short                       i, j;               /* index */
	struct ph_b_config_na   FAR *p_ph_b_na_config;  /* pointer on the current na object of
													   the configuration data */
	uchar                   FAR *p_current;         /* memory alloc current pointer */
	struct node             FAR *p_node_na;         /* node pointer */
	struct node             FAR *p_top_node = P_NIL;/* current top node pointer */
	uchar                   FAR *p_blk;             /* memory block pointer */
	ushort					stream_size;			/* stream block size */

		/* Object occurrence building */

#   if OPTIMIZATION == SPEED

			/* Build a  NA access table if not done */

		if (p_ph_b_na_tab == P_NIL) {

			if ((p_ph_b_na_tab = (struct ph_b_na_object FAR *FAR *)Mem_alloc (sizeof (struct ph_b_na_object FAR *) * Na_nb, PID_VL)) == P_NIL) {
				return (NOK);
			}

		}

#   endif

		/* Build IT access tables to PEITAB context */

	if ((p_tab_peitab_a == P_NIL) && (Ph_b_config_hscx_nb != 0)) {

		if ((p_tab_peitab_a = (struct peitab FAR *FAR *)Mem_alloc (sizeof (struct peitab FAR *) * Ph_b_config_hscx_nb, PID_VL)) == P_NIL) {
			return (NOK);
		}

		if ((p_tab_peitab_b = (struct peitab FAR *FAR *)Mem_alloc (sizeof (struct peitab FAR *) * Ph_b_config_hscx_nb, PID_VL)) == P_NIL) {
			return (NOK);
		}

	}

						/* NA LOOP */

	for (i = 0; i < Ph_b_config_na_nb; i++) {

		p_ph_b_na_config = Ph_b_config_a_na (i);

			/* Check the NAI validity. If present --> error */

		if ((Ph_b_config_nai >= Na_nb) || (ph_b_access_nai (Ph_b_config_nai) == OK)) {
			return (NOK);
		}

			/* Memory allocation */


#		if PH_B_STREAM == ON

				/* For each channel used by the network access */

			stream_size = 0;

			for (j = 0; j < PH_BRI_MX_CHANI; j++) {

				if (Ph_b_config_stream_flag == ON) {

					stream_size += (((Ph_b_config_stream_block_nb	== 0) 	? 	PH_B_STREAM_BLOCK_NB 	: Ph_b_config_stream_block_nb)) *
								   (((Ph_b_config_stream_block_size	== 0) 	?	PH_B_STREAM_BLOCK_SIZE 	: Ph_b_config_stream_block_size) + Block_header_size);

				}

			}

#		else

			stream_size = 0;

#		endif

		if ((p_blk = p_current = Mem_alloc (Rnd_sizeof (struct node) + Ph_b_size + stream_size, PID_VL)) == A_NIL) {
			return (NOK);
		}

		if (p_top_node == P_NIL) {
			p_top_node = (struct node FAR *)p_current;
		}

			/* Init the node structure pointers */

		if (i != 0) {
			p_node_na -> p_next = (struct node FAR *) p_current;
		}

		p_node_na               = (struct node FAR *) p_current;
		p_node_na -> p_next     = P_NIL;
		p_node_na -> p_dp       = P_NIL;

		p_ph_b_na               = (struct ph_b_na_object FAR *) (p_node_na +1);

			/* Init the access key */

		Ph_b_nai                = Ph_b_config_nai;          /* network access ID */

			/* Upper layer default entity ID */

		Ph_b_ent_up_default = (Ph_b_config_ent_up == 0) ? ENT_DL_B : Ph_b_config_ent_up;

		if (Entity_in_system (Ph_b_ent_up_default) != ON) {
			return (NOK);
		}

			/* Init the memory block pointer */

		Ph_b_p_mem_blk          = p_blk;

			/* For each channel set the access key : chani */

		for (j = 0; j < PH_BRI_MX_CHANI; j++) {
			p_ph_b_chan         = Ph_b_a_chan (j);
			Ph_b_chani          = X_to_chani (j);
			Ph_b_chan_nai       = Ph_b_nai;
			Ph_b_ent_up			= Ph_b_ent_up_default;
			Ph_b_init_mode 		= B_MODE_NIL;
		}

#       if OPTIMIZATION == SPEED

				/* Load the index table with the NA address */

			p_ph_b_na_tab [Ph_b_nai]  = p_ph_b_na;

#       endif

	} /* end of NA loop */

		/* Set the NA links */

	if (p_ph_b_top_node == P_NIL) {
		p_ph_b_top_node = p_top_node;

	} else {

			/* Link the new NA thread to the existing one */

		for (p_node_na  = p_ph_b_top_node; Next(p_node_na) != P_NIL; p_node_na = Next(p_node_na));

		Next(p_node_na) = p_top_node;
	}

	return (OK);
}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_access_nai, chani - implements the access to the PH B
				 data structures using NAI, SAPI, CHANI.

Usage            uchar ph_b_access_nai (nai)
				 uchar ph_b_access_chani (nai, chani)
					- nai   : Network access ID.
					- chani : channel ID.

Return value    return code = OK  found,
							= NOK not found.

common constants and declarations  ph_b.h

common : p_ph_b_na_tab, p_ph_b_top_node, p_ph_b_na, p_ph_b_chan.

*----------------------------------------------------------------------------*/

uchar   ph_b_access_nai (nai)
	nai_t   nai;    /* Network access ID */
{

#	if OPTIMIZATION != SPEED
		struct node     FAR *p_node;
#	endif

		/* Check Nai validity */

	if (nai >= Na_nb) {
		return (NOK);
	}

#   if OPTIMIZATION == SPEED

		if ((p_ph_b_na = p_ph_b_na_tab[nai]) == P_NIL) {
			return (NOK);

		} else {

			return (OK);
		}

#   else

			/*
				Init the starting address of the node structure
				and the tree scanning.
			*/

		for (p_node = p_ph_b_top_node; p_node != P_NIL; p_node = Next_node) {
			p_ph_b_na = (struct ph_b_na_object FAR *) (p_node + 1);

			if (Ph_b_nai == nai) {
				return (OK);
			}

		}

			/* Not found */

		p_ph_b_na   = P_NIL;
		return (NOK);

#   endif

}

/*--------------------------------------------------------------------------*/

void ph_b_access_first_na ()
{
	struct node     FAR *p_node;    /* temporary pointer on a node */

	if ((p_node = p_ph_b_top_node) != P_NIL) {
		p_ph_b_na = (struct ph_b_na_object FAR *) (p_node + 1);

	} else {

		p_ph_b_na = P_NIL;
	}

}

/*--------------------------------------------------------------------------*/

void ph_b_access_next_na ()
{
	struct node     FAR *p_node;    /* temporary pointer on a node */

	if (p_ph_b_na != P_NIL) {
		p_node = (struct node FAR *)p_ph_b_na - 1;

		if ((p_node = Next_node) == P_NIL) {
			p_ph_b_na = P_NIL;

		} else {

			p_ph_b_na = (struct ph_b_na_object FAR *) (p_node + 1);
		}

	}

}

/*--------------------------------------------------------------------------*/

uchar   ph_b_access_chani (nai, chani)
	nai_t       nai;        /* Network access ID */
	add_t       chani;      /* Channel ID */
{

	add_t   i;      /* index */

	if (ph_b_access_nai (nai) == NOK) {
		return (NOK);
	}

	for ( i = 0; i < PH_BRI_MX_CHANI; i++) {
		p_ph_b_chan = Ph_b_a_chan (i);

		if (Ph_b_chani == chani) {
			return (OK);
		}

	}

	p_ph_b_chan = P_NIL;
	p_ph_b_na   = P_NIL;

	return (NOK);
}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_start_xmit - implements the test of the transmit queue
				 and if needed the initialization of a transmission when the
				 transmitter is not busy.

				 This function is also called by the interruption routine so it
				 shall not used global variables except those protected by the
				 transmitter busy flag.

Usage            uchar ph_b_start_xmit (entity_id)
					- entity_id         : calling entity ID,
					- ph_b_chan_object  : channel context pointer.

Return value :  returns = STOP      : no more transmission to process.
						= CONTINUE  : transmission in progress.

common constants and declarations  ph_b.h

common : L2 --> LLD mailbox (protected by the transmitter busy flag).

*---------------------------------------------------------------------------*/

uchar ph_b_start_xmit (entity_id, p_ph_b_chan)
	ent_id_t                        entity_id;
	struct  ph_b_chan_object    FAR *p_ph_b_chan;
{
	struct message FAR  *p_msg;         /* message to process */
	struct buffer  FAR  *p_buffer;      /* buffer to process */
	struct peitab  FAR  *p_peitab;      /* PEITAB channel pointer */
	it_mask_t            old_mask;      /* IT old mask */

	p_peitab = Ph_b_a_peitab;

		/* Is the transmit queue empty ? */

	It_read_first_xmt (p_msg, old_mask);

	if (p_msg  != P_NIL) {

			/* Start the TX watchdog timer */

		if (entity_id == ENT_PH_B) {

				/* Report TX start */

			Ph_b_tx_report_start_tx (Ph_b_chani);

#   		    if PH_B_TX_WATCHDOG_TIMER == ON

					Start_timer (T199);
					Ph_b_p_xmit_msg = p_msg;
#				endif

		}

#		if (PH_B_TX_DONE == OFF)

			else {

#   		    if PH_B_TX_WATCHDOG_TIMER == ON
					ph_b_start_tx_watchdog_timer (p_msg, p_ph_b_chan);

# 		      endif
			}

#		endif

			/* Send the frame */

		if (hscx_send_frame (p_peitab, L_data_size, L_a_data) == NOK) {
			return (CONTINUE);
		}

	} else {


			/* Report TX done */

		Ph_b_tx_report_end_tx (Ph_b_chani);

		return (STOP);
	}

	return (CONTINUE);
}


/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_retransmit - implements the retransmission of a
				 received message to another entity with another primitive
				 code.

Usage            uchar ph_b_retransmit (entity_t to, code_t code)
					- to    : destination entity,
					- code  : primitive code.

Return value    return code = OK
							= NOK

common constants and declarations  ph_b.h

common : message/buffer pointers.

*---------------------------------------------------------------------------*/

void ph_b_retransmit (to, code)
	ent_id_t    to;                 /* destination entity */
	code_t      code;               /* primitive code */
{

		/* Address */

	R_msg_from  = ENT_PH_B;         /* origination entity ID */
	R_msg_to    = to;               /* destination entity ID */
	R_msg_sapi  = PH_SAPI_B;        /* SAPI B */
	R_msg_chani = Ph_b_chani;       /* B channel number */

		/* Event ID */

	R_msg_code  = code;             /* primitive code */

		/* Send the message */

	Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;
}

/*--------------------------------------------------------------------------*/

void ph_b_transmit (to, code)
	ent_id_t    to;                 /* destination entity */
	code_t      code;               /* primitive code */
{

	if (p_snd_msg == P_NIL) {
		S_msg_alloc;
	}

		/* Address */

	S_msg_from  = ENT_PH_B;         /* origination entity ID */
	S_msg_to    = to;               /* destination entity ID */
	S_msg_nai   = Ph_b_nai;         /* NAI */
	S_msg_sapi  = PH_SAPI_B;        /* SAPI B */
	S_msg_chani = Ph_b_chani;       /* B channel number */

		/* Event ID */

	S_msg_code  = code;             /* primitive code */

		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
}

/*--------------------------------------------------------------------------*/

#if PH_B_TX_DONE == ON

void ph_b_transmit_ph_tx_done (p_msg)
	struct message 	FAR *p_msg;		/* message pointer */

{
	L_msg_from 	= ENT_PH_B;			/* origination entity ID */
	L_msg_to	= Ph_b_ent_up;		/* destination entity ID */
	L_msg_code	= PH_B_TX_DONE_IN;	/* primitive code */

		/* Send the message */

	Send_message (p_msg);
}

#endif

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_clear_xmt - implements the clearing of a message
				 in the XMIT waiting FIFO.

Usage            uchar ph_b_clear_xmt (struct message FAR *p_msg_clear)
					- p_msg_clear : address of the message to search.

Return value    return code = OK  found,
							= NOK not found.

common constants and declarations  ph_b.h

common : message/buffer pointers.

*---------------------------------------------------------------------------*/

void ph_b_clear_xmt (p_msg_clear)
	struct message FAR *p_msg_clear;        /* message to clear */
{
	struct message FAR *p_msg;              /* current message pointer */
	struct message FAR *p_msg_prior;        /* current prior message pointer */
	struct peitab  FAR *p_peitab;           /* PEITAB channel pointer */
	it_mask_t           old_mask;           /* old mask */
	uchar				found = OFF;		/* found flag */

	p_peitab = Ph_b_a_peitab;

	It_disable_hscx (old_mask);

	if ((p_msg = Ph_b_p_it_xmt_first) != P_NIL) {

			/* First of the XMIT queue ? ---> ABORT */

		if (p_msg == p_msg_clear) {
			L_msg_lib   = ON;

			hscx_reset_tx_channel (p_peitab);
			It_enable_hscx (old_mask);
			return;
		}

			/* Transmit PH_B_COMMIT_CO */

		if (Ph_b_wait_commit_flag) {
			Ph_b_wait_commit_flag = FALSE;

			It_enable_hscx (old_mask);
				ph_b_transmit (Ph_b_ent_up, PH_B_COMMIT_CO);
			It_disable_hscx (old_mask);

		}

			/* Next - if found update the XMIT queue */


		for (p_msg_prior = p_msg, p_msg = L_msg_p_services;
			 p_msg != P_NIL;
			 p_msg_prior = p_msg, p_msg = L_msg_p_services) {

			if (p_msg == p_msg_clear) {

					/* Found : remove from the XMIT queue */

				found = ON;

					/* Flow control management */

				Ph_b_mark_fc_dec (p_ph_b_chan);

				if ((X_msg_p_services (p_msg_prior) = L_msg_p_services) == P_NIL) {
					Ph_b_p_it_xmt_last  = p_msg_prior;
				}

			}

		}


	}


	if (found == OFF) {

			/* Message Still used (for PH_XMIT_IN report) ? */

		if (Msg_in_ph_fifo (p_msg_clear)) {

				/* Yes - Postpone the releasing of the message */

			p_msg 		= p_msg_clear;
			L_msg_lib 	= ON;

			It_enable_hscx (old_mask);



		} else {

			It_enable_hscx (old_mask);

					/* Release the message */

#			if PH_B_TX_DONE == ON
				ph_b_retransmit (Ph_b_ent_up, PH_B_CLEAR_CO);

#			else

				Free_msg (p_msg_clear);
#			endif

		}

	} else {

		It_enable_hscx (old_mask);

		Free_msg (p_msg_clear);
	}

}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_discard_xmt - implements the clearing of the XMIT
				 waiting FIFO.

Usage            void ph_b_discard_xmt ()

common constants and declarations  ph_b.h

common : message/buffer pointers.

*---------------------------------------------------------------------------*/

void ph_b_discard_xmt ()
{
	struct message FAR *p_msg;              /* current message pointer */
	struct message FAR *p_next_msg;         /* current next message pointer */
	struct peitab  FAR *p_peitab;           /* PEITAB channel pointer */
	it_mask_t           old_mask;           /* old mask */

	p_peitab = Ph_b_a_peitab;

	It_disable_hscx (old_mask);

	if ((p_msg = Ph_b_p_it_xmt_first) != P_NIL) {

			/* Keep the first element in the FIFO */

		Ph_b_p_it_xmt_last  = p_msg;
		p_next_msg          = L_msg_p_services;
		L_msg_p_services    = P_NIL;
		It_enable_hscx      (old_mask);

			/* Release the next messages of the FIFO */

		while ((p_msg = p_next_msg) != P_NIL) {
			p_next_msg = L_msg_p_services;

#			if PH_B_TX_DONE == ON

					 /* Send PH_TX_DONE_IN to DL B */

				 ph_b_transmit_ph_tx_done (p_msg); p_msg = P_NIL; p_buffer = P_NIL;

#			else

					/* Message and buffer shall be released ? */

				if (L_msg_lib == ON) {

						/* Release the message */

					Free_msg (p_msg);

				} else {

					Msg_reset_in_ph_fifo_mark (p_msg);
				}

#			endif

		}

		if (Ph_b_init_mode != B_MODE_NIL) {

				/* ABORT the first message of the FIFO */

			hscx_reset_tx_channel (p_peitab);

		} else {

			p_msg = Ph_b_p_it_xmt_first;

				/* Free the first message or reset the in fifo mark */

#			if PH_B_TX_DONE == ON

					 /* Send PH_TX_DONE_IN to DL B */

				 ph_b_transmit_ph_tx_done (p_msg); p_msg = P_NIL; p_buffer = P_NIL;

#			else

					/* Message and buffer shall be released ? */

				if (L_msg_lib == ON) {

						/* Release the message */

					Free_msg (p_msg);

				} else {

					Msg_reset_in_ph_fifo_mark (p_msg);
				}

#			endif

				/* FIFO clear */

			Ph_b_p_it_xmt_first =
			Ph_b_p_it_xmt_last  = P_NIL;

				/* Flow control management */

			Ph_b_mark_fc_reset ();

				/* Transmit PH_B_COMMIT_CO */

			if (Ph_b_wait_commit_flag) {
				Ph_b_wait_commit_flag = FALSE;
				ph_b_transmit (Ph_b_ent_up, PH_B_COMMIT_CO);
			}

		}

	} else {

		It_enable_hscx (old_mask);
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_mark_fc_inc - ph_b_mark_fc_dec implements the
				 management of the outgoing flow control.

Usage            void ph_b_mark_fc_inc 	(p_ph_b_chan_ctx)
				 void ph_b_mark_fc_dec	(p_ph_b_chan_ctx)

common constants and declarations  ph_b.h

common :	ph_b_na context

*--------------------------------------------------------------------------*/

#if PH_B_FC == ON

void ph_b_mark_fc_inc (p_ph_b_chan_ctx)
	struct ph_b_chan_object FAR *p_ph_b_chan_ctx;
{
	struct message 			FAR *p_msg;
	struct ph_b_chan_object	FAR *p_ph_b_chan = p_ph_b_chan_ctx;

	if ((Ph_b_out_fc_high_mark != 0)					&&
		(++Ph_b_out_fc_mark == Ph_b_out_fc_high_mark) 	&&
		(Ph_b_out_fc_state != BUSY)) {

			/* Set busy state */

		Ph_b_out_fc_state	= BUSY;

			/* Transmit PH_B_BUSY_IN to upper layer */

		p_msg 			= p_snd_msg;	/* Save current send pointer */
		p_snd_msg		= P_NIL;		/* send pointer to NIL */

		ph_b_transmit (Ph_b_ent_up, PH_B_BUSY_IN);
		p_snd_msg 		= p_msg;
	}

}

/*--------------------------------------------------------------------------*/

void ph_b_mark_fc_dec (p_ph_b_chan_ctx)
	struct ph_b_chan_object   	FAR *p_ph_b_chan_ctx;
{
	struct message				FAR *p_msg;
	struct ph_b_chan_objec		FAR *p_ph_b_chan = p_ph_b_chan_ctx;

		/*
			Update the Flow control current mark
			and compare to the high mark.
		*/


	if ((Ph_b_out_fc_high_mark != 0)					&&
		(--Ph_b_out_fc_mark == Ph_b_out_fc_low_mark) 	&&
		(Ph_b_out_fc_state == BUSY)) {

			/* Reset FC mark state */

		Ph_b_out_fc_state	= FREE;

			/* Send a PH_B_CLEAR_BUSY_IN to the upper layer */

		p_msg 			= p_snd_msg;	/* Save current send pointer */
		p_snd_msg		= P_NIL;		/* send pointer to NIL */

		ph_b_transmit (Ph_b_ent_up, PH_B_CLEAR_BUSY_IN);

		p_snd_msg 		= p_msg;
	}                                 	/* restore send pointer */

}

#endif

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_init - implements the initialization of a B channel
				 using a HSCX component.

Usage            void ph_b_init (struct p_peitab FAR *p_peitab,
								 struct mph_b_init FAR *p_data,
								 chani)
					- p_peitab : PEITAB pointer,
					- p_data   : address of the data parameters.
					- chani	   : channel ID

common constants and declarations  ph_b.h

common :

*---------------------------------------------------------------------------*/

void ph_b_init (p_peitab, p_data, chani)
	struct peitab           FAR *p_peitab;      /* peitab pointer */
	struct mph_b_init       FAR *p_data;        /* init parameters structure */
	uchar						 chani;			/* Channel ID */
{
	uchar						 ts;			/* Time slot size */

	p_peitab -> chani = chani;

		/* calculate timeslot size */

	switch (Mph_b_init_rate) {

		case RATE_64KBS :
			ts = 8;
			break;

		case RATE_56KBS :
			ts = 7;
			break;

		case RATE_48KBS :
			ts = 6;
			break;

		case RATE_32KBS :
			ts = 4;
			break;

		case RATE_16KBS :
			ts = 2;
			break;

		case RATE_8KBS :
			ts = 1;
			break;

		case RATE_128KBS :
			ts = 16;
			break;

		case RATE_112KBS :
			ts = 14;
			break;

		case RATE_96KBS :
			ts = 12;
			break;

		case RATE_72KBS :
			ts = 9;
			break;

		default :
			ts = 8;		/* = 64 KBS */
			break;
	}

		/* Set B channel mode and time slot assignment */

	switch (Mph_b_init_mode) {

			/* HDLC mode */

		case B_MODE_DATA_HDLC :

			hscx_init (p_peitab, PT_MD_EXT_TRANSP);

				/* Assign time slots to the HSCX channel */

			hscx_assign_ts (p_peitab, PH_B_RX, Ph_b_ts_rx, ts, TRUE);   	/* assign RX channel */
			hscx_assign_ts (p_peitab, PH_B_TX, Ph_b_ts_tx, ts, TRUE);   	/* assign TX channel */
			break;

			/* Full transparent mode */

		case B_MODE_DATA_TRANSPARENT :

			hscx_init (p_peitab, PT_MD_FULL_TRANSP);

				/* Assign time slots to the HSCX channels */

			hscx_assign_ts (p_peitab, PH_B_RX, Ph_b_ts_rx, ts, TRUE);   	/* assign RX channel */
			hscx_assign_ts (p_peitab, PH_B_TX, Ph_b_ts_tx, ts, TRUE);   	/* assign TX channel */
			break;

		default :
			break;

	}

		/* LAYER 2 */

		/* default value for layer 2 entity ID */

	Ph_b_ent_up	= Ph_b_ent_up_default;

	if ((Mph_b_init_layer_2_ent_id != ENT_NIL) &&
		(Entity_in_system (Mph_b_init_layer_2_ent_id) != OFF)
	   ) {
		Ph_b_ent_up = Mph_b_init_layer_2_ent_id;
	}

		/* LAYER 3 */

	Ph_b_layer_3_ent_id = Mph_b_init_layer_3_ent_id;

			/* All is allowed */

	Wr_hscx (p_peitab -> pt_r_mask, (uchar)0);

	Ph_b_init_mode = Mph_b_init_mode;
}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_b_stop - implements the stopping of a B channel
				 using a HSCX component.

Usage            void ph_b_stop (struc peitab FAR *p_peitab)
					- p_peitab : PEITAB pointer,

common constants and declarations  ph_b.h

common :

*---------------------------------------------------------------------------*/

void ph_b_stop (p_peitab)
	struct peitab	FAR *p_peitab;      /* peitab pointer */
{

	if (Ph_b_init_mode != B_MODE_NIL) {

		switch (Ph_b_init_mode) {

				/* Data HDLC */

			case B_MODE_DATA_HDLC :
				hscx_stop		(p_peitab);

						/* Discard FIFO */

				Ph_b_init_mode = B_MODE_NIL;
				ph_b_discard_xmt ();
				break;

					/* Data transparent */

			case B_MODE_DATA_TRANSPARENT :
				hscx_stop      (p_peitab);
				Ph_b_init_mode = B_MODE_NIL;
				break;

		}

#		if PH_B_FC == ON

				/* No more PH flow control (for frame relay) */

			Ph_b_p_ph_fc_tx = Ph_b_p_ph_fc_rx = P_NIL;

#		endif

#		if PH_B_STREAM == ON

				/* Reset old mode */

			ph_b_stream_reset (p_peitab);
			Stream = FALSE;

#		endif

			/* It HSCX chanel no more allowed */

		Wr_hscx (p_peitab -> pt_r_mask, (uchar)~(ISTA_ICA | ISTA_EXA));
	}

}

/*--------------------------------------------------------------------------*/

#if PH_B_STREAM == ON

	extern	void (* CONST p_hscx_stream_out) 		();
	extern	void (* CONST p_ph_b_stream_reset) 		();

void ph_b_stream_init (p_peitab, x_ph_stream, p_ph_b_stream)
	struct peitab 		FAR *p_peitab;  	/* context pointer */
	uchar 				 	 x_ph_stream;	/* stream index */
	struct ph_b_stream	FAR *p_ph_b_stream;	/* stream cell pointer */
{

	if (Stream_rx_block_nb != 0) {

		It_disable ();

		if ((Stream_p_ph_stream = p_ph_b_stream) != P_NIL) {

			It_enable ();

			switch ((Stream_mode = Ph_b_stream_mode)) {

				case STREAM_MODE_V14			:
				case STREAM_MODE_V110_ASYNC		:
				case STREAM_MODE_V110_SYNC		:
				case STREAM_MODE_TRANSPARENT 	:

					Stream = TRUE;

						/* Init RX context */

					Stream_rx_p_current_block 		= Stream_rx_p_first_block;
					Stream_rx_p_current_data		= (uchar FAR *)Stream_rx_p_current_block + Block_header_size;
					Stream_rx_data_size				= 0;
					Stream_rx_block_retransmitted	= OFF;

						/* Init TX context */

					Stream_tx_fifo_x_first		= 0;
					Stream_tx_fifo_size			= 0;
					Stream_tx_fifo_started	 	= OFF;
					Stream_tx_block_size		= 0;

						/* Start FULL TRANSPARENT mode */

					hscx_init (p_peitab, PT_MD_FULL_TRANSP);

						/* Assign time slots to the HSCX channels */

					hscx_assign_ts (p_peitab, PH_B_RX, Ph_b_ts_rx, 8, TRUE);   	/* assign RX channel */
					hscx_assign_ts (p_peitab, PH_B_TX, Ph_b_ts_tx, 8, TRUE);   	/* assign TX channel */

					It_disable ();

						if ((Stream_x_ph_stream	= x_ph_stream) == 0) {

							switch (Stream_mode) {

								case STREAM_MODE_V14:
								case STREAM_MODE_V110_ASYNC:
								case STREAM_MODE_V110_SYNC:

										/* Stream out in the same SCC */

									Ph_b_stream_p_ctx_1 	= (uchar FAR *)p_peitab;
									Ph_b_stream_p_fct_1 	= (void FAR * CONST)p_hscx_stream_out;
									Ph_b_stream_p_reset_1 	= (void FAR * CONST)p_ph_b_stream_reset;
									break;

								default :

										/* Stream out in another SCC */

									Ph_b_stream_p_ctx_0 	= (uchar FAR *)p_peitab;
									Ph_b_stream_p_fct_0 	= (void FAR * CONST)p_hscx_stream_out;
									Ph_b_stream_p_reset_0 	= (void FAR * CONST)p_ph_b_stream_reset;

									break;

							}

						} else {

							switch (Stream_mode) {

								case STREAM_MODE_V14	:
								case STREAM_MODE_V110_ASYNC:
								case STREAM_MODE_V110_SYNC:

										/* Stream out in the same SCC */

									Ph_b_stream_p_ctx_0 	= (uchar FAR *)p_peitab;
									Ph_b_stream_p_fct_0 	= (void FAR * CONST)p_hscx_stream_out;
									Ph_b_stream_p_reset_0 	= (void FAR * CONST)p_ph_b_stream_reset;
									break;

								default :

										/* Stream out in another SCC */

									Ph_b_stream_p_ctx_1 	= (uchar FAR *)p_peitab;
									Ph_b_stream_p_fct_1 	= (void FAR * CONST)p_hscx_stream_out;
									Ph_b_stream_p_reset_1 	= (void FAR * CONST)p_ph_b_stream_reset;
									break;
							}

						}

					It_enable ();
					break;

				default :
					Stream = FALSE;
					break;
			}

		} else {

			It_enable ();
			Stream = FALSE;
		}

	} else {

		Stream = FALSE;
	}

}


/*-------------------------------------------------------------------------*/

void ph_b_stream_reset (p_peitab)
	struct peitab 		FAR *p_peitab;  	/* context pointer */
{
	struct ph_b_stream	FAR *p_ph_b_stream;	/* stream cell pointer */

	if (Stream) {

			/*
				Reset the context pointer in
				the stream cell in order
				to stop the transmission
				to this channel.

				Reset also the linked channel.

			*/

		It_disable ();

			if ((p_ph_b_stream = Stream_p_ph_stream) != P_NIL) {

				if (Stream_x_ph_stream == 0) {

					switch (Stream_mode) {

						case STREAM_MODE_V14	:
						case STREAM_MODE_V110_ASYNC:
						case STREAM_MODE_V110_SYNC:

								/* Reset the current channel */

							Ph_b_stream_p_ctx_1 	= P_NIL;
							Ph_b_stream_p_fct_1 	= FCT_NIL;
							Ph_b_stream_p_reset_1 	= FCT_NIL;

								/* Reset the linked channel */

							if ((Ph_b_stream_p_ctx_0 	!= P_NIL) &&
								(Ph_b_stream_p_reset_0 	!= FCT_NIL)) {
								Ph_b_stream_p_reset_0 (Ph_b_stream_p_ctx_0);
							}
							break;

						default :

								/* Reset the current channel */

							Ph_b_stream_p_ctx_0 	= P_NIL;
							Ph_b_stream_p_fct_0 	= FCT_NIL;
							Ph_b_stream_p_reset_0 	= FCT_NIL;

							/* Reset the linked channel */

							if ((Ph_b_stream_p_ctx_1 	!= P_NIL) &&
								(Ph_b_stream_p_reset_1 	!= FCT_NIL)) {
								Ph_b_stream_p_reset_1 (Ph_b_stream_p_ctx_1);
							}

							break;

					}

				} else {

					switch (Stream_mode) {

						case STREAM_MODE_V14	:
						case STREAM_MODE_V110_ASYNC:
						case STREAM_MODE_V110_SYNC:

								/* Reset the current channel */

							Ph_b_stream_p_ctx_0 	= P_NIL;
							Ph_b_stream_p_fct_0 	= FCT_NIL;
							Ph_b_stream_p_reset_0 	= FCT_NIL;

							/* Reset the linked channel */

							if ((Ph_b_stream_p_ctx_1 	!= P_NIL) &&
								(Ph_b_stream_p_reset_1 	!= FCT_NIL)) {
								Ph_b_stream_p_reset_1 (Ph_b_stream_p_ctx_1);
							}

							break;

						default :

								/* Reset the current channel */

							Ph_b_stream_p_ctx_1 	= P_NIL;
							Ph_b_stream_p_fct_1 	= FCT_NIL;
							Ph_b_stream_p_reset_1 	= FCT_NIL;

								/* Reset the linked channel */

							if ((Ph_b_stream_p_ctx_0 	!= P_NIL) &&
								(Ph_b_stream_p_reset_0 	!= FCT_NIL)) {
								Ph_b_stream_p_reset_0 (Ph_b_stream_p_ctx_0);
							}
							break;
					}

				}

				Stream_p_ph_stream = P_NIL;

			}

		It_enable ();

	}

}

		/* Function pointer */

	void (* CONST p_ph_b_stream_reset) () = (void FAR *)ph_b_stream_reset;

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ph_b_var_init - init of PH_B entity's global variables.

Usage            	void ph_b_var_init ();

Return value :		void

*--------------------------------------------------------------------------*/

#if ASSERT == ON

	extern uint it_hscx_a_nb;
	extern uint it_hscx_b_nb;

	extern long	ph_tx_byte_counter;		/* TX byte counter */
	extern long	ph_rx_byte_counter;		/* RX byte counter */

	extern long	ph_tx_frame_counter;	/* TX frame counter */
	extern long	ph_rx_frame_counter;	/* RX frame counter */

#endif

void ph_b_var_init ()
{
	p_ph_b_top_node 		= P_NIL;    /* Top node pointer */
	p_tab_peitab_a			= P_NIL;    /* PH B PEITAB pointer table HSCX A */
	p_tab_peitab_b			= P_NIL;    /* PH B PEITAB pointer table HSCX B */

#	if OPTIMIZATION == SPEED
		p_ph_b_na_tab		= P_NIL;	/* NA access index table */
#	endif

#	if ASSERT == ON

		it_hscx_a_nb 		= 0;
		it_hscx_b_nb		= 0;

		ph_tx_byte_counter	= 0;		/* TX byte counter */
		ph_rx_byte_counter	= 0;		/* RX byte counter */

		ph_tx_frame_counter = 0;		/* TX frame counter */
		ph_rx_frame_counter = 0;		/* RX frame counter */

#	endif

}

/*EOF*/
