
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - hscx_it.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		hscx_it - implements the interruption server in ISDN-BRICKS for
 *		SIEMENS HSCX LLD.
 *
 *		it_hscx_chan - handle the interrupts generated by an HDLC controller
 *		(HSCX channel).
 *
 *--------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    Siemens HSCX for B-channels Driver               |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#define ENTITY ENT_PH_B_IT

#include "ph_b.h"

		/* PEITAB table pointers */

	extern struct peitab FAR *FAR *p_tab_peitab_a;  /* PH B PEITAB pointer table HSCX A */
	extern struct peitab FAR *FAR *p_tab_peitab_b;  /* PH B PEITAB pointer table HSCX B */

#if PH_B_AUDIT == ON

#   define   Read_register()				   \
	grx_star = Rd_hscx (p_peitab -> pt_r_star);\
	grx_mode = Rd_hscx (p_peitab -> pt_r_mode);\
	grx_timr = Rd_hscx (p_peitab -> pt_r_timr);\
	grx_rbcl = Rd_hscx (p_peitab -> pt_r_rbcl);\
	grx_rsta = Rd_hscx (p_peitab -> pt_r_rsta);\
	grx_rhcr = Rd_hscx (p_peitab -> pt_r_rhcr);\
	grx_ccr2 = Rd_hscx (p_peitab -> pt_r_ccr2);\
	grx_rbch = Rd_hscx (p_peitab -> pt_r_rbch);\
	grx_cr1  = Rd_hscx (p_peitab -> pt_r_ccr1)

	uchar grx_star;
	uchar grx_mode;
	uchar grx_timr;
	uchar grx_rbcl;
	uchar grx_rsta;
	uchar grx_rhcr;
	uchar grx_ccr2;
	uchar grx_rbch;
	uchar grx_cr1;

#else

#   define Read_register()
#endif

/*

						CHIP INTERRUPT SERVER

*/

/***************************************************************************
 *                                                                         *
 *    SIEMENS ISDN-Userboard  (c) 1987-1989                                *
 *    ======================                                               *
 *                                                                         *
 *    Firmware:   device driver functions for HSCX only                    *
 *    File    :   hscx.c                                                   *
 *    created :   Aug. 1989                                                *
 *    author  :   Peter Mueller                                            *
 *    compiled:   Microsoft C compiler  5.1 (Small)                        *
 *                                                                         *
 ***************************************************************************/

		/* Local function declarations */

#if NEW_FCT_STYLE == ON
	void    hscx_it_chan    (uchar ista,    struct peitab FAR *p_peitab);
	void    hscx_event      (uchar event,   struct peitab FAR *p_peitab);
#else
	void    hscx_it_chan    ();
	void    hscx_event      ();
#endif

/***************************************************************************/

#if ASSERT == ON

	uint    it_hscx_a_nb;
	uint    it_hscx_b_nb;

	uchar   b1_ista_g;
	uchar   b2_ista_g;

	uchar   b_rsta_g;
	uchar   b_exir_g;

	long	ph_tx_byte_counter;		/* TX byte counter */
	long	ph_rx_byte_counter;		/* RX byte counter */

	long	ph_tx_frame_counter;	/* TX frame counter */
	long	ph_rx_frame_counter;	/* RX frame counter */

#endif

/*-------------------------------------------------------------------------*/

void hscx_it (hscx_id)
	uchar                hscx_id;   /* HSCX ID */
{
	uchar                b_ista, a_ista;
	struct peitab   FAR *p_peitab_a;
	struct peitab   FAR *p_peitab_b;

	p_peitab_b = p_tab_peitab_b [hscx_id];

		/* Any HSCX interrupt ? */

	while ((b_ista = Rd_hscx (p_peitab_b  -> pt_r_ista)) != 0) {

			/* interrupt from HSCX channel A ?  */
			/* (indicated by the last two       */
			/*  bits of ISTAB)                  */

		if (b_ista & (ISTA_ICA | ISTA_EXA)) {
			p_peitab_a = p_tab_peitab_a [hscx_id];

				/* Interrupt from HSCX channel A ?  */

			a_ista = Rd_hscx (p_peitab_a -> pt_r_ista);

			if (b_ista & ISTA_EXA) {
			   a_ista |= ISTA_EXI;
			}

			b_ista &= ~(ISTA_ICA | ISTA_EXA);

				/* Process IT HSCX A */

#			if ASSERT == ON
				it_hscx_a_nb++;
				b1_ista_g = a_ista;
#			endif

			hscx_it_chan (a_ista, p_peitab_a);
		 }

			/* Interrupt from HSCX channel B ?  */

		if (b_ista) {

				/* Process IT HSCX B */

#			if ASSERT == ON
				it_hscx_b_nb++;
				b2_ista_g = b_ista;
#			endif

			hscx_it_chan (b_ista, p_peitab_b);
		}

	}

		/* Mask and then clear the IT mask register */

	Wr_hscx (p_peitab_b -> pt_r_mask, (uchar) 0xFF);
	Wr_hscx (p_peitab_b -> pt_r_mask, 0);
}

   /*    ***   The interrupt service routines   ***   */
   /*    ******************************************   */

/***************************************************************************
 *                                                                         *
 *    Function: it_hscx_chan ()                                            *
 *    Parms   :'p_peitab'   pointer to PEITAB-table entry for this channel *
 *             'ista' value of interrupt status register                   *
 *    purpose : handle the interrupts generated by an HDLC controller      *
 *              (HSCX channel).                                            *
 *                                                                         *
 ***************************************************************************/

#if PH_B_STREAM == ON
	/*
	 *	Filler bytes.
	 *	Use 0x54 for filling for voice, 0x7E for HDLC flags, 0xFF for idle data
	 */

#	define NUL 0xFF

	static uchar CONST_ARRAY p_stream_wait_block [] = {
		NUL,NUL,NUL,NUL,NUL,NUL,NUL,NUL,
		NUL,NUL,NUL,NUL,NUL,NUL,NUL,NUL,
		NUL,NUL,NUL,NUL,NUL,NUL,NUL,NUL,
		NUL,NUL,NUL,NUL,NUL,NUL,NUL,NUL
	};

#endif

void hscx_it_chan (ista, p_peitab)
	register uchar              ista;
	register struct peitab  FAR *p_peitab;
{
	ushort                      data_size;
	uchar                       cmd;
	long                        state74 = 0L;
	uchar                       rsta;
	struct  buffer          FAR *p_buffer;

	Read_register ();

	/*++++++++++++++++++++++++ FULL TRANSPARENT MODE +++++++++++++++++++++++*/

#	if PH_B_STREAM == ON

			/* +++++++++++ Relaying if full transparent mode ? +++++++++++++*/

	{
		struct ph_b_stream	FAR *p_ph_b_stream;		/* Stream cell pointer */
		struct block_header	FAR *p_block;			/* Rx block pointer */


			/* ++++++++++++++++ Relaying in streaming mode +++++++++++++++++*/

		if (Stream) {

			if (Stream_mode == STREAM_MODE_TRANSPARENT) {

				cmd = 0;

					/* +++++++++++++++ Receive Pool Full ? +++++++++++++++++++++*/

				if (ista & ISTA_RPF) {

						/* Read incoming data on the current channel */

					if (Stream_rx_data_size + RFIFO_SIZE < Stream_rx_block_size) {

							/* The whole fifo can be read, and the block will not be filled */
							/* Move from the RFIFO to the current block */

						String_in ((char FAR *)Stream_rx_p_current_data,
								   p_peitab -> pt_r_fifo,
								   RFIFO_SIZE);

						Stream_rx_data_size 		+= RFIFO_SIZE;
						Stream_rx_p_current_data 	+= RFIFO_SIZE;

					} else {

							/* Fifo contents will fill the current block,
							   and possibly start a new one */
							/* Read first fifo part and fill the current block */

						String_in ((char FAR *)Stream_rx_p_current_data,
									p_peitab -> pt_r_fifo,
									(data_size = Stream_rx_block_size - Stream_rx_data_size));

							/*
								Transfer the block to the transmit port
								if streaming is OK.
							*/

							/* Equivalent to a first or a next block */

						p_block	= Stream_rx_p_current_block;
						Stream_out ((uchar FAR *)p_block + Block_header_size,
									(Stream_rx_block_retransmitted == ON) ?
									PH_B_STREAM_BLOCK_NEXT : PH_B_STREAM_BLOCK_FIRST,
									Stream_rx_block_size);

						Stream_rx_p_current_block 		= Block_p_next_block;
						Stream_rx_data_size				= 0;
						Stream_rx_p_current_data		= (uchar FAR *)Stream_rx_p_current_block + Block_header_size;
						Stream_rx_block_retransmitted	= ON;

							/* Second party ? */

						if (data_size != RFIFO_SIZE) {

								/* Transfer the remaining part of the RFIFO */

							data_size	= RFIFO_SIZE - data_size;
							String_in ((char FAR *)Stream_rx_p_current_data,
										p_peitab -> pt_r_fifo,
										data_size);

							Stream_rx_p_current_data 	+= data_size;
							Stream_rx_data_size 		 = data_size;

						}

					}

						/*  Write command for next reception */

					cmd |= CMDR_RMC;
				}

					/* +++++++++++++++++ Transmit Pool ready ? +++++++++++++++++*/

				if (ista & ISTA_XPR) {

					if (Stream_tx_block_size == 0) {

						/* Try to get a block from TX fifo */

						Stream_tx_data_size	= 0;
						Stream_tx_fifo_get_block (Stream_tx_p_current_data, Stream_tx_block_size);
					}

					if (Stream_tx_block_size == 0) {

						/* No block available, send filler */

						String_out ((char FAR *)p_stream_wait_block,
									p_peitab -> pt_r_fifo,
									sizeof (p_stream_wait_block));
					}
					else {
							/* Data are present in block */
							/* Write outgoing data on the current channel */

						if (Stream_tx_data_size + XFIFO_SIZE < Stream_tx_block_size) {

								/* A full fifo can be written, and this will not
								   empty the block */
								/* Move from the current block */

							String_out ((char FAR *)Stream_tx_p_current_data,
										p_peitab -> pt_r_fifo,
										XFIFO_SIZE);

							Stream_tx_data_size			+= XFIFO_SIZE;
							Stream_tx_p_current_data	+= XFIFO_SIZE;

						} else {

								/* Move end of current block */
								/* After this, the block will be empty */

							String_out ((char FAR *)Stream_tx_p_current_data,
										p_peitab -> pt_r_fifo,
										(data_size = Stream_tx_block_size - Stream_tx_data_size));

								/* Fetch next TX data block from TX fifo */

							Stream_tx_data_size	= 0;
							Stream_tx_fifo_get_block (Stream_tx_p_current_data, Stream_tx_block_size);

							if (Stream_tx_block_size == 0) {

								/* This will occur upon closure of the stream */

							}
							else if (data_size != XFIFO_SIZE) {

								/* The HSCX XFIFO has not been completely filled */
								/* Continue the HSCX XFIFO loading */

								data_size = XFIFO_SIZE - data_size;
								String_out ((char FAR *)Stream_tx_p_current_data,
											p_peitab -> pt_r_fifo,
											data_size);

								Stream_tx_data_size		 	 = data_size;
								Stream_tx_p_current_data	+= data_size;
							}

						}

					}

						/*  Write command for transmission */

					cmd |= CMDR_XTF;
				}


				 /* --------------------- Extended interrupt ---------------------*/

				if (ista & ISTA_EXI) {
					uchar    exir;

					exir = Rd_hscx (p_peitab -> pt_r_exir);

#					if ASSERT == ON
						b_exir_g = exir;
#					endif

					if ((exir & (EXIR_XMR | EXIR_XDU | EXIR_RFO)) != 0) {

						/* Please refer to the data sheets  */
						/* respectively techn. descriptions */
						/* of the controllers for detailed  */
						/* description of these interrupts  */
						/* free the transmit path if it     */
						/* was a XMR or XDU interrupt       */

						if (exir & (EXIR_XMR | EXIR_XDU)) {
							p_peitab -> pt_tx_cnt   = 0;
							p_peitab -> pt_state   &= ~PT_TX_WORKS;
							hscx_event (EV_TX_RETRY, p_peitab);
						}

						hscx_event (EV_TX_ERR, p_peitab);
					}

				}


				if (cmd) {

						/*  Write command */

					Wr_hscx (p_peitab -> pt_r_cmdr, cmd);
				}
				return;

			} else {

					/*---------------------- HDLC mode ---------------------*/

				return;
			}

		}

	}

#	endif

	/*++++++++++++++++++++++++++ HDLC  MODE ++++++++++++++++++++++++++++++++*/

			/* ------------------ HDLC receiver interrupt ? ----------------*/

   if (ista & (ISTA_RPF | ISTA_RME)) {

		if (ista & ISTA_RPF) {

			/*------------------ RPF interrupt -----------------------------*/

			/* RPF interrupt:                   */
			/* 32 bytes of a frame longer than  */
			/* 32 bytes have been received      */
			/* and are now available in the     */
			/* RFIFO.                           */
			/* The message is not complete.     */

		  data_size = RFIFO_SIZE;

		  if (p_peitab -> pt_rx_cnt == 0) {
			 Ph_b_rx_report_start_rx (p_peitab -> chani);
		  }

		} else {

			   /*----------------- RME interrupt ---------------------------*/

			   /* RME interrupt:                   */
			   /* Receive message end. The RFIFO   */
			   /* contains a complete frame        */
			   /* (length <= 32 byte) or the last  */
			   /* bytes or a frame (length > 32)   */
			   /* ================================ */

			   /* read byte count register(s) to   */
			   /* get the number of currently      */
			   /* received bytes                   */

			data_size = (ushort) Rd_hscx (p_peitab -> pt_r_rbcl) |
						(ushort) ((Rd_hscx (p_peitab -> pt_r_rbch) & 0x0F) << 8);

				/* exactly 32 bytes received ?      */

			if (data_size && !(data_size &= 0x1F)) {
				data_size = RFIFO_SIZE;
			}

		}

			/* data_size now contains the number*/
			/* of bytes actually received       */
			/* first data bytes of a new        */
			/* frame, i.e not already working   */
			/* in receive direction ?           */

		if ( ! (p_peitab -> pt_state & PT_RX_WORKS)) {

				/* Buffer not preallocated ==> allocate it */

			It_get_buffer (p_buffer);

			if (p_buffer != P_NIL) {

					/* Buffer header init */

				Buffer_header_init;

					/* PEITAB context init */

				p_peitab -> pt_rx_curr  = p_peitab -> pt_rx_start = (uchar FAR *)Buffer_a_start_data;
				p_peitab -> pt_rx_frame = 0x00;
				p_peitab -> pt_state   |= PT_RX_WORKS;

			} else {

				p_peitab -> pt_rx_start = P_NIL;
				p_peitab -> pt_rx_frame = PT_FR_NO_MEMORY;
				p_peitab -> pt_state   &= ~PT_RX_WORKS;
			}

		}
		   /* Update receive byte count        */

		if ((p_peitab -> pt_rx_cnt += data_size) > Buffer_data_lgth) {
			p_peitab -> pt_rx_frame = PT_FR_OVERFLOW;
		}

			/* Read the bytes from the RFIFO    */
			/* if no error was detected         */

		if (p_peitab -> pt_rx_frame < PT_FR_ERROR) {

			String_in ((char FAR *)p_peitab -> pt_rx_curr, (char FAR *)p_peitab -> pt_r_fifo, data_size);

				/* update buffer pointer            */
				/* it points to the next free       */
				/* location in the buffer           */

			p_peitab -> pt_rx_curr += data_size;

		}

			   /* enter 'RMC' command              */

		Wr_hscx (p_peitab -> pt_r_cmdr, CMDR_RMC);

		if (ista & ISTA_RME) {

				/* Error already detected ? */

			if (p_peitab -> pt_rx_frame < PT_FR_ERROR) {

				  /* RME !!!                          */
				  /* the buffer now contains all      */
				  /* received bytes inclusively the   */
				  /* status byte (RSTA)               */
				  /* get the RECEIVE STATUS byte      */

#				if ASSERT == ON

					b_rsta_g = p_peitab -> pt_rec_state = *(p_peitab -> pt_rx_curr - 1);

#				else

					p_peitab -> pt_rec_state 			= *(p_peitab -> pt_rx_curr - 1);
#				endif

				if (data_size) {
					data_size--;
					p_peitab -> pt_rx_cnt--;

#					if ASSERT == ON
						ph_rx_byte_counter += p_peitab -> pt_rx_cnt + 3;
						ph_rx_frame_counter++;
#					endif

				}

				if ((rsta = (p_peitab -> pt_rec_state & (RSTA_RDO | RSTA_CRC | RSTA_RAB)) ^RSTA_CRC) != 0) {
					p_peitab -> pt_rx_frame = PT_FR_FAULT;
				}

			}

			switch (p_peitab -> pt_rx_frame) {

				case PT_FR_FAULT:
					state74 |= (long) rsta << 8L;
					break;

				case PT_FR_OVERFLOW:
					p_peitab -> pt_rx_cnt   = Buffer_data_lgth;	/* to mark an overflow */
					p_peitab -> pt_rx_frame = 0x00;				/* Overflow --> not an error */
					break;

				case PT_FR_NO_MEMORY:
					state74 |= RESP_ERR_MMU;
					break;

				default:
					break;
			}

					/* Send and event RECEIVE DONE              */
					/* to PH_B or if error release the buffer   */

			if (p_peitab -> pt_rx_frame < PT_FR_ERROR) {

					/* Received frame done */

				hscx_event (EV_RX_DONE, p_peitab);

					/* Preallocate a new buffer */

				It_get_buffer (p_buffer);

				if (p_buffer != P_NIL) {

						/* Init buffer header */

					Buffer_header_init;

						/* Load frame offset with a hole */

					Buffer_data_offset += p_peitab -> pt_rx_offset;

						/* Init PEITAB context */

					p_peitab -> pt_rx_curr   = p_peitab -> pt_rx_start = (uchar FAR *)Buffer_a_start_data;
					p_peitab -> pt_state    |= PT_RX_WORKS;

				} else {

						/* Delay the buffer preallocation */

					p_peitab -> pt_rx_start  = P_NIL;
					p_peitab -> pt_state    &= ~PT_RX_WORKS;
				}

			} else {

				p_peitab -> pt_rx_curr   = p_peitab -> pt_rx_start;
			}

				/* Return from RX RME ready for next frame */

			p_peitab -> pt_rec_state   = 0;
			p_peitab -> pt_rx_cnt      = 0;
			p_peitab -> pt_rx_frame    = 0x00;

		}

   } if (ista & ISTA_XPR) {

		   /*-------------------- XPR interrupt -----------------------*/

		   /* XPR interrupt                    */
		   /* the XPR interrupt indicates      */
		   /* that the XFIFO is ready for new  */
		   /* data bytes.                      */
		   /* Reasons:                         */
		   /* - HDLC controller was reset via  */
		   /*   a reset command                */
		   /* - frame transmission finished    */
		   /* - one half of the XFIFO has      */
		   /*   been sent, new data bytes can  */
		   /*   be shifted to the XFIFO        */

		   /* transmit byte count is 0         */

		if ((data_size = p_peitab -> pt_tx_cnt) == 0) {

			   /* - HDLC controller reset command  */
			   /*   was given previously           */

			if (p_peitab -> pt_state & PT_HDLC_RESET) {

					/* Do nothing when it was a HDLC    */
					/* controller reset (do only clear  */
					/* the indicating flag)             */

				p_peitab -> pt_state    &= ~PT_HDLC_RESET;
				p_peitab -> pt_tx_cnt    = 0;
				p_peitab -> pt_state    &= ~PT_TX_WORKS;
				hscx_event (EV_TX_RESET, p_peitab);

			} else {

				   /* XPR was generated because the    */
				   /* last transmission is finished    */
				   /*   generate a transmit            */
				   /*   acknowledge response and free  */
				   /*   the transmit path              */

				p_peitab -> pt_tx_cnt   = 0;
				p_peitab -> pt_state   &= ~PT_TX_WORKS;
				hscx_event (EV_TX_DONE, p_peitab);
			}

		} else {

				/* - More data to be sent !         */

			cmd = CMDR_XTF;

			if (data_size > XFIFO_SIZE)  {
				data_size = XFIFO_SIZE;
			}

			String_out ((char FAR *)p_peitab -> pt_tx_curr, p_peitab -> pt_r_fifo, data_size);

			p_peitab -> pt_tx_curr += data_size;      /* update current buffer pointer    */
			p_peitab -> pt_tx_cnt  -= data_size;      /* and counter of remaining bytes   */

			if (p_peitab -> pt_tx_cnt == 0) {

					/* End Of command */

					cmd |= CMDR_XME;
			}

				/*  Write command */

			Wr_hscx (p_peitab -> pt_r_cmdr, cmd);
		}

	}

		 /* --------------------- Extended interrupt ---------------------*/

	if (ista & ISTA_EXI) {
		uchar    exir, status;

		exir = Rd_hscx (p_peitab -> pt_r_exir);

#		if ASSERT == ON
			 b_exir_g = exir;
#		endif

		if ((status = (exir & (EXIR_XMR | EXIR_XDU | EXIR_RFO)) >> 1) != 0) {
			state74 |= (long) status << 16;

				/* Please refer to the data sheets  */
				/* respectively techn. descriptions */
				/* of the controllers for detailed  */
				/* description of these interrupts  */
				/* free the transmit path if it     */
				/* was a XMR or XDU interrupt       */

			if (exir & (EXIR_XMR | EXIR_XDU)) {
				p_peitab -> pt_tx_cnt   = 0;
				p_peitab -> pt_state   &= ~PT_TX_WORKS;
				hscx_event (EV_TX_RETRY, p_peitab);
			}

		}

	}

	if (state74) {
		hscx_event (EV_TX_ERR, p_peitab);
	}

}

/*-------------------------------------------------------------------------*/

#if PH_B_STREAM == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             hscx_stream_out - implements the transmission
				 of a block in streaming mode.

Usage            void hscx_stream_out (p_peitab, p_block, data_size)
					- p_peitab 	 = context pointer,
					- p_block	 = block pointer,
					- type       = type of block :
									. PH_B_STREAM_FRAME_ABORT,
									. PH_B_STREAM_BLOCK_FIRST,
									. PH_B_STREAM_BLOCK_NEXT,
									. PH_B_STREAM_BLOCK_LAST,
									. PH_B_STREAM_BLOCK_SUP.

					- data_size	 = data size of the block.

common constants and declarations  basic.h

common : HSCX channel context.

*--------------------------------------------------------------------------*/

uchar hscx_stream_out (p_peitab, p_block, type, data_size)
	register uchar  		FAR *p_peitab;				/* context pointer */
	uchar					FAR	*p_block;				/* block to transmit */
	register uchar		 	 	type;					/* type of block : STREAM_FRAME_ABORT, STREAM_BLOCK_NEXT or STREAM_BLOCK_LAST */
	ushort				 	 	data_size;				/* block data size */
{

	Stream_tx_fifo_put_block (p_block, data_size);

		/* Return OK */

	return (OK);

}

/*--------------------------------------------------------------------------*/

		/* Function pointer */

	void (* CONST p_hscx_stream_out) () = (void (FAR *)())hscx_stream_out;

#endif

/*EOF*/
