
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - basic.h
 *
 * $Revision$
 *
 * $Date$
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    Siemens HSCX for B-channels Driver               |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

/***************************************************************************
 *                                                                         *
 *    Siemens ISDN-Userboard  (c) 1989                                     *
 *    ======================                                               *
 *                                                                         *
 *    Firmware:   definitions for the ISDN devices                         *
 *    File:       basic.h                                                  *
 *    created:    March 1988                                               *
 *    author:     Peter Mueller, Frank Dowling                             *
 *    compiled:   Microsoft C-Compiler                                     *
 *                                                                         *
 ***************************************************************************/

   /* History
	  ======================================================================
	  date  author   reason

					 1989

	  --------------------------------------------------------------------*/

#if PH_B_STREAM == ON

#	define	STREAM_TX_FIFO_SIZE			16
#	define	STREAM_TX_GUARD_SIZE		1		/* Minimum number of blocks present, in steady state, in the Tx fifo */

		/* Stream current context */

#	define Stream    			   		p_peitab -> stream_flag
#	define Stream_mode 			   		p_peitab -> stream_mode
#	define Stream_p_ph_stream	   		p_peitab -> p_ph_b_stream
#	define Stream_x_ph_stream	   		p_peitab -> stream_x_ph_stream

#  	define Stream_rx_p_first_block    	p_peitab -> stream_rx_p_first_block
#	define Stream_rx_block_nb		   	p_peitab -> stream_rx_block_nb
#	define Stream_rx_block_size       	p_peitab -> stream_rx_block_size
#	define Stream_rx_p_current_block  	p_peitab -> p_stream_rx_current_block
#	define Stream_rx_p_current_data  	p_peitab -> p_stream_rx_current_data
#	define Stream_rx_data_size	  		p_peitab -> stream_rx_data_size
#	define Stream_rx_block_retransmitted p_peitab -> stream_rx_block_retransmitted

#	define Stream_tx_block_size       	p_peitab -> stream_tx_block_size
#	define Stream_tx_p_current_data  	p_peitab -> p_stream_tx_current_data
#	define Stream_tx_data_size	  		p_peitab -> stream_tx_data_size

#	define Stream_tx_fifo_size		  	((struct peitab FAR *)p_peitab) -> stream_tx_fifo_size
#	define Stream_tx_fifo_started	  	((struct peitab FAR *)p_peitab) -> stream_tx_fifo_started
#	define Stream_tx_fifo_x_first	  	((struct peitab FAR *)p_peitab) -> stream_tx_fifo_x_first
#	define Stream_tx_fifo_p_block(i)	((struct peitab FAR *)p_peitab) -> stream_tx_fifo[i].p_block
#	define Stream_tx_fifo_block_size(i)	((struct peitab FAR *)p_peitab) -> stream_tx_fifo[i].bloc_size

		/* Stream block header */

	struct block_header {
		struct block_header FAR 	*p_next_block;		/* next block address */
		uchar					 	rx_status;			/* RX status */
	};

#	define Block_rx_status			((struct block_header FAR *) p_block) -> rx_status
#	define Block_p_next_block 		((struct block_header FAR *) p_block) -> p_next_block

#	define Block_header_size		Rnd_sizeof (struct block_header)

#	define Stream_out(p_block,type,data_size)																		\
	if ((p_ph_b_stream = Stream_p_ph_stream) != P_NIL) {															\
		if (Stream_x_ph_stream == 0) {																				\
			if (Ph_b_stream_p_ctx_1 != P_NIL) {																		\
				if ((Ph_b_stream_p_fct_1) ((uchar FAR *)Ph_b_stream_p_ctx_1, p_block, type, data_size) == NOK) {	\
					Trap (TRAP_TX_SYNCHRO, "hdlc_b_stream_out");                         							\
				}                                                                 					              	\
			}                                                                                   					\
		} else {                                                               										\
			if (Ph_b_stream_p_ctx_0 != P_NIL) {																		\
				if ((Ph_b_stream_p_fct_0) ((uchar FAR *)Ph_b_stream_p_ctx_0, p_block, type, data_size) == NOK) {	\
					Trap (TRAP_TX_SYNCHRO, "hdlc_b_stream_out");                         							\
				}                                                                               					\
			}                                                               										\
		}																											\
	}


#define Stream_tx_fifo_put_block(p_block, block_size)															\
	{	uchar _last;													\
		if (Stream_tx_fifo_size >= (STREAM_TX_FIFO_SIZE - 1)) {			\
			Trap (TRAP_TX_OVERRUN, "hscx_it");							\
		} else {														\
			_last	= Stream_tx_fifo_x_first + Stream_tx_fifo_size;		\
			if (_last >= STREAM_TX_FIFO_SIZE) 	{						\
				_last -= STREAM_TX_FIFO_SIZE; }							\
			Stream_tx_fifo_p_block 		(_last)	= p_block;				\
			Stream_tx_fifo_block_size 	(_last)	= block_size;           \
			++Stream_tx_fifo_size;										\
			if ((!Stream_tx_fifo_started) && 							\
				(Stream_tx_fifo_size > STREAM_TX_GUARD_SIZE)) {			\
				Stream_tx_fifo_started	= ON;	}						\
		}																\
	}

/*
 *		Upon return, block_size if set to 0 if the Tx fifo was empty
 */
#define Stream_tx_fifo_get_block(p_block, block_size)					\
	if ((!Stream_tx_fifo_started) || (Stream_tx_fifo_size <= 0)) {		\
		block_size = 0; p_block = (uchar FAR *)p_stream_wait_block;		\
	} else {															\
		uchar	_first;													\
		_first		= Stream_tx_fifo_x_first;                   		\
		p_block		= Stream_tx_fifo_p_block 	(_first);         		\
		block_size 	= Stream_tx_fifo_block_size (_first);               \
		--Stream_tx_fifo_size;											\
		Stream_tx_fifo_x_first = ((++_first == STREAM_TX_FIFO_SIZE) ?   \
			0 : _first);												\
	}

		/* Type of block */

#	define PH_B_STREAM_FRAME_ABORT		'A'
#	define PH_B_STREAM_BLOCK_FIRST		'F'
#	define PH_B_STREAM_BLOCK_NEXT		'N'
#	define PH_B_STREAM_BLOCK_LAST		'L'
#	define PH_B_STREAM_BLOCK_SUP		'S'

#endif

#define MAX_PEITAB     		6

#define MAX_PEI_VALUES 		6
									   /* defines for the hardware         */
									   /* configuration:                   */
									   /* =========================        */
#define  MM_TE          1              /*    TE (Terminal Equipment)       */
#define  MM_NT          2
#define  MM_LT_S        3              /*    LT-S (Line Termination -S)    */
#define  MM_LT_T        4
#define  MM_NO_SUPPORT  5



   /* add-on-module identifiers (IDs)
	  ===============================

	  The ID number of an add-on-module is decoded in the module's
	  description EPROM and depends on the module's operating mode
	  ( TE / NTS / LT-S ) which can be switched via a set of jumpers.

      The module ID number is used to identify the module and its operating
      mode. This information is neccessary to do the appropriate register
      setup and to control the components according to the operating mode  */

            /* IDs of the 'LAYER 2' module: 
                           (with ICC + HSCC)       */
                                                                                    
#define  MID_LAYER2_TE     0x01     
#define  MID_LAYER2_NT_S   0x02           
#define  MID_LAYER2_DEM    0x03           
#define  MID_LAYER2_LT_S   0x06


            /* IDs of the 'S access V 0' module:
                           (with ISAC-S + 2 ICCs)  */

#define  MID_ISACS0_TE_S   0x07 
#define  MID_ISACS0_TE_E   0x08    
#define  MID_ISACS0_NT_S   0x09 
#define  MID_ISACS0_LT_T   0x0A    

            /* IDs of the S access V 1' module:
                           (with ISAC-S + HSCX)    */

#define  MID_ISACS1_TE_S   0x0B
#define  MID_ISACS1_LT_T   0x0C 
#define  MID_ISACS1_LT_S   0x0D 
#define  MID_ISACS1_NT_S   0x0E

            /* IDs of the 'SBCX LAYER 2' module: 
                           (with ICC + SBCX)       */
                                                                                    
#define  MID_L2_SBCX_TE    0x40     
#define  MID_L2_SBCX_NT_S  0x41           
#define  MID_L2_SBCX_LT_S  0x42           


#define  MID_AUDIO_IF      0x05        /* ID of the AUDIO interface        */
                                       /* module                           */


            /* ICC register offsets    
               --------------------     register mnemonic
                                       (see also ICC / ISAC data sheet)    */
                                 
#define ICC_FIFO     0x00                 /* RFIFO / XFIFO  */
#define ICC_MASK     0x20                 /* MASK           */
#define ICC_ISTA     ICC_MASK             /* ISTA           */
#define ICC_CMDR     0x21                 /* CMDR           */
#define ICC_STAR     ICC_CMDR             /* STAR           */
#define ICC_MODE     0x22                 /* MODE           */
#define ICC_TIMR     0x23                 /* TIMR           */
#define ICC_XAD1     0x24                 /* XAD1           */
#define ICC_EXIR     ICC_XAD1             /* EXIR           */
#define ICC_XAD2     0x25                 /* XAD2           */
#define ICC_RFBC     ICC_XAD2             /* RFBC           */
#define ICC_SAP1     0x26                 /* SAP1           */
#define ICC_SAP2     0x27                 /* SAP2           */
#define ICC_RSTA     ICC_SAP2             /* RSTA           */
#define ICC_TEI1     0x28                 /* TEI1           */
#define ICC_TEI2     0x29                 /* TEI2           */
#define ICC_RHCR     ICC_TEI2             /* RHCR           */
#define ICC_SPCR     0x30                 /* SPCR           */
#define ICC_CIXR     0x31                 /* CIXR = CIRR    */
#define ICC_MONR     0x32                 /* MONR           */
#define ICC_SSGX     0x33                 /* SSGX           */
#define ICC_SFCR     0x34                 /* SFCR           */
#define ICC_STCR     0x37                 /* STCR           */
#define ICC_ADFR     0x38                 /* ADFR           */

                                       /* additional registers of          */
                                       /* ICC/ISAC  Version B              */
#define ICC_RBCH     0x2A                 /* RBCH           */
#define ICC_CIX1     0x33                 /* CIX1 = CIR1    */
#define ICC_MOX1     0x34                 /* MOX1 = MOR1    */
#define ICC_ADF2     0x39                 /* ADF2           */
#define ICC_MOCR     0x3A                 /* MOCR = MOSR    */
#define ISAC_SQXR    0x3B

            /* HSCC-Register offsets from Base-Address   
               ---------------------------------------   */
            /* registers common for channel A and B      */

#define HSCC_BGR        0x2B
#define HSCC_TCR        0x2C
#define HSCC_TSAR       0x2D
#define HSCC_TSAX       0x2E
#define HSCC_CCR        0x2F

            /* the following registers have different base addresses 
               depending on the channel (HSCC ch.A or B); 
               (refer to HSCC data sheet for detailed description)         */

#define HSCC_FIFO       0x00
#define HSCC_MASK       0x20
#define HSCC_ISTA       HSCC_MASK
#define HSCC_CMDR       0x21     
#define HSCC_STAR       HSCC_CMDR
#define HSCC_MODE       0x22
#define HSCC_TIMR       0x23
#define HSCC_XAD1       0x24
#define HSCC_EXIR       HSCC_XAD1
#define HSCC_XAD2       0x25
#define HSCC_RFBC       HSCC_XAD2
#define HSCC_RAH1       0x26
#define HSCC_RAH2       0x27
#define HSCC_RSTA       HSCC_RAH2
#define HSCC_RAL1       0x28
#define HSCC_RAL2       0x29
#define HSCC_RHCR       HSCC_RAL2



            /* HSCX-Register offsets from Base-Address   
               ---------------------------------------   */

            /* Channel A and channel B have identical register structures;
               channel A offset from base address:    0
               channel B offset from base address: 0x40                    */


#define HSCX_FIFO       0x00           /* RFIFO and XFIFO                  */
#define HSCX_MASK       0x20
#define HSCX_ISTA       HSCX_MASK
#define HSCX_CMDR       0x21     
#define HSCX_STAR       HSCX_CMDR
#define HSCX_MODE       0x22
#define HSCX_TIMR       0x23
#define HSCX_XAD1       0x24
#define HSCX_EXIR       HSCX_XAD1
#define HSCX_XAD2       0x25
#define HSCX_RBCL       HSCX_XAD2
#define HSCX_RAH1       0x26
#define HSCX_RAH2       0x27
#define HSCX_RSTA       HSCX_RAH2
#define HSCX_RAL1       0x28
#define HSCX_RAL2       0x29
#define HSCX_RHCR       HSCX_RAL2
#define HSCX_XBCL       0x2A           /* transmit byte count low          */
#define HSCX_BGR        0x2B           /* baud rate generator register     */
#define HSCX_CCR2       0x2C           /* channel configuration reg. 2     */
#define HSCX_RBCH       0x2D           /* receive byte count high          */
#define HSCX_XBCH       HSCX_RBCH      /* transmit byte count low          */
#define HSCX_VSTR       0x2E           /* version status register          */
#define HSCX_RLCR       HSCX_VSTR      /* receive lenght check register    */
#define HSCX_CCR1       0x2F           /* channel configuration reg. 1     */
#define HSCX_TSAX       0x30           /* timeslot assignment reg. trans.  */
#define HSCX_TSAR       0x31           /* timeslot assignment reg. rec.    */
#define HSCX_XCCR       0x32           /* channel capacity reg. transmit   */
#define HSCX_RCCR       0x33           /* channel capacity reg. receive    */




            /* register-flags (ICC/HSCC/HSCX)
               ------------------------------ */

               /* ISTA (interrupt status register) */

#define  ISTA_RME    0x80     /* Receive Message End                       */
#define  ISTA_RPF    0x40     /* Receive Pool Full                         */
#define  ISTA_RSC    0x20     /* Receive Status Change 
                                 (used in auto mode only)                  */
#define  ISTA_XPR    0x10     /* Transmit Pool Ready                       */
#define  ISTA_TIN    0x08     /* Timer Interrupt                           */

                              /* following only valid for ISAC-S and ICC   */
#define  ISTA_CIC    0x04     /* C/I Code Change                           */
#define  ISTA_SIN    0x02     /* Synchronous Transfer Register             */
#define  ISTA_EXI    0x01     /* Extended Interrupt                        */

                              /* following only for HSCC/HSCX  ISTA B      */
#define  ISTA_ICA    0x04     /* indicates Interrupt from channel A        */
#define  ISTA_EXA    0x02     /* extended Interrupt from channel A         */
#define  ISTA_EXB    0x01     /* extended Interrupt from channel B         */

               
               /* MASK (interrupt mask register) */

#define  MASK_RME    0x80
#define  MASK_RPF    0x40
#define  MASK_RSC    0x20
#define  MASK_XPR    0x10
#define  MASK_TIN    0x08
#define  MASK_CIC    0x04
#define  MASK_SIN    0x02
#define  MASK_EXI    0x01

               /* EXIR (extended interrupt register)  */

#define  EXIR_XMR    0x80     /* Transmit Message Repeat                   */
#define  EXIR_XDU    0x40     /* Transmit Data Underrun                    */
#define  EXIR_PCE    0x20     /* Protocol Error                            */
#define  EXIR_RFO    0x10     /* Receive Frame Overflow                    */

                              /* SOV, MOR, SAW, WOV only in ICC/ISAC !     */
#define  EXIR_SOV    0x08     /* Synchronous Transfer Overflow             */
#define  EXIR_MOR    0x04     /* MON channel status change                 */ 
#define  EXIR_SAW    0x02     /* Subscriber Awake                          */
#define  EXIR_WOV    0x01     /* Watchdog Timer Overflow                   */

                              /* CSC only in HSCC and HSCX !               */
#define  EXIR_CSC    0x08     /* Clear to send Status Change               */
#define  EXIR_RFS    0x04     /* Receive Frame Start ( only in the HSCX !) */


               /* STAR (status register)        */

#define  STAR_BVS    0x02     /* B-channel Valid at SLD (only ICC/ISAC)    */
#define  STAR_XFW    0x40     /* transmit FIFO write enable, data can be 
                                 written into the XFIFO                    */

#define  STAR_CEC    0x04     /* command executing ( only HSCX )           */


               /* RSTA (receive status register) */

#define  RSTA_RDO    0x40     /* Receive Data Overflow                     */
#define  RSTA_CRC    0x20     /* CRC compare/check                         */
#define  RSTA_RAB    0x10     /* Receive Message Aborted                   */
 
  

               /* CMDR (command register)       */
 
#define  CMDR_RMC    0x80     /* Receive Message Complete                  */
#define  CMDR_RHR    0x40     /* Reset HDLC Receiver                       */
#define  CMDR_RNR    0x20     /* Receiver Not Ready -  
                                 (used in auto mode only)                  */
#define  CMDR_XREP   0x20     /* transmission repeat ( only in the HSCX !) */
#define  CMDR_STI    0x10     /* Start Timer                               */
#define  CMDR_XTF    0x08     /* Transmit Transparent Frame                */
#define  CMDR_XIF    0x04     /* Transmit I-Frame (used in auto mode only) */
#define  CMDR_XME    0x02     /* Transmit Message End                      */
#define  CMDR_XRES   0x01     /* Transmit Reset                            */


               /* MODE (Mode Register) */

#define  MODE_MDS1   0x80     /* Mode Select 1        (MDS2)               */
#define  MODE_MDS0   0x40     /* Mode Select 2        (MDS1)               */
#define  MODE_ADM    0x20     /* Address Mode         (MDS0)               */
#define  MODE_TMD    0x10     /* Timer Mode                                */
#define  MODE_RAC    0x08     /* Receiver Active                           */

                              /* following bits to program an ICC's (ISAC)
                                 serial port b mode:
                                 IOM interface or HDLC interface           */
#define  MODE_HMD2   0x04     /* HDLC port Mode2                           */
#define  MODE_HMD1   0x02     /* HDLC port Mode1                           */
#define  MODE_HMD0   0x01     /* HDLC port Mode0					       */

                              /* when HSCC/HSCX are used the bits
                                 have a different meaning                  */
#define  MODE_RTS    0x04     /* Request To Send                           */
#define  MODE_TRS    0x02     /* Timer Resolution                          */
#define  MODE_TLP    0x01     /* Test-Loop                                 */
   

               /* CIXR  Register (CIX0 when ICC-B (ISAC) */

#define  CIXR_TBC    0x40     /* TIC bus Control                           */
                              /* C/I-Code Transmit                         */
#define  CIXR_TCX    0x02     /* T-channel transmit                        */
#define  CIXR_ECX    0x01     /* E-channel transmit                        */


               /* STCR (ICC/ISAC) (synchronous transfer control register) */

#define  STCR_ST1    0x08     /* Enable SIN interrupt at the beginning
                                 of 8 kHz frame signal                     */
#define  STCR_ST0    0x04     /* Enable SIN interrupt at center of
                                 8 kHz frame signal                        */
#define  STCR_SC1    0x02     /* Synchronous Transfer 1 complete           */
#define  STCR_SC0    0x01     /* Synchronous Transfer 0 complete           */


               /* SPCR (ICC/ISAC) (serial port control register)           */

#define  SPCR_SPU    0x80     /* Software Power Up - (in TE mode only)     */
#define  SPCR_SAC    0x40     /* SIP Activated                             */
#define  SPCR_SPM    0x20     /* Serial Port Timing Mode                   */
#define  SPCR_TPL    0x10     /* Test Loop                                 */
#define  SPCR_B1C1   0x08     /* Switching of B1 channel (IOM1)            */
#define  SPCR_B1C0   0x04     /*    "       "       "    (IOM1)            */
#define  SPCR_B2C1   0x02     /* Switching of B2 channel (IOM1)            */
#define  SPCR_B2C0   0x01     /*    "       "       "    (IOM1)            */


               /* CCR (only HSCC: common configuration register)           */ 
 
#define  CCR_PU      0x80     /* Power up                                  */
#define  CCR_ODS     0x10     /* output driver select                      */


               /* CCR1 ( only HSCX: channel configuration register1)       */ 
 
#define  CCR1_PU     0x80     /* Power up                                  */
#define  CCR1_ODS    0x10     /* output driver select                      */
#define  CCR1_ITF    0x08     /* interframe time fill ( IDLE or FLAGS )    */

               /* CCR2 ( only HSCX: channel configuration register2)       */ 
 
#define  CCR2_XCS0   0x20     /* tx clock shift bit 0                      */
#define  CCR2_RCS0   0x10     /* rx clock shift bit 0                      */



#define  CODX_ALL_BITS  0x3C  


               /* C/I codes      */
               /* =========      */

#define  CODX_DID       0x3C  /* 1111: DID; deactivation indication
                                            downstream                     */
#define  CODX_DIU       0x3C  /* 1111: DIU; deactivation indication
                                            upstream                       */
#define  CODX_DI        0x3C  /* 1111: DI;  deactivation indication        */

#define  CODX_ACT_IND10 0x34  /* 1101:       activation indication (P10)   */
#define  CODX_ACT_IND   0x30  /* 1100:
                                 upstream ->
                                   NT/TE/LT-T/LT-S: 
                                          AIU; Activation indication;
                                               receiver is syncronous   
                                   TE/LT-T: AI8; Info 4  
                                                  priority is 8 or 9  
                                 downstream -> only on NT activation ind.  */
#define  CODX_DEAC      0x04

#define  CODX_ACT_REQ   0x20  /* 1000: upstream/downstream ->
                                 NT/TE/LT-T/LT-S: activation request       */

#define  CODX_EI        0x18  /* 0110: TE: EI; Error indicate downstream   */
#define  CODX_RESYN     0x10  /* 0100: upstream -> resncronisation         */

#define  CODX_RS        0x04  /* 0001: TE; upstream -> Reset               */ 
#define  CODX_PU        0x1C  /* 0111: TE; PU indication                   */

#define  CODX_DEA_REQ   0x00  /* 0000: upstream ->
                                 NT:      TIM; Clocks are required   
                                 TE/LT-T: DR;  Deactivation request by S
                                 downstream ->
                                 LT-S/NT: DR;  Deactivation request                                   
                                 TE/LT-T: TIM; Clocks are requiered        */

#define  CODX_TIM       0x00  /* NT: timing clocks required                */

#define  CODX_LSL       0x04  /* NT: lost signal level                     */

#define  CODX_EI        0x18  /* NT: error indication                      */

#define  CODX_RES       0x34  /* 1101: IBC TE/LT; Reset command            */ 
#define  CODX_TMA       0x14  /* 0101: IBC TE; Test mode (Reset) indication*/ 
#define  CODX_DA        0x04  /* 0001: IBC TE; Test mode (Reset) indication*/ 
#define  CODX_ARL       0x24  /* 1001: IEC TE; Loop request                */ 
#define  CODX_ARLQ      0x28  /* 1010: IEC-Q TE/LT; Loop request           */ 

#define  MONX_ID        0x80  /* Monitor Channel ID command                */ 

               /* C/R mailbox response #73 :
                  constants to indicate the different C/I codes      */

#define  CI_PH_AI       0x01  /* Physical Activate Indication              */ 
#define  CI_PH_DI       0x02  /* Physical Deactivate Indication            */
#define  CI_MPH_AI      0x01  /* Management-Physical Activation Indication */
#define  CI_MPH_DI      0x02  /* Management-Physical Deactivation Ind.     */
#define  CI_MPH_EI_LF   0x04  /* Management-Physical Error Indication
                                 Lost Framing                              */
#define  CI_MPH_EI_RY   0x08  /* Management-Physical Error Indication
                                 Resynchronisized                          */
#define  CI_MPH_II_CON  0x10  /* Management-Physical Information Indication
                                 Connected                                 */
#define  CI_XCONT_ZERO  0x10  /* Send continuous zeroes:
                                 transmission of AMI pulses at 96 kHz      */
#define  CI_MPH_II_DIS  0x20  /* Management-Physical Information Indication
                                 Diconnected                               */

#define  CI_TIMING      0x40  /* Timing, clocks required                   */
#define  CI_LOST_SL     0x80  /* Lost signal level                         */
#define  CI_ERR_IND     0xC0  /* Error indication, RST and SCZ both active */




   /* Error Codes for Resp_Status_BASIC ()
      (to report error condition detected 
               during interrupt handling )
      ====================================   */

               /* status byte 3  */


#define  RESP_ERR_MMU   0x08L          /* no memory                        */
#define  RESP_ERR_N201  0x10L          /* frame to long                    */
#define  RESP_ERR_READY 0x20L          /* Peer Receiver Ready              */
#define  RESP_ERR_BUSY  0x21L          /* Peer Receiver Busy               */
                                                                 
#define  RESP_ERR_TIN   0x40L          /* TIMER interrupt                  */ 

               /* status byte 2 */

                                       /* Receive Data Overflow            */
#define  RESP_ERR_RDO   (DWORD) RSTA_RDO << 8L
                                       /* CRC-Error                        */
#define  RESP_ERR_CRC   (DWORD) RSTA_CRC << 8L
                                       /* Receive Frame aborted            */
#define  RESP_ERR_RAB   (DWORD) RSTA_RAB << 8L


               /* status byte 1 */

                                       /* Message Lost/Transmission Error  */
#define  RESP_ERR_XMR   (DWORD) EXIR_XMR << 15L
                                       /* Message Lost / Data Underrun     */
#define  RESP_ERR_XDU   (DWORD) EXIR_XDU << 15L
                                       /* N(R)-Error + Unexpected I-Data   */
#define  RESP_ERR_PCE   (DWORD) EXIR_PCE << 15L
                                       /* Receive Frame overlow            */
#define  RESP_ERR_RFO   (DWORD) EXIR_RFO << 15L
   



            /* The following definitions are for the
               different variables in the PEITAB structure */

                                    /* values of 'pt_device'               */
#define  PT_NON_EXIST      0
#define  PT_ICC            1        /*    ICC or ISAC-S A                  */
#define  PT_ICC_B          2        /*    ICC/ISAC-S B                     */
#define  PT_HSCC           3        /*    HSCC                             */
#define  PT_HSCX           4        /*    HSCX                             */

                                       /* Note: pt_device is set to        */
                                       /* PT_ICC or PT_ICC_B even if it    */
                                       /* is an ISAC-S                     */

                                    /* values of 'pt_Lay1id':  
                                       (ID numbers of Layer1 devices)      */

#define  UNK_LAY1       0           /* unknown layer1 device               */
#define  SBC_LAY1       1           /*    SBC                              */
#define  IBC_A3_LAY1    2           /*    IBC version A3                   */
#define  IBC_LAY1       3           /*    IBC                              */
#define  IEC_LAY1       4           /*    IEC T                            */
#define  IECQ_LAY1      5           /*    IEC Q                            */

                                    /* values of 'pt_Codec'                */
#define  NOT_PRESENT    0
#define  SICOFI         1           /* means:   SICOFI detected;        
                                          and  :   device is used to 
                                                   program the SICOFI      */
#define  ARCOFI         2           /* means:   ARCOFI detected;
                                          and  :   device is used to 
                                                   program the ARCOFI      */

                                    /* values of 'pt_op_mode'              */
                                    /* (stores operation mode of HDLC      */
                                    /*  controller)                        */

#define  PT_MD_AUTO        0        /* - Auto-Mode                         */
#define  PT_MD_NON_AUTO    1        /* - non Auto-Mode                     */
#define  PT_MD_TRANSP      2        /* - transparent mode                  */
                                    /*    (high byte address recognition)  */
#define  PT_MD_EXT_TRANSP  3        /* - extended transparent mode         */
                                    /*    (no address recognition)         */
#define  PT_MD_FULL_TRANSP 5        /* - full transparent mode             */
                                    /*    (no HDLC framing; only HSCX)     */
#define  PT_MD_NOT_FIXED   0xFF     /* - mode not fixed                    */

                                 
                                    /* values of the frame identifiers     */
                                    /* 'pt_rx_frame' and 'pt_tx_frame'     */
                                    /* (store frame type + errors)         */
#define  PT_FR_I           0        /*    I-frame                          */
#define  PT_FR_UI          1        /*    UI-frame                         */
#define  PT_FR_TR          2        /*    transparent data                 */
#define  PT_FR_S           4        /*    S-frame                          */
#define  PT_FR_U           8        /*    U-frame                          */

#define  VALID          0x00
#define  MUTILATED      0x80
#define  TOO_LONG       0x82

#define  PT_FR_ERROR     100        /* indicates an error (i.e. the frame  */
                                    /* identifier has a number >= 100)     */
#define  PT_FR_OVERFLOW  100        /* indicates frame overflow            */
#define  PT_FR_NO_MEMORY 101        /* no memory was free to store frame   */
#define  PT_FR_FAULT     102        /* frame is erroneous because:
                                       - CRC failed
                                       - RDO receive data overflow
                                       - RAB receiver aborted              */

                                    /* flags of 'pt_state'                 */
                                    /* which indicates the various states  */
                                    /* of an HDLC controller and some other*/
                                    /* special conditions                  */
#define  PT_TX_MMU_FREE    0x0001      /* memory buffer must be released   */
                                       /* after transmission               */
#define  PT_TX_WORKS       0x0002      /* controller is working in         */
                                       /* transmit direction               */
#define  PT_RX_WORKS       0x0004      /* controller is working in         */
                                       /* receive direction                */
#define  PT_HDLC_RESET     0x0008      /* controller was reset via         */
                                       /* command                          */
#define  PT_LOOP           0x0010      /* controller in test loop mode     */
#define  PT_M128           0x0100      /* modulo 128 (extended) operation  */
#define  PT_L1_CTRL        0x0200      /* device is used to program L1     */
#define  PT_DEV_AT_SLD     0x0400      /* device at SLD interface (IOM1)   */
#define  PT_IOM2           0x1000      /* device operates in IOM2       
                                                             configuration */


                                 /* flags used for B channel assignment 
                                    at the SLD interface                   */
#define PT_ASS_TXB1        0x01  /* transmit on B1 channel                 */
#define PT_ASS_TXB2        0x02

#define PT_ASS_RXB1        0x10  /* receive on B1 channel                  */
#define PT_ASS_RXB2        0x20

                                 /* values of 'pt_ModulMode'               */
#define PT_MM_TE           1     /* TE Terminal                            */
#define PT_MM_NT           2     /* NT   (Network Termination)             */
#define PT_MM_LT_S         3     /* LT-S (Line Termination -S)             */
#define PT_MM_LT_T         4
#define PT_MM_NO_SUPPORT   5


/*-------------------------------------------------------------------------*/

#if PH_B_STREAM == ON

#endif

/*-------------------------------------------------------------------------*/



   /* Structures
      ==========  */
                                 /* the following structure has been
                                    defined to hold all specific
                                    information about a device             */

struct peitab
{
   IO_PORT              pt_io_base;       /* I/O location                  */
   unsigned int         pt_device,        /* type of device:               */
                                          /* (i.e. HDLC controller type)   */
                                          /* ICC (ISAC), HSCC or HSCX      */
                        pt_Lay1id,        /* adapted layer 1 device ID:    */
                                          /* SBC_LAY1 (= SBC in ISAC-S)    */
                                          /* IBC_LAY1, IEC_LAY1, ...       */
                        pt_Codec,         /* adapted CODEC                 */
                        pt_op_mode,       /* operation mode of the HDLC    */
                                          /* controller (AUTOMODE, ..)     */
						pt_state;         /* device status                 */

   uchar                pt_pei,           /* PEI value                     */
                        pt_sld_access,    /* channel assignment at SLD     */ 
                        pt_ModulMode;     /* current mode:                 */
                                          /* TE, NTs/LT-S                  */

   uchar			FAR *pt_tx_start;     /* tx start pointer              */
   uchar			FAR	*pt_tx_curr;      /* tx current pointer            */
   uchar			FAR	*pt_rx_start;     /* rx start pointer              */
   uchar      		FAR	*pt_rx_curr;      /* rx current pointer            */
   unsigned int         pt_tx_cnt,        /* transmit byte count           */
						pt_rx_cnt;        /* receive byte count            */
   unsigned char		pt_rx_offset;     /* rx offset to be added to the  */
										  /* buffer offset field           */
   uchar                pt_rx_frame,      /* type of received frame        */
						pt_tx_frame,      /* type of sent frame            */
						pt_rec_state,     /* contains receive status       */
										  /*   of the HDLC controller      */
						pt_CI_rec,        /* received CI code (L1 device   */
										  /*  status if one is adapted)    */

						pt_tim_mode;   /* timer value for auto-mode        */

									   /* store timeslot assignment        */
									   /* only HSCX                        */
   unsigned int         pt_txass_slot,
						pt_txass_size,
						pt_rxass_slot,
						pt_rxass_size;


									   /* the following structure          */
									   /* elements hold the addresses      */
									   /* (pointers) to the device         */
									   /* registers                        */
   IO_PORT              pt_r_fifo;
   IO_PORT              pt_r_ista;
   IO_PORT              pt_r_mask;
   VOLATILE IO_PORT     pt_r_star;	   /* for While loop checking CEC bit  */
   IO_PORT              pt_r_cmdr;
   IO_PORT              pt_r_mode;
   IO_PORT              pt_r_timr;
   IO_PORT              pt_r_exir;
   IO_PORT              pt_r_xad1;
   IO_PORT              pt_r_xad2;
   IO_PORT              pt_r_rsta;
   IO_PORT              pt_r_sap1;     /* = RAH1 in HSCC and HSCX 	       */
   IO_PORT              pt_r_sap2;     /* = RAH2                   		   */
   IO_PORT              pt_r_tei1;     /* = RAL1                    	   */
   IO_PORT              pt_r_tei2;     /* = RAL2                           */
   IO_PORT              pt_r_rhcr;
									   /* receive byte count register,     */
									   /* only ICC Ax and HSCC             */
   IO_PORT              pt_r_rfbc;

									   /* registers to control the inter-  */
									   /* faces (IOM, SLD, SSI) of an ICC  */
									   /* or ISAC-S(/P)                    */
   IO_PORT              pt_r_spcr;
   IO_PORT              pt_r_cixr;     /* Command response register in ICC */
									   /* and ISAC, in versions B CIX0     */
   IO_PORT              pt_r_stcr;
   IO_PORT              pt_r_sfcr;
   IO_PORT              pt_r_sscx;
   IO_PORT              pt_r_monr;     /* Monitor channel register in ICC  */
									   /* and ISAC, in versions B MOX0     */
   IO_PORT              pt_r_adfr;     /* add. feature register in ICC     */
									   /* and ISAC, in versions B ADF1     */

									   /* special registers of the HSCC    */
   IO_PORT              pt_r_bgr;
   IO_PORT              pt_r_tcr;
   IO_PORT              pt_r_ccr;

									   /* receive byte count registers in  */
									   /* HSCX and ICC Bx                  */
   IO_PORT              pt_r_rbch;
   IO_PORT              pt_r_rbcl;

									   /* special registers in HSCX        */
   IO_PORT              pt_r_xbcl;
   IO_PORT              pt_r_ccr2;
   IO_PORT              pt_r_xbch;
   IO_PORT              pt_r_rlcr;
   IO_PORT              pt_r_ccr1;

									   /* registers for timeslot assign-   */
									   /* ment (e.g. HSCX)                 */
   IO_PORT              pt_r_tsar;
   IO_PORT              pt_r_tsax;
   IO_PORT              pt_r_xccr;
   IO_PORT              pt_r_rccr;

									   /* additional registers of ICC B    */
									   /*    IOM2 mode                     */
   IO_PORT              pt_r_adf2;     /* add. feature register 2          */
   IO_PORT              pt_r_mocr;     /* monitor control (w), status (r)  */
   IO_PORT              pt_r_mox1;     /* MOX1 (w)  MOR1 (r) registers     */
   IO_PORT              pt_r_cix1;     /* CIX1 (w)  CIR1 (r) registers     */


		/* OMNITEL */

   struct peitab 	FAR *a_peitab;	   /* Link to the other HSCX peitab */
   it_mask_t			it_mask;	   /* IT mask */

#	if PH_B_STREAM == ON
		uchar					stream_flag;				/* Streaming flag : TRUE or FALSE */
		uchar					stream_mode;				/* Streaming mode */

		struct ph_b_stream	FAR *p_ph_b_stream;				/* streaming cell pointer */
		uchar					stream_x_ph_stream;			/* index of the channel in the stream cell */

		struct block_header	FAR *stream_rx_p_first_block;	/* RX first block pointer */
		uchar					stream_rx_block_nb;			/* number of RX blocks */
		ushort					stream_rx_block_size;		/* RX block size */
		struct block_header	FAR *p_stream_rx_current_block;	/* current RX block pointer */
		uchar				FAR *p_stream_rx_current_data;	/* current RX data pointer in the current block */
		ushort					stream_rx_data_size;		/* current RX data size */
		uchar                	stream_rx_block_retransmitted; /* ON if a received block has been retransmitted */

		ushort					stream_tx_block_size;		/* TX block size */
		uchar				FAR *p_stream_tx_current_data;	/* current TX data pointer in the current block */
		ushort					stream_tx_data_size;		/* current TX data size */

		uchar					stream_tx_fifo_x_first;		/* Current TX FIFO index to first */
		signed char				stream_tx_fifo_size;		/* Current TX FIFO size (signed) */
		uchar					stream_tx_fifo_started;		/* TX FIFO started (filled with a sufficient number of blocks) */

		struct stream_tx_fifo {								/* TX FIFO array */
			uchar			FAR *p_block;					/* Tx bloc address */
			ushort		 		bloc_size;					/* Tx block data size */
		} stream_tx_fifo [STREAM_TX_FIFO_SIZE];

#		if PH_B_V14 == ON
			struct v14_ctx	 	v14_ctx;					/* V.14 context */
#		endif

#		if PH_B_V110 == ON
			struct v110_ctx	 	v110_ctx;					/* V.110 context */
#		endif


#	endif

		uchar					chani;						/* Channel Id */
};

typedef struct peitab PEITAB;


/*EOF*/
