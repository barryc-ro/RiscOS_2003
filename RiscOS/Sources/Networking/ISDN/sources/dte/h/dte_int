
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - dte_int.h
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		- contains all DTE_INT interface declarations and definitions.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    TR29-PACK                                        |*/
/*|    DTE_INT Entity                                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef	DTE_INT
#define DTE_INT

#include	"dte_par.h"

	/* Processing of obsolete names */

#ifndef DTE_DATA_RELAY
#	define	DTE_DATA_RELAY		DTE_DATA_XPT
#endif


	/* Setting of defaults */

#ifndef DTE_RESET_CONFIG
#	define	DTE_RESET_CONFIG	RESET_CONFIG	/* Use global option */
#endif

#ifndef	DTE_ASYN_TO_PH
#	define	DTE_ASYN_TO_PH		OFF
#endif
#ifndef	DTE_EXT_CNF_USER
#	define	DTE_EXT_CNF_USER	OFF
#endif

#if	((DTE_COMM_PORT_SYNC == OFF) && (DTE_V14 == OFF) && (DTE_V110 == OFF))
#	undef	DTE_MX_COMM_PORT
#	define	DTE_MX_COMM_PORT	0
#else
#	if DTE_MX_COMM_PORT == 0
#		undef	DTE_MX_COMM_PORT
#		define	DTE_MX_COMM_PORT	1
#	endif
#endif
#if ((DTE_COMM_PORT_SYNC == ON) || (DTE_V14 == ON) || (DTE_V110 == ON))
#	define	DTE_USE_CP					ON
#else
#	define	DTE_USE_CP						OFF
#endif


#ifndef	DTE_MX_ASS_NA_PER_CH
#	define	DTE_MX_ASS_NA_PER_CH			1
#endif

#ifndef	DTE_MX_CFG_MX_OUTGOING_SERVICES
#	define	DTE_MX_CFG_MX_OUTGOING_SERVICES 1
#endif

#if	DTE_DIR == OFF
#	undef	DTE_MX_DIR_ENTRY
#	undef	DTE_MX_DIR_DS_SIZE
#	define	DTE_MX_DIR_ENTRY	0
#	define	DTE_MX_DIR_DS_SIZE	0
#endif

#ifndef DTE_MX_EXT_AT_PREFIX_SIZE
#	define		DTE_MX_EXT_AT_PREFIX_SIZE 	1
#endif
#ifndef	DTE_MX_CFG_EXT_AT
#	define		DTE_MX_CFG_EXT_AT			1
#endif

#ifndef DTE_MX_CFG_SLOT_ENTRY
#	ifdef DTE_MX_SLOT_ENTRY
#		define	DTE_MX_CFG_SLOT_ENTRY	DTE_MX_SLOT_ENTRY	/* old name : DTE_MX_SLOT_ENTRY */
#	else
#		define	DTE_MX_CFG_SLOT_ENTRY	1
#	endif
#endif

#ifndef	DTE_MX_SLOT_STR_SIZE
#	define	DTE_MX_SLOT_STR_SIZE	0
#endif
#ifndef	DTE_MX_TIME_STR_SIZE
#	define	DTE_MX_TIME_STR_SIZE	25
#endif

#ifndef	DTE_ISDN_PASSWORD_SIZE
#	define	DTE_ISDN_PASSWORD_SIZE	32
#endif
#ifndef	DTE_MX_REMOTE_CALLERS
#	define		DTE_MX_REMOTE_CALLERS	8
#endif
#ifndef	DTE_MX_REMOTE_CALLERS_LISTS
#	define		DTE_MX_REMOTE_CALLERS_LISTS	2
#endif

#ifndef	DTE_SIMPLE_CHANNEL_ADDRESSING
#	define		DTE_SIMPLE_CHANNEL_ADDRESSING		OFF
#endif
#if	DTE_SIMPLE_CHANNEL_ADDRESSING == OFF
#	undef		DTE_SCA_ISDN_ADDR_SIZE
#	define		DTE_SCA_ISDN_ADDR_SIZE			0
#	undef		DTE_SCA_ISDN_SUB_ADDR_SIZE
#	define		DTE_SCA_ISDN_SUB_ADDR_SIZE		0
#	undef		DTE_SCA_UUI_SIZE
#	define		DTE_SCA_UUI_SIZE				0
#endif

#ifndef	DTE_CHECK_ISDN_ADDR_SIZE
#	define	DTE_CHECK_ISDN_ADDR_SIZE		DTE_ISDN_ADDR_SIZE
#endif
#if	DTE_CHECK_ISDN_ADDR_SIZE > DTE_ISDN_ADDR_SIZE
#	undef	DTE_CHECK_ISDN_ADDR_SIZE
#	define	DTE_CHECK_ISDN_ADDR_SIZE		DTE_ISDN_ADDR_SIZE
#endif

#ifndef	DTE_CHECK_ISDN_SUB_ADDR_SIZE
#	define	DTE_CHECK_ISDN_SUB_ADDR_SIZE	DTE_ISDN_SUB_ADDR_SIZE
#endif
#if	DTE_CHECK_ISDN_SUB_ADDR_SIZE > DTE_ISDN_SUB_ADDR_SIZE
#	undef	DTE_CHECK_ISDN_SUB_ADDR_SIZE
#	define	DTE_CHECK_ISDN_SUB_ADDR_SIZE	DTE_ISDN_SUB_ADDR_SIZE
#endif

#ifndef	DTE_SCA_ISDN_ADDR_SIZE
#	define	DTE_SCA_ISDN_ADDR_SIZE			DTE_ISDN_ADDR_SIZE
#endif
#if	DTE_SCA_ISDN_ADDR_SIZE > DTE_ISDN_ADDR_SIZE
#	undef	DTE_SCA_ISDN_ADDR_SIZE
#	define	DTE_SCA_ISDN_ADDR_SIZE			DTE_ISDN_ADDR_SIZE
#endif

#ifndef	DTE_SCA_ISDN_SUB_ADDR_SIZE
#	define	DTE_SCA_ISDN_SUB_ADDR_SIZE		DTE_ISDN_SUB_ADDR_SIZE
#endif
#if	DTE_SCA_ISDN_SUB_ADDR_SIZE > DTE_ISDN_SUB_ADDR_SIZE
#	undef	DTE_SCA_ISDN_SUB_ADDR_SIZE
#	define	DTE_SCA_ISDN_SUB_ADDR_SIZE		DTE_ISDN_SUB_ADDR_SIZE
#endif

#ifndef	DTE_SCA_UUI_SIZE
#	define	DTE_SCA_UUI_SIZE				0
#endif

#ifndef	DTE_MX_PAD_STRING_SIZE
#	define		DTE_MX_PAD_STRING_SIZE		8
#endif

#ifndef	DTE_CH_NAME_SIZE
#	define		DTE_CH_NAME_SIZE			0
#endif

#define		DTE_MX_CALL		(DTE_MX_CALL_PER_CH * DTE_MX_CH)

#ifndef	DTE_MX_CFG_DTE
#	define	DTE_MX_CFG_DTE			DTE_MX_DTE
#endif
#ifndef	DTE_MX_CFG_COMM_PORT
#	define	DTE_MX_CFG_COMM_PORT	DTE_MX_COMM_PORT
#endif
#ifndef	DTE_MX_CFG_NA
#	define	DTE_MX_CFG_NA			DTE_MX_NA
#endif
#ifndef	DTE_MX_CFG_CH
#	define	DTE_MX_CFG_CH			DTE_MX_CH
#endif
#ifndef	DTE_MX_2_CFG_CH
#	define	DTE_MX_2_CFG_CH			1
#endif
#ifndef	DTE_MX_CFG_PAD_STRING_SIZE
#	define	DTE_MX_CFG_PAD_STRING_SIZE	DTE_MX_PAD_STRING_SIZE
#endif
#if DTE_MX_CFG_PAD_STRING_SIZE	> DTE_MX_PAD_STRING_SIZE
#	undef	DTE_MX_CFG_PAD_STRING_SIZE
#	define	DTE_MX_CFG_PAD_STRING_SIZE	DTE_MX_PAD_STRING_SIZE
#endif

#ifndef	dte_user_call_id_t
#	define	dte_user_call_id_t	uchar
#endif
#ifndef	dte_call_ix_t
#	define	dte_call_ix_t		short		/* call index, must be signed */
#endif

#define	DTE_NB_PAD_PAR				22	/* Number of CCITT PAD parameters */
#define	DTE_NB_SUPP_PAD_PAR			 1	/* Number of supplementary PAD parameters */

#include	"pdte_int.h"

/*---------------------------------------------------------------------------
 *		General constants
 *--------------------------------------------------------------------------*/
#define		DTE_MAX_UCHAR		((uchar)(~0))	/* max value of uchar */
#define		DTE_MAX_USHORT		((ushort)(~0))	/* max value of ushort */

/*---------------------------------------------------------------------------
 *			PRIMITIVE CODES GENERAL DESCRIPTION
 *--------------------------------------------------------------------------*/

#define		DTE_INT_DA_RQ			'A'	/* data to transmit from DTE	*/
#define		DTE_INT_DA_RS			'B'	/* transmitted data acknowledgement */
#define		DTE_INT_SIGNAL_RQ   	'C' /* signal to transmit from DTE 	*/
#define 	DTE_INT_TIMER_START_RQ	'D'	/* timer start request 			*/
#define 	DTE_INT_TIMER_STOP_RQ	'E'	/* timer stop request 			*/
#define		DTE_INT_JN_DA_RQ		'F'	/* data to transmit from synchronous junction */
#define		DTE_INT_SETPARM_RQ		'P' /* set DTE_INT parameters */

#define		DTE_INT_DA_IN			'a' /* data to send by handler indication */
#define		DTE_INT_SETPARM_IN		'p' /* set Physical DTE parameters */
#define		DTE_INT_SETPARM_CO		'q' /* set DTE_INT parameters confirmation */
#define		DTE_INT_SIGNAL_IN   	'c' /* signal to transmit to DTE 	*/
#define		DTE_INT_MODE_IN			'm' /* mode change indication */
										/* inf0	: new handler mode to select */
										/* inf1 : reserved for PDTE use */
#define		DTE_INT_LINE_IN			'l' /* line speed change indication */
										/* inf0 : new speed to select */
										/* inf1 : reserved for PDTE use */
#define		DTE_INT_PH_R_ACT_IN   	'1' /* PH_R simulation, DTR on */
#define		DTE_INT_PH_R_DEA_IN   	'0' /* PH_R simulation, DTR off */

#define		DTE_INT_INIT_RQ			'I' /* reinitialize asynchronous junction */
										/* nai: junction id. sapi: SAPI_NIL. conn_id: ADD_NIL	*/
										/* may be sent by any 'user' entity, including SM */

#define		DTE_INT_OUTPUT_RQ		'O'	/* output request */
										/* nai: junction id. sapi: SAPI_NIL. conn_id: ADD_NIL */
										/* may be sent by any 'user' entity */
			/*
			 *	inf0: indicates processing to perform on the current AT
			 *		  command (if one is being executed)
			 *		  OK:  terminate AT command, ok
			 *			   "OK" will be displayed if the command is the last
			 *				of the command line. Else the following AT
			 *				command of the line will be processed.
			 *		  NOK: terminate AT command, error
			 *			   "ERROR" will be displayed. The following AT
			 *			 	commands of the line are ignored.
			 *		  STOP: terminate AT command, error
			 *			    the argument string will be displayed. The
			 *				following AT commands of the line are ignored.
			 *		  CONTINUE: do not terminate AT command, do not change
			 *				AT interpreter state.
			 *	p_buffer : address of a buffer containing the string to
			 *		  display. if P_NIL, no string is displayed (however
			 *		  processing is performed on the AT command)
			 */

/*---------------------------------------------------------------------------
 *			Primitives for message interface, primitives codes
 *---------------------------------------------------------------------------
 *	For all primitives, addressing scheme (nai, sapi, conn_id) is :
 *		nai		is the (AT) junction id
 *		sapi	is the DTE channel id
 *		conn_id	is ADD_NIL
 *	Note: for DTE_INT_ASSIGN_RQ, sapi may be SAPI_NIL, meaning: all DTE
 *		  channels associated to the junction.
 *-------------------------------------------------------------------------*/
#define	DTE_INT_ASSIGN_RQ			'X'	/* DTE_INT_ASSIGN_RQ: 	Assignment request */
#define	DTE_INT_ASSIGN_CO			'x'	/* DTE_INT_ASSIGN_CO: 	Assignment confirm */
#define	DTE_INT_REMOVAL_RQ			'Y'	/* DTE_INT_REMOVAL_RQ: 	Removal request */
#define	DTE_INT_REMOVAL_CO			'y'	/* DTE_INT_REMOVAL_CO: 	Removal confirm */
										/* DTE_INT_DA_RQ:		Data request */
										/* DTE_INT_DA_IN:		Data indication */
#define	DTE_INT_AT_RQ				'Z'	/* DTE_INT_AT_RQ: 		AT command request */
#define	DTE_INT_AT_IN				'z'	/* DTE_INT_AT_IN: 		AT message indication */
#define	DTE_INT_BUSY_RQ				'('	/* DTE_INT_BUSY_RQ: 	Busy request */
#define	DTE_INT_CLEAR_BUSY_RQ		'['	/* DTE_INT_CLEAR_BUSY_RQ: Clear busy request */
#define	DTE_INT_BUSY_IN				')'	/* DTE_INT_BUSY_IN: 	Busy indication */
#define	DTE_INT_CLEAR_BUSY_IN		']'	/* DTE_INT_CLEAR_BUSY_IN: Clear busy indication */
#define	DTE_INT_SYNC_RQ				'+'	/* DTE_INT_SYNC_RQ: 	Synchronization request */
#define	DTE_INT_SYNC_CO				'-'	/* DTE_INT_SYNC_CO: 	Synchronization confirmation */
#define	DTE_INT_SYNC_IN				's'	/* DTE_INT_SYNC_IN: 	Synchronization indication */
#define	DTE_INT_SYNC_RS				'S'	/* DTE_INT_SYNC_RS: 	Synchronization response */

struct dte_int_assign_removal {		/* DTE_INT_ASSIGN_RQ, DTE_INT_ASSIGN_CO, DTE_INT_REMOVAL_RQ, DTE_INT_REMOVAL_CO */
	struct confirm	confirm;        /* xxx_CO: confirmation */
									/* 'cause' codes : */
#	define	DI_ASS_CAUSE_INVALID_REFERENCES		0x11	/* invalid references (nai, sapi) */
#	define	DI_ASS_CAUSE_INVALID_FC_ENABLE		0x12	/* Invalid value for the flow control 'enable' field */
#	define	DI_ASS_CAUSE_INVALID_FC_MARKS		0x13	/* Invalid value for the flow control low mark/high mark fields */
#	define	DI_ASS_CAUSE_INVALID_DATA_SIZE		0x14	/* Invalid value for the minimum data offset or maximum data size fields */

	struct {						/* flow control substructure */
		uchar	enable;				/* DTE_INT_ASSIGN_RQ: ON: enable use of this substructure. */
									/*	OFF: disable, equivalent to high_mark = low_mark = sync_window = 0 */
		short	high_mark;			/* DTE_INT_ASSIGN_RQ: flow control high mark */
									/* 	when the queue length gets greater than 'high_mark', transmission to user stops */
		short	low_mark;			/* DTE_INT_ASSIGN_RQ: flow control low mark */
									/* 	when the queue length reaches 'low_mark', transmission to user resumes */
		short	sync_window;		/* DTE_INT_ASSIGN_RQ: number of data indications sent between to DTE_INT_SYNC_IN */
									/* 	0: no DTE_INT_SYNC_IN will be sent */
		short	min_data_offset;	/* DTE_INT_ASSIGN_RQ: minimum data offset for data sent by DTE_INT to user entity, for this DTE channel */
		short	max_data_size;		/* DTE_INT_ASSIGN_RQ: maximum data size for data sent by DTE_INT to user entity, for this DTE channel */
									/* 	0: no limitation */
	} fc;

	struct {						/* DTE_INT_ASSIGN_CO only : AT interpreter parameters */
		short	max_cmd_length;		/* DTE_INT_ASSIGN_CO: maximum length of an AT command, including terminating \r */
		uchar	q;					/* DTE_INT_ASSIGN_CO: Q parameter value. 0: normal. 1: silent. 2: no incoming calls messages */
		uchar	v;					/* DTE_INT_ASSIGN_CO: V parameter value. 0: numeric form. 1: alphabetic form */
		uchar	s003;				/* DTE_INT_ASSIGN_CO: S3 (carriage return) register value */
		uchar	s004;				/* DTE_INT_ASSIGN_CO: S4 (line feed) register value */
		uchar	s005;				/* DTE_INT_ASSIGN_CO: S5 (backspace) register value */
	}				at;
	struct {						/* DTE_INT_ASSIGN_CO only : data transfer parameters */
		ushort	offset_min;			/* DTE_INT_ASSIGN_CO: minimum data offset for buffers associated to DTE_INT_DA_RQ */
		ushort	size_max;			/* DTE_INT_ASSIGN_CO: maximum data size for buffers associated to DTE_INT_DA_RQ */
	}				data;
};

#define	Dte_int_ass_rem_ret_code		(((struct dte_int_assign_removal *)p_data)->confirm.return_code)
#define	Dte_int_ass_rem_cause			(((struct dte_int_assign_removal *)p_data)->confirm.cause)
#define	Dte_int_ass_rem_diagnostic		(((struct dte_int_assign_removal *)p_data)->confirm.diagnostic)

#define	Dte_int_ass_rem_fc_enable		(((struct dte_int_assign_removal *)p_data)->fc.enable)
#define	Dte_int_ass_rem_fc_high_mark	(((struct dte_int_assign_removal *)p_data)->fc.high_mark)
#define	Dte_int_ass_rem_fc_low_mark		(((struct dte_int_assign_removal *)p_data)->fc.low_mark)
#define	Dte_int_ass_rem_fc_sync_window	(((struct dte_int_assign_removal *)p_data)->fc.sync_window)
#define	Dte_int_ass_rem_fc_min_data_offset	\
										(((struct dte_int_assign_removal *)p_data)->fc.min_data_offset)
#define	Dte_int_ass_rem_fc_max_data_size	\
										(((struct dte_int_assign_removal *)p_data)->fc.max_data_size)

#define	Dte_int_ass_rem_at_max_cmd_length	\
										(((struct dte_int_assign_removal *)p_data)->at.max_cmd_length)
#define	Dte_int_ass_rem_at_q			(((struct dte_int_assign_removal *)p_data)->at.q)
#define	Dte_int_ass_rem_at_v			(((struct dte_int_assign_removal *)p_data)->at.v)
#define	Dte_int_ass_rem_at_s003			(((struct dte_int_assign_removal *)p_data)->at.s003)
#define	Dte_int_ass_rem_at_s004			(((struct dte_int_assign_removal *)p_data)->at.s004)
#define	Dte_int_ass_rem_at_s005			(((struct dte_int_assign_removal *)p_data)->at.s005)

#define	Dte_int_ass_rem_data_offset_min	(((struct dte_int_assign_removal *)p_data)->data.offset_min)
#define	Dte_int_ass_rem_data_size_max	(((struct dte_int_assign_removal *)p_data)->data.size_max)

#define	Dte_int_ass_rem_size			  (sizeof (struct dte_int_assign_removal))


/*---------------------------------------------------------------------------
 *			Primitives for transparent mode, primitives codes
 *---------------------------------------------------------------------------
 *	For all primitives, addressing scheme (nai, sapi, conn_id) is :
 *		nai		is the (AT) junction id
 *		sapi	is SAPI_NIL, conn_id is ADD_NIL
 *	DTE_MESSAGE_INTERFACE compilation flag shall be set to ON.
 *-------------------------------------------------------------------------*/
#define		DTE_INT_SET_TRANSP_RQ		'T'	/* set transparent mode (establishes a path PDTE <-> user entity, instead of PDTE <-> ENT_DTE_INT */
											/* inf0: new PDTE mode (DTE_ATREAD, DTE_PLUSFMT_SND, etc.) */
											/* if 0 (recommended), no change in PDTE mode is performed */
#define		DTE_INT_CLEAR_TRANSP_RQ		'U'	/* clear transparent mode */
											/* inf0: new PDTE mode (DTE_ATREAD, DTE_PLUSFMT_SND, etc.) */
											/* if 0 (recommended), no change in PDTE mode is performed */
#define		DTE_INT_PORTS_IN			'v'	/* set junction signals (ports) in tranaparent mode */
struct 		dte_int_ports_in_args  {
	uchar		cts_valid;					/* ON: following field is valid. OFF: following field has to be ignored */
	uchar		cts_value;					/* new CTS value (ON or OFF) */
	uchar		dsr_valid;					/* ON: following field is valid. OFF: following field has to be ignored */
	uchar		dsr_value;					/* new DSR value (ON or OFF) */
	uchar		cd_valid;					/* ON: following field is valid. OFF: following field has to be ignored */
	uchar		cd_value;					/* new CD value (ON or OFF) */
	uchar		ri_valid;					/* ON: following field is valid. OFF: following field has to be ignored */
	uchar		ri_value;					/* new RI value (ON or OFF) */
	uchar		aux_valid;					/* ON: following field is valid. OFF: following field has to be ignored */
	uchar		aux_value;					/* new AUX (auxiliary, application specific) value (ON or OFF) */
};
#	define	Dte_int_ports_in_cts_valid		(((struct dte_int_ports_in_args FAR *)p_data)->cts_valid)
#	define	Dte_int_ports_in_cts_value		(((struct dte_int_ports_in_args FAR *)p_data)->cts_value)
#	define	Dte_int_ports_in_dsr_valid		(((struct dte_int_ports_in_args FAR *)p_data)->dsr_valid)
#	define	Dte_int_ports_in_dsr_value		(((struct dte_int_ports_in_args FAR *)p_data)->dsr_value)
#	define	Dte_int_ports_in_cd_valid		(((struct dte_int_ports_in_args FAR *)p_data)->cd_valid)
#	define	Dte_int_ports_in_cd_value		(((struct dte_int_ports_in_args FAR *)p_data)->cd_value)
#	define	Dte_int_ports_in_ri_valid		(((struct dte_int_ports_in_args FAR *)p_data)->ri_valid)
#	define	Dte_int_ports_in_ri_value		(((struct dte_int_ports_in_args FAR *)p_data)->ri_value)
#	define	Dte_int_ports_in_aux_valid		(((struct dte_int_ports_in_args FAR *)p_data)->aux_valid)
#	define	Dte_int_ports_in_aux_value		(((struct dte_int_ports_in_args FAR *)p_data)->aux_value)

#	define	Dte_int_ports_in_size			(sizeof (struct dte_int_ports_in_args))


/*---------------------------------------------------------------------------
 *			TIMER EXPIRATION PRIMITIVE CODES
 *-------------------------------------------------------------------------*/

#define		TI_DTR_POLLING	'D'		/*	synchronous port DTR polling */
#define		TI_PHCTO		'C'		/*	TR-29 phase C timeout (last page) */

#if DTE_SM_CFG_UPDATE == ON
#	define	TI_POST_SAVE	'P'		/*	post SM parameter save timer */
#endif

#if DTE_USE_CP == ON
#	define	TI_S25_SYNC		'S'		/*	S25 synchronous DTR off to on watchdog timer */
#endif

#define		TI_BREAK		'1'		/*  break duration timer 	*/
#define		TI_S25			'5'		/*	S25 DTR tracking timer */
#define		TI_S26			'6'		/*	S26 RTS tracking timer */
#define		TI_S7			'7'		/*	S7 connection establishment timer */
#define		TI_CONNECT		'A'		/*	'CONNECT' timer */
#define		TI_S117			'R'		/*	S117 'between RING' timer */
#if DTE_PAD_V120_COMPRESSION == ON
#	define	TI_ENC_FLUSH	'E'		/*	Encoder flush timer */
#	define	TI_DEC_FLUSH	'G'		/*	Decoder flush timer */
#endif
#if DTE_DIR_LIST == ON
#	define	TI_CALL_LIST	'B'		/*	Between-calls timer */
#endif

/*---------------------------------------------------------------------------
 *			PRIMITIVES DETAILED FORMAT
 *--------------------------------------------------------------------------*/
	/*-----------------------------------------------------------------------
	 *	SAPs for DTE_INT
	 *	DTE_INT_SAPI_JN		: SAP for accessing DTE_INT from (PDTE) interrupt
	 *						  routine
	 *	SAPI_NIL			: other cases.
	 *----------------------------------------------------------------------*/
#define	DTE_INT_SAPI_JN		0			/* must not be equal to a DTE channel number */

	/*-----------------------------------------------------------------------
	 *	DTE_INT_DA_RQ, DTE_INT_DA_RS : Data request, data indication
	 *
	 *	inf0	: ON if end of stream, else OFF
	 *----------------------------------------------------------------------*/
#	define	Dte_int_da_rqin_size			INF_SIZE

	/*-----------------------------------------------------------------------
	 *	DTE_INT_DATA_RS : Data response
	 *----------------------------------------------------------------------*/
#	define	Dte_int_da_rs_size				(0)

	/* Set and test end of stream in DTE_INT_DA_xx primitives */
	/*--------------------------------------------------------*/

#define	S_set_end_of_stream()		(S_msg_inf0 = ON)
#define	S_reset_end_of_stream()		(S_msg_inf0 = OFF)
#define	R_set_end_of_stream()		(R_msg_inf0 = ON)
#define	R_reset_end_of_stream()		(R_msg_inf0 = OFF)

#define	R_is_end_of_stream()		((R_msg_inf0 == ON) ? ON : OFF)
#define	S_is_end_of_stream()		((S_msg_inf0 == ON) ? ON : OFF)


#define	R_set_closed_on_idle()		(R_msg_inf1 = ON)
#define	S_set_closed_on_idle()		(S_msg_inf1 = ON)
#define	R_reset_closed_on_idle()	(R_msg_inf1 = OFF)
#define	S_reset_closed_on_idle()	(S_msg_inf1 = OFF)
#define	R_is_closed_on_idle()		((R_msg_inf1 == ON) ? ON : OFF)
#define	S_is_closed_on_idle()		((S_msg_inf1 == ON) ? ON : OFF)

	/*-----------------------------------------------------------------------
	 *	DTE_INT_SIGNAL_RQ, DTE_INT_SIGNAL_IN : Signal request, indication
	 *----------------------------------------------------------------------*/
	struct dte_int_signal_rqin_args {
		uchar	signal_name;		/* detected signal name (DI_SIG_xxx) */
		uchar	reserved;			/* reserved, for filling alignment hole */
		union {
			uchar	character;			/* detected escape character (for DI_SIG_ESCAPE) */
			uchar	spd;				/* detected junction speed */
		} u;
		ushort	error_status;		/* symbolic error status (for DI_SIG_ERROR) */
		ushort	hw_status;			/* hardware error status (for DI_SIG_ERROR) */
	};

#	define	Dte_int_signal_rq_signal_name	(((struct dte_int_signal_rqin_args FAR *)p_data)->signal_name)
#	define	Dte_int_signal_rq_speed			(((struct dte_int_signal_rqin_args FAR *)p_data)->u.spd)
#	define	Dte_int_signal_rq_character		(((struct dte_int_signal_rqin_args FAR *)p_data)->u.character)
#	define	Dte_int_signal_rq_error_status	(((struct dte_int_signal_rqin_args FAR *)p_data)->error_status)
#	define	Dte_int_signal_rq_hw_status		(((struct dte_int_signal_rqin_args FAR *)p_data)->hw_status)
#	define	Dte_int_signal_rq_reserved		(((struct dte_int_signal_rqin_args FAR *)p_data)->reserved)
#	define	Dte_int_signal_rq_size			(sizeof (struct dte_int_signal_rqin_args))

#	define	Dte_int_signal_in_signal_name	Dte_int_signal_rq_signal_name
#	define	Dte_int_signal_in_speed			Dte_int_signal_rq_speed
#	define	Dte_int_signal_in_character		Dte_int_signal_rq_character
#	define	Dte_int_signal_in_error_status	Dte_int_signal_rq_error_status
#	define	Dte_int_signal_in_hw_status		Dte_int_signal_rq_hw_status
#	define	Dte_int_signal_in_size			Dte_int_signal_rq_size


	/* Signal names */

#	define	DI_SIG_BREAK			'B'		/* Break detected */
#	define	DI_SIG_CANCEL			'C'		/* Cancel requested */
#	define	DI_SIG_DATA_RECEIVED	'D'		/* user data received */
#	define	DI_SIG_ESCAPE			'E'		/* Escape sequence detected */
#	define	DI_SIG_ERROR			'I'		/* Error at the physical interface */
#	define	DI_SIG_JUNCTION			'J'		/* Junction signal change detected */
#	define	DI_SIG_PAD_ABORT		'P'		/* PAD abort requested */
#	define	DI_SIG_RATE				'R'		/* Junction rate change */
#	define	DI_SIG_COMMAND_START	'S'		/* Command start detected */
#	define	DI_SIG_BUSY				'0'		/* busy requested */
#	define	DI_SIG_CLEAR_BUSY		'1'		/* clear busy requested */
#	define	DI_SIG_FIRST_COLUMN		'-'		/* Back in first column, input buffer empty */
#	define	DI_SIG_PLUS_PLUS_PLUS	'+'		/* +++ detected */

#	define	DI_SIG_CLEAR			DI_SIG_PLUS_PLUS_PLUS	/* Obsolete name, for compatibility */
#	define	DI_SIG_XOFF				DI_SIG_BUSY				/* Obsolete name, for compatibility */
#	define	DI_SIG_XON				DI_SIG_CLEAR_BUSY		/* Obsolete name, for compatibility */


	/* Symbolic status possible values (error status is a 'or' of these bits) */

#	define	DI_ERR_PARITY_ERROR			0x01	/* Parity error */
#	define	DI_ERR_FRAMING_ERROR		0x02	/* Framing error */

#	define	DI_ERR_OVERRUN_ERROR		0x04	/* Overrun error */

#	define	DI_ERR_OTHER_ERROR			0x08	/* Other fatal error */

#	define	DI_ERR_INTERFACE_RESET		0x80	/* Full reset of the DTE-DCE interface */
												/* For example, power down at the DTE */

	/*-----------------------------------------------------------------------
	 *	DTE_INT_TIMER_START_RQ : Start timer request
	 *	DTE_INT_TIMER_STOP_RQ  : Stop timer request
	 *----------------------------------------------------------------------*/
	struct dte_int_timer_rq_args {
		uchar 			id;			/* timer identifier index : TPOLLING_X...  */
		uchar 			reserved;	/* reserved, for filling alignment hole */
		ushort  		val;		/* value of timer in system ticks		 */
	};

#	define 	Dte_int_timer_rq_ti_id		(((struct dte_int_timer_rq_args FAR *)p_data)->id)
#	define 	Dte_int_timer_rq_ti_val		(((struct dte_int_timer_rq_args FAR *)p_data)->val)
#	define 	Dte_int_timer_rq_reserved	(((struct dte_int_timer_rq_args FAR *)p_data)->reserved)
#	define	Dte_int_timer_rq_size		(sizeof (struct dte_int_timer_rq_args))

	/*-----------------------------------------------------------------------
	 *	DTE_INT_AT_RQ :
	 *		[1] sent by DTE_INT to external entity:
	 *					Send AT command to external entity request
	 *					no argument, AT command line in buffer.
	 *					the buffer does NOT contain the initial 'AT', nor
	 *					the terminating '\r'.
	 *		[2] sent by a user entity to DTE_INT (message interface):
	 *					no argument, AT command line in buffer.
	 *					the buffer does contain the initial 'AT'.
	 *
	 *	DTE_INT_AT_IN : AT response or indication from external entity
	 *					x_dte_int_at_in_ret_code : return code
	 *						OK 		: terminate the AT command, normal case
	 *						NOK 	: terminate the AT command, error
	 *						CONTINUE: unsollicited, spontaneous message
	 *----------------------------------------------------------------------*/
#	define 	S_dte_int_at_in_ret_code	(S_msg_inf0)
#	define 	R_dte_int_at_in_ret_code	(R_msg_inf0)
#	define 	L_dte_int_at_in_ret_code	(L_msg_inf0)

/*--------------------------------------------------------------------------
 *		Directory entry codes
 *-------------------------------------------------------------------------*/
#define	dte_dir_id_t	short							/* Directory entry id : must be longer than an unsigned char */
#define	DTE_DIR_ID_NIL	((dte_dir_id_t)-1)				/* No directory entry */


/*---------------------------------------------------------------------------
 *		Configuration structures (SM_SET_CONFIG_RQ)
 *-------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------
 *		Substructure, for DTE channel configuration
 *-------------------------------------------------------------------------*/
	struct dte_ch_config {

		uchar   	ch_id;				/* DTE channel id (any positive value, except 0) */

		nai_t       nai;				/* 'nai_sig', default signalling nai */
										/* if 'associated nas' are used, this na must be present and enabled in the 'associated nas' table */
		uchar		jn_id;				/* associated DTE junction id */
		uchar		comm_port_id;		/* associated communication port id */
										/* DTE_COMM_PORT_ID_NIL if no associated communication port */

		uchar		service;	   		/* service offered to DTE by DTE_INT channel */
										/* DTE_USER_VOICE_SERVICE, DTE_USER_PAD_SERVICE, etc. */
		uchar		lock_service;		/* ON: service is fixed. OFF: service can be changed by AT command */
		uchar		disable;			/* ON: disable the DTE channel. OFF: enable the DTE channel (normal value) */
		uchar		and_k;				/* initial AT&K value (flow control options) [0..4] (3) */
										/* 0: no flow control, 2: XON/XOFF, 3: RTS/CTS */
		uchar		and_q;				/* initial AT&Q value (communications mode options) [0..6] (0) */
		uchar		and_d;				/* initial AT&D value (DTR options) [0..3] (0) */
		uchar		s25;				/* initial value of the S25 register (DTR delay) [0..255] (0) */
		uchar		and_r;				/* initial AT&R value (RTS/CTS options) [0..1] (0) */
		uchar		s26;				/* initial value of the S26 register (RTS/CTS delay) [0..255] (0) */
		uchar		and_s;				/* initial AT&S value (DSR options) [0..2] (0) */
		uchar		and_c;				/* initial AT&C value (CD options) [0..2] (0) */
		uchar		s7;					/* initial value of the S7 register (wait for carrier after dialing, in seconds) [0..255] (60) */
										/* suggested value : minimum 40 seconds, value required by Australian ISDN operator */
		uchar		s9;					/* initial value of the S9 register (carrier detect response time) [0..255] (0) */
		uchar		s10;				/* initial value of the S10 register (lost carrier delay) [0..255] (0) */

		uchar		nb_calls;			/* number of calls managed by the DTE channel [0..] */
		dte_user_call_id_t
					first_call_user_id;	/* user id of the first call associated to the DTE channel [1..] */

		uchar		nb_conns;			/* number of connections managed by the DTE channel, must be 1 */
		uchar		first_conn_id;		/* id of the first connection (in the network access) associated to the DTE channel [0..] */
										/* For a data modem DTE channel (service DTE_USER_MODEM_SERVICE), MUST be set to 0 */
										/* V.120: must be set to the corresponding V.120 DL CES */
		sapi_t		n_sapi;				/* Associated NSAP, for PAD on D-channel or leased line. Else set to SAPI_NIL */
										/* Used only for PAD incoming calls on D-channel or leased line */
		sapi_t		dl_sapi;			/* Associated DLSAP, for PAD on D-channel or leased line. Else set to SAPI_NIL */
										/* Used for PAD incoming calls on D-channel or leased line */
										/* Also used for V.120 addressing */
										/* V.120: must be set to the corresponding DL SAP (V.120, MLP).. */
		uchar		inc_priority;		/* channel priority, with respect to incoming calls */
										/* 0: highest priority, 254: lowest priority */
										/* 255: incoming calls are not accepted */
		uchar		mx_inc_calls;		/* maximum number of concurrent non idle incoming calls [0..] */
		uchar		inc_manual_answer;	/* ON if manual answer is possible */
		uchar		inc_auto_answer;	/* ON if automatic answer is possible */
		uchar		s0;					/* initial S0 value (number of rings before answering) */

		dte_call_ix_t	mx_out_calls;	/* maximum number of concurrent outgoing calls [0..] */
		dte_call_ix_t	mx_act_calls;	/* maximum number of concurrent non idle calls [0..] */
		dte_call_ix_t	mx_data_calls;	/* maximum number of concurrent data calls [0..] */
		dte_call_ix_t	mx_voice_calls;	/* maximum number of concurrent voice calls [0..] */
										/* Note: calls using 'Raw telephony' DTE service are 'data' calls, not 'voice' calls */
		uchar		t_p;				/* initial tone or pulse dialing method ('T' or 'P') */
		uchar		s6;					/* initial S6 value (wait before blind dialing) [0..255] (0) */
		uchar		s8;					/* initial S8 value (comma dial modifier duration) [0..255] (2) */
		uchar		s11;				/* initial S11 value (DTMF duration) [50..255] (50) */

		uchar		s30;				/* initial S30 value (inactivity timeout) [0..255] (0) */
		uchar		s36;				/* initial S36 value (negotiation failure treatement) [0..7] (7) */
		uchar		s37;				/* initial S37 value (desired DCE line speed) [0..9] (0) */
		uchar		s38;				/* initial S38 value (delay before forced hang up) [0..255] (0) */
		uchar		s48;				/* initial S48 value (negotiation selection) [0, 3, 7, 128] (7) */
		uchar		per_c;				/* initial %C value (data compression) [0..3] (0) */
										/* a value of 255 disables permanently data compression */
		uchar		phcto;				/* initial +PHCTO value (fax phase C timeout) [0..255] (30) */

		uchar		s18;				/* initial S18 value (test timer) [50..255] (0) */

		uchar		s112;				/* initial S112 value (format of extended calls messages) [0..3] (1) */
		uchar		x;					/* initial X value (call progress options) [0..4] (4) */
		uchar		w;					/* initial W value (negotiation message selection) [0..2] (0) */
		uchar		unused_s095;		/* NOW UNUSED. PLEASE SET TO 0. Formerly: initial S95 value. S95 value is now defined in the 'dte_config' substructure */
		uchar		hole_size;			/* size of the hole, for data to send to CF or PH [0..10] (5) */
		uchar		y;					/* initial Y value (long break disconnect) [0..1] (0) */
		uchar		s82;				/* initial S82 value (break signalling technique, V.42) [3, 7, 128] (3) */

		uchar		pad_autostart;		/* ON: autostart of the PAD. OFF: no autostart */
		nai_t		dc_nai;				/* associated NAI, for PAD with Data Compression */
										/* if not used, set to NAI_NIL */
		add_t		dc_stream_id;		/* associated stream id, for PAD with Data Compression */
		uchar		pad_out_prof_name [3];
										/* PAD  : outgoing profile (string of 2 ASCII characters + \0, e.g: "F "). */
										/* V.120: profile (string of 2 ASCII characters + \0, e.g: "F "). */
										/* if set to "", default profile is selected */
		uchar		pad_in_prof_name [3];
										/* PAD  : incoming profile (string of 2 ASCII characters + \0, e.g: "F "). */
										/* if set to "", default profile is selected */
										/* V.120: not used */

		uchar		route_mx_nb_buffer;	/* maximum number of buffers for the route. 0 : use default value */
		uchar 		pad_def_call_string [DTE_MX_CFG_PAD_STRING_SIZE+1];
										/* PAD: default PAD command string to use for establishing virtual circuit, without \r */
										/* Else "" */
		uchar		callers_list_id;	/* Callers list id (for incoming calls authentification) */
										/* Set to 0 if none */

		uchar		relay_mode;			/* PH_R relay mode : 0 or DTE_RELAY_FRAME: frame relay (one, or two aggregated B-channels) */
										/* DTE_RELAY_STREAM_HDLC: stream; HDLC only; DTE_RELAY_STREAM_TRANSPARENT: stream, transparent. */
#		define 		DTE_RELAY_FRAME					0
#		define 		DTE_RELAY_STREAM_HDLC			1
#		define 		DTE_RELAY_STREAM_TRANSPARENT	2
#		define 		DTE_RELAY_SYNC_V110				3
#		define 		DTE_RELAY_V120_BIT_TRANSPARENT	4
#		define 		DTE_RELAY_V120_HDLC				5
#		define 		DTE_RELAY_V14					6
#		define 		DTE_RELAY_ASYN_V110				7
#		define 		DTE_RELAY_DISABLED				0xFF

		uchar		rate;			   	/* DTE channel asynchronous junction rate (PDTE_RATE_xxx, see PDTE_INT.H)	*/
										/* 0: use associated junction default rate */
		struct {						/* SCA: Simple DTE channel addressing data */
										/* Use the 'Sca_init_a_isdn' or the 'Sca_init_a_x25' macros to initialize the structure */
			uchar	enable;					/* ON: enable the following fields. OFF : disable */
			uchar	loc_isdn_addr [DTE_SCA_ISDN_ADDR_SIZE + 1];
											/* local ISDN or X.25 address (D-channel or leased line) attached to the DTE channel */
											/* If "", no selection based upon called party ISDN number */
			uchar	loc_isdn_sub_addr [DTE_SCA_ISDN_SUB_ADDR_SIZE + 1];
											/* local ISDN subaddress attached to the DTE channel */
											/* If "", no selection based upon called party ISDN subaddress */
			uchar	loc_uui_data [DTE_SCA_UUI_SIZE + 1];
											/* UUI attached to DTE channel */
											/* If "", no selection based upon incoming call UUI */
			uchar	reserved;				/* Reserved (not used anymore) */
			uchar	addr_type;				/* Address type. 0 : any, ENT_CC: ISDN address, ENT_X25 : X.25 address */
		} sca;
											/* More PAD parameters, for PAD V2 */
		uchar		pad_out_serv_prof_name [3];
										/* PAD  : outgoing service profile (string of 2 ASCII characters + \0, e.g: "BP"). */
										/* V.120: service profile (string of 2 ASCII characters + \0, e.g: "BP"). */
										/* if set to "", default service profile is selected */
		uchar		pad_in_serv_prof_name [3];
										/* PAD  : incoming service profile (string of 2 ASCII characters + \0, e.g: "BP"). */
										/* V.120: not used */
										/* if set to "", default service profile is selected */
		uchar		litt_name [DTE_CH_NAME_SIZE + 1];
										/* DTE channel litterary name */

		add_t		def_data_chani;		/* default associated B channel (0: any, 1 : B1, 2: B2, etc.). */
		uchar		acu_profile;		/* ACU profile/service to use for outgoing and incoming calls. 0: use default value (defined by the DTE channel service) */
		uchar		ext_jn_id;			/* external junction identifier, for external entities processing external AT commands */
										/* 0: use DTE channel identifier */
		uchar		s116;				/* initial S116 value (+++ processing) [0..2] (2) */
		short		enc_dc_block_size;	/* (PAD/V.120 compression) Encoder block size. 0: default value. */
										/* For V.120, this size must be less than or equal to the length of the V.120 info field (default: 260) */
		short		v42b_dict_size;		/* (PAD/V.120 compression) (P1) V.42bis dictionary size. 0: default value. */
		short		v42b_str_size;		/* (PAD/V.120 compression) (P2) V.42bis dictionary depth. 0: default value. */
		uchar		s113;				/* initial S113 value (extended message format) */
		struct {                    	/* PAD or V.120 compression (encoding) parameters */
			timer_val_t	flush_timer_val;/* Encoder flush timer duration */
			uchar		mx_blocks;		/* Maximum number of blocks sent to encoder without flush */
			uchar		high_mark;		/* Encoder high mark */
			uchar		low_mark;		/* Encoder low mark */
			uchar		th_low_traffic;	/* Encoder traffic low threshold */
			timer_val_t	v42b_resp_timer_val; /* V.120 only : timer during which the responder waits for end of V.42bis negotiation. */
										/* 0: no V.42bis over V.120 negotiation */
		}			enc_parameters;
		struct {                    	/* PAD or V.120 compression (decoding) parameters */
			timer_val_t	flush_timer_val;/* Decoder flush timer duration */
			uchar		reserved;		/* Reserved */
			uchar		high_mark;		/* Decoder high mark */
			uchar		low_mark;		/* Decoder low mark */
			uchar		th_low_traffic;	/* Decode traffic low threshold */
			short		low_data_size;	/* Decoder low data size */
										/* A received block of encoded data smaller or equal to this size will be flushed immediately */
										/* 0: use default value */
			short		block_size;		/* Decoder block size. 0: default value (same as encoding block). */
										/* Suggested value : slightly smaller than the buffer data size */
		}			dec_parameters;
		uchar		s117;				/* initial S117 value (delay between successive RING messages). 0: 1 single RING */
		uchar		s115;				/* initial S115 value (miscellaneous non standard call processing). 0: default. */
		uchar		pad_par_23;			/* ON : generate X.25 M-bit for long PAD messages */
										/* OFF: X.25 M-bit is always off */
		uchar		and_g;				/* initial &G value (0: disable guard tone, 2: enable) */
		uchar		cc_service_list_id;	/* DTE_INT / Call Control correlation parameter. (0: none) */
		add_t		cce_conn_id;		/* CCE call identifier. 0 if no use of CCE (extended Call Control)  */
		struct {                    	/* Physical parameters (for 'physical V.110')*/
			uchar		user_rate;		/* Physical rate (for physical V.110) (PDTE_RATE_xxx, see PDTE_INT.H) */
			uchar		syn_asyn;		/* V.110/V.120: synchronous (ON), asynchronous (OFF) */
			uchar		data_nb;		/* Asyn V.110 : number of data bits: 5, 7 or 8 */
			uchar		stop_nb;		/* Asyn V.110 : number of stop bits: 0:1.5, 1:1, 2: 2 */
			uchar		parity;			/* Asyn V.110 : parity: PAR_PARITY_ODD, PAR_PARITY_EVEN or PAR_NO_PARITY */
		}			ph_parameters;
		uchar		ch_unique_id;		/* DTE channel unique (in the whole system) identifier */
										/* used in particular for computing the update ids */
		uchar		s118;				/* initial S118 (asynchronous frame format) value. 0: transparent. 2: PPP */
#		if ((DTE_ASYN_TO_PH == ON) || (DTE_FAX == ON))
		struct {        						/* Transmit queue parameters, in front of CF(fax)/PH/PH_B */
			uchar		to_ph_queue_high_mark;	/* 0: no flow control. High threshold before flow-controlling the DTE */
												/* WARNING: this field MUST be NON-ZERO for fax */
			uchar		to_ph_queue_low_mark;	/* low threshold before flow-releasing the DTE */
			uchar		sync_window;			/* max number of DA_RQ to send between two SYNC_RQ */
						/*
						 *	Suggested values are (3, 0, 3)
						 */
		} ph;
#		endif

		uchar		mnp4_disable;		/* ON: disable use of MNP-4. OFF: enable */
		dte_dir_id_t dir_entry_id;		/* associated directory entry id, for asynchronous DTR dialing. Set to an inexistent directory entry (e.g. 0) if no use */

		ushort		s109;				/* initial S109 value (Carrier Speed Selector) [0..9] (0) */

		ushort		disable_modulations;/* bit map, used to disable modulation V.34, V.FC */
#			define 		DTE_DISABLE_MODULATION_V34				0X0001	/* bit 0 : V.34 */
#			define 		DTE_DISABLE_MODULATION_VFC				0X0002	/* bit 1 : V.FC (V Fast Class) */

		timer_val_t	org_connect_timer_val;	/* duration of the delay before sending the 'CONNECT' message when originating, in milliseconds. 0: send connect immediately */
		timer_val_t	ans_connect_timer_val;	/* duration of the delay before sending the 'CONNECT' message when answering, in milliseconds. 0: send connect immediately */
		uchar		first_call_appearance_id;/* first call appearance id. Used only for AT&T 5ESS5, telephony calls. 0: use default value (supplied by the network) */
		uchar		s119;				/* initial S119 value (calling party processing). |1: display list of calling party numbers. |2; force display even if presentation is restricted */
		uchar		s120;				/* initial S120 value (called party processing). |1: display redirection number */
		struct {                        /* The purpose of this data structure is to be able to manage several nai on one DTE channel */
										/* This occurs when there are several SPIDs, each SPID being corresponding to one signalling na */
			struct {
				uchar		enable;			/* if !=OFF: enable use of this na. if OFF: disable use of this na */
				nai_t		nai_sig;		/* (signalling) network access identifier */
				uchar		na_user_id;		/* na user id. Must be non zero */
				uchar		mx_calls;		/* maximum number of calls allowed on this na */
			} na [DTE_MX_ASS_NA_PER_CH];
		}			ass_na;
		uchar		s131;				/* initial S131 value (call clearing processing). 0: normal. 1: do not send ACU_CLEAR_IN */

		uchar		check;				/* marker, for checks */
										/* must be set to DTE_CH_CHECK	*/
#		define 		DTE_CONFIG_CH		0

	};


/*---------------------------------------------------------------------------
 *		Main configuration structure for DTE_INT configuration
 *-------------------------------------------------------------------------*/

struct	dte_config_buffer	{

	/*-------------------------*/
	/*	Confirmation structure */
	/*-------------------------*/

	struct confirm 			dte_confirm;

	/*--------------------------*/
	/* 	Destination interpreter */
	/*--------------------------*/

	uchar					int_unit;		/* DTE unit (AT, PAD..) concerned */
											/* DTE_AT_INT_UNIT : configuration buffer for the AT interpreter */
											/* DTE_PAD_INT_UNIT : configuration buffer for the PAD */
	uchar					type;			/* configuration structure type */
											/* 0 : main, initial configuration */
#	define	DTE_CFIG_OUT_SERVICE_TYPE	'O'	/* Configuration : outgoing service description */
#	define	DTE_CFIG_DIRECTORY_TYPE		'D'	/* Configuration : directory description */
#	define	DTE_CFIG_CALLER_ID_TYPE		'S'	/* Configuration : security, callers identification list */
#	define	DTE_CFIG_TIME_SLOT_TYPE		'T'	/* Configuration : time slot call filtering description */
#	define	DTE_CFIG_DTE_CHANNEL_TYPE	'C'	/* Configuration : DTE channel configuration */
#	define	DTE_CFIG_EXT_AT_TYPE		'X'	/* Configuration : external AT interpreters */


	/*-------------------------------*/
	/* 	Global sizing and parameters */
	/*-------------------------------*/

	uchar					jn_nb;	  		/* In this configuration buffer, number of DTE-DCE (asynchronous) junctions [0..] */
	nai_t					na_nb;			/* In this configuration buffer, number of network accesses [0..] */
	dte_call_ix_t			call_nb;		/* In this configuration buffer, maximum number of calls [0..] */
	uchar					conn_nb;		/* In this configuration buffer, maximum number of connections [0..] */
											/* equal to the number of DTE channels */
	uchar 					ch_nb;			/* In this configuration buffer, number of DTE channels [0..] */
	uchar 					comm_port_nb;	/* In this configuration buffer, number of communications ports [0..] */

	uchar					b_chan_nb;		/* Maximum total number of B-channels per network access [1..] */
											/* 2 for ISDN BRI */
											/* valid only in first configuration buffer */

	timer_val_t				dtr_poll_interval;/* Duration between 2 synchronous port DTR polls */
											/* valid only in first configuration buffer */

	uchar					and_y;			/* Initial &Y value (stored profile for hard reset) [0..1] (0) */
											/* valid only in first configuration buffer */

	uchar					out_service_nb;	/* Maximum number of USER outgoing services description [0..] */
											/* valid only in first configuration buffer */

	uchar					check;			/* sentinel, for checks */
#	define DTE_CONFIG_RES_1	0


	/*----------------------------*/
	/* 	DTE junctions description */
	/*----------------------------*/

	struct dte_config {

		struct pdte_config pdte_conf;	/* Physical DTE configuration data */
										/* See PDTE_INT.H */

		uchar 		jn_id;			   	/* DTE junction identifier (any value) */

		uchar		ch_id;				/* default associated DTE channel id */
		uchar		rate;			   	/* DTE link rate (PDTE_RATE_xxx, see PDTE_INT.H)	*/
		uchar		ext_clock;		   	/* ON if junction clock is supplied externally (DCE UART clocked by the DTE) */
										/* OFF if junction UART clock is generated by the DCE */
		uchar		char_lgth;		   	/* length of UART character (7, 8) in bits 	*/
		uchar		stop_nb;		   	/* number of stop bits (1, 2) in UART characters */
		uchar		parity;			   	/* UART characters parity : PAR_PARITY_ODD, PAR_PARITY_EVEN,
										   PAR_NO_PARITY, etc. See PDTE_INT.H */
		uchar		s2;					/* initial value of the S2 register (escape sequence character) [0..255] (128) */
		uchar		s3;					/* initial value of the S3 register (carriage return character) [0..255] (0x0D) */
		uchar		s4;					/* initial value of the S4 register (linefeed character) [0..255] (0x0A) */
		uchar		s5;					/* initial value of the S5 register (backspace character) [0..255] (0x08) */
		uchar		s12;				/* initial value of the S12 register (escape sequence guard time) [0..255] (0) */
		uchar		e;					/* initial value of the E parameter (echo) [0..1] (1) */
		uchar		q;					/* initial value of the Q parameter (result code display options) [0..2] (0) */
		uchar		v;					/* initial value of the V parameter (result code format options) [0..1] (1) */
		uchar		ok;					/* send 'OK' at end of configuration. NOK: do not send, 0 or OK : send */
		timer_val_t	short_post_save;	/* duration, in standard format, of the standard post save timer, for reliable storage */
										/* May be 0 (no delay after storage start request). Used only if DTE_SM_CFG_UPDATE is set to ON */
		timer_val_t	long_post_save;		/* duration, in standard format, of the long post save timer (for AT&W command), for reliable storage */
										/* May be 0 (no delay after storage start request). Used only if DTE_SM_CFG_UPDATE is set to ON */
		uchar		modem_ch_id;		/* Associated DTE channel for modem (+FCLASS=0). 0 if none */
		uchar		fax_ch_id;			/* Associated DTE channel for fax   (+FCLASS=2). 0 if none */

		uchar		access_rights;		/* Access rights associated to the junction */
										/* 0: all rights */
#		define	DTE_ACCESS_USER			(0x01)	/* Junction user has 'User' rights */
#		define	DTE_ACCESS_INSTALLATION	(0x02)	/* Junction user has 'Installation' rights */
#		define	DTE_ACCESS_TEST			(0x04)	/* Junction user has (certification) 'Tests' rights */
#		define	DTE_ACCESS_MAINTENANCE	(0x08)	/* Junction user has 'Maintenance' rights */
#		define	DTE_ACCESS_MANAGEMENT	(0x10)	/* Junction user has 'Management' rights */

		uchar		s121;				/* S121: processing to perform upon AT&F. 0: standard. 255: nothing. Else DTE channel id to select */
		uchar		s122;				/* S122: processing to perform upon AT Z. 0: standard. */
										/*  254: restore parameters for current DTE channel from user profile. */
										/*  255: nothing. Else DTE channel id to select */
		uchar		s123;				/* S123: processing to perform upon DTR drop. 0: standard (use &D). */
										/*		 1: ignore DTR drop (&D setting superseded by implicit &D0) */

		uchar		disable;			/* ON: disable (physical access to) the junction. OFF: enable */
		uchar		s095;				/* initial S95 value (more negotiation message selection) [0..255] (0 or 254) */
		uchar		check;				/* reserved. Set to 0, or any other value */
#		define 	DTE_CONFIG_RES_JN	0	/* for compatibility with older versions */
	} dte_config  [DTE_MX_CFG_DTE];


	/*---------------------------------*/
	/* Communication ports description */
	/*---------------------------------*/

#if DTE_MX_CFG_COMM_PORT != 0

	struct dte_comm_port_config {

		uchar		cp_id;				/* internal communication port id (any value, except DTE_COMM_PORT_ID_NIL (0xFF)) */
		uchar   	cp_ph_id;			/* communication port id, used by PH (any value, typically identical to cp_id) */
		uchar		type;				/* communication port type : DTE_SYNC_COMM_PORT (synchronous), or possibly DTE_NULL_COMM_PORT */
		uchar		dtr_ip_id;			/* input port associated to the DTR junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		rts_ip_id;			/* input port associated to the RTS junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		cts_op_id;			/* output port associated to the CTS junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		dcd_op_id;			/* output port associated to the DCD junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		dsr_op_id;			/* output port associated to the DSR junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		ri_op_id;			/* output port associated to the RI junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		aux_op_id;			/* output port associated to the AUX supplementary 'junction' signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		and_x;				/* initial &X value (synchronous transmit clock source) [0..2] (0) */
		dte_dir_id_t dir_entry_id;		/* associated directory entry id. Set to an unexistent directory entry id if DTR dialing is not requested */

		uchar		resp_sup;			/* ON: suppress result code when DTR dialing, OFF: display result code  */

		uchar		dtr_poll;			/* ON : DTR state is acquired by polling */
										/* OFF: DTR state is signaled by PH_R primitives */
		uchar FAR	*cp_base_addr;		/* 68302 base address. If 0, uses default value DTE_68302_BASE_ADDR */
		uchar		disable;			/* ON: disable (physical access to) the communication port. OFF: enable */
		uchar		dsr_or_ri_op_id;	/* output port associated to the 'DSR or RI' 'junction' signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* other : set to 0 */
		uchar		check;				/* marker, for checks */
										/* must be set to DTE_COMM_PORT_CHECK	*/
#		define 		DTE_CONFIG_RES_CP	0
	} comm_port_config [DTE_MX_CFG_COMM_PORT];

#endif


	/*------------------------------*/
	/* Network accesses description */
	/*------------------------------*/

	struct dte_na_config {
		nai_t       nai_sig;			/* network access identifier (any value) */

		uchar		mgt_ch_id;			/* identifier of the associated management DTE channel */

		uchar		network_line_type; 	/* network line type (DTE_ISDN_LINE, DTE_AGGREGATED_ISDN_LINE, DTE_ANALOG_LINE, etc) */

		uchar		spk_control;		/* speaker initial control : DTE_SPK_OFF,
										   DTE_SPK_ON, DTE_SPK_TIL_CD,
										   DTE_SPK_DIAL_TIL_CD */
		uchar		spk_level;			/* speaker initial level :
										   DTE_SPK_LOW_LEVEL, DTE_SPK_MEDIUM_LEVEL,
										   DTE_SPK_HIGH_LEVEL */
		uchar		out_service_id;		/* outgoing service description id, 0 for default */
		uchar		mx_calls;			/* maximum number of calls (including D-channel pseudo-calls) supported by the line/network */
										/* 0 : use default value (1 for analog, 2 for ISDN, 0 for leased line) */
		uchar		clear_non_authentified_calls;
										/* ON: clear non authentified incoming calls */
										/* OFF: do nothing, let ring the non authentified incoming calls */
		uchar		mgt_jn_id;			/* Identifier of the associated management asynchronous junction */
										/* if 0, the first declared asynchronous junction is used */
		uchar		mx_b_chan;			/* maximum number of B-channels supported by the network for this line */
										/* typically 1 for analog line, 2 for basic ISDN access, etc. B-channel ids range from 0 to  line_mx_b_chan-1 */
		nai_t       nai_relay;			/* 'nai_data', network access identifier, to use for data transfers */
										/* Suggested value : same as nai_sig */
		nai_t       nai_acu;			/* network access identifier, to use with ACU, for group 3 fax over ISDN */
										/* Suggested value : same as nai_sig */
		uchar		reg_s000_min;		/* (regulation) minimum non-zero S0 value. 0: ignored */
		uchar		reg_s000_max;		/* (regulation) maximum non-zero S0 value. 0: ignored */
		uchar		reg_s007_min;		/* (regulation) minimum non-zero S7 value. 0: ignored */
		uchar		reg_s007_max;		/* (regulation) maximum non-zero S7 value. 0: ignored */
		uchar		at_56k;				/* ON: network access has 56kbps B-channels. OFF: 64kbps */

		uchar		check;				/* marker, for checks */
										/* must be set to DTE_NA_CHECK */
#		define 		DTE_CONFIG_RES_NA	0

	} na_config [DTE_MX_CFG_NA];


	/*--------------------------*/
	/* DTE channels description */
	/*--------------------------*/

	struct dte_ch_config ch_config [DTE_MX_CFG_CH];		/* DTE channels declarations */


	/* More general data, extensions */

	uchar					scc_nb;			/* Maximum number of SCC in the system [1..] */
											/* valid only in first configuration buffer */
	ent_id_t				api_entity;		/* API entity name (ENT_xxx). If no use of API, set to 0. */
											/* valid only in first configuration buffer */

	/* Extension for configuration in multiple buffers */

	uchar					more_config;	/* ON:  more configuration buffers (type 0) follow.
											   OFF: last (type 0) configuration buffer */
	struct _grand_total {					/* grand total, for all configurations structures */

		uchar				valid;			/* ON: use this substructure. OFF: do not use */
		uchar				jn_nb;	  		/* Maximum total number of DTE-DCE (asynchronous) junctions [1..] */
		nai_t				na_nb;			/* Maximum total number of network accesses [1..] */
		dte_call_ix_t		call_nb;		/* Maximum total number of calls [1..] */
		short				conn_nb;		/* Maximum total number of connections [1..] */
											/* equal to the number of DTE channels */
		short 				ch_nb;			/* Maximum total number of DTE channels [1..] */
		uchar 				comm_port_nb;	/* Maximum total number of communications ports [0..] */

	} gt;

	uchar               from_user_profile;	/*    OFF: configuration does not come from user profile, comes from factory defaults */
											/* != OFF: configuration comes from user profile */
	uchar				call_list_nb;		/* Maximum number of call lists which may be simultaneously active */
											/* valid only in first configuration buffer */
	struct {
		uchar			use_jn_id;			/* ON/OFF: use junction id (instead of junction internal index) for computing the update id values */
		uchar			use_nai;			/* ON/OFF: use network access signalling id (instead of na internal index) for computing the update id values */
		uchar			use_ch_unique_id;	/* ON/OFF: use DTE channel unique id (instead of DTE channel internal index) for computing the update id values */
	} upd;									/* valid only in first configuration buffer */

};


/*
 *  Macros for initializing the SCA (simple DTE channel addressing) data
 */
#if	DTE_SIMPLE_CHANNEL_ADDRESSING == ON
#	define	Sca_init_a_isdn(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept)	\
			{ enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept, ENT_CC }
#	define	Sca_init_a_x25(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept)	\
			{ enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept, ENT_X25 }
#	define	Sca_init_a(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept)	\
			{ enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept, 0 }
#	define	Sca_init(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui)	\
			{ enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, OFF, 0	}
#else
#	define	Sca_init_a_isdn(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept)	\
			{ enable, "", "", "", accept, ENT_CC }
#	define	Sca_init_a_x25(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept)	\
			{ enable, "", "", "", accept, ENT_X25 }
#	define	Sca_init_a(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui, accept)	\
			{ enable, "", "", "", accept, 0 }
#	define	Sca_init(enable, loc_isdn_or_x25_addr, loc_isdn_sub_addr, loc_uui)	\
			{ enable, "", "", "", OFF, 0	}
#endif

/*
 *	Access macros using pointers :
 *		p_dte_config		: general configuration structure
 *		p_dte_config_jn		: DTE_DCE link (junction) configuration structure
 *		p_dte_config_cp		: communication port
 *		p_dte_config_na		: network access configuration structure
 *		p_dte_config_ch		: DTE channel access configuration structure
 */

#define 	Dcfg_confirm_cause			(p_dte_config -> dte_confirm.cause)
#define 	Dcfg_confirm_diag			(p_dte_config -> dte_confirm.diagnostic)
#define 	Dcfg_confirm_ret_code		(p_dte_config -> dte_confirm.return_code)
#define		Dcfg_int_unit				(p_dte_config -> int_unit)
#define		Dcfg_type					(p_dte_config -> type)

#define		Dcfg_and_y					(p_dte_config -> and_y)
#define		Dcfg_api_entity				(p_dte_config -> api_entity)
#define		Dcfg_b_chan_nb				(p_dte_config -> b_chan_nb)
#define		Dcfg_call_nb				(p_dte_config -> call_nb)
#define		Dcfg_call_list_nb			(p_dte_config -> call_list_nb)
#define		Dcfg_comm_port_nb			(p_dte_config -> comm_port_nb)
#define		Dcfg_conn_nb				(p_dte_config -> conn_nb)
#define		Dcfg_ch_nb					(p_dte_config -> ch_nb)
#define		Dcfg_dtr_poll_interval		(p_dte_config -> dtr_poll_interval)
#define		Dcfg_from_user_profile		(p_dte_config -> from_user_profile)
#define		Dcfg_jn_nb					(p_dte_config -> jn_nb)
#define		Dcfg_na_nb					(p_dte_config -> na_nb)
#define		Dcfg_out_service_nb			(p_dte_config -> out_service_nb)
#define		Dcfg_scc_nb					(p_dte_config -> scc_nb)
#define		Dcfg_upd_use_jn_id			(p_dte_config -> upd.use_jn_id)
#define		Dcfg_upd_use_nai			(p_dte_config -> upd.use_nai)
#define		Dcfg_upd_use_ch_unique_id	(p_dte_config -> upd.use_ch_unique_id)

#define		Dcfg_more_config			(p_dte_config -> more_config)

#define		Dcfg_gt_valid				(p_dte_config -> gt.valid)
#define		Dcfg_gt_call_nb				(p_dte_config -> gt.call_nb)
#define		Dcfg_gt_comm_port_nb		(p_dte_config -> gt.comm_port_nb)
#define		Dcfg_gt_conn_nb				(p_dte_config -> gt.conn_nb)
#define		Dcfg_gt_ch_nb				(p_dte_config -> gt.ch_nb)
#define		Dcfg_gt_jn_nb				(p_dte_config -> gt.jn_nb)
#define		Dcfg_gt_na_nb				(p_dte_config -> gt.na_nb)

#define 	Dcfg_a_jn(i)				(&(p_dte_config -> dte_config[i]))
#define 	Dcfg_a_na(i)				(&(p_dte_config -> na_config[i]))
#define 	Dcfg_a_ch(i)				(&(p_dte_config -> ch_config[i]))
#define 	Dcfg_a_comm_port(i)			(&(p_dte_config -> comm_port_config[i]))


	/* Junction configuration macros */

#define		Dcfg_jn_a_pdte				(&(p_dte_config_jn -> pdte_conf))
#define		Dcfg_jn_access_rights		(p_dte_config_jn -> access_rights)
#define		Dcfg_jn_ch_id				(p_dte_config_jn -> ch_id)
#define		Dcfg_jn_char_lgth			(p_dte_config_jn -> char_lgth)
#define		Dcfg_jn_check				(p_dte_config_jn -> check)
#define		Dcfg_jn_disable				(p_dte_config_jn -> disable)
#define		Dcfg_jn_e					(p_dte_config_jn -> e)
#define		Dcfg_jn_ext_clock			(p_dte_config_jn -> ext_clock)
#define		Dcfg_jn_fax_ch_id			(p_dte_config_jn -> fax_ch_id)
#define 	Dcfg_jn_id					(p_dte_config_jn -> jn_id)
#define		Dcfg_jn_long_post_save		(p_dte_config_jn -> long_post_save)
#define		Dcfg_jn_modem_ch_id			(p_dte_config_jn -> modem_ch_id)
#define		Dcfg_jn_ok					(p_dte_config_jn -> ok)
#define		Dcfg_jn_parity				(p_dte_config_jn -> parity)
#define		Dcfg_jn_q					(p_dte_config_jn -> q)
#define		Dcfg_jn_rate				(p_dte_config_jn -> rate)
#define		Dcfg_jn_short_post_save		(p_dte_config_jn -> short_post_save)
#define		Dcfg_jn_stop_nb				(p_dte_config_jn -> stop_nb)
#define		Dcfg_jn_spk_control			(p_dte_config_jn -> spk_control)
#define		Dcfg_jn_spk_level			(p_dte_config_jn -> spk_level)
#define		Dcfg_jn_s2					(p_dte_config_jn -> s2)
#define		Dcfg_jn_s3					(p_dte_config_jn -> s3)
#define		Dcfg_jn_s4					(p_dte_config_jn -> s4)
#define		Dcfg_jn_s5					(p_dte_config_jn -> s5)
#define		Dcfg_jn_s12					(p_dte_config_jn -> s12)
#define		Dcfg_jn_s095				(p_dte_config_jn -> s095)
#define		Dcfg_jn_s121				(p_dte_config_jn -> s121)
#define		Dcfg_jn_s122				(p_dte_config_jn -> s122)
#define		Dcfg_jn_s123				(p_dte_config_jn -> s123)
#define		Dcfg_jn_v					(p_dte_config_jn -> v)


	/* Communication port configuration macros */

#define		Dcfg_cp_id					(p_dte_config_cp -> cp_id)
#define		Dcfg_cp_ph_id				(p_dte_config_cp -> cp_ph_id)

#define		Dcfg_cp_and_x				(p_dte_config_cp -> and_x)
#define		Dcfg_cp_aux_op_id			(p_dte_config_cp -> aux_op_id)
#define		Dcfg_cp_base_addr			(p_dte_config_cp -> cp_base_addr)
#define		Dcfg_cp_check				(p_dte_config_cp -> check)
#define		Dcfg_cp_cd_op_id			(p_dte_config_cp -> dcd_op_id)
#define		Dcfg_cp_cts_op_id			(p_dte_config_cp -> cts_op_id)
#define		Dcfg_cp_dir_entry_id		(p_dte_config_cp -> dir_entry_id)
#define		Dcfg_cp_disable				(p_dte_config_cp -> disable)
#define		Dcfg_cp_dsr_op_id			(p_dte_config_cp -> dsr_op_id)
#define		Dcfg_cp_dsr_or_ri_op_id		(p_dte_config_cp -> dsr_or_ri_op_id)
#define		Dcfg_cp_dtr_ip_id			(p_dte_config_cp -> dtr_ip_id)
#define		Dcfg_cp_dtr_poll			(p_dte_config_cp -> dtr_poll)
#define		Dcfg_cp_mgt_ch_id			(p_dte_config_cp -> mgt_ch_id)
#define		Dcfg_cp_ri_op_id			(p_dte_config_cp -> ri_op_id)
#define		Dcfg_cp_rts_ip_id			(p_dte_config_cp -> rts_ip_id)
#define		Dcfg_cp_type				(p_dte_config_cp -> type)
#define		Dcfg_cp_resp_sup			(p_dte_config_cp -> resp_sup)


	/* Network access configuration macros */

#define		Dcfg_na_nai_sig				(p_dte_config_na -> nai_sig)
#define		Dcfg_na_nai					Dcfg_na_nai_sig
#define		Dcfg_na_nai_acu				(p_dte_config_na -> nai_acu)
#define		Dcfg_na_nai_data			(p_dte_config_na -> nai_relay)
#define		Dcfg_na_nai_relay			Dcfg_na_nai_data

#define		Dcfg_na_at_56k				(p_dte_config_na -> at_56k)
#define		Dcfg_na_check				(p_dte_config_na -> check)
#define		Dcfg_na_clear_non_authentified_calls	\
										(p_dte_config_na -> clear_non_authentified_calls)
#define		Dcfg_na_mgt_ch_id			(p_dte_config_na -> mgt_ch_id)
#define		Dcfg_na_mgt_jn_id			(p_dte_config_na -> mgt_jn_id)
#define		Dcfg_na_mx_b_chan			(p_dte_config_na -> mx_b_chan)
#define		Dcfg_na_mx_calls			(p_dte_config_na -> mx_calls)
#define		Dcfg_na_network_line_type	(p_dte_config_na -> network_line_type)
#define		Dcfg_na_out_service_id		(p_dte_config_na -> out_service_id)
#define		Dcfg_na_spk_control			(p_dte_config_na -> spk_control)
#define		Dcfg_na_spk_level			(p_dte_config_na -> spk_level)

#define		Dcfg_na_reg_s000_min		(p_dte_config_na -> reg_s000_min)
#define		Dcfg_na_reg_s000_max		(p_dte_config_na -> reg_s000_max)
#define		Dcfg_na_reg_s007_min		(p_dte_config_na -> reg_s007_min)
#define		Dcfg_na_reg_s007_max		(p_dte_config_na -> reg_s007_max)

	/* Channel configuration macros */

#define		Dcfg_ch_id					(p_dte_config_ch -> ch_id)
#define		Dcfg_ch_unique_id			(p_dte_config_ch -> ch_unique_id)

#define		Dcfg_ch_and_c				(p_dte_config_ch -> and_c)
#define		Dcfg_ch_and_d				(p_dte_config_ch -> and_d)
#define		Dcfg_ch_and_g				(p_dte_config_ch -> and_g)
#define		Dcfg_ch_and_k				(p_dte_config_ch -> and_k)
#define		Dcfg_ch_and_q				(p_dte_config_ch -> and_q)
#define		Dcfg_ch_and_r				(p_dte_config_ch -> and_r)
#define		Dcfg_ch_and_s				(p_dte_config_ch -> and_s)
#define		Dcfg_ch_ans_connect_timer_val	\
										(p_dte_config_ch -> ans_connect_timer_val)

#define		Dcfg_ch_ass_na_enable(i)	(p_dte_config_ch -> ass_na.na[i].enable)
#define		Dcfg_ch_ass_na_nai_sig(i)	(p_dte_config_ch -> ass_na.na[i].nai_sig)
#define		Dcfg_ch_ass_na_user_id(i)	\
										(p_dte_config_ch -> ass_na.na[i].na_user_id)
#define		Dcfg_ch_ass_na_mx_calls(i)	(p_dte_config_ch -> ass_na.na[i].mx_calls)

#define		Dcfg_ch_check				(p_dte_config_ch -> check)

#define		Dcfg_ch_acu_profile			(p_dte_config_ch -> acu_profile)
#define		Dcfg_ch_callers_list_id		(p_dte_config_ch -> callers_list_id)
#define		Dcfg_ch_cc_service_list_id	(p_dte_config_ch -> cc_service_list_id)
#define		Dcfg_ch_cce_conn_id			(p_dte_config_ch -> cce_conn_id)
#define		Dcfg_ch_comm_port_id		(p_dte_config_ch -> comm_port_id)
#define		Dcfg_ch_dc_nai				(p_dte_config_ch -> dc_nai)
#define		Dcfg_ch_dc_stream_id		(p_dte_config_ch -> dc_stream_id)

#define		Dcfg_ch_dec_block_size		(p_dte_config_ch -> dec_parameters.block_size)
#define		Dcfg_ch_dec_flush_timer_val	(p_dte_config_ch -> dec_parameters.flush_timer_val)
#define		Dcfg_ch_dec_high_mark		(p_dte_config_ch -> dec_parameters.high_mark)
#define		Dcfg_ch_dec_low_data_size	(p_dte_config_ch -> dec_parameters.low_data_size)
#define		Dcfg_ch_dec_low_mark		(p_dte_config_ch -> dec_parameters.low_mark)
#define		Dcfg_ch_dec_th_low_traffic	(p_dte_config_ch -> dec_parameters.th_low_traffic)

#define		Dcfg_ch_dir_entry_id		(p_dte_config_ch -> dir_entry_id)

#define		Dcfg_ch_enc_block_size		(p_dte_config_ch -> enc_dc_block_size)
#define		Dcfg_ch_enc_flush_timer_val	(p_dte_config_ch -> enc_parameters.flush_timer_val)
#define		Dcfg_ch_enc_high_mark		(p_dte_config_ch -> enc_parameters.high_mark)
#define		Dcfg_ch_enc_low_mark		(p_dte_config_ch -> enc_parameters.low_mark)
#define		Dcfg_ch_enc_mx_blocks		(p_dte_config_ch -> enc_parameters.mx_blocks)
#define		Dcfg_ch_enc_th_low_traffic	(p_dte_config_ch -> enc_parameters.th_low_traffic)

#define		Dcfg_ch_v42b_resp_timer_val	(p_dte_config_ch -> enc_parameters.v42b_resp_timer_val)
#define		Dcfg_ch_v42b_dict_size		(p_dte_config_ch -> v42b_dict_size)
#define		Dcfg_ch_v42b_str_size       (p_dte_config_ch -> v42b_str_size)
#define		Dcfg_ch_def_data_chani		(p_dte_config_ch -> def_data_chani)
#define		Dcfg_ch_def_nai_sig			(p_dte_config_ch -> nai)
#define		Dcfg_ch_disable				(p_dte_config_ch -> disable)
#define		Dcfg_ch_dl_sapi				(p_dte_config_ch -> dl_sapi)
#define		Dcfg_ch_ext_jn_id			(p_dte_config_ch -> ext_jn_id)
#define		Dcfg_ch_first_call_appearance_id		\
				(p_dte_config_ch -> first_call_appearance_id)
#define		Dcfg_ch_first_call_user_id	(p_dte_config_ch -> first_call_user_id)
#define		Dcfg_ch_first_conn_id		(p_dte_config_ch -> first_conn_id)
#define		Dcfg_ch_hole_size			(p_dte_config_ch -> hole_size)
#define		Dcfg_ch_inc_auto_answer		(p_dte_config_ch -> inc_auto_answer)
#define		Dcfg_ch_inc_manual_answer	(p_dte_config_ch -> inc_manual_answer)
#define		Dcfg_ch_inc_priority		(p_dte_config_ch -> inc_priority)
#define		Dcfg_ch_jn_id				(p_dte_config_ch -> jn_id)
#define		Dcfg_ch_litt_name			(p_dte_config_ch -> litt_name)
#define		Dcfg_ch_lock_service		(p_dte_config_ch -> lock_service)

#define		Dcfg_ch_disable_modulations	(p_dte_config_ch -> disable_modulations)
#define		Dcfg_ch_mnp4_disable		(p_dte_config_ch -> mnp4_disable)
#define		Dcfg_ch_mx_act_calls		(p_dte_config_ch -> mx_act_calls)
#define		Dcfg_ch_mx_data_calls		(p_dte_config_ch -> mx_data_calls)
#define		Dcfg_ch_mx_inc_calls		(p_dte_config_ch -> mx_inc_calls)
#define		Dcfg_ch_mx_out_calls		(p_dte_config_ch -> mx_out_calls)
#define		Dcfg_ch_mx_voice_calls		(p_dte_config_ch -> mx_voice_calls)
#define		Dcfg_ch_nai					Dcfg_ch_def_nai_sig
#define		Dcfg_ch_nb_calls			(p_dte_config_ch -> nb_calls)
#define		Dcfg_ch_nb_conns			(p_dte_config_ch -> nb_conns)
#define		Dcfg_ch_n_sapi				(p_dte_config_ch -> n_sapi)
#define		Dcfg_ch_org_connect_timer_val	\
										(p_dte_config_ch -> org_connect_timer_val)
#define		Dcfg_ch_out_mx_calls		(p_dte_config_ch -> out_mx_calls)
#define		Dcfg_ch_pad_auto_start		(p_dte_config_ch -> pad_autostart)
#define		Dcfg_ch_pad_in_prof_name	(p_dte_config_ch -> pad_in_prof_name)
#define		Dcfg_ch_pad_in_serv_prof_name	\
										(p_dte_config_ch -> pad_in_serv_prof_name)
#define		Dcfg_ch_pad_out_prof_name	(p_dte_config_ch -> pad_out_prof_name)
#define		Dcfg_ch_pad_out_serv_prof_name	\
										(p_dte_config_ch -> pad_out_serv_prof_name)
#define		Dcfg_ch_pad_def_call_string	(p_dte_config_ch -> pad_def_call_string)
#define		Dcfg_ch_pad_par_23			(p_dte_config_ch -> pad_par_23)
#define		Dcfg_ch_per_c				(p_dte_config_ch -> per_c)
#define		Dcfg_ch_ph_data_nb			(p_dte_config_ch -> ph_parameters.data_nb)
#define		Dcfg_ch_ph_parity			(p_dte_config_ch -> ph_parameters.parity)
#define		Dcfg_ch_ph_stop_nb			(p_dte_config_ch -> ph_parameters.stop_nb)
#define		Dcfg_ch_ph_syn_asyn			(p_dte_config_ch -> ph_parameters.syn_asyn)
#define		Dcfg_ch_ph_sync_window		(p_dte_config_ch -> ph.sync_window)
#define		Dcfg_ch_ph_user_rate		(p_dte_config_ch -> ph_parameters.user_rate)
#define		Dcfg_ch_phcto				(p_dte_config_ch -> phcto)
#define		Dcfg_ch_rate				(p_dte_config_ch -> rate)
#define		Dcfg_ch_relay_mode			(p_dte_config_ch -> relay_mode)
#define		Dcfg_ch_route_mx_nb_buffer	(p_dte_config_ch -> route_mx_nb_buffer)
#define		Dcfg_ch_sca_addr_type		(p_dte_config_ch -> sca.addr_type)
#define		Dcfg_ch_sca_enable			(p_dte_config_ch -> sca.enable)
#define		Dcfg_ch_sca_loc_isdn_addr	\
										(p_dte_config_ch -> sca.loc_isdn_addr)
#define		Dcfg_ch_sca_loc_isdn_sub_addr		\
										(p_dte_config_ch -> sca.loc_isdn_sub_addr)
#define		Dcfg_ch_sca_loc_uui_data	(p_dte_config_ch -> sca.loc_uui_data)
#define		Dcfg_ch_service				(p_dte_config_ch -> service)
#define		Dcfg_ch_s0					(p_dte_config_ch -> s0)
#define		Dcfg_ch_s6					(p_dte_config_ch -> s6)
#define		Dcfg_ch_s7					(p_dte_config_ch -> s7)
#define		Dcfg_ch_s8					(p_dte_config_ch -> s8)
#define		Dcfg_ch_s9					(p_dte_config_ch -> s9)
#define		Dcfg_ch_s10					(p_dte_config_ch -> s10)
#define		Dcfg_ch_s11					(p_dte_config_ch -> s11)
#define		Dcfg_ch_s18					(p_dte_config_ch -> s18)
#define		Dcfg_ch_s25					(p_dte_config_ch -> s25)
#define		Dcfg_ch_s26					(p_dte_config_ch -> s26)
#define		Dcfg_ch_s30					(p_dte_config_ch -> s30)
#define		Dcfg_ch_s36					(p_dte_config_ch -> s36)
#define		Dcfg_ch_s37					(p_dte_config_ch -> s37)
#define		Dcfg_ch_s38					(p_dte_config_ch -> s38)
#define		Dcfg_ch_s48					(p_dte_config_ch -> s48)
#define		Dcfg_ch_s82					(p_dte_config_ch -> s82)
#define		Dcfg_ch_s109				(p_dte_config_ch -> s109)
#define		Dcfg_ch_s112				(p_dte_config_ch -> s112)
#define		Dcfg_ch_s113				(p_dte_config_ch -> s113)
#define		Dcfg_ch_s115				(p_dte_config_ch -> s115)
#define		Dcfg_ch_s116				(p_dte_config_ch -> s116)
#define		Dcfg_ch_s117				(p_dte_config_ch -> s117)
#define		Dcfg_ch_s118				(p_dte_config_ch -> s118)
#if DTE_EXT_CALLING_PARTY == ON
#	define	Dcfg_ch_s119				(p_dte_config_ch -> s119)
#endif
#if DTE_EXT_CALLED_PARTY == ON
#	define	Dcfg_ch_s120				(p_dte_config_ch -> s120)
#endif
#if DTE_ISDN_CC == ON
#	define	Dcfg_ch_s131				(p_dte_config_ch -> s131)
#endif
#define		Dcfg_ch_t_p					(p_dte_config_ch -> t_p)
#define		Dcfg_ch_to_ph_queue_high_mark	\
										(p_dte_config_ch -> ph.to_ph_queue_high_mark)
#define		Dcfg_ch_to_ph_queue_low_mark	\
										(p_dte_config_ch -> ph.to_ph_queue_low_mark)
#define		Dcfg_ch_w					(p_dte_config_ch -> w)
#define		Dcfg_ch_x					(p_dte_config_ch -> x)
#define		Dcfg_ch_y					(p_dte_config_ch -> y)


/*--------------------------------------------------------------------------
 *		Configuration data structure, for list of DTE channels
 *-------------------------------------------------------------------------*/

struct dte_config_list_dte_channel	{

	/*-------------------------*/
	/*	Confirmation structure */
	/*-------------------------*/

	struct confirm 			dte_confirm;

	/*--------------------------*/
	/* 	Destination interpreter */
	/*--------------------------*/

	uchar					int_unit;		/* DTE unit (AT, PAD..) concerned */
											/* must be DTE_AT_INT_UNIT */
											/* DTE_PAD_INT_UNIT : configuration buffer for the PAD */
	uchar					type;			/* configuration structure type */
											/* must be DTE_CFIG_DTE_CHANNEL_TYPE */
/* Beginning of specific part */

	/*-------------------------------*/
	/* 	Global sizing and parameters */
	/*-------------------------------*/

	uchar 					ch_nb;			/* In this configuration buffer, number of DTE channels [0..] */

	/* Extension for configuration in multiple buffers */

	struct {
		uchar				more_config;	/* ON:  more configuration buffers follow.
											   OFF: last configuration buffer */
		uchar				reserved;		/* reserved. set to 0 */
	}						ext;

	struct dte_ch_config ch_config [DTE_MX_2_CFG_CH];	/* DTE channels declarations */

};

#define Dcfg_list_ch_ch_nb			(p_dte_list_dte_channel_config -> ch_nb)
#define Dcfg_list_ch_more_config	(p_dte_list_dte_channel_config -> ext. more_config)

#define Dcfg_list_ch_a_ch(i)		(&(p_dte_list_dte_channel_config -> ch_config [i]))


/*--------------------------------------------------------------------------
 *		Configuration data structure, for DTE interface directory
 *-------------------------------------------------------------------------*/

#if DTE_DIR == ON

struct dte_config_directory {
	struct confirm 			dte_confirm;
	uchar					int_unit;		/* DTE unit (AT, PAD..) concerned */
	uchar					type;			/* configuration structure type */

/* Beginning of specific part */

	struct {
		dte_dir_id_t	dir_id;				/* directory entry id. 0 : end of list */
		ushort			update_id;			/* SM associated update id. 0 if none */

		uchar			ds [DTE_MX_DIR_DS_SIZE + 1];/* dial string */
													/* nul terminated string */
		uchar			ch_id;						/* for lists: DTE channel to use when dialing */
													/* 0: use current DTE channel */
		dte_dir_id_t	next_dir_id;				/* next directory entry to dial in the list */
													/* 0, or DTE_DIR_ID_NIL: end of list */
		uchar			nb_max_tries_list;			/* maximum number of tries for the list starting with this number */
													/* DTE_MAX_UCHAR: repeat list indefinitely */
		uchar			nb_max_tries_number;		/* maximum number of tries for this number */
		uchar			dial_command;				/* dial command to use for this number */
													/* 0: use 'AT*D/' or 'ATD' according to the directory entry (starting with '/' or not) */
													/* DTE_CL_CMD_AT_D: 	 use always 'ATD' */
													/* DTE_CL_CMD_AT_STAR_D: use always 'AT*D/' */
#		define			DTE_CL_CMD_AT_D			'D'				/* use AT  D 	*/
#		define			DTE_CL_CMD_AT_STAR_D	'*'				/* use AT *D/ 	*/

		timer_val_t		before_dial_delay;			/* delay before dialing this number */
													/* 0: dial immediately */
	} dte_dir_entries [DTE_MX_DIR_ENTRY];

};

#define	Dcfg_dir_id(i)			(p_dte_config_dir -> dte_dir_entries[i].dir_id)
#define	Dcfg_dir_update_id(i)	(p_dte_config_dir -> dte_dir_entries[i].update_id)
#define	Dcfg_dir_ds(i)			(p_dte_config_dir -> dte_dir_entries[i].ds)

#define	Dcfg_dir_ch_id(i)				(p_dte_config_dir -> dte_dir_entries[i].ch_id)
#define	Dcfg_dir_dial_command(i)		(p_dte_config_dir -> dte_dir_entries[i].dial_command)
#define	Dcfg_dir_next_dir_id(i)			(p_dte_config_dir -> dte_dir_entries[i].next_dir_id)
#define	Dcfg_dir_nb_max_tries_list(i)	(p_dte_config_dir -> dte_dir_entries[i].nb_max_tries_list)
#define	Dcfg_dir_nb_max_tries_number(i)	(p_dte_config_dir -> dte_dir_entries[i].nb_max_tries_number)
#define	Dcfg_dir_before_dial_delay(i)	(p_dte_config_dir -> dte_dir_entries[i].before_dial_delay)

#endif


/*--------------------------------------------------------------------------
 *		Configuration data structure, for outgoing service description
 *-------------------------------------------------------------------------*/

struct dte_config_out_service {

	struct confirm 			dte_confirm;
	uchar					int_unit;		/* DTE unit (AT, PAD..) concerned */
	uchar					type;			/* configuration structure type */
/* Beginning of specific part */
	uchar					out_serv_nb;	/* number of outgoing service descriptions */

	struct {
		uchar		id;						/* outgoing service id */
		struct {
			uchar	dte_user_service;		/* DTE service user id */
			uchar	acu_service;			/* corresponding ACU service */
		} dte_acu [DTE_MX_SERVICES];
	} out_serv [DTE_MX_CFG_MX_OUTGOING_SERVICES];
};

#define	Dcfg_os_out_serv_nb             (p_dte_config_os -> out_serv_nb)
#define	Dcfg_os_id(i)            		(p_dte_config_os -> out_serv[i].id)
#define	Dcfg_os_dte_user_service(i,j)	(p_dte_config_os -> out_serv[i].dte_acu[j].dte_user_service)
#define	Dcfg_os_acu_service(i,j)		(p_dte_config_os -> out_serv[i].dte_acu[j].acu_service)


/*--------------------------------------------------------------------------
 *		Configuration data structure, for caller's filtering list
 *		(Filtering of incoming calls, based on the remote caller's
 *		characteristics)
 *-------------------------------------------------------------------------*/

struct dte_config_inc_caller_filtering {

	struct confirm 			dte_confirm;
	uchar					int_unit;		/* DTE_AT_INT_UNIT : DTE unit concerned */
	uchar					type;			/* DTE_CFIG_CALLER_ID_TYPE, configuration structure type */

/* Beginning of specific part */
	uchar					list_nb;		/* number of lists */

	struct {
		uchar		id;						/* list identifier */
		struct {
			uchar	enable;					/* ON : enable the record. OFF: disable */
			uchar	rem_isdn_addr [DTE_CHECK_ISDN_ADDR_SIZE + 1];
											/* remote ISDN address. */
											/* If '\0', no filtering based upon remote ISDN address */
			uchar	rem_isdn_sub_addr [DTE_CHECK_ISDN_SUB_ADDR_SIZE + 1];
											/* remote ISDN subaddress. */
											/* If '\0', no filtering based upon remote ISDN subaddress */
			uchar	uui_data [DTE_ISDN_PASSWORD_SIZE + 1];
											/* password (in UUI) bytes */
		} remote_caller [DTE_MX_REMOTE_CALLERS];
	} list [DTE_MX_REMOTE_CALLERS_LISTS];
};

/*
 *		Macro to initialize a remote_caller, with password supplied as
 *		a 'C' string.
 *		To specify an empty string, use "", not P_NIL.
 */

#define	Remote_caller_init(enable, rem_isdn_addr, rem_isdn_sub_addr, 	\
						   c_string_password)							\
			{ enable, rem_isdn_addr, rem_isdn_sub_addr,	c_string_password 	}

#define	Dcfg_icf_list_nb	            (p_dte_config_icf -> list_nb)
#define	Dcfg_icf_list_id(i_list)		(p_dte_config_icf -> list[i_list].id)
#define	Dcfg_icf_caller_enable(i_list, i_caller)	\
			(p_dte_config_icf -> list[i_list].remote_caller[i_caller].enable)
#define	Dcfg_icf_isdn_addr(i_list, i_caller)	\
			(p_dte_config_icf -> list[i_list].remote_caller[i_caller].rem_isdn_addr)
#define	Dcfg_icf_isdn_sub_addr(i_list, i_caller)	\
			(p_dte_config_icf -> list[i_list].remote_caller[i_caller].rem_isdn_sub_addr)
#define	Dcfg_icf_uui_data(i_list, i_caller)	\
			(p_dte_config_icf -> list[i_list].remote_caller[i_caller].uui_data)


/*--------------------------------------------------------------------------
 *		Configuration data structure, for time slot call filtering
 *-------------------------------------------------------------------------*/

#if DTE_TIME_SLOT == ON

#ifndef dte_slot_id_t
#	define	dte_slot_id_t	uchar			/* type : slot identifier */
#endif

struct dte_config_slot {

	struct confirm 	dte_confirm;

	uchar			int_unit;		/* DTE unit (AT, PAD..) concerned */
	uchar			type;			/* configuration structure type */

/* Beginning of specific part */

	dte_slot_id_t	slot_nb;		/* number of slots in the array */

	struct {
		dte_slot_id_t	id;				/* slot id */
		uchar			enable;			/* ON : enable slot. OFF: disable */
		uchar			str [DTE_MX_SLOT_STR_SIZE + 1]; /* slot string */
														/* nul terminated string */
	} slot_entries [DTE_MX_CFG_SLOT_ENTRY];

	struct {
		dte_slot_id_t	total_nb_slots;	/* total number of slots */
										/* valid only in FIRST configuration structure */
										/* if 0: the value from 'slot_nb' is used */
	} more;

};

/*
 *		Macro to initialize a time slot.
 *		To specify an empty string, use "", not P_NIL.
 */

#define	Time_slot_init(enable, id, str)		{ id, enable, str }

#define	Dcfg_slot_nb	            (p_dte_config_slot -> slot_nb)
#define	Dcfg_slot_id(i)	            (p_dte_config_slot -> slot_entries[i].id)
#define	Dcfg_slot_enable(i)	        (p_dte_config_slot -> slot_entries[i].enable)
#define	Dcfg_slot_str(i)			(p_dte_config_slot -> slot_entries[i].str)
#define	Dcfg_slot_total_nb_slots	(p_dte_config_slot -> more.total_nb_slots)

#endif

/*--------------------------------------------------------------------------
 *	Configuration data structure, for DTE_INT AT interpreter extensions
 *	(external commands, processed by external entities)
 *-------------------------------------------------------------------------*/
#if DTE_AT_EXTERNAL == ON

struct dte_config_ext_at {
	struct confirm 			dte_confirm;
	uchar					int_unit;		/* DTE unit (AT, PAD..) concerned */
	uchar					type;			/* configuration structure type */
											/* DTE_CFIG_EXT_AT_TYPE : AT interpreter extensions */
/* Beginning of specific part */
	uchar					ext_at_nb;		/* number of external AT command prefixes */

	struct {

		uchar		prefix [DTE_MX_EXT_AT_PREFIX_SIZE];/* prefix for the extended AT commands */
									/* must be in uppercase */
		ent_id_t	ent_id;			/* name of the entity hosting the external AT interpreter */
									/* 0: disable the prefix */
		uchar		imm_ok;			/* ON : send an immediate ok when the AT command is entered */

	} at_ext_entries [DTE_MX_CFG_EXT_AT];

};

#define	Dcfg_ext_at_nb				(p_dte_config_ext_at -> ext_at_nb)
#define	Dcfg_ext_at_prefix(i, j)	(p_dte_config_ext_at -> at_ext_entries [i] . prefix [j])
#define	Dcfg_ext_at_ent_id(i)		(p_dte_config_ext_at -> at_ext_entries [i] . ent_id)
#define	Dcfg_ext_at_imm_ok(i)		(p_dte_config_ext_at -> at_ext_entries [i] . imm_ok)
#endif


/*--------------------------------------------------------------------------
 *		Special magic value, for checks
 *-------------------------------------------------------------------------*/
#define	DTE_JN_CHECK				 0
#define	DTE_NA_CHECK			 	 0
#define	DTE_CH_CHECK				 0
#define	DTE_COMM_PORT_CHECK			 0


/*--------------------------------------------------------------------------
 *		Configuration NOK cause codes
 *-------------------------------------------------------------------------*/

#define	DTE_CAUSE_OTHER				(0xFE)	/* 254 7254 0x1C56 Other configuration error */

#define	DTE_CAUSE_INV_GT_BUFFER		(0x71)	/* 113 7113 0x1BC9 'Grand total' configuration buffer must be the first. Diagnostic: number of configuration buffers received */
#define	DTE_CAUSE_INV_EXT_BUFFER	(0x72)	/* 114 7114 0x1BCA Optional configuration buffer received before all basic configurations have been processed. Diagnostic: configuration type */

#define	DTE_CAUSE_JN_NB				(0x81)	/* 129 7129 0x1BD9 Invalid number of junctions. Diagnostic: requested number of junctions */
#define	DTE_CAUSE_CP_NB				(0x82)	/* 130 7130 0x1BDA Invalid number of communication ports. Diagnostic: requested number of communication ports */
#define	DTE_CAUSE_NA_NB				(0x83)	/* 131 7131 0x1BDB Invalid number of network accesses. Diagnostic: requested number of network accesses */
#define	DTE_CAUSE_CALL_NB2			(0x85)	/* 133 7133 0x1BDD Invalid number of calls. Diagnostic: index of DTE channel */
#define	DTE_CAUSE_CH_NB				(0x86)	/* 134 7134 0x1BDE Invalid number of DTE channels. Diagnostic: requested number of DTE channels */
#define	DTE_CAUSE_B_CHAN_NB			(0x87)	/* 135 7135 0x1BDF Invalid number of B-channels. Diagnostic: requested number of B-channels */
#define	DTE_CAUSE_DIR_NB			(0x88)	/* 136 7136 0x1BE0 Invalid number of directory entries. Diagnostic: requested number of directory entries */
#define	DTE_CAUSE_AT_NB				(0x89)	/* 137 7137 0x1BE1 Invalid number of AT interpreters. Diagnostic: requested number of AT interpreters */
#define	DTE_CAUSE_JSIG_NB			(0x8A)	/* 138 7138 0x1BE2 Invalid number of junction signal groups (sync + async). Diagnostic: requested number of junction signal groups */
#define	DTE_CAUSE_CONN_NB			(0x8B)	/* 139 7139 0x1BE3 Invalid number of connections. Diagnostic: requested number of connections */
#define	DTE_CAUSE_CONN_NB2			(0x8C)	/* 140 7140 0x1BE4 Invalid number of connections. Diagnostic: index of DTE channel */
#define	DTE_CAUSE_CONN_NB3			(0x8D)	/* 141 7141 0x1BE5 Invalid number of connections (1 and only 1 connection per DTE channel, please). Diagnostic: index of DTE channel */
#define	DTE_CAUSE_OUT_SERVICE_NB	(0x8E)	/* 142 7142 0x1BE6 Invalid number of outgoing service descriptions. Diagnostic: number of outgoing service descriptions */
#define	DTE_CAUSE_CH_NB2			(0x8F)	/* 143 7143 0x1BE7 Invalid number of DTE channels. Diagnostic: current number of DTE channels */

#define	DTE_CAUSE_JN_CHECK			(0x91)	/* 145 7145 0x1BE9 Invalid junction description structure. Diagnostic: index of junction structure */
#define	DTE_CAUSE_CP_CHECK			(0x92)	/* 146 7146 0x1BEA Invalid communication port description structure. Diagnostic: index of communication port structure */
#define	DTE_CAUSE_NA_CHECK			(0x93)	/* 147 7147 0x1BEB Invalid network access description structure. Diagnostic: index of network access structure */
#define	DTE_CAUSE_CH_CHECK			(0x95)	/* 149 7149 0x1BED Invalid DTE channel description structure. Diagnostic: index of DTE channel structure */
#define	DTE_CAUSE_INV_CONF_TYPE		(0x96)	/* 150 7150 0x1BEE Invalid configuration type. Diagnostic: configuration type */
#define	DTE_CAUSE_INV_SLOT_STR		(0x97)	/* 151 7151 0x1BEF Invalid time slot string. Diagnostic: index of the errored time slot in configuration structure */
#define	DTE_CAUSE_TOO_MANY_SLOTS	(0x98)	/* 152 7152 0x1BF0 Too many slots requested. Diagnostic: 0 */

#define	DTE_CAUSE_NA_INV_CH			(0xA0)	/* 160 7160 0x1BF8 Invalid channel in network access context description. Diagnostic: internal network access index */
#define	DTE_CAUSE_NA_INV_JN			(0xA1)	/* 161 7161 0x1BF9 Invalid channel in network access context description. Diagnostic: internal network access index */
											/* 162 7162 0x1BFA Reserved */
#define	DTE_CAUSE_NA_INV_ID			(0xA3)	/* 163 7163 0x1BFB Invalid network access identifier. Diagnostic: index of network access structure */
#define	DTE_CAUSE_NA_INV_NB_CALL	(0xA4)	/* 164 7164 0x1BFC Invalid number of calls for the network access. Diagnostic: network access identifier (signalling) */
#define	DTE_CAUSE_NA_INV_TYPE		(0xA5)	/* 165 7165 0x1BFD Network access if of invalid or unsupported type. Diagnostic: network access identifier (signalling) */

#define	DTE_CAUSE_CP_INV_ID			(0xA8)	/* 168 7168 0x1C00 Invalid communication port id. Diagnostic: index of communication port structure */
#define	DTE_CAUSE_CP_DTR_POLL		(0xA9)	/* 169 7169 0x1C01 DTR poll requested and not available. Diagnostic: communication port index */
#define	DTE_CAUSE_CALL_NA_NB		(0xB0)	/* 176 7176 0x1C08 Two many calls for a network access. Diagnostic: index of offending call structure */
#define	DTE_CAUSE_OUT_SERVICE_DEF	(0xB1)	/* 177 7177 0x1C09 Redefinition of default outgoing service description. Diagnostic: index of outgoing service description */

#define	DTE_CAUSE_JN_INV_CH			(0xB7)	/* 183 7183 0x1C0F Invalid channel in junction context description. Diagnostic: internal junction index */
#define	DTE_CAUSE_JN_CH_ERR			(0xB8)	/* 184 7184 0x1C10 Inconsistency between DTE channel and junction. Diagnostic: internal junction index */
#define	DTE_CAUSE_JN_CH_DIS			(0xB9)	/* 185 7185 0x1C11 DTE channel associated to junction is disabled. Diagnostic: internal junction index */
#define	DTE_CAUSE_JN_UND_SPEED		(0xBA)	/* 186 7186 0x1C12 Undefined junction speed. Diagnostic: index of junction structure */
											/* 				   (Use 'external clock' configuration field */
#define	DTE_CAUSE_JN_INV_ID			(0xBB)	/* 187 7187 0x1C13 Invalid junction id. Diagnostic: index of junction structure */

#define	DTE_CAUSE_CH_INV_NA_1		(0xC1)	/* 193 7193 0x1C19 Invalid nai in DTE channel description (or in 'associated na', if DTE channel points to NAI_NIL). Diagnostic: index of DTE channel structure */
#define	DTE_CAUSE_CH_INV_NA_2		(0xC2)	/* 194 7194 0x1C1A Invalid nai in DTE channel 'associated na' description. Diagnostic: index of 'associated na' structure */
#define	DTE_CAUSE_CH_INV_NA_3		(0xC3)	/* 195 7195 0x1C1B Invalid default associated na DTE channel 'associated na' description. Diagnostic: 0 */
#define	DTE_CAUSE_CH_INV_NA_4		(0xC4)	/* 196 7196 0x1C1C An associated na was specified twice in the 'associated nas' description. Diagnostic: index of 'associated na' structure */
#define	DTE_CAUSE_CH_INV_NA_5		(0xC5)	/* 197 7197 0x1C1D Two associated na were specified with the same 'user id' in the 'associated nas' description. Diagnostic: index of 'associated na' structure */
											/* */
#define	DTE_CAUSE_CH_INV_CP			(0xC9)	/* 201 7201 0x1C21 Invalid communication port id in DTE channel description. Diagnostic: index of DTE channel structure */
#define	DTE_CAUSE_CH_INV_JN			(0xCA)	/* 202 7202 0x1C22 Invalid junction id in DTE channel description. Diagnostic: index of DTE channel structure */
#define	DTE_CAUSE_CH_INV_CALL		(0xCB)	/* 203 7203 0x1C23 Invalid call id (already used) in DTE channel description. Diagnostic: index of DTE channel structure */
#define	DTE_CAUSE_CH_INV_CH			(0xCC)	/* 204 7204 0x1C24 Invalid DTE channel id (DTE channel 0 is forbidden) in DTE channel description. Diagnostic: index of DTE channel structure */
/*#define DTE_CAUSE_CH_INV_SERVICE	(0xCD)*//* 205 7205 0x1C25 Invalid DTE channel service. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_INV_AND_Q		(0xCE)	/* 206 7206 0x1C26 Invalid &Q parameter. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_INV_AND_C		(0xCF)	/* 207 7207 0x1C27 Invalid &C parameter. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_INV_AND_D		(0xD0)	/* 208 7208 0x1C28 Invalid &D parameter. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_INV_AND_R		(0xD1)	/* 209 7209 0x1C29 Invalid &R parameter. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_INV_AND_S		(0xD2)	/* 210 7210 0x1C2A Invalid &S parameter. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_INV_S116		(0xD3)	/* 211 7211 0x1C2B Invalid S116 parameter. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_DCC			(0xD4)	/* 212 7212 0x1C2C Invalid DCC parameters. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_INV_ID			(0xD5)	/* 213 7213 0x1C2D Invalid DTE channel identifier. Diagnostic: index of the DTE channel structure */
#define	DTE_CAUSE_CH_V120			(0xD6)	/* 214 7214 0x1C2E Invalid V.120 parameters. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_PPP			(0xD7)	/* 215 7215 0x1C2F Error while initializing PPP DTE channel. Diagnostic: user DTE channel id */
#define	DTE_CAUSE_CH_FAX_FC			(0xD8)	/* 216 7216 0x1C30 Field 'to_ph_queue_high_mark' is zero in a DTE channel configuration for fax. Diagnostic : DTE channel id */
											/*                 It must be non zero, else no flow control will be exercised */

#define	DTE_CAUSE_JN_HARD			(0xE2)	/* 226 7226 0x1C3A Unable to initialize asynchronous junction hardware. Diagnostic: junction index */
#define	DTE_CAUSE_CP_HARD			(0xE3)	/* 227 7227 0x1C3B Unable to initialize communication port hardware. Diagnostic: communication port index */

#define	DTE_CAUSE_ALLOC				(0xF1)	/* 241 7241 0x1C49 Unable to allocate memory for DTE contexts. Diagnostic: id of the offending allocation */
#define	DTE_CAUSE_ATTACH			(0xF2)	/* 242 7242 0x1C4A Unable to configure 'attach/detach' contexts */
#define	DTE_CAUSE_TIMER				(0xF3)	/* 243 7243 0x1C4B Unable to allocate timer */
#define	DTE_CAUSE_RESET_CONFIG		(0xF4)	/* 244 7244 0x1C4C Configuration received although DTE_INT is already configured and RESET_CONFIG is OFF */


/*--------------------------------------------------------------------------
 *		Communication port id codes
 *-------------------------------------------------------------------------*/
#define	DTE_COMM_PORT_ID_NIL		(0xFF)	/* No associated communication port */

/*--------------------------------------------------------------------------
 *		Communication port type codes
 *-------------------------------------------------------------------------*/
#define	DTE_SYNC_COMM_PORT			'S'		/* Synchronous communication port */
#define	DTE_NULL_COMM_PORT			'?'		/* Empty communication port (NULL device) */


/*--------------------------------------------------------------------------
 *		Network line type codes
 *-------------------------------------------------------------------------*/
#define	DTE_ANALOG_LINE				'A'		/* Analog switched line */
#define	DTE_LEASED_LINE				'L'		/* Analog leased line */
#define	DTE_ISDN_LINE				'I'		/* ISDN line  */
#define	DTE_AGGREGATED_ISDN_LINE	'i'		/* ISDN line, with multiple parallel calls */


/*--------------------------------------------------------------------------
 *		Codes for service offered by the DCE to the DTE
 *		S111 possible values, as seen by DTE.
 *------------------------------------------------------------------------*/
#define	DTE_USER_UNDEFINED_SERVICE		0		/* Undefined service */
#define	DTE_USER_VOICE_SERVICE			1		/* Voice service */
#define	DTE_USER_MODEM_SERVICE			2		/* Modem service */
#define	DTE_USER_RAW_DATA_SERVICE		3		/* Raw data service */
#define	DTE_USER_FAX_SERVICE			4		/* Fax service */
#define	DTE_USER_V14_SERVICE			5		/* Extended V.14 service */
#define	DTE_USER_ASYN_V110_SERVICE		6		/* Asynchronous V.110 service */
#define	DTE_USER_PAD_SERVICE			7		/* PAD service, B channel */
#define	DTE_USER_ASYN_V120_SERVICE		8		/* Asynchronous V.120 service */
#define	DTE_USER_DATA_RELAY_SERVICE		10		/* Relay data service (Physical relay) */
#define	DTE_USER_RAW_TELEPHONY_SERVICE	11		/* Raw telephony service */
#define	DTE_USER_PH_V110_SERVICE		12		/* Physical V.110 service */
#define	DTE_USER_ASYN_HDLC_SERVICE		14		/* Asynchronous over HDLC service */
#define	DTE_USER_CF_V110_SERVICE		15		/* CF over V.110 service */

#define	DTE_USER_DATA_XPT_SERVICE		DTE_USER_DATA_RELAY_SERVICE	/* Obsolete name */
#define	DTE_USER_V120_SERVICE    		DTE_USER_ASYN_V120_SERVICE	/* Obsolete name */


/*--------------------------------------------------------------------------
 *		Codes for data compression
 *------------------------------------------------------------------------*/
#define	DTE_DC_NONE				'0'			/* No data compression */
#define	DTE_DC_V42BIS			'V'			/* V.42bis data compression */
#define	DTE_DC_MNP5				'5'			/* MNP-5 data compression */
#define	DTE_DC_STAC_LZS			'S'			/* Stac Lzs data compression */

/*--------------------------------------------------------------------------
 *		Codes for error correction
 *------------------------------------------------------------------------*/
#define	DTE_EC_NONE				'0'			/* No error correction */
#define	DTE_EC_LAPM				'L'			/* LAP-M error correction */
#define	DTE_EC_MNP4				'4'			/* MNP-4 error correction */

/*--------------------------------------------------------------------------
 *		Speaker behaviour codes
 *-------------------------------------------------------------------------*/
#define	DTE_SPK_OFF				0			/* Always OFF */
#define	DTE_SPK_TIL_CD			1			/* ON until CD detected */
#define	DTE_SPK_ON				2			/* Always ON */
#define	DTE_SPK_DIAL_TIL_CD 	3			/* ON from dial until CD detected */


/*--------------------------------------------------------------------------
 *		Speaker level codes
 *-------------------------------------------------------------------------*/
#define	DTE_SPK_LOW_LEVEL		0			/* Low level */
#define	DTE_SPK_MEDIUM_LEVEL	2			/* Medium level */
#define	DTE_SPK_HIGH_LEVEL		3			/* High level */

	/* interface unit : AT interpreter, PAD/X.25 or PAD/V.120 */

#define		DTE_AT_INT_UNIT					'A'
#define		DTE_PAD_INT_UNIT				'P'
#define     DTE_V120_INT_UNIT				'2'
#define     DTE_VOID_INT_UNIT				'!'		/* void unit. Do not use */


/*--------------------------------------------------------------------------
 *		Extended configuration commands  (AT#xxx)
 *-------------------------------------------------------------------------*/

#if DTE_EXT_CNF == ON

	/*-----------------------------------------------------------------------
	 *				Initialization macros
	 *----------------------------------------------------------------------*/
	/*----------*/
	/* syntaxes */
	/*----------*/
#define	Xcc_syntax_keyword(keyword, help)									\
	{ keyword, P_NIL, help, XCC_READ_ONLY, XCC_KEYWORD, 0, 0
#define	Xcca_syntax_keyword(keyword, sec, help)								\
	{ keyword, sec, help, XCC_READ_ONLY, XCC_KEYWORD, 0, 0

#define	Xcc_syntax_int(keyword, help, access, par_type, min, max)			\
	{ keyword, P_NIL, help, access, par_type, min, max
#define	Xcca_syntax_int(keyword, sec, help, access, par_type, min, max)		\
	{ keyword, sec, help, access, par_type, min, max

#define	Xcc_syntax_isdn_addr(keyword, help, access)							\
	{ keyword, P_NIL, help, access, XCC_IA_ISDN_ADDR, DTE_ISDN_ADDR_SIZE, 0
#define	Xcca_syntax_isdn_addr(keyword, sec, help, access)					\
	{ keyword, sec, help, access, XCC_IA_ISDN_ADDR, DTE_ISDN_ADDR_SIZE, 0
#define	Xcc_syntax2_isdn_addr(keyword, help, access, length)				\
	{ keyword, P_NIL, help, access, XCC_IA_ISDN_ADDR, 						\
	Min (length, DTE_ISDN_ADDR_SIZE), 0
#define	Xcca_syntax2_isdn_addr(keyword, sec, help, access, length)			\
	{ keyword, sec, help, access, XCC_IA_ISDN_ADDR, 						\
	  Min (length, DTE_ISDN_ADDR_SIZE), 0

#define	Xcc_syntax_isdn_sub_addr(keyword, help, access)						\
	{ keyword, P_NIL, help, access, XCC_IA_ISDN_SUB_ADDR, 					\
	  DTE_ISDN_SUB_ADDR_SIZE, 0
#define	Xcca_syntax_isdn_sub_addr(keyword, sec, help, access)				\
	{ keyword, sec, help, access, XCC_IA_ISDN_SUB_ADDR, 					\
	  DTE_ISDN_SUB_ADDR_SIZE, 0
#define	Xcc_syntax2_isdn_sub_addr(keyword, help, access, length)			\
	{ keyword, P_NIL, help, access, XCC_IA_ISDN_SUB_ADDR, 					\
	  Min (length, DTE_ISDN_SUB_ADDR_SIZE), 0
#define	Xcca_syntax2_isdn_sub_addr(keyword, sec, help, access, length)		\
	{ keyword, sec, help, access, XCC_IA_ISDN_SUB_ADDR, 					\
	  Min (length, DTE_ISDN_SUB_ADDR_SIZE), 0

#define	Xcc_syntax_slot(keyword, help, access)								\
	{ keyword, P_NIL, help, access, XCC_SLOT_STR, DTE_MX_SLOT_STR_SIZE, 0
#define	Xcca_syntax_slot(keyword, sec, help, access)						\
	{ keyword, sec, help, access, XCC_SLOT_STR, DTE_MX_SLOT_STR_SIZE, 0
#define	Xcc_syntax2_slot(keyword, help, access, length)						\
	{ keyword, P_NIL, help, access, XCC_SLOT_STR, 							\
	  Min (length, DTE_MX_SLOT_STR_SIZE), 0
#define	Xcca_syntax2_slot(keyword, sec, help, access, length)				\
	{ keyword, sec, help, access, XCC_SLOT_STR, 							\
	  Min (length, DTE_MX_SLOT_STR_SIZE), 0

#define	Xcc_syntax_string(keyword, help, access, min_length, max_length)	\
	{ keyword, P_NIL, help, access, XCC_STRING, min_length, max_length
#define	Xcca_syntax_string(keyword, sec, help, access, min_length, 			\
	max_length)																\
	{ keyword, sec, help, access, XCC_STRING, min_length, max_length

#define	Xcc_syntax_time(keyword, help, access)								\
	{ keyword, P_NIL, help, access, XCC_TIME, DTE_MX_TIME_STR_SIZE, 0
#define	Xcca_syntax_time(keyword, sec, help, access)						\
	{ keyword, sec, help, access, XCC_TIME, 0, 0

	/*---------*/
	/* actions */
	/*---------*/
#define	Xcc_action_help()		XCC_ACT_HELP, P_NIL, 0, 0, 0, 0, 0 }
#define	Xcca_action_help_access(h, read_access, write_access, list_access)	\
			XCC_ACT_HELP, P_NIL, h, 0, read_access, write_access, list_access }
#define	Xcca_action_help(h)		Xcca_action_help_access(h, 0, 0, 0)

#define	Xcc_action_list()		XCC_ACT_LIST, P_NIL, 0, 0, 0, 0, 0 }
#define	Xcca_action_list_access(l, read_access, write_access, list_access)	\
			XCC_ACT_LIST, P_NIL, l, 0, read_access, write_access, list_access }
#define	Xcca_action_list(l)		Xcca_action_list_access(l, 0, 0, 0)

#define	Xcc_action_and_f()		XCC_ACT_AND_F, P_NIL, 0, 0, 0, 0, 0 }
#define	Xcc_action_z()			XCC_ACT_Z, P_NIL, 0, 0, 0, 0, 0  }
#define	Xcca_action_z(z)		XCC_ACT_Z, P_NIL, z, 0, 0, 0, 0  }

#define	Xcc_action_time()		XCC_ACT_TIME, P_NIL, 0, 0, 0, 0, 0 }

#if DTE_EXT_CNF_USER == ON
#	define	_USER_FCT_NIL	P_NIL,
#else
#	define	_USER_FCT_NIL
#endif

#define	Xcc_action_sm_access(par_id, read_access, write_access, list_access)	\
			XCC_ACT_SM, P_NIL, _USER_FCT_NIL par_id, 0, read_access, write_access, list_access }
#define	Xcc_action_sm(par_id)	Xcc_action_sm_access(par_id, 0, 0, 0)

#define	Xcc_action_sm_x25_packet_size(par_id_1, par_id_2)					\
			XCC_ACT_SM_X25_PACKET_SIZE, P_NIL, _USER_FCT_NIL par_id_1, par_id_2 , 0, 0, 0 }

#define	Xcc_action_ram_access(base, size, index, read_access, write_access, list_access)		\
			XCC_ACT_RAM, (uchar FAR *)base, _USER_FCT_NIL size, index, read_access, write_access, list_access  }
#define	Xcc_action_ram(base, size, index)									\
			Xcc_action_ram_access(base, size, index, 0, 0, 0)

#if DTE_EXT_CNF_USER == ON
#	define	Xcc_action_user(user_fct)										\
			XCC_ACT_USER, P_NIL, user_fct, 0, 0, 0, 0, 0 }

#	define	Xcc_action_sm_user_access(user_fct, par_id, read_access, write_access, list_access)	\
			XCC_ACT_SM_USER, P_NIL, user_fct, par_id, 0, read_access, write_access, list_access }
#	define	Xcc_action_sm_user(user_fct, par_id)							\
				Xcc_action_sm_user_access(user_fct,par_id, 0, 0, 0)
#endif

#define	Xcc_sentinel														\
			{ P_NIL }


	/*-----------------------------------------------------------------------
	 *				Extended configuration commands description
	 *----------------------------------------------------------------------*/

struct dte_xcc_dsc {

	char		*keyword;			/* string, AT parameter (command) name */
	char		*sec_keyword;		/* string, secondary AT parameter (command) name. For example an abbreviation. */
	char		*help;				/* string, help string, or P_NIL */

	uchar		flags;				/* descriptive flags */
#	define		XCC_WRITE_ONLY	(0x01)								/* parameter can be set */
#	define		XCC_READ_ONLY	(0x02)								/* parameter can be read */
#	define		XCC_RW			(XCC_READ_ONLY | XCC_WRITE_ONLY)	/* parameter can be set and read */

	uchar		par_type;			/* parameter type */
#	define		XCC_KEYWORD				('k')	/* no parameter, only single keyword */
#	define		XCC_CHAR				('c')	/* parameter has the length of a char */
#	define		XCC_SHORT				('s')	/* parameter has the length of a short */
#	define		XCC_SHORT_POWER_2		('3')	/* parameter has the length of a short and is a power of two */
#	define		XCC_INT					('i')	/* parameter has the length of an int */
#	define		XCC_INT_POWER_2			('2')	/* parameter has the length of an int and is a power of two */
#	define		XCC_LONG				('l')	/* parameter has the length of a long */
#	define		XCC_STRING				('S')	/* parameter is string */
#	define		XCC_IA_ISDN_ADDR		('A')	/* parameter is an ISDN address */
#	define		XCC_IA_ISDN_SUB_ADDR	('B')	/* parameter is an ISDN sub-address */
#	define		XCC_SLOT_STR			('t')	/* parameter is a time slot string */
#	define		XCC_TIME				('T')	/* parameter is a date/time description */

	long 		min_val;			/* integral type : minimum value */
									/* XCC_STRING : minimum string length */
									/* XCC_IA_ISDN_ADDR : maximum length of ISDN address */
									/* XCC_IA_ISDN_SUB_ADDR : maximum length of the ISDN subaddress */
									/* XCC_SLOT_STR : maximum length of the slot string */
	long 		max_val;			/* integral type : maximum value */
									/* XCC_STRING : maximum string length */

	uchar 		action;				/* action to perform */
#	define	 	XCC_ACT_HELP	('h')	/* display help */
#	define	 	XCC_ACT_LIST	('l')	/* display list of parameters values */
#	define	 	XCC_ACT_RAM		('r')	/* set/get in RAM */
#	define	 	XCC_ACT_SM		('s')	/* set/get through SM */
#	define		XCC_ACT_SM_X25_PACKET_SIZE	('X') /* set/get through SM, X.25 packet size */
#	define	 	XCC_ACT_TIME	('t')	/* set/get date and time */
#	define	 	XCC_ACT_Z		('z')	/* perform an unconditional AT Z */
#	define	 	XCC_ACT_AND_F	('f')	/* perform an unconditional AT &F */
#	define	 	XCC_ACT_USER	('u')	/* call a user routine */
#	if DTE_EXT_CNF_USER == ON
#		define	XCC_ACT_SM_USER	('U')	/* set/get through SM + user function */
#	endif

	uchar FAR	*stor_base;			/* storage base address */

#	if DTE_EXT_CNF_USER == ON

#		if NEW_FCT_STYLE == ON
			uchar	(FAR *p_user_fct)(		/* address of user function */
							 uchar 		 fn,
							 uchar 		 arg_type,
							 uchar 		 jn_id,
							 uchar 		 dte_ch_id,
							 uchar 		 nai,
							 uchar 		 comm_port_id,
							 long  FAR 	*p_long,
							 uchar FAR 	*p_str);
#		else
			uchar	(FAR *p_fct)();			/* address of user function */
#		endif

#		define	DTE_UF_FN_READ		'r'		/* function: read */
#		define	DTE_UF_FN_WRITE		'w'		/* function: write */
#		define	DTE_UF_FN_ERASE		'e'		/* function: erase */
#		define	DTE_UF_ARG_LONG		'l'		/* argument type: long */
#		define	DTE_UF_ARG_STRING	's'		/* argument type: string */
	/*-----------------------------------------------------------------------
	 *	p_user_fct is the address of a user function, which is called upon
	 *	recognition of the commands
	 *		"AT#xxx=val" 	(fn == DTE_UF_FN_WRITE) 	or
	 *		"AT#xxx-"		(fn == DTE_UF_FN_ERASE) 	or
	 *		"AT#xxx?" 		(fn == DTE_UF_FN_READ).
	 *
	 *	return value : OK, NOK or CONTINUE
	 *		OK		: command execution is terminated successfully
	 *		NOK		: command execution is terminated in error
	 *		CONTINUE: command execution is not terminated
	 *	fn : (input argument)
	 *		- DTE_UF_FN_WRITE	: AT command "AT#xxx=val"
	 *		- DTE_UF_FN_ERASE	: AT command "AT#xxx-"
	 *		- DTE_UF_FN_READ	: AT command "AT#xxx?"
	 *	arg_type : (input argument)
	 *		DTE_UF_ARG_LONG   : argument is long, found at p_long
	 *		DTE_UF_ARG_STRING : argument is a string, found at p_str
	 *		the associated syntax for the "#xxx" command may be
	 *		- XCC_LONG  		(arg_type will be DTE_UF_ARG_LONG)
	 *		- XCC_STRING		(arg_type will be DTE_UF_ARG_STRING)
	 *	jn_id 		: junction (DTE port) id (input argument)
	 *	dte_ch_id 	: DTE channel id         (input argument)
	 *	nai 		: network (ISDN, GSTN, etc.) access identifier
	 *				  (input argument)
	 *	comm_port_id: communication port id. May be DTE_COMM_PORT_ID_NIL
	 *				  (meaning : no associated communication port)
	 *				  (input argument)
	 *
	 *	p_long : address of a long variable, argument
	 *		when arg_type == DTE_UF_ARG_LONG :
	 *			input argument  (fn == DTE_UF_FN_WRITE) or
	 *			output argument (fn == DTE_UF_FN_READ. The user
	 *			function will set the value at p_long).
	 *			When fn is DTE_UF_FN_ERASE, p_long is undefined.
	 *		when arg_type == DTE_UF_ARG_STRING :
	 *			when fn == DTE_UF_FN_WRITE : input argument, length of the
	 *				string (without the terminating zero)
	 *			when fn == DTE_UF_FN_ERASE : undefined
	 *			when fn == DTE_UF_FN_READ : input/output argument
	 *				Upon entry, *p_long gives the available length (without
	 *				terminating zero) for storing the returned string.
	 *				Upon exit, *p_long gives the actual length (without
	 *				terminating zero) used for storing the returned string.
	 *				The user function has to set the value at p_long.
	 *
	 *	p_str : address of a string variable, argument
	 *		significant only when arg_type == DTE_UF_ARG_STRING.
	 *			when fn == DTE_UF_FN_WRITE : input argument (nul terminated
	 *				string)
	 *			when fn == DTE_UF_FN_ERASE : undefined
	 *			when fn == DTE_UF_FN_READ : ouput argument (nul terminated
	 *				string).
	 *				The user function has to set the string at p_str.
	 *		The strings are nul ('\0') terminated.
	 *
	 *---------------------------------------------------------------------*/
#	endif /* DTE_EXT_CNF_USER == ON */


	short		stor_size_par_id;	/* storage recurrency factor (sizeof struct), */
									/* or: (first) SM parameter id, or */
									/* for XCC_ACT_HELP and XCC_ACT_LIST:	*/
									/* 	0: display help/list using primary keyword. */
									/* 	1: display help/list using secondary keyword */
	short		idx;				/* index to use. If >= 0, use immediate value */
									/* else ( < 0) one of XCC_IDX_JN, XCC_IDX_NA, XCC_IDX_CH (see below) */
									/* or: second SM parameter id */
	uchar		read_access_rights;	/* Access rights necessary for reading */
									/* (executing the command in 'read' form) */
									/* 0: no rights necessary. Else DTE_ACCESS_USER, DTE_ACCESS_INSTALLATION, etc. */
	uchar		write_access_rights;/* Access rights necessary for writing */
									/* (executing the command in 'write' or 'execute' form) */
	uchar		list_access_rights;/* Access rights necessary for listing */
									/* (executing the command in 'list' or 'help' form) */
};

#endif /* endif DTE_EXT_CNF */

#	define	 	XCC_IDX_JN		(-1)	/* index through DTE-DCE junction index, or through DTE-DTE junction identifier, according to DTE_INT configuration */
#	define		XCC_IDX_NA		(-2)	/* index through network access index, or through network access identifier, according to DTE_INT configuration */
#	define		XCC_IDX_CH		(-3)	/* index through DTE channel index, or through DTE channel unique identifier identifier, according to DTE_INT configuration */
#	define		XCC_IDX_AT		(-4)	/* index through AT context index	*/

/*---------------------------------------------------------------------------
 *	DTE_INT time representation
 *-------------------------------------------------------------------------*/
#define YEAR_BASE			(94)		/* year base */
#define	MAX_NB_YEARS		128
#define	YEAR_00				(1900)
#define	YEAR_0				(YEAR_00+YEAR_BASE)
#define	YEAR_1				(YEAR_0 + MAX_NB_YEARS)

struct dte_time {
	uchar		year;			/* 0..254, with respect to YEAR_BASE; TIME_ITEM_NIL: undefined */
	uchar		month;			/* 1..12, TIME_ITEM_NIL: undefined */
	uchar		date;			/* 1..31, TIME_ITEM_NIL: undefined */
	uchar		hour;			/* 0..23, TIME_ITEM_NIL: undefined */
	uchar		minute;			/* 0..59, TIME_ITEM_NIL: undefined */
	uchar		second;			/* 0..59, TIME_ITEM_NIL: undefined */
	uchar		day_of_week;	/* 1..7, (1: monday), TIME_ITEM_NIL: undefined */
};
#define		TIME_ITEM_NIL				0xFF
#define		Time_year					(p_dte_time -> year)
#define		Time_month					(p_dte_time -> month)
#define		Time_date					(p_dte_time -> date)
#define		Time_hour					(p_dte_time -> hour)
#define		Time_minute					(p_dte_time -> minute)
#define		Time_second					(p_dte_time -> second)
#define		Time_day_of_week			(p_dte_time -> day_of_week)



#define	DTE_CHAR_8_NONE		0	/* 8-bit, no parity */
#define	DTE_CHAR_7_EVEN		1	/* 7-bit, parity even */
#define	DTE_CHAR_7_ODD		2	/* 7-bit, parity odd */

#define	DTE_KEYWORD_ESCAPE		0x00		/* keyword, escape */
#	define	DTE_ESCAPE_JN_RATE		'r'		/* followed by junction rate, in internal form */

/*---------------------------------------------------------------------------
 *		Function prototyping
 *-------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	   uchar	dte						(struct message FAR *);
	   void		dte_int_var_init		(void);
	   uchar 	dte_slot_check_cur_time (void);
#else
	   uchar	dte						();
	   void		dte_int_var_init		();
	   uchar 	dte_slot_check_cur_time ();
#endif


/*---------------------------------------------------------------------------
 *		For PAD use
 *-------------------------------------------------------------------------*/

	extern	uchar FAR *					p_pdte_ctxt;
#	define	P_pdte_ctxt					(p_pdte_ctxt)
#	define	Get_pdte_ctxt(jn_id)		dte_acc_jn_from_id (jn_id)

#if NEW_FCT_STYLE == ON
		uchar		dte_acc_jn_from_id		(uchar);
		void 		dte_dcc_pad_break_in 	(void);
		void 		dte_dcc_pad_busy_in 	(uchar);
		void 		dte_dcc_pad_data_in 	(struct message FAR *);
		void 		dte_dcc_v120_data_in 	(struct message FAR *);
		void   		dte_jn_change_mode		(uchar, uchar);
		nai_t 		dte_jn_id				(void);
		uchar 		dte_jn_select			(nai_t jn_id);
		uchar		dte_jn_get_parity 		(void);
		uchar		dte_jn_get_pad_rate		(void);
		void		dte_pad_call_rq_sent 	(void);
		void		dte_pad_vc_new_state_in	(uchar);
		void		dte_v120_link_new_state (uchar);
		void		dte_v120_report_v42b_negotiation (uchar ok, uchar p0, ushort p1, uchar p2);
		int	 		ltoa_far 				(long, char FAR *, int);
#else
		uchar		dte_acc_jn_from_id		();
		void 		dte_dcc_pad_break_in 	();
		void 		dte_dcc_pad_busy_in 	();
		void 		dte_dcc_pad_data_in 	();
		void 		dte_dcc_v120_data_in 	();
		void		dte_jn_change_mode		();
		uchar		dte_jn_get_parity 		();
		uchar		dte_jn_get_pad_rate		();
		nai_t 		dte_jn_id				();
		uchar 		dte_jn_select			();
		void		dte_pad_call_rq_sent 	();
		void		dte_pad_vc_new_state_in	();
		void		dte_v120_link_new_state	();
		void		dte_v120_report_v42b_negotiation ();
		int	 		ltoa_far 				();
#endif

#define	Dte_change_mode(new_mode, connected)	dte_jn_change_mode (new_mode, connected)
#define	Dte_pad_vc_new_state_in(new_state)		dte_pad_vc_new_state_in (new_state)
#define	Dte_v120_link_new_state_in(new_state)	dte_v120_link_new_state (new_state)
#define	Dte_v120_report_v42b_negotiation(ok, p0, p1, p2)	\
												dte_v120_report_v42b_negotiation (ok, p0, p1, p2)


/*---------------------------------------------------------------------------
 *						SIMULATION
 *-------------------------------------------------------------------------*/

#if SIMULATION == ON

/*
 *	Simulation functions prototyping.
 */

#	if NEW_FCT_STYLE == ON

		uchar	ana_sdu_dte				(struct message FAR *);
		uchar	ana_sdu_ti_dte			(struct message FAR *);
		uchar 	build_it_to_dte			(void);
		uchar 	build_cf_to_dte			(void);
		uchar	build_sdu_acu_to_dte	(void);
		uchar 	build_sdu_user_to_dte	(void);

#	else

		uchar	ana_sdu_dte				();
		uchar	ana_sdu_ti_dte			();
		uchar   build_it_to_dte			();
		uchar   build_cf_to_dte			();
		uchar	build_sdu_acu_to_dte	();
		uchar 	build_sdu_user_to_dte	();

#	endif

#endif			/* SIMULATION */

#endif

/*EOF*/
