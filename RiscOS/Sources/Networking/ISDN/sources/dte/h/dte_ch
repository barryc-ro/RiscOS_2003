
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * 	filename - dte_ch.h
 *
 * $Revision$
 *
 * $Date$
 *
 *		Declarations of the DTE channel context
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    TR29-PACK                                        |*/
/*|    DTE_INT Entity                                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef	_DTE_CH
#define _DTE_CH


#define	DTE_PAD_V120_PROFILE_STR_SIZE	2		/* Size of a PAD or V.120 profile string (identifier) */

#if DTE_PAD_V120_COMPRESSION == ON
#	include		"dcc_int.h"
#endif

struct dte_channel_ctxt {

#if DTE_ASSERT == ON
	uchar			dump_id [4];			/* For dumps */
#endif

	uchar			ix;					/* internal DTE channel index */

	uchar			id;					/* external (user, AT&O command) DTE channel id */
	uchar			unique_id;			/* internal unique DTE channel id */

	uchar			jn_id;				/* associated DTE junction identifier */
	uchar			jn_ix;				/* associated DTE junction index */
	uchar			conn_ix;			/* associated data connection index */
	uchar			cc_service_list_id;	/* DTE_INT / Call Control correlation parameter. 0: none */

#if DTE_USE_CP == ON
	comm_port_ix_t	comm_port_ix;		/* associated communication port index */
										/* DTE_COMM_PORT_IX_NIL: no associated communication port */
	uchar			comm_port_state;	/* (copy of) communication port state */
#endif

#if DTE_SEC_REMOTE_ID == ON
	uchar			callers_list_id;	/* associated callers list id. 0 if none */
#endif

	dte_call_ix_t	nb_calls;			/* number of calls managed by the DTE channel */
	uchar			nb_conns;			/* number of connections managed by the DTE channel */
	dte_call_ix_t	next_idle_call_ix;	/* index of first free call in the list */
	dte_call_ix_t	call_ix [DTE_MX_CALL_PER_CH];	/* managed call indexes */

	struct {							/* DTE channel parameters */
		uchar			init;				/* ON if DTE channel is initialized, else OFF */
		dte_service_t	dte_service;		/* service offered to DTE by DTE_INT */
		uchar			disable;			/* ON: DTE channel is disabled (cannot be selected) */
		uchar			lock_service;		/* ON: lock service. OFF: service can be modified by AT command */

		dte_call_ix_t	mx_act_calls;		/* maximum number of concurrent non idle calls */
		dte_call_ix_t	mx_inc_calls;		/* maximum number of concurrent non idle incoming calls */
		dte_call_ix_t	mx_out_calls;		/* maximum number of concurrent non idle outgoing calls */
		dte_call_ix_t	mx_data_calls;		/* maximum number of concurrent non idle 'data' calls */
		dte_call_ix_t	mx_voice_calls;		/* maximum number of concurrent non idle 'voice' calls */

		uchar			str_format;			/* default string format, for incoming calls */

		uchar			chan_ext_format;	/* 'extended interface' message format */
#		define			DTE_INT_CH_EXT_FMT_SHORT	('s')	/* Extended commands, short form */
#if DTE_EXT_CALL == ON
#		define			DTE_INT_CH_EXT_FMT_LONG		('l')	/* Extended commands, long form */
#endif

		uchar			chan_at_format;		/* 'AT interface' message format */
#		define			DTE_INT_CH_AT_FMT_STD		('A')   /* AT standard format */

#if DTE_MATRA_TA_INTERFACE == ON
#		define			DTE_INT_CH_AT_FMT_TA_1		('M')   /* AT modified format, Matra TA interface compatible */

#endif
		uchar			chan_all_q931_format;/* ON: display all messages related to Q.931 signalling. OFF: display only basic messages */

		dte_call_ix_t	cur_single_call_ix;	/* current single call index, for ATD and ATA commands and autoanswering */
		dte_call_ix_t	cur_conn_call_ix;	/* current call index associated to a data connection */
		dte_call_ix_t	ans_calls;			/* current number of answered incoming calls */
		dte_call_ix_t	out_calls;			/* current number of non idle outgoing calls */
		dte_call_ix_t	data_calls;			/* current number of non idle data calls */
		dte_call_ix_t	voice_calls;		/* current number of non idle voice calls */

		dte_user_call_id_t	call_user_id;	/* last call's identifier for DTE_INT user */
		uchar			call_str_format;	/* last call's string format */
		uchar			call_direction;		/* last call's direction */
		uchar			call_clear_cause;	/* last call's clear cause */
		uchar			call_network_clear_cause;
											/* last call network clear cause */
		long			call_total_cost;	/* last call total cost */

		short			inc_priority;		/* channel priority, with respect to incoming calls */
											/* 0: disable incoming calls. 1: lowest priority. 255: highest priority */
		uchar			inc_manual_answer;	/* ON if manual answer is possible */
		uchar			inc_auto_answer;	/* ON if automatic answer is possible */
		uchar			s0;					/* S0 register, for ISDN and analog */
		uchar			t_p;				/* tone or pulse dialing ('T' or 'P') */

		add_t			def_data_chani;		/* default associated data channel id. 0 : any. */
		uchar			acu_profile;		/* ACU profile (or service) to use for outgoing and incoming calls. 0: use default value (defined by the DTE channel service) */

		add_t			data_chani;			/* data channel id */
		uchar			back_to_cmd;		/* ON if back to command mode */

#if DTE_USE_CP == ON
		uchar			relay_mode;				/* PH_R relay mode : RELAY_STREAM_HDLC, RELAY_STREAM_TRANSPARENT, RELAY_FRAME */
#endif
		uchar			route_mx_nb_buffer;		/* Maximum number of buffers for the route */

		uchar				to_jn_open;			/* ON if junction is open */
		struct message FAR *to_jn_fifo_first;	/* head of the queue of messages for the junction */
		struct message FAR *to_jn_fifo_last;	/* tail of the queue of messages for the junction */

#if DTE_USE_CP == ON
		uchar			dtr_dial_ans;		/* ON if DTR dialing/answering is enabled */
		uchar			dtr_or_ph_r_op_in_progress;	/* ON if DTR operation (dialing or answering) or
													   PH_R dialing is in progress */
#endif
		uchar			jn_speed;			/* Asynchronous junction rate. 0: use default junction rate */
		uchar			and_d;				/* &D : DTR behaviour */
#						define	DTE_AND_D_BASE_MSK		0x0F	/* mask for basic functions */
#						define	DTE_AND_D_EXT_ON_MSK	0x10	/* mask for extensions, processing for DTR ON */
#						define	DTE_AND_D_EXT_ON_AND_Z	0x10	/* execute command stored in &Zxx */
		uchar			and_c;				/* &C : CD  behaviour */

#if DTE_PAD == ON
		uchar			cd_on_in_pad_command;	/* ON : CD is ON in PAD command mode */
#endif

		uchar			and_r;				/* &R : CTS behaviour */
		uchar			and_s;				/* &S : DSR behaviour */
		timer_val_t		s25_hundredths;		/* DTR change detect time, in hundredths of seconds */
		timer_val_t		s25_seconds;		/* DTR change detect time, in seconds */
		struct timer 	s25_timer;			/* S25 timer state */
		timer_val_t		s26;    			/* RTS/CTS delay */
		struct timer 	s26_timer;			/* S26 timer state */

		timer_val_t		s7;					/* Wait for connection delay */
		struct timer 	s7_timer;			/* S7 timer state */

		timer_val_t		s117;    			/* delay between RING messages */
		struct timer 	s117_timer;			/* S117 timer state */

		timer_val_t		org_connect_timer_val;	/* delay between sending CONNECT, when originating */
		timer_val_t		ans_connect_timer_val;	/* delay between sending CONNECT, when answering */
		struct timer 	connect_timer;			/* connect timer state */

#	if DTE_ASYN_TO_PH == ON
		uchar			s118;				/* asynchronous frames format */
#	endif

#	if ((DTE_ISDN_CC == ON) && (DTE_SPF_FACILITY == ON))
		uchar			mgt_fac_code;		/* last management facility code, to confirm */
		uchar			mgt_fac_action;		/* last management facility action, to confirm */
#	endif

		uchar			x_messages;			/* X representation, messages presentation part : result code set */
		uchar			x_busy;				/* X representation, BUSY message enabled */
		uchar			x_no_dial_tone;		/* X representation, NO DIALTONE message enabled */
		uchar			and_q;				/* &Q representation : synchronous/asynchronous/error corrected */
		uchar			w;					/* W representation : negotiation messages options */

#	if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON))
		uchar			mnp4_disable;		/* ON: disable use of MNP4. OFF: enable */
		uchar			n_auto;				/* Select Negociate Handshake */
												/* N0, N1, N2, N3, N4, N5 										*/
#			define		N_AUTO_0			0	/* N0 : Non automatic handshake: Fixed at S37 speed only		*/
#			define		N_AUTO_1			1	/* N1 : Automatic handshake : From S37 speed specified to 300 	*/
#			define		N_AUTO_2			2	/*      without V23 											*/
#			define		N_AUTO_3			3   /* N2 : Automatic handshake : From S37 speed specified to 300 	*/
#			define		N_AUTO_4			4	/*      with V23 												*/
#			define		N_AUTO_5			5	/* N3 : Originate mode : same as N0 							*/
												/* 		Answer mode : same as N1 								*/
												/* N4 : Originate mode : same as N0 							*/
												/* 		Answer mode : same as N2 								*/
												/* N5 : Originate mode : same as N1 							*/
												/* 		Answer mode : same as N0 								*/

		uchar			b003;				/* Modulation to select at 300 bps */
#			define		B003_V21			15 		/* V.21 */
#			define		B003_103			16 		/* Bell 103 */

		uchar			b006;				/* Modulation to select at 600 bps */
#			define		B006_V23_STANDARD	20 		/* V.23 standard half duplex tx75/rx1200 */
#			define		B006_V23_REVERSE	21		/* V.23 reverse  half duplex tx1200/rx75 */
#			define		B006_V23_FULL		23		/* V.23 full duplex, 4-wire, 1200/1200 */

		uchar			b012;				/* Modulation to select at 1200 bps */
#			define		B012_V22			0 		/* V.22 */
#			define		B012_112A			1 		/* Bell 112A */
#			define		B012_V23_STANDARD	2 		/* V.23 standard half duplex tx75/rx1200 */
#			define		B012_V23_REVERSE	3 		/* V.23 reverse  half duplex tx1200/rx75 */
#			define		B012_V23_FULL		5 		/* V.23 full duplex, 4-wire, 1200/1200 */

		uchar			b024;				/* Modulation to select at 2400 bps */
#			define		B024_V22_BIS		30 		/* V.22 Bis */
#			define		B024_V26_BIS		32 		/* V.26 Bis */
#			define		B024_V34			33 		/* V.34 */

#	if DTE_V34 == ON

		uchar			b048;				/* Modulation to select at 4800 bps */
#			define		B048_V32			41 		/* V.32 */
#			define		B048_V32_BIS		255		/* V.32 BIS -> may exist : prepared for future */
#			define		B048_V34			44		/* V.34 */

		uchar			b072;				/* Modulation to select at 7200 bps */
#			define		B072_V32_BIS		52 		/* V.32 Bis*/
#			define		B072_V34			53		/* V.34 */

		uchar			b096;				/* Modulation to select at 9600 bps */
#			define		B096_V32			60 		/* V.32 */
#			define		B096_V32_BIS		255		/* V.32 BIS -> may exist : prepared for future */
#			define		B096_V34			65		/* V.34 */
#			define		B096_VFC			64 		/* V.FC */

		uchar			b120;				/* Modulation to select at 12000 bps */
#			define		B120_V32_BIS		70		/* V.32 BIS */
#			define		B120_V33			255		/* V.33 -> may exist : prepared for future */
#			define		B120_V34			72		/* V.34 */
#			define		B120_VFC			71 		/* V.FC */

		uchar			b144;				/* Modulation to select at 14400 bps */
#			define		B144_V32_BIS		75		/* V.32 BIS -> may exist : prepared for future */
#			define		B144_V33			255		/* V.33 -> may exist : prepared for future */
#			define		B144_V34			77		/* V.34 */
#			define		B144_VFC			76 		/* V.FC */

		uchar			b168_288;			/* Modulation to select from 16800 bps to 28800 bps */
#			define		B168_288_V34		80		/* V.34 */
#			define		B168_288_VFC		81 		/* V.FC */

#	endif /* DTE_V34 == ON */

		uchar			s37;				/* S37 register : line modulation */
#			define		S37_LAST_AT		 0
#			define		S37_00300		 3
#			define		S37_00600		 4
#			define		S37_01200		 5
#			define		S37_02400		 6
#			if DTE_V34 == ON
#				define	S37_04800		 7
#				define	S37_07200		 8
#				define	S37_09600		 9
#				define	S37_12000		10
#				define	S37_14400		11
#				define	S37_16800		26
#				define	S37_19200		12
#				define	S37_21600		33
#				define	S37_24000		29
#				define	S37_26400		34
#				define	S37_28800		15
#			endif

		uchar			s36;				/* S36 register : error correction fallback */
		timer_val_t		s9;					/* S9  register : carrier detect response time */
		timer_val_t		s10;				/* S10 register : delay between lost carrier and hang up */
#	endif


#		if DTE_V34 == ON
			ushort			s109;			/* S109 register : Carrier Speed Selector */
#		endif								/* 16 Bits mapped */ 

#	if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON) || (DTE_PAD_V120_COMPRESSION == ON))
		uchar			s48;				/* S48 register : error correction negociation */
		uchar			req_per_c;			/* %C  representation : (requested) data compression */
#	endif

#	if DTE_PAD_V120_COMPRESSION == ON
		uchar			neg_per_c;			/* negotiated %C representation */
#	endif

#	if DTE_V120 == ON
		struct {              				/* V.120 sub-context */
			uchar		state;				/* V.120 state */
			uchar		link_state;			/* V.120 data link state */
		} v120;
#	endif

#	if DTE_PAD_V120_COMPRESSION == ON

		nai_t			dc_nai;		   		/* associated DC nai, for PAD with Data Compression */
		add_t			dc_stream_id;  		/* associated DC stream id, for PAD with Data Compression */
		uchar			dcc_state;   		/* DCC state for DTE_INT */

#		define			DTE_DCC_ST_COMPRESSION_DENIED	'!'		/* compression denied (probably initialization error) */
#		define			DTE_DCC_ST_IDLE					'0'		/* idle */
#		define			DTE_DCC_ST_INITIALIZING			'I'		/* initializing */
#		define			DTE_DCC_ST_ACTIVE				'A'		/* compression active */


		ushort			v42b_req_p1;		/* P1, requested V.42bis dictionary size */
#		ifndef	DTE_DEF_V42B_DICT_SIZE
#			define		DTE_DEF_V42B_DICT_SIZE			512		/* Default value, small */
#		endif
		ushort			v42b_neg_p1;		/* P1, negotiated V.42bis dictionary size */

		uchar			v42b_req_p2;		/* P2, requested V.42bis dictionary depth */
#		ifndef	DTE_DEF_V42B_STR_SIZE
#			define		DTE_DEF_V42B_STR_SIZE			32		/* Default value */
#		endif
		uchar			v42b_neg_p2;		/* P2, negotiated V.42bis dictionary depth */

#if DTE_V120 == ON
		timer_val_t		v42b_resp_timer_val; /* V.42bis negotiation timer value. 0: no negotiation */
#endif

		/*--------------------*/
		/* Encoder parameters */
		/*--------------------*/
		short			enc_block_size;		/* Encoder block size */
#		ifndef	DTE_DEF_DC_BLOCK_SIZE
#			define		DTE_DEF_DC_BLOCK_SIZE			128		/* Default value */
#		endif

		timer_val_t		enc_flush;			/* Encoder flush timer */
#		ifndef	DTE_DEF_ENC_FLUSH_TIMER_DURATION
#			define		DTE_DEF_ENC_FLUSH_TIMER_DURATION	(200 * M_SCD)
#		endif
		struct timer 	enc_flush_timer;	/* Encoder flush timer state */

		uchar			enc_mx_blocks;		/* Encoder maximum number of blocks */
#		ifndef	DTE_DEF_ENC_MX_BLOCKS
#			define		DTE_DEF_ENC_MX_BLOCKS			5		/* Default value */
#		endif
		uchar			enc_low_mark;		/* Encoder low mark */
#		ifndef	DTE_DEF_ENC_LOW_MARK
#			define		DTE_DEF_ENC_LOW_MARK			1		/* Default value */
#		endif
		uchar			enc_high_mark;		/* Encoder high mark */
#		ifndef	DTE_DEF_ENC_HIGH_MARK
#			define		DTE_DEF_ENC_HIGH_MARK			4		/* Default value */
#		endif
		uchar			enc_th_low_traffic;	/* Encoder traffic low threshold */
#		ifndef	DTE_DEF_ENC_TH_LOW_TRAFFIC
#			define		DTE_DEF_ENC_TH_LOW_TRAFFIC		0		/* Default value */
#		endif

		uchar			enc_dc_busy;		/* Encoder, DC busy */
		uchar			enc_x25_v120_busy;	/* Encoder, X.25 or V.120 busy */


		/*--------------------*/
		/* Decoder parameters */
		/*--------------------*/
		short			dec_block_size;		/* Decoder block size */

		timer_val_t		dec_flush;			/* Decoder flush timer */
#		ifndef	DTE_DEF_DEC_FLUSH_TIMER_DURATION
#			define		DTE_DEF_DEC_FLUSH_TIMER_DURATION	(200 * M_SCD)
#		endif
		struct timer 	dec_flush_timer;	/* Decoder flush timer state */

		short			dec_low_data_size;	/* Decoder low data size. Received data under this size will flushed immediately */
#		ifndef	DTE_DEF_DEC_LOW_DATA_SIZE
#			define		DTE_DEF_DEC_LOW_DATA_SIZE		20		/* Default value */
#		endif

		uchar			dec_low_mark;		/* Decoder low mark */
#		ifndef	DTE_DEF_DEC_LOW_MARK
#			define		DTE_DEF_DEC_LOW_MARK			1		/* Default value */
#		endif

		uchar			dec_high_mark;		/* Decoder high mark */
#		ifndef	DTE_DEF_DEC_HIGH_MARK
#			define		DTE_DEF_DEC_HIGH_MARK			4		/* Default value */
#		endif

		uchar			dec_th_low_traffic;	/* Decoder traffic low threshold */
#		ifndef	DTE_DEF_DEC_TH_LOW_TRAFFIC
#			define		DTE_DEF_DEC_TH_LOW_TRAFFIC		0		/* Default value */
#		endif

		uchar			dec_dc_busy;		/* Decoding, DC busy */
		uchar			dec_jn_busy;		/* Decoding, DTE busy */

		struct dcc_ctx	dcc_ctxt;			/* DCC context */

#	endif

		uchar			int_unit;			/* interface unit : AT or PAD */
		uchar			start_pad_unit;		/* start PAD unit flag */

#	if ((DTE_PAD == ON) || (DTE_V120 == ON))
		sapi_t			x25_v120_dl_sapi;	/* data link layer service access point id (for X.25 and V.120) */
		uchar			pad_v120_line_status;	/* status of the PAD or V.120 link : outgoing call, incoming call, inactive */
		char			pad_v120_outgoing_profile 	[DTE_PAD_V120_PROFILE_STR_SIZE + 1];	/* PAD CCITT   profile for outgoing call */
		char			pad_v120_outgoing_serv_prof [DTE_PAD_V120_PROFILE_STR_SIZE + 1];	/* PAD service profile for outgoing call */
#	endif

#	if DTE_PAD == ON
		uchar			pad_auto_start;			/* ON: PAD autostart. OFF: no PAD autostart */
		sapi_t			x25_n_sapi;				/* X.25 network service access point id (for X.25) */
		add_t			b_channel_used_by_pad;	/* B-channel used (attached) by PAD. ADD_NIL : no B-channel is currently used. */

		uchar			chan_pad_msg_format;	/* PAD messages format */
#		define			DTE_INT_CH_PAD_FMT_STD				('s')   /* PAD standard format */
#		define			DTE_INT_CH_PAD_FMT_VERBOSE_MODEM	('M')   /* PAD modem format, verbose */
#		define			DTE_INT_CH_PAD_FMT_MODEM			('m')   /* PAD modem format, silent (normal) */

		uchar			pad_vc_state;		/* PAD virtual circuit state (ON: established, OFF: cleared) */

		struct message FAR *
						p_msg_x25_call_in;	/* adress of X.25_CALL_IN message */
		char			pad_incoming_profile 	[DTE_PAD_V120_PROFILE_STR_SIZE + 1];	/* PAD CCITT   profile for incoming call */
		char			pad_incoming_serv_prof	[DTE_PAD_V120_PROFILE_STR_SIZE + 1];	/* PAD service profile for incoming call */

		uchar			pad_def_call_rq_size;			/* PAD default VC establishment string size */
		uchar			pad_def_call_rq_string			/* PAD default VC establishment string, without \0 */
						 [DTE_MX_PAD_STRING_SIZE];
		struct {                           				/* PAD parameters */
			uchar		valid;							/* ON if value is valid */
			uchar		value;							/* parameter value */
		}				pad_parameter [DTE_NB_PAD_PAR + DTE_NB_SUPP_PAD_PAR];
#	endif

		uchar			pad_cmd_call_rq_size;			/* PAD VC establishment string size, from AT command */
		uchar			pad_cmd_call_rq_string			/* PAD VC establishment string, without \0, from AT command */
						 [DTE_MX_PAD_STRING_SIZE];

		uchar			and_v;				/* AT &V parameter value */
		uchar			display_state;		/* current display state */
#   	define		DTE_DISPLAY_START			'S'		/* Start display */
#		define		DTE_DISPLAY_CHANNEL			'c'		/* Display DTE channel */
#		define		DTE_DISPLAY_SINGLE_LETTER	'l'		/* Display single letter and & parameters */
#		define		DTE_DISPLAY_PHONE_NUMBERS	'p'		/* Display stored phone numbers */
#		define		DTE_DISPLAY_TERMINATED		'0'		/* Display is terminated */
#if	DTE_DIR == ON
		dte_dir_id_t	dir_entry_id;		/* associated directory entry, for DTR dialing (in asynchronous mode) */
		short			v_i_dir;			/* index of current directory entry, for AT &V */
#endif
#	if ((DTE_DIR_LIST == ON) && (DTE_TIME_SLOT == ON))
		uchar			ts_barred;			/* ON if outgoing calls are barred on this DTE channel, due to time slot constraints */
#	endif

#if DTE_AT_EXTERNAL == ON
		uchar			ext_jn_id;			/* external junction identifier, for external entities processing external AT commands */
#endif

		uchar			litt_name [DTE_CH_NAME_SIZE + 1];	/* DTE channel litterary name */

#if DTE_V34 == ON
		ushort			modulations_disabled;	/* image of disable_modulations coming from config */
												/* bits map */
												/* possible values	*/
												/*   DTE_DISABLE_MODULATION_V34 : bit 0 : V34 */
												/*   DTE_DISABLE_MODULATION_VFC : bit 1 : VFC (VFAST) */
#endif
		/*-----*/
		/* PPP */
		/*-----*/
#if DTE_PPP == ON
		struct {
			uchar			FAR *p_ppp_ctxt;		/* (struct dte_ppp_asyn_ctxt FAR *) Asynchronous PPP encoding/decoding process context */
			struct buffer 	FAR *p_dec_out_buffer;	/* address of output decoding context */
		} ppp;
#endif

	} 				ch;

#if DTE_SIMPLE_CHANNEL_ADDRESSING == ON
	struct {						/* Simple DTE channel addressing data */
		uchar	addr_type;					/* address type. 0: any, */
											/* ENT_CC: ISDN address, ENT_X25: X25 address */
		uchar	loc_isdn_or_x25_addr_size;	/* local ISDN or X.25 address size */
		uchar	loc_isdn_sub_addr_size;		/* local ISDN subaddress size */
		uchar	loc_uui_size;				/* local UUI size */
		uchar	loc_isdn_or_x25_addr [DTE_SCA_ISDN_ADDR_SIZE + 1];
											/* local ISDN or X.25 address attached to the DTE channel */
											/* If "", no selection based upon called party ISDN number */
		uchar	loc_isdn_sub_addr [DTE_SCA_ISDN_SUB_ADDR_SIZE + 1];
											/* local ISDN subaddress attached to the DTE channel */
											/* If "", no selection based upon called party ISDN subaddress */
		uchar	loc_uui_data [DTE_SCA_UUI_SIZE + 1];
											/* UUI attached to DTE channel */
											/* If "", no selection based upon incoming call UUI */
	} sca;
#endif

	struct {                        /* The purpose of this data structure is to be able to manage several nai on one DTE channel */
									/* This occurs when there are several SPIDs, each SPID being corresponding to one signalling na */
		nai_t	nb_ass_nas;			/* number of associated network accesses in the following array */
		nai_t	def_ass_na_ix;		/* default associated_na index in the following table */
		nai_t	cur_ass_na_ix;		/* current associated_na index in the following table */
		struct {
			nai_t		sig_net_ix;		/* (signalling) network access index */
			uchar		user_id;		/* na user id. Must be non zero */
#define					ASS_NA_DEFAULT_USER_ID	1		/* default user id */
			uchar		mx_calls;		/* maximum number of calls allowed on this na */

			uchar		act_calls;		/* current number of active calls on this na */
		} na [DTE_MX_ASS_NA_PER_CH];
	} ass_na;

#if ((DTE_PH_V110 == ON) || (DTE_CF_V110 == ON))
	struct {
		uchar		user_rate;		/* Physical rate (for physical V.110) (PDTE_RATE_xxx, see PDTE_INT.H) */
		uchar		syn_asyn;		/* V.110/V.120: synchronous (ON), asynchronous (OFF) */
		uchar		data_nb;		/* Asyn V.110 : number of data bits: 5, 7 or 8 */
		uchar		stop_nb;		/* Asyn V.110 : number of stop bits: 0:1.5, 1:1, 2: 2 */
		uchar		parity;			/* Asyn V.110 : parity: PAR_PARITY_ODD, PAR_PARITY_EVEN or PAR_NO_PARITY */
	} ph_parameters;
#endif

#if DTE_MESSAGE_INTERFACE == ON
	struct {
		ent_id_t	user_entity;			/* name of the user entity */
											/* ENT_NIL: no user entity, DTE channel is associated to a true asynchronous junction */
		uchar		saved_ch_id;			/* saved DTE channel identifier, or 0 */
		short		min_data_offset;		/* minimum data offset for data sent by DTE_INT to its user */
		short		max_data_size;			/* maximum data size for data sent by DTE_INT to its user */
	} message_interface;
#endif

	struct {							/* DTE channel parameters, user form */
		uchar		and_c;					/* &C */
		uchar		and_d;					/* &D */
#		if DTE_MODEM == ON
			uchar	and_g;					/* &G : guard tone */
#		endif
		uchar		and_k;					/* &K : flow control */
		uchar		and_q;					/* &Q */
		uchar		and_r;					/* &R */
		uchar		and_s;					/* &S */
		uchar		s6;						/* S6   */
		uchar		s7;						/* S7   */
		uchar		s8;						/* S8   */
		uchar		s9;						/* S9   */
		uchar		s10;					/* S10  */
		uchar		s011;					/* S11  */
		uchar		s25;					/* S25  */
		uchar		s26;					/* S26  */
		uchar		s36;					/* S36  */
		uchar		s37;					/* S37  */
#		if DTE_V34 == ON
			ushort	s109;					/* S109 register : Carrier Speed Selector */
#		endif
		uchar		service;				/* S111 */
		uchar		s112;					/* S112 */
		uchar		s113;					/* S113 */
		uchar		s115;					/* S115 */
		uchar		s116;					/* S116 */
		uchar		s117;					/* S117 */
#		if DTE_EXT_CALLING_PARTY == ON
			uchar	s119;					/* S119 */
#			define		DTE_119_DISPLAY_LIST		0x01	/* display list of calling numbers */
#			define		DTE_119_FORCE_DISPLAY		0x02	/* force display even if presentation is restricted */
#			define			DTE_119_MASK	(DTE_119_DISPLAY_LIST | DTE_119_FORCE_DISPLAY)
#		endif

#		if DTE_EXT_CALLED_PARTY == ON
			uchar	s120;					/* S120 */
#			define		DTE_120_DISPLAY_REDIRECTION		0x01	/* display redirection number, if present */
#			define			DTE_120_MASK	(DTE_120_DISPLAY_REDIRECTION)
#		endif

#	if DTE_ISDN_CC == ON
		uchar		s131;					/* S131 */		/* call clearing processing. 0: normal. non zero : do not send ACU_CLEAR_RS. */
#	endif

#	if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON) || (DTE_PAD_V120_COMPRESSION == ON))
		uchar		s48;					/* S48  */
		uchar		per_c;					/* %C */
#	endif
		uchar		x;						/* X */

		uchar		back_n;					/* \N */
	}				user;

#if DTE_NO_S122_254 == OFF
	struct {             					/* Saved values */
		uchar		and_c;					/* &C */
		uchar		and_d;					/* &D */
#		if DTE_MODEM == ON
			uchar	and_g;					/* &G : guard tone */
#		endif
		uchar		and_k;					/* &K : flow control */
		uchar		and_q;					/* &Q */
		uchar		and_r;					/* &R */
		uchar		and_s;					/* &S */
		uchar		s0;						/* S0 	*/
		uchar		s6;						/* S6   */
		uchar		s7;						/* S7   */
		uchar		s8;						/* S8   */
		uchar		s9;						/* S9   */
		uchar		s10;					/* S10  */
		uchar		s011;					/* S11  */
		uchar		s25;					/* S25  */
		uchar		s26;					/* S26  */
		uchar		s36;					/* S36  */
		uchar		s37;					/* S37  */
#		if DTE_V34 == ON
			ushort	s109;					/* S109 register : Carrier Speed Selector */
#		endif
		uchar		service;				/* S111 */
		uchar		s112;					/* S112 */
		uchar		s113;					/* S113 */
		uchar		s115;					/* S115 */
		uchar		s116;					/* S116 */
		uchar		s117;					/* S117 */
#		if DTE_ASYN_TO_PH == ON
			uchar	s118;					/* S118	*/
#		endif
#		if DTE_EXT_CALLING_PARTY == ON
			uchar	s119;					/* S119 */
#		endif
#		if DTE_EXT_CALLED_PARTY == ON
			uchar	s120;					/* S120 */
#		endif
#		if DTE_ISDN_CC == ON
			uchar	s131;					/* S131 */
#		endif
#		if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON) || (DTE_PAD_V120_COMPRESSION == ON))
			uchar	s48;					/* S48  */
			uchar	per_c;					/* %C */
#		endif

		uchar		t_p;					/* T/P 	*/
		uchar		x;						/* X */
		uchar		w;						/* W 	*/

#		if DTE_PAD == ON
			uchar	pad_par_23;				/* PAD parameter 23 */
#		endif

#		if DTE_USE_CP == ON
			uchar	relay_mode;				/* relay mode */
#		endif
	}				zero;
#endif	/* DTE_NO_S122_254 == OFF */

};

#define Ch_round_size			Rnd_sizeof (struct dte_channel_ctxt)

#define	Ch_dump_id				(P_dte_channel -> dump_id)

#define	Ch_ix					(P_dte_channel -> ix)
#define	Ch_id					(P_dte_channel -> id)
#define	Ch_unique_id			(P_dte_channel -> unique_id)

#define	Ch_call_ix				(P_dte_channel -> call_ix)
#define	Ch_next_idle_call_ix	(P_dte_channel -> next_idle_call_ix)
#define	Ch_cc_service_list_id	(P_dte_channel -> cc_service_list_id)
#define	Ch_conn_ix				(P_dte_channel -> conn_ix)
#if DTE_USE_CP == ON
#	define	Ch_comm_port_ix		(P_dte_channel -> comm_port_ix)
#	define	Ch_comm_port_state	(P_dte_channel -> comm_port_state)
#endif
#define	Ch_jn_id				(P_dte_channel -> jn_id)
#define	Ch_jn_ix				(P_dte_channel -> jn_ix)
#define	Ch_callers_list_id		(P_dte_channel -> callers_list_id)

#define	Ch_a_dcc_ctxt			((struct dcc_ctx FAR *)&(P_dte_channel -> ch.dcc_ctxt))
#define	Ch_act_calls			(Ch_ans_calls + Ch_out_calls)
#define	Ch_acu_profile			(P_dte_channel -> ch.acu_profile)
#define	Ch_and_c				(P_dte_channel -> ch.and_c)
#define	Ch_and_d				(P_dte_channel -> ch.and_d)
#define	Ch_and_q				(P_dte_channel -> ch.and_q)
#define	Ch_and_r				(P_dte_channel -> ch.and_r)
#define	Ch_and_s				(P_dte_channel -> ch.and_s)
#define	Ch_and_v				(P_dte_channel -> ch.and_v)
#define	Ch_ans_calls			(P_dte_channel -> ch.ans_calls)
#define	Ch_ans_connect_timer_val	\
								(P_dte_channel -> ch.ans_connect_timer_val)
#define	Ch_nb_ass_nas			(P_dte_channel -> ass_na.nb_ass_nas)
#define	Ch_def_ass_na_ix		(P_dte_channel -> ass_na.def_ass_na_ix)
#define	Ch_cur_ass_na_ix		(P_dte_channel -> ass_na.cur_ass_na_ix)
#define	Ch_ass_na_sig_net_ix(i)	(P_dte_channel -> ass_na.na[i].sig_net_ix)
#define	Ch_ass_na_user_id(i)	(P_dte_channel -> ass_na.na[i].user_id)
#define	Ch_ass_na_mx_calls(i)	(P_dte_channel -> ass_na.na[i].mx_calls)
#define	Ch_ass_na_act_calls(i)	(P_dte_channel -> ass_na.na[i].act_calls)

#define	Ch_back_to_cmd			(P_dte_channel -> ch.back_to_cmd)
#if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON))
#	define	Ch_b003				(P_dte_channel -> ch.b003)
#	define	Ch_b006				(P_dte_channel -> ch.b006)
#	define	Ch_b012				(P_dte_channel -> ch.b012)
#	define	Ch_b024				(P_dte_channel -> ch.b024)
#	if DTE_V34 == ON
#		define	Ch_b048			(P_dte_channel -> ch.b048)
#		define	Ch_b072			(P_dte_channel -> ch.b072)
#		define	Ch_b096			(P_dte_channel -> ch.b096)
#		define	Ch_b120			(P_dte_channel -> ch.b120)
#		define	Ch_b144			(P_dte_channel -> ch.b144)
#		define	Ch_b168_288		(P_dte_channel -> ch.b168_288)
#	endif
#endif

#if DTE_PAD == ON
#	define	Ch_b_channel_used_by_pad		\
								(P_dte_channel -> ch.b_channel_used_by_pad)
#endif

#define	Ch_call_clear_cause		(P_dte_channel -> ch.call_clear_cause)
#define	Ch_call_direction		(P_dte_channel -> ch.call_direction)
#define	Ch_call_network_clear_cause		\
								(P_dte_channel -> ch.call_network_clear_cause)
#define	Ch_call_str_format		(P_dte_channel -> ch.call_str_format)
#define	Ch_call_total_cost		(P_dte_channel -> ch.call_total_cost)
#define	Ch_call_user_id			(P_dte_channel -> ch.call_user_id)
#define	Ch_chan_all_q931_format	(P_dte_channel -> ch.chan_all_q931_format)
#define	Ch_chan_at_format		(P_dte_channel -> ch.chan_at_format)
#define	Ch_chan_ext_format		(P_dte_channel -> ch.chan_ext_format)
#define	Ch_chan_pad_msg_format	(P_dte_channel -> ch.chan_pad_msg_format)

#if DTE_PAD == ON
#	define	Ch_cd_on_in_pad_command			\
								(P_dte_channel -> ch.cd_on_in_pad_command)
#endif
#define Ch_connect_timer_id		(P_dte_channel -> ch.connect_timer.id)
#define Ch_connect_timer_sn		(P_dte_channel -> ch.connect_timer.sn)
#define Ch_connect_timer_state	(P_dte_channel -> ch.connect_timer.state)

#define	Ch_cur_conn_call_ix		(P_dte_channel -> ch.cur_conn_call_ix)
#define	Ch_cur_single_call_ix	(P_dte_channel -> ch.cur_single_call_ix)
#define	Ch_data_calls			(P_dte_channel -> ch.data_calls)
#define	Ch_data_chani			(P_dte_channel -> ch.data_chani)
#define	Ch_dc_nai				(P_dte_channel -> ch.dc_nai)
#define	Ch_dc_stream_id			(P_dte_channel -> ch.dc_stream_id)
#define	Ch_dcc_context_state	(P_dte_channel -> ch.dcc_ctxt.state)
#define	Ch_dcc_state			(P_dte_channel -> ch.dcc_state)
#define	Ch_dcc_user_fct			(P_dte_channel -> ch.dcc_ctxt.p_dcc_send)
#define	Ch_dcc_v42b_neg_p1		(P_dte_channel -> ch.v42b_neg_p1)
#define	Ch_dcc_v42b_neg_p2		(P_dte_channel -> ch.v42b_neg_p2)
#define	Ch_dcc_v42b_req_p1		(P_dte_channel -> ch.v42b_req_p1)
#define	Ch_dcc_v42b_req_p2		(P_dte_channel -> ch.v42b_req_p2)
#define	Ch_dcc_v42b_resp_timer_val	\
								(P_dte_channel -> ch.v42b_resp_timer_val)
#define	Ch_dec_block_size		(P_dte_channel -> ch.dec_block_size)
#define	Ch_dec_dc_busy			(P_dte_channel -> ch.dec_dc_busy)
#define	Ch_dec_jn_busy			(P_dte_channel -> ch.dec_jn_busy)
#define	Ch_dec_flush			(P_dte_channel -> ch.dec_flush)
#define Ch_dec_flush_id			(P_dte_channel -> ch.dec_flush_timer.id)
#define Ch_dec_flush_sn			(P_dte_channel -> ch.dec_flush_timer.sn)
#define Ch_dec_flush_state		(P_dte_channel -> ch.dec_flush_timer.state)
#define Ch_dec_high_mark		(P_dte_channel -> ch.dec_high_mark)
#define Ch_dec_low_data_size	(P_dte_channel -> ch.dec_low_data_size)
#define Ch_dec_low_mark			(P_dte_channel -> ch.dec_low_mark)
#define Ch_dec_th_low_traffic	(P_dte_channel -> ch.dec_th_low_traffic)
#define	Ch_def_data_chani		(P_dte_channel -> ch.def_data_chani)
#define	Ch_dir_entry_id			(P_dte_channel -> ch.dir_entry_id)
#define	Ch_disable				(P_dte_channel -> ch.disable)
#define	Ch_display_state		(P_dte_channel -> ch.display_state)
#define	Ch_dtr_dial_ans			(P_dte_channel -> ch.dtr_dial_ans)
#define	Ch_dtr_or_ph_r_op_in_progress				\
								(P_dte_channel -> ch.dtr_or_ph_r_op_in_progress)
#define	Ch_enc_block_size		(P_dte_channel -> ch.enc_block_size)
#define	Ch_enc_dc_busy			(P_dte_channel -> ch.enc_dc_busy)
#define	Ch_enc_flush			(P_dte_channel -> ch.enc_flush)
#define Ch_enc_flush_id			(P_dte_channel -> ch.enc_flush_timer.id)
#define Ch_enc_flush_sn			(P_dte_channel -> ch.enc_flush_timer.sn)
#define Ch_enc_flush_state		(P_dte_channel -> ch.enc_flush_timer.state)
#define Ch_enc_high_mark		(P_dte_channel -> ch.enc_high_mark)
#define Ch_enc_low_mark			(P_dte_channel -> ch.enc_low_mark)
#define Ch_enc_mx_blocks		(P_dte_channel -> ch.enc_mx_blocks)
#define Ch_enc_th_low_traffic	(P_dte_channel -> ch.enc_th_low_traffic)
#define	Ch_enc_x25_v120_busy	(P_dte_channel -> ch.enc_x25_v120_busy)
#define	Ch_ext_jn_id			(P_dte_channel -> ch.ext_jn_id)
#define	Ch_inc_auto_answer		(P_dte_channel -> ch.inc_auto_answer)
#define	Ch_inc_manual_answer	(P_dte_channel -> ch.inc_manual_answer)
#define	Ch_inc_priority			(P_dte_channel -> ch.inc_priority)
#define	Ch_init					(P_dte_channel -> ch.init)
#define	Ch_int_unit				(P_dte_channel -> ch.int_unit)
#define	Ch_jn_speed				(P_dte_channel -> ch.jn_speed)
#define	Ch_litt_name			(P_dte_channel -> ch.litt_name)
#if	DTE_V34 == ON
#	define	Ch_modulations_disabled	(P_dte_channel -> ch.modulations_disabled)
#endif
#define	Ch_lock_service			(P_dte_channel -> ch.lock_service)
#define	Ch_mgt_fac_action		(P_dte_channel -> ch.mgt_fac_action)
#define	Ch_mgt_fac_code			(P_dte_channel -> ch.mgt_fac_code)

#if DTE_MESSAGE_INTERFACE == ON
#	define	Ch_mi_user_entity		(P_dte_channel -> message_interface.user_entity)
#	define	Ch_mi_saved_ch_id		(P_dte_channel -> message_interface.saved_ch_id)
#	define	Ch_mi_min_data_offset	(P_dte_channel -> message_interface.min_data_offset)
#	define	Ch_mi_max_data_size		(P_dte_channel -> message_interface.max_data_size)
#endif

#if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON))
#	define	Ch_mnp4_disable		(P_dte_channel -> ch.mnp4_disable)
#	define	Ch_n_auto			(P_dte_channel -> ch.n_auto)
#endif
#define	Ch_mx_act_calls			(P_dte_channel -> ch.mx_act_calls)
#define	Ch_mx_data_calls		(P_dte_channel -> ch.mx_data_calls)
#define	Ch_mx_inc_calls			(P_dte_channel -> ch.mx_inc_calls)
#define	Ch_mx_out_calls			(P_dte_channel -> ch.mx_out_calls)
#define	Ch_mx_voice_calls		(P_dte_channel -> ch.mx_voice_calls)
#define	Ch_nb_calls				(P_dte_channel -> nb_calls)
#define	Ch_nb_conns				(P_dte_channel -> nb_conns)
#define	Ch_neg_per_c			(P_dte_channel -> ch.neg_per_c)
#define	Ch_org_connect_timer_val	\
								(P_dte_channel -> ch.org_connect_timer_val)
#define	Ch_out_calls			(P_dte_channel -> ch.out_calls)
#define	Ch_p_msg_x25_call_in	(P_dte_channel -> ch.p_msg_x25_call_in)
#if DTE_PPP == ON
#	define	Ch_p_ppp_ctxt		(P_dte_channel -> ch.ppp.p_ppp_ctxt)
#	define	Ch_ppp_dec_out_buffer	\
								(P_dte_channel -> ch.ppp.p_dec_out_buffer)
#endif
#if DTE_PAD == ON
#	define	Ch_pad_auto_start	(P_dte_channel -> ch.pad_auto_start)
#endif
#define	Ch_pad_cmd_call_rq_size	(P_dte_channel -> ch.pad_cmd_call_rq_size)
#define	Ch_pad_cmd_call_rq_string	\
								(P_dte_channel -> ch.pad_cmd_call_rq_string)
#define	Ch_pad_def_call_rq_size	(P_dte_channel -> ch.pad_def_call_rq_size)
#define	Ch_pad_def_call_rq_string	\
								(P_dte_channel -> ch.pad_def_call_rq_string)
#define	Ch_pad_incoming_profile	(P_dte_channel -> ch.pad_incoming_profile)
#define	Ch_pad_incoming_serv_prof	\
								(P_dte_channel -> ch.pad_incoming_serv_prof)
#define	Ch_pad_v120_outgoing_profile	\
								(P_dte_channel -> ch.pad_v120_outgoing_profile)
#define	Ch_pad_v120_outgoing_serv_prof	\
								(P_dte_channel -> ch.pad_v120_outgoing_serv_prof)
#define	Ch_pad_parameter_valid(i)	\
								(P_dte_channel -> ch.pad_parameter[i].valid)
#define	Ch_pad_parameter_value(i)	\
								(P_dte_channel -> ch.pad_parameter[i].value)
#define	Ch_pad_v120_line_status	(P_dte_channel -> ch.pad_v120_line_status)
#define	Ch_pad_vc_state			(P_dte_channel -> ch.pad_vc_state)
#define	Ch_ph_data_nb			(P_dte_channel -> ph_parameters.data_nb)
#define	Ch_ph_parity 			(P_dte_channel -> ph_parameters.parity)
#define	Ch_ph_stop_nb			(P_dte_channel -> ph_parameters.stop_nb)
#define	Ch_ph_syn_asyn			(P_dte_channel -> ph_parameters.syn_asyn)
#define	Ch_ph_user_rate			(P_dte_channel -> ph_parameters.user_rate)
#define	Ch_relay_mode			(P_dte_channel -> ch.relay_mode)
#define	Ch_req_per_c			(P_dte_channel -> ch.req_per_c)
#define	Ch_route_mx_nb_buffer	(P_dte_channel -> ch.route_mx_nb_buffer)
#define	Ch_sca_addr_type				(P_dte_channel -> sca.addr_type)
#define	Ch_sca_loc_isdn_or_x25_addr		(P_dte_channel -> sca.loc_isdn_or_x25_addr)
#define	Ch_sca_loc_isdn_or_x25_addr_size		\
										(P_dte_channel -> sca.loc_isdn_or_x25_addr_size)
#define	Ch_sca_loc_isdn_sub_addr		(P_dte_channel -> sca.loc_isdn_sub_addr)
#define	Ch_sca_loc_isdn_sub_addr_size	(P_dte_channel -> sca.loc_isdn_sub_addr_size)
#define	Ch_sca_loc_uui_data				(P_dte_channel -> sca.loc_uui_data)
#define	Ch_sca_loc_uui_size				(P_dte_channel -> sca.loc_uui_size)
#define	Ch_service				(P_dte_channel -> ch.dte_service)
#define	Ch_start_pad_unit		(P_dte_channel -> ch.start_pad_unit)
#define	Ch_str_format			(P_dte_channel -> ch.str_format)
#define	Ch_s000					(P_dte_channel -> ch.s0)
#define	Ch_s7					(P_dte_channel -> ch.s7)
#define Ch_s7_id				(P_dte_channel -> ch.s7_timer.id)
#define Ch_s7_sn				(P_dte_channel -> ch.s7_timer.sn)
#define Ch_s7_state				(P_dte_channel -> ch.s7_timer.state)
#define	Ch_s009					(P_dte_channel -> ch.s9)
#define	Ch_s10					(P_dte_channel -> ch.s10)
#define	Ch_s25_hundredths		(P_dte_channel -> ch.s25_hundredths)
#define Ch_s25_id				(P_dte_channel -> ch.s25_timer.id)
#define Ch_s25_sn				(P_dte_channel -> ch.s25_timer.sn)
#define	Ch_s25_seconds			(P_dte_channel -> ch.s25_seconds)
#define Ch_s25_state			(P_dte_channel -> ch.s25_timer.state)
#define	Ch_s26					(P_dte_channel -> ch.s26)
#define Ch_s26_id				(P_dte_channel -> ch.s26_timer.id)
#define Ch_s26_sn				(P_dte_channel -> ch.s26_timer.sn)
#define Ch_s26_state			(P_dte_channel -> ch.s26_timer.state)
#define	Ch_s36					(P_dte_channel -> ch.s36)
#define	Ch_s37					(P_dte_channel -> ch.s37)
#if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON) || (DTE_PAD_V120_COMPRESSION == ON))
#	define	Ch_s48				(P_dte_channel -> ch.s48)
#endif
#define	Ch_s109					(P_dte_channel -> ch.s109)
#define	Ch_s117					(P_dte_channel -> ch.s117)
#define Ch_s117_id				(P_dte_channel -> ch.s117_timer.id)
#define Ch_s117_sn				(P_dte_channel -> ch.s117_timer.sn)
#define Ch_s117_state			(P_dte_channel -> ch.s117_timer.state)
#define	Ch_s118					(P_dte_channel -> ch.s118)
#define	Ch_to_jn_fifo_first		(P_dte_channel -> ch.to_jn_fifo_first)
#define	Ch_to_jn_fifo_last		(P_dte_channel -> ch.to_jn_fifo_last)
#define	Ch_to_jn_open			(P_dte_channel -> ch.to_jn_open)
#if ((DTE_DIR_LIST == ON) && (DTE_TIME_SLOT == ON))
#	define	Ch_ts_barred		(P_dte_channel -> ch.ts_barred)
#endif
#define	Ch_t_p					(P_dte_channel -> ch.t_p)
#define	Ch_v_i_dir				(P_dte_channel -> ch.v_i_dir)
#define	Ch_v120_link_state		(P_dte_channel -> ch.v120.link_state)
#define	Ch_v120_state			(P_dte_channel -> ch.v120.state)
#define	Ch_voice_calls			(P_dte_channel -> ch.voice_calls)
#define	Ch_w					(P_dte_channel -> ch.w)
#define	Ch_x_busy				(P_dte_channel -> ch.x_busy)
#define	Ch_x_messages			(P_dte_channel -> ch.x_messages)
#define	Ch_x_no_dial_tone		(P_dte_channel -> ch.x_no_dial_tone)
#define	Ch_x25_n_sapi			(P_dte_channel -> ch.x25_n_sapi)
#define	Ch_x25_v120_dl_sapi		(P_dte_channel -> ch.x25_v120_dl_sapi)

#define	Ch_user_and_c			(P_dte_channel -> user.and_c)
#define	Ch_user_and_d			(P_dte_channel -> user.and_d)
#if DTE_MODEM == ON
#	define	Ch_user_and_g		(P_dte_channel -> user.and_g)
#endif
#define	Ch_user_and_k			(P_dte_channel -> user.and_k)
#define	Ch_user_and_q			(P_dte_channel -> user.and_q)
#define	Ch_user_and_r			(P_dte_channel -> user.and_r)
#define	Ch_user_and_s			(P_dte_channel -> user.and_s)
#define	Ch_user_back_n			(P_dte_channel -> user.back_n)
#define	Ch_user_per_c			(P_dte_channel -> user.per_c)
#define	Ch_user_s6				(P_dte_channel -> user.s6)
#define	Ch_user_s7				(P_dte_channel -> user.s7)
#define	Ch_user_s8				(P_dte_channel -> user.s8)
#define	Ch_user_s009			(P_dte_channel -> user.s9)
#define	Ch_user_s10				(P_dte_channel -> user.s10)
#define	Ch_user_s011			(P_dte_channel -> user.s011)
#define	Ch_user_s25				(P_dte_channel -> user.s25)
#define	Ch_user_s26				(P_dte_channel -> user.s26)
#define	Ch_user_s36				(P_dte_channel -> user.s36)
#define	Ch_user_s37				(P_dte_channel -> user.s37)
#if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON) || (DTE_PAD_V120_COMPRESSION == ON))
#	define	Ch_user_s48			(P_dte_channel -> user.s48)
#endif
#define	Ch_user_service			(P_dte_channel -> user.service)
#define	Ch_user_s109			(P_dte_channel -> user.s109)
#define	Ch_user_s112			(P_dte_channel -> user.s112)
#define	Ch_user_s113			(P_dte_channel -> user.s113)
#define	Ch_user_s115			(P_dte_channel -> user.s115)
#define	Ch_user_s116			(P_dte_channel -> user.s116)
#define	Ch_user_s117			(P_dte_channel -> user.s117)
#if DTE_EXT_CALLING_PARTY == ON
#	define	Ch_user_s119		(P_dte_channel -> user.s119)
#endif
#if DTE_EXT_CALLED_PARTY == ON
#	define	Ch_user_s120		(P_dte_channel -> user.s120)
#endif
#if DTE_ISDN_CC == ON
#	define	Ch_user_s131		(P_dte_channel -> user.s131)
#endif
#define	Ch_user_x				(P_dte_channel -> user.x)

#if DTE_NO_S122_254 == OFF
#define	Ch0_pad_par_23			(P_dte_channel -> zero.pad_par_23)
#define	Ch0_relay_mode			(P_dte_channel -> zero.relay_mode)
#define	Ch0_s0					(P_dte_channel -> zero.s0)
#define	Ch0_s118				(P_dte_channel -> zero.s118)
#define	Ch0_t_p					(P_dte_channel -> zero.t_p)
#define	Ch0_user_and_c			(P_dte_channel -> zero.and_c)
#define	Ch0_user_and_d			(P_dte_channel -> zero.and_d)
#if DTE_MODEM == ON
#	define	Ch0_user_and_g		(P_dte_channel -> zero.and_g)
#endif
#define	Ch0_user_and_k			(P_dte_channel -> zero.and_k)
#define	Ch0_user_and_q			(P_dte_channel -> zero.and_q)
#define	Ch0_user_and_r			(P_dte_channel -> zero.and_r)
#define	Ch0_user_and_s			(P_dte_channel -> zero.and_s)
#define	Ch0_user_per_c			(P_dte_channel -> zero.per_c)
#define	Ch0_user_s6				(P_dte_channel -> zero.s6)
#define	Ch0_user_s7				(P_dte_channel -> zero.s7)
#define	Ch0_user_s8				(P_dte_channel -> zero.s8)
#define	Ch0_user_s009			(P_dte_channel -> zero.s9)
#define	Ch0_user_s10			(P_dte_channel -> zero.s10)
#define	Ch0_user_s011			(P_dte_channel -> zero.s011)
#define	Ch0_user_s25			(P_dte_channel -> zero.s25)
#define	Ch0_user_s26			(P_dte_channel -> zero.s26)
#define	Ch0_user_s36			(P_dte_channel -> zero.s36)
#define	Ch0_user_s37			(P_dte_channel -> zero.s37)
#if ((DTE_MODEM == ON) || (DTE_CF_V110 == ON) || (DTE_PAD_V120_COMPRESSION == ON))
#	define	Ch0_user_s48		(P_dte_channel -> zero.s48)
#endif
#define	Ch0_user_s109			(P_dte_channel -> zero.s109)
#define	Ch0_user_s112			(P_dte_channel -> zero.s112)
#define	Ch0_user_s113			(P_dte_channel -> zero.s113)
#define	Ch0_user_s115			(P_dte_channel -> zero.s115)
#define	Ch0_user_s116			(P_dte_channel -> zero.s116)
#define	Ch0_user_s117			(P_dte_channel -> zero.s117)
#if DTE_EXT_CALLING_PARTY == ON
#	define	Ch0_user_s119		(P_dte_channel -> zero.s119)
#endif
#if DTE_EXT_CALLED_PARTY == ON
#	define	Ch0_user_s120		(P_dte_channel -> zero.s120)
#endif
#if DTE_ISDN_CC == ON
#	define	Ch0_user_s131		(P_dte_channel -> zero.s131)
#endif
#define	Ch0_user_service		(P_dte_channel -> zero.service)
#define	Ch0_user_x				(P_dte_channel -> zero.x)
#define	Ch0_w					(P_dte_channel -> zero.w)
#endif	/* DTE_NO_S122_254 == OFF */

#define		Start_s7_timer(delta)										\
			if (Ch_s7 != 0) { 											\
			Timer_start (Ch_s7_id, Ch_s7+(delta), ++(Ch_s7_sn), TI_S7);	\
			Ch_s7_state = ON; }
#define		Stop_s7_timer()												\
			Timer_stop (Ch_s7_id);	Ch_s7_state = OFF
#define		Valid_s7_timer()											\
			(Ch_s7_state == ON) && (R_msg_inf0 == Ch_s7_sn)

#define		Start_s25_asyn_timer_seconds()									\
			Timer_start (Ch_s25_id, Ch_s25_seconds, ++(Ch_s25_sn), TI_S25);	\
			Ch_s25_state = ON
#define		Start_s25_asyn_timer_hundredths()								\
			Timer_start (Ch_s25_id, Ch_s25_hundredths, 						\
			++(Ch_s25_sn), TI_S25);											\
			Ch_s25_state = ON
#if DTE_USE_CP == ON
#	define	Start_s25_sync_timer(duration)									\
			Timer_start (Ch_s25_id, duration, ++(Ch_s25_sn), TI_S25_SYNC);	\
			Ch_s25_state = ON
#endif
#define		Stop_s25_timer()										\
			Timer_stop (Ch_s25_id);	Ch_s25_state = OFF
#define		Valid_s25_timer()										\
			(Ch_s25_state == ON) && (R_msg_inf0 == Ch_s25_sn)

#define		Start_s26_timer()										\
		Timer_start (Ch_s26_id, Ch_s26,	++(Ch_s26_sn), TI_S26);		\
		Ch_s26_state = ON
#define		Stop_s26_timer()										\
		Timer_stop (Ch_s26_id);	Ch_s26_state = OFF
#define		Valid_s26_timer()										\
		(Ch_s26_state == ON) && (R_msg_inf0 == Ch_s26_sn)

#define		Start_s117_timer()											\
		if (Ch_s117 != 0) {												\
			Timer_start (Ch_s117_id, Ch_s117, ++(Ch_s117_sn), TI_S117);	\
			Ch_s117_state = ON; }
#define		Stop_s117_timer()										\
		Timer_stop (Ch_s117_id); Ch_s117_state = OFF
#define		Valid_s117_timer()										\
		(Ch_s117_state == ON) && (R_msg_inf0 == Ch_s117_sn)

#if DTE_PAD_V120_COMPRESSION == ON
#	define	Start_encoder_flush_timer()										\
		if ((Ch_enc_flush != 0) && (Ch_enc_flush_id != P_NIL)) { 			\
			Timer_start (Ch_enc_flush_id, Ch_enc_flush, ++(Ch_enc_flush_sn),\
			TI_ENC_FLUSH);													\
			Ch_enc_flush_state = ON; }
#	define	Stop_encoder_flush_timer()										\
		if (Ch_enc_flush_id != P_NIL) {                             		\
			Timer_stop (Ch_enc_flush_id); Ch_enc_flush_state = OFF; }
#	define	Valid_encoder_flush_timer()										\
			(Ch_enc_flush_state == ON) && (R_msg_inf0 == Ch_enc_flush_sn)

#	define	Start_decoder_flush_timer()										\
		if ((Ch_dec_flush != 0) && (Ch_dec_flush_id != P_NIL)) {			\
			Timer_start (Ch_dec_flush_id, Ch_dec_flush, ++(Ch_dec_flush_sn),\
			TI_DEC_FLUSH);													\
			Ch_dec_flush_state = ON; }
#	define	Stop_decoder_flush_timer()										\
		if (Ch_dec_flush_id != P_NIL) {										\
			Timer_stop (Ch_dec_flush_id); Ch_dec_flush_state = OFF; }
#	define	Valid_decoder_flush_timer()										\
			(Ch_dec_flush_state == ON) && (R_msg_inf0 == Ch_dec_flush_sn)
#endif

#define		Start_connect_timer(duration)									\
			if ((Ch_connect_timer_id != P_NIL) && (duration != 0)) { 		\
			Timer_start (Ch_connect_timer_id, duration, 					\
				++(Ch_connect_timer_sn), TI_CONNECT);						\
				Ch_connect_timer_state = ON; }

#define		Stop_connect_timer()											\
			if (Ch_connect_timer_id != P_NIL) {						 		\
				Timer_stop (Ch_connect_timer_id); 							\
				Ch_connect_timer_state = OFF; }

#define		Valid_connect_timer()											\
			((Ch_connect_timer_id != P_NIL) && 								\
			(Ch_connect_timer_state == ON) && 								\
			(R_msg_inf0 == Ch_connect_timer_sn))


#define	Update_pad_parameter_5()											\
					Ch_pad_parameter_value (5-1) = (Jn_s39 == JN_S39_FC_XON) ? 1 : 0;	\
					Ch_pad_parameter_valid (5-1) = ON

#define	Update_pad_parameter_11()											\
					Ch_pad_parameter_value (11-1) = dte_jn_get_pad_rate ();	\
					Ch_pad_parameter_valid (11-1) = ON

#define	Update_pad_parameter_12()											\
					Ch_pad_parameter_value (12-1) = (Jn_s39 == JN_S39_FC_XON) ? 1 : 0;	\
					Ch_pad_parameter_valid (12-1) = ON

#define	Update_pad_parameter_21()	dte_pad_upd_21 ()

#define	Set_pad_parameter_23(val)											\
					Ch_pad_parameter_value (23-1) = val;					\
					Ch_pad_parameter_valid (23-1) = ON
#define	Get_pad_parameter_23()	(Ch_pad_parameter_value(23-1))
#define	Get_23_bit_m()			(((Get_pad_parameter_23() & DTE_PP_23_GEN_BIT_M_MSK) != 0) ? ON : OFF)
#define	Get_23_send_break()		(((Get_pad_parameter_23() & DTE_PP_23_GEN_EOM_MSK) == DTE_PP_23_GEN_EOM_BREAK) ? ON : OFF)

#if	DTE_V34 == ON
#	define	Ch_v34_modulation_disabled	(((Ch_modulations_disabled & DTE_DISABLE_MODULATION_V34) == 0) ? OFF : ON )
#	define	Ch_vfc_modulation_disabled	(((Ch_modulations_disabled & DTE_DISABLE_MODULATION_VFC) == 0) ? OFF : ON )
#else
#	define	Ch_v34_modulation_disabled	ON
#	define	Ch_vfc_modulation_disabled	ON
#endif

#	define	DTE_PP_23_GEN_BIT_M_MSK		0x01
/*
 *	DTE_PP_23_GEN_EOM_MSK	: when the received X.25 packet is the last of a
 *							  X.25 message (M-bit is 0), generate an
 *							  indication to the DTE
 *		DTE_PP_23_GEN_EOM_BREAK: generate a break to the DTE
 */
#	define		DTE_PP_23_GEN_EOM_MSK			0x02
#		define		DTE_PP_23_GEN_EOM_BREAK		0x02	/* generate a break */


/*--------------------------------------------------------------------------
 *				S111 (DCE service) representation values
 *
 *	SERV_DATA_OVER_JUNCTION	: set if, after call establishment, data are
 *							  transferred over the asynchronous junction.
 *							  (modem-type behaviour).
 *-------------------------------------------------------------------------*/

#define	SERV_DATA_OVER_JUNCTION		0x4000
#define	SERV_DATA_DIGITAL			0x2000
#define	Jn_used_during_data_transfer(service) 	\
			(((service) & SERV_DATA_OVER_JUNCTION) != 0)
#define	Is_data_digital(service) 	\
			(((service) & SERV_DATA_DIGITAL) != 0)

#define	DTE_UNDEFINED_SERVICE		('?')													/* Undefined service */
#define	DTE_MODEM_SERVICE			('M' | SERV_DATA_OVER_JUNCTION)						/* Modem service */
#define	DTE_FAX_SERVICE				('F' | SERV_DATA_OVER_JUNCTION)						/* Fax service */
#define	DTE_PAD_SERVICE				('P' | SERV_DATA_OVER_JUNCTION | SERV_DATA_DIGITAL)	/* PAD service */
#define	DTE_RAW_DATA_SERVICE		('R' |                           SERV_DATA_DIGITAL) /* Raw data service */
#define	DTE_VOICE_SERVICE			('V')												/* Voice service */
#define	DTE_DATA_RELAY_SERVICE		('X' |                           SERV_DATA_DIGITAL)	/* Relay data service */
#define	DTE_CF_V110_SERVICE			('c')												/* CF over V.110 service */
#define	DTE_ASYN_TO_PH_SERVICE		('h' | SERV_DATA_OVER_JUNCTION | SERV_DATA_DIGITAL)	/* Asynchronous over HDLC service */
#define	DTE_PH_V110_SERVICE			('i')												/* Physical V.110 service */
#define	DTE_RAW_TELEPHONY_SERVICE	('r')												/* Raw telephony service */
#define	DTE_ASYN_V110_SERVICE		('1' | SERV_DATA_OVER_JUNCTION)						/* Asynchronous V.110 service */
#define	DTE_ASYN_V120_SERVICE		('2' | SERV_DATA_OVER_JUNCTION | SERV_DATA_DIGITAL)	/* Asynchronous V.120 service */
#define	DTE_V14_SERVICE				('4' | SERV_DATA_OVER_JUNCTION | SERV_DATA_DIGITAL)	/* V.14 service */

#define	DTE_DATA_XPT_SERVICE 		DTE_DATA_RELAY_SERVICE									/* Obsolete name */

/*--------------------------------------------------------------------------
 *				&Q representation values
 *-------------------------------------------------------------------------*/
#define	AND_Q_ASYN	'A'						/* Asynchronous mode */
#define	AND_Q_EC	'E'						/* Error corrected mode */
#if DTE_USE_CP == ON
#	define	AND_Q_SYNC	'S'					/* Synchronous mode */
#endif

/*-------------------------------------------------------------------------
 *			&D (DTR behaviour) representation values
 *------------------------------------------------------------------------*/
#define	AND_D_0					0
#define	AND_D_1					1
#define	AND_D_2					2
#define	AND_D_3					3
#define	AND_D_5					5

/*--------------------------------------------------------------------------
 *				S95 bits
 *-------------------------------------------------------------------------*/
#define	S95_DTE_SPEED		(0x01)		/* Report DCE speed, instead of DTE speed */
#define	S95_ARQ				(0x02)		/* Append ARQ after CONNECT, when error control connection */
#define	S95_CARRIER			(0x04)		/* Enable CARRIER messages */
#define	S95_PROTOCOL		(0x08)		/* Enable PROTOCOL messages */
#define	S95_COMPRESSION		(0x20)		/* Enable COMPRESSION messages */

/*--------------------------------------------------------------------------
 *				%C representation values
 *-------------------------------------------------------------------------*/
#define	PER_C_NO_DC						'0'			/* No data compression */
#define	PER_C_DC_NIL					'F'			/* Void data compression */
#define	PER_C_DC_MNP5					'5'			/* MNP-5 data compression */
#define	PER_C_DC_V42B					'V'			/* V.42bis data compression */
#define	PER_C_DC_V42B_ENCODE_ONLY		'E'			/* V.42bis encoder only */
#define	PER_C_DC_V42B_DECODE_ONLY		'D'			/* V.42bis decoder only */
#define	PER_C_DC_V42B_MNP5				'*'			/* V.42bis+MNP-5 data compression */
#define	PER_C_DC_STAC_LZS				'S'			/* Stac Lzs data compression encode/decode */
#define	PER_C_DC_STAC_LZS_ENCODE_ONLY	'K'			/* Stac Lzs encoder only */
#define	PER_C_DC_STAC_LZS_DECODE_ONLY	'k'			/* Stac Lzs decoder only */

/*--------------------------------------------------------------------------
 *				S48 representation values
 *-------------------------------------------------------------------------*/
#define	S48_EC_NEGO_ENABLED		'N'			/* Negotiation enabled */
#define	S48_EC_NEGO_DISABLED	'V'			/* LAP-M direct */
#define	S48_EC_MNP4				'4'			/* MNP-4 direct */
#define	S48_EC_S36				'S'			/* Use S36 to negociate */

/*--------------------------------------------------------------------------
 *				S36 representation values
 *-------------------------------------------------------------------------*/
#define	S36_EC_FB_HANGUP		'h'	/* Hangup */
#define	S36_EC_FB_ASYN			'a'	/* Attempt asynchronous connection */
#define	S36_EC_FB_MNP_HANGUP	'm'	/* Attempt MNP connection, else hangup */
#define	S36_EC_FB_MNP_ASYN		'f'	/* Attempt MNP connection, else asynchronous connection */

/*--------------------------------------------------------------------------
 *				S113 representation values
 *-------------------------------------------------------------------------*/
#define		DTE_CH_113_HARSH_MSK						(0x01)	/* bit 0 */
#	define	DTE_CH_113_HARSH_CURRENT			(0x01)			/* # commands display the current value */

#define		DTE_CH_113_SWITCH_MSK						(0x02)	/* bit 1 */
#	define	DTE_CH_113_SWITCH_DISPLAY			(0x02)			/* display extended switch messages */

#define		DTE_CH_113_MPH_REPORT_MSK					(0x04)	/* bit 2 display MPH report messages */
#	define	DTE_CH_113_MPH_REPORT_DISPLAY 		(0x04)			/* display MPH report messages */

#define		DTE_CH_113_SETUP_ACK_MSK					(0x08)	/* bit 3 display SETUP_ACK message */
#	define	DTE_CH_113_SETUP_ACK_DISPLAY		(0x08)			/* display SETUP_ACK message */

#define		DTE_CH_113_PROGRESS_FMT_MSK					(0x10)	/* bit 4 */
#	define	DTE_CH_113_PROGRESS_FMT_DISPLAY		(0x10)			/* (bit 4) Display cause in hex in PROGRESS INDICATION */
																/*         and CALL PROCEEDING even in block mode */
#	define	Ch_chan_precise_progress() 						\
			((Ch_user_s113 & DTE_CH_113_PROGRESS_FMT_MSK) ? ON : OFF)

/*--------------------------------------------------------------------------
 *				S115 representation values
 *-------------------------------------------------------------------------*/
#define		DTE_CH_115_CALL_MSK		(0x01)
#	define	DTE_CH_115_CALL_CLEAR_ON_ALERT	(0x01)	/* Clear the outgoing call when ALERT is received */
#define		DTE_CH_115_SETUP_MSK	(0x08)
#	define	DTE_CH_115_SETUP_DISPLAY		(0x08)	/* Display incoming incompatible setups */

#define		DTE_CH_115_EXT_IND_MSK	(0xF0)			/* Extended indications mask */
													/* Extended indications encoding is done using a 4-bit integer, representing 16 values, with increasing level of detail */
													/* Possible (future) values are 0x00, 0x10, 0x20, 0x30, 0x40, 0x50 .. 0xF0 */
#	define		DTE_CH_115_EXT_IND_PH_RATE	(0x10)	/* Extended indication: ph rate */

/*--------------------------------------------------------------------------
 *				S118 representation values
 *-------------------------------------------------------------------------*/
#define		S118_ASYN	0				/* No frame structure */
#define		S118_SLIP	1				/* SLIP frame structure */
#if DTE_PPP == ON
#define		S118_PPP	2				/* PPP frame structure */
#endif

/*-------------------------------------------------------------------------
 *			DTE channel functions declarations
 *------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON

	uchar		dte_ch_and_c 			(uchar, uchar);
	uchar		dte_ch_and_d 			(uchar, uchar);
	uchar		dte_ch_and_r 			(uchar);
	uchar		dte_ch_and_s 			(uchar, uchar);
#	if DTE_MESSAGE_INTERFACE == ON
		void	dte_ch_mi_event			(short);
#	endif
#else

	uchar		dte_ch_and_c 			();
	uchar		dte_ch_and_d 			();
	uchar		dte_ch_and_r 			();
	uchar		dte_ch_and_s 			();
#	if DTE_MESSAGE_INTERFACE == ON
		void	dte_ch_mi_event			();
#	endif

#endif


/*--------------------------------------------------------------------------
 *				DTE channel context external declarations
 *-------------------------------------------------------------------------*/

#if DTE_MX_CH != 1

	extern	struct dte_channel_ctxt	*p_dte_channel; 		/* pointer on current DTE channel context */
	extern	struct dte_channel_ctxt	*p_dte_channel_tab;		/* pointer on DTE channel contexts table */
#	define	P_dte_channel			(p_dte_channel)
#	define	Get_ch_from_ix(i)		P_dte_channel = &p_dte_channel_tab [i]

#	define	Save_p_ch(p_ch)			p_ch = P_dte_channel
#	define	Restore_p_ch(p_ch)		P_dte_channel = p_ch

#else

	extern	struct dte_channel_ctxt	dte_channel_context;	/* single DTE channel context */
#	define	P_dte_channel			(&dte_channel_context)
#	define	Get_ch_from_ix(i)

#	define	Save_p_ch(p_ch)
#	define	Restore_p_ch(p_ch)

#endif

#define		Get_ass_na_from_ix(i)	Ch_cur_ass_na_ix = (i)

#endif	/* _DTE_CH */

/*EOF*/
