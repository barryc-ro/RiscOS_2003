
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * 	filename - dte.h
 *
 * $Revision$
 *
 * $Date$
 *
 * 	function(s)
 *
 *		Common declarations for DTE_INT entity.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    TR29-PACK                                        |*/
/*|    DTE_INT Entity                                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef	_DTE
#define _DTE

#include	"services.h"
#include	"dte_int.h"

#if SIMULATION == ON
#	include "simul.h"
#endif

	/*	Define compilation options, if they are not */

#ifndef ENT_PH_FAX
#	define	ENT_PH_FAX	ENT_PH_MODEM
#endif

#ifndef	DTE_VOICE
#	define	DTE_VOICE						OFF
#endif

#ifndef	DTE_RAW_DATA
#	define	DTE_RAW_DATA					OFF
#endif
#ifndef	DTE_RAW_TELEPHONY
#	define	DTE_RAW_TELEPHONY				OFF
#endif

#ifndef	DTE_MODEM
#	define	DTE_MODEM						OFF
#endif
#ifndef	DTE_V17
#	define	DTE_V17							OFF
#endif
#ifndef	DTE_V33
#	define	DTE_V33							OFF
#endif
#ifndef	DTE_V34
#	define	DTE_V34							OFF
#endif
#ifndef	DTE_CF_V110
#	define	DTE_CF_V110						OFF
#endif

#ifndef	DTE_FAX
#	define	DTE_FAX							OFF
#endif

#ifndef	DTE_EXT_CALL
#	define	DTE_EXT_CALL					OFF
#endif
#ifndef	DTE_EXT_CALLING_PARTY
#	define	DTE_EXT_CALLING_PARTY			OFF
#endif
#ifndef	DTE_EXT_CALLED_PARTY
#	define	DTE_EXT_CALLED_PARTY			OFF
#endif

#ifndef	DTE_EXT_CNF
#	define	DTE_EXT_CNF						OFF
#endif

#ifndef	DTE_PAD
#	define	DTE_PAD							OFF
#endif
#ifndef	DTE_X25
#	define	DTE_X25							OFF
#endif
#ifndef	DTE_PH_V110
#	define	DTE_PH_V110						OFF
#endif
#ifndef	DTE_PPP
#	define	DTE_PPP							OFF
#endif

#ifndef	DTE_ISDN_CC
#	define	DTE_ISDN_CC						OFF
#endif
#ifndef	DTE_AGGREGATED_ISDN_CC
#	define	DTE_AGGREGATED_ISDN_CC			OFF
#endif
#ifndef	DTE_ISDN_HARSH
#	define	DTE_ISDN_HARSH					OFF
#endif
#ifndef	DTE_ISDN_STAR
#	define	DTE_ISDN_STAR					OFF
#endif
#ifndef	DTE_ANALOG_ACU
#	define	DTE_ANALOG_ACU					OFF
#endif
#ifndef	DTE_PERMANENT_LINK
#	define	DTE_PERMANENT_LINK				OFF
#endif

#ifndef	DTE_TEST
#	define	DTE_TEST						OFF
#endif
#ifndef	DTE_NO_TEST_MODEM_FAX
#	define	DTE_NO_TEST_MODEM_FAX			OFF
#endif

#ifndef	DTE_COMM_PORT_SYNC
#	define	DTE_COMM_PORT_SYNC				OFF
#endif

#ifndef	DTE_Q2_DTR_POLL
#	define	DTE_Q2_DTR_POLL					OFF
#endif

#ifndef	DTE_Q2_DTR_PH_R
#	define	DTE_Q2_DTR_PH_R					OFF
#endif

#ifndef	DTE_SPEAKER
#	define	DTE_SPEAKER						OFF
#endif

#ifndef	DTE_INTERNAL
#	define	DTE_INTERNAL					OFF
#endif

#ifndef DTE_DYN_OUT_SERVICE
#	define	DTE_DYN_OUT_SERVICE				OFF
#endif

#ifndef	DTE_STS
#	define	DTE_STS							OFF
#endif

#ifndef DTE_SM_CFG_UPDATE
#	define	DTE_SM_CFG_UPDATE				OFF
#endif

#ifndef DTE_HELP
#	define	DTE_HELP						OFF
#endif

#ifndef	DTE_ASSERT
#	define	DTE_ASSERT						OFF
#endif

#ifndef	DTE_TRACE
#	define	DTE_TRACE						OFF
#endif

#ifndef	DTE_MATRA_TA_INTERFACE
#	define	DTE_MATRA_TA_INTERFACE			OFF
#endif

#ifndef	DTE_SEC_REMOTE_ID
#	define	DTE_SEC_REMOTE_ID				OFF
#endif

/* For DTE_SIMPLE_CHANNEL_ADDRESSING, see DTE_INT.H */

#ifndef	DTE_TIME_SLOT
#	define	DTE_TIME_SLOT					OFF
#endif

#ifndef	DTE_API
#	define	DTE_API							OFF
#endif

#ifndef	DTE_OVERLAP_SENDING
#	define	DTE_OVERLAP_SENDING				OFF
#endif

#ifndef	DTE_PAD_V120_COMPRESSION
#	define	DTE_PAD_V120_COMPRESSION		OFF
#endif

#ifndef	DTE_NO_SW_POLLING
#	define	DTE_NO_SW_POLLING				OFF
#endif

#ifndef	DTE_USE_PAD_V1
#	define	DTE_USE_PAD_V1					OFF
#endif

#ifndef	DTE_NO_PLUS_PLUS_PLUS
#	define	DTE_NO_PLUS_PLUS_PLUS			OFF
#endif
#ifndef DTE_USER_COMMANDS
#	define	DTE_USER_COMMANDS 				OFF
#endif
#ifndef Dte_user_command_expand
#	define	Dte_user_command_expand(ascii_command, num_arg)		P_NIL
#endif

#ifndef	DTE_SWITCH
#	define	DTE_SWITCH						OFF
#endif

#ifndef DTE_STAC_LZS
#	define	DTE_STAC_LZS					OFF
#endif

	/*-----------------------------*/
	/* Implied compilation options */
	/*-----------------------------*/
#if ((DTE_TEST == ON) && (DTE_NO_TEST_MODEM_FAX == OFF) && ((DTE_MODEM == ON) || (DTE_FAX == ON)))
#	define	_DTE_TEST_MODEM_FAX			ON
#else
#	define	_DTE_TEST_MODEM_FAX				OFF
#endif
#if ((DTE_TEST == ON) && (DTE_ISDN_CC == ON))
#	define	_DTE_TEST_ISDN				ON
#else
#	define	_DTE_TEST_ISDN					OFF
#endif

#if DTE_PAD == ON
#	undef	DTE_X25
#	define	DTE_X25							ON
#endif

#if DTE_EXT_CALL == ON
#	ifndef DTE_SPF_FACILITY
#		define	DTE_SPF_FACILITY			ON
#	endif
#	ifndef DTE_SUSPEND_FACILITY
#		define	DTE_SUSPEND_FACILITY		ON
#	endif
#else
#	undef	DTE_SPF_FACILITY
#	define	DTE_SPF_FACILITY				OFF
#	undef 	DTE_SUSPEND_FACILITY
#	define	DTE_SUSPEND_FACILITY			OFF
#endif

#if	DTE_SWITCH == ON
#	undef	DTE_ISDN_CC
#	define	DTE_ISDN_CC						ON
#endif

#if DTE_ISDN_CC == OFF
#	undef	DTE_AGGREGATED_ISDN_CC
#	define	DTE_AGGREGATED_ISDN_CC			OFF
#endif


#if DTE_TIME_SLOT == ON
#	define	DTE_TIME						ON
#else
#	define	DTE_TIME						OFF
#endif

#if DTE_ARINC_EXTENSIONS == ON
#	undef	DTE_TIME
#	define	DTE_TIME						ON
#endif

#ifndef	DTE_MX_CC_CALL_PER_LINE
#	define	DTE_MX_CC_CALL_PER_LINE			2
#endif

#ifndef	DTE_SCC_NB
#	define	DTE_SCC_NB						3
#endif


#define	DTE_MX_AT					(DTE_MX_DTE + DTE_MX_COMM_PORT)		/* Maximum number of AT interpreters */
#define	DTE_MX_JSIG					(DTE_MX_DTE + DTE_MX_COMM_PORT)		/* Maximum number of junction signals */

#define	DTE_TOTAL_ISDN_ADDR_SIZE	(DTE_ISDN_ADDR_SIZE + DTE_ISDN_SUB_ADDR_SIZE + 1)	/* Typical : address: 23, '*': 1, sub-address: 10 */

/*---------------------------------------------------------------------------
 *		General types
 *---------------------------------------------------------------------------
 *	Event : the DTE_EVENT_MASK bitfield indicates the unit in charge of
 *			the processing of the event.
 *
 *	The values in DTE_EVENT_MASK are defined in the respective xx_UNIT.H
 *	files.
 */

#define		event_id_t				ushort		/* event type */
#define		DTE_EVENT_MASK			0xE000

#define		DTE_CALL_IX_NIL			(-1)		/* No call */

#define		comm_port_ix_t			char		/* communication port index, must be signed */
#define		DTE_COMM_PORT_IX_NIL	(-1)		/* No communication port */

#define		DTE_CH_IX_NIL			0xFF		/* No DTE channel */

#define		dte_service_t			ushort

/*---------------------------------------------------------------------------
 *		General constants
 *--------------------------------------------------------------------------*/
#define		NO 				(0)
#define		YES				(1)

#define		DTE_MAX_USHORT		((ushort)(~0))	/* max value of ushort */

#define		DTE_CH_ID_NIL	0				/* non existent DTE channel */
#define		P_FCT_NIL		FCT_NIL


#ifndef	AT_WORK_SIZE
#	define 	AT_WORK_SIZE		(DTE_PIB_SIZE)	/* lexical element buffer size */
#endif

#define DTE_V120_HEADERS_SIZE	(6 + 4)				/* V.120 headers size (V.120 + LAP-D + MLP) */

/*--------------------------------------------------------------------------
 * 		DCE roles
 *-------------------------------------------------------------------------*/
#define		DTE_ROLE_ORIGINATOR		'o'			/* originator (caller) */
#define		DTE_ROLE_ANSWERER		'a'			/* answerer (called) */

/*--------------------------------------------------------------------------
 * 		DTE-DCE exchanged messages format
 *-------------------------------------------------------------------------*/

#define		DTE_STR_AT				'A'			/* AT standard format */
#define		DTE_STR_STAR			'*'			/* Extended '* commands' format */

/*---------------------------------------------------------------------------
 *		DTE trap codes
 *--------------------------------------------------------------------------*/

#define	TRAP_DTE_INTERNAL_ERROR		701		/* 0x2BD : internal error */
#define	TRAP_DTE_DTR_OFF			703		/* 0x2BF : DTR ON to OFF, AT&D5 */
#define	TRAP_DTE_BUFFER_TOO_SHORT	704		/* 0x2C0 : buffer size too small */
#define	TRAP_DTE_TRAP_REQUESTED		705		/* 0x2C1 : trap requested by At command */
#define	TRAP_DTE_NOT_INITIALIZED	707		/* 0x2C2 : DTE_INT entity not yet initialised */
#define	TRAP_DTE_BAD_DCE_SERVICE	710		/* 0x2C6 : inconsistent DCE service code */
#define	TRAP_DTE_BAD_ACU_SERVICE	711		/* 0x2C7 : inconsistent ACU service code */
#define	TRAP_DTE_BAD_PACKET_SIZE	712		/* 0x2C8 : illegal packet size */
#define	TRAP_DTE_ACCESS				713		/* 0x2C9 : access to contexts not possible */
#define	TRAP_DTE_EVENT				714		/* 0x2CA : unrecognized event */

#define	TRAP_DTE_PREP_SEND_MSG		719		/* 0x2CF : prepare sending message error :
												   p_snd_msg may be lost */
#define	TRAP_DTE_PRIMITIVE			720		/* 0x2D0 : incorrect primitive format from sending entity */
#define	TRAP_DTE_X25_PRIM_REJ		721		/* 0x2D1 : primitive rejected from Management X25 or X25 entity */
#define	TRAP_DTE_CALL_CLEAR_RQ		722		/* 0x2D2 : maintenance trap : trap if ACU_CLEAR_RQ requested */
#define	TRAP_DTE_CALL_CLEAR_IN		723		/* 0x2D3 : maintenance trap : trap if ACU_CLEAR_IN received */
#define	TRAP_DTE_CALL_CLEAR_CO		724		/* 0x2D4 : maintenance trap : trap if ACU_CLEAR_CO received */

#define	TRAP_DTE_DCC_RECEIVE		725		/* 0x2D5 : assertion trap : dte_dcc_receive */
#define	TRAP_DTE_DCC_EVENT			726		/* 0x2D6 : assertion trap : dte_dcc_event */
#define	TRAP_DTE_CP					727		/* 0x2D7 : assertion trap : communication port */
#define	TRAP_DTE_PER_C				728		/* 0x2D8 : assertion trap : invalid %C */
											/* */
#define	TRAP_DTE_ACC_CH_CALL		730		/* 0x2DA : assertion trap : access channel from call */
#define	TRAP_DTE_ACC_CH_CONN		731		/* 0x2DB : assertion trap : access channel from connection */
#define	TRAP_DTE_ACC_CH_DC_STREAM	732		/* 0x2DC : assertion trap : access channel from DC stream */
#define	TRAP_DTE_ACC_CH_JN			733		/* 0x2DD : assertion trap : access channel from junction id */
											/* */
#define	TRAP_DTE_ACC_CH_DL_CONN		735		/* 0x2DF : assertion trap : access channel from DL connection */
#define	TRAP_DTE_ACC_CH_CP_CONN		737		/* 0x2E1 : assertion trap : access channel from communication port */
#define	TRAP_DTE_ACC_CH_CP			738		/* 0x2E2 : assertion trap : access channel from communication port */
#define	TRAP_DTE_ACC_CH_IX			739		/* 0x2E3 : assertion trap : access channel from index */
#define	TRAP_DTE_ACC_CC_INCOMING	740		/* 0x2E4 : assertion trap : access channel for ACU/CC incoming call */
#define	TRAP_DTE_ACC_CP				741		/* 0x2E5 : assertion trap : access communication port */
#define	TRAP_DTE_ACC_JN				742		/* 0x2E6 : assertion trap : access junction */
#define	TRAP_DTE_ACC_NA				743		/* 0x2E7 : assertion trap : access network access */
#define	TRAP_DTE_ACC_X25_INCOMING	744		/* 0x2E8 : assertion trap : access channel for X.25 incoming call */
#define	TRAP_DTE_ACC_CH_NA_1		745		/* 0x2E9 : assertion trap : access channel from network access (data) */
#define	TRAP_DTE_ACC_CH_NA_2		746		/* 0x2EA : assertion trap : access channel from associated network access (data) */
#define	TRAP_DTE_ACC_CH_NA_3		747		/* 0x2EB : assertion trap : access channel from network access (signalling) */
#define	TRAP_DTE_ACC_CH_NA_4		748		/* 0x2EC : assertion trap : access channel from associated network access (signalling) */
#define	TRAP_DTE_ACC_CH_NA_5		749		/* 0x2ED : assertion trap : access channel from network access (signalling/facility or test) */
											/* */
#define	TRAP_DTE_AUX_EV				751		/* 0x2EF : assertion trap : AUX event */
#define	TRAP_DTE_CTS_EV				752		/* 0x2F0 : assertion trap : CTS event */
#define	TRAP_DTE_CD_EV				753		/* 0x2F1 : assertion trap : CD event */
#define	TRAP_DTE_DSR_EV				754		/* 0x2F2 : assertion trap : DSR event */
#define	TRAP_DTE_RI_EV				755		/* 0x2F3 : assertion trap : RI event */
#define	TRAP_DTE_DTR_EV				756		/* 0x2F4 : assertion trap : DTR event */
#define	TRAP_DTE_RTS_EV				757		/* 0x2F5 : assertion trap : RTS event */


	/*-- Trap codes greater than 770 are defined in PDTE.H --*/

	/* ASSERT trap codes */

#define	TRAP_DTE_ASSERT_ERROR		7800	/* 0x1E78 : general assert error */
#define	TRAP_DTE_ASSERT_01			7801	/* 0x1E79 : Assert error # 01 */
#define	TRAP_DTE_ASSERT_02			7802
#define	TRAP_DTE_ASSERT_03			7803
#define	TRAP_DTE_ASSERT_04			7804
#define	TRAP_DTE_ASSERT_05			7805
#define	TRAP_DTE_ASSERT_06			7806
#define	TRAP_DTE_ASSERT_07			7807
#define	TRAP_DTE_ASSERT_08			7808

#define	TRAP_DTE_B_CH_ACU			7809	/* 0x1E81 : invalid B channel returned by CC/ACU (in ACU_CONN_CO) (assert) */
#define	TRAP_DTE_ASS_NA_1			7810	/* 0x1E82 : inconsistency in associated na index, #1 */
#define	TRAP_DTE_ASS_NA_2			7811	/* 0x1E83 : inconsistency in associated na index, #1 */

#define	TRAP_DTE_ASSERT_18			7818
#define	TRAP_DTE_ASSERT_19			7819
#define	TRAP_DTE_ASSERT_20			7820
#define	TRAP_DTE_ASSERT_21			7821
#define	TRAP_DTE_ASSERT_22			7822
#define	TRAP_DTE_ASSERT_23			7823
#define	TRAP_DTE_ASSERT_24			7824
#define	TRAP_DTE_ASSERT_25			7825
#define	TRAP_DTE_ASSERT_26			7826
#define	TRAP_DTE_ASSERT_27			7827
#define	TRAP_DTE_ASSERT_28			7828
#define	TRAP_DTE_ASSERT_29			7829
#define	TRAP_DTE_ASSERT_30			7830
#define	TRAP_DTE_ASSERT_31			7831
#define	TRAP_DTE_ASSERT_32			7832
#define	TRAP_DTE_ASSERT_33			7833
#define	TRAP_DTE_ASSERT_34			7834
#define	TRAP_DTE_ASSERT_35			7835
#define	TRAP_DTE_ASSERT_36			7836	/* Assert error # 36 */
#define	TRAP_DTE_ASSERT_37			7837
#define	TRAP_DTE_ASSERT_38			7838
#define	TRAP_DTE_ASSERT_39			7839
#define	TRAP_DTE_ASSERT_40			7840
#define	TRAP_DTE_ASSERT_41			7841
#define	TRAP_DTE_ASSERT_42			7842
#define	TRAP_DTE_ASSERT_43			7843
#define	TRAP_DTE_ASSERT_44			7844
#define	TRAP_DTE_ASSERT_45			7845
#define	TRAP_DTE_ASSERT_46			7846

#define	TRAP_DTE_CL_CMD				7851	/* 0x1EAB : inconsistency, no dial command in progress */
#define	TRAP_DTE_CL_CALL			7852	/* 0x1EAC : inconsistency, no call context present */
#define	TRAP_DTE_CL_STATE			7853	/* 0x1EAD : inconsistency, call list state */
#define	TRAP_DTE_CL_EVENT			7854	/* 0x1EAE : inconsistency, unknown event */
#define	TRAP_DTE_CL_CALL_LIST		7855	/* 0x1EAF : configuration error: no call list available */
#define	TRAP_DTE_CL_NUMBER			7856	/* 0x1EB0 : no number to dial */
#define	TRAP_DTE_CL_DTE_CH			7857	/* 0x1EB1 : inconsistency, no associated DTE channel */

#define	TRAP_DTE_PPP_OUT_SYNC		7871	/* 0x1EBF : error while generating output synchronous frame */
#define	TRAP_DTE_PPP_IN_SYNC		7872	/* 0x1EC0 : error while decoding input synchronous frame */

	/*
	 *	Trap codes greater than 7970 are reserved for
	 *	DIST (DTE_INT Symbol Table management)
	 */

#define	XON							(0x11)	/* DC1 ascii code  */

/*---------------------------------------------------------------------------
 *		Configuration parameters
 *--------------------------------------------------------------------------*/

#define	DTE_BREAK_STD_LGTH	10


/*---------------------------------------------------------------------------
 *		DTE_INT DCC-related internal event codes
 *--------------------------------------------------------------------------*/
#define	DTE_DCC_INIT_DCC_EV				'I'		/* Initialize DCC */
#define	DTE_DCC_STOP_DCC_EV				'S'		/* Stop DCC */
#define	DTE_DCC_DC_PRIMITIVE_EV			'k'		/* Message from Data Compression */
#define	DTE_DCC_DTE_DATA_RCVD_EV		'D'		/* Data (to compress) received from DTE */
#define	DTE_DCC_NET_DATA_RCVD_EV		'd'		/* Data (to decompress) received from network (PAD) */
#define	DTE_DCC_ENC_FLUSH_TIMER_EV		'E'		/* Encoder flush timer expiration */
#define	DTE_DCC_DEC_FLUSH_TIMER_EV		'F'		/* Decoder flush timer expiration */
#define	DTE_DCC_DEC_FLOW_BUSY_EV		'B'		/* Decoded flow busy */
#define	DTE_DCC_DEC_FLOW_CLEAR_BUSY_EV	'C'		/* Decoded flow clear busy */

/*---------------------------------------------------------------------------
 *		Assertion macros
 *--------------------------------------------------------------------------*/
#if DTE_ASSERT == ON
#	define	Dte_assert(cond, code, str)	{ if (!(cond)) { Dte_trap (code, str); } }
#else
#	define	Dte_assert(cond, code, str)
#endif

#if (((DTE_ASSERT == ON) || (ASSERT == ON)) && (DTE_ASSERT_NO_STRING == OFF))
#	define	Dte_trap(code, str)		dte_trap (code, str)
#else
#	define	Dte_trap(code, str)		dte_trap (code)
#endif


/*---------------------------------------------------------------------------
 *		DTE message macros
 *-------------------------------------------------------------------------*/
#define	Dte_snd_prepare(data_size, p_old_msg)							\
	prepare_sending_message (data_size, (struct message FAR *)p_old_msg)


/*---------------------------------------------------------------------------
 *	Miscellaneous macros, to deal with the deficiencies of the Intel
 *	C 86 V3
 *-------------------------------------------------------------------------*/

#if C_COMPILER == IC86_V3
	/* Non-standard, extended definition */
#	define	Const_far_ptr_array(type, name)	CONST_ARRAY type FAR *name []
#	define	Const_ptr_array(type, name)		CONST_ARRAY type     *name []
#else
	/* Standard, correct definition */
#	define	Const_far_ptr_array(type, name)	type FAR * CONST_ARRAY name []
#	define	Const_ptr_array(type, name)		type     * CONST_ARRAY name []
#endif

typedef	short	cmd_id_t;		/* Command identifier */

/*---------------------------------------------------------------------------
 *		DTE_INT context for AT external commands, processed in separate
 *		entities
 *-------------------------------------------------------------------------*/
#if DTE_AT_EXTERNAL == ON

	struct ext_at_ctxt {
		uchar			ext_at_nb;		/* number of extended AT interpreters */

		struct _at_ext_entry {
			uchar		prefix [DTE_MX_EXT_AT_PREFIX_SIZE];/* prefix for the extended AT commands */
			ent_id_t	ent_id;							/* name of the entity hosting the extended AT interpreter */
			uchar		imm_ok;							/* ON : send an immediate ok when the AT command is entered */
		} at_ext_entries [1];							/* (dynamic allocation) */
	};

#define	Dte_ext_at_nb   				(p_dte_ext_at -> ext_at_nb)
#define	Dte_ext_at_prefix(i, j)			(p_dte_ext_at -> at_ext_entries [i] . prefix [j])
#define	Dte_ext_at_ent_id(i)			(p_dte_ext_at -> at_ext_entries [i] . ent_id)
#define	Dte_ext_at_imm_ok(i)			(p_dte_ext_at -> at_ext_entries [i] . imm_ok)

#define	Dte_ext_cmd_to_index(cmd_id)	((cmd_id) - I_AT_EXTERNAL)
#define	Dte_ext_index_to_cmd(i)			((i) + I_AT_EXTERNAL)

#define	Dte_ext_at_object_size(nb_dsc)	((((nb_dsc)-1) * Rnd_sizeof (struct _at_ext_entry)) + Rnd_sizeof(struct ext_at_ctxt))

#endif

/*---------------------------------------------------------------------------
 *			DTE_INT entity variables declarations
 *-------------------------------------------------------------------------*/

struct dte_entity {					/* DTE_INT entity description */
	uchar				init_flag;		/* init made indicator (ON, OFF) */
	uchar				built_flag;		/* objects built indicator (ON, OFF) */
	uchar				reconfig_flag;	/* reconfiguration indicator (ON, OFF) */
	uchar				nb_config;		/* number of (type 0) configuration buffers received */

	short				jn_nb;			/* total number of DTE junctions */
	short				scc_nb;			/* total number of SCCs */
	short				na_nb;			/* total number of network accesses */
	dte_call_ix_t		call_nb;		/* total number of calls */
	short				conn_nb;		/* total number of connections */
	short				ch_nb;			/* total number of DTE channels */
	short				comm_port_nb;	/* total number of communication ports */
	short				at_nb;			/* total number of AT interpreters */
	short				jsig_nb;		/* total number of junction signal groups */
	short				max_out_service_nb;/* total max number of outgoing services decription */
	short				out_service_nb;	/* total number of outgoing services decription */

#	if DTE_DIR_LIST == ON
	uchar				call_list_nb;	/* number of call lists */
#	endif

	uchar				from_user_profile;/* ON: configuration comes from user profile. OFF: comes from factory profile */

	uchar				more_config;	/* When configuring, ON: more configuration data follow. OFF: last configuration */
	short				cfg_i_jn;		/* When configuring, index of the next junction */
	short				cfg_i_at;		/* When configuring, index of the next AT interpreter */
#	if DTE_USE_CP == ON
	short				cfg_i_cp;		/* When configuring, index of the next communication port */
#	endif
	short				cfg_i_net;		/* When configuring, index of the next network access */
	short				cfg_i_ch;		/* When configuring, index of the next DTE channel */
	dte_call_ix_t		cfg_i_call;		/* When configuring, index of the next call */
	short				cfg_i_conn;		/* When configuring, index of the next connection */

#	if DTE_SM_CFG_UPDATE == ON
	uchar				profile_id;		/* reboot profile id */
#	endif

		/* PAD parameters */
		/*----------------*/
#	if DTE_PAD == ON
	uchar				pad_par_value;	/* PAD parameter value */
#	endif


#	if DTE_SEC_REMOTE_ID == ON
	uchar FAR			*p_callers_list; /* address of first callers list */
#	endif

#if DTE_API == ON
	ent_id_t			api_entity;		/* API entity name */
#endif

	struct {
		uchar			use_jn_id;			/* ON/OFF: use junction id (instead of junction internal index) for computing the update id values */
		uchar			use_nai;			/* ON/OFF: use network access signalling id (instead of na internal index) for computing the update id values */
		uchar			use_ch_unique_id;	/* ON/OFF: use DTE channel unique id (instead of DTE channel internal index) for computing the update id values */
	} upd;
	struct {
		uchar				cause;			/* failure cause */
		short				diag;			/* failure diagnostic (supplementary information) */
	}					work;			/* work variables */

#if ((DTE_USE_CP == ON) && (DTE_Q2_DTR_POLL == ON))

	struct {
		short				n_polls;		/* number of DTRs to poll */
		timer_val_t			tim_val;		/* DTR polling interval */
		uchar FAR			*tim_id;		/* DTR timer id */
		uchar				tim_sn;			/* DTR timer sequence number */
		uchar				tim_state;		/* DTR timer state */
	}					dtr;			/* DTR polling */

#endif

#if ((DTE_X25 == ON) || (DTE_V120 == ON))
	struct {
		add_t				data_chani;		/* B-channel identifier */
		sapi_t				dl_sapi;		/* DLSAP identifier */
		add_t				dl_ces;			/* DL CES identifier */
	}					x25_v120;
#endif

#if DTE_INTERNAL == ON

	uchar FAR		   *mem_addr;		/* current memory address */
	ulong				mem_def_length;	/* default range length */

#endif

#if DTE_LOG == ON

	int				    record_ix;		/* index of current record */
	int					nb_records;		/* number of records remaining to process */

#endif

#if DTE_SIMPLE_CHANNEL_ADDRESSING == ON
	struct {
		uchar				 data_chani;			/* B channel */
		uchar				 interworking;			/* ON: incoming call is interworking. OFF: is not */
		uchar				 isdn_or_x25_addr_size;	/* ISDN or X.25 address size */
		uchar				 isdn_sub_addr_size;	/* ISDN subaddress size */
		uchar				 uui_size;				/* UUI size */
		uchar				*p_isdn_or_x25_addr;	/* address of ISDN or X.25 address data */
		uchar				*p_isdn_sub_addr;		/* address of ISDN subaddress data */
		uchar				*p_uui;					/* address of UUI data */
	} sca;
#endif

#if DTE_TIME_SLOT == ON
	uchar FAR 				*p_slot_object;			/* address of slot descriptions object */
#endif
#if DTE_PPP == ON
	ushort	FAR 			*ppp_p_fcs_tab;			/* address of PPP FCS table */
#endif

#if DTE_AT_EXTERNAL == ON
	struct ext_at_ctxt FAR	*p_ext_at_object;		/* address of extended AT commands object */
#endif

	uchar					 t_work [AT_WORK_SIZE];	/* work buffer */

};

extern struct dte_entity	dte_entity;
#	define		Dte_api_entity					(dte_entity.api_entity)
#	define		Dte_built_flag					(dte_entity.built_flag)
#	define		Dte_call_list_nb				(dte_entity.call_list_nb)
#	define		Dte_cause						(dte_entity.work.cause)
#	define		Dte_diag						(dte_entity.work.diag)
#	define		Dte_init_flag					(dte_entity.init_flag)
#	define		Dte_at_nb						(dte_entity.at_nb)
#	define		Dte_comm_port_nb				(dte_entity.comm_port_nb)
#	define		Dte_conn_nb						(dte_entity.conn_nb)
#	define		Dte_call_nb						(dte_entity.call_nb)
#	define		Dte_cfg_i_at					(dte_entity.cfg_i_at)
#	define		Dte_cfg_i_call					(dte_entity.cfg_i_call)
#	define		Dte_cfg_i_ch					(dte_entity.cfg_i_ch)
#	define		Dte_cfg_i_conn					(dte_entity.cfg_i_conn)
#	define		Dte_cfg_i_cp					(dte_entity.cfg_i_cp)
#	define		Dte_cfg_i_jn					(dte_entity.cfg_i_jn)
#	define		Dte_cfg_i_net					(dte_entity.cfg_i_net)
#	define		Dte_ch_nb						(dte_entity.ch_nb)
#	define		Dte_data_chani					(dte_entity.x25_v120.data_chani)
#	define		Dte_dl_sapi						(dte_entity.x25_v120.dl_sapi)
#	define		Dte_dl_ces						(dte_entity.x25_v120.dl_ces)
#	define		Dte_from_user_profile			(dte_entity.from_user_profile)
#	define		Dte_jn_nb						(dte_entity.jn_nb)
#	define		Dte_jsig_nb						(dte_entity.jsig_nb)
#	define		Dte_max_out_service_nb			(dte_entity.max_out_service_nb)
#	define		Dte_more_config					(dte_entity.more_config)
#	define		Dte_na_nb						(dte_entity.na_nb)
#	define		Dte_nb_config					(dte_entity.nb_config)
#	define		Dte_out_service_nb				(dte_entity.out_service_nb)
#	define		Dte_p_callers_list				(dte_entity.p_callers_list)
#	define		Dte_reconfig_flag				(dte_entity.reconfig_flag)
#	define		Dte_scc_nb						(dte_entity.scc_nb)
#	define		Dte_upd_use_jn_id				(dte_entity.upd.use_jn_id)
#	define		Dte_upd_use_nai					(dte_entity.upd.use_nai)
#	define		Dte_upd_use_ch_unique_id		(dte_entity.upd.use_ch_unique_id)

#	define		Dte_profile_id					(dte_entity.profile_id)

#	define		Dte_pad_par_value				(dte_entity.pad_par_value)

#	define		Dte_ppp_p_fcs_tab				(dte_entity.ppp_p_fcs_tab)

#	define		Dte_dtr_n_polls                 (dte_entity.dtr.n_polls)
#	define		Dte_dtr_tim_val                 (dte_entity.dtr.tim_val)
#	define		Dte_dtr_tim_id                  (dte_entity.dtr.tim_id)
#	define		Dte_dtr_tim_sn                  (dte_entity.dtr.tim_sn)
#	define		Dte_dtr_tim_state               (dte_entity.dtr.tim_state)

#	define		Dte_mem_addr					(dte_entity.mem_addr)
#	define		Dte_mem_def_length				(dte_entity.mem_def_length)

#	define		Dte_record_ix					(dte_entity.record_ix)
#	define		Dte_nb_records					(dte_entity.nb_records)

#	define		Sca_data_chani					(dte_entity.sca.data_chani)
#	define		Sca_isdn_interworking			(dte_entity.sca.interworking)
#	define		Sca_isdn_or_x25_addr_size		(dte_entity.sca.isdn_or_x25_addr_size)
#	define		Sca_isdn_sub_addr_size			(dte_entity.sca.isdn_sub_addr_size)
#	define		Sca_p_isdn_or_x25_addr			(dte_entity.sca.p_isdn_or_x25_addr)
#	define		Sca_p_isdn_sub_addr				(dte_entity.sca.p_isdn_sub_addr)
#	define		Sca_p_uui						(dte_entity.sca.p_uui)
#	define		Sca_uui_size					(dte_entity.sca.uui_size)

#	define		P_slot_object					(dte_entity.p_slot_object)
#	define		Dte_p_ext_at_object				(dte_entity.p_ext_at_object)
#	define		Tvc_a_work						(dte_entity.t_work)

#	define		Dte_nok(cause, diag)			{ Dte_cause = cause; Dte_diag = diag; Dte_assert (0, cause + 7000, "dte/Dte_nok"); return (NOK); }



#define		event_id		event_id_dte	 /* event identifier */
#define		p_data			p_data_dte

#if SIMULATION == OFF

#	define 	p_snd_msg		p_snd_msg_dte	 /* pointer on the current message to send if any */
#	define 	p_rcv_msg		p_rcv_msg_dte	 /* pointer on the current received message if any */
#	define 	p_buffer		p_buffer_dte	 /* pointer on the current buffer if any */

#endif


extern	event_id_t						event_id; 		/* event identifier */
extern	struct 	message 			FAR	*p_snd_msg; 	/* pointer on the current message to send if any */
extern	struct	message 			FAR	*p_rcv_msg; 	/* pointer on the current received message if any */
extern	struct 	buffer  			FAR	*p_buffer;		/* pointer on the curent buffer if any */

extern	uchar						FAR	*p_data;		/* pointer on user data in primitives	*/

extern	struct dte_config_buffer	FAR	*p_dte_config;			/* pointer on configuration buffer */
extern	struct dte_config_list_dte_channel 	FAR *p_dte_list_dte_channel_config;	/* pointer on configuration buffer */
extern	struct dte_config			FAR *p_dte_config_jn;		/* pointer on configuration structure, junction */
extern	struct dte_na_config		FAR *p_dte_config_na;		/* pointer on configuration structure, network access */
extern	struct dte_ch_config		FAR *p_dte_config_ch;		/* pointer on configuration structure, channel */


/*---------------------------------------------------------------------------
 *		Access macros
 *-------------------------------------------------------------------------*/

#if NEW_FCT_STYLE == ON
	extern	uchar 	dte_acc_ch_from_jn 				(nai_t);
	extern	uchar 	dte_acc_ch_from_cc_call_id		(uchar, nai_t, add_t);
	extern	uchar 	dte_acc_ch_from_comm_port_id	(nai_t);
	extern	uchar 	dte_acc_ch_from_cp_na_only		(nai_t);
	extern	uchar 	dte_acc_ch_from_cp_na_conn		(nai_t, add_t);
	extern	uchar 	dte_acc_ch_from_data_conn		(nai_t, add_t);
#if DTE_PAD_V120_COMPRESSION == ON
	extern	uchar 	dte_acc_ch_from_dc_stream		(nai_t, add_t);
#endif
	extern	uchar 	dte_acc_ch_from_dl_sapi_ces		(nai_t, sapi_t, add_t);
#if DTE_AT_EXTERNAL == ON
	extern uchar	dte_acc_ch_from_ext_jn_id 		(nai_t);
#endif
	extern	uchar 	dte_acc_ch_from_na_data			(nai_t);
	extern	uchar 	dte_acc_ch_from_na_sig			(nai_t nai, code_t code, uchar FAR *p_data, uchar access_key);
	extern	uchar 	dte_acc_ch_from_id				(nai_t, uchar);
	extern	uchar 	dte_acc_ch_from_mx25_refs		(nai_t, add_t);
	extern	uchar 	dte_acc_ch_from_ph_b_refs		(nai_t, add_t);
	extern	uchar 	dte_acc_ch_from_user_refs		(ent_id_t, nai_t, sapi_t, uchar);
	extern	uchar 	dte_acc_ch_from_x25_conn		(nai_t, sapi_t, add_t);
	extern	uchar 	dte_acc_ch_from_x25_dl_conn		(nai_t, sapi_t, add_t,
													 sapi_t);
#if DTE_V120 == ON
	extern	uchar 	dte_acc_ch_from_v120_dl_conn	(nai_t, add_t, sapi_t);
#endif
#if DTE_DIR_LIST == ON
	extern	uchar 	dte_acc_ch_from_call_list_id	(uchar);
#endif

#	if DTE_MX_COMM_PORT != 1
		extern	uchar	dte_acc_comm_port_from_id	(uchar);
#	endif

#	if DTE_MX_NA != 1

#		if ((DTE_ISDN_CC == ON ) && (DTE_FAX == ON))
			extern	uchar 	dte_acc_net_from_na_acu	(nai_t);
#		endif

		extern	uchar 	dte_acc_net_from_na_data	(nai_t);
		extern	uchar 	dte_acc_net_from_na_sig		(nai_t);
#	endif

#else
	extern	uchar 	dte_acc_ch_from_jn 				();
	extern	uchar 	dte_acc_ch_from_cc_call_id		();
	extern	uchar 	dte_acc_ch_from_comm_port_id	();
	extern	uchar 	dte_acc_ch_from_cp_na_only		();
	extern	uchar 	dte_acc_ch_from_cp_na_conn		();
	extern	uchar 	dte_acc_ch_from_data_conn		();
#if DTE_PAD_V120_COMPRESSION == ON
	extern	uchar 	dte_acc_ch_from_dc_stream		();
#endif
	extern	uchar 	dte_acc_ch_from_dl_sapi_ces		();
#if DTE_AT_EXTERNAL == ON
#	extern uchar	dte_acc_ch_from_ext_jn_id 		();
#endif
	extern	uchar 	dte_acc_ch_from_na_data			();
	extern	uchar 	dte_acc_ch_from_na_sig			();
	extern	uchar 	dte_acc_ch_from_id				();
	extern	uchar 	dte_acc_ch_from_mx25_refs		();
	extern	uchar 	dte_acc_ch_from_ph_b_refs		();
	extern	uchar 	dte_acc_ch_from_user_refs		();
	extern	uchar 	dte_acc_ch_from_x25_conn		();
	extern	uchar 	dte_acc_ch_from_x25_dl_conn		();
#if DTE_V120 == ON
	extern	uchar 	dte_acc_ch_from_v120_dl_conn	();
#endif
#if DTE_DIR_LIST == ON
	extern	uchar 	dte_acc_ch_from_call_list_id	();
#endif

#	if DTE_MX_COMM_PORT != 1
		extern	uchar	dte_acc_comm_port_from_id	();
#	endif
#	if DTE_MX_NA != 1

#		if ((DTE_ISDN_CC == ON ) && (DTE_FAX == ON))
			extern	uchar 	dte_acc_net_from_na_acu	();
#		endif

		extern	uchar 	dte_acc_net_from_na_data	();
		extern	uchar 	dte_acc_net_from_na_sig		();
#	endif

#endif

#define	Access_ch_from_jn(jn_id)					dte_acc_ch_from_jn (jn_id)
#define	Access_ch_from_cc_call_id(access_key, nai, cc_call_id)			\
			dte_acc_ch_from_cc_call_id (access_key, nai, cc_call_id)
#define	Access_ch_from_comm_port_id(nai)			dte_acc_ch_from_comm_port_id (nai)
#define	Access_ch_from_cp_na_only(nai)				dte_acc_ch_from_cp_na_only (nai)
#define	Access_ch_from_cp_na_conn(nai, conn_id)		dte_acc_ch_from_cp_na_conn (nai, conn_id)
#define	Access_ch_from_data_conn(nai, sapi, conn_id) dte_acc_ch_from_data_conn (nai, conn_id)
#define	Access_ch_from_dl_sapi_ces(nai, sapi, ces)	dte_acc_ch_from_dl_sapi_ces (nai, sapi, ces)
#define	Access_ch_from_ext_jn_id(nai, sapi, conn_id)	dte_acc_ch_from_ext_jn_id (nai)

#define	Access_ch_from_mx25_refs(nai, dl_sapi, data_chani)	\
													dte_acc_ch_from_mx25_refs (nai, data_chani)
#define	Access_ch_from_na_data(nai)					dte_acc_ch_from_na_data (nai)
#define	Access_ch_from_na_sig(nai, code, p_data, access_key)	\
													dte_acc_ch_from_na_sig (nai, code, p_data, access_key)
#define	Access_ch_from_ph_b_refs(nai, sapi, b_ch)	dte_acc_ch_from_ph_b_refs (nai, b_ch)
#define	Access_ch_from_user_refs(ent_id, nai, sapi, code)		\
													dte_acc_ch_from_user_refs (ent_id, nai, sapi, code)
#define	Access_ch_from_x25_conn(nai, sapi, conn_id)	dte_acc_ch_from_x25_conn (nai, sapi, conn_id)
#define	Access_ch_from_x25_dl_conn(nai, x25_sapi, conn_id, dl_sapi)		\
													dte_acc_ch_from_x25_dl_conn (nai, x25_sapi, conn_id, dl_sapi)
#define	Access_ch_from_v120_dl_conn(nai, dl_sapi, conn_id)		\
													dte_acc_ch_from_v120_dl_conn (nai, dl_sapi, conn_id)

#if DTE_PAD_V120_COMPRESSION == ON
#	define	Access_ch_from_dc_stream(nai, stream_id) dte_acc_ch_from_dc_stream (nai, stream_id)
#endif
#if DTE_DIR_LIST == ON
#	define	Access_ch_from_call_list_id(call_list_id)	dte_acc_ch_from_call_list_id (call_list_id)
#endif

#if DTE_USE_CP == ON
#	if DTE_MX_COMM_PORT != 1
#		define	Access_comm_port_from_id(cp_id)		dte_acc_comm_port_from_id (cp_id)
#	else
#		define	Access_comm_port_from_id(cp_id)		((Comm_port_id == cp_id) ? OK : NOK)
#	endif
#endif

#define	Access_jn_from_id(jn_id)					dte_acc_jn_from_id (jn_id)

#if DTE_MX_NA != 1
#	define	Access_net_from_na_sig(nai)				dte_acc_net_from_na_sig (nai)
#	define	Access_net_from_na_data(nai)			dte_acc_net_from_na_data (nai)

#	if ((DTE_ISDN_CC ==  ON) && (DTE_FAX == ON))
#		define	Access_net_from_na_acu(nai)			dte_acc_net_from_na_acu (nai)
#	endif

#else
#	define	Access_net_from_na_sig(nai)				((Net_nai_sig == nai) ? OK : NOK)
#	define	Access_net_from_na_data(nai)			((Net_nai_data == nai) ? OK : NOK)

#	if ((DTE_ISDN_CC ==  ON) && (DTE_FAX == ON))
#		define	Access_net_from_na_acu(nai)			((Net_nai_acu == nai) ? OK : NOK)
#	endif

#endif

#if DTE_MX_CH != 1
#	define	Access_ch_from_id(jn_id, ch_id)			dte_acc_ch_from_id (jn_id, ch_id)
#else
#	define	Access_ch_from_id(jn_id, ch_id)			(((Ch_id == ch_id) && (Ch_jn_id == jn_id)) ? OK : NOK)
#endif


#if NEW_FCT_STYLE == ON
	extern	void 	dte_acc_objects_from_ch		(void);
#else
	extern	void 	dte_acc_objects_from_ch		();
#endif

#define	Access_objects_from_ch()	dte_acc_objects_from_ch ()

/*--------------------------------------------------------------------------
 *		Context access codes
 *-------------------------------------------------------------------------*/
#define		ACC_NONE				0	/* No access */
#define		ACC_JN					1	/* Access from DTE link id */
#if ((DTE_ISDN_CC == ON) || (DTE_ANALOG_ACU == ON))
#	define	ACC_CALL_ID				2	/* Access from CC/ACU call id */
#endif
#define		ACC_CONN_DATA			3	/* Access from data connection */
#if DTE_X25 == ON
#	define	ACC_CONN_X25			4	/* Access from X.25 (PAD) connection */
#	define	ACC_X25_DL_CONN			5	/* Access from X.25 connection + DLSAP */
#endif
										/* */
#define		ACC_NA_DATA				7	/* Access from 'data' nai */

#if DTE_USE_CP == ON
#	define	ACC_COMM_PORT_ID		8	/* Access from nai */
#	define	ACC_CP_NA_ONLY			9	/* Access from nai (DTE junction or ISDN na) */
#	define	ACC_CP_NA_CONN			10	/* Access from ISDN nai, connid (for communication port) */
#endif

#define		ACC_CH_IX_1				11	/* Access from DTE channel index, na */
#define		ACC_CH_IX_2				12	/* Access from DTE channel index, conn_id */

#if DTE_PAD_V120_COMPRESSION == ON
#	define	ACC_DC_STREAM			13	/* Access from DC stream references */
#endif
#if DTE_V120 == ON
#	define	ACC_V120_NA_SAPI_CES	14	/* Access from V.120 na/sap/ces (attach and co) */
#	define	ACC_V120_DL_CONN		15	/* Access from X.25 connection + DLSAP */
#endif
#if DTE_X25 == ON
#	define	ACC_MX25_REFS			16	/* Access from MX25 references */
#endif
#if ((DTE_PH_V110 == ON) || (DTE_ASYN_TO_PH == ON))
#	define	ACC_PH_B_REFS			17	/* Access from PH-B references */
#endif
#if DTE_DIR_LIST == ON
#	define	ACC_CALL_LIST_ID		18	/* Access from call list identifier */
#endif
#if DTE_MESSAGE_INTERFACE == ON
#	define	ACC_USER_REFS			19	/* Access from user references */
#endif
#if DTE_AT_EXTERNAL == ON
#	define	ACC_EXT_JN_ID			20	/* Access from 'external junction id' */
#endif
#if ((DTE_ISDN_CC == ON) && (DTE_FAX == ON))
#	define	ACC_CALL_CED_CNG		21	/* Access from call id, using 'nai data' */
#endif

#define		ACC_NA_SIG_MGT			22	/* Access from 'signalling' nai - management DTE channel */

#if _DTE_TEST_ISDN == ON
#	define	ACC_NA_SIG_TEST			23	/* Access from 'signalling' nai - DTE channel which has a pending TEST request */
#endif
#if DTE_SPF_FACILITY == ON
#	define		ACC_NA_SIG_FAC		24	/* Access from 'signalling' nai - DTE channel which has a pending facility request */
#endif

#define		ACC_DELAYED				30	/* Access delayed */
#define		ACC_DONE				31	/* DTE channel access already done */
#define		ACC_IGNORE				32	/* No access to do, primitive should be ignored */

/*--------------------------------------------------------------------------
 *		ISDN address format
 *-------------------------------------------------------------------------*/
#ifndef	DTE_ISDN_CALL_SUB_ADDRESS_SEPARATOR
#	define	DTE_ISDN_CALL_SUB_ADDRESS_SEPARATOR			'*'
#endif
#define		Is_call_sub_addr_separator(c)		((c) == DTE_ISDN_CALL_SUB_ADDRESS_SEPARATOR)


#ifndef	DTE_ISDN_CALL_OTHER_ADDRESS_SEPARATOR
#	define	DTE_ISDN_CALL_OTHER_ADDRESS_SEPARATOR		'&'
#endif
#define		Is_call_other_addr_separator(c)		((c) == DTE_ISDN_CALL_OTHER_ADDRESS_SEPARATOR)


/*---------------------------------------------------------------------------
 *		Authentification
 *-------------------------------------------------------------------------*/

#if	DTE_SEC_REMOTE_ID == ON
#	define	Dte_sec_check_conn_in(p_msg)	dte_sec_check_conn_in (p_msg)
#else
#	define	Dte_sec_check_conn_in(p_msg)	(ON)
#endif

/*---------------------------------------------------------------------------
 *		Message display
 *-------------------------------------------------------------------------*/
#if DTE_PAD == ON
#	define	Dte_ch_display_allowed()	dte_ch_display_allowed ()
#else
#	define	Dte_ch_display_allowed()	ON
#endif

/*---------------------------------------------------------------------------
 *			PPP
 *-------------------------------------------------------------------------*/
	/* Size of the PPP FCS table */
#define	DTE_PPP_FCS_TABLE_SIZEOF	Rnd_sizeof (ushort [256])
#if NEW_FCT_STYLE == ON
	void 	dte_ppp_asyn_build_fcs_table (ushort	fcs_tab [256]);
#else
	void 	dte_ppp_asyn_build_fcs_table ();
#endif


/*---------------------------------------------------------------------------
 *		DTE memory traces
 *-------------------------------------------------------------------------*/
#if (DTE_TRACE == ON)

#define	DTE_RED_COLOR		0x04
#define	DTE_YELLOW_COLOR	0x0D
#define	DTE_GREEN_COLOR		0x02
#define	DTE_STD_COLOR		0x07

#	if NEW_FCT_STYLE == ON
		void 	dttr_ascii			(uchar, uchar);
		void 	dttr_byte			(uchar, uchar);
		void 	dttr_disable		(void);
		void 	dttr_enable			(void);
		void 	dttr_init			(void);
		void 	dttr_string			(uchar, char *);
#	else
		void 	dttr_ascii			();
		void 	dttr_byte			();
		void 	dttr_disable		();
		void 	dttr_enable			();
		void 	dttr_init			();
		void 	dttr_string			();
#	endif

#	define Dttr_ascii(byte)					dttr_ascii (DTE_STD_COLOR, (uchar)(byte))
#	define Dttr_ascii_color(color, byte)	dttr_ascii (color, (uchar)(byte))
#	define Dttr_byte(byte)					dttr_byte (DTE_STD_COLOR, (uchar)(byte))
#	define Dttr_byte_color(color, byte)		dttr_byte (color, (uchar)(byte))
#	define Dttr_disable()					dttr_disable ()
#	define Dttr_enable()					dttr_enable ()
#	define Dttr_init()						dttr_init ()
#	define Dttr_string(p)					dttr_string (DTE_STD_COLOR, p)
#	define Dttr_string_color(color, p)		dttr_string (color, p)

#else

#	define Dttr_ascii(byte)
#	define Dttr_ascii_color(color, byte)
#	define Dttr_byte(byte)
#	define Dttr_byte_color(color, byte)
#	define Dttr_disable()
#	define Dttr_enable()
#	define Dttr_init()
#	define Dttr_string(p)
#	define Dttr_string_color(color, p)

#endif

/*---------------------------------------------------------------------------
 *		Macros for PDTE access
 *-------------------------------------------------------------------------*/

#if DTE_MESSAGE_INTERFACE == ON
#	define	Ph_dte_jn_active()	((Ch_mi_user_entity == ENT_NIL) &&			\
								 (Jn_disable == OFF))
#	define	Ph_dte_jn_enabled()	(Jn_disable == OFF)

#	define	Ph_dte_redirect_data(p_msg)										\
				{ if (Ch_mi_user_entity != ENT_NIL) {						\
					dte_jn_mi_queue_send_data (p_msg,								\
						(at_state () == AT_CMD_STATE) ? 					\
						DTE_INT_AT_IN : DTE_INT_DA_IN);						\
				  } else { Free_msg (p_msg); } }

#	define	Ph_dte_redirect_data_ret(p_msg, ret_code)						\
			{ if (Ch_mi_user_entity != ENT_NIL) {							\
				ret_code = dte_jn_mi_queue_send_data (p_msg,					\
							(at_state () == AT_CMD_STATE) ? 				\
							DTE_INT_AT_IN : DTE_INT_DA_IN);					\
			  } else { Free_msg (p_msg); ret_code = CONTINUE; } }

#	define	Ph_dte_redirect_signal(code)									\
					{ if (Ch_mi_user_entity != ENT_NIL) {					\
						dte_snd_mi (P_NIL, code); } }
#else
#	define	Ph_dte_jn_active()							(Jn_disable == OFF)
#	define	Ph_dte_redirect_data(p_msg)					{ Free_msg (p_msg); }
#	define	Ph_dte_redirect_data_ret(p_msg, ret_code)						\
								{ Ph_dte_redirect_data (p_msg); ret_code = CONTINUE; }
#	define	Ph_dte_redirect_signal(code)
#endif

#if DTE_ASSERT == ON
#	define	Ph_dte_at_change_mode(P_pdte_ctxt, byte)	Trace ('('); Trace ('a'); Trace (byte); Trace (')'); Ph_dte_change_mode (P_pdte_ctxt, DTE_ATREAD, PD_PAD_DTR_IGNORE);
#else
#	define	Ph_dte_at_change_mode(P_pdte_ctxt, byte)	Ph_dte_change_mode (P_pdte_ctxt, DTE_ATREAD, PD_PAD_DTR_IGNORE);
#endif
#define	Ph_dte_change_mode(p_ph_ctxt, mode, dtr)							\
		 if (Ph_dte_jn_active ()) { Hdl_change_mode (p_ph_ctxt, mode, dtr); }
#define	Ph_dte_da_rq_received(p_ph_ctxt, sapi)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_da_rq_received (p_ph_ctxt, sapi); }

#define	Ph_dte_get_autobaud(p_ph_ctxt)										\
		 (Ph_dte_jn_active () ? Hdl_get_autobaud (p_ph_ctxt) : 0)
#define	Ph_dte_get_block_size(p_ph_ctxt)									\
		 (Ph_dte_jn_active () ? Hdl_get_block_size (p_ph_ctxt) : 0)
#define	Ph_dte_get_cap_autobaud(p_ph_ctxt, rate)							\
		 (Ph_dte_jn_active () ? Hdl_get_cap_autobaud (p_ph_ctxt, rate) : 	\
								(PD_AB_CAP_MONOBAUD|PD_AB_CAP_AUTOBAUD))
#define	Ph_dte_get_junction_rate(p_ph_ctxt)									\
		 (Ph_dte_jn_active () ? Hdl_get_junction_rate (p_ph_ctxt) : 0)
#define	Ph_dte_get_dtr(p_ph_ctxt)											\
		 (Ph_dte_jn_active () ? Hdl_get_dtr (p_ph_ctxt) : JSIG_ON)
#define	Ph_dte_get_rts(p_ph_ctxt)											\
		 (Ph_dte_jn_active () ? Hdl_get_rts (p_ph_ctxt) : JSIG_ON)

#define	Ph_dte_init(p_ph_ctxt, a_pdte, scc_nb, jn_id, e, cl, st, p, rate)	\
		 ((Jn_disable == OFF) ? (Hdl_init (p_ph_ctxt, a_pdte, scc_nb, 		\
								 jn_id, e, cl, st, p, rate)) : OK)
#define	Ph_dte_jn_rq_received(p_ph_ctxt, sapi)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_jn_rq_received (p_ph_ctxt, sapi); }
#define	Ph_dte_reinit(p_ph_ctxt)											\
		 if (Jn_disable == OFF) { Hdl_reinit (p_ph_ctxt); }
#define	Ph_dte_reset_config(p_ph_ctxt)										\
		 if (Jn_disable == OFF) { Hdl_reset_config (p_ph_ctxt); }

#define	Ph_dte_is_xmt_congested(p_ph_ctxt)									\
		 (Ph_dte_jn_active () ? (Hdl_is_xmt_congested (p_ph_ctxt)) : OFF)
#define	Ph_dte_reset_break(p_ph_ctxt)										\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_reset_break (p_ph_ctxt); }
#define	Ph_dte_reset_busy(p_ph_ctxt)										\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_reset_busy (p_ph_ctxt); }

#define	Ph_dte_send_busy_in(p_ph_ctxt)										\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_send_busy_in (p_ph_ctxt); }									\
		 else { Ph_dte_redirect_signal (DTE_INT_BUSY_IN); }
#define	Ph_dte_send_clear_busy_in(p_ph_ctxt)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_send_clear_busy_in (p_ph_ctxt); }							\
		 else { Ph_dte_redirect_signal (DTE_INT_CLEAR_BUSY_IN); }

#define	Ph_dte_send_break_in(p_ph_ctxt)										\
		 if (Ph_dte_jn_active ()) { struct message FAR *p_msg;				\
			p_msg	= Alloc_msg ();											\
			Hdl_send_break_in (p_ph_ctxt, p_msg); }
#define	Ph_dte_send_data_in(p_ph_ctxt, p_msg)								\
		 if (Ph_dte_jn_active ()) { Hdl_send_data_in (p_ph_ctxt, p_msg); }	\
		 else { Ph_dte_redirect_data (p_msg); }
#define	Ph_dte_send_data_in_ret(p_ph_ctxt, p_msg, ret_code)					\
		 if (Ph_dte_jn_active ()) {											\
			ret_code = Hdl_send_data_in (p_ph_ctxt, p_msg); }				\
		 else { Ph_dte_redirect_data_ret (p_msg, ret_code); }
#define	Ph_dte_send_transparent_data(p_ph_ctxt, p_msg)						\
		 if (Ph_dte_jn_enabled ()) { Hdl_send_data_in (p_ph_ctxt, p_msg); }
#define	Ph_dte_set_at_char_format(p_ph_ctxt, nbits, parity)					\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_at_char_format (p_ph_ctxt, nbits, parity); }
#define	Ph_dte_set_at_echo(p_ph_ctxt, on_off)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_at_echo (p_ph_ctxt, on_off); }
#define	Ph_dte_set_autobaud(p_ph_ctxt, val)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_autobaud (p_ph_ctxt, val); }
#define	Ph_dte_set_aux(p_ph_ctxt, state)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_aux (p_ph_ctxt, state); }
#define	Ph_dte_set_bit_m(p_ph_ctxt, on_off)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_bit_m (p_ph_ctxt, on_off); }
#define	Ph_dte_set_block_size(p_ph_ctxt, size)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_block_size (p_ph_ctxt, size); }
#define	Ph_dte_set_break(p_ph_ctxt)											\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_break (p_ph_ctxt); }
#define	Ph_dte_set_cd(p_ph_ctxt, state)										\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_cd (p_ph_ctxt, state); }
#define	Ph_dte_set_cts(p_ph_ctxt, state)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_cts (p_ph_ctxt, state); }
#define	Ph_dte_set_char(p_ph_ctxt, code, character)							\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_char (p_ph_ctxt, code, character); }
#if DTE_PAD == ON
#define	Ph_dte_set_cd_in_pad_command(p_ph_ctxt, on_off)						\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_cd_in_pad_command (p_ph_ctxt, on_off); }
#endif
#define	Ph_dte_set_cd_proc(p_ph_ctxt, proc)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_cd_proc (p_ph_ctxt, proc); }
#define	Ph_dte_set_dsr(p_ph_ctxt, state)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_dsr (p_ph_ctxt, state); }
#define	Ph_dte_set_dsr_proc(p_ph_ctxt, proc)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_dsr_proc (p_ph_ctxt, proc); }
#define	Ph_dte_set_dtr_proc(p_ph_ctxt, proc)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_dtr_proc (p_ph_ctxt, proc); }
#define	Ph_dte_set_fc(p_ph_ctxt, xon, rts)									\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_fc (p_ph_ctxt, xon, rts); }
#define	Ph_dte_set_idle(p_ph_ctxt, duration)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_v120_idle (p_ph_ctxt, duration); }
#define	Ph_dte_set_line_rate(p_ph_ctxt, rate)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_line_rate (p_ph_ctxt, rate); }
#define	Ph_dte_set_ri(p_ph_ctxt, state)										\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_set_ri (p_ph_ctxt, state); }

#if DTE_NO_PLUS_PLUS_PLUS == ON
#	define	Ph_dte_set_s012(p_ph_ctxt, s012_ms)
#else
#	define	Ph_dte_set_s012(p_ph_ctxt, s012_ms)								\
			 if (Ph_dte_jn_active ()) {										\
				Hdl_set_s012 (p_ph_ctxt, s012_ms); }
#endif

#define	Ph_dte_start_latency_timer(p_ph_ctxt)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_start_latency_timer (p_ph_ctxt); }
#define	Ph_dte_stop_latency_timer(p_ph_ctxt)								\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_stop_latency_timer (p_ph_ctxt); }
#define	Ph_dte_stop_timers(p_ph_ctxt)										\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_stop_timers (p_ph_ctxt); }
#define	Ph_dte_suppress_pad_messages(p_ph_ctxt, state)						\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_suppress_pad_messages (p_ph_ctxt, state); }
#define	Ph_dte_switch_autobaud(p_ph_ctxt, on_off)							\
		 if (Ph_dte_jn_active ()) {											\
			Hdl_switch_autobaud (p_ph_ctxt, on_off); }


	/* Local macros definitions, time management */

#ifndef Tick_to_ms
	extern	ushort	timer_system_tick;		/* timer tick value in number of system tick */
#	define	Tick_to_ms(nb_ticks)	((nb_ticks) * timer_system_tick)
#	define	Ms_to_tick(nb_ms)		((nb_ms) / timer_system_tick)
#endif

/*---------------------------------------------------------------------------
 *		DTE_INT functions declarations
 *-------------------------------------------------------------------------*/
#ifndef Trace
#	define	Trace(byte)
#endif
#if DTE_ASSERT == ON
#	define	Dte_ch_disconnect(c)	Trace ('$'); Trace ('('); Trace (c); Trace (')'); dte_ch_disconnect ()
#else
#	define	Dte_ch_disconnect(c)	dte_ch_disconnect ()
#endif

#if NEW_FCT_STYLE == ON
	void 			dl_control				(code_t);
	uchar 			dl_extra_parm			(void);
	uchar			dl_information			(code_t);
#	if DTE_FAX == ON
		uchar 		dl_getparm				(uchar rq_co);
		uchar 		dl_setparm				(uchar rq_co);
#	endif
	uchar			dl_set_per_c			(uchar);
	uchar 			dl_signal 				(void);
	void			dl_try_enter_fax_reception (void);
	void 			dte_acu 				(void);
	uchar			dte_acu_access_code		(uchar FAR *);
	event_id_t		dte_acu_event_id		(void);
	void 			dte_acu_in_co			(event_id_t);
	uchar			dte_and_v				(void);
#if DTE_AT_EXTERNAL == ON
		uchar        dte_at_ext_init			(uchar FAR *);
#endif
	uchar        	dte_at_process          (event_id_t, uchar FAR *);
	uchar        	dte_at_rcv              (void);
	void			dte_atz_end				(void);
	uchar 			dte_build_object		(void);
	uchar			dte_call_control		(event_id_t);
	uchar			dte_call_control_2		(event_id_t);
	uchar			dte_call_init	 		(void);
	void			dte_call_parameter	  	(event_id_t);
	uchar			dte_cf_control 			(event_id_t);
	uchar			dte_cf_disconnect 		(void);
	void			dte_cf_event_id 		(void);
	void 			dte_ch_acu_conn_co		(uchar, uchar);
	uchar 			dte_ch_and_q			(uchar, uchar, uchar);
	void 			dte_ch_break			(void);
	void 			dte_ch_da_rq			(void);
	uchar			dte_ch_disconnect 		(void);
	uchar			dte_ch_display_allowed	(void);
	void 			dte_ch_get_dte_channel	(void);
	void 			dte_ch_get_service 		(void);
	uchar 			dte_ch_get_s112	 		(void);
	uchar 			dte_ch_get_s113	 		(void);
	uchar 			dte_ch_get_s115	 		(void);
	uchar 			dte_ch_get_s116	 		(void);
	uchar 			dte_ch_get_s117	 		(void);
	uchar 			dte_ch_get_s118	 		(void);
#	if DTE_EXT_CALLING_PARTY == ON
		uchar 		dte_ch_get_s119	 		(void);
#	endif
#	if DTE_EXT_CALLED_PARTY == ON
		uchar 		dte_ch_get_s120	 		(void);
#	endif
#	if DTE_ISDN_CC == ON
		uchar 		dte_ch_get_s131	 		(void);
#	endif
	uchar 			dte_ch_get_s161	 		(void);
	uchar			dte_ch_init	 			(uchar);
	uchar 			dte_ch_ini_and_c		(uchar);
	uchar 			dte_ch_ini_and_d		(uchar);
	uchar 			dte_ch_ini_and_q		(uchar);
	uchar 			dte_ch_ini_and_s		(uchar);
	uchar 			dte_ch_ini_s113			(uchar);
#	if DTE_PPP == ON
		uchar 		dte_ch_ppp_init			(uchar first, uchar FAR * FAR * p_p_ppp_ctxt);
#	endif
	void 			dte_ch_report_connect	(uchar, uchar, uchar, uchar, uchar);
	void			dte_ch_report_disconnect(void);
#	if DTE_NO_S122_254 == OFF
		void		dte_ch_restore 			(void);
		void		dte_ch_save	 			(void);
#	endif
	uchar 			dte_ch_set_dte_channel	(nai_t, uchar, uchar, uchar);
	uchar 			dte_ch_set_pad_par_23	(uchar);
	uchar 			dte_ch_set_service 		(uchar);
	uchar 			dte_ch_set_s000			(uchar);
	uchar 			dte_ch_set_s007			(uchar);
	uchar 			dte_ch_set_s25			(uchar);
	uchar 			dte_ch_set_s26			(uchar);
	uchar 			dte_ch_set_s112			(uchar);
	uchar 			dte_ch_set_s113			(uchar, uchar);
	uchar 			dte_ch_set_s115			(uchar);
	uchar 			dte_ch_set_s116			(uchar);
	uchar 			dte_ch_set_s117			(uchar);
	uchar 			dte_ch_set_s118			(uchar);
#	if DTE_EXT_CALLING_PARTY == ON
		uchar 		dte_ch_set_s119	 		(uchar);
#	endif
#	if DTE_EXT_CALLED_PARTY == ON
		uchar 		dte_ch_set_s120	 		(uchar);
#	endif
#	if DTE_ISDN_CC == ON
		uchar 		dte_ch_set_s131	 		(uchar);
#	endif
	uchar 			dte_ch_set_s161	 		(uchar);
	uchar 			dte_ch_set_t_p			(uchar);
	uchar 			dte_ch_set_w			(uchar);
	uchar 			dte_ch_set_x			(uchar);
#	if DTE_SIMPLE_CHANNEL_ADDRESSING == ON
		uchar 		dte_check_inc_called_party (ent_id_t);
#	endif
	uchar			dte_check_inc_service	(uchar);
	uchar			dte_check_inc_ressources(void);
	uchar			dte_conn_init	 		(uchar);
	void			dte_data_fax_in	 		(struct buffer FAR *);
	uchar			dte_data_in		 		(void);
	uchar			dte_data_rq		 		(void);
	void 			dte_echo				(code_t code, short data_size);
	void 			dte_error				(void);
	ushort			dte_gstn_event 			(void);
	uchar			dte_gstn_process		(event_id_t);
	uchar 			dte_init				(void);
	dte_service_t	dte_int_service 		(uchar);
	uchar			dte_jn					(void);
	uchar 			dte_jn_init				(uchar);
	uchar 			dte_jn_get_s095	 		(void);
	uchar 			dte_jn_get_s121	 		(void);
	uchar 			dte_jn_get_s122	 		(void);
	uchar 			dte_jn_get_s123	 		(void);
#	if DTE_NO_S122_254 == OFF
		void 		dte_jn_restore			(void);
		void 		dte_jn_save				(void);
#	endif
	uchar 			dte_jn_set_s2	 		(uchar);
	uchar 			dte_jn_set_s3	 		(uchar);
	uchar 			dte_jn_set_s4	 		(uchar);
	uchar 			dte_jn_set_s5	 		(uchar);
	uchar 			dte_jn_set_s012	 		(uchar);
	uchar 			dte_jn_set_s095			(uchar);
	uchar 			dte_jn_set_s121	 		(uchar);
	uchar 			dte_jn_set_s122	 		(uchar);
	uchar 			dte_jn_set_s123	 		(uchar);
	uchar 			dte_jn_set_s124	 		(uchar);
	uchar        	dte_message_filter      (void);
	uchar			dte_net_init	 		(void);
	uchar			dte_out_service_init	(void);
	uchar 			dte_pad_acu_message_filter (void);
	event_id_t 		dte_pad_event_id 		(void);
	void			dte_pad_get_parms		(void);
	void			dte_pad_get_prof_parm	(char FAR *, uchar);
	uchar			dte_pad_resume_pad		(uchar jn_id);
	void 			dte_pad_set_line_state	(nai_t, add_t, uchar);
	void			dte_padstart_pad		(void);
	void			dte_padstop_no_call		(void);
	uchar			dte_padstop_rq			(uchar cause);
	uchar			dte_pad_suspend_pad		(uchar jn_id);
	uchar 			dte_pad_unit_rcv		(void);
	uchar			dte_padstop_requested	(void);
	void			dte_pad_upd_21 			(void);
	void			dte_pad_vc_establish_rq	(void);
	uchar 			dte_pad_x25_message_filter (void);
	uchar	 		dte_ph_r_access_code	(void);
	ushort			dte_ph_r_event 			(void);
	uchar        	dte_rcv                 (void);
#   if DTE_RESET_CONFIG == ON
		uchar    	dte_reset_config        (void);
#   endif
	uchar 			dte_sec_check_conn_in	(struct message FAR *);
	uchar 			dte_sec_init			(uchar FAR *);
	uchar        	dte_set_config          (void);
#	if DTE_SM_REPORT == ON
		uchar		dte_sm					(void);
		void 		dte_sm_report_in		(void);
#	endif
	void 			dte_snd_acu_cc			(void);
	void 			dte_snd_acu_signalling	(void);
	void 			dte_snd_cf				(void);
	void 			dte_snd_dte_cp			(void);
	void 			dte_snd_dte_jn			(code_t code);
	void 			dte_snd_fax_gstn		(void);
	void 			dte_snd_mgt_acu			(void);
	void 			dte_snd_mi				(struct message FAR *p_msg, code_t code);
	void			dte_snd_msg 			(ent_id_t);
	void 			dte_snd_ph_b			(void);
	void 			dte_snd_sm				(void);
	void 			dte_snd_sts				(void);
	uchar 			dte_sts_event			(void);
	uchar 			dte_sts_start			(void);
	uchar 			dte_to_acu_service 		(void);
	uchar 			dte_to_cf_service 		(void);

#	if (((DTE_ASSERT == ON) || (ASSERT == ON)) && (DTE_ASSERT_NO_STRING == OFF))
		void		dte_trap 				(ushort, char *);
#	else
		void		dte_trap 				(ushort);
#	endif

	uchar        	dte_unexp               (void);
	void			tr29_product			(void);

	uchar			dte_ext_call			(void);
	uchar FAR 	   *prepare_sending_message	(ushort, struct message FAR *);

#	if ((DTE_ISDN_CC == ON) && (DTE_SPF_FACILITY == ON))
		void 		dte_fac_clear			(void);
		void 		dte_fac_co 				(void);
		void 		dte_uui_in				(void);
#	endif

	void 			dte_info_in				(void);

#	if DTE_SUSPEND_FACILITY == ON
		void 		dte_resume_co			(void);
		void 		dte_suspend_co			(void);
#	endif

#	if DTE_INTERNAL == ON
		short 		dte_fmt_dump_buffer 	(struct buffer FAR *, short,
											 uchar FAR *,
											 uchar FAR *, ulong);
		void		dte_internal			(void);
#	endif

#	if DTE_LOG == ON
		void		dte_log_process				(void);
#	endif

#	if DTE_X25 == ON
		uchar 		dte_at_x25_message_filter	(void);
		uchar	 	dte_mx25_access_code		(void);
		uchar	 	dte_x25_access_code			(void);
		void		dte_x25_disconnect			(void);
		uchar 		dte_x25_packet_num_to_pow 	(int);
		void		dte_x25_process				(event_id_t);
#	endif

#	if DTE_PAD_V120_COMPRESSION == ON
		uchar		dte_dcc_event 			(uchar);
		uchar		dte_dcc_init 			(uchar);
		uchar		dte_dcc_is_active		(void);
#	endif
#	if DTE_V120 == ON
		void 		dte_v120_da_rq			(void);
		uchar 		dte_v120_disconnect		(void);
		uchar 		dte_v120_init			(uchar);
		uchar 		dte_v120_is_active		(void);
		void 		dte_v120_set_line_state	(nai_t, add_t, uchar);
		uchar 		dte_v120_process 		(ushort, uchar FAR *, ushort);
		uchar 		dte_v120_sm_access_code	(void);
		uchar 		dte_v120_start_v120		(void);
#	endif

#	if ((DTE_PH_V110 == ON) || (DTE_ASYN_TO_PH == ON) || (DTE_SWITCH == ON))
		uchar	 	dte_ph_access_code		(void);
		event_id_t 	dte_ph_event_id 		(void);
#	endif
#	if ((DTE_PH_V110 == ON) || (DTE_ASYN_TO_PH == ON))
		uchar	 	dte_ph_process	 		(event_id_t);
#	endif

#	if DTE_ASYN_TO_PH == ON
		void	 	dte_ph_clear_co	 		(void);
		void	 	dte_ph_conn_co	 		(void);
		void	 	dte_ph_busy_rq	 		(uchar on_off);
		void	 	dte_ph_da_rq	 		(void);
#	endif

#	if ((DTE_USE_CP == ON) && (DTE_PH_V110 == ON))
		void		dte_ph_filter	 		(void);
#	endif

#	if DTE_SWITCH == ON
		uchar		dte_switch				(void);
#	endif

#else

	void 			dl_control				();
	uchar 			dl_extra_parm			();
	uchar			dl_information			();
#	if DTE_FAX == ON
		uchar 		dl_getparm				();
		uchar 		dl_setparm				();
#	endif
	uchar			dl_set_per_c			();
	uchar 			dl_signal 				();
	void			dl_try_enter_fax_reception ();
	void 			dte_acu 				();
	uchar			dte_acu_access_code		();
	event_id_t		dte_acu_event_id		();
	void 			dte_acu_in_co			();
	uchar			dte_and_v				();
#if DTE_AT_EXTERNAL == ON
		uchar        dte_at_ext_init		();
#endif
	uchar        	dte_at_process          ();
	uchar        	dte_at_rcv              ();
	void			dte_atz_end				();
	uchar 			dte_build_object		();
	uchar			dte_call_control		();
	uchar			dte_call_control_2		();
	uchar			dte_call_init	 		();
	void			dte_call_parameter	  	();
	uchar			dte_cf_control 			();
	uchar			dte_cf_disconnect 		();
	void			dte_cf_event_id 		();
	void 			dte_ch_acu_conn_co		();
	uchar			dte_ch_and_q			();
	void 			dte_ch_break			();
	void 			dte_ch_da_rq			();
	uchar			dte_ch_disconnect 		();
	uchar			dte_ch_display_allowed	();
	void 			dte_ch_get_dte_channel	();
	void 			dte_ch_get_service 		();
	uchar 			dte_ch_get_s112	 		();
	uchar 			dte_ch_get_s113	 		();
	uchar 			dte_ch_get_s115	 		();
	uchar 			dte_ch_get_s116	 		();
	uchar 			dte_ch_get_s117	 		();
	uchar 			dte_ch_get_s118	 		();
#	if DTE_EXT_CALLING_PARTY == ON
		uchar 		dte_ch_get_s119	 		();
#	endif
#	if DTE_EXT_CALLED_PARTY == ON
		uchar 		dte_ch_get_s120	 		();
#	endif
#	if DTE_ISDN_CC == ON
		uchar 		dte_ch_get_s131	 		();
#	endif
	uchar 			dte_ch_get_s161	 		();
	uchar			dte_ch_init	 			();
	uchar 			dte_ch_ini_and_c		();
	uchar			dte_ch_ini_and_d		();
	uchar			dte_ch_ini_and_q		();
	uchar 			dte_ch_ini_and_s		();
	uchar 			dte_ch_ini_s113			();
#	if DTE_PPP == ON
		uchar 		dte_ch_ppp_init			();
#	endif
	void 			dte_ch_report_connect	();
	void			dte_ch_report_disconnect();
#if DTE_NO_S122_254 == OFF
		void		dte_ch_restore 			();
		void		dte_ch_save	 			();
#endif
	uchar 			dte_ch_set_dte_channel	();
	uchar 			dte_ch_set_pad_par_23	();
	uchar 			dte_ch_set_service 		();
	uchar			dte_ch_set_s000			();
	uchar			dte_ch_set_s007			();
	uchar 			dte_ch_set_s25			();
	uchar 			dte_ch_set_s26			();
	uchar 			dte_ch_set_s112			();
	uchar 			dte_ch_set_s113			();
	uchar 			dte_ch_set_s115			();
	uchar 			dte_ch_set_s116			();
	uchar 			dte_ch_set_s117			();
	uchar 			dte_ch_set_s118			();
#	if DTE_EXT_CALLING_PARTY == ON
		uchar 		dte_ch_set_s119	 		();
#	endif
#	if DTE_EXT_CALLED_PARTY == ON
		uchar 		dte_ch_set_s120	 		();
#	endif
#	if DTE_ISDN_CC == ON
		uchar 		dte_ch_set_s131	 		();
#	endif
	uchar 			dte_ch_set_s161	 		();
	uchar 			dte_ch_set_t_p			();
	uchar 			dte_ch_set_w			();
	uchar 			dte_ch_set_x			();
#	if DTE_SIMPLE_CHANNEL_ADDRESSING == ON
		uchar 		dte_check_inc_called_party ();
#	endif
	uchar			dte_check_inc_service	();
	uchar			dte_check_inc_ressources();
	uchar			dte_conn_init		 	();
	void			dte_data_fax_in	 		();
	uchar			dte_data_in		 		();
	uchar			dte_data_rq		 		();
	void 			dte_echo				();
	void 			dte_error				();
	ushort			dte_gstn_event 			();
	uchar			dte_gstn_process		();
	uchar 			dte_init				();
	dte_service_t	dte_int_service 		();
	uchar 			dte_jn					();
	uchar 			dte_jn_init				();
	uchar 			dte_jn_get_s095	 		();
	uchar 			dte_jn_get_s121	 		();
	uchar 			dte_jn_get_s122	 		();
	uchar 			dte_jn_get_s123	 		();
#	if DTE_NO_S122_254 == OFF
		void 		dte_jn_restore			();
		void 		dte_jn_save				();
#	endif
	uchar 			dte_jn_set_s2	 		();
	uchar 			dte_jn_set_s3	 		();
	uchar 			dte_jn_set_s4	 		();
	uchar 			dte_jn_set_s5	 		();
	uchar 			dte_jn_set_s012	 		();
	uchar 			dte_jn_set_s095			();
	uchar 			dte_jn_set_s121	 		();
	uchar 			dte_jn_set_s122	 		();
	uchar 			dte_jn_set_s123	 		();
	uchar 			dte_jn_set_s124	 		();
	uchar        	dte_message_filter      ();
	uchar			dte_net_init	 		();
	uchar			dte_out_service_init	();
	uchar 			dte_pad_acu_message_filter ();
	event_id_t 		dte_pad_event_id 		();
	void			dte_pad_get_parms		();
	void			dte_pad_get_prof_parm	();
	uchar			dte_pad_resume_pad		();
	void 			dte_pad_set_line_state	();
	void			dte_padstart_pad		();
	void			dte_padstop_no_call		();
	uchar			dte_padstop_rq			();
	uchar			dte_pad_suspend_pad		();
	uchar 			dte_pad_unit_rcv		();
	uchar			dte_padstop_requested	();
	void			dte_pad_upd_21 			();
	void			dte_pad_vc_establish_rq	();
	uchar 			dte_pad_x25_message_filter ();
	ushort			dte_ph_r_event 			();
	uchar        	dte_rcv                 ();
#   if DTE_RESET_CONFIG == ON
		uchar    	dte_reset_config        ();
#	endif
	uchar 			dte_sec_check_conn_in	();
	uchar 			dte_sec_init			();
	uchar        	dte_set_config          ();
#	if DTE_SM_REPORT == ON
		uchar 		dte_sm					();
		void 		dte_sm_report_in		();
#	endif
	void 			dte_snd_acu_cc			();
	void 			dte_snd_acu_signalling	();
	void 			dte_snd_cf				();
	void 			dte_snd_dte_cp			();
	void 			dte_snd_dte_jn			();
	void 			dte_snd_fax_gstn		();
	void 			dte_snd_mgt_acu			();
	void 			dte_snd_mi				();
	void			dte_snd_msg 			();
	void 			dte_snd_ph_b			();
	void 			dte_snd_sm				();
	void 			dte_snd_sts				();
	uchar 			dte_sts_event			();
	uchar 			dte_sts_start			();
	uchar 			dte_to_acu_service 		();
	uchar 			dte_to_cf_service 		();
	void			dte_trap 				();
	uchar        	dte_unexp               ();
	void			tr29_product			();

	uchar			dte_ext_call			();

#if DTE_SUSPEND_FACILITY == ON
	void 			dte_resume_co			();
	void 			dte_suspend_co			();
#endif
	uchar FAR 	   *prepare_sending_message	();

#	if ((DTE_ISDN_CC == ON) && (DTE_SPF_FACILITY == ON))
	void 			dte_fac_clear			();
	void 			dte_fac_co 				();
	void 			dte_uui_in				();
#	endif

	void 			dte_info_in				();

#if DTE_SUSPEND_FACILITY == ON
	void 			dte_resume_co			();
	void 			dte_suspend_co			();
#endif

#	if DTE_INTERNAL == ON
	short 			dte_fmt_dump_buffer		();
	void			dte_internal			();
#	endif

#	if DTE_LOG == ON
		void		dte_log_process				();
#	endif

#	if DTE_X25 == ON
		uchar 		dte_at_x25_message_filter	();
		uchar		dte_mx25_access_code		();
		uchar		dte_x25_access_code			();
		void		dte_x25_disconnect			();
		uchar 		dte_x25_packet_num_to_pow 	();
		void		dte_x25_process				();
#	endif

#	if DTE_PAD_V120_COMPRESSION == ON
		uchar		dte_dcc_event 				();
		uchar		dte_dcc_init 				();
		uchar		dte_dcc_is_active			();
#	endif

#	if DTE_V120 == ON
		void 		dte_v120_da_rq				();
		uchar 		dte_v120_disconnect			();
		uchar 		dte_v120_init				();
		uchar 		dte_v120_is_active			();
		void 		dte_v120_set_line_state		();
		uchar 		dte_v120_process 			();
		uchar 		dte_v120_sm_access_code		();
		uchar 		dte_v120_start_v120			();
#	endif

#	if ((DTE_PH_V110 == ON) || (DTE_ASYN_TO_PH == ON) || (DTE_SWITCH == ON))
		uchar	 	dte_ph_access_code			();
		event_id_t 	dte_ph_event_id 			();
#	endif
#	if ((DTE_PH_V110 == ON) || (DTE_ASYN_TO_PH == ON))
		uchar	 	dte_ph_process	 			();
#	endif

#	if DTE_ASYN_TO_PH == ON
		void	 	dte_ph_clear_co	 			();
		void	 	dte_ph_conn_co	 			();
		void	 	dte_ph_busy_rq	 			();
		void	 	dte_ph_da_rq	 			();
#	endif

#	if ((DTE_USE_CP == ON) && (DTE_PH_V110 == ON))
		void		dte_ph_filter	 			();
#	endif

#	if DTE_SWITCH == ON
		uchar		dte_switch					();
#	endif

#endif

extern	uchar CONST_ARRAY t_parity [];
extern	uchar			  dte_trap_if_call_clear;

#endif

/*EOF*/

