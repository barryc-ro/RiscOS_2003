
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - dte_ppp.c
 *
 * $Revision$
 *
 * $Date$
 *
 * functions
 *
 *	dte_ch_ppp_init 			- initialize DTE channel for PPP processing
 *	dte_ppp_alloc_buffer 		- allocate a buffer for a PPP frame
 *	dte_ppp_asyn_build_fcs_table- build PPP FCS table
 *
 *	dte_ppp_asyn_dec_abort 		- abort decoding of current frame
 *	dte_ppp_asyn_dec_init 		- initialize asynchronous PPP to frame
 *								  processing
 *	dte_ppp_asyn_dec_stop 		- terminate asynchronous PPP to frame
 *								  processing
 *	dte_ppp_asyn_dec_err_code 	- get last decode error code
 *	dte_ppp_asyn_decode 		- convert asynchronous PPP data to PPP block
 *	dte_ppp_asyn_enc_abort 		- abort encoding of current frame
 *	dte_ppp_asyn_enc_init 		- initialize frame to asynchronous PPP
 *								  processing
 *	dte_ppp_asyn_enc_stop 		- terminate frame to asynchronous PPP
 *								  processing
 *	dte_ppp_asyn_enc_err_code 	- get last encode error code
 *	dte_ppp_asyn_encode 		- convert PPP block to asynchronous PPP data
 *	dte_ppp_asyn_init	 		- initialize asynchronous PPP to frame
 *								  processing
 *	dte_ppp_link_init 			- initialize link description
 *	dte_ppp_sync_decode 		- convert synchronous PPP frame to PPP block
 *	dte_ppp_sync_encode 		- convert PPP block to synchronous PPP frame
 *	p3_fr_parse 				- parse a PPP frame
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    TR29-PACK                                        |*/
/*|    DTE_INT Entity                                   |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include 	"services.h"
#include 	"dte_par.h"        		/* simply to get compilation options */

#if DTE_PPP == ON
#	include 	"dte.h"
#	include 	"dte_ch.h"
#	include 	"dte_ppp.h"
#endif

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#if DTE_PPP == ON

#define	PPP_FCS_SIZE		2				/* PPP FCS size */
#define	PPP_POLYNOMIAL		0x8408			/* PPP FCS polynomial : x**0 + x**5 + x**12 + x**16 */

#define	PPP_FCS_INIT		0xFFFF			/* PPP FCS initial value */
#define	PPP_FCS_FINAL		0xF0B8			/* PPP FCS final value, when computed over all frame bytes, including received FCS */


/*---------------------------------------------------------------------------
 *			Decoding states
 *-------------------------------------------------------------------------*/
#define		DTE_PPP_DST_STOPPED				's'		/* stopped */
#define		DTE_PPP_DST_STARTED				'1'		/* started, waiting for first flag */
#define		DTE_PPP_DST_BETWEEN_FRAMES		'i'		/* idle, between frames */
#define		DTE_PPP_DST_IN_DATA				'd'		/* decoding regular data */
#define		DTE_PPP_DST_IN_ESCAPE			'e'		/* escape character detected */

/*---------------------------------------------------------------------------
 *			Encoding states
 *-------------------------------------------------------------------------*/
#define		DTE_PPP_EST_STOPPED				's'		/* stopped */
#define		DTE_PPP_EST_IDLE				'i'		/* idle */
#define		DTE_PPP_EST_GEN_DATA			'd'		/* generating regular data */
#define		DTE_PPP_EST_GEN_ESCAPE			'e'		/* generating an escape (0x7D has been sent) */
#define		DTE_PPP_EST_GEN_FCS_1			'1'		/* generating FCS, part 1 (first FCS byte has been sent) */
#define		DTE_PPP_EST_GEN_FCS_2			'2'		/* generating FCS, part 2 (second FCS byte has been sent) */

/*---------------------------------------------------------------------------
 *		Local functions declarations
 *--------------------------------------------------------------------------*/
#ifndef STATIC
#	define	STATIC
#endif

#if NEW_FCT_STYLE == ON
	STATIC	struct buffer FAR 	*dte_ppp_alloc_buffer	(struct ppp_link FAR *p_ppp_link);
	STATIC	void 				 dte_ppp_link_init 		(struct ppp_link FAR *p_ppp_link);
#else
	STATIC	struct buffer FAR 	*dte_ppp_alloc_buffer	();
	STATIC	void 				 dte_ppp_link_init 		();
#endif

/*---------------------------------------------------------------------------
 *		Local tables
 *--------------------------------------------------------------------------*/
/*
 *	0x11 (XON, DC1) is encoded as 0x02 in the third byte of the
 *					internal representation of the ACCM
 *	0x13 (XOFF, DC3) is encoded as 0x08 in the third byte
 */
uchar CONST_ARRAY ppp_accm_bit_tab [8] = {
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
};


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ch_ppp_init : initialize DTE channel for PPP processing

Usage           uchar dte_ch_ppp_init (uchar first,
									   uchar FAR * FAR *p_p_ppp_ctxt)
							first	: ON : if first configuration
							p_p_ppp_ctxt: address of a pointer where to
										  store the address of the context
Return value : 	OK or NOK

Description :	allocate ressources if necessary, initialize context

*--------------------------------------------------------------------------*/

uchar dte_ch_ppp_init (first, p_p_ppp_ctxt)
uchar			 	first;
uchar FAR *	FAR *	p_p_ppp_ctxt;
{
	if (p_p_ppp_ctxt == P_NIL) {
		return (NOK);
	}

#	if DTE_RESET_CONFIG == ON
		if (first == ON) {
#	endif
			if ((Ch_disable	== OFF) &&
				((Ch_lock_service == OFF) ||
				 (Ch_service == DTE_ASYN_TO_PH_SERVICE))) {
				/*
				 *	PPP service may be used : allocate ressources
				 */
				if ((*p_p_ppp_ctxt = Mem_alloc (Ppp_ctxt_size, PID_VL)) ==
					 P_NIL) {
					return (NOK);
				}
			}
			else {
				*p_p_ppp_ctxt = P_NIL;
			}

#	if DTE_RESET_CONFIG == ON
		} else {					/* after a RESET_CONFIG */
			if ((Ch_disable	== OFF) &&
				((Ch_lock_service == OFF) ||
				 (Ch_service == DTE_ASYN_TO_PH_SERVICE))) {
				/*
				 *	PPP service may be used : allocate ressources if
				 *	not already done.
				 */
				if (*p_p_ppp_ctxt == P_NIL) {
					if ((*p_p_ppp_ctxt = Mem_alloc (Ppp_ctxt_size, PID_VL)) ==
						 P_NIL) {
						return (NOK);
					}

				} /* else ressources already allocated */
			}
			else {
				/*
				 *	PPP service will not be used : free ressources
				 *	if ressources have been allocated previously.
				 */
				if (*p_p_ppp_ctxt != P_NIL) {
					Mem_free ((char FAR *)*p_p_ppp_ctxt, PID_VL);
					*p_p_ppp_ctxt	= P_NIL;
				}
			}
		}
#	endif

	return (OK);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_alloc_buffer : allocate a buffer for a PPP frame

Usage           struct buffer FAR *dte_ppp_alloc_buffer (
							struct ppp_link FAR 		*p_ppp_link)

						- p_ppp_link : address of the link context

Return value : 	address of the allocated buffer or P_NIL

Description :	allocate a buffer for a PPP frame, initialize header

*--------------------------------------------------------------------------*/

struct buffer FAR *dte_ppp_alloc_buffer (p_ppp_link)
struct ppp_link FAR 		*p_ppp_link;
{
	struct buffer FAR	*p_buffer;

	p_buffer = Alloc_buffer ();
	if (p_buffer != P_NIL) {
		Buffer_data_offset  += Link_cur_hole_size_to;
	}
	return (p_buffer);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_build_fcs_table : build PPP FCS table

Usage           void dte_ppp_asyn_build_fcs_table (ushort fcs_tab [256]);
						- fcs_tab : address of the table to build.
									The table contains 256 ushorts.
									Updated upon exit.
Return value : 	none

Description :	build PPP FCS table
				The code is borrowed from RFC 1331.
				Drew D. Perkins at Carnegie Mellon University.
				Borrowed from Mohsen Banan and D. Hugh Redelmeier.

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_build_fcs_table (fcs_tab)
ushort		fcs_tab [256];
{
	uchar 		i;
	ushort 		b;
	ushort		v;

	for (b = 0 ; b < 256; ++b) {
		for (v = b, i = 8; i--; ) {
			v	= (v & 1) ? ((v >> 1) ^ PPP_POLYNOMIAL) : (v >> 1);
		}
		fcs_tab [b] = v & 0xFFFF;
	}
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_dec_abort : abort decoding of current frame

Usage           void dte_ppp_asyn_dec_abort (struct dte_ppp_asyn_ctxt *p_ppp_asyn);

Return value : 	none

Description :	Abort decoding of current frame

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_dec_abort (p_ppp_asyn)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
{
	if (p_ppp_asyn == P_NIL) {
		return;
	}
	switch (Ppp_a_dec_state) {
	default:							/* Error */
	case DTE_PPP_DST_STOPPED:			/* Stopped */
		break;
	case DTE_PPP_DST_STARTED:			/* Started */
		break;
	case DTE_PPP_DST_BETWEEN_FRAMES:	/* Idle, between frames */
	case DTE_PPP_DST_IN_DATA:			/* Decoding regular data */
	case DTE_PPP_DST_IN_ESCAPE:			/* Escape character detected */
		Ppp_a_dec_state		= DTE_PPP_DST_BETWEEN_FRAMES;
		Ppp_a_dec_err_code	= DTE_PPP_ERR_FRAME_ABORTED;
		break;
	}
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_dec_init : initialize asynchronous PPP to
										frame processing

Usage           void dte_ppp_asyn_dec_init (
							struct dte_ppp_asyn_ctxt *p_ppp_asyn,
							uchar					  check_fcs,
							ushort FAR				 *p_fcs_tab)
						- p_ppp_asyn : address of the decoding context
									   To be stored by the caller.
						- check_fcs	: ON: check received FCS. OFF: do not check.
						- p_fcs_tab	: address of the FCS table.
Return value : 	none

Description :	Initialize asynchronous PPP to frame processing.

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_dec_init (p_ppp_asyn, check_fcs, p_fcs_tab)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
uchar						 check_fcs;
ushort FAR					*p_fcs_tab;
{
	if (p_ppp_asyn == P_NIL) {
		return;
	}
	if (p_fcs_tab == P_NIL) {
		check_fcs	= OFF;
	}
	Ppp_a_dec_state			= DTE_PPP_DST_STARTED;
	Ppp_a_dec_check_fcs		= check_fcs;
	Ppp_a_dec_fcs_tab		= p_fcs_tab;
	Ppp_a_dec_err_code		= 0;
	Ppp_a_dec_computed_fcs	= 0;
	Ppp_a_dec_received_fcs	= 0;

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_dec_stop : terminate asynchronous PPP to frame
										processing

Usage           void dte_ppp_asyn_dec_stop (struct dte_ppp_asyn_ctxt *p_ppp_asyn)
						- p_ppp_asyn : address of the decoding context

Return value : 	none

Description :	Terminate asynchronous PPP to frame processing

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_dec_stop (p_ppp_asyn)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
{
	if (p_ppp_asyn == P_NIL) {
		return;
	}
	Ppp_a_dec_state	= DTE_PPP_DST_STOPPED;
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_dec_err_code : get last decode error code

Usage           uchar dte_ppp_asyn_dec_err_code (struct dte_ppp_asyn_ctxt *p_ppp_asyn)
						- p_ppp_asyn : address of the decoding context

Return value : 	last decoding error. 0: no error.

Description :	Get last decode error code

*--------------------------------------------------------------------------*/

uchar dte_ppp_asyn_dec_err_code (p_ppp_asyn)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
{
	if (p_ppp_asyn == P_NIL) {
		return (DTE_PPP_ERR_NO_CONTEXT);
	}

	switch (Ppp_a_dec_state) {
	default:	/* Invalid state, context was probably not initialized */
		return (DTE_PPP_ERR_INV_STATE);

	case DTE_PPP_DST_STOPPED:
	case DTE_PPP_DST_STARTED:
	case DTE_PPP_DST_BETWEEN_FRAMES:
	case DTE_PPP_DST_IN_DATA:
	case DTE_PPP_DST_IN_ESCAPE:
		break;
	}

	return (Ppp_a_dec_err_code);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_decode : convert asynchronous PPP data to PPP block

Usage           uchar dte_ppp_asyn_decode (
							struct dte_ppp_asyn_ctxt 	*p_ppp_asyn,
							struct buffer FAR 			*p_in_asyn_buf,
							struct buffer FAR 			*p_out_frm_buf)

						- p_ppp_asyn : address of the decoding context
						- p_in_asyn_buf : address of the input buffer,
								contains asynchronous data.
								On exit, data_offset/data_size are updated.
						- p_out_frm_buf : address of the output buffer,
								contains 'frame' data.
								On exit, data_offset/data_size are updated.

Return value : 	decoding process result code :
				NOK: an error occurred.
					Output buffer has to be discarded.
					Input buffer can be reused.
				STOP: a complete, correct frame has been generated.
					Input buffer may or may not be empty.
					Output buffer contains the complete frame.
				CONTINUE: a complete frame could not be built.
					Input buffer is empty.
					Output buffer contains a partial frame, and has to
					be supplied again upon next routine activation.

Description :	Convert asynchronous PPP data to frame

*--------------------------------------------------------------------------*/

uchar dte_ppp_asyn_decode (p_ppp_asyn, p_in_asyn_buf, p_out_frm_buf)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
struct buffer FAR 			*p_in_asyn_buf;
struct buffer FAR 			*p_out_frm_buf;
{
	uchar FAR				*p_in;
	short					 in_size;
	short					 in_0_size;
	uchar FAR				*p_out;
	short					 out_rem_size;
	short					 out_0_rem_size;
	uchar					 c;
	uchar					 state;
	uchar					 eat_flags;
	uchar					 discard_output_frame;
	uchar					 valid_frame_detected;
	short					 length;
	uchar					 ret_code;
	struct buffer FAR		*p_buffer;
	struct ppp_link FAR		*p_ppp_link;		/* address of the current link context */

	if (p_ppp_asyn == P_NIL) {
		return (NOK);
	}

	p_buffer	= p_in_asyn_buf;
	if (p_buffer == P_NIL) {
		return (CONTINUE);
	}
	p_in		= Buffer_a_start_data;
	in_size		= Buffer_data_size;
	in_0_size	= in_size;

	p_buffer	= p_out_frm_buf;
	if (p_buffer == P_NIL) {
		return (STOP);
	}
	p_out			= Buffer_a_end_data;
	out_rem_size	= Buffer_data_lgth - Buffer_data_offset - Buffer_data_size;
	out_0_rem_size	= out_rem_size;

	state					= Ppp_a_dec_state;
	eat_flags				= OFF;
	discard_output_frame	= OFF;
	valid_frame_detected	= OFF;

	p_ppp_link	= Ppp_a_link_1;

	while ((in_size > 0) && (out_rem_size > 0)) {
		c = *p_in++; --in_size;
		if (state == DTE_PPP_DST_IN_DATA) {
			if (c == P3_FLAG_CHAR) {				/* End of frame detected */
												/*-----------------------*/
				state					= DTE_PPP_DST_BETWEEN_FRAMES;
				eat_flags				= ON;
				valid_frame_detected	= ON;
				break;									/* EXIT loop */
			}
			else if (c == P3_CONTROL_ESCAPE_CHAR) {
				state					= DTE_PPP_DST_IN_ESCAPE;
			}
			else if (Is_in_accm_from (c)) {
				/*
				 *	A control character has been inserted : suppress it
				 */
				;
			}
			else {
				*p_out++ = c;
				--out_rem_size;
			}
		}

		else if (state == DTE_PPP_DST_IN_ESCAPE) {
			if (c == P3_FLAG_CHAR) {				/* Invalid frame detected */
												/*------------------------*/
				state					= DTE_PPP_DST_BETWEEN_FRAMES;
				discard_output_frame	= ON;
				eat_flags				= ON;
				break;									/* EXIT loop */
			}
			else if (Is_in_accm_from (c)) {
				/*
				 *	A control character has been inserted : suppress it
				 */
				;
			}
			else {
				state					= DTE_PPP_DST_IN_DATA;
				*p_out++ = c ^ P3_XOR_BIT;
				 --out_rem_size;
			}
		}

		else if (state == DTE_PPP_DST_BETWEEN_FRAMES) {
			if (c == P3_FLAG_CHAR) {

				/* Optimization : try to eat more flags */

				while ((in_size > 0) && (*p_in == P3_FLAG_CHAR)) {
					++p_in; --in_size;
				}
			}
			else if (c == P3_CONTROL_ESCAPE_CHAR) {
				state	= DTE_PPP_DST_IN_ESCAPE;
			}
			else if (Is_in_accm_from (c)) {
				/*
				 *	A control character has been inserted : suppress it
				 */
				;
			}
			else {
				state 	= DTE_PPP_DST_IN_DATA;
				*p_out++ = c; --out_rem_size;
			}
		}

		else if (state == DTE_PPP_DST_STARTED) {

			/* We are waiting for an initial flag */
			/*------------------------------------*/
			if (c != P3_FLAG_CHAR) {	/* Eat all non-flags */
				while ((in_size > 0) && (*p_in != P3_FLAG_CHAR)) {
					++p_in; --in_size;
				}
				c	= *p_in;
			}
			if (c == P3_FLAG_CHAR) {	/* Eat one or more flags */
				state 	= DTE_PPP_DST_BETWEEN_FRAMES;
				while ((in_size > 0) && (*p_in == P3_FLAG_CHAR)) {
					++p_in; --in_size;
				}
			}
		}

		else if (state == DTE_PPP_DST_STOPPED) {
			Ppp_a_dec_err_code	= DTE_PPP_ERR_STOPPED;
			return (NOK);
		}

		else {
			/* No access to dec_err_code, context pointer may be incorrect */
			return (NOK);
		} /* end ifs */

	} /* end while */

	/* Save internal state */
	/*---------------------*/
	Ppp_a_dec_state	= state;

	/* Post_processing, input buffer */
	/*-------------------------------*/
	/* Eat supplementary flags */
	if (eat_flags == ON) {
		while ((in_size > 0) && (*p_in == P3_FLAG_CHAR)) {
			++p_in; --in_size;
		}
	}

	/* Update input buffer coordinates */

	p_buffer			= p_in_asyn_buf;
	Buffer_data_size	= in_size;
	Buffer_data_offset += in_0_size - in_size;

	/* (End of input buffer processing) */

	ret_code	= OK;

	if ((valid_frame_detected == OFF) && (out_rem_size <= 0)) {
		Ppp_a_dec_err_code		= DTE_PPP_ERR_FRAME_TOO_SHORT;
		discard_output_frame	= ON;
		ret_code				= NOK;
	}

	if (valid_frame_detected == ON) {
		/*--------------------*/
		/* Check frame length */
		/*--------------------*/
		p_buffer	= p_out_frm_buf;
		length		= Buffer_data_size + out_0_rem_size - out_rem_size;
		if (length <= PPP_FCS_SIZE) {
			if (length < PPP_FCS_SIZE) {
				ret_code			= NOK;
				Ppp_a_dec_err_code	= DTE_PPP_ERR_FRAME_TOO_SHORT;
			}
			valid_frame_detected 	= OFF;
			discard_output_frame	= ON;
		}
	}

	if ((valid_frame_detected == ON) && (Ppp_a_dec_check_fcs == ON)) {
		ushort	fcs;
		ushort	received_fcs;

		/*-----------*/
		/* Check FCS */				/* Adapted from RFC 1331 */
		/*-----------*/
		for (p_out = Buffer_a_start_data, length -= PPP_FCS_SIZE,
			 fcs = PPP_FCS_INIT; length-- > 0; ) {

			/*
			 *	The following code is correct :
			 *
			 *		fcs	= (fcs >> 8) ^ Ppp_a_dec_fcs_tab [(fcs ^ *p_out++) & 0xFF];
			 *
			 *	However, some compilers are not able to generate correct
			 *	code for this expression (for example, Microtec 68K V4.1),
			 *	so let's be patient with them.
			 */
			uchar		a;

			a	= (fcs ^ *p_out++) & 0xFF;
			fcs	= (fcs >> 8) ^ Ppp_a_dec_fcs_tab [a];
		}

		received_fcs	= ((p_out [1] << 8) + p_out [0]) ^ 0xFFFF;

		Ppp_a_dec_computed_fcs	= fcs;
		Ppp_a_dec_received_fcs	= received_fcs;
		if (received_fcs != fcs) {
			ret_code				= NOK;
			Ppp_a_dec_err_code		= DTE_PPP_ERR_FCS_ERROR;
			valid_frame_detected	= OFF;
			discard_output_frame	= ON;
		}
	} /* end if */

	/* Update output buffer coordinates */

	p_buffer		= p_out_frm_buf;
	if (discard_output_frame == ON) {
		Buffer_data_size	= 0;
	}
	else {
		Buffer_data_size += out_0_rem_size - out_rem_size;
		if (valid_frame_detected == ON) {
			Buffer_data_size	-= PPP_FCS_SIZE;
		}
	}

	/* Return */

	if (ret_code == NOK) {
		return (NOK);
	}

	if (valid_frame_detected == ON) {
		return (STOP);
	}
	else {
		return (CONTINUE);
	}
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_enc_abort : abort encoding of current frame

Usage           void dte_ppp_asyn_enc_abort (struct dte_ppp_asyn_ctxt *p_ppp_asyn);
							struct dte_ppp_asyn_ctxt 	*p_ppp_asyn,
							struct buffer FAR 			*p_out_asyn_buf)

						- p_ppp_asyn : address of the encoding context
						- p_out_asyn_buf : address of the output buffer,
								contains asynchronous data.
								On exit, data_offset/data_size are updated.
								For good results, the buffer must be able to
								contain 2 bytes.
Return value : 	none

Description :	Abort encoding of current asynchronous PPP frame

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_enc_abort (p_ppp_asyn, p_out_asyn_buf)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
struct buffer FAR 			*p_out_asyn_buf;
{
	struct buffer FAR 		*p_buffer;
	uchar FAR				*p_out;
	short					 out_rem_size;

	if (p_ppp_asyn == P_NIL) {
		return;
	}

	switch (Ppp_a_enc_state) {
	default:
		/* No access to enc_err_code, context pointer may be incorrect */
		return;

	case DTE_PPP_EST_STOPPED:
		Ppp_a_enc_err_code	= DTE_PPP_ERR_STOPPED;
		return;
	case DTE_PPP_EST_IDLE:			/* idle */
		return;						/* do nothing */
	case DTE_PPP_EST_GEN_DATA:		/* generating regular data */
	case DTE_PPP_EST_GEN_ESCAPE:	/* generating an escape (0x7D has been sent) */
	case DTE_PPP_EST_GEN_FCS_1:		/* generating FCS, part 1 (first FCS byte has been sent) */
	case DTE_PPP_EST_GEN_FCS_2:		/* generating FCS, part 2 (second FCS byte has been sent) */
		break;
	}

	p_buffer		= p_out_asyn_buf;

	p_out			= Buffer_a_start_data;
	out_rem_size	= Buffer_data_lgth - Buffer_data_offset - Buffer_data_size;
	if (out_rem_size >= 2) {
		*p_out++	= P3_CONTROL_ESCAPE_CHAR;
		*p_out++	= P3_FLAG_CHAR;
		Buffer_data_size	+= 2;
	}
	else if (out_rem_size == 1) {	/* Put a flag, try to generate a FCS error */
		*p_out++	= P3_FLAG_CHAR;
		++Buffer_data_size;
	}

	Ppp_a_enc_state = DTE_PPP_EST_IDLE;
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_enc_init : initialize frame to asynchronous PPP
										processing

Usage           void dte_ppp_asyn_enc_init (
							struct dte_ppp_asyn_ctxt *p_ppp_asyn,
							ushort FAR				 *p_fcs_tab)
						- p_ppp_asyn : address of the encoding context
									   To be stored by the caller.
						- p_fcs_tab	: address of the FCS table.
Return value : 	none

Description :	Initialize frame to asynchronous PPP processing.

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_enc_init (p_ppp_asyn, p_fcs_tab)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
ushort FAR					*p_fcs_tab;
{
	if (p_ppp_asyn == P_NIL) {
		return;
	}
	Ppp_a_enc_fcs_tab		= p_fcs_tab;
	Ppp_a_enc_state			= DTE_PPP_EST_IDLE;
	Ppp_a_enc_err_code		= 0;
	Ppp_a_enc_computed_fcs	= 0;
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_enc_stop : terminate frame to asynchronous PPP
										processing

Usage           void dte_ppp_asyn_enc_stop (struct dte_ppp_asyn_ctxt *p_ppp_asyn)
						- p_ppp_asyn : address of the encoding context

Return value : 	none

Description :	Terminate frame to asynchronous PPP processing

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_enc_stop (p_ppp_asyn)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
{
	if (p_ppp_asyn == P_NIL) {
		return;
	}
	Ppp_a_enc_state			= DTE_PPP_EST_STOPPED;
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_enc_err_code : get last encode error code

Usage           uchar dte_ppp_asyn_enc_err_code (struct dte_ppp_asyn_ctxt *p_ppp_asyn)
						- p_ppp_asyn : address of the encoding context

Return value : 	last encoding error. 0: no error.

Description :	Get last encode error code

*--------------------------------------------------------------------------*/

uchar dte_ppp_asyn_enc_err_code (p_ppp_asyn)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
{
	if (p_ppp_asyn == P_NIL) {
		return (DTE_PPP_ERR_NO_CONTEXT);
	}

	switch (Ppp_a_enc_state) {

	default:	/* Invalid state, context was probably not initialized */
		return (DTE_PPP_ERR_INV_STATE);

	case DTE_PPP_EST_STOPPED:		/* stopped */
	case DTE_PPP_EST_IDLE:			/* idle */
	case DTE_PPP_EST_GEN_DATA:		/* generating regular data */
	case DTE_PPP_EST_GEN_ESCAPE:	/* generating an escape (0x7D has been sent) */
	case DTE_PPP_EST_GEN_FCS_1:		/* generating FCS, part 1 (first FCS byte has been sent) */
	case DTE_PPP_EST_GEN_FCS_2:		/* generating FCS, part 2 (second FCS byte has been sent) */
		break;
	}
	return (Ppp_a_enc_err_code);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_encode : convert PPP block to asynchronous PPP
									  data

Usage           uchar dte_ppp_asyn_encode (
							struct ppp_link FAR			*p_ppp_link,
							struct dte_ppp_asyn_ctxt FAR*p_ppp_asyn,
							struct buffer FAR 			*p_in_frm_buf,
							struct buffer FAR 			*p_out_asyn_buf)

						- p_ppp_link : address of the PPP link context
						- p_ppp_asyn : address of the decoding context
						- p_in_frm_buf : address of the input buffer,
								contains 'frame' data.
								On exit, data_offset/data_size are updated.
						- p_out_asyn_buf : address of the output buffer,
								contains asynchronous data.
								On exit, data_offset/data_size are updated.

Return value : 	encoding process result code :
				NOK: an error occurred.
					Output buffer has to be discarded.
					Input buffer has been completely analyzed.
				STOP: a complete, correct asynchronous PPP frame has been
					generated.
					Output buffer contains the final part of the
					asynchronous PPP frame.
					Input buffer has been completely analyzed.
				CONTINUE: a complete frame asynchronous PPP frame could not
					be built. Encoding is still in progress.
					Output buffer contains a partial asynchronous PPP frame
					data.
					Input buffer has to be supplied again on next routine
					call.

Description :	Convert asynchronous PPP data to frame

*--------------------------------------------------------------------------*/

uchar dte_ppp_asyn_encode (p_ppp_link, p_ppp_asyn, p_in_frm_buf, p_out_asyn_buf)
struct ppp_link			 	*p_ppp_link;
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
struct buffer FAR 			*p_in_frm_buf;
struct buffer FAR 			*p_out_asyn_buf;
{
	uchar FAR				*p_in;
	uchar FAR				*p_in_0;
	short					 in_size;
	short					 in_0_size;
	uchar FAR				*p_out;
	short					 out_rem_size;
	short					 out_0_rem_size;
	uchar					 c;
	uchar					 state;
	uchar					 compute_fcs;
	struct buffer FAR		*p_buffer;


	if (p_ppp_asyn == P_NIL) {
		return (NOK);
	}

	p_buffer	= p_in_frm_buf;
	if (p_buffer == P_NIL) {
		Ppp_a_enc_err_code	= DTE_PPP_ERR_NULL_INPUT;
		return (NOK);
	}
	p_in_0		= Buffer_a_start_data;
	in_0_size	= Buffer_data_size;

	p_buffer	= p_out_asyn_buf;
	if (p_buffer == P_NIL) {
		return (STOP);
	}
	p_out			= Buffer_a_start_data;
	out_0_rem_size	= Buffer_data_lgth - Buffer_data_offset - Buffer_data_size;


	compute_fcs	= OFF;
	switch (Ppp_a_enc_state) {
	default:
		/* No access to enc_err_code, context pointer may be incorrect */
		return (NOK);

	case DTE_PPP_EST_STOPPED:
		Ppp_a_enc_err_code	= DTE_PPP_ERR_STOPPED;
		return (NOK);

	case DTE_PPP_EST_IDLE:
		compute_fcs	= ON;
		break;

	case DTE_PPP_EST_GEN_DATA:		/* generating regular data */
	case DTE_PPP_EST_GEN_ESCAPE:	/* generating an escape (0x7D has been sent) */
	case DTE_PPP_EST_GEN_FCS_1:		/* generating FCS, part 1 (first FCS byte has been sent) */
	case DTE_PPP_EST_GEN_FCS_2:		/* generating FCS, part 2 (second FCS byte has been sent) */
		break;
	}

	if ((compute_fcs == ON) && (Ppp_a_enc_fcs_tab != P_NIL)) {
		ushort			fcs;

		/*-------------*/
		/* Compute FCS */				/* Adapted from RFC 1331 */
		/*-------------*/
		for (p_in = p_in_0, in_size = in_0_size, fcs = PPP_FCS_INIT; in_size-- > 0; ) {
			/*
			 *	The following code is correct :
			 *
			 *		fcs	= (fcs >> 8) ^ Ppp_a_enc_fcs_tab [(fcs ^ *p_in++) & 0xFF];
			 *
			 *	However, some compilers are not able to generate correct
			 *	code for this expression (for example, Microtec 68K V4.1),
			 *	so let's be patient with them.
			 */
			uchar		a;

			a	= (fcs ^ *p_in++) & 0xFF;
			fcs	= (fcs >> 8) ^ Ppp_a_enc_fcs_tab [a];
		} /* end for */
		Ppp_a_enc_computed_fcs	= fcs;
	} /* end if */

	/*--------------------------------------*/
	/* Generate asynchronous frame contents */
	/*--------------------------------------*/
	p_in			= p_in_0;
	in_size			= in_0_size;
	out_rem_size	= out_0_rem_size;
	state			= Ppp_a_enc_state;
	while ((out_rem_size > 0) && (in_size > 0)) {
		switch (state) {
		default:
			Ppp_a_enc_err_code	= DTE_PPP_ERR_INTERNAL;
			return (NOK);

		case DTE_PPP_EST_IDLE:			/* Idle, generate first flag */
			*p_out++	= P3_FLAG_CHAR; --out_rem_size;
			state 		= DTE_PPP_EST_GEN_DATA;
			break;

		case DTE_PPP_EST_GEN_DATA:		/* Generating regular data */
			c	= *p_in;
			if (Is_in_accm_to (c)) {
				*p_out++	= P3_CONTROL_ESCAPE_CHAR; --out_rem_size;
				state 		= DTE_PPP_EST_GEN_ESCAPE;
			}
			else {
				*p_out++	= c; --out_rem_size;
				++p_in, --in_size;
			}
			break;

		case DTE_PPP_EST_GEN_ESCAPE:	/* Generating an escape sequence */
			*p_out++	= *p_in ^ P3_XOR_BIT;
			--out_rem_size;
			++p_in, --in_size;
			state 		= DTE_PPP_EST_GEN_DATA;
			break;
		}
	} /* end while */

	if ((in_size <= 0) && 		/* Input buffer exhausted */
		(out_rem_size >= 5)) {	/* Enough place for 2 bytes FCS2, 2 bytes FCS1, final flag */

		/*-------------------------------*/
		/* Generate FCS and closing flag */
		/*-------------------------------*/
		while ((out_rem_size > 0) && (state != DTE_PPP_EST_IDLE)) {

			switch (state) {
			default:						/* should not happen */
				Ppp_a_enc_err_code	= DTE_PPP_ERR_INTERNAL;
				break;

			case DTE_PPP_EST_GEN_DATA:		/* Generating regular data */
				c = Ppp_a_enc_fcs2 ^ 0xFF;
				if (Is_in_accm_to (c)) {
					*p_out++	= P3_CONTROL_ESCAPE_CHAR; --out_rem_size;
					*p_out++	= c ^ P3_XOR_BIT ; --out_rem_size;
				}
				else {
					*p_out++	= c; --out_rem_size;
				}
				state 		= DTE_PPP_EST_GEN_FCS_1;
				break;

			case DTE_PPP_EST_GEN_FCS_1:		/* FCS1 generated */
				c = Ppp_a_enc_fcs1 ^ 0xFF;
				if (Is_in_accm_to (c)) {
					*p_out++	= P3_CONTROL_ESCAPE_CHAR; --out_rem_size;
					*p_out++	= c ^ P3_XOR_BIT ; --out_rem_size;
				}
				else {
					*p_out++	= c; --out_rem_size;
				}
				state 		= DTE_PPP_EST_GEN_FCS_2;
				break;

			case DTE_PPP_EST_GEN_FCS_2:		/* FCS2 generated */
				*p_out++	= P3_FLAG_CHAR; --out_rem_size;
				state 		= DTE_PPP_EST_IDLE;
				break;
			}
		}
	}

	/* Save state */

	Ppp_a_enc_state	= state;

	/* Update input buffer coordinates */
	/*---------------------------------*/
	p_buffer			 = p_in_frm_buf;
	Buffer_data_offset	+= in_0_size - in_size;
	Buffer_data_size 	-= in_0_size - in_size;

	/* Update output buffer coordinates */
	/*----------------------------------*/
	p_buffer			 = p_out_asyn_buf;
	Buffer_data_size	+= out_0_rem_size - out_rem_size;

	/* Return */
	/*--------*/
	if ((in_size == 0) && (state == DTE_PPP_EST_IDLE)) {
		return (STOP);
	}
	return (CONTINUE);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_asyn_init : initialize asynchronous PPP to
									frame processing

Usage           void dte_ppp_asyn_init (
							struct dte_ppp_asyn_ctxt *p_ppp_asyn)
						- p_ppp_asyn : address of the decoding context
									   To be stored by the caller.

Return value : 	none

Description :	Initialize asynchronous PPP to frame processing.

*--------------------------------------------------------------------------*/

void dte_ppp_asyn_init (p_ppp_asyn)
struct dte_ppp_asyn_ctxt 	*p_ppp_asyn;
{
	struct	ppp_link FAR	*p_ppp_link;

	if (p_ppp_asyn == P_NIL) {
		return;
	}

	/*----------------------------------------------------------------------
	 *		Configuration
	 *----------------------------------------------------------------------*/
	p_ppp_link			= Ppp_a_link_1;
	Link_cfg_sdu_format	= P3_SDU_ASYN_OCTET;	/* asynchronous format, octet-oriented */

	p_ppp_link			= Ppp_a_link_2;
	Link_cfg_sdu_format	= P3_SDU_SYNC_BIT;		/* synchronous format, bit-oriented */

	/*----------------------------------------------------------------------
	 *		Initialization
	 *----------------------------------------------------------------------*/
	p_ppp_link	= Ppp_a_link_1;
	Link_p_relayed	= Ppp_a_link_2;
	dte_ppp_link_init (p_ppp_link);

	p_ppp_link	= Ppp_a_link_2;
	Link_p_relayed	= Ppp_a_link_1;
	dte_ppp_link_init (p_ppp_link);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_link_init : initialize link description

Usage           void dte_ppp_link_init (struct ppp_link FAR *p_ppp_link)
						- p_ppp_link : address of the link descriptor

Return value : 	none

Description :	Initialize link descriptor

*--------------------------------------------------------------------------*/

STATIC void dte_ppp_link_init (p_ppp_link)
struct ppp_link FAR 	*p_ppp_link;
{

	Memset_far ((char FAR *)Link_def_accm_to,   0x00,
				P3_NB_BYTES_IN_ACCM_TO);

	switch (Link_cfg_sdu_format) {
	default	:
	case P3_SDU_ASYN_OCTET:			/* asynchronous format, octet oriented */

			/* receive ACCM is all 1s */

		Memset_far ((char FAR *)Link_def_accm_from, 0xFF,
					P3_NB_BYTES_IN_ACCM_FROM);

			/*
			 *	transmit ACCM :
			 *	all characters between 0x00 and 0x1f are escaped,
			 *	plus flag 0x7E,
			 *	plus escape 0x7D
			 */
		Memset_far ((char FAR *)Link_def_accm_to,   0xFF,
					P3_NB_BYTES_IN_ACCM_FROM);					/* yes, FROM */

		Set_in_def_accm_to (P3_FLAG_CHAR);
		Set_in_def_accm_to (P3_CONTROL_ESCAPE_CHAR);
			/*
			 *	Add possibly other characters
			 *	DC1/DC3 with parity
			 *	DEL with and without parity
			 *	all control characters with parity
			 *	etc.	For now : nothing.
			 */

		break;

	case P3_SDU_SYNC_OCTET:			/* synchronous format, octet oriented */

			/* receive ACCM is all 0s */

		Memset_far ((char FAR *)Link_def_accm_from, 0x00,
					P3_NB_BYTES_IN_ACCM_FROM);

			/*
			 *	transmit ACCM :
			 *	flag 0x7E and escape 0x7D are escaped.
			 *	characters between 0x00 and 0x1f are NOT escaped,
			 */
		Set_in_def_accm_to (P3_FLAG_CHAR);
		Set_in_def_accm_to (P3_CONTROL_ESCAPE_CHAR);
		break;


	case P3_SDU_SYNC_BIT:			/* synchronous format, bit oriented */

			/* receive ACCM is all 0s */

		Memset_far ((char FAR *)Link_def_accm_from, 0x00,
					P3_NB_BYTES_IN_ACCM_FROM);

			/* transmit ACCM is all 0s */

		break;
	}

	Reset_in_accm_to (P3_FLAG_CHAR ^ P3_XOR_BIT);		/* this one cannot be escaped */

	Link_def_mru_from	= LCP_DEFAULT_MRU;
	Link_def_mru_to		= LCP_DEFAULT_MRU;
	Link_def_mru_loc	= Buffer_data_lgth - P3_MAX_NB_BYTES_FOR_HOLE;

	/*
	 *	Initialize current values from default values
	 */
	Link_cur_mru_loc	= Link_def_mru_loc;

	Link_cur_mru_from	= Link_def_mru_from;
	Memcpy_far ((char FAR *)Link_cur_accm_from,
				(char FAR *)Link_def_accm_from, P3_NB_BYTES_IN_ACCM_FROM);

	Link_cur_mru_to		= Link_def_mru_to;
	Copy_full_accm_to (Link_def_accm_to);

	Link_cur_hole_size_to	= 2;		/* 0 is OK for PHs */

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_sync_decode : convert synchronous PPP frame to
									  PPP block

Usage           uchar dte_ppp_sync_decode (
							struct ppp_link FAR			*p_ppp_link,
							struct buffer FAR 			*p_in_out_sync_buf)

						- p_ppp_link : address of the PP link description
						- p_in_out_sync_buf :
							on entry : address of the input buffer,
							on exit, buffer contents and data_size may be
									 updated.

Return value : 	decoding process result code :
				NOK: an error occurred.
				STOP: a complete, correct frame has been generated.
					Buffer contains the complete block

Description :	Convert synchronous PPP frame to block
				The size of the output buffer is by construction smaller
				than the size of the input buffer

*--------------------------------------------------------------------------*/

uchar dte_ppp_sync_decode (p_ppp_link, p_in_out_sync_buf)
struct ppp_link FAR			*p_ppp_link;
struct buffer FAR 			*p_in_out_sync_buf;
{
	uchar FAR				*p_in;
	short					 in_size;
	uchar FAR				*p_out_0;
	uchar FAR				*p_out;
	uchar					 c;
	uchar					 state;
	struct buffer FAR		*p_buffer;

	p_buffer	= p_in_out_sync_buf;
	if (p_buffer == P_NIL) {
		return (NOK);
	}

	p_in		= Buffer_a_start_data;
	in_size		= Buffer_data_size;

	p_out_0	= p_out	= Buffer_a_start_data;

	state		= DTE_PPP_DST_IN_DATA;

	while (in_size > 0) {
		c = *p_in++; --in_size;
		if (state == DTE_PPP_DST_IN_DATA) {
#if	0
			if (c == P3_CONTROL_ESCAPE_CHAR) {
				state	= DTE_PPP_DST_IN_ESCAPE;
			}
			else if (Is_in_accm_from (c)) {
				/*
				 *	A control character has been inserted : suppress it
				 */
				;
			}
			else
#endif
			{
				*p_out++ = c;
			}
		}
		else if (state == DTE_PPP_DST_IN_ESCAPE) {
			if (Is_in_accm_from (c)) {
				/*
				 *	A control character has been inserted : suppress it
				 */
				;
			}
			else {
				state	= DTE_PPP_DST_IN_DATA;
				*p_out++ = c ^ P3_XOR_BIT;
			}
		} /* end ifs */
	} /* end while */


	/* Update buffer coordinates */

	Buffer_data_size	= p_out - p_out_0;

	return (STOP);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dte_ppp_sync_encode : convert PPP block to synchronous PPP frame

Usage           uchar dte_ppp_sync_encode (
							struct ppp_link FAR 		*p_ppp_link,
							struct buffer FAR * FAR *	*p_p_in_out_buffer);

						- p_ppp_link : address of the link context
						- p_p_in_out_buffer :
							on entry:
								address of the address of the input buffer
							on exit:
								address of the address of the ouput buffer.
								On exit, data_offset/data_size are updated.

Return value : 	encoding process result code :
				NOK: an error occurred.
					Output buffer has to be discarded.
					Input buffer has been completely analyzed.
				STOP: a complete, correct synchronous PPP frame has been
					generated.
					Output buffer contains the generated synchronous PPP
					frame.
					Input buffer has been completely analyzed.
				CONTINUE: a complete frame synchronous PPP frame could not
					be built. Encoding is still in progress.
					Input buffer and output buffer are discraded

Description :	Convert PPP 'block' data to synchronous frame.
				Currently the output frame must fit in ONE single buffer.
				The output buffer may be identical to the input buffer.
				Or it may be different. In this case the input buffer is
				freed here, and an output buffer is allocated here.

*--------------------------------------------------------------------------*/

uchar dte_ppp_sync_encode (p_ppp_link, p_p_in_out_buffer)
struct ppp_link FAR 		*p_ppp_link;
struct buffer FAR * FAR 	*p_p_in_out_buffer;
{
	uchar FAR				*p_in;
	uchar FAR				*p_in_0;
	short					 in_size;
	short					 in_0_size;
	uchar FAR				*p_out;
	short					 out_rem_size;
	short					 out_0_rem_size;
	uchar					 c;
	uchar					 state;
	uchar					 compute_fcs;
	struct buffer FAR		*p_buffer;
	struct buffer FAR		*p_in_buf;
	struct buffer FAR		*p_out_buf;

	compute_fcs	= OFF;

	if ((compute_fcs == OFF) && Is_accm_to_empty ()) {
		/*
		 *	No processing to perform on input block,
		 *	output frame IS input block
		 */
		return (STOP);
	}

	p_in_buf	= P_NIL;
	p_out_buf	= P_NIL;


	p_in_buf	= *p_p_in_out_buffer;

	if (p_in_buf == P_NIL) {
		goto error;
	}
	p_buffer	= p_in_buf;
	p_in_0		= Buffer_a_start_data;
	in_0_size	= Buffer_data_size;

	/*
	 *	Allocate output buffer
	 */
	p_out_buf	= dte_ppp_alloc_buffer (p_ppp_link);
	if (p_out_buf == P_NIL) {
		goto error;
	}
	p_buffer		= p_out_buf;
	p_out			= Buffer_a_start_data;
	out_0_rem_size	= Buffer_data_lgth - Buffer_data_offset - Buffer_data_size;

	/*
	 *	Prepare result
	 */
	*p_p_in_out_buffer	= p_buffer;

	/*-------------------------*/
	/* Generate frame contents */
	/*-------------------------*/
	p_in			= p_in_0;
	in_size			= in_0_size;
	out_rem_size	= out_0_rem_size;
	state			= DTE_PPP_EST_IDLE;

	while ((out_rem_size > 0) && (in_size > 0)) {
		switch (state) {
		default:
			goto error;

		case DTE_PPP_EST_IDLE:			/* Idle, generate first flag */
			state 		= DTE_PPP_EST_GEN_DATA;
			break;

		case DTE_PPP_EST_GEN_DATA:		/* Generating regular data */
			c	= *p_in;
			if (Is_in_accm_to (c)) {
				*p_out++	= P3_CONTROL_ESCAPE_CHAR; --out_rem_size;
				state 		= DTE_PPP_EST_GEN_ESCAPE;
			}
			else {
				*p_out++	= c; --out_rem_size;
				++p_in, --in_size;
			}
			break;

		case DTE_PPP_EST_GEN_ESCAPE:	/* Generating an escape sequence */
			*p_out++	= *p_in ^ P3_XOR_BIT;
			--out_rem_size;
			++p_in, --in_size;
			state 		= DTE_PPP_EST_GEN_DATA;
			break;

		} /* end switch */

	} /* end while */

	if ((in_size <= 0) && 		/* Input buffer exhausted */
		(compute_fcs == OFF)) {
		state 		= DTE_PPP_EST_IDLE;
	}

	/* Update input buffer coordinates */
	/*---------------------------------*/
	p_buffer			 = p_in_buf;
	Buffer_data_offset	+= in_0_size - in_size;
	Buffer_data_size 	-= in_0_size - in_size;

	/* Update output buffer coordinates */
	/*----------------------------------*/
	p_buffer			 = p_out_buf;
	Buffer_data_size	+= out_0_rem_size - out_rem_size;

	/* Return */
	/*--------*/
	if ((in_size == 0) && (state == DTE_PPP_EST_IDLE)) {
		Free_buffer (p_in_buf);
		return (STOP);
	}

	Free_buffer (p_in_buf);
	Free_buffer (p_out_buf);
	*p_p_in_out_buffer	= P_NIL;
	return (CONTINUE);

error:
	Free_buffer (p_in_buf);
	Free_buffer (p_out_buf);
	*p_p_in_out_buffer	= P_NIL;
	return (NOK);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			p3_fr_parse : parse a PPP frame

Usage           void p3_fr_parse (
							struct ppp_link   FAR *p_ppp_link,
							struct ppp_fr_dsc FAR *p_fr_dsc,
							struct buffer 	  FAR *p_buffer)

						- p_ppp_link : address of the link context
						- p_fr_dsc : address of the frame descriptor to build
						- p_buffer : address of the buffer containing the frame

Return value : 	none

Description :	Parse a PPP frame, build a frame descriptor

*--------------------------------------------------------------------------*/

void p3_fr_parse (p_ppp_link, p_fr_dsc, p_buffer)
struct ppp_link 	FAR		*p_ppp_link;
struct ppp_fr_dsc 	FAR		*p_fr_dsc;
struct buffer 		FAR 	*p_buffer;
{
	uchar			FAR		*p_in;
	uchar			FAR		*p_in_0;
	short					 in_size;
	short					 in_size_0;
	short					 ncnzb;		/* number of consecutive non zero bytes */
	ppp_protocol_id_t		 protocol_id;
	uchar					 c;

	uchar					 nb_options;	/* number of LCP otions */
	ppp_opt_off_t			 next_offset;	/* offset for next LCP option */


	Memset_far ((char FAR *)p_fr_dsc, 0x00, Ppp_fr_dsc_size);

	Fr_p_buffer		= p_buffer;
	Fr_p_ppp_link	= p_ppp_link;
	Fr_p_first_byte	= Buffer_a_start_data;

	p_in		= p_in_0	= Buffer_a_start_data;
	in_size_0	= in_size	= Buffer_data_size;

	/*
	 *	Parse address and control field : FF 03
	 */
	if (in_size >= 2) {
		if ((p_in [0] == P3_ADDRESS_BYTE) &&
			(p_in [1] == P3_CONTROL_BYTE)) {
			p_in	+= 2;	in_size -= 2;
			Fr_ppp_acf_present	= ON;
		}
	}

	/*
	 *	Parse protocol id (C021, etc.)
	 */
	protocol_id		= 0;
	ncnzb			= 0;

	while (in_size > 0) {
		c	= *p_in++;	--in_size;

		if ((c == 0x00) && (ncnzb == 0)) {
			/*
			 *	We are in a sequence of initial zero bytes
			 */
			;
		}
		else {
			++ncnzb;
			protocol_id	= (protocol_id * 256) + c;

			if ((c & 0x01) != 0) {
				/*
				 *	The LSB is 1 : end of protocol field
				 */
				break;
			}
		}
	}

	if (ncnzb > 2) {	/* more than two significant bytes for encoding the protocol id */
		Fr_error_code	= P3_FRR_PROTOCOL_ID_TOO_LONG;
		return;
	}

	Fr_ppp_protocol_id	= protocol_id;
	Fr_ppp_info_off		= in_size_0 - in_size;

	switch (protocol_id) {
	default:				/* other, non processed protocols */
		return;

	case P3PROT_LCP:		/* LCP protocol : decode 'code' */
		Fr_lcp_code			= *p_in++;	--in_size;
		Fr_lcp_identifier	= *p_in++;	--in_size;

		Fr_lcp_fr_length	= Get_short_from_p (p_in);

		/*
		 *	Check LCP-protocol supplied size against received data size
		 */
		if (Fr_lcp_fr_length < 4) {
			Fr_error_code	= P3_FRR_LCP_FR_SIZE_4;
			Fr_error_offset	= p_in - p_in_0;
			return;
		}
		if (in_size < (Fr_lcp_fr_length - 4)) {
			Fr_error_code	= P3_FRR_LCP_FR_SIZE_RECEIVED_DATA;
			Fr_error_offset	= p_in - p_in_0;
			return;
		}
		/*
		 *	Check LCP-protocol supplied size against MRU
		 */
		if (Fr_lcp_fr_length > Link_cur_mru_from) {
			Fr_error_code	= P3_FRR_LCP_FR_SIZE_MRU;
			Fr_error_offset	= p_in - p_in_0;
			return;
		}
		p_in += 2; in_size -= 2;

		/*
		 *	Adjust in_size, and in_size_0, in order to avoid analyzing padding
		 */
		in_size_0	-= 	(in_size - (Fr_lcp_fr_length - 4));
		in_size		 = Fr_lcp_fr_length - 4;

		/*
		 *	Analyze CONFIGURE_xxx
		 */
		switch (Fr_lcp_code) {
		default:
			break;
		case LCP_CONFIGURE_REQUEST:
		case LCP_CONFIGURE_ACK:
		case LCP_CONFIGURE_NAK:
		case LCP_CONFIGURE_REJECT:
			/*
			 *	Analyze options
			 */
			nb_options	= 0;
			next_offset	= 0;

			while (in_size > 0) {
				uchar			opt_length;
				uchar			opt_type;

				if (nb_options > P3_NB_CONFIGURE_OPTIONS) {
					Fr_error_code	= P3_FRR_CFG_LCP_NB_OPTS;
					Fr_error_offset	= p_in - p_in_0;
					break;
				}

				if (in_size < 2) {
					Fr_error_code	= P3_FRR_LCP_OPT_SIZE_RECEIVED_2;
					Fr_error_offset	= p_in - p_in_0;
					break;
				}
				opt_type	= *p_in;
				p_in += 1; in_size	-= 1;

				opt_length	= *p_in;
				if (opt_length < 2) {
					Fr_error_code	= P3_FRR_LCP_OPT_SIZE_DECLARED_2;
					Fr_error_offset	= p_in - p_in_0;
					break;
				}

				if (in_size < (opt_length - 2)) {
					Fr_error_code	= P3_FRR_LCP_OPT_SIZE_RECEIVED_SHORT;
					Fr_error_offset	= p_in - p_in_0;
					break;
				}

				p_in += 1; in_size	-= 1;

				opt_length -= 2;		/* adjust for internal storage */

				if ((next_offset + opt_length) > P3_NB_BYTES_IN_OPTIONS) {
					Fr_error_code	= P3_FRR_CFG_LCP_NB_BYTES_FOR_OPTS;
					Fr_error_offset	= p_in - p_in_0;
					break;
				}

				Fr_lcp_cfg_opt_type   (nb_options) = opt_type;
				Fr_lcp_cfg_opt_offset (nb_options) = next_offset;
				Fr_lcp_cfg_opt_length (nb_options) = opt_length;

				Memcpy_far ((char FAR *)(Fr_lcp_cfg_opt_data + next_offset),
							(char FAR *)p_in, opt_length);

				/*
				 *	Process the options we are interested in
				 */
				switch (opt_type) {
				default:
					break;
				case LCP_CO_MRU:	/* Maximum-Receive-Unit */
					if (opt_length != 2) {
						Fr_error_code	= P3_FRR_LCP_MRU_SIZE;
						Fr_error_offset	= p_in - p_in_0 - 1;
						break;
					}
					Fr_lcp_cfg_mru_present	= ON;
					Fr_lcp_cfg_mru_val		= Get_short_from_p (p_in);
					break;

				case LCP_CO_ACCM: 	/* ACCM : Async-Control-Character-Map */
					if (opt_length != 4) {
						Fr_error_code	= P3_FRR_LCP_ACCM_SIZE;
						Fr_error_offset	= p_in - p_in_0 - 1;
						break;
					}
					Fr_lcp_cfg_accm_present	= ON;
					/*
					 *	Save frame's ACCM into internal form : swap bytes.
					 *	Bits in bytes are kept in the line order.
					 *	An ACCM representing DC1/DC3 (XON/XOFF, 0x11/0x13)
					 *	is encoded in a frame as 00 0A 00 00
					 */
					Fr_lcp_cfg_accm_val [0] = p_in [3];
					Fr_lcp_cfg_accm_val [1] = p_in [2];
					Fr_lcp_cfg_accm_val [2] = p_in [1];
					Fr_lcp_cfg_accm_val [3] = p_in [0];
					break;
				}

				if (Fr_error_code != 0) {
					break;
				}

				p_in	+= opt_length;
				in_size	-= opt_length;

				++nb_options;
				next_offset	+= opt_length;
			} /* end while */

			Fr_lcp_cfg_nb_options	= nb_options;
			Fr_lcp_cfg_next_offset	= next_offset;

			break;
		}
		break;

	} /* end switch */
}

#endif		/* DTE_PPP == ON */

/*EOF*/
