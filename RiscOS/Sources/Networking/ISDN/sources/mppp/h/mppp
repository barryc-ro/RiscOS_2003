
/*--------------------------------------------------------------------------*
 *						 M O D U L E   H E A D E R
 *
 * filename - mppp.h
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the commmon declarations of the Multi Link Point to Point
 * Protocol functions (ML PPP)
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    Multi Link PPP Entity                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1997 by OMNITEL SA                 |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef _MPPP_H /* { */
#define _MPPP_H

/*--------------------------------------------------------------------------*/

#include "services.h"	/* OMNITEL-Bricks Common Services header file */

#include "mppp_int.h"	/* ML PPP upper interface */
#include "mppp_dbg.h"	/* entity debugging macros */


/*-----------------------------------------------------------------------*/

			/* Pasword-Authentication-Protocol parameters */

			/* PAP Username and Password */

#ifndef MPPP_MX_SZ_USERNAME
#	define MPPP_MX_SZ_USERNAME		64		/* maximum size of PAP Username */
#endif

#ifndef MPPP_MX_SZ_PASSWORD
#	define MPPP_MX_SZ_PASSWORD		64		/* maximum size of PAP Password */
#endif

/*--------------------------------------------------------------------------*/

#if SIMULATION == OFF

			/* ML PPP entity defines */

#	define	event_id				event_id_mppp		/* event identifier */
#	define	ret_code				ret_code_mppp		/* return code */
#	define	p_snd_msg				p_snd_msg_mppp		/* pointer on the current message to send if any */
#	define	p_rcv_msg				p_rcv_msg_mppp		/* pointer on the current received message if any */
#	define	p_buffer				p_buffer_mppp		/* pointer on the curent buffer if any */
#	define	p_buffer_end			p_buffer_end_mppp	/* pointers on the end of the current buffer if any */
#	define	os_err					os_err_mppp			/* OS error code */

#endif


/*--------------------------------------------------------------------------*/

		/*
			Bundle's SPPP CEPs objects list management structure
		*/

struct sppp_queue_mgt {
   struct sppp_cep FAR *p_first;	/* pointer to the first entry */
   struct sppp_cep FAR *p_last;		/* pointer to the last entry */
};

		/*--------------------------------------------------------------------

			SPPPs queue manipulation macros.
			The following parameters are used:

			p_h : pointer to the head of the list
			p_e : pointer to a list entry on which the macro will operate

			_TMP_p_curr : temporary current entry pointer
			_TMP_p_next : temporary entry's front link pointer
			_TMP_p_first: temporary pointer to the first entry
			_TMP_p_last : temporary pointer to the last entry

		---------------------------------------------------------------------*/

		/* Initialization of the list */

#define Sppp_init_list_head(p_h)		\
	(p_h)->p_first = (p_h)->p_last = P_NIL

		/* This macro gets the first entry in the list */

#define Sppp_get_first_in_list(p_h)		\
	((p_h)->p_first)

		/* This macro gets the last entry in the list */

#define Sppp_get_last_in_list(p_h)		\
	((p_h)->p_last)

		/* This macro gets the front link from an entry */

#define Sppp_get_next_in_list(p_e)	\
	((p_e)->p_next)

		/* This macro checks for an empty list */

#define Sppp_is_list_empty(p_h)			\
	(Sppp_get_first_in_list(p_h) == P_NIL)

		/* This macro removes an entry from the list */

#define Sppp_remove_entry_list(p_h,p_e)			\
		{										\
			struct sppp_cep FAR *_TMP_p_next;	\
			struct sppp_cep FAR *_TMP_p_curr;	\
			_TMP_p_next = (p_e)->p_next;		\
			if (((p_h)->p_first == (p_e)) && ((p_h)->p_last == (p_e))) { \
				(p_h)->p_first = (p_h)->p_last = P_NIL;		\
			} else if ((p_h)->p_first == (p_e)) {			\
				(p_h)->p_first = _TMP_p_next;				\
			} else {										\
				_TMP_p_curr = (p_h)->p_first;				\
				while ((_TMP_p_curr)->p_next != (p_e)) {	\
					_TMP_p_curr = (_TMP_p_curr)->p_next;	\
				}											\
				if ((p_h)->p_last == (p_e)) {				\
					(_TMP_p_curr)->p_next = P_NIL;			\
					(p_h)->p_last = _TMP_p_curr;			\
				} else {									\
					(_TMP_p_curr)->p_next = _TMP_p_next;	\
				}											\
			}												\
		}

/*$$$ NOT USED	(p_e)->p_next = P_NIL;							\ */


		/* This macro removes the first entry from the list */

#define Sppp_remove_head_list(p_h) \
	{Sppp_remove_entry_list (p_h, ((p_h)->p_first));}

		/* This macro removes the last entry from the list */

#define Sppp_remove_tail_list(p_h) \
	{Sppp_remove_entry_list (p_h, ((p_h)->p_last));}

		/* This macro inserts an entry at the tail of the list */

#define Sppp_insert_tail_list(p_h,p_e)			\
		{										\
			struct sppp_cep FAR *_TMP_p_last;	\
			_TMP_p_last	 = (p_h)->p_last;		\
			(p_e)->p_next  = P_NIL;				\
			if (_TMP_p_last == P_NIL) {			\
				(p_h)->p_first = (p_e);			\
			} else {							\
				_TMP_p_last->p_next = (p_e);	\
			}									\
			(p_h)->p_last  = (p_e);				\
		}

		/* This macro inserts an entry at the head of the list */

#define Sppp_insert_head_list(p_h,p_e)			\
		{										\
			struct sppp_cep FAR *_TMP_p_first;	\
			_TMP_p_first = (p_h)->p_first;		\
			if (_TMP_p_first == P_NIL) {		\
				(p_h)->p_last = (p_e);			\
			}									\
			(p_e)->p_next = _TMP_p_first;		\
			(p_h)->p_first = (p_e);				\
		}

/*--------------------------------------------------------------------------*/

		/* Macros for mesages codes translation */

#define Mppp_xlate_ph_to_mppp_code(code)		(code)
#define Mppp_xlate_mppp_to_ph_code(code)		(code)

#define Mppp_xlate_mppp_to_cc_code(code)		(code)
#define Mppp_xlate_cc_to_mppp_code(code)		(code)

#define Mppp_xlate_mppp_to_dl_code(code)		(code)
#define Mppp_xlate_dl_to_mppp_code(code)		(code)

#define Mppp_xlate_mppp_to_x25_code(code)		(code)
#define Mppp_xlate_x25_to_mppp_code(code)		(code)

/*--------------------------------------------------------------------------*/

		/*===================================================================

			Protocol Field Codes in PPP Data Link Frames.
			[RFC 1661 and RFC Draft May 1996]

			- All protocols MUST be odd
			- The least significant bit of the least significant octet MUST
			  equal "1"
			- All protocols MUST be assigned such that the least significant
			  bit of the most significant octet equals "0"

			All protocols IDs verify these rules:
			1- (PPP_PROT_MASK & Protocol_Value) = Protocol_Value
			   and
			2- (Protocol_Value % 2) = 1

		====================================================================*/

#define PPP_PROT_MASK			0xFEFF

	/*
		This macro determines a PPP (Control) Protocol
	*/

#define Mppp_is_prot(pid)			(((pid) % 2) && (((pid) & PPP_PROT_MASK) == (pid)))
#define Mppp_is_c_prot(pid)			((Mppp_is_prot(pid)) && ((pid) & 0x8000))

	/*
		Network-Layer Protocols ID Of Specific Packets
		Range: 0*** to 3***
		(not exhaustive. See RFC 1700)
	*/

#define PPP_PROT_IP			0x0021	/* Internet Protocol ID */
#define PPP_PROT_MP			0x003D	/* Multilink Protocol ID */
#define PPP_PROT_PADDING	0x0001	/* Padding Protocol ID */
#define PPP_PROT_BAP_DRAFT	0x0071	/* Bandwidth Allocation Protocol ID (Draft) */
#define PPP_PROT_NLPID		0x00CF	/* PPP Network Layer Protocol ID */

	/*
		Protocols with low volume traffic which have no associated
		Network Control Protocol
		Range: 4*** to 7***
		(not exhaustive. See RFC 1700)
	*/


	/*
		Network Control Protocols ID Of Specific Packets (NCPs)
		Range: 8*** to b***
		(not exhaustive. See RFC 1700)
	*/

#define PPP_PROT_IPCP		0x8021	/* Internet Protocol Control Protocol ID */
#define PPP_PROT_MLCP		0x803D	/* Multi-Link Control Protocol ID */
#define PPP_PROT_BACP_DRAFT	0x8071	/* Bandwidth Allocation Control Protocol ID (Draft) */
#define PPP_PROT_CCP		0x80FD	/* Compression Control Protocol ID */

	/*
		Link-Layer Control Protocols (e.g LCP)
		Range: c*** to f***
		(not exhaustive. See RFC 1700)
	*/

#define PPP_PROT_LCP		0xC021	/* Link Control Protocol ID */
#define PPP_PROT_PAP		0xC023	/* Password Authentication Protocol ID */
#define PPP_PROT_LQR		0xC025	/* Link Quality Report */
#define PPP_PROT_CBCP		0xC029	/* CallBack Control Protocol (CBCP) */

#define PPP_PROT_BACP		0xC02B	/* Bandwidth Allocation Conotrol Protocol ID */
#define PPP_PROT_BAP		0xC02D	/* Bandwidth Allocation Protocol ID */

#define PPP_PROT_CHAP		0xC223	/* Challenge Handshake Authentication Protocol ID */

#define PPP_AUTH_ALG_MD5	5		/* MD5 digest algorithm */

/*-----------------------------------------------------------------------*/

	/*
		PPP "UI" frame header (address+contro+protocol ID)
	*/

#define PPP_UI_ADD_VAL			(uchar)0xFF		/* UI address field */
#define PPP_UI_CTRL_VAL			(uchar)0x03		/* UI control field */
#define PPP_UI_ADD_CTRL_LGTH	2				/* UI address and control fields length */

	/*
		PPP headers
	*/

#define PPP_FRAME_HEADER_LGTH		4	/* address+control+protocol ID */
#define PPP_PACKET_HEADER_LGTH		4	/* packet code + packet id + packet length */

	/*
		Asynchonous PPP frames reception states
	*/

#define PPP_RFS_FIRST_FRAME_START	'F'		/* First frame start: waiting for PPP flag */
#define PPP_RFS_FRAME_START			'S'		/* frame Start: PPP flag is optional */
#define PPP_RFS_FRAME_RECEIVING		'R'		/* frame Receiving: frame partially received */

	/* General constants for HDLC-Like implementation */

#define PPP_FLAG					0x7E	/* PPP flag */
#define PPP_CTRL_ESC				0x7D	/* PPP control escapr character */
#define PPP_CTRL_CHAR_CMPL_MASK		0x20	/* PPP control character complement mask */
#define PPP_FCS_OK					0xF0B8	/* This value is the only valid value of FCS */

#define PPP_FCS_INIT_VAL			0xFFFF		/* FCS initial value (0xFFFF for new equipment or 0) */
#define PPP_FCS_POLYNOME_16			0x8408		/* polynome (in reverse order) for the calculation of FCS */

#define Mppp_fcs_check_ok(fcs)		(fcs == PPP_FCS_OK)

		/*
			These macros determine if a character need to be escaped
		*/

#define Mppp_is_ctrl_char(c)		((c) < PPP_CTRL_CHAR_CMPL_MASK)
#define Mppp_char_to_escape(c,map)	(((ulong)map) & ((ulong)1 << ((c) & 0x1F)))


		/*
			Maximum value for a PPP Packet ID
		*/

#define	PPP_MX_PACKET_ID_VAL		0xFF

/*-----------------------------------------------------------------------*/

		/*=====================================

			Macros used to format/decode
					PPP packets.

		=====================================*/


		/*
			Get/Put char/short/long.
			Pointer is advanced.
			p_curr is "uchar FAR *".
		*/

#define Mppp_get_char(c, p_curr)	(c) = *(p_curr)++

#define Mppp_put_char(c, p_curr)	*(p_curr)++ = (uchar) (c)

#define Mppp_get_short(s, p_curr)	(s) = *(p_curr)++ << 8; \
									(s) |= *(p_curr)++

#define Mppp_put_short(s, p_curr)	*(p_curr)++ = (uchar) ((s) >> 8); \
									*(p_curr)++ = (uchar) (s)

#define Mppp_get_long(l, p_curr)		(l) = *(p_curr)++ << 8; \
									(l) |= *(p_curr)++; (l) <<= 8; \
									(l) |= *(p_curr)++; (l) <<= 8; \
									(l) |= *(p_curr)++

#define Mppp_put_long(l, p_curr)	*(p_curr)++ = (uchar) ((l) >> 24); \
									*(p_curr)++ = (uchar) ((l) >> 16); \
									*(p_curr)++ = (uchar) ((l) >> 8); \
									*(p_curr)++ = (uchar) (l)

#define Mppp_inc_ptr(n, p_curr)		((p_curr) += (n))

#define Mppp_dec_ptr(n, p_curr)		((p_curr) -= (n))

		/*
			This macro formats the PPP frame header:
			Address,Control,Protocol ID.
		*/

#define Mppp_load_ppp_header(p_curr, pid)	\
				Mppp_put_char(PPP_UI_ADD_VAL, p_curr);	\
				Mppp_put_char(PPP_UI_CTRL_VAL, p_curr); \
				Mppp_put_short(pid, p_curr)

		/*
			This macro returns a PPP magic number. Actually returns the number
			of Omnitel system ticks.
		*/

#define Mppp_gen_magic()			((ulong)(System_time()))

/*-----------------------------------------------------------------------*/

		/*===================================================================

							PPP Link Phase Diagram
							(Related to LCP)

		+------+		+-----------+			+--------------+
		|	   |  UP	|			|	OPENED	|			   | SUCCESS/NONE
		| DEAD |------->| Establish |---------->| Authenticate |------+
		|	   |		|			|			|			   |	  |
		+------+		+-----------+			+--------------+	  |
		   ^				  |						 |				  |
		   |	  FAIL		  |						 |				  |
		   |<-----------------+				  FAIL	 |				  |
		   |						   +-------------+				  |
		   |						   |							  |
		   |		  +------------+   |			 +---------+	  |
		   |   DOWN	  |			   |   v   CLOSING	 |		   |	  |
		   +----------| Terminate  |<--+-------------| Network |<-----+
					  |			   |				 |		   |
					  +------------+				 +---------+

		Not all transitions are specified in this diagram.

			Link Phases definitions.
			[RFC 1661]

			* Dead (physical-layer not ready)
			* Establish (ready for LCP options negotiation)
			* Authenticate (ready for authentication protocol)
			* Network (ready for Network Layer Protocol exchanges)
			* Terminate (terminating the PPP link, before disconnect)

		====================================================================*/

#define SPPP_LINK_PHASE_DEAD				'D'
#define SPPP_LINK_PHASE_ESTABLISHMENT		'E'
#define SPPP_LINK_PHASE_AUTHENTICATE		'A'
#define SPPP_LINK_PHASE_NETWORK				'N'
#define SPPP_LINK_PHASE_TERMINATION			'T'

/*-------------------------------------------------------------------------*/

			/* MultiLink state machine */

#define MPPP_ESTABLISHED			'E'		/* MPPP established */
#define MPPP_RELEASED				'R'		/* MPPP released */
#define MPPP_AWAITING_EST			'W'		/* MPPP awaiting establishment */
#define MPPP_AWAITING_REL			'w'		/* MPPP awaiting release */
#define MPPP_AWAITING_SPPP_EST		'C'		/* awaiting SPPP establishment */
#define MPPP_AWAITING_SPPP_REL		'D'		/* awaiting SPPP releasing */
#define MPPP_AWAITING_RESET_CO		'O'		/* awaiting reset confirm */

			/*	Single Link Connection state */

#define SPPP_ESTABLISHED			'E'		/* Single link connection established */
#define SPPP_RELEASED				'R'		/* Single link connection released */
#define SPPP_AWAITING_EST			'W'		/* Single link connection awaiting estabish */
#define SPPP_AWAITING_REL			'w'		/* Single link connection awaiting release */


/*-----------------------------------------------------------------------*/

			/* Macro used for the setting of PPP member link phase */

#define	Set_sppp_cep_link_phase(val)	Sppp_cep_link_phase	= val

/*-----------------------------------------------------------------------*/

				/* Call Control Cause values (we cannot include NS files) */

#define MPPP_CC_CAUSE_CALL_REJECTED		21		/* call rejected */

				/* SL PPP call control state */

#define MPPP_CC_STATE_NULL				'0'		/* released */
#define MPPP_CC_STATE_CALL_INIT			'1'		/* outgoing call initiated */
#define MPPP_CC_STATE_CALL_IN			'2'		/* incoming call indicated */
#define MPPP_CC_STATE_CALL_RS			'3'		/* incoming call accepted (awaiting for a CONN_CO after sending a CONN_RS) */
#define MPPP_CC_STATE_ACTIVE			'4'		/* established/connected */
#define MPPP_CC_STATE_DISC_RQ			'5'		/* release requested */
#define MPPP_CC_STATE_DISC_IN			'6'		/* release indicated */
#define MPPP_CC_STATE_DISC_RS			'7'		/* release response (awaiting for a CLEAR_CO after sending a CLEAR_RS) */


/*-----------------------------------------------------------------------*/

			/* Entity control flow state */

#define FREE					'F'				/* free entity */
#define BUSY					'B'				/* busy entity */

/*-----------------------------------------------------------------------*/

			/* Types of access to ML/SL PPP objects */

#define MPPP_ACC_TYPE_SIG		'S'				/* signalling SAP */
#define MPPP_ACC_TYPE_SIG_MGT	'M'				/* signalling management */
#define MPPP_ACC_TYPE_DATA		'D'				/* data SAP */

/*-----------------------------------------------------------------------*/

			/* Authentication Protocols : TIMER MANAGEMENT */

#define MPPP_PAP_TI_X_RESTART		0	/* PAP Restart timer	 */

			/* Start timer */

#define Sppp_auth_start_timer(xx)		\
			Timer_start (Sppp_auth_ti_id(xx), Sppp_auth_ti_val(xx),					\
						++(Sppp_auth_ti_sn(xx)), Sppp_auth_ti_ev_id(xx)); Sppp_auth_ti_state(xx) = ON

#define Sppp_auth_start_timer_val(xx,val) \
			Timer_start (Sppp_auth_ti_id(xx), val, ++(Sppp_auth_ti_sn(xx)),		\
						Sppp_auth_ti_ev_id(xx)); Sppp_auth_ti_state(xx) = ON

			/* Restart timer = start timer */

#define Sppp_auth_restart_timer(xx)	\
			Timer_start (Sppp_auth_ti_id(xx), Sppp_auth_ti_val(xx),						\
						++(Sppp_auth_ti_sn(xx)), Sppp_auth_ti_ev_id(xx)); Sppp_auth_ti_state(xx) = ON

			/* Stop timer */

#define Sppp_auth_stop_timer(xx)	\
			Timer_stop (Sppp_auth_ti_id(xx)); Sppp_auth_ti_state(xx) = OFF

			/* Timer state access */

#define Sppp_auth_state_timer(xx)		\
			Sppp_auth_ti_state(xx)

			/* Check timer event validity according to the sequence number */

#define Sppp_auth_valid_time_out(xx)		\
			((Sppp_auth_ti_state(xx) == ON) && (R_msg_inf0 == Sppp_auth_ti_sn (xx)))

#define Sppp_auth_ti_ev_id(xx)	MPPP_AUTH_TI_EV_ID[xx]	/* timer ID table */

/*-----------------------------------------------------------------------*/

			/* ML PPP Control Protocols : TIMER MANAGEMENT */

		/* ML PPP Control Protocols timer table : index assigned to timers */

#define MPPP_LCP_TI_X_RESTART		0	/* ML PPP LCP Restart timer	 */
#define MPPP_BACP_TI_X_RESTART		1	/* ML PPP BACP Restart timer */
#define MPPP_BAP_TI_X_RESTART		2	/* ML PPP BAP Restart timer */

			/* Start timer */

#define Mppp_c_prot_start_timer(xx)		\
			Timer_start (Mppp_c_prot_ti_id(xx), Mppp_c_prot_ti_val(xx),					\
						++(Mppp_c_prot_ti_sn(xx)), Mppp_c_prot_ti_ev_id(xx)); Mppp_c_prot_ti_state(xx) = ON

#define Mppp_c_prot_start_timer_val(xx,val) \
			Timer_start (Mppp_c_prot_ti_id(xx), val, ++(Mppp_c_prot_ti_sn(xx)),		\
						Mppp_c_prot_ti_ev_id(xx)); Mppp_c_prot_ti_state(xx) = ON

			/* Restart timer = start timer */

#define Mppp_c_prot_restart_timer(xx)	\
			Timer_start (Mppp_c_prot_ti_id(xx), Mppp_c_prot_ti_val(xx),						\
						++(Mppp_c_prot_ti_sn(xx)), Mppp_c_prot_ti_ev_id(xx)); Mppp_c_prot_ti_state(xx) = ON

			/* Stop timer */

#define Mppp_c_prot_stop_timer(xx)	\
			Timer_stop (Mppp_c_prot_ti_id(xx)); Mppp_c_prot_ti_state(xx) = OFF

			/* Timer state access */

#define Mppp_c_prot_state_timer(xx)		\
			Mppp_c_prot_ti_state(xx)

			/* Check timer event validity according to the sequence number */

#define Mppp_c_prot_valid_time_out(xx)		\
			((Mppp_c_prot_ti_state(xx) == ON) && (R_msg_inf0 == Mppp_c_prot_ti_sn (xx)))

#define Mppp_c_prot_ti_ev_id(xx)	MPPP_CP_TI_EV_ID[xx]	/* timer ID table */

/*-------------------------------------------------------------------------*/

		/*===================================================================

			Control Protocols Packets Codes.
			[RFC 1661]

			1- Configuation packets
				* Configure-Request
				* Configure-Ack
				* Configure-Nak
				* Configure-Reject
			2- Termination packets
				* Terminate-Request
				* Terminate-Ack
			3- Maintenance packets
				* Code-Reject
				* Protocol-Reject
				* Echo-Request
				* Echo-Reply
				* Discard-Request

			Additional LCP Packets [RFC 1570]
				* Identification
				* Time-Remaining

		====================================================================*/

#define MPPP_PPP_PCK_NIL				0

#define MPPP_CP_PCK_CONFIG_RQ			1
#define MPPP_CP_PCK_CONFIG_ACK			2
#define MPPP_CP_PCK_CONFIG_NAK			3
#define MPPP_CP_PCK_CONFIG_REJ			4

#define MPPP_CP_PCK_TERM_RQ				5
#define MPPP_CP_PCK_TERM_ACK			6

#define MPPP_CP_PCK_CODE_REJ			7

#define MPPP_CP_PCK_PROTOCOL_REJ		8
#define MPPP_CP_PCK_ECHO_RQ				9
#define MPPP_CP_PCK_ECHO_REPLY			10
#define MPPP_CP_PCK_DISCARD_RQ			11

#define MPPP_CP_PCK_IDENTIFICATION		12
#define MPPP_CP_PCK_TIME_REMAINING		13

		/*===================================================================

			Authentication Protocols Packets Codes.
			[RFC 1334] and [RFC 1994]

			1- PAP packets
				* Authenticate-Request
				* Authenticate-Ack
				* Authenticate-Nak

			2- CHAP packets
				* Challenge
				* Response
				* Success
				* Failure

		====================================================================*/

#define MPPP_CP_PCK_PAP_AUTH_RQ			1
#define MPPP_CP_PCK_PAP_AUTH_ACK		2
#define MPPP_CP_PCK_PAP_AUTH_NAK		3

#define MPPP_CP_PCK_CHAP_CHALLENGE		1
#define MPPP_CP_PCK_CHAP_RESPONSE		2
#define MPPP_CP_PCK_CHAP_SUCCESS		3
#define MPPP_CP_PCK_CHAP_FAILURE		4


		/*===================================================================

			Control Protocol Option Negotiation States.
			[RFC 1661]

			* Initial		[0]
			* Starting		[1]
			* Closed		[2]
			* Stopped		[3]
			* Closing		[4]
			* Stopping		[5]
			* Request-Sent	[6]
			* Ack-Received	[7]
			* Ack-Sent		[8]
			* Opened		[9]

		====================================================================*/

#define MPPP_CP_STATE_INITIAL				'0'
#define MPPP_CP_STATE_STARTING				'1'
#define MPPP_CP_STATE_CLOSED				'2'
#define MPPP_CP_STATE_STOPPED				'3'
#define MPPP_CP_STATE_CLOSING				'4'
#define MPPP_CP_STATE_STOPPING				'5'
#define MPPP_CP_STATE_REQUEST_SENT			'6'
#define MPPP_CP_STATE_ACK_RECEIVED			'7'
#define MPPP_CP_STATE_ACK_SENT				'8'
#define MPPP_CP_STATE_OPENED				'9'

			/* The following states ONLY exist on the first member link */

#define MPPP_CP_STATE_REQUEST_RECEIVED		'a'
#define MPPP_CP_STATE_TERM_RECEIVED			'b'

			/*
				The following states ONLY exist for Authentication Protocols
				PAP/CHAP 
				[RFC 1334] and [RFC 1994]
			*/

#define	MPPP_CP_STATE_AUTH_SENT				'c'
#define	MPPP_CP_STATE_AUTH_RECEIVED			'd'
#define	MPPP_CP_STATE_CHALLENGE_SENT		'e'
#define	MPPP_CP_STATE_CHALLENGE_RECEIVED	'f'
#define	MPPP_CP_STATE_RESPONSE_SENT			'g'
#define	MPPP_CP_STATE_RESPONSE_RECEIVED		'h'
#define	MPPP_CP_STATE_AUTH_SUCCESS			'i'
#define	MPPP_CP_STATE_AUTH_FAILURE			'j'

		/*===================================================================

			Control Protocol Option Negotiation Events.
			[RFC 1661]

			* Up
			* Down
			* Open
			* Close
			* Timeout
			* Receive-Configure-Request
			* Receive-Configure-Ack
			* Receive-Configure-Nak
			* Receive-Configure-Rej
			* Receive-Terminate-Request
			* Receive-Terminate-Ack
			* Receive-Unknown-Code
			* Receive-Code-Reject
			* Receive-Protocol-Reject
			* Receive-Echo-Request
			* Receive-Echo-Reply
			* Receive-Discard-Request

			Authentication (Control) Protocol Events.
			[RFC 1334] and [RFC 1994]

			=-=-=-= PAP events =-=-=-=
			* Receive-Authenticate-Request
			* Receive-Authenticate-Ack
			* Receive-Authenticate-Nak

			=-=-=-= CHAP events =-=-=-=
			* Receive-Challenge
			* Receive-Response
			* Receive-Success
			* Receive-Failure

		====================================================================*/

#define MPPP_CP_EV_NIL						EV_NIL

#define MPPP_CP_EV_UP						'A'
#define MPPP_CP_EV_DOWN						'B'
#define MPPP_CP_EV_OPEN						'C'
#define MPPP_CP_EV_CLOSE					'D'
#define MPPP_CP_EV_TIMEOUT					'E'
#define MPPP_CP_EV_RCV_CFG_RQ				'F'
#define MPPP_CP_EV_RCV_CFG_ACK				'G'
#define MPPP_CP_EV_RCV_CFG_NAK				'H'
#define MPPP_CP_EV_RCV_CFG_REJ				'I'
#define MPPP_CP_EV_RCV_TERM_RQ				'J'
#define MPPP_CP_EV_RCV_TERM_ACK				'K'
#define MPPP_CP_EV_RCV_UNKNOWN_CODE			'L'
#define MPPP_CP_EV_RCV_CODE_REJ				'M'
#define MPPP_CP_EV_RCV_PROTOCOL_REJ			'N'
#define MPPP_CP_EV_RCV_ECHO_RQ				'O'
#define MPPP_CP_EV_RCV_ECHO_REPLY			'P'
#define MPPP_CP_EV_RCV_DISCARD_RQ			'Q'

#define	MPPP_CP_EV_RCV_PAP_AUTH_RQ			'R'
#define	MPPP_CP_EV_RCV_PAP_AUTH_ACK			'S'
#define	MPPP_CP_EV_RCV_PAP_AUTH_NAK			'T'

#define	MPPP_CP_EV_RCV_CHAP_CHALLENGE		'U'
#define	MPPP_CP_EV_RCV_CHAP_RESPONSE		'V'
#define	MPPP_CP_EV_RCV_CHAP_SUCCESS			'W'
#define	MPPP_CP_EV_RCV_CHAP_FAILURE			'X'

		/*===================================================================

			Control Protocols Actions Functions and Context.
			This structure defines a set of entry points
			provided by each Control Protocol. It allows the use
			of a single finite state machine for all the Control
			Protocols we will support.

		====================================================================*/

#define MPPP_SZ_PROT_NAME	8	/* size of a protocol name string : "LCP", "BACP" ... */

struct mppp_c_prot {

	ushort			ppp_pid;		/* PPP Protocol ID field value */

	uchar			event;			/* last Control Protocol event */
	uchar			state;			/* Control Protocol state */

	uchar			s_packet_id;	/* sent (initiated) Control packet identifier */
	uchar			r_packet_id;	/* received Control packet identifier */

	uchar			s_packet_code;	/* sent (initiated) Control packet code */
	uchar			r_packet_code;	/* received Control packet code */

	uchar		FAR *p_data;		/* current pointer to frame data */
	ushort			data_size;		/* current frame data size */

	uchar			terminate_count;/* number of sent Terminate-Request */
	uchar			mx_terminate;	/* maximum number of consecutive Terminate-Request */
	uchar			configure_count;/* number of sent Configure-Request */
	uchar			mx_configure;	/* maximum number of consecutive Configure-Request */
	uchar			failure_count;	/* number of sent Configure-Nak */
	uchar			mx_failure;		/* maximum number of consecutive Configure-Nak */

	uchar			rej_flag;		/* ON --> send REJECT instead of NAK packet */

	struct timer	timer_table[MPPP_MX_CP_TIMER];	/* array of timers information */
	timer_val_t		timer_val_table[MPPP_MX_CP_TIMER];	/* array of timers values */
	char			name[MPPP_SZ_PROT_NAME+1];	/* protocol text name */

#	if NEW_FCT_STYLE == ON	/* { */

		void (* illegal_event)					(void);
		void (* this_layer_up)					(void);
		void (* this_layer_down)				(void);
		void (* this_layer_started)				(void);
		void (* this_layer_finished)			(void);
		void (* init_restart_counter)			(void);
		void (* zero_restart_counter)			(void);
		void (* send_configure_request)			(void);
		void (* send_configure_ack)				(void);
		void (* send_configure_nak_rej)			(void);
		void (* send_terminate_request)			(void);
		void (* send_terminate_ack)				(void);
		void (* send_code_reject)				(void);
		void (* send_echo_reply)				(void);
		uchar(* is_reject_fatal)				(void);
		uchar(* check_configure_request)		(void);
		uchar(* check_configure_ack_nak_rej)	(void);

#else

		void (* illegal_event)					();
		void (* this_layer_up)					();
		void (* this_layer_down)				();
		void (* this_layer_started)				();
		void (* this_layer_finished)			();
		void (* init_restart_counter)			();
		void (* zero_restart_counter)			();
		void (* send_configure_request)			();
		void (* send_configure_ack)				();
		void (* send_configure_nak_rej)			();
		void (* send_terminate_request)			();
		void (* send_terminate_ack)				();
		void (* send_code_reject)				();
		void (* send_echo_reply)				();
		uchar(* is_reject_fatal)				();
		uchar(* check_configure_request)		();
		uchar(* check_configure_ack_nak_rej)	();

#endif /* not NEW_FCT_STYLE } */

};


				/*
					Macros using the p_mppp_c_prot to access the
					Control Protocol context information
				*/

#define Mppp_c_prot_ppp_pid					p_mppp_c_prot -> ppp_pid

#define Mppp_c_prot_event					p_mppp_c_prot -> event
#define Mppp_c_prot_state					p_mppp_c_prot -> state

#define Mppp_c_prot_s_packet_id				p_mppp_c_prot -> s_packet_id
#define Mppp_c_prot_r_packet_id				p_mppp_c_prot -> r_packet_id
#define Mppp_c_prot_s_packet_code			p_mppp_c_prot -> s_packet_code
#define Mppp_c_prot_r_packet_code			p_mppp_c_prot -> r_packet_code

#define Mppp_c_prot_p_data					p_mppp_c_prot -> p_data
#define Mppp_c_prot_data_size				p_mppp_c_prot -> data_size

#define Mppp_c_prot_terminate_count			p_mppp_c_prot -> terminate_count
#define Mppp_c_prot_mx_terminate			p_mppp_c_prot -> mx_terminate
#define Mppp_c_prot_configure_count			p_mppp_c_prot -> configure_count
#define Mppp_c_prot_mx_configure			p_mppp_c_prot -> mx_configure
#define Mppp_c_prot_failure_count			p_mppp_c_prot -> failure_count
#define Mppp_c_prot_mx_failure				p_mppp_c_prot -> mx_failure

#define Mppp_c_prot_rej_flag				p_mppp_c_prot -> rej_flag

#define Mppp_c_prot_ti_state(xx)			p_mppp_c_prot -> timer_table[xx].state
#define Mppp_c_prot_ti_id(xx)				p_mppp_c_prot -> timer_table[xx].id
#define Mppp_c_prot_ti_sn(xx)				p_mppp_c_prot -> timer_table[xx].sn
#define Mppp_c_prot_ti_val(xx)				p_mppp_c_prot -> timer_val_table[xx]

#define Mppp_c_prot_name					p_mppp_c_prot -> name

					/* Actions functions macros */

#define Mppp_c_prot_illegal_event				(p_mppp_c_prot -> illegal_event)
#define Mppp_c_prot_this_layer_up				(p_mppp_c_prot -> this_layer_up)
#define Mppp_c_prot_this_layer_down				(p_mppp_c_prot -> this_layer_down)
#define Mppp_c_prot_this_layer_started			(p_mppp_c_prot -> this_layer_started)
#define Mppp_c_prot_this_layer_finished			(p_mppp_c_prot -> this_layer_finished)
#define Mppp_c_prot_init_restart_counter		(p_mppp_c_prot -> init_restart_counter)
#define Mppp_c_prot_zero_restart_counter		(p_mppp_c_prot -> zero_restart_counter)
#define Mppp_c_prot_send_configure_request		(p_mppp_c_prot -> send_configure_request)
#define Mppp_c_prot_send_configure_ack			(p_mppp_c_prot -> send_configure_ack)
#define Mppp_c_prot_send_configure_nak_rej		(p_mppp_c_prot -> send_configure_nak_rej)
#define Mppp_c_prot_send_terminate_request		(p_mppp_c_prot -> send_terminate_request)
#define Mppp_c_prot_send_terminate_ack			(p_mppp_c_prot -> send_terminate_ack)
#define Mppp_c_prot_send_code_reject			(p_mppp_c_prot -> send_code_reject)
#define Mppp_c_prot_send_echo_reply				(p_mppp_c_prot -> send_echo_reply)
#define Mppp_c_prot_is_reject_fatal				(p_mppp_c_prot -> is_reject_fatal)
#define Mppp_c_prot_check_configure_request		(p_mppp_c_prot -> check_configure_request)
#define Mppp_c_prot_check_configure_ack_nak_rej (p_mppp_c_prot -> check_configure_ack_nak_rej)

					/*
						Macro for setting the internal event ID associated
						to the current Control Protocol's packet code.
					*/

#define Mppp_set_c_prot_event(pck_code)		mppp_set_c_prot_event(pck_code)

					/* Macros, for setting the control protocol states */

#define Set_c_prot_state_initial			Mppp_c_prot_state = MPPP_CP_STATE_INITIAL
#define Set_c_prot_state_starting			Mppp_c_prot_state = MPPP_CP_STATE_STARTING
#define Set_c_prot_state_closed				Mppp_c_prot_state = MPPP_CP_STATE_CLOSED
#define Set_c_prot_state_stopped			Mppp_c_prot_state = MPPP_CP_STATE_STOPPED
#define Set_c_prot_state_closing			Mppp_c_prot_state = MPPP_CP_STATE_CLOSING
#define Set_c_prot_state_stopping			Mppp_c_prot_state = MPPP_CP_STATE_STOPPING
#define Set_c_prot_state_request_sent		Mppp_c_prot_state = MPPP_CP_STATE_REQUEST_SENT
#define Set_c_prot_state_ack_received		Mppp_c_prot_state = MPPP_CP_STATE_ACK_RECEIVED
#define Set_c_prot_state_ack_sent			Mppp_c_prot_state = MPPP_CP_STATE_ACK_SENT
#define Set_c_prot_state_opened				\
				{		\
					Mppp_c_prot_state = MPPP_CP_STATE_OPENED;	\
					if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {	\
						if (((Mppp_cep_ack_negot & LCP_NEG_AUTH) || (Mppp_cep_peer_ack_negot & LCP_NEG_AUTH))) {	\
							Sppp_cep_link_phase	= SPPP_LINK_PHASE_AUTHENTICATE;	\
						} else {	\
							Sppp_cep_link_phase	= SPPP_LINK_PHASE_NETWORK;	\
						}			\
					}			\
				}

					/*
						The following transition states are used
						ONLY for the first member link.
					*/

#define Set_c_prot_state_request_received	Mppp_c_prot_state = MPPP_CP_STATE_REQUEST_RECEIVED
#define Set_c_prot_state_term_received		Mppp_c_prot_state = MPPP_CP_STATE_TERM_RECEIVED

/*-----------------------------------------------------------------------*/

		/*===================================================================

			Authentication Protocols Actions Functions and Context.

		====================================================================*/

struct sppp_auth {
	uchar			active;			/* active context (ON/OFF) */
	uchar			event;			/* last Protocol event */
	uchar			state;			/* Control Protocol state */

	uchar			s_packet_id;	/* sent (initiated) packet identifier */
	uchar			r_packet_id;	/* received packet identifier */

	uchar			s_packet_code;	/* sent (initiated) packet code */
	uchar			r_packet_code;	/* received packet code */

	uchar		FAR *p_data;		/* current pointer to frame data */
	ushort			data_size;		/* current frame data size */

	uchar			count;			/* number of sent Authenticate-Request/Channelnge */
	uchar			mx_count;		/* maximum number of consecutive Authenticate-Request/Challenge */

	struct timer	timer_table[MPPP_MX_AUTH_TIMER];	/* timer information */
	timer_val_t		timer_val_table[MPPP_MX_AUTH_TIMER];/* timer value */

};


				/*
					Macros using the p_sppp_auth to access the
					Authentication Protocol context information
				*/

#define Sppp_auth_active				p_sppp_auth -> active
#define Sppp_auth_event					p_sppp_auth -> event
#define Sppp_auth_state					p_sppp_auth -> state

#define Sppp_auth_s_packet_id			p_sppp_auth -> s_packet_id
#define Sppp_auth_r_packet_id			p_sppp_auth -> r_packet_id
#define Sppp_auth_s_packet_code			p_sppp_auth -> s_packet_code
#define Sppp_auth_r_packet_code			p_sppp_auth -> r_packet_code

#define Sppp_auth_p_data				p_sppp_auth -> p_data
#define Sppp_auth_data_size				p_sppp_auth -> data_size

#define Sppp_auth_count					p_sppp_auth -> count
#define Sppp_auth_mx_count				p_sppp_auth -> mx_count

#define Sppp_auth_ti_state(xx)			p_sppp_auth -> timer_table[xx].state
#define Sppp_auth_ti_id(xx)				p_sppp_auth -> timer_table[xx].id
#define Sppp_auth_ti_sn(xx)				p_sppp_auth -> timer_table[xx].sn
#define Sppp_auth_ti_val(xx)			p_sppp_auth -> timer_val_table[xx]

					/*
						Macro for setting the internal event ID associated
						to the current Authentication Protocol's packet code.
					*/

#define Sppp_set_auth_event(pid,pck_code)			mppp_set_auth_event(pid,pck_code)
#define Sppp_set_auth_context(ev_code,f_user)		mppp_set_auth_context(ev_code,f_user)

					/*
						The following transition states are used
						ONLY for the Authentication Protocols (PAP/CHAP)
						(PAP/CHAP are also PPP Control Protocols)
					*/

#define	Set_auth_state_request_sent				Sppp_auth_state = MPPP_CP_STATE_AUTH_SENT
#define	Set_auth_state_request_received			Sppp_auth_state = MPPP_CP_STATE_AUTH_RECEIVED
#define	Set_auth_state_challenge_sent			Sppp_auth_state = MPPP_CP_STATE_CHALLENGE_SENT
#define	Set_auth_state_challenge_received		Sppp_auth_state = MPPP_CP_STATE_CHALLENGE_RECEIVED
#define	Set_auth_state_response_sent			Sppp_auth_state = MPPP_CP_STATE_RESPONSE_SENT
#define	Set_auth_state_response_received		Sppp_auth_state = MPPP_CP_STATE_RESPONSE_RECEIVED
#define	Set_auth_state_success					Sppp_auth_state = MPPP_CP_STATE_AUTH_SUCCESS
#define	Set_auth_state_failure					Sppp_auth_state = MPPP_CP_STATE_AUTH_FAILURE

/*-----------------------------------------------------------------------*/

			/* Local SAPIs used to distinguish received messages */

			/* From underlying entities */

#define MPPP_L_SAPI_ACU_MULTI_CHAN	'a'		/* SAPI for ACU Multi-chan messages */
#define MPPP_L_SAPI_DL_LAPB			'b'		/* SAPI for links using the DL_LAPB service */
#define MPPP_L_SAPI_ACU				'c'		/* SAPI for ACU messages */
#define MPPP_L_SAPI_DL_LAPD			'd'		/* SAPI for links using the DL_LAPD service */
#define MPPP_L_SAPI_ACU_MGT			'm'		/* SAPI for ACU Management messages*/
#define MPPP_L_SAPI_PH_B			'p'		/* SAPI for links using the PH-B service */
#define MPPP_L_SAPI_PH				'q'		/* SAPI for links using the PH service */
#define MPPP_L_SAPI_DL_V120			'v'		/* SAPI for links using the DL_V120 service */
#define MPPP_L_SAPI_X25				'x'		/* SAPI for links using the X25 service */

			/* From upper entities */

#define MPPP_L_SAPI_DATA_ASYN		'A'		/* SAPI for ASYN data transfer */
#define MPPP_L_SAPI_BAP				'B'		/* SAPI for BAP events */
#define MPPP_L_SAPI_DATA_SYNC		'D'		/* SAPI for SYNC data transfer */
#define MPPP_L_SAPI_EXT_EVENTS		'E'		/* SAPI for external commands from user entity */
#define MPPP_L_SAPI_SIG_MGT			'M'		/* SAPI for signalling (to Call Manager) */
#define MPPP_L_SAPI_CP				'P'		/* SAPI for Control Protocols messages */
#define MPPP_L_SAPI_SIG				'S'		/* SAPI for signalling (to Call Manager) */

			/* Macro for formatting the internal event */

#define Mppp_set_event(lsapi,code)	((ushort)(lsapi<<8)+(uchar)(code))

#define Mppp_get_lsapi(evt)		((sapi_t)(evt >> 8))

			/* MPPP message codes <--> CC/PH/DL/X25 message codes */

#define Mppp_code_from_cc_code(c)			(c)
#define Mppp_code_from_ph_code(c)			(c)
#define Mppp_code_from_dl_code(c)			(c)
#define Mppp_code_from_x25_code(c)			(c)

#define Mppp_cc_code_from_mppp_code(c)		(c)
#define Mppp_ph_code_from_mppp_code(c)		(c)
#define Mppp_dl_code_from_mppp_code(c)		(c)
#define Mppp_x25_code_from_mppp_code(c)		(c)

/*-----------------------------------------------------------------------*/

			/* Macro to copy all the message and buffer information */

#define Mppp_copy_msg_and_buffer(p_to,p_from)	mppp_copy_msg_and_buffer(p_to,p_from)

/*-----------------------------------------------------------------------*/

			/* Global ML PPP events types */

#define MPPP_EV_TYPE_BACP		'B'		/* BACP event type */
#define MPPP_EV_TYPE_BAP		'b'		/* BAP event type */
#define MPPP_EV_TYPE_LCP		'L'		/* LCP event type */
#define MPPP_EV_TYPE_MP			'M'		/* MP event type */
#define MPPP_EV_TYPE_MLCP		'U'		/* MLCP event type */
#define MPPP_EV_TYPE_CHAP		'C'		/* CHAP event type */
#define MPPP_EV_TYPE_PAP		'P'		/* PAP event type */

#define MPPP_EV_TYPE_SIGNALLING 'S'		/* signalling event type */

#define MPPP_EV_TYPE_OTHER		'O'		/* other events type */


/*--------------------------------------------------------------------------*/

			/* Queue complement structure */

struct mppp_queue_compl {
	struct message FAR	*p_sent;	/* last sent frame */
	uchar				 flag;		/* signal flag */
};


/*-----------------------------------------------------------------------*/

		/*
			LCP negotiation options usage bit mask.
			If a bit is set, then the corresponding
			LCP configuration option is negotiated.
		*/

#define LCP_NEG_MRU				0x0001	/* maximum receive unit */
#define LCP_NEG_ACCM			0x0002	/* async. control characters map */
#define LCP_NEG_AUTH			0x0004	/* authentication protocol */
#define LCP_NEG_LQM				0x0008	/* link quality monitoring protocol */

#define LCP_NEG_MAGIC			0x0010	/* magic number */
#define LCP_NEG_PFC				0x0020	/* protocol field compression */
#define LCP_NEG_ACFC			0x0040	/* address and control fields compression */
#define LCP_NEG_FCS				0x0080	/* FCS alternatives */

#define LCP_NEG_PADDING			0x0100	/* self-describing padding */
#define LCP_NEG_NUMBERED		0x0200	/* numbered mode */
#define LCP_NEG_CALLBACK		0x0400	/* callback */
#define LCP_NEG_COMPOUND		0x0800	/* compound frames */

#define LCP_NEG_MRRU			0x1000	/* multilink maximum received reconstructed unit */
#define LCP_NEG_SSNHF			0x2000	/* short sequence number header format */
#define LCP_NEG_EDO				0x4000	/* endpoint discriminator option */

#define LCP_NEG_LDO				0x8000	/* link discriminator option */


		/*
			BACP negotiation options usage bit mask.
			If a bit is set, then the corresponding
			BACP configuration option is negotiated.
		*/

#define BACP_NEG_FAVP			0x10000L	/* favored peer */

/*-----------------------------------------------------------------------*/

	/*
		The following structure contains LCP options applied to an
		individual link within the bundle.
	*/

struct sppp_lcp_opt {
	ulong		negot;			/* bit mask of selected options */
	ulong		magic;			/* Magic Number */
	ulong		accm;			/* Async-Character-Control-Map */

#	if MPPP_BAP == ON
		ulong	ldo;			/* Link discriminator option */
#	endif

#	if ((MPPP_LCP_EXTENSIONS == ON) && (MPPP_CALLBACK_PER_LINK == ON))

		struct sppp_lcp_opt_ext {
			uchar	callback_op;		/* CallBack operation */
			uchar	callback_msg_lgth;	/* CallBack message length */
			uchar	callback_msg[MPPP_MX_SZ_CALLBACK_MSG+1];	/* CallBack message */
		} lcp_ext;

#	endif

};

	/*
		The following structure contains CP options negotiated during
		the first PPP link establishment.
	*/

struct mppp_cp_opt {

	ulong			negot;			/* bit mask of selected options */

	struct _tag_lcp {

		ulong		accm;			/* ACCM */
		ulong		lqr_period;		/* Link Quality Report period */
		ulong		magic;			/* Magic Number */
		ushort		mru;			/* Max Receive Unit */
		ushort		mrru;			/* Multilink Max Receive Reconstructed Unit of the local PPP stack */
		ushort		auth;			/* Authentication protocol */
		uchar		chap_alg;		/* CHAP digest algorithm */
		ushort		lqm;			/* Link Quality Monitoring protocol */
		uchar		edo_class;		/* Endpoint discriminator option class */
		uchar		edo_add_lgth;	/* EDO address length */
		uchar		edo_add[MPPP_MX_SZ_EDO_ADD+1];	/* Endpoint discriminator option */

#		if MPPP_BAP == ON
			ulong	ldo;			/* Link discriminator option */
#		endif

	} _lcp;

#	if MPPP_LCP_EXTENSIONS == ON	/* { */

		struct _tag_lcp_ext {

			uchar	ext_usage;		/* LCP extensions usage (ON/OFF) */
			uchar	fcs_alt;		/* FCS alternatives */
			uchar	max_padding;	/* Maximum number of padding octets in a frame */

#			if MPPP_CALLBACK_PER_LINK == OFF

				uchar	callback_op;		/* CallBack operation */
				uchar	callback_msg_lgth;	/* CallBack message length */
				uchar	callback_msg[MPPP_MX_SZ_CALLBACK_MSG+1];	/* CallBack message */

#			endif

		} _lcp_ext;

#	endif	/* } */

#	if MPPP_BAP == ON	/* { */

		struct _tag_bacp {
			ulong	favp;			/* Favored-Peer value */
		} _bacp;

#	endif	/* } */


};	/* end of mppp_cp_opt structure */


/*-----------------------------------------------------------------------*/

					/* ML PPP : NETWORK ACCESS MANAGEMENT */

struct mppp_na {
	uchar	FAR *p_mem_blk; 	/* memory block allocated to the NA */
	nai_t		nai;			/* network access identifier */
	uchar		sap_nb;			/* number of declared SAP */
	uchar		active;			/* access status : set (ON) or stop (OFF) */
	uchar		system_state;	/* local system state : BUSY or FREE */
};

				/* Access to current NA value using p_mppp_na pointer */

#define Mppp_na_p_mem_blk				p_mppp_na -> p_mem_blk
#define Mppp_na_nai						p_mppp_na -> nai
#define Mppp_na_sap_nb					p_mppp_na -> sap_nb
#define Mppp_na_active					p_mppp_na -> active
#define Mppp_na_system_state			p_mppp_na -> system_state

/*-----------------------------------------------------------------------*/

					/* SL PPP : NETWORK ACCESS MANAGEMENT */

struct sppp_na {
	uchar	FAR *p_mem_blk; /* memory block allocated to the NA */
	nai_t		nai;		/* network access identifier */
	uchar		type;		/* network access type */
	uchar		cep_nb;	/* number of declared SAP/CEP */
	uchar		active;	/* access status : set (ON) or stop (OFF) */
};

				/* Access to current NA value using p_mppp_na pointer */

#define Sppp_na_p_mem_blk			p_sppp_na -> p_mem_blk
#define Sppp_na_nai					p_sppp_na -> nai
#define Sppp_na_type				p_sppp_na -> type
#define Sppp_na_cep_nb				p_sppp_na -> cep_nb
#define Sppp_na_active				p_sppp_na -> active

/*-----------------------------------------------------------------------*/

			/* SL PPP : Single Link PPP context */

struct sppp_cep {
	uchar					ref;			/* UNIQUE reference value */
	uchar					link_type;		/* link type */
	ulong					link_speed;		/* link speed in kbps */
	uchar					link_mode;		/* link mode (SYNC, ASYNC) */
	uchar					link_phase;		/* PPP link phase */
	uchar					link_drop_rq_flag;	/* PPP link DROP requested (ON/OFF) */
	uchar					link_add_rq_flag;	/* PPP link ADD requested (ON/OFF) */

	struct queue_mgt		tx_data_queue;	/* PPP data frames Tx queue */

	struct sppp_cc_info {
		ent_id_t			entity_id;		/* underlying entity for signalling */
		nai_t				nai;			/* NAI for signalling */
		sapi_t				sapi;			/* SAPI for signalling */
		sapi_t				sapi_mgt;		/* SAPI for signalling Maganement */
		add_t				conn_id;		/* connection ID for signalling */
		uchar				state;			/* connection state */
	} cc_info;

	struct sppp_data_info {
		ent_id_t			entity_id;		/* underlying entity for data transfer */
		nai_t				nai;			/* NAI for data transfer */
		sapi_t				sapi;			/* SAPI for data transfer */
		add_t				conn_id;		/* DL CES or PH CHANI for data transfer */
		add_t				chani;			/* channel ID */
		uchar				state;			/* data channel state */
		uchar				hole_size;		/* additional hole in data message */
		uchar				check_flags;	/* checking of PPP frame FLAG and FCS */
		uchar				out_busy_flag;	/* outgoing flow control busy flag (ON/OFF) */

		uchar				be;				/* beging end flag */
		mppp_modulo_t		rx_mvr;			/* latest fragment received on the member link */

		struct queue_mgt	tx_qu_tab;		/* member link Tx waiting queue */

		struct message FAR *p_msg;			/* current message pointer */




		long				tx_byte_count;	/* Tx byte count */
		long				tx_frame_count; /* Tx frame count */

		uchar				rcv_frame_state;	/* current state of received frame */
		uchar				ass_frame_escape;	/* asynchronous PPP assembling frame ESCAPE character saved */
		ushort				ass_frame_fcs;		/* asynchronous PPP assembling frame FCS storage */
		struct message FAR *ass_frame_p_msg;	/* asynchronous PPP assembling frame message pointer */
	} data_info;


		/* Reverse pointer to the bundle objects */

	struct mppp_na	FAR		*_p_mppp_na;	/* pointer to the ML PPP's NA */
	struct mppp_sap FAR		*_p_mppp_sap;	/* pointer to the ML PPP's SAP */
	struct mppp_cep FAR		*_p_mppp_cep;	/* pointer to the ML PPP's CEP */

	struct sppp_lcp_opt		ack;			/* LCP options we ack'd */
	struct sppp_lcp_opt		peer_ack;		/* LCP options the peer ack'd */

	struct mppp_c_prot		lcp_info;		/* LCP Control Protocol context */

	struct sppp_auth		local_auth_info;	/* PAP/CHAP Control Protocols context (we are the authenticator) */
	struct sppp_auth		peer_auth_info;		/* PAP/CHAP Control Protocols context (the peer is the authenticator) */

	struct sppp_cep		FAR *p_next;		/* pointer to the next SL PPP in the bundle */

};


		/* Access macros to SL PPP context using p_sppp_cep pointer */

#define Sppp_cep_ref				p_sppp_cep -> ref
#define Sppp_cep_link_type			p_sppp_cep -> link_type
#define Sppp_cep_link_speed			p_sppp_cep -> link_speed
#define Sppp_cep_link_mode			p_sppp_cep -> link_mode
#define Sppp_cep_link_phase			p_sppp_cep -> link_phase
#define Sppp_cep_link_drop_rq_flag	p_sppp_cep -> link_drop_rq_flag
#define Sppp_cep_link_add_rq_flag	p_sppp_cep -> link_add_rq_flag

#define Sppp_cep_tx_data_p_first	p_sppp_cep -> tx_data_queue.p_first
#define Sppp_cep_tx_data_p_last		p_sppp_cep -> tx_data_queue.p_last

#define Sppp_cep_cc_entity_id		p_sppp_cep -> cc_info.entity_id
#define Sppp_cep_cc_nai				p_sppp_cep -> cc_info.nai
#define Sppp_cep_cc_sapi			p_sppp_cep -> cc_info.sapi
#define Sppp_cep_cc_sapi_mgt		p_sppp_cep -> cc_info.sapi_mgt
#define Sppp_cep_cc_conn_id			p_sppp_cep -> cc_info.conn_id
#define Sppp_cep_cc_state			p_sppp_cep -> cc_info.state

#define Sppp_cep_data_entity_id		p_sppp_cep -> data_info.entity_id
#define Sppp_cep_data_nai			p_sppp_cep -> data_info.nai
#define Sppp_cep_data_sapi			p_sppp_cep -> data_info.sapi
#define Sppp_cep_data_conn_id		p_sppp_cep -> data_info.conn_id
#define Sppp_cep_data_chani			p_sppp_cep -> data_info.chani
#define Sppp_cep_data_state			p_sppp_cep -> data_info.state
#define Sppp_cep_data_hole_size		p_sppp_cep -> data_info.hole_size
#define Sppp_cep_data_check_flags	p_sppp_cep -> data_info.check_flags
#define Sppp_cep_data_out_busy		p_sppp_cep -> data_info.out_busy_flag

#define Sppp_cep_data_be				p_sppp_cep -> data_info.be
#define Sppp_cep_data_p_msg				p_sppp_cep -> data_info.p_msg
#define Sppp_cep_data_rx_mvr			p_sppp_cep -> data_info.rx_mvr

#define Sppp_cep_data_tx_first			p_sppp_cep -> data_info.tx_qu_tab.p_first
#define Sppp_cep_data_tx_last			p_sppp_cep -> data_info.tx_qu_tab.p_last

#define Sppp_cep_data_tx_byte_count		p_sppp_cep -> data_info.tx_byte_count
#define Sppp_cep_data_tx_frame_count	p_sppp_cep -> data_info.tx_frame_count

#define Sppp_cep_rcv_frame_state		p_sppp_cep -> data_info.rcv_frame_state
#define Sppp_cep_ass_frame_p_msg		p_sppp_cep -> data_info.ass_frame_p_msg
#define Sppp_cep_ass_frame_fcs			p_sppp_cep -> data_info.ass_frame_fcs
#define Sppp_cep_ass_frame_escape		p_sppp_cep -> data_info.ass_frame_escape

#define Sppp_cep_p_mppp_na				p_sppp_cep -> _p_mppp_na
#define Sppp_cep_p_mppp_sap				p_sppp_cep -> _p_mppp_sap
#define Sppp_cep_p_mppp_cep				p_sppp_cep -> _p_mppp_cep

		/* Access to LCP options we ack'd */

#define Sppp_cep_ack					p_sppp_cep -> ack
#define Sppp_cep_ack_negot				p_sppp_cep -> ack.negot
#define Sppp_cep_ack_magic				p_sppp_cep -> ack.magic
#define Sppp_cep_ack_accm				p_sppp_cep -> ack.accm

#if MPPP_BAP == ON
#	define Sppp_cep_ack_ldo				p_sppp_cep -> ack.ldo
#endif

#if ((MPPP_LCP_EXTENSIONS == ON) && (MPPP_CALLBACK_PER_LINK == ON))
#	define Sppp_cep_ack_callback_op			p_sppp_cep -> ack.lcp_ext.callback_op
#	define Sppp_cep_ack_callback_msg_lgth	p_sppp_cep -> ack.lcp_ext.callback_msg_lgth
#	define Sppp_cep_ack_callback_msg		p_sppp_cep -> ack.lcp_ext.callback_msg
#endif

		/* Access to LCP options the peer ack'd */

#define Sppp_cep_peer_ack				p_sppp_cep -> peer_ack
#define Sppp_cep_peer_ack_negot			p_sppp_cep -> peer_ack.negot
#define Sppp_cep_peer_ack_magic			p_sppp_cep -> peer_ack.magic
#define Sppp_cep_peer_ack_accm			p_sppp_cep -> peer_ack.accm

#if MPPP_BAP == ON
#	define Sppp_cep_peer_ack_ldo		p_sppp_cep -> peer_ack.ldo
#endif

#if ((MPPP_LCP_EXTENSIONS == ON) && (MPPP_CALLBACK_PER_LINK == ON))
#	define Sppp_cep_peer_ack_callback_op		p_sppp_cep -> peer_ack.lcp_ext.callback_op
#	define Sppp_cep_peer_ack_callback_msg_lgth	p_sppp_cep -> peer_ack.lcp_ext.callback_msg_lgth
#	define Sppp_cep_peer_ack_callback_msg		p_sppp_cep -> peer_ack.lcp_ext.callback_msg
#endif

#define Sppp_cep_lcp_info			(p_sppp_cep -> lcp_info)
#define Sppp_cep_p_lcp_info			((struct mppp_c_prot FAR *)&(p_sppp_cep -> lcp_info))

#define Sppp_cep_local_auth_info	(p_sppp_cep -> local_auth_info)
#define Sppp_cep_p_local_auth_info	((struct sppp_auth FAR *)&(p_sppp_cep -> local_auth_info))

#define Sppp_cep_peer_auth_info		(p_sppp_cep -> peer_auth_info)
#define Sppp_cep_p_peer_auth_info	((struct sppp_auth FAR *)&(p_sppp_cep -> peer_auth_info))

#define Sppp_cep_p_next				p_sppp_cep -> p_next

#define Sppp_set_cc_state(state)	Sppp_cep_cc_state=state


		/* Reset of CP options we Ack'd */

#define Sppp_cep_reset_ack_cp_opt()		\
			{						\
				Memset_far ((char FAR *)&(Sppp_cep_ack), 0, sizeof (struct sppp_lcp_opt));	\
				Sppp_cep_p_peer_auth_info->active = OFF;			\
				Sppp_cep_p_peer_auth_info->count  = Sppp_cep_p_peer_auth_info->mx_count;			\
				if (Sppp_cep_link_mode == SPPP_MODE_SYNC) {			\
					Sppp_cep_ack_accm = LCP_SYNC_ACCM_I;			\
				} else {											\
					Sppp_cep_ack_accm = LCP_ASYNC_ACCM_I;			\
				}													\
			}


		/* Reset of CP options the peer Ack'd */

#define Sppp_cep_reset_peer_ack_cp_opt()	\
			{				\
				Memset_far ((char FAR *)&(Sppp_cep_peer_ack), 0, sizeof (struct sppp_lcp_opt));	\
				Sppp_cep_p_local_auth_info->active = OFF;				\
				Sppp_cep_p_local_auth_info->count  = Sppp_cep_p_local_auth_info->mx_count;			\
				if (Sppp_cep_link_mode == SPPP_MODE_SYNC) {				\
					Sppp_cep_peer_ack_accm = LCP_SYNC_ACCM_I;			\
				} else {												\
					Sppp_cep_peer_ack_accm = LCP_ASYNC_ACCM_I;			\
				}														\
			}

/*-----------------------------------------------------------------------*/

				/* ML PPP : SERVICE ACCESS POINT (Upper layer's view) */

struct mppp_sap {

	uchar						cep_nb;				/* number of declared CEP */

	struct sig_info {
		sapi_t					sapi;				/* service access point identifier */
		sapi_t					sapi_mgt;			/* service access point identifier for management */
		ent_id_t				upper_entity_id;	/* upper entity identifier */
	} sig;

	struct data_info {
		sapi_t					sapi;				/* service access point identifier */
		ent_id_t				upper_entity_id;	/* upper entity identifier */
		uchar					ui;					/* ON = UI only */
		ushort					no_split_max_size;	/* max size of packet not slpitted */
		ushort					split_flag;			/* split flag : ON or OFF */

		mppp_modulo_t			modulo;				/* modulo */
		mppp_modulo_t			w;					/* parameter : windowing size transmitter */
		mppp_modulo_t			x;					/* parameter : guard size transmitter */
		uchar					header_size;		/* parameter : header size */
		uchar					congestion_mgt;		/* congestion flag : ON --> congestion management */

#		if MPPP_FC == ON
			uchar				out_fc_low_mark;	/* outgoing flow control low mark */
			uchar				out_fc_high_mark;	/* outgoing flow control high mark */
#		endif

	} data;

};

			/* Access to current SAP values using p_mppp_sap pointer */

#define Mppp_sap_cep_nb						p_mppp_sap -> cep_nb

#define Mppp_sap_sig_sapi					p_mppp_sap -> sig.sapi
#define Mppp_sap_sig_sapi_mgt				p_mppp_sap -> sig.sapi_mgt
#define Mppp_sap_sig_upper_entity_id		p_mppp_sap -> sig.upper_entity_id

#define Mppp_sap_data_sapi					p_mppp_sap -> data.sapi
#define Mppp_sap_data_upper_entity_id		p_mppp_sap -> data.upper_entity_id

#define Mppp_sap_data_ui					p_mppp_sap -> data.ui
#define Mppp_sap_data_no_split_max_size		p_mppp_sap -> data.no_split_max_size
#define Mppp_sap_data_split_flag			p_mppp_sap -> data.split_flag

#define Mppp_sap_data_modulo				p_mppp_sap -> data.modulo
#define Mppp_sap_data_w						p_mppp_sap -> data.w
#define Mppp_sap_data_x						p_mppp_sap -> data.x
#define Mppp_sap_data_header_size			p_mppp_sap -> data.header_size

#define Mppp_sap_data_congestion_mgt		p_mppp_sap -> data.congestion_mgt

#if MPPP_FC == ON
#	define Mppp_sap_data_out_fc_low_mark	p_mppp_sap -> data.out_fc_low_mark
#	define Mppp_sap_data_out_fc_high_mark	p_mppp_sap -> data.out_fc_high_mark
#endif


/*-----------------------------------------------------------------------*/

		/* Message direction */

#define	MPPP_FROM_LOCAL_USER		'L'		/* message from local user */
#define	MPPP_FROM_PEER				'P'		/* message from the peer system */
#define	MPPP_FROM_OTHER				'O'		/* message from other source */

/*-----------------------------------------------------------------------*/

		/* ML PPP : CONNECTION END POINT (Upper layer's view) */

#ifndef	MPPP_MX_LCP_OPT_NB
#	define	MPPP_MX_LCP_OPT_NB		25		/* maximum number of LCP options in a packet */
#endif

struct mppp_cep {
							/* IDENTIFICATION */

	add_t					ces;					/* connection endpoint suffix */

						/* CONNECTION state */

	uchar					fragment_state;			/* Fragment current state */
	uchar					own_receiver_state;		/* receiver busy */
	uchar					remote_receiver_state;	/* remote busy */
	uchar					commit_rq;				/* pending commitment to upper layer */

	uchar					msg_direction;			/* message direction : FROM_LOCAL_USER, FROM_PEER, FROM_OTHER */

#	if MPPP_FC == ON
		uchar				out_fc_state;			/* outgoing flow control state : FREE or BUSY */
		uchar				out_fc_mark;			/* outgoing flow control current mark */
#	endif

	mppp_modulo_t			mvs;					/* send state variable MV (S) */
	mppp_modulo_t			mvt;					/* acknowledge state variable MV (T) */
	mppp_modulo_t			mvr;					/* receive state variable MV (R) */
	uchar					sig_state;				/* ML PPP CEP signalling state */
	uchar					data_state;				/* ML PPP CEP data channel state */
	uchar					upper_layer_initiated;	/* flag upper layer initiated */
	uchar					auto_open_flag;			/* flag indicating AUTOMATIC OPEN event from upper entity */
	uchar					open_rq_flag;			/* flag indicating receipt of OPEN event from upper entity */
	uchar					close_rq_flag;			/* flag indicating receipt of CLOSE event from upper entity */

	struct queue_mgt		tx_qu_tab;				/* Tx waiting queue I */
	struct mppp_queue_compl	tx_qu_compl;			/* Tx complement information to the queue management */
	struct queue_mgt		rx_qu_tab;				/* Rx waiting queue I */
	struct queue_mgt		rx_faq;					/* Rx frame assembly queue */

	struct _tag_chap_info {
		sppp_ref_t			link_ref;				/* Link to be used for Response */
		uchar				state;					/* CHAP Authentication state at bundle level */
		struct queue_mgt	chall_qu;				/* CHAP Challenge waiting queue */
	} chap_info;


#	if MPPP_BAP == ON

		struct mppp_c_prot	bacp_info;		/* BACP Control Protocols contexts */
		struct mppp_c_prot	bap_info;		/* BAP Control Protocols contexts */

#	endif

		/*
			Multilink Protocol Indicators

			mp_enabled:	ON	--> MP sucessfully negotiated
						OFF --> MP not negotiated or negotiation failed

			mp_rejected:ON	--> MP rejected. Do not propose it again
						OFF --> MP not rejected

			edo_rejected:ON	 --> EDO rejected. Do not propose it again
						 OFF --> EDO not rejected

			ssnhf_rejected:	ON	--> SSNHF rejected. Do not propose it again
							OFF --> SSNHF not rejected

		*/

	struct _tag_mp_flags {
		uchar				mp_enabled;			/* MP enabled (ON/OFF) */
		uchar				mp_rejected;		/* MP rejected by the peer (ON/OFF) */
		uchar				edo_rejected;		/* EDO rejected by the peer (ON/OFF) */
		uchar				ssnhf_rejected;		/* SSNHF rejected by the peer (ON/OFF) */
	} _mp_flags;

#	if MPPP_BAP == ON

		struct _tag_bacp_data {
			uchar			bacp_enabled;		/* BACP enabled (ON/OFF) */
			uchar			bacp_rejected;		/* BACP rejected by the peer (ON/OFF) */
			uchar			favored_peer;		/* Favored-Peer indicator (ON/OFF) */
		} _bacp_data;

		struct _tag_bap_data {
			uchar			no_phone_number;	/* Use of no phone number option (ON/OFF) in BAP packets */
			uchar			reason_lgth;		/* BAP reason length */
			uchar	FAR		*p_reason;			/* address of the BAP reason string */
		} _bap_data;

#	endif

	struct _tag_frag_info {
		uchar				first_frag_received;/* ON -> received 1st fragment in this bundle */
		uchar				frag_pfc;			/* ON -> received a fragment with protocol field compressed */
		uchar				first_frag_pfc;		/* ON -> first fragment with protocol field compressed */
		uchar				frag_acfc;			/* ON -> received a fragment with address/control fields compressed */
	} _frag_info;

	struct saved_conn_rq {
		struct message		FAR *p_msg_conn_rq; 			/* copy of the initial ACU_CONN_RQ message */
		uchar				FAR *p_first_other_called_nb;	/* pointer to the current 'other' called number */
		uchar				FAR *p_current_other_called_nb;	/* pointer to the first 'other' called number */
	} conn_rq_info;

		/* LCP options from the configuration data */

	ushort					min_mrru;		/* Minimum MRRU we allow */
	ushort					mrru;			/* MRRU we negotiate */
	uchar					bacp_usage;		/* usage of Bandwidth Allocation Control Protocol (ON/OFF) */
	uchar					edo_usage;		/* usage of Endpoint discriminator option class */
	uchar					lcp_ext_usage;	/* LCP extensions usage (ON/OFF) */
	uchar					edo_class;		/* Endpoint discriminator option class */
	uchar					edo_add_lgth;	/* Endpoint discriminator option length */
	uchar					edo_add[MPPP_MX_SZ_EDO_ADD+1];	/* Endpoint discriminator address */
	uchar					mp_disabled;	/* Multilink Protocol disabled (ON/OFF) */

	uchar					rcv_lcp_opt_nb;		/* number of LCP options received from the peer in Configure-Request */
	uchar					rcv_lcp_opt_tab[MPPP_MX_LCP_OPT_NB];	/* array of the original ordered LCP options from the peer */

#	if ((MPPP_LCP_EXTENSIONS == ON) && (MPPP_CALLBACK_PER_LINK == OFF))	/* { */

		struct mppp_cep_lcp_ext {
			uchar			callback_op;		/* CallBack operation */
			uchar			callback_msg_lgth;	/* CallBack message length */
			uchar			callback_msg[MPPP_MX_SZ_CALLBACK_MSG+1];	/* CallBack message */
		} lcp_ext;

#	endif	/* } */

	ulong					accm_to_local;	/* ACCM used when SENDING data to the local PPP stack */
	ulong					accm_to_peer;	/* ACCM used when SENDING data to the peer system */

		/* CP options we ack'd */

	struct mppp_cp_opt		ack;

		/* CP options the peer ack'd */

	struct mppp_cp_opt		peer_ack;

		/* PAP username and password to replay */

	uchar					username_lgth;
	uchar					username[MPPP_MX_SZ_USERNAME+1];
	uchar					password_lgth;
	uchar					password[MPPP_MX_SZ_PASSWORD+1];

		/* Single Link PPP connections */

	uchar					sppp_nb;				/* current number of SL PPP's in the ML PPP */
	uchar					min_sppp_nb;			/* minimum number of SL PPP's required */
	uchar					used_sppp_nb;			/* current number of SL PPP's in use */
	uchar					opened_sppp_nb;			/* current number of SL PPP's in OPENED state */
	uchar					busy_sppp_nb;			/* current number of SL PPP's in BUSY state */
	ulong					sppp_total_link_speed;	/* current total speed in kbps */

		/* List of SL PPP references */

	sppp_ref_t				sppp_ref_tab[MPPP_MX_SPPP];

	struct sppp_queue_mgt	sppp_list_head;			/* head of the list of SL PPPs part if this bundle */

};


			/* Access to current CEP values using p_mppp_cep pointer */

#define Mppp_cep_ces						p_mppp_cep -> ces

#define Mppp_cep_fragment_state				p_mppp_cep -> fragment_state
#define Mppp_cep_own_receiver_state			p_mppp_cep -> own_receiver_state
#define Mppp_cep_remote_receiver_state		p_mppp_cep -> remote_receiver_state
#define Mppp_cep_commit_rq					p_mppp_cep -> commit_rq

#define Mppp_cep_msg_direction				p_mppp_cep -> msg_direction

#if MPPP_FC == ON
#	define Mppp_cep_out_fc_mark				p_mppp_cep -> out_fc_mark
#	define Mppp_cep_out_fc_state			p_mppp_cep -> out_fc_state
#endif

#define Mppp_cep_mvs						p_mppp_cep -> mvs
#define Mppp_cep_mvt						p_mppp_cep -> mvt
#define Mppp_cep_mvr						p_mppp_cep -> mvr
#define Mppp_cep_sig_state					p_mppp_cep -> sig_state
#define Mppp_cep_data_state					p_mppp_cep -> data_state

#define Mppp_cep_upper_layer_initiated		p_mppp_cep -> upper_layer_initiated
#define Mppp_cep_auto_open_flag				p_mppp_cep -> auto_open_flag
#define Mppp_cep_open_rq_flag				p_mppp_cep -> open_rq_flag
#define Mppp_cep_close_rq_flag				p_mppp_cep -> close_rq_flag

#define Mppp_cep_tx_first					p_mppp_cep -> tx_qu_tab.p_first
#define Mppp_cep_tx_last					p_mppp_cep -> tx_qu_tab.p_last
#define Mppp_cep_tx_sent					p_mppp_cep -> tx_qu_compl.p_sent
#define Mppp_cep_rx_first					p_mppp_cep -> rx_qu_tab.p_first
#define Mppp_cep_rx_last					p_mppp_cep -> rx_qu_tab.p_last
#define Mppp_cep_rx_faq_first				p_mppp_cep -> rx_faq.p_first
#define Mppp_cep_rx_faq_last				p_mppp_cep -> rx_faq.p_last

#define Mppp_cep_chap_link_ref				p_mppp_cep -> chap_info.link_ref
#define Mppp_cep_chap_state					p_mppp_cep -> chap_info.state
#define Mppp_cep_chap_first					p_mppp_cep -> chap_info.chall_qu.p_first
#define Mppp_cep_chap_last					p_mppp_cep -> chap_info.chall_qu.p_last

#define Mppp_cep_mp_enabled					p_mppp_cep -> _mp_flags.mp_enabled
#define Mppp_cep_mp_rejected				p_mppp_cep -> _mp_flags.mp_rejected
#define Mppp_cep_edo_rejected				p_mppp_cep -> _mp_flags.edo_rejected
#define Mppp_cep_ssnhf_rejected				p_mppp_cep -> _mp_flags.ssnhf_rejected

#if MPPP_BAP == ON	/* { */

#	define Mppp_cep_bacp_enabled			p_mppp_cep -> _bacp_data.bacp_enabled
#	define Mppp_cep_bacp_rejected			p_mppp_cep -> _bacp_data.bacp_rejected
#	define Mppp_cep_bacp_favored_peer		p_mppp_cep -> _bacp_data.favored_peer

#	define Mppp_cep_bap_no_phone_number		p_mppp_cep -> _bap_data.no_phone_number
#	define Mppp_cep_bap_reason_lgth			p_mppp_cep -> _bap_data.reason_lgth
#	define Mppp_cep_bap_p_reason			p_mppp_cep -> _bap_data.p_reason

#endif	/* MPPP_BAP == ON } */

#define Mppp_cep_first_frag_received		p_mppp_cep -> _frag_info.first_frag_received
#define Mppp_cep_frag_pfc					p_mppp_cep -> _frag_info.frag_pfc
#define Mppp_cep_first_frag_pfc				p_mppp_cep -> _frag_info.first_frag_pfc
#define Mppp_cep_frag_acfc					p_mppp_cep -> _frag_info.frag_acfc

#define Mppp_cep_p_msg_conn_rq				p_mppp_cep -> conn_rq_info.p_msg_conn_rq
#define Mppp_cep_p_first_other_called_nb	p_mppp_cep -> conn_rq_info.p_first_other_called_nb
#define Mppp_cep_p_current_other_called_nb	p_mppp_cep -> conn_rq_info.p_current_other_called_nb

#define Mppp_cep_min_mrru					p_mppp_cep -> min_mrru
#define Mppp_cep_mrru						p_mppp_cep -> mrru
#define Mppp_cep_edo_usage					p_mppp_cep -> edo_usage
#define Mppp_cep_bacp_usage					p_mppp_cep -> bacp_usage
#define Mppp_cep_lcp_ext_usage				p_mppp_cep -> lcp_ext_usage
#define Mppp_cep_edo_class					p_mppp_cep -> edo_class
#define Mppp_cep_edo_add_lgth				p_mppp_cep -> edo_add_lgth
#define Mppp_cep_edo_add					p_mppp_cep -> edo_add

#define Mppp_cep_mp_disabled				p_mppp_cep -> mp_disabled

#define Mppp_cep_rcv_lcp_opt_nb				p_mppp_cep -> rcv_lcp_opt_nb
#define Mppp_cep_rcv_lcp_opt_tab(xx)		p_mppp_cep -> rcv_lcp_opt_tab[xx]

#if MPPP_LCP_EXTENSIONS == ON
#	define Mppp_cep_callback_op				p_mppp_cep -> lcp_ext.callback_op
#	define Mppp_cep_callback_msg_lgth		p_mppp_cep -> lcp_ext.callback_msg_lgth
#	define Mppp_cep_callback_msg			p_mppp_cep -> lcp_ext.callback_msg
#endif

#define Mppp_cep_accm_to_local				p_mppp_cep -> accm_to_local
#define Mppp_cep_accm_to_peer				p_mppp_cep -> accm_to_peer


		/* Access to LCP options we ack'd */

#define Mppp_cep_ack					p_mppp_cep -> ack
#define Mppp_cep_ack_negot				p_mppp_cep -> ack.negot
#define Mppp_cep_ack_accm				p_mppp_cep -> ack._lcp.accm
#define Mppp_cep_ack_magic				p_mppp_cep -> ack._lcp.magic
#define Mppp_cep_ack_mru				p_mppp_cep -> ack._lcp.mru
#define Mppp_cep_ack_mrru				p_mppp_cep -> ack._lcp.mrru
#define Mppp_cep_ack_auth				p_mppp_cep -> ack._lcp.auth
#define Mppp_cep_ack_chap_alg			p_mppp_cep -> ack._lcp.chap_alg
#define Mppp_cep_ack_lqm				p_mppp_cep -> ack._lcp.lqm
#define Mppp_cep_ack_lqr_period			p_mppp_cep -> ack._lcp.lqr_period
#define Mppp_cep_ack_edo_class			p_mppp_cep -> ack._lcp.edo_class
#define Mppp_cep_ack_edo_add_lgth		p_mppp_cep -> ack._lcp.edo_add_lgth
#define Mppp_cep_ack_edo_add			p_mppp_cep -> ack._lcp.edo_add

#if MPPP_BAP == ON
#	define Mppp_cep_ack_ldo				p_mppp_cep -> ack._lcp.ldo
#endif

#if MPPP_LCP_EXTENSIONS == ON	/* { */

#	define Mppp_cep_ack_fcs_alt				p_mppp_cep -> ack._lcp_ext.fcs_alt
#	define Mppp_cep_ack_max_padding			p_mppp_cep -> ack._lcp_ext.max_padding

#	if MPPP_CALLBACK_PER_LINK == OFF	/* { */
#		define Mppp_cep_ack_callback_op			p_mppp_cep -> ack._lcp_ext.callback_op
#		define Mppp_cep_ack_callback_msg_lgth	p_mppp_cep -> ack._lcp_ext.callback_msg_lgth
#		define Mppp_cep_ack_callback_msg		p_mppp_cep -> ack._lcp_ext.callback_msg_lgth
#	endif	/* } */

#endif	/* } */


#if MPPP_BAP == ON /* { */
#	define Mppp_cep_ack_favp			p_mppp_cep -> ack._bacp.favp
#endif	/* } */


#if MPPP_BAP == ON	/* { */

#	define Mppp_cep_reset_ack_cp_opt()		\
			{	\
				Memset_far ((char FAR *)&(Mppp_cep_ack), 0, sizeof (struct mppp_cp_opt));	\
				Mppp_cep_ack_favp	= BACP_CALLED_PARTY_FAVP_I;	\
			}

#else	/* } { */

#	define Mppp_cep_reset_ack_cp_opt()		\
			{	\
				Memset_far ((char FAR *)&(Mppp_cep_ack), 0, sizeof (struct mppp_cp_opt));	\
			}

#endif	/* } */


		/* Access to LCP options the peer ack'd */

#define Mppp_cep_peer_ack				p_mppp_cep -> peer_ack
#define Mppp_cep_peer_ack_negot			p_mppp_cep -> peer_ack.negot
#define Mppp_cep_peer_ack_magic			p_mppp_cep -> peer_ack._lcp.magic
#define Mppp_cep_peer_ack_accm			p_mppp_cep -> peer_ack._lcp.accm
#define Mppp_cep_peer_ack_mru			p_mppp_cep -> peer_ack._lcp.mru
#define Mppp_cep_peer_ack_mrru			p_mppp_cep -> peer_ack._lcp.mrru
#define Mppp_cep_peer_ack_auth			p_mppp_cep -> peer_ack._lcp.auth
#define Mppp_cep_peer_ack_chap_alg		p_mppp_cep -> peer_ack._lcp.chap_alg
#define Mppp_cep_peer_ack_lqm			p_mppp_cep -> peer_ack._lcp.lqm
#define Mppp_cep_peer_ack_lqr_period	p_mppp_cep -> peer_ack._lcp.lqr_period
#define Mppp_cep_peer_ack_edo_class		p_mppp_cep -> peer_ack._lcp.edo_class
#define Mppp_cep_peer_ack_edo_add_lgth	p_mppp_cep -> peer_ack._lcp.edo_add_lgth
#define Mppp_cep_peer_ack_edo_add		p_mppp_cep -> peer_ack._lcp.edo_add

#if MPPP_BAP == ON
#	define Mppp_cep_peer_ack_ldo		p_mppp_cep -> peer_ack._lcp.ldo
#endif

#if MPPP_LCP_EXTENSIONS == ON	/* { */

#	define Mppp_cep_peer_ack_fcs_alt			p_mppp_cep -> peer_ack._lcp_ext.fcs_alt
#	define Mppp_cep_peer_ack_max_padding		p_mppp_cep -> peer_ack._lcp_ext.max_padding

#	if MPPP_CALLBACK_PER_LINK == OFF	/* { */
#		define Mppp_cep_peer_ack_callback_op		p_mppp_cep -> peer_ack._lcp_ext.callback_op
#		define Mppp_cep_peer_ack_callback_msg_lgth	p_mppp_cep -> peer_ack._lcp_ext.callback_msg_lgth
#		define Mppp_cep_peer_ack_callback_msg		p_mppp_cep -> peer_ack._lcp_ext.callback_msg_lgth
#	endif	/* } */

#endif	/* } */

#if MPPP_BAP == ON /* { */
#	define Mppp_cep_peer_ack_favp		p_mppp_cep -> peer_ack._bacp.favp
#endif	/* } */

#if MPPP_BAP == ON	/* { */

#	define Mppp_cep_reset_peer_ack_cp_opt()	\
			{	\
				Memset_far ((char FAR *)&(Mppp_cep_peer_ack), 0, sizeof (struct mppp_cp_opt));	\
				Mppp_cep_peer_ack_favp	= BACP_CALLING_PARTY_FAVP_I;	\
			}

#else

#	define Mppp_cep_reset_peer_ack_cp_opt()	\
			{	\
				Memset_far ((char FAR *)&(Mppp_cep_peer_ack), 0, sizeof (struct mppp_cp_opt));	\
			}

#endif	/* } */


#if MPPP_BAP == ON
#	define Mppp_cep_bacp_info				(p_mppp_cep -> bacp_info)
#	define Mppp_cep_p_bacp_info				((struct mppp_c_prot FAR *)&(p_mppp_cep -> bacp_info))
#	define Mppp_cep_bap_info				(p_mppp_cep -> bap_info)
#	define Mppp_cep_p_bap_info				((struct mppp_c_prot FAR *)&(p_mppp_cep -> bap_info))
#endif

#define	Mppp_cep_username_lgth				p_mppp_cep -> username_lgth
#define	Mppp_cep_p_username					&(p_mppp_cep -> username[0])
#define	Mppp_cep_password_lgth				p_mppp_cep -> password_lgth
#define	Mppp_cep_p_password					&(p_mppp_cep -> password[0])

#define Mppp_cep_sppp_nb					p_mppp_cep -> sppp_nb
#define Mppp_cep_min_sppp_nb				p_mppp_cep -> min_sppp_nb
#define Mppp_cep_used_sppp_nb				p_mppp_cep -> used_sppp_nb
#define Mppp_cep_opened_sppp_nb				p_mppp_cep -> opened_sppp_nb
#define Mppp_cep_busy_sppp_nb				p_mppp_cep -> busy_sppp_nb

#define Mppp_cep_sppp_total_link_speed		p_mppp_cep -> sppp_total_link_speed

#define Mppp_cep_sppp_ref_tab(xx)			p_mppp_cep -> sppp_ref_tab[xx]

#define Mppp_cep_sppp_list_head				p_mppp_cep -> sppp_list_head

		/* This macro checks if the current entry is the first in the bundle */

#define Is_sppp_first_in_bundle()			((p_sppp_cep != P_NIL) && (p_sppp_cep == Mppp_cep_sppp_list_head.p_first))

#define	Mppp_link_mode_accm(mode)			((Sppp_cep_link_mode == SPPP_MODE_SYNC) ? \
												LCP_SYNC_ACCM_I : LCP_ASYNC_ACCM_I)

/*-----------------------------------------------------------------------*/

					/*
						TRAP MANAGEMENT
					*/


					/*
						TRAP code : trap function is called if and inconsistancy
						   is detected inside the sofware, generally due
						   to a bug. Trap function must freeze the
						   situation and dump it to some permanent support
						   in order to fix the bug.
					*/


#define TRAP_MPPP_ERROR				900		/* general purpose Trap code */
#define TRAP_MPPP_RET_CODE			901		/* unknown return code */
#define TRAP_MPPP_TIMER_CODE		902		/* unknown timer message code */
#define TRAP_MPPP_NULL_POINTER		903		/* unexpected null pointer */
#define TRAP_MPPP_NO_HOLE			904		/* no hole in message or buffer */
#define TRAP_MPPP_QUEUE_CHECK		905		/* inconsistency in the MP queue */
#define TRAP_MPPP_COUNTER			906		/* Byte Counter error */
#define TRAP_MPPP_P_MSG				907		/* unexpected value of message pointer */
#define TRAP_MPPP_ENTITY_FROM		908		/* unknown origination entity code */
#define TRAP_MPPP_NO_CONTEXT		909		/* unexpected null context pointer */
#define TRAP_MPPP_EVENT_ID			910		/* unexpected or unknown event ID */
#define TRAP_MPPP_BUNDLE_CHECK		911		/* inconsistent information in the bundle context */
#define TRAP_MPPP_UNKNOWN_VAL		912		/* unexpected unknown value */

/*-----------------------------------------------------------------------*/

					/* FUNCTION DECLARATIONS */

#if NEW_FCT_STYLE == ON /* { */

		/* Main functions */

	uchar	mppp_config							(struct mppp_config FAR *p_mppp_cfg);
	uchar	mppp_config_sl_ppp					(struct sppp_config FAR *p_sppp_cfg);
	uchar	mppp_config_ml_ppp					(struct mppp_config FAR *p_mppp_cfg);
	uchar	mppp_reset_config					(nai_t nai);
	uchar	mppp_c_prot_initialize				(struct mppp_c_prot FAR *p_pr, struct mppp_cfg_cep FAR *p_cfg);
	uchar	mppp_auth_initialize				(struct sppp_auth FAR *p_pr, struct mppp_cfg_cep FAR *p_cfg);

		/* Access functions */

	uchar	mppp_access_object					(uchar type, nai_t nai, sapi_t sapi, add_t ces);
	uchar	mppp_access_na						(nai_t nai);
	void	mppp_access_first_na				(void);
	void	mppp_access_next_na					(void);
	void	mppp_access_first_sap				(void);
	void	mppp_access_next_sap				(void);
	void	mppp_access_first_cep				(void);
	void	mppp_access_next_cep				(void);

	uchar	mppp_access_sppp_na					(nai_t nai);
	void	mppp_access_first_sppp_na			(void);
	void	mppp_access_next_sppp_na			(void);
	void	mppp_access_first_sppp_cep			(void);
	void	mppp_access_next_sppp_cep			(void);
	uchar	mppp_access_sppp_cc_object			(uchar acc_type, ent_id_t entity, nai_t nai, sapi_t sapi, add_t cid);
	uchar	mppp_access_sppp_data_object		(ent_id_t entity, nai_t nai, sapi_t sapi, add_t cid);
	uchar	mppp_access_sppp_ref				(sppp_ref_t ref);

	void	mppp_access_first_sppp_in_bundle	(void);
	void	mppp_access_next_sppp_in_bundle		(void);

	uchar	mppp_build_object					(struct mppp_config FAR *p_mppp_config);
	uchar	mppp_build_sl_ppp_object			(struct sppp_config FAR *p_sppp_config);
	uchar	mppp_build_ml_ppp_object			(struct mppp_config FAR *p_mppp_config);

		/* process function */

	uchar	mppp_rcv							(void);

	uchar	mppp_rcv_cc							(void);
	uchar	mppp_rcv_ph							(void);
	uchar	mppp_rcv_dl							(void);
	uchar	mppp_rcv_x25						(void);

	void	mppp_process						(void);
	void	mppp_state_proc						(void);
	void	mppp_state_signalling				(void);
	void	mppp_c_prot_state_machine			(void);
	void	mppp_c_prot_update_bandwidth		(uchar was_opened);
	void	mppp_c_prot_send_pap_auth_request	(void);
	void	mppp_auth_state_machine				(ushort prot_id);
	void	mppp_set_c_prot_event				(uchar pck_code);
	void	mppp_set_auth_event					(ushort prot_id, uchar pck_code);
	void	mppp_set_auth_context				(code_t ev_code, uchar f_user);
	uchar	mppp_dispatch_frame					(uchar FAR * FAR *pp_data, ushort FAR *p_size, uchar from_user);
	ushort	mppp_prepare_packet_to_send			(ushort prot_id, uchar pck_code, uchar pck_id, uchar FAR *p_start, ushort data_size);
	uchar	mppp_copy_msg_and_buffer			(struct message FAR *p_msg_to, struct message FAR *p_msg_from);

	struct	message FAR *mppp_sync_to_async		(struct message FAR *p_msg_in, ulong accm_map, uchar hole_size, uchar add_flags);
	struct	message FAR *mppp_async_to_sync		(void);

	void	mppp_act_dea_lower_layer			(ent_id_t ent_to, uchar act_flag);
	void	mppp_busy_to_lower_layer			(ent_id_t ent_to, uchar busy_flag);
	uchar	mppp_make_cc_call_rq				(void);
	uchar	mppp_clear_cc_call_rq				(void);

	uchar	mppp_save_conn_rq_info				(struct message FAR *p_msg_conn_rq);

	void	mppp_process_sm_msg					(void);
	void	mppp_process_ti_msg					(void);
	uchar	mppp_process_ext_events				(void);
	uchar	mppp_check_link_busy				(void);

	void	mppp_process_pending_tx				(void);
	void	mppp_process_pending_sppp_tx		(void);

	void	mppp_reset_mp_flags					(void);
	void	mppp_reset_chap_info				(void);

	void	bap_state_proc						(void);

		/* Queue management */


	void	mppp_in_sppp_tx_queue				(void);
	uchar	mppp_out_sppp_tx_queue				(void);
	void	mppp_discard_sppp_tx_queue			(void);
	void	mppp_check_sppp_tx_queue			(void);

	void	mppp_in_chap_queue					(void);
	uchar	mppp_out_chap_queue					(void);
	void	mppp_discard_chap_queue				(void);

		/* Send */

	void	mppp_snd							(ent_id_t ent_id, code_t code);
	uchar	mppp_snd_data_msg_to_peer			(ent_id_t ent_id, ulong accm_map);
	void	mppp_snd_data_msg_to_local			(ent_id_t ent_id, ulong accm_map);
	void	mppp_snd_msg_to_user				(ent_id_t ent_id, sapi_t sapi, code_t code);
	void	mppp_snd_error_in					(mppp_cause_t cause_val, mppp_diag_t diag_val, sapi_t sapi);
	void	mppp_snd_ext_add_link_in_co			(code_t ev_code);
	void	mppp_snd_ext_drop_link_in_co		(code_t ev_code, mppp_cause_t cause_val, mppp_diag_t diag_val, uchar drop_origin);
	void	mppp_retransmit						(code_t code, ent_id_t ent_id);

#	if MPPP_AUDIT == ON
		void	mppp_audit_in					(void);
#	endif

		/* Simulation functions */

#	if MPPP_SIM_ANALYSER == ON
		void	pr_mppp_object					(void);
		void	pr_mppp_state					(void);
#	endif

#else	/* Not NEW_FCT_STYLE */


		/* Main functions */

	uchar	mppp_config							();
	uchar	mppp_config_sl_ppp					();
	uchar	mppp_config_ml_ppp					();
	uchar	mppp_reset_config					();
	uchar	mppp_c_prot_initialize				();
	uchar	mppp_auth_initialize				();

		/* Access functions */

	uchar	mppp_access_object					();
	uchar	mppp_access_na						();
	void	mppp_access_first_na				();
	void	mppp_access_next_na					();
	void	mppp_access_first_sap				();
	void	mppp_access_next_sap				();
	void	mppp_access_first_cep				();
	void	mppp_access_next_cep				();

	uchar	mppp_access_sppp_na					();
	void	mppp_access_first_sppp_na			();
	void	mppp_access_next_sppp_na			();
	void	mppp_access_first_sppp_cep			();
	void	mppp_access_next_sppp_cep			();
	uchar	mppp_access_sppp_cc_object			();
	uchar	mppp_access_sppp_data_object		();

	uchar	mppp_access_sppp_ref				();

	void	mppp_access_first_sppp_in_bundle	();
	void	mppp_access_next_sppp_in_bundle		();

	uchar	mppp_build_object					();
	uchar	mppp_build_sl_ppp_object			();
	uchar	mppp_build_ml_ppp_object			();

		/* process function */

	uchar	mppp_rcv							();

	uchar	mppp_rcv_cc							();
	uchar	mppp_rcv_ph							();
	uchar	mppp_rcv_dl							();
	uchar	mppp_rcv_x25						();

	void	mppp_process						();
	void	mppp_state_proc						();
	void	mppp_state_signalling				();
	void	mppp_c_prot_state_machine			();
	void	mppp_c_prot_update_bandwidth		();
	void	mppp_c_prot_send_pap_auth_request	();
	void	mppp_auth_state_machine				();
	void	mppp_set_c_prot_event				();
	void	mppp_set_auth_event					();
	void	mppp_set_auth_context				();
	uchar	mppp_dispatch_frame					();
	ushort	mppp_prepare_packet_to_send			();
	uchar	mppp_copy_msg_and_buffer			();

	struct	message FAR *mppp_sync_to_async		();
	struct	message FAR *mppp_async_to_sync		();

	void	mppp_act_dea_lower_layer			();
	void	mppp_busy_to_lower_layer			();
	uchar	mppp_make_cc_call_rq				();
	uchar	mppp_clear_cc_call_rq				();

	uchar	mppp_save_conn_rq_info				();

	void	mppp_process_sm_msg					();
	void	mppp_process_ti_msg					();
	uchar	mppp_process_ext_events				();
	uchar	mppp_check_link_busy				();

	void	mppp_process_pending_tx				();
	void	mppp_process_pending_sppp_tx		();

	void	mppp_reset_mp_flags					();
	void	mppp_reset_chap_info				();

	void	bap_state_proc						();

		/* Queue management */

	void	mppp_in_sppp_tx_queue				();
	uchar	mppp_out_sppp_tx_queue				();
	void	mppp_discard_sppp_tx_queue			();
	void	mppp_check_sppp_tx_queue			();

	void	mppp_in_chap_queue					();
	uchar	mppp_out_chap_queue					();
	void	mppp_discard_chap_queue				();

		/* Send */

	void	mppp_snd							();
	uchar	mppp_snd_data_msg_to_peer			();
	void	mppp_snd_data_msg_to_local			();
	void	mppp_snd_msg_to_user				();
	void	mppp_snd_error_in					();
	void	mppp_snd_ext_add_link_in_co			();
	void	mppp_snd_ext_drop_link_in_co		();
	void	mppp_retransmit						();

#	if MPPP_AUDIT == ON
		void	mppp_audit_in					();
#	endif

		/* Simulation functions */

#	if MPPP_SIM_ANALYSER == ON
		void	pr_mppp_object					();
		void	pr_mppp_state					();
#	endif

#endif	/* not NEW_FCT_STYLE } */

/*-----------------------------------------------------------------------*/

#endif	/* _MPPP_H } */

/*EOF*/

