
/*--------------------------------------------------------------------------*
 *						 M O D U L E   H E A D E R
 *
 * filename - lcp_sta.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s) : state driven automaton
 *		- lcp_xxx routines implement the processing of an event according
 *			to the LCP automaton state.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    Multi Link PPP Entity                            |*/
/*|    Link Control Protocol                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1997 by OMNITEL SA                 |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/


#include "mppp.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#include "mppp_ext.h"
#include "lcp.h"		/* LCP definitions */


/*-------------------------------------------------------------------------*/

			/* Local functions prototypes */

#if NEW_FCT_STYLE == ON
	uchar	lcp_check_configure_ack		(void);
	uchar	lcp_check_configure_nak		(void);
	uchar	lcp_check_configure_rej		(void);
#else
	uchar	lcp_check_configure_ack		();
	uchar	lcp_check_configure_nak		();
	uchar	lcp_check_configure_rej		();
#endif

/*-------------------------------------------------------------------------*/

		/*
			The following macros are used in this way:

			Lcp_opt_REQ_xxx	loads an option in a Configure-Request
							packet to be sent

			Lcp_opt_ACK_xxx	checks an option present in a received
							Configure-Ack packet.
							ML PPP specific options are removed from
							the original Configure-Ack packet

			Lcp_opt_NAK_xxx	checks an option present in a received
							Configure-Nak packet

			Lcp_opt_REJ_xxx	checks an option present in a received
							Configure-Rej packet

		*/

		/*-=-=-=-=-=-= MRU Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_MRU(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MRU) {	\
						Mppp_put_char(LCP_OPT_MRU, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_SHORT,_p_curr);	\
						Mppp_put_short(_val,_p_curr);				\
					}												\
				}

#define Lcp_opt_ACK_MRU(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MRU) {	\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_MRU)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								if (opt_val_ushort != _val) {		\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_MRU(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MRU) {	\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_MRU)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_MRU);	\
							} else {								\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
					}												\
				}

#define Lcp_opt_REJ_MRU(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MRU) {	\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_MRU)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								if (opt_val_ushort != _val) {		\
									goto opt_rej_error;				\
								}									\
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_MRU);	\
							} else {								\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
					}												\
				}

		/*-=-=-=-=-=-= ACCM Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_ACCM(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACCM) {	\
						Mppp_put_char(LCP_OPT_ACCM, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_LONG,_p_curr);		\
						Mppp_put_long(_val,_p_curr);				\
					}												\
				}

#define Lcp_opt_ACK_ACCM(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACCM) {	\
						if ((pack_lgth -= LCP_OPT_SZ_LONG) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LONG) && (opt_type == LCP_OPT_ACCM)) {	\
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								if (opt_val_ulong != _val) {		\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_ACCM(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACCM) {	\
						if ((pack_lgth -= LCP_OPT_SZ_LONG) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LONG) && (opt_type == LCP_OPT_ACCM)) {	\
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_ACCM); \
							} else {								\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
					}												\
				}

#define Lcp_opt_REJ_ACCM(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACCM) {	\
						if ((pack_lgth -= LCP_OPT_SZ_LONG) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LONG) && (opt_type == LCP_OPT_ACCM)) {	\
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								if (opt_val_ulong != _val) {		\
									goto opt_rej_error;				\
								}									\
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_ACCM); \
							} else {								\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
					}												\
				}

		/*-=-=-=-=-=-= AUTH Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_AUTH(_p_curr,_val1,_val2)						\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_AUTH) {	\
						if (_val1 == PPP_PROT_CHAP) {				\
							Mppp_put_char(LCP_OPT_AUTH, _p_curr);	\
							Mppp_put_char(LCP_OPT_SZ_CHAP,_p_curr); \
							Mppp_put_short(_val1,_p_curr);			\
							Mppp_put_char(_val2,_p_curr);			\
						}											\
						if (_val1 == PPP_PROT_PAP) {				\
							Mppp_put_char(LCP_OPT_AUTH, _p_curr);	\
							Mppp_put_char(LCP_OPT_SZ_SHORT,_p_curr);\
							Mppp_put_short(_val1,_p_curr);			\
						}											\
					}												\
				}

#define Lcp_opt_ACK_AUTH(_p_curr,_val1,_val2)						\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_AUTH) {	\
						if (_val1 == PPP_PROT_CHAP) {				\
							if ((pack_lgth -=  LCP_OPT_SZ_CHAP) >= 0) { \
								Mppp_get_char(opt_type,_p_curr);	\
								Mppp_get_char(opt_lgth,_p_curr);	\
								if ((opt_lgth == LCP_OPT_SZ_CHAP) && (opt_type == LCP_OPT_AUTH)) {	\
									Mppp_get_short(opt_val_ushort,_p_curr); \
									Mppp_get_char(opt_val_uchar,_p_curr);	\
									if ((opt_val_ushort != _val1) || (opt_val_uchar != _val2)) {	\
										goto opt_ack_error;			\
									}								\
								} else {							\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						}											\
						if (_val1 == PPP_PROT_PAP) {				\
							if ((pack_lgth -=  LCP_OPT_SZ_SHORT) >= 0) {	\
								Mppp_get_char(opt_type,_p_curr);	\
								Mppp_get_char(opt_lgth,_p_curr);	\
								if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_AUTH)) { \
									Mppp_get_short(opt_val_ushort,_p_curr); \
									if (opt_val_ushort != _val1) {	\
										goto opt_ack_error;			\
									}								\
								} else {							\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						}											\
					}												\
				}

#define Lcp_opt_NAK_AUTH(_p_curr,_val1,_val2)						\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_AUTH) {	\
						if (_val1 == PPP_PROT_CHAP) {				\
							if ((pack_lgth -=  LCP_OPT_SZ_CHAP) >= 0) { \
								Mppp_get_char(opt_type,_p_curr);	\
								Mppp_get_char(opt_lgth,_p_curr);	\
								if ((opt_lgth == LCP_OPT_SZ_CHAP) && (opt_type == LCP_OPT_AUTH)) {	\
									Mppp_get_short(opt_val_ushort,_p_curr); \
									Mppp_get_char(opt_val_uchar,_p_curr);	\
									Mppp_cep_peer_ack_negot &= (~LCP_NEG_AUTH); \
								} else {							\
									goto opt_nak_error;				\
								}									\
							} else {								\
								goto opt_nak_error;					\
							}										\
						}											\
						if (_val1 == PPP_PROT_PAP) {				\
							if ((pack_lgth -=  LCP_OPT_SZ_SHORT) >= 0) {	\
								Mppp_get_char(opt_type,_p_curr);	\
								Mppp_get_char(opt_lgth,_p_curr);	\
								if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_AUTH)) { \
									Mppp_get_short(opt_val_ushort,_p_curr); \
									Mppp_cep_peer_ack_negot &= (~LCP_NEG_AUTH); \
								} else {							\
									goto opt_nak_error;				\
								}									\
							} else {								\
								goto opt_nak_error;					\
							}										\
						}											\
					}												\
				}

#define Lcp_opt_REJ_AUTH(_p_curr,_val1,_val2)						\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_AUTH) {	\
						if (_val1 == PPP_PROT_CHAP) {				\
							if ((pack_lgth -=  LCP_OPT_SZ_CHAP) >= 0) { \
								Mppp_get_char(opt_type,_p_curr);	\
								Mppp_get_char(opt_lgth,_p_curr);	\
								if ((opt_lgth == LCP_OPT_SZ_CHAP) && (opt_type == LCP_OPT_AUTH)) {	\
									Mppp_get_short(opt_val_ushort,_p_curr); \
									Mppp_get_char(opt_val_uchar,_p_curr);	\
									if ((opt_val_ushort != _val1) || (opt_val_uchar != _val2)) {	\
										goto opt_rej_error;			\
									}								\
									Mppp_cep_peer_ack_negot &= (~LCP_NEG_AUTH); \
								} else {							\
									goto opt_rej_error;				\
								}									\
							} else {								\
								goto opt_rej_error;					\
							}										\
						}											\
						if (_val1 == PPP_PROT_PAP) {				\
							if ((pack_lgth -=  LCP_OPT_SZ_SHORT) >= 0) {	\
								Mppp_get_char(opt_type,_p_curr);	\
								Mppp_get_char(opt_lgth,_p_curr);	\
								if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_AUTH)) { \
									Mppp_get_short(opt_val_ushort,_p_curr); \
									if (opt_val_ushort != _val1) {	\
										goto opt_rej_error;			\
									}								\
									Mppp_cep_peer_ack_negot &= (~LCP_NEG_AUTH); \
								} else {							\
									goto opt_rej_error;				\
								}									\
							} else {								\
								goto opt_rej_error;					\
							}										\
						}											\
					}												\
				}

		/*-=-=-=-=-=-= LQM Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_LQM(_p_curr,_val1,_val2)						\
				{													\
					if ((Mppp_cep_peer_ack_negot & LCP_NEG_LQM) && (_val1 == PPP_PROT_LQR)) { \
						Mppp_put_char(LCP_OPT_LQM, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_LQR,_p_curr);		\
						Mppp_put_short(_val1,_p_curr);				\
						Mppp_put_long(_val2,_p_curr);				\
					}												\
				}

#define Lcp_opt_ACK_LQM(_p_curr,_val1,_val2)						\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_LQM) {	\
						if ((_val1 == PPP_PROT_LQR) && ((pack_lgth -= LCP_OPT_SZ_LQR) >= 0)) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LQR) && (opt_type == LCP_OPT_LQM)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								if ((opt_val_ulong != _val1) || (opt_val_ulong != _val2)) {		\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_LQM(_p_curr,_val1,_val2)						\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_LQM) {	\
						if ((_val1 == PPP_PROT_LQR) && ((pack_lgth -= LCP_OPT_SZ_LQR) >= 0)) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LQR) && (opt_type == LCP_OPT_LQM)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_LQM);	\
							} else {								\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
					}												\
				}

#define Lcp_opt_REJ_LQM(_p_curr,_val1,_val2)						\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_LQM) {	\
						if ((_val1 == PPP_PROT_LQR) && ((pack_lgth -= LCP_OPT_SZ_LQR) >= 0)) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LQR) && (opt_type == LCP_OPT_LQM)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_LQM);	\
							} else {								\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
					}												\
				}

		/*-=-=-=-=-=-= MAGIC Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_MAGIC(_p_curr,_val)							\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MAGIC) {	\
						Mppp_put_char(LCP_OPT_MAGIC, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_LONG,_p_curr);		\
						Mppp_put_long(_val,_p_curr);				\
					}												\
				}

#define Lcp_opt_ACK_MAGIC(_p_curr,_val)							\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MAGIC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_LONG) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LONG) && (opt_type == LCP_OPT_MAGIC)) { \
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								if (opt_val_ulong != _val) {		\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_MAGIC(_p_curr,_val)							\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MAGIC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_LONG) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LONG) && (opt_type == LCP_OPT_MAGIC)) { \
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								if (opt_val_ulong != _val) {		\
									goto opt_nak_error;				\
								}									\
							} else {								\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
					}												\
				}

#define Lcp_opt_REJ_MAGIC(_p_curr,_val)							\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MAGIC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_LONG) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_LONG) && (opt_type == LCP_OPT_MAGIC)) { \
								Mppp_get_long(opt_val_ulong,_p_curr);	\
								if (opt_val_ulong != _val) {		\
									goto opt_rej_error;				\
								}									\
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_MAGIC);	\
							} else {								\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
					}												\
				}

		/*-=-=-=-=-=-= PFC Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_PFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_PFC) {	\
						Mppp_put_char(LCP_OPT_PFC, _p_curr);			\
						Mppp_put_char(LCP_OPT_SZ_NULL,_p_curr);		\
					}												\
				}

#define Lcp_opt_ACK_PFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_PFC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_PFC)) {	\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_PFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_PFC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_PFC)) {	\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
						Mppp_cep_peer_ack_negot &= (~LCP_NEG_PFC);	\
					}												\
				}

#define Lcp_opt_REJ_PFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_PFC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_PFC)) {	\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
						Mppp_cep_peer_ack_negot &= (~LCP_NEG_PFC);	\
					}												\
				}

		/*-=-=-=-=-=-= ACFC Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_ACFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACFC) {	\
						Mppp_put_char(LCP_OPT_ACFC, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_NULL,_p_curr);		\
					}												\
				}

#define Lcp_opt_ACK_ACFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACFC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_ACFC)) {	\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_ACFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACFC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_ACFC)) {	\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
						Mppp_cep_peer_ack_negot &= (~LCP_NEG_ACFC); \
					}												\
				}

#define Lcp_opt_REJ_ACFC(_p_curr)									\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_ACFC) {	\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_ACFC)) {	\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
						Mppp_cep_peer_ack_negot &= (~LCP_NEG_ACFC); \
					}												\
				}

		/*-=-=-=-=-=-= MRRU Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_MRRU(_p_curr,_val)								\
				{													\
					if ((Mppp_cep_mp_disabled == OFF) && (Mppp_cep_peer_ack_negot & LCP_NEG_MRRU) && (Mppp_cep_mp_rejected == OFF)) {	\
						Mppp_put_char(LCP_OPT_MRRU, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_SHORT,_p_curr);	\
						Mppp_put_short(_val,_p_curr);				\
					}												\
				}

#define Lcp_opt_ACK_MRRU(_p_curr,_val)								\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MRRU) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							_p_no = (uchar FAR *)(_p_co+LCP_OPT_SZ_SHORT);		\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_MRRU)) { \
								Mppp_get_short(opt_val_ushort,_p_curr); \
								if (opt_val_ushort != _val) {		\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
							Memcpy_far ((char FAR *)_p_co,			\
										(char FAR *)_p_no,			\
										(uint)(_p_end-_p_no));		\
							_p_curr = _p_co;						\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_MRRU(_p_curr,_val)								\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MRRU) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							_p_no = (uchar FAR *)(_p_co+LCP_OPT_SZ_SHORT);		\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_MRRU)) { \
								Mppp_get_short(opt_val_ushort,_p_curr); \
								if ((opt_val_ushort <= LCP_MRRU_I) && (opt_val_ushort <= _val)) {	\
									Mppp_cep_peer_ack_mrru	= opt_val_ushort;	\
								} else {							\
									goto opt_nak_error;				\
								}									\
							} else {								\
								goto opt_nak_error;					\
							}										\
							Memcpy_far ((char FAR *)_p_co,			\
										(char FAR *)_p_no,			\
										(uint)(_p_end-_p_no));		\
							_p_curr = _p_co;						\
						} else {									\
							goto opt_nak_error;						\
						}											\
					}												\
				}

#define Lcp_opt_REJ_MRRU(_p_curr,_val)								\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_MRRU) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							_p_no = (uchar FAR *)(_p_co+LCP_OPT_SZ_SHORT);		\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_MRRU)) { \
								Mppp_get_short(opt_val_ushort,_p_curr); \
								if (opt_val_ushort == _val) {	\
									Mppp_cep_peer_ack_negot &= (~LCP_NEG_MRRU); \
									Mppp_cep_mp_enabled = OFF;		\
									Mppp_cep_mp_rejected = ON;	\
								} else {							\
									goto opt_rej_error;				\
								}									\
							} else {								\
								goto opt_rej_error;					\
							}										\
							Memcpy_far ((char FAR *)_p_co,			\
										(char FAR *)_p_no,			\
										(uint)(_p_end-_p_no));		\
							_p_curr = _p_co;						\
						} else {									\
							goto opt_rej_error;						\
						}											\
					}												\
				}

		/*-=-=-=-=-=-= SSNHF Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_SSNHF(_p_curr)										\
				{														\
					if ((Mppp_cep_mp_disabled == OFF) && 				\
						(Mppp_cep_mp_rejected == OFF) &&				\
						(Mppp_cep_ssnhf_rejected == OFF) &&				\
						(Mppp_cep_peer_ack_negot & LCP_NEG_SSNHF)) {	\
						Mppp_put_char(LCP_OPT_SSNHF, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_NULL,_p_curr);		\
					}												\
				}

#define Lcp_opt_ACK_SSNHF(_p_curr)									\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_SSNHF) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							_p_no = (uchar FAR *)(_p_co+LCP_OPT_SZ_NULL);		\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_SSNHF)) { \
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
						Memcpy_far ((char FAR *)_p_co,				\
									(char FAR *)_p_no,				\
									(uint)(_p_end-_p_no));			\
						_p_curr = _p_co;							\
					}												\
				}

#define Lcp_opt_NAK_SSNHF(_p_curr)									\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_SSNHF) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							_p_no = (uchar FAR *)(_p_co+LCP_OPT_SZ_NULL);		\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_SSNHF)) { \
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
						Memcpy_far ((char FAR *)_p_co,				\
									(char FAR *)_p_no,				\
									(uint)(_p_end-_p_no));			\
						_p_curr = _p_co;							\
						Mppp_cep_peer_ack_negot &= (~LCP_NEG_SSNHF);	\
					}												\
				}

#define Lcp_opt_REJ_SSNHF(_p_curr)									\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_SSNHF) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= LCP_OPT_SZ_NULL) >= 0) {	\
							_p_no = (uchar FAR *)(_p_co+LCP_OPT_SZ_NULL);		\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth != LCP_OPT_SZ_NULL) || (opt_type != LCP_OPT_SSNHF)) { \
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
						Memcpy_far ((char FAR *)_p_co,				\
									(char FAR *)_p_no,				\
									(uint)(_p_end-_p_no));			\
						_p_curr = _p_co;							\
						Mppp_cep_peer_ack_negot &= (~LCP_NEG_SSNHF);	\
					}												\
				}

		/*-=-=-=-=-=-= EDO Option =-=-=-=-=-=-=*/

#define Lcp_opt_REQ_EDO(_p_curr,_class,_lgth,_p_addr)					\
				{													\
					if ((Mppp_cep_mp_disabled == OFF) && (Mppp_cep_peer_ack_negot & LCP_NEG_EDO) && (Mppp_cep_mp_rejected == OFF)) {	\
						Mppp_put_char(LCP_OPT_EDO, _p_curr);			\
						Mppp_put_char((_lgth+3),_p_curr);				\
						Mppp_put_char(_class, _p_curr);				\
						Memcpy_far((char FAR *)_p_curr,(char FAR *)_p_addr,_lgth);				\
						_p_curr += _lgth;							\
					}												\
				}

#define Lcp_opt_ACK_EDO(_p_curr,_class,_lgth,_p_addr)				\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_EDO) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= (_lgth+3)) >= 0) {		\
							_p_no = (uchar FAR *)(_p_co+_lgth+3);	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == (_lgth+3)) && (opt_type == LCP_OPT_EDO)) { \
								Mppp_get_char(opt_val_uchar, _p_curr);		\
								if ((opt_val_uchar != _class) || (Memcmp_far ((char FAR *)_p_addr,(char FAR *)_p_curr, (uint)_lgth) != 0)) {	\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
						Memcpy_far ((char FAR *)_p_co,				\
									(char FAR *)_p_no,				\
									(uint)(_p_end-_p_no));			\
						_p_curr = _p_co;							\
					}												\
				}

#define Lcp_opt_NAK_EDO(_p_curr,_class,_lgth,_p_addr)				\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_EDO) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= (_lgth+3)) >= 0) {		\
							_p_no = (uchar FAR *)(_p_co+_lgth+3);	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == (_lgth+3)) && (opt_type == LCP_OPT_EDO)) { \
								Mppp_get_char(opt_val_uchar, _p_curr);		\
								if ((opt_val_uchar == _class) && (Memcmp_far ((char FAR *)_p_addr,(char FAR *)_p_curr, (uint)_lgth) == 0)) {	\
									Mppp_cep_peer_ack_negot &= (~LCP_NEG_EDO);	\
								} else {							\
									goto opt_nak_error;				\
								}									\
							} else {								\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
						Memcpy_far ((char FAR *)_p_co,				\
									(char FAR *)_p_no,				\
									(uint)(_p_end-_p_no));			\
						_p_curr = _p_co;							\
					}												\
				}

#define Lcp_opt_REJ_EDO(_p_curr,_class,_lgth,_p_addr)				\
				{													\
					uchar FAR *_p_co;								\
					uchar FAR *_p_no;								\
					uchar FAR *_p_end;								\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_EDO) {	\
						_p_co  = _p_curr;							\
						_p_end = (_p_curr+pack_lgth);				\
						if ((pack_lgth -= (_lgth+3)) >= 0) {		\
							_p_no = (uchar FAR *)(_p_co+_lgth+3);	\
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == (_lgth+3)) && (opt_type == LCP_OPT_EDO)) { \
								Mppp_get_char(opt_val_uchar, _p_curr);		\
								if ((opt_val_uchar == _class) && (Memcmp_far ((char FAR *)_p_addr,(char FAR *)_p_curr, (uint)_lgth) == 0)) {	\
									Mppp_cep_peer_ack_negot &= (~LCP_NEG_EDO);	\
								} else {							\
									goto opt_rej_error;				\
								}									\
							} else {								\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
						Memcpy_far ((char FAR *)_p_co,				\
									(char FAR *)_p_no,				\
									(uint)(_p_end-_p_no));			\
						_p_curr = _p_co;							\
					}												\
				}


		/*-=-=-=-=-=-= LDO Option =-=-=-=-=-=-=*/

#if MPPP_BAP == ON	/* { */

#define Lcp_opt_REQ_LDO(_p_curr,_val)								\
				{													\
					if ((Mppp_cep_mp_disabled == OFF) && (Mppp_cep_bacp_rejected == OFF) && (Mppp_cep_peer_ack_negot & LCP_NEG_LDO)) {	\
						Mppp_put_char(LCP_OPT_LDO, _p_curr);		\
						Mppp_put_char(LCP_OPT_SZ_SHORT,_p_curr);	\
						Mppp_put_short(_val,_p_curr);				\
					}												\
				}

#define Lcp_opt_ACK_LDO(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_LDO) {	\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_LDO)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								if (opt_val_ushort != _val) {		\
									goto opt_ack_error;				\
								}									\
							} else {								\
								goto opt_ack_error;					\
							}										\
						} else {									\
							goto opt_ack_error;						\
						}											\
					}												\
				}

#define Lcp_opt_NAK_LDO(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_LDO) {	\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_LDO)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_LDO);	\
							} else {								\
								goto opt_nak_error;					\
							}										\
						} else {									\
							goto opt_nak_error;						\
						}											\
					}												\
				}

#define Lcp_opt_REJ_LDO(_p_curr,_val)								\
				{													\
					if (Mppp_cep_peer_ack_negot & LCP_NEG_LDO) {	\
						if ((pack_lgth -= LCP_OPT_SZ_SHORT) >= 0) { \
							Mppp_get_char(opt_type,_p_curr);		\
							Mppp_get_char(opt_lgth,_p_curr);		\
							if ((opt_lgth == LCP_OPT_SZ_SHORT) && (opt_type == LCP_OPT_LDO)) {	\
								Mppp_get_short(opt_val_ushort,_p_curr); \
								if (opt_val_ushort != _val) {		\
									goto opt_rej_error;				\
								}									\
								Mppp_cep_peer_ack_negot &= (~LCP_NEG_LDO);	\
							} else {								\
								goto opt_rej_error;					\
							}										\
						} else {									\
							goto opt_rej_error;						\
						}											\
					}												\
				}


#endif	/* MPPP_BAP == ON } */


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			 All the following functions implement the execution of a
				 received event (external or internal, servicing queue,
				 expiry of timers, receiver busy condition) according to the
				 state of the automaton.

Usage			 void lcp_xxxxxx ();

Description


Return value	 void

Common constants and declarations : mppp.h

Common objects : current contexts (thru access macros).

*--------------------------------------------------------------------------*/

		/*
						==== ILLEGAL-EVENT ====

			This indicates an event that cannot occur in aproperly
			implemented automaton. The implementation has an internal
			error, which should be reported and logged. No transition
			is taken, and the implementation SHOULD NOT reset to freeze.
		*/

void lcp_illegal_event ()
{
	MPPP_DBG_FUNC ("lcp_illegal_event()")

	MPPP_DBG_ENTER ();

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== THIS-LAYER-UP ====

			This action indicates to the upper layers that the automaton
			is entering the OPENED state.
			Typically, this action is used by the LCP to signal the UP
			event to a NCP, Authentication Protocol, or Link Quality
			Protocol, or MAY be used by a NCP to indicate that the link
			is available for its network layer traffic.
		*/

void lcp_this_layer_up ()
{
	MPPP_DBG_FUNC ("lcp_this_layer_up()")

	MPPP_DBG_ENTER ();

	Lcp_indicate_up_event ();

	if ((! Is_sppp_first_in_bundle ()) &&
		(Mppp_cep_ack_auth == PPP_PROT_PAP)) {

			/* Set up the pointer to the authentication information context */

		p_sppp_auth	= Sppp_cep_p_peer_auth_info;

				/* Initialize restart counters to Max */

		Sppp_auth_count	= Sppp_auth_mx_count;

		if (Sppp_cep_link_phase == SPPP_LINK_PHASE_AUTHENTICATE) {

			if (Sppp_auth_count > 0) {

					/* Send PAP Authenticate-Request packet */

				mppp_c_prot_send_pap_auth_request ();

			}

		}

	}

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== THIS-LAYER-DOWN ====

			This action indicates to the upper layers that the automaton
			is leaving the OPENED state.
			Typically, this action is used by the LCP to signal the DOWN
			event to a NCP, Authentication Protocol, or Link Quality
			Protocol, or MAY be used by a NCP to indicate that the link
			is no longer available for its network layer traffic.
		*/

void lcp_this_layer_down ()
{
	MPPP_DBG_FUNC ("lcp_this_layer_down()")

	MPPP_DBG_ENTER ();

	Lcp_indicate_down_event ();

		/* Stop the LCP Restart timer */

	Mppp_c_prot_stop_timer (MPPP_LCP_TI_X_RESTART);

	if ((! Is_sppp_first_in_bundle ()) &&
		(Mppp_cep_ack_auth == PPP_PROT_PAP)) {

			/* Set up the pointer to the authentication information context */

		p_sppp_auth	= Sppp_cep_p_peer_auth_info;

			/* Zero the restart counters */

		Sppp_auth_count	= 0;

	}

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== THIS-LAYER-STARTED ====

			This action indicates to the lower layers that the automaton
			is entering the STARTING state, and the lower layer is needed
			for the link. The lower layer SHOULD respond with an UP event
			when the lower layer is available.
			The results of this action are highly implementation dependent.
		*/

void lcp_this_layer_started ()
{
	MPPP_DBG_FUNC ("lcp_this_layer_started()")

	MPPP_DBG_ENTER ();

	Lcp_activate_lower_layer ();

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== THIS-LAYER-FINISHED ====

			This action indicates to the lower layers that the automaton
			is entering the INITIAL state, CLOSED or STOPPED states, and
			the lower layer is no longer needed for the link. The lower layer
			SHOULD respond with a DOWN event when the lower layer has
			terminated.
			Typically, this action MAY be used by the LCP to advance to the
			LINK DEAD phase, or MAY be used by a NCP to indicate to the LCP
			that the link may terminate when there are no other NCPs open.
			The results of this action are highly implementation dependent.
		*/

void lcp_this_layer_finished ()
{
	MPPP_DBG_FUNC ("lcp_this_layer_finished()")

	MPPP_DBG_ENTER ();

	Lcp_deactivate_lower_layer ();

		/* Stop the LCP Restart timer */

	Mppp_c_prot_stop_timer (MPPP_LCP_TI_X_RESTART);

		/*
			If we failed to negotiate LCP, then we signal this error
			and we terminate the connection.
		*/

	if (Mppp_c_prot_configure_count == 0) {

		mppp_snd_error_in (MPPP_CAUSE_CFG_NOT_CONVERGING,
							MPPP_DIAG_NO_REPLY,
							MPPP_SAPI_EXT_EVENTS);

	}

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== INITIALIZE-RESTART-COUNT ====

			This action sets the Restart counter to the appropriate value
			(Max-Terminate or Max-Configure). The counter is decremented for
			each transmission, including the first.
			In addition to setting the Restart counter, the implementation
			MUST set the timeout period to the initial value when the Restart
			timer backoff is used.
		*/

void lcp_init_restart_counter ()
{
	MPPP_DBG_FUNC ("lcp_init_restart_counter()")

	MPPP_DBG_ENTER ();

	Mppp_c_prot_terminate_count = Mppp_c_prot_mx_terminate;
	Mppp_c_prot_configure_count = Mppp_c_prot_mx_configure;
	Mppp_c_prot_failure_count   = 0;

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== ZERO-RESTART-COUNT ====

			This action sets the Restart counter to zero.
			This action enables the Finite-State-Automaton (FSA) to pause
			before proceeding to the desired final state, allowing traffic to
			be processed by the peer. In addition to zeroing the Restart
			counter, the implementation MUST set the timeout period to an
			appropriate value.
		*/

void lcp_zero_restart_counter ()
{
	MPPP_DBG_FUNC ("lcp_zero_restart_counter()")

	MPPP_DBG_ENTER ();

	Mppp_c_prot_terminate_count = 0;
	Mppp_c_prot_configure_count = 0;
	Mppp_c_prot_failure_count   = Mppp_c_prot_mx_failure;

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== SEND-CONFIGURE-REQUEST ====

			A Configure-Request packet is transmitted. This indicates the
			desire to open a connection with a specified set of Configuration
			Options. The Restart timer is started when the Configure-Request
			packet is transmitted, to guard against packet loss. The Restart
			counter is decremented each time a Configure-Request is sent.
		*/

void lcp_send_configure_request ()
{
	MPPP_DBG_FUNC ("lcp_send_configure_request()")

	uchar			FAR *p_curr;
	uchar			FAR *p_curr_start;
	uchar			FAR *p_data_start;
	ushort				data_size;
	struct buffer	FAR *p_buffer;

	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_LCP;

	p_buffer = Alloc_buffer ();

	p_data_start	= Buffer_a_start_data;
	p_curr			=
	p_curr_start	= (p_data_start+PPP_PACKET_HEADER_LGTH+PPP_FRAME_HEADER_LGTH);

	Lcp_opt_REQ_MRU		(p_curr, Mppp_cep_peer_ack_mru);
	Lcp_opt_REQ_ACCM	(p_curr, 0);	/* We ALWAYS request 0 */
	Lcp_opt_REQ_AUTH	(p_curr, Mppp_cep_peer_ack_auth, PPP_AUTH_ALG_MD5);
	Lcp_opt_REQ_LQM		(p_curr, PPP_PROT_LQR, Mppp_cep_peer_ack_lqr_period);

	if (mppp_c_prot_event_id != MPPP_CP_EV_TIMEOUT) {

			/* Generate a new Magic Number only if not a retransmission */

		Sppp_cep_peer_ack_magic = Mppp_gen_magic ();

	}

	Lcp_opt_REQ_MAGIC	(p_curr, Sppp_cep_peer_ack_magic);
	Lcp_opt_REQ_PFC		(p_curr);
	Lcp_opt_REQ_ACFC	(p_curr);
	Lcp_opt_REQ_MRRU	(p_curr, Mppp_cep_peer_ack_mrru);
	Lcp_opt_REQ_SSNHF	(p_curr);
	Lcp_opt_REQ_EDO		(p_curr, Mppp_cep_peer_ack_edo_class, Mppp_cep_peer_ack_edo_add_lgth, &Mppp_cep_peer_ack_edo_add);

#	if MPPP_BAP == ON
		Sppp_cep_peer_ack_ldo = (ushort)Sppp_cep_ref;
		Lcp_opt_REQ_LDO	(p_curr, Sppp_cep_peer_ack_ldo);
#	endif

#	if 0	/*$$$ NOT USED { */

			/*
				Update the PPP packet identifier
				As stated in RFC 1661,
				for retransmissions, the Identifier MAY remain
				unchanged.
				We think it's better to change the identifier, so that
				any extra-Ack, due to collision, will be discarded.
			*/

		if (mppp_c_prot_event_id != MPPP_CP_EV_TIMEOUT) {
			Mppp_c_prot_s_packet_id++;
		}

#	endif	/* NOT USED } */

		/* Update the PPP packet identifier */

	if (Mppp_c_prot_s_packet_id == PPP_MX_PACKET_ID_VAL) {
		Mppp_c_prot_s_packet_id	= 0;
	} else {
		Mppp_c_prot_s_packet_id++;
	}

		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_LCP,
												MPPP_CP_PCK_CONFIG_RQ,
												Mppp_c_prot_s_packet_id,
												p_data_start,
												(p_curr - p_curr_start));


		/* Set the buffer size, and allocate a message for sending */

	Buffer_data_size	= data_size;
	p_snd_msg			= Msg_or_buffer (p_buffer, 0);

		/* Queue this message */

	mppp_in_sppp_tx_queue ();


		/* Send a data message to the lower entity */

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_link_mode_accm (Sppp_cep_link_mode));

		/* Decrement the configure count, and start the restart timer */

	Mppp_c_prot_configure_count--;
	Mppp_c_prot_start_timer (MPPP_LCP_TI_X_RESTART);

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== SEND-CONFIGURE-ACK ====

			A Configure-Ack packet is transmitted. This acknowledges the
			reception of a Configure-Request packet with an acceptable set of
			Configuration Options.
		*/

void lcp_send_configure_ack ()
{
	MPPP_DBG_FUNC ("lcp_send_configure_ack()")

	uchar	FAR	*p_data_start;
	ushort		data_size;

	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_LCP;

		/* Try to reuse the received message */

	if ((p_rcv_msg == P_NIL) ||
		((p_rcv_msg != P_NIL) && (R_msg_lib == OFF))) {

		p_snd_msg	= Alloc_msg ();

	} else {

		p_snd_msg	= p_rcv_msg;
		p_rcv_msg	= P_NIL;

	}

	p_data_start	= S_a_data;

		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_LCP,
												MPPP_CP_PCK_CONFIG_ACK,
												Mppp_c_prot_r_packet_id,
												p_data_start,
												Mppp_c_prot_data_size);

	if (p_buffer != P_NIL) {
		Buffer_data_size =
		S_msg_frag_size  = data_size;
	} else {
		S_msg_data_size	= (uchar)data_size;
	}

		/* Queue this message */

	mppp_in_sppp_tx_queue ();


		/* Send this packet to the peer system */

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_link_mode_accm (Sppp_cep_link_mode));

	if (Mppp_c_prot_state == MPPP_CP_STATE_ACK_RECEIVED) {

		if ((Mppp_cep_ack_negot & LCP_NEG_MRRU) && (Mppp_cep_peer_ack_negot & LCP_NEG_MRRU)) {

				/* Set the MP as enabled */

			Mppp_cep_mp_enabled	= ON;

			MPPP_DBG_NOTICE ("MP PPP successfully negotiated");

		}

	}

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== SEND-CONFIGURE-NAK/REJ ====

			A Configure-Nak or Configure-Reject packet is transmitted, as
			appropriate. This negative response reports the reception of a
			Configure-Request packet with an unacceptable set of Configuration
			Options.
			Configure-Nak packets are used to refuse a Configure Option value,
			and to suggest a new, acceptable value. Configure-Reject packets
			are used to refuse all negotiation about a Configuration Option,
			typically because it is not recognized or implemented.
		*/

void lcp_send_configure_nak_rej ()
{
	MPPP_DBG_FUNC ("lcp_send_configure_nak_rej()")
	
	uchar	FAR	*p_data_start;
	ushort		data_size;
	uchar		code;


	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_LCP;

	if ((Mppp_c_prot_rej_flag == ON) ||
		(++Mppp_c_prot_failure_count > Mppp_c_prot_mx_failure)) {

			/* Send Configure Reject instead of Configure Nak */

		code = MPPP_CP_PCK_CONFIG_REJ;

		MPPP_DBG_NOTICE ("sending CONFIG REJ");

	} else {

			/*
				Send Configure Nak or Configure-Reject,
				if a requested Configuration Option is not recognized
				or not implemented.
			*/


		code = MPPP_CP_PCK_CONFIG_NAK;

		MPPP_DBG_NOTICE ("sending CONFIG NAK");

	}

		/* Try to reuse the received message */

	if ((p_rcv_msg == P_NIL) ||
		((p_rcv_msg != P_NIL) && (R_msg_lib == OFF))) {

		p_snd_msg	= Alloc_msg ();

	} else {

		p_snd_msg	= p_rcv_msg;
		p_rcv_msg	= P_NIL;

	}

	p_data_start	= S_a_data;

		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_LCP,
												code,
												Mppp_c_prot_r_packet_id,
												p_data_start,
												Mppp_c_prot_data_size);

	if (p_buffer != P_NIL) {
		Buffer_data_size =
		S_msg_frag_size  = data_size;
	} else {
		S_msg_data_size	= (uchar)data_size;
	}

		/* Queue this message */

	mppp_in_sppp_tx_queue ();

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_link_mode_accm (Sppp_cep_link_mode));

		/* Reset the reject flag */

	Mppp_c_prot_rej_flag	= OFF;

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== SEND-TERMINATE-REQUEST ====

			A Terminate-Request packet is transmitted. This indicates the
			desire to close a connection. The Restart timer is started when
			the Terminate-Request packet is transmitted, to guard against
			packet loss. The Restart counter is decremented each time a
			Terminate-Request packet is sent.
		*/

void lcp_send_terminate_request ()
{
	MPPP_DBG_FUNC ("lcp_send_terminate_request()")

	struct buffer	FAR *p_buffer;

	uchar	FAR	*p_data_start;
	ushort		data_size;

	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_LCP;

	p_buffer = Alloc_buffer ();

	p_data_start	= Buffer_a_start_data;

#	if 0	/*$$$ NOT USED { */

			/*
				Update the PPP packet identifier
				As stated in RFC 1661,
				for retransmissions, the Identifier MAY remain
				unchanged.
				We think it's better to change the identifier, so that
				any extra-Ack, due to collision, will be discarded.
			*/

		if (mppp_c_prot_event_id != MPPP_CP_EV_TIMEOUT) {
			Mppp_c_prot_s_packet_id++;
		}

#	endif	/* NOT USED } */

		/* Update the PPP packet identifier */

	if (Mppp_c_prot_s_packet_id == PPP_MX_PACKET_ID_VAL) {
		Mppp_c_prot_s_packet_id	= 0;
	} else {
		Mppp_c_prot_s_packet_id++;
	}

		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_LCP,
												MPPP_CP_PCK_TERM_RQ,
												Mppp_c_prot_s_packet_id,
												p_data_start,
												0);

	Buffer_data_size	= data_size;

	p_snd_msg	= Msg_or_buffer (p_buffer, 0);

		/* Update the link phase */

	Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

		/* Queue this message */

	mppp_in_sppp_tx_queue ();

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_cep_accm_to_peer);

	Mppp_c_prot_terminate_count--;
	Mppp_c_prot_start_timer (MPPP_LCP_TI_X_RESTART);

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== SEND-TERMINATE-ACK ====

			A Terminate-Ack packet is transmitted. This acknowledges the
			reception of a Terminate-Request packet or otherwise serves to
			synchronize the automatons.
		*/

void lcp_send_terminate_ack ()
{
	MPPP_DBG_FUNC ("lcp_send_terminate_ack()")

	uchar	FAR *p_data_start;
	ushort		data_size;

	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_LCP;

		/* Try to reuse the received message */

	if ((p_rcv_msg == P_NIL) ||
		((p_rcv_msg != P_NIL) && (R_msg_lib == OFF))) {

		p_snd_msg	= Alloc_msg ();

	} else {

		p_snd_msg		= p_rcv_msg;
		p_rcv_msg		= P_NIL;


	}

	p_data_start	= S_a_data;


		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_LCP,
												MPPP_CP_PCK_TERM_ACK,
												Mppp_c_prot_r_packet_id,
												p_data_start,
												0);

	if (p_buffer != P_NIL) {
		Buffer_data_size	= data_size;
	} else {
		S_msg_data_size		= (uchar)data_size;
	}

		/* Update the link phase */

	Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

		/* Queue this message */

	mppp_in_sppp_tx_queue ();

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_cep_accm_to_peer);

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== SEND-CODE-REJECT ====

			A Code-Reject packet is transmitted. This indicates the reception
			of an unknown type of packet.
		*/

void lcp_send_code_reject ()
{
	MPPP_DBG_FUNC ("lcp_send_code_reject()")

	uchar	FAR *p_data_start;
	ushort		data_size;

	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_LCP;

		/* Try to reuse the received message */

	if ((p_rcv_msg == P_NIL) ||
		((p_rcv_msg != P_NIL) && (R_msg_lib == OFF))) {

		p_snd_msg	= Alloc_msg ();

	} else {

		p_snd_msg		= p_rcv_msg;
		p_rcv_msg		= P_NIL;


	}

	p_data_start	= S_a_data;


		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_LCP,
												MPPP_CP_PCK_CODE_REJ,
												Mppp_c_prot_s_packet_id,
												p_data_start,
												0);

	if (p_buffer != P_NIL) {
		Buffer_data_size	= data_size;
	} else {
		S_msg_data_size		= (uchar)data_size;
	}

		/* Queue this message */

	mppp_in_sppp_tx_queue ();

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_cep_accm_to_peer);


	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== SEND-ECHO-REPLY ====

			An Echo-Reply packet is transmitted. This acknowledges the
			reception of an Echo-Request packet.
		*/

void lcp_send_echo_reply ()
{
	MPPP_DBG_FUNC ("lcp_send_echo_reply()")

	uchar	FAR *p_data_start;
	ushort		data_size;

	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_LCP;

		/* Try to reuse the received message */

	if ((p_rcv_msg == P_NIL) ||
		((p_rcv_msg != P_NIL) && (R_msg_lib == OFF))) {

		p_snd_msg	= Alloc_msg ();

	} else {

		p_snd_msg		= p_rcv_msg;
		p_rcv_msg		= P_NIL;


	}

	p_data_start	= S_a_data;


		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_LCP,
												MPPP_CP_PCK_ECHO_REPLY,
												Mppp_c_prot_r_packet_id,
												p_data_start,
												0);

	if (p_buffer != P_NIL) {
		Buffer_data_size	= data_size;
	} else {
		S_msg_data_size		= (uchar)data_size;
	}

		/* Queue this message */

	mppp_in_sppp_tx_queue ();

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_cep_accm_to_peer);

	MPPP_DBG_LEAVE ();

}

/*-------------------------------------------------------------------------*/

		/*
						==== IS-REJECT-FATAL ====

			This action determines whether a received Reject packet is
			permitted or catastrophic.
		*/

uchar lcp_is_reject_fatal ()
{
	MPPP_DBG_FUNC ("lcp_is_reject_fatal()")

	MPPP_DBG_ENTER ();

	if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CODE_REJ) {

			/* Code-reject packet received */

		switch (mppp_c_prot_rej_packet_code) {

			case MPPP_CP_PCK_CONFIG_RQ :
			case MPPP_CP_PCK_CONFIG_ACK :
			case MPPP_CP_PCK_CONFIG_NAK :
			case MPPP_CP_PCK_CONFIG_REJ :
			case MPPP_CP_PCK_TERM_RQ :
			case MPPP_CP_PCK_TERM_ACK :
			case MPPP_CP_PCK_CODE_REJ :
			case MPPP_CP_PCK_PROTOCOL_REJ:

				MPPP_DBG_NOTICE ("Fatal LCP Code-Reject");
				MPPP_DBG_LEAVE ();
				return (TRUE);

			default:
				break;

		}

	} else if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_PROTOCOL_REJ) {

			/* Protocol-Reject packet received */

		switch (Mppp_c_prot_ppp_pid) {

#			if MPPP_BAP == ON
				case PPP_PROT_BACP:
					MPPP_DBG_NOTICE ("BACP protocol rejected");
					break;
#			endif

			case PPP_PROT_LCP:
				MPPP_DBG_NOTICE ("LCP protocol rejected");
				MPPP_DBG_LEAVE ();
				return (TRUE);

			default:
				break;

		}

	}

	MPPP_DBG_LEAVE ();

	return (FALSE);
}

/*-------------------------------------------------------------------------*/

		/*
						==== CHECK-CONFIGURE-REQUEST ====

			This action determines whether a received Configure-Request is
			acceptable or not.
			This routine does not reject any option during the LCP negotiation
			initiated in the first member link, except if we receive MP options
			while the MP is disabled for this bundle.
		*/

uchar lcp_check_configure_request ()
{
	MPPP_DBG_FUNC ("lcp_check_configure_request()")

	uchar	FAR *p_octet;		/* pointer to next octet to parse */
	uchar	FAR *p_curr_out;	/* pointer to current output octet */
	uchar	FAR *p_curr_opt;	/* pointer to current option */
	uchar	FAR *p_next_opt;	/* pointer to next option */
	uchar	FAR *p_end_data;	/* pointer to the first octet beyond the packet */
	uchar	FAR *p_lgth;		/* pointer to the packet length address */
	uchar		opt_lgth;		/* option length */
	uchar		opt_type;		/* option type */
	uchar		opt_val_uchar;	/* option 'uchar' value */
	ushort		opt_val_ushort; /* option 'ushort' value */
	ulong		opt_val_ulong;	/* option 'ulong' value */
	uchar		opt_retcode;	/* option return code (ACK/NAK/REJ) */
	uchar		pack_retcode;	/* whole packet return code (ACK/NAK/REJ) */
	long		lgth;			/* length left to parse */
	uchar		tmp_edo_add[MPPP_MX_SZ_EDO_ADD];	/* EDO maximum length */
	uchar		return_stop;	/* indicator for STOP return code */

	MPPP_DBG_ENTER ();

		/*
			At this stage, the packet header is valid.
			We subtract the header length for the following processing
		*/

		/*
			Set up the pointer to the beginning of the output packet
			and the packet length.
		*/

	p_curr_out	= Mppp_c_prot_p_data;
	lgth		= Mppp_c_prot_data_size;
	p_lgth		= (uchar FAR *)(Mppp_c_prot_p_data - 2);

		/* Initialize the pointer to the first octet beyond the packet */

	p_end_data	= (uchar FAR *)(Mppp_c_prot_p_data+ (ushort)lgth);

		/*
			We reset the information about the options we ack'd
		*/

	Sppp_cep_reset_ack_cp_opt ();

	if (Is_sppp_first_in_bundle ()) {

			/* Reset the number of LCP options we should Ack */

		Mppp_cep_rcv_lcp_opt_nb		= 0;

	}


		/*
			Let's go through the options
		*/

	p_next_opt			 = p_octet = Mppp_c_prot_p_data;
	pack_retcode		 = MPPP_CP_PCK_CONFIG_ACK;	/* default to success */
	Mppp_c_prot_rej_flag = OFF;	/* default to no Reject packet to send */
	return_stop			 = FALSE;	/* default to no STOP to return */

		/* Loop until no more option to process */

	while (lgth > 0) {

		opt_retcode = MPPP_CP_PCK_CONFIG_ACK;	/* default to success */
		p_curr_opt	= p_octet = p_next_opt;

			/*
				Check the consistency of this option
				1- is there enough data for the option ?
				2- is the option length field >= 2
				3- is the option length > the remaining data length ?
			*/

		if ((lgth < 2) || (p_curr_opt[1] < 2) || (p_curr_opt[1] > lgth)) {

				/*
					This option is bad, the remaining options in the
					packet will be rejected.
				*/

			MPPP_DBG_ERROR ("wrong LCP option length");

			opt_retcode =  MPPP_CP_PCK_CONFIG_REJ;		/* bad option */
			opt_lgth	= lgth; /* reject all the remaining options */
			lgth		= 0;	/* no more loop to run */

			if (Is_sppp_first_in_bundle ()) {
				return_stop = TRUE;
			}

			goto opt_terminated;
		}

			/* Get the option type (1 octet) */

		Mppp_get_char (opt_type, p_octet);

			/* Get the option length (1 octet) */

		Mppp_get_char (opt_lgth, p_octet);

			/* Update the remaining length */

		lgth -= opt_lgth;

			/* Set up the pointer to the next option */

		p_next_opt += opt_lgth;

			/* Increment the number of LCP options we should Ack */

		if (Is_sppp_first_in_bundle ()) {

				/* Save the position for this LCP option */

			Mppp_cep_rcv_lcp_opt_tab ((Mppp_cep_rcv_lcp_opt_nb++)) = opt_type;

			if (Mppp_cep_rcv_lcp_opt_nb >= MPPP_MX_LCP_OPT_NB) {

				MPPP_DBG_ERROR ("too many LCP options to manage");

				Trap (TRAP_MPPP_ERROR, "lcp_check_configure_request");

				MPPP_DBG_LEAVE ();

				return (NOK);

			}

		}


			/* Forward processing according to the option type */

		switch (opt_type) {

				/*=========================
					Max Receive Unit (MRU)
				==========================*/

			case LCP_OPT_MRU:
				MPPP_DBG_DISPLAY ("received MRU(");

				if (! Is_sppp_first_in_bundle()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_MRU)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_SHORT) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Get and check the MRU value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_INT (opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (")");

				if (Is_sppp_first_in_bundle()) {

						/* Keep a trace of this option value */

					Mppp_cep_ack_mru = opt_val_ushort;

				} else {

					if (opt_val_ushort != Mppp_cep_ack_mru) {
						MPPP_DBG_WARNING ("MRU value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Note that the peer negotiated the MRU */

				Sppp_cep_ack_negot	|= LCP_NEG_MRU;
				break;


				/*======================================
					Async Character Control Map (ACCM)
				=======================================*/

			case LCP_OPT_ACCM:
				MPPP_DBG_DISPLAY ("received ACCM(");

				if (! Is_sppp_first_in_bundle()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_ACCM)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						Mppp_c_prot_rej_flag	= ON;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_LONG) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Get the ACCM value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Check the ACCM value */

				if (Is_sppp_first_in_bundle()) {

						/*
							Keep a trace of this option value
							This ACCM becomes effective after we've
							sent a Config-Ack.
						*/


					Mppp_cep_ack_accm	= opt_val_ulong;

						/*
							If the peer is requesting a non-zero ACCM,
							we keep this value for us, and we transmit
							a zero ACCM to the local user PPP, so that
							we can avoid extra ACCM conversion.
						*/

					if (opt_val_ulong != 0) {
						Mppp_dec_ptr (4, p_octet);
						Mppp_put_long (0, p_octet);
					}

				} else {

					if (opt_val_ulong != Mppp_cep_ack_accm) {
						MPPP_DBG_WARNING ("ACCM value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}
				}

				Sppp_cep_ack_accm	= opt_val_ulong;


					/* Note that the peer negotiated the ACCM */

				Sppp_cep_ack_negot	|= LCP_NEG_ACCM;
				break;

				/*======================================
					Authentication protocol (AUTH)
				=======================================*/

			case LCP_OPT_AUTH:
				MPPP_DBG_DISPLAY ("received AUTH(");

				if (! Is_sppp_first_in_bundle()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_AUTH)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (((Mppp_cep_ack_auth == PPP_PROT_CHAP) && (opt_lgth != LCP_OPT_SZ_CHAP)) ||
						((Mppp_cep_ack_auth == PPP_PROT_PAP) && (opt_lgth != LCP_OPT_SZ_SHORT))) {

						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Get the authentication protocol value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ushort);

				if (opt_val_ushort == PPP_PROT_CHAP) {

						/* Get the one-way hash method to be used (if CHAP) */

					MPPP_DBG_DISPLAY_STR (",");

					Mppp_get_char (opt_val_uchar, p_octet);

					MPPP_DBG_DISPLAY_HEX ((uchar)opt_val_uchar);

				}

				MPPP_DBG_DISPLAY_STR (")");

					/* Check the AUTH value */

				if (Is_sppp_first_in_bundle()) {

						/*
							Keep a trace of this option value
							We don't care about the Algorithm to be used
							with CHAP.
						*/

					Mppp_cep_ack_auth = opt_val_ushort;

				} else {

					if (opt_val_ushort != Mppp_cep_ack_auth) {

						MPPP_DBG_WARNING ("AUTH value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;

					}
				}

					/* Note that the peer negotiated the AUTH_PROT */

				Sppp_cep_ack_negot	|= LCP_NEG_AUTH;
				break;

				/*==========================================
					Link Quality Monitoring protocol (LQM)
				===========================================*/

			case LCP_OPT_LQM:
				MPPP_DBG_DISPLAY ("received LQM(");

				if (! Is_sppp_first_in_bundle()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_LQM)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_LQR) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/*
						Get the quality protocol (Link Quality Report)
						value and the report period value
					*/

				Mppp_get_short (opt_val_ushort, p_octet);
				Mppp_get_long (opt_val_ulong, p_octet);

				MPPP_DBG_DISPLAY_HEX ((ushort)opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (",");
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Check the LQM protocol */

				if (Is_sppp_first_in_bundle()) {

						/* Keep a trace of this option value */

					Mppp_cep_ack_lqm		= opt_val_ushort;
					Mppp_cep_ack_lqr_period = opt_val_ulong;

				} else {

					if (opt_val_ushort != Mppp_cep_ack_lqm) {
						MPPP_DBG_WARNING ("QUAL value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_val_ulong != Mppp_cep_ack_lqr_period) {
						MPPP_DBG_WARNING ("QUAL period value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Note that the peer negotiated the LQM */

				Sppp_cep_ack_negot	|= LCP_NEG_LQM;
				break;

				/*========================================================
					Magic Number (MAGIC). One for each single PPP link
				=========================================================*/

			case LCP_OPT_MAGIC:
				MPPP_DBG_DISPLAY ("received MAGIC(");

				if (! Is_sppp_first_in_bundle()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_MAGIC)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_LONG) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Get the MAGIC NUMBER value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

				if (Is_sppp_first_in_bundle ()) {

						/* Keep a trace of this option value */

					Mppp_cep_ack_magic	=
					Sppp_cep_ack_magic	= opt_val_ulong;

				} else {

						/*
							The peer's magic number must be different from ours
							0 is not a valid magic number.
						*/

					if (opt_val_ulong == 0) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (Sppp_cep_peer_ack_magic == opt_val_ulong) {

						opt_retcode = MPPP_CP_PCK_CONFIG_NAK;
						Mppp_dec_ptr (sizeof(long), p_octet);

							/*
								We generate a new magic number for the
								ConfigNak packet, in order to detect a
								link loopback
							*/

						opt_val_ulong = Mppp_gen_magic ();
						Mppp_put_long (opt_val_ulong, p_octet);
						break;
					}

						/* Save the magic number value */

					Sppp_cep_ack_magic = opt_val_ulong;

				}

					/* Note that the peer negotiated the MAGIC number */

				Sppp_cep_ack_negot	|= LCP_NEG_MAGIC;
				break;


				/*=====================================
					Protocol Field Compression (PFC)
				======================================*/

			case LCP_OPT_PFC:
				MPPP_DBG_DISPLAY ("received PFC");

				if (! Is_sppp_first_in_bundle ()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_PFC)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_NULL) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Note that the peer negotiated the PFC */

				Sppp_cep_ack_negot	|= LCP_NEG_PFC;
				break;


				/*=================================================
					Address and Control Field Compression (ACFC)
				==================================================*/

			case LCP_OPT_ACFC:
				MPPP_DBG_DISPLAY ("received ACFC");

				if (! Is_sppp_first_in_bundle ()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_ACFC)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_NULL) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Note that the peer negotiated the ACFC */

				Sppp_cep_ack_negot	|= LCP_NEG_ACFC;
				break;


				/*===============================================
					Max Receive Reconstructed Unit (MRRU)

					This ML PPP option MUST NOT be retransmitted
					to the local PPP stack.
				================================================*/

			case LCP_OPT_MRRU:
				MPPP_DBG_DISPLAY ("received MRRU(");

				if (! Is_sppp_first_in_bundle()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_MRRU)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_SHORT) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* Get and check the MRRU value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_INT (opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (")");

					/* The MP is disabled, then we reject this option  */

				if (Mppp_cep_mp_disabled == ON) {
					opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
					return_stop	= TRUE;
					break;
				}

				if (Is_sppp_first_in_bundle()) {

						/* Keep a trace of this option value */

					Mppp_cep_ack_mrru = opt_val_ushort;

				} else {

					if (opt_val_ushort != Mppp_cep_ack_mrru) {
						MPPP_DBG_WARNING ("MRRU value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* We should expect a minimum MRRU */

				if (Mppp_cep_ack_mrru < Mppp_cep_min_mrru) {
					opt_retcode = MPPP_CP_PCK_CONFIG_NAK;
					Mppp_cep_ack_mru = 0;
					break;
				}

				if (Is_sppp_first_in_bundle ()) {

						/*
							This VALID option must not be sent to our local
							PPP stack.
							We move the next option up, and we adjust the
							remaining length of the packet
						*/

					Memcpy_far ((char FAR *)p_curr_out,
								(char FAR *)p_next_opt,
								(uint)(p_end_data - p_next_opt));

						/*
							Set up pointers so that the "next" option's pointer
							stays at the current option's address
						*/

					p_next_opt	= p_curr_opt = p_curr_out;

				}

					/* Note that the peer negotiated the MRRU */

				Sppp_cep_ack_negot	|= LCP_NEG_MRRU;
				break;


				/*=================================================
					Short Sequence Number Header Format (SSNHF)

					This ML PPP option MUST NOT be retransmitted
					to the local PPP stack.
				==================================================*/

			case LCP_OPT_SSNHF:
				MPPP_DBG_DISPLAY ("received SSNHF");

				if (! Is_sppp_first_in_bundle ()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_SSNHF)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (opt_lgth != LCP_OPT_SZ_NULL) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* The MP is disabled, then we reject this option  */

				if (Mppp_cep_mp_disabled == ON) {
					opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
					return_stop	= TRUE;
					break;
				}

				if (Is_sppp_first_in_bundle ()) {

						/*
							This VALID option must not be sent to our local
							PPP stack.
							We move the next option up, and we adjust the
							remaining length of the packet
						*/

					Memcpy_far ((char FAR *)p_curr_out,
								(char FAR *)p_next_opt,
								(uint)(p_end_data - p_next_opt));

						/*
							Set up pointers so that the "next" option's pointer
							stays at the current option's address
						*/

					p_next_opt	= p_curr_opt = p_curr_out;

				}

					/* Note that the peer negotiated the SSNHF */

				Sppp_cep_ack_negot	|= LCP_NEG_SSNHF;
				break;


				/*=========================================
					Endpoint Discriminator Option (EDO)

					This ML PPP option MUST NOT be retransmitted
					to the local PPP stack.
				==========================================*/

			case LCP_OPT_EDO:
				MPPP_DBG_DISPLAY ("received EDO");

				if (! Is_sppp_first_in_bundle()) {

					if (! (Mppp_cep_ack_negot & LCP_NEG_EDO)) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

					/* The length of the EDO depends on the EDO class */

				Mppp_get_char (opt_val_uchar, p_octet);

				MPPP_DBG_DISPLAY_STR ("(class=");
				MPPP_DBG_DISPLAY_INT (opt_val_uchar);
				MPPP_DBG_DISPLAY_STR (")");

					/* The MP is disabled, then we reject this option  */

				if (Mppp_cep_mp_disabled == ON) {
					opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
					return_stop	= TRUE;
					break;
				}

					/* Dispatch according to the EDO class */

				switch (opt_val_uchar) {

					case LCP_EDO_CLASS_0:		/* Null class */

							/* Fixed length EDO */

						if (opt_lgth != LCP_OPT_SZ_EDO_0) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						}
						break;

					case LCP_EDO_CLASS_1:	/* Locally Assigned Address */

							/* Variable length EDO */

						if (opt_lgth > LCP_OPT_MX_SZ_EDO_1) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						}
						break;

					case LCP_EDO_CLASS_2:		/* Internet Protocol (IP) address */

							/* Fixed length EDO */

						if (opt_lgth != LCP_OPT_SZ_EDO_2) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						}
						break;

					case LCP_EDO_CLASS_3:	/* IEEE 802.1 Globally assigned MAC address */

							/* Fixed length EDO */

						if (opt_lgth != LCP_OPT_SZ_EDO_3) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						}
						break;

					case LCP_EDO_CLASS_4:	/* PPP Magic-Number Block */

							/* Variable length EDO */

						if (opt_lgth > LCP_OPT_MX_SZ_EDO_4) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						}
						break;

					case LCP_EDO_CLASS_5:	/* Public Switched Network Directory Number */

							/* Variable length EDO */

						if (opt_lgth > LCP_OPT_MX_SZ_EDO_5) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						}
						break;

					default:	/* Unknown EDO class */
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;


				}

					/* Something wrong ? */

				if (opt_retcode != MPPP_CP_PCK_CONFIG_ACK) {
					break;
				}

					/* Retrieve the EDO bytes, if address information is present */

				if (opt_lgth > LCP_OPT_SZ_EDO_0) {

					Memcpy_far ((char FAR *)&tmp_edo_add[0], (char FAR *)p_octet, (opt_lgth - LCP_OPT_SZ_EDO_0));

						/* Set the pointer beyond the EDO address */

					Mppp_inc_ptr ((opt_lgth - LCP_OPT_SZ_EDO_0),p_octet);
				}

				if (Is_sppp_first_in_bundle()) {

						/* Keep a trace of this option value */

					Mppp_cep_ack_edo_class	  = opt_val_uchar;
					Mppp_cep_ack_edo_add_lgth = (uchar)(opt_lgth - LCP_OPT_SZ_EDO_0);

					Memcpy_far ((char FAR *)&Mppp_cep_ack_edo_add[0], (char FAR *)&tmp_edo_add[0], Mppp_cep_ack_edo_add_lgth);

				} else {

						/* We don't accept a different EDO value in the same bundle */

					if (opt_val_uchar != Mppp_cep_ack_edo_class) {
						MPPP_DBG_WARNING ("EDO class value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

					if (Memcmp_far ((char FAR *)&Mppp_cep_ack_edo_add[0], (char FAR *)&tmp_edo_add[0], Mppp_cep_ack_edo_add_lgth)) {
						MPPP_DBG_WARNING ("EDO address value changed!");
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						break;
					}

				}

				if (Is_sppp_first_in_bundle ()) {

						/*
							This VALID option must not be sent to our local
							PPP stack.
							We move the next option up, and we adjust the
							remaining length of the packet
						*/

					Memcpy_far ((char FAR *)p_curr_out,
								(char FAR *)p_next_opt,
								(uint)(p_end_data - p_next_opt));

						/*
							Set up pointers so that the "next" option's pointer
							stays at the current option's address
						*/

					p_next_opt	= p_curr_opt = p_curr_out;

				}

					/* Note that the peer negotiated the EDO */

				Sppp_cep_ack_negot	|= LCP_NEG_EDO;
				break;

#			if MPPP_BAP == ON	/* { */

					/*===================================
						Link Discriminator Option (LDO)
					=====================================*/

				case LCP_OPT_LDO:
					MPPP_DBG_DISPLAY ("received LDO(");

					if (! Is_sppp_first_in_bundle()) {

						if (! (Mppp_cep_ack_negot & LCP_NEG_LDO)) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

						if (opt_lgth != LCP_OPT_SZ_SHORT) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

					}

						/* Get and check the LDO value */

					Mppp_get_short (opt_val_ushort, p_octet);
					MPPP_DBG_DISPLAY_INT (opt_val_ushort);
					MPPP_DBG_DISPLAY_STR (")");

						/* The MP is disabled, then we reject this option  */

					if (Mppp_cep_mp_disabled == ON) {
						opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
						return_stop	= TRUE;
						break;
					}

						/* Keep a trace of this option value */

					Sppp_cep_ack_ldo = opt_val_ushort;

						/* Note that the peer negotiated the LDO */

					Sppp_cep_ack_negot	|= LCP_NEG_LDO;
					break;


#			endif	/* MPPP_BAP == ON } */


#			if MPPP_LCP_EXTENSIONS == ON	/* { */


					/*=================================================
									FCS Alernatives
					==================================================*/

				case LCP_OPT_FCS:
					MPPP_DBG_DISPLAY ("received FCS-ALT(");

					if (! Is_sppp_first_in_bundle ()) {

						if (! (Mppp_cep_ack_negot & LCP_NEG_FCS)) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

						if (opt_lgth != LCP_OPT_SZ_BYTE) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

					}


						/* Get the FCS-Alternatives value */

					Mppp_get_char (opt_val_uchar, p_octet);
					MPPP_DBG_DISPLAY_INT (opt_val_uchar);
					MPPP_DBG_DISPLAY_STR (")");

						/* Check the FCS-Alt value */

					if (Is_sppp_first_in_bundle()) {

							/* Keep a trace of this option value */

						Mppp_cep_ack_fcs_alt = opt_val_uchar;

					} else {

						if (opt_val_uchar != Mppp_cep_ack_fcs_alt) {
							MPPP_DBG_WARNING ("FCS-ALT value changed!");
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}
					}

						/* Note that the peer negotiated the FCS-Alternatices */

					Sppp_cep_ack_negot	|= LCP_NEG_FCS;
					break;


					/*=================================================
								Self-Describing-Padding
					==================================================*/

				case LCP_OPT_PADDING:
					MPPP_DBG_DISPLAY ("received PADDING(");

					if (! Is_sppp_first_in_bundle ()) {

						if (! (Mppp_cep_ack_negot & LCP_NEG_PADDING)) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

						if (opt_lgth != LCP_OPT_SZ_BYTE) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

					}


						/* Get the PADDING value */

					Mppp_get_char (opt_val_uchar, p_octet);
					MPPP_DBG_DISPLAY_INT (opt_val_uchar);
					MPPP_DBG_DISPLAY_STR (")");

						/* Check the PADDING value */

					if (Is_sppp_first_in_bundle()) {

							/* Keep a trace of this option value */

						Mppp_cep_ack_max_padding = opt_val_uchar;

					} else {

						if (opt_val_uchar != Mppp_cep_ack_max_padding) {
							MPPP_DBG_WARNING ("PADDING value changed!");
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}
					}

						/* Note that the peer negotiated the PADDING */

					Sppp_cep_ack_negot	|= LCP_NEG_PADDING;
					break;


					/*=====================================
								Compound Frames
					======================================*/

				case LCP_OPT_COMPOUND:
					MPPP_DBG_DISPLAY ("received COMPOUND");

					if (! Is_sppp_first_in_bundle ()) {

						if (! (Mppp_cep_ack_negot & LCP_NEG_COMPOUND)) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

						if (opt_lgth != LCP_OPT_SZ_NULL) {
							opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
							break;
						}

					}

						/* Note that the peer negotiated the COMPOUND Frames */

					Sppp_cep_ack_negot	|= LCP_NEG_COMPOUND;
					break;


#			endif	/* MPPP_LCP_EXTENSIONS } */


			default:
				MPPP_DBG_WARNING ("received unknown option(");
				MPPP_DBG_WARNING_INT (opt_type);
				MPPP_DBG_WARNING_STR (")");

				opt_retcode = MPPP_CP_PCK_CONFIG_REJ;
				break;

		}	/* end of switch */


opt_terminated:

				/*
					The "pack_retcode" reminds us the final return code for
					this packet.

					Options return code are processed in the following order:
					1- Config-REJ'd options ONLY
					2- Config-NAK'd options ONLY
					3- Config-ACK'd options ONLY
				*/

		if ((return_stop == TRUE) || (! Is_sppp_first_in_bundle ())) {

			if ((opt_retcode == MPPP_CP_PCK_CONFIG_ACK) &&
				(pack_retcode != MPPP_CP_PCK_CONFIG_ACK)) {

					/*
						The current option is OK,
						but the previous one wasn't
						--> this current option will not be sent to the peer.
					*/

				continue;

			}

			if (opt_retcode == MPPP_CP_PCK_CONFIG_NAK) {

				if (pack_retcode == MPPP_CP_PCK_CONFIG_REJ) {

						/*
							We want to send back this option in Config-NAK,
							but a previous option must be sent in a
							Config-REJ
							--> this current option will not be sent with the REJ
						*/

					continue;
				}

				if (pack_retcode == MPPP_CP_PCK_CONFIG_ACK) {

						/*
							Up to now, all the options were to be ACK'd,
							but the current option is unacceptable, will be
							NAK'd
							--> the global return code for this packet
							is then set to NAK
						*/

					pack_retcode = MPPP_CP_PCK_CONFIG_NAK;

						/*
							Rewind the output pointer to the beginning
							of the packet, because the type of the packet
							has changed (ACK->NAK)
							--> by now, any option previously added to this packet
							will be ignore
						*/

					p_curr_out	= Mppp_c_prot_p_data;

				}

			}

				/*
					The current option must be Config-REJ'd
					If we have not rejected any option before, in this packet,
					then we need to rewind the output pointer to the beginning
					of the packet
				*/

			if ((opt_retcode == MPPP_CP_PCK_CONFIG_REJ) &&
				(pack_retcode != MPPP_CP_PCK_CONFIG_REJ))	{

				pack_retcode = MPPP_CP_PCK_CONFIG_REJ;
				p_curr_out	= Mppp_c_prot_p_data;

					/* Note that we MUST send a Configure-Reject packet */

				Mppp_c_prot_rej_flag	= ON;

			}

				/*
					If the pointer to the current output location is different
					from the pointer to the current option, then the
					current option must be moved up within the
					packet
				*/

			if (p_curr_out != p_curr_opt) {
				Memcpy_far ((char FAR *)p_curr_out, (char FAR *)p_curr_opt, opt_lgth);
			}

		}

			/* We set the pointer to the next output location */

		if (p_curr_out != p_next_opt) {
			Mppp_inc_ptr (opt_lgth, p_curr_out);
		}

	}	/* end of while */

		/*
			For the first single link PPP negotiation,
			we mark all the received options as negotiated for the
			bundle itself.
		*/

	if (Is_sppp_first_in_bundle ()) {

		if (return_stop == TRUE) {

				/*
					This Configure-Request packet must be rejected
					before there is something going wrong.
				*/

			Sppp_cep_reset_ack_cp_opt ();
		}

		Mppp_cep_ack_negot	= Sppp_cep_ack_negot;

	}

		/*
			Any additional options to be NAK'd, for unsent configuration
			options can be added here.
			This allow us to prompt the peer to include that option in its
			next Configure-Request packet.
		*/

		/* Let's compute the length of the formatted packet */

	Mppp_c_prot_data_size	= (ushort)(p_curr_out - Mppp_c_prot_p_data);

		/* Load the final packet length */

	Mppp_put_short ((Mppp_c_prot_data_size+PPP_PACKET_HEADER_LGTH), p_lgth);

		/*
			We are not responsible for Acking/Naking/Rejecting the
			negotiation on the FIRST member link, except if we receive
			MP options while the MP is disabled on this bundle.
		*/

	if (return_stop == TRUE) {

		MPPP_DBG_LEAVE ();

			/* STOP */

		return (STOP);

	}

	if ((Is_sppp_first_in_bundle ()) || (pack_retcode == MPPP_CP_PCK_CONFIG_ACK)) {

		MPPP_DBG_LEAVE ();

			/* ACK */

		return (OK);

	} else {

		MPPP_DBG_LEAVE ();

			/* NAK or REJ */

		return (NOK);
	}

}

/*-------------------------------------------------------------------------*/

		/*
						==== CHECK-CONFIGURE-ACK-NAK-REJ ====

			This action determines whether a received Configure-Ack/Nak/Rej
			is acceptable or not.
			This routine does not reject any option during the LCP negotiation
			initiated in the first member link.
		*/


		/*-------------------------------------*/

uchar lcp_check_configure_ack ()
{
	MPPP_DBG_FUNC ("lcp_check_configure_ack()")

	uchar	FAR *p_curr;		/* parsing pointer */
	ulong		opt_val_ulong;	/* option 'ulong' value */
	ushort		opt_val_ushort; /* option 'ushort' value */
	int			pack_lgth;		/* remaining length in the packet */
	uchar		opt_type;		/* configuration option type */
	uchar		opt_lgth;		/* configuration option length */
	uchar		opt_val_uchar;	/* option 'uchar' value */
	uchar		result;			/* return code */

	MPPP_DBG_ENTER ();

		/*
			The acknowledged Configuration Options MUST NOT be reordered
			or modified in any way.
		*/

	p_curr		= Mppp_c_prot_p_data;
	pack_lgth	= Mppp_c_prot_data_size;


		/* Check the Ack'd options */

	Lcp_opt_ACK_MRU		(p_curr, Mppp_cep_peer_ack_mru);
	Lcp_opt_ACK_ACCM	(p_curr, 0);	/* We ALWAYS request 0 */
	Lcp_opt_ACK_AUTH	(p_curr, Mppp_cep_peer_ack_auth, PPP_AUTH_ALG_MD5);
	Lcp_opt_ACK_LQM		(p_curr, PPP_PROT_LQR, Mppp_cep_peer_ack_lqr_period);
	Lcp_opt_ACK_MAGIC	(p_curr, Sppp_cep_peer_ack_magic);
	Lcp_opt_ACK_PFC		(p_curr);
	Lcp_opt_ACK_ACFC	(p_curr);
	Lcp_opt_ACK_MRRU	(p_curr, Mppp_cep_peer_ack_mrru);
	Lcp_opt_ACK_SSNHF	(p_curr);
	Lcp_opt_ACK_EDO		(p_curr, Mppp_cep_peer_ack_edo_class, Mppp_cep_peer_ack_edo_add_lgth, &Mppp_cep_peer_ack_edo_add);

#	if MPPP_BAP == ON
		Lcp_opt_ACK_LDO	(p_curr, Sppp_cep_peer_ack_ldo);
#	endif

		/*
			We must have parsed all the Configuration Options we requested.
		*/

	if (pack_lgth != 0) {
		MPPP_DBG_ERROR ("extra options in Config-Ack");
		result	= NOK;
	} else {
		result	= OK;
	}

		/*
			Update the length of the Configure-Ack packet, since we
			should have removed ML PPP specific options
		*/

	Mppp_c_prot_data_size	= (ushort)(p_curr - Mppp_c_prot_p_data);

	if (result == OK) {

		if (Mppp_c_prot_state == MPPP_CP_STATE_ACK_SENT) {

			if ((Mppp_cep_ack_negot & LCP_NEG_MRRU) && (Mppp_cep_peer_ack_negot & LCP_NEG_MRRU)) {

					/* Set the MP as enabled */

				Mppp_cep_mp_enabled	= ON;

				MPPP_DBG_NOTICE ("MP enabled");

			}

		}

	}

	MPPP_DBG_LEAVE ();

	return (result);

opt_ack_error:

		/*
			We detected an error in an Ack'd option (length or values)
		*/

	MPPP_DBG_ERROR ("bad Ack'd option(");
	MPPP_DBG_ERROR_INT   (opt_type);
	MPPP_DBG_ERROR_STR   (")");

	MPPP_DBG_LEAVE ();

	return (NOK);

}

		/*-------------------------------------*/

uchar lcp_check_configure_nak ()
{
	MPPP_DBG_FUNC ("lcp_check_configure_nak()")

	int			pack_lgth;		/* (signed) remaining length in the packet */
	uchar		opt_type;		/* configuration option type */
	uchar		opt_lgth;		/* configuration option length */
	uchar		opt_val_uchar;	/* option 'uchar' value */
	ushort		opt_val_ushort; /* option 'ushort' value */
	ulong		opt_val_ulong;	/* option 'ulong' value */
	uchar	FAR *p_curr;		/* parsing pointer */
	uchar	FAR *p_next_opt;	/* pointer to the next option */
	uchar		result;			/* return code */

	MPPP_DBG_ENTER ();


		/*
			The Nak'd Configuration Options MUST NOT be reordered
		*/

	p_curr		= Mppp_c_prot_p_data;
	pack_lgth	= Mppp_c_prot_data_size;

		/* Check the Nak'd options */

	Lcp_opt_NAK_MRU		(p_curr, Mppp_cep_peer_ack_mru);
	Lcp_opt_NAK_ACCM	(p_curr, 0);	/* We ALWAYS request 0 */
	Lcp_opt_NAK_AUTH	(p_curr, Mppp_cep_peer_ack_auth, PPP_AUTH_ALG_MD5);
	Lcp_opt_NAK_LQM		(p_curr, PPP_PROT_LQR, Mppp_cep_peer_ack_lqr_period);
	Lcp_opt_NAK_MAGIC	(p_curr, Sppp_cep_peer_ack_magic);
	Lcp_opt_NAK_PFC		(p_curr);
	Lcp_opt_NAK_ACFC	(p_curr);
	Lcp_opt_NAK_MRRU	(p_curr, Mppp_cep_peer_ack_mrru);
	Lcp_opt_NAK_SSNHF	(p_curr);
	Lcp_opt_NAK_EDO		(p_curr, Mppp_cep_peer_ack_edo_class, Mppp_cep_peer_ack_edo_add_lgth, &Mppp_cep_peer_ack_edo_add);

#	if MPPP_BAP == ON
		Lcp_opt_NAK_LDO	(p_curr, Sppp_cep_peer_ack_ldo);
#	endif


		/*
			We must have parsed all the Configuration Options we requested.
			The peer may have added some Options it wants us to add in the
			next Configure-Request.
			We don't support this, it is the responsability of the local
			PPP stack to accept this.
		*/

	while (pack_lgth >= LCP_OPT_SZ_NULL) {

		Mppp_get_char (opt_type, p_curr);	/* get the option type */
		Mppp_get_char (opt_lgth, p_curr);	/* get the option length */

		if ((pack_lgth -= opt_lgth) < 0) {
			goto opt_nak_error;
		}

		p_next_opt	= p_curr + opt_lgth - 2;
		p_curr		= p_next_opt;
	}

		/* At this stage, all the packet must have been processed */

	if (pack_lgth != 0) {
		MPPP_DBG_ERROR ("Config-Nak inconsistent packet length");
		result	= NOK;
	} else {
		result	= OK;
	}

	MPPP_DBG_LEAVE ();
	return (result);

opt_nak_error:

		/*
			We detected an error in an Nak'd option (length or values)
		*/

	MPPP_DBG_ERROR ("error in Nak'd option");
	MPPP_DBG_LEAVE ();
	return (NOK);

}

		/*-------------------------------------*/

uchar lcp_check_configure_rej ()
{
	MPPP_DBG_FUNC ("lcp_check_configure_rej()")

	int			pack_lgth;		/* remaining length in the packet */
	uchar		opt_type;		/* configuration option type */
	uchar		opt_lgth;		/* configuration option length */
	uchar		opt_val_uchar;	/* option 'uchar' value */
	ushort		opt_val_ushort; /* option 'ushort' value */
	ulong		opt_val_ulong;	/* option 'ulong' value */
	uchar	FAR *p_curr;		/* parsing pointer */
	uchar		result;			/* return code */

	MPPP_DBG_ENTER ();

		/*
			The rejected Configuration Options MUST NOT be reordered
			or modified in any way.
		*/

	p_curr		= Mppp_c_prot_p_data;
	pack_lgth	= Mppp_c_prot_data_size;

		/* Check the Rej'd options */

	Lcp_opt_REJ_MRU		(p_curr, Mppp_cep_peer_ack_mru);
	Lcp_opt_REJ_ACCM	(p_curr, 0);	/* We ALWAYS request 0 */
	Lcp_opt_REJ_AUTH	(p_curr, Mppp_cep_peer_ack_auth, PPP_AUTH_ALG_MD5);
	Lcp_opt_REJ_LQM		(p_curr, PPP_PROT_LQR, Mppp_cep_peer_ack_lqr_period);
	Lcp_opt_REJ_MAGIC	(p_curr, Sppp_cep_peer_ack_magic);
	Lcp_opt_REJ_PFC		(p_curr);
	Lcp_opt_REJ_ACFC	(p_curr);
	Lcp_opt_REJ_MRRU	(p_curr, Mppp_cep_peer_ack_mrru);
	Lcp_opt_REJ_SSNHF	(p_curr);
	Lcp_opt_REJ_EDO		(p_curr, Mppp_cep_peer_ack_edo_class, Mppp_cep_peer_ack_edo_add_lgth, &Mppp_cep_peer_ack_edo_add);

#	if MPPP_BAP == ON
		Lcp_opt_REJ_LDO	(p_curr, Sppp_cep_peer_ack_ldo);
#	endif

		/*
			We must have parsed all the Configuration Options we requested.
		*/

	if (pack_lgth != 0) {
		MPPP_DBG_ERROR ("extra options in Config-Rej");
		result	= NOK;
	} else {
		result	= OK;
	}

	MPPP_DBG_LEAVE ();
	return (result);

opt_rej_error:

		/*
			We detected an error in an Ack'd option (length or values)
		*/

	MPPP_DBG_ERROR ("error in Rej'd option");
	MPPP_DBG_LEAVE ();
	return (NOK);

}

		/*-------------------------------------*/

uchar lcp_check_configure_ack_nak_rej ()
{
	MPPP_DBG_FUNC ("lcp_check_configure_ack_nak_rej()")
	uchar	result;

	MPPP_DBG_ENTER ();

	result	= NOK;

	if (Mppp_c_prot_r_packet_id == Mppp_c_prot_s_packet_id) {

			/*
				The packet ID MUST match that of the last transmitted
				Config-Req
			*/

			/* Check Configure-Ack */

		if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_ACK) {
			result = lcp_check_configure_ack ();
		}

			/* Check Configure-Nak */

		if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_NAK) {
			result = lcp_check_configure_nak ();
		}

			/* Check Configure-Rej */

		if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_REJ) {
			result = lcp_check_configure_rej ();
		}

	}

	MPPP_DBG_LEAVE ();

	return (result);

}

/*-------------------------------------------------------------------------*/

/* EOF */

