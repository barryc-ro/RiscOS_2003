
/*--------------------------------------------------------------------------*
 *						 M O D U L E   H E A D E R
 *
 * filename - mppp_cp.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s) : control protocols state machines functions.
 *
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    Multi Link PPP Entity                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1997 by OMNITEL SA                 |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "mppp.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#include "mppp_ext.h"

		/* Additional header files */

#include "lcp.h"
#include "mp.h"

/*--------------------------------------------------------------------------*/

		/* Local Functions prototypes */

#if NEW_FCT_STYLE == ON

	uchar	check_user_configure_request		(void);
	uchar	check_user_configure_ack_nak_rej	(void);
	uchar	check_peer_configure_ack_nak_rej	(void);

	void	mppp_c_prot_state_machine_1			(void);
	void	mppp_c_prot_state_machine_2			(void);

	void	mppp_c_prot_set_state_1				(uchar state, code_t event, uchar direction);

	void	mppp_c_prot_state_initial			(void);
	void	mppp_c_prot_state_starting			(void);
	void	mppp_c_prot_state_closed			(void);
	void	mppp_c_prot_state_stopped			(void);
	void	mppp_c_prot_state_closing			(void);
	void	mppp_c_prot_state_stopping			(void);
	void	mppp_c_prot_state_request_sent		(void);
	void	mppp_c_prot_state_ack_received		(void);
	void	mppp_c_prot_state_ack_sent			(void);
	void	mppp_c_prot_state_opened			(void);

#else

	uchar	check_user_configure_request		();
	uchar	check_user_configure_ack_nak_rej	();
	uchar	check_peer_configure_ack_nak_rej	();

	void	mppp_c_prot_state_machine_1			();
	void	mppp_c_prot_state_machine_2			();

	void	mppp_c_prot_set_state_1				();

	void	mppp_c_prot_state_initial			();
	void	mppp_c_prot_state_starting			();
	void	mppp_c_prot_state_closed			();
	void	mppp_c_prot_state_stopped			();
	void	mppp_c_prot_state_closing			();
	void	mppp_c_prot_state_stopping			();
	void	mppp_c_prot_state_request_sent		();
	void	mppp_c_prot_state_ack_received		();
	void	mppp_c_prot_state_ack_sent			();
	void	mppp_c_prot_state_opened			();

#endif


/*--------------------------------------------------------------------------*/

		/* Local macros */


#define	Set_first_link_c_prot_state(state,event,direction)		\
					mppp_c_prot_set_state_1(state,event,direction)

/*--------------------------------------------------------------------------*/

		/* Array of implicit timers values */

	CONST timer_val_t	mppp_c_prot_ti_val_i[]	= {MPPP_CP_RESTART_TI_VAL_I};


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_c_prot_state_machine	- ML PPP state machine for all the
					Control Protocols.

Usage			void mppp_c_prot_state_machine (void);

Return value :	returns void

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

void mppp_c_prot_state_machine ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_machine()")

	code_t	initial_event_id;

	MPPP_DBG_ENTER ();

	if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

		if (Is_sppp_first_in_bundle ()) {

			if (Mppp_c_prot_state == MPPP_CP_STATE_INITIAL) {

				mppp_c_prot_state_initial ();

			}

				/* Call the 1st member link's state machine */

			mppp_c_prot_state_machine_1 ();

				/*
					Make additional processing on the other member links
					according to the event we received on the 1st member
					link.
				*/

			switch ((initial_event_id = mppp_c_prot_event_id)) {

				case MPPP_CP_EV_RCV_CFG_ACK:

					if (Mppp_c_prot_state == MPPP_CP_STATE_OPENED) {

							/* Reset bundle's counters */

						mp_reinit_ctx ();

						if ((Sppp_cep_link_phase == SPPP_LINK_PHASE_NETWORK) &&
							(Mppp_cep_mp_enabled == ON) &&
							(Mppp_cep_used_sppp_nb < Mppp_cep_min_sppp_nb)) {

								/*
									The 1st member link is just OPENED
									Try another connection now.
								*/

							mppp_access_next_sppp_in_bundle ();

							for ( ;((p_sppp_cep != P_NIL) && (Mppp_cep_used_sppp_nb < Mppp_cep_min_sppp_nb));
									mppp_access_next_sppp_in_bundle ()) {

								p_mppp_c_prot = Sppp_cep_p_lcp_info;

#								if MPPP_CC == ON /* { */

									if (Sppp_cep_cc_entity_id != ENT_NIL) {

										if (Sppp_cep_cc_state == MPPP_CC_STATE_NULL) {

												/* Make another call */

											if (mppp_make_cc_call_rq () == OK) {

													/* Signal the OPEN event to the state machine */

												mppp_event_type = MPPP_EV_TYPE_LCP;
												mppp_c_prot_event_id = MPPP_CP_EV_OPEN;

												mppp_c_prot_state_machine ();

											}

										}


									} else

#								endif	/* MPPP_CC == ON } */

									/* No additional code here */

								{

											/*
												No call to make
												Signal the OPEN event to
												the state machine
											*/

										Set_c_prot_state_initial;

											/* Reset the link phase */

										Set_sppp_cep_link_phase (SPPP_LINK_PHASE_DEAD);

										mppp_c_prot_event_id = MPPP_CP_EV_OPEN;

										mppp_c_prot_state_machine_2 ();


								}


							}



								/* Restore the initial member link context */

							mppp_access_first_sppp_in_bundle ();

							p_mppp_c_prot = Sppp_cep_p_lcp_info;

								/* Restore the initial event ID */

							mppp_c_prot_event_id	= initial_event_id;

						}


					}
					break;


				case MPPP_CP_EV_RCV_CFG_RQ:
				case MPPP_CP_EV_RCV_TERM_RQ:


						/*
							1- Reconfiguration of the first member link while
							   in OPENED state.

							2- Received the Terminate-Request packet, from the
							   peer system or from the local user.

							---> We signal the CLOSE Event on the other links
						*/

					if (initial_event_id == MPPP_CP_EV_RCV_TERM_RQ) {

							/* Update the link phase */

						Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

					} else if (initial_event_id == MPPP_CP_EV_RCV_CFG_RQ) {

							/* Update the link phase */

						Set_sppp_cep_link_phase (SPPP_LINK_PHASE_ESTABLISHMENT);
					}

					if (Mppp_cep_used_sppp_nb > 1) {

						mppp_access_next_sppp_in_bundle ();

						for ( ;p_sppp_cep != P_NIL; mppp_access_next_sppp_in_bundle ()) {

							p_mppp_c_prot	= Sppp_cep_p_lcp_info;

							mppp_c_prot_event_id = MPPP_CP_EV_CLOSE;

							mppp_c_prot_state_machine_2 ();

							if (initial_event_id == MPPP_CP_EV_RCV_TERM_RQ) {

									/* Update the link phase */

								Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

							} else if (initial_event_id == MPPP_CP_EV_RCV_CFG_RQ) {

									/* Update the link phase */

								Set_sppp_cep_link_phase (SPPP_LINK_PHASE_ESTABLISHMENT);
							}

						}

							/* Restore the initial member link context */

						mppp_access_first_sppp_in_bundle ();
						p_mppp_c_prot = Sppp_cep_p_lcp_info;

							/* Restore the initial event ID */

						mppp_c_prot_event_id	= initial_event_id;
					}
					break;

				default:
					break;

			}


		} else {

				/* Other member links' state machine (context dependent) */

			mppp_c_prot_state_machine_2 ();

		}

	}

		/* !!! else follows ... */

#	if MPPP_BAP == ON	/* { */

		else if (Mppp_c_prot_ppp_pid == PPP_PROT_BACP) {

			mppp_c_prot_state_machine_2 ();

		}

#	endif	/* MPPP_BAP == ON } */

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_c_prot_update_bandwidth - ensures the updates of the total
					bandwidth according to the link state.

Usage			void mppp_c_prot_update_bandwidth (uchar was_opened);

Return value :	returns void

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

void mppp_c_prot_update_bandwidth (was_opened)
	uchar	was_opened;

{
	MPPP_DBG_FUNC ("mppp_c_prot_update_bandwidth()")


	MPPP_DBG_ENTER ();

	if ((p_mppp_cep == P_NIL) || (p_sppp_cep == P_NIL)) {

		MPPP_DBG_ERROR ("no context for this operation");

#		if ASSERT == ON
			Trap (TRAP_MPPP_NO_CONTEXT, "mppp_c_prot_update_bandwidth");
#		endif

	}

		/* Check if the bundle bandwidth must be DECREASED */

	if ((was_opened == TRUE) && (Sppp_cep_link_phase != SPPP_LINK_PHASE_NETWORK)) {

#		if ASSERT == ON

				/* Check the consistency of the link speed values */

			if (Mppp_cep_sppp_total_link_speed < Sppp_cep_link_speed) {
				Trap (TRAP_MPPP_BUNDLE_CHECK, "mppp_c_prot_update_bandwidth");
			}

#		endif

			/* Decrease the bundle bandwidth */

		Mppp_cep_sppp_total_link_speed	-= Sppp_cep_link_speed;

			/* Decrease the number of OPENED links */

		Mppp_cep_opened_sppp_nb--;

	}

		/* Check if the bundle bandwidth must be INCREASED */

	if ((was_opened == FALSE) && (Sppp_cep_link_phase == SPPP_LINK_PHASE_NETWORK)) {

			/* Increase the bundle bandwidth */

		Mppp_cep_sppp_total_link_speed	+= Sppp_cep_link_speed;

			/* Increase the number of OPENED links */

		Mppp_cep_opened_sppp_nb++;

			/* Signal the availability of the new member link */

		if (! Is_sppp_first_in_bundle ()) {

			if (Sppp_cep_link_add_rq_flag == ON) {
				mppp_snd_ext_add_link_in_co (MPPP_EXT_ADD_LINK_CO);
			}else {
				mppp_snd_ext_add_link_in_co (MPPP_EXT_ADD_LINK_IN);
			}

		}

	}

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_c_prot_state_machine_1 - ML PPP state machine for all the
					Control Protocols, on the first member link ONLY.

Usage			void mppp_c_prot_state_machine_1 (void);

Return value :	returns void

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

void mppp_c_prot_state_machine_1 ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_machine_1()")

	uchar	FAR *p_start_data;
	ushort		data_size;
	code_t		msg_code;
	code_t		current_event;	/* current CP event ID */
	uchar		current_state;	/* current CP state */
	uchar		was_opened;		/* signal if the LCP was in OPENED state */

	MPPP_DBG_ENTER ();

	msg_code	= EV_NIL;
	was_opened	= FALSE;

	if (p_mppp_c_prot == P_NIL) {

		MPPP_DBG_ERROR ("p_mppp_c_prot is P_NIL");

#		if ASSERT == ON
			Trap (TRAP_MPPP_NO_CONTEXT, "mppp_c_prot_state_machine_1");
#		endif

		MPPP_DBG_LEAVE ();
		return;
	}

		/*
			Set the OPENED state indicator which is used to detect any
			change in the bundle's bandwidth
		*/

	if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {
		was_opened		= (Sppp_cep_link_phase == SPPP_LINK_PHASE_NETWORK) ? TRUE : FALSE;
	}

		/* Set the state variables to be used for updating the CP state */

	current_state	= Mppp_c_prot_state;
	current_event	= mppp_c_prot_event_id;

		/* Set the pointer to frame data start and the frame size */

	p_start_data	= R_a_data;
	data_size		= R_data_size;


		/*
			If the packet is conveyed within the message data area,
			check if there is enough room left for MP options.
		*/

	if ((p_buffer == P_NIL) &&
		(Mppp_cep_msg_direction == MPPP_FROM_LOCAL_USER) &&
		((Message_data_lgth - (R_msg_data_size + (R_msg_a_start_data - R_msg_a_first_data))) < (3 + Mppp_cep_edo_add_lgth + (2*LCP_OPT_SZ_SHORT)))) {

			/* Allocate a buffer */

		Buffer_alloc;

			/* Maintain the extra data offset */

		Buffer_data_offset	+= (ushort)(R_msg_a_start_data - R_msg_a_first_data);

			/* Move Control Protocol data from the message to the buffer */

		Memcpy_far ((char FAR *)Buffer_a_start_data, (char FAR *)p_start_data, data_size);
		Buffer_data_size	= data_size;
		R_msg_data_size		= 0;

			/* Link the message to the buffer */

		R_msg_init_link_buffer;

			/*
				The following pointer is set to the address of the
				first Control Protocol option.

				The PPP frame header and PPP packet header have been
				checked and skipped before.
			*/

		Mppp_c_prot_p_data	= (Buffer_a_start_data + PPP_PACKET_HEADER_LGTH + PPP_FRAME_HEADER_LGTH);

			/* Set up the new start data address */

		p_start_data	= R_a_data;

	}


		/* Dispatch event according to the current event */

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_UP:

			if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

				msg_code	= MPPP_ACT_IN;

					/* Update the link phase */

				Set_sppp_cep_link_phase (SPPP_LINK_PHASE_ESTABLISHMENT);
			}

				/* Continue. No break */

		case MPPP_CP_EV_DOWN:

			if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

				if (msg_code == EV_NIL) {

					msg_code = MPPP_DEA_IN;

						/* Update the link phase */

					Set_sppp_cep_link_phase (SPPP_LINK_PHASE_DEAD);

				}

					/* Retransmit this "activation" message to the upper entity */

				p_snd_msg	= p_rcv_msg;
				p_rcv_msg	= P_NIL;

				S_msg_nai	= Mppp_na_nai;
				S_msg_add	= Mppp_cep_ces;

					/*
						Forward this Link (de)activation indication to
						the upper layer
					*/

				mppp_snd_msg_to_user (Mppp_sap_data_upper_entity_id, Mppp_sap_data_sapi, msg_code);
			}
			break;


		case MPPP_CP_EV_OPEN:
		case MPPP_CP_EV_CLOSE:

			if (Sppp_cep_cc_entity_id == ENT_NIL) {

				if (mppp_c_prot_event_id == MPPP_CP_EV_OPEN) {
					mppp_act_dea_lower_layer (Sppp_cep_data_entity_id, ON);
				} else {
					mppp_act_dea_lower_layer (Sppp_cep_data_entity_id, OFF);
				}

			}
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:

			if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

					/* Update the link phase */

				Set_sppp_cep_link_phase (SPPP_LINK_PHASE_ESTABLISHMENT);

			}

			if (Mppp_cep_msg_direction == MPPP_FROM_PEER) {

					/* Reset the ACCM to the Peer */

				Mppp_cep_accm_to_peer	= Mppp_link_mode_accm (Sppp_cep_link_mode);

					/* Configure-Request from the peer */

				if (Mppp_c_prot_state == MPPP_CP_STATE_STOPPED) {

					Mppp_c_prot_init_restart_counter ();

					if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

							/* Reset the ACCM to the Local PPP stack */

						Mppp_cep_accm_to_local	= (Mppp_sap_data_sapi == MPPP_SAPI_DATA_SYNC) ? LCP_SYNC_ACCM_I : LCP_ASYNC_ACCM_I;

					}

				}


					/* Display the RX (4th parameter is OFF) packet data */

				MPPP_DBG_PACKETS (p_start_data, data_size, 0, OFF);

					/*
						If we have received MP specific options while the
						MP is disabled for the bundle, then we send a
						Configure-Reject for the MP options we received.
					*/

				if (Mppp_c_prot_check_configure_request () == STOP) {
					Mppp_c_prot_send_configure_nak_rej ();
					break;
				}

					/*
						Update the final size of the buffer we transmit
						to the local PPP stack
					*/

				data_size = (Mppp_c_prot_data_size + PPP_PACKET_HEADER_LGTH + PPP_FRAME_HEADER_LGTH);

					/* Set up the pointer to message to send */

				if (p_buffer != P_NIL) {
					Buffer_data_size	= data_size;
				} else {
					R_msg_data_size		= (uchar)data_size;
				}

				p_snd_msg = p_rcv_msg;
				p_rcv_msg = P_NIL;

					/* Send this packet up */

				mppp_snd_data_msg_to_local (Mppp_sap_data_upper_entity_id, Mppp_cep_accm_to_local);

			} else if (Mppp_cep_msg_direction == MPPP_FROM_LOCAL_USER) {

					/* Reset the ACCM to the Local PPP stack */

				Mppp_cep_accm_to_local	= (Mppp_sap_data_sapi == MPPP_SAPI_DATA_SYNC) ? LCP_SYNC_ACCM_I : LCP_ASYNC_ACCM_I;

					/* We add Multilink specific options in the packet */

				check_user_configure_request ();

					/*
						Update the final size of the buffer we transmit
						to the local PPP stack
					*/

				data_size = (Mppp_c_prot_data_size + PPP_PACKET_HEADER_LGTH + PPP_FRAME_HEADER_LGTH);

					/* Display the TX (4th parameter is ON) packet data */

				MPPP_DBG_PACKETS (p_start_data, data_size, 0, ON);

				if (p_buffer != P_NIL) {
					Buffer_data_size	= data_size;
				} else {
					R_msg_data_size		= (uchar)data_size;
				}

					/* Set up the pointer to message to send */

				p_snd_msg = p_rcv_msg;
				p_rcv_msg = P_NIL;

					/* Queue this message */

				mppp_in_sppp_tx_queue ();


					/* Send the packet to the peer system */

				mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_link_mode_accm (Sppp_cep_link_mode));
			}
			break;

		case MPPP_CP_EV_RCV_CFG_ACK:
		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:

			if (Mppp_cep_msg_direction == MPPP_FROM_PEER) {

					/* Display the RX (4th parameter is OFF) packet data */

				MPPP_DBG_PACKETS (p_start_data, data_size, 0, OFF);

					/* Configure-Ack/Nak/Rej from the peer */

				if (check_peer_configure_ack_nak_rej () == OK) {
					Mppp_c_prot_init_restart_counter ();
				}

					/*
						Update the final size of the buffer we transmit
						to the local PPP stack
					*/

				data_size = (Mppp_c_prot_data_size + PPP_PACKET_HEADER_LGTH + PPP_FRAME_HEADER_LGTH);

					/* Set up the pointer to message to send */

				if (p_buffer != P_NIL) {
					Buffer_data_size	= data_size;
				} else {
					R_msg_data_size		= (uchar)data_size;
				}

				p_snd_msg = p_rcv_msg;
				p_rcv_msg = P_NIL;

					/* Send the packet up */

				mppp_snd_data_msg_to_local (Mppp_sap_data_upper_entity_id, Mppp_cep_accm_to_local);

				if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_ACK) {

						/*
							If the ACCM has been negotiated, then we update the
							global ACCM value to LOCAL PPP
						*/

					if (Sppp_cep_peer_ack_negot & LCP_NEG_ACCM) {
						Mppp_cep_accm_to_local	= Mppp_cep_peer_ack_accm;
					}

				}

			} else if (Mppp_cep_msg_direction == MPPP_FROM_LOCAL_USER) {

					/* We add Multilink specific options in the packet */

				if (check_user_configure_ack_nak_rej () == OK) {
					Mppp_c_prot_init_restart_counter ();
				}

					/*
						Update the final size of the buffer we transmit
						to the local PPP stack
					*/

				data_size = (Mppp_c_prot_data_size + PPP_PACKET_HEADER_LGTH + PPP_FRAME_HEADER_LGTH);

					/* Display the TX (4th parameter is ON) packet data */

				MPPP_DBG_PACKETS (p_start_data, data_size, 0, ON);

					/* Set up the pointer to message to send */

				if (p_buffer != P_NIL) {
					Buffer_data_size	= data_size;
				} else {
					R_msg_data_size		= (uchar)data_size;
				}

				p_snd_msg = p_rcv_msg;
				p_rcv_msg = P_NIL;

					/* Queue this message */

				mppp_in_sppp_tx_queue ();


					/* Send the packet to the peer */

				mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_link_mode_accm (Sppp_cep_link_mode));

				if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_ACK) {

						/*
							If the ACCM has been negotiated, then we update the
							global ACCM value to LOCAL PPP
						*/

					if (Sppp_cep_ack_negot & LCP_NEG_ACCM) {
						Mppp_cep_accm_to_peer	= Mppp_cep_ack_accm;
					}

				}

			}
			break;


		default:

			if (Mppp_cep_msg_direction == MPPP_FROM_PEER) {

					/* Set up the pointer to message to send */

				p_snd_msg = p_rcv_msg;
				p_rcv_msg = P_NIL;

					/* Forward the packet up */

				mppp_snd_data_msg_to_local (Mppp_sap_data_upper_entity_id, Mppp_cep_accm_to_local);

				if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_TERM_RQ) {

					if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

							/* Update the link phase */

						Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

					}

					MPPP_DBG_NOTICE ("received Terminate-Request on 1st Link");

				}

			} else if (Mppp_cep_msg_direction == MPPP_FROM_LOCAL_USER) {

					/* Set up the pointer to message to send */

				p_snd_msg = p_rcv_msg;
				p_rcv_msg = P_NIL;

					/* Queue this message */

				mppp_in_sppp_tx_queue ();


					/* Forward the packet to the peer */

				mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_cep_accm_to_peer);

					/*
						Our user entity is requesting the termination of
						the first member link.
					*/

				if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_TERM_RQ) {

					if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

							/* Update the link phase */

						Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

					}

					MPPP_DBG_NOTICE ("sent Terminate-Request on 1st Link");

				}

			}
			break;

	}

		/* Set the new CP state */

	Set_first_link_c_prot_state (current_state, current_event, Mppp_cep_msg_direction);

		/* Check if the bundle bandwidth must be updated */

	if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

		mppp_c_prot_update_bandwidth (was_opened);

	}

	MPPP_DBG_LEAVE ();
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_c_prot_state_machine_2 - ML PPP state machine for all the
					Control Protocols. For LCP, applies only to not-first
					member links.

Usage			void mppp_c_prot_state_machine_2 (void);

Return value :	returns void

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

void mppp_c_prot_state_machine_2 ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_machine_2()")

	uchar		send_drop_in_co;
	code_t		drop_code;
	uchar		was_opened;		/* signal if the LCP was in OPENED state */
	uchar		drop_origin;	/* origination of the Link Drop */

	MPPP_DBG_ENTER ();

	send_drop_in_co	= OFF;
	drop_code		= EV_NIL;
	was_opened		= FALSE;

	if (p_mppp_c_prot == P_NIL) {

		MPPP_DBG_ERROR ("p_mppp_c_prot is P_NIL");

#		if ASSERT == ON
			Trap (TRAP_MPPP_NO_CONTEXT, "mppp_c_prot_state_machine_2");
#		endif

		MPPP_DBG_LEAVE ();
		return;
	}

		/*
			Set the OPENED state indicator which is used to detect any
			change in the bundle's bandwidth
		*/

	if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

		was_opened		= (Sppp_cep_link_phase == SPPP_LINK_PHASE_NETWORK) ? TRUE : FALSE;

	}

		/* Dispatch event according to the current state */


	switch (Mppp_c_prot_state) {

		case MPPP_CP_STATE_INITIAL:
			mppp_c_prot_state_initial ();
			break;

		case MPPP_CP_STATE_STARTING:
			mppp_c_prot_state_starting ();
			break;

		case MPPP_CP_STATE_CLOSED:
			mppp_c_prot_state_closed ();
			break;

		case MPPP_CP_STATE_STOPPED:
			mppp_c_prot_state_stopped ();
			break;

		case MPPP_CP_STATE_CLOSING:
			mppp_c_prot_state_closing ();
			break;

		case MPPP_CP_STATE_STOPPING:
			mppp_c_prot_state_stopping ();
			break;

		case MPPP_CP_STATE_REQUEST_SENT:
			mppp_c_prot_state_request_sent ();
			break;

		case MPPP_CP_STATE_ACK_RECEIVED:
			mppp_c_prot_state_ack_received ();
			break;

		case MPPP_CP_STATE_ACK_SENT:
			mppp_c_prot_state_ack_sent ();
			break;

		case MPPP_CP_STATE_OPENED:
			mppp_c_prot_state_opened ();
			break;

		default:
			MPPP_DBG_ERROR ("unknown CP state");
			break;

	}

		/* Specific processing for LCP events */

	if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

			/* The Link is Up */

		if (mppp_c_prot_event_id == MPPP_CP_EV_UP) {

				/* Update the link phase */

			Set_sppp_cep_link_phase (SPPP_LINK_PHASE_ESTABLISHMENT);

		}

			/* The Link is Down */

		if (mppp_c_prot_event_id == MPPP_CP_EV_DOWN) {

				/* Update the link phase */

			Set_sppp_cep_link_phase (SPPP_LINK_PHASE_DEAD);

				/* Stop the LCP Restart timer */

			Mppp_c_prot_stop_timer (MPPP_LCP_TI_X_RESTART);

		}

		if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_TERM_RQ) {

				/* Update the link phase */

			Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

		}

			/* Check if the bundle bandwidth must be updated */

		mppp_c_prot_update_bandwidth (was_opened);

			/* The Link is Down */

		if (mppp_c_prot_event_id == MPPP_CP_EV_DOWN) {

				/* Reset the member link Tx queue */

			mppp_discard_sppp_tx_queue ();

				/* Reset the sent packets identifiers */

			Mppp_c_prot_s_packet_id		= 0;


				/*
					The lower layer is down.
					If the Link DROP has been requested, then we clear
					this call.
				*/


#			if MPPP_CC == ON	/* { */

					/* We request the ISDN call clearance if necessary */

				if (Sppp_cep_cc_entity_id != ENT_NIL) {

					if (Sppp_cep_cc_state == MPPP_CC_STATE_NULL) {

							/*
								Call already cleared. We send the Drop
								event now
							*/

						send_drop_in_co	= ON;

					} else if (Sppp_cep_link_drop_rq_flag == ON) {

						mppp_clear_cc_call_rq ();

					}

				} else

#			endif	/* MPPP_CC == ON } */

				/* No additional code here */

			{

					/*
						No ISDN call to clear
						Send immediate Drop event to the upper entity
					*/

				send_drop_in_co	= ON;

			}

				/* Any Drop event to send up ? */

			if (send_drop_in_co == ON) {

				if (Sppp_cep_link_drop_rq_flag == ON) {
					drop_code	= MPPP_EXT_DROP_LINK_CO;
					drop_origin	= MPPP_ORIGIN_USER;
				} else {
					drop_code	= MPPP_EXT_DROP_LINK_IN;
					drop_origin	= (Mppp_cep_msg_direction == MPPP_FROM_PEER) ? MPPP_ORIGIN_PEER : MPPP_ORIGIN_PROVIDER;
				}

					/* Format and send the Drop event */

				mppp_snd_ext_drop_link_in_co (drop_code,
											MPPP_CAUSE_DISC_NORM,
											MPPP_DIAG_NO_INFO,
											drop_origin);

			}

		}

	}

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_c_prot_set_state_1 implements the setting of the first
					member link Control Protocol states.

Usage			void mppp_c_prot_set_state_1 (uchar state, code_t event,
												uchar origin);

Description		This routine considers the currently received CP event, from
				the local user or from the peer system, and then updates the
				CP state accordingly.


Return value	 void

Common constants and declarations : mppp.h

Common objects : current p_mppp_c_prot pointer.

*--------------------------------------------------------------------------*/

void mppp_c_prot_set_state_1 (state, event_code, origin)
	uchar	state;		/* current CP state */
	code_t	event_code;	/* currently received CP event */
	uchar	origin;		/* event origin */
{
	MPPP_DBG_FUNC ("mppp_c_prot_set_state_1()")


	MPPP_DBG_ENTER ();


		/* Dispatch according to the received LCP event */

	switch (event_code) {

		case MPPP_CP_EV_UP:

			if (state == MPPP_CP_STATE_INITIAL) {

				Set_c_prot_state_closed;

				if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {

						/* Update the link phase */

					Set_sppp_cep_link_phase (SPPP_LINK_PHASE_ESTABLISHMENT);

				}

			}
			break;


		case MPPP_CP_EV_DOWN:

			switch (state) {

				case MPPP_CP_STATE_CLOSED:
				case MPPP_CP_STATE_CLOSING:
					Set_c_prot_state_initial;
					break;

				case MPPP_CP_STATE_STOPPED:
				case MPPP_CP_STATE_STOPPING:
				case MPPP_CP_STATE_REQUEST_SENT:
				case MPPP_CP_STATE_ACK_RECEIVED:
				case MPPP_CP_STATE_ACK_SENT:
				case MPPP_CP_STATE_OPENED:
					Set_c_prot_state_starting;
					break;


			}
			break;


		case MPPP_CP_EV_OPEN:

			if (state == MPPP_CP_STATE_INITIAL) {
				Set_c_prot_state_starting;
			}
			break;


		case MPPP_CP_EV_CLOSE:
			break;


		case MPPP_CP_EV_RCV_CFG_RQ:

			if (origin == MPPP_FROM_LOCAL_USER) {

				if (state != MPPP_CP_STATE_ACK_SENT) {
					Set_c_prot_state_request_sent;
				}

			} else if (origin == MPPP_FROM_PEER) {

					/*
						Specific transition state to indicate receipt, from
						the peer, of a Configure-Request packet on the
						first member link.
					*/

				if (state != MPPP_CP_STATE_ACK_RECEIVED) {
					Set_c_prot_state_request_received;
				}

			}
			break;


		case MPPP_CP_EV_RCV_CFG_ACK:

			if (origin == MPPP_FROM_LOCAL_USER) {

				if (state == MPPP_CP_STATE_ACK_RECEIVED) {

					Set_c_prot_state_opened;

						/*
							In order to interoperate with systems running the
							RFC 1717 MP, we accept the Multilink Protocol negotiation
							based on MRRU, SSNHF or both.

							But, according to RFC 1990, we NEVER send the SSNHF
							option by itself to negotiate the Multilink Protocol.
						*/

					if (((Mppp_cep_ack_negot & LCP_NEG_MRRU) || (Mppp_cep_ack_negot & LCP_NEG_SSNHF)) &&
						(Mppp_cep_peer_ack_negot & LCP_NEG_MRRU)) {

							/* Set the MP as enabled */

						Mppp_cep_mp_enabled		= ON;
						Mppp_cep_mp_rejected	= OFF;

						MPPP_DBG_NOTICE ("MP enabled");

					}

						/*
							Check for the successful negotiation of BAP
							specific LCP option (Link Discriminator)
						*/

#					if MPPP_BAP == ON	/* MPPP_BAP == ON */

						if (Mppp_cep_ack_negot & LCP_NEG_LDO) {

								/* Set the BACP as enabled */

							Mppp_cep_bacp_enabled	= ON;
							Mppp_cep_bacp_rejected	= OFF;

							MPPP_DBG_NOTICE ("BACP enabled");

						}

#					endif	/* MPPP_BAP == ON } */

				} else {

					Set_c_prot_state_ack_sent;

				}

			} else if (origin == MPPP_FROM_PEER) {

				if (state == MPPP_CP_STATE_ACK_SENT) {

					Set_c_prot_state_opened;

						/*
							In order to interoperate with systems running the
							RFC 1717 MP, we accept the Multilink Protocol negotiation
							based on MRRU, SSNHF or both.

							But, according to RFC 1990, we NEVER send the SSNHF
							option by itself to negotiate the Multilink Protocol.
						*/

					if (((Mppp_cep_ack_negot & LCP_NEG_MRRU) || (Mppp_cep_ack_negot & LCP_NEG_SSNHF)) &&
						(Mppp_cep_peer_ack_negot & LCP_NEG_MRRU)) {

							/* Set the MP as enabled */

						Mppp_cep_mp_enabled		= ON;
						Mppp_cep_mp_rejected	= OFF;

						MPPP_DBG_NOTICE ("MP enabled");

					}

						/*
							Check for the successful negotiation of BAP
							specific LCP option (Link Discriminator)
						*/

#					if MPPP_BAP == ON	/* MPPP_BAP == ON */

						if (Mppp_cep_ack_negot & LCP_NEG_LDO) {

								/* Set the BACP as enabled */

							Mppp_cep_bacp_enabled	= ON;
							Mppp_cep_bacp_rejected	= OFF;

							MPPP_DBG_NOTICE ("BACP enabled");

						}

#					endif	/* MPPP_BAP == ON } */

				} else {

					Set_c_prot_state_ack_received;

				}

			}
			break;


		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
			break;


		case MPPP_CP_EV_RCV_TERM_RQ:
		case MPPP_CP_EV_RCV_TERM_ACK:

			if (state == MPPP_CP_STATE_OPENED) {

					/* Just to leave the OPENED state */

				Set_c_prot_state_term_received;

					/* Update the link phase */

				Set_sppp_cep_link_phase (SPPP_LINK_PHASE_TERMINATION);

			}
			break;


		default:
			break;

	}


	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			 All the following functions implement the execution of a
				 received event (external or internal, servicing queue,
				 expiry of timers, receiver busy condition) according to the
				 state of the automaton.

Usage			 void mppp_c_prot_state_xxxxxx (void);

Description


Return value	 void

Common constants and declarations : mppp.h

Common objects : current p_mppp_c_prot pointer.

*--------------------------------------------------------------------------*/

		/* THESE STATES ARE THOSE DEFINED IN THE RFC 1661 */

		/*
						STATE 0: INITIAL

			In the INITIAL state, the lower layer is unavailable (DOWN),
			and no OPEN has occured. The Restart timer is not running in
			the INITIAL state.
		*/

void mppp_c_prot_state_initial ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_initial()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_UP:
			Set_c_prot_state_closed;
			break;

		case MPPP_CP_EV_OPEN:
			Mppp_c_prot_this_layer_started ();
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_CLOSE:
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();
}

/*--------------------------------------------------------------------------*/

		/*

						STATE 1: STARTING

			The STARTING state is the Open counterpart to the INITIAL state.
			An administrative Open has been initiated, but the lower layer is
			still unavailable (DOWN). The Restart timer is not running in
			the STARTING state.
		*/

void mppp_c_prot_state_starting ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_starting()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_UP:
			Mppp_c_prot_init_restart_counter ();
			Mppp_c_prot_send_configure_request ();
			Set_c_prot_state_request_sent;
			break;

		case MPPP_CP_EV_OPEN:
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_CLOSE:
			Mppp_c_prot_this_layer_finished ();
			Set_c_prot_state_initial;
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();
}

/*--------------------------------------------------------------------------*/

		/*
						STATE 2: CLOSED

			In the CLOSED state, the link is available (UP), but no Open
			has occured. The Restart timer is not running in the CLOSED
			state.
			Upon reception of Configure-Request packets, a Terminate-Ack
			is sent. Terminate-Acks are silently discarded to avoid
			creating a loop.
		*/

void mppp_c_prot_state_closed ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_closed()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_DOWN:
			Set_c_prot_state_initial;
			break;

		case MPPP_CP_EV_OPEN:
			Mppp_c_prot_init_restart_counter ();
			Mppp_c_prot_send_configure_request ();
			Set_c_prot_state_request_sent;
			break;

		case MPPP_CP_EV_CLOSE:
		case MPPP_CP_EV_RCV_TERM_ACK:
		case MPPP_CP_EV_RCV_ECHO_RQ:
		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
			break;

		case MPPP_CP_EV_RCV_CODE_REJ:
			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_finished ();
			}
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:
		case MPPP_CP_EV_RCV_CFG_ACK:
		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
			Mppp_c_prot_send_terminate_ack ();
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();
}

/*--------------------------------------------------------------------------*/

		/*

						STATE 3: STOPPED

			The STOPPED state is the Open counterpart to the CLOSED state.
			It is entered when the automaton is waiting for a DOWN event
			after the This-Layer-Finished action, or after sending a
			Terminate-Ack. The Restart timer is not running in the
			STOPPED state.
			Upon reception of Configure-Request packets, an appropriate
			response is sent. Upon reception of another packets, a
			Terminate-Ack is sent. Terminate-Acks are silently discarded
			to avoid creating loop.

		*/

void mppp_c_prot_state_stopped ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_stopped()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_DOWN:
			Mppp_c_prot_this_layer_started ();
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_OPEN:	/* see Open event discussion (RFC 1661) */
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_this_layer_up ();
			break;

		case MPPP_CP_EV_CLOSE:
			Set_c_prot_state_closed;
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:
			Mppp_c_prot_init_restart_counter ();
			Mppp_c_prot_send_configure_request ();

			if (Mppp_c_prot_check_configure_request () == OK) {
				Mppp_c_prot_send_configure_ack ();
				Set_c_prot_state_ack_sent;
			} else {
				Mppp_c_prot_send_configure_nak_rej ();
				Set_c_prot_state_request_sent;
			}
			break;

		case MPPP_CP_EV_RCV_CFG_ACK:
		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
		case MPPP_CP_EV_RCV_TERM_RQ:
			Mppp_c_prot_send_terminate_ack ();
			break;

		case MPPP_CP_EV_RCV_TERM_ACK:
		case MPPP_CP_EV_RCV_ECHO_RQ:
		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
			break;

		case MPPP_CP_EV_RCV_CODE_REJ:

			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_finished ();
			}
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;
	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*/

		/*
						STATE 4: CLOSING

			In the CLOSING state, an attempt is made to terminate the
			connection. A Terminate-Request has been sent and the Restart
			timer is running, but a Terminate-Ack has not yet been
			received.
			Upon reception of a Terminate-Ack, the CLOSED state is entered.
			Upon the expiration of the Restart, a new Terminate-Request is
			is transmitted, and the Restart timer is restarted. After the
			Restart timer has expired Max-Terminae times, the CLOSED state
			is entered.

		*/

void mppp_c_prot_state_closing ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_closing()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_DOWN:
			Set_c_prot_state_initial;
			break;

		case MPPP_CP_EV_OPEN:	/* see Open event discussion (RFC 1661) */
			Set_c_prot_state_stopping;
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_this_layer_up ();
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
			break;

		case MPPP_CP_EV_RCV_CODE_REJ:

			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_closed;
			}
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		case MPPP_CP_EV_RCV_TERM_RQ:
			Mppp_c_prot_send_terminate_ack ();
			break;

		case MPPP_CP_EV_RCV_TERM_ACK:
			Mppp_c_prot_this_layer_finished ();
			Set_c_prot_state_closed;
			break;

		case MPPP_CP_EV_TIMEOUT:

			if (Mppp_c_prot_terminate_count > 0) {
				Mppp_c_prot_send_terminate_request ();
			} else {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_closed;
			}
			break;

		case MPPP_CP_EV_CLOSE:
		case MPPP_CP_EV_RCV_CFG_RQ:
		case MPPP_CP_EV_RCV_CFG_ACK:
		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
		case MPPP_CP_EV_RCV_ECHO_RQ:
		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*/

		/*
						STATE 5: STOPPING

			The STOOPING state is the Open counterpart to the CLOSING state.
			A Terminate-Request has been sent and the Restart timer is
			running, but a Terminate-Ack has not yet been received.

		*/

void mppp_c_prot_state_stopping ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_stopping()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_DOWN:
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_OPEN:	/* see Open event discussion (RFC 1661) */
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_this_layer_up ();
			break;

		case MPPP_CP_EV_CLOSE:
			Set_c_prot_state_closing;
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
			break;

		case MPPP_CP_EV_RCV_CODE_REJ:

			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		case MPPP_CP_EV_RCV_TERM_RQ:
			Mppp_c_prot_send_terminate_ack ();
			break;

		case MPPP_CP_EV_RCV_TERM_ACK:
			Mppp_c_prot_this_layer_finished ();
			Set_c_prot_state_stopped;
			break;

		case MPPP_CP_EV_TIMEOUT:

			if (Mppp_c_prot_terminate_count > 0) {
				Mppp_c_prot_send_terminate_request ();
			} else {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:
		case MPPP_CP_EV_RCV_CFG_ACK:
		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
		case MPPP_CP_EV_RCV_ECHO_RQ:
		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*/

		/*
						STATE 6: REQUEST-SENT

			In the REQUEST-SENT state an attempt is made to configure the
			connection. A Configure-Request has been sent and the Restart
			timer is running, but a Configure-Ack has not yer been
			received, nor has one been sent.

		*/

void mppp_c_prot_state_request_sent ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_request_sent()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_DOWN:
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_OPEN:
		case MPPP_CP_EV_RCV_TERM_ACK:
		case MPPP_CP_EV_RCV_ECHO_RQ:
		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		case MPPP_CP_EV_CLOSE:
			Mppp_c_prot_init_restart_counter ();
			Mppp_c_prot_send_terminate_request ();
			Set_c_prot_state_closing;
			break;

		case MPPP_CP_EV_TIMEOUT:

			if (Mppp_c_prot_configure_count > 0) {
				Mppp_c_prot_send_configure_request ();
			} else {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:

			if (Mppp_c_prot_check_configure_request () == OK) {
				Mppp_c_prot_send_configure_ack ();
				Set_c_prot_state_ack_sent;
			} else {
				Mppp_c_prot_send_configure_nak_rej ();
			}
			break;

		case MPPP_CP_EV_RCV_CFG_ACK:
			if (Mppp_c_prot_check_configure_ack_nak_rej () == OK) {
				Mppp_c_prot_init_restart_counter ();
				Set_c_prot_state_ack_received;
			}
			break;

		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
			if (Mppp_c_prot_check_configure_ack_nak_rej () == OK) {
				Mppp_c_prot_init_restart_counter ();
				Mppp_c_prot_send_configure_request ();
			}
			break;

		case MPPP_CP_EV_RCV_TERM_RQ:
			Mppp_c_prot_send_terminate_ack ();
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
			break;

		case MPPP_CP_EV_RCV_CODE_REJ:

			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*/

		/*
						STATE 7: ACK-RECEIVED

			In the ACK-RECEIVED state, a Configure-Request has been sent and
			a Configure-Ack has been received. The Restart timer is still
			running, since a Configure-Ack has not yet been sent.

		*/

void mppp_c_prot_state_ack_received ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_ack_received()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_DOWN:
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_OPEN:
		case MPPP_CP_EV_RCV_ECHO_RQ:
		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		case MPPP_CP_EV_CLOSE:
			Mppp_c_prot_init_restart_counter ();
			Mppp_c_prot_send_terminate_request ();
			Set_c_prot_state_closing;
			break;

		case MPPP_CP_EV_TIMEOUT:

			if (Mppp_c_prot_configure_count > 0) {
				Mppp_c_prot_send_configure_request ();
				Set_c_prot_state_request_sent;
			} else {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:

			if (Mppp_c_prot_check_configure_request () == OK) {
				Mppp_c_prot_send_configure_ack ();
				Set_c_prot_state_opened;
				Mppp_c_prot_this_layer_up ();
			} else {
				Mppp_c_prot_send_configure_nak_rej ();
			}
			break;

		case MPPP_CP_EV_RCV_CFG_ACK:
		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
			if (Mppp_c_prot_check_configure_ack_nak_rej () == OK) {
				Mppp_c_prot_send_configure_request ();
				Set_c_prot_state_request_sent;
			}
			/* Log the received Configure-Ack packet */
			break;

		case MPPP_CP_EV_RCV_TERM_RQ:
			Mppp_c_prot_send_terminate_ack ();
			Set_c_prot_state_request_sent;
			break;

		case MPPP_CP_EV_RCV_TERM_ACK:
			Set_c_prot_state_request_sent;
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
			break;

		case MPPP_CP_EV_RCV_CODE_REJ:

			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*/

		/*
						STATE 8: ACK-SENT

			In the ACK-SENT state, a Configure-Request and a Configure-Ack
			have both been sent, but a Configure-Ack has not yet been
			received. The Restart timer is running, since a Configure-Ack
			has not yet been received.

		*/

void mppp_c_prot_state_ack_sent ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_ack_sent()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case MPPP_CP_EV_DOWN:
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_OPEN:
		case MPPP_CP_EV_RCV_TERM_ACK:
		case MPPP_CP_EV_RCV_ECHO_RQ:
		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		case MPPP_CP_EV_CLOSE:
			Mppp_c_prot_init_restart_counter ();
			Mppp_c_prot_send_terminate_request ();
			Set_c_prot_state_closing;
			break;

		case MPPP_CP_EV_TIMEOUT:

			if (Mppp_c_prot_configure_count > 0) {
				Mppp_c_prot_send_configure_request ();
			} else {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:

			if (Mppp_c_prot_check_configure_request () == OK) {
				Mppp_c_prot_send_configure_ack ();
			} else {
				Mppp_c_prot_send_configure_nak_rej ();
			}
			break;

		case MPPP_CP_EV_RCV_CFG_ACK:

			if (Mppp_c_prot_check_configure_ack_nak_rej () == OK) {
				Mppp_c_prot_init_restart_counter ();
				Set_c_prot_state_opened;
				Mppp_c_prot_this_layer_up ();
			}
			break;

		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:

			if (Mppp_c_prot_check_configure_ack_nak_rej () == OK) {
				Mppp_c_prot_init_restart_counter ();
				Mppp_c_prot_send_configure_request ();
			}
			break;

		case MPPP_CP_EV_RCV_TERM_RQ:
			Mppp_c_prot_send_terminate_ack ();
			Set_c_prot_state_request_sent;
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
			break;

		case MPPP_CP_EV_RCV_CODE_REJ:
			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_finished ();
				Set_c_prot_state_stopped;
			}
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*/

		/*
						STATE 9: OPENED

			In the OPENED state, a Configure-Ack has been both sent and
			received. The restart timer is not running.
			When entering the OPENED state, the implementation SHOULD
			signal the upper layers that it is now UP. Conversely, when
			leaving the OPENED state, the implementation SHOULD signal the
			upper layers that it is now DOWN.

		*/

void mppp_c_prot_state_opened ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_state_opened()")

	MPPP_DBG_ENTER ();

	switch (mppp_c_prot_event_id) {

		case EV_NIL:	/* Nothing to do */
			break;

		case MPPP_CP_EV_DOWN:
			Mppp_c_prot_this_layer_down ();
			Set_c_prot_state_starting;
			break;

		case MPPP_CP_EV_OPEN:	/* see Open event discussion (RFC 1661) */
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_this_layer_up ();
			break;

		case MPPP_CP_EV_CLOSE:
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_init_restart_counter ();
			Mppp_c_prot_send_terminate_request ();
			Set_c_prot_state_closing;
			break;

		case MPPP_CP_EV_RCV_CFG_RQ:
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_send_configure_request ();
			if (Mppp_c_prot_check_configure_request () == OK) {
				Mppp_c_prot_send_configure_ack ();
				Set_c_prot_state_ack_sent;
			} else {
				Mppp_c_prot_send_configure_nak_rej ();
				Set_c_prot_state_request_sent;
			}
			break;

		case MPPP_CP_EV_RCV_TERM_ACK:
		case MPPP_CP_EV_RCV_CFG_ACK:
		case MPPP_CP_EV_RCV_CFG_NAK:
		case MPPP_CP_EV_RCV_CFG_REJ:
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_send_configure_request ();
			Set_c_prot_state_request_sent;
			break;

		case MPPP_CP_EV_RCV_TERM_RQ:
			Mppp_c_prot_this_layer_down ();
			Mppp_c_prot_zero_restart_counter ();
			Mppp_c_prot_send_terminate_ack ();
			Set_c_prot_state_stopping;
			break;

		case MPPP_CP_EV_RCV_UNKNOWN_CODE:
			Mppp_c_prot_send_code_reject ();
			break;

		case MPPP_CP_EV_RCV_PROTOCOL_REJ:
		case MPPP_CP_EV_RCV_CODE_REJ:

			if (Mppp_c_prot_is_reject_fatal ()) {
				Mppp_c_prot_this_layer_down ();
				Mppp_c_prot_init_restart_counter ();
				Mppp_c_prot_send_terminate_request ();
				Set_c_prot_state_stopping;
			}
			break;

		case MPPP_CP_EV_RCV_ECHO_RQ:

			if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {
				Mppp_c_prot_send_echo_reply ();
			}
			break;

		case MPPP_CP_EV_RCV_ECHO_REPLY:
		case MPPP_CP_EV_RCV_DISCARD_RQ:
			break;

		default:
			Mppp_c_prot_illegal_event ();
			break;

	}

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_set_c_prot_event - implements the setting of the event
				associated to a given packet code.

Usage			void mppp_set_c_prot_event (pck_code);
					uchar pck_code; packet code.

Return value :	returns void

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

void mppp_set_c_prot_event (pck_code)
	uchar		pck_code;			/* packet code */
{
	MPPP_DBG_FUNC ("mppp_set_c_prot_event()")

	uchar	stop_timer_flag;

	MPPP_DBG_ENTER ();

	stop_timer_flag	= OFF;

	switch (pck_code) {

		case MPPP_PPP_PCK_NIL:
			mppp_c_prot_event_id	= EV_NIL;
			break;

		case MPPP_CP_PCK_CONFIG_RQ:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CFG_RQ;
			break;

		case MPPP_CP_PCK_CONFIG_ACK:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CFG_ACK;
			stop_timer_flag			= ON;
			break;

		case MPPP_CP_PCK_CONFIG_NAK:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CFG_NAK;
			break;

		case MPPP_CP_PCK_CONFIG_REJ:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CFG_REJ;
			break;

		case MPPP_CP_PCK_TERM_RQ:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_TERM_RQ;
			break;

		case MPPP_CP_PCK_TERM_ACK:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_TERM_ACK;
			stop_timer_flag			= ON;
			break;

		case MPPP_CP_PCK_CODE_REJ:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CODE_REJ;
			stop_timer_flag			= ON;
			break;

		case MPPP_CP_PCK_PROTOCOL_REJ:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_PROTOCOL_REJ;
			stop_timer_flag			= ON;
			break;

		case MPPP_CP_PCK_ECHO_RQ:

			if (Mppp_c_prot_ppp_pid != PPP_PROT_LCP) {
				goto unknown_pck;
			} else {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_ECHO_RQ;
			}
			break;

		case MPPP_CP_PCK_ECHO_REPLY:

			if (Mppp_c_prot_ppp_pid != PPP_PROT_LCP) {
				goto unknown_pck;
			} else {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_ECHO_REPLY;
				stop_timer_flag			= ON;
			}
			break;

		case MPPP_CP_PCK_DISCARD_RQ:

			if (Mppp_c_prot_ppp_pid != PPP_PROT_LCP) {
				goto unknown_pck;
			} else {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_DISCARD_RQ;
			}
			break;

		case MPPP_CP_PCK_IDENTIFICATION:
		case MPPP_CP_PCK_TIME_REMAINING:
		default:
		unknown_pck:
			mppp_c_prot_event_id	= MPPP_CP_EV_RCV_UNKNOWN_CODE;
			mppp_c_prot_rej_packet_code = pck_code;
			break;

	}


		/* Any timer to stop ? */

	if (stop_timer_flag == ON) {

			/* Ack/Nak/Rej from the peer, and not the 1st member link */

		if ((Mppp_cep_msg_direction == MPPP_FROM_PEER) &&
			(! Is_sppp_first_in_bundle ())) {

			if (Mppp_c_prot_r_packet_id == Mppp_c_prot_s_packet_id) {

					/*
						The packet ID MUST match that of the last transmitted
						Request
					*/

					/* Stop the Restart timer */

				if (Mppp_c_prot_ppp_pid == PPP_PROT_LCP) {
					Mppp_c_prot_stop_timer (MPPP_LCP_TI_X_RESTART);
				}

#				if MPPP_BAP == ON

					else if (Mppp_c_prot_ppp_pid == PPP_PROT_BACP) {
						Mppp_c_prot_stop_timer (MPPP_BACP_TI_X_RESTART);
					}

#				endif

			}

		}

	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_set_auth_event - implements the setting of the event
				associated to a given authentication protocol packet code.

Usage			void mppp_set_auth_event (prot_id, pck_code, p_flag);
					ushort prot_id;	PPP protocol ID (PAP/CHAP)
					uchar pck_code; packet code
					uchar FAR *p_flag; flag for Timer to stop (ON/OFF)

Return value :	returns void

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

void mppp_set_auth_event (prot_id, pck_code)
	ushort		prot_id;	/* protocol ID (PAP/CHAP) */
	uchar		pck_code;	/* packet code */
{
	MPPP_DBG_FUNC ("mppp_set_auth_event()")

	MPPP_DBG_ENTER ();

	mppp_c_prot_event_id	= EV_NIL;

	if (pck_code == MPPP_PPP_PCK_NIL) {

			/* Nothing to do */

		MPPP_DBG_WARNING ("processed PCK_NIL packet");
		MPPP_DBG_LEAVE ();

		return;
	}

		/* Dispatch according to the protocol ID */

	switch (prot_id) {

		case PPP_PROT_PAP:

			if (pck_code == MPPP_CP_PCK_PAP_AUTH_RQ) {

				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_PAP_AUTH_RQ;

			} else if (pck_code == MPPP_CP_PCK_PAP_AUTH_ACK) {

				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_PAP_AUTH_ACK;

			} else if (pck_code == MPPP_CP_PCK_PAP_AUTH_NAK) {

				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_PAP_AUTH_NAK;

			} else {

				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_UNKNOWN_CODE;

			}
			break;

		case PPP_PROT_CHAP:

				/*
					We are not responsible for sending/checking
					the CHAP packets content
					--> No timer to manage
				*/

			if (pck_code == MPPP_CP_PCK_CHAP_CHALLENGE) {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CHAP_CHALLENGE;
			} else if (pck_code == MPPP_CP_PCK_CHAP_RESPONSE) {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CHAP_RESPONSE;
			} else if (pck_code == MPPP_CP_PCK_CHAP_SUCCESS) {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CHAP_SUCCESS;
			} else if (pck_code == MPPP_CP_PCK_CHAP_FAILURE) {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_CHAP_FAILURE;
			} else {
				mppp_c_prot_event_id	= MPPP_CP_EV_RCV_UNKNOWN_CODE;
			}
			break;

		default:
			MPPP_DBG_ERROR ("unknown AUTH protocol");
			Trap (TRAP_MPPP_UNKNOWN_VAL, "mppp_set_auth_event");
			break;

	}

	if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_UNKNOWN_CODE) {

			/* received unknown packet code */

		MPPP_DBG_ERROR ("received unknown AUTH packet(");
		MPPP_DBG_ERROR_INT (pck_code);
		MPPP_DBG_ERROR_STR (")");

	}

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_set_auth_context - implements the setting of the 
				authenticator context pointer to local or peer
				according to the received authentication protocol event.

Usage			void mppp_set_auth_context (prot_id, pck_code, f_user);
					ushort prot_id;	PPP protocol ID (PAP/CHAP)
					uchar pck_code; packet code
					uchar f_user; from user (ON/OFF)

Return value :	returns void

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

void mppp_set_auth_context (ev_code, from_user)
	code_t	ev_code;	/* internal event code */
	uchar	from_user;	/* from User indicator (ON/OFF) */
{
	MPPP_DBG_FUNC ("mppp_set_auth_context()")

	MPPP_DBG_ENTER ();

	p_sppp_auth	= P_NIL;

		/*
			In case of one-way authentication, the context
			pointer is set directly
		*/

	if ((Mppp_cep_ack_negot & LCP_NEG_AUTH) &&
		(! (Mppp_cep_peer_ack_negot & LCP_NEG_AUTH))) {

			/* The peer is the ONLY authenticator for the Link */

		p_sppp_auth	= Sppp_cep_p_peer_auth_info;

	} else if ((Mppp_cep_peer_ack_negot & LCP_NEG_AUTH) &&
				(! (Mppp_cep_ack_negot & LCP_NEG_AUTH))) {

			/* We are the ONLY authenticator for the Link */

		p_sppp_auth	= Sppp_cep_p_local_auth_info;

	}

	if (p_sppp_auth != P_NIL) {
		MPPP_DBG_LEAVE ();
		return;
	}

	switch (ev_code) {

		case MPPP_CP_EV_RCV_PAP_AUTH_RQ:
		case MPPP_CP_EV_RCV_CHAP_RESPONSE:

			if (from_user == ON) {

					/* The peer is the authenticator */

				p_sppp_auth	= Sppp_cep_p_peer_auth_info;

			} else {

					/* We are the authenticator */

				p_sppp_auth	= Sppp_cep_p_local_auth_info;

			}
			break;

		case MPPP_CP_EV_RCV_PAP_AUTH_ACK:
		case MPPP_CP_EV_RCV_PAP_AUTH_NAK:
		case MPPP_CP_EV_RCV_CHAP_CHALLENGE:
		case MPPP_CP_EV_RCV_CHAP_SUCCESS:
		case MPPP_CP_EV_RCV_CHAP_FAILURE:

			if (from_user == ON) {

					/* We are the authenticator */

				p_sppp_auth	= Sppp_cep_p_local_auth_info;

			} else {

					/* The peer is the authenticator */

				p_sppp_auth	= Sppp_cep_p_peer_auth_info;

			}
			break;

		default:
			break;

	}

	MPPP_DBG_LEAVE ();
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_c_prot_initialize - implements the initialization of the
					control protocol information.

Usage			uchar mppp_c_prot_initialize (p_pr, p_cfg);

Return value :	returns OK or NOK.

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

uchar mppp_c_prot_initialize (p_pr, p_cfg)
	struct mppp_c_prot	FAR *p_pr;
	struct mppp_cfg_cep FAR *p_cfg;
{
	MPPP_DBG_FUNC ("mppp_c_prot_initialize()")

	struct mppp_cfg_cep		FAR *p_mppp_cfg_cep;	/* pointer on the current config CEP object */
	uchar						i, j;				/* loop indexes */

	MPPP_DBG_ENTER ();

		/* Set up the pointers we'll use */

	p_mppp_c_prot	= p_pr;
	p_mppp_cfg_cep	= p_cfg;

	Mppp_c_prot_mx_terminate	=
	Mppp_c_prot_terminate_count = Set_default (Mppp_cfg_cep_c_prot_mx_terminate, MPPP_CP_MX_TERMINATE_I);

	Mppp_c_prot_mx_configure	=
	Mppp_c_prot_configure_count = Set_default (Mppp_cfg_cep_c_prot_mx_configure, MPPP_CP_MX_CONFIGURE_I);

	Mppp_c_prot_mx_failure		= Set_default (Mppp_cfg_cep_c_prot_mx_failure,	 MPPP_CP_MX_FAILURE_I);

	Mppp_c_prot_rej_flag		= OFF;


		/* Set the Control Protocols Timers values */

	for (i = 0; i < MPPP_MX_CP_TIMER; i++) {
		Mppp_c_prot_ti_val (i)	= Set_default (Mppp_cfg_cep_c_prot_ti_val (i),	mppp_c_prot_ti_val_i[i]);
	}

		/*
			Initialize the Received/Sent Control packets
			Identifiers values
		*/

	Mppp_c_prot_r_packet_id		=
	Mppp_c_prot_s_packet_id		= 0;

		/*
			Initialize the Received/Sent packets codes
		*/

	Mppp_c_prot_r_packet_code	=
	Mppp_c_prot_s_packet_code	= MPPP_PPP_PCK_NIL;

		/*
			Initialize the PPP frame parsing pointer and size
		*/

	Mppp_c_prot_p_data		= P_NIL;
	Mppp_c_prot_data_size	= 0;

		/* Initialize Event and State */

	Mppp_c_prot_event			= MPPP_CP_EV_NIL;
	Mppp_c_prot_state			= MPPP_CP_STATE_INITIAL;

		/* Initialize the restart counters */

	Mppp_c_prot_failure_count			= 0;

		/*
			Timer init :
				- Init timer state to OFF,
				- allocate timer resource.
		*/

		/* ML PPP Control Protocols Timers */

	for (i = 0; i < MPPP_MX_CP_TIMER; i++) {

		Mppp_c_prot_ti_state (i) = OFF;

		if ((Mppp_c_prot_ti_id (i) =
				Timer_alloc (ENT_MPPP, Mppp_na_nai, Mppp_sap_data_sapi, Mppp_cep_ces)) == P_NIL) {

				/* Free the previously allocated timers */

			for (j = 0; j < i; j++) {
				Timer_free (Mppp_c_prot_ti_id (j));
			}

			ret_code	= MPPP_CFG_ERR_TI_ALLOC;

			MPPP_DBG_LEAVE ();

			return (NOK);
		}

	}

	MPPP_DBG_LEAVE ();

	return (OK);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_auth_initialize - implements the initialization of the
					authentication protocol information.

Usage			uchar mppp_auth_initialize (p_pr, p_cfg);

Return value :	returns OK or NOK.

common constants and declarations : mppp.h

common objects : current contexts pointers

*--------------------------------------------------------------------------*/

uchar mppp_auth_initialize (p_pr, p_cfg)
	struct sppp_auth	FAR *p_pr;
	struct mppp_cfg_cep FAR *p_cfg;
{
	MPPP_DBG_FUNC ("mppp_auth_initialize()")

	struct mppp_cfg_cep		FAR *p_mppp_cfg_cep;	/* pointer on the current config CEP object */
	uchar						i, j;				/* loop indexes */

	MPPP_DBG_ENTER ();

		/* Set up the pointers we'll use */

	p_sppp_auth		= p_pr;
	p_mppp_cfg_cep	= p_cfg;

	Sppp_auth_mx_count	= Set_default (Mppp_cfg_cep_c_prot_mx_configure, MPPP_CP_MX_CONFIGURE_I);

		/* Set the Authentication Protocols Timers values */

	for (i = 0; i < MPPP_MX_AUTH_TIMER; i++) {
		Sppp_auth_ti_val (i) = MPPP_CP_RESTART_TI_VAL_I;
	}

		/*
			Initialize the Received/Sent Control packets
			Identifiers values
		*/

	Sppp_auth_r_packet_id	=
	Sppp_auth_s_packet_id	= 0;

		/*
			Initialize the Received/Sent packets codes
		*/

	Sppp_auth_r_packet_code	=
	Sppp_auth_s_packet_code	= MPPP_PPP_PCK_NIL;

		/*
			Initialize the PPP frame parsing pointer and size
		*/

	Mppp_c_prot_p_data		= P_NIL;
	Mppp_c_prot_data_size	= 0;

		/* Initialize Event and State */

	Sppp_auth_active		= OFF;
	Sppp_auth_event			= MPPP_CP_EV_NIL;
	Sppp_auth_state			= MPPP_CP_STATE_INITIAL;

		/* Initialize the restart counters */

	Sppp_auth_count			= Sppp_auth_mx_count;

		/*
			Timer init :
				- Init timer state to OFF,
				- allocate timer resource.
		*/

		/* Authentication Protocols Timers */

	for (i = 0; i < MPPP_MX_AUTH_TIMER; i++) {

		Sppp_auth_ti_state (i) = OFF;

		if ((Sppp_auth_ti_id (i) =
				Timer_alloc (ENT_MPPP, Mppp_na_nai, Mppp_sap_data_sapi, Mppp_cep_ces)) == P_NIL) {

				/* Free the previously allocated timers */

			for (j = 0; j < i; j++) {
				Timer_free (Sppp_auth_ti_id (j));
			}

			ret_code	= MPPP_CFG_ERR_TI_ALLOC;

			MPPP_DBG_LEAVE ();

			return (NOK);
		}

	}

	MPPP_DBG_LEAVE ();

	return (OK);

}

/*-------------------------------------------------------------------------*/

		/*
					==== CHECK-CONFIGURE-REQUEST-FROM-LOCAL-USER ====

			This routine checks a Configure-Request coming from the local
			user PPP module.
			Multilink specific Configuration options are added at the end
			of the original packet and the packet length is updated.

			This routine is only used for the first member link.
		*/

uchar check_user_configure_request ()
{
	MPPP_DBG_FUNC ("check_user_configure_request()")

	uchar			FAR *p_octet;		/* pointer to next octet to parse */
	uchar			FAR *p_curr_opt;	/* pointer to current option */
	uchar			FAR *p_next_opt;	/* pointer to next option */
	uchar			FAR *p_lgth;		/* pointer to the packet length address */
	uchar				opt_lgth;		/* option length */
	uchar				opt_type;		/* option type */
	ulong				opt_val_ulong;	/* option 'ulong' value */
	ushort				opt_val_ushort; /* option 'ushort' value */
	uchar				opt_val_uchar;  /* option 'uchar' value */
	int					lgth;			/* length left to parse */

	MPPP_DBG_ENTER ();

		/*
			At this stage, the packet header is valid.
			We subtract the header length for the following processing
		*/

		/*
			Set up the pointer to the beginning of the output packet
			and the packet length.
		*/

	lgth		= Mppp_c_prot_data_size;
	p_lgth		= (uchar FAR *)(Mppp_c_prot_p_data - 2);

		/*
			We reset the information about the options we peer ack'd
		*/

	Sppp_cep_reset_peer_ack_cp_opt ();

		/* Reset the ACCM to the Local PPP stack */

	Mppp_cep_accm_to_local	= (Mppp_sap_data_sapi == MPPP_SAPI_DATA_SYNC) ? LCP_SYNC_ACCM_I : LCP_ASYNC_ACCM_I;

		/*
			Let's go through the options
		*/

	p_next_opt		= Mppp_c_prot_p_data;

		/* Loop until no more option to process */

	while (lgth > 0) {

		p_curr_opt	= p_octet = p_next_opt;

			/*
				Check the consistency of this option
				1- is there enough data for the option ?
				2- is the option length field >= 2
				3- is the option length > the remaining data length ?
			*/

#		if ASSERT == ON	/* { */

			if ((lgth < 2) || (p_curr_opt[1] < 2) || (p_curr_opt[1] > lgth)) {

					/*
						This option is bad, the remaining options in the
						packet will be rejected.
					*/

				MPPP_DBG_ERROR ("wrong LCP option length");

				opt_lgth	= lgth; /* reject all the remaining options */
				lgth		= 0;	/* no more loop to run */

				MPPP_DBG_LEAVE ();

				return (NOK);
			}

#		endif	/* } */

			/* Get the option type (1 octet) */

		Mppp_get_char (opt_type, p_octet);

			/* Get the option length (1 octet) */

		Mppp_get_char (opt_lgth, p_octet);

			/* Update the remaining length */

		lgth -= opt_lgth;

			/* Set up the pointer to the next option */

		p_next_opt += opt_lgth;

			/* Forward processing according to the option type */

		switch (opt_type) {

				/*=========================
					Max Receive Unit (MRU)
				==========================*/

			case LCP_OPT_MRU:
				MPPP_DBG_DISPLAY ("requested MRU(");

					/* Get and check the MRU value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_INT (opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (")");

					/* Keep a trace of this option value */

				Mppp_cep_peer_ack_mru = opt_val_ushort;

					/* Note that we  negotiated the MRU */

				Sppp_cep_peer_ack_negot	|= LCP_NEG_MRU;
				break;


				/*======================================
					Async Character Control Map (ACCM)
				=======================================*/

			case LCP_OPT_ACCM:
				MPPP_DBG_DISPLAY ("requested ACCM(");

					/* Get the ACCM value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/*
						Keep a trace of this option value
						This ACCM becomes effective after we've
						sent a Config-Ack.
						If the local PPP is requesting a non-zero
						ACCM, then we transmit a zero ACCM to the peer
						system, and we remember which ACCM the
						local PPP expects.
					*/

				Mppp_cep_peer_ack_accm	= opt_val_ulong;
				Sppp_cep_peer_ack_accm	= opt_val_ulong;

				if (opt_val_ulong != 0) {
					Mppp_dec_ptr (4, p_octet);
					Mppp_put_long (0, p_octet);
				}

					/* Note that the we negotiated the ACCM */

				Sppp_cep_peer_ack_negot	|= LCP_NEG_ACCM;
				break;

				/*======================================
					Authentication protocol (AUTH)
				=======================================*/

			case LCP_OPT_AUTH:
				MPPP_DBG_DISPLAY ("requested AUTH(");

					/* Get the authentication protocol value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_HEX ((ushort)opt_val_ushort);

				if (opt_val_ushort == PPP_PROT_CHAP) {

						/* Get the one-way hash method to be used (if CHAP) */

					MPPP_DBG_DISPLAY_STR (",");

					Mppp_get_char (opt_val_uchar, p_octet);

					MPPP_DBG_DISPLAY_HEX ((uchar)opt_val_uchar);

				}

				MPPP_DBG_DISPLAY_STR (")");

					/* Keep a trace of this option value */

				Mppp_cep_peer_ack_auth = opt_val_ushort;

					/* Note that the we negotiated the AUTH_PROT */

				Sppp_cep_peer_ack_negot	|= LCP_NEG_AUTH;
				break;

				/*==========================================
					Link Quality Monitoring protocol (LQM)
				===========================================*/

			case LCP_OPT_LQM:
				MPPP_DBG_DISPLAY ("requested LQM(");

					/*
						Get the quality protocol (Link Quality Report)
						value and the report period value
					*/

				Mppp_get_short (opt_val_ushort, p_octet);
				Mppp_get_long (opt_val_ulong, p_octet);

				MPPP_DBG_DISPLAY_HEX ((ushort)opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (",");
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Keep a trace of this option value */

				Mppp_cep_peer_ack_lqm			= opt_val_ushort;
				Mppp_cep_peer_ack_lqr_period	= opt_val_ulong;

					/* Note that we negotiated the LQM */

				Sppp_cep_peer_ack_negot	|= LCP_NEG_LQM;
				break;

				/*========================================================
					Magic Number (MAGIC). One for each single PPP link
				=========================================================*/

			case LCP_OPT_MAGIC:
				MPPP_DBG_DISPLAY ("requested MAGIC(");

					/* Get the MAGIC NUMBER value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Keep a trace of this option value */

				Mppp_cep_peer_ack_magic	=
				Sppp_cep_peer_ack_magic	= opt_val_ulong;

					/* Note that we negotiated the MAGIC number */

				Sppp_cep_peer_ack_negot	|= LCP_NEG_MAGIC;
				break;


				/*=====================================
					Protocol Field Compression (PFC)
				======================================*/

			case LCP_OPT_PFC:
				MPPP_DBG_DISPLAY ("requested PFC");

					/* Note that we peer negotiated the PFC */

				Sppp_cep_peer_ack_negot	|= LCP_NEG_PFC;
				break;


				/*=================================================
					Address and Control Field Compression (ACFC)
				==================================================*/

			case LCP_OPT_ACFC:
				MPPP_DBG_DISPLAY ("requested ACFC");

					/* Note that we negotiated the ACFC */

				Sppp_cep_peer_ack_negot	|= LCP_NEG_ACFC;
				break;


			default:
				MPPP_DBG_WARNING ("requested unknown option(");
				MPPP_DBG_WARNING_INT (opt_type);
				MPPP_DBG_WARNING_STR (")");

					/* Update the parsing pointer */

				Mppp_inc_ptr ((opt_lgth - 2), p_octet);
				break;

		}	/* end of switch */

	}	/* end of while */



		/*
			We add our Multilink specific configuration options
			(MRRU, SSNHF, EDO, ...) if the MP negotiation is not
			disabled and has not been rejected before.
		*/

	if ((Mppp_cep_mp_disabled == OFF) && (Mppp_cep_mp_rejected == OFF)) {

			/*
				Max-Reconstructed-Receive-Unit (MRRU)
			*/

		Mppp_put_char	(LCP_OPT_MRRU, p_octet);
		Mppp_put_char	(LCP_OPT_SZ_SHORT, p_octet);
		Mppp_put_short	(Mppp_cep_mrru, p_octet);
		Mppp_cep_peer_ack_mrru = Mppp_cep_mrru;

		Sppp_cep_peer_ack_negot	|= LCP_NEG_MRRU;

			/* Short-Sequence-Number-Header-Format (SSNHF) */

		if ((Mppp_cep_ssnhf_rejected == OFF) && (Mppp_sap_data_modulo == MP_MX_SHORT_MODULO)) {
			Mppp_put_char	(LCP_OPT_SSNHF, p_octet);
			Mppp_put_char	(LCP_OPT_SZ_NULL, p_octet);
			Sppp_cep_peer_ack_negot	|= LCP_NEG_SSNHF;
		}

			/* Endpoint-Discriminator-Option (EDO) */

		if ((Mppp_cep_edo_usage == ON) && (Mppp_cep_edo_rejected == OFF)) {
			Mppp_put_char	(LCP_OPT_EDO, p_octet);
			Mppp_put_char	((Mppp_cep_edo_add_lgth+3),p_octet);
			Mppp_put_char	(Mppp_cep_edo_class, p_octet);

			Memcpy_far ((char FAR *)p_octet,(char FAR *)&Mppp_cep_edo_add,Mppp_cep_edo_add_lgth);

				/* Save this as if already Ack'd by the peer */

			Memcpy_far ((char FAR *)&Mppp_cep_peer_ack_edo_add,(char FAR *)&Mppp_cep_edo_add, Mppp_cep_edo_add_lgth);
			Mppp_cep_peer_ack_edo_class		= Mppp_cep_edo_class;
			Mppp_cep_peer_ack_edo_add_lgth	= Mppp_cep_edo_add_lgth;

			p_octet += Mppp_cep_edo_add_lgth;

			Sppp_cep_peer_ack_negot	|= LCP_NEG_EDO;
		}


#		if MPPP_BAP == ON /* { */

				/* Link Discriminator (For BAP) */

			if ((Mppp_cep_bacp_usage == ON) &&
				(Mppp_cep_bacp_rejected == OFF)) {

					/*
						We use our UNIQUE member link reference as
						our endpoint's Link Discriminator value
					*/

				Mppp_put_char	(LCP_OPT_LDO, p_octet);
				Mppp_put_char	(LCP_OPT_SZ_SHORT, p_octet);
				Mppp_put_short	(Sppp_cep_ref, p_octet);

				Sppp_cep_peer_ack_ldo = Sppp_cep_ref;

				Sppp_cep_peer_ack_negot	|= LCP_NEG_LDO;

			}

#		endif	/* MPPP_BAP == ON } */


	}

		/*
			For this first single link PPP negotiation,
			we mark all the received options as negotiated for the
			bundle itself.
		*/

	Mppp_cep_peer_ack_negot	= Sppp_cep_peer_ack_negot;

		/* Let's compute the length of the formatted packet */

	Mppp_c_prot_data_size	= (ushort)(p_octet - Mppp_c_prot_p_data);

		/* Load the final packet length */

	Mppp_put_short ((Mppp_c_prot_data_size+PPP_PACKET_HEADER_LGTH), p_lgth);


		/*
			We are not responsible for Acking/Naking/Rejecting the
			negotiation on the FIRST member link
		*/

	MPPP_DBG_LEAVE ();

	return (OK);
}

/*-------------------------------------------------------------------------*/

		/*
				==== CHECK-USER-CONFIGURE-ACK-NAK-REJ ====


			This routine checks a Configure-Ack/Nak/Rej coming from the local
			user PPP module.
			Multilink specific Configuration options are added at the end
			of the original packet if we received an ACK.

			This routine is only used for the first member link.
		*/

uchar check_user_configure_ack_nak_rej ()
{
	MPPP_DBG_FUNC ("check_user_configure_ack_nak_rej()")

	uchar	FAR *p_octet;		/* pointer to next octet to parse */
	uchar	FAR *p_curr_opt;	/* pointer to current option */
	uchar	FAR *p_next_opt;	/* pointer to next option */
	uchar	FAR *p_lgth;		/* pointer to the packet length address */
	uchar		opt_lgth;		/* option length */
	uchar		opt_type;		/* option type */
	ulong		opt_val_ulong;	/* option 'ulong' value */
	ushort		opt_val_ushort; /* option 'ushort' value */
	uchar		opt_val_uchar;  /* option 'uchar' value */
	int			lgth;			/* length left to parse */

	MPPP_DBG_ENTER ();

		/*
			At this stage, the packet header is valid.
			We subtract the header length for the following processing
		*/

		/*
			Set up the pointer to the beginning of the output packet
			and the packet length.
		*/

	lgth		= Mppp_c_prot_data_size;
	p_lgth		= (uchar FAR *)(Mppp_c_prot_p_data - 2);


		/*
			Let's go through the options
		*/

	p_next_opt		= Mppp_c_prot_p_data;

		/* Loop until no more option to process */

	while (lgth > 0) {

		p_curr_opt	= p_octet = p_next_opt;

			/*
				Check the consistency of this option
				1- is there enough data for the option ?
				2- is the option length field >= 2
				3- is the option length > the remaining data length ?
			*/

#		if ASSERT == ON	/* { */

			if ((lgth < 2) || (p_curr_opt[1] < 2) || (p_curr_opt[1] > lgth)) {

					/*
						This option is bad, the remaining options in the
						packet will be rejected.
					*/

				MPPP_DBG_ERROR ("wrong LCP option length");

				opt_lgth	= lgth; /* reject all the remaining options */
				lgth		= 0;	/* no more loop to run */

				MPPP_DBG_LEAVE ();

				return (NOK);
			}

#		endif	/* } */

			/* Get the option type (1 octet) */

		Mppp_get_char (opt_type, p_octet);

			/* Get the option length (1 octet) */

		Mppp_get_char (opt_lgth, p_octet);

			/* Update the remaining length */

		lgth -= opt_lgth;

			/* Set up the pointer to the next option */

		p_next_opt += opt_lgth;

			/* Forward processing according to the option type */

		switch (opt_type) {

				/*=========================
					Max Receive Unit (MRU)
				==========================*/

			case LCP_OPT_MRU:
				MPPP_DBG_DISPLAY ("sent Ack-Nak-Rej MRU(");

					/* Get and check the MRU value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_INT (opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_ack_mru = LCP_MRU_I;

						/* Note that the local PPP refused this option */

					Sppp_cep_ack_negot	&= (~LCP_NEG_MRU);

				}
				break;


				/*======================================
					Async Character Control Map (ACCM)
				=======================================*/

			case LCP_OPT_ACCM:
				MPPP_DBG_DISPLAY ("sent Ack-Nak-Rej ACCM(");

					/* Get the ACCM value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/*
						We have to restore the original ACCM before sending
						the Ack/Nak/Rej to the peer system.
					*/

				Mppp_dec_ptr (4, p_octet);
				Mppp_put_long (Mppp_cep_ack_accm, p_octet);

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					if (Sppp_cep_link_mode == SPPP_MODE_SYNC) {
						Mppp_cep_ack_accm =
						Sppp_cep_ack_accm = LCP_SYNC_ACCM_I;
					} else {
						Mppp_cep_ack_accm =
						Sppp_cep_ack_accm = LCP_ASYNC_ACCM_I;
					}

						/* Note that the local PPP refused this option */

					Sppp_cep_ack_negot	&= (~LCP_NEG_ACCM);

				}
				break;

				/*======================================
					Authentication protocol (AUTH)
				=======================================*/

			case LCP_OPT_AUTH:
				MPPP_DBG_DISPLAY ("sent Ack-Nak-Rej AUTH(");

					/* Get the authentication protocol value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_HEX ((ushort)opt_val_ushort);

				if (opt_val_ushort == PPP_PROT_CHAP) {

						/* Get the one-way hash method to be used (if CHAP) */

					MPPP_DBG_DISPLAY_STR (",");

					Mppp_get_char (opt_val_uchar, p_octet);

					MPPP_DBG_DISPLAY_HEX ((uchar)opt_val_uchar);

				}

				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_ack_auth= 0;

						/* Note that the local PPP refused this option */

					Sppp_cep_ack_negot	&= (~LCP_NEG_AUTH);

				} else {

						/*
							Set the peer authenticator context active
							--- The peer is the authenticator ---
						*/

					p_sppp_auth			= Sppp_cep_p_peer_auth_info;
					Sppp_auth_active	= ON;

				}
				break;

				/*==========================================
					Link Quality Monitoring protocol (LQM)
				===========================================*/

			case LCP_OPT_LQM:
				MPPP_DBG_DISPLAY ("sent Ack-Nak-Rej LQM(");

					/*
						Get the quality protocol (Link Quality Report)
						value and the report period value
					*/

				Mppp_get_short (opt_val_ushort, p_octet);
				Mppp_get_long (opt_val_ulong, p_octet);

				MPPP_DBG_DISPLAY_HEX ((ushort)opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (",");
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_ack_lqm			= 0;
					Mppp_cep_ack_lqr_period	= 0;

						/* Note that the local PPP refused this option */

					Sppp_cep_ack_negot	&= (~LCP_NEG_LQM);

				}
				break;

				/*========================================================
					Magic Number (MAGIC). One for each single PPP link
				=========================================================*/

			case LCP_OPT_MAGIC:
				MPPP_DBG_DISPLAY ("sent Ack-Nak-Rej MAGIC(");

					/* Get the MAGIC NUMBER value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_ack_magic	= 0;

						/* Note that the local PPP refused this option */

					Sppp_cep_ack_negot	&= (~LCP_NEG_MAGIC);

				}
				break;


				/*=====================================
					Protocol Field Compression (PFC)
				======================================*/

			case LCP_OPT_PFC:
				MPPP_DBG_DISPLAY ("sent Ack-Nak-Rej PFC");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

						/* Note that the local PPP refused this option */

					Sppp_cep_ack_negot	&= (~LCP_NEG_PFC);

				}
				break;


				/*=================================================
					Address and Control Field Compression (ACFC)
				==================================================*/

			case LCP_OPT_ACFC:
				MPPP_DBG_DISPLAY ("sent Ack-Nak-Rej ACFC");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

						/* Note that the local PPP refused this option */

					Sppp_cep_ack_negot	&= (~LCP_NEG_ACFC);

				}
				break;

			default:
				MPPP_DBG_WARNING ("sent Ack-Nak-Rej unknown option(");
				MPPP_DBG_WARNING_INT (opt_type);
				MPPP_DBG_WARNING_STR (")");

					/* Update the parsing pointer */

				Mppp_inc_ptr ((opt_lgth - 2), p_octet);
				break;

		}	/* end of switch */

	}	/* end of while */

		/* The local PPP accepted the Configure-Request */

	if ((mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_ACK) &&
		(Mppp_cep_mp_rejected == OFF)) {

			/*
				We add our Multilink specific configuration options
				(MRRU, SSNHF, EDO, ...).
			*/

			/* Max-Reconstructed-Receive-Unit (MRRU) */

		if (Sppp_cep_ack_negot & LCP_NEG_MRRU)  {

			Mppp_put_char	(LCP_OPT_MRRU, p_octet);
			Mppp_put_char	(LCP_OPT_SZ_SHORT, p_octet);
			Mppp_put_short	(Mppp_cep_ack_mrru, p_octet);

		}

			/* Short-Sequence-Number-Header-Format (SSNHF) */

		if (Sppp_cep_ack_negot & LCP_NEG_SSNHF) {

			Mppp_put_char	(LCP_OPT_SSNHF, p_octet);
			Mppp_put_char	(LCP_OPT_SZ_NULL, p_octet);

		}

			/* Endpoint-Discriminator-Option (EDO) */

		if (Sppp_cep_ack_negot & LCP_NEG_EDO) {

			Mppp_put_char	(LCP_OPT_EDO, p_octet);
			Mppp_put_char	((Mppp_cep_ack_edo_add_lgth+3),p_octet);
			Mppp_put_char	(Mppp_cep_ack_edo_class, p_octet);
			Memcpy_far ((char FAR *)p_octet,(char FAR *)&Mppp_cep_ack_edo_add,Mppp_cep_ack_edo_add_lgth);
			p_octet += Mppp_cep_ack_edo_add_lgth;

		}

#		if MPPP_BAP == ON	/* { */

				/* Link Discriminator Option (LDO) */

			if ((Sppp_cep_ack_negot & LCP_NEG_LDO) && (Mppp_cep_bacp_usage == ON)) {

				Mppp_put_char	(LCP_OPT_LDO, p_octet);
				Mppp_put_char	(LCP_OPT_SZ_SHORT, p_octet);
				Mppp_put_short	(Sppp_cep_ack_ldo, p_octet);

			}

#		endif	/* MPPP_BAP == ON } */


	}

		/*
			For this first single link PPP negotiation,
			we mark all the received options as negotiated for the
			bundle itself.
		*/

	Mppp_cep_ack_negot	= Sppp_cep_ack_negot;

		/* Let's compute the length of the formatted packet */

	Mppp_c_prot_data_size	= (ushort)(p_octet - Mppp_c_prot_p_data);

		/* Load the final packet length */

	Mppp_put_short ((Mppp_c_prot_data_size+PPP_PACKET_HEADER_LGTH), p_lgth);

		/*
			We are not responsible for Acking/Naking/Rejecting the
			negotiation on the FIRST member link
		*/

	MPPP_DBG_LEAVE ();

	return (OK);
}

/*-------------------------------------------------------------------------*/

		/*
				==== CHECK-PEER-CONFIGURE-ACK-NAK-REJ ====


			This routine checks a Configure-Ack/Nak/Rej coming from the peer
			system.
			Multilink specific Configuration options are removed from the end
			of the original packet.

			This routine is only used for the first member link.
		*/

uchar check_peer_configure_ack_nak_rej ()
{
	MPPP_DBG_FUNC ("check_peer_configure_ack_nak_rej()")

	uchar	FAR *p_octet;		/* pointer to next octet to parse */
	uchar	FAR *p_curr_out;	/* pointer to current output octet */
	uchar	FAR *p_curr_opt;	/* pointer to current option */
	uchar	FAR *p_next_opt;	/* pointer to next option */
	uchar	FAR *p_end_data;	/* pointer to the first octet beyond the packet */
	uchar	FAR *p_lgth;		/* pointer to the packet length address */
	uchar		opt_lgth;		/* option length */
	uchar		opt_type;		/* option type */
	uchar		opt_val_uchar;	/* option 'uchar' value */
	ushort		opt_val_ushort; /* option 'ushort' value */
	ulong		opt_val_ulong;	/* option 'ulong' value */
	int			lgth;			/* length left to parse */

	MPPP_DBG_ENTER ();

		/*
			At this stage, the packet header is valid.
			We subtract the header length for the following processing
		*/

		/*
			Set up the pointer to the beginning of the output packet
			and the packet length.
		*/

	p_curr_out	= Mppp_c_prot_p_data;
	lgth		= Mppp_c_prot_data_size;
	p_lgth		= (uchar FAR *)(Mppp_c_prot_p_data - 2);

		/* Initialize the pointer to the first octet beyond the packet */

	p_end_data	= (uchar FAR *)(Mppp_c_prot_p_data+lgth);

		/*
			Let's go through the options
		*/

	p_next_opt		= Mppp_c_prot_p_data;

		/* Loop until no more option to process */

	while (lgth > 0) {

		p_curr_opt	= p_octet = p_next_opt;

			/*
				Check the consistency of this option
				1- is there enough data for the option ?
				2- is the option length field >= 2
				3- is the option length > the remaining data length ?
			*/

#		if ASSERT == ON	/* { */

			if ((lgth < 2) || (p_curr_opt[1] < 2) || (p_curr_opt[1] > lgth)) {

					/*
						This option is bad, the remaining options in the
						packet will be rejected.
					*/

				MPPP_DBG_ERROR ("wrong LCP option length");

				opt_lgth	= lgth; /* reject all the remaining options */
				lgth		= 0;	/* no more loop to run */

				MPPP_DBG_LEAVE ();

				return (NOK);
			}

#		endif	/* } */

			/* Get the option type (1 octet) */

		Mppp_get_char (opt_type, p_octet);

			/* Get the option length (1 octet) */

		Mppp_get_char (opt_lgth, p_octet);

			/* Update the remaining length */

		lgth -= opt_lgth;

			/* Set up the pointer to the next option */

		p_next_opt += opt_lgth;

			/* Forward processing according to the option type */

		switch (opt_type) {

				/*=========================
					Max Receive Unit (MRU)
				==========================*/

			case LCP_OPT_MRU:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej MRU(");

					/* Get and check the MRU value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_INT (opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_peer_ack_mru = LCP_MRU_I;

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_MRU);

				}
				break;


				/*======================================
					Async Character Control Map (ACCM)
				=======================================*/

			case LCP_OPT_ACCM:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej ACCM(");

					/* Get the ACCM value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/*
						We have to restore the original ACCM before sending
						the Ack/Nak/Rej to the peer system.
					*/

				Mppp_dec_ptr (4, p_octet);
				Mppp_put_long (Mppp_cep_peer_ack_accm, p_octet);

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {


					if (Sppp_cep_link_mode == SPPP_MODE_SYNC) {
						Mppp_cep_peer_ack_accm =
						Sppp_cep_peer_ack_accm = LCP_SYNC_ACCM_I;
					} else {
						Mppp_cep_peer_ack_accm =
						Sppp_cep_peer_ack_accm = LCP_ASYNC_ACCM_I;
					}


						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_ACCM);

				}
				break;

				/*======================================
					Authentication protocol (AUTH)
				=======================================*/

			case LCP_OPT_AUTH:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej AUTH(");

					/* Get the authentication protocol value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_HEX ((ushort)opt_val_ushort);

				if (opt_val_ushort == PPP_PROT_CHAP) {

						/* Get the one-way hash method to be used (if CHAP) */

					MPPP_DBG_DISPLAY_STR (",");

					Mppp_get_char (opt_val_uchar, p_octet);

					MPPP_DBG_DISPLAY_HEX ((uchar)opt_val_uchar);

				}

				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_peer_ack_auth= 0;

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_AUTH);

				} else {

						/*
							Set the local authenticator context active
							--- We are the authenticator ---
						*/

					p_sppp_auth			= Sppp_cep_p_local_auth_info;
					Sppp_auth_active	= ON;

				}
				break;

				/*==========================================
					Link Quality Monitoring protocol (LQM)
				===========================================*/

			case LCP_OPT_LQM:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej LQM(");

					/*
						Get the quality protocol (Link Quality Report)
						value and the report period value
					*/

				Mppp_get_short (opt_val_ushort, p_octet);
				Mppp_get_long (opt_val_ulong, p_octet);

				MPPP_DBG_DISPLAY_HEX ((ushort)opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (",");
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_peer_ack_lqm			= 0;
					Mppp_cep_peer_ack_lqr_period	= 0;

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_LQM);

				}
				break;

				/*========================================================
					Magic Number (MAGIC). One for each single PPP link
				=========================================================*/

			case LCP_OPT_MAGIC:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej MAGIC(");

					/* Get the MAGIC NUMBER value */

				Mppp_get_long (opt_val_ulong, p_octet);
				MPPP_DBG_DISPLAY_HEX (opt_val_ulong);
				MPPP_DBG_DISPLAY_STR (")");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

					Mppp_cep_peer_ack_magic	= 0;

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_MAGIC);

				}
				break;


				/*=====================================
					Protocol Field Compression (PFC)
				======================================*/

			case LCP_OPT_PFC:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej PFC");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_PFC);

				}
				break;


				/*=================================================
					Address and Control Field Compression (ACFC)
				==================================================*/

			case LCP_OPT_ACFC:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej ACFC");

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_ACFC);

				}
				break;


				/*===============================================
					Max Receive Reconstructed Unit (MRRU)

					This ML PPP option MUST NOT be retransmitted
					to the local PPP stack.
				================================================*/

			case LCP_OPT_MRRU:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej MRRU(");

					/* Get and check the MRRU value */

				Mppp_get_short (opt_val_ushort, p_octet);
				MPPP_DBG_DISPLAY_INT (opt_val_ushort);
				MPPP_DBG_DISPLAY_STR (")");

					/*
						This VALID option must not be sent to our local
						PPP stack.
						We move the next option up, and we adjust the
						remaining length of the packet
					*/

				Memcpy_far ((char FAR *)p_curr_out,
							(char FAR *)p_next_opt,
							(uint)(p_end_data - p_next_opt));

					/*
						Set up pointers so that the "next" option's pointer
						stays at the current option's address
					*/

				p_next_opt	= p_curr_opt = p_curr_out;

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_MRRU);

					if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_REJ) {
						Mppp_cep_mp_rejected 	= ON;
						Mppp_cep_mp_enabled		= OFF;
					}

				}
				break;

				/*=================================================
					Short Sequence Number Header Format (SSNHF)

					This ML PPP option MUST NOT be retransmitted
					to the local PPP stack.
				==================================================*/

			case LCP_OPT_SSNHF:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej SSNHF");

					/*
						This VALID option must not be sent to our local
						PPP stack.
						We move the next option up, and we adjust the
						remaining length of the packet
					*/

				Memcpy_far ((char FAR *)p_curr_out,
							(char FAR *)p_next_opt,
							(uint)(p_end_data - p_next_opt));

					/*
						Set up pointers so that the "next" option's pointer
						stays at the current option's address
					*/

				p_next_opt	= p_curr_opt = p_curr_out;

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_SSNHF);

					if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_REJ) {
						Mppp_cep_ssnhf_rejected = ON;
					}

				}
				break;


				/*=========================================
					Endpoint Discriminator Option (EDO)

					This ML PPP option MUST NOT be retransmitted
					to the local PPP stack.
				==========================================*/

			case LCP_OPT_EDO:
				MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej EDO");

					/* The length of the EDO depends on the EDO class */

				Mppp_get_char (opt_val_uchar, p_octet);

				MPPP_DBG_DISPLAY_STR ("(class=");
				MPPP_DBG_DISPLAY_INT (opt_val_uchar);
				MPPP_DBG_DISPLAY_STR (")");

				switch (opt_val_uchar) {

					case LCP_EDO_CLASS_0:		/* Null class */

							/* Fixed length EDO */

						if (opt_lgth != LCP_OPT_SZ_EDO_0) {
							MPPP_DBG_ERROR ("bad option length");
						}
						break;

					case LCP_EDO_CLASS_1:	/* Locally Assigned Address */

							/* Variable length EDO */

						if (opt_lgth > LCP_OPT_MX_SZ_EDO_1) {
							MPPP_DBG_ERROR ("bad option length");
						}
						break;

					case LCP_EDO_CLASS_2:		/* Internet Protocol (IP) address */

							/* Fixed length EDO */

						if (opt_lgth != LCP_OPT_SZ_EDO_2) {
							MPPP_DBG_ERROR ("bad option length");
						}
						break;

					case LCP_EDO_CLASS_3:	/* IEEE 802.1 Globally assigned MAC address */

							/* Fixed length EDO */

						if (opt_lgth != LCP_OPT_SZ_EDO_3) {
							MPPP_DBG_ERROR ("bad option length");
						}
						break;

					case LCP_EDO_CLASS_4:	/* PPP Magic-Number Block */

							/* Variable length EDO */

						if (opt_lgth > LCP_OPT_MX_SZ_EDO_4) {
							MPPP_DBG_ERROR ("bad option length");
						}
						break;

					case LCP_EDO_CLASS_5:	/* Public Switched Network Directory Number */

							/* Variable length EDO */

						if (opt_lgth > LCP_OPT_MX_SZ_EDO_5) {
							MPPP_DBG_ERROR ("bad option length");
						}
						break;

					default:	/* Unknown EDO class */
						MPPP_DBG_ERROR ("bad option class");
						break;


				}

					/*
						This VALID option must not be sent to our local
						PPP stack.
						We move the next option up, and we adjust the
						remaining length of the packet
					*/

				Memcpy_far ((char FAR *)p_curr_out,
							(char FAR *)p_next_opt,
							(uint)(p_end_data - p_next_opt));

					/*
						Set up pointers so that the "next" option's pointer
						stays at the current option's address
					*/

				p_next_opt	= p_curr_opt = p_curr_out;

					/* Nak-Rej'd this option */

				if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

						/* Note that the peer system refused this option */

					Sppp_cep_peer_ack_negot	&= (~LCP_NEG_EDO);

					if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_REJ) {
						Mppp_cep_edo_rejected = ON;
					}

				}
				break;


				/*===============================================
					Link Discriminator Option (LDO)

					This BACP specific option MUST NOT be
					retransmitted to the local PPP stack.
				================================================*/

#			if MPPP_BAP == ON	/* { */

				case LCP_OPT_LDO:
					MPPP_DBG_DISPLAY ("rcvd Ack-Nak-Rej LDO(");

						/* Get and check the LDO value */

					Mppp_get_short (opt_val_ushort, p_octet);
					MPPP_DBG_DISPLAY_INT (opt_val_ushort);
					MPPP_DBG_DISPLAY_STR (")");

						/*
							This VALID option must not be sent to our local
							PPP stack.
							We move the next option up, and we adjust the
							remaining length of the packet
						*/

					Memcpy_far ((char FAR *)p_curr_out,
								(char FAR *)p_next_opt,
								(uint)(p_end_data - p_next_opt));

						/*
							Set up pointers so that the "next" option's pointer
							stays at the current option's address
						*/

					p_next_opt	= p_curr_opt = p_curr_out;

						/* Nak-Rej'd this option */

					if (mppp_c_prot_event_id != MPPP_CP_EV_RCV_CFG_ACK) {

							/* Note that the peer system refused this option */

						Sppp_cep_peer_ack_negot	&= (~LCP_NEG_LDO);

						if (mppp_c_prot_event_id == MPPP_CP_EV_RCV_CFG_REJ) {
							Mppp_cep_bacp_rejected 	= ON;
							Mppp_cep_bacp_enabled	= OFF;
						}

					}
					break;

#			endif	/* MPPP_BAP == ON } */

			default:
				MPPP_DBG_WARNING ("rcvd Ack-Nak-Rej unknown option(");
				MPPP_DBG_WARNING_INT (opt_type);
				MPPP_DBG_WARNING_STR (")");
				break;

		}	/* end of switch */

			/* We set the pointer to the next output location */

		if (p_curr_out != p_next_opt) {
			Mppp_inc_ptr (opt_lgth, p_curr_out);
		}

	}	/* end of while */

		/*
			For this first single link PPP negotiation,
			we mark all the received options as negotiated for the
			bundle itself.
		*/

	Mppp_cep_peer_ack_negot	= Sppp_cep_peer_ack_negot;

		/* Let's compute the length of the formatted packet */

	Mppp_c_prot_data_size	= (ushort)(p_curr_out - Mppp_c_prot_p_data);

		/* Load the final packet length */

	Mppp_put_short ((Mppp_c_prot_data_size+PPP_PACKET_HEADER_LGTH), p_lgth);

		/*
			We are not responsible for Acking/Naking/Rejecting the
			negotiation on the FIRST member link
		*/

	MPPP_DBG_LEAVE ();

	return (OK);
}


/*-------------------------------------------------------------------------*/

		/*
						==== SEND-PAP-AUTHENTICATE-REQUEST ====

			A PAP Authenticate-Request packet is transmitted.
			The Authenticate-Request packet is used to begin the Password
			Authentication Protocol. The Restart timer is started when the
			Authenticate-Request packet is transmitted, to guard against
			packet loss. The Restart counter is decremented each time a
			Authenticate-Request is sent.
		*/

void mppp_c_prot_send_pap_auth_request ()
{
	MPPP_DBG_FUNC ("mppp_c_prot_send_auth_request()")

	uchar			FAR *p_curr;
	uchar			FAR *p_curr_start;
	uchar			FAR *p_data_start;
	ushort				data_size;
	struct buffer	FAR *p_buffer;

	MPPP_DBG_ENTER ();

	mppp_current_ppp_pid = PPP_PROT_PAP;

	p_buffer		= Alloc_buffer ();

	p_data_start	= Buffer_a_start_data;
	p_curr			=
	p_curr_start	= (p_data_start+PPP_PACKET_HEADER_LGTH+PPP_FRAME_HEADER_LGTH);

	Mppp_put_char		(Mppp_cep_username_lgth, p_curr);
	Memcpy_far ((char FAR *)p_curr, (char FAR *)Mppp_cep_p_username, Mppp_cep_username_lgth);
	p_curr	+= Mppp_cep_username_lgth;

	Mppp_put_char		(Mppp_cep_password_lgth, p_curr);
	Memcpy_far ((char FAR *)p_curr, (char FAR *)Mppp_cep_p_password, Mppp_cep_password_lgth);
	p_curr	+= Mppp_cep_password_lgth;

		/* Update the PPP packet identifier */

	if (mppp_c_prot_event_id != MPPP_CP_EV_TIMEOUT) {
		Sppp_auth_s_packet_id++;
	}

		/* Prepare the PPP frame for sending */

	data_size	= mppp_prepare_packet_to_send (PPP_PROT_PAP,
												MPPP_CP_PCK_PAP_AUTH_RQ,
												Sppp_auth_s_packet_id,
												p_data_start,
												(p_curr - p_curr_start));

		/* Set the buffer size, and allocate a message for sending */

	Buffer_data_size	= data_size;
	p_snd_msg			= Msg_or_buffer (p_buffer, 0);

	MPPP_DBG_NOTICE ("sending PAP Auth-Req");

		/* Set the Authenticate state */

	Set_auth_state_request_sent;

		/* Queue this message */

	mppp_in_sppp_tx_queue ();

		/* Send a data message to the lower entity */

	mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_link_mode_accm (Sppp_cep_link_mode));

		/* Decrement the authenticate count, and start the restart timer */

	Sppp_auth_count--;
	Sppp_auth_start_timer (MPPP_PAP_TI_X_RESTART);

	MPPP_DBG_LEAVE ();

}

/*--------------------------------------------------------------------------*/

/* EOF */

