
/*--------------------------------------------------------------------------*
 *						 M O D U L E   H E A D E R
 *
 * filename - mppp.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		mppp - implements a Multi Link PPP entity entry point.
 *
 *		mppp_config - implements the construction of the ML PPP layer
 *		objects
 *
 *		mppp_config_sl_ppp - implements the intialization of the SL PPP
 *		objects
 *
 *		mppp_config_ml_ppp - implements the intialization of the ML PPP
 *		objects
 *
 *		mppp_reset_config - implements the resetting of the ML PPP layer
 *		objects
 *
 *		mppp_audit_in - implements the audit management of the ML PPP state.
 *
 *		mppp_var_init - init of ML PPP entity's global variables.
 *
 *		mppp_process_ti_msg - implements the processing of Timer
 *					messages.
 *
 *		mppp_process_sm_msg - implements the processing of SM messages
 *						other than (RE)SET_CONFIG_RQ.
 *
 *		mppp_process - implements the main processing function of the
 *						  ML PPP.
 *
 *		mppp_process_ext_events - implements the main processing
 *						function of the ML PPP external events.
 *
 *		mppp_check_link_busy - implements the checking of the member
 *						links outgoing FC BUSY state.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    Multi Link PPP Entity                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1997 by OMNITEL SA                 |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/


#include "mppp.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#if REVISION_STRING == ON
#	include "rev.mppp"
#endif

/*-------------------------------------------------------------------------*/

				/* Additional Header Files */

#include "lcp.h"		/* LCP definitions */
#include "mlcp.h"		/* MLCP definitions */
#include "mp.h"			/* MP definitions */

#if MPPP_BAP == ON
#	include "bacp.h"	/* BACP definitions */
#	include "bap.h"		/* BAP definitions */
#endif

/*-------------------------------------------------------------------------*/

			/* Copyright */

CONST char			mppp_copyright[]	= "Copyright (c) 1997 by OMNITEL SA - All Rights Reserved";
CONST char			mppp_licence[]	= LICENSE_NBER;

/*-------------------------------------------------------------------------*/

			/* LOCAL FUNCTIONS PROTOTYPES */

#if NEW_FCT_STYLE == ON

	uchar		mppp_check_edo_add_lgth		(uchar edo_class, uchar edo_add_lgth);

#	if RESET_CONFIG == ON
		uchar	mppp_reset_config_ml_ppp	(nai_t nai);
		uchar	mppp_reset_config_sl_ppp	(nai_t nai);
#	endif

#else

	uchar		mppp_check_edo_add_lgth		();

#	if RESET_CONFIG == ON
		uchar	mppp_reset_config_ml_ppp	();
		uchar	mppp_reset_config_sl_ppp	();
#	endif

#endif

/*-------------------------------------------------------------------------*/

			/* ML PPP init flag */

uchar				mppp_init_flag;


		/* Common variables : ML PPP context */

Entity_common (mppp);			/* common ML PPP entity variables */

struct	node		FAR *p_mppp_tree;		/* pointer on the top of the tree object structure */
struct	node		FAR *p_sppp_tree;		/* pointer on the top of the tree object structure */

#if OPTIMIZATION == SPEED
	struct	mppp_na			FAR *FAR *p_mppp_na_tab;	/* access table */
	struct	sppp_na FAR *FAR *p_sppp_na_tab;	/* access table */
#endif

struct	mppp_na			FAR *p_mppp_na;			/* pointer on the current ML PPP network access object */
struct	mppp_sap		FAR *p_mppp_sap;		/* pointer on the current ML PPP service access point object */
struct	mppp_cep		FAR *p_mppp_cep;		/* pointer on the current ML PPP connection end point object */

struct	sppp_na			FAR *p_sppp_na;			/* pointer on the current SL PPP network access object */
struct	sppp_cep		FAR *p_sppp_cep;		/* pointer on the current SL PPP CEP object */

struct	mppp_c_prot		FAR *p_mppp_c_prot;		/* pointer on the current Control Protocol context */
struct	sppp_auth		FAR *p_sppp_auth;		/* pointer on the current Authentication context */

code_t						mppp_event_type;	/* internal event type */
sapi_t						mppp_local_sapi;	/* internal local SAPI */

ushort						mppp_current_ppp_pid;	/* curent PPP protocol ID */

uchar						mppp_c_prot_rej_packet_code;	/* rejected control packet code */
code_t						mppp_c_prot_event_id;	/* Control Protocol event ID */

nai_t						mppp_error_nai;			/* cuurrent NAI for error message */
sapi_t						mppp_error_sapi;		/* cuurrent SAPI for error message */
add_t						mppp_error_ces;			/* CES for error message */
ent_id_t					mppp_error_entity_id;	/* entity ID for error message */

uchar						mppp_auth_r_packet_code;	/* received PAP/CHAP packet code */
uchar						mppp_auth_r_packet_id;		/* received PAP/CHAP packet Id */
uchar						mppp_auth_s_packet_code;	/* PAP/CHAP packet code to send */
uchar						mppp_auth_s_packet_id;		/* PAP/CHAP packet Id to send */

/*-------------------------------------------------------------------------*/

			/* ML PPP timer event ID */

CONST_ARRAY code_t		MPPP_CP_TI_EV_ID [] = {MPPP_LCP_TI_RESTART, MPPP_BACP_TI_RESTART, MPPP_BAP_TI_RESTART};

/*-------------------------------------------------------------------------*/

			/* Authentication timer event ID */

CONST_ARRAY code_t		MPPP_AUTH_TI_EV_ID [] = {MPPP_PAP_TI_RESTART};

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp - implements the Multi Link PPP entity
					entry point.

Usage			uchar mppp (p_msg);

*--------------------------------------------------------------------------*/

uchar mppp (p_msg)
	struct message		FAR *p_msg;				/* pointer on received message */
{

	MPPP_DBG_FUNC ("mppp()")

	uchar				FAR *p_data;		/* pointer to message/buffer data */
	struct mppp_config	FAR *p_mppp_cfg;	/* pointer on the configuration data */

	MPPP_DBG_ENTER ();

		/* Init the entity pointers */

	p_rcv_msg	= p_msg;			/* received message pointer */
	p_buffer	= R_msg_p_buffer;	/* asociated buffer */
	p_snd_msg	= P_NIL;			/* send buffer to NIL */
	p_data		= R_a_data;

		/* Init objects context pointers to P_NIL */

	p_mppp_na		= P_NIL;
	p_mppp_sap		= P_NIL;
	p_mppp_cep		= P_NIL;
	p_sppp_na		= P_NIL;
	p_sppp_cep		= P_NIL;
	p_mppp_c_prot	= P_NIL;
	p_sppp_auth		= P_NIL;

		/* Initialize ML PPP global event type */

	mppp_event_type = EV_NIL;

	if (R_msg_from == ENT_SM) {

		switch (R_msg_code) {

			case SM_SET_CONFIG_RQ:


				p_mppp_cfg	= (struct mppp_config FAR *)p_data;
				ret_code	= 0;

				if ((Mppp_cfg_ret_code = mppp_config (p_mppp_cfg)) != OK)  {
					Mppp_cfg_cause		= ret_code;		/* internal return code */
					Mppp_cfg_diagnostic = ENT_MPPP;
					mppp_init_flag		= OFF;
				} else {
					Mppp_cfg_cause		= 0;
					Mppp_cfg_diagnostic = 0;
					mppp_init_flag		= ON;
				}

					/* Send back the confirm message to SM */

				mppp_retransmit (SM_SET_CONFIG_CO, ENT_SM);
				break;

#			if RESET_CONFIG == ON	/* { */

					/* ML PPP RESET CONFIGURATION request */

				case SM_RESET_CONFIG_RQ :

					Confirm_ret_code = mppp_reset_config (R_msg_nai);
					Confirm_cause	= 0;

						/* Retransmit to SM with an error code */

					mppp_retransmit (SM_RESET_CONFIG_CO, ENT_SM);
					break;

#			endif	/* RESET_CONFIG == ON } */

			default :

				if (mppp_init_flag == ON) {

					mppp_process_sm_msg ();

				} else {

						/*
							Init not done
							---> requeue the incoming message
					*/

					Send_message (p_rcv_msg); p_rcv_msg = P_NIL;

				}
				break;

		}

	} else {

			/*
				Messages from entity other than SM.
				Is configuration already done ?
			*/

		if (mppp_init_flag == ON) {

				/* Yes - process the received message */

			mppp_process ();

		} else {

				/*
					ML PPP entity not yet initialized,
					---> requeue the received message
				*/

			Send_message (p_rcv_msg);
			p_rcv_msg = P_NIL;

			MPPP_DBG_LEAVE ();

			return (OK);

		}

	}

	if ((p_rcv_msg != P_NIL) && (R_msg_lib == ON)) {
		Free_msg (p_rcv_msg); p_rcv_msg = P_NIL;
	}

	p_buffer	= P_NIL;

	MPPP_DBG_LEAVE ();

	return (OK);
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_process_ti_msg - implements the processing of Timer
					messages.

Usage			void mppp_process_ti_msg (void);

Description		mppp_process_ti_msg processes a TIMER originated message.

Return value	void

Common constants and declarations : mppp.h

Common objects : p_rcv_msg : pointer on the received message

*--------------------------------------------------------------------------*/

void mppp_process_ti_msg ()
{
	MPPP_DBG_FUNC ("mppp_process_ti_msg()")

	MPPP_DBG_ENTER ();

		/* Find the bundle context */

	if (mppp_access_object (MPPP_ACC_TYPE_DATA, R_msg_nai, R_msg_sapi, R_msg_conn_id) != OK) {

		MPPP_DBG_ERROR ("access_object failed");
		MPPP_DBG_LEAVE ();

		return;

	}


		/* Dispatch according to the received event */

	switch (event_id) {

		case MPPP_LCP_TI_RESTART:

			for (mppp_access_first_sppp_in_bundle ();
				p_sppp_cep != P_NIL;
				mppp_access_next_sppp_in_bundle ()) {

				p_mppp_c_prot	= Sppp_cep_p_lcp_info;

				if (Mppp_c_prot_valid_time_out (MPPP_LCP_TI_X_RESTART)) {

						/* Call the LCP state machine */

					mppp_current_ppp_pid	= Mppp_c_prot_ppp_pid;
					mppp_event_type 		= MPPP_EV_TYPE_LCP;
					mppp_c_prot_event_id	= MPPP_CP_EV_TIMEOUT;

					mppp_c_prot_state_machine ();

					break;
				}

			}
			break;

		case MPPP_PAP_TI_RESTART:
			mppp_c_prot_event_id	= MPPP_CP_EV_TIMEOUT;
			mppp_current_ppp_pid	= PPP_PROT_PAP;
			mppp_event_type 		= MPPP_EV_TYPE_PAP;

			for (mppp_access_first_sppp_in_bundle ();
				p_sppp_cep != P_NIL;
				mppp_access_next_sppp_in_bundle ()) {

				p_sppp_auth	= Sppp_cep_p_peer_auth_info;

				if (Sppp_auth_valid_time_out (MPPP_PAP_TI_X_RESTART)) {

						/* Call the AUTH state machine */

					mppp_auth_state_machine (mppp_current_ppp_pid);
					break;
				}

			}
			break;

#		if MPPP_BAP == ON	/* { */

			case MPPP_BACP_TI_RESTART:

					/* Is it a timer event for the bundle BACP negotiation ? */

				p_mppp_c_prot	= Mppp_cep_p_bacp_info;

				if (Mppp_c_prot_valid_time_out (MPPP_BACP_TI_X_RESTART)) {

					mppp_access_first_sppp_in_bundle ();

						/* Call the BACP state machine */

					mppp_current_ppp_pid	= Mppp_c_prot_ppp_pid;
					mppp_event_type 		= MPPP_EV_TYPE_BACP;
					mppp_c_prot_event_id	= MPPP_CP_EV_TIMEOUT;

					mppp_c_prot_state_machine ();

				}
				break;

			case MPPP_BAP_TI_RESTART:

					/* Is it a timer event for the bundle BAP ? */

				p_mppp_c_prot	= Mppp_cep_p_bap_info;

				if (Mppp_c_prot_valid_time_out (MPPP_BAP_TI_X_RESTART)) {

					mppp_access_first_sppp_in_bundle ();

						/* Call the BAP state machine */

					mppp_current_ppp_pid	= Mppp_c_prot_ppp_pid;
					mppp_event_type 		= MPPP_EV_TYPE_BAP;
					mppp_c_prot_event_id	= MPPP_CP_EV_TIMEOUT;

					bap_state_machine ();

				}
				break;


#		endif	/* MPPP_BAP == ON } */


		default:
			MPPP_DBG_ERROR ("unknown Timer event(");
			MPPP_DBG_ERROR_INT (event_id);
			MPPP_DBG_ERROR_STR (")");
			break;

	}


	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_process_sm_msg - implements the processing of SM messages
					other than (RE)SET_CONFIG_RQ.

Usage			void mppp_process_sm_msg (void);

Description		mppp_process_sm_msg processes a SM originated message.

Return value	void

Common constants and declarations : mppp.h

Common objects : p_rcv_msg : pointer on the received message

*--------------------------------------------------------------------------*/

void mppp_process_sm_msg ()

{
	MPPP_DBG_FUNC ("mppp_process_sm_msg()")

	nai_t		nai;		/* Network Access ID */
	uchar 	FAR *p_data;	/* data pointer */

	MPPP_DBG_ENTER ();

	event_id	= R_msg_code;
	nai			= R_msg_nai;
	p_data		= R_a_data;

		/* NA dependent message */

	switch (event_id) {

		case SM_STOP_RQ :

			if ((mppp_access_na (nai) == OK) && (mppp_access_sppp_na (nai) == OK)) {

					/* Set this Member Link NA inactive */

				Sppp_na_active	= OFF;
	
					/* Set this Bundle NA inactive and send back a confirmation */
		
				Mppp_na_active	= OFF;

				Confirm_ret_code = OK;

			} else {

				Confirm_ret_code	= NOK;
				Confirm_cause		= 0;
				Confirm_diagnostic	= ENT_MPPP;

			}

			mppp_retransmit (SM_STOP_CO, ENT_SM);
			break;

		case SM_BUSY_RQ:
		case SM_CLEAR_BUSY_RQ:

				/* Set the resource congestion state in NA coontexts */

			for (mppp_access_first_na (); p_mppp_na != P_NIL; mppp_access_next_na ()) {

				if (Mppp_na_active == ON) {
					Mppp_na_system_state = (event_id == SM_BUSY_RQ) ? BUSY : FREE;
				}

			}
			break;

		default:
			MPPP_DBG_WARNING ("received unknown SM primitive(");
			MPPP_DBG_WARNING_BYTE (event_id);
			MPPP_DBG_WARNING_STR  (")");
			break;
	}

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_process_ext_events - implements the main processing
					function of the ML PPP external events.

Usage			uchar mppp_process_ext_events (void);

Description		mppp_process_ext_events implements the processing of a received
					external event message.

Return value	OK
				NOK
				STOP

Common constants and declarations : mppp.h

Common objects : p_rcv_msg : pointer on the received message

*--------------------------------------------------------------------------*/

uchar mppp_process_ext_events ()

{
	MPPP_DBG_FUNC ("mppp_process_ext_events()")

	mppp_cause_t	cause_code;		/* MPPP cause value */
	mppp_diag_t		diag_code;		/* MPPP diagnostic value */
	uchar			send_confirm;	/* flag for sending immediate confirmation */

	MPPP_DBG_ENTER ();

	cause_code		= MPPP_CAUSE_SUCCESS;
	diag_code		= MPPP_DIAG_NO_INFO;
	send_confirm	= OFF;


		/* Set the Control Protocol event ID */

	switch (event_id) {

			/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
					OPEN/CLOSE BUNDLE REQUEST
					(For the 1st member link only)
			*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

		case MPPP_EXT_OPEN_RQ :
		case MPPP_EXT_CLOSE_RQ :

			if (p_sppp_cep != P_NIL) {

				if (Is_sppp_first_in_bundle ()) {

					p_mppp_c_prot 			= Sppp_cep_p_lcp_info;

					mppp_current_ppp_pid	= PPP_PROT_LCP;
					mppp_event_type 		= MPPP_EV_TYPE_LCP;

					if (event_id == MPPP_EXT_OPEN_RQ) {

						Mppp_cep_data_state		= MPPP_AWAITING_EST;

						mppp_c_prot_event_id	= MPPP_CP_EV_OPEN;
						Mppp_cep_open_rq_flag	= ON;
						Mppp_cep_close_rq_flag	= OFF;

					} else {

						Mppp_cep_data_state		= MPPP_AWAITING_REL;

						mppp_c_prot_event_id 	= MPPP_CP_EV_CLOSE;
						Mppp_cep_open_rq_flag	= OFF;
						Mppp_cep_close_rq_flag	= ON;
					}

				} else {

						/* Not the first member link */

					cause_code	= MPPP_CAUSE_REQUEST_REFUSED;
					diag_code	= MPPP_DIAG_NOT_FIRST_LINK;

				}

			} else {

					/* No valid member link for this OPEN/CLOSE request */

				cause_code	= MPPP_CAUSE_REQUEST_REFUSED;
				diag_code	= MPPP_DIAG_NO_MEMBER_LINK;

			}
			break;


			/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
					ADD MEMBER LINK REQUEST
			*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

		case MPPP_EXT_ADD_LINK_RQ :

				/* Is there any member link context available ? */

			if (Mppp_cep_used_sppp_nb == Mppp_cep_sppp_nb) {

				cause_code	= MPPP_CAUSE_REQUEST_REFUSED;
				diag_code	= MPPP_DIAG_BUNDLE_BUSY;

			} else if (Mppp_cep_mp_enabled == OFF) {

				cause_code	= MPPP_CAUSE_REQUEST_REFUSED;
				diag_code	= MPPP_DIAG_NO_MULTILINK;

			} else {

					/* Find a free member link context */

				for (mppp_access_first_sppp_in_bundle ();
						p_sppp_cep != P_NIL;
						mppp_access_next_sppp_in_bundle ()) {

					p_mppp_c_prot 	= Sppp_cep_p_lcp_info;

						/*
							The first member link MUST be in
							LCP NETWORK-PROTOCOL Phase
						*/

					if (Is_sppp_first_in_bundle ()) {

						if (Sppp_cep_link_phase == SPPP_LINK_PHASE_NETWORK) {

							continue;

						} else {

							cause_code	= MPPP_CAUSE_REQUEST_REFUSED;
							diag_code	= MPPP_DIAG_FIRST_LINK_NOT_OPENED;

							break;

						}

					}

						/* Not the first member link */

#					if MPPP_BAP == ON	/* { */

							/* Check if we MUST use the BAP */

						if ((Mppp_cep_bacp_usage == ON) &&
							(Mppp_cep_bacp_enabled == ON)) {

								/*
									This request MUST be processed by the
									the BAP state machine
								*/

							p_mppp_c_prot	= Mppp_cep_p_bap_info;

							bap_state_machine ();
							break;

						}

#					endif	/* MPPP_BAP == ON } */

						/* The BAP is not available */

#					if MPPP_CC == ON	/* { */

						if (Sppp_cep_cc_entity_id != ENT_NIL) {

							if (Sppp_cep_cc_state == MPPP_CC_STATE_NULL) {

									/* Format and send the connect request message */

								if (mppp_make_cc_call_rq () == OK) {

										/* Signal the OPEN event to the state machine */

									mppp_event_type = MPPP_EV_TYPE_LCP;
									mppp_c_prot_event_id = MPPP_CP_EV_OPEN;

									mppp_c_prot_state_machine ();

								}
								break;

							}

						} else

#					else	/* } { */

						Sppp_cep_cc_entity_id	= ENT_NIL;

#					endif	/* MPPP_CC == ON } */

							/* !!! Do not add any code here */

						{

								/* No ISDN call to establish */

							if ((Sppp_cep_data_state == SPPP_RELEASED) ||
								((Sppp_cep_data_state == SPPP_ESTABLISHED)
									&&
								(Mppp_c_prot_state == MPPP_CP_STATE_CLOSED))) {

									/*
										We force a transition to LCP INITIAL
										state for a clean start.
									*/

								Set_c_prot_state_initial;

									/*
										Signal the LCP OPEN event.
									*/

									/* Set Control Protocol information */

								mppp_current_ppp_pid	= PPP_PROT_LCP;
								mppp_event_type 		= MPPP_EV_TYPE_LCP;
								mppp_c_prot_event_id 	= MPPP_CP_EV_OPEN;

								break;
							}

						}


				}


					/* Continue the ADD LINK process if no error to signal */

				if (cause_code == MPPP_CAUSE_SUCCESS) {

						/* Any context found ? */

					if (p_sppp_cep == P_NIL) {

						cause_code	= MPPP_CAUSE_REQUEST_REFUSED;
						diag_code	= MPPP_DIAG_BUNDLE_BUSY;

					} else {

							/* Set the flag for adding the new member link */

						Sppp_cep_link_add_rq_flag	= ON;

					}

				}

			}
			break;


			/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
					DROP MEMBER LINK REQUEST
			*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

		case MPPP_EXT_DROP_LINK_RQ :


#			if MPPP_BAP == ON	/* { */

				if ((Mppp_cep_bacp_usage == ON) &&
					(Mppp_cep_bacp_enabled == ON)) {

						/*
							This request MUST be processed by the
							the BAP state machine
						*/

					mppp_access_first_sppp_in_bundle ();

					p_mppp_c_prot 	= Sppp_cep_p_lcp_info;

					if (Mppp_c_prot_state == MPPP_CP_STATE_OPENED) {

						p_mppp_c_prot	= Mppp_cep_p_bacp_info;

						bap_state_machine ();

					} else {

							/* Cannot process this request */

						cause_code	= MPPP_CAUSE_REQUEST_REFUSED;
						diag_code	= MPPP_DIAG_FIRST_LINK_NOT_OPENED;

						break;
					}

				}

#			endif	/* MPPP_BAP == ON } */


#			if MPPP_CC == ON	/* { */

				if (Sppp_cep_cc_entity_id != ENT_NIL) {

					if (Sppp_cep_cc_state == MPPP_CC_STATE_NULL) {

						cause_code		= MPPP_CAUSE_UNDEFINED;
						diag_code		= MPPP_DIAG_LINK_NOT_ACTIVE;

						send_confirm 	= ON;
						goto finish_drop_now;

					} else if (Sppp_cep_data_state == SPPP_RELEASED) {

							/* Request the ISDN call clearance */

						mppp_clear_cc_call_rq ();

							/* Signal the CLOSE event to the state machine */

						mppp_event_type		 = MPPP_EV_TYPE_LCP;
						mppp_c_prot_event_id = MPPP_CP_EV_CLOSE;

						mppp_c_prot_state_machine ();

						break;
					}

				} else

#			endif	/* MPPP_CC == ON } */

				/* !!! No additional code here */

			{

				if (Sppp_cep_data_state == SPPP_RELEASED) {

					cause_code		= MPPP_CAUSE_UNDEFINED;
					diag_code		= MPPP_DIAG_LINK_NOT_ACTIVE;

					send_confirm = ON;
					goto finish_drop_now;

				}


			}

				/* Start the link termination */

			Sppp_cep_link_drop_rq_flag	= ON;
			mppp_current_ppp_pid		= PPP_PROT_LCP;
			mppp_event_type 			= MPPP_EV_TYPE_LCP;

			mppp_c_prot_event_id 		= MPPP_CP_EV_CLOSE;


finish_drop_now:

				/* Send the confirmation now ? */

			if (send_confirm == ON) {

					/* Format and send an immediate confirmation */

				mppp_snd_ext_drop_link_in_co (MPPP_EXT_DROP_LINK_CO,
												cause_code,
												diag_code,
												MPPP_ORIGIN_USER);

				MPPP_DBG_LEAVE ();

				return (STOP);

			}
			break;

		default:
			break;

	}

		/* Any error to signal ? */

	if (cause_code != MPPP_CAUSE_SUCCESS) {

			/* Format and send the error indication */

		mppp_snd_error_in (cause_code, diag_code, R_msg_sapi);

		MPPP_DBG_LEAVE ();

		return (STOP);

	}

	MPPP_DBG_LEAVE ();
	return (OK);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_check_link_busy - implements the checking of the member
					links outgoing FC BUSY state.

Usage			uchar mppp_check_link_busy (void);

Description		mppp_check_link_busy checks the BUSY condition of the member
					links and sends MPPP_BUSY_IN to the upper if necessary.
					If the member links exit from the BUSY condition, the
					MPPP_CLEAR_BUSY_IN is sent.

Return value	STOP		a MPPP_(CLEAR)BUSY_IN message has been sent, or
							no bundle.
				CONTINUE	continue normal processing

Common constants and declarations : mppp.h

Common objects : context pointers.

*--------------------------------------------------------------------------*/


#if MPPP_FC == ON	/* { */

uchar mppp_check_link_busy ()
{
	MPPP_DBG_FUNC ("mppp_check_link_busy()")

	code_t	code;
	uchar	result;

	MPPP_DBG_ENTER ();

	code	= EV_NIL;
	result	= CONTINUE;

	if (p_mppp_cep == P_NIL) {

			/* No bundle context. Nothing to do */

		MPPP_DBG_LEAVE ();

		return (STOP);
	}

	if (Mppp_cep_opened_sppp_nb == 0) {

			/* No OPENED link. Nothing to do */

		MPPP_DBG_LEAVE ();

		return (CONTINUE);

	}

	if (Mppp_cep_busy_sppp_nb == Mppp_cep_opened_sppp_nb) {

			/* All the member links are in outgoing FC BUSY state */

		if (Mppp_cep_out_fc_state == FREE) {

				/* Set FC mark state to BUSY */

			Mppp_cep_out_fc_state	= BUSY;

			code	= MPPP_BUSY_IN;

			MPPP_DBG_NOTICE ("MPPP_BUSY_IN");

		}

	} else if (Mppp_cep_busy_sppp_nb < Mppp_cep_opened_sppp_nb) {

		if ((Mppp_cep_out_fc_state == BUSY) && (Mppp_na_system_state == FREE)) {

				/* Set FC mark state to FREE */

			Mppp_cep_out_fc_state	= FREE;

			code	= MPPP_CLEAR_BUSY_IN;

			MPPP_DBG_NOTICE ("MPPP_CLEAR_BUSY_IN");

		}

	}

	if (code != EV_NIL) {

			/* Send a MPPP_BUSY_IN or MPPP_CLEAR_BUSY_IN to the upper layer */

		p_snd_msg		= Alloc_msg ();
		S_msg_nai		= Mppp_na_nai;
		S_msg_ces		= Mppp_cep_ces;

			/* Send message to upper layer */

		mppp_snd_msg_to_user (Mppp_sap_data_upper_entity_id, Mppp_sap_data_sapi, code);

		if (code == MPPP_CLEAR_BUSY_IN) {

				/*
					Restart the sending of queued messages on
					this bundle
				*/

			mppp_process_pending_tx ();

		}

		result	= STOP;

	}


	MPPP_DBG_LEAVE ();

	return (result);
}

#endif	/* MPPP_FC == ON } */


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_process - implements the main processing function of the
				  ML PPP.

Usage			void mppp_process (void);

Description		mppp_process implements the processing of a received message.

Return value	void

Common constants and declarations : mppp.h

Common objects : p_rcv_msg : pointer on the received message

*--------------------------------------------------------------------------*/

void mppp_process ()
{

	MPPP_DBG_FUNC ("mppp_process()")

	MPPP_DBG_ENTER ();

		/* Determine the event type and set context pointers */

	ret_code  = mppp_rcv ();


#	if MPPP_FC == ON

			/*
				Check the busy state of the member links and send MPPP_BUSY_IN
				if all the member links are in outgoing BUSY state.

				Send MPPP_CLEAR_BUSY_IN if links are available again for
				outgoing data transfer.
			*/

		if (mppp_check_link_busy () == STOP) {

				/*
					BUSY or CLEAR_BUSY indication sent to the upper entity,
					or no bundle's context present.
				*/

			MPPP_DBG_LEAVE ();
			return;

		}

#	endif

		/* Dispatch according to the return code */

	switch (ret_code) {

			/*
				OK then continue to process
				the received message.
			*/

		case OK :
			mppp_state_proc ();
			break;

				/* STOP: processing completed */

		case STOP :
			break;

				/* NOK : error condition detected */

		case NOK :
			break;

		default :

#			if ASSERT == ON
				Trap (TRAP_MPPP_RET_CODE, "mppp_process");
#			else
				break;
#			endif

	}


#	if MPPP_SIM_ANALYSER == ON
		pr_mppp_state ();
#	endif


#	if ((MPPP_AUDIT == ON) && (ASSERT == ON))

		if (performance == OFF) {
			mppp_audit_in ();
		}

#	endif

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_config_sl_ppp - implements the initialization of
							 the SL PPP objects.

Usage			uchar mppp_config_sl_ppp (struct sppp_config FAR *s_mppp_cfg);
					- p_sppp_cfg : pointer on configuration data.

Description		mppp_config_sl_ppp implements the initialization of the
				SL PPP objects (sppp_na, sppp_cep) on a tree structure.

Return value	uchar return code = OK configuration is done,
									NOK configuration has failed.

Common constants and declarations : mppp.h

Common objects	sppp_na		: network access
				sppp_cep	: SL PPP connection end point

*--------------------------------------------------------------------------*/

uchar mppp_config_sl_ppp (p_sppp_cfg)
	struct sppp_config	FAR *p_sppp_cfg;
{

	MPPP_DBG_FUNC ("mppp_config_sl_ppp()")

	uchar					 i, j;				/* index */
	struct sppp_cfg_na	FAR *p_sppp_cfg_na;		/* pointer on the current na object of
												   the configuration data */
	struct sppp_cfg_cep FAR *p_sppp_cfg_cep;	/* pointer on the current CEP object of
												   the configuration data */

	MPPP_DBG_ENTER ();

		/* +++++++++++++++ SL PPP NA loop ++++++++++++++++++++++++++ */

	for (i = 0; i < Sppp_cfg_na_nb; i++) {

			/* Init p_sppp_na : pointer on SL PPP NA */

		p_sppp_cfg_na = &Sppp_cfg_object_na (i);	/* current pointer in the configuration */

		if (mppp_access_sppp_na (Sppp_cfg_na_nai) == NOK) {

			ret_code = MPPP_CFG_ERR_UNKNOWN_SPPP_NAI;

			MPPP_DBG_ERROR ("unknown member link nai");
			MPPP_DBG_LEAVE ();

			return (NOK);
		}

			/* Recopy NA values from the configuration structure */

		Sppp_na_cep_nb		= Sppp_cfg_na_cep_nb;	/* number of SL PPP CEP */

				/*---------------- SL PPP CEP loop ---------------------*/

		for (j = 0, mppp_access_first_sppp_cep (); p_sppp_cep != P_NIL; mppp_access_next_sppp_cep (), j++) {

				/* Message configuration CEP structure pointer */

			p_sppp_cfg_cep	= &Sppp_cfg_object_cep (i, j);

				/* Recopy SL PPP CEP information from the configuration */

			Sppp_cep_link_type			= Set_default (Sppp_cfg_cep_link_type, SPPP_LINK_ISDN_B);	/* SL PPP link type */
			Set_sppp_cep_link_phase (SPPP_LINK_PHASE_DEAD);				/* SL PPP Link Phase */
			Sppp_cep_link_speed			= Set_default (Sppp_cfg_cep_link_speed, SPPP_SPEED_64KBPS); /* SL PPP link speed in kbps */
			Sppp_cep_link_mode			= Set_default (Sppp_cfg_cep_link_mode, SPPP_MODE_SYNC);		/* SL PPP link mode */
			Sppp_cep_link_drop_rq_flag	= OFF;				/* Link DROP requested (ON/OFF) */
			Sppp_cep_link_add_rq_flag	= OFF;				/* Link ADD requested (ON/OFF) */

			Sppp_cep_cc_entity_id		= Sppp_cfg_cep_cc_entity_id;	/* SL PPP signalling entity */
			Sppp_cep_cc_nai				= Sppp_cfg_cep_cc_nai;		/* SL PPP NAI for signalling */
			Sppp_cep_cc_sapi			= Sppp_cfg_cep_cc_sapi;		/* SL PPP signalling SAPI */
			Sppp_cep_cc_sapi_mgt		= Sppp_cfg_cep_cc_sapi_mgt;	/* SL PPP signalling Management SAPI */
			Sppp_cep_cc_conn_id			= ADD_NIL;					/* SL PPP signalling CONN ID */
			Sppp_cep_cc_state			= MPPP_CC_STATE_NULL;

			Sppp_cep_data_entity_id		= Sppp_cfg_cep_data_entity_id;	/* SL PPP data entity */
			Sppp_cep_data_nai			= Sppp_cfg_cep_data_nai;		/* SL PPP NAI for dat */
			Sppp_cep_data_sapi			= Sppp_cfg_cep_data_sapi;		/* SL PPP data SAPI */
			Sppp_cep_data_conn_id		= Sppp_cfg_cep_data_conn_id;	/* SL PPP data DL CES or PH chani */
			Sppp_cep_data_chani			= ADD_NIL;				/* SL PPP channel ID */
			Sppp_cep_data_state			= SPPP_RELEASED;		/* SL PPP data channel state */
			Sppp_cep_data_hole_size		= Sppp_cfg_cep_data_hole_size;	/* SL PPP data hole size in xxx_DA_RQ */
			Sppp_cep_data_check_flags	= Sppp_cfg_cep_data_check_flags;	/* checking of PPP frame FLAG and FCS */

			Sppp_cep_data_out_busy		= OFF;				/* outgoing flow control busy state */
			Sppp_cep_rcv_frame_state	= PPP_RFS_FIRST_FRAME_START;	/* PPP_FLAG is expected */

			Sppp_cep_ass_frame_p_msg	= P_NIL;
			Sppp_cep_ass_frame_fcs		= PPP_FCS_INIT_VAL;
			Sppp_cep_ass_frame_escape	= FALSE;


#			if MPPP_LCP_EXTENSIONS == ON	/* { */

					/* Copy the Callback information from the configuration data */

#				if MPPP_CALLBACK_PER_LINK == ON	/* { */

					if (Sppp_cfg_cep_callback_msg_lgth > MPPP_MX_SZ_CALLBACK_MSG) {

						ret_code	= MPPP_CFG_ERR_CALLBACK_LGTH;

						MPPP_DBG_ERROR ("member link's callback out of range");
						MPPP_DBG_LEAVE ();

						return (NOK);

					}

					Sppp_cep_peer_ack_callback_op		= Sppp_cfg_cep_callback_op;
					Sppp_cep_peer_ack_callback_msg_lgth	= Sppp_cfg_cep_callback_msg_lgth;

					Memcpy_far ((char FAR *)&Sppp_cep_peer_ack_callback_msg[0],
								(char FAR *)&Sppp_cfg_cep_callback_msg[0],
								Sppp_cep_peer_ack_callback_msg_lgth);

#				endif	/* } */


#			endif	/* } */


		} /* ---------------------- End of SL PPP CEP loop ----------*/

		Sppp_na_active	= ON;		/* set the NA active */

	}	/* ----------------------- End SL PPP NA loop -------------------*/

	MPPP_DBG_LEAVE ();

	return (OK);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_config_ml_ppp - implements the initialization of
							 the ML PPP objects.

Usage			uchar mppp_config_ml_ppp (struct mppp_config FAR *p_mppp_cfg);
					- p_mppp_cfg : pointer on configuration data.

Description		mppp_config_ml_ppp implements the initialization of the
				ML PPP objects (na, sppp_cep) on a tree structure.

Return value	uchar return code = OK configuration is done,
									NOK configuration has failed.

Common constants and declarations : mppp.h

Common objects	mppp_na		: network access
				mppp_sap	: ML PPP service access point
				mppp_cep	: ML PPP connection end point

*--------------------------------------------------------------------------*/

uchar mppp_config_ml_ppp (p_mppp_cfg)
	struct mppp_config	FAR *p_mppp_cfg;
{

	MPPP_DBG_FUNC ("mppp_config_ml_ppp()")

	uchar					 i, j, k, l;			/* index */
	struct mppp_cfg_na		FAR *p_mppp_cfg_na;		/* pointer on the current na object of
													   the configuration data */
	struct mppp_cfg_sap		FAR *p_mppp_cfg_sap;	/* pointer on the current SAP object of
													   the configuration data */
	struct mppp_cfg_cep		FAR *p_mppp_cfg_cep;	/* pointer on the current CEP object of
													   the configuration data */
	struct sppp_na			FAR *p_sppp_na_save;	/* saved pointer */


	MPPP_DBG_ENTER ();


			/* +++++++++++++++ ML PPP NA loop ++++++++++++++++++++++++++ */

	for (i = 0; i < Mppp_cfg_mppp_na_nb; i++) {

			/* Init p_mppp_na : pointer on ML PPP NA */

		p_mppp_cfg_na = &Mppp_cfg_object_na (i);	/* current pointer in the configuration */

		if (mppp_access_na (Mppp_cfg_na_nai) == NOK) {

			ret_code = MPPP_CFG_ERR_UNKNOWN_NAI;

			MPPP_DBG_ERROR ("nai not configured");
			MPPP_DBG_LEAVE ();

			return (NOK);
		}

			/* Recopy NA values from the configuration structure */

		Mppp_na_sap_nb			= Mppp_cfg_na_mppp_sap_nb;		/* number of SAP in the NA */
		Mppp_na_system_state	= FREE;

				/* ------------- ML PPP SAP loop ------------------- */

		for (j = 0, mppp_access_first_sap (); p_mppp_sap != P_NIL; mppp_access_next_sap (), j++) {

				/* Message configuration SAP structure pointer */

			p_mppp_cfg_sap	= &Mppp_cfg_object_sap (i, j);

				/* Initialize ML PPP SAP context */

			Mppp_sap_cep_nb						= Mppp_cfg_sap_mppp_cep_nb;

			Mppp_sap_sig_upper_entity_id		= Set_default (Mppp_cfg_sap_sig_upper_entity_id, ENT_DTE_INT);
			Mppp_sap_data_upper_entity_id		= Set_default (Mppp_cfg_sap_data_upper_entity_id, ENT_DTE_INT);

			Mppp_sap_data_ui					= Mppp_cfg_sap_data_ui;
			Mppp_sap_data_no_split_max_size		= Set_default (Mppp_cfg_sap_data_no_split_max_size, LCP_MRU_I);
			Mppp_sap_data_split_flag			= OFF;

			Mppp_sap_data_modulo				= Set_default (Mppp_cfg_sap_data_modulo, MPPP_MODULO_I);

				/*
					Normalize the Modulo value:
					The Multilink Protocol only defines 12-bit and 24-bit sequence
					numbers.
				*/

			if (Mppp_sap_data_modulo > MP_MX_SHORT_MODULO) {
				Mppp_sap_data_modulo	= MP_MX_LONG_MODULO;
			} else {
				Mppp_sap_data_modulo	= MP_MX_SHORT_MODULO;
			}

			Mppp_sap_data_congestion_mgt		= Mppp_cfg_sap_data_congestion_mgt;

			if (Mppp_sap_data_ui == ON) {
				Mppp_sap_data_split_flag = ON;
			} else {
				Mppp_sap_data_split_flag = OFF;
			}

			if (Mppp_sap_data_split_flag == OFF) {

					/* Header size */

				Mppp_sap_data_header_size = MP_LONG_HEADER_SIZE;

					/* Window size ; w */

				Mppp_sap_data_w		= Set_default (Mppp_cfg_sap_data_w, MPPP_W_I);

				if (Mppp_sap_data_w >= Mppp_sap_data_modulo) {

					ret_code = MPPP_CFG_ERR_WINDOW_SIZE;

					MPPP_DBG_ERROR ("_w >= modulo");
					MPPP_DBG_LEAVE ();

					return (NOK);
				}

					/* Guard size ; x */

				Mppp_sap_data_x		= Set_default (Mppp_cfg_sap_data_x, MPPP_X_I);

				if ((Mppp_sap_data_w + Mppp_sap_data_x) >= Mppp_sap_data_modulo) {

					ret_code = MPPP_CFG_ERR_GUARD_SIZE;

					MPPP_DBG_ERROR ("_w +_x >= modulo");
					MPPP_DBG_LEAVE ();

					return (NOK);
				}

			} else {

				if (Mppp_sap_data_modulo > MP_MX_SHORT_MODULO) {

						/* Header size */

					Mppp_sap_data_header_size = MP_LONG_HEADER_SIZE;

				} else {

					Mppp_sap_data_header_size = MP_SHORT_HEADER_SIZE;
				}

					/* Window size = Guard size ; w, x */

				Mppp_sap_data_x =
				Mppp_sap_data_w = Set_default (Mppp_cfg_sap_data_x, MPPP_X_I);

				if ((Mppp_sap_data_x) >= Mppp_sap_data_modulo) {

					ret_code = MPPP_CFG_ERR_GUARD_SIZE;

					MPPP_DBG_ERROR ("_x >= modulo");
					MPPP_DBG_LEAVE ();

					return (NOK);
				}

			}

#			if MPPP_FC == ON	/* { */

					/* Flow control marks */

				if ((Mppp_sap_data_out_fc_high_mark = Mppp_cfg_sap_data_out_fc_high_mark) != 0) {

					Mppp_sap_data_out_fc_low_mark = Mppp_cfg_sap_data_out_fc_low_mark;

					if (Mppp_sap_data_out_fc_high_mark <= Mppp_sap_data_out_fc_low_mark) {

						ret_code = MPPP_CFG_ERR_FC_LEVEL;

						MPPP_DBG_ERROR ("fc_high <= fc_low");
						MPPP_DBG_LEAVE ();

						return (NOK);
					}
				}

#			endif	/* MPPP_FC == ON } */


				/*---------------- ML PPP CEP loop ---------------------*/

			for (k = 0, mppp_access_first_cep (); p_mppp_cep != P_NIL; mppp_access_next_cep (), k++) {

					/* Message configuration CEP structure pointer */

				p_mppp_cfg_cep	= &Mppp_cfg_object_cep (i, j, k);

				Mppp_cep_sig_state				=
				Mppp_cep_data_state				= MPPP_RELEASED;

				Mppp_cep_upper_layer_initiated	= OFF;

				Mppp_cep_auto_open_flag			= Mppp_cfg_cep_auto_open;
				Mppp_cep_open_rq_flag			= OFF;
				Mppp_cep_commit_rq				= OFF;
				Mppp_cep_close_rq_flag			= OFF;
				Mppp_cep_msg_direction			= MPPP_FROM_OTHER;

					/* Reset the bundle's CP options we ack'd */

				Mppp_cep_reset_ack_cp_opt ();

					/* Reset the bundle's CP options the peer ack'd */

				Mppp_cep_reset_peer_ack_cp_opt ();

					/* Reset the ML-PPP flags related to use of MP, SSNHF, EDO */

				mppp_reset_mp_flags ();

					/* 1st fragment not received yet */

				Mppp_cep_first_frag_received = OFF;

					/* ACFC and PFC flags */

				Mppp_cep_frag_acfc		=
				Mppp_cep_frag_pfc		=
				Mppp_cep_first_frag_pfc	= OFF;

					/* Reset the pointer to the saved message */

				Mppp_cep_p_msg_conn_rq		= P_NIL;

					/* Reset the CHAP context information */

				mppp_reset_chap_info ();

					/* Initialize the Multilink PPP LCP options */

				Mppp_cep_min_mrru			= Set_default (Mppp_cfg_cep_min_mrru, LCP_MIN_MRRU_I);
				Mppp_cep_mrru				= Set_default (Mppp_cfg_cep_mrru, LCP_MRRU_I);

				if (((int)Mppp_cfg_cep_edo_class < LCP_EDO_CLASS_0) ||
						(Mppp_cfg_cep_edo_class > LCP_EDO_CLASS_5)) {

					ret_code	= MPPP_CFG_ERR_EDO_CLASS;

					MPPP_DBG_ERROR ("EDO class out of range");
					MPPP_DBG_LEAVE ();

					return (NOK);

				}

				if (mppp_check_edo_add_lgth (Mppp_cfg_cep_edo_class, Mppp_cfg_cep_edo_add_lgth) != OK) {

					ret_code	= MPPP_CFG_ERR_EDO_ADD_LGTH;

					MPPP_DBG_ERROR ("EDO address length out of range");
					MPPP_DBG_LEAVE ();

					return (NOK);

				}

#				if MPPP_BAP == ON
					Mppp_cep_bacp_usage	= Mppp_cfg_cep_bacp_usage;
#				else
					Mppp_cep_bacp_usage	= OFF;
#				endif

				Mppp_cep_edo_usage		= Mppp_cfg_cep_edo_usage;
				Mppp_cep_edo_class		= Mppp_cfg_cep_edo_class;
				Mppp_cep_edo_add_lgth	= Mppp_cfg_cep_edo_add_lgth;

				Memcpy_far ((char FAR *)&Mppp_cep_edo_add[0],
							(char FAR *)&Mppp_cfg_cep_edo_add[0],
							Mppp_cep_edo_add_lgth);


					/* Set the Multilink Protocol support flag */

				Mppp_cep_mp_disabled	= Mppp_cfg_cep_mp_disabled;

					/* Set the LCP extensions information */

#				if MPPP_LCP_EXTENSIONS == ON	/* { */

					Mppp_cep_lcp_ext_usage	= Mppp_cfg_cep_lcp_ext_usage;

#					if MPPP_CALLBACK_PER_LINK == OFF	/* { */

						if (Mppp_cfg_cep_callback_msg_lgth > MPPP_MX_SZ_CALLBACK_MSG) {

							ret_code	= MPPP_CFG_ERR_CALLBACK_LGTH;

							MPPP_DBG_ERROR ("bundle's callback out of range");
							MPPP_DBG_LEAVE ();

							return (NOK);

						}

						Mppp_cep_callback_op		= Mppp_cfg_cep_callback_op;
						Mppp_cep_callback_msg_lgth	= Mppp_cfg_cep_callback_msg_lgth;

						Memcpy_far ((char FAR *)&Mppp_cep_callback_msg[0],
									(char FAR *)&Mppp_cfg_cep_callback_msg[0],
									Mppp_cep_callback_msg_lgth);

#					endif	/* } */


#				else	/* } { */

					Mppp_cep_lcp_ext_usage	= OFF;

#				endif	/* } */


#				if MPPP_FC == ON

						/* Flow control states */

					Mppp_cep_out_fc_state = FREE;

#				endif

					/* Check for the SL PPP connections */

				Mppp_cep_sppp_total_link_speed = 0;

					/* Reset the PAP Username and Password information */

				Mppp_cep_username_lgth	= 0;
				Mppp_cep_password_lgth	= 0;

#				if ASSERT == ON	/* { */

						/*
							We do not allow bundle without member link
						*/

					if (Mppp_cfg_cep_sppp_nb == 0) {

						ret_code = MPPP_CFG_ERR_SPPP_NB;

						MPPP_DBG_ERROR ("sppp_nb=0");
						MPPP_DBG_LEAVE ();

						return (NOK);

					}

#				endif	/* }  ASSERT == ON */

				if ((Mppp_cfg_cep_sppp_nb > MPPP_MX_SPPP) ||
					(Mppp_cfg_cep_sppp_nb < Mppp_cfg_cep_min_sppp_nb)) {

					ret_code = MPPP_CFG_ERR_SPPP_NB;

					MPPP_DBG_ERROR ("sppp_nb > MAX or < min_sppp_nb");
					MPPP_DBG_LEAVE ();

					return (NOK);
				}

				Mppp_cep_sppp_nb		= Mppp_cfg_cep_sppp_nb;
				Mppp_cep_min_sppp_nb	= Mppp_cfg_cep_min_sppp_nb;

				Mppp_cep_used_sppp_nb	=
				Mppp_cep_opened_sppp_nb	=
				Mppp_cep_busy_sppp_nb	= 0;

					/* Set SL PPPs list to empty */

				Sppp_init_list_head (&Mppp_cep_sppp_list_head);

				for (l = 0; l < Mppp_cep_sppp_nb; l++) {

					Mppp_cep_sppp_ref_tab (l)	= Mppp_cfg_cep_sppp_ref_tab (l);

						/*
							WARNING!!!!
							Save the p_sppp_na pointer before checking the
							validity of the SL PPP's reference value.
						*/

					p_sppp_na_save	= p_sppp_na;

					if (mppp_access_sppp_ref (Mppp_cep_sppp_ref_tab(l)) != OK) {

							/*
								A SL PPP's reference  has been associated to
								this ML PPP's bundle, but this SL PPP has not been
								configured.
							*/

						ret_code = MPPP_CFG_ERR_MISSING_SLPPP;
						MPPP_DBG_ERROR ("member link not configured");

						MPPP_DBG_LEAVE ();

						return (NOK);

					} else {

#						if RESET_CONFIG == ON	/* { */

								/*
									When the RESET_CONFIG facility is supported,
									we must verify that the member link's NAI value
									(the one used to build the objects tree) is the same
									as the bundle's one.
									This NAI MAY be different from the NAI used to send/receive
									messages to/from the lower layer entity.
								*/

							if (Sppp_na_nai != Mppp_na_nai) {

								ret_code = MPPP_CFG_ERR_DIFFERENT_NAI;
								MPPP_DBG_ERROR ("bad member link's NAI for RESET_CONFIG");

								MPPP_DBG_LEAVE ();

								return (NOK);

							}

#						endif	/* RESET_CONFIG == ON } */

							/* Restore the p_sppp_na pointer */

						p_sppp_na	= p_sppp_na_save;

							/*
								Verify that this SL PPP is not already associated to
								another ML PPP bundle.
							*/

						if (Sppp_cep_p_mppp_cep != P_NIL) {

							ret_code = MPPP_CFG_ERR_SLPPP_IN_BUNDLE;

							MPPP_DBG_ERROR ("member link already in a bundle");
							MPPP_DBG_LEAVE ();

							return (NOK);

						}

							/*
								Mark this SL PPP as member link of the current
								ML PPP bundle.
							*/

						Sppp_cep_p_mppp_na		= p_mppp_na;
						Sppp_cep_p_mppp_sap		= p_mppp_sap;
						Sppp_cep_p_mppp_cep		= p_mppp_cep;


							/* Reset the CP options we ack'd */

						Sppp_cep_reset_ack_cp_opt ();

							/* Reset the CP options the peer ack'd */

						Sppp_cep_reset_peer_ack_cp_opt ();

							/* Add this SL PPP in the ML PPP bundle */

						Sppp_insert_tail_list (&Mppp_cep_sppp_list_head, p_sppp_cep);

						if (Is_sppp_first_in_bundle ()) {

								/*
									Set up the default ACCMs
									(to local PPP and to peer system)
								*/

							Mppp_cep_accm_to_local	= (Mppp_sap_data_sapi == MPPP_SAPI_DATA_SYNC) ? LCP_SYNC_ACCM_I : LCP_ASYNC_ACCM_I;
							Mppp_cep_accm_to_peer	= Mppp_link_mode_accm (Sppp_cep_link_mode);

						}


							/* Initialize the control protocol information */

						if (mppp_c_prot_initialize (Sppp_cep_p_lcp_info,p_mppp_cfg_cep) == OK) {

								/* Initialize LCP context */

							lcp_context_config ();

								/*
									The LCP state of the member links
									is set to "STARTING", if automatic OPEN
									event is set to ON.
								*/

							if (Mppp_cep_auto_open_flag == ON) {
								Set_c_prot_state_starting;
							}

								/* Initialize the Authentication Protocol contexts */

							if ((mppp_auth_initialize (Sppp_cep_p_peer_auth_info, p_mppp_cfg_cep) != OK) ||
								(mppp_auth_initialize (Sppp_cep_p_local_auth_info, p_mppp_cfg_cep) != OK)) {

								ret_code	= MPPP_CFG_ERR_AUTH_INIT;

								MPPP_DBG_ERROR ("init of AUTH failed");
								MPPP_DBG_LEAVE ();

								return (NOK);

							}

						} else {

							ret_code	= MPPP_CFG_ERR_LCP_INIT;

							MPPP_DBG_ERROR ("init of LCP failed");
							MPPP_DBG_LEAVE ();

							return (NOK);
						}

					}

				}

					/*
						Request initialization of Control Protocols contexts
					*/

#				if MPPP_BAP == ON	/* { */

					if (mppp_c_prot_initialize (Mppp_cep_p_bacp_info,p_mppp_cfg_cep) == OK) {

							/* Configure the BACP context */

						bacp_context_config ();

					} else {

						ret_code	= MPPP_CFG_ERR_BACP_INIT;

						MPPP_DBG_ERROR ("init of BACP failed");
						MPPP_DBG_LEAVE ();

						return (NOK);
					}

					if (mppp_c_prot_initialize (Mppp_cep_p_bap_info,p_mppp_cfg_cep) == OK) {

							/* Configure the BAP context */

						bap_context_config ();

					} else {

						ret_code	= MPPP_CFG_ERR_BAP_INIT;

						MPPP_DBG_ERROR ("init of BAP failed");
						MPPP_DBG_LEAVE ();

						return (NOK);
					}

#				endif	/* } */

			} /* ---------------------- End of ML PPP CEP loop ----------*/


		} /* ---------------------- End of ML PPP SAP loop ----------*/

		Mppp_na_active	= ON;		/* set the NA active */

	}	/* ----------------------- End ML PPP NA loop -------------------*/


	MPPP_DBG_LEAVE ();

	return (OK);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_config - implements the building and initialization of
							 the ML PPP layer objects.

Usage			uchar mppp_config (struct mppp_config FAR *p_mppp_cfg);
					- p_mppp_cfg : pointer on configuration data.

Description		mppp_config implements the building of the ML PPP objects
				(na, mppp_cep) on a tree structure and the
				initialization	of the objects.

Return value	uchar return code = OK configuration is done,
									NOK configuration has failed.

Common constants and declarations : mppp.h

Common objects	na			: network access
				mppp_cep	: ML PPP connection end point

*--------------------------------------------------------------------------*/

uchar mppp_config (p_mppp_cfg)
	struct mppp_config	FAR *p_mppp_cfg;				/* pointer on the configuration data */
{
	MPPP_DBG_FUNC ("mppp_config()")

	MPPP_DBG_ENTER ();

		/* Build the object tree structures */

	if (Mppp_cfg_type == MPPP_CFG_TYPE_MEMBER_LINK) {

		if (mppp_build_sl_ppp_object ((struct sppp_config FAR *)p_mppp_cfg) == NOK) {

				/*
					The global variable ret_code contains the cause
					value of the configuration failure.
				*/

			MPPP_DBG_ERROR ("build_sl_ppp_object failed");
			MPPP_DBG_LEAVE ();

			return (NOK);
		}

			/*
				SL PPPs objects MUST be configured before
				ML PPP objects
			*/

		if (mppp_config_sl_ppp ((struct sppp_config FAR *)p_mppp_cfg) == NOK) {

				/*
					The global variable ret_code contains the cause
					value of the configuration failure.
				*/

			MPPP_DBG_ERROR ("config_sl_ppp failed");
			MPPP_DBG_LEAVE ();

			return (NOK);

		}

		MPPP_DBG_NOTICE ("member link config OK");

	} else if (Mppp_cfg_type == MPPP_CFG_TYPE_BUNDLE) {

		if (mppp_build_ml_ppp_object (p_mppp_cfg) == NOK) {

				/*
					The global variable ret_code contains the cause
					value of the configuration failure.
				*/

			MPPP_DBG_ERROR ("build_ml_ppp_object failed");
			MPPP_DBG_LEAVE ();

			return (NOK);
		}

		if (mppp_config_ml_ppp (p_mppp_cfg) == NOK) {

				/*
					The global variable ret_code contains the cause
					value of the configuration failure.
				*/

			MPPP_DBG_ERROR ("config_ml_ppp failed");
			MPPP_DBG_LEAVE ();

			return (NOK);
		}

		MPPP_DBG_NOTICE ("bundle config OK");

	} else {


			/* Unknown configuration type */

		ret_code	= MPPP_CFG_ERR_UNKNOWN_TYPE;

		MPPP_DBG_ERROR ("unknown config type");
		MPPP_DBG_LEAVE ();

		return (NOK);

	}

#	if (MPPP_SIM_ANALYSER == ON)
		pr_mppp_object ();
#	endif


	MPPP_DBG_LEAVE ();

		/* Return OK */

	return (OK);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_reset_config - implements the reseting of
								   a ML PPP data link layer object.

Usage			uchar mppp_reset_config (nai);
					- nai : NAI to be reset.

Return value	uchar return code = OK reset configuration is done,
									NOK reset configuration has failed.

Common constants and declarations : mppp.h

Common objects	na			: network access
				mppp_cep	: data link connection end point

*--------------------------------------------------------------------------*/

#if RESET_CONFIG == ON	/* { */

uchar mppp_reset_config (nai)
	nai_t	nai;
{

	MPPP_DBG_FUNC ("mppp_reset_config()")

	if ((mppp_reset_config_ml_ppp (nai) == OK) && (mppp_reset_config_sl_ppp (nai) == OK)) {

		MPPP_DBG_LEAVE ();
		return (OK);
	}

	MPPP_DBG_ERROR ("reset_config failed");
	MPPP_DBG_LEAVE ();

	return (NOK);

}

#endif	/* RESET_CONFIG == ON } */


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_reset_config_ml_ppp - implements the reseting of
								   a ML PPP data link layer object.

Usage			uchar mppp_reset_config_ml_pppp (nai);
					- nai : NAI to be reset.

Return value	uchar return code = OK reset configuration is done,
									NOK reset configuration has failed.

Common constants and declarations : mppp.h

Common objects	na			: network access
				mppp_cep	: data link connection end point

*--------------------------------------------------------------------------*/

#if RESET_CONFIG == ON	/* { */

uchar mppp_reset_config_ml_ppp (nai)
	nai_t	nai;
{

	MPPP_DBG_FUNC ("mppp_reset_config_ml_ppp()")
	
	struct mppp_na		FAR *p_na_prior;	/* temporary mppp_na pointer */

#	if MPPP_BAP == ON	/* { */
		uchar				i;				/* loop counter */
#	endif

	MPPP_DBG_ENTER ();

		/* ----------------------- NA loop -------------------------- */

	p_na_prior = P_NIL;

	for (mppp_access_first_na (); p_mppp_na != P_NIL; mppp_access_next_na ()) {

		if (Mppp_na_nai == nai) {

				/* The Line should be OFF before resetting the configuration */

			if (Mppp_na_active != OFF) {

				MPPP_DBG_LEAVE ();

				return (NOK);
			}

#			if OPTIMIZATION == SPEED
				p_mppp_na_tab [nai] = P_NIL;
#			endif

				/* Update the NA link */

			if (p_na_prior == P_NIL) {

				p_mppp_tree = (((struct node FAR *)p_mppp_na) - 1) -> p_next;

			} else {

				(((struct node FAR *)p_na_prior) - 1) -> p_next =  (((struct node FAR *)p_mppp_na) - 1) -> p_next;
			}

				/*---- SAP/CEP loop ----*/

			for (mppp_access_first_sap (); p_mppp_sap != P_NIL; mppp_access_next_sap ()) {

				for (mppp_access_first_cep (); p_mppp_cep != P_NIL; mppp_access_next_cep ()) {

#					if MPPP_BAP == ON	/* { */

							/* Set up the pointer used by the access macros */

						p_mppp_c_prot	= Mppp_cep_p_bacp_info;

							/* Free Control Protocols Timers */

						for (i = 0; i < MPPP_MX_CP_TIMER; i++) {
							Timer_free (Mppp_c_prot_ti_id (i));
						}

#					endif	/* MPPP_BAP == ON } */

						/* Discard the bundle's messages queues */

					mp_discard_rx_queue		();
					mp_discard_tx_queue		();
					mp_discard_faq			();

					mppp_reset_chap_info	();

						/* Free the saved ACU connect request message */

					if (Mppp_cep_p_msg_conn_rq != P_NIL) {
						Free_msg (Mppp_cep_p_msg_conn_rq);
					}

						/* Remove all the SL PPP connections from the ML PPP bundle */

					while (! Sppp_is_list_empty (&Mppp_cep_sppp_list_head)) {

						Sppp_remove_head_list (&Mppp_cep_sppp_list_head);
						Mppp_cep_sppp_nb--;

					}

				}

			}

				/* And free the NA memory block */

			Mem_free ((char FAR *)Mppp_na_p_mem_blk, PID_VL);

			mppp_init_flag	= OFF;

			MPPP_DBG_LEAVE ();

			return (OK);
		}

		p_na_prior = p_mppp_na;
	}

	MPPP_DBG_LEAVE ();

	return (NOK);
}

#endif	/* RESET_CONFIG == ON } */


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_reset_config_sl_ppp - implements the reseting of
								   a SL PPP member link object.

Usage			uchar mppp_reset_config_sl_pppp (nai);
					- nai : NAI to be reset.

Return value	uchar return code = OK reset configuration is done,
									NOK reset configuration has failed.

Common constants and declarations : mppp.h

Common objects	na			: network access
				sppp_cep	: connection end point

*--------------------------------------------------------------------------*/

#if RESET_CONFIG == ON	/* { */

uchar mppp_reset_config_sl_ppp (nai)
	nai_t	nai;
{

	MPPP_DBG_FUNC ("mppp_reset_config_sl_ppp()")
	
	struct sppp_na		FAR *p_na_prior;	/* temporary sppp_na pointer */
	uchar					i;				/* loop counter */

	MPPP_DBG_ENTER ();

		/* ----------------------- NA loop -------------------------- */

	p_na_prior = P_NIL;

	for (mppp_access_first_sppp_na (); p_sppp_na != P_NIL; mppp_access_next_sppp_na ()) {

		if (Sppp_na_nai == nai) {

				/* The Line should be OFF before resetting the configuration */

			if (Sppp_na_active != OFF) {

				MPPP_DBG_LEAVE ();

				return (NOK);
			}

#			if OPTIMIZATION == SPEED
				p_sppp_na_tab [nai] = P_NIL;
#			endif

				/* Update the NA link */

			if (p_na_prior == P_NIL) {

				p_sppp_tree = (((struct node FAR *)p_sppp_na) - 1) -> p_next;

			} else {

				(((struct node FAR *)p_na_prior) - 1) -> p_next =  (((struct node FAR *)p_sppp_na) - 1) -> p_next;
			}

				/* Free the timer cells associated to the NA */

				/*---- CEP loop ----*/

			for (mppp_access_first_sppp_cep (); p_sppp_cep != P_NIL; mppp_access_next_sppp_cep ()) {

					/* Set up the pointer used by the access macros */

				p_mppp_c_prot	= Sppp_cep_p_lcp_info;

				for (i = 0; i < MPPP_MX_CP_TIMER; i++) {
					Timer_free (Mppp_c_prot_ti_id (i));
				}

					/* Free Authentication Protocols Timers */

				p_sppp_auth		=  Sppp_cep_p_local_auth_info;

				for (i = 0; i < MPPP_MX_AUTH_TIMER; i++) {
					Timer_free (Sppp_auth_ti_id (i));
				}

				p_sppp_auth		=  Sppp_cep_p_peer_auth_info;

				for (i = 0; i < MPPP_MX_AUTH_TIMER; i++) {
					Timer_free (Sppp_auth_ti_id (i));
				}

					/* Discard the Tx queue */

				mppp_discard_sppp_tx_queue ();

				if (Sppp_cep_ass_frame_p_msg != P_NIL) {
					Free_msg (Sppp_cep_ass_frame_p_msg);
				}

			}

				/* And free the NA memory block */

			Mem_free ((char FAR *)Sppp_na_p_mem_blk, PID_VL);

			MPPP_DBG_LEAVE ();

			return (OK);
		}

		p_na_prior = p_sppp_na;
	}

	MPPP_DBG_LEAVE ();

	return (NOK);
}

#endif	/* RESET_CONFIG == ON } */


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_process_pending_tx - restarts the sending of queued
					frames due to lower layers flow control BUSY state.

Usage			void mppp_process_pending_tx ();

Common constants and declarations : mppp.h

Common objects : context pointers.

*--------------------------------------------------------------------------*/

void mppp_process_pending_tx()
{

	MPPP_DBG_FUNC ("mppp_process_pending_tx()")

	MPPP_DBG_ENTER ();

	if (Mppp_cep_mp_enabled == ON) {
		mp_restart_tx ();
	}

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_process_pending_sppp_tx - restarts the sending of queued
					messages on a member link context, due to lower layers
					flow control BUSY state.

Usage			void mppp_process_pending_sppp_tx ();

Common constants and declarations : mppp.h

Common objects : context pointers.

*--------------------------------------------------------------------------*/

void mppp_process_pending_sppp_tx()
{

	MPPP_DBG_FUNC ("mppp_process_pending_sppp_tx()")

	MPPP_DBG_ENTER ();

	for ( ; ; ) {

		if (mppp_snd_data_msg_to_peer (Sppp_cep_data_entity_id, Mppp_cep_accm_to_peer) != OK) {
			break;
		}

	}

	MPPP_DBG_LEAVE ();

}


/*--------------------------------------------------------------------------*/

uchar mppp_check_edo_add_lgth (edo_class, edo_add_lgth)
	uchar	edo_class;
	uchar	edo_add_lgth;
{
	MPPP_DBG_FUNC ("mppp_check_edo_add_lgth()")

	uchar	result;

	MPPP_DBG_ENTER ();

	result	= OK;

	if (edo_add_lgth > MPPP_MX_SZ_EDO_ADD) {

		MPPP_DBG_LEAVE ();
		return (NOK);

	}

	switch (edo_class) {

		case LCP_EDO_CLASS_0:		/* Null class */

				/* Fixed length EDO address = 0 */

			if (edo_add_lgth > 0) {
				result	= NOK;
			}
			break;

		case LCP_EDO_CLASS_1:	/* Locally Assigned Address */

				/* Variable length EDO */

			if (edo_add_lgth > (LCP_OPT_MX_SZ_EDO_1 - 3)) {
				result = NOK;
			}
			break;

		case LCP_EDO_CLASS_2:		/* Internet Protocol (IP) address */

				/* Fixed length EDO address = 4 */

			if (edo_add_lgth != (LCP_OPT_SZ_EDO_2 - 3)) {
				result = NOK;
			}
			break;

		case LCP_EDO_CLASS_3:	/* IEEE 802.1 Globally assigned MAC address */

				/* Fixed length EDO = 6 */

			if (edo_add_lgth != (LCP_OPT_SZ_EDO_3 - 3)) {
				result = NOK;
			}
			break;

		case LCP_EDO_CLASS_4:	/* PPP Magic-Number Block */

				/* Variable length EDO */

			if (edo_add_lgth > (LCP_OPT_MX_SZ_EDO_4 - 3)) {
				result = NOK;
			}
			break;

		case LCP_EDO_CLASS_5:	/* Public Switched Network Directory Number */

				/* Variable length EDO */

			if (edo_add_lgth > (LCP_OPT_MX_SZ_EDO_5 - 3)) {
				result = NOK;
			}
			break;

	}

	MPPP_DBG_LEAVE ();

	return (result);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_reset_mp_flags - resets the MP flags

Usage			void mppp_reset_mp_flags ();

Common constants and declarations : mppp.h

Common objects : context pointers.

*--------------------------------------------------------------------------*/

void mppp_reset_mp_flags ()
{

	MPPP_DBG_FUNC ("mppp_reset_mp_flags()")

	MPPP_DBG_ENTER ();

#	if ASSERT == ON

		if (p_mppp_cep == P_NIL) {

			MPPP_DBG_ERROR ("p_mppp_cep is P_NIL");

			Trap (TRAP_MPPP_NULL_POINTER, "mppp_reset_mp_flags");

		}

#	endif

		/* Disable the Multilink PPP before negotiation */

	Mppp_cep_mp_enabled			= OFF;

		/* Multilink PPP reject flag */

	Mppp_cep_mp_rejected		= OFF;

		/* Multilink EDO reject flag */

	Mppp_cep_edo_rejected		= OFF;

		/* Multilink SSNHF reject flag */

	Mppp_cep_ssnhf_rejected		= OFF;

#	if MPPP_BAP == ON	/* { */

			/* Disable the BACP before negotiation */

		Mppp_cep_bacp_enabled		= OFF;

			/* BACP reject flag */

		Mppp_cep_bacp_rejected		= OFF;

			/* Favored-Peer flag */

		Mppp_cep_bacp_favored_peer	= OFF;

			/* Use of "No-Phone-Number" Option in BAP packets */

		Mppp_cep_bap_no_phone_number	= OFF;

			/* BAP Reason information */

		Mppp_cep_bap_reason_lgth	= 0;
		Mppp_cep_bap_p_reason		= P_NIL;

#	endif	/* MPPP_BAP == ON } */


	MPPP_DBG_LEAVE ();
}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mppp_reset_chap_info - resets the CHAP information

Usage			void mppp_reset_chap_info ();

Common constants and declarations : mppp.h

Common objects : context pointers.

*--------------------------------------------------------------------------*/

void mppp_reset_chap_info ()
{
	if (p_mppp_cep != P_NIL) {

		mppp_discard_chap_queue ();

		Mppp_cep_chap_link_ref	= SPPP_REF_NIL;
		Mppp_cep_chap_state		= MPPP_CP_STATE_INITIAL;
		Mppp_cep_chap_first		=
		Mppp_cep_chap_last		= P_NIL;

	}

}

/*--------------------------------------------------------------------------*/

#if MPPP_AUDIT == ON	/* { */

struct mppp_audit {
	long	system_time;		/* system time for time stamping */
	code_t	last_event;			/* last received event */
	nai_t	nai;				/* network access ID */
	sapi_t	s_sapi;				/* signalling service access point ID */
	sapi_t	d_sapi;				/* data service access point ID */
	uchar	ppp_link_state;		/* PPP single link state */
	uchar	lcp_state;			/* PPP LCP state */
} mppp_audit[MPPP_MX_AUDIT];

ushort		x_mppp_audit;				/* current index */

void mppp_audit_in ()
{
	MPPP_DBG_FUNC ("mppp_audit_in()")

	MPPP_DBG_ENTER ();

	if (p_mppp_cep != P_NIL) {

			/* p_mppp_na is also valid */

			/* Get and store system time */

		mppp_audit[x_mppp_audit].system_time	= System_time ();

			/* Copy last received event ID */

		mppp_audit[x_mppp_audit].last_event		= event_id;

			/* Copy address nai and sapi */

		mppp_audit[x_mppp_audit].nai			= Mppp_na_nai;			/* network access ID */
		mppp_audit[x_mppp_audit].s_sapi			= Mppp_sap_sig_sapi;	/* signalling service access point ID */
		mppp_audit[x_mppp_audit].d_sapi			= Mppp_sap_data_sapi;	/* data service access point ID */

			/* Copy from the current context */


			/* Next entry */

		x_mppp_audit = ((++x_mppp_audit >= MPPP_MX_AUDIT) ? 0 : x_mppp_audit);
	}

	MPPP_DBG_LEAVE ();
}

#endif	/* MPPP_AUDIT == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				mppp_var_init - init of ML PPP entity's global variables.

Usage				void mppp_var_init ();

Return value :		void

Common constants and declarations : mppp.h

Common objects : ML PPP global variables.

*--------------------------------------------------------------------------*/

void mppp_var_init ()
{
	MPPP_DBG_FUNC ("mppp_var_init()")

	MPPP_DBG_ENTER ();

	mppp_init_flag			= OFF;
	p_mppp_tree				= P_NIL;
	p_sppp_tree				= P_NIL;

#	if OPTIMIZATION == SPEED
		p_mppp_na_tab		= P_NIL;
		p_sppp_na_tab	= P_NIL;
#	endif

#	if MPPP_AUDIT == ON
		x_mppp_audit		= 0;
#	endif

	MPPP_DBG_LEAVE ();

}

/*-----------------------------------------------------------------------*/

/* EOF */	/* MPPP.C */

