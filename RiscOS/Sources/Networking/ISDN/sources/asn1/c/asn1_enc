
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - asn1_enc.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function (s)
 *
 *		asn1_encoding_start - 		implements the encoding of an ASN1 type
 *									described with a metaprogram and other
 *									possible imbricated meta-programs : This
 *									is the main ASN1 encoding function.
 *
 *		asn1_encode_basic_type -	implements the encoding of an ASN1
 *									basic type, i.e. described with a
 *									metaprogram that has no "type field"
 *									(no reference to another ASN1 type).
 *
 *		asn1_init - 				implements the initialisation of common
 *									variables used in ASN1 implementation.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    ASN1 language notation encoding/decoding library |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "asn1.h"
#include "asn1cons.h"

		/* Copyright */

CONST char 	asn1_enc_copyright[]	= "Copyright (c) 1989/96 by OMNITEL SA - All Rights Reserved";
CONST char 	asn1_enc_licence[]		= LICENSE_NBER;

/*-------------------------------------------------------------------------*/

		/* Common ASN1 variables */
		/* --------------------- */

uchar			asn1_type_tag_class;			/* storage of the tag class of current type for type identification encoding */
asn1_tag_nb_t	asn1_type_tag_nb;				/* storage of the tag number of current type for type identification encoding */

#if ASN1_TAG_NB_EXTENSION_MECHANISM == ON

	uchar FAR 	*p_asn1_tag_nb;					/* storage of pointer to extended tag nb */

#endif

			/* Tables used to store specific parameters useful to analyse a type :
				for each parameter, one entry is required for each possible
				type imbrication level */

ulong				asn1_tab_length			[ASN1_MX_IMBRICATION_LEVEL];	/* current length */
uchar	FAR			*asn1_tab_p_length_field[ASN1_MX_IMBRICATION_LEVEL];	/* pointer to current length data area */
uchar	FAR			*asn1_tab_p_pc			[ASN1_MX_IMBRICATION_LEVEL];	/* pointer to type description meta-program */
uchar				asn1_tab_field_nb		[ASN1_MX_IMBRICATION_LEVEL];	/* current number of type fields already processed in a meta-program */

uchar				asn1_imbric_level;										/* current imbrication level */

			/* access macros to Tables */

#define 	Imbricated_length(xx)		asn1_tab_length[xx]
#define 	Imbricated_p_length(xx)		asn1_tab_p_length_field[xx]
#define 	Imbricated_p_pc(xx)			asn1_tab_p_pc[xx]
#define 	Imbricated_field_nb(xx)		asn1_tab_field_nb[xx]

#define 	Current_length				Imbricated_length		(asn1_imbric_level)
#define 	Current_p_length			Imbricated_p_length		(asn1_imbric_level)
#define 	Current_p_pc				Imbricated_p_pc			(asn1_imbric_level)
#define 	Current_field_nb			Imbricated_field_nb		(asn1_imbric_level)

#define 	Lowest_p_pc					Imbricated_p_pc			(0)

#define 	Lower_p_pc					Imbricated_p_pc			(asn1_imbric_level - 1)
#define 	Lower_field_nb				Imbricated_field_nb		(asn1_imbric_level - 1)
#define 	Lower_length				Imbricated_length		(asn1_imbric_level - 1)

#if ASN1_OPTIONAL_USED == ON
	extern uchar FAR	*p_asn1_optional_ind;		/* pointer to list of optional indicators associated with current type */
#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	asn1_encoding_start - implements the encoding of an
					ASN1 type described with a metaprogram and other
					possible imbricated meta-programs.

Usage            	ulong asn1_encoding_start (uchar FAR *p_pc, uchar FAR * FAR *p_p_data, uchar FAR *p_limit, uchar store_nb, asn1_store_t FAR *p_store_list);
						- p_pc : address of the meta-language program describing instructions to be executed,
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit,
						- store_nb : number of meta-program storage descriptions in list,
						- p_store_list : pointer to list of meta-program storage descriptions.

Description			the function scans the metaprograms describing each type
					included in the ASN1 type to be encoded and encode each
					type in the order they appear in a (Type Length Value)
					model (specified by an encoding rules recommendation,
					currently only 1 : the Basic Encoding Rules). The resulting
					encoded data are put in the data area pointed to by
					*p_p_data pointer. Each time a new meta-program is to be
					analysed (corresponding to a "type field" in current
					meta-program), the imbrication level is increased. The
					first level is 0, corresponding to the first analysed
					meta-program that pertains to the type to be encoded.

Return value :		the total length of encoded data or 0 if a problem occurs.

Common constants and declarations : asn1.h, asn1_int.h, asn1_ber.h.

*--------------------------------------------------------------------------*/

ulong  asn1_encoding_start (p_pc, p_p_data, p_limit, store_nb, p_store_list)
	uchar FAR			*p_pc;				/* meta-language program counter */
	uchar FAR * FAR 	*p_p_data;			/* pointer to data area pointer : on first octet where to put the encoded data */
	uchar FAR			*p_limit;			/* pointer to data area limit */
	uchar				store_nb;			/* number of meta-program storage descriptions in list */
	asn1_store_t FAR	*p_store_list;		/* pointer to list of meta-program storage descriptions */
{

	ulong							length = 0;				/* length to be returned = total data length */
	ulong							get_length;				/* variable used to get current length returned by a function */
	struct asn1_type_common	FAR		*p_type_desc;			/* pointer to common fields used in a type description meta-program */
	struct asn1_address_size FAR 	*p_store = P_NIL;		/* pointer to structure describing address and size of value */
	uchar							list_x;					/* current index in list of storage contexts */
	uchar							analyses_nb;			/* number of type analyses to be done */
	uchar							analyse_field_nb;		/* number of the current type field to be analysed */

	if ((p_type_desc = (struct asn1_type_common FAR *)p_pc) == P_NIL) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_START, P_NIL, p_pc);
		return (0);
	};

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_START_P_DATA, P_NIL, p_pc);
		return (0);
	}

	if ((p_limit == P_NIL) || (p_limit <= *p_p_data)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_START_P_LIM, p_limit, p_pc);
		return (0);
	}

	if ((p_store_list == P_NIL) || (store_nb == 0)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_NO_STORE_CTX, (uchar FAR *)p_store_list, p_pc);
		return (0);
	};

		/* init common variables */

	asn1_init ();

		/* init program counter of lowest level */

	Lowest_p_pc			= p_pc;

	while (TRUE) {

			/* The encoding is made according to a (Type Length Value) model
				-> encode the current TYPE IDENTIFICATION octets */

		if ((get_length = Asn1_encode_type_ident (p_p_data, p_limit,
												  Asn1_type_id,
												  Asn1_type_impl_flag,
												  Asn1_type_tag_class,
												  Asn1_type_tag_nb,
												  Asn1_type_p_tag_nb)) != 0)
		{

			if (get_length == ASN1_ERR_TYPE_IDENT_LGTH) {

					/* a problem has occurred while encoding type identification */

				Asn1_set_error	(ASN1_ERR_ENCOD_TYPE_IDENT, (uchar FAR *)&length, Current_p_pc);
				return (0);
			}

				/* *p_p_data now points to the first octet of length field */

			Current_length = 0;
			length += get_length;
			Current_p_length = *p_p_data;

				/* if a lower level exists, the corresponding length
					shall take into account the length of the "type
					identification" field of the imbricated type */

			if (asn1_imbric_level != 0) {

				Lower_length += get_length;
			}
		}

			/*
				*p_p_data now points to the first octet of length field
				(if type identification has been encoded above)
				-> encode the value, there are 2 cases :

					1) the current type is a basic type (no field in type
					description meta-program), encode the length + value
					with a basic encoding specific function;

					2) the current type has one or more field(s) -> get
					the first one, increase the imbrication level and
					continue to process in this function.
			*/

		if (Asn1_type_field_nb == 0) {

				/* BASIC TYPE */

			if (p_store == P_NIL) {

					/* if pointer to storage context is null, search in the list
						for a context associated with current basic type */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) != ASN1_INDEX_NIL) {

						/* a context is found : update pointer */

					Asn1_get_p_store (list_x);
				}
			}

			if ((get_length = asn1_encode_basic_type (p_store, p_p_data, p_limit)) == 0) {

					/* an error has occurred during basic encoding */

				return (0);
			}

#			if ASN1_ANY_TYPE_USED == ON
				if (get_length == 0xFFFFFFFFL) {

					get_length = 0;	/* an "ANY" type may be empty : in this case, reset dummy length value */
				}
#			endif

				/* encoding of basic type is achieved : reinit storage
					pointer to prevent mis-use for next type encoding */

			p_store = P_NIL;

				/* basic type is encoded :
					1) increment total length and store current length,
					2) if it is not the lowest imbrication level
						increment length of lower level,
					3) search for next type to be encoded : decrease
						level until next field not yet analysed is found
						or until the lowest level is reached.

					4) if no next field found and lowest level is reached,
						encoding is completed successfully ->
						return total length. */

			length += get_length;
			Current_length = get_length;

			if (asn1_imbric_level == 0) {

				/* the type to be encoded is simply a basic type :
					encoding has completed -> return length */

				return (length);
			}

			while (asn1_imbric_level != 0) {

			label_level_loop_decrease :

					/* A lower level exists, the corresponding length
						shall take into account the length of the
						value encoding of the imbricated type */

				Lower_length += Current_length;

					/* reset current length and decrease imbrication level */

				Current_length = 0;
				asn1_imbric_level--;

					/* update pointer to common fields of lower meta-program */

				if ((Asn1_get_p_type_desc) == P_NIL) {

						/* Set error context and return 0 */

					Asn1_set_error_and_cause	(ASN1_ERR_ENCOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_DEC_LEVEL);
					return (0);
				}

					/* one more type field analysed (the one corresponding
						to the imbricated type which has just been encoded) */

				Current_field_nb++;

					/*
					  1) If the current type is a SEQUENCE or a SET, we
						have to encode each type matching a field in the
						meta-program -> the number of types to be analysed
						is the value of "field_nb" in meta-program, the
						current field to be analysed is Current_field_nb.

					  2) If the current type is a SEQUENCE OF or a SET OF,
						we have to process n encodings of the type specified
						in the meta-program -> the number n is specified by
						the ASN1 user with the field "store_size" in the
						corresponding storage context (its value may change
						from an ANS1 encoding to another one), the Current_field_nb
						Macro represents here the current number of times the
						type has already been encoded and the current field
						to be analysed is the only one in the meta-program (nb = 0).

					  3) If 1) and 2) do not apply, the current type
						description use another type description (not basic)
						but should have only one field, the type to
						which it refers and is to be analysed only once.
					*/

				switch (Asn1_type_id) {

					case ASN1_SEQUENCE_TYPE_ID :
					case ASN1_SET_TYPE_ID :

						analyses_nb = Asn1_type_field_nb;
						analyse_field_nb = Current_field_nb;

#						if ASN1_OPTIONAL_USED == ON

							/* search for first type field in SEQUENCE or SET
								that is to be encoded (mandatory or optional with indicator indicating present) */

							while (analyse_field_nb < analyses_nb) {

									/* get list of optional indicators associated with type */

								p_asn1_optional_ind = Asn1_type_opt_ind_list (analyse_field_nb);

									/* Is type to be analysed ? */

								if (asn1_value_present () == PRESENT) {

										/* Yes -> stop searching */

									break;
								}

									/* No -> continue to scan */

								analyse_field_nb++;
							}

								/* update current field Nb */

							Current_field_nb = analyse_field_nb;

#						endif

						break;

					case ASN1_SEQUENCEOF_TYPE_ID :
					case ASN1_SETOF_TYPE_ID :

							/* search in the list for a context associated
								with current SET OF or SEQUENCE OF type */

						if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) == ASN1_INDEX_NIL) {

								/* No context found where to read values
									-> set error context and return 0 */

							Asn1_set_error	(ASN1_ERR_ENCOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
							return (0);
						}

							/* a context is found : update pointer */

						Asn1_get_p_store (list_x);

							/* get the current valid storage information context :
								more than one may exist if this type is itself
								contained in a list (SET OF or SEQUENCE OF) */

						while (p_store != (struct asn1_address_size FAR *)P_NIL) {

							if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

									/* This is the right context : stop scanning */

								break;
							}

								/* get next storage context */

							p_store = Asn1_type_next_store;
						}

						if (p_store == (struct asn1_address_size FAR *)P_NIL) {

								/* No context found : set error context and return 0 */

							Asn1_set_error	(ASN1_ERR_ENCOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
							return (0);
						}

						if (Asn1_type_store_size > (uchar)(~0)) {

								/* number of times the type is to be encoded
									exceeds 255 : invalid
									-> Set error context and return 0 */

							Asn1_set_error	(ASN1_ERR_ENCOD_TOO_MANY_TYPES, &asn1_imbric_level, Current_p_pc);
							return (0);
						}

						analyses_nb = (uchar)Asn1_type_store_size;
						analyse_field_nb = 0;

							/* reinit storage pointer to prevent mis-use for next type analyse */

						p_store = P_NIL;
						break;

					default :

						analyses_nb = 1;
						break;
				}

				if (Current_field_nb < analyses_nb) {

						/* there are analyses left to be processed
							-> increase level and get matching meta-program
								pointer */

					asn1_imbric_level++;

					if ((Current_p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

							/* type is not basic but a nil meta-program pointer
								(type field in meta_program description) was specified */

						Trap (TRAP_ASN1_NIL_PC, "asn1_encoding_start");
						return (0);
					}

						/* init current level variable */

					Current_p_length	= P_NIL;
					Current_field_nb	= 0;
					Current_length		= 0;

						/* update pointer to common fields of current meta-program */

					if ((Asn1_get_p_type_desc) == P_NIL) {

							/* Set error context and return 0 */

						Asn1_set_error_and_cause	(ASN1_ERR_ENCOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_INC_LEVEL);
						return (0);
					}

						/* search in the list for a context associated
							with field of current lower level meta-program
							corresponding to current type (this type in included
							in a SET or SEQUENCE or SET OF or SEQUENCE OF type) */

					if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Lower_p_pc, (analyse_field_nb + 1))) != ASN1_INDEX_NIL) {

							/* a context is found -> update storage pointer */

						Asn1_get_p_store (list_x);

					} else {

						p_store = P_NIL;
					}

						/* analyse of this meta-program */

					break;

				} else {

					/* All the fields of the current meta-program have been
						analysed : encode the length in reserved data area */

					if (Current_p_length != P_NIL) {

						if ((get_length = Asn1_encode_sized_length (Current_length, ASN1_LGTH_HOLE_SIZE, &Current_p_length)) == 0) {

							Asn1_set_error	(ASN1_ERR_ENCOD_SIZED_LGTH, &asn1_imbric_level, Current_p_pc);
							return (0);
						}
					}

						/* Current level is processed : if it is
							the lowest level, encoding has completed
							-> return length
							else continue to process at lower level.

							In all cases, set the encoding flag to
							indicate that current value is encoded */

						/* search in the list for a context associated
							with current encoded type */

					if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) != ASN1_INDEX_NIL) {

							/* a context is found -> update storage pointer */

						Asn1_get_p_store (list_x);
					}

						/* get the current valid storage information context :
							more than one may exist if this type is itself
							contained in a list (SET OF or SEQUENCE OF) */

					while (p_store != (struct asn1_address_size FAR *)P_NIL) {

						if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

								/* This is the right context : stop scanning */

							break;
						}

							/* get next storage context */

						p_store = Asn1_type_next_store;
					}

					if (p_store != (struct asn1_address_size FAR *)P_NIL) {

							/* a context is found : set encoding flag */

						Asn1_type_store_flag = ASN1_ENCODED_VALUE;
					}

						/* reinit storage pointer to prevent mis-use for next type analyse */

					p_store = P_NIL;

					if (asn1_imbric_level == 0) {

						return (length);
					}

					continue;
				}

			} /* end of "while (asn1_imbric_level != 0)" */

				/* analyse of next meta-program */

			continue;

		} else {

				/* NOT BASIC TYPE */

			/* initialize number of fields processed */

			analyse_field_nb = 0;

			switch (Asn1_type_id) {

				/* check that there is at least 1 type to encode if type is
					a list (SET OF or a SEQUENCE OF). If 0 encoding is specified
					encode null length and process next type at lower level if any */

				case ASN1_SEQUENCEOF_TYPE_ID :
				case ASN1_SETOF_TYPE_ID :

						/* search in the list for a context associated
							with current SET OF or SEQUENCE OF type */

					if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) == ASN1_INDEX_NIL) {

							/* No context found where to read values
								-> set error context and return 0 */

						Asn1_set_error	(ASN1_ERR_ENCOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
						return (0);
					}

						/* a context is found : update pointer */

					Asn1_get_p_store (list_x);

						/* get the current valid storage information context :
							more than one may exist if this type is itself
							contained in a list (SET OF or SEQUENCE OF) */

					while (p_store != (struct asn1_address_size FAR *)P_NIL) {

						if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

								/* This is the right context : stop scanning */

							break;
						}

							/* get next storage context */

						p_store = Asn1_type_next_store;
					}

					if (p_store == (struct asn1_address_size FAR *)P_NIL) {

							/* No context found : set error context and return 0 */

						Asn1_set_error	(ASN1_ERR_ENCOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
						return (0);
					}

					if (Asn1_type_store_size == 0) {

							/* number of times the type is to be encoded = 0
								Nothing to encode -> encode null length and
								process level decrease in upper loop */

						if ((get_length = Asn1_encode_length	(0, p_p_data, p_limit)) == 0) {

							Asn1_set_error_and_cause	(ASN1_ERR_ENCOD_DATA_TOO_BIG, (uchar FAR *)&length, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
							return (0);
						}

						Asn1_type_store_flag = ASN1_ENCODED_VALUE;

							/* reinit storage pointer to prevent mis-use for next type analyse */

						p_store = P_NIL;
						length += get_length;

						if (asn1_imbric_level == 0) {

							return (length);
						}

						Lower_length += get_length;
						goto label_level_loop_decrease;
					}

						/* reinit storage pointer to prevent mis-use for next type analyse */

					p_store = P_NIL;
					break;

#				if ASN1_OPTIONAL_USED == ON

					/* if type is a SEQUENCE or a SET, search for first type field
						that is to be analysed (mandatory or optional with indicator indicating present) */

					case ASN1_SEQUENCE_TYPE_ID :
					case ASN1_SET_TYPE_ID :

						analyses_nb = Asn1_type_field_nb;

						while (analyse_field_nb < analyses_nb) {

								/* get list of optional indicators associated with type */

							p_asn1_optional_ind = Asn1_type_opt_ind_list (analyse_field_nb);

								/* Is type to be analysed ? */

							if (asn1_value_present () == PRESENT) {

									/* Yes : stop searching */

								break;
							}

								/* No : continue to scan */

							analyse_field_nb++;
						}

						if (analyse_field_nb == analyses_nb) {

							/* all the fields are optional and none is to be encoded
								-> encode null length and process level decrease in upper loop */

							if ((get_length = Asn1_encode_length	(0, p_p_data, p_limit)) == 0) {

								Asn1_set_error_and_cause	(ASN1_ERR_ENCOD_DATA_TOO_BIG, (uchar FAR *)&length, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
								return (0);
							}

								/* reinit storage pointer to prevent mis-use for next type analyse */

							p_store = P_NIL;
							length += get_length;

							if (asn1_imbric_level == 0) {

								return (length);
							}

							Lower_length += get_length;
							goto label_level_loop_decrease;
						}

						break;

#				endif /* ASN1_OPTIONAL_USED */
			}

			if (get_length != 0) {

					/* Type identification has been encoded : *p_p_data now
						points to the first octet of length field : reserve
						a data area to store the length with a given size */

				(*p_p_data) += ASN1_LGTH_HOLE_SIZE;

					/* check that data area pointer does not exceed p_limit */

				if (*p_p_data > p_limit) {

					Asn1_set_error_and_cause	(ASN1_ERR_ENCOD_DATA_TOO_BIG, (uchar FAR *)&length, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
					return (0);
				}

				length += ASN1_LGTH_HOLE_SIZE;

				/* if a lower level exists, the corresponding length
					shall take into account the fixed length of the
					"length" field of the imbricated type */

				if (asn1_imbric_level != 0) {

					Lower_length += ASN1_LGTH_HOLE_SIZE;
				}

			} else {

					/* Type identification has not been encoded : the length
						is not to be encoded at this level so we reset the
						current length pointer to avoid a further encoding
						of the length that would delete the following
						encoding (this following encoding shall start with
						the type identification of next type to be analysed
						at upper level). */

				Current_p_length = P_NIL;
			}

			if (Asn1_type_id == ASN1_CHOICE_TYPE_ID) {

				/*
					Current type is a CHOICE type : its encoding is the one
					of the chosen type among the type fields described in
					the meta-program. Use the storage "size" field to
					determine which type field is to be encoded, no
					additional imbrication level is required.
				*/

					/* search in the list for a context associated
						with current CHOICE type */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) == ASN1_INDEX_NIL) {

						/* No context found where to read values
							-> set error context and return 0 */

					Asn1_set_error	(ASN1_ERR_ENCOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
					return (0);
				}

					/* a context is found : update pointer */

				Asn1_get_p_store (list_x);

					/* get the current valid storage information context :
						more than one may exist if this type is itself
						contained in a list (SET OF or SEQUENCE OF) */

				while (p_store != (struct asn1_address_size FAR *)P_NIL) {

					if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

							/* This is the right context : stop scanning */

						break;
					}

						/* get next storage context */

					p_store = Asn1_type_next_store;
				}

				if (p_store == (struct asn1_address_size FAR *)P_NIL) {

						/* No context found : set error context and return 0 */

					Asn1_set_error	(ASN1_ERR_ENCOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
					return (0);
				}

				if (Asn1_type_store_size >= Asn1_type_field_nb) {

						/* Set error context and return 0 */

					Asn1_set_error	(ASN1_ERR_ENCOD_CHOICE, (uchar FAR *)&(Asn1_type_store_size), Current_p_pc);
					return (0);
				}

					/* get "size" field of current storage context that represents
						for a CHOICE type the field number of the type to be encoded */

				analyse_field_nb = (uchar)(Asn1_type_store_size);

					/* set the encoding flag so that the storage context is
						not used twice : it cannot be set after this point
						because for a CHOICE type, imbrication level is not
						incremented -> so we set it now though encoding is
						not yet processed */

				Asn1_type_store_flag = ASN1_ENCODED_VALUE;

					/* get meta-program pointer */

				if ((p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

						/* type is not basic but a nil meta-program pointer
							(type field in meta_program description) was specified */

					Trap (TRAP_ASN1_NIL_PC, "asn1_encoding_start");
					return (0);
				}

					/* search in the list if a storage context is associated
						with the current field of the CHOICE type, corresponding
						to the next type to be analysed */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, (analyse_field_nb + 1))) != ASN1_INDEX_NIL) {

						/* a context is found -> update storage pointer */

					Asn1_get_p_store (list_x);

				} else {

					p_store = P_NIL;
				}

					/* update current level meta-program pointer */

				Current_p_pc = p_pc;

					/* update pointer to common field of current meta-program
						and reset field number of current level */

				if ((Asn1_get_p_type_desc) == P_NIL) {

						/* Set error context and return 0 */

					Asn1_set_error_and_cause	(ASN1_ERR_ENCOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
					return (0);
				}

				Current_field_nb = 0;

					/* analyse of this meta-program */

				continue;
			}

			if (p_store == P_NIL) {

					/* search in the list if a storage context is associated
						with the current field of the type, corresponding
						to the next type to be analysed */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, (analyse_field_nb + 1))) != ASN1_INDEX_NIL) {

						/* a context is found -> update storage pointer */

					Asn1_get_p_store (list_x);

				} else {

					p_store = P_NIL;
				}
			}

				/* increase imbrication level */

			if ((asn1_imbric_level + 1) >= ASN1_MX_IMBRICATION_LEVEL) {

					/* too many imbrication levels : should never happen */

				Trap (TRAP_ASN1_IMBRICATION, "asn1_encoding_start");
				return (0);
			}

				/* init number of fields that have already been analysed
					in current level and increase level */

			Current_field_nb = analyse_field_nb;
			asn1_imbric_level++;

			if ((p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

					/* type is not basic but a nil meta-program pointer
						(type field in meta_program description) was specified */

				Trap (TRAP_ASN1_NIL_PC, "asn1_encoding_start");
				return (0);
			}

				/* update current level meta-program pointer */

			Current_p_pc = p_pc;

				/* update pointer to common field of current meta-program */

			if ((Asn1_get_p_type_desc) == P_NIL) {

					/* Set error context and return 0 */

				Asn1_set_error_and_cause	(ASN1_ERR_ENCOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
				return (0);
			}

				/* analyse of this meta-program */

			continue;
		}
	}
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	asn1_encode_basic_type - implements the encoding of an
					ASN1 basic type, i.e. described with a metaprogram that
					has no "type field" (no reference to another ASN1 type).

Usage            	ulong asn1_encode_basic_type (asn1_store_ctx_t FAR *p_store, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- p_store : pointer to storage context structure,
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit.

Description			the function reads the metaprogram describing the ASN1
					basic type and encodes it in a (Type Length Value)
					model (specified by an encoding rules recommendation,
					currently only 1 : the Basic Encoding Rules).
					The type is identified with the Type ID and the matching
					type specific encoding function is called in order to
					encode the length and the value.
					The resulting encoded data are put in the data area
					pointed to by *p_p_data pointer.

Return value :		the total length of encoded data or 0 if a problem occurs.

Common constants and declarations : asn1.h, asn1_int.h, asn1_ber.h.

*--------------------------------------------------------------------------*/

ulong  asn1_encode_basic_type (p_store, p_p_data, p_limit)
	asn1_store_ctx_t FAR		*p_store;			/* pointer to address structure for value to be encoded */
	uchar FAR * FAR 			*p_p_data;			/* pointer to data area pointer : on first octet where to put the encoded data */
	uchar FAR					*p_limit;			/* pointer to data area limit */
{

	ulong 							length;				/* length to be returned */
	struct asn1_type_common	FAR		*p_type_desc; 		/* pointer to common fields used in description meta-program */
	uchar FAR						*p_lgth;			/* pointer to length location (used for constructed types) */

	if ((Asn1_get_p_type_desc) == P_NIL) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_BASIC_START, P_NIL, Current_p_pc);
		return (0);
	};

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_BASIC_P_DATA, P_NIL, Current_p_pc);
		return (0);
	}

	if ((p_limit == P_NIL) || (p_limit <= *p_p_data)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_BASIC_P_LIM, p_limit, Current_p_pc);
		return (0);
	}

		/* get the current valid storage information context :
			more than one may exist if this type is itself
			contained in a list (SET OF or SEQUENCE OF) */

	while (p_store != (asn1_store_ctx_t FAR *)P_NIL) {

			/* 	the valid context is determined according to the "coding flag" field
				and the Type id : if the type is an OBJECT IDENTIFIER, the flag
				represents the number of appended sub-identifiers if it has
				not already been encoded and it is inferior to ASN1_MX_APPEND_SUBID */

		if (Asn1_type_id != ASN1_OBJECTIDENT_TYPE_ID) {

			if ((Asn1_type_store_flag == ASN1_NO_CODING_DONE) ||
				(Asn1_type_store_flag == ASN1_CODING_POSITIVE) ||
				(Asn1_type_store_flag == ASN1_CODING_NEGATIVE)) {

					/* This is the right context : stop scanning */

				break;
			}

		} else if (Asn1_type_store_flag <= ASN1_MX_APPEND_SUBID) {

				/* This is the right context : stop scanning */

			break;
		}

			/* get next storage context */

		p_store = Asn1_type_next_store;
	}

	if ((p_store == (asn1_store_ctx_t FAR *)P_NIL) && (Asn1_type_id != ASN1_NULL_TYPE_ID)) {

			/* No context found and it is not a NULL type :
				set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_BASIC_P_STORE, P_NIL, Current_p_pc);
		return (0);
	}

	if (Asn1_type_field_nb != 0) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_ENCOD_NOT_BASIC, P_NIL, Current_p_pc);
		return (0);
	}

		/*	test if encoding is constructed : it is possible even for basic type
			if explicit tagging is used. If so -> skip length of constructed type,
			encode tag of primitive Type, process value and encode length of constructed type */


	p_lgth = P_NIL;
	if ((Asn1_type_tag_class != ASN1_TYPE_NO_TAG) &&
		((Asn1_type_impl_flag == ASN1_TYPE_EXPLICIT) || (Asn1_type_impl_flag == ASN1_TYPE_NO_IMPLICIT_KEYW))) {

		p_lgth = *p_p_data;
		(*p_p_data) += ASN1_LGTH_HOLE_SIZE;
		Asn1_encode_type_ident (p_p_data, p_limit, Asn1_type_id, 0, ASN1_TYPE_NO_TAG, ASN1_TYPE_NO_TAG, Asn1_type_p_tag_nb);
	}

	switch (Asn1_type_id) {

		case ASN1_BOOLEAN_TYPE_ID :

			if ((length = (ulong)Asn1_encode_boolean ((uchar)(Asn1_type_store_size), p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_BOOLEAN, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;

		case ASN1_INTEGER_TYPE_ID :

				/* "flag" field in storage context is used to provide the sign */

			if ((length = (ulong)Asn1_encode_integer (Asn1_type_store_size, Asn1_type_store_flag, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_INTEGER, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;

		case ASN1_ENUMERATED_TYPE_ID :

			if ((length = (ulong)Asn1_encode_enumerated (Asn1_type_store_size, Asn1_type_store_flag, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_ENUMERATED, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;

#		if ASN1_BIT_STRING_TYPE_USED == ON	/* BIT STRING Type is used */
		case ASN1_BITSTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_bit_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_BITSTRING, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

		case ASN1_OCTETSTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_octet_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_OCTETSTRING, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;

#		if ASN1_NUMERIC_S_TYPE_USED == ON	/* NumericString Type is used */
		case ASN1_NUMERICSTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_numeric_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_NUMERICSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_PRINTABLE_S_TYPE_USED == ON	/* PrintableString Type is used */
		case ASN1_PRINTABLESTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_printable_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_PRINTABLESTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_TELETEX_S_TYPE_USED == ON	/* TeletexString Type is used */
		case ASN1_TELETEXSTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_teletex_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_TELETEXSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_VIDEOTEX_S_TYPE_USED == ON	/* VideotexString Type is used */
		case ASN1_VIDEOTEXSTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_videotex_string ((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_VIDEOTEXSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_IA5_S_TYPE_USED == ON	/* IA5String Type is used */
		case ASN1_IA5STRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_IA5_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_IA5STR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_GRAPHIC_S_TYPE_USED == ON	/* GraphicString Type is used */
		case ASN1_GRAPHICSTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_graphic_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_GRAPHICSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_VISIBLE_S_TYPE_USED == ON	/* VisibleString Type is used */
		case ASN1_VISIBLESTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_visible_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_VISIBLESTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_GENERAL_S_TYPE_USED == ON	/* GeneralString Type is used */
		case ASN1_GENERALSTRING_TYPE_ID :

			if ((length = (ulong)Asn1_encode_general_string	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_GENERALSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

		case ASN1_NULL_TYPE_ID :

			if ((length = (ulong)Asn1_encode_null(p_p_data, p_limit)) == 0) {

					/* Set error context and return 0 */

				Asn1_set_error	(ASN1_ERR_ENCOD_NULL, P_NIL, Current_p_pc);
				return (0);
			}

			break;

		case ASN1_OBJECTIDENT_TYPE_ID :

				/* "flag" field in storage context is used to provide
					the number of appended sub-identifiers */

			if ((length = (ulong)Asn1_encode_object_identifier ((asn1_node_id_t)Asn1_type_store_size, Asn1_type_store_flag, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_OBJ_ID, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;

#		if ASN1_OBJ_DESC_TYPE_USED == ON	/* ObjectDescriptor Type is used */
		case ASN1_OBJECTDESCR_TYPE_ID :

			if ((length = (ulong)Asn1_encode_object_descriptor	((ushort)Asn1_type_store_size, Asn1_type_store_add, p_p_data, p_limit)) == 0) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_OBJ_DESC, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_ANY_TYPE_USED == ON
		case ASN1_ANY_TYPE_ID :

				/* "ANY" Type : Copy data transparently */

			length = Asn1_type_store_size;
			if ((p_limit <= ((*p_p_data) + (ushort)length)) || (Asn1_type_store_add == P_NIL)) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_ENCODED_VALUE;
				Asn1_set_error	(ASN1_ERR_ENCOD_BASIC_P_LIM, p_limit, Current_p_pc);
				return (0);
			}

			Memcpy_far ((char FAR *)(*p_p_data), (char FAR *)(Asn1_type_store_add), (uchar)(length));
			(*p_p_data) += (uchar)(length);
			break;
#		endif

	/*		not implemented
		case ASN1_UNIVERSALTIME_TYPE_ID :
		case ASN1_GENERALIZEDTIME_TYPE_ID :
		case ASN1_EXTERNAL_TYPE_ID :
		case ASN1_REAL_TYPE_ID :
	*/
		default :

				/* the ASN1 type is unknown or not implemented */

			Trap (TRAP_ASN1_TYPE_NOT_IMPLEMENTED, "asn1_encode_basic_type");
			return (0);
	}

		/* value is encoded : encode the length of construted Type (if any) in reserved data area */

	if (p_lgth != P_NIL) {

    	length = (ulong)((ulong)(*p_p_data) - (ulong)p_lgth - ASN1_LGTH_HOLE_SIZE);
		Asn1_encode_sized_length (length, ASN1_LGTH_HOLE_SIZE, &p_lgth);
		length += ASN1_LGTH_HOLE_SIZE;	/* length to be returned shall take into account the "Length" field itself */
	}

		/* successful encoding : set storage context flag and return length of encoded data */

	if (Asn1_type_id != ASN1_NULL_TYPE_ID) {

		Asn1_type_store_flag = ASN1_ENCODED_VALUE;
	}

#	if ASN1_ANY_TYPE_USED == ON
		if ((Asn1_type_id == ASN1_ANY_TYPE_ID) && (length == 0)) {

			length = 0xFFFFFFFFL;	/* an "ANY" type may be empty : in this case, set 'length' to a dummy value to avoid bad use */
		}
#	endif

	return (length);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	asn1_init - implements the initialisation
					of common variables used in ASN1 implementation.

Usage            	void asn1_init (void);

Return value :		void

Common constants and declarations : asn1.h.

*--------------------------------------------------------------------------*/

void asn1_init ()
{
	uchar i;		/* loop index */

		/* init stored tag to NIL */

	Asn1_reset_stored_tag	();

		/* init error context */

	asn1_error_type			= ASN1_ERR_NIL;
	p_asn1_erroneous_value	= P_NIL;
	p_pc_asn1_error			= P_NIL;
	asn1_error_cause		= ASN1_ERR_CAUSE_NIL;

		/* init imbrication level */

	asn1_imbric_level = 0;

		/* init imbrication tables */

	for (i = 0; i < ASN1_MX_IMBRICATION_LEVEL; i++) {

		Imbricated_length (i)		= (ulong)0;
		Imbricated_p_length (i)		= P_NIL;
		Imbricated_p_pc (i)			= P_NIL;
		Imbricated_field_nb (i)		= 0;
	}

#	if ASN1_BER_USED == ON

			/* init BER pointer to the conversion table from
				Type ID to type identification encoding */

		p_ber_prim_tag_nb = (struct ber_primitive_tag_nb FAR *)BER_TYPE_PRIMITIVE_TAG_NB;

#	endif

}

/*EOF*/
