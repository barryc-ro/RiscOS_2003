
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ber_dec.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function (s)
 *
 *	All the functions used to decode ASN1 data according to
 *	Basic Encoding Rules :
 *
 *		ber_decode_type_ident			- implements the decoding of the IDENTIFIER
 *											OCTETS field of a BER encoded value.
 *
 *		ber_decode_length				- implements the decoding of the
 *											length field for any value decoding
 *
 *		ber_decode_null					- implements the decoding of a
 *											NULL value according to
 *											the basic encoding rules
 *
 *		ber_decode_boolean				- implements the decoding of a
 *											BOOLEAN value according to
 *											the basic encoding rules
 *
 *		ber_decode_integer				- implements the decoding of an
 *											INTEGER value according to
 *											the basic encoding rules
 *
 *		ber_decode_prim_bitstring		- implements the decoding of a
 *											BIT STRING value according to
 *											the basic encoding rules
 *
 *		ber_decode_prim_o_c_string		- implements the decoding of an OCTET STRING
 *											or CharacterString value
 *											according to the basic encoding rules
 *
 *		ber_decode_object_id			- implements the decoding of an
 *											OBJECT IDENTIFIER value according
 *											to the basic encoding rules
 *
 *		ber_decode_obj_sub_id			- implements the decoding of a component
 *											in an OBJECT IDENTIFIER value according
 *											to the basic encoding rules
 *
 *		ber_compare_length 				- implements the comparaison of the
 *											LENGTH OCTETS field of a BER encoded
 *											data with a given length or with data
 *											if length is of indefinite form.
 *
 *		uchar ber_skip_type_id			- implements the skipping of the
 *											IDENTIFIER OCTETS field of a BER encoded
 *											type without any interpretation.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    ASN1 language notation encoding/decoding library |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "asn1.h"

		/* Copyright */

CONST char 	ber_dec_copyright[]	= "Copyright (c) 1989/96 by OMNITEL SA - All Rights Reserved";
CONST char 	ber_dec_licence[]		= LICENSE_NBER;

extern struct asn1_obj_id_node CONST FAR *p_asn1_obj_id_list;

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_decode_type_ident - implements the decoding of the IDENTIFIER
					OCTETS field of a BER encoded value.


Usage            	uchar ber_decode_type_ident (uchar FAR * FAR *p_p_data, uchar FAR *p_limit,
												 uchar type_id, uchar impl, uchar class,
												 asn1_tag_nb_t tag_nb,
								# if ASN1_TAG_NB_EXTENSION_MECHANISM == ON
												 uchar FAR *p_tag_nb);
								# endif
						- p_p_data : pointer to pointer where to read encoded IDENTIFIER OCTETS field,
						- p_limit : pointer to data area limit,
						- type_id : value identifying the ASN1 type to be decoded, equivalent to ASN1 keyword (SEQUENCE, CHOICE, ...),
						- impl : flag indicating if IMPLICIT or EXPLICIT or none keyword was used in the type description,
						- class : class of the tag of the type (or NO_TAG if type is not a tagged type),
						- tag_nb : number of the tag of the type (or NO_TAG if type is not a tagged type),
							last argument : only if tag number extension mechanism is used : see "# if" above
						- p_tag_nb :pointer to the number of the tag if tag is too long to be described only with tag_nb, else P_NIL.

Description			the function reads the numbers and keywords used
					in the ASN1 type description to identify the type.
					if type cannot be identified (further analyse required),
					it returns 0. Else, it decodes the IDENTIFIER OCTETS
					of the BER encoded value pointed to by p_data pointer
					compares both identification, and it sets p_data after
					the end of the IDENTIFIER OCTETS field.

Return value :  0 if type cannot be identified (not enough identification info),
				else number of octets in IDENTIFIER OCTETS field if this field
				matches the type identification else BER_ERR_TYPE_IDENT_LGTH.

Common constants and declarations : asn1_ber.h.

*--------------------------------------------------------------------------*/

#if ASN1_TAG_NB_EXTENSION_MECHANISM == ON

ushort ber_decode_type_ident (p_p_data, p_limit, type_id, impl, class, tag_nb, p_tag_nb)

#else

ushort ber_decode_type_ident (p_p_data, p_limit, type_id, impl, class, tag_nb)

#endif

	uchar FAR * FAR	*p_p_data;
	uchar FAR		*p_limit;
	uchar			type_id;
	uchar			impl;
	uchar			class;
	asn1_tag_nb_t	tag_nb;

#if ASN1_TAG_NB_EXTENSION_MECHANISM == ON
	uchar FAR		*p_tag_nb;
#endif
{
	ushort 			i = 0;					/* loop index */
	uchar 			constructed = NOK;		/* flag indicating if type is contructed : OK = constructed / NOK = primitive / CONTINUE = both */
	uchar			type_found = OFF;		/* flag indicating if type was found in table */
	uchar 			tagged_type;			/* flag indicating if type is tagged */
	ushort 			octet_nb;				/* number of octets in IDENTIFIER OCTETS field */
	asn1_tag_nb_t	current_tag_nb;			/* current value of tag nb */

#	if ASN1_TAG_NB_EXTENSION_MECHANISM == ON

		uchar		bit_position;			/* position in current octet */

#	endif

#	if ASN1_ANY_TYPE_USED == ON

		if (type_id == ASN1_ANY_TYPE_ID) {

			return (0);	/* "ANY" Type : no decoding is done (even for TYPE), data is copied transparently */
		}

#	endif

	asn1_constructed_flag = OFF;		/* init constructed flag */

		/* if a specific tag class was provided, type is a tagged type */

	tagged_type = (class != ASN1_TYPE_NO_TAG);

		/* Is the type encoding constructed ?

			 - For a tagged type :
			if the IMPLICIT keyword was not used in the type description,
			(EXPLICIT or none) the encoding is constructed,
			else the encoding is constructed if the base encoding is constructed
			and is primitive otherwise (base encoding is given with the type ID)

			- For a non-tagged type :
			as in second case for tagged type, the type ID will indicate if the
			encoding is constructed, while scanning the UNIVERSAL class table */

	if (tagged_type &&
		((impl == ASN1_TYPE_EXPLICIT) || (impl == ASN1_TYPE_NO_IMPLICIT_KEYW)))
	{

		constructed = OK;

	} else {

			/* scan table using type ID to know if type encoding is contructed */

		while ((Ber_type_id	(i)) != ASN1_TYPE_ID_NIL) {

			if ((Ber_type_id (i)) == type_id) {

					/* type is found : update flags and stop scanning */

				type_found = ON;

				switch (Ber_type_prim_flag (i)) {

					case BER_CONSTRUCTOR_ENCODING :

							/* type is constructed : set flag */

						constructed = OK;
						break;

					case BER_BOTH_PRIM_CONS_ENCODING :

							/* type may be primitive or constructed : set flag to CONTINUE */

						constructed = CONTINUE;
						break;
				}

				if (! tagged_type) {

						/* if type is not tagged, the tag class is UNIVERSAL
							and the tag number to be encoded is the one in the table,
							else class and number to be encoded are the ones of the tag */

					class = ASN1_TYPE_CLASS_UNIVERSAL;
					tag_nb = Ber_type_tag_nb (i);
				}

				break;
			}

				/* type not found : continue to scan */

			i++;
		}
	}

		/* Is there a Tag (class + nb) that has already been stored ?
			Yes : this is the one to be encoded */

	if (Asn1_get_tag_class != ASN1_TYPE_NO_TAG) {

		class = Asn1_get_tag_class;
		tag_nb = Asn1_get_tag_nb;
		Asn1_get_p_tag_nb	(p_tag_nb)
	}

	if ((constructed == NOK) && (type_found == OFF)) {

			/*	constructed encoding is not determined : type
				description requires further analyse ->
				no decoding but store the Tag if type is tagged */

		if (tagged_type) {

			Asn1_store_tag_class	(class);
			Asn1_store_tag_nb		(tag_nb);
			Asn1_store_p_tag_nb		(p_tag_nb)
		}

		return (0);
	}

		/*
			Tag can be encoded, stored Tag has already been taken
			into account above -> reset it to avoid further bad reuse
			for another Tag. */

	Asn1_reset_stored_tag	();

		/* encoding way is determined : decode the IDENTIFIER OCTETS
			and compare with the way (Primitive/Constructor) and the Tag */

	switch (class) {

		case ASN1_TYPE_CLASS_UNIVERSAL :

			class = BER_TAG_CLASS_UNIVERSAL;
			break;

		case ASN1_TYPE_CLASS_APPLICATION :

			class = BER_TAG_CLASS_APPLICATION;
			break;

		case ASN1_TYPE_CLASS_CONTEXT_SPFC :

			class = BER_TAG_CLASS_CTX_SPECIFIC;
			break;

		case ASN1_TYPE_CLASS_PRIVATE :

			class = BER_TAG_CLASS_PRIVATE;
			break;

		default :

			Trap (TRAP_ASN1_TAG_CLASS, "ber_decode_type_ident - Bad Tag Class");
			break;
	}

		/* decode tag class in data and compare */

	if (class != Get_bits ((**p_p_data), 6, 2)) {

			/* Set error cause and return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
		return (BER_ERR_TYPE_IDENT_LGTH);
	}

		/* decode Primitive/Constructor flag and compare */

	if ((Get_bits ((**p_p_data), 5, 1)) == BER_CONSTRUCTOR_ENCODING) {

		asn1_constructed_flag = ON;
	}

	switch (constructed) {

		case OK :		/* type is contructed */

			if (asn1_constructed_flag != ON) {

					/* Set error cause and return error indication length */

				Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_P_C_FLAG);
				return (BER_ERR_TYPE_IDENT_LGTH);
			}

			break;

		case NOK :		/* type is primitive */

			if (asn1_constructed_flag != OFF) {

					/* Set error cause and return error indication length */

				Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_P_C_FLAG);
				return (BER_ERR_TYPE_IDENT_LGTH);
			}

			break;
	}

		/* decode Tag Number and compare */

	if ((tag_nb < BER_TAG_NB_EXTENDED)

#		if ASN1_TAG_NB_EXTENSION_MECHANISM == ON
			&& (p_tag_nb == P_NIL)
#		endif
		) {

			/* tag number is in range 0 to 30 : it must be encoded on 1 octet
				using bits 1 to 5 : compare with data, increment pointer and return 1 */

		if ((uchar)tag_nb != Get_bits ((**p_p_data), 0, 5)) {

				/* Set error cause and return error indication length */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
			return (BER_ERR_TYPE_IDENT_LGTH);
		}

		(*p_p_data)++;
		return (1);
	}

		/* tag number is too high to be encoded on 1 octet : IDENTIFIER OCTETS
			field should contain a leading octet followed by 1 or more subsequent octets */

		/* check leading octet (Bit 1 to 5 = 1) */

	if (Get_bits ((**p_p_data), 0, 5) != BER_TAG_NB_EXTENDED) {

				/* Set error cause and return error indication length */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
			return (BER_ERR_TYPE_IDENT_LGTH);
	}

	(*p_p_data) ++;

		/* Bits 1 to 7 of first subsequent octet shall not all be 0 */

	if (Get_bits ((**p_p_data), 0, 7) == 0) {

				/* Set error cause and return error indication length */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
			return (BER_ERR_TYPE_IDENT_LGTH);
	}

		/* check that data area pointer does not exceed p_limit */

	if (p_limit <= *p_p_data) {

			/* Set error cause and return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (BER_ERR_TYPE_IDENT_LGTH);
	}

		/* init octet counter */

	octet_nb = 1;

		/* decode subsequent octets :
			a list of 1 or more octet(s), bit 8 of last octet
			is 0 (STOP), bit 8 of each preceding octet is 1 (CONTINUE),
			bits 7 to 1 of all the octets in the list = tag nb */

#	if ASN1_TAG_NB_EXTENSION_MECHANISM == ON

		if (p_tag_nb != P_NIL) {

			/* Tag number is provided using p_tag_nb pointer :
				a list of octets and their number. */

				/* get number of octets in list : it is the first octet
					pointed to by p_tag_nb */

			i = *p_tag_nb++;

				/* delete all the null first octets */

			while (*p_tag_nb == 0) {

				if (i == 0) {

					Trap (TRAP_ASN1_TAG_NB, "ber_decode_type_ident - Bad extended Tag Nb");
				}

				i--;
				p_tag_nb++;
			}

				/* p_tag_nb now points to the first non null octet,
					init current position in octet and number of octets
					to be used for encoding */

			bit_position = 0;
			octet_nb = 0;

				/* BER encoding use only bits 1 to 7 of each subsequent octet :
					We scan the list of i octets using a bit_position variable,
					which represents the position in the octets list of the
					first bit of current data octet to be encoded. It is of course
					a modulo 8 counter. Each time the counter exceeds 8, it wraps
					around and number of octet in list is decremented. */

			while (i > 1) {

				bit_position += 7;
				octet_nb++;

				if (bit_position >= 8) {

					bit_position -= 8;
					i--;
				}
			}

				/* first octet of the list */

			if (bit_position == 0) {

				bit_position = 7;
				octet_nb++;
			}

				/* init loop counter */

			i = 0;

				/*
					bit_position is now the position of the first bit of
					the first data octet in the first octet of the list :
					One more octet may be needed if the most significant
					bits from position in first list octet are not null.
				*/

			tagged_type = Get_bits ((*p_tag_nb), bit_position, (8 - bit_position));

			if (tagged_type != 0) {

				octet_nb++;		/* one more octet to be encoded matching the most significant bits */
				i = 1;			/* increment loop index so that loop below is not processed too many times */

					/* check extension bit and first data octet (matching
						the most significant bits of first octet in list) */

				if ((Get_bits ((**p_p_data), 7, 1) != BER_EXT_BIT_CONTINUE) ||
					(Get_bits ((**p_p_data), 0, 7) != tagged_type)) {

						/* Set error cause and return error indication length */

					Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
					return (BER_ERR_TYPE_IDENT_LGTH);
				}

					/* increment data pointer */

				(*p_p_data)++;
			}

				/* number of encoded data octets is computed : check them
					(value in bits 1 to 7 and extension bit 8). The algorithm
					to check the data from the octet list is as follows :

					bit_position  p_tag_nb   next octet
							|		|          |
							v		v          v
						--------------  --------------
						|   | n bits |  | 7-n |      | n = bit_position.
						--------------  --------------
							 |________________|
									||
									vv
						  --------------------
						  |E| n bits | 7 - n | <-- p_data, E = extension bit.
						  --------------------
				*/

				/* check that data area pointer will not exceed p_limit */

			if (p_limit <= ((*p_p_data) + octet_nb)) {

					/* Set error cause return error indication length */

				Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
				return (BER_ERR_TYPE_IDENT_LGTH);
			}

			while (i < octet_nb) {

				if (bit_position != 7) {

					tagged_type = (uchar)((*p_tag_nb) << (7 - bit_position));
					p_tag_nb++;
					tagged_type += Get_bits ((*p_tag_nb), (bit_position + 1), (7 - bit_position));

						/* next position : if it was 3, we have taken into account
							bits 2, 1 and 0 of current list octet, and bits 7, 6,
							5 and 4 of next octet -> next position is 4 so that we
							start from bit 3 for next octet */

					bit_position++;

				} else {

					tagged_type = (*p_tag_nb) & Mask (7);
					bit_position = 0;
				}

				if (i == (octet_nb - 1)) {

					break;
				}

					/* check extension bit and value */

				if ((Get_bits ((**p_p_data), 7, 1) != BER_EXT_BIT_CONTINUE) ||
					(Get_bits ((**p_p_data), 0, 7) != tagged_type)) {

						/* Set error cause and return error indication length */

					Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
					return (BER_ERR_TYPE_IDENT_LGTH);
				}

				(*p_p_data)++;
				i++;
			}

				/* check extension bit and value */

			if ((Get_bits ((**p_p_data), 7, 1) != BER_EXT_BIT_STOP) ||
				(Get_bits ((**p_p_data), 0, 7) != tagged_type)) {

					/* Set error cause and return error indication length */

				Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
				return (BER_ERR_TYPE_IDENT_LGTH);
			}

			(*p_p_data)++;

				/* 1 leading octet + octet_nb subsequent octets */

			return (octet_nb + 1);
		}

#	endif

		/* Tag number is provided with tag_nb argument */

	current_tag_nb = tag_nb;

	while (current_tag_nb >= 128) {

		octet_nb++;
		current_tag_nb /= (asn1_tag_nb_t)128;
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + octet_nb)) {

			/* Set error cause and return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (BER_ERR_TYPE_IDENT_LGTH);
	}

		/*	check that Bit 8 of the last octet is set to 0 and that
			Bits 1 to 7 represent the end of tag_nb value :
			use tagged_type variable for current data octet */

	tagged_type = (*p_p_data)[octet_nb - 1];

	if (Get_bits (tagged_type, 0, 7) != (uchar)(tag_nb % (asn1_tag_nb_t)128)) {

			/* Set error cause and return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
		return (BER_ERR_TYPE_IDENT_LGTH);
	}

	if (Get_bits (tagged_type, 7, 1) != BER_EXT_BIT_STOP) {

			/* Set error cause and return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
		return (BER_ERR_TYPE_IDENT_LGTH);
	}

	tag_nb /= (asn1_tag_nb_t)128;

		/*	check that Bit 8 of each other octet is set to one and
			that Bits 1 to 7 represent the corresponding part of
			tag_nb value (use tagged_nb for current octet value) */

	for (i = (octet_nb - 1); i > 0; i--) {

		tagged_type = (*p_p_data)[i - 1];

		if (Get_bits (tagged_type, 0, 7) != (uchar)(tag_nb % (asn1_tag_nb_t)128)) {

				/* Set error cause and return error indication length */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
			return (BER_ERR_TYPE_IDENT_LGTH);
		}

		if (Get_bits (tagged_type, 7, 1) != BER_EXT_BIT_CONTINUE) {

				/* Set error cause and return error indication length */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_TAG);
			return (BER_ERR_TYPE_IDENT_LGTH);
		}

		tag_nb /= (asn1_tag_nb_t)128;
	}

		/* set data pointer after the end of value */

	(*p_p_data) += octet_nb;

		/* 1 leading octet + octet_nb subsequent octets */

	return (octet_nb + 1);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_decode_length - implements the decoding of the
					LENGTH OCTETS field of a BER encoded data.

Usage            	uchar ber_decode_length (ushort FAR *p_length, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- p_length : pointer to length to be returned,
						- p_p_data : pointer to pointer where to read LENGTH OCTETS field,
						- p_limit : pointer to data area limit.

Return value :      the functions returns a value describing the form used for encoding :
						BER_DECODE_INDEFINITE_LGTH if indefinite form,
						BER_DECODE_SHORT_FORM_LGTH if definite short form,
						BER_DECODE_LONG_FORM_LGTH if definite long form,
						BER_DECODE_LGTH_NOK if an error occurs.

					Decoded length is returned with p_length pointer argument.

Common constants and declarations : asn1_ber.h.

*--------------------------------------------------------------------------*/

#define BER_DECODE_INDEFINITE_LGTH		1
#define BER_DECODE_SHORT_FORM_LGTH		2
#define BER_DECODE_LONG_FORM_LGTH		3
#define BER_DECODE_LGTH_NOK				255

uchar ber_decode_length (p_length, p_p_data, p_limit)
	ushort FAR 		*p_length;			/* pointer to length to be returned */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer : on first octet of LENGTH OCTETS field */
	uchar FAR 		*p_limit;			/* pointer to data area limit */
{
	uchar	length_octets_lgth;			/* current number of octets in the LENGTH OCTETS field */
	ushort	length;						/* current length */

	if (**p_p_data == BER_LGTH_INDEFINITE_FORM) {

			/* first octet indicates indefinite form */

		(*p_p_data)++;
		return (BER_DECODE_INDEFINITE_LGTH);
	}

	if (**p_p_data <= BER_MX_LGTH_SHORT_FORM) {

			/* short form : length is data itself on 1 octet */

		*p_length = (ushort)(**p_p_data);
		(*p_p_data)++;

		return (BER_DECODE_SHORT_FORM_LGTH);
	}

		/* long form : 1 initial octet whose 7 least significant bits
			indicate the number of subsequent octets */

	length_octets_lgth = Get_bits((**p_p_data), 0, 7);
	(*p_p_data)++;

		/* check that data area pointer does not exceed p_limit */

	if (p_limit <= ((*p_p_data) + length_octets_lgth)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (BER_DECODE_LGTH_NOK);
	}

	length = 0;

	while ((length_octets_lgth > 0) && (**p_p_data == 0)) {

			/* read the first null octets until not null or end of length field */

		(*p_p_data)++;
		length_octets_lgth--;
	}

	if (length_octets_lgth == 0) {

			/* all the octets are null -> length = 0 */

		*p_length = (ushort)0;
		return (BER_DECODE_LONG_FORM_LGTH);
	}

	if (length_octets_lgth > sizeof (ushort)) {

			/* the length is too high to be encoded with an unsigned long
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (BER_DECODE_LGTH_NOK);
	}

		/* compute length */

	while (length_octets_lgth-- > 0) {

		length = (length * (ushort)256) + **p_p_data;
		(*p_p_data)++;
	}

	*p_length = length;
	return (BER_DECODE_LONG_FORM_LGTH);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_decode_xxx - implement the decoding of ASN1 data according
					to the Basic Encoding Rules and return the resulting value. xxx
					represents the ASN1 type of the value to be decoded (boolean,
					integer, ...) -> 1 function per ASN1 type.

Usage            	uchar ber_decode_null (uchar FAR * FAR *p_p_data, uchar FAR *p_limit);

					uchar ber_decode_boolean (asn1_store_ctx_t FAR *p_store, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);

					uchar ber_decode_integer (asn1_store_ctx_t FAR *p_store, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);

					uchar ber_decode_prim_bitstring (asn1_store_ctx_t FAR *p_store, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);

					uchar ber_decode_prim_o_c_string (asn1_store_ctx_t FAR *p_store, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);

					uchar ber_decode_object_id (asn1_store_ctx_t FAR *p_store, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);

						- p_store : pointer to storage context where to put decoded value,
						- p_p_data : pointer to pointer where to read data to be decoded,
						- p_limit : pointer to data area limit.

Description			the function reads the data to be decoded from area pointed
					to by *p_p_data pointer and it decodes the Value along with
					its Length octets. It puts the resulting decoded value in
					storage context pointed to by p_ctx pointer and it sets p_data
					at the end of the data (outside). p_data is passed
					by address so that it can be modified -> uchar FAR * FAR *

Return value :		OK if data valid and correctly decoded, NOK else.

Common constants and declarations : asn1.h, asn1_int.h, asn1_ber.h.

*--------------------------------------------------------------------------*/

	/* NULL type decoding */

uchar  ber_decode_null (p_p_data, p_limit)
	uchar FAR * FAR			*p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR				*p_limit;			/* pointer to limit of data area */
{
	ushort					length;				/* length of CONTENT OCTETS */
	uchar					ret_code;			/* return code */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (NOK);
	}

	ret_code = ber_decode_length (&length, p_p_data, p_limit);

	switch (ret_code) {

		case BER_DECODE_LGTH_NOK :

				/* an error has occurred during length decoding -> return NOK */

			return (NOK);

		case BER_DECODE_INDEFINITE_LGTH :

			/* the indefinite form shall not be used for primitive encoding
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_PRIM_INDEF_LGTH);
		return (NOK);
	}

		/* the content octets shall not contain any octet -> the length is 0 */

	if (length != 0) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_LENGTH);
		return (NOK);
	}

	return (OK);
}

/* ------------------------------------------------------------------------ */

	/* BOOLEAN type decoding */

uchar  ber_decode_boolean (p_store, p_p_data, p_limit)
	asn1_store_ctx_t FAR	*p_store;			/* pointer to context where to store decoded BOOLEAN value */
	uchar FAR * FAR			*p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR				*p_limit;			/* pointer to limit of data area */
{
	ushort					length;				/* length of CONTENT OCTETS */
	uchar					ret_code;			/* return code */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (NOK);
	}

	if (p_store == P_NIL) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_STORE);
		return (NOK);
	}

	ret_code = ber_decode_length (&length, p_p_data, p_limit);

	switch (ret_code) {

		case BER_DECODE_LGTH_NOK :

				/* an error has occurred during length decoding -> return NOK */

			return (NOK);

		case BER_DECODE_INDEFINITE_LGTH :

			/* the indefinite form shall not be used for primitive encoding
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_PRIM_INDEF_LGTH);
		return (NOK);
	}

		/* the content octets shall consist of a single octet */

	if (length != 1) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_LENGTH);
		return (NOK);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + 1)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (NOK);
	}

		/* CONTENT OCTETS : FALSE if 0, TRUE else */

	if (**p_p_data == BER_BOOLEAN_FALSE) {

		Asn1_type_store_size = (ulong)FALSE;

	} else {

		Asn1_type_store_size = (ulong)TRUE;
	}

	(*p_p_data)++;
	return (OK);
}

/* ------------------------------------------------------------------------ */

	/* INTEGER and ENUMERATED type decoding */

		/* The encoding of an enumerated value shall be that of the integer
			value with which it is associated */

uchar  ber_decode_integer (p_store, p_p_data, p_limit)
	asn1_store_ctx_t FAR	*p_store;			/* pointer to context where to store decoded INTEGER value */
	uchar FAR * FAR			*p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR				*p_limit;			/* pointer to limit of data area */
{
	ushort					length;				/* length of CONTENT OCTETS */
	ushort					i;					/* loop index */
	uchar					cur_octet;			/* current octet used for return code or sign of INTEGER value */
	ulong					value;				/* numerical value of INTEGER */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (NOK);
	}

	if (p_store == P_NIL) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_STORE);
		return (NOK);
	}

	cur_octet = ber_decode_length (&length, p_p_data, p_limit);

	switch (cur_octet) {

		case BER_DECODE_LGTH_NOK :

				/* an error has occurred during length decoding -> return NOK */

			return (NOK);

		case BER_DECODE_INDEFINITE_LGTH :

			/* the indefinite form shall not be used for primitive encoding
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_PRIM_INDEF_LGTH);
		return (NOK);
	}

		/* the content octets shall consist of 1 or more octet */

	if (length == 0) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_LENGTH);
		return (NOK);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + length)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (NOK);
	}

		/*	CONTENT OCTETS : if the content octets consist of more than 1
			octet, then the bits of the first octet and bit 8 of the second
			octet shall not all be 1 and shall not all be 0 (it ensures that
			an integer value is always encoded in the smallest possible form)
		*/

	if (length > 1) {

		cur_octet = (*p_p_data)[1];

		if ((**p_p_data == 0) && (Get_bits (cur_octet, 7, 1) == 0)) {

				/* Set error cause and return NOK */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_NOT_MINIMAL);
			return (NOK);
		}

		if ((**p_p_data == 255) && (Get_bits (cur_octet, 7, 1) == 1)) {

				/* Set error cause and return NOK */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_NOT_MINIMAL);
			return (NOK);
		}
	}

		/*	CONTENT OCTETS : 2's complement encoded integer, first octet is
			the most significant one and its bit 8 is the sign bit,
			last octet is the least significant one
		*/

	if (Get_bits ((**p_p_data), 7, 1) == 1) {

		cur_octet = ASN1_CODING_NEGATIVE;

	} else {

		cur_octet = ASN1_CODING_POSITIVE;
	}

		/*
			To match 2's complement, if the value is negative,
			substract 1 to encoded value (using a carry) and then
			1's complement is to be applied to all the encoded octets.
		*/

	if (cur_octet == ASN1_CODING_NEGATIVE) {

		for (i = length; i > 0; i--) {

				/* substract 1 : if current octet (starting from length)
					is not null, substract 1 and stop, else set it to 255
					and continue to process with preceding octet */

			if (((*p_p_data)[i - 1]) != 0) {

				((*p_p_data)[i - 1])--;
				break;
			}

			((*p_p_data)[i - 1]) = 255;
		}

			/* 1's complement : complement all the bits of current octet */

		for (i = 0; i < length; i++) {

			(*p_p_data)[i] = ~((*p_p_data)[i]);
		}
	}

		/* compute numerical value */

	i = 0;

	while ((i < length) && (**p_p_data == 0)) {

		(*p_p_data)++;
		i++;
	}

	if ((length - i) > sizeof (ulong)) {

			/*	value is too high to be encoded with an unsigned long
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_HIGH_VAL);
		return (NOK);
	}

	value = 0;

	while (i++ < length) {

		value = (value * (ulong)256) + **p_p_data;
		(*p_p_data)++;
	}

		/* store value into context and return OK :
			value into "size" field, sign into "coding_flag" field */

	Asn1_type_store_size	= value;
	Asn1_type_store_flag	= cur_octet;
	return (OK);
}

/* ------------------------------------------------------------------------ */

	/* BIT STRING type decoding */

uchar  ber_decode_prim_bitstring (p_store, p_p_data, p_limit)
	asn1_store_ctx_t FAR	*p_store;			/* pointer to context where to store decoded BIT STRING value */
	uchar FAR * FAR			*p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR				*p_limit;			/* pointer to limit of data area */
{
	ushort					length;				/* length of CONTENT OCTETS */
	uchar					ret_code;			/* return code */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (NOK);
	}

	if (p_store == P_NIL) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_STORE);
		return (NOK);
	}

	ret_code = ber_decode_length (&length, p_p_data, p_limit);

	switch (ret_code) {

		case BER_DECODE_LGTH_NOK :

				/* an error has occurred during length decoding -> return NOK */

			return (NOK);

		case BER_DECODE_INDEFINITE_LGTH :

			/* the indefinite form shall not be used for primitive encoding
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_PRIM_INDEF_LGTH);
		return (NOK);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + length)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (NOK);
	}

		/*	the content octets for the primitive encoding shall contain
			an initial octet followed by 0, 1 or more subsequnt octets
			-> length must be greater than or equal to 1 */

	if (length == 0) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_LENGTH);
		return (NOK);
	}

		/*	CONTENT OCTETS : the initial octet shall encode the number
			of unused bits in the final subsequent octet ; it must be
			in range 0 to 7
		*/

	if (**p_p_data > 7) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_UNUSED_BITS_NB);
		return (NOK);
	}

		/*	the subsequent octets shall encode the string of bits commencing
			with bit 8 of first octet and proceeding to the trailing bit
			(bits 8 to 1 of first octet followed by bit 8 to 1 of second
			octet, ...) -> we return the number of subsequent octets in "size"
			field (not counting initial octet) and a pointer to the initial
			octet followed by the string
		*/

	Asn1_type_store_add		= *p_p_data;
	Asn1_type_store_size	= length - 1;

	(*p_p_data)	+= length;
	return (OK);
}

/* ------------------------------------------------------------------------ */

	/* decoding for following primitive encoded types :
				- OCTET STRING,
				- all character string types (NumericString, PrintableString,
				TeletexString, VideotexString, VisibleString, IAString,
				GraphicString, GeneralString),
				- ObjectDescriptor.
	*/

uchar  ber_decode_prim_o_c_string (p_store, p_p_data, p_limit)
	asn1_store_ctx_t FAR	*p_store;			/* pointer to context where to store decoded OCTET STRING value */
	uchar FAR * FAR			*p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR				*p_limit;			/* pointer to limit of data area */
{
	ushort					length;				/* length of CONTENT OCTETS */
	uchar					ret_code;			/* return code */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (NOK);
	}

	if (p_store == P_NIL) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_STORE);
		return (NOK);
	}

	ret_code = ber_decode_length (&length, p_p_data, p_limit);

	switch (ret_code) {

		case BER_DECODE_LGTH_NOK :

				/* an error has occurred during length decoding -> return NOK */

			return (NOK);

		case BER_DECODE_INDEFINITE_LGTH :

			/* the indefinite form shall not be used for primitive encoding
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_PRIM_INDEF_LGTH);
		return (NOK);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + length)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (NOK);
	}

		/*	CONTENT OCTETS : the primitive encoding contains 0, 1 or more
			octets equal in value to the octets in the data, in the order
			they appear in the data value -> return size and string pointer
		*/

	Asn1_type_store_add		= *p_p_data;
	Asn1_type_store_size	= length;
	(*p_p_data)	+= length;
	return (OK);
}

/* ------------------------------------------------------------------------ */

	/* OBJECT IDENTIFIER type decoding */

uchar  ber_decode_object_id (p_store, p_p_data, p_limit)
	asn1_store_ctx_t FAR				*p_store;			/* pointer to context where to store decoded OBJECT IDENTIFIER value */
	uchar FAR * FAR						*p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR							*p_limit;			/* pointer to limit of data area */
{
	ushort								length;				/* length of CONTENT OCTETS */
	ushort								i;					/* loop index */
	uchar								cur_val;			/* current value */
	uchar								start_of_subid;		/* flag indicating if it is the start of current sub-identifier */
	uchar								sub_id_nb;			/* number of encoded sub-identifiers in object identifier */
	struct asn1_obj_id_node CONST FAR	*p_cur_node;		/* pointer to current node in object identifier tree */
	struct asn1_obj_id_node CONST FAR	*p_sav_node;		/* pointer to saved node in object identifier tree */
	ulong								cur_sub_id;			/* current sub-identifier */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (NOK);
	}

	if (p_asn1_obj_id_list == P_NIL) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NO_OBJ_ID_NODE);
		return (NOK);
	}
	 
	if (p_store == P_NIL) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_STORE);
		return (NOK);
	}

	cur_val = ber_decode_length (&length, p_p_data, p_limit);

	switch (cur_val) {

		case BER_DECODE_LGTH_NOK :

				/* an error has occurred during length decoding -> return NOK */

			return (NOK);

		case BER_DECODE_INDEFINITE_LGTH :

			/* the indefinite form shall not be used for primitive encoding
				-> set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_PRIM_INDEF_LGTH);
		return (NOK);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + length)) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (NOK);
	}

	p_limit = (*p_p_data) + length;		/* set p_limit to end of value for next usage */

		/*	CONTENT OCTETS : an ordered list of encoding of sub-identifiers
			concatenated together : there shall be at least one sub-id
			(corresponding to the 2 first components) -> length shall not be 0

			first subidentifier = 40 * first component value + second component value,
			i'th subidentifier = (i +1)'th component value,
			number of subidentifiers = number of components - 1. */

	if (length == 0) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_LENGTH);
		return (NOK);
	}

		/*	Each sub-identifier is represented as a serie of 1 or more octet :
			Bit 8 of the last octet is 0, Bit 8 of each preceding octet is 1.
			Bits 7 to 1 of the octets in the serie collectively encode the
			sub-identifier, the leading octet shall not be 0x80 so that the
			fewest possible octets are used.
		*/

		/* check that the last octet of complete encoding has bit 8
			to 0 and leading octet of each sub-id is not 0x80 */

	cur_val = (*p_p_data)[length - 1];

	if (Get_bits (cur_val, 7, 1) != BER_EXT_BIT_STOP) {

			/* Set error cause and return NOK */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_BAD_LENGTH);
		return (NOK);
	}

	sub_id_nb = 0;
	start_of_subid = ON;

	for (i = 0; i < length; i++) {

		cur_val = (*p_p_data)[i];

		if (start_of_subid == ON) {

			if (cur_val == 0x80) {

					/* Set error cause and return NOK */

				Asn1_set_error_cause	(ASN1_ERR_CAUSE_NOT_MINIMAL);
				return (NOK);
			}

			sub_id_nb++;
		}

		if (Get_bits (cur_val, 7, 1) == BER_EXT_BIT_STOP) {

			start_of_subid = ON;

		} else {

			start_of_subid = OFF;
		}
	}

		/* search for the node corresponding to the root of the tree */

	if ((p_cur_node = Asn1_get_obj_id_node (ASN1_OBJ_ID_ROOT)) == P_NIL) {

		Trap	(TRAP_ASN1_NODE_INCONSISTENCY, "ber_decode_object_id");
		return (NOK);
	}

		/* get first sub-identifier */

	if (ber_decode_obj_sub_id (p_p_data, &cur_sub_id) == NOK) {

		return (NOK);
	}

		/*	Only 3 possible component values from the root : 0, 1, 2 and
			values up to 39 only allowed from nodes reached by 0 and 1,
			which enables the encoding :
			first subidentifier = 40 * first component value + second component value
		*/

	if (cur_sub_id < 40) {

			/* first component = 0; second component = decoded cur_sub_id */

		cur_val = 0;

	} else if (cur_sub_id < 80) {

			/* first component = 1; second component = decoded cur_sub_id - 40 */

		cur_val = 1;

	} else {

			/* first component = 2; second component = decoded cur_sub_id - 80 */

		cur_val = 2;
	}

		/* get second component value */

	cur_sub_id -= (cur_val * 40);

		/* reach first node in tree */

	if ((p_cur_node = Asn1_get_son_node (p_cur_node, cur_val)) == P_NIL) {

			/* value {0, 0} is allowed even if it matches no node in the tree
				-> If so, it corresponds to NIL OBJ ID */

		if ((cur_val != 0) || (cur_sub_id != 0) || (sub_id_nb != 1)) {

				/* Set error cause and return NOK */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_NO_OBJ_ID_NODE);
			return (NOK);
		}

		Asn1_type_store_size	= (ulong)ASN1_OBJ_ID_NIL;
		Asn1_type_store_flag	= 0;
		return (OK);
	}

		/* reach second node in tree */

	if ((p_cur_node = Asn1_get_son_node (p_cur_node, cur_sub_id)) == P_NIL) {

			/* value {0, 0} is allowed even if it matches no node in the tree
				-> If so, it corresponds to NIL OBJ ID */

		if ((cur_val != 0) || (cur_sub_id != 0) || (sub_id_nb != 1)) {

				/* Set error cause and return NOK */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_NO_OBJ_ID_NODE);
			return (NOK);
		}

		Asn1_type_store_size	= (ulong)ASN1_OBJ_ID_NIL;
		Asn1_type_store_flag	= 0;
		return (OK);
	}

	sub_id_nb--;

		/* 	scan the OBJECT IDENTIFIER tree using the list of sub-identifiers :
			they should equal the label of the arcs in the tree from the root
			to a Node that has no son node -> this node is the right one */

	while (sub_id_nb != 0) {

		length = (ushort)((ulong)p_limit - (ulong)(*p_p_data));		/* get number of remaining octets */
		p_sav_node	= p_cur_node;		/* save current node before searching son node */
		p_limit		= *p_p_data;		/* save pointer to data before decoding current component */

		if (ber_decode_obj_sub_id (p_p_data, &cur_sub_id) == NOK) {

			return (NOK);
		}

		if ((p_cur_node = Asn1_get_son_node (p_cur_node, cur_sub_id)) == P_NIL) {

				/*	No son node matches current component in OBJECT IDENTIFIER
					tree from current node -> continue to decode :
						the node to be returned is the current one,
						the coded components that follow are passed into
							storage contexts for appended sub-identifiers.
				*/

			p_cur_node	= p_sav_node;	/* restore current node */
			*p_p_data	= p_limit;		/* restore data pointer to start of current component for it shall be decoded again further */
			p_limit		+= length;		/* restore pointer to end of data */
			break;
		}

		p_limit += length;				/* restore pointer to end of data */
		sub_id_nb--;

		if (Asn1_son_node_nb == ASN1_OBJ_ID_NO_SON_NODE) {

				/* no son node : it is the node corresponding to encoded OBJECT ID */

			break;
		}
	}

		/* store the node in given context : node ID into "size" field and
			number of sub-identifiers that are not decoded yet into
			"coding_flag" : this is the number of appended sub-identifiers */

	Asn1_type_store_size	= (ulong)(Asn1_cur_node_id);
	Asn1_type_store_flag	= sub_id_nb;

	if (sub_id_nb == 0) {

			/* no more data : decoding has completed */

		return (OK);
	}

		/* init storage context that will contain first appended sub-identifier */

	p_store = p_asn1_appended_obj_id;

#	if ASN1_DYNAMIC_APPEND_CTX_USED == ON

			/*	If dynamic mechanism for appended sub-identifiers storage is
				currently used, call the user specific function, that may
				update the "address" field of storage contexts to be used if
				necessary (Node ID + nb of sub-id + pointer to next context
				to be used are passed to the ASN1 user).
			*/

		if (Asn1_dynamic_append_ctx_used == ON) {

			Asn1_user_append_store_ctx (Asn1_cur_node_id, sub_id_nb, p_store);
		}

#	endif

		/*	store the last sub-identifiers (appended) : 1 per context
			or use "address" field if not NIL for octet string */

	while (sub_id_nb-- > 0) {

			/* checks that a storage context exists */

		if (p_store == P_NIL) {

				/* Set error cause and return NOK */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_MANY_SUBID);
			return (NOK);
		}

		if (ber_decode_obj_sub_id (p_p_data, &cur_sub_id) == NOK) {

			return (NOK);
		}

		Asn1_type_store_size	= cur_sub_id;

			/* get next storage context */

		if (p_store -> address != P_NIL) {

			length = (ushort)((ulong)p_limit - (ulong)(*p_p_data));		/* get number of remaining octets */
			p_limit = p_store -> address;

				/* last appended sub-identifiers consist of an octet string :
					inspect "coding_flag" to know how this string is to be processed */

			if (Asn1_type_store_flag == ASN1_FLAG_OBJ_ID_APPEND_STR) {

					/* the string is simply to be copied */

				Memcpy_far ((char FAR *)p_limit, (char FAR *)(*p_p_data), (uchar)length);
				(*p_p_data) += (uchar)(length);
				Asn1_type_store_flag = 0;
				p_store = Asn1_type_next_store;
				break;
			}

				/* each octet of the string is to be processed as a separate sub-identifier : use p_limit as string pointer */

			while (sub_id_nb-- > 0) {

				if (ber_decode_obj_sub_id (p_p_data, &cur_sub_id) == NOK) {

					return (NOK);
				}

				if (cur_sub_id > (uchar)(~0)) {

					Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_HIGH_VAL);
					return (NOK);
				}

				*p_limit++ = (uchar)cur_sub_id;
			}

			Asn1_type_store_flag = 0;
			p_store = Asn1_type_next_store;
			break;
		}

		Asn1_type_store_flag = 0;
		p_store = Asn1_type_next_store;
	}

		/* update global pointer to list of sub-identifiers */

	p_asn1_appended_obj_id = p_store;

	return (OK);
}

/* ------------------------------------------------------------------------ */

	/* decodes an OBJECT IDENTIFIER sub-identifier */

uchar ber_decode_obj_sub_id (p_p_data, p_sub_id)
	uchar FAR * FAR					*p_p_data;				/* pointer to data area pointer (on first octet of current sub-identifier) */
	ulong FAR *						p_sub_id;				/* pointer to sub-identifier to return */
{
	ulong							cur_sub_id;				/* current sub-identifier */

		/* init value of sub-identifier with last octet : Bits 7 to 1 */

	cur_sub_id = (ulong)((**p_p_data) & Mask (7));

		/* process following octets until Bit 8 is set to 0 or overflow */

	while (Get_bits ((**p_p_data), 7, 1) == BER_EXT_BIT_CONTINUE) {

			/* get next octet */

		(*p_p_data)++;

			/* check that value is not too high */

		if (cur_sub_id >= (ulong)0x2000000L) {

				/* Set error cause and return NOK */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_HIGH_VAL);
			return (NOK);
		}

		cur_sub_id = (cur_sub_id * (ulong)128) + (**p_p_data & Mask (7));
	}

		/* set data pointer after the last octet */

	(*p_p_data)++;

	*p_sub_id = cur_sub_id;
	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_compare_length - implements the comparaison of the
					LENGTH OCTETS field of a BER encoded data with a given
					length or with data if length is of indefinite form.

Usage            	uchar ber_compare_length (ulong length, uchar FAR *p_length, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- length : length to be compared,
						- p_length : pointer to LENGTH OCTETS field,
						- p_p_data : pointer to pointer after the content octets that have already been decoded,
						- p_limit : pointer to data area limit.

Return value :		OK if given length equals the one in the LENGTH OCTETS field
					or if the field specifies indefinite form and the data pointer
					points to end-of_content octets, NOK else.

Common constants and declarations : asn1_ber.h.

*--------------------------------------------------------------------------*/

extern ulong				asn1_tab_length [ASN1_MX_IMBRICATION_LEVEL];	/* current length */
extern uchar				asn1_imbric_level;								/* current imbrication level */

#define Current_length		asn1_tab_length[asn1_imbric_level]

uchar ber_compare_length (length, p_length, p_p_data, p_limit)
	ulong			length;				/* length to be compared */
	uchar FAR 		*p_length;			/* pointer to length to be returned */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer */
	uchar FAR		*p_limit;			/* pointer to data area limit */
{
	ushort	data_length;				/* length contained in data field */
	uchar	i;							/* loop index */

		/* try and decode LENGTH OCTETS FIELD */

	switch (ber_decode_length (&data_length, &p_length, p_limit)) {

		case BER_DECODE_INDEFINITE_LGTH :

			break;

		case BER_DECODE_LGTH_NOK :

				/* an error occurred -> return NOK */

			return (NOK);

		default :

				/* length is decoded and contained in data_length -> compare with given length */

			if ((ulong)data_length == length) {

				return (OK);
			}

			return (NOK);
	}

		/* length is of indefinite form -> check if data pointer
			indicates end of content */

	if (((*p_p_data) + BER_END_OF_CONTENT_SIZE) > p_limit) {

		return (NOK);
	}

	for (i = 0; i < BER_END_OF_CONTENT_SIZE; i++) {

		if (((*p_p_data)[i]) != BER_END_OF_CONTENT_OCTET) {

			return (NOK);
		}
	}

		/* data pointer indicates end-of-content -> update data pointer and return OK */

	(*p_p_data) += BER_END_OF_CONTENT_SIZE;
	Current_length += BER_END_OF_CONTENT_SIZE;	/* current length shall take into account the END-OF-CONTENT octets */

	return (OK);
}

#if ASN1_ANY_TYPE_USED == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	uchar ber_skip_type_id - implements the skipping of the
					IDENTIFIER OCTETS field of a BER encoded type without
					any interpretation of this field (usually, this field
					will be 1 octet long but it may be longer for
					tag numbers greater than or equal to 31).

Usage            	uchar ber_skip_type_id (uchar FAR * FAR *p_p_data);
						- p_p_data : pointer to pointer after the content octets that have already been decoded,
						- p_limit : pointer to data area limit.

Return value :		OK if IDENTIFIER OCTETS field does not exceed limit of data area,
					NOK else.

Common constants and declarations : asn1_ber.h.

*--------------------------------------------------------------------------*/

uchar ber_skip_type_id (p_p_data, p_limit)
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer */
	uchar FAR		*p_limit;			/* pointer to data area limit */
{

	if (Get_bits ((**p_p_data), 0, 5) < BER_TAG_NB_EXTENDED) {

			/* encoded tag number is in range 0 to 30 : 1 octet is used for IDENTIFIER OCTETS field */

		(*p_p_data)++;
		return (OK);
	}

			/* encoded tag number >= 31 : IDENTIFIER OCTETS field consists of 1 leading octet followed by 1 or more subsequent octets */

	(*p_p_data)++;		/* skip leading octet */

    	/* skip subsequent octets until Bit 8 indicates "last octet" */

	while (Get_bits ((**p_p_data), 7, 1) == BER_EXT_BIT_CONTINUE) {

		if ((*p_p_data) >= p_limit) {

        	return (NOK);
		}

		(*p_p_data)++;
	}

	(*p_p_data)++;		/* skip last octet of IDENTIFIER OCTETS field */
	return (OK);
}

#endif


/* EOF */
