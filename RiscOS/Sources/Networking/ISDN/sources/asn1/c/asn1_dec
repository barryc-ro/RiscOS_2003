
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - asn1_dec.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function (s)
 *
 *		asn1_decoding_start - 		implements the decoding of an ASN1 type
 *									described with a metaprogram and other
 *									possible imbricated meta-programs : This
 *									is the main ASN1 decoding function.
 *
 *		asn1_decode_basic_type -	implements the decoding of an ASN1
 *									basic type, i.e. described with a
 *									metaprogram that has no "type field"
 *									(no reference to another ASN1 type).
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    ASN1 language notation encoding/decoding library |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "asn1.h"

#if REVISION_STRING == ON
#	include "rev.asn1"
#endif

		/* Copyright */

CONST char 	asn1_dec_copyright[]	= "Copyright (c) 1989/96 by OMNITEL SA - All Rights Reserved";
CONST char 	asn1_dec_licence[]		= LICENSE_NBER;

/*-------------------------------------------------------------------------*/

		/* Common ASN1 variables */
		/* --------------------- */

			/* Tables used to store specific parameters useful to analyse a type :
				for each parameter, one entry is required for each possible
				type imbrication level */

extern ulong				asn1_tab_length			[ASN1_MX_IMBRICATION_LEVEL];	/* current length */
extern uchar	FAR			*asn1_tab_p_length_field[ASN1_MX_IMBRICATION_LEVEL];	/* pointer to current length data area */
extern uchar	FAR			*asn1_tab_p_pc			[ASN1_MX_IMBRICATION_LEVEL];	/* pointer to type description meta-program */
extern uchar				asn1_tab_field_nb		[ASN1_MX_IMBRICATION_LEVEL];	/* current number of type fields already processed in a meta-program */

extern uchar				asn1_imbric_level;										/* current imbrication level */

			/* access macros to Tables */

#define 	Imbricated_length(xx)		asn1_tab_length[xx]
#define 	Imbricated_p_length(xx)		asn1_tab_p_length_field[xx]
#define 	Imbricated_p_pc(xx)			asn1_tab_p_pc[xx]
#define 	Imbricated_field_nb(xx)		asn1_tab_field_nb[xx]

#define 	Current_length				Imbricated_length		(asn1_imbric_level)
#define 	Current_p_length			Imbricated_p_length		(asn1_imbric_level)
#define 	Current_p_pc				Imbricated_p_pc			(asn1_imbric_level)
#define 	Current_field_nb			Imbricated_field_nb		(asn1_imbric_level)

#define 	Lowest_p_pc					Imbricated_p_pc			(0)

#define 	Lower_p_pc					Imbricated_p_pc			(asn1_imbric_level - 1)
#define 	Lower_field_nb				Imbricated_field_nb		(asn1_imbric_level - 1)
#define 	Lower_length				Imbricated_length		(asn1_imbric_level - 1)

#if ASN1_OPTIONAL_USED == ON
	extern uchar FAR	*p_asn1_optional_ind;		/* pointer to list of optional indicators associated with current type */
#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	asn1_decoding_start - implements the decoding of an
					ASN1 type described with a metaprogram and other
					possible imbricated meta-programs.

Usage            	ulong asn1_decoding_start (uchar FAR *p_pc, uchar FAR * FAR *p_p_data, uchar FAR *p_limit, uchar store_nb, asn1_store_t FAR *p_store_list);
						- p_pc : address of the meta-language program describing instructions to be executed,
						- p_p_data : pointer to pointer where to read data to be decoded,
						- p_limit : pointer to data area limit,
						- store_nb : number of meta-program storage descriptions in list,
						- p_store_list : pointer to list of meta-program storage descriptions.

Description			the function scans the metaprograms describing each type
					included in the ASN1 type to be decoded and decode each
					type in the order they appear in a (Type Length Value)
					model (specified by an encoding rules recommendation,
					currently only 1 : the Basic Encoding Rules). The resulting
					decoded value are put in the storage contexts given with
					*p_store_list pointer and p_next pointer of the contexts.
					Each time a new meta-program is to be analysed (corresponding
					to a "type field" in current meta-program), the imbrication
					level is increased. The first level is 0, corresponding to
					the first analysed meta-program that pertains to the type to be decoded.

Return value :		the total length of decoded data or 0 if a problem occurs.

Common constants and declarations : asn1.h, asn1_int.h, asn1_ber.h.

*--------------------------------------------------------------------------*/

ulong  asn1_decoding_start (p_pc, p_p_data, p_limit, store_nb, p_store_list)
	uchar FAR			*p_pc;				/* meta-language program counter */
	uchar FAR * FAR 	*p_p_data;			/* pointer to data area pointer : on first octet where to read the encoded data */
	uchar FAR			*p_limit;			/* pointer to data area limit */
	uchar				store_nb;			/* number of meta-program storage descriptions in list */
	asn1_store_t FAR	*p_store_list;		/* pointer to list of meta-program storage descriptions */
{

	ulong							length = 0;				/* length to be returned = total data length */
	ulong							get_length;				/* variable used to get current length returned by a function */
	struct asn1_type_common	FAR		*p_type_desc;			/* pointer to common fields used in a type description meta-program */
	struct asn1_address_size FAR 	*p_store = P_NIL;		/* pointer to structure describing address and size of value */
	uchar							list_x;					/* current index in list of storage contexts */
	uchar							analyses_nb;			/* number of type analyses to be done */
	uchar							analyse_field_nb;		/* number of the current type field to be analysed */

	if ((p_type_desc = (struct asn1_type_common FAR *)p_pc) == P_NIL) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_START, P_NIL, p_pc);
		return (0);
	};

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_START_P_DATA, P_NIL, p_pc);
		return (0);
	}

	if ((p_limit == P_NIL) || (p_limit <= *p_p_data)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_START_P_LIM, p_limit, p_pc);
		return (0);
	}

	if ((p_store_list == P_NIL) || (store_nb == 0)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_NO_STORE_CTX, (uchar FAR *)p_store_list, p_pc);
		return (0);
	};

		/* init common variables */

	asn1_init ();

		/* init program counter of lowest level */

	Lowest_p_pc			= p_pc;

	while (TRUE) {

			/* The decoding is made according to a (Type Length Value) model
				-> decode the current TYPE IDENTIFICATION octets */

		if ((get_length = Asn1_decode_type_ident (p_p_data, p_limit,
												  Asn1_type_id,
												  Asn1_type_impl_flag,
												  Asn1_type_tag_class,
												  Asn1_type_tag_nb,
												  Asn1_type_p_tag_nb)) != 0)
		{

			if (get_length == ASN1_ERR_TYPE_IDENT_LGTH) {

					/* decoded type identification does not match the one in meta-program */

				Asn1_set_error	(ASN1_ERR_DECOD_TYPE_IDENT, (uchar FAR *)&length, Current_p_pc);
				return (0);
			}

				/* *p_p_data now points to the first octet of length field */

			Current_length = 0;
			length += get_length;
			Current_p_length = *p_p_data;

				/* if a lower level exists, the corresponding length
					shall take into account the length of the "type
					identification" field of the imbricated type */

			if (asn1_imbric_level != 0) {

				Lower_length += get_length;
			}
		}

			/*
				*p_p_data now points to the first octet of length field
				(if type identification has been decoded above)
				-> decode the value, there are 2 cases :

					1) the current type is a basic type (no field in type
					description meta-program), decode the length + value
					with a basic decoding specific function;

					2) the current type has one or more field(s) -> get
					the first one, increase the imbrication level and
					continue to process in this function.
			*/

		if (Asn1_type_field_nb == 0) {

				/* BASIC TYPE */

			if (p_store == P_NIL) {

					/* if pointer to storage context is null, search in the list
						for a context associated with current basic type */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) != ASN1_INDEX_NIL) {

						/* a context is found : update pointer */

					Asn1_get_p_store (list_x);
				}
			}

			if ((get_length = asn1_decode_basic_type (p_store, p_p_data, p_limit)) == 0) {

					/* an error has occurred during basic decoding */

				return (0);
			}

				/* decoding of basic type is achieved : reinit storage
					pointer to prevent mis-use for next type decoding */

			p_store = P_NIL;

				/* basic type is decoded :
					1) increment total length and store current length,
					2) if it is not the lowest imbrication level
						increment length of lower level,
					3) search for next type to be decoded : decrease
						level until next field not yet analysed is found
						or until the lowest level is reached.

					4) if no next field found and lowest level is reached,
						decoding is completed successfully ->
						return total length. */

			length += get_length;
			Current_length = get_length;

			if (asn1_imbric_level == 0) {

				/* the type to be decoded is simply a basic type :
					decoding has completed -> return length */

				return (length);
			}

			while (asn1_imbric_level != 0) {

					/* A lower level exists, the corresponding length
						shall take into account the length of the
						value decoding of the imbricated type */

				Lower_length += Current_length;

				label_decrease_level_loop :

					/* decrease imbrication level */

				asn1_imbric_level--;

					/* update pointer to common fields of lower meta-program */

				if ((Asn1_get_p_type_desc) == P_NIL) {

						/* Set error context and return 0 */

					Asn1_set_error_and_cause	(ASN1_ERR_DECOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_DEC_LEVEL);
					return (0);
				}

					/* one more type field analysed (the one corresponding
						to the imbricated type which has just been decoded) */

				Current_field_nb++;

					/*
					  1) If the current type is a SEQUENCE or a SET, we
						have to decode each type matching a field in the
						meta-program -> the number of types to be analysed
						is the value of "field_nb" in meta-program, the
						current field to be analysed is Current_field_nb.

					  2) If the current type is a SEQUENCE OF or a SET OF,
						we have to process n decodings of the type specified
						in the meta-program -> the number n is passed onto
						the ASN1 user with the field "store_size" in the
						corresponding storage context, the Current_field_nb
						Macro represents here the current number of times the
						type has already been decoded and the current field
						to be analysed is the only one in the meta-program (nb = 0).

					  3) If 1) and 2) do not apply, the current type
						description use another type description (not basic)
						but should have only one field, the type to
						which it refers and is to be analysed only once.
					*/

				switch (Asn1_type_id) {

					case ASN1_SEQUENCE_TYPE_ID :
					case ASN1_SET_TYPE_ID :

						analyses_nb = Asn1_type_field_nb;
						analyse_field_nb = Current_field_nb;

#						if ASN1_OPTIONAL_USED == ON

						/*	compare the length of data in SET or SEQUENCE type that have
							already been decoded and the length of the type in data :
							if they are equal, type decoding is over -> check that all
							other fields are optional and mark them 'Absent' */

							if (Asn1_compare_length (Current_length, Current_p_length, p_p_data, p_limit) == OK) {

								while (analyse_field_nb < analyses_nb) {

										/* get list of optional indicators associated with type */

									p_asn1_optional_ind = Asn1_type_opt_ind_list (analyse_field_nb);

									if (p_asn1_optional_ind == P_NIL) {	/* type is mandatory -> set error */

										Asn1_set_error	(ASN1_ERR_DECOD_MISSING_TYPES, &analyse_field_nb, Current_p_pc);
										return (0);
									}

									asn1_set_optional_value (ABSENT);	/* Mark field absent */
									analyse_field_nb++;
								}
							}

						/*	Scan the type fields in meta-program :

							if type is mandatory, it shall be processed -> stop scanning

							else compare data with type identification :
								if comparaison is OK, the type is encoded in data -> stop scanning
								else the optional type is not encoded -> next field
						*/

							while (analyse_field_nb < analyses_nb) {

									/* get list of optional indicators associated with type */

								p_asn1_optional_ind = Asn1_type_opt_ind_list (analyse_field_nb);

								if (p_asn1_optional_ind == P_NIL) {

									/* type is mandatory -> process it */

									break;
								}

									/* get meta-program pointer */

								if ((p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

										/* type is not basic but a nil meta-program pointer
											(type field in meta_program description) was specified */

									Trap (TRAP_ASN1_NIL_PC, "asn1_decoding_start");
									return (0);
								}

									/* compare data with type identification of current field */

								if (Asn1_compare_type_ident (*p_p_data, p_limit, p_pc) == OK) {

										/* comparaison is OK : the type field is to be processed
											-> Mark it present and stop scanning */

									asn1_set_optional_value (PRESENT);
									break;
								}

								/* comparaison is NOK : the type field is not
									to be processed -> Mark it absent and continue to scan */

								asn1_set_optional_value (ABSENT);
								analyse_field_nb++;
							}

								/* update current field Nb */

							Current_field_nb = analyse_field_nb;

#						endif /* ASN1_OPTIONAL_USED == ON */

						break;

					case ASN1_SEQUENCEOF_TYPE_ID :
					case ASN1_SETOF_TYPE_ID :

						analyse_field_nb = 0;

							/*	compare the length of data in SET OF or SEQUENCE OF
								type that have already been decoded and the length
								of the type in data : if they are equal, type
								decoding is over, else continue to process */

						if (Asn1_compare_length (Current_length, Current_p_length, p_p_data, p_limit) == OK) {

								/* reset analyse_nb to stop process of current type */

							analyses_nb = 0;

						} else {

								/* set analyse_nb to 255 to continue process of current type */

							analyses_nb = 255;
						}

						break;

					default :

							/*	the imbricated type has been decoded : end of type should be
								reached -> compare the length of data that have already been
								decoded and the encoded length of the type in data */

						if (Current_p_length != P_NIL) {

							if (Asn1_compare_length (Current_length, Current_p_length, p_p_data, p_limit) == NOK) {

								Asn1_set_error (ASN1_ERR_DECOD_IMBRIC_LGTH, (uchar FAR *)&Current_length, Current_p_pc);
								return (0);
							}
                        }

						analyses_nb = 1;
						break;
				}

				if (Current_field_nb < analyses_nb) {

						/* there are analyses left to be processed
							-> increase level and get matching meta-program
								pointer */

					asn1_imbric_level++;

					if ((Current_p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

							/* type is not basic but a nil meta-program pointer
								(type field in meta_program description) was specified */

						Trap (TRAP_ASN1_NIL_PC, "asn1_decoding_start");
						return (0);
					}

						/* init current level variable */

					Current_p_length	= P_NIL;
					Current_field_nb	= 0;
					Current_length		= 0;

						/* update pointer to common fields of current meta-program */

					if ((Asn1_get_p_type_desc) == P_NIL) {

							/* Set error context and return 0 */

						Asn1_set_error_and_cause	(ASN1_ERR_DECOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_INC_LEVEL);
						return (0);
					}

						/* search in the list for a context associated
							with field of current lower level meta-program
							corresponding to current type (this type in included
							in a SET or SEQUENCE or SET OF or SEQUENCE OF type) */

					if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Lower_p_pc, (analyse_field_nb + 1))) != ASN1_INDEX_NIL) {

							/* a context is found -> update storage pointer */

						Asn1_get_p_store (list_x);

					} else {

						p_store = P_NIL;
					}

						/* analyse of this meta-program */

					break;

				} else {

					/* 	All the fields of the current meta-program have been
						analysed, current level is processed : if it is
							the lowest level, decoding has completed
							-> return length
							else continue to process at lower level.

							In all cases, set the coding flag to
							indicate that current value is decoded
					*/

						/* search in the list for a context associated
							with current decoded type */

					if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) != ASN1_INDEX_NIL) {

							/* a context is found -> update storage pointer */

						Asn1_get_p_store (list_x);
					}

						/* get the current valid storage information context :
							more than one may exist if this type is itself
							contained in a list (SET OF or SEQUENCE OF) */

					while (p_store != (struct asn1_address_size FAR *)P_NIL) {

						if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

								/* This is the right context : stop scanning */

							break;
						}

							/* get next storage context */

						p_store = Asn1_type_next_store;
					}

					if (p_store != (struct asn1_address_size FAR *)P_NIL) {

							/* a context is found : set decoding flag */

						Asn1_type_store_flag = ASN1_DECODED_VALUE;

							/* store the number "n" of decoded contained types
								if current type is a list (SET OF or SEQUENCE OF) */

						if ((Asn1_type_id == ASN1_SEQUENCEOF_TYPE_ID) ||
							(Asn1_type_id == ASN1_SETOF_TYPE_ID)) {

							Asn1_type_store_size = (ulong)Current_field_nb;
						}
					}

						/* reinit storage pointer to prevent mis-use for next type analyse */

					p_store = P_NIL;

					if (asn1_imbric_level == 0) {

						return (length);
					}

					continue;
				}

			} /* end of "while (asn1_imbric_level != 0)" */

				/* analyse of next meta-program */

			continue;

		} else {

				/* NOT BASIC TYPE */

			/* initialize number of fields processed */

			analyse_field_nb = 0;

			if (get_length != 0) {

					/* Type identification has been decoded : *p_p_data now
						points to the first octet of length field set pointer
						to length of current level */

				Current_p_length = *p_p_data;

					/* check that data area pointer does not exceed p_limit */

				if (*p_p_data > p_limit) {

					Asn1_set_error_and_cause	(ASN1_ERR_DECOD_DATA_TOO_BIG, (uchar FAR *)&length, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
					return (0);
				}

					/* skip the length field to process next type */

				Asn1_decode_length	((ushort FAR *)&get_length, p_p_data, p_limit);

					/*	The total length and, if a lower level exists,
						the corresponding length shall take into account
						the length of the "length" field of the imbricated type */

				analyses_nb = (uchar)(*p_p_data - Current_p_length);
				length += analyses_nb;

				if (asn1_imbric_level != 0) {

					Lower_length += analyses_nb;
				}

					/*	check that it is not the end of the data (null length or END-OF-OCTETS)
						if so, this type is not to be processed -> store number
						of items (= 0) if type is a list (SET OF/SEQUENCE OF)
						and continue to process above (in loop "while (level != 0)") */

				if (Asn1_compare_length (0, Current_p_length, p_p_data, p_limit) == OK) {

						/* search in the list for a context associated with current type */

					if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) != ASN1_INDEX_NIL) {

							/* a context is found -> update storage pointer */

						Asn1_get_p_store (list_x);
					}

						/* get the current valid storage information context :
							more than one may exist if this type is itself
							contained in a list (SET OF or SEQUENCE OF) */

					while (p_store != (struct asn1_address_size FAR *)P_NIL) {

						if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

								/* This is the right context : stop scanning */

							break;
						}

							/* get next storage context */

						p_store = Asn1_type_next_store;
					}

					if (p_store != (struct asn1_address_size FAR *)P_NIL) {

							/* a context is found : set decoding flag */

						Asn1_type_store_flag = ASN1_DECODED_VALUE;

							/* store the number "n" of decoded contained types
								if current type is a list (SET OF or SEQUENCE OF) */

						if ((Asn1_type_id == ASN1_SEQUENCEOF_TYPE_ID) ||
							(Asn1_type_id == ASN1_SETOF_TYPE_ID)) {

							Asn1_type_store_size = (ulong)0;
						}
					}

						/* reinit storage pointer to prevent mis-use for next type analyse */

					p_store = P_NIL;

					if (asn1_imbric_level == 0) {

						return (length);
					}

					goto label_decrease_level_loop;
				}

#				if ASN1_OPTIONAL_USED == ON

					if ((Asn1_type_id == ASN1_SEQUENCE_TYPE_ID) ||
						(Asn1_type_id == ASN1_SET_TYPE_ID)) {

						analyses_nb = Asn1_type_field_nb;

						/*	Scan the type fields in meta-program :

							if type is mandatory, it shall be processed -> stop scanning

							else compare data with type identification :
								if comparaison is OK, the type is encoded in data -> stop scanning
								else the optional type is not encoded -> next field
						*/

						while (analyse_field_nb < analyses_nb) {

								/* get list of optional indicators associated with type */

							p_asn1_optional_ind = Asn1_type_opt_ind_list (analyse_field_nb);

							if (p_asn1_optional_ind == P_NIL) {

								/* type is mandatory -> process it */

								break;
							}

								/* get meta-program pointer */

							if ((p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

									/* type is not basic but a nil meta-program pointer
										(type field in meta_program description) was specified */

								Trap (TRAP_ASN1_NIL_PC, "asn1_decoding_start");
								return (0);
							}

								/* compare data with type identification of current field */

							if (Asn1_compare_type_ident (*p_p_data, p_limit, p_pc) == OK) {

									/* comparaison is OK : the type field is to be processed
										-> Mark it present and stop scanning */

								asn1_set_optional_value (PRESENT);
								break;
							}

							/* comparaison is NOK : the type field is not
								to be processed -> Mark it absent and continue to scan */

							asn1_set_optional_value (ABSENT);
							analyse_field_nb++;
						}

						if (analyse_field_nb == analyses_nb) {

							/*	All the fields are optional and decoded type identification
								does not match any one in SET/SEQUENCE meta-program
								but it is not the end of SET or SEQUENCE -> error
							*/

							Asn1_set_error	(ASN1_ERR_DECOD_TYPE_IDENT, (uchar FAR *)&length, Current_p_pc);
							return (0);
						}
					}

#				endif /* ASN1_OPTIONAL_USED == ON */

			} else {

					/*	Type identification has not been decoded : we reset
						the current length pointer to avoid a further mis-use.
						The following decoding shall start with the type
						identification of next type to be analysed at upper level.
					*/

				Current_p_length = P_NIL;
			}

			if (Asn1_type_id == ASN1_CHOICE_TYPE_ID) {

				/*
					Current type is a CHOICE type : its decoding is the one of
					chosen type among the type fields described in the meta-program,
					no additional imbrication is required.
				*/

					/*	scan all the fields and compare the type
						identification of current field with data in order
						to determine which type field is encoded */

				analyses_nb = Asn1_type_field_nb;

				for (analyse_field_nb = 0; analyse_field_nb < analyses_nb; analyse_field_nb++) {

						/* get meta-program pointer */

					if ((p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

							/* type is not basic but a nil meta-program pointer
								(type field in meta_program description) was specified */

						Trap (TRAP_ASN1_NIL_PC, "asn1_decoding_start");
						return (0);
					}

						/* compare data with type identification of current field */

					if (Asn1_compare_type_ident (*p_p_data, p_limit, p_pc) == OK) {

							/* comparaison is OK : this is the right type field */

						break;
					}
				}

				if (analyse_field_nb == analyses_nb) {

						/* decoded type identification does not match any one in CHOICE meta-program */

					Asn1_set_error	(ASN1_ERR_DECOD_TYPE_IDENT, (uchar FAR *)&length, Current_p_pc);
					return (0);
				}

					/* search in the list for a context associated
						with current CHOICE type */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, 0)) == ASN1_INDEX_NIL) {

						/* No context found where to put index value
							-> set error context and return 0 */

					Asn1_set_error	(ASN1_ERR_DECOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
					return (0);
				}

					/* a context is found : update pointer */

				Asn1_get_p_store (list_x);

					/* get the current valid storage information context :
						more than one may exist if this type is itself
						contained in a list (SET OF or SEQUENCE OF) */

				while (p_store != (struct asn1_address_size FAR *)P_NIL) {

					if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

							/* This is the right context : stop scanning */

						break;
					}

						/* get next storage context */

					p_store = Asn1_type_next_store;
				}

				if (p_store == (struct asn1_address_size FAR *)P_NIL) {

						/* No context found : set error context and return 0 */

					Asn1_set_error	(ASN1_ERR_DECOD_NO_STORE_CTX, &asn1_imbric_level, Current_p_pc);
					return (0);
				}

					/* put the field number (index in CHOICE) of the encoded
						type into the "size" field of current storage context */

				Asn1_type_store_size = (ulong)analyse_field_nb;

					/* set the coding flag so that the storage context is
						not used twice : it cannot be set after this point
						because for a CHOICE type, imbrication level is not
						incremented -> so we set it now though decoding is
						not yet processed */

				Asn1_type_store_flag = ASN1_DECODED_VALUE;

					/* search in the list if a storage context is associated
						with the current field of the CHOICE type, corresponding
						to the next type to be analysed */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, (analyse_field_nb + 1))) != ASN1_INDEX_NIL) {

						/* a context is found -> update storage pointer */

					Asn1_get_p_store (list_x);

				} else {

					p_store = P_NIL;
				}

					/* update current pointer to meta-program matching type field in CHOICE */

				Current_p_pc = p_pc;

					/* update pointer to common field of current meta-program
						and reset field number of current level */

				if ((Asn1_get_p_type_desc) == P_NIL) {

						/* Set error context and return 0 */

					Asn1_set_error_and_cause	(ASN1_ERR_DECOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
					return (0);
				}

				Current_field_nb = 0;

					/* analyse of this meta-program */

				continue;
			}

			if (p_store == P_NIL) {

					/* search in the list if a storage context is associated
						with the current field of the type, corresponding
						to the next type to be analysed */

				if ((list_x = asn1_search_store_ctx (p_store_list, &store_nb, Current_p_pc, (analyse_field_nb + 1))) != ASN1_INDEX_NIL) {

						/* a context is found -> update storage pointer */

					Asn1_get_p_store (list_x);

				} else {

					p_store = P_NIL;
				}
			}

				/* increase imbrication level */

			if ((asn1_imbric_level + 1) >= ASN1_MX_IMBRICATION_LEVEL) {

					/* too many imbrication levels : should never happen */

				Trap (TRAP_ASN1_IMBRICATION, "asn1_decoding_start");
				return (0);
			}

				/* init number of fields that have already been analysed
					in current level and increase level */

			Current_field_nb = analyse_field_nb;
			asn1_imbric_level++;

			if ((p_pc = Asn1_type_p_pc	(analyse_field_nb)) == P_NIL) {

					/* type is not basic but a nil meta-program pointer
						(type field in meta_program description) was specified */

				Trap (TRAP_ASN1_NIL_PC, "asn1_decoding_start");
				return (0);
			}

				/* update current level meta-program pointer and init current level variable */

			Current_p_pc 		= p_pc;
			Current_p_length	= P_NIL;
			Current_field_nb	= 0;
			Current_length		= 0;

				/* update pointer to common field of current meta-program */

			if ((Asn1_get_p_type_desc) == P_NIL) {

					/* Set error context and return 0 */

				Asn1_set_error_and_cause	(ASN1_ERR_DECOD_NIL_TYPE_DESC, &asn1_imbric_level, Current_p_pc, ASN1_ERR_CAUSE_NOT_BASIC);
				return (0);
			}

				/* analyse of this meta-program */

			continue;
		}
	}
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	asn1_decode_basic_type - implements the decoding of an
					ASN1 basic type, i.e. described with a metaprogram that
					has no "type field" (no reference to another ASN1 type).

Usage            	ulong asn1_decode_basic_type (asn1_store_ctx_t FAR *p_store, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- p_store : pointer to storage context structure,
						- p_p_data : pointer to pointer where to read encoded data,
						- p_limit : pointer to data area limit.

Description			the function reads the metaprogram describing the ASN1
					basic type and decodes it in a (Type Length Value)
					model (specified by an encoding rules recommendation,
					currently only 1 : the Basic Encoding Rules).
					The type is identified with the Type ID and the matching
					type specific decoding function is called in order to
					decode the length and the value.
					The resulting decoded value is passed onto the user
					with the storage context pointed to by p_store pointer.

Return value :		the total length of decoded data or 0 if a problem occurs.

Common constants and declarations : asn1.h, asn1_int.h, asn1_ber.h.

*--------------------------------------------------------------------------*/

ulong  asn1_decode_basic_type (p_store, p_p_data, p_limit)
	asn1_store_ctx_t FAR		*p_store;			/* pointer to address structure for value to be decoded */
	uchar FAR * FAR 			*p_p_data;			/* pointer to data area pointer : on first octet where to read the encoded data */
	uchar FAR					*p_limit;			/* pointer to data area limit */
{

	uchar FAR						*p_first_data;		/* pointer to first data */
	struct asn1_type_common	FAR		*p_type_desc; 		/* pointer to common fields used in description meta-program */
    ushort							construct_length;	/* length of constructed type if any */
#	if ASN1_ANY_TYPE_USED == ON
    	uchar						indef_level;		/* level of imbricated types with indefinite lengths */
#	endif

	if ((Asn1_get_p_type_desc) == P_NIL) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_BASIC_START, P_NIL, Current_p_pc);
		return (0);
	};

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_BASIC_P_DATA, P_NIL, Current_p_pc);
		return (0);
	}

	if ((p_limit == P_NIL) || (p_limit <= *p_p_data)) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_BASIC_P_LIM, p_limit, Current_p_pc);
		return (0);
	}

		/* get the current valid storage information context :
			more than one may exist if this type is itself
			contained in a list (SET OF or SEQUENCE OF) */

	while (p_store != (asn1_store_ctx_t FAR *)P_NIL) {

			/* 	the valid context is determined according to the "coding flag" field */

		if (Asn1_type_store_flag == ASN1_NO_CODING_DONE) {

				/* This is the right context : stop scanning */

			break;
		}

			/* get next storage context */

		p_store = Asn1_type_next_store;
	}

	if ((p_store == (asn1_store_ctx_t FAR *)P_NIL) && (Asn1_type_id != ASN1_NULL_TYPE_ID)) {

			/* No context found and it is not a NULL type :
				set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_BASIC_P_STORE, P_NIL, Current_p_pc);
		return (0);
	}

	if (Asn1_type_field_nb != 0) {

			/* Set error context and return 0 */

		Asn1_set_error	(ASN1_ERR_DECOD_NOT_BASIC, P_NIL, Current_p_pc);
		return (0);
	}

		/* init pointer to first octet data */

	p_first_data = *p_p_data;

		/*	test constructed_flag : if current type identification indicated "constructed"
			(possible even for basic type if explicit tagging was used or if type coding may
			be primitive OR construted as for OCTET STRING), content is "Type Length Value"
			-> decode current length (of constructed type) and Type and process value if
			decoding is compatible with type */

	if ((asn1_constructed_flag == ON)
#	if ASN1_ANY_TYPE_USED == ON
		&& (Asn1_type_id != ASN1_ANY_TYPE_ID)
#	endif 
	) {

			/* skip the length of constructed type */

		Asn1_decode_length	(&construct_length, p_p_data, p_limit);

			/* decode imbricated type using type identification without the Tag (Tag has just been decoded and checked, it shall not be repeated) */

		switch (Asn1_decode_type_ident (p_p_data, p_limit, Asn1_type_id, 0, ASN1_TYPE_NO_TAG, 0, Asn1_type_p_tag_nb)) {

			case 0 :		/* type identification requires furher analyse to check tag : it should not happen at this point */
			case ASN1_ERR_TYPE_IDENT_LGTH :		/* decoded type identification does not match the one in meta-program */

				Asn1_set_error	(ASN1_ERR_DECOD_TYPE_IDENT, *p_p_data, Current_p_pc);
				return (0);

			default :

				break;
		}
	}

	switch (Asn1_type_id) {

		case ASN1_BOOLEAN_TYPE_ID :

			if (Asn1_decode_boolean (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_BOOLEAN, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;

		case ASN1_INTEGER_TYPE_ID :

				/* "flag" field in storage context is used to provide the sign */

			if (Asn1_decode_integer (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_INTEGER, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			return ((ulong)((*p_p_data) - p_first_data));

		case ASN1_ENUMERATED_TYPE_ID :

			if (Asn1_decode_enumerated (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_ENUMERATED, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			return ((ulong)((*p_p_data) - p_first_data));

#		if ASN1_BIT_STRING_TYPE_USED == ON	/* BIT STRING Type is used */
		case ASN1_BITSTRING_TYPE_ID :

			if (Asn1_decode_bit_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_BITSTRING, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

		case ASN1_OCTETSTRING_TYPE_ID :

			if (Asn1_decode_octet_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_OCTETSTRING, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;

#		if ASN1_NUMERIC_S_TYPE_USED == ON	/* NumericString Type is used */
		case ASN1_NUMERICSTRING_TYPE_ID :

			if (Asn1_decode_numeric_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_NUMERICSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_PRINTABLE_S_TYPE_USED == ON	/* PrintableString Type is used */
		case ASN1_PRINTABLESTRING_TYPE_ID :

			if (Asn1_decode_printable_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_PRINTABLESTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_TELETEX_S_TYPE_USED == ON	/* TeletexString Type is used */
		case ASN1_TELETEXSTRING_TYPE_ID :

			if (Asn1_decode_teletex_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_TELETEXSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_VIDEOTEX_S_TYPE_USED == ON	/* VideotexString Type is used */
		case ASN1_VIDEOTEXSTRING_TYPE_ID :

			if (Asn1_decode_videotex_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_VIDEOTEXSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_IA5_S_TYPE_USED == ON	/* IA5String Type is used */
		case ASN1_IA5STRING_TYPE_ID :

			if (Asn1_decode_IA5_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_IA5STR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_GRAPHIC_S_TYPE_USED == ON	/* GraphicString Type is used */
		case ASN1_GRAPHICSTRING_TYPE_ID :

			if (Asn1_decode_graphic_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_GRAPHICSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_VISIBLE_S_TYPE_USED == ON	/* VisibleString Type is used */
		case ASN1_VISIBLESTRING_TYPE_ID :

			if (Asn1_decode_visible_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_VISIBLESTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

#		if ASN1_GENERAL_S_TYPE_USED == ON	/* GeneralString Type is used */
		case ASN1_GENERALSTRING_TYPE_ID :

			if (Asn1_decode_general_string (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_GENERALSTR, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif

		case ASN1_NULL_TYPE_ID :

			if (Asn1_decode_null(p_p_data, p_limit) == NOK) {

					/* Set error context and return 0 */

				Asn1_set_error	(ASN1_ERR_DECOD_NULL, P_NIL, Current_p_pc);
				return (0);
			}

			return ((ulong)((*p_p_data) - p_first_data));

		case ASN1_OBJECTIDENT_TYPE_ID :

				/* "flag" field in storage context is used to provide
					the number of appended sub-identifiers */

			if (Asn1_decode_object_identifier (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_OBJ_ID, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			return ((ulong)((*p_p_data) - p_first_data));

#		if ASN1_OBJ_DESC_TYPE_USED == ON	/* ObjectDescriptor Type is used */
		case ASN1_OBJECTDESCR_TYPE_ID :

			if (Asn1_decode_object_descriptor (p_store, p_p_data, p_limit) == NOK) {

					/* Set error context and coding flag and return 0 */

				Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
				Asn1_set_error	(ASN1_ERR_DECOD_OBJ_DESC, Asn1_type_store_add, Current_p_pc);
				return (0);
			}

			break;
#		endif 

#		if ASN1_ANY_TYPE_USED == ON
		case ASN1_ANY_TYPE_ID :

				/* "ANY" Type : compute total length and copy data transparently */

			indef_level = 0;

			while (TRUE) {

				if (((*p_p_data)[0] == BER_END_OF_CONTENT_OCTET) &&
					((*p_p_data)[1] == BER_END_OF_CONTENT_OCTET)) {	/* data pointer indicates end-of-content */

					(*p_p_data) += 2;	/* skip END-OF-CONTENT OCTETS */
					indef_level--;

					if (indef_level == 0) {

						break;	/* end of type is reached */
					}

					continue;	/* continue to process imbricated type that follows from beginning of loop */
				}

						/* skip IDENTIFIER OCTETS field */

				if (Asn1_skip_type_id (p_p_data, p_limit) == NOK) {

						/* Set error context and coding flag and return 0 */

					Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
					Asn1_set_error	(ASN1_ERR_DECOD_BASIC_P_LIM, p_limit, Current_p_pc);
					return (0);
				}

				construct_length = 0xFFFF;
				Asn1_decode_length	(&construct_length, p_p_data, p_limit);		/* compute length and skip LENGTH OCTETS field */

				if (construct_length == 0xFFFF) {	/* length is of indefinite form */

					indef_level++;
					continue;	/* continue to process imbricated type that follows from beginning of loop */
				}

				if (p_limit <= ((*p_p_data) + construct_length)) {

						/* Set error context and coding flag and return 0 */

					Asn1_type_store_flag = ASN1_NOT_DECODED_VALUE;
					Asn1_set_error	(ASN1_ERR_DECOD_BASIC_P_LIM, p_limit, Current_p_pc);
					return (0);
				}

				(*p_p_data) += construct_length;	/* skip Content */

				if (indef_level == 0) {

					break;	/* end of Type is reached */
				}
			}

			Asn1_type_store_size = (ulong)((*p_p_data) - p_first_data);
			Asn1_type_store_add = p_first_data;
			break;
#		endif

	/*		not implemented
		case ASN1_UNIVERSALTIME_TYPE_ID :
		case ASN1_GENERALIZEDTIME_TYPE_ID :
		case ASN1_EXTERNAL_TYPE_ID :
		case ASN1_REAL_TYPE_ID :
	*/
		default :

				/* the ASN1 type is unknown or not implemented */

			Trap (TRAP_ASN1_TYPE_NOT_IMPLEMENTED, "asn1_decode_basic_type");
			return (0);
	}

		/* successful decoding : set storage context flag and return length of decoded data */

	Asn1_type_store_flag = ASN1_DECODED_VALUE;
	return ((ulong)((*p_p_data) - p_first_data));
}

/*EOF*/
