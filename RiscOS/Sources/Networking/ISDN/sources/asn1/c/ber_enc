
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ber_enc.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function (s)
 *
 *	All the functions used to encode an ASN1 value according to
 *	Basic Encoding Rules :
 *
 *		ber_encode_type_ident 			- implements the encoding of the
 *											IDENTIFIER OCTETS field
 *											for a BER value encoding
 *
 *		ber_encode_length				- implements the encoding of the
 *											length field for any value encoding
 *
 *		ber_encode_sized_length 		- implements the encoding of the
 *											LENGTH OCTETS field in the
 *											definite form with a given size
 *											for a BER value encoding.
 *
 *		ber_encode_boolean				- implements the encoding of a
 *											BOOLEAN value according to
 *											the basic encoding rules
 *
 *		ber_encode_integer				- implements the encoding of an
 *											INTEGER value according to
 *											the basic encoding rules
 *
 *		ber_encode_prim_bitstring		- implements the encoding of a
 *											BIT STRING value according to
 *											the basic encoding rules
 *
 *		ber_encode_prim_o_c_string		- implements the encoding of an OCTET STRING
 *											or CharacterString value
 *											according to the basic encoding rules
 *
 *		ber_encode_null					- implements the encoding of a
 *											NULL value according to
 *											the basic encoding rules
 *
 *		ber_encode_object_id			- implements the encoding of an
 *											OBJECT IDENTIFIER value according
 *											to the basic encoding rules
 *
 *		ber_octet_nb_in_obj_component	- implements the counting of number
 *											of components in an
 *											OBJECT IDENTIFIER value
 *
 *		ber_encode_obj_component		- implements the encoding of a component
 *											in an OBJECT IDENTIFIER value according
 *											to the basic encoding rules
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS                                   |*/
/*|    ASN1 language notation encoding/decoding library |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "asn1.h"

		/* Copyright */

CONST char 	ber_enc_copyright[]	= "Copyright (c) 1989/96 by OMNITEL SA - All Rights Reserved";
CONST char 	ber_enc_licence[]		= LICENSE_NBER;

/*-------------------------------------------------------------------------*/

		/* Common BER variables */
		/* -------------------- */

struct ber_primitive_tag_nb	FAR		*p_ber_prim_tag_nb;

	/* table containing length of current appended sub-identifiers for OBJECT IDENTIFIER values */

static uchar append_subid_length[ASN1_MX_APPEND_SUBID];

	/* current number of appended sub-identifier lengths stored in table */

static uchar append_subid_nb;

extern struct asn1_obj_id_node CONST FAR *p_asn1_obj_id_list;

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_encode_type_ident - implements the encoding of the IDENTIFIER
					OCTETS field in a minimal form for a BER value encoding.


Usage            	uchar ber_encode_type_ident (uchar FAR * FAR *p_p_data, uchar FAR *p_limit,
												 uchar type_id, uchar impl, uchar class,
												 asn1_tag_nb_t tag_nb,
								# if ASN1_TAG_NB_EXTENSION_MECHANISM == ON
												 uchar FAR *p_tag_nb);
								# endif
						- p_p_data : pointer to pointer where to store resulting IDENTIFIER OCTETS field,
						- p_limit : pointer to data area limit,
						- type_id : value identifying the ASN1 type to be encoded, equivalent to ASN1 keyword (SEQUENCE, CHOICE, ...),
						- impl : flag indicating if IMPLICIT or EXPLICIT or none keyword was used in the type description,
						- class : class of the tag of the type (or NO_TAG if type is not a tagged type),
						- tag_nb : number of the tag of the type (or NO_TAG if type is not a tagged type),
							last argument : only if tag number extension mechanism is used : see "# if" above
						- p_tag_nb :pointer to the number of the tag if tag is too long to be described only with tag_nb, else P_NIL.

Description			the function reads the numbers and keywords used
					in the ASN1 type description to identify the type and
					encodes the matching IDENTIFIER OCTETS of the BER encoding
					of the type. It puts the resulting encoded type in area
					pointed to by p_data pointer and it sets p_data after
					the end of the IDENTIFIER OCTETS field.

Return value : 	number of octets in IDENTIFIER OCTETS field
				or BER_ERR_TYPE_IDENT_LGTH if an error occurs.

Common constants and declarations : asn1_ber.h.

*--------------------------------------------------------------------------*/

#if ASN1_TAG_NB_EXTENSION_MECHANISM == ON

ushort ber_encode_type_ident (p_p_data, p_limit, type_id, impl, class, tag_nb, p_tag_nb)

#else

ushort ber_encode_type_ident (p_p_data, p_limit, type_id, impl, class, tag_nb)

#endif

	uchar FAR * FAR	*p_p_data;
	uchar FAR		*p_limit;
	uchar			type_id;
	uchar			impl;
	uchar			class;
	asn1_tag_nb_t	tag_nb;

#if ASN1_TAG_NB_EXTENSION_MECHANISM == ON
	uchar FAR		*p_tag_nb;
#endif
{
	ushort 			i = 0;					/* loop index */
	uchar 			constructed = OFF;		/* flag indicating if type is contructed */
	uchar			type_found = OFF;		/* flag indicating if type was found in table */
	uchar 			tagged_type;			/* flag indicating if type is tagged */
	ushort 			octet_nb;				/* number of octets in IDENTIFIER OCTETS field */
	asn1_tag_nb_t	current_tag_nb;			/* current value of tag nb */

#	if ASN1_TAG_NB_EXTENSION_MECHANISM == ON

		uchar		bit_position;			/* position in current octet */

#	endif

#	if ASN1_ANY_TYPE_USED == ON

		if (type_id == ASN1_ANY_TYPE_ID) {

			return (0);	/* "ANY" Type : no encoding is done (even for TYPE), data is copied transparently */
		}

#	endif

		/* if a specific tag class was provided, type is a tagged type */

	tagged_type = (class != ASN1_TYPE_NO_TAG);

		/* Is the type encoding constructed ?

			 - For a tagged type :
			if the IMPLICIT keyword was not used in the type description,
			(EXPLICIT or none) the encoding is constructed,
			else the encoding is constructed if the base encoding is constructed
			and is primitive otherwise (base encoding is given with the type ID)

			- For a non-tagged type :
			as in second case for tagged type, the type ID will indicate if the
			encoding is constructed, while scanning the UNIVERSAL class table */

	if (tagged_type &&
		((impl == ASN1_TYPE_EXPLICIT) || (impl == ASN1_TYPE_NO_IMPLICIT_KEYW)))
	{

		constructed = ON;

	} else {

			/* scan table using type ID to know if type encoding is contructed */

		while ((Ber_type_id	(i)) != ASN1_TYPE_ID_NIL) {

			if ((Ber_type_id (i)) == type_id) {

					/* type is found : update flags and stop scanning */

				type_found = ON;

				if ((Ber_type_prim_flag (i)) == BER_CONSTRUCTOR_ENCODING) {

						/* type is constructed : set flag */

					constructed = ON;
				}

				if (! tagged_type) {

						/* if type is not tagged, the tag class is UNIVERSAL
							and the tag number to be encoded is the one in the table,
							else class and number to be encoded are the ones of the tag */

					class = ASN1_TYPE_CLASS_UNIVERSAL;
					tag_nb = Ber_type_tag_nb (i);
				}

				break;
			}

				/* type not found : continue to scan */

			i++;
		}
	}

		/* Is there a Tag (class + nb) that has already been stored ?
			Yes : this is the one to be encoded */

	if (Asn1_get_tag_class != ASN1_TYPE_NO_TAG) {

		class = Asn1_get_tag_class;
		tag_nb = Asn1_get_tag_nb;
		Asn1_get_p_tag_nb	(p_tag_nb)
	}

	if ((constructed == OFF) && (type_found == OFF)) {

			/* constructed encoding is not determined : type
				description requires further analyse ->
				no encoding but store the Tag if type is tagged */

		if (tagged_type) {

			Asn1_store_tag_class	(class);
			Asn1_store_tag_nb		(tag_nb);
			Asn1_store_p_tag_nb		(p_tag_nb)
		}

		return (0);
	}

		/*
			Tag is about to be encoded, stored Tag has already been taken
			into account above -> reset it to avoid further bad reuse
			for another Tag. */

	Asn1_reset_stored_tag	();

		/* encoding way is determined : encode the IDENTIFIER OCTETS
			corresponding to this way (Primitive/Constructor) and the Tag */

	switch (class) {

		case ASN1_TYPE_CLASS_UNIVERSAL :

			class = BER_TAG_CLASS_UNIVERSAL;
			break;

		case ASN1_TYPE_CLASS_APPLICATION :

			class = BER_TAG_CLASS_APPLICATION;
			break;

		case ASN1_TYPE_CLASS_CONTEXT_SPFC :

			class = BER_TAG_CLASS_CTX_SPECIFIC;
			break;

		case ASN1_TYPE_CLASS_PRIVATE :

			class = BER_TAG_CLASS_PRIVATE;
			break;

		default :

			Trap (TRAP_ASN1_TAG_CLASS, "ber_encode_type_ident - Bad Tag Class");
			break;
	}

		/* IDENTIFIER OCTETS : encode tag class and way (Primitive/Constructor) */

	Ber_encode_tag_class		(class, *p_p_data);

	if (constructed == ON) {

		Ber_encode_prim_cons_flag	(BER_CONSTRUCTOR_ENCODING, *p_p_data);

	} else {

		Ber_encode_prim_cons_flag	(BER_PRIMITIVE_ENCODING, *p_p_data);
	}

	if ((tag_nb < BER_TAG_NB_EXTENDED)

#		if ASN1_TAG_NB_EXTENSION_MECHANISM == ON
			&& (p_tag_nb == P_NIL)
#		endif
		) {

			/* tag number can be encoded on 1 octet : encode it, increment pointer and return 1 */

		Ber_encode_tag_nb_1o	((uchar)tag_nb, *p_p_data);
		(*p_p_data) ++;
		return (1);
	}

		/* tag number is too high to be encoded on 1 octet : IDENTIFIER OCTETS
			field contains a leading octet followed by 1 or more subsequent octets */

		/* encode leading octet */

	Ber_encode_tag_nb_1o	(BER_TAG_NB_EXTENDED, *p_p_data);
	(*p_p_data) ++;

		/* check that data area pointer does not exceed p_limit */

	if (p_limit <= *p_p_data) {

			/* Set error cause and return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (BER_ERR_TYPE_IDENT_LGTH);
	}

		/* init octet counter */

	octet_nb = 1;

		/* encode subsequent octets :
			a list of 1 or more octet(s), bit 8 of last octet
			is 0 (STOP), bit 8 of each preceding octet is 1 (CONTINUE),
			bits 7 to 1 of all the octets in the list = tag nb */

#	if ASN1_TAG_NB_EXTENSION_MECHANISM == ON

		if (p_tag_nb != P_NIL) {

			/* Tag number is provided using p_tag_nb pointer :
				a list of octets and their number. */

				/* get number of octets in list : it is the first octet
					pointed to by p_tag_nb */

			i = *p_tag_nb++;

				/* delete all the null first octets */

			while (*p_tag_nb == 0) {

				if (i == 0) {

					Trap (TRAP_ASN1_TAG_NB, "ber_encode_type_ident - Bad extended Tag Nb");
				}

				i--;
				p_tag_nb++;
			}

				/* p_tag_nb now points to the first non null octet,
					init current position in octet and number of octets
					to be used for encoding */

			bit_position = 0;
			octet_nb = 0;

				/* BER encoding use only bits 1 to 7 of each subsequent octet :
					We scan the list of i octets using a bit_position variable,
					which represents the position in the octets list of the
					first bit of current data octet to be encoded. It is of course
					a modulo 8 counter. Each time the counter exceeds 8, it wraps
					around and number of octet in list is decremented. */

			while (i > 1) {

				bit_position += 7;
				octet_nb++;

				if (bit_position >= 8) {

					bit_position -= 8;
					i--;
				}
			}

				/* first octet of the list */

			if (bit_position == 0) {

				bit_position = 7;
				octet_nb++;
			}

				/* init loop counter */

			i = 0;

				/*
					bit_position is now the position of the first bit of
					the first data octet in the first octet of the list :
					One more octet may be needed if the most significant
					bits from position in first list octet are not null.
				*/

			if ((((*p_tag_nb) >> bit_position) & Mask (8 - bit_position)) != 0) {

				octet_nb++;		/* one more octet to be encoded matching the most significant bits */
				i = 1;			/* increment loop index so that loop below is not processed too many times */

					/* octet matching the most significant bits of first octet in list */

				**p_p_data = (((*p_tag_nb) >> bit_position) & Mask (8 - bit_position));

					/* set extension bit and increment data pointer */

				Ber_encode_ext_bit	(BER_EXT_BIT_CONTINUE, *p_p_data);
				(*p_p_data)++;
			}

				/* number of data octets to be encoded is computed : fill them
					with value in bits 1 to 7 and extension bit 8. The algorithm
					to fill the data from the octet list is as follows :

					bit_position  p_tag_nb   next octet
							|		|          |
							v		v          v
						--------------  --------------
						|   | n bits |  | 7-n |      | n = bit_position.
						--------------  --------------
							 |________________|
									||
									vv
						  --------------------
						  |E| n bits | 7 - n | <-- p_data, E = extension bit.
						  --------------------
				*/

				/* check that data area pointer will not exceed p_limit */

			if (p_limit <= ((*p_p_data) + octet_nb)) {

					/* Set error cause return error indication length */

				Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
				return (BER_ERR_TYPE_IDENT_LGTH);
			}

			while (i < octet_nb) {

				**p_p_data = 0;

				if (bit_position != 7) {

					**p_p_data = (uchar)((*p_tag_nb) << (7 - bit_position));
					p_tag_nb++;
					(**p_p_data) += (((*p_tag_nb) >> (bit_position + 1)) & Mask (7 - bit_position));

						/* next position : if it was 3, we have taken into account
							bits 2, 1 and 0 of current list octet, and bits 7, 6,
							5 and 4 of next octet -> next position is 4 so that we
							start from bit 3 for next octet */

					bit_position++;

				} else {

					**p_p_data = (*p_tag_nb) & Mask (7);
					bit_position = 0;
				}

					/* set extension bit and increment data pointer */

				Ber_encode_ext_bit	(BER_EXT_BIT_CONTINUE, *p_p_data);
				(*p_p_data)++;
				i++;
			}

					/* get last data octet to set extension bit
						to STOP and increment data pointer */

				(*p_p_data)--;
				Ber_encode_ext_bit	(BER_EXT_BIT_STOP, *p_p_data);
				(*p_p_data)++;

				/* 1 leading octet + octet_nb subsequent octets */

			return (octet_nb + 1);
		}

#	endif

		/* Tag number is provided with tag_nb argument */

	current_tag_nb = tag_nb;

	while (current_tag_nb >= 128) {

		octet_nb++;
		current_tag_nb /= (asn1_tag_nb_t)128;
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + octet_nb)) {

			/* Set error cause and return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (BER_ERR_TYPE_IDENT_LGTH);
	}

	for (i = octet_nb; i > 0; i--) {

		(*p_p_data)[i - 1] = (uchar)(tag_nb % (asn1_tag_nb_t)128);
		Ber_encode_ext_bit	(BER_EXT_BIT_CONTINUE, ((*p_p_data) + i - 1));
		tag_nb /= (asn1_tag_nb_t)128;
	}

		Ber_encode_ext_bit	(BER_EXT_BIT_STOP, ((*p_p_data) + octet_nb - 1));
		(*p_p_data) += octet_nb;

		/* 1 leading octet + octet_nb subsequent octets */

	return (octet_nb + 1);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_encode_length - implements the encoding of the LENGTH
					OCTETS field in the minimal definite form for a BER value encoding.

Usage            	uchar ber_encode_length (ulong length, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- length : length value to be encoded,
						- p_p_data : pointer to pointer where to store resulting LENGTH OCTETS field.

Description			the function reads the length to be encoded and encodes it,
					using the definite form. The short form is used if possible,
					else the long form with minimal number of octets. It puts
					the resulting encoded length in area pointed to by p_data pointer
					and it sets p_data after the end of the LENGTH OCTETS field.

Return value : 	number of octets in LENGTH OCTETS field or 0.

Common constants and declarations : asn1_ber.h.

*--------------------------------------------------------------------------*/

uchar  ber_encode_length (length, p_p_data, p_limit)
	ulong 			length;				/* value of length to be encoded */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer : on first octet of LENGTH OCTETS field */
	uchar FAR 		*p_limit;			/* pointer to data area limit */
{
	uchar	length_octets_lgth;			/* current number of octets in the LENGTH OCTETS field */
	uchar	octet_x;					/* index of current octet of encoded length value */
	ulong   current_length;				/* current variable used to compute number of octets */

	if (length <= BER_MX_LGTH_SHORT_FORM) {

			/* short form */

		**p_p_data = (uchar)length;
		(*p_p_data)++;

			/* check that data area pointer does not exceed p_limit */

		if (p_limit <= *p_p_data) {

				/* Set error cause and return 0 */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
			return (0);
		}

			/* a single octet for short form length -> return 1 */

		return (1);
	}

		/* long form : init number of octets and current length */

	current_length = length;
	length_octets_lgth = 1;

	while (current_length >= 256) {

		length_octets_lgth++;
		current_length /= (ulong)256;
	}

			/* check that data area pointer will not exceed p_limit */

		if (p_limit <= ((*p_p_data) + length_octets_lgth)) {

				/* Set error cause and return 0 */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
			return (0);
		}

		/* set first octet indicating long form and LL (length of the length) */

	**p_p_data = BER_LGTH_LONG_FORM + length_octets_lgth;
	(*p_p_data)++;

	for (octet_x = length_octets_lgth; octet_x > 0; octet_x--) {

		(*p_p_data)[octet_x - 1] = (uchar)(length % (ulong)256);
		length /= (ulong)256;
	}

	(*p_p_data) += length_octets_lgth;

		/* 1 octet to specify long form length + length_octets_lgth octets
			to specify number of following octets in OCTETS LENGTH field */

	return (length_octets_lgth + 1);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_encode_sized_length - implements the encoding of the
					LENGTH OCTETS field in the definite form with a
					given size for a BER value encoding.

Usage            	uchar ber_encode_sized_length (ulong length, uchar size, uchar FAR * FAR *p_p_data);
						- length : length value to be encoded,
						- size : resulting size of the encoded LENGTH OCTETS field,
						- p_p_data : pointer to pointer where to store resulting LENGTH OCTETS field.

Description			the function reads the length to be encoded and the size
					expected and encodes it, using the definite form, so that
					the resulting encoding has exactly the given size. Thus
					the short form is used if size is 1 (length shall not
					exceed 127 in this case), else the long form shall be used
					with given number of octets : maybe more octets than the
					minimal necessary shall be used (with some of the octets
					set to 0) but it is authorized in BER specification. It puts
					the resulting encoded length in area pointed to by p_data pointer
					and it sets p_data after the end of the LENGTH OCTETS field.

Return value : 	number of octets in LENGTH OCTETS field or 0.

Common constants and declarations : asn1_ber.h.

*--------------------------------------------------------------------------*/

uchar  ber_encode_sized_length (length, size, p_p_data)
	ulong 			length;				/* value of length to be encoded */
	uchar 			size;				/* expected size of encoded data */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer : on first octet of LENGTH OCTETS field */
{
	uchar	length_octets_lgth;			/* current number of octets in the LENGTH OCTETS field */
	uchar	octet_x;					/* index of current octet of encoded length value */
	ulong   current_length;				/* current variable used to compute number of octets */

		/* expected size may not be null or exceed 127 */

	if ((size == 0) || (size > (BER_MX_LL_LONG_FORM + 1))) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_LGTH_SIZE);
		return (0);
	}

		/* expected size is 1 -> length may not exceed 127,
			in this case, short form is used */

	if (size == 1) {

		if (length > BER_MX_LGTH_SHORT_FORM) {

				/* Set error cause and return 0 */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_LGTH_SIZE);
			return (0);
		}

			/* short form */

		**p_p_data = (uchar)length;
		(*p_p_data)++;

			/* a single octet for short form length -> return 1 */

		return (1);
	}

		/* size is > 1 -> use long form : init number of octets and current length */

	current_length = length;
	length_octets_lgth = 1;

	while (current_length >= 256) {

		length_octets_lgth++;
		current_length /= (ulong)256;
	}

		/* if minimal number of octets necessary to encode the length
			(+ 1 for leading octet of length indicating Long Form)
			is greater than expected size, do nothing and reject */

	if (size < length_octets_lgth + 1) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_LGTH_SIZE);
		return (0);
	}

		/* set first octet indicating long form and LL (length of the length) */

	**p_p_data = BER_LGTH_LONG_FORM + size - 1;
	(*p_p_data)++;

		/* set the first unused octets to 0 */

	for (octet_x = 0; octet_x < (uchar)(size - length_octets_lgth - 1); octet_x++) {

		**p_p_data = 0;
		(*p_p_data)++;
	}

	for (octet_x = length_octets_lgth; octet_x > 0; octet_x--) {

		(*p_p_data)[octet_x - 1] = (uchar)(length % (ulong)256);
		length /= (ulong)256;
	}

	(*p_p_data) += length_octets_lgth;

		/* LENGTH OCTETS field has expected size */

	return (size);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	ber_encode_xxx - implement the encoding of a value according
					to the Basic Encoding Rules and return its length. xxx
					represents the ASN1 type of the value to be encoded (boolean,
					integer, ...) -> 1 function per ASN1 type.

Usage            	uchar ber_encode_boolean (uchar value, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- value : BOOLEAN value to be encoded,
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit.

					uchar ber_encode_integer (ulong value, uchar sign, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- value : numerical value of INTEGER to be encoded,
						- value : sign of INTEGER value to be encoded,
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit.

					ushort  ber_encode_prim_bitstring (ushort size, uchar FAR *p_string, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- size : number of useful octets in string,
						- p_string : pointer to string of octets (first octet contains the number of unused bits in last octet),
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit.

					ushort  ber_encode_prim_o_c_string (ushort size, uchar FAR *p_string, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- size : number of useful octets in string,
						- p_string : pointer to string of octets,
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit.

					uchar  ber_encode_null (uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit.

					ushort  ber_encode_object_id (asn1_node_id_t node_id, uchar FAR * FAR *p_p_data, uchar FAR *p_limit);
						- node_id : identifier of node corresponding to object identifier to be encoded,
						- p_p_data : pointer to pointer where to store resulting encoded data,
						- p_limit : pointer to data area limit.

Description			the function reads the value to be encoded, using eventually
					a pointer to the value and the number of octets in this value,
					and it encodes the Value along with its Length octets
					(in TLV fashion as described in recommendation X209). It puts
					the resulting encoded data in area pointed to by p_data pointer
					and it sets p_data at the end of the data (outside). p_data is
					passed by address so that it can be modified -> uchar FAR * FAR *

Return value : length of encoded data, including Length octets.

Common constants and declarations : asn1.h, asn1_int.h, asn1_ber.h.

*--------------------------------------------------------------------------*/

	/* BOOLEAN type encoding */

uchar  ber_encode_boolean (value, p_p_data, p_limit)
	uchar 			value;				/* BOOLEAN value to be encoded */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR		*p_limit;			/* pointer to limit of data area */
{

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (0);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + 2)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* LENGTH OCTETS : 1 octet, length = 1 (short form) */

	**p_p_data = 1;
	(*p_p_data)++;

		/* CONTENT OCTETS : 0 for FALSE, other value for TRUE */

	if (value == FALSE) {

		**p_p_data = BER_BOOLEAN_FALSE;

	} else {

		**p_p_data = BER_BOOLEAN_DEF_TRUE;
	}

		/* return length of encoded data : Length (1o) + Content (1o) */

	(*p_p_data)++;
	return (2);
}

/* ------------------------------------------------------------------------ */

	/* INTEGER and ENUMERATED type encoding */

		/* The encoding of an enumerated value shall be that of the integer
			value with which it is associated */

uchar  ber_encode_integer (value, sign, p_p_data, p_limit)
	ulong			value;				/* INTEGER value : numerical value */
	uchar			sign;				/* sign of INTEGER value */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR		*p_limit;			/* pointer to limit of data area */
{
	uchar	octet_nb = 1;				/* number of octets useful for encoded integer value */
	uchar	octet_x;					/* index of current octet of encoded value */
	uchar	octet_value;				/* current octet value */
	ulong	current_var;				/* current variable used to compute resulting data and its size */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (0);
	}

	if ((sign != ASN1_CODING_POSITIVE) && (sign != ASN1_CODING_NEGATIVE)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_UNKNOWN_SIGN);
		return (0);
	}

		/* save value */

	current_var = value;

		/* We divide the unsigned value into 256 as many times as possible to compute number of octets */

	while (current_var >= (ushort)(256)) {

		current_var /= (ulong)(256);
		octet_nb++;
	}

		/* To encode a 2's complement signed integer value, 1 more octet is
			necessary if the highest octet is > 128 or equals 128 and
			the value to be encoded is positive.
			For example, any number in interval [-128;+127] shall be encoded on 1 octet,
			but value +128 or -152 shall be encoded on 2 octets. */

	if ((current_var > 128) || ((current_var == 128) && (sign == ASN1_CODING_POSITIVE))) {

		octet_nb++;
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + octet_nb + 1)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* LENGTH OCTETS : 1 octet, length = octet_nb (short form) */

	**p_p_data = octet_nb;
	(*p_p_data)++;

		/* CONTENT OCTETS : 2's complement encoded integer, first octet is
			the most significant one and its bit 8 is the sign bit, last octet = the least significant */

	for (octet_x = octet_nb; octet_x > 0; octet_x--) {

		(*p_p_data)[octet_x - 1] = (uchar)(value % (ulong)256);
		value /= (ulong)256;
	}

		/*
			To match 2's complement, if the value is negative,
			1's complement is to be applied to all the encoded octets
			and then we add 1 using sign as a carry.
		*/

	if (sign == ASN1_CODING_NEGATIVE) {

		for (octet_x = octet_nb; octet_x > 0; octet_x--) {

				/* 1's complement : complement all the bits of current octet starting with last one */

			octet_value = ~((*p_p_data)[octet_x - 1]);

			if (sign == ASN1_CODING_NEGATIVE) {

					/* sign has not changed : it means that there is a carry (= 1) to add */

				if (octet_value == 255) {

						/* by adding 1, current octet value would be 256 ->
							the new value is 0 and carry is reported to next value */

					octet_value = 0;

				} else {

						/* add 1 to current octet value : it will not exceed
							maximum value so there is no more carry to report
							-> change sign */

					octet_value++;
					sign = ASN1_ENCODED_VALUE;
				}
			}

				/* store resulting octet value in current data area */

			(*p_p_data)[octet_x - 1] = octet_value;
		}
	}

		/* return length of encoded data : Length (1o) + Content (octet_nb o) */

	(*p_p_data) += octet_nb;
	return (octet_nb + 1);
}

/* ------------------------------------------------------------------------ */

	/* BIT STRING type : primitive encoding */

ushort  ber_encode_prim_bitstring (size, p_string, p_p_data, p_limit)
	ushort 			size;				/* number of useful octets in string */
	uchar FAR 		*p_string;			/* pointer to string of octets */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR		*p_limit;			/* pointer to limit of data area */
{
	ushort	i;							/* loop index */
	uchar	length_octets_lgth;			/* total number of octets in the LENGTH OCTETS field */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (0);
	}

	if (p_string == P_NIL) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_POINTER);
		return (0);
	}

		/* if number of unused bits is greater than 7, there are too many octets
			in the string -> invalid. this number is given with the first octet
			pointed to by p_string */

	if (*p_string > 7) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_UNUSED_BITS_NB);
		return (0);
	}

	if (size > ((ushort)(~0) - 4)) {

			/* the value returned by the function is an ushort and it is
				(size + 4) for the high values of size. It may not exceed
				(ushort)(~0)
			-> Do not process size > (ushort)(~0) - 4 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* LENGTH OCTETS : definite form, short or long form according to the value of size,
			the value of the length is size + 1 (1 for initial octet, size for subsequent octets) */

	if ((length_octets_lgth = ber_encode_length ((ulong)(size + 1), p_p_data, p_limit)) == 0) {

		return (0);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + size + 1)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* CONTENT OCTETS : 1 initial octet + 0 or more subsequent octet(s) */

	if (size == 0) {

			/* if the bitstring is empty, there shall be no subsequent octets,
				and the initial octet shall be zero */

		**p_p_data = 0;
		(*p_p_data)++;

			/* return length of encoded data : Length (1o) + Content (1o) */

		return (2);
	}

		/* the initial octet encode the number of unused bits in the final octet */

	**p_p_data = *p_string++;
	(*p_p_data)++;

	for (i = 0; i < size; i++) {

		**p_p_data = *p_string++;
		(*p_p_data)++;
	}

			/* return length of encoded data : Length (length_octets_lgth o) + Content ((size + 1) o) */

	return (size + length_octets_lgth + 1);
}

/* ------------------------------------------------------------------------ */

	/* primitive encoding for following types :
				- OCTET STRING,
				- all character string types (NumericString, PrintableString,
				TeletexString, VideotexString, VisibleString, IAString,
				GraphicString, GeneralString),
				- ObjectDescriptor.
	*/

ushort  ber_encode_prim_o_c_string (size, p_string, p_p_data, p_limit)
	ushort 			size;				/* number of useful octets in string */
	uchar FAR 		*p_string;			/* pointer to string of octets */
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR		*p_limit;			/* pointer to limit of data area */
{
	ushort	i;							/* loop index */
	uchar	length_octets_lgth;			/* total number of octets in the LENGTH OCTETS field */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (0);
	}

	if ((p_string == P_NIL) && (size != 0)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_POINTER);
		return (0);
	}

	if (size > ((ushort)(~0) - 3)) {

			/* the value returned by the function is an ushort and it is
				(size + 3) for the high values of size. It may not exceed
				(ushort)(~0)
			-> Do not process size > (ushort)(~0) - 3 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* LENGTH OCTETS : definite form, short or long form according
			to the value of size, the value of the length is size */

	if ((length_octets_lgth = ber_encode_length ((ulong)size, p_p_data, p_limit)) == 0) {

		return (0);
	}

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + size)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* CONTENT OCTETS : 0 or more octet(s) equal to octets in string */

	for (i = 0; i < size; i++) {

		**p_p_data = *p_string++;
		(*p_p_data)++;
	}

		/* return length of encoded data : Length (length_octets_lgth o) + Content (size o) */

	return (size + length_octets_lgth);
}

/* ------------------------------------------------------------------------ */

	/* NULL type encoding */

uchar  ber_encode_null (p_p_data, p_limit)
	uchar FAR * FAR *p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR		*p_limit;			/* pointer to limit of data area */
{

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (0);
	}

	if (p_limit <= ((*p_p_data) + 1)) {

			/* Set error cause return error indication length */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* LENGTH OCTETS : 1 octet, length = 0 (short form) -> No content octets */

	**p_p_data = 0;
	(*p_p_data)++;

		/* return length of encoded data : Length (1o) */

	return (1);
}

/* ------------------------------------------------------------------------ */

	/* OBJECT IDENTIFIER type encoding */

ushort  ber_encode_object_id (node_id, sub_id_nb, p_p_data, p_limit)
	asn1_node_id_t						node_id;			/* identifier of a node in object identifier tree matching the object identifier to be encoded */
	uchar								sub_id_nb;			/* number of sub-identifiers (components) that are appended at the end of the value */
	uchar FAR * FAR 					*p_p_data;			/* pointer to data area pointer (on first octet of LENGTH OCTETS) */
	uchar FAR							*p_limit;			/* pointer to limit of data area */
{
	uchar								component_nb;		/* number of components in object identifier to encode */
	ushort								start_length;		/* length of value without appended sub-identifiers (corresponding to the OBJECT IDENTIFIER associated with the node in the tree given with p_object) */
	ushort								append_length;		/* length of value of appended sub-identifiers */
	struct asn1_obj_id_node CONST FAR	*p_cur_node;		/* pointer to current node in object identifier tree */
	struct asn1_obj_id_node CONST FAR	*p_upper_node;		/* pointer to upper node in object identifier tree */
	uchar								length_octets_lgth;	/* total number of octets in the LENGTH OCTETS field */
	asn1_obj_id_component_t				cur_component;		/* current object identifier component to be encoded */
	asn1_store_ctx_t FAR				*p_store_ctx;		/* current pointer to storage context corresponding to an appended sub-identifier */
	uchar FAR							*p_str;				/* pointer to string of appended sub-identifiers */

	if ((p_p_data == P_NIL) || (*p_p_data == P_NIL)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NIL_P_DATA);
		return (0);
	}

	if (p_asn1_obj_id_list == P_NIL) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NO_OBJ_ID_NODE);
		return (0);
	}
	 
	if (node_id == ASN1_OBJ_ID_NIL) {

			/* The OBJECT IDENTIFIER is not related to a node in the tree :
				Encode only 2 first components 0.0 : 1 sub-identifier = 0 */

		if ((length_octets_lgth = ber_encode_length ((ulong)1, p_p_data, p_limit)) == 0) {

			return (0);
		}

			/* check that data area pointer will not exceed p_limit */

		if (p_limit <= ((*p_p_data) + 1)) {

				/* Set error cause and return 0 */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
			return (0);
		}

		**p_p_data = 0;
		(*p_p_data)++;

			/* return length of encoded data : Length + Content (1 o) */

		return ((ushort)(length_octets_lgth + 1));
	}

		/*	search for the node corresponding to node_id */

	if ((p_cur_node = Asn1_get_obj_id_node (node_id)) == P_NIL) {

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_NO_OBJ_ID_NODE);
		return (0);
	}

		/*	Check that object identifier value contains at least 2 components
			as specified in recommendation X208 : check that this node and
			its upper node are not the root */

	if ((Asn1_cur_node_id == ASN1_OBJ_ID_ROOT) ||
		(Asn1_upper_node_id == ASN1_OBJ_ID_ROOT)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_OBJ_ID_COMP_NB);
		return (0);
	}

		/* get upper node in object identifier tree */

	if ((p_upper_node = Asn1_get_obj_id_node (Asn1_upper_node_id)) == P_NIL) {

		Trap	(TRAP_ASN1_ENCOD_NO_UPPER_NODE, "ber_encode_object_id");
		return (0);
	}

	if (sub_id_nb > ASN1_MX_APPEND_SUBID) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_MANY_SUBID);
		return (0);
	}

		/* init number of components and length */

	component_nb = 2;
	start_length = 0;

		/* scan the tree from object identifier to encode to root
			in order to count the number of components */

	while ((p_upper_node -> upper_node_x) != ASN1_OBJ_ID_ROOT) {

			/* increment number of components */

		component_nb++;

			/* increment length to number of octets necessary to encode
				the current component */

		start_length += ber_octet_nb_in_obj_component ((ulong)(Asn1_cur_component));

			/* get upper node in object identifier tree */

		p_cur_node = p_upper_node;

		if ((p_upper_node = Asn1_get_obj_id_node (Asn1_upper_node_id)) == P_NIL) {

			Trap	(TRAP_ASN1_ENCOD_NO_UPPER_NODE, "ber_encode_object_id");
			return (0);
		}
	}

	cur_component = (((p_upper_node -> label_component) * (asn1_obj_id_component_t)40) + (Asn1_cur_component));

		/* increment length to number of octets necessary to encode the first component */

	start_length += ber_octet_nb_in_obj_component ((ulong)cur_component);

		/* init addressing information for sub-identifiers to be appended */

	p_store_ctx = p_asn1_appended_obj_id;
	append_length = 0;

		/* Use length_octets_lgth variable as a loop index at this point
			to scan the list of all sub-identifiers and count the length.
			The sub-identifiers are given by global p_asn1_appended_obj_id pointer. */

	for (length_octets_lgth = 0; length_octets_lgth < sub_id_nb; length_octets_lgth++) {

			/* checks that a storage context exists */

		if (p_store_ctx == P_NIL) {

				/* Set error cause and return 0 */

			Asn1_set_error_cause	(ASN1_ERR_CAUSE_NO_APPEND_OBJ);
			return (0);
		}

			/* increment number of components */

		component_nb++;

			/* store number of octets necessary to encode the current component */

		append_subid_length [length_octets_lgth] = ber_octet_nb_in_obj_component (p_store_ctx -> size);

			/* increment length of appended value */

		append_length += append_subid_length [length_octets_lgth];

			/* get next storage context */

		if (p_store_ctx -> address != P_NIL) {

			p_str = p_store_ctx -> address;
			length_octets_lgth++;

				/* last appended sub-identifiers consist of an octet string :
					inspect "coding_flag" to know how this string is to be interpreted */

			if (p_store_ctx -> coding_flag == ASN1_FLAG_OBJ_ID_APPEND_STR) {

					/* the string is simply to be copied */

				component_nb++;
				append_subid_length [length_octets_lgth] = (uchar)(sub_id_nb - length_octets_lgth);
				append_length += (uchar)(sub_id_nb - length_octets_lgth);
				length_octets_lgth++;
				break;
			}

            	/* each octet of the string is to be processed as a separate sub-identifier */

			while (length_octets_lgth < sub_id_nb) {

				component_nb++;
				append_subid_length [length_octets_lgth] = ber_octet_nb_in_obj_component (*p_str);
				append_length += append_subid_length [length_octets_lgth];
				length_octets_lgth++;
				p_str++;
			}

			break;
		}

		p_store_ctx = p_store_ctx -> p_next;
	}

	if ((start_length + append_length) > ((ushort)(~0) - 3)) {

			/* the value returned by the function is an ushort and it is
				(length + 3) for the high values of length. It may not exceed
				(ushort)(~0)
			-> Do not process length > (ushort)(~0) - 3 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* LENGTH OCTETS : definite form, short or long form
			according to the value of length */

	if ((length_octets_lgth = ber_encode_length ((ulong)(start_length + append_length), p_p_data, p_limit)) == 0) {

		return (0);
	}

		/* CONTENT OCTETS : ordered list of encoding of subidentifiers :
			first subidentifier = 40 * first component value + second component value,
			i'th subidentifier = (i +1)'th component value,
			number of subidentifiers = number of components - 1. */

		/* check that data area pointer will not exceed p_limit */

	if (p_limit <= ((*p_p_data) + start_length + append_length)) {

			/* Set error cause and return 0 */

		Asn1_set_error_cause	(ASN1_ERR_CAUSE_TOO_BIG_DATA);
		return (0);
	}

		/* add length_octets_lgth to append_length so that length_octets_lgth may be reused */

	append_length += length_octets_lgth;

			/* set p_data pointer at the end of data area corresponding
				to node in the tree (without sub-identifiers) : process
				encoding from the end is more simple */

	(*p_p_data) += (start_length - 1);

		/* search again for the node corresponding to node_id */

	if ((p_cur_node = Asn1_get_obj_id_node (node_id)) == P_NIL) {

		Trap	(TRAP_ASN1_ENCOD_NO_NODE, "ber_encode_object_id");
		return (0);
	}

		/* get upper node in object identifier tree */

	if ((p_upper_node = Asn1_get_obj_id_node (Asn1_upper_node_id)) == P_NIL) {

		Trap	(TRAP_ASN1_ENCOD_NO_UPPER_NODE, "ber_encode_object_id");
		return (0);
	}

		/* scan the tree from object identifier to root
			in order to encode each component */

	while ((p_upper_node -> upper_node_x) != ASN1_OBJ_ID_ROOT) {

			/* get current component */

		cur_component = Asn1_cur_component;

			/* encode sub-identifier matching the current component */

		length_octets_lgth = ber_encode_obj_component ((ulong)cur_component, *p_p_data);

			/* decrement data pointer to number of encoded octets for current sub-identifier
				so that it points to the end of preceding sub-identifier */

		(*p_p_data) -= length_octets_lgth;

			/* get upper node in object identifier tree */

		p_cur_node = p_upper_node;

		if ((p_upper_node = Asn1_get_obj_id_node (Asn1_upper_node_id)) == P_NIL) {

			Trap	(TRAP_ASN1_ENCOD_NO_UPPER_NODE, "ber_encode_object_id");
			return (0);
		}
	}

		/* encode first and second components : one subidentifier for both,
			with value (40 * first + second) */

	cur_component = (((p_upper_node -> label_component) * (asn1_obj_id_component_t)40) + (Asn1_cur_component));

	length_octets_lgth = ber_encode_obj_component ((ulong)cur_component, *p_p_data);

		/* decrement data pointer to number of encoded octets for current sub-identifier
			so that it points before the first sub-identifier */

	(*p_p_data) -= length_octets_lgth;

		/* set pointer after the end of encoded object identifier (without appended sub-identifiers) */

	(*p_p_data) += start_length;

		/* re-init storage context pointer to first sub-identifier to be appended */

	p_store_ctx = p_asn1_appended_obj_id;

		/* append the last sub-identifiers given with the list of storage contexts */

	for (append_subid_nb = 0; append_subid_nb < sub_id_nb; append_subid_nb++) {

			/* checks that a storage context exists */

		if (p_store_ctx == P_NIL) {

				/* it should exist for it has just been checked above during length count :
					: internal process error -> Trap */

			Trap	(TRAP_ASN1_ENCOD_NO_STORE_CTX, "ber_encode_object_id");
			return (0);
		}

			/* set data area pointer at the end of current value area using
				length that has been computed previously and stored */

		(*p_p_data) += append_subid_length [append_subid_nb];

			/* sub-identifier is given with the "size" field, encode it */

		ber_encode_obj_component (p_store_ctx -> size, *p_p_data);

			/* get next storage context */

		if (p_store_ctx -> address != P_NIL) {

			p_str = p_store_ctx -> address;
			append_subid_nb++;

				/* last appended sub-identifiers consist of an octet string :
					inspect "coding_flag" to know how this string is to be interpreted */

			if (p_store_ctx -> coding_flag == ASN1_FLAG_OBJ_ID_APPEND_STR) {

					/* the string is simply to be copied */

				(*p_p_data)++;		/* set data pointer to start of string (it points to last octet of previous sub-identifier) */
				Memcpy_far ((char FAR *)(*p_p_data), (char FAR *)p_str, (uchar)(sub_id_nb - append_subid_nb));
				(*p_p_data) += (uchar)(sub_id_nb - append_subid_nb - 1);
				p_store_ctx -> coding_flag = ASN1_ENCODED_VALUE;
				p_store_ctx = p_store_ctx -> p_next;
				break;
			}

				/* each octet of the string is to be processed as a separate sub-identifier */

			while (append_subid_nb < sub_id_nb) {

				(*p_p_data) += append_subid_length [append_subid_nb];
				ber_encode_obj_component (*p_str, *p_p_data);
				append_subid_nb++;
				p_str++;
			}

				/* set coding flag */

			p_store_ctx -> coding_flag = ASN1_ENCODED_VALUE;
			p_store_ctx = p_store_ctx -> p_next;
			break;
		}

			/* set coding flag */

		p_store_ctx -> coding_flag = ASN1_ENCODED_VALUE;
		p_store_ctx = p_store_ctx -> p_next;
	}

		/* set data area pointer AFTER the encoded data */

	(*p_p_data)++;

		/* update global pointer to list of sub-identifiers to be appended */

	p_asn1_appended_obj_id = p_store_ctx;

		/* return length of encoded data : Length + Content related to node in the tree (start_length o) + Content related to appended sub-identifiers (append_length o) */

	return (start_length + append_length);
}

/* ------------------------------------------------------------------------ */

	/* number of octets used to encode an object identifier component */

uchar ber_octet_nb_in_obj_component (component)
	ulong component;		/* object identifier component whose encoding length is to be calculated */
{
	uchar i = 1;		/* loop index */

		/* a component is coded on a minimal list of octets, using
			bits 1 to 7 to encode the value -> 1 octet for value from 0 to 127,
			2 octets from 128 to 128 * 128 -1, ... */

	while (component >= (uchar)128) {

		i++;
		component /= (ulong)128;
	}

	return (i);
}

/* ------------------------------------------------------------------------ */

	/* encode an object identifier component from the end */

uchar ber_encode_obj_component (component, p_data)
	ulong		component;		/* object identifier component to be encoded */
	uchar FAR	*p_data;		/* pointer to last octet of data area where to encode the value */
{
	uchar i = 1;	/* current number of octets */

		/*
			encode sub-identifier matching the current component :
			a list of 1 or more octet(s), bit 8 of last octet
			is 0 (STOP), bit 8 of each preceding octet is 1 (CONTINUE),
			bits 7 to 1 of all the octets in the list = subidentifier
		*/

		/* we start with the last octet -> Bit 8 = STOP, p_data will be decremented */

	Ber_encode_ext_bit(BER_EXT_BIT_STOP, p_data);

	while (component >= (uchar)128) {

				/* process of all octets except first : value = bits 7 to 1
					Bit 8 of precedent octet = CONTINUE */

		Asn1_put_field	(p_data, 0, 7, (uchar)(component % 128));
		p_data--;
		Ber_encode_ext_bit(BER_EXT_BIT_CONTINUE, p_data);
		component /= (ulong)128;
		i++;
	}

		/* encode 7 last bits of first octet */

	Asn1_put_field	(p_data, 0, 7, (uchar)component);

	return (i);
}

/* ------------------------------------------------------------------------ */

	/* ObjectDescriptor type primitive encoding, it matches the ASN1 definition :
	 *
	 *	ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString
	 *
	 *		-> use ber_encode_prim_o_c_string () function, that encodes all character string types.
	 *
	 */


/* EOF */
