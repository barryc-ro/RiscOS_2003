/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - cc.h
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the commmon declarations of the CC functions.
 *
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Call Control (CC) Entity                         |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "services.h"

#include "ns_int.h"

#include "cc_int.h"

#include "acu_int.h"

#if SIMULATION == OFF

			/* CC entity defines */


#	define	event_id				event_id_cc		/* event identifier */
#	define	ret_code				ret_code_cc		/* return code */
#	define 	p_snd_msg				p_snd_msg_cc	/* pointer on the current message to send if any */
#	define 	p_rcv_msg				p_rcv_msg_cc	/* pointer on the current received message if any */
#	define 	p_buffer				p_buffer_cc		/* pointer on the curent buffer if any */
#	define 	p_buffer_end			p_buffer_end_cc	/* pointers on the end of the current buffer if any */
#	define 	os_err					os_err_cc		/* OS error code */

#endif

	/* Define default values parameters of cc_par.h if not defined */

#ifndef CC_PAR_SEMI_PERMANENT_CIRCUITS
#	define CC_PAR_SEMI_PERMANENT_CIRCUITS	OFF		/* process semi-permanent circuits (ON/OFF, available on AU1 only at the moment) */
#endif

#ifndef CC_F_AT4
#	define CC_F_AT4					OFF				/* default value to ensure compatibility of older 'cc_par.h' */
#endif

#ifndef CC_ADDRESS_FILTERING
#	define CC_ADDRESS_FILTERING		ON				/* default value to ensure compatibility of older 'cc_par.h' */
#endif

#ifndef CC_SUB_ADDRESS_DELIMITER
#	define CC_SUB_ADDRESS_DELIMITER	'*'				/* Address*Sub-address default delimiter */
#endif

#define	CC_NB_CHAN_ID_SENT			30				/* Nb of channel id sent */

#ifndef CC_V120_CODING
#	define CC_V120_CODING			ON				/* V.120(ON) or DATA(OFF) coding for V120 services */
#endif

#ifndef CC_PAR_SIGNAL_IE
#	define CC_PAR_SIGNAL_IE			OFF				/* process Signal IE if available (ON/OFF, available on NI2, E10 and DMS only) */
#endif
#ifndef CC_PAR_PROGRESS_IND_IE
#	define CC_PAR_PROGRESS_IND_IE	OFF				/* process Progress-Indicator IE if available (ON/OFF, available on NI2, E10 and DMS only) */
#endif

#if ARINC_NETWORKS == ON
#	undef  CC_PAR_SIGNAL_IE
#	define CC_PAR_SIGNAL_IE			ON				/* process Signal IE if available (ON/OFF, available on NI2, E10 and DMS only) */
#	undef  CC_PAR_PROGRESS_IND_IE
#	define CC_PAR_PROGRESS_IND_IE	ON				/* process Signal IE if available (ON/OFF, available on NI2, E10 and DMS only) */
#endif

#if ACU_INTERFACE == OFF
#	undef  ACU_PAR_EXTENDED_PRIM
#	define ACU_PAR_EXTENDED_PRIM	OFF
#	undef  CC_PAR_REDIR_NB
#	define CC_PAR_REDIR_NB			OFF
#	undef  CC_PAR_PROGRESS_IND_IE
#	define CC_PAR_PROGRESS_IND_IE	OFF				/* process Signal IE if available (ON/OFF, available on NI2, E10 and DMS only) */
#endif

#ifndef ACU_PAR_EXTENDED_PRIM
#	define ACU_PAR_EXTENDED_PRIM	OFF
#endif

#if ACU_PAR_EXTENDED_PRIM == OFF
#	undef  ACU_PAR_EXT_LLC
#	define ACU_PAR_EXT_LLC			OFF
#	undef  ACU_PAR_EXT_CUG
#	define ACU_PAR_EXT_CUG			OFF
#	undef  ACU_PAR_EXT_FAC_ASN1
#	define ACU_PAR_EXT_FAC_ASN1		OFF
#endif

#if (ACU_PAR_EXT_CUG == ON) && (CC_F_ETS == ON)
#	if (NS_SUPP_SERVICES == OFF) || (NS_SS_CUG == OFF)
#		error 'NS_SUPP_SERVICES' and 'NS_SS_CUG' must be set to ON in 'ns_par.h'
#	endif
#endif

#if (ACU_PAR_EXT_FAC_ASN1 == ON) && (CC_F_ETS == ON) && (NS_SUPP_SERVICES == OFF)
#	error 'NS_SUPP_SERVICES' must be set to ON in 'ns_par.h'
#endif

	/* _ACU_PAR_EXT_FACILITY is tested where extended facility is used */

#if CC_F_ETS == ON
#	if (ACU_PAR_EXT_FAC_ASN1 == ON) || (ACU_PAR_EXT_CUG == ON) || ((NS_HOLD_RETRIEVE == ON) && (NS_SS_ECT == ON))
#		define _ACU_PAR_EXT_FACILITY	ON
#	else
#		define _ACU_PAR_EXT_FACILITY	OFF
#	endif
#else
#	define _ACU_PAR_EXT_FACILITY	OFF
#endif

#if (ACU_PAR_EXT_LLC == OFF) && (ACU_PAR_EXT_FAC_ASN1 == OFF) && (ACU_PAR_EXT_CUG == OFF)
#	undef  ACU_PAR_EXTENDED_PRIM
#	define ACU_PAR_EXTENDED_PRIM	OFF
#endif

#ifndef    Cc_par_allocate_asn1_invoke_id
#	define Cc_par_allocate_asn1_invoke_id(conn_id)			cc_allocate_asn1_invoke_id (conn_id)
#endif
#ifndef    Cc_par_free_asn1_invoke_id
#	define Cc_par_free_asn1_invoke_id(conn_id,invoke_id)	cc_free_asn1_invoke_id (conn_id, invoke_id)
#endif

		/*
			Redefine the 'ns_int_ctx' interface structure name so that
			it is private to CC entity only.
			This allows to use more than one Ns-upper entity, each one
			having its own private 'ns_int_ctx' structure.
		*/

#define	ns_int_ctx					ns_int_ctx_cc

/*-------------------------------------------------------------------------*/
						/*
						 * For compatibility purpose,
						 * if a flag is unknown, define it to OFF.
						 */

#ifndef CC_F_A11
#	define CC_F_A11					OFF
#endif
#ifndef CC_F_A17
#	define CC_F_A17					OFF
#endif
#ifndef CC_F_AT4
#	define CC_F_AT4					OFF
#endif
#ifndef CC_F_AT5
#	define CC_F_AT5					OFF
#endif
#ifndef CC_F_AT9
#	define CC_F_AT9					OFF
#endif
#ifndef CC_F_E10
#	define CC_F_E10					OFF
#endif
#ifndef CC_F_AU1
#	define CC_F_AU1					OFF
#endif
#ifndef CC_F_BIP
#	define CC_F_BIP					OFF
#endif
#ifndef CC_F_BT2
#	define CC_F_BT2					OFF
#endif
#ifndef CC_F_BV1
#	define CC_F_BV1					OFF
#endif
#ifndef CC_F_DMS
#	define CC_F_DMS					OFF
#endif
#ifndef CC_F_DRV
#	define CC_F_DRV					OFF
#endif
#ifndef CC_F_ETS
#	define CC_F_ETS					OFF
#endif
#ifndef CC_F_HKT
#	define CC_F_HKT					OFF
#endif
#ifndef CC_F_KDD
#	define CC_F_KDD					OFF
#endif
#ifndef CC_F_NI1
#	define CC_F_NI1					OFF
#endif
#ifndef CC_F_NI2
#	define CC_F_NI2					OFF
#endif
#ifndef CC_F_NTT
#	define CC_F_NTT					OFF
#endif
#ifndef CC_F_QSI
#	define CC_F_QSI					OFF
#endif
#ifndef CC_F_SWD
#	define CC_F_SWD					OFF
#endif
#ifndef CC_F_TR6
#	define CC_F_TR6					OFF
#endif
#ifndef CC_F_VN2
#	define CC_F_VN2					OFF
#endif
#ifndef CC_F_VN3
#	define CC_F_VN3					OFF
#endif
#ifndef CC_F_VN6
#	define CC_F_VN6					OFF
#endif

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-=-*/
					/*                       */
					/*  CC global variables  */
					/*                       */
					/*-=-=-=-=-=-=-=-=-=-=-=-*/

extern nai_t						cc_current_nai;     	/* CC current nai */
extern sapi_t						cc_current_sapi_user;	/* current user SAPI */
extern conn_id_t					cc_current_conn_id;		/* current CONN_ID */
extern ent_id_t						cc_current_ent_user;	/* current user entity */

extern sapi_t						cc_from_sapi;  			/* sapi of received msg */
extern ushort						cc_event_id;			/* absolute event id out of SAPI and msg_code */

extern uchar						cc_service_id;			/* service id */
extern uchar						cc_service_class;		/* service class */

extern struct node				FAR *p_cc_tree;				/* pointer to the top of Network Access structures list */
extern struct cc_na				FAR *p_cc_na;				/* pointer to the current Network Access structure */
extern struct cc_call			FAR	*p_cc_call;				/* pointer to the current call context */

extern struct cc_profile		FAR *p_cc_profiles_tree;	/* top node of the profiles list */
extern struct cc_profile		FAR *p_cc_profile;			/* current profile pointer */

extern uchar						cc_error_class;			/* current NS-form error class */
extern uchar						cc_error_value;			/* and value */
extern ent_id_t						cc_error_to;			/* and destination entity */
extern sapi_t						cc_error_sapi;			/* and SAPI */

extern code_t						cc_tmp_prim_code;		/* temporary primitive code (used in some cc_build.*) */

extern uchar						cc_cause;
extern uchar						cc_cause_class;
extern uchar						cc_cause_val;

extern uchar					FAR *p_data_cc;				/* pointer to the received data */

extern uchar						cc_calling_nb_size;
extern uchar						cc_calling_nb_type;
extern uchar						cc_calling_nb_pres;
extern uchar						cc_calling_nb_screen;
extern char						FAR *p_calling_address;
extern char						FAR *p_calling_subaddress;

#if CC_PAR_MULTIPLE_CALLING_NB == ON
	extern uchar					cc_calling_nb2_size;
	extern uchar					cc_calling_nb2_type;
	extern uchar					cc_calling_nb2_pres;
	extern uchar					cc_calling_nb2_screen;
	extern char					FAR *p_calling_address2;
	extern char					FAR *p_calling_subaddress2;
#else
#	define cc_calling_nb2_size		0						/* to avoid too many code changes */
#endif

extern uchar						cc_called_nb_type;
extern uchar						cc_called_nb_plan;
extern uchar						cc_called_nb_size;
extern uchar					FAR *p_called_nb;
extern char						FAR *p_rq_address;

extern uchar						cc_called_sub_add_size;
extern uchar					FAR *p_called_sub_add;
extern char						FAR *p_rq_subaddress;

#if CC_PAR_REDIR_NB == ON
	extern uchar					cc_redir_nb_size;
	extern uchar					cc_redir_nb_type;
	extern uchar					cc_redir_nb_pres;
	extern uchar					cc_redir_nb_screen;
	extern uchar					cc_redir_nb_reason;
	extern char					FAR *p_redir_address;
#else
#	define cc_redir_nb_size			0
#endif

extern uchar						cc_sending_complete;	/* sending complete PRESENT->ON, ABSENT->OFF */

#if CC_PAR_DISPLAY_IE == ON
	extern uchar					cc_display_size[];		/* received display information size */
	extern uchar					cc_display_type[];		/* received display information size */
	extern char					FAR *p_cc_display[];		/* pointer on the received display string */
	extern uchar					cc_display_instance_nb;	/* display instance number */
	extern uchar					cc_display_total_size;	/* sum of all display sizes */
#	if ACU_INTERFACE == ON
		extern struct acu_display_list FAR *p_cc_display_list;	/* address of the received ACU display_list */
#	endif
#else
#	define cc_display_total_size	0						/* to avoid too many code changes */
#	define cc_store_display(p_display,p_start)				/* to disable this function call */
#	if ACU_INTERFACE == ON
#		define cc_read_display_from_acu(a_display_list)		/* to disable this function call */
#	endif
#endif

extern char						FAR *p_call_id;

#if CC_UUI == ON
	extern char					FAR *p_cc_uui;
	extern uchar					cc_uui_size;
#else
#	define p_cc_uui					P_NIL	/* no UUI */
#	define cc_uui_size				0		/* no UUI */
#endif

extern uchar						cc_restart_indicator;

extern uchar						cc_spf_facility_action;	/* specific facility action */
extern uchar						cc_spf_facility_code;	/* specific facility code */

extern char						FAR *p_cc_facility;
extern uchar						cc_facility_size;

extern uchar						cc_setup_report_in;	/* send-report-in flag */

extern uchar						cc_interworking;	/* interworking situation detected in the NS_CONN_IN ? (ON/OFF) */

extern struct layer_1_info			cc_layer_1_info;	/* internal temporary layer 1 information */

extern signed char					cc_chan_nb;				/* number of channels in cc_chan_id[] */
extern signed char					cc_chan_id[];			/* channels list */
extern uchar						cc_chan_excl;			/* 'pref/excl' field value in 'chan_id' IE */
extern uchar						cc_chan_sel;			/* channel selection field */
extern uchar						cc_chan_map_lgth;		/* length of the B-channels map */
extern uchar						cc_chan_map[];			/* B-channels map (32 slots) */
extern uchar						cc_store_chan_id;		/* set to ON if the 'chan_id' IE is to be stored in the next message */
extern uchar						cc_chan_id_from_user;	/* set to ON if channel id is received from the User */

#if CC_PAR_PROGRESS_IND_IE == ON
	extern struct acu_progress_ind	cc_progress_ind;		/* progress-indicator */
#else
#	define cc_store_progress_ind(p_progress_ind)			/* to disable this function call */
#	define cc_read_progress_ind_from_acu(p_progress_ind)	/* to disable this function call */
#endif

#if CC_PAR_DATE_TIME == ON
	extern struct acu_date_time		cc_date_time;			/* date and time information */
#endif

#if ACU_PAR_EXTENDED_PRIM == ON
#	define ACU_SZ_I_EXT				500						/* size of the internal data buffer */
	extern ushort					cc_ext_lgth;			/* extended IEs total lgth */

	extern uchar               FAR *p_cc_i_ext;				/* pointer to internal extended data buffer */
	extern uchar                    t_cc_i_ext[];			/* internal extended data buffer */
	extern ushort                   cc_i_ext_lgth;			/* internal extended data total lgth */
	extern ushort                   cc_i_ext_nb;			/* nb of items in the internal extended data buffer */

#else
#	define cc_ext_lgth				0						/* to avoid too many code changes */
#	define cc_i_ext_lgth			0						/* to avoid too many code changes */
#endif

#if ACU_PAR_EXT_LLC == ON
	extern struct acu_ext_llc       cc_ext_llc;				/* extended LLC information */
#endif

#if _ACU_PAR_EXT_FACILITY == ON
	extern uchar               FAR *p_cc_ext_fac_asn1;		/* pointer to the ASN1 facility data */
	extern ushort                  cc_ext_fac_asn1_lgth;	/* size of the ASN1 facility data */
	extern ushort                  cc_ext_fac_asn1_comp_nb;	/* nb of components in the ASN1 facility data */
#endif

#if ACU_PAR_EXT_CUG == ON
	extern uchar               FAR *p_cc_ext_cug;			/* pointer to the 'acu_ext_cug' structure */
#endif

#if CC_PAR_CHARGING_INFO == ON
	extern uchar					cc_charging_type;		/* charging type */
	extern uchar					cc_charging_period;		/* charging period */
	extern uchar					cc_charging_multi;		/* charging multiplier */
	extern long						cc_charging;			/* charging (nb of units) */
#endif

#if CC_PAR_KEYPAD_IE == ON
	extern char						FAR *p_cc_keypad;
	extern uchar						cc_keypad_size;
#else
#	define cc_keypad_size			0						/* to avoid too many code changes */
#endif

#if CC_ATT_HCDT == ON
	extern uchar					cc_button_type;
	extern uchar					cc_module_nb;
	extern uchar					cc_button_nb;
	extern uchar					cc_switchhook;
#endif

#if CC_PAR_SIGNAL_IE == ON
	extern uchar					cc_signal_val;
#endif

#if ARINC_NETWORKS == ON
	extern uchar					cc_dtmf_digit;
	extern uchar					cc_up_down_flag;
	extern uchar					cc_dtmf_duration;
	extern uchar			 		cc_notif_descr;
	extern uchar					cc_spf_fac_code;
	extern uchar					cc_spf_fac_id;
	extern uchar					cc_departure_year;
	extern uchar					cc_departure_month;
	extern uchar					cc_departure_day;
	extern uchar					cc_service_class_id;
	extern uchar					cc_nats_route_ind;
	extern uchar					cc_satcom_route_ind;
	extern uchar					cc_tfts_route_ind;
	extern uchar					cc_credit_card_status;
	extern uchar					cc_nats_avail;
	extern uchar					cc_satcom_avail;
	extern uchar					cc_tfts_avail;
	extern uchar					cc_nats_pos;
	extern uchar					cc_satcom_pos;
	extern uchar					cc_tfts_pos;

	extern uchar					cc_track_1_size;
	extern uchar					cc_track_2_size;
	extern uchar					cc_flight_op_id_size;
	extern uchar					cc_flight_number_size;

	extern char					FAR *p_cc_track_1;
	extern char					FAR *p_cc_track_2;
	extern char					FAR	*p_cc_flight_op_id;
	extern char					FAR	*p_cc_flight_number;
#else
#	define cc_track_1_size			0
#	define cc_track_2_size			0
#	define cc_flight_op_id_size		0
#	define cc_flight_number_size	0
#endif

#if CC_ATT_HCDT == ON
	extern uchar					cc_call_appear;
	extern uchar					cc_dest_call_appear;
#endif

extern conn_id_t					cc_other_conn_id;

extern struct cc_param					*p_cc_param;
extern struct cc_uchar_fct_table		*p_cc_uchar_fct_table;
extern struct cc_uchar_fct_1p_table		*p_cc_uchar_fct_1p_table;
extern struct cc_uchar_fct_2uc_table	*p_cc_uchar_fct_2uc_table;
extern struct cc_uchar_fct_3uc_table	*p_cc_uchar_fct_3uc_table;
extern struct cc_p_fct_2uc_table		*p_cc_p_fct_2uc_table;

extern uchar						cc_net_idx;			/* Number of implemented networks */
extern uchar						cc_operator;		/* to save the Cc_na_network in order to check the consistancy of the config. */
extern uchar						cc_select_op;		/* Current selected operator */

extern uchar				   		cc_a17;             /* index for ARINC A17	operator */
extern uchar				   		cc_a11;             /* index for ARINC A11	operator */
extern uchar				   		cc_at4;             /* index for ATT_4ESS	operator */
extern uchar				   		cc_at5;             /* index for ATT_5E5	operator */
extern uchar				   		cc_at9;             /* index for ATT_5E9	operator */
extern uchar				   		cc_e10;             /* index for ATT_5E10	operator */
extern uchar				   		cc_au1;             /* index for AUSTEL_1	operator */
extern uchar				   		cc_bip;             /* index for BELLCORE	operator */
extern uchar				   		cc_bt2;             /* index for BT_ISDN2	operator */
extern uchar				   		cc_bv1;				/* index for BG_V1		operator */
extern uchar				   		cc_dms;             /* index for NT_DMS100	operator */
extern uchar				   		cc_ets;             /* index for ETSI		operator */
extern uchar				   		cc_kdd;             /* index for KDD 		operator */
extern uchar				   		cc_ni1;             /* index for N_ISDN1	operator */
extern uchar				   		cc_ni2;             /* index for N_ISDN2	operator */
extern uchar				   		cc_ntt;             /* index for NTT		operator */
extern uchar				   		cc_hkt;             /* index for HK_TEL		operator */
extern uchar				   		cc_qsi;             /* index for ECMA_QSIG	operator */
extern uchar				   		cc_swd;				/* index for SWD_TVKT	operator */
extern uchar				   		cc_tr6;             /* index for DT_1TR6	operator */
extern uchar				   		cc_vn2;             /* index for FT_VN2		operator */
extern uchar				   		cc_vn3;             /* index for FT_VN3		operator */
extern uchar				   		cc_vn6;             /* index for FT_VN6		operator */

extern char				FAR * CONST p_cc_empty_string;

extern struct cc_service FAR * CONST t_cc_services[];	/* services description tables list */

extern 	uchar						cc_spid_size;		/* SPID string size */

#if _CC_SPID_INFO == ON
	extern  uchar FAR *				p_spid;				/* pointer to the SPID */
	extern	uchar 					cc_ces;				/* CES on which the SPID was received */
	extern  uchar 					cc_usid;			/* User Id */
	extern  uchar 					cc_tid;				/* Terminal Id */
	extern  uchar 					cc_interpreter;		/* Intrepreter */
	extern  uchar 					cc_endpoint_action;	/* Action to be taken on the Endpoint Id */
#endif

/*-------------------------------------------------------------------------*/
				/* Absolute event out of SAPI and CODE */

#define Event(sapi,code)			(((short)sapi << 8) + code)

						/* Constants */

#define	NETWORK_NOT_IMPLEMENTED		255
#define	NO_OPERATOR_DEFINED			255

/*-------------------------------------------------------------------------*/

							/* State definitions */

#define STATE_NULL						0
#define STATE_CALL_INIT					1
#define STATE_OVERLAP_SENDING			2
#define STATE_OUTGOING_CALL_PROC		3
#define STATE_RINGING					6
#define STATE_CALL_RECEIVED				7
#define STATE_HOOKED_OFF				8
#define STATE_ACTIVE					10
#define STATE_RELEASE_IN				12
#define STATE_RELEASE_USER				13
#define STATE_RELEASE_NS				14
#define STATE_SUSPEND_RQ				15
#define STATE_RESUME_RQ					17
#define STATE_RELEASE_RQ				19
#define STATE_SPF_FACILITY_RQ			21
#define STATE_ERROR_IN					99
#define STATE_SPF_REGISTRATION_RQ		254

#define STATE_OUT_OF_ORDER				253

					/* States used when overlap receiving */

#define	STATE_AWAIT_DIGIT				100
#define	STATE_AWAIT_ADDITIONAL_DIGIT	101

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/*   CC tele-services  */
					/*     definitions     */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

		/* cc_service sub-structures */

	struct cc_service_hlc {
		uchar code;						/* hlc code */
		uchar teleservice;				/* hlc teleservice */
	};

	struct cc_service_bc_llc {
		uchar trf_cap;
		uchar trf_mode;
		uchar trf_rate;
		uchar structure;
		uchar dest_rate;

		uchar protocol_id_1;
		uchar syn_asyn;
		uchar negotiation;
		uchar user_rate;

		uchar protocol_id_2;

		uchar protocol_id_3;

		uchar add_layer_id;				/* additional user information layer protocol identifier */
		uchar add_protocol_id;			/* additional user information protocol identifier */
	};

	struct cc_service_indicator {
		uchar service;					/* service id */
		uchar add_info;					/* additionnal information */
	};

		/* cc_service structure itself */

struct cc_service {

	uchar						service_id;	/* service_id */

	struct cc_service_hlc		hlc;

	struct cc_service_bc_llc	bc;

	struct cc_service_bc_llc	llc;

	struct cc_service_indicator	service_indicator;

	uchar						b_mode;		/* B channel transfert mode */

};

	/* Manipulation macros thru p_cc_service pointer */

#define Cc_service_id					p_cc_service ->	service_id

#define Cc_service_hlc_code				p_cc_service -> hlc.code
#define Cc_service_hlc_teleservice		p_cc_service -> hlc.teleservice

#define Cc_service_bc_trf_cap			p_cc_service -> bc.trf_cap
#define Cc_service_bc_trf_mode			p_cc_service -> bc.trf_mode
#define Cc_service_bc_trf_rate			p_cc_service -> bc.trf_rate
#define Cc_service_bc_structure			p_cc_service -> bc.structure
#define Cc_service_bc_dest_rate			p_cc_service -> bc.dest_rate

#define Cc_service_bc_protocol_id_1		p_cc_service -> bc.protocol_id_1
#define Cc_service_bc_syn_asyn			p_cc_service -> bc.syn_asyn
#define Cc_service_bc_negotiation		p_cc_service -> bc.negotiation
#define Cc_service_bc_user_rate			p_cc_service -> bc.user_rate

#define Cc_service_bc_protocol_id_2		p_cc_service -> bc.protocol_id_2

#define Cc_service_bc_protocol_id_3		p_cc_service -> bc.protocol_id_3

	/* For ATT_5E5 only */

#define Cc_service_bc_layer_nb			Cc_service_bc_protocol_id_1
#define Cc_service_bc_layer_id			Cc_service_bc_syn_asyn
#define Cc_service_bc_protocol_id		Cc_service_bc_negotiation
#define Cc_service_bc_add_layer_id		Cc_service_bc_user_rate
#define Cc_service_bc_add_protocol_id	Cc_service_bc_protocol_id_2

	/* LLC IE fields */

#define Cc_service_llc_trf_cap			p_cc_service -> llc.trf_cap
#define Cc_service_llc_trf_mode			p_cc_service -> llc.trf_mode
#define Cc_service_llc_trf_rate			p_cc_service -> llc.trf_rate
#define Cc_service_llc_structure		p_cc_service -> llc.structure
#define Cc_service_llc_dest_rate		p_cc_service -> llc.dest_rate

#define Cc_service_llc_protocol_id_1	p_cc_service -> llc.protocol_id_1
#define Cc_service_llc_syn_asyn			p_cc_service -> llc.syn_asyn
#define Cc_service_llc_negotiation		p_cc_service -> llc.negotiation
#define Cc_service_llc_user_rate		p_cc_service -> llc.user_rate

#define Cc_service_llc_protocol_id_2	p_cc_service -> llc.protocol_id_2
#define Cc_service_llc_protocol_id_3	p_cc_service -> llc.protocol_id_3

	/* For ATT_5E5 only */

#define Cc_service_llc_layer_nb			Cc_service_llc_protocol_id_1
#define Cc_service_llc_layer_id			Cc_service_llc_syn_asyn
#define Cc_service_llc_protocol_id		Cc_service_llc_negotiation
#define Cc_service_llc_add_layer_id		Cc_service_llc_user_rate
#define Cc_service_llc_add_protocol_id	Cc_service_llc_protocol_id_2

	/* 1TR6' Service_indicator IE fields */

#define Cc_service_service_ind_service	p_cc_service -> service_indicator.service
#define Cc_service_service_ind_add_info	p_cc_service -> service_indicator.add_info

#define Cc_service_b_mode				p_cc_service -> b_mode

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/* B Channels contexts */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

struct cc_b_chan {
	uchar			used;				/* allocation flag: bit field: bit 1= used, bit 2= held */
	uchar			mode;				/* B channel mode (as defined in ph_int.h) */
	uchar			init_code;			/* last init/stop action code (MPH_B_INIT/STOP_RQ) */
	struct cc_call FAR *p_active_call;	/* pointer to the active call using the B-channel */
	struct cc_call FAR *p_held_call;	/* pointer to the held call sharing the B-channel */
};

#define Cc_access_b_chan(chan_id)		p_cc_b_chan = (struct cc_b_chan FAR *)&(Cc_na_b_chan_ctx [chan_id-1])
#define Cc_access_first_b_chan			p_cc_b_chan = Cc_na_b_chan_ctx
#define Cc_access_next_b_chan			p_cc_b_chan++

#define Cc_b_chan_used					p_cc_b_chan -> used
#define Cc_b_chan_mode					p_cc_b_chan -> mode
#define Cc_b_chan_init_code				p_cc_b_chan -> init_code
#define Cc_b_chan_p_active_call			p_cc_b_chan -> p_active_call
#define Cc_b_chan_p_held_call			p_cc_b_chan -> p_held_call

	/* values for 'used' field */

#define CC_B_CHAN_FREE					0	/* B-channel is free */
#define CC_B_CHAN_USED					1	/* B-channel is used */
#define CC_B_CHAN_HELD					2	/* B-channel is held */

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/*     NA contexts     */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

struct cc_na {
	nai_t 				int_nai;								/* network access identifier */
	nai_t				mph_nai;								/* nai to be sent to physical layer */
	uchar				type;									/* access type (BRI/PRI) */
	uchar				function;								/* functional grouping (FG_TE_NT/FG_NT_TE) */
	uchar 				network;								/* network operator */
	ushort				country;								/* country */
	uchar				call_nb;								/* number of call contexts */
	uchar				uui_recognition;						/* UUI recognition flag */
	ushort				in_calls_behaviour;						/* Incoming calls behaviour */
	ushort				out_calls_behaviour;					/* Outgoing calls behaviour */

	uchar				state;									/* NA state: STATE_ACTIVE/OUT_OF_ORDER */

	char				calling_nb[CC_MX_SZ_CALLING_NB+1]; 		/* calling address for outgoing calls */
	char				calling_sub_add[CC_MX_SZ_CALLING_SUB_ADD+1]; /* calling sub-address for outgoing calls */

#if CC_OVERLAP_RECEIVING == ON
	uchar				nb_digits_to_route;						/* nb of digits to route the call */
#endif

	uchar				deflection_flag;						/* deflection flag ON or OFF */
	char				deflection_address[ACU_MX_SZ_CALLED_NB+1];	/* deflection called address for outgoing calls */
	char				deflection_subaddress[ACU_MX_SZ_CALLED_SUB_ADD+1];/* deflection called subaddress for outgoing calls */

	uchar				hold_nb;								/* nb of held calls */

	uchar				local_nb_service_nb;					/* number of local_nb/service associations */

	struct na_called_nb_service {
		uchar				service_list_id;						/* service list id associated with the services list */
		uchar				priority;								/* service list priority (0..255) */
		uchar				b_chan_id;								/* Associated B channel id if needed (0 means 'any channel') */
		ent_id_t			ns_upper_ent;							/* NS upper entity id for NS_CONN_IN redirection */
		ent_id_t			ent_user;								/* user entity used for incoming calls */
		ent_id_t			sapi_user;								/* user sapi   used for incoming calls */
		char				local_nb[CC_MX_SZ_CALLED_NB+1]; 		/* local address for address filtering */
		char				local_sub_add[CC_MX_SZ_CALLED_SUB_ADD+1];/* local sub-address for sub-address filtering */
		CONST struct cc_service FAR *t_cc_services[CC_MX_SERVICES+1];/* list of allowed services */
		struct cc_profile FAR *t_cc_profiles[CC_MX_SERVICES+1];		/* list of associated profiles */
	} na_called_nb_service_tab [CC_MX_ADD_LOCAL_NB+1];				/* list of called number-services associations */

		/*
			B channels objects:
			allocated at the end of the NA structure.
		*/

	uchar				nb_b_chan;								/* nb of channel objects */
	struct cc_b_chan	b_chan_ctx[1];							/* first B channel object */

		/* Here are the next B channel objects */
};

#define X_DEFAULT_SERVICE_LIST			0						/* default service list index */

				/* Access to current NA values using p_cc_na pointer */

#define Nai								p_cc_na -> int_nai
#define Na_mph_nai						p_cc_na -> mph_nai
#define Cc_na_type 						p_cc_na -> type
#define Cc_na_function					p_cc_na -> function
#define	Cc_na_network					p_cc_na -> network
#define	Cc_na_country					p_cc_na -> country
#define Cc_na_call_nb					p_cc_na -> call_nb
#define Cc_na_uui_recognition			p_cc_na -> uui_recognition

#define Cc_na_in_calls_behaviour		p_cc_na -> in_calls_behaviour
#define Cc_na_out_calls_behaviour		p_cc_na -> out_calls_behaviour

#define Cc_na_state						p_cc_na -> state

#define Cc_na_a_calling_nb				p_cc_na -> calling_nb
#define Cc_na_a_calling_sub_add			p_cc_na -> calling_sub_add

#define Cc_na_nb_digits_to_route		p_cc_na -> nb_digits_to_route

#define Cc_na_deflection_flag			p_cc_na -> deflection_flag
#define Cc_na_deflection_address		p_cc_na -> deflection_address
#define Cc_na_deflection_subaddress		p_cc_na -> deflection_subaddress

#define Cc_na_b_chan_ctx				p_cc_na -> b_chan_ctx
#define Cc_na_nb_b_chan					p_cc_na -> nb_b_chan

#define Cc_na_hold_nb					p_cc_na -> hold_nb

#define Cc_na_local_nb_service_nb		p_cc_na -> local_nb_service_nb

#define Cc_na_service_list_id(i)		(p_cc_na -> na_called_nb_service_tab[i].service_list_id)
#define Cc_na_a_local_nb(i)				(p_cc_na -> na_called_nb_service_tab[i].local_nb)
#define Cc_na_a_local_sub_add(i)		(p_cc_na -> na_called_nb_service_tab[i].local_sub_add)
#define Cc_na_ns_upper_ent(i)			(p_cc_na -> na_called_nb_service_tab[i].ns_upper_ent)
#define Cc_na_ent_user(i)				(p_cc_na -> na_called_nb_service_tab[i].ent_user)
#define Cc_na_sapi_user(i)				(p_cc_na -> na_called_nb_service_tab[i].sapi_user)
#define Cc_na_priority(i)				(p_cc_na -> na_called_nb_service_tab[i].priority)
#define Cc_na_b_chan_id(i)				(p_cc_na -> na_called_nb_service_tab[i].b_chan_id)

#define Cc_na_p_cc_service(i,j)			(p_cc_na -> na_called_nb_service_tab[i].t_cc_services[j])
#define Cc_na_service_id(i,j)			(p_cc_na -> na_called_nb_service_tab[i].t_cc_services[j] -> service_id)

#define Cc_na_p_cc_profile(i,j)			(p_cc_na -> na_called_nb_service_tab[i].t_cc_profiles[j])

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/*    CALL contexts    */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

struct cc_call {
	conn_id_t					conn_id;			/* Connection ID */
	ent_id_t					ent_user;			/* User entity using the call */
	sapi_t						sapi_user;			/* Service Access Point ID of user entity */

	uchar						state;				/* automaton state */
	uchar						previous_state;		/* automaton state */

	uchar						hold_state;			/* call held ON/OFF */

#	if (NS_HOLD_RETRIEVE == ON) && (NS_SS_ECT == ON)
		short					asn1_invoke_id;		/* currently used ASN1 invoke id used */
#	endif

	uchar						b_chan_nb;			/* nb of B-channels handled */
	add_t						b_chan_list[CC_NB_CHAN_ID_SENT]; /* B channel list */
	uchar						b_chan_excl;		/* 'pref/excl' field value in 'chan_id' IE */

	uchar						uui_rq;				/* UUI requested or not in outgoing messages */
	uchar						uui_first_response;	/* is it the first response to conn_rq that may contain UUI ? */

		  struct cc_profile FAR	*p_cc_profile;		/* pointer to the CC profile used for the call */
	uchar						x_current_services_list;/* index of the current list of allowed services */
	CONST struct cc_service FAR	*p_cc_service;		/* pointer to the CC service used for the call */

	uchar						service_class;		/* internal service class */
	uchar						local_protocol_id;	/* local protocol id */

	struct layer_1_info			layer_1_info;		/* layer 1 information */

#	if CC_PAR_SEMI_PERMANENT_CIRCUITS == ON
		uchar					semi_permanent_circuit; /* semi-permanent circuit call (ON/OFF) */
#	endif

	uchar						facility_code;		/* facility code */
	code_t						last_msg_to_ns;		/* last request/response primitive sent to NS */
	code_t						last_msg_from_user;	/* last request/response primitive received from the user */

	uchar						clear_cause;		/* saved NS_CLEAR_IN cause for ACU_CLEAR_CO if no cause in NS_CLEAR_CO */

#	if CC_OVERLAP_RECEIVING == ON
		char					build_called_nb		[ACU_MX_SZ_CALLED_NB+1];		/* saved received called nb */
		char					build_called_sub_add[ACU_MX_SZ_CALLED_SUB_ADD+1];/* saved received called sub address */
		uchar					called_sub_add_size;
		uchar					nb_digit_received;	/* nb digit received */
		struct message FAR		*p_conn_in;			/* pointer on the message to be sent to the application */
#	endif

};

		/* Access to the call data using p_cc_call context pointer */

#define Cc_call_conn_id								p_cc_call -> conn_id
#define Cc_call_ent_user							p_cc_call -> ent_user
#define Cc_call_sapi_user							p_cc_call -> sapi_user
#define Cc_call_state								p_cc_call -> state
#define Cc_call_previous_state						p_cc_call -> previous_state
#define Cc_call_b_chan_nb							p_cc_call -> b_chan_nb
#define Cc_call_b_chan_id							Cc_call_b_chan(0)
#define Cc_call_b_chan(i)							p_cc_call -> b_chan_list[i]
#define Cc_call_b_chan_excl							p_cc_call -> b_chan_excl
#define Cc_call_x_current_service_list				p_cc_call -> x_current_services_list
#define Cc_call_p_cc_service						p_cc_call -> p_cc_service
#define Cc_call_p_cc_profile						p_cc_call -> p_cc_profile
#define Cc_call_local_protocol_id					p_cc_call -> local_protocol_id
#define Cc_call_service_class						p_cc_call -> service_class
#define	Cc_call_a_layer_1_info						((struct layer_1_info FAR *)&(p_cc_call -> layer_1_info))
#define	Cc_call_ph_rate								p_cc_call -> layer_1_info.ph_rate
#define	Cc_call_user_rate							p_cc_call -> layer_1_info.user_rate
#define	Cc_call_syn_asyn							p_cc_call -> layer_1_info.syn_asyn
#define	Cc_call_stop_bits							p_cc_call -> layer_1_info.stop_bits
#define	Cc_call_data_bits							p_cc_call -> layer_1_info.data_bits
#define	Cc_call_parity								p_cc_call -> layer_1_info.parity
#define Cc_call_b_chan_mode							Cc_call_p_cc_service -> b_mode
#define Cc_call_uui_rq								p_cc_call -> uui_rq
#define Cc_call_first_conn_rq_uui_response			p_cc_call -> uui_first_response
#define Cc_call_facility_code						p_cc_call -> facility_code
#define Cc_call_last_msg_to_ns						p_cc_call -> last_msg_to_ns
#define Cc_call_last_msg_from_user					p_cc_call -> last_msg_from_user
#define Cc_call_clear_cause							p_cc_call -> clear_cause
#define Cc_call_hold_state							p_cc_call -> hold_state

#if (NS_HOLD_RETRIEVE == ON) && (NS_SS_ECT == ON)
#	define Cc_call_asn1_invoke_id					p_cc_call -> asn1_invoke_id
#endif

#if CC_PAR_SEMI_PERMANENT_CIRCUITS == ON
#	define Cc_call_semi_permanent_circuit			p_cc_call -> semi_permanent_circuit
#endif

#define	Cc_call_a_build_called_nb					&(p_cc_call -> build_called_nb[0])
#define	Cc_call_a_build_called_sub_add				&(p_cc_call -> build_called_sub_add[0])
#define	Cc_call_called_sub_add_size					p_cc_call -> called_sub_add_size
#define	Cc_call_nb_digit_rcv						p_cc_call -> nb_digit_received
#define	Cc_call_p_conn_in							p_cc_call -> p_conn_in

	/* Call related actions macros */

#define Cc_set_state(new_state)						cc_set_state (new_state)

#define Cc_call_current_exist						(p_cc_call != P_NIL && Cc_call_state != STATE_NULL)
#define Cc_call_clear()								cc_call_clear ()

#define Cc_set_ns_error(class, value)				cc_set_ns_error  (class, value)
#define Cc_set_cc_error(value)						cc_set_cc_error  (value)
#define Cc_set_acu_error(value)						cc_set_acu_error (value)

#define Cc_set_error(sapi, ns_class, ns_value, cc_value, acu_value) \
			cc_set_error (sapi, ns_class, ns_value, cc_value, acu_value)

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/*   Profile contexts  */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

struct cc_profile {

	struct cc_profile FAR *p_next;		/* pointer to the next profile */

	uchar profile_id;					/* profile id */

	uchar service_id;					/* associated service id */

		/* MPH_B_SWITCH_RQ-related parameters */

	uchar    switch_enable;				/* enable sending of MPH_B_SWITCH_RQ (ON) or not (OFF) */

		/* MPH_B_INIT_RQ-related parameters */

	uchar    init_enable;				/* enable sending of MPH_B_INIT_RQ (ON) or not (OFF) */
	ent_id_t init_l2_ent_id;			/* layer 2 entity id */
	ent_id_t init_l3_ent_id;			/* layer 3 entity id */

};

#define Cc_profile_id					p_cc_profile -> profile_id
#define Cc_profile_service_id			p_cc_profile -> service_id

#define Cc_profile_switch_rq_enable		p_cc_profile -> switch_enable

#define Cc_profile_init_rq_enable		p_cc_profile -> init_enable
#define Cc_profile_init_rq_l2_ent_id	p_cc_profile -> init_l2_ent_id
#define Cc_profile_init_rq_l3_ent_id	p_cc_profile -> init_l3_ent_id

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-=-*/
					/*                       */
					/*      Internal ids     */
					/*                       */
					/*-=-=-=-=-=-=-=-=-=-=-=-*/

	/*
		These values are used in CC internal structures, for the
		different services descriptions (see cc_serv.xxx files).

		It is translated at both receiving and sending time.
	*/

#define CC_SRV_VOICE				CC_SERVICE_TELEPHONY
#define CC_SRV_DATA					CC_SERVICE_DATA_HDLC
#define CC_SRV_X25					CC_SERVICE_X25
#define CC_SRV_FAX					CC_SERVICE_FAX_3
#define CC_SRV_FAX_4				CC_SERVICE_FAX_4
#define CC_SRV_MODEM				CC_SERVICE_AUDIO_MODEM
#define CC_SRV_AUDIO_7				CC_SERVICE_AUDIO_7
#define CC_SRV_DATA_TRANSPARENT		CC_SERVICE_DATA_TRANSPARENT
#define	CC_SRV_DATA_56KBS			CC_SERVICE_DATA_56KBS
#define	CC_SRV_DATA_H0				CC_SERVICE_DATA_H0
#define	CC_SRV_DATA_H11				CC_SERVICE_DATA_H11
#define	CC_SRV_DATA_H12				CC_SERVICE_DATA_H12
#define	CC_SRV_DATA_MULTIRATE		CC_SERVICE_DATA_MULTIRATE
#define	CC_SRV_DATA_128KBS			CC_SERVICE_DATA_128KBS
#define CC_SRV_VOICE_TRANSPARENT	CC_SERVICE_TRANSPARENT
#define CC_SRV_X25_PACKET			CC_SERVICE_X25_PACKET
#define CC_SRV_V110					CC_SERVICE_V110
#define CC_SRV_V120					CC_SERVICE_V120
#define CC_SRV_VIDEO				CC_SERVICE_VIDEO
#define CC_SRV_TDD					CC_SERVICE_TDD

#define CC_SRV_NIL					CC_SERVICE_NIL

	/*
		Service Classes :
		allows partial or total compatibility checking with incoming calls.
	*/

#define CC_SRV_CLASS_MULTI_CHAN		'M'		/* Multi channels-type services */
#define CC_SRV_CLASS_DATA			'D'		/* Data-type services */
#define CC_SRV_CLASS_VOICE			'V'		/* Voice-type services */

	/* Check-flag values for services scanning function */

#define CC_CHECK_CLASS				'C'		/* Check service Class only */
#define CC_CHECK_SERVICE			'S'		/* Check service id */

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/*      Trap codes     */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

#define TRAP_CC_ERROR				400		/* CC generic error */
#define TRAP_CC_NS_MSG_CODING		404		/* NS primitive coding error */
#define	TRAP_CC_INIT				407		/* Initialization error */
#define	TRAP_CC_PROC_ERROR			408		/* case in Net_xxx function not provided (internal error) */
#define	TRAP_CC_BUILD_ERROR			409		/* try to build a message not available for the selected operator (internal error) */
#define TRAP_CC_B_CHAN				410		/* B-channel/call contexts integrity problem */

/*-------------------------------------------------------------------------*/

					/*
						Msg/Buffer allocation macro :

						ACU uses 'p_data' as data pointer for
						macro access, while CC uses 'p_cc_data'.
					*/


#if CC_INTERFACE == ON
#	define Cc_alloc_data(size)		p_cc_data = cc_alloc_data (size)
#endif

#if ACU_INTERFACE == ON
#	define Acu_alloc_data(size)		p_data    = cc_alloc_data (size)
#endif

/*-------------------------------------------------------------------------*/

					/* Definition of CC_MX_NETWORK_NB */

#define	CC_MX_NETWORK_NB					(CC_NETWORK_NB + 1)


		/*
		 * CC_ONE_NETWORK :
		 *	- When set to ON, means that this version is equivalant to a
		 *		single network version. For every Nai the NETWORK OPERATOR
		 *		must be the same. It can be one of those for which the flag
		 *		has been set to ON in CC_PAR.H file.
		 *	- When set to OFF, means that, for any Nai,	you can select
		 *		at config time one of the NETWORK OPERATORS for which
		 *		the flag has been set to ON in CC_PAR.H file.
		 */

#if CC_NETWORK_NB == 1
#	define	CC_ONE_NETWORK				ON
#else
#	define	CC_ONE_NETWORK				OFF
#endif

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-=-*/
					/*                       */
					/*   Network dependent   */
					/* parameters management */
					/*                       */
					/*-=-=-=-=-=-=-=-=-=-=-=-*/

struct cc_param {
	uchar 	called_sub_add;				/* process the called sub address filtering */
	uchar 	calling_sub_add;			/* process the calling sub address filtering */
	uchar	class_incompatible;			/* Cause class for INCOMPATIBLE DESTINATION clearing cause */
	uchar	val_incompatible;			/* Cause value for INCOMPATIBLE DESTINATION clearing cause */
	uchar 	spf_fac;					/* Network Specific Facilities implemented */
	uchar 	att_hcdt_fac;				/* AT&T HCDT Specific Facilities implemented */
	uchar	uui;						/* process the uui */
	uchar	uui_in_alert;				/* uui in Alert message ? */
	uchar	overlap_rcv;				/* process the overlap receiving */
	uchar	suspend_resume;				/* process the suspend/resume */
	uchar	restart_procedure;			/* process the restart procedures */
	uchar	sup_services;				/* process the supplementary services */
	uchar	channel_id_in_setup;		/* send a channel ID in the setup message (TE only) */
	uchar	chan_id_in_first_rs;		/* chan_id in first response to incoming call */
	uchar	d_chan_id;					/* D-channel time-slot number */
	uchar	b_chan_nb;					/* Max B-channel time-slot in PRI */
	uchar	nt_call_proc_rq;			/* Force NS_CALL_PROC_RQ in NT side (ON/OFF) */
	uchar	keypad_implemented;			/* Keypad IE implemented ? (ON/OFF) */
	uchar   ETSI_ASN1_fac;				/* ETSI ASN1 facilities support (ON/OFF) */
};

#define	Called_sub_add_used				Cc_param_val -> called_sub_add
#define	Calling_sub_add_used			Cc_param_val -> calling_sub_add
#define	Class_incompatible				Cc_param_val -> class_incompatible
#define	Val_incompatible				Cc_param_val -> val_incompatible
#define	Spf_fac_used					Cc_param_val -> spf_fac
#define	Att_hcdt_fac_used				Cc_param_val -> att_hcdt_fac
#define	Uui_used						Cc_param_val -> uui
#define	Uui_in_alert					Cc_param_val -> uui_in_alert
#define	Overlap_rcv_used				Cc_param_val -> overlap_rcv
#define	Suspend_resume_used				Cc_param_val -> suspend_resume
#define	Restart_procedure_used			Cc_param_val -> restart_procedure
#define	Sup_services_used				Cc_param_val -> sup_services
#define	Channel_id_in_setup_used		Cc_param_val -> channel_id_in_setup
#define	Channel_id_in_first_rs			Cc_param_val -> chan_id_in_first_rs
#define	D_chan_id						Cc_param_val -> d_chan_id
#define B_chan_nb						Cc_param_val -> b_chan_nb
#define Force_ns_call_proc_rq_in_nt		Cc_param_val -> nt_call_proc_rq
#define Cc_param_keypad_implemented		Cc_param_val -> keypad_implemented
#define Cc_param_ETSI_ASN1_fac_support	Cc_param_val -> ETSI_ASN1_fac

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-=-*/
					/*                       */
					/*   Network dependent   */
					/*  Specific  functions  */
					/*      management       */
					/*                       */
					/*-=-=-=-=-=-=-=-=-=-=-=-*/

struct cc_uchar_fct_table {

#	if ASSERT == ON
		uchar		idx;
#	endif

#	if NEW_FCT_STYLE == ON
		uchar	(*fct)	(void);
#	else
		uchar	(*fct)	();
#	endif

};

#define Uchar_cc_fct(fct_key)					p_cc_uchar_fct_table[fct_key].fct
#define Exec_cc_uchar_fct(fct_key)				p_cc_uchar_fct_table[fct_key].fct()
#define Idx_cc_uchar(fct_key)					p_cc_uchar_fct_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct cc_uchar_fct_1p_table {

#	if ASSERT == ON
		uchar		idx;
#	endif

#	if NEW_FCT_STYLE == ON
		uchar	(*fct)	(code_t p1, uchar FAR *p_data);
#	else
		uchar	(*fct)	();
#	endif

};

#define Uchar_cc_fct_1p(fct_key)				p_cc_uchar_fct_1p_table[fct_key].fct
#define Exec_cc_uchar_fct_1p(fct_key,p1,p_data)	p_cc_uchar_fct_1p_table[fct_key].fct(p1, p_data)
#define Idx_cc_uchar_1p(fct_key)				p_cc_uchar_fct_1p_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct cc_uchar_fct_2uc_table {

#	if ASSERT == ON
		uchar		idx;
#	endif

#	if NEW_FCT_STYLE == ON
		uchar	(*fct)	(uchar p1, uchar p2);
#	else
		uchar	(*fct)	();
#	endif

};

#define Uchar_cc_fct_2uc(fct_key)				p_cc_uchar_fct_2uc_table[fct_key].fct
#define Exec_cc_uchar_fct_2uc(fct_key,p1,p2)	p_cc_uchar_fct_2uc_table[fct_key].fct(p1,p2)
#define Idx_cc_uchar_2uc(fct_key)				p_cc_uchar_fct_2uc_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct cc_uchar_fct_3uc_table {

#	if ASSERT == ON
		uchar		idx;
#	endif

#	if NEW_FCT_STYLE == ON
		uchar	(*fct)	(uchar p, uchar q, uchar r);
#	else
		uchar	(*fct)	();
#	endif

};

#define Uchar_cc_fct_3uc(fct_key)				p_cc_uchar_fct_3uc_table[fct_key].fct
#define Exec_cc_uchar_fct_3uc(fct_key,p,q,r)	p_cc_uchar_fct_3uc_table[fct_key].fct(p,q,r)
#define Idx_cc_uchar_3uc(fct_key)				p_cc_uchar_fct_3uc_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct cc_p_fct_2uc_table {

#	if ASSERT == ON
		uchar		idx;
#	endif

#	if NEW_FCT_STYLE == ON
		uchar	FAR * (*fct)	(uchar p1, uchar p2);
#	else
		uchar	FAR * (*fct)	();
#	endif

};

#define P_cc_fct_2uc(fct_key)					p_cc_p_fct_2uc_table[fct_key].fct
#define Exec_cc_p_fct_2uc(fct_key,p1,p2)		p_cc_p_fct_2uc_table[fct_key].fct(p1,p2)
#define Idx_cc_p_2uc(fct_key)					p_cc_p_fct_2uc_table[fct_key].idx

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#if ASSERT == ON
#	define	Put_cc_fct(a,b)						{a,b}
#else
#	define	Put_cc_fct(a,b)						{b}
#endif

#define F_NIL								0

#define	F_UC_NET_CHECKING_SERVICE			0
#define	MX_CC_UCHAR_FCT_NB					1

#define	F_UC_1P_CC_BUILD_TO_NS				0
#define	MX_CC_UC_FCT_1P_NB					1

#define	F_UC_1UC_CC_TEST_ADD_MATCH			0
#define	MX_CC_UC_FCT_1UC_NB					1

#define	F_UC_2UC_GET_IE         			0
#define	F_UC_2UC_ISDN_LGTH_STR              1
#define	F_UC_2UC_CC_GET_CHAN_ID				2
#define	F_UC_2UC_SET_TO_NEXT_IE_INSTANCE	3
#define	F_UC_2UC_GET_REMAINING_IE_INSTANCE	4
#define	MX_CC_UC_FCT_2UC_NB					5

#define	F_UC_3UC_ISDN_GET_VAL				0
#define	MX_CC_UC_FCT_3UC_NB					1

#define	F_P_2UC_ISDN_P_STR					0
#define	MX_CC_P_FCT_2UC_NB					1

#define	Net_checking_service()				(Exec_cc_uchar_fct				(F_UC_NET_CHECKING_SERVICE))

#define	Cc_build_to_ns(p1,p_data)			(Exec_cc_uchar_fct_1p			(F_UC_1P_CC_BUILD_TO_NS, p1, p_data))

#define	Net_get_ie(p1,p2)					(Exec_cc_uchar_fct_2uc			(F_UC_2UC_GET_IE, p1, p2))
#define	Net_isdn_lgth_str(p1,p2)			(Exec_cc_uchar_fct_2uc			(F_UC_2UC_ISDN_LGTH_STR, p1, p2))
#define	Cc_get_chan_id(p1,p2)				(Exec_cc_uchar_fct_2uc			(F_UC_2UC_CC_GET_CHAN_ID, p1, p2))
#define	Net_set_to_next_ie_instance(p1,p2) 	(Exec_cc_uchar_fct_2uc			(F_UC_2UC_SET_TO_NEXT_IE_INSTANCE, p1, p2))
#define	Net_get_remaining_ie_instance(p1,p2) (Exec_cc_uchar_fct_2uc			(F_UC_2UC_GET_REMAINING_IE_INSTANCE, p1, p2))

#define	Net_isdn_get_val(p1,p2,p3)			(Exec_cc_uchar_fct_3uc			(F_UC_3UC_ISDN_GET_VAL, p1, p2, p3))

#define	Net_isdn_p_str(p1,p2)				(Exec_cc_p_fct_2uc				(F_P_2UC_ISDN_P_STR, p1, p2))

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Table describing the compiled networks */

struct cc_net_presence {

#if SIMULATION == ON
	uchar	operator_idx;
#endif

	uchar	presence;
};

#define	Cc_net_table_presence(op)			T_CC_NET_PRESENCE[op].presence

#if SIMULATION == ON
#	define Put_cc_net_presence(op_idx, net)	{op_idx, net}
#else
#	define Put_cc_net_presence(op_idx, net)	{net}
#endif
			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Table used to know what networks have been configured */

#if RESET_CONFIG == ON

struct cc_net_config {
	uchar	config;						/* ON/OFF */
	uchar	idx;						/* ets, vn6, ni2, ... */
	uchar	nb_time;					/* nb of times an operator was selected */
};

	extern struct cc_net_config				t_cc_net_config [];

#	define	Cc_net_table_config(op)			t_cc_net_config[op].config
#	define	Cc_net_table_idx(op)			t_cc_net_config[op].idx
#	define	Cc_net_table_nb_time(op)		t_cc_net_config[op].nb_time

#else

	extern uchar							t_cc_net_config	[];

#	define	Cc_net_table_config(op)			t_cc_net_config[op]
#endif

			/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct cc_fct_table {
	uchar FAR				*param;				/* array of specific parameters */
	uchar FAR				*v_f_tab;			/* void function without parameter */
	uchar FAR				*u_f_tab;			/* uchar function without parameter */
	uchar FAR				*u_f_1p_tab;		/* uchar function with 1 parameter */
	uchar FAR				*u_f_2uc_tab;		/* uchar function with 2 uchar parameters */
	uchar FAR				*u_f_3uc_tab;		/* uchar function with 3 uchar parameters */
	uchar FAR				*p_f_2uc_tab;		/* uchar FAR * function with 2 uchar parameters */
	struct cc_service FAR	*p_serv;			/* specific services table */
};

#define	Spf_cc_param_tab(net_id)		t_cc_net_spf_fct[net_id].param
#define	Spf_cc_services(net_id)			(t_cc_net_spf_fct[net_id].p_serv)
#define	Spf_cc_void_fct(net_id)			t_cc_net_spf_fct[net_id].v_f_tab
#define	Spf_cc_uchar_fct(net_id)		t_cc_net_spf_fct[net_id].u_f_tab
#define	Spf_cc_uchar_fct_1p(net_id)		t_cc_net_spf_fct[net_id].u_f_1p_tab
#define	Spf_cc_uchar_fct_2uc(net_id)	t_cc_net_spf_fct[net_id].u_f_2uc_tab
#define	Spf_cc_uchar_fct_3uc(net_id)	t_cc_net_spf_fct[net_id].u_f_3uc_tab
#define	Spf_cc_p_fct_2uc(net_id)		t_cc_net_spf_fct[net_id].p_f_2uc_tab

#define	T_cc_services(xx)				(struct cc_service FAR *)&(Spf_cc_services(Cc_na_network)[xx])

#define	Cc_param_val					(p_cc_param)

extern struct cc_fct_table				t_cc_net_spf_fct[];	/* table which contains for each network, the specific function addresses */

/*-------------------------------------------------------------------------*/

					/*-=-=-=-=-=-=-=-=-=-=-=-*/
					/*                       */
					/* Functions  prototypes */
					/*                       */
					/*-=-=-=-=-=-=-=-=-=-=-=-*/

#if NEW_FCT_STYLE == ON

		/* cc.c routines: */

	uchar	cc_reset_config			(void);
	void	cc_del_tree				(struct node FAR *p_node);

		/* cc_accss.c routines: */

	uchar	cc_build_object			(struct cc_config FAR *p_cc_config);
	uchar	cc_access_na			(nai_t nai);
	void	cc_access_first_na		(void);
	void	cc_access_next_na		(void);
	uchar	cc_access_conn_id		(conn_id_t conn_id);
	void	cc_access_first_call	(void);
	void	cc_access_next_call		(void);
	struct cc_profile FAR *cc_access_profile (uchar profile_id);
	void	cc_in_queue             (struct message FAR *p_msg);
	struct message FAR *cc_out_queue (void);

		/* cc_rcv.c routines: */

	uchar	cc_rcv					(void);

		/* cc_snd.c routines: */

	uchar	cc_snd_to_ns			(code_t pr_id);
	void	cc_snd_to_mph			(code_t code);
	void	cc_retransmit_to_user  	(code_t pr_id);
	void	cc_snd_to_user			(code_t pr_id);
	uchar 	FAR *cc_alloc_data 		(ushort size);
	void	cc_snd_acu_err_in		(uchar cause, uchar diag);

		/* cc_switc.c routines: */

	uchar	cc_switch				(void);

		/* cc_state.c routines: */

	void	cc_state_driven			(void);

		/* cc_proc.c routines: */

	void	cc_error_process		(void);
	void	cc_set_ns_error			(uchar ns_cause_class, uchar ns_cause_value);
	void	cc_set_cc_error			(uchar value);
	void	cc_set_acu_error		(uchar value);
	void	cc_set_error			(sapi_t sapi, uchar ns_class, uchar ns_value, uchar cc_value, uchar acu_value);
	void	cc_call_clear			(void);
	void	cc_set_state			(uchar new_state);
	void	cc_retrieve_previous_state (void);
	CONST struct cc_service FAR *get_p_cc_service (uchar check_key, uchar service_id_or_class);
	uchar	cc_service_to_class		(uchar cc_service_id);
	CONST struct cc_service FAR *cc_access_service (uchar internal_service_id);
	void	cc_reset_temp_layer_1_info (void);
	void 	cc_reset_call_layer_1_info (void);
	void	cc_get_layer_1_info_from_msg(struct layer_1_info FAR *p_layer_1_info);
	void	cc_put_layer_1_info_from_temp(struct layer_1_info FAR *p_layer_1_info);
	void	cc_read_cause_from_ns	(code_t code);
	void	cc_read_called_nb_from_ns (code_t code);
	void	cc_read_called_sub_add_from_ns (code_t code);
	void	cc_read_display_from_ns (code_t code);
#if (ACU_INTERFACE == ON) && (CC_PAR_DISPLAY_IE == ON)
	void	cc_read_display_from_acu(struct acu_display_list FAR *a_display_list);
#endif
#if CC_UUI == ON
	void	cc_read_uui_from_ns		(code_t code);
#endif
	void	cc_read_keypad_from_ns	(code_t code);
	void	cc_read_facility_from_ns (code_t code);
#if CC_PAR_PROGRESS_IND_IE == ON
	void	cc_read_progress_ind_from_ns (code_t code);
	void	cc_read_progress_ind_from_acu (struct acu_progress_ind FAR *p_progress_ind);
	void 	cc_store_progress_ind	(struct acu_progress_ind FAR *p_progress_ind);
#endif
#if CC_PAR_SIGNAL_IE == ON
	void	cc_read_signal_from_ns	(code_t code);
#endif
#if ARINC_NETWORKS == ON
	void	cc_read_credit_card_nb_from_ns (code_t code);
	void	cc_read_credit_card_status_from_ns (code_t code);
#endif
#if CC_PAR_REDIR_NB == ON
	void	cc_read_redir_nb_from_ns (code_t code);
	void	cc_store_redir_nb_in_acu_prim (struct acu_redir_nb FAR *p_acu_redir_nb, char FAR *p_acu_redir_nb_string);
#endif
	void	cc_read_chan_id_from_ns	(code_t code);
	uchar	cc_process_chani_list_from_acu (struct chani_list FAR *p_chani_list);
	uchar	cc_read_chani_list_from_acu	(struct chani_list FAR *p_chani_list);
	void	cc_alloc_chan_list		(struct chani_list FAR *p_chani_list);
	void	cc_write_call_chan_list_to_acu (struct chani_list FAR *p_chani_list);
	void	cc_chani_list_to_map	(void);
	void	cc_chani_map_to_list	(uchar map_lgth, uchar FAR *p_map);
	void	cc_reset_call_b_chan	(void);
	uchar	cc_find_free_b_chan		(void);
	uchar	cc_find_single_free_b_chan(void);
	void	cc_alloc_b_chan			(uchar chan_id);
	void	cc_free_b_chan			(uchar chan_id);
	uchar	cc_alloc_b_chan_if_allowed (void);
	void	cc_b_switch				(uchar channel_id, uchar mode, uchar tone_id);
	void	cc_b_init_stop			(code_t code);
	void	cc_snd_ced				(void);
	void	cc_decode_address		(char FAR *FAR *p_p_address, char FAR *FAR *p_p_subaddress);
	void	cc_build_address		(char FAR *p_in_number, char FAR *p_in_subaddress, char FAR *p_out_address);
	uchar	strcmp_reverse			(uchar FAR *p_s1, uchar FAR *p_s2);
	signed char	cc_address_filtering(signed char x_local_nb);
	uchar	cc_test_chan_id_match	(signed char x_local_nb);
	uchar	cc_test_address_match	(signed char x_local_nb);
	short	cc_strlen				(char FAR *p_str);
	uchar	cc_restart_chan_id		(uchar flag);
#if CC_PAR_CHARGING_INFO == ON
	void	cc_read_charging_value_from_ns (code_t prim_code);
#endif
#if CC_PAR_DATE_TIME == ON
	void	cc_read_date_time_from_ns (code_t prim_code);
#endif
#if ACU_PAR_EXTENDED_PRIM == ON
	void	cc_read_ext_parms_from_acu (uchar FAR *p_data);
	void    cc_store_ext_data_in_acu_prim (uchar FAR *p_data, uchar FAR *a_end_strings);
	uchar FAR *cc_init_acu_ext_descriptor (uchar FAR *p_data, uchar FAR *p_ext_data);
	uchar FAR *cc_append_ext_data_to_acu (uchar FAR *p_data, uchar FAR *p_ext_data, char FAR *p_from, ushort ext_lgth, ushort ext_nb);
	void	cc_store_ext_fac_asn1_in_ns_prim (uchar first_component);
#endif
#if ACU_PAR_EXT_LLC == ON
	void	cc_read_ext_llc_from_ns (code_t prim_code);
#endif
#if _ACU_PAR_EXT_FACILITY == ON
	void	cc_read_ext_facility_from_ns(code_t prim_code);
#endif
#if ACU_PAR_EXTENDED_PRIM == ON
	void	cc_add_i_ext_fac_asn1	(uchar FAR *p_from, ushort lgth, ushort component_nb);
#endif
#if ACU_PAR_EXT_CUG == ON
	void	cc_read_cug_from_ns		(code_t prim_code);
#endif
#if (NS_HOLD_RETRIEVE == ON) && (NS_SS_ECT == ON)
	short	cc_allocate_asn1_invoke_id (add_t conn_id);
	void	cc_free_asn1_invoke_id	(add_t conn_id, short invoke_id);
#endif
#if CC_PAR_DISPLAY_IE == ON
	void 	cc_store_display 		(struct acu_display_list FAR * p_display, char FAR *p_start);
#endif
	uchar	cc_check_network		(uchar na_op, uchar cc_op, ushort na_country, ushort cc_country);
	uchar	cc_get_network			(uchar net, ushort country);
	uchar 	cc_get_net_idx			(uchar net);

#if RESET_CONFIG == ON
	uchar	cc_dec_net_idx			(uchar net_idx);
#endif

	void	cc_build_fct 			(uchar op);
	void	cc_reset_op_idx			(void);
	uchar	cc_build_p_table		(void);

#if _CC_SPID_INFO == ON
	void	cc_read_spid_from_ns 	(code_t prim_code);
#endif


#	if SIMULATION == ON

			/* ana_cc.c routines: */

		void	pr_cc_version		(void);
		void	pr_cc_state			(void);
		void	pr_cc_service_id	(void);
		void	pr_cc_x_address_list (uchar x_local_nb);
		void	pr_cc_wrong_b_chan	(void);
		void	pr_cc_alloc_b_chan	(uchar chan_id);
		void	pr_cc_free_b_chan	(uchar chan_id);

#	endif

#else

		/* cc.c routines: */

	uchar	cc_reset_config			();
	void	cc_del_tree				();

		/* cc_accss.c routines: */

	uchar	cc_build_object			();
	uchar	cc_access_na			();
	void	cc_access_first_na		();
	void	cc_access_next_na		();
	uchar	cc_access_conn_id		();
	void	cc_access_first_call	();
	void	cc_access_next_call		();
	struct cc_profile FAR *cc_access_profile ();
	void	cc_in_queue             ();
	struct message FAR *cc_out_queue ();

		/* cc_rcv.c routines: */

	uchar	cc_rcv					();

		/* cc_snd.c routines: */

	uchar	cc_snd_to_ns			();
	void	cc_snd_to_mph			();
	void	cc_retransmit_to_user  	();
	void	cc_snd_to_user			();
	uchar 	FAR *cc_alloc_data 		();
	void	cc_snd_acu_err_in		();

		/* cc_switc.c routines: */

	uchar	cc_switch				();

		/* cc_state.c routines: */

	void	cc_state_driven			();

		/* cc_proc.c routines: */

	void	cc_error_process		();
	void	cc_set_ns_error			();
	void	cc_set_cc_error			();
	void	cc_set_acu_error		();
	void	cc_set_error			();
	void	cc_call_clear			();
	void	cc_set_state			();
	void	cc_retrieve_previous_state ();
	CONST struct cc_service FAR *get_p_cc_service ();
	uchar	cc_service_to_class		();
	CONST struct cc_service FAR *cc_access_service ();
	void	cc_reset_temp_layer_1_info ();
	void 	cc_reset_call_layer_1_info ();
	void	cc_get_layer_1_info_from_msg();
	void	cc_put_layer_1_info_from_temp();
	void	cc_read_cause_from_ns	();
	void	cc_read_called_nb_from_ns ();
	void	cc_read_called_sub_add_from_ns ();
	void	cc_read_display_from_ns ();
#if (ACU_INTERFACE == ON) && (CC_PAR_DISPLAY_IE == ON)
	void	cc_read_display_from_acu();
#endif
#if CC_UUI == ON
	void	cc_read_uui_from_ns		();
#endif
	void	cc_read_keypad_from_ns	();
	void	cc_read_facility_from_ns ();
#if CC_PAR_PROGRESS_IND_IE == ON
	void	cc_read_progress_ind_from_ns ();
	void	cc_read_progress_ind_from_acu ();
	void 	cc_store_progress_ind	();
#endif
#if CC_PAR_SIGNAL_IE == ON
	void	cc_read_signal_from_ns	();
#endif
#if ARINC_NETWORKS == ON
	void	cc_read_credit_card_nb_from_ns ();
	void	cc_read_credit_card_status_from_ns ();
#endif
#if CC_PAR_REDIR_NB == ON
	void	cc_read_redir_nb_from_ns ();
	void	cc_store_redir_nb_in_acu_prim ();
#endif
	void	cc_read_chan_id_from_ns	();
	uchar	cc_process_chani_list_from_acu ();
	uchar	cc_read_chani_list_from_acu	();
	void	cc_alloc_chan_list		();
	void	cc_write_call_chan_list_to_acu ();
	void	cc_chani_list_to_map	();
	void	cc_chani_map_to_list	();
	void	cc_reset_call_b_chan	();
	uchar	cc_find_free_b_chan		();
	uchar	cc_find_single_free_b_chan();
	void	cc_alloc_b_chan			();
	void	cc_free_b_chan			();
	uchar	cc_alloc_b_chan_if_allowed ();
	void	cc_b_switch				();
	void	cc_b_init_stop			();
	void	cc_snd_ced				();
	void	cc_decode_address		();
	void	cc_build_address		();
	uchar	strcmp_reverse			();
	signed char	cc_address_filtering();
	uchar	cc_test_chan_id_match	();
	uchar	cc_test_address_match	();
	short	cc_strlen				();
	uchar	cc_restart_chan_id		();
#if CC_PAR_CHARGING_INFO == ON
	void	cc_read_charging_value_from_ns ();
#endif
#if CC_PAR_DATE_TIME == ON
	void	cc_read_date_time_from_ns();
#endif
#if ACU_PAR_EXTENDED_PRIM == ON
	void	cc_read_ext_parms_from_acu ();
	void    cc_store_ext_data_in_acu_prim ();
	uchar FAR *cc_init_acu_ext_descriptor ();
	uchar FAR *cc_append_ext_data_to_acu ();
	void	cc_store_ext_fac_asn1_in_ns_prim ();
#endif
#if ACU_PAR_EXT_LLC == ON
	void	cc_read_ext_llc_from_ns ();
#endif
#if _ACU_PAR_EXT_FACILITY == ON
	void	cc_read_ext_facility_from_ns();
#endif
#if ACU_PAR_EXTENDED_PRIM == ON
	void	cc_add_i_ext_fac_asn1	();
#endif
#if ACU_PAR_EXT_CUG == ON
	void	cc_read_cug_from_ns		();
#endif
#if (NS_HOLD_RETRIEVE == ON) && (NS_SS_ECT == ON)
	short	cc_allocate_asn1_invoke_id ();
	void	cc_free_asn1_invoke_id	();
#endif
#if CC_PAR_DISPLAY_IE == ON
	void 	cc_store_display 		();
#endif
	uchar	cc_check_network		();
	uchar	cc_get_network			();
	uchar 	cc_get_net_idx			();

#if RESET_CONFIG == ON
	uchar	cc_dec_net_idx			();
#endif

	void	cc_build_fct 			();
	void	cc_reset_op_idx			();
	uchar	cc_build_p_table		();

#if _CC_SPID_INFO == ON
	void	cc_read_spid_from_ns 	();
#endif
    
#	if SIMULATION == ON

			/* ana_cc.c routines: */

		void	pr_cc_version		();
		void	pr_cc_state			();
		void	pr_cc_service_id	();
		void	pr_cc_x_address_list ();
		void	pr_cc_wrong_b_chan	();
		void	pr_cc_alloc_b_chan	();
		void	pr_cc_free_b_chan	();

#	endif

#endif

/*EOF*/
