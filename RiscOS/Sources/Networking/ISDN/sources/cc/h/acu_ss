/*--------------------------------------------------------------------------*
 *						M O D U L E   H E A D E R
 *
 * filename - acu_ss.h
 *
 * $Revision$
 *
 * $Date$
 *
 *  Header implementing the upper interface of the CC entity specific to
 *  the SUPPLEMENTARY SERVICES, for the ACU interface of CC only.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Call Control (CC) Entity                         |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef ACU_SS_INT
#	define ACU_SS_INT

/*==========================================================================

			- definition of types used for Supplementary Services -
*/

typedef short		acu_ss_inv_id_t;		/* type for Invoke identifier values -> it matches the ASN1 definition InvokeIdType ::= INTEGER (-32768..32767) */
typedef uchar		acu_ss_op_id_t;			/* type for operation interface identifiers */

/*==========================================================================*/

					/*-=-=-=-=-=-=-=-*/
					/*               */
					/* General rules */
					/*               */
					/*-=-=-=-=-=-=-=-*/

/*

	1. GENERAL ARCHITECTURE OF AN ASN1 FACILITY

	1.1. Content of an ASN1 facility

		- An ASN1 facility is composed of 1 or more "COMPONENTs".

		- A "COMPONENT" is composed of:
			- a component header structure ('struct acu_ss_component')
			- 0 or 1 "OPERATION", depending on the "component tag":
				- "INVOKE"       : always contains an operation
				- "RETURN ERROR" : no operation
				- "RETURN REJECT": no operation
				- "RETURN RESULT": may contain an operation

		- An "OPERATION" is composed of:
			- an operation-specific structure
			- 0 or more "additional information" structures or strings

	1.2. Architecture of the structures

		The structures are stored one after each other using the following
		scheme:

			COMPONENT
				[OPERATION
					[additional info]
					[other additional info...]
				]
					...
			[other COMPONENTs...]


	2. ACCESSING TO A "COMPONENT"

	2.1. Component header pointer: p_ss_component

		A pointer is dedicated to point to the component header structure:

			uchar FAR *p_ss_component;

		All component header fields are then accessed through this pointer,
		using the 'Acu_ss_component(field_name)' macro (read and write).

	2.2. READING a component header

		General algorithm:

		a. Set p_ss_component to point to the component header;

		b. Use the 'Acu_ss_component(field_name)' macros to read the fields
		   of the component header;

		c. if 'Acu_ss_is_operation_available()' is true
		   then
				// an operation is available;
				read the operation; // See 3.2.
		   else
				// no operation is attached to the component

		d. if 'Acu_ss_is_next_comp_available()' is true
		   then
				// another component is available;
				call 'Acu_ss_get_next_comp_address()' to update the
				'p_ss_component' pointer to point to the next
				component header;
				go to b.;
		   else
				// no more component to be read,
				// end of facility processing.


	2.3. WRITING a component header

		General algorithm:

		a. Set p_ss_component to point to the location where to write the
		   component header;

		b. Use one of the following macros to write the component header:
		   - 'Acu_ss_store_comp_invoke()' for an "INVOKE" component
		   - 'Acu_ss_store_comp_return_result()' for a "RETURN RESULT" component
		   - 'Acu_ss_store_comp_return_error()' for a "RETURN ERROR" component
		   - 'Acu_ss_store_comp_reject()' to store a "REJECT" component

		c. if an operation is to be stored
		   then
				store the operation; // see 3.3.
		   else
				call 'Acu_ss_store_no_operation()' to specify that no
				operation is attached to the component;

		d. if another component is to be stored
		   then
				call 'Acu_ss_set_to_next_component()' to update the
				'next_component_offset' field of the current component, and
				the p_ss_component pointer;
				go to b.;
		   else
				// no other component to be stored,
				call 'Acu_ss_set_last_component()' to end the component
				header;
				// end of facility processing.
				// p_ss_info gives the current address of the last byte stored
				// in the facility, which can be used to compute the total
				// length of the ANS1 facility.


	3. ACCESSING TO AN "OPERATION"

	3.1. Operation pointer: p_ss_operation

		A pointer is dedicated to point to the operation related to the
		component beeing processed:

			uchar FAR *p_ss_operation;

		The type of the structure pointed to by p_ss_operation depends on
		the operation itself.

		Macros are defined to access to each field of all types of operations.
		(read and write)

	3.2. READING an operation

		General algorithm:

		a. call 'Acu_ss_get_operation_address()' to set the operation pointer
		   'p_ss_operation' to allow to read the operation itself;

		b. use the operation-specific macros to read the different fields
		   of the operation structure;

		c. if the operation contains some additional info (e.g. in
			'acu_aoc_charging_rq_res' operation, the 'aocs_first_cur_info'
			field gives the offset of the AOCSCurrencyInfo structure attached
			to the ChargingRequest Result operation)

		   then
				read the additional information;
		   else
				// no additional info

		d. // end of operation reading
		   // go to 2.2.d.

	3.3. WRITING an operation

		General algorithm:

		a. use the operation-specific macros to write the different fields
		   of the operation structure;

		b.
			Acu_ss_set_to_end_of_operation(op_struct_name) sets 'p_ss_info' to the
			end of the current operation structure, in order to read or write
			the additional information, or the next component.

*/

/*==========================================================================*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/* Component structure */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

	/* Common structure used for all components in facility IE */

struct acu_ss_component {
	ushort				next_component_offset;			/* offset of common data for next component in Facility IE */
	ushort				component_data_offset;			/* offset of data specific to current component in Facility IE */
	uchar				component_tag;					/* type of component : Invoke / Returnresult / ReturnError / Reject */
	uchar				inv_or_lk_id_or_res_presence;	/* presence of Invoke Identifier (Reject component) or of Linked Identifier
															(Invoke component) or of operation data in ReturnResult component */
	acu_ss_inv_id_t		invoke_id;						/* invoke Identifier */
	acu_ss_inv_id_t		lk_id_or_pb_tag;				/* linked Identifier (Invoke component) or type of problem (Reject component)
															: General / Invoke / ReturnResult / ReturnError */
	acu_ss_op_id_t		op_err_pb_identifier;			/* CC interface identifier of operation or error or problem contained in the component */
};

#define Acu_ss_component(field)				((struct acu_ss_component FAR *)p_ss_component) -> field

		/*---------------------------------*/
		/* Component header READING macros */
		/*---------------------------------*/

	/*
	 *	Acu_ss_is_next_comp_available() is true if another component
	 *	is available, false if no other component is available
	 */
#define Acu_ss_is_next_comp_available()		(Acu_ss_component (next_component_offset) != OFFSET_NIL)

	/*
	 *	Acu_ss_get_next_comp_address() updates the 'p_ss_component'
	 *	pointer to point to the next component header
	 */
#define Acu_ss_get_next_comp_address()		p_ss_component += Acu_ss_component (next_component_offset)

	/*
	 *	Acu_ss_is_operation_available() is true if an operation is
	 *	available, false if no operation is attached to the component
	 */
#define Acu_ss_is_operation_available()		(Acu_ss_component (component_data_offset) != OFFSET_NIL)

	/*
	 *	Acu_ss_get_operation_address() initialises 'p_ss_operation' for
	 *	READING the operation attached to the component
	 */
#define Acu_ss_get_operation_address()		p_ss_operation = p_ss_component + Acu_ss_component (component_data_offset)

		/*---------------------------------*/
		/* Component header WRITING macros */
		/*---------------------------------*/

	/*
	 *	Acu_ss_store_component_header() stores any component
	 *	(generic macro used by all component tag-specific macros)
	 */
#define Acu_ss_store_component_header(tag,inv_lk_id_res_pres,inv,link,op_err_pb)\
			Acu_ss_component (component_tag)                = tag;               \
			Acu_ss_component (inv_or_lk_id_or_res_presence) = inv_lk_id_res_pres;\
			Acu_ss_component (invoke_id)                    = inv;               \
			Acu_ss_component (lk_id_or_pb_tag)              = link;              \
			Acu_ss_component (op_err_pb_identifier)         = op_err_pb;         \
			Acu_ss_component (component_data_offset)        = Rnd_sizeof (struct acu_ss_component);\
			p_ss_info = p_ss_operation = p_ss_component + Rnd_sizeof (struct acu_ss_component)

	/*
	 *	Acu_ss_store_comp_invoke() stores an "INVOKE" component
	 *
	 *		- lk_id_pres = presence of Linked identifier (PRESENT/ABSENT)
	 *		- inv        = Invoke identifier (short)
	 *		- link       = Linked identifier (short)
	 *		- op_id	     = operation identifier
	 */
#define Acu_ss_store_comp_invoke(lk_id_pres,inv,link,op_id) \
			Acu_ss_store_component_header (FAC_INVOKE, lk_id_pres, inv, link, op_id)

	/*
	 *	Acu_ss_store_comp_return_result() stores a "RETURN RESULT" component
	 *
	 *		- op_pres    = presence of operation data (PRESENT/ABSENT)
	 *		- inv        = Invoke identifier (short)
	 *		- op_id	     = operation identifier
	 */
#define Acu_ss_store_comp_return_result(op_pres,inv,op_id) \
			Acu_ss_store_component_header (FAC_RETURN_RESULT, op_pres, inv, 0, op_id)

	/*
	 *	Acu_ss_store_comp_return_error() stores a "RETURN ERROR" component
	 *
	 *		- inv        = Invoke identifier (short)
	 *		- err_id     = error identifier
	 */
#define Acu_ss_store_comp_return_error(inv,err_id) \
			Acu_ss_store_component_header (FAC_RETURN_ERROR, ABSENT, inv, 0, err_id)

	/*
	 *	Acu_ss_store_comp_reject() stores a "REJECT" component
	 *
	 *		- inv_id_pres= presence of Invoke identifier (PRESENT/ABSENT)
	 *		- inv        = Invoke identifier (short)
	 *		- pb_tag     = tag (type) of problem
	 *		- pb_val     = problem value
	 */
#define Acu_ss_store_comp_reject(inv_id_pres,inv,pb_tag,pb_val) \
			Acu_ss_store_component_header (FAC_REJECT, inv_id_pres, inv, pb_tag, pb_val)

	/*
	 *	Acu_ss_store_no_operation() specifies that no operation is
	 *	attached to the component
	 */
#define Acu_ss_store_no_operation() \
			Acu_ss_component (component_data_offset) = OFFSET_NIL

	/*
	 *	Acu_ss_set_to_next_component() must be called before storing another
	 *	component.
	 *	It updates the 'next_component_offset' field of the current component,
	 *	and the p_ss_component pointer
	 */
#define Acu_ss_set_to_next_component() \
			Acu_ss_align_p_ss_info ();   \
			Acu_ss_component (next_component_offset) = (ushort)((ulong)p_ss_info - (ulong)p_ss_component); \
			p_ss_component = p_ss_info

	/*
	 *	Acu_ss_set_last_component() must be called after having stored the
	 *	last component (and its operation if any).
	 */
#define Acu_ss_set_last_component() \
			Acu_ss_component (next_component_offset) = OFFSET_NIL

	/*
	 *	Acu_ss_set_to_end_of_operation(op_struct_name) sets 'p_ss_info' to the
	 *	end of the current operation structure, in order to read or write
	 *	the additional information, or the next component.
	 */
#define Acu_ss_set_to_end_of_operation(op_struct_name) \
			p_ss_info = p_ss_operation + Rnd_sizeof (struct op_struct_name)

		/* Maximum number of Facility components in a primitive */

#define	ACU_MX_FAC_COMPONENTS				4

#define	Acu_ss_align_p_ss_info()			p_ss_info = (uchar FAR *)Round ((long)(p_ss_info))

/*==========================================================================*/

		/* structures used to store values acording to ASN1 type */

struct acu_asn1_integer {					/* INTEGER type */
	uchar			sign;					/* ASN1_CODING_POSITIVE / ASN1_CODING_NEGATIVE / other if no coding */
	ulong			value;
};

struct acu_asn1_string {					/* OCTET STRING / CharacterString types */
	uchar		size;
	uchar FAR	*p_string;					/* address of string or P_NIL if no coding */
};

	/* special values used to indicate that a value is not provided */

#define ACU_SS_INT_UCHAR_NOT_PROVIDED		0xFF
#define ACU_SS_INT_CHAR_NOT_PROVIDED		(char)(0x80)
#define ACU_SS_INT_USHORT_NOT_PROVIDED		0xFFFF
#define ACU_SS_INT_SHORT_NOT_PROVIDED		(short)(0x8000)
#define ACU_SS_INT_ULONG_NOT_PROVIDED		0xFFFFFFFFL
#define ACU_SS_INT_LONG_NOT_PROVIDED		(long)(0x80000000L)

/*==========================================================================

			- definition of all general constant values -
*/

			/* protocol profile (service discriminator) field */

#define FAC_REMOTE_OP_PROT					G_5 (1,0,0,0,1)			/* remote operations protocol */

			/* general ASN1 tags */

#define FAC_INTEGER_TAG						G_5 (0,0,0,1,0)			/* ASN1 INTEGER tag */
#define FAC_OBJECT_ID_TAG					G_5 (0,0,1,1,0)			/* ASN1 OBJECT IDENTIFIER tag */
#define FAC_NULL_TAG						G_5 (0,0,1,0,1)			/* ASN1 NULL tag */
#define FAC_SEQUENCE_TAG					G_5 (1,0,0,0,0)			/* ASN1 SEQUENCE tag */

			/* Component tags */

#define FAC_INVOKE							G_5 (0,0,0,0,1)
#define FAC_RETURN_RESULT					G_5 (0,0,0,1,0)
#define FAC_RETURN_ERROR					G_5 (0,0,0,1,1)
#define FAC_REJECT							G_5 (0,0,1,0,0)

			/* Problem tags in RejectComponent */

#define REJ_GENERAL_PB_TAG					G_5 (0,0,0,0,0)			/* General Problem */
#define REJ_INVOKE_PB_TAG					G_5 (0,0,0,0,1)			/* Invoke Problem */
#define REJ_RET_RESULT_PB_TAG				G_5 (0,0,0,1,0)			/* ReturnResult Problem */
#define REJ_RET_ERROR_PB_TAG				G_5 (0,0,0,1,1)			/* ReturnError Problem */

			/* Problem identifiers */

	/* General Problem */

#define GEN_PB_UNRECOGNIZED_COMP			0						/* unrecognized component */
#define GEN_PB_MISTYPED_COMP				1						/* mistyped component */
#define GEN_PB_BAD_STRUCT_COMP				2						/* badly structured component */

	/* Invoke Problem */

#define INV_PB_DUPLICATE					0						/* duplicate invocation */
#define INV_PB_UNRECOGNIZED_OP				1						/* unrecognized operation */
#define INV_PB_MISTYPED_ARG					2						/* mistyped argument */
#define INV_PB_RESOURCE_LIMIT				3						/* resource limitation */
#define INV_PB_INITIATOR_RELEASE			4						/* initiator releasing */
#define INV_PB_UNRECOGNIZED_LK_ID			5						/* unrecognized linked ID */
#define INV_PB_LK_RS_UNEXPECTED				6						/* linked response unexpected */
#define INV_PB_UNEXPECTED_CHILD_OP			7						/* unexpected child operation */

	/* ReturnResult Problem */

#define RET_RES_PB_UNRECOGNIZED_INV			0						/* unrecognized invocation */
#define RET_RES_PB_RES_RS_UNEXPECTED		1						/* result response unexpected */
#define RET_RES_PB_MISTYPED_RESULT			2						/* mistyped result */

	/* ReturnError Problem */

#define RET_ERR_PB_UNRECOGNIZED_INV			0						/* unrecognized invocation */
#define RET_ERR_PB_ERR_RS_UNEXPECTED		1						/* error response unexpected */
#define RET_ERR_PB_UNRECOGNIZED_ERR			2						/* unrecognized error */
#define RET_ERR_PB_UNEXPECTED_ERR			3						/* unexpected error */
#define RET_ERR_PB_MISTYPED_PARAM			4						/* mistyped parameter */

			/* General Error values (defined using ERROR ASN1 Macro) :
				in ReturnError component ('op_err_pb_identifier' field) */

#define SS_ERR_NOT_SUBSCRIBED				0						/* basic or requested service not subscribed */
#define SS_ERR_NOT_AVAILABLE				3						/* requested SS not available for the basic service */
#define SS_ERR_NOT_IMPLEMENTED				4						/* SS requested not implemented for the basic service */
#define SS_ERR_INVALID_SERVED_NB			6						/* served user' number provided invalid */
#define SS_ERR_INVALID_CALL_STATE			7						/* SS cannot be requested in current call state */
#define SS_ERR_SERVICE_NOT_PROVIDED			8						/* served user not subscribed for the basic service */
#define SS_ERR_NOT_INCOMING_CALL			9						/* SS not requested for an incoming call */
#define SS_ERR_INTERAC_NOT_ALLOWED			10						/* performance of the requested SS prohibited by another SS */
#define SS_ERR_RESOURCE_UNAVAILABLE			11						/* resources required to perform requested SS not available */

/*==========================================================================*/

					/*-=-=-=-=-=-=-=-=-=-=-*/
					/*                     */
					/* Advice Of Charge SS */
					/*                     */
					/*        (AOC)        */
					/*                     */
					/*-=-=-=-=-=-=-=-=-=-=-*/

	/* AOC service support { */

	/*	Advice Of Charge SS, including 3 services : AOC-S (at call set-up time),
	 *	AOC-D (during the call), AOC-E (at the end of the call)
	 * ------------------------------------------------------------------ */

		/*	ACU interface identifiers of Operations for AOC SS : ChargingRequest, AOCSCurrency,
			AOCSSpecialArr, AOCDCurrency, AOCDChargingUnit, AOCECurrency and AOCEChargingunit */

#define ACU_OP_AOC_CHARGING_RQ				1			/* Charging Request */
#define ACU_OP_AOCS_CURRENCY				2			/* AOC-S given in currency units */
#define ACU_OP_AOCS_SPECIAL_ARR				3			/* AOC-S for special charging arrangement */
#define ACU_OP_AOCD_CURRENCY				4			/* AOC-D given in currency units */
#define ACU_OP_AOCD_CHARGING_UNIT			5			/* AOC-D given in charging units */
#define ACU_OP_AOCE_CURRENCY				6			/* AOC-E given in currency units */
#define ACU_OP_AOCE_CHARGING_UNIT			7			/* AOC-E given in charging units */

		/*	ACU interface additional Error identifiers AOC :
			in ReturnError component ('op_err_pb_identifier' field) */

#define SS_ERR_AOC_NO_CH_INF_AVAIL			26			/* no charging info available */

		/* sizing constants for array (matching SEQUENCE OF ASN1 Type) */

#define ACU_AOC_MX_RECORDED_UNITS			32			/* maximum number of RecordedUnits used for AOC inside an operation */
#define ACU_AOC_MX_AOCS_CURRENCY_INFO		10			/* maximum number of AOCSCurrencyInfo used for AOC inside an operation */

		/* structure of data at ACU interface for each operation clause (ARGUMENT and RESULT) */

	/*--------------------------------------*/
	/* ChargingRequest operation : ARGUMENT */
	/*--------------------------------------*/

struct	acu_aoc_charging_rq_arg {
	uchar		charging_case;				/* ChargingCase = ENUMERATED {0, 1, 2} */
};

	/*
	 *	ChargingRequest Argument reading macro
	 */
#define Acu_aoc_charging_rq(field)			((struct acu_aoc_charging_rq_arg FAR *)p_ss_operation) -> field

#define ACU_AOC_CHARGING_CALL_SETUP			0			/* charging Information at call set-up time */
#define ACU_AOC_CHARGING_DURING_CALL		1			/* charging Information during a call */
#define ACU_AOC_CHARGING_CALL_END			2			/* charging Information at the end of a call */

	/*
	 *	Acu_store_aoc_charging_rq_arg(case) writes a ChargingRequest operation
	 *	argument:
	 *	- case = charging case
	 */
#define Acu_store_aoc_charging_rq_arg(case) \
			Acu_aoc_charging_rq (charging_case) = case; \
			Acu_ss_set_to_end_of_operation (acu_aoc_charging_rq_arg)

	/*------------------------------------*/
	/* ChargingRequest operation : RESULT */
	/*------------------------------------*/

struct	acu_aoc_charging_rq_res {
	uchar		result_type;				/* type of RESULT (in CHOICE) */
	uchar		aocs_special_arr_info;		/* AOCSSpecialArrInfo : INTEGER (1..10) */
	ushort		aocs_first_cur_info;		/* offset of first instance of AOCSCurrencyInfo */
};

	/*
	 *	ChargingRequest Result reading macro
	 */
#define Acu_aoc_charging_rq_res(field)		((struct acu_aoc_charging_rq_res FAR *)p_ss_operation) -> field

		/* possible types of RESULT 'result_type' field */

#define ACU_AOC_CHARGING_INFO_FOLLOWS		0			/* type is chargingInfoFollows : no other parameters in RESULT */
#define ACU_AOCS_SPECIAL_ARR_INFO			1			/* type is AOCSSpecialArrInfo : 1 other parameter in RESULT = aocs_special_arr_info */
#define ACU_AOCS_CURRENCY_INFO_RQ			2			/* type is AOCSCurrencyInfoList : n parameters */

	/*
	 *	If 'result_type' is not ACU_AOCS_CURRENCY_INFO_RQ, then
	 *	Acu_store_aoc_charg_rq_not_cur() writes a ChargingRequest operation
	 *	result:
	 *	- type        = type of charging information
	 *	- special_arr = SpecialArrInfo (meaningful only if 'result_type' is
	 *	  ACU_AOCS_SPECIAL_ARR_INFO).
	 */
#define Acu_store_aoc_charging_rq_not_cur(type,special_arr) \
			Acu_aoc_charging_rq_res (result_type)           = type; \
			Acu_aoc_charging_rq_res (aocs_special_arr_info) = special_arr; \
			Acu_aoc_charging_rq_res (aocs_first_cur_info)   = OFFSET_NIL; \
			Acu_ss_set_to_end_of_operation (acu_aoc_charging_rq_res)

	/*
	 *	If 'result_type' is ACU_AOCS_CURRENCY_INFO_RQ, then
	 *	Acu_store_aoc_charg_rq_cur() writes a ChargingRequest operation result
	 */
#define Acu_store_aoc_charging_rq_cur() \
			Acu_aoc_charging_rq_res (result_type)           = ACU_AOCS_CURRENCY_INFO_RQ; \
			Acu_ss_set_to_end_of_operation (acu_aoc_charging_rq_res); \
			Acu_aoc_charging_rq_res (aocs_first_cur_info)   = (ushort)((ulong)p_ss_info - (ulong)p_ss_component)

	/*----------------------------*/
	/* AOCSCurrencyInfo structure */
	/*----------------------------*/

struct acu_aocs_currency_info {				/* AOCSCurrencyInfo structure */
	ushort		next_currency_info;			/* offset for next instance */
	uchar		charged_item;				/* chargedItem : ENUMERATED {0, 1, 2, 3, 4} */
	uchar		currency_info_type;			/* type of currency info provided */
	uchar		special_charging_code;		/* specialChargingCode : INTEGER (1..10) */
	ulong		amount;						/* currencyAmount inside Amount : INTEGER(0..16777215) */
	uchar		amount_multiplier;			/* multiplier inside Amount : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
	uchar		volume_unit_or_charg_type;	/* vRVolumeUnit inside VolumeRateCurrency : ENUMERATED {0, 1, 2} or
													dChargingType inside DurationCurrency : ENUMERATED {0, 1} */
	ulong		length_of_time_unit;		/* lengthOfTimeUnit inside dTime : INTEGER (0..16777215) */
	uchar		scale;						/* scale inside dTime : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
	ulong		granularity_lg_time_u;		/* lengthOfTimeUnit inside dGranularity : INTEGER (0..16777215) or 0xFFFFFFFF if not present */
	uchar		granularity_scale;			/* scale inside dGranularity : ENUMERATED {0, 1, 2, 3, 4, 5, 6} or 255 if not present */
	uchar		currency_size;				/* size of Currency string : maximum = 10 */
	uchar		first_currency_oct;			/* first octet of Currency string (IA5 characters) */
};

	/*
	 *	AOCSCurrencyInfo reading macro
	 */
#define Acu_aocs_currency_info(field)		((struct acu_aocs_currency_info FAR *)p_ss_info) -> field

		/* possible values of 'charged_item' */

#define ACU_AOCS_BASIC_COMMUNICATION		0			/* charging information for basic communication */
#define ACU_AOCS_CALL_ATTEMPT				1			/* charging information for call attempt */
#define ACU_AOCS_CALL_SETUP					2			/* charging information for call setup */
#define ACU_AOCS_USER_TO_USER_INFO			3			/* charging information for user-to-user information */
#define ACU_AOCS_OPERATION_OF_SS			4			/* charging information for operation of Supplementary Services */

		/* possible types of currency information '(currency_info_type') */

#define ACU_AOCS_DURATION_CURR_INFO			0			/* specific currency : durationCurrency */
#define ACU_AOCS_FLAT_RATE_CURR_INFO		1			/* specific currency : flatRateCurrency */
#define ACU_AOCS_VOLUME_RATE_CURR_INFO		2			/* specific currency : volumeRateCurrency */
#define ACU_AOCS_SPECIAL_CHARGING_CODE		3			/* specialChargingCode : only 1 other parameter = special_charging_code */
#define ACU_AOCS_FREE_OF_CHARGE				4			/* free of Charge : no other parameter in currency info */
#define ACU_AOCS_INFO_NOT_AVAIL				5			/* currency information not available : no other parameter in currency info */

#define ACU_MX_AOCS_CURR_INFO_TYPE				ACU_AOCS_INFO_NOT_AVAIL		/* maximum permitted value */

		/* possible values of 'amount_multiplier' */

#define ACU_AOC_MULTIP_ONE_THOUSANDTH		0			/* mulitplier of amount is 1/1000 */
#define ACU_AOC_MULTIP_ONE_HUNDREDTH		1			/* mulitplier of amount is 1/100 */
#define ACU_AOC_MULTIP_ONE_TENTH			2			/* mulitplier of amount is 1/10 */
#define ACU_AOC_MULTIP_ONE					3			/* mulitplier of amount is 1 */
#define ACU_AOC_MULTIP_TEN					4			/* mulitplier of amount is 10 */
#define ACU_AOC_MULTIP_HUNDRED				5			/* mulitplier of amount is 100 */
#define ACU_AOC_MULTIP_THOUSAND				6			/* mulitplier of amount is 1000 */

		/* possible values of dChargingType : 'volume_unit_or_charg_type'
		 * if 'result_type' is ACU_AOCS_DURATION_CURR_INFO
		 */

#define ACU_AOC_CONTINUOUS_CHARGING			0			/* continuous charging */
#define ACU_AOC_STEP_FUNCTION_CHARG			1			/* step function charging */

		/* possible values of vRVolumeUnit : 'volume_unit_or_charg_type'
		 * if 'result_type' is ACU_AOCS_VOLUME_RATE_CURR_INFO
		 */

#define ACU_AOC_VOLUME_UNIT_OCTET			0			/* volume unit is octet */
#define ACU_AOC_VOLUME_UNIT_SEGMENT			1			/* volume unit is segment */
#define ACU_AOC_VOLUME_UNIT_MESSAGE			2			/* volume unit is message */

		/* scale inside dTime and dGranularity :
		 * 'scale' and 'granularity_scale' fields
		 */

#define ACU_AOC_SCALE_ONE_HUNDREDTH_SCD		0			/* time scale is 1/100 second */
#define ACU_AOC_SCALE_ONE_TENTH_SCD			1			/* time scale is 1/10 second */
#define ACU_AOC_SCALE_ONE_SECOND			2			/* time scale is 1 second */
#define ACU_AOC_SCALE_TEN_SECONDS			3			/* time scale is 10 seconds */
#define ACU_AOC_SCALE_ONE_MINUTE			4			/* time scale is 1 minute */
#define ACU_AOC_SCALE_ONE_HOUR				5			/* time scale is 1 hour */
#define ACU_AOC_SCALE_TWENTY_FOUR_HOUR		6			/* time scale is 24 hours */

	/*
	 *  Acu_store_aocs_currency_info : store 1 instance of AOCS currency info (AOCSCurrencyInfo structure).
	 *
	 *	INPUT :
	 *		- ch_item          = chargedItem (0..4),
	 *		- cur_type         = type of currency info provided,
	 *		- spec_ch_code     = specialChargingCode (1..10),
	 *		- amount_          = currencyAmount inside Amount (0..16777215),
	 *		- amount_mul       = multiplier inside Amount : (0..6),
	 *		- volume_u_ch_type = vRVolumeUnit inside VolumeRateCurrency (0..2) or dChargingType inside DurationCurrency (0..1),
	 *		- lg_time_u        = lengthOfTimeUnit inside dTime (0..16777215),
	 *		- scale_           = scale inside dTime (0..6),
	 *		- gr_lg_time_u     = lengthOfTimeUnit inside dGranularity (0..16777215) or 0xFFFFFFFF if not present,
	 *		- gr_scale         = scale inside dGranularity : ENUMERATED {0, 1, 2, 3, 4, 5, 6} or 255 if not present,
	 *		- cur_sz           = size of Currency string,
	 *		- p_cur            = address of Currency string.
	 */
#define Acu_store_aocs_currency_info(ch_item,cur_type,spec_ch_code,amount_,amount_mul,volume_u_ch_type,lg_time_u,scale_,gr_lg_time_u,gr_scale,cur_sz,p_cur) \
	Acu_aocs_currency_info (charged_item)              = ch_item; \
	Acu_aocs_currency_info (currency_info_type)        = cur_type; \
	Acu_aocs_currency_info (special_charging_code)     = spec_ch_code; \
	Acu_aocs_currency_info (amount)                    = amount_; \
	Acu_aocs_currency_info (amount_multiplier)         = amount_mul; \
	Acu_aocs_currency_info (volume_unit_or_charg_type) = volume_u_ch_type; \
	Acu_aocs_currency_info (length_of_time_unit)       = lg_time_u; \
	Acu_aocs_currency_info (scale)                     = scale_; \
	Acu_aocs_currency_info (granularity_lg_time_u)     = gr_lg_time_u; \
	Acu_aocs_currency_info (granularity_scale)         = gr_scale; \
	Acu_aocs_currency_info (currency_size)             = cur_sz; \
	Memcpy_far ((char FAR *)&(Acu_aocs_currency_info (first_currency_oct)), (char FAR *)(p_cur), cur_sz)

	/*
	 *  Acu_set_last_aocs_cur_info: store end of AOCS currency info :
	 *  It must be called after last instance in list.
	 *
	 *  Acu_set_next_aocs_cur_info : it must be called before storing
	 *  the next instance of AOCS currency info.
	 */
#define Acu_set_last_aocs_cur_info() \
	Acu_aocs_currency_info (next_currency_info) = OFFSET_NIL; \
	p_ss_info = &(Acu_aocs_currency_info (first_currency_oct)) + Acu_aocs_currency_info (currency_size); \
	Acu_ss_align_p_ss_info ()

#define Acu_set_next_aocs_cur_info() \
	{	uchar FAR *p_tmp; \
		p_tmp = &(Acu_aocs_currency_info (first_currency_oct)) + Acu_aocs_currency_info (currency_size); \
		p_tmp = (uchar FAR *)Round ((long)(p_tmp)); \
		Acu_aocs_currency_info (next_currency_info) = (ushort)((ulong)p_tmp - (ulong)p_ss_component); \
		p_ss_info = p_tmp; \
	}

	/*--------------------------------------------------------*/

			/* AOC-S SS support { */

	/*-----------------------------------*/
	/* AOCSCurrency operation : ARGUMENT */
	/*-----------------------------------*/

struct	acu_aocs_currency_arg {
	uchar		type;						/* type of ARGUMENT (in CHOICE) */
	ushort		first_cur_info;				/* offset of first instance of AOCSCurrencyInfo */
};

	/*
	 *	AOCSCurrency operation reading and writing macro
	 */
#define Acu_aocs_currency(field)			((struct acu_aocs_currency_arg FAR *)p_ss_operation) -> field

		/* possible types of ARGUMENT ('type') */

#define ACU_AOCS_CHARG_NOT_AVAIL			0			/* type is chargeNotAvailable : no other parameters in ARGUMENT */
#define ACU_AOCS_CURRENCY_INFO				1			/* type is AOCSCurrencyInfoList : n parameters formatted according */
														/* to 'acu_aocs_currency_info' (AOCSCurrencyInfo structure) */

	/*
	 *	Acu_store_aocs_currency_not_av :
	 *	store ARGUMENT of AOCSCurrency operation : chargeNotAvailable.
	 */
#define Acu_store_aocs_currency_not_av() \
	Acu_aocs_currency (type)           = ACU_AOCS_CHARG_NOT_AVAIL; \
	Acu_aocs_currency (first_cur_info) = OFFSET_NIL; \
	Acu_ss_set_to_end_of_operation (acu_aocs_currency_arg)

	/*
	 *	Acu_store_aocs_currency_list : store ARGUMENT of AOCSCurrency operation
	 *	which is a list of 1 or more currency info (type is AOCSCurrencyInfoList).
	 *
	 *	no INPUT : data is to be provided with next Macro.
	 */
#define Acu_store_aocs_currency_list() \
	Acu_aocs_currency (type)           = ACU_AOCS_CURRENCY_INFO; \
	Acu_ss_set_to_end_of_operation (acu_aocs_currency_arg); \
	Acu_aocs_currency (first_cur_info) = (ushort)((ulong)p_ss_info - (ulong)p_ss_component)

	/*-------------------------------------*/
	/* AOCSSpecialArr operation : ARGUMENT */
	/*-------------------------------------*/

struct	acu_aocs_special_arr_arg {
	uchar	type;				/* type of ARGUMENT (in CHOICE) */
	uchar	arr_info;			/* AOCSSpecialArrInfo : INTEGER (1..10) */
};

	/*
	 *	AOCSSpecialArr operation reading macro
	 */
#define Acu_aocs_special_arr(field)			((struct acu_aocs_special_arr_arg FAR *)p_ss_operation) -> field

		/* possible types of ARGUMENT */

#define ACU_AOCS_SP_ARR_CHARG_NOT_AVAIL		0			/* type is chargeNotAvailable : no other parameters in ARGUMENT */
#define ACU_AOCS_SP_ARR_INFO				1			/* type is AOCSSpecialArrInfo : 1 parameter */

	/*
	 *   Acu_store_aocs_special_arr : store ARGUMENT of AOCSSpecialArr operation :
	 *
	 *		INPUT :
	 *			- ch_type = type of charging information,
	 *			- special_arr = SpecialArrInfo (meaningful only if type is AOCSSpecialArrInfo).
	 */
#define Acu_store_aocs_special_arr(ch_type, special_arr) \
	Acu_aocs_special_arr (type)     = ch_type; \
	Acu_aocs_special_arr (arr_info) = special_arr; \
	Acu_ss_set_to_end_of_operation (acu_aocs_special_arr_arg)

			/* end of AOC-S SS support } */

	/*--------------------------------------------------------*/

			/* AOC-D SS support { */

	/*-----------------------------------*/
	/* AOCDCurrency operation : ARGUMENT */
	/*-----------------------------------*/

struct	acu_aocd_currency_arg {
	uchar	arg_type;						/* type of ARGUMENT */
	uchar	type_of_charging;				/* type of charging information (in specificCurrency) : ENUMERATED {0, 1} */
	uchar	billing_id;						/* AOCD Billing ID (in specificCurrency) : ENUMERATED {0, 1, 2} or 255 if absent */
	ulong	amount;							/* currencyAmount inside Amount : INTEGER(0..16777215) */
	uchar	amount_multiplier;				/* multiplier inside Amount : ENUMERATED {0, 1, 2, 3, 4, 5, 6} */
	uchar	currency_size;					/* size of Currency string : maximum = 10 */
	uchar	first_currency_oct;				/* first octet of Currency string (IA5 characters) */
};

	/*
	 *	AOCDCurrency operation reading macro
	 */
#define Acu_aocd_currency(field)			((struct acu_aocd_currency_arg FAR *)p_ss_operation) -> field

		/* possible types of ARGUMENT */

#define ACU_AOCD_CHARGE_NOT_AVAILABLE		0			/* type is chargeNotAvailable : no other parameters in ARGUMENT */
#define ACU_AOCD_CURR_FREE_OF_CHARGE		1			/* type is free of charge : no other parameters in ARGUMENT */
#define ACU_AOCD_SPECIFIC_CURRENCY			2			/* type is specificCurrency : all parameters meaninful */

		/* possible types of charging information */

#define ACU_AOCD_CHARG_INFO_SUB_TOTAL		0			/* SubTotal charging */
#define ACU_AOCD_CHARG_INFO_TOTAL			1			/* Total charging */

		/* possible Billing IDs for AOC-D */

#define ACU_AOCD_BILL_ID_NORMAL				0			/* normal charging */
#define ACU_AOCD_BILL_ID_REVERSE			1			/* reverse charging */
#define ACU_AOCD_BILL_ID_CREDIT_CARD		2			/* credit card charging */

		/* possible values of 'amount_multiplier' field are defined above */

	/*
	 *	Acu_store_aocd_currency_not_spfc : store ARGUMENT of AOCDCurrency operation which is
	 *	not a specific currency info (type is chargeNotAvailable or freeOfCharge).
	 *
	 *	INPUT :
	 *		- type = type of ARGUMENT.
	 */
#define Acu_store_aocd_currency_not_spfc(type) \
	Acu_aocd_currency (arg_type)      = type; \
	Acu_aocd_currency (currency_size) = 0; \
	p_ss_info = &(Acu_aocd_currency (first_currency_oct))

	/*
	 *	Acu_store_aocd_currency_spfc : store ARGUMENT of AOCDCurrency operation which is
	 *	a specific currency info (type is specificCurrency inside AOCDCurrencyInfo).
	 *
	 *	INPUT :
	 *		- ch_type = type of charging information (inside specificCurrency),
	 *		- bill_id = AOCD Billing ID (in specificCurrency) : ENUMERATED {0, 1, 2} or 255 if absent,
	 *		- amount_ = currencyAmount inside Amount (0..16777215),
	 *		- amount_mul = multiplier inside Amount : (0..6),
	 *		- cur_sz = size of Currency string,
	 *		- p_cur = address of Currency string.
	 */
#define Acu_store_aocd_currency_spfc(ch_type, bill_id, amount_, amount_mul, cur_sz, p_cur) \
	Acu_aocd_currency (arg_type)          = ACU_AOCD_SPECIFIC_CURRENCY; \
	Acu_aocd_currency (type_of_charging)  = ch_type; \
	Acu_aocd_currency (billing_id)        = bill_id; \
	Acu_aocd_currency (amount)            = amount_; \
	Acu_aocd_currency (amount_multiplier) = amount_mul; \
	Acu_aocd_currency (currency_size)     = cur_sz; \
	Memcpy_far ((char FAR *)&(Acu_aocd_currency (first_currency_oct)), (char FAR *)(p_cur), cur_sz); \
	p_ss_info = &(Acu_aocd_currency (first_currency_oct)) + cur_sz; \
	Acu_ss_align_p_ss_info ()


	/*---------------------------------------*/
	/* AOCDChargingUnit operation : ARGUMENT */
	/*---------------------------------------*/

struct	acu_aocd_charging_unit_arg {
	uchar		arg_type;					/* type of ARGUMENT */
	uchar		type_of_charging;			/* type of charging information (in specificChargingUnits) : ENUMERATED {0, 1} */
	uchar		billing_id;					/* AOCD Billing ID (in specificChargingUnits) : ENUMERATED {0, 1, 2} or 255 if absent */
	ushort		first_recorded_unit;		/* offset of first instance of RecordedUnits (in recordedUnitsList) */
};

	/*
	 *	AOCDChargingUnit operation reading macro
	 */
#define Acu_aocd_charging_unit(field)		((struct acu_aocd_charging_unit_arg FAR *)p_ss_operation) -> field

		/* possible types of ARGUMENT */

#define ACU_AOCD_CHARGING_NOT_AVAILABLE		0			/* type is chargeNotAvailable : no other parameters in ARGUMENT */
#define ACU_AOCD_FREE_OF_CHARGE				1			/* type is free of charge : no other parameters in ARGUMENT */
#define ACU_AOCD_SPECIFIC_CHARGING_UNIT		2			/* type is specificChargingUnits : n parameters */

	/*
	 *	Acu_store_aocd_charg_u_not_spfc : store ARGUMENT of AOCDChargingUnit
	 *	operation which is not a specific charging unit info (type is
	 *	chargeNotAvailable or freeOfCharge).
	 *
	 *	INPUT :
	 *		- type = type of ARGUMENT.
	 */
#define Acu_store_aocd_charg_u_not_spfc(type) \
	Acu_aocd_charging_unit (arg_type)            = type; \
	Acu_aocd_charging_unit (first_recorded_unit) = OFFSET_NIL; \
	Acu_ss_set_to_end_of_operation (acu_aocd_charging_unit_arg)

	/*
	 *  Acu_store_aocd_charg_u_spfc : store ARGUMENT of AOCDChargingUnit operation which is
	 *	a specific charging unit info (type is specificChargingUnits inside AOCDChargingUnitInfo).
	 *
	 *	INPUT :
	 *		- ch_type = type of charging information (inside specificChargingUnit),
	 *		- bill_id = AOCD Billing ID (in specificChargingUnit) : ENUMERATED {0, 1, 2} or 255 if absent.
	 *	data in list of recorded units is to be provided with next Macros.
	 */
#define Acu_store_aocd_charg_u_spfc(ch_type, bill_id)	\
	Acu_aocd_charging_unit (arg_type)            = ACU_AOCD_SPECIFIC_CHARGING_UNIT; \
	Acu_aocd_charging_unit (type_of_charging)    = ch_type; \
	Acu_aocd_charging_unit (billing_id)          = bill_id; \
	Acu_ss_set_to_end_of_operation (acu_aocd_charging_unit_arg); \
	Acu_aocd_charging_unit (first_recorded_unit) = (ushort)((ulong)p_ss_info - (ulong)p_ss_component)

			/* end of AOC-D SS support } */

	/*--------------------------------------------------------*/

			/* AOC-D or AOC-E SS support { */

		/* possible values of 'type_of_charging' and 'billing_id' fields are defined above */

struct acu_aoc_recorded_unit {				/* RecordedUnits structure */
	ushort		next_unit_info;				/* offset for next instance */
	uchar		type_of_unit;				/* recordedTypeOfUnits : INTEGER (1..16) or 255 if absent */
	ulong		number_of_units;			/* recordedNumberOfUnits : INTEGER (0..16777215) or ACU_SS_INT_ULONG_NOT_PROVIDED (0xFFFFFFFF) if absent */
};

	/*
	 *	RecordedUnits structure reading macro
	 */
#define Acu_aoc_recorded_unit(field)		((struct acu_aoc_recorded_unit FAR *)p_ss_info) -> field

	/*
	 *  Acu_store_aoc_recorded_unit : store 1 instance of recorded unit info (RecordedUnits structure).
	 *
	 *	INPUT :
	 *		- u_type = recordedTypeOfUnits : INTEGER (1..16) or 255 if absent,
	 *		- u_nb = recordedNumberOfUnits : INTEGER (0..16777215) or ACU_SS_INT_ULONG_NOT_PROVIDED (0xFFFFFFFF) if not available.
	 */
#define Acu_store_aoc_recorded_unit(u_type, u_nb) \
	Acu_aoc_recorded_unit (type_of_unit)    = u_type; \
	Acu_aoc_recorded_unit (number_of_units) = u_nb

	/*
	 *  Acu_set_last_aoc_recorded_u : store end of recorded unit info : It must be called
	 *	after last instance in list.
	 *
	 *	Acu_set_next_aoc_recorded_u : it must be called before storing next instance of recorded unit info.
	 */
#define Acu_set_last_aoc_recorded_u() \
	Acu_aoc_recorded_unit (next_unit_info) = OFFSET_NIL; \
	p_ss_info += Rnd_sizeof (struct acu_aoc_recorded_unit)

#define Acu_set_next_aoc_recorded_u() \
	Acu_aoc_recorded_unit (next_unit_info) = (ushort)(((ulong)p_ss_info - (ulong)p_ss_component) + Rnd_sizeof (struct acu_aoc_recorded_unit)); \
	p_ss_info += Rnd_sizeof (struct acu_aoc_recorded_unit)

			/* end of AOC-D or AOC-E SS support } */

	/*--------------------------------------------------------*/

			/* AOC-E SS support { */

	/*-----------------------------------*/
	/* AOCECurrency operation : ARGUMENT */
	/*-----------------------------------*/

struct	acu_aoce_currency_arg {
	uchar	arg_type;						/* type of ARGUMENT */
	uchar	billing_id;						/* AOCE Billing ID (in specificCurrency) : ENUMERATED {0, .. , 7} or 255 if absent */
	ulong	amount;							/* currencyAmount inside Amount : INTEGER(0..16777215) */
	uchar	amount_multiplier;				/* multiplier inside Amount : ENUMERATED {0, 1, 2, 3, 4, 5, 6}, values defined above */
	uchar	charg_assoc_type;				/* type of ChargingAssociation or 255 if absent. If it is absent, all following parameters are meaninless except Currency string */
	short	charg_identifier;				/* chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767) */
	uchar	party_nb_type;					/* type of PartyNumber */
	uchar	type_of_nb;						/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	uchar	currency_size;					/* size of Currency string : maximum = 10 */
	uchar	nb_digits_size;					/* size of NumberDigits string inside PartyNumber : maximum = 20 */
	uchar	first_currency_oct;				/* first octet of Currency string (IA5 characters)*/
		/* Currency string is immediately followed by NumberDigits string if any */
};

	/*
	 *	AOCECurrency operation reading macro
	 */
#define Acu_aoce_currency(field)			((struct acu_aoce_currency_arg FAR *)p_ss_operation) -> field

		/* possible types of ARGUMENT */

#define ACU_AOCE_CHARGE_NOT_AVAILABLE		0			/* type is chargeNotAvailable : no other parameters in ARGUMENT */
#define ACU_AOCE_CURR_FREE_OF_CHARGE		1			/* type is free of charge : only 'chargingAssociation' related parameters */
#define ACU_AOCE_SPECIFIC_CURRENCY			2			/* type is specificCurrency : all parameters meaninful */

		/* possible Billing IDs for AOC-E (255 if absent) */

#define ACU_AOCE_BILL_ID_NORMAL				0			/* normal charging */
#define ACU_AOCE_BILL_ID_REVERSE			1			/* reverse charging */
#define ACU_AOCE_BILL_ID_CREDIT_CARD		2			/* credit card charging */
#define ACU_AOCE_BILL_ID_FORWARD_UNC		3			/* call forwarding unconditional */
#define ACU_AOCE_BILL_ID_FORWARD_BUSY		4			/* call forwarding busy */
#define ACU_AOCE_BILL_ID_FORWARD_NOR		5			/* call forwarding no reply */
#define ACU_AOCE_BILL_ID_DEFLECTION			6			/* call deflection */
#define ACU_AOCE_BILL_ID_TRANSFER			7			/* call transfer */

		/* possible types of chargingAssociation (255 if absent) */

#define ACU_AOCE_ASSOC_CHARG_ID				0			/* type is chargeIdentifier : only charg_identifier and Currency string meaningful in following fields */
#define ACU_AOCE_ASSOC_CHARG_NUMBER			1			/* type is chargeNumber : charg_identifier field is meaningless */

		/* possible types of PartyNumber */

#define ACU_SS_PARTY_NB_UNKNOWN				0			/* unknown partyNumber : 'type_of_nb' field is meaningless */
#define ACU_SS_PARTY_NB_PUBLIC				1			/* Public partyNumber */
#define ACU_SS_PARTY_NB_DATA				2			/* data partyNumber : 'type_of_nb' field is meaningless */
#define ACU_SS_PARTY_NB_TELEX				3			/* telex partyNumber : 'type_of_nb' field is meaningless */
#define ACU_SS_PARTY_NB_PRIVATE				4			/* Private partyNumber */
#define ACU_SS_PARTY_NB_NATIONAL			5			/* national standard partyNumber : 'type_of_nb' field is meaningless */

#define ACU_SS_MX_PARTY_NB_TYPE				ACU_SS_PARTY_NB_NATIONAL		/* maximum permitted value */

		/* possible types of number : only if partyNumber type is Public or Private */

#define ACU_SS_PUB_PRIV_NB_UNKNOWN			0			/* Public or Private : unknown number */
#define ACU_SS_PUB_PRIV_NB_ABBREVIATED		6			/* Public or Private : abbreviated number */

#define ACU_SS_PUBLIC_NB_INTERNATIONAL		1			/* Public : international number */
#define ACU_SS_PUBLIC_NB_NATIONAL			2			/* Public : national number */
#define ACU_SS_PUBLIC_NB_NETWORK_SPFC		3			/* Public : network specific number */
#define ACU_SS_PUBLIC_NB_SUBSCRIBER			4			/* Public : subscriber number */

#define ACU_SS_PRIV_NB_LEVEL2_REGIONAL		1			/* Private : level 2 regional number */
#define ACU_SS_PRIV_NB_LEVEL1_REGIONAL		2			/* Private : level 1 regional number */
#define ACU_SS_PRIV_NB_PTN_SPECIFIC			3			/* Private : PTN specific number */
#define ACU_SS_PRIV_NB_LOCAL				4			/* Private : local number */

	/*
	   Acu_store_aoce_currency_not_av : store ARGUMENT of AOCECurrency operation : chargeNotAvailable
	*/

#define Acu_store_aoce_currency_not_av()		\
	Acu_aoce_currency (arg_type) = AOC_AOCE_CHARGE_NOT_AVAILABLE;	\
	p_ss_info++

	/*
	 *  Acu_store_aoce_currency_free : store ARGUMENT of AOCECurrency operation : freeOfCharge
	 *
	 *	INPUT :
	 *		- ch_assoc = type of ChargingAssociation or 255 if absent.
	 *		- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
	 *		- party_type = type of PartyNumber,
	 *		- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
	 *		- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
	 *		- p_nb = address of NumberDigits string.
	 */
#define Acu_store_aoce_currency_free(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb)	\
	Acu_aoce_currency (arg_type) = AOC_AOCE_CURR_FREE_OF_CHARGE;	\
	Acu_aoce_currency (charg_assoc_type) = ch_assoc;	\
	Acu_aoce_currency (charg_identifier) = ch_id;		\
	Acu_aoce_currency (party_nb_type) = party_type;	\
	Acu_aoce_currency (type_of_nb) = nb_type;			\
	Acu_aoce_currency (currency_size) = 0;			\
	Acu_aoce_currency (nb_digits_size) = nb_sz;		\
	Memcpy_far ((char FAR *)&(Acu_aoce_currency (first_currency_oct)), (char FAR *)(p_nb), nb_sz);\
	p_ss_info = &(Acu_aoce_currency (first_currency_oct)) + nb_sz

	/*
	 *  Acu_store_aoce_currency_spfc : store ARGUMENT of AOCECurrency operation which is
	 *	a specific currency info (type is specificCurrency inside AOCECurrencyInfo).
	 *
	 *	INPUT :
	 *		- ch_assoc = type of ChargingAssociation or 255 if absent.
	 *		- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
	 *		- party_type = type of PartyNumber,
	 *		- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
	 *		- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
	 *		- p_nb = address of NumberDigits string.
	 *		- bill_id = AOCE Billing ID (in specificCurrency) : ENUMERATED {0, .. , 7} or 255 if absent,
	 *		- amount_ = currencyAmount inside Amount (0..16777215),
	 *		- amount_mul = multiplier inside Amount : (0..6),
	 *		- cur_sz = size of Currency string,
	 *		- p_cur = address of Currency string.
	 */
#define Acu_store_aoce_currency_spfc(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb, bill_id, amount_, amount_mul, cur_sz, p_cur)	\
	Acu_aoce_currency (arg_type) = AOC_AOCE_SPECIFIC_CURRENCY;	\
	Acu_aoce_currency (charg_assoc_type) = ch_assoc;		\
	Acu_aoce_currency (charg_identifier) = ch_id;			\
	Acu_aoce_currency (party_nb_type) = party_type;		\
	Acu_aoce_currency (type_of_nb) = nb_type;				\
	Acu_aoce_currency (nb_digits_size) = nb_sz;			\
	Acu_aoce_currency (billing_id) = bill_id;				\
	Acu_aoce_currency (amount) = amount_;					\
	Acu_aoce_currency (amount_multiplier) = amount_mul;	\
	Acu_aoce_currency (currency_size) = cur_sz;			\
	Memcpy_far ((char FAR *)&(Acu_aoce_currency (first_currency_oct)), (char FAR *)(p_cur), cur_sz);\
	p_ss_info = &(Acu_aoce_currency (first_currency_oct) + cur_sz;	\
	Memcpy_far ((char FAR *)p_ss_info, (char FAR *)(p_nb), nb_sz);					\
	p_ss_info += nb_sz

	/*---------------------------------------*/
	/* AOCEChargingUnit operation : ARGUMENT */
	/*---------------------------------------*/

struct	acu_aoce_charging_unit_arg {
	uchar	arg_type;						/* type of ARGUMENT */
	uchar	billing_id;						/* AOCE Billing ID (in specificChargingUnits) : ENUMERATED {0, .. , 7} or 255 if absent */
	uchar	charg_assoc_type;				/* type of ChargingAssociation or 255 if absent */
	short	charg_identifier;				/* chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767) */
	uchar	party_nb_type;					/* type of PartyNumber */
	uchar	type_of_nb;						/* Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless */
	ushort	first_recorded_unit;			/* offset of first instance of RecordedUnits (in recordedUnitsList) */
	uchar	nb_digits_size;					/* size of NumberDigits string inside PartyNumber : maximum = 20 */
	uchar	first_nb_digit;					/* first octet of NumberDigits string */
};

	/*
	 *	AOCEChargingUnit operation reading macro
	 */
#define Acu_aoce_charging_unit(field)		((struct acu_aoce_charging_unit_arg FAR *)p_ss_operation) -> field

		/* possible types of ARGUMENT */

#define ACU_AOCE_CHARGING_NOT_AVAILABLE		0			/* type is chargeNotAvailable : no other parameters in ARGUMENT */
#define ACU_AOCE_FREE_OF_CHARGE				1			/* type is free of charge : only 'chargingAssociation' related parameters */
#define ACU_AOCE_SPECIFIC_CHARGING_UNIT		2			/* type is specificChargingUnits : n parameters */

		/* possible values of other fields are defined above. recordedUnitsList is the same
			as for AOC-D above : a list of RecordedUnits structures (acu_aoc_recorded_unit) */

	/*
	 *  Acu_store_aoce_charg_u_not_av : store ARGUMENT of AOCEChargingUnit operation : chargeNotAvailable
	 */
#define Acu_store_aoce_charg_u_not_av()		\
	Acu_aoce_charging_unit (arg_type) = ACU_AOCE_CHARGING_NOT_AVAILABLE;	\
	p_ss_info++

	/*
	 *  Acu_store_aoce_charg_u_free : store ARGUMENT of AOCEChargingUnit operation : freeOfCharge
	 *
	 *	INPUT :
	 *		- ch_assoc = type of ChargingAssociation or 255 if absent.
	 *		- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
	 *		- party_type = type of PartyNumber,
	 *		- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
	 *		- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
	 *		- p_nb = address of NumberDigits string.
	 */
#define Acu_store_aoce_charg_u_free(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb)	\
	Acu_aoce_charging_unit (arg_type) = ACU_AOCE_FREE_OF_CHARGE;	\
	Acu_aoce_charging_unit (first_recorded_unit) = OFFSET_NIL;	\
	Acu_aoce_charging_unit (charg_assoc_type) = ch_assoc;	\
	Acu_aoce_charging_unit (charg_identifier) = ch_id;	\
	Acu_aoce_charging_unit (party_nb_type) = party_type;	\
	Acu_aoce_charging_unit (type_of_nb) = nb_type;	\
	Acu_aoce_charging_unit (nb_digits_size) = nb_sz;	\
	Memcpy_far ((char FAR *)&(Acu_aoce_charging_unit (first_nb_digit)), (char FAR *)(p_nb), nb_sz); \
	p_ss_info = &(Acu_aoce_charging_unit (first_nb_digit)) + nb_sz

	/*
	 *  Acu_store_aoce_charg_u_spfc : store ARGUMENT of AOCEChargingUnit operation which is
	 *	a specific charging unit info (type is specificChargingUnits inside AOCEChargingUnitInfo).
	 *
	 *	INPUT :
	 *		- ch_assoc = type of ChargingAssociation or 255 if absent.
	 *		- ch_id = chargeIdentifier in ChargingAssociation : INTEGER (-32768..32767),
	 *		- party_type = type of PartyNumber,
	 *		- nb_type = Type of number : PublicTypeOfNumber or PrivateTypeOfNumber or meaningless,
	 *		- nb_sz = size of NumberDigits string inside PartyNumber : maximum = 20,
	 *		- p_nb = address of NumberDigits string.
	 *		- bill_id = AOCE Billing ID (in specificChargingUnits) : ENUMERATED {0, .. , 7} or 255 if absent.
	 *	data in list of recorded units is to be provided with Macros above, as for AOC-D
	 */
#define Acu_store_aoce_charg_u_spfc(ch_assoc, ch_id, party_type, nb_type, nb_sz, p_nb, bill_id)	\
	Acu_aoce_charging_unit (arg_type) = ACU_AOCE_SPECIFIC_CHARGING_UNIT;	\
	Acu_aoce_charging_unit (charg_assoc_type) = ch_assoc;	\
	Acu_aoce_charging_unit (charg_identifier) = ch_id;	\
	Acu_aoce_charging_unit (party_nb_type) = party_type;	\
	Acu_aoce_charging_unit (type_of_nb) = nb_type;		\
	Acu_aoce_charging_unit (nb_digits_size) = nb_sz;		\
	Acu_aoce_charging_unit (billing_id) = bill_id;		\
	Memcpy_far ((char FAR *)&(Acu_aoce_charging_unit (first_nb_digit)), (char FAR *)(p_nb), nb_sz);\
	{	uchar FAR *p_tmp; \
		p_tmp = &(Acu_aoce_charging_unit (first_nb_digit)) + nb_sz;	\
		p_tmp = (uchar FAR *)Round ((long)(p_tmp));	\
		Acu_aoce_charging_unit (first_recorded_unit) = (ushort)((ulong)p_tmp - (ulong)p_ss_component);	\
		p_ss_info = p_tmp; \
	}

			/* end of AOC-E SS support } */

	/* end of AOC service support } */

/*==========================================================================*/

					/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
					/*                             */
					/*	Closed User Group SS (CUG) */
					/*                             */
					/*	          (CUG)            */
					/*                             */
					/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

#if ACU_PAR_EXT_CUG == ON		/* Closed User Group SS support { */

		/*	ACU interface identifier of Operation for CUG SS : CUGCallOperation */

#define ACU_OP_CUG_CALL						8

		/*	ACU interface additional Error identifiers for CUG :
			in ReturnError component ('op_err_pb_identifier' field) */

#define SS_ERR_CUG_INV_OR_UNREG_INDEX		16			/* invalid or unregistered CUG index */
#define SS_ERR_CUG_RQ_SRV_VIOL_CONSTR		17			/* requested basic service violates CUG Constraints */
#define SS_ERR_CUG_OUT_CALL_BARRED			18			/* outgoing calls barred within CUG */
#define SS_ERR_CUG_INC_CALL_BARRED			19			/* incoming calls barred within CUG */
#define SS_ERR_CUG_USER_NOT_MEMBER			20			/* user not member of CUG */
#define SS_ERR_CUG_FAC_SUB_CL_INCONS		21			/* inconsistency in designated facility and subscriber class */

	/*------------------------------*/
	/* CUGCall operation : ARGUMENT */
	/*------------------------------*/

struct acu_cug_call_arg {
	uchar	out_access_rq;					/* outgoingAccessRequest : TRUE/FALSE or 0xFF if not present */
	ushort	cug_index;						/* cUgIndex : INTEGER (0..32767) or 0xFFFF if not present */
};

	/*
	 *	CUGCall reading macro
	 */
#define Acu_cug_call(field)					((struct acu_cug_call_arg FAR *)p_ss_operation) -> field

	/*
	 *	Acu_store_cug_call(outg_access_rq,index) writes a CUG operation
	 *	- outg_access_rq = outgoingAccessRequest (TRUE/FALSE or 0xFF if not present),
	 *	- index          = cUgIndex ((0..32767) or 0xFFFF if not present).
	 */
#define Acu_store_cug_call(outg_access_rq,index) \
			Acu_cug_call (outg_access_rq) = outg_access_rq;	\
			Acu_cug_call (cug_index)      = index; \
			Acu_ss_set_to_end_of_operation (acu_cug_call_arg)

#endif /* end of "Closed User Group" SS support } */

/*------------------------------------------------------------------------*/

#endif /* ACU_SS_INT */

/*EOF*/
