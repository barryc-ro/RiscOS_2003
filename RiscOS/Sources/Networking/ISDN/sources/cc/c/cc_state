
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - cc_state.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *    cc_state_driven - Main Call Control state-driven state-machine.
 *
 *-------------------------------
 *
 * Local functions:
 *
 *    cc_process_conn_in - process NS_CONN_IN message.
 *
 *    cc_process_ns_call_proc_in - process NS_CALL_PROC_IN message.
 *
 *    cc_process_ns_alert_in - process NS_ALERT_IN message.
 *
 *    cc_process_ns_user_info_in - process NS_USER_INFO_IN message.
 *
 *    cc_process_acu_user_info_rq - process ACU_USER_INFO_RQ message.
 *
 *    cc_process_acu_information_rq - process ACU_INFORMATION_RQ message.
 *
 *    cc_process_ns_progress_in - process NS_PROGRESS_IN message.
 *
 *    cc_process_ns_conn_co - process NS_CONN_CO message.
 *
 *    cc_process_cc_hook_off_rq - process CC_HOOK_OFF_RQ message.
 *
 *    cc_snd_acu_progress_in - builds and sends an ACU_PROGRESS_IN.
 *
 *    cc_snd_acu_digit_co - build and send ACU_DIGIT_CO.
 *
 *    cc_snd_ns_call_proc_alert_conn - build and send NS_CALL_PROC_RQ,
 *         NS_ALERT_RQ and NS_CONN_RS if required by configuration.
 *
 *    cc_snd_ns_conn_rs_and_set_state - build and send NS_CONN_RS and change state.
 *
 *    cc_snd_conn_co_and_set_active - build and send ACU_CONN_CO or CC_HOOK_OFF_CO and set ACTIVE state.
 *
 *    cc_switch_outgoing_call_b_channel - switch the B channel allocated the
 *    an outgoing call if available, and warn the user.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Call Control (CC) Entity                         |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "cc.h"
#include "isdn.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#include "cc_ie.h"
#include "ctx_ext.h"
#include "ph_int.h"

#include "cc_undef.h"
#include "ns_mac.h"
#include "cc_undef.h"	/* restore ns_par.h flags */

		/* Local function prototype */

#if NEW_FCT_STYLE == ON
	uchar cc_process_conn_in                (void);
	void  cc_process_ns_call_proc_in        (void);
	void  cc_process_ns_alert_in            (void);
	void  cc_process_ns_user_info_in        (void);
	void  cc_process_acu_user_info_rq       (void);
	void  cc_process_acu_information_rq     (void);
	void  cc_process_ns_progress_in         (void);
	void  cc_process_ns_conn_co             (void);
	void  cc_process_cc_hook_off_rq         (void);
	void  cc_snd_acu_progress_in            (uchar event_code);
	void  cc_snd_acu_digit_co               (void);
	uchar cc_snd_ns_call_proc_alert_conn    (void);
	void  cc_snd_ns_conn_rs_and_set_state   (void);
	void  cc_snd_conn_co_and_set_active     (void);
	void  cc_switch_outgoing_call_b_channel (void);
#else
	uchar cc_process_conn_in                ();
	void  cc_process_ns_call_proc_in        ();
	void  cc_process_ns_alert_in            ();
	void  cc_process_ns_user_info_in        ();
	void  cc_process_acu_user_info_rq       ();
	void  cc_process_acu_information_rq     ();
	void  cc_process_ns_progress_in         ();
	void  cc_process_ns_conn_co             ();
	void  cc_process_cc_hook_off_rq         ();
	void  cc_snd_acu_progress_in            ();
	void  cc_snd_acu_digit_co               ();
	uchar cc_snd_ns_call_proc_alert_conn    ();
	void  cc_snd_ns_conn_rs_and_set_state   ();
	void  cc_snd_conn_co_and_set_active     ();
	void  cc_switch_outgoing_call_b_channel ();
#endif

		/* Isdn context */

	Isdn_ctx_ext;

		/* cc_state.c local variables */

#	if CC_OVERLAP_RECEIVING == ON

		char		uui_tmp[ACU_MX_SZ_UUI+1];		/* temporary UUI data saving */

#		if CC_SUPP_SERVICES == ON
			char	fac_tmp[ACU_MX_SZ_FACILITY+1];	/* temporary FACILITY data saving */
#		endif

#	endif

#	if (SIMULATION == ON) && (ACU_INTERFACE == ON)
		struct acu_conn_rq_args FAR *p_acu_conn_rq;
		struct acu_conn_in_args FAR *p_acu_conn_in;
#	endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_state_driven - implements the Call Control automaton.

Usage           void cc_state_driven ();

Return value	: void

*--------------------------------------------------------------------------*/

void cc_state_driven ()
{
	uchar				FAR	*p_data;					/* data pointer in primitive */

#	if CC_INTERFACE == ON
		uchar			FAR *p_cc_data;					/* data pointer in Call Control primitive */
#	endif

#   if CC_OVERLAP_RECEIVING == ON
		uchar			FAR *p_data_msg;				/* temporary message data pointer saving */
		ushort				new_size, old_size;			/* new and old size of messages */
#	endif

#	if ACU_INTERFACE == ON
		CONST struct cc_service	FAR *p_cc_service;
#	endif

#	if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON)
		uchar				 chan_id;					/* channel id to be used */
		struct cc_call	 FAR *p_cc_call_sav;			/* temporary call pointer */
		struct cc_b_chan FAR *p_cc_b_chan;				/* B-channel context pointer */
#	endif

		/* Set event ID and from ID variables */

#	if CC_INTERFACE == ON
		p_cc_data			=
#	endif

	p_data					= p_data_cc;

	/********************************************************************
	 *                                                              	*
	 *						STATE DRIVEN AUTOMATON                     	*
	 *                                                              	*
	 *                                                              	*
	 *        Switch according to the Call Control automaton state     	*
	 *                                                                  *
	 ********************************************************************/

	switch (Cc_call_state) {

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     STATE_NULL                        */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_NULL :

			switch (cc_event_id) {

					/*----------------------------*/
					/*         NS_CONN_IN         */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_CONN_IN) :

					if (cc_process_conn_in () == STOP) {
						return;
					}

#					if EQUIPMENT == NT2

							/*
								Switch the B channel on NT-side only, if it is
								allowed by the selected VOICE-class profile.
							*/

						if ((Cc_na_function == FG_NT_TE) &&
							(Cc_call_service_class == CC_SRV_CLASS_VOICE) &&
							(Cc_profile_switch_rq_enable == ON)
						   ) {
							cc_b_switch (Cc_call_b_chan_id, Cc_call_b_chan_mode, B_AUDIO_TONE_NIL);
						}

#					endif

						/*
							Force the optionally B-channel-id sent in the
							first response to the NS_CONN_IN to be exclusive.
						*/

					cc_chan_excl = CHAN_EXCL;

#					if CC_OVERLAP_RECEIVING == ON

							/*
								Send back a SETUP_ACK if transparent Overlap
								Receiving is used.
							*/

						if (Overlap_rcv_used == ON) {

							if (Cc_na_in_calls_behaviour & CC_TRANSPARENT_OVERLAP_RCV) {

									/*
										Transparent overlap receiving mode:
										Send a SETUP ACKNOWLEDGE if the
										number is not complete
									*/

								if (cc_sending_complete == OFF) {

										/*
											Send NS_SETUP_ACK_RQ to enter
											the Overlap-receiving state
										*/

									cc_snd_to_ns (NS_SETUP_ACK_RQ);
									cc_store_chan_id = OFF;

										/*
											And wait for 'End-of-dialling'
											info for next messages
										*/

									Cc_set_state (STATE_RINGING);
									return;
								}

							}

						}

#					endif

#					if CC_OVERLAP_RECEIVING == ON
						send_call_proc_alert :
#					endif

					if (Cc_profile_service_id == CC_SERVICE_X25_PACKET) {
						Cc_set_state (STATE_RINGING);
						return;
					}

						/*
							Build and send
								NS_CALL_PROC_RQ,
								NS_ALERT_RQ
							and NS_CONN_RS if required by configuration.
						*/

					if (cc_snd_ns_call_proc_alert_conn () == STOP) {
						return;
					}

						/* Set RINGING state (no NS_CONN_RS has been sent) */

					Cc_set_state (STATE_RINGING);
					return;

					/*----------------------------*/
					/*         CC_DIAL_RQ         */
					/*----------------------------*/

#			  if CC_INTERFACE == ON

				case Event (CC_SAPI, CC_DIAL_RQ) :

					Cc_call_user_rate = Cc_dial_rq_user_rate; /* for V110/V120 only */

						/* Get called nb/sub-address */

					p_rq_address	= (char FAR *)Cc_dial_rq_a_called_nb;		/* init the p_dial_rq_nb pointer to the received data */

					if (p_rq_address[0] == '\0') {
						p_rq_address = P_NIL;
					}

					cc_called_nb_type = ACU_NB_TYPE_UNKNOWN;
					cc_called_nb_plan = ACU_NB_PLAN_UNKNOWN;

					p_rq_subaddress = (char FAR *)Cc_dial_rq_a_called_sub_add;

					if (p_rq_subaddress[0] == '\0') {
						p_rq_subaddress = P_NIL;
					}

						/* Get calling nb/sub-address */
						/* First in CC_DIAL_RQ primitive, */
						/* if absent, take configurated address */

					p_calling_address    = (char FAR *)Cc_dial_rq_a_calling_nb;
					p_calling_subaddress = (char FAR *)Cc_dial_rq_a_calling_sub_add;
					cc_calling_nb_pres   = ACU_NB_PRES_ALLOWED;

						/* Take transmitted Calling info if present */

					if ((p_calling_address[0] == '\0') && (p_calling_subaddress[0] == '\0')) {

							/* Take configuration fields */

						p_calling_address    = (char FAR *)Cc_na_a_calling_nb;
						p_calling_subaddress = (char FAR *)Cc_na_a_calling_sub_add;
					}

						/* And preserve only non-empty fields */

					if (p_calling_address[0] == '\0') {
						p_calling_address = P_NIL;
					}

					cc_calling_nb_type = ACU_NB_TYPE_UNKNOWN;

					if (p_calling_subaddress[0] == '\0') {
						p_calling_subaddress = P_NIL;
					}

#					if CC_UUI == ON

							/* UUI protocol */

						Cc_call_first_conn_rq_uui_response =
						Cc_call_uui_rq = (*Cc_dial_rq_a_uui != '\0') ? ON : OFF;

						if (Cc_call_uui_rq == ON) {
							p_cc_uui = (char FAR *)Cc_dial_rq_a_uui;
						}

#					endif

					cc_snd_to_ns	(NS_CONN_RQ);
					Cc_set_state	(STATE_CALL_INIT);
					return;

#			  endif

					/*----------------------------*/
					/*         ACU_CONN_RQ        */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_CONN_RQ) :

#					if (SIMULATION == ON) && (ACU_INTERFACE == ON)
						p_acu_conn_rq = (struct acu_conn_rq_args FAR *)p_data;
#					endif

#					if _CC_SPID_INFO == ON

						if (Cc_na_function == FG_NT_TE) {
                            cc_usid				= Acu_conn_rq_usid;
                            cc_tid				= Acu_conn_rq_tid;
                            cc_interpreter		= Acu_conn_rq_interpreter;
                            cc_endpoint_action	= Acu_conn_rq_endpoint_action;
						}

#					endif

#					if CC_ATT_HCDT == ON
						cc_call_appear	= Acu_conn_rq_call_appear;
#					endif

					cc_read_progress_ind_from_acu (&Acu_conn_rq_ progress_ind);

#					if ARINC_NETWORKS == ON

						cc_notif_descr	= Acu_conn_rq_notif_descr;

#						if CC_SPF_FAC == ON
							cc_spf_fac_id 	= Acu_conn_rq_spf_fac_id;
							cc_spf_fac_code = Acu_conn_rq_spf_fac_val;
#						endif

						cc_departure_year	= Acu_conn_rq_departure_year;
						cc_departure_month	= Acu_conn_rq_departure_month;
						cc_departure_day	= Acu_conn_rq_departure_day;
						cc_service_class_id	= Acu_conn_rq_service_class_id;

						cc_nats_route_ind	= Acu_conn_rq_nats_route_ind;
						cc_satcom_route_ind	= Acu_conn_rq_satcom_route_ind;
						cc_tfts_route_ind	= Acu_conn_rq_tfts_route_ind;

						if (Acu_conn_rq_flight_op_id_size !=  0) {
							p_cc_flight_op_id	= Acu_conn_rq_a_flight_op_id;
						}

						if (Acu_conn_rq_flight_number_size !=  0) {
							p_cc_flight_number	= Acu_conn_rq_a_flight_number;
						}

#					endif

						/* Copy layer 1 information into the call context */

					cc_get_layer_1_info_from_msg (Acu_conn_rq_a_layer_1_info);

					cc_sending_complete = Acu_conn_rq_sending_complete;

					if (Acu_conn_rq_called_nb_size != 0) {
						p_rq_address = Acu_conn_rq_a_called_nb;

							/* Filter and extract the subaddress */

						cc_decode_address ((char FAR *FAR *)&p_rq_address, (char FAR *FAR *)&p_rq_subaddress);
						cc_called_nb_type = Acu_conn_rq_called_nb_type;
						cc_called_nb_plan = Acu_conn_rq_called_nb_plan;

					} else {

						p_rq_address    =
						p_rq_subaddress = P_NIL;
					}

						/* Get calling nb/sub-address */
						/* First in ACU_CONN_RQ primitive, */
						/* if absent, take configurated address */

					if (Acu_conn_rq_calling_nb_size != 0) {

							/* Take transmitted values */

						p_calling_address    = Acu_conn_rq_a_calling_nb;
						cc_decode_address ((char FAR *FAR *)&p_calling_address, (char FAR *FAR *)&p_calling_subaddress);
						cc_calling_nb_type   = Acu_conn_rq_calling_nb_type;
						cc_calling_nb_pres   = Acu_conn_rq_calling_nb_pres;
						cc_calling_nb_screen = Acu_conn_rq_calling_nb_screen;

#						if CC_PAR_MULTIPLE_CALLING_NB == ON

							if (Acu_conn_rq_calling_nb2_size != 0) {

									/* Get second calling_nb information */

								p_calling_address2    = Acu_conn_rq_a_calling_nb2;
								cc_decode_address ((char FAR *FAR *)&p_calling_address2, (char FAR *FAR *)&p_calling_subaddress2);
								cc_calling_nb2_type   = Acu_conn_rq_calling_nb2_type;
								cc_calling_nb2_pres   = Acu_conn_rq_calling_nb2_pres;
								cc_calling_nb2_screen = Acu_conn_rq_calling_nb2_screen;

							} else {

								p_calling_address2    = P_NIL;
							}

#						endif

					} else {

							/* Take configuration fields if not empty */

						p_calling_address    = (char FAR *)Cc_na_a_calling_nb;

						if (p_calling_address[0] == '\0') {
							p_calling_address = P_NIL;
						}

						cc_calling_nb_type   = ACU_NB_TYPE_UNKNOWN;
						cc_calling_nb_pres   = ACU_NB_PRES_ALLOWED;
						cc_calling_nb_screen = ACU_NB_SCREEN_USER_PROVIDED;

						p_calling_subaddress = (char FAR *)Cc_na_a_calling_sub_add;

						if (p_calling_subaddress[0] == '\0') {
							p_calling_subaddress = P_NIL;
						}

#						if CC_PAR_MULTIPLE_CALLING_NB == ON

								/*
									Only one calling_nb is configurable, so
									set the second calling_nb information
									variables
								*/

							p_calling_address2    = P_NIL;
							cc_calling_nb2_type   = ACU_NB_TYPE_UNKNOWN;
							cc_calling_nb2_pres   = ACU_NB_PRES_ALLOWED;
							cc_calling_nb2_screen = ACU_NB_SCREEN_USER_PROVIDED;

#						endif

					}

						/*
							CLIR facility: force sending of calling_nb IE
							if presentation is not allowed
						*/

					if (Acu_conn_rq_identification_denied_rq == ON) {

							/*
								This parameter overrides ALL 'calling_nb_pres'
								fields
							*/

						if (p_calling_address == P_NIL) {

								/*
									No calling number given: force
									transmission of an empty address
								*/

							p_calling_address = "";
						}

							/* Force all calling numbers to be 'Restricted' */

						cc_calling_nb_pres = ACU_NB_PRES_RESTRICTED;

#						if CC_PAR_MULTIPLE_CALLING_NB == ON
							cc_calling_nb2_pres = ACU_NB_PRES_RESTRICTED;
#						endif

					}

						/* Read/check/allocate the given B-channels if any */

					switch (cc_read_chani_list_from_acu ((struct chani_list FAR *)&Acu_conn_rq_data_chani_nb)) {

						case STOP:

								/* The B-channel is already allocated */

#							if CC_SPF_FAC == OFF

									/* Reject the outgoing call */

								Cc_set_acu_error (ACURC_NOLINE);
								return;

#							else

								if (Spf_fac_used == OFF) {

										/* No facility: reject the outgoing call */

									Cc_set_acu_error (ACURC_NOLINE);
									return;

								} else {

										/*
											Facilities are used:
											Search another call held on the
											same B channel
										*/

									Cc_access_b_chan (Acu_conn_rq_data_chani);

									if (Cc_b_chan_p_held_call == P_NIL) {

											/*
												No held call is sharing the B channel:
												reject the outgoing call
											*/

										Cc_set_acu_error (ACURC_NOLINE);
										return;
									}

										/*
											A held call is sharing the B channel:
											read and allocate the B-channel
											accept the outgoing call
										*/

									cc_alloc_chan_list ((struct chani_list FAR *)&Acu_conn_rq_data_chani_nb);
									break;

								}

#							endif

						case CONTINUE:

								/*
									No B-channel list is given:
									Allocate one if on NT side or required
									by the standard
								*/

							if ((Channel_id_in_setup_used == ON)
#								if EQUIPMENT == NT2
								 || (Cc_na_function == FG_NT_TE)
#								endif
							   ) {

									/* Allocate a free B-channel */

								if (cc_find_free_b_chan () == NOK) {

										/*
											No free channel available:
											reject the call
										*/

									Cc_set_acu_error (ACURC_NOLINE);
									return;
								}

							}

							break;

						case OK:
							break;

					}

						/* Read the preferred/exclusive flag */

					Cc_call_b_chan_excl  =
					cc_chan_excl         = Acu_conn_rq_data_chani_excl;

#					if CC_SPF_FAC == ON

						if (Spf_fac_used == ON) {

								/*
									Get Facility to store into NS_CONN_RQ :
									Since only one facility at a time is supported,
									the priorities are set as follows :
										1 - (Highest) Transfer request;
										2 - 		  Identification denied;
										3 - (Lowest)  Charging information.
								*/

							cc_spf_facility_code  = Cc_call_facility_code = NIL;

							if (Acu_conn_rq_transfer_rq == ON) {

								p_cc_call_sav = p_cc_call;	/* save current call context pointer */

								if (cc_access_conn_id (Acu_conn_rq_transfer_conn_id) == OK) {

										/*
											Check if it is an active call.
										*/

									if (Cc_call_state == STATE_ACTIVE) {

											/*
												The call to be transfered exists :
												"complex transfer" (Facility
												stored into the NS_CONN_RQ
												primitive).
											*/

										cc_spf_facility_code = ACU_FAC_TRF;
										cc_chan_id[0]        = Cc_call_b_chan_id;

									}

								}

								p_cc_call = p_cc_call_sav;

							} else if (Acu_conn_rq_identification_denied_rq == ON) {

								cc_spf_facility_code = FT_SPF_FAC_IDENTIFICATION_DENIED;

#						if CC_PAR_CHARGING_INFO == ON
							} else if (Acu_conn_rq_charging_rq == ON) {

								cc_spf_facility_code = ACU_FAC_CHARGING;
#						endif
							}

						}

#					endif

#					if CC_SUPP_SERVICES == ON

						if (Sup_services_used == ON) {
							cc_facility_size = 0;

							if (Acu_conn_rq_facility_size != 0) {
								cc_facility_size = Acu_conn_rq_facility_size;
								p_cc_facility    = Acu_conn_rq_a_facility;
							}
						}

#					endif

#					if CC_UUI == ON

							/* UUI protocol */

						Cc_call_first_conn_rq_uui_response =
						Cc_call_uui_rq = (Acu_conn_rq_uui_size != 0) ? ON : OFF;

						if (Cc_call_uui_rq == ON) {
							p_cc_uui = Acu_conn_rq_a_uui;
						}

#					endif

#					if ARINC_NETWORKS == ON

							/* Strore credit card tracks information */

						if ((cc_track_1_size = Acu_conn_rq_track_1_size) != 0) {

								/* Take transmitted values */

							p_cc_track_1 = Acu_conn_rq_a_track_1;
						}

						if ((cc_track_2_size = Acu_conn_rq_track_2_size) != 0) {

								/* Take transmitted values */

							p_cc_track_2 = Acu_conn_rq_a_track_2;
						}

#					endif

						/* Get display IE contents if present */

					cc_read_display_from_acu (Acu_conn_rq_a_display_list);

#					if ACU_PAR_EXTENDED_PRIM == ON
						cc_read_ext_parms_from_acu (p_data);
#					endif

					cc_snd_to_ns (NS_CONN_RQ);
					Cc_set_state (STATE_CALL_INIT);
					return;

#			  endif

					/*----------------------------*/
					/*        ACU_RESUME_RQ       */
					/*----------------------------*/

#			  if (ACU_INTERFACE == ON) && (CC_SUSPEND_RESUME == ON)

				case Event (ACU_SAPI, ACU_RESUME_RQ) :

					if (Suspend_resume_used == ON) {
						p_call_id = Acu_resume_a_call_id;
						cc_snd_to_ns (NS_RESUME_RQ);
						Cc_set_state (STATE_RESUME_RQ);
					}

					return;

#			  endif

					/*----------------------------*/
					/*       ACU_FACILITY_RQ      */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_FACILITY_RQ) :

						/*
							Only for call forwarding
							request, clear or enquiry.
						*/

#					if CC_SPF_FAC == ON

						if (Spf_fac_used == ON) {

							if ((cc_spf_facility_code = Acu_facility_code)  == ACU_FAC_CALL_FORWARDING) {

								p_rq_address		= P_NIL;
								p_rq_subaddress 	= P_NIL;

								if ((cc_spf_facility_action = Acu_facility_action) == ACU_RQ_ACTIVATE) {
									p_rq_address 	= Acu_facility_a_called_address;
									cc_decode_address ((char FAR *FAR *)&p_rq_address, (char FAR *FAR *)&p_rq_subaddress);
								}

								if (cc_snd_to_ns (NS_SPF_REGISTRATION_RQ) == OK) {
									Cc_set_state (STATE_SPF_REGISTRATION_RQ);
									return;
								}
							}
						}

#					endif

					Memset_far ((char FAR *)p_data, 0, Acu_facility_size);
					Acu_facility_network_cause = ACU_NETWORK_CAUSE_NIL;
					Acu_facility_action        = ACU_CO_REJ;
					cc_retransmit_to_user		(ACU_FACILITY_CO);
					Cc_call_clear ();
					return;

#			  endif

			}
			return;

				/*-------------------------------------------------------*/
				/*                                                       */
				/*               STATE_AWAIT_DIGIT : incoming call	     */
				/*                                                       */
				/*-------------------------------------------------------*/

#		if CC_OVERLAP_RECEIVING == ON	/* { */

			case STATE_AWAIT_DIGIT :

					/* Process only NS_INFO_IN message */

				if (cc_event_id != Event (NS_SAPI_SIG, NS_INFO_IN)) return;

				cc_sending_complete = (Net_get_ie (NS_INFO_IN, IE_SENDING_COMPLETE) == ABSENT) ? OFF : ON;

				cc_read_called_nb_from_ns (NS_INFO_IN);

				if ((cc_called_nb_size != 0) || (cc_sending_complete == ON)) {

						/*
						 * Test if the sum of digits already received and
						 * digits just received does not exceed the
						 * maximum length of called nb.
						 * If so, truncate the received string.
						 */

					if ((cc_called_nb_size + Cc_call_nb_digit_rcv) > ACU_MX_SZ_CALLED_NB) {
						p_called_nb[ACU_MX_SZ_CALLED_NB - Cc_call_nb_digit_rcv] = '\0';
					}

					Cc_call_nb_digit_rcv += Strcpy_far (Cc_call_a_build_called_nb + Cc_call_nb_digit_rcv, (char FAR *)p_called_nb, cc_called_nb_size) - 1;

					if ((Cc_call_nb_digit_rcv >= Cc_na_nb_digits_to_route) ||
						(cc_sending_complete == ON)) {

							/*
							 * We received enough digits to make able
							 * the application to route the call.
							 * So we send to it an ACU_CONN_IN.
							 */

						p_called_nb			= (uchar FAR *)Cc_call_a_build_called_nb;
						cc_called_nb_size	= Cc_call_nb_digit_rcv + 1;

						if (Cc_na_in_calls_behaviour & CC_TRUNCATE_NB) {

								/* Force the end of string. */

							p_called_nb[Cc_na_nb_digits_to_route] = '\0';
							cc_called_nb_size = Cc_na_nb_digits_to_route +1;	/* +1 for '\0' */
						}

						if (cc_called_nb_size > Cc_na_nb_digits_to_route) {

								/*
								 * Some other digits may come, but they are
								 * no more useful. Update the current state.
								 * That one will be reset,
								 * but saved in 'previous_state' field.
								 * This previous_state is used to discard
								 * the potential other digits that may arrive.
								 */

							Cc_set_state (STATE_AWAIT_ADDITIONAL_DIGIT);
						}

							/*
							 * Send a ACU_CONN_IN to the application.
							 * Store current context with the data of
							 * the previous NS_CONN_IN.
							 */

						p_snd_msg = Cc_call_p_conn_in;

						switch (cc_current_sapi_user) {

#							if CC_INTERFACE == ON

								case CC_SAPI :
									cc_snd_to_user (CC_RING_IN);
									break;

#							endif

#							if ACU_INTERFACE == ON

								case ACU_SAPI :

									p_data	 = S_a_data;
									old_size = S_msg_data_size;

										/*
										 * Save UUI and FACILITY which were in the ACU_CONN_IN which
										 * were not sent because of lack of called nb digits.
										 * We need to save them, because they are stored
										 * after the called nb data.
										 */

#									if CC_UUI == ON
										Strcpy_far ((char FAR *)uui_tmp, Acu_conn_in_a_uui, Acu_conn_in_uui_size);
										cc_uui_size = Acu_conn_in_uui_size;
#									endif

#									if CC_SUPP_SERVICES == ON

										if (Sup_services_used == ON) {
											Memcpy_far ((char FAR *)fac_tmp, Acu_conn_in_a_facility, Acu_conn_in_facility_size);
											cc_facility_size = Acu_conn_in_facility_size;
										}

#									endif

									if (Cc_call_called_sub_add_size != 0) {
										cc_called_nb_size--;	/* End of string was twice taken in account */
									}

									if (p_buffer == P_NIL) {

										new_size = S_msg_data_size + cc_called_nb_size;

										if (new_size > Message_data_lgth) {

												/*
												 * Previously, a message data area was enough.
												 * Now adding the called nb size, we need a buffer...
												 * So, allocate a buffer, and copy previous message
												 * data in the new buffer data area.
												 */

											p_data_msg			= p_data;
											S_msg_data_size		= 0;
											Buffer_alloc;
											S_msg_init_link_buffer;
											Buffer_data_size	= new_size;
											p_data				= Buffer_a_first_data;

											Memcpy_far ((char FAR *)p_data, (char FAR *)p_data_msg, old_size);

										} else {

												/* Message data area still remains enough */

											S_msg_data_size = new_size;
										}

									} else {

											/* We assume a buffer data area will still remain enough */

										Buffer_data_size += cc_called_nb_size;
									}

										/* Store complete called nb */

									Acu_conn_in_called_nb_size = cc_called_nb_size;
									cc_build_address ((char FAR *)p_called_nb, (char FAR *)Cc_call_a_build_called_sub_add, Acu_conn_in_a_called_nb);

										/* Then UUI */

#									if CC_UUI == ON

										Acu_conn_in_uui_size = cc_uui_size;

										if (cc_uui_size != 0) {
											Strcpy_far (Acu_conn_in_a_uui, (char FAR *)uui_tmp, Acu_conn_in_uui_size);
										}

#									endif

#									if CC_SUPP_SERVICES == ON

										if (Sup_services_used == ON) {

												/* And finally FACILITY */

											Acu_conn_in_facility_size = cc_facility_size;

											if (cc_facility_size != 0) {
												Memcpy_far (Acu_conn_in_a_facility, (char FAR *)fac_tmp, cc_facility_size);
											}
										}

#									endif

									cc_store_display (Acu_conn_in_a_display_list, Acu_conn_in_a_display);

									if (cc_address_filtering (0) == -1) {

										if (Cc_na_network != cc_tr6) {
											Cc_set_ns_error (C_C_NORMAL_EVENT, C_V_NO_ANSWER_19);

										} else {

											Cc_set_ns_error (C_C_011, C_V_NO_USER_RESPONDING);
										}

										return;
									}

									cc_snd_to_user (ACU_CONN_IN);

										/* Automatic generation of ACU_ALERT_IN ? */

									if (Cc_na_in_calls_behaviour & CC_SEND_ALERT_IN) {
										Acu_alloc_data (Acu_alert_in_size);
										Acu_alert_in_alert = ACUAC_RING;

#										if CC_PAR_PROGRESS_IND_IE == ON
											Acu_alert_in_progress_ind_nb      = 0;
											Acu_alert_in_progress_location    = ACU_BYTE_VAL_NIL;
											Acu_alert_in_progress_description = ACU_BYTE_VAL_NIL;
#										endif

#										if CC_PAR_SIGNAL_IE == ON
											Acu_alert_in_signal_val           = ACU_BYTE_VAL_NIL;
#										endif

										cc_snd_to_user (ACU_ALERT_IN);
									}

									break;
#							endif

						} /* end switch (cc_current_sapi) */

						goto send_call_proc_alert;

					} /* end if (enough digits to route) */

				} /* end if (digits or sending-complete received) */

				return;

#		endif	/* } CC_OVERLAP_RECEIVING == ON */

			/*-------------------------------------------------------*/
			/*                                                       */
			/*               STATE_RINGING : incoming call           */
			/*                                                       */
			/*-------------------------------------------------------*/

#		if CC_OVERLAP_RECEIVING == ON
			case STATE_AWAIT_ADDITIONAL_DIGIT :
#		endif

		case STATE_RINGING :

			switch (cc_event_id) {

					/*----------------------------*/
					/*         NS_INFO_IN         */
					/*----------------------------*/

#			  if (ACU_INTERFACE == ON) && (CC_OVERLAP_RECEIVING == ON)

				case Event (NS_SAPI_SIG, NS_INFO_IN) :

						/* Extract numbering info */

					cc_read_called_nb_from_ns (NS_INFO_IN);

					Acu_alloc_data (Acu_digit_in_size +
									cc_called_nb_size);

					Acu_digit_in_digit_size = cc_called_nb_size;
					Memcpy_far (Acu_digit_in_a_digit, (char FAR *)p_called_nb, cc_called_nb_size);

					cc_sending_complete = (Net_get_ie (NS_INFO_IN, IE_SENDING_COMPLETE) == ABSENT) ? OFF : ON;

						/* Store the 'sending complete' info */

					Acu_digit_in_sending_complete = cc_sending_complete;

						/* Send the message to the user */

					cc_snd_to_user (ACU_DIGIT_IN);

#					if (CC_PAR_KEYPAD_IE == ON) && (EQUIPMENT == NT2)

							/*
								Keypad facility on NT-side:
								Send ACU_INFORMATION_IN if any Keypad IE
								is present in the NS_INFO_IN.
							*/


						if (Cc_na_function == FG_NT_TE) {

							cc_read_keypad_from_ns (NS_INFO_IN);

							if (cc_keypad_size != 0) {
								Acu_alloc_data (Acu_information_size +
												cc_keypad_size);

								Acu_information_keypad_size = cc_keypad_size;
								Memcpy_far (Acu_information_a_keypad, p_cc_keypad, cc_keypad_size + 1);
								Acu_information_charging_type = ACU_BYTE_VAL_NIL;

								cc_snd_to_user (ACU_INFORMATION_IN);
							}
						}

#					endif

						/* And wait for next info if not complete */

					if (cc_sending_complete == OFF) {
						return;
					}

						/*
							End of dialling reached:
							Check if any automatic answering is to be done
						*/

					p_cc_profile = Cc_call_p_cc_profile;

						/*
							Build and send
								NS_CALL_PROC_RQ,
								NS_ALERT_RQ
							and NS_CONN_RS if required by configuration.
						*/

					if (cc_snd_ns_call_proc_alert_conn () == STOP) {
						return;
					}

#					if EQUIPMENT == NT2

							/*
								Switch the B channel on NT-side only, if it is
								allowed by the selected VOICE-class profile.
							*/

						if ((Cc_na_function == FG_NT_TE) &&
							(Cc_call_service_class == CC_SRV_CLASS_VOICE) &&
							(Cc_profile_switch_rq_enable == ON)
						   ) {
							cc_b_switch (Cc_call_b_chan_id, Cc_call_b_chan_mode, B_AUDIO_TONE_NIL);
						}

#					endif

					return;

#			  endif

					/*----------------------------*/
					/*      ACU_CALL_PROC_RQ      */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_CALL_PROC_RQ) :

						/* Read/check/allocate the given B-channels if any */

					if (cc_process_chani_list_from_acu ((struct chani_list FAR *)&Acu_call_proc_rq_data_chani_nb) == NOK) {
						return;
					}

						/* Get display IE contents if present */

					cc_read_display_from_acu (Acu_call_proc_rq_a_display_list);

					cc_read_progress_ind_from_acu (&Acu_call_proc_rq_ progress_ind);

#					if ACU_PAR_EXTENDED_PRIM == ON
						cc_read_ext_parms_from_acu (p_data);
#					endif

					cc_snd_to_ns (NS_CALL_PROC_RQ);
					Cc_set_state (STATE_RINGING);
					return;

#			  endif

					/*----------------------------*/
					/*        ACU_ALERT_RQ        */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_ALERT_RQ) :

						/* Read/check/allocate the given B-channels if any */

					if (cc_process_chani_list_from_acu ((struct chani_list FAR *)&Acu_alert_rq_data_chani_nb) == NOK) {
						return;
					}

#					if CC_UUI == ON

							/* Get the UUI information */

						if ((Cc_call_uui_rq == ON) && (Acu_alert_rq_uui_size != 0)) {
							p_cc_uui = Acu_alert_rq_a_uui;
						}

#					endif

						/* Get display IE contents if present */

					cc_read_display_from_acu (Acu_alert_rq_a_display_list);

					cc_read_progress_ind_from_acu (&Acu_alert_rq_ progress_ind);

#					if CC_PAR_SIGNAL_IE == ON
						cc_signal_val 		= Acu_alert_rq_signal_val;
#					endif

#					if ACU_PAR_EXTENDED_PRIM == ON
						cc_read_ext_parms_from_acu (p_data);
#					endif

					cc_snd_to_ns (NS_ALERT_RQ);
					Cc_set_state (STATE_RINGING);
					return;

#			  endif

					/*----------------------------*/
					/*        CC_ALERT_RQ         */
					/*----------------------------*/

#			  if (CC_INTERFACE == ON) && (CC_ADDRESS_FILTERING == OFF)

				case Event (CC_SAPI, CC_ALERT_RQ) :

#					if CC_UUI == ON

						if (Cc_call_uui_rq == ON) {
							p_cc_uui = (char FAR *)Cc_alert_a_uui;
						}

#					endif

					cc_chan_nb    = 1;
					cc_chan_id[0] = Cc_call_b_chan_id;
					cc_snd_to_ns (NS_ALERT_RQ);
					Cc_set_state (STATE_CALL_RECEIVED);
					return;
#			  endif

					/*----------------------------*/
					/*      ACU_USER_INFO_RQ      */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_USER_INFO_RQ) :
					cc_process_acu_user_info_rq ();
					return;

#			  endif

					/*----------------------------*/
					/*      NS_USER_INFO_IN       */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (NS_SAPI_SIG, NS_USER_INFO_IN) :
					cc_process_ns_user_info_in ();
					return;

#			  endif

					/*----------------------------*/
					/*         ACU_CONN_RS        */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_CONN_RS) :

					if (Acu_conn_rs_service != ACU_NO_SERVICE) {

							/* A new service id has been requested by the User */

							/* Access to the profile */

						if ((p_cc_profile = cc_access_profile (Acu_conn_rs_service)) == P_NIL) {

								/* Profile not found : clear the call */

									/* To NS : NS_CLEAR_RQ */

							cc_error_class = Class_incompatible;
							cc_error_value = Val_incompatible;

							cc_snd_to_ns	(NS_CLEAR_RQ);
							Cc_set_state	(STATE_RELEASE_NS);

								/* To User : ACU_CLEAR_CO/CC_HOOK_ON_CO */

							Cc_set_acu_error  (ACURC_BAD_SERVICE);

							return;
						}

						p_cc_service				= cc_access_service (Cc_profile_service_id);

						Cc_call_p_cc_profile		= p_cc_profile;
						Cc_call_p_cc_service		= p_cc_service;
						Cc_call_service_class		= cc_service_to_class (Cc_profile_service_id);

							/* Copy layer 1 information into the call context */

						cc_get_layer_1_info_from_msg (Acu_conn_rs_a_layer_1_info);

					} else {

						p_cc_profile = Cc_call_p_cc_profile;
					}

						/* Read/check/allocate the given B-channels if any */

					if (cc_process_chani_list_from_acu ((struct chani_list FAR *)&Acu_conn_rs_data_chani_nb) == NOK) {
						return;
					}

#					if CC_PAR_DATE_TIME == ON

							/* Get the Date and Time information */

						if ((cc_date_time.available = Acu_conn_rs_date_available) != OFF) {
							Memcpy_far ((char FAR *)&cc_date_time, (char FAR *)Acu_conn_rs_a_date_time, sizeof (struct acu_date_time));
						}

#					endif

#					if CC_UUI == ON

							/* Get the UUI information */

						if ((Cc_call_uui_rq == ON) && (Acu_conn_rs_uui_size != 0)) {
							p_cc_uui = Acu_conn_rs_a_uui;
						}

#					endif

						/* Get display IE contents if present */

					cc_read_display_from_acu (Acu_conn_rs_a_display_list);

#					if CC_SUPP_SERVICES == ON

						if (Sup_services_used == ON) {
							cc_facility_size = Acu_conn_rs_facility_size;

							if (Acu_conn_rs_facility_size != 0) {
								p_cc_facility = Acu_conn_rs_a_facility;
							}
						}

#					endif

#					if CC_PAR_SIGNAL_IE == ON
						cc_signal_val = Acu_conn_rs_signal_val;
#					endif

#					if ACU_PAR_EXTENDED_PRIM == ON
						cc_read_ext_parms_from_acu (p_data);
#					endif

						/* Send NS_CONN_RS and set state */

					cc_snd_ns_conn_rs_and_set_state ();
					return;

#			  endif

					/*----------------------------*/
					/*       CC_HOOK_OFF_RQ       */
					/*----------------------------*/

#			  if CC_INTERFACE == ON

				case Event (CC_SAPI, CC_HOOK_OFF_RQ) :
					cc_process_cc_hook_off_rq ();
					return;

#			  endif

			}

			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                  STATE_CALL_RECEIVED                  */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if (CC_INTERFACE == ON) && (CC_ADDRESS_FILTERING == OFF)

		case STATE_CALL_RECEIVED :

			switch (cc_event_id) {

					/*----------------------------*/
					/*       CC_HOOK_OFF_RQ       */
					/*----------------------------*/

#			  if CC_INTERFACE == ON

				case Event (CC_SAPI, CC_HOOK_OFF_RQ) :
					cc_process_cc_hook_off_rq ();
					return;

#			  endif

			}

			return;

#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                   STATE_HOOKED_OFF                    */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_HOOKED_OFF :

			switch (cc_event_id) {

					/*----------------------------*/
					/*          NS_CONN_CO        */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_CONN_CO) :
					cc_process_ns_conn_co ();
					return;

			}
			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     STATE_CALL_INIT                   */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_CALL_INIT :


			switch (cc_event_id) {

				   /*----------------------------*/
				   /*       NS_SETUP_ACK_IN      */
				   /*----------------------------*/

				case Event (NS_SAPI_SIG, NS_SETUP_ACK_IN) :

						/* Enter Overlap-Sending mode */

					switch (cc_current_sapi_user) {

#						if ACU_INTERFACE == ON

							case ACU_SAPI :

								Cc_set_state (STATE_OVERLAP_SENDING);

									/* Get the B channel number to be used if any */

								cc_read_chan_id_from_ns (NS_SETUP_ACK_IN);

								if (cc_chan_nb != 0) {

									if (cc_alloc_b_chan_if_allowed () == STOP) {

										/* the received B channel is not allowed, stop */

										return;
									}

#									if CC_PAR_PROGRESS_IND_IE == ON
										cc_read_progress_ind_from_ns (NS_SETUP_ACK_IN);
#									endif

#									if CC_PAR_SIGNAL_IE == ON
										cc_read_signal_from_ns (NS_SETUP_ACK_IN);
#									endif

#									if _ACU_PAR_EXT_FACILITY == ON
										cc_read_ext_facility_from_ns (NS_SETUP_ACK_IN);
#									endif

										/* Send ACU_PROGRESS_IN */

									cc_snd_acu_progress_in (ACUEV_DIAL_TONE);

										/* And switch B channel */

									cc_switch_outgoing_call_b_channel ();
								}

								return;

#						endif

#						if CC_INTERFACE == ON

							case CC_SAPI :

									/* Overlap sending not supported in CC interface */

								Cc_set_cc_error (ERR_CC_OVERLAP_SENDING);
								return;

#						endif

					}

					return;

					/*----------------------------*/
					/*       NS_CALL_PROC_IN      */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_CALL_PROC_IN) :

#				  if ACU_INTERFACE == ON

					if (Cc_na_out_calls_behaviour & CC_SEND_DIGIT_CO_ON_PROGRESS) {

							/* Warn Application that dialing is complete */

						cc_snd_acu_digit_co ();
					}

#				  endif

					cc_process_ns_call_proc_in ();
					return;

					/*----------------------------*/
					/*         ACU_DIGIT_RQ       */
					/*----------------------------*/

						/* Too early ! (must wait for NS_SETUP_ACK_IN) */

#				if ACU_INTERFACE == ON

					case Event (ACU_SAPI, ACU_DIGIT_RQ) :
						return;

#				endif

					/*----------------------------*/
					/*         NS_ALERT_IN        */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_ALERT_IN) :
					Cc_set_state (STATE_OUTGOING_CALL_PROC);
					cc_process_ns_alert_in ();
					return;

					/*----------------------------*/
					/*          NS_CONN_CO        */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_CONN_CO) :
					cc_process_ns_conn_co ();
					return;

					/*----------------------------*/
					/*       NS_PROGRESS_IN       */
					/*----------------------------*/

#			if ACU_INTERFACE == ON

				case Event (NS_SAPI_SIG, NS_PROGRESS_IN) :
					cc_process_ns_progress_in ();
					return;

#			endif

			}
			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                  STATE_OVERLAP_SENDING                */
			/*                                                       */
			/*-------------------------------------------------------*/

#	if ACU_INTERFACE == ON

		case STATE_OVERLAP_SENDING :

			switch (cc_event_id) {

					/*----------------------------*/
					/*         ACU_DIGIT_RQ       */
					/*----------------------------*/

				case Event (ACU_SAPI, ACU_DIGIT_RQ) :
					p_rq_address = Acu_digit_rq_a_digit;

						/* Extract the address */

					cc_sending_complete = Acu_digit_rq_sending_complete;

					cc_decode_address ((char FAR *FAR *)&p_rq_address, (char FAR *FAR *)&p_rq_subaddress);

					cc_snd_to_ns (NS_INFO_RQ);
					Cc_set_state (STATE_OVERLAP_SENDING);
					return;

					/*----------------------------*/
					/*       NS_CALL_PROC_IN      */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_CALL_PROC_IN) :

						/* Warn Application that dialing is complete */

					cc_snd_acu_digit_co ();

						/* and process the NS_CALL_PROC_IN message */

					cc_process_ns_call_proc_in ();
					return;

					/*----------------------------*/
					/*         NS_ALERT_IN        */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_ALERT_IN) :

						/* Warn Application that dialing is complete */

					cc_snd_acu_digit_co ();

					Cc_set_state (STATE_OUTGOING_CALL_PROC);	/* to avoid second ACU_DIGIT_CO after NS_CONN_CO */

					cc_process_ns_alert_in ();
					return;

					/*----------------------------*/
					/*          NS_CONN_CO        */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_CONN_CO) :

						/* Warn Application that dialing is complete */

					cc_snd_acu_digit_co ();

						/* and process NS_CONN_CO */

					cc_process_ns_conn_co ();
					return;

					/*----------------------------*/
					/*       NS_PROGRESS_IN       */
					/*----------------------------*/

#			if ACU_INTERFACE == ON

				case Event (NS_SAPI_SIG, NS_PROGRESS_IN) :
					cc_process_ns_progress_in ();
					return;

#			endif

					/*----------------------------*/
					/*     ACU_INFORMATION_RQ	  */
					/*----------------------------*/

#			if (ACU_INTERFACE == ON) && ((CC_PAR_KEYPAD_IE == ON) || (CC_PAR_DISPLAY_IE == ON))

				case Event (ACU_SAPI, ACU_INFORMATION_RQ) :
					cc_process_acu_information_rq ();
					return;

#			endif

			}
			return;

#		endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                 STATE_OUTGOING_CALL_PROC              */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_OUTGOING_CALL_PROC :

			switch (cc_event_id) {

					/*----------------------------*/
					/*         NS_ALERT_IN        */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_ALERT_IN) :
					cc_process_ns_alert_in ();
					return;

					/*----------------------------*/
					/*       NS_PROGRESS_IN       */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_PROGRESS_IN) :

#					if ACU_INTERFACE == ON
						cc_process_ns_progress_in ();
#					endif


						/*
							Activate B channel processing
							for VOICE-class calls only, if allowed by
							configuration.
						*/

					if ((Cc_call_service_class == CC_SRV_CLASS_VOICE) &&
						(Cc_call_b_chan_id != NO_CHAN) &&
						(Cc_na_out_calls_behaviour & CC_SEND_CONN_CO_ON_PROGRESS)
					   ) {

						cc_snd_conn_co_and_set_active ();
					}
					return;

					/*----------------------------*/
					/*          NS_CONN_CO        */
					/*----------------------------*/

				case Event (NS_SAPI_SIG, NS_CONN_CO) :

#					if CC_UUI == ON

						if (Uui_used == ON) {

							if (Cc_call_first_conn_rq_uui_response == ON &&
								Net_get_ie (NS_CONN_CO, IE_UUI) == ABSENT) {

								Cc_call_uui_rq = OFF;
							}

						} else {

							Cc_call_uui_rq = OFF;
						}

#					endif

					cc_process_ns_conn_co ();
					return;

					/*----------------------------*/
					/*      ACU_USER_INFO_RQ      */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_USER_INFO_RQ) :
					cc_process_acu_user_info_rq ();
					return;

#			  endif

					/*----------------------------*/
					/*      NS_USER_INFO_IN       */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (NS_SAPI_SIG, NS_USER_INFO_IN) :
					cc_process_ns_user_info_in ();
					return;

#			  endif

					/*----------------------------*/
					/*       ACU_FACILITY_RQ      */
					/*----------------------------*/

#			  if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) && (CC_ATT_HCDT == ON)

				case Event (ACU_SAPI, ACU_FACILITY_RQ) :

					if ((Spf_fac_used == ON) && (Att_hcdt_fac_used == ON)) {

							/*
							 * Allow facility while in state
							 * STATE_OUTGOING_CALL_PROC.
							 * The treatment is the same as for
							 * the active state.
							 */

						goto spf_rq_10;
					}

#			  endif

					/*----------------------------*/
					/*      NS_SPF_FACILITY_CO    */
					/*----------------------------*/

						/*
							Confirmation of the facility request during Call
							proceeding phase : nothing to answer to the user.
						*/


					/*----------------------------*/
					/*         ACU_DIGIT_RQ       */
					/*----------------------------*/

						/* Ignore any additional digits */

#				if ACU_INTERFACE == ON

					case Event (ACU_SAPI, ACU_DIGIT_RQ) :
						return;

#				endif

			}
			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     STATE_ACTIVE                      */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_ACTIVE :

			/*
				All clearing messages are treated
				by the previous switch (event_id).
			*/

			switch (cc_event_id) {

					/*----------------------------*/
					/*      ACU_USER_INFO_RQ      */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_USER_INFO_RQ) :
					cc_process_acu_user_info_rq ();
					return;

#			  endif

					/*----------------------------*/
					/*      NS_USER_INFO_IN       */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (NS_SAPI_SIG, NS_USER_INFO_IN) :
					cc_process_ns_user_info_in ();
					return;

#			  endif

					/*----------------------------*/
					/*     ACU_INFORMATION_RQ	  */
					/*----------------------------*/

#			  if (ACU_INTERFACE == ON) && ((CC_PAR_KEYPAD_IE == ON) || (CC_PAR_DISPLAY_IE == ON))

				case Event (ACU_SAPI, ACU_INFORMATION_RQ) :
					cc_process_acu_information_rq ();
					return;

#			  endif

					/*----------------------------*/
					/*          NS_CONN_CO        */
					/*----------------------------*/

					/*
						This can occur if CC has sent an ACU_CONN_CO when
						it has received NS_PROGRESS_IN.
						We need to send some of the IEs to the application
						so that they are not lost.
						These IEs will be put into an ACU_INFORMATION_IN.
					*/

#			  if ACU_INTERFACE == ON

				case Event (NS_SAPI_SIG, NS_CONN_CO) :

						/* Build an ACU_INFORMATION_IN */

					Acu_alloc_data (Acu_information_size +
									cc_display_total_size +
									cc_i_ext_lgth);

#					if CC_PAR_CHARGING_INFO == ON
						cc_read_charging_value_from_ns (NS_CONN_CO);
						Acu_information_charging_type   = cc_charging_type;
						Acu_information_charging_period = cc_charging_period;
						Acu_information_charging_multi  = cc_charging_multi;
						Acu_information_charging        = cc_charging;
#					else
						Acu_information_charging_type   = ACU_BYTE_VAL_NIL;
#					endif

					cc_store_display (Acu_conn_co_a_display_list, Acu_conn_co_a_display);

					cc_snd_to_user (ACU_INFORMATION_IN);
					break;

#			  endif

					/*----------------------------*/
					/*     NS_SPF_FACILITY_CO     */
					/*----------------------------*/

#			  if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) && (CC_ATT_HCDT == ON)

				case Event (NS_SAPI_SIG, NS_SPF_FACILITY_CO) :

				  spf_co_10:

					if (Spf_fac_used == ON) {

						if ((Net_get_ie (NS_SPF_FACILITY_CO, IE_OTHER_CALL_REF) == PRESENT) ||
							(Net_isdn_get_val (NS_SPF_FACILITY_CO, IE_SERVICE_ID, FLD_SERVICE_ID) == DA_TRANS_ACK)
						   ) {

								/* Get the conn_id of the HELD call */

							p_cc_call_sav = p_cc_call;	/* save current call context pointer */

							if (Net_isdn_get_val (NS_SPF_FACILITY_CO, IE_SERVICE_ID, FLD_SERVICE_ID) == DA_TRANS_ACK) {

								cc_other_conn_id = cc_current_conn_id;
								Cc_call_facility_code = ACU_FAC_TRF;
								goto state_spf_fac;

							} else {

								cc_other_conn_id = Net_isdn_get_val (NS_SPF_FACILITY_CO, IE_OTHER_CALL_REF, FLD_OTHER_CALL_REF);
							}

							if (cc_current_conn_id != cc_other_conn_id) {

									/*
									 * The conference is created on conn_id = cc_other_conn_id
									 * Access this new conn_id.
									 * Check that its state is STATE_SPF_FACILITY_RQ
									 * and that it is in a held condition.
									 */

								if (cc_access_conn_id (cc_other_conn_id) == OK) {

										/*
										 *	Check if it is an held call.
										 */

									if ((Cc_call_state == STATE_SPF_FACILITY_RQ) && (Cc_call_hold_state == ON)) {
										goto state_spf_fac;
									}

								} else {

										/*
											No held call is sharing the B channel:
											reject the outgoing call
										*/

									p_cc_call = p_cc_call_sav;

									Cc_set_acu_error (ACURC_NOLINE);
									return;

								}

							}

							Cc_call_facility_code = ACU_FAC_THREE_PARTY;
							goto state_spf_fac;

						}

					}

					return;

#			  endif

					/*----------------------------*/
					/*       ACU_SUSPEND_RQ       */
					/*----------------------------*/

#			  if (ACU_INTERFACE == ON) && (CC_SUSPEND_RESUME == ON)

				case Event (ACU_SAPI, ACU_SUSPEND_RQ) :

					if (Suspend_resume_used == ON) {
						p_call_id = Acu_suspend_a_call_id;
						cc_snd_to_ns (NS_SUSPEND_RQ);
						Cc_set_state (STATE_SUSPEND_RQ);
					}

					return;
#			  endif

					/*----------------------------*/
					/*       ACU_FACILITY_RQ      */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_FACILITY_RQ) :

#					if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) && (CC_ATT_HCDT == ON)
					  spf_rq_10 :
#					endif

#					if CC_SUPP_SERVICES == ON

						if ((Sup_services_used == ON) && (Acu_facility_code == ACU_FAC_TRANSPARENT)) {

							cc_facility_size = Acu_facility_facility_size;

							if (Acu_facility_facility_size != 0) {
								p_cc_facility = Acu_facility_a_facility;
							}

							p_rq_address = Acu_facility_a_called_address;
							cc_decode_address ((char FAR *FAR *)&p_rq_address, (char FAR *FAR *)&p_rq_subaddress);


								/* Get calling nb/sub-address */

							if (Acu_facility_calling_nb_size != 0) {

									/* Take transmitted values */

								p_calling_address = Acu_facility_a_calling_nb;
								cc_decode_address ((char FAR *FAR *)&p_calling_address, (char FAR *FAR *)&p_calling_subaddress);

							} else {

									/* Take configuration fields if not empty */

								p_calling_address    = (char FAR *)Cc_na_a_calling_nb;

								if (p_calling_address[0] == '\0') {
									p_calling_address = P_NIL;
								}

								p_calling_subaddress = (char FAR *)Cc_na_a_calling_sub_add;

								if (p_calling_subaddress[0] == '\0') {
									p_calling_subaddress = P_NIL;
								}

							}

							cc_snd_to_ns (NS_FAC_RQ);

							return;
						}

#					endif

#					if CC_SPF_FAC == ON

						if (Spf_fac_used == ON) {

								/*
									Only for :
										. call hold and retrieve
										. alternate
										. conference
										. transfer
										. ASN1

								*/

							cc_spf_facility_code	= Acu_facility_code;
							cc_spf_facility_action	= Acu_facility_action;

							if (Cc_call_facility_code == NIL) {

								switch (cc_spf_facility_code) {

									case ACU_FAC_HOLD :

										if (cc_spf_facility_action == ACU_RQ_ACTIVATE) {

											if (Cc_call_hold_state == OFF) {

													/*
														BRI and at5 : more than 1 held call at a time
														PRI: as many as needed
													*/

												Cc_call_facility_code = cc_spf_facility_code;

												if (cc_snd_to_ns (NS_SPF_FACILITY_RQ) == OK) {
													Cc_set_state (STATE_SPF_FACILITY_RQ);
													return;
												}
											}
										}
										break;

									case ACU_FAC_THREE_PARTY :
									case ACU_FAC_ALTERNATE :
									case ACU_FAC_RETRIEVE :

										if (cc_spf_facility_action == ACU_RQ_ACTIVATE) {

												/* The call must be held */

											if ((Cc_call_hold_state == ON)
#												if CC_ATT_HCDT == ON
													|| (Att_hcdt_fac_used  == ON)
#												endif
											   ) {

												Cc_call_facility_code = cc_spf_facility_code;

#												if CC_ATT_HCDT == ON

													if (Att_hcdt_fac_used == ON) {
														cc_other_conn_id = Acu_facility_conn_id;

														if ((cc_other_conn_id == cc_current_conn_id) &&
															(cc_spf_facility_code != ACU_FAC_RETRIEVE)) {

																/*
																	The call must be held first,
																	so indicate ACU_FAC_HOLD in
																	the confirmation message.
																*/

															Cc_call_facility_code = ACU_FAC_HOLD;
														}

													}

#												endif

												if (cc_snd_to_ns (NS_SPF_FACILITY_RQ) == OK) {
													Cc_set_state (STATE_SPF_FACILITY_RQ);
													return;
												}
											}
										}

										break;

									case ACU_FAC_TRF :

										Cc_call_facility_code = cc_spf_facility_code;

#										if CC_ATT_HCDT == ON

											if (Att_hcdt_fac_used == ON) {

												cc_other_conn_id = Acu_facility_conn_id;

												if (cc_other_conn_id == cc_current_conn_id) {

														/* This a HOLD process */

													Cc_call_facility_code = ACU_FAC_HOLD;

												}

												if (cc_snd_to_ns (NS_SPF_FACILITY_RQ) == OK) {
													Cc_set_state (STATE_SPF_FACILITY_RQ);
													return;
												}

												break;

											}

#										endif

											/*
												The transfer must concern the
												current Held call and the current
												active call which is sharing the same
												B channel.
											*/

										if ((cc_spf_facility_action == ACU_RQ_ACTIVATE) &&
											(Cc_call_hold_state == ON)
										   ) {

												/*
													Search for an active call on
													the same B channel.
												*/

											Cc_access_b_chan (Cc_call_b_chan_id);

											if (Cc_b_chan_p_active_call != P_NIL) {

													/* Found: send NS_FACILITY_RQ */

												if (cc_snd_to_ns (NS_SPF_FACILITY_RQ) == OK) {
													Cc_set_state (STATE_SPF_FACILITY_RQ);
													return;
												}
											}

										}
										break;


									case ACU_FAC_FEATURE_ACT :

#										if CC_ATT_HCDT == ON

											cc_button_type		= Acu_facility_button_type;
											cc_module_nb		= Acu_facility_module_nb;
											cc_button_nb		= Acu_facility_button_nb;
											cc_switchhook		= Acu_facility_switchhook;
											Cc_call_facility_code= cc_spf_facility_code;

											cc_current_conn_id 	= CONN_ID_MANAGEMENT;

											if (cc_snd_to_ns (NS_INFO_RQ) == OK) {
												Cc_set_state (STATE_SPF_FACILITY_RQ);
												return;
											}

#										endif

										break;


									case ACU_FAC_DROP :

#										if CC_ATT_HCDT == ON
											cc_snd_to_ns (NS_SPF_FACILITY_RQ);
#										endif

										return;
								}
							}
						}

#					endif

						/* Facility rejected */

					Memset_far ((char FAR *)&Acu_facility_network_cause, 0, Acu_facility_size - Offsetof (acu_facility, network_cause));
					Acu_facility_network_cause 	= ACU_NETWORK_CAUSE_NIL;
					Acu_facility_action 		= ACU_CO_REJ;

						/* Send response to user */

					cc_retransmit_to_user (ACU_FACILITY_CO);
					return;
#			  endif

					/*----------------------------*/
					/*         ACU_DIGIT_RQ       */
					/*----------------------------*/

						/* Ignore any additional digits */

#				if ACU_INTERFACE == ON

					case Event (ACU_SAPI, ACU_DIGIT_RQ) :

#						if ARINC_NETWORKS == ON

							if (((Cc_na_network == cc_a11) || (Cc_na_network == cc_a17)) &&
								(Cc_na_function != FG_NT_TE)) {
								cc_dtmf_digit		= Acu_digit_rq_dtmf_digit;
								cc_up_down_flag		= Acu_digit_rq_up_down;
								cc_dtmf_duration	= Acu_digit_rq_dtmf_duration;

								cc_snd_to_ns (NS_INFO_RQ);
							}

#						endif

						return;

#				endif

			}

			return; /* end of STATE_ACTIVE */

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                   STATE_RELEASE_RQ                    */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_RELEASE_RQ :

				/*
					The NS_CLEAR_CO is treated
					by the previous switch (R_msg_code).
				*/

			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                   STATE_RELEASE_IN                    */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_RELEASE_IN :

			switch (cc_event_id) {

					/*----------------------------*/
					/*        CC_HOOK_ON_RS       */
					/*----------------------------*/

#			  if CC_INTERFACE == ON

				case Event (CC_SAPI, CC_HOOK_ON_RS) :

#					if CC_UUI == ON

						if (Cc_call_uui_rq == ON) {
							p_cc_uui = (char FAR *)Cc_hook_on_rs_a_uui;
						}

#					endif

					cc_snd_to_ns  (NS_CLEAR_RS);
					return;
#			  endif

					/*----------------------------*/
					/*         ACU_CLEAR_RS       */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_CLEAR_RS) :

#					if CC_UUI == ON

						if ((Cc_call_uui_rq == ON) && (Acu_clear_rs_uui_size != 0)) {
							p_cc_uui = Acu_clear_rs_a_uui;
						}

#					endif

						/* Get display IE contents if present */

					cc_read_display_from_acu (Acu_clear_rs_a_display_list);

#					if CC_SUPP_SERVICES == ON

						if (Sup_services_used == ON) {
							cc_facility_size = Acu_clear_rs_facility_size;

							if (Acu_clear_rs_facility_size != 0) {
								p_cc_facility = Acu_clear_rs_a_facility;
							}
						}

#					endif

#					if ACU_PAR_EXTENDED_PRIM == ON
						cc_read_ext_parms_from_acu (p_data);
#					endif

					cc_snd_to_ns (NS_CLEAR_RS);
					return;
#			  endif

			}
			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                  STATE_RELEASE_USER                   */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_RELEASE_USER :

			switch (cc_event_id) {

					/*----------------------------*/
					/*         ACU_CLEAR_RS       */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_CLEAR_RS) :
					Cc_call_clear ();
					return;
#			  endif

			}
			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                   STATE_ERROR_IN                      */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_ERROR_IN :

			switch (cc_event_id) {

					/*----------------------------*/
					/*        CC_HOOK_ON_RS       */
					/*----------------------------*/

#			  if CC_INTERFACE == ON

				case Event (CC_SAPI, CC_HOOK_ON_RS) :
					Cc_call_clear ();
					return;
#			  endif
					/*----------------------------*/
					/*         ACU_CLEAR_RS       */
					/*----------------------------*/

#			  if ACU_INTERFACE == ON

				case Event (ACU_SAPI, ACU_CLEAR_RS) :
					Cc_call_clear ();
					return;
#			  endif

			}
			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                    STATE_SUSPEND_RQ                   */
			/*                                                       */
			/*-------------------------------------------------------*/

#	if (ACU_INTERFACE == ON) && (CC_SUSPEND_RESUME == ON)

		case STATE_SUSPEND_RQ :

			if (Suspend_resume_used == ON) {

				switch (cc_event_id) {

						/*----------------------------*/
						/*        NS_SUSPEND_CO       */
						/*----------------------------*/

					case Event (NS_SAPI_SIG, NS_SUSPEND_CO) :

						switch (cc_current_sapi_user) {

							case ACU_SAPI :

								cc_read_cause_from_ns (NS_SUSPEND_CO);

								Acu_alloc_data (Acu_suspend_size +
												cc_display_total_size);

								cc_store_display (Acu_suspend_a_display_list, Acu_suspend_a_display);

								if (cc_cause != 0xFF) {

										/* Suspend rejected :
										   go back to Active state.
										*/

									Acu_suspend_ret_code      = NOK;
									Acu_suspend_network_cause = cc_cause;
									cc_snd_to_user (ACU_SUSPEND_CO);
									Cc_set_state (STATE_ACTIVE);

								} else {

										/* Suspend acknowledged :
										   disconnect the B channel
										   and clear the call context.
										*/

									Acu_suspend_ret_code      = OK;
									Acu_suspend_network_cause = 0;
									cc_snd_to_user (ACU_SUSPEND_CO);
									Cc_call_clear ();
								}

								return;

						}

						return;

				}
			}

			return;

#	endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                    STATE_RESUME_RQ                    */
			/*                                                       */
			/*-------------------------------------------------------*/

#	if (ACU_INTERFACE == ON) && (CC_SUSPEND_RESUME == ON)

		case STATE_RESUME_RQ :

			if (Suspend_resume_used == ON) {

				switch (cc_event_id) {

						/*----------------------------*/
						/*        NS_RESUME_CO        */
						/*----------------------------*/

					case Event (NS_SAPI_SIG, NS_RESUME_CO) :

						switch (cc_current_sapi_user) {

							case ACU_SAPI :
								cc_read_cause_from_ns (NS_RESUME_CO);

								Acu_alloc_data (Acu_resume_size +
												cc_display_total_size);

								cc_store_display (Acu_resume_a_display_list, Acu_resume_a_display);

								if (cc_cause != 0xFF) {

										/* Resume rejected :
										   clear the call context.
										*/

									Acu_resume_ret_code      = NOK;
									Acu_resume_network_cause = cc_cause;
									cc_snd_to_user (ACU_RESUME_CO);
									Cc_call_clear ();

								} else {

										/* Resume acknowledged :
										   reconnect the B channel
										*/

									Acu_resume_ret_code      = OK;
									Acu_resume_network_cause = 0;

									cc_read_chan_id_from_ns (NS_RESUME_CO);

									cc_alloc_b_chan (cc_chan_id[0]);
									Acu_resume_data_chani      =
									Cc_call_b_chan_id	       = cc_chan_id[0];
									Cc_call_b_chan_excl        =
									Acu_resume_data_chani_excl = cc_chan_excl;

									cc_snd_to_user (ACU_RESUME_CO);

									if (Cc_profile_switch_rq_enable == ON) {
										cc_b_switch    (cc_chan_id[0], Cc_call_b_chan_mode, B_AUDIO_TONE_NIL);
									}

									if (Cc_profile_init_rq_enable == ON) {
										cc_b_init_stop (MPH_B_INIT_RQ);
									}

									Cc_set_state   (STATE_ACTIVE);
								}
								break;

						}
						return;

				}
			}

			return;

#	endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*               STATE_SPF_FACILITY_RQ                   */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_SPF_FACILITY_RQ :

#		  if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) && (CC_ATT_HCDT == ON)
			state_spf_fac :
#		  endif

#		  if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) /* { */

			if (Spf_fac_used == ON) {

				chan_id = 0;

				switch (cc_event_id) {

						/*----------------------------*/
						/*     NS_SPF_FACILITY_CO     */
						/*----------------------------*/

					case Event (NS_SAPI_SIG, NS_SPF_FACILITY_CO) :

						switch (cc_current_sapi_user) {

							case ACU_SAPI :

								cc_read_cause_from_ns (NS_SPF_FACILITY_CO);

#								if (ACU_PAR_EXT_FAC_ASN1 == ON) && (NS_SS_ECT == ON)
									cc_read_ext_facility_from_ns (NS_SPF_FACILITY_CO);
#								endif

							cc_fac_co:

								Acu_alloc_data (Acu_facility_size +
												cc_display_total_size);

								cc_store_display (Acu_facility_a_display_list, Acu_facility_a_display);

									/* If cause present ---> facility rejected */

								if (cc_cause != 0xFF) {

										/* Facility rejected */

									Acu_facility_action 		= ACU_CO_REJ;
									Acu_facility_code			= Cc_call_facility_code;
									Acu_facility_network_cause 	= cc_cause;

									cc_snd_to_user (ACU_FACILITY_CO);

								} else {

									switch (Cc_call_facility_code) {

										case ACU_FAC_HOLD :

												/* Set Hold condition on current CALL */

											Cc_call_hold_state = ON;
											Cc_na_hold_nb++;

												/* Set hold state for the B-channel */

											Cc_access_b_chan (Cc_call_b_chan_id);
											Setbit   (Cc_b_chan_used, CC_B_CHAN_HELD);
											Unsetbit (Cc_b_chan_used, CC_B_CHAN_USED);
											Cc_b_chan_p_active_call = P_NIL;
											Cc_b_chan_p_held_call   = p_cc_call;

#											if CC_ATT_HCDT == ON

												if (Att_hcdt_fac_used == ON) {

													if (Net_get_ie (NS_SPF_FACILITY_CO, IE_SERVICE_ID) == PRESENT) {

														switch (Net_isdn_get_val (NS_SPF_FACILITY_CO, IE_SERVICE_ID, FLD_SERVICE_ID)) {

															case DA_HOLD_ACK :
																Cc_call_facility_code = ACU_FAC_HOLD;
																break;

															case DA_TRANS_ACK :
																Cc_call_facility_code = ACU_FAC_TRF;
																break;
														}
													}
												}

#											endif

											break;

										case ACU_FAC_RETRIEVE :
										case ACU_FAC_THREE_PARTY :

												/* Reset Hold condition */

											if (cc_current_conn_id == cc_other_conn_id) {

													/* Clear hold state for the B-channel */

												Cc_access_b_chan (Cc_call_b_chan_id);

												Cc_call_hold_state = OFF;
												Cc_na_hold_nb--;

												Unsetbit (Cc_b_chan_used, CC_B_CHAN_HELD);
												Cc_b_chan_p_held_call   = P_NIL;

													/* Set the B-channel back to the active call */

												Setbit   (Cc_b_chan_used, CC_B_CHAN_USED);
												Cc_b_chan_p_active_call = p_cc_call;

											} else {

												cc_current_conn_id = cc_other_conn_id;
											}

#											if CC_ATT_HCDT == ON

												if (Att_hcdt_fac_used == ON) {

													cc_read_chan_id_from_ns (NS_SPF_FACILITY_CO);

													if (cc_chan_id[0] != NO_CHAN) {
														cc_alloc_b_chan (cc_chan_id[0]);
														Cc_call_b_chan_id = cc_chan_id[0];
													}
												}

#											endif

											break;

										case ACU_FAC_ALTERNATE :

												/*
													Transfer Hold condition on
													alternate active call:

													Search for the other call
													that shares the same B
													channel
												*/

											Cc_access_b_chan (Cc_call_b_chan_id);

											if (Cc_b_chan_p_active_call != P_NIL) {

													/*
														Found: set hold state to that call,
														and reset it on the original held call
													*/

												Cc_b_chan_p_active_call -> hold_state = ON;

												Cc_b_chan_p_held_call   = Cc_b_chan_p_active_call;
												Cc_b_chan_p_active_call = p_cc_call;

												Cc_call_hold_state	    = OFF;
											}

											break;

										case ACU_FAC_TRF :

												/*
													Transfer acknowledged :
													just warn user.
												*/

											break;

#									if CC_ATT_HCDT == ON

										case ACU_FAC_FEATURE_ACT :

												if (Net_get_ie (NS_SPF_FACILITY_CO, IE_SERVICE_ID) == PRESENT) {

													switch (Net_isdn_get_val (NS_SPF_FACILITY_CO, IE_SERVICE_ID, FLD_SERVICE_ID)) {

														case DA_HOLD_ACK :
															Cc_call_hold_state = ON;
															Cc_na_hold_nb++;

																/* Set hold state for the B-channel */

															Cc_access_b_chan (Cc_call_b_chan_id);

															Setbit   (Cc_b_chan_used, CC_B_CHAN_HELD);
															Unsetbit (Cc_b_chan_used, CC_B_CHAN_USED);
															Cc_b_chan_p_active_call = P_NIL;
															Cc_b_chan_p_held_call   = p_cc_call;

															Cc_call_facility_code   = ACU_FAC_HOLD;
															break;
													}

												}

											break;

#									endif

									}

										/* Facility acknowledged */

									Acu_facility_action 		= ACU_CO_ACK;
									Acu_facility_code			= Cc_call_facility_code;
									Acu_facility_network_cause 	= ACU_NETWORK_CAUSE_NIL;
									Acu_facility_data_chani		= chan_id;

										/* Send response to user */

									cc_snd_to_user (ACU_FACILITY_CO);
								}

								Cc_set_state (STATE_ACTIVE);
								Cc_call_facility_code = NIL;
								break;
						}

					  break;

						/*----------------------------*/
						/*          NS_HOLD_CO        */
						/*----------------------------*/

#			  	if NS_HOLD_RETRIEVE == ON

					case Event (NS_SAPI_SIG, NS_HOLD_CO) :

						switch (cc_current_sapi_user) {

							case ACU_SAPI :

								cc_read_cause_from_ns (NS_HOLD_CO);

								goto cc_fac_co;

						}

						break;

#				endif

						/*----------------------------*/
						/*          NS_RET_CO         */
						/*----------------------------*/

#			  	if NS_HOLD_RETRIEVE == ON

					case Event (NS_SAPI_SIG, NS_RET_CO) :

						switch (cc_current_sapi_user) {

							case ACU_SAPI :

								cc_read_cause_from_ns (NS_RET_CO);

								goto cc_fac_co;

						}

						break;

#				endif

						/*----------------------------*/
						/*     ACU_FACILITY_RQ  	  */
						/*----------------------------*/

					case Event (ACU_SAPI, ACU_FACILITY_RQ) :

#						if CC_ATT_HCDT == ON

							switch (Acu_facility_code) {

								case ACU_FAC_DROP :
								case ACU_FAC_RETRIEVE :
									cc_spf_facility_code = Acu_facility_code;
									cc_snd_to_ns (NS_SPF_FACILITY_RQ);
									break;


							}

#						endif

						break;

				}
			}

#		  endif /* } (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) */

			return;

			/*-------------------------------------------------------*/
			/*                                                       */
			/*               STATE_SPF_REGISTRATION_RQ               */
			/*                                                       */
			/*-------------------------------------------------------*/

		case STATE_SPF_REGISTRATION_RQ :

#		  if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) /* { */

			if (Spf_fac_used == ON) {

				switch (cc_event_id) {

						/*----------------------------*/
						/*   NS_SPF_REGISTRATION_CO   */
						/*----------------------------*/

					case Event (NS_SAPI_SIG, NS_SPF_REGISTRATION_CO) :

						switch (cc_current_sapi_user) {

							case ACU_SAPI :

								cc_read_cause_from_ns (NS_SPF_REGISTRATION_CO);

								Acu_alloc_data (Acu_facility_size);

								Acu_facility_code			= ACU_FAC_CALL_FORWARDING;

									/* If cause present ---> registration rejected */

								if (cc_cause != 0xFF) {

										/* Registration rejected */

									Acu_facility_action			= ACU_CO_REJ;
									Acu_facility_network_cause	= cc_cause;

								} else {

										/* Registration acknowledged */

									Acu_facility_action			= ACU_CO_ACK;
									Acu_facility_network_cause 	= ACU_NETWORK_CAUSE_NIL;
									Memcpy_far (Acu_facility_a_called_address, (char FAR *)Net_isdn_p_str (NS_SPF_REGISTRATION_CO, IE_SPF_FAC), Min (ACU_MX_SZ_CALLED_NB+1, Net_isdn_lgth_str (NS_SPF_REGISTRATION_CO, IE_SPF_FAC)));
								}

									/* Send response to user */

								cc_snd_to_user (ACU_FACILITY_CO);
								Cc_call_clear ();
								break;

						}
						return;

				}

			}

#		  endif /* } (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) */

			return;


			/*-------------------------------------------------------*/
			/*                                                       */
			/*                    UNKNOWN STATE                      */
			/*                                                       */
			/*-------------------------------------------------------*/

		default :
			return;

	}	/* End of switch (Cc_call_state) */

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_conn_in - implements the receipt of a NS_CONN_IN.

Usage           uchar cc_process_conn_in ();

Return value	: CONTINUE: continue processing
				  STOP: stop processing.

*--------------------------------------------------------------------------*/

uchar cc_process_conn_in ()
{
	signed char             i;							/* tmp index */
	uchar					cc_calling_sub_add_size;	/* received calling nb+sub address size */

	uchar				FAR	*p_data;					/* data pointer in primitive */

#	if CC_INTERFACE == ON
		uchar			FAR *p_cc_data;					/* data pointer in Call Control primitive */
#	endif

	conn_id_t               conn_id_sav;				/* CC current conn_id */
	struct cc_call      FAR *p_cc_call_sav;				/* temporary call pointer */
	struct cc_profile   FAR *p_cc_profile_sav;			/* temporary profile pointer */

#	if CC_SPF_FAC == ON

		if ((Spf_fac_used == ON) && (cc_setup_report_in == OFF)) {

				/* Terminal Deflection facility active ? */

			if (Cc_na_deflection_flag == ON) {

					/*
						Clear the call with a specific facility for
						deflection to another address.
					*/

				cc_spf_facility_action	= FT_SPF_FAC_RQ_ACTIVATE;
				cc_spf_facility_code	= FT_SPF_FAC_CALL_DEFLECTION;

				p_rq_address			= Cc_na_deflection_address;
				p_rq_subaddress			= Cc_na_deflection_subaddress;

				if (Cc_na_network == cc_tr6) {
					cc_error_class		= C_C_011;
					cc_error_value		= C_V_CALL_REJECTED;

				} else {

					cc_error_class		= C_C_NORMAL_EVENT;
					cc_error_value		= C_V_NORMAL_CLEARING_16;
				}

#				if CC_UUI == ON
					p_cc_uui = P_NIL;
#				endif

				cc_snd_to_ns			(NS_CLEAR_RQ);
				Cc_set_state			(STATE_RELEASE_NS);
				return (STOP);
			}

				/*--------------------------------*/
				/* Get ARINC specific-facility IE */
				/*--------------------------------*/

#			if ARINC_NETWORKS == ON

				if (Net_get_ie (NS_CONN_IN, IE_SPF_FAC) == PRESENT) {
					cc_spf_fac_id 	= Net_isdn_get_val (NS_CONN_IN, IE_SPF_FAC, FLD_SPF_FAC_ID);
					cc_spf_fac_code = Net_isdn_get_val (NS_CONN_IN, IE_SPF_FAC, FLD_SPF_FAC_CODE);

				} else {

					cc_spf_fac_id	=
					cc_spf_fac_code = BYTE_VAL_NIL;
				}

#			endif
		}

#	endif

			/* progress_ind */

#	if CC_PAR_PROGRESS_IND_IE == ON
		cc_read_progress_ind_from_ns (NS_CONN_IN);
#	endif

		/*-------------------------*/
		/* Get ARINC specific info */
		/*-------------------------*/

#	if ARINC_NETWORKS == ON

			/* notify */

		cc_notif_descr = 0xff;

		if (Net_get_ie (NS_CONN_IN, IE_NOTIF_IND) == PRESENT) {
			cc_notif_descr = Net_isdn_get_val (NS_CONN_IN, IE_NOTIF_IND, FLD_NOTIF_DESCR);
		}

			/* route_select */

		cc_nats_route_ind	=
		cc_satcom_route_ind	=
		cc_tfts_route_ind	= 0xff;

		if (Net_get_ie (NS_CONN_IN, IE_ROUTE_SELECT) == PRESENT) {
			cc_nats_route_ind	= Net_isdn_get_val (NS_CONN_IN, IE_ROUTE_SELECT, FLD_NATS);
			cc_satcom_route_ind	= Net_isdn_get_val (NS_CONN_IN, IE_ROUTE_SELECT, FLD_SATCOM);
			cc_tfts_route_ind	= Net_isdn_get_val (NS_CONN_IN, IE_ROUTE_SELECT, FLD_TFTS);
		}

			/* credit_card_nb */

		cc_read_credit_card_nb_from_ns (NS_CONN_IN);

			/* departure */

		cc_departure_year	=
		cc_departure_month	=
		cc_departure_day	=
		cc_service_class_id	= 0xff;

		cc_flight_op_id_size  =
		cc_flight_number_size = 0;

		p_cc_flight_op_id	=
		p_cc_flight_number	= P_NIL;

		if (Net_get_ie (NS_CONN_IN, IE_AIRCRAFT_INFO) == PRESENT) {
			cc_departure_year	= Net_isdn_get_val 	(NS_CONN_IN, IE_AIRCRAFT_INFO, FLD_DEPARTURE_YEAR);
			cc_departure_month	= Net_isdn_get_val 	(NS_CONN_IN, IE_AIRCRAFT_INFO, FLD_DEPARTURE_MONTH);
			cc_departure_day	= Net_isdn_get_val 	(NS_CONN_IN, IE_AIRCRAFT_INFO, FLD_DEPARTURE_DAY);
			cc_service_class_id	= Net_isdn_get_val 	(NS_CONN_IN, IE_AIRCRAFT_INFO, FLD_SERVICE_CLASS_ID);
			cc_flight_op_id_size= Net_isdn_lgth_str	(NS_CONN_IN, FLD_AIRCRAFT_INFO_OP_ID);
			cc_flight_number_size= Net_isdn_lgth_str(NS_CONN_IN, FLD_AIRCRAFT_NUMBER);
			p_cc_flight_op_id	= (char FAR *)Net_isdn_p_str(NS_CONN_IN, FLD_AIRCRAFT_INFO_OP_ID);
			p_cc_flight_number	= (char FAR *)Net_isdn_p_str(NS_CONN_IN, FLD_AIRCRAFT_NUMBER);
		}

#	endif

		/*------------------------------*/
		/* Get extended LLC information */
		/*------------------------------*/

#	if ACU_PAR_EXT_LLC == ON
		cc_read_ext_llc_from_ns (NS_CONN_IN);
#	endif

		/*--------------------------*/
		/* Get facility information */
		/*--------------------------*/

#	if CC_SUPP_SERVICES == ON

		cc_read_facility_from_ns (NS_CONN_IN);

#	else

#		if _ACU_PAR_EXT_FACILITY == ON
			cc_read_ext_facility_from_ns (NS_CONN_IN);
#		endif

#	endif

#	if ACU_PAR_EXT_CUG == ON
		cc_read_cug_from_ns (NS_CONN_IN);
#	endif

		/*---------------------*/
		/* Get UUI information */
		/*---------------------*/

#	if CC_UUI == ON

		if (Uui_used == ON) {

				/* UUI protocol */

			Cc_call_uui_rq = (Net_get_ie (NS_CONN_IN, IE_UUI) == PRESENT) ? Cc_na_uui_recognition : OFF;

			cc_read_uui_from_ns (NS_CONN_IN);

		} else {

			Cc_call_uui_rq = OFF;
		}

#	endif

		/*----------------------------*/
		/* Get Channel-id information */
		/*----------------------------*/

		/* Already read in cc_rcv (), stored into 'cc_chan_id[]' */

		/*
		   If a channel number is available
		   connect the assigned B channel
		   to the physical device else
		   ignore the call by clearing it except
		   in germany with DT_1TR6 or in NT side.
		*/

	if ((cc_setup_report_in    == OFF) &&
		(Cc_profile_service_id != CC_SERVICE_X25_PACKET) &&
		(Cc_call_p_cc_profile  != P_NIL)
	   ) {

			/*
				if indicated B-channel is already in use then
					if TE side then
						Look for an outgoing call using the same B-channel,
						If found then
							If the network has not answered yet
								(i.e. state=STATE_CALL_INIT) then
								clear this outgoing call attempt,
								accept the current incoming call.
							else
								if B-channel is held then
									accept the current incoming call.
								else
									if B-channel is 'exclusive', then
										reject the incoming call,
									else
										find a free channel.
					else (NT side)
							if B-channel is 'exclusive', then
								reject the incoming call,
							else
								find a free channel.
				else
					accept the current incoming call.
			*/

			/* Loop on all channels: check if not already used */

		for (i = cc_chan_nb - 1; i >= 0; i--) {

			struct cc_b_chan FAR  *p_cc_b_chan;

				/* Check if the provided channel id is already used */

			Cc_access_b_chan (cc_chan_id[i]);

			if (Cc_b_chan_used != CC_B_CHAN_FREE) {

#			  if EQUIPMENT == NT2

				if (Cc_na_function == FG_NT_TE) {

						/*
							(NT-side)

							Channel already allocated:
							if it is 'exclusive', then
								reject the call,
							else
								find a free channel.
						*/

					if (cc_chan_excl == CHAN_EXCL) {

							/* chan_id is exclusive: reject the call */

						if (Cc_na_network != cc_tr6) {

							if (Cc_na_network != cc_at5) {
								Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44);

							} else {

								Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34);
							}

							Cc_set_state (STATE_RELEASE_NS);
						}

						return (STOP);
					}

						/*
							Reset the channel list so that we try to find
							free channels.

							!!!WARNING!!!

							Do not reset the nb of channels,
							it is used to know how many of them are necessary!
						*/

					cc_chan_id[0] = NO_CHAN;

				} else {	/* TE-side */

#			  endif

						/* Save current call pointer */

					p_cc_call_sav = p_cc_call;

						/* Loop on calls */

					for (cc_access_first_call ();
						 p_cc_call != P_NIL;
						 cc_access_next_call ()
						) {

						if ((Cc_call_state == STATE_NULL) ||
							(Cc_call_b_chan_id != cc_chan_id [0])) {

								/* context not used, or */
								/* not the right B-channel */

							continue;
						}

							/* This call is using the same B-channel */

						if (Cc_call_state == STATE_CALL_INIT) {

								/*
									Found a call in STATE_CALL_INIT using
									the same B-channel: clear it and
									carry-on with the incoming call
								*/

									/* save conn_id */

							conn_id_sav        = cc_current_conn_id;

									/* send NS_CLEAR_RQ */

							cc_current_conn_id = Cc_call_conn_id;

							if (Cc_na_network != cc_tr6) {
								Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44);

							} else {

								Cc_set_ns_error (C_C_000, C_V_NORMAL_CLEARING_16);
							}

							cc_snd_to_ns (NS_CLEAR_RQ);

									/* free the B-channel associated to this */
									/* call to be able to allocate it to */
									/* the incoming call */

							p_cc_profile_sav   = p_cc_profile;
							p_cc_profile       = Cc_call_p_cc_profile;
							cc_reset_call_b_chan ();

									/* restore current context variables */

							cc_error_to        = ENT_NIL;
							cc_current_conn_id = conn_id_sav;
							p_cc_call          = p_cc_call_sav;
							p_cc_profile       = p_cc_profile_sav;

									/* carry-on with the incoming call */

							break;

						} else {

								/* The call is not in STATE_CALL_INIT */

#							if CC_SPF_FAC == ON

								if ((Spf_fac_used == ON) &&
									(Cc_call_hold_state == ON)) {

										/* The call is held: */
										/* accept the current incoming call */

										/* restore current context variables */

									p_cc_call = p_cc_call_sav;

										/* carry-on with the incoming call */

									break;
								}

#							endif

								/* restore current context variables */

							p_cc_call = p_cc_call_sav;

							if (cc_chan_excl == CHAN_EXCL) {

									/* chan_id is exclusive: reject the call */

								if (Cc_na_network != cc_tr6) {

									if (Cc_na_network != cc_at5) {
										Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44);

									} else {

										Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34);
									}

									Cc_set_state (STATE_RELEASE_NS);
								}

								return (STOP);
							}

								/*
									Reset the channel list so that we try to find
									free channels.

									!!!WARNING!!!

									Do not reset the nb of channels,
									it is used to know how many of them are necessary!
								*/

							cc_chan_id[0] = NO_CHAN;

								/* carry-on with the incoming call */

							break;
						} /* end else (!STATE_CALL_INIT) */

					} /* end for (all calls) */

#			  if EQUIPMENT == NT2

				} /* end else (TE-side) */

#			  endif

			} /* end if (B-channel used) */

		} /* end for (all B-channels) */

			/*
				if no chan_id has been provided,
				or it is already used but 'preferred' only,
				then try to find a free one.
			*/

		if (cc_chan_id[0] == NO_CHAN) {

			if (cc_find_free_b_chan () == NOK) {

				if (Cc_na_network != cc_tr6) {

					if (Cc_na_network == cc_a17) {
						Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44);

					} else if (Cc_na_network == cc_dms) {

						Cc_set_ns_error (C_C_NORMAL_EVENT, C_V_USER_BUSY_17);

					} else {

						Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34);
					}

					Cc_set_state (STATE_RELEASE_NS);
				}

				return (STOP);

			}

		} else {

				/* Allocate the received channels */

			for (i = cc_chan_nb - 1; i >= 0; i--) {
				cc_alloc_b_chan (cc_chan_id[i]);
				Cc_call_b_chan (i) = cc_chan_id[i];
			}

		}

	} else {

			/*
				copy the received B-channels list into the call context
				so that they are put in the indicated primitive
			*/

		for (i = cc_chan_nb - 1; i >= 0; i--) {
			Cc_call_b_chan (i) = cc_chan_id[i];
		}


	}

	Cc_call_b_chan_nb   = cc_chan_nb;
	Cc_call_b_chan_excl = cc_chan_excl;

		/*
			Force chan_id in first response to incoming call:
			TE side: if required by the standard,
			NT side: always.
		*/

	if ((Channel_id_in_first_rs == ON) ||
		(Cc_na_function == FG_NT_TE)) {

		cc_store_chan_id = ON;
	}

		/*---------------------------*/
		/* Get Called-nb information */
		/*---------------------------*/

		/* (Already extracted in cc_rcv () for address filtering) */

		/*--------------------------------*/
		/* Get Called-sub_add information */
		/*--------------------------------*/

		/* (Already extracted in cc_rcv () for address filtering) */

		/*----------------------------*/
		/* Get Calling-nb information */
		/*----------------------------*/

	if (Net_get_ie (NS_CONN_IN, IE_CALLING_NB) == PRESENT) {
		cc_calling_nb_size   = Net_isdn_lgth_str (NS_CONN_IN, IE_CALLING_NB);
		p_calling_address    = (char FAR *)Net_isdn_p_str (NS_CONN_IN, IE_CALLING_NB);
		cc_calling_nb_pres   = Net_isdn_get_val (NS_CONN_IN, IE_CALLING_NB, FLD_NB_PRES);
		cc_calling_nb_type   = Net_isdn_get_val (NS_CONN_IN, IE_CALLING_NB, FLD_NB_TYPE);
		cc_calling_nb_screen = Net_isdn_get_val (NS_CONN_IN, IE_CALLING_NB, FLD_NB_SCREEN);

	} else {

		cc_calling_nb_size   = 0;
		p_calling_address    = P_NIL;
		cc_calling_nb_pres   = ACU_NB_PRES_ALLOWED;
		cc_calling_nb_type   = ACU_NB_TYPE_UNKNOWN;
		cc_calling_nb_screen = ACU_NB_SCREEN_USER_PROVIDED;
	}

		/*-----------------------------------*/
		/* Get second Calling-nb information */
		/*-----------------------------------*/

#	if CC_PAR_MULTIPLE_CALLING_NB == ON

		Net_set_to_next_ie_instance (NS_CONN_IN, IE_CALLING_NB);

		if (Net_get_ie (NS_CONN_IN, IE_CALLING_NB) == PRESENT) {
			cc_calling_nb2_size   = Net_isdn_lgth_str (NS_CONN_IN, IE_CALLING_NB);
			p_calling_address2    = (char FAR *)Net_isdn_p_str (NS_CONN_IN, IE_CALLING_NB);
			cc_calling_nb2_pres   = Net_isdn_get_val (NS_CONN_IN, IE_CALLING_NB, FLD_NB_PRES);
			cc_calling_nb2_type   = Net_isdn_get_val (NS_CONN_IN, IE_CALLING_NB, FLD_NB_TYPE);
			cc_calling_nb2_screen = Net_isdn_get_val (NS_CONN_IN, IE_CALLING_NB, FLD_NB_SCREEN);

		} else {

			cc_calling_nb2_size   = 0;
			p_calling_address2    = P_NIL;
			cc_calling_nb2_pres   = ACU_NB_PRES_ALLOWED;
			cc_calling_nb2_type   = ACU_NB_TYPE_UNKNOWN;
			cc_calling_nb2_screen = ACU_NB_SCREEN_USER_PROVIDED;
		}

#	endif

		/*---------------------------------*/
		/* Get Calling-sub-add information */
		/*---------------------------------*/

	cc_calling_sub_add_size	= 0;
	p_calling_subaddress		= P_NIL;

#	if CC_CALLING_SUB_ADD == ON

		if (Calling_sub_add_used == ON) {

			if (Net_get_ie (NS_CONN_IN, IE_CALLING_SUB_ADD) == PRESENT) {
				cc_calling_sub_add_size = Net_isdn_lgth_str (NS_CONN_IN, IE_CALLING_SUB_ADD);
				p_calling_subaddress       = (char FAR *)Net_isdn_p_str (NS_CONN_IN, IE_CALLING_SUB_ADD);

					/*
						Make sure that the sub-address is a
						null-terminated string
					*/

				if (p_calling_subaddress [cc_calling_sub_add_size-1] != '\0') {
					p_calling_subaddress [cc_calling_sub_add_size++] = '\0';
				}

					/*
						See CC_RCV.C / Get called-sub-add part
					*/

				if (p_calling_subaddress [0] == FORMAT_IA5) {
					p_calling_subaddress ++;
					cc_calling_sub_add_size --;
				}

			}

		}

#	endif

		/*--------------------------*/
		/* Get redir-nb information */
		/*--------------------------*/

#	if CC_PAR_REDIR_NB == ON
		cc_read_redir_nb_from_ns (NS_CONN_IN);
#	endif

		/*-------------------------*/
		/* Get sending-complete IE */
		/*-------------------------*/

	cc_sending_complete = (Net_get_ie (NS_CONN_IN, IE_SENDING_COMPLETE) == ABSENT) ? OFF : ON;

#	if CC_OVERLAP_RECEIVING == ON

			/* Save the received digits if buffered Overlap Receiving is used. */

		if ((Overlap_rcv_used == ON) &&
			!(Cc_na_in_calls_behaviour & CC_TRANSPARENT_OVERLAP_RCV)
		   ) {

			if (cc_sending_complete == ON) {

					/*
						Sending-complete received:
						ensure that we've reached the minimum required digits
						Warning: cc_called_nb_size = nb of digit + '\0'
					*/

				if (cc_called_nb_size <= Cc_na_nb_digits_to_route) {

						/* not anough digits received: reject the call */

					if (Cc_na_network != cc_tr6) {
						Cc_set_ns_error (C_C_NORMAL_EVENT, C_V_INVALID_NUMBER_FORMAT_28);

					} else {

						Cc_set_ns_error (C_C_111, C_V_LOCAL_ERROR_PROCEDURE);
					}

					Cc_set_state (STATE_RELEASE_NS);
					return (STOP);

				}

					/*
						Else: do not wait for additional digits,
						continue NS_CONN_IN processing
					*/

			} else {

					/*
						Sending-complete not received:
						wait for additional digits if necessary
					*/

				Cc_call_nb_digit_rcv = 0;

				if (cc_called_nb_size != 0) {

					if (cc_setup_report_in == OFF) {

						Cc_call_nb_digit_rcv = cc_called_nb_size - 1;

							/* Warning! cc_called_nb_size equals "nb of digit + '\0'" */

						if (cc_called_nb_size <= Cc_na_nb_digits_to_route) {

								/*
								 * Some other digits are missing.
								 * Store the received digits and save the
								 * data stored in the CONN_IN.
								 */

							Memcpy_far (Cc_call_a_build_called_nb, (char FAR *)p_called_nb, cc_called_nb_size);
							cc_called_nb_size = 0;	/* to avoid further data allocation */

						} else {

								/* Enough digits received */

							Cc_set_state (STATE_AWAIT_ADDITIONAL_DIGIT);
						}

					}

				}

				if (cc_called_sub_add_size != 0) {
					Memcpy_far (Cc_call_a_build_called_sub_add, (char FAR *)p_called_sub_add, cc_called_sub_add_size);
					Cc_call_called_sub_add_size = cc_called_sub_add_size;
				}

			}

		}

#	endif

		/*=============================================*/
		/*                                             */
		/* Build the CC_RING_IN/ACU_CONN_IN primitives */
		/*                                             */
		/*=============================================*/

	switch (cc_current_sapi_user) {

#	  if CC_INTERFACE == ON

		case CC_SAPI :

			Cc_alloc_data (Cc_ring_in_size);

				/* copy the B channel number if any */

			Cc_ring_in_b_chan_id = Cc_call_b_chan_id;

				/* copy the service id */

			Cc_ring_in_service_id = (p_cc_profile == P_NIL) ? ACU_NO_SERVICE : Cc_profile_id;
			Cc_ring_in_user_rate  = Cc_call_user_rate;

				/* copy the calling nb if any */

			if (cc_calling_nb_size != 0) {
				Strcpy_far ((char FAR *)Cc_ring_in_a_calling_nb, p_calling_address, CC_MX_SZ_CALLING_NB+1);
			}

#			if CC_CALLING_SUB_ADD == ON

					/* copy the calling sub address if any */

				if (Calling_sub_add_used == ON) {

					if (cc_calling_sub_add_size != 0) {
						Strcpy_far ((char FAR *)Cc_ring_in_a_calling_sub_add, p_calling_subaddress, CC_MX_SZ_CALLING_SUB_ADD+1);
					}
				}

#			endif

#			if CC_UUI == ON

					/* copy the UUI if present */

				if (cc_uui_size != 0) {
					Strcpy_far ((char FAR *)Cc_ring_in_a_uui, p_cc_uui, CC_MX_SZ_UUI+1);
				}

#			endif

#			if CC_OVERLAP_RECEIVING == ON

				if (Overlap_rcv_used == ON) {

					if ((cc_called_nb_size <= Cc_na_nb_digits_to_route) &&
						(cc_sending_complete == OFF)) {

							/* Save the data of the received NS_CONN_IN */

						Cc_call_p_conn_in	= p_snd_msg;
						p_snd_msg			= P_NIL;

							/* Send a SETUP ACKNOWLEDGE */

						cc_snd_to_ns (NS_SETUP_ACK_RQ);

						Cc_set_state (STATE_AWAIT_DIGIT);

						return (STOP);
					}

				}

#			endif

				/* and send the message to the Application entity */

			cc_snd_to_user (CC_RING_IN);
			break;

#	  endif

#	  if ACU_INTERFACE == ON

		case ACU_SAPI :

				/*
					Determine ACU-packed-form calling_nb*sub-add
					and called_nb*sub_add sizes.
				*/

			if (cc_calling_sub_add_size != 0) {
				cc_calling_nb_size	+= cc_calling_sub_add_size + (cc_calling_nb_size == 0 ? 1 : 0);
			}

			if (cc_called_sub_add_size != 0) {
				cc_called_nb_size	+= cc_called_sub_add_size  + (cc_called_nb_size  == 0 ? 1 : 0);
			}

#			if CC_OVERLAP_RECEIVING == ON

				if (Overlap_rcv_used == ON) {
					Cc_call_called_sub_add_size = cc_called_sub_add_size;
				}

#			endif

				/*-------------------------------------------*/
				/* Allocate a message and a buffer if needed */
				/*-------------------------------------------*/

#			if ACU_PAR_EXT_LLC == ON
				cc_ext_lgth = cc_ext_llc.hdr.lgth;
#			endif

			Acu_alloc_data (Acu_conn_in_size      + \
							cc_calling_nb_size    + \
							cc_calling_nb2_size   + \
							cc_called_nb_size     + \
							cc_redir_nb_size      + \
							cc_uui_size           + \
							cc_facility_size      + \
							cc_display_total_size + \
							cc_track_1_size       + \
							cc_track_2_size       + \
							cc_flight_op_id_size  + \
							cc_flight_number_size + \
							cc_ext_lgth           + \
							cc_i_ext_lgth);

#			if (SIMULATION == ON) && (ACU_INTERFACE == ON)
				p_acu_conn_in = (struct acu_conn_in_args FAR *)p_data;
#			endif

				/*--------------------------------------*/
				/* Store service_id and service_list_id */
				/*--------------------------------------*/

			if (cc_setup_report_in == OFF) {
				Acu_conn_in_service			= (p_cc_profile == P_NIL) ? cc_service_id : Cc_profile_id;

			} else {

				Acu_conn_in_service			= cc_service_id;
			}

			Acu_conn_in_service_list_id = Cc_na_service_list_id (Cc_call_x_current_service_list);

#			if CC_PAR_SEMI_PERMANENT_CIRCUITS == ON
				Acu_conn_in_semi_permanent_circuit = Cc_call_semi_permanent_circuit;
#			endif

				/*--------------------*/
				/* Store layer 1 info */
				/*--------------------*/

				/* Copy layer 1 information from the internal temporary variable */

			cc_layer_1_info.ph_rate = cc_layer_1_info.user_rate;
			cc_put_layer_1_info_from_temp (Acu_conn_in_a_layer_1_info);

				/*-------------------*/
				/* Store channel-ids */
				/*-------------------*/

			cc_write_call_chan_list_to_acu ((struct chani_list FAR *)&Acu_conn_in_data_chani_nb);

			Acu_conn_in_interworking	= cc_interworking;

			Acu_conn_in_sending_complete= cc_sending_complete;

				/*-----------------------*/
				/* Store call_appearance */
				/*-----------------------*/

#			if CC_ATT_HCDT == ON

				cc_dest_call_appear          = ACU_BYTE_VAL_NIL;

				if (Net_get_ie (NS_CONN_IN, IE_DEST_CALL_APPEAR) == PRESENT) {
					cc_dest_call_appear      = Net_isdn_get_val (NS_CONN_IN, IE_DEST_CALL_APPEAR, FLD_DEST_CALL_APPEAR);
				}

				Acu_conn_in_dest_call_appear = cc_dest_call_appear;
#			else

				Acu_conn_in_dest_call_appear = ACU_BYTE_VAL_NIL;
#			endif

				/*
					Be carefull to store the variable-length
					fields in their ACU_INT.H-defined order.
				*/

				/*---------------------------*/
				/* Store CALLING NUMBER info */
				/*---------------------------*/

			Acu_conn_in_calling_nb_pres   = cc_calling_nb_pres;
			Acu_conn_in_calling_nb_type   = cc_calling_nb_type;
			Acu_conn_in_calling_nb_screen = cc_calling_nb_screen;
			Acu_conn_in_calling_nb_size   = cc_calling_nb_size;
			cc_build_address (p_calling_address, p_calling_subaddress, Acu_conn_in_a_calling_nb);

				/*----------------------------------*/
				/* Store second CALLING NUMBER info */
				/*----------------------------------*/

#			if CC_PAR_MULTIPLE_CALLING_NB == ON

				Acu_conn_in_calling_nb2_pres   = cc_calling_nb2_pres;
				Acu_conn_in_calling_nb2_type   = cc_calling_nb2_type;
				Acu_conn_in_calling_nb2_screen = cc_calling_nb2_screen;
				Acu_conn_in_calling_nb2_size   = cc_calling_nb2_size;
				cc_build_address (p_calling_address2, P_NIL, Acu_conn_in_a_calling_nb2);

#			endif

				/*-------------------------------*/
				/* Overlap-receiving procedure ? */
				/*-------------------------------*/

#			if CC_OVERLAP_RECEIVING == ON

					/*
						Send back a SETUP_ACK if buffered Overlap Receiving
						is used.
					*/

				if ((cc_setup_report_in == OFF) &&
					(Overlap_rcv_used == ON) &&
					!(Cc_na_in_calls_behaviour & CC_TRANSPARENT_OVERLAP_RCV)
				   ) {

						/* Bufferized overlap receiving mode */

					if ((cc_called_nb_size <= Cc_na_nb_digits_to_route) &&
						(cc_sending_complete == OFF)) {

						Acu_conn_in_called_nb_size	= 0;
						p_called_nb      			= P_NIL;
						p_called_sub_add			= P_NIL;

							/* Save the ACU_CONN_IN message */

						Cc_call_p_conn_in	= p_snd_msg;
						p_snd_msg			= P_NIL;

							/* Send a SETUP ACKNOWLEDGE */

						cc_snd_to_ns (NS_SETUP_ACK_RQ);

							/* And wait for additional digits */

						Cc_set_state (STATE_AWAIT_DIGIT);
						return (STOP);
					}

				}

#			endif

				/*--------------------------*/
				/* Store CALLED NUMBER info */
				/*--------------------------*/

			Acu_conn_in_called_nb_type = cc_called_nb_type;
			Acu_conn_in_called_nb_plan = cc_called_nb_plan;
			Acu_conn_in_called_nb_size = cc_called_nb_size;
			cc_build_address ((char FAR *)p_called_nb, (char FAR *)p_called_sub_add, Acu_conn_in_a_called_nb);

				/*------------------------------*/
				/* Store REDIRECTED NUMBER info */
				/*------------------------------*/

#			if CC_PAR_REDIR_NB == ON
				cc_store_redir_nb_in_acu_prim ((struct acu_redir_nb FAR *)&(Acu_conn_in_ redir_nb), Acu_conn_in_a_redir_nb);
#			endif

				/*----------------*/
				/* Store UUI info */
				/*----------------*/

#			if CC_UUI == ON

				Acu_conn_in_uui_size = cc_uui_size;

				if (cc_uui_size != 0) {
					Strcpy_far (Acu_conn_in_a_uui, p_cc_uui, ACU_MX_SZ_UUI+1);
				}

#			endif

				/*---------------------*/
				/* Store FACILITY info */
				/*---------------------*/

#			if CC_SUPP_SERVICES == ON

				if (Sup_services_used == ON) {
					Acu_conn_in_facility_size = cc_facility_size;

					if (cc_facility_size != 0) {
						Memcpy_far (Acu_conn_in_a_facility, p_cc_facility, cc_facility_size);
						cc_facility_size = 0;	/* To avoid sending of facility in a automatic NS_CONN_RS */
					}
				}

#			endif

				/*--------------------*/
				/* Store DISPLAY info */
				/*--------------------*/

			cc_store_display (Acu_conn_in_a_display_list, Acu_conn_in_a_display);

				/*-------------------------*/
				/* Store PROGRESS_IND info */
				/*-------------------------*/

			cc_store_progress_ind (&Acu_conn_in_ progress_ind);

				/*-------------------------------------*/
				/* Store ARINC specific info & strings */
				/*-------------------------------------*/

#			if ARINC_NETWORKS == ON

					/* notify */

				Acu_conn_in_notif_descr 		= cc_notif_descr;

#				if CC_SPF_FAC == ON

					Acu_conn_in_spf_fac_val 	= cc_spf_fac_code;
					Acu_conn_in_spf_fac_id		= cc_spf_fac_id;

#				endif

					/* departure */

				Acu_conn_in_departure_year		= cc_departure_year;
				Acu_conn_in_departure_month		= cc_departure_month;
				Acu_conn_in_departure_day		= cc_departure_day;
				Acu_conn_in_service_class_id	= cc_service_class_id;

					/* route_select */

				Acu_conn_in_nats_route_ind		= cc_nats_route_ind;
				Acu_conn_in_satcom_route_ind	= cc_satcom_route_ind;
				Acu_conn_in_tfts_route_ind		= cc_tfts_route_ind;

					/* credit_card */

				Acu_conn_in_track_1_size 		= cc_track_1_size;
				Acu_conn_in_track_2_size 		= cc_track_2_size;
				Acu_conn_in_flight_op_id_size 	= cc_flight_op_id_size;
				Acu_conn_in_flight_number_size 	= cc_flight_number_size;

				if (cc_track_1_size != 0) {
					Memcpy_far (Acu_conn_in_a_track_1, p_cc_track_1, cc_track_1_size+1);
				}

				if (cc_track_2_size != 0) {
					Memcpy_far (Acu_conn_in_a_track_2, p_cc_track_2, cc_track_2_size+1);
				}

				if (cc_flight_op_id_size != 0) {
					Strcpy_far (Acu_conn_in_a_flight_op_id, p_cc_flight_op_id, cc_flight_op_id_size + 1);
				}

				if (cc_flight_number_size != 0) {
					Strcpy_far (Acu_conn_in_a_flight_number, p_cc_flight_number, cc_flight_number_size + 1);
				}

#			endif

				/*----------------------------*/
				/* Store extended information */
				/*----------------------------*/

#			if ACU_PAR_EXTENDED_PRIM == ON
				cc_store_ext_data_in_acu_prim (p_data, Acu_conn_in_a_end_strings);
#			endif

				/*------------------*/
				/* Send ACU_CONN_IN */
				/*------------------*/

			if (cc_setup_report_in == OFF) {

					/*
						No ACU_SETUP_REPORT_IN to be sent:
						send ACU_CONN_IN.
					*/

				cc_snd_to_user (ACU_CONN_IN);

					/* Automatic generation of ACU_ALERT_IN ? */

				if (Cc_na_in_calls_behaviour & CC_SEND_ALERT_IN) {
					Acu_alloc_data (Acu_alert_in_size);
					Acu_alert_in_alert = ACUAC_RING;

#					if CC_PAR_PROGRESS_IND_IE == ON
						Acu_alert_in_progress_ind_nb      = 0;
						Acu_alert_in_progress_location    = ACU_BYTE_VAL_NIL;
						Acu_alert_in_progress_description = ACU_BYTE_VAL_NIL;
#					endif

#					if CC_PAR_SIGNAL_IE == ON
						Acu_alert_in_signal_val           = ACU_BYTE_VAL_NIL;
#					endif

					cc_snd_to_user (ACU_ALERT_IN);
				}

			} else {

					/*
						Only report to the user and then
						free the call context.
					*/

				cc_current_sapi_user = ACU_SAPI_MGT;
				cc_current_conn_id   = CONN_ID_MANAGEMENT;

				cc_snd_to_user (ACU_SETUP_REPORT_IN);

				cc_current_conn_id   = Cc_call_conn_id;
				Cc_call_clear ();

					/*
						Reset uui pointer so that it is
						not sent in the NS_CLEAR_RQ.
					*/

#				if CC_UUI == ON
					p_cc_uui = P_NIL;
#				endif

				return (STOP);
			}

			break;

#	  endif

	}

#	if CC_UUI == ON

			/* Set UUI to send back to NS (first response to NS) */

		if (Cc_call_uui_rq == ON) {
			p_cc_uui = p_cc_empty_string;	/* empty UUI */
		}

#	endif

		/*
			Reset the global variable if not to be used so that it is not
			used for coding the next message sent to NS
		*/

	if (cc_store_chan_id == OFF) {
		cc_chan_id[0] = NO_CHAN;
	}

	return (CONTINUE);

} /* end of cc_process_conn_in () */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_ns_call_proc_in

Description     process NS_CALL_PROC_IN message.

Usage           cc_process_ns_call_proc_in ();

*--------------------------------------------------------------------------*/

void cc_process_ns_call_proc_in ()
{
		/* Change call state */

	Cc_set_state (STATE_OUTGOING_CALL_PROC);

		/* Get the B channel number to be used if any */

	cc_read_chan_id_from_ns (NS_CALL_PROC_IN);

	if (cc_chan_nb != 0) {

		if (cc_alloc_b_chan_if_allowed () == STOP) {

				/* the received B channel is not allowed, stop */

			return;
		}

	}

#	if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON)

			/*
				Is there any facility to be sent during
				Call proceeding phase ?
			*/

		if (Cc_call_facility_code != NIL) {
			cc_spf_facility_action = ACU_RQ_ACTIVATE;
			cc_spf_facility_code   = Cc_call_facility_code;
			cc_snd_to_ns (NS_SPF_FACILITY_RQ);
		}

#	endif

#	if ACU_INTERFACE == ON

			/*
				Send ACU_PROGRESS_IN if not done before
				or if ASN1 facility is received
			*/

#		if _ACU_PAR_EXT_FACILITY == ON
			cc_read_ext_facility_from_ns (NS_CALL_PROC_IN);
#		endif

		if ((cc_current_sapi_user == ACU_SAPI) &&
			((Cc_call_previous_state == STATE_CALL_INIT) ||
			 (cc_i_ext_lgth != 0)
			)) {

#			if CC_PAR_PROGRESS_IND_IE == ON
				cc_read_progress_ind_from_ns (NS_CALL_PROC_IN);
#			endif

#			if CC_PAR_SIGNAL_IE == ON
				cc_signal_val = 0xff;
#			endif

				/* Send ACU_PROGRESS_IN */

			cc_snd_acu_progress_in (ACUEV_DIAL_TONE);

		}

#   endif

		/* switch B channel if available, and warn the user. */

	cc_switch_outgoing_call_b_channel ();
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_ns_alert_in

Description     process NS_ALERT_IN message.

Usage           cc_process_ns_alert_in ();

*--------------------------------------------------------------------------*/

void cc_process_ns_alert_in ()
{
#	if ACU_INTERFACE == ON
		uchar FAR *p_data;
#	endif

#	if (CC_INTERFACE == ON) && (CC_ADDRESS_FILTERING == OFF)
		uchar FAR *p_cc_data;
#	endif

#	if CC_PAR_PROGRESS_IND_IE == ON
		cc_read_progress_ind_from_ns (NS_ALERT_IN);
#	endif

#	if CC_PAR_SIGNAL_IE == ON
		cc_read_signal_from_ns       (NS_ALERT_IN);
#	endif

#	if CC_PAR_REDIR_NB == ON
		cc_read_redir_nb_from_ns     (NS_ALERT_IN);
#	endif

		/* Get the B channel number to be used if any */

	cc_read_chan_id_from_ns (NS_ALERT_IN);

	if (cc_chan_nb != 0) {

		if (cc_alloc_b_chan_if_allowed () == STOP) {

				/* the received B channel is not allowed, stop */

			return;
		}

	}

		/* UUI protocol */

#	if CC_UUI == ON

		if (Uui_in_alert == ON) {

			if (Uui_used == ON) {

				if (Net_get_ie (NS_ALERT_IN, IE_UUI) == ABSENT) {
					Cc_call_uui_rq = OFF;

				} else {

					cc_read_uui_from_ns (NS_ALERT_IN);
				}

			} else {

				Cc_call_uui_rq = OFF;
			}
		}

		Cc_call_first_conn_rq_uui_response = OFF;

#	endif

#	if CC_SUPP_SERVICES == ON

		cc_read_facility_from_ns (NS_ALERT_IN);

#	else

#		if _ACU_PAR_EXT_FACILITY == ON
			cc_read_ext_facility_from_ns (NS_ALERT_IN);
#		endif

#	endif

	switch (cc_current_sapi_user) {

#	  if (CC_INTERFACE == ON) && (CC_ADDRESS_FILTERING == OFF)

		case CC_SAPI :

			Cc_alloc_data (Cc_alert_size);

#			if CC_UUI == ON

				if (cc_uui_size != 0) {
					Strcpy_far ((char FAR *)Cc_alert_a_uui, p_cc_uui, CC_MX_SZ_UUI+1);
				}

#			endif

			cc_snd_to_user (CC_ALERT_IN);
			break;
#	  endif

#	  if ACU_INTERFACE == ON

		case ACU_SAPI :
			Acu_alloc_data (Acu_alert_in_size +
							cc_redir_nb_size +
							cc_uui_size +
							cc_facility_size +
							cc_display_total_size +
							cc_i_ext_lgth);

			Acu_alert_in_alert = ACUAC_REMOTE_ALERTED;

				/*-------------------*/
				/* Store channel-ids */
				/*-------------------*/

			cc_write_call_chan_list_to_acu ((struct chani_list FAR *)&Acu_alert_in_data_chani_nb);

			cc_store_progress_ind (&Acu_alert_in_ progress_ind);

#			if CC_PAR_SIGNAL_IE == ON
				Acu_alert_in_signal_val				= cc_signal_val;
#			endif

				/*------------------------------*/
				/* Store REDIRECTED NUMBER info */
				/*------------------------------*/

#			if CC_PAR_REDIR_NB == ON
				cc_store_redir_nb_in_acu_prim ((struct acu_redir_nb FAR *)&(Acu_alert_in_ redir_nb), Acu_alert_in_a_redir_nb);
#			endif

#			if CC_UUI == ON

				Acu_alert_in_uui_size = cc_uui_size;

				if (cc_uui_size != 0) {
					Strcpy_far (Acu_alert_in_a_uui, p_cc_uui, ACU_MX_SZ_UUI+1);
				}

#			endif

			Acu_alert_in_facility_size = cc_facility_size;

			if (cc_facility_size != 0) {
				Memcpy_far (Acu_alert_in_a_facility, p_cc_facility, cc_facility_size);
			}

			cc_store_display (Acu_alert_in_a_display_list, Acu_alert_in_a_display);

#			if ACU_PAR_EXTENDED_PRIM == ON
				cc_store_ext_data_in_acu_prim (p_data, Acu_alert_in_a_end_strings);
#			endif

			cc_snd_to_user (ACU_ALERT_IN);
			break;

#	  endif

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_ns_user_info_in

Description     process NS_USER_INFO_IN message.

Usage           cc_process_ns_user_info_in ();

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_process_ns_user_info_in ()
{
	uchar FAR *p_data;

#	if CC_UUI == ON
		cc_read_uui_from_ns (NS_USER_INFO_IN);
#	endif

#	if _ACU_PAR_EXT_FACILITY == ON
		cc_read_ext_facility_from_ns (NS_USER_INFO_IN);
#	endif

	Acu_alloc_data (Acu_user_info_size +
					cc_uui_size +
					cc_i_ext_lgth);

#	if CC_UUI == ON

		Acu_user_info_uui_size = cc_uui_size;

		if (cc_uui_size != 0) {
			Strcpy_far (Acu_user_info_a_uui, p_cc_uui, ACU_MX_SZ_UUI+1);
		}

#	endif

#	if ACU_PAR_EXTENDED_PRIM == ON
		cc_store_ext_data_in_acu_prim (p_data, Acu_user_info_a_end_strings);
#	endif

	cc_snd_to_user (ACU_USER_INFO_IN);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_acu_user_info_rq

Description     process ACU_USER_INFO_RQ message.

Usage           cc_process_acu_user_info_rq ();

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_process_acu_user_info_rq ()
{
	uchar FAR *p_data = p_data_cc;

		/* Read received info */

#	if CC_UUI == ON

		if (Acu_user_info_uui_size != 0) {
			p_cc_uui = Acu_user_info_a_uui;
		}

#	endif

#	if ACU_PAR_EXTENDED_PRIM == ON
		cc_read_ext_parms_from_acu (p_data);
#	endif

		/* build and send NS_USER_INFO_RQ */

	cc_snd_to_ns (NS_USER_INFO_RQ);

		/* Set state to the current state to update the 'previous_state' */

	Cc_set_state (Cc_call_state);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_acu_information_rq

Description     process ACU_INFORMATION_RQ message.

Usage           cc_process_acu_information_rq ();

*--------------------------------------------------------------------------*/

#if (ACU_INTERFACE == ON) && ((CC_PAR_KEYPAD_IE == ON) || (CC_PAR_DISPLAY_IE == ON))

void cc_process_acu_information_rq ()
{
	uchar FAR *p_data = p_data_cc;

		/* Get Keypad IE contents if allowed and present */

#	if CC_PAR_KEYPAD_IE == ON

		if (Cc_param_keypad_implemented == ON) {

			if ((cc_keypad_size = Acu_information_keypad_size) != 0) {
				p_cc_keypad = Acu_information_a_keypad;
			}

		} else {

			cc_keypad_size = 0;	/* no Keypad */
		}

#	endif

		/* Get display IE contents if present */

	cc_read_display_from_acu (Acu_information_a_display_list);

		/* Send NS_INFO_RQ only if Keypad or Display are available */

#	if (CC_PAR_KEYPAD_IE == ON) || (CC_PAR_DISPLAY_IE == ON)

		if ((cc_display_total_size != 0) ||
			(cc_keypad_size != 0)
		   ) {
			cc_snd_to_ns (NS_INFO_RQ);
		}

#	endif

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_ns_progress_in - processing of a NS_PROGRESS_IN.

Usage           void cc_process_ns_progress_in ();

Return value	none

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_process_ns_progress_in ()
{

	if (cc_current_sapi_user == ACU_SAPI) {

			/*
				Send ACU_PROGRESS_IN to warn the user
				that an Interworking situation occured.
			*/

		cc_read_cause_from_ns (NS_PROGRESS_IN);

#		if CC_PAR_PROGRESS_IND_IE == ON
			cc_read_progress_ind_from_ns (NS_PROGRESS_IN);
#		endif

#		if CC_PAR_SIGNAL_IE == ON
			cc_signal_val = ACU_BYTE_VAL_NIL;
#		endif

#		if _ACU_PAR_EXT_FACILITY == ON
			cc_read_ext_facility_from_ns (NS_PROGRESS_IN);
#		endif

		cc_snd_acu_progress_in (ACUEV_INTERWORKING);
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_ns_conn_co

Description     process NS_CONN_CO message.

Usage           cc_process_ns_conn_co ();

*--------------------------------------------------------------------------*/

void cc_process_ns_conn_co ()
{

		/*--------------------------*/
		/* Get charging information */
		/*--------------------------*/

#	if CC_PAR_CHARGING_INFO == ON
		cc_read_charging_value_from_ns (NS_CONN_CO);
#	endif

		/*--------------------------*/
		/* Get redir-nb information */
		/*--------------------------*/

#	if CC_PAR_REDIR_NB == ON
		cc_read_redir_nb_from_ns (NS_CONN_CO);
#	endif

		/* process received B channel */

	cc_read_chan_id_from_ns (NS_CONN_CO);

	if (cc_chan_nb != 0) {

		if (cc_alloc_b_chan_if_allowed () == STOP) {

				/* the received B channel is not allowed, stop */

			return;
		}

	}

#	if CC_UUI == ON
		cc_read_uui_from_ns (NS_CONN_CO);
#	endif

#	if CC_PAR_DATE_TIME == ON
		cc_read_date_time_from_ns (NS_CONN_CO);
#	endif

		/*--------------------------*/
		/* Get facility information */
		/*--------------------------*/

#	if CC_SUPP_SERVICES == ON

		cc_read_facility_from_ns (NS_CONN_CO);

#	else

#		if _ACU_PAR_EXT_FACILITY == ON
			cc_read_ext_facility_from_ns (NS_CONN_CO);
#		endif

#	endif

			/* progress_ind */

#	if CC_PAR_PROGRESS_IND_IE == ON
		cc_read_progress_ind_from_ns (NS_CONN_CO);
#	endif

#	if CC_PAR_SIGNAL_IE == ON
		cc_read_signal_from_ns (NS_CONN_CO);
#	endif

		/* Send ACU_CONN_CO/CC_HOOK_OFF_CO */

	cc_snd_conn_co_and_set_active ();
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_cc_hook_off_rq

Description     process CC_HOOK_OFF_RQ message.

Usage           cc_process_cc_hook_off_rq ();

*--------------------------------------------------------------------------*/

#if CC_INTERFACE == ON

void cc_process_cc_hook_off_rq ()
{

#	if CC_UUI == ON

		uchar FAR *p_cc_data = p_data_cc;		/* data pointer in CC primitive */

			/* Get UUI */

		if ((Uui_used == ON) && (Cc_call_uui_rq == ON)) {
			p_cc_uui = (char FAR *)Cc_hook_off_rq_a_uui;
		}

#	endif

		/* Send NS_CONN_RS and set state */

	cc_snd_ns_conn_rs_and_set_state ();
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_snd_acu_progress_in

Description     builds and sends an ACU_PROGRESS_IN message to the user.

Usage           cc_snd_acu_progress_in (event_code);
					uchar event_code: event code
						- ACUEV_DIAL_TONE:    indicates that the B-channel
							  is available.
						- ACUEV_INTERWORKING: interworking indication
							  (indicates receipt of NS_PROGRESS_IN)

Return value    none

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_snd_acu_progress_in (event_code)
	uchar event_code;
{
	uchar FAR *p_data;

	Acu_alloc_data (Acu_progress_in_size +
					cc_display_total_size +
					cc_i_ext_lgth);

	Acu_progress_in_event = event_code;

	cc_write_call_chan_list_to_acu ((struct chani_list FAR *)&Acu_progress_in_data_chani_nb);

	Acu_progress_in_cause					= cc_cause;

	cc_store_progress_ind (&Acu_progress_in_ progress_ind);

#	if CC_PAR_SIGNAL_IE == ON
		Acu_progress_in_signal_val			= cc_signal_val;
#	endif

	cc_store_display (Acu_progress_in_a_display_list, Acu_progress_in_a_display);

#	if ACU_PAR_EXTENDED_PRIM == ON
		cc_store_ext_data_in_acu_prim (p_data, Acu_progress_in_a_end_strings);
#	endif

	cc_snd_to_user (ACU_PROGRESS_IN);

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_snd_acu_digit_co

Description     build and send ACU_DIGIT_CO.

Usage           cc_snd_acu_digit_co ();

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_snd_acu_digit_co ()
{
	uchar FAR *p_data;

		/* the 'display' IE has already been read in cc_rcv() */

	Acu_alloc_data (Acu_digit_co_size +
					cc_display_total_size);

	cc_store_display (Acu_digit_co_a_display_list, Acu_digit_co_a_display);

	cc_snd_to_user (ACU_DIGIT_CO);

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_snd_ns_call_proc_alert_conn

Description     build and send NS_CALL_PROC_RQ, NS_ALERT_RQ and NS_CONN_RS
				if required by configuration.

Usage           uchar cc_snd_ns_call_proc_alert_conn ();

Return value	STOP if nothing to be done after
				(i.e. NS_CONN_RS has been sent),
				or CONTINUE otherwise.

*--------------------------------------------------------------------------*/

uchar cc_snd_ns_call_proc_alert_conn ()
{

		/*
			Automatic sending of NS_CALL_PROC_RQ ?
			(by configuration or forced by the protocol)
		*/

	if ((Cc_na_in_calls_behaviour & CC_SEND_CALL_PROC_RQ)

#		if EQUIPMENT == NT2
			|| ((Cc_na_function == FG_NT_TE) &&
				(Force_ns_call_proc_rq_in_nt == ON))
#		endif

		) {
		cc_snd_to_ns (NS_CALL_PROC_RQ);
		cc_store_chan_id = OFF;
	}

		/* Automatic sending of NS_ALERT_RQ ? */

	if (((Cc_na_in_calls_behaviour & CC_DATA_ALERT_RQ)  &&
		 (Cc_call_service_class != CC_SRV_CLASS_VOICE))
	  ||
		((Cc_na_in_calls_behaviour & CC_VOICE_ALERT_RQ) &&
		 (Cc_call_service_class == CC_SRV_CLASS_VOICE))
		) {

		cc_snd_to_ns (NS_ALERT_RQ);
		cc_store_chan_id = OFF;
	}

		/* Automatic sending of NS_CONN_RS ? */

	if (((Cc_na_in_calls_behaviour & CC_DATA_CONN_RS)  &&
		 (Cc_call_service_class != CC_SRV_CLASS_VOICE))
	  ||
		((Cc_na_in_calls_behaviour & CC_VOICE_CONN_RS) &&
		 (Cc_call_service_class == CC_SRV_CLASS_VOICE))
		) {

			/* Send NS_CONN_RS and set state */

		cc_snd_ns_conn_rs_and_set_state ();
		return (STOP);
	}

	return (CONTINUE);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_snd_ns_conn_rs_and_set_state

Description     build and send NS_CONN_RS and change state.

Usage           cc_snd_ns_conn_rs_and_set_state ();

*--------------------------------------------------------------------------*/

void cc_snd_ns_conn_rs_and_set_state ()
{

#	if EQUIPMENT == NT2

			/*
				NT side :
				Send back ACU_CONN_CO to user because NS does not
				send back NS_CONN_CO on incoming calls after having
				sent Connect message to the TE (because
				Connect_Ack is optional in TE side).
			*/

		if (Cc_na_function == FG_NT_TE) {
			cc_snd_conn_co_and_set_active ();
			return;
		}

#	endif

		/* Send NS_CONN_RS */

	cc_snd_to_ns (NS_CONN_RS);

		/* Set HOOKED_OFF state (wait for NS_CONN_CO) */

	Cc_set_state (STATE_HOOKED_OFF);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_snd_conn_co_and_set_active

Description     build and send ACU_CONN_CO or CC_HOOK_OFF_CO and
				set ACTIVE state.

Usage           cc_snd_conn_co_and_set_active ();

*--------------------------------------------------------------------------*/

void cc_snd_conn_co_and_set_active ()
{
#	if ACU_INTERFACE == ON
		uchar			FAR	*p_data;		/* data pointer in ACU primitive */
#	endif

#	if CC_INTERFACE == ON
		uchar			FAR *p_cc_data;		/* data pointer in CC primitive */
#	endif

		/* Switch and Init the assigned B channel if necessary */

	if (Cc_profile_switch_rq_enable == ON) {
		cc_b_switch    (Cc_call_b_chan_id, Cc_call_b_chan_mode, B_AUDIO_TONE_NIL);
	}

	if (Cc_profile_init_rq_enable == ON) {
		cc_b_init_stop (MPH_B_INIT_RQ);
	}

		/* Send ACU_CONN_CO/CC_HOOK_OFF_CO to user */

	switch (cc_current_sapi_user) {

#	  if CC_INTERFACE == ON

		case CC_SAPI :
			Cc_alloc_data (Cc_hook_off_co_size);
			Cc_hook_off_co_b_chan_id = Cc_call_b_chan_id;

#			if CC_UUI == ON
				Strcpy_far ((char FAR *)Cc_hook_off_co_a_uui, p_cc_uui, CC_MX_SZ_UUI+1);
#			endif

			cc_snd_to_user (CC_HOOK_OFF_CO);
			break;
#	  endif

#	  if ACU_INTERFACE == ON

		case ACU_SAPI :
			Acu_alloc_data (Acu_conn_co_size +
							cc_redir_nb_size +
							cc_uui_size +
							cc_facility_size +
							cc_display_total_size +
							cc_i_ext_lgth);

			Acu_conn_co_service			= Cc_profile_id;
			cc_write_call_chan_list_to_acu ((struct chani_list FAR *)&Acu_conn_co_data_chani_nb);

#			if CC_PAR_CHARGING_INFO == ON
				Acu_conn_co_charging_type	= cc_charging_type;
				Acu_conn_co_charging_period	= cc_charging_period;
				Acu_conn_co_charging_multi	= cc_charging_multi;
				Acu_conn_co_charging		= cc_charging;
#			else
				Acu_conn_co_charging_type	= ACU_BYTE_VAL_NIL;
#			endif

				/*------------------------------*/
				/* Store REDIRECTED NUMBER info */
				/*------------------------------*/

#			if CC_PAR_REDIR_NB == ON
				cc_store_redir_nb_in_acu_prim ((struct acu_redir_nb FAR *)&(Acu_conn_co_ redir_nb), Acu_conn_co_a_redir_nb);
#			endif

#			if CC_UUI == ON

				Acu_conn_co_uui_size			= cc_uui_size;

				if (cc_uui_size != 0) {
					Strcpy_far (Acu_conn_co_a_uui, p_cc_uui, ACU_MX_SZ_UUI+1);
				}

#			endif

#			if CC_PAR_DATE_TIME == ON
				Memcpy_far ((char FAR *)Acu_conn_co_a_date_time,
							(char FAR *)&cc_date_time,
							sizeof (cc_date_time));
#			else
				Acu_conn_co_date_available = OFF;
#			endif

#			if CC_SUPP_SERVICES == ON

				if (Sup_services_used == ON) {
					Acu_conn_co_facility_size = cc_facility_size;

					if (cc_facility_size != 0) {
						Memcpy_far (Acu_conn_co_a_facility, p_cc_facility, cc_facility_size);
					}
				}

#			endif

#			if CC_PAR_SIGNAL_IE == ON
				Acu_conn_co_signal_val	= cc_signal_val;
#			endif

			cc_store_display (Acu_conn_co_a_display_list, Acu_conn_co_a_display);

#			if ACU_PAR_EXTENDED_PRIM == ON
				cc_store_ext_data_in_acu_prim (p_data, Acu_conn_co_a_end_strings);
#			endif

			cc_snd_to_user (ACU_CONN_CO);

#			if EQUIPMENT == NT2

				if (Cc_na_function == FG_NT_TE) {

						/*
							Send back NS_CONN_RS for
							Acknowledgement.
						*/

#					if CC_UUI == ON
						p_cc_uui = P_NIL;
#					endif

					cc_snd_to_ns (NS_CONN_RS);

				}

#			endif

			break;

#	  endif
	}

		/* Set ACTIVE state */

	Cc_set_state (STATE_ACTIVE);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_switch_outgoing_call_b_channel

Description		switch the B channel allocated the an outgoing call
				if available, and warn the user.

Usage           cc_switch_outgoing_call_b_channel ();

*--------------------------------------------------------------------------*/

void cc_switch_outgoing_call_b_channel ()
{
#if CC_INTERFACE == ON
	uchar FAR *p_cc_data;
#endif

	if (Cc_call_b_chan_id != NO_CHAN) {

			/* Connect the assigned B channel. */

		if (Cc_profile_switch_rq_enable == ON) {
			cc_b_switch (Cc_call_b_chan_id, Cc_call_b_chan_mode, B_AUDIO_TONE_NIL);
		}

		switch (cc_current_sapi_user) {

#		if CC_INTERFACE == ON

			case CC_SAPI :
				Cc_alloc_data (Cc_assign_channel_in_size);
				Cc_assign_channel_in_b_chan_id = Cc_call_b_chan_id;
				cc_snd_to_user (CC_ASSIGN_CHANNEL_IN);
				break;

#		endif

#		if ACU_INTERFACE == ON

			case ACU_SAPI :

					/* Send CED and wait for CNG */

				cc_snd_ced ();
				break;

#		endif

		}

	}

}

/*EOF*/
