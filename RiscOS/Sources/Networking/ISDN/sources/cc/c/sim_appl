
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - sim_appl.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *        build_sdu_appli_to_cc - implements the building of an application
 *								  message sent to Call Control.
 *
 *		  pr_cc_code - implements the printing of the CC RQ/RS primitive
 *        			   code.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Call Control (CC) Entity                         |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "cc.h"
#include "services.h"
#include "cc_int.h"
#include "acu_int.h"

#if C_COMPILER == TC
#	pragma  hdrstop
#endif

#if SIMULATION == ON
#	include "simul.h"
#	include "conf_cc.h"
#	include <string.h>

/*-------------------------------------------------------------------------*/

extern uint cc_sim_flag;		/* CC: simulation flag (bit-field) */

#define CC_SIM_FLAG_DISPLAY		1		/* bit 1: generate Display IE in ACU primitives */
#define CC_SIM_FLAG_FAC_IE		2		/* bit 2: generate Facility IE in ACU primitives */

/*-------------------------------------------------------------------------*/

	/* local simulation variables and prototypes */

uint	g_na_nb;
uint	g_call_nb;
uchar	g_user_entity[2]= {' '};
uchar	g_user_sapi  [2]= {' '};
uchar	g_in_calls_behaviour[2]= {' '};
uint	g_nb_digits_to_route;
uchar	g_cc_sapi[2]	= {' '};
uchar	g_service_id [2]= {' '};
uchar	g_cc_profile_config_sent = OFF;

uchar	g_called_nb	 [80];
uchar	g_calling_nb [80];

uchar	g_syn_asyn[2];
uint	g_user_rate;
uint	g_stop_bit;
uint	g_data_bit;
uchar	g_parity[2];

uint	g_chan_id;
char	g_chan_excl;

ushort	g_cc_display_total_size;

uint	g_call_appear;
uint	g_button;

uchar	g_uui[2]		= {' '};
#define	g_uui_recognition	g_uui

uchar	g_provide_chan_id[2] = {'N'};

uint	g_facility_code;
uchar	g_facility_action[2] = {' '};

uchar	g_set_mode_action[2] = {' '};
uchar	g_set_mode_code[2]   = {' '};

#if _CC_SPID_INFO == ON

	uint	g_endpoint_action;
	uint	g_usid;
	uint	g_tid;
	uint	g_interpreter;
#endif

extern uchar	g_acu_conn_in_service;

/*---------------*/

#	if NEW_FCT_STYLE == ON
		ushort	build_cc_dial_rq			(uchar FAR *p_data);
		ushort	build_cc_hook_off_rq		(uchar FAR *p_data);
		ushort	build_cc_hook_on_rq			(uchar FAR *p_data);
		ushort	build_cc_hook_on_rs			(uchar FAR *p_data);
		ushort	build_acu_conn_rq			(uchar FAR *p_data);
		ushort	build_acu_conn_rs			(uchar FAR *p_data);
		ushort	build_acu_clear_rq			(uchar FAR *p_data);
		ushort	build_acu_clear_rs			(uchar FAR *p_data);
		ushort	build_acu_digit_rq			(uchar FAR *p_data);
		ushort	build_acu_call_proc_rq		(uchar FAR *p_data);
		ushort	build_acu_alert_rq			(uchar FAR *p_data);
		ushort	build_acu_user_info_rq		(uchar FAR *p_data);
		ushort	build_acu_facility_rq		(uchar FAR *p_data);
		ushort	build_acu_suspend_rq		(uchar FAR *p_data);
		ushort	build_acu_resume_rq			(uchar FAR *p_data);
		ushort	build_acu_test_rq			(uchar FAR *p_data);
		ushort	build_acu_set_mode_rq		(uchar FAR *p_data);
		ushort	build_acu_information_rq 	(uchar FAR *p_data);
		void	build_sm_set_config_rq_to_cc(void);
		void	build_sm_reset_config_rq	(void);
		void	build_sm_stop_rq			(void);
		void	cc_sim_acu_store_asn1_fac	(uchar FAR *p_data);
		void	get_simul_net_op 			(uchar nai, ushort FAR *na_country, uchar FAR *na_op);
		void	mg_na_nb					(void);
		void	mg_user_entity				(void);
		void	mg_user_sapi				(void);
		void	mg_call_nb					(void);
		void	mg_in_calls_behaviour		(void);
		char	mg_data_conn_rs_behaviour	(void);
		char	mg_voice_conn_rs_behaviour	(void);
		char	mg_data_alert_rq_behaviour	(void);
		char	mg_voice_alert_rq_behaviour (void);
		char	mg_send_alert_in_behaviour	(void);
		char	mg_send_call_proc_rq_behaviour (void);
		char	mg_transp_overlap_rcv_behaviour(void);
		char	mg_nb_digits_to_route		(void);
		void	mg_cc_sapi					(void);
		void	mg_service_id				(void);
		void	mg_layer_1_info				(void);
		void	mg_syn_asyn 				(void);
		void	mg_user_rate				(void);
		void	mg_stop_bit					(void);
		void	mg_data_bit					(void);
		void	mg_parity   				(void);
		void	mg_called_nb_sub_add		(void);
		void	mg_calling_nb_sub_add		(void);
		void	mg_uui_recognition			(void);
		void	mg_uui						(void);
		void	mg_chan_id					(void);
		void	mg_provide_chan_id			(void);
		void	mg_facility_code			(void);
		void	mg_facility_action			(void);
		void	mg_set_mode_code			(void);
		void	mg_set_mode_action			(void);
		void	mg_call_appear 				(void);
		void	mg_button	 				(void);
		void	pr_cc_sapi					(void);
		void	pr_cc_code					(void);
		void	pr_cc_services_list			(void);
		void	pr_acu_service_id			(void);
		void	pr_acu_facility_code		(void);
		void	pr_sm_code					(void);
		void	extract_nb_sub_add			(uchar FAR *p_from, uchar FAR *p_to_nb, uchar FAR *p_to_sub_add);
		void	extract_calling_nb_info		(char FAR * FAR *a_p_digits, uchar FAR *a_pres, uchar FAR *a_type, uchar FAR *a_screen, uchar FAR *a_ident_denied);
		uchar	sm_init_send				(uchar to, uchar FAR *p_config, ushort size, struct cfg_update FAR *p_cfg_update);
		void	cc_sim_acu_store_display	(struct acu_display_list FAR *p_display, uchar FAR *p_data);
		uchar FAR *cc_sim_acu_add_display	(struct acu_display_list FAR *p_display, uchar FAR *p_data, char FAR *p_string);

#		if _CC_SPID_INFO == ON
			void 	mg_endpoint_action		(void);
			void 	mg_usid 				(void);
			void 	mg_tid 					(void);
			void 	mg_interpreter 			(void);
#		endif

#	else
		ushort	build_cc_dial_rq			();
		ushort	build_cc_hook_off_rq		();
		ushort	build_cc_hook_on_rq			();
		ushort	build_cc_hook_on_rs			();
		ushort	build_acu_conn_rq			();
		ushort	build_acu_conn_rs			();
		ushort	build_acu_clear_rq			();
		ushort	build_acu_clear_rs			();
		ushort	build_acu_digit_rq			();
		ushort	build_acu_call_proc_rq		();
		ushort	build_acu_alert_rq			();
		ushort	build_acu_user_info_rq		();
		ushort	build_acu_facility_rq		();
		ushort	build_acu_suspend_rq		();
		ushort	build_acu_resume_rq			();
		ushort	build_acu_test_rq			();
		ushort	build_acu_set_mode_rq		();
		ushort	build_acu_information_rq 	();
		void	build_sm_set_config_rq_to_cc();
		void	build_sm_reset_config_rq	();
		void	build_sm_stop_rq			();
		void	cc_sim_acu_store_asn1_fac	();
		void	get_simul_net_op 			();
		void	mg_na_nb					();
		void	mg_user_entity				();
		void	mg_user_sapi				();
		void	mg_call_nb					();
		void	mg_in_calls_behaviour		();
		char	mg_data_conn_rs_behaviour	();
		char	mg_voice_conn_rs_behaviour	();
		char	mg_data_alert_rq_behaviour	();
		char	mg_voice_alert_rq_behaviour ();
		char	mg_send_alert_in_behaviour	();
		char	mg_send_call_proc_rq_behaviour ();
		char	mg_transp_overlap_rcv_behaviour();
		char	mg_nb_digits_to_route		();
		void	mg_cc_sapi					();
		void	mg_service_id				();
		void	mg_layer_1_info				();
		void	mg_syn_asyn 				();
		void	mg_user_rate				();
		void	mg_stop_bit					();
		void	mg_data_bit					();
		void	mg_parity   				();
		void	mg_called_nb_sub_add		();
		void	mg_calling_nb_sub_add		();
		void	mg_uui_recognition			();
		void	mg_uui						();
		void	mg_chan_id					();
		void	mg_provide_chan_id			();
		void	mg_facility_code			();
		void	mg_facility_action			();
		void	mg_set_mode_code			();
		void	mg_set_mode_action			();
		void	mg_call_appear 				();
		void	mg_button	 				();
		void	pr_cc_sapi					();
		void	pr_cc_code					();
		void	pr_cc_services_list			();
		void	pr_acu_service_id			();
		void	pr_acu_facility_code		();
		void	pr_sm_code					();
		void	extract_nb_sub_add			();
		void	extract_calling_nb_info		();
		uchar	sm_init_send				();
		void	cc_sim_acu_store_display	();
		uchar FAR *cc_sim_acu_add_display	();

#		if _CC_SPID_INFO == ON
			void 	mg_endpoint_action		();
			void 	mg_usid 				();
			void 	mg_tid 					();
			void 	mg_interpreter 			();
#		endif

#	endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             build_sdu_xxx_to_yyy - implements the building of an
				 Application service message for the Call Control entity.

Usage            uchar build_sdu_xxx_to_yyy ();

Common constants and declarations : cc.h

Common objects   : message current context.

*-------------------------------------------------------------------------*/

uchar build_sdu_dte_to_acu ()
{
	return (build_sdu_appli_to_cc ());
}

/*---------------*/

uchar build_sdu_appli_to_cc ()
{
	uchar FAR *	p_data;
	ushort		data_size = 0;

		/* Get message header parameters */

	mg_nai		();

	mg_cc_sapi	();
	while (g_cc_sapi[0] == '?') {
		pr_cc_sapi ();
		mg_cc_sapi();
	}

	mg_conn_id	();
	mg_code		();

	while (g_code[0] == '?') {
		pr_cc_code ();
		mg_code ();
	}

		/* Allocate a message and a buffer */

	S_msg_alloc;
	Buffer_alloc;

	S_msg_from		= g_from[0];
	S_msg_to		= g_to[0];
	S_msg_code 		= g_code[0];
	S_msg_nai 		= g_nai;
	S_msg_sapi 		= g_cc_sapi[0];
	S_msg_conn_id 	= g_conn_id;
	S_msg_init_link_buffer;

	p_data = Buffer_a_first_data;

	if (g_cc_sapi[0] == CC_SAPI) {

		switch (g_code[0]) {

			case CC_DIAL_RQ :
				data_size = build_cc_dial_rq (p_data);
				break;

			case CC_HOOK_OFF_RQ :
				data_size = build_cc_hook_off_rq (p_data);
				break;

			case CC_HOOK_ON_RQ :
				data_size = build_cc_hook_on_rq (p_data);
				break;

			case CC_HOOK_ON_RS :
				data_size = build_cc_hook_on_rs (p_data);
				break;

			case CC_INIT_RQ :
				break;

		}

	} else {

		switch (g_code[0]) {

			case ACU_CONN_RQ :
				data_size = build_acu_conn_rq (p_data);
				break;

			case ACU_CONN_RS :
				data_size = build_acu_conn_rs (p_data);
				break;

			case ACU_CLEAR_RQ :
				data_size = build_acu_clear_rq (p_data);
				break;

			case ACU_CLEAR_RS :
				data_size = build_acu_clear_rs (p_data);
				break;

			case ACU_DIGIT_RQ :
				data_size = build_acu_digit_rq (p_data);
				break;

			case ACU_CALL_PROC_RQ :
				data_size = build_acu_call_proc_rq (p_data);
				break;

			case ACU_ALERT_RQ :
				data_size = build_acu_alert_rq (p_data);
				break;

			case ACU_USER_INFO_RQ :
				data_size = build_acu_user_info_rq (p_data);
				break;

			case ACU_FACILITY_RQ :
				data_size = build_acu_facility_rq (p_data);
				break;

			case ACU_SUSPEND_RQ :
				data_size = build_acu_suspend_rq (p_data);
				break;

			case ACU_RESUME_RQ :
				data_size = build_acu_resume_rq (p_data);
				break;

			case ACU_TEST_RQ :
				data_size = build_acu_test_rq (p_data);
				break;

			case ACU_SET_MODE_RQ :
				data_size = build_acu_set_mode_rq (p_data);
				break;

			case ACU_SETPARM_RQ :
				break;

			case ACU_INFORMATION_RQ :
				data_size = build_acu_information_rq (p_data);
				break;
		}

	}

	Buffer_data_size = data_size;

	return (OK);
}

/*---------------*/

uchar build_sdu_sm_to_cc ()
{
	S_msg_alloc;

	S_msg_from		= g_from[0];
	S_msg_to		= g_to[0];

	mg_code		();

	while (g_code[0] == '?') {
		pr_sm_code ();
		mg_code ();
	}

	S_msg_code 		= g_code[0];

	switch (g_code[0]) {

		case SM_SET_CONFIG_RQ:
			build_sm_set_config_rq_to_cc ();
			break;

		case SM_RESET_CONFIG_RQ:
			build_sm_reset_config_rq ();
			break;

		case SM_STOP_RQ:
			build_sm_stop_rq ();
			break;

		default :
			mg_to ();
			S_msg_to  = g_to[0];
			build_sdu_std ();

	}

	return (OK);
}

/*---------------*/

struct cc_config cc_config_tmp;	/* temporary CC configuration structure */

void build_sm_set_config_rq_to_cc ()
{
	ushort					i,j;
	struct cc_config 	FAR *p_cc_config;
	struct cc_config_na	FAR *p_cc_config_na;

#	if CC_PROFILE_CONFIG == ON

		if (g_cc_profile_config_sent != ON) {

			g_cc_profile_config_sent = ON;

				/* First, send the additional profiles configuration */

			Buffer_alloc;
			S_msg_init_link_buffer;

			Memcpy_far ((char FAR *)Buffer_a_start_data, (char FAR *)&cc_profile_config_data, sizeof (struct cc_profile_config));
			Buffer_data_size = sizeof (struct cc_profile_config);

			Send_message (p_snd_msg);

				/* And re-allocate the message for the main CC configuration */

			p_snd_msg = Alloc_msg ();

			S_msg_from		= g_from[0];
			S_msg_to		= g_to[0];

			S_msg_code 		= g_code[0];
		}

#	endif

	Memcpy_far ((char FAR *)&cc_config_tmp, (char FAR *)&cc_config_data, sizeof (struct cc_config));
	p_cc_config	   = (struct cc_config *)&cc_config_tmp;

	mg_na_nb ();	/* '0' means default configuration */

	if (g_na_nb != 0) {

		Cc_config_na_nb = g_na_nb;

		for (i = 0, j = g_na_nb; j > 0; i++, j--) {

			p_cc_config_na = Cc_config_na_a (i);

			mg_nai ();
			Cc_config_nai = g_nai;

			mg_user_entity ();
			Cc_config_ent_user = g_user_entity[0];

			mg_user_sapi ();
			Cc_config_sapi_user = g_user_sapi[0];

			mg_call_nb ();
			Cc_config_call_nb = g_call_nb;

			mg_in_calls_behaviour ();

			switch (Toupper (g_in_calls_behaviour[0])) {

				case 'Y' :
					Cc_config_in_calls_behaviour = 1;
					break;

				case 'N' :
					Cc_config_in_calls_behaviour = 0;
					break;

				case '*' :	/* select each bit */
					Cc_config_in_calls_behaviour =
						  (mg_send_alert_in_behaviour     () == 'Y' ? CC_SEND_ALERT_IN    : 0)
						| (mg_send_call_proc_rq_behaviour () == 'Y' ? CC_SEND_CALL_PROC_RQ: 0)
						| (mg_data_alert_rq_behaviour     () == 'Y' ? CC_DATA_ALERT_RQ    : 0)
						| (mg_voice_alert_rq_behaviour    () == 'Y' ? CC_VOICE_ALERT_RQ   : 0)
						| (mg_data_conn_rs_behaviour      () == 'Y' ? CC_DATA_CONN_RS     : 0)
						| (mg_voice_conn_rs_behaviour     () == 'Y' ? CC_VOICE_CONN_RS    : 0)
						| (mg_transp_overlap_rcv_behaviour() == 'Y' ? CC_TRANSPARENT_OVERLAP_RCV: 0);

					if (!(Cc_config_in_calls_behaviour & CC_TRANSPARENT_OVERLAP_RCV)) {
						Cc_config_nb_digits_to_route = mg_nb_digits_to_route ();
					}

					if (Cc_config_in_calls_behaviour == 0) {
						Cc_config_in_calls_behaviour = CC_BEHAVIOUR_NIL;
					}

					break;

			}

			mg_called_nb_sub_add ();
			extract_nb_sub_add (g_called_nb, Cc_config_a_local_nb, Cc_config_a_local_sub_add);

			mg_calling_nb_sub_add ();
			extract_nb_sub_add (g_calling_nb, Cc_config_a_calling_nb, Cc_config_a_calling_sub_add);

			mg_uui_recognition ();
			Cc_config_uui_recognition = (Toupper(g_uui_recognition[0]) == 'Y') ? ON : OFF;

			get_simul_net_op (g_nai, &Cc_config_na_country, &Cc_config_na_operator);

		}

	} else {

			/*
				Update network and operator fields in the NA sub structures
				if forced by command line
			*/

		for (i = 0; i < Cc_config_na_nb; i++) {

			p_cc_config_na = Cc_config_na_a (i);

			get_simul_net_op (Cc_config_nai, &Cc_config_na_country, &Cc_config_na_operator);
		}

	}

	get_simul_net_op (g_nai, &Cc_config_country, &Cc_config_operator);

	mg_provide_chan_id ();

	sm_init_send (g_to[0], (uchar FAR *)&cc_config_tmp, sizeof (struct cc_config), P_NIL);
}

/*---------------*/

void build_sm_reset_config_rq ()
{
	mg_nai ();
	S_msg_nai = g_nai;
}

/*---------------*/

void build_sm_stop_rq ()
{
	mg_nai ();
	S_msg_nai = g_nai;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			build_xxx_rq/rs - get all the parameters needed for the
									  building of a CC_???_RQ/RS or a
									  ACU_???_RQ/RS primitive.

Usage           void build_xxx_rq/rs (p_data)
					- uchar FAR *p_data: address of the current position
					  within the data area of the CC_???_RQ/RS or
					  ACU_???_RQ/RS primitive.
Related
functions usage void mg_zzz();

Common constants and declarations : services.h and simul.h

*--------------------------------------------------------------------------*/

ushort build_cc_dial_rq (p_cc_data)
	uchar FAR *p_cc_data;
{
	mg_service_id    ();

	while (g_service_id[0] == '?') {
		pr_cc_services_list ();
		mg_service_id ();
	}

	Cc_dial_rq_service_id = g_service_id[0];

	mg_called_nb_sub_add   ();
	extract_nb_sub_add (g_called_nb, Cc_dial_rq_a_called_nb, Cc_dial_rq_a_called_sub_add);

	mg_calling_nb_sub_add   ();
	extract_nb_sub_add (g_calling_nb, Cc_dial_rq_a_calling_nb, Cc_dial_rq_a_calling_sub_add);

	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Strcpy_far ((char FAR *)Cc_dial_rq_a_uui, "UUI dial_rq", 30);

	} else {

		Cc_dial_rq_a_uui[0] = 0;
	}

	return (Cc_dial_rq_size);
}

/*---------------*/

ushort build_cc_hook_off_rq (p_cc_data)
	uchar FAR *p_cc_data;
{
	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Strcpy_far ((char FAR *)Cc_hook_off_rq_a_uui, "UUI hook_off_rq", 30);

	} else {

		Cc_hook_off_rq_a_uui[0] = 0;
	}

	return (Cc_hook_off_rq_size);
}

/*---------------*/

ushort build_cc_hook_on_rq (p_cc_data)
	uchar FAR *p_cc_data;
{
	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Strcpy_far ((char FAR *)Cc_hook_on_rq_a_uui, "UUI hook_on_rq", 30);

	} else {

		Cc_hook_on_rq_a_uui[0] = 0;
	}

	return (Cc_hook_on_rq_size);
}

/*---------------*/

ushort build_cc_hook_on_rs (p_cc_data)
	uchar FAR *p_cc_data;
{
	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Strcpy_far ((char FAR *)Cc_hook_on_rs_a_uui, "UUI hook_on_rs", 30);

	} else {

		Cc_hook_on_rs_a_uui[0] = 0;
	}

	return (Cc_hook_on_rs_size);
}

/*==========================================================================*/

	/* Default 56k layer 1 information */

CONST struct layer_1_info sim_cc_default_56k_layer_1_info = {
	ACU_RA_56000,		/* physical rate */
	ACU_RA_56000,		/* user rate */
	ACU_SYN,			/* syn/asyn */
	ACU_BYTE_VAL_NIL,	/* stop bits */
	ACU_BYTE_VAL_NIL,	/* data bits */
	ACU_BYTE_VAL_NIL	/* parity */
};

	/* Default V110 layer 1 information */

CONST struct layer_1_info sim_cc_default_v110_layer_1_info = {
	ACU_RA_19200,		/* physical rate */
	ACU_RA_19200,		/* user rate */
	ACU_ASYN,			/* syn/asyn */
	ACU_STOP_BIT_1,		/* stop bits */
	ACU_DATA_BIT_8,		/* data bits */
	ACU_NO_PARITY		/* parity */
};

	/* Default V120 layer 1 information */

CONST struct layer_1_info sim_cc_default_v120_layer_1_info = {
	ACU_RA_19200,		/* physical rate */
	ACU_RA_19200,		/* user rate */
	ACU_ASYN,			/* syn/asyn */
	ACU_BYTE_VAL_NIL,	/* stop bits */
	ACU_BYTE_VAL_NIL,	/* data bits */
	ACU_BYTE_VAL_NIL	/* parity */
};

	/* Default layer 1 information */

CONST struct layer_1_info sim_cc_default_layer_1_info = {
	ACU_BYTE_VAL_NIL,	/* physical rate */
	ACU_BYTE_VAL_NIL,	/* user rate */
	ACU_BYTE_VAL_NIL,	/* syn/asyn */
	ACU_BYTE_VAL_NIL,	/* stop bits */
	ACU_BYTE_VAL_NIL,	/* data bits */
	ACU_BYTE_VAL_NIL	/* parity */
};

struct layer_1_info sim_cc_empty_layer_1_info;

ushort build_acu_conn_rq (p_data)
	uchar FAR *p_data;
{
	struct layer_1_info FAR *p_layer_1_info;
	char i;
	char FAR *p_calling_nb;
	char FAR *p_calling_nb2;

#	if ARINC_NETWORKS == ON
		char p_track[10];
#	endif

		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_conn_rq_size);

	mg_service_id    ();

	while (g_service_id[0] == '?') {
		pr_acu_service_id ();
		mg_service_id ();
	}

	Acu_conn_rq_service = g_service_id[0];

	switch (Acu_conn_rq_service) {

		case ACU_V110_SERVICE :
		case ACU_V120_SERVICE :

			mg_layer_1_info ();

			p_layer_1_info = (struct layer_1_info FAR *)&sim_cc_empty_layer_1_info;

			sim_cc_empty_layer_1_info.ph_rate   =
			sim_cc_empty_layer_1_info.user_rate = g_user_rate;
			sim_cc_empty_layer_1_info.syn_asyn  = g_syn_asyn[0];
			sim_cc_empty_layer_1_info.data_bits = g_data_bit;
			sim_cc_empty_layer_1_info.parity    = g_parity[0];
			sim_cc_empty_layer_1_info.stop_bits = g_stop_bit;
			break;

		case ACU_DATA_56KBS_SERVICE :
			p_layer_1_info = (struct layer_1_info FAR *)&sim_cc_default_56k_layer_1_info;
			break;

		default :
			p_layer_1_info = (struct layer_1_info FAR *)&sim_cc_default_layer_1_info;
			break;

	}

		/* Now copy the layer 1 info into the primitive */

	Memcpy_far ((char FAR *)Acu_conn_rq_a_layer_1_info,
				(char FAR *)p_layer_1_info,
				sizeof (struct layer_1_info));

	p_layer_1_info = Acu_conn_rq_a_layer_1_info;

	mg_called_nb_sub_add   ();

	Acu_conn_rq_sending_complete = OFF;

	switch (g_called_nb[0]) {

		case '-':	/* no called number */
			break;

		case '!':	/* no called number, but with Sending_complete */
			Acu_conn_rq_sending_complete = ON;
			break;

		default:
			Acu_conn_rq_called_nb_size = Strcpy_far ((char FAR *)Acu_conn_rq_a_called_nb, (char FAR *)g_called_nb, ACU_MX_SZ_CALLED_NB) - 1;
			Acu_conn_rq_called_nb_type = ACU_NB_TYPE_UNKNOWN;
			Acu_conn_rq_called_nb_plan = ACU_NB_PLAN_UNKNOWN;

				/* 123*456! means 'with sending complete */

			if (g_called_nb[Acu_conn_rq_called_nb_size-1] == '!') {
				Acu_conn_rq_called_nb_size--;
				Acu_conn_rq_sending_complete = ON;
			}

				/* 123*456at56 means 'at 56kbs' => ph_rate=56kbs */

			if ((g_called_nb[Acu_conn_rq_called_nb_size-4] == 'a') &&
				(g_called_nb[Acu_conn_rq_called_nb_size-3] == 't') &&
				(g_called_nb[Acu_conn_rq_called_nb_size-2] == '5') &&
				(g_called_nb[Acu_conn_rq_called_nb_size-1] == '6')) {
				Acu_conn_rq_called_nb_size -= 4;

				p_layer_1_info -> ph_rate = ACU_RA_56000;
			}

			Acu_conn_rq_a_called_nb[Acu_conn_rq_called_nb_size] = '\0';
			break;
	}

		/* Get aclling number/sub-address */

	mg_calling_nb_sub_add ();

	p_calling_nb = (char FAR *)&g_calling_nb[0];

	Acu_conn_rq_identification_denied_rq = OFF;

	Acu_conn_rq_calling_nb_size      = 0;
	Acu_conn_rq_calling_nb_pres      = ACU_NB_PRES_ALLOWED;
	Acu_conn_rq_calling_nb_type      = ACU_NB_TYPE_INTERNATIONAL;
	Acu_conn_rq_calling_nb_screen    = ACU_NB_SCREEN_USER_PROVIDED;

	Acu_conn_rq_calling_nb2_size     = 0;
	Acu_conn_rq_calling_nb2_pres     = ACU_NB_PRES_ALLOWED;
	Acu_conn_rq_calling_nb2_type     = ACU_NB_TYPE_INTERNATIONAL;
	Acu_conn_rq_calling_nb2_screen   = ACU_NB_SCREEN_USER_PROVIDED;

		/* Is there a calling number string? */

	if (*(char FAR *)g_calling_nb != '-') {

		extract_calling_nb_info (&p_calling_nb,
								 &Acu_conn_rq_calling_nb_pres,
								 &Acu_conn_rq_calling_nb_type,
								 &Acu_conn_rq_calling_nb_screen,
								 &Acu_conn_rq_identification_denied_rq);

		Acu_conn_rq_calling_nb_size = Strcpy_far ((char FAR *)Acu_conn_rq_a_calling_nb, p_calling_nb, ACU_MX_SZ_CALLING_NB) - 1;

			/*
				Is there a second calling number ?
				The two calling_nb info are seperated by a '+' character.
			*/

			/* Look for a '+' in the calling_nb string */

		for (p_calling_nb2 = p_calling_nb;
			 (*p_calling_nb2 != '+') && (*p_calling_nb2 != '\0');
			 p_calling_nb2++);

		if (*p_calling_nb2 == '+') {

				/* Yes! */

				/* First, update the first calling_nb string info */

			Acu_conn_rq_calling_nb_size = (acu_size_t)(long)(p_calling_nb2 - p_calling_nb);
			*(Acu_conn_rq_a_calling_nb + Acu_conn_rq_calling_nb_size) = '\0';

				/* Then, extract the second calling_nb information */

			p_calling_nb2++; /* to skip the '+' */

			extract_calling_nb_info (&p_calling_nb2,
									 &Acu_conn_rq_calling_nb2_pres,
									 &Acu_conn_rq_calling_nb2_type,
									 &Acu_conn_rq_calling_nb2_screen,
									 &Acu_conn_rq_identification_denied_rq);

			Acu_conn_rq_calling_nb2_size = Strcpy_far ((char FAR *)Acu_conn_rq_a_calling_nb2, p_calling_nb2, ACU_MX_SZ_CALLING_NB) - 1;

		}

	}

	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Acu_conn_rq_uui_size = Strcpy_far ((char FAR *)Acu_conn_rq_a_uui, "UUI conn_rq", 30);

	} else {

		Acu_conn_rq_uui_size	= 0;
	}

#	if CC_PAR_PROGRESS_IND_IE == ON
		Acu_conn_rq_progress_description	= ACUPROGRESS_DESCR_IN_BAND_NOW;
		Acu_conn_rq_progress_location		= ACUPROGRESS_LOC_USER;
#	endif

#	if ARINC_NETWORKS == ON

		Acu_conn_rq_notif_descr				= ACUUSER_RESUMED;

#		if (CC_SPF_FAC == ON)
			Acu_conn_rq_spf_fac_id	= ACUSPF_FAC_GES_SPECIAL_SERVICE;
			Acu_conn_rq_spf_fac_val= 0x12;
#		endif

		Acu_conn_rq_departure_year	= 95;
		Acu_conn_rq_departure_month	= 6;
		Acu_conn_rq_departure_day	= 2;
		Acu_conn_rq_service_class_id= 1;

		Acu_conn_rq_nats_route_ind	= ACUNATS_REQUEST_Q_USER;
		Acu_conn_rq_satcom_route_ind= ACUSATCOM_REQUEST_Q_USER;
		Acu_conn_rq_tfts_route_ind	= ACUTFTS_REMOVE_USER;

#	endif

	Acu_conn_rq_data_chani		= 0;
	Acu_conn_rq_data_chani_nai	= 0;
	Acu_conn_rq_data_chani_nb	= 0;
	Acu_conn_rq_data_chani_excl = OFF;

	Acu_conn_rq_facility_size	= 0;

	if (Toupper (g_provide_chan_id[0]) == 'Y') {
		mg_chan_id ();

		if (g_chan_id != 0) {

			if (cc_service_to_class (Acu_conn_rq_service) != CC_SRV_CLASS_MULTI_CHAN) {

					/* 1 B-channel */

				Acu_conn_rq_data_chani      = g_chan_id;
				Acu_conn_rq_data_chani_nai	= g_nai;
				Acu_conn_rq_data_chani_nb	= 1;

			} else {

					/* Multiple B-channels */

				Acu_conn_rq_data_chani_nb	= 6;

					/* Code 6 B-channels, starting at the given one */

				for (i=0; i<6; i++) {
					Acu_conn_rq_data_chani_tab     (i) = g_chan_id + i;
					Acu_conn_rq_data_chani_tab_nai (i) = g_nai;
				}

			}

			Acu_conn_rq_data_chani_excl = g_chan_excl;
		}

		Acu_conn_rq_facility_size = Strcpy_far ((char FAR *)Acu_conn_rq_a_facility, "ACU_CONN_RQ ASN1 FACILITY !", 28);
		*(Acu_conn_rq_a_facility + 28) = 0;
		*(Acu_conn_rq_a_facility + 29) = 0;
		Acu_conn_rq_facility_size += 2;
	}

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_conn_rq_a_display_list,
							 (uchar FAR *)Acu_conn_rq_a_display
							);

#	if EQUIPMENT == NT2

			/* if we are in NT side, then provide Chan-id */

		if (g_chan_id == 0) {

			if (cc_config_data.cc_config_na[g_nai].function == FG_NT_TE) {
				Acu_conn_rq_data_chani      = 2;
		 		Acu_conn_rq_data_chani_nai	= g_nai;
				Acu_conn_rq_data_chani_nb	= 1;
				Acu_conn_rq_data_chani_excl = OFF;
			}
        }

#	endif

#	if ARINC_NETWORKS == ON

		p_track[0] = 0x1;
		p_track[1] = 0x2;
		p_track[2] = 0x3;
		p_track[3] = 0x4;
		p_track[4] = 0x5;

		Memcpy_far ((char FAR *)Acu_conn_rq_a_track_1, p_track, 5);
		Acu_conn_rq_track_1_size = 5;

		p_track[0] = 0x6;
		p_track[1] = 0x7;
		p_track[2] = 0x8;
		p_track[3] = 0x9;
		p_track[4] = 0x0;

		Memcpy_far ((char FAR *)Acu_conn_rq_a_track_2, p_track, 5);
		Acu_conn_rq_track_2_size = 5;

		Acu_conn_rq_flight_op_id_size  = Strcpy_far ((char FAR *)Acu_conn_rq_a_flight_op_id, "ABC", 4);
		Acu_conn_rq_flight_number_size = Strcpy_far ((char FAR *)Acu_conn_rq_a_flight_number, "1234", 5);

		return (Acu_conn_rq_size 				+ Acu_conn_rq_called_nb_size+1 		+
				Acu_conn_rq_calling_nb_size+1	+ Acu_conn_rq_uui_size+1			+
				Acu_conn_rq_facility_size+1 	+ Acu_conn_rq_track_1_size+1		+
				Acu_conn_rq_track_2_size+1		+ Acu_conn_rq_flight_op_id_size+1	+
				Acu_conn_rq_flight_number_size+1);
#	else

		if ((Acu_conn_rq_service == ACU_VOICE_SERVICE) &&
			(cc_config_data.cc_config_na[g_nai].na_operator == AT5)) {
			mg_call_appear ();
			Acu_conn_rq_call_appear = g_call_appear;

		} else {

			Acu_conn_rq_call_appear = 1;
		}

#		if ACU_PAR_EXTENDED_PRIM == ON

		if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			uchar FAR *p_ext_data;	/* pointer used to store the extended parameters */

				/* Store extended parameters */

				/* 0. initialise the extension descriptor */

			Acu_ext_descr_address = (uchar FAR *)Acu_conn_rq_a_end_strings;

				/* 1. Extended LLC */

					/* prepare 'p_ext_data' */

			p_ext_data = Acu_ext_descr_address + Acu_ext_descr_lgth;

					/* update the extension descriptor */

			Acu_ext_descr_nb++;
			Acu_ext_descr_lgth += Acu_ext_llc_size;

					/* write the extended parameter header */

			Acu_ext_id   = ACU_EXT_LLC;
			Acu_ext_lgth = Acu_ext_llc_size;

					/* Write the LLC itself */

					/* (These values are only for test purposes!) */

				/* octet 3 */
			Acu_ext_llc(coding_std)  = 0x00;	/* CCITT */
			Acu_ext_llc(trf_cap)     = 0x08;	/* unrestricted */

				/* octet 3a */
			Acu_ext_llc(out_band_neg)= ACU_BYTE_VAL_NIL;

				/* octet 4 */
			Acu_ext_llc(trf_mode)    = 0x00;	/* circuit */
			Acu_ext_llc(trf_rate)    = 0x10;	/* 64k */

				/* octet 4a */
			Acu_ext_llc(structure)   = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(config)      = ACU_BYTE_VAL_NIL;

				/* octet 4b */
			Acu_ext_llc(establish)   = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(symmetry)    = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(dest_rate)   = ACU_BYTE_VAL_NIL;

				/* octet 5 */
			Acu_ext_llc(l1_protocol) = 0x08;	/* V.120 */

				/* octet 5a */
			Acu_ext_llc(syn_asyn)    = ACU_SYN; /* synchronous */
			Acu_ext_llc(negotiation) = 0x00;	/* In-band negotiation not possible */
			Acu_ext_llc(user_rate)   = 0x0f;	/* 56kbs */

				/* octet 5b for V.110 */
			Acu_ext_llc(inter_rate)  = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(nic_tx)      = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(nic_rx)      = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(fc_tx)       = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(fc_rx)       = ACU_BYTE_VAL_NIL;

				/* octet 5b for V.120 */
			Acu_ext_llc(ra_hdr)      = 0x0;		/* rate adaption header not included */
			Acu_ext_llc(multi_frame) = 0x1;		/* multi-frame establishment supported */
			Acu_ext_llc(op_mode)     = 0x0;		/* bit-transparent mode */
			Acu_ext_llc(lli_negot)   = 0x0;		/* LLI=256 only */
			Acu_ext_llc(assign)      = 0x0;		/* message originator is "default assignee" */
			Acu_ext_llc(band_negot)  = 0x1;		/* negotiation is done in-band using logical link 0 */

				/* octet 5c (V.110 or V.120 only) */
			Acu_ext_llc(stop_bits)   = ACU_STOP_BIT_1; /* 1 stop bit */
			Acu_ext_llc(data_bits)   = ACU_DATA_BIT_8; /* 8 data bits */
			Acu_ext_llc(parity)      = ACU_NO_PARITY;  /* no parity */

				/* octet 5d (V.110 or V.120 only) */
			Acu_ext_llc(duplex)      = 0x01;	/* full duplex */
			Acu_ext_llc(modem)       = 0x0b;	/* V.29 */

				/* octet 6 */
			Acu_ext_llc(l2_protocol) = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(l2_option)   = ACU_BYTE_VAL_NIL;

				/* octet 6a */
			Acu_ext_llc(l3_protocol) = ACU_BYTE_VAL_NIL;
			Acu_ext_llc(l3_option)   = ACU_BYTE_VAL_NIL;


				/* 2. Extended CUG */

					/* prepare 'p_ext_data' */

			p_ext_data = Acu_ext_descr_address + Acu_ext_descr_lgth;

					/* update the extension descriptor */

			Acu_ext_descr_nb++;
			Acu_ext_descr_lgth += Acu_ext_cug_size;

					/* write the extended parameter header */

			Acu_ext_id   = ACU_EXT_CUG;
			Acu_ext_lgth = Acu_ext_cug_size;

					/* Write the CUG itself */

					/* (These values are only for test purposes!) */

			Acu_ext_cug(invoke_id)     = 0x4956;
			Acu_ext_cug(out_access_rq) = FALSE;
			Acu_ext_cug(index)         = 0x0045;


				/* 3. Extended ASN1 facility */

			cc_sim_acu_store_asn1_fac (p_data);
          }

#		endif

#		if _CC_SPID_INFO == ON

			mg_endpoint_action ();
            Acu_conn_rq_endpoint_action = g_endpoint_action;

            if (Acu_conn_rq_endpoint_action != ACU_ACTION_NO_ENDPOINT_ID) {

            	mg_usid ();
                Acu_conn_rq_usid = g_usid;
            	mg_tid ();
                Acu_conn_rq_tid = g_tid;
            	mg_interpreter ();
                Acu_conn_rq_interpreter = g_interpreter;
            }

#		endif

		return (Acu_conn_rq_size +
				Acu_conn_rq_called_nb_size+1 +
				Acu_conn_rq_calling_nb_size+1 +
				Acu_conn_rq_calling_nb2_size+1 +
				Acu_conn_rq_uui_size+1 +
				Acu_conn_rq_facility_size+1 +
				Acu_conn_rq_display_size+1
#				if ACU_PAR_EXTENDED_PRIM == ON
					+ Acu_conn_rq_ext_parms_lgth
#				endif
			   );
#	endif

}

void extract_calling_nb_info (a_p_digits, a_pres, a_type, a_screen, a_ident_denied)
	char FAR * FAR *a_p_digits;
	uchar      FAR *a_pres;
	uchar      FAR *a_type;
	uchar      FAR *a_screen;
	uchar      FAR *a_ident_denied;
{

	while (**a_p_digits != '\0') {

		switch (Toupper (**a_p_digits)) {

				/* "D123456" means 'identification Denied' */

			case 'D':
				*a_ident_denied = ON;
				break;

				/* "R123456" means 'presentation Restricted' */

			case 'R':
				*a_pres = ACU_NB_PRES_RESTRICTED;
				break;

				/* "N123456" means 'Network-provided' */

			case 'N':
				*a_screen = ACU_NB_SCREEN_NETWORK_PROVIDED;
				break;

				/* "I123456" means 'International' */

			case 'I':
				*a_type = ACU_NB_TYPE_INTERNATIONAL;
				break;

				/* "S123456" means 'Subscriber number' */

			case 'S':
				*a_type = ACU_NB_TYPE_LOCAL;
				break;

			default:
				goto done;

		}

		(*a_p_digits)++;

	}

done:

	return;

}

/*---------------*/

ushort build_acu_conn_rs (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_conn_rs_size);

	Acu_conn_rs_service       = ACU_NO_SERVICE;

	if (g_acu_conn_in_service == ACU_X25_PACKET_SERVICE) {
		Acu_conn_rs_data_chani      = 2;
		Acu_conn_rs_data_chani_nai	= g_nai;
		Acu_conn_rs_data_chani_nb	= 1;
		Acu_conn_rs_data_chani_excl = OFF;

	} else {

		mg_chan_id ();
		Acu_conn_rs_data_chani      = g_chan_id;
		Acu_conn_rs_data_chani_nb   = g_chan_id != 0 ? 1 : 0;
		Acu_conn_rs_data_chani_excl = g_chan_excl;
	}

	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Acu_conn_rs_uui_size = Strcpy_far ((char FAR *)Acu_conn_rs_a_uui, "UUI conn_rs", 30);

	} else {

		Acu_conn_rs_uui_size = 0;
	}

	Acu_conn_rs_date_available = ON;
	Acu_conn_rs_year           = 96;    /* 25 Sep 96 */
	Acu_conn_rs_month          = 9;
	Acu_conn_rs_day            = 25;
	Acu_conn_rs_hour           = 12;	/* 12:45:13 */
	Acu_conn_rs_minute         = 45;
	Acu_conn_rs_second         = 13;

	Acu_conn_rs_facility_size  = 0;

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_conn_rs_a_display_list,
							 (uchar FAR *)Acu_conn_rs_a_display
							);

#if CC_PAR_SIGNAL_IE == ON
	Acu_conn_rs_signal_val = ACUDIAL_ON;
#endif

#if ACU_PAR_EXTENDED_PRIM == ON

	if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			/* Store extended parameters */

			/* initialise the extension descriptor */

		Acu_ext_descr_address = (uchar FAR *)Acu_conn_rs_a_end_strings;

			/* Store extended ASN1 facility */

		cc_sim_acu_store_asn1_fac (p_data);
	}

#endif

	return (Acu_conn_rs_size +
			Acu_conn_rs_uui_size+1 +
			Acu_conn_rs_facility_size+1 +
			Acu_conn_rs_display_size+1
#			if ACU_PAR_EXTENDED_PRIM == ON
				+ Acu_ext_descr_lgth
#			endif
		   );
}

/*---------------*/

ushort build_acu_clear_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_clear_rq_size);

	mg_uui ();

	Acu_clear_rq_cause = 0;

	if (Toupper(g_uui[0]) == 'Y') {
		Acu_clear_rq_uui_size = Strcpy_far ((char FAR *)Acu_clear_rq_a_uui, "UUI clear_rq", 30);

	} else {

		Acu_clear_rq_uui_size	= 0;
	}

	Acu_clear_rq_facility_size = 0;

	if (Toupper (g_provide_chan_id[0]) == 'Y') {
		Acu_clear_rq_facility_size = Strcpy_far ((char FAR *)Acu_clear_rq_a_facility, "ASN1 FACILITY !", 16);
	}

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_clear_rq_a_display_list,
							 (uchar FAR *)Acu_clear_rq_a_display
							);

#if CC_PAR_SIGNAL_IE == ON
	Acu_clear_rq_signal_val = ACUDIAL_ON;
#endif

#if ACU_PAR_EXTENDED_PRIM == ON

	if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			/* Store extended parameters */

			/* initialise the extension descriptor */

		Acu_ext_descr_address = (uchar FAR *)Round((ulong)Acu_clear_rq_a_end_strings);

			/* Store extended ASN1 facility */

		cc_sim_acu_store_asn1_fac (p_data);
	}

#endif

	return (Acu_clear_rq_size +
			Acu_clear_rq_uui_size+1 +
			Acu_clear_rq_facility_size+1 +
			Acu_clear_rq_display_size+1
#			if ACU_PAR_EXTENDED_PRIM == ON
				+ Acu_ext_descr_lgth
#			endif
		   );
}

/*---------------*/

ushort build_acu_clear_rs (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_clear_rs_size);

	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Acu_clear_rs_uui_size = Strcpy_far ((char FAR *)Acu_clear_rs_a_uui, "UUI clear_rs", 30);

	} else {

		Acu_clear_rs_uui_size	= 0;
	}

	Acu_clear_rs_facility_size = 0;

	if (Toupper (g_provide_chan_id[0]) == 'Y') {
		Acu_clear_rs_facility_size = Strcpy_far ((char FAR *)Acu_clear_rs_a_facility, "ASN1 FACILITY !", 16);
	}

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_clear_rs_a_display_list,
							 (uchar FAR *)Acu_clear_rs_a_display
							);

#if ACU_PAR_EXTENDED_PRIM == ON

	if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			/* Store extended parameters */

			/* initialise the extension descriptor */

		Acu_ext_descr_address = (uchar FAR *)Acu_clear_rs_a_end_strings;

			/* Store extended ASN1 facility */

		cc_sim_acu_store_asn1_fac (p_data);

	}

#endif

	return (Acu_clear_rs_size +
			Acu_clear_rs_uui_size+1 +
			Acu_clear_rs_facility_size+1 +
			Acu_clear_rs_display_size+1
#			if ACU_PAR_EXTENDED_PRIM == ON
				+ Acu_ext_descr_lgth
#			endif
		   );
}

/*---------------*/

ushort build_acu_digit_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_digit_rq_size);

#	if ARINC_NETWORKS == ON

		Acu_digit_rq_digit_size		= 0;
		Acu_digit_rq_dtmf_digit		= '1';		/* digit 1 */
		Acu_digit_rq_up_down		= ACUKEY_UP;/* key up */
		Acu_digit_rq_dtmf_duration	= 0x08;		/* 8 * 40ms */

#	else

		mg_called_nb_sub_add   ();
		Acu_digit_rq_digit_size = Strcpy_far ((char FAR *)Acu_digit_rq_a_digit, (char FAR *)g_called_nb, ACU_MX_SZ_CALLED_NB) - 1;

#	endif

	Acu_digit_rq_sending_complete = OFF;

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_digit_rq_a_display_list,
							 (uchar FAR *)Acu_digit_rq_a_display
							);

	return (Acu_digit_rq_size +
			Acu_digit_rq_digit_size+1 +
			Acu_digit_rq_display_size+1 +
			Acu_digit_rq_display_size+1
			);
}

/*---------------*/

ushort build_acu_information_rq (p_data)
	uchar FAR *p_data;
{

#if ARINC_NETWORKS == ON
	char p_track[10];
#endif

		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_information_size);

#if ARINC_NETWORKS == ON

	Acu_information_credit_card_status	= ACUCARD_REJECT;
	Acu_information_nats_avail			= ACUNATS_AVAILABLE;
	Acu_information_satcom_avail		= ACUSATCOM_NOT_AVAILABLE;
	Acu_information_tfts_avail			= ACUTFTS_AVAILABLE;
	Acu_information_nats_pos			= ACUNATS_QUEUED;
	Acu_information_satcom_pos			= ACUSATCOM_NOT_QUEUED;
	Acu_information_tfts_pos			= ACUTFTS_QUEUED;

	p_track[0] = 0x1;
	p_track[1] = 0x2;
	p_track[2] = 0x3;
	p_track[3] = 0x4;
	p_track[4] = 0x5;

	Memcpy_far ((char FAR *)Acu_information_a_track_1, p_track, 5);
	Acu_information_track_1_size = 5;

	p_track[0] = 0x6;
	p_track[1] = 0x7;
	p_track[2] = 0x8;
	p_track[3] = 0x9;
	p_track[4] = 0x0;

	Memcpy_far ((char FAR *)Acu_information_a_track_2, p_track, 5);
	Acu_information_track_2_size = 5;

#endif

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_information_a_display_list,
							 (uchar FAR *)Acu_information_a_display
							);

		/* Then Keypad */

	Acu_information_keypad_size = sizeof ("*KEYPAD*");
	Memcpy_far (Acu_information_a_keypad, "*KEYPAD*", Acu_information_keypad_size);

#	if _CC_SPID_INFO == ON

		if (g_cc_sapi[0] == ACU_SAPI_MGT) {
            mg_endpoint_action ();
            Acu_information_endpoint_action = g_endpoint_action;

            if (Acu_information_endpoint_action != ACU_ACTION_NO_ENDPOINT_ID) {

                mg_usid ();
                Acu_information_usid = g_usid;
                mg_tid ();
                Acu_information_tid = g_tid;
                mg_interpreter ();
                Acu_information_interpreter = g_interpreter;
                mg_conn_id ();
                Acu_information_ces = g_conn_id;
            }
		}

#	endif

	return (Acu_information_size +
			Acu_information_display_size);

}

/*---------------*/

ushort build_acu_call_proc_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_call_proc_rq_size);

	mg_chan_id ();
	Acu_call_proc_rq_data_chani      = g_chan_id;
	Acu_call_proc_rq_data_chani_nb   = g_chan_id != 0 ? 1 : 0;
	Acu_call_proc_rq_data_chani_excl = g_chan_excl;

#if CC_PAR_PROGRESS_IND_IE == ON
	Acu_call_proc_rq_progress_description	= ACUPROGRESS_DESCR_IN_BAND_NOW;
	Acu_call_proc_rq_progress_location		= ACUPROGRESS_LOC_USER;
#endif

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_call_proc_rq_a_display_list,
							 (uchar FAR *)Acu_call_proc_rq_a_display
							);

#if ACU_PAR_EXTENDED_PRIM == ON

	if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			/* Store extended parameters */

			/* initialise the extension descriptor */

		Acu_ext_descr_address = (uchar FAR *)Acu_call_proc_rq_a_end_strings;

			/* Store extended ASN1 facility */

		cc_sim_acu_store_asn1_fac (p_data);

	}

#endif

	return (Acu_call_proc_rq_size +
			Acu_call_proc_rq_display_size+1
#			if ACU_PAR_EXTENDED_PRIM == ON
				+ Acu_ext_descr_lgth
#			endif
		   );
}

/*---------------*/

ushort build_acu_alert_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_alert_rq_size);

	mg_chan_id ();
	Acu_alert_rq_data_chani      = g_chan_id;
	Acu_alert_rq_data_chani_nb   = g_chan_id != 0 ? 1 : 0;
	Acu_alert_rq_data_chani_excl = g_chan_excl;

	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Acu_alert_rq_uui_size = Strcpy_far ((char FAR *)Acu_alert_rq_a_uui, "UUI alert_rq", 30);

	} else {

		Acu_alert_rq_uui_size = 0;
	}

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_alert_rq_a_display_list,
							 (uchar FAR *)Acu_alert_rq_a_display
							);

#if CC_PAR_PROGRESS_IND_IE == ON
	Acu_alert_rq_progress_description	= ACUPROGRESS_DESCR_IN_BAND_NOW;
	Acu_alert_rq_progress_location		= ACUPROGRESS_LOC_USER;
#endif

#if CC_PAR_SIGNAL_IE == ON
		Acu_alert_rq_signal_val 		= ACUNET_CONGEST_ON;
#endif

#if ACU_PAR_EXTENDED_PRIM == ON

	if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			/* Store extended parameters */

			/* initialise the extension descriptor */

		Acu_ext_descr_address = (uchar FAR *)Acu_alert_rq_a_end_strings;

			/* Store extended ASN1 facility */

		cc_sim_acu_store_asn1_fac (p_data);

	}

#endif

	return (Acu_alert_rq_size +
			Acu_alert_rq_uui_size+1 +
			Acu_alert_rq_display_size+1
#			if ACU_PAR_EXTENDED_PRIM == ON
				+ Acu_ext_descr_lgth
#			endif
		   );
}

/*---------------*/

ushort build_acu_user_info_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_user_info_size);

	mg_uui ();

	if (Toupper(g_uui[0]) == 'Y') {
		Acu_user_info_uui_size = Strcpy_far ((char FAR *)Acu_user_info_a_uui, "UUI user_info_rq", 30);

	} else {

		Acu_user_info_uui_size = 0;
	}

#if ACU_PAR_EXTENDED_PRIM == ON

	if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			/* Store extended parameters */

			/* initialise the extension descriptor */

		Acu_ext_descr_address = (uchar FAR *)Acu_user_info_a_end_strings;

			/* Store extended ASN1 facility */

		cc_sim_acu_store_asn1_fac (p_data);

	}

#endif

	return (Acu_user_info_size +
			Acu_user_info_uui_size
#			if ACU_PAR_EXTENDED_PRIM == ON
				+ Acu_ext_descr_lgth
#			endif
			);
}

/*---------------*/

ushort build_acu_facility_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_facility_size);

	mg_facility_code ();

	while (g_code[0] == '?') {
		pr_acu_facility_code ();
		mg_facility_code ();
	}

	Acu_facility_code = (uchar)g_facility_code;
	Acu_facility_facility_size   = 0;
	Acu_facility_calling_nb_size = 0;

	switch (g_facility_code) {

			/* Active-state facilities */

		case ACU_FAC_HOLD :
		case ACU_FAC_RETRIEVE :
		case ACU_FAC_ALTERNATE :
		case ACU_FAC_TRF :
		case ACU_FAC_THREE_PARTY :
			g_facility_action[0] = ACU_RQ_ACTIVATE;

			if (g_facility_code == ACU_FAC_THREE_PARTY) {
				mg_conn_id ();
				Acu_facility_conn_id =  g_conn_id;
			}

			if (cc_config_data.cc_config_na[g_nai].na_operator == AT5) {

					/* Conn-id needed for HCDT transfer */

				if (g_facility_code == ACU_FAC_TRF) {
					mg_conn_id ();
					Acu_facility_conn_id =  g_conn_id;
				}
			}

			break;

			/* Null-state facilities */

		case ACU_FAC_CALL_FORWARDING :
		case ACU_FAC_CALL_DEFLECTION :
			mg_facility_action ();

			if (g_facility_action[0] == ACU_RQ_ACTIVATE) {
				Strcpy_far (Acu_facility_a_called_address, "987654*123", 20);
			}
			break;

		case ACU_FAC_TRANSPARENT :
			Strcpy_far (Acu_facility_a_called_address, "987654*123", 20);
			Acu_facility_facility_size = Strcpy_far ((char FAR *)Acu_facility_a_facility, "ASN1 FACILITY !", 16);
			Acu_facility_calling_nb_size = Strcpy_far((char FAR *)Acu_facility_a_calling_nb, "12", 3);
			break;

		case ACU_FAC_CALL_APPEAR :
			g_facility_action[0] 	= ACU_RQ_ACTIVATE;
			Acu_facility_switchhook	= ACU_HOOK_ON;
			break;

		case ACU_FAC_FEATURE_ACT :
			g_facility_action[0] 	= ACU_RQ_ACTIVATE;
			Acu_facility_button_type= ACU_BUTTON_TYPE_UNKNOWN;
			mg_button ();
			Acu_facility_button_nb	= g_button;
			Acu_facility_module_nb	= ACU_MODULE_0;
			Acu_facility_call_appear= 0xFF;
			Acu_facility_switchhook	= 0xFF;
			break;

		case ACU_FAC_CHARGING :
		case ACU_FAC_CHARGING_TOTAL :
		case ACU_FAC_MALICIOUS_CALL_ID :
		default :
			break;

	}

	Acu_facility_action = g_facility_action[0];

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_facility_a_display_list,
							 (uchar FAR *)Acu_facility_a_display
							);

#if ACU_PAR_EXTENDED_PRIM == ON

	if (!(cc_sim_flag & CC_SIM_FLAG_FAC_IE)) {

			/* Store extended parameters */

			/* initialise the extension descriptor */

		Acu_ext_descr_address = (uchar FAR *)Acu_facility_a_end_strings;

			/* Store extended ASN1 facility */

		cc_sim_acu_store_asn1_fac (p_data);

	}

#endif

	return (Acu_facility_size +
			Acu_facility_facility_size+1 +
			Acu_facility_calling_nb_size+1 +
			Acu_facility_display_size+1
#			if ACU_PAR_EXTENDED_PRIM == ON
				+ Acu_ext_descr_lgth
#			endif
			);
}

/*---------------*/

ushort build_acu_suspend_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_suspend_size);

		/* Get the Call_id */

	Strcpy_far (Acu_suspend_a_call_id, "A", 2);

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_suspend_a_display_list,
							 (uchar FAR *)Acu_suspend_a_display
							);

	return (Acu_suspend_size +
			Acu_suspend_display_size+1);
}

/*---------------*/

ushort build_acu_resume_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_resume_size);

		/* Get the Service_id */

	mg_service_id    ();

	while (g_service_id[0] == '?') {
		pr_acu_service_id ();
		mg_service_id ();
	}

	Acu_resume_service = g_service_id[0];

		/* Get the Call_id */

	Strcpy_far (Acu_resume_a_call_id, "A", 3);

		/* Store Display IE if any */

	cc_sim_acu_store_display ((struct acu_display_list FAR *)Acu_resume_a_display_list,
							 (uchar FAR *)Acu_resume_a_display
							);

	return (Acu_resume_size +
			Acu_resume_display_size+1
			);
}

/*---------------*/

ushort build_acu_test_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_test_size);

	Acu_test_action					= ACU_RQ_ACTIVATE;
	Acu_test_code					= ACU_TEST_B_CHAN_LOOP_BACK;
	Acu_test_b_chan_loop_back_nb	= 1;

	return (Acu_test_size);
}

/*---------------*/

ushort	build_acu_set_mode_rq (p_data)
	uchar FAR *p_data;
{
		/* Reset to 0 the primitive data structure */

	Memset_far ((char FAR *)p_data, 0, Acu_set_mode_size);

	mg_set_mode_action ();
	mg_set_mode_code ();

	Acu_set_mode_action	= g_set_mode_action[0];
	Acu_set_mode_code	= g_set_mode_code[0];

	return (Acu_set_mode_size);
}

/*-------------------------------------*/

void cc_sim_acu_store_display (p_display, p_data)
	struct acu_display_list FAR *p_display;
	uchar                   FAR *p_data;
{
	g_cc_display_total_size = 0;

	if (cc_sim_flag & CC_SIM_FLAG_DISPLAY) {
		p_data = cc_sim_acu_add_display (p_display, p_data, "First DISPLAY string (#1)");
		p_data = cc_sim_acu_add_display (p_display, p_data, "Second DISPLAY string (#2)");
		g_cc_display_total_size = Acu_display_total_size;
	}

}

	/*---*/

uchar FAR *cc_sim_acu_add_display (p_display, p_data, p_string)
	struct acu_display_list FAR *p_display;
	uchar                   FAR *p_data;
	char                    FAR *p_string;
{
	uchar idx = Acu_display_nb;
	uchar siz = strlen (p_string) + 1;

		/* update the acu_display_list structure fields */

	Acu_display_nb++;
	Acu_display_total_size     += siz;
	Acu_display_type      (idx) = 0;
	Acu_display_p_display (idx) = (char FAR *)p_data;
	Acu_display_size      (idx) = siz;

		/* copy the string */

	Memcpy_far ((char FAR *)p_data, p_string, siz);

		/* return address of next string location */

	return (p_data + siz);
}

/*-------------------------------------*/

#if ACU_PAR_EXTENDED_PRIM == ON

#include "acu_ss.h"

void cc_sim_acu_store_asn1_fac (p_data)
	uchar FAR *p_data;
{
	uchar FAR *p_ext_data;
	uchar FAR *p_ss_component;		/* component pointer */
	uchar FAR *p_ss_operation;		/* operation pointer */
	uchar FAR *p_ss_info;			/* additional information pointer */
	uchar FAR *p_ss_begin;			/* pointer to the beginning of the ASN1 data */
	ushort     asn1_size;

			/* prepare 'p_ext_data' */

	p_ext_data = Acu_ext_descr_address + Acu_ext_descr_lgth;

			/* update the extension descriptor */

	Acu_ext_descr_nb++;

			/* write the extended parameter header */

	Acu_ext_id   = ACU_EXT_FAC_ASN1;

		/*
		 * acu_ss.h/2.3.a:
		 * Set p_ss_component to point to the component header;
		 */

	p_ss_begin     =
	p_ss_component = p_ext_data + Acu_ext_fac_asn1_size;

		/*
		 * acu_ss.h/2.3.b.:
		 * Use one of the following macros to write the component header:
		 * - 'Acu_ss_store_comp_invoke()' for an "INVOKE" component
		 * - 'Acu_ss_store_comp_return_result()' for a "RETURN RESULT" component
		 * - 'Acu_ss_store_comp_return_error()' for a "RETURN ERROR" component
		 * - 'Acu_ss_store_comp_reject()' to store a "REJECT" component
		 */

		/*
		 * Store an "Invoke" component,
		 * with "AOCChargingRequest" operation argument:
		 */

	Acu_ss_store_comp_invoke(PRESENT, 1, 0, ACU_OP_AOC_CHARGING_RQ);

		/*
		 * Store the Operation:
		 * acu_ss.h/2.3.c. and 3.3.a.:
		 * use the operation-specific macros to write the different fields
		 * of the operation structure:
		 */

	Acu_aoc_charging_rq (charging_case) = ACU_AOC_CHARGING_CALL_SETUP;

		/*
		 * acu_ss.h/3.3.b.:
		 * Acu_ss_set_to_end_of_operation(op_struct_name) sets 'p_ss_info'
		 * to the end of the current operation structure, in order to
		 * read or write the additional information,
		 * or the next component.
		 */

	Acu_ss_set_to_end_of_operation (acu_aoc_charging_rq_arg);

		/*
		 * Let's store another component:
		 * acu_ss.h/2.3.d.:
		 * call 'Acu_ss_set_to_next_component()' to update the
		 * 'next_component_offset' field of the current component, and
		 * the p_ss_component pointer;
		 * go to 2.3.b.;
		 */

	Acu_ss_set_to_next_component ();

		/*
		 * acu_ss.h/2.3.b.:
		 * Use one of the following macros to write the component header:
		 * - 'Acu_ss_store_comp_invoke()' for an "INVOKE" component
		 * - 'Acu_ss_store_comp_return_result()' for a "RETURN RESULT" component
		 * - 'Acu_ss_store_comp_return_error()' for a "RETURN ERROR" component
		 * - 'Acu_ss_store_comp_reject()' to store a "REJECT" component
		 */

		/*
		 * Store an "Invoke" component,
		 * with "AOCChargingRequest" operation argument:
		 */

	Acu_ss_store_comp_invoke(PRESENT, 1, 0, ACU_OP_AOC_CHARGING_RQ);

		/*
		 * Store the Operation:
		 * acu_ss.h/2.3.c. and 3.3.a.:
		 * use the operation-specific macros to write the different fields
		 * of the operation structure:
		 */

	Acu_aoc_charging_rq (charging_case) = ACU_AOC_CHARGING_DURING_CALL;

		/*
		 * acu_ss.h/3.3.b.:
		 * Acu_ss_set_to_end_of_operation(op_struct_name) sets 'p_ss_info'
		 * to the end of the current operation structure, in order to
		 * read or write the additional information,
		 * or the next component.
		 */

	Acu_ss_set_to_end_of_operation (acu_aoc_charging_rq_arg);

		/*
		 * no other component is to be stored:
		 * acu_ss.h/2.3.d.:
		 * call 'Acu_ss_set_last_component()' to end the component
		 * header;
		 */

	Acu_ss_set_last_component ();

		/*
		 * acu_ss.h/2.3.d. (continued):
		 * // end of facility processing.
		 * // p_ss_info gives the current address of the last byte stored
		 * // in the facility, which can be used to compute the total
		 * // length of the ANS1 facility.
		 */

	asn1_size    = Acu_ext_fac_asn1_size +
				   (ulong)p_ss_info - (ulong)p_ss_begin;

	Acu_ext_lgth        = asn1_size;
	Acu_ext_descr_lgth += asn1_size;

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mg_xxx - get one parameter needed for the
						 building of a CC_???_RQ/RS primitive.

Usage           void mg_xxx ()

Common constants and declarations : services.h and simul.h

*--------------------------------------------------------------------------*/

void mg_na_nb ()
{
	Prompt	("NA nb (0=default config)", u, g_na_nb);
	Scan 	(d, &g_na_nb);
	Echo	(u, g_na_nb);
}

/*---------------*/

void mg_user_entity ()
{
	Prompt	("             User entity", c, g_user_entity[0]);
	Scan 	(1s, &g_user_entity[0]);
	Echo	(c, g_user_entity[0]);
}

/*---------------*/

void mg_user_sapi ()
{
	Prompt	("         User sapi (C/A)", c, g_user_sapi[0]);
	Scan 	(1s, &g_user_sapi[0]);
	Echo	(c, g_user_sapi[0]);
}

/*---------------*/

void mg_call_nb ()
{
	Prompt	(" Number of Call contexts", u, g_call_nb);
	Scan 	(d, &g_call_nb);
	Echo	(u, g_call_nb);
}

/*---------------*/

void mg_in_calls_behaviour ()
{
	Prompt	("    Auto answering (Y/N)", c, g_in_calls_behaviour[0]);
	Scan 	(1s, &g_in_calls_behaviour[0]);
	Echo	(c, g_in_calls_behaviour[0]);
}

	char mg_data_conn_rs_behaviour ()
	{
		Prompt	(" Auto Data CONN_RS (Y/N)", c, g_in_calls_behaviour[0]);
		Scan 	(1s, &g_in_calls_behaviour[0]);
		Echo	(c, g_in_calls_behaviour[0]);
		return	(Toupper (g_in_calls_behaviour[0]));
	}

	char mg_voice_conn_rs_behaviour ()
	{
		Prompt	("Auto Voice CONN_RS (Y/N)", c, g_in_calls_behaviour[0]);
		Scan 	(1s, &g_in_calls_behaviour[0]);
		Echo	(c, g_in_calls_behaviour[0]);
		return	(Toupper (g_in_calls_behaviour[0]));
	}

	char mg_data_alert_rq_behaviour ()
	{
		Prompt	(" Auto Data ALERT_RQ(Y/N)", c, g_in_calls_behaviour[0]);
		Scan 	(1s, &g_in_calls_behaviour[0]);
		Echo	(c, g_in_calls_behaviour[0]);
		return	(Toupper (g_in_calls_behaviour[0]));
	}

	char mg_voice_alert_rq_behaviour ()
	{
		Prompt	("Auto Voice ALERT_RQ(Y/N)", c, g_in_calls_behaviour[0]);
		Scan 	(1s, &g_in_calls_behaviour[0]);
		Echo	(c, g_in_calls_behaviour[0]);
		return	(Toupper (g_in_calls_behaviour[0]));
	}

	char mg_send_alert_in_behaviour	()
	{
		Prompt	(" Auto ACU_ALERT_IN (Y/N)", c, g_in_calls_behaviour[0]);
		Scan 	(1s, &g_in_calls_behaviour[0]);
		Echo	(c, g_in_calls_behaviour[0]);
		return	(Toupper (g_in_calls_behaviour[0]));
	}

	char mg_send_call_proc_rq_behaviour ()
	{
		Prompt	(" Auto CALL_PROC_RQ (Y/N)", c, g_in_calls_behaviour[0]);
		Scan 	(1s, &g_in_calls_behaviour[0]);
		Echo	(c, g_in_calls_behaviour[0]);
		return	(Toupper (g_in_calls_behaviour[0]));
	}

	char mg_transp_overlap_rcv_behaviour ()
	{
		Prompt	("Transp Overlap rcv (Y/N)", c, g_in_calls_behaviour[0]);
		Scan 	(1s, &g_in_calls_behaviour[0]);
		Echo	(c, g_in_calls_behaviour[0]);
		return	(Toupper (g_in_calls_behaviour[0]));
	}

	char mg_nb_digits_to_route ()
	{
		Prompt	("   Nb of digits to route", d, g_nb_digits_to_route);
		Scan 	(d, &g_nb_digits_to_route);
		Echo	(d, g_nb_digits_to_route);
		return	((uchar)g_nb_digits_to_route);
	}

/*---------------*/

void mg_cc_sapi ()
{
	Prompt	("                    Sapi", c, g_cc_sapi[0]);
	Scan 	(1s, &g_cc_sapi[0]);
	Echo	(c, g_cc_sapi[0]);
}

/*---------------*/

void mg_service_id ()
{
	Prompt	("                 Service", c, g_service_id[0]);
	Scan 	(1s, &g_service_id[0]);
	Echo	(c, g_service_id[0]);
}

/*---------------*/

void mg_called_nb_sub_add ()
{
	*g_called_nb = ' ';
	Prompt	("    called number digits", s, g_called_nb);
	Scan 	(s, g_called_nb);
	Echo	(s, g_called_nb);
}

/*---------------*/

void mg_layer_1_info ()
{
	mg_syn_asyn ();
	mg_user_rate();
	mg_data_bit ();

	if (g_data_bit != ACU_BYTE_VAL_NIL) {
		mg_parity   ();
		mg_stop_bit ();
	}
}

void mg_syn_asyn ()
{
	g_syn_asyn[0] = 'S';

	for (;;) {

		Prompt	("       SYN(S) or ASYN(A)", c, g_syn_asyn[0]);
		Scan 	(1s, &g_syn_asyn[0]);
		Echo	(c, g_syn_asyn[0]);

		switch (Toupper (g_syn_asyn[0])) {

			case 'S' :
				g_syn_asyn[0] = ACU_SYN;
				return;

			case 'A' :
				g_syn_asyn[0] = ACU_ASYN;
				return;

			default :
				g_syn_asyn[0] = 0xff;
				return;
		}
	}
}

void mg_user_rate ()
{
	g_user_rate = 1;

	for (;;) {

		Prompt	("User rate(1=19200,5=56k)", d, g_user_rate);
		Scan 	(d, &g_user_rate);
		Echo	(d, g_user_rate);

		switch (g_user_rate) {

			case 1 :
				g_user_rate = ACU_RA_19200;
				return;

			case 5 :
				g_user_rate = ACU_RA_56000;
				return;

			default:
				return;
		}
	}
}

void mg_data_bit ()
{
	g_data_bit = 8;

	for (;;) {

		Prompt	("Data bit (5,7,8,255=N/A)", d, g_data_bit);
		Scan 	(d, &g_data_bit);
		Echo	(d, g_data_bit);

		switch (g_data_bit) {

			case 5 :
				g_data_bit = ACU_DATA_BIT_5;
				return;

			case 7 :
				g_data_bit = ACU_DATA_BIT_7;
				return;

			case 8 :
				g_data_bit = ACU_DATA_BIT_8;
				return;

			case 255 :
				g_stop_bit = g_parity[0] = ACU_BYTE_VAL_NIL;
				return;
		}
	}
}

void mg_parity ()
{
	g_parity[0] = 'N';

	for (;;) {

		Prompt	("          Parity (O,E,N)", c, g_parity[0]);
		Scan 	(1s, &g_parity[0]);
		Echo	(c, g_parity[0]);

		switch (Toupper (g_parity[0])) {

			case 'N' :
				g_parity[0] = ACU_NO_PARITY;
				return;

			case 'E' :
				g_parity[0] = ACU_EVEN;
				return;

			case 'O' :
				g_parity[0] = ACU_ODD;
				return;
		}
	}
}

void mg_stop_bit ()
{
	g_stop_bit = 1;

	for (;;) {

		Prompt	("Stop bit (1=1,2=2,0=1.5)", d, g_stop_bit);
		Scan 	(d, &g_stop_bit);
		Echo	(d, g_stop_bit);

		switch (g_stop_bit) {

			case 0 :
				g_stop_bit = ACU_STOP_BIT_1_5;
				return;

			case 1 :
				g_stop_bit = ACU_STOP_BIT_1;
				return;

			case 2 :
				g_stop_bit = ACU_STOP_BIT_2;
				return;
		}
	}
}

/*---------------*/

void mg_calling_nb_sub_add ()
{
	*g_calling_nb = ' ';
	Prompt	("   calling number digits", s, g_calling_nb);
	Scan 	(s, g_calling_nb);
	Echo	(s, g_calling_nb);
}

/*---------------*/

void mg_chan_id ()
{
	char	str[10];

	str[0] = '\0';

	Prompt	("              Channel id", 4s, &str[0]);
	Scan	(4s, &str[0]);
	Echo	(4s, &str[0]);

	if (Toupper (str[0]) == 'X') {

			/* eXclusive channel */

		g_chan_excl = ON;
		g_chan_id   = atoi (&str[1]);
		return;

	} else {

			/* preferred channel */

		g_chan_excl = OFF;
		g_chan_id   = atoi (&str[0]);
		return;
	}

}

/*---------------*/

void mg_provide_chan_id ()
{
	Prompt	("         Provide chan_id", c, g_provide_chan_id[0]);
	Scan 	(1s, &g_provide_chan_id[0]);
	Echo	(c, g_provide_chan_id[0]);
}

/*---------------*/

void mg_uui_recognition ()
{
	Prompt	("   UUI recognition (Y/N)", c, g_uui_recognition[0]);
	Scan 	(1s, &g_uui_recognition[0]);
	Echo	(c, g_uui_recognition[0]);
}

/*---------------*/

void mg_uui ()
{
	Prompt	("  UUI in primitive (Y/N)", c, g_uui[0]);
	Scan 	(1s, &g_uui[0]);
	Echo	(c, g_uui[0]);
}

/*---------------*/

void mg_facility_code ()
{
	Prompt	("           Facility code", u, g_facility_code);
	Scan 	(d, &g_facility_code);
	Echo	(u, g_facility_code);
}

/*---------------*/

void mg_facility_action ()
{
	Prompt	(" Facility action (A/C/E)", c, g_facility_action[0]);
	Scan 	(1s, &g_facility_action[0]);
	Echo	(c, g_facility_action[0]);
}

/*---------------*/

void mg_call_appear ()
{
	Prompt	("             Call appear", u, g_call_appear);
	Scan 	(d, &g_call_appear);
	Echo	(u, g_call_appear);
}

/*---------------*/

void mg_button ()
{
	Prompt	("               Button nb", u, g_button);
	Scan 	(d, &g_button);
	Echo	(u, g_button);
}

/*---------------*/

void mg_set_mode_code ()
{
	Prompt	("           Set_mode code", c, g_set_mode_code[0]);
	Scan 	(1s, &g_set_mode_code[0]);
	Echo	(c, g_set_mode_code[0]);
}

/*---------------*/

void mg_set_mode_action ()
{
	Prompt	(" Set_mode action (A/C/E)", c, g_set_mode_action[0]);
	Scan 	(1s, &g_set_mode_action[0]);
	Echo	(c, g_set_mode_action[0]);
}

#if _CC_SPID_INFO == ON /* { */

void mg_endpoint_action()
{
	Prompt	("                  Action", u, g_endpoint_action);
	Scan 	(d, &g_endpoint_action);
	Echo	(u, g_endpoint_action);
}

/*--------------*/

void mg_usid ()
{
	Prompt	("                    USID", u, g_usid);
	Scan 	(d, &g_usid);
	Echo	(u, g_usid);
}

/*-------------*/

void mg_tid ()
{
	Prompt	("                     TID", u, g_tid);
	Scan 	(d, &g_tid);
	Echo	(u, g_tid);
}

/*-------------*/

void mg_interpreter ()
{
	Prompt	("             Interpreter", u, g_interpreter);
	Scan 	(d, &g_interpreter);
	Echo	(u, g_interpreter);
}

#endif /* } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			pr_xxx - print lists of allowed symbols

Usage           void pr_xxx ()

Common constants and declarations : services.h and simul.h and ana_cc.c

*--------------------------------------------------------------------------*/

void pr_cc_sapi ()
{
	fprintf (f_out, "\n\t\t%c : CC  sapi\n\t\t%c : ACU sapi Management\n\t\t%c : ACU sapi\n",
					CC_SAPI, ACU_SAPI_MGT, ACU_SAPI);
}

/*---------------*/

extern	CONST	struct	code_text	cc_prim[];
extern	CONST	struct	code_text	acu_prim[];

void pr_cc_code ()
{
	struct code_text *p_prim;
	uchar i = 0;

	fprintf (f_out, "    Call Control primitives codes \n");

	p_prim = (g_cc_sapi[0] == CC_SAPI) ? (struct code_text *)cc_prim : (struct code_text *)acu_prim;

	while ((p_prim[i].code != 0) && (p_prim[i].code < 'a')) {

		if ((i+1) % 2) {
			fprintf (f_out, "\n\t%c : %s",p_prim[i].code,p_prim[i].p_text);

		} else {

			fprintf (f_out, "\t\t%c : %s",p_prim[i].code,p_prim[i].p_text);
		}

		i++;
	}
	fprintf (f_out, "\n");
}

/*---------------*/

extern	struct code_text t_cc_service_id[];

void pr_cc_services_list ()
{
	uchar i = 0;

	fprintf (f_out, "\n");

	while (t_cc_service_id[i].code != 0) {

		if ((i+1) % 2) {
			fprintf (f_out, "\n\t%c : %s",t_cc_service_id[i].code, t_cc_service_id[i].p_text);

		} else {

			fprintf (f_out, "\t\t%c : %s",t_cc_service_id[i].code, t_cc_service_id[i].p_text);
		}

		i++;
	}
	fprintf (f_out, "\n");
}

/*---------------*/

extern	struct code_text t_acu_service_id[];

void pr_acu_service_id ()
{
	uchar i = 0;

	fprintf (f_out, "\n");

	while (t_acu_service_id[i].code != 0) {

		if ((i+1) % 2) {
			fprintf (f_out, "\n\t%c : %s", t_acu_service_id[i].code, t_acu_service_id[i].p_text);

		} else {

			fprintf (f_out, "\t\t%c : %s", t_acu_service_id[i].code, t_acu_service_id[i].p_text);
		}

		i++;
	}
	fprintf (f_out, "\n");
}

/*---------------*/

extern	struct code_text t_acu_facility_code[];

void pr_acu_facility_code ()
{
	uchar i = 0;

	fprintf (f_out, "\n");

	while (t_acu_facility_code[i].code != 0) {

		if ((i+1) % 2) {
			fprintf (f_out, "\n\t%d : %s", t_acu_facility_code[i].code, t_acu_facility_code[i].p_text);

		} else {

			fprintf (f_out, "\t\t%d : %s", t_acu_facility_code[i].code, t_acu_facility_code[i].p_text);
		}

		i++;
	}
	fprintf (f_out, "\n");
}

/*---------------*/

extern	CONST	struct	code_text	sm_prim[];

void pr_sm_code ()
{
	uchar i = 0;

	fprintf (f_out, "              SM primitives codes \n");

	while (sm_prim[i].code != 0) {

		if (sm_prim[i].code >= 'a') {
			i++;
			continue;	/* print only SM_..._RQ/RS codes */
		}

		if ((i+1) % 2) {
			fprintf (f_out, "\n\t%c : %s",sm_prim[i].code,sm_prim[i].p_text);

		} else {

			fprintf (f_out, "\t\t%c : %s",sm_prim[i].code,sm_prim[i].p_text);
		}

		i++;
	}
	fprintf (f_out, "\n");
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            extract_nb_sub_add - extracts the Called number and
				Called sub-address out of a string which format is :
					"123564*4564"

Usage           void extract_nb_sub_add (uchar FAR *p_from,
										 uchar FAR *p_to_nb,
										 uchar FAR *p_to_sub_add);

Common constants and declarations : services.h and simul.h and ana_cc.c

*--------------------------------------------------------------------------*/

void extract_nb_sub_add (p_from, p_to_nb, p_to_sub_add)
	uchar FAR *p_from;
	uchar FAR *p_to_nb;
	uchar FAR *p_to_sub_add;
{
	ushort i,j;

	for (i = 0; p_from[i] != CC_SUB_ADDRESS_DELIMITER && p_from[i] != '\0'; i++) {
		p_to_nb[i] = p_from[i];
	}

	p_to_nb[i] = '\0';

#	if CC_CALLED_SUB_ADD == ON

	j = 0;

	if (p_from[i++] == CC_SUB_ADDRESS_DELIMITER) {

		for ( ; p_from[i] != '\0'; i++, j++) {
			p_to_sub_add[j] = p_from[i];
		}

	}

	p_to_sub_add[j] = '\0';

#	endif

}


#endif	/* SIMULATION */

/*EOF*/
