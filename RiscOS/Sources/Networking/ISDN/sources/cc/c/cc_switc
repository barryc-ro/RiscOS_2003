
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - cc_switch.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *        cc_switch - implements a Call Control responder.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Call Control (CC) Entity                         |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "cc.h"
#include "isdn.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#include "cc_ie.h"
#include "ctx_ext.h"

#include "ph_int.h"

#include "cc_undef.h"
#include "ns_mac.h"
#include "cc_undef.h"	/* restore ns_par.h flags */

		/* Isdn context */

	Isdn_ctx;

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_switch - implements the Call Control responder
				automaton.

Usage           uchar cc_switch ();

Return value	: STOP if nothing else to do;
				  CONTINUE if to be processed in State-driven part.

*--------------------------------------------------------------------------*/

uchar cc_switch ()
{
	uchar			FAR	*p_data;		/* data pointer in primitive */
	uchar				tmp_cause, network_cause;

#	if CC_RESTART_PROCEDURE == ON
		uchar			i;
#	endif

#	if CC_SUPP_SERVICES == ON
		uchar			calling_nb_size;    /* calling nb size */
#	endif

#	if ACU_INTERFACE == ON
		uchar			action_code;
		struct cc_b_chan FAR  *p_cc_b_chan;
#	endif

#	if CC_INTERFACE == ON
		uchar		FAR *p_cc_data;		/* data pointer in Call Control primitive */
#	endif

		/* Set event ID and from ID variables */

#	if CC_INTERFACE == ON
		p_cc_data			=
#	endif

	p_data					= p_data_cc;

		/*
			Reset the buffer pointer in order to use it
			for sending messages.
		*/

	p_buffer				= P_NIL;

	/********************************************************************
	 *                                                                  *
	 *						EVENT DRIVEN AUTOMATON                      *
	 *                                                                  *
	 *				Switch according to the received event              *
	 *                                                                  *
	 ********************************************************************/

	switch (cc_event_id) {

#		if CC_RESTART_PROCEDURE == ON

				/*-------------------------------------------------------*/
				/*                                                       */
				/*                     NS_RESTART_IN                     */
				/*                                                       */
				/*-------------------------------------------------------*/

			case Event (NS_SAPI_SIG, NS_RESTART_IN) :

				if (Restart_procedure_used == OFF) break;

				cc_restart_indicator = Net_isdn_get_val (NS_RESTART_IN, IE_RESTART_IND, FLD_RESTART_CLASS);

				switch (cc_restart_indicator) {

					case RI_INDICATED_CHANNEL :

							/*	Read Channel ID received from NS and process
								according to 'Channel selection' field */

						cc_read_chan_id_from_ns (NS_RESTART_IN);

						if (cc_chan_sel == NO_CHAN) {

							break;		/* No Channel specified : nothing to do -> stop processing */
						}

							/*	1 or more B channel(s) are to be restarted -> set 'cc_store_chan_id'
								so that a Channel ID IE is included in RESTART ACK that will be sent */

						cc_store_chan_id = ON;

							/*	if "Any Channel" is specified, all channels are to be restarted
								(equivalent to "Single Interface") -> process in next 'case' */

						if (cc_chan_sel != ANY_CHAN) {

							i = 0;

							while ((cc_chan_id[i] != 0) && (i < CC_NB_CHAN_ID_SENT)) {

									/* Search the call context related to the chan_id */

								cc_access_first_call ();

								while (p_cc_call != P_NIL) {

									if ((Cc_call_state != STATE_NULL) &&
										(Cc_call_b_chan_id == cc_chan_id [i])) {

											/*
											 * chan_id found :
											 *	send NS_RESTART_RQ,
											 *	send CLEAR_CO to the appli,
											 *	clear call context,
											 *	send NS_RESTART_RS on management conn id.
											 */

										cc_restart_chan_id (ON);
									}

									cc_access_next_call ();

								}

								i++;

							}

								/*
								 * No more channel to be restarted.
								 * Send a NS_RESTART_RS to end
								 * the restart procedure.
								 */

							cc_current_conn_id = CONN_ID_MANAGEMENT;
							cc_snd_to_ns (NS_RESTART_RS);
							break;
						}

							/* no break : process of "Any channel" is done in 'case' hereafter */

					case RI_SINGLE_INTERFACE :
					case RI_ALL_INTERFACES :

							/* Search the call context related to the chan_id */

						cc_access_first_call ();

						while (p_cc_call != P_NIL) {

							if (Cc_call_state != STATE_NULL) {

									/*
									 *	send NS_RESTART_RQ,
									 *	send CLEAR_CO to the appli,
									 *	clear call context,
									 *	send NS_RESTART_RS on management conn id.
									 */

									 /*	!! 'cc_restart_indicator' may indicate :
									  *		1) All Interfaces
									  *		2) Single Interface
									  *		3) Indicated Channel if channel selection is "Any Channel"
									  */

								if (cc_restart_indicator != RI_ALL_INTERFACES) {
									cc_restart_chan_id (ON);	/* case 2) and 3) above */
								} else {
									cc_restart_chan_id (OFF);	/* case 1) above */
								}
							}

							cc_access_next_call ();

						}

							/*
							 * No more channel to be restarted.
							 * Send a NS_RESTART_RS to end
							 * the restart procedure.
							 */

						cc_current_conn_id = CONN_ID_MANAGEMENT;
						cc_snd_to_ns (NS_RESTART_RS);
						break;

				}

				break;

#			endif	/* CC_RESTART_PROCEDURE */

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     NS_ERR_IN                         */
			/*                                                       */
			/*-------------------------------------------------------*/

		case Event (NS_SAPI_SIG, NS_ERR_IN) :

				/* Set the right ACU error code according to the received NS error code */

			switch (R_msg_inf0) {

					/*
						System congestion error :
							- inform upper entity.
					*/

				case ERR_U_CONGESTION_BUSY :			/* resource congestion */

					switch (cc_current_sapi_user) {

#					  if CC_INTERFACE == ON

						case CC_SAPI :
							Cc_set_cc_error (ERR_CC_CONGESTION);
							break;
#					  endif

#					  if ACU_INTERFACE == ON

						case ACU_SAPI :
							cc_snd_acu_err_in (ACUER_CONGESTION, 0);
							break;
#					  endif

					}
					break;


					/*
						Call addressing error :
							- inform upper entity;
							- clear the call context.
					*/

				case ERR_U_NON_EXISTENT_CALL 		 :	/* the call connection does not exist */
				case ERR_U_NAI 						 :	/* invalid Network Access ID */
				case ERR_U_CALL_CONN_ID_UNKNOWN 	 :	/* call connection ID unknown */
				case ERR_U_CALL_CONN_ID_ALREADY_USED :	/* call connection ID already used */
				case ERR_U_NO_CALL_CTX_AVAILABLE 	 :	/* call connection context saturation */

					switch (cc_current_sapi_user) {

#					  if CC_INTERFACE == ON

						case CC_SAPI :
							Cc_set_cc_error (ERR_CC_ADDRESSING);
							Cc_call_clear ();
							break;
#					  endif

#					  if ACU_INTERFACE == ON

						case ACU_SAPI :
							Cc_set_acu_error (ACURC_NOLINE);
							Cc_call_clear ();
							break;
#					  endif

					}
					break;

				case ERR_U_SSDU_UNEXPECTED 			 :	/* unexpected SSDU */

					if (R_msg_inf1 == NS_INFO_RQ) {

							/*
								Ignore error upon having sent an extra
								NS_INFO_RQ (collision between NS_INFO_RQ and
								NS_CALL_PROC_IN).
							*/

						break;
					}

					switch (cc_current_sapi_user) {

#					  if ACU_INTERFACE == ON

						case ACU_SAPI :

#						  if CC_SPF_FAC == ON

							if (Spf_fac_used == ON) {

								if (Cc_call_last_msg_to_ns == NS_SPF_FACILITY_RQ) {
									Acu_alloc_data				(Acu_facility_size);
									Acu_facility_code 			= Cc_call_facility_code;
									Cc_call_facility_code		= NIL;
									Acu_facility_action 		= ACU_CO_REJ;

									if (Cc_na_network != cc_tr6) {
										Acu_facility_network_cause 	= C_v_user (C_C_PROTOCOL_ERROR, C_V_MESSAGE_STATE_INCONSISTENCY_98);

									} else {

										Acu_facility_network_cause 	= ACU_NETWORK_CAUSE_NIL;
									}

									cc_snd_to_user				(ACU_FACILITY_CO);
									cc_retrieve_previous_state	();
									return (STOP);
								}

							}

#						  endif

							break;

#					  endif

						default :
							break;
					}

					/* no break; here: Carry-on like other error codes */

					/*
						Protocol message coding error :
							- inform upper entity;
							- process call clearing sequence.
					*/

				case ERR_U_SSDU_CODE 				 :	/* unknown SSDU ID */
				case ERR_U_PRIMITIVE_NOT_IMPLEMENTED : 	/* SSDU primitive not implemented */

						/* Force ACU primitive code error diag */

					R_msg_inf1 = Cc_call_last_msg_from_user;

					/* no break; here: Carry-on like other error codes */

				case ERR_U_MANDATORY_PARAM_MISSING 	 :	/* mandatory parameter missing */
				case ERR_U_PARAM_TYPE 				 :	/* incorrect parameter type */
				case ERR_U_PARAM_LGTH 				 :	/* incorrect parameter length */
				case ERR_U_PARAM_VAL 				 :	/* invalid parameter */
				default :

					switch (cc_current_sapi_user) {

#					  if CC_INTERFACE == ON

						case CC_SAPI :
							Cc_set_cc_error (ERR_CC_PROTOCOL);

							switch (Cc_call_state) {

								case STATE_CALL_INIT :
								case STATE_RELEASE_USER :
								case STATE_RELEASE_RQ :

										/*
											Do not send NS_CLEAR_RQ,
											Wait for CC_HOOK_ON_RS / ACU_CLEAR_RS.
										*/

									Cc_set_state (STATE_ERROR_IN);
									break;

								default :
									cc_snd_to_ns (NS_CLEAR_RQ);
									break;
							}

							break;
#					  endif

#					  if ACU_INTERFACE == ON

						case ACU_SAPI :
							cc_snd_acu_err_in ((uchar)R_msg_inf0, (uchar)R_msg_inf1);
							cc_retrieve_previous_state ();
							return (STOP);
#					  endif

					}

					break;

			}
			return (STOP);

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     NS_CLEAR_IN                       */
			/*                                                       */
			/*-------------------------------------------------------*/

		case Event (NS_SAPI_SIG, NS_CLEAR_IN) :

				/*
				 * Process only if not yet in clearing phase.
				 * If we are still waiting for digits, we clear the call
				 * without sending anything to the application.
				 */

			cc_read_cause_from_ns (NS_CLEAR_IN);

#			if CC_PAR_PROGRESS_IND_IE == ON
				cc_read_progress_ind_from_ns (NS_CLEAR_IN);
#			endif

			switch (Cc_call_state) {

				case STATE_RELEASE_IN :
					break;

				case STATE_RELEASE_RQ :

#					if CC_F_VN6 == ON

						if ((Cc_na_network == cc_vn6) && (Cc_na_country == FRANCE)) {

								/*
									Clearing collision:
									NS might have ignored the previous
									NS_CLEAR_RQ if the state was u7 (alerting).
									We must answer to the incoming clearing
									indication.
								*/

							cc_snd_to_ns (NS_CLEAR_RS);
						}

#					endif

					break;

#				if CC_OVERLAP_RECEIVING == ON

					case STATE_AWAIT_DIGIT :
						cc_snd_to_ns (NS_CLEAR_RS);
						Cc_set_state (STATE_RELEASE_IN);
						break;

#				endif

				default :

#				if CC_UUI == ON

					p_cc_uui = p_cc_empty_string;	/* no UUI by default */

					cc_read_uui_from_ns (NS_CLEAR_IN);

					if ((p_cc_uui == p_cc_empty_string) &&
						(Cc_call_state == STATE_OUTGOING_CALL_PROC)) {

							/*
							 * First response to SETUP without UUI,
							 * so set the flag to OFF.
							 */

						Cc_call_uui_rq = OFF;
					}

#				endif

					/*--------------------------*/
					/* Get facility information */
					/*--------------------------*/

#				if CC_SUPP_SERVICES == ON

					cc_read_facility_from_ns (NS_CLEAR_IN);

#				else

#					if _ACU_PAR_EXT_FACILITY == ON
						cc_read_ext_facility_from_ns (NS_CLEAR_IN);
#					endif

#				endif

#				if CC_PAR_SIGNAL_IE == ON
					cc_read_signal_from_ns (NS_CLEAR_IN);
#				endif

#				if CC_PAR_CHARGING_INFO == ON
					cc_read_charging_value_from_ns (NS_CLEAR_IN);
#				endif

				switch (cc_current_sapi_user) {

#				  if CC_INTERFACE == ON

					case CC_SAPI :
						Cc_alloc_data (Cc_hook_on_in_size);
						Cc_hook_on_in_cause_class = cc_cause_class;
						Cc_hook_on_in_cause_val   = cc_cause_val;

#						if CC_UUI == ON
							Strcpy_far ((char FAR *)Cc_hook_on_in_a_uui, p_cc_uui, CC_MX_SZ_UUI+1);
#						endif

						cc_snd_to_user (CC_HOOK_ON_IN);
						break;
#				  endif

#				  if ACU_INTERFACE == ON

					case ACU_SAPI :
						Acu_alloc_data (Acu_clear_in_size +
										cc_uui_size +
										cc_facility_size +
										cc_display_total_size +
										cc_i_ext_lgth);

						Acu_clear_in_network_cause =
						Cc_call_clear_cause        = cc_cause;

							/* Determine 'ret_code' according to the network cause */

						tmp_cause = (Cc_na_network != cc_tr6) ?
								C_v_user (C_C_NORMAL_EVENT, C_V_USER_BUSY_17) :
								C_v_user (C_C_011, C_V_USER_BUSY);

						Acu_clear_in_ret_code = (Acu_clear_in_network_cause == tmp_cause) ?
												ACURC_BUSY : ACURC_HUNGUP;

							/* Store the received UUI if any */

#						if CC_UUI == ON

							Acu_clear_in_uui_size = cc_uui_size;

							if (cc_uui_size != 0) {
								Strcpy_far (Acu_clear_in_a_uui, p_cc_uui, ACU_MX_SZ_UUI+1);
							}

#						endif

#						if CC_SUPP_SERVICES == ON

							if (Sup_services_used == ON) {
								Acu_clear_in_facility_size = cc_facility_size;

								if (cc_facility_size != 0) {
									Memcpy_far (Acu_clear_in_a_facility, p_cc_facility, cc_facility_size);
								}
							}

#						endif

#						if CC_PAR_CHARGING_INFO == ON
							Acu_clear_in_charging_type	= cc_charging_type;
							Acu_clear_in_charging_period= cc_charging_period;
							Acu_clear_in_charging_multi	= cc_charging_multi;
							Acu_clear_in_charging		= cc_charging;
#						else
							Acu_clear_in_charging_type	= ACU_BYTE_VAL_NIL;
#						endif

						cc_store_display (Acu_clear_in_a_display_list, Acu_clear_in_a_display);

						cc_store_progress_ind (&Acu_clear_in_ progress_ind);

#						if CC_PAR_SIGNAL_IE == ON
							Acu_clear_in_signal_val = cc_signal_val;
#						endif

#						if ACU_PAR_EXTENDED_PRIM == ON
							cc_store_ext_data_in_acu_prim (p_data, Acu_clear_in_a_end_strings);
#						endif

						cc_snd_to_user  (ACU_CLEAR_IN);
						break;

#				  endif

				}

				Cc_set_state (STATE_RELEASE_IN);
			}

			return (STOP);

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     NS_CLEAR_CO                       */
			/*                                                       */
			/*-------------------------------------------------------*/

		case Event (NS_SAPI_SIG, NS_CLEAR_CO) :

			cc_read_cause_from_ns (NS_CLEAR_CO);

#			if CC_UUI == ON
				cc_read_uui_from_ns (NS_CLEAR_CO);
#			endif

				/*--------------------------*/
				/* Get facility information */
				/*--------------------------*/

#			if CC_SUPP_SERVICES == ON

				cc_read_facility_from_ns (NS_CLEAR_CO);

#			else

#				if _ACU_PAR_EXT_FACILITY == ON
					cc_read_ext_facility_from_ns (NS_CLEAR_CO);
#				endif

#			endif

				/*--------------------------*/
				/* Get charging information */
				/*--------------------------*/

#			if CC_PAR_CHARGING_INFO == ON
				cc_read_charging_value_from_ns (NS_CLEAR_CO);
#			endif

				/*--------------------------------------------*/
				/* Build CC_HOOK_ON_CO/ACU_CLEAR_CO primitive */
				/*--------------------------------------------*/

			switch (cc_current_sapi_user) {

#			  if CC_INTERFACE == ON

				case CC_SAPI :

					if (Cc_call_state != STATE_RELEASE_NS) {

						Cc_alloc_data  (Cc_hook_on_co_size);

						if (cc_cause != 0xFF) {
							Cc_hook_on_co_cause_class = cc_cause_class;
							Cc_hook_on_co_cause_val   = cc_cause_val;

						} else {

							Cc_hook_on_co_cause_class = BYTE_VAL_NIL;
						}

						cc_snd_to_user (CC_HOOK_ON_CO);
					}

					Cc_call_clear  ();
					break;

#			  endif

#			  if ACU_INTERFACE == ON

				case ACU_SAPI :

					switch (Cc_call_state) {

						case STATE_RELEASE_NS : /* no ACU_CLEAR_CO */

#							if (CC_SPF_FAC == ON)

									/*
										Deflection service rejected : release
										the deflection facility condition.
									*/

								if (Spf_fac_used == ON) {

									if (Cc_na_network != cc_tr6) {

										if (cc_cause != C_v_user (C_C_NORMAL_EVENT, C_V_NORMAL_CLEARING_16)) {
											Cc_na_deflection_flag = OFF;
										}

									} else {

										if (cc_cause != C_v_user (C_C_011, C_V_CALL_REJECTED)) {
											Cc_na_deflection_flag = OFF;
										}
									}

								}

#							endif

							Cc_call_clear ();
							break;

#						if CC_SUSPEND_RESUME == ON

							case STATE_RESUME_RQ :  /* Resume reject */

								if (Suspend_resume_used == ON) {
									Acu_alloc_data (Acu_resume_size +
													cc_display_total_size);
									Acu_resume_ret_code = NOK;

									cc_store_display (Acu_resume_a_display_list, Acu_resume_a_display);

									cc_snd_to_user (ACU_RESUME_CO);
									Cc_call_clear ();
								}

								break;

#						endif

#						if CC_OVERLAP_RECEIVING == ON

							case STATE_AWAIT_DIGIT :
								Cc_call_clear  ();
								break;

#						endif

						default : /* send ACU_CLEAR_CO */

#							if CC_OVERLAP_RECEIVING == ON

								if ((Cc_call_state == STATE_RELEASE_IN) &&
									(Cc_call_previous_state == STATE_AWAIT_DIGIT)) {

									Cc_call_clear ();
									return (STOP);
								}

#							endif

							Acu_alloc_data (Acu_clear_co_size +
											cc_uui_size +
											cc_facility_size +
											cc_i_ext_lgth);

#							if CC_UUI == ON

								if (Uui_used == ON) {

									Acu_clear_co_uui_size = cc_uui_size;

									if (cc_uui_size != 0) {
										Strcpy_far (Acu_clear_co_a_uui, p_cc_uui, ACU_MX_SZ_UUI+1);
									}

								}

#							endif

#							if CC_SUPP_SERVICES == ON

								if (Sup_services_used == ON) {

										/* Store facility IE if present */

									Acu_clear_co_facility_size = cc_facility_size;

									if (cc_facility_size != 0) {
										Memcpy_far (Acu_clear_co_a_facility, p_cc_facility, cc_facility_size);
									}
								}

#							endif

							if (cc_cause != 0xFF) {
								Acu_clear_co_network_cause =
								network_cause              = cc_cause;

							} else {

								Acu_clear_co_network_cause =
								network_cause              = Cc_call_clear_cause;
							}

							tmp_cause = (Cc_na_network != cc_tr6) ?
									C_v_user (C_C_NORMAL_EVENT, C_V_USER_BUSY_17) :
									C_v_user (C_C_011, C_V_USER_BUSY);

							if (network_cause == tmp_cause) {
								Acu_clear_co_ret_code = ACURC_BUSY;

							} else {

								Acu_clear_co_ret_code = ((network_cause == C_v_user (C_C_DATA_LINK_FAILURE, C_V_DL_RELEASE)) ||
														 (network_cause == C_v_user (C_C_NA_FAILURE, C_V_NA_DISCONNECTED))) ?
														ACURC_NOLINE : ACURC_HUNGUP;
							}


#							if ARINC_NETWORKS == ON
								cc_read_credit_card_status_from_ns (NS_CLEAR_CO);
#							endif

#							if CC_PAR_CHARGING_INFO == ON
								Acu_clear_co_charging_type	= cc_charging_type;
								Acu_clear_co_charging_period= cc_charging_period;
								Acu_clear_co_charging_multi	= cc_charging_multi;
								Acu_clear_co_charging		= cc_charging;
#							else
								Acu_clear_co_charging_type	= ACU_BYTE_VAL_NIL;
#							endif

#							if ARINC_NETWORKS == ON
								Acu_clear_co_credit_card_status = cc_credit_card_status;
#							endif

							cc_store_display (Acu_clear_co_a_display_list, Acu_clear_co_a_display);

#							if ACU_PAR_EXTENDED_PRIM == ON
								cc_store_ext_data_in_acu_prim (p_data, Acu_clear_co_a_end_strings);
#							endif

							cc_snd_to_user (ACU_CLEAR_CO);
							Cc_call_clear ();

							break;
					}

					break;

#			  endif

			}

			return (STOP);

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     NS_INFO_IN                        */
			/*                                                       */
			/*-------------------------------------------------------*/

		case Event (NS_SAPI_SIG, NS_INFO_IN) :

			switch (cc_current_sapi_user) {

#			  if CC_INTERFACE == ON

				case CC_SAPI :
					cc_retransmit_to_user (CC_INFO_IN);
					break;
#			  endif

#			  if ACU_INTERFACE == ON

				case ACU_SAPI :

#					if ARINC_NETWORKS == ON

						if (((Cc_na_network == cc_a11) || (Cc_na_network == cc_a17)) &&
							(Cc_call_state == STATE_ACTIVE)) {

							if (Net_get_ie (NS_INFO_IN, IE_DTMF_2_DIALING) == PRESENT) {

								Acu_alloc_data	(Acu_digit_in_size);

								Acu_digit_in_dtmf_digit 	= Net_isdn_get_val (NS_INFO_IN, IE_DTMF_2_DIALING, FLD_DTMF_DIGIT);
								Acu_digit_in_up_down 		= Net_isdn_get_val (NS_INFO_IN, IE_DTMF_2_DIALING, FLD_UP_DOWN_FLAG);
								Acu_digit_in_dtmf_duration	= Net_isdn_get_val (NS_INFO_IN, IE_DTMF_2_DIALING, FLD_DTMF_DURATION);
								cc_snd_to_user (ACU_DIGIT_IN);
							}

						}

						cc_read_credit_card_status_from_ns (NS_INFO_IN);

						cc_nats_avail 			=
						cc_satcom_avail 		=
						cc_tfts_avail 			=
						cc_nats_pos 			=
						cc_satcom_pos 			=
						cc_tfts_pos 			= 0xff;

						if (Net_get_ie (NS_INFO_IN, IE_QUEUE_INFO) == PRESENT) {
							 cc_nats_avail 		= Net_isdn_get_val (NS_INFO_IN, IE_QUEUE_INFO, FLD_NATS_AVAIL);
							 cc_satcom_avail 	= Net_isdn_get_val (NS_INFO_IN, IE_QUEUE_INFO, FLD_SATCOM_AVAIL);
							 cc_tfts_avail 		= Net_isdn_get_val (NS_INFO_IN, IE_QUEUE_INFO, FLD_TFTS_AVAIL);
							 cc_nats_pos 		= Net_isdn_get_val (NS_INFO_IN, IE_QUEUE_INFO, FLD_NATS_POS);
							 cc_satcom_pos 		= Net_isdn_get_val (NS_INFO_IN, IE_QUEUE_INFO, FLD_SATCOM_POS);
							 cc_tfts_pos 		= Net_isdn_get_val (NS_INFO_IN, IE_QUEUE_INFO, FLD_TFTS_POS);
						}

#					endif

#					if CC_PAR_CHARGING_INFO == ON
						cc_read_charging_value_from_ns (NS_INFO_IN);
#					endif

					if (Overlap_rcv_used == ON) {

						if ((Cc_call_state == STATE_RINGING) ||
							(Cc_call_state == STATE_AWAIT_DIGIT)) {
							return (CONTINUE);
						}

						if (Cc_call_previous_state == STATE_AWAIT_ADDITIONAL_DIGIT) {
							return (STOP);
						}

					}

#					if (CC_PAR_KEYPAD_IE == ON) && (EQUIPMENT == NT2)
						cc_read_keypad_from_ns (NS_INFO_IN);
#					endif

#					if ARINC_NETWORKS == ON
						cc_read_credit_card_nb_from_ns (NS_INFO_IN);
#					endif

#					if _CC_SPID_INFO == ON
						cc_read_spid_from_ns (NS_INFO_IN);
#					endif

					Acu_alloc_data (Acu_information_size +
									cc_display_total_size +
									cc_keypad_size +
									cc_track_1_size +
									cc_track_2_size +
                                    cc_spid_size);

						/* End of conference */

					Acu_information_end_of_three_party 	= OFF;

#					if (CC_SPF_FAC == ON)

						if (Spf_fac_used == ON) {

							if (Net_get_ie (NS_INFO_IN, IE_SPF_FAC) == PRESENT) {

									/* Conferencing ? */

								if ((Net_isdn_get_val (NS_INFO_IN, IE_SPF_FAC, FLD_ACTION) == FT_SPF_FAC_CO_ACK) &&
									(Net_isdn_get_val (NS_INFO_IN, IE_SPF_FAC, FLD_CODE)   == FT_SPF_FAC_THREE_PARTY)) {
									Acu_information_end_of_three_party 	= ON;
								}

							}

						}

#					endif

					cc_store_display (Acu_information_a_display_list, Acu_information_a_display);

#					if (CC_PAR_KEYPAD_IE == ON) && (EQUIPMENT == NT2)

						if (cc_keypad_size != 0) {
							Acu_information_keypad_size = cc_keypad_size;
							Memcpy_far (Acu_information_a_keypad, p_cc_keypad, cc_keypad_size + 1);
						}

#					endif

#					if ARINC_NETWORKS == ON

						Acu_information_credit_card_status 	= cc_credit_card_status;
						Acu_information_nats_avail			= cc_nats_avail;
						Acu_information_satcom_avail		= cc_satcom_avail;
						Acu_information_tfts_avail			= cc_tfts_avail;
						Acu_information_nats_pos			= cc_nats_pos;
						Acu_information_satcom_pos			= cc_satcom_pos;
						Acu_information_tfts_pos			= cc_tfts_pos;

						Acu_information_track_1_size 		= cc_track_1_size;
						Acu_information_track_2_size 		= cc_track_2_size;

						if (cc_track_1_size != 0) {
							Memcpy_far (Acu_information_a_track_1, p_cc_track_1, cc_track_1_size+1);
						}

						if (cc_track_2_size != 0) {
							Memcpy_far (Acu_information_a_track_2, p_cc_track_2, cc_track_2_size+1);
						}

#					endif

#					if CC_PAR_CHARGING_INFO == ON
						Acu_information_charging_type	= cc_charging_type;
						Acu_information_charging_period = cc_charging_period;
						Acu_information_charging_multi	= cc_charging_multi;
						Acu_information_charging		= cc_charging;
#					else
						Acu_information_charging_type	= ACU_BYTE_VAL_NIL;
#					endif

#					if _CC_SPID_INFO == ON

                        if (cc_spid_size != 0) {
                            cc_current_sapi_user		= ACU_SAPI_MGT;
                            cc_current_conn_id			= CONN_ID_NIL;
                            Acu_information_ces 		= cc_ces;
                            Acu_information_spid_size 	= cc_spid_size;

                            Strcpy_far ((char FAR *)Acu_information_a_spid, (char FAR *)p_spid, cc_spid_size + 1);
                        }

#					endif

					cc_snd_to_user (ACU_INFORMATION_IN);
					break;
#			  endif
			}
			return (STOP);

				/*-------------------------------------------------------*/
				/*                                                       */
				/*                    ACU_INFORMATION_RQ                 */
				/*                                                       */
				/*-------------------------------------------------------*/

#		if ACU_INTERFACE == ON

			case Event (ACU_SAPI, ACU_INFORMATION_RQ) :

#			if ARINC_NETWORKS == ON

				if (Cc_na_network == cc_a17) {

						/* ARINC A17 only */

					cc_dtmf_digit 			= 0xff;
					cc_credit_card_status	= Acu_information_credit_card_status;
					cc_nats_avail			= Acu_information_nats_avail;
					cc_satcom_avail			= Acu_information_satcom_avail;
					cc_tfts_avail			= Acu_information_tfts_avail;
					cc_nats_pos				= Acu_information_nats_pos;
					cc_satcom_pos			= Acu_information_satcom_pos;
					cc_tfts_pos				= Acu_information_tfts_pos;

						/* Strore credit card tracks information */

					if ((cc_track_1_size = Acu_information_track_1_size) != 0) {

							/* Take transmitted values */

						p_cc_track_1 = Acu_information_a_track_1;
					}

					if ((cc_track_2_size = Acu_information_track_2_size) != 0) {

							/* Take transmitted values */

						p_cc_track_2 = Acu_information_a_track_2;
					}

					cc_snd_to_ns (NS_INFO_RQ);

					return (STOP);	/* end of processing */
				}

#			endif

				/* continue processing in the state-driven state-machine */

			return (CONTINUE);

#		endif

#		if (ACU_INTERFACE == ON) && (_CC_SPID_INFO == ON)

			case Event (ACU_SAPI_MGT, ACU_INFORMATION_RQ) :

				if (Cc_na_function == FG_NT_TE) {
                    cc_ces 				= Acu_information_ces;
                    cc_usid 			= Acu_information_usid;
                    cc_tid 				= Acu_information_tid;
                    cc_interpreter		= Acu_information_interpreter;
                    cc_endpoint_action	= Acu_information_endpoint_action;
                    cc_current_conn_id	= CONN_ID_MANAGEMENT;

					cc_error_class = BYTE_VAL_NIL;

                    switch (cc_endpoint_action) {

						case ACU_ACTION_NO_SPID_NEGOTIATION :
                        	cc_error_class = C_C_PROTOCOL_ERROR;
                        	cc_error_value = C_V_NON_EXISTENT_IE_99;
                            break;

                        case ACU_ACTION_INVALID_SPID :
                        	cc_error_class = C_C_PROTOCOL_ERROR;
                        	cc_error_value = C_V_INVALID_IE_CONTENT_100;
                            break;
					}

                   	cc_snd_to_ns (NS_INFO_RQ);
                }

            	return (STOP);
#		endif

#		if (ACU_INTERFACE == ON) && (CC_SPF_FAC == ON) && (CC_ATT_HCDT == ON)

			case Event (NS_SAPI_SIG, NS_SPF_FACILITY_CO) :

				if ((Att_hcdt_fac_used  == ON) &&
					(cc_current_conn_id == CONN_ID_MANAGEMENT)) {
					Acu_alloc_data				(Acu_facility_size);

					Acu_facility_call_appear 	= Net_isdn_get_val (NS_SPF_FACILITY_CO, IE_SEL_CALL_APPEAR, FLD_CALL_APPEAR);
					Acu_facility_code 			= ACU_FAC_CALL_APPEAR;
					Acu_facility_action 		= ACU_CO_ACK;
					Acu_facility_network_cause 	= 0;

					cc_current_ent_user			= Cc_na_ent_user (0);
					cc_current_sapi_user		= ACU_SAPI_MGT;

					cc_snd_to_user (ACU_FACILITY_CO);

					return (STOP);
				}

				return (CONTINUE);

#		endif

				/*-------------------------------------------------------*/
				/*                                                       */
				/*                     NS_FAC_IN                         */
				/*                                                       */
				/*-------------------------------------------------------*/

#		if (ACU_INTERFACE == ON) && (ACU_PAR_EXTENDED_PRIM == ON)

			case Event (NS_SAPI_SIG, NS_FAC_IN) :

					/* Get extended facility */

#				if CC_SUPP_SERVICES == OFF

#					if _ACU_PAR_EXT_FACILITY == ON
						cc_read_ext_facility_from_ns (NS_FAC_IN);
#					endif

#				endif

				Acu_alloc_data (Acu_facility_size +
								cc_i_ext_lgth);

#				if ACU_PAR_EXTENDED_PRIM == ON
					cc_store_ext_data_in_acu_prim (p_data, Acu_facility_a_end_strings);
#				endif

				Acu_facility_code   = ACU_FAC_TRANSPARENT;
				Acu_facility_action = ACU_IN_TX;

				cc_snd_to_user (ACU_FACILITY_IN);

				return (STOP);

#		endif

				/*-------------------------------------------------------*/
				/*                                                       */
				/*                     NS_FAC_CO                         */
				/*                                                       */
				/*-------------------------------------------------------*/

#		if (ACU_INTERFACE == ON) && (CC_SUPP_SERVICES == ON)

			case Event (NS_SAPI_SIG, NS_FAC_CO) :

				if (Sup_services_used == OFF) return (STOP);

					/* Get called_nb IE  */

				cc_read_called_nb_from_ns (NS_FAC_CO);

					/* Called sub address is never provided by NS in that message */

				cc_build_address ((char FAR *)p_called_nb, (char FAR *)P_NIL, Acu_conn_in_a_called_nb);

				cc_read_facility_from_ns (NS_FAC_CO);

				if (Net_get_ie (NS_FAC_CO, IE_CALLING_NB) == PRESENT) {
					calling_nb_size = Net_isdn_lgth_str (NS_FAC_CO, IE_CALLING_NB);
					p_calling_address = (char FAR *)Net_isdn_p_str (NS_FAC_CO, IE_CALLING_NB);

				} else {

					calling_nb_size		= 0;
					p_calling_address	= P_NIL;
				}

				Acu_alloc_data (Acu_facility_size +
								cc_facility_size +
								calling_nb_size +
								cc_display_total_size);

				Acu_facility_facility_size		= cc_facility_size;
				Acu_facility_calling_nb_size	= calling_nb_size;

				if (cc_facility_size != 0) {
					Memcpy_far (Acu_facility_a_facility, p_cc_facility, cc_facility_size);
				}

				if (calling_nb_size !=  0) {
					Strcpy_far (Acu_facility_a_calling_nb,	(char FAR *)p_calling_address,	ACU_MX_SZ_CALLING_NB+1);
				}

				cc_store_display (Acu_facility_a_display_list, Acu_facility_a_display);

					/* Send response to user */

				cc_current_ent_user		= Cc_na_ent_user (0);
				cc_current_sapi_user	= (cc_current_conn_id == CONN_ID_MANAGEMENT ? ACU_SAPI_MGT : ACU_SAPI);

				cc_snd_to_user (ACU_FACILITY_CO);

				return (STOP);

#		endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     CC_HOOK_ON_RQ                     */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if CC_INTERFACE == ON

		case Event (CC_SAPI, CC_HOOK_ON_RQ) :

			cc_error_class	= (Cc_na_network == cc_tr6) ? C_C_000 : C_C_NORMAL_EVENT;
			cc_error_value	= C_V_NORMAL_CLEARING_16;

#			if CC_UUI == ON

				if (Uui_used == ON) {

					if (Cc_call_uui_rq == ON) {
						p_cc_uui = (char FAR *)Cc_hook_on_rq_a_uui;
					}

				}

#			endif

			cc_snd_to_ns	(NS_CLEAR_RQ);
			Cc_set_state	(STATE_RELEASE_RQ);
			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                   CC_USER_BUSY_RQ                     */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if CC_INTERFACE == ON

		case Event (CC_SAPI, CC_USER_BUSY_RQ) :

			if (Cc_call_state == STATE_NULL) {
				Cc_call_state = STATE_OUT_OF_ORDER;
			}
			cc_retransmit_to_user	(CC_USER_BUSY_CO);
			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                 CC_USER_CLEAR_BUSY_RQ                 */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if CC_INTERFACE == ON

		case Event (CC_SAPI, CC_USER_CLEAR_BUSY_RQ) :

			if (Cc_call_state == STATE_OUT_OF_ORDER) {
				Cc_call_state = STATE_NULL;
			}

			cc_retransmit_to_user	(CC_USER_CLEAR_BUSY_CO);
			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     ACU_CLEAR_RQ                      */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI, ACU_CLEAR_RQ) :

			if (Acu_clear_rq_cause == 0) {

				cc_error_class	= (Cc_na_network == cc_tr6) ? C_C_000 : C_C_NORMAL_EVENT;
				cc_error_value	= C_V_NORMAL_CLEARING_16;

			} else {

					/* Cause value given by User */

				cc_error_class		= Get_bits (Acu_clear_rq_cause, 4, 3);
				cc_error_value		= Get_bits (Acu_clear_rq_cause, 0, 4);
			}

			Cc_call_clear_cause		= C_v_user (cc_error_class, cc_error_value);

#			if CC_UUI == ON

				if (Uui_used == ON) {

					if ((Cc_call_uui_rq == ON) && (Acu_clear_rq_uui_size != 0)) {
						p_cc_uui	= Acu_clear_rq_a_uui;
					}

				}

#			endif

				/* Get display IE contents if present */

			cc_read_display_from_acu (Acu_clear_rq_a_display_list);

#			if CC_SUPP_SERVICES == ON

				if (Sup_services_used == ON) {
					cc_facility_size = Acu_clear_rq_facility_size;

					if (Acu_clear_rq_facility_size != 0) {
						p_cc_facility = Acu_clear_rq_a_facility;
					}
				}

#			endif

#			if CC_PAR_SIGNAL_IE == ON
				cc_signal_val = Acu_clear_rq_signal_val;
#			endif

#			if ACU_PAR_EXTENDED_PRIM == ON
				cc_read_ext_parms_from_acu (p_data);
#			endif

			cc_snd_to_ns	(NS_CLEAR_RQ);
			Cc_set_state	(STATE_RELEASE_RQ);
			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     ACU_SETPARM_RQ                    */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI, ACU_SETPARM_RQ) :

				/* Send back an ACU_SETPARM_CO primitive */

			Acu_alloc_data (Acu_setparm_co_size);
			cc_snd_to_user (ACU_SETPARM_CO);
			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     ACU_INIT_RQ                       */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI, ACU_INIT_RQ) :
			cc_current_ent_user				= Acu_init_rq_new_user;
			cc_current_sapi_user			= Acu_init_rq_new_sapi;

				/* Send back an ACU_INIT_CO primitive */

			Acu_alloc_data (Acu_init_co_size);

			switch (cc_current_sapi_user) {

				case CC_SAPI  :
				case ACU_SAPI :
					Cc_na_ent_user  (0)		= cc_current_ent_user;
					Cc_na_sapi_user (0)		= cc_current_sapi_user;
					Acu_init_co_ret_code	= OK;
					break;

				default :
					Acu_init_co_ret_code	= NOK;
					Acu_init_co_diagnostic	= cc_current_sapi_user;
					break;
			}

			cc_snd_to_user (ACU_INIT_CO);
			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     ACU_INFO_RQ                       */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI, ACU_INFO_RQ) :

				/* ignored */

			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*           ACU_FACILITY_RQ (call-related)              */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI, ACU_FACILITY_RQ) :

#			if CC_SPF_FAC == ON

				if (Spf_fac_used == ON) {

					if (Acu_facility_code == ACU_FAC_RECALL) {
						p_rq_address = P_NIL;
						Acu_facility_network_cause = ACU_NETWORK_CAUSE_NIL;
						Acu_facility_action = ACU_CO_ACK;

						cc_snd_to_ns (NS_INFO_RQ);

						cc_retransmit_to_user (ACU_FACILITY_CO);
						return (STOP);
					}

				}

#			endif

				/* Get display IE contents if present */

			cc_read_display_from_acu (Acu_facility_a_display_list);

#			if ACU_PAR_EXTENDED_PRIM == ON
				cc_read_ext_parms_from_acu (p_data);

				if (cc_ext_fac_asn1_lgth != 0) {
					cc_snd_to_ns (NS_FAC_RQ);	/* with ASN1 facility */
					return (STOP);
				}

#			endif

			return (CONTINUE);

#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*           ACU_FACILITY_RQ (not call-related)          */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI_MGT, ACU_FACILITY_RQ) :

			Acu_facility_network_cause 	= ACU_NETWORK_CAUSE_NIL;
			cc_spf_facility_action     	= Acu_facility_action;
			Acu_facility_action        	= ACU_CO_REJ;
			Acu_facility_x_display_nb	= 0;

#			if CC_SUPP_SERVICES == ON

				if ((Sup_services_used == ON) && (Acu_facility_code == ACU_FAC_TRANSPARENT)) {

					if ((cc_facility_size = Acu_facility_facility_size) != 0) {
						p_cc_facility	= Acu_facility_a_facility;
					}

					p_rq_address 		= Acu_facility_a_called_address;
					cc_decode_address ((char FAR *FAR *)&p_rq_address, (char FAR *FAR *)&p_rq_subaddress);


						/* Get calling nb/sub-address */

					if (Acu_facility_calling_nb_size != 0) {

							/* Take transmitted values */

						p_calling_address = Acu_facility_a_calling_nb;
						cc_decode_address ((char FAR *FAR *)&p_calling_address, (char FAR *FAR *)&p_calling_subaddress);

					} else {

							/* Take configuration fields if not empty */

						p_calling_address    = (char FAR *)Cc_na_a_calling_nb;

						if (p_calling_address[0] == '\0') {
							p_calling_address = P_NIL;
						}

						p_calling_subaddress = (char FAR *)Cc_na_a_calling_sub_add;

						if (p_calling_subaddress[0] == '\0') {
							p_calling_subaddress = P_NIL;
						}

					}

					cc_current_conn_id = CONN_ID_MANAGEMENT;
					cc_snd_to_ns (NS_FAC_RQ);

					return (STOP);
				}

#			endif

#			if CC_SPF_FAC == ON

				if (Spf_fac_used == ON) {

					switch ((cc_spf_facility_code = Acu_facility_code)) {

						case ACU_FAC_CALL_DEFLECTION :

							switch (cc_spf_facility_action) {

								case ACU_RQ_ACTIVATE :
									p_rq_address 		= Acu_facility_a_called_address;
									p_rq_subaddress 	= "";
									cc_decode_address ((char FAR *FAR *)&p_rq_address, (char FAR *FAR *)&p_rq_subaddress);

									Strcpy_far ((char FAR *)Cc_na_deflection_address, p_rq_address, ACU_MX_SZ_CALLED_NB+1);
									Strcpy_far ((char FAR *)Cc_na_deflection_subaddress, p_rq_subaddress, ACU_MX_SZ_CALLED_SUB_ADD+1);

									Cc_na_deflection_flag 	= ON;
									Acu_facility_action 	= ACU_CO_ACK;
									break;

								case ACU_RQ_CLEAR :

									if (Cc_na_deflection_flag == ON) {
										Cc_na_deflection_flag = OFF;
										Acu_facility_action = ACU_CO_ACK;
									}
									break;

								case ACU_RQ_ENQUIRY :

									if (Cc_na_deflection_flag == ON) {
										cc_build_address ((char FAR *)Cc_na_deflection_address,
														  (char FAR *)Cc_na_deflection_subaddress,
														  Acu_facility_a_called_address);
										Acu_facility_action = ACU_CO_ACK;

									} else {

										*Acu_facility_a_called_address = '\0';
									}

									break;
							}

							break;

#						if CC_ATT_HCDT == ON

							case ACU_FAC_CALL_APPEAR :
							case ACU_FAC_FEATURE_ACT :

								if (Att_hcdt_fac_used == ON) {
									cc_button_type		= Acu_facility_button_type;
									cc_module_nb		= Acu_facility_module_nb;
									cc_button_nb		= Acu_facility_button_nb;
									cc_switchhook		= Acu_facility_switchhook;

									cc_current_conn_id 	= CONN_ID_MANAGEMENT;

									cc_snd_to_ns (NS_INFO_RQ);

									return (STOP);
								}

#						endif

					}
				}


#			endif

			cc_retransmit_to_user (ACU_FACILITY_CO);

			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                     ACU_TEST_RQ                       */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI_MGT, ACU_TEST_RQ) :

			if (Acu_test_code == ACU_TEST_B_CHAN_LOOP_BACK) {

				Cc_access_b_chan (Acu_test_b_chan_loop_back_nb);

				switch (Acu_test_action) {

					case ACU_RQ_ACTIVATE :

						if (Cc_b_chan_mode != B_MODE_LOOP_BACK_ON) {
							cc_b_switch (Acu_test_b_chan_loop_back_nb, B_MODE_LOOP_BACK_ON, B_AUDIO_TONE_NIL);
							Acu_test_action 		= ACU_CO_ACK;
							Acu_test_response_code	= ON;	/* B channel looped back */

						} else {

							Acu_test_action			= ACU_CO_REJ;
						}
						break;

					case ACU_RQ_CLEAR :

						if (Cc_b_chan_mode == B_MODE_LOOP_BACK_ON) {
							cc_b_switch (Acu_test_b_chan_loop_back_nb, B_MODE_LOOP_BACK_OFF, B_AUDIO_TONE_NIL);
							Acu_test_action			= ACU_CO_ACK;
							Acu_test_response_code	= OFF;	/* B channel un-looped back */

						} else {

							Acu_test_action			= ACU_CO_REJ;
						}
						break;

					case ACU_RQ_ENQUIRY :

						if (Cc_b_chan_mode == B_MODE_LOOP_BACK_ON) {
							Acu_test_response_code	= ON;

						} else {

							Acu_test_response_code	= OFF;
						}

						Acu_test_action = ACU_CO_ACK;
						break;
				}

				cc_retransmit_to_user (ACU_TEST_CO);

			}

			return (STOP);
#	  endif

			/*-------------------------------------------------------*/
			/*                                                       */
			/*                   ACU_SET_MODE_RQ                     */
			/*                                                       */
			/*-------------------------------------------------------*/

#	  if ACU_INTERFACE == ON

		case Event (ACU_SAPI_MGT, ACU_SET_MODE_RQ) :

			action_code = ACU_CO_REJ;

#			if CC_USE_ACU_SET_MODE_RQ_CO == ON

				switch (Acu_set_mode_code) {

						/*-------------------------------*/
						/*  ACU_MODE_ALL_NA_OUT_OF_ORDER */
						/*-------------------------------*/

					case ACU_MODE_ALL_NA_OUT_OF_ORDER:

							/* allow/forbid calls on NAI */

						action_code = ACU_CO_ACK;

						cc_access_first_na ();

						while (p_cc_na != P_NIL) {

							switch (Acu_set_mode_action) {

								case ACU_RQ_ACTIVATE :
									Cc_na_state = STATE_OUT_OF_ORDER;
									break;

								case ACU_RQ_CLEAR :
									Cc_na_state = STATE_ACTIVE;
									break;

								case ACU_RQ_ENQUIRY :

									if (Cc_na_state != STATE_OUT_OF_ORDER) {
										action_code = ACU_CO_REJ;
									}
									break;

							}

							cc_access_next_na ();

						}

						break;

						/*---------------------------*/
						/*  ACU_MODE_NA_OUT_OF_ORDER */
						/*---------------------------*/

					case ACU_MODE_NA_OUT_OF_ORDER:

							/* allow/forbid calls on NAI */

						if (cc_access_na (cc_current_nai) == NOK) {
							break;
						}

						switch (Acu_set_mode_action) {

							case ACU_RQ_ACTIVATE :
								Cc_na_state = STATE_OUT_OF_ORDER;
								action_code = ACU_CO_ACK;
								break;

							case ACU_RQ_CLEAR :
								Cc_na_state = STATE_ACTIVE;
								action_code = ACU_CO_ACK;
								break;

							case ACU_RQ_ENQUIRY :

								if (Cc_na_state == STATE_OUT_OF_ORDER) {
									action_code = ACU_CO_ACK;
								}
								break;
						}

						break;

						/*----------------------------*/
						/* ACU_MODE_CALL_OUT_OF_ORDER */
						/*----------------------------*/

					case ACU_MODE_CALL_OUT_OF_ORDER:

							/* allow/forbid calls on NAI/CONN_ID */

						if ((cc_access_na (cc_current_nai) == NOK) ||
							(cc_access_conn_id (cc_current_conn_id) == NOK)) {
							break;
						}

						switch (Acu_set_mode_action) {

							case ACU_RQ_ACTIVATE :

								if (Cc_call_state == STATE_NULL) {
									Cc_call_state   = STATE_OUT_OF_ORDER;
									action_code     = ACU_CO_ACK;
								}
								break;

							case ACU_RQ_CLEAR :

								if (Cc_call_state == STATE_OUT_OF_ORDER) {
									Cc_call_state   = STATE_NULL;
									action_code     = ACU_CO_ACK;
								}
								break;

							case ACU_RQ_ENQUIRY :

								if (Cc_call_state == STATE_OUT_OF_ORDER) {
									action_code     = ACU_CO_ACK;
								}

								break;
						}

						/*-----------------------------*/
						/* ACU_MODE_CHANI_OUT_OF_ORDER */
						/*-----------------------------*/

					case ACU_MODE_CHANI_OUT_OF_ORDER:

							/* allow/forbid usage of a B-channel */

						if ((Acu_set_mode_data_chani > Cc_na_nb_b_chan) ||
							(Acu_set_mode_data_chani == 0)) {
							break;
						}

						Cc_access_b_chan (Acu_set_mode_data_chani);

						switch (Acu_set_mode_action) {

							case ACU_RQ_ACTIVATE :

								if (Cc_b_chan_used == CC_B_CHAN_FREE) {
									Setbit (Cc_b_chan_used, CC_B_CHAN_USED);
									action_code     = ACU_CO_ACK;
								}
								break;

							case ACU_RQ_CLEAR :

								if (Cc_b_chan_used != CC_B_CHAN_FREE) {
									Cc_b_chan_used          = CC_B_CHAN_FREE;
									Cc_b_chan_p_active_call =
									Cc_b_chan_p_held_call   = P_NIL;
									action_code             = ACU_CO_ACK;
								}
								break;

							case ACU_RQ_ENQUIRY :

								if (Cc_b_chan_used != CC_B_CHAN_FREE) {
									action_code     = ACU_CO_ACK;
								}

								break;
						}

						break;

				}

#			endif

			Acu_set_mode_action = action_code;
			cc_retransmit_to_user (ACU_SET_MODE_CO);

			return (STOP);

#	  endif


		default :
			return (CONTINUE);

	}

	return (STOP);

}

/*EOF*/
