/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - cc_proc.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *      cc_error_process - process an error occured in CC.
 *      cc_set_ns_error  - sets an error to be sent to NS.
 *      cc_set_cc_error  - sets an error to be sent to CC.
 *      cc_set_acu_error - sets an error to be sent to ACU.
 *
 *      cc_call_clear    - clears the current call context.
 *      cc_set_state     - changes current call's state.
 *
 *		cc_retrieve_previous_state - retrieves back the previous call state
 *							after an error processing.
 *
 *		get_p_cc_service - gets the pointer to the service description
 *
 *		cc_service_to_class - converts a CC service id into an class.
 *
 *      cc_reset_temp_layer_1_info    - reset temporary layer 1 info structure
 *      cc_reset_call_layer_1_info    - reset call context's layer 1 info
 *      cc_get_layer_1_info_from_msg  - copy the received layer 1 info
 *                         into the call context
 *      cc_put_layer_1_info_from_temp - copy layer 1 info from temporary
 *                         to ACU primitive and to call context.
 *
 *      cc_read_cause_from_ns - read cause IE from an incoming NS message.
 *
 *      cc_read_called_nb_from_ns - read CALLED_NB IE info from an incoming NS message.
 *
 *      cc_read_called_sub_add_from_ns - read called_sub_add IE info from an incoming NS message.
 *
 *      cc_read_display_from_ns - read display IE info from an incoming NS message.
 *
 *      cc_read_display_from_acu - read display info from an incoming ACU message.
 *
 *      cc_read_uui_from_ns - read UUI info from an incoming NS message.
 *
 *      cc_read_keypad_from_ns - read keypad info from an incoming NS message.
 *
 *      cc_read_facility_from_ns - read facility info from an incoming NS message.
 *
 *      cc_read_progress_ind_from_ns - read progress_ind info from an incoming NS message (ARINC).
 *
 *      cc_read_signal_from_ns - read signal info from an incoming NS message (ARINC).
 *
 *      cc_read_credit_card_nb_from_ns - read credit_card_nb info from an incoming NS message (ARINC).
 *
 *      cc_read_chan_id_from_ns  - read channel_id and chan_sel fields from an incoming NS message.
 *
 *      cc_read_chani_list_from_acu - read+check+allocate the list of
 *                                    channels given by an ACU primitive.
 *
 *      cc_alloc_chan_list - allocate the list of channels given by an ACU primitive.
 *
 *      cc_write_call_chan_list_to_acu - write the call channels list into an
 *                                       ACU primitive.
 *
 *      cc_chani_list_to_map - convert a B-channels list into a "channels map".
 *
 *      cc_reset_call_b_chan - reset the B channels assigned to the call.
 *
 *      cc_find_free_b_chan - try to find a set of free B channels.
 *      cc_find_single_free_b_chan - try to find one free B channel.
 *      cc_alloc_b_chan
 *      cc_free_b_chan   - allocate/free a B-channel context.
 *		cc_alloc_b_chan_if_allowed - allocate a B-channel context if not already allocated.
 *
 *      cc_b_switch      - request the switching of the MAP to the B1 or B2
 *                         channel.
 *      cc_b_init_stop   - request the activation or deactivation of the B1
 *                         or B2 channel.
 *
 *      cc_snd_ced       - sends a CED to the ENT_PH_GSTN entity.
 *
 *      cc_decode_address- filter an input called or calling number address and
 *		                   subaddress
 *      cc_build_address - build an address from a called number
 *		                   or calling number address and subaddress.
 *		cc_get_net_idx	  - get current network index
 *		cc_dec_net_idx	  - decrement network index
 *		cc_get_network	  - get current network to be set in Na_network
 *      cc_build_p_table  - init of NS network table.
 *		cc_check_network  - network integrity
 *		cc_build_fct	  - build fct array
 *		cc_reset_op_idx	  - reset the opeator indexes
 *
 *		cc_restart_chan_id - implements the restart of the channel ID.
 *
 *		strcmp_reverse - compares two strings from the end of the strings.
 *
 *		cc_address_filtering - address/sub-address filtering process
 *
 *		cc_test_address_match - tests if address/sub-address matches
 *			one of the registered NA addresses.
 *
 *		cc_test_chan_id_match - tests if received B chan_id
 *			matches one of the registered NA addresses.
 *
 *		cc_read_charging_value_from_ns - get the charging IE fields.
 *
 *		cc_read_date_time_from_ns - get the 'Date_time' IE fields.
 *
 *		cc_read_ext_llc_from_ns - get the 'LLC' IE fields (extended ACU only).
 *
 *		cc_read_ext_facility_from_ns- read the 'Facility' IE fields (extended ACU only).
 *		cc_ext_fac_local_process -
 *		cc_ext_fac_process_op -
 *		cc_add_i_ext_fac_return_err -
 *		cc_add_i_ext_fac_reject -
 *		cc_add_i_ext_cug -
 *
 *		cc_read_cug_from_ns - read the CUG facility IE fields (extended ACU only).
 *
 *		cc_read_ext_parms_from_acu - read the extended parameters from an
 *		ACU primitive.
 *		cc_read_ext_element_from_acu -
 * 
 *		cc_read_spid_from_ns- reads SPID information.
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Call Control (CC) Entity                         |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "cc.h"
#include "isdn.h"

#if C_COMPILER == TC
#	pragma hdrstop
#endif

#include "cc_ie.h"
#include "ctx_ext.h"

#include "ph_int.h"

#include "cc_prof.h"
#include "cc_fct.h"

#if _ACU_PAR_EXT_FACILITY == ON /* { */
#if NEW_FCT_STYLE == ON
	static uchar cc_ext_fac_local_process   (uchar comp_tag, ns_ss_inv_id_t invoke_id);
	static void cc_ext_fac_process_op       (uchar comp_tag, ns_ss_inv_id_t invoke_id, ns_ss_op_id_t op_id);
#	if ACU_PAR_EXTENDED_PRIM == ON
	static void cc_add_i_ext_fac_return_err (ns_ss_inv_id_t invoke_id, ns_ss_op_id_t error_id);
	static void cc_add_i_ext_fac_reject     (uchar present, ns_ss_inv_id_t invoke_id, uchar pb_type, uchar pb_val);
#	endif
#	if ACU_PAR_EXT_CUG == ON
	static void cc_add_i_ext_cug            (ns_ss_inv_id_t invoke_id);
#	endif
#else
	static uchar cc_ext_fac_local_process   ();
	static void cc_ext_fac_process_op       ();
#	if ACU_PAR_EXTENDED_PRIM == ON
	static void cc_add_i_ext_fac_return_err ();
	static void cc_add_i_ext_fac_reject     ();
#	endif
#	if ACU_PAR_EXT_CUG == ON
	static void cc_add_i_ext_cug            ();
#endif
#endif
#endif

		/*
			The following table indicates wether the networks are
			compiled or not.
			WARNING : this table must be ordered in increasing operator
			indexes (as defined in services.h).
		*/

	CONST struct cc_net_presence T_CC_NET_PRESENCE[] = {
		Put_cc_net_presence (0,				0),
		Put_cc_net_presence (FT_VN2,		CC_F_VN2),
		Put_cc_net_presence (FT_VN3,		CC_F_VN3),
		Put_cc_net_presence (FT_VN6,		CC_F_VN6),
		Put_cc_net_presence (DT_1TR6,		CC_F_TR6),
		Put_cc_net_presence (BT_ISDN2,		CC_F_BT2),
		Put_cc_net_presence (ATT_5E5,		CC_F_AT5),
		Put_cc_net_presence (ATT_5E9,		CC_F_AT9),
		Put_cc_net_presence (NT_DMS100,		CC_F_DMS),
		Put_cc_net_presence (NTT,			CC_F_NTT),
		Put_cc_net_presence (KDD,			CC_F_KDD),
		Put_cc_net_presence (ETSI,			CC_F_ETS),
		Put_cc_net_presence (BG_V1,			CC_F_BV1),
		Put_cc_net_presence (N_ISDN1,		CC_F_NI1),
		Put_cc_net_presence (SWD_TVKT,		CC_F_SWD),
		Put_cc_net_presence (AUSTEL_1,		CC_F_AU1),
		Put_cc_net_presence (ECMA_QSIG,		CC_F_QSI),
		Put_cc_net_presence (HK_TEL,		CC_F_HKT),
		Put_cc_net_presence (DRV,			CC_F_DRV),
		Put_cc_net_presence (BELLCORE_PRI,	CC_F_BIP),
		Put_cc_net_presence (N_ISDN2,		CC_F_NI2),
		Put_cc_net_presence (CTU_CDS,		CC_F_A17),
		Put_cc_net_presence (CTU_BS,		CC_F_A11),
		Put_cc_net_presence (ATT_5E10,		CC_F_E10),
		Put_cc_net_presence (ATT_4ESS,		CC_F_AT4),
	};

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_error_process

Description     process an error occured in CC.

Usage           cc_error_process ();

Return value	none.

*--------------------------------------------------------------------------*/

void cc_error_process ()
{
#	if ACU_INTERFACE == ON
		uchar FAR *p_data;
#	endif

		/* dispatch according to error message destination */

	cc_current_ent_user		= cc_error_to;
	cc_current_sapi_user	= cc_error_sapi;

	switch (cc_error_sapi) {

			/* NS entity */

		case NS_SAPI_SIG :
#			if CC_UUI == ON
				p_cc_uui = P_NIL;
#			endif
			cc_snd_to_ns (NS_CLEAR_RQ);

			break;

			/* Application entities */

#	  if CC_INTERFACE == ON

		case CC_SAPI :
			Free_buffer (R_msg_p_buffer); R_msg_p_buffer = P_NIL;
			R_msg_inf0 		= cc_error_value;
			R_msg_data_size = INF_SIZE;
			cc_retransmit_to_user (CC_ERR_IN);
			break;
#	  endif

#	  if ACU_INTERFACE == ON

		case ACU_SAPI :
			Acu_alloc_data (Acu_clear_co_size);
			Acu_clear_co_ret_code		= cc_error_value;
			Acu_clear_co_network_cause	= ACU_NETWORK_CAUSE_NIL;
			cc_snd_to_user (ACU_CLEAR_CO);
			break;
#	  endif

		default :
			break;

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_set_ns_error

Description     sets an error to be sent to NS.

Usage           cc_set_ns_error (uchar ns_cause_class, uchar ns_cause_value);

Return value    none.

*--------------------------------------------------------------------------*/

void cc_set_ns_error (cause_class, value)
uchar cause_class;
uchar value;
{
	cc_error_class = cause_class;
	cc_error_value = value;
	cc_error_to    = ENT_NS;
	cc_error_sapi  = NS_SAPI_SIG;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_set_cc_error

Description     sets an error to be sent to CC.

Usage           cc_set_cc_error (uchar value);

Return value    none.

*--------------------------------------------------------------------------*/

#if CC_INTERFACE == ON

void cc_set_cc_error (value)
uchar value;
{
	cc_error_value = value;
	cc_error_to    = cc_current_ent_user;
	cc_error_sapi  = CC_SAPI;
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_set_acu_error

Description     sets an error to be sent to ACU.

Usage           cc_set_acu_error (uchar value);

Return value    none.

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_set_acu_error (value)
uchar value;
{
	cc_error_value = value;
	cc_error_to    = cc_current_ent_user;
	cc_error_sapi  = ACU_SAPI;
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_set_error

Description     sets an error depending on the current used sapi.

Usage           cc_set_acu_error (sapi_t sapi, uchar ns_class,
					 uchar ns_value, uchar cc_value, uchar acu_value);

					- sapi : used to determine to whom the error is to be
							 sent;
					- ns_class/ns_value : NS cause class/value;
					- cc_value  : error to be sent to CC;
					- acu_value : error to be sent to ACU.

Return value    none.

*--------------------------------------------------------------------------*/

void cc_set_error (sapi, ns_class, ns_value, cc_value, acu_value)
sapi_t	sapi;
uchar	ns_class;
uchar	ns_value;
uchar	cc_value;
uchar	acu_value;
{
	switch (sapi) {

		case NS_SAPI_SIG :
			Cc_set_ns_error (ns_class, ns_value);
			break;

#		if CC_INTERFACE == ON

			case CC_SAPI :
				Cc_set_cc_error (cc_value);
				break;

#		endif

#		if ACU_INTERFACE == ON

			case ACU_SAPI :
				Cc_set_acu_error (acu_value);
				break;

#		endif

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_call_clear

Description     clears a call context.

Usage           cc_call_clear ();

Return value    none

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

void cc_call_clear ()
{

	cc_reset_call_b_chan ();

	Cc_call_state			=
	Cc_call_previous_state	= STATE_NULL;

	Cc_call_x_current_service_list = X_DEFAULT_SERVICE_LIST;	/* default services list */

#	if CC_PAR_SEMI_PERMANENT_CIRCUITS == ON
		Cc_call_semi_permanent_circuit = OFF;
#	endif

	cc_reset_call_layer_1_info ();

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_set_state

Description     changes current call's state.

Usage           cc_set_state (uchar new_state);

Return value    none

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

void cc_set_state (new_state)
uchar new_state;
{
	Cc_call_previous_state = Cc_call_state;
	Cc_call_state          = new_state;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_retrieve_previous_state

Description     retrieves back the previous call state after an error
				processing.

Usage           cc_retrieve_previous_state ();

Return value    none

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_retrieve_previous_state ()
{
	uchar FAR *p_data;

		/* Retrieve previous call state */

	Cc_call_state = Cc_call_previous_state;

	if (Cc_call_state == STATE_NULL) {

		Acu_alloc_data (Acu_clear_co_size);
		Acu_clear_co_ret_code		= ACURC_INTERNAL;
		Acu_clear_co_network_cause	= ACU_NETWORK_CAUSE_NIL;
		cc_snd_to_user (ACU_CLEAR_CO);

		Cc_call_clear ();
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            get_p_cc_service

Description     returns the pointer to the service
				description if found in the NA services list, else
				returns P_NIL. Used for incoming calls only.

Usage           p_cc_service = get_p_cc_service (uchar check_key,
												 uchar service_id_or_class);

					uchar check_key : type of checking to be done
									  (CC_CHECK_SERVICE or CC_CHECK_CLASS);

					uchar service_id_or_class : internal service id or class,

Return value    CC service description address or P_NIL.
				p_cc_profile points to the related profile description.

Common objects	NA, CALL, PROFILE contexts.

*--------------------------------------------------------------------------*/

CONST struct cc_service FAR *get_p_cc_service (check_key, service_id_or_class)
	uchar		check_key;
	uchar		service_id_or_class;
{
	uchar		i=0;				/* index of the service in the list */
	uchar		x_services_list;	/* index of the services list */

	x_services_list	= Cc_call_x_current_service_list;

	do {

		p_cc_profile = Cc_na_p_cc_profile (x_services_list, i);

		if (p_cc_profile == P_NIL) {
			return (P_NIL);
		}

		i++;

	} while (! (((check_key == CC_CHECK_SERVICE) && (service_id_or_class == Cc_profile_service_id)) ||
				((check_key == CC_CHECK_CLASS)   && (service_id_or_class == cc_service_to_class (Cc_profile_service_id)))
			   )
			);


	return (Cc_na_p_cc_service (x_services_list, i-1));
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_service_to_class

Description     converts a CC service id into a class.

Usage           uchar service_class = cc_service_to_class  (cc_service_id);

					uchar cc_service_id : CC service id,

Return value    service class;

Common constants and declarations : acu_int.h and cc_int.h

*--------------------------------------------------------------------------*/

struct cc_service_convert {
	uchar cc_service_id;
	uchar service_class;
};

struct cc_service_convert CONST_ARRAY t_cc_service_convert[] = {
	{	CC_SERVICE_X25,					CC_SRV_CLASS_DATA},
	{	CC_SERVICE_X25_RELAY,			CC_SRV_CLASS_DATA},
	{	CC_SERVICE_X25_PACKET,			CC_SRV_CLASS_DATA},
	{	CC_SERVICE_DATA_HDLC,			CC_SRV_CLASS_DATA},
	{	CC_SERVICE_RAW_DATA,			CC_SRV_CLASS_DATA},
	{	CC_SERVICE_DATA_HDLC_RELAY,		CC_SRV_CLASS_DATA},
	{	CC_SERVICE_DATA_TRANSPARENT,	CC_SRV_CLASS_DATA},
	{	CC_SERVICE_DATA_TRANS_RELAY,	CC_SRV_CLASS_DATA},
	{	CC_SERVICE_TELEPHONY,			CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_RAW_TELEPHONY,		CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_TELEPHONY_RELAY,		CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_TELEPHONY_GCI,		CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_TELEPHONY_GCI_RELAY,	CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_AUDIO_MODEM,			CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_AUDIO_MODEM_RELAY,	CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_AUDIO_7,				CC_SRV_CLASS_DATA},
	{	CC_SERVICE_FAX_3,				CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_FAX_3_RELAY,			CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_FAX_4,				CC_SRV_CLASS_DATA},
	{	CC_SERVICE_DATA_56KBS,			CC_SRV_CLASS_DATA},
	{	CC_SERVICE_DATA_56KBS_RELAY,	CC_SRV_CLASS_DATA},
	{	CC_SERVICE_TRANSPARENT,			CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_TRANSPARENT_RELAY,	CC_SRV_CLASS_VOICE},
	{	CC_SERVICE_V110,				CC_SRV_CLASS_DATA},
	{	CC_SERVICE_V120,				CC_SRV_CLASS_DATA},
	{	CC_SERVICE_VIDEO,				CC_SRV_CLASS_DATA},
	{	CC_SERVICE_TDD,					CC_SRV_CLASS_DATA},
	{	CC_SERVICE_DATA_H0,				CC_SRV_CLASS_MULTI_CHAN},
	{	CC_SERVICE_DATA_H11,			CC_SRV_CLASS_MULTI_CHAN},
	{	CC_SERVICE_DATA_H12,			CC_SRV_CLASS_MULTI_CHAN},
	{	CC_SERVICE_DATA_MULTIRATE,		CC_SRV_CLASS_MULTI_CHAN},
	{	CC_SERVICE_DATA_128KBS,			CC_SRV_CLASS_MULTI_CHAN},
};

#define Sizeof_t_cc_service_convert	(sizeof (t_cc_service_convert) / sizeof (struct cc_service_convert))

	/*------------------------------------------------------------*/

uchar cc_service_to_class (cc_service_id)
	uchar 		cc_service_id;
{
	uchar i;

	for (i = 0; i < Sizeof_t_cc_service_convert; i++) {

		if (t_cc_service_convert[i].cc_service_id == cc_service_id) {
			return (t_cc_service_convert[i].service_class);
		}
	}

	return (CC_SRV_CLASS_DATA);

}

	/*-----------*/

CONST struct cc_service FAR *cc_access_service (cc_service_id)
	uchar cc_service_id;
{
	CONST struct cc_service FAR *p_cc_service;

	for (p_cc_service = T_cc_services (0);
		 Cc_service_id != CC_SERVICE_NIL;
		 p_cc_service++
		) {

		if (Cc_service_id == cc_service_id) {

				/* Service id found */

			return (p_cc_service);
		}

	}

	return (P_NIL);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_reset_temp_layer_1_info    - reset temporary layer 1 info
												structure.
				cc_reset_temp_layer_1_info    - reset call context's layer 1
												info structure.
				cc_get_layer_1_info_from_msg  - copy the received layer 1
												info into the call context.
				cc_put_layer_1_info_from_temp - copy layer 1 info from
												temporary to ACU primitive
												and to call context.

Usage			cc_reset_temp_layer_1_info ();
				cc_reset_call_layer_1_info ();
				cc_get_layer_1_info_from_msg (p_layer_1_info);
				cc_put_layer_1_info_from_temp (p_layer_1_info);
					- struct layer_1_info FAR *p_layer_1_info: pointer to
					the layer 1 information structure.

Return value	none.

*--------------------------------------------------------------------------*/

	/* Default 56k layer 1 information */

CONST struct layer_1_info cc_default_56k_layer_1_info = {
	RA_56KBS,		/* physical rate */
	RA_56KBS,		/* user rate */
	SYN,			/* syn/asyn */
	BYTE_VAL_NIL,	/* stop bits */
	BYTE_VAL_NIL,	/* data bits */
	BYTE_VAL_NIL	/* parity */
};

	/*--------*/

void cc_reset_temp_layer_1_info ()
{

	Memset_far ((char FAR *)&cc_layer_1_info,
				BYTE_VAL_NIL,
				sizeof (struct layer_1_info));

}

	/*--------*/

void cc_reset_call_layer_1_info ()
{

	Memset_far ((char FAR *)Cc_call_a_layer_1_info,
				BYTE_VAL_NIL,
				sizeof (struct layer_1_info));

}

	/*--------*/

void cc_get_layer_1_info_from_msg (p_layer_1_info)
	struct layer_1_info FAR *p_layer_1_info;
{

		/* Copy from ACU_..._RQ/RS primitive to call context */

		/*
			Force 56kbs service coding for Data-class calls
			with ph_rate of 56kbs.
		*/

	if ((Cc_profile_service_id == CC_SERVICE_DATA_56KBS) ||
		((p_layer_1_info -> ph_rate == RA_56KBS) &&
		 (Cc_call_service_class == CC_SRV_CLASS_DATA))
	   ) {

		Cc_call_p_cc_service = cc_access_service (CC_SERVICE_DATA_56KBS);

		p_layer_1_info = (struct layer_1_info FAR *)&cc_default_56k_layer_1_info;
	}

	Memcpy_far ((char FAR *)Cc_call_a_layer_1_info,
				(char FAR *)p_layer_1_info,
				sizeof (struct layer_1_info));

}

	/*--------*/

void cc_put_layer_1_info_from_temp (p_layer_1_info)
	struct layer_1_info FAR *p_layer_1_info;
{

		/* Copy from internal layer 1 info to ACU_..._IN primitive */

	Memcpy_far ((char FAR *)p_layer_1_info,
				(char FAR *)&cc_layer_1_info,
				sizeof (struct layer_1_info));

		/* Copy from internal layer 1 info to call context */

	Memcpy_far ((char FAR *)Cc_call_a_layer_1_info,
				(char FAR *)&cc_layer_1_info,
				sizeof (struct layer_1_info));

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_cause_from_ns

Description     read cause IE from an incoming NS message.

Usage           cc_read_cause_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	'cc_cause', cc_cause_val and 'cc_cause_class' global
				variables are set.
				If no cause is found,
				then these variables are set to 0 (and cc_cause is set to 0xFF).

*--------------------------------------------------------------------------*/

void cc_read_cause_from_ns (code)
	code_t     code;
{

	if ((code == NS_CLEAR_IN) ||
		(Net_get_ie (code, IE_CAUSE) == PRESENT)
	   ) {
		cc_cause_class = Net_isdn_get_val (code, IE_CAUSE, FLD_CAUSE_CLASS);
		cc_cause_val   = Net_isdn_get_val (code, IE_CAUSE, FLD_CAUSE_VAL);

		cc_cause       = C_v_user (cc_cause_class, cc_cause_val);

	} else {

		cc_cause_class =
		cc_cause_val   = 0;
		cc_cause       = 0xFF;
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_called_nb_from_ns

Description     read CALLED_NB IE info from an incoming NS message.

Usage           cc_read_called_nb_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	'p_called_nb', 'cc_called_nb_size',
				and 'cc_called_nb_type' global variables are set.
				If no CALLED_NB is found,
				then these variables are set to 0.

*--------------------------------------------------------------------------*/

void cc_read_called_nb_from_ns (code)
	code_t     code;
{

	cc_called_nb_size = 0;
	p_called_nb       = P_NIL;

	if (Net_get_ie (code, IE_CALLED_NB) == PRESENT) {
		cc_called_nb_size = Net_isdn_lgth_str (code, IE_CALLED_NB);
		p_called_nb       = Net_isdn_p_str    (code, IE_CALLED_NB);
		cc_called_nb_type = Net_isdn_get_val  (code, IE_CALLED_NB, FLD_NB_TYPE);
		cc_called_nb_plan = Net_isdn_get_val  (code, IE_CALLED_NB, FLD_NB_PLAN);
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_called_sub_add_from_ns

Description     read called_sub_add IE info from an incoming NS message.

Usage           cc_read_called_sub_add_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	'p_called_sub_add', 'cc_called_sub_add_size',
				and 'cc_called_sub_add_type' global variables are set.
				If no called_sub_add is found,
				then these variables are set to 0.

*--------------------------------------------------------------------------*/

void cc_read_called_sub_add_from_ns (code)
	code_t     code;
{

	cc_called_sub_add_size = 0;
	p_called_sub_add       = P_NIL;

#	if CC_CALLED_SUB_ADD == ON

		if (Called_sub_add_used == ON) {

			if (Net_get_ie (code,IE_CALLED_SUB_ADD) == PRESENT) {

				cc_called_sub_add_size	= Net_isdn_lgth_str (code, IE_CALLED_SUB_ADD);
				p_called_sub_add		= (uchar FAR *)Net_isdn_p_str (code, IE_CALLED_SUB_ADD);

					/*
						Make sure that the sub-address is a
						null-terminated string
					*/

				if (p_called_sub_add [cc_called_sub_add_size-1] != '\0') {
					p_called_sub_add [cc_called_sub_add_size++] = '\0';
				}

					/*
						In the ETSI-like 'OSI' sub-address,
						a special pattern (FORMAT_IA5) is
						inserted before the sub-address string.
						But in the Belgium network, this pattern
						is not taken in account, but sent
						transparently to the destination.
						Thus, if an ETSI-like 'OSI' sub-address
						is sent to the Belgium network, then
						the pattern will be INCLUDED INTO the
						sub-address string. To avoid this situation,
						we must extract the pattern from the
						string if it is present.
					*/

				if (p_called_sub_add [0] == FORMAT_IA5) {
					p_called_sub_add ++;
					cc_called_sub_add_size --;
				}

			}
		}

#	endif

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_display_from_ns

Description     read display info from an incoming NS message.

Usage           cc_read_display_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	sets 'cc_display_total_size', 'cc_display_instance_nb',
				'cc_display_size[]', 'p_cc_display[]'.
				If no display is found, then these variable are set to 0.

*--------------------------------------------------------------------------*/

#if CC_PAR_DISPLAY_IE == ON

void cc_read_display_from_ns (code)
	code_t code;
{
	uchar i;

	cc_display_total_size	= 0;
	cc_display_instance_nb	= 0;

	if (Net_get_ie (code, IE_DISPLAY) == PRESENT) {

		cc_display_instance_nb	= Net_get_remaining_ie_instance (code, IE_DISPLAY);

		for (i = 0; (i < cc_display_instance_nb) && (i < ACU_MX_DISPLAY); i++) {

			cc_display_size[i] = Net_isdn_lgth_str (code, IE_DISPLAY);

			if (cc_display_size [i] != 0) {

				cc_display_total_size += cc_display_size[i];

				p_cc_display[i]		= (char FAR *)Net_isdn_p_str (code, IE_DISPLAY);
				cc_display_type[i]	= Net_isdn_get_val(code, IE_DISPLAY, FLD_DISPLAY_TYPE);

				Net_set_to_next_ie_instance(code, IE_DISPLAY);

			}
		}

	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_display_from_acu

Description     read display info from an incoming ACU message.

Usage           cc_read_display_from_acu ();

Return value	sets 'cc_display_total_size' and 'p_cc_display_list',
				If no display is found,
				then 'cc_display_total_size' is set to 0.

*--------------------------------------------------------------------------*/

#if (ACU_INTERFACE == ON) && (CC_PAR_DISPLAY_IE == ON)

void cc_read_display_from_acu (p_display)
	struct acu_display_list FAR *p_display;
{
		/* Get display IE contents if present */

	if ((cc_display_total_size = Acu_display_total_size) != 0) {
		p_cc_display_list = p_display;
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_store_display

Description     store the display field into an ACU primitive.

Usage           void cc_store_display ((struct acu_display_list FAR *)p_display, (char FAR *)p_start_display_txt);

Return value    none

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

#if CC_PAR_DISPLAY_IE == ON

void cc_store_display (p_display, p_start)
	struct acu_display_list FAR * p_display;
	char FAR *p_start;
{

	uchar i;
	uchar display_size;

	Acu_display_nb 		      = cc_display_instance_nb;
	display_size              = 0;

	for (i = 0; i < cc_display_instance_nb; i++) {

		Acu_display_type(i) = cc_display_type[i];

		if ((Acu_display_size(i) = cc_display_size[i]) != 0) {
			p_start += display_size;
			Acu_display_p_display(i) = p_start;
			Memcpy_far (p_start, p_cc_display[i], cc_display_size[i]);
		}

		display_size += cc_display_size[i];

	}

	Acu_display_total_size = cc_display_total_size;
	cc_display_total_size  = 0;	/* reset the global variable to avoid problems */

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_uui_from_ns

Description     read UUI info from an incoming NS message.

Usage           cc_read_uui_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	sets 'p_cc_uui' global pointer to the beginning of the UUI;
				and 'cc_uui_size' to its size.
				If no UUI is found, then these variable are not altered.

*--------------------------------------------------------------------------*/

#if CC_UUI == ON

void cc_read_uui_from_ns (code)
	code_t     code;
{

	if (Uui_used == ON) {

		if ((Cc_call_uui_rq == ON) && (Net_get_ie (code, IE_UUI) == PRESENT)) {
			p_cc_uui	= (char FAR *)Net_isdn_p_str (code, IE_UUI);
			cc_uui_size	= Net_isdn_lgth_str (code, IE_UUI);
		}
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_keypad_from_ns

Description     read keypad info from an incoming NS message.

Usage           cc_read_keypad_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	'p_keypad' and 'cc_keypad_size' global variables are set.
				If no keypad is found,
				then these variables are set to 0.

*--------------------------------------------------------------------------*/

#if (CC_PAR_KEYPAD_IE == ON) && (EQUIPMENT == NT2)

void cc_read_keypad_from_ns (code)
	code_t     code;
{

	cc_keypad_size = 0;
	p_cc_keypad    = P_NIL;

	if (Net_get_ie (code, IE_KEYPAD) == PRESENT) {
		cc_keypad_size = Net_isdn_lgth_str (code, IE_KEYPAD);
		p_cc_keypad    = (char FAR *)Net_isdn_p_str (code, IE_KEYPAD);
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_facility_from_ns

Description     read facility info from an incoming NS message.

Usage           cc_read_facility_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	'p_facility', 'cc_facility_size' global variables are set.
				If no facility is found,
				then these variables are set to 0.

*--------------------------------------------------------------------------*/

#if CC_SUPP_SERVICES == ON

void cc_read_facility_from_ns (code)
	code_t     code;
{

	cc_facility_size = 0;
	p_cc_facility    = P_NIL;

	if (Sup_services_used == ON) {

		if (Net_get_ie (code, IE_FACILITY) == PRESENT) {
			cc_facility_size = Net_isdn_lgth_str (code, IE_FACILITY);
			p_cc_facility    = (char FAR *)Net_isdn_p_str (code, IE_FACILITY);
		}
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_progress_ind_from_ns

Description     read progress_ind info from an incoming NS message.

Usage           cc_read_progress_ind_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	'cc_progress_ind' global variable is set.
				If no progress_ind is found, then it is set to 0xFF.

*--------------------------------------------------------------------------*/

#if CC_PAR_PROGRESS_IND_IE == ON

void cc_read_progress_ind_from_ns (code)
	code_t     code;
{
	signed char i;

	cc_progress_ind.nb         = 0;
	cc_progress_ind.t[0].loc   = ACU_BYTE_VAL_NIL;
	cc_progress_ind.t[0].descr = ACU_BYTE_VAL_NIL;

	if (Net_get_ie (code, IE_PROGRESS_IND) == PRESENT) {
		Net_isdn_get_val (code, IE_PROGRESS_IND, FLD_NIL);

			/*
				If Data call but interworking occurs,
				then assume it is a 56k call.
			*/

		for (i = cc_progress_ind.nb-1; i >= 0; i--) {

			if (cc_progress_ind.t[i].descr == PROGRESS_DESCR_NON_END_TO_END_ISDN) {
				Cc_call_ph_rate           =
				cc_layer_1_info.user_rate =
				cc_layer_1_info.ph_rate   = RA_56KBS;
				break;
			}
		}

	}


}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_progress_ind_from_acu

Description     read progress_ind info from an incoming ACU message.

Usage           cc_read_progress_ind_from_acu (p_progress_ind);

Return value	'cc_progress_ind' global variable is set.
				If no progress_ind is found, then it is set to 0xFF.

*--------------------------------------------------------------------------*/

#if CC_PAR_PROGRESS_IND_IE == ON

void cc_read_progress_ind_from_acu (p_progress_ind)
	struct acu_progress_ind FAR *p_progress_ind;
{
	Memcpy_far ((char FAR *)&cc_progress_ind, (char FAR *)p_progress_ind, sizeof (struct acu_progress_ind));
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_store_progress_ind

Description     store the progress_ind field into an ACU primitive.

Usage           void cc_store_progress_ind ((char FAR *)p_progress_ind);

Return value    none

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

#if CC_PAR_PROGRESS_IND_IE == ON

void cc_store_progress_ind (p_progress_ind)
	struct acu_progress_ind FAR *p_progress_ind;
{
	Memcpy_far ((char FAR *)p_progress_ind, (char FAR *)&cc_progress_ind, sizeof (struct acu_progress_ind));
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_signal_from_ns

Description     read signal info from an incoming NS message (ARINC).

Usage           cc_read_signal_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	'cc_signal_loc' global variable is set.
				If no signal is found, then it is set to 0xFF.

*--------------------------------------------------------------------------*/

#if CC_PAR_SIGNAL_IE == ON

void cc_read_signal_from_ns (code)
	code_t     code;
{

	cc_signal_val = 0xff;

	if (Net_get_ie (code, IE_SIGNAL) == PRESENT) {
		cc_signal_val = Net_isdn_get_val (code, IE_SIGNAL, FLD_SIGNAL_VAL);
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_credit_card_nb_from_ns

Description     read credit_card_nb info from an incoming NS message (ARINC).

Usage           cc_read_credit_card_nb_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	sets the following global variables:
				cc_track_1_size, cc_track_2_size,
				p_cc_track_1, p_cc_track_2.
				If no credit_card_nb is found, then these variables are
				set to 0.

*--------------------------------------------------------------------------*/

#if ARINC_NETWORKS == ON

void cc_read_credit_card_nb_from_ns (code)
	code_t     code;
{

	cc_track_1_size = 0;
	cc_track_2_size = 0;

	p_cc_track_1 	= P_NIL;
	p_cc_track_2 	= P_NIL;

	if (Net_get_ie (code, IE_CREDIT_CARD_NB) == PRESENT) {
		cc_track_1_size = Net_isdn_lgth_str (code, FLD_CREDIT_CARD_TRACK_1);
		cc_track_2_size = Net_isdn_lgth_str (code, FLD_CREDIT_CARD_TRACK_2);

		p_cc_track_1 	= (char FAR *)Net_isdn_p_str (code, FLD_CREDIT_CARD_TRACK_1);
		p_cc_track_2 	= (char FAR *)Net_isdn_p_str (code, FLD_CREDIT_CARD_TRACK_2);
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_credit_card_status_from_ns

Description     read credit_card_status info from an incoming NS message (ARINC).

Usage           cc_read_credit_card_status_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	sets the cc_credit_card_status global variable.
				If no credit_card_status is found, then this variable is
				set to 0xff.

*--------------------------------------------------------------------------*/

#if ARINC_NETWORKS == ON

void cc_read_credit_card_status_from_ns (code)
	code_t     code;
{

	cc_credit_card_status = 0xff;

	if (Net_get_ie (code, IE_CREDIT_CARD_STATUS) == PRESENT) {
		cc_credit_card_status = Net_isdn_get_val (code, IE_CREDIT_CARD_STATUS, FLD_CREDIT_CARD_STATUS);
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_redir_nb_from_ns

Description     read all fields of redir_nb IE, from an incoming
				NS message; fills-in the cc_redir_nb_... variables.

Usage           cc_read_redir_nb_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value	void
Global variables and contexts affected:
					- cc_redir_nb_...

*--------------------------------------------------------------------------*/

#if CC_PAR_REDIR_NB == ON

void cc_read_redir_nb_from_ns (code)
	code_t     code;
{

	if (Net_get_ie (code, IE_REDIR_NB) == PRESENT) {

			/*
			 *	The network-specific function 'Net_isdn_get_val()'
			 *	reads all the relevant fields of the redir_nb IE.
			 */

		Net_isdn_get_val (code, IE_REDIR_NB, FLD_NIL);

	} else {

		cc_redir_nb_size   = 0;
		p_redir_address    = P_NIL;
		cc_redir_nb_pres   = ACU_NB_PRES_ALLOWED;
		cc_redir_nb_type   = ACU_NB_TYPE_UNKNOWN;
		cc_redir_nb_reason = ACU_NB_REASON_UNKNOWN;
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_store_redir_nb_in_acu_prim

Description		stores the redir_nb IE in an ACU primitive.

Usage           cc_store_redir_nb_in_acu_prim (p_acu_redir_nb, p_acu_redir_nb_string)
					uchar FAR *p_acu_redir_nb: address of the redir_nb field
					  in the ACU primitive;
					uchar FAR *p_acu_redir_nb_string: address of the redir_nb string
					  in the ACU primitive;

Return value	void
Global variables and contexts affected:
					- cc_redir_nb_...

*--------------------------------------------------------------------------*/

#if CC_PAR_REDIR_NB == ON

void cc_store_redir_nb_in_acu_prim (p_acu_redir_nb, p_acu_redir_nb_string)
	struct acu_redir_nb FAR *p_acu_redir_nb;
	char                FAR *p_acu_redir_nb_string;
{
	if ((p_acu_redir_nb -> size  = cc_redir_nb_size) != 0) {
		p_acu_redir_nb -> pres   = cc_redir_nb_pres;
		p_acu_redir_nb -> type   = cc_redir_nb_type;
		p_acu_redir_nb -> screen = cc_redir_nb_screen;
		p_acu_redir_nb -> reason = cc_redir_nb_reason;
		cc_build_address (p_redir_address, P_NIL, p_acu_redir_nb_string);
	}
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_chan_id_from_ns

Description     read chan_id, chan_sel and pref_excl fields from an incoming
				NS message; fills-in the cc_chan_id[] list.

Usage           cc_read_chan_id_from_ns (prim_code);
					code_t prim_code: NS primitive code;

Return value    Global variables and contexts affected:
					- cc_chan_nb + cc_chan_id[];
					- cc_chan_excl;
					- cc_chan_sel;

*--------------------------------------------------------------------------*/

void cc_read_chan_id_from_ns (code)
	code_t     code;
{
	cc_chan_sel = NO_CHAN;

	if (Net_get_ie (code, IE_CHAN_ID) == PRESENT) {

			/*
			 *	The network-specific function 'Cc_get_chan_id'
			 *	now reads all the relevant fields of the Channel ID.
			 */

		Cc_get_chan_id   (code, IE_CHAN_ID);

		if (cc_chan_sel == ANY_CHAN) {
			cc_chan_nb    = 0;
			cc_chan_id[0] = NO_CHAN;
		}

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_process_chani_list_from_acu

Description     read+check+allocate the list of channels given by an ACU
				primitive, or tries to allocate a new one if not given
				in the ACU primitive but required by the standard.

Usage           uchar cc_process_chani_list_from_acu (p_chani_list);
				struct chani_list FAR *p_chani_list: pointer to the list.

Return value	NOK: stop processing the received primitive;
				OK:  carry on, the provided channel list has been processed;

				Global variables and contexts affected:
					- cc_chan_nb + cc_chan_id[];
					- cc_chan_excl;
					- cc_chan_id_from_user;
					- cc_store_chan_id;
					- B-channels contexts;
					- Call context;

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

uchar cc_process_chani_list_from_acu (p_chani_list)
	struct chani_list FAR *p_chani_list;
{
	signed char i;

	switch (cc_read_chani_list_from_acu (p_chani_list)) {

		case STOP:

				/*
					The given channel_id is already allocated:
					reject the primitive
				*/

			cc_snd_acu_err_in (ACUER_PARAM_VAL, ACUERDIAG_CHAN_ID);
			return (NOK);

		case CONTINUE:

				/* No channel provided */

				/*
					If an answer to the incoming call has
					already been transmitted,
					then it is not necessary to send the
					channel_id information again
				*/

			if (Cc_call_previous_state != STATE_NULL) {
				break;
			}

				/*
					It is the first answer to the incoming call:
					force sending of channel_id
					if required by the standard or on NT-side,
					otherwize do not send it.
				*/

			if ((Channel_id_in_first_rs == ON)
#				if EQUIPMENT == NT2
				 || (Cc_na_function == FG_NT_TE)
#				endif
			   ) {

					/*
						if a channel-id has already been
						   allocated to that call,
						then
							force it to be exclusive and
							send it.
						else
							try to allocate a new one.
					*/

				if (Cc_call_b_chan_nb != 0) {

						/*
							Copy the channel recorded in the
							call context into the temporary
							cc_chan_id[] table
						*/

					cc_chan_excl        =
					Cc_call_b_chan_excl = CHAN_EXCL;
					cc_chan_nb          = Cc_call_b_chan_nb;

					for (i = cc_chan_nb - 1; i >= 0; i--) {
						cc_chan_id[i] = Cc_call_b_chan (i);
					}

					cc_chan_id_from_user = ON;
					cc_store_chan_id     = ON;

						/* carry on with the channel */

					break;
				}

					/* Try to allocate a new channel-id */

				if (cc_find_free_b_chan () == NOK) {

						/*
							No free channel available:
							clear the call!
						*/

				}

					/* Send the new allocated B channel */

				break;

			}
			break;

		case OK:	/* the given channel_id is available */
			break;

	}

	return (OK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_chani_list_from_acu

Description     read+check+allocate the list of channels given by an ACU
				primitive. Put the list into 'cc_chan_list[]' and
				into the call context.

Usage           uchar cc_read_chani_list_from_acu (p_chani_list);
				struct chani_list FAR *p_chani_list: pointer to the list.

Return value	STOP:     at least one of the B-channels is already
						  allocated: stop the processing;
				CONTINUE: carry on, but no channel list has been provided;
				OK:       carry on, the provided channel list has been processed;

				Global variables and contexts affected:
					- cc_chan_nb + cc_chan_id[];
					- cc_chan_excl;
					- cc_chan_id_from_user;
					- cc_store_chan_id;
					- B-channels contexts;
					- Call context;

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

uchar cc_read_chani_list_from_acu (p_chani_list)
	struct chani_list FAR *p_chani_list;
{
	struct cc_b_chan FAR *p_cc_b_chan;
	signed char           i,j;
	uchar                 chan_id;

	if ((Cc_call_b_chan_id   != NO_CHAN) &&
		(Cc_call_b_chan_excl == CHAN_EXCL)) {

			/*
				The B-channels are already allocated and exclusive
				for that call: ignore the B-channels list.
			*/

		return (CONTINUE);
	}

	if (((cc_chan_nb = p_chani_list -> nb) == 0) ||
		(p_chani_list -> tab[0].chan_id    == NO_CHAN)
	   ) {

			/* No list in the ACU primitive: continue. */

		return (CONTINUE);
	}

		/* Process the channels list */

		/* Loop on all listed channels */

	for (i = cc_chan_nb - 1; i >= 0; i--) {

			/* Check if the provided chan_id is already used */

		chan_id = p_chani_list -> tab[i].chan_id;

		if ((chan_id == 0) ||
			(chan_id == D_chan_id) ||
			(chan_id > B_chan_nb)
		   ) {

				/* Invalid B-channel id: stop the processing */

			return (STOP);
		}

		Cc_access_b_chan (chan_id);

		if (Cc_b_chan_used != CC_B_CHAN_FREE) {

				/*
					The B-channel is already used:
					if it is the one of the current call
					then no problem
					else reject
				*/

				/* look into the call context channel list */

			for (j = Cc_call_b_chan_nb - 1; j >= 0; j--) {

				if (Cc_call_b_chan (j) == chan_id) {

						/* found: accept the given channel id */

					break;
				}

			}

				/* if not found then reject the given channel id */

			if (j < 0) {
				return (STOP);
			}

		}

			/* next channel in the list */

	} /* end for (all listed channels) */

		/* first reset the channels allocated to the call if any */

	cc_reset_call_b_chan ();

		/* then allocate the given channel list */

	cc_alloc_chan_list (p_chani_list);

		/* Carry on with the processed channel list */

	return (OK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_alloc_chan_list

Description     allocate the list of channels given by an ACU
				primitive. Put the list into 'cc_chan_list[]' and
				into the call context.

Usage           void cc_alloc_chan_list (p_chani_list);
				struct chani_list FAR *p_chani_list: pointer to the list.

Return value	none

				Global variables and contexts affected:
					- cc_chan_nb + cc_chan_id[];
					- cc_chan_id_from_user;
					- cc_store_chan_id;
					- B-channels contexts;
					- Call context;

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_alloc_chan_list (p_chani_list)
	struct chani_list FAR *p_chani_list;
{
	signed char            i;

		/* All listed channels are available: allocate them */

	Cc_call_b_chan_nb   = cc_chan_nb;
	Cc_call_b_chan_excl =
	cc_chan_excl        = p_chani_list -> chan_id_excl;

	for (i = cc_chan_nb - 1; i >= 0; i--) {
		cc_alloc_b_chan (p_chani_list -> tab[i].chan_id);
		Cc_call_b_chan (i) =
		cc_chan_id[i]      = p_chani_list -> tab[i].chan_id;
	}

	cc_chan_id_from_user = ON;	/* The channel id is received from the User */
	cc_store_chan_id     = ON;

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_write_call_chan_list_to_acu

Description     write the call channels list into an ACU primitive.

Usage           void cc_write_call_chan_list_to_acu (p_chani_list);
				struct chani_list FAR *p_chani_list: pointer to the list.

Return value	none

*--------------------------------------------------------------------------*/

#if ACU_INTERFACE == ON

void cc_write_call_chan_list_to_acu (p_chani_list)
	struct chani_list FAR *p_chani_list;
{
	signed char            i;

		/* Loop on all call channels */

	for (i = Cc_call_b_chan_nb - 1; i >= 0; i--) {
		p_chani_list -> tab[i].chan_id = Cc_call_b_chan (i);
		p_chani_list -> tab[i].nai     = cc_current_nai;
	}

		/* Set the number of channels */

	p_chani_list -> nb           = Cc_call_b_chan_nb;

		/* Set Preferred/exclusive value */

	p_chani_list -> chan_id_excl = Cc_call_b_chan_excl;
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_chani_list_to_map

Description     convert a B-channels list into a "channels map".

				The map has the following format:

				.bit # : . 8. 7. 6. 5. 4. 3. 2. 1.
				-------:--------------------------
				byte #0: .--.--.30.29.28.27.26.25.
				byte #1: .24.23.22.21.20.19.18.17.
				byte #2: .16.15.14.13.12.11.10. 9.
				byte #3: . 8. 7. 6. 5. 4. 3. 2. 1.

Usage           void cc_chani_list_to_map ();

Return value	the global 'cc_chan_map[]' array is set up.

*--------------------------------------------------------------------------*/

#if (CC_TYPE_PRI == ON)

void cc_chani_list_to_map ()
{
	signed char i;
	char        bit_nb;

	for (i = cc_chan_nb - 1; i >= 0; i--) {

			/* the bit number in the string is the slot number - 1 */

		bit_nb = cc_chan_id[i] - 1;

			/* Set the proper bit of the proper octet of the string */

		cc_chan_map [3 - (bit_nb / 8)] |= (1 << (bit_nb % 8));
	}

}

#endif /* (CC_TYPE_PRI == ON) */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_chani_map_to_list

Description     convert a B-channels map into a list.
				Uses cc_chan_map_lgth and cc_chan_map[] array as source map;
				Sets-up cc_chan_id[] and cc_chan_nb variables.

Usage           void cc_chani_map_to_list (map_lgth, p_map);
				uchar      map_lgth: nb of bytes in the given map;
				uchar FAR *p_map: pointer to the map.

Return value	- cc_chan_nb + cc_chan_id[] set up.

*--------------------------------------------------------------------------*/

#if (CC_TYPE_PRI == ON)

void cc_chani_map_to_list (map_lgth, p_map)
	uchar      map_lgth;
	uchar FAR *p_map;
{
	signed char  x_chan_map;		/* index in the map */
	signed char  x_chan_id;			/* index in the list */
	uchar        map_byte;			/* current byte in the map */
	uchar        map_byte_cnt;		/* byte counter */
	uchar        bit;				/* bit counter in the byte */

		/*
		 * Scan all the map, starting at the last octet to get the channel
		 * ids in increasing order.
		 */

	x_chan_id    = 0;
	map_byte_cnt = 0;

	for (x_chan_map = map_lgth - 1; x_chan_map >= 0; x_chan_map--) {

		map_byte = p_map [x_chan_map];

			/* Scan the 8 bits of the byte */

		for (bit = 1; bit <= 8; bit++) {

			if (map_byte & 0x01) {

					/* bit is set: record the channel id */

				cc_chan_id [x_chan_id++] = 8 * map_byte_cnt + bit;
			}

			map_byte >>= 1;
		}

		map_byte_cnt++;

	}

	cc_chan_nb = x_chan_id;

}

#endif /* (CC_TYPE_PRI == ON) */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_reset_call_b_chan

Description     reset the B channels assigned to the call

Usage           void cc_reset_call_b_chan ();

Return value	none;

*--------------------------------------------------------------------------*/

void cc_reset_call_b_chan ()
{

	uchar       chan_id;
	struct cc_b_chan FAR *p_cc_b_chan;
	signed char i;

#	if CC_SPF_FAC == ON
		struct cc_call FAR *p_cc_call_sav;
		struct cc_call FAR *p_cc_call_other;
#	endif

	if (Cc_call_b_chan_nb != 0) {

		chan_id = Cc_call_b_chan_id;

			/*
				1 - if another call is sharing the same B-channel, then:

					1a - if the call being cleared is not held, then:
							init the B channel back to the parameters of the
							held call.

					1b - else: (current call is held)
							clear the hold condition on the call.

					1c - And leave the B channel to its current state:
						 Reset current call context chan list
						 (but do not free it).

				2 - else: (no other call on that B-channel)

					2a - if the current call is held then:
							clear the hold condition.

					2b - else: do nothing

					2c - Free the B channel (normal operation).
			*/

#		if CC_SPF_FAC == ON

			if ((Spf_fac_used == ON) && (Cc_na_hold_nb != 0)) {

					/* Search another call sharing the same B channel */

				Cc_access_b_chan (chan_id);

					/* test the active call using that B-channel if any */

				p_cc_call_other = Cc_b_chan_p_active_call;

				if ((p_cc_call_other == P_NIL) ||
					(p_cc_call_other == p_cc_call)) {

						/* not the active one, try the held if any */

					p_cc_call_other = Cc_b_chan_p_held_call;

					if ((p_cc_call_other == P_NIL) ||
						(p_cc_call_other == p_cc_call)) {

							/*
								not the held one neither: no other call is sharing
								the B-channel.
							*/

						p_cc_call_other = P_NIL;
					}
				}

				if (p_cc_call_other != P_NIL) {

						/* 1: another call is sharing the B channel */

					if (Cc_call_hold_state == OFF) {

							/*
								1a: the current call is not held :
									init the B channel back to the
									parameters of the held call.
							*/

							/* save current call pointer */

						p_cc_call_sav	= p_cc_call;

							/* point to the other (not held) call */

						p_cc_call       = p_cc_call_other;
						p_cc_profile	= Cc_call_p_cc_profile;

							/* switch & init the B-channel to its parameters */

						if (Cc_profile_switch_rq_enable == ON) {
							cc_b_switch		(chan_id, Cc_call_b_chan_mode, B_AUDIO_TONE_NIL);
						}

						if (Cc_profile_init_rq_enable == ON) {
							cc_b_init_stop	(MPH_B_INIT_RQ);
						}

							/* restore current call & profile pointers */

						p_cc_call		= p_cc_call_sav;
						p_cc_profile	= Cc_call_p_cc_profile;

							/*
								Update B-channel context:
								the current (active) call does not handle
								this B-channel anymore.
							*/

						Unsetbit (Cc_b_chan_used, CC_B_CHAN_USED);
						Cc_b_chan_p_active_call = P_NIL;

					} else {

							/*
								1b: the call beeing cleared is held:
									Clear the hold condition on the call
									and leave without clearing the B channel.
							*/

						Cc_call_hold_state = OFF;
						Cc_na_hold_nb--;

							/* Clear hold state for the B-channel */

						Unsetbit (Cc_b_chan_used, CC_B_CHAN_HELD);
						Cc_b_chan_p_held_call = P_NIL;
					}

						/* 1c: Reset current call context chan list */

					Cc_call_b_chan (0) = NO_CHAN;
					Cc_call_b_chan_nb  = 0;

					return;

				} else {

						/* 2 - else: (no other call on that B-channel) */

					if (Cc_call_hold_state == ON) {

							/*
								2a: the call beeing cleared is held:
								Clear the hold condition
							*/

						Cc_call_hold_state = OFF;
						Cc_na_hold_nb--;

							/* Clear hold state for the B-channel */

						Unsetbit (Cc_b_chan_used, CC_B_CHAN_HELD);
						Cc_b_chan_p_held_call = P_NIL;

					} else {

							/*
								2b: the call beeing cleared is not held:
								do nothing.
							*/

					}

						/* 2c: Clear the B channel */

				}

			}

#		endif

			/* Switch/stop B chan if it has been switched/init before */

		if (p_cc_profile != P_NIL) {

			if (Cc_profile_init_rq_enable == ON) {
				cc_b_init_stop	(MPH_B_STOP_RQ);
			}

			if (Cc_profile_switch_rq_enable == ON) {
				cc_b_switch		(chan_id, B_MODE_NIL, B_AUDIO_TONE_NIL);
			}

		}

		for (i = Cc_call_b_chan_nb - 1; i >= 0; i--) {
			cc_free_b_chan (Cc_call_b_chan (i));
			Cc_call_b_chan (i) = NO_CHAN;
		}

		Cc_call_b_chan_nb = 0;

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_find_free_b_chan

Description     try to find one or more free B channels.

Usage           uchar cc_find_free_b_chan ();

Return value	OK  if found;
				NOK if not found.

*--------------------------------------------------------------------------*/

uchar cc_find_free_b_chan ()
{
	signed char i;		/* tmp index */

	if (cc_chan_nb == 0) {

			/* Determine how many channels are to be assigned */

		if (Cc_call_service_class == CC_SRV_CLASS_MULTI_CHAN) {
/**/		cc_chan_nb = 6;

		} else {

			cc_chan_nb = 1;

		}

	}

	for (i = cc_chan_nb - 1; i >= 0; i--) {

		if ((cc_chan_id[i] = cc_find_single_free_b_chan ()) == NO_CHAN) {

				/*
					No free channel available:
					reject the call
				*/

				/* Deallocate the allocated channels */

			for (i++; i < cc_chan_nb; i++) {
				cc_free_b_chan (cc_chan_id[i]);
			}

			return (NOK);
		}

			/* Allocate the channel */

		cc_alloc_b_chan (cc_chan_id[i]);
		Cc_call_b_chan (i) = cc_chan_id[i];
	}

	Cc_call_b_chan_nb = cc_chan_nb;

		/*
			Set flag to send back the chan_id IE
			in the next message
		*/

	cc_store_chan_id = ON;

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_find_single_free_b_chan

Description     try to find a free B channel id.

Usage           uchar cc_find_single_free_b_chan ();

Return value	Allocated B channel, or NO_CHAN if none is available.

*--------------------------------------------------------------------------*/

uchar cc_find_single_free_b_chan ()
{
	struct cc_b_chan FAR	*p_cc_b_chan;
	uchar					chan_id;

#if EQUIPMENT == NT2

	if (Cc_na_function == FG_NT_TE) {

	   for (chan_id = 1; chan_id <= Cc_na_nb_b_chan; chan_id++) {

		   Cc_access_b_chan (chan_id);

		   if ((Cc_b_chan_used == CC_B_CHAN_FREE) && (chan_id != D_chan_id)) {
			   return (chan_id);
		   }
	   }

	} else {

#endif

	   for (chan_id = Cc_na_nb_b_chan; chan_id >= 1; chan_id--) {

		   Cc_access_b_chan (chan_id);

		   if ((Cc_b_chan_used == CC_B_CHAN_FREE) && (chan_id != D_chan_id)) {
			   return (chan_id);
		   }
	   }

#if EQUIPMENT == NT2
	}
#endif

	return (NO_CHAN);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_alloc_b_chan, cc_free_b_chan

Description     allocate/free B-channel context.

Usage           void cc_alloc_b_chan (chan_id);
				void cc_free_b_chan  (chan_id);
					- uchar chan_id: channel id to be allocated/freed;

Return value	Allocated B channel, or NO_CHAN if none available.

*--------------------------------------------------------------------------*/

void cc_alloc_b_chan (chan_id)
	uchar chan_id;
{
	struct cc_b_chan FAR  *p_cc_b_chan;

	Cc_access_b_chan (chan_id);

	Setbit (Cc_b_chan_used, CC_B_CHAN_USED);

	Cc_b_chan_p_active_call = p_cc_call;

#	if SIM_ANALYSER == ON
		pr_cc_alloc_b_chan (chan_id);
#	endif

}

	/*---------*/

void cc_free_b_chan (chan_id)
	uchar chan_id;
{
	struct cc_b_chan FAR  *p_cc_b_chan;

	Cc_access_b_chan (chan_id);

	Cc_b_chan_used = CC_B_CHAN_FREE;

	Cc_b_chan_p_active_call =
	Cc_b_chan_p_held_call   = P_NIL;

#	if SIM_ANALYSER == ON
		pr_cc_free_b_chan (chan_id);
#	endif

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_alloc_b_chan_if_allowed

Description     allocate a B-channel context if allowed;
				update Call B-channels list.

Usage           void cc_alloc_b_chan_if_allowed ();

Return value	STOP if the channel is not allowed,
				or CONTINUE if allowed.

*--------------------------------------------------------------------------*/

uchar cc_alloc_b_chan_if_allowed ()
{
	struct cc_b_chan FAR *p_cc_b_chan;
	uchar                 x_chan;

		/*
			Check that the received B-channel is
			not already allocated for another call
		*/

	for (x_chan = 0; x_chan < cc_chan_nb; x_chan++) {

		Cc_access_b_chan (cc_chan_id[x_chan]);

		if ((Cc_b_chan_used          != CC_B_CHAN_FREE) &&
			(Cc_b_chan_p_active_call != p_cc_call) &&
			(Cc_b_chan_p_held_call   != p_cc_call)
			) {

				/*
					The received B-channel is already used by another call.
					Check if the B-channel is held or not.
					If it is held, then accept the given B-channel,
					else reject.
				*/

			if ((Cc_b_chan_p_held_call != P_NIL) &&
				(Cc_b_chan_p_held_call != p_cc_call)) {

					/* found another held call using the same B-channel: accept */

			} else {

					/* Reject the call */

			reject:

				if (Cc_na_network != cc_at5) {
					Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_REQUESTED_CIRCUIT_NOT_AVAILABLE_44);

				} else {

					Cc_set_ns_error (C_C_RESOURCE_UNAVAILABLE, C_V_NO_CIRCUIT_AVAILABLE_34);
				}

				Cc_set_state (STATE_RELEASE_RQ);
				return (STOP);
			}

		}

		accept:

			/*
				Check that the received B-channel is
				the same as the requested one if it was
				exclusive
			*/

		if ((cc_chan_id[x_chan] != Cc_call_b_chan (x_chan)) &&
			(Cc_call_b_chan (x_chan) != NO_CHAN)
			) {

				/*
					The received B-channel is NOT the same as
					the requested one
				*/

			if (Cc_call_b_chan_excl == ON) {

					/*
						We requested an Exclusive channel, so
						reject the answer
					*/

				goto reject;

			} else {

					/*
						We requested a Preferred channel, so
						free the previous one and allocate
						the new one
					*/

				cc_free_b_chan (Cc_call_b_chan (x_chan));
			}
		}

			/* Allocate the B-channel */

		cc_alloc_b_chan (cc_chan_id[x_chan]);
		Cc_call_b_chan (x_chan) = cc_chan_id[x_chan];

	}

	Cc_call_b_chan_excl = cc_chan_excl;

	Cc_call_b_chan_nb   = cc_chan_nb;

	return (CONTINUE);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_b_switch

Description     request the switching of the B1 or B2 channel.

Usage           void cc_b_switch (uchar chan_id, uchar mode, uchar tone_id);
					- chan_id : channel port ID,
					- mode	  : usage mode.
					- tone_id : tone ID.

Return value	none;

*--------------------------------------------------------------------------*/

void cc_b_switch (chan_id, mode, tone_id)
	uchar	chan_id;		/* channel port ID */
	uchar	mode;			/* mode */
	uchar	tone_id;		/* tone ID */
{
	struct buffer    FAR *p_buffer = P_NIL;	/* local buffer pointer */
	uchar			 FAR *p_data;			/* data structure */
	struct cc_b_chan FAR *p_cc_b_chan;		/* B channel context */
	signed char           i;				/* tmp index */

	if (chan_id == NO_CHAN) {
		return;
	}

	Cc_access_b_chan (chan_id);

	if (Cc_b_chan_mode != mode) {

		Cc_b_chan_mode = mode;

			/* Prepare a message (and a buffer if needed) */

		Prepare_data_to_send (p_snd_msg, p_buffer, Mph_b_switch_size, p_data);

		Mph_b_switch_mode					= mode;

			/* Keep 'chan_id' for compatibility */

		Mph_b_switch_chan_id				= chan_id;

			/* Copy the B-channels list */

		if (p_cc_call != P_NIL) {

				/* Call-related */

			Mph_b_switch_chan_nb = Cc_call_b_chan_nb;

			for (i = Cc_call_b_chan_nb - 1; i >= 0; i--) {
				Mph_b_switch_chan_list (i) = Cc_call_b_chan (i);
			}

		} else {

				/* Not call-related */

			Mph_b_switch_chan_nb       = 1;
			Mph_b_switch_chan_list (1) = chan_id;
		}

		Mph_b_switch_device_id				= DEVICE_ID_NIL;
		Mph_b_switch_tone_id  				= tone_id;

		cc_snd_to_mph (MPH_B_SWITCH_RQ);

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_b_init_stop

Description     request the activation or deactivation
				of the B1 or B2	channel from B-channels driver.

Usage           void cc_b_init_stop (code_t code);
					- code    : primitive code,

Return value	none;

*--------------------------------------------------------------------------*/

void cc_b_init_stop (code)
	code_t		code;		/* primitive code */
{
	struct buffer    FAR *p_buffer = P_NIL;	/* local buffer pointer */
	uchar			 FAR *p_data;			/* data structure */
	struct cc_b_chan FAR *p_cc_b_chan;		/* B channel context */
	uchar				  rate;				/* temporary rate value */
	signed char           i;				/* tmp index */

	Cc_access_b_chan (Cc_call_b_chan_id);

	if (Cc_b_chan_init_code == code) {
		return;		/* already done */
	}

	Cc_b_chan_init_code = code;				/* update init code */

		/* Prepare a message (and a buffer if needed) */

	Prepare_data_to_send (p_snd_msg, p_buffer, Mph_b_init_size, p_data);

		/* Store the B-channel mode */

	Mph_b_init_mode					= Cc_call_b_chan_mode;

		/* Keep 'chan_id' for compatibility */

	Mph_b_init_chan_id				= Cc_call_b_chan_id;

		/* Copy the B-channels list */

	Mph_b_init_chan_nb = Cc_call_b_chan_nb;

	for (i = Cc_call_b_chan_nb - 1; i >= 0; i--) {
		Mph_b_init_chan_list (i) = Cc_call_b_chan (i);
	}

		/* Store the 'rate' if necessary */

	rate = 0;	/* default value, i.e. 64kbs */

	if (Cc_call_service_class == CC_SRV_CLASS_DATA) {

		switch (Cc_profile_service_id) {

			case CC_SERVICE_DATA_56KBS :
				rate = RATE_56KBS;
				break;

			case CC_SERVICE_V120 :

				if (Cc_call_ph_rate == RA_56KBS) {
					rate = RATE_56KBS;
				}
				break;

			default:
				rate = Cc_call_ph_rate;
				break;
		}

	}

	Mph_b_init_rate					= rate;
	Mph_b_init_intermediate_rate	= 0;
	Mph_b_init_nic_tx				= 0;
	Mph_b_init_nic_rx				= 0;
	Mph_b_init_fc_tx				= 0;
	Mph_b_init_fc_rx				= 0;
	Mph_b_init_stop_bit_nb			= Cc_call_stop_bits;
	Mph_b_init_data_bit_nb			= Cc_call_data_bits;
	Mph_b_init_parity				= Cc_call_parity;
	Mph_b_init_syn_asyn				= Cc_call_syn_asyn;

	Mph_b_init_layer_2_ent_id  		= Cc_profile_init_rq_l2_ent_id;
	Mph_b_init_layer_3_ent_id  		= Cc_profile_init_rq_l3_ent_id;

	cc_snd_to_mph (code);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_snd_ced

Description     sends a CED to the ENT_PH_GSTN entity.

Usage           cc_snd_ced ();

Return value	none;

*--------------------------------------------------------------------------*/

void cc_snd_ced ()
{
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_decode_address

Description     filter an input called or calling number address and subaddress

Usage           cc_decode_address (p_p_address, p_p_subaddress);

Return value    *p_p_address    = P_NIL	if no address

				*p_p_subaddress = P_NIL if no sub-address

				ex : z1P2D34*7Q8D9 :
					 *p_p_address points to "1234",
					 and *p_p_subaddress points to "789".

*--------------------------------------------------------------------------*/

void cc_decode_address (p_p_address, p_p_subaddress)
	char	FAR *FAR *p_p_address;
	char	FAR	*FAR *p_p_subaddress;
{
	char		 FAR *p_curr;
	char		 FAR *p_curr_filtered;
	char			  no_address;

	*p_p_subaddress = P_NIL;

	if (*p_p_address == P_NIL) {
		return;
	}

	no_address			= FALSE;
	p_curr_filtered		= *p_p_address;

		/* Filter the AT address and subaddress number string */

	for (p_curr = *p_p_address; *p_curr != '\0'; p_curr++) {

		if (*p_curr == CC_SUB_ADDRESS_DELIMITER) {

			if (p_curr_filtered == *p_p_address) {
				no_address			= TRUE;

			} else {

				*p_curr_filtered++	= '\0';		/* replace the delimiter with '\0' to end address string */
			}

			*p_p_subaddress = p_curr_filtered;	/* set sub_address pointer */

				/* Copy the remaining characters without filter */

			p_curr++;

			while (*p_curr != '\0') {
				*p_curr_filtered++ = *p_curr++;
			}

				/* And exit from loop */

			break;
		}

		switch (*p_curr) {

			case '0' :
			case '1' :
			case '2' :
			case '3' :
			case '4' :
			case '5' :
			case '6' :
			case '7' :
			case '8' :
			case '9' :

			case '*' :
			case '#' :

#		ifdef CC_CALLED_SUB_ADD_WA
			case '$' :
#		endif
				*p_curr_filtered++ = *p_curr;
				break;

			default :
				break;

		}

	}

	*p_curr_filtered = '\0';

	if ((*p_p_subaddress != P_NIL) && (**p_p_subaddress == '\0')) {
		*p_p_subaddress = P_NIL;
	}

	if (no_address == TRUE) {
		*p_p_address = P_NIL;
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_build_address

Description     build an address from a called number
				or calling number address and subaddress.

Usage           cc_build_address (p_in_number, p_in_subaddress, p_out_address);


*--------------------------------------------------------------------------*/

void cc_build_address (p_in_number, p_in_subaddress, p_out_address)
	char		FAR *p_in_number;
	char		FAR *p_in_subaddress;
	char		FAR *p_out_address;
{
	ushort			size;

	if (p_in_number == P_NIL) {
		*p_out_address = '\0';
		size = 1;

	} else {

		size = Strcpy_far (p_out_address, (char FAR *)p_in_number, ACU_MX_SZ_CALLED_NB+1);
	}

	if ((p_in_subaddress != P_NIL) && (*p_in_subaddress != '\0')) {
		*(p_out_address + size - 1) = CC_SUB_ADDRESS_DELIMITER;
		Strcpy_far (p_out_address + size, (char FAR *)p_in_subaddress, ACU_MX_SZ_CALLED_SUB_ADD +1);
	}
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            strcmp_reverse

Description     compares two strings from the end of the strings.

Usage           uchar strcmp_reverse (s1, s2)

Return value    return code = OK if last digits of s1 and s2 match,
							  else NOK.

*--------------------------------------------------------------------------*/

uchar strcmp_reverse (p_s1, p_s2)
	uchar FAR *p_s1;
	uchar FAR *p_s2;
{
	uchar				s1_lgth;
	uchar				s2_lgth;
	uchar				min_lgth;
	register uchar FAR *p_current_s1;
	register uchar FAR *p_current_s2;

	if (*p_s1 == 0 || *p_s2 == 0) {
		return (NOK);
	}

		/* Search for the end of the two strings */

	p_current_s1 = p_s1;
	while (*p_current_s1++); s1_lgth = p_current_s1 - p_s1; p_current_s1 -= 2;

	p_current_s2 = p_s2;
	while (*p_current_s2++); s2_lgth = p_current_s2 - p_s2; p_current_s2 -= 2;

	min_lgth = Min (s1_lgth, s2_lgth) - 1;	/* -1 to exclude trailing 0 */

		/* Begin comparison */

	while ((*p_current_s1-- == *p_current_s2--) && (--min_lgth > 0));

		/* If all (i.e. min_lgth) digits are equal, then s1 and s2 match */

	return ((min_lgth == 0) ? OK : NOK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_address_filtering

Description     searches for corresponding
				address/sub-address in the NA address/services list,
				and if not found in the auxiliary list, processes
				address filtering if configured so.

Usage           char cc_address_filtering ()

Return value    'x_local_nb' if address found,
				-1 if not.

Common constants and declarations : cc.h

Common objects : p_cc_na, cc_interworking.

*--------------------------------------------------------------------------*/

signed char cc_address_filtering (x_local_nb)
signed char x_local_nb;		/* index of the local number (services list associated) */
{

		/*
			Address is present : search matching number in auxiliary
			address/services associations list first.
		*/

	for (; x_local_nb < Cc_na_local_nb_service_nb; x_local_nb++) {

		if (cc_test_address_match (x_local_nb) == OK) {

				/* Address matches */

#			if SIMULATION == ON
				pr_cc_x_address_list (x_local_nb);
#			endif

				/* test if B channel matches */

			if (cc_test_chan_id_match (x_local_nb) == OK) {

					/* B channel matches also : OK */

				return (x_local_nb);
			}

				/* B channel does not match : try next list */

		}

	}

#	if CC_ADDRESS_FILTERING == ON

			/*
				No additional local number-services association match,
				ensure conformance with the default local number if needed
			*/

		if ((Cc_na_priority(0) == CC_PRIORITY_DISABLE) ||
			(cc_test_address_match (0) == NOK)
		   ) {

				/* Address doesn't match */

			return (-1);
		}

			/*
				Address matches
				or configuration's address is NIL (no address filtering) :
				filtering is OK.
			*/

#		if SIMULATION == ON
			pr_cc_x_address_list (0);
#		endif

			/* test if B channel matches */

		if (cc_test_chan_id_match (0) == NOK) {

				/* B channel does not match */

			return (-1);
		}

#	endif

	return (0);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_test_chan_id_match

Description     tests if received B chan_id
				matches one of the registered NA addresses.

Usage           uchar cc_test_chan_id_match (x_local_nb)
				char x_local_nb : index of the address/service association
				to be compared with the received address.

Return value    return code = OK if chan_id matches,
							  NOK if not.

Common objects : p_cc_na, cc_chan_id[].

*--------------------------------------------------------------------------*/

uchar cc_test_chan_id_match (x_local_nb)
signed char x_local_nb;		/* index of the local number (services list associated) */
{

	if ((Cc_na_b_chan_id (x_local_nb) != NO_CHAN) &&
		(Cc_na_b_chan_id (x_local_nb) != cc_chan_id[0])
	   ) {

			/* B channel does not match */

#		if SIMULATION == ON
			pr_cc_wrong_b_chan ();
#		endif

		return (NOK);

	} else {

		return (OK);
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_test_address_match

Description     tests if received address/sub-address
				matches one of the registered NA addresses.

Usage           uchar cc_test_address_match (x_local_nb)
				char x_local_nb : index of the address/service association
				to be compared with the received address.

Return value    return code = OK if address matches, or if the registered
							  address is NIL.
							  NOK if not.

Common objects : p_cc_na,          cc_interworking,
				 p_called_nb,      cc_called_nb_size,
				 p_called_sub_add, cc_called_sub_add_size.

*--------------------------------------------------------------------------*/

uchar cc_test_address_match (x_local_nb)
signed char x_local_nb;
{

	if (*Cc_na_a_local_nb (x_local_nb) != '\0') {

		if (p_called_nb == P_NIL) {
			return (NOK);
		}

			/* Test matching in reverse order */

		if (strcmp_reverse ((uchar FAR *)Cc_na_a_local_nb (x_local_nb), p_called_nb) == NOK) {

				/* address doesn't match */

			return (NOK);
		}

			/*
				Address present and match : Test sub-address.
			*/
	}

#	if CC_CALLED_SUB_ADD == ON

			/* Sub-address testing to be done ? */

		if (*Cc_na_a_local_sub_add (x_local_nb) != '\0') {

			if (p_called_sub_add == P_NIL) {

					/*
						No sub-address received :
						if an interworking situation occured, then ACCEPT
						else reject.
					*/

				if (cc_interworking == ON) {
					return (OK);

				} else {

					return (NOK);
				}
			}

				/* Sub-address is present : Test exact matching */

			if (Strcmp_far ((char FAR *)Cc_na_a_local_sub_add (x_local_nb), (char FAR *)p_called_sub_add)) {
				return (NOK);
			}

				/*
					Sub-address present and match :
				*/

		}

#	endif

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_strlen

Description     get string length

Usage           short cc_strlen (char FAR *p_str)

Return value	Returns the number of characters in p_str, not counting the
				terminating null character.

*--------------------------------------------------------------------------*/

short cc_strlen (p_str)
register char FAR *p_str;
{
	register short sz = 0;
	while (*p_str++ != 0) sz++;
	return (sz);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_restart_chan_id

Description     implements the restart of the channel
				ID.

Usage           uchar cc_restart_chan_id (flag);
					flag = ON	: send a RESTART_RQ
					flag = OFF	: don't send a RESTART_RQ

Return value	: OK

*--------------------------------------------------------------------------*/

#if CC_RESTART_PROCEDURE == ON

uchar cc_restart_chan_id (flag)
	uchar flag;
{
#	if ACU_INTERFACE == ON
		uchar FAR *p_data;
#	endif

#	if CC_INTERFACE == ON
		uchar FAR *p_cc_data;
#	endif

	cc_current_conn_id = Cc_call_conn_id;

	if (flag == ON) {
		cc_snd_to_ns (NS_RESTART_RQ);
	}

	cc_current_ent_user  = Cc_call_ent_user;
	cc_current_sapi_user = Cc_call_sapi_user;

	switch (cc_current_sapi_user) {

#	  if CC_INTERFACE == ON

		case CC_SAPI :
			Cc_alloc_data  (Cc_hook_on_co_size);

			Cc_hook_on_co_cause_class = C_C_RESTART;
			Cc_hook_on_co_cause_val   = C_V_RESTART;

			cc_snd_to_user (CC_HOOK_ON_CO);
			break;
#	  endif

#	  if ACU_INTERFACE == ON

		case ACU_SAPI :

			Acu_alloc_data (Acu_clear_co_size);
			Acu_clear_co_network_cause = C_v_user (C_C_RESTART, C_V_RESTART);
			cc_snd_to_user (ACU_CLEAR_CO);
			break;
#	  endif

	}

	Cc_call_clear ();

	return (OK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_charging_value_from_ns

Description     get the charging IE fields.

Usage           void cc_read_charging_value_from_ns (prim_code);

Return value    none

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

#if CC_PAR_CHARGING_INFO == ON

void cc_read_charging_value_from_ns (prim_code)
	code_t prim_code;
{
	uchar lgth, i;

		/* Get charging info from charging IE */

	cc_charging = 0;

	if (Net_get_ie (prim_code, IE_CHARGING) == PRESENT) {

		lgth = Net_isdn_lgth_str (prim_code, IE_CHARGING);

		for (i = 0; i < lgth; i++) {
			cc_charging += (long)Net_isdn_get_val (prim_code, IE_CHARGING, (uchar)(FLD_CHARGING_VAL1 + i)) << (8*i);
		}

		cc_charging_type	= Net_isdn_get_val (prim_code, IE_CHARGING, FLD_CHARGING_TYPE);
		cc_charging_period	= Net_isdn_get_val (prim_code, IE_CHARGING, FLD_CHARGING_PERIOD);
		cc_charging_multi	= Net_isdn_get_val (prim_code, IE_CHARGING, FLD_CHARGING_MULTI);
	}

#	if CC_SPF_FAC == ON

			/* Or from Specific-Facility IE if provided */

		if (Spf_fac_used == ON) {

			if (Net_get_ie (prim_code, IE_SPF_FAC) == PRESENT) {

				if ((Net_isdn_get_val (prim_code, IE_SPF_FAC, FLD_ACTION)  == FT_SPF_FAC_IN_TX) &&
					((Net_isdn_get_val (prim_code, IE_SPF_FAC, FLD_CODE)   == FT_SPF_FAC_CHARGING) ||
					 (Net_isdn_get_val (prim_code, IE_SPF_FAC, FLD_CODE)   == FT_SPF_FAC_CHARGING_TOTAL))) {
					Net_isdn_get_val (prim_code, IE_SPF_FAC, FLD_CHARGING);
					cc_charging_type = 0;	/* not ACU_BYTE_VAL_NIL to mark it as available */
				}

			}

		}

#	endif

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_date_time_from_ns

Description     get the 'Date_time' IE fields.

Usage           void cc_read_date_time_from_ns (prim_code);

Return value    none

Common constants and declarations : cc.h

Common objects : cc_date_time internal structure.

*--------------------------------------------------------------------------*/

#if CC_PAR_DATE_TIME == ON

void cc_read_date_time_from_ns (prim_code)
	code_t prim_code;
{

	if (Net_get_ie (prim_code, IE_DATE_TIME) == PRESENT) {
		Net_isdn_get_val (prim_code, IE_DATE_TIME, FLD_NIL);
		cc_date_time.available = ON;

	} else {

		cc_date_time.available = OFF;
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_check_network

Description     check network operator consistancy

Usage           uchar cc_check_na_network (cc_net, na_net);

Return value    CC_CFG_OK or CC_CFG_ERR_...

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

uchar cc_check_network (na_op, cc_op, na_country, cc_country)
	uchar	na_op;
	uchar	cc_op;
	ushort	na_country;
	ushort	cc_country;
{

#	if ASSERT == ON

		if (na_op == 255) {
			na_op = 0;
		}
		if (cc_op == 255) {
			cc_op = 0;
		}
		if (cc_country == 0xffff) {
			cc_country = 0;
		}
		if (na_country == 0xffff) {
			na_country = 0;
		}

#	endif


	if (na_country == NIL) {

		if (cc_country == NIL) {

			/*
			 * No country was specified in the NA and CC config,
			 * => set the default value.
			 */

			na_country	= CC_COUNTRY;

		} else {

			/*
			 * No country was specified at the NA level,
			 * => set the CC value.
			 */

			na_country = cc_country;
		}
	}

	if (na_op == NIL) {

		if (cc_op == NIL) {

			/*
			 * No operator was specified in the NA and CC config,
			 * => set the default value.
			 */

			na_op = CC_OPERATOR;

		} else {

			/*
			 * No operator was specified at the NA level.
			 * => Set na_op to cc_op.
			 */

			na_op = cc_op;
		}
	}

	Cc_na_network = cc_get_network (na_op, na_country);
	Cc_na_country = na_country;

	if (ret_code != CC_CFG_OK) {
		return (ret_code);
	}

#	if CC_ONE_NETWORK == ON

		if ((cc_operator != NO_OPERATOR_DEFINED) && (cc_operator != cc_select_op)) {

				/*
				 * 2 different networks were set in the config.
				 * This is prohibited since ONE_NETWORK was set to ON.
				 */

			return (CC_CFG_ERR_NA_OPERATOR);
		}

			/*
			 * cc_select_op was initialized in get_network function.
			 * Save it in the 'cc_operator' variable.
			 */

		cc_operator = cc_select_op;

#	endif

	return (CC_CFG_OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			cc_get_network

Description     from the operator and the country,
				return the according network.

Usage            	uchar cc_get_network ();

Return value :		the network identifier.
					'ret_code' global variable is set if an error is detected.

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

#define MX_COUNTRY_NET_OP	8

struct country_net {
	ushort country;
	uchar  op[MX_COUNTRY_NET_OP];
};

CONST_ARRAY struct country_net t_cc_country_net[] = {

/* country		default op	other1		other2		other3 		other4 		other 5 	other 6 */

{AUSTRALIA,		{AUSTEL_1,	ETSI}},
{BELGIUM,		{BG_V1,		ETSI,		FT_VN6}},
{FRANCE,		{FT_VN3,	FT_VN2,		FT_VN6}},
{GERMANY,		{DT_1TR6,	ETSI}},
{JAPAN,			{NTT,		KDD}},
{SWEDEN,		{SWD_TVKT,	ETSI}},
{UK,			{ETSI,		BT_ISDN2}},
{USA,			{NT_DMS100,	N_ISDN1,	N_ISDN2,	ATT_5E5,	ATT_5E9,	ATT_5E10, BELLCORE_PRI, ATT_4ESS}},
{HONG_KONG,		{HK_TEL, 	ETSI}},
{EUROPE,		{ETSI,		ECMA_QSIG,	FT_VN6}},
{SOUTH_AFRICA,	{ETSI}},
{COUNTRY_NIL,   {CTU_CDS,	CTU_BS}},
{0},

};

	/*
		Table giving the address of the variable used to identify the
		operators.

		WARNING: the order must fit the definitions given in services.h
	*/

uchar * PIC_CONST_ARRAY t_cc_operator_var[] = {
	P_NIL,
	Pic_address (&cc_vn2),
	Pic_address (&cc_vn3),
	Pic_address (&cc_vn6),
	Pic_address (&cc_tr6),
	Pic_address (&cc_bt2),
	Pic_address (&cc_at5),
	Pic_address (&cc_at9),
	Pic_address (&cc_dms),
	Pic_address (&cc_ntt),
	Pic_address (&cc_kdd),
	Pic_address (&cc_ets),
	Pic_address (&cc_bv1),
	Pic_address (&cc_ni1),
	Pic_address (&cc_swd),
	Pic_address (&cc_au1),
	Pic_address (&cc_qsi),
	Pic_address (&cc_hkt),
	P_NIL,						/* 'drv' not implemented yet */
	Pic_address (&cc_bip),
	Pic_address (&cc_ni2),
	Pic_address (&cc_a17),
	Pic_address (&cc_a11),
	Pic_address (&cc_e10),
	Pic_address (&cc_at4),
};

#if OM_CODE_TYPE == OM_PIC

void pic_init_t_cc_operator_var (void)
{
	Pic_init_index ();

	Pic_index++;	/* first entry is P_NIL */
	Pic_init_array (t_cc_operator_var, &cc_vn2);
	Pic_init_array (t_cc_operator_var, &cc_vn3);
	Pic_init_array (t_cc_operator_var, &cc_vn6);
	Pic_init_array (t_cc_operator_var, &cc_tr6);
	Pic_init_array (t_cc_operator_var, &cc_bt2);
	Pic_init_array (t_cc_operator_var, &cc_at5);
	Pic_init_array (t_cc_operator_var, &cc_at9);
	Pic_init_array (t_cc_operator_var, &cc_dms);
	Pic_init_array (t_cc_operator_var, &cc_ntt);
	Pic_init_array (t_cc_operator_var, &cc_kdd);
	Pic_init_array (t_cc_operator_var, &cc_ets);
	Pic_init_array (t_cc_operator_var, &cc_bv1);
	Pic_init_array (t_cc_operator_var, &cc_ni1);
	Pic_init_array (t_cc_operator_var, &cc_swd);
	Pic_init_array (t_cc_operator_var, &cc_au1);
	Pic_init_array (t_cc_operator_var, &cc_qsi);
	Pic_init_array (t_cc_operator_var, &cc_hkt);
	Pic_index++;	/* P_NIL entry, 'drv' not implemented yet */
	Pic_init_array (t_cc_operator_var, &cc_bip);
	Pic_init_array (t_cc_operator_var, &cc_ni2);
	Pic_init_array (t_cc_operator_var, &cc_a17);
	Pic_init_array (t_cc_operator_var, &cc_a11);
	Pic_init_array (t_cc_operator_var, &cc_e10);
	Pic_init_array (t_cc_operator_var, &cc_at4);
}

#endif

uchar cc_get_network (op, country)
	uchar	op;
	ushort	country;
{
	CONST struct country_net	*p_country_net;
	uchar						i;

		/* Search for the 'country' in the 't_cc_country_net' table */

	p_country_net = (struct country_net *)&t_cc_country_net [0];

	while ((p_country_net -> country != 0) && (p_country_net -> country != country)) {

		p_country_net++;
	}

	if (p_country_net -> country == 0) {

			/* country not found : select the cc_par.h one */

		country = CC_COUNTRY;
		op      = CC_OPERATOR;

	} else {

			/* Search for the operator in the list */

		i=0;

		do {

			if (p_country_net -> op[i] == op) break;

			i++;

		} while (! ((i == MX_COUNTRY_NET_OP) || (p_country_net -> op[i] == 0)));

		if ((i == MX_COUNTRY_NET_OP) || (p_country_net -> op[i] == 0)) {

				/* operator not found : force default one */

			op = p_country_net -> op[0];

		}

	}

	cc_select_op = op;

	if (*(t_cc_operator_var[op]) == NIL) {

		*(t_cc_operator_var[op]) = cc_get_net_idx (op);
	}

#	if RESET_CONFIG == ON

			/* Increment the nb of times a specification has been chosen */

		Cc_net_table_nb_time (cc_select_op)++;

#	endif

	return (*(t_cc_operator_var[op]));
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				cc_get_net_idx

Description         get network index

Usage            	uchar cc_get_net_idx (op);

Return value :		current network index
					'ret_code' global variable is set if an error is detected.

*--------------------------------------------------------------------------*/

uchar cc_get_net_idx (op)
	uchar op;
{

	uchar ret_net_idx;								/* return code */

#	if RESET_CONFIG == ON
		uchar x_op;									/* loop index */
#	endif

	if (Cc_net_table_presence (op) == OFF) {
		ret_code = CC_CFG_ERR_OP_NOT_COMPILED;
		return (0);
	}

#	if RESET_CONFIG == ON

			/* Is there one index no more used ? (due to reset config) */

		x_op = 1;

		do {

			if ((Cc_net_table_config (x_op) == ON) 	&&
				(Cc_net_table_nb_time (x_op) == 0)) {

					/* Reset the 'config done' flag for the old one */

				Cc_net_table_config (x_op)	= OFF;

					/* Reset the 'config done' flag for current one (op) */

				Cc_net_table_config (op)	= OFF;

					/* Set the available network index */

				ret_net_idx	= Cc_net_table_idx (x_op);

					/* Reset the 'net_idx' flag */

				Cc_net_table_idx (x_op) = NIL;
				break;
			}

			x_op++;

		} while (x_op < MX_OPERATOR_NB);

			/* Previous search failed ? */

		if (x_op == MX_OPERATOR_NB) {

				/*
				 * - Yes.
				 * Allocate a new net_idx which must be different from
				 * those already in use.
				 */

			cc_net_idx = 1;

			do {

				x_op = 1;

				do {

					if ((Cc_net_table_config (x_op) == ON) 	&&
						(Cc_net_table_nb_time (x_op) > 0)) {

							/* This 'x_op' is in use */

						if (cc_net_idx == Cc_net_table_idx (x_op)) {

								/*
								 * net_idx is already used
								 *	--> Get another one.
								 */

							break;
						}
					}

				} while (++x_op < MX_OPERATOR_NB);

				if (x_op == MX_OPERATOR_NB) {

						/*
						 * We did not find a index wich equals
						 * 'net_idx' --> We keep it.
						 */

					break;
				}

					/* Try another net_idx */

			} while (++cc_net_idx < MX_OPERATOR_NB);

			ret_net_idx = cc_net_idx;
		}

#	else

		ret_net_idx = ++cc_net_idx;

#	endif

	if (ret_net_idx > CC_NETWORK_NB) {

		ret_code = CC_CFG_ERR_TOO_MANY_OP;
		return (0);
	}

#	if RESET_CONFIG == ON
		Cc_net_table_idx (op) = ret_net_idx;
#	endif

	return (ret_net_idx);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				cc_dec_net_idx -

Usage            	uchar cc_dec_net_idx (net_idx);

Return value :		OK/NOK

*--------------------------------------------------------------------------*/

#if RESET_CONFIG == ON

uchar cc_dec_net_idx (net_idx)
	uchar net_idx;
{

	uchar i;

	i = 1;

	do {

		if (Cc_net_table_idx (i) == net_idx) {

				/* Decrement the nb of times the specification is used */

			if (Cc_net_table_nb_time (i) > 0) {
				Cc_net_table_nb_time (i)--;
			}

			if (Cc_net_table_nb_time (i) == 0) {

					/*
					 * That specification is no longer in use,
					 * reset its index.
					 */

				*(t_cc_operator_var[i]) = NIL;

#				if CC_ONE_NETWORK == ON

						/* Reset the 'net_idx' */

					cc_net_idx = NIL;

						/* Reset the 'operator' for cc_check_network function */

					cc_operator	= NO_OPERATOR_DEFINED;

#				endif
			}

			return (OK);
		}

	} while (++i < MX_OPERATOR_NB);

	return (NOK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_build_fct

Description     init of CC network table.

Usage           void cc_build_fct ();

Return value    none

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

void cc_build_fct (op)
	uchar op;

{

	if (Cc_net_table_config (op) == OFF) {

#		if CC_F_A11 == ON
			a11_cc_build_fct	();
#		endif

#		if CC_F_A17 == ON
			a17_cc_build_fct	();
#		endif

#		if CC_F_AT4 == ON
			at4_cc_build_fct	();
#		endif

#		if CC_F_AT5 == ON
			at5_cc_build_fct	();
#		endif

#		if CC_F_AT9 == ON
			at9_cc_build_fct	();
#		endif

#		if CC_F_E10 == ON
			e10_cc_build_fct	();
#		endif

#		if CC_F_AU1 == ON
			au1_cc_build_fct	();
#		endif

#		if CC_F_BIP == ON
			bip_cc_build_fct	();
#		endif

#		if CC_F_BT2 == ON
			bt2_cc_build_fct	();
#		endif

#		if CC_F_BV1 == ON
			bv1_cc_build_fct	();
#		endif

#		if CC_F_DMS == ON
			dms_cc_build_fct	();
#		endif

#		if CC_F_ETS == ON
			ets_cc_build_fct	();
#		endif

#		if CC_F_KDD == ON
			kdd_cc_build_fct	();
#		endif

#		if CC_F_NI1 == ON
			ni1_cc_build_fct	();
#		endif

#		if CC_F_NI2 == ON
			ni2_cc_build_fct	();
#		endif

#		if CC_F_NTT == ON
			ntt_cc_build_fct	();
#		endif

#		if CC_F_SWD == ON
			swd_cc_build_fct	();
#		endif

#		if CC_F_QSI == ON
			qsi_cc_build_fct	();
#		endif

#		if CC_F_HKT == ON
			hkt_cc_build_fct	();
#		endif

#		if CC_F_TR6 == ON
			tr6_cc_build_fct	();
#		endif

#		if CC_F_VN2 == ON
			vn2_cc_build_fct	();
#		endif

#		if CC_F_VN3 == ON
			vn3_cc_build_fct	();
#		endif

#		if CC_F_VN6 == ON
			vn6_cc_build_fct	();
#		endif

		Cc_net_table_config (op) = ON;
	}

}

/*-------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_reset_op_idx

Description     Reset operator indexes

Usage           void cc_reset_op_idx  ();

Return value	ON/OFF
*--------------------------------------------------------------------------*/

void cc_reset_op_idx ()
{

	uchar i;

	cc_swd = 							/* index for SWD_TVKT	operator */
	cc_bv1 = 							/* index for BG_V1		operator */
	cc_au1 = 							/* index for AUSTEL_1	operator */
	cc_bip = 							/* index for BELLCORE	operator */
	cc_tr6 = 							/* index for DT_1TR6	operator */
	cc_vn2 = 							/* index for FT_VN2		operator */
	cc_vn3 = 							/* index for FT_VN3		operator */
	cc_vn6 = 							/* index for FT_VN6		operator */
	cc_ets = 							/* index for ETSI		operator */
	cc_at4 = 							/* index for ATT_4ESS	operator */
	cc_at5 = 							/* index for ATT_5E5	operator */
	cc_at9 = 							/* index for ATT_5E9	operator */
	cc_e10 = 							/* index for ATT_5E10	operator */
	cc_bt2 = 							/* index for BT_ISDN2	operator */
	cc_dms = 							/* index for NT_DMS100	operator */
	cc_kdd = 							/* index for KDD 		operator */
	cc_ni1 = 							/* index for N_ISDN1	operator */
	cc_ni2 = 							/* index for N_ISDN2	operator */
	cc_ntt = 							/* index for NTT		operator */
	cc_hkt = 							/* index for HK_TEL		operator */
	cc_a11 = 							/* index for A11		operator */
	cc_a17 = 							/* index for A17		operator */
	cc_qsi = NIL;						/* index for ECMA_QSIG	operator */

	for (i = 0; i < MX_OPERATOR_NB; i++) {
		Cc_net_table_config(i)			= OFF;

#		if RESET_CONFIG == ON
			Cc_net_table_idx (i)		= NIL;
			Cc_net_table_nb_time(i)		= 0;
#		endif 
	}

	cc_net_idx		= NIL;					/* Number of implemented networks */
	cc_operator		= NO_OPERATOR_DEFINED;	/* to save the Cc_na_network in order to check the consistancy of the config. */
	cc_select_op	= NIL;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_build_p_table

Description     init of CC network table.

Usage           uchar cc_build_p_table ();

Return value :	OK/NOK

Common constants and declarations : cc.h

Common objects : CC global variables.

*--------------------------------------------------------------------------*/

uchar cc_build_p_table ()
{

	p_cc_param				= (struct cc_param 					*)Spf_cc_param_tab		(Cc_na_network);
	p_cc_uchar_fct_table	= (struct cc_uchar_fct_table		*)Spf_cc_uchar_fct		(Cc_na_network);
	p_cc_uchar_fct_1p_table	= (struct cc_uchar_fct_1p_table		*)Spf_cc_uchar_fct_1p	(Cc_na_network);
	p_cc_uchar_fct_2uc_table= (struct cc_uchar_fct_2uc_table 	*)Spf_cc_uchar_fct_2uc	(Cc_na_network);
	p_cc_uchar_fct_3uc_table= (struct cc_uchar_fct_3uc_table 	*)Spf_cc_uchar_fct_3uc	(Cc_na_network);
	p_cc_p_fct_2uc_table	= (struct cc_p_fct_2uc_table 		*)Spf_cc_p_fct_2uc		(Cc_na_network);

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_ext_llc_from_ns

Description     get the 'LLC' IE fields (extended ACU only).

Usage           void cc_read_ext_llc_from_ns (prim_code);

Return value    none

Common constants and declarations : cc.h

Common objects : cc_ext_llc internal structure.

*--------------------------------------------------------------------------*/

#if ACU_PAR_EXT_LLC == ON

void cc_read_ext_llc_from_ns (prim_code)
	code_t prim_code;
{

	if (Net_get_ie (prim_code, IE_LLC) == PRESENT) {
		Net_isdn_get_val (prim_code, IE_EXT_LLC, FLD_NIL);
		cc_ext_llc.hdr.id   = ACU_EXT_LLC;
		cc_ext_llc.hdr.lgth = Acu_ext_llc_size;

	} else {

		cc_ext_llc.hdr.lgth = 0;
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_ext_facility_from_ns

Description     read the 'Facility' IE fields (extended ACU only).

Usage           void cc_read_ext_facility_from_ns (prim_code);

Return value    none

Common constants and declarations : cc.h

*--------------------------------------------------------------------------*/

#if _ACU_PAR_EXT_FACILITY == ON /* { */

#	include "cc_undef.h"
#	include "ns_mac.h"
#	include "cc_undef.h"	/* restore ns_par.h flags */
	Isdn_ctx_ext;

void cc_read_ext_facility_from_ns (prim_code)
	code_t prim_code;
{
	uchar			comp_tag;			/* tag of current component */
	ns_ss_inv_id_t	invoke_id;			/* invoke id */
	ns_ss_op_id_t	op_err_pb_id;		/* identifier of operation */

	if (Cc_param_ETSI_ASN1_fac_support == OFF) {
		return;
	}

	if (Net_get_ie (prim_code, IE_FACILITY) == PRESENT) {

			/* Get the complete ASN1 facility element */

#		if ACU_PAR_EXTENDED_PRIM == ON
			cc_add_i_ext_fac_asn1 (p_cc_ext_fac_asn1, cc_ext_fac_asn1_lgth, cc_ext_fac_asn1_comp_nb);
#		endif

			/*
				The 'Isdn_get_ss_first_component()' macro has been called
				within Net_get_ie() function.
			*/

		while (1) {	/* loop on all components within facility IE */

			comp_tag     = Isdn_get_ss_comp_val (component_tag);
			invoke_id    = Isdn_get_ss_comp_val (invoke_id);
			op_err_pb_id = Isdn_get_ss_comp_val (op_err_pb_identifier);

				/* Process a component tag handled locally by CC first */

			if (cc_ext_fac_local_process (comp_tag, invoke_id) == CONTINUE) {

					/* Not a local tag; process according to the component tag */

				switch (comp_tag) {

					case FAC_INVOKE :
						cc_ext_fac_process_op (comp_tag, invoke_id, op_err_pb_id);
						break;

					case FAC_RETURN_RESULT :

						if (Isdn_get_ss_comp_val (inv_or_lk_id_or_res_presence) == ABSENT) {
								/* no data in RESULT */
							break;
						}

						cc_ext_fac_process_op (comp_tag, invoke_id, op_err_pb_id);
						break;

					case FAC_RETURN_ERROR :
#						if ACU_PAR_EXTENDED_PRIM == ON
							cc_add_i_ext_fac_return_err (invoke_id, op_err_pb_id);
#						endif
						break;

					case FAC_REJECT :
#						if ACU_PAR_EXTENDED_PRIM == ON
							cc_add_i_ext_fac_reject (Isdn_get_ss_comp_val (inv_or_lk_id_or_res_presence),
													 invoke_id,
													 Isdn_get_ss_comp_val (lk_id_or_pb_tag),
													 op_err_pb_id
													);
#						endif
						break;
				}

			}

				/* More components to be processed ? */

			if (!Isdn_ss_is_next_component()) {
				break;		/* no more component: exit */
			}

			Isdn_get_ss_next_component();	/* point to next component */

		}	/* end of loop on all components inside current IE instance */

	}

}

#endif /* _ACU_PAR_EXT_FACILITY == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_ext_fac_local_process

Description     read the 'Facility' IE fields (extended ACU only).

Usage           uchar cc_ext_fac_local_process (comp_tag, invoke_id, op_id)

Return value	CONTINUE if the component has not been processed
				STOP otherwise

*--------------------------------------------------------------------------*/

#if _ACU_PAR_EXT_FACILITY == ON /* { */

static uchar cc_ext_fac_local_process (comp_tag, invoke_id)
	uchar           comp_tag;	/* component tag */
	ns_ss_inv_id_t	invoke_id;	/* invoke id */
{

#	if NS_SS_ECT == ON /* Explicit Call Transfer SS supported */

			/* if the received invoke_id is the one of the
			   ECT facility currently requested by CC then
			   free it, otherwise it is a facility directly
			   requested by the application.
			   (Note: 0 means 'not used by CC')
			*/

		if ((invoke_id == Cc_call_asn1_invoke_id) && (invoke_id != 0)) {

			if (comp_tag != FAC_INVOKE) {
/*???*/
				Cc_par_free_asn1_invoke_id (cc_current_conn_id, invoke_id);
				return (STOP);	/* component processed completed */
			}
		}

#	endif

	return (CONTINUE);	/* not a CC-local facility */
}

#endif /* _ACU_PAR_EXT_FACILITY == ON } */

/*------------*/

#if _ACU_PAR_EXT_FACILITY == ON /* { */

static void cc_ext_fac_process_op (comp_tag, invoke_id, op_id)
	uchar           comp_tag;	/* component tag */
	ns_ss_inv_id_t	invoke_id;	/* invoke id */
	ns_ss_op_id_t	op_id;		/* identifier of operation */
{

	if (!Isdn_ss_is_op_data()) {

		/* NO operation data */

	} else {

		Isdn_get_ss_a_op_data();	/* Point to operation data */

			/* process data according to operation ID */

		switch (op_id) {

#			if ACU_PAR_EXT_CUG == ON /* Closed User Group SS supported */
				case NS_OP_CUG_CALL :
					cc_add_i_ext_cug (invoke_id);
					break;
#			endif

			default:
				break;
		}

	}

}

#endif /* _ACU_PAR_EXT_FACILITY == ON } */

/*------------*/

#if ACU_PAR_EXTENDED_PRIM == ON /* { */

void cc_add_i_ext_fac_asn1 (p_from, lgth, component_nb)
	uchar FAR *p_from;	/* address of ASN1 facility */
	ushort lgth;		/* ASN1 facility length */
	ushort component_nb;/* nb of components in the facility */
{
	uchar FAR *p_ext_data;

		/* point to current internal extended data buffer */

	p_ext_data   = p_cc_i_ext;

		/* Load extended values */

	Acu_ext_id   = ACU_EXT_FAC_ASN1;
	Acu_ext_lgth = lgth + Acu_ext_fac_asn1_size;
	Acu_ext_fac_asn1(component_nb) = component_nb;
	p_cc_i_ext  += Acu_ext_fac_asn1_size;

	Memcpy_far ((char FAR *)p_cc_i_ext, (char FAR *)p_from, lgth);

		/* update internal extended data buffer pointer */


	p_cc_i_ext    += lgth;
	cc_i_ext_lgth += lgth + Acu_ext_fac_asn1_size;
	cc_i_ext_nb++;

}

#endif /* ACU_PAR_EXTENDED_PRIM == ON } */

/*------------*/

#if ACU_PAR_EXTENDED_PRIM == ON /* { */

static void cc_add_i_ext_fac_return_err (invoke_id, error_id)
	ns_ss_inv_id_t	invoke_id;	/* invoke id */
	ns_ss_op_id_t	error_id;	/* identifier of error */
{
	uchar FAR *p_ext_data;

		/* point to current internal extended data buffer */

	p_ext_data   = p_cc_i_ext;

		/* Load extended values */

	Acu_ext_id   = ACU_EXT_FAC_RETURN_ERR;
	Acu_ext_lgth = Acu_ext_fac_return_err_size;

	Acu_ext_fac_return_err (invoke_id) = invoke_id;
	Acu_ext_fac_return_err (error_id)  = error_id;

		/* update internal extended data buffer pointer */

	p_cc_i_ext    += Acu_ext_fac_return_err_size;
	cc_i_ext_lgth += Acu_ext_fac_return_err_size;
	cc_i_ext_nb++;

}

#endif /* ACU_PAR_EXTENDED_PRIM == ON } */

/*------------*/

#if ACU_PAR_EXTENDED_PRIM == ON /* { */

static void cc_add_i_ext_fac_reject (present, invoke_id, pb_type, pb_val)
	uchar			present;	/* invoke_id present ? */
	ns_ss_inv_id_t	invoke_id;	/* invoke id */
	uchar			pb_type;	/* problem type */
	uchar			pb_val;		/* problem value */
{
	uchar FAR *p_ext_data;

		/* point to current internal extended data buffer */

	p_ext_data   = p_cc_i_ext;

		/* Load extended values */

	Acu_ext_id   = ACU_EXT_FAC_REJECT;
	Acu_ext_lgth = Acu_ext_fac_reject_size;

	Acu_ext_fac_reject (present)   = present;
	Acu_ext_fac_reject (invoke_id) = invoke_id;
	Acu_ext_fac_reject (pb_type)   = pb_type;
	Acu_ext_fac_reject (pb_val)    = pb_val;

		/* update internal extended data buffer pointer */

	p_cc_i_ext    += Acu_ext_fac_reject_size;
	cc_i_ext_lgth += Acu_ext_fac_reject_size;
	cc_i_ext_nb++;

}

#endif /* ACU_PAR_EXTENDED_PRIM == ON } */

/*------------*/

#if ACU_PAR_EXT_CUG == ON /* Closed User Group SS supported { */

static void cc_add_i_ext_cug (invoke_id)
	ns_ss_inv_id_t	invoke_id;	/* invoke id */
{
	uchar FAR *p_ext_data;

		/* point to current internal extended data buffer */

	p_ext_data   = p_cc_i_ext;

		/* Load extended values */

	Acu_ext_id   = ACU_EXT_CUG;
	Acu_ext_lgth = Acu_ext_cug_size;

	Acu_ext_cug(invoke_id)     = invoke_id;
	Acu_ext_cug(out_access_rq) = Isdn_get_cug_call_arg (out_access_rq);
	Acu_ext_cug(index)         = Isdn_get_cug_call_arg (cug_index);

		/* update internal extended data buffer pointer */

	p_cc_i_ext    += Acu_ext_cug_size;
	cc_i_ext_lgth += Acu_ext_cug_size;
	cc_i_ext_nb++;

}

#endif /* ACU_PAR_EXT_CUG == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_cug_from_ns

Description     read the CUG facility IE fields (extended ACU only).

Usage           void cc_read_cug_from_ns (prim_code);

Return value    none

Common constants and declarations :

*--------------------------------------------------------------------------*/

#if ACU_PAR_EXT_CUG == ON /* { */

void cc_read_cug_from_ns (prim_code)
	code_t prim_code;
{

	if (Cc_na_network != cc_tr6) {
		return;	/* TR6-specific processing */
	}

	if (Net_get_ie (prim_code, IE_FACILITY) == PRESENT) {

			/* get CUG facility fields */

		Net_isdn_get_val (prim_code, IE_FACILITY, FLD_NIL);
	}

}

#endif /* ACU_PAR_EXT_CUG == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_ext_parms_from_acu

Description     read the extended parameters from an ACU primitive.

Usage           void cc_read_ext_parms_from_acu ();

Return value    none

Common constants and declarations : cc.h

Common objects : cc_ext_llc internal structure,
				 p_cc_ext_cug pointer.

*--------------------------------------------------------------------------*/

#if ACU_PAR_EXTENDED_PRIM == ON /* { */

#	if NEW_FCT_STYLE == ON
		void cc_read_ext_element_from_acu (uchar FAR *p_ext_data);
#	else
		void cc_read_ext_element_from_acu ();
#	endif

void cc_read_ext_parms_from_acu (p_data)
	uchar FAR *p_data;
{
	uchar FAR *p_ext_data;
	uchar i;

		/* Reset all global variables related to the extended parameters */

#if ACU_PAR_EXT_LLC == ON
	cc_ext_llc.hdr.lgth  = 0;
#endif

#if ACU_PAR_EXT_CUG == ON
	p_cc_ext_cug         = P_NIL;
#endif

	if (Acu_ext_descr_nb == 0) {
		return;
	}

		/* read each extended parameter */

	p_ext_data = Acu_ext_descr_address;

	for (i = Acu_ext_descr_nb; i > 0; i--) {
		cc_read_ext_element_from_acu (p_ext_data);
		p_ext_data += Acu_ext_lgth;
	}

		/* check that the general descriptor is coherent with each parameter */

	if ((p_ext_data - Acu_ext_descr_address) != Acu_ext_descr_lgth) {
		Trap (TRAP_CC_ERROR, "cc_read_ext_parms_from_acu");
	}

}

	/*----*/

void cc_read_ext_element_from_acu (p_ext_data)
	uchar FAR *p_ext_data;
{

	switch (Acu_ext_id) {

		case ACU_EXT_LLC :	/* LLC extended data */

#		  if ACU_PAR_EXT_LLC == ON

			if (Acu_ext_lgth != Acu_ext_llc_size) {
				Trap (TRAP_CC_ERROR, "cc_read_ext_element_from_acu(LLC)");
			}

			Memcpy_far ((char FAR *)&cc_ext_llc, (char FAR *)p_ext_data, Acu_ext_llc_size);

#		  endif

			break;

		case ACU_EXT_FAC_ASN1 :	/* ASN1 Facility extended data */

#		  if ACU_PAR_EXT_FAC_ASN1 == ON

				/* Set CC pointer to the Facility data */

			p_cc_ext_fac_asn1    = p_ext_data + Acu_ext_fac_asn1_size;
			cc_ext_fac_asn1_lgth = Acu_ext_lgth - Acu_ext_fac_asn1_size;

#		  endif

			break;

		case ACU_EXT_CUG :	/* CUG extended data */

#		  if ACU_PAR_EXT_CUG == ON

			if (Acu_ext_lgth != Acu_ext_cug_size) {
				Trap (TRAP_CC_ERROR, "cc_read_ext_element_from_acu(CUG)");
			}

				/* Set CC pointer to the CUG structure */

			p_cc_ext_cug = p_ext_data;

#		  endif

			break;

		default:
			Trap (TRAP_CC_ERROR, "cc_read_ext_element_from_acu(default)");
			break;

	}

}

#endif /* ACU_PAR_EXTENDED_PRIM == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_store_ext_data_in_acu_prim (a_end_strings)

Description     Stores all extended data in an ACU primitive.

Usage			cc_store_ext_data_in_acu_prim (p_data, a_end_strings);

Parameters		uchar FAR *p_data: address of the ACU primitive data area;
				uchar FAR *a_end_strings: address of current end of ACU primitive.

	!!! WARNING: this function must be called only after having stored ALL other
				 information in the ACU primitive.

*--------------------------------------------------------------------------*/

#if ACU_PAR_EXTENDED_PRIM == ON

void cc_store_ext_data_in_acu_prim (p_data, a_end_strings)
	uchar FAR *p_data;
	uchar FAR *a_end_strings;
{
	uchar FAR *p_ext_data;

	if ((cc_i_ext_nb == 0)
#		if ACU_PAR_EXT_LLC == ON
			&& (cc_ext_llc.hdr.lgth == 0)
#		endif
	   ) {

			/* no extended data to be stored */

		return;
	}

		/* Initialize the extended descriptor */

	p_ext_data = cc_init_acu_ext_descriptor (p_data, (uchar FAR *)a_end_strings);

#	if ACU_PAR_EXT_LLC == ON

			/* LLC extended data ? */

		if (cc_ext_llc.hdr.lgth != 0) {
			p_ext_data = cc_append_ext_data_to_acu (p_data, p_ext_data, (char FAR *)&cc_ext_llc, Acu_ext_llc_size, 1);
			cc_ext_llc.hdr.lgth = 0;	/* reset extended LLC */
		}

#	endif

		/* internal extended data (ASN1 facility or other) ? */

	if (cc_i_ext_nb != 0) {
		p_ext_data  = cc_append_ext_data_to_acu (p_data, p_ext_data, (char FAR *)&t_cc_i_ext[0], cc_i_ext_lgth, cc_i_ext_nb);
		cc_i_ext_nb = 0;				/* reset extended data */
	}

#	if ACU_PAR_EXT_FAC_ASN1 == ON
		cc_ext_fac_asn1_lgth = 0;		/* reset extended ASN1 facility */
#	endif

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			cc_init_acu_ext_descriptor

Description     initialises the ACU primitive extended data descriptor

Usage           p_ext_data = cc_init_acu_ext_descriptor (p_data,
														 p_ext_data);

Parameters		p_data: pointer to the ACU primitive data area;
				p_ext_data: pointer to the place where to store the extended
					data in the ACU primitive;

Return value    updated 'p_ext_data' parameter, to be used for call to
				'cc_append_ext_data_to_acu()' function.

*--------------------------------------------------------------------------*/

#if ACU_PAR_EXTENDED_PRIM == ON

uchar FAR *cc_init_acu_ext_descriptor (p_data, p_ext_data)
	uchar FAR *p_data;
	uchar FAR *p_ext_data;
{
	Acu_ext_descr_nb      = 0;
	Acu_ext_descr_lgth    = 0;
	Acu_ext_descr_address = p_ext_data;

	return (p_ext_data);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			cc_append_ext_data_to_acu

Description     appends an extended parameter to an ACU primitive.

Usage           p_ext_data = cc_append_ext_data_to_acu (p_data,
														p_ext_data,
														p_ext_from,
														ext_lgth,
														ext_nb);

Parameters		p_data: pointer to the ACU primitive data area;
				p_ext_data: pointer to the place where to store the extended
					data in the ACU primitive;
				p_from: address of the extended data to be stored;
				ext_lgth: lgth of the extended data to be stored;
				ext_nb: nb of extended elements contained in the extended data;

Return value    updated 'p_ext_data' parameter, to be used for next call to
				'cc_append_ext_data_to_acu()' function.

*--------------------------------------------------------------------------*/

#if ACU_PAR_EXTENDED_PRIM == ON

uchar FAR *cc_append_ext_data_to_acu (p_data, p_ext_data, p_from, ext_lgth, ext_nb)
	uchar FAR *p_data;
	uchar FAR *p_ext_data;
	char FAR  *p_from;
	ushort     ext_lgth;
	ushort     ext_nb;
{
	Acu_ext_descr_nb += ext_nb;
	Memcpy_far ((char FAR *)p_ext_data, p_from, ext_lgth);
	Acu_ext_descr_lgth += ext_lgth;

	return (p_ext_data + ext_lgth);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_store_ext_fac_asn1_in_ns_prim

Description     store the ASN1 facility given by the user into an NS
				primitive.

Usage           cc_store_ext_fac_asn1_in_ns_prim (first_component);
				first_component: 1 if the ASN1 facility to be stored
				is the first one in the primitive, 0 if not.

IMPORTANT NOTES:
				- the 'Isdn_ets_store_facility (prim)' macro must be
				  called before calling this function.
				- the 'Set_ns_last_component()' macro must be called after
				  this function.

Parameters		p_data: pointer to the ACU primitive data area;

Common constants and declarations : cc.h

Common objects: - p_cc_ext_fac_asn1: global pointer to ASN1 facility data to
				be stored;
				- cc_ext_fac_asn1_lgth: lgth of this data.
				- ns_int_ctx: NS interface context global variable.

*--------------------------------------------------------------------------*/

#if (ACU_PAR_EXT_FAC_ASN1 == ON) || (ACU_PAR_EXT_CUG == ON) /* { */

void cc_store_ext_fac_asn1_in_ns_prim (first_component)
	uchar first_component;
{

	if (cc_ext_fac_asn1_lgth != 0) {

		if (!first_component) {
			Set_ns_to_next_component ();
		}

			/* copy the ASN1 facility */

		Memcpy_far ((char FAR *)ns_int_ctx.p__ss_data,
					(char FAR *)p_cc_ext_fac_asn1,
					cc_ext_fac_asn1_lgth);

			/* Update NS context variables for next IEs */

		ns_int_ctx.p__val = ns_int_ctx.p__ss_data + cc_ext_fac_asn1_lgth;
		Align_struct_ns_p_val ();
	}

}

#endif /* (ACU_PAR_EXT_FAC_ASN1 == ON) || (ACU_PAR_EXT_CUG == ON) } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_allocate_asn1_invoke_id ()
				cc_free_asn1_invoke_id ()

Description     allocate/free an invoke id used by CC.
				called thru 'Cc_par_allocate_asn1_invoke_id()' and
				'Cc_par_free_asn1_invoke_id()' macros defined in cc_par.h
				These macros may be redefined to call application functions
				instead of these default ones.

Usage           cc_free_asn1_invoke_id (conn_id, invoke_id);
				invoke_id = cc_allocate_asn1_invoke_id (conn_id);

Parameters		- add_t conn_id: current conn_id on which the facility is beeing used
				- short invoke_id: invoke_id used/to be used.

Common constants and declarations : cc.h

*--------------------------------------------------------------------------*/

#if (NS_HOLD_RETRIEVE == ON) && (NS_SS_ECT == ON) /* { */

short cc_allocate_asn1_invoke_id (conn_id)
	add_t conn_id;
{
	short invoke_id;

		/*
			Allocation algorithm:
			Eeach invoke_id is local to one particular call-reference.
			Only one invoke id at a time will be used by CC for one call.
			We will never use 0, which is used to specify that no invoke-id
			is in use.
		*/

	while ((invoke_id = (short)Rand_omnitel ()) == 0);

	return (invoke_id);
}

	/*----------*/

void cc_free_asn1_invoke_id (conn_id, invoke_id)
	add_t conn_id;
	short invoke_id;
{

	/* nothing to do! */

}

#endif /* (NS_HOLD_RETRIEVE == ON) && (NS_SS_ECT == ON) } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            cc_read_spid_from_ns ()

Description     Read SPID information.

Usage           cc_read_spid_from_ns (code)

Parameter	 	code_t code = primitive code.

Common constants and declarations : cc.h

*--------------------------------------------------------------------------*/

#if _CC_SPID_INFO == ON /* { */

void cc_read_spid_from_ns (code)
	code_t     code;
{

	cc_spid_size	= 0;
    cc_ces			= 0;
	p_spid			= P_NIL;

	if (Cc_na_function == FG_NT_TE) {

        if (Net_get_ie (code, IE_SPID) == PRESENT) {
            cc_ces		 = Net_isdn_get_val  (code, IE_SPID, FLD_CES);
            cc_spid_size = Net_isdn_lgth_str (code, IE_SPID);
            p_spid       = Net_isdn_p_str    (code, IE_SPID);
        }
	}
}

#endif /* } */

/*EOF*/
