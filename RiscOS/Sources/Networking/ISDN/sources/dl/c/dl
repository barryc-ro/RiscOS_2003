
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - dl.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		dl - implements the main function of the data link layer
 *
 *		dl_config - implements the construction of the data link layer
 *		objects
 *
 *		dl_reset_config - implements the reseting of the data link layer
 *		objects
 *
 *		dl_audit_in - implements the audit management of the DL state.
 *
 *		dl_var_init - init of DL entity's global variables.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    LAP-BRICKS                                       |*/
/*|    ISDN-BRICKS                                      |*/
/*|    X25-BRICKS                                       |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

			/* Compilation options */

#define ENTITY 		DL_D			/* LAPD Data Link entity */
#define MODULO 		128				/* MODULO 128 */

#include "dl.h"  					/* DL header module */

#if REVISION_STRING == ON
#	include "rev.dl"
#endif

			/* Copyright */

CONST char 			dl_copyright[]	= "Copyright (c) 1989 - 1990 by OMNITEL SA - All Rights Reserved";
CONST char 			dl_licence[]	= LICENSE_NBER;

			/* DL init flag */

uchar				dl_init_flag;

			/* DL common context */

					 Entity_common (dl);		/* DL entity common variables */
union 	frame 	FAR	*p_rcv_frame;				/* FAR pointer on received frame */
union 	frame 	FAR	*p_snd_frame;				/* FAR pointer on frame to send */
struct 	upfh 		 receive_fr;				/* frame header structure of a received frame */
struct 	upfh 		 send_fr;					/* frame header structure of frame to send */

struct 	dlna 	FAR *p_dlna;					/* pointer on the current DL network access object */
struct 	dlchan 	FAR *p_dlchan;					/* pointer on the current DL channel object */
struct 	dlsap 	FAR *p_dlsap;					/* pointer on the current DL service access point object */
struct 	dlcep 	FAR *p_dlcep;					/* pointer on the current DL connection end point */

struct 	node 	FAR *p_dl_tree;					/* pointer on the tree top of the tree object structure */

struct queue_mgt 	 dl_internal_queue;			/* DL internal queue */

#if OPTIMIZATION == SPEED
	struct  dlna	FAR *FAR *p_dlna_tab;		/* access table */
#endif

uchar				 dl_att_ni;					/* DL AT&T and NI option flag */
uchar				 dl_state;					/* current DL state */

#if DL_IDENTIFICATION == ON
	struct dl_ident_profile	FAR	*p_dl_ident_profile;
	uchar						 dl_ident_profile_nb;
#endif

			/* DL timer event ID */

CONST_ARRAY	uchar 	DL_TI_EV_ID [] = {TI_200, TI_203, TI_V120_XID};

			/* Cache context : frequently used read only context data */

			ent_id_t	dl_entity_id;

#if NEW_FCT_STYLE == ON
	void dl_load_cr		(void);
	void dl_load_dte_cr (void);
	void dl_load_dce_cr (void);

#else

	void dl_load_cr		();
	void dl_load_dte_cr ();
	void dl_load_dce_cr ();
#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dl - implements the main function of the data link layer.

Usage           uchar dl (p_msg);
					- struct message FAR *p_msg;

Related
functions usage void dl_rcv ();			wait for a data link event.

				void broadcast ();  	process an event sent to a broadcast
										connection.

				void switch_state ();	process an event according to its
										connection state.

Description     dl () implements the receiving and dispatching of an external
				event and the seaching and dispatching of internal event.

Return value    OK or NOK

Common constants and declarations : dl.h

Common objects  : current connection end point object

*--------------------------------------------------------------------------*/

uchar dl (p_msg)
	struct message 		FAR *p_msg;				/* pointer on received message */
{
	uchar 				FAR *p_data;			/* data pointer */
	struct dl_config 	FAR *p_dl_config;		/* configuration data pointer */
	struct message		FAR *p_rcv_dea;			/* DEA IN message pointer */
	uchar					 stop_flag;			/* Stop flag */
	uchar					 event;				/* temporary event ID */
	nai_t					 nai;				/* NAI */

start:

		/* Init message and buffer pointers */

	p_rcv_msg 	= p_msg;
	p_buffer  	= R_msg_p_buffer;
	p_snd_msg 	= P_NIL;
	p_data		= R_a_data;

		/* Init objects context pointers to P_NIL */

	p_dlna		= P_NIL;
	p_dlchan	= P_NIL;
	p_dlsap		= P_NIL;
	p_dlcep		= P_NIL;

		/* Data Link configuration and initialization primitives */

	if (R_msg_from == ENT_MDL) {
		stop_flag = ON;

		switch (R_msg_code) {

				/* MDL_SET_CONFIG_RQ : DL initialization */

			case MDL_SET_CONFIG_RQ :

				p_dl_config = (struct dl_config FAR *)p_data;

#				if DL_MLP == ON

					if (Dl_config_mlp_flag == OFF) {

#				endif

					if (dl_config (p_dl_config) == OK) {

							/* Set flag init done */

						dl_init_flag = ON;

							/* Send back an OK confirmation */

						Dl_config_ret_code = OK;

					} else {

							/* Send reject confirmation to MDL */

						Dl_config_ret_code 		= NOK;
						Dl_config_diagnostic 	= ENT_DL;
					}

						/* Send back confirmation message to MDL */

					dl_retransmit (MDL_SET_CONFIG_CO, ENT_MDL);

#				if DL_MLP == ON

					} else {

							/* MLP configuration */

						mlp (p_rcv_msg);
					}

#				endif

				break;

				/* MDL STOP request */

			case MDL_STOP_RQ :

				if (dl_access_na (R_msg_nai) == OK) {
					Confirm_ret_code 	= OK;

						/* Save NAI */

					nai					= R_msg_nai;

						/* Retransmit to MDL */

					dl_retransmit (MDL_STOP_CO, ENT_MDL);

						/*
							Build an incoming  deactivation message
							for all channels of the Network Access.
						*/

					p_rcv_msg			= Alloc_msg ();
					R_msg_header_init;

					R_msg_from			= ENT_PH;

					R_msg_code 			= PH_DEA_IN;

					R_msg_nai			= nai;
					R_msg_sapi			= PH_SAPI_NIL;
					R_msg_chani			= PH_CHANI_NIL;

						/* Process PH DEA IN primitive */

					stop_flag			= OFF;	/* process the PH_DEA message */

				} else {

					Confirm_ret_code	= NOK;

						/* Retransmit to MDL */

					dl_retransmit (MDL_STOP_CO, ENT_MDL);
				}

				break;

#			if RESET_CONFIG == ON

					/* MDL RESET CONFIGURATION request */

				case MDL_RESET_CONFIG_RQ :

					Confirm_ret_code = dl_reset_config (R_msg_nai);

						/* Retransmit to MDL with an error code */

					dl_retransmit (MDL_RESET_CONFIG_CO, ENT_MDL);
					break;

#			endif

#			if DL_STATISTICS == ON

				case MDL_INFO_RQ :
					dl_send_to_mdl_info ();
					break;

#			endif


			default :

				if (dl_init_flag == OFF) {

						/* Init not done ---> requeue the incoming message */

					Send_message (p_rcv_msg); p_rcv_msg = P_NIL;

				} else {

					stop_flag = OFF;
				}

				break;

		}

			/* If stop flag ON return from the DL entity */

		if (stop_flag == ON) {
			goto end;
		}

	}

			/*
			   Process incoming event and load the current
			   connection context if the frame is valid.
			*/

	if (dl_rcv () == NOK) {

			/*
				Invalid frame or invalid action :
				--> discard the frame, no action is taken.
			*/

		goto end;
	}

			/* Is it a global primitive ? */

	switch (event_id) {

			/* Null event */

		case EV_NIL 			:

			/* No BUSY management in DL */

		case PH_BUSY_IN 		:
		case PH_CLEAR_BUSY_IN 	:
			break;

			/* Line activation indication */

		case PH_ACT_IN :

#			if DL_PH_TX_DONE == ON

					/* Load the TX done flag in channel context */

				if ((R_data_size == Ph_act_size) && (Ph_act_tx_done == ON)) {
					Chan_tx_done = ON;

				} else {

					Chan_tx_done = OFF;
				}

#			endif

				/*	Process the queue of incoming requests if any */

			while (dl_out_queue_incoming_rq_co () == OK) {

				if (dl_rcv () == OK) {
					dl_process ();
				}

			}


			break;

			/* Line deactivation indication */

		case PH_DEA_IN :

				/* Save the received message pointer */

			p_rcv_dea = p_rcv_msg; p_rcv_msg = P_NIL;

				/* Discard the request queue */

			dl_discard_queue_incoming_rq_co ();

				/* Restore the received message pointer */

			p_rcv_msg = p_rcv_dea;

				/* Process the DEA INDICATION */

				/* SAP loop */

			for (dl_access_first_dlsap (); p_dlsap != P_NIL; dl_access_next_dlsap ()) {

					/* CEP loop */

				for (dl_access_first_dlcep (); p_dlcep != P_NIL; dl_access_next_dlcep ()) {

						/*
							Process if CEP chani and requested chani are equal
							or if ISDN D channel. The D channel manage the
							network access failures.
						*/

					if (Chani != PH_CHANI_NIL) {

						if ((R_msg_chani == Chani) ||
							((R_msg_chani == PH_CHANI_D) &&
							 ((Na_type == BRI) || (Na_type == PRI))
							)
						   ) {

							if (dl_access_chan (Nai, Chani) == OK) {
								dl_process ();
							}

						}

					}

				}

			}

			break;

			/* Busy request and clear busy request */

		case MDL_BUSY_RQ 		:
		case MDL_CLEAR_BUSY_RQ 	:

				/* Event associated with a network access (NA) */

			event = event_id;

				/* SAP loop */

			for (dl_access_first_dlsap (); p_dlsap != P_NIL; dl_access_next_dlsap ()) {

				if (No_congestion != ON) {

						/* CEP loop */

					for (dl_access_first_dlcep (); p_dlcep != P_NIL; dl_access_next_dlcep ()) {

						if (Chani != PH_CHANI_NIL) {

							if (dl_access_chan (Nai, Chani) == OK) {

									/* Process */

								switch (event) {

										/* Flow control primitives */

#									if DL_FC == ON

										case MDL_CLEAR_BUSY_RQ :

											if (In_fc_state == FREE) {
												event_id = DL_CLEAR_BUSY_RQ;
												dl_process ();
											}

											System_state = FREE;
											break;

										case MDL_BUSY_RQ :
											event_id = DL_BUSY_RQ;
											dl_process ();
											System_state = BUSY;
											break;

#									else

										case MDL_CLEAR_BUSY_RQ :
											event_id = DL_CLEAR_BUSY_RQ;
											dl_process ();
											System_state = FREE;
											break;

										case MDL_BUSY_RQ :
											event_id = DL_BUSY_RQ;
											dl_process ();
											System_state = BUSY;
											break;
#									endif

									default :
										break;
								}

							}

						}

					}

				}

			}

			break;

#		if (DL_LAPB == ON) || (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

			case MDL_ATTACH_SAPI_RQ :
			case MDL_DETACH_SAPI_RQ :

				p_rcv_msg	= P_NIL;

#				if DL_MLP == ON

						/* MLP SAPI ? */

					if (Dl_ass_sapi >= DL_SAPI_MLP) {

							/* Process Multilink ATTACH/DETACH request */

						dl_mlp_attach_detach (p_msg);

					} else {

#				endif

							/* Process Single link ATTACH/DETACH request */

						dl_slp_attach_detach (p_msg, ON);

#				if DL_MLP == ON
					}
#				endif

				break;

#		endif /* (DL_LAPB == ON) || (DL_V120 == ON) || (DL_LAP4K == ON)  || (DL_LAPF == ON) */

#		if DL_FC == ON

				/* Upper layer flow control primitives */

					/* No more traffic to upper layer */

			case DL_BUSY_RQ :
				dl_process ();
				In_fc_state = Own_receiver_state = BUSY;
				break;

					/* Restart traffic if no system busy condition */

			case DL_CLEAR_BUSY_RQ :

				if (System_state == FREE) {
					dl_process ();
					Own_receiver_state 		= FREE;
					Discarded_i_frame_state = OFF;
				}

				In_fc_state = FREE;
				break;

#		endif

#		if DL_PH_TX_DONE == ON

					/*
						PH TX done indication
						---> start the retry timer if necessary.
					*/

			case PH_TX_DONE_IN :

					/* TX done ON ? */

				if (Chan_tx_done == ON) {

						/* Is the retry timer awaiting TX done ? */

					if (Tx_done_t200 == ON) {

							/* The retry timer is awaiting PH_TX_DONE_IN */

						Tx_done_t200 = OFF;
						Start_timer (T200);

					} else {

							/* Is the T200 timer running */

						if (State_timer (T200) == ON) {


								/* Set the timer T200 ready to restart */

							Tx_done_t200 = ON;
						}

					}


						/* Is the message in DL I queue */

					if (R_msg_lib == ON) {

							/* No - Free the received message */

						Free_msg (p_rcv_msg);

					} else {

							/* Yes - Reset the in PH FIFO mark */

						Msg_reset_in_ph_fifo_mark (p_rcv_msg);
					}

						/* Clear the received message pointer */

					p_rcv_msg = P_NIL;
				}


				break;

#		endif

			/* Others primitives associated with a connection end point */

		default :
			dl_process ();
			break;

	}   /* End switch event_id */


		/* Return from the DL entity */

	end:

		/* Store current state in DL audit cyclic buffer */

#	if DL_AUDIT == ON

#		if ASSERT == ON
			if (performance == OFF) {
				dl_audit_in ();
			}
#		else
			dl_audit_in ();
#		endif

#	else

#		if ASSERT == OFF

			if (p_dlcep != P_NIL) {
				dl_state = State;
			}

#		endif

#	endif

#	if ASSERT == ON

			/* Check the queues consistancy */

		if ((performance == OFF) && (p_dlcep != P_NIL)) {
			dl_queue_check (QU_I);
		}

#	endif

		/* Free the remaining messages if necessary */

	Free_msg (p_rcv_msg);
	Free_msg (p_snd_msg);

		/* Check DL internal queue */

	if ((p_msg = dl_out_queue ()) == P_NIL) {
		return (OK);
	}

		/* Audit */

	Msg_audit_in ('I', p_msg);

#	if SIMULATION == ON
		pr_message (p_msg, OFF);
#	endif

		/* Process the internal message */

	goto start;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dl_process - implements the processing of a connection
				message primitive received by the DL entity.

Usage           void dl_process ();

Common constants and declarations : dl.h

Common objects : p_rcv_msg : pointer on the received message
				 p_dlna points on the NA context
				 p_dlsap points on the SAP context
				 p_dlcep points on the CEP context

*--------------------------------------------------------------------------*/

void dl_process ()
{

		/* Reset internal event flag */

	Signal_flag (QU_I) = Signal_flag (QU_UI) = ON;

	process: 							/* for internal event */

#	if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

		if (Tei == DL_TEI_BROADCAST) {
			broadcast ();				/* process broadcast connection event */

		} else {

			switch_state ();			/* process event according to the connection state */
		}

#	else

		switch_state ();				/* process event according to the connection state */
#	endif

			/* Internal signal ? */

	if (dl_init_flag == ON) {

				/* From the acknowledged I or UI queues ? */

		if ( (Signal_flag (QU_I) == ON) && ((First (QU_I) != P_NIL) &&
											((Sent (QU_I) == P_NIL) ||
											 (Next (Sent (QU_I)) != P_NIL)
											)
										   )
		   ) {
			event_id			= QU_FR_I;
			Signal_flag (QU_I)	= OFF;
			goto process;

		} else {

			if ((Signal_flag (QU_UI) == ON) &&
				(First (QU_UI) != P_NIL)
			   ) {
				event_id			= QU_UI;
				Signal_flag (QU_UI) = OFF;
				goto process;
			}

		}

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dl_config - implements the building and initialization of
						  the data link layer objects.

Usage           uchar dl_config (struct dl_config FAR *p_dl_config);
					- p_dl_config : pointer on configuration data.

Description     dl_config implements the building of the data link objects
				(na, sap, dlcep) on a tree structure and the initialization
				of the objects.

Return value    uchar return code = OK configuration is done,
									NOK configuration has failed.

Common constants and declarations : dl.h

Common objects  na			: network access
				sap			: service access point
				dlcep		: data link connection end point

*--------------------------------------------------------------------------*/

uchar dl_config (p_dl_config)
	struct dl_config 	FAR	*p_dl_config;				/* pointer on the configuration data */
{
	uchar					 i, j;						/* index */
	short 					 l;							/* index */
	struct na 			FAR	*p_dl_config_na;			/* pointer on the current na object of
														   the configuration data */
	struct sap 			FAR	*p_dl_config_sap;			/* pointer on the current sap object of
														   the configuration data */
	uchar					 k_i;						/* temporary */

#	if DL_T203 == ON
		timer_val_t			 ti_203_i;					/* TI 203 implicit value */
#	endif

#	if DL_PH_MUX == ON
		struct dlmux	FAR	*p_dlmux;					/* DL MUX pointer */
		struct dlna		FAR *p_dlna_sav;				/* used to save the NA context pointer */
		struct dlchan	FAR *p_dlchan_ph;				/* DLCHAN context pointer */
		nai_t				 ph_nai;					/* current PH NAI */
		nai_t				 nai;						/* current NAI */
#	endif

		/* Build the object tree structures */

	if (dl_build_object (p_dl_config) == NOK) {
		return (NOK);
	}

		/* Load AT&T NI option flag */

	Na_att_ni_flag = Dl_config_att_ni_flag;

		/* ----------------------- NA loop -------------------------- */

	for (i = 0; i < Dl_config_na_nb; i++) {

			/* Init p_dlna : pointer on NA */

		p_dl_config_na = &Dl_config_object_na (i);		/* current pointer in the configuration */

		if (dl_access_na (Dl_config_nai) == NOK) {
			return (NOK);
		}

			/* recopy NA values from the configuration structure */

		Na_type			= Dl_config_type;				/* type of access */
		Sap_nb			= Dl_config_sap_nb;				/* number of SAP in the NA */
		Na_fct			= Dl_config_fct;				/* function */

			/* Number of CHANI in the network access */

#		if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

			if ( ! ((Na_type == PRI) || (Na_type == BRI))) {
				Na_channel_nb = Dl_config_channel_nb;

			} else {

				Na_channel_nb = Dl_config_channel_nb + 1;
			}

#		else

			Na_channel_nb = Dl_config_channel_nb;
#		endif

			/*+++++++++++++++++ CHANNEL loop ++++++++++++++++++++*/

			/* Load the NA channels information */

		for (j = 0; j < Na_channel_nb; j++) {

				/* Access to the channel context */

			if (dl_access_chan (Nai, j) == NOK) {
				return (NOK);
			}

			Chan_chani = j;

#			if DL_SIM_BUILDER  == ON

					/* Set the NA active */

				Chan_state = S_PH_INFO_TX_AVAILABLE;

#			else

					/* Set the NA not active */

				Chan_state = S_PH_INFO_TX_NOT_AVAILABLE;

#			endif

			Chan_first_rq 				= P_NIL;
			Chan_last_rq  				= P_NIL;

			Chan_chani_to_nai			= Nai;
			Chan_chani_to_sapi			= DL_SAPI_NIL;
			Chan_chani_to_dl_entity_id 	= ENT_NIL;

#			if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON)

				if (((Na_type == PRI) || (Na_type == BRI)) &&
					(j == PH_CHANI_D)) {

					Chan_ph_entity_id 	= ENT_PH_D;
					Chan_ph_sapi      	= PH_SAPI_D;
					Chan_chani_to_sapi	= DL_SAPI_MDL;

					if (Na_type == BRI) {
						Chan_chani_to_ces 	= DL_CES_BROADCAST;

					} else {

						Chan_chani_to_ces 	= DL_CES_SIG;
					}

				}

#				if DL_PRI_MULTI_D == ON

					else if (Na_type == PRI_MULTI_D) {

							/*
								SAPI  = Signalling SAPI.
								CHANI = CES,
							*/

						Chan_ph_entity_id 	= ENT_PH_D;
						Chan_ph_sapi      	= PH_SAPI_D;
						Chan_chani_to_sapi	= DL_SAPI_SIG;
						Chan_chani_to_ces 	= j;

					}

#				endif

				else {

						/* channel */

					Chan_ph_sapi      		= PH_SAPI_B;

					if ((Na_type == SCI) | (Na_type == SCI_HDTM)) {
						Chan_ph_entity_id 	= ENT_PH;

					} else {

						Chan_ph_entity_id 	= ENT_PH_B;
					}

					if (Sap_nb == 1) {
						dl_access_first_dlsap	();
						Chan_chani_to_sapi	= Sapi;
					}

				}

#			else

				Chan_ph_sapi      			= PH_SAPI_B;
				Chan_ph_entity_id 			= ENT_PH;

				if (Sap_nb == 1) {
					dl_access_first_dlsap 	();
					Chan_chani_to_sapi		= Sapi;
				}

#			endif

#			if DL_LAPX == ON

				if (Na_type == SCI_HDTM) {

						/* LAPX configuration and initialization */

					Chan_dlx_state 			= DLX_IDLE_0;
					Chan_dlx_usage 			= ON;

						/* XT1 timer initialization */

					Chan_dlx_xt1_a 	 		= Dl_config_dlx_xt1_a;
					Chan_dlx_xt1_o 			= Dl_config_dlx_xt1_o;
					Chan_dlx_xt1_state 		= OFF;

					if ((Chan_dlx_xt1_id 	= Timer_alloc (ENT_DL_B, Nai, SAPI_NIL, j)) == P_NIL) {
						return (NOK);
					}

				} else {

					Chan_dlx_usage 			= OFF;
				}

#			else

					/* Single Channel HDTM not allowed */

				if (Na_type == SCI_HDTM) {
					return (NOK);
				}

#			endif

#			if DL_IDENTIFICATION == ON
				Chan_ident_profile_nb = 0;
#			endif

		}

#		if DL_PH_MUX == ON

				/* DL PHYSICAL MULTIPLEXER */

				/* Initialise the dlchan pointer */

			Na_a_dlchan = P_NIL;

			if (Dl_config_ph_mux == ON) {

					/* Master mux NAI */

				p_dlmux = Na_a_dlmux;

					/* Reset the virtual NAI attachments */

				for (j = 0; j < DL_MX_NA_PER_MUX; j++) {
					Dl_mux_nai (j) = NAI_NIL;
				}

			} else {

					/* Slave or "normal" NAI */

				if ((ph_nai = Dl_config_ph_nai) != NAI_NIL) {

						/* It should be a Slave mux NAI */

						/* Remember the current NAI */

					nai = Nai;

						/* Save the DL NA context pointer */

					p_dlna_sav = p_dlna;

						/* The related Master NAI should already be configured */

					if (dl_access_na (ph_nai) == NOK) {
						return (NOK);
					}

						/* The Master NAI must be multiplexed */

					if ((p_dlmux = Na_a_dlmux) != P_NIL) {

							/* The current NAI is a Slave mux NAI */

							/* Find and reserve a free virtual NAI attachment */

						for (j = 0; j < DL_MX_NA_PER_MUX; j++) {

							if (Dl_mux_nai (j) == NAI_NIL) {
								Dl_mux_nai (j) = nai;
								break;
							}

						}

							/* Too many NAIs attached to the Physical NAI ? */

						if (j == DL_MX_NA_PER_MUX) {
							return (NOK);
						}

						p_dlchan_ph = Na_a_chan (PH_CHANI_D);

							/* Restore the DL NA context pointer */

						p_dlna = p_dlna_sav;

							/* Link to the PH channel context */

						Na_a_dlchan = p_dlchan_ph;

					} else {

							/*
								The Master NAI is not multiplexed:
								assume that the current NAI is a "normal" one
							*/

							/* Restore the DL NA context pointer */

						p_dlna = p_dlna_sav;

					}

				}

			}

#		endif


				/* -------------------- SAP loop ------------------- */

		j = 0;

		for (dl_access_first_dlsap (); p_dlsap != P_NIL; dl_access_next_dlsap ()) {

				/* Message configuration SAP structure pointer */

			p_dl_config_sap	= &Dl_config_object_sap (i, j);

				/* Recopy the SAP values from the configuration structure */

			Dl_entity_id 	= Dl_entity_id_ctx	= Dl_config_dl_entity_id;	/* DL entity ID */
			Modulo			= Dl_config_modulo;			/* Modulo value */
			Dlcep_nb		= Dl_config_dlcep_nb;		/* number of DLCEP */
			N201			= Dl_config_n201;			/* maximum number of octets in an I field size */
			Dl_teledisket	= OFF;						/* no teledisket profile */

#			if DL_LAPF == ON
				Lapf_add_ff	= Set_default (Dl_config_lapf_add_ff, 2); /* LAPF address field format */
				Lapf_de		= Dl_config_lapf_de;		/* LAPF discard elligibility bit */
				Lapf_dc		= Dl_config_lapf_dc;		/* LAPF DLCI or DL-CORE control indicator */
#			endif

				/* Set SAP default values according to SAPI */

			No_congestion	= Dl_config_no_congestion;	/* no congestion management flag */

			if (Dl_config_l3_entity_id == 0) {

				switch (Sapi) {

					case DL_SAPI_SIG :
						L3_entity_id 	= ENT_NS;		/* Network signalling entity */
						No_congestion 	= OFF;			/* congestion management forced */
						break;

					case DL_SAPI_X25 :					/* packet communication conforming to X.25 level 3 procedures */
					case DL_SAPI_PCK_D :				/* packet mode using Q.931 call control procedures */
						L3_entity_id 	= ENT_X25;
						No_congestion	= ON;			/* no congestion management forced */
						break;

					case DL_SAPI_MDL : 					/* Layer 2 Management procedure */
						L3_entity_id 	= ENT_MDL;
						No_congestion	= ON;			/* congestion management unused (UI only ) */
						break;

					default :
						L3_entity_id 	= ENT_L3;		/* Default : generic L3 entity */
						break;
				}

			} else {

					/* If X25 PLP force no congestion management */

				if ((L3_entity_id = Dl_config_l3_entity_id) == ENT_X25) {
					No_congestion		= ON;			/* no congestion management forced */
				}

			}

				/* Init Channel entity with the current one */

			Chan_chani_to_dl_entity_id 	= Dl_entity_id;

				/* Init  I frame header size */

			switch (Dl_entity_id) {

#				if DL_LAP4K == ON
					case ENT_DL_4K      :
#				endif

#				if DL_V120 == ON
					case ENT_DL_V120 	:
#				endif

#				if DL_LAPD == ON
					case ENT_DL_D 		:
#				endif


#					if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON)

							/* LAPD protocol */

						if (Modulo == MODULO_EXTENDED) {

#							if DL_MODULO_128 == ON
								I_size = i_size_d_128 ();	/* LAPD - modulo 128 */
#							else
								Trap (TRAP_MODULO_DISABLE, "dl_config : D - 128");
#							endif

						} else {

#							if DL_MODULO_8 == ON
								I_size = i_size_d_8 ();		/* LAPD - modulo 8 */
#							else
								Trap (TRAP_MODULO_DISABLE, "dl_config : D - 8");
#							endif

						}

						break;

#					endif

#				if DL_LAPF == ON

					case ENT_DL_F	:

						switch (Lapf_add_ff) {

#							if DL_LAPF_ADD_FF_2 == ON

								case 2 :
									I_size = i_size_f_2 ();	/* LAPF - address field 2 octets */
									break;

#							endif

#							if DL_LAPF_ADD_FF_3 == ON

								case 3 :
									I_size = i_size_f_3 ();	/* LAPF - address field 3 octets */
									break;

#							endif

#							if DL_LAPF_ADD_FF_4 == ON

								case 4 :
									I_size = i_size_f_4 ();	/* LAPF - address field 4 octets */
									break;

#							endif

								default :
									return (NOK);

						}

						break;

#				endif

#				if DL_LAPB == ON

					case ENT_DL_B :

							/* LAPB protocol */

						if (Modulo == MODULO_EXTENDED) {

#							if DL_MODULO_128 == ON
								I_size = i_size_b_128 ();	/* LAPB - modulo 128 */

#							else

								Trap (TRAP_MODULO_DISABLE, "dl_config : B - 128");
#							endif

						} else {

#							if DL_MODULO_8 == ON
								I_size = i_size_b_8 ();		/* LAPB - modulo 8 */
#							else
								Trap (TRAP_MODULO_DISABLE, "dl_config : B - 8");
#							endif

							Dl_teledisket	= Dl_config_teledisket;		/* Teledisquete is possible */
						}

							/* Load ISDN-BIOS flag */

#						if DL_ISDN_BIOS == ON
							Isdn_bios = Dl_config_isdn_bios;
#						endif

						break;

#					endif

				default :
					return (NOK);

			}

					/* Init implicit timer value */

				/* T200 timer configuration value */

			T200_val = (Dl_config_ti_0 == 0) ? T200_I : Dl_config_ti_0;

				/* Retry Counter : RC */

			N200 = (Dl_config_rc_nb == 0) ? N200_I : Dl_config_rc_nb;

				/* Window size ; K_cfg */

			switch (Na_type) {

				case PRI 			:

#				if DL_PRI_MULTI_D == ON
					case PRI_MULTI_D 	:
#				endif

					if (Sapi == DL_SAPI_SIG) {
						k_i = K_I_PRI_SIG;

					} else {

						k_i = K_I_PRI_PCK;
					}
					break;

				case BRI :

					if (Sapi == DL_SAPI_SIG) {
						k_i = K_I_BRI_SIG;

					} else {

						k_i = K_I_BRI_PCK;
					}
					break;

				default :
					k_i = K_I_SCI;
					break;

			}

			K_cfg = (Dl_config_k == 0) ? k_i : Dl_config_k;

#			if DL_XID == ON

				Xid_timer_val = (Dl_config_xid_ti_val == 0) ? T200_val 	:	Dl_config_xid_ti_val;
				Xid_rc_max    = (Dl_config_xid_rc_max == 0) ? N200		: 	Dl_config_xid_rc_max;

#				if DL_IDENTIFICATION == ON
					Xid_ident_profile_nb = Dl_config_ident_profile_nb + dl_ident_profile_nb;
#				endif

#			endif

					/* ------------------- DLCEP loop -------------------- */

			l = 0;

			for (dl_access_first_dlcep (); p_dlcep != P_NIL; dl_access_next_dlcep ()) {

					/* Init according Entity Id */

				 switch (Dl_entity_id) {

#					if DL_LAPB == ON

							/* LAPB */

						case ENT_DL_B :

								/*  LAPB : set S_TEI_ASSIGNED state */

							State = S_TEI_ASSIGNED;

								/*
									If Single Channel Interface init the channel
									with the current SAPI and current CES.
								*/

							if ((Na_type == SCI) || (Na_type == SCI_HDTM)) {

									/* for suppression of the SAPI attachment */

#							  if 0
								Chan_chani_to_sapi	= Sapi;
								Chan_chani_to_ces 	= Ces;
								Chani				= 0;
#							  endif

								Chani				= PH_CHANI_NIL;

							} else {

									/*
										ISDN B channels dynamic attachment :

										- SAPI_NIL in the access table (chani to SAPI)
										- CHANI_NIL in the channel Id.
									*/

								Chani				= PH_CHANI_NIL;
							}
							break;

#					endif

#					if DL_V120 == ON

						case ENT_DL_V120 	:
							State	= S_TEI_ASSIGNED;
							Dlci	= DL_DLCI_NIL;
							Chani	= PH_CHANI_NIL;
							break;

#					endif

#					if DL_LAPF == ON

						case ENT_DL_F		:
							Dlci	= DL_DLCI_NIL;
							State	= S_TEI_UNASSIGNED;
							Chani	= 0;
							break;

#					endif

#					if DL_LAP4K == ON

						case ENT_DL_4K :

							Chani		= 0;

							if (Sapi == DL_SAPI_LAP4K_MDL) {
								Dlci	= DL_DLCI_LAP4K_MGT;
								Tei		= DL_TEI_BROADCAST;
								State	= S_TEI_ASSIGNED;

							} else {

								Dlci	= DL_DLCI_NIL;
								State	= S_TEI_UNASSIGNED;
							}
							break;

#					endif

#					if (DL_LAPD == ON)

							/* LAPD */

						case ENT_DL_D 	:

								/* Broadcast connection : mandatory for LAPD BRI and PRI */

							if (((Na_type == PRI) || (Na_type == BRI)) &&
								(Ces == DL_CES_BROADCAST)
							   ) {
								State	= S_TEI_ASSIGNED;
								Tei		= DL_TEI_BROADCAST;
							}

								/* Non broadcast connection */

#							if EQUIPMENT == TE

									/* Terminal Equipment */

#								if DL_PRI_MULTI_D == ON

									else if (Na_type == PRI_MULTI_D) {

										if (Dl_config_tei (l) < DL_TEI_AUTOMATIC_LOW) {
											Tei		= Dl_config_tei (l);
											State	= S_TEI_ASSIGNED;

										} else {

											Tei		= DL_TEI_POINT_TO_POINT;
											State	= S_TEI_ASSIGNED;
										}

									}

#								endif

								else if (Na_type == PRI) {

										/* PRI */

									if (Dl_config_tei (l) < DL_TEI_AUTOMATIC_LOW) {
										Tei		= Dl_config_tei (l);
										State	= S_TEI_ASSIGNED;

									} else if (Ces == DL_CES_SIG) {

										Tei		= DL_TEI_POINT_TO_POINT;
										State	= S_TEI_ASSIGNED;

									} else {

										Tei		= DL_TEI_NIL;
										State	= S_TEI_UNASSIGNED;
									}

								} else {

											/*
											   Terminal BRI - S0
											   ==> Point to multipoint configuration
											   with TEI automatic assignment.
											*/


											/*
											   LAPD and not broadcast ==> TEI = DL_TEI_NIL
											   and state = TEI unassigned or TEI = i_dl_tei
											   and state = TEI assigned.
											*/


									if (Dl_config_tei (l) < DL_TEI_AUTOMATIC_LOW) {
										Tei		= Dl_config_tei (l);
										State	= S_TEI_ASSIGNED;

									} else {

										Tei		= DL_TEI_NIL;
										State	= S_TEI_UNASSIGNED;
									}

								}

#							else /* NT2: */

									/* Network Termination 2 equipment (NT2) */

								else if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {

											/*
											   NT2 BRI terminal side -
											   ==> Point to multipoint configuration
											   with TEI automatic assignment.
											*/


											/*
											   LAPD and not broadcast ==> TEI = DL_TEI_NIL
											   and state = TEI unassigned or TEI = i_dl_tei
											   and state = TEI assigned.
											*/


									if (Dl_config_tei (l) < DL_TEI_AUTOMATIC_LOW) {
										Tei		= Dl_config_tei (l);
										State	= S_TEI_ASSIGNED;

									} else {

										Tei		= DL_TEI_NIL;
										State	= S_TEI_UNASSIGNED;
									}


								} else {

										/*
										   NT2 BRI Network side - T0 or
										   NT2 PRI Network side - T2 or
										   NT2 PRI Terminal side - S2
										   ==> manual TEI if signalling - Point to point configuration.
										*/

									if (Dl_config_tei (l) < DL_TEI_AUTOMATIC_LOW) {
										Tei		= Dl_config_tei (l);
										State	= S_TEI_ASSIGNED;

									} else if ((Na_type == PRI)

#									if DL_PRI_MULTI_D == ON
										|| (Na_type == PRI_MULTI_D)
#									endif

										) {
										Tei 	= DL_TEI_POINT_TO_POINT;
										State	= S_TEI_ASSIGNED;

									} else {

										Tei		= DL_TEI_NIL;
										State	= S_TEI_UNASSIGNED;
									}

								}

#							endif

								/*
									Load CHANI according to SAPI
									(if Sapi <= 63 --> D channel
									 else B channel).
								*/

							if (Sapi > DL_SAPI_MDL) {
								Chani = PH_CHANI_NIL;

#							if DL_PRI_MULTI_D

								} else if (Na_type == PRI_MULTI_D) {

										/* Convention : Chani = CES */

									Chani = l;

#							endif

							} else {

								Chani = PH_CHANI_D;
							}

							break;

#					endif

							/* Unknown entity */

					default :
						Trap (TRAP_UNKNOWN_ENTITY, "dl_config");

				} /* end switch Dl_entity_id ... */

					/*
					   Init DLCEP context :
						- V(S), V(A), V(R) = 0
						- release exception :
							. receiver and remote state = FREE,
							. l3,
							. waiting acknowledgment (local and remote),
							. reject exception.
					*/

				Vs = Va = Vr = 0;
				clear_exception_conditions ();

					/*
						 Set queue pointers to P_NIL and
						 queue internal signals to OFF.
					*/

				First (QU_I)		= Last (QU_I) 	= Sent (QU_I) = P_NIL;
				Signal_flag (QU_I)	= OFF;

				First (QU_UI)		= Last (QU_UI) 	= Sent (QU_UI)= P_NIL;
				Signal_flag (QU_UI)	= OFF;

					/*
						Timer init :
							- Init timer states to OFF,
							- allocate timer resource.
					*/

					/* T200 timer */

				Ti_state (T200)	= OFF;

				if ((Ti_id (T200) = Timer_alloc (Dl_entity_id, Nai, Sapi, Ces)) == P_NIL) {
					return (NOK);
				}

#				if DL_T203 == ON

					if (Dl_config_ti_1 != DL_TIMER_NIL) {

							/* T203 timer */

						Ti_state (T203)	= OFF;

						if ((Ti_id (T203) = Timer_alloc (Dl_entity_id, Nai, Sapi, Ces)) == P_NIL) {
							return (NOK);
						}

						if (Dl_att_ni == OFF) {
							ti_203_i = T203_I;

						} else {

							ti_203_i = T203_ATT_NI_I;
						}

						Ti_val (T203) = (Dl_config_ti_1 == 0) ? ti_203_i : Dl_config_ti_1;

					} else {

						Ti_id (T203) = P_NIL;
					}

#				else

#					if 0

						if ((Dl_config_ti_1 != 0) || (Dl_config_ti_1 != DL_TIMER_NIL)) {
							return (NOK);
						}

#					endif

#				endif

#				if (DL_V120 == ON) && (DL_V120_XID_NEGOTIATION == ON) && (DL_XID == ON)

						/* TM20 timer */

					Ti_state (TM20)	= OFF;

					if ((Ti_id (TM20) = Timer_alloc (Dl_entity_id, Nai, Sapi, Ces)) == P_NIL) {
						return (NOK);
					}

					Ti_val (TM20) = Xid_timer_val;

#				endif

#				if DL_FC == ON

						/* Flow control marks */

					if ((Out_fc_high_mark = Dl_config_out_fc_high_mark) != 0) {
						Out_fc_low_mark	= Dl_config_out_fc_low_mark;

						if (Out_fc_high_mark <= Out_fc_low_mark) {
							return (NOK);
						}

					}

					System_state = In_fc_state = Out_fc_state = FREE;

#				endif

					/* Load Command/Response values according to the side */

#				if EQUIPMENT == TE

						/* TE side */

#					if (DL_V120 == ON) || (DL_LAPF == ON)

						if ((Dl_entity_id == ENT_DL_V120) ||
							(Dl_entity_id == ENT_DL_F)) {
							dl_load_cr ();

						} else

#					endif

					if (((Dl_entity_id == ENT_DL_B)

#						if DL_LAP4K == ON
							|| (Dl_entity_id == ENT_DL_4K)
#						endif

						) && (Na_fct == DL_DCE)) {

						dl_load_dce_cr ();

					} else {

						dl_load_dte_cr ();
					}

#				else

						/* Network access fonctionnal grouping */

					switch (Na_fct) {

							/* Network side */

						case FG_NT_TE :

#							if (DL_V120 == ON) || (DL_LAPF == ON)

								if ((Dl_entity_id == ENT_DL_V120) ||
									(Dl_entity_id == ENT_DL_F)) {
									dl_load_cr ();
								}

#							endif

						case DL_DTE :

							if (Dl_entity_id == ENT_DL_B) {
								dl_load_dte_cr ();

							} else {

								dl_load_dce_cr ();
							}

							break;

							/* User side */

						default :

#							if (DL_V120 == ON) || (DL_LAPF == ON)

								if ((Dl_entity_id == ENT_DL_V120) ||
									(Dl_entity_id == ENT_DL_F)) {
									dl_load_cr ();

								} else

#							endif

							{
								dl_load_dte_cr ();
							}

							break;

					}

#				endif

					/* Init negotiated parameter with configuration values */

				dl_init_with_configuration_param ();

					/* Reset MLP link */

#				if DL_MLP == ON
					Slp_nai		= NAI_NIL;
					Slp_sapi	= DL_SAPI_NIL;
					Slp_ces		= DL_CES_NIL;
#				endif

					/* Next Connection Endpoint */

				l++;

			}    /* --------------- End of dlcep loop ---------------------*/

				/* Next SAP */

			j++;

		} /* ---------------------- End of sap loop -----------------------*/

	}	/* ----------------------- End na loop ----------------------------*/

#	if DL_IDENTIFICATION == ON

			/* Load the identification profiles */

		for (i = 0; i < DL_CONFIG_MX_IDENT_PROFILE; i++) {

			if (Dl_config_ident_profile_flag (i) == ON) {

				if (++dl_ident_profile_nb > DL_MX_IDENT_PROFILE) {
					return (NOK);
				}

					/* Copy the identity and the signature */

				Memcpy_far ((char FAR *)Dl_ident_profile_a_id 			(dl_ident_profile_nb),
							(char FAR *)Dl_config_ident_profile_a_id  	(i),
							DL_ID_SIZE);

				Memcpy_far ((char FAR *)Dl_ident_profile_a_sig 			(dl_ident_profile_nb),
							(char FAR *)Dl_config_ident_profile_a_sig  	(i),
							DL_SIG_SIZE);

			}

		}


#	endif

#	if DL_RELAY == ON

	{

	struct 	dlna 	FAR *p_dlna_1;		/* temporary pointer on the current DL network access object */
	struct 	dlchan 	FAR *p_dlchan_1;	/* temporary pointer on the current DL channel object */
	struct 	dlsap 	FAR *p_dlsap_1;		/* temporary pointer on the current DL service access point object */
	struct 	dlcep 	FAR *p_dlcep_1;		/* temporary pointer on the current DL connection end point */

	struct 	dlna 	FAR *p_dlna_2;		/* temporary pointer on the current DL network access object */
	struct 	dlchan 	FAR *p_dlchan_2;	/* temporary pointer on the current DL channel object */
	struct 	dlsap 	FAR *p_dlsap_2;		/* temporary pointer on the current DL service access point object */
	struct 	dlcep 	FAR *p_dlcep_2;		/* temporary pointer on the current DL connection end point */

			/* Process relay configuration */

		for (i = 0; i < DL_CONFIG_MX_RELAY; i++) {

			if (Dl_config_relay_flag (i) == ON) {

				if (dl_access_object (Dl_config_relay_nai_1 (i),
									  Dl_config_relay_sapi_1 (i),
									  TYPE_CES,
									  Dl_config_relay_ces_1 (i)) == OK) {

						/* Already used in a relay ? */

					if (R_p_dlna != P_NIL) {
						return (NOK);
					}

						/* save the context */

					p_dlna_1 	= p_dlna;
					p_dlchan_1  = p_dlchan;
					p_dlsap_1	= p_dlsap;
					p_dlcep_1	= p_dlcep;

				} else {

					return (NOK);
				}

				if (dl_access_object (Dl_config_relay_nai_2  (i),
									  Dl_config_relay_sapi_2 (i),
									  TYPE_CES,
									  Dl_config_relay_ces_2 (i)) == OK) {

						/* Already used in a relay ? */

					if (R_p_dlna != P_NIL) {
						return (NOK);
					}
						/* Load the CTX 2 with CTX 1 pointers */

					R_p_dlna 	= p_dlna_1;
					R_p_dlchan	= p_dlchan_1;
					R_p_dlsap 	= p_dlsap_1;
					R_p_dlcep 	= p_dlcep_1;

					R_lc_state	= LC_RELEASED;
					R_first		=
					R_last		= P_NIL;

						/* If one CEP force ATTACH if not done */

					if ((p_dlchan == P_NIL) && (Dlcep_nb == 1)) {

						if (dl_access_chan (Nai, 0) == OK) {
							Chani 				= 0;
							Chan_chani_to_sapi 	= Sapi;
							Chan_chani_to_ces  	= Ces;
						}

					}

						/* If DL loop back --> return */

					if (p_dlcep != p_dlcep_1) {

							/* Save the CTX2 */

						p_dlna_2 	= p_dlna;
						p_dlchan_2  = p_dlchan;
						p_dlsap_2	= p_dlsap;
						p_dlcep_2	= p_dlcep;

							/* switch to current context to CTX 1 */

						p_dlna 		= p_dlna_1;
						p_dlchan	= p_dlchan_1;
						p_dlsap 	= p_dlsap_1;
						p_dlcep 	= p_dlcep_1;

							/* Load the CTX 1 with CTX 2 pointers */

						R_p_dlna 	= p_dlna_2;
						R_p_dlchan	= p_dlchan_2;
						R_p_dlsap 	= p_dlsap_2;
						R_p_dlcep 	= p_dlcep_2;

						R_lc_state	= LC_RELEASED;
						R_first		=
						R_last		= P_NIL;

							/* If one CEP force ATTACH if not done */

						if ((p_dlchan == P_NIL) && (Dlcep_nb == 1)) {

							if (dl_access_chan (Nai, 0) == OK) {
								Chani 				= 0;
								Chan_chani_to_sapi 	= Sapi;
								Chan_chani_to_ces  	= Ces;
							}

						}


					}

				} else {

					return (NOK);
				}

			}

		}

	}

#	endif

#	if DL_SIM_ANALYSER == ON
		pr_dl_object ();
#	endif

		/* Return OK */

	return (OK);

}

/*-------------------------------------------------------------------------*/

void dl_load_cr ()
{
	Cr_rcv_command	= CR_COMMAND;
	Cr_rcv_response = CR_RESPONSE;
	Cr_snd_command	= CR_COMMAND;
	Cr_snd_response = CR_RESPONSE;
}

void dl_load_dte_cr ()
{
	Cr_rcv_command	= DTE_CR_RCV_COMMAND;
	Cr_rcv_response = DTE_CR_RCV_RESPONSE;
	Cr_snd_command	= DTE_CR_SND_COMMAND;
	Cr_snd_response = DTE_CR_SND_RESPONSE;
}

void dl_load_dce_cr ()
{
	Cr_rcv_command	= DCE_CR_RCV_COMMAND;
	Cr_rcv_response = DCE_CR_RCV_RESPONSE;
	Cr_snd_command	= DCE_CR_SND_COMMAND;
	Cr_snd_response = DCE_CR_SND_RESPONSE;
}

/*-------------------------------------------------------------------------*/

void	dl_init_with_configuration_param ()
{
	N201_tx			= N201;
	N201_rx			= N201;
	K	   			= K_cfg;
	Ti_val (T200) 	= T200_val;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dl_reset_config - implements the reseting of
						  a data link layer object.

Usage           uchar dl_reset_config (nai);
					- nai : NAI to be reset.

Return value    uchar return code = OK reset configuration is done,
									NOK reset configuration has failed.

Common constants and declarations : dl.h

Common objects  na			: network access
				sap			: service access point
				dlcep		: data link connection end point

*--------------------------------------------------------------------------*/

#if RESET_CONFIG == ON

uchar dl_reset_config (nai)
	nai_t	nai;
{
	struct dlna 		FAR *p_na_prior;	/* temporary dlna pointer */

#if DL_LAPX == ON
	uchar					i;				/* index */
#endif

		/* ----------------------- NA loop -------------------------- */

	p_na_prior = P_NIL;

	for (dl_access_first_na (); p_dlna != P_NIL; dl_access_next_na ()) {

		if (Nai == nai) {

				/* The Line should be OFF before reseting the configuration */

			if (Na_active != OFF) {
				return (NOK);
			}

#			if OPTIMIZATION == SPEED
				p_dlna_tab[nai]	= P_NIL;
#			endif

				/* Update the NA link */

			if (p_na_prior == P_NIL) {
				p_dl_tree = (((struct node FAR *)p_dlna) - 1) -> p_next;

			} else {

				(((struct node FAR *)p_na_prior) - 1) -> p_next =  (((struct node FAR *)p_dlna) - 1) -> p_next;
			}

				/* Free the timer cells associated to the NA */

				/*---- CHANNEL loop ----*/

#			if DL_LAPX == ON

					/* XT1 timer reset */

				if (Na_type == SCI_HDTM) {

					for (i = 0; i < Na_channel_nb; i++) {

						dl_access_chan (nai, i);
						Timer_free (Chan_dlx_xt1_id);
					}
				}

#			endif

				/*---- SAP loop ----*/

			for (dl_access_first_dlsap (); p_dlsap != P_NIL; dl_access_next_dlsap ()) {

				for (dl_access_first_dlcep (); p_dlcep != P_NIL; dl_access_next_dlcep ()) {

					Timer_free (Ti_id (T200));
					Timer_free (Ti_id (T203));

				}

			}

				/* And free the NA memory block */

			Mem_free ((char FAR *)P_mem_blk, PID_VL);

			return (OK);
		}

		p_na_prior = p_dlna;
	}

	return (NOK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             	dl_audit_in - implements the management of the DL audit
								  array used to store the DL current context
								  after processing an event.

Usage            	void dl_audit_in ();

Return value : void

Common constants and declarations : dl.h

Common objects : current context pointers (p_dlna and p_dlcep)

*--------------------------------------------------------------------------*/

#if DL_AUDIT == ON

struct dl_audit {
	long	system_time;				/* system time for time stamping */
	uchar	last_event;					/* last received event */
	nai_t	nai;						/* network access ID */
	sapi_t	sapi;						/* service access point ID */
	ces_t	ces;						/* connection endpoint suffix */
	uchar	tei;						/* terminal endpoint identifier */
	uchar 	chani;						/* channel identifier */
	uchar 	own_receiver_state;			/* receiver busy */
	uchar 	remote_receiver_state;		/* remote busy */
	uchar  	v_s;						/* multiple frame operation / send state variable V(S) */
	uchar  	v_a;						/* multiple frame operation / acknowledge state variable V(A) */
	uchar  	v_r;						/* multiple frame operation / receive state variable V(R) */
	uchar   rc;							/* retransmission counter variable */
	uchar 	state;						/* dlcep state */
	uchar  	remote_ack_pending;			/* pending remote acknowledgment */
	uchar   commit_rq;					/* pending commitment to layer 3 */
	uchar 	reject_exception;			/* reject exception state */
	uchar 	layer_3_initiated;			/* flag layer 3 initiated */
} dl_audit[DL_MX_AUDIT];

short		x_dl_audit = 0;				/* current index */

void dl_audit_in ()
{

	if (p_dlcep != P_NIL) {

			/* Get and store system time */

		dl_audit[x_dl_audit].system_time 	= System_time ();

			/* Copy last received event ID */

		dl_audit[x_dl_audit].last_event = event_id;

			/* Copy address nai and sapi */

		dl_audit[x_dl_audit].nai				= Nai;					/* network access ID */
		dl_audit[x_dl_audit].sapi				= Sapi;					/* service access point ID */

			/* Copy from the current call context */

		dl_audit[x_dl_audit].ces				= Ces;					/* connection endpoint suffix */
		dl_audit[x_dl_audit].tei				= Tei;					/* terminal endpoint identifier */
		dl_audit[x_dl_audit].chani				= Chani;				/* channel identifier */
		dl_audit[x_dl_audit].own_receiver_state	= Own_receiver_state;	/* receiver busy */
		dl_audit[x_dl_audit].remote_receiver_state= Remote_receiver_state;/* remote busy */
		dl_audit[x_dl_audit].v_s				= Vs;					/* multiple frame operation / send state variable V(S) */
		dl_audit[x_dl_audit].v_a				= Va;					/* multiple frame operation / acknowledge state variable V(A) */
		dl_audit[x_dl_audit].v_r				= Vr;					/* multiple frame operation / receive state variable V(R) */
		dl_audit[x_dl_audit].rc					= Rc;					/* retransmission counter variable */
		dl_audit[x_dl_audit].state				= State;				/* cep state */
		dl_audit[x_dl_audit].remote_ack_pending	= Remote_ack_pending;	/* pending remote acknowledgment */
		dl_audit[x_dl_audit].commit_rq			= Commit_rq;			/* pending commitment to layer 3 */
		dl_audit[x_dl_audit].reject_exception	= Reject_exception;		/* reject exception state */
		dl_audit[x_dl_audit].layer_3_initiated	= Layer_3_initiated;	/* flag layer 3 initiated */

			/* Load global dl state (for displaying in BG) */

		dl_state = State;

			/* Next entry */

		x_dl_audit = ((++x_dl_audit >= DL_MX_AUDIT) ? 0 : x_dl_audit);
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				dl_var_init - init of DL entity's global variables.

Usage            	void dl_var_init ();

Return value :		void

Common constants and declarations : dl.h

Common objects : DL global variables.

*--------------------------------------------------------------------------*/

void dl_var_init ()
{
	dl_init_flag			= OFF;
	p_dl_tree				= P_NIL;

#	if OPTIMIZATION == SPEED
		p_dlna_tab			= P_NIL;
#	endif

#	if DL_IDENTIFICATION == ON
		p_dl_ident_profile	= P_NIL;
#	endif

#	if DL_AUDIT == ON
		x_dl_audit			= 0;
#	endif

	dl_state				= 0;
	dl_att_ni				= OFF;

	dl_internal_queue.p_first 	=
	dl_internal_queue.p_last 	= P_NIL;

#	if OM_CODE_TYPE == OM_PIC	/* specific functions used only for PIC */
		pic_init_dl ();
#	endif		
}

/*EOF*/
