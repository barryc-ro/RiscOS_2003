
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - mdl.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *         mdl - implements the mdl entity main function.
 *
 *         tei_local_rm - implements the local removal of a TEI identity.
 *
 *		   mdl_config - implements the mdl configuration and initialization
 *         and the init-message sending to the DL entity.
 *
 *         mdl_build_object - implements the building of the data link
 *		   layer management objects.
 *
 *		   mdl_access_na - implements the access to the NA context using
 *		   nai as access key.
 *
 *		   mdl_access_first_na - implements the access to the first NA
 *		   context.
 *
 *		   mdl_access_next_na - implements the access to the next NA
 *		   context acording to the current NA pointer.
 *
 *		   mdl_access_sap - implements the access to the SAP context using
 *		   sapi as access key.
 *
 *		   mdl_access_first sap and mdl_access_next_sap - implement
 *		   the sequential access to the SAP context.
 *
 *		   mdl_access_ces - implements the access to the
 * 		   current context from the  addressing elements.
 *
 *		   mdl_send_dl, mdl_send_dl_connand mdl_send_dl_data - implements
 *         the sending of a message and a data unit from the MDL entity
 *         to the DL entity.
 *
 *		   mdl_retransmit - implements the retransmission of a
 *		   received message.
 *
 *		   mdl_in_queue_tap and mdl_out_queue_tap - implements the queue
 *         management of the mdl structure.
 *
 *		   mdl_discard_queue_tap - implements the clearing of the all
 *		   the messages from the sap service queue.
 *
 *		   mdl_tap_chk - implements the initialization on the p_tap pointer
 *		   and the checking of the received TAP message.
 *
 *         mdl_error_report - implements the processing of an error
 *		   detected in the MDL entity.
 *
 *         tei_local_rm - implements the removal of a TEI if neccessary.
 *
 *		   mdl_alloc_data - implements the allocation of a message or a
 *	       buffer according to the data size.
 *
 *		   mdl_build_assign_from_current_and_send - implements the
 *		   building of a MDL ASSIGN REQUEST primitive and its sending
 *		   to the DL connection.
 *
 *		   mdl_tei_time_assign - mdl_tei_time_removal - implements the
 *		   the assignment or removal of the TEI according to the mask
 *		   event and according to the configuration requirement.
 *
 *		   mdl_var_init - init of MDL entity's global variables.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    LAP-BRICKS                                       |*/
/*|    ISDN-BRICKS                                      |*/
/*|    X25-BRICKS                                       |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

		/* Compilation options */

#define ENTITY 			MDL					/* layer Management Data Link entity */
#define MODULO 			128					/* MODULO 128 */

#include "dl.h"

		/* Copyright */

CONST char 	mdl_copyright[]	= "Copyright (c) 1989 - 1991 by OMNITEL SA - All Rights Reserved";
CONST char 	mdl_licence[]	= LICENSE_NBER;

		/* Common variables */

	Entity_common (mdl);					/* MDL entity common variables */

			/* Access to the MDL objects */

struct	mdlna 			FAR *p_mdlna;		/* pointer to the current Network Access object */
struct 	mdlsap 			FAR *p_mdlsap;		/* pointer to the current Service Access Point object */
struct	mdlcep 			FAR *p_mdlcep;		/* pointer to the current Connection Endpoint object */

		ces_t				ces;			/* Current CES index */

#		if (DL_LAP4K  == ON) || (DL_LAPF == ON)
			uchar			vc_id;			/* Virtual Channel ID */
			ushort			first_mdlces;	/* position of the first mdlces structure */
#		endif

			/* MDL option flag */

uchar						mdl_att_ni;		/* AT&T and NI option flag */

			/* TAP pointer and tei value */

struct 	tap 			FAR *p_tap;  		/* pointer to the TAP message */

#if DL_LAP4K == ON
	struct 	tap_lap4k	FAR *p_tap_lap4k;	/* pointer to the TAP_LAP4K message */
#endif

#if (DL_LAPF == ON) && ((DL_LAPF_ADD_FF_3 == ON) || (DL_LAPF_ADD_FF_4 == ON))
	ulong				 	tei;			/* TEI or DLCI received value */

#else

	ushort				 	tei;			/* TEI or DLCI received value */
#endif

			/* MDL objects : context location declaration */

struct 	node			FAR	*p_mdl_tree;	/* pointer to the first node of the NA object context */

#if OPTIMIZATION == SPEED
	struct mdlna	FAR* FAR *p_mdlna_tab;	/* Na access table pointer */
#endif

/*


		-------------           ------------
		|           | ------->  |          |
		|    DL     |           |   MDL    |--------> MDL_USER or MDL_NET
		|           | <-------  |          |<-------    |   ----> MDL_FROM_MC_XXX
		-------------           ------------            |  |
														V  |
												  --------------
												  |  MC_USER   |
												  |  MC_NET    |
												  --------------

*/

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name           	mdl  - implements the Data Link layer Management entity.

Usage           uchar mdl (p_msg);
					- struct message FAR *p_msg;

Related
functions usage uchar mdl_config 		(struct dl_config FAR *p_dl_config);
				uchar mdl_access_ces	(nai_t nai, sapi_t sapi, ces_t ces);
				void send_dl			(uchar prim_code, uchar sapi, ces_t ces, uchar info);
				void send_dl_data		(uchar prim_code);
				void in_queue_tap		();
				void out_queue_tap		();
				void start_timer		(uchar x_timer);
				void stop_timer			(uchar x_timer);
				void set_state			(uchar state_code);
				void Free_msg			(struct message *p_msg);
				void mdl_from_dl_user	(void);
				void mdl_from_dl_net	(void);
				void id_chk_ti			(void);
				void id_tei_ti			(void);

Description     mdl implements the MDL entity which manages the TEI
				assignment procedure and the error reporting.

Return value    uchar return code  	= OK
									= NOK

Common constants and declarations : dl.h

Common objects : message and buffer context.

*--------------------------------------------------------------------------*/

uchar mdl (p_msg)
	struct message FAR *p_msg;				/* pointer on received message */
{
	uchar				FAR *p_data;		/* data pointer */
	struct dl_config 	FAR *p_dl_config;	/* data configuration pointer */
	nai_t					 nai;			/* temporary NAI */

#	if EQUIPMENT == NT2
		uchar				tei_received;	/* TEI */
#	endif

#	if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)
		uchar 	  	 	  	 i;				/* index */
		struct na 		FAR	*p_dl_config_na;/* current pointer to the na object */
#	endif

		/* Initialize message, buffer and entity pointers context */

	p_rcv_msg 	= p_msg;

start:

	p_buffer  	= R_msg_p_buffer;
	event_id 	= R_msg_code;
	p_data		= R_a_data;
	nai			= R_msg_nai;

	p_snd_msg 	= P_NIL;
	p_mdlna		= P_NIL;
	p_mdlsap	= P_NIL;
	p_mdlcep	= P_NIL;
	tei			= DL_TEI_NIL;
	ces			= DL_CES_NIL;

#	if (DL_LAP4K  == ON) || (DL_LAPF == ON)
		first_mdlces = 0;
		vc_id		 = 0;
#	endif

		/* Incoming message execution */

			/* Dispatch according to the origination entity */

	switch (R_msg_from) {

			/******************************/
			/*          FROM              */
			/*     SYSTEM ENTITY          */
			/******************************/

		case ENT_SM :

			switch (event_id) {

					/* Configuration message */

				case SM_SET_CONFIG_RQ :

						/* Configure and initialize objects in MDL and in DL */

					p_dl_config = (struct dl_config FAR *) p_data;

#					if DL_MLP == ON

						if (Dl_config_mlp_flag == OFF) {

#					endif

							if (mdl_config (p_dl_config) == OK) {

									/* Send the received buffer to the Data Link entity */

								mdl_retransmit (MDL_SET_CONFIG_RQ, ENT_DL);

							} else {

								Dl_config_ret_code = NOK;
								mdl_retransmit (SM_SET_CONFIG_CO, ENT_SM);
							}

#					if DL_MLP == ON

						} else {

							mdl_retransmit (MDL_SET_CONFIG_RQ, ENT_DL);
						}

#					endif

					break;

#				if (DL_LAPD == ON) /* { */

						/* SM_DL_TEI_RQ */

						/* Load a non-automatic TEI value 								*/
						/* R_msg_inf0 = NIL (return code) 								*/
						/* R_msg_inf1 = SAPI or DL_SAPI_NIL if no DL assignment to do 	*/
						/* R_msg_inf2 = TEI or DL_TEI_NIL (revalid the previous TEI) 	*/
						/* R_msg_inf3 = CES 											*/

					case SM_DL_TEI_RQ :

#						if EQUIPMENT == NT2 /* { */

							switch (Na_fct) {

								case FG_NT_TE :
									ret_code = NOK;
									break;

								default :

										/* Init current NA object pointer */

									ret_code 		= NOK;
									tei_received 	= (uchar)R_msg_inf2;

									if (mdl_access_na (nai) == OK) {

											/* Assign non-automatic TEI */

										mdl_assign_non_automatic_tei ();
									}

									R_msg_inf0 = ret_code;
									R_msg_inf2 = tei_received;

									mdl_retransmit (SM_DL_TEI_CO, ENT_SM);
									break;

							}

#						else /* EQUIPMENT == NT2 } else { */

								/* Init current NA object pointer */

							ret_code = NOK;

							if (mdl_access_na (nai) == OK) {

									/* Assign non-automatic TEI */

								mdl_assign_non_automatic_tei ();
							}

							R_msg_inf0 = ret_code;

							mdl_retransmit (SM_DL_TEI_CO, ENT_SM);

#						endif /* EQUIPMENT != NT2 } */

						break;

#				endif /* (DL_LAPD == ON) } */

						/* Buffer congestion request */

				case SM_BUSY_RQ :

					for (mdl_access_first_na (); p_mdlna != P_NIL; mdl_access_next_na ()) {
						mdl_send_dl (MDL_BUSY_RQ, DL_SAPI_MDL, DL_CES_NIL, 0);
					}
					break;

						/* End of buffer congestion request */

				case SM_CLEAR_BUSY_RQ :

					for (mdl_access_first_na (); p_mdlna != P_NIL; mdl_access_next_na ()) {
						mdl_send_dl (MDL_CLEAR_BUSY_RQ, DL_SAPI_MDL, DL_CES_NIL, 0);
					}
					break;

					/* Network Access is disconnected */

				case SM_STOP_RQ :

						/* Retransmit message to DL entity */

					mdl_retransmit (MDL_STOP_RQ, ENT_DL);
					break;

						/* unload the configuration */

#				if RESET_CONFIG == ON /* { */

					case SM_RESET_CONFIG_RQ :

						if (mdl_access_na (nai) == OK) {

								/* The Line should be OFF before resetting the configuration */

							if (Na_active == OFF) {

									/* Retransmit message to DL entity */

								mdl_retransmit (MDL_RESET_CONFIG_RQ, ENT_DL);

							} else {

								Confirm_ret_code = NOK;

									/* Retransmit to SM with an error code */

								mdl_retransmit (SM_RESET_CONFIG_CO, ENT_SM);
							}

						}

					break;

#				endif /* RESET_CONFIG == ON } */

					/* Channel B : SAPI management */

#				if (DL_LAPB == ON) || (DL_V120 == ON) || (DL_LAPF == ON) /* { */

					case SM_DL_ATTACH_SAPI_RQ :

#						if (DL_LAPF == ON) || (DL_LAP4K == ON)

								/* Attach Virtual Channel to SAP */

							if (mdl_access_na (nai) == OK) {

								if (mdl_access_sap (Dl_ass_sapi) == OK) {

									if ((Dl_entity_id == ENT_DL_F) &&
										(Na_type == BRI) || (Na_type == PRI)

#										if DL_PRI_MULTI_D == ON
											|| (Na_type == PRI_MULTI_D)
#										 endif

										) {
										Vc_id = Dl_ass_vc_id;
									}

								}

							}

#						endif

						mdl_retransmit (MDL_ATTACH_SAPI_RQ, ENT_DL);
						break;

					case SM_DL_DETACH_SAPI_RQ :

#						if (DL_LAPF == ON) || (DL_LAP4K == ON)

								/* Detach Virtual Channel from SAP */

							if (mdl_access_na (nai) == OK) {

								if (mdl_access_sap (Dl_ass_sapi) == OK) {

									if ((Dl_entity_id == ENT_DL_F) &&
										(Na_type == BRI) || (Na_type == PRI)

#										if DL_PRI_MULTI_D == ON
											|| (Na_type == PRI_MULTI_D)
#										endif

										) {
										Vc_id = DL_VC_ID_NIL;
									}

								}

							}
#						endif

						mdl_retransmit (MDL_DETACH_SAPI_RQ, ENT_DL);
						break;

#				endif /* (DL_LAPB == ON) || (DL_V120 == ON) || (DL_LAPF == ON) } */

#				if (DL_LAPD == ON) /* { */

						/* Line powered ON */

					case SM_NA_POWER_ON_RQ :

						if (mdl_access_na (nai) == OK) {

#							if DL_PH_MUX == ON

								if (Na_a_mdlmux != P_NIL) {

										/* PHYSICAL MULTIPLEX processing : duplicate the received message */

									mdl_ph_mux (Na_a_mdlmux);

								}

#							endif

							Na_ph_connect_state = ON;

							mdl_tei_time_assign (DL_TEI_TIME_POWER_ON |
												 DL_TEI_TIME_CONFIGURATION);
						}
						break;

						/* Line powered OFF */

					case SM_NA_POWER_OFF_RQ :

						if (mdl_access_na (nai) == OK) {

#							if DL_PH_MUX == ON

								if (Na_a_mdlmux != P_NIL) {

										/* PHYSICAL MULTIPLEX processing : duplicate the received message */


									mdl_ph_mux (Na_a_mdlmux);

								}

#							endif

							Na_ph_connect_state = OFF;

							mdl_tei_time_removal (DL_TEI_TIME_POWER_OFF);
						}
						break;

#				endif /* (DL_LAPD == ON) } */

					/* Information request : first DL info */

				case SM_INFO_RQ :

#					if DL_STATISTICS == ON
						mdl_retransmit (MDL_INFO_RQ, ENT_DL);
#					else

							/* No statistics: confirm directly with no data */

						Mdl_info_entity_origination = ENT_MDL;
						Mdl_info_type				= INFO_TYPE_STATISTICS;
						mdl_retransmit (SM_INFO_CO, ENT_SM);
#					endif

					break;

				default :
					break;

			}
			break;


			/******************************/
			/*          FROM              */
			/* PHysical management entity */
			/*             or             */
			/*    PHysical D  entity      */
			/******************************/

#	if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

		case ENT_MPH 	:
		case ENT_MPH_D 	:
		case ENT_MPH_B 	:
		case ENT_PH_D 	:

				/* Init current NA object pointer */

			if (mdl_access_na (nai) == OK) {

#				if DL_PH_MUX == ON

					if (Na_a_mdlmux != P_NIL) {

							/* PHYSICAL MULTIPLEX processing : duplicate the received message */


						mdl_ph_mux (Na_a_mdlmux);
					}

#				endif

				switch (event_id) {

						/* MPH activation indication */

					case MPH_ACT_IN :
					case PH_ACT_IN  :
						Na_ph_active_state = ON;

#						if (DL_LAPD == ON)

							if (Na_dl_entity_id == ENT_DL_D) {

									/* LAPD */

								switch (Na_fct) {

									case FG_NT_TE :

#										if EQUIPMENT == NT2
											start_id_chk (TAP_ALL_TEI);
#										endif

										break;

									default :

											/* TEI to assign ? */

										mdl_tei_time_assign (DL_TEI_TIME_POWER_ON		|
															 DL_TEI_TIME_ACTIVATION 	|
															 DL_TEI_TIME_CONFIGURATION);
										break;
								}

							}

#						endif

						break;

						/* MPH deactivation indication */

					case MPH_DEA_IN :
					case PH_DEA_IN  :
						Na_ph_active_state = OFF;

							/* Clear assignments in progess */

							/* Scan the CES structure of the NA */

						for (ces = 0; ces < Ces_nb; ces++) {

							if (State != TAP_FREE) {

									/* Discard the waiting queue */

								mdl_discard_queue (QU_TAP);

									/* Free the current state */

								Rq_ri 			= RI_NIL;
								State 			= TAP_FREE;
								Stop_timer_t202 ();

#								if (DL_LAP4K == ON) || (DL_LAPF == ON)

										/* Indication DLCI value */

									In_dlci = DL_DLCI_NIL;

#								endif

							}

#							if DL_LAP4K == ON

								if ((Na_dl_entity_id == ENT_DL_4K) &&
									(Ti_state_t201 == ON)) {

										/* Discard the waiting queue */

									mdl_discard_queue (QU_L3);

										/* Free the current state */

									Stop_timer_t201 ();
									Ti_state_t201 = OFF;
								}

#							endif


						}

#						if DL_LAPD == ON

								/* Local TEI to remove ? */

							mdl_tei_time_removal (DL_TEI_TIME_DEACTIVATION);

#						endif

						break;

				}

			}

			break;

#		endif /* (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) } */

			/******************************/
			/*           FROM             */
			/*     DATA LINK ENTITIES     */
			/******************************/

		case ENT_DL   		:
		case ENT_DL_D 		:
		case ENT_DL_B 		:

#	if DL_LAP4K == ON
		case ENT_DL_4K 		:
#	endif

#	if DL_LAPF == ON
		case ENT_DL_F 		:
#	endif

#	if DL_V120 == ON
		case ENT_V120 		:
#	endif

					/* DL set configuration done ? */

			switch (event_id) {

				case MDL_SET_CONFIG_CO :

						/* Action at the Initialization time : TEI assignment */

#					if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

						p_dl_config = (struct dl_config FAR *)p_data;

#						if DL_MLP == ON

							if (Dl_config_mlp_flag == OFF) {

#						endif

									/* In order not to reuse the buffer pointer */

								p_buffer 	= P_NIL;

								if (Dl_config_ret_code == OK) {

									for (i = 0; i < Dl_config_na_nb; i++) {
										p_dl_config_na	= (struct na FAR *)&Dl_config_object_na (i);

										if (mdl_access_na (Dl_config_nai) == NOK) {
											break;
										}

#										if EQUIPMENT == NT2

												/* TEI check if BRI access */

											mdl_from_dl_net ();

#										else

#											if DL_LAPD == ON

													/* TEI assignment if requested */

												mdl_tei_time_assign (DL_TEI_TIME_CONFIGURATION);

#											endif

#										endif

									}

								}

#						if DL_MLP == ON

							}

#						endif

#					endif /* (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) } */

						/* Retransmit a SM_SET_CONFIG_CO to the System Management */

					mdl_retransmit (SM_SET_CONFIG_CO, ENT_SM);

					break;


				case MDL_SAPI_CO :

						/* Retransmit a SM_DL_SAPI_CO to the System Management */

					mdl_retransmit (SM_DL_SAPI_CO, ENT_SM);
					break;

				case MDL_STOP_CO :

					if (mdl_access_na (nai) == OK) {

#						if DL_LAPD == ON

								/* Remove all the TEI identity */

							tei_local_rm (TAP_ALL_TEI);

#						endif

						Na_active = OFF;
						mdl_retransmit (SM_STOP_CO, ENT_SM);
					}
					break;

#				if RESET_CONFIG == ON

					case MDL_RESET_CONFIG_CO :

						if (Confirm_ret_code == OK) {
							Confirm_ret_code = mdl_reset_config (nai);
						}

						mdl_retransmit (SM_RESET_CONFIG_CO, ENT_SM);
						break;

#				endif

					/* Information confirm */

#			  if DL_STATISTICS == ON

				case MDL_INFO_CO :

					if (mdl_access_na (nai) == OK) {

							/* Add error counters to the received message */

						Memcpy_far ((char FAR *)Mdl_info_a_dl_err,  (char FAR *)&Dl_err_type  (0), sizeof (Dl_err_type  (0)) * (DL_ERR_TYPE_NB));
						Memcpy_far ((char FAR *)Mdl_info_a_mdl_err, (char FAR *)&Mdl_err_type (0), sizeof (Mdl_err_type (0)) * (MDL_ERR_TYPE_NB));

							/* Transmit to SM */

						mdl_retransmit (SM_INFO_CO, ENT_SM);
					}

					break;

#			  endif

					/* Message from the D channel */

				default :

						/*
							If system congestion the incoming messages
							are ignored.
						 */

					if (Congestion_busy) {
						break;
					}

						/*
							Message a with a Data Link Connection
							End point address.
						*/

						/* Init current CES */

					ces	= R_msg_ces;

						/* Init current object pointers */

					if (mdl_access_ces (nai, R_msg_sapi, ces) == NOK) {

						if (event_id != MDL_ERR_IN) {
							Trap (TRAP_MDL_ACCESS, "mdl");
						}

					} else {

#						if DL_LAP4K == ON

							if (Dl_entity_id == ENT_DL_4K) {

									/* LAP4K */

								mdl_lap4k ();

							} else

#						endif

#						if DL_LAPF == ON

							if (Dl_entity_id == ENT_DL_F) {

									/* Process the DL message */

								mdl_lapf ();

							} else

#						endif

#						if (DL_LAP4K == ON) || (DL_LAPF == ON)

							{

#						endif


								/* LAPD */

									/* Functional grouping */

								switch (Na_fct) {

									case FG_NT_TE :

#										if EQUIPMENT == NT2
											mdl_from_dl_net ();
#										endif

										break;

									default :
										mdl_from_dl_user ();
										break;

								}

#						if (DL_LAP4K == ON) || (DL_LAPF == ON)

							}

#						endif


							/* Clear the situation before going out. */

						Free_msg	(p_snd_msg); p_snd_msg	= P_NIL;
						Free_msg	(p_rcv_msg); p_rcv_msg	= P_NIL;

						p_buffer							= P_NIL;

							/* Connection Management request ON ? */

						if (p_mdlcep != P_NIL) {

							if (Mc_state == MC_AWAITING_CONFIRM) {
								break;
							}

						} else {

							break;
						}

							/*
							   Is there requests in the CES waiting queue ?
							   process the next one.
							*/

						if (State == TAP_FREE) {

							if (mdl_out_queue (QU_TAP) == OK) {
								goto start;
							}

						}

#						if DL_LAP4K == ON

							if (Ti_state_t201 == OFF) {

								if (mdl_out_queue (QU_L3) == OK) {
									goto start;
								}

							}

#						endif

					} 	/* End access == OK */

			} /* end switch */

			break;

			/******************************/
			/*           FROM             */
			/*        TIMER ENTITY        */
			/******************************/

		case ENT_TI	  :

#			if (DL_LAPD == ON) || (DL_LAP4K == ON) /* { */

					/* NA access */

				if (mdl_access_na (nai) == NOK) {
					break;
				}

					/* Init current CES */

				if ((ces = R_msg_ces) > Ces_nb) {
					break;
				}

#				if DL_LAP4K == ON

					if (Na_dl_entity_id == ENT_DL_4K) {

							/* LAP4K */

						mdl_lap4k ();

					} else {

#				endif

							/* Switch according event ID */

						switch (event_id) {

#							if EQUIPMENT == NT2

									/* Network side timer T201 has expired */

								case TI_201 :
									mdl_from_dl_net ();
									break;

#							endif


								/* User side timer T202 has expired */

							case TI_202 :
								mdl_from_dl_user ();
								break;

#							if MC_TEST_PROCEDURE == ON || MC_DEFAULT_PARAMETER == OFF

									/* XID timer has expired */

								case TI_204 :

										/* Connection Management */

									if (mdl_access_ces (nai, R_msg_sapi, ces) == NOK) {
										break;
									}

										/* Functional grouping */

									switch (Na_fct) {

										case FG_NT_TE :

#											if EQUIPMENT == NT2
												mdl_from_dl_net ();
#											endif

											break;

										default :
											mdl_from_dl_user ();
											break;

									}

									break;

#							endif

#							if MC_TEST_PROCEDURE == ON

									/* Error counter timer */

								case TI_205 :

										/* Reset interval timer error counter */

									Err_counter_int = 0;

										/* Periodic timer */

									Start_timer_t205 ();
									break;

#							endif

								/* Unexpected timer event : ignored message */

							default :
								break;

						} /* end of switch timer primitive code */

#				if DL_LAP4K == ON
					}
#				endif

					/*
					   Is there requests in the CES waiting queue ?
					   process the next one.
					*/

				if (State == TAP_FREE) {

					if (mdl_out_queue (QU_TAP) == OK) {
						goto start;
					}

				}

#				if DL_LAP4K == ON

					if (Ti_state_t201 == OFF) {

						if (mdl_out_queue (QU_L3) == OK) {
							goto start;
						}

					}

#				endif

				break;

#			endif /* (DL_LAPD == ON) || (DL_LAP4K == ON) } */

			/******************************/
			/*                            */
			/*  UPPER LAYER ORIGINATION   */
			/*                            */
			/******************************/

		default :

#			if (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

					/* Init current CES */

				ces	= R_msg_ces;

					/* Init current object pointers */

				if (mdl_access_ces (nai, R_msg_sapi, ces) == OK) {

					if (L3_entity_id == R_msg_from) {

						switch (Dl_entity_id) {

								/* Check if LAP4K */

#							if DL_LAP4K == ON

								case ENT_DL_4K :

										/* Process LAP4K */

									mdl_lap4k_from_l3 ();


										/*
										   Is there requests in the CES waiting queue ?
										   process the next one.
										*/

									if (State == TAP_FREE) {

										if (mdl_out_queue (QU_TAP) == OK) {
											goto start;
										}

									}

									if (Ti_state_t201 == OFF) {

										if (mdl_out_queue (QU_L3) == OK) {
											goto start;
										}

									}

									break;
#							endif

#							if DL_LAPF == ON

									/* Check if LAPF */

								case ENT_DL_F :

										/* Process LAPF from upper layer */

									mdl_lapf_from_l3 ();
									break;
#							endif

						}

					} else {


						/******************************/
						/*                            */
						/*   UNEXPECTED ORIGINATION   */
						/*                            */
						/******************************/

						break;							/* ignored message */

					}

				}

#			endif /* (DL_LAP4K == ON) || (DL_LAPF == ON) } */


			break;

	}	/* End switch from */

		/* Free the remaining messages if necessary */

	Free_msg (p_rcv_msg);
	Free_msg (p_snd_msg);

		/* Exit from MDL entity */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            mdl_config - implements the initialisation of the MDL entity
				from the SM_SET_CONFIG_RQ message and the sending of the init
				message to the Data Link entity.

Usage           uchar mdl_config (struct dl_config FAR *p_dl_config);
					- p_dl_config : pointer on the data configuration.

Related
functions usage uchar *Timer_alloc ();
				void send_dl_data (uchar prim_code);
				void Srand_omnitel (int init_rand);

Description     mdl_config implements the loading of the MDL objects and
				the creation and sending of the DL CONFIG REQUEST message.

Return value    uchar return code  	= OK
									= NOK

Common constants and declarations : dl.h

Common objects : message and buffer context.

*--------------------------------------------------------------------------*/

uchar mdl_config (p_dl_config)
	struct 	dl_config 	FAR	*p_dl_config;		/* configuration data structure */
{
	uchar 					 i, j, l;			/* temporary loop index */
	struct 	na 			FAR	*p_dl_config_na;	/* current pointer to the na object */
	struct 	sap 		FAR	*p_dl_config_sap;	/* current pointer to the sap object */
	uchar					 k_i;				/* temporary */

#	if DL_LAPF == ON
		uchar				 vc_id_conf;		/* use to save VC ID for Single channel case */
#	endif

#	if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)
		ushort				 mx_ces;			/* max number of CES */
#	endif

#	if DL_PH_MUX == ON
		struct mdlmux	FAR	*p_mdlmux;			/* MDL MUX pointer */
		struct mdlna	FAR *p_mdlna_sav;		/* used to save the NA context pointer */
		nai_t				 ph_nai;			/* current PH NAI */
		nai_t				 nai;				/* current NAI */
#	endif

		/* Build the objects and the access paths */

	if (mdl_build_object (p_dl_config) == NOK) {
		return (NOK);
	}
		/* Init MDL object and send an configuration message to DL */

		/*------------------------------ MDL NA ----------------------------*/

	for (i = 0; i < Dl_config_na_nb; i++) {

		p_dl_config_na	= (struct na FAR *)&Dl_config_object_na (i);
		mdl_access_na (Dl_config_nai);

			/* Load AT&T and NI option flag */

		Na_att_ni_flag = Dl_config_att_ni_flag;

			/* Init NA context */

				/* Load NA Contants */

		Na_type					= Dl_config_type;				/* type of access */
		Na_fct					= Dl_config_fct;				/* fonctional grouping of the NA */
		Sap_nb					= Dl_config_sap_nb;				/* number of SAP in the NA */

		Na_tei_time_assignment 	= Dl_config_tei_time_assignment;/* TEI assignment time */
		Na_tei_time_removal 	= Dl_config_tei_time_removal;	/* TEI removal time */

		Na_active				= ON;							/* line is active */
		Na_ph_connect_state		= OFF;							/* PH state not connected */
		Na_ph_active_state		= OFF;							/* PH state not active */

			/* TEI management : usefull for LAPD only */

#		if EQUIPMENT == NT2

				/* NT2 terminal side : TEI allocation base */

			if (Na_fct == FG_NT_TE) {
				Tei_base = DL_TEI_AUTOMATIC_UP;			/* Tei base of the ASP */
			}

#		endif

#		if MC_TEST_PROCEDURE == ON

				/* Timer used to clear the error counters */

			if ((Ti_id_t205	= Timer_alloc (ENT_MDL, Nai, DL_SAPI_MDL, DL_CES_BROADCAST)) == P_NIL) {
				return (NOK);
			}

			Ti_val_t205		= T205_I;

				/* Start the timer for the error counters clear procedure */

			Start_timer_t205 ();

#		endif

#		if (DL_LAPF == ON) || (DL_LAP4K == ON)
			Vc_to_first_mdlces (0) = first_mdlces = 0;
#		endif

#		if DL_PH_MUX == ON

				/* DL PHYSICAL MULTIPLEXER */

				/* Initialise the dlchan pointer */

			if (Dl_config_ph_mux == ON) {

					/* Master mux NAI */

				p_mdlmux = Na_a_mdlmux;

					/* Reset the virtual NAI attachments */

				for (j = 0; j < DL_MX_NA_PER_MUX; j++) {
					Mdl_mux_nai (j) = NAI_NIL;
				}

			} else {

					/* Slave or "normal" NAI */

				if ((ph_nai = Dl_config_ph_nai) != NAI_NIL) {

						/* It should be a Slave mux NAI */

						/* Remember the current NAI */

					nai = Nai;

						/* Save the DL NA context pointer */

					p_mdlna_sav = p_mdlna;

						/* The related Master NAI should already be configured */

					if (mdl_access_na (ph_nai) == NOK) {
						return (NOK);
					}

						/* The Master NAI must be multiplexed */

					if ((p_mdlmux = Na_a_mdlmux) != P_NIL) {

							/* The current NAI is a Slave mux NAI */

							/* Find and reserve a free virtual NAI attachment */

						for (j = 0; j < DL_MX_NA_PER_MUX; j++) {

							if (Mdl_mux_nai (j) == NAI_NIL) {
								Mdl_mux_nai (j) = nai;
								break;
							}

						}

							/* Too many NAIs attached to the Physical NAI ? */

						if (j == DL_MX_NA_PER_MUX) {
							return (NOK);
						}

							/* Restore the DL NA context pointer */

						p_mdlna = p_mdlna_sav;

					} else {

							/*
								The Master NAI is not multiplexed:
								assume that the current NAI is a "normal" one
							*/

							/* Restore the DL NA context pointer */

						p_mdlna = p_mdlna_sav;

					}

				}

			}

#		endif

#		if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

			mx_ces = Ces_d_nb;

				/*--------------- Init NA/CES data structure table ------------ */

			for (ces = 0; ces < mx_ces; ces++) {

					/* TEI Non broadcast connection */

					/* Terminal S0, S2, T2 */

#				if EQUIPMENT == TE /* { */

				switch (Na_type) {

					case PRI :

							/* TEI Broadcast */

						if (ces == DL_CES_BROADCAST) {
							Tap_tei 				=
							Tap_tei_non_automatic 	= DL_TEI_BROADCAST;

						} else {

									/* PRI - T2 ==> TEI from the configuration list */

							if (Dl_config_tei (ces) < DL_TEI_AUTOMATIC_LOW) {
								Tap_tei 				=
								Tap_tei_non_automatic 	= Dl_config_tei (ces);

									/* Init the address recognition in the PH level */

								tei = Tap_tei;
								mdl_user_send_sm_dlci ();

							} else if (ces == DL_CES_SIG) {

								Tap_tei 				=
								Tap_tei_non_automatic 	= DL_TEI_POINT_TO_POINT;

									/* Init the address recognition in the PH level */

								tei = Tap_tei;
								mdl_user_send_sm_dlci ();

							} else {

								Tap_tei 				=
								Tap_tei_non_automatic 	= DL_TEI_NIL;
							}

						}

						break;

#					if DL_PRI_MULTI_D == ON /* { */

						case PRI_MULTI_D 	:

									/* TEI from the configuration list */

							if (Dl_config_tei (ces) < DL_TEI_AUTOMATIC_LOW) {
								Tap_tei 				=
								Tap_tei_non_automatic 	= Dl_config_tei (ces);

									/* Init the address recognition in the PH level */

								tei = Tap_tei;
								mdl_user_send_sm_dlci ();

							} else {

								Tap_tei 				=
								Tap_tei_non_automatic 	= DL_TEI_POINT_TO_POINT;

									/* Init the address recognition in the PH level */

								tei = Tap_tei;
								mdl_user_send_sm_dlci ();

							}
							break;

#					endif /* } DL_PRI_MULTI_D == ON */

					case BRI :

							/* TEI Broadcast */

						if (ces == DL_CES_BROADCAST) {
							Tap_tei 				=
							Tap_tei_non_automatic 	= DL_TEI_BROADCAST;

						} else {

								/*
									BRI - S0 ==> automatic or non-automatic
												 TEI.
								*/

							if (Dl_config_tei (ces) < DL_TEI_AUTOMATIC_LOW) {
								Tap_tei 				=
								Tap_tei_non_automatic 	= Dl_config_tei (ces);

									/* Init the address recognition in the PH level */

								tei = Tap_tei;
								mdl_user_send_sm_dlci ();

							} else {

								Tap_tei 				=
								Tap_tei_non_automatic 	= DL_TEI_NIL;
							}

						}

						break;

					default :

						Tap_tei 					=
						Tap_tei_non_automatic 		= DL_TEI_NIL;
						break;

				}

							/* NT2 : S0, T0, T2, S2 */

#				else /* EQUIPMENT == TE } else { */


						/* NT2 BRI terminal side ? S0 */

					if ((Na_type == BRI) && (Na_fct == FG_NT_TE)) {
						Tap_tei 				=
						Tap_tei_non_automatic 	= DL_TEI_NIL;

					} else {

						if (Dl_config_tei (ces) < DL_TEI_AUTOMATIC_LOW) {
							Tap_tei 				=
							Tap_tei_non_automatic 	= Dl_config_tei (ces);

								/* Init the address recognition in the PH level */

							tei = Tap_tei;
							mdl_user_send_sm_dlci ();

						} else if ((Na_type == PRI)

#						if DL_PRI_MULTI_D == ON
							|| (Na_type == PRI_MULTI_D)
#						endif
						) {

							Tap_tei 				=
							Tap_tei_non_automatic 	= DL_TEI_POINT_TO_POINT;

								/* Init the address recognition in the PH level */

							tei = Tap_tei;
							mdl_user_send_sm_dlci ();

						} else {

							Tap_tei 				=
							Tap_tei_non_automatic 	= DL_TEI_NIL;
						}

					}

#				endif /* EQUIPMENT != TE } */


					/* Dynamic values */

				State		= TAP_FREE;			/* no request in progress */
				Rc			= 0;				/* Reset retry count */

					/* Requested status */

				Rq_ri		= RI_NIL;			/* Reset requested RI */
				Rq_ai		= DL_TEI_NIL;       /* Reset requested ai */
				Rq_action	= TAP_NIL;			/* Reset requested action */

					/* TAP queue empty */

				First (QU_TAP) = Last (QU_TAP) = P_NIL;

#				if (DL_LAP4K == ON) || (DL_LAPF == ON)

						/* Indication DLCI value */

					Rq_dlci = In_dlci = DL_DLCI_NIL;

#				endif

#				if DL_LAP4K == ON

						/* L3 queue empty */

					First (QU_L3) = Last (QU_L3) = P_NIL;

#				endif

			} /*------------------------ End for NA/CES -----------------------*/


#			if (DL_LAPF == ON) || (DL_LAP4K == ON)
				Vc_to_first_mdlces (1) = first_mdlces = mx_ces;
#			endif

#		endif /* (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) } */

#		if DL_LAPF == ON /* { */

				/*
					Process the Virtual Channels
					used for switched channel profiles.
				*/

			for (j = 0; j < DL_LAPF_CONFIG_MX_VC; j++) {

				if (Dl_config_lapf_vc_id (j) != DL_VC_ID_NIL) {

					Vc_to_first_mdlces (vc_id = vc_id_conf = Dl_config_lapf_vc_id (j)) = first_mdlces;

					for (ces = 0; ces < Dl_config_lapf_vc_nb_dlci (j); ces++) {

						Tap_dlci 	= Dl_config_lapf_vc_dlci (j, ces);

							/* Dynamic values */

						State		= TAP_FREE;			/* no request in progress */
						Rc			= 0;				/* Reset retry count */

						/* Requested status */

						Rq_ri		= RI_NIL;			/* Reset requested RI */
						Rq_ai		= DL_TEI_NIL;       /* Reset requested ai */
						Rq_action	= TAP_NIL;			/* Reset requested action */

							/* TAP queue empty */

						First (QU_TAP) = Last (QU_TAP) = P_NIL;

							/* Indication DLCI value */

						Rq_dlci = In_dlci = DL_DLCI_NIL;
					}

					mx_ces = first_mdlces += Dl_config_lapf_vc_nb_dlci (j);

				} else {

					break;
				}

				Vc_to_first_mdlces (vc_id + 1) = first_mdlces;

			} /*------------------------ End for VC -----------------------*/

#		endif /* LAPF == ON } */

#		if (DL_LAPF == ON) || (DL_LAP4K == ON)

				/* reset base value */

			first_mdlces	= 0;

#		endif

			/*---------------------------- SAP ----------------------------*/

		for (j = 0; j < Dl_config_sap_nb; j++) {

				/* Init SAP context */

			p_dl_config_sap	= (struct sap FAR *)&Dl_config_object_sap (i, j);

			if (mdl_access_sap (Dl_config_sapi) == NOK) {
				Trap (TRAP_DL_INIT, "mdl_config");
			}

			Dlcep_nb		= Dl_config_dlcep_nb;			/* number of DLCEP in the SAP */

			Na_dl_entity_id	=
			Dl_entity_id	= Dl_config_dl_entity_id;		/* DL entity ID */

#			if (DL_LAPF == ON) || (DL_LAP4K == ON) /* { */

				if ( ! ((Na_type == BRI) || (Na_type == PRI)

#				if DL_PRI_MULTI_D == ON
					|| (Na_type == PRI_MULTI_D)
#				endif

				  )) {

#					if DL_LAPF == ON
						Vc_id = (Dl_entity_id == ENT_DL_F) ? vc_id_conf : 0;

#					else

						Vc_id = 0;
#					endif

				} else {

					Vc_id = DL_VC_ID_NIL;
				}

#			endif /* } */


#			if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

				if (Sapi == DL_SAPI_MDL) {

					if (Na_fct != FG_NT_TE) {
						N202 = Set_default (Dl_config_rc_nb, N202_I);

#						if DL_LAP4K == ON
							Ti_val_t201	 = Set_default (Dl_config_ti_tap, T201_I);
#						endif

						Ti_val_t202	 = Set_default (Dl_config_ti_tap, T202_I);

							/* Set-up all the CES timers */

						for (l = 0; l < mx_ces; l++) {
							ces = l;

#							if DL_LAP4K == ON

								if ((Ti_id_t201	= Timer_alloc (ENT_MDL, Nai, Sapi, ces)) == P_NIL) {
									return (NOK);
								}

#							endif

							if ((Ti_id_t202	= Timer_alloc (ENT_MDL, Nai, Sapi, ces)) == P_NIL) {
								return (NOK);
							}

						}

					}


#				if EQUIPMENT == NT2

					else {

						N203 = Set_default (Dl_config_rc_nb, N203_I);

						if ((Ti_id_t201	= Timer_alloc (ENT_MDL, Nai, DL_SAPI_MDL, DL_CES_BROADCAST)) == P_NIL) {
							return (NOK);
						}

						Ti_val_t201	= Set_default (Dl_config_ti_tap, T201_I);
					}

#				endif

				}

#			endif /* (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) } */


				/* Frame size : configuration value */

			N201_tx_cfg = N201_rx_cfg = Dl_config_n201;			/* maximum  number of octet in an information field */

				/* Window size : K_tx configuration value */

			switch (Na_type) {

				case PRI :

#				if DL_PRI_MULTI_D == ON
					case PRI_MULTI_D :
#				endif

					if (Sapi == DL_SAPI_SIG) {
						k_i = K_I_PRI_SIG;

					} else {

						k_i = K_I_PRI_PCK;
					}
					break;

				case BRI :

					if (Sapi == DL_SAPI_SIG) {
						k_i = K_I_BRI_SIG;

					} else {

						k_i = K_I_BRI_PCK;
					}
					break;

				default :
					k_i = K_I_SCI;
					break;

			}

			K_tx_cfg = Set_default (Dl_config_k, k_i);

				/* T200 timer configuration value */

			T200_cfg = Set_default (Dl_config_ti_0, T200_I);

				/*-------------------------- DLCEP -------------------------*/

			for (l = 0; l < Dl_config_dlcep_nb; l++) {

				if (mdl_access_ces (Nai, Sapi, l) == NOK) {
					Trap (TRAP_DL_INIT, "mdl_config");
				}

				Mc_state	= MC_IDLE;			/* connection management state */

					/* Init current parameter */

				N201_tx			= N201_tx_cfg;
				N201_rx			= N201_rx_cfg;
				K_tx			= K_tx_cfg;
				T200			= T200_cfg;
				L3_entity_id 	= Set_default (Dl_config_l3_entity_id, ENT_L3);

#				if (MC_DEFAULT_PARAMETER == OFF) || (MC_TEST_PROCEDURE == ON) /* { */

					N204 = Set_default (Dl_config_xid_rc_max, N204_I);

					if ((Ti_id_t204	= Timer_alloc (ENT_MDL, Nai, Sapi, l)) == P_NIL) {
						return (NOK);
					}

					Ti_val_t204	= Set_default (Dl_config_xid_ti_val, T204_I);

#					if MC_TEST_PROCEDURE == ON

							/* Init XID I field size */

						N201_xid = N201_tx_cfg;

#					endif

#				endif /* } */

			} /*--------------------- End of dlcep loop --------------------*/

		} /*--------------------------- SAP loop ---------------------------*/

	} /*------------------------------ NA loop -----------------------------*/

			/* Return */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            mdl_build_object - implements the building of the data link
								   layer management objects.

Usage           uchar mdl_build_object (struct dl_config FAR *p_dl_config);
					- p_dl_config : pointer on the data configuration.

Description     mdl_build_object implements the building of the data link
				management objects	(na, sap, dlcep) on a tree structure
				allocated inside the static memory area :

						   | (p_mdlna)
						   v
					mdlna --> mdlna --> mdlna ..... --> mdlna
					mdlces[]  mdlces[]  mdlces[]        mdlces[]
					   |
					   | (p_mdlsap)
					   v
					  mdlsap --> mdlsap --> mdlsap  ... --> mdlsap
									|
									|  (p_mdlcep)
									v
									mdlcep --> mdlcep --> mdlcep ... --> mdlcep

				Each occurrence of object is initialized .


Return value    return code = OK  done
							= NOK failed

Common constants and declarations : dl.h

Common objects : Dl_config : init configuration from MDL layer management

*--------------------------------------------------------------------------*/

uchar mdl_build_object (p_dl_config)
	struct dl_config 	FAR	*p_dl_config;				/* pointer on the init configuration */
{
	uchar 					i,j,l;						/* index */
	struct na 			FAR	*p_dl_config_na;			/* pointer on the current na object of
														   the configuration data */
	struct sap 			FAR	*p_dl_config_sap;			/* pointer on the current sap object of
														   the configuration data */
	short					object_size;				/* total size needed by the object tre structure */
	short					na_object_size;				/* Na current object size */
	uchar					ces_mx_nb;					/* number of CES/TEI in a NA */
	uchar					ces_nb_d;					/* number of CES/TEI in a D channel NA */
	uchar 				FAR	*p_current;					/* pointer on the current free location */
	uchar 				FAR	*p_mem_blk;					/* pointer on the allocated block */
	uchar 				FAR	*p_top_node		= P_NIL;	/* top of the first allocated node */
	struct node 		FAR	*p_node_na 		= P_NIL;	/* pointer on an na node */
	struct node			FAR	*p_node_sap 	= P_NIL;	/* pointer on a sap node */
	struct node			FAR	*p_node_dlcep 	= P_NIL;	/* pointer on a cep node */

#	if OPTIMIZATION == SPEED

			/* Build a  NA access table if not done */

		if (p_mdlna_tab == P_NIL) {

			if ((p_mdlna_tab = (struct mdlna FAR *FAR *)Mem_alloc (sizeof (struct mdlna FAR *) * Na_nb, PID_VL)) == P_NIL) {
				return (NOK);
			}

		}

#	endif
					/* Object occurence building */

		/* ---------------------- NA LOOP ----------------------*/

	for (i = 0; i < Dl_config_na_nb; i++) {
		p_dl_config_na = &Dl_config_object_na (i);

			/* Calculate the area size needed to store the MDL objects */

		ces_mx_nb = 0;

		for (j = 0; j < Dl_config_sap_nb; j++) {
			p_dl_config_sap	= &Dl_config_object_sap (i, j);

			if (Dl_config_dl_entity_id != ENT_DL_F) {

				if (ces_mx_nb < Dl_config_dlcep_nb) {
					ces_mx_nb = Dl_config_dlcep_nb;
				}

			}

		}
			/* Check the number of CES/TEI in the NA context. */

		if ((ces_nb_d = ces_mx_nb) > DL_MX_DLCEP) {
			return (NOK);
		}

#		if DL_LAPF == ON /* { */

				/* Calculate the number of CES used by LAPF Virtual Channels */

		for (j = 0; j < DL_LAPF_CONFIG_MX_VC; j++) {

			if (Dl_config_lapf_vc_id (j) != DL_VC_ID_NIL) {

				if (Dl_config_lapf_vc_nb_dlci (j) <= DL_LAPF_MX_DLCI) {
					ces_mx_nb += Dl_config_lapf_vc_nb_dlci (j);

				} else {

					return (NOK);
				}

			} else {

				break;
			}

		}

#		endif /* DL_LAPF == ON } */



		object_size = na_object_size = 	 Rnd_sizeof (struct node) 	+
										 Rnd_sizeof (struct mdlna) 	+
										(Rnd_sizeof (struct mdlces) * (ces_mx_nb - 1));

#		if DL_PH_MUX == ON

			if (Dl_config_ph_mux == ON) {
				object_size 	+= Rnd_sizeof (struct mdlmux);
			}

#		endif

		for (j = 0; j < Dl_config_sap_nb; j++) {
			p_dl_config_sap	= &Dl_config_object_sap (i, j);
			object_size	+= 	 Rnd_sizeof (struct node) + Rnd_sizeof (struct mdlsap) +
							(Rnd_sizeof (struct node) + Rnd_sizeof (struct mdlcep)) * Dl_config_dlcep_nb;
		}

			/* Memory allocation - tree top initialization */

		if ((p_mem_blk = p_current = Mem_alloc (object_size, PID_VL)) == A_NIL) {
			return (NOK);
		}

		if (p_top_node == P_NIL) {
			p_top_node = p_current;
		}

			/* Check the NAI validity */

		if ((Dl_config_nai >= Na_nb) || (mdl_access_na (Dl_config_nai) == OK)) {
			return (NOK);
		}

			/* Init the node structure */

		if ( i != 0) {
			p_node_na -> p_next = (struct node FAR *) p_current;
		}

		p_node_na				= (struct node FAR *) p_current;
		p_node_na -> p_next 	= P_NIL;
		p_node_na -> p_dp 		= P_NIL;

		p_current				+= na_object_size;

		p_mdlna					= (struct mdlna FAR *) (p_node_na + 1);

#		if DL_PH_MUX == ON


				/* PH MUX ON ? */

			if (Dl_config_ph_mux == ON) {

					/* PH MULTIPLEXER context */

				Na_a_mdlmux = (struct mdlmux FAR *)p_current;

				p_current += Rnd_sizeof (struct mdlmux);
			}

#		endif

		p_node_na -> p_dp		= (struct node FAR *) p_current;

			/* Init NA object with memory and access information */

		P_mem_blk				= p_mem_blk;				/* block alocated to the NA */
		Nai 					= Dl_config_nai;			/* network access ID */

#		if (DL_LAPF == OFF) && (DL_LAP4K == OFF)
			Ces_nb				= ces_mx_nb;				/* number of CES/TEI in the NA */
#		endif

		Ces_d_nb				= ces_nb_d;					/* number of CES/TEI in the NA for D channel */

#		if OPTIMIZATION == SPEED
			p_mdlna_tab [Nai]	= p_mdlna;
#		endif

#		if DL_PH_MUX == ON

			Ph_nai = Nai;

				/* PH redirection ? */

			if ((Dl_config_ph_mux == OFF) && (Dl_config_ph_nai != NAI_NIL)) {
				Ph_nai = Dl_config_ph_nai;
			}

#		endif

			/* ---------------------- SAP LOOP ----------------------*/

		for (j = 0; j < Dl_config_sap_nb; j++) {

			if (j != 0) {						/* set next pointer into last sap if one */
				p_node_sap -> p_next = (struct node FAR *) p_current;
			}

				/*
				   - current node on current location,
				   - set next pointer and prior pointer to nil,
				   - set new current location.
				*/

			p_dl_config_sap			= &Dl_config_object_sap (i, j);

			p_node_sap				= (struct node FAR *) p_current;
			p_node_sap -> p_next	= P_NIL;
			p_node_sap -> p_dp		= P_NIL;

			p_current				+= Rnd_sizeof (struct node) + Rnd_sizeof (struct mdlsap);

			p_node_sap -> p_dp		= (struct node FAR *) p_current;

				/* Initialize current SAP */

					/* Node structure */

			p_mdlsap				= (struct mdlsap FAR *) (p_node_sap + 1);
			Sapi					= Dl_config_sapi;				/* SAP ID */

					/* ------------------- DLCEP LOOP --------------------*/

			for (l = 0; l < Dl_config_dlcep_nb; l++) {

				if (l != 0) {

						 /*
							Sets the next pointer into the last
							created	node if not the first one.
						 */

					p_node_dlcep -> p_next = (struct node FAR *) p_current;
				}

					/*
					   - current node on current location,
					   - set next pointer and prior pointer to nil,
					   - set new current location.
					*/

				p_node_dlcep			= (struct node FAR *) p_current;
				p_node_dlcep -> p_next 	= P_NIL;
				p_node_dlcep -> p_dp 	= P_NIL;

				p_current				+= Rnd_sizeof (struct node) + Rnd_sizeof (struct mdlcep);

					/* Initialize current dlcep */

				p_mdlcep = (struct mdlcep FAR *) (p_node_dlcep + 1);

				Ces = l;

			} /* End of dlcep loop */

		} /* End of sap loop */

	}	/* End na loop */

		/* Is it the first configuration message */

	if (p_mdl_tree == P_NIL) {

			/* Init the P_DL_TREE pointer */

		p_mdl_tree = (struct node FAR *)p_top_node;

	} else {

			/* Link the new NA thread to the existing one */

		for (p_node_na = p_mdl_tree; Next(p_node_na) != P_NIL; p_node_na = Next(p_node_na));
		Next(p_node_na) = (struct node FAR *)p_top_node;
	}

#	if DL_LAPD == ON

			/* Init random routine */

		Srand_omnitel (RANDOM_INIT);

#	endif

		/* Return */

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            mdl_reset_config - implements the reseting of
						  a data link layer object.

Usage           uchar mdl_reset_config (nai);
					- nai : NAI to be reset.

Return value    uchar return code = OK reset configuration is done,
									NOK reset configuration has failed.

Common constants and declarations : dl.h

Common objects  na			: network access
				sap			: service access point
				dlcep		: data link connection end point

*--------------------------------------------------------------------------*/

#if RESET_CONFIG == ON /* { */

uchar mdl_reset_config (nai)
	nai_t	nai;
{
	struct mdlna FAR *p_na_prior;	/* NA prior */
	uchar			 i;				/* loop index */

	p_na_prior = P_NIL;

	for (mdl_access_first_na (); p_mdlna != P_NIL; mdl_access_next_na ()) {

		if (Nai == nai) {

#			if OPTIMIZATION == SPEED
				p_mdlna_tab[nai] = P_NIL;
#			endif

				/* Update the NA link */

			if (p_na_prior == P_NIL) {
				p_mdl_tree = (((struct node FAR *)p_mdlna) - 1) -> p_next;

			} else {

				(((struct node FAR *)p_na_prior) - 1) -> p_next =  (((struct node FAR *)p_mdlna) - 1) -> p_next;
			}

#			if MC_TEST_PROCEDURE == ON
				Timer_free (Ti_id_t205);
#			endif

				/*---- SAP ----*/

			for (mdl_access_first_sap (); p_mdlsap != P_NIL; mdl_access_next_sap ()) {

				if (Sapi == DL_SAPI_MDL) {

					if (Na_fct != FG_NT_TE) {

						for (i = 0; i < Ces_nb; i++) {
							ces = i;
							Timer_free (Ti_id_t202);
						}

					}

#					if EQUIPMENT == NT2

						else {

							Timer_free (Ti_id_t201);
						}

#					endif

				}

#				if (MC_DEFAULT_PARAMETER == OFF) || (MC_TEST_PROCEDURE == ON)

						/*---- DLCEP ----*/

					for (i = 0; i < Dlcep_nb; i++) {
						mdl_access_ces (nai, Sapi, i);
						Timer_free (Ti_id_t204);
					}

#				endif

			} /*--- SAP loop ---*/

				/* Free the NA memory block */

			Mem_free ((char FAR *)P_mem_blk, PID_VL);
			return (OK);
		}

		p_na_prior = p_mdlna;
	}

	return (NOK);

}

#endif /* RESET_CONFIG == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_access_na - implements the access to the NA context using
				nai as access key.

				mdl_access_first_na - implements the access to the first NA
				context.

				mdl_access_next_na - implements the access to the next NA
				context acording to the current NA pointer.

Usage           uchar mdl_access_na			(nai_t nai);
				uchar mdl_access_first_na	();
				uchar mdl_access_next_na	();

Description :	mdl_access_na implements the direct access to the NA context
				through the NA access table or the scanning of the NA context
				using the node sequential structure.

Return value : 	mdl_access_xx returns = OK pointer is set on NA context,
									  = NOK no NA context found, pointer is
										set to NIL.

Common constants and declarations : dl.h

Common objects : NA context.

*--------------------------------------------------------------------------*/

uchar mdl_access_na (nai)
	nai_t	nai;			/* Network Access Identifier */
{

	if (nai >= Na_nb) {
		p_mdlna = P_NIL;
		return (NOK);
	}

#	if OPTIMIZATION == SPEED

		if ((p_mdlna_tab == P_NIL) ||
			((p_mdlna = p_mdlna_tab[nai]) == P_NIL)) {
			return (NOK);
		}

		Mdl_att_ni = Na_att_ni_flag;
		return (OK);

#	else

			/*
				Init the starting address of the node structure
				and the tree scanning.
			*/

		for (mdl_access_first_na (); p_mdlna != P_NIL; mdl_access_next_na ()) {

			if (Nai == nai) {
				Mdl_att_ni = Na_att_ni_flag;
				return (OK);
			}

		}

		p_mdlna = P_NIL;
		return (NOK); 							/* end of na thread */

#	endif

}

/*--------------------------------------------------------------------------*/

uchar mdl_access_first_na ()
{

	if (p_mdl_tree == P_NIL) {
		p_mdlna = P_NIL;
		return (NOK);
	}

	p_mdlna = (struct mdlna FAR *) ((struct node FAR *)p_mdl_tree + 1);
	return (OK);

}

/*--------------------------------------------------------------------------*/

uchar mdl_access_next_na ()
{
	struct node FAR *p_node;

	if (p_mdlna == P_NIL)  {
		return (NOK);
	}

	p_node = (struct node FAR *)p_mdlna - 1;

	if ((p_node = Next_node) == P_NIL) {
		p_mdlna = P_NIL;
		return (NOK);
	}

	p_mdlna = (struct mdlna FAR *) (p_node + 1);
	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_access_sap - implements the access to the SAP context using
				sapi as access key.

Usage           uchar mdl_access_sap (sapi_t sapi);

Description :	mdl_access_sap implements the access to the NA context
				through the scanning of the SAP context using the node
				sequential structure.

Return value : 	mdl_access_sap returns = OK,
									   = NOK.

Common constants and declarations : dl.h

Common objects : NA context.

*--------------------------------------------------------------------------*/

uchar mdl_access_sap (sapi)
	sapi_t	sapi;							/* Service acccess point Identifier */
{

		/*
		   Scan the SAP occurrence using the next pointer
		   to find the match identifier.
		*/

	for (mdl_access_first_sap (); p_mdlsap != P_NIL; mdl_access_next_sap ()) {

		if (Sapi == sapi) {

#			if (DL_LAPF == ON) || (DL_LAP4K == ON)

				if ((vc_id = Vc_id) != DL_VC_ID_NIL) {
					first_mdlces = Vc_to_first_mdlces (vc_id);
				}

#			endif

			return (OK);
		}

	}

	p_mdlsap = P_NIL;


	return (NOK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_access_first sap and mdl_access_next_sap - implement
				the sequential access to the SAP context.

Usage           uchar mdl_access_first_sap ();
				uchar mdl_access_next_sap ();

Description :	mdl_access_xxx_sap implements the access to the NA context
				through the scanning of the SAP context using the node
				sequential structure.

Return value : 	mdl_access_xxx_sap returns = OK,
										   = NOK.

Common constants and declarations : dl.h

Common objects : NA context.

*--------------------------------------------------------------------------*/

uchar mdl_access_first_sap ()
{
	struct node FAR *p_node;

	if (p_mdlna == P_NIL) {
		p_mdlsap = P_NIL;
		return (NOK);
	}

		/*
			Init the starting address of the node structure
			and the tree scanning.
		*/

	p_node = (struct node FAR *)p_mdlna - 1;

	if ((p_node = Down_node) == P_NIL) {
		p_mdlsap = P_NIL;
		return (NOK);
	}

	p_mdlsap	= (struct mdlsap FAR *) (p_node + 1);

#	if (DL_LAPF == ON) || (DL_LAP4K == ON)

		if ((vc_id = Vc_id) != DL_VC_ID_NIL) {
			first_mdlces = Vc_to_first_mdlces (vc_id);
		}

#	endif

	return (OK);

}

/*--------------------------------------------------------------------------*/

uchar mdl_access_next_sap ()
{
	struct node FAR *p_node;

	if (p_mdlsap == P_NIL) {
		return (NOK);
	}

		/*
			Init the starting address of the node structure
			and the tree scanning.
		*/

	p_node = (struct node FAR *)p_mdlsap - 1;

	if ((p_node = Next_node) == P_NIL) {
		p_mdlsap = P_NIL;
		return (NOK);
	}

	p_mdlsap	= (struct mdlsap FAR *) (p_node + 1);


#	if (DL_LAPF == ON) || (DL_LAP4K == ON)

		if ((vc_id = Vc_id) != DL_VC_ID_NIL) {
			first_mdlces = Vc_to_first_mdlces (vc_id);
		}

#	endif

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name  			mdl_access_ces - implements the loading of the current context
				pointers from the object ID.

Usage           uchar mdl_access_ces (nai_t nai, sapi_t sapi, uchar ces);


Description     access to the objects are made using the ID as an index
				and scanning and comparing the ID valiues.

Return value    return code		= OK
								= NOK

Common constants and declarations : dl.h

Common objects	context pointers : p_mdlna, p_mdlsap, p_mdlcep.

*--------------------------------------------------------------------------*/

uchar mdl_access_ces (nai, sapi, ces)
	nai_t 			nai;						/* Network Access ID */
	sapi_t 			sapi;						/* Service Access Point ID */
	ces_t 			ces;						/* Connection Endpoint Suffix */

{
	struct node FAR	*p_node;					/* temporary node pointer */

	p_mdlcep = P_NIL;

		/* Access to the MDL NA context */

	if (mdl_access_na (nai) == NOK) {
		return (NOK);
	}

		/* Access to the MDL SAP context */

	if (mdl_access_sap (sapi) == NOK) {
		return (NOK);
	}

		/* Access to the MDL DLCEP context */

	if (ces >= Dlcep_nb) {
		return (NOK);
	}

		/*
			Init the starting address of the node structure
			and the tree scanning.
		*/

	p_node 	= (struct node FAR *)p_mdlsap - 1;

		/*
		   Scan the DLCEP occurrence using the next pointer
		   to find the match identifier.
		*/


	for (p_node = Down_node; p_node != P_NIL; p_node = Next_node) {
		p_mdlcep = (struct mdlcep FAR *) (p_node + 1);

		if (Ces == ces) {
			return (OK);
		}

	}

	 p_mdlcep = P_NIL;
	 return (NOK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            mdl_send_dl - implements the loading and sending of a message
				without	buffer to the Data Link entity.

				mdl_send_dl_conn - implements the loading and sending of a
				message with or without	buffer to the Data Link connection
				of the data link entity coming from the CME (connection
				management entity).

				mdl_send_dl_data - implements the loading and sending to
				the Data Link entity of a message and a linked buffer coming
				from the LME (layer management entity).

Usage           void mdl_send_dl (code_t prim_code, sapi_t sapi, ces_t ces, uchar info);

				void mdl_send_dl_conn (code_t prim_code, sapi_t sapi, ces_t ces);

				void mdl_send_dl_data (code_t prim_code);

Related
functions usage void send (struct message *p_msg);

Return value    void

Common constants and declarations :	dl.h

Common objects	: message and buffer context.

*--------------------------------------------------------------------------*/

void mdl_send_dl (code, sapi, ces, inf0)
	code_t			code;		/* primitive code */
	sapi_t 			sapi;		/* Service Access Point ID */
	ces_t 			ces;		/* Connection EndPoint Suffix */
	uchar 			inf0;		/* information */
{

		/* Allocated a message if need */

	S_msg_alloc;

		/* Load the message header */

	S_msg_code 		= code;		/* primitive code */
	S_msg_nai 		= Nai;		/* network access ID */
	S_msg_sapi 		= sapi;		/* service access point ID */
	S_msg_ces 		= ces;		/* connection end point suffix */
	S_msg_from 		= ENT_MDL;	/* from MDL entity */
	S_msg_to 		= ENT_DL;	/* to Data Link entity */

		/* load data */

	S_msg_inf0 		= inf0;		/* information to transmit */
	S_msg_data_size	= INF_SIZE; /* data size */

		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg	= P_NIL;
}

/*-------------------------------------------------------------------------*/

void mdl_send_dl_conn (code, sapi, ces)
	code_t			code;		/* primitive code */
	sapi_t 			sapi;		/* Service Access Point ID */
	ces_t 			ces;		/* Connection EndPoint Suffix */
{

		/* Allocated a message if need */

	if (p_snd_msg == P_NIL) {
		S_msg_alloc;
	}

		/* Load the message header */

	S_msg_code 		= code;		/* primitive code */
	S_msg_nai 		= Nai;		/* network access ID */
	S_msg_sapi 		= sapi;		/* service access point ID */
	S_msg_ces 		= ces;		/* connection end point suffix */
	S_msg_from 		= ENT_MDL;	/* from MDL entity */
	S_msg_to 		= ENT_DL;	/* to Data Link entity */

		/* link the buffer if needful */

	S_msg_init_link_buffer;

		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL;

	if (p_buffer != P_NIL) {
		p_buffer = P_NIL;
	}

}

/*-------------------------------------------------------------------------*/

	/* p_buffer : points on the data to be sent */

void mdl_send_dl_data (code)
	code_t		code;				/* primitive code */
{
		/* Allocated a message if not already done */

	if (p_snd_msg == P_NIL) {
		S_msg_alloc;
	}

		/* Load the message header */

	S_msg_code 		= code;				/* primitive code */
	S_msg_nai 		= Nai;				/* network access ID */
	S_msg_sapi 		= DL_SAPI_MDL;		/* management SAP ID */
	S_msg_ces 		= DL_CES_BROADCAST;	/* CES broadcast */
	S_msg_from 		= ENT_MDL;			/* from MDL entity */
	S_msg_to 		= ENT_DL;			/* to Data Link entity */

		/* Link the current buffer to the message if needful */

	S_msg_init_link_buffer;

		/* Send the message and the optional linked buffer */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_retransmit - implements the retransmission of a
				received message.

Usage           void mdl_retransmit (code_t code, ent_id_t to);
					- code : new primitive code,
					- to   : destination entity.

Related
functions usage void Send_message (struct message FAR p_msg);

Common constants and declarations : services.h

Common objects : server context.

*--------------------------------------------------------------------------*/

void mdl_retransmit (code, to)
	code_t		code;		/* primitive code */
	ent_id_t	to;			/* entity Id */
{
	R_msg_code	= code;

	R_msg_to	= to;
	R_msg_from	= ENT_MDL;

	Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;
}

/*-------------------------------------------------------------------------*/

#if DL_LAPD == ON /* { */

void	mdl_set_p_tap ()
{

#	if MESSAGE_SEND_DATA == ON /* { */

			/* Is the message large enough */

		if ((int)Message_data_lgth >= I_tap_size + S_u_size) {

				/* Yes - Use a message only */

			S_msg_alloc;

			S_msg_data_offset	+= S_u_size;
			S_msg_data_size		 = I_tap_size;

				/* Init pointer on the tap area */

			p_tap = (struct tap FAR *)S_msg_a_start_data;

			p_buffer = P_NIL;

		} else

#	endif /* } */

		{

				/* Use a buffer */

				/* Allocation of a buffer */

			p_buffer = Buffer_alloc;

				/* Load buffer header */

			Buffer_data_offset	+= S_u_size;
			Buffer_data_size	 = I_tap_size;

				/* Init pointer on the tap area */

			p_tap = (struct tap FAR *)Buffer_a_start_data;

		}

}

#endif /* DL_LAPD == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name          	mdl_in_queue  - implements the adjonction of a message
				into the service queue.

				mdl_out_queue - implements the extraction of the top
				message	from the sap service queue.

				mdl_discard_queue - implements the clearing of the all
				the messages from the sap service queue.

Usage           void 	mdl_in_queue 		(queue_id);
				uchar 	mdl_out_queue 		(queue_id);
				void 	mdl_discard_queue 	(queue_id);

					. queue_id : Id of the queue.

				p_mdlna points the NA object,
				ces is initialized with the CES value.


Description     see dl_queue management.

Return value     = OK queue not empty, p_rcv_msg contains the next message
				   pointer.

				 = NOK queue empty.

Common constants and declarations : dl.h

Common objects : message context.

*--------------------------------------------------------------------------*/

void mdl_in_queue (queue_id)
	uchar	queue_id;		/* Queue ID */
{

	if (Last (queue_id) == P_NIL) {
		Next (p_rcv_msg)		= Prior (p_rcv_msg) = P_NIL;
		First (queue_id)		= Last (queue_id) 	= p_rcv_msg;

	} else {

		Next (p_rcv_msg)		= P_NIL;
		Prior (p_rcv_msg)		= Last (queue_id);
		Next (Last(queue_id))	= p_rcv_msg;
		Last (queue_id)			= p_rcv_msg;
	}

}

/*-------------------------------------------------------------------------*/

uchar mdl_out_queue (queue_id)
	uchar	queue_id;		/* Queue ID */
{

	Free_msg (p_rcv_msg);

	if ((p_rcv_msg = First (queue_id)) == P_NIL) {
		p_rcv_msg = P_NIL;
		return (NOK);

	} else {

		if (Next (First (queue_id)) == P_NIL) {
			First (queue_id) = Last (queue_id) 	= P_NIL;

		} else {

			Prior (Next (First (queue_id))) 	= P_NIL;
			First (queue_id) 					= Next (p_rcv_msg);
		}

		return (OK);

	}

}
/*-------------------------------------------------------------------------*/

void mdl_discard_queue (queue_id)
	uchar	queue_id;		/* Queue ID */
{
	struct message 	FAR	*p_msg,	FAR *p_old;		/* temporary message pointers */

	for (p_msg = First (queue_id); p_msg != P_NIL; ) {
		p_old		= p_msg;

		if ((L_msg_from == ENT_DL_D) && (L_msg_code == MDL_AS_TEI_IN)) {
			mdl_send_dl (MDL_ERR_RS, Rq_sapi, ces, 'A');
		}

		p_msg		= Next (p_old);
		Free_msg	(p_old);
	}

	First (queue_id) = Last (queue_id) = P_NIL;
}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            mdl_error_report - implements the processing of an error
				detected in the MDL entity.

Usage           uchar mdl_error_report (error_code);
					- error code : code of the detected error.

Related
functions usage

Common constants and declarations : dl.h

Common objects	: received message and buffer, NA context.

*---------------------------------------------------------------------------*/

#if DL_EXTRA_ERROR_REPORTING == ON /* { */

void mdl_error_report (error_code)
	char				 error_code;		/* error code */
{

	uchar			FAR *p_data;			/* data pointer */
	struct message	FAR *p_msg;    			/* current snd message pointer */
	struct buffer	FAR *p_buff;			/* current bufer pointer */

		/* Update the error counters */

	error_code = (error_code < 'a' ? 'a': error_code);
	error_code = (error_code > 'z' ? 'z': error_code);
	++Mdl_err_type (error_code - 'a');

		/* Send the event to SM */

	p_msg 	= P_NIL;
	p_data	= P_NIL;
	p_buff 	= P_NIL;

	Prepare_data_to_send (p_msg, p_buff, Mdl_error_size, p_data);

	if (p_data != P_NIL) {

			/* Load the data */

		Mdl_error_entity_origination	= ENT_MDL;
		Mdl_error_report_type			= REPORT_TYPE_ERROR;

		Mdl_error_event_from			= R_msg_from;
		Mdl_error_code					= R_msg_code;

		Mdl_error_cause					= error_code;
		Mdl_error_tei					= tei;
		Mdl_error_ces					= ces;

			/* Event origination ? */

		switch (R_msg_from) {

				/* From the PH entities */

			case ENT_DL :
			case ENT_DL_D :
			case ENT_DL_B :

				if (R_msg_code == MDL_U_DA_IN) {

						/* Load the error data from the received frame */

					if (R_data_size != 0) {
						Memcpy_far ((char FAR *)Mdl_error_a_data,
									(char FAR *)R_a_data,
									(int)I_tap_size);
					}

				}

				break;

				/* From TIMER */

			default :
				break;
		}

			/* Send the message to the SM entity */

		L_msg_from	= ENT_MDL;
		L_msg_to	= ENT_SM;

		L_msg_nai	= Nai;
		L_msg_sapi	= SAPI_NIL;
		L_msg_add	= ADD_NIL;

		L_msg_code	= SM_REPORT_IN;

		Send_message (p_msg);

	}

}

#endif /* DL_EXTRA_ERROR_REPORTING == ON } */

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            tei_local_rm - implements the removal of a TEI if neccessary.

Usage           uchar tei_local_rm (tei_to_remove);

					- tei_to_remove : TEI identity to remove, if TAP_ALL_TEI
					  remove all the assigned TEI.

Related
functions usage void send_dl (uchar prim_code, sapi_t sapi, uchar ces, info);

return code			= OK  removal done,
					= NOK no removal done.

Common constants and declarations : dl.h

Common objects	: buffer and tap context.

*---------------------------------------------------------------------------*/

#if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

	/* Test if it is necessary to remove  the TEI's, if so do it */
	/* If a TEI shall be removed return OK, if not return NOK */

uchar tei_local_rm (tei_to_remove)
	register ushort		tei_to_remove;			/* TEI to remove */
{
	register uchar 		ces_i;					/* temporary ces */
	uchar				ret_code;				/* return code */
	uchar				tei_i;					/* temporary TEI */

		/* Init the return code to NOK */

	ret_code = NOK;

		/* If point to point, ignore */

	if (tei_to_remove == DL_TEI_POINT_TO_POINT) {
		return (NOK);
	}

		/*
		   Check the TEI to remove,
		   if not valid ignore the message.
		*/

	if ((tei_to_remove > DL_TEI_AUTOMATIC_UP) && (tei_to_remove != TAP_ALL_TEI) && (tei_to_remove != TAP_ALL_AUTOMATIC_TEI)) {
		return (NOK);
	}

		/* Scan the TEI table of the NA */

	for (ces_i = 0; ces_i < Tei_nb; ces_i++) {

		if ((ces_i != DL_CES_BROADCAST) && (Tap_tei_x (ces_i) != DL_TEI_NIL) &&
			(((tei_i = Tap_tei_x (ces_i)) == tei_to_remove) ||
			 ((tei_to_remove == TAP_ALL_TEI) && (Tap_tei_x (ces_i) != DL_TEI_POINT_TO_POINT)) ||
			 (tei_to_remove == TAP_ALL_AUTOMATIC_TEI))
		   ) {

				/* Non automatic TEI ? */

			if (tei_i < DL_TEI_AUTOMATIC_LOW) {

				if (tei_to_remove != TAP_ALL_AUTOMATIC_TEI) {

						/* Error reporting to System Management */

					Mdl_error_report ('g');

				} else {

					continue;
				}

			}

				/* Send the TEI removal information to the System Management */

				/*
					The TEI is already allocated ---> TEI removal procedure:
					- send MDL_RM_TEI_RQ messages to the DL entity.
				*/

			Tap_tei_x (ces_i) = DL_TEI_NIL;

				/*
				   Send a MDL_REMOVE_RQ to all the ces = i connections
				   of all the SAP of the NA.
				*/

			for (mdl_access_first_sap (); p_mdlsap != P_NIL; mdl_access_next_sap ()) {

				if ((Sapi != DL_SAPI_MDL) 		&&
					((Dl_entity_id == ENT_DL_D) ||
					 (Dl_entity_id == ENT_DL_4K)
					)
				   ) {

						/* Send SM_DL_DLCI_IN to warn other layers */

					S_msg_alloc;

					S_msg_inf0		= DL_TEI_REMOVAL;
					S_msg_inf1		= Sapi;
					S_msg_inf2		= tei_i;
					S_msg_inf3		= ces_i;

					S_msg_data_size	= INF_SIZE;

						/* Load the message header */

					S_msg_from 		= ENT_MDL;
					S_msg_to		= ENT_SM;

#					if DL_PH_MUX == OFF
						S_msg_nai	= Nai;

#					else

						S_msg_nai	= Ph_nai;
#					endif

					S_msg_code		= SM_DL_DLCI_IN;

						/* Send the message to the SM entity */

					Send_message (p_snd_msg); p_snd_msg = P_NIL;

					mdl_send_dl (MDL_RM_TEI_RQ, Sapi, ces_i, tei_i);

					ret_code 		= OK;		/* set removal done */
				}

			} /* End for all SAPs ... */

		}  /* Endif tap_tei .... */

	}	/* End for ces_i ... */

	return (ret_code);
}

#endif /* (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_tap_chk - implements the initialization on the p_tap
							  pointer  and the checking of the received
							  TAP message.

Usage           uchar mdl_tap_chk (void);

Return value : 	mdl_tap_chk returns = OK  if TAP message valid tei is loaded,
									= NOK if TAP message invalid.

Common constants and declarations : dl.h.

Common objects : p_rcv_msg, p_buffer, p_tap, tei

*--------------------------------------------------------------------------*/

#if DL_LAPD == ON /* { */

#	if EQUIPMENT == NT2

			/* temporary TEI table for ID_CHK_RS messages */

		uchar mdl_tei_tab [DL_MX_DLCEP + 1];

#	endif

uchar mdl_tap_chk ()
{
	ushort			 data_size;		/* data size */

#	if EQUIPMENT == NT2
		uchar 	FAR	*p_tap_end;		/* End of data */
		ushort		 i, j;			/* Index */
		ushort		 nb_tei;		/* Number of TEI in the table */
#	endif

		/*  Load data size and data pointer */

	if ((p_buffer = R_msg_p_buffer) == P_NIL) {
		data_size 	= R_msg_data_size;
		p_tap 		= (struct tap FAR *)R_msg_a_start_data;

	} else {

		data_size 	= Buffer_data_size;
		p_tap		= (struct tap FAR *)Buffer_a_start_data;
	}

		/*  Check the information size */

#	if EQUIPMENT == NT2

		if ((Na_fct	== FG_NT_TE) && (I_tap_type == TAP_ID_CHK_RS)) {

				/*
					The frame size cannot be lower than I_tap_size,
					but it can greater.
				*/

			if (data_size < I_tap_size) {
				Mdl_error_report ('a');
				return (NOK);
			}

		} else {

				/* The frame size must be I_tap_size */

			if (data_size != I_tap_size) {
				Mdl_error_report ('a');
				return (NOK);
			}

		}

#	else

			/* The frame size must be I_tap_size */

		if (data_size != I_tap_size) {
			Mdl_error_report ('a');
			return (NOK);
		}

#	endif

		/*
			Is the information message valid ?
			if not ignore the message.
		*/

		/* Check tha Management Entity ID (MEI) */

	if (I_tap_mei != TAP_MEI) {
		Mdl_error_report ('b');
		return (NOK);
	}

		/*
		   Action Indicator field extension bit
		   = no extension.
		*/

#	if EQUIPMENT == NT2

		if ((Na_fct	== FG_NT_TE) &&	(I_tap_type == TAP_ID_CHK_RS)) {

			p_tap_end 	= (uchar FAR *)p_tap + data_size;

			i 			= 0;
			--((uchar FAR *)p_tap);	/* because it will be incremented in the loop */

				/* Scan all the AI values until FINAL bit or out of limits */

			do {

				if (((((uchar FAR *)p_tap)++ + I_tap_size) == p_tap_end) ||
					(i == DL_MX_DLCEP)
				   ) {
					Mdl_error_report ('c');
					return (NOK);
				}

				mdl_tei_tab [i++] = I_tap_ai;

			} while (I_tap_ai_ext != EA_FINAL);

				/* Mark the end of the TEI table */

			mdl_tei_tab [i] = DL_TEI_NIL;

				/* Check if all received TEIs are different */

			nb_tei = i;

			for (i = 0; i < nb_tei; i++) {

				tei = mdl_tei_tab [i];

				for (j = i + 1; j < nb_tei; j++) {

					if (tei == mdl_tei_tab [j]) {
						Mdl_error_report ('c');
						return (NOK);
					}

				}

			}

				/* Restore the original p_tap pointer */

			p_tap = (struct tap FAR *)(p_tap_end - data_size);

		} else {

				/* The Action Indicator field (Ai) cannot be extended */

			if (I_tap_ai_ext != EA_FINAL) {
				Mdl_error_report ('c');
				return (NOK);
			}

				/* Load the TEI global variable */

			tei	= I_tap_ai;
		}

#	else

			/* The Action Indicator field (Ai) cannot be extended */

		if (I_tap_ai_ext != EA_FINAL) {
			Mdl_error_report ('c');
			return (NOK);
		}

			/* Load the TEI global variable */

		tei = I_tap_ai;

#	endif

		/* return OK */

	return (OK);
}

#endif /* DL_LAPD == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_alloc_data - implements the allocation of a message or a
								 buffer according to the data size.

Usage           uchar FAR *mdl_alloc_data (ushort size);
					- size   : size of the data area.

Return 			address of the data area , p_buffer = buffer pointer or P_NIL

Common constants and declarations : services.h

Common objects : message and buffer context.

*--------------------------------------------------------------------------*/

#if (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) /* { */

uchar FAR *mdl_alloc_data (size)
	ushort	size;				/* size of the data area */
{
	uchar FAR *p_data;

		/* Buffer or message ? */

	if ((ushort)Message_data_lgth < size) {

			/* Buffer */

		Buffer_alloc;
		Buffer_data_size	= size;
		p_data				= Buffer_a_first_data;

	} else {

			/* Message */

		p_buffer			= P_NIL;
		S_msg_alloc;
		S_msg_data_size		= (uchar)size;
		p_data				= S_msg_a_first_data;
	}

		/* Clear the data area */

	Memset_far ((char FAR *)p_data, 0, size);

		/* Return with a pointer on the data area */

	return (p_data);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_build_asssign_from_current_and_send - implements the
				building of a MDL ASSIGN REQUEST primitive and its sending
				to the DL connection.

Usage           void mdl_build_assign_from_current_and_send (tei_val,
				sapi_val, ces_val);
					- tei_val 	: TEI to assign to the connection,
					- sapi_val 	: SAPI of the conection,
					- ces_val 	: CES of the connection.

Common constants and declarations : dl.h

Common objects : p_rcv_msg, p_snd_msg, p_buffer, MDL objects contexts

*--------------------------------------------------------------------------*/

void mdl_build_assign_from_current_and_send (tei_val, sapi_val, ces_val)
	ushort 		tei_val; 	/* Assigned TEI */
	sapi_t		sapi_val;	/* SAPI */
	ces_t		ces_val;	/* CES */
{
	uchar FAR	*p_data;

		/* Build the MDL ASSIGN REQUEST data area */

	if (mdl_access_ces (Nai, sapi_val, ces_val) == OK) {
		p_data 				= mdl_alloc_data (Mdl_assign_size);

		Mdl_assign_n201_tx 	= N201_tx;		/* TX I or UI max frame size */
		Mdl_assign_n201_rx	= N201_rx;		/* RX I or UI max frame size */
		Mdl_assign_k_tx		= K_tx;			/* K outstanding TX frame */
		Mdl_assign_t200		= T200;			/* T200 timer value */

#		if MC_TEST_PROCEDURE == ON

			/* Save the current N201 TX value for XID test I length */

			N201_xid = Mdl_assign_n201_tx;

#		endif

		Mdl_assign_tei	= tei_val;			/* Assign TEI */

			/* Send MDL ASSIGN REQUEST to DL connection */

		mdl_send_dl_conn (MDL_AS_TEI_RQ, sapi_val, ces_val);
	}

}

#endif /* (DL_LAPD == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON) } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			mdl_tei_time_assign - mdl_tei_time_removal - implements the
				the assignment or removal of the TEI according to the mask
				event and according to the configuration requirement.

Usage           void mdl_tei_time_assign 	(event_mask);
				void mdl_tei_time_removal   (event_mask);
					- event_mask : event mask.

						DL_TEI_TIME_ACTIVATION		TEI time is : line activation
						DL_TEI_TIME_DEACTIVATION	TEI time is : line deactivation
						DL_TEI_TIME_CONFIGURATION	TEI time is : configuration
						DL_TEI_TIME_USER_ACTION		TEI time is : user action
						DL_TEI_TIME_POWER_ON		TEI time is : line power on (connected)
						DL_TEI_TIME_POWER_OFF		TEI time is : line power off (disconnected)
						DL_TEI_TIME_TEI_REMOVAL		TEI time is : received of a REMOVAL message from the network
						DL_TEI_TIME_TEI_DENIED		TEI time is : received of a DENIED message from the network
						DL_TEI_TIME_NIL				TEI time is : not defined

Common constants and declarations : dl.h

Common objects : MDL objects contexts

*--------------------------------------------------------------------------*/

#if DL_LAPD == ON /* { */

void mdl_tei_time_assign (event_mask)
	ushort		event_mask;		/* event mask to match */
{

		/* Test matching event */

	if (Na_tei_time_assignment & event_mask) {

			/* Assign the Signalling TEI if not already done */

			/* Functional grouping : TE side only */

		switch (Na_fct) {

			case FG_NT_TE :
				break;

			default :

					/* Access to the signalling SAPI and the first CES */

				if (mdl_access_ces (Nai, DL_SAPI_SIG, DL_CES_SIG) == OK) {

						/*
							Assign the Signalling TEI's if not already done,
							and continue until all the signalling TEI's are
							assigned.
						*/

					for (ces = DL_CES_SIG; ces < Dlcep_nb; ces++) {

						if (mdl_access_ces (Nai, DL_SAPI_SIG, ces) == OK) {

								/*   CES already assigned ? */

							if (Tap_tei == DL_TEI_NIL) {

									/* Ces not already assigned : assign it */

									/* Assignment under way ? */

								if (State == TAP_AWAITING_RS) {

										/* Wait for completion */

									continue;

								} else {

										/* Is the line in active state ? */

									if (Na_ph_active_state == ON) {

											/* Request TEI ID and set parameters */

										Rc = 0;							/* reset retry count */
										id_tei_rq (DL_SAPI_SIG, ces);

									} else {

											/* Request NA activation to PH */
											/* Allocated a message if need */

										S_msg_alloc;

											/* Load the message header */

										S_msg_code 		= MPH_ACT_RQ;	/* primitive code */

#										if DL_PH_MUX == OFF
											S_msg_nai	= Nai;

#										else

											S_msg_nai	= Ph_nai;
#										endif

										S_msg_sapi 		= PH_SAPI_D;	/* D channel Service Access point ID */
										S_msg_chani 	= PH_CHANI_D;	/* D channel ID */

										S_msg_from 		= ENT_MDL;		/* from MDL entity */
										S_msg_to 		= ENT_MPH;		/* to MPH entity */

											/* Send the message */

										Send_message (p_snd_msg); p_snd_msg	= P_NIL;

										break;		/* Wait */

									}


								}


							}	/* if (Tap_tei == DL_TEI_NIL) */

						}	/* if (mdl_access_ces ()... */

					}	/* For (all CES) */

				} /* If mdl_access_ces () */

				break;

		}	/* if TE side */

	}	/* if tei_time_assignment OK */

}

/*-------------------------------------------------------------------------*/

void mdl_tei_time_removal (event_mask)
	ushort	event_mask;			/* event to match */
{

		/* Matching event ? */

	if (Na_tei_time_removal & event_mask) {

			/* Remove all assigned TEI's */

			/* Functional grouping */

		switch (Na_fct) {

			case FG_NT_TE :

#				if EQUIPMENT == NT2
					mdl_from_dl_net ();
#				endif

				break;

			default :
				tei_local_rm (TAP_ALL_AUTOMATIC_TEI);
				break;

		}

	}

}



#endif /* DL_LAPD == ON } */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             mdl_ph_mux - implements the demultiplexing of a received
				 information from layer 1.

Usage            uchar mdl_ph_mux (struct mdlmux FAR *p_mdl_mux);
					- p_mdl_mux : mux pointer context.

Common constants and declarations : dl.h, dl_comm.h

Common objects	:  Na context pointed by p_mdlna.

*--------------------------------------------------------------------------*/

#if DL_PH_MUX == ON

extern	struct server   FAR *p_server;					/* base server descriptor pointer */
extern	struct entity_descriptor p_entity_descriptor[]; /* entity descriptor table */

void mdl_ph_mux (p_mdlmux)
	struct mdlmux		FAR 	*p_mdlmux;				/* Mux pointer */
{
	uchar				 		 i;						/* current index */
	struct message 	FAR 		*p_msg;					/* current message pointer */
	struct buffer	FAR 		*p_buff;				/* current buffer pointer */
	nai_t				 		 nai;					/* current NAI */
	struct message 	FAR * FAR 	*p_fifo_p_first;        /* Server FIFO first pointer */
	struct message 	FAR * FAR 	*p_fifo_p_last;			/* server FIFO last  pointer */

		/* Look for the received TEI in all multiplexed NAs */

	for (i = 0; i < DL_MX_NA_PER_MUX; i++) {

			/* Process all multiplexed NAs except the received one */

		if (((nai = Mdl_mux_nai (i)) != NAI_NIL) && (nai != Nai)) {

			if ((p_msg = Alloc_msg ()) != P_NIL) {

					/* Copy useful data from *p_rcv_msg to *p_msg */

				Memcpy_far ((char FAR *)p_msg,
							(char FAR *)p_rcv_msg,
							R_msg_data_offset + R_msg_data_size);

				if (R_msg_p_buffer != P_NIL) {

						/* Copy the linked buffer as well */

					if ((p_buff = Alloc_buffer ()) != P_NIL) {

							/* Copy the current reveived buffer in the new one */

						Memcpy_far ((char FAR *)p_buff,
									(char FAR *)p_buffer,
									Buffer_data_offset + Buffer_data_size);

						L_msg_p_buffer = p_buff;

					} else {

						Free_msg (p_msg);
						continue;
					}

				}

					/* Set the NAI origination to the multiplexed NAI */

				L_msg_nai = nai;

					/* Put the message in the server FIFO queue */

				p_fifo_p_first = (struct message FAR *FAR *)&Entity_to_fifo_p_first (L_msg_to);
				p_fifo_p_last  = (struct message FAR *FAR *)&Entity_to_fifo_p_last (L_msg_to);
				Fifo_put_msg (p_fifo_p_first, p_fifo_p_last, p_msg);
			}

		} /* End if () */

	} /* End for (i) */

}

#endif /* DL_PH_MUX == ON */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				mdl_var_init - init of MDL entity's global variables.

Usage            	void mdl_var_init ();

Return value :		void

Common constants and declarations : dl.h

Common objects : MDL global variables.

*--------------------------------------------------------------------------*/

void mdl_var_init ()
{
	p_mdl_tree				= P_NIL;

#	if OPTIMIZATION == SPEED
		p_mdlna_tab			= P_NIL;
#	endif

	mdl_att_ni				= OFF;
}

/*EOF*/
