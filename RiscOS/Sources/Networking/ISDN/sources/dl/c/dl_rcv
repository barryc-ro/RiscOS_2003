
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - dl_rcv.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *        dl_rcv - implements the dispatching of a message received by
 *        the data link entity, according to its addressing information
 *        and its primitive code.
 *
 *        dl_process_act_dea_in - implements the processing of a
 *		  PH_ACT_IN and PH_DEA_IN received according to the NA state.
 *
 *        dl_test_na_chan_activation - implements the processing
 *		  of a received message from the upper layer according to the
 *		  NA channel state.
 *
 *        dl_build_xid_ident_element - implements the building of an XID
 *		  protocol element for identification.
 *
 *		  dl_get_xid_ident_diagnostic - implements the extraction of the
 *		  diagnostic value from the information field
 *
 *        dl_identification - implements the test of identification need
 *		  and the sending of an XID identification frame.
 *
 *        dl_ph_mux - implements the demultiplexing of a received
 *		  frame.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    LAP-BRICKS                                       |*/
/*|    ISDN-BRICKS                                      |*/
/*|    X25-BRICKS                                       |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

	/* Compilation options */

#define ENTITY 	DL_D	/* LAPD Data Link entity */
#define MODULO 	128		/* MODULO 128 */

#include "dl.h"
#include "dl_comm.h"

#if DL_SIM_BUILDER  == ON
	extern	uint	dl_ass_tei;
#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             dl_rcv - implements the dispatching and the first
						  processing of a message received by the
						  data link entity.

Usage            uchar dl_rcv ();

Related
functions usage uchar dl_access_object (nai_t nai, sapi_t sapi, uchar type,
										conn_id_t add);

Description     dl_rcv implements the first processing of a received
						message. It sets the current context for the
						following processing, paticularily the event
						identifier is set according to the message
						code.


Return value    dl_rcv returns a code :

					= OK  : valid frame. The context pointers are set and
							p_rcv_frame points on the received frame.

					= NOK : Invalid frame or no more processing to do.

Common constants and declarations : dl.h, dl_comm.h

Common objects	: unpack receive structure,
				  received message and buffer,
				  current contexts,

*--------------------------------------------------------------------------*/

uchar dl_rcv ()
{
	ushort			data_size;		/* temporary data size */
	nai_t			nai;			/* NA ID */
	sapi_t			sapi;			/* SAP ID */
	add_t			ces;			/* CES and Channel ID */
	code_t			code;			/* primitive code */
	add_t			chani;			/* channel ID */
	ent_id_t		from;			/* entity origination */

#	if DL_PH_TX_DONE == ON
		uchar	FAR *p_data;		/* data pointer */
#	endif

#	if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)
		uchar		 add_ff;		/* Address field format */
#	endif


#	if DL_SIM_BUILDER  == ON
		rcv:
#	endif

		/* Load local variables */

	nai 	= R_msg_nai;
	sapi    = R_msg_sapi;
	ces		= chani = R_msg_add;
	code	= R_msg_code;
	from	= R_msg_from;

#	if DL_EXTRA_ERROR_REPORTING == ON

			/* Reset Unpack frame area */

		Ru_sapi			= DL_SAPI_NIL;
		Ru_tei          = DL_TEI_NIL;

#		if (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)
			Ru_dlci		= DL_DLCI_NIL;
#		endif

		Ru_chani		= PH_CHANI_NIL;
		Ru_cr			= DL_CR_NIL;
		Ru_format		= DL_FORMAT_NIL;
		Ru_command		= DL_COMMAND_NIL;
		Ru_pf			= DL_PF_NIL;
		Ru_ns			= 0xff;
		Ru_nr			= 0xff;
		Ru_header_size	= 0xff;
		Ru_size_total	= 0xffff;

#	endif

		/* Switch according to the message origination */

	switch (from) {

			/***************************
			** From Data Link entities**
			****************************/

		case ENT_DL 		:

#		if DL_LAPB == ON
			case ENT_DL_B 	:
#		endif

#		if DL_LAPD == ON
			case ENT_DL_D 	:
#		endif

#		if DL_V120 == ON
			case ENT_DL_V120:
#		endif

#		if DL_LAPF == ON
			case ENT_DL_F	:
#		endif

#		if DL_LAP4K == ON
			case ENT_DL_4K  :
#		endif

#			if DL_MLP == ON

						/* To MLP speudo entity ? */

				if (R_msg_to == ENT_MLP) {

						/* Process MLP */

					mlp (p_rcv_msg);

						/* return */

					event_id = EV_NIL;
					return (OK);
				}

#			endif

			if (dl_access_object (nai, sapi, TYPE_CES, ces) == NOK) {

				if ((event_id = code) == WAIT_ACK) {
					return (OK);
				}

				Trap (TRAP_DL_RECEIVE, "dl_rcv");

			} else {

#				if DL_RELAY == ON

				{
					struct message FAR *p_msg;

					if ((event_id = code) == WAIT_ACK) {
						return (OK);

					} else {

							/* Relay ? */

						if (R_p_dlna != P_NIL) {

							p_msg = p_rcv_msg;
							p_rcv_msg = P_NIL, p_buffer = P_NIL;
							dl_relay_rcv (p_msg);
							return (NOK);
						}

					}

				}

#				endif

			}

			/*****************************************
			** From Management Data Link entity MDL **
			******************************************/

			/* From layer 2 management entity (MDL) */

		case ENT_MDL :

			if (dl_init_flag == ON) {

				if ( ! ((ces == DL_CES_NIL) || (sapi == DL_SAPI_NIL))) {

					if (dl_access_object (nai, sapi, TYPE_CES, ces) == NOK) {
						event_id = EV_ERR_ADDRESS;
						return (NOK);
					}

				} else {

					if (dl_access_na (nai) == NOK) {
						event_id = EV_ERR_ADDRESS;
						return (NOK);
					}

				}

#				if (DL_SIM_BUILDER == ON) && (DL_LAPD == ON)

						/* TEI assignment ? */

					if (((event_id = code) == MDL_U_DA_RQ) &&
						(dl_ass_tei == ON) &&
						(Dl_entity_id == ENT_DL_D)
					   ) {

						if (Na_fct != FG_NT_TE) {

								/* Assign TEI simulation procedure */

							if (simul_tap () == OK) {
								goto rcv;
							}

						}

					}

#				endif


					/* Init event ID */

				if ((event_id = code) == MDL_U_DA_RQ) {

					if (dl_test_na_chan_activation () == STOP) {
						event_id = EV_NIL;
						break;
					}

				}

			}
			break;

			/***********************
			** From timer process **
			************************/

		case ENT_TI :

#			if DL_IDENTIFICATION == ON

				if (code == TI_XID) {

					if (dl_access_chan (nai, chani) == NOK) {
						event_id = EV_ERR_ADDRESS;
						return (NOK);
					}

					if (Chan_state != S_PH_INFO_TX_AVAILABLE) {
						event_id = code;

						if (dl_process_act_dea_in () == STOP) {
							event_id = EV_NIL;
							return (NOK);
						}

					}

				}

#			endif

#			if DL_LAPX == ON

				if (code == TI_XT1) {

					if (dl_access_chan (nai, chani) == NOK) {
						event_id = EV_ERR_ADDRESS;
						return (NOK);
					}


						/* LAPX in use ? */

					if ((chani != PH_CHANI_NIL) && (Chan_dlx_usage == ON)) {

							/* LAPX significant events */

						event_id = code;
						dl_lapx_event_process ();

							/* Nothing more to do */

						event_id = EV_NIL;
					}


				} else {

#			endif

#			if DL_MLP == ON

				if (sapi >= DL_SAPI_MLP)  {

						/* process MLP */

					mlp (p_rcv_msg);

						/* Return */

					event_id = EV_NIL;
					return (OK);
				}

#			endif

			if (dl_access_object (nai, sapi, TYPE_CES, ces) == NOK) {
				event_id = EV_ERR_ADDRESS;
				return (NOK);
			}

			switch (code) {

				case TI_200 :

					if (Valid_time_out (T200)) {
						event_id           = code;
						State_timer (T200) = OFF;

							/* Increment T200 expiry counter */

						Inc_stat_counter (Na_nb_t200_expiry);

					} else {

						event_id = EV_NIL;
					}

					break;

				case TI_203 :

					if (Valid_time_out (T203)) {
						event_id           = code;
						State_timer (T203) = OFF;

					} else {

						event_id = EV_NIL;
					}

					break;

#				if (DL_V120 == ON) && (DL_V120_XID_NEGOTIATION == ON)

					case TI_V120_XID :

						if (Dl_entity_id == ENT_DL_V120) {

							if (Valid_time_out (TM20)) {
								event_id           = code;
								State_timer (TM20) = OFF;
								break;

							}
						}

						event_id = EV_NIL;
						break;

#				endif

				default:
					event_id = EV_NIL;
					break;
			}

#	if DL_LAPX == ON

		}

#	endif

		break;

			/***************************
			** From PHysical entities **
			****************************/

		case ENT_PH   	:
		case ENT_MPH  	:
		case ENT_MPH_B 	:
		case ENT_PH_D 	:
		case ENT_PH_B 	:

			if (dl_access_chan (nai, chani) == NOK) {
				event_id = EV_ERR_ADDRESS;
				return (NOK);
			}

#			if DL_LAPX == ON

					/* LAPX in use ? */

				if ((chani != PH_CHANI_NIL) && (Chan_dlx_usage == ON)) {

						/* LAPX significant events */

					event_id = code;
					dl_lapx_event_process ();
				}

#			endif

				/*
				   Primitives that concern all the connections
				   of a network access :
						- PH_ACT_IN,
						- PH_DEA_IN.
				*/

			if ((code == PH_ACT_IN) || (code == PH_DEA_IN)) {
				event_id = code;

					/* Process the NA state machine */

				if (dl_process_act_dea_in () == STOP) {
					event_id = EV_NIL;			/* No more to do */
				}

				return (OK);

#			if DL_PH_TX_DONE == OFF

				} else if (code != PH_DA_IN) {

					event_id = EV_NIL;
					return (OK);
				}

#			else

				} else if (code == PH_CLEAR_CO) {

						/* PH CLEAR CONFIRM */

							/* 	Free the message contained
								in the received message.*
							*/

					p_data = R_a_data;
					Free_msg (*(struct message FAR *FAR *)p_data);

				} else if ( ! ((code == PH_DA_IN) || (code == PH_TX_DONE_IN))) {

					event_id = EV_NIL;
					return (OK);
				}

#			endif

				/*
					PH_DA_IN 		: received frame.

					PH_TX_DONE_IN 	: frame transmit done indication.

					Init the current frame address and the frame size.
				*/

					/* Test if chained buffers ? */

			if ((p_buffer 			!= P_NIL) &&
				(Buffer_p_next  	!= P_NIL) &&
				(R_msg_frag_size	!= 0)
			   ){

					/* Frame size */

				Ru_size_total 	= R_msg_frag_size;

					/*
						Search for the buffer where the data
						fragment is starting.
					*/

				for (data_size = Buffer_data_size; data_size < R_msg_frag_offset; data_size += Buffer_data_size) {

					if ((p_buffer = Buffer_p_next) == P_NIL) {
						Trap (TRAP_DL_BUFFER_CHAIN, "dl_rcv");
					}

				}

				p_rcv_frame		= (union frame FAR *)(R_a_data + (R_msg_frag_offset - (data_size - Buffer_data_size)));

			} else {

				Ru_size_total	= R_data_size;
				p_rcv_frame		= (union frame FAR *)R_a_data;
			}


			/* --------------- DL MULTIPLEX PROCEDURE ----------------*/

#			if DL_PH_TX_DONE == ON

					/* PH TX DONE INDICATION */

				if (code == PH_TX_DONE_IN) {

						/* Load the pointer connection context */

					if (R_ea1 == EA_FINAL) {

							/* LAP B */

						dl_access_object (nai, 0, TYPE_CHANNEL, Chan_chani);

					} else {

						switch (Chan_chani_to_dl_entity_id) {

							case ENT_NIL 	:

#							if DL_LAPD == ON

								case ENT_DL_D 	:

										/* LAP D */

									dl_access_object (nai, R_sapi, TYPE_TEI, R_tei);
									break;
#							endif

#							if (DL_V120 == ON)

								case ENT_DL_V120 :

										/* V120 */

									dl_access_object (nai, (Ru_sapi = Chan_chani_to_sapi), TYPE_DLCI, R_dlci);
									break;
#							endif

#							if DL_LAPF == ON

								case ENT_DL_F :

										/* LAPF */

									dl_access_object (nai, (Ru_sapi = Chan_chani_to_sapi), TYPE_DLCI, R_dlci);
									break;
#							endif

#							if DL_LAP4K == ON

								case ENT_DL_4K :

										/* LAP4K */

									if (R_dlci == DL_DLCI_MGT) {
										Ru_sapi = DL_SAPI_LAP4K_MDL;

									} else {

										Ru_sapi = DL_SAPI_LAP4K_DATA;
									}

									dl_access_object (nai, Ru_sapi, TYPE_DLCI, R_dlci);
									break;
#							endif

						}

					}

					event_id 	= PH_TX_DONE_IN;

					return (OK);

				}

#			endif

				/* Increment Rx frame counter */

			Inc_stat_counter (Na_nb_rx_frame);

				/* Is the frame valid ? */

			if (Ru_size_total == 0) {
				Mdl_error_report ('T');
				return (NOK);
			}

				/*
					Load :
						- C/R (Command or Response),
						- SAPI,
					from the frame header.
				*/

			Ru_cr 	= R_cr;             /* C/R bit */
			Ru_sapi	= R_sapi;			/* SAPI */

#		if DL_ISDN_BIOS == OFF

				/* test the EA1 bit */

			if (R_ea1 == EA_FINAL) { 	/* address field format one octet */

#		else

			/*
				ISDN-BIOS address field is not compliant to HDLC standards,
				the address field is one byte only but the address extension
				bit could bit set to "0" instead of "1".
			*/



			if ((R_ea1 == EA_FINAL)||
				(Chan_chani_to_sapi == DL_SAPI_ISDN_BIOS)) {

#		endif

#				if DL_LAPB == ON

						/* LAPB : Load the channel ID */

					Ru_chani  = Chan_chani;

						/* Is the address valid ? */

#					if DL_ISDN_BIOS == OFF

						if ( ! ((Ru_sapi == DL_SAPI_LAPB) &&
								(dl_access_object (nai, 0, TYPE_CHANNEL, Ru_chani) == OK))) {
							Mdl_error_report ('V');
							return (NOK);			/* invalid address */
						}

#					else

						if (dl_access_object (nai, 0, TYPE_CHANNEL, Ru_chani) == NOK) {
							Mdl_error_report ('V');
							return (NOK);			/* invalid address */
						}

						if (Ru_sapi != DL_SAPI_LAPB) {

							if (Isdn_bios == ON) {

								if (Ru_sapi != DL_SAPI_ISDN_BIOS) {
									Mdl_error_report ('V');
									return (NOK);	/* invalid address */
								}

							} else {

								Mdl_error_report ('V');
								return (NOK);		/* invalid address */
							}



						}

#					endif

						/*
						   Check the consistency of the entity ID
						   in the configuration data
						*/

					if (Dl_entity_id != ENT_DL_B) {
						Mdl_error_report ('U');
						return (NOK);
					}

#				else

					return (NOK);
#				endif

			} else {

						/* Address takes two octets : LAPD, V120, LAP4K or 2, 3 4 : LAPF */

#				if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

						/* Is the frame address length valid ? */

					if (Ru_size_total < 2) {
						Mdl_error_report ('T');
						return (NOK);
					}

						/* Is the address field extension bit valid ? */

#					if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

						if (R_ea2 != EA_FINAL) {

							if (Ru_size_total > 2) {

								if (R_ea3 != EA_FINAL) {

									if (Ru_size_total > 3) {

										if (R_ea4 != EA_FINAL) {
											Mdl_error_report ('T');
											return (NOK);

										} else {

											add_ff = 4;
										}

									} else {

										Mdl_error_report ('T');
										return (NOK);
									}

								} else {

									add_ff = 3;
								}

							} else {

								Mdl_error_report ('T');
								return (NOK);
							}

						} else {

							add_ff = 2;
						}

#					endif

					switch (Chan_chani_to_dl_entity_id) {

						case ENT_NIL :

#						if DL_LAPD == ON
							case ENT_DL_D :
#						endif

								/* Address field format = 2 */

							if (add_ff != 2) {
								Mdl_error_report ('T');
								return (NOK);
							}

								/* Load the TEI from the frame header */

							Ru_tei	= R_tei;			/* TEI */

#							if DL_PH_MUX == ON

								if ((chani == PH_CHANI_D) && (Na_a_dlmux != P_NIL)) {

										/* PHYSICAL MULTIPLEX processing : duplicate the received message */

									dl_ph_mux (Na_a_dlmux);

										/*
											Reload the 'nai' variable
											because R_msg_nai could have been
											modified by dl_ph_mux()
										*/

									nai = R_msg_nai;
								}

#							endif

#							if DL_PRI_MULTI_D == ON

								if (Na_type == PRI_MULTI_D) {

										/*  Is the address valid ?
											Access to the DL objects using the
											following keys :
												- NAI,
												- SAPI,
												- CES = CHANI.
										*/

									if (dl_access_object (nai, Ru_sapi, TYPE_CES, chani) == NOK) {
										Mdl_error_report ('U');
										return (NOK);			/* invalid address */
									}

								} else

#							endif

							{

									/*  Is the address valid ?
										Access to the DL objects using the
										following keys :
											- NAI,
											- SAPI,
											- TEI.
									*/

								if (dl_access_object (nai, Ru_sapi, TYPE_TEI, Ru_tei) == NOK) {

#									if EQUIPMENT == NT2

										if (Na_fct == FG_NT_TE) {
											Send_to_mdl_err ('U');
										}

#									endif

									return (NOK);			/* invalid address */
								}

							}
							break;

								/* V.120 */

#					if DL_V120 == ON

						case ENT_DL_V120 :

								/* Address field format = 2 */

							if (add_ff != 2) {

								Mdl_error_report ('T');
								return (NOK);
							}

									/* V120 */

							if (dl_access_object (nai, (Ru_sapi = Chan_chani_to_sapi), TYPE_DLCI_V120, R_dlci) == NOK) {
								Mdl_error_report ('U');
								return (NOK);			/* invalid address */
							}
							break;

#						endif

							/* LAPF */

#						if DL_LAPF == ON

								/* LAPF */

							case ENT_DL_F :

									/* Address Field Format */

								switch (add_ff) {

#									if DL_LAPF_ADD_FF_2 == ON

										case 2 :
											Ru_dlci = R_dlci_f2;
											break;

#									endif

#									if DL_LAPF_ADD_FF_2 == ON

										case 3 :
											Ru_dlci = R_dlci_f3;
											break;

#									endif

#									if DL_LAPF_ADD_FF_2 == ON

										case 4 :
											Ru_dlci = R_dlci_f4;
											break;

#									endif

								}

								if (dl_access_object (nai, (Ru_sapi = Chan_chani_to_sapi), TYPE_DLCI_LAPF, Ru_dlci) == NOK) {
									Mdl_error_report ('U');
									return (NOK);			/* invalid address */
								}

									/* Address field format = 2 */

								if (add_ff != Lapf_add_ff) {
									Mdl_error_report ('T');
									return (NOK);
								}

								break;

#						endif

							/* LAP 4K */

#						if DL_LAP4K == ON

							case ENT_DL_4K :

									/* LAP4K */

								if (R_dlci == DL_DLCI_LAP4K_MGT) {
									Ru_sapi = DL_SAPI_LAP4K_MDL;

								} else {

									Ru_sapi = DL_SAPI_LAP4K_L3;
								}

								if (dl_access_object (nai, Ru_sapi, TYPE_DLCI_LAP4K, R_dlci) == NOK) {
									Mdl_error_report ('U');
									return (NOK);			/* invalid address */
								}
								break;
#						endif

						default :
							Mdl_error_report ('U');
							return (NOK);
					}

#				else

					Mdl_error_report ('U');
					return (NOK);
#				endif

			}

				/*
					Unpack the frame in the received Unpack data structure :
						--> copy the frame field in the unpack received
						structure.
				*/

			switch (Dl_entity_id) {

#				if DL_LAPB == ON

							/* LAPB */

					 case ENT_DL_B :

						if (Modulo == MODULO_EXTENDED) {

#						   if DL_MODULO_128 == ON
								ret_code = up_b_128 ();

#							else

								Trap (TRAP_MODULO_DISABLE, "dl_rcv");
#							endif

						} else {

#							if DL_MODULO_8 == ON
								ret_code = up_b_8 ();

#							else

								Trap (TRAP_MODULO_DISABLE, "dl_rcv");
#							endif

						}
						break;

#				endif

#				if DL_LAPD == ON

						/* LAPD */

					case ENT_DL_D 	:
#				endif

#				if DL_V120 == ON
					case ENT_DL_V120 :
#				endif

#				if DL_LAPF == ON
					case ENT_DL_F :
#				endif

#				if DL_LAP4K == ON
					case ENT_DL_4K :
#				endif

#						if (DL_LAPD == ON) || (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

							if (Modulo == MODULO_EXTENDED) {

#								if DL_MODULO_128 == ON
									ret_code = up_d_128 ();

#								else

									Trap (TRAP_MODULO_DISABLE, "dl_rcv");
#								endif

							} else {

#								if DL_MODULO_8 == ON
									ret_code = up_d_8 ();

#								else

									Trap (TRAP_MODULO_DISABLE, "dl_rcv");
#								endif

							}

							break;

#						endif

				default :
					Trap (TRAP_UNKNOWN_ENTITY, "dl_rcv");

			} /* End switch Dl_entity_id */

				/* Is the frame header length correct ? */

			if (ret_code == NOK) {
				Mdl_error_report ('W');
				return (NOK);
			}

#			if DL_SIM_ANALYSER == ON
					pr_frame ('I');
#			endif

/*

	--------------------------------------------------------------------
	|  Format | commands | Response | Encoding  8  7  6  5  4  3  2  1 |  octet
	|------------------------------------------------------------------|
	|         |          |          |        |      N(S)          | 0  |  4
	| Informa | I(info)  | I V.120  |        |--------------------|----|
	| Transf  |          |          |        |      N(R)          | P  |  5
	|---------|----------|----------|--------|-------------------------|
	|   S     |          |          |        | 0  0  0  0  0  0  0  1  |  4
	|   U     |    RR    |   RR     |        |-------------------------|
	|   P     |          |          |        |      N(R)          |P/F |  5
	|   E     |----------|----------|--------|-------------------------|
	|   R     |          |          |        | 0  0  0  0  0  1  0  1  |  4
	|   V     |    RNR   |   RNR    |        |-------------------------|
	|   I     |          |          |        |      N(R)          |P/F |  5
	|   S     |----------|----------|--------|-------------------------|
	|   O     |          |          |        | 0  0  0  0  1  0  0  1  |  4
	|   R     |    REJ   |   REJ    |        |-------------------------|
	|   Y     |          |          |        |      N(R)          |P/F |  4
	|---------|----------|----------|--------|-------------------------|
	|         |  SABM    |          |        | 0  0  1 |P |1  1 | 1 1  |  4
	|         |----------|----------|--------|---------|--|-----|------|
	|   U     |  SABME   |          |        | 0  1  1 |P |1  1 | 1 1  |  4
	|   N     |----------|----------|--------|---------|--|-----|------|
	|   N     |          |  DM      |        | 0  0  0 |F |1  1 | 1 1  |  4
	|   U     |----------|----------|--------|---------|--|-----|------|
	|   M     |   UI     |          |        | 0  0  0 |P |0  0 | 1 1  |  4
	|   B     |----------|----------|--------|---------|--|-----|------|
	|   E     |   DISC   |          |        | 0  1  0 |P |0  0 | 1 1  |  4
	|   R     |----------|----------|--------|---------|--|-----|------|
	|   E     |          |   UA     |        | 0  1  1 |F |0  0 | 1 1  |  4
	|   D     |----------|----------|--------|---------|--|-----|------|
	|         |   SI0    |   SI0    |        | 0  1  1 |PF|0  1 | 1 1  |  4
	|         |----------|----------|--------|---------|--|-----|------|
	|         |   SI1    |   SI1    |        | 1  1  1 |PF|0  1 | 1 1  |  4
	|         |----------|----------|--------|---------|--|-----|------|
	|         |          |   FRMR   |        | 1  0  0 |F |0  1 | 1 1  |  4
	|---------|----------|----------|--------|---------|--|-----|------|
	|  Mgt    |  XID     |   XID    |        | 1  0  1 |PF|1  1 | 1 1  |  4
	--------------------------------------------------------------------
*/
			/*------------------- DATA LINK PROCEDURE ---------------------*/

				/* Load the received frame size according to the total
				   size of the received data if buffer are chained.
				*/


				/* Load the event ID according to the received frame */

			event_id = FR_ERR_CTRL;

			switch (Ru_format) {

				case I :

						/* Is the Information field size valid ? */

					if (Ru_size_total > Ru_size_up) {
						event_id = FR_ERR_I_TOO_LONG;

						} else if ((Ru_cr == Cr_rcv_command)

#							if DL_ISDN_BIOS == ON
								   || (Isdn_bios == ON)
#							endif

#							if DL_V120 == ON
								   || (Dl_entity_id == ENT_V120)
#							endif

#							if DL_LAPF == ON
								   || (Dl_entity_id == ENT_DL_F)
#							endif

								  ) {

								/* If a command frame or ISDN-BIOS --> OK */

							event_id = FR_I;

								/* Increment RR counter */

							Inc_stat_counter (Na_nb_rx_i);
						}

					break;

				case S :

						/* No extra information in the frame ? */

					if (Ru_size_total > Ru_size_up) {
						event_id = FR_ERR_INFO;

					} else {

							/* Load the event ID from the frame command.*/

						switch (Ru_command) {

							case RR :
								event_id = FR_RR;

									/* Increment RR counter */

								Inc_stat_counter (Na_nb_rx_rr);
								break;

							case RNR :
								event_id = FR_RNR;

									/* Increment RNR counter */

								Inc_stat_counter (Na_nb_rx_rnr);
								break;

							case REJ :
								event_id = FR_REJ;

									/* Increment REJ counter */

								Inc_stat_counter (Na_nb_rx_reject);
								break;

							default :
								event_id = FR_ERR_CTRL;
								break;

						}	/* End switch ru_command */

					}

					break;

				case U :

					switch (Ru_command) {

#						if DL_MODULO_128 == ON

								/* Set Asynchronous Balanced Mode Extended */

							case SABME :

									/* Only if modulo extended */

								if (Modulo == MODULO_EXTENDED) {

										/* No extra information in the frame ? */

									if (Ru_size_total >  Ru_size_up) {
										event_id = FR_ERR_INFO;

									} else if (Ru_cr == Cr_rcv_command) {

										event_id = (Modulo == MODULO_EXTENDED) ?
										FR_SABME : FR_ERR_CTRL;

									} else {

										event_id = FR_ERR_CTRL;
									}

								}

								break;

#						endif

#						if DL_MODULO_8 == ON

								/* Set Asynchronous Balanced Mode */

							case SABM :

								if (Modulo == MODULO_BASIC) {

										/* No extra information in the frame ? */

									if (Ru_size_total >  Ru_size_up) {
										event_id = FR_ERR_INFO;

									} else if (Ru_cr == Cr_rcv_command) {

										event_id = (Modulo == MODULO_BASIC) ? FR_SABM : FR_ERR_CTRL;
									}

								} else {

									event_id = FR_ERR_CTRL;
								}

								break;

#						endif

							/* Disconnected Mode */

						case DM :

								/* No extra information in the frame ? */

							if (Ru_size_total >  Ru_size_up) {
								event_id = FR_ERR_INFO;

							} else if (Ru_cr == Cr_rcv_response) {

								event_id = FR_DM;
							}
							break;

								/* Disconnect */

						case DISC :

								/* No extra information in the frame ? */

							if (Ru_size_total >  Ru_size_up) {
								event_id = FR_ERR_INFO;

							} else if (Ru_cr == Cr_rcv_command) {

								event_id = FR_DISC;
							}
							break;

								/* Unnumbered Acknowledgement */

						case UA :

								/* No extra information in the frame ? */

							if (Ru_size_total >  Ru_size_up) {
								event_id = FR_ERR_INFO;

							} else if (Ru_cr == Cr_rcv_response) {

								event_id = FR_UA;
							}
							break;

								/* Frame Reject */

						case FRMR :

							if (Ru_size_total != Ru_size_up) {
								event_id = FR_ERR_LENGTH;

							} else if (Ru_cr == Cr_rcv_response) {

								event_id = FR_FRMR;

#								if DL_EXTRA_ERROR_REPORTING == ON

										/* Status report to MDL */

									dl_send_to_mdl_report (REPORT_TYPE_STATUS, 0);

#								endif

							}
							break;

								/* Unnumbered Information */

						case UI :

								/* Is the I field size valid ? */

							if (Ru_size_total > Ru_size_up) {
								event_id = FR_ERR_I_TOO_LONG;

							} else if (Ru_cr == Cr_rcv_command) {

								event_id = FR_UI;
							}

							break;

								/* Exchange Identification : XID */

						case XID :

								/* Is the information field size valid ? */

							if (Ru_size_total > Ru_size_up) {
								event_id = FR_ERR_I_TOO_LONG;

							} else if (Ru_cr == Cr_rcv_command) {

								event_id = FR_XID_COMMAND;

							} else {

								event_id = FR_XID_RESPONSE;
							}

							break;

#					   	if DL_U_FRAME == ON

							case SI0 :
							case SI1 :

									/* Is the information field size valid ? */


								if (Ru_cr == Cr_rcv_command) {

									if (Ru_size_total > Ru_size_up) {
										event_id = FR_ERR_I_TOO_LONG;

									} else if (Ru_size_total == Ru_header_size) {
										event_id = FR_SI_COMMAND_EMPTY;

									} else {

										event_id = FR_SI_COMMAND;
									}

								} else {

									if (Ru_size_total == Ru_header_size) {
										event_id = FR_SI_RESPONSE;

									} else {

										event_id = FR_ERR_INFO;
									}

								}

								break;
#						endif

								/* Unknown command */

						default  :
							event_id = FR_ERR_CTRL;
							break;

					} /* End switch */

					break;

					default :
						event_id = FR_ERR_CTRL;
						break;

			}	/* End switch layer 2 */

#			if DL_INVALID_SZ_CHK_DELAYED == ON

					/* Check frame minimum size for incorrect length frame */

				if ((event_id != FR_ERR_CTRL) &&
					(Ru_size_total < Ru_header_size)
				   ) {

					Mdl_error_report ('T');
					return (NOK);
				}

#			endif

#			if DL_IDENTIFICATION == ON

				if (Chan_state != S_PH_INFO_TX_AVAILABLE) {

					if (dl_process_act_dea_in () == STOP) {
						return (NOK);
					}

				}

#			endif

			break;

			/***************************************************
			** Unexpected entity origination or in DL context **
			****************************************************/

		default :

				/* Interface synchronization request (no need for a DL connection) */

			if (code == DL_INT_SYNC_RQ) {
					dl_retransmit (DL_INT_SYNC_CO, from);
					return (NOK);
			}

#			if DL_MLP == ON

				if (sapi >= DL_SAPI_MLP)  {

						/* process MLP */

					mlp (p_rcv_msg);

						/* Return */

					event_id = EV_NIL;
					return (OK);
				}

#			endif

			if (dl_access_object (nai, sapi, TYPE_CES, ces) == NOK)  {
				event_id = EV_ERR_ADDRESS;
				return (NOK);
			}

			if (from == L3_entity_id) {
				event_id = code;

				switch (event_id) {

						/* Commitment request */

					case DL_COMMIT_RQ :

						if (First (QU_I) == P_NIL) {
							Send_to_l3 (DL_COMMIT_CO);

						} else {

							Commit_rq = ON;
						}

						return (NOK);

						/* Flow interface synchronisation */

						/* Flow control : immediat action */

					case DL_BUSY_RQ 		:
					case DL_CLEAR_BUSY_RQ 	:
						break;

					default :

							/* PH state ? */

						if (dl_test_na_chan_activation () == STOP) {

								/* DL connection NOK to process frame */

							event_id = EV_NIL;
						}

				}

			} else {

				Trap (TRAP_DL_RECEIVE, "dl_rcv");
			}

	}

	return (OK);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            dl_process_act_dea_in - implements the processing of a
				PH_ACT_IN and PH_DEA_IN received according to the NA channel
				state.

				This function delays the PH_ACT_IN until the X.32 identification
				by the network side.

Usage           uchar dl_process_act_dea_in ();

Return value    dl_process_act_dea_in returns a code :

					= CONTINUE : continue the processing of the message,

					= STOP : no more processing to do.

Common constants and declarations : dl.h, dl_comm.h

Common objects	:  Na context pointed by p_dlna and p_dlchan.

*--------------------------------------------------------------------------*/

uchar dl_process_act_dea_in ()
{
#	if DL_IDENTIFICATION == ON
		uchar	FAR	*p_data;	/* user data pointer */
		uchar		 diag;		/* diagnostic value */
#	endif

	switch (Chan_state) {

			/* Information transfer not available */

		case S_PH_INFO_TX_NOT_AVAILABLE :

			switch (event_id) {

				case PH_ACT_IN :

#					if DL_IDENTIFICATION == ON

							/* Attach done ? */

						if (Chan_chani_to_sapi  == DL_SAPI_NIL) {
							Chan_state = S_PH_ID_AWAITING_ATTACH;
							return (STOP);
						}

							/* Test if identification required */

						switch (dl_identification ()) {

							case OK :

									/* Reset retry counter */

								Chan_ident_rc = 0;

								Chan_state = S_PH_ID_AWAITING_CO;
								return (STOP);

							case NOK :
								Chan_state = S_PH_INFO_TX_AVAILABLE;
								return (CONTINUE);
						}

#					else

						Chan_state = S_PH_INFO_TX_AVAILABLE;
						return (CONTINUE);
#					endif

				case PH_DEA_IN :
					dl_discard_queue_incoming_rq_co ();
					return (CONTINUE);

				default :
					break;

			}
			break;

			/* Activation requested */

		case S_PH_ACTIVATION_REQUESTED :

			switch (event_id) {

				case PH_ACT_IN :

#					if DL_IDENTIFICATION == ON

							/* Attach done ? */

						if (Chan_chani_to_sapi == DL_SAPI_NIL) {
							Chan_state = S_PH_ID_AWAITING_ATTACH;
							return (STOP);
						}

							/* Test if identification required */

						switch (dl_identification ()) {

							case OK :

									/* Reset retry counter */

								Chan_ident_rc = 0;

								Chan_state = S_PH_ID_AWAITING_CO;
								return (STOP);

							case NOK :
								Chan_state = S_PH_INFO_TX_AVAILABLE;
								return (CONTINUE);
						}

#					else

						Chan_state = S_PH_INFO_TX_AVAILABLE;
						return (CONTINUE);
#					endif

				case PH_DEA_IN :
					Chan_state = S_PH_INFO_TX_NOT_AVAILABLE;
					dl_discard_queue_incoming_rq_co ();
					return (CONTINUE);

				default :
					break;

			}
			break;

			/* Information transfer available */

		case S_PH_INFO_TX_AVAILABLE :

			switch (event_id) {

				case PH_DEA_IN :
					Chan_state = S_PH_INFO_TX_NOT_AVAILABLE;
					return 	 (CONTINUE);

				case PH_ACT_IN :
					return (STOP);

				default :
					break;

			}
			break;

#		if DL_IDENTIFICATION == ON

			case S_PH_ID_AWAITING_ATTACH :

				switch (event_id) {

					case MDL_ATTACH_SAPI_RQ :

							/* Test if identification required */

						switch (dl_identification ()) {

							case OK :

									/* Reset retry counter */

								Chan_ident_rc = 0;

								Chan_state = S_PH_ID_AWAITING_CO;
								return (STOP);

							case NOK :
								Chan_state = S_PH_INFO_TX_AVAILABLE;

									/* Continue the line activation in DL */

								if (p_snd_msg == P_NIL) {
									p_snd_msg = Alloc_msg ();

								} else {

									S_msg_header_init;
								}

								S_msg_from			= ENT_PH;
								S_msg_to			= ENT_DL;

								S_msg_nai			= Nai;
								S_msg_sapi			= Sapi;
								S_msg_chani			= Chani;
								S_msg_code			= PH_ACT_IN;

									/* Put in the DL internal queue : remote execution */

								dl_in_queue (); p_snd_msg = P_NIL;
								return (STOP);
						}

						break;

					case PH_DEA_IN :
						Chan_state = S_PH_INFO_TX_NOT_AVAILABLE;
						dl_discard_queue_incoming_rq_co ();
						return (CONTINUE);

				}
				break;

			case S_PH_ID_AWAITING_CO :

				switch (event_id) {

					case PH_DEA_IN :
						Chan_state = S_PH_INFO_TX_NOT_AVAILABLE;
						dl_discard_queue_incoming_rq_co ();
						return (CONTINUE);

					case FR_XID_RESPONSE :

						if (Ru_p == P_ON) {
							Chan_ident_stop_timer ();
							Chan_state = S_PH_ID_AWAITING_RS;
							return (STOP);
						}
						break;

					case FR_DM :
						Chan_ident_stop_timer ();
						Send_to_mdl_err ('E');

					case TI_XID :

						if (Chan_ident_rc == Chan_ident_rc_max) {

							if (dl_access_object (Chan_chani_to_nai,
								Chan_chani_to_sapi,
								TYPE_CES,
								Chan_chani_to_ces) == OK) {

								Send_to_mdl_err ('O');
								Send_to_ph (PH_DEA_RQ);
								dl_discard_queue_incoming_rq_co ();
								Chan_state = S_PH_INFO_TX_NOT_AVAILABLE;
							}

							return (STOP);

						} else {

								/* Test if identification required */

							if (dl_identification () == OK) {
									(Chan_ident_rc)++;
									return (STOP);
							}

						}
						return (STOP);

					default :
						break;

				}
				break;


			case S_PH_ID_AWAITING_RS :

				switch (event_id) {

					case PH_DEA_IN :
						Chan_state = S_PH_INFO_TX_NOT_AVAILABLE;
						dl_discard_queue_incoming_rq_co ();
						return (CONTINUE);

					case FR_XID_COMMAND :

						if ((Ru_p == ON) && ((diag = dl_get_xid_ident_diagnostic ()) != DL_ID_DIAG_NIL)) {

							if (p_buffer != P_NIL) {
								Free_buffer (p_buffer);
								R_msg_p_buffer = p_buffer = P_NIL;
							}

								/*
									Acknowledge the XID frame with an
									XID response frame.
								 */

							R_msg_data_offset 	= MESSAGE_HEADER_SIZE + DL_MX_FRAME_HEADER;

							p_data				= R_msg_a_start_data;

							*p_data++			= XID_FI_CCITT;
							*p_data++			= XID_GI_USER_DATA;

							R_msg_data_size		= (uchar)((long)p_data - (long)(R_msg_a_start_data));

							send_frame (FR_XID_RESPONSE, Ru_p);


							if (diag == DL_ID_DIAG_CONFIRMED) {
								Chan_state 		= S_PH_INFO_TX_AVAILABLE;

									/* Continue the line activation in DL */

								if (p_rcv_msg == P_NIL) {
									p_rcv_msg = Alloc_msg ();

								} else {

									R_msg_header_init;
								}

								R_msg_nai			= Nai;
								R_msg_sapi			= Sapi;
								R_msg_chani			= Chani;
								R_msg_code			= PH_ACT_IN;

								event_id			= PH_ACT_IN;

								return 	 (CONTINUE);

							} else {

									/*
										Identification failed -->
										deactivated the line.
									 */

								Send_to_ph (PH_DEA_RQ);
								return (STOP);
							}

						}

					default :
						break;

				}
				break;

#		endif

	}

	return (STOP);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             dl_test_na_chan_activation - implements the processing
				 of a received message from the upper layer according to the
				 NA state.

Usage            void dl_test_na_chan_activation ();

return code      = STOP     PH TX not available --> the request is queued
				 = CONTINUE PH TX available

Common constants and declarations : dl.h, dl_comm.h

Common objects	:  Na context pointed by p_dlna, p_dlchan.
*--------------------------------------------------------------------------*/

uchar dl_test_na_chan_activation ()
{

		/* Test according to the NA state */

	switch (Chan_state) {

			/*
				NA not active : start NA activation process
				and queue the incoming request.
			*/

		case S_PH_INFO_TX_NOT_AVAILABLE :

				/*
					If the request is a release request
					response immmediatly :
					  The connection is already released.
				*/

			if (event_id == DL_REL_RQ) {
				Send_to_l3 (DL_REL_CO);

			} else {

				dl_in_queue_incoming_rq_co	();
				Send_to_ph	(PH_ACT_RQ);
				Chan_state = S_PH_ACTIVATION_REQUESTED;
			}
			return (STOP);

#		if DL_IDENTIFICATION == ON

				/* Awaiting for identification */

			case S_PH_ID_AWAITING_ATTACH    :
			case S_PH_ID_AWAITING_CO        :
			case S_PH_ID_AWAITING_RS        :
				dl_in_queue_incoming_rq_co	();
				return (STOP);
#		endif

			/* Activation in process : queue the request */

		case S_PH_ACTIVATION_REQUESTED :
			dl_in_queue_incoming_rq_co ();
			return (STOP);

	}

	return (CONTINUE);

}

#if DL_IDENTIFICATION == ON
/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             dl_build_xid_ident_element - implements the building of an XID
				 protocol element for identification.

				 dl_get_xid_ident_diagnostic - implements the extraction of the
				 diagnostic value from the information field

Usage            void dl_build_xid_ident_element ();

				 uchar dl_get_xid_ident_element ()
				 return the diagnostic value if found else DL_ID_DIAG_NIL.


Common constants and declarations : dl.h, dl_comm.h

Common objects	:  Na context pointed by p_dlna, p_dlchan.
*--------------------------------------------------------------------------*/

void dl_build_xid_ident_element ()
{
	uchar	FAR *p_data;
	uchar	FAR *p_data_start;

		/* Allocate a buffer */

	Buffer_alloc_reused;

	Buffer_data_offset	+= DL_MX_FRAME_HEADER;

	if (p_rcv_msg == P_NIL) {
		p_rcv_msg = Alloc_msg ();
	}

	R_msg_header_init;

	R_msg_init_link_buffer;

	p_data = p_data_start = Buffer_a_start_data;

		/* Load XID header */

	*p_data++ = XID_FI_CCITT;

	*p_data++ = XID_GI_USER_DATA;

		/* Load identity */

	*p_data++ = XID_PI_IDENTITY;
	*p_data++ = DL_ID_SIZE;

	Memcpy_far ((char FAR *)p_data, (char FAR *)Chan_ident_a_id, DL_ID_SIZE);

	p_data += DL_ID_SIZE;

		/* Load signature */

	*p_data++ = XID_PI_SIGNATURE;
	*p_data++ = DL_SIG_SIZE;

	Memcpy_far ((char FAR *)p_data,(char FAR *)Chan_ident_a_sig, DL_SIG_SIZE);

	p_data += DL_SIG_SIZE;

		/* Load data size */

	Buffer_data_size = (uint)((long)p_data - (long)p_data_start);
}

/*--------------------------------------------------------------------------*/

uchar dl_get_xid_ident_diagnostic ()
{
	uchar		FAR	*p_data;			/* pointer on data */
	uchar		FAR	*p_data_last;		/* pointer on last data */

	p_data		= R_a_data + Ru_header_size;
	p_data_last = p_data + R_data_size - 1 - Ru_header_size;

		/* Format Id */

	if (*p_data++ != XID_FI_CCITT) {
		return (DL_ID_DIAG_NIL);
	}

		/* Group user data */

	if (*p_data++ != XID_GI_USER_DATA) {
		return (DL_ID_DIAG_NIL);
	}

		/* Diagnostic parameter */

	if (*p_data++ != XID_PI_DIAGNOSTIC) {
		return (DL_ID_DIAG_NIL);
	}

		/* Check last byte */

	if (p_data != p_data_last) {
		return (DL_ID_DIAG_NIL);
	}

		/* Return diagnostic value */

	return (*p_data);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             dl_identification - implements the test of identification need
				 and the sending of an XID identification frame.

Usage            uchar dl_identification ();

return code      = OK 	identification processed,
				 = NOK  identification not processed

Common constants and declarations : dl.h, dl_comm.h

Common objects	:  Na context pointed by p_dlna, p_dlchan.
*--------------------------------------------------------------------------*/

uchar dl_identification ()

{

	if (Chan_ident_profile_nb != 0) {

		if (dl_access_object (Chan_chani_to_nai,
							  Chan_chani_to_sapi,
							  TYPE_CES,
							  Chan_chani_to_ces) == OK) {

				/* Build the XID identification data frame */

			dl_build_xid_ident_element ();

				/* Send the XID frame */

			send_frame (FR_XID_COMMAND, P_ON);

				/* Start retry timer */

			Chan_ident_start_timer ();

			return (OK);

		} else {

			return (NOK);
		}

	}

	return (NOK);

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             dl_ph_mux - implements the demultiplexing of a received
				 frame.

Usage            uchar dl_ph_mux (struct dlmux FAR *p_dl_mux);
					- p_dl_mux : mux pointer context.

Common constants and declarations : dl.h, dl_comm.h

Common objects	:  Na context pointed by p_dlna, p_dlchan.

*--------------------------------------------------------------------------*/

#if DL_PH_MUX == ON

void dl_ph_mux (p_dlmux)
	struct dlmux		FAR *p_dlmux;					/* Mux pointer */
{
	uchar				 		i;						/* current index */
	struct buffer	FAR 		*p_buff;				/* current buffer pointer */
	nai_t				 		nai;					/* current NAI */

		/* Look for the received TEI in all multiplexed NAs */

	for (i = 0; i < DL_MX_NA_PER_MUX; i++) {

			/* Process all multiplexed NAs except the received one */

		if (((nai = Dl_mux_nai (i)) != NAI_NIL) && (nai != Nai)) {

				/* SAPI, TEI filtering */

			if (Ru_tei != DL_TEI_BROADCAST) {

				if (dl_access_object (nai, Ru_sapi, TYPE_TEI, Ru_tei) == NOK) {

						/* TEI unknown in this NAI: try next NAI */

					continue;

				} else {

						/*
							Found the TEI in this NAI: process the received
							message with this NAI
						*/

					R_msg_nai = nai;
					break;
				}

			}

				/*
					Broadcast TEI: duplicate the received frame
					and queue it into the server queue in order to process it
				*/

			if ((p_snd_msg = Alloc_msg ()) != P_NIL) {

					/* Copy useful data from *p_rcv_msg to *p_msg */

				Memcpy_far ((char FAR *)p_snd_msg,
							(char FAR *)p_rcv_msg,
							R_msg_data_offset + R_msg_data_size);

				if (R_msg_p_buffer != P_NIL) {

						/* Copy the linked buffer as well */

					if ((p_buff = Alloc_buffer ()) != P_NIL) {

							/* Copy the current reveived buffer in the new one */

						Memcpy_far ((char FAR *)p_buff,
									(char FAR *)p_buffer,
									Buffer_data_offset + Buffer_data_size);

						S_msg_p_buffer = p_buff;

					} else {

						Free_msg (p_snd_msg); p_snd_msg = P_NIL;
						continue;
					}

				}

					/* Set the NAI origination to the multiplexed NAI */

				S_msg_nai = nai;

					/* Put the message in the DL internal FIFO queue */

				dl_in_queue ();
			}

		} /* End if () */

	} /* End for (i) */

}

#endif /* DL_PH_MUX == ON */

/*--------------------------------------------------------------------------*/

/*EOF*/



