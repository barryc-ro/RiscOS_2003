
/*---------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - dl_snd.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *		dl_snd - implements the sending of a message from the DL entity.
 *
 *      dl_send_to_mdl_error - implements the sending of an error messsage
 *		to the MDL entity.
 *
 *      dl_send_to_mdl_report - implements the sending of a report messsage
 *		to the MDL entity.
 *
 *    	dl_send_to_mdl_info - implements the sending of an
 *		information confirm message to the MDL entity.
 *
 *		send_frame - implements the sending of a frame to the PH entity.
 *
 *      set_s_frame - set_u_frame implements the loading of the
 *		Send Unpack	structure (SU) for a S/U frame header.
 *
 *		dl_retransmit - implements the retransmission of a received message
 *
 *---------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    LAP-BRICKS                                       |*/
/*|    ISDN-BRICKS                                      |*/
/*|    X25-BRICKS                                       |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

	/* compilation options */

#define ENTITY 	DL_D	/* LAPD Data Link entity */
#define MODULO 	128		/* MODULO 128 */

#include "dl.h"
#include "dl_comm.h"

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name         		dl_snd - implements the sending of a message from a
							 DL entity.

Usage				void dl_snd (uchar to, uchar msg_id);

Related
functions usage 	void Send_message (struct message *p_snd_msg);
						sends the p_snd_msg message

Description     	dl_snd implements the sending of a message generated by
					the DL entity.

Return value    	void

Common constants and declarations : dl.h

Common objects		current cep object

*---------------------------------------------------------------------------*/

void dl_snd (to, msg_id)
	uchar  			msg_id; 					/* message code */
	uchar 			to;							/* destination entity ID */

{
		/* If context on a connexion ---> retry queues I and UI = ON */

	if ((p_dlcep != P_NIL) && (to != ENT_MDL)) {
		Signal_flag (QU_I) = Signal_flag (QU_UI) = ON;
	}

		/* Message to layer 3, to management entity or to physical layer */

			/* If XXX_DA_IN  --> ajust data position and size in the buffer */

	switch (msg_id) {

		case DL_U_DA_IN 	:
		case MDL_U_DA_IN 	:
		case DL_DA_IN 		:
		case MDL_XID_CO 	:
		case MDL_XID_IN 	:

			if (p_buffer  != P_NIL) {

					/* Use the current received buffer */

				if (p_rcv_msg != P_NIL) {
					R_msg_p_buffer = P_NIL;
				}

					/* Remove the frame header */

				Buffer_data_offset 	+= Ru_header_size;		/* discard the header by changing */
				Buffer_data_size	-= Ru_header_size;		/* substract the header size */
				Buffer_link_count	 = 0;					/* reset buffer link count */

					/* Allocate a message */

				S_msg_alloc;

					/* Link the buffer (if any) to the message to be sent. */

				S_msg_init_link_buffer;

			} else {

					/* The received message must be used */

				p_snd_msg			 = p_rcv_msg; p_rcv_msg = P_NIL;
				S_msg_p_buffer		 = P_NIL;

					/* Remove the frame header */

				S_msg_data_offset	+= Ru_header_size;
				S_msg_data_size		-= Ru_header_size;
			}

			break;

		case MDL_SET_CONFIG_CO :

			if (p_buffer  != P_NIL) {

					/* Use the current received buffer */

				if (p_rcv_msg != P_NIL) R_msg_p_buffer = P_NIL;

				Buffer_link_count	 = 0;					/* reset buffer link count */

					/* Allocate a message */

				S_msg_alloc;

					/* Link the buffer (if any) to the message to be sent. */

				S_msg_init_link_buffer;

			} else {

					/* The received message must be used */

				p_snd_msg			 = p_rcv_msg; p_rcv_msg = P_NIL;
				S_msg_p_buffer		 = P_NIL;
			}

			break;

		default :
			break;

	}

		/* Allocate a message if not already done */

	if (p_snd_msg == P_NIL) {
		p_snd_msg 	= Alloc_msg ();
	}

		/* Load the message header fields */

	if (p_dlna == P_NIL) {
		S_msg_nai	= NAI_NIL;
		S_msg_from	= ENT_DL;

	} else {

		S_msg_nai 	= Nai;						/* Na ID */

		if (p_dlcep != P_NIL) {
			S_msg_from 	= Dl_entity_id;  		/* origination entity ID */

		} else {

			S_msg_from	= ENT_DL;				/* generic entity */
		}
	}

	S_msg_code	= msg_id;						/* primitive code ID */
	S_msg_to 	= to; 							/* destination entity */

		/* Dispatch according to the destination entity */

	switch (to) {								/* switch according to the destination entity */

		case ENT_MDL :							/* MDL entity */

			if (p_dlcep != P_NIL) {
				S_msg_ces	= Ces;				/* set Connection Endpoint Suffix */
				S_msg_sapi 	= Sapi;				/* set Service Access Point ID */

			} else {

				S_msg_ces	= DL_CES_BROADCAST;
				S_msg_sapi	= DL_SAPI_MDL;
			}

			break;

		case ENT_L3 	:						/* Layer 3 (generic) entity */

			if (p_dlsap != P_NIL) {

#				if DL_ISDN_BIOS == ON

						/* test if ISDN BIOS facilities and frame IN */

					if ((Isdn_bios == ON) && (msg_id == DL_DA_IN)) {

							/* End of NCB flag in priority field */

						if (Ru_sapi == DL_SAPI_ISDN_BIOS) {
							S_msg_priority = ON;

						} else {

							S_msg_priority = OFF;
						}

					}

#				endif

				S_msg_to = L3_entity_id;		/* Load the L3 entity ID from the SAPI */

#				if DL_RELAY == ON

						/* DL relaying ? */

					if ((p_dlcep != P_NIL) && (R_p_dlna != P_NIL)) {

							/* yes - force ENT_DL */

						S_msg_to = ENT_DL;
					}

#				endif
			}

		case ENT_NS :							/* Network Signalling */

			if ((msg_id == DL_EST_IN) || (msg_id == DL_EST_CO)) {
				S_msg_inf0 		= Tei;
				S_msg_data_size = INF_SIZE;
			}

#		if DL_LAPD == ON
			case ENT_DL_D :						/* Data Link LAPD entity */
#		endif

#		if DL_LAPB == ON
			case ENT_DL_B :						/* Data Link LAPB entity */
#		endif

#		if DL_V120 == ON
			case ENT_DL_V120 :					/* V.120 */
#		endif

#		if DL_LAPF == ON
			case ENT_DL_F :						/* LAPF */
#		endif

#		if DL_LAP4K == ON
			case ENT_DL_4K :					/* LAP4K */
#		endif

		case ENT_DL :							/* Data Link generic entity */

			if (p_dlcep != P_NIL) {
				S_msg_ces	= Ces;				/* set Connection Endpoint Suffix */
				S_msg_sapi 	= Sapi;				/* set Service Access Point ID */

			} else {

				S_msg_ces	= DL_CES_NIL;
				S_msg_sapi	= DL_SAPI_NIL;
			}

			break;

		case ENT_PH_D 	:						/* PHysical D channel entity */
		case ENT_MPH 	:						/* PHysical management entity */

#			if DL_PH_MUX == ON
				S_msg_nai = Chan_chani_to_nai;	/* NAI from the channel context */
#			endif

			S_msg_sapi 	= PH_SAPI_D;			/* D channel Service Access point ID */

#			if DL_PRI_MULTI_D == ON

				if (Na_type == PRI_MULTI_D) {

					if (p_dlcep != P_NIL) {
						S_msg_chani = Chani;			/* D channel ID */

					} else {

						S_msg_chani = Chan_chani;		/* current channel Id */
					}

				} else

#			endif

			{
				S_msg_chani = PH_CHANI_D;			/* D channel ID */
			}

			S_msg_priority = ((p_dlsap != P_NIL) &&
							  ((Sapi == DL_SAPI_SIG) ||
							   (Sapi == DL_SAPI_MDL))) ?
							   DL_PRIORITY_SIG : DL_PRIORITY_NO_SIG;

			break;

		case ENT_PH_B 	:             			/* PHysical B channel entity */
		case ENT_PH    	:
		case ENT_MPH_B 	:
			S_msg_sapi  = PH_SAPI_B;			/* PHysical channel Service Access Point ID */

			if (p_dlcep != P_NIL) {
				S_msg_chani = Chani;			/* B channel ID */

			} else {

				S_msg_chani = Chan_chani;		/* current channel Id */
			}

#			if DL_LAPX == ON

					/* Test if Half Duplex mode (HDTM) */

				if ((Chan_chani != PH_CHANI_NIL) && (Chan_dlx_usage == ON)) {

						/* HDTM */

					if (dl_lapx_send () == STOP) {
						return;
					}

				}

#			endif

			break;

		default :
			Trap (TRAP_DL_SEND, "dl_send");		/* inconsistency */
	}

		/* To DL or MLP ? */

	switch (S_msg_to) {

#		if DL_LAPD == ON
			case ENT_DL_D :						/* Data Link LAPD entity */
#		endif

#		if DL_LAPB == ON
			case ENT_DL_B :						/* Data Link LAPB entity */
#		endif

#		if DL_LAPF == ON
			case ENT_DL_F :						/* LAPF */
#		endif

#		if DL_V120 == ON
			case ENT_DL_V120 :					/* V.120 */
#		endif

#		if DL_LAP4K == ON
			case ENT_DL_4K :					/* LAP4K */
#		endif

		case ENT_DL :							/* Data Link generic entity */
		case ENT_MLP :
			dl_in_queue (); p_buffer = P_NIL;
			break;

		default :

				/* Send the message and its associated buffer */

			Send_message (p_snd_msg), p_snd_msg = P_NIL, p_buffer = P_NIL;	/* no more message and buffer available */
	}

}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name         		dl_send_to_mdl_error - implements the sending of a message
					error to the MDL entity.

					dl_send_to_mdl_report - implements the sending of a report
					to the MDL entity.

Usage				void dl_send_to_mdl_error  (uchar error_code);
					void dl_send_to_mdl_report (uchar error_type, error_code);

Related
functions usage 	void Send_message (struct message *p_snd_msg);
						sends the p_snd_msg message

Description     	dl_snd implements the sending of a message generated by
					the DL entity.

Return value    	void

Common constants and declarations : dl.h

Common objects		current cep object

*---------------------------------------------------------------------------*/

void dl_send_to_mdl_error (error_code)
	uchar 			 	error_code;			/* errror code */
{
	dl_send_to_mdl_report (REPORT_TYPE_ERROR, error_code);
}

/*--------------------------------------------------------------------------*/

	/* Send and error indication message to the MDL entity */

void dl_send_to_mdl_report (error_type, error_code)
	uchar				 error_type;		/* error type  */
	uchar 			 	 error_code;		/* errror code */
{
	uchar			FAR *p_data;			/* data pointer */
	struct message	FAR *p_msg;    			/* current snd message pointer */
	struct message	FAR *p_snd_msg_save;    /* save current snd message pointer */
	struct buffer	FAR *p_buff;			/* current bufer pointer */

		/* Build the event message and send it */

	p_msg 	= P_NIL;
	p_buff 	= P_NIL;

	Prepare_data_to_send (p_msg, p_buff, Mdl_error_size, p_data);

	if (p_data != P_NIL) {

			/* Load the data */

		Mdl_error_entity_origination	= ENT_DL;
		Mdl_error_report_type			= REPORT_TYPE_ERROR;

		Mdl_error_cause				 	= error_code;

		if (p_dlcep != P_NIL) {
			Mdl_error_dl_state			= State;
			Mdl_error_tei 				= Tei;
			Mdl_error_sapi				= Sapi;

		} else {

			Mdl_error_dl_state			= S_NIL;
			Mdl_error_tei 				= DL_TEI_NIL;
			Mdl_error_sapi				= DL_SAPI_NIL;
		}

		if (p_rcv_msg != P_NIL) {
			Mdl_error_event_from		= R_msg_from;
			Mdl_error_code				= R_msg_code;

				/* Event origination ? */

			switch (R_msg_from) {

					/* From the PH entities */

				case ENT_PH :
				case ENT_PH_D :
				case ENT_PH_B :

					if (R_msg_code == PH_DA_IN) {

							/* Load the error data from the received frame */

						Mdl_error_sapi			= Ru_sapi;
						Mdl_error_tei       	= Ru_tei;
						Mdl_error_chani			= Ru_chani;
						Mdl_error_cr			= Ru_cr;
						Mdl_error_format    	= Ru_format;
						Mdl_error_command		= Ru_command;
						Mdl_error_pf			= Ru_pf;
						Mdl_error_ns			= Ru_ns;
						Mdl_error_nr			= Ru_nr;

						if (p_dlcep != P_NIL) {
							Mdl_error_vs        = Vs;
							Mdl_error_vr        = Vr;
							Mdl_error_va        = Va;
						}

						Mdl_error_header_size   = Ru_header_size;
						Mdl_error_size_total	= Ru_size_total;

						if (error_type == REPORT_TYPE_ERROR) {

							if (R_data_size != 0) {

								Memcpy_far ((char FAR *)Mdl_error_a_data,
											(char FAR *)R_a_data,
											(int)DL_MX_FRAME_HEADER);
							}

						} else {
									/* FRMR frame */

							Mdl_error_report_type = REPORT_TYPE_STATUS;

								Memcpy_far ((char FAR *)Mdl_error_a_data,
											(char FAR *)R_a_data + Ru_header_size,
											(int)(Ru_size_up - Ru_header_size));
						}

					}

					break;


					/* From upper layers, MDL or TIMER */

				default :
					break;

			}

		} else {

			Mdl_error_event_from		= ENT_NIL;
		}

			/* Send the message to the MDL entity */

		p_snd_msg_save					= p_snd_msg;
		p_snd_msg						= p_msg;
		Send_to_mdl 					(MDL_ERR_IN);
		p_snd_msg 						= p_snd_msg_save;

	}

}

/*---------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name         		dl_send_to_mdl_info - builds and sends statistics
					information message to the MDL entity (MDL_INFO_CO).

Usage				void dl_send_to_mdl_info (void);

Description     	dl_snd implements the sending of a message generated by
					the DL entity.

Return value    	void

Common constants and declarations : dl.h

Common objects		current NA object

*---------------------------------------------------------------------------*/

#if DL_STATISTICS == ON

void dl_send_to_mdl_info ()
{
	uchar			FAR *p_data;			/* data pointer */
	struct buffer	FAR *p_buff;			/* current bufer pointer */

		/* Build the information message and send it */

	p_snd_msg 	= P_NIL;
	p_buff 		= P_NIL;

	Prepare_data_to_send (p_snd_msg, p_buff, Mdl_info_size, p_data);

	if (p_data != P_NIL) {

			/* Load the data */

		Mdl_info_entity_origination	= ENT_DL;
		Mdl_info_type				= INFO_TYPE_STATISTICS;

		if (dl_access_na (R_msg_nai) == OK) {
			Mdl_info_nb_tx_frame        = Na_nb_tx_frame;
			Mdl_info_nb_rx_frame        = Na_nb_rx_frame;
			Mdl_info_nb_t200_expiry     = Na_nb_t200_expiry;
			Mdl_info_nb_tx_i	       	= Na_nb_tx_i;
			Mdl_info_nb_rx_i   		    = Na_nb_rx_i;
			Mdl_info_nb_tx_reject       = Na_nb_tx_reject;
			Mdl_info_nb_rx_reject       = Na_nb_rx_reject;
			Mdl_info_nb_tx_rr	       	= Na_nb_tx_rr;
			Mdl_info_nb_rx_rr   	    = Na_nb_rx_rr;
			Mdl_info_nb_tx_rnr	       	= Na_nb_tx_rnr;
			Mdl_info_nb_rx_rnr   	    = Na_nb_rx_rnr;
		}

			/* Send the message */

		Send_to_mdl 				(MDL_INFO_CO);
	}

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name         		send_frame - implements the sending of a frame to the
					PHysical layer.

Usage           	void send_frame (uchar frame_id, uchar pf);
							- frame_id : frame ID,
							- pf       : P/F bit.

Related
functions usage 	void Send_message (struct message *p_msg);


Description     	send_frame implements the sending of a frame to the PHysical
					entity ENT_PH_D, ENT_PH or ENT_PH_B.

Return value    	void

Common constants and declarations : dl.h

Common objects		current message context, dlcep context.

*--------------------------------------------------------------------------*/

void send_frame (frame_id, pf)
	uchar 		frame_id;						/* frame ID */
	uchar 		pf;								/* poll final bit */
{
	struct		message FAR	*p_msg;				/* temporary pointer */

		/*
		   If the frame is not information frame (I, UI or XID)
		   ---> use only a message.
		*/

	switch (frame_id) {

			/* Frame with an information field */

		case FR_I 	:
		case FR_UI 	:
		case FR_XID_COMMAND  :
		case FR_XID_RESPONSE :

#		if DL_U_FRAME == ON
			case FR_SI_COMMAND :
#		endif

			break;

			/* Frame without information field */

		default :

			/*
			   Only a frame header ---> no linked buffer.
			   if a message is already allocated reuse it,
			   else allocate a new message.
			*/

			if (p_snd_msg == P_NIL){
				p_snd_msg = Alloc_msg ();		/* allocate a new message */

			} else {

					/* Reuse the message but free its linked buffer */

				Free_buffer (S_msg_p_buffer);

					/* init p_buffer to P_NIL and liberation flag to ON */

				S_msg_lib 		= ON;			/* liberation flag = ON */
				S_msg_p_buffer 	= P_NIL;		/* no buffer */
			}

			break;

	}

		/* Switch according to the frame ID */

	switch (frame_id) {

			/* Frame with an information field ? */

		case FR_I 	:
		case FR_UI 	:
		case FR_XID_COMMAND  :
		case FR_XID_RESPONSE :

#		if DL_U_FRAME == ON
			case FR_SI_COMMAND :
#		endif

			Inc_stat_counter (Na_nb_tx_i);

				/*
				   Reuse the received message which may contain
				   a pointer on the data buffer.
				*/


			if ((p_msg = p_rcv_msg) == P_NIL) {
				Trap (TRAP_SND_I_FRAME, "send_frame");
			}

			p_rcv_msg	= p_snd_msg;	  	/* exchange the contents of
											   p_snd_msg and p_rcv_msg */
			p_snd_msg 	= p_msg;

			if (frame_id == FR_I) {

					/* Reset the liberation flag and PH queue mark */

				S_msg_lib 	= OFF;			/* liberation flag = OFF ==> no release to be done */
				Msg_set_in_ph_fifo_mark (p_snd_msg);

					/* Init unpacked frame structure */

				Su_cr		= Cr_snd_command;
				Su_ns 		= Vs;			/* N(S) */
				Su_nr 		= Vr;			/* N(R) */
				Su_format 	= I;        	/* format */
				Su_p 		= pf;			/* poll bit */

			} else {

					/* Set liberation flag to ON */

				S_msg_lib 	= ON;			/* liberation flag = ON */

					/*
						Load the Send Unpack structure according
						to the frame Id.
					*/

				switch (frame_id) {

						/* XID command */

					case FR_XID_COMMAND :
						set_u_frame (Cr_snd_command, XID, pf);
						break;

						/* XID response */

					case FR_XID_RESPONSE :
						set_u_frame (Cr_snd_response, XID, pf);
						break;

						/* Unnumbered Information */

					 case FR_UI :
						set_u_frame (Cr_snd_command, UI, pf);
						break;

#					if DL_U_FRAME == ON

						case FR_SI_COMMAND :
							S_msg_lib 	= OFF;			/* liberation flag = OFF ==> no release to be done */
							Msg_set_in_ph_fifo_mark (p_snd_msg);

							if (Vs == 0) {
								set_u_frame (Cr_snd_command, SI0, pf);

							} else {

								set_u_frame (Cr_snd_command, SI1, pf);
							}
							break;
#					endif

				}

			}
			break;

			/* Receiver Ready / Response */

		case FR_RR_RESPONSE :
			Inc_stat_counter (Na_nb_tx_rr);
			set_s_frame (Cr_snd_response, RR, pf);
			break;

			/* Receiver Ready / Response */

		case FR_RR_COMMAND :
			Inc_stat_counter (Na_nb_tx_rr);
			set_s_frame (Cr_snd_command, RR, pf);
			break;

			/* Receiver Not Ready / Response */

		case FR_RNR_RESPONSE :
			Inc_stat_counter (Na_nb_tx_rnr);
			set_s_frame (Cr_snd_response, RNR, pf);
			break;

			/* Receiver Not Ready / Command */

		case FR_RNR_COMMAND :
			Inc_stat_counter (Na_nb_tx_rnr);
			set_s_frame (Cr_snd_command, RNR, pf);
			break;

			/* Reject */

		case FR_REJ_COMMAND :
		case FR_REJ :
			Inc_stat_counter (Na_nb_tx_reject);
			set_s_frame (Cr_snd_command, REJ, pf);
			break;

		case FR_REJ_RESPONSE :
			Inc_stat_counter (Na_nb_tx_reject);
			set_s_frame (Cr_snd_response, REJ, pf);
			break;

			/* Set Asynchronous Balanced Mode extended */

		case FR_SABME :
			set_u_frame (Cr_snd_command, SABME, pf);
			break;

			/* Set Asynchronous Balanced Mode */

		case FR_SABM :
			set_u_frame (Cr_snd_command, SABM, pf);
			break;

			/* Disconnected Mode */

		case FR_DM :
			set_u_frame	(Cr_snd_response, DM, pf);
			break;

			/* Disconnect */

		case FR_DISC :
			set_u_frame (Cr_snd_command, DISC, pf);
			break;

			/* Unnumbered Acknowledged */

		case FR_UA :
			set_u_frame (Cr_snd_response, UA, pf);
			break;

			/* FRaMe Reject */

		case FR_FRMR :
			set_u_frame (Cr_snd_response, FRMR, pf);

				/* Save P/F for retransmission */

			Frmr_pf = pf;
			break;

#		if DL_U_FRAME == ON

			case FR_SI_COMMAND_EMPTY :

				if (Vs == 0) {
					set_u_frame (Cr_snd_command, SI0, pf);

				} else {

					set_u_frame (Cr_snd_command, SI1, pf);
				}
				break;

			case FR_SI_RESPONSE :

				if (Vr == 0) {
					set_u_frame (Cr_snd_response, SI0, pf);

				} else {

					set_u_frame (Cr_snd_response, SI1, pf);
				}
				break;
#		endif


		default :
			Trap (TRAP_DL_SEND_FRAME, "send_frame");

	}

		/*
		   Pack the frame header according to the protocol (8 or 128)
		   and to the modulo (8 or 128).

		   Send the message to the PHysical entity (PHysical D or
		   PHysical B) according to the channel ID.
		*/

	switch (Dl_entity_id) {

#		if (DL_LAPD == ON)

				/* LAPD protocol */

			case ENT_DL_D 	:

					/* Address field */

				Su_sapi = Sapi;					/* Service Access Point ID */
				Su_tei  = Tei;					/* Terminal Endpoint ID */

				if (Modulo == MODULO_EXTENDED) {

#					if DL_MODULO_128 == ON
						p_d_128 ();				/* LAPD - modulo 128 */

#					else

						Trap (TRAP_MODULO_DISABLE, "send_frame");
#					endif

				} else {

#					if DL_MODULO_8 == ON
						p_d_8 ();				/* LAPD - modulo 8 */

#					else

						Trap (TRAP_MODULO_DISABLE, "send_frame");
#					endif

				}

				break;

#		endif

#		if DL_LAPB == ON

				/* LAPB protocol */

			case ENT_DL_B :

#				if DL_ISDN_BIOS == ON

					if ((Isdn_bios 		== ON) 		&&
						(frame_id 		== FR_I) 	&&
						(S_msg_priority == ON)) {
						Su_sapi = DL_SAPI_ISDN_BIOS;

					} else {

						Su_sapi = DL_SAPI_LAPB;
					}

#				else

					Su_sapi = DL_SAPI_LAPB;
#				endif

				if (Modulo == MODULO_EXTENDED) {

#					if DL_MODULO_128 == ON
						p_b_128 ();				/* LAPB - modulo 128 */

#					else

						Trap (TRAP_MODULO_DISABLE, "send_frame");
#					endif

				} else {

#					if DL_MODULO_8 == ON
						p_b_8 ();				/* LAPB - modulo 8 */

#					else

						Trap (TRAP_MODULO_DISABLE, "send_frame");
#					endif

				}
				break;

#		endif

				/* V.120, LAPF and LAP4K protocols */

#		if DL_V120 == ON
			case ENT_DL_V120 :
#		endif

#		if DL_LAP4K == ON
			case ENT_DL_4K   :
#		endif

#				if (DL_V120 == ON) || (DL_LAP4K == ON)

						/* Address field */

					Su_sapi = Sapi_from_dcli (Dlci);/* Service Access Point ID */
					Su_tei  = Tei_from_dcli  (Dlci);/* Terminal Endpoint ID */

					if (Modulo == MODULO_EXTENDED) {

#						if DL_MODULO_128 == ON
							p_d_128 ();				/* V.120/LAP4K - modulo 128 */

#						else

							Trap (TRAP_MODULO_DISABLE, "send_frame");
#						endif

					} else {

#						if DL_MODULO_8 == ON
							p_d_8 ();				/* V.120/LAP4K - modulo 8 */

#						else

							Trap (TRAP_MODULO_DISABLE, "send_frame");
#						endif

					}

					break;

#				endif

#		if DL_LAPF == ON

			case ENT_DL_F :							/* LAPF */

				Su_de	= Lapf_de;
				Su_dc	= Lapf_dc;
				Su_dlci = Dlci;
				Su_fecn =
				Su_becn = 0;

				switch (Lapf_add_ff) {

#					if DL_LAPF_ADD_FF_2 == ON

						case 2 :
							p_f_2 ();
							break;

#					endif

#					if DL_LAPF_ADD_FF_3 == ON

						case 3 :
							p_f_3 ();
							break;

#					endif

#					if DL_LAPF_ADD_FF_4 == ON

						case 4 :
							p_f_4 ();
							break;

#					endif

				}

				break;

#		endif


		default :
			Trap (TRAP_UNKNOWN_ENTITY, "send_frame");

	}

#	if DL_SIM_ANALYSER == ON
		pr_frame ('O');
#	endif

		/* Send to PH entity */

	Send_to_ph (PH_DA_RQ);

		/* Increment frame TX counter */

	Inc_stat_counter (Na_nb_tx_frame);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

nName          set_s_frame - set_u_frame implements the loading of the
			  Send Unpack	structure (SU) for a S/U frame header.

Usage         void set_s_frame (uchar cr, uchar command_val, uchar pf_val);
			  void set_u_frame (uchar cr, uchar command_val, uchar pf_val);
					- cr			: frame ID,
					- command_val 	: control field,
					- pf_val    	: P/F bit.


Common constants and declarations : dl.h

Common objects		current SU data structure.

*--------------------------------------------------------------------------*/

	/* Load the frame header of a supervisory type frame */

void set_s_frame (cr_val, command_val, pf_val)
	uchar 	cr_val;						/* frame command or response field */
	uchar 	command_val;				/* frame commande field */
	uchar 	pf_val;						/* frame poll final bit field */
{
	Su_cr 		= cr_val;				/* C/R */
	Su_format 	= S;        	    	/* Supervisory */
	Su_pf 		= pf_val;				/* P/F */
	Su_command 	= command_val;  		/* frame command */
	Su_nr 		= Vr;					/* V(R) */
}

/*-------------------------------------------------------------------------*/

	/* Load the frame header of an Unnumbered type frame */

void set_u_frame (cr_val, command_val, pf_val)
	uchar	cr_val;						/* command or response */
	uchar 	command_val;				/* frame command field */
	uchar 	pf_val;						/* frame poll final bit field */
{
	Su_cr		= cr_val;
	Su_format 	= U;					/* Unnumbered */
	Su_pf 		= pf_val;				/* P/F */
	Su_command 	= command_val;			/* frame command */
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			dl_retransmit - implements the retransmission of a
				received message.

Usage           void dl_retransmit (code_t code, ent_id_t to);
					- code : new primitive code,
					- to   : destination entity.

Related
functions usage void Send_message (struct message FAR p_msg);

Common constants and declarations : services.h

Common objects : server context.

*--------------------------------------------------------------------------*/

void dl_retransmit (code, to)
	code_t		code;					/* primitive code */
	ent_id_t	to;						/* entity Id */
{
	R_msg_code	= code;

	R_msg_to	= to;
	R_msg_from	= ENT_DL;

	Send_message (p_rcv_msg); p_rcv_msg = P_NIL;
}

/*EOF*/
