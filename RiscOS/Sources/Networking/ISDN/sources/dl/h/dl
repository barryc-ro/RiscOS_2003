
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - dl.h
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the commmon declarations of the DL functions.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    LAP-BRICKS                                       |*/
/*|    ISDN-BRICKS                                      |*/
/*|    X25-BRICKS                                       |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef DL_H /* { */
#define DL_H

#	include "services.h" 				/* OMNITEL-BRICKS services header */
#	include "dl_int.h"					/* DL upper interface */
#	include "ph_int.h"					/* PH upper interface */

#	if DL_V120 == ON
#		include "v120_int.h"			/* V120 upper interface */
#	endif

/*-------------------------------------------------------------------------*/

	/* Message audit Macro */

#ifndef Msg_audit_in

		/* Now defined in serv_por.h, but needed to keep compatibility */

#	if MESSAGE_AUDIT == ON /* { */

#		if ASSERT == ON

#			define Msg_audit_in(direction, p_msg)		\
				if (performance == OFF) { 				\
					msg_audit_in (direction, p_msg); 	\
				} 										\
				Msg_capture  (direction, p_msg)
#		else

#			define Msg_audit_in(direction, p_msg)		\
				msg_audit_in (direction, p_msg); 		\
				Msg_capture  (direction, p_msg)
#		endif

#	else /* } { */

#		define Msg_audit_in(direction, p_msg)			\
				Msg_capture  (direction, p_msg)
#	endif /* } */

#endif

/*-------------------------------------------------------------------------*/

		/* OPTIONAL PARAMETERS (for compatibility between releases */

#ifndef DL_LAPD
#	define DL_LAPD						OFF			/* enable or disable LAPD (code generation) */
#endif

#ifndef DL_LAPX
#	define DL_LAPX						OFF			/* enable or disable LAPX (code generation) */
#endif

#ifndef DL_LAPB
#	define DL_LAPB						OFF			/* enable or disable LAPB (code generation) */
#endif

#ifndef DL_ISDN_BIOS
#	define DL_ISDN_BIOS					OFF			/* DL with ISDN-BIOS facilities : ON or OFF */
#endif

#ifndef	DL_MODULO_128
#	define DL_MODULO_128				OFF			/* disable modulo 128 frame sequencing (code generation) */
#endif

#ifndef DL_MODULO_8
#	define DL_MODULO_8					OFF			/* disable modulo 8 frame sequencing (code generation) */
#endif

#ifndef DL_V120
#	define DL_V120						OFF			/* disable V.120 LAP */
#endif

#ifndef DL_LAP4K
#	define DL_LAP4K						OFF			/* disable LA4K */
#endif

#ifndef DL_LAPF
#	define DL_LAPF						OFF			/* disable LAPF */
#endif

#ifndef DL_U_FRAME
#	define DL_U_FRAME					OFF			/* disable U frame mode (I.441 RED BOOK) */
#endif

#ifndef DL_T200_ENQUIRY
#	define DL_T200_ENQUIRY				OFF			/* option enquiry (RR) (ON) or I frame (OFF) after timer T200 expiry */
#endif

#ifndef DL_INVALID_SZ_CHK_DELAYED
#	define DL_INVALID_SZ_CHK_DELAYED	ON			/* Check of invalid size frame delayed */
#endif

#ifndef DL_IDENTIFICATION
#	define DL_IDENTIFICATION			OFF			/* Identification procedure (X32) */
#endif

#ifndef DL_FC
#	define DL_FC						OFF         /* Flow control */
#endif

#ifndef	DL_EXTRA_ERROR_REPORTING
#	define	DL_EXTRA_ERROR_REPORTING  	OFF			/* Supplementary error reporting */
#endif

#ifndef DL_T203
#	define DL_T203						OFF			/* Timer T203 ON or OFF */
#endif

#ifndef T203_ATT_NI_I
#	ifdef T203_ATT_I
#		define T203_ATT_NI_I			T203_ATT_I
#	else
#		define T203_ATT_NI_I			30*SECOND	/* DL watch dog timer value for AT&T and National-ISDN */
#	endif
#endif

#ifndef DL_PH_TX_DONE
#	define DL_PH_TX_DONE				OFF			/* PH_TX_DONE_IN Transmit done received from PH : shall be set to OFF */
#endif

#ifndef DL_ID_VERIFY
#	define DL_ID_VERIFY					OFF			/* IDentity verify requested by the user or not */
#endif

#ifndef DL_REMOVE_TEI_ON_RETRY
#	define DL_REMOVE_TEI_ON_RETRY 		ON			/* Remove TEI or ID verify on unsuccessful retry (usefull for ETSI) */
#endif

#ifndef DL_PH_MUX
#	define DL_PH_MUX					OFF			/* Physical access multiplex : ON or OFF */
#endif

#ifndef K_I_PRI_SIG
#	define K_I_PRI_SIG					7			/* primary rate implicit window size for signalling */
#endif

#ifndef	K_I_PRI_PCK
#	define K_I_PRI_PCK					7			/* primary rate implicit window size for packet */
#endif

#ifndef K_I_BRI_SIG
#	define K_I_BRI_SIG					1			/* basic rate implicit window size for signalling */
#endif

#ifndef	K_I_BRI_PCK
#	define K_I_BRI_PCK					3			/* basic rate packet sapi window size */
#endif

#ifndef	K_I_SCI
#	define K_I_SCI						7			/* single channel interface */
#endif

#ifndef DL_RELAY
#	define DL_RELAY						OFF			/* DL relay option */
#endif

#ifndef DL_MLP
#	define DL_MLP						OFF			/* Multi Link Protocol option */
#endif

#ifndef DL_LAPF_ADD_FF_2
#	define DL_LAPF_ADD_FF_2				ON			/* LAPF address field format 2 octets */
#endif

#ifndef DL_LAPF_ADD_FF_3
#	define DL_LAPF_ADD_FF_3				OFF			/* LAPF address field format 3 octets */
#endif

#ifndef DL_LAPF_ADD_FF_4
#	define DL_LAPF_ADD_FF_4				OFF			/* LAPF address field format 4 octets */
#endif

#ifndef DL_PRI_MULTI_D
#	define DL_PRI_MULTI_D				OFF			/* multi D-channel PRI access with one DL connexion per D-channel */
#endif

#if DL_V120 == ON
#	undef  DL_LAPD
#	define DL_LAPD						ON			/* If V120 --> DL LAPD = ON */
#endif

#ifndef DL_V120_XID_NEGOTIATION
#	define DL_V120_XID_NEGOTIATION		ON			/* DL V.120 XID negotiation ON */
#endif

/*-------------------------------------------------------------------------*/

#define ENT_MLP					1					/* Pseudo MLP entity */
#define MLP_ACK_LIST_SIZE		8					/* maximum number of element in the MLP ack list */
#define MLP_SLP_I_NIL			(~0)				/* NIL MLP SLP index */

/*-------------------------------------------------------------------------*/

						/* DL GENERAL COMMON VARIABLES */

#if DL_SIM_BUILDER  == OFF

#	if ENTITY == MDL
#		define	event_id		event_id_mdl		/* event identifier */
#		define	ret_code		ret_code_mdl		/* return code */
#		define 	p_snd_msg		p_snd_msg_mdl		/* pointer on the current message to send if any */
#		define 	p_rcv_msg		p_rcv_msg_mdl		/* pointer on the current received message if any */
#		define 	p_buffer		p_buffer_mdl		/* pointer on the curent buffer if any */
#		define 	p_buffer_end	p_buffer_end_mdl	/* pointers on the end of the current buffer if any */
#		define 	os_err			os_err_mdl			/* OS error code */
#	else
#		define	event_id		event_id_dl			/* event identifier */
#		define	ret_code		ret_code_dl			/* return code */
#		define 	p_snd_msg		p_snd_msg_dl		/* pointer on the current message to send if any */
#		define 	p_rcv_msg		p_rcv_msg_dl		/* pointer on the current received message if any */
#		define 	p_buffer		p_buffer_dl			/* pointer on the curent buffer if any */
#		define 	p_buffer_end	p_buffer_end_dl		/* pointers on the end of the current buffer if any */
#		define 	os_err			os_err_dl			/* OS error code */
#	endif

#endif

/*--------------------------------------------------------------------------

								LAP MANAGEMENT

---------------------------------------------------------------------------*/

						/* DATA LINK MACRO'S */

#define Set_state(xx) 		State = (xx)							/* set current cep state */

#define Inc_v_modulo(xx) 	if(++(xx) == Modulo)          (xx) = 0 	/* increment variable */

#define Inc_v_128(xx) 		if(++(xx) == MODULO_EXTENDED) (xx) = 0 	/* increment variable modulo 128*/

#define Inc_v_8(xx) 		if(++(xx) == MODULO_BASIC)    (xx) = 0 	/* increment variable modulo 128*/

#define Dec_v_modulo(xx) 	((xx) == 0 ? (xx) = Modulo - 1 : --(xx))/* decrement variable */

#define Valid_nr() 			( (Va <= Vs) ? (Va <= Ru_nr) && (Ru_nr <= Vs) : (Va <= Ru_nr) || (Ru_nr <= Vs) )

#define Send_to_l3(code) 	dl_snd (ENT_L3,		code)				/* send a message to layer 3 entity */
#define Send_to_mdl(code)	dl_snd (ENT_MDL,	code)				/* send a message to MDL entity */
#define Send_to_dl(code)	dl_snd (ENT_DL,		code)				/* send a message to DL entity */
#define Send_to_ph_d(code)	dl_snd (ENT_PH_D,	code)				/* send a message to the physical D channel entity */
#define Send_to_mph(code)	dl_snd (ENT_MPH,	code)				/* send a message to the physical management */

#define Send_to_ph(code) 	dl_snd (Chan_ph_entity_id, code)		/* send a message to the physical entity */

#define Send_clear_to_ph()	Send_to_ph (PH_CLEAR_RQ)

#define Signal_WAIT_ACK		dl_snd (Dl_entity_id,		WAIT_ACK)			/* internal signal : send a message to DL entity */

#define Signal_QU_I
#define Signal_QU_UI

/*--------------------------------------------------------------------------*/

			/* DATA LINK : CODE STATES OF THE GENERAL AUTOMATA */

#define S_NIL						'0'		/* NIL state */
#define S_TEI_UNASSIGNED			'1'		/* TEI unassigned */
#define S_ASSIGN_AWAITING_TEI		'2' 	/* assign awaiting TEI */
#define S_ESTABLISH_AWAITING_TEI  	'3' 	/* establish awaiting TEI */
#define S_TEI_ASSIGNED				'4'		/* TEI assigned */
#define S_AWAITING_ESTABLISHMENT	'5'		/* awaiting establishment of operation */
#define S_AWAITING_RELEASE			'6'		/* awaiting release */
#define S_MFO						'7'		/* multiple frame operation */
#define S_TIMER_RECOVERY			'8'		/* timer recovery */
#define S_FRAME_REJECT				'9'		/* Frame reject condition FRMR */

#define S_AWAITING_PH_CONNECTION	'A'		/* LAPB : awaiting PH connection */

/*--------------------------------------------------------------------------*/

			/* DATA LINK : CODE STATES OF THE SFO GENERAL AUTOMATA */

#define S_U_ESTABLISH_AWAITING_TEI  'a' 	/* establish awaiting TEI */
#define S_U_AWAITING_ESTABLISHMENT	'b'		/* awaiting establishment of operation */
#define S_U_SFO						'c'		/* single frame operation */

/*--------------------------------------------------------------------------*/

			/* DATA LINK HDTM (LAPX) : CODE STATES OF THE AUTOMATA */

#define DLX_IDLE_0                  '0'		/* DLX idle state */
#define DLX_TX_1                  	'1'		/* Half duplex sending state */
#define DLX_WAIT_RX_2 	        	'2'		/* Wait for receiving state */
#define DLX_RX_3                   	'3'		/* Half duplex receiving state */
#define DLX_WAIT_TX_4              	'4'		/* Wait for sending state */

/*--------------------------------------------------------------------------*/

		/* PHYSICAL ACCESS STATE AS VIEW BY DATA LINK LAPD ENTITY */

#define S_PH_INFO_TX_NOT_AVAILABLE	'1'		/* information transfer not available */
#define S_PH_ACTIVATION_REQUESTED	'2'		/* activation requested */
#define S_PH_INFO_TX_AVAILABLE		'3'		/* information transfer available */
#define	S_PH_ID_AWAITING_ATTACH 	'5'		/* awaiting attachment (SAPI, CES) */
#define	S_PH_ID_AWAITING_CO 		'6'		/* awaiting XID confirm frame */
#define	S_PH_ID_AWAITING_RS 		'7'		/* awaiting XID response frame */

/*-------------------------------------------------------------------------*/

						/* TRAP MANAGEMENT */

			/*
			   TRAP code : trap function is called if and inconsistancy
						   is detected inside the sofware, generally due
						   to a bug. Trap function must freeze the
						   situation and dump it to some permanent support
						   in order to fix the bug.
			*/

#define TRAP_DL_STATE				201		/* inconsistent state in the global state machine */
#define TRAP_MODULO_DISABLE			202		/* no code for the modulo */
#define TRAP_DL_INIT				203		/* error in initialization of DL */
#define TRAP_DL_SEND				204		/* unknow destination entity in dl_send function */
#define TRAP_DL_RECEIVE				205		/* invalid message received by DL entity */
#define TRAP_DL_SEND_FRAME			206		/* unknown frame */
#define TRAP_SENT_QUEUE				207		/* erroneous sent queue */
#define TRAP_DL_MSG_ADD				208		/* abnormal message address */
#define TRAP_FRAME_TOO_LONG			209		/* frame to send too long */
#define TRAP_FRAME_SIZE				210		/* frame longer than the buffer data area */
#define TRAP_LAPD_ONLY				211		/* State LAPD only */
#define TRAP_SND_I_FRAME			212		/* */
#define TRAP_MDL_ACCESS				213		/* unknown CES */
#define TRAP_DL_BUFFER_CHAIN		214		/* abnormal buffers chain */
#define TRAP_DL_QUEUE_CHECK			215		/* check queue */
#define TRAP_MLP_ACK_CO_LIST		216		/* MLP list too short */

/*-------------------------------------------------------------------------*/

						/* TEI MANAGEMENT */

			/* Messages used for the TEI assignment procedure */

struct tap {
	uchar	  		  mei;			/* management entity identifier */
	uchar 	   		  ri_1;			/* reference number part 1 */
	uchar 	   		  ri_2;			/* reference number part 2 */
	uchar 	          type;			/* message type */
	uchar     		  ai_1;			/* action indicator field octet */
};

#define	I_tap_size			5		/* size of the tap structure */

			/* Access to TEI assignment data structure using p_tap pointer */

#define I_tap_type 			((struct tap FAR *)p_tap) -> type  	/* message type */
#define I_tap_ai_1			((struct tap FAR *)p_tap) -> ai_1  	/* action indicator field octet */
#define I_tap_ri_1			((struct tap FAR *)p_tap) -> ri_1	/* reference number */
#define I_tap_ri_2			((struct tap FAR *)p_tap) -> ri_2	/* reference number */
#define I_tap_mei			((struct tap FAR *)p_tap) -> mei	/* management entity identifier */

#define I_tap_ri_load(val)	I_tap_ri_1 = (val); I_tap_ri_2 = ((val) >> 8)	/* store the reference number */
#define I_tap_ri			((I_tap_ri_2 << 8) + I_tap_ri_1)

#define I_tap_ai_load(ai) 	I_tap_ai_1 = ((ai) << 1) + EA_FINAL
#define I_tap_ai			(I_tap_ai_1 >> 1)
#define I_tap_ai_ext		(I_tap_ai_1 & 0x1)

				/* Codes */

#define TAP_ID_RQ			1		/* identity request (user to network) */
#define TAP_ID_ASS			2		/* identity assigned (network to user) */
#define TAP_ID_DENIED		3		/* identity denied (network to user) */
#define TAP_ID_CHK_RQ		4		/* identity check request (network to user) */
#define TAP_ID_CHK_RS		5		/* identity check response (user to network) */
#define TAP_ID_RM			6		/* identity remove (network to user ) */
#define TAP_ID_VERIFY		7		/* identity verify */
#define TAP_NIL				255		/* NIL */

#define TAP_MEI				15		/* management entity identifier */

#define TAP_ANY_TEI			127		/* any tei acceptable */
#define TAP_ALL_TEI			127		/* all TEI */
#define TAP_ALL_AUTOMATIC_TEI	254	/* all automatic TEI */

				/* Number of Identity remove message to send in sucession */

#define MX_ID_REMOTE_RM		2

				/* Maximum number of retry for an Identity verify message */

#define MX_VERIFY			2


#define RI_NIL		 		100000L /* RI null value : out of normal range */

/*------------------------------------------------------------------------*/

#if DL_LAP4K == ON /* { */

			/* Messages used for the DLCI assignment procedure */

struct tap_lap4k {
	uchar	  		  mei;			/* management entity identifier */
	uchar 	          type;			/* message type */
	uchar     		  dlci_1;		/* dlci 1 */
	uchar     		  dlci_2;		/* dlci 2 */
};

#define	I_tap_lap4k_size		4	/* size of the tap structure */

			/* Access to TEI assignment data structure using p_tap pointer */

#define I_tap_lap4k_type 			((struct tap_lap4k FAR *)p_tap_lap4k) -> type  		/* message type */
#define I_tap_lap4k_dlci_1			((struct tap_lap4k FAR *)p_tap_lap4k) -> dlci_1  	/* DLCI 1 */
#define I_tap_lap4k_dlci_2			((struct tap_lap4k FAR *)p_tap_lap4k) -> dlci_2		/* DLCI 2 */
#define I_tap_lap4k_mei				((struct tap_lap4k FAR *)p_tap_lap4k) -> mei		/* management entity identifier */

#define I_tap_lap4k_dlci_load(dlci) I_tap_lap4k_dlci_1 = (((dlci) >> 7) & Mask (6));	\
									I_tap_lap4k_dlci_2 = ((dlci) & Mask (7))

#define I_tap_lap4k_dlci			((I_tap_lap4k_dlci_1 << 7) + I_tap_lap4k_dlci_2)

				/* Codes */

#define TAP_LAP4K_ID_RQ			1		/* LAP4K identity request */
#define TAP_LAP4K_ID_RQ_OK		2		/* LAP4K identity request accepted */
#define TAP_LAP4K_ID_RQ_NOK		3		/* LAP4K identity request rejected */
#define TAP_LAP4K_ID_RM			4		/* LAP4K identity remove */
#define TAP_LAP4K_NIL			255		/* LAP4K NIL */

#define TAP_LAP4K_MEI			15		/* management entity identifier */

#endif /* } */

/*-------------------------------------------------------------------------*/

						/* FRAME MANAGEMENT */

			/* Frame structure for peer to peer communication */

					/* Address field */

/*					LAPD

	  8    7    6    5    4    3    2    1      octet
	-----------------------------------------
	|         S A P I             |C/R| EA 0|    2
	|---------------------------------|-----|
	|            T E I                | EA 1|    3
	-----------------------------------------	*/

/*					V.120

	  8    7    6    5    4    3    2    1      octet
	-----------------------------------------
	| upper   D L C I             |C/R| EA 0|    2
	|---------------------------------|-----|
	| lower   D L C I                 | EA 1|    3
	-----------------------------------------	*/

/*					LAPF

	  8    7    6    5    4    3    2    1      octet
	-----------------------------------------
	|  upper  D L C I             |C/R| EA 0|    2
	|---------------------------------|-----|
	|         D L C I   |FECN|BECN| DE| EA 0|    3
	-----------------------------------------
	|         D L C I                 | EA 0|    4
	-----------------------------------------
	|  lower  D L C I             |D/C| EA 1|    5
	-----------------------------------------	*/

struct address {
	uchar		octet_1;
	uchar		octet_2;
	uchar		octet_3;
	uchar		octet_4;
};

#if (ENTITY == DL_D) || (ENTITY == MDL)
#	define Fr_address uchar dl_add1;uchar dl_add2
#	define Fr_address_size	2
#endif

#if (ENTITY == DL_F)
#	if LAPF_ADD_FF == 2
#		define Fr_address uchar dl_add1;uchar dl_add2
#		define Fr_address_size	2
#	endif

#	if LAPF_ADD_FF == 3
#		define Fr_address uchar dl_add1;uchar dl_add2;uchar dl_add3
#		define Fr_address_size	3
#	endif

#	if LAPF_ADD_FF == 4
#		define Fr_address uchar dl_add1;uchar dl_add2;uchar dl_add3;uchar dl_add4
#		define Fr_address_size	4
#	endif
#endif

#ifndef Fr_address		/* other cases: */
#	define Fr_address uchar dl_add1
#	define Fr_address_size	1
#endif

#define ADDRESS_B_SIZE_LOW	1	/* lower size of a LAPB address field */
#define ADDRESS_D_SIZE_LOW	2	/* lower size of a LAPD address field */

				/* Access to a received frame using p_rcv_frame pointer */

#define R_octet_1 			p_rcv_frame -> address.octet_1
#define R_octet_2			p_rcv_frame -> address.octet_2
#define R_octet_3			p_rcv_frame -> address.octet_3
#define R_octet_4			p_rcv_frame -> address.octet_4

#define R_ea1				(Get_bits (R_octet_1, 0, 1))
#define R_cr 				(Get_bits (R_octet_1, 1, 1))
#define R_sapi 				(Get_bits (R_octet_1, 2, 6))

#define R_ea2				(Get_bits (R_octet_2, 0, 1))
#define R_tei 				(Get_bits (R_octet_2, 1, 7))

#define R_ea3				(Get_bits (R_octet_3, 0, 1))
#define R_ea4				(Get_bits (R_octet_4, 0, 1))

#	if (DL_V120 == ON) || (DL_LAP4K == ON)
#		define R_dlci  		(((Get_bits (R_octet_1, 2, 6)) << 7) | (Get_bits (R_octet_2, 1, 7)))
#	endif

#define R_dlci_f2			(((Get_bits (R_octet_1, 2, 6)) << 4) | (Get_bits (R_octet_2, 4, 4)))

#define R_dlci_f3			(((Get_bits (R_octet_3, 1, 1)) == 1) ?																			 									\
								(((Get_bits (R_octet_1, 2, 6)) << 4)  |  (Get_bits (R_octet_2, 4, 4))) :                                    									\
								(((Get_bits (R_octet_1, 2, 6)) << 10) | ((Get_bits (R_octet_2, 4, 4)) << 6) | (Get_bits (R_octet_3, 6, 2)))										\
							)

#define R_dlci_f4			(((Get_bits (R_octet_4, 1, 1)) == 1) ?																												\
								(((Get_bits (R_octet_1, 2, 6)) << 11) | (Get_bits (R_octet_2, 4, 4) << 7)  | (Get_bits (R_octet_3, 7, 2))) :   									\
								(((Get_bits (R_octet_1, 2, 6)) << 16) | (Get_bits (R_octet_2, 4, 4) << 12) | (Get_bits (R_octet_3, 6, 2) << 6) | (Get_bits (R_octet_4, 6, 2)))	\
							)

#if DL_LAPF == ON
#	if LAPF_ADD_FF == 2
#		define R_dlci_f		R_dlci_f2
#	endif
#	if LAPF_ADD_FF == 3
#		define R_dlci_f		R_dlci_f3
#	endif
#	if LAPF_ADD_FF == 4
#		define R_dlci_f		R_dlci_f4
#	endif
#endif

				/* Access to a sending frame using p_snd_frame */

#define S_octet_1 			p_snd_frame -> address.octet_1
#define S_octet_2			p_snd_frame -> address.octet_2
#define S_octet_3			p_snd_frame -> address.octet_3
#define S_octet_4			p_snd_frame -> address.octet_4

#define S_ea1				(Get_bits (S_octet_1, 0, 1))
#define S_cr 				(Get_bits (S_octet_1, 1, 1))
#define S_sapi 				(Get_bits (S_octet_1, 2, 6))

#define S_ea2				(Get_bits (S_octet_2, 0, 1))
#define S_tei 				(Get_bits (S_octet_2, 1, 7))

#if ENTITY != DL_F

#	if (DL_V120 == ON) || (DL_LAP4K == ON)
#		define Sapi_from_dcli(dlci) ((dlci >> 7) & Mask (6))
#		define Tei_from_dcli(dlci)	 (dlci & Mask (7))
#	endif

#endif

#define S_address_load_ea1(ea1) \
							S_octet_1 = ((S_octet_1) & 0xfe) | (ea1)

#define S_address_load_ea2(ea2) \
							S_octet_2 = ((S_octet_2) & 0xfe) | (ea2)

#define S_address_load_ea3(ea3) \
							S_octet_3 = ((S_octet_3) & 0xfe) | (ea3)

#define S_address_load_ea4(ea4) \
							S_octet_4 = ((S_octet_4) & 0xfe) | (ea4)

#if ENTITY == DL_D

#	define S_address_load(sapi, tei, cr) 											\
							S_octet_1 = ((((sapi) << 1) | (cr)) << 1) | EA_CONTINUE;\
							S_octet_2 = ((tei) << 1) | EA_FINAL

#endif

#if ENTITY == DL_F /* { */

#	if DL_LAPF == ON /* { */

#		if LAPF_ADD_FF == 2

#			define S_address_load(dlci, cr, fecn, becn, de, dc) 													 		\
							S_octet_1 = ((((dlci >> 4) << 1) | (cr)) << 1) 							| EA_CONTINUE;			\
							S_octet_2 = ((dlci) << 4) | (fecn << 3) | (becn << 2) | (de << 1) 		| EA_FINAL

#		endif

#		if LAPF_ADD_FF == 3

#			define S_address_load(dlci, cr, fecn, becn, de, dc) 																\
							if (dc == 0) {                                                                              	\
								S_octet_1 = ((((dlci >> 10) << 1) | (cr)) << 1) 							| EA_CONTINUE;	\
								S_octet_2 =   ((dlci >> 6 ) << 1) | (fecn << 3) | (becn << 2) | (de << 1) 	| EA_CONTINUE;	\
								S_octet_3 =   ((dlci	  )	<< 2) 											| EA_FINAL;		\
							} else {                                                                                    	\
								S_octet_1 = ((((dlci >> 4) << 1)  | (cr)) << 1) 							| EA_CONTINUE;	\
								S_octet_2 =   ((dlci     ) << 1)  | (fecn << 3) | (becn << 2) | (de << 1)	| EA_CONTINUE;	\
								S_octet_3 = (1 << 1)														| EA_FINAL;		\
							}

#		endif

#		if LAPF_ADD_FF == 4

#			define S_address_load(dlci, cr, fecn, becn, de, dc) 																\
							if (dc == 0) {                                                                              	\
								S_octet_1 = ((((dlci >> 17) << 1) | (cr)) << 1) 							| EA_CONTINUE;	\
								S_octet_2 =   ((dlci >> 13) << 1) | (fecn << 3) | (becn << 2) | (de << 1) 	| EA_CONTINUE;	\
								S_octet_3 =   ((dlci >> 6 ) << 2)              								| EA_CONTINUE;	\
								S_octet_4 =   ((dlci      ) << 2)  											| EA_FINAL;		\
							} else {                                                                                    	\
								S_octet_1 = ((((dlci >> 10) << 1) | (cr)) << 1) 							| EA_CONTINUE;	\
								S_octet_2 =   ((dlci >> 6 ) << 1) | (fecn << 3) | (becn << 2) | (de << 1) 	| EA_CONTINUE;	\
								S_octet_3 =   ((dlci)       << 2)											| EA_CONTINUE;	\
								S_octet_4 = 						(1 << 1)								| EA_FINAL;		\
							}

#		endif

#	endif /* DL_LAPF == ON } */

#endif /* ENTITY == DL_F } */

#ifndef S_address_load		/* other cases: */

#	define S_address_load(sapi, tei, cr) \
							S_octet_1 = ((((sapi) << 1) + (cr)) << 1) + EA_FINAL

#endif


#define S_address_load_b(sapi, tei, cr) \
							S_octet_1 = ((((sapi) << 1) + (cr)) << 1) + EA_FINAL

			/* Frame address values */

						/* DTE side : Frame command / response bit */

#define DTE_CR_SND_COMMAND	0		/* command from user side */
#define	DTE_ADDRESS_B		DTE_CR_SND_COMMAND
#define DTE_CR_SND_RESPONSE	1		/* response from user side */
#define	DTE_ADDRESS_A		DTE_CR_SND_RESPONSE
#define DTE_CR_RCV_COMMAND	1		/* command to user side */
#define DTE_CR_RCV_RESPONSE	0		/* response to user side */

						/* DCE side : Frame command / response bit */

#define DCE_CR_SND_COMMAND	1		/* command from user side */
#define	DCE_ADDRESS_B		DCE_CR_SND_COMMAND
#define DCE_CR_SND_RESPONSE	0		/* response from user side */
#define	DCE_ADDRESS_A		DCE_CR_SND_RESPONSE
#define DCE_CR_RCV_COMMAND	0		/* command to user side */
#define DCE_CR_RCV_RESPONSE	1		/* response to user side */

						/* LAPF and V.120 */

#define CR_COMMAND			0		/* command from user side */
#define CR_RESPONSE			1		/* response from user side */

						/* Extension address bit */

#define EA_CONTINUE			0		/* address field continue on next octet */
#define EA_FINAL			1		/* final octet of address field */

#define MX_CONTROL_FIELD_SIZE 2		/* Maximum size of the control field */

/*

	--------------------------------------------------------------------
	|  Format | commands | Response | Encoding  8  7  6  5  4  3  2  1 | octet
	|------------------------------------------------------------------|
	|         |          |          |        |      N(S)          | 0  |  4
	| Informa | I(info)  |          |        |-------------------------|
	| Transf  |          |          |        |      N(R)          | P  |  5
	|------------------------------------------------------------------|
	|   S     |          |          |        | 0  0  0  0  0  0  0  1  |  4
	|   U     |    RR    |   RR     |        |-------------------------|
	|   P     |          |          |        |      N(R)          |P/F |  5
	|   E     |----------|----------|--------|-------------------------|
	|   R     |          |          |        | 0  0  0  0  0  1  0  1  |  4
	|   V     |    RNR   |   RNR    |        |-------------------------|
	|   I     |          |          |        |      N(R)          |P/F |  5
	|   S     |----------|----------|--------|-------------------------|
	|   O     |          |          |        | 0  0  0  0  1  0  0  1  | 4
	|   R     |    REJ   |   REJ    |        |-------------------------|
	|   Y     |          |          |        |      N(R)          |P/F | 4
	|-------- |----------|----------|--------|-------------------------|
	|         |          |          |        | M  M  M |PF|M  M | 1 1  | 4
	|         |----------|----------|--------|---------|--|-----|------|
	|   U     |  SABME   |          |        | 0  1  1 |P |1  1 | 1 1  | 4
	|   N     |----------|----------|--------|---------|--|-----|------|
	|   N     |          |  DM      |        | 0  0  0 |F |1  1 | 1 1  | 4
	|   U     |----------|----------|--------|---------|--|-----|------|
	|   M     |   UI     |          |        | 0  0  0 |P |0  0 | 1 1  | 4
	|   B     |----------|----------|--------|---------|--|-----|------|
	|   E     |   DISC   |          |        | 0  1  0 |P |0  0 | 1 1  | 4
	|   R     |----------|----------|--------|---------|--|-----|------|
	|   E     |          |   UA     |        | 0  1  1 |F |0  0 | 1 1  | 4
	|   D     |----------|----------|--------|---------|--|-----|------|
	|         |          |   FRMR   |        | 0  1  1 |F |0  1 | 1 1  | 4
	|-------- |----------|----------|--------|---------|--|-----|------|
	|  Mgt    |  XID     |   XID    |        | 1  0  1 |PF|1  1 | 1 1  | 4
	--------------------------------------------------------------------

*/

							/* U frame format */

struct u {
	Fr_address;				/* address field */
	uchar  cf;				/* control field */
};

#define Fr_u_size			(Fr_address_size + 1)

				/* U format (S_u_xxxx) */

#define S_cf_u						p_snd_frame -> u.cf

#define S_u_load(command, pf)		S_cf_u = ((((((( (command) >> 2 ) << 1 ) + \
												(pf) ) << 2 ) + \
											  ((command) & Mask (2)) ) << 2 ) + \
											 CTRL_U )

#define S_u_p 						(Get_bits (S_cf_u, 4, 1))
#define S_u_f 						(Get_bits (S_cf_u, 4, 1))
#define S_u_pf						(Get_bits (S_cf_u, 4, 1))
#define S_u_command	 				((Get_bits (S_cf_u, 5, 3) << 2) + \
									 Get_bits (S_cf_u, 2, 2))

#define S_u_size					Fr_u_size


				/* U format (R_u_xxxx) */

#define R_cf_u						p_rcv_frame -> u.cf

#define R_u							(Get_bits (R_cf_u, 0, 2))
#define R_u_p 						(Get_bits (R_cf_u, 4, 1))
#define R_u_f 						(Get_bits (R_cf_u, 4, 1))
#define R_u_pf						(Get_bits (R_cf_u, 4, 1))
#define R_u_command 				((Get_bits (R_cf_u, 5, 3) << 2) + \
									Get_bits (R_cf_u, 2, 2))

#define R_u_size					Fr_u_size

	/*---------------------*/

#if MODULO == 128 /* { */

					/* Modulo 128 */

			/* I frame format */

struct i{
	Fr_address;				/* address field */
	uchar	cf_1;			/* control field 1 */
	uchar	cf_2;			/* control field 2 */
};

#define	Fr_i_size			(Fr_address_size + 2)

			/* S frame format */

struct s {
	Fr_address;				/* address field */
	uchar	cf_1;			/* control field 1 */
	uchar	cf_2;			/* control field 2 */
};

#define Fr_s_size			(Fr_address_size + 2)

			/* Access to send frame   / Left Hand Side   using p_snd_frame */

				/* I (S_i_xxxx) or s (S_s_xxxx) format */

#	define S_cf_i_1					p_snd_frame -> i.cf_1
#	define S_cf_i_2					p_snd_frame -> i.cf_2
#	define S_i_load(p, nr, ns) 		S_cf_i_1 = ((ns) << 1) + CTRL_I;\
									S_cf_i_2 = ((nr) << 1 ) + p
#	define S_i						(Get_bits (S_cf_i_1, 0, 1))
#	define S_i_ns 					(Get_bits (S_cf_i_1, 1, 7))
#	define S_i_p 					(Get_bits (S_cf_i_2, 0, 1))
#	define S_i_nr 					(Get_bits (S_cf_i_2, 1, 7))
#	define S_i_size					Fr_i_size

#	define S_cf_s_1					p_snd_frame -> s.cf_1
#	define S_cf_s_2					p_snd_frame -> s.cf_2
#	define S_s_load(command, pf, nr) S_cf_s_1 = ((command) << 2) + CTRL_S;\
									S_cf_s_2 = ((nr) << 1 ) + pf
#	define S_s						(Get_bits (S_cf_s_1, 0, 2))
#	define S_s_command				(Get_bits (S_cf_s_1, 2, 6))
#	define S_s_pf					(Get_bits (S_cf_s_2, 0, 1))
#	define S_s_p 					(Get_bits (S_cf_s_2, 0, 1))
#	define S_s_f 					(Get_bits (S_cf_s_2, 0, 1))
#	define S_s_nr 					(Get_bits (S_cf_s_2, 1, 7))
#	define S_s_size					Fr_s_size

			/* Access to received frame / Right Hand Side  using p_rcv_frame pointer */

				/* I (R_i_xxxx) or s (R_s_xxxx) format */

#	define R_cf_i_1					p_rcv_frame -> i.cf_1
#	define R_cf_i_2					p_rcv_frame -> i.cf_2
#	define R_i						(Get_bits (R_cf_i_1, 0, 1))
#	define R_i_ns 					(Get_bits (R_cf_i_1, 1, 7))
#	define R_i_nr 					(Get_bits (R_cf_i_2, 1, 7))
#	define R_i_p 					(Get_bits (R_cf_i_2, 0, 1))
#	define R_i_size					Fr_i_size

#	define R_cf_s_1					p_rcv_frame -> s.cf_1
#	define R_cf_s_2					p_rcv_frame -> s.cf_2
#	define R_s						(Get_bits (R_cf_s_1, 0, 2))
#	define R_s_command				(Get_bits (R_cf_s_1, 2, 6))
#	define R_s_pf					(Get_bits (R_cf_s_2, 0, 1))
#	define R_s_p 					(Get_bits (R_cf_s_2, 0, 1))
#	define R_s_f 					(Get_bits (R_cf_s_2, 0, 1))
#	define R_s_nr 					(Get_bits (R_cf_s_2, 1, 7))
#	define R_s_size					Fr_s_size

#endif /* MODULO == 128 } */

	/*---------------------*/

#if MODULO == 8 /* { */

						/*  Modulo 8 */

				/* I frame format */

struct i {
	Fr_address;				/* address field */
	uchar	cf;				/* control field */
};
#define Fr_i_size			(Fr_address_size + 1)

				/* S frame format */

struct s {
	Fr_address;				/* address field */
	uchar	cf;				/* control field */
};

#define Fr_s_size			(Fr_address_size + 1)

			/* Access to send frame   / Left Hand Side   using p_snd_frame */

				/* I (S_i_xxxx) or s (S_s_xxxx) format */


#	define S_cf_i					p_snd_frame -> i.cf
#	define S_i_load(p, nr, ns)		S_cf_i = ((((((nr) << 1) + p) << 3) + (ns)) << 1) + CTRL_I;
#	define S_i_ns 					Get_bits (S_cf_i, 1, 3)
#	define S_i_p 					Get_bits (S_cf_i, 4, 1)
#	define S_i_nr 					Get_bits (S_cf_i, 5, 3)
#	define S_i_size					Fr_i_size

#	define S_cf_s					p_snd_frame -> s.cf
#	define S_s_load(command, pf, nr) S_cf_s = ((((((nr) << 1) + pf) << 2) + (command)) << 2) + CTRL_S;
#	define S_s_command				Get_bits (S_cf_s, 2, 2)
#	define S_s_pf					Get_bits (S_cf_s, 4, 1)
#	define S_s_p 					Get_bits (S_cf_s, 4, 1)
#	define S_s_f 					Get_bits (S_cf_s, 4, 1)
#	define S_s_nr 					Get_bits (S_cf_s, 5, 3)
#	define S_s_size					Fr_s_size

			/* Access to received frame / Right Hand Side  using p_rcv_frame pointer */

				/* I (R_i_xxxx) or s (R_s_xxxx) format */

#	define R_cf_i					p_rcv_frame -> i.cf
#	define R_i						Get_bits (R_cf_i, 0, 1)
#	define R_i_nr 					Get_bits (R_cf_i, 5, 3)
#	define R_i_ns 					Get_bits (R_cf_i, 1, 3)
#	define R_i_p 					Get_bits (R_cf_i, 4, 1)
#	define R_i_size					Fr_i_size

#	define R_cf_s					p_rcv_frame -> s.cf
#	define R_s						Get_bits (R_cf_s, 0, 2)
#	define R_s_command				Get_bits (R_cf_s, 2, 2)
#	define R_s_pf					Get_bits (R_cf_s, 4, 1)
#	define R_s_p 					Get_bits (R_cf_s, 4, 1)
#	define R_s_f 					Get_bits (R_cf_s, 4, 1)
#	define R_s_nr 					Get_bits (R_cf_s, 5, 3)
#	define R_s_size					Fr_s_size

#endif /* MODULO == 8 } */

	/*---------------------*/

						/* Frame general structure */

union frame {
	struct address address;				/* address field */
	struct i i;							/* control field A / information transfer format - I */
	struct s s;							/* control field B / supervisory format - S */
	struct u u;							/* control field A or B / unnumbered format - U */
};

			/* Frame control field values */

						/* Types of control fields */

#define CTRL_I			0				/* information transfer - I */
#define CTRL_S 			1				/* supervisory - S */
#define CTRL_U  		3				/* unnumbered  - U */

						/* Poll/Final bit value */

#define P_ON			1				/* poll bit set */
#define P_OFF			0

#define F_ON			1				/* final bit set */
#define F_OFF			0

						/* Commands and Responses */

							/* U encoding */

#define	SABM			G_5(0,0,1,1,1)	/* set asynchronous balanced mode */
#define SABME			G_5(0,1,1,1,1)	/* set asynchronous balanced mode extended */
#define DISC 			G_5(0,1,0,0,0)	/* disconnect */
#define UA				G_5(0,1,1,0,0)	/* unnumbered acknowledge */
#define UI				G_5(0,0,0,0,0)	/* unnumbered information */
#define SI0				G_5(0,1,1,0,1)	/* SI0 information */
#define SI1				G_5(1,1,1,0,1)	/* SI1 information */
#define DM				G_5(0,0,0,1,1)	/* disconnect mode */
#define FRMR			G_5(1,0,0,0,1)	/* frame reject */
#define XID				G_5(1,0,1,1,1)	/* eXchange IDentification */
#define U_INVALID		G_5(1,1,1,1,1)	/* invalid U code */

							/* S encoding */

#define RR				G_2(0,0)		/* receive ready */
#define RNR				G_2(0,1)        /* receive not ready */
#define REJ				G_2(1,0)		/* reject */
#define S_INVALID		G_2(1,1)		/* invalid S code */

						/* modulo */

#define MODULO_BASIC 	8				/* basic modulo */
#define MODULO_EXTENDED 128				/* extended modulo */

				/* Received an send frame internal event ID */

			/* These event ID must different of the PH_XXX_IN event ID (a,b) */

#define FR_I			1         		/* information frame */
#define FR_SABM			2				/* set asynchronous balanced mode */
#define FR_SABME		3				/* set asynchronous balanced mode extended */
#define FR_DISC			4				/* disconnect */
#define FR_UI			5				/* unnumbered information */
#define FR_RR			6				/* receive ready */
#define FR_RNR			7				/* receive not ready */
#define FR_REJ			8				/* reject */
#define FR_UA			9				/* unnumbered acknowledged */
#define FR_DM			10				/* disconnect mode */
#define FR_FRMR			11				/* frame reject */
#define FR_XID_COMMAND	12				/* XID command  */
#define FR_XID_RESPONSE	13				/* XID response */


#define FR_RR_COMMAND 	14				/* receive ready command */
#define FR_RR_RESPONSE	15				/* receive ready response */
#define FR_RNR_COMMAND	16				/* receive not ready command */
#define FR_RNR_RESPONSE 17				/* receive not ready  response */
#define FR_REJ_COMMAND	18				/* frame reject command */
#define FR_REJ_RESPONSE	19				/* frame reject response */

			/* Erroneous frame */

#define FR_ERR_CTRL		20				/* frame control field errror */
#define FR_ERR_INFO		21				/* information not permitted */
#define FR_ERR_LENGTH	22				/* incorrect length */
#define FR_ERR_I_TOO_LONG 23			/* frame too long */
#define FR_ERR_INVALID_NR 24	        /* invalid NR */

			/* Internal event */

#define QU_FR_I			25				/* in queue frame I */
#define QU_FR_UI		26				/* in queue frame UI */

			/* SI frame */

#define FR_SI_COMMAND	27				/* SI command with information field */
#define FR_SI_COMMAND_EMPTY	28			/* SI command without information field */
#define FR_SI_RESPONSE	29				/* SI response */


			 /* FRMR Frame reject response information field format */

/*
	  8    7    6    5    4    3    2    1      octet
	-----------------------------------------
	|         Rejected frame                |    5
	|---------------------------------------|
	|         Control field                 |    6
	|---------------------------------------|
	|             V(S)                 | 0  |    7
	|----------------------------------|----|
	|             V(R)                 |C/R |    8
	|----------------------------------|----|
	| 0   0     0    0  |  z |  y |  x | w  |    9
	-----------------------------------------	*/

#if MODULO == 128 /* { */

	struct frmr	{
		Fr_address;						/* address field */
		uchar		u_control;

		uchar		rfcf_1;				/* rejected frame control field */
		uchar		rfcf_2;				/*     idem						*/
		uchar		vs;					/* V(S) current state */
		uchar		vr;					/* V(R) current state */
		uchar		wxyz;				/* error cause */
	};


#	define 	S_frmr_size 					Fr_u_size + 5
#	define 	S_frmr_cf_size 					2
#	define	S_a_frmr_control			  &(((struct frmr FAR *)p_snd_frame) -> u_control)
#	define	S_a_frmr_rfcf				  &(((struct frmr FAR *)p_snd_frame) -> rfcf_1)
#	define	S_frmr_vs						((struct frmr FAR *)p_snd_frame) -> vs
#	define	S_frmr_vr						((struct frmr FAR *)p_snd_frame) -> vr
#	define	S_frmr_wxyz						((struct frmr FAR *)p_snd_frame) -> wxyz

#	define	S_frmr_load(vs, cr, vr, wxyz)   S_frmr_vs	= (vs) << 1;			\
											S_frmr_vr	= ((vr) << 1) + (cr);	\
											S_frmr_wxyz	= (wxyz)

#else /* MODULO == 128 } else { */

	struct frmr	{
		Fr_address;						/* address field */
		uchar		u_control;

		uchar		rfcf_1;				/* rejected control field */
		uchar		vs_vr;				/* current variable state */
		uchar		wxyz;				/* eeror cause */
	};


#	define 	S_frmr_size 					Fr_u_size + 3
#	define 	S_frmr_cf_size 					1
#	define	S_a_frmr_control			  &(((struct frmr FAR *)p_snd_frame) -> u_control)
#	define	S_a_frmr_rfcf				  &(((struct frmr FAR *)p_snd_frame) -> rfcf_1)
#	define	S_frmr_vs_vr					((struct frmr FAR *)p_snd_frame) -> vs_vr
#	define	S_frmr_wxyz						((struct frmr FAR *)p_snd_frame) -> wxyz

#	define	S_frmr_load(vs, cr, vr, wxyz)   S_frmr_vs_vr	= (((((vr) << 1) + (cr)) << 3) + (vs)) << 1;\
											S_frmr_wxyz		= (wxyz)

#endif /* MODULO != 128 } */

#define FRMR_SIZE_MAX		9				/* Max size of a frmr frame */

			/* Coding invalid cause */

#define FRMR_W				(1)			/* invalid control field bit */
#define FRMR_X				(1 << 1)	/* invalid information field */
#define FRMR_Y				(1 << 2)	/* too long frame */
#define FRMR_Z				(1 << 3)	/* invalid N(R) */

/*-------------------------------------------------------------------------*/

			/*
			   Unpacked frame header structure (each field is store
			   into one byte).
			*/

struct upfh {
	sapi_t 			sapi;				/* sapi */
	uchar 			tei;				/* tei */
	uchar 			chani;				/* channel Identifier */
	uchar 			cr;					/* command response bit */
	uchar 			format;				/* format (i,s,u) */
	uchar 			command;			/* command code */
	uchar 			pf;					/* poll/final bit */
	uchar 			ns;					/* ns sequense number */
	uchar 			nr;					/* nr sequence number */
	uchar			header_size;		/* frame header size */

#	if (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

#		if (DL_LAPF == ON) && ((DL_LAPF_ADD_FF_3) || (DL_LAPF_ADD_FF_4))
			ulong	dlci;				/* DLCI */

#		else

			ushort	dlci;				/* DLCI */
#		endif

#		if (DL_LAPF == ON)
			uchar	becn;				/* BECN */
			uchar	fecn;				/* FECN */
			uchar	de;					/* DE */
			uchar	dc;					/* DC */
#		endif

#	endif

	ushort 	size_total;					/* frame total size */
	ushort	size_up;					/* upper limit of the frame size */
	uchar	control [MX_CONTROL_FIELD_SIZE];/* received control field */
};

			/* Receive Unpacked (Ru_...) values */

#define Ru_sapi			receive_fr.sapi
#define Ru_tei			receive_fr.tei
#define Ru_dlci			receive_fr.dlci
#define Ru_becn			receive_fr.becn
#define Ru_fecn			receive_fr.fecn
#define Ru_de			receive_fr.de
#define Ru_dc			receive_fr.dc
#define Ru_chani		receive_fr.chani
#define Ru_cr			receive_fr.cr
#define Ru_format		receive_fr.format
#define Ru_command		receive_fr.command
#define Ru_f			receive_fr.pf
#define Ru_pf			receive_fr.pf
#define Ru_p			receive_fr.pf
#define Ru_ns			receive_fr.ns
#define Ru_nr			receive_fr.nr
#define Ru_header_size	receive_fr.header_size
#define Ru_size_total	receive_fr.size_total
#define Ru_size_up		receive_fr.size_up
#define Ru_a_control   &receive_fr.control [0]


			/* Send Unpacked (Su_...) values */

#define Su_sapi			send_fr.sapi
#define Su_tei			send_fr.tei
#define Su_dlci			send_fr.dlci
#define Su_chani 		send_fr.chani
#define Su_becn			send_fr.becn
#define Su_fecn			send_fr.fecn
#define Su_de			send_fr.de
#define Su_dc			send_fr.dc
#define Su_cr			send_fr.cr
#define Su_format		send_fr.format
#define Su_command		send_fr.command
#define Su_f			send_fr.pf
#define F				send_fr.pf
#define Su_p			send_fr.pf
#define Su_pf			send_fr.pf
#define Su_ns			send_fr.ns
#define Su_nr			send_fr.nr
#define Su_header_size	send_fr.header_size
#define Su_size_up		send_fr.size_up

#define I				'I'
#define S				'S'
#define U				'U'

/*-------------------------------------------------------------------------*/

					/* DL and MDL QUEUE MANAGEMENT */

					/* Queue complement structure */

struct queue_compl {
	struct message FAR	*p_sent;	/* last sent  i frame */
	uchar 				 flag;		/* signal flag */
};

					/* DL Queue parameters */

#define QU_UI			0			/* index waiting queue UI */
#define QU_I        	1			/* index waiting queue I */
#define MX_QUEUE		2			/* maximum number of queues used
									   simultaneaously */

					/* MDL Queue parameters */

#define QU_TAP			0           /* index queue TAP MDL */

#if DL_LAP4K == ON
#	define QU_L3		1           /* index queue L3 MDL */
#define MX_QUEUE_MDL	2			/* maximum number of queue in MDL */

#else

#define MX_QUEUE_MDL	1			/* maximum number of queue in MDL */
#endif

/*-------------------------------------------------------------------------*/

				/* DL : TIMER MANAGEMENT */

#define MX_TIMER		MX_DL_TIMER

#if (ENTITY == DL_D) || (ENTITY == DL_B) || (ENTITY == DL_F) /* { */

			/* DL timer table : index assigned to timers (for overlaping) */

#define T200			0			/* timer T200 (DL) */
#define T203			1			/* timer T203 (DL) */

#if DL_V120 == ON
#	define TM20			2			/* timer V120 XID */
#	define MX_DL_TIMER	3			/* maximum number of timer used simultaneously */
#else
#	define MX_DL_TIMER	2			/* maximum number of timer used simultaneously */
#endif

#define Ti_ev_id(xx)	DL_TI_EV_ID[xx]	/* timer ID table */

				/* Timer macro's */

#if OPTIMIZATION == SPEED /* { */

#	if DL_PH_TX_DONE == ON
#		define Start_timer_t200()      if (Chan_tx_done == ON) {	\
											Tx_done_t200 = ON;  	\
										} else {                	\
											Start_timer	(T200);  	\
										}

#		define Stop_timer_t200()        Stop_timer 		(T200); Tx_done_t200 = OFF

#		define T200_running()			((Tx_done_t200 == ON) || (State_timer (T200) == ON))

#		define Restart_timer_t200()		dl_restart_timer_t200_tx_done ()

#	else

#		define Start_timer_t200()		Start_timer 	(T200)
#		define Stop_timer_t200()        Stop_timer 		(T200)
#		define T200_running()			(State_timer (T200) == ON)
#		define Restart_timer_t200()		Restart_timer 	(T200)
#	endif

#else /* OPTIMIZATION == SPEED } else { */

#	if DL_PH_TX_DONE == ON
#		define Start_timer_t200()		dl_start_timer_t200_tx_done ()
#		define Stop_timer_t200()		dl_stop_timer_t200_tx_done  ()
#		define T200_running()			((Tx_done_t200 == ON) || (State_timer (T200) == ON))
#		define Restart_timer_t200()		dl_restart_timer_t200_tx_done ()

#	else

#		define Start_timer_t200()		dl_start_timer 	(T200)
#		define Stop_timer_t200()        dl_stop_timer 	(T200)
#		define T200_running()			(State_timer (T200) == ON)
#		define Restart_timer_t200()		dl_restart_timer (T200)
#	endif

#endif /* OPTIMIZATION != SPEED } */


#if OPTIMIZATION == SPEED /* { */

#	if DL_T203 == ON
#		define Start_timer_t203()		if (Ti_id (T203) != P_NIL) {\
											Start_timer 	(T203);	\
										}

#		define Restart_timer_t203()		if (Ti_id (T203) != P_NIL) {\
											Restart_timer 	(T203);	\
										}

#		define Stop_timer_t203()        if (Ti_id (T203) != P_NIL) {\
											Stop_timer 		(T203);	\
										}

#	else

#		define Start_timer_t203()
#		define Restart_timer_t203()
#		define Stop_timer_t203()
#	endif

#else /* OPTIMIZATION == SPEED } else { */

#	if DL_T203 == ON
#		define Start_timer_t203()		dl_start_timer_t203 	()
#		define Restart_timer_t203()		dl_restart_timer_t203	()
#		define Stop_timer_t203()        dl_stop_timer_t203 		()

#	else

#		define Start_timer_t203()
#		define Restart_timer_t203()
#		define Stop_timer_t203()
#	endif

#endif /* OPTIMIZATION != SPEED } */

/*-------------------------------------------------------------------------*/

					/* DL OPTION FLAG */

#define	Dl_att_ni			dl_att_ni			/* AT&T and NI access to option flag */
	extern uchar			dl_att_ni;			/* AT&T and NI option flag */

/*-------------------------------------------------------------------------*/

					/* DL : PH CHANNEL MANAGEMENT */

struct dlchan {
	add_t					chani;				/* Channel ID */
	uchar					state;				/* Channel state : for channel activation */
	nai_t					nai;				/* Network access Id */
	sapi_t 					sapi;				/* Channel identifier to DL SAPI */
	ces_t					ces;				/* Connection ID using the channel */
	ent_id_t				dl_entity_id;		/* DL entity identifier (ENT_DL_D, ENT_DL_B, ENT_DL_V120, ENT_DL_4K) */
	struct queue_mgt 		qu_tab;				/* incoming L3 request waiting queue for PH activation */
	sapi_t					ph_sapi;			/* PH SAPI */
	ent_id_t    			ph_entity_id;		/* PH entity Id managing the channel */
	ent_id_t    			l3_entity_id;		/* L3 entity ID given by the PH layer */

#	if DL_IDENTIFICATION == ON
		uchar				rc;					/* retry count */
		uchar				rc_max;				/* max number of retry */
		uchar				ident_profile_nb;	/* identification profile number */
		timer_val_t			ident_timer_val;	/* Identification timer value */
		struct 	timer 		timer_ident [1];	/* Identification timer table */
#	endif

#	if DL_LAPX == ON
		uchar				dlx_usage;			/* Used as LAPX or not */
		uchar				dlx_state;			/* LAPX state */
		struct 	queue_mgt 	qu_tx [1];			/* LAPX transmit queue */
		timer_val_t			xt1_originator;		/* LAPX XT1 calling timer value */
		timer_val_t			xt1_answerer;		/* LAPX XT1 called timer value */
		timer_val_t			xt1_val;			/* LAPX XT1 timer current value */
		struct 	timer 		timer_dlx [1];		/* LAPX timer table */
#	endif

#	if DL_PH_TX_DONE == ON
		uchar				tx_done;			/* Transmit done indication : ON or OFF */
#	endif

};


#if DL_PH_MUX == ON /* { */

					/* DL : Physical multiplex description */

	struct dlmux {
		nai_t	linked_na [DL_MX_NA_PER_MUX];
	};


#	define Dl_mux_nai(xx)			p_dlmux -> linked_na [xx]
#	define Dl_mux_size				Rnd_sizeof (struct dlmux)

#endif /* DL_PH_MUX == ON } */

					/* DL : NETWORK ACCESS MANAGEMENT */

struct dlna {
	uchar				FAR *p_mem_blk;			/* memory block allocated to the NA */
	nai_t 					 nai;				/* network access identifier */
	uchar					 fct;				/* functional grouping */
	uchar 					 type;				/* type of network access */
	uchar 					 sap_nb;			/* number of declared SAP */
	uchar 					 active;			/* access status : set (ON) or stop (OFF) */
	add_t					 channel_nb;		/* number of channel ID */
	uchar					 att_ni_flag;		/* AT&T and NI flag */

#	if DL_STATISTICS == ON
		ulong				 nb_tx_frame;		/* number of Tx frame */
		ulong				 nb_rx_frame;		/* number of Rx frame */
		ulong				 nb_tx_i;			/* number of Tx I frame */
		ulong				 nb_rx_i;			/* number of Rx I frame */
		ulong				 nb_tx_rr;			/* number of Tx RR frame */
		ulong				 nb_rx_rr;			/* number of Rx RR frame */
		ushort				 nb_tx_reject;		/* number of Tx REJ frame */
		ushort				 nb_rx_reject;		/* number of Rx REJ frame */
		ushort				 nb_tx_rnr;			/* number of Tx RNR frame */
		ushort				 nb_rx_rnr;			/* number of Rx RNR frame */
		ushort				 nb_t200_expiry;	/* number of T200 expiry */
#	endif

#	if DL_PH_MUX == ON
		struct dlchan 	FAR *p_ph_chan;			/* Physical channel pointer */
		struct dlmux	FAR *p_dlmux;			/* DL multiplexer pointer */
#	endif

	struct dlchan 			 dlchan [1];		/* channel management first item of the channel array */
};

				/* Access to current NA value using p_dlna pointer */

#define P_mem_blk					p_dlna -> p_mem_blk
#define Nai 						p_dlna -> nai
#define Na_channel_nb				p_dlna -> channel_nb
#define Na_fct						p_dlna -> fct
#define Na_type						p_dlna -> type
#define Sap_nb						p_dlna -> sap_nb
#define Na_active					p_dlna -> active
#define Na_att_ni_flag				p_dlna -> att_ni_flag

#if DL_STATISTICS == ON
#	define Na_nb_tx_frame			p_dlna -> nb_tx_frame
#	define Na_nb_rx_frame			p_dlna -> nb_rx_frame
#	define Na_nb_t200_expiry		p_dlna -> nb_t200_expiry
#	define Na_nb_tx_reject			p_dlna -> nb_tx_reject
#	define Na_nb_rx_reject			p_dlna -> nb_rx_reject
#	define Na_nb_tx_rr				p_dlna -> nb_tx_rr
#	define Na_nb_rx_rr				p_dlna -> nb_rx_rr
#	define Na_nb_tx_rnr				p_dlna -> nb_tx_rnr
#	define Na_nb_rx_rnr				p_dlna -> nb_rx_rnr
#	define Na_nb_tx_i				p_dlna -> nb_tx_i
#	define Na_nb_rx_i				p_dlna -> nb_rx_i
#	define Inc_stat_counter(x)		(x)++
#else
#	define Inc_stat_counter(x)
#endif

#define Na_a_dlchan				p_dlna -> p_ph_chan
#define Na_a_dlmux				p_dlna -> p_dlmux
#define Na_a_chan(chani)			((struct dlchan FAR *)&(p_dlna -> dlchan[chani]))

				/* Access to the Channel information */

#define Chan_chani					p_dlchan -> chani
#define Chan_state					p_dlchan -> state
#define Chan_chani_to_nai 			p_dlchan -> nai
#define Chan_chani_to_sapi 			p_dlchan -> sapi
#define Chan_chani_to_ces 			p_dlchan -> ces
#define Chan_chani_to_dl_entity_id	p_dlchan -> dl_entity_id
#define Chan_first_rq				p_dlchan -> qu_tab.p_first
#define Chan_last_rq				p_dlchan -> qu_tab.p_last
#define Chan_ph_sapi				p_dlchan -> ph_sapi
#define Chan_ph_entity_id			p_dlchan -> ph_entity_id
#define Chan_l3_entity_id			p_dlchan -> l3_entity_id

#if DL_IDENTIFICATION == ON /* { */
#	define Chan_ident_rc			p_dlchan -> rc
#	define Chan_ident_rc_max		p_dlchan -> rc_max
#	define Chan_ident_profile_nb	p_dlchan -> ident_profile_nb
#	define Chan_ident_a_id			Dl_ident_profile_a_id ((Chan_ident_profile_nb))
#	define Chan_ident_a_sig			Dl_ident_profile_a_sig((Chan_ident_profile_nb))
#	define Chan_ident_timer_val		p_dlchan -> ident_timer_val
#	define Chan_ident_timer_state	p_dlchan -> timer_ident[0].state
#	define Chan_ident_timer_id		p_dlchan -> timer_ident[0].id
#	define Chan_ident_timer_sn		p_dlchan -> timer_ident[0].sn

			/* XID timer management */

#	define Chan_ident_start_timer()		if (Chan_ident_timer_val != 0) {			\
											Timer_start (Chan_ident_timer_id,		\
														 Chan_ident_timer_val,		\
														 ++(Chan_ident_timer_sn),	\
														 TI_XID);					\
											Chan_ident_timer_state = ON;			\
										}

#	define Chan_ident_stop_timer()  	if (Chan_ident_timer_state == ON) {			\
											Timer_stop (Chan_ident_timer_id);		\
											Chan_ident_timer_state = OFF;			\
										}

#	define Chan_ident_valid_time_out() ((Chan_ident_timer_state == ON) &&			\
										 (R_msg_inf0 == Chan_ident_timer_sn))

#endif /* DL_IDENTIFICATION == ON } */


#if DL_LAPX == ON /* { */
#	define Chan_dlx_usage			p_dlchan -> dlx_usage
#	define Chan_dlx_state			p_dlchan -> dlx_state
#	define Chan_dlx_first			p_dlchan -> qu_tx[0].p_first
#	define Chan_dlx_last			p_dlchan -> qu_tx[0].p_last
#	define Chan_dlx_xt1_o			p_dlchan -> xt1_originator
#	define Chan_dlx_xt1_a			p_dlchan -> xt1_answerer
#	define Chan_dlx_xt1_val			p_dlchan -> xt1_val
#	define Chan_dlx_xt1_state		p_dlchan -> timer_dlx[0].state
#	define Chan_dlx_xt1_id			p_dlchan -> timer_dlx[0].id
#	define Chan_dlx_xt1_sn			p_dlchan -> timer_dlx[0].sn

				/* Dlx timer management */

#	define Chan_dlx_start_timer_xt1()	if (Chan_dlx_xt1_val  != 0) {				\
												Timer_start (Chan_dlx_xt1_id,		\
															 Chan_dlx_xt1_val,		\
															 ++(Chan_dlx_xt1_sn),	\
															 TI_XT1);				\
												Chan_dlx_xt1_state = ON;			\
										}

#	define Chan_dlx_stop_timer_xt1()  	if (Chan_dlx_xt1_state == ON) {				\
												Timer_stop (Chan_dlx_xt1_id);		\
												Chan_dlx_xt1_state = OFF;			\
										}

#	define Chan_dlx_valid_time_out_xt1() ((Chan_dlx_xt1_state == ON) &&				\
												(R_msg_inf0 == Chan_dlx_xt1_sn))
#endif /* DL_LAPX == ON } */


#if DL_PH_TX_DONE == ON
#	define Chan_tx_done				p_dlchan -> tx_done
#endif

/*-------------------------------------------------------------------------*/

				/* DL : SERVICE ACCESS POINT MANAGEMENT (L3 VIEW) */

struct dlsap {
	sapi_t			sapi;					/* service access point identifier */
	uchar	 		modulo;					/* modulo 128 or 8 */
	uchar			i_size;					/* I frame header size */
	uchar 			dlcep_nb;				/* number of declared DLCEP */
	ent_id_t		dl_entity_id;			/* DL entity identifier (ENT_D or ENT_B) */
	ent_id_t		l3_entity_id;			/* L3 entity identifier */
	ent_id_t		l3_entity_id_default;	/* L3 default entity identifier */
	uchar 			n200;					/* parameter : maximum of retransmissions (N200) */
	ushort			n201;					/* parameter : maximum size of an information field */
	uchar 			k;						/* parameter : windowing size transmitter */
	uchar			no_congestion;			/* no congestion flag : OFF --> congestion management */

#	if DL_FC == ON
		uchar		out_fc_low_mark;		/* outgoing flow control low mark */
		uchar		out_fc_high_mark;		/* outgoing flow control high mark */
#	endif

	timer_val_t	t200_val;					/* parameter : T200 timer value */

#	if DL_XID == ON
		uchar		xid_rc_max;  			/* maximum retry */
		timer_val_t xid_timer_val;			/* retry timer val */

#		if DL_IDENTIFICATION == ON
			uchar		xid_ident_profile_nb;	/* identification profile number */
#		endif

#	endif

#	if DL_ISDN_BIOS == ON
		uchar		isdn_bios;				/* LAPB ISDN-BIOS facilities : ON or OFF */
#	endif

	uchar			teledisket;				/* teledisket profile : EURO SFT */

#	if DL_LAPF == ON
		uchar		lapf_add_ff;			/* LAPF : Address field format : 2, 3 or 4 */
		uchar		lapf_de;				/* LAPF : discard eligibility bit */
		uchar		lapf_dc;				/* LAPF : DLCI or DL-CORE control indicator */
#	endif

};

			/* Access to current SAP values using p_dlsap pointer */

#define Modulo					p_dlsap -> modulo
#define N200 					p_dlsap -> n200
#define N201 					p_dlsap -> n201
#define Dlcep_nb				p_dlsap -> dlcep_nb
#define Sapi 					p_dlsap -> sapi
#define Dl_entity_id_ctx		p_dlsap -> dl_entity_id
#define L3_entity_id			p_dlsap -> l3_entity_id
#define L3_entity_id_default	p_dlsap -> l3_entity_id_default
#define I_size					p_dlsap -> i_size
#define K_cfg					p_dlsap -> k
#define No_congestion			p_dlsap -> no_congestion

#define Out_fc_low_mark			p_dlsap -> out_fc_low_mark
#define Out_fc_high_mark		p_dlsap -> out_fc_high_mark

#define T200_val				p_dlsap -> t200_val

#define Xid_rc_max				p_dlsap -> xid_rc_max
#define Xid_timer_val			p_dlsap -> xid_timer_val
#define Xid_ident_profile_nb	p_dlsap -> xid_ident_profile_nb

#define Isdn_bios				p_dlsap -> isdn_bios

#define Dl_teledisket			p_dlsap -> teledisket

#define Lapf_add_ff				p_dlsap -> lapf_add_ff
#define Lapf_de					p_dlsap -> lapf_de
#define Lapf_dc					p_dlsap -> lapf_dc

			/* Cache access for frequently read only data */

#define Dl_entity_id			dl_entity_id
		extern ent_id_t			dl_entity_id;

/*-------------------------------------------------------------------------*/

				/* DL : DATA LINK CONNECTION ENDPOINT MANAGEMENT */

struct dlcep {
	ces_t		ces;						/* connection endpoint suffix */
	uchar		tei;						/* terminal endpoint identifier */
	add_t		chani;						/* channel identifier */

#	if (DL_V120 == ON) || (DL_LAP4K == ON) || (DL_LAPF == ON)

#		if (DL_LAPF == ON) && ((DL_LAPF_ADD_FF_3) || (DL_LAPF_ADD_FF_4))
			ulong	dlci;					/* DLCI */

#		else

			ushort	dlci;					/* DLCI */
#		endif

#	endif

	ushort		n201_tx;					/* maximum size of the information field transmitter */
	ushort		n201_rx;					/* maximum size of the information field receiver */
	uchar 		k_tx;						/* parameter : windowing size transmitter */
	timer_val_t	ti [MX_TIMER];				/* parameter : timer values */
	uchar 		own_receiver_state;			/* receiver busy */
	uchar		system_state;				/* local system state : BUSY or FREE */
	uchar		discarded_i_frame_state;	/* I frame discarded during busy condition or not : ON or OFF */
	uchar 		remote_receiver_state;		/* remote busy */

#	if DL_FC == ON
		uchar	in_fc_state;				/* incoming flow control state : BUSY or FREE */
		uchar   out_fc_state;				/* outgoing flow control state : FREE or BUSY */
		uchar	out_fc_mark;				/* outgoing flow control current mark */
#	endif

	uchar  		s;							/* multiple frame operation / send state variable V(S) */
	uchar  		a;							/* multiple frame operation / acknowledge state variable V(A) */
	uchar  		r;							/* multiple frame operation / receive state variable V(R) */
	uchar   	rc;							/* retransmission counter variable */
	uchar 		state;						/* cep state */
	uchar  		remote_ack_pending;			/* pending remote acknowledgment */
	uchar   	commit_rq;					/* pending commitment to layer 3 */
	uchar 		reject_exception;			/* reject exception state */
	uchar 		layer_3_initiated;			/* flag layer 3 initiated */
	uchar 		layer_3_rel_rq;				/* flag layer 3 rel_rq received : ON or OFF */
	uchar		cr_rcv_command;				/* C/R received command */
	uchar		cr_rcv_response;			/* C/R received response */
	uchar		cr_snd_command;				/* C/R sent command */
	uchar		cr_snd_response;			/* C/R sent response */
	struct 		timer timer_table[MX_TIMER];/* timer table */
	struct 		queue_mgt qu_tab[MX_QUEUE];	/* standard waiting queue I et UI */
	struct 		queue_compl qu_compl[MX_QUEUE];	/* complement information to the queue management */
	uchar		frmr_save[FRMR_SIZE_MAX];	/* frame rejection save area */

#	if DL_PH_TX_DONE == ON
		uchar	tx_done_t200;				/* T200 requested at the end of the TX */
#	endif

	uchar		frmr_pf;					/* P/F for FRMR retransmission */

#	if DL_U_FRAME == ON
		uchar	u_frame_flag;				/* U Frame (ON) or MFO (OFF) */
		uchar	si_empty_flag;				/* SI empty frame transmitted flag */
#	endif

#	if DL_RELAY == ON
		uchar				 lc_state;		/* Link connection state */
		struct dlna  	FAR *p_dlna;		/* NA pointer */
		struct dlchan 	FAR *p_dlchan;		/* CHAN pointer */
		struct dlsap 	FAR *p_dlsap;		/* SAP pointer */
		struct dlcep 	FAR *p_dlcep;		/* CEP pointer */
		struct queue_mgt 	 r_queue;		/* request waiting queue for DL establishment */
#	endif

#	if DL_MLP == ON
		nai_t				slp_nai;		/* SLP NAI 	*/
		sapi_t				slp_sapi;       /* SLP SAPI */
		ces_t				slp_ces;		/* SLP CES 	*/
		uchar			FAR *p_mlpna;   	/* MLP NA pointer */
		uchar			FAR *p_mlpcep;		/* Mlp CEP pointer */
#	endif

#	if (DL_V120 == ON) && (DL_V120_XID_NEGOTIATION == ON)
		uchar				 setparm_save[V120_setparm_size];/* setparm request data save area */
		uchar				 rc_xid;		/* XID retry count */
#	endif

#	if DL_STATISTICS == ON
		long				 tx_byte;
		long				 tx_i_frame;
		long				 tx_rr_frame;
		long				 tx_rnr_frame;
		long				 tx_rej_frame;

		long				 rx_byte;
		long				 rx_bad_frame;
		long				 rx_i_frame;
		long				 rx_rr_frame;
		long				 rx_rnr_frame;
		long				 rx_rej_frame;
#	endif

};

			/* Access to current CEP values using p_dlcep pointer */

#define N201_tx					p_dlcep -> n201_tx
#define N201_rx					p_dlcep -> n201_rx
#define K						p_dlcep -> k_tx
#define Ti_val(xx)				p_dlcep -> ti[xx]
#define Vs 						p_dlcep -> s
#define Va 						p_dlcep -> a
#define Vr 						p_dlcep -> r
#define Rc 						p_dlcep -> rc
#define Remote_ack_pending		p_dlcep -> remote_ack_pending
#define Commit_rq				p_dlcep -> commit_rq
#define Remote_receiver_state 	p_dlcep -> remote_receiver_state
#define Own_receiver_state 		p_dlcep -> own_receiver_state
#define Discarded_i_frame_state p_dlcep -> discarded_i_frame_state
#define In_fc_state		 		p_dlcep -> in_fc_state
#define System_state	 		p_dlcep -> system_state
#define Out_fc_mark			 	p_dlcep -> out_fc_mark
#define Out_fc_state	 		p_dlcep -> out_fc_state

#define Reject_exception 		p_dlcep -> reject_exception
#define State 					p_dlcep -> state
#define Layer_3_initiated		p_dlcep -> layer_3_initiated
#define Layer_3_rel_rq			p_dlcep -> layer_3_rel_rq
#define Ces 					p_dlcep -> ces
#define Tei 					p_dlcep -> tei
#define Dlci 					p_dlcep -> dlci
#define Chani					p_dlcep -> chani
#define First(xx)				p_dlcep -> qu_tab[xx].p_first
#define Last(xx)				p_dlcep -> qu_tab[xx].p_last
#define Sent(xx)				p_dlcep -> qu_compl[xx].p_sent
#define Signal_flag(xx) 		p_dlcep -> qu_compl[xx].flag
#define Ti_state(xx)			p_dlcep -> timer_table[xx].state
#define Ti_id(xx)				p_dlcep -> timer_table[xx].id
#define Ti_sn(xx)				p_dlcep -> timer_table[xx].sn
#define Frmr_a_save				&(p_dlcep -> frmr_save[0])
#define Cr_rcv_command			p_dlcep -> cr_rcv_command
#define Cr_rcv_response			p_dlcep -> cr_rcv_response
#define Cr_snd_command			p_dlcep -> cr_snd_command
#define Cr_snd_response			p_dlcep -> cr_snd_response

#if (DL_V120 == ON) && (DL_V120_XID_NEGOTIATION == ON)
#	define Setparm_a_save	  &(p_dlcep -> setparm_save[0])
#	define Rc_xid				p_dlcep -> rc_xid
#endif

#if DL_PH_TX_DONE == ON
#	define Tx_done_t200			p_dlcep -> tx_done_t200
#endif

#if DL_U_FRAME == ON
#	define U_frame_flag			p_dlcep -> u_frame_flag
#	define Si_empty_flag		p_dlcep -> si_empty_flag
#endif

#define Frmr_pf					p_dlcep -> frmr_pf

#if DL_RELAY == ON
#	define R_lc_state			p_dlcep -> lc_state
#	define R_p_dlna				p_dlcep -> p_dlna
#	define R_p_dlchan			p_dlcep -> p_dlchan
#	define R_p_dlsap			p_dlcep -> p_dlsap
#	define R_p_dlcep			p_dlcep -> p_dlcep
#	define R_first				p_dlcep -> r_queue.p_first
#	define R_last				p_dlcep -> r_queue.p_last
#endif

#if DL_MLP == ON
#	define Slp_nai				p_dlcep -> slp_nai
#	define Slp_sapi				p_dlcep -> slp_sapi
#	define Slp_ces				p_dlcep -> slp_ces
#	define Slp_p_mlpna			p_dlcep -> p_mlpna
#	define Slp_p_mlpcep			p_dlcep -> p_mlpcep
#endif

		/* Statisitics */

#if DL_STATISTICS == ON
#	define Tx_byte				p_dlcep -> 	tx_byte
#	define Tx_i_frame			p_dlcep -> 	tx_i_frame
#	define Tx_rr_frame			p_dlcep -> 	tx_rr_frame
#	define Tx_rnr_frame			p_dlcep -> 	tx_rnr_frame
#	define Tx_rej_frame			p_dlcep -> 	tx_rej_frame

#	define Rx_byte				p_dlcep -> 	rx_byte
#	define Rx_bad_frame			p_dlcep -> 	rx_bad_frame
#	define Rx_i_frame			p_dlcep -> 	rx_i_frame
#	define Rx_rr_frame			p_dlcep -> 	rx_rr_frame
#	define Rx_rnr_frame			p_dlcep -> 	rx_rnr_frame
#	define Rx_rej_frame			p_dlcep -> 	rx_rej_frame
#endif

			/* Entity control flow state */

#define FREE					'F'				/* free entity */
#define BUSY					'B'				/* busy entity */

/*-------------------------------------------------------------------------*/

#if DL_IDENTIFICATION == ON /* { */

						/* DL IDENTIFICATION PROFILE */

	struct dl_ident_profile {
		uchar	id [DL_ID_SIZE];		/* Identity string */
		uchar	sig[DL_SIG_SIZE];		/* signature string */
	};

#	define Dl_ident_profile_a_id(xx)	&(p_dl_ident_profile [xx-1].id [0])
#	define Dl_ident_profile_a_sig(xx)	&(p_dl_ident_profile [xx-1].sig[0])

	extern struct dl_ident_profile FAR *p_dl_ident_profile;
	extern uchar						dl_ident_profile_nb;

#endif /* DL_IDENTIFICATION == ON } */

/*-------------------------------------------------------------------------*/

					/* DL ERROR MANAGEMENT */

#	define Send_to_mdl_err(error_code)		dl_send_to_mdl_error (error_code)

#if DL_EXTRA_ERROR_REPORTING == ON
#	define Mdl_error_report(error_code)		dl_send_to_mdl_report (REPORT_TYPE_ERROR, error_code)
#else
#	define Mdl_error_report(error_code)
#endif

/*-------------------------------------------------------------------------*/

#endif /* (ENTITY == DL_D) || (ENTITY == DL_B) || (ENTITY == DL_F) } */

/*-------------------------------------------------------------------------*/

#if ENTITY == MDL /* { */

				/* MDL : TIMER MANAGEMENT */

#define Start_timer_t201()		Timer_start (Ti_id_t201, Ti_val_t201, ++(Ti_sn_t201), TI_201); Ti_state_t201 = ON
#define Start_timer_t202()		Timer_start (Ti_id_t202, Ti_val_t202, ++(Ti_sn_t202), TI_202); Ti_state_t202 = ON
#define Start_timer_t204()		Timer_start (Ti_id_t204, Ti_val_t204, ++(Ti_sn_t204), TI_204); Ti_state_t204 = ON
#define Start_timer_t205()		Timer_start (Ti_id_t205, Ti_val_t205, ++(Ti_sn_t205), TI_205); Ti_state_t205 = ON

#define Stop_timer_t201()   	Timer_stop (Ti_id_t201); Ti_state_t201 = OFF
#define Stop_timer_t202()   	Timer_stop (Ti_id_t202); Ti_state_t202 = OFF
#define Stop_timer_t204()   	Timer_stop (Ti_id_t204); Ti_state_t204 = OFF
#define Stop_timer_t205()   	Timer_stop (Ti_id_t205); Ti_state_t205 = OFF

#define Valid_time_out_t201() 	((Ti_state_t201 == ON) && (R_msg_inf0 == Ti_sn_t201))
#define Valid_time_out_t202() 	((Ti_state_t202 == ON) && (R_msg_inf0 == Ti_sn_t202))
#define Valid_time_out_t204() 	((Ti_state_t204 == ON) && (R_msg_inf0 == Ti_sn_t204))
#define Valid_time_out_t205() 	((Ti_state_t205 == ON) && (R_msg_inf0 == Ti_sn_t205))

/*-------------------------------------------------------------------------*/

				/* MDL NA QUEUE STATE */

#define TAP_AWAITING_RS			'W'				/* awaiting response state */
#define TAP_FREE				'F'				/* not awaiting state */

/*-------------------------------------------------------------------------*/

					/* MDL OPTION FLAG */

#define	Mdl_att_ni			mdl_att_ni			/* AT&T and NI access to option flag */
	extern uchar			mdl_att_ni;			/* AT&T and NI option flag */

/*-------------------------------------------------------------------------*/

				/* MDL : NETWORK ACCESS DESCRIPTION */

				/* CES structure located in NA */

struct mdlces	{

#	if (DL_LAP4K  == OFF) && (DL_LAPF == OFF)

		uchar	tei;					/* TEI affected to the CES */
		uchar	tei_non_automatic;		/* non_automatic TEI value or DL_TEI_NIL */

#	else

#		if (DL_LAPF == ON) && ((DL_LAPF_ADD_FF_3 == ON) || (DL_LAPF_ADD_FF_4 == ON))
			ulong	tei;				/* TEI or DLCI affected to the CES */
			ulong	tei_non_automatic;	/* non_automatic TEI or DLCI value or DL_DLCI_NIL */

#		else

			ushort	tei;				/* TEI or DLCI affected to the CES */
			ushort	tei_non_automatic;	/* non_automatic TEI or DLCI value or DL_DLCI_NIL */
#		endif

#	endif

	uchar 	state;						/* TAP state machine state: TAP_FREE, TAP_AWAITING_RS */
	uchar 	rc;							/* retry counter */
	struct 	timer timer_t202[1];		/* timer T202 user side */
	struct 	queue_mgt qu_mdl[MX_QUEUE_MDL];	/* waiting queue to TAP and L3 */
	struct 	timer timer_t201[1];		/* timer T201 L3 timer */


	uchar	rq_to;						/* layer 3 entity requesting the service */
	uchar	rq_action;					/* action in progress: TAP_NIL, TAP_ID_RQ, TAP_ID_CHK_RQ, TAP_ID_VERIFY, TAP_LAP4K_ID_RQ */
	uchar	rq_ai;						/* ai of the action in progess if usefull */
	ulong	rq_ri;						/* random number of the awaiting response */
	sapi_t	rq_sapi;					/* sapi for the current request */

#	if (DL_LAPF == ON) && ((DL_LAPF_ADD_FF_3 == ON) || (DL_LAPF_ADD_FF_4 == ON))
		ulong	rq_dlci;				/* DLCI for the current request */

#	else

		ushort	rq_dlci;				/* DLCI for the current request */
#	endif

#	if EQUIPMENT == NT2
		ushort	tei_id_rs;				/* TEI ID response to a check request */
		ushort	tei_id_rs_count;		/* response counter to a check request */
#	endif

};

#if DL_PH_MUX == ON /* { */

				/* MDL : Physical multiplex description */

	struct mdlmux {
		nai_t	linked_na [DL_MX_NA_PER_MUX];
	};


#	define Mdl_mux_nai(xx)			p_mdlmux -> linked_na [xx]
#	define Mdl_mux_size				Rnd_sizeof (struct mdlmux)

#endif /* DL_PH_MUX == ON } */


			/* NA structure */

struct mdlna {
	uchar			FAR *p_mem_blk;		/* memory block allocated to the NA */
	nai_t 			nai;				/* network access identifier */
	uchar 			active;				/* access status : set (ON) or stop (OFF) */
	uchar 			ph_connect_state;	/* PH connect state : ON or OFF */
	uchar 			ph_active_state;	/* PH active state  : ON or OFF */
	uchar 			type;				/* access type = BRI, PRI SCI */
	uchar			fct;				/* functional grouping */
	sapi_t 			sap_nb;				/* number of sap */
	uchar 			modulo;				/* network access modulo */
	ent_id_t 		dl_entity_id;		/* DL entity Id */
	uchar			att_ni_flag;		/* AT&T and NI flag */

#	if (DL_LAP4K  == ON) || (DL_LAPF == ON)

#		if (DL_LAPF == ON) && ((DL_LAPF_ADD_FF_3 == ON) || (DL_LAPF_ADD_FF_4 == ON))
			ulong	in_sapi;			/* SAPI */
			ulong	in_dlci;			/* DLCI */

#		else

			ushort	in_sapi;			/* SAPI */
			ushort	in_dlci;			/* DLCI */
#		endif

#	endif

#	if DL_LAP4K == ON
		timer_val_t	t201;				/* parameter : timer values t201 */
#	endif

	timer_val_t		t202;				/* parameter : timer values t202 */
	ushort			n20X;				/* parameter : maximum of retransmission  for TAP (N202 or N203) */
	uchar 			nb_b_channel;		/* number of B channel allowed */
	uchar			ces_tei_nb;			/* number of CES and TEI used in the Network Access */
	ulong 			err_count;			/* total error count */
	ushort  		err_dl [DL_ERR_TYPE_NB];	/* DL error count by type of error */
	ushort  		err_mdl[MDL_ERR_TYPE_NB];	/* MDL error count by type of error */
	ulong 			err_count_int;		/* interval timer error count */

	ushort			tei_time_assignment;/* TEI time assignment */
	ushort			tei_time_removal;	/* TEI time removal */

#	if MC_TEST_PROCEDURE == ON || MC_DEFAULT_PARAMETER == OFF
		timer_val_t	t204;				/* parameter : timer values t204 */
		ushort		n204;				/* xid retransmission counter value (N204) */
#	endif

#	if MC_TEST_PROCEDURE == ON
		timer_val_t	t205;				/* parameter : timer values t205 */
		struct timer timer_t205[1];		/* timer T205 user side */
#	endif

#	if EQUIPMENT == NT2
		uchar		tei_base;			/* TEI base for TEI assignment */
		timer_val_t	t201;				/* parameter : timer values t201 */
		struct timer timer_t201[1];		/* timer T201 network side */
#	endif

#	if DL_PH_MUX
		nai_t		ph_nai;				/* physical NAI */
#	endif

#	if (DL_LAPF == ON) || (DL_LAP4K == ON)
		ushort		vc_to_first_mdlces [33];
#	endif

#	if DL_PH_MUX == ON
		struct mdlmux	FAR *p_mdlmux;	/* MDL multiplexer pointer */
#	endif


	struct mdlces 	mdlces[1];			/* CES data structure table */
};

			/* Access to curent NA using p_mdlna pointer  */

#define P_mem_blk				p_mdlna -> p_mem_blk
#define Nai 					p_mdlna -> nai
#define Na_active				p_mdlna -> active
#define Na_type					p_mdlna -> type
#define Na_ph_connect_state		p_mdlna -> ph_connect_state
#define Na_ph_active_state		p_mdlna -> ph_active_state
#define Na_fct					p_mdlna -> fct
#define Na_att_ni_flag			p_mdlna -> att_ni_flag
#define Na_a_mdlmux				p_mdlna -> p_mdlmux
#define Sap_nb					p_mdlna -> sap_nb
#define Modulo 					p_mdlna -> modulo
#define Na_dl_entity_id 		p_mdlna -> dl_entity_id
#define Ti_val_t201				p_mdlna -> t201
#define Ti_val_t202				p_mdlna -> t202
#define N202					p_mdlna -> n20X
#define N203					p_mdlna -> n20X
#define Err_count				p_mdlna -> err_count
#define Dl_err_type(xx)			p_mdlna -> err_dl[xx]
#define Mdl_err_type(xx)		p_mdlna -> err_mdl[xx]
#define Err_count_int			p_mdlna -> err_count_int
#define Na_tei_time_assignment	p_mdlna -> tei_time_assignment
#define Na_tei_time_removal		p_mdlna -> tei_time_removal

#if (MC_TEST_PROCEDURE == ON) || (MC_DEFAULT_PARAMETER == OFF)
#	define Ti_val_t204			p_mdlna -> t204
#	define N204					p_mdlna -> n204
#endif

#if MC_TEST_PROCEDURE == ON
#	define Ti_val_t205			p_mdlna -> t205
#	define Ti_state_t205		p_mdlna -> timer_t205[0].state
#	define Ti_sn_t205			p_mdlna -> timer_t205[0].sn
#	define Ti_id_t205			p_mdlna -> timer_t205[0].id
#endif

#if EQUIPMENT == NT2
#	define Ti_val_t201			p_mdlna -> t201
#	define Ti_state_t201		p_mdlna -> timer_t201[0].state
#	define Ti_sn_t201			p_mdlna -> timer_t201[0].sn
#	define Ti_id_t201			p_mdlna -> timer_t201[0].id
#	define Tei_base				p_mdlna -> tei_base
#endif

#if DL_PH_MUX
#	define Ph_nai				p_mdlna -> ph_nai
#endif

#if (DL_LAPF == ON) || (DL_LAP4K == ON)
#	define In_dlci						p_mdlna -> in_dlci
#	define In_sapi						p_mdlna -> in_sapi
#	define Vc_to_first_mdlces(vc_id) 	p_mdlna -> vc_to_first_mdlces [vc_id]
#	define Tei_nb						(Vc_to_first_mdlces (vc_id + 1) - Vc_to_first_mdlces (vc_id))
#	define Ces_nb						(Vc_to_first_mdlces (vc_id + 1) - Vc_to_first_mdlces (vc_id))
#	define Ces_d_nb						p_mdlna -> ces_tei_nb
#	define First_mdlces					first_mdlces

#else

#	define Vc_nb_dlci(vc_id) 			Ces_nb
#	define Vc_to_first_mdlces(vc_id)
#	define Tei_nb						p_mdlna -> ces_tei_nb
#	define Ces_nb						p_mdlna -> ces_tei_nb
#	define Ces_d_nb						Ces_nb
#	define First_mdlces                 0
#endif

			/* By CES */

#if (DL_LAP4K  == OFF) && (DL_LAPF == OFF)
#	define Tap_tei					p_mdlna -> mdlces[ces].tei
#	define Tap_tei_non_automatic	p_mdlna -> mdlces[ces].tei_non_automatic
#	define Tap_tei_x(x)				p_mdlna -> mdlces[x].tei

#else

#	define Tap_tei					p_mdlna -> mdlces[ces + First_mdlces].tei
#	define Tap_tei_non_automatic	p_mdlna -> mdlces[ces + First_mdlces].tei_non_automatic
#	define Tap_tei_x(x)				p_mdlna -> mdlces[x   + First_mdlces].tei
#	define Tap_dlci					p_mdlna -> mdlces[ces + First_mdlces].tei
#	define Tap_dlci_non_automatic	p_mdlna -> mdlces[ces + First_mdlces].tei_non_automatic
#	define Tap_dlci_x(x)			p_mdlna -> mdlces[x   + First_mdlces].tei
#	define Ti_state_t201			p_mdlna -> mdlces[ces + First_mdlces].timer_t201[0].state
#	define Ti_sn_t201				p_mdlna -> mdlces[ces + First_mdlces].timer_t201[0].sn
#	define Ti_id_t201				p_mdlna -> mdlces[ces + First_mdlces].timer_t201[0].id

#endif

#define State						p_mdlna -> mdlces[ces + First_mdlces].state
#define Rc							p_mdlna -> mdlces[ces + First_mdlces].rc
#define First(xx)					p_mdlna -> mdlces[ces + First_mdlces].qu_mdl[xx].p_first
#define Last(xx)					p_mdlna -> mdlces[ces + First_mdlces].qu_mdl[xx].p_last
#define Ti_state_t202				p_mdlna -> mdlces[ces + First_mdlces].timer_t202[0].state
#define Ti_sn_t202					p_mdlna -> mdlces[ces + First_mdlces].timer_t202[0].sn
#define Ti_id_t202					p_mdlna -> mdlces[ces + First_mdlces].timer_t202[0].id
#define Rq_to						p_mdlna -> mdlces[ces + First_mdlces].rq_to
#define Rq_action					p_mdlna -> mdlces[ces + First_mdlces].rq_action
#define Rq_sapi						p_mdlna -> mdlces[ces + First_mdlces].rq_sapi
#define Rq_ces						p_mdlna -> mdlces[ces + First_mdlces].rq_ces
#define Rq_dlci						p_mdlna -> mdlces[ces + First_mdlces].rq_dlci
#define Rq_ai						p_mdlna -> mdlces[ces + First_mdlces].rq_ai
#define Rq_ri						p_mdlna -> mdlces[ces + First_mdlces].rq_ri

#if EQUIPMENT == NT2
#	define Tei_id_rs				p_mdlna -> mdlces[ces + First_mdlces].tei_id_rs
#	define Tei_id_rs_x(x)			p_mdlna -> mdlces[x   + First_mdlces].tei_id_rs
#	define Tei_id_rs_count			p_mdlna -> mdlces[ces + First_mdlces].tei_id_rs_count
#	define Tei_id_rs_count_x(x)		p_mdlna -> mdlces[x   + First_mdlces].tei_id_rs_count
#endif

				/* Management Connection state codes */

#define MC_IDLE					 0	/* idle state */
#define MC_AWAITING_CONFIRM		 1	/* awaiting confirm */

/*-------------------------------------------------------------------------*/

				/*  MDL : SERVICE ACCESS POINT MANAGEMENT */

struct mdlsap {
	sapi_t 		sapi;					/* service access point identifier */
	ces_t 		dlcep_nb; 	    		/* number of dlcep */
	uchar 		dl_entity_id;			/* DL entity identifier (ENT_DL_D, ENT_DL_B, ENT_DL_V120, ENT_DL_4K) */
	ushort		n201_tx;				/* N201 configuration value of transmitter */
	ushort		n201_rx;				/* N201 configuration value of receiver */
	uchar		k_tx;					/* configuration window size (transmit) */
	timer_val_t	t200;					/* configuration retransmission timer value */

#	if (DL_LAPF == ON) || (DL_LAP4K == ON)
		uchar	vc_id;					/* Virtual channel ID */
#	endif

};

					/* Access to current SAP values using p_mdlsap pointer */

#define Sapi 				p_mdlsap -> sapi
#define Dlcep_nb			p_mdlsap -> dlcep_nb
#define Dl_entity_id		p_mdlsap -> dl_entity_id
#define N201_tx_cfg			p_mdlsap -> n201_tx
#define N201_rx_cfg			p_mdlsap -> n201_rx
#define K_tx_cfg			p_mdlsap -> k_tx
#define T200_cfg			p_mdlsap -> t200

#if (DL_LAPF == ON) || (DL_LAP4K == ON)
#	define Vc_id			p_mdlsap -> vc_id
#endif

/*-------------------------------------------------------------------------*/

		/*  MDL CONNECTION MANAGEMENT : DATA LINK CONNECTION END POINT */

struct mdlcep {
	ces_t		ces;					/* connection endpoint suffix */
	uchar		mc_state;				/* management connection state */

#	if MC_TEST_PROCEDURE == ON || MC_DEFAULT_PARAMETER == OFF
		uchar	mark_param;				/* mark XID param frame sent */
		uchar	mark_test;				/* mark XID test frame sent */
		uchar	rc_xid;					/* XID retransmission counter */
		struct 	timer timer_t204[1];	/* timer T204 network side */
#	endif

	ushort		n201_tx;				/* N201 configuration value of transmitter */
	ushort		n201_rx;				/* N201 configuration value of receiver */
	uchar		k_tx;					/* configuration window size (transmit) */
	timer_val_t	t200;					/* configuration retransmission timer value */
	ent_id_t 	l3_entity_id;			/* upper layer entity ID */
};

			/* Access to current CES values using p_mdlcep pointer */

#define Ces 				p_mdlcep -> ces

#define Mc_state			p_mdlcep -> mc_state
#define Mark_param			p_mdlcep -> mark_param
#define Mark_test			p_mdlcep -> mark_test
#define Rc_xid				p_mdlcep -> rc_xid
#define N201_xid			p_mdlcep -> n201_tx

#define Ti_state_t204		p_mdlcep -> timer_t204[0].state
#define Ti_sn_t204			p_mdlcep -> timer_t204[0].sn
#define Ti_id_t204			p_mdlcep -> timer_t204[0].id

#define N201_tx				p_mdlcep -> n201_tx
#define N201_rx				p_mdlcep -> n201_rx
#define K_tx				p_mdlcep -> k_tx
#define T200				p_mdlcep -> t200

#define L3_entity_id		p_mdlcep -> l3_entity_id

/*--------------------------------------------------------------------------*/

					/* MDL ERROR MANAGEMENT */

#if DL_EXTRA_ERROR_REPORTING == ON
#	define Mdl_error_report(error_code)		mdl_error_report (error_code)
#else
#	define Mdl_error_report(error_code)
#endif

/*-------------------------------------------------------------------------*/

#endif /* ENTITY == MDL } */

/*-------------------------------------------------------------------------*/

							/* XID MANAGEMENT */

#include "xid_int.h"

#define XID_FI_CCITT								G_8 (1, 0, 0, 0, 0, 0, 1, 0)    /* CCITT Format Identifier */

			/* ------------------- IDENTIFICATION ----------------------- */

#if DL_IDENTIFICATION == ON /* { */

			/* Identification protocol element and X.32 facility codes */

#	define XID_GI_USER_DATA							G_8 (1,1,1,1, 1,1,1,1)	/* user data  */

#	define XID_PI_IDENTITY							G_8 (1,1,0,0, 1,1,0,0)	/* ID identity element Parameter Identifier */
#	define XID_PI_SIGNATURE							G_8 (1,1,0,0, 1,1,0,1)	/* ID signature element Parameter Identifier */
#	define XID_PI_DIAGNOSTIC						G_8 (0,0,0,0, 0,1,1,1)	/* ID diagnostic element Parameter Identifier */
#	define XID_PI_RANDOM							G_8 (1,1,0,0, 1,1,1,0)	/* ID random number element Parameter Identifier */
#	define XID_PI_SIGNED							G_8 (1,1,0,0, 1,1,1,1)	/* ID signed response element Parameter Identifier */
#	define XID_PI_LOCATION							G_8 (1,1,0,1, 0,0,0,0)	/* ID temporary location element Parameter Identifier */

			/* Diagnostic coding field */

#	define DL_ID_DIAG_NIL							G_8 (0,0,0,0, 0,0,0,0)	/* no diagnostic element */
#	define DL_ID_DIAG_CONFIRMED						G_8 (0,1,1,1, 1,1,1,1)	/* Identification/authentification confirmed */
#	define DL_ID_DIAG_FAILED						G_8 (1,0,0,0, 0,0,0,0)	/* Identification/authentification failed */

#	define DL_ID_DIAG_FAILED_INCONSISTENCY			G_8 (1,0,0,0, 0,0,0,1)	/* Identification/authentification failed : inconsistency */
#	define DL_ID_DIAG_FAILED_ID_TOO_NEW				G_8 (1,0,0,0, 0,0,1,0)	/* Identification/authentification failed : ID too new */
#	define DL_ID_DIAG_FAILED_ID_OLD					G_8 (1,0,0,0, 0,0,1,1)	/* Identification/authentification failed : ID old */
#	define DL_ID_DIAG_FAILED_ID_NOT_ALLOWED			G_8 (1,0,0,0, 0,1,0,0)	/* Identification/authentification failed : ID not allowed */
#	define DL_ID_DIAG_FAILED_SERVICE_NOT_ACCEPTED 	G_8 (1,0,0,0, 0,1,0,1)	/* Identification/authentification failed : service not accepted */
#	define DL_ID_DIAG_FAILED_NUMBER_NOT_NOT_ALLOWED G_8 (1,0,0,0, 0,1,1,0)	/* Identification/authentification failed : number not allowed */
#	define DL_ID_DIAG_FAILED_BAD_ENCRIPTION_PROCESS G_8 (1,0,0,0, 0,1,1,1)	/* Identification/authentification failed : bad encription process */
#	define DL_ID_DIAG_FAILED_PROTOCOL_ERROR 		G_8 (1,0,0,0, 1,0,0,0)	/* Identification/authentification failed : protocol error */
#	define DL_ID_DIAG_FAILED_LAYER_2_NOT_VERIFY 	G_8 (1,0,0,0, 1,0,0,0)	/* Identification/authentification failed : layer 2 not verify */

#	define DL_ID_DIAG_NET_CONGESTION 				G_8 (0,0,0,0, 0,1,0,1)	/* network congestion */
#	define DL_ID_DIAG_IN_USE 						G_8 (0,0,0,1, 0,1,1,1)	/* network congestion */
#	define DL_ID_DIAG_DIAL_BACK						G_8 (0,0,1,1, 1,1,1,1)	/* network congestion */
#	define DL_ID_DIAG_CONGESTION_DIAL_BACK			G_8 (0,0,0,1, 1,0,1,1)	/* congestion for dial back */
#	define DL_ID_DIAG_DIAL_BACK_CONFIRMED			G_8 (0,0,0,1, 1,0,1,1)	/* dial back confirmed */

#endif /* DL_IDENTIFICATION == ON } */


			/* ---------------- PARAMETER AND TEST -------------------- */

#	define XID_DL_D_GI_PARAM  			G_8 (1, 0, 0, 0,  0, 0, 0, 0)
#	define XID_DL_D_GI_TEST				G_8 (1, 0, 0, 0,  0, 0, 0, 1)

#	define XID_DL_D_PI_N201_TX			G_8 (0, 0, 0, 0,  0, 1, 0, 1)
#	define XID_DL_D_PI_N201_RX			G_8 (0, 0, 0, 0,  0, 1, 1, 0)
#	define XID_DL_D_PI_K_TX				G_8 (0, 0, 0, 0,  0, 1, 1, 1)
#	define XID_DL_D_PI_T200				G_8 (0, 0, 0, 0,  1, 0, 0, 1)

	struct xid_param {
		uchar	group_flag;				/* group flag */

		uchar	n201_tx_flag;			/* N201_tx */
		ushort	n201_tx;

		uchar 	n201_rx_flag;			/* N201_rx */
		ushort	n201_rx;

		uchar	k_tx_flag;				/* K_tx */
		uchar	k_tx;

		uchar	t200_flag;				/* T200 */
		ulong	t200;
	};

			/* Access to the parameter data structure */

#define Xid_param_n201_tx			xid_param.n201_tx
#define Xid_param_n201_rx			xid_param.n201_rx
#define Xid_param_k_tx				xid_param.k_tx
#define Xid_param_t200				xid_param.t200

#define Xid_param_group_flag		xid_param.group_flag

#define Xid_param_n201_tx_flag		xid_param.n201_tx_flag
#define Xid_param_n201_rx_flag		xid_param.n201_rx_flag
#define Xid_param_k_tx_flag			xid_param.k_tx_flag
#define Xid_param_t200_flag			xid_param.t200_flag

			/* XID T200 timer value convertion */

#define Xid_convert_t200_from_local(val)	(val / XID_TIMER_UNIT)
#define Xid_convert_t200_from_remote(val)	(val * XID_TIMER_UNIT)

#define XID_TEST_SIZE				(N201_I - XID_TEST_I_HEADER_SIZE) /* size of the test pattern array */

/*-------------------------------------------------------------------------*/

				/* OBJECT ACCESS MANAGEMENT */

#define TYPE_NA				'N'			/* access to NA only */
#define TYPE_SAP			'S'			/* access to NA, SAP only */
#define TYPE_TEI 			'T'			/* access to DLCEP using NA, SAP, TEI */
#define TYPE_CES			'C'			/* access to DLCEP using NA, SAP, CES */
#define TYPE_CHANNEL 		'H'			/* access to DLCEP using NA, SAP, CHANI */
#define TYPE_DLCI_V120 		'2'			/* access to DLCEP using NA, SAP, DLCI and CHANI */
#define TYPE_DLCI_LAPF 		'F'			/* access to DLCEP using NA, SAP, DLCI and CHANI */
#define TYPE_DLCI_LAP4K		'4'			/* access to DLCEP using NA, SAP, DLCI */

/*-------------------------------------------------------------------------*/

				/* DL RELAY */

			/*  Link Connection state wiew from layer 3 */

#define LC_ESTABLISHED			'E'					/* link connection established */
#define LC_RELEASED				'R'					/* link connection released */
#define LC_AWAITING_EST			'W'					/* link connection awaiting estabish */
#define LC_AWAITING_REL			'w'					/* link connection awaiting release */

			/* Trap codes */

#define TRAP_LC_INCONSISTENCY	280					/* Inconsistency state and event */
#define TRAP_DL_CODE			281					/* Unknown primitive code */

/*-------------------------------------------------------------------------*/

					/* DATA LINK FUNCTIONS DECLARATIONS */

#if NEW_FCT_STYLE == ON /* { */

#	if DL_MLP == ON
		uchar	mlp 							(struct message FAR *p_msg);
#	endif

		/* Main functions : OSI entities */

	uchar 	dl_config							(struct dl_config FAR *p_dl_config);
	uchar 	dl_reset_config						(nai_t nai);
	void	dl_process							(void);
	uchar	dl_process_act_dea_in				(void);
	uchar 	dl_test_na_chan_activation		 	(void);
	void	dl_init_with_configuration_param 	(void);
	void	dl_audit_in							(void);

	void 	dl_lapx_event_process				(void);
	uchar	dl_lapx_send						(void);

		/* Access functions */

	uchar 	dl_access_object					(nai_t nai, sapi_t sapi, uchar type, ulong val);
	uchar 	dl_access_na						(nai_t nai);
	uchar	dl_access_chan						(nai_t nai, add_t chani);
	void	dl_access_first_dlsap				(void);
	void	dl_access_next_dlsap				(void);
	void	dl_access_first_na					(void);
	void	dl_access_next_na					(void);
	void	dl_access_first_dlcep				(void);
	void	dl_access_next_dlcep				(void);
	uchar	dl_build_object 					(struct dl_config FAR *p_dl_config);

		/* Miscellaneous DL functions */

	uchar 	e_unnumb							(void);
	uchar 	e_fr_err							(void);
	void 	error_recovery						(void);
	void 	establish_dl						(void);
	void 	establish_u_dl						(void);
	void 	clear_exception_conditions			(void);
	void 	transmit_enquiry					(void);
	void 	enquiry_response					(void);
	void 	invoke_retransmission				(void);
	void 	stop_transmission 					(void);
	void 	unexpected_ev						(void);
	void 	u_unexpected_ev						(void);
	uchar	able_to_establish					(void);
	void	invalid_nr							(void);
	uchar	xid_process 						(void);
	void	xid_save_tei						(void);
	void	xid_remove_tei						(void);
	uchar	dl_slp_attach_detach				(struct message FAR *p_msg, uchar confirm_flag);
	void	dl_mlp_attach_detach				(struct message FAR *p_msg);

	void 	dl_start_timer 						(uchar timer_x);
	void 	dl_start_timer_t203					(void);
	void 	dl_start_timer_t200_tx_done			(void);
	void 	dl_stop_timer 						(uchar timer_x);
	void 	dl_stop_timer_t203					(void);
	void 	dl_stop_timer_t200_tx_done 			(void);
	void 	dl_restart_timer 					(uchar timer_x);
	void 	dl_restart_timer_t203				(void);
	void 	dl_restart_timer_t200_tx_done		(void);

		/* State functions */

	void 	switch_state						(void);
	void 	s_tei_unassigned					(void);
	void 	s_assign_awaiting_tei				(void);
	void 	s_establish_awaiting_tei			(void);
	void	s_awaiting_ph_connection			(void);
	void 	s_tei_assigned						(void);
	void 	s_awaiting_establishment			(void);
	void 	s_awaiting_release					(void);
	void 	s_mfo								(void);
	void 	s_timer_recovery					(void);
	void	s_frame_reject						(void);
	void	broadcast							(void);

		/* State functions */

	void 	s_u_establish_awaiting_tei			(void);
	void 	s_u_awaiting_establishment			(void);
	void 	s_u_sfo								(void);

		/* Queue management functions */

	void 	dl_in_queue_incoming_rq_co			(void);
	uchar 	dl_out_queue_incoming_rq_co			(void);
	void 	dl_discard_queue_incoming_rq_co		(void);
	void 	in_queue							(uchar qu_x);
	uchar	out_queue							(uchar qu_x);
	void 	discard_queue						(uchar qu_x);
	void 	get_next_i_queue_entry				(void);
	void 	set_acknowledged					(void);
	void	reset_unacknowledged				(void);
	void	get_last_transmitted_i_frame 		(void);
	void	dl_queue_check						(uchar qu_x);

	void 	dl_in_queue 						(void);
	struct message FAR *dl_out_queue			(void);

	void 	dlx_in_fifo							(void);
	uchar	dlx_out_fifo						(void);
	void 	dlx_discard_fifo					(void);
	uchar 	dlx_selective_discard_fifo			(struct message FAR *p_msg);

		/* Receive functions */

	uchar 	dl_rcv								(void);

		/* Pack functions */

	void 	p_b_8								(void);
	void 	p_b_128								(void);
	void 	p_d_8								(void);
	void 	p_d_128								(void);
	void	p_f_2								(void);
	void	p_f_3								(void);
	void	p_f_4								(void);

	uchar	i_size_b_8							(void);
	uchar	i_size_b_128						(void);
	uchar	i_size_d_8							(void);
	uchar	i_size_d_128						(void);
	uchar	i_size_f_2							(void);
	uchar	i_size_f_3							(void);
	uchar	i_size_f_4							(void);

		/* Unpack functions */

	uchar	up_b_8								(void);
	uchar	up_b_128							(void);
	uchar	up_d_8								(void);
	uchar	up_d_128							(void);
	uchar	up_f_2								(void);
	uchar	up_f_3								(void);
	uchar	up_f_4								(void);

		/* Send functions */

	void 	dl_snd								(uchar to, uchar msg_id);
	void 	send_frame							(uchar frame_id, uchar pf_val);
	void	dl_retransmit						(code_t code , ent_id_t to);
	void	dl_send_to_mdl_error				(uchar error_code);
	void	dl_send_to_mdl_report 				(uchar error_type, uchar error_code);
	void 	dl_send_to_mdl_info 				(void);

		/* Set frame header functions */

	void 	set_s_frame 						(uchar cr_val, uchar command_val, uchar pf_val);
	void 	set_u_frame 						(uchar cr_val, uchar command_val, uchar pf_val);

		/* PH MUX fonction */

#	if DL_PH_MUX == ON

#		if ENTITY == DL_D
			void dl_ph_mux 						(struct dlmux	FAR *p_dlmux);
#		endif

#	endif

#	if DL_RELAY == ON
		void dl_relay_rcv 						(struct message FAR *p_msg);
#	endif


		/* Simulation functions */

#	if DL_SIM_ANALYSER == ON
		void 	pr_dl_object					(void);
		void	pr_dlcep						(void);
		void	pr_dl_state						(void);
		void	pr_tei_msg						(uchar FAR *p_tap, ushort data_lgth);
#	endif

#	if DL_SIM_BUILDER == ON
		ushort 	build_pdu_frame					(void);
		ushort	build_pdu_asp					(uchar FAR *p_data);
		ushort	build_pdu_asp_lap4k				(uchar FAR *p_data);
		ushort	build_i_pdu_ns					(uchar FAR *p_data);
		ushort	build_i_pdu_ns_2				(uchar FAR *p_data);
		ushort	build_ui_pdu_ns					(uchar FAR *p_data);
		ushort	build_ui_pdu_ns_2				(uchar FAR *p_data);
#	endif

#	if DL_IDENTIFICATION == ON
		void	dl_build_xid_ident_element		(void);
		uchar	dl_get_xid_ident_diagnostic		(void);
		uchar 	dl_identification 				(void);
#	endif

#	if (DL_V120 == ON) && (DL_V120_XID_NEGOTIATION == ON)
		uchar 	v120_process_negotiation_events (void);
#	endif

#	if OM_CODE_TYPE == OM_PIC	/* specific functions used only for PIC */
		void pic_init_dl (void);
#	endif

#endif /* } */

#if NEW_FCT_STYLE == OFF /* { */

#	if DL_MLP == ON
		uchar	mlp 							();
#	endif

		/* Main functions : OSI entities */

	uchar 	dl_config							();
	uchar 	dl_reset_config						();
	void	dl_process							();
	uchar	dl_process_act_dea_in				();
	uchar 	dl_test_na_chan_activation		 	();
	void	dl_init_with_configuration_param 	();
	void	dl_audit_in							();

	void 	dl_lapx_event_process				();
	uchar	dl_lapx_send						();

		/* Access functions */

	uchar 	dl_access_object					();
	uchar 	dl_access_na						();
	uchar	dl_access_chan						();
	void	dl_access_first_dlsap				();
	void	dl_access_next_dlsap				();
	void	dl_access_first_na					();
	void	dl_access_next_na					();
	void	dl_access_first_dlcep				();
	void	dl_access_next_dlcep				();
	uchar	dl_build_object 					();

		/* Miscellaneous DL functions */

	uchar 	e_unnumb							();
	uchar 	e_fr_err							();
	void 	error_recovery						();
	void 	establish_dl						();
	void 	establish_u_dl						();
	void 	clear_exception_conditions			();
	void 	transmit_enquiry					();
	void 	enquiry_response					();
	void 	invoke_retransmission				();
	void 	stop_transmission 					();
	void 	unexpected_ev						();
	void 	u_unexpected_ev						();
	uchar	able_to_establish					();
	void	invalid_nr							();
	uchar	xid_process 						();
	void	xid_save_tei						();
	void	xid_remove_tei						();
	uchar	dl_slp_attach_detach				();
	void	dl_mlp_attach_detach				();

	void 	dl_start_timer 						();
	void 	dl_start_timer_t203					();
	void 	dl_start_timer_t200_tx_done			();
	void 	dl_stop_timer 						();
	void 	dl_stop_timer_t203					();
	void 	dl_stop_timer_t200_tx_done 			();
	void 	dl_restart_timer 					();
	void 	dl_restart_timer_t203				();
	void 	dl_restart_timer_t200_tx_done		();

		/* State functions */

	void 	switch_state						();
	void 	s_tei_unassigned					();
	void 	s_assign_awaiting_tei				();
	void 	s_establish_awaiting_tei			();
	void	s_awaiting_ph_connection			();
	void 	s_tei_assigned						();
	void 	s_awaiting_establishment			();
	void 	s_awaiting_release					();
	void 	s_mfo								();
	void 	s_timer_recovery					();
	void	s_frame_reject						();
	void	broadcast							();

		/* State functions */

	void 	s_u_establish_awaiting_tei			();
	void 	s_u_awaiting_establishment			();
	void 	s_u_sfo								();

		/* Queue management functions */

	void 	dl_in_queue_incoming_rq_co			();
	uchar 	dl_out_queue_incoming_rq_co			();
	void 	dl_discard_queue_incoming_rq_co		();
	void 	in_queue							();
	uchar	out_queue							();
	void 	discard_queue						();
	void 	get_next_i_queue_entry				();
	void 	set_acknowledged					();
	void	reset_unacknowledged				();
	void	get_last_transmitted_i_frame 		();
	void	dl_queue_check						();

	void 	dl_in_queue 						();
	struct message FAR *dl_out_queue			();

	void 	dlx_in_fifo							();
	uchar	dlx_out_fifo						();
	void 	dlx_discard_fifo					();
	uchar 	dlx_selective_discard_fifo			();

		/* Receive functions */

	uchar 	dl_rcv								();

		/* Pack functions */

	void 	p_b_8								();
	void 	p_b_128								();
	void 	p_d_8								();
	void 	p_d_128								();
	void	p_f_2								();
	void	p_f_3								();
	void	p_f_4								();

	uchar	i_size_b_8							();
	uchar	i_size_b_128						();
	uchar	i_size_d_8							();
	uchar	i_size_d_128						();
	uchar	i_size_f_2							();
	uchar	i_size_f_3							();
	uchar	i_size_f_4							();

		/* Unpack functions */

	uchar	up_b_8								();
	uchar	up_b_128							();
	uchar	up_d_8								();
	uchar	up_d_128							();
	uchar	up_f_2								();
	uchar	up_f_3								();
	uchar	up_f_4								();

		/* Send functions */

	void 	dl_snd								();
	void 	send_frame							();
	void	dl_retransmit						();
	void	dl_send_to_mdl_error				();
	void	dl_send_to_mdl_report 				();
	void 	dl_send_to_mdl_info 				();

		/* Set frame header functions */

	void 	set_s_frame 						();
	void 	set_u_frame 						();

		/* PH MUX fonction */

#	if DL_PH_MUX == ON

#		if ENTITY == DL_D
			void dl_ph_mux 						();
#		endif

#	endif

#	if DL_RELAY == ON
		void dl_relay_rcv 						();
#	endif


		/* Simulation functions */

#	if DL_SIM_ANALYSER == ON
		void 	pr_dl_object					();
		void	pr_dlcep						();
		void	pr_dl_state						();
		void	pr_tei_msg						();
#	endif

#	if DL_SIM_BUILDER == ON
		ushort 	build_pdu_frame					();
		ushort	build_pdu_asp					();
		ushort	build_pdu_asp_lap4k				();
		ushort	build_i_pdu_ns					();
		ushort	build_i_pdu_ns_2				();
		ushort	build_ui_pdu_ns					();
		ushort	build_ui_pdu_ns_2				();
#	endif

#	if DL_IDENTIFICATION == ON
		void	dl_build_xid_ident_element		();
		uchar	dl_get_xid_ident_diagnostic		();
		uchar 	dl_identification 				();
#	endif

#	if (DL_V120 == ON) && (DL_V120_XID_NEGOTIATION == ON)
		uchar 	v120_process_negotiation_events ();
#	endif

#	if OM_CODE_TYPE == OM_PIC	/* specific functions used only for PIC */
		void pic_init_dl ();
#	endif

#endif /* } */

/*------------------------------------------------------------------*/

#if ENTITY == MDL /* { */

		/* MDL function declarations */

#	if NEW_FCT_STYLE == ON /* { */

		void	mdl_from_dl_user				(void);
		void	mdl_from_dl_net					(void);
		uchar 	mdl_config						(struct dl_config FAR *p_dl_config);
		uchar 	mdl_reset_config				(nai_t nai);

		void 	mdl_send_dl						(code_t prim_code, sapi_t sapi, ces_t ces, uchar info);
		void 	mdl_send_dl_conn				(code_t prim_code, sapi_t sapi, ces_t ces);

		void 	mdl_send_dl_data				(code_t prim_code);
		void	mdl_retransmit					(code_t code , ent_id_t to);

		void 	mdl_in_queue					(uchar queue_id);
		uchar 	mdl_out_queue					(uchar queue_id);
		void	mdl_discard_queue 				(uchar queue_id);

		uchar	mdl_access_na					(nai_t nai);
		uchar 	mdl_access_first_na				(void);
		uchar 	mdl_access_next_na				(void);
		uchar	mdl_access_sap					(sapi_t sapi);
		uchar	mdl_access_first_sap			(void);
		uchar	mdl_access_next_sap				(void);
		uchar	mdl_access_ces					(nai_t nai, sapi_t sapi, ces_t ces);
		uchar   FAR *mdl_alloc_data             (ushort size);

		uchar	mdl_build_object				(struct dl_config FAR *p_dl_config);
		void	mdl_reuse_received				(void);
		void	mdl_build_assign_from_current_and_send (ushort tei_val, sapi_t sapi_val, ces_t ces_val);

		void	mdl_set_p_tap					(void);
		uchar	mdl_tap_chk						(void);

		void 	mdl_lap4k_from_l3				(void);
		void 	mdl_lap4k						(void);
		uchar 	mdl_tap_lap4k_chk 				(void);
		uchar 	dlci_lap4k_local_rm 			(ushort dlci_to_remove);
		void	mdl_set_p_tap_lap4k 			(void);
		void	id_dlci_rq_tap					(void);
		void	id_dlci_rs_tap					(void);
		void	id_dlci_rq_l3					(sapi_t sapi, ces_t ces);
		void	id_dlci_rs_l3					(void);
		void	id_dlci_rm_l3					(void);
		void	id_dlci_ti_t201					(void);
		void	id_dlci_ti_t202					(void);
		void 	mdl_send_dlci_l3 				(ent_id_t to, code_t	code, nai_t	nai, sapi_t	sapi, add_t	ces, uchar ret_code, ushort	dlci);
		void	id_tei_rq						(sapi_t sapi, ces_t ces);
		void	id_tei_rs						(void);
		void	id_tei_ti						(void);
		void	mdl_assign_non_automatic_tei 	(void);
		void 	mdl_user_send_sm_dlci 			(void);

		void 	mdl_lapf_from_l3				(void);
		void 	mdl_lapf						(void);
		uchar 	dlci_lapf_local_rm 				(ushort dlci_to_remove);

		uchar	tei_local_rm					(ushort tei);
		void	tei_remote_rm					(ushort tei);

		uchar	select_tei						(void);

		void	start_id_chk					(ushort tei);
		void	id_chk_rq						(ushort tei);
		void	id_chk_rs						(void);
		void	id_chk_ti						(void);
		void	id_chk_in						(void);
		void	in_use_tei						(ushort tei);

		void 	id_verify_rq					(ushort tei);
		void	id_verify_ti					(void);

		void	id_rq							(void);

		void 	mdl_tei_time_assign 			(ushort event_mask);
		void 	mdl_tei_time_removal 			(ushort event_mask);

			/* Management Connection */

		void	mc_user							(void);
		void	mc_net							(void);
		void	mdl_from_mc_user				(void);
		void	mdl_from_mc_net					(void);

			/* MDL error reporting */

		void 	mdl_error_report				(char error_code);

			/* PH MUX */

#		if DL_PH_MUX == ON
			void mdl_ph_mux 					(struct mdlmux	FAR	*p_mdlmux);
#		endif

#	endif /* } */

#	if NEW_FCT_STYLE == OFF /* { */
		void	mdl_from_dl_user				();
		void	mdl_from_dl_net					();
		uchar 	mdl_config						();
		uchar 	mdl_reset_config				();
		void 	mdl_send_dl						();
		void 	mdl_send_dl_conn				();
		void 	mdl_send_dl_data				();
		void	mdl_retransmit					();
		void 	mdl_in_queue					();
		uchar 	mdl_out_queue					();
		void	mdl_discard_queue 				();
		uchar 	mdl_access_na					();
		uchar 	mdl_access_first_na				();
		uchar 	mdl_access_next_na				();
		uchar	mdl_access_sap					();
		uchar	mdl_access_first_sap			();
		uchar	mdl_access_next_sap				();
		uchar	mdl_access_ces					();
		uchar	mdl_build_object				();
		void	mdl_reuse_received				();
		void	mdl_build_assign_from_current_and_send ();
		uchar FAR *mdl_alloc_data               ();

		void	mdl_set_p_tap					();
		uchar	mdl_tap_chk						();

		void 	mdl_lap4k_from_l3				();
		void 	mdl_lap4k						();
		uchar 	mdl_tap_lap4k_chk 				();
		uchar 	dlci_lap4k_local_rm 			();
		void	mdl_set_p_tap_lap4k 			();
		void	id_dlci_rq_tap					();
		void	id_dlci_rs_tap					();
		void	id_dlci_rq_l3					();
		void	id_dlci_rs_l3					();
		void	id_dlci_rm_l3					();
		void	id_dlci_ti_t201					();
		void	id_dlci_ti_t202					();
		void 	mdl_send_dlci_l3 				();

		void	id_tei_rq						();
		void	id_tei_rs						();
		void	id_tei_ti						();
		void	mdl_assign_non_automatic_tei 	();
		void 	mdl_user_send_sm_dlci 			();

		void 	mdl_lapf_from_l3				();
		void 	mdl_lapf						();
		uchar 	dlci_lapf_local_rm 				();

		uchar	tei_local_rm					();
		void	tei_remote_rm					();

		uchar	select_tei						();

		void	start_id_chk					();
		void	id_chk_rq						();
		void	id_chk_rs						();
		void	id_chk_ti						();
		void	id_chk_in						();

		void	in_use_tei						();

		void 	id_verify_rq					();
		void	id_verify_ti					();

		void	id_rq							();

		void 	mdl_tei_time_assign 			();
		void 	mdl_tei_time_removal 			();

			/* Management Connection */

		void	mc_user				 			();
		void	mc_net				 			();
		void	mdl_from_mc_user   				();
		void	mdl_from_mc_net   				();

			/* MDL error reporting */

		void 	mdl_error_report				();

			/* PH MUX */

		void 	mdl_ph_mux 						();

#	endif /* } */


#endif /* ENTITY == MDL } */

/*-----------------------------------------------------------------------*/

#endif /* DL_H } */

/*EOF*/
