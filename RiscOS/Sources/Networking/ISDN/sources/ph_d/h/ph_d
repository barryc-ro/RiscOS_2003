
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ph_d.h
 *
 * $Revision$
 *
 * $Date$
 *
 * Implements the commmon declarations of the ISAC-S PH functions.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Siemens ISAC-S Driver                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef PH_D
#define PH_D

#include "services.h"                               /* OMNITEL-BRICKS services header */
#include "ph_d_int.h"                               /* PH upper interface */
#include "it.h"                                     /* interrupt routines communication interface */

/*--------------------------------------------------------------------------*/

					/* For compatibility with previous release */

#ifndef PH_D_WA_1
#	define PH_D_WA_1 		ON						/* Workaround 1 to avoid "Lost framing" event upon receipt of INFO_0 in F6 */
#endif

#ifndef PH_D_U
#	define PH_D_U			OFF
#endif

#if PH_D_U == ON
#	ifndef PH_D_WA_2
#		define PH_D_WA_2 	ON						/* Workaround 2 for IEC-Q V5.1: monitor receive handler related bug concerning MER interrupt */
#	endif
#	ifndef PH_D_WA_3
#		define PH_D_WA_3 	ON						/* Workaround 2 for IEC-Q V5.1: monitor receive handler related bug concerning MER interrupt */
#	endif
#endif

#ifndef PH_D_T105_I
#	define PH_D_T105_I      (500 * MILLISECOND)  	/* TE : T5 ETSI timer delay loss of power event */
#endif

/*--------------------------------------------------------------------------*/

 /* access to peripheral devices (in IO space):
	===========================================

	- in IO             (e.g. 8088 ÊP):
	  the devices are accessed via special IO commands
	  (in ASM : 'inp' and 'outp'). From C source level the
	  library functions inp () and outp () are used:

		 INPUT:   byte_value = inp ([port address]);

		 OUTPUT:  outp([port address], byte_value);

   - memory mapped IO   (e.g. 80188 ÊC or ÊC without IO port)

	 the devices are (virtually) in the memory space and can be
	 accessed via pointers. The inp () and outp () functions are
	 substituted by the follwing macros.

			#define  inp(port) *port
			#define  outp(port,byte_val) *port=byte_val

	=============================================================          */

#if PH_MEMORY_MAPPED_IO == ON
									   /* memory mapped IO (80188)         */
	typedef VOLATILE char FAR *IO_PORT;         /* pointer to IO devices possible   */
									   /* the type IO_PORT is defined as   */
									   /* far pointer to a BYTE            */
									   /* ==============================   */
			/* MACROS */
			/* ?????? */

#   define  Rd_sbc(p_port)              *p_port
#   define  Wr_sbc(p_port,byte_val)     *p_port=byte_val

#   define  Rd_icc(p_port)              *p_port
#   define  Wr_icc(p_port,byte_val)     *p_port=byte_val

#   define  Rd_iec(p_port)              *p_port

#   define  Wr_iec(p_port,byte_val)     *p_port=byte_val

#   if PH_FIFO_MOVE == ON
#       define  String_in(p_to,p_from,cnt)  Memcpy_far  (p_to,   p_from, cnt)
#       define  String_out(p_from,p_to,cnt) Memcpy_far  (p_to,   p_from, cnt)

#   else

#       define  String_in(p_to,p_from,cnt)  {                                       			\
												register char 	FAR *p_current = p_to;         	\
												register char 	FAR *p_fifo	   = p_from;       	\
												register 		     ushort remainder    = cnt; \
												while (remainder--) {               			\
													*p_current++ = *p_fifo;         			\
												}                                   			\
											}

#       define  String_out(p_from,p_to,cnt) {                                       			\
												register char 	FAR *p_current = p_from;       	\
												register char 	FAR *p_fifo	   = p_to;       	\
												register			 ushort remainder    = cnt;	\
												while (remainder--) {               			\
													*p_fifo = *p_current++;           			\
												}                                   			\
											}
#   endif

#else
									   /* 'normal' IO via the reserved     */
									   /* instructions IN/OUT coded in     */
									   /* ASM                              */

	typedef ushort  IO_PORT;           /* the type IO_PORT is defined as   */
									   /* 'unsigned short' (= 2 bytes) to  */
									   /* cover the 64k range of the IO    */
									   /* space                            */

									   /* devices in the IO space are      */
									   /* programmed using the MSC library */
									   /* functions inp() and outp()       */

#if C_COMPILER == TC
#   include <dos.h>
#endif

#if C_COMPILER == MSC
#   include <dos.h>
#   include <conio.h>
#endif

#   define  Rd_sbc(a_port)              inp  ((int)a_port)
#   define  Wr_sbc(a_port,byte_val)     outp ((int)a_port, byte_val)

#   define  Rd_icc(a_port)              inp  ((int)a_port)
#   define  Wr_icc(a_port,byte_val)     outp ((int)a_port, byte_val)

#   define  Rd_iec(a_port)              inp  ((int)a_port)
#   define  Wr_iec(a_port,byte_val)     outp ((int)a_port, byte_val)

#   if PH_FIFO_MOVE == ON

#       define  String_in(p_to,port,cnt)    string_in_io 	(p_to,    port, cnt)

#       define  String_out(p_from,port,cnt) string_out_io 	(p_from,  port, cnt)

#   else

#       define  String_in(p_to,port,cnt)    {                                           	\
												register char 	FAR *p_current = p_to;  	\
												register int 		 fifo	   = (int)port;	\
												register ushort 	 remainder = cnt;		\
												while (remainder--) {                   	\
													*p_current++ = inp ((int)fifo);     	\
												}                                       	\
											}

#       define  String_out(p_from,port,cnt) {                                           	\
												register char 	FAR *p_current = p_from;	\
												register int 		 fifo	   = (int)port;	\
												register ushort 	 remainder = cnt;   	\
												while (remainder--) {                   	\
													outp ((int)fifo, *p_current++);    	 	\
												}                                       	\
											}

#   endif

#endif

#if (PH_D_U == ON) && (ENTITY == ENT_MPH)

#	define  Mph_d_ci_action(p_PI_tab, byte_val) Wr_iec(p_PI_tab -> pt_r_cixu, (Sfi(U_CIWU_W_CI, byte_val) | U_CIWU_W_CI_MASK))
#endif

#include "def.h"
#include "basic.h"

/*-------------------------------------------------------------------------*/

		/* These macros mask an interrupt level via the 8259 interrupt controller */

#define Isdn_controller_mask(mask_level, mask_value)    It_mask     (mask_level, mask_value)
#define Isdn_controller_unmask(mask_level)              It_unmask   (mask_level)
#define Isdn_controller_ldmask(mask_value)              It_ldmask   (mask_value);

#define ISAC_MASK       ISDN_CONTROLLER_MASK
#define SBC_MASK        ISDN_CONTROLLER_MASK

/*-------------------------------------------------------------------------*/

						/* PH GENERAL COMMON VARIABLES */

#if SIMULATION == OFF

#   if ENTITY ==  ENT_PH_D

#       define  event_id            event_id_ph_d       /* event identifier */
#       define  ret_code            ret_code_ph_d       /* return code */
#       define  p_snd_msg           p_snd_msg_ph_d      /* pointer on the current message to send if any */
#       define  p_rcv_msg           p_rcv_msg_ph_d      /* pointer on the current received message if any */
#       define  p_buffer            p_buffer_ph_d       /* pointer on the curent buffer if any */
#       define  p_buffer_end        p_buffer_end_ph_d   /* pointers on the end of the current buffer if any */
#       define  os_err              os_err_ph_d         /* OS error code */

#   endif

#   if ENTITY == ENT_MPH

#       define  event_id            event_id_mph_d      /* event identifier */
#       define  ret_code            ret_code_mph_d      /* return code */
#       define  p_snd_msg           p_snd_msg_mph_d     /* pointer on the current message to send if any */
#       define  p_rcv_msg           p_rcv_msg_mph_d     /* pointer on the current received message if any */
#       define  p_buffer            p_buffer_mph_d      /* pointer on the curent buffer if any */
#       define  p_buffer_end        p_buffer_end_mph_d  /* pointers on the end of the current buffer if any */
#       define  os_err              os_err_mph_d        /* OS error code */

#   endif

#endif

/*-------------------------------------------------------------------------*/

            /* I.430 TE Physical states definitions */

#define F1                          1               /* state 1  : inactive */
#define F2                          2               /* state 2  : sensing  */
#define F3                          3               /* state 3  : deactivated */
#define F4                          4               /* state 4  : awaiting signal */
#define F5                          5               /* state 5  : identifying input */
#define F6                          6               /* state 6  : synchronized */
#define F7                          7               /* state 7  : activated */
#define F8                          8               /* state 8  : lost framing */
#define F_NIL                       255             /* state NIL */

/*-------------------------------------------------------------------------*/

			/* I.430 NT Physical states definitions */

#define G1                          11               /* state 1  : Deactive */
#define G2                          12               /* state 2  : Pending activation */
#define G3                          13               /* state 3  : Active */
#define G4                          14               /* state 4  : Pending Deactivaction */

/*-------------------------------------------------------------------------*/

				/* MPH D and PH D event and primitive codes */

#define EV_PH_AR                    'A'             /* request activation of the physical layer */
#define EV_PH_DR                    'B'             /* request deactivation of the physical layer */

#define EV_TI_101                   'C'             /* timer 101 expired (level 1 T1) */
#define EV_TI_102                   'D'             /* timer 102 expired (level 1 T2) */
#define EV_TI_103                   'E'             /* timer 103 expired (level 1 T3) */
#define EV_TI_104                   'F'             /* timer 104 expired (level 1 T3) */

#define EV_LOSS_OF_POWER            'G'             /* TE loss of power */
#define EV_DETECTION_OF_POWER       'H'             /* TE power ON and detection of power */

#define EV_INFO_0                   'I'             /* receiving INFO 0 */
#define EV_INFO_1                   'J'             /* receiving INFO 1 */
#define EV_INFO_2                   'K'             /* receiving INFO 2 */
#define EV_INFO_3                   'L'             /* receiving INFO 3 */
#define EV_INFO_4_8                 'M'             /* receiving INFO 4 priority 8 */
#define EV_INFO_4_10                'N'             /* receiving INFO 4 priority 10 */
#define EV_INFO_4                 	'M'             /* receiving INFO4 */

#define EV_LOST_FRAMING             'O'             /* lost framing */
#define EV_ANY_SIGNAL               'P'             /* any signal */

#define EV_ERR_IND                  'Q'             /* error indication */
#define EV_ERR_CLK                  'R'             /* clock error */

#define	EV_TI_198                   'S'				/* WA 1 : timer expiry T198 */

#if (PH_D_U == ON) && (PH_D_MODE == MODE_TIMER)
#	define	EV_TI_999                   'T'
#endif



							/* Alias code */

#define PH_AR                       PH_ACT_RQ       /* PH activation request primitive */
#define PH_AI                       PH_ACT_IN       /* PH activation indicate primitive */

#define PH_DR                       PH_DEA_RQ       /* PH deactivation request primitive */
#define PH_DI                       PH_DEA_IN       /* PH deactivation indication primitive */

#define MPH_AR                      MPH_ACT_RQ      /* MPH activation request primitive */
#define MPH_AI                      MPH_ACT_IN      /* MPH activation indicate primitive */

#define MPH_DR                      MPH_DEA_RQ      /* MPH deactivation request primitive */
#define MPH_DI                      MPH_DEA_IN      /* MPH deactivation indication primitive */

#define MPH_EI                      MPH_EI0_IN      /* MPH error indication */
#define MPH_EI1                     MPH_EI1_IN      /* MPH error indication 1 */
#define MPH_EI2                     MPH_EI2_IN      /* MPH error indication 2 */

#define MPH_II_C                    MPH_II_C_IN     /* MPH information indication Connect */
#define MPH_II_D                    MPH_II_D_IN     /* MPH information indication Disconnect */

							/* Interrupt event ID */

#define EV_TX_DONE                  'a'             /* Transmit done */
#define EV_RX_DONE                  'b'             /* receive done */
#define EV_TX_ERR                   'c'             /* erroneous transmission */
#define EV_RX_ERR                   'd'             /* erroneous reception */
#define EV_TX_RETRY                 'e'             /* erroneous transmission --> retry possible */
#define EV_TX_TO                    'f'             /* watch dog timer expiration */
#define EV_TX_RESET                 'g'             /* transmit reset */

				/* CCITT I.430 INFO codes */

#define INFO_0                      0               /* INFO 0 : TE <-> NT no signal */
#define INFO_1                      1               /* INF0 1 : TE --> NT positive ZERO, negative ZERO, six ONE */
#define INFO_2                      2               /* INFO 2 : NT --> TE */
#define INFO_3                      3               /* INFO 3 : TE --> NT synchronized frame */
#define INFO_4                      4               /* INFO 4 : NT --> TE */

				/* PH priority levels */

#define PH_D_PRIORITY_CLASS_1_NORMAL    0
#define PH_D_PRIORITY_CLASS_1_LOWER     1
#define PH_D_PRIORITY_CLASS_2_NORMAL    2
#define PH_D_PRIORITY_CLASS_2_LOWER     3

/*--------------------------------------------------------------------------*/

#if ENTITY == ENT_PH_D

					/* PH : TIMER MANAGEMENT */

#   define T101                     0                           /* CCITT I430 T1 timer */
#   define T102                     1                           /* CCITT I430 T2 timer */
#   define T103                     2                           /* CCITT I430 T3 timer */
#   define T104                     3                           /* ETSI  T4 timer */
#   define T105                     4                           /* ETSI  T5 loss of power timer */

#   define T198                     5                           /* for work around # 1 */

#   define Ti_ev_id(xx)             PH_D_TI_EV_ID[xx]           /* timer ID table */

#   if  PH_TX_WATCHDOG_TIMER == ON
#       define T199                 6                           /* TX watch dog timer */
#       define MX_TIMER             7                           /* maximum number of timer used simultaneously */

#   else

#       define MX_TIMER             6                           /* maximum number of timer used simultaneously */
#   endif

#	define PH_D_T198_I              (25 * MILLISECOND)	 		/* value for delayed LOST of FRAMING in F6 when receiving INFO 0 */

/*-------------------------------------------------------------------------*/

                        /* PH D NA context */

    struct ph_d_na {
        struct peitab                   peitab;                 /* pei table */
        nai_t                           nai;                    /* NA ID */
		uchar                           state;                  /* current PH state */
		uchar							power_s;				/* Power ON or OFF */
		uchar							isac_id;                /* ISAC-S ID in the system */
		uchar							codec_id;              	/* CODEC ID */
		uchar							codec_chan_id;			/* Channel ID assign to the codec */
		uchar                           priority;               /* priority current value */
		uchar                           chan_loop_back;         /* channel loop back */
		uchar                           fct;                    /* function : FG_TE_NET, FG_TE_NT, FG_NT_TE, FG_NT_NET */
		uchar                           state_pipe_counter;     /* number of state change in the pipe */

		ent_id_t						ent_dl;					/* DL entity ID */
		ent_id_t						ent_mdl;				/* MDL entity ID */
		ent_id_t						ent_maintenance;		/* maintenance entity ID */

		long							rfc;					/* good frame received counter */
		long							tfc;					/* good frame transmit counter */
		long                            error_counter;          /* error counter */

		struct message   FAR * VOLATILE p_it_xmt_first;         /* TX FIFO */
		struct message   FAR * VOLATILE p_it_xmt_last;          /* TX FIFO */
		struct message   FAR * VOLATILE p_xmt_msg;              /* current XMIT message */

		timer_val_t                     ti [MX_TIMER];          /* timer values */
		struct timer                    timer_table [MX_TIMER]; /* timer table  */

#       if PH_FRAME_ADD_RECOGNITION == ON

					/* Address register number management */

			uchar                       p_add_reg [ADD_REG_NB];
			uchar                       add_flag;

#       endif

		uchar                      FAR *p_mem_blk;              /* Address of the memory block */

			/* BRI error statistics */

		ushort							lost_framing;    		/* lost framing */
		ushort							lost_synchronization;   /* lost synchronization */

#		if PH_D_U == ON
			uchar								active;			/* NA active or not : ON or OFF */
#		endif

		uchar							loop3_flag;				/* LOOP3 activated: ON or OFF */

		uchar							iom_power_down_req;
																/* IOM2 to POWER DOWN requested : ON or OFF */
	};

#   define Ph_d_a_peitab_to_ph_d_na(p_peitab) ((struct ph_d_na FAR *)p_peitab)

#   define Ph_d_a_peitab            &(p_ph_d_na -> peitab)
#   define Ph_d_nai                 p_ph_d_na -> nai
#   define Ph_d_state               p_ph_d_na -> state
#   define Ph_d_power_s             p_ph_d_na -> power_s
#   define Ph_d_isac_id             p_ph_d_na -> isac_id
#   define Ph_d_codec_id            p_ph_d_na -> codec_id
#   define Ph_d_codec_chan_id       p_ph_d_na -> codec_chan_id
#   define Ph_d_p_xmit_msg          p_ph_d_na -> p_msg_xmit
#   define Ph_d_priority            p_ph_d_na -> priority
#   define Ph_d_fct                 p_ph_d_na -> fct
#   define Ph_d_state_pipe_counter  p_ph_d_na -> state_pipe_counter
#   define Ph_d_ent_dl				p_ph_d_na -> ent_dl
#   define Ph_d_ent_mdl        		p_ph_d_na -> ent_mdl
#   define Ph_d_ent_maintenance		p_ph_d_na -> ent_maintenance
#	define Ph_d_receive_counter 	p_ph_d_na -> rfc
#	define Ph_d_transmit_counter	p_ph_d_na -> tfc
#   define Ph_d_error_counter       p_ph_d_na -> error_counter
#   define Ph_d_chan_loop_back      p_ph_d_na -> chan_loop_back
#   define Ph_d_p_it_xmt_first      p_ph_d_na -> p_it_xmt_first
#   define Ph_d_p_it_xmt_last       p_ph_d_na -> p_it_xmt_last
#   define Ph_d_p_xmt_msg           p_ph_d_na -> p_xmt_msg
#   define Ph_d_p_add_reg           p_ph_d_na -> p_add_reg
#   define Ph_d_add_flag            p_ph_d_na -> add_flag
#   define Ph_d_p_mem_blk           p_ph_d_na -> p_mem_blk

#	if PH_D_U == ON
#		define Ph_d_active				p_ph_d_na 	-> active
#	endif

#   define Ph_d_size                Rnd_sizeof (struct ph_d_na)

#	define Ph_d_loop3_flag         	p_ph_d_na -> loop3_flag

#	define Ph_d_iom_power_down_req 	p_ph_d_na -> iom_power_down_req

	/* BRI statistics */

#	define Ph_d_lost_framing		p_ph_d_na -> lost_framing
#	define Ph_d_lost_synchronization p_ph_d_na -> lost_synchronization

			/* Access to PH timer management values */

#   define Ti_val(xx)               p_ph_d_na -> ti[xx]
#   define Ti_state(xx)             p_ph_d_na -> timer_table[xx].state
#   define Ti_id(xx)                p_ph_d_na -> timer_table[xx].id
#   define Ti_sn(xx)                p_ph_d_na -> timer_table[xx].sn

			/* Transmitter busy flag */

#   define Transmitter_busy         (((struct peitab FAR *)Ph_d_a_peitab) -> pt_state & (PT_TX_WORKS | PT_HDLC_RESET))

#endif

/*-------------------------------------------------------------------------*/

#if (ENTITY == ENT_MPH) || (ENTITY == ENT_MPH_IT)

					/* MPH REPORT MANAGEMENT */

#if PH_REPORTING_TO_SM == ON
#	define Mph_report_to_sm(error_code)		mph_d_send_report_to_sm (error_code)

#else

#	define Mph_report_to_sm(error_code)
#endif

#if PH_D_U == ON

#if EQUIPMENT == TE

					/* MPH TE : TIMER MANAGEMENT */

		/* MPH timer table : index assigned to timers (for overlaping) */

#	define T103						0			/* CCITT I430 T3 timer         */
#	define T104						1			/* ETSI T4 timer         */

#	if PH_D_WA_1 == ON
#		define T198						2
#		define PH_D_T198_I              (25 * MILLISECOND) 	/* value for delayed LOST of FRAMING in F6 when receiving INFO 0 */

#		if PH_D_POWER_S == ON
#			define T105					3		/* ETSI permanent loss of power */
#			if (PH_D_MODE == MODE_TIMER)
#   			define T999             4
#				define MX_MPH_D_TIMER		5		/* maximum number of timer used simultaneously */

#			else
#				define MX_MPH_D_TIMER		4		/* maximum number of timer used simultaneously */

#			endif
#		else
#			if (PH_D_MODE == MODE_TIMER)
#   			define T999             	3
#				define MX_MPH_D_TIMER		4		/* maximum number of timer used simultaneously */
#			else
#				define MX_MPH_D_TIMER		3		/* maximum number of timer used simultaneously */
#			endif

#		endif

#	else

#		if PH_D_POWER_S == ON
#			define T105					2		/* ETSI permanent loss of power */
#			if (PH_D_MODE == MODE_TIMER)
#   			define T999             	3
#				define MX_MPH_D_TIMER		4		/* maximum number of timer used simultaneously */
#			else
#				define MX_MPH_D_TIMER		3		/* maximum number of timer used simultaneously */
#			endif

#		else
#			if (PH_D_MODE == MODE_TIMER)
#   			define T999             	2
#				define MX_MPH_D_TIMER		3		/* maximum number of timer used simultaneously */
#			else
#				define MX_MPH_D_TIMER		2		/* maximum number of timer used simultaneously */
#			endif

#		endif

#	endif

#else

					/* MPH NT : TIMER MANAGEMENT */

		/* MPH timer table : index assigned to timers (for overlaping) */

#	define T101						0			/* CCITT T1 timer         	*/
#	define T102						1			/* CCITT T2 timer         	*/
#	define T103						2			/* CCITT I430 T3 timer    	*/
#	define T104						3			/* ETSI T4 timer         	*/

#	if PH_D_WA_1 == ON
#		define T198					4
#		define PH_D_T198_I          (25 * MILLISECOND) 	/* value for delayed LOST of FRAMING in F6 when receiving INFO 0 */

#		if PH_D_POWER_S == ON
#			define T105				5			/* ETSI permanent loss of power */
#			if (PH_D_MODE == MODE_TIMER)
#   			define T999             6
#				define MX_MPH_D_TIMER	7			/* maximum number of timer used simultaneously */
#			else
#				define MX_MPH_D_TIMER	6			/* maximum number of timer used simultaneously */
#			endif

#		else

#			if (PH_D_MODE == MODE_TIMER)
#   			define T999         5
#				define MX_MPH_D_TIMER	6			/* maximum number of timer used simultaneously */
#			else
#				define MX_MPH_D_TIMER	5			/* maximum number of timer used simultaneously */
#			endif
#		endif

#	else

#		if PH_D_POWER_S == ON
#			define T105				4			/* ETSI permanent loss of power */
#			if (PH_D_MODE == MODE_TIMER)
#   			define T999         5
#				define MX_MPH_D_TIMER	6			/* maximum number of timer used simultaneously */
#			else
#				define MX_MPH_D_TIMER	5			/* maximum number of timer used simultaneously */
#			endif
#		else

#			if (PH_D_MODE == MODE_TIMER)
#   			define T999         	4
#				define MX_MPH_D_TIMER	5			/* maximum number of timer used simultaneously */
#			else
#				define MX_MPH_D_TIMER	4			/* maximum number of timer used simultaneously */
#			endif
#		endif

#	endif

#endif

#include "PSB21910.h"

#endif /* if PH_D_U == ON */

/*-------------------------------------------------------------------------*/

					/* MPH_D : TIMER MANAGEMENT */

		/* MPH_D timer table : index assigned to timers (for overlaping) */

/*-------------------------------------------------------------------------*/

						/* MPH NA context */

	struct mph_d_na {
					nai_t               nai;                    /* NA ID */
					uchar				transceiver_mode;       /* Tranceiver mode */
					uchar               fct;                    /* functionnal grouping */
					uchar               state;                  /* state (NETWORK side) */
					ent_id_t			ent_up;					/* upper layer entity ID */
					ent_id_t			ent_mdl;				/* upper layer management entity ID */
					uchar           FAR *p_mem_blk;             /* memory block pointer */
					uchar       		layer1;                 /* layer1 component : PH_SBC, PH_IBC, PH_IEC */
#					if (PH_D_U == ON)
						uchar			 	device_id;				/* IEC-Q ID */
						long                iec_base_add;          	/* IEC-Q base address */
						ushort              iec_it_add;            	/* IEC-Q IT address */
						uchar			 	lt_uoa;					/* U interface Activate only : ON or OFF */
						uchar			 	nt_ps;						/* NT Power status */
						struct PI_tab       pitab;                 	/* pi table */

						timer_val_t		 	ti[MX_MPH_D_TIMER];		/* timer values */
						struct timer	 	timer_table[MX_MPH_D_TIMER];/* timer table  */
#						if MX_CHIP_STORAGE_B_U != 0
							uchar	 chip_storage_b_u [MX_CHIP_STORAGE_B_U];/*  U component byte register */
#						endif

#						if MX_CHIP_STORAGE_W_U != 0
							ushort	chip_storage_w_u [MX_CHIP_STORAGE_W_U];/* U component word register */
#						endif

#					endif

	};

#   define Mph_d_nai            	p_mph_d_na -> nai
#	define Mph_d_device_id			p_mph_d_na -> device_id
#   define Mph_d_fct            	p_mph_d_na -> fct
#   define Mph_d_state          	p_mph_d_na -> state
#   define Mph_d_ent_up         	p_mph_d_na -> ent_up
#   define Mph_d_ent_mdl        	p_mph_d_na -> ent_mdl
#   define Mph_d_p_mem_blk      	p_mph_d_na -> p_mem_blk
#   define Mph_d_layer1         	p_mph_d_na -> layer1
#	define Mph_d_transceiver_mode	p_mph_d_na -> transceiver_mode

#	if (PH_D_U == ON)
#   	define Mph_d_iec_base_add  			p_mph_d_na -> iec_base_add
#   	define Mph_d_iec_it_add    			p_mph_d_na -> iec_it_add
#   	define Mph_d_a_PI_tab   			((struct PI_tab FAR *)&(p_mph_d_na -> pitab))
#		define Mph_d_chip_storage_b_u(x)	p_mph_d_na  -> chip_storage_b_u [x]
#		define Mph_d_chip_storage_w_u(x)	p_mph_d_na  -> chip_storage_w_u [x]
#		define Mph_d_lt_uoa					p_mph_d_na  -> lt_uoa
#		define Mph_d_nt_ps					p_mph_d_na  -> nt_ps

						/* Context storage assignment */

	/* access to read registers */
#		define Mph_d_u_br_r(x)				Mph_d_chip_storage_b_u (2*x)

	/* access to write registers */
#		define Mph_d_u_br_w(x)				Mph_d_chip_storage_b_u (2*x+1)

#		define Mph_d_u_mon_0_eoc			Mph_d_chip_storage_b_u (U_BR_MAX*2 + 0)
#		define Mph_d_u_mon_1_sq_code		Mph_d_chip_storage_b_u (U_BR_MAX*2 + 1)
#		define Mph_d_u_mon_8_local          Mph_d_chip_storage_b_u (U_BR_MAX*2 + 2)
#		define Mph_d_u_mon_8_internal_coef  Mph_d_chip_storage_b_u (U_BR_MAX*2 + 3)
#		define Mph_d_u_mon_2_eoc            Mph_d_chip_storage_w_u (0)

# 		if (MX_CHIP_STORAGE_B_U  < (U_BR_MAX*2 + 4))
			ERROR
#		endif

#		if (MX_CHIP_STORAGE_W_U < 1)
			ERROR
#		endif

#	endif /* if (PH_D_U == ON) */

#   define Mph_d_size           Rnd_sizeof (struct mph_d_na)

		/* Access to PH timer management values */

#   define Ti_val(xx)           p_mph_d_na -> ti[xx]
#   define Ti_state(xx)         p_mph_d_na -> timer_table[xx].state
#   define Ti_id(xx)            p_mph_d_na -> timer_table[xx].id
#   define Ti_sn(xx)            p_mph_d_na -> timer_table[xx].sn
#	define Ti_ev_id(xx) 		MPH_TI_EV_ID[xx]

		/* Line state as view by MPH */

#   define MPH_D_INFO_TRF_NOT_AVAILABLE     'N'
#   define MPH_D_INFO_TRF_AVAILABLE         'A'
#   define MPH_D_INFO_TRF_INTERRUPTED       'I'

#endif

/*-------------------------------------------------------------------------*/

							/* PH_D  macro's */

		/* Put a message into the transmit FIFO */

#define It_put_xmt(p_msg, old_mask)                                     \
	It_disable_isac (old_mask);                                         \
	Fifo_put_msg (&(Ph_d_p_it_xmt_first), &(Ph_d_p_it_xmt_last), p_msg);\
	It_enable_isac (old_mask)

		/* Fetch a message from the transmit FIFO */

#define It_get_xmt(p_msg, old_mask)                                     \
	It_disable_isac (old_mask);                                         \
	Fifo_get_msg (&(Ph_d_p_it_xmt_first), &(Ph_d_p_it_xmt_last), p_msg);\
	It_enable_isac (old_mask)

		/* Read the first message pointer of the transmit FIFO */

#define It_read_first_xmt(p_msg, old_mask)                              \
	It_disable_isac (old_mask);                                         \
	p_msg = Ph_d_p_it_xmt_first;                                        \
    It_enable_isac (old_mask)

/*-------------------------------------------------------------------------*/

                /* Function declarations */

#if NEW_FCT_STYLE == ON

#if ENTITY == ENT_PH_D
	uchar   ph_d_start_xmit                 (ent_id_t entity_id, struct ph_d_na FAR *p_ph_d_na, uchar wd_timer_flag);
	void    ph_d_start_tx_watchdog_timer    (struct ph_d_na FAR *p_ph_d_na, struct message FAR *p_msg_xmit);
	void    ph_d_clear_xmt                  (struct message FAR *p_msg_clear);
	uchar   ph_d_build_object               (struct ph_d_config FAR *p_ph_d_config);
	uchar   ph_d_access_nai                 (nai_t nai);
	void    ph_d_access_first_na            (void);
	void    ph_d_access_next_na             (void);
	void 	ph_d_te_power_event 			(uchar event_id);
#endif

	uchar   mph_d_build_object              (struct ph_d_config FAR *p_ph_d_config);

#if ENTITY == ENT_MPH
	uchar   mph_d_access_nai                (nai_t nai);
	void    mph_d_access_first_na           (void);
	void    mph_d_access_next_na            (void);
#endif

	void    isac_event                      (struct peitab FAR *p_peitab, uchar event_id);
	void    isac_it                         (uchar isac_id);

	int     sbc_init                        (struct peitab FAR *p_peitab, uchar pt_mode);
	int     sbc_act                         (struct peitab FAR *p_peitab, uchar priority);
	uchar   sbc_info_4                      (struct peitab FAR *p_peitab);
	int     sbc_act_local_loop              (struct peitab FAR *p_peitab);
	int     sbc_act_local_loop3             (struct peitab FAR *p_peitab);
	int     sbc_reset_local_loop3           (struct peitab FAR *p_peitab);
	int     sbc_dea                         (struct peitab FAR *p_peitab);
	void    sbc_it                          (struct peitab FAR *p_peitab);
	int     sbc_reset                       (struct peitab FAR *p_peitab);
	int     sbc_enable_clock                (struct peitab FAR *p_peitab);
	int     sbc_iom2_switch        			(struct peitab FAR *p_peitab, uchar flag);
	void    sbc_event                       (struct peitab FAR *p_peitab);
	uchar 	sbc_read_te_event 				(struct peitab FAR *p_peitab);

#	if (PH_D_U == ON) && (ENTITY == ENT_MPH)
		void    iec_init_PI_tab                 (struct PI_tab FAR *p_PI_tab, IO_PORT base, uchar delta);
		int     iec_init                        (struct PI_tab FAR *p_PI_tab, uchar pt_mode);
		void    iec_it                          (uchar PI_tab_id);
#		if PH_D_MODE == MODE_TIMER
			void 	iec_status						(struct PI_tab FAR *p_PI_tab);
#		endif
		uchar 	mph_d_b_chan_loopback_4 		(add_t chan_id, uchar action);
		uchar 	mph_d_convert			 		(uchar	event);
		uchar 	mph_d_convert_u_te		 		(uchar	event);
		uchar 	mph_d_convert_u_lt		 		(uchar	event);
		uchar 	mph_d_convert_u_nt		 		(uchar	event);
		void	mph_d_nt_ps_u_te				(void);
		void	mph_d_nt_ps_u_nt				(void);
		void	mph_d_eoc_operation				(ushort eoc);
		void 	mph_d_write_eoc 				(uchar address, uchar indicator, uchar code);
		void 	mph_d_write_eoc_u_te			(ushort eoc);
		void 	mph_d_write_eoc_u_nt			(ushort eoc);
		void 	mph_d_rq_corrupted_crc 			(uchar on_off);
		void 	mph_d_rq_corrupted_crc_u_te		(uchar on_off);
		void 	mph_d_rq_corrupted_crc_u_nt		(uchar on_off);
		void 	mph_d_reinit	 				(void);
		void 	mph_d_reinit_u_te 				(void);
		void 	mph_d_reinit_u_lt 				(void);
		void 	mph_d_reinit_u_nt 				(void);
		void 	mph_d_reinit_st_nt 				(void);
		void 	mph_d_reinit_st_te 				(void);
		void 	mph_d_reinit_st_lt 				(void);
		void 	mph_d_stop		 				(void);
		void 	mph_d_stop_u_te 				(void);
		void 	mph_d_stop_u_lt 				(void);
		void 	mph_d_stop_u_nt 				(void);
		void 	mph_d_stop_st_nt 				(void);
		void 	mph_d_stop_st_te 				(void);
		void 	mph_d_stop_st_lt 				(void);
#	endif

	void    icc_init_peitab                 (struct peitab FAR *p_peitab, IO_PORT base, uchar delta);
	int     icc_init                        (struct peitab FAR *p_peitab, uchar modulo, uchar mode);

	int     icc_loop                        (struct peitab FAR *p_peitab, uchar on_off, add_t chan_id);
	void    icc_it                          (uchar ista, struct peitab FAR *p_peitab);
	long    icc_it_rx                       (uchar rpf, struct peitab FAR *p_peitab);
	int     icc_reset                       (struct peitab FAR *p_peitab);
	int     icc_reset_tx_channel            (struct peitab FAR *p_peitab);
	void    icc_event                       (struct peitab FAR *p_peitab, uchar event);
	uchar   icc_send_frame                  (struct peitab FAR *p_peitab, ushort data_size, uchar FAR *p_frame);
	void    icc_switch_b_channel            (struct peitab FAR *p_peitab, add_t chan_id);

#   if PH_MEMORY_MAPPED_IO == OFF
		void    string_in_io                (char FAR *p_to,   IO_PORT port, ushort cnt);
		void    string_out_io               (char FAR *p_from, IO_PORT port, ushort cnt);
#   endif

	int     arcofi_assign_voice             (struct peitab FAR *p_peitab, uchar channel);
	int     arcofi_imod                     (struct peitab FAR *p_peitab, uchar arcofi_id);
	uchar   arcofi_init                     (struct peitab FAR *p_peitab, uchar arcofi_id,
											 uchar FAR *p_arcofi_sop,
											 uchar FAR *p_arcofi_tg1,
											 uchar FAR *p_arcofi_tg2,
											 uchar FAR *p_arcofi_tg3,
											 uchar FAR *p_arcofi_tf,
											 uchar FAR *p_arcofi_cg,
											 uchar FAR *p_arcofi_txg,
											 uchar FAR *p_arcofi_sg,
											 uchar FAR *p_arcofi_cffx,
											 uchar FAR *p_arcofi_cffr,
											 uchar FAR *p_arcofi_coefsp,
											 uchar FAR *p_arcofi_agc_tx,
											 uchar FAR *p_arcofi_agc_rx
											);
	uchar	arcofi_update 					(struct peitab FAR *p_peitab, uchar FAR *p_data);
	int     rd_mon1                         (struct peitab FAR *p_peitab, uchar cmd, uchar FAR *parm, int cnt);
	int     wr_mon1                         (struct peitab FAR *p_peitab, uchar FAR *parm, int Cnt);
	void    addr_mon1                       (struct peitab FAR *p_peitab, uchar mad);
	uchar   mon1_ident                      (struct peitab FAR *p_peitab, uchar id_cmd, uchar FAR *id_code);
	uchar	arcofi_power					(struct peitab FAR *p_peitab, uchar pu);

#	if (PH_D_U == ON) && ((ENTITY == ENT_MPH) || (ENTITY == ENT_MPH_IT))

		uchar 	mph_d_b_chan_loopback_u_te		(add_t chan_id, uchar action);
		uchar 	mph_d_b_switch 					(struct mph_b_switch FAR *p_data);
		void	mph_d_disable_b_u_te 			(uchar chan_id);
		void	mph_d_enable_b_u_te 			(uchar chan_id);
		void 	mph_d_process_event 			(code_t	code);
		void	mph_d_rx_mc_u_te 				(uchar FAR *p_data);
		void 	mph_d_send_to_ph_d 				(code_t	code);
		void 	mph_d_send_to_mdl 				(code_t	code);
		void 	mph_d_send_to_sm 				(code_t	code);
		void 	mph_d_send_report_to_sm 		(code_t	code);
		void	mph_d_state_machine 			(uchar event);
		void	mph_d_te_state_machine_u_te		(uchar event);
		void	mph_d_nt1_state_machine_u_nt	(uchar event);
		void	mph_d_lt_state_machine_u_lt		(uchar event);
		void	mph_d_reset_image_reg_u		 	(struct mph_d_na	FAR *p_mph_d_na);
		int     rd_mon                          (struct PI_tab 		FAR *p_PI_tab, uchar FAR *p_parm, int cnt);
		int     wr_mon                          (struct PI_tab 		FAR *p_PI_tab, uchar FAR *p_parm, int cnt);
#	endif

#else

#if ENTITY == ENT_PH_D
	uchar   ph_d_start_xmit                 ();
	void    ph_d_start_tx_watchdog_timer    ();
	void    ph_d_clear_xmt                  ();
	uchar   ph_d_build_object               ();
	uchar   ph_d_access_nai                 ();
	void    ph_d_access_first_na            ();
	void    ph_d_access_next_na             ();
	void 	ph_d_te_power_event 			();
#endif

#if ENTITY == ENT_MPH
	uchar   mph_d_build_object              ();
	uchar   mph_d_access_nai                ();
	void    mph_d_access_first_na           ();
	void    mph_d_access_next_na            ();
#endif

	void    isac_event                      ();
	void    isac_it                         ();

	int     sbc_init                        ();
	int     sbc_act                         ();
	uchar   sbc_info_4                      ();
	int     sbc_act_local_loop              ();
	int     sbc_act_local_loop3             ();
	int     sbc_reset_local_loop3           ();
	int     sbc_dea                         ();
	void    sbc_it                          ();
	int     sbc_reset                       ();
	int     sbc_enable_clock                ();
	int     sbc_iom2_switch					();
	void    sbc_event                       ();
	uchar 	sbc_read_te_event 				();

#	if (PH_D_U == ON)  && (ENTITY == ENT_MPH)
		void    iec_init_PI_tab                 ();
		int     iec_init                        ();
		void    iec_it                          ();
#		if PH_D_MODE == MODE_TIMER
			void 	iec_status						();
#		endif
		uchar 	mph_d_b_chan_loopback_4 		();
		uchar 	mph_d_convert			 		();
		uchar 	mph_d_convert_u_te		 		();
		uchar 	mph_d_convert_u_lt		 		();
		uchar 	mph_d_convert_u_nt		 		();
		void	mph_d_nt_ps_u_te				();
		void	mph_d_nt_ps_u_nt				();

		void	mph_d_eoc_operation				();
		void 	mph_d_write_eoc 				();
		void 	mph_d_write_eoc_u_te			();
		void 	mph_d_write_eoc_u_nt			();
		void 	mph_d_rq_corrupted_crc 			();
		void 	mph_d_rq_corrupted_crc_u_te		();
		void 	mph_d_rq_corrupted_crc_u_nt		();
		void 	mph_d_reinit	 				();
		void 	mph_d_reinit_u_te 				();
		void 	mph_d_reinit_u_lt 				();
		void 	mph_d_reinit_u_nt 				();
		void 	mph_d_reinit_st_nt 				();
		void 	mph_d_reinit_st_te 				();
		void 	mph_d_reinit_st_lt 				();

		void 	mph_d_stop		 				();
		void 	mph_d_stop_u_te 				();
		void 	mph_d_stop_u_lt 				();
		void 	mph_d_stop_u_nt 				();
		void 	mph_d_stop_st_nt 				();
		void 	mph_d_stop_st_te 				();
		void 	mph_d_stop_st_lt 				();
#	endif

	void    icc_init_peitab                 ();
	int     icc_init                        ();
	int     icc_loop                        ();
	void    icc_it                          ();
	long    icc_it_rx                       ();
	int     icc_reset                       ();
	int     icc_reset_tx_channel            ();
	void    icc_event                       ();
	uchar   icc_send_frame                  ();
	void    icc_switch_b_channel            ();

#   if PH_MEMORY_MAPPED_IO == OFF
		void    string_in_io                ();
		void    string_out_io               ();
#   endif

	int     arcofi_assign_voice             ();
	int     arcofi_imod                     ();
	uchar   arcofi_init                     ();
	uchar	arcofi_update 					();

	int     wr_mon1                         ();
	int     rd_mon1                         ();
	void    addr_mon1                       ();
	uchar   mon1_ident                      ();
	uchar	arcofi_power					();

#	if (PH_D_U == ON) && ((ENTITY == ENT_MPH) || (ENTITY == ENT_MPH_IT))
		uchar 	mph_d_b_chan_loopback_u_te		();
		uchar 	mph_d_b_switch 					();
		void	mph_d_disable_b_u_te 			();
		void	mph_d_enable_b_u_te 			();
		void 	mph_d_process_event 			();
		void	mph_d_rx_mc_u_te 				();
		void 	mph_d_send_to_ph_d 				();
		void 	mph_d_send_to_mdl 				();
		void 	mph_d_send_to_sm 				();
		void 	mph_d_send_report_to_sm 		();
		void	mph_d_state_machine 			();
		void	mph_d_te_state_machine_u_te		();
		void	mph_d_nt1_state_machine_u_nt	();
		void	mph_d_lt_state_machine_u_lt		();
		void	mph_d_reset_image_reg_u		 	();
		int     rd_mon                          ();
		int     wr_mon                          ();
#	endif
#endif

/*-------------------------------------------------------------------------*/
#endif

/*EOF*/

