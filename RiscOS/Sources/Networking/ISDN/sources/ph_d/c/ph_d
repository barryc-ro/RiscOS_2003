
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - ph_d.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *         ph_d - implements the PHysical D channel entity in ISDN-BRICKS
 *         for SIEMENS ISAC-S chip.
 *
 *         ph_d_config - implements the configuration and the
 *         initialization of the PH entity.
 *
 *         ph_d_start_xmit - implements the test of the transmit queue
 *         and if needed the initialization of a transmission when the
 *         transmitter is not busy.
 *
 *         ph_d_retransmit - implements the retansmission of a
 *         received message to another entity with another primitive
 *         code.
 *
 *         ph_d_clear_xmt - implements the clearing of a message
 *         in the XMIT waiting queue.
 *
 *         ph_d_te_power_event - implements the management of the
 *		   power detection for TEs locally powered and able
 *		   to detect power 1 or 2.
 *
 *         ph_d_te_activation_deactivation - implements activation/
 *         deactivation automaton for TEs locally powered and able
 *         to detect power 1 or 2.
 *
 *         ph_d_te_send_info - implements the sending of INFO 0, 1, 3,
 *         on the S0 Terminal line interface.
 *
 *         ph_d_net_send_info - implements the sending of INFO 0, 2, 4,
 *         on the S0 NT line interface.
 *
 *         ph_d_te_activation_action - implements the activation action
 *         on the S0 interface.
 *
 *         ph_d_te_deactivation_action - implements the deactivation action
 *         on the S0 interface.
 *
 *         ph_d_switch_b_chan - implements the switching of a B channel
 *         according to data contained in a message received from CC.
 *
 *         ph_d_stop_b_chan - implements the switching of a B channel
 *         according to data contained in a message received from CC.
 *
 *         ph_d_dlci_event_mgt - implements management of a DLCI address
 *         event coming from MDL.
 *
 *         ph_d_add_enable & ph_d_add_disable - implements the frame
 *         address recognition enabling and disabling action.
 *
 *         ph_d_net_activation_deactivation - implements activation/
 *         deactivation automaton for NETWORK side.
 *
 *         ph_d_net_activation_action - implements the activation action
 *         on the S0 interface network side.
 *
 *         ph_d_net_deactivation_action - implements the deactivation action
 *         on the S0 interface network side.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Siemens ISAC-S Driver                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#define ENTITY ENT_PH_D

#include "ph_d.h"
#include "dl_int.h"
#include "ctx_ext.h"

#if REVISION_STRING == ON
#	include "rev.ph_d_bri"
#endif

CONST char  ph_d_copyright[]    = "Copyright (c) 1990 - 1996 by OMNITEL SA - All Rights Reserved";
CONST char  ph_d_licence[]      = LICENSE_NBER;

		/* Common variables */

	Entity_common                (ph_d);            /* PH D entity common variables */
	struct node             FAR *p_ph_d_top_node;   /* Top node */
	struct ph_d_na          FAR *p_ph_d_na;         /* current NA pointer */
	struct peitab     FAR * FAR *p_tab_peitab_isac; /* PH D PEITAB pointer table ISAC-S */
	uchar                        ph_state;          /* global ph_state */

#	if OPTIMIZATION == SPEED
		struct ph_d_na FAR * FAR *p_ph_d_na_tab;	/* NA access index table */
#	endif

#   if PH_D_AUDIT == ON
		ushort                  ph_d_s_fifo_counter;/* TX IT FIFO counter */
#   endif

	uchar						layer_1_init_flag;	/* layer 1 init flag (common for access by application layer --> display line status) */

/*-------------------------------------------------------------------------*/

					/* PH : TIMER MANAGEMENT */

	CONST_ARRAY uchar           PH_D_TI_EV_ID[] = {TI_101, TI_102, TI_103, TI_104, TI_105, TI_198, TI_199};

/*-------------------------------------------------------------------------*/

						/* Function declarations */

#if NEW_FCT_STYLE == ON
	uchar   ph_d_config                     (struct ph_d_config FAR *p_ph_d_config);
	void    ph_d_retransmit                 (ent_id_t to, code_t code);
	void    ph_d_transmit                   (ent_id_t to, code_t code);
	void    ph_d_te_activation_deactivation (uchar event_id);
	void    ph_d_te_activation_action       (void);
	void    ph_d_te_deactivation_action     (void);
	void    ph_d_net_activation_deactivation(uchar event_id);
	void    ph_d_net_activation_action      (void);
	void    ph_d_net_deactivation_action    (void);
	void    ph_d_send_to_mph                (code_t code);
	void    ph_d_send_to_dl                 (code_t code);
	void    ph_d_send_to_dl_ai              (void);
	void    ph_d_send_to_mdl                (code_t code);
	uchar   ph_d_te_send_info               (uchar code);
	uchar   ph_d_net_send_info              (uchar code);
	void    ph_d_switch_b_chan              (uchar FAR *p_data);
	void    ph_d_stop_b_chan                (uchar FAR *p_data);
	uchar   ph_d_add_enable                 (uchar reg, uchar tei);
	uchar   ph_d_add_disable                (uchar reg);
	void    ph_d_dlci_event_mgt             (void);
	void    ph_d_discard_xmt                (void);
	void	ph_d_transmit_tx_done_in 		(struct message FAR *p_msg);

#else

	uchar   ph_d_config                     ();
	void    ph_d_retransmit                 ();
	void    ph_d_transmit                   ();
	void    ph_d_te_activation_deactivation ();
	void    ph_d_te_deactivation_action     ();
	void    ph_d_te_activation_action       ();
	void    ph_d_net_activation_deactivation();
	void    ph_d_net_deactivation_action    ();
	void    ph_d_net_activation_action      ();
	void    ph_d_send_to_mph                ();
	void    ph_d_send_to_dl                 ();
	void    ph_d_send_to_dl_ai              ();
	void    ph_d_send_to_mdl                ();
	uchar   ph_d_te_send_info               ();
	uchar   ph_d_net_send_info              ();
	void    ph_d_switch_b_chan              ();
	void    ph_d_stop_b_chan                ();
	uchar   ph_d_add_enable                 ();
	uchar   ph_d_add_disable                ();
	void    ph_d_dlci_event_mgt             ();
	void    ph_d_discard_xmt                ();
	void	ph_d_transmit_tx_done_in		();

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            ph_d - implements the PH_D entity for an SIEMENS ISAC-S.

Usage           uchar ph_d (struct message FAR *p_msg);
					- p_msg : message to process by the PH_D entity.

Return value :  returns = OK
						= NOK

common constants and declarations : ph.h

common objects : p_rcv_msg, p_snd_msg, p_buffer pointers.

*--------------------------------------------------------------------------*/

uchar ph_d (p_msg)
	struct message      FAR *p_msg;         /* pointer on received message */
{
	uchar               FAR *p_data;        /* data pointer */
	it_mask_t                old_mask;      /* old IT mask */
	struct ph_d_config  FAR *p_ph_d_config; /* set config data pointer */
	struct ph_d_na      FAR *p_na_prior;    /* NA prior pointer */
	struct peitab       FAR *p_peitab;      /* PEITAB pointer */
	nai_t                    nai;           /* NA ID */
	struct buffer		FAR *p_buff;		/* temporary buffer pointer */

#   if PH_TX_WATCHDOG_TIMER == ON
		struct message  FAR *p_xmt_msg;     /* pointer on xmit message */
#   endif

		/* Init entity pointers */

	p_rcv_msg   = p_msg;
	p_buffer    = R_msg_p_buffer;
	p_snd_msg   = P_NIL;

	p_data      = R_a_data;
	nai         = R_msg_nai;

		/* Dispatcher : from entity */

	switch (R_msg_from) {

			/*----------------------- From MPH ----------------------------*/

/* 		case ENT_APPLI 	: for internal debug */
		case ENT_MPH 	:

				/* Dispatcher : event code */

			switch (R_msg_code) {

					/* Init requested from MPH entity */

				case MPH_SET_CONFIG_RQ :

						/* Configuration */

					p_ph_d_config           = (struct ph_d_config FAR *)p_data;
					Ph_d_config_ret_code    = ph_d_config (p_ph_d_config);

						/* Retransmit set config confirm to MPH */

					ph_d_retransmit (ENT_MPH, MPH_SET_CONFIG_CO);
					break;

#               if PH_FRAME_ADD_RECOGNITION == ON

					case MPH_DL_DLCI_RQ :

						/*
							DLCI address management :

								- inf0 : code : DL_TEI_ASSIGNMENT or DL_TEI_REMOVE
								- inf1 : SAPI
								- inf2 : TEI
						*/

                        if (ph_d_access_nai (nai) == OK) {
							ph_d_dlci_event_mgt ();
						}
						break;

#               endif

						/* Switch B channel to Codec */

				case MPH_B_SWITCH_RQ :

					if (ph_d_access_nai (nai) == OK) {
						ph_d_switch_b_chan (p_data);
					}

					break;

					/* Init B channel */

				case MPH_B_INIT_RQ :
					break;

					/* Stop Network Access request */

				case MPH_STOP_RQ :

					if (ph_d_access_nai (nai) == OK) {

							/* Send confirmation to MPH */

						ph_d_retransmit (ENT_MPH, MPH_STOP_CO);
					}

					break;

					/* Reset configuration request */

				case MPH_RESET_CONFIG_RQ :

					p_na_prior = P_NIL;

					for (ph_d_access_first_na (); p_ph_d_na != P_NIL; ph_d_access_next_na ()) {

						if (Ph_d_nai == nai) {

#                           if OPTIMIZATION == SPEED

									/* Reset index table */

								p_ph_d_na_tab[Ph_d_nai] = P_NIL;

#                           endif


								/* No more IT path */

							p_tab_peitab_isac [Ph_d_isac_id] = P_NIL;

								/* Update the NA link */

							if (p_na_prior == P_NIL) {
								p_ph_d_top_node = (((struct node FAR *)p_ph_d_na) - 1) -> p_next;

							} else {

								(((struct node FAR *)p_na_prior) - 1) -> p_next =  (((struct node FAR *)p_ph_d_na) - 1) -> p_next;
							}

								/* Free the timer cells associated to the NA */

#							if EQUIPMENT == NT2

								switch (Ph_d_fct) {

									case FG_NT_TE :
										Timer_free (Ti_id (T101));
										Timer_free (Ti_id (T102));
										break;

									case FG_TE_NET :
									case FG_TE_NT  :
									case FG_NT_NET :
										Timer_free (Ti_id (T103));
										Timer_free (Ti_id (T104));
										break;

								}

#							else

								Timer_free (Ti_id (T103));
								Timer_free (Ti_id (T104));
#							endif

#							if PH_D_WA_1 == ON
								Timer_free (Ti_id (T198));
#							endif

#							if PH_TX_WATCHDOG_TIMER == ON
								Timer_free (Ti_id (T199));
#							endif

								/* And free the NA memory block */

							Mem_free ((char FAR *)Ph_d_p_mem_blk, PID_VL);
							break;
						}

						p_na_prior = p_ph_d_na;

					}

						/* Send back confirm to MPH */

					Confirm_ret_code = OK;
					ph_d_retransmit (ENT_MPH, MPH_RESET_CONFIG_CO);
					break;

					/* Information request */

				case MPH_INFO_RQ :

					if (ph_d_access_nai (nai) == OK) {
						p_snd_msg 	= P_NIL;
						p_buff		= P_NIL;
						p_data		= P_NIL;

							/* Build the event message and send it */

						Prepare_data_to_send (p_snd_msg, p_buff, Mph_info_size, p_data);

						if (p_data != P_NIL) {
							Mph_info_entity_origination		= ENT_PH_D;
							Mph_info_type					= INFO_TYPE_STATISTICS;

							Memcpy_far 						((char FAR *)Mph_info_a_chip_id,
															 (char FAR *)"SIEMENS ISAC-S",
															 (uint)PH_CHIP_ID_SIZE);

							Mph_info_rfc					= Ph_d_receive_counter;
							Mph_info_tfc					= Ph_d_transmit_counter;
							Mph_info_ec						= Ph_d_error_counter;

							Mph_info_na_type 				= BRI;

								/* ACT/DEA statistics */

							Mph_info_lost_framing			= Ph_d_lost_framing;
							Mph_info_lost_synchronization	= Ph_d_lost_synchronization;

								/* Transmit information to MPH */

							ph_d_transmit (ENT_MPH, MPH_INFO_CO);
						}

					}

					break;

				case MPH_AR :

					if (ph_d_access_nai (nai) == OK) {

#	            		if EQUIPMENT == NT2

							switch (Ph_d_fct) {

								case FG_TE_NT :
								case FG_TE_NET :
								case FG_NT_NET :
									ph_d_te_activation_deactivation (EV_PH_AR);
									break;

								case FG_NT_TE :
									ph_d_net_activation_deactivation (EV_PH_AR);
									break;
							}

#   	            	else

							ph_d_te_activation_deactivation (EV_PH_AR);
#	                	endif

					}

					break;

						/* Device Management Request */

					case MPH_DEVICE_RQ :
						Ph_device_ret_code 	= OK;
						p_peitab 			= Ph_d_a_peitab;

						switch (Ph_device_fct) {

								/* ARCOFI Management */

							case PH_DEVICE_FCT_ARCOFI_MGT :

#								if (PH_CODEC == ARCOFI_2163) || (PH_CODEC == ARCOFI_2165)

									Arcofi_IOM2_enable(p_peitab);

										/* Codec update */

									Arcofi_ret_code = arcofi_update (p_peitab, Ph_device_a_arcofi);
#								endif

								break;

								/* ISAC POWER UP */

							case PH_DEVICE_FCT_ISAC_POWER_UP :

									/* Enable Power Up */

								sbc_iom2_switch (p_peitab, OFF);
								break;

								/* ISAC ACTIVATE TEST LOOP 3 */

							case PH_DEVICE_FCT_ISAC_TLP3 :

								Ph_device_ret_code = sbc_act_local_loop3 (p_peitab);
								if (Ph_device_ret_code == OK) {
									ph_d_te_activation_action();
									Ph_d_loop3_flag = ON;
								}
								break;

								/* ISAC RESET TEST LOOP 3 */

							case PH_DEVICE_FCT_ISAC_TLP3_STOP :

								Ph_device_ret_code = sbc_reset_local_loop3 (p_peitab);
								if (Ph_device_ret_code == OK) {
									ph_d_te_deactivation_action();
									Ph_d_loop3_flag = OFF;

								}
								break;

								/* ISAC POWER DOWN */

							case PH_DEVICE_FCT_ISAC_POWER_DOWN :

								sbc_iom2_switch (p_peitab, ON);
								break;

#							if PH_CODEC != PH_CODEC_NIL

								case PH_DEVICE_FCT_CODEC_POWER_UP :
									Arcofi_IOM2_enable(p_peitab);
									arcofi_power (p_peitab, ON);
									break;

								case PH_DEVICE_FCT_CODEC_POWER_DOWN :
									Arcofi_IOM2_enable(p_peitab);
									arcofi_power (p_peitab, OFF);
									sbc_iom2_switch (p_peitab, p_peitab -> iom_power_down);
									break;

#							endif

								default :
									Ph_device_ret_code = NOK;
									break;
						}

							/* Confirm to requestor */

						ph_d_retransmit (ENT_MPH, MPH_DEVICE_CO);
						break;

					/* Deactivation Request */

				case MPH_DEA_RQ :

#            		if EQUIPMENT == NT2

						switch (Ph_d_fct) {

							case FG_TE_NT :
							case FG_TE_NET :
							case FG_NT_NET :
								ph_d_te_activation_deactivation (EV_PH_DR);
								break;

							case FG_NT_TE :
								ph_d_net_activation_deactivation (EV_PH_DR);
								break;
						}

#  	            	else

						ph_d_te_activation_deactivation (EV_PH_DR);
#                	endif

					break;

#				if (PH_D_U == ON)

						/* Network access activated */

					case MPH_ACT_IN :

						if (ph_d_access_nai (nai) == OK) {
							p_peitab		= Ph_d_a_peitab;

							if ((p_peitab -> pt_Lay1id == IEC_LAY1) && (Ph_d_active == OFF)) {

								ph_d_send_to_dl_ai          ();
								ph_d_te_activation_action   ();
								ph_state = Ph_d_state	= F7;
								Ph_d_active = ON;
							}
						}
						break;

						/* Network access deactivated */

					case MPH_DEA_IN :

						if (ph_d_access_nai (nai) == OK) {
							p_peitab		= Ph_d_a_peitab;

							if (p_peitab -> pt_Lay1id == IEC_LAY1) {

								ph_d_send_to_dl             (PH_DI);
								ph_d_te_deactivation_action ();
								ph_state = Ph_d_state = F3;
								Ph_d_active = OFF;
							}
						}
						break;
#				endif

					/* Unknown request */

				default :
					break;

			}
			break;

			/*-------------------- From DL entity -----------------------*/

		default :

			if (ph_d_access_nai (nai) == OK) {

				if (Ph_d_ent_dl == R_msg_from) {

					p_peitab = Ph_d_a_peitab;

						/* Dispatcher : event code */

					switch (R_msg_code) {

							/* Send frame requested */

						case PH_DA_RQ :

							if (Ph_d_loop3_flag == ON) {

								Ph_d_ent_maintenance = R_msg_from;
							}

								/* Queue the new incoming Data request */

							It_put_xmt (p_rcv_msg, old_mask); p_rcv_msg = P_NIL, p_buffer = P_NIL;

								/* If the transmitter busy ---> return */

							It_disable_isac (old_mask);

							if (Transmitter_busy) {
								It_enable_isac (old_mask);
								break;
							}

							It_enable_isac (old_mask);

								/* Start the transfer */

							ph_d_start_xmit (ENT_PH_D, p_ph_d_na, STOP);

								/* Return to entity dispatcher */

							break;

							/* Clear the XMIT queue and release the message */

						case PH_CLEAR_RQ :
							p_msg = *(struct message FAR *FAR *)p_data;
							ph_d_clear_xmt (p_msg);
							break;

							/* Activation request */

						case PH_AR :

#	                       if EQUIPMENT == NT2

								switch (Ph_d_fct) {

									case FG_TE_NT :
									case FG_TE_NET :
									case FG_NT_NET :
										ph_d_te_activation_deactivation (EV_PH_AR);
										break;

									case FG_NT_TE :
										ph_d_net_activation_deactivation (EV_PH_AR);
										break;
								}

#   	                    else

								ph_d_te_activation_deactivation (EV_PH_AR);
#	                       endif

							break;

						case PH_DR:

# 	                      if EQUIPMENT == NT2

								switch (Ph_d_fct) {

									case FG_NT_TE :
										ph_d_net_activation_deactivation (EV_PH_DR);
										break;
								}

#	                       endif

							break;

							/* Unexpected message : ignored */

						default :
							break;

					}

#	               if PH_D_AUDIT == ON

						It_disable_isac (old_mask);
							It_xmt_check (ph_d_s_fifo_counter, Ph_d_p_it_xmt_first, Ph_d_p_it_xmt_last, TRAP_TX_FIFO_ERROR, "ph_d");
						It_enable_isac (old_mask);

#	               endif

				} else {

						/* Loop back 3 ON ? */

					if (Ph_d_loop3_flag == ON) {

						p_peitab = Ph_d_a_peitab;

							/* Dispatcher : event code */

						switch (R_msg_code) {

								/* Send frame requested */

							case PH_DA_RQ :

								Ph_d_ent_maintenance = R_msg_from;

									/* Queue the new incoming Data request */

								It_put_xmt (p_rcv_msg, old_mask); p_rcv_msg = P_NIL, p_buffer = P_NIL;

									/* If the transmitter busy ---> return */

								It_disable_isac (old_mask);

								if (Transmitter_busy) {
									It_enable_isac (old_mask);
									break;
								}

								It_enable_isac (old_mask);

									/* Start the transfer */

								ph_d_start_xmit (ENT_PH_D, p_ph_d_na, STOP);

									/* Return to entity dispatcher */

								break;

						}
					}

				}

			}



			break;

			/*---------------- From PH_D interrupt entity -----------------*/

		case ENT_PH_D_IT :

			if (ph_d_access_nai (nai) == OK) {

				p_peitab = Ph_d_a_peitab;

					/* Dispatcher : event code */

				switch (R_msg_code) {

						/* TX  done */

					case PH_IT_XMIT_IN :
						Ph_d_transmit_counter++;

#						if PH_TX_WATCHDOG_TIMER == ON

#							if PH_TX_DONE == ON

								if (R_msg_p_services != P_NIL) {

										/* Restart the TX watchdog timer */

									Start_timer (T199);
									Ph_d_p_xmit_msg = (struct message FAR *)R_msg_p_services;

								} else

#							endif

								{

										/* Stop the TX watchdog timer */

									if (Ti_state (T199) == ON) {
										Stop_timer (T199);
									}

								}

#                       endif

#						if PH_TX_DONE == OFF

							if (R_msg_lib == ON) {
								Free_msg (p_rcv_msg);
							}

							p_rcv_msg   = P_NIL;
							p_buffer    = P_NIL;

#						else

							ph_d_retransmit (Ph_d_ent_dl, PH_TX_DONE_IN);
#						endif

						break;

						/* RX done */

					case PH_IT_RCV_IN :
						Ph_d_receive_counter++;

						if (Buffer_data_size != 0) {

#                       	if MESSAGE_SEND_DATA == ON

									/* Data received hold in a message : transfer */

								if (Buffer_data_size <= Message_data_lgth) {

										/* Copy data from the buffer to the message */

									R_msg_header_init;
									R_msg_p_buffer  = P_NIL;
									R_msg_data_size = Buffer_data_size;

									Memcpy_far ((char FAR *)R_msg_a_start_data, (char FAR *)Buffer_a_start_data, Buffer_data_size);

										/* Deallocate the buffer (to the IT stack */

									Free_buffer (p_buffer);
									p_buffer = P_NIL;
								}

#                       	endif

							if (Ph_d_loop3_flag == ON) {

									/* Send to the maintenance entity */

								ph_d_retransmit (Ph_d_ent_maintenance, PH_DA_IN);

							} else {
									/* Send to the DL_D entity */

								ph_d_retransmit (Ph_d_ent_dl, PH_DA_IN);
							}
						}
						break;

#                   if PH_TX_WATCHDOG_TIMER == ON

						case PH_IT_START_WD_IN :

								/* Start the watchdog timer */

							Start_timer (T199);
							Ph_d_p_xmt_msg = *(struct message FAR *FAR *)p_data;
							break;

#                   endif

						/* Event change received */

					case PH_IT_EVENT_IN :

							/* Execute I.430 state machine for extra events */

#                       if EQUIPMENT == NT2

							switch (Ph_d_fct) {

								case FG_TE_NT :
								case FG_TE_NET :
								case FG_NT_NET :

#									if PH_D_POWER_S == ON

										switch (R_msg_inf0) {

											case EV_LOSS_OF_POWER :
												Start_timer (T105);
												break;

											case EV_DETECTION_OF_POWER :

												if (State_timer (T105) == ON) {
													Stop_timer (T105);

												} else {

													ph_d_te_power_event (R_msg_inf0);
												}

												break;

											default :
												ph_d_te_power_event (R_msg_inf0);
												break;

										}

#									else

										ph_d_te_activation_deactivation (R_msg_inf0);
#									endif

									break;

								case FG_NT_TE :
									ph_d_net_activation_deactivation (R_msg_inf0);
									break;
							}

#                       else

#							if PH_D_POWER_S == ON

								switch (R_msg_inf0) {

									case EV_LOSS_OF_POWER :
										Start_timer (T105);
										break;

									case EV_DETECTION_OF_POWER :

										if (State_timer (T105) == ON) {
											Stop_timer (T105);

										} else {

											ph_d_te_power_event (R_msg_inf0);
										}

										break;

									default :
										ph_d_te_power_event (R_msg_inf0);
										break;

								}

#							else

								ph_d_te_activation_deactivation (R_msg_inf0);
#							endif

#                       endif

#						if PH_D_POWER_S == ON

							if ((R_msg_inf0 != EV_LOSS_OF_POWER) &&
								(R_msg_inf0 != EV_DETECTION_OF_POWER)) {

									/* Update the state change pipe counter */

								It_disable_sbc (old_mask);
									Ph_d_state_pipe_counter--;
								It_enable_sbc  (old_mask);
							}

#						else

								/* Update the state change pipe counter */

							It_disable_sbc (old_mask);
								Ph_d_state_pipe_counter--;
							It_enable_sbc  (old_mask);

#						endif

						break;

					default :
						break;

				}

			}
			break;

				/*--------------------- From Timer entity -----------------*/

			case ENT_TI :

				if (ph_d_access_nai (nai) == OK) {

					p_peitab = Ph_d_a_peitab;

					switch (R_msg_code) {

#                       if PH_TX_WATCHDOG_TIMER == ON

							case TI_199 :

								if (Valid_time_out (T199)) {
									State_timer (T199) = OFF;
									It_read_first_xmt (p_xmt_msg, old_mask);

									switch (Ph_d_state) {

										case F7 :
										case G3 :

											if (p_xmt_msg == Ph_d_p_xmt_msg) {
												icc_reset_tx_channel (Ph_d_a_peitab);
											}

											break;

										default :

												/* Discard message of the transmit FIFO */

											ph_d_discard_xmt ();
											break;

									}

								}
								break;

#                       endif

#                       if EQUIPMENT == NT2

								/* Timer 101 */

							case TI_101 :

								if (Valid_time_out (T101)) {
									State_timer (T101) = OFF;
									ph_d_net_activation_deactivation (EV_TI_101);
								}
								break;

								/* Timer 102 */

							case TI_102 :

								if (Valid_time_out (T102)) {
									State_timer (T102) = OFF;
									ph_d_net_activation_deactivation (EV_TI_102);
								}
								break;

#                       endif

							/* Activation timer expiry */

						case TI_103 :

							if (Valid_time_out (T103)) {
								State_timer (T103) = OFF;
								ph_d_te_activation_deactivation (EV_TI_103);
							}
							break;

							/* Permanent Deactivation timer expiry */

						case TI_104 :

							if (Valid_time_out (T104)) {
								State_timer (T104) = OFF;
								ph_d_te_activation_deactivation (EV_TI_104);
							}
							break;

#       				if PH_D_POWER_S == ON

								/* Loss of power postponed */

							case TI_105 :

								if (Valid_time_out (T105)) {
									State_timer (T105) 	= OFF;

										/*
											Execute now I.430 state machine
											with loss of power event.
										*/

									ph_d_te_power_event (EV_LOSS_OF_POWER);
								}

								break;

#						endif

#						if PH_D_WA_1 == ON

								/* T198 Work around 1 timer expiry */

							case TI_198 :

								if (Valid_time_out (T198)) {
									State_timer (T198) = OFF;
									ph_d_te_activation_deactivation (EV_TI_198);
								}
								break;

#						endif

					}

				}
				break;
	}

		/* Message and buffer stacks management */

	It_stack_mgt ();

		/* Free the remaining messages if necessary */

	if (p_rcv_msg != P_NIL) {

		if (R_msg_lib == ON) {
			Free_msg (p_rcv_msg);

		} else {

			Msg_reset_in_ph_fifo_mark (p_rcv_msg);
		}

	}

	Free_msg (p_snd_msg);

		/* Entity return */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_config - implements the configuration and the
				 initialization of the PH entity.

Usage            void ph_d_config ()

		mmon constants and declarations  ph.h

common : xmit FIFO pointers.

*--------------------------------------------------------------------------*/

uchar ph_d_config (p_ph_d_config)
	struct ph_d_config      FAR *p_ph_d_config;     /* configuration pointer */
{
    struct ph_d_na_config   FAR *p_ph_d_na_config;  /* Na configuration pointer */
	it_mask_t                    old_mask;          /* old IT mask */
	uchar                        i;                 /* current index */
	struct peitab           FAR *p_peitab;          /* PEITAB structure pointer */

		/* Build the object structures */

	if (ph_d_build_object (p_ph_d_config) == NOK) {
		return (NOK);
	}

		/* Init the PH D objects */

	for (i = 0; i < Ph_d_config_na_nb; i++) {

		p_ph_d_na_config = Ph_d_config_a_na(i);

		if (ph_d_access_nai (Ph_d_config_nai) == NOK) {
			return (NOK);
		}

			/* Load PH object */

		Ph_d_isac_id	= Ph_d_config_isac_id;
		p_peitab		= Ph_d_a_peitab;

		Ph_d_ent_dl 	= (Ph_d_config_ent_dl  == 0) ? ENT_DL_D : Ph_d_config_ent_dl;
		Ph_d_ent_mdl 	= (Ph_d_config_ent_mdl == 0) ? ENT_MDL  : Ph_d_config_ent_mdl;

			/* Init IT PEITAB pointer */

		p_tab_peitab_isac [Ph_d_isac_id] = p_peitab;

			/* Init maximum frame size */

		p_peitab -> mx_fr_size  = Ph_d_config_mx_fr_size;

			/* Init IT mask in PEITAB */

		p_peitab -> it_mask     = Ph_d_config_isac_it_mask;

			/* Layer 1 component type */

		switch (Ph_d_config_layer1) {

			case PH_SBC :
				p_peitab -> pt_Lay1id = SBC_LAY1;
				break;

			case PH_IBC :
				p_peitab -> pt_Lay1id = IBC_LAY1;
				return (NOK);

			case PH_IEC :
				p_peitab -> pt_Lay1id = IEC_LAY1;

#				if PH_D_U == OFF
					return (NOK);
#				else
					break;
#				endif

			default :
				return (NOK);
		}

			/* Module mode */

		switch (Ph_d_fct = Ph_d_config_fct) {

			case FG_TE_NT 	:
			case FG_TE_NET 	:
				p_peitab -> pt_ModulMode = PT_MM_TE;
				break;

#			if EQUIPMENT == NT2

				case FG_NT_NET 	:
					p_peitab -> pt_ModulMode = PT_MM_LT_T;
					break;

				case FG_NT_TE :
					p_peitab -> pt_ModulMode = PT_MM_LT_S;
					break;

#			endif

			default :
				 return (NOK);

		}

			/* Set bus mode */

		switch (Ph_d_config_bus_mode) {

			case PH_IOM1 :
				p_peitab -> pt_state = PT_DEV_AT_SLD;
				break;

			case PH_IOM2 :
				p_peitab -> pt_state = PT_IOM2;
				break;

			default :
				return (NOK);
		}

			/* Init the ISAC-S ICC PEITAB  */

		icc_init_peitab (p_peitab, (IO_PORT)Ph_d_config_isac_base_add, Ph_d_config_isac_delta_add);

		p_peitab -> tem_pfs 			= Ph_d_config_tem_pfs;
		p_peitab -> iom_ods 			= Ph_d_config_iom_ods;
		p_peitab -> iom_power_down 		= Set_default (Ph_d_config_iom2_power_down, OFF);
		p_peitab -> iom_csel 			= Ph_d_config_iom2_chani;

		Ph_d_iom_power_down_req = OFF;

			/* Init THE ISAC-S SBC in TE mode */

		if (sbc_init (p_peitab, p_peitab -> pt_ModulMode) == NOK) {
			return (NOK);
		}

#		if PH_D_U == ON
			if (p_peitab -> tem_pfs == PT_ADF1_TM) { /* test mode for U_X functionality */

				Wr_sbc (p_peitab -> pt_r_adfr, ((p_peitab -> tem_pfs) & 0x03) << 4);
			}
#		endif

			/* Loop back B1 and B2 at configuration time */

		if (Ph_d_config_chan_loop_back == ON) {
			icc_loop (p_peitab, ON, 1);
			icc_loop (p_peitab, ON, 2);
		}

#       if PH_ACTIVE_PER_CALL == OFF

				/*
					Init ICC HDLC D channel modulo 128
					and EXTENDED TRANSPARENT mode.
				*/

			icc_init (Ph_d_a_peitab, ON, PT_MD_EXT_TRANSP);

#       endif

			/* Init context variables */

				/* loop back status */

		Ph_d_chan_loop_back = Ph_d_config_chan_loop_back;

		Ph_d_priority = PH_D_PRIORITY_CLASS_1_NORMAL;

#       if EQUIPMENT == NT2

			switch (Ph_d_fct) {

				case FG_NT_TE :

						/* Line init state */

					ph_state = Ph_d_state = G1;

						/* Timer T101 */

					Ti_val (T101)   = (Ph_d_config_ti_101 == 0) ? PH_D_T101_I : Ph_d_config_ti_101;
					Ti_state (T101) = OFF;

					if ((Ti_id (T101) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
						return (NOK);
					}

						/* Timer T102 */

					Ti_val (T102)   = (Ph_d_config_ti_102 == 0) ? PH_D_T102_I : Ph_d_config_ti_102;
					Ti_state (T102) = OFF;

					if ((Ti_id (T102) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
						return (NOK);
					}

					break;

				case FG_TE_NET :
				case FG_TE_NT  :
				case FG_NT_NET :

						/* Line init state */

#                   if PH_D_POWER_S == ON
						ph_state = Ph_d_state 	= F1;
						Ph_d_power_s 			= OFF;

#                   else

						ph_state 			= Ph_d_state = F3;
						Ph_d_power_s 		= ON;
						ph_d_te_send_info   (INFO_0);
						ph_d_send_to_mph    (MPH_II_C);
#                   endif

						/* Timer T103 : Deactivation timer */

					Ti_val (T103)   = (Ph_d_config_ti_103 == 0) ? PH_D_T103_I : Ph_d_config_ti_103;
					Ti_state (T103) = OFF;

					if ((Ti_id (T103) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
						return (NOK);
					}

						/* Timer T104 : Permanent Deactivation timer */

					Ti_val (T104)   = (Ph_d_config_ti_104 == 0) ? PH_D_T104_I : Ph_d_config_ti_104;
					Ti_state (T104) = OFF;

					if ((Ti_id (T104) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
						return (NOK);
					}

					break;

			}

#       else

				/* Line init state */

#           if PH_D_POWER_S == ON

					/* Init : power OFF */

				ph_state 		= Ph_d_state = F1;
				Ph_d_power_s 	= OFF;

#           else

					/* Init : F3 */

				ph_state 			= Ph_d_state = F3;
				Ph_d_power_s 		= ON;
				ph_d_te_send_info   (INFO_0);
				ph_d_send_to_mph    (MPH_II_C);

#           endif

				/* Timer T103 : Deactivation timer */

			Ti_val (T103)   = (Ph_d_config_ti_103 == 0) ? PH_D_T103_I : Ph_d_config_ti_103;
			Ti_state (T103) = OFF;

			if ((Ti_id (T103) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
				return (NOK);
			}

				/* Timer T104 : Permanent Deactivation timer */

			Ti_val (T104)   = (Ph_d_config_ti_104 == 0) ? PH_D_T104_I : Ph_d_config_ti_104;
			Ti_state (T104) = OFF;

			if ((Ti_id (T104) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
				return (NOK);
			}

#       endif

#       if PH_D_POWER_S == ON

				/* Timer T105 : Permanent loss of power timer */

			Ti_val (T105)   = PH_D_T105_I;
			Ti_state (T105) = OFF;

			if ((Ti_id (T105) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
				return (NOK);
			}

#		endif

#		if PH_D_WA_1 == ON				/* Workaround 1 to avoid "Lost framing" event upon receipt of INFO_0 in F6 */

				/* Timer T198 : to avoid "Lost framing" event upon receipt of INFO_0 in F6 */

			Ti_val (T198)   = PH_D_T198_I;
			Ti_state (T198) = OFF;

			if ((Ti_id (T198) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
				return (NOK);
			}

#		endif

#       if PH_TX_WATCHDOG_TIMER == ON

				/* Timer T199 : TX watch dog timer */

			Ti_val (T199)   = (Ph_d_config_ti_199 == 0) ? PH_D_T199_I : Ph_d_config_ti_199;
			Ti_state (T199) = OFF;

			if ((Ti_id (T199) = Timer_alloc (ENT_PH_D, Ph_d_nai, PH_SAPI_D, PH_CHANI_D)) == P_NIL) {
				return (NOK);
			}

#       endif

#		if (PH_CODEC == ARCOFI_2163) || (PH_CODEC == ARCOFI_2165)

				/* Codec present ? */

			if ((Ph_d_codec_id = Ph_d_config_arcofi_id) != 0) {

					/* Init the ARCOFI */

				p_peitab -> pt_Codec = PRESENT;

				Arcofi_IOM2_enable(p_peitab);
				if (arcofi_init (p_peitab,
								 Ph_d_codec_id,
								 Ph_d_config_a_arcofi_sop,
								 Ph_d_config_a_arcofi_tg1,
								 Ph_d_config_a_arcofi_tg2,
								 Ph_d_config_a_arcofi_tg3,
								 Ph_d_config_a_arcofi_tf,
								 Ph_d_config_a_arcofi_cg,
								 Ph_d_config_a_arcofi_gain,
								 Ph_d_config_a_arcofi_sg,
								 Ph_d_config_a_arcofi_cffx,
								 Ph_d_config_a_arcofi_cffr,
								 Ph_d_config_a_arcofi_coefsp,
								 Ph_d_config_a_arcofi_agc_tx,
								 Ph_d_config_a_arcofi_agc_rx
								) == NOK) {
					return (NOK);
				}
			}

#       endif

#		if (PH_CODEC == ARCOFI_2160)

				/* Codec present ? */

			if ((Ph_d_codec_id = Ph_d_config_arcofi_id) != 0) {

					/* Init the ARCOFI */

				p_peitab -> pt_Codec = PRESENT;

				Arcofi_IOM2_enable(p_peitab);
				if (arcofi_imod (p_peitab, Ph_d_codec_id) == NOK) {
					return (NOK);
				}
			}

#		endif

#       if PH_D_U == ON
			Ph_d_active = OFF;				/* initial state: physical deactivation */
#		endif

		Ph_d_loop3_flag = OFF;

		sbc_iom2_switch (p_peitab, p_peitab -> iom_power_down);

			/* Init TX FIFO pointers */

		It_disable_isac (old_mask);
			Ph_d_p_it_xmt_first =
			Ph_d_p_it_xmt_last  = P_NIL;
		It_enable_isac (old_mask);
	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_start_xmit - implements the test of the transmit queue
				 and if needed the initialization of a transmission when the
				 transmitter is not busy.

				 This function is also called by the interruption (ISR) so it
				 shall not used global variables except those protected by the
				 transmitter busy flag.

Usage            uchar ph_d_start_xmit (entity_id, struct ph_d_na FAR *p_ph_d_na, uchar wr_timer_flag)
					- entity_id 	: calling entity ID,
					- ph_d_na   	: NA current pointer.
					- wd_timer_flag : . STOP restart the watch dog timer,
									  . CONTINUE do not restart the watch dog timer

Return value :  returns = STOP      : no more transmission to process.
						= CONTINUE  : transmission in progress.

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

uchar ph_d_start_xmit (entity_id, p_ph_d_na, wd_timer_flag)
	ent_id_t             entity_id;		/* calling entity ID */
	struct ph_d_na  FAR *p_ph_d_na;		/* context pointer */
	uchar				 wd_timer_flag;	/* timer flag */
{
	struct message  FAR *p_msg;   	  	/* message to process */
	it_mask_t            old_mask;  	/* old IT mask */
	struct peitab   FAR *p_peitab;  	/* PEITAB */
	struct buffer	FAR *p_buffer;		/* Local buffer pointer */

		/* load PEITAB pointer */

	p_peitab = Ph_d_a_peitab;

		/* Is the transmit queue empty ? */

	It_read_first_xmt (p_msg, old_mask);

	if (p_msg  != P_NIL) {

#       if PH_TX_WATCHDOG_TIMER == ON

				/* Watchdog timer has been stopped ? */

			if ((wd_timer_flag == STOP) && (State_timer (T199) == OFF)) {

					/* Yes - Restart the TX watchdog timer */

				if (entity_id == ENT_PH_D) {
					Start_timer (T199);
					Ph_d_p_xmt_msg = p_msg;

				}

#				if (PH_TX_DONE == OFF)

					else {

						ph_d_start_tx_watchdog_timer (p_ph_d_na, p_msg);
					}

#				endif

			}

#       endif

				/* IF not active wait for activation */

		switch (Ph_d_state) {

			case F7 :

#				if PH_D_U == ON
					if (p_peitab -> pt_Lay1id != IEC_LAY1) {
#				endif
					/* Change priority */

				if ((L_msg_priority == DL_PRIORITY_SIG) ||
					(Ph_d_loop3_flag == ON)) {

					if (Ph_d_priority != PH_D_PRIORITY_CLASS_1_NORMAL) {
						sbc_act (p_peitab, (Ph_d_priority = PH_D_PRIORITY_CLASS_1_NORMAL));
					}

				} else {

					if (Ph_d_priority != PH_D_PRIORITY_CLASS_2_NORMAL) {
						sbc_act (p_peitab, (Ph_d_priority = PH_D_PRIORITY_CLASS_2_NORMAL));
					}

				}

#				if PH_D_U == ON
					}
#				endif
					/* 	And send the frame : */

#			if EQUIPMENT == NT2
				case G3 :
#			endif

						/* Send the frame */

					if (icc_send_frame (Ph_d_a_peitab, L_data_size, L_a_data) == NOK) {
						Trap (TRAP_TX_ERROR, "ph_d_start_xmit");
					}

				break;

			case F3 :

#				if PH_D_U == ON
					if (p_peitab -> pt_Lay1id != IEC_LAY1) {
#				endif

					/* Restart line activation */

				ph_d_te_activation_deactivation (EV_PH_AR);

					/* Discard the queue if no watch dog timer */

#				if PH_D_U == ON
					}
#				endif

			default :

#       		if PH_TX_WATCHDOG_TIMER == OFF
					ph_d_discard_xmt ();
#				endif

				break;

		}

	} else {

		return (STOP);
	}

	return (CONTINUE);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_retransmit - implements the retansmission of a
				 received message to another entity with another primitive
				 code.

Usage            uchar ph_d_retransmit (entity_t to, code_t code)
					- to    : destination entity,
					- code  : primitive code.

Return value    return code = OK
							= NOK

common constants and declarations  ph.h

common : message/buffer pointers.

*--------------------------------------------------------------------------*/

void ph_d_retransmit (to, code)
	ent_id_t    to;                 /* destination entity */
	code_t      code;               /* primitive code */
{

		/* Address */

	R_msg_from  = ENT_PH_D;         /* origination entity ID */
	R_msg_to    = to;               /* destination entity ID */
	R_msg_sapi  = PH_SAPI_D;        /* MPH SAPI */
	R_msg_chani = PH_CHANI_D;       /* D channel */

		/* Event ID */

	R_msg_code  = code;             /* primitive code */

		/* Send the message */

	Send_message (p_rcv_msg); p_rcv_msg = P_NIL; p_buffer = P_NIL;
}

/*-------------------------------------------------------------------------*/

void ph_d_transmit (to, code)
	ent_id_t    to;                 /* destination entity */
	code_t      code;               /* primitive code */
{

	if (p_snd_msg == P_NIL) {

		if ((p_snd_msg = Alloc_msg ()) == P_NIL) {
			return;
		}

	}

		/* Address */

	S_msg_from  = ENT_PH_D;         /* origination entity ID */
	S_msg_to    = to;               /* destination entity ID */
	S_msg_nai   = Ph_d_nai;         /* NAI */
	S_msg_sapi  = PH_SAPI_D;        /* PH D SAPI */
	S_msg_chani = PH_CHANI_D;       /* D channel */

		/* Event ID */

	S_msg_code  = code;             /* primitive code */

		/* Send the message */

	Send_message (p_snd_msg); p_snd_msg = P_NIL; p_buffer = P_NIL;
}

/*--------------------------------------------------------------------------*/

void ph_d_send_to_dl (code)
	code_t  code;
{
	ph_d_transmit (Ph_d_ent_dl, code);
}

/*--------------------------------------------------------------------------*/

void ph_d_send_to_dl_ai ()
{

#	if PH_TX_DONE == ON
		struct buffer	FAR *p_buff;
		uchar			FAR *p_data;

		p_buff 	= P_NIL;

		Prepare_data_to_send (p_snd_msg, p_buff, Ph_act_size, p_data);

		if (p_data != P_NIL) {

				/* Load the data */

			Ph_act_tx_done	= ON;

				/* Send the message */

			ph_d_transmit (Ph_d_ent_dl, PH_AI);
		}

#	else

		if ((p_snd_msg = Alloc_msg ()) != P_NIL) {
			ph_d_transmit (Ph_d_ent_dl, PH_AI);
		}

#	endif

}

/*-------------------------------------------------------------------------*/

void ph_d_transmit_tx_done_in (p_msg)
	struct message 	FAR *p_msg;		/* message pointer */

{
	L_msg_from 	= ENT_PH_D;			/* origination entity ID */
	L_msg_to	= Ph_d_ent_dl;		/* destination entity ID */
	L_msg_code	= PH_TX_DONE_IN;	/* primitive code */

		/* Send the message */

	Send_message (p_msg);
}

/*--------------------------------------------------------------------------*/

void ph_d_send_to_mdl (code)
	code_t  code;
{
	ph_d_transmit (Ph_d_ent_mdl, code);
}

/*--------------------------------------------------------------------------*/

void ph_d_send_to_mph (code)
	code_t  code;
{
	ph_d_transmit (ENT_MPH, code);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_clear_xmt - implements the clearing of a message
				 in the XMIT waiting queue.

Usage            uchar ph_d_clear_xmt (struct message FAR *p_msg_clear)
					- p_msg_clear : address of the message to clear.

Return value    return code = OK  found,
							= NOK not found.

common constants and declarations  ph.h

common : message/buffer pointers.

*--------------------------------------------------------------------------*/

void ph_d_clear_xmt (p_msg_clear)
	struct message  FAR *p_msg_clear;       /* message to clear */
{
	struct message  FAR *p_msg;             /* current message pointer */
	struct message  FAR *p_msg_prior;       /* current prior message pointer */
	it_mask_t           old_mask;           /* old IT mask */
	struct peitab   FAR *p_peitab;          /* PEITAB pointer */
	uchar				 found = OFF;		/* found in the FIFO */

		/* load PEITAB pointer */

	p_peitab = Ph_d_a_peitab;

	It_disable_isac (old_mask);

	if ((p_msg = Ph_d_p_it_xmt_first) != P_NIL) {

			/* First of the XMIT queue ? ---> ABORT */

		if (p_msg == p_msg_clear) {

			L_msg_lib   = ON;

			icc_reset_tx_channel (Ph_d_a_peitab);
			It_enable_isac (old_mask);
			return;
		}

			/* Next - if found update the XMIT queue */

		for (p_msg_prior = p_msg, p_msg = L_msg_p_services;
			 p_msg != P_NIL;
			 p_msg_prior = p_msg, p_msg = L_msg_p_services) {

			if (p_msg == p_msg_clear) {

					/* Found : remove from the XMIT queue */

				found = ON;

				if ((X_msg_p_services (p_msg_prior) = L_msg_p_services) == P_NIL) {
					Ph_d_p_it_xmt_last  = p_msg_prior;
				}

			}

		}

	}

	if (found == OFF) {

			/* Message Still used (for PH_XMIT_IN report) ? */

		if (Msg_in_ph_fifo (p_msg_clear)) {

				/* Yes - Postpone the releasing of the message */

			p_msg 		= p_msg_clear;
			L_msg_lib 	= ON;

			It_enable_isac (old_mask);


		} else {


			It_enable_isac (old_mask);

#			if PH_TX_DONE == ON
				ph_d_retransmit (Ph_d_ent_dl, PH_CLEAR_CO);

#			else

				Free_msg (p_msg_clear);
#			endif

		}


	} else {

		It_enable_isac (old_mask);
		Free_msg (p_msg_clear);
	}
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_discard_xmt - implements the clearing of the XMIT
				 waiting FIFO.

Usage            void ph_d_discard_xmt (void)

common constants and declarations  ph_d.h

common : message/buffer pointers.

*--------------------------------------------------------------------------*/

void ph_d_discard_xmt ()
{
	struct message FAR *p_msg;              /* current message pointer */
	struct message FAR *p_next_msg;         /* current next message pointer */
	struct peitab  FAR *p_peitab;           /* PEITAB channel pointer */
	it_mask_t           old_mask;           /* old mask */

	p_peitab = Ph_d_a_peitab;

	It_disable_isac (old_mask);

	if ((p_msg = Ph_d_p_it_xmt_first) != P_NIL) {

			/* First of the XMIT queue ? ---> ABORT */

		icc_reset_tx_channel (p_peitab);

		Ph_d_p_it_xmt_first =
		Ph_d_p_it_xmt_last  = P_NIL;

		It_enable_isac (old_mask);

			/* Next - release the message of the FIFO */

		for ( ; p_msg != P_NIL; p_msg = p_next_msg) {
			p_next_msg = L_msg_p_services;

#			if PH_TX_DONE == ON

					 /* Send PH_TX_DONE_IN to DL D */

				 ph_d_transmit_tx_done_in (p_msg); p_msg = P_NIL;

#			else

					/* Message and buffer shall be released ? */

				if (L_msg_lib == ON) {

						/* Release the message */

					Free_msg (p_msg);

				} else {

					Msg_reset_in_ph_fifo_mark (p_msg);
				}

#			endif

		}

	} else {

		It_enable_isac (old_mask);
	}

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_te_power_event - implements the management of the
				 power detection for TEs locally powered and able
				 to detect power 1 or 2.

Usage            uchar ph_d_te_power_event (uchar event_id)
					- event_id : event to process.

Return value

common constants and declarations  ph.h

common : PH na context.

*--------------------------------------------------------------------------*/

#if PH_D_POWER_S == ON

void ph_d_te_power_event (event_id)
	uchar       		event_id;           /* event to process */
{
	struct peitab  FAR *p_peitab;           /* PEITAB channel pointer */

	p_peitab = Ph_d_a_peitab;

		/* DISAPPEARENCE OF POWER S ? */

	if (event_id == EV_LOSS_OF_POWER) {

		Ph_d_power_s = OFF;

			/* disappearence of power S detected */

		switch (Ph_d_state) {

				/*
					If previous state = F6 or F7
					ignore LOST OF POWER.
				*/

			case F6 :
			case F7 :
				event_id = EV_NIL;
				break;

				/* Process LOSS OF POWER */

			default :

					/*
						Stop line management and Disable receiver/transmitter and
						then process LOSS OF POWER.
					*/

				sbc_reset (p_peitab);
				break;

		}

	} else if (event_id == EV_DETECTION_OF_POWER) {

			/* DETECTION OF POWER */

		Ph_d_power_s = ON;

			/*
				Detection of power S :
					if F1 ---> POWER ON enable receiver/transmitter
					else use state.

			*/

		if (Ph_d_state == F1) {

				/* Power ON */

				/* Enable receiver/transmitter */

			sbc_init (p_peitab, p_peitab -> pt_ModulMode);

				/* Process DETECTION OF POWER */

			ph_d_te_activation_deactivation (EV_DETECTION_OF_POWER);

				/* Now read the chip current event and process it */

			event_id = sbc_read_te_event (p_peitab);
		}

	} else {

			/* OTHERS EVENTS */

			/* Is the power OFF ? */

		if (Ph_d_power_s == OFF) {

				/* Yes - no power detected at the S interface */

			switch (Ph_d_state) {

					/* Coming from F6 or F7 and going to F6 or F7 */

				case F6 :
				case F7 :

					switch (event_id) {

							/* If INFO 2 or INFO 4 --> ignore LOSS OF POWER */

						case EV_INFO_2 		:
						case EV_INFO_4_8  	:
						case EV_INFO_4_10 	:
							break;

							/* Else report new event and after report LOSS OF POWER */

						default :

								/* First process current event */

							ph_d_te_activation_deactivation (event_id);

								/* Then process LOSS OF POWER */

							event_id = EV_LOSS_OF_POWER;

								/* Stop SBC and Disable receiver/transmitter */

							sbc_reset (p_peitab);

							break;

					}
					break;

					/* No expected events */

				default :
					sbc_reset (p_peitab);
					event_id = EV_NIL;
					break;

			}

		}

	}

	if (event_id != EV_NIL) {

			/* Process the current event */

		ph_d_te_activation_deactivation (event_id);
	}

}

#endif

/*--------------------------------------------------------------------------*/

		/* Conformance with the CCITT blue book I.430 table C-1/I.430 */

void ph_d_te_activation_deactivation (event_id)
	uchar       event_id;           /* event to process */
{
#	if PH_D_U == ON
		struct peitab       FAR *p_peitab;      /* PEITAB pointer */
#	endif
	uchar   state;                  /* state */

	state = Ph_d_state;

			/* +++++ Event driven automaton ++++++ */

	switch (event_id) {

			/*------------------- Loss of power --------------------*/

		case EV_LOSS_OF_POWER :
			Stop_timer (T103);

			switch (state) {

				case F2 :
					state                       = F1;
					break;

				case F3 :
					ph_d_send_to_mph            (MPH_II_D);
					state                       = F1;
					break;

				case F4 :
				case F5 :
				case F8 :
					ph_d_send_to_mph            (MPH_II_D);
					ph_d_send_to_mph            (MPH_DI);
					ph_d_send_to_dl             (PH_DI);
					state                       = F1;
					break;

				case F6 :

#					if PH_D_WA_1 == ON
						Stop_timer 				(T198);
#					endif

				case F7 :
					break;
			}
			break;

			/*------------------- Detection of power --------------------*/

		case EV_DETECTION_OF_POWER :

			switch (state) {

				case F1 :
					ph_d_send_to_mph            (MPH_II_C);
					ph_d_te_deactivation_action ();
					state                       = F3;
					break;

			}
			break;

			/*------------------- Activate Request --------------------*/

		case EV_PH_AR :

#			if PH_D_U == ON

				p_peitab		= Ph_d_a_peitab;

				if (p_peitab -> pt_Lay1id == IEC_LAY1) {

					if (Ph_d_active == OFF) {

						ph_d_retransmit (ENT_MPH, MPH_ACT_RQ);

					} else {

						break;
					}

				}  else {
#			endif

			switch (state) {

				case F1 :
				case F2 :
					ph_d_send_to_dl             	(PH_DI);
					ph_d_send_to_mph            	(MPH_DI);
					break;

				case F3 :

						/* Already activated ? */

					if (ph_d_te_send_info (INFO_1) == OK) {
						ph_d_send_to_dl_ai          ();
						ph_d_send_to_mph            (MPH_AI);
						ph_d_te_activation_action   ();
						state                       = F7;

					} else {

						Start_timer                 (T103);
						state                       = F4;
					}
					break;

				case F5 :
				case F6 :
				case F8 :

					if (State_timer (T103) == OFF) {
						Start_timer            	   	(T103);
					}
					break;

				case F7 :
					ph_d_send_to_dl_ai     	     	();
					ph_d_send_to_mph            	(MPH_AI);
					break;

			}
#			if PH_D_U == ON
				}
#			endif

			break;

			/*------------------- Deactivate Request --------------------*/

		case EV_PH_DR :

#			if PH_D_U == ON

				p_peitab		= Ph_d_a_peitab;

				if (p_peitab -> pt_Lay1id == IEC_LAY1) {

					if (Ph_d_active == OFF) {

						ph_d_send_to_dl            	(PH_DI);

					} else {

						ph_d_retransmit	(ENT_MPH, MPH_DEA_RQ);
					}
					break;

				}  else {
#			endif

			switch (state) {

				case F1 :
				case F2 :
				case F3 :
					break;

				case F5 :
				case F6 :
				case F8 :
				case F7 :
					ph_d_send_to_mph           	(MPH_DI);
					ph_d_send_to_dl            	(PH_DI);
					ph_d_te_send_info           (INFO_0);
					ph_d_te_deactivation_action ();
					state                       = F3;
					break;

			}

#			if PH_D_U == ON
				}
#			endif

			break;

			/*------------------- Expiry timer T3 ---------------------*/

		case EV_TI_103 :

			switch (state) {

				case F8 :
					ph_d_send_to_mph            (MPH_EI2);

				case F4 :
				case F5 :
					ph_d_send_to_mph            (MPH_DI);
					ph_d_send_to_dl             (PH_DI);
					ph_d_te_send_info           (INFO_0);
					ph_d_te_deactivation_action ();
					state                       = F3;
					break;

				case F6 :

#					if PH_D_WA_1 == ON
						Stop_timer 				(T198);
#					endif

					ph_d_send_to_mph            (MPH_DI);
					ph_d_send_to_dl             (PH_DI);
					ph_d_te_deactivation_action ();
					break;

			}
			break;

			/*------------------- Expiry timer T4 ---------------------*/

		case EV_TI_104 :

			if (state != F7) {
				ph_d_send_to_mph            	(MPH_DI);
				ph_d_send_to_dl             	(PH_DI);
			}
			break;

			/*-------------------- Receiving INFO 0 --------------------*/

		case EV_INFO_0 :

			switch (state) {

				case F2 :
					ph_d_send_to_mph            (MPH_II_C);
					ph_d_te_send_info           (INFO_0);
					ph_d_te_deactivation_action ();
					state                       = F3;
					break;

				case F8 :
					ph_d_send_to_mph            (MPH_EI2);

				case F7 :
					Start_timer                 (T104);
					ph_d_te_send_info           (INFO_0);
					ph_d_te_deactivation_action ();
					state                       = F3;
					break;

				case F6 :

#					if PH_D_WA_1 == ON
						Stop_timer 				(T198);
#					endif

					ph_d_send_to_mph            (MPH_DI);
					ph_d_send_to_dl             (PH_DI);
					ph_d_te_send_info           (INFO_0);
					ph_d_te_deactivation_action ();
					state                       = F3;
					break;

			}
			break;

			/*------------------- Receiving any signal -----------------*/

		case EV_ANY_SIGNAL :

			switch (state) {

				case F4 :
					state                       = F5;
					break;

			}
			break;

			/*--------------------  Receiving INFO 2 -------------------*/

		case EV_INFO_2 :

			switch (state) {

				case F1 :
				case F2 :
					ph_d_send_to_mph            (MPH_II_C);
					state                       = F6;
					break;

				case F3 :
				case F4 :
				case F5 :
					state                       = F6;
					break;

				case F7 :
				case F8 :
					Ph_d_lost_synchronization++;
					ph_d_send_to_mph            (MPH_EI1);
					state                       = F6;
					break;

			}
			break;

			/*--------------------- Receiving INFO 4 -------------------*/

		case EV_INFO_4_8  :
		case EV_INFO_4_10 :

			if (event_id == EV_INFO_4_8) {
				Ph_d_priority = PH_D_PRIORITY_CLASS_1_NORMAL;

			} else {

				Ph_d_priority = PH_D_PRIORITY_CLASS_2_NORMAL;
			}

					/* Active state : stop CCITT T3 and ETSI timer T4 */

			Stop_timer                          (T103);
			Stop_timer                          (T104);

			switch (state) {

				case F1 :
				case F2 :
					ph_d_send_to_mph            (MPH_II_C);

				case F3 :
				case F4 :
				case F5 :
					ph_d_send_to_dl_ai          ();
					ph_d_send_to_mph            (MPH_AI);
					ph_d_te_activation_action   ();
					state                       = F7;
					break;

				case F6 :

#					if PH_D_WA_1 == ON
						Stop_timer 				(T198);
#					endif

				case F8 :
					ph_d_send_to_dl_ai          ();
					ph_d_send_to_mph            (MPH_AI);
					ph_d_send_to_mph            (MPH_EI2);
					ph_d_te_activation_action   ();
					state                       = F7;
					break;

			}
			break;

			/*---------------------- Lost framing ---------------------*/

		case EV_LOST_FRAMING :

			switch (state) {

					/* Equivalent to any signal */

				case F4 :
					state                       = F5;
					break;

					/* Other cases = LOST FRAMING */

				case F6 :

#					if PH_D_WA_1 == ON

							/* Delay LOST FRAMING event */

						Start_timer (T198);
						break;

#					endif

				case F7 :
					Ph_d_lost_framing++;
					ph_d_send_to_mph            (MPH_EI1);
					state                       = F8;
					break;

			}
			break;

#		if PH_D_WA_1 == ON

				/* Delay LOST FRAMING signal */

			case EV_TI_198 :

				if (state == F6) {
					Ph_d_lost_framing++;
					ph_d_send_to_mph            (MPH_EI1);
					state                       = F8;
				}
				break;

#		endif

	}
	ph_state = Ph_d_state = state;
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_te_send_info - implements the sending of INFO 0, 1, 2, 3,
				 4 on the S0 line interface.

Usage            void uchar ph_d_te_send_info (uchar code)
					- code : type of INFO.


Return code = OK already done,
			= NOK not already done ... under the way.


common constants and declarations  ph.h

common : p_peitab

*--------------------------------------------------------------------------*/

uchar ph_d_te_send_info (code)
    uchar                code;
{
	struct peitab   FAR *p_peitab = Ph_d_a_peitab;

	switch (code) {

			/* Sending INFO 0 : deactivation */

		case INFO_0 :
			sbc_dea (p_peitab);
			return (sbc_reset (p_peitab));

			/* Sending INFO 1 : activation  */

		case INFO_1 :
			return (sbc_act (p_peitab, PH_D_PRIORITY_CLASS_1_NORMAL));

			/* Sending INFO 3 : done by the component */

		case INFO_3 :
			break;

	}

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_net_send_info - implements the sending of INFO 0, 1, 2, 3,
				 4 on the S0 line interface.

Usage            void uchar ph_d_net_send_info (uchar code)
					- code : type of INFO.


Return code = OK already done,
			= NOK not already done ... under the way.


common constants and declarations  ph.h

common : p_peitab

*--------------------------------------------------------------------------*/

uchar ph_d_net_send_info (code)
    uchar                code;
{
	struct peitab   FAR *p_peitab = Ph_d_a_peitab;

    switch (code) {

            /* Sending INFO 0 : deactivation */

		case INFO_0 :
			sbc_dea (p_peitab);
			return (sbc_reset (p_peitab));

            /* Sending INFO 2 : activation */

        case INFO_2 :
			return (sbc_act (p_peitab, PH_D_PRIORITY_CLASS_1_NORMAL));

            /* Sending INFO 4 : done by the component */

		case INFO_4 :
			sbc_info_4 (p_peitab);
            break;
    }

    return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_te_activation_action - implements the activation action
				 on the S0 interface.

Usage            void uchar ph_d_te_activation_action (void)

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

void ph_d_te_activation_action ()
{

#   if PH_ACTIVE_PER_CALL == ON

		struct peitab   FAR *p_peitab;

			/* Enable all IT */

		p_peitab = Ph_d_a_peitab;

		Wr_icc  (p_peitab -> pt_r_mask,(uchar)0);

            /*
				Init ICC HDLC D channel modulo 128
				and EXTENDED TRRANSPARENT mode.
            */

		icc_init (p_peitab, ON, PT_MD_EXT_TRANSP);

#   endif

	Ph_d_state = F7;

		/* Restart the transmit queue */

	ph_d_start_xmit (ENT_PH_D, p_ph_d_na, STOP);

}

/*--------------------------------------------------------------------------*
                     F U N C T I O N   H E A D E R

Name             ph_d_te_deactivation_action - implements the deactivation action
				 on the S0 interface.

Usage            void uchar ph_d_te_deactivation_action (void)

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

void ph_d_te_deactivation_action ()
{

#   if PH_ACTIVE_PER_CALL == ON
	struct peitab   FAR *p_peitab;

		p_peitab = Ph_d_a_peitab;

		ph_d_discard_xmt ();

			/*  Reset ICC HDLC. */

		icc_reset (p_peitab);

			/* No more ICC interrupt */

		Wr_icc  (p_peitab -> pt_r_mask,(uchar)(~(ISTA_CIC)));

#   else

			/* Discard the Tx FIFO */

		ph_d_discard_xmt ();

#   endif

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_switch_b_chan - implements the switching of a B channel
				 according to data contained in a message received from CC
				 thru MPH.

Usage            void uchar ph_d_switch_b_chan (p_data)
					- p_data : pointer on the mph_d_b_switching data structure.

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

void ph_d_switch_b_chan (p_data)
	uchar           FAR *p_data;        /* switch data structure */
{
	struct peitab   FAR *p_peitab;

	p_peitab = Ph_d_a_peitab;

	switch (Mph_b_switch_mode) {

#		if (PH_CODEC == ARCOFI_2160) || (PH_CODEC == ARCOFI_2163) || (PH_CODEC == ARCOFI_2165)

				/* Voice */

			case B_MODE_VOICE :

					/* USER AUDIO FUNCTIONS : INIT */

				Ph_b_init_codec_voice (device_id,chan_id);

				if (Ph_d_codec_id != 0) {

					Arcofi_IOM2_enable(p_peitab);

						/* Channel to assign to the ARCOFI Codec */

					arcofi_assign_voice (p_peitab, (Ph_d_codec_chan_id = Mph_b_switch_chan_id));
				}
				break;

#		endif

		case B_MODE_AUDIO :
			Ph_b_init_codec_audio (Ph_d_device_id, (Ph_d_codec_chan_id = Mph_b_switch_chan_id));
			break;

		case B_MODE_LOOP_BACK_ON :
			icc_loop (p_peitab, ON, Mph_b_switch_chan_id);
			break;

		case B_MODE_LOOP_BACK_OFF :
			icc_loop (p_peitab, OFF, Mph_b_switch_chan_id);
			break;

			/* Stop channel */

		case B_MODE_NIL :
			icc_switch_b_channel (p_peitab, Mph_b_switch_chan_id);

				if ((Ph_d_codec_id != 0) &&
					(Mph_b_switch_chan_id == Ph_d_codec_chan_id)) {

					Ph_b_stop_codec (Ph_d_device_id, Ph_d_codec_chan_id);

#					if (PH_CODEC == ARCOFI_2160) || (PH_CODEC == ARCOFI_2163) || (PH_CODEC == ARCOFI_2165)

						Arcofi_IOM2_enable(p_peitab);
							/* Channel to assign to the ARCOFI Codec */

						arcofi_assign_voice (p_peitab, (Ph_d_codec_chan_id = NO_CHANNEL));
# 		     	 	endif
				}


			break;

			/* Others */

		default :
			icc_switch_b_channel (p_peitab, Mph_b_switch_chan_id);
			break;

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_stop_b_chan - implements the switching of a B channel
				 according to data contained in a message received from CC
				 thru MPH.

Usage            void uchar ph_d_stop_b_chan (p_data)
					- p_data : pointer on the mph_d_b_switching data structure.

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

void ph_d_stop_b_chan (p_data)
	uchar           FAR *p_data;        /* switch data structure */
{
	struct peitab   FAR *p_peitab;

	p_peitab = Ph_d_a_peitab;

	switch (Mph_b_init_mode) {

#		if (PH_CODEC == ARCOFI_2160) || (PH_CODEC == ARCOFI_2163) || (PH_CODEC == ARCOFI_2165)

			case B_MODE_VOICE :
				break;
#       endif


		default :
			icc_switch_b_channel (p_peitab, PH_CHANI_NIL);
			break;

	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_dlci_event_mgt - implements management of a DLCI address
				 event coming from MDL.

Usage            void ph_d_dlci_event_mgt (void)

				 received message :

						- inf0 : code : DL_TEI_ASIGNMENT or DL_TEI_REMOVE
						- inf1 : SAPI
						- inf2 : TEI

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

#if PH_FRAME_ADD_RECOGNITION == ON

void ph_d_dlci_event_mgt ()
{
	ushort  i;


		/* Address recognition management ON ? */

	if (Ph_d_add_flag == ON) {

		switch (R_msg_inf0) {

				/* TEI assignment */

			case DL_TEI_ASSIGNMENT :

					/* search TEI in the table */

				for (i = 0; i < ADD_REG_NB; i++) {

					if (Ph_d_p_add_reg[i] == R_msg_inf2) {
						break;
					}

				}

					/* Found ? */

				if (i == ADD_REG_NB) {

						/* NO - search a hole */

					for (i = 0; i < ADD_REG_NB; i++) {

						if (Ph_d_p_add_reg[i] == DL_TEI_NIL) {
                            break;
						}

                    }

						/* Hole found ? saturation */

					if (i == ADD_REG_NB) {

							/* NO --> Disable all address recognition */

                        for (i = 0; i < ADD_REG_NB; i++) {
                            ph_d_add_disable (i);
                        }

							/* Address recognition flag to OFF */

                        Ph_d_add_flag = OFF;
                        break;

					} else {

							/* YES - enable the TEI */

						ph_d_add_enable (i, (Ph_d_p_add_reg[i] = R_msg_inf2));
                    }

				}
				break;

				/* TEI removal */

            case DL_TEI_REMOVAL :

					/* search TEI in the table */

                for (i = 0; i < ADD_REG_NB; i++) {

					if (Ph_d_p_add_reg[i] == R_msg_inf2) {

							/*
                                Found - disable the TEI and relesae
								the register location.
							*/

						ph_d_add_disable (i);
						Ph_d_p_add_reg[i] = DL_TEI_BROADCAST;

                    }

				}
                break;

		}

	}

}

#endif

/*--------------------------------------------------------------------------*
                     F U N C T I O N   H E A D E R

Name             ph_d_add_enable & mph_d_add_disable - implements the frame
				 address recognition enabling and disabling action.

Usage            uchar ph_d_add_enable (uchar reg, uchar tei)
                    - reg   : register number,
                    - tei   : TEI value.

				 uchar mph_d_add_disable (uchar reg)
                    - reg   : register number,

Return value    return code = OK  done
                            = NOK error

common constants and declarations  ph.h

common : message/buffer pointers.

*--------------------------------------------------------------------------*/

#if PH_FRAME_ADD_RECOGNITION == ON

uchar ph_d_add_enable (reg, tei)
	uchar                   reg;            /* register to enable */
	uchar                   tei;            /* TEI value */
{

	return (NOK);
}

/*-------------------------------------------------------------------------*/

uchar ph_d_add_disable (reg)
	uchar                   reg;            /* register to disable */
{
	return (OK);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_net_activation_deactivation - implements activation/
				 deactivation automaton for NETWORK side.

Usage            uchar ph_d_net_activation_deactivation (uchar event_id)
					- event_id : event to process.

Return value    return code = OK  done
							= NOK error

remark          the SIEMENS SBC is performing the I.430 automata and sends
				the ad hoc response to the outside. This automaton is in
				charge of managing the events not coming from outside and
				complementing the actions in the others cases.

common constants and declarations  ph.h

common : PH na context.

*--------------------------------------------------------------------------*/

#if EQUIPMENT == NT2

		/* Conformance with the CCITT blue book I.430 table C-1/I.430 */

void ph_d_net_activation_deactivation (event_id)
	uchar       event_id;           /* event to process */
{
	uchar   state;                  /* state */

	state = Ph_d_state;

			/* +++++ Event driven automaton ++++++ */

	switch (event_id) {

			/*------------------- Activate request --------------------*/

		case EV_PH_AR :

			switch (state) {

				case G1 :
				case G4 :
					Stop_timer                  (T102);
					ph_d_net_send_info          (INFO_2);
					Start_timer                 (T101);
					state                       = G2;
					break;

			}
			break;

			/*------------------- Deactivate request --------------------*/

		case EV_PH_DR :

			switch (state) {

				case G2 :
				case G3 :
					Stop_timer                  (T101);
					ph_d_send_to_dl             (PH_DI);
					ph_d_net_deactivation_action();
					ph_d_net_send_info          (INFO_0);
					Start_timer                 (T102);
					state                       = G4;
					break;

			}
			break;

			/*------------------- Expiry timer T1 ---------------------*/

		case EV_TI_101 :

			switch (state) {

				case G2 :
					ph_d_net_deactivation_action();
					ph_d_net_send_info          (INFO_0);
					ph_d_send_to_dl             (PH_DI);
					Start_timer                 (T102);
					state                       = G4;
					break;

			}
			break;

			/*------------------- Expiry timer T2 ---------------------*/

		case EV_TI_102 :

			switch (state) {

				case G4 :
					ph_d_net_deactivation_action();
					ph_d_net_send_info          (INFO_0);
					state                       = G1;
					break;

			}
			break;

			/*-------------------- Receiving INFO 0 --------------------*/

		case EV_INFO_0 :

			switch (state) {

				case G3 :
					ph_d_net_deactivation_action();
					Stop_timer					(T102);
					state                       = G2;
					break;

				case G4 :
					Stop_timer                  (T102);
					ph_d_net_send_info          (INFO_0);
					state                       = G1;

			}
			break;

			/*--------------------  Receiving INFO 1 -------------------*/

		case EV_INFO_1 :

			switch (state) {

				case G1 :
					ph_d_net_send_info          (INFO_2);
					Start_timer                 (T101);
					state                       = G2;
					break;

			}
			break;

			/*--------------------- Receiving INFO 3 -------------------*/

		case EV_INFO_3 :

			switch (state) {

				case G2 :
					Stop_timer                  (T101);
					ph_d_net_activation_action  ();
					ph_d_net_send_info          (INFO_4);
					ph_d_send_to_dl_ai          ();
					ph_d_send_to_mph            (MPH_AI);
					state                       = G3;
					break;

			}
			break;

			/*---------------------- Lost framing ---------------------*/

		case EV_LOST_FRAMING :

			switch (state) {

				case G3:
					ph_d_net_deactivation_action();
					ph_d_net_send_info          (INFO_2);
					ph_d_send_to_mph            (MPH_DI);
					ph_d_send_to_mph            (MPH_EI);
					state                       = G2;
					break;

			}
			break;

	}

	ph_state = Ph_d_state = state;
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_net_activation_action - implements the activation action
				 on the S0 interface network side.

Usage            void uchar ph_d_net_activation_action (void)

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

#if EQUIPMENT == NT2

void ph_d_net_activation_action ()
{

#   if PH_ACTIVE_PER_CALL == ON

	struct peitab   FAR *p_peitab;

			/* Enable all IT */

		p_peitab = Ph_d_a_peitab;

		Wr_icc  (p_peitab -> pt_r_mask, (uchar)0);

			/*
				Init ICC HDLC D channel modulo 128
				and EXTENDED TRRANSPARENT mode.
			*/

		icc_init (p_peitab, ON, PT_MD_EXT_TRANSP);

#   endif

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             ph_d_net_deactivation_action - implements the deactivation action
				 on the S0 interface network side.

Usage            void uchar ph_d_net_deactivation_action (void)

common constants and declarations  ph.h

common :

*--------------------------------------------------------------------------*/

#if EQUIPMENT == NT2

void ph_d_net_deactivation_action ()
{

#   if PH_ACTIVE_PER_CALL == ON

	struct peitab   FAR *p_peitab;

		p_peitab = Ph_d_a_peitab;

		ph_d_discard_xmt ();

            /*  Reset ICC HDLC. */

		icc_reset (p_peitab);

			/* No more ICC SBC interrupt */

		Wr_icc  (p_peitab -> pt_r_mask, (uchar)(~(ISTA_CIC)));

#   endif

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				ph_d_var_init - init of PH_D entity's global variables.

Usage            	void ph_d_var_init ();

Return value :		void

*--------------------------------------------------------------------------*/

void ph_d_var_init ()
{
		p_ph_d_top_node 	= P_NIL;    /* Top node pointer */
		p_tab_peitab_isac	= P_NIL; 	/* PH D PEITAB pointer table ISAC-S */

#		if OPTIMIZATION == SPEED
			p_ph_d_na_tab	= P_NIL;	/* NA access index table */
#		endif

}

/*EOF*/
