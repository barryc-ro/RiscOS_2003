
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - arcofi.c
 *
 * $Revision$
 *
 * $Date$
 *
 * ARCOFI 2160 functions:
 *
 * arcofi_imod         -
 * arcofi_power        -
 * arcofi_op_mode      -
 * arcofi_set_loud     -
 * arcofi_sidetone     -
 * arcofi_b_usage      -
 * arcofi_time_freq    -
 * arcofi_set_ampl     -
 * arcofi_set_tone     -
 * arcofi_ctrl_dtmf    -
 * arcofi_init_hands   -
 * arcofi_init_tx      -
 * arcofi_init_rx      -
 * arcofi_search_btmap -
 * arcofi_assign_voice -
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Siemens ISAC-S Driver                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

/***************************************************************************
 *                                                                         *
 *    SIEMENS ISDN-Userboard  (c) 1987-1989                                *
 *    ======================                                               *
 *                                                                         *
 *    Firmware:   ARCOFI driver                                            *
 *    File    :   arcofi.c                                                 *
 *    created :   Sept. 1988                                               *
 *    author  :   Peter Mueller                                            *
 *    compiled:   Microsoft C compiler 5.1 (small memory model)            *
 *                                                                         *
 ***************************************************************************/


   /* History
	  ======================================================================
	  date     author            reason

				  1989

	  Sept. 5  PM          The time tone and beat frequency coefficients in
						   the corresponding tables are only valid for
						   ARCOFI versions >= B1. The frequency coefficients
						   in the table are for trapezoid wave forms.

	  --------------------------------------------------------------------*/

   /*
	  The following set of functions can be used to program the ARCOFI.
	  There are driver functions to
	  - power up/down the ARCOFI.
	  - set the operating mode (ready, loud hearing 1/2/3, hands free, mute)
	  - set the loudness (= gain of the receive path)
	  - set the sidetone level
	  - choose the B channel to be used
	  - set beat tone frequency, amplitude and time
	  - switch the beat tone on and off
	  - control the DTMF generator

	  One of the functions in this source file  ( imod_arcofi () )
	  is called once during the system setup if an ARCOFI was detected.
	  The imod_arcofi () function is responsible for the initialization of
	  the local tables (e.g. which hold some coefficients) and
	  variables (for example the current value of the ARCOFI CMDR register).
	  The tables are necessary to support features like 'loudness up
	  /down' or the mapping of frequency/amplitude/time values to
	  coefficients (which can be written to the ARCOFI).
   */

#define ENTITY ENT_PH_D

   /* Include Files
	  =============  */

#include "ph_d.h"

#if PH_CODEC == ARCOFI_2160 /* { */

   /* Defines
	  ======= */

	/* flags of ARCOFI CR  registers          */

#define  CR4_LAW     0x01
#define  CR4_PM      0x02
#define  CR4_BM      0x04
#define  CR4_TM      0x08
#define  CR4_BT      0x10
#define  CR4_TG      0x20
#define  CR4_DTMF    0x40
#define  CR4_DHF     0x80

#define  CR2_TR      0x02

#define  CR1_GR      0x80
#define  CR1_GZ      0x40
#define  CR1_FX      0x20
#define  CR1_FR      0x10
#define  CR1_GX      0x08

	/* Flags of ARCOFI CMDR register          */

#define  CMDR_RCS    0x10       /* 1 / 0 : B2/B1 channel;              */
#define  CMDR_PU     0x20       /* 1 / 0 : powered up/down             */
#define  CMDR_RW     0x40       /* 1 / 0 : R/W from/to Arcofi          */
#define  CMDR_AD     0x80       /* SIP state in TX                     */

#define  B1_CH       0x00
#define  B2_CH       0x01
#define  B1B2_CH     0x02

	/* Maximum and minimum values of    */
	/* the coefficient table entries    */

#define  MAX_GAIN_TAB   13      /* # of entries in the gain table   */
#define  MAX_AMP_TAB    11      /* # of entries in the amplitude    */
								/* table                            */

#define  FREQ_TAB_MAX   11      /* length of frequency coefficient  */
								/* table                            */
#define  FREQ_MIN       25      /* lowest frequency value  [Hz]     */
#define  FREQ_MAX       1777    /* highest frequency value [Hz]     */
								/*  in the table                    */

#define  TIME_TAB_MAX   13      /* maximum length of time           */
								/* coefficient table                */
#define  TIME_MIN       20      /* lowest beat time value  [ms]     */
#define  TIME_MAX       4096    /* highest beat time value [ms]     */
								/*  in the table                    */
		   /* Local Functions
			  ===============   */

#if NEW_FCT_STYLE == ON
	int				arcofi_power 		(struct peitab 	FAR *p_peitab, uchar pu);
	int 			arcofi_op_mode 		(struct peitab 	FAR *p_peitab, uchar mode);
	int 			arcofi_set_loud 	(struct peitab 	FAR *p_peitab, uchar up);
	int 			arcofi_set_tone 	(struct peitab 	FAR *p_peitab, uchar on, uchar signal_mix, uchar tonetype, uchar outp_ctrl);
	int 			arcofi_sidetone 	(struct peitab 	FAR *p_peitab, uchar level);
	int 			arcofi_b_usage 		(struct peitab 	FAR *p_peitab, uchar channel);
	int 			arcofi_time_freq 	(struct peitab 	FAR *p_peitab, int beattime, uchar mapping, uchar tg_id, uchar reg_h, uchar reg_l);
	int 			arcofi_set_ampl 	(struct peitab 	FAR *p_peitab, uchar mapping, uchar tg_id, uchar reg);
	int 			arcofi_ctrl_dtmf 	(struct peitab 	FAR *p_peitab, uchar on, uchar h_group, uchar l_group);
	int 			arcofi_init_hands 	(struct peitab 	FAR *p_peitab, uint cnt, uchar FAR *frame);
	int 			arcofi_init_tx 		(struct peitab 	FAR *p_peitab, uint cnt, uchar FAR *frame);
	int 			arcofi_init_rx 		(struct peitab 	FAR *p_peitab, uint cnt, uchar FAR *frame);
	ushort 			arcofi_search_btmap (struct peitab 	FAR *p_peitab, int beattime, uchar hbyte, uchar lbyte);

#else

	int            	arcofi_power 		();
	int            	arcofi_op_mode 		();
	int            	arcofi_set_loud		();
	int            	arcofi_sidetone 	();
	int 			arcofi_set_tone 	();
	int            	arcofi_b_usage 		();
	int            	arcofi_time_freq 	();
	int            	arcofi_set_ampl 	();
	int            	arcofi_ctrl_dtmf 	();
	int            	arcofi_init_hands 	();
	int            	arcofi_init_tx 		();
	int            	arcofi_init_rx 		();
	ushort         	arcofi_search_btmap ();
#endif

		   /* Variables */

	static			int         curr_gain;     /* current position in gaintable       */
	static  		uchar	  	curr_channel;  /* B channel currently assigned        */
					uchar       arc_cmdr;      /* used to store ARCOFI CMDR bits 4..7
												(the CMDR can't be read !)       */

	static  		ushort      gaintable	[MAX_GAIN_TAB];
	static  		uchar       ampli_table	[MAX_AMP_TAB];
	static  		ushort      freq_coeff	[FREQ_TAB_MAX];
	static  		ushort      freqtable	[FREQ_TAB_MAX];
	static  		ushort      btime_coeff	[TIME_TAB_MAX];
	static  		ushort      btime_table	[TIME_TAB_MAX];
	static  		uchar       level_tab	[4];

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_imod ()                                             *
 *    Parms   : none                                                       *
 *    Purpose : Initialize the tables for the ARCOFI drivers               *
 *              Do a default setup for the ARCOFI to ensure compatibility  *
 *              to elder protocol software version which do not support    *
 *              the ARCOFI.
 *                                                                         *
 *             NOTE: If it is neccessary to provide country specific       *
 *                   beat time and beat frequency values to generate       *
 *                   the specific sidetones in the handset,                *
 *                   the coefficient tables as well as the tables with the *
 *                   corresponding time [ms] / frequency [Hz] values must  *
 *                   be changed                                            *
 *                                                                         *
 ***************************************************************************/

int arcofi_imod (p_peitab, arcofi_id)
	register struct peitab 	FAR *p_peitab;
	uchar						 arcofi_id;
{
	uchar  						 frame [26];
	int   						 exe_state = OK;
	uchar						 id_code [2];

	curr_gain 		= 0;
	curr_channel 	= 0;
	arc_cmdr    	= 0;

		/* init ARCOFI address */

	addr_mon1 (p_peitab, (uchar)(arcofi_id | 1));

		/* Read ARCOFI ID */

	mon1_ident (p_peitab, (Mon1_addr & 0xfe), id_code);

		/*
			GAIN table        ( GR reg. 1 + 2 values for gain adjustment )
			==========
					  range :=  {-45,-40,-35,-30,-25,-20,-15,-10,-5,0,5,10,14}[dB]
					  with gaintable[0] for -45dB, gaintable[1] for -40dB, ...
		*/

	gaintable[0]   = 0xF83A;	/* = - 45 dB                        */
	gaintable[1]   = 0xF832;    /* = - 40 dB                        */
	gaintable[2]   = 0xE843;
	gaintable[3]   = 0xD8A6;
	gaintable[4]   = 0xC8BB;
	gaintable[5]   = 0xB8BA;
	gaintable[6]   = 0xB8B1;
	gaintable[7]   = 0x29C1;
	gaintable[8]   = 0xB988;
	gaintable[9]   = 0x8888;
	gaintable[10]  = 0x1192;
	gaintable[11]  = 0x1012;
	gaintable[12]  = 0x0000;    /* = 14 dB                          */

		/*
			AMPLITUDE table   ( reg. values for beat amplitude adjustment )
			===============   range :=  from 0 to -50 dB in 5 dB steps
							  with ampli_table[0] = 0dB, ampli_table[1] = -5dB, ...
		*/

	ampli_table[0]  = 0x00;     /* = 0 dB                           */
	ampli_table[1]  = 0x30;     /* = - 5 dB                         */
	ampli_table[2]  = 0x21;
	ampli_table[3]  = 0xA1;
	ampli_table[4]  = 0xA2;
	ampli_table[5]  = 0xB3;
	ampli_table[6]  = 0x74;
	ampli_table[7]  = 0x35;
	ampli_table[8]  = 0x26;
	ampli_table[9]  = 0xA6;
	ampli_table[10] = 0xA7;     /* = -50 dB                         */

		/*
			FREQ tables :  'freqtable' holds the frequency, 'freq_coeff' the
			===========    corresponding coefficients, i.e.
						   the frequency stored in freqtable[i] can be programmed
						   using the coefficients in freq_coeff[i];  i = {0,..,10}

						   Note: The coefficients below are for trapeciod waves only!
		*/

	freq_coeff[0]   = 0xA7AA;   /* -> freqtable[0] : 25 Hz          */
	freq_coeff[1]   = 0xA6AA;
	freq_coeff[2]   = 0xA3AA;
	freq_coeff[3]   = 0xB3A2;
	freq_coeff[4]   = 0xB3AA;
	freq_coeff[5]   = 0xA2AA;
	freq_coeff[6]   = 0xA2AA;
	freq_coeff[7]   = 0xC2AA;
	freq_coeff[8]   = 0x5232;
	freq_coeff[9]   = 0x12AA;
	freq_coeff[10]  = 0xB1AA;

								/* corresponding frequencies in [Hz]      */
	freqtable[0]  = 25;         /* coeff. for 25 Hz are in freq_coeff[0]  */
	freqtable[1]  = 50;
	freqtable[2]  = 400;
	freqtable[3]  = 425;
	freqtable[4]  = 450;
	freqtable[5]  = 575;
	freqtable[6]  = 800;
	freqtable[7]  = 950;
	freqtable[8]  = 1040;
	freqtable[9]  = 1400;
	freqtable[10] = 1777;

		/*
			BEAT TIME tables: btime_table[i] holds the beat time in [ms] and the
			btime_coeff[i] the corresponding 2 coefficient bytes
		*/

	btime_coeff[0]   = 0xA2BA;  /* = 20 ms : btime_table[0]         */
	btime_coeff[1]   = 0xA3BA;
	btime_coeff[2]   = 0xA3B1;
	btime_coeff[3]   = 0xC4A1;
	btime_coeff[4]   = 0xA4B1;
	btime_coeff[5]   = 0xB5A2;
	btime_coeff[6]   = 0x26A2;
	btime_coeff[7]   = 0x4699;
	btime_coeff[8]   = 0x0799;
	btime_coeff[9]   = 0x4788;
	btime_coeff[10]  = 0x9788;
	btime_coeff[11]  = 0x97B1;
	btime_coeff[12]  = 0x879A;
								/* beat time values in [ms]      */
	btime_table[0]   = 20;
	btime_table[1]   = 40;
	btime_table[2]   = 50;
	btime_table[3]   = 70;     	/* 2 coeff. bytes for 70 ms in btime_coeff[3]*/
	btime_table[4]   = 100;
	btime_table[5]   = 150;
	btime_table[6]   = 200;
	btime_table[7]   = 250;
	btime_table[8]   = 300;
	btime_table[9]   = 500;
	btime_table[10]  = 1024;
	btime_table[11]  = 1820;
	btime_table[12]  = 4096;

		/*
			LEVEL table    for sidetone adjustment ( -50, -34, -17, 00 dB )
			===========
		*/

	level_tab[0] = 0xA7;        /* -50 dB                           */
	level_tab[1] = 0x25;
	level_tab[2] = 0x32;
	level_tab[3] = 0x00;        /*   0 dB                           */

	/*
		END of tables initialization and start of ARCOFI default setup !!!
		******************************************************************
	*/

			/* Next an array is built with      */
			/* the default settings for MIC     */
			/* gain, GX filter, FX filter,      */
			/* speech encoding, GR and FR       */
			/* filter values.                   */
			/* The array frame [] is then       */
			/* handed over to the               */
			/* arcofi_init_hands () function    */
			/* to initialize the handset        */
			/* ###############################  */

	frame[0]  = 2;				/* coarse gain adjustment (MIC gain)*/
	frame[1]  = 0x29;       	/* fine gain adjustment (GX1)       */
	frame[2]  = 0xC1;       	/*                      (GX2)       */

	frame[3]  = 0xFF;       	/* FX coefficients frame[3]..[12]   */
	frame[4]  = 0xFF;
	frame[5]  = 0xFF;
	frame[6]  = 0xFF;
	frame[7]  = 0xFF;
	frame[8]  = 0xFF;
	frame[9]  = 0xFF;
	frame[10] = 0xFF;
	frame[11] = 0xFF;
	frame[12] = 0xFF;

	frame[13] = 1;          	/* high pass off                    */
	frame[14] = 1;          	/* æ Law speech encoding            */

	frame[15] = 0x01;       	/* loudness medium                  */

	frame[16] = 0xFF;       	/* FR filter coefficients           */
	frame[17] = 0xFF;
	frame[18] = 0xFF;
	frame[19] = 0xFF;
	frame[20] = 0xFF;
	frame[21] = 0xFF;
	frame[22] = 0xFF;
	frame[23] = 0xFF;
	frame[24] = 0xFF;
	frame[25] = 0xFF;

		/* Init handset with values of frame [] */

	if (arcofi_init_hands (p_peitab, 26, (uchar FAR *) frame) != OK) {
		exe_state = NOK;
	}

		/* Set default tone generator frequencies */

	if (arcofi_time_freq (p_peitab, 0, 0, 0, 0xA4, 0x99) != OK) {	/* TG1 800 Hz  */
		exe_state = NOK;
	}

	if (arcofi_time_freq (p_peitab, 0, 0, 1, 0x34, 0x99) != OK) {	/* TG2 1050 Hz */
		exe_state = NOK;
	}

	if (arcofi_time_freq (p_peitab, 0, 0, 2, 0x14, 0x99) != OK) {	/* TG1 1300 Hz */
		exe_state = NOK;
	}

		/* Set default beat tone times */

	if (arcofi_time_freq (p_peitab, 1, 0, 0, 0x14, 0xB2) != OK) {	/* TG1 40 ms   */
		exe_state = NOK;
	}

	if (arcofi_time_freq (p_peitab, 1, 0, 1, 0x14, 0xB2) != OK) {	/* TG2 40 ms   */
		exe_state = NOK;
	}

	if (arcofi_time_freq (p_peitab, 1, 0, 2, 0x14, 0xB2) != OK) {	/* TG3 40 ms   */
		exe_state = NOK;
	}

	if (arcofi_set_ampl (p_peitab, 0, 0, 0xB3) != OK) {
		exe_state = NOK;
	}

	if (arcofi_set_ampl (p_peitab, 0, 1, 0xB3) != OK) {
		exe_state = NOK;
	}

	if (arcofi_set_ampl (p_peitab, 0, 2, 0xB3) != OK) {
		exe_state = NOK;
	}

	if (arcofi_sidetone (p_peitab, 0x01) != OK) {					/* sidetone level low (-34 dB)*/
		exe_state = NOK;
	}

	if (arcofi_op_mode (p_peitab, 1) != OK) {						/* set ARCOFI ready           */
		exe_state = NOK;
	}

# 	if PH_D_CODEC_POWER_DOWN == ON

		if (arcofi_power (p_peitab, OFF) != OK) {					/* and switch it power down   */
			exe_state = NOK;
		}

#	endif

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_power ()                                            *
 *    Parms   : pu ( ON / OFF   power up / down )                          *
 *    Purpose : Power up / down of ARCOFI.                                 *
 *                                                                         *
 ***************************************************************************/

int arcofi_power (p_peitab, pu)
	register struct peitab 	FAR *p_peitab;
	uchar						 pu;
{
	uchar     					 cmdr;

		/* Set / Reset PU if pu == TRUE / pu == FALSE */

	if (pu != OFF) {
		arc_cmdr |= CMDR_PU;

	} else {

		arc_cmdr &= ~CMDR_PU;
	}

	cmdr = 0x0f | arc_cmdr;

	return (wr_mon1 (p_peitab, (uchar FAR *) &cmdr, 1));
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_op_mode ()                                          *
 *    Parms   : mode                                                       *
 *    Purpose : Set ARCOFI operation mode, parameter 'mode' can be         *
 *              directly loaded into register CR3:                         *
 *              00 = off; 01 = ready; 02/03/04 = loud hearing 1/2/3        *
 *              05 = hands free; 06 = mute;                                *
 *                                                                         *
 ***************************************************************************/

int arcofi_op_mode (p_peitab, mode)
	register struct peitab 	FAR *p_peitab;
	uchar  						 mode;
{
	int      					 exe_state = OK;
	uchar     					 parm [2];

	if (mode > 0x06) {
		return (NOK);
	}

	if (rd_mon1 (p_peitab, 0x46 | arc_cmdr, (uchar FAR*) &parm[1], 1) != OK) {
		exe_state = NOK;
	}

		/* read CR3       */

	parm[1] &= 0xE3;                /* clear bits 2..4                  */
	parm[1] |= (mode << 2);         /* set bits 2..4 for op. mode       */

	parm[0] = 0x06 | arc_cmdr;      /* select write operation for CR3   */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 2) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_set_loud ()                                         *
 *    Parms   : up                                                         *
 *    Purpose : Set ARCOFI loudness up (up = 1) or down (up = 0)           *
 *              by changing the contents of GR                             *
 *              The coefficients are stored in the gaintable[]             *
 *              loudness up:  take next ( higher) coeff. of gaintable[]    *
 *              loudness down: take previous ( lower ) coeff. of table     *
 *                                                                         *
 ***************************************************************************/

int arcofi_set_loud (p_peitab, up)
	register struct peitab 	FAR *p_peitab;
	uchar						 up;
{
	uchar     					 parm[3];

	switch (up)	{

		case 0x00:              	/* gain down                        */
			curr_gain--;

			if (curr_gain < 0) {
				curr_gain = 0;
			}

			break;

		case 0x01:                  /* gain up                          */
			curr_gain++;

			if (curr_gain > (MAX_GAIN_TAB - 1)) {
				curr_gain = MAX_GAIN_TAB - 1;
			}

			break;

		case 0x02:                  /* set default gain, curr_gain   */
									/* must be set by calling routine ! */
			break;

		default:
			return (NOK);
	}

	parm[0] = 0x0B | arc_cmdr;      /* write CMD for GR registers       */
									/* get the 2 coeff. bytes from the  */
									/* table                            */

	parm[1] = HIBYTE (gaintable[curr_gain]);
	parm[2] = LOBYTE (gaintable[curr_gain]);

	return (wr_mon1 (p_peitab, (uchar FAR*) parm, 3));
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_sidetone ()                                         *
 *    Parms   : level                                                      *
 *    Purpose : Set ARCOFI sidetone level:                                 *
 *              null (level=0x00), low ( 0x01), medium (0x02), high (0x03) *
 *                                                                         *
 ***************************************************************************/

int arcofi_sidetone (p_peitab, level)
	register struct peitab 	FAR *p_peitab;
	uchar  						 level;
{
	int           				 exe_state = OK;
	uchar           			 parm[5];

	if (level > 0x03) {
		return (NOK);
	}

	if (rd_mon1 (p_peitab, 0x49 | arc_cmdr, (uchar FAR*) &parm[1], 4) != OK) {
		exe_state = NOK;
	}

	parm[0] = 0x09 | arc_cmdr;      /* write CMD for gain and TG        */
									/* amplitudes                       */

	parm[1] = level_tab [level];    /* insert new value for GZ          */
									/* other values not changed         */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_b_usage ()                                          *
 *    Parms   : channel                                                    *
 *    Purpose : Select the B channel : B1, B2 or both                      *
 *                                                                         *
 ***************************************************************************/

int arcofi_b_usage (p_peitab, channel)
	register struct peitab 	FAR *p_peitab;
	uchar     					 channel;
{
	int      					 exe_state = OK;
	uchar     					 parm[5];

		/* read registers CR4 .. CR1:       */
		/* parm [1] is CR4,.. parm[4] is CR1 */

	if (rd_mon1 (p_peitab, (0x40 | arc_cmdr), (uchar FAR*) &parm[1], 4) != OK) {
		exe_state = NOK;
	}

	switch (channel) {

		case 0x00:                  /* use B1                           */
			parm[3]  &= ~CR2_TR;    /* delete the TR bit in CR2         */
			arc_cmdr &= ~CMDR_RCS;  /* delete the RCS bit in CMDR       */
			break;

		case 0x01:                  /* use B2                           */
			parm[3]  &= ~CR2_TR;    /* delete the TR bit in CR2         */
			arc_cmdr |= CMDR_RCS;   /* set the RCS bit in CMDR          */
			break;

		case 0x02:                  /* use B1 + B2                      */
			parm[3]  |= CR2_TR;     /* delete the TR bit in CR2         */
			break;

		default:
			return (NOK);
	}

	curr_channel = channel;

	parm[0] = arc_cmdr;             /* write CMD for CR registers       */
	parm[1] |= CR4_TM;              /* set TM bit in CR4                */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
		exe_state = NOK;
	}

	return (exe_state);

}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_time_freq ()                                        *
 *    Parms   : beattime   (to select setting of beattime or frequency)    *
 *              mapping, tg_id (tone gen. ID), reg_h, reg_l (frequ. values)*
 *    Purpose : Set frequency in one of the tone generators                *
 *                                                                         *
 ***************************************************************************/

int arcofi_time_freq (p_peitab, beattime, mapping, tg_id, reg_h, reg_l)
	register struct peitab 	FAR *p_peitab;
	int            				 beattime;
	uchar  						 mapping, tg_id, reg_h, reg_l;
{
	int            				 exe_state = OK;
	uchar           			 hbyte = reg_h,
								 lbyte = reg_l, parm[5];
	uint   						 two_coeff;

		/* mapping of the parameters to     */
		/* corresponding coefficients       */
		/* requested ?                      */

	if (mapping) {

			/* the search routine returns a     */
			/* pair or coefficients combined in */
			/* a ushort                         */

		two_coeff   = arcofi_search_btmap (p_peitab, beattime, reg_h, reg_l);

		hbyte       = HIBYTE (two_coeff);   /* extract the high byte         */
		lbyte       = LOBYTE (two_coeff);   /*  and the low byte coefficient */
	}

	switch (tg_id) {                      	/* select tone generator            */

		case 0x00:                          /* TG #1 */
			parm[0] = 0x41 | arc_cmdr;
			break;

		case 0x01:                          /* TG #2 */
			parm[0] = 0x43 | arc_cmdr;
			break;

		case 0x02:                          /* TG #3 */
			parm[0] = 0x4E | arc_cmdr;
			break;

		default:
			return (NOK);
	}

		/* read the tone generator's        */
		/* frequency and beat time coeffi-  */
		/* cients                           */

	if (rd_mon1 (p_peitab, parm[0], (uchar FAR*) &parm[1], 4) != OK) {
	  exe_state = NOK;
	}

	if (beattime) {				/* beat time programming ?          */
								/*    YES.                          */

		parm[1] = hbyte;        /* insert new beat time coeff.      */
		parm[2] = lbyte;
	} else {                    /*    NO.                           */
		parm[3] = hbyte;        /* insert new frequency coeff.      */
		parm[4] = lbyte;
	}

	parm[0] &= ~0x40;           /* reset RW bit for write operation */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_set_ampl ()                                         *
 *    Parms   : mapping, tg_id (tone gen. ID), reg (amplitude value)       *
 *    Purpose : Set amplitude in one of the tone generators ( 1,2 or 3 )   *
 *                                                                         *
 ***************************************************************************/

int arcofi_set_ampl (p_peitab, mapping, tg_id, reg)
	register struct peitab 	FAR *p_peitab;
	uchar						 mapping, tg_id, reg;
{
	int      					 exe_state = OK;
	uchar    					 ampl, parm[5];
	int      					 off, value;

	ampl = reg;

	if (mapping) {

		/* mapping requested ?              */
		/* search for the register value in */
		/* ampli_table : 'ampl' is the      */
		/* amplitude in [dB] to be set      */

		if (ampl < 0x80)  {		/* positive [dB] value ?            */
			value = 0;         	/* no values above 0 [dB] possible  */
		} else {                /* negative [dB] value              */
			value = (int)(0xFF - ampl);

			if (value > 50) {
				value = 50;
			}

		}

			/* subtract 5 from the requested    */
			/* amplitude value until it is <= 0 */
			/* The number of subtractions is    */
			/* the offset in the ampli_table    */
			/* where the corresponding coeff.   */
			/* byte can be found                */

		for (off = 0; off < (MAX_AMP_TAB - 1); off++, value -= 5) {

			if (value <= 0) {
				break;
			}

			ampl = ampli_table[off];
		}

	}

			/* read gain and beat tone          */
			/* generators amplitudes            */

	if (rd_mon1 (p_peitab, 0x49 | arc_cmdr, (uchar FAR*) &parm[1], 4) != OK) {
		exe_state = NOK;
	}

	switch (tg_id) {

			/* select the tone generator to be  */
			/*                      programmed  */

		case 0x00:    	/* TG #1 */
			parm[4] = ampl;
			break;

		case 0x01:      /* TG #2 */
			parm[3] = ampl;
			break;

		case 0x02:                       /* TG #3 */
			parm[2] = ampl;
			break;

		default:
			return (NOK);
   }

   parm[0] = 0x09 | arc_cmdr;

   if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
	  exe_state = NOK;
   }

   return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_set_tone ()                                         *
 *    Parms   : 'on': tone on/off                                          *
 *              'signal_mix' : exclusive square wave or mix with voice     *
 *              'tonetype'    : single / two /three tone,                  *
 *              'outp_ctrl'   : to piezo or to ear                         *
 *    Purpose : Tone generation on / off.                                  *
 *                                                                         *
 ***************************************************************************/

int arcofi_set_tone (p_peitab, on, signal_mix, tonetype, outp_ctrl)
	register struct peitab 	FAR *p_peitab;
	uchar 						 on, signal_mix, tonetype, outp_ctrl;
{
	int   						 exe_state = OK;
	uchar  						 parm[5];

		/* Read register CR4  (= parm[1])   */
		/* (error in ARCOFI A1: CR4 can't   */
		/* be read alone with COP 0x47 !)   */
		/* COP 0x40 must be used            */

	if (rd_mon1 (p_peitab, 0x40 | arc_cmdr, (uchar FAR*) &parm[1], 4) != OK) {
		exe_state = NOK;
	}

	if (on) {

			/*    ****  TONE ON  ****           */

		parm[1] |= CR4_TG;

		if (!signal_mix) {
			parm[1] &= ~CR4_TM;
		} else {
			parm[1] |= CR4_TM;
		}

		parm[1] &= ~(CR4_BT | CR4_BM | CR4_PM);

		switch (tonetype) {

			case 0x00 :			/* continuous tone generator 1      */
				break;

			case 0x01:         	/* continuous tone generator 2      */
				parm[1] |= CR4_BM;
				break;

			case 0x02:          /* two tone generator 1 and 2       */
				parm[1] |= CR4_BT;
				break;

			case 0x03:          /* three tone, generators 1, 2 and 3*/
				parm[1] |= CR4_BT | CR4_BM;
				break;

			default:
				return (NOK);
		}

		if (!outp_ctrl) {
			parm[1] |= CR4_PM;
		}

	} else  {

			/*    **** TONE OFF ****            */

		parm[1] &= ~CR4_TG;
		parm[1] |= CR4_TM;

	}

	parm[0] = 0x00 | arc_cmdr;

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_ctrl_dtmf ()                                        *
 *    Parms   :                                                            *
 *    Purpose : enable/disable DTMF generator                              *
 *                                                                         *
 ***************************************************************************/

int arcofi_ctrl_dtmf (p_peitab, on, h_group, l_group)
	register struct peitab 	FAR *p_peitab;
	uchar 						 on, h_group, l_group;
{
	int   						 exe_state = OK;
	uchar  						 parm[5];

	parm[0] = 0x08 | arc_cmdr;
	parm[1] = h_group;
	parm[2] = l_group;

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 3) != OK) {
		exe_state = NOK;
	}

		/* Read register CR4 (= parm[1])    */

	if (rd_mon1 (p_peitab, 0x40 | arc_cmdr, (uchar FAR*) &parm[1], 4) != OK) {
		exe_state = NOK;
	}

	if (on) {

			/* and set the DTMF bit             */

		parm[1] |= CR4_DTMF;
	} else {
		parm[1] &= ~CR4_DTMF;
	}

	parm[0] = arc_cmdr;

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_init_hands ()                                       *
 *    Parms   : counter and pointer to parameters                          *
 *    Purpose : initialize the handset                                     *
 *                                                                         *
 ***************************************************************************/

int arcofi_init_hands (p_peitab, cnt, frame)
	register struct peitab 	FAR *p_peitab;
	unsigned int    			 cnt;
	uchar 					FAR	*frame;
{
	uchar  						 parm [6];
	int   						 exe_state = OK;

		/* Set bits in CR1 to load the      */
		/* filters GR, GZ, GX with data     */
		/* from CRAM FX and FR disabled     */

	parm[4] = CR1_GR | CR1_GZ | CR1_GX;
	parm[3] = 0x89;                     /* CR2: SA,SB,SC outputs, SD input  */
	parm[2] = 0x44;                     /* CR3                              */
										/* high pass on/off,                */
										/* speech encoding mue/A - law      */

	parm[1] = (frame [13] ? CR4_DHF : 0x00) | (frame [14] ? CR4_LAW : 0x00);
	parm[0] = arc_cmdr = 0x00;

	if (wr_mon1 (p_peitab, (uchar FAR *) parm, 5) != OK) {
		exe_state = NOK;
	}

		/* Init transmit path               */
		/* frame[0]     COARSE GAIN ADJUST. */
		/* frame[1]+[2] FINE GAIN ADJUST.   */
		/*              -> GX1/2            */
		/* frame[3]..[12] FX FILTER coeff.  */

	if (arcofi_init_tx (p_peitab, 13, frame) != OK) {
		exe_state = NOK;
	}

		/* Init receive path                */
		/* frame[15]..[25] FR FILTER coeff. */

	if (arcofi_init_rx (p_peitab, 11, &frame[15]) != OK) {
		exe_state = NOK;
	}

	if (arcofi_b_usage (p_peitab, curr_channel) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_init_tx ()                                          *
 *    Parms   : counter and pointer to parameters                          *
 *    Purpose : initialize the transmit path                               *
 *                                                                         *
 ***************************************************************************/

int arcofi_init_tx (p_peitab, cnt, frame)
	register struct peitab 	FAR *p_peitab;
	unsigned int    			cnt;
	uchar					FAR	*frame;
{
	uchar  						 parm[12];
	int   						 i, exe_state = OK;

		/* frame[0]  COARSE GAIN ADJUST.    */
		/* ============================     */

		/* read register CR3                */

	if (rd_mon1 (p_peitab, 0x46 | arc_cmdr, (uchar FAR*) &parm[1], 1) != OK) {
		exe_state = NOK;
	}

	parm[1] &= 0x1F;                    /* mask bits 5..7                   */
	parm[1] |= (frame[0] << 5);         /* set bits 5..7 for gain           */
	parm[0]  = 0x06 | arc_cmdr;         /* command value to write CR3       */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 2) != OK) {
		exe_state = NOK;
	}

	for (i = 1; i < 11; i++) {
		parm[i] = frame[i];
	}

			/* frame[1]+[2] FINE GAIN ADJUST.   */
			/*                 -> GX1/2         */
			/* ================================ */

	parm[0] = 0x02 | arc_cmdr;          /* parm[0] now used as command byte */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 3) != OK) {
		exe_state = NOK;
	}


		/* frame[3]..[12]  FX FILTER COEFF. */
		/* ================================ */

	parm[2] = 0x0A | arc_cmdr;         	/* write the first 8 coefficients   */
										/*        fx1 .. fx8                */

	if (wr_mon1 (p_peitab, (uchar FAR*) &parm [2], 9) != OK) {
		exe_state = NOK;
	}

		/* read fr9, fr10, fx9 and fx10     */

	if (rd_mon1 (p_peitab, 0x4D | arc_cmdr, (uchar FAR*) &parm[1], 4) != OK) {
		exe_state = NOK;
	}

	parm[0] = 0x0D | arc_cmdr;          /* write the last two FX coef.      */
	parm[3] = frame[11];                /*    fx9                           */
	parm[4] = frame[12];                /*    fx10                          */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
		exe_state = NOK;
	}

		/* read CR1                     */

	if (rd_mon1 (p_peitab, 0x44 | arc_cmdr, (uchar FAR*) &parm[1], 1) != OK) {
		exe_state = NOK;
	}

	parm[0] = arc_cmdr | 0x04;

	if (frame[0] & 0x80) {              /* FX filter on                     */
		parm[1] |= 0x20;
	} else {                            /* FX filter off                    */
		parm[1] &= ~0x20;
	}

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 2) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_init_rx ()                                          *
 *    Parms   : counter and pointer to parameters                          *
 *    Purpose : initialize the receive path                                *
 *                                                                         *
 ***************************************************************************/

int arcofi_init_rx (p_peitab, cnt, frame)
	register struct peitab 	FAR *p_peitab;
	unsigned int    			 cnt;
	uchar 					FAR	*frame;
{
	uchar     					 parm[9];
	int      					 i, exe_state = OK;

		/* frame[0] = loudness:             */
		/* 0 low, 1 medium, 2 high,         */
		/* 3 very high                      */
		/* ================================ */

	curr_gain = (int)(((unsigned) (frame[0] & 0x03)) << 2) + 5;

		/* set default loudness             */

	if (arcofi_set_loud (p_peitab, 2) != OK) {
		exe_state = NOK;
	}

		/* frame[1]..[10]  FR FILTER coeff. */
		/* ===============================  */

	for (i = 1; i < 9; i++) {
		parm[i] = frame[i];
	}

	parm[0] = 0x0C | arc_cmdr;          /* write CMD for coeff. fr1..fr8    */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 9) != OK) {
		exe_state = NOK;
	}

		/* read fr9, fr10, fx9 and fx10     */

	if (rd_mon1 (p_peitab, 0x4D | arc_cmdr, (uchar FAR*) &parm[1], 4) != OK) {
		exe_state = NOK;
	}

	parm[0] = 0x0D | arc_cmdr;          /* write the last 2 FR coefficients */
	parm[1] = frame[9];                 /*    fr9                           */
	parm[2] = frame[10];                /*    fr10                          */

	if (wr_mon1 (p_peitab, (uchar FAR*) parm, 5) != OK) {
		exe_state = NOK;
	}

		/* read CR1                         */

	if (rd_mon1 (p_peitab, 0x44 | arc_cmdr, (uchar FAR*) &parm[1], 1) != OK) {
		exe_state = NOK;
	}

	parm[0] = arc_cmdr | 0x04;

	if (frame[0] & 0x80) {              /* FR filter on                     */
		parm[1] |= 0x10;
	} else  {                           /* FR filter off                    */
		parm[1] &= ~0x10;
	}

	if (wr_mon1 (p_peitab, (uchar FAR*)parm, 2) != OK) {
		exe_state = NOK;
	}

	return (exe_state);
}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_search_btmap ()                                     *
 *    Parms   : beattime  = 1: search in time table                        *
 *                        = 0: search in frequ. table                      *
 *    Purpose : search in time/frequency coefficient table for register    *
 *              values. 'hbyte' and 'lbyte' are converted to one integer   *
 *              time / frequ. value ( [ms] or [Hz] ) which is the search   *
 *              parameter ( i.e. a time/freq. which must be programmed     *
 *              in the ARCOFI via the corresponding coefficients )         *
 *                                                                         *
 ***************************************************************************/

ushort arcofi_search_btmap (p_peitab, beattime, hbyte, lbyte)
	register struct peitab 	FAR *p_peitab;
	int							 beattime;
	uchar       				 hbyte, lbyte;
{
	int      					 i, maxoff, diff1, diff2;
	ushort     					*tab, *coef;
	ushort     					 value, maxval, minval;

		/* convert the characters to an     */
		/* integer value: value is the      */
		/* frequency / time                 */

	value = ((ushort) hbyte << 8) + (ushort) lbyte;

		/* set the pointers to the time or  */
		/* the frequency tables (depending  */
		/* on variable 'beattime')          */

	if (beattime) {
		tab      = btime_table;
		coef     = btime_coeff;
		minval   = TIME_MIN;
		maxval   = TIME_MAX;
		maxoff   = TIME_TAB_MAX - 1;

	} else {

		tab      = freqtable;
		coef     = freq_coeff;
		minval   = FREQ_MIN;
		maxval   = FREQ_MAX;
		maxoff   = FREQ_TAB_MAX - 1;
	}

	if (value <= minval) {       /* don't search if minimum or       */
		i = 0;
		goto FOUND;
	}

	if (value >= maxval) {       /*    maximum values are wanted     */
		i = maxoff;
		goto FOUND;
	}

		/* compare the wanted frequency /   */
		/* time in 'value' with the table   */
		/* entries.                         */

	for (i = 1, tab++; i < maxoff; i++, tab++) {

	  if (*tab >= value) {			/* exit  if an entry in the table   */
		 break;                     /* greater than 'value' is detected */
	  }

	}

		/* compute the differences and take */
		/* the table entry which is closer  */
		/* to 'value'                       */

	diff1 = (int) value  - (int) (*(tab - 1));
	diff2 = (int) (*tab) - (int) value;

	if (diff1 <= diff2) {
		i--;
	}

FOUND:

		/* read the byte coefficient from   */
		/* the integer coefficient table    */
		/* and return it to the calling     */
		/* function                         */

	return (coef[i]);

}

/***************************************************************************
 *                                                                         *
 *    Function: arcofi_assign_voice ()                                     *
 *    Parms   : channel                                                    *
 *    Purpose : This function does the B channel assignment and power up / *
 *              down procedure of ARCOFI CODEC filters                     *
 *                                                                         *
 ***************************************************************************/

int arcofi_assign_voice (p_peitab, channel)
	register struct peitab 	FAR *p_peitab;
	uchar              			 channel;
{

		/* Return if no there is no CODEC   */

	if (p_peitab -> pt_Codec == NOT_PRESENT) {
		return (FALSE);
	}

	switch (channel) {

		case NO_CHANNEL :

#			if PH_D_CODEC_POWER_DOWN == ON

					/* 0 means: no B channel            */
					/* assignment -> power down         */

				arcofi_power (p_peitab, OFF);
#			endif

			return (TRUE);

		case B1_CHANNEL:

				/* assign to B1                     */
				/* ############                     */

			Wr_sbc (p_peitab -> pt_r_sscx, 0x00);
			break;

		case B2_CHANNEL:

				/* assign to B2                     */
				/* ############                     */

			Wr_sbc (p_peitab -> pt_r_sscx, 0x88);
			break;

				/* assign B1 and B2 channels        */
				/* #########################        */

		case (B1_CHANNEL | B2_CHANNEL):
			break;

		default:
			return (FALSE);
	}

			/* program ARCOFI for B1, B2 or     */
			/* B1+B2 and do a power up          */

	if (channel == (B1_CHANNEL | B2_CHANNEL)) {
		arcofi_b_usage (p_peitab, 2);

	} else {

		arcofi_b_usage (p_peitab, (channel & B1_CHANNEL) ? 0 : 1);
	}

#	if PH_D_CODEC_POWER_UP == ON
		arcofi_power (p_peitab, ON);
#	endif

	return (TRUE);
}

#endif /* PH_CODEC == ARCOFI_2160 } */

/*EOF*/
