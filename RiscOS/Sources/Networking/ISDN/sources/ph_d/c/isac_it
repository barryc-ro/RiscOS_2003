
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - isac_it.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    ISDN-BRICKS                                      |*/
/*|    Siemens ISAC-S Driver                            |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

/***************************************************************************
 *                                                                         *
 *    SIEMENS ISDN-Userboard  (c) 1987-1989                                *
 *    ======================                                               *
 *                                                                         *
 *    Firmware:   L2 device driver functions for ICC/ISAC-S                *
 *    File    :   icc.c                                                    *
 *    created :   Aug. 1989                                                *
 *    author  :   Peter Mueller                                            *
 *    compiled:   Microsoft C compiler  5.1 (Small)                        *
 *                                                                         *
 ***************************************************************************/

#define ENTITY ENT_PH_D_IT

   /* Include Files
	  =============  */

#include "ph_d.h"                       /* general definitions              */

		/* PEITAB table pointers */

	extern struct peitab FAR *FAR *p_tab_peitab_isac;	/* PH B PEITAB pointer table HSCX A */

#if PH_D_AUDIT == ON
#	define   Read_register 							\
	g_isac_star = Rd_icc (p_peitab -> pt_r_star);	\
	g_isac_mode = Rd_icc (p_peitab -> pt_r_mode);	\
	g_isac_timr = Rd_icc (p_peitab -> pt_r_timr);	\
	g_isac_rbcl = Rd_icc (p_peitab -> pt_r_rbcl);	\
	g_isac_rsta = Rd_icc (p_peitab -> pt_r_rsta);	\
	g_isac_rhcr = Rd_icc (p_peitab -> pt_r_rhcr);	\
	g_isac_rbch = Rd_icc (p_peitab -> pt_r_rbch);	\
	g_isac_ccr1 = Rd_icc (p_peitab -> pt_r_ccr1);	\
	g_isac_spcr = Rd_icc (p_peitab -> pt_r_spcr)

	uchar g_isac_star;
	uchar g_isac_mode;
	uchar g_isac_timr;
	uchar g_isac_rbcl;
	uchar g_isac_rsta;
	uchar g_isac_rhcr;
	uchar g_isac_rbch;
	uchar g_isac_ccr1;
	uchar g_isac_spcr;

#else

#	define Read_register
#endif

   /* Function Declarations
	  =====================   */

   /*    ***   The interrupt service routines   ***   */
   /*    ******************************************   */

/***************************************************************************
 *                                                                         *
 *    Function: isac_it ()                                                 *
 *    Parms   : ISAC-S ID                                                  *
 *    purpose : Interrupt-handler for the ISAC-S chip.                     *
 *                                                                         *
 ***************************************************************************/

	uint	icc_it_counter;
	uint	sbc_it_counter;

	uint	it_d_nb;
	uchar 	d_ista_g;
	uchar 	d_ista_2;

void isac_it (isac_id)
	uchar						 isac_id;
{
	register struct peitab  FAR *p_peitab;
			 uchar             	 ista;

	if ((p_peitab = p_tab_peitab_isac [isac_id]) != P_NIL) {

		Read_register;

		if ((d_ista_g = ista = Rd_icc (p_peitab -> pt_r_ista)) != 0) {
														/* layer 1 device controller ?      */
			if (ista & ~ISTA_CIC) {		            	/* D channel interrupt ?            */
				icc_it_counter++;
				icc_it (ista, p_peitab);
			}

			if (ista & ISTA_CIC)  {		            	/* CIC interrupt ? (layer 1 device  */
				sbc_it_counter++;					    /*                   status change) */
				sbc_it (p_peitab);
			}

			it_d_nb++;

		}

	}

}

/***************************************************************************
 *                                                                         *
 *    Function: icc_it ()                                                  *
 *    Parms   :'p_peitab'   pointer to PEITAB-table entry for this channel *
 *             'ista' value of interrupt status register                   *
 *    purpose : handle the interrupts generated by the HDLC controller     *
 *              of an ICC.                                                 *
 *                                                                         *
 ***************************************************************************/

void icc_it (ista, p_peitab)
   register uchar    	 			 ista;
   register struct	peitab   	FAR	*p_peitab;
{
			ushort 		       		 cnt;
			uchar    		    	 cmd;
			ulong       			 state74 = 0L;

		/* XPR interrupt                    */
		/* the XPR interrupt indicates      */
		/* that the XFIFO is ready for new  */
		/* data bytes.                      */
		/* Reasons:                         */
		/* - HDLC controller was reset via  */
		/*   a reset command                */
		/* - frame transmission finished    */
		/* - one half of the XFIFO has      */
		/*   been sent, new data bytes can  */
		/*   be shifted to the XFIFO        */

   if ((ista & ISTA_XPR) && ! (ista & ISTA_TIN)) {

			/* Transmit byte count is 0         */

	  if ((cnt = p_peitab -> pt_tx_cnt) == 0) {

				/* - HDLC controller reset command  */
				/*   was given previously           */

		 if (p_peitab -> pt_state & PT_HDLC_RESET) {

				/* do nothing when it was a HDLC    */
				/* controller reset (do only clear  */
				/* the indicating flag)             */

			p_peitab -> pt_state &= ~PT_HDLC_RESET;
			isac_event (p_peitab, EV_TX_RESET);

		 } else {

				/* XPR was generated because the    */
				/* last transmission is finished    */
				/*   generate a transmit            */
				/*   acknowledge response and free  */
				/*   the transmit path              */

			p_peitab -> pt_tx_cnt = 0;
			p_peitab -> pt_state &= ~PT_TX_WORKS;
			isac_event (p_peitab, EV_TX_DONE);
		 }

	  }  else {

				/* - more data to be sent !         */

		 if (p_peitab -> pt_op_mode == PT_MD_AUTO) {
			cmd = (p_peitab -> pt_tx_frame ? CMDR_XTF : CMDR_XIF) | (Rd_icc(p_peitab -> pt_r_star) & CMDR_RNR);

		 } else {

			cmd = CMDR_XTF;
		 }

		 if (cnt <= PH_FIFO_SIZE)  {

				 /* if less than PH_FIFO_SIZE bytes then   	*/
				 /* shift them into the XFIFO and   		*/
				 /* give XME command                 		*/
				 /* (transmit message end) command   		*/

			String_out ((char FAR *)p_peitab -> pt_tx_curr, p_peitab -> pt_r_fifo, cnt);
			p_peitab -> pt_tx_cnt  = 0;
			Wr_icc (p_peitab -> pt_r_cmdr, cmd | CMDR_XME);

		 } else {

				/* more than PH_FIFO_SIZE bytes are left to   */
				/* be sent; write PH_FIFO_SIZE into the XFIFO */

			String_out ((char FAR *)p_peitab -> pt_tx_curr, p_peitab -> pt_r_fifo, PH_FIFO_SIZE);

			Wr_icc (p_peitab -> pt_r_cmdr, cmd); 		/* give the transmit command,       */
			p_peitab -> pt_tx_curr += PH_FIFO_SIZE; 	/* update current buffer pointer    */
			p_peitab -> pt_tx_cnt  -= PH_FIFO_SIZE; 	/* and counter of remaining bytes   */
		 }

	  }

   }

   if (ista & ISTA_TIN) {              					/* TIN interrupt                    */
		state74 |= RESP_ERR_TIN;   					    /* set the TIN error flag           */

			/* Timer expiry --> send event */

		p_peitab -> pt_tx_cnt = 0;
		p_peitab -> pt_state &= ~PT_TX_WORKS;
		isac_event (p_peitab, EV_TX_TO);

		if (ista & ISTA_XPR) {
				 p_peitab -> pt_tx_cnt = 0;
				 p_peitab -> pt_state &= ~PT_TX_WORKS;

					/* indicate TX done to PH D */

				isac_event (p_peitab, EV_TX_DONE);
		}

   }
		/* HDLC receiver interrupt ?        */

   if (ista & (ISTA_RPF | ISTA_RME)) {
		 state74 |= icc_it_rx (ista & ISTA_RPF, p_peitab);
   }

		/* Extended interrupt ? */

   if (ista & ISTA_EXI)  {
	  uchar    exir = Rd_icc (p_peitab -> pt_r_exir),
			   status;

	  d_ista_2 = exir;

	  if ((status = (exir & (EXIR_XMR | EXIR_XDU | EXIR_RFO)) >> 1) != 0) {
		 state74 |= (ulong) status << 16;

			/* please refer to the data sheets  */
			/* repectively techn. descriptions  */
			/* of the controllers for detailed  */
			/* descripton of these interrupts   */

			/* free the transmit path if it     */
			/* was a XMR or XDU interrupt       */

		 if (exir & (EXIR_XMR | EXIR_XDU)) {
				p_peitab -> pt_tx_cnt = 0;
				p_peitab -> pt_state &= ~PT_TX_WORKS;
				isac_event (p_peitab, EV_TX_RETRY);
		 }

	  }

			/* MON channel status change        */
			/* indication                       */

	  if (p_peitab -> pt_device == PT_ICC_B && exir & 0x04) {
		 uchar    dummy;

				/* read MOSR register               */

		 dummy = Rd_icc (p_peitab -> pt_r_mocr);
	  }

   }

   if (state74) {
	  isac_event (p_peitab, EV_TX_ERR);
   }

}

/***************************************************************************
 *                                                                         *
 *    Function: icc_it_rx ()                                               *
 *																		   *
 *    Parms   : 'p_peitab' pointer to PEITAB entry assigned to             *
 *               the controller                                            *
 *              'rpf' = 1 if RPF interrupt                                 *
 *																		   *
 *    purpose : handle interrupts generated by the HDLC receiver of an     *
 *              ICC/ISAC-S                                                 *
 *                                                                         *
 ***************************************************************************/

long icc_it_rx (rpf, p_peitab)
			uchar              		rpf;
   register struct	peitab   	FAR	*p_peitab;
{
			ushort     	     		rx_count;			/* receive count */
			uchar      	     		rx_sta;             /* receive status */
			ulong     	     		state74 = 0L;       /* return status */
			struct buffer		FAR *p_buffer;

		/* RPF interrupt:                   			*/
		/* PH_FIFO_SIZE bytes of a frame longer than  	*/
		/* PH_FIFO_SIZE bytes have been received      	*/
		/* and are now available in the RFIFO. 			*/
		/* The message is not complete.					*/

   if (rpf) {
	  rx_count = PH_FIFO_SIZE;

   } else {

			/* RME interrupt:								*/
			/* Receive message end. The RFIFO   			*/
			/* contains a complete frame        			*/
			/* (length <= PH_FIFO_SIZE byte) or the last  	*/
			/* bytes or a frame (length > PH_FIFO_SIZE)		*/
			/* ================================ 			*/

			/* read byte count register(s) to   */
			/* get the number of currently      */
			/* received bytes                   */

			/* Read status and if RDA = 0 the FIFO is empty */
			/*  --> do nothing								*/

	  if ((Rd_icc (p_peitab -> pt_r_rsta) & RSTA_RDA) == 0) {

			/* Enter RMC command */

		Wr_icc (p_peitab -> pt_r_cmdr, CMDR_RMC);

			/* return */

		return (state74);

	  }

	  if (p_peitab -> pt_device == PT_ICC_B) {
		 rx_count = ((ushort) Rd_icc (p_peitab -> pt_r_rbcl)) | ((ushort) (Rd_icc (p_peitab -> pt_r_rbch) & 0x0F) << 8);

	  } else {

		 rx_count = (uchar) Rd_icc (p_peitab -> pt_r_rfbc);
	  }

	  if (rx_count && ! (rx_count &= 0x1F)) {
		 rx_count = PH_FIFO_SIZE;
	  }

   }
		/* rx_count now contains the number	*/
		/* of bytes actually received      	*/

		/* first data bytes of a new       	*/
		/* frame, i.e not already working  	*/
		/* in receive direction ?          	*/

   if ( ! (p_peitab -> pt_state & PT_RX_WORKS))  {

		if (rx_count > 0) {
			It_get_buffer (p_buffer);

			if (p_buffer != P_NIL) {
				Buffer_header_init;
				p_peitab -> pt_rx_curr = p_peitab -> pt_rx_start = (uchar FAR *)Buffer_a_start_data;

			} else {

				p_peitab -> pt_rx_start = P_NIL;
				p_peitab -> pt_rx_frame = PT_FR_NO_MEMORY;
			}

			p_peitab -> pt_state |= PT_RX_WORKS;
		}

   }
		/* Update receive byte count        */

   if ((p_peitab -> pt_rx_cnt += rx_count) > p_peitab -> mx_fr_size) {
	  p_peitab -> pt_rx_frame = PT_FR_OVERFLOW;
   }

			/* read the bytes from the RFIFO    */
			/* if no error was detected         */

   if (p_peitab -> pt_rx_frame < PT_FR_ERROR) {
	  String_in ((char FAR *)p_peitab -> pt_rx_curr, p_peitab -> pt_r_fifo, rx_count);
	  p_peitab -> pt_rx_curr += rx_count; 	/* update buffer pointer        */
											/* it points to the next free   */
											/* location in the buffer       */
   }

   if (rpf) {

			/* return when RPF interrupt        */
			/* enter 'RMC' command              */

	  Wr_icc (p_peitab -> pt_r_cmdr, CMDR_RMC | (Rd_icc (p_peitab -> pt_r_star) & CMDR_RNR));

	  return (state74);
   }
			/* RME !!!                          */
			/* the memory buffer now contains   */
			/* all received bytes               */
			/* ==============================   */

			/* receive status byte is in RSTA   */

	if (p_peitab -> pt_rec_state < PT_FR_ERROR) {

			/* No error detected */

	   p_peitab -> pt_rec_state = Rd_icc (p_peitab -> pt_r_rsta);

			  /* enter 'RMC' command              */

	   Wr_icc (p_peitab -> pt_r_cmdr, CMDR_RMC | (Rd_icc (p_peitab -> pt_r_star) & CMDR_RNR));

			/* Check the frame status */

	   if ((rx_sta 					= (p_peitab -> pt_rec_state & (RSTA_RDO | RSTA_CRC | RSTA_RAB)) ^RSTA_CRC) != 0) {
		  p_peitab -> pt_rx_frame 	= PT_FR_FAULT;
	   }

	}

   switch (p_peitab -> pt_rx_frame){

	  case PT_FR_FAULT:
		 state74 |= (ulong) rx_sta << 8L;
		 break;

	  case PT_FR_OVERFLOW:
		 p_peitab -> pt_rx_cnt 		= Buffer_data_lgth;
		 p_peitab -> pt_rx_frame 	= 0x00;
		 break;

	  case PT_FR_NO_MEMORY:
		 state74 |= RESP_ERR_MMU;
		 break;

	  default:
		 break;
   }

		/* Send and event RECEIVE DONE 				*/
		/* to PH_D or if error release the buffer 	*/

		/* If nothing received do nothing */

   if (p_peitab -> pt_rx_cnt != 0) {

		if (p_peitab -> pt_rx_frame < PT_FR_ERROR) {
			isac_event (p_peitab, EV_RX_DONE);

		} else if (p_peitab -> pt_rx_start) {

				   /* release the receive data         */
				   /* buffer if the frame reception    */
				   /* or frame were erroneous          */

			p_buffer = Buffer_a_from_a_start_data (p_peitab -> pt_rx_start);
			It_put_buffer (p_buffer);
		}

	}

		/* Return */

   p_peitab -> pt_rx_start 	  = P_NIL;
   p_peitab -> pt_state      &= ~PT_RX_WORKS;
   p_peitab -> pt_rec_state   = 0;
   p_peitab -> pt_rx_frame    = 0x00;
   p_peitab -> pt_rx_cnt      = 0;

   return (state74);
}

/*-------------------------------------------------------------------------*/

void icc_to_tx_channel (p_peitab)
   register struct peitab   FAR *p_peitab;
{
	p_peitab -> pt_tx_cnt = 0;

		   /* mark the channel controlling     */
		   /* device as currently not working  */
		   /* in transmit direction.           */

	p_peitab -> pt_state &= ~PT_TX_WORKS;
	isac_event (p_peitab, EV_TX_TO);
}

/***************************************************************************
 *                                                                         *
 *    Function: sbc_it () 	                                               *
 *    Parms   : pointer to PEITAB table entry (in BASIC access first entry)*
 *    purpose : handle C/I interrupts indicating a status change of SBC    *
 *                                                                         *
 ***************************************************************************/

void sbc_it (p_peitab)
   register struct	peitab   	FAR	*p_peitab;
{
   d_ista_2 = p_peitab -> pt_CI_rec = Rd_sbc (p_peitab -> pt_r_cixr);/* read CIRR (CIR0) register        */

   if (p_peitab -> pt_state & PT_IOM2) {

	  if ((p_peitab -> pt_CI_rec & CODX_CIC0_BIT) == 0)  {

			/* for further extension: look at SQC bit... */
		return;
	  }

   } else {

	  if ((p_peitab -> pt_CI_rec & CODX_CIC1_BIT) == 0)  {
			/* for further extension: look at SQC bit... */
		return;
	  }
   }

   if (p_peitab -> pt_ModulMode == PT_MM_LT_S)  {

		   /* in LT-S configuration:           */
		   /* send DID if the SBC is in the    */
		   /* DIU state                        */
		   /* -> deactivation                  */

		if ((p_peitab -> pt_CI_rec & CODX_ALL_BITS) == CODX_DIU)  {

			 if (p_peitab -> pt_state & PT_IOM2) {

				Wr_sbc (p_peitab -> pt_r_cixr, CIXR_TBC | CODX_DID | 0x03);

			 } else {

				Wr_sbc (p_peitab -> pt_r_cixr, CIXR_TBC | CODX_DID);
			}

		}

	} else {

			/* TE configuration:                */
			/* power down the SBC if it has     */
			/* changed from activated to        */
			/* pending mode                     */

		if ((p_peitab -> pt_CI_rec & CODX_ALL_BITS) == CODX_DEA_REQ) {

			if (p_peitab -> pt_state & PT_IOM2) {


				Wr_sbc (p_peitab -> pt_r_cixr, CIXR_TBC | CODX_DIU | 0x03);

			} else {

				Wr_sbc (p_peitab -> pt_r_cixr, CIXR_TBC | CODX_DIU);
			}

		}

		   /* Activation confirmation in IOM2  */
		   /* configurations. The SBC          */
		   /* (ISAC-S) must confirm an         */
		   /* activation from network side.    */
		   /* Only then it will be             */
		   /* transparent for upstream D and   */
		   /* B channel data                   */

		if (p_peitab -> pt_state & PT_IOM2) {

			switch (p_peitab -> pt_CI_rec & CODX_ALL_BITS) {

				case CODX_ACT_IND :
					Wr_sbc (p_peitab -> pt_r_cixr, CIXR_TBC | CODX_ACT_REQ | 0x03);
					break;

				case CODX_ACT_IND10 :
					Wr_sbc (p_peitab -> pt_r_cixr, CIXR_TBC | CODX_ACT_REQ10 | 0x03);
					break;

			}

		}

   }

		/* Process the received event */

   sbc_event (p_peitab);
}

/***************************************************************************
 *                                                                         *
 *    Function: sbc_event ()                                               *
 *    Parms   : pointer to PEITAB table entry                              *
 *    purpose:  Generate a response which indicates the current (new)      *
 *              L1 status                                                  *
 *                                                                         *
 ***************************************************************************/

void 	sbc_event (p_peitab)
	register struct	peitab  	FAR	*p_peitab;
{
			uchar     				state;
			uchar					event_te;
			uchar					event_nt;

	   /* evalute 'Cixr' indicating the    */
	   /* L1 device status and create the  */
	   /* corresponding response           */

   switch (p_peitab -> pt_CI_rec & CODX_ALL_BITS)  {

	  case CODX_TIM:                   /* 0000: timing clocks required     */
		 event_te   = event_nt = EV_INFO_0;
		 state 		= CI_TIMING;
		 break;

	  case CODX_LSL:                   /* 0001: lost signal level          */
		 event_te	= event_nt = EV_INFO_0;
		 state 		= CI_LOST_SL;
		 break;

	  case CODX_EI:                    /* 0110: error indication           */
		 event_te 	= event_nt = EV_ERR_IND;
		 state 		= CI_ERR_IND;
		 break;

	  case CODX_RESYN:                 /* 0100: resynchronizing            */
		 event_te 	= event_nt = EV_LOST_FRAMING;
		 state 		= CI_MPH_EI_LF;
		 break;

	  case CODX_ACT_REQ:               /* 1000: activation request         */
		 event_te 	= EV_INFO_2;
		 event_nt	= EV_INFO_1;
		 state 		= CI_MPH_EI_RY;
		 break;

	  case CODX_ACT_IND:               /* 1100: activation indication P8   */
		 event_te 	= EV_INFO_4_8;
		 event_nt	= EV_INFO_3;
		 state 		= CI_PH_AI;
		 break;
									   /* 1101: activation indicatiom P10  */
									   /* CBFD: this indication has a      */
									   /* completely different meaning     */
									   /* for IEC-Q.                       */
	  case CODX_ACT_IND10:
		 event_te 	= EV_INFO_4_10;
		 event_nt	= EV_NIL;
		 state 		= CI_PH_AI;
		 break;

	  case CODX_DIU:                   /* 1111: deactivation indication    */
		 event_te   = event_nt = EV_INFO_0;
		 state 		= CI_PH_DI;
		 break;

	  default:
		 event_te	= EV_NIL;
		 state 		= 0xFF;
   }

		/* Call PH_D_IT event driver according to functional grouping */

	if (p_peitab -> pt_ModulMode == PT_MM_LT_S)  {

		if (p_peitab -> event != event_nt) {
			p_peitab -> event  = event_nt;
			isac_event (p_peitab, event_nt);
		}

	} else {

		if (p_peitab -> event != event_te) {
			p_peitab -> event  = event_te;
			isac_event (p_peitab, event_te);
		}

	}

}

/*-------------------------------------------------------------------------*/

uchar 	sbc_read_te_event (p_peitab)
	register struct	peitab  	FAR	*p_peitab;
{
			uchar					event_te;

	   /* evalute 'Cixr' indicating the    */
	   /* L1 device status and create the  */
	   /* corresponding response           */

   switch (p_peitab -> pt_CI_rec & CODX_ALL_BITS)  {

	  case CODX_TIM:                   /* 0000: timing clocks required     */
		 event_te   = EV_INFO_0;
		 break;

	  case CODX_LSL:                   /* 0001: lost signal level          */
		 event_te	= EV_INFO_0;
		 break;

	  case CODX_EI:                    /* 0110: error indication           */
		 event_te 	= EV_ERR_IND;
		 break;

	  case CODX_RESYN:                 /* 0100: resynchronizing            */
		 event_te 	= EV_LOST_FRAMING;
		 break;

	  case CODX_ACT_REQ:               /* 1000: activation request         */
		 event_te 	= EV_INFO_2;
		 break;

	  case CODX_ACT_IND:               /* 1100: activation indication P8   */
		 event_te 	= EV_INFO_4_8;
		 break;
									   /* 1101: activation indicatiom P10  */
									   /* CBFD: this indication has a      */
									   /* completely different meaning     */
									   /* for IEC-Q.                       */
	  case CODX_ACT_IND10:
		 event_te 	= EV_INFO_4_10;
		 break;

	  case CODX_DIU:                   /* 1111: deactivation indication    */
		 event_te   = EV_INFO_0;
		 break;

	  default:
		 event_te	= EV_NIL;
   }

   return (event_te);
}

/*EOF*/
