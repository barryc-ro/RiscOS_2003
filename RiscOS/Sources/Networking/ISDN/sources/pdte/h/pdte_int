
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - pdte_int.h
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s)
 *
 *      - contains all physical DTE interface declarations and definitions.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    TR29-PACK                                        |*/
/*|    PDTE Entity                                      |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef PDTE_INT
#define PDTE_INT

	/* Type of UARTs supported and operational */
    /*-----------------------------------------*/

#define     WD16452				1	/* Western Digital 16452 (with fifos) */
#define     IN8250				2	/* 8250 (PC compatible) UART */
#define     MOTO302				3	/* Motorola 68302 SCCs */
#define     MOTO2681			4	/* Motorola 2681 DUART */
#define     PH26C92				5	/* Philips 26C92 DUART (with fifos) */
#define     UART_API			6	/* No UART, UART is replaced by an API */
#define     PH2691				7	/* Philips 2691 DUART */
#define     MOTO3xx_WITH_16550	8	/* Motorola 68xxx in 16550 emulation mode */


	/* UART's registers access through the i/o or memory address space */
	/*-----------------------------------------------------------------*/

#define UART_IO_MAPPED      'I'
#define UART_MEMORY_MAPPED  'M'
#define UART_NOT_MAPPED  	'-'						/* API, no physical i/o */


	/* Typical 8250 addresses, for PC 8250s */
	/*--------------------------------------*/

	/* COM1 */
	/*------*/
#define	COM1_UART_ADDRESS		0x3F8
#define	COM1_UART_MASK			4		/* bit position in interrupt controller mask register */
#define	COM1_UART_INT_VECTOR_NB	(12)	/* COM1 INT vector (IRQ 4) */

	/* COM2 */
	/*------*/
#define	COM2_UART_ADDRESS		0x2F8
#define	COM2_UART_MASK			3		/* bit position in interrupt controller mask register */
#define	COM2_UART_INT_VECTOR_NB	(11)	/* COM2 INT vector (IRQ 3)*/

	/* COM3 */
	/*------*/
#define	COM3_UART_ADDRESS		0x3E8
#define	COM3_UART_MASK			4		/* bit position in interrupt controller mask register */
#define	COM3_UART_INT_VECTOR_NB	(12)	/* COM3 INT vector (IRQ 4) */

	/* COM4 */
	/*------*/
#define	COM4_UART_ADDRESS		0x2E8
#define	COM4_UART_MASK			3		/* bit position in interrupt controller mask register */
#define	COM4_UART_INT_VECTOR_NB	(11)	/* COM4 INT vector (IRQ 3) */


	/* SCC ids, for 68302 chips */
	/*--------------------------*/

#define     SCC1_302        '1'
#define     SCC2_302        '2'
#define     SCC3_302        '3'
#define     SCC_NO_SCC_302  '?'


    /* Channel ids, for 2681 chips and similar DUARTs */
    /*------------------------------------------------*/

#define     SCC_CHAN_A      'A'     /* Channel A */
#define     SCC_CHAN_B      'B'     /* Channel B */
#define     SCC_NO_CHAN     '?'     /* null value */


    /* Output port ids (identifying junction signals) */
    /* for 2681 and similar chips                     */
    /*------------------------------------------------*/

#define     OP_OP_0         '0'     /* Output port 0 */
#define     OP_OP_1         '1'     /* Output port 1 */
#define     OP_OP_2         '2'     /* Output port 2 */
#define     OP_OP_3         '3'     /* Output port 3 */
#define     OP_OP_4         '4'     /* Output port 4 */
#define     OP_OP_5         '5'     /* Output port 5 */
#define     OP_OP_6         '6'     /* Output port 6 */
#define     OP_OP_7         '7'     /* Output port 7 */
#define     OP_OP_NONE      '?'     /* No output port associated to the junction signal */


    /* Input port ids (identifying junction signals) */
    /* for 2681 and similar chips                     */
    /*------------------------------------------------*/

#define     IP_IP_0         '0'     /* Input port 0 */
#define     IP_IP_1         '1'     /* Input port 1 */
#define     IP_IP_2         '2'     /* Input port 2 */
#define     IP_IP_3         '3'     /* Input port 3 */
#define     IP_IP_4         '4'     /* Input port 4 */
#define     IP_IP_5         '5'     /* Input port 5 */
#define     IP_IP_6         '6'     /* Input port 6 */
#define     IP_IP_7         '7'     /* Input port 7 */
#define     IP_IP_NONE      '?'     /* No input port associated to the junction signal */


	/* Parity values definition */
    /*--------------------------*/

#define     PAR_PARITY_ODD      'O'
#define     PAR_PARITY_EVEN     'E'
#define     PAR_PARITY_MARK     'M'
#define     PAR_PARITY_SPACE    'S'
#define     PAR_NO_PARITY        0


    /* Clock frequencies definitions */
	/*-------------------------------*/

#define PDTE_CLOCK_UNK_FREQ      0          /* Unknown frequency, use default value */
#define PDTE_CLOCK_1_8_MHZ     	'1'         /*  1.8432 MHz */
#define PDTE_CLOCK_15_3_MHZ     '5'         /* 15.36   MHz */
#define PDTE_CLOCK_16_0_MHZ     '6'         /* 16      MHz */
#define PDTE_CLOCK_16_3_MHZ     'M'         /* 16.384  MHz */
#define PDTE_CLOCK_16_5_MHZ     'K'         /* 16.588  MHz */
#define PDTE_CLOCK_16_6_MHZ     '7'         /* 16.667  MHz */
#define PDTE_CLOCK_18_4_MHZ     '8'         /* 18.432  MHz */
#define PDTE_CLOCK_20_0_MHZ     '2'         /* 20      MHz */
#define PDTE_CLOCK_22_1_MHZ     'T'         /* 22.1184 MHz */
#define PDTE_CLOCK_24_0_MHZ     'F'         /* 24      MHz */
#define PDTE_CLOCK_25_0_MHZ     'O'         /* 25      MHz */


	/*  Bit rate definitions */
	/*-----------------------*/

#define PDTE_RATE_EXTERNAL  0x00    /* rate is defined externally (undefined) */
#define PDTE_RATE_UNDEF     0x00    /* rate is defined externally (undefined) */
#define PDTE_RATE_0050       50    	/*     50 bps */
#define PDTE_RATE_0075        5	    /*     75 bps */
#define PDTE_RATE_7             PDTE_RATE_0075
#define PDTE_RATE_0110      110		/*    110 bps */
#define PDTE_RATE_0150      150    	/*    150 bps */
#define PDTE_RATE_0200      200	    /*    200 bps */
#define PDTE_RATE_0300        8	    /*    300 bps */
#define PDTE_RATE_3           	PDTE_RATE_0300
#define PDTE_RATE_0600        6	    /*    600 bps */
#define PDTE_RATE_6   			PDTE_RATE_0600
#define PDTE_RATE_12          1	    /*   1200 bps */
#define PDTE_RATE_24          2		/*   2400 bps */
#define PDTE_RATE_36          3		/*   3600 bps */
#define PDTE_RATE_48          4		/*   4800 bps */
#define PDTE_RATE_72          7		/*   7200 bps */
#define PDTE_RATE_96          9 	/*   9600 bps */
#define PDTE_RATE_120        12 	/*  12000 bps */
#define PDTE_RATE_144        14		/*  14400 bps */
#define PDTE_RATE_168        16		/*  16800 bps */
#define PDTE_RATE_192        19	    /*  19200 bps */
#define PDTE_RATE_216        21	    /*  21600 bps */
#define PDTE_RATE_240        24	    /*  24000 bps */
#define PDTE_RATE_264        26	    /*  26400 bps */
#define PDTE_RATE_288        28	    /*  28800 bps */
#define PDTE_RATE_384        38		/*  38400 bps */
#define PDTE_RATE_480        48	    /*  48000 bps */	/* (synchronous rate) */
#define PDTE_RATE_560        56	    /*  56000 bps */	/* (synchronous rate) */
#define PDTE_RATE_576        57	    /*  57600 bps */
#define PDTE_RATE_640        64	    /*  64000 bps */	/* (line speed) */
#define PDTE_RATE_1152      115		/* 115200 bps */	/* 's' */
#define PDTE_RATE_1280      128	    /* 128000 bps */	/* (line speed) */
#define PDTE_RATE_2304      230	    /* 230400 bps */
									/* No encoding of speed can be greater than 253, please */

	/* Special magic value, for checks */
	/*---------------------------------*/

#define     PDTE_CHECK          0


	/* Junction signal symbolic names */
    /*--------------------------------*/

#define PD_JN_RX    		'r'
#define PD_JN_TX    		'X'

#define PD_JN_DTR			'D'
#define PD_JN_RTS   		'R'

#define PD_JN_CTS   		'c'
#define PD_JN_DSR			'd'
#define PD_JN_CD 			'~'
#define PD_JN_RI			'i'
#define PD_JN_DSR_OR_RI		'j'
#define PD_JN_AUX			'x'
#define PD_JN_CTS2			'h'


    /* Termination, flow control and miscellaneous control characters */
    /*----------------------------------------------------------------*/

#define     PD_NUL      (0x00)      /* NUL                      ASCII code */
#define     PD_ETX      (0x03)      /* ETX                      ASCII code */
#define     PD_EOT      (0x04)      /* EOT                      ASCII code */
#define     PD_ENQ      (0x05)      /* ENQ                      ASCII code */
#define     PD_ACK      (0x06)      /* ACK                      ASCII code */
#define     PD_BEL      (0x07)      /* BEL                      ASCII code */
#define     PD_BS       (0x08)      /* BS   (backspace)         ASCII code */
#define     PD_HT		(0x09)      /* HT   (tab)				ASCII code */
#define     PD_LF       (0x0A)      /* LF   (line feed)         ASCII code */
#define     PD_CR       (0x0D)      /* CR   (carriage return)   ASCII code */
#define     PD_DLE      (0x10)      /* DLE                      ASCII code */
#define     PD_XON      (0x11)      /* DC1                      ASCII code */
#define     PD_DC2      (0x12)      /* DC2                      ASCII code */
#define     PD_XOFF     (0x13)      /* DC3                      ASCII code */
#define     PD_CAN      (0x18)      /* CAN (cancel)             ASCII code */
#define     PD_ESC      (0x1B)      /* ESC (escape)             ASCII code */
#define     PD_SPACE    (0x20)      /* ' '                      ASCII code */
#define     PD_PLUS     (0x2B)      /* '+'                      ASCII code */
#define     PD_DEL      (0x7F)      /* DEL                      ASCII code */


    /* Interrupt type to process masks, for interrupt routine entry points */
    /*---------------------------------------------------------------------*/

#define     PD_IT_RECEIVE       (0x01)
#define     PD_IT_TRANSMIT      (0x02)
#define     PD_IT_OTHER         (0x04)


    /* Select compilation parameters */
    /*-------------------------------*/

#include    "dte_par.h"
#include    "pdte_par.h"

#ifndef PDTE_ASSERT
#	define	PDTE_ASSERT		ASSERT
#endif

#if	UART == UART_API
#	undef	UART_IO
#	define	UART_IO		UART_NOT_MAPPED
#endif

#ifndef PD_NB_BREAK_LOOPS_1200
#	define	PD_NB_BREAK_LOOPS_1200	0x0A00	/* suitable value for a 68302 at 18.432 MHz */
#endif

	/* Input and output port ids (identifying junction signals) */
	/* for 68302 chip                                           */
	/*----------------------------------------------------------*/

#   define  PO_INVERTED     0x80    /* Indicates that the signal logic is inverted */

#   define  PO_NO_PORT      0x3F    /* No port defined for this signal */
									/* Same value as for PO_PB15, if it had existed ! */

#   define  PO_EXTERNAL_PORT	PO_NO_PORT	/* The signal is not connected to a 68302 port, but to some external device */
											/* For DTR and RTS, the signal value will be retrieved through the macros Hdl_get_dtr() and Hdl_get_rts() */

	/* CD and CTS, SCC1 and SCC3 */
						/*   0  is reserved */
#   define  PO_CD1          (1)
#   define  PO_CTS1         (2)
#   define  PO_CD3          (3)
#   define  PO_CTS3         (4)

	/* Dedicated on-chip peripheral pin, port A */

#   define  PO_RXD2			(16 +  0)
#   define  PO_TXD2         (16 +  1)
#   define  PO_RCLK2        (16 +  2)
#   define  PO_TCLK2        (16 +  3)
#   define  PO_CTS2         (16 +  4)
#   define  PO_RTS2         (16 +  5)
#   define  PO_CD2          (16 +  6)
#   define  PO_BRG2         (16 +  7)
#   define  PO_RXD3         (16 +  8)
#   define  PO_TXD3         (16 +  9)
#   define  PO_RCLK3        (16 + 10)
#   define  PO_TCLK3        (16 + 11)
#   define  PO_BRG3         (16 + 12)
#   define  PO_DREQ         (16 + 13)
#   define  PO_DACK         (16 + 14)
#   define  PO_DONE         (16 + 15)


	/* General purpose i/o chip, port A */

#   define  PO_PA0          (32 +  0)
#   define  PO_PA1          (32 +  1)
#   define  PO_PA2          (32 +  2)
#   define  PO_PA3          (32 +  3)
#   define  PO_PA4          (32 +  4)
#   define  PO_PA5          (32 +  5)
#   define  PO_PA6          (32 +  6)
#   define  PO_PA7          (32 +  7)
#   define  PO_PA8          (32 +  8)
#   define  PO_PA9          (32 +  9)
#   define  PO_PA10         (32 + 10)
#   define  PO_PA11         (32 + 11)
#   define  PO_PA12         (32 + 12)
#   define  PO_PA13         (32 + 13)
#   define  PO_PA14         (32 + 14)
#   define  PO_PA15         (32 + 15)

	/* Dedicated on-chip peripheral pin, port B */

#   define  PO_IACK7        (48 +  0)
#   define  PO_IACK6        (48 +  1)
#   define  PO_IACK1        (48 +  2)
#   define  PO_TIN1         (48 +  3)
#   define  PO_TOUT1        (48 +  4)
#   define  PO_TIN2         (48 +  5)
#   define  PO_TOUT2        (48 +  6)
#   define  PO_WDOG         (48 +  7)

	/* General purpose i/o chip, port B */

#   define  PO_PB0          (64 +  0)
#   define  PO_PB1          (64 +  1)
#   define  PO_PB2          (64 +  2)
#   define  PO_PB3          (64 +  3)
#   define  PO_PB4          (64 +  4)
#   define  PO_PB5          (64 +  5)
#   define  PO_PB6          (64 +  6)
#   define  PO_PB7          (64 +  7)

#   define  PO_PB8          (64 +  8)
#   define  PO_PB9          (64 +  9)
#   define  PO_PB10         (64 + 10)
#   define  PO_PB11         (64 + 11)

#if (UART == MOTO3xx_WITH_16550)
#	define	PO_16550_TX		(80 + 1)
#	define	PO_16550_RX		(80 + 2)
#	define	PO_16550_DTR	(80 + 3)
#	define	PO_16550_DSR	(80 + 4)
#	define	PO_16550_RTS	(80 + 5)
#	define	PO_16550_CTS	(80 + 6)
#	define	PO_16550_RI		(80 + 7)
#	define	PO_16550_CD		(80 + 8)
#	define	PO_16550_OUT1	(80 + 9)
#	define	PO_16550_OUT2	(80 + 10)
#	define	PO_16550_LOOP	(80 + 11)
#endif

#   define  PO_ALWAYS_OFF	(80 + 15)
#   define  PO_ALWAYS_ON	(PO_ALWAYS_OFF | PO_INVERTED)


/*---------------------------------------------------------------------------
 *          PDTE CONFIGURATION STRUCTURE
 *--------------------------------------------------------------------------*/

#if UART_IO == UART_IO_MAPPED
#  	define  pd_int_io_addr          uint
#endif
#if UART_IO == UART_MEMORY_MAPPED
#  	define  pd_int_io_addr          uchar FAR*
#endif
#if UART_IO == UART_NOT_MAPPED
#  	define  pd_int_io_addr          short
#endif

struct pdte_config {

	uchar           uart_model_id;      /* UART model id : */
										/* WD16452, IN8250, MOTO302, MOTO2681, PH2691, PH26C92, etc */
										/* MOTO3xx_WITH_16550 : Motorola 68302 with 16550 emulation (for example MC68PM302) */
	pd_int_io_addr  scc_base_address;   /* SCC/channel base address : */
										/* 68302 : SCC base address */
										/* 2681, 26C92 : DUART base address */
										/* 16452 : DUART base address */
										/* 8250  : UART base address. For PC COM ports, typical values are : */
										/*         COM1: 0x3F8, COM2: 0x2F8, COM3: 0x3E8, COM4: 0x2E8 (See #defines COM1_UART_ADDRESS etc. supra) */
										/* Other : set to 0 */
    uchar           scc_id;             /* SCC/channel id : */
                                        /* 68302 : SCC id (SCC1_302, SCC2_302, SCC3_302) */
                                        /* 2681, 26C92 : channel id (SCC_CHAN_A, SCC_CHAN_B) */
										/* API : name of the API entity */
										/* Other : set to 0 */
    uchar           rx_op_id;           /* RX output signal wiring information */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* MOTO3xx_WITH_16550 : PO_16550_TX typically */
										/* Other : set to 0 */
    uchar           tx_ip_id;           /* TX input  signal wiring information */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* MOTO3xx_WITH_16550 : PO_16550_RX typically */
										/* Other : set to 0 */
    uchar           dtr_ip_id;          /* DTR input port wiring information */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
                                        /* 2681, 26C92 : IP_IP_0..IP_IP_7, or IP_IP_NONE if DTR junction signal is not wired to the 2681 IP */
										/* MOTO3xx_WITH_16550 : PO_16550_DTR typically */
										/* Other : set to 0 */
    uchar           rts_ip_id;          /* RTS input port wiring information */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* 2681, 26C92 : IP_IP_0..IP_IP_7, IP_IP_NONE if RTS junction signal is not wired to the 2681 IP */
										/* MOTO3xx_WITH_16550 : PO_16550_RTS typically */
										/* Other : set to 0 */
    ushort          o_port_mask_init;   /* Initial value of the 'output port register' */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* MOTO3xx_WITH_16550 : 0 typically */
										/* 2681, 26C92 : initial value of the OPCR register (which contains informations about all port outputs) */
                                        /* 2681, 26C92 : typical value : 0 */
                                        /* Other : set to 0 */
    uchar           cts_op_id;          /* Output port associated to the CTS junction signal */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* MOTO3xx_WITH_16550 : PO_16550_CTS typically */
										/* 2681, 26C92 : OP_OP_0..OP_OP7, or OP_OP_NONE if CTS is not wired */
                                        /* Other : set to 0 */
    uchar           dcd_op_id;          /* Output port associated to the DCD junction signal */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* MOTO3xx_WITH_16550 : PO_16550_CD typically */
										/* 2681, 26C92 : OP_OP_0..OP_OP7, or OP_OP_NONE if DCD is not wired */
                                        /* Other : set to 0 */
    uchar           dsr_op_id;          /* Output port associated to the DSR junction signal */
                                        /* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* MOTO3xx_WITH_16550 : PO_16550_DSR typically */
										/* 2681, 26C92 : OP_OP_0..OP_OP7, or OP_OP_NONE if DSR is not wired */
                                        /* Other : set to 0 */
	uchar           ri_op_id;           /* Output port associated to the RI junction signal */
										/* MOTO3xx_WITH_16550 : PO_16550_RI typically */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
                                        /* 2681, 26C92 : OP_OP_0..OP_OP7, or OP_OP_NONE if RI is not wired */
                                        /* Other : set to 0 */
    uchar           aux_op_id;          /* Output port associated to the AUX supplementary 'junction' signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT (typical) */
										/* MOTO3xx_WITH_16550 : same as 68302 */
										/* 2681, 26C92 : OP_OP_0..OP_OP7, or OP_OP_NONE if RI is not wired */
                                        /* Other : set to 0 */
    ushort          it1_mask_init;      /* Initial value of the 'interrupt mask', part 1 */
										/* 2681, 26C92 : initial value of the IMR register (which contains information about both channels and input port) */
                                        /* 2681, 26C92 : typical value : 0 */
                                        /* Other : set to 0 */
    ushort          it2_mask_init;      /* Initial value of the 'interrupt mask', part 2 */
										/* 2681, 26C92 : initial value of bits 3-0 of the ACR register (which contains information about input port) */
                                        /* 2681, 26C92 : typical value : 0 */
                                        /* Other : set to 0 */
    ushort          clock1;             /* Clock information, part 1 */
                                        /* 68302       : value of the SCON register (bits WOMS and EXTC) to be ORed with the value computed internally */
                                        /* 2681, 26C92 : value of the CSR register (when external clock is selected) */
										/* 2681, 26C92 : typical value : 0 or 0xEE */
                                        /* 2681, 26C92 : This value is only used when the clock is external */
                                        /* Other : set to 0 */
    ushort          clock2;             /* Clock information, part 2 */
                                        /* 2681, 26C92 : value of the ACR register */
                                        /* 2681, 26C92 : typical value : 0xF0 */
                                        /* 2681, 26C92 : This value may be reprogrammed for speed change, input port management */
										/* Other : set to 0 */
    ushort          counter_val;        /* Embedded counter value */
                                        /* 2681, 26C92 : value of the CTUR register */
                                        /* 2681, 26C92 : typical value : 0x20 */
                                        /* 2681, 26C92 : Used only when the actual hardware chip is a 2681 */
										/* Other : set to 0 */
    ushort          max_idl;            /* Number of idle characters after which a receive buffer is complete */
                                        /* 68302 : number of idle characters after which a receive buffer is closed */
                                        /* Other : set to 0 */
    uchar           r_n_bd;             /* Number of reception buffers */
										/* 68302 : number of BDs used for reception */
										/* Other : set to 0 */
	uchar           x_n_bd;             /* Number of transmission buffers */
										/* 68302 : max number of BDs used for transmission */
										/* Other : set to 0 */
    short           r_size;             /* Size of the receive fifo / receive buffers */
                                        /* 68302 : size of the receive buffers [1..BUFFER_DATA_LGTH] */
                                        /* 2681  : size of the receive fifo : 1 or 4 */
                                        /* 2681  : a value of 1 indicates : interrupt upon each received character */
                                        /* 2681  : a value of 4 indicates : interrupt upon receive fifo full */
										/* 26C92 : size of the receive fifo :  */
                                        /* 26C92 : Possible values : 1, 3, 6, 8 */
                                        /* Other : set to 0 */
    short           x_size;             /* Size of the transmit fifo / transmit buffers */
										/* 68302 : unused. Set to 0 */
										/* 2681  : must be set to 1 */
                                        /* 26C92 : size of the transmit fifo :  */
                                        /* 26C92 : Possible values : 1, 4, 6, 8 */
                                        /* Other : set to 0 */
	uchar           clock_frequency;    /* Frequency of the clock (crystal/oscillator) driving the UART */
										/* 68302 : 0: use System_rate_Hz */
										/* 68302 : PDTE_CLOCK_15_3_MHZ, PDTE_CLOCK_16_0_MHZ, PDTE_CLOCK_16_6_MHZ, etc. */
										/* Other : set to 0 */
	uchar           scc_it_ix;          /* Index of associated interrupt routine */
										/* this value has to be supplied as argument of the u302_it() interrupt routine */
	ushort			pad_min_idl;		/* Default minimum number of idle characters to wait for before */
										/* considering buffer reception is complete, in PAD with parameter 4:1 */
										/* 68302 : significant. 0: use default value */
										/* Other : set to 0 */
	struct {							/* V.14 specific processing description */
		uchar		v14_n_r_bd;  		/* In V.14 mode, number of reception buffers */
										/* 68302 : in V.14 mode, number of BDs used for reception. 0: use default */
										/* Other : set to 0 */
		uchar		v14_n_x_bd;			/* In V.14 mode, number of transmission buffers */
										/* 68302 : in V.14 mode, max number of BDs used for transmission. 0: use default */
										/* Other : set to 0 */
		short		v14_sync_block_size;/* In V.14 mode, size of the synchronous blocks */
										/* 68302 : in V.14 mode, size of the synchronous blocks. 0: use default */
										/* Other : set to 0 */
		short		v14_x_bd_size;		/* In V.14 mode, size of the transmit buffers */
										/* 68302 : in V.14 mode, size of the transmit BDs. 0: use default. */
										/* Other : set to 0 */
		short		v14_nb_idle;		/* In V.14, number of idle characters before closing a reception buffer */
										/* 68302 : number of idle characters before closing a receive BD. 0: use default. */
										/* Other : set to 0 */
	} v14_config;
	uchar           cts2_op_id;         /* Output port associated to the secondary CTS junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* Other : set to 0 */
	struct {							/* V.120 specific processing description */
		short 		r_v120_size;  		/* In asynchronous V.120, frame size. 0: select default value (260) */
										/* 68302 : size of the receive BD in V.120 + 2 */
										/* Other : set to 0 */
		short 		r_dc_v120_size;		/* In asynchronous V.120, frame size. 0: select default value (buffer size) */
										/* 68302 : size of the receive BD in (V.120 + Data Compression) */
										/* Other : set to 0 */
	} v120_config;
	struct {							/* V.110 specific processing description */
		uchar		v110_n_r_bd;  		/* In asynchronous V.110 mode, number of reception buffers */
										/* 68302 : in asynchronous V.110 mode, number of BDs used for reception. 0: use default */
										/* Other : set to 0 */
		uchar		v110_n_x_bd;		/* In asynchronous V.110 mode, number of transmission buffers */
										/* 68302 : in asynchronous V.110 mode, max number of BDs used for transmission. 0: use default */
										/* Other : set to 0 */
		short		v110_sync_block_size;/* CURRENTLY UNUSED. Please set to 0 */
		short		v110_x_bd_size;		/* In asynchronous V.110 mode, size of the transmit buffers */
										/* 68302 : in asynchronous V.110 mode, size of the transmit BDs. 0: use default. */
										/* Other : set to 0 */
		short		v110_nb_idle;		/* In asynchronous V.110, number of idle characters before closing a reception buffer */
										/* 68302 : number of idle characters before closing a receive BD. 0: use default. */
										/* Other : set to 0 */
	} v110_config;
	short			nb_da_rq_low;		/* Low mark,  local PDTE-DTE_INT flow control queue */
	short			nb_da_rq_high;		/* High mark, local PDTE-DTE_INT flow control queue */
										/* 0: disable local flow control */
	uchar			autobaud;			/* Autobaud processing */
										/* PD_AB_NONE (0): autobaud is disabled */
										/* PD_AB_ON_AT:  autobaud detection continuous in AT command mode */
										/* PD_AB_ALWAYS_DISABLED: autobaud is disabled, and cannot be enabled (by AT command) */
#										define	PD_AB_NONE				0
#										define	PD_AB_ON_AT				1
#										define	PD_AB_ON_DTR			2		/* reserved for future implementation */
#										define	PD_AB_ALWAYS_DISABLED	0x40

	struct {
		uchar		dsr_or_ri_op_id;	/* Output port associated to the 'DSR or RI' junction signal */
										/* 68302 : PO_xxxx [ | PO_INVERTED ], or PO_NO_PORT */
										/* Other : set to 0 */
	}				more_jn_signals;
#   define          PDTE_CONFIG_RES     0
	ent_id_t		user_entity;		/* default entity associated to PDTE. 0: PDTE_ENTITY (in general ENT_DTE_INT) */

	struct {							/* flow control */
		uchar		to_dte_fifo_high;	/* high mark for (transmit) queue from PDTE to DTE. 0: use default value (PDTE_DEF_TO_DTE_FIFO_HIGH) */
		uchar		to_dte_fifo_low;	/* low mark for (transmit) queue from PDTE to DTE. 0: use default value (PDTE_DEF_TO_DTE_FIFO_LOW) */
	}				fc;

	uchar           check;              /* Sentinel, for check. Must be set to PDTE_CHECK. */
};


	/* Access to the configuration structure through the p_pdte_config pointer */
	/*-------------------------------------------------------------------------*/

#define     I_pdte_aux_op_id            (p_pdte_config->aux_op_id)
#define     I_pdte_check                (p_pdte_config->check)
#define     I_pdte_clock1               (p_pdte_config->clock1)
#define     I_pdte_clock2               (p_pdte_config->clock2)
#define     I_pdte_clock_frequency      (p_pdte_config->clock_frequency)
#define     I_pdte_counter_val          (p_pdte_config->counter_val)
#define     I_pdte_cts_op_id            (p_pdte_config->cts_op_id)
#define     I_pdte_cts2_op_id			(p_pdte_config->cts2_op_id)
#define     I_pdte_dcd_op_id            (p_pdte_config->dcd_op_id)
#define     I_pdte_dsr_op_id            (p_pdte_config->dsr_op_id)
#define     I_pdte_dsr_or_ri_op_id		(p_pdte_config->more_jn_signals.dsr_or_ri_op_id)
#define     I_pdte_dtr_ip_id            (p_pdte_config->dtr_ip_id)
#define     I_pdte_ent_api				(p_pdte_config->scc_id)
#define     I_pdte_it1_mask_init        (p_pdte_config->it1_mask_init)
#define     I_pdte_it2_mask_init        (p_pdte_config->it2_mask_init)
#define     I_pdte_max_idl              (p_pdte_config->max_idl)
#define     I_pdte_o_port_mask_init     (p_pdte_config->o_port_mask_init)
#define     I_pdte_pad_min_idl			(p_pdte_config->pad_min_idl)
#define     I_pdte_r_dc_v120_size		(p_pdte_config->v120_config.r_dc_v120_size)
#define     I_pdte_r_size               (p_pdte_config->r_size)
#define     I_pdte_r_n_bd               (p_pdte_config->r_n_bd)
#define     I_pdte_r_v120_size			(p_pdte_config->v120_config.r_v120_size)
#define     I_pdte_ri_op_id             (p_pdte_config->ri_op_id)
#define     I_pdte_rts_ip_id            (p_pdte_config->rts_ip_id)
#define     I_pdte_rx_op_id             (p_pdte_config->rx_op_id)
#define     I_pdte_scc_base_address     (p_pdte_config->scc_base_address)
#define     I_pdte_scc_id               (p_pdte_config->scc_id)
#define     I_pdte_scc_it_ix            (p_pdte_config->scc_it_ix)
#define     I_pdte_tx_ip_id             (p_pdte_config->tx_ip_id)
#define     I_pdte_uart_model_id        (p_pdte_config->uart_model_id)
#define     I_pdte_x_size               (p_pdte_config->x_size)
#define     I_pdte_x_n_bd               (p_pdte_config->x_n_bd)

#define     I_pdte_v14_n_r_bd			(p_pdte_config->v14_config.v14_n_r_bd)
#define     I_pdte_v14_n_x_bd			(p_pdte_config->v14_config.v14_n_x_bd)
#define     I_pdte_v14_nb_idle			(p_pdte_config->v14_config.v14_nb_idle)
#define     I_pdte_v14_sync_block_size	(p_pdte_config->v14_config.v14_sync_block_size)
#define     I_pdte_v14_x_bd_size		(p_pdte_config->v14_config.v14_x_bd_size)

#define     I_pdte_v110_n_r_bd			(p_pdte_config->v110_config.v110_n_r_bd)
#define     I_pdte_v110_n_x_bd			(p_pdte_config->v110_config.v110_n_x_bd)
#define     I_pdte_v110_nb_idle			(p_pdte_config->v110_config.v110_nb_idle)
#define     I_pdte_v110_sync_block_size	(p_pdte_config->v110_config.v110_sync_block_size)
#define     I_pdte_v110_x_bd_size		(p_pdte_config->v110_config.v110_x_bd_size)

#define     I_pdte_nb_da_rq_low			(p_pdte_config->nb_da_rq_low)
#define     I_pdte_nb_da_rq_high		(p_pdte_config->nb_da_rq_high)
#define     I_pdte_autobaud             (p_pdte_config->autobaud)
#define     I_pdte_user_entity			(p_pdte_config->user_entity)

#define     I_pdte_to_dte_fifo_high		(p_pdte_config->fc.to_dte_fifo_high)
#define     I_pdte_to_dte_fifo_low		(p_pdte_config->fc.to_dte_fifo_low)


	/* Flow control types */

#define FC_XON_XOFF             'X'
#define FC_V24_FLOW_CONTROL     'J'


    /* Timer indexes */

#if ((DTE_PAD == ON) || (((DTE_MODEM == ON) || (DTE_V120 == ON)) && (DTE_NO_SW_POLLING == OFF)))
#	define	TPOLLING_X      0   /*  received data polling timer */
#endif
#define     TLATENCY_X      1   /*  latency timer           */

#define     PDTE_NTIMERS    2

    /* Timer primitives codes */

#if ((DTE_PAD == ON) || (((DTE_MODEM == ON) || (DTE_V120 == ON)) && (DTE_NO_SW_POLLING == OFF)))
#	define	TI_POLLING      'F' /*  received data polling timer */
#endif

#define     TI_LATENCY      'L' /*  latency timer   */


	/* PDTE working modes, general and AT-related modes */

#define     DTE_ATREAD     		'C' /* AT command detection   */
#define     DTE_AT_AUTOBAUD		'c' /* AT command detection with automatic baud rate detection */
#define     DTE_ATABORT     	'A' /* any character sending */
#define     DTE_DLEFMT_RCV  	'f' /* dle filtering in data sent to DTE    */
#define     DTE_DLEFMT_SND  	'F' /* dle filtering in data received from DTE      */
#define     DTE_PLUSFMT_SND 	'P' /* +++ processing in data received from DTE (modem or V.120) */
#define     DTE_RAWFMT_SND  	'R' /* raw transparent mode in data received from DTE    */
#define     DTE_IDLE        	'I' /* idle no processing    */

#define     DTE_RAW_V14			'4' /* V.14 mode */
#define     DTE_RAW_ASYN_V110	'1' /* Asynchronous V.110 mode */
#define     DTE_ASYN_V120		'2' /* Asynchronous V.120 mode : similar to DTE_PLUSFMT_SND */
#define     DTE_ASYN_V120_DC	'3' /* Asynchronous V.120, with data compression mode : similar to DTE_PLUSFMT_SND */

	/* Modes for PAD */

#if DTE_PAD == ON
#   define      DTE_PAD_IDLE_ESCAPE 'i' /* idle + escape character detection */
#   define      DTE_PAD_COMMAND     'X' /* PAD command mode */
#   define      DTE_PAD_DATA        'x' /* PAD data mode */
#   define      DTE_PAD_DATA_OPENED 'y' /* PAD data mode, VC opened. Transient state */

#   define      DTE_IDLE_ESCAPE  		DTE_PAD_IDLE_ESCAPE		/* obsolete name */
#endif

	/* Junction signals states */

#define		JSIG_ON			'1'						/* signal is ON */
#define		JSIG_OFF		'0'						/* signal is OFF */
#define		JSIG_UNKNOWN	'?'						/* signal state unknown */


	/* Entity entry points */

#   if NEW_FCT_STYLE == ON
	uchar pd_ph (struct message FAR *p_msg);
#else
	uchar pd_ph ();
#endif

	/* Interrupt routines entry points */

#if (UART == MOTO302) || (UART == MOTO3xx_WITH_16550)
#   if NEW_FCT_STYLE == ON
        void    u302_it         (uchar);
#   else
		void    u302_it         ();
#   endif
#endif

#if (UART == MOTO2681) || (UART == PH26C92) || (UART == PH2691)
#   if NEW_FCT_STYLE == ON
        void    u2681_it            (uchar, uchar, uchar, uchar);
#   else
        void    u2681_it            ();
#   endif
#endif

#if (UART == WD16452) || (UART == IN8250)
#   if NEW_FCT_STYLE == ON
        void    u8250_it        (uchar);
#   else
        void    u8250_it        ();
#   endif
#endif

    /* Interface macros and functions declarations */

#define Hdl_build_object(jn_nb, scc_nb) hdl_build_object (jn_nb, scc_nb)
#define Hdl_change_mode(p_pdte_ctxt, mode, more)    hdl_change_mode (p_pdte_ctxt, mode, more)
#   define  PD_PAD_DTR_IGNORE       ('i')
#   define  PD_PAD_DTR_JUNCTION     ('j')
#   define  PD_PAD_DTR_ESCAPE       ('s')

#define Hdl_da_rq_received(p_pdte_ctxt, sapi) hdl_da_rq_received (p_pdte_ctxt, sapi)
#define Hdl_get_autobaud(p_pdte_ctxt) 			hdl_get_autobaud (p_pdte_ctxt)
#define Hdl_get_block_size(p_pdte_ctxt) 		hdl_get_block_size (p_pdte_ctxt)
#define Hdl_get_cap_autobaud(p_pdte_ctxt, rate)	hdl_get_cap_autobaud (p_pdte_ctxt, rate)
#	define	PD_AB_CAP_MONOBAUD	0x01				/* Monobaud possible */
#	define	PD_AB_CAP_AUTOBAUD	0x02				/* Autobaud possible */

#define Hdl_get_junction_rate(p_pdte_ctxt) 		hdl_get_junction_rate (p_pdte_ctxt)
#define Hdl_get_v120_frame_size(p_pdte_ctxt)	hdl_get_v120_frame_size (p_pdte_ctxt)
#define Hdl_init(p_hdl_mgt, p_pdte_config, scc_nb, id, echo, word_length, stop_nb, parity, rate)\
										hdl_init (p_hdl_mgt, p_pdte_config, scc_nb, id, echo, \
										word_length, stop_nb, parity, rate)
#define Hdl_is_xmt_congested(p_pdte_ctxt)   	pd_is_xmt_congested (p_pdte_ctxt)
#define Hdl_jn_rq_received(p_pdte_ctxt, sapi)   hdl_jn_rq_received (p_pdte_ctxt, sapi)
#define Hdl_reinit(p_hdl_mgt)					hdl_reinit (p_hdl_mgt)
#define Hdl_reset_break(p_pdte_ctxt)        	hdl_reset_break (p_pdte_ctxt)
#define Hdl_reset_busy(p_pdte_ctxt)				hdl_reset_busy (p_pdte_ctxt)
#define Hdl_reset_config(p_hdl_mgt)				hdl_reset_config (p_hdl_mgt)
#define Hdl_send_break_in(p_pdte_ctxt, p_msg)	hdl_send_break_in (p_pdte_ctxt, p_msg)
#define Hdl_send_busy_in(p_pdte_ctxt)			hdl_send_busy_in (p_pdte_ctxt)
#define Hdl_send_clear_busy_in(p_pdte_ctxt)		hdl_send_clear_busy_in (p_pdte_ctxt)
#define Hdl_send_data_in(p_pdte_ctxt, p_msg)	hdl_send_data_in (p_pdte_ctxt, p_msg)
#define Hdl_send_setparm_in(p_pdte_ctxt, p_msg)	hdl_send_setparm_in (p_pdte_ctxt, p_msg); p_msg = P_NIL
#define Hdl_send_signal_in(p_pdte_ctxt, p_msg)	Free_msg (p_msg); p_msg = P_NIL
#define Hdl_set_at_char_format(p_pdte_ctxt, at_nbits, at_parity)	\
												hdl_set_at_char_format (p_pdte_ctxt, at_nbits, at_parity)
#define Hdl_set_at_echo(p_pdte_ctxt, echo)		hdl_set_at_echo (p_pdte_ctxt, echo)
#define Hdl_set_autobaud(p_pdte_ctxt, val)		hdl_set_autobaud (p_pdte_ctxt, val)
#define Hdl_set_bit_m(p_pdte_ctxt, on_off)		hdl_set_bit_m (p_pdte_ctxt, on_off)
#define Hdl_set_block_size(p_pdte_ctxt, size)	hdl_set_block_size (p_pdte_ctxt, size)
#define Hdl_set_break(p_pdte_ctxt)				hdl_set_break (p_pdte_ctxt)
#define Hdl_set_char(p_pdte_ctxt, reg, new_char)	hdl_set_char (p_pdte_ctxt, reg, new_char)
#   define  CHAR_S2         '2'
#   define  CHAR_S3         '3'
#   define  CHAR_S5         '5'

#define	Hdl_set_cd_in_pad_command(p_pdte_ctxt, on_off)		\
												hdl_set_cd_in_pad_command (p_pdte_ctxt, on_off)
#define Hdl_set_cd_proc(p_pdte_ctxt, proc)		hdl_set_cd_proc (p_pdte_ctxt, proc)
#	define	PD_CD_FORCE			0				/* force CD ON */
#	define	PD_CD_PROCESS		1				/* process CD 'normally' */

#define Hdl_set_ctxt(i_jn)              		hdl_set_ctxt (i_jn)

#define Hdl_set_dsr_proc(p_pdte_ctxt, proc)		hdl_set_dsr_proc (p_pdte_ctxt, proc)
#	define	PD_DSR_FORCE		0				/* force DSR ON */
#	define	PD_DSR_PROCESS		1				/* process DSR 'normally' */

#define Hdl_set_dtr_proc(p_pdte_ctxt, proc)		hdl_set_dtr_proc (p_pdte_ctxt, proc)
#	define	PD_DTR_IGNORE		0				/* ignore DTR changes of states (DTR is considered to be always ON) */
#	define	PD_DTR_PROCESS		1				/* process DTR changes of states */

#define Hdl_set_fc(p_pdte_ctxt, xon, rts)		hdl_set_fc (p_pdte_ctxt, xon, rts)

#if DTE_NO_PLUS_PLUS_PLUS == ON
#	define Hdl_set_s012(p_pdte_ctxt, s012_ms)
#else
#	define Hdl_set_s012(p_pdte_ctxt, s012_ms)	hdl_set_s012 (p_pdte_ctxt, s012_ms)
#endif

#define	Hdl_set_v120_idle(p_pdte_ctxt, duration)	\
										hdl_set_v120_idle (p_pdte_ctxt, duration)
#define Hdl_set_line_rate(p_pdte_ctxt, rate)	hdl_set_line_rate (p_pdte_ctxt, rate)
#define Hdl_set_parameters(p_pdte_ctxt, p_msg)	hdl_set_parameters (p_pdte_ctxt, p_msg)

#if DTE_MESSAGE_INTERFACE == ON
#define Hdl_set_transp(p_pdte_ctxt, entity, mode)	\
												hdl_set_transp (p_pdte_ctxt, entity, mode)
#endif

#define Hdl_start_latency_timer(p_pdte_ctxt) 	hdl_start_latency_timer (p_pdte_ctxt)
#define Hdl_stop_latency_timer(p_pdte_ctxt)		hdl_stop_latency_timer (p_pdte_ctxt)
#define Hdl_stop_timers(p_pdte_ctxt)			hdl_stop_timers (p_pdte_ctxt)
#define Hdl_suppress_pad_messages(p_pdte_ctxt, on_off) \
                                        hdl_suppress_pad_messages (p_pdte_ctxt, on_off)
#define Hdl_switch_autobaud(p_pdte_ctxt, on_off)	hdl_switch_autobaud (p_pdte_ctxt, on_off)
#define Hdl_timer_expiration(p_pdte_ctxt, ix, sn)    \
										hdl_timer_expiration (p_pdte_ctxt, ix, sn)

#ifndef Hdl_get_dtr
#	define Hdl_get_dtr(p_pdte_ctxt)        		hdl_get_jn (p_pdte_ctxt, PD_JN_DTR)
#endif
#ifndef Hdl_get_rts
#	define Hdl_get_rts(p_pdte_ctxt)        		hdl_get_jn (p_pdte_ctxt, PD_JN_RTS)
#endif
#ifndef Hdl_set_cts
#	define Hdl_set_cts(p_pdte_ctxt, state) 		hdl_set_jn (p_pdte_ctxt, PD_JN_CTS, state)
#endif
#ifndef Hdl_set_dsr
#	define Hdl_set_dsr(p_pdte_ctxt, state)		hdl_set_jn (p_pdte_ctxt, PD_JN_DSR, state)
#endif
#ifndef Hdl_set_cd
#	define Hdl_set_cd(p_pdte_ctxt, state)  		hdl_set_jn (p_pdte_ctxt, PD_JN_CD, state)
#endif
#ifndef Hdl_set_ri
#	define Hdl_set_ri(p_pdte_ctxt, state)		hdl_set_jn (p_pdte_ctxt, PD_JN_RI, state)
#endif
#ifndef Hdl_set_aux
#	define Hdl_set_aux(p_pdte_ctxt, state)		hdl_set_jn (p_pdte_ctxt, PD_JN_AUX, state)
#endif

#ifndef Pd_cp_get_dtr
#	define Pd_cp_get_dtr()                 		pd_cp_get_jn (PD_JN_DTR)
#endif

#if NEW_FCT_STYLE == ON

    uchar               hdl_build_object            (uchar, uchar);
	void                hdl_change_mode             (uchar FAR *, uchar, uchar);
	void                hdl_da_rq_received          (uchar FAR *, sapi_t);
	uchar				hdl_get_autobaud			(uchar FAR *);
	int                 hdl_get_block_size          (uchar FAR *);
	uchar				hdl_get_cap_autobaud		(uchar FAR *, uchar);
	uchar               hdl_get_jn                  (uchar FAR *, uchar);
	uchar				hdl_get_junction_rate       (uchar FAR *);
	short				hdl_get_v120_frame_size		(uchar FAR *);
	uchar               hdl_init                    (uchar FAR *,
													 struct pdte_config FAR *,
													 uchar,
													 uchar,
													 uchar,
													 uchar,
													 uchar,
													 uchar,
													 uchar);
	void                hdl_jn_rq_received          (uchar FAR *, sapi_t);
	uchar               hdl_reinit                  (uchar FAR *);
	void                hdl_reset_break             (uchar FAR *);
	void                hdl_reset_busy				(uchar FAR *);
	uchar               hdl_reset_config			(uchar FAR *);
	void				hdl_send_break_in			(uchar FAR *, struct message FAR *);
	void                hdl_send_busy_in            (uchar FAR *);
	void                hdl_send_clear_busy_in      (uchar FAR *);
	uchar               hdl_send_data_in            (uchar FAR *, struct message FAR *);
	void                hdl_send_setparm_in         (uchar FAR *, struct message FAR *);
	void                hdl_set_at_char_format		(uchar FAR *, uchar, uchar);
	void                hdl_set_at_echo             (uchar FAR *, uchar);
	void                hdl_set_autobaud			(uchar FAR *, uchar);
	void                hdl_set_bit_m	            (uchar FAR *, uchar);
	void                hdl_set_block_size          (uchar FAR *, int);
	void                hdl_set_break               (uchar FAR *);
	void                hdl_set_cd_in_pad_command	(uchar FAR *, uchar);
	void                hdl_set_cd_proc             (uchar FAR *, uchar);
	uchar FAR *         hdl_set_ctxt                (uchar);
	void                hdl_set_char                (uchar FAR *, uchar, uchar);
	void                hdl_set_dsr_proc            (uchar FAR *, uchar);
	void                hdl_set_dtr_proc            (uchar FAR *, uchar);
	void                hdl_set_fc                  (uchar FAR *, uchar, uchar);
	void                hdl_set_jn                  (uchar FAR *, uchar, uchar);
    void                hdl_set_line_rate           (uchar FAR *, int);
	void                hdl_set_parameters          (uchar FAR *, struct message FAR *);
#	if DTE_NO_PLUS_PLUS_PLUS == OFF
		void 			hdl_set_s012	 			(uchar FAR *, timer_val_t);
#	endif
#	if DTE_MESSAGE_INTERFACE == ON
		void            hdl_set_transp              (uchar FAR *, ent_id_t, uchar);
#	endif
	void 				hdl_set_v120_idle 			(uchar FAR *, long);
	void                hdl_start_latency_timer     (uchar FAR *);
    void                hdl_stop_latency_timer      (uchar FAR *);
    void                hdl_stop_timers             (uchar FAR *);
    void                hdl_suppress_pad_messages   (uchar FAR *, uchar);
	void                hdl_switch_autobaud			(uchar FAR *, uchar);
	void                hdl_timer_expiration        (uchar FAR *, uchar, uchar);
	struct buffer FAR  *pd_get_reception_buffer     (uchar FAR *, short);
    uchar               pd_is_xmt_congested         (uchar FAR *);
    struct buffer FAR  *pd_polling_expiration       (uchar FAR *, uchar);
    void                pd_polling_start            (uchar FAR *);
    void                pd_polling_stop             (uchar FAR *);
#	if DTE_PAD == ON
		void			pd_send_idle_delayed_buffer	(uchar FAR *);
#	endif
	void                pdte_int_var_init           (void);

#   if SIMULATION == ON
		uchar           sim_inp_dte_scc             (uchar);        /* port read simulation */
        void            sim_it_dte_scc              (void);         /* It activation simulation */
        void            sim_new_mode_dte_scc        (void);         /* mode change simulation */
        void            sim_outp_dte_scc            (uchar, uchar); /* port write simulation */
#   endif

#else

    uchar               hdl_build_object            ();
    void                hdl_change_mode             ();
	void                hdl_da_rq_received          ();
	uchar				hdl_get_autobaud			();
	int                 hdl_get_block_size          ();
	uchar				hdl_get_cap_autobaud		();
	uchar               hdl_get_jn                  ();
	uchar				hdl_get_junction_rate       ();
	short				hdl_get_v120_frame_size		();
	uchar               hdl_init                    ();
	void                hdl_jn_rq_received          ();
	uchar               hdl_reinit                  ();
	void                hdl_reset_break             ();
	void                hdl_reset_busy				();
	uchar               hdl_reset_config			();
	void				hdl_send_break_in			();
	void                hdl_send_busy_in            ();
	void                hdl_send_clear_busy_in      ();
	uchar               hdl_send_data_in            ();
	void                hdl_send_setparm_in         ();
	void                hdl_set_at_char_format		();
	void                hdl_set_at_echo             ();
	void                hdl_set_autobaud			();
	void                hdl_set_bit_m	            ();
	void                hdl_set_block_size          ();
	void                hdl_set_break               ();
	void                hdl_set_cd_in_pad_command	();
	void                hdl_set_cd_proc             ();
	uchar FAR *         hdl_set_ctxt                ();
	void                hdl_set_char                ();
	void                hdl_set_dsr_proc            ();
	void                hdl_set_dtr_proc            ();
	void                hdl_set_fc                  ();
	void                hdl_set_jn                  ();
    void                hdl_set_line_rate           ();
	void                hdl_set_parameters          ();
#	if DTE_NO_PLUS_PLUS_PLUS == OFF
		void 				hdl_set_s012	 		();
#	endif
#	if DTE_MESSAGE_INTERFACE == ON
		void            hdl_set_transp              ();
#	endif
	void 				hdl_set_v120_idle 			();
	void                hdl_start_latency_timer     ();
    void                hdl_stop_latency_timer      ();
    void                hdl_stop_timers             ();
    void                hdl_suppress_pad_messages   ();
	void                hdl_switch_autobaud			();
	void                hdl_timer_expiration        ();
	struct buffer FAR  *pd_get_reception_buffer     ();
	uchar               pd_is_xmt_congested         ();
	struct buffer FAR  *pd_polling_expiration       ();
	void                pd_polling_start            ();
	void                pd_polling_stop             ();
#	if DTE_PAD == ON
	void				pd_send_idle_delayed_buffer	();
#	endif
	void                pdte_int_var_init           ();

#   if SIMULATION == ON
        uchar           sim_inp_dte_scc             (); /* port read simulation */
        void            sim_it_dte_scc              (); /* It activation simulation */
        void            sim_new_mode_dte_scc        (); /* mode change simulation */
        void            sim_outp_dte_scc            (); /* port write simulation */
#   endif

#endif

#endif

