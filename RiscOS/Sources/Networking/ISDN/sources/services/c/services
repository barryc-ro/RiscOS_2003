
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - services.c
 *
 * $Revision$
 *
 * $Date$
 *
 * function(s) : communication with the OS (implementation dependent).
 *
 *     os_send_message - implements the sending of a message to an entity
 *                       located outside the server.
 *     os_receive_message - implements the receiving of a message from an
 *                       entity located outside the server.
 *
 *     get_message_and_put_in_fifo - put the message received from the OS
 *                       (external) message queue into the server's queue.
 *
 *     mem_free  - implements the deallocation of a memory block.
 *     mem_alloc - implements the allocation of a memory block.
 *
 *     lock_resource   - lock a process support on a resource.
 *     unlock_resource - unlock a process support on a resource.
 *
 *     system_time - read system time.
 *     timer_delay - put a process in wait state during a delay.
 *
 *     os_start_timer - request OS to start a timer.
 *     os_stop_timer - request OS to stop a timer.
 *
 *     trap - process a fatal error (software inconsistency).
 *     abort_omnitel - implements the abortion of a process in case of
 *                     fatal trap.
 *
 *     msg_audit_filtering - implements the filtering of a message
 *                           for audit purpose.
 *     msg_capture - implements the capture of a message
 *
 *     sm_msg_process - implements the processing of a messages
 *                      sent to SM (SM_REPORT_IN etc.)
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS Services                          |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "services.h"
#include "ctx_ext.h"

	/*-------------------*/

#if (OS == MS_DOS) || (OS == WINDOWS_NT) || (OS == WINDOWS_95)
#	include <stdlib.h>
#	include <stdio.h>
#endif

	/*-------------------*/

#if OS == UNIX
#	include <sys/types.h>
#	include <sys/socket.h>	/* for recv, send */
#	include <sys/time.h>	/* for select and gettimeofday */

#	include <errno.h>
#	include <stdlib.h>
#	include <stdio.h>
#endif

	/*-------------------*/

#if OS == OS9
#	include <errno.h>
#	include <modes.h>
#	include <types.h>
#	include <stdlib.h>
#	include <time.h>
#	include <signal.h>
#	include <alarm.h>
#endif

	/*-------------------*/

#if OS == VRTX
#	include "vrtxil.h"
#	include "vrtxvisi.h"
#endif

	/*-------------------*/

#if OS == RTC86
#	include	"def.m0strgen"
#	include	"base86c.h"
#	include	"envmt.h"
	extern		long 				tick_counter;
	extern		struct i_service 	i_service;
#endif

	/*-------------------*/

#if OS == MTR86
#	include "scoop_s0.h"
#	include "affic.h"

	struct message FAR *p_fifo_server_first;
	struct message FAR *p_fifo_server_last;

#endif

	/*-------------------*/

#if OS == KOS
#	include "kos.h"
#endif

	/*-------------------*/

#if OS == OS_IOPOS
#	include "iopos.h"
#	undef	FALSE
#	undef	TRUE
	void	soft_fault (int);
#endif

	/*-------------------*/

#if OS == IMECOM_OS
#	define	IMFXPS
#	include	"fwconfig.h"
#endif

	/*-------------------*/

#if OS == PSOS
#	include "STD.h"
#	include "cpsos.h"
#endif

	/*-------------------*/

#if OS == PSOS86
#	include "psos.h"
#endif

	/*-------------------*/

#if OS == PSOS_PLUS
#   include "psos.h"
#endif

	/*-------------------*/

#if OS == RTEMS
#   include <rtems.h>
#   include <stdlib.h>
#endif

	/*-------------------*/

#if OS == VXWORKS
#	undef OK
#	include "taskLib.h"
#	include "msgQLib.h"
#	include "memLib.h"
#	include "tickLib.h"

#	undef OK
#	define	OK	2	/* redefine 'OK' to its original 'services.h' value ! */
#endif

	/*-------------------*/

#if OS == MVP_ME
#	include "task.h"
#endif

	/*-------------------*/

#if OS == OSE_OS68

	union SIGNAL {
		struct message 		message;
		struct buffer 		buffer;
		struct timer_cell 	timer_cell;
		uchar               omnitel_byte;
	};

#	include "ose.h"

#endif

	/*-------------------*/

#if OS == RISC_OS
#	include "sys/types.h"
#	include "sys/time.h"
#	include "errno.h"
#	include "stdlib.h"
#	include "kernel.h"
#	include "swis.h"
	extern long				timer_system_tick;
	extern _kernel_oserror	*module_final(int , int , void *);
	extern void				*module_wsp;

#endif

	/*-------------------*/

#if (OS == NUCLEUS_PLUS)
#	include "nucleus.h"		/* Nucleus definitions */
#endif

	/*-------------------*/

#if OS == OMNITEL_OS
#	include "omni_os.h"

		/*
			!!! include here all needed files required for additional
			!!! porting functions

			stdlib.h is included here for 'malloc()' and 'free()' functions.
		*/

#	include <stdlib.h>

#endif

/*--------------------------------------------------------------------------*/

/*
*
*	This module implements the access to the OS functions.
*	The way used to communicate between these functions and the
*	outside is OS and TOOLS (Linker and loader) dependent.
*	The serv_por.h header module isolates these functions and
*	the GENERAL COMMON functions and the user's server functions.
*
*                -------------------------------
*               |                         |     |
*               |  ISOLATION : serv_por.h |     |
*      -------  |                         |  S  |
*     |      ===============================>   |
*    -------  | |                         |  E  |
*   |       | | |  --------------------   |     |
*  -------  | | | |     COM_PROC.C     |  |  R  |
* |       | | | | |                   ======>   |       ----------
* | O  S  | | | | |    OMNITEL common  |  |  V  |      |          |
* | M  E  ==========>                  |  |     |      |          |
* | N  R  | | | | |      functions     |  |  I  |      |          |
* | I  V  | | | | |                    |  |    =======>|   O  S   |
* | T  E  | |-  | |--------------------|  |  C  |      |          |
* | E  R  |-    | |                    |  |     |      |          |
* | L  S  ==========>  OMNITEL timer  ======>E  |      |          |
* |       |     | |                    |  |     |       ----------
*  -------      | |      functions     |  |  S  |
*               | |                    |  |     |
*               | |        ------------|  |  .  |
*               | |       |   timer   ======>   |
*               | |       |  process   |  |  C  |
*               |  --------------------   |     |
*               |                         |     |
*               |                         |     |
*                -------------------------------
*/
/*--------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            os_send_message - implements the sending of a message to
								  an external (OS) queue.

Usage           void os_send_message (uint qid, struct message *p_send);
						- qid	 = queue integer,
						- p_send = address of the message to send.

Description     os_send_message implements the sending of a message and
				its linked buffer to an OS queue.This function is Operating
				System and implementation dependent.

Return value    void

*--------------------------------------------------------------------------*/

#if OS == AMX

CONST int amx_send_priority	= 2;	/* medium priority */

#	if (OS_RELEASE == MC68000_V3)
		extern CJ_ID		amx_cj_qid [];		/* Message Queue ID table */
#	endif

#endif

	/*-------------------*/

#if OS == OS_IOPOS
#	define  ISDN_INIT
#	include "cfg.config"
	QUEUE_PTR OS_IOPOS_queue_p_tab [SERVER_NB];
#endif

	/*-------------------*/

#if (OS == PSOS) || (OS == PSOS86)
	extern ulong 			psos_xid [];		/* Message exchange ID */
#endif

	/*-------------------*/

#if OS == PSOS_PLUS
	extern ulong            psos_qid [];        /* Message queue ID */
#endif

	/*-------------------*/

#if OS == RTEMS
	extern rtems_id         rtems_qid [];       /* Message queue ID */
#endif

	/*-------------------*/

#if OS == VXWORKS
	extern MSG_Q_ID	 		vxworks_qid [];		/* Message Queue ID table */
#endif

	/*-------------------*/

#if (SIMULATION == OFF) && ((OS == OS9) || (OS == UNIX) || (OS == RISC_OS))

#	if OS == UNIX

		extern uint		fd_snd[];			/* transmition socket descriptors array */

#	endif

#	if OS == OS9

		extern path_id  fd_snd[];			/* transmition descriptors array */

#	endif

#	if OS == RISC_OS

		extern void os_install_callback (void);
		extern int	in_callback;			/* TRUE if inside callback routine */

#	endif

	extern uchar	ext_msg_count;			/* number of messages in the external queue (messages from Timer or NIL entities) */

		/* structure used to pass data thru pipes */

	struct os_msg {
		ent_id_t	from;					/* origin of the message (entity identifier) */
		ent_id_t	to;						/* destination of the message (entity identifier) */
		nai_t		nai;					/* network access identifier */
		sapi_t		sapi;					/* service access point identifier */
		add_t		add;					/* address field (ces, tei, chani, call_id ...) */
		code_t		code;					/* primitive code (unique only between two entities) */
		ushort		data_size;				/* data size */
	};


	struct message FAR *p_fifo_ext_first;
	struct message FAR *p_fifo_ext_last;

#	define	Put_msg_in_external_fifo(p_msg)		Fifo_put_msg (&p_fifo_ext_first, &p_fifo_ext_last, p_msg)
#	define	Get_msg_from_external_fifo(p_msg)	Fifo_get_msg (&p_fifo_ext_first, &p_fifo_ext_last, p_msg)

#endif

	/*-------------------*/

#if OS == MVP_ME
	extern long		t_mvp_queue_port_id [];		/* Message Queues Ports ID list */
#endif

	/*-------------------*/

#if OS == OSE_OS68
	extern PROCESS	ose_process_id [];			/* Process ID list */
	CONST SIGSELECT	ose_signal_list [] = {	1,
											OSE_OMNITEL_SIGNAL
										 };
#endif

	/*-------------------*/

#if (SIMULATION == OFF) && ((OS == WINDOWS_NT) || (OS == WINDOWS_95))
	extern DWORD		win32_thread_id [];		/* Threads Messages Queues ID list */
#endif

	/*-------------------*/

#if (OS == NUCLEUS_PLUS)
	extern NU_QUEUE		nucleus_qid [];        /* Message queue ID */
#endif

	/*-------------------*/

/*--------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*      os_send_message     */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


void os_send_message (qid, p_snd_msg)
	uint				qid;			/* queue Id */
	struct message FAR	*p_snd_msg;		/* address of the message to transmit */
{

#	if (SIMULATION == OFF) && ((OS == WINDOWS_NT) || (OS == WINDOWS_95))
		DWORD	os_err_win32;			/* extended error information */
#	endif

			/*-------------------- OS9/UNIX -----------------------*/

#	if (SIMULATION == OFF) && ((OS == OS9) || (OS == UNIX))

		struct buffer		*p_buffer;			/* omnitel buffer */
		struct os_msg		 os_msg;			/* socket message header */

			/*---------------------- UNIX -------------------------*/

#		if OS == UNIX
			int					 ret;			/* UNIX system call return code */
			int					 fd;			/* socket descriptor */
#		endif

			/*---------------------- OS9 --------------------------*/

#		if OS == OS9
			path_id				 fd;			/* path descriptor */
			ulong				 data_lgth;		/* length of the sent data */
#		endif

		if ((S_msg_from == ENT_TI) || (S_msg_from == ENT_NIL)) {

				/*
					messages sent from pseudo-entities should be put
					in the server external fifo.
				*/

			Put_msg_in_external_fifo (p_snd_msg);
			ext_msg_count++;
			return;
		}


			/* load the socket descriptor */

		fd = fd_snd[qid-1];

			/*
				send the message header content and the linked buffer if any
				(unchained buffer) from the socket identified by qid
			*/

		os_msg.from			= S_msg_from;
		os_msg.to			= S_msg_to;
		os_msg.nai			= S_msg_nai;
		os_msg.sapi			= S_msg_sapi;
		os_msg.add			= S_msg_add;
		os_msg.code			= S_msg_code;
		os_msg.data_size	= S_data_size;

			/*------------------------ UNIX ---------------------------*/

#		if OS == UNIX

			if ((ret = send (fd, (char *)&os_msg, sizeof (struct os_msg), 0)) != sizeof (struct os_msg)) {
				Trap ((ret == -1 ? TRAP_OS + errno : TRAP_OS), "os_send_message");
			}

			if (os_msg.data_size != 0) {

				if (p_buffer != P_NIL) {

					if ((ret = send (fd, Buffer_a_start_data, Buffer_data_size, 0)) != Buffer_data_size) {
						Trap (((ret == -1) ? TRAP_OS + errno : TRAP_OS), "os_send_message");
					}

				} else {

					if ((ret = send (fd, S_msg_a_start_data, S_msg_data_size, 0)) != S_msg_data_size) {
						Trap (((ret == -1) ? TRAP_OS + errno : TRAP_OS), "os_send_message");
					}

				}

			}

#		endif

			/*------------------------ OS9 ----------------------------*/

#		if OS == OS9

			data_lgth			= sizeof (struct os_msg);

			if (_os_write (fd, &os_msg, &data_lgth) != 0) {
				Trap (TRAP_OS + errno, "os_send_message");
			}

			if (data_lgth != sizeof (struct os_msg)) {
				Trap (TRAP_OS, "os_send_message");
			}

			if ((data_lgth = os_msg.data_size) != 0) {

				if (_os_write (fd, (p_buffer != P_NIL) ? Buffer_a_start_data : S_msg_a_start_data, &data_lgth) != 0) {
					Trap (TRAP_OS + errno, "os_send_message");
				}

				if (data_lgth != os_msg.data_size) {
					Trap (TRAP_OS, "os_send_message");
				}

			}

#		endif

			/* Free the message */

		if (S_msg_lib == ON) {
			Free_msg (p_snd_msg);

		} else {

				/* Mark the message free but don't free it */

			S_msg_p_services = (struct message FAR *)1;
		}

#	endif

			/*------------------------ RISC_OS ---------------------------*/

#	if OS == RISC_OS

			/*
				messages sent from pseudo-entities should be put
				in the server external fifo.
			*/

		Put_msg_in_external_fifo (p_snd_msg);
		ext_msg_count++;
		if (!in_callback) os_install_callback ();
		return;

#	endif

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX
		sc_qpost ((int)qid, (char FAR *)p_snd_msg, &os_err);

		if (os_err != RET_OK) {
			Trap (TRAP_OS + os_err, "os_send_message");
		}
#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX

#		if (OS_RELEASE == I86_V2)
			os_err = ajsend ((uint)(qid), amx_send_priority, &p_snd_msg);
#		endif

#		if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
			os_err = ajsend ((AMXID)(qid), amx_send_priority, &p_snd_msg);

			if (os_err != AEROK) {
				Trap (TRAP_OS + os_err, "os_send_message");
			}
#		endif

#		if (OS_RELEASE == MC68000_V3)
			os_err = cjmbsend (amx_cj_qid[qid], (void FAR *)&p_snd_msg, CJ_NO);

			if (os_err != CJ_EROK) {
				Trap (TRAP_OS + os_err, "os_send_message");
			}
#		endif

#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86
		os_err = SendWithPrio((int)qid, (DoubleWord)p_snd_msg, (int)NONURGENT);

		if ( os_err != cOK ) {
			Trap (TRAP_OS + os_err, "os_send_message");
		}
#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86

			/*
				Designed for a one-server system only
				because of the home-made messages fifo
				queue management : it manages only one
				messages fifo queue.
				Further coding should be done to access
				to multiple fifos.
			*/

		It_disable ();

		Fifo_put_msg (&p_fifo_server_first, &p_fifo_server_last, p_snd_msg);

		It_enable ();

			/* and set the signal of the server's task */

		switch (S_msg_from) {

			case ENT_PH_IT :
			case ENT_PH_D_IT :

#		  if TIMER_IT == ON
			case ENT_TI :
#		  endif

				MTR_put_sgn_it (SGN_SERVER);
				break;

			default :
				MTR_put_sgn (SGN_SERVER);
				break;

		}

#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
		Mt_Signal((EVENT)qid, p_snd_msg);
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS

		if (queue (OS_IOPOS_queue_p_tab [qid - 1], (BYTE_PTR)p_snd_msg) == FALSE) {
			Trap (TRAP_OS, "os_send_message");
		}

#	endif

		/*---------------------- IMECOM_OS -----------------------*/

#	if OS == IMECOM_OS

		char FAR *p_os_msg;

		switch (S_msg_from) {

			case ENT_PH_IT :
			case ENT_PH_D_IT :

#		  if TIMER_IT == ON
			case ENT_TI :
#		  endif

				creat_msg	((char FAR * FAR *)&p_os_msg, IT_OS_MESS);
				fill_msg	((char FAR *)&p_snd_msg, sizeof (p_snd_msg), p_os_msg);
				post_msg_int(1, (short)qid, p_os_msg, sizeof(p_snd_msg));
				break;

			default :
				creat_msg ((char FAR * FAR *)&p_os_msg, SHORT_OS_MESS);
				fill_msg  ((char FAR *)&p_snd_msg, sizeof (p_snd_msg), p_os_msg);
				post_msg  (1, (short)qid, p_os_msg, sizeof(p_snd_msg));
				break;

		}

#	endif

		/*-------------------------- PSOS ------------------------*/

#	if OS == PSOS

		PSOS_T_MESSAGE	psos_msg;						/* PSOS message */

		psos_msg.home_exch = 0;                 		/* normal message */
		psos_msg.body[0]   = (ulong) p_snd_msg;			/* parameter 0 : message address */

		if ((os_err = PSOS_F_SEND_X (psos_xid [qid], &psos_msg)) != PSOS_C_RC_OK) {
			Trap (TRAP_OS + os_err, "os_send_message");
		}

#	endif

		/*------------------------- PSOS86 -----------------------*/

#	if OS == PSOS86

		MESSAGE	psos_msg;						        /* PSOS message */

		psos_msg.home_exch = 0;                 		/* normal message */
		psos_msg.body[0]   = (ulong) p_snd_msg;			/* parameter 0 : message address */

		if ((os_err = send_x (psos_xid [qid], &psos_msg)) != 0) {
			Trap (TRAP_OS + os_err, "os_send_message");
		}

#	endif

		/*----------------------- PSOS_PLUS ----------------------*/

#   if OS == PSOS_PLUS

		ulong psos_msg[4];                              /* PSOS message */
		ulong os_err;                                   /* pSOS+ error code */

		psos_msg[0] = (ulong) p_snd_msg;                /* parameter 0 : message address */

		if ((os_err = q_send (psos_qid [qid], psos_msg)) != 0) {
			Trap (TRAP_OS + os_err, "os_send_message");
		}

#   endif

		/*-------------------------- RTEMS -----------------------*/

#	if OS == RTEMS

		if (rtems_message_queue_send (rtems_qid [qid],
				(char FAR *)&p_snd_msg, sizeof (struct message FAR *)) != RTEMS_SUCCESSFUL) {
			Trap (TRAP_OS, "os_send_message");
		}

#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

		if (msgQSend (vxworks_qid [qid], (char FAR *)&p_snd_msg, sizeof (struct message FAR *), NO_WAIT, MSG_PRI_NORMAL) == ERROR) {
			Trap (TRAP_OS, "os_send_message");
		}

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME

		TaskSendMsg ((void *)p_snd_msg, t_mvp_queue_port_id [qid]);

#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68

			/*
				Restore the administration block and enter
				the calling process as owner of the block
			*/

		p_snd_msg = (struct message *)(((uchar *)p_snd_msg) - sizeof (SIGSELECT));

		restore ((union SIGNAL *)p_snd_msg);

			/* Send the signal message */

		send ((union SIGNAL **)&p_snd_msg, ose_process_id [qid]);

#	endif

		/*---------------------- MS_WINDOWS -----------------------*/

#	if OS == MS_WINDOWS

		if (PostMessage ((HWND)qid, (UINT)WM_USER_OMNITEL, (WPARAM)0, (LPARAM)p_snd_msg) == FALSE) {
			Trap (TRAP_OS, "os_send_message");
		}

#	endif

		/*---------------------- WINDOWS_NT/95 --------------------*/

#	if (SIMULATION == OFF) && ((OS == WINDOWS_NT) || (OS == WINDOWS_95))

		if (PostThreadMessage ((DWORD)win32_thread_id [qid], (UINT)WM_USER_OMNITEL, (WPARAM)0, (LPARAM)p_snd_msg) == FALSE) {
			os_err_win32	= GetLastError ();
			Trap ((ushort)(TRAP_OS + os_err_win32), "os_send_message");
		}

#	endif

		/*----------------------- NUCLEUS_PLUS ----------------------*/

#   if (OS == NUCLEUS_PLUS)

		STATUS status;                                   /* Nucleus status return code */

		if ((status = NU_Send_To_Queue (&nucleus_qid [qid], (VOID *)&p_snd_msg, 1, NU_NO_SUSPEND)) != NU_SUCCESS) {
			Trap (TRAP_OS + status, "os_send_message");
		}

#   endif

		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS

		if (om_os_mbx_send (qid, p_snd_msg) != OM_OS_OK) {
			Trap (TRAP_OS, "os_send_message");
		}

#	endif

} /* End of os_send_message () */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            os_receive_message - implements the pending for an incoming
								  message in a server.

Usage           struct message FAR *os_receive_message (uint qid);
					- qid : external queue ID of the current server.

Description     os_receive_message implements the attempting to receive a
				message from the external unique FIFO (queue). If it is
				empty the server pends for a message from this external FIFO.
				This service is Operating System and implementation
				dependent.

Return value    os_receive_message returns an address pointing on a received
				message.

*--------------------------------------------------------------------------*/

#if (SIMULATION == OFF) && ((OS == OS9) || (OS == UNIX))

#	if OS == UNIX

		extern uint		fd_rcv[];				/* reception socket descriptors array */

#	endif

#	if OS == OS9

		extern path_id	fd_rcv[];				/* reception path descriptors array */

#	endif

		extern uchar	msg_from[QUEUE_NB];		/* reception message counters table */
		extern uchar	timer_handler_flag;		/* timer expiry flag */

#	if NEW_FCT_STYLE == ON
		void os_block_signals		(void);
		void os_unblock_signals		(void);
		void os_sig_wait			(void);

#	else

		void os_block_signals		();
		void os_unblock_signals		();
		void os_sig_wait			();
#	endif

#endif

						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*    os_receive_message    */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


struct message FAR *os_receive_message (qid)
	uint		qid;					/* external queue ID */
{
	struct message FAR 	*p_msg;

#   if SIMULATION == ON
        p_msg = P_NIL;
#   endif

#	if (SIMULATION == OFF) && ((OS == WINDOWS_NT) || (OS == WINDOWS_95))
		DWORD	os_err_win32;		/* extended error information */
		MSG		win32_msg;			/* windows message */
		BOOL	bResult;			/* boolean temporary result */
#	endif

			/* Wait for a message */

			/*-------------------- OS9/UNIX -----------------------*/

#	if (SIMULATION == OFF) && ((OS == OS9) || (OS == UNIX))

		struct buffer		*p_buffer;		/* omnitel buffer */

		struct os_msg		 os_msg;		/* socket message header */
		uchar				 i;				/* loop counter */

#		if OS == UNIX
			int				 ret;			/* UNIX system call return code */
#		endif

#		if OS == OS9
			ulong			 data_lgth;		/* length of the received data */
#		endif

			/*
				set the process waiting for signals :
					return if signal has already occured.
			*/

    sigwait :
		os_sig_wait ();

			/* a signal has occured */

		if (timer_handler_flag == TRUE) {
			timer_handler ();

				/*
					no timeout should have occured since last expiry
					since we just leave the function : reset the flag.
				*/

			timer_handler_flag = FALSE;
		}

		Get_msg_from_external_fifo (p_msg);

		if (p_msg != P_NIL) {
			ext_msg_count--;
			return (p_msg);
		}

		for (i = 0; i < QUEUE_NB; i++) {

			if (msg_from[i] != 0) {

				qid	= fd_rcv[i];		/* load socket descriptor */

				os_block_signals ();
					msg_from[i]--;		/* decrement message counter */
				os_unblock_signals ();

				break;
			}

		}

		if (i == QUEUE_NB) {

				/*
                    no message to be received :
                    we shall return while there is no message provided
                 */

			goto loop_on_sigwait;
		}

		p_msg = Alloc_msg ();

			/*------------------------ UNIX ---------------------------*/

#		if OS == UNIX

				/* expect for a socket message */

			if ((ret = recv (qid, (char *) &os_msg, sizeof (struct os_msg), 0)) != sizeof (struct os_msg)) {
				Trap ((ret == -1 ? TRAP_OS + errno : TRAP_OS), "os_receive_message");
			}

			L_msg_from	= os_msg.from;
			L_msg_to	= os_msg.to;
			L_msg_nai	= os_msg.nai;
			L_msg_sapi	= os_msg.sapi;
			L_msg_add	= os_msg.add;
			L_msg_code	= os_msg.code;

			if (os_msg.data_size != 0) {

				if (os_msg.data_size > Message_data_lgth) {
					p_buffer = Alloc_buffer ();

					if ((ret = recv (qid, (char *) Buffer_a_first_data, os_msg.data_size, 0)) != os_msg.data_size) {
						Trap ((ret == -1 ? TRAP_OS + errno : TRAP_OS), "os_receive_message");
					}

					Buffer_data_size = ret;
					L_msg_init_link_buffer;

				} else {

					if ((ret = recv (qid, (char *) L_msg_a_first_data, os_msg.data_size, 0)) != os_msg.data_size) {
						Trap ((ret == -1 ? TRAP_OS + errno : TRAP_OS), "os_receive_message");
					}

					L_msg_data_size = ret;
				}

			}

#		endif

			/*------------------------ OS9 ----------------------------*/

#		if OS == OS9

			data_lgth			= sizeof (struct os_msg);

				/* expect for a socket message */

			if (_os_read (qid, (char *) &os_msg, &data_lgth) != 0) {
				Trap (TRAP_OS + errno, "os_receive_message");
			}

			if (data_lgth != sizeof (struct os_msg)) {
				Trap (TRAP_OS, "os_receive_message");
			}

			L_msg_from	= os_msg.from;
			L_msg_to	= os_msg.to;
			L_msg_nai	= os_msg.nai;
			L_msg_sapi	= os_msg.sapi;
			L_msg_add	= os_msg.add;
			L_msg_code	= os_msg.code;

			if (os_msg.data_size != 0) {

				if ((data_lgth = os_msg.data_size) > Message_data_lgth) {
					p_buffer = Alloc_buffer ();

					if (_os_read (qid, (char *) Buffer_a_first_data, &data_lgth) != 0) {
						Trap (TRAP_OS + errno, "os_receive_message");
					}

					if ((Buffer_data_size = data_lgth) != os_msg.data_size) {
						Trap (TRAP_OS, "os_receive_message");
					}

					L_msg_init_link_buffer;

				} else {

					if (_os_read (qid, (char *) L_msg_a_first_data, &data_lgth) != 0) {
						Trap (TRAP_OS + errno, "os_receive_message");
					}

					if ((L_msg_data_size = data_lgth) != os_msg.data_size) {
						Trap (TRAP_OS, "os_receive_message");
					}

				}

			}

#		endif

#	endif

			/*------------------------ RISC_OS ---------------------------*/

#	if OS == RISC_OS

		It_disable ();
			Get_msg_from_external_fifo (p_msg);
		It_enable ();

		if (p_msg != P_NIL) {
			ext_msg_count--;
			return (p_msg);
		}

#	endif

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX
		p_msg = (struct message FAR *) sc_qpend ((int)qid, (long)0, &os_err);

		if (os_err != RET_OK) {
			Trap (TRAP_OS + os_err, "os_receive_message");
		}

#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX

#		if OS_RELEASE != MC68000_V3
			p_msg = P_NIL;
#		endif

#		if OS_RELEASE == MC68000_V3

				/* Server is no more a function but a running process	*/
				/* which must wait for a mailbox...						*/
			{
				char msg [CJ_MAXMSZ];	/* The message size is not a pointer */

				/* Waiting at priority 10 with no time out */

				os_err = cjmbwait (amx_cj_qid[qid],  (void *) msg, 10, 0);

				if (os_err != CJ_EROK) {
					Trap (TRAP_OS + os_err, "os_receive_message");
				}
				p_msg = ((struct message FAR * FAR *)msg)[0];
			}

#		endif

#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86
		os_err = Receive ((int)qid, (struct message far *)&p_msg, 0L);

		if (os_err != cOK) {
			Trap (TRAP_OS + os_err, "os_receive_message");
		}

#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86

		MTR_wait_sgn 	(SGN_SERVER, NO_TIMEOUT);

		It_disable ();

		Fifo_get_msg (&p_fifo_server_first, &p_fifo_server_last, p_msg);

			/* test if fifo is empty */

		if (p_msg == P_NIL) {
			MTR_raz_sgn 	(SGN_SERVER);
		}

		It_enable();

#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS

		EVENT		event;
		MESSAGE		message;
		TIME		time;

		if (Mt_Next_Event(&event, &message, &time, -1) == EVENT_RECEIVED) {

			if (event == (EVENT)qid) {
				p_msg = message;
			}

		} else {

			Trap (TRAP_OS + os_err, "os_receive_message");
		}

#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS

		while ((p_msg = (struct message FAR *)u_wait (OS_IOPOS_queue_p_tab [qid])) == P_NIL);

#	endif

		/*---------------------- IMECOM_OS -----------------------*/

#	if OS == IMECOM_OS
		p_msg = P_NIL;
#	endif

		/*------------------------- PSOS -------------------------*/

#	if OS == PSOS

		PSOS_T_MESSAGE	psos_msg;				/* PSOS message */

		if ((os_err = PSOS_F_REQ_X (psos_xid [qid], &psos_msg, (uchar)0, (ulong)0)) != PSOS_C_RC_OK) {
			Trap (TRAP_OS + os_err, "os_receive_message");
		}

		p_msg = (struct message FAR *)psos_msg.body [0];

#	endif

		/*------------------------ PSOS86 ------------------------*/

#	if OS == PSOS86

		MESSAGE	psos_msg;				        /* PSOS message */

		if ((os_err = req_x (psos_xid [qid], &psos_msg, (uchar)WAIT, (ulong)INFINITE)) != 0) {
			Trap (TRAP_OS + os_err, "os_receive_message");
		}

		p_msg = (struct message FAR *)psos_msg.body [0];

#	endif

		/*---------------------- PSOS_PLUS -----------------------*/

#   if OS == PSOS_PLUS

		unsigned long psos_msg[4];      /* PSOS message */
		ulong os_err;                   /* pSOS+ error code */

		if ((os_err = q_receive (psos_qid [qid], Q_WAIT, 0/*no timeout*/, psos_msg)) != 0) {
			Trap (TRAP_OS + os_err, "os_receive_message");
		}

        p_msg = (struct message FAR *)psos_msg[0];

#   endif

		/*------------------------- RTEMS ------------------------*/

#	if OS == RTEMS

		unsigned32 len;

		if (rtems_message_queue_receive (
				rtems_qid [qid], &p_msg, &len, RTEMS_WAIT, RTEMS_NO_TIMEOUT) != RTEMS_SUCCESSFUL) {
			Trap (TRAP_OS, "os_receive_message");
		}

#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

		if (msgQReceive (vxworks_qid [qid], (char FAR *)&p_msg, sizeof (struct message FAR *), WAIT_FOREVER) == ERROR) {
			Trap (TRAP_OS, "os_receive_message");
		}

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME

		p_msg = (struct message FAR *)TaskReceiveMsg (t_mvp_queue_port_id [qid]);

#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68

		p_msg = (struct message FAR *)((uchar FAR *)(receive ((SIGSELECT *)ose_signal_list)) + sizeof (SIGSELECT));

#	endif

		/*---------------------- MS_WINDOWS ----------------------*/

#	if OS == MS_WINDOWS

		p_msg = P_NIL;

#	endif

		/*---------------------- WINDOWS_NT/95 --------------------*/

#	if (SIMULATION == OFF) && ((OS == WINDOWS_NT) || (OS == WINDOWS_95))

		for ( ; ; ) {

			bResult = GetMessage ((LPMSG)&win32_msg, (HWND)NULL, 0, 0);

			if (bResult == FALSE) {

					/* WM_QUIT message received */

				p_msg	= P_NIL;
				break;

			} else if (bResult == TRUE) {

					/* Translates virtual-key codes */

				TranslateMessage (&win32_msg);

					/* Dispatches message to window */

				DispatchMessage  (&win32_msg);

				if (win32_msg.message == WM_USER_OMNITEL) {
					p_msg	= (struct message FAR *)(win32_msg.lParam);
					break;
				}

			} else {

					/* Fatal error (bResult = -1) */

				os_err_win32	= GetLastError ();
				Trap ((ushort)(TRAP_OS + os_err_win32), "os_receive_message");

			}

		}

#	endif

		/*----------------------- NUCLEUS_PLUS ----------------------*/

#   if (OS == NUCLEUS_PLUS)

		STATUS 		status;                                   /* Nucleus status return code */
		UNSIGNED	received_size;

		if ((status = NU_Receive_From_Queue (&nucleus_qid [qid], (VOID *)&p_msg, 1, &received_size, NU_SUSPEND)) != NU_SUCCESS) {
			Trap (TRAP_OS + status, "os_receive_message");
		}
#		if ASSERT == ON
			if (received_size != 1) {
				
					/* Must be 1 */
					
				Trap (TRAP_OS + status, "os_receive_message bis");
			}
#		endif

#   endif

		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS

			/* Get the first message from the highest priority mailbox */

		om_os_mbx_receive_highest (&p_msg);

#   endif

	return (p_msg);

} /* End of os_receive_message () */

/*------------------------------------------------------------------------*/

#if (BEGIN_WITH_MSG == ON) || (OS == MS_WINDOWS)

extern	struct server   FAR *p_server;					/* base server descriptor pointer */
extern	struct entity_descriptor p_entity_descriptor[]; /* entity descriptor table */

/*--------------------------------------------------------------------------*/

struct message FAR *get_message_and_put_in_fifo (p_param)
	uchar FAR * FAR *p_param;
{
	struct message FAR *p_msg;
	struct message FAR *FAR *p_fifo_p_first;
	struct message FAR *FAR *p_fifo_p_last;

		/*---------------------- IMECOM_OS ----------------------*/

#	if OS == IMECOM_OS
		read_msg ((char far *)&p_msg, sizeof (p_msg),(char far *)p_param);
		lib_msg  ((char far *)p_param);
#	endif

		/*------------------------ AMX --------------------------*/

#	if OS == AMX
		p_msg = (struct message FAR *)*p_param;
#	endif

		/*-------------------- MS_WINDOWS (3.x) ------------------*/

#	if OS == MS_WINDOWS
		p_msg = (struct message FAR *)*p_param;
#	endif

		/*-------------------- WINDOWS_NT/95 ---------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)
		p_msg = (struct message FAR *)*p_param;
#	endif

		/* Get message from stack */

	if (p_msg != P_NIL) {

			/* Put message in internal FIFO */

		p_fifo_p_first = (struct message FAR *FAR *)&Entity_to_fifo_p_first (L_msg_to);
		p_fifo_p_last  = (struct message FAR *FAR *)&Entity_to_fifo_p_last (L_msg_to);
		Fifo_put_msg (p_fifo_p_first, p_fifo_p_last, p_msg);
	}

	return (p_msg);

} /* End of get_message_and_put_in_fifo () */

#endif /* (BEGIN_WITH_MSG == ON) || (OS == MS_WINDOWS) */

/*-------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             mem_free - implements the deallocation of a memory block
							previously allocated to the server.

				 mem_alloc- implements the allocation of a memory block.
							if variable length partition it is set to 0;

Usage            mem_free (char FAR *p_add, uchar pid);
					- p_add = pointer on the block to deallocate,
					- pid   = partition ID.

				 uchar FAR *mem_alloc (short lgth, uchar pid);
					- lgth = length of the block to allocate,
					- pid  = partition ID.

Related
functions usage : OS dependent.

*---------------------------------------------------------------------------*/

#if SIMULATION == ON

#	include "simul.h"
	long		 		 sim_vl_used;			/* length of the available memory of the static partition */

		/* Structure used on top of allocated VL block for printing */

	struct mem_reserved {
		ushort lgth;								/* length of the block */
	};

#	define Mem_reserved_size	Rnd_sizeof (struct mem_reserved)

#endif

#if OS == VRTX
	extern	char 	FAR	*part_add;				/* available memory for OMNITEL-BRICKS static partition */
	extern	long		 part_lgth;				/* length of the available memory of the static partition */
#endif

#if OS == OS_IOPOS
	uchar FAR *OS_IOPOS_pool_p_tab [MX_PID + 1];
#endif

#if OS == AMX

#	if (OS_RELEASE == I86_V2)
		int		tab_pool_id[MX_PID];
#	endif

#	if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
		AMXID 	tab_pool_id[MX_PID];
#	endif

#	if (OS_RELEASE == MC68000_V3)
		CJ_ID 	tab_pool_id[MX_PID + 1];	/* One more element for PID_VL */
#	endif

#endif

#if OS == PSOS
	extern ulong	psos_ptid [MX_PID];
#endif

#if OS == PSOS86
	extern INT8    *psos_ptid [MX_PID];
#endif

#if OS == PSOS_PLUS
	extern ulong    psos_ptid [MX_PID];
	extern ulong    psos_vl_region_id;
#endif

#if OS == RTEMS
	extern rtems_id	rtems_ptid [MX_PID];
#endif

#if OS == VXWORKS
	extern PART_ID	vxworks_ptid [MX_PID];
#endif

#if OS == MVP_ME
	extern long		t_mvp_pool_port_id [MX_PID];	/* Port ID list for buffer pools */
#endif

#if OS == OSE_OS68
	extern OSBUFSIZE  	 ose_pool_size [MX_PID];	/* pool size array */
	extern	char 	FAR	*part_add;					/* available memory for OMNITEL-BRICKS static partition */
	extern	long		 part_lgth;					/* length of the available memory of the static partition */
#endif

#if (OS == MS_WINDOWS) || (OS == WINDOWS_NT) || (OS == WINDOWS_95)
	struct mem_handle {
		HGLOBAL hglb;								/* memory object global handle */
	};
#endif

#if (OS == NUCLEUS_PLUS)
	extern NU_PARTITION_POOL	n_tpid [MX_PID];		/* Partitions table ids */
	extern NU_MEMORY_POOL		nucleus_vl_mem_id;		/* Variable memory id */
#endif

/*--------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*         mem_alloc        */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


uchar FAR *mem_alloc (lgth, pid)
	ushort		lgth;			/* length of the block to allocate */
	uchar		pid;			/* partition ID */
{
	uchar		FAR *p_mem;		/* temporary block address */

#	if OS == AMX
		long		lgth_ret;
#	endif

#	if OS == MTR86
		uint virtual_lgth;
#	endif

#	if (OS == MS_WINDOWS) || (OS == WINDOWS_NT) || (OS == WINDOWS_95)
		UINT	fuAlloc;		/* the way the memory block is allocated */
		HGLOBAL hglb;			/* global handle for memory object */
		struct mem_handle FAR *p_mem_handle; /* pointer to memory handle information */
#	endif

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX

		if (pid == PID_VL) {

				/* Variable length partition */

			if (part_lgth >= lgth) {

					/* Allocate the memory */

				p_mem		 = (uchar FAR *)part_add;
				part_add	+= (long)Round16 (lgth);
				part_lgth	-= (long)Round16 (lgth);

					/* Clear to 0 the allocated area */

				Memset_far ((char FAR *)p_mem, 0, lgth);

			} else {

				Trap (TRAP_PART_VL, "mem_alloc VL");
				p_mem = P_NIL;
			}

		} else {

				/* Fixed length partition */

			p_mem = (char FAR *)sc_gblock ((int)pid, &os_err);
			if (os_err != RET_OK) p_mem = P_NIL;
		}

#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX

		lgth = Round(lgth);

		if (pid == PID_VL) {

				/* Variable length partition */

#			if (OS_RELEASE != MC68000_V3)
				os_err = ajmget ((long)lgth, &p_mem, &lgth_ret);

				if (os_err != AEROK) {
					Trap (TRAP_OS + os_err, "mem_alloc VL");
#			endif

#			if (OS_RELEASE == MC68000_V3)

				pid = MX_PID;
				os_err = cjmmget ((CJ_ID)tab_pool_id [pid], (ulong)lgth, &p_mem, (ulong FAR *) &lgth_ret);

				if (os_err != CJ_EROK) {
					Trap (TRAP_OS + os_err, "mem_alloc VL");
#			endif

				p_mem = P_NIL;

			} else {

					/* Clear to 0 the area */

				Memset_far ((char *)p_mem, 0, lgth);
			}

		} else {

				/* Fixed length partitions */

#			if (OS_RELEASE == I86_V2)
				os_err = ajbgb ((int)tab_pool_id [pid], &p_mem);
#			endif

#			if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
				os_err = ajbget ((AMXID)tab_pool_id [pid], &p_mem);

				if (os_err != AEROK) {
					p_mem = P_NIL;
				}
#			endif

#			if (OS_RELEASE == MC68000_V3)

					/* Doesn't wait for a buffer if none */

				os_err = cjbmget ((CJ_ID)tab_pool_id [pid], (void FAR *)&p_mem, 10, -1);

				if (os_err != CJ_EROK) {
					p_mem = P_NIL;
				}
#			endif

		}

#	endif

		/*------------------- MS/DOS SIMULATION ------------------*/

#	if (OS == MS_DOS) && (SIMULATION == ON)

		if (pid == PID_VL) {

			if (pr_vl_mem == ON) {

				sim_vl_used += lgth;

					/* print PID_VL allocation */

				fprintf (f_out, "\nMem_alloc: +%d=%ld", lgth, sim_vl_used);
			}

		}

			/* Reserve space to keep track of the requested length for Mem_free() */

		lgth += Mem_reserved_size;

		if ((p_mem = (uchar FAR *)malloc (lgth)) == NULL) {
			p_mem = P_NIL;

		} else if (pid == PID_VL) {

				/* Clear to 0 the area */

			Memset_far ((char FAR *)p_mem, 0, lgth);
		}

			/* Keep track of the requested length for Mem_free() */

		((struct mem_reserved FAR *)p_mem) -> lgth = lgth - Mem_reserved_size;
		p_mem += Mem_reserved_size;

#	endif

		/*------------------- MS/DOS NO SIMULATION ------------------*/

#	if (OS == MS_DOS) && (SIMULATION == OFF)

		if ((p_mem = (uchar FAR *)malloc (lgth)) == NULL) {
			p_mem = P_NIL;

		} else if (pid == PID_VL) {

				/* Clear to 0 the area */

			Memset_far ((char FAR *)p_mem, 0, lgth);
		}

#	endif

		/*---------------------- UNIX / OS9 ------------------------*/

#	if (OS == UNIX) || (OS == OS9)

		if ((p_mem = (uchar FAR *)malloc (lgth)) != P_NIL) {

			if (pid == PID_VL) {

					/* Clear to 0 the  area */

				Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86

		if ( i_service.part_lgth >= lgth ) {
			p_mem = (uchar FAR *)i_service.part_add;
			i_service.part_add += Round (lgth);
			i_service.part_lgth -= Round (lgth);

			Memset_far ((char FAR *)p_mem, 0, lgth);

		} else {

			Trap (TRAP_PART_VL, "mem_alloc");
		}

#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86

		virtual_lgth = (uint)((lgth + 10) >> 4);

		if ( (uint) ((lgth + 10) & 0x0f) != 0 ) {
			virtual_lgth ++;
		}

		if ((os_err = MTR_get_msg ((uint)pid, virtual_lgth, &p_mem)) != 0) {
			Trap (TRAP_OS + os_err, "   mem_alloc    ");

		} else if (pid == PID_VL) {

			/* Clear to 0 the area */

			Memset_far ((char FAR *)p_mem, 0, lgth);
		}

#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
		p_mem = Mt_Alloc_Mem( pid, &lgth);
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS

		if (pid == PID_VL) {

				/* Variable length partition */

			if ((p_mem  = (uchar FAR *)gmem ((POOL_PTR)OS_IOPOS_pool_p_tab [MX_PID], (long)Round (lgth))) == P_NIL) {
				Trap (TRAP_OS, "mem_alloc_vl");
			}

			p_mem = (uchar FAR *)Round ((long)p_mem);

				/* Clear to 0 the allocated area */

			Memset_far ((char FAR *)p_mem, 0, lgth);

		} else {

				/* Fixed length partition */

			if ((p_mem = (uchar FAR *)get_chunk ((CH_POOL_PTR)OS_IOPOS_pool_p_tab [pid])) == P_NIL) {
				Trap (TRAP_OS, "mem_alloc_fl");
			}

			p_mem = (uchar FAR *)Round ((long)p_mem);
		}

#	endif

		/*---------------------- IMECOM_OS -----------------------*/

#	if OS == IMECOM_OS

		if (pid != PID_VL) {
			p_mem = (uchar far *)get_memory_from_os(lgth);

		} else {

			p_mem = (uchar far *)get_working_memory(lgth);
		}

#	endif

		/*------------------------- PSOS -------------------------*/

#	if OS == PSOS

		if (pid != PID_VL) {

				/* fixed length --> buffer pool */

			if (PSOS_F_GET_BUF (psos_ptid[pid], (long)Round (lgth), &p_mem) != PSOS_C_RC_OK) {
				p_mem = P_NIL;
			}

		} else {

				/* variable length --> segment */

			if (PSOS_F_ALLOC_SEG ((long)Round (lgth), (ushort)PSOS_C_REGION2, (uchar)PSOS_C_NOWAIT, (long)NIL, &p_mem) != PSOS_C_RC_OK) {
				p_mem = P_NIL;

			} else {

				p_mem = (uchar FAR *)Round ((long)p_mem);

					/* Clear to 0 the allocated area */

				Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#	endif

		/*------------------------ PSOS86 ------------------------*/

#	if OS == PSOS86

		if (pid != PID_VL) {

				/* fixed length --> buffer pool */

			if (get_buf (psos_ptid[pid], (long)Round16 (lgth), &p_mem) != 0) {
				p_mem = P_NIL;
			}

		} else {

				/* variable length --> segment */

			if (alloc_seg ((long)Round (lgth), (uchar)ANYREGION/*$$*/, (uchar)NOWAIT, (long)NIL, (uchar FAR *)&p_mem) != 0) {
				p_mem = P_NIL;

			} else {

					/* Clear to 0 the allocated area */

				Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#	endif

		/*---------------------- PSOS_PLUS -----------------------*/

#   if OS == PSOS_PLUS

		if (pid != PID_VL) {

				/* fixed length --> buffer pool */

			if (pt_getbuf (psos_ptid[pid], (void **)&p_mem) != 0) {
				p_mem = P_NIL;
            }

        } else {

                /*
                 * variable length --> get a segment
                 * using psos_vl_region_id initialized by os_create_memory()
                 */

            if (rn_getseg (psos_vl_region_id, (ulong)Round (lgth), RN_NOWAIT, 0 /* timeout ignored */, (void **)&p_mem) != 0) {
                p_mem = P_NIL;

            } else {

                    /* Clear to 0 the allocated area */

                Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#   endif

		/*------------------------ RTEMS -------------------------*/

#	if OS == RTEMS

		if (pid != PID_VL) {

				/* fixed length --> memory pool */

			if (rtems_partition_get_buffer(rtems_ptid[pid], &p_mem) != RTEMS_SUCCESSFUL) {
				p_mem = P_NIL;
			}

		} else {

				/* variable length --> system partition */

			if ((p_mem = (uchar FAR *)malloc (lgth)) == NULL) {
				p_mem = P_NIL;

			} else {

				p_mem = (uchar FAR *)Round ((long)p_mem);

					/* Clear to 0 the allocated area */

				Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

		if (pid != PID_VL) {

				/* fixed length --> memory pool */

			if ((p_mem = memPartAlloc (vxworks_ptid [pid], (unsigned)lgth)) == NULL) {
				p_mem = P_NIL;
			}

		} else {

				/* variable length --> system partition */

			if ((p_mem = (uchar FAR *)malloc (lgth)) == NULL) {
				p_mem = P_NIL;

			} else {

				p_mem = (uchar FAR *)Round ((long)p_mem);

					/* Clear to 0 the allocated area */

				Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME

		if (pid != PID_VL) {

				/* fixed length --> buffer port pool */

			p_mem = (uchar FAR *)TaskAcceptMsg (t_mvp_pool_port_id [pid]);

		} else {

				/* variable length --> system partition */

			if ((p_mem = (uchar FAR *)TaskAllocMsg ((long)lgth, -1)) != P_NIL) {

				p_mem = (uchar FAR *)Round ((long)p_mem);

					/* Clear to 0 the allocated area */

				Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68


		if (pid != PID_VL) {

				/* fixed length --> buffer port pool */

			p_mem = ((uchar FAR *)alloc (lgth + sizeof (SIGSELECT), OSE_OMNITEL_SIGNAL)) + sizeof (SIGSELECT);

		} else {

				/* Variable length partition */

			if (part_lgth >= lgth) {

					/* Allocate the memory */

				p_mem		 = (uchar FAR *)part_add;
				part_add	+= (long)Round16 (lgth);
				part_lgth	-= (long)Round16 (lgth);

					/* Clear to 0 the allocated area */

				Memset_far ((char FAR *)p_mem, 0, lgth);

			} else {

				Trap (TRAP_PART_VL, "mem_alloc VL");
				p_mem = P_NIL;
			}

		}


#	endif

		/*----------------------- MS-WINDOWS ----------------------*/

#	if OS == MS_WINDOWS

		if (pid == PID_VL) {
			fuAlloc = GMEM_SHARE|GMEM_FIXED|GMEM_ZEROINIT;
		} else {
			fuAlloc = GMEM_SHARE|GMEM_FIXED;
		}

		if (((hglb = GlobalAlloc (fuAlloc, (DWORD)(lgth + sizeof (struct mem_handle))))) == NULL) {

			p_mem	= P_NIL;

		} else {

			p_mem					= (uchar FAR *)(GlobalLock (hglb));

				/* Load the global object handle for Mem_free */

			p_mem_handle			= (struct mem_handle FAR *)p_mem;
			p_mem_handle -> hglb	= hglb;
			p_mem					+= sizeof (struct mem_handle);

		}

#	endif

		/*------------------- WINDOWS_NT/95 ----------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)

			/*
				In the linear WIN32 API environment, there is no difference
				between the local heap and the global heap.

				Only processes that use DDE or clipboard for interprocess
				communication should use the GMEM_SHARE (same as GMEM_DDESHARE)
				flag.

				Memory allocated with this function is guaranteed to be
				aligned on an 8-byte boundary.
				If this function succeeds, it allocates at least the
				amount of memory requested.
				To determine the actual number of bytes allocated,
				the GlobalSize() function should be used.
			*/

		if (pid == PID_VL) {
			fuAlloc = GMEM_FIXED|GMEM_ZEROINIT;
		} else {
			fuAlloc = GMEM_FIXED;
		}

		if (((hglb = GlobalAlloc (fuAlloc, (DWORD)(lgth + sizeof (struct mem_handle))))) == NULL) {

			p_mem	= P_NIL;

		} else {

				/*
					No use of GlobalLock() function.

					For memory objects allocated with the GMEM_FIXED flag,
					the value of the returned pointer is equal to the value
					of the specified handle.

					So, we simply cast the return value to a pointer.

				*/


			p_mem					= (uchar FAR *)(hglb);

				/* Load the global object handle for Mem_free */

			p_mem_handle			= (struct mem_handle FAR *)p_mem;
			p_mem_handle -> hglb	= hglb;
			p_mem					+= sizeof (struct mem_handle);

		}

#	endif

		/*---------------------- RISC OS------------------------*/

#	if OS == RISC_OS

		if ((p_mem = (uchar FAR *)malloc (lgth)) != P_NIL) {

			if (pid == PID_VL) {

					/* Clear to 0 the area */

				Memset_far ((char FAR *)p_mem, 0, lgth);
			}

		}

#	endif

		/*---------------------- NUCLEUS_PLUS -----------------------*/

#   if (OS == NUCLEUS_PLUS)

        if (pid != PID_VL) {

                /* fixed length --> buffer pool */

            if (NU_Allocate_Partition (&n_tpid [pid], (VOID **)&p_mem, NU_NO_SUSPEND) != NU_SUCCESS) {
                p_mem = P_NIL;
            }

        } else {

                /*
                 * variable length --> get a segment
                 * using psos_vl_region_id initialized by os_create_memory()
                 */

            if (NU_Allocate_Memory (&nucleus_vl_mem_id, (VOID **)&p_mem, Round (lgth), NU_NO_SUSPEND) != NU_SUCCESS) {
                p_mem = P_NIL;

            } else {

                    /* Clear to 0 the allocated area */

                Memset_far ((char FAR *)p_mem, 0, lgth);
            }

		}

#   endif

		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS

		/* !!! Put your own memory management routine call here !!! */

		if ((p_mem = (uchar FAR *)malloc (lgth)) == NULL) {
			p_mem = P_NIL;

		} else if (pid == PID_VL) {

				/* Clear to 0 the area */

			Memset_far ((char FAR *)p_mem, 0, lgth);
		}

#   endif

		/* Return with allocated pointer */

	return (p_mem);

} /* End of mem_alloc () */

/*----------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*         mem_free         */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


void mem_free (p_add, pid)
	char		FAR	*p_add;		/* address of the block to release */
	uchar		pid;			/* partition ID */
{

#	if (OS == MS_WINDOWS) || (OS == WINDOWS_NT) || (OS == WINDOWS_95)

		HGLOBAL hglb;							/* global handle of a memory object */
		struct mem_handle	FAR *p_mem_handle;	/* pointer to memory handle information */

#		if (OS == WINDOWS_NT) || (OS == WINDOWS_95)
			DWORD	os_err_win32;				/* extended error information */
#		endif

#	endif

		/*------------------- MS/DOS SIMULATION ------------------*/

#	if (OS == MS_DOS) && (SIMULATION == ON)

			/* Restore the 'mem_reserved' block */

		p_add -= Mem_reserved_size;

		if (pid == PID_VL) {

				/* VL free */

			sim_vl_used -= ((struct mem_reserved FAR *)p_add) -> lgth;

			if (pr_vl_mem == ON) {

					/* print PID_VL deallocation */

				fprintf (f_out, "\nMem_free: -%d=%ld", ((struct mem_reserved FAR *)p_add) -> lgth, sim_vl_used);
			}

		}

		free ((char *)p_add);

#	endif

		/*------------------- MS/DOS NO SIMULATION ------------------*/

#	if (OS == MS_DOS) && (SIMULATION == OFF)

		free ((char *)p_add);

#	endif

		/*---------------------- UNIX / OS9 ------------------------*/

#	if (OS == UNIX) || (OS == OS9)
		free ((char *)p_add);
#	endif

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX

		if (pid != PID_VL) {
			sc_rblock ((int)pid, (char FAR *)p_add, &os_err);

			if (os_err != RET_OK) {
				Trap (TRAP_OS + os_err, "mem_free");
			}

		}

#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX

		if (pid == PID_VL) {
			
#			if (OS_RELEASE != MC68000_V3)
				os_err = ajmfre ((char FAR *)p_add);

				if (os_err != AEROK) {
					Trap (TRAP_OS + os_err, "mem_free VL");
				}
#			endif

#			if (OS_RELEASE == MC68000_V3)

				os_err = cjmmfree ((void FAR *) p_add);;

				if (os_err != CJ_EROK) {
					Trap (TRAP_OS + os_err, "mem_free VL");
				}
#			endif

		} else {

#			if (OS_RELEASE == I86_V2)
				os_err = ajbrb ((char FAR *)p_add);
#			endif

#			if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
				os_err = ajbfre ((char FAR *)p_add);
			
				if (os_err != AEROK) {
					Trap (TRAP_OS + os_err, "mem_free");
				}
#			endif

#			if (OS_RELEASE == MC68000_V3)
				os_err = cjbmfree ((void FAR *) p_add);;

				if (os_err != CJ_EROK) {
					Trap (TRAP_OS + os_err, "mem_free");
				}
#			endif

		}

#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86

		if (pid != PID_VL) {
			MTR_lib_msg ((char FAR *)p_add);
		}

#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86
		Trap (TRAP_OS, "mem_free : redimensionnez les caches !");
#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
		Mt_Release_Mem(pid, (BYTE *) p_add);
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS

		if (pid == PID_VL) {

				/* Variable length partition */

			if ((p_add = pmem ((POOLT_PTR)OS_IOPOS_pool_p_tab [MX_PID], p_add)) != P_NIL) {
				Trap (TRAP_OS, "mem_free_vl");
			}

		} else {

				/* Fixed length partition */

			if ((p_add = (char FAR *)(rel_chunk ((CH_POOL_PTR)(OS_IOPOS_pool_p_tab[pid]), (CHUNK_PTR)p_add))) != P_NIL) {
				Trap (TRAP_OS, "mem_free_fl");
			}

		}

#	endif

		/*---------------------- IMECOM_OS -----------------------*/

#	if OS == IMECOM_OS

		if (pid != PID_VL) {
			lib_memory_to_os (p_add);

		} else {

			lib_work_mem (p_add);
		}

#	endif

		/*------------------------- PSOS -------------------------*/

#	if OS == PSOS

		if (pid != PID_VL) {

				/* Fixed length --> buffer pool */

			if ((os_err = PSOS_F_RET_BUF (psos_ptid[pid], (uchar FAR *)p_add)) != PSOS_C_RC_OK) {
				Trap (TRAP_OS + os_err, "mem_free_fl");
			}

		} else {

				/* Variable length --> segment */

			if ((os_err = PSOS_F_FREE_SEG ((uchar FAR *)p_add)) != PSOS_C_RC_OK) {
				Trap (TRAP_OS + os_err, "mem_free_vl");
			}

		}

#	endif

		/*------------------------ PSOS86 ------------------------*/

#	if OS == PSOS86

		if (pid != PID_VL) {

				/* Fixed length --> buffer pool */

			if ((os_err = ret_buf (psos_ptid[pid], (uchar FAR *)p_add)) != 0) {
				Trap (TRAP_OS + os_err, "mem_free_fl");
			}

		} else {

				/* Variable length --> segment */

			if ((os_err = free_seg ((uchar FAR *)p_add)) != 0) {
				Trap (TRAP_OS + os_err, "mem_free_vl");
			}

		}

#	endif

		/*---------------------- PSOS_PLUS -----------------------*/

#   if OS == PSOS_PLUS

		ulong os_err;                  /* pSOS+ error code */

		if (pid != PID_VL) {

				/* Fixed length --> buffer pool */

			if ((os_err = pt_retbuf (psos_ptid[pid], (void *)p_add)) != 0) {
				Trap (TRAP_OS + os_err, "mem_free_fl");
			}

		} else {

				/* Variable length --> segment */

			if ((os_err = rn_retseg (psos_vl_region_id, (void *)p_add)) != 0) {
				Trap (TRAP_OS + os_err, "mem_free_vl");
			}

		}

#   endif

		/*------------------------ RTEMS -------------------------*/

#	if OS == RTEMS

		if (pid != PID_VL) {

				/* Fixed length --> memory pool */

			if (rtems_partition_return_buffer(rtems_ptid[pid], p_add) != RTEMS_SUCCESSFUL) {
				Trap (TRAP_OS, "mem_free_fl");
			}

		} else {

				/* Variable length --> system pool */

			free ((void FAR *)p_add);

		}

#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

#		if OS_RELEASE == VXWORKS_5_0

			if (pid != PID_VL) {

					/* Fixed length --> memory pool */

				if (memPartFree (vxworks_ptid [pid], (uchar FAR *)p_add) == ERROR) {
					Trap (TRAP_OS, "mem_free_fl");
				}

			} else {

					/* Variable length --> system pool */

				if (free ((uchar FAR *)p_add) == ERROR) {
					Trap (TRAP_OS, "mem_free_vl");
				}

			}

#		else

			if (pid != PID_VL) {

					/* Fixed length --> memory pool */

				if (memPartFree (vxworks_ptid [pid], p_add) == ERROR) {
					Trap (TRAP_OS, "mem_free_fl");
				}

			} else {

					/* Variable length --> system pool */

				free ((void FAR *)p_add);

			}

#		endif

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME

			/*
				Reclaim the block to its original port.
				Variable-length blocks do not have port, so the OS will
				just deallocate the block.
			*/

		TaskReclaimMsg ((void *)p_add);

#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68


		if (pid != PID_VL) {

				/*
					Restore the administration block and enter
					the calling process as owner of the block
				*/

			p_add -= sizeof (SIGSELECT);

			restore ((union SIGNAL *)p_add);

				/* Fixed length --> buffer port pool */

			free_buf ((union SIGNAL **)&p_add);

		} else {

			Trap (TRAP_PART_VL, "mem_fre VL");
		}

#	endif

		/*----------------------- MS-WINDOWS  ----------------------*/

#	if OS == MS_WINDOWS

			/* Get the global reference */

		p_mem_handle	= (struct mem_handle FAR *)(p_add - sizeof (struct mem_handle));
		hglb			= p_mem_handle -> hglb;
		GlobalUnlock (hglb);
		GlobalFree (hglb);

#	endif

		/*------------------- WINDOWS_NT/95  -----------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)

			/* Get the global reference */

		p_mem_handle	= (struct mem_handle FAR *)(p_add - sizeof (struct mem_handle));
		hglb			= p_mem_handle -> hglb;

		if (GlobalFree (hglb) == hglb) {
			os_err_win32 = GetLastError ();
			Trap ((ushort)(TRAP_OS + os_err_win32), "mem_free");
		}

#	endif

		/*---------------------- RISC OS ------------------------*/

#	if OS == RISC_OS
		free ((char *)p_add);
#	endif

		/*---------------------- NUCLEUS_PLUS -------------------*/

#   if (OS == NUCLEUS_PLUS)

		STATUS status;                  /* Nucleus status return code */

		if (pid != PID_VL) {

				/* Fixed length --> Partition pool */

			if ((status = NU_Deallocate_Partition ((VOID *)p_add)) != NU_SUCCESS) {
				Trap (TRAP_OS + status, "mem_free_fl");
			}

		} else {

				/* Variable length --> segment */

			if ((status = NU_Deallocate_Memory ((VOID *)p_add)) != NU_SUCCESS) {
				Trap (TRAP_OS + status, "mem_free_vl");
			}

		}

#   endif

		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS

		/* !!! Put your own memory management routine call here !!! */

		free ((void *)p_add);

#   endif

} /* End of mem_free () */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             lock_resource & unlock_resource - implements the management
				 of resources in order to solve concurrent access to resources.

				 lock_resource - implements the allocation of a resource to
								   the caller server.

				 unlock_resource - implements the allocation of a resource to
								   the caller server.

Usage            lock_resource (int resource_id);
					- resource_id = resource identification.

				 unlock_resource (int resource_id);
					- resource_id = resource identification.

Related
functions usage : OS dependent.


Description     lock_resource implements the allocation of a resource to a
				server process in order to access to a shared single resource.
				unlock_resource releases a previously allocated resource.

*--------------------------------------------------------------------------*/

#if SIMULATION == ON

			/* Lock/unlock resource simulation */

	short					sem_timer_val;
	short					sem_server_init_val;
	short					sem_cache_val;

#endif

			/* Resource identifiers */

	extern int				sem_timer;			/* semaphore ID to protect shared timer data */
	extern int				sem_server_init;	/* semaphore ID internal queue */
	extern int				sem_cache;			/* semaphore ID cache */

	/*-------*/

#if	OS == AMX

#	if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == MC68000_V3) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
#		define		MX_SEM	3
#	endif
#	if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
		AMXID				t_resource[MX_SEM];
#	endif
#	if (OS_RELEASE == MC68000_V3)
		CJ_ID				t_resource[MX_SEM];
#	endif

#endif

	/*-------*/

#if OS == PSOS_PLUS
	extern unsigned long    psos_sem_id[];      /* Semaphores ID list */
#endif

	/*-------*/

#if OS == VXWORKS
	extern SEM_ID			vxworks_semid[];    /* VxWorks binary semaphores ids table */
#endif

	/*-------*/

#if OS == MVP_ME
	extern long				t_mvp_sem_id[];		/* Semaphores ID list */
#endif

	/*-------*/

#if OS == OSE_OS68
	extern SEMAPHORE		ose_sem_id[];		/* Semaphores ID list */
#endif

	/*-------*/

#if (SIMULATION == OFF) && ((OS == WINDOWS_NT) || (OS == WINDOWS_95))
	extern HANDLE			win32_sem_handle[];	/* Semaphores handle list */
#endif

	/*-------*/

#if (OS == NUCLEUS_PLUS)
	extern NU_SEMAPHORE 	nucleus_sem_id [];	/* Semaphores ID list */
#endif


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*      lock_resource       */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


void lock_resource (resource_id)
	int		resource_id;				 /* resource identification */
{

#if SIMULATION == ON

	if (resource_id == sem_timer) {

		if (sem_timer_val++ != 0) {
			Trap (TRAP_LOCK, "lock_resource");
		}

	} else if (resource_id == sem_server_init) {

		if (sem_server_init_val++ != 0) {
			Trap (TRAP_LOCK, "lock_resource");
		}

	} else if (resource_id == sem_cache) {

		if (sem_cache_val++ != 0) {
			Trap (TRAP_LOCK, "lock_resource");
		}

	} else {

		Trap (TRAP_LOCK, "lock_resource");
	}

#else

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX

		sc_spend ((int)resource_id, (long)0, &os_err);

		if (os_err != RET_OK) {
			Trap (TRAP_OS + os_err, "lock_resource");
		}

#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX

#		if (OS_RELEASE == I86_V2)
			os_err = ajrsrv ((int)resource_id);
#		endif

#		if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
			os_err = ajsmrsv (t_resource[resource_id], 0, 0);
		
			if (os_err != AEROK) {
				Trap (TRAP_OS + os_err, "lock_resource");
			}
#		endif

#		if (OS_RELEASE == MC68000_V3)
			os_err = cjrmrsv (t_resource[resource_id], 10, 0);

			if (os_err != CJ_EROK) {
				Trap (TRAP_OS + os_err, "lock_resource");
			}
#		endif

#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86
		os_err = PWithPrio ((int)resource_id, 0L);

		if (os_err != cOK) {
			Trap (TRAP_OS + os_err, "lock_resource");
		}
#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86
		MTR_lock ();
#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
		It_disable ();
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS
		It_disable ();
#	endif

		/*------------------------- IMECOM_OS --------------------*/

#	if OS == IMECOM_OS
		It_disable ();
#	endif

		/*------------------------- PSOS -------------------------*/

#	if OS == PSOS
		It_disable ();
#	endif

		/*------------------------ PSOS86 ------------------------*/

#	if OS == PSOS86
		/* we could use process mode (setting NO_PREEMPT bit) */
		It_disable ();
#	endif

		/*---------------------- PSOS_PLUS -----------------------*/

#   if OS == PSOS_PLUS

		ulong os_err;                  /* pSOS+ error code */

		if ((os_err = sm_p (psos_sem_id[resource_id], SM_WAIT, 0/* no timeout*/)) != 0) {
			Trap (TRAP_OS + os_err, "lock_resource");
		}

#   endif

		/*------------------------- RTEMS ------------------------*/

#	if OS == RTEMS
		It_disable ();
#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

		if (semTake (vxworks_semid[resource_id], WAIT_FOREVER) == ERROR) {
			Trap (TRAP_OS, "lock_resource");
		}

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME

		TaskWaitSema (t_mvp_sem_id [resource_id]);

#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68
		wait_sem (ose_sem_id [resource_id]);
#	endif

		/*------------------- WINDOWS_NT/95 ------------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)

			/*
				For Windows NT, the semaphore handle must have SYNCHRONIZE
				access.
			*/

		DWORD	os_err_win32;			/* extended error information */

		if (WaitForSingleObject (win32_sem_handle[resource_id], INFINITE) == WAIT_FAILED) {
			os_err_win32 = GetLastError ();
			Trap ((ushort)(TRAP_OS + os_err_win32), "lock_resource");
		}

#	endif

		/*---------------------- NUCLEUS_PLUS ---------------------*/

#   if (OS == NUCLEUS_PLUS)

		STATUS status; 					/* Nucleus status return code */

		if ((status = NU_Obtain_Semaphore (&nucleus_sem_id[resource_id], NU_SUSPEND)) != NU_SUCCESS) {
			Trap (TRAP_OS + status, "lock_resource");
		}

#   endif


#endif /* not SIMULATION */

		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS
		It_disable ();
#	endif

} /* End of lock_resource () */

/*-------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*     unlock_resource      */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


void unlock_resource (resource_id)
	int		resource_id;				/* resource identification */
{

#if SIMULATION == ON

	if (resource_id == sem_timer) {

		if (--sem_timer_val != 0) {
		Trap (TRAP_LOCK, "unlock_resource");
		}

	} else if (resource_id == sem_server_init) {

		if (--sem_server_init_val != 0) {
			Trap (TRAP_LOCK, "unlock_resource");
		}

	} else if (resource_id == sem_cache) {

		if (--sem_cache_val != 0) {
			Trap (TRAP_LOCK, "unlock_resource");
		}

	} else {

		Trap (TRAP_LOCK, "unlock_resource");
	}

#else

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX
		sc_spost ((int)resource_id, &os_err);

		if (os_err != RET_OK) {
			Trap (TRAP_OS + os_err, "unlock_resource");
		}

#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX

#		if (OS_RELEASE == I86_V2)
			os_err = ajrels ((int)resource_id);
#		endif

#		if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
			os_err = ajsmrls (t_resource[resource_id]);

			if (os_err != AEROK) {
				Trap (TRAP_OS + os_err, "unlock_resource");
			}
#		endif

#		if (OS_RELEASE == MC68000_V3)
			os_err = cjrmrls (t_resource[resource_id]);

			if (os_err != CJ_EROK) {
				Trap (TRAP_OS + os_err, "unlock_resource");
			}
#		endif

#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86
		os_err = V((int)resource_id);

		if (os_err != cOK) {
			Trap (TRAP_OS + os_err, "unlock_resource");
		}

#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86
		MTR_unlock ();
#	endif


		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
		It_enable ();
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS
		It_enable ();
#	endif

		/*------------------------- IMECOM_OS --------------------*/

#	if OS == IMECOM_OS
		It_enable ();
#	endif

		/*------------------------- PSOS -------------------------*/

#	if OS == PSOS
		It_enable ();
#	endif

		/*------------------------ PSOS86 ------------------------*/

#	if OS == PSOS86
		/* we could use process mode (resetting NO_PREEMPT bit) */
		It_enable ();
#	endif

		/*---------------------- PSOS_PLUS -----------------------*/

#   if OS == PSOS_PLUS

		ulong os_err;                  /* pSOS+ error code */

        if ((os_err = sm_v (psos_sem_id[resource_id])) != 0) {
            Trap (TRAP_OS + os_err, "unlock_resource");
        }

#   endif

		/*------------------------- RTEMS ------------------------*/

#	if OS == RTEMS
		It_enable ();
#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

		if (semGive (vxworks_semid[resource_id]) == ERROR) {
			Trap (TRAP_OS, "unlock_resource");
		}

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME

		TaskSignalSema (t_mvp_sem_id [resource_id]);

#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68
		signal_sem (ose_sem_id [resource_id]);
#	endif

		/*------------------- WINDOWS_NT/95 ------------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)

		DWORD	os_err_win32;			/* extended error information */

		if (ReleaseSemaphore (win32_sem_handle[resource_id], 1, NULL) == FALSE) {
			os_err_win32 = GetLastError ();
			Trap ((ushort)(TRAP_OS + os_err_win32), "unlock_resource");
		}

#	endif

		/*---------------------- NUCLEUS_PLUS -------------------*/

#   if (OS == NUCLEUS_PLUS)

		STATUS status;					/* NUCLEUS status return code */

        if ((status = NU_Release_Semaphore (&nucleus_sem_id[resource_id])) != NU_SUCCESS) {
            Trap (TRAP_OS + status, "unlock_resource");
        }

#   endif

#endif /* not SIMULATION */

		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS
		It_enable ();
#	endif

} /* End of unlock_resource () */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            system_time - implements the reading of the current time
							  in system tick.

Usage           long system_time (void);

Related
functions usage : OS dependent.

Description     system_time implements the reading of the current time
				in SYSTEM_TICK unit.

return			absolute number of system tick.

*--------------------------------------------------------------------------*/

#if TIMER_IT == OFF /* { */

#if (OS == AMX) || (OS == MS_DOS) || (OS == OSE_OS68) || (OS == MS_WINDOWS) || \
    (OS == PSOS_PLUS) || (OS == PSOS) || (OS == PSOS86)

		VOLATILE long system_tick_counter;

        /* This function shall be called periodically by a user-defined mechanism */

		void	timer_system_tick_proc ()
		{
			system_tick_counter++;
		}

        /* This function should be called at initialization-time by a user-defined mechanism */

		void	timer_system_tick_init ()
		{
			system_tick_counter = 0;
		}

#endif

#endif /* } */

	/*-------------------*/

#if (OS == UNIX) || (OS == OS9) || (OS == WINDOWS_NT) || (OS == WINDOWS_95)
	extern ushort timer_system_tick;			/* value of the system tick */
#endif

/*-------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*       system_time        */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


long system_time ()
{

#if (SIMULATION == ON) || (TIMER_IT == ON) /* { */
	extern long current_time;
	return (current_time);

#else /* } { */

		/*----------------------- UNIX ----------------------------*/

#	if OS == UNIX

		struct timeval	tv;

		if (gettimeofday (&tv, P_NIL) != 0) {
			Trap (TRAP_OS + errno, "system_time");
		}

		return (((tv.tv_sec * 1000) + (tv.tv_usec / 1000)) / timer_system_tick);

#	endif

		/*------------------------ OS9 ----------------------------*/

#	if OS == OS9

		ulong				time;			/* time parameter */
		ulong				date;			/* date parameter */
		ushort				day;			/* day parameter */
		ulong				ticks;			/* ticks parameter */

			/* Get time in ticks according to the Julian format */

		if (_os9_getime (3, &time, &date, &day, &ticks) != 0) {
			Trap (TRAP_OS + errno, "system_time");
		}

		return (((time * 1000) / timer_system_tick) + (ticks & 0xffff));

#	endif

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX
		return (sc_gtime ());
#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX
#       if (OS_RELEASE == I386_V1)
			return (ajtick());
#       else
			return (system_tick_counter);
#       endif
#	endif

		/*---------------------- MS/DOS --------------------------*/

#	if OS == MS_DOS
		return (system_tick_counter);
#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86
		return (tick_counter);
#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86
		return (system_tick_counter);
#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
		return (Current_Time());
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS
		extern long mclock;
		return (mclock);
#	endif

		/*------------------------- IMECOM_OS --------------------*/

#	if OS == IMECOM_OS
#	endif

		/*------------------------- PSOS -------------------------*/

#	if (OS == PSOS_PLUS) || (OS == PSOS) || (OS == PSOS86)
		return (system_tick_counter);
#	endif

		/*------------------------- RTEMS ------------------------*/

#	if OS == RTEMS
		long tm;

		rtems_clock_get(RTEMS_CLOCK_GET_TICKS_SINCE_BOOT, &tm);
		return tm;
#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS
		return (tickGet ());
#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME
#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68

		/*	we could return ((ulong)get_ticks ()); */

        return (system_tick_counter);

#	endif

		/*------------------------ MS_WINDOWS ---------------------*/

#	if OS == MS_WINDOWS
		return (system_tick_counter);
#	endif

		/*------------------------ WINDOWS_NT/95 ------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)
		return ((long)(GetTickCount() / timer_system_tick));
#	endif

		/*------------------------ RISC OS ----------------------------*/

#	if OS == RISC_OS
		_kernel_swi_regs r;

		_kernel_swi(OS_ReadMonotonicTime, &r, &r);
		return((long)(r.r[0])/(10*timer_system_tick));
#	endif

		/*------------------------ NUCLEUS_PLUS -----------------------*/

#	if (OS == NUCLEUS_PLUS)
		return (system_tick_counter);
#	endif

#endif /* (SIMULATION == OFF) && (TIMER_IT == OFF) } */

} /* End of system_time () */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             timer_delay - implements a  timer delay.

Usage            void timer_delay (long delay);
					- delay : delay duration in SYSTEM TICK unit

Related
functions usage : OS dependent.

Description     timer_delay implements the waiting of a process during
				a duration in SYSTEM_TICK unit.

*--------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*       timer_delay        */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


void timer_delay (delay_value)
	long	delay_value;	/* duration of the delay in SYSTEM_TICK unit */
{

#if SIMULATION == ON

#else

		/*---------------------- MS/DOS --------------------------*/

#	if OS == MS_DOS

		while (delay_value-- != 0) {
			timer_system_tick_proc ();
		}

#	endif

		/*----------------------- UNIX ----------------------------*/

#	if OS == UNIX

		usleep (delay_value * timer_system_tick * 1000);

#	endif

		/*------------------------ OS9 ----------------------------*/

#	if OS == OS9

		if (_os9_sleep ((ulong *)&delay_value) != 0) {
			Trap (TRAP_OS + errno, "timer_delay");
		}

#	endif

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX
		sc_delay ((long)delay_value);
#	endif

		/*------------------------ AMX ---------------------------*/

#	if (OS == AMX) && (TIMER_IT == OFF)

#		if (OS_RELEASE == I86_V2)
			os_err = ajwatm ((int)delay_value);
#		endif

#		if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
			os_err = ajwatm ((long)delay_value);
		
			if (os_err != AEROK) {
				Trap (TRAP_OS + os_err, "timer_delay");
			}
#		endif

#		if (OS_RELEASE == MC68000_V3)
			os_err = cjtkwaitm ((CJ_TIME)delay_value);

			if (os_err != CJ_EROK) {
				Trap (TRAP_OS + os_err, "timer_delay");
			}
#		endif

#	endif

		/*------------------------ RTC86 -------------------------*/

#	if OS == RTC86

		int *presultat;

		os_err = WaitEvents ((int)0, delay_value, presultat);

		if (os_err != cOK) {
			Trap (TRAP_OS + os_err, "timer_delay");
		}

#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86
		MTR_delai (delay_value);
#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS
		i_delay (delay_value);
#	endif

		/*------------------------- IMECOM_OS --------------------*/

#	if OS == IMECOM_OS
#	endif

		/*------------------------- PSOS -------------------------*/

#	if OS == PSOS

		if ((os_err = PSOS_F_PAUSE_P (delay_value)) != PSOS_C_RC_OK) {
			Trap (TRAP_OS + os_err, "timer_delay");
		}

#	endif

		/*------------------------ PSOS86 ------------------------*/

#	if OS == PSOS86

		pause_p (delay_value);      /* return is always 0 */

#	endif

		/*---------------------- PSOS_PLUS -----------------------*/

#   if OS == PSOS_PLUS

        tm_wkafter (delay_value);   /* return is always 0 */

#   endif

		/*------------------------ RTEMS -------------------------*/

#   if OS == RTEMS

		rtems_task_wake_after (delay_value);

#   endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

		if (taskDelay ((int)delay_value) == ERROR) {
			Trap (TRAP_OS, "ERROR");
		}

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME
#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68
		delay ((OSTIME)delay_value);
#	endif

		/*------------------- WINDOWS_NT/95 ------------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)

		Sleep ((DWORD) (delay_value * timer_system_tick));

#	endif

		/*----------------------- RISC_OS ----------------------------*/

#	if OS == RISC_OS
		/* declared in delay.h (socket) but the assembler code is not found anywhere (delay.s)
		 *
		 * DELAY_(delay_value* timer_system_tick * 1000);
		 *
		 */
#	endif

		/*------------------------ NUCLEUS_PLUS -----------------------*/

#	if (OS == NUCLEUS_PLUS)
		NU_Sleep ((UNSIGNED) delay_value);
#	endif

#endif /* not SIMULATION */

} /* End of timer_delay () */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name        os_start_timer - request OS to start a timer.

Usage		void os_start_timer ()

*--------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*      os_start_timer      */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


#if SIMULATION == OFF

#if OS == OS9

	static alarm_id	omnitel_alarm_id;		/* used by OS9 for unique alarm ID storage */

#endif


void os_start_timer (timer_val)
	ulong	timer_val;						/* timer duration value in ticks */
{

		/*------------------------ UNIX ---------------------------*/

#	if OS == UNIX

		struct itimerval	timer_value;		/* timer value structure */
		ulong				ti_val_ms;			/* timer value in ms */

		timer_value.it_interval.tv_sec	= 0;
		timer_value.it_interval.tv_usec	= 0;
		ti_val_ms						= timer_val * timer_system_tick;
		timer_value.it_value.tv_sec		= ti_val_ms / 1000;
		timer_value.it_value.tv_usec	= (ti_val_ms % 1000) * 1000;

		if (setitimer (ITIMER_REAL, &timer_value, 0) < 0) {
			Trap (TRAP_OS + errno, "os_start_timer");
		}

#	endif

		/*-------------------------- OS9 ---------------------------*/

#	if OS == OS9

			/*
				NOTE : we don't ensure that high order bit is not set
				and that 'timer_val' is greater than 2.
			*/

		if (_os_alarm_set (&omnitel_alarm_id, SIG_TIMER, timer_val)) {
			Trap (TRAP_OS + errno, "os_start_timer");
		}

#	endif

} /* End of os_start_timer () */

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name        os_stop_timer - request OS to stop a timer.

Usage		void os_stop_timer ()

*--------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*      os_stop_timer       */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


#if SIMULATION == OFF

void os_stop_timer ()
{

		/*------------------------ UNIX ---------------------------*/

#	if OS == UNIX

		if (setitimer (ITIMER_REAL, 0, 0) < 0) {
			Trap (TRAP_OS + errno, "os_stop_timer");
		}

#	endif

		/*-------------------------- OS9 ---------------------------*/

#	if OS == OS9

		if (_os_alarm_delete (omnitel_alarm_id)) {
			Trap (TRAP_OS + errno, "os_stop_timer");
		}

#	endif

} /* End of os_stop_timer () */

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             trap - implements the processing of a fatal software error.

Usage            void trap (ushort trap_code, diagnostic_string);
						- trap_code = error code,
						- diagnostic_string = address of a literal containing
											  location name of the originator

Related
functions usage : OS dependent.

Description     trap implementation is OS dependent.

*--------------------------------------------------------------------------*/

#if SIMULATION == ON

#	if OS == MS_DOS
		extern FILE *f_out;			/* File OUT access */
#	endif

#	if OS == RTC86
		extern FILE *f_out;			/* File OUT access */
#	endif

#	if OS == UNIX
		extern FILE *f_out;			/* File OUT access */
#	endif

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)
		extern FILE *f_out;			/* File OUT access */
#	endif

#endif


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*           trap           */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


#if (SIMULATION == ON) || (ASSERT == ON)

#	if OS == MVP_ME
		void otrap (code, diagnostic_string)
#	else
		void trap (code, diagnostic_string)
#	endif

	ushort 	code;					/* error cause */
	char	diagnostic_string [];	/* error diagnostic */

#else

#	if OS == MVP_ME
		void otrap (code)
#	else
		void trap (code)
#	endif

	ushort 	code;					/* error cause */

#endif

{

#if SIMULATION == ON

		/*------------------------ MS/DOS (simulation) -----------*/

#	if OS == MS_DOS
		fprintf (f_out, "\n\n-- OMNITEL-BRICKS Simulator - TRAP - cause =  %u  diagnostic = %s --\n", code, diagnostic_string);
		fflush (f_out);
		fcloseall ();
#	endif

		/*------------------------ UNIX (simulation) -------------*/

#	if OS == UNIX
		fprintf (f_out, "\n\n-- OMNITEL-BRICKS Simulator - TRAP - cause =  %u  diagnostic = %s --\n", code, diagnostic_string);
		fflush (f_out);
#	endif

		/*------------------------ RTC86 (simulation) ------------*/

#	if OS == RTC86
		printf ("\n\n-- OMNITEL-BRICKS Simulator - TRAP - cause =  %u  diagnostic = %s --\n", code, diagnostic_string);
		fprintf (f_out, "\n\n-- OMNITEL-BRICKS Simulator - TRAP - cause =  %u  diagnostic = %s --\n", code, diagnostic_string);
		fflush (f_out);
		fcloseall ();
#	endif

		/*------------------------ WINDOWS_NT/95 (simulation) ----*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)
		fprintf (f_out, "\n\n-- OMNITEL-BRICKS Simulator - TRAP - cause =  %u  diagnostic = %s --\n", code, diagnostic_string);
		fflush (f_out);
		fcloseall ();
#	endif

#else

		/*------------------------ AMX ---------------------------*/

#	if (OS == AMX) || (OS == VRTX)

#		if NEW_FCT_STYLE == ON
			void process_trap_event (ushort code, char *diag);

#		else

			void process_trap_event ();
#		endif

#		if ASSERT == ON
			process_trap_event (code, diagnostic_string);

#		else

			process_trap_event (code, "");
#		endif

#	endif

#	if OS == RTC86
		trap_env ((int)code, diagnostic_string);
#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86
#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS

#			if ASSERT == ON
				kos_error (code, diagnostic_string);

#			else

				kos_error (code, "");
#	endif
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS

		if (((code >= 400) && (code <= 420)) || (code == 7)) {
			soft_fault (1000 + code);
		} else {
			fault (1000 + code);
		}

#	endif

		/*------------------------- IMECOM_OS --------------------*/

#	if OS == IMECOM_OS

#		if ASSERT == ON
		FP_trace_prn (diagnostic_string);
		crash(FB_ENT, (short)code, (short)diagnostic_string);

#		else

			FP_trace_prn ("");
			crash(FB_ENT, (short)code, (short)"");
#	endif

#	endif

		/*--------------------- PSOS/PSOS_PLUS -------------------*/

#   if (OS == PSOS) || (OS == PSOS_PLUS) || (OS == PSOS86)

#       if NEW_FCT_STYLE == ON
			void psos_process_trap_event (ushort code, char *p_diag);

#       else

			void psos_process_trap_event ();
#       endif

#       if ASSERT == ON
			psos_process_trap_event (code, diagnostic_string);

#       else

			psos_process_trap_event (code, "");
#       endif

#   endif

		/*------------------------ RTEMS -------------------------*/

#	if OS == RTEMS

#		if NEW_FCT_STYLE == ON
			void rtems_process_trap_event (ushort code, char *p_diag);
#		else
			void rtems_process_trap_event ();
#		endif

#		if ASSERT == ON
			rtems_process_trap_event (code, diagnostic_string);
#		else
			rtems_process_trap_event (code, "");
#		endif

#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

#		if NEW_FCT_STYLE == ON
			void vxworks_process_trap_event (ushort code, char *p_diag);

#		else

			void vxworks_process_trap_event ();
#		endif

#		if ASSERT == ON
			vxworks_process_trap_event (code, diagnostic_string);

#		else

			vxworks_process_trap_event (code, "");
#		endif

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME
#	endif

		/*------------------------ OSE_OS68 ----------------------*/

#	if OS == OSE_OS68

#		if NEW_FCT_STYLE == ON
			void process_trap_event (ushort code, char *diag);

#		else

			void process_trap_event ();
#		endif

#		if ASSERT == ON
			process_trap_event (code, diagnostic_string);

#		else

			process_trap_event (code, "");
#		endif

#	endif

		/*------------------------ WINDOWS_NT/95  ----------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)

#		if NEW_FCT_STYLE == ON
			void process_trap_event (ushort code, char *diag);
#		else
			void process_trap_event ();
#		endif

#		if ASSERT == ON
			process_trap_event (code, diagnostic_string);
#		else
			process_trap_event (code, "");
#		endif

#	endif

#endif /* not SIMULATION */

		/*------------------ WINDOWS (simulation or not)	 ----------*/

#	if OS == MS_WINDOWS

#		if NEW_FCT_STYLE == ON
			void process_trap_event (ushort code, char *diag);
#		else
			void process_trap_event ();
#		endif

#		if ASSERT == ON
			process_trap_event (code, diagnostic_string);
#		else
			process_trap_event (code, "");
#		endif

#	endif

		/*----------------------- RISC_OS ----------------------------*/

#  	if OS == RISC_OS
#  	endif

		/*------------------------ NUCLEUS_PLUS -----------------------*/

#	if (OS == NUCLEUS_PLUS)

#		if NEW_FCT_STYLE == ON
			void process_trap_event (ushort code, char *diag);

#		else

			void process_trap_event ();
#		endif

#		if ASSERT == ON
			process_trap_event (code, diagnostic_string);

#		else

			process_trap_event (code, "");
#		endif

#	endif

		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS
#   endif

		/* ========== Call the abort function =========== */

	abort_omnitel();

} /* End of trap () */

	/*===================================================================*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*       abort_omnitel      */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


void abort_omnitel ()
{

		/*------------------------ VRTX --------------------------*/

#	if OS == VRTX

			/* Wait for ever */

		for ( ; ; );

#	endif

		/*------------------------ AMX ---------------------------*/

#	if OS == AMX

#		if NEW_FCT_STYLE == ON
			void shut_down_application	(void);

#		else

			void shut_down_application	();
#		endif

		shut_down_application ();

#	endif

		/*------------------------ MS/DOS ------------------------*/

#	if OS == MS_DOS

		abort ();

#	endif

		/*------------------------ UNIX --------------------------*/

#	if OS == UNIX

		abort ();

#	endif

		/*------------------------ MTR86 -------------------------*/

#	if OS == MTR86

			/* Wait for ever */

		for ( ; ; );

#	endif

		/*-------------------------- KOS -------------------------*/

#	if OS == KOS
#	endif

		/*------------------------- OS_IOPOS ---------------------*/

#	if OS == OS_IOPOS
#	endif

		/*------------------------- IMECOM_OS --------------------*/

#	if OS == IMECOM_OS
#	endif

		/*-------------------------- PSOS -------------------------*/

#   if (OS == PSOS) || (OS == PSOS_PLUS) || (OS == PSOS86)

#       if NEW_FCT_STYLE == ON
			void psos_shut_down_application (void);

#       else

			void psos_shut_down_application ();
#       endif

		psos_shut_down_application ();

#   endif

		/*------------------------- RTEMS ------------------------*/

#	if OS == RTEMS

#		if NEW_FCT_STYLE == ON
			void rtems_shut_down_application	(void);
#		else
			void rtems_shut_down_application	();
#		endif

		rtems_shut_down_application ();

#	endif

		/*------------------------ VXWORKS -----------------------*/

#	if OS == VXWORKS

#		if NEW_FCT_STYLE == ON
			void vxworks_shut_down_application	(void);

#		else

			void vxworks_shut_down_application	();
#		endif

		vxworks_shut_down_application ();

#	endif

		/*------------------------ MVP_ME ------------------------*/

#	if OS == MVP_ME
		abort ();
#	endif

		/*------------------------ OSE_OS68 ------------------------*/

#	if OS == OSE_OS68

			/* Wait for ever */

		for (;;);

#	endif

		/*---------------------- MS_WINDOWS ------------------------*/

#	if OS == MS_WINDOWS
#	endif

		/*---------------------- WINDOWS_NT/95 ---------------------*/

#	if (OS == WINDOWS_NT) || (OS == WINDOWS_95)

#		if SIMULATION == ON

			abort ();

#		else

#			if NEW_FCT_STYLE == ON
				void win32_shut_down_application	(void);
#			else
				void win32_shut_down_application	();
#			endif

			win32_shut_down_application ();

#		endif

#	endif

		/*-------------------------- RISC OS -------------------------*/

#	if OS == RISC_OS

			/* call the module finalization code */

		module_final(0, 0, module_wsp);

#	endif

		/*------------------------ NUCLEUS_PLUS -----------------------*/

#	if (OS == NUCLEUS_PLUS)

#		if NEW_FCT_STYLE == ON
			void shut_down_application	(void);

#		else

			void shut_down_application	();
#		endif

		shut_down_application ();

#	endif


		/*---------------------- OMNITEL_OS -----------------------*/

#	if OS == OMNITEL_OS
#   endif

} /* End of abort_omnitel () */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             msg_audit_filtering - implements the filtering of a message
				 for audit purpose.

Usage            uchar msg_audit_filtering (uchar direction,
											struct message FAR *p_msg, );
					- direction : direction code of the message :
							'i' : sent, internal to the server;
							'I' : received, internal to the server;
							'e' : sent, external (OS);
							'R' : received, external (OS).
					- p_msg     : pointer on the message to filter.

Description     message audit filtering according to implementation
				requirements.

Return value    = CONTINUE --> audit the message
				= STOP     --> no audit

*--------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*    msg_audit_filtering   */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/


#if MESSAGE_AUDIT == ON

uchar msg_audit_filtering (direction, p_msg)
	char				direction;       	/* direction code */
	struct message FAR 	*p_msg;				/* pointer on a message */
{
	return (CONTINUE);
}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			 msg_capture - use to capture a message

Usage			 void  msg_capture (uchar direction,
									struct message FAR *p_msg);

					- direction 	: direction code of the message :
							'i' : sent, internal to the server;
							'I' : received, internal to the server;
							'e' : sent, external (OS);
							'R' : received, external (OS).
					- p_msg 		: pointer on the message to filter.

Description		Message capturing for user capturing facilities.

Return value	void

*--------------------------------------------------------------------------*/


						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/
						/*                          */
						/*        msg_capture       */
						/*                          */
						/*-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if MESSAGE_CAPTURE == ON

void msg_capture (direction, p_msg)
	char				direction;       	/* direction code */
	struct message FAR 	*p_msg;				/* pointer on a message */
{

}

#endif

/*EOF*/
