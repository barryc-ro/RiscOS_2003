
/*-----------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - com_proc.c
 *
 * $Revision$
 *
 * $Date$
 *
 *     _ctype_omnitel[] array describing the type of the ASCII characters.
 *
 * function(s) :
 *
 *     memcpy_far - copies area 2 to area 1, always n bytes.
 *     memset_far - sets an array of n chars starting at p_to to
 *                  the character c.
 *     memcmp_far - compare 2 areas, n bytes max.
 *     move_str_far - copy 2 strings
 *     strcmp_far  - compares two strings
 *
 *     srand_omnitel -  implements random init.
 *     rand_omnitel - implements random function.
 *
 *     kbhit - implements the test of a keyboard hiting event
 *             in a UNIX system.
 *
 *     difftime - implements the calculation of the difference
 *                betweeen two time values stored in two time_t structures
 *                (new_time - old_time).
 *
 *     add_blk - implements the adition of a memory block
 *               previously allocated to the block list.
 *     check_rel_blk - implements the checking of the block lists
 *               to search a given memory block and release it from the list.
 *
 *     free_msg  - deallocates a message.
 *     alloc_msg - allocates a message.
 *
 *     free_buffer   - deallocates a buffer.
 *     alloc_buffer  - allocates a buffer.
 *     msg_or_buffer - transfer of a buffer data in a message.
 *
 *     free_timer_cell  - deallocates a timer cell.
 *     alloc_timer_cell - allocates a timer cell.
 *
 *     free_memory_cache - implements the freeing of all the memory
 *               blocks allocated to the memory caches.
 *
 *     o_send_message - implements the sending of a message from
 *               an entity to an other entity.
 *     receive_message - implements the pending for an incoming
 *               message in a server.
 *
 *     congestion_busy,
 *     test_and_set_congestion,
 *     test_and_reset_congestion,
 *     entity_congestion_flag : implement the congestion management
 *
 *     send_busy - sends an SM_BUSY_IN or SM_CLEAR_BUSY_IN to the SM entity.
 *
 *     entity_to_server_access - returns server-id associated to an entity-id.
 *
 *     read_buffer_lgth,
 *     read_message_lgth,
 *     read_na_nb:        read services variables.
 *
 *     msg_audit_in - implements the management of a message audit buffer
 *               used to store message and buffer information.
 *
 *     services_init - implements the initialization of the
 *               services using a services init data structure.
 *     server_init - implements the initialization of a server.
 *
 *     read_i_services - implements the reading of the services parameters
 *
 *     prepare_data_to_send () - prepare a message and a buffer in order to
 *               load data. The buffer is under the data size which is needed.
 *
 *     services_var_init - init of services global variables.
 *
 *-----------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS Services                          |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#include "services.h"
#include "it.h"
#include "ctx_ext.h"

#if REVISION_STRING == ON
#	include "rev.services"
#endif

#define CPU_CONGESTION 	OFF		/* no CPU congestion flag */

/*

	This module implements the OMNITEL GENERAL COMMON FUNCTIONS.
	The way used to communicate between these functions and the
	outside is OS and TOOLS (Linker and loader) dependent.
	The serv_por.h header module isolates these functions and
	the OS and user'server functions.


*                -------------------------------
*               |                         |     |
*               |  ISOLATION : serv_por.h |     |
*      -------  |                         |  S  |
*     |      ===============================>   |
*    -------  | |                         |  E  |
*   |       | | |  --------------------   |     |
*  -------  | | | |     COM_PROC.C     |  |  R  |
* |       | | | | |                   ======>   |       ----------
* | O  S  | | | | |    OMNITEL common  |  |  V  |      |          |
* | M  E  ==========>                  |  |     |      |          |
* | N  R  | | | | |      functions     |  |  I  |      |          |
* | I  V  | | | | |                    |  |    =======>|   O  S   |
* | T  E  | |-  | |--------------------|  |  C  |      |          |
* | E  R  |-    | |                    |  |     |      |          |
* | L  S  ==========>  OMNITEL timer  ======>E  |      |          |
* |       |     | |                    |  |     |       ----------
*  -------      | |      functions     |  |  S  |
*               | |                    |  |     |
*               | |        ------------|  |  .  |
*               | |       |   timer   ======>   |
*               | |       |  process   |  |  C  |
*               |  --------------------   |     |
*               |                         |     |
*               |                         |     |
*                -------------------------------
*/

	int os_err;						/* last operating system error code */

#if SIMULATION == ON
	int interrupt_state;			/* simulated interrupt state */
									/* 0 : its are enabled */
									/* non zero : its are disabled (masked) */
#endif

#ifndef Msg_audit_in

		/* Now defined in serv_por.h, but needed to keep compatibility */

#	if MESSAGE_AUDIT == ON /* { */

#		if ASSERT == ON

#			define Msg_audit_in(direction, p_msg)		\
				if (performance == OFF) { 				\
					msg_audit_in (direction, p_msg); 	\
				} 										\
				Msg_capture  (direction, p_msg)
#		else

#			define Msg_audit_in(direction, p_msg)		\
				msg_audit_in (direction, p_msg); 		\
				Msg_capture  (direction, p_msg)
#		endif

#	else /* } { */

#		define Msg_audit_in(direction, p_msg)			\
				Msg_capture  (direction, p_msg)

#	endif /* } */

#	define Msg_audit_filtering(direction, p_msg)	msg_audit_filtering (direction, p_msg)

#endif


/*-------------------------------------------------------------------------*/

		/* ASCII table / character type */

		/* from UNIX */

#define _B 	_IS_SP		/* space */
#define _N	_IS_DIG	    /* digit */
#define _U	_IS_UPP		/* upper case */
#define _L	_IS_LOW		/* lower case */
#define _X	_IS_HEX		/* hexadecimal */
#define _C	_IS_CTL		/* control */
#define _P	_IS_PUN		/* punctuation */
#define _S	128 		/* unused */

CONST_ARRAY	uchar	_ctype_omnitel[] = { 0,

/*	     0		1	 	2	 	3	 	4	 	5	 	6	 	7  */

/*  0*/	_C,		_C,		_C,		_C,		_C,		_C,		_C,		_C,
/*  8*/	_C,		_S|_C,	_S|_C,	_S|_C,	_S|_C,	_S|_C,	_C,		_C,
/* 10*/	_C,		_C,		_C,		_C,		_C,		_C,		_C,		_C,
/* 18*/	_C,		_C,		_C,		_C,		_C,		_C,		_C,		_C,
/* 20*/	_S|_B,	_P,		_P,		_P,		_P,		_P,		_P,		_P,
/* 28*/	_P,		_P,		_P,		_P,		_P,		_P,		_P,		_P,
/* 30*/	_N|_X,	_N|_X,	_N|_X,	_N|_X,	_N|_X,	_N|_X,	_N|_X,	_N|_X,
/* 38*/	_N|_X,	_N|_X,	_P,		_P,		_P,		_P,		_P,		_P,
/* 40*/	_P,		_U|_X,	_U|_X,	_U|_X,	_U|_X,	_U|_X,	_U|_X,	_U,
/* 48*/	_U,		_U,		_U,		_U,		_U,		_U,		_U,		_U,
/* 50*/	_U,		_U,		_U,		_U,		_U,		_U,		_U,		_U,
/* 58*/	_U,		_U,		_U,		_P,		_P,		_P,		_P,		_P,
/* 60*/	_P,		_L|_X,	_L|_X,	_L|_X,	_L|_X,	_L|_X,	_L|_X,	_L,
/* 68*/	_L,		_L,		_L,		_L,		_L,		_L,		_L,		_L,
/* 70*/	_L,		_L,		_L,		_L,		_L,		_L,		_L,		_L,
/* 78*/	_L,		_L,		_L,		_P,		_P,		_P,		_P,		_C,
/* 80*/	 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,		0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,		0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,		0,	 	0,	 	0,
		 0,		0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,
		 0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0,	 	0
};

/*-------------------------------------------------------------------------*/

#ifndef FAST_MEM_ACCESS

/*
 *      Copy p_from to p_to, always copy n bytes.
 */

void memcpy_far (p_to, p_from, n)
	register char FAR	*p_to;
	register char FAR	*p_from;
	register ushort		 n;
{

	while (n-- > 0) {
		*p_to++ = *p_from++;
	}

}

#endif

/*-------------------------------------------------------------------------*/

#ifndef FAST_MEM_ACCESS

/*
 *     Set an array of n chars starting at p_to to the character c.
 */

void memset_far (p_to, c, n)
	register char FAR	*p_to;
	register char  		 c;
	register ushort		 n;
{

	while (n-- > 0) {
		*p_to++ = c;
	}

}

#endif

/*-------------------------------------------------------------------------*/

/*
 *      Compare p_from to p_to, compare n bytes max.
 */

ushort memcmp_far (p_to, p_from, n)
	register char FAR	*p_to	;
	register char FAR	*p_from	;
	register ushort 	 n		;
{

	while ((n > 0) && (*p_to++ == *p_from++)) {
		--n;
	}

	return (n);
}

/*-------------------------------------------------------------------------*/
/*
 *     Copy a string with a maximum number of characters.
 *			Returns the number of copied characters (including the null
 *			terminating character).
 *			If the maximum number of characters to be copied is reached,
 *			a null terminating character is put in the last copied character's
 *			place.
 */

uint move_str_far (p_to, p_from, mx_sz)
	register char FAR	*p_to;
	register char FAR	*p_from;
	ushort 				 mx_sz;
{
	register uint i = 1;

	if (p_from == P_NIL) {
		return (0);
	}

	while ((*p_to++ = *p_from++)!= '\0') {

		if (i++ >= mx_sz) {
			*(p_to-1) = '\0';
			i--;
			break;
		}

	}

	return (i);
}

/*-------------------------------------------------------------------------*/
/*
 *     Compare two strings - returns: 	0 	if equal
 *										<>0 else
 */

int strcmp_far(s1, s2)
	register char 	FAR *s1;
	register char 	FAR *s2;
{
	if(s1 == s2)
		return(0);

	while(*s1 == *s2++)
		if(*s1++ == '\0')
			return(0);
	return(*s1 - *--s2);
}


/*-------------------------------------------------------------------------*/

static long randx;

void srand_omnitel (x)
	long 		x;
{
		randx = x;
}

/*-------------------------------------------------------------------------*/

int rand_omnitel ()
{

#if SIMULATION == ON
	return ((int)randx++);

#else

#	if OS == OS_IOPOS
		extern long mclock;
		return ((int)((randx = (randx + (mclock & 0xff)) * 1103515245L + 12345) >>16) & 0x7fff);
#	else
		return ((int)((randx = randx * 1103515245L + 12345) >>16) & 0x7fff);
#	endif

#endif

}

#if (SIMULATION == ON) && (OS == UNIX)

#include <sys/poll.h>

	/* Parameters */

#define STDIN_FD	0		/* STDIN file logical number */
#define FDNUMBER	1		/* number of fds structure */

	/* Fds array */

static	struct pollfd	fds[FDNUMBER];

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			kbhit - implements the test of a keyboard hiting event
						in a UNIX system.

Usage           int kbhit();

Related
functions usage poll(struct fds, nbfds, 0);

Return value : 	kbhit returns TRUE if a keyboard key has been hit.

Common constants and declarations : poll.h

Common objects : fds array.

*--------------------------------------------------------------------------*/

int kbhit ()
{

		/* Initialization */

	fds[0].fd		= STDIN_FD;
	fds[0].events   = POLLIN;

		/* Poll the keyboard : STDIN */

	poll (fds, (ulong)FDNUMBER, 0);

		/* Test a received event */

	if (fds[0].revents == POLLIN) {
		return (TRUE);

	} else {

		return (FALSE);
	}

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			difftime - implements the calculation of the difference
						   betweeen two time values stored in two time_t
						   structures (new_time - old_time).

Usage           double difftime(struct time_t new_time, struct time_t old_time);

Return value : 	difftime returns the difference in Second scale.

Common constants and declarations : time.h

*--------------------------------------------------------------------------*/

#include <time.h>

double difftime (new_time, old_time)
	time_t new_time, old_time;

{
	return ((double)(new_time - old_time));
}

#endif

#if ASSERT == ON

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             add_blk - implements the addition of a memory block
						   previously allocated to the block list.

				 check_rel_blk - implements the checking of the block list
							 to search a given memory block and release it
							 from the list.

Usage            void add_blk (uchar FAR *p_blk, uchar blk_type);
					- p_blk 	= pointer on the block to add to the block list,
					- blk_type	= block type.

				 uchar check_rel_blk (uchar FAR *p_blk, uchar blk_type);
					- p_blk 	= pointer on the block to check,
					- blk_type	= block type.
					- return	= block pointer or P_NIL.

*--------------------------------------------------------------------------*/

#define MX_BLK_LIST		3			/* Maximum number of Block Lists */

#define	BLK_MSG			0			/* Message */
#define	BLK_BUFFER		1			/* Buffer */
#define	BLK_TIMER_CELL	2			/* Timer-cell */
#define	BLK_NIL			0xff		/* Nil */

#define	INI_MSG			0xFF		/* initialization value of a message */
#define INI_BUFFER		0xFF		/* initialization value of a buffer */
#define	INI_TIMER_CELL	0xFF		/* initialisation value of a timer-cell */

extern	int	 	sem_server_init;	/* semaphore server init */

typedef	uchar FAR * FAR *t_blk_list_t;

struct blk_list_def {
	t_blk_list_t	t_blk_list;
	ushort			blk_list_size;
};

struct blk_list_def t_blk_list_def[MX_BLK_LIST];	/* array of block lists definitions */

/*--------------------------------------------------------------------------*/

void	add_blk	(p_blk, blk_type)
	uchar	FAR		*p_blk;			/* block address */
	uchar			blk_type;		/* block type */
{
	ushort			i;				/* loop index */
	ushort			list_size;		/* size of the block list */
	uchar FAR *FAR *p_current_blk;	/* block list scanning pointer */

	if (blk_type < MX_BLK_LIST) {

		list_size	  = t_blk_list_def[blk_type].blk_list_size;
		p_current_blk = t_blk_list_def[blk_type].t_blk_list;

		for (i = 0 ; i < list_size; i++, p_current_blk++) {

			Lock_resource (sem_server_init);

			if ((*p_current_blk == p_blk) || (*p_current_blk == P_NIL)) {
				*p_current_blk = p_blk;

					/* Return */

				Unlock_resource (sem_server_init);
				return;
			}

			Unlock_resource (sem_server_init);
		}
	}

	Trap (TRAP_BLK_LIST, "add_blk");

}

/*-------------------------------------------------------------------------*/

uchar FAR *check_rel_blk (p_blk, blk_type)
	uchar	FAR		*p_blk;			/* block address */
	uchar			blk_type;		/* block type */
{
	ushort			i;				/* loop index */
	ushort			list_size;		/* size of the block list */
	uchar FAR *FAR *p_current_blk;	/* block list scanning pointer */

	if (blk_type < MX_BLK_LIST) {

		list_size	  = t_blk_list_def[blk_type].blk_list_size;
		p_current_blk = t_blk_list_def[blk_type].t_blk_list;

		for (i = 0; i < list_size; i++, p_current_blk++) {

			Lock_resource (sem_server_init);

			if (*p_current_blk == p_blk) {
				*p_current_blk = P_NIL;

					/* Found - return */

				Unlock_resource (sem_server_init);
				return (p_blk);
			}

			Unlock_resource (sem_server_init);
		}
	}

	return (P_NIL);

}

#endif

/*-------------------------------------------------------------------------*/

							/* CPU SHARED DATA */


						/* VARIABLE LENGTH MEMORY MANAGEMENT */

			char 					FAR	*part_add;				/* available memory for OMNITEL-BRICKS static partition */
			long						part_lgth;				/* length of the available memory of the static partition*/

						/* MESSAGE CONGESTION MANAGEMENT */

			ushort						message_nb;				/* number of message */
			uchar						message_lgth;			/* message length */

			ushort			   VOLATILE	message_alloc_counter;	/* allocation message counter */

#		if MESSAGE_CONG_CONTROL == ON
			ushort						message_low_mark;		/* message low mark value */
			ushort						message_high_mark;		/* message high mark value */
			uchar			   VOLATILE	message_cong_flag;		/* Message congestion flag */
			ushort			   VOLATILE	message_cong_nb;		/* Message congestion counter */
#		endif

#		if ASSERT == ON

				/* Performance : short-cut of simulation control */

			uint						performance;			/* performance flag */

#		endif

#		if MESSAGE_CACHE == ON

				/*
				   Cache data management : the access is protected against
				   concurrent access by a semaphore  (lock_cache and unlock cache).
				*/

	static ushort						 message_cache_size;	/* size of the message cache */
	static struct message FAR * VOLATILE p_message_cache;		/* cache pointer array */
	static ushort				VOLATILE message_cache_nb;		/* number of message in the cache */

#		endif

							/* RESOURCE ID */

			int 	   	 				sem_timer;				/* semaphore ID to protect shared timer data */
			int 		 				sem_server_init;		/* semaphore server init */
			int 		 				sem_cache;				/* semaphore ID cache */

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             free_msg - implements the deallocation of a message
							previously used by the server.

				 alloc_msg - implements the allocation of a message.

Usage            free_msg (structure message FAR *p_msg);
					- p_msg = pointer on the message to deallocate.

				 struct message FAR *alloc_msg (void);


Related
functions usage : void Mem_free   (char FAR *p_add, uchar pid);
				  char *Mem_alloc (ushort lgth, uchar pid);


Description     free_msg implements the deallocation of a message.
				The message is keep in a local cache for a next reusing.
				If the local cache is full up the message is returned to
				the Operating System. This service is Operating System
				and implementation dependent.

				alloc_msg implements the symetric service.

				The message cache is managed Last In First Out (LIFO).

*--------------------------------------------------------------------------*/

void free_msg (p_msg)
	struct message FAR *p_msg;
{

	if (p_msg != P_NIL) {

#		if ASSERT == ON

			if (performance == OFF) {

					/* Check if the pointer has been allocated to a message */

				if (check_rel_blk ((uchar FAR *)p_msg, BLK_MSG) == P_NIL) {
					Msg_audit_in ('t', p_msg);
					Trap (TRAP_BAD_POINTER, "free_msg");
				}

			}

#		endif

			/* Release the linked buffer */

		if (L_msg_p_buffer != P_NIL) {
			Free_buffer (L_msg_p_buffer);
			L_msg_p_buffer = P_NIL;
		}

			/* Lock the shared data */

		/*++++++++++++++++++++++*/
		Lock_resource (sem_cache);

#		if BLOCK_COUNTING == ON

			if (message_alloc_counter-- == 0) {
				Trap (TRAP_MSG_FREE, "free_msg");
			}

#		else

#			if MESSAGE_CONG_CONTROL == ON
				--message_alloc_counter;
#			endif

#		endif

#		if MESSAGE_CACHE == ON

				/* Is the message cache full ? */

			if (message_cache_nb < message_cache_size) {

#				if ASSERT == ON

					/* Check if already in the cache */

					if (performance == OFF) {

						{
							struct message FAR *p_curr;

							for (p_curr = p_message_cache; p_curr != 0; p_curr = p_curr -> p_next) {

								if (p_curr == p_msg) {
									Msg_audit_in ('t', p_msg);
									Trap (TRAP_BAD_POINTER, "free_msg");
								}

							}

						}

					}

#				endif

				Lifo_put_msg (p_message_cache, p_msg);
				message_cache_nb++;

				Unlock_resource (sem_cache);
				/*-------------------------*/

			} else {

#		endif

		Unlock_resource (sem_cache);
		/*-------------------------*/

		Mem_free ((char FAR *)p_msg, PID_MESSAGE);

#		if MESSAGE_CACHE == ON
			}
#		endif

	}

#	if MESSAGE_CONG_CONTROL == ON

			/* If high mark on reset the congestion busy if necessary */

		It_disable ();

			if ((message_cong_flag == ON) &&
				(message_alloc_counter == message_nb - message_high_mark)) {
				message_cong_flag = OFF;      		/* reset message congestion flag */
				test_and_reset_congestion (OFF);    /* test global congestion and reset if necessary */
			}

		It_enable ();

#	endif

}

/*-------------------------------------------------------------------------*/

struct message FAR *alloc_msg ()
{
	struct message FAR *p_msg;			/* pointer on the allocated message */

		/* Lock the shared data */

	/*++++++++++++++++++++++*/
	Lock_resource (sem_cache);

#	if BLOCK_COUNTING == ON

			/* Increment message count */

		if (++message_alloc_counter > message_nb) {
			Trap (TRAP_MSG_ALLOC, "alloc_msg");
		}

#	else

#		if MESSAGE_CONG_CONTROL == ON
			++message_alloc_counter;
#		endif

#	endif

#	if MESSAGE_CACHE == ON

		if (message_cache_nb == 0) {

#	endif

	Unlock_resource (sem_cache);
	/*-------------------------*/

	if ((p_msg = (struct message FAR *) Mem_alloc (message_lgth, PID_MESSAGE)) == P_NIL) {
		Trap (TRAP_MSG_ALLOC, "alloc_msg");
	}

#	if MESSAGE_CACHE == ON

		} else {

			Lifo_get_msg (p_message_cache, p_msg);
			message_cache_nb--;
			Unlock_resource (sem_cache);
			/*-------------------------*/
		}

#	endif

#	if MESSAGE_CONG_CONTROL == ON

			/* Message congestion management */

		It_disable ();

			if ((message_cong_flag == OFF) &&
				(message_alloc_counter == message_nb - message_low_mark)) {
				message_cong_flag 		= ON;			/* set flag on */
				message_cong_nb++;
				test_and_set_congestion (OFF);			/* test and send start of resource congestion */
			}

		It_enable ();

#	endif

#	if ASSERT == ON

		if (performance == OFF) {

				/* Reset the message */

			Memset_far ((char FAR *)p_msg, (uchar)INI_MSG, message_lgth);

				/* Add the message to the check list */

			add_blk ((uchar FAR *)p_msg, BLK_MSG);
		}

#	endif

		/* Init message header */

	L_msg_lib			= ON;
	L_msg_p_buffer		= P_NIL;

	L_msg_data_offset	= MESSAGE_HEADER_SIZE;

	L_msg_data_size 	=
	L_msg_frag_size		=
	L_msg_frag_offset	= 0;

		/* Return */

	 return (p_msg);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             free_buffer - implements the deallocation of a previously
							   allocated thread of buffers.

				 alloc_buffer - implements the allocation of a buffer.

Usage            void free_buffer (struct buffer FAR *p_buff);
						- p_buffer : address of the first buffer of the
									 thread to deallocate.

				 struct buffer FAR *alloc_buffer (void)

Related
functions usage : void Mem_free   (char FAR *p_add, uchar pid);
				  char *Mem_alloc (ushort lgth, uchar pid);


Description     free_buffer test the link count, if 0 the buffer is
				deallocated. if not 0 it decrements the link count
				and deallocate the buffer and the folowing buffer in the
				thread if the link count is than empty.

				The deallocated buffer is stored in	a local LIFO cache
				for a faster futur reallocation.

				If the cache is full up the buffer is returned to the OS.
				The cache is managed Last In First Out (LIFO).

				alloc_buffer is the symetrical service of free_buffer.

*--------------------------------------------------------------------------*/

				/* COMMMON VARIABLES */

			ushort						buffer_nb;				/* number of buffer */
			ushort						buffer_lgth;			/* buffer length */

			ushort	   		   VOLATILE buffer_alloc_counter;	/* number of allocated buffer */

#if BUFFER_CACHE == ON
	static ushort						buffer_cache_size;		/* size of the buffer cache */
	static struct buffer FAR * VOLATILE p_buffer_cache;			/* cache buffer */
	static ushort			   VOLATILE	buffer_cache_nb;	    /* number of buffer in the cache */
#endif

#if BUFFER_CONG_CONTROL == ON
	ushort								buffer_low_mark;		/* low mark value */
	ushort								buffer_high_mark;		/* high mark value */
	uchar					   VOLATILE	buffer_cong_flag;		/* BUFFER CONGESTION flag */
	ushort					   VOLATILE buffer_cong_nb;			/* buffer congestion counter */
#endif

/*-------------------------------------------------------------------------*/

void free_buffer (p_buffer)
	struct buffer FAR *p_buffer;
{
	struct buffer FAR *p_next_buffer;

	while (p_buffer != P_NIL) {

		It_disable ();

		if ((Buffer_link_count == 0) || (--Buffer_link_count == 0)) {

			It_enable ();

#			if ASSERT == ON

				if (performance == OFF) {

						/* Check if the pointer has been allocted to a buffer */

					if (check_rel_blk ((uchar FAR *)p_buffer, BLK_BUFFER) == P_NIL) {
						Trap (TRAP_BAD_POINTER, "free_buffer");
					}

				}

#			endif

				/* Next Thread */

			p_next_buffer = Buffer_p_next;

#			if BUFFER_CACHE == ON

				/* Lock shared data */

			/*++++++++++++++++++++++*/
			Lock_resource (sem_cache);

					/* Is the cache full ? */

			if (buffer_cache_nb < buffer_cache_size) {

#				if ASSERT == ON

					/* Check if already in the cache */

					if (performance == OFF) {

						{
							struct buffer FAR *p_curr;

							for (p_curr = p_buffer_cache; p_curr != 0; p_curr = p_curr -> p_next) {

								if (p_curr == p_buffer) {
									Trap (TRAP_BAD_POINTER, "free_buffer");
								}

							}

						}

					}

#				endif

				Lifo_put_buffer (p_buffer_cache, p_buffer);
				buffer_cache_nb++;
				Unlock_resource (sem_cache);
				/*------------------------*/

			} else {

					/* Unlock shared data */

				Unlock_resource (sem_cache);
				/*------------------------*/

#			endif

				Mem_free ((char FAR *)p_buffer, PID_BUFFER);

#		if BUFFER_CACHE == ON

			}

#		endif

#		if BLOCK_COUNTING == ON

			It_disable ();

			if (buffer_alloc_counter-- == 0) {
				It_enable ();

				Trap (TRAP_BUFFER_FREE, "free_buffer");
			}

			It_enable ();

#		else

#			if BUFFER_CONG_CONTROL == ON

				It_disable ();
					--buffer_alloc_counter;
				It_enable ();

#			endif

#		endif


#		if BUFFER_CONG_CONTROL == ON

				/* If high mark on reset the congestion busy if necessary */

			It_disable ();

				if ((buffer_alloc_counter == buffer_nb - buffer_high_mark) &&
					(buffer_cong_flag == ON)) {
					buffer_cong_flag = OFF;      		/* reset buffer congestion flag */
					test_and_reset_congestion (OFF);    /* test global congestion and reset if necessary */
				}

			It_enable ();

#		endif

			p_buffer = p_next_buffer;

		} else {

			It_enable ();
			break;
		}

	}

}

/*-------------------------------------------------------------------------*/

struct buffer FAR *alloc_buffer ()
{
	struct buffer  FAR	*p_buffer;			/* pointer to allocated buffer */


		/* Lock the shared data */

	Lock_resource (sem_cache);

#if BLOCK_COUNTING == ON

		/* Increment buffer count */

	if (++buffer_alloc_counter > buffer_nb) {
		Trap (TRAP_BUFFER_ALLOC, "alloc_buffer");
	}

#else

#	if BUFFER_CONG_CONTROL == ON
		++buffer_alloc_counter;
#	endif

#endif

#if BUFFER_CACHE == ON

		/* Is the buffer cache empty ? */

	if (buffer_cache_nb == 0) {

#endif

	Unlock_resource (sem_cache);

	if ((p_buffer = (struct buffer FAR *) Mem_alloc (buffer_lgth, PID_BUFFER)) == P_NIL) {
		Trap (TRAP_BUFFER_ALLOC, "buffer_alloc");
	}

#if BUFFER_CACHE == ON

	} else {

		Lifo_get_buffer (p_buffer_cache, p_buffer);
		buffer_cache_nb--;
		Unlock_resource (sem_cache);
	}

#endif

#if BUFFER_CONG_CONTROL == ON

		/* Buffer congestion management */

	It_disable ();

		if ((buffer_cong_flag == OFF) && (buffer_alloc_counter == buffer_nb - buffer_low_mark)) {
			buffer_cong_flag 		= ON;		/* set x_off flag on */
			buffer_cong_nb++;
			test_and_set_congestion (OFF);		/* test and send start of resource congestion */
		}

	It_enable ();

#endif

#if ASSERT == ON

	if (performance == OFF) {

			/* Reset the buffer */

		Memset_far ((char FAR *)p_buffer, (uchar)INI_BUFFER, buffer_lgth);

			/* Add the buffer to the check list */

		add_blk ((uchar FAR *)p_buffer, BLK_BUFFER);

	}

#endif

		/* Init the buffer header */

	Buffer_header_init;

		/* Return */

	return (p_buffer);

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			msg_or_buffer - implements the transfer of the buffer data
								in a message if the message is able to contain
								the data, after the buffer is deallocated.
								If not the buffer is linked to the message
								previously allocated.

Usage           struct message FAR *msg_or_buffer (struct buffer FAR *p_buffer,
												   uchar hole size);
						- p_buffer  : pointer on buffer,
						- hole_size : size of the hole.

Common constants and declarations : Buffer an Msg

Common objects : p_buffer points on the current buffer.
				 p_msg points on the message.

*--------------------------------------------------------------------------*/

struct message FAR *msg_or_buffer (p_buffer, hole_size)
	struct	buffer FAR 	*p_buffer;		/* buffer pointer */
	uchar				hole_size;		/* hole size ahead of data */
{
	struct message FAR	*p_msg;			/* pointer on the send message */

		/* Allocate a send message */

	p_msg = Alloc_msg ();

#if MESSAGE_SEND_DATA == ON

		/* Message only or message + buffer ? */

	if ((ushort)(Buffer_data_size + hole_size) <= (ushort)Message_data_lgth) {
		L_msg_header_init;
		L_msg_data_size		 = (uchar)Buffer_data_size;
		L_msg_data_offset   += hole_size;

		Memcpy_far ((char FAR *)L_msg_a_start_data, (char FAR *)Buffer_a_start_data, Buffer_data_size);

		Free_buffer (p_buffer);

	} else {

#endif

			/* Link the buffer to the message to send */

		L_msg_init_link_buffer;					/* init the linked buffer address or P_NIL */

#if MESSAGE_SEND_DATA == ON

	}

#endif

	return (p_msg);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             free_timer_cell - implements the deallocation of a timer
								   cell.

				 alloc_timer_cell - implements the allocation of a timer cell.

Usage            free_timer_cell (uchar FAR *p_cell);
					- p_cell = address of a timer cell.

				 uchar FAR *alloc_timer_cell (void)

Related
functions usage : void Mem_free   (char FAR *p_add, uchar pid);
				  char FAR *Mem_alloc (ushort lgth, uchar pid);


Description     free_timer_cell implements the deallocation of a previously
				allocated timer_cell. A cache array is used to optimilize
				the allocation/deallocation of a timer_cell.

				alloc_timer_cell is symetrical.

				The cache is managed Last In First Out (LIFO).

return			 = P_NIL timer-cell saturation,
				!= P_NIL no timer-cell saturation / pointer on the allocated
						 cell.

*--------------------------------------------------------------------------*/

		/* Timer external variable */

	extern	ushort							timer_system_tick;		/* timer tick value in number of system tick */
	extern	ushort							timer_cell_nb;			/* number of timer cell in the system */
	extern	ushort							timer_precision;		/* timer precision required */
	extern	ushort							timer_slot_size;		/* number of timer slots */
	extern	struct timer_head FAR * VOLATILE p_timer_slot;			/* timer slot table pointer */
	extern	ushort							timer_period_tick;		/* timer tick period in ms */
	extern	ushort							timer_period_val;		/* timer period value */
	extern	ushort 	VOLATILE				timer_x_hand_clock;		/* hanclock value */
	extern	ulong 	VOLATILE				timer_last_time_clock;	/* last current system tick */

#	if TIMER_IT == ON
		extern 	long 						current_time;			/* current system time */
#	endif


#if TIMER_CELL_CACHE == ON
	static ushort							timer_cell_cache_size;		/* size of the cache */
	static struct timer_cell FAR * VOLATILE p_timer_cell_cache; 		/* timer_cell cache array */
	static ushort				   VOLATILE	timer_cell_cache_nb;		/* current number of timer cell in the cache */
#endif

	ushort						   VOLATILE	timer_cell_alloc_counter; 	/* timer cell allocation counter */

/*-------------------------------------------------------------------------*/

void free_timer_cell (p_cell)
	struct	timer_cell 		FAR *p_cell;	/* timer-cell to release */
{

	if (p_cell != P_NIL) {

#		if ASSERT == ON

			if (performance == OFF) {

					/* Check if the pointer has been allocted to a timer-cell */

				if (check_rel_blk ((uchar FAR *)p_cell, BLK_TIMER_CELL) == P_NIL) {
					Trap (TRAP_BAD_POINTER, "free_timer_cell");
				}

			}

#		endif

			/* Lock the shared data */

		Lock_resource (sem_cache);

#		if BLOCK_COUNTING == ON

				/* Decrement the timer-cell allocation counter */

			if (timer_cell_alloc_counter-- == 0) {
				Trap (TRAP_TIMER_CELL_FREE, "free_timer_cell");
			}

#		endif

#		if TIMER_CELL_CACHE == ON

				/* Is the cache full ? */

			if (timer_cell_cache_nb < timer_cell_cache_size) {
				Lifo_put_timer_cell (p_timer_cell_cache, p_cell);
				timer_cell_cache_nb++;
				Unlock_resource (sem_cache);

			} else {

#		endif

			/* Unlock the shared data */

		Unlock_resource (sem_cache);

		Mem_free ((char FAR *)p_cell, PID_TIMER);

#		if TIMER_CELL_CACHE == ON

			}

#		endif

	}

}

/*-------------------------------------------------------------------------*/

struct timer_cell FAR *alloc_timer_cell ()
{
	struct timer_cell	FAR *p_cell;

		/* Lock the shared data */

	Lock_resource (sem_cache);

#	if BLOCK_COUNTING == ON

			/* Increment the timer-cell allocation counter */

		if (++timer_cell_alloc_counter > timer_cell_nb) {
            timer_cell_alloc_counter--;
			Unlock_resource (sem_cache);
			return (P_NIL);
		}

#	endif


#if TIMER_CELL_CACHE == ON

	if (timer_cell_cache_nb == 0) {

#endif

		Unlock_resource (sem_cache);

		if ((p_cell = (struct timer_cell FAR *) Mem_alloc (sizeof (struct timer_cell), PID_TIMER)) == P_NIL) {
			return (P_NIL);
		}

#if TIMER_CELL_CACHE == ON

	} else {

		Lifo_get_timer_cell (p_timer_cell_cache, p_cell);
		timer_cell_cache_nb--;
		Unlock_resource (sem_cache);
	}

#endif

#if ASSERT == ON

	if (performance == OFF) {

			/* Reset the timer-cell */

		Memset_far ((char FAR *)p_cell, (uchar)INI_TIMER_CELL, sizeof (struct timer_cell));

			/* Add the timer cell to the check list */

		add_blk ((uchar FAR *)p_cell, BLK_TIMER_CELL);

	}

#endif

	return (p_cell);

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             free_memory_cache - implements the freeing of all the memory
									 blocks allocated to the memory caches.

Usage            void free_memory_cache (void);

Related
functions usage : void Mem_free   (char FAR *p_add, uchar pid);

*--------------------------------------------------------------------------*/

void free_memory_cache ()
{
	struct message		FAR * VOLATILE p_msg;
	struct buffer		FAR * VOLATILE p_buffer;
	struct timer_cell	FAR * VOLATILE p_timer_cell;

	Lock_resource (sem_cache);

#if MESSAGE_CACHE == ON

	while (message_cache_nb != 0) {
		message_cache_nb--;
		Lifo_get_msg (p_message_cache, p_msg);
		Mem_free ((char FAR *)p_msg, PID_MESSAGE);
	}

#endif

#if BUFFER_CACHE == ON

	while (buffer_cache_nb != 0) {
		buffer_cache_nb--;
		Lifo_get_buffer (p_buffer_cache, p_buffer);
		Mem_free ((char FAR *)p_buffer, PID_BUFFER);
	}

#endif

#if TIMER_CELL_CACHE == ON

	while (timer_cell_cache_nb != 0) {
		timer_cell_cache_nb--;
		Lifo_get_timer_cell (p_timer_cell_cache, p_timer_cell);
		Mem_free ((char FAR *)p_timer_cell, PID_TIMER);
	}

#endif

	Unlock_resource (sem_cache);

}

#if SIM_BUILDER == ON
	extern	uint	tare;		/* simulation used to evaluate the simulation overhead */
#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            o_send_message - implements the sending of a message from
								 an entity to an other entity.

Usage           void o_send_message (struct message *p_send);
						- p_send = address of the message to send.

Related
functions usage void put_queue(struct message FAR *p_msg, p_fifo);


Description     o_send_message implements the message communication
				system between OSI entity supported by server process.

Return value    void

*--------------------------------------------------------------------------*/

				/* SERVER global variables */

uchar						 server_nb;		/* number of servers to managed */
struct server   		FAR *p_server;		/* server descriptor pointer */
struct entity_descriptor	 p_entity_descriptor [ENTITY_ID_MAX - ENTITY_ID_MIN + 1];

void o_send_message (p_msg)
	struct message FAR	*p_msg;							/* address of the message to transmit */
{
#if OS != OMNITEL_OS
	struct message FAR 	*FAR *p_fifo_p_first;			/* FIFO first pointer */
	struct message FAR 	*FAR *p_fifo_p_last;			/* FIFO last  pointer */
#endif

	uint					  queue_id_to;				/* external queue identifier */
	uint					  queue_id_from;			/* external queue identifier */
	uchar					  x_server;					/* server current index */

#	if ASSERT == ON

		struct buffer 		FAR  *p_buffer;				/* buffer pointer */

		if (performance == OFF) {

				/* p_msg = P_NIL pointer */

			if (p_msg == P_NIL) {
				Trap (TRAP_BAD_POINTER, "o_send_message");
			}

				/* Assert : data offset and data size */

			if (L_msg_data_offset < MESSAGE_HEADER_SIZE) {
				Msg_audit_in ('t', p_msg);
				Trap (TRAP_MSG_DATA, "o_send_message");
			}

			if (L_msg_data_offset + L_msg_data_size > (uint)message_lgth) {
				Msg_audit_in ('t', p_msg);
				Trap (TRAP_MSG_DATA, "o_send_message");
			}

			if ((p_buffer = L_msg_p_buffer) != P_NIL) {

				if (Buffer_data_offset < BUFFER_HEADER_SIZE) {
					Msg_audit_in ('t', p_msg);
					Trap (TRAP_BUFFER_DATA, "o_send_message");
				}

				if (Buffer_data_offset + Buffer_data_size > (uint)buffer_lgth) {
					Msg_audit_in ('t', p_msg);
					Trap (TRAP_BUFFER_DATA, "o_send_message");
				}

			}

		}

#	endif

		/* Load Queue ID of the "from" servers */

	queue_id_from 	= ((x_server = Entity_to_server (L_msg_from))	== SERVER_ENTITY_X_NIL) ?
					  QID_NIL :
					  Server_qid (x_server);


		/* Load Queue ID of the "to" servers */

	queue_id_to 	= ((x_server = Entity_to_server (L_msg_to))		== SERVER_ENTITY_X_NIL) ?
					  QID_NIL :
					  Server_qid (x_server);


		/*
		   Are the origination and the destination entities
		   in the same server ? (managed by the same external queue).
		*/


	if ((queue_id_to == queue_id_from) && (queue_id_to != QID_NIL)) {


			/*
			   Yes, the two entities are in the same server
			   --> internal communication.
			*/

		Msg_audit_in ('i', p_msg);

#		if OS != OMNITEL_OS
			p_fifo_p_first	= (struct message FAR *FAR *)&Server_fifo_p_first (x_server);
			p_fifo_p_last	= (struct message FAR *FAR *)&Server_fifo_p_last  (x_server);
			Fifo_put_msg 	(p_fifo_p_first, p_fifo_p_last, p_msg);

#		else

				/*
					OMNITEL OS: no internal server FIFO,
					Post the message to the external ad hoc queue
				*/

			Os_send_message (queue_id_to, p_msg);

#		endif

	} else {

			/*
			   No, the two entities are in two separated servers
			   ---> external communication.
			*/

#		if SIM_ANALYSER == ON

				/* Print the message to transmit */

			pr_message (p_msg, ON);

#		endif

			/* Simulation ? */

#		if SIMULATION == ON

				/* Deallocation ? */

			if (L_msg_lib == ON) {
				Free_msg (p_msg);

			} else {

					/* Message as transmittted */

				p_msg -> p_services = (struct message FAR *)1;
			}

#		else

			Msg_audit_in ('e', p_msg);

			if (queue_id_to == QID_NIL) {
				Msg_audit_in ('t', p_msg);
				Trap (TRAP_NO_EXTERNAL_QUEUE, "o_send_message");
			}

				/* Post the message to the external ad hoc queue. */

			Os_send_message (queue_id_to, p_msg);

#		endif


	} 	/* End else */

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name            receive_message - implements the pending for an incoming
								  message in a server.

Usage           struct message FAR *receive_message (uint qid);
					- qid : external queue ID of the current server.

Related
functions usage struct message FAR *get_queue ();


Description     receive_message implements the attempting to receive a
				message in a server from a entity. A server serves one
				or several entities. receive_message polls first the
				internal FIFO of the server, if it is empty the server
				attempts to receive a message from the external unique
				FIFO (queue). If it is empty the server pends for a message
				from this external FIFO using the OS_RECEIVE function.

Return value    receive_message returns an address pointing on a received
				message.

*--------------------------------------------------------------------------*/

struct message FAR *receive_message (qid)
	uint		qid;							/* external queue ID */
{
	struct message FAR 	*p_msg;				/* received message pointer */
#if OS != OMNITEL_OS
	struct message FAR 	*FAR *p_fifo_p_first;	/* FIFO first pointer */
	struct message FAR 	*FAR *p_fifo_p_last;	/* FIFO last  pointer */
	uchar				i;
#endif

#	if SIM_BUILDER == ON
		start :
#	endif

#		if OS != OMNITEL_OS

				/* Search the FIFO descriptor pointer */

			for (i = 0; i < server_nb; i++) {

				if (Server_qid(i) == qid) {
					break;
				}

			}

			if (i == server_nb) {
				return (P_NIL);
			}

				/* Is there a message in the internal FIFO ? */

			p_fifo_p_first	= (struct message FAR *FAR *)&Server_fifo_p_first (i);
			p_fifo_p_last	= (struct message FAR *FAR *)&Server_fifo_p_last  (i);

			Fifo_get_msg (p_fifo_p_first, p_fifo_p_last, p_msg)

			if (p_msg != P_NIL) {

					/* yes ---> return it */

				Msg_audit_in ('I', p_msg);
				return (p_msg);
			}

#		endif

			/* No ---> wait on the external queue */

			/* MS/DOS simulation */

#		if SIM_BUILDER == ON
			p_msg = simul_message ();

			if (p_msg != P_NIL) {
				Msg_audit_in ('B', p_msg);

					/*
					   If tare  ON release the message and restart
					   the building of a message.
					*/

				if (tare == OFF) {
					return (p_msg);

				} else {

					Free_msg (p_msg);
					goto start;
				}

			}

			goto start;

#		else

				/* Wait for a message */

			p_msg = (struct message FAR *) Os_receive_message (qid);

			if (p_msg != P_NIL) {
				Msg_audit_in ('R', p_msg);
			}

			return (p_msg);

#		endif

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             congestion_busy - test_and_set_congestion -
				 test_and_reset_congestion implement the congestion management

Usage            uchar congestion_busy				(void);
				 void  test_and_set_congestion 		(uchar it_status);
				 void  test_and_reset_congestion 	(uchar it_status);

*--------------------------------------------------------------------------*/

	uchar  	VOLATILE congestion_flag;			/* CONGESTION FLAG : ON if an X_OFF has been sent and no X_ON */

	uchar	VOLATILE it_stack_msg_cong_flag;	/* IT stack message congestion flag */
	uchar	VOLATILE it_stack_buffer_cong_flag;	/* IT stack Buffer congestion flag */

#	if CPU_CONGESTION == ON
		uchar   VOLATILE cpu_cong_flag;			/* CPU CONGESTION flag */
#	endif

	ushort	VOLATILE it_stack_msg_cong_nb;		/* IT stack message congestion counter*/
	ushort	VOLATILE it_stack_buffer_cong_nb;	/* IT stack Buffer congestion counter */

#	if CPU_CONGESTION == ON
		ushort  VOLATILE cpu_cong_nb;			/* CPU CONGESTION counter */
#	endif

	ushort	VOLATILE it_stack_msg_nb;		 	/* current number of message in the stack */
	ushort	VOLATILE it_stack_buffer_nb;		/* current number of buffer in the stack */

	uchar	VOLATILE congestion_on_flag;		/* CONGESTION BUSY message requested */
	uchar	VOLATILE congestion_off_flag;		/* CONGESTION CLEAR BUSY message requested */

/*--------------------------------------------------------------------------*/

uchar congestion_busy ()
{
	return (congestion_flag);
}

/*--------------------------------------------------------------------------*/

void test_and_set_congestion (it_status)
	uchar	it_status;	/* ON = call under IT / OFF call from entity */

{

		/* If congestion OFF then set ON and send BUSY IN message to SM */

	if (congestion_flag == OFF) {
		congestion_flag = ON;

		if (congestion_on_flag == ON) {

			if (it_status == ON) {
				It_enable ();
				send_busy (SM_BUSY_IN, ON);
				It_disable ();

			} else {

				send_busy (SM_BUSY_IN, OFF);
			}

		}

	}

}

/*--------------------------------------------------------------------------*/


void test_and_reset_congestion (it_status)
	uchar	it_status;	/* ON = call under IT / OFF call from entity */
{

		/* If all congestion flags OFF send CLEAR BUSY INDICATION to SM */

	if (   (it_stack_buffer_cong_flag	== OFF)
		&& (it_stack_msg_cong_flag    	== OFF)

#	if MESSAGE_CONG_CONTROL == ON
		&& (message_cong_flag			== OFF)
#	endif

#	if BUFFER_CONG_CONTROL == ON
		&& (buffer_cong_flag			== OFF)
#   endif

#	if CPU_CONGESTION == ON
		&& (cpu_cong_flag				== OFF)
#	endif

	   ){
		congestion_flag = OFF;							/* reset congestion flag */

		if (congestion_off_flag == ON) {

			if (it_status == ON) {
				It_enable ();
				send_busy (SM_CLEAR_BUSY_IN, ON);		/* send clear resource congestion indication */
				It_disable ();

			} else {

				send_busy (SM_CLEAR_BUSY_IN, OFF);		/* send clear resource congestion indication */
			}

		}

	}

}


/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             send_busy - implements the sending of alert message
								  SM_BUSY_IN and SM_CLEAR_BUSY_IN to the
								  System Management entity.

Usage            void send_busy (uchar primitive_code, uchar it_flag);
					- primitive_code = SM_BUSY_IN or SM_CLEAR_BUSY_IN,
					- it_flag        = call under IT (ON) or not (OFF).

Related
functions usage : void o_send_message (struct message FAR *p_msg).

*--------------------------------------------------------------------------*/

void send_busy (primitive_code, it_flag)
	code_t				primitive_code;	/* primitive code of buffer flow control */
	uchar				it_flag;        /* it origination (ON) or not (OFF) */
{
	struct message FAR	*p_msg;         /* pointer on the allocated message */

	if (it_flag == ON) {
		It_get_msg (p_msg);

	} else {

			/* Allocate a communication message */

		p_msg = Alloc_msg ();
	}

	if (p_msg != P_NIL) {

			/* Load the message */

#		if SIMULATION == ON
			L_msg_from	= ENT_SM;

#		else

			if (it_flag == ON) {
				L_msg_from 	= ENT_PH_IT;

			} else {

				L_msg_from 	= ENT_NIL;
			}

#		endif

		L_msg_to		= ENT_SM;
		L_msg_nai		= NAI_NIL;
		L_msg_sapi		= SAPI_NIL;
		L_msg_add		= ADD_NIL;
		L_msg_code		= primitive_code;

			/* Send the message to the System Management entity */

		o_send_message (p_msg);

	}
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name             msg_audit_in - implements the management of the message audit
					 used to store the message and buffer information in a
					 cyclic FIFO for audit inspection.

Usage            void msg_audit_in (uchar direction, struct message FAR *p_msg);
						- direction = Sent or Received message :
								. 'e'      'R' 		external queue,
								. 'i'      'I' 		internal FIFO,
								. 'b'      'B' 		message builder.

						- p_msg = pointer on the message to be stored in the
								  audit array.

Return value     void.

*--------------------------------------------------------------------------*/

#if MESSAGE_AUDIT == ON

		/* Audit array */

struct	msg_audit  VOLATILE msg_audit [MESSAGE_AUDIT_SIZE];

struct msg_audit VOLATILE *p_msg_audit;		/* current pointer to the msg_audit table */

	/*
		'nb_audit_bytes_for_msg_data' gives the nb of bytes to copied into
		the audit 'data[]' field out of the message data area:
		this value is a constant because when auditing the message data area,
		the Message_data_size field is not used: the complete audit 'data[]'
		field is filled in, unless the message data area is shorter than the
		size of the audit 'data[]' field.
		Thus, this variable is initialised in 'services_init()' function.
	*/

ushort nb_audit_bytes_for_msg_data;

/*------------------------------------------------------------------------*/

void msg_audit_in (direction, p_msg)
			char					direction;			/* sent or received code */
			struct 	message 	FAR	*p_msg;     		/* message to be stored in the audit array */
{
			 struct 	buffer 	FAR	*p_buffer;			/* linked buffer pointer */
	register struct	msg_audit		*p_x;				/* msg audit current pointer */

		/* Filtering */

	if (Msg_audit_filtering (direction, p_msg) == STOP) {
		return;
	}

		/* Update the current pointer on the next item */

	It_disable ();

		p_x = (struct msg_audit *) p_msg_audit;

		if (++p_msg_audit == &msg_audit [MESSAGE_AUDIT_SIZE]) {
			p_msg_audit = &msg_audit[0];
		}

	It_enable ();

		/* Sent or Received */

	p_x -> direction = direction;	/* direction code */

		/* Get system time */

	p_x -> system_time				= System_time ();

		/* Resource counters and congestion flag */

	p_x -> message_alloc			= message_alloc_counter;
	p_x -> buffer_alloc				= buffer_alloc_counter;
	p_x -> timer_cell_alloc			= timer_cell_alloc_counter;
	p_x -> it_stack_msg_nb			= it_stack_msg_nb;
	p_x -> it_stack_buffer_nb		= it_stack_buffer_nb;
	p_x -> congestion_flag			= congestion_flag;

#	if MESSAGE_CONG_CONTROL == ON
		p_x -> message_cong_nb		= message_cong_nb;
#	else
		p_x -> message_cong_nb		= 0;
#	endif

#	if BUFFER_CONG_CONTROL == ON
		p_x -> buffer_cong_nb		= buffer_cong_nb;
#	else
		p_x -> buffer_cong_nb		= 0;
#	endif

	p_x -> it_stack_msg_cong_nb		= it_stack_msg_cong_nb;
	p_x -> it_stack_buffer_cong_nb	= it_stack_buffer_cong_nb;

		/* Transfert the data from the message to the msg_audit array */

	p_x -> to 						= L_msg_to;
	p_x -> from 					= L_msg_from;
	p_x -> nai	 					= L_msg_nai;
	p_x -> sapi 					= L_msg_sapi;
	p_x -> conn_id 					= L_msg_conn_id;
	p_x -> code 					= L_msg_code;
	p_x -> p_msg					= p_msg;
	p_x -> p_buffer					= p_buffer = L_msg_p_buffer;

	if (p_buffer != P_NIL) {

			/* Transfert the data from the buffer to the msg_audit array */

		p_x -> data_size 			= Buffer_data_size;	/* data size */

		Memcpy_far ((char FAR *)&p_x -> data[0],
					(char FAR *)Buffer_a_start_data,
					(ushort)Min (Buffer_data_size, MESSAGE_AUDIT_DATA_LGTH) );
	} else {

			/* Transfert the data from the message to the msg_audit array */

		p_x -> data_size = L_msg_data_size;

		Memcpy_far ((char FAR *)&p_x -> data[0],
					(char FAR *)L_msg_a_data,
					nb_audit_bytes_for_msg_data);

	}

		/* set system_time field to "????" to mark last item */

	p_msg_audit -> system_time = 0x3f3f3f3fL;

}

#endif

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			services_init - implements the initialization of the
								services using a services init
								data structure.

Usage           uchar services_init (p_i_service);
						- p_i_service : pointer on the init service data,

Return value : 	services init returns = OK
									  = NOK already done.

Common constants and declarations : services.h

*--------------------------------------------------------------------------*/

				/* NETWORK ACCESS */

nai_t						 na_nb;			/* maximum number of network access */

/*-------------------------------------------------------------------------*/

uchar services_init (p_i_service)
	struct i_service	FAR *p_i_service;
{
	uchar					i;			/* subscript */

		/* first time ? */

	if (message_nb != 0) {
		return (NOK);
	}

#	if ASSERT == ON
		performance				= (uint)I_performance;  /* performance flag */
#	endif

		/* Static address initialization */

	if (I_message_part_lgth != 0) {
		part_lgth 				= I_message_part_lgth;
		part_add 				= I_message_part_add;

	} else {

		part_add				= P_NIL;
		part_lgth				= 0;
	}

		/* Message initialization */

	message_nb 					= I_message_nb;
	message_lgth				= I_message_lgth;
	message_alloc_counter		= 0;

	if (Message_data_lgth < INF_SIZE) {
		Trap (TRAP_MSG_DATA_LGTH, "services_init");
	}

#	if MESSAGE_CACHE == ON

		message_cache_nb		= 0;

		if ((message_cache_size	= I_message_cache_size) != 0) {
			p_message_cache = P_NIL;
		}

#	else

		if (I_message_cache_size != 0) {
			Trap (TRAP_MESSAGE_CACHE, "services_init");
		}

#	endif

#	if MESSAGE_CONG_CONTROL == ON

		if ((message_high_mark = I_message_high_mark) != 0) {
			message_low_mark = I_message_low_mark;

			if ((message_high_mark > message_nb) ||
				(message_low_mark  > message_high_mark)) {
				Trap (TRAP_CONGESTION_CONTROL, "services_init");
			}

		} else {

			Trap (TRAP_CONGESTION_CONTROL, "services_init");
		}

#	else

		if (I_message_high_mark != 0) {
			Trap (TRAP_CONGESTION_CONTROL, "services_init");
		}

#	endif

		/*  Buffer initialization */

	buffer_nb					= I_buffer_nb;
	buffer_lgth					= I_buffer_lgth;
	buffer_alloc_counter		= 0;

#	if BUFFER_CACHE == ON

		buffer_cache_nb         = 0;	/* number of buffer in the cache */

		if ((buffer_cache_size	= I_buffer_cache_size) != 0) {
			p_buffer_cache = P_NIL;
		}

#	else

		if (I_buffer_cache_size != 0) {
			Trap (TRAP_BUFFER_CACHE, "services_init");
		}

#	endif

#	if BUFFER_CONG_CONTROL == ON

		if ((buffer_high_mark = I_buffer_high_mark) != 0) {
			buffer_low_mark		= I_buffer_low_mark;

			if ((buffer_high_mark > buffer_nb) ||
				(buffer_low_mark  > buffer_high_mark)) {
				Trap (TRAP_CONGESTION_CONTROL, "services_init");
			}

		} else {

			Trap (TRAP_CONGESTION_CONTROL, "services_init");
		}

#	else

		if (I_buffer_high_mark != 0) {
			Trap (TRAP_CONGESTION_CONTROL, "services_init");
		}

#	endif

		/* Timer cell initialization */

	timer_precision			= I_timer_precision;
	timer_system_tick		= I_timer_system_tick;

#	if TIMER_IT == OFF

		if (timer_precision < timer_system_tick) {
			Trap (TRAP_TIMER_VALUE, "services_init");
		}

		timer_last_time_clock = System_time ();

		timer_period_tick		= (ushort)(timer_precision   / timer_system_tick);
		timer_period_val		= (ushort)(timer_period_tick * timer_system_tick);

#	else

		current_time			=
		timer_last_time_clock  	= 0;

		timer_period_val		= timer_system_tick;

#	endif

	timer_cell_nb				= I_timer_cell_nb;
	timer_cell_alloc_counter	=
	timer_x_hand_clock			= 0;
	timer_slot_size				= I_timer_slot_size;

#	if TIMER_CELL_CACHE == ON

		timer_cell_cache_nb		= 0;	/* current number of timer cell in the cache */

		if ((timer_cell_cache_size = I_timer_cell_cache_size) != 0) {
			p_timer_cell_cache	= P_NIL;
		}

#	else

		if (I_timer_cell_cache_size != 0) {
			Trap (TRAP_TIMER_CELL_CACHE, "services_init");
		}

#	endif

	if ((p_timer_slot = (struct timer_head FAR *)Mem_alloc ((ushort)(timer_slot_size * sizeof (struct timer_head)), PID_VL)) == P_NIL) {
		Trap (TRAP_TIMER_SLOT, "services_init");
	}

#	if ASSERT == ON

		if (performance == OFF) {

			t_blk_list_def[BLK_MSG].blk_list_size		 	= message_nb;
			t_blk_list_def[BLK_BUFFER].blk_list_size	 	= buffer_nb;
			t_blk_list_def[BLK_TIMER_CELL].blk_list_size 	= timer_cell_nb;

			if (((t_blk_list_def[BLK_MSG].t_blk_list		= (t_blk_list_t)Mem_alloc ((ushort)(message_nb	  * sizeof (uchar FAR *)), PID_VL)) == P_NIL) ||
				((t_blk_list_def[BLK_BUFFER].t_blk_list		= (t_blk_list_t)Mem_alloc ((ushort)(buffer_nb	  * sizeof (uchar FAR *)), PID_VL)) == P_NIL) ||
				((t_blk_list_def[BLK_TIMER_CELL].t_blk_list	= (t_blk_list_t)Mem_alloc ((ushort)(timer_cell_nb * sizeof (uchar FAR *)), PID_VL)) == P_NIL) ) {
				Trap (TRAP_BLOCK_LIST, "services_init");
			}

		}

#	endif

		/* SERVER init */

	server_nb = (uchar)I_server_nb;

		/* Allocate the servers control blocks */

	if ((p_server = (struct server FAR *)Mem_alloc ((ushort)(server_nb * sizeof (struct server)), PID_VL)) == P_NIL) {
		Trap (TRAP_SERVER, "services_init");
	}

		/* Reset the servers control blocks */

	for (i = 0; i < server_nb; i++) {
		Server_qid 			(i)	= QID_NIL;
		Server_fifo_p_first (i)	= P_NIL;
		Server_fifo_p_last 	(i)	= P_NIL;
	}

		/* Reset the entities control blocks */

	for (i = ENTITY_ID_MIN; i <= ENTITY_ID_MAX; i++) {
		Entity_to_server      (i) = SERVER_ENTITY_X_NIL;
		Entity_congestion_on  (i) = 		/* CONGESTION BUSY message requested */
		Entity_congestion_off (i) = OFF;	/* CONGESTION CLEAR BUSY message requested */
		Entity_p_fct          (i) = (p_ent_fct_t) P_NIL;	/* Entity's entry point */
	}

		/* Initialize the maximum number of Network Access */

	na_nb = I_na_nb;

		/* Congestion management variables init */

	congestion_flag				= 		/* CONGESTION FLAG : ON if an X_OFF has been sent and no X_ON */

#	if MESSAGE_CONG_CONTROL == ON
		message_cong_flag		= 		/* Message congestion flag */
#	endif

#	if BUFFER_CONG_CONTROL == ON
		buffer_cong_flag		= 		/* buffer CONGESTION flag */
#	endif

#	if CPU_CONGESTION == ON
		cpu_cong_flag			= 		/* CPU CONGESTION flag */
#	endif

	congestion_on_flag			= 		/* CONGESTION BUSY message requested */
	congestion_off_flag			= OFF;	/* CONGESTION CLEAR BUSY message requested */

#	if CPU_CONGESTION == ON
		cpu_cong_nb				= 0;	/* reset CPU congestion counter */
#	endif

#	if MESSAGE_CONG_CONTROL == ON
		message_cong_nb			= 0; 	/* reset message congestion counter */
#	endif

#	if BUFFER_CONG_CONTROL == ON
		buffer_cong_nb			= 0;	/* reset buffer congestion counter */
#	endif

		/* Message Audit init */

#	if MESSAGE_AUDIT == ON
		p_msg_audit                 = &msg_audit[0];	/* current index in the msg_audit table */
		nb_audit_bytes_for_msg_data = (ushort)Min ((ushort)(Message_data_lgth + MESSAGE_GAP_SIZE + 2*sizeof (uchar)), MESSAGE_AUDIT_DATA_LGTH);
#	endif

		/* Return code */

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			server_init - implements the initialization of a server.

Usage           uchar server_init (uint qid, uchar *p_entity, ushort fifo_size);
						- qid       : external queue ID of the server,
						- p_entity  : pointer to the entity list,
						- fifo_size : size of the server internal FIFO.

Return value : 	services init returns = OK

Common constants and declarations : services.h

*--------------------------------------------------------------------------*/

uchar server_init (qid, p_server_def)
	uint					 	qid;			/* server queue ID */
	CONST struct server_def	FAR *p_server_def;	/* server definition */
{
	uchar					 	x_server;				/* subscript */

		/* Services init already done ? */

	if (p_server == P_NIL) {
		return (NOK);
	}

	if (qid == QID_NIL) {
		return (NOK);
	}

		/* Lock shared data */

	Lock_resource (sem_server_init);

		/* Add QID to the server list */

		/* Look for a free server control block */

	for (x_server = 0; x_server < server_nb; x_server++) {

		if (Server_qid(x_server) == QID_NIL) {
			Server_qid(x_server) = qid;
			break;
		}

	}

		/* No server control block left ? */

	if (x_server == server_nb) {
		Trap (TRAP_SERVER, "server_init");
	}

		/* Load entities control blocks */

	for ( ; Server_def_entity_id != ENT_NIL; p_server_def++) {

			/* Is the entity id in range ? */

		if ((Server_def_entity_id < ENTITY_ID_MIN) || (Server_def_entity_id > ENTITY_ID_MAX)) {
			Trap (TRAP_ENTITY_ID, "server_init");
		}

			/* Is the entity already described ? */

		if (Entity_to_server (Server_def_entity_id) != SERVER_ENTITY_X_NIL) {
			Trap (TRAP_SERVER_ENTITY, "server_init");
		}

			/* Load the entity control block */

		Entity_to_server     (Server_def_entity_id)	= x_server;
		Entity_congestion_off(Server_def_entity_id) = Server_def_congestion_off;
		Entity_congestion_on (Server_def_entity_id)	= Server_def_congestion_on;
		Entity_p_fct         (Server_def_entity_id)	= Server_def_p_fct;

			/* Set global congestion processing flags */

		congestion_on_flag 	|= Server_def_congestion_on;
		congestion_off_flag |= Server_def_congestion_off;

			/* Call entity's global variables init function if provided */

		if (Server_def_p_init_fct != FCT_NIL) {
			(*Server_def_p_init_fct) ();
		}

	}

		/* Return */

	Unlock_resource (sem_server_init);

	return (OK);
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			read_i_services - implements the reading of the services
				parameters as inititialized.

Usage           ushort read_i_server (struct i_service FAR *p_i_service);
					- p_i_services : pointer on the services structure.

Return value : 	size of the structure

Common constants and declarations : services.h

*--------------------------------------------------------------------------*/

ushort read_i_services (p_i_service)
	struct i_service FAR *p_i_service;
{

		/* Static address initialization */

	I_message_part_add			= part_add;
	I_message_part_lgth			= part_lgth;

		/* Message initialization */

	I_message_lgth				= message_lgth;
	I_message_nb				= message_nb;

#	if MESSAGE_CACHE == ON
		I_message_cache_size	= message_cache_size;

#	else

		I_message_cache_size	= 0;
#	endif

#	if MESSAGE_CONG_CONTROL == ON
		I_message_low_mark		= message_low_mark;
		I_message_high_mark		= message_high_mark;

#	else

		I_message_low_mark		= 0;
		I_message_high_mark		= 0;
#	endif

#	if MESSAGE_AUDIT == ON
		I_message_audit_size	= MESSAGE_AUDIT_SIZE;

#	else

		I_message_audit_size	= 0;
#	endif

		/*  Buffer initialization */

	I_buffer_lgth				= buffer_lgth;
	I_buffer_nb					= buffer_nb;

#	if BUFFER_CACHE == ON
		I_buffer_cache_size		= buffer_cache_size;

#	else

		I_buffer_cache_size		= 0;
#	endif

#	if BUFFER_CONG_CONTROL == ON
		I_buffer_low_mark		= buffer_low_mark;
		I_buffer_high_mark		= buffer_high_mark;

#	else

		I_buffer_low_mark		= 0;
		I_buffer_high_mark		= 0;
#	endif

		/* Timer cell initialization */

	I_timer_cell_nb				= timer_cell_nb;

#	if TIMER_CELL_CACHE == ON
		I_timer_cell_cache_size	= timer_cell_cache_size;

#	else

		I_timer_cell_cache_size	= 0;
#	endif

	I_timer_system_tick			= timer_system_tick;
	I_timer_precision			= timer_precision;
	I_timer_slot_size			= timer_slot_size;

		/* SERVER init */

	I_server_nb					= server_nb;

		/* NETWORK ACCESS init */

	I_na_nb						= na_nb;

#	if ASSERT == ON
		I_performance			= (uchar)performance;
#	else
		I_performance			= ON;
#	endif

		/* Return code */

	return (Rnd_sizeof(struct i_service));
}

/*-------------------------------------------------------------------------*/

					/* CPU LEVEL / EXTERNAL DATA */

uchar	entity_to_server_access(ent_id)
	ent_id_t	ent_id;
{
	if ((ent_id < ENTITY_ID_MIN) || (ent_id > ENTITY_ID_MAX)) {
		return (SERVER_ENTITY_X_NIL);
	}
	return (Entity_to_server (ent_id));
}

/*-------------------------------------------------------------------------*/

uchar	entity_congestion_flag (ent_id, type)
	ent_id_t	ent_id;		/* entity ID */
	uchar		type;		/* ON or OFF */
{

	if ((ent_id < ENTITY_ID_MIN) || (ent_id > ENTITY_ID_MAX)) {
		return (OFF);
	}

		/* Return congestion flag according to requested code ON or OFF */

	if (type == ON) {
		return (Entity_congestion_on (ent_id));

	} else {

		return (Entity_congestion_off (ent_id));
	}

}

/*-------------------------------------------------------------------------*/

ushort	read_buffer_lgth ()
{
	return (buffer_lgth);
}

/*-------------------------------------------------------------------------*/

		/* Message length */

uchar	read_message_lgth ()
{
	return (message_lgth);
}

/*-------------------------------------------------------------------------*/

		/* Number of NA in the system */

nai_t	read_na_nb ()
{
	return (na_nb);
}

/*-------------------------------------------------------------------------*/

		/* Get entity entry point from ent_id */

p_ent_fct_t get_entity_p_fct (ent_id)
	ent_id_t ent_id;
{
	return (Entity_p_fct (ent_id));
}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name			prepare_data_to_send ()

Description     Used to allocate or reuse a message or a buffer,
				according to the needed data size of the user.
				The block is initialized with the needed data size.
				p_data points on the data area of the block or on P_NIL
				if no block is possible.

Usage			void prepare_data_to_send (&p_msg, &p_buffer, data_lgth, &p_data);

					struct message FAR * FAR *a_p_msg	 : pointer to a message (passed by address),
					struct buffer  FAR * FAR *a_p_buffer : pointer to a buffer  (passed by address),
					ushort                   data_lgth   : required data length,
					uchar          FAR * FAR *a_p_data   : pointer to the data area (passed by address)

		- *a_p_msg and *a_p_buffer can either be P_NIL or point to a message/buffer,
		  If one is P_NIL, then a message/buffer is allocated and the pointer
		  is updated;

		- *a_p_data is filled with the address of the data area of the message
		  or the buffer. It is set to P_NIL if no message or no buffer can be
		  allocated.

Return value :	void
				parameters *a_p_msg, *a_p_buffer and *a_p_data are updated

*--------------------------------------------------------------------------*/

void prepare_data_to_send (a_p_msg, a_p_buffer, data_lgth, a_p_data)
	struct message FAR * FAR *a_p_msg;
	struct buffer  FAR * FAR *a_p_buffer;
	ushort                   data_lgth;
	uchar          FAR * FAR *a_p_data;
{
	register struct message FAR *p_msg;		/* local variables */
	register struct buffer  FAR *p_buffer;

	p_msg     = *a_p_msg;
	p_buffer  = *a_p_buffer;

	if (p_msg == P_NIL) {
		p_msg = Alloc_msg ();

	} else {

		L_msg_data_offset	 			= MESSAGE_HEADER_SIZE;
		L_msg_p_buffer	 				= P_NIL;
	}

	if (p_msg != P_NIL) {

		if (data_lgth <= (ushort)Message_data_lgth) {
			*a_p_data					= L_msg_a_first_data;
			L_msg_data_size				= (uchar)data_lgth;

		} else if (data_lgth <= Buffer_data_lgth) {

			if (p_buffer == P_NIL) {
				p_buffer 				= Alloc_buffer ();

			} else {

				Buffer_data_offset		= BUFFER_HEADER_SIZE;
				Buffer_p_next			= P_NIL;
			}

			if (p_buffer != P_NIL) {
				*a_p_data				= Buffer_a_first_data;
				Buffer_data_size 		= data_lgth;
				L_msg_p_buffer			= p_buffer;
				Buffer_link_count 		= 1;

			} else {

				*a_p_data = P_NIL;
				Free_msg (p_msg); p_msg = P_NIL;
			}

		} else {

			Trap (TRAP_BLOCK_DATA_SIZE, "prepare_data_to_send");
		}

	}

	*a_p_msg	= p_msg;
	*a_p_buffer	= p_buffer;

}

/*--------------------------------------------------------------------------*
					 F U N C T I O N   H E A D E R

Name				services_var_init - init of services global variables.

Usage            	void services_var_init ();

Return value :		void

*--------------------------------------------------------------------------*/

void services_var_init ()
{

		/* Message management variables */

	message_nb					= 0;	/* number of message */


}

/*EOF*/
