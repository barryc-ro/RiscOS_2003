
/*--------------------------------------------------------------------------*
 *                       M O D U L E   H E A D E R
 *
 * filename - services.h
 *
 * $Revision$
 *
 * $Date$
 *
 *	Header implementing the	services declarations to all the functions of
 *  the OMNITEL-BRICKS package.
 *
 *-------------------------------------------------------------------------*/

/*[]---------------------------------------------------[]*/
/*|                                                     |*/
/*|    OMNITEL-BRICKS Services                          |*/
/*|                                                     |*/
/*|    Copyright (c) 1989-1997 by OMNITEL SA            |*/
/*|    All Rights Reserved.                             |*/
/*|                                                     |*/
/*[]---------------------------------------------------[]*/

#ifndef SERVICES_H
#define SERVICES_H

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*   GENERAL CONSTANTS   */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

		/* ON / OFF */

#ifndef ON
#	define ON				(1)
#endif
#ifndef OFF
#	define OFF				(0)
#endif

		/* TRUE / FALSE */

#ifndef FALSE
#	define FALSE			(0)
#endif
#ifndef TRUE
#	define TRUE				(1)
#endif

		/* PASS / FAIL */

#ifndef PASS
#	define PASS    			(0)
#endif
#ifndef FAIL
#	define FAIL    			(-1)
#endif

		/* ENABLE / DISABLE */

#ifndef ENABLE
#	define ENABLE  			(1)
#endif
#ifndef DISABLE
#	define DISABLE 			(0)
#endif

		/* OK / not OK */

#ifndef OK
#	define OK				(2)					/* return code : OK */
#endif
#ifndef NOK
#	define NOK				(3)					/* return code : Not OK */
#endif

		/* STOP / CONTINUE */

#ifndef STOP
#	define STOP				(4)					/* return code : nothing more to process */
#endif
#ifndef CONTINUE
#	define CONTINUE			(5)					/* return code : something more to process */
#endif

		/* PRESENT / ABSENT / MISSING */

#ifndef PRESENT
#	define PRESENT			(6)					/* element is present */
#endif
#ifndef ABSENT
#	define ABSENT			(7)					/* element is missing */
#endif
#ifndef MISSING
#	define MISSING			ABSENT				/* alias ABSENT */
#endif

		/* NIL constants */

#define NIL					(0)
#define OFFSET_NIL			(0)					/* null offset */
#define FILE_NIL			(0)					/* NULL file pointer to FILE */
#define FCT_NIL				(0)					/* NULL fonction */
#define QID_NIL				0xFFFF				/* Queue ID NIL */

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*      C COMPILER       */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define TC 					1					/* "tc","tcc" Borland's Turbo C or C++ */
#define BORLANDC			TC					/* "bc","bcc" Borland's C or C++ */
#define IT					2					/* Intermetrics i80x86 */
#define IT68				3					/* "c68000" Intermetrics MC68000 */
#define MSC					4					/* "cl" Microsoft C */
#define LA					5					/* Lattice C */
#define IC86				6					/* "ic86" Intel C compiler */
#define MT68				7					/* "mcc68k" Microtek 68000 compiler (for MS-DOS) */
#define CC					8					/* "cc" Unix C compiler */
#define GCC					9					/* "gcc" GNU Unix C compiler (for SUN machines) */
#define C_TMS320			10  				/* "dspcl" Texas Instruments TMS320Cx C compiler */
#define CCA_HP				11					/* "cc" Unix CC ANSI compiler (for HP machines) */
#define CC68				12					/* "cc68000" 68000 C Cross Compiler (for HP64000 machines) */
#define HC29K				13					/* "hc29k" AMD 29000 High C 29 K */
#define ULTRAC				14					/* MicroWare Ultra C */
#define GNU68				15					/* GNU 68xxx */
#define C_TI_MVP			16					/* "mpcl" and "ppcl" Texas Instruments TMS320Cx-MVP C compilers */
#define ACC_SPARC			17					/* "acc" ANSI C compiler for SUN SPARC stations */
#define MT68_SPARC			18					/* "mcc68k" Microtek 68000 compiler (for SUN SPARC) */
#define HIGHC				19					/* "hc386" MetaWare High-C Compiler for Intel 32-bit */
#define IC960CA				20					/* Intel "C" ic960CA / CF compiler */
#define CC_DIAB				21					/* Diab "dcc" compiler */
#define ACORN_CC			22					/* "ACORN CC"  Compiler for Acorn computers */
#define SDS68K				23					/* SDS 68K CrossCode Compiler 7.0 (Software Development Systems) */
#define CC_WATCOM_TNT       24                  /* "Watcom" compiler  used in conjunction with PHAR LAP TNT DOS extender */
#define CC_WATCOM           25                  /* "Watcom" compiler  */
#define JPS_THUMB_CC		26					/* Jumpstart Cross Compiler 3.1 for Thumb generation (VLSI) */

#define CC_ANSI				254					/* Standard ANSI C */

#define COMPILER_UNDEFINED	255					/* undefined compiler */

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*    OPERATING SYSTEM   */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define MS_DOS				1					/* MS/DOS */
#define VRTX				2					/* VRTX */
#define UNIX				3					/* Unix */
#define PSOS				4					/* PSOS 68K */
#define PSOS68K				PSOS				/* Alias */
/*      PSOS86				defined below		   PSOS iapx 86 */
#define PSOS_PLUS			5					/* PSOS+ */

	/* Conditionally define OS2 due to conflicts with IBM C/Set++ compiler */

#ifndef OS2
#define OS2					6					/* OS2 */
#endif

#define RTC86				7					/* Real Time Craft iapx 86 */
#define AMX					8					/* AMX iapx 86 */
#define KOS					9					/* K. OS */
#define MTR86				10					/* MTR iapx 86 */
#define WINDOWS_NT			11					/* MS WINDOWS NT */
#define OS_IOPOS			12					/* IOPOS OS */
#define IMECOM_OS			13					/* I. OS */
#define SCEPTRE				14					/* SCEPTRE OS */
#define VXWORKS				15					/* VxWorks */
#define LYNXOS				16					/* LynxOs */
#define CHORUS				17					/* Chorus micro kernel */
#define OS9					18					/* OS 9 */
#define MVP_ME				19					/* Texas MVP Multitasking Executive */
#define OSE_OS68            20                  /* OSE CLASSIC 68000 from ENEA DATA */
#define MS_WINDOWS			21					/* MS/DOS WINDOWS 3.x */
#define WINDOWS_95			22					/* MS WINDOWS 95 */
#define RISC_OS				23					/* Acorn RiscOS */
#define PSOS86				24					/* PSOS for iapx 86 */
#define RTEMS				25					/* RTEMS */
#define	NUCLEUS_PLUS		26					/* Accelerate Technology NUCLEUS PLUS */

#define OMNITEL_OS			254					/* built-in Omnitel scheduler */
#define OS_PRIVATE			255					/* private OS */

				/*-------------*/
				/* OS releases */
				/*-------------*/

				/* AMX OS releases */

#define I86_V2				1					/* AMX 86 v2.xx */
#define I86_V3				2					/* AMX 86 v3.xx */
#define MC68000_V2			3					/* AMX 68000 v2.xx */
#define MC68000_V3			4					/* AMX 68000 v3.xx */
#define I386_V1				5					/* AMX 386 v1.xx */

				/* VXWORKS OS releases */

#define VXWORKS_5_0 		1					/* VXWORKS 5.0 */
#define VXWORKS_5_1 		2					/* VXWORKS 5.1 */

				/* RISC_OS OS releases */

#define RISCOS_3_5			1					/* RiscOS 3.5 */
#define RISCOS_3_6			2					/* RiscOS 3.6 */
#define RISCOS_3_7			3					/* RiscOS 3.7 */

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*      TARGET  CPU      */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

					/* MOTOROLA family */

#define MOTOROLA_1			681					/* Motorola 68000/10/20 : byte aligment */
#define MOTOROLA_2			682					/* Motorola 68000/10/20/30/40 family : word alignment */
#define MOTOROLA_4			684					/* Motorola 68040 family : double word alignment */

#define MC68000				1					/* Motorola 68000 */
#define MC68010				2					/* Motorola 68010 */
#define MC68020				3					/* Motorola 68020 */
#define MC68030				4					/* Motorola 68030 */
#define MC68040				5					/* Motorola 68040 */
#define CPU32				8					/* Motorola CPU32 */

#define MC680X0				9					/* Motorola 680XXX family */

#define MC68302				302					/* Motorola 68302 */
#define MC68360				360					/* Motorola 68360 */

					/* INTEL family */

#define INTEL_1				801					/* Intel IAPX family byte alignment */
#define INTEL_2				802					/* Intel IAPX family word alignment */
#define INTEL_4				804					/* Intel IAPX family dword alignment */
#define INTEL_8				808					/* Intel IAPX family quad-word alignment */

#define I80188				188					/* Intel 80188 */
#define I80186				186					/* Intel 80186 */
#define I80286				286                 /* Intel 80286 */
#define I80386				386                 /* Intel 80386 */
#define I80486				486                 /* Intel 80486 */
#define PENTIUM				586                 /* Intel PENTIUM */

#define I80XXX				86					/* Intel I80XX family */
#define I86_16				87					/* Intel I86 family - 16-bit */
#define I86_32				88					/* Intel I86 family - 32-bit */

#define	I960				20					/* Intel 960 */

#define	I960CA				21					/* Intel 960 */
#define	I960KA				22					/* Intel 960 */
#define	I960KB				23					/* Intel 960 */

					/* SPARC family */

#define SPARC				10					/* SPARC */

					/* AMD29000 family */

#define AMD29000			30					/* AMD 29000 : double word alignment */

					/* HP-PA RISC family */

#define HP_PA_2				40					/* HP PA risc CPU : word alignment */
#define HP_PA_4				41					/* HP PA risc CPU : double word alignment */

					/* Texas-Instruments family */

#define TMS320				50					/* DSP Texas Instruments TMS320Cx */
#define TI_MVP				51					/* MVP single-chip multiprocessor device */

					/* ARM family */

#define ARM_600				62					/* ARM 600 cpu core */
#define ARM_700				63					/* ARM 700 cpu core */
#define ARM_7500			64					/* ARM 7500 cpu core */
#define ARM_SA				65					/* StrongARM cpu core */

					/* Other CPUs */

#define CPU_PRIVATE			1000				/* private CPU */
#define CPU_private			1000				/* private CPU */


				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*      CODE TYPE        */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define OM_RELOCATABLE		1					/* Relocatable Code */
#define OM_PIC				2					/* Position Independant Code */

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*      OPTIMIZATION     */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define	SPEED				1					/* speed */
#define SIZE                2					/* memory size */
#define MIXED				3					/* mixed speed and size */

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*       EQUIPMENT       */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define TE					1					/* terminal */
#define NT1					2					/* network termination 1 */
#define NT2					3					/* network termination 2 */
#define LT					4					/* line termination */
#define	AN					5					/* Access Network */
#define LE					6					/* Local Exchange */
#define NT1_PLUS			7					/* NT1+ (Smart NT1) */

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*   NETWORK OPERATORS   */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define FT_VN2				1					/* France Telecom VN2 */
#define FT_VN3				2					/* France Telecom VN3 */
#define FT_VN4				FT_VN6				/* Now obsolete */
#define FT_VN6				3					/* France Telecom VN6 */
#define DT_1TR6				4					/* Deutsche Telekom 1TR6 */
#define BT_ISDN2			5					/* British Telecom ISDN2 */
#define ATT_5E5				6					/* AT&T 5ESS5 */
#define ATT_5E9				7					/* AT&T 5ESS9 */
#define NT_DMS100			8					/* Northern Telecom DMS100 */
#define NTT					9					/* Nippon Telegraph Telephone */
#define KDD					10					/* Kokusai Denshin Denwa */
#define ETSI				11					/* European ETSI Technical Comittee */
#define BG_V1				12					/* Belgian V1 */
#define N_ISDN1				13					/* US National ISDN 1 */
#define SWD_TVKT			14					/* Sweedish Televerket */
#define AUSTEL_1			15					/* Australian Telecom 1 */
#define	ECMA_QSIG			16					/* ECMA 143 QSIG */
#define	HK_TEL				17					/* Hong Kong Telephone */
#define DRV					18					/* DRV */
#define BELLCORE_PRI        19                  /* Bellecore, ISDN Primary rate interface, TR-NWT-001268, Issue 1 dec 91*/
#define N_ISDN2				20					/* US National ISDN 2 */
#define CTU_CDS				21					/* ARINC CTU to zone units CDS - ARINC 746 attachment 17 */
#define CTU_BS				22					/* ARINC CTU to Bearer Systems (BS) -  ARINC 746 attachment 11 */
#define ATT_5E10			23					/* ARINC CTU to Bearer Systems (BS) -  ARINC 746 attachment 11 */
#define ATT_4ESS			24					/* AT&T 4ESS (AT&T TR41459, August 1995) */

#define	MX_OPERATOR_NB		25					/* equals greater 'network index' + 1 */

		/* (Aliases representing filename extensions) */

#define VN2					FT_VN2
#define VN3					FT_VN3
#define VN4					VN6
#define VN6					FT_VN6
#define	EURO_NUMERIS		FT_VN6
#define TR6					DT_1TR6
#define BT2					BT_ISDN2
#define AT4					ATT_4ESS
#define AT5					ATT_5E5
#define AT9					ATT_5E9
#define E10					ATT_5E10
#define DMS					NT_DMS100
#define ETS					ETSI
#define BV1					BG_V1
#define NI1					N_ISDN1
#define NI2					N_ISDN2
#define SWD					SWD_TVKT
#define AU1					AUSTEL_1
#define	QSI					ECMA_QSIG
#define	HKT					HK_TEL
#define BIP					BELLCORE_PRI
#define	A17					CTU_CDS
#define	A11					CTU_BS

	/* V5 adaptation */

#define V5_ITU				1					/* V5 ITU */
#define V5_MX_OPERATOR_NB	2					/* equals greater 'network index' + 1 */

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*						 */
				/*	ATM SPECIFICATIONS	 */
				/*						 */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define	ATM_FORUM_3_0		1
#define	ITU_Q2931			2
#define	ATM_FORUM_3_1		3
#define	ATM_FORUM_4_0		4
#define	ATM_FORUM_P_NNI_1_0	5

#define	MX_ATM_VERSIONS		6

		/* (Aliases representing filename extensions) */

#define	FRM					ATM_FORUM_3_0
#define	ITU                 ITU_Q2931
#define	F31					ATM_FORUM_3_1
#define	F40					ATM_FORUM_4_0
#define	N10					ATM_FORUM_P_NNI_1_0

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*     COUNTRY CODES     */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define	AUSTRALIA			61
#define	AUSTRIA				43
#define	BELGIUM				32
#define	CANADA				1
#define	DENMARK				45
#define EUROPE				1000
#define	FINLAND				358
#define	FRANCE				33
#define	GERMANY				49
#define	HONG_KONG			852
#define	INDIA				91
#define	IRLANDE				353
#define	ITALY				39
#define	JAPAN				81
#define	KOREA				82
#define	LUXEMBOURG			352
#define	NETHERLANDS			31
#define	NEW_ZEALAND			64
#define	NORWAY				47
#define	PORTUGAL			351
#define	SOUTH_AFRICA		27
#define	SPAIN				34
#define	SWEDEN				46
#define	SWITZERLAND			41
#define	UK					44
#define	USA					1
#define	USSR				7
#define COUNTRY_NIL			9999

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*     NETWORK ACCESS    */
				/*       INTERFACE       */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/


#define BRI					1					/* 2**0 basic rate interface (S0) */
#define PRI					2					/* 2**1 primary rate interface (S2) */

#define SCI					4					/* Single Channel Interface */
#define NMI					4					/* Non Multiplexed Interface */
#define SCI_HDTM			8					/* SCI and Half duplex transmission mode */

#define PRI_MULTI_D			16					/* multi D-channel primary rate interface (S2) */

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  FUNCTIONAL GROUPING  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

/*
					 TE                S             NT1             U        ISDN
				----------------				----------------           --------------
				|              |       |        |              |     |     |            |
				|  FG_TE_NET   |-------|--------|              |-----|-----|  FG_LT_NT  |
				|              |       |        |              |     |     |            |
				----------------                ----------------           --------------

					  User <======================>  Network



				TE			S			   NT2             T        NT1         U       ISDN
		----------------		 ------------------------      --------------       --------------
		|              |    |    |          |           |  |   |            |   |   |            |
		|  FG_TE_NT    |----|----| FG_NT_TE | FG_NT_NET |--|---|            |---|---|   FG_LT_NT |
		|              |    |    |          |           |  |   |            |   |   |            |
		----------------         ------------------------      --------------       --------------

			  User <=============>  Network	|  User <============>  Network

*/

#define FG_TE_NET			1					/* TE connected to the public network */
#define FG_TE				FG_TE_NET			/* TE connected to the public network */
#define FG_TE_NT			2					/* TE connected to an NT2 */

#define FG_NT_NET			4					/* NT2 network side */
#define FG_NT_TE			8					/* NT2 terminal side */
#define FG_NET				FG_NT_TE			/* NET to TE - network side */

#define FG_LT_NT			16					/* Line termination */

#define FG_NIL				((uchar)(~0))		/* Non-ISDN function */


/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*    SERVICES OPTIONS   */
				/*     AND PARAMETERS    */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#include "serv_par.h"

#ifndef OM_CPU
#	define OM_CPU	CPU		/* define OM_CPU to older CPU if not defined in 'serv_par.h' */
#endif

#if	(OM_CPU == MOTOROLA_1) || (OM_CPU == MC68000) || (OM_CPU == MC68010)
#	define	OM_CPU_FAMILY	MC680X0
#	undef	OM_CPU
#	define	OM_CPU			MOTOROLA_1
#endif

#if	(OM_CPU == MOTOROLA_2) || (OM_CPU == MC68020) || (OM_CPU == MC68030) || (OM_CPU == MC68040) || (OM_CPU == MC68302) || (OM_CPU == CPU32) || (OM_CPU == MC68360)
#	define	OM_CPU_FAMILY	MC680X0
#	undef	OM_CPU
#	define	OM_CPU			MOTOROLA_2
#endif

#if	(OM_CPU == MOTOROLA_4)
#	define	OM_CPU_FAMILY	MC680X0
#	undef	OM_CPU
#	define	OM_CPU			MOTOROLA_4
#endif

#if (OM_CPU == INTEL_4) || (OM_CPU == INTEL_8)
#	define	OM_CPU_FAMILY	I86_32
#endif

#if (OM_CPU == I80186) || (OM_CPU == I80286) || (OM_CPU == I80386) || (OM_CPU == I80486) || (OM_CPU == PENTIUM)
#	define	OM_CPU_FAMILY	I80XXX
#	undef	OM_CPU
#	define	OM_CPU			INTEL_2
#endif

#if (OM_CPU == INTEL_1) || (OM_CPU == INTEL_2)
#	define	OM_CPU_FAMILY	I80XXX
#endif

#if (OM_CPU == I80188)
#	define	OM_CPU_FAMILY	I80XXX
#	undef	OM_CPU
#	define	OM_CPU			INTEL_1
#endif

#if	(OM_CPU == I960KB) || (OM_CPU == I960CA) || (OM_CPU == I960)
#	define 	OM_CPU_FAMILY	I960
#endif

#ifndef OM_CPU_FAMILY
#	define 	OM_CPU_FAMILY	OM_CPU
#endif

/*-------------*/

#if OS == OSE_OS68
#	undef	MC68040			/* to avoid conflict in 'ose.h' */
#   define  OSE_OMNITEL_SIGNAL  0x02
#endif

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*   PIC-related macros  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#ifndef OM_CODE_TYPE
#	define OM_CODE_TYPE		OM_RELOCATABLE		/* default is "relocatable code" */
#endif

	/*----*/

#if OM_CODE_TYPE == OM_PIC

#   define Pic_index		i_pic

#   define Pic_init_index()	uchar Pic_index = 0

#   define Pic_init_array(array_name, val_name) \
		array_name[Pic_index++] = val_name

#   define Pic_init_struct(struct_name, field_name, val_name) \
		struct_name.field_name = val_name

#   define Pic_init_struct_array(array_name, i, field_name, val_name) \
		array_name[i].field_name = val_name

#   define Pic_init_struct_array_next(array_name, field_name, val_name) \
		array_name[Pic_index++].field_name = val_name

#	define Pic_address(add)	A_NIL

#else

#   define Pic_index
#   define Pic_init_index()
#   define Pic_init_array(array_name, val_name)
#   define Pic_init_struct(struct_name, field_name, val_name)
#   define Pic_init_struct_array(array_name, i, field_name, val_name)
#   define Pic_init_struct_array_next(array_name, field_name, val_name)
#	define Pic_address(add)	add

#endif

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*      RANDOM INIT      */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#if SIMULATION == ON
#	define	RANDOM_INIT		0

#else

#	define	RANDOM_INIT		(long)(9734 * System_time()) /* random init */
#endif

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  ADDRESSING CONSTANTS */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

					/* NIL ADDRESS */

#define NAI_NIL				((nai_t)~0)
#define SAPI_NIL			((sapi_t)~0)
#define ADD_NIL				((add_t)~0)
#define CONN_ID_NIL			0

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*    SOFTWARE TOOLS     */
				/*       CPU - OS        */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

			/*-----------------------------*/
			/* COMPILER-related parameters */
			/*-----------------------------*/

				/*
					InterTools (Intermetrics) iapx80XXX "C"
					compiler facilities.

					It is strongly recommanded to use a "C" preprocessor
					like CPP before calling the Intertools compiler.
				*/

#if OM_CODE_TYPE == OM_PIC
#	define PIC_CONST							/* PIC code: no constant */
#	define PIC_CONST_ARRAY						/* PIC code: no constant array */
#else
#	define PIC_CONST		CONST				/* Relocatable code: keep same definition */
#	define PIC_CONST_ARRAY	CONST_ARRAY			/* Relocatable code: keep same definition */
#endif

#if C_COMPILER == IT
#	define FAR									/* no FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST								/* no constant (external pb) */
#	define CONST_ARRAY							/* no constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE								/* concurrent access to memory */
#	define VOID_POINTER		OFF					/* void pointer */
#endif

				/* InterTools (Intermetrics) 68000 compiler facilities. */

#if C_COMPILER == IT68
#	define FAR									/* no FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory */
#	define VOID_POINTER		OFF					/* void pointer */
#endif

				/* Turbo C and TC++ iapx80xxx (Borland) facilities */

#if C_COMPILER == TC
#	if (OS != MS_WINDOWS) && (OS != WINDOWS_NT) && (OS != WINDOWS_95)
#	define FAR				far					/* far pointer */
#	endif
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	ON					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* Microsoft "C" iapx80xxx facilities */

#if C_COMPILER == MSC
#	define FAR				far					/* far pointer */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	ON					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory */
#	define VOID_POINTER		ON					/* void pointer */
#	define Bound			int bound;			/* force structure alignment */
#endif

				/* Lattice "C" compiler facilities */

#if C_COMPILER == LA
#	define FAR									/* no FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory */
#	define VOID_POINTER		OFF					/* void pointer */
#endif

				/* Intel "C" iapx80xxx compiler */

#if C_COMPILER == IC86
#	define FAR				far					/* far pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	ON					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		OFF					/* open console not possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* Microtec  MCC68K "C" compiler  */

#if C_COMPILER == MT68
#	define FAR									/* no FAR pointer (68k) */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* UNIX "C" compiler : CC (SPARC, AMD29000) */

#if C_COMPILER == CC
#	define FAR									/* no FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST								/* no constant */
#	define CONST_ARRAY							/* no constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		OFF					/* open console not possible = stdin and sdtout */
#	define PASTE			OFF					/* paste with # not allowed, paste using comment */
#	define STRINGIZING		OFF					/* # in literal string not allowed */
#	define VOLATILE								/* concurrent access to memory : OFF */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* HP UNIX "C" ANSI compiler : CC */

#if C_COMPILER == CCA_HP
#	define FAR									/* no FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
												/* WARNING: '-Aa' option must be set */
#	define CONST								/* no constant */
#	define CONST_ARRAY							/* no constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		OFF					/* open console not possible = stdin and sdtout */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE								/* concurrent access to memory : OFF */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* UNIX "C" compiler : GCC (MOTOROLA) */

#if C_COMPILER == GCC
#	define FAR									/* no FAR pointer */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST								/* no constant */
#	define CONST_ARRAY							/* no constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		OFF					/* open console not possible = stdin and sdtout */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		OFF					/* # in literal string not allowed */
#	define VOLATILE								/* concurrent access to memory : OFF */
#	define VOID_POINTER		OFF					/* void pointer */
#endif

				/* Texas Istruments TMS320Cx "C" compiler */

#if C_COMPILER == C_TMS320
#	define FAR									/* no far pointer */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	ON					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE								/* concurrent access to memory : OFF */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* 68000 "C" Cross Compiler (for MOTOROLA on HP) */

#if C_COMPILER == CC68
#	define FAR									/* no FAR pointer (68k) */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* AMD 29000 High C 29 K Compiler */

#if C_COMPILER == HC29K
#	define FAR									/* no FAR pointer (AMD29000) */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		OFF					/* open console not possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		OFF					/* # in literal string not allowed */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* MicroWare Ultra "C" compiler  */

#if C_COMPILER == ULTRAC
#	define FAR									/* no FAR pointer (68k) */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* GNU 68xxx "C" compiler  */

#if C_COMPILER == GNU68
#	define FAR			    					/* No FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* Texas MVP "C" compiler  */

#if C_COMPILER == C_TI_MVP
#	define FAR			    					/* No FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE								/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* "acc" ANSI C compiler for SUN SPARC stations */

#if C_COMPILER == ACC_SPARC
#	define FAR			    					/* No FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		OFF					/* open console not possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		OFF					/* # in literal string not allowed */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* "mcc68k" Microtek 68000 compiler (for SUN SPARC) */

#if C_COMPILER == MT68_SPARC
#	define FAR			    					/* No FAR pointer */
#	define NEW_FCT_STYLE   	OFF					/* old style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console not possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string not allowed */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* "hc386" Metaware High-C compiler for Intel 32-bit */

#if C_COMPILER == HIGHC
#	ifdef FAR
#	undef FAR
#	endif
#	define FAR			    					/* No FAR pointer */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console not possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string not allowed */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* Intel "C" ic960CA / CF compiler */

#if C_COMPILER == IC960CA
#	define FAR									/* No far pointer */
#	define NEW_FCT_STYLE	OFF					/* old style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#	define Bound			int bound;			/* force structure alignment */
#endif

				/* Diab "dcc" compiler */

#if C_COMPILER == CC_DIAB
#	define FAR			    					/* No FAR pointer */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST								/* No constant */
#	define CONST_ARRAY							/* No constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* Acorn "C" compiler  */

#if C_COMPILER == ACORN_CC
#	define FAR									/* No FAR pointer */
#	define NEW_FCT_STYLE	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* SDS 68K CrossCode Compiler 7.0 (Software Development Systems) */

#if C_COMPILER == SDS68K
#	define FAR									/* no FAR pointer (68k) */
#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* WATCOM compiler used in conjunction with PHARLAP TNT dos extender */

#if C_COMPILER == CC_WATCOM_TNT
#   define FAR                                  /* far pointer */
#   define NEW_FCT_STYLE    ON                  /* new style function declaration */
#   define CONST            const               /* constant */
#   define CONST_ARRAY      const               /* constant array */
#   define ASSIGN_CONSTANT  ON                  /* assign a pointer to a constant item of an array */
#   define OPEN_CONSOLE     ON                  /* open console possible */
#   define PASTE            ON                  /* paste with ## */
#   define STRINGIZING      ON                  /* # in literal string */
#   define VOLATILE         volatile            /* concurrent access to memory */
#   define VOID_POINTER     ON                  /* void pointer */
#endif

				/* WATCOM compiler (for INTEL) */

#if C_COMPILER == CC_WATCOM
#   define FAR              far                 /* far pointer */
#   define NEW_FCT_STYLE    ON                  /* new style function declaration */
#   define CONST            const               /* constant */
#   define CONST_ARRAY      const       		/* constant array */
#   define ASSIGN_CONSTANT  ON                  /* assign a pointer to a constant item of an array */
#   define OPEN_CONSOLE     ON                  /* open console possible */
#   define PASTE            ON                  /* paste with ## */
#   define STRINGIZING      ON                  /* # in literal string */
#   define VOLATILE         volatile            /* concurrent access to memory */
#   define VOID_POINTER     ON                  /* void pointer */
#endif

				/* VLSI Jumpstart Thumb "C" compiler  */

#if C_COMPILER == JPS_THUMB_CC
#	define FAR									/* No FAR pointer */
#	define NEW_FCT_STYLE	OFF					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

				/* ANSI "C" compiler */

#if C_COMPILER == CC_ANSI

#	if OM_CPU_FAMILY == INTEL_80XXX
#		define FAR			far					/* FAR pointer */
#	else
#		define FAR			    				/* No FAR pointer */
#	endif

#	define NEW_FCT_STYLE   	ON					/* new style function declaration */
#	define CONST			const				/* constant */
#	define CONST_ARRAY		const				/* constant array */
#	define ASSIGN_CONSTANT	OFF					/* assign a pointer to a constant item of an array */
#	define OPEN_CONSOLE		ON					/* open console possible */
#	define PASTE			ON					/* paste with ## */
#	define STRINGIZING		ON					/* # in literal string */
#	define VOLATILE			volatile			/* concurrent access to memory : ON */
#	define VOID_POINTER		ON					/* void pointer */
#endif

			/*-----------------------------*/
			/*   CPU-related parameters    */
			/*-----------------------------*/

#ifndef ALIGNMENT

					/* MOTOROLA */

#if OM_CPU == MOTOROLA_1
#	define	ALIGNMENT		1					/* byte align */
#endif

#if OM_CPU == MOTOROLA_2
#	define	ALIGNMENT		2					/* word align */
#endif

#if OM_CPU == MOTOROLA_4
#	define	ALIGNMENT		4					/* double word align */
#endif

					/* SPARC */

#if OM_CPU == SPARC
#	define	ALIGNMENT		4					/* double word align */
#endif

					/* HP_PA */

#if OM_CPU == HP_PA_2
#	define	ALIGNMENT		2					/* word align */
#endif

#if OM_CPU == HP_PA_4
#	define	ALIGNMENT		4					/* double word align */
#endif

					/* AMD 29000 */

#if OM_CPU == AMD29000
#	define	ALIGNMENT		4					/* double word align */
#endif

					/* INTEL */

#if OM_CPU == INTEL_1
#	define	ALIGNMENT		1					/* byte align */
#endif

#if OM_CPU == INTEL_2
#	define	ALIGNMENT		2					/* word align */
#endif

#if OM_CPU == INTEL_4
#	define	ALIGNMENT		4					/* dword align */
#endif

#if OM_CPU == INTEL_8
#	define	ALIGNMENT		8					/* quad-word align */
#endif

					/* TMS320Cx */

#if OM_CPU == TMS320
#	define	ALIGNMENT		1					/* 16bits align */
#endif

					/* Texas MVP */

#if OM_CPU == TI_MVP
#	define	ALIGNMENT		4					/* 32 bits align */
#endif

					/* ARM CPUs */

#if OM_CPU == ARM_600
#	define	ALIGNMENT		4					/* 32 bits align */
#endif

#if OM_CPU == ARM_700
#	define	ALIGNMENT		4					/* 32 bits align */
#endif

#if OM_CPU == ARM_7500
#	define	ALIGNMENT		4					/* 32 bits align */
#endif

#if OM_CPU == ARM_SA
#	define	ALIGNMENT		4					/* 32 bits align */
#endif

#endif

			/*-----------------------------*/
			/*    OS-related parameters    */
			/*-----------------------------*/

#if (OS == WINDOWS_NT) || (OS == WINDOWS_95) || (OS == IMECOM_OS) || (OS == RISC_OS)

#	define BEGIN_WITH_MSG				ON

#else

#	if OS == AMX

#		if (OS_RELEASE != MC68000_V3)
#			define BEGIN_WITH_MSG		ON
#		endif
#		if (OS_RELEASE == MC68000_V3)
#			define BEGIN_WITH_MSG		OFF
#		endif

#	else
#		define BEGIN_WITH_MSG			OFF
#	endif

#endif

#if (OS == MS_WINDOWS) || (OS == WINDOWS_NT) || (OS == WINDOWS_95)
#	define	WM_USER_OMNITEL 	(WM_USER + 1)		/* WINDOWS MESSAGE FOR OMNITEL */
#endif

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*      NULL POINTERS    */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#if VOID_POINTER == ON
#	define P_NIL			((void FAR *)(0))	/* null pointer */
#	define A_NIL			((void FAR *)(0))	/* null address */

#else

#	define P_NIL			0L
#	define A_NIL			0L
#endif

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                         */
				/* COMMON FUNCTIONS MACROS */
				/*                         */
				/*-=-=-=-=-=-=-=-=-=-=-=-=-*/

#include "serv_por.h"

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*     GENERAL MACROS    */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Insert revision strings into source files or not */

#if REVISION_STRING == ON
#	define Revision_string(var,str) char CONST_ARRAY var[] = str;
#else
#	define Revision_string(var,str)
#endif

#ifdef SERVICES_INCLUDE_REV
	Revision_string (services_h_rev, "SERVICES.H $Revision$");
#endif
				/* Shorter form of unsigned char, short, long */

typedef unsigned 		char 	uchar;			/* unsigned char */

#if (OS != UNIX) || (!defined (__sys_types_h) && !defined (_SYS_TYPES_H))
	typedef unsigned 	int 	uint;			/* unsigned integer */

#	ifndef __INCvxTypesOldh
#		if (OS != RISC_OS) || !defined (_TYPES_)
			typedef unsigned 	short 	ushort;	/* unsigned short */
#		endif
#	endif

#endif

#if (OS != UNIX) || !defined (_SYS_TYPES_H)
	typedef unsigned 	long 	ulong;			/* unsigned long */
#endif

				/*
				   G_x : generate a value according to a bit pattern
						 bit are set left to right
						 if necessary they can be set rigth to left.
				*/

#define G_1(b1) (uchar)b1

#define G_2(b2,b1) (uchar)((b2<<1)+b1)

#define G_3(b3,b2,b1) (uchar)((((b3<<1)+b2)<<1)+b1)

#define G_4(b4,b3,b2,b1) (uchar)((((((b4<<1)+b3)<<1)+b2)<<1)+b1)

#define G_5(b5,b4,b3,b2,b1) (uchar)((((((((b5<<1)+b4)<<1)+b3)<<1)+b2)<<1)+b1)

#define G_6(b6,b5,b4,b3,b2,b1) (uchar)((((((((((b6<<1)+b5)<<1)+b4)<<1)+b3)<<1)+b2)\
							   <<1)+b1)

#define G_7(b7,b6,b5,b4,b3,b2,b1) (uchar)((((((((((((b7<<1)+b6)<<1)+b5)<<1)+b4)\
								  <<1)+b3)<<1)+b2)<<1)+b1)

#define G_8(b8,b7,b6,b5,b4,b3,b2,b1) (uchar)((((((((((((((b8<<1)+b7)<<1)+b6)<<1)\
									 +b5)<<1)+b4)<<1)+b3)<<1)+b2)<<1)+b1)

			/* Bits manipulation macros */

#if C_COMPILER == C_TMS320

		/* To avoid Mask(16) == Mask(0), but doesn't work with long words! */

#	define Mask(xx)						(((xx)>15) ? (~0) : (~((~0) << (xx))))/* mask of xx 1 : (000111111...1111) */

#else

#	define Mask(xx)						(~((~0) << (xx)))					/* mask of xx 1 : (000111111...1111) */
#endif

#define Setbit(flag, mask)				((flag) |= (mask))					/* set some bits according to mask */
#define Unsetbit(flag, mask)			((flag) &= ~(mask))					/* clear bit (s) according to mask */
#define Isonebit(flag, mask)			((flag) & (mask))					/* true if one bit of the mask is to 1 */
#define Isallbits(flag, mask)			(((flag) & (mask)) == (mask)) 		/* true if all bits of the mask = 1 */
#define Setnumbit(integer, numbit)		Setbit   (integer, 1 << (numbit))   /* set one bit at range numbit */
#define Unsetnumbit(integer, numbit)	Unsetbit (integer, 1 << (numbit))	/* clear one bit at range numbit */
#define Isnumbit(integer, numbit)		Isonebit (integer, 1 << (numbit))	/* test one bit at range numbit */

#define Get_bits(integer, p, l)			(((integer) >> (p))& Mask (l))

			/* Bit field manipulation macros */

			/*
				The bit field is defined by two values :

					. NAME_P : position of the bit field in the value
							   starting from 0,
					. NAME_L : length of the bit field.

				- Sfi 			: Set field initial value : field name and value,
				- Mf  			: modify bit field value  : value, field name, value,
				- Mask_field 	: mask of the field       : field name
				- Gf            : load a field value      : value, field name

			*/

#define Sfi(field_name,field_val)			((field_val) << Paste (field_name,_P))
#define Mf(val,field_name,field_val)		(((val) & (~Mask_field (field_name))) | Sfi (field_name, field_val))
#define Mask_field(field_name)   			(Mask(Paste (field_name,_L)) << Paste (field_name,_P))
#define Gf(val,field_name)					Get_bits (val, Paste (field_name,_P), Paste (field_name,_L))

			/* Alias */

#define Get_field(val,field_name)				Gf(val,field_name)
#define Modify_field(val,field_name,field_val)	Mf(val,field_name,field_val)
#define Set_field_initial(field_name,field_val)	Sfi(field_name,field_val)

			/* Default value : if val is null set default value */

#define Set_default(val, val_default)	((val == 0) ? val_default : val)

			/* Paste two Id's */

#if PASTE == ON
#	define Paste(A,B)			A##B
#	define Paste3(A,B,C)		A##B##C

#else

#	define Paste(A,B)			A/**/B
#	define Paste3(A,B,C)		A/**/B/**/C
#endif

			/* Structure field offset and size */

#define	Offsetof(str, fld)		(ushort)((ulong)(&(((struct str *) 0) -> fld)))
#define Fldsiz(str, fld)		(sizeof (((struct str *) 0) -> fld)

			/* Min and Max */

#ifdef _HIGHC_
#	define Min(a, b)			_min (a, b)
#	define Max(a, b)			_max (a, b)

#else

#	define Min(a, b)			((a) < (b) ? (a) : (b))
#	define Max(a, b)			((a) > (b) ? (a) : (b))
#endif

			/* Roundxxx() macros */

#define Round2(val)				(((val) + 1)  & ~1)
#define Round4(val)				(((val) + 3)  & ~3)
#define Round8(val)				(((val) + 7)  & ~7)
#define Round16(val)			(((val) + 15) & ~15)

			/* Round() macro */

#if ALIGNMENT == 1
#	define Round(x)				(x)
#endif

#if ALIGNMENT == 2
#	define Round(x)				Round2 (x)
#endif

#if ALIGNMENT == 4
#	define Round(x)				Round4 (x)
#endif

#if ALIGNMENT == 8
#	define Round(x)				Round8 (x)
#endif

			/* Rounded 'sizeof' */

#define Rnd_sizeof(type)		(Round (sizeof (type)))

			/* size of a table */

#define Sizeof_table(t)			(sizeof (t) / sizeof (t[0]))

			/* Padding for structure and data alignment */

#ifndef Bound
#	if ALIGNMENT == 1
#		define Bound
#	else
#		define Bound			unsigned :0;
#	endif
#endif

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  SERVICES TRAP CODES  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

	/*
	   TRAP code : trap function is called if and inconsistancy
				   is detected inside the sofware, generally due
				   to a bug. Trap function must freeze the
				   situation and dump it to some permanent support
				   in order to fix the bug.
	*/

#define TRAP_OS						1000		/* OS-related Trap codes base */

	/* Services Trap codes */

#define TRAP_BUFFER_SIZE			1			/* no buffer size for sending init message */
#define TRAP_INTERNAL_FIFO			2			/* internal FIFO saturation */
#define TRAP_TI_CODE				3			/* abnormal code in message coming from TIMER */
#define TRAP_FROM					4			/* abnormal from value in message */
#define TRAP_TIMER_ALLOC			5			/* timer alloc malloc return NULL */
#define TRAP_UNKNOWN_ENTITY			6			/* entity ID unknown */
#define TRAP_NOT_IMPLEMENTED_ENTITY 7			/* the current server don't implement the dest entity */
#define TRAP_BUFFER_ALLOC			8			/* buffer saturation */
#define TRAP_MSG_ALLOC				9			/* message saturation */
#define TRAP_TIMER_CELL_ALLOC		10			/* timer cell saturation */
#define	TRAP_MSG_LIB				11			/* liberation flag inconsistency */
#define TRAP_LOCK					12			/* lock/unlock inconsistency */
#define TRAP_PART_VL				13			/* saturation of the variable length partition */
#define TRAP_BLK_LIST				14			/* block checking list saturated */
#define TRAP_BAD_POINTER			15			/* block checking error */
#define TRAP_MSG_FREE				16			/* erroneous message alloc counter detected in free_msg */
#define TRAP_BUFFER_FREE			17			/* erroneous buffer alloc counter detected in free_buffer */
#define TRAP_TIMER_CELL_FREE		18			/* erroneous timer-cell alloc counter detected in free_timer_cell */
#define TRAP_NO_HOLE				19			/* no enough room in the hole ahead the Information */
#define TRAP_MSG_DATA				21			/* check sent message data size error */
#define TRAP_BUFFER_DATA			22			/* check sent buffer data size error */
#define TRAP_MESSAGE_CACHE			23			/* memory not available for message cache */
#define TRAP_BUFFER_CACHE			24			/* memory not available for buffer cache */
#define TRAP_TIMER_CELL_CACHE		25			/* memory not available for timer cell cache */
#define TRAP_CONGESTION_CONTROL		26			/* error in congestion control configuration */
#define TRAP_SERVER_QUEUE			27			/* error in server queue init */
#define TRAP_TIMER_VALUE			28			/* invalid timer value in services init configuration*/
#define TRAP_TIMER_SLOT				29			/* error memory in configuration for timer slot*/
#define TRAP_BLOCK_LIST				30			/* error memory in configuration in block list configuration*/
#define TRAP_FIFO					31			/* error memory in block FIFO configuration*/
#define TRAP_SERVER					32			/* no memory for server control blocks, or too many servers in the system */
#define TRAP_ENTITY_ID				33			/* invalid entity ID */
#define TRAP_SERVER_ENTITY			34			/* entity defined more than once in the servers */
#define TRAP_NO_EXTERNAL_QUEUE		35			/* no external queue in send_message */
#define TRAP_MSG_DATA_LGTH			36			/* length of message data area given in configuration too short */
#define TRAP_BLOCK_DATA_SIZE		37			/* block data size not large enough */

	/* SM entity Trap codes */

#define TRAP_SM_INIT				80			/* SM: configuration cycle problem: */
												/* configuration destination entity not in the system */
												/* or configuration structure is too large to fit in a buffer */
#define TRAP_SM_INIT_UPDATE_PAR		81			/* SM: update parameters initialization error */
#define TRAP_SM_SET_CONFIG_CO		82			/* SM: SM_SET_CONFIG_CO received with Confirm_ret_code != OK */

#define TRAP_SM_HOOK_BEFORE_CONFIG	83			/* SM: "before config" hook did not return OK */
#define TRAP_SM_HOOK_AFTER_CONFIG	84			/* SM: "after config"  hook did not return OK */

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  ENTITY  IDENTIFIERS  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

/* 		codes assignement : printable ASCII codes only [0x20-0x7f]

	(space)-ENTITY_ID_MIN		minimum entity ID value
	!		ENT_MPPP			Multi-Link PPP entity
	"
	#
	$
	%
	&
	'
	(
	)
	*
	+
	,
	-
	.
	/		ENT_PH_Z			Z interface entity
	0		ENT_STS				STS entity
	1		ENT_API				API entity
	2       ENT_V120/ENT_DL_V120 V.120 LAP entity
	3		ENT_L3				generic layer 3 entity
	4		ENT_MNP4			DL MNP4 entity
	5       ENT_MAALCP			ATM Adaptation Layer Common Part Management entity
	5       ENT_V5				V5 Layer 3 entity
	6		ENT_SMI/ENT_PH_S	Shared Memory Interface entity
	7       ENT_IB				ISDN BIOS entity
	8		ENT_IBI				ISDN BIOS interface entity
	9       ENT_ACC				ATM Call Control entity
	:		ENT_ECL				Equipment Control Link entity
	;	   	ENT_MPH_S           Shared Memory Interface management entity
	<		ENT_ILMI			Interim Local Network Management Interface entity
	=		ENT_MPH_GSTN		physical general switched telephone network management entity
	>		ENT_RC				Remote Control entity
	?
	@		ENT_AT_V25			conversion V.25 <--> "AT" command set
	A		ENT_APPLI			application entity
	B		ENT_BL				black list entity
	C		ENT_CC				call control entity
	C		ENT_CCR				call control relay entity
	D		ENT_PH_D			D channel physical entity
	E		ENT_MT30			T.30 management entity
	F		ENT_MFM				fax modem management entity
	G		ENT_PH_GSTN			physical general switched telephone network entity
	H		ENT_PH_MODEM		physical modem entity
	I		ENT_IP				ISO 8473 IP protocol entity
	J		ENT_ES				ISO 9542 ESIS protocol entity
	K		ENT_IS				ISO 10589 ISIS protocol entity
	L		ENT_FS				file server entity
	M		ENT_MNS				network signalling management entity
	N 		ENT_FT				file transfer entity
	O		ENT_MX213			X.213 management entity
	P      	ENT_MPH				generic physical management entity
	Q       ENT_MPH_B			management B channel
	R       ENT_PH_R			PH relay
	S		ENT_NS				network signalling Q.931 entity
	T		ENT_TI				timer process or timer IT
	U		ENT_AALCP           ATM Adaptation Layer Common Part entity
	V		ENT_DC				data compression entity
	W       ENT_MPH_D			management D channel if already MPH exist
	X		ENT_MX25			X.25 management entity
	Y       ENT_ANS				ATM network signalling entity
	Z       ENT_EF				ETSI EuroFile service entity
	[		ENT_CCE				Extended Call Control entity (Nx64K calls)
	\
	]       ENT_DL_F			Frame Relay (LAPF)
	^
	_		ENT_AT_ECL			AT-ECL entity
	`	   	ENT_ECI 			Eicon Interface entity (OMNABIOS)
	a		ENT_PAD				X.25 PAD entity
	b		ENT_DL_B			DL LAPB entity
	c		ENT_PH_B			physical B channel entity
	d		ENT_DL_D			DL LAPD Q.921 entity
	e       ENT_T30				T.30 entity
	f		ENT_FM				fax modem entity
	g       ENT_DL_R			Data Link relay
	h       ENT_MAAL			ATM Adaptation Layer Management entity
	h       ENT_DL_V5			V5 Data Link entity
	i		ENT_DTE_INT			DTE interface entity
	j       ENT_MIP				ISO CLNP Management entity
	k       ENT_DL_4K			LAP4K entity
	l		ENT_DL				DL generic entity
	m		ENT_MDL				DL management entity
	n		ENT_NIL				NIL entity
	o		ENT_X213			X.213 entity
	p       ENT_PH				generic physical entity
	q		ENT_PH_IT			interrupt pseudo entity
	r		ENT_PH_D_IT			physical D channel interruption
	s		ENT_CF				control function entity
	t		ENT_T				transport entity
	u		ENT_ACU				automatic calling unit entity
	v		ENT_DL_M			DL LAPM entity
	w       ENT_MANS			ATM network signalling Management entity
	x		ENT_X25				X.25 entity
	y       ENT_AAL				ATM Adaptation Layer entity
	y       ENT_BCC_RM			V5 BCC Resource Manager entity
	z		ENT_SM				system management entity
	{		ENT_LEC				Lan Emulation Client entity
	|		ENT_MLEC			Lan Emulation Client Management entity
	}
	~
	~-------ENTITY_ID_MAX		maximum entity ID value
	(0x7f)

*/

#ifndef ENTITY_ID_MIN
#define ENTITY_ID_MIN			' '				/* min entity ID */
#endif

#ifndef ENTITY_ID_MAX
#define ENTITY_ID_MAX			'~'				/* max entity ID */
#endif

#define ENT_NIL					'n'				/* entity NIL */

#define ENT_SM					'z'				/* System Management */
#define ENT_TI					'T'				/* TImer process pseudo-entity */

#define ENT_APPLI				'A'				/* application entity */

#define ENT_FS					'L'				/* File server entity */
#define ENT_FT					'N'				/* File transfer */

#define ENT_DTE_INT				'i'				/* DTE interface entity */
#define ENT_DTE_SCC_IT			ENT_PH_IT		/* DTE serial controller interface interrupt */
#define ENT_DTE_INT_IT			ENT_PH_IT

#define ENT_RC					'>'				/* Remote Control entity */

#define ENT_ECL					':'				/* Equipment Control Link entity */
#define ENT_AT_ECL				'_'				/* AT-ECL entity (between DTE-INT and ECL entities) */

#define	ENT_ILMI				'<'				/* Interim Local Network Management Interface entity */

#define ENT_ECI					'`'             /* Eicon Interface entity (OMNABIOS) */

#define ENT_STS					'0'				/* STS entity id */

#define ENT_DL_R				'g'				/* Data link relay */
#define ENT_MDL				 	'm'				/* Data Link layer Management entity */
#define ENT_DL				 	'l'				/* Data Link generic entity */
#define ENT_DL_D			 	'd'				/* " LAPD " Data Link entity */
#define ENT_DL_B			 	'b'				/* " LAPB " Data Link entity */
#define ENT_DL_F				']'				/* Data Link LAPF entity */
#define ENT_DL_M				'v'				/* Data Link LAPM entity */
#define ENT_MNP4				'4'				/* MNP 4 processing entity */
#define ENT_V120				'2'				/* V120 LAP entity */
#define ENT_DL_V120			 	ENT_V120		/* V.120 Data Link entity */
#define ENT_DL_4K			 	'k'				/* LAP4K Data Link entity */

#define ENT_DC					'V'				/* Data compression entity */

#define ENT_CC					'C'				/* Call Control entity */
#define ENT_CCR					ENT_CC			/* Call Control Relay entity */
#define ENT_CCE					'['				/* Extended Call Control entity (Nx64K calls) */
#define ENT_CF					's'				/* Control Functions entity */

#define ENT_MNS					'M'				/* NS layer Management entity */
#define ENT_NS					'S'				/* network signalling entity */
#define ENT_L3					'3'				/* layer 3 generic entity */

#define	ENT_FM					'f'				/* FAXMOD entity */
#define	ENT_MFM					'F'				/* FAXMOD management entity */
#define	ENT_T30					'e'				/* T30 entity */
#define	ENT_MT30				'E'				/* T30 management entity */

#define ENT_PH_R				'R'				/* PH relay */
#define ENT_MPH				 	'P'				/* physical layer management */
#define ENT_MPH_D				'W'				/* physical layer management D channel */
#define ENT_MPH_B			 	'Q'				/* physical layer management B channel */
#define ENT_MPH_IT				ENT_PH_IT		/* physical layer management interrupt */
#define ENT_PH				 	'p'				/* physical generic entity */
#define ENT_PH_IT				'q'				/* physical IT */

#define ENT_PH_D			 	'D'				/* physical D channel entity */
#define ENT_PH_D_IT			 	'r'				/* physical D channel interruption */

#define ENT_PH_Z			 	'/'				/* physical Z interface entity */
#define ENT_PH_Z_IT			 	ENT_PH_IT		/* physical Z interface interruption */

#define ENT_PH_B			 	'c'				/* physical B channel entity */
#define ENT_PH_B_IT			 	ENT_PH_IT		/* physical B channel interruption */
#define ENT_MPH_B_IT		 	ENT_PH_IT		/* physical B channel interruption */

#define ENT_PH_GSTN			 	'G'				/* physical GSTN entity */
#define ENT_PH_GSTN_IT		 	ENT_PH_IT		/* physical GSTN interruption */
#define ENT_MPH_GSTN			'='				/* physical GSTN management entity */

#define ENT_PH_MODEM			'H'				/* physical modem entity */
#define ENT_PH_MODEM_IT			ENT_PH_IT		/* physical modem interruption */

#define ENT_PAD					'a'				/* packet assembler deassembler */
#define ENT_T					't'				/* OSI transport entity */
#define ENT_MX25				'X'				/* X25 layer management entity */
#define ENT_X25					'x'				/* X.25-PLP entity */
#define ENT_X213				'o'				/* X.213 entity */
#define ENT_MX213				'O'				/* X.213 layer management entity */

#define ENT_ACU					'u'				/* ACU entity */
#define ENT_BL					'B'				/* Black List entity */

#define ENT_IP					'I'				/* ISO IP entity */
#define ENT_ES					'J'				/* ISO ES-IS entity */
#define ENT_IS					'K'				/* ISO IS-IS entity */
#define ENT_MIP					'j'				/* ISO CLNP Management entity */

#define ENT_ACC					'9'				/* ATM Call Control entity */
#define ENT_ANS					'Y'				/* ATM network signalling entity */
#define ENT_MANS				'w'				/* ATM network signalling Management entity */
#define ENT_AAL					'y'				/* ATM Adaptation Layer entity */
#define ENT_MAAL				'h'				/* ATM Adaptation Layer Management entity */
#define ENT_AALCP				'U'				/* ATM Adaptation Layer Common Part entity */
#define ENT_AALCP_IT			ENT_PH_IT		/* ATM Adaptation Layer Common Part Interrupt entity */
#define ENT_MAALCP				'5'				/* ATM Adaptation Layer Common Part Management entity */
#define ENT_MAALCP_IT			ENT_PH_IT		/* ATM Adaptation Layer Common Part Management Interrupt entity */

#define ENT_SMI					'6'				/* Shared Memory Interface entity */
#define ENT_SMI_IT				ENT_PH_IT		/* Shared Memory Interface Interrupt part pseudo-entity */

#define ENT_MPH_S				';'             /* Shared Memory Interface management entity */
#define ENT_PH_S				ENT_SMI			/* Shared Memory Interface entity */
#define ENT_PH_S_IT				ENT_SMI_IT		/* Shared Memory Interface Interrupt part pseudo-entity */

#define ENT_API					'1'				/* API entity */

#define ENT_IB					'7'				/* ISDN BIOS entity */
#define ENT_IBI					'8'				/* ISDN BIOS interface entity */

#define ENT_EF					'Z'				/* ETSI EuroFile service entity */
#define ENT_AT_V25				'@'				/* conversion V25 <--> "AT" */

#define ENT_V5					'5'				/* V5 PROTOCOL */
#define ENT_DL_V5				'h'				/* V5 Data Link entity */
#define ENT_BCC_RM				'y'				/* V5 BCC Resource Manager */

#define ENT_MPPP				'!'				/* Multi-Link PPP entity */

#define	ENT_LEC					'{'				/* Lan Emulation Client entity */
#define	ENT_MLEC				'|'				/* Lan Emulation Client Management entity */
#define	ENT_LM					ENT_MLEC		/* Alias (ATM-FORUM naming convention) */

/*--------------------------------------------------------------------------*/

					/*  GLOBAL EVENT CODES */

#define EV_NIL					'~'				/* null event = nothing to do */
#define EV_ERR_ADDRESS			'@'				/* communication message with an errored address field */

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  MESSAGES MANAGEMENT  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

struct message {

		/* Addressing information */

	ent_id_t	from;							/* origin of the message (entity identifier) */
	ent_id_t	to;								/* destination of the message (entity identifier) */
	nai_t		nai;							/* network access identifier */
	sapi_t		sapi;							/* service access point identifier */
	add_t		add;							/* address field (ces, tei, chani, call_id ...) */

		/* Entity queueing pointers */

	struct message FAR	*p_next;				/* pointer to next message if queued */
	struct message FAR	*p_prior;				/* pointer to prior message if queued */

		/* Services pointer */

	struct message FAR	*p_services;			/* pointer used by services functions */

		/* Buffer access */

	struct		buffer FAR	*p_buff;			/* pointer to buffer */
	ushort		frag_offset;					/* buffer fragment offset */
	ushort		frag_size;						/* buffer fragment size */

		/* Primitive code (event ID) */

	code_t		code;							/* primitive code (unique only between two entities) */

		/* Priority value */

	priority_t	priority;						/* requested processing priority */

		/* Retention flag : if message queued by entity */

	uchar		lib;							/* liberation flag : */
												/*	= OFF --> no liberation */
		/* Access to the data of the message */

	uchar		data_offset;
	uchar		data_size;
};

		/* Message information */

struct 	inf {
	ushort		inf0;							/* information location 0 */
	ushort		inf1;							/* information location 1 */
	ushort		inf2;							/* information location 2 */
	ushort		inf3;							/* information location 3 */
	ushort		inf4;							/* information location 4 */
};

#define INF_SIZE				sizeof (struct inf)									/* information data size */

			/* Constant definitions */

#define MESSAGE_HEADER_SIZE		(uchar)Rnd_sizeof (struct message)	/* message header size */
#define Message_data_lgth		(Message_lgth - MESSAGE_HEADER_SIZE)
#define MESSAGE_GAP_SIZE        (MESSAGE_HEADER_SIZE - sizeof (struct message))

				   /*-------------------------------------------*/

		   /*
			  Generic macro access to the messages structures
			  ('X_msg_...' series)
		   */

#define X_msg_code(p)			p -> code		/* primitive code */
#define X_msg_priority(p)		p -> priority	/* requested priority value */
#define X_msg_from(p)			p -> from		/* origination entity */
#define X_msg_lib(p)			p -> lib		/* liberation flag */
#define X_msg_to(p)				p -> to			/* destination entity */
#define X_msg_nai(p) 			p -> nai		/* network access identifier */
#define X_msg_circ_gid(p)		p -> nai        /* Circuit global identifier */
#define X_msg_sapi(p) 			p -> sapi		/* service access point identifier */
#define X_msg_add(p) 			p -> add		/* generic address */
#define X_msg_ces(p) 			p -> add		/* connection endpoint suffix (CES) */
#define X_msg_tei				p -> add        /* Terminal Endpoint Identifier (TEI) value */
#define X_msg_chani(p)			p -> add		/* channel identifier */
#define X_msg_conn_id(p)		p -> add		/* connection identifier */
#define X_msg_stream_id(p)		p -> add		/* stream identifier */

#define X_msg_p_buffer(p)		p -> p_buff		/* buffer address */
#define X_msg_frag_offset(p)	p -> frag_offset/* buffer fragment offset */
#define X_msg_frag_size(p)		p -> frag_size	/* buffer fragment size */

#define X_msg_inf0(p)			(((struct inf FAR *)((uchar FAR *)p + MESSAGE_HEADER_SIZE)) -> inf0)	/* information 0 */
#define X_msg_inf1(p)			(((struct inf FAR *)((uchar FAR *)p + MESSAGE_HEADER_SIZE)) -> inf1)	/* information 1 */
#define X_msg_inf2(p)			(((struct inf FAR *)((uchar FAR *)p + MESSAGE_HEADER_SIZE)) -> inf2)	/* information 2 */
#define X_msg_inf3(p)			(((struct inf FAR *)((uchar FAR *)p + MESSAGE_HEADER_SIZE)) -> inf3)	/* information 3 */
#define X_msg_inf4(p)			(((struct inf FAR *)((uchar FAR *)p + MESSAGE_HEADER_SIZE)) -> inf4)	/* information 4 */

#define X_msg_frame_size(p) 	X_msg_data_size(p)						/* frame size */
#define X_msg_a_frame(p)		(union frame FAR *)X_msg_a_first_data(p)/* frame position inside a message */

#define X_msg_data_offset(p)	p -> data_offset
#define X_msg_data_size(p)		p -> data_size

#define X_msg_a_data(p)			(uchar FAR *)&(p -> data_offset)
#define X_msg_a_start_data(p)	((uchar FAR *)p + X_msg_data_offset(p))
#define X_msg_a_end_data(p)		((uchar FAR *)p + X_msg_data_offset(p) + X_msg_data_size(p))
#define X_msg_a_first_data(p)	((uchar FAR *)p + MESSAGE_HEADER_SIZE)

#define X_msg_init_link_buffer(p)if ((X_msg_p_buffer(p) = p_buffer) != P_NIL) {		\
									X_msg_frag_size(p) 	= Buffer_data_size;			\
									Buffer_link_count 	= 1;						\
								}

#define X_msg_link_buffer(p)	if ((X_msg_p_buffer(p)	= p_buffer) != P_NIL) {		\
									X_msg_frag_size(p)	= Buffer_data_size;			\
									It_disable ();									\
									Buffer_link_count++;							\
									It_enable ();									\
								}

#define X_msg_header_init(p)	X_msg_data_offset(p)	= MESSAGE_HEADER_SIZE;		\
								X_msg_data_size(p)		= 0

#define X_msg_alloc(p) 			if (p != P_NIL) {									\
									Free_msg (p);									\
								}													\
								p = Alloc_msg ()

#define X_a_data(p)				(((p_buffer = X_msg_p_buffer(p)) == P_NIL) ? X_msg_a_start_data(p) : Buffer_a_start_data)
#define X_a_end_data(p)			(((p_buffer = X_msg_p_buffer(p)) == P_NIL) ? X_msg_a_end_data(p)   : Buffer_a_end_data)
#define X_data_offset(p)		(((p_buffer = X_msg_p_buffer(p)) == P_NIL) ? X_msg_data_offset(p)  : Buffer_data_offset)
#define X_data_size(p)			(((p_buffer = X_msg_p_buffer(p)) == P_NIL) ? X_msg_data_size(p)    : Buffer_data_size)

#define X_msg_p_next(p)			p -> p_next
#define X_msg_p_prior(p)		p -> p_prior

#define X_msg_p_services(p)		p -> p_services

				   /*-------------------------------------------*/

		   /*
			  Reading received message  / Right Hand Side  thru p_rcv_msg
			  ('R_msg_...' series)
		   */

#define R_msg_code 				X_msg_code			(p_rcv_msg)
#define R_msg_priority			X_msg_priority		(p_rcv_msg)
#define R_msg_from				X_msg_from			(p_rcv_msg)
#define R_msg_lib				X_msg_lib			(p_rcv_msg)
#define R_msg_to				X_msg_to			(p_rcv_msg)
#define R_msg_nai 				X_msg_nai			(p_rcv_msg)
#define R_msg_circ_gid			X_msg_circ_gid		(p_rcv_msg)
#define R_msg_sapi 				X_msg_sapi			(p_rcv_msg)
#define R_msg_add 				X_msg_add			(p_rcv_msg)
#define R_msg_ces 				X_msg_ces			(p_rcv_msg)
#define R_msg_chani				X_msg_chani			(p_rcv_msg)
#define R_msg_conn_id			X_msg_conn_id		(p_rcv_msg)
#define R_msg_stream_id			X_msg_stream_id		(p_rcv_msg)

#define R_msg_p_buffer			X_msg_p_buffer		(p_rcv_msg)
#define R_msg_frag_offset		X_msg_frag_offset	(p_rcv_msg)
#define R_msg_frag_size			X_msg_frag_size		(p_rcv_msg)

#define R_msg_inf0				X_msg_inf0			(p_rcv_msg)
#define R_msg_inf1				X_msg_inf1			(p_rcv_msg)
#define R_msg_inf2				X_msg_inf2			(p_rcv_msg)
#define R_msg_inf3				X_msg_inf3			(p_rcv_msg)
#define R_msg_inf4				X_msg_inf4			(p_rcv_msg)

#define R_msg_frame_size 		X_msg_frame_size	(p_rcv_msg)
#define R_msg_a_frame			X_msg_a_frame		(p_rcv_msg)

#define R_msg_data_offset		X_msg_data_offset	(p_rcv_msg)
#define R_msg_data_size			X_msg_data_size		(p_rcv_msg)

#define R_msg_a_data			X_msg_a_data		(p_rcv_msg)
#define R_msg_a_start_data		X_msg_a_start_data	(p_rcv_msg)
#define R_msg_a_end_data		X_msg_a_end_data	(p_rcv_msg)
#define R_msg_a_first_data		X_msg_a_first_data	(p_rcv_msg)

#define R_msg_header_init		X_msg_header_init	(p_rcv_msg)
#define R_msg_init_link_buffer	X_msg_init_link_buffer(p_rcv_msg)

#define R_a_data				X_a_data			(p_rcv_msg)
#define R_a_end_data			X_a_end_data		(p_rcv_msg)
#define R_data_offset			X_data_offset		(p_rcv_msg)
#define R_data_size				X_data_size			(p_rcv_msg)

#define R_msg_p_next			X_msg_p_next		(p_rcv_msg)
#define R_msg_p_prior			X_msg_p_prior		(p_rcv_msg)

#define R_msg_p_services		X_msg_p_services	(p_rcv_msg)

				   /*-------------------------------------------*/

		   /*
			  Writing sent message   / Left Hand Side   thru p_snd_msg pointer
			  (S_msg_... series)
		   */

#define S_msg_code 				X_msg_code			(p_snd_msg)
#define S_msg_priority			X_msg_priority		(p_snd_msg)
#define S_msg_from				X_msg_from			(p_snd_msg)
#define S_msg_lib				X_msg_lib			(p_snd_msg)
#define S_msg_to				X_msg_to			(p_snd_msg)
#define S_msg_nai 				X_msg_nai			(p_snd_msg)
#define S_msg_circ_gid			X_msg_circ_gid		(p_snd_msg)
#define S_msg_sapi 				X_msg_sapi			(p_snd_msg)
#define S_msg_add 				X_msg_add			(p_snd_msg)
#define S_msg_ces 				X_msg_ces			(p_snd_msg)
#define S_msg_tei				X_msg_tei			(p_snd_msg)
#define S_msg_chani				X_msg_chani			(p_snd_msg)
#define S_msg_conn_id			X_msg_conn_id		(p_snd_msg)
#define S_msg_stream_id			X_msg_stream_id		(p_snd_msg)

#define S_msg_p_buffer			X_msg_p_buffer		(p_snd_msg)
#define S_msg_frag_offset		X_msg_frag_offset	(p_snd_msg)
#define S_msg_frag_size			X_msg_frag_size		(p_snd_msg)

#define S_msg_inf0				X_msg_inf0			(p_snd_msg)
#define S_msg_inf1				X_msg_inf1			(p_snd_msg)
#define S_msg_inf2				X_msg_inf2			(p_snd_msg)
#define S_msg_inf3				X_msg_inf3			(p_snd_msg)
#define S_msg_inf4				X_msg_inf4			(p_snd_msg)

#define S_msg_frame_size 		X_msg_frame_size	(p_snd_msg)
#define S_msg_a_frame			X_msg_a_frame		(p_snd_msg)

#define S_msg_data_offset		X_msg_data_offset	(p_snd_msg)
#define S_msg_data_size        	X_msg_data_size		(p_snd_msg)

#define S_msg_a_data			X_msg_a_data		(p_snd_msg)
#define S_msg_a_start_data		X_msg_a_start_data	(p_snd_msg)

#define S_msg_a_first_data		X_msg_a_first_data	(p_snd_msg)

#define S_msg_init_link_buffer	X_msg_init_link_buffer(p_snd_msg)
#define S_msg_link_buffer		X_msg_link_buffer	(p_snd_msg)
#define S_msg_header_init		X_msg_header_init	(p_snd_msg)
#define S_msg_alloc				X_msg_alloc			(p_snd_msg)

#define S_a_data				X_a_data			(p_snd_msg)
#define S_a_end_data			X_a_end_data		(p_snd_msg)
#define S_data_offset			X_data_offset		(p_snd_msg)
#define S_data_size				X_data_size			(p_snd_msg)

#define S_msg_p_next			X_msg_p_next		(p_snd_msg)
#define S_msg_p_prior			X_msg_p_prior		(p_snd_msg)

#define S_msg_p_services		X_msg_p_services	(p_snd_msg)

				   /*- - - - - - - - - - - - - - - - - - - - - -*/

#define Reused_snd_msg 			if (p_snd_msg == P_NIL) {		\
									p_snd_msg = Alloc_msg ();	\
								} else {						\
									S_msg_p_buffer = P_NIL;		\
									S_msg_header_init;			\
								}

				   /*-------------------------------------------*/

		   /* Local pointer p_msg */
		   /*
			  Accessing a message poited to by a local 'p_msg' pointer
			  (L_msg_... series)
		   */


#define L_msg_code 				X_msg_code			(p_msg)
#define L_msg_priority			X_msg_priority		(p_msg)
#define L_msg_from				X_msg_from			(p_msg)
#define L_msg_lib				X_msg_lib			(p_msg)
#define L_msg_to				X_msg_to			(p_msg)
#define L_msg_nai 				X_msg_nai			(p_msg)
#define L_msg_circ_gid			X_msg_circ_gid		(p_msg)
#define L_msg_sapi 				X_msg_sapi			(p_msg)
#define L_msg_add 				X_msg_add			(p_msg)
#define L_msg_ces 				X_msg_ces			(p_msg)
#define L_msg_chani				X_msg_chani			(p_msg)
#define L_msg_conn_id			X_msg_conn_id		(p_msg)
#define L_msg_stream_id			X_msg_stream_id		(p_msg)

#define L_msg_p_buffer			X_msg_p_buffer		(p_msg)
#define L_msg_frag_offset		X_msg_frag_offset	(p_msg)
#define L_msg_frag_size			X_msg_frag_size		(p_msg)

#define L_msg_inf0				X_msg_inf0			(p_msg)
#define L_msg_inf1				X_msg_inf1			(p_msg)
#define L_msg_inf2				X_msg_inf2			(p_msg)
#define L_msg_inf3				X_msg_inf3			(p_msg)
#define L_msg_inf4				X_msg_inf4			(p_msg)

#define L_msg_a_frame			X_msg_a_frame		(p_msg)

#define L_msg_data_offset		X_msg_data_offset	(p_msg)
#define L_msg_data_size        	X_msg_data_size		(p_msg)

#define L_msg_a_data			X_msg_a_data		(p_msg)
#define L_msg_a_start_data		X_msg_a_start_data	(p_msg)
#define L_msg_a_end_data		X_msg_a_end_data	(p_msg)
#define L_msg_a_first_data		X_msg_a_first_data	(p_msg)

#define L_msg_init_link_buffer	X_msg_init_link_buffer(p_msg)
#define L_msg_link_buffer		X_msg_link_buffer	(p_msg)
#define L_msg_header_init		X_msg_header_init	(p_msg)
#define L_msg_alloc				X_msg_alloc			(p_msg)

#define L_a_data				X_a_data			(p_msg)
#define L_a_end_data			X_a_end_data		(p_msg)
#define L_data_offset			X_data_offset		(p_msg)
#define L_data_size				X_data_size			(p_msg)

#define L_msg_p_next			X_msg_p_next		(p_msg)
#define L_msg_p_prior			X_msg_p_prior		(p_msg)

#define L_msg_p_services		X_msg_p_services	(p_msg)

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  BUFFERS  MANAGEMENT  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

struct buffer {
		ushort				link_count;			/* number of links to a message (fragmentation) */
		struct buffer FAR * p_next;				/* pointer to a linked buffer */
		ushort				data_offset;		/* offset of the useful data */
		ushort				data_size;			/* size of the useful data */
};

					/* Constants definition */

#define BUFFER_HEADER_SIZE	Rnd_sizeof (struct buffer)

#define Buffer_data_lgth	(Buffer_lgth - BUFFER_HEADER_SIZE)

					/* Manipulation macro's thru p_buffer pointer */

#define Buffer_link_count	p_buffer -> link_count 			/* number of message linked to the buffer (fragmentation) */

#define Buffer_p_next		p_buffer -> p_next				/* next linked buffer */

#define Buffer_data_size   	p_buffer -> data_size			/* useful data size */
#define Buffer_data_offset	p_buffer -> data_offset   		/* useful data offset */
#define Buffer_a_first_data	((uchar FAR *)p_buffer + BUFFER_HEADER_SIZE)	/* address of  the first available byte */
#define Buffer_a_start_data	((uchar FAR *)p_buffer + Buffer_data_offset)	/* calculated address of the useful data */
#define Buffer_a_end_data	((uchar FAR *)p_buffer + Buffer_data_offset + Buffer_data_size) /* calculated address of the end of the useful data */
#define Buffer_save_size	Buffer_data_offset + Buffer_data_size			/* part of the buffer used by data (for saving) */

#define Buffer_header_init	Buffer_data_offset	= BUFFER_HEADER_SIZE;		\
							Buffer_data_size 	= Buffer_link_count = 0;	\
							Buffer_p_next		= P_NIL

#define Buffer_alloc		(p_buffer = Alloc_buffer ())

#define Buffer_alloc_reused	if (p_rcv_msg == P_NIL) {						\
								Buffer_alloc;								\
							} else {										\
								if ((p_buffer = R_msg_p_buffer) == P_NIL) {	\
									Buffer_alloc;							\
								} else {									\
									R_msg_p_buffer = P_NIL;					\
									Buffer_header_init;						\
								}											\
							}

#define Buffer_a_from_a_start_data(p_start_data)  (struct buffer FAR *)(p_start_data - BUFFER_HEADER_SIZE)

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*   TIMERS MANAGEMENT   */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

				/*----------------------*/
				/*    Timer constants   */
				/*----------------------*/

#define MILLISECOND			(timer_val_t)1	/* UNIT = Millisecond */
#define M_SCD				MILLISECOND

#define SECOND				(1000*M_SCD)	/* 1000 mSECOND scale = 1SECOND */
#define SCD					SECOND          /* Alias */

#define D_SECOND			(100*M_SCD)		/* 100  mSECOND scale */
#define TENTH_SECOND		D_SECOND		/* Alias */
#define D_SCD				D_SECOND        /* Alias */
#define T_SCD				D_SECOND		/* Alias */

#define HUNDREDTH_SECOND	10*M_SCD		/* 1 hundredth of second */
#define H_SCD				HUNDREDTH_SECOND

					/* Timer  object structure */

struct timer {
	uchar 	state;							/* status : ON (time-out possible) or OFF (time-out unexpected) */
	uchar 	sn;								/* sequence number (modulo) used to avoid alea situation (due to concurrent action) */
	uchar 	FAR *id;						/* timer identifier given by the timer allocate function */
};

#define TIMER_ID_NIL		(uchar FAR *)0	/* timer ID NULL */

				/*----------------------*/
				/* Timer object actions */
				/*----------------------*/

			/*
				xx is a timer index used internally to retreave
				the timer data in the ad hoc objects.

				The following macros are to be defined :

				   Ti_id 	: timer ID (address of the timer cell),
				   Ti_val	: timer value (ushort),
				   Ti_sn 	: sequence number (modulo 256),
				   Ti_ev_id : timer event code,
				   Ti_state : timer state : ON or OFF.

			*/

			/* Start timer */

#define Start_timer(xx) 		Timer_start (Ti_id(xx), Ti_val(xx),				\
								++(Ti_sn(xx)), Ti_ev_id(xx)); Ti_state(xx) = ON

#define Start_timer_val(xx,val)	Timer_start (Ti_id(xx), val, ++(Ti_sn(xx)),		\
								Ti_ev_id(xx)); Ti_state(xx) = ON

			/* Restart timer = start timer */

#define Restart_timer(xx)		Timer_start (Ti_id(xx), Ti_val(xx),				\
								++(Ti_sn(xx)), Ti_ev_id(xx)); Ti_state(xx) = ON
			/* Stop timer */

#define Stop_timer(xx)			Timer_stop (Ti_id(xx)); Ti_state(xx) = OFF

			/* Timer state access */

#define State_timer(xx) 		Ti_state(xx)

			/* Check timer event validity according to the sequence number */

#define Valid_time_out(xx)		(Ti_state(xx) == ON) && (R_msg_inf0 == Ti_sn(xx))

				/*----------------------*/
				/* Timer cell structure */
				/*----------------------*/

struct timer_cell {
	struct 		timer_cell 	FAR *p_next;		/* pointer to next cell */
	struct 		timer_cell 	FAR *p_prior;		/* pointer to prior cell */
	ulong 		to_clock;						/* clock time when the time-out will fail */
	ushort 		x_timer_head;					/* index in the timer_head table */
	uchar		period_flag;					/* ON if the timer is periodic */

	union {

			/* One-shot timers data */

		struct {
			nai_t 		nai;					/* network access identifier */
			sapi_t 		sapi;					/* service access point identifier */
			add_t 		add;					/* address complement */
			code_t 		ev_id;					/* timer event ID */
			uchar 		sn;						/* sequence number */
			ent_id_t	entity_id;				/* originator entity ID */
		} one_shot;

			/* Periodic timers data */

		struct {
			timer_val_t to_val;					/* saved time-out value */

#			if NEW_FCT_STYLE == ON
				void (FAR *p_fct) (ulong param);/* pointer to the user function called periodically at timer expiration */
#			else
				void (FAR *p_fct) ();
#			endif

			ulong		fct_param;				/* parameter passed to the called function */

		} periodic;

	} data;
};

#define TIMER_CELL_LGTH		sizeof (struct timer_cell)

			/* Access to timer cell value using p_cell pointer */

#define Cell_next			((struct timer_cell FAR *)p_cell) -> p_next
#define Cell_prior			((struct timer_cell FAR *)p_cell) -> p_prior
#define Cell_to_clock   	((struct timer_cell FAR *)p_cell) -> to_clock
#define Cell_x_head			((struct timer_cell FAR *)p_cell) -> x_timer_head
#define Cell_period_flag	((struct timer_cell FAR *)p_cell) -> period_flag
#define Cell_nai			((struct timer_cell FAR *)p_cell) -> data.one_shot.nai
#define Cell_sapi			((struct timer_cell FAR *)p_cell) -> data.one_shot.sapi
#define Cell_add			((struct timer_cell FAR *)p_cell) -> data.one_shot.add
#define Cell_ev_id			((struct timer_cell FAR *)p_cell) -> data.one_shot.ev_id
#define Cell_sn				((struct timer_cell FAR *)p_cell) -> data.one_shot.sn
#define Cell_entity_id		((struct timer_cell FAR *)p_cell) -> data.one_shot.entity_id
#define Cell_to_val			((struct timer_cell FAR *)p_cell) -> data.periodic.to_val
#define Cell_p_fct			((struct timer_cell FAR *)p_cell) -> data.periodic.p_fct
#define Cell_fct_param		((struct timer_cell FAR *)p_cell) -> data.periodic.fct_param

				/*----------------------*/
				/* Timer slot structure */
				/*----------------------*/

struct timer_head {
	 struct timer_cell FAR *p_first;					/* pointer to the first timer cell */
};

			/* Access to the thread header values using an index */

#define Head_first(x)		p_timer_slot[x].p_first
#define Head_a_cell(x)		(struct timer_cell FAR *)p_timer_slot[x]

				/*----------------------------*/
				/* System tick-related macros */
				/*----------------------------*/

	/*
		This one should be defined in serv_por.h
		Define it if not defined, for compatibility purposes.
	*/

#ifndef Timer_system_tick
#define Timer_system_tick		read_timer_system_tick()
#endif

	/* Ticks <-> milliseconds conversion macros */

#define	Tick_to_ms(nb_ticks)	((nb_ticks) * Timer_system_tick)
#define	Ms_to_tick(nb_ms)		((nb_ms)    / Timer_system_tick)

/*-----------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*    MESSAGES  AUDIT    */
				/*       STRUCTURE       */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#if MESSAGE_AUDIT == ON

	struct	msg_audit {
		long 				system_time;			/* time stamping */
		char				direction;				/* Sent or Received Internal */

		uchar 				from;					/* entity origination ID */
		uchar 				to;						/* entity destination ID */

		code_t 				code;					/* primitive code */

		nai_t				nai;					/* network access ID */
		sapi_t				sapi;					/* sapi destination */
		add_t				conn_id;				/* conn_id destination */

		uchar				congestion_flag;		/* congestion flag */

		ushort				message_alloc;			/* allocated message */
		ushort				buffer_alloc;			/* allocated buffer */
		ushort				timer_cell_alloc;		/* allocated timer cell */

		ushort				it_stack_msg_nb;		/* IT message stack counter */
		ushort				it_stack_buffer_nb;		/* IT message stack counter */

		ushort				message_cong_nb;		/* message congestion counter */
		ushort				buffer_cong_nb;			/* buffer congestion counter */
		ushort				it_stack_msg_cong_nb;	/* IT stack message congestion counter */
		ushort				it_stack_buffer_cong_nb;/* IT stack buffer congestion counter */

		struct message FAR	*p_msg;					/* message address */
		struct buffer  FAR	*p_buffer;				/* buffer address */

		ushort				data_size;				/* buffer data size */

		uchar				data [MESSAGE_AUDIT_DATA_LGTH];/* message or buffer data */
	};

#endif

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*    MESSAGE QUEUEING   */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

			/*
				Queue manipulation macro's (independant on the queue
				management location).
				Uses:
					- p_next:  pointer to the next  block in the queue
					- p_prior: pointer to the prior block in the queue
			*/

#define Next(p_xx)		((p_xx) -> p_next)		/* get next  element from element pointed to by p_xx */
#define Prior(p_xx)		((p_xx) -> p_prior)		/* get prior element from element pointed to by p_xx */


			/*
				Queue management structure : communication messages are queued
				using their 'p_next' and 'p_prior' pointers.
				The queues (start/end) are managed by the following
				structure:
			*/

struct queue_mgt {
	struct message FAR	*p_first;				/* pointer to the head of the queue */
	struct message FAR	*p_last;				/* pointer to the tail of the queue */
};

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/* SERVICES  FIFO / LIFO */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/


		/*
			Communications messages are queued using the
			'p_services' pointer (one way pointer).
			A FIFO management descriptor points to the first and
			last messages of the queue.
		*/

				/*-----------------*/
				/* FIFO management */
				/*-----------------*/

		/*
			FIFO manipulation using the 'p_services' location :
				- get first element of the FIFO,
				- put at the queue  of the FIFO.

			The FIFO head and tail pointers are pointers to the first
			and last messages of the FIFO. They are passed by address
			to the macro:

			struct message FAR *p_fifo_first_msg;
			struct message FAR *p_fifo_last_msg;
			struct message FAR *p_msg;

			Fifo_put_msg (&p_lifo_first_msg, &p_lifo_last_msg, p_msg);
			Fifo_get_msg (&p_lifo_first_msg, &p_lifo_last_msg, p_msg);
		*/

#define Fifo_put_msg(p_fifo_p_first, p_fifo_p_last, p_xx)		\
	if (*p_fifo_p_last == P_NIL) {								\
		*p_fifo_p_first = *p_fifo_p_last = p_xx;				\
	} else {													\
		(*p_fifo_p_last) -> p_services 	= p_xx;					\
		*p_fifo_p_last 					= p_xx;					\
	}															\
	p_xx -> p_services = P_NIL

#define Fifo_put_first_msg(p_fifo_p_first, p_fifo_p_last, p_xx)	\
	if (*p_fifo_p_first == P_NIL) {								\
		*p_fifo_p_first = *p_fifo_p_last = p_xx;				\
		p_xx -> p_services = P_NIL;								\
	} else {													\
		p_xx -> p_services = (*p_fifo_p_first) -> p_services;	\
		(*p_fifo_p_first) -> p_services	= p_xx;					\
	}

#define Fifo_put_head_msg(p_fifo_p_first, p_fifo_p_last, p_xx)	\
	if (*p_fifo_p_first == P_NIL) {								\
		*p_fifo_p_first = *p_fifo_p_last = p_xx;				\
		p_xx -> p_services = P_NIL;								\
	} else {													\
		p_xx -> p_services = *p_fifo_p_first;					\
		*p_fifo_p_first    = p_xx;								\
	}

#define Fifo_get_msg(p_fifo_p_first, p_fifo_p_last, p_xx)		\
	if ((p_xx = *p_fifo_p_first) != P_NIL) {					\
		*p_fifo_p_first = (*p_fifo_p_first) -> p_services;		\
		if (*p_fifo_p_first == P_NIL) {							\
			*p_fifo_p_last = P_NIL;								\
		}														\
	}

		/* Check FIFO consistency */

#define Fifo_check_msg(counter, p_fifo_first, p_fifo_last, trap_code, p_location)   \
		{																			\
			struct message FAR *p_check_next  = p_fifo_first;						\
			struct message FAR *p_check_prior = P_NIL; 								\
			counter = 0; 															\
			while (p_check_next != P_NIL) { 										\
				counter++;															\
				p_check_prior 	= p_check_next; 									\
				p_check_next 	= X_msg_p_services (p_check_next); 					\
			} 																		\
			if (p_check_prior != p_fifo_last) { 									\
				Trap (trap_code, p_location);										\
			} 																		\
		}

				/*-----------------*/
				/* LIFO management */
				/*-----------------*/

		/*
			LIFO manipulation : messages, buffers and timer cells
			using the 'p_next' field.

			The LIFO head pointer is a pointer to the first block:

				struct xxxx FAR *p_lifo_first_xxxx;
				struct xxxx FAR *p_block;

				Lifo_put (p_lifo_first_xxxx, p_block);
				Lifo_get (p_lifo_first_xxxx, p_block);
		*/

#define Lifo_put(p_lifo_first, p)		\
	(p) -> p_next = p_lifo_first;		\
	p_lifo_first  = p;

#define Lifo_get(p_lifo_first, p)		\
	if ((p = p_lifo_first) !=  P_NIL) {	\
		p_lifo_first = (p) -> p_next;	\
	}

#define Lifo_put_msg(p_lifo_first, p_msg)					Lifo_put (p_lifo_first, p_msg)
#define Lifo_get_msg(p_lifo_first, p_msg)					Lifo_get (p_lifo_first, p_msg)

#define Lifo_put_buffer(p_lifo_first, p_buffer)				Lifo_put (p_lifo_first, p_buffer)
#define Lifo_get_buffer(p_lifo_first, p_buffer)				Lifo_get (p_lifo_first, p_buffer)

#define Lifo_put_timer_cell(p_lifo_first, p_timer_cell)		Lifo_put (p_lifo_first, p_timer_cell)
#define Lifo_get_timer_cell(p_lifo_first, p_timer_cell)		Lifo_get (p_lifo_first, p_timer_cell)

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*     TREE STRUCTURE    */
				/*       MANAGEMENT      */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

	/* Tree object structure : left to right and up to down manipulation */

struct node {
	struct 	node 	FAR *p_next;				/* next node */
	struct 	node 	FAR *p_dp;     				/* down node or prior node */
};

#define Next_node 			(p_node) -> p_next	/* next node (same level) */
#define Down_node			(p_node) -> p_dp	/* adjacent lower node */
#define Prior_node			(p_node) -> p_dp	/* prior node (same level) (lowest lever only) */

#define Node_from_p(p)		(((struct node FAR *)p) - 1)
												/* get node   pointer from object pointer */
#define P_from_node(p_node)	(p_node + 1)		/* get object pointer from node   pointer */


/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  SM PRIMITIVES CODES  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

				/* SM <----> service user */

#define SM_BUSY_RQ				'A'				/* start of resource congestion */
#define SM_BUSY_IN				'a'				/* resource congestion indicate */

#define SM_CLEAR_BUSY_RQ		'B'				/* end of resource congestion  alert */
#define SM_CLEAR_BUSY_IN		'b'				/* end of resource congestion  indication */

#define	SM_SET_CONFIG_RQ		'C'				/* set configuration request */
#define SM_SET_CONFIG_CO        'c'				/* set configuration confirm */

#define	SM_RESET_CONFIG_RQ		'D'				/* reset configuration request */
#define	SM_RESET_CONFIG_CO		'd'				/* reset configuration request */

#define SM_INIT_RQ				'E'				/* not used yet */
#define SM_INIT_CO				'e'				/* not used yet */
#define SM_START_TRAFFIC_RQ		'E'				/* Request START Traffic */
#define SM_START_TRAFFIC_CO		'e'				/* Confirm START Traffic */

#define SM_STOP_RQ				'F'				/* request stopping traffic entitie */
#define SM_STOP_CO				'f'				/* stopping traffic entitie  confirm */
#define SM_STOP_TRAFFIC_RQ		'F'				/* request stopping traffic entitie */
#define SM_STOP_TRAFFIC_CO		'f'				/* stopping traffic entitie  confirm */

#define SM_INFO_RQ				'G'				/* request for Data Link statistic */
#define SM_INFO_CO				'g'				/* Data link statistic confirm */

#define SM_INFO_IN				'H'				/* request for SM informations (environment parameters) */
#define SM_INFO_RS				'h'				/* SM information response */

#define SM_NA_POWER_ON_RQ		'I'				/* Network Access powered ON request */
#define SM_NA_POWER_ON_IN		'i'				/* Network Access powered ON indication */

#define SM_NA_POWER_OFF_RQ		'J'				/* Network Access powered OFF request */
#define SM_NA_POWER_OFF_IN		'j'				/* Network Access powered OFF indication */

#define SM_REPORT_RQ			'K'				/* Report request */
#define SM_REPORT_IN			'k'				/* Report indication */

#define SM_SET_REPORT_IN		'l'				/* Select report processing options */

	/* Configuration update management primitives */

#define SM_PUT_UPDATE_PAR_IN	'w'				/* put update parameter indication */
#define SM_PUT_UPDATE_PAR_RS	'W'				/* put update parameter response */

#define SM_GET_UPDATE_PAR_IN	'x'				/* Get update parameter indication */
#define SM_GET_UPDATE_PAR_RS	'X'				/* Get update parameter response */

				/*-------------------------------------*/

#define SM_TEI_RQ				'M'				/* Non-automatic TEI management */
#define SM_TEI_IN				'm'				/* Non-automatic TEI management */

#define SM_TEI_RS				'N'				/* Non-automatic TEI management */
#define SM_TEI_REG_IN			'n'				/* Non-automatic TEI management */

#define SM_DL_DLCI_RQ			'O'				/* DLCI assignment or removal request */
#define SM_DL_DLCI_IN			'o'				/* DLCI assignment or removal indication */

#define SM_DL_ATTACH_SAPI_IN	'p'				/* indicate SAPI attach   from Layer 3 Management entity to   SM */
#define SM_DL_DETACH_SAPI_IN	'q'				/* indicate SAPI detach   from Layer 3 Management entity to   SM */
#define SM_DL_SAPI_RS			'Q'				/* response SAPI management to Layer 3 Management entity from SM */

#define SM_DL_ATTACH_SAPI_RQ	'R'				/* request attach of a SAPI, CES to a CHANI */
#define SM_DL_SAPI_CO			'r'				/* confirm SAPI management */
#define SM_DL_DETACH_SAPI_RQ	'S'				/* request detach of a SAPI, CES to a CHANI */

#define SM_DL_TEI_RQ			'T'				/* request  loading of a non-automatic TEI */
#define SM_DL_TEI_IN			't'				/* indicate loading of a non-automatic TEI */
#define SM_DL_TEI_RS			'U'				/* response loading of a non-automatic TEI */
#define SM_DL_TEI_CO			'u'				/* confirm  loading of a non-automatic TEI */

#define SM_MIP_MAN_ROUT_RQ		'V'				/* request MIP manual routeing */
#define SM_MIP_MAN_ROUT_CO		'v'				/* confirm MIP manual routeing */

					/* D/B Channels Maintenance (SM <-> MNS) */

#define	SM_CHANNEL_MAINT_RQ		'Y'				/* D or B channel maintenance request */
#define	SM_CHANNEL_MAINT_CO		'y'             /* D or B channel maintenance confirm */

	/* Aliases used by Omnitel's X25/MX25 entities */

#define SM_X25_DL_ATTACH_SAPI_IN	SM_DL_ATTACH_SAPI_IN	/* indicate SAPI attach from MX25 entity to SM */
#define SM_X25_DL_DETACH_SAPI_IN	SM_DL_DETACH_SAPI_IN	/* indicate SAPI detach from MX25 entity to SM */
#define SM_X25_DL_SAPI_RS			SM_DL_SAPI_RS			/* response SAPI management to MX25 entity from SM */

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                         */
				/* GENERAL DATA STRUCTURES */
				/*    OF SM PRIMITIVES     */
				/*                         */
				/*-=-=-=-=-=-=-=-=-=-=-=-=-*/

		/*
			SM_REPORT_RQ/IN heading structure :
			This structure is followed by the Origination entity's
			Report data structure (see the Entity's interface itself)
		*/

struct sm_report	{
	ent_id_t		entity_origination;	/* entity ID where the report has been detected */
	uchar			report_type;		/* Type of report message */
};

#define REPORT_TYPE_ERROR		'r'		/* type error */
#define REPORT_TYPE_EVENT		'e'		/* type event */
#define REPORT_TYPE_STATUS		's'		/* type status */

#define	Sm_report_entity_origination	((struct sm_report FAR *)(p_data)) -> entity_origination
#define	Sm_report_report_type			((struct sm_report FAR *)(p_data)) -> report_type


					/*-=-=-=-=-=-*/

		/*
			SM_SET_REPORT_IN structure
		*/

struct sm_set_report {
	uchar			processing;			/* processing to be performed */
										/* ON:  start forwarding SM_REPORT_IN to an entity */
										/* OFF: stop  forwarding SM_REPORT_IN to an entity */
	ent_id_t		forward_entity;		/* entity to which to start/stop forwarding SM_REPORT_IN */
	uchar			report_type;		/* type of records to start/stop forwarding. 0 : all types. */

	ent_id_t		origination_entity;	/* SM_REPORT_IN originating entity. ENT_NIL : all entities. */
	nai_t			origination_nai;	/* SM_REPORT_IN originating nai. NAI_NIL : all nais. */
	sapi_t			origination_sapi;	/* SM_REPORT_IN originating SAPI. SAPI_NIL : all SAPs. */
	add_t			origination_add;	/* SM_REPORT_IN originating address. ADD_NIL: all addresses. */
};

#define	Sm_set_report_processing		((struct sm_set_report FAR *)(p_data)) -> processing
#define	Sm_set_report_forward_entity	((struct sm_set_report FAR *)(p_data)) -> forward_entity
#define	Sm_set_report_report_type		((struct sm_set_report FAR *)(p_data)) -> report_type
#define	Sm_set_report_origination_entity ((struct sm_set_report FAR *)(p_data)) -> origination_entity
#define	Sm_set_report_origination_nai	((struct sm_set_report FAR *)(p_data)) -> origination_nai
#define	Sm_set_report_origination_sapi	((struct sm_set_report FAR *)(p_data)) -> origination_sapi
#define	Sm_set_report_origination_add	((struct sm_set_report FAR *)(p_data)) -> origination_add

#define	Sm_set_report_size				sizeof (struct sm_set_report)

					/*-=-=-=-=-=-*/

		/*
			SM_INFO_RQ/CO heading structure :
			This structure is followed by the Origination entity's
			Information data structure (see the Entity's interface itself)
		*/

struct sm_info {
	ent_id_t		entity_origination;	/* entity ID where the information has been built */
	uchar			info_type;			/* Type of information confirm message */
};

#define Sm_info_entity_origination		((struct sm_info FAR *)p_data) -> entity_origination
#define Sm_info_info_type				((struct sm_info FAR *)p_data) -> info_type

#define INFO_TYPE_STATISTICS	's'		/* type statistics */

					/*-=-=-=-=-=-*/

		/* SM_INFO_RQ/IN/RS/CO structure */

struct sm_info_config {
	ent_id_t	ent_id; 				/* entity ID to which SM sent the configuration message */
	uchar		profile;				/* current profile (ON) or factory configuration (OFF) */
};

#define Sm_info_ent_id					((struct sm_info_config FAR *)p_data) -> ent_id
#define Sm_info_profile					((struct sm_info_config FAR *)p_data) -> profile

#define SM_INFO_SIZE					sizeof (struct sm_info_config)

					/*-=-=-=-=-=-*/

		/* SM_PUT/GET_UPDATE_PAR_IN_RS */

struct sm_update {
	uchar	return_code;				/* return code */
	uchar	val_type;					/* configuration or update value */
	ushort	id;    						/* Update ID */
	uchar	data_length;				/* value length */
	uchar	value;						/* first position of the value */
};

#define Update_return_code				((struct sm_update FAR *)p_data) -> return_code
#define Update_val_type					((struct sm_update FAR *)p_data) -> val_type
#define Update_id						((struct sm_update FAR *)p_data) -> id
#define Update_data_length				((struct sm_update FAR *)p_data) -> data_length
#define Update_a_data					((uchar FAR *)&((struct sm_update FAR *)p_data) -> data_length)
#define Update_a_value		   			((uchar FAR *)&((struct sm_update FAR *)p_data) ->value)
#define UPDATE_SIZE						(sizeof (struct sm_update) - 1)

#define UPDATE_INITIAL_VALUE			'I'
#define UPDATE_VALUE					'U'

#define PROFILE_NIL						(uchar)(~0)     /* NIL profile ID */

					/*-=-=-=-=-=-*/

		/* LIST OF ENTITIES CONFIGURATION STRUCTURES */

struct cfg_update {
	uint		 id;					/* configuration update ID */
	uchar	FAR *p_val;                 /* pointer on the configuration value to update */
	uchar		 length;				/* update parameter size */
};

#define Cfg_update_id(i)				p_cfg_update [i].id
#define Cfg_update_p_val(i)				p_cfg_update [i].p_val
#define Cfg_update_length(i)			p_cfg_update [i].length
#define UPDATE_ID_NIL					((uint)(~0))

		/* STANDARD UPDATE IDs */

#define UPDATE_START_CONFIG_ID			0			/* start of configuration procedure (SM) */
#define UPDATE_STOP_CONFIG_ID			1			/* stop  of configuration procedure (SM) */

#define UPDATE_SELECT_PROFILE_ID		2			/* Select the profile to use at reset time (DTE_INT) */
#define UPDATE_STORE_PROFILE_ID			3			/* store profile number (DTE_INT) */

#define UPDATE_TEI_ID					200			/* TEI update ID (PAD) */

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-=*/
				/*                        */
				/* CONFIRMATION STRUCTURE */
				/*                        */
				/*-=-=-=-=-=-=-=-=-=-=-=-=*/

			/*
				Used to return an acknowledgement or a reject
				(Used in SM_CONFIG_RQ/CO primitives)
			*/

struct confirm {
	uchar	return_code;			/* return code : OK or NOK */
	uchar	cause;					/* cause Id if NOK */
	uchar	diagnostic;				/* diagnostic if NOK */
};

			/* Access using p_data pointer */

#define Confirm_ret_code	((struct confirm FAR *)p_data) -> return_code
#define Confirm_cause		((struct confirm FAR *)p_data) -> cause
#define Confirm_diagnostic	((struct confirm FAR *)p_data) -> diagnostic

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                         */
				/* SERVICES INITIALIZATION */
				/*        STRUCTURE        */
				/*                         */
				/*-=-=-=-=-=-=-=-=-=-=-=-=-*/

struct	i_service {
	char	FAR *part_add;				/* address of the static memory */
	long	part_lgth;					/* size of the static memory */

	uchar	message_lgth;				/* message length */
	ushort	message_nb;					/* number of messages */
	ushort	message_cache_size;			/* size of the message caches */
	ushort	message_low_mark;			/* message congestion control : low mark buffer */
	ushort	message_high_mark;			/* message congestion control : high mark buffer */
	ushort	message_audit_size;			/* size of the message audit array */

	ushort	buffer_lgth;				/* buffer length */
	ushort	buffer_nb;					/* number of buffers */
	ushort	buffer_cache_size;       	/* size of the buffer caches */
	ushort	buffer_low_mark;			/* buffer congestion control : low mark buffer */
	ushort	buffer_high_mark;			/* buffer congestion control : high mark buffer */

	ushort	timer_cell_nb;				/* number of timer cells */
	ushort	timer_cell_cache_size;		/* size of the timer cell caches */
	ushort	timer_system_tick;			/* system tick in milliseconds */
	ushort	timer_precision;			/* precision of a timer in milliseconds */
	ushort	timer_slot_size;			/* number of timer slots */

	ushort	server_nb;					/* number of servers */

	nai_t	na_nb;						/* maximum number of network access */

	uchar	performance;				/* performance flag (ON/OFF) */

};

#define I_message_part_add				p_i_service -> part_add
#define I_message_part_lgth				p_i_service -> part_lgth

#define I_message_lgth					p_i_service -> message_lgth
#define I_message_nb					p_i_service -> message_nb
#define I_message_low_mark				p_i_service -> message_low_mark
#define I_message_high_mark				p_i_service -> message_high_mark
#define I_message_cache_size			p_i_service -> message_cache_size
#define	I_message_audit_size			p_i_service -> message_audit_size

#define I_buffer_lgth					p_i_service -> buffer_lgth
#define I_buffer_nb						p_i_service -> buffer_nb
#define	I_buffer_low_mark				p_i_service -> buffer_low_mark
#define I_buffer_high_mark				p_i_service -> buffer_high_mark
#define I_buffer_cache_size				p_i_service -> buffer_cache_size

#define I_timer_system_tick				p_i_service -> timer_system_tick
#define I_timer_cell_nb					p_i_service -> timer_cell_nb
#define I_timer_cell_cache_size			p_i_service -> timer_cell_cache_size
#define I_timer_precision				p_i_service -> timer_precision
#define I_timer_slot_size				p_i_service	-> timer_slot_size

#define I_server_nb						p_i_service -> server_nb
#define I_na_nb							p_i_service -> na_nb

#define I_performance					p_i_service -> performance

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*      CONFIGURATION    */
				/*       DESCRIPTOR      */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

struct config_descriptor {
	ent_id_t				 entity_id;			/* Entity id */
	uchar				FAR *config_address;	/* Entity's configuration structure address */
	ushort					 config_size;		/* Entity's configuration structure size */
	struct cfg_update	FAR *p_update;			/* pointer on update list */
	uchar					 wait_flag;			/* if ON, SM wait for the SET_CONFIG_CO before continuing */
};

		/* Access thru p_config table : */

#define Config_entity_id	p_config_descriptor -> entity_id
#define Config_address		p_config_descriptor -> config_address
#define Config_size			p_config_descriptor -> config_size
#define Config_p_update		p_config_descriptor -> p_update
#define Config_wait_flag	p_config_descriptor -> wait_flag

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-=*/
				/*                        */
				/* COMPILATION PARAMETERS */
				/*       STRUCTURE        */
				/*                        */
				/*-=-=-=-=-=-=-=-=-=-=-=-=*/

	/* Used to keep track of the Compile-time flags values */

struct compile_param {
	uchar	compiler;						/* compiler   : TC , MSC, IT, LA , IC86, MT68, CC, C_TMS320, C_TI_MVP */
	uchar	os;								/* OS         : MS_DOS, VRTX, UNIX, PSOS , RTC86, AMX, MTR86... */
	ushort	cpu;							/* Target CPU : INTEL(1 & 2), MOTOROLA (1 & 2), SPARC, AMD29000, TMS320, TI_MVP */
	uchar	equipment;						/* equipment : TE (terminal) or NT2 (network termination 2) */
	uchar	optimization;					/* optimization : SPEED, SIZE, MIXED */
	uchar	assert;							/* assert test ON or OFF */
	uchar	message_cache;					/* message cache ON or OFF */
	uchar	buffer_cache;					/* buffer cache ON or OFF */
	uchar	timer_it;						/* timer IT handler (ON) or timer process (OFF) */
	uchar	timer_cell_cache;				/* timer cell cache */
	uchar	block_counting;					/* block counting facilities : ON or OFF */
	uchar	message_cong_control;			/* congestion control ON or OFF */
	uchar	buffer_cong_control;			/* congestion control ON or OFF */
	uchar	message_audit;					/* message audit ON or OFF */
	uchar	message_send_data; 				/* Information data in message */

#	if MESSAGE_AUDIT == ON
		ushort	message_audit_size;			/* size of the message audit array */
		ushort	message_audit_data_lgth; 	/* size of the message or buffer data to store in the audit array */
#	endif

};

		/* Access thru p_compile_param structure : */

#define		I_Compiler					((struct compile_param FAR *)p_compil_param)->compiler
#define		I_I_Os						((struct compile_param FAR *)p_compil_param)->os
#define		I_Cpu						((struct compile_param FAR *)p_compil_param)->cpu
#define		I_Equipment					((struct compile_param FAR *)p_compil_param)->equipment
#define		I_Optimization				((struct compile_param FAR *)p_compil_param)->optimization
#define		I_Assert					((struct compile_param FAR *)p_compil_param)->assert
#define		I_Message_cache				((struct compile_param FAR *)p_compil_param)->message_cache
#define		I_Buffer_cache				((struct compile_param FAR *)p_compil_param)->buffer_cache
#define		I_Timer_it					((struct compile_param FAR *)p_compil_param)->timer_it
#define		I_Timer_cell_cache			((struct compile_param FAR *)p_compil_param)->timer_cell_cache
#define		I_Block_counting			((struct compile_param FAR *)p_compil_param)->block_counting
#define		I_Message_cong_control		((struct compile_param FAR *)p_compil_param)->message_cong_control
#define		I_Buffer_cong_control		((struct compile_param FAR *)p_compil_param)->buffer_cong_control
#define		I_Message_audit				((struct compile_param FAR *)p_compil_param)->message_audit
#define		I_Message_send_data			((struct compile_param FAR *)p_compil_param)->message_send_data

#if MESSAGE_AUDIT == ON
#	define	I_Message_audit_size		((struct compile_param FAR *)p_compil_param)->message_audit_size
#	define	I_Message_audit_data_lgth	((struct compile_param FAR *)p_compil_param)->message_audit_data_lgth
#endif

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*     COMMON  CONTEXT   */
				/*        VARIABLES      */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

		extern	uint				performance;	/* performance flag (ON/OFF) */

#define External_common 																					\
		extern	code_t 				event_id; 		/* event identifier */									\
		extern	uchar 				ret_code;   	/* return code */										\
		extern	struct 	message FAR	*p_snd_msg; 	/* pointer on the current message to send if any */		\
		extern	struct	message FAR	*p_rcv_msg; 	/* pointer on the current received message if any */	\
		extern	struct 	buffer  FAR	*p_buffer;		/* pointer on the curent buffer if any */				\
		extern	uchar   		FAR	*p_buffer_end;	/* pointers on the end of the current buffer if any */	\
		extern	int					os_err			/* OS error code */

#if SIMULATION == OFF

#	define Server_common	struct d_u_m_m_y {char a;}		/* dummy declaration line */

#	define Entity_common(entity_name) 																			\
		code_t 				 Paste(event_id_,entity_name);	/* event identifier */								\
		uchar 				 Paste(ret_code_,entity_name);	/* return code */									\
		struct 	message FAR	*Paste(p_snd_msg_,entity_name); /* pointer on the current message to send if any */	\
		struct	message FAR	*Paste(p_rcv_msg_,entity_name);	/* pointer on the current received message if any */\
		struct 	buffer  FAR	*Paste(p_buffer_,entity_name);	/* pointer on the curent buffer if any */			\
		uchar   		FAR	*Paste(p_buffer_end_,entity_name);/* pointers on the end of the current buffer */	\
		int					 Paste(os_err_,entity_name)		/* OS error code */

#else

#	define Entity_common(entity_name)			External_common

#	define Server_common 																			\
		code_t 				event_id; 			/* event identifier */								\
		uchar 				ret_code;       	/* return code */									\
		struct 	message FAR	*p_snd_msg;   		/* pointer on the current message to send if any */	\
		struct	message FAR	*p_rcv_msg; 		/* pointer on the current received message if any */\
		struct 	buffer  FAR	*p_buffer;			/* pointer on the curent buffer if any */			\
		uchar   		FAR	*p_buffer_end		/* pointers on the end of the current buffer */		\

#endif

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/* SERVERS MAIN FUNCTION */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#if SIMULATION == ON

#	define Begin_server(name, p_entity, qid, p_from, flag_list)													\
		void main (nb_arg, tab_p_arg)																			\
		int 	nb_arg;																							\
		char 	*tab_p_arg[];																					\
	{																											\
		p_snd_msg = P_NIL;																						\
		p_rcv_msg = P_NIL;																						\
		p_buffer  = P_NIL;																						\
		simul_init (nb_arg, tab_p_arg, p_from, flag_list);														\
		sm_services_init ();																					\
		p_rcv_msg = Alloc_msg ();																				\
		Server_init (qid, p_entity);																			\
		if (sm (p_rcv_msg) == NOK) {																			\
			Trap (TRAP_SM_INIT, "Init_server");																	\
		}

#else

#	if BEGIN_WITH_MSG != ON

#		if OS != OMNITEL_OS

#			define Begin_server(name, p_entity, qid, p_from, flag_list)											\
				int name ()																						\
				{																								\
					struct	message FAR	*p_rcv_msg = P_NIL; /* pointer on the current received message if any */\
					Server_init (qid, p_entity)				/* initialize the server */

#		else

#			define Begin_server(name, p_entity, qid, p_from, flag_list)											\
				void name ()																					\
				{																								\
					Server_init (qid, p_entity)				/* initialize the server */

#		endif

#	else

#		if (OS == AMX)

#			if (OS_RELEASE == I86_V2)
#				define Begin_server(name, p_entity, qid, p_from, flag_list)										\
					void	name (param)																		\
						uchar	param;																			\
					{																							\
						struct	message FAR	*p_rcv_msg; 	/* pointer on the current received message if any */\
						p_rcv_msg = get_message_and_put_in_fifo ((uchar FAR * FAR *)&param);					\
						if (p_rcv_msg == P_NIL) {																\
							qid = ajgetn ();																	\
							Server_init (qid, p_entity);														\
						}

#			endif

#			if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
#				define Begin_server(name, p_entity, qid, p_from, flag_list)										\
					void	name (param)																		\
						int	param;																				\
					{																							\
						struct	message FAR	*p_rcv_msg; 	/* pointer on the current received message if any */\
						p_rcv_msg = get_message_and_put_in_fifo ((uchar FAR * FAR *)&param);					\
						if (p_rcv_msg == P_NIL) {																\
							qid = ajtkid ();																	\
							Server_init (qid, p_entity);														\
						}
#			endif

#		endif

#		if (OS == IMECOM_OS)
#			define Begin_server(name, p_entity, qid, p_from, flag_list)											\
				void	name (param)																			\
					uchar FAR * FAR *param;																		\
				{																								\
					struct	message 	FAR	*p_rcv_msg; 	/* pointer on the current received message if any */\
					p_rcv_msg = get_message_and_put_in_fifo (param);											\
					if (p_rcv_msg == P_NIL) {																	\
						Server_init (qid, p_entity);															\
					}
#		endif

#		if (OS == WINDOWS_NT) || (OS == WINDOWS_95)
#			define Begin_server(name, p_entity, qid, p_from, flag_list)										\
				void	name (param)																		\
					int	param;																				\
				{																							\
					struct	message FAR	*p_rcv_msg; 	/* pointer on the current received message if any */\
					p_rcv_msg = get_message_and_put_in_fifo ((uchar FAR * FAR *)&param);					\
					if (p_rcv_msg == P_NIL) {																\
						Server_init (qid, p_entity);														\
					}
#		endif

#		if (OS == RISC_OS)
#			define Begin_server(name, p_entity, qid, p_from, flag_list) \
				void	name (param)						\
					uchar param;							\
				{											\
					struct	message FAR *p_rcv_msg = P_NIL;	\
					if (param == ON) {						\
						Server_init (qid, p_entity);		\
					}										\
					It_disable ()
#		endif

#	endif

#endif

						/*------------------*/

#if SIM_ANALYSER == ON
#	define Pr_rcv_msg 	pr_message (p_rcv_msg, OFF)	/* print the received message */

#else

#	define Pr_rcv_msg
#endif

						/*------------------*/

#if OS != OMNITEL_OS
#	define Server_loop(qid)													\
																			\
				/* Process an incoming event */								\
																			\
			while ((p_rcv_msg = Receive_message (qid)) != P_NIL) {			\
				p_ent_fct_t p_fct;                                          \
																			\
				Pr_rcv_msg;													\
																			\
				if ((R_msg_to < ENTITY_ID_MIN) ||                           \
					(R_msg_to > ENTITY_ID_MAX) ||                           \
					((p_fct = Get_entity_p_fct (R_msg_to)) == (p_ent_fct_t)P_NIL)) {     \
					Trap (TRAP_NOT_IMPLEMENTED_ENTITY, "Server function");	\
				}															\
																			\
					/* Call the entity function */							\
																			\
				(*p_fct) (p_rcv_msg);										\
																			\
			}

#else
#	define Server_loop(qid)	/* the scheduling loop is in ob_init/omni_os/ob_main.c */
#endif
						/*------------------*/

#define Server_main(name, p_server_def_ent, qid, spare, p_from, flag_list)	\
		Begin_server (name, p_server_def_ent, qid, p_from, flag_list);		\
			Server_loop  (qid)												\
		}


/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  SERVERS  DEFINITION  */
				/*       STRUCTURES      */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/


	/* Entity function entry point typedef */

#if NEW_FCT_STYLE == ON
	typedef		uchar (FAR *p_ent_fct_t) (struct message FAR *p_msg);
#else
	typedef		uchar (FAR *p_ent_fct_t) ();
#endif

	/* Server definition structure */

struct server_def {
	ent_id_t		entity_id;      		/* entity ID */
	p_ent_fct_t		p_fct;					/* entity function entry point */
	uchar			congestion_off;			/* if congestion off send clear busy message */
	uchar			congestion_on;			/* if congestion on send busy message */

#	if NEW_FCT_STYLE == ON
		void		(FAR *p_init_fct) (void);	/* entity variables initialization function */
#	else
		void		(FAR *p_init_fct) ();		/* entity variables initialization function */
#	endif

};

#define	Server_def_entity_id			(p_server_def -> entity_id)
#define	Server_def_p_fct				(p_server_def -> p_fct)
#define	Server_def_congestion_off		(p_server_def -> congestion_off)
#define Server_def_congestion_on		(p_server_def -> congestion_on)
#define	Server_def_p_init_fct			(p_server_def -> p_init_fct)

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*    INTERNAL SERVERS   */
				/*       STRUCTURES      */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

				/* Entity control block */

struct entity_descriptor {
	uchar		x_server;				/* Entity index to server descriptor */
	uchar		congestion_off;			/* congestion OFF flag */
	uchar		congestion_on;			/* congestion ON flag */
	p_ent_fct_t	p_ent_fct;				/* entity entry point */
};

#define Ed_entity_id_to_x(ent_id)		(ent_id - ENTITY_ID_MIN)				/* relative entity number for table access */
#define Ed_x_to_entity_id(x)			(ent_id_t)(x + ENTITY_ID_MIN)
#define Ed_x_max						(ENTITY_ID_MAX - ENTITY_ID_MIN)

#define Entity_to_server(ent_id)	   	p_entity_descriptor[Ed_entity_id_to_x(ent_id)].x_server
#define Entity_congestion_off(ent_id)  	p_entity_descriptor[Ed_entity_id_to_x(ent_id)].congestion_off
#define Entity_congestion_on(ent_id)	p_entity_descriptor[Ed_entity_id_to_x(ent_id)].congestion_on
#define Entity_p_fct(ent_id)	   		p_entity_descriptor[Ed_entity_id_to_x(ent_id)].p_ent_fct

#define SERVER_ENTITY_X_NIL				255					/* NIL index for p_server_entity table */

				/* Is the entity in the system - called from server */

#define Entity_in_system(ent_id)		((Entity_to_server_access (ent_id) == SERVER_ENTITY_X_NIL) ? OFF : ON)

				/* Server control block */

struct server {
	uint			   qid;				/* server queue ID */
	struct message FAR *p_first;		/* internal FIFO first message */
	struct message FAR *p_last;			/* internal FIFO last message */
};

#define Server_qid(x)					p_server[x].qid
#define Server_fifo_p_first(x)			p_server[x].p_first
#define Server_fifo_p_last(x)			p_server[x].p_last

				/* Get queue ID and p_fifo from entity ID */

#define Entity_to_qid(ent_id)   		Server_qid			(Entity_to_server (ent_id))
#define Entity_to_fifo_p_first(ent_id)	Server_fifo_p_first (Entity_to_server (ent_id))
#define Entity_to_fifo_p_last(ent_id)	Server_fifo_p_last	(Entity_to_server (ent_id))

/*--------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/* FUNCTIONS  PROTOTYPES */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/


#if NEW_FCT_STYLE == ON /* { */

			/* System management functions */

	uchar				sm							(struct message FAR *p_msg);
	void				sm_var_init					(void);
	uchar				sm_msg_process				(struct message FAR *p_msg);

			/* OS service functions */

	uchar 				FAR *mem_alloc				(ushort lgth,		uchar pid);
	void				mem_free					(char FAR *p_add,	uchar pid);

	void 				os_send_message				(uint qid, struct message FAR *p_msg);
	struct message FAR	*os_receive_message			(uint qid);

	void				lock_resource				(int resource_id);
	void				unlock_resource				(int resource_id);

	long				system_time					(void);
	void				timer_delay					(long delay);

	void				os_start_timer				(unsigned long timer_val);
	void				os_stop_timer				(void);

			/* Timer management functions */

	uchar 				FAR *timer_alloc			(ent_id_t entity_id, nai_t nai, sapi_t sapi, add_t add);
	void 				timer_free					(uchar FAR *timer_id);
	void 				timer_start					(uchar FAR *timer_id, timer_val_t to_val, uchar ns, code_t ev_id);
	void 				periodic_timer_start		(uchar FAR *timer_id, timer_val_t to_val, void (FAR *p_fct) (ulong param), ulong fct_param);
	void 				timer_stop					(uchar FAR *timer_id);

#	if	OS == AMX
		void			timer_process				(void);
		void			timer_system_tick_proc		(void);

#	else

		int 			timer_process				(void);
#	endif

	void				timer_it					(void);
	void				timer_handler				(void);


#	if ASSERT == ON

			/* Check functions */

		uchar FAR *		check_rel_blk				(uchar FAR *p_blk, uchar blk_type);
		void			add_blk						(uchar FAR *p_blk, uchar blk_type);

#	endif

#	if (SIM_BUILDER == ON) || (SIM_ANALYSER == ON)

			/* Simulation functions */

#		if SIM_BUILDER == ON
			struct 	message FAR *simul_message		(void);
#		endif

#		if SIM_ANALYSER == ON
			void 			pr_message				(struct message FAR *p_msg, uchar out_flag);
#		endif

#	else
			/* Main functions */

#		if BEGIN_WITH_MSG == ON

#			if OS == AMX

#				if (OS_RELEASE == I86_V2)
					void		server			 	(uchar param);
					void		s1234 		 		(uchar param);
					void 		s123				(uchar param);
					void 		s23 				(uchar param);
					void 		s2 					(uchar param);
					void 		s3 					(uchar param);
					void		s4					(uchar param);
#				endif

#				if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
					void		server			 	(int param);
					void		s1234 		 		(int param);
					void 		s123				(int param);
					void 		s23 				(int param);
					void 		s2 					(int param);
					void 		s3 					(int param);
					void		s4					(int param);
#				endif

#			endif

#			if OS == IMECOM_OS

				void		server			 		(uchar FAR * FAR *param);
				void		s1234 		 			(uchar FAR * FAR *param);
				void 		s123					(uchar FAR * FAR *param);
				void 		s23 					(uchar FAR * FAR *param);
				void 		s2 						(uchar FAR * FAR *param);
				void 		s3 						(uchar FAR * FAR *param);
				void		s4						(uchar FAR * FAR *param);

#			endif


#		else

			int				server			 		(void);
			int				s1234 		 			(void);
			int 			s123					(void);
			int 			s23 					(void);
			int 			s2 						(void);
			int 			s3 						(void);
			int				s4						(void);

#		endif

		struct message FAR *get_message_and_put_in_fifo	(uchar FAR * FAR *p_param);

#	endif

			/* SERVICES functions */

	void				services_var_init			(void);

	uchar				services_init				(struct i_service FAR *p_i_service);
	uchar				sm_services_init			(void);
	uchar				server_init					(uint qid, CONST struct server_def FAR *p_server_def);

	struct message FAR	*alloc_msg					(void);
	void 				free_msg					(struct message FAR *p_msg);

	struct buffer FAR	*alloc_buffer				(void);
	void 				free_buffer					(struct buffer FAR *p_buff);

	struct timer_cell 	FAR *alloc_timer_cell 		(void);
	void 				free_timer_cell				(struct timer_cell FAR *p_cell);

	void				free_memory_cache 			(void);

	uchar				congestion_busy				(void);
	void				test_and_set_congestion 	(uchar it_status);
	void				test_and_reset_congestion 	(uchar it_status);
	void				send_busy					(code_t primitive_code, uchar it_flag);

	void 				o_send_message				(struct message FAR *p_msg);
	struct message FAR	*receive_message			(uint qid);

	struct message FAR	*msg_or_buffer				(struct buffer FAR *p_buffer, uchar hole_size);
	void				prepare_data_to_send		(struct message FAR * FAR *a_p_msg, struct buffer FAR * FAR *a_p_buffer, ushort data_lgth, uchar FAR * FAR *a_p_data);

	void				msg_audit_in				(char direction, struct message FAR *p_msg);
	uchar				msg_audit_filtering			(char direction, struct message FAR *p_msg);
	void				msg_capture					(char direction, struct message FAR *p_msg);

#	if (SIMULATION == ON) || (ASSERT == ON)
#		if OS == MVP_ME
			void 		otrap						(ushort code, char diagnostic_string[]);
#		else
			void 		trap						(ushort code, char diagnostic_string[]);
#		endif
#	else
#		if OS == MVP_ME
			void 		otrap						(ushort code);
#		else
			void 		trap						(ushort code);
#		endif
#	endif

	void 				abort_omnitel				(void);

	ushort				memcmp_far					(char FAR *p_to, char FAR *p_from, ushort n);
	int					strcmp_far					(char FAR *s1,   char FAR *s2);
	uint 				move_str_far				(char FAR *p_to, char FAR *p_from, ushort mx_sz);

#	ifdef FAST_MEM_ACCESS
		void		FAR	fast_memcpy					(char FAR *p_to, char FAR *p_from, ushort n);
		void 		FAR	fast_memset					(char FAR *p_to, char val, ushort lgth);

#	else

		void 			memcpy_far 					(char FAR *p_to, char FAR *p_from, ushort n);
		void 			memset_far					(char FAR *p_to, char val, ushort lgth);
#	endif

	uchar				entity_to_server_access		(ent_id_t ent_id);
	uchar				entity_congestion_flag		(ent_id_t ent_id, uchar type);

	int					rand_omnitel 				(void);
	void 				srand_omnitel				(long seed);

			/* UNIX like general functions */

#	if OS == UNIX
		int				kbhit						(void);
		double			difftime					(long new_time, long old_time);
#	endif

			/* CPU LEVEL */

	ushort				read_buffer_lgth			(void);
	uchar				read_message_lgth			(void);
	nai_t				read_na_nb					(void);
	ushort				read_i_services				(struct i_service FAR *p_i_service);
	ushort				read_timer_system_tick		(void);
	p_ent_fct_t			get_entity_p_fct			(ent_id_t ent_id);


#endif /* } */

#if NEW_FCT_STYLE == OFF /* { */

			/* System management functions */

	uchar				sm							();
	void				sm_var_init					();
	uchar				sm_msg_process				();

			/* OS service functions */

	uchar 				FAR *mem_alloc				();
	void				mem_free					();

	void 				os_send_message				();
	struct message FAR	*os_receive_message			();

	void				lock_resource				();
	void				unlock_resource				();

	long				system_time					();
	void				timer_delay					();

	void				os_start_timer				();
	void				os_stop_timer				();

			/* Timer management functions */

	uchar 				FAR *timer_alloc			();
	void 				timer_free					();
	void 				timer_start					();
	void 				periodic_timer_start		();
	void 				timer_stop					();

#	if	OS == AMX
		void			timer_process				();
		void			timer_system_tick_proc		();

#	else

		int 			timer_process				();
#	endif

	void				timer_it					();
	void				timer_handler				();


#	if ASSERT == ON

			/* Check functions */

		uchar FAR *		check_rel_blk				();
		void			add_blk						();

#	endif

#	if (SIM_BUILDER == ON) || (SIM_ANALYSER == ON)

			/* Simulation functions */

#		if SIM_BUILDER == ON
			struct 	message FAR *simul_message		();
#		endif

#		if SIM_ANALYSER == ON
			void 			pr_message				();
#		endif

#	else
			/* Main functions */

#		if BEGIN_WITH_MSG == ON

#			if OS == AMX

#				if (OS_RELEASE == I86_V2)
					void		server			 	();
					void		s1234 		 		();
					void 		s123				();
					void 		s23 				();
					void 		s2 					();
					void 		s3 					();
					void		s4					();
#				endif

#				if (OS_RELEASE == MC68000_V2) || (OS_RELEASE == I86_V3) || (OS_RELEASE == I386_V1)
					void		server			 	();
					void		s1234 		 		();
					void 		s123				();
					void 		s23 				();
					void 		s2 					();
					void 		s3 					();
					void		s4					();
#				endif

#			endif

#			if OS == IMECOM_OS

				void		server			 		();
				void		s1234 		 			();
				void 		s123					();
				void 		s23 					();
				void 		s2 						();
				void 		s3 						();
				void		s4						();

#			endif

			struct message FAR *get_message_and_put_in_fifo	();

#		else

			int				server			 		();
			int				s1234 		 			();
			int 			s123					();
			int 			s23 					();
			int 			s2 						();
			int 			s3 						();
			int				s4						();

#		endif

#	endif

			/* SERVICES functions */

	void				services_var_init			();

	uchar				services_init				();
	uchar				sm_services_init			();
	uchar				server_init					();

	struct message FAR	*alloc_msg					();
	void 				free_msg					();

	struct buffer FAR	*alloc_buffer				();
	void 				free_buffer					();

	struct timer_cell 	FAR *alloc_timer_cell 		();
	void 				free_timer_cell				();

	void				free_memory_cache 			();

	uchar				congestion_busy				();
	void				test_and_set_congestion 	();
	void				test_and_reset_congestion 	();
	void				send_busy					();

	void 				o_send_message				();
	struct message FAR	*receive_message			();

	struct message FAR	*msg_or_buffer				();
	void				prepare_data_to_send		();

	void				msg_audit_in				();
	uchar				msg_audit_filtering			();
	void				msg_capture					();

#	if (SIMULATION == ON) || (ASSERT == ON)
#		if OS == MVP_ME
			void 		otrap						();
#		else
			void 		trap						();
#		endif
#	else
#		if OS == MVP_ME
			void 		otrap						();
#		else
			void 		trap						();
#		endif
#	endif

	void 				abort_omnitel				();

	ushort				memcmp_far					();
	int					strcmp_far					();
	uint 				move_str_far				();

#	ifdef FAST_MEM_ACCESS
		void		FAR	fast_memcpy					();
		void 		FAR	fast_memset					();

#	else

		void 			memcpy_far 					();
		void 			memset_far					();
#	endif

	uchar				entity_to_server_access		();
	uchar				entity_congestion_flag		();

	int					rand_omnitel 				();
	void 				srand_omnitel				();

			/* UNIX like general functions */

#	if OS == UNIX
		int				kbhit						();
		double			difftime					();
#	endif

			/* CPU LEVEL */

	ushort				read_buffer_lgth			();
	uchar				read_message_lgth			();
	nai_t				read_na_nb					();
	ushort				read_i_services				();
	ushort				read_timer_system_tick		();
	p_ent_fct_t			get_entity_p_fct			();

#endif /* } OLD STYLE FUNCTION */

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*  'ctype.h' EMULATION  */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#define _IS_SP	1					/* is space */
#define _IS_DIG	2					/* is digit indicator */
#define _IS_UPP	4					/* is upper case */
#define _IS_LOW	8					/* is lower case */
#define _IS_HEX	16					/* [A-F] or [a-f] */
#define _IS_CTL	32					/* Control */
#define _IS_PUN	64					/* punctuation */

extern CONST_ARRAY	uchar  _ctype_omnitel[];	/* Character type array */

#define Isalnum(c)	(_ctype_omnitel[(c) + 1] & (_IS_DIG | _IS_UPP | _IS_LOW))
#define Isalpha(c)	(_ctype_omnitel[(c) + 1] & (_IS_UPP | _IS_LOW))
#define Isascii(c)	((unsigned)(c) < 128)
#define Iscntrl(c)	(_ctype_omnitel[(c) + 1] & _IS_CTL)
#define Isdigit(c)	(_ctype_omnitel[(c) + 1] & _IS_DIG)
#define Isgraph(c)	((c) >= 0x21 && (c) <= 0x7e)
#define Islower(c)	(_ctype_omnitel[(c) + 1] & _IS_LOW)
#define Isprint(c)	((c) >= 0x20 && (c) <= 0x7e)
#define Ispunct(c)	(_ctype_omnitel[(c) + 1] & _IS_PUN)
#define Isspace(c)	(_ctype_omnitel[(c) + 1] & _IS_SP)
#define Isupper(c)	(_ctype_omnitel[(c) + 1] & _IS_UPP)
#define Isxdigit(c)	(_ctype_omnitel[(c) + 1] & (_IS_DIG | _IS_HEX))
#define Toupper(c)	(Islower(c) ? (c) - 'a' + 'A' : (c))
#define Tolower(c)	(Isupper(c) ? (c) - 'A' + 'a' : (c))

/*-------------------------------------------------------------------------*/

				/*-=-=-=-=-=-=-=-=-=-=-=-*/
				/*                       */
				/*     VRTX INTERFACE    */
				/*                       */
				/*-=-=-=-=-=-=-=-=-=-=-=-*/

#if OS == VRTX

			/* VRTX header constant definitions */

#	define WORD 			short
#	define BYTE    			char
#	define FPTR				char FAR *
#	define STATRP			char FAR *
#	define DWORD			long

			/* VRTX CPU */

#	if (OM_CPU == INTEL_1) || (OM_CPU == INTEL_2)
#		define IAPX86
#	endif

#	if (OM_CPU == MOTOROLA_1) || (OM_CPU == MOTOROLA_2)
#		define M68K
#	endif

#endif

/*-------------------------------------------------------------------------*/

#endif /* SERVICES_H */

/*EOF*/
