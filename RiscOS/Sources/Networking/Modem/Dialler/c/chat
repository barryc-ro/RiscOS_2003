/* File:    chat.c
 * Purpose: Process scripts
 * Author:  DN Walker, Ben Laughton
 * History:
 *
 * 1996-12-18: BAL
 * Inherited from DN Walker, based on UNIX chat.
 *
 * 1997-03-21: BAL
 * *commands now called with _kernel_system rather than SWI OS_CLI to stop
 * Dialler's code being overwritten in command is a program!
 *
 * 1997-04-25: BAL
 * Undid previous change because it was causing even more problems, so now
 * can't invoke other programs from script.
 *
 * 1997-05-07: BAL
 * Major rewrite of chat_do_script and chat_expect routines and script command
 * handling.
 *
 * 1998-02-17: BAL
 * New status code for user-defined abort strings.
 *
 * 1998-04-21: BAL
 * Fixed a memory trample in do_command - was doing malloc (argc + 1) instead
 * of malloc (sizeof (char *) * (argc + 1)).
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include <ctype.h>
#include "kernel.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "swis.h"

/* OSLib - used for definitions only */
#include "OS:osargs.h"
#include "OS:osgbpb.h"

/* #include "MemCheck:MemCheck.h" */

/* Dialler */
#include "bool.h"
#include "chat.h"
#include "dialler.h"
#include "error.h"
#include "flags.h"
#include "handlers.h"
#include "header.h"
#include "list.h"
#include "log.h"
#include "module.h"
#include "script.h"
#include "serial.h"
#include "status.h"
#include "timeout.h"
#include "utils.h"

#ifdef BLOCKDRIVERS
  #include "driver.h"
#endif




/* =============================================================================
 * Define contants
 */

enum    /* results from read_script function */
{
    ReadScript_EndOfScript,
    ReadScript_ScriptError,
    ReadScript_SystemError,
    ReadScript_OK
};

enum    /* results from do_command function */
{
    Command_NotCommand,
    Command_Done,
    Command_Error
};

enum    /* results from command handler functions */
{
    CommandHandler_OK,
    CommandHandler_Error
};

enum    /* results from chat_expect and chat_send functions */
{
    Script_DoneString,
    Script_Callback,
    Script_Abort,
    Script_Timeout
};

#define STR_LEN 1024    /* maximum length of a line in a script */
#define AbortString_Base 6

enum
{
    ReadScript_ReadScript,
    ReadScript_Reset,
    ReadScript_SkipLine
};




/* =============================================================================
 * Define macros
 */

#define M_isoctal(c) (((c) >= '0') && ((c) <= '7'))




/* =============================================================================
 * Define types
 */

typedef struct _string_list
{
    char *string;
    struct _string_list *next;
} string_list;

/* The following stucture describes the commands that can be used in a chat
 * script:
 * cmd_name: name of command (or what it starts with)
 * num_args: number of parameters taken by command
 *           (-1 -> cmd_name is string that command starts with)
 * cmd_func: pointer to function to deal with this command
 */
struct cmd
{
    char *cmd_name;
    int num_args;
    int (*cmd_func)(char **);
};




/* =============================================================================
 * Declare function prototypes
 */

static char *read_script (const unsigned int reason_code, int *const result);
static int do_command (const char *const string);
static int abort_command_handler (char **argv);
static int report_command_handler (char **argv);
static int timeout_command_handler (char **argv);
static int connection_timeout_command_handler (char **argv);
static int default_command_handler (char **argv);
static int system_command_handler (char **argv);
static int comment_command_handler (char **argv);
static int status_command_handler (char **argv);
static int chat_expect (char *s);
static char *character (char c);
static int chat_send (char *s);
static int put_string (char *s);
static int get_string (char *string);
static char *clean (register char *s, const int sending);
char *instrn (register const char *cs, register const char *ct,
              const size_t n1, const size_t n2,
              char **last, int *const remaining);
static void character_string (const char *const label,
                              const char *string,
                              int len);
#ifdef DEBUG
  static void write_ascii (const char *const s, int n);
#endif
static void string_list_free (void *  string);
static int string_list_match (
                        list_handle        list,
                        const char *const  buffer,
                        const int          buffer_len,
                        char **const       list_match,
                        char **const       buffer_match,
                        int *const         partial);




/* =============================================================================
 * Declare global variables
 */

static struct cmd script_command[] =
{
    {"ABORT", 1, abort_command_handler},
    {"REPORT", 1, report_command_handler},
    {"TIMEOUT", 1, timeout_command_handler},
    {"CONNECTION_TIMEOUT", 1, connection_timeout_command_handler},
    {"*", -1, system_command_handler},
    {"DEFAULT", 2, default_command_handler},
    {"#", -1, comment_command_handler},
    {"STATUS", 1, status_command_handler},
    {NULL, 0, NULL}    /* NULL entry terminates list */
};

int chat_do_script_pending = false;
static char *std_abort_string[] =
{
    "NO CARRIER",
    "ERROR",
    "NO DIALTONE",
    "BUSY",
    "NO ANSWER"
};
static int num_std_abort_strings;

static list_handle  abort_list = NULL;
static list_handle  report_list = NULL;




/* =============================================================================
 * Define functions
 */

/* -----------------------------------------------------------------------------
+
   chat_abort
-
 */

#if 0
extern void chat_abort (void)
{
    chat_expect (NULL);
    chat_send (NULL);
    get_string (NULL);
    put_string (NULL);
    chat_do_script (NULL, NULL);
}
#endif




/* -----------------------------------------------------------------------------
+
   chat_do_script

   Execute a script.  This routine is always called via a transient callback.

   Inputs
   r:  pointer to register bank
   pw: value of R12 specified in OS_AddCallBack

   Returns
   NULL
-
 */

extern _kernel_oserror *chat_do_script (_kernel_swi_regs *r, void *pw)
{
    enum
    {
        ChatState_ReadScript,
        ChatState_ExpectString,
        ChatState_SendString,
        ChatState_Abort,
        ChatState_CompletedScript
    };
    enum
    {
        Expect,
        Send
    };
    static char *string;
    static int chat_state = ChatState_ReadScript;
    static int expect_or_send = Expect;


    chat_do_script_pending = false;

    /* Special case: if this routine is called directly with both arguments
     * NULL then an external reset condition has occurred, such as the hangup
     * script being executed in the middle of a dial script.
     */
    if (r == NULL && pw == NULL)
    {
        chat_state = ChatState_ReadScript;
        return NULL;
    }

    for (;;)
    {
        M_debug (("chat state = %d", chat_state));

        switch (chat_state)
        {
            case ChatState_ReadScript:
            {
                int result;

                string = read_script (ReadScript_ReadScript, &result);
                switch (result)
                {
                    case ReadScript_EndOfScript:
                        chat_state = ChatState_CompletedScript;
                        break;

                    case ReadScript_OK:
                        if (expect_or_send == Expect)
                        {
                            int result = do_command (string);

                            switch (result)
                            {
                                case Command_Done:
                                    chat_state = ChatState_ReadScript;
#if defined Daytona
                                    break;
#else
                                    handlers_add_callafter (5);
                                    return NULL;
#endif

                                case Command_NotCommand:
                                    chat_state = ChatState_ExpectString;
                                    break;

                                case Command_Error:
                                    chat_state = ChatState_Abort;
                                    break;

                                default:
                                    M_debug ((
                                        "invalid result from do_command: %d",
                                        result));
                                    chat_state = ChatState_Abort;
                                    break;
                            }
                        }
                        else
                            chat_state = ChatState_SendString;
                        break;

                    case ReadScript_SystemError:
                        chat_state = ChatState_Abort;
                        break;

                    case ReadScript_ScriptError:
                        M_status_set (Dialler_AbortedScript_Syntax);
                        chat_state = ChatState_Abort;
                        break;

                    default:
                        M_debug (("invalid result from read_script: %d",
                                  result));
                        chat_state = ChatState_Abort;
                        break;
                }
                break;
            }

            case ChatState_ExpectString:
            {
                int result = chat_expect (string);

                switch (result)
                {
                    case Script_DoneString:
                        expect_or_send = Send;
                        chat_state = ChatState_ReadScript;
#if defined Daytona
                        break;
#else
                        handlers_add_callafter (5);
                        return NULL;
#endif

                    case Script_Callback:
                        chat_state = ChatState_ExpectString;
                        return NULL;

                    case Script_Abort: case Script_Timeout:
                        chat_state = ChatState_Abort;
                        break;

                    default:
                        chat_state = ChatState_Abort;
                        M_debug (("invalid result from chat_expect: %d",
                                  result));
                        break;
                }
                break;
            }

            case ChatState_SendString:
            {
                int result = chat_send (string);

                switch (result)
                {
                    case Script_DoneString:
                        expect_or_send = Expect;
                        chat_state = ChatState_ReadScript;
#if defined Daytona
                        break;
#else
                        handlers_add_callafter (5);
                        return NULL;
#endif

                    case Script_Callback:
                        chat_state = ChatState_SendString;
                        return NULL;

                    case Script_Abort:
                    case Script_Timeout:
                        chat_state = ChatState_Abort;
                        break;

                    default:
                        chat_state = ChatState_Abort;
                        M_debug (("invalid result from chat_send: %d", result));
                        break;
                }
                break;
            }

            case ChatState_Abort:
                read_script (ReadScript_Reset, NULL);
                script_abort (true);
                chat_state = ChatState_ReadScript;
                return NULL;

            case ChatState_CompletedScript:
                read_script (ReadScript_Reset, NULL);
                script_completed ();
                chat_state = ChatState_ReadScript;
                return NULL;

            default:
                M_debug (("chat_do_script state machine in invalid state: %d",
                          chat_state));
                chat_state = ChatState_Abort;
                break;
        }
    }
}




/* -----------------------------------------------------------------------------
+
   read_script

   Read the next string from the script

   Inputs
   reset:

   Outputs
   result: ReadScript_EndOfScript
           ReadScript_OK
           ReadScript_ScriptError
           ReadScript_SystemError

   Returns
   success: pointer to string
   failure: NULL
-
 */


static char *read_script (const unsigned int reason_code, int *const result)
{
    static char line[STR_LEN];
    static char gstrans_string[STR_LEN];
    static char *sp = NULL;

    char *string;
    unsigned int processor_flags;
    _kernel_oserror *e;


    if (reason_code == ReadScript_Reset)
    {
        sp = NULL;
        return NULL;
    }

    if (sp == NULL || *sp == '\0' || reason_code == ReadScript_SkipLine)
    {
        if (script_get_next_line (line, STR_LEN) == NULL)
        {
            *result = ReadScript_EndOfScript;
            return NULL;
        }

        sp = line;

        if (reason_code == ReadScript_SkipLine)
            return sp;
    }

    /* Skip leading white space */
    while (*sp == ' ' || *sp == '\t')
        ++sp;

    /* Check for a quote character */
    if (*sp == '"' || *sp == '\'')
    {
        char quote = *sp++;    /* copy the quote character */
        string = sp;    /* store a pointer to the string in quotes */

        /* Look for close quote */
        while (*sp != quote)
        {
            if (*sp == '\0')
            {
                syslog ("Syntax error in script\n"
                        "Unterminated quote around %s", string);
                *result = ReadScript_ScriptError;
                return NULL;
            }

            /* '\' is the escape character, as in C */
            if (*sp++ == '\\')
            {
                if (*sp != '\0')
                    ++sp;
            }
        }
    }

    /* Deal with any other character */
    else
    {
        string = sp;    /* Save a pointer to the start of the string */

        /* Get the rest of the string */
        while (*sp != '\0' && *sp != ' ' && *sp != '\t')
            ++sp;
    }

    if (*sp != '\0')
        *sp++ = '\0';


    /* Pass string through OS_GSTrans to expand system variables etc. */
    e = _swix (OS_GSTrans, _INR (0, 2) | _OUT (_FLAGS),
               string, gstrans_string, sizeof (gstrans_string),
               &processor_flags);

    if (e)
    {
        *result = ReadScript_SystemError;
        syslog ("System error (%d): %s", e->errnum, e->errmess);
        return NULL;
    }


    /* If carry flag is set then there wasn't enough space in the
     * buffer for the GSTrans'd string.
     */
    if ((processor_flags & _C))
    {
        *result = ReadScript_SystemError;
        syslog ("System error: Out of memory");
        return NULL;
    }

    M_debug (("string is %s", string));
    *result = ReadScript_OK;
    return gstrans_string;
}




/* -----------------------------------------------------------------------------
+
   do_command

   Check if a given string is a script command.  If so then read its parameters
   and invoke the appropriate command handler.

   Inputs
   string: string to be checked

   Returns
   Command_NotCommand
   Command_Done
   Command_Error
-
 */

static int do_command (const char *const string)
{
    char **argv = NULL;
    int arg;
    int argc = 0;
    int i = 0;
    int result;


    /* Check if the given string matches any of the commands */
    while (script_command[i].cmd_name)
    {
        if (script_command[i].num_args < 0 &&
            strncmp (string, script_command[i].cmd_name,
                     strlen (script_command[i].cmd_name)) == 0)
        {
            argc = 0;
            break;
        }

        else if (strcmp (string, script_command[i].cmd_name) == 0)
        {
            argc = script_command[i].num_args;
            break;
        }

        ++i;
    }

    if (script_command[i].cmd_name == NULL)
        return Command_NotCommand;    /* string isn't a command */


    /* Get parameters for command */
    argv = malloc (sizeof (char *) * (argc + 1));
    if (argv == NULL)
    {
        syslog ("System error: Out of memory");
        goto error;
    }

    argv[0] = (char *) string;
    M_debug (("argv[0] = %s", string));
    for (arg = 1; arg <= argc; arg++)
    {
        argv[arg] = read_script (0, &result);
        switch (result)
        {
            case ReadScript_EndOfScript:
                syslog ("Command %s requires %d parameters but only %d given",
                        script_command[i].cmd_name,
                        script_command[i].num_args, arg);
                goto error;

            case ReadScript_OK:
                M_debug (("argv[%d] = %s", arg, argv[arg]));
                break;

            case ReadScript_SystemError:
                goto error;

            case ReadScript_ScriptError:
                M_status_set (Dialler_AbortedScript_Syntax);
                goto error;

            default:
                M_debug (("invalid result from read_script: %d", result));
                goto error;
        }
    }

    if ((*script_command[i].cmd_func)(argv) == CommandHandler_Error)
        goto error;

    M_debug (("command executed successfully"));
    free (argv);
    return Command_Done;

error:
    M_debug (("command failed"));
    if (argv)
        free (argv);
    return Command_Error;
}




/* -----------------------------------------------------------------------------
+
   command handlers

   The following functions are command handlers for chat script commands.

   Inputs
   argv: pointers to command's arguments
         argv[0] = pointer to command name

   Returns
   success: CommandHandler_OK
   failure: CommandHandler_Error
-
 */

/* argv[1] = abort string */
static int abort_command_handler (char **argv)
{
    char *abort_string;

    if ((abort_string = clean (argv[1], 0)) == NULL)
        return CommandHandler_Error;

    list_add_item (abort_list,
                   abort_string);

    character_string ("abort on", argv[1], 0);

    return CommandHandler_OK;
}

/* argv[1] = report string */
static int report_command_handler (char **argv)
{
    char *report_string;

    if ((report_string = clean (argv[1], 0)) == NULL)
        return CommandHandler_Error;

    list_add_item (report_list,
                   report_string);

    character_string ("report on", argv[1], 0);

    return CommandHandler_OK;
}

/* argv[1] = timeout length */
static int timeout_command_handler (char **argv)
{
    timeout_duration = atoi (argv[1]);

    if (timeout_duration <= 0)
        syslog ("timeout disabled");
    else
        syslog ("timeout set to %d seconds", timeout_duration);
    return CommandHandler_OK;
}

/* argv[1] = connection timeout length */
static int connection_timeout_command_handler (char **argv)
{
    _kernel_swi_regs r;

    r.r[1] = atoi (argv[1]);
    connection_timeout_set (&r);
    return CommandHandler_OK;
}

/* argv[1] = name of system variable to check / create
 * argv[2] = value to give variable if it doesn't already exist
 */
static int default_command_handler (char **argv)
{
    int exists;
    _kernel_swi_regs r;

    /* Check is system varible exists. If not then set it to given value */

    /* Find out if system variable exists.  NB. Can't use _swix
     * beacuse an error is always generated and _swix then doesn't
     * fill in the results.
     */
    r.r[0] = (int) argv[1];
    r.r[1] = (int) NULL;
    r.r[2] = (int) 0x80000000;
    r.r[3] = 0;
    r.r[4] = 0;

    _kernel_swi (OS_ReadVarVal, &r, &r);
    exists = r.r[2];

    if (!exists)
        _swix (OS_SetVarVal, _INR (0, 4),
               argv[1], argv[2], strlen (argv[2]), 0, 0);

    return CommandHandler_OK;
}

static int system_command_handler (char **argv)
{
    _kernel_oserror *e;


    if ((e = _swix (OS_CLI, _IN (0),
                    argv[0] + 1)) != NULL)
    {
        syslog ("System error (%d): %s", e->errnum, e->errmess);
        return CommandHandler_Error;
    }

    return CommandHandler_OK;
}

static int comment_command_handler (char **argv)
{
    M_unused (argv);

    read_script (ReadScript_SkipLine, NULL);
    return CommandHandler_OK;
}

static int status_command_handler (char **argv)
{
    if (status_change_string (argv[1], strlen (argv[1])))
        return CommandHandler_Error;

    return CommandHandler_OK;
}




/* -----------------------------------------------------------------------------
+
   expect_strtok

   Modified version of 'strtok' which skips \ sequences

   Inputs
   s:    string to segment for initial call, NULL thereafter
   term: string containing termination characters

   Returns
   pointer to next segment
-
 */

static char *expect_strtok (char *s, char *term)
{
    static char *str = "";
    int escape_flag = 0;
    char *result;


    if (s)
    {
        M_debug (("new call to expect_strtok: %s", s));
        str = s;
    }

    if (*str)
        result = str;
    else
        result = NULL;

    while (*str)
    {
        if (escape_flag)    /* skip this character */
        {
            escape_flag = 0;
            ++str;
            continue;
        }

        if (*str == '\\')    /* skip the next character */
        {
            ++str;
            escape_flag = 1;
            continue;
        }

        if (strchr (term, *str) == NULL)
        {
            /* include this character in the token */
            ++str;
            continue;
        }

        *str++ = '\0';    /* terminate this token */
        break;
    }

  #ifdef DEBUG
    if (result == NULL)
        log_output ("no segment to return");
    else
        log_output ("returning segment: %s", result);
  #endif

    return result;
}




/* -----------------------------------------------------------------------------
+
   chat_expect

   Try to get the expect string from the modem.  If only a partial string is
   obtained before running out of characters in the serial buffer then a
   callback is used to let RISC OS do something useful while we wait for more
   input.  If the expected string is not obtained then the send substring
   is sent (if present).

   Inputs:
   s: pointer to expect string
   state:

   Returns
   Script_DoneString: got the expected string
   Script_Callback:
   Script_Error:     couldn't get string
-
 */

static int chat_expect (char *s)
{
    enum    /* states for 'expect string' state machine */
    {
        ExpectState_NewString,
        ExpectState_ExpectString,
        ExpectState_SendSubString
    };
    static char *string;
    static int expect_state = ExpectState_NewString;
    int result;

    if (s == NULL)    /* abort: reset state machine and return */
    {
        expect_state = ExpectState_NewString;
        return Script_Abort;
    }

    for (;;)
    {
        switch (expect_state)
        {
            case ExpectState_NewString:
                string = expect_strtok (s, "-");
                expect_state = ExpectState_ExpectString;
                break;

            case ExpectState_ExpectString:
                if (string == NULL)
                {
                    expect_state = ExpectState_NewString;
                    return Script_DoneString;
                }

                result = get_string (string);
                M_debug (("get_string returned %d", result));
                switch (result)
                {
                    case Script_Callback:
                        return result;

                    case Script_DoneString: case Script_Abort:
                        expect_state = ExpectState_NewString;
                        return result;

                    case Script_Timeout:
                        /* expected string was not got within the allowed time
                         * so look for a send sub-string.
                         */

                        string = expect_strtok (NULL, "-");
                        expect_state = ExpectState_SendSubString;
                        break;

                    default:
                        expect_state = ExpectState_NewString;
                        M_debug (("invalid result from get_string: %d",
                                  result));
                        return Script_Abort;
                }
                break;

            case ExpectState_SendSubString:
                if (string == NULL)
                {
                    expect_state = ExpectState_NewString;
                    return Script_Timeout;
                }

                result = chat_send (string);
                switch (result)
                {
                    case Script_DoneString:
                    case Script_Abort:
                    case Script_Timeout:
                        string = expect_strtok (NULL, "-");
                        expect_state = ExpectState_ExpectString;
                        break;

                    case Script_Callback:
                        return result;

                    default:
                        M_debug (("invalid result from chat_send: %d", result));
                        return Script_Abort;
                }
                break;

            default:
                M_debug (("chat_expect state machine in invalid state: %d",
                          expect_state));
                expect_state = ExpectState_NewString;
                return Script_Abort;
        }
    }
}




/* -----------------------------------------------------------------------------
+
   chat_send

   Process a send string ready for it to be executed by put_string

   Inputs
   s: pointer to send string

   Returns
   Script_DoneString
   Script_Callback
   Script_Abort
   Script_Timeout
-
 */

static int chat_send (char *s)
{
    static int new_string = true;
    int result;

    if (s == NULL)    /* abort: reset and return */
    {
        new_string = true;
        return Script_Abort;
    }

    if (new_string)
    {
        if (strcmp (s, "EOT") == 0)
            strcpy (s, "^D\\c");

        else if (strcmp (s, "BREAK") == 0)
            strcpy (s, "\\K\\c");

        new_string = false;
    }

    result = put_string (s);
    M_debug (("put_string returned %d", result));
    switch (result)
    {
        case Script_DoneString:
        case Script_Abort:
        case Script_Timeout:
            new_string = true;
            return result;

        case Script_Callback:
            new_string = false;
            return result;

        default:
            M_debug (("invalid result from put_string: %d", result));
            return Script_Abort;
    }
}




/* -----------------------------------------------------------------------------
+
   put_string

   Send a string to the modem and execute commands (eg. \d -> sleep (1))

   Inputs
   s: pointer to string to write to serial port

   Returns
   Script_DoneString
   Script_Callback
   Script_Abort
   Script_Timeout
-
 */

static int put_string (char *string)
{
    static char *send_string;
    static char *s;
    static int new_string = true;
    char *escape_char;
  #ifdef BLOCKDRIVERS
    int bytes_put;
  #else
    _kernel_oserror *e;
  #endif


    if (string == NULL)    /* abort: reset and return */
    {
        new_string = true;
        return Script_Abort;
    }

    if (new_string)
    {
        if ((send_string = clean (string, true)) == NULL)
            return Script_Abort;

        s = send_string;
        character_string ("send", s, 0);
        timeout_activate ();
        new_string = false;
    }

    while (*s != '\0' && !timed_out)
    {
        if (*s == '\\')
        {
            ++s;
            switch (*(s++))
            {
                case 'd':
                    handlers_add_callafter (100);
                    return Script_Callback;

#if 0
                case 'K':
                    break_sequence ();    /* need to send a break ! */
                    continue;
#endif

                case 'p':
                    handlers_add_callafter (10);
                    return Script_Callback;

                default:
                    --s;
            }
        }

        escape_char = strchr (s + 1, '\\');

        if (escape_char != NULL)
            *escape_char = '\0';

        M_debug (("%s", s));
      #ifdef DEBUG
        write_ascii (s, strlen (s));
      #endif

      #ifdef BLOCKDRIVERS
        bytes_put = driver_putblock (s, strlen (s));
        M_debug (("put %d bytes", bytes_put));
        if (bytes_put == 0)
        {
            new_string = true;
            free (send_string);
            return Script_Abort;
        }

        s += bytes_put;
      #else
        if ((e = _swix (OS_GBPB, _INR (0, 3) | _OUT (2),
                        OSGBPB_Write, serial_out, s, strlen (s),
                        &s)) != NULL)
        {
            new_string = true;
            free (send_string);
            return Script_Abort;
        }
      #endif

        if (escape_char != NULL)
            *escape_char = '\\';
    }


    if (timed_out)
    {
        M_debug (("timed out in put_string"));
        new_string = true;
        free (send_string);
        return Script_Timeout;
    }
    else
        timeout_cancel ();

    free (send_string);
    new_string = true;
    return Script_DoneString;
}




/* -----------------------------------------------------------------------------
+
   get_string

   Wait for a string to come in from the serial port.  If there is only a
   partial string in the input buffer then we use a callback.  This allows
   RISC OS to get on with other things while we're waiting for the rest of the
   string.

   Returns
   Script_DoneString : read expected string
   Script_Callback   : do callback
   Script_Abort      : got abort string or error
   Script_Timeout    : timed out
-
 */

static int get_string (char *string)
{
    static int new_string = true;
    static int len;
    static char input_buff[STR_LEN];
    static char *s;
    static char *expect_string;
    static char *end;
    static char *next_search_pos;
    static char *next_unprocessed;
    char *matched_expect;
    char *list_match;
    char *buffer_match;
    int rc;
    int partial_match[3] = {0, 0, 0};
    int bytes;
  #ifndef BLOCKDRIVERS
    int bytes_left = 0;
  #endif
    _kernel_oserror *e = NULL;
    bool log_needs_newline = false;


    if (string == NULL)    /* reset and return */
    {
        new_string = true;
        s = input_buff;
        next_search_pos = input_buff;
        next_unprocessed = input_buff;
        end = input_buff + STR_LEN;
        return Script_Abort;
    }

    if (new_string)
    {
        /* Initialise pointers to current position in buffer and
         * end of buffer
         */
/* This bit isn't done anymore so that report strings can be seen when
   they are split across two expect string sequences.
        s = input_buff;
        next_search_pos = input_buff;
        end = s + STR_LEN;
*/
        if ((expect_string = clean (string, 0)) == NULL)
            goto return_abort;

        /* Initialise input buffer to all '\0' */
/* Not necessary: routines don't rely on termination */
/*         memset (input_buff, '\0', STR_LEN); */


        /* Make sure there is enough space in the input buffer to store the
         * expected string.
         */
        len = strlen (expect_string);
        M_debug (("expect string length: %d", len));

        if (len > STR_LEN)
        {
            syslog ("Error: expect string %s is too long", expect_string);
            goto return_abort;
        }


        else if (len == 0)    /* return immediately if nothing is expected */
            goto return_got_string;

        /* Log the expected string */
        character_string ("expect", expect_string, 0);
        new_string = false;
    }


    /* Activate timeouts */
    timeout_activate ();

  #ifndef BLOCKDRIVERS
    need_rx_data_present = true;
  #endif


    while (!timed_out)
    {
        /* Find how much data is in the serial recieve buffer */
      #ifdef BLOCKDRIVERS
        bytes = driver_checkrx ();
      #else
        if ((e = _swix (OS_Args, _INR (0, 1) | _OUT (2),
                        OSArgs_ReadExt, serial_in,
                        &bytes)) != NULL)
        {
            break;
        }
      #endif
#if 0
        syslog ("%d bytes in serial input buffer", bytes);
#endif
        M_debug (("%d bytes in serial input buffer", bytes));


        /* If there is data in the serial input buffer then read it.  If not
         * then return.
         */
        if (bytes > 0)
        {
            /* Ensure that input buffer will not overflow */
            if (s + bytes > end)
            {
                syslog ("Not enough space in Dialler's input buffer");
                goto return_abort;
            }

          #ifdef BLOCKDRIVERS
            bytes = driver_getblock (s, bytes);
            s += bytes;
          #else
            if ((e = _swix (OS_GBPB, _INR (0, 3) | _OUTR (2, 3),
                            OSGBPB_Read, serial_in, s, bytes,
                            &s, &bytes_left)) != NULL)
            {
                break;
            }

            bytes -= bytes_left;
          #endif

            /* M_debug (("%d bytes left", bytes_left)); */
        }

        /* If there is no data available to be read, but there is still
         * unprocessed data from a previous call then check the unprocessed
         * data.
         */
        else if (next_unprocessed == s)
        {
            /* The expected string hasn't been got yet and there's no more
             * data in the serial input buffer.  Return to RISC OS to allow
             * multitasking to continue - if any more data appears before the
             * script times out then this routine will be called back and pick
             * up where it left off.
             */

            M_debug (("callback"));
          #ifdef BLOCKDRIVERS
            need_rx_data_present = true;
          #endif

            if (log_needs_newline)
            {
                logf ("\n");
            }
            return Script_Callback;
        }

      #ifdef DEBUG
        character_string (NULL, s - bytes, bytes);
      #else
        {
            char *c;

            for (c = s - bytes; c < s; c++)
            {
                if (*c == '\n')
                {
                    logf ("\n");
                    log_needs_newline = false;
                }
                else if (*c != '\r')
                {
                    logf (character (*c));
                    log_needs_newline = true;
                }
           }
        }
      #endif

        /* Check if modem response matches one of the report strings */
        if (string_list_match (
                 report_list, next_search_pos, s - next_search_pos,
                 &list_match, &buffer_match, &partial_match[0]) >= 0)
        {
            char *c;
            int got_report_string = false;

            /* Find out if the report string is complete
             * ie. look for a terminating control character
             */
            c = buffer_match;
            while (c < s)
            {
                if (iscntrl (*c))
                {
                    got_report_string = true;
                    if (status_change_string (buffer_match, c - buffer_match))
                        goto return_abort;

                    syslog ("got report string %s", list_match);
                    break;
                }

                ++c;
            }

            if (!got_report_string)
            {
                /* Report string wasn't complete, but it could be completed
                 * next time.  Have to fake a partial match so that the initial
                 * part of the string isn't thrown away.
                 */

                partial_match[0] = s - buffer_match;
            }
        }

        /* Check to see if expected string has arrived */
        matched_expect = instrn (next_search_pos,
                                 expect_string,
                                 s - next_search_pos,
                                 len,

                                 NULL,
                                 &partial_match[1]);

        /* Only checking the buffer for expect string counts as 'processing'
         * the characters in the buffer.  If there is a complete match for
         * the expect string then the next unprocecessed character is the one
         * immediately after the expect string.  Otherwise it is the last
         * character in the buffer.
         */
        if (matched_expect == NULL)
        {
            next_unprocessed = s;

            M_debug (("checking abort strings"));

            /* Check if modem response matches one of the abort strings */
            if (string_list_match (abort_list,
                                   next_search_pos,
                                   s - next_search_pos,

                                   &list_match,
                                   NULL,
                                   &partial_match[2]) >= 0)
            {
                int   i = 0;
                bool  standard_abort_string = false;

                /* If it is one of the predefined abort strings then set the
                 * status appropriately.
                 */

                while (i < num_std_abort_strings &&
                       standard_abort_string == false)
                {
                    if (strcmp (std_abort_string[i], list_match) == 0)
                    {
                        M_status_set (AbortString_Base + i);
                        standard_abort_string = true;
                    }
                    else
                    {
                        ++i;
                    }
                }

                if (standard_abort_string == false)
                {
                    M_status_set (Dialler_AbortedScript_UserAbortString);
                }
                syslog ("got abort string %s", list_match);
                goto return_abort;
            }
        }
        else
        {
            next_unprocessed = matched_expect + len;
        }

        /* If the expect string was matched then buffer must not be
         * overwritten because there may be another expect string at a
         * later point in the buffer.
         *
         * If there are no partial or complete matches of strings of any
         * kind then the buffer can be filled and searched from the start again.
         *
         * There may be multiple partial matches at the end of the buffer.
         * In this case the next search of the buffer should start from the
         * beginning of the partial match nearest the start of the buffer.
         */
        if (partial_match[0] == 0 &&
            partial_match[1] == 0 &&
            partial_match[2] == 0)
        {
            if (matched_expect)
            {
                /* Next time, start searching the buffer for strings just
                 * after the expect string that was just matched.
                 */
                next_search_pos = matched_expect + len;
            }
            else
            {
                /* can start filling at start of buffer */
                s = input_buff;
                next_search_pos = input_buff;
                next_unprocessed = s;
                M_debug (("no partial match, going back to start of buffer"));
            }
        }
        else
        {
            int i, largest_partial_match = 0;

            for (i = 0;
                 i < sizeof (partial_match) / sizeof (partial_match[0]);
                 i++)
            {
                if (partial_match[i] > largest_partial_match)
                    largest_partial_match = partial_match[i];
            }

#if 0
            syslog ("largest partial match = %d", largest_partial_match);
            syslog ("this search pos: %p", next_search_pos);
#endif
            next_search_pos = s - largest_partial_match;
#if 0
            syslog ("next search pos: %p", next_search_pos);
#endif
        }

        if (matched_expect != NULL)
            goto return_got_string;
    }

    if (e)
    {
        syslog ("Error: get_string: %s", e->errmess);
    }

    if (timed_out)
    {
        syslog ("read timed out after %d seconds", timeout_duration);
    }
    else
    {
        syslog ("read failed");
    }

return_abort:
    /* Cleanup and return when aborting the script.  This deals with timeouts
     * as well.
     */
    if (timed_out)
    {
        rc = Script_Timeout;
    }
    else
    {
        rc = Script_Abort;
    }
    need_rx_data_present = false;
    new_string = true;
    handlers_remove_queued_callback ();
    timeout_cancel ();
    free (expect_string);
    if (log_needs_newline)
    {
        logf ("\n");
    }
    return rc;


return_got_string:
    /* Cleanup and return when the expected string has been got */
    need_rx_data_present = false;
    new_string = true;
    logf (" -- got it\n");
    handlers_remove_queued_callback ();
    timeout_cancel ();
    free (expect_string);
    return Script_DoneString;
}




/* -----------------------------------------------------------------------------
+
   character

   Convert any character code into human-readable form

   Inputs
   c : character code to display

   Returns
   pointer to human-readable representation of character
-
 */

static char *character (char c)
{
    static char string[5];
    int meta = false;


    /* Top-bit-set characters are Meta-characters: prefix with M- */
    if ((c & 0x80))
        meta = true;

    c &= 0x7f;    /* Clear top bit */

    /* Control characters are prefixed with ^ */
    if (c < 32)
        sprintf (string, "%s^%c", meta ? "M-" : "", (int) c + '@');

    /* Delete is ^? */
    else if (c == 127)
        sprintf (string, "%s^?", meta ? "M-" : "");

    /* Normal character */
    else
        sprintf (string, "%s%c", meta ? "M-" : "", c);

    string[sizeof (string) - 1] = '\0';

    return string;
}




/* -----------------------------------------------------------------------------
+
   clean

   'Clean up' this string
-
 */

static char *clean (char *s, const int sending)
{
    char *temp;
    char *s1;
    char *clean_string;
    char cur_chr;
    int add_return = sending;


    M_debug (("sending = %d", sending));
    M_debug (("length of unclean string: %d", strlen (s)));

    if ((temp = malloc (STR_LEN)) == NULL)
        return NULL;

    M_debug (("allocated memory for temporary string"));

    s1 = temp;

    while (*s)
    {
        cur_chr = *s++;

        /* Possible control character to be sent */
        if (cur_chr == '^')
        {
            cur_chr = *s++;

            if (cur_chr == '\0')
            {
                *s1++ = '^';
                break;
            }

            cur_chr &= 0x1f;

            if (cur_chr != 0)
                *s1++ = cur_chr;

            continue;
        }


        /* Escape character */
        if (cur_chr != '\\')
        {
            *s1++ = cur_chr;
            continue;
        }

        cur_chr = *s++;

        if (cur_chr == '\0')
        {
            if (sending)
            {
                *s1++ = '\\';
                *s1++ = '\\';
            }
            break;
        }

        switch (cur_chr)
        {
            case 'b':
                *s1++ = '\b';
                break;

            case 'c':
                if (sending && *s == '\0')
                    add_return = 0;
                else
                    *s1++ = cur_chr;
                break;

            case '\\': case 'K': case 'p': case 'd':
                if (sending)
                    *s1++ = '\\';
                *s1++ = cur_chr;
                break;

            case 'r':
                *s1++ = '\r';
                break;

            case 'n':
                *s1++ = '\n';
                break;

            case 's':
                *s1++ = ' ';
                break;

            case 't':
                *s1++ = '\t';
                break;

            case 'N':
                if (sending)
                {
                    *s1++ = '\\';
                    *s1++ = '\0';
                }
                else
                    *s1++ = 'N';
                break;

            default:
                if (M_isoctal (cur_chr))
                {
                    cur_chr &= 0x07;

                    if (M_isoctal (*s))
                    {
                        cur_chr <<= 3;
                        cur_chr |= *s++ - '0';

                        if (M_isoctal (*s))
                        {
                            cur_chr <<= 3;
                            cur_chr |= *s++ - '0';
                        }
                    }

                    if (cur_chr != 0 || sending)
                    {
                        if (sending && (cur_chr == '\\' || cur_chr == 0))
                            *s1++ = '\\';
                        *s1++ = cur_chr;
                    }
                    break;
                }

                if (sending)
                    *s1++ = '\\';
                *s1++ = cur_chr;
                break;
        }
    }

    if (add_return)
        *s1++ = '\r';

    /* *s1++ = '\0'; */ /* guarantee closure */
    *s1++ = '\0'; /* terminate the string */

  #ifdef DEBUG
    character_string ("cleaned string is", temp, 0);
/*     write_ascii (temp, (int) (s1 - temp)); */
  #endif

    clean_string = mem_dup (temp, (size_t) (s1 - temp));
    free (temp);

    return clean_string;
}




/* -----------------------------------------------------------------------------
+
   chat_initialise

   Initialise the chat module - call before executing script
-
 */

extern int chat_initialise (void)
{
#if 0
    int i;
#endif

    chat_finalise ();    /* make sure everything is in a clean state */

    abort_list = list_create (string_list_free);
    if (abort_list == NULL)
        return 1;

    report_list = list_create (string_list_free);
    if (report_list == NULL)
        return 1;

    /* Add standard abort strings to abort string list */
    num_std_abort_strings = sizeof (std_abort_string) /
                            sizeof (std_abort_string[0]);

#if 0
    for (i = 0; i < num_std_abort_strings; ++i)
    {
        list_add_item (abort_list,
                       std_abort_string[i]);
    }
#endif

    /* Ensure state machines are reset */
    read_script (ReadScript_Reset, NULL);
    chat_expect (NULL);
    chat_send (NULL);
    get_string (NULL);
    put_string (NULL);

    return 0;
}




/* -----------------------------------------------------------------------------
+
   chat_finalise

   Close down the chat module, free memory etc.
-
 */

extern void chat_finalise (void)
{
    handlers_remove_queued_callback ();
    handlers_remove_queued_callafter ();

    chat_expect (NULL);
    chat_send (NULL);
    get_string (NULL);
    put_string (NULL);
    chat_do_script (NULL, NULL);
    read_script (ReadScript_Reset, NULL);

    /* Free abort and report lists */
    if (abort_list != NULL)
    {
        list_destroy (abort_list);
        abort_list = NULL;
    }

    if (report_list != NULL)
    {
        list_destroy (report_list);
        report_list = NULL;
    }

/*     status_change_string (NULL, 0); */

    /* doing_script = false; */
}




/* -----------------------------------------------------------------------------
+
   instrn

   Test if a string of characters of a specififed length appears anywhere
   within another string of specified length.  Supports partial matching as
   well.

   Inputs
   cs: pointer to string to search in
   ct: pointer to string to search for
   n1: length of cs
   n2: length of ct

   Outputs
   next_pos: complete match: pointer to start of ct in cs
             partial match:  pointer to position in cs to start searching next
                             time
             no match:       pointer to end of cs

   partial_match_size: complete match: 0
                       partial match:  length of partial match
                       no match:       0

   Returns
   complete match: pointer to start of ct in cs
   partial match : NULL
   no match      : NULL
-
 */

char *instrn (register const char *cs, register const char *ct,
              const size_t n1, const size_t n2,
              char **next_pos, int *const partial_match_size)
{
    register const char *end_cs = cs + n1;
    register const char *end_ct = ct + n2;
    register const char *ct_copy = ct;
    char *last = (char *) end_cs;
    int remaining = 0;


/*
    M_debug (("cs = %p, ct = %p, n1 = %d, n2 = %d, end_cs = %p, end_ct = %p",
              cs, ct, n1, n2, end_cs, end_ct));
*/
    if (partial_match_size)
        *partial_match_size = 0;

    while (cs < end_cs)
    {
        if (*cs++ == *ct)
        {
/*
            M_debug (("compared\t[%d][%d]", *(cs - 1), *ct));
            syslog ("compared\t[%d][%d]", *(cs - 1), *ct);
*/
            ++ct;
            /* Save pointer to first character (returned if a partial match
             * is found at the end of cs).
             */
            last = (char *) (cs - 1);
            remaining = (int) end_cs - (int) last;

            while (cs < end_cs && ct < end_ct)
            {
/*
                M_debug (("comparing\t[%d][%d]", *cs, *ct));
                syslog ("comparing\t[%d][%d]", *cs, *ct);
*/
                if (*cs != *ct)
                {
                    goto not_found;
                }

                ++cs;
                ++ct;
            }


            if (next_pos)
                *next_pos = last;

            if (ct == end_ct)
            {
                /* Complete match */
                return last;
            }

            else
            {
                /* Partial match at end of cs */
                if (partial_match_size)
                {
/*
                  M_debug (("instrn:partial match size is %d", remaining));
                    syslog ("instrn:partial match size is %d", remaining);
*/
                    *partial_match_size = remaining;
                }

                return NULL;
            }

not_found:
            last = (char *) end_cs;
            remaining = 0;
            ct = ct_copy;
        }
    }

    return NULL;
}




#ifdef DEBUG
static void write_ascii (const char *const s, int n)
{
    char ascii[6];
    int i;


    if (n == -1)
    {
        n = strlen (s);
    }


    for (i = 0; i < n; i++)
    {
        sprintf (ascii, "[%d]", s[i]);
        logf (ascii);
    }

    logf ("\n");
}
#endif




static void character_string (const char *const label,
                              const char *string,
                              int len)
{
    const char *s = string;
    char *end;

    if (len <= 0)
        len = strlen (string);

    end = (char *) string + len;

    if (label)
    {
        logf (label);
        logf (" (");
    }

    while (s < end)
        logf (character (*s++));

    if (label)
        logf (")");

    logf ("\n");

/*
  #ifdef DEBUG
    write_ascii (string, -1);
  #endif
*/
}




/* -----------------------------------------------------------------------------
+
   string_list_free

   Free client data in a string list item

   Inputs
   string: pointer to string to free
-
 */

static void string_list_free (void *  string)
{
    free (string);
}




/* -----------------------------------------------------------------------------
+
   string_list_match

   Find out whether a buffer contains one of the strings in a string list

   Inputs
   list:       pointer to head of string list
   buffer:     buffer to search in
   buffer_len: length of buffer

   Outputs
   string:  pointer to 0 terminated matched or partially matched string in list
   match:   pointer to matched or partially matched string in buffer
            (may not be terminated)
   partial: length of partially matched string (0 if complete or no match)

   Returns
   complete match: item number of matched
   no match:       -1
   partial match:  -1
-
 */

static int string_list_match (
                        list_handle        list,
                        const char *const  buffer,
                        const int          buffer_len,
                        char **const       list_match,
                        char **const       buffer_match,
                        int *const         partial_size)
{
    char *           matched_string;
    char *           string;
    int              count = 0;
    int              len;
    int              partial = 0;
    list_iterator_t  iter;


    list_initialise_iterator (&iter,
                              list);

    if (partial_size)
        *partial_size = 0;

    for (iter.reset (&iter), count = 0;
         !iter.finished (&iter);
         iter.next (&iter), count++)
    {
        string = (char *) iter.current (&iter);
        len    = strlen (string);

        matched_string = instrn (buffer,
                                 string,
                                 buffer_len,
                                 len,
                                 NULL,
                                 &partial);

        if (matched_string != NULL)
        {
            if (buffer_match != NULL)
                *buffer_match = matched_string;

            if (list_match != NULL)
                *list_match = string;

            return count;
        }

        else if (partial > 0 && partial_size && partial > *partial_size)
        {
            if (buffer_match != NULL)
                *buffer_match = (char *) (buffer + buffer_len) - partial;

/*
            syslog ("string_list_match:partial match size is %d", partial);
*/
            *partial_size = partial;
        }
    }

    if (buffer_match != NULL)
        *buffer_match = NULL;

    if (list_match != NULL)
        *list_match = NULL;

    return -1;
}
