/*
 * Created by cmhg vsn 5.15 [Feb 14 1997]
 */

#ifndef __cmhg_ppphdr_h
#define __cmhg_ppphdr_h

#ifndef __kernel_h
#include "kernel.h"
#endif

#define CMHG_VERSION 515

#define Module_Title                     "PPP"
#define Module_Help                      "PPP"
#define Module_VersionString             "1.19"
#define Module_VersionNumber             119
#define Module_Date                      "09 Mar 1998"


/*
 * Initialisation code
 * ===================
 *
 * Return NULL if your initialisation succeeds; otherwise return a pointer
 * to an error block. cmd_tail points to the string of arguments with which
 * the module is invoked (may be "").
 * podule_base is 0 unless the code has been invoked from a podule.
 * pw is the 'R12' value established by module initialisation. You may
 * assume nothing about its value (in fact it points to some RMA space
 * claimed and used by the module veneers). All you may do is pass it back
 * for your module veneers via an intermediary such as SWI OS_CallEvery
 * (use _swix() to issue the SWI call).
 */
_kernel_oserror *ppp_initialise(char *cmd_tail, int podule_base, void *pw);


/*
 * Finalisation code
 * =================
 *
 * Return NULL if your finalisation succeeds. Otherwise return a pointer to
 * an error block if your finalisation handler does not wish to die (e.g.
 * toolbox modules return a 'Task(s) active' error).
 * fatal, podule and pw are the values of R10, R11 and R12 (respectively)
 * on entry to the finalisation code.
 */
_kernel_oserror *ppp_quit(int fatal, int podule, void *pw);


/*
 * Service call handler
 * ====================
 *
 * Return values should be poked directly into r->r[n]; the right
 * value/register to use depends on the service number (see the relevant
 * RISC OS Programmer's Reference Manual section for details).
 * pw is the private word (the 'R12' value).
 */
void ppp_sc_handler(int service_number, _kernel_swi_regs *r, void *pw);


/*
 * Command handler
 * ===============
 *
 * If cmd_no identifies a command, then arg_string gives the command tail
 * (which you may not overwrite), and argc is the number of parameters.
 * Return NULL if the command has been successfully handled; otherwise
 * return a pointer to an erro block describing the failure (in this
 * case, the veneer code will set the 'V' bit).
 *
 * If cmd_no identifies a *Help entry, then arg_string denotes a buffer
 * that you can assemble your output into. cmd_handler must return
 * NULL, an error pointer or help_PRINT_BUFFER (if help_PRINT_BUFFER)
 * is returned, the NUL-terminated buffer will be printed).
 *
 * If cmd_no identifies a *Configure option, then arg_string gives the
 * command tail, and argc the number of parameters. Return NULL, an error
 * pointer, or one of the four special values defined below. If arg_string
 * is set to arg_CONFIGURE_SYNTAX, the user has typed *Configure with no
 * parameter; simply print your syntax string. If arg_string is set to
 * arg_STATUS, print your current configured status. Otherwise use
 * arg_string and argc to set the *Configure option.
 *
 * pw is the private word pointer ('R12') value passed into the entry
 * veneer
 */
#define help_PRINT_BUFFER         ((_kernel_oserror *) arg_string)
#define arg_CONFIGURE_SYNTAX      ((char *) 0)
#define arg_STATUS                ((char *) 1)
#define configure_BAD_OPTION      ((_kernel_oserror *) -1)
#define configure_NUMBER_NEEDED   ((_kernel_oserror *) 1)
#define configure_TOO_LARGE       ((_kernel_oserror *) 2)
#define configure_TOO_MANY_PARAMS ((_kernel_oserror *) 3)

#define CMD_PPPInfo                     0
#define CMD_PPPConnect                  1
#define CMD_PPPDisconnect               2
#define CMD_PPPLog                      3

_kernel_oserror *ppp_cli_handler(char *arg_string, int argc, int cmd_no, void *pw);


/*
 * SWI handler code
 * ================
 *
 * Return NULL if the SWI is handled successfully; otherwise return
 * a pointer to an error block which describes the error.
 * The veneer code sets the 'V' bit if the returned value is non-NULL.
 * The special value error_BAD_SWI may be returned if you do not
 * implement a SWI; the veneer will arrange for the appropriate
 * standard internationalised error 'SWI value out of range for
 * module PPP' to be returned.
 * The handler may update any of its input registers (R0-R9).
 * pw is the private word pointer ('R12') value passed into the
 * SWI handler entry veneer.
 */
#define PPP_00                          0x04b600
#ifndef PPP_DCIVersion
#define PPP_DCIVersion                  0x04b600
#define PPP_Inquire                     0x04b601
#define PPP_GetNetworkMTU               0x04b602
#define PPP_SetNetworkMTU               0x04b603
#define PPP_Transmit                    0x04b604
#define PPP_Filter                      0x04b605
#define PPP_Stats                       0x04b606
#define PPP_7                           0x04b607
#define PPP_8                           0x04b608
#define PPP_9                           0x04b609
#define PPP_10                          0x04b60a
#define PPP_11                          0x04b60b
#define PPP_12                          0x04b60c
#define PPP_13                          0x04b60d
#define PPP_14                          0x04b60e
#define PPP_15                          0x04b60f
#define PPP_16                          0x04b610
#define PPP_17                          0x04b611
#define PPP_18                          0x04b612
#define PPP_19                          0x04b613
#define PPP_20                          0x04b614
#define PPP_21                          0x04b615
#define PPP_22                          0x04b616
#define PPP_23                          0x04b617
#define PPP_24                          0x04b618
#define PPP_25                          0x04b619
#define PPP_26                          0x04b61a
#define PPP_27                          0x04b61b
#define PPP_28                          0x04b61c
#define PPP_29                          0x04b61d
#define PPP_30                          0x04b61e
#define PPP_31                          0x04b61f
#define PPP_AlterSettings               0x04b620
#define PPP_Status                      0x04b621
#endif

#define error_BAD_SWI ((_kernel_oserror *) -1)

_kernel_oserror *ppp_swi_handler(int swi_no, _kernel_swi_regs *r, void *pw);


/*
 * Generic veneers
 * ===============
 *
 * These are the names of the generic entry veneers compiled by CMHG.
 * Use these names as an argument to, for example, SWI OS_CallEvery
 * or OS_AddCallBack.
 *
 * These veneers ensure that your handlers preserve R0-R11
 * and the processor flags (unless you return an error pointer.
 * The veneer can be entered in either IRQ or SVC mode. R12 and
 * R14 are corrupted.
 */
extern void hupcheck_entry(void);
extern void term_entry(void);
extern void hup_entry(void);
extern void start_entry(void);
extern void timeout_entry(void);
extern void callb_entry(void);
extern void poll_entry(void);

/*
 * These are the handler functions that the veneers declared above
 * call.
 *
 * For a standard exit, return NULL. For handlers that can return an
 * error, return an error block pointer, and the veneer will set the
 * 'V' bit, and set R0 to the error pointer.
 *
 * 'r' points to a vector of words containing the values of R0-R9 on
 * entry to the veneer. If r is updated, the updated values will be
 * loaded into R0-R9 on return from the handler.
 *
 * pw is the private word pointer ('R12') value with which the
 * entry veneer is called.
 */
_kernel_oserror *hupcheck_handler(_kernel_swi_regs *r, void *pw);
_kernel_oserror *term_handler(_kernel_swi_regs *r, void *pw);
_kernel_oserror *hup_handler(_kernel_swi_regs *r, void *pw);
_kernel_oserror *start_handler(_kernel_swi_regs *r, void *pw);
_kernel_oserror *timeout_handler(_kernel_swi_regs *r, void *pw);
_kernel_oserror *callb_handler(_kernel_swi_regs *r, void *pw);
_kernel_oserror *poll_handler(_kernel_swi_regs *r, void *pw);


/*
 * Vector handlers
 * ===============
 *
 * This is the name of the vector handler entry veneer
 * compiled by CMHG. Use this name as an argument to SWI
 * OS_Claim. (EventV claimants should use a CMHG event handler).
 *
 * Note that vector handlers were previously called IRQ handlers
 * and were documented as being for attaching to IrqV. IrqV has
 * long being deprecated; you should use OS_ClaimDeviceVector and
 * a CMHG generic veneer instead.
 */
extern void upcall_entry(void);

/*
 * This is the handler function you must write to handle the
 * vector for which upcall_entry is the veneer function.
 *
 * If a handler function is installed onto a vector, then:
 *   Return 0 to intercept the call.
 *   Return 1 to pass on the call.
 * If you use a vector handler veneer for any other purpose, always
 * return non-0, and consider the use of a generic veneer instead.
 * It is not currently possible to return an error from a vector
 * handler.
 *
 * 'r' points to a vector of words containing the values of R0-R9 on
 * entry to the veneer. If r is updated, the updated values will be
 * loaded into R0-R9 on return from the handler.
 *
 * pw is the private word pointer ('R12') value with which the
 * vector entry veneer is called.
 */
int upcall_handler(_kernel_swi_regs *r, void *pw);

#endif
