; -*-As-*-
;
;	 ppp_io.s
;
;	 data transfer routines for PPP driver
;
;	 $Header$
;	 $Source$
;
;	 Copyright (c) 1995 Acorn Computers Ltd.,  Cambridge,  England
;
;	 $Log$
;	 Revision 4.1.7.3  1997/03/21 12:39:01  jfarrell
;	 Update to PPP 1.15, using Internet 5 libraries.
;
;
;
	GET	Hdr.CVars

sp	RN	13
I_bit	*	(1:SHL:27)
C_bit	*	(1:SHL:29)
SVC_mode *	3
XOS_AddCallBack	*	&20054
XOS_Args	*	&20009

	AREA	ppp_io,  CODE,  READONLY


;
; callproto - set r12 and branch to protocol module's handler
;
; void callproto(DibRef dib, struct mbuf *m0,
;                  void (*handler)(DibRef, struct mbuf *),
;                   unsigned int pw);

	EXPORT  callproto
callproto
	MOV	r12,a4
	MOV	pc,a3


	IF BlockDrivers={TRUE}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ticker_handler:
;
; this routine is installed directly on TickerV.
;

	ImportVar poll_pending
	ImportVar serialevents_active
	ImportVar portnumber

start_entry_ptr
	IMPORT	start_entry
	DCD	start_entry

poll_entry_ptr
	IMPORT	poll_entry
	DCD	poll_entry

		EXPORT	ticker_handler
ticker_handler	ROUT

;
; before we switch mode (below) need to store r14_irq (i.e. lr) on
; the irq stack.  copy pc into r9 so we can restore the correct
; mode upon exit
;
	STMFD	sp!,  {r0-r3,  r6,  r7,  r9,  lr}
	MOV	r9,  pc

;
; we are normally called in IRQ mode,  get into SVC mode.
;
	ORR	r0,  r9,  #SVC_mode
	TEQP	r0,  #0
	NOP
	STMFD	r13!, {lr}             	; Preserve r14_svc

;
; mess around with relocation offsets
;

	LDR	r0, [r12]
	StaticBaseFromWP r6, r0		; data reloc now in r6

	LDRVar	R7,R6,portnumber

	MOV	R0,#5           ; Check RX buffer
	MOV	R1,R7	     	; Port number
	BL	driver_asm
	TEQS	R0,#0

	BNE	%FA10
5	LDRVar	r0, r6, serialevents_active
	TEQS	r0, #0
	BLNE	checkoutput
	LDMFD	r13!, {lr}
	TEQP	r9,  #0
	NOP
	LDMFD	sp!,  {r0-r3,  r6,  r7,  r9,  pc}^

10	ADRVar	r3, r6, poll_pending
	LDR	r0, [r3]
	TEQS	r0, #0
	BNE	%BA5

	LDR	r0, poll_entry_ptr
	MOV	r1, r12
	SWI	XOS_AddCallBack
	STR	r0, [r3]

	B	%BA5

checkoutput
	STMFD	sp!,{lr}
	MOV	R0,#4  ; Check TX
	MOV	R1,R7
	BL	driver_asm
	CMPS	R0,#64
	LDMLOFD sp!,{pc}^
	MOV	R0,#0
	STRVar	R0,R6,serialevents_active,LR
	LDR	R0,start_entry_ptr
	MOV	R1,R12
	SWI	XOS_AddCallBack
	LDMFD	sp!,{PC}^


	ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; splhi etc:
;
; Disable IRQs. Once IRQs are disabled,  we cannot/must not be reentered.
;
; Returns a value indicating the state of interrupts prior to calling here.
;
		EXPORT	splhi[LEAF]
splhi		ROUT

	AND	r0, lr, #I_bit
	ORRS	pc, lr, #I_bit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ensure_irqs_on:
;
; Ensure that interrupts are enabled. Returns a value that,  when passed
; to restore_irqs,  will restore the state prior to enabling interrupts.
;
		EXPORT	ensure_irqs_on[LEAF]
ensure_irqs_on	ROUT

	AND	r0, lr, #I_bit
	BICS	pc, lr, #I_bit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; restore_irqs etc:
;
; Restore interrupts to the state they were in prior to a call to
; splhi,  using the value returned by splhi.
;
		EXPORT	restore_irqs[LEAF]
		EXPORT	splx[LEAF]

restore_irqs	ROUT
splx
	BIC	lr, lr, #I_bit
	ORRS	pc, lr, r0

	IF BlockDrivers={TRUE}

; Grobbly bit - the block driver is in the data area, but we need
; to call it as code. This assembler veneer handles relocations.

	ImportVar driver_block

; Version to be called from C
	EXPORT driver
driver
	STMFD	sp!,{lr}
	StaticBaseFromSL lr
	ADRVar	ip,lr,driver_block
	MOV	lr,pc
	MOV	pc,ip
	LDMFD	sp!,{pc}^


; Version to be called from Assembler above
; Takes R6 as its relocation base
driver_asm
	STMFD	sp!,{r4, lr}
	ADRVar	r4,r6,driver_block
	MOV	lr,pc
	MOV	pc,r4
	LDMFD	sp!,{r4, pc}^

	ENDIF

	END

;	/* EOF ppp_io.s */
