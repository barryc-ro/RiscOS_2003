; -*-As-*-
;
;	 ppp_io.s
;
;	 data transfer routines for PPP driver
;
;	 $Header$
;	 $Source$
;
;	 Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
;
;	 :RCS Log discontinued:
;
;
	GET	Hdr.CVars

SP	RN	13
I_bit	*	(1:SHL:27)
C_bit	*	(1:SHL:29)
SVC_mode *	3
XOS_AddCallBack	*	&20054

	AREA	ppp_io, CODE, READONLY

;
; callproto - set r12 and branch to protocol module's handler
;
; void callproto(DibRef dib, struct mbuf *m0,
;                  void (*handler)(DibRef, struct mbuf *),
;                   unsigned int pw);

	EXPORT  callproto
callproto
	MOV	r12,a4
	MOV	pc,a3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ticker_handler:
;
; this routine is installed directly on TickerV.  If the byte to be inserted
; is destined for the serial input buffer, then it is diverted and placed
; in our own private buffer.
;

	ImportVar poll_pending
	ImportVar serialevents_active
	ImportVar portnumber

start_entry_ptr
	IMPORT	start_entry
	DCD	start_entry

poll_entry_ptr
	IMPORT	poll_entry
	DCD	poll_entry

		EXPORT	ticker_handler
ticker_handler	ROUT

;
; before we switch mode (below) need to store r14_irq (i.e. lr) on
; the irq stack.  copy pc into r9 so we can restore the correct
; mode upon exit
;
	STMFD	SP!, {R0-R3, R6, R7, R9, LR}
	MOV	R9, PC

;
; we are normally called in IRQ mode, get into SVC mode.
;
	ORR	R0, R9, #SVC_mode
	TEQP	R0, #0
	NOP
	STMFD	R13!,{LR}             ; Preserve R14_svc

;
; mess around with relocation offsets
;

	LDR	R0,[R12]
	StaticBaseFromWP R6,R0		; data reloc now in r6

	LDRVar	R7,R6,portnumber

	MOV	R0,#5           ; Check RX buffer
	MOV	R1,R7	     	; Port number
	BL	driver_asm
	TEQS	R0,#0

	BNE	%FA10
5	LDRVar	R0,R6,serialevents_active
	TEQS	R0,#0
	BLNE	checkoutput
	LDMFD	R13!,{LR}
	TEQP	R9, #0
	NOP
	LDMFD	SP!, {R0-R3, R6, R7, R9, PC}^

10	ADRVar	R3,R6,poll_pending
	LDR	R0,[R3]
	TEQS	R0,#0
	BNE	%BA5

	LDR	R0,poll_entry_ptr
	MOV	R1,R12
	SWI	XOS_AddCallBack
	STR	R0,[R3]

	B	%BA5

checkoutput
	STMFD	sp!,{lr}
	MOV	R0,#4  ; Check TX
	MOV	R1,R7
	BL	driver_asm
	CMPS	R0,#64
	LDMLOFD sp!,{pc}^
	MOV	R0,#0
	STRVar	R0,R6,serialevents_active,LR
	LDR	R0,start_entry_ptr
	MOV	R1,R12
	SWI	XOS_AddCallBack
	LDMFD	sp!,{PC}^



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; splhi etc:
;
; Disable IRQs. Once IRQs are disabled, we cannot/must not be reentered.
;
; Returns a value indicating the state of interrupts prior to calling here.
;
		EXPORT	splhi[LEAF]
splhi		ROUT

	AND	r0, lr, # I_bit
	ORRS	pc, lr, # I_bit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ensure_irqs_on:
;
; Ensure that interrupts are enabled. Returns a value that, when passed
; to restore_irqs, will restore the state prior to enabling interrupts.
;
		EXPORT	ensure_irqs_on[LEAF]
ensure_irqs_on	ROUT

	AND	r0, lr, # I_bit
	BICS	pc, lr, # I_bit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; restore_irqs etc:
;
; Restore interrupts to the state they were in prior to a call to
; splhi, using the value returned by splhi.
;
		EXPORT	restore_irqs[LEAF]
		EXPORT	splx[LEAF]

restore_irqs	ROUT
splx
	BIC	lr, lr, # I_bit
	ORRS	pc, lr, r0

; Grobbly bit - the block driver is in the data area, but we need
; to call it as code. This assembler veneer handles relocations.

	ImportVar driver_block

; Version to be called from C
	EXPORT driver
driver
	STMFD	sp!,{lr}
	StaticBaseFromSL lr
	ADRVar	ip,lr,driver_block
	MOV	lr,pc
	MOV	pc,ip
	LDMFD	sp!,{pc}^


; Version to be called from Assembler above
; Takes R6 as its relocation base
driver_asm
	STMFD	sp!,{r4, lr}
	ADRVar	r4,r6,driver_block
	MOV	lr,pc
	MOV	pc,r4
	LDMFD	sp!,{r4, pc}^

	END

;	/* EOF ppp_io.s */
