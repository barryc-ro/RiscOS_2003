; -*-As-*-
;
;	 ppp_io.s
;
;	 data transfer routines for PPP driver
;
;	 Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
;
;
	GET	Hdr.CVars

SP	RN	13
I_bit	*	(1:SHL:27)
C_bit	*	(1:SHL:29)
SVC_mode *	3
XOS_AddCallBack	*	&20054

	AREA	ppp_io, CODE, READONLY

;
; callproto - set r12 and branch to protocol module's handler
;
; void callproto(DibRef dib, struct mbuf *m0,
;                  void (*handler)(DibRef, struct mbuf *),
;                   unsigned int pw);

	EXPORT  callproto
callproto
	MOV	r12,a4
	MOV	pc,a3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ticker_handler:
;
; this routine is installed directly on TickerV.  If the byte to be inserted
; is destined for the serial input buffer, then it is diverted and placed
; in our own private buffer.
;

	ImportVar ring_insert
	ImportVar ring_limit
	ImportVar ring_start
	ImportVar poll_pending

poll_entry_ptr
	IMPORT	poll_entry
	DCD	poll_entry

		EXPORT	ticker_handler
ticker_handler	ROUT

;
; before we switch mode (below) need to store r14_irq (i.e. lr) on
; the irq stack.  copy pc into r9 so we can restore the correct
; mode upon exit
;
	STMFD	SP!, {R0-R1, R6, R9, LR}
	MOV	R9, PC

;
; we are normally called in IRQ mode, get into SVC mode.
;
	ORR	R0, R9, #SVC_mode
	TEQP	R0, #0
	NOP
	STMFD	R13!,{LR}

;
; mess around with relocation offsets
;

	LDR	R0,[R12]
	StaticBaseFromWP R6,R0		; data reloc now in r6

	MOV	R0,#5           ; Check RX buffer
	MOV	R1,#0	     	; Port number (***HACK***)
	BL	driver_asm
	TEQS	R0,#0

	BNE	%FA10
5	LDMFD	R13!,{LR}
	TEQP	R9, #0
	NOP
	LDMFD	SP!, {R0-R1, R6, R9, PC}^


; copy a block into  the ring buffer
; R2->data, R3=len

10	STMFD	SP!, {R2-R4}
	B	%FA13

20	LDRVar	R2,R6,ring_insert           ; R2=ring_insert
	LDRVar	R4,R6,ring_limit            ; R4=ring_limit
	SUBS	R3,R4,R2                    ; R3=space till end of buffer
	LDRVar	R2,R6,ring_start,EQ         ; if no space, R2=ring_start
	SUBEQ	R3,R4,R2
	MOV	R0,#3      ; Get block
	MOV	R1,#0
	BL	driver_asm   		    ; get as many as possible (R3)
	ADD	R2,R2,R0
	STRVar	R2,R6,ring_insert,LR        ; update ring_insert
	TEQS	R2,R4                       ; if ring_insert=ring_limit
	BEQ	%BA20                       ;    then go round again

13	ADRVar	R3,R6,poll_pending
	LDR	R0,[R3]
	TEQS	R0,#0
	BNE	%F25

	LDR	R0,poll_entry_ptr
	MOV	R1,R12
	SWI	XOS_AddCallBack
	STR	R0,[R3]
;
25	LDMFD	SP!, {R2-R4}
	B	%B5



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; splhi etc:
;
; Disable IRQs. Once IRQs are disabled, we cannot/must not be reentered.
;
; Returns a value indicating the state of interrupts prior to calling here.
;
		EXPORT	splhi[LEAF]
splhi		ROUT

	AND	r0, lr, # I_bit
	ORRS	pc, lr, # I_bit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ensure_irqs_on:
;
; Ensure that interrupts are enabled. Returns a value that, when passed
; to restore_irqs, will restore the state prior to enabling interrupts.
;
		EXPORT	ensure_irqs_on[LEAF]
ensure_irqs_on	ROUT

	AND	r0, lr, # I_bit
	BICS	pc, lr, # I_bit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; restore_irqs etc:
;
; Restore interrupts to the state they were in prior to a call to
; splhi, using the value returned by splhi.
;
		EXPORT	restore_irqs[LEAF]
		EXPORT	splx[LEAF]

restore_irqs	ROUT
splx
	BIC	lr, lr, # I_bit
	ORRS	pc, lr, r0

; Grobbly bit - the block driver is in the data area, but we need
; to call it as code. This assembler veneer handles relocations.

	ImportVar driver_block

; Version to be called from C
	EXPORT driver
driver
	STMFD	sp!,{r4-r5,lr}
	StaticBaseFromSL r5
	ADRVar	r4,r5,driver_block
	MOV	lr,pc
	MOV	pc,r4
	LDMFD	sp!,{r4-r5,pc}^


; Version to be called from Assembler above
; Takes R6 as its relocation base
driver_asm
	STMFD	sp!,{r1-r4,lr}
	ADRVar	r4,r6,driver_block
	;LDR	lr,a8000
	;STR	r4,[lr]
	;MOV	r0,#0
	;LDMFD	sp!,{r4,pc}^
	MOV	lr,pc
	MOV	pc,r4
77	LDMFD	sp!,{r1-r4,pc}^

a8000
	DCD	&8000

	END

;	/* EOF ppp_io.s */
