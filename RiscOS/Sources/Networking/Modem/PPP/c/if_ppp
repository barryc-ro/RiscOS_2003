/*
 * if_ppp.c - Point-to-Point Protocol (PPP) Asynchronous driver.
 *
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Drew D. Perkins
 * Carnegie Mellon University
 * 4910 Forbes Ave.
 * Pittsburgh, PA 15213
 * (412) 268-8576
 * ddp@andrew.cmu.edu
 *
 * Based on:
 *	@(#)if_sl.c	7.6.1.2 (Berkeley) 2/15/89
 *
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Serial Line interface
 *
 * Rick Adams
 * Center for Seismic Studies
 * 1300 N 17th Street, Suite 1450
 * Arlington, Virginia 22209
 * (703)276-7900
 * rick@seismo.ARPA
 * seismo!rick
 *
 * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).
 * Converted to 4.3BSD Beta by Chris Torek.
 * Other changes made at Berkeley, based in part on code by Kirk Smith.
 *
 * Converted to 4.3BSD+ 386BSD by Brad Parker (brad@cayman.com)
 * Added VJ tcp header compression; more unified ioctls
 *
 * Extensively modified by Paul Mackerras (paulus@cs.anu.edu.au).
 * Cleaned up a lot of the mbuf-related code to fix bugs that
 * caused system crashes and packet corruption.	 Changed pppstart
 * so that it doesn't just give up with a collision if the whole
 * packet doesn't fit in the output ring buffer.
 *
 * Added priority queueing for interactive IP packets, following
 * the model of if_sl.c, plus hooks for bpf.
 * Paul Mackerras (paulus@cs.anu.edu.au).
 */

/* 1998-03-09: BAL
 * Removed support for using the Dialler for idle-timeout.  This was completely
 * pointless as PPP's built-in idle timer works fine.
 */

/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */


static char *ack_if_ppp="Copyright (c) 1989 Carnegie Mellon University. "
                        "All rights reserved.";

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sys/dcistructs.h"

#include "ppp.h"
#if NPPP > 0


#include "sys/errno.h"
/*#include "sys/param.h"*/
#include "sys/types.h"
/*#include "sys/proc.h"*/
#include "sys/mbuf.h"
/*#include "sys/buf.h"*/
#include "sys/socket.h"
#include "sys/ioctl.h"
/*#include "sys/file.h"*/
#include "sys/signal.h"
#include "sys/tty.h"
#include "sys/conf.h"
#include "sys/syslog.h"

#include "net/if.h"
#include "net/netisr.h"
#include "net/route.h"

#ifdef INET
#include "netinet/in.h"
#include "netinet/if_ether.h"
#include "netinet/in_systm.h"
#include "netinet/in_var.h"
#include "netinet/ip.h"
#include "netinet/tcp.h"
#endif

#include "socklib.h"

#include "mbuf.h"
#include "swis.h"

#include "pppd.h"
#include "ppp_io.h"

#include "ppphdr.h"
#include "pppmodule.h"

#ifdef BLOCKDRIVERS
  #include "blockdrive.h"
#else
  #include "ioctl.h"
#endif

#include "if_ppp.h"
#include "serial.h"
#include "dialler.h"

#include "pppd/minixlib.h"
#include "pppd/main.h"
#include "MemCheck/MemCheck.h"



#ifdef VJC
#define HDROFF	MAX_HDR
#else
#define	HDROFF	(0)
#endif

/* This is a NetBSD-current kernel. */
#define CCOUNT(q)	((q)->c_cc)

#define	PPP_HIWAT	1000	/* Don't start a new packet if HIWAT on queue */

static int	pppgetm(struct ppp_softc *sc);
void	pppdumpm(struct mbuf *m0, int pktlen);
/*void	pppdumpms(struct mbuf *m0, int pktlen);*/
static void	pppdumpb(u_char *b, int l);
static void	ppplogchar(struct ppp_softc *, int);
static void     update_flags(struct ppp_softc *, unsigned change, unsigned newval);

struct ppp_softc ppp_softc[NPPP];

static int in_pppstart;

/*
 * The following disgusting hack gets around the problem that IP TOS
 * can't be set yet.  We want to put "interactive" traffic on a high
 * priority queue.  To decide if traffic is interactive, we check that
 * a) it is TCP and b) one of its ports is telnet, rlogin or ftp control.
 */
static const u_short interactive_ports[8] = {
	0,	513,	0,	0,
	0,	21,	0,	23,
};
#define INTERACTIVE(p) (interactive_ports[(p) & 7] == (p))

/*
 * Does c need to be escaped?
 */
#define ESCAPE_P(c)	(sc->sc_asyncmap[(c) >> 5] & (1 << ((c) & 0x1F)))

static int splimped;

static int splimp(void)
{
    int oldsplimped=splimped;

    splimped=1;

    return oldsplimped;
}

#define unsplimp(a) (splimped=a)




/*
 * Called from boot code to establish ppp interfaces.
 */
_kernel_oserror *pppattach(void)
{
    struct ppp_softc *sc;
    int i;
    _kernel_oserror *e;

    for (i = 0; i < NPPP; i++)
    {
        sc=&ppp_softc[i];

        memset(&sc->sc_outq, 0, sizeof sc->sc_outq);
        memset(&sc->sc_fastq, 0, sizeof sc->sc_fastq);
        memset(&sc->sc_comp, 0, sizeof sc->sc_comp);
        sc->sc_outm = NULL;
        sc->sc_mtu = PPP_MTU;
        sc->sc_outq.ifq_maxlen = IFQ_MAXLEN;
        sc->sc_fastq.ifq_maxlen = IFQ_MAXLEN;
    }

    pdebug((LOG_DEBUG, "sc=%x", sc));

    e=serial_initialise(ppp_softc);

    return e;
}


/*
 * Deallocate a ppp unit.
 */
static void pppdealloc(struct ppp_softc *sc)
{
    struct mbuf *m;

    for (;;) {
	    IF_DEQUEUE(&sc->sc_fastq, m);
	    if (m == NULL)
                break;
	    MBCTL.freem(&MBCTL, m);
	}
    for (;;) {
	    IF_DEQUEUE(&sc->sc_outq, m);
	    if (m == NULL)
                break;
	    MBCTL.freem(&MBCTL, m);
	}
    update_flags(sc, IFF_UP|IFF_RUNNING, 0);
}

/*
 * Line specific open routine for async tty devices.
 * Attach the given tty to the first available ppp unit.
 */
int pppopen(int fd)
{
    struct ppp_softc *sc=&ppp_softc[fd];

#if 0
   /* if (tp->t_line == PPPDISC)*/ {
	    /*(struct ppp_softc *) tp->t_sc*/;
	    if (sc != NULL/* && sc->sc_devp == (void *) tp*/)
                return (0);
	}
#endif
    sc->sc_flags=SC_DEBUG /*| SC_LOG_RAWIN*/;
    sc->sc_mru=PPP_MRU;
#ifdef VJC
    sl_compress_init(&sc->sc_comp);
#endif
    update_flags(sc, IFF_RUNNING, IFF_RUNNING);


    if (sc->sc_outm != NULL) {
	    MBCTL.freem(&MBCTL, sc->sc_outm);
	    sc->sc_outm = NULL;
	}

    if (pppgetm(sc) == 0) {
            update_flags(sc, IFF_UP|IFF_RUNNING, 0);
	    return (ENOBUFS);
	}

    sc->sc_ilen = 0;
    memset(sc->sc_asyncmap, 0, sizeof(sc->sc_asyncmap));
    sc->sc_asyncmap[0] = 0xffffffff;
    sc->sc_asyncmap[3] = 0x60000000;
    sc->sc_rasyncmap = 0;

    return (0);
}

/*
 * Line specific close routine.
 * Detach the tty from the ppp unit.
 * Mimics part of ttyclose().
 */
void pppclose(int fd)
{
    struct ppp_softc *sc=&ppp_softc[fd];
    int s;
    /* Do some sort of buffer flush/ serial close */
    s = splimp();		/* paranoid; splnet probably ok */
    serial_finalise();

    MBCTL.freem(&MBCTL, sc->sc_outm);
    sc->sc_outm = NULL;
    if (sc->sc_m)
    {
        MRESET(sc->sc_m);
        free(mtod(sc->sc_m, void *));
        MBCTL.freem(&MBCTL, sc->sc_m);
        sc->sc_m = NULL;
    }
    pppdealloc(sc);


    unsplimp(s);
}

/*
 * Line specific (tty) read routine.
 *
 * No queuing - pppread can only be called within a pppd_signal_handler(SIGIO);
 */
int pppread(int fd, u_char *p, int n)
{
    struct ppp_softc *sc = &ppp_softc[fd];
    struct mbuf *m0, *m;
    int len;

    if (0/* Carrier off && (tp->t_cflag & CLOCAL) == 0*/)
	return 0;		/* end of file */
    if (sc == NULL)
	return 0;

    m0=sc->sc_m;

    if (m0 == 0 || m0->m_type == 1)
    {
        errno=EWOULDBLOCK;
        return -1;
    }

    /* Mark that the packet has been read */
    m0->m_type=1;
    MBCTL.export(&MBCTL, m0, n, p);

    for (len=0, m=m0; m; m=m->m_next)
        len+=m->m_len;

    return len;
}

/*
 * Line specific (tty) write routine.
 */

int pppwrite(int s, u_char *p, int nbytes)
{
    struct ppp_softc *sc = &ppp_softc[s];
    struct mbuf *m0;
    struct sockaddr dst;

    if (0 /*Carrier off && (tp->t_cflag & CLOCAL) == 0*/)
	return 0;		/* wrote 0 bytes */
    if (sc == NULL)
	return EIO;
    if (nbytes > sc->sc_mtu + PPP_HDRLEN || nbytes < PPP_HDRLEN)
	return EMSGSIZE;

    m0=MBCTL.alloc(&MBCTL, nbytes, p);
    if (m0 == NULL)
        return ENOBUFS;

    dst.sa_family = AF_UNSPEC;
    memcpy(dst.sa_data, mtod(m0, void *), sizeof(struct ppp_header));
    m0->m_off += PPP_HDRLEN;
    m0->m_len -= PPP_HDRLEN;
    return (pppoutput(&sc->dib, m0, &dst));
}

/*
 * Line specific (tty) ioctl routine.
 * Provide a way to get the ppp unit number.
 * This discipline requires that tty device drivers call
 * the line specific l_ioctl routine from their ioctl routines.
 */
int pppioctl(int socket, int cmd, caddr_t data)
{
    /* Hack - only one PPP device at present */
    struct ppp_softc *sc = &ppp_softc[0];
    int s, error, flags, mru;

    if (sc == NULL)
	return -1;

    switch (cmd) {
	  case PPPIOCGUNIT:
	    *(int *)data = sc->dib.dib_unit;
	    break;

	  case PPPIOCGFLAGS:
	    *(u_int *)data = sc->sc_flags;
	    break;

	  case PPPIOCSFLAGS:
	    flags = *(int *)data & SC_MASK;
	    s = splimp();
	    sc->sc_flags = (sc->sc_flags & ~SC_MASK) | flags;
	    unsplimp(s);
	    break;

	  case PPPIOCSASYNCMAP:
	    sc->sc_asyncmap[0] = *(u_int *)data;
	    break;

	  case PPPIOCGASYNCMAP:
	    *(u_int *)data = sc->sc_asyncmap[0];
	    break;

	  case PPPIOCSRASYNCMAP:
	    sc->sc_rasyncmap = *(u_int *)data;
	    break;

	  case PPPIOCGRASYNCMAP:
	    *(u_int *)data = sc->sc_rasyncmap;
	    break;

	  case PPPIOCSXASYNCMAP:
	    memcpy(sc->sc_asyncmap, data, sizeof sc->sc_asyncmap);
	    sc->sc_asyncmap[1] = 0;		    /* mustn't escape 0x20 - 0x3f */
	    sc->sc_asyncmap[2] &= ~0x40000000;	/* mustn't escape 0x5e */
	    sc->sc_asyncmap[3] |= 0x60000000;	/* must escape 0x7d, 0x7e */
	    break;

	  case PPPIOCGXASYNCMAP:
	    memcpy(data, sc->sc_asyncmap, sizeof sc->sc_asyncmap);
	    break;

	  case PPPIOCSMRU:
	    mru = *(int *)data;
	    if (mru >= PPP_MRU && mru <= PPP_MAXMRU)
	    {
                    sc->sc_mru = mru;
                    if (pppgetm(sc) == 0)
                    {
                	    error = ENOBUFS;
                	    sc->sc_mru = PPP_MRU;
                	    if (pppgetm(sc) == 0)
                	        update_flags(sc, IFF_UP, 0);
                    }
            }
	    break;

	  case PPPIOCGMRU:
	    *(int *)data = sc->sc_mru;
	    break;

#ifdef VJC
	  case PPPIOCSMAXCID:
	    sl_compress_setup(&sc->sc_comp, *(int *)data);
	    break;
#endif

	  default:
	    /* Not one of ours - pass on to Internet module */
	    return socketioctl(socket, cmd, data);
	}
    return 0;
}

/*
 * FCS lookup table as calculated by genfcstab.
 */
const static u_short fcstab[256] = {
	0x0000,	0x1189,	0x2312,	0x329b,	0x4624,	0x57ad,	0x6536,	0x74bf,
	0x8c48,	0x9dc1,	0xaf5a,	0xbed3,	0xca6c,	0xdbe5,	0xe97e,	0xf8f7,
	0x1081,	0x0108,	0x3393,	0x221a,	0x56a5,	0x472c,	0x75b7,	0x643e,
	0x9cc9,	0x8d40,	0xbfdb,	0xae52,	0xdaed,	0xcb64,	0xf9ff,	0xe876,
	0x2102,	0x308b,	0x0210,	0x1399,	0x6726,	0x76af,	0x4434,	0x55bd,
	0xad4a,	0xbcc3,	0x8e58,	0x9fd1,	0xeb6e,	0xfae7,	0xc87c,	0xd9f5,
	0x3183,	0x200a,	0x1291,	0x0318,	0x77a7,	0x662e,	0x54b5,	0x453c,
	0xbdcb,	0xac42,	0x9ed9,	0x8f50,	0xfbef,	0xea66,	0xd8fd,	0xc974,
	0x4204,	0x538d,	0x6116,	0x709f,	0x0420,	0x15a9,	0x2732,	0x36bb,
	0xce4c,	0xdfc5,	0xed5e,	0xfcd7,	0x8868,	0x99e1,	0xab7a,	0xbaf3,
	0x5285,	0x430c,	0x7197,	0x601e,	0x14a1,	0x0528,	0x37b3,	0x263a,
	0xdecd,	0xcf44,	0xfddf,	0xec56,	0x98e9,	0x8960,	0xbbfb,	0xaa72,
	0x6306,	0x728f,	0x4014,	0x519d,	0x2522,	0x34ab,	0x0630,	0x17b9,
	0xef4e,	0xfec7,	0xcc5c,	0xddd5,	0xa96a,	0xb8e3,	0x8a78,	0x9bf1,
	0x7387,	0x620e,	0x5095,	0x411c,	0x35a3,	0x242a,	0x16b1,	0x0738,
	0xffcf,	0xee46,	0xdcdd,	0xcd54,	0xb9eb,	0xa862,	0x9af9,	0x8b70,
	0x8408,	0x9581,	0xa71a,	0xb693,	0xc22c,	0xd3a5,	0xe13e,	0xf0b7,
	0x0840,	0x19c9,	0x2b52,	0x3adb,	0x4e64,	0x5fed,	0x6d76,	0x7cff,
	0x9489,	0x8500,	0xb79b,	0xa612,	0xd2ad,	0xc324,	0xf1bf,	0xe036,
	0x18c1,	0x0948,	0x3bd3,	0x2a5a,	0x5ee5,	0x4f6c,	0x7df7,	0x6c7e,
	0xa50a,	0xb483,	0x8618,	0x9791,	0xe32e,	0xf2a7,	0xc03c,	0xd1b5,
	0x2942,	0x38cb,	0x0a50,	0x1bd9,	0x6f66,	0x7eef,	0x4c74,	0x5dfd,
	0xb58b,	0xa402,	0x9699,	0x8710,	0xf3af,	0xe226,	0xd0bd,	0xc134,
	0x39c3,	0x284a,	0x1ad1,	0x0b58,	0x7fe7,	0x6e6e,	0x5cf5,	0x4d7c,
	0xc60c,	0xd785,	0xe51e,	0xf497,	0x8028,	0x91a1,	0xa33a,	0xb2b3,
	0x4a44,	0x5bcd,	0x6956,	0x78df,	0x0c60,	0x1de9,	0x2f72,	0x3efb,
	0xd68d,	0xc704,	0xf59f,	0xe416,	0x90a9,	0x8120,	0xb3bb,	0xa232,
	0x5ac5,	0x4b4c,	0x79d7,	0x685e,	0x1ce1,	0x0d68,	0x3ff3,	0x2e7a,
	0xe70e,	0xf687,	0xc41c,	0xd595,	0xa12a,	0xb0a3,	0x8238,	0x93b1,
	0x6b46,	0x7acf,	0x4854,	0x59dd,	0x2d62,	0x3ceb,	0x0e70,	0x1ff9,
	0xf78f,	0xe606,	0xd49d,	0xc514,	0xb1ab,	0xa022,	0x92b9,	0x8330,
	0x7bc7,	0x6a4e,	0x58d5,	0x495c,	0x3de3,	0x2c6a,	0x1ef1,	0x0f78
};

/*
 * Calculate a new FCS given the current FCS and the new data.
 */
static u_short pppfcs(u_short fcs, u_char *cp, int len)
{
    while (len--)
	fcs = PPP_FCS(fcs, *cp++);
    return (fcs);
}

#if 0
extern int ppp_headers_added_in_pppoutput;
extern int queued_in_pppoutput;
#endif
/*
 * Queue a packet.  Start transmission if not active.
 * Packet is placed in Information field of PPP frame.
 */
int pppoutput(struct dib *ifp, struct mbuf *m0, const struct sockaddr *dst)
{
    struct ppp_softc *sc = &ppp_softc[ifp->dib_unit];
    struct ppp_header *ph;
    int protocol, address, control;
    u_char *cp;
    int s, error;
    struct ip *ip;
    struct ifqueue *ifq;
    struct mbuf *m, **m1;
    extern volatile int idle_time;


    if ((sc->moreflags & IFF_RUNNING) == 0
	|| (sc->moreflags & IFF_UP) == 0 && dst->sa_family != AF_UNSPEC)
    {
        if ((dialler_flags & DiallerFlags_UsingDialler) &&
            (dialler_flags & DiallerFlags_AutoDial))
        {
            unsigned int status;

            if (dialler_flags & DiallerFlags_DiallerB)
            {
                _swix (DiallerB_Status, _OUT (0), &status);
            }
            else
            {
                _swix (Dialler_Status, _OUT (0), &status);
            }

            if ((status & (Dialler_ExecutingScript_Dial | Dialler_Connected)) == 0)
            {
                /* Dial up using previous settings */
                if (dialler_flags & DiallerFlags_DiallerB)
                {
                    _swix (DiallerB_Dial, _INR (0, 4), 0, 0, 0, 0, 0);
                }
                else
                {
                    _swix (Dialler_Dial, _INR (0, 4), 0, 0, 0, 0, 0);
                }
            }
            error = ENETUNREACH;
        }

        else
	    error = ENETDOWN;	/* sort of */

	goto bad;
    }

    idle_time = 0;

    /*
     * Compute PPP header.
     */
    address = PPP_ALLSTATIONS;
    control = PPP_UI;
    ifq = &sc->sc_outq;
    switch (dst->sa_family)
    {
#ifdef INET
      case AF_INET:
	protocol = PPP_IP;
	if ((sc->sc_flags & SC_ENABLE_IP) == 0)
	{
            error = ENETDOWN;
	    goto bad;
        }

	/*
	 * If this is a TCP packet to or from an "interactive" port,
	 * put the packet on the fastq instead.
	 * Assuming a word aligned packet
	 */
	if ((ip = mtod(m0, struct ip *))->ip_p == IPPROTO_TCP)
	{
	    struct tcphdr *tcp=(struct tcphdr *)((char *)ip + ip->ip_hl*4);
            if (INTERACTIVE(ntohs(tcp->th_sport)) ||
                INTERACTIVE(ntohs(tcp->th_dport)))
                ifq = &sc->sc_fastq;
	}

	break;
#endif
      case AF_UNSPEC:
        ph = (struct ppp_header *) dst->sa_data;
        address = ph->ph_address;
        control = ph->ph_control;
        protocol = ntohs(ph->ph_protocol);
        break;
      default:
        syslog(LOG_ERR, "ppp%d: af%d not supported", ifp->dib_unit, dst->sa_family);
        error = EAFNOSUPPORT;
        goto bad;
    }

    m=m0;
    m1=&m0;
    while (m)
    {
        /*ppp_headers_added_in_pppoutput++;*/
        /*
         * Add PPP header.	If no space in first mbuf, allocate another.
         */
        if (m->m_off - m->m_inioff < PPP_HDRLEN)
        {
            struct mbuf *temp;

            temp=m;
            m=MBCTL.alloc_s(&MBCTL, PPP_HDRLEN, 0);
    	    if (m == 0)
    	    {
    	        error = ENOBUFS;
    	        goto bad;
    	    }
    	    m->m_next=temp;
    	    m->m_list=temp->m_list;
    	    temp->m_list=NULL;
    	    *m1=m;

    	    m->m_len = 0;
        }
        else
    	    m->m_off -= PPP_HDRLEN;

        cp = mtod(m, u_char *);
        *cp++ = address;
        *cp++ = control;
        *cp++ = protocol >> 8;
        *cp++ = protocol & 0xff;
        m->m_len += PPP_HDRLEN;

        if (sc->sc_flags & SC_LOG_OUTPKT)
        {
            pdebug((LOG_DEBUG, "ppp%d output: ", ifp->dib_unit));
            pppdumpm(m0, -1);
        }
        m1=&m->m_list;
        m=m->m_list;
    }

    /*
     * Put the packet on the appropriate queue.
     */
    if (IF_QFULL(ifq))
    {
        IF_DROP(ifq);
        sc->st.st_tx_general_errors++;
        error = ENOBUFS;
        goto bad;
    }

    s = splhi();

    /* AJS changed 23/10/96 */
    for (m=m0; m->m_list; m=m->m_list)
    {
        /*queued_in_pppoutput++;*/
        ifq->ifq_len++;
    }

    /* leaves m pointing at last mbuf in chain,
       so incr. ifq_len to account for it
    */

    ifq->ifq_len++;


    /* A sort of IF_ENQUEUE for a list of packets */
    if (ifq->ifq_tail == 0)
        ifq->ifq_head = m0;
    else
        ifq->ifq_tail->m_list = m0;
    ifq->ifq_tail = m;
    /* end AJS changes */

    splx(s);

    /*
     * Tell the device to send it out.
     */

    pdebug((LOG_DEBUG, "After enqueuing, ifq->qlen=%d", ifq->ifq_len));

    /*
     * If not already pumping data, call pppstart to start the pumps, else
     * call serial_enableevents to make absolutely sure we get notified
     * when the buffer has free space
     *
     * If changing to use UpCalls, make the "else" bit check that we're
     * not in a situation where the buffer has > 64 bytes but there isn't
     * a start callback pending.
     */
    if (!in_pppstart)
        pppstart(ifp->dib_unit);
    else
    {
      #ifndef BLOCKDRIVERS
        int buffer_size;
        int free_space;
        ioctl_t ioctl;

        ioctl.group = 0;
        ioctl.reason = IOCtl_buffer_size;
        ioctl.reserved = 0;
        ioctl.read = 1;
        ioctl.write = 0;

        /* read buffer size */
        _swix (OS_Args, _INR (0, 2), OS_Args_IOCtl, serial_out, &ioctl);
        buffer_size = ioctl.data;

        /* read amount of free space in serial output buffer */
        _swix (OS_Args, _INR (0, 1) | _OUT (2), 2, serial_out, &free_space);

        if (free_space != buffer_size && free_space > 63)
        {
            int interrupt_state = splhi ();


            if (!start_callback_pending)
            {
                if (!_swix (OS_AddCallBack, _INR (0, 1), start_entry, module_wsp))
                    start_callback_pending = TRUE;
            }

            restore_irqs (interrupt_state);
        }
      #endif
        serial_enableevents();
    }


    return (0);

  bad:
    freelist(m0);
    return error;
}

/*
 * Grab another packet off a queue and apply VJ compression,
 * address/control and/or protocol compression if appropriate.
 */
static struct mbuf *ppp_dequeue(struct ppp_softc *sc)
{
    int s;
    struct mbuf *m;
    u_char *cp;
    int address, control, protocol;

    pdebug((LOG_DEBUG, "fastq.ifq_len=%d", sc->sc_fastq.ifq_len));
    pdebug((LOG_DEBUG, "outq.ifq_len=%d", sc->sc_outq.ifq_len));
    /* Grab off the fast queue first, otherwise off the slowq */
    s = splhi();
    IF_DEQUEUE(&sc->sc_fastq, m);
    if (m == NULL)
	IF_DEQUEUE(&sc->sc_outq, m);
    splx(s);
    if (m == NULL)
	return NULL;

    /*
     * Extract the ppp header of the new packet.
     * The ppp header will be in one mbuf.
     */
    cp = mtod(m, u_char *);
    address = cp[0];
    control = cp[1];
    protocol = (cp[2] << 8) + cp[3];

#ifdef VJC
    /*
     * If the packet is a TCP/IP packet, see if we can compress it.
     */
    if (protocol == PPP_IP && sc->sc_flags & SC_COMP_TCP)
    {
        struct ip *ip;
        int type;
        struct mbuf *mp;

        mp = m;
	ip = (struct ip *) (cp + PPP_HDRLEN);
	/* If the first mbuf is < or smaller than a PPP header, skip
	   to the next one
	 */

	if (mp->m_len <= PPP_HDRLEN)
	{
	    mp = mp->m_next;
	    ip = mtod(mp, struct ip *);
	}
	/* mp now points to the mbuf that contains the tcp header. it
	   may be pointing at either the PPP header or the IP header.
	   Hence we also supply ip, which does point at the IP header
	 */
	/* this code assumes the IP/TCP header is in one non-shared mbuf */
        if (((int)ip)&3)
            pdebug((LOG_DEBUG, "*****************NON-ALIGNED IP HEADER**********"));
	if (ip->ip_p == IPPROTO_TCP)
	{
	    /*pdebug((LOG_DEBUG, "Compressing packet: before:"));
	    pppdumpm(m, -1);*/
	    type = sl_compress_tcp(mp, ip, &sc->sc_comp,
                		   !(sc->sc_flags & SC_NO_TCP_CCID));
	    switch (type)
	    {
	      case TYPE_UNCOMPRESSED_TCP:
	        protocol = PPP_VJC_UNCOMP;
                break;
              case TYPE_COMPRESSED_TCP:
	        protocol = PPP_VJC_COMP;
                cp = mtod(m, u_char *);
                cp[0] = address;	/* header has moved */
                cp[1] = control;
                cp[2] = 0;
                break;
	    }
	    cp[3] = protocol;	/* update protocol in PPP header */
	    /*pdebug((LOG_DEBUG, "after:"));
	    pppdumpm(m, -1);*/
	}
    }
#endif	/* VJC */

    /*
     * Compress the address/control and protocol, if possible.
     */
    if (sc->sc_flags & SC_COMP_AC && address == PPP_ALLSTATIONS &&
	control == PPP_UI && protocol != PPP_ALLSTATIONS &&
	protocol != PPP_LCP)
    {
        /* can compress address/control */
        m->m_off += 2;
        m->m_len -= 2;
    }
    if (sc->sc_flags & SC_COMP_PROT && protocol < 0xFF)
    {
        /* can compress protocol */
        if (mtod(m, u_char *) == cp)
        {
	    cp[2] = cp[1];	/* move address/control up */
	    cp[1] = cp[0];
	}
        ++m->m_off;
        --m->m_len;
    }

    return m;
}



#ifdef BLOCKDRIVERS

static int putbyte(char c)
{
/*    int s=splhi();*/
    int yes;

    yes=driver_putbyte(c);


 /*   splx(s);*/

    return yes==0 ? 0 : -1;
}

#else

static int putbyte(char c)
{
    _kernel_oserror *e;

    e = _swix(OS_BPut, _INR (0, 1), c, serial_out);

    return e==NULL ? 0 : -1;
}

#endif



#ifdef BLOCKDRIVERS

static int putblock(u_char *p, int n)
{
    int put;
    int bytes_free;
    /*int s=splhi();*/

    if ((bytes_free = driver_checktx ()) < n)
    {

        pdebug ((LOG_DEBUG, "Wanted to send %d bytes but only room for %d in buffer",
                 n, bytes_free));
    }


    put=driver_putblock(p, n);

   /* splx(s);*/

    return n-put;
}

#else

static int putblock(u_char *p, int n)
{
    int not_done;


    _swix(OS_GBPB, _INR (0, 3) | _OUT (3),  2, serial_out, p, n, &not_done);
  #if 0
    pdebug ((LOG_DEBUG, "tried %d, %d not done", n, not_done));
  #endif

    return (not_done);
}

#endif


_kernel_oserror *start_handler(_kernel_swi_regs *r, void *pw)
{
  #ifndef BLOCKDRIVERS
    start_callback_pending = FALSE;
  #endif

    _kernel_irqs_on();

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    pdebug ((LOG_DEBUG, "in_pppstart: %d", in_pppstart));
    if (!in_pppstart)
        pppstart(0);
   /* else
        serial_enableevents();*/

    MemCheck_UnRegisterMiscBlock (r);

    return (NULL);

    NOT_USED (r);
    NOT_USED (pw);
}

/*
 * Start output on async tty interface.	 Get another datagram
 * to send from the interface queue and start sending it.
 *
 * BAL: This function has become a bit messy in order to cope with data polling using
 * blockdrivers and asynchronous notification using the dual serial interface - these
 * two schemes require a different approach.  Things are relatively simple when polling
 * for data in the blockdrivers.  If the output buffer gets full a flag is set, the next
 * poll checks if this flag is set and if so will ensure there is now plenty of free
 * space in the output buffer, in which case a transient callback to pppstart is added.
 * Things are more complicated with dual serial's upcalls.  There is only one chance
 * to catch the upcall that indicates the free space in the output buffer has crossed
 * the set threshold.  This could conceivably occur between filling the output buffer
 * and setting the flag to indicate there is more to do, in which case the upcall is
 * missed.  The solution is to always assume the upcall is needed and then remove it
 * if it turns out that it isn't.
 */
void pppstart(int fd)
{
    struct ppp_softc *sc = &ppp_softc[fd];
    struct mbuf *m;
    int len, freeinbuffer;
    u_char *start, *stop, *cp;
    int n, ndone, done;
    struct mbuf *m2;
    int firsttime=1;

    in_pppstart=1;
  #ifdef BLOCKDRIVERS
    serial_disableevents ();
  #endif

    if (sc == NULL)
    {
/*        (*tp->t_oproc)(tp);*/
        in_pppstart=0;
        return;
    }

  #ifndef BLOCKDRIVERS
    /* When using dual serial assume that the upcall is always needed so that it can't
     * be missed.  If it isn't really needed then the callback can be removed later.
     */
    serial_enableevents ();
  #endif

    for (;;)
    {
        /*
         * If there is more in the output queue, just send it now.
         */

      #ifdef BLOCKDRIVERS
        freeinbuffer=driver_checktx();
      #else
        _swix(OS_Args, _INR(0, 1) | _OUT(2), 2, serial_out, &freeinbuffer);
      #endif

        if (freeinbuffer < 20)
	{
            in_pppstart=0;
	    serial_enableevents();
	    return;
	}


	/*
	 * See if we have an existing packet partly sent.
	 * If not, get a new packet and start sending it.
	 * We take packets on the priority queue ahead of those
	 * on the normal queue.
	 */
	m = sc->sc_outm;
	if (m == NULL)
	{
	    /*
	     * Get another packet to be sent
	     */
	    m = ppp_dequeue(sc);
	    if (m == NULL)
	    {
                in_pppstart=0;
              #ifndef BLOCKDRIVERS
                /* All the data has now been sent so the effects of any
                 * UpCall_DeviceThresAbove's should be undone.
                 */
                serial_disableevents();
              #endif
                return;
	    }
            /*pdebug((LOG_DEBUG, "Dequeued a packet"));
            pppdumpm(m, -1);*/
	    /*
	     * The extra PPP_FLAG will start up a new packet, and thus
	     * will flush any accumulated garbage.  We do this whenever
	     * the line may have been idle for some time.
	     */
	    if (firsttime)
	    {
	        ++sc->st.st_tx_bytes;
	        putbyte(PPP_FLAG);
	        firsttime=0;
	    }

	    /* Calculate the FCS for the first mbuf's worth. */
	    sc->sc_outfcs = pppfcs(PPP_INITFCS, mtod(m, u_char *), m->m_len);
	}

	for (;;)
	{
	    start = mtod(m, u_char *);
	    len = m->m_len;
	    stop = start + len;
	    while (len > 0)
	    {
	        /*
	         * Find out how many bytes in the string we can
	         * handle without doing something special.
	         */
	        for (cp = start; cp < stop; cp++)
	            if (ESCAPE_P(*cp))
                        break;
                n = cp - start;
                if (n)
                {
                    ndone = n - putblock(start, n);
                    len -= ndone;
                    start += ndone;
                    sc->st.st_tx_bytes += ndone;

                    if (ndone < n)
                        break;    /* packet doesn't fit */
                }
                /*
                 * If there are characters left in the mbuf,
                 * the first one must be special..
                 * Put it out in a different form.
                 */
                if (len)
                {
                    u_char b[2];
                  #ifdef BLOCKDRIVERS
                    if (driver_checktx() < 2)
                        break;
                  #else
                    _swix(OS_Args, _INR(0, 1) | _OUT(2), 2, serial_out, &freeinbuffer);
                    if (freeinbuffer < 2)
                        break;
                  #endif
                    b[0]=PPP_ESCAPE;
                    b[1]=*start ^ PPP_TRANS;
                    putblock(b, 2);
                    sc->st.st_tx_bytes += 2;
                    start++;
                    len--;
                }
	    }
	    /*
	     * If we didn't empty this mbuf, remember where we're up to.
	     * If we emptied the last mbuf, try to add the FCS and closing
	     * flag, and if we can't, leave sc_outm pointing to m, but with
	     * m->m_len == 0, to remind us to output the FCS and flag later.
	     */
	    done = len == 0;
	    if (done && m->m_next == NULL)
	    {
	        u_char *p;
	        int c;
	        u_char endseq[8];

	        /*
	         * We may have to escape the bytes in the FCS.
	         */
	        p = endseq;
	        c = ~sc->sc_outfcs & 0xFF;
	        if (ESCAPE_P(c))
	        {
                    *p++ = PPP_ESCAPE;
                    *p++ = c ^ PPP_TRANS;
	        } else
	            *p++ = c;
                c = (~sc->sc_outfcs >> 8) & 0xFF;
	        if (ESCAPE_P(c))
	        {
                    *p++ = PPP_ESCAPE;
                    *p++ = c ^ PPP_TRANS;
	        } else
	            *p++ = c;
                *p++ = PPP_FLAG;

	        /*
                 * Try to output the FCS and flag. If the bytes
                 * don't all fit, back out.
                 */

                if (p > endseq)
                {
                    int bufspace;
                  #ifndef BLOCKDRIVERS
                    _kernel_oserror *e = NULL;
                  #endif

                  #ifdef BLOCKDRIVERS
                    bufspace=driver_checktx();
                    if (bufspace < p-endseq)
                        done = 0;
                    else
                        putblock (endseq, p-endseq);

                  #else

                    e = _swix(OS_Args, _INR(0, 1) | _OUT(2), 2, serial_out, &bufspace);
                  #ifdef DEBUG
                    if (e)
                        pdebug ((LOG_DEBUG, "pppstart error %d: %s", e->errnum, e->errmess));
                  #endif
                    if (e || (bufspace < p-endseq))
                        done = 0;
                    else
                        putblock(endseq, p-endseq);

                  #endif
                }
	    }

	    if (!done)
	    {
	        m->m_off = (int)start - (int)m;
	        m->m_len = len;
	        sc->sc_outm = m;
                in_pppstart=0;
              #ifdef BLOCKDRIVERS
	        serial_enableevents();
              #endif
                return;		/* can't do any more at the moment */
	    }

	    /* Finished with this mbuf; free it and move on. */
	    m2=m->m_next;
	    MBCTL.free(&MBCTL, m);
	    if (m2 == NULL)
	        break;

	    m = m2;
	    sc->sc_outfcs = pppfcs(sc->sc_outfcs, mtod(m, u_char *), m->m_len);
	}

	/* Finished a packet */
	sc->sc_outm = NULL;
	sc->st.st_tx_bytes++;	/* account for closing flag */
	sc->st.st_tx_frames++;
    }
}

/*
 * Allocate enough mbuf to handle current MRU.
 */

static int pppgetm(struct ppp_softc *sc)
{
    int len = HDROFF + sc->sc_mru + PPP_HDRLEN + PPP_FCSLEN;
    int s;
    void *mem;

    s = splimp();

    if (sc->sc_m)
    {
        MRESET(sc->sc_m);
        free(mtod(sc->sc_m, void *));
        MBCTL.freem(&MBCTL, sc->sc_m);
        sc->sc_m=NULL;
    }


    mem=malloc(len);

    if (mem)
        sc->sc_m=MBCTL.alloc_u(&MBCTL, len, mem);

    if (sc->sc_m == NULL)
    {
        unsplimp(s);
	syslog(LOG_WARNING, "ppp%d: can't allocate mbuf", sc->dib.dib_unit);
	return 0;
    }

    unsplimp(s);
    return 1;
}



/*
 * PPP packet input routine.
 * The caller has checked and removed the FCS.
 * The return value is 1 if the packet was put on sc->sc_inq,
 * 0 otherwise.
 */
#define COMPTYPE(proto)	((proto) == PPP_VJC_COMP? TYPE_COMPRESSED_TCP: \
                	 TYPE_UNCOMPRESSED_TCP)

/* The input mbuf is single and unsafe - take a copy */
static int ppppktin(struct ppp_softc *sc, struct mbuf *m, int ilen)
{
    int xlen, proto, rv;
    struct ppp_header hdr;
    u_char *dptr;
    struct mbuf *m2;
    RxHdr *rx;

    sc->st.st_rx_frames++;
    rv = 0;

    hdr = *mtod(m, struct ppp_header *);
    proto = ntohs(hdr.ph_protocol);

#ifdef VJC
    /*
     * See if we have a VJ-compressed packet to uncompress.
     */
    if (proto == PPP_VJC_COMP || proto == PPP_VJC_UNCOMP)
    {
        char *pkttype = proto == PPP_VJC_COMP? "": "un";

        if (sc->sc_flags & SC_REJ_COMP_TCP)
        {
	    if (sc->sc_flags & SC_DEBUG)
                syslog(LOG_WARNING, "ppp%d: %scomp pkt w/o compression; flags 0x%x",
            sc->dib.dib_unit, pkttype, sc->sc_flags);
	    sc->st.st_rx_general_errors++;
	    return 0;
        }
	/*printf("Decompressing packet: before:\n");
	pppdumpms(m, -1);*/

        m->m_off += PPP_HDRLEN;
        m->m_len -= PPP_HDRLEN;
	ilen -= PPP_HDRLEN;
	dptr=mtod(m, u_char *);
	xlen = sl_uncompress_tcp_part(&dptr,
	                              m->m_len, ilen,
                		      COMPTYPE(proto), &sc->sc_comp);
	m->m_off=(int)dptr-(int)m; /* this should be dtoo(m, dptr); but it's broken */

	if (xlen == 0)
	{
	    if (sc->sc_flags & SC_DEBUG)
                syslog(LOG_WARNING, "ppp%d: sl_uncompress failed on type %scomp",
	                      sc->dib.dib_unit, pkttype);
	    sc->st.st_rx_general_errors++;
	    return 0;
	}

	/* adjust the first mbuf by the decompressed amt */
	xlen += PPP_HDRLEN;
	m->m_len += xlen - ilen;
	ilen = xlen;
	m->m_off -= PPP_HDRLEN;
	proto = PPP_IP;

	/* put the ppp header back in place */
	hdr.ph_protocol = htons(PPP_IP);
	*mtod(m, struct ppp_header *)=hdr;
	/*printf("after:\n");
	pppdumpms(m, -1);*/

    }
#endif /* VJC */

    switch (proto)
    {
#ifdef INET
      case PPP_IP:
        /*
	 * IP packet - take off the ppp header and pass it up to IP.
	 */
        m = MBCTL.copy(&MBCTL, m, 0, M_COPYALL);

        if (m==0)
        {
            syslog(LOG_WARNING, "ppp%d: Out of mbufs", sc->dib.dib_unit);
            return 0;
        }


	if ((sc->moreflags & IFF_UP) == 0
	    || (sc->sc_flags & SC_ENABLE_IP) == 0)
	{
	    /* interface is down - drop the packet. */
	    MBCTL.freem(&MBCTL, m);
	    return 0;
	}
	m->m_off += PPP_HDRLEN;
	m->m_len -= PPP_HDRLEN;

        for (m2=m; m2; m2=m2->m_next)
            m2->m_type = MT_DATA;
      #if 0
      #ifdef DEBUG
        {
            int i;
            for (i=0; i<20; i++)
            {
                pdebug ((LOG_DEBUG, "%02x ", mtod(m, char *)[i]));
            }

            pdebug ((LOG_DEBUG, "\n"));
        }
      #endif
      #endif

        m2=MBCTL.alloc_s(&MBCTL, sizeof(RxHdr), NULL);
        if (m2==0)
        {
            MBCTL.freem(&MBCTL, m);
            return 0;
        }
        m2->m_next=m;
        m2->m_type=MT_HEADER;
        rx=mtod(m2, RxHdr *);
        memset(rx, 0, sizeof *rx);
        rx->rx_frame_type=ETHERTYPE_IP;
        rx->rx_error_level=ERRLVL_NO_ERRORS;

        callproto(&sc->dib, m2, sc->inetfilter->fs_handler, sc->inetfilter->fs_pwptr);
	/*schednetisr(NETISR_IP);
	inq = &ipintrq;*/
	return 1;
#endif

      default:
        /*
	 * Some other protocol - place on input queue for read().
	 */
	rv = 1;
	pdebug((LOG_DEBUG, "Sending packet to PPPD"));
	break;
    }

    /*
     * Send packet to pppd. Simply raise SIGIO, it will
     * call pppread, which will send it the contents of
     * sc->sc_m
     */
    pppd_signal_handler(SIGIO);

    return rv;
}

/*
 * tty interface receiver interrupt.
 */
static unsigned paritytab[8] =
{
	0x96696996, 0x69969669, 0x69969669, 0x96696996,
	0x69969669, 0x96696996, 0x96696996, 0x69969669
};


/*
 * Note that the input buffer (sc->sc_m) is a single, unsafe mbuf
 */
void pppinput(int c, int fd)
{
    struct ppp_softc *sc;
    struct mbuf *m;
    int ilen;

    /*tk_nin++;*/
    sc = &ppp_softc[fd];
    if (sc == NULL /*|| tp != (struct tty *) sc->sc_devp*/)
	return;


    ++sc->st.st_rx_bytes;

    if (c == 256)
    {
	    /* framing error or overrun on this char - abort packet */
	    if (sc->sc_flags & SC_DEBUG)
                pdebug((LOG_DEBUG, "ppp%d: framing error", sc->dib.dib_unit));
            sc->st.st_rx_general_errors++;
	    goto flush;
    }

    c &= 0xff;

    if (c & 0x80)
	sc->sc_flags |= SC_RCV_B7_1;
    else
	sc->sc_flags |= SC_RCV_B7_0;

    if (paritytab[c >> 5] & (1 << (c & 0x1F)))
	sc->sc_flags |= SC_RCV_ODDP;
    else
	sc->sc_flags |= SC_RCV_EVNP;

    if (sc->sc_flags & SC_LOG_RAWIN)
	ppplogchar(sc, c);

    if (c == PPP_FLAG)
    {
	ilen = sc->sc_ilen;
	sc->sc_ilen = 0;

	if (sc->sc_rawin_count > 0)
	    ppplogchar(sc, -1);

	/*
	 * If SC_ESCAPED is set, then we've seen the packet
	 * abort sequence "}~".
	 */
	if (sc->sc_flags & (SC_FLUSH | SC_ESCAPED)
	    || ilen > 0 && sc->sc_fcs != PPP_GOODFCS)
	{
#ifdef VJC
	    /*
	     * If we've missed a packet, we must toss subsequent compressed
	     * packets which don't have an explicit connection ID.
	     */
	    sl_uncompress_tcp(NULL, 0, TYPE_ERROR, &sc->sc_comp);
#endif
	    if ((sc->sc_flags & (SC_FLUSH | SC_ESCAPED)) == 0)
	    {
	        if (sc->sc_flags & SC_DEBUG)
                {
	            pdebug((LOG_DEBUG, "ppp%d: bad fcs", sc->dib.dib_unit));
	        }
	        sc->st.st_crc_failures++;
	    }
	    else
                sc->sc_flags &= ~(SC_FLUSH | SC_ESCAPED);
	    return;
	}

	if (ilen < PPP_HDRLEN + PPP_FCSLEN)
	{
	    if (ilen)
	    {
	        if (sc->sc_flags & SC_DEBUG)
	        {
	            pdebug((LOG_DEBUG, "ppp%d: too short (%d)", sc->dib.dib_unit, ilen));
	        }
                sc->st.st_runt_frames++;
	    }
	    return;
	}

	/*
	 * Remove FCS trailer.
	 */
	ilen -= 2;
	sc->sc_m->m_len-=2;

	if (sc->sc_flags & SC_LOG_INPKT)
	{
	    pdebug((LOG_DEBUG, "ppp%d: got %d bytes", sc->dib.dib_unit, ilen));
	}

	ppppktin(sc, sc->sc_m, ilen);

	return;
    }

    if (sc->sc_flags & SC_FLUSH)
    {
	if (sc->sc_flags & SC_LOG_FLUSH)
	    ppplogchar(sc, c);
	return;
    }

    if (c < 0x20 && (sc->sc_rasyncmap & (1 << c)))
	return;

    if (sc->sc_flags & SC_ESCAPED)
    {
        sc->sc_flags &= ~SC_ESCAPED;
        c ^= PPP_TRANS;
    }
    else if (c == PPP_ESCAPE)
    {
        sc->sc_flags |= SC_ESCAPED;
        return;
    }

    /*
     * Initialize buffer on first octet received.
     * First octet could be address or protocol (when compressing
     * address/control).
     * Second octet is control.
     * Third octet is first or second (when compressing protocol)
     * octet of protocol.
     * Fourth octet is second octet of protocol.
     */
    if (sc->sc_ilen == 0)
    {
        /* reset the first input mbuf */
        m = sc->sc_m;

        /* Paranoia */
        if (!m)
        {
            return;
        }

        m->m_type = 0; /* Mark packet as unread */
        m->m_len = 0;
        m->m_off = m->m_inioff + HDROFF;
	sc->sc_mp = mtod(m, char *);
	sc->sc_fcs = PPP_INITFCS;
	if (c != PPP_ALLSTATIONS)
	{
	    if (sc->sc_flags & SC_REJ_COMP_AC)
	    {
	        if (sc->sc_flags & SC_DEBUG)
	            pdebug((LOG_DEBUG, "ppp%d: garbage received: 0x%x (need 0xFF)",
                	       sc->dib.dib_unit, c));
                sc->st.st_rx_general_errors++;
                goto flush;
	    }
	    *sc->sc_mp++ = PPP_ALLSTATIONS;
	    *sc->sc_mp++ = PPP_UI;
	    sc->sc_ilen += 2;
	    m->m_len += 2;
	}
    }
    if (sc->sc_ilen == 1 && c != PPP_UI)
    {
        if (sc->sc_flags & SC_DEBUG)
            pdebug((LOG_DEBUG, "ppp%d: missing UI (0x3), got 0x%x",
	       sc->dib.dib_unit, c));
	sc->st.st_rx_general_errors++;
	goto flush;
    }
    if (sc->sc_ilen == 2 && (c & 1) == 1)
    {
        /* a compressed protocol */
        *sc->sc_mp++ = 0;
        sc->sc_ilen++;
        sc->sc_m->m_len++;
    }
    if (sc->sc_ilen == 3 && (c & 1) == 0)
    {
        if (sc->sc_flags & SC_DEBUG)
            pdebug((LOG_DEBUG, "ppp%d: bad protocol %x", sc->dib.dib_unit,
	       (sc->sc_mp[-1] << 8) + c));
	sc->st.st_rx_general_errors++;
	goto flush;
    }

    /* packet beyond configured mru? */
    if (++sc->sc_ilen > sc->sc_mru + PPP_HDRLEN + PPP_FCSLEN)
    {
        if (sc->sc_flags & SC_DEBUG)
            pdebug((LOG_DEBUG, "ppp%d: packet too big", sc->dib.dib_unit));
        sc->st.st_overlong_frames++;
        goto flush;
    }

    m=sc->sc_m;

    ++m->m_len;
    *sc->sc_mp++ = c;
    sc->sc_fcs = PPP_FCS(sc->sc_fcs, c);
    return;

  flush:
    if (!(sc->sc_flags & SC_FLUSH))
    {
        sc->sc_flags |= SC_FLUSH;
        if (sc->sc_flags & SC_LOG_FLUSH)
            ppplogchar(sc, c);
    }
}


#define MAX_DUMP_BYTES	128

void pppdumpm(struct mbuf *m0, int pktlen)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    struct mbuf *m;
    static const char digits[] = "0123456789abcdef";

    for (m = m0; m && pktlen; m = m->m_next)
    {
        int l = m->m_len;
        u_char *rptr = mtod(m, u_char *);

        if (pktlen > 0)
        {
	    if (l > pktlen)
	 	l = pktlen;
	    pktlen -= l;
	}
	while (l--)
	{
	    if (bp > buf + sizeof(buf) - 4)
                goto done;
	    *bp++ = digits[*rptr >> 4]; /* convert byte to ascii hex */
	    *bp++ = digits[*rptr++ & 0xf];
	}

	if (m->m_next)
	{
	    if (bp > buf + sizeof(buf) - 3)
                goto done;
	    *bp++ = '|';
	}
	else
	    *bp++ = ' ';
    }
  done:
    if (m && pktlen)
	*bp++ = '>';
    *bp = 0;
    pdebug((LOG_DEBUG, "%s", buf));
}

/*void pppdumpms(struct mbuf *m0, int pktlen)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    struct mbuf *m;
    static const char digits[] = "0123456789abcdef";

    for (m = m0; m && pktlen; m = m->m_next)
    {
        int l = m->m_len;
        u_char *rptr = mtod(m, u_char *);

        if (pktlen > 0)
        {
	    if (l > pktlen)
	 	l = pktlen;
	    pktlen -= l;
	}
	while (l--)
	{
	    if (bp > buf + sizeof(buf) - 4)
                goto done;
	    *bp++ = digits[*rptr >> 4];
	    *bp++ = digits[*rptr++ & 0xf];
	}

	if (m->m_next)
	{
	    if (bp > buf + sizeof(buf) - 3)
                goto done;
	    *bp++ = '|';
	}
	else
	    *bp++ = ' ';
    }
  done:
    if (m && pktlen)
	*bp++ = '>';
    *bp = 0;
    printf("%s\n", buf);
}*/

static void ppplogchar(struct ppp_softc *sc, int c)
{
    if (c >= 0)
	sc->sc_rawin[sc->sc_rawin_count++] = c;
    if (sc->sc_rawin_count >= sizeof(sc->sc_rawin)
	|| c < 0 && sc->sc_rawin_count > 0) {
	    pdebug((LOG_DEBUG, "ppp%d input: ", sc->dib.dib_unit));
	    pppdumpb((u_char *) sc->sc_rawin, sc->sc_rawin_count);
	    sc->sc_rawin_count = 0;
	}
}

static void pppdumpb(u_char *b, int l)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    static char digits[] = "0123456789abcdef";

    while (l--)
    {
	    if (bp >= buf + sizeof(buf) - 3)
	    {
                    *bp++ = '>';
                    break;
	    }
	    *bp++ = digits[*b >> 4]; /* convert byte to ascii hex */
	    *bp++ = digits[*b++ & 0xf];
	    *bp++ = ' ';
    }

    *bp = 0;
    pdebug((LOG_DEBUG, "%s", buf));
}

extern int s; /* A socket to fiddle with */

static void update_flags(struct ppp_softc *sc, unsigned change, unsigned newval)
{
    /*struct ifreq ifr;
    unsigned flags;

    sprintf(ifr.ifr_name, "ppp%d", sc-ppp_softc);

    socketioctl(s, SIOCGIFFLAGS, (caddr_t) &ifr);

    ifr.ifr_flags=flags=(ifr.ifr_flags &~ change) | newval;

    socketioctl(s, SIOCSIFFLAGS, (caddr_t) &ifr);

    ifr.ifr_flags=flags;

    socketioctl(s, SIOCSIFFLAGS, (caddr_t) &ifr);

    sc->moreflags=flags;*/

    sc->moreflags=(sc->moreflags &~ change) | newval;

    if ((dialler_flags & DiallerFlags_UsingDialler) &&
        (dialler_flags & DiallerFlags_AutoDial) && !finalising)
    {
        sc->st.st_link_status |= ST_STATUS_ACTIVE;
    }

    else
    {
        sc->st.st_link_status &= ~ST_STATUS_ACTIVE;

        if (sc->moreflags & IFF_RUNNING)
            sc->st.st_link_status |= ST_STATUS_ACTIVE;
    }
}

#endif	/* NPPP > 0 */
