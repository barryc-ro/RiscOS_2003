/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 4.1.7.3  1997/03/21 12:38:50  jfarrell
 * Update to PPP 1.15, using Internet 5 libraries.
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "errno.h"

#include "sys/types.h"
#include "sys/dcistructs.h"

#include "net/if.h"
#include "netinet/in_systm.h"
#include "netinet/in.h"
#include "netinet/if_ether.h"
#include "sys/signal.h"
#include "sys/syslog.h"

#include "kernel.h"
#include "swis.h"

#include "ppp_io.h"
#include "pppmodule.h"

#ifdef BLOCKDRIVERS
    #include "blockdrive.h"
#else
    #include "ioctl.h"
#endif

#include "if_ppp.h"
#include "ppphdr.h"

#include "pppd/minixlib.h"
#include "pppd/main.h"
#include "serial.h"

#define TickerV 0x1C
#define UpCallV 0x1D


extern int splhi(void);
extern void splx(int);

#define Event_OutputEmpty 0
#define Event_SerialError 7

#define SerialError_Overrun 0x10
#define SerialError_Framing 0x08
#define SerialError_DCD     0x02

#ifdef BLOCKDRIVERS
int *driver_speedtable;
int driver_noofspeeds;
#else
int serial_in = 0;
int serial_out = 0;
static int callback_pending = 0;
#endif

int serialevents_active;

#if 0
static volatile u_char *framing_error;
#endif

extern void *module_wsp;

#ifdef BLOCKDRIVERS
int poll_pending = 0;
int portnumber=0;
#endif

#ifdef BLOCKDRIVERS

/*
 * iprelease - remove routine from InsV so we no longer catch serial
 * input characters
 */
static void release_ticker(void)
{
    _swix(OS_RemoveTickerEvent, _INR(0,1), hupcheck_entry, module_wsp);
    _swix(OS_Release, _INR(0,2), TickerV, ticker_handler, module_wsp);
}

#else

static void release_upcall (void)
{
    _swix(OS_RemoveTickerEvent, _INR(0,1), hupcheck_entry, module_wsp);
    _swix(OS_Release, _INR (0, 2), UpCallV, upcall_entry, module_wsp);
}

#endif


/**********************************************************************/

#ifdef BLOCKDRIVERS

/*
 * ipcatch - add routine to InsV to catch serial input characters
 */
static _kernel_oserror *claim_ticker(void)
{
    _kernel_oserror *e=0;

    e=_swix(OS_CallEvery, _INR(0,2), 99, hupcheck_entry, module_wsp);
    if (e)
        return e;

    return _swix(OS_Claim, _INR(0,2), TickerV, ticker_handler, module_wsp);
}

#else

static _kernel_oserror *claim_upcall (void)
{
    _kernel_oserror *e = NULL;

    e = _swix(OS_CallEvery, _INR(0,2), 99, hupcheck_entry, module_wsp);
    if (e)
    {
        return e;
    }

    e = _swix (OS_Claim, _INR (0, 2), UpCallV, upcall_entry, module_wsp);

    /* Check if there is any data in the buffer to start with and if so read
     * and process it (if this isn't done then the Device_RxDataPresent upcall
     * would never be issued because the buffer would never be empty).
     */
    _swix (OS_Args, _INR (0, 1) | _OUT (2), 2, serial_in, &bytes);
    if (bytes > 0)
    {
        _swix (OS_AddCallBack, _INR (0, 1), poll_entry, module_wsp);
        callback_pending = 1;    /* prevent multiple callback being added */
    }

    return e;
}

#endif

/**********************************************************************/

#ifdef BLOCKDRIVERS

_kernel_oserror *hupcheck_handler(_kernel_swi_regs *r, void *pw)
{
    idle_time++;

    if (modem && (driver_modemcontrol() & 8) == 0)
        _swix(OS_AddCallBack, _INR(0,1), hup_entry, module_wsp);
    else if (idle_time_limit && idle_time >= idle_time_limit)
        _swix(OS_AddCallBack, _INR(0,1), term_entry, module_wsp);

    return NULL;
}

#else

_kernel_oserror *hupcheck_handler(_kernel_swi_regs *r, void *pw)
{
    ioctl_t ioctl;


    NOT_USED (r);
    NOT_USED (pw);

    idle_time++;

    ioctl.reason = IOCtl_control_lines;
    ioctl.group = 0;
    ioctl.reserved = 0;
    ioctl.read = 1;
    ioctl.write = 0;

    _swix (OS_Args, _INR (0, 2), OS_Args_IOCtl, serial_in, &ioctl);
    if (modem && (ioctl.data & IOCtl_control_line_DCD) == 0)
        _swix(OS_AddCallBack, _INR(0,1), hup_entry, module_wsp);
    else if (idle_time_limit && idle_time >= idle_time_limit)
        _swix(OS_AddCallBack, _INR(0,1), term_entry, module_wsp);

    return NULL;
}

#endif

/**********************************************************************/

_kernel_oserror *hup_handler(_kernel_swi_regs *r, void *pw)
{
    NOT_USED(pw);
    NOT_USED(r);

    pppd_signal_handler(SIGHUP);

    return NULL;
}

_kernel_oserror *term_handler(_kernel_swi_regs *r, void *pw)
{
    NOT_USED(pw);
    NOT_USED(r);

    syslog(LOG_INFO, "Idle for %d seconds", idle_time_limit);

    pppd_signal_handler(SIGTERM);

    return NULL;
}

void serial_enableevents(void)
{
    serialevents_active=1;
}

/**********************************************************************/

/*
 * poll_cancel - remove any pending call to poll_entry
 */

#ifdef BLOCKDRIVERS

static void poll_cancel(void)
{
    int s = splhi();

    if (poll_pending)
    {
        _swix(OS_RemoveCallBack, _INR(0,1), poll_entry, module_wsp);

        poll_pending = 0;
    }

    splx(s);
}

#else

static void poll_cancel (void)
{
    if (callback_pending)
    {
        _swix(OS_RemoveCallBack, _INR(0,1), poll_entry, module_wsp);
        callback_pending = 0;
    }
}

#endif

/**********************************************************************/

#ifdef BLOCKDRIVERS

/* XXX Trace */
extern int rxerrors;

/*
 * poll_handler - it is time to check whether there are any characters
 * in the input buffer again.  try to drain the buffer, then reset the
 * timeout to call this routine again
 */
_kernel_oserror *poll_handler(_kernel_swi_regs *r, void *pw)
{

    char buffer[256], *p=buffer;
    int bytes, error;
    /* int s; */

    _kernel_irqs_on ();

    NOT_USED(pw);
    NOT_USED(r);

    bytes=driver_getblock(buffer, sizeof buffer);
    error=(driver_rxerrors() & 7);

    while (bytes)
    {
        /*s=splhi();*/
        p=buffer;

        while (bytes)
        {
            pppinput(*p, 0);
            bytes--;
            p++;
        }
        if (error)
        {
            /*rxerrors++;*/
            pppinput(256, 0);
        }

        /*splx(s);*/

        bytes=driver_getblock(buffer, sizeof buffer);
        error=(driver_rxerrors() & 7);
    }

    poll_pending = 0;

    return NULL;
}

#else

_kernel_oserror *poll_handler(_kernel_swi_regs *r, void *pw)
{

    char buffer[256], *p=buffer;
    int bytes, bytes_not_done;

    _kernel_irqs_on ();

    callback_pending = 0;    /* no callbacks waiting */

    NOT_USED(pw);
    NOT_USED(r);

    /* Read amount of data in serial input buffer */
    _swix (OS_Args, _INR (0, 1) | _OUT (2), 2, serial_in, &bytes);

    if (bytes > 0)
    {
        if (bytes > sizeof (buffer))
            bytes = sizeof (buffer);

        /* Read data from serial input buffer */
        _swix (OS_GBPB, _INR (0, 3) | _OUT (3),
               4, serial_in, buffer, bytes, &bytes_not_done);
        bytes -= bytes_not_done;
    }

    while (bytes)
    {
        p = buffer;

        while (bytes)
        {
            pppinput(*p, 0);
            bytes--;
            p++;
        }

        _swix (OS_Args, _INR (0, 1) | _OUT (2), 2, serial_in, &bytes);
        if (bytes > 0)
        {
            /* If there is more data to read and a DeviceRxDataPresent upcall
             * occurred while this function was executing then an upcall will
             * have been added.  This is no longer necessary as the data it
             * informed us about is just about to be read anyway, so remove the
             * upcall.
             */

            if (callback_pending)
            {
                _swix (OS_RemoveCallBack, _INR (0, 1), poll_handler, pw);
                callback_pending = 0;
            }

            if (bytes > sizeof (buffer))
                bytes = sizeof (buffer);

            _swix (OS_GBPB, _INR (0, 3) | _OUT (3),
                   4, serial_in, buffer, bytes, &bytes_not_done);
            bytes -= bytes_not_done;
        }
    }

    return NULL;
}

#endif

/**********************************************************************/

_kernel_oserror *serial_finalise(void)
{
#ifdef BLOCKDRIVERS
    release_ticker();
#else
    release_upcall();
#endif

    poll_cancel();

#ifdef BLOCKDRIVERS
    driver_closedown();
#else
    if (serial_in != 0)
    {
        _swix (OS_Find, _INR (0, 1), 0, serial_in);

        serial_in = 0;
    }

    if (serial_out != 0)
    {
        _swix (OS_Find, _INR (0, 1), 0, serial_out);
        serial_out = 0;
    }
#endif


    return(NULL);
}


/**********************************************************************/

#ifdef BLOCKDRIVERS

_kernel_oserror *serial_initialise(struct ppp_softc *sc)
{
    char *error;
    _kernel_oserror *e = NULL;


    NOT_USED (sc);

#ifdef TINYSTUBS
    poll_pending=0;
    portnumber=0;
#endif

    error=driver_initialise();

    if (error)
    {
        strcpy(_ppp_errblk.errmess, error);
        _ppp_errblk.errnum = 1;
        e=&_ppp_errblk;
    }

    if (!e)
        e=claim_ticker();

    driver_speedtable=driver_block+64;

    return e;
}

#else

_kernel_oserror *serial_initialise(struct ppp_softc *sc)
{
    NOT_USED (sc);

    return (claim_upcall ());
}

#endif

/**********************************************************************/

#ifndef BLOCKDRIVERS

int upcall_handler (_kernel_swi_regs *r, void *pw)
{
    switch (r->r[0])
    {
        case 15:    /* DeviceRxDataPresent */
            /* Only interested in the serial input stream */
            if (r->r[1] != serial_in)
            {
                return (0);    /* Pass on the call */
            }

            _swix (OS_AddCallBack, _INR (0, 1), poll_entry, pw);
            callback_pending = 1;    /* prevent multiple callback being added */
            break;

        case 16:    /* DeviceThresAbove */
            /* Only interested in the serial output stream */
            if (r->r[1] != serial_out)
            {
                return (0);    /* Pass on the call */
            }

            if (serialevents_active)
            {
                serialevents_active = 0;
                _swix (OS_AddCallBack, _INR (0, 1), start_entry, pw);
            }
            break;

        default:
            return (0);    /* Pass on call */
    }

    return (1);    /* Intercept the call */
}

#endif

/**********************************************************************/

/* EOF serial.c */
