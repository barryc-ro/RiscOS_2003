/* -*-C-*-
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * 1998-03-09: BAL
 * Idle timer was mistakenly being incremented twice in hangup check handler.
 * Removed reliance on Dialler for hangup check if dialler option is used on
 * command line.
 *
 * 1998-05-12: BAL
 * Fixed bug in dual serial poll_handler: call to remove callback was passing
 * address of handler function rather than veneer routine.  This call would
 * obviously fail silently, but any pending callback would still go off.  This
 * was resulting in PPP blocking heavily in certain situations.
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "errno.h"

#include "sys/types.h"
#include "sys/dcistructs.h"

#include "net/if.h"
#include "netinet/in_systm.h"
#include "netinet/in.h"
#include "netinet/if_ether.h"
#include "sys/signal.h"
#include "sys/syslog.h"

#include "kernel.h"
#include "swis.h"

#include "ppp_io.h"
#include "pppmodule.h"

#ifdef BLOCKDRIVERS
  #include "blockdrive.h"
#else
  #include "ioctl.h"
#endif

#include "if_ppp.h"
#include "ppphdr.h"

#include "pppd/minixlib.h"
#include "pppd/main.h"
#include "serial.h"

#include "dialler.h"
#include "MemCheck/MemCheck.h"

#define TickerV 0x1C
#define UpCallV 0x1D


#define Service_PPPTimingOut 0xc0


extern int splhi(void);
extern void splx(int);

#define Event_OutputEmpty 0
#define Event_SerialError 7

#define SerialError_Overrun 0x10
#define SerialError_Framing 0x08
#define SerialError_DCD     0x02

#ifdef BLOCKDRIVERS
  int *driver_speedtable;
  int driver_noofspeeds;
#else
  int serial_in = 0;
  int serial_out = 0;
  static int callback_pending = 0;
  int start_callback_pending = FALSE;
#endif

int serialevents_active = FALSE;

#if 0
  static volatile u_char *framing_error;
#endif

extern void *module_wsp;

#ifdef BLOCKDRIVERS
  int poll_pending = 0;
  int portnumber=0;
#endif

#ifdef BLOCKDRIVERS

/*
 * iprelease - remove routine from InsV so we no longer catch serial
 * input characters
 */
static void release_ticker(void)
{
    _swix(OS_RemoveTickerEvent, _INR(0,1), hupcheck_entry, module_wsp);
    _swix(OS_Release, _INR(0,2), TickerV, ticker_handler, module_wsp);
}

#else

static void release_upcall (void)
{
    _swix(OS_RemoveTickerEvent, _INR(0,1), hupcheck_entry, module_wsp);
    _swix(OS_Release, _INR (0, 2), UpCallV, upcall_entry, module_wsp);
}

#endif


/**********************************************************************/

#ifdef BLOCKDRIVERS

/*
 * ipcatch - add routine to InsV to catch serial input characters
 */
static _kernel_oserror *claim_ticker(void)
{
    _kernel_oserror *e = NULL;

    e=_swix(OS_CallEvery, _INR(0,2), 99, hupcheck_entry, module_wsp);
    if (e)
    {
        return e;
    }

    return _swix(OS_Claim, _INR(0,2), TickerV, ticker_handler, module_wsp);
}

#else

static _kernel_oserror *claim_upcall (void)
{
    int bytes;
    _kernel_oserror *e = NULL;


    e = _swix(OS_CallEvery, _INR(0,2), 99, hupcheck_entry, module_wsp);
    if (e)
    {
        return e;
    }

    e = _swix (OS_Claim, _INR (0, 2), UpCallV, upcall_entry, module_wsp);

    /* Check if there is any data in the buffer to start with and if so read
     * and process it (if this isn't done then the Device_RxDataPresent upcall
     * would never be issued because the buffer would never be empty).
     */
    _swix (OS_Args, _INR (0, 1) | _OUT (2), 2, serial_in, &bytes);
    if (bytes > 0)
    {
        _swix (OS_AddCallBack, _INR (0, 1), poll_entry, module_wsp);
        callback_pending = TRUE;    /* prevent multiple callback being added */
    }

    return e;
}

#endif

/**********************************************************************/

_kernel_oserror *hupcheck_handler(_kernel_swi_regs *r, void *pw)
{
    NOT_USED (r);
    NOT_USED (pw);

    /* Check DCD line */
    if (modem && serial_dcd == 0)
    {
        /* DCD has been dropped */
        _swix(OS_AddCallBack, _INR(0,1), hup_entry, module_wsp);
    }
    else
    {
        int interrupt_status;


        /* atomic update and test of counter */
        interrupt_status = splhi ();
        idle_time++;

        if (idle_time_limit > 0 && idle_time >= idle_time_limit)
        {
            int not_claimed;

            restore_irqs (interrupt_status);

            /* Issue Servive Call to indicate PPP is about to timeout.  If this
             * Service Call is claimed then do not timeout.
             */
            _swix (OS_ServiceCall, _IN (1) | _OUT (1),
                   Service_PPPTimingOut, &not_claimed);

            if (not_claimed)
            {
                _swix (OS_AddCallBack, _INR (0,1), term_entry, module_wsp);
            }
            else
            {
                /* another atomic counter update */
                interrupt_status = splhi ();
                idle_time = 0;
                restore_irqs (interrupt_status);
            }
        }
        else
        {
            restore_irqs (interrupt_status);
        }
    }

    return NULL;
}

/**********************************************************************/

_kernel_oserror *hup_handler(_kernel_swi_regs *r, void *pw)
{
    NOT_USED(pw);
    NOT_USED(r);

    pppd_signal_handler(SIGHUP);

    return NULL;
}

_kernel_oserror *term_handler(_kernel_swi_regs *r, void *pw)
{
    NOT_USED(pw);
    NOT_USED(r);

    syslog(LOG_INFO, "Idle for %d seconds", idle_time_limit);

    pppd_signal_handler(SIGTERM);

    return NULL;
}

void serial_enableevents(void)
{
    pdebug ((LOG_DEBUG, "serial_enableevents"));
    serialevents_active = TRUE;
}


#ifdef BLOCKDRIVERS

void serial_disableevents (void)
{
    serialevents_active = FALSE;
}

#else

void serial_disableevents (void)
{
    /* Set the serialevent_active flag to zero and release any pending callback
     * to pppstart
     */

    serialevents_active = FALSE;

    if (start_callback_pending)
    {
        pdebug ((LOG_DEBUG, "removing callback to start_entry"));
        start_callback_pending = FALSE;
        _swix (OS_RemoveCallBack, _INR (0, 1), start_entry, module_wsp);
    }
}

#endif

/**********************************************************************/

/*
 * poll_cancel - remove any pending call to poll_entry
 */

#ifdef BLOCKDRIVERS

static void poll_cancel(void)
{

    if (poll_pending)
    {
        int interrupt_status = splhi ();


        _swix(OS_RemoveCallBack, _INR (0, 1), poll_entry, module_wsp);
        poll_pending = FALSE;
        restore_irqs (interrupt_status);
    }
}

#else

static void poll_cancel (void)
{
    if (callback_pending)
    {
        int interrupt_status = splhi ();


        pdebug ((LOG_DEBUG, "removing callback"));
        _swix(OS_RemoveCallBack, _INR (0, 1), poll_entry, module_wsp);
        callback_pending = FALSE;
        restore_irqs (interrupt_status);
    }
}

#endif

/**********************************************************************/

#ifdef BLOCKDRIVERS

/* XXX Trace */
extern int rxerrors;

/*
 * poll_handler - it is time to check whether there are any characters
 * in the input buffer again.  try to drain the buffer, then reset the
 * timeout to call this routine again
 */
_kernel_oserror *poll_handler(_kernel_swi_regs *r, void *pw)
{

    char buffer[256], *p=buffer;
    int bytes, error;
    /* int s; */

    _kernel_irqs_on ();

    NOT_USED(pw);
    NOT_USED(r);

    bytes=driver_getblock(buffer, sizeof buffer);
    error=(driver_rxerrors() & 7);

    while (bytes)
    {
        /*s=splhi();*/
        p=buffer;

        while (bytes)
        {
            pppinput(*p, 0);
            bytes--;
            p++;
        }
        if (error)
        {
            /*rxerrors++;*/
            pppinput(256, 0);
        }

        /*splx(s);*/

        bytes=driver_getblock(buffer, sizeof buffer);
        error=(driver_rxerrors() & 7);
    }

    poll_pending = 0;

    return NULL;
}

#else

_kernel_oserror *poll_handler(_kernel_swi_regs *r, void *pw)
{

    char buffer[256], *p=buffer;
    int bytes, bytes_not_done;
    int interrupt_status;
    _kernel_oserror *e = NULL;


    /* atomic update of callback pending flag */
    interrupt_status = splhi ();
    callback_pending = FALSE;    /* no callbacks waiting */
    restore_irqs (interrupt_status);

    _kernel_irqs_on ();

    NOT_USED(pw);
    NOT_USED(r);

    e = _swix (OS_GBPB, _INR (0, 3) | _OUT (3),
               4, serial_in, buffer, sizeof (buffer), &bytes_not_done);
    if (e)
    {
        pdebug ((LOG_DEBUG, "error %d: %s", e->errnum, e->errmess));
        return NULL;
    }
    bytes = sizeof (buffer) - bytes_not_done;
    pdebug ((LOG_DEBUG, "read first block: %d bytes", bytes));

    while (bytes)
    {
        /*s=splhi();*/
        p=buffer;

        while (bytes)
        {
            pppinput(*p, 0);
            bytes--;
            p++;
        }

        /*splx(s);*/

        e = _swix (OS_GBPB, _INR (0, 3) | _OUT (3),
                   4, serial_in, buffer, sizeof (buffer), &bytes_not_done);
        if (e)
        {
            pdebug ((LOG_DEBUG, "error %d: %s", e->errnum, e->errmess));
            return NULL;
        }

        bytes = sizeof (buffer) - bytes_not_done;
        pdebug ((LOG_DEBUG, "read block: %d bytes", bytes));

        if (bytes > 0)
        {
            /* If there is more data to read and a DeviceRxDataPresent upcall
             * occurred while this function was executing then an upcall will
             * have been added.  This is no longer necessary as the data it
             * informed us about is just about to be read anyway, so remove the
             * upcall.
             */

            if (callback_pending)
            {
                pdebug ((LOG_DEBUG, "about to remove callback"));
                _swix (OS_RemoveCallBack, _INR (0, 1), poll_entry, pw);

                /* atomic update of callback pending flag */
                interrupt_status = splhi ();
                callback_pending = FALSE;    /* no callbacks waiting */
                restore_irqs (interrupt_status);

                pdebug ((LOG_DEBUG, "callback removed"));
            }
        }
    }

    return NULL;
}

#endif

/**********************************************************************/

_kernel_oserror *serial_finalise(void)
{
#ifdef BLOCKDRIVERS
    release_ticker();
#else
    release_upcall();
#endif

    poll_cancel();

#ifdef BLOCKDRIVERS
    driver_closedown();
#else
    if ((dialler_flags & DiallerFlags_UsingDialler) == 0)
    {
        if (serial_in != 0)
        {
            _swix (OS_Find, _INR (0, 1), 0, serial_in);
            serial_in = 0;
        }

        if (serial_out != 0)
        {
            _swix (OS_Find, _INR (0, 1), 0, serial_out);
            serial_out = 0;
        }
    }
#endif

    if (dialler_flags & DiallerFlags_UsingDialler)
    {
        if (dialler_flags & DiallerFlags_DiallerB)
        {
            _swix (DiallerB_Arbitrate,
                   _IN (0),

                   Dialler_Arbitrate_RelinquishAccess);
        }
        else
        {
            _swix (Dialler_Arbitrate,
                   _IN (0),

                   Dialler_Arbitrate_RelinquishAccess);
        }
    }

    return(NULL);
}


/**********************************************************************/

#ifdef BLOCKDRIVERS

_kernel_oserror *serial_initialise(struct ppp_softc *sc)
{
    char *error;
    _kernel_oserror *e = NULL;


    NOT_USED (sc);

#ifdef TINYSTUBS
    poll_pending=0;
    portnumber=0;
#endif

    if ((dialler_flags & DiallerFlags_UsingDialler))
    {
        int io_access_granted;


        if (dialler_flags & DiallerFlags_DiallerB)
        {
            e = _swix (DiallerB_Arbitrate,
                       _IN (0) | _OUT (0),

                       Dialler_Arbitrate_RequestIOAccess,

                       &io_access_granted);
        }
        else
        {
            e = _swix (Dialler_Arbitrate,
                       _IN (0) | _OUT (0),

                       Dialler_Arbitrate_RequestIOAccess,

                       &io_access_granted);
        }

        if (e)
            return (e);

        if (io_access_granted != Dialler_IOAccessGranted_BlockDrivers)
        {
            strcpy (_ppp_errblk.errmess,
                    "PPP was refused access to the serial port");
            _ppp_errblk.errnum = 1;
            return &_ppp_errblk;
        }
    }


    error=driver_initialise();

    if (error)
    {
        strcpy(_ppp_errblk.errmess, error);
        _ppp_errblk.errnum = 1;
        e=&_ppp_errblk;
    }

    if (!e)
        e=claim_ticker();

    driver_speedtable=driver_block+64;

    return e;
}

#else

#define OutputFreeSpaceThres 63

_kernel_oserror *serial_initialise(struct ppp_softc *sc)
{
    _kernel_oserror *e = NULL;


    NOT_USED (sc);

    if ((dialler_flags & DiallerFlags_UsingDialler))
    {
        int io_access_granted;


        /* Get the serial file handles from the dialler */
        if (dialler_flags & DiallerFlags_DiallerB)
        {
            e = _swix (DiallerB_Arbitrate,
                       _IN (0) | _OUTR (0, 2),

                       Dialler_Arbitrate_RequestIOAccess,

                       &io_access_granted,
                       &serial_in,
                       &serial_out);
        }
        else
        {
            e = _swix (Dialler_Arbitrate,
                       _IN (0) | _OUTR (0, 2),

                       Dialler_Arbitrate_RequestIOAccess,

                       &io_access_granted,
                       &serial_in,
                       &serial_out);
        }

        if (e)
            return (e);

        if (io_access_granted != Dialler_IOAccessGranted_DualSerial)
        {
            strcpy (_ppp_errblk.errmess,
                    "PPP was refused access to the serial port");
            _ppp_errblk.errnum = 1;
            return &_ppp_errblk;
        }
    }

    else
    {
        ioctl_t ioctl;

        /* Open an input and output stream on the serial device */

        e = _swix (OS_Find, _INR (0, 1) | _OUT (0), 0x4f, devname, &serial_in);
        if (e)
            return (e);

        e = _swix (OS_Find, _INR (0, 1) | _OUT (0), 0xcf, devname, &serial_out);
        if (e)
            return (e);

        ioctl.reason = IOCtl_buffer_threshold;
        ioctl.group = 0;
        ioctl.reserved = 0;
        ioctl.read = 1;
        ioctl.write = 1;
        ioctl.data = OutputFreeSpaceThres;

        _swix (OS_Args, _INR (0, 2), OS_Args_IOCtl, serial_out, &ioctl);

#if 0
        /* This hack was to work around a bug in the dual serial module whereby if
         * the buffer threshold was changed, the change would only take effect the
         * next time a stream was opened.  This has been fixed in versions of
         * dual serial from 0.19.
         */

        _swix (OS_Find, _INR (0, 1), 0, serial_out);    /* close stream */

        e = _swix (OS_Find, _INR (0, 1) | _OUT (0), 0xcf, devname, &serial_out);
        if (e)
            return (e);
#endif
    }

    return (claim_upcall ());
}

#endif

/**********************************************************************/

#ifndef BLOCKDRIVERS

extern unsigned int get_pc (void);
int upcall_handler (_kernel_swi_regs *r, void *pw)
{
    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));
    switch (r->r[0])
    {
        case 15:    /* DeviceRxDataPresent */
            pdebug ((LOG_DEBUG, "DeviceRxDataPresent (%d)", r->r[1]));
            /* Only interested in the serial input stream */
            if (r->r[1] != serial_in)
            {
                MemCheck_UnRegisterMiscBlock (r);
                return (1);    /* Pass on the call */
            }

            _swix (OS_AddCallBack, _INR (0, 1), poll_entry, pw);
            callback_pending = TRUE;    /* prevent multiple callback being added */
            break;

        case 16:    /* DeviceThresAbove */
            pdebug ((LOG_DEBUG, "DeviceThresAbove (%d)", r->r[1]));
            MemCheck_UnRegisterMiscBlock (r);
            return (1);    /* Pass on call */


        case 17:    /* DeviceThresBelow */
            pdebug ((LOG_DEBUG, "DeviceThresBelow (%d)", r->r[1]));

            /* Only interested in the serial output stream */
            if (r->r[1] != serial_out)
            {
                 MemCheck_UnRegisterMiscBlock (r);
                 return (1);    /* Pass on the call */
            }

            if (serialevents_active)
            {
                pdebug ((LOG_DEBUG, "serial events active"));
                serialevents_active = FALSE;
                if (!start_callback_pending)
                {
                    pdebug ((LOG_DEBUG, "adding callback to start_handler"));
                    if (!_swix (OS_AddCallBack, _INR (0, 1), start_entry, pw))
                        start_callback_pending = TRUE;
                }

                else
                {
                    pdebug ((LOG_DEBUG, "callback pending to start_handler"));
                }
            }

            else
            {
                pdebug ((LOG_DEBUG, "serial events not active"));
            }
            break;

        default:
            MemCheck_UnRegisterMiscBlock (r);
            return (1);    /* Pass on call */
    }

    MemCheck_UnRegisterMiscBlock (r);
    return (0);    /* Intercept call */
}

#endif

/* -----------------------------------------------------------------------------
+
   serial_dcd

   Get the status of the DCD line.

   Returns
   0: DCD not asserted (ie. no carrier)
   1: DCD asserted
-
 */

#ifdef BLOCKDRIVERS

extern serial_dcd (void)
{
    if ((driver_modemcontrol() & 8) == 0)
    {
        return 0;
    }

    return 1;
}

#else

extern serial_dcd (void)
{
    ioctl_t ioctl;

    ioctl.reason = IOCtl_control_lines;
    ioctl.group = 0;
    ioctl.reserved = 0;
    ioctl.read = 1;
    ioctl.write = 0;

    _swix (OS_Args, _INR (0, 2), OS_Args_IOCtl, serial_in, &ioctl);

    if ((ioctl.data & IOCtl_control_line_DCD) == 0)
    {
        return 0;
    }

    return 1;
}

#endif

/**********************************************************************/

/* EOF serial.c */
