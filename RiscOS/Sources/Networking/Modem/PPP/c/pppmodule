/* -*-C-*-
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * 1998-03-09: BAL
 * Added support for using DiallerB as well as Dialler for serial stream
 * handle arbitration.
 *
 * Removed support for using Dialler to check for line drops as PPP's
 * built in routines are perfectly good enough.
 */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sys/types.h"
#include "sys/dcistructs.h"
#include "sys/errno.h"
#include "sys/mbuf.h"
#include "sys/signal.h"
#include "sys/ioctl.h"
#include "sys/syslog.h"
#include "pppd/minixlib.h"

#include "net/if.h"
#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/if_ether.h"

#include "kernel.h"
#include "swis.h"

#include "ppp.h"
#include "pppd.h"
#include "pppmodule.h"
#include "serial.h"
#include "if_ppp.h"

#include "pppd/pppd.h"

#ifdef BLOCKDRIVERS
  #include "blockdrive.h"
#else
  #include "ioctl.h"
#endif

#include "pppd/main.h"

#include "ppp_io.h"
#include "ppphdr.h"
#include "mbuf.h"

#include "dialler.h"
#include "svcprint.h"

#ifdef Trace_TRACE
  #include "Trace.Trace.h"
#endif

#include "MemCheck/MemCheck.h"


#define PPP_AlterSettings_Timeout        0

#define PPP_Status_Timeout               0
#define PPP_Status_Connection            1



/*** XXX TRACE ***/
#if 0
int ppp_headers_added_in_pppoutput;
int queued_in_pppoutput;
int passed_into_transmit;
#endif

#if 0
static unsigned int original_int_handler = 0;
extern void intercept (void);
#endif

struct swient
{
    static int (*swi_call)(_kernel_swi_regs *);			/* swi handler */
};

struct client
{
    static _kernel_oserror *(*cli_call)(int argc, char **argv);
};

extern int s; /* A socket to fiddle with */

static int ppp_version(_kernel_swi_regs *), ppp_setmtu(_kernel_swi_regs *);
static int ppp_getmtu(_kernel_swi_regs *), ppp_filter(_kernel_swi_regs *);
static int ppp_inquire(_kernel_swi_regs *), ppp_transmit(_kernel_swi_regs *);
static int ppp_stats(_kernel_swi_regs *);

static struct stats st;

static struct swient ppp_ent[] =
{
    ppp_version,
    ppp_inquire,
    ppp_getmtu,
    ppp_setmtu,
    ppp_transmit,
    ppp_filter,
    ppp_stats
};

static _kernel_oserror *do_pppinfo(int argc, char **argv);
static _kernel_oserror *do_startppp(int argc, char **argv);
static _kernel_oserror *do_stopppp(int argc, char **argv);
static _kernel_oserror *do_ppplog(int argc, char **argv);

static struct client ppp_cli_call[] =
{
    do_pppinfo,
    do_startppp,
    do_stopppp,
    do_ppplog
};

void *module_wsp = 0;

_kernel_oserror _ppp_errblk = { 0 };

extern void pppdumpm(struct mbuf *m0, int pktlen);

#define pppcnt NPPP

extern const char *usage_string;

static int managerstarted = 0;
int finalising = 0;

#ifdef Trace_TRACE
  static int trace_depth = 1;
#endif


/**********************************************************************/

static _kernel_oserror *ppp_error(int error)
{
    if (error)
    {
	if (error >= 0x80)
	    _ppp_errblk.errnum = error;
	else
	    REALLYSETDCI4ERRNO(_ppp_errblk.errnum, error);

	strcpy(_ppp_errblk.errmess, "PPP module error");
	return &_ppp_errblk;
    }
    else
	return 0;
}


/**********************************************************************/

/*
 * freelist - free an mbuf list
 */

void freelist(struct mbuf *m0)
{
    struct mbuf *m;


    while (m0)
    {
        m=m0->m_list;
        MBCTL.freem(&MBCTL, m0);
        m0=m;
    }
}

/**********************************************************************/

/*
 * set_receive_level - raise and lower the parallel link as
 *                     appropriate
 */

static int set_receive_level(int unit, int addrlevel)
{
    int error=0;
    struct ppp_softc *ppp=&ppp_softc[unit];

    pdebug ((LOG_DEBUG, "ppp: set_receive_level(%d)", addrlevel));
    switch (addrlevel)
    {
        /* we only use ADDRLVL_SPECIFIC */
      case ADDRLVL_SPECIFIC:
        if (!(ppp->moreflags & IFF_RUNNING))
            error=0;/*start_interface();*/
        break;

      default:
      	/*plip_device_clear();*/
        if (ppp->moreflags & IFF_RUNNING)
            error=0;/*stop_interface();*/
        break;
    }

    return error;
}

/**********************************************************************/


/*
 * update_addrlevel - find most general address level for all
 * active filters on a given unit, and ask for hardware to
 * be set to that level.
 */
static int update_addrlevel(int unit)
{
    int level = -1;

    if (ppp_softc[unit].inetfilter)
        level = ADDRLVL_SPECIFIC;

    return set_receive_level(unit, level);

}
/**********************************************************************/

/*
 * check_addrlevel - check that address level for a filter SWI
 * is valid. returns 1 if valid, else 0.
 */
static int check_addrlevel(u_int level)
{
    return((level == ADDRLVL_SPECIFIC) ? 1 : 0);
}


/**********************************************************************/

/*
 * send_frametypefree - raise a service call to let protocol modules
 * know that a given frame type has been freed
 */
static void send_frametypefree(u_int unit)
{
    unsigned frame_type;

    SET_FRAMELEVEL(frame_type, FRMLVL_E2SPECIFIC);
    SET_FRAMETYPE(frame_type, ETHERTYPE_IP);

    _swix(OS_ServiceCall, _INR(0,4), &ppp_softc[unit].dib, Service_DCIFrameTypeFree,
                          frame_type, ADDRLVL_SPECIFIC, ERRLVL_NO_ERRORS);
}

/**********************************************************************/

/*
 * undo_singlefilter - stop a filter iff the recipient protocol
 * module has a private word pointer that matches the one given
 */
static void undo_singlefilter(u_int unit, u_int pwp)
{
    FilterSingleRef fs = ppp_softc[unit].inetfilter;

    if(fs && fs->fs_pwptr == pwp)
    {
	/*
	 * we have a match - send a service call round
	 * to let protocol modules know about new claims
	 * available.
	 */
	send_frametypefree(unit);
	free(fs);
	ppp_softc[unit].inetfilter = NULL;
    }
}

/**********************************************************************/

/*
 * filtersoff - disable filtering for the module
 * with the given private word pointer.
 */
static void filtersoff(u_int pwp)
{
    int unit;

    /*
     * loop over all active units looking for the module
     */
    for(unit = 0; unit < pppcnt; ++unit)
    {
	undo_singlefilter(unit, pwp);

	/*
	 * check whether receiver can be disabled
	 */
	update_addrlevel(unit);
    }
}

/**********************************************************************/

/*
 * do_singlefilter - handle a filter claim or release
 */
static int do_singlefilter(_kernel_swi_regs *r)
{
    int unit = r->r[1];
    FilterSingleRef fs = ppp_softc[unit].inetfilter;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));
    /*
     * check whether claiming or releasing
     */
    if (r->r[0] & FILTER_RELEASE)
    {
	if (!fs)
	{
	    /*
	     * trying to free a non-existent claim
	     */
	    MemCheck_UnRegisterMiscBlock (r);
	    return EINVAL;
	}

	if (fs->fs_handler != (void (*)())r->r[6] || fs->fs_pwptr != r->r[5])
	{
	    /*
	     * trying to release somebody else's claim
	     */
	    MemCheck_UnRegisterMiscBlock (r);
	    return EPERM;
	}

	/*
	 * everything checks out, do the free
	 */
	send_frametypefree(unit);
	free(fs);
	ppp_softc[unit].inetfilter = NULL;

	/*
	 * check whether receiver can be disabled
	 */
	update_addrlevel(unit);
    }
    else
    {
	/*int error;
	struct ppp_softc *ppp = &ppp_softc[unit];*/

	/*
	 * it's a claim - most values have been range checked, but
	 * take a look at frame type (which *must* be zero)
	 */

	if(fs)
	{
#           if 0
	    if( (ppp->ppp_flags & PPP_DUPCLAIMEXPECTED) &&
	       fs &&
	       fs->fs_handler == (void (*)())r->r[6] &&
	       fs->fs_pwptr == r->r[5] )
	    {
		/*
		 * its a legitimate reclaim - need to check that
		 * we can bring the card up live once again.
		 */
		if( (error = enioctl(unit, 1, 1)) != 0 )
		{
		    /*
		     * return an error, but *do not* free the structure
		     */
		    MemCheck_UnRegisterMiscBlock (r);
		    return error;
		}

		/*
		 * set receive level for this unit to the
		 * loosest address filtering necessary.
		 */
		update_addrlevel(unit);
		MemCheck_UnRegisterMiscBlock (r);
		return 0;
	    }
	    else
#           endif
		/*
		 * this frame level is already claimed in some fashion
		 */
		MemCheck_UnRegisterMiscBlock (r);
		return(INETERR_FILTERGONE);
	}

	if( (fs = (FilterSingleRef)malloc(sizeof(*fs))) == NULL )
	{
	    /*
	     * cannot claim memory for this structure
	     */
	    MemCheck_UnRegisterMiscBlock (r);
	    return(ENOMEM);
	}

	/*
	 * check that we can bring the card up live
	 */
	/*if( (error = enioctl(unit, 1, 1)) != 0 )
	{
	    (void)free(fs);
	    return(error);
	}*/

	/*
	 * everything checks out OK, initialise the structure
	 */
	ppp_softc[unit].inetfilter = fs;
	fs->fs_errlevel = r->r[4];
	fs->fs_handler = (void (*)())r->r[6];
	fs->fs_pwptr = r->r[5];

	/*
	 * set receive level for this unit to the
	 * loosest address filtering necessary.
	 */
	update_addrlevel(unit);
    }

    /* all OK */
    MemCheck_UnRegisterMiscBlock (r);
    return(0);
}

/**********************************************************************/

/*
 * stats_init - initialise stats structures
 */
static void stats_init(void)
{
    int unit;

    for (unit=0; unit<NPPP; unit++)
    {
        /*
         * actual statistics structure is easy - only one field to set
         */
        memset(&ppp_softc[unit].st, 0, sizeof(struct stats));
        ppp_softc[unit].st.st_interface_type = ST_TYPE_SERIAL;
        ppp_softc[unit].st.st_link_status=ST_STATUS_OK | ST_STATUS_DIRECT;
        ppp_softc[unit].st.st_link_polarity=1;
    }

    /*
     * now fill in struct st which describes
     * the stats. this interface supports.
     */
    memset(&st, 0, sizeof st);
    st.st_interface_type = (char)~0;
    st.st_link_status = ~0;
    st.st_tx_frames = ~0;
    st.st_tx_bytes = ~0;
    st.st_tx_general_errors = ~0;
    st.st_crc_failures = ~0;
    st.st_runt_frames = ~0;
    st.st_overlong_frames = ~0;
    st.st_unwanted_frames = ~0;
    st.st_rx_frames = ~0;
    st.st_rx_bytes = ~0;
    st.st_rx_general_errors = ~0;
}

/**********************************************************************/

static int ppp_filter(_kernel_swi_regs *r)
{
    int flags;
    int unit;
    int frametype;
    int addrlevel;
    int errlevel;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    flags     = r->r[0];
    unit      = r->r[1];
    frametype = r->r[2];
    addrlevel = r->r[3];
    errlevel  = r->r[4];

    pdebug ((LOG_DEBUG,
             "PPP_Filter: flags=%d unit=%d frametype=%d addrlevel=%d errlevel=%d\n",
             flags, unit, frametype, addrlevel, errlevel));

    /*
     * range checking
     */
    if( flags >= FILTER_1STRESERVED ||
        unit >= NPPP ||
       !check_addrlevel(addrlevel) ||
       !check_errlevel(errlevel) )
    {
	MemCheck_UnRegisterMiscBlock (r);
	return(EINVAL);
    }

    /*
     * now check type and level
     */
    if( (GET_FRAMELEVEL(frametype)) != FRMLVL_E2SPECIFIC ||
        (GET_FRAMETYPE(frametype)) != ETHERTYPE_IP )
    {
	MemCheck_UnRegisterMiscBlock (r);
	return(EINVAL);
    }

    /* that's all */
    MemCheck_UnRegisterMiscBlock (r);
    return(do_singlefilter(r));
}

/**********************************************************************/

static int ppp_version(_kernel_swi_regs *r)
{
    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));
    if( r->r[0] )
    {
	MemCheck_UnRegisterMiscBlock (r);
	return(EINVAL);
    }

    r->r[1] = DCIVERSION;
    MemCheck_UnRegisterMiscBlock (r);
    return (0);
}

/**********************************************************************/

static int ppp_inquire(_kernel_swi_regs *r)
{
    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));
    if( r->r[0] )
    {
	MemCheck_UnRegisterMiscBlock (r);
	return(EINVAL);
    }

    r->r[2] = ppp_softc[r->r[1]].dib.dib_inquire;

    MemCheck_UnRegisterMiscBlock (r);
    return(0);
}

/**********************************************************************/

static int ppp_getmtu(_kernel_swi_regs *r)
{
    int flags;
    int unit;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    flags = r->r[0];
    unit  = r->r[1];

    if (flags || unit < 0 || unit >= NPPP)
    {
	MemCheck_UnRegisterMiscBlock (r);
	return EINVAL;
    }

    r->r[2] = ppp_softc[unit].sc_mtu;

    MemCheck_UnRegisterMiscBlock (r);
    return 0;
}

/**********************************************************************/

static int ppp_setmtu(_kernel_swi_regs *r)
{
    int flags;
    int unit;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    flags = r->r[0];
    unit  = r->r[1];

    if (flags || unit < 0 || unit >= NPPP)
    {
	MemCheck_UnRegisterMiscBlock (r);
	return EINVAL;
    }

    ppp_softc[unit].sc_mtu=r->r[2];

    MemCheck_UnRegisterMiscBlock (r);
    return 0;
}

/**********************************************************************/


/* XXXX TRACE XXXX */
#if 1
static int copied, ensured;
int rxerrors;
#endif

static int ppp_transmit(_kernel_swi_regs *r)
{
    const static struct sockaddr dst={AF_INET}; /* Bodge! */
    unsigned flags;
    int unit;
    unsigned type;
    struct mbuf *m0, *md, *md1, *m1, **m2, *temp;
    int error=0;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    flags = r->r[0];
    unit  = r->r[1];
    type  = r->r[2];
    m0    = (struct mbuf *) r->r[3];

#ifdef DEBUG
    {
        int packet_len, packet_count;
        struct mbuf *  debug_m0;
        struct mbuf *  debug_m1;

        for (debug_m0 = (struct mbuf *)r->r[3], packet_count = 1;
             debug_m0;
             debug_m0 = debug_m0->m_list, packet_count++)
        {
            for (debug_m1 = debug_m0, packet_len = 0;
                 debug_m1;
                 debug_m1 = debug_m1->m_next)
            {
                packet_len += debug_m1->m_len;
            }

            syslog (LOG_DEBUG, "Packet %d length: %d", packet_count, packet_len);
        }
    }
#endif


    if ((flags &~ TX_PROTOSDATA) || type != ETHERTYPE_IP ||
        unit > NPPP || unit < 0)
        error=EINVAL;

    if (error)
    {
        if (!(flags & TX_PROTOSDATA))
            freelist(m0);

	MemCheck_UnRegisterMiscBlock (r);
        return error;
    }
#if 0
    for (m1=m0; m1; m1=m1->m_list)
        passed_into_transmit++;
#endif

    if (flags & TX_PROTOSDATA)
    {
        pdebug((LOG_DEBUG, "Copying data"));
        copied++;
        /*
         * the protocol module is hanging on to the data, so we
         * need to make a copy
         */

        md=MBCTL.copy(&MBCTL, m0, 0, M_COPYALL);

        if (md)
        {
            for (md1=md, m1=m0; md1 && m1->m_list; md1=md1->m_list, m1=m1->m_list)
            {
                md1->m_type=0;
                md1->m_list=MBCTL.copy(&MBCTL, m1->m_list, 0, M_COPYALL);
            }

            if (m1->m_list)
            {
               /* md1->m_list must =0, ie copy failed */
               freelist(md);        /* free our partial copied list */
               syslog (LOG_INFO, "ENOBUFS");
               error=ENOBUFS;
            }
        }
        else
        {
            error=ENOBUFS;
            syslog (LOG_INFO, "ENOBUFS");
        }
    }
    else
    {
        pdebug ((LOG_DEBUG, "Ensuring data"));
        ensured++;
        /*
         * the protocol module is giving us the data, but we
         * must ensure it's safe
         */

        m2=&m0;
        md1=m0;

        while (md1)
        {
            temp=md1->m_list;
            md1=*m2=MBCTL.ensure_safe(&MBCTL, md1);
            if (!md1)
            {
                freelist(m0);
                freelist(temp);
                error=ENOBUFS;
                syslog (LOG_INFO, "ENOBUFS");
                break;
            }
            md1->m_list=temp;
            m2=&md1->m_list;
            md1=md1->m_list;
        }
        md=m0;
    }

    if (error)
        ppp_softc[unit].st.st_tx_general_errors++;
    else
        error=pppoutput(&ppp_softc[unit].dib, md, &dst);

    MemCheck_UnRegisterMiscBlock (r);
    return error;
}

/**********************************************************************/

static int ppp_stats(_kernel_swi_regs *r)
{
    unsigned flags;
    int unit;
    struct stats *output;
    const struct stats *ps;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    flags  = r->r[0];
    unit   = r->r[1];
    output = (struct stats *) r->r[2];

    switch (flags)
    {
        case 0:
            ps=&st;
            break;

        case 1:
            ps=&ppp_softc[unit].st;
            break;

        default:
            MemCheck_UnRegisterMiscBlock (r);
            return EINVAL;
    }

    memcpy(output, ps, sizeof(struct stats));

    MemCheck_UnRegisterMiscBlock (r);
    return 0;
}

/**********************************************************************/

static _kernel_oserror *ppp_alter_settings (_kernel_swi_regs *r)
{
    unsigned int reason_code;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    reason_code = r->r[0];

    switch (reason_code)
    {
        case PPP_AlterSettings_Timeout:
        {
            int new_idle_time_limit = r->r[2];


            if (new_idle_time_limit < 0)
            {
                _ppp_errblk.errnum = 0;
                strcpy (_ppp_errblk.errmess, "PPP: bad idle time limit");
                MemCheck_UnRegisterMiscBlock (r);
                return (&_ppp_errblk);
            }

            else
            {
                int interrupt_status;


                /* atomic update of idle time limit */
                interrupt_status = splhi ();
                idle_time_limit = new_idle_time_limit;
                restore_irqs (interrupt_status);
            }
            break;
        }

        default:
            _ppp_errblk.errnum = 0;
            strcpy (_ppp_errblk.errmess, "PPP: bad reason code");
            MemCheck_UnRegisterMiscBlock (r);
            return (&_ppp_errblk);
            break;
    }

    MemCheck_UnRegisterMiscBlock (r);
    return NULL;
}

/**********************************************************************/

static _kernel_oserror *ppp_status (_kernel_swi_regs *r)
{
    unsigned int reason_code;
    int interrupt_status;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    reason_code = r->r[0];

    switch (reason_code)
    {
        case PPP_Status_Timeout:
            r->r[2] = default_idle_time_limit;

            /* atomic read of idle time limit */
            interrupt_status = splhi ();
            r->r[3] = idle_time_limit;
            restore_irqs (interrupt_status);
            break;

        case PPP_Status_Connection:
            if (modem)
            {
                r->r[2] = serial_dcd ();
            }

            /* atomic read of ppp phase */
            interrupt_status = splhi ();
            r->r[3] = phase;
            restore_irqs (interrupt_status);
            break;

        default:
            _ppp_errblk.errnum = 0;
            strcpy (_ppp_errblk.errmess, "PPP: bad reason code");
            MemCheck_UnRegisterMiscBlock (r);
            return (&_ppp_errblk);
            break;
    }

    MemCheck_UnRegisterMiscBlock (r);
    return NULL;
}

/**********************************************************************/

static void callback(void (*f)(void), void *pw)
{
    _swix(OS_AddCallBack, _INR(0,1), f, pw);
}

/**********************************************************************/

/*
 * send_driverstatus - send a DCIDriverStatus service
 * call for given dib
 */
static void send_driverstatus(DibRef dib, int status)
{
    _swix(OS_ServiceCall, _INR(0,3), dib, Service_DCIDriverStatus,
                                     status, DCIVERSION);
}

/**********************************************************************/

/*
 * callb_handler - handler for callback primed by initialisation
 * routine: send round DCIDriverStatus service call for all units
 */
_kernel_oserror *callb_handler(_kernel_swi_regs *r, void *pw)
{
    int i;


    for( i = 0; i < pppcnt; ++i )
        send_driverstatus(&ppp_softc[i].dib, 0);

    return NULL;

    NOT_USED (r);
    NOT_USED (pw);
}

/**********************************************************************/

#if defined Trace_TRACE && defined DEBUG

static void trace_enter (const char *fn)
{
    int i;

    Debug_Routine ("PPP");
    for (i = 0; i < trace_depth; i++)
        Debug_Routine (" |");

    Debug_Routine (" %s\n", fn);

    ++trace_depth;
}

static void trace_exit (const char *fn)
{
    int i;

    if (--trace_depth < 1)
        trace_depth = 1;

    for (i = 0; i < trace_depth; i++)
        Debug_Routine (" |");

    Debug_Routine ("~%s\n", fn);
}

#endif




#ifdef MemCheck_MEMCHECK

static char    memcheck_buffer[1024 * 100];
static char *  memcheck_ptr = memcheck_buffer;
static FILE *  memcheck_out = 0;

static int  memcheck_vprintf (void *        reference,
                              const char *  format,
                              va_list       args)
{
    int          n = 0;

    if (memcheck_ptr < (memcheck_buffer + sizeof (memcheck_buffer)))
    {
        n = vsprintf (memcheck_ptr,
                      format,
                      args);
        if (n > 0)
        {
            memcheck_ptr += n;
        }
    }
    else
    {
        n = 0;
    }

    return n;
}

_kernel_oserror *  memcheck_output (_kernel_swi_regs *  r,
                                    void *              pw)
{
    r = r;
    pw = pw;

    memcheck_out = fopen ("$.PPPMemCheck",
                          "a+");
    if (memcheck_out)
    {
        fwrite (memcheck_buffer,
                1,
                memcheck_ptr - memcheck_buffer,
                memcheck_out);

        fclose (memcheck_out);
        memcheck_ptr = memcheck_buffer;
    }

    return NULL;
}

_kernel_oserror *  memcheck_callevery (_kernel_swi_regs *  r,
                                       void *              pw)
{
    r = r;
    pw = pw;

    _swix (OS_AddCallBack,
           _INR (0, 1),
           memcheck_output_entry,
           pw);

    return NULL;
}

#endif



/*
 * Module Initialisation code.
 */
#if CMHG_VERSION < 516
_kernel_oserror *ppp_initialise(char *cmd_tail, int pbase, void *pw)
#else
_kernel_oserror *ppp_initialise(const char *cmd_tail, int pbase, void *pw)
#endif
{
    _kernel_oserror *e;
    int unit;
    DibRef dib;

    module_wsp = pw;

#   ifdef TINYSTUBS
    managerstarted=0;
    finalising=0;
#   endif


    MemCheck_Init ();
    MemCheck_RedirectToFunction (memcheck_vprintf, 0);
    MemCheck_SetStoreMallocFunctions (1);
    MemCheck_InterceptSCLStringFunctions();
    MemCheck_SetQuitting (0, 0);
    MemCheck_SetAccessQuitting (0, 0);
    /* Don't output blocks on every diagnostic.  Alot of diagnostics are produced
     * because of MemCheck faulting accesses to externally supplied mbuf data structures.
     * There are too many instances of these to make it feasible to register them all as
     * misc blocks.
     */
    MemCheck_SetAutoOutputBlocksInfo (0);

#ifdef MemCheck_MEMCHECK
    _swix (OS_CallEvery,
           _INR (0, 2),
           99,
           memcheck_callevery_entry,
           pw);
#endif

    /*if( (error = ppp_init()) != 0 )
	return(ppp_error(error));*/

    if( pppcnt == 0 )
	return(NULL);

    /*
     * Initialize Driver Information Blocks
     */
    for( unit = 0; unit < pppcnt; unit++ )
    {
	dib = &ppp_softc[unit].dib;

	dib->dib_swibase = PPP_00;
	dib->dib_name = (unsigned char *)"ppp";
	dib->dib_unit = unit;
	dib->dib_address = (unsigned char *)"\0\0\0\0\0";
	dib->dib_module = (unsigned char *)"PPP";
        dib->dib_location=(unsigned char *)"Serial port";
	dib->dib_inquire = INQ_POINTOPOINT | INQ_HASSTATS;
        dib->dib_slot.sl_slotid=ST_TYPE_SERIAL;
        dib->dib_slot.sl_minor=0;
        dib->dib_slot.sl_pcmciaslot=0;
        dib->dib_slot.sl_mbz=0;
    }

    stats_init();

    _swix(OS_SetVarVal, _INR(0,4), "Inet$EtherType", "ppp0", 4, 0, 4);

    setlogmask(LOG_UPTO(LOG_DEBUG));


    /*
     * check whether the mbuf manager module is loaded yet
     */
    if( !managerstarted && mb_present() )
    {
	/*
	 * mbuf manager is loaded - initialise entry points
	 */
	if( (e = mb_entryinit()) != NULL )
	    return(e);

	/*
	 * OK - set a callback to issue Service_DCIDriverStatus
	 */
	callback(callb_entry, pw);

	managerstarted = 1;
    }

  #ifdef Trace_TRACE
    Trace_SetVerboseLevel (5);
    Trace_IgnoreFunctions (
        "Printf syslog pppd* PDebug* trace* hup* upcall_handler pppinput pppioctl "
        "putblock ppp_dequeue message_* pr_log");
#if 0
    Trace_IgnoreFunctions (
        "Printf syslog PDebug* trace* pppinput putblock");
#endif
    Trace_SetHandlers (trace_enter, trace_exit);
    Trace_InterceptAllFunctions ();
  #endif

  #if 0
    _kernel_irqs_off ();
    _swix (OS_ClaimProcessorVector, _INR (0, 1) | _OUT (1),
           0x106, intercept, &original_int_handler);
    {
        unsigned int *zpp=(unsigned int *) 0xf4;
        *zpp=original_int_handler;
    }
    _kernel_irqs_on ();
  #endif
    return(NULL);

    NOT_USED(pbase);
    NOT_USED(cmd_tail);
}

/**********************************************************************/

/*
 * Module Finalization code
 */
_kernel_oserror *ppp_quit(int fatal, int podule, void *pw)
{
    int i;


  #if 0
    _swix (OS_ClaimProcessorVector, _INR (0, 2),
           0x6, original_int_handler, intercept);
  #endif

    finalising = 1;

    pppd_signal_handler(SIGHUP);

    for( i = 0; i < pppcnt; ++i )
        send_driverstatus(&ppp_softc[i].dib, 1);


    /*ppp_final();*/

    /*
     * finish session with mbuf manager, ignore any
     * errors (they don't mean much, since session
     * *may* still be closed, despite any errors
     * returned)
     */
    mb_closesession();

    /* Paranoia */
    serial_finalise();

#ifdef MemCheck_MEMCHECK

    _swix (OS_RemoveTickerEvent,
           _INR (0, 1),
           memcheck_callevery_entry,
           pw);

    _swix (OS_RemoveCallBack,
           _INR (0, 1),
           memcheck_output,
           pw);

    MemCheck_OutputBlocksInfo ();
    memcheck_output (NULL, NULL);

#endif

    return NULL;

    NOT_USED (fatal);
    NOT_USED (podule);
    NOT_USED (pw);
}

/**********************************************************************/

/*
 * handle_managerstatus - deal with a MbufManagerStatus service call
 */
static void handle_managerstatus(_kernel_swi_regs *r)
{
    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));
    switch( r->r[0] )
    {
      case MbufManagerStatus_Started:
	if( !managerstarted )
	{
	    /*
	     * mbuf manager has appeared - initialise entry points
	     */
	    if( mb_entryinit() == NULL )
	    {
		/*
		 * mbuf system initialised, set a callback
		 * to announce our presence
		 */
		managerstarted = 1;
		callback(callb_entry, module_wsp);
	    }
	}

	break;

      case MbufManagerStatus_Stopping:
	/*
	 * should only ever see this message if we are
	 * finalising our own module, otherwise something
	 * has gone terribly wrong (the mbuf manager should
	 * only stop when all its clients have closed their
	 * sessions)
	 */
	if( !finalising )
	    printf("ppp panic: Mbuf manager has stopped\n");

	break;

      case MbufManagerStatus_Scavenge:
	/* do nothing */
	break;

      default:
	break;
    }
    MemCheck_UnRegisterMiscBlock (r);
}

/**********************************************************************/

/* Module Service Call handler */
void ppp_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    NOT_USED (pw);

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    if ((dialler_flags & DiallerFlags_UsingDialler) &&
        (sn == Service_DiallerStatus || sn == Service_DiallerBStatus))
    {
        if ( ( (dialler_flags & DiallerFlags_DiallerB) &&
                   sn == Service_DiallerBStatus) ||
             ( (dialler_flags & DiallerFlags_DiallerB) == 0 &&
                   sn == Service_DiallerStatus))
        {
/*         syslog (LOG_INFO, "Service_DiallerStatus: %x", r->r[0]); */

            if (r->r[0] & Dialler_RelinquishAccess)
            {
                pppd_signal_handler (SIGHUP);
            }
        }
    }

    /*
     * ignore nearly all calls until the
     * mbuf manager has been initialised
     */
    else if( !managerstarted )
    {
	if( sn == Service_MbufManagerStatus)
	    /* best not to ignore this one */
	    handle_managerstatus(r);
    }

    else
    {
	int i;

	switch( sn )
	{
	  case Service_EnumerateNetworkDrivers:
	    for( i = 0; i < pppcnt; ++i )
	    {
		ChDibRef chd;

		if( (chd = (ChDibRef)malloc(sizeof(*chd))) == NULL )
		    /*
		     * failed to claim memory - return as
		     * much information as possible
		     */
		    break;

		chd->chd_dib = &ppp_softc[i].dib;
		chd->chd_next = (ChDibRef)r->r[0];
		r->r[0] = (int)chd;
	    }

	    break;

	  case Service_DCIProtocolStatus:
	    if( r->r[3] == DCIVERSION )
	    {
		pdebug ((LOG_DEBUG, "\021\02ppp: Protocol '%s' is %sing\021\07\n",
		               r->r[4], r->r[2] ? "dy" : "start"));
		/*
		 * only interested in termination calls
		 */
		if( r->r[2] == 1 )
		    filtersoff(r->r[0]);
	    }

	    break;

	  default:
	    break;
	}
    }
    MemCheck_UnRegisterMiscBlock (r);
}

/**********************************************************************/

/*
 * Module SWI handler
 */
_kernel_oserror *ppp_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;
    int error, oldstate;

    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));
    NOT_USED(pw);

    /*
     * XXX
     *
     * we *assume* that, since service calls are not active
     * until the mbuf manager has been started, nobody can
     * find out our swibase, and therefore cannot raise any
     * SWIS.  if this is not true (i.e. someone looks up our
     * particular SWI number, then they deserve all the trouble
     * which they are probably likely to receive.
     */

    /*
     * check that a correct unit number has been
     * given for all SWIs other than Version
     */
    if( swinum != DCI4Version && r->r[1] >= pppcnt  )
    {
        MemCheck_UnRegisterMiscBlock (r);
        return(ppp_error(ENXIO));
    }

    pdebug ((LOG_DEBUG, "\021\06SWI %x...", swinum & 63));

    if( swinum >= (sizeof(ppp_ent) / sizeof(ppp_ent[0])) )
    {
        _kernel_oserror *e = NULL;


        /* SWI is not a DCI4 related one: these SWIs return _kernel_oserror* rather
         * than an integer error number.
         */
        switch (swinum)
        {
            case PPP_AlterSettings - PPP_00:
                e = ppp_alter_settings (r);
                break;

            case PPP_Status - PPP_00:
                e = ppp_status (r);
                break;

            default:
                MemCheck_UnRegisterMiscBlock (r);
                return error_BAD_SWI;
        }

        MemCheck_UnRegisterMiscBlock (r);
        return e;
    }

    callp = &ppp_ent[swinum];
    oldstate = ensure_irqs_on();
    error = (*(callp->swi_call))(r);
    restore_irqs(oldstate);

    pdebug ((LOG_DEBUG, "error %d\021\07\n", error));

    MemCheck_UnRegisterMiscBlock (r);
    return(ppp_error(error));
}

/**********************************************************************/

/*
 * printstat - just print a statistic line, aligned
 */
static void printstat(const char *s, unsigned long n)
{
    char temp[40];

    if (n)
        sprintf(temp, "%-20s: %lu\r\n", s, n);
    else
        sprintf(temp, "%-20s:\r\n", s);

    _swix(OS_Write0, _IN(0), temp);
}

/*
 * prpppstats - print our statistics
 */
static int prpppstats(void)
{
    int unit;
    DibRef dib;
    struct stats *stats;
    extern volatile int idle_time;

    for (unit=0; unit < NPPP; unit++)
    {
        printf("ppp%d: Serial port, %s.\n\n", unit,
                (ppp_softc[unit].moreflags & IFF_RUNNING)?"up":"down");

        dib=&ppp_softc[unit].dib;
        stats=&ppp_softc[unit].st;

	printf("Interface driver    : %s\n", dib->dib_name);
	printf("Interface unit      : %u\n", dib->dib_unit);
	printf("Interface location  : %s\n", dib->dib_location);
#ifdef BLOCKDRIVERS
	printf("Block driver        : %s\n", (char *)(driver_block+32));
	printf("Port number         : %d\n", portnumber);
	printf("Serial speed        : %d bps\n", driver_txspeed(-1));
#else
        printf("Serial device       : %s\n", devname);

        if (serial_in == 0)
        {
            printf("Serial speed        : N/A\n");
        }

        else
        {
            ioctl_t ioctl;

            ioctl.reason = IOCtl_baud_rate;
            ioctl.group = 0;
            ioctl.reserved = 0;
            ioctl.read = 1;
            ioctl.write = 0;

            _swix (OS_Args, _INR (0, 2), OS_Args_IOCtl, serial_in, &ioctl);

            printf("Serial speed        : %d bps\n", ioctl.data);
        }
#endif

	printstat("MRU", ppp_softc[unit].sc_mru);
	printstat("MTU", ppp_softc[unit].sc_mtu);
	printstat("Packets in fastq", ppp_softc[unit].sc_fastq.ifq_len);
	printstat("Packets in outq", ppp_softc[unit].sc_outq.ifq_len);
	printf("Idle time           : %d s\n", idle_time);
	printstat("Packets sent", stats->st_tx_frames);
	printstat("Packets received", stats->st_rx_frames);
	printstat("Bytes sent", stats->st_tx_bytes);
	printstat("Bytes received", stats->st_rx_bytes);
	printstat("Send errors", stats->st_tx_general_errors);
	printstat("Receive errors", stats->st_rx_general_errors);
	printstat("CRC Failures", stats->st_crc_failures);
	printstat("Receives too small", stats->st_runt_frames);
	printstat("Receives too large", stats->st_overlong_frames);
	printstat("Unwanted frames", stats->st_unwanted_frames);
#if 0
	printstat("Copied frames", copied);
	printstat("Ensured frames", ensured);
	printstat("RX errors", rxerrors);
        printstat("Chains passed to Transmit", passed_into_transmit);
        printstat("PPP headers added", ppp_headers_added_in_pppoutput);
        printstat("Packets queued", queued_in_pppoutput);
#endif

        if (ppp_softc[unit].inetfilter)
        {
    	    FilterSingleRef fs = ppp_softc[unit].inetfilter;

   	    printf("\nStandard clients:\n\n");

    	    printf("Frame = %.4x, ErrLvl=%.2x, AddrLvl=01, Handler=%p,%x\n",
    	            ETHERTYPE_IP, fs->fs_errlevel, fs->fs_handler, fs->fs_pwptr);
        }
    }

    /*if( ppp_lastlog[0] )
    {
	printf("\n%-18s%s\n", "Driver Info", ppp_lastlog);
	ppp_lastlog[0] = '\0';
    }

    if( ppp_lasterr[0] )
    {
	printf("%-18s%s\n", "Driver Error", ppp_lasterr);
	ppp_lasterr[0] = '\0';
    }*/

    return 1;
}

/**********************************************************************/

static _kernel_oserror *do_startppp(int argc, char **argv)
{
    return pppd_main(argc, argv);
}

/**********************************************************************/

static _kernel_oserror *do_stopppp(int argc, char **argv)
{
    pppd_signal_handler(SIGTERM);

    return 0;

    NOT_USED(argc);
    NOT_USED(argv);
}

/**********************************************************************/

static _kernel_oserror *do_pppinfo(int argc, char **argv)
{
    printf("%-18s", "DCI Version");
    printf("%d.%02d\n\n", DCIVERSION / 100, DCIVERSION % 100);

    prpppstats();

    return(NULL);

    NOT_USED(argc);
    NOT_USED(argv);
}



/**********************************************************************/

static _kernel_oserror *do_ppplog(int argc, char **argv)
{
    printlog();

    return NULL;

    NOT_USED(argc);
    NOT_USED(argv);
}

/* -----------------------------------------------------------------------------
+
   str_dup

   Duplicate a string and return a pointer to it.  Client is responsible for
   freeing memory.

   Inputs
   s: pointer to string to duplicate

   Returns
   success: pointer to duplicated string
   failure: NULL
-
 */

static char *str_ctrl_dup (const char *const s)
{
    size_t len = 0;    /* at least one char for terminator */
    const char *c = s;
    char *p;

    while (!iscntrl (*c))
    {
        ++c;
        ++len;
    }

    p = malloc (len + 1);
    if (p)
    {
        memcpy (p, s, len);
        p[len] = '\0';
    }

    return (p);
}

/**********************************************************************/

#if CMHG_VERSION < 516
_kernel_oserror *ppp_cli_handler(char *arg_string, int arg_count,
                                 int cmd_no, void *pw)
#else
_kernel_oserror *ppp_cli_handler(const char *arg_string, int arg_count,
                                 int cmd_no, void *pw)
#endif
{
    struct client *callp;
    int margc;
    char *margv[20];
    char *cp;
    char **argp = margv;
    char *w_arg_string;
    _kernel_oserror *e;


    MemCheck_RegisterMiscBlock_String (arg_string);

    if( cmd_no >= sizeof(ppp_cli_call) / sizeof(ppp_cli_call[0]) )
    {
        _ppp_errblk.errnum = 42;
        sprintf(_ppp_errblk.errmess, "PPP: bad command number: %d\n",
                cmd_no);
        MemCheck_UnRegisterMiscBlock (arg_string);
        return &_ppp_errblk;
    }

    /*
     * YEURGH!
     *
     * This time it is RISC OS and cmhg conspiring to necessitate
     * more grungy code: if the arg_count is "too large", assume
     * that this is a help request, rather than a *-command, in
     * which case arg_string is a text buffer, and arg_count is
     * the buffer length, and breaking the string up is a bad idea.
     * The "too large" level is set at 128, on the assumption that
     * the max. length of a command line is 256 bytes which gives a
     * (theoritical) maximum of 128 arguments
     */

    if( arg_count < 128 )
    {
        w_arg_string = str_ctrl_dup (arg_string);
        if (w_arg_string == NULL)
        {
            _ppp_errblk.errnum = 0;
            strcpy (_ppp_errblk.errmess,
                    "PPP: not enough memory to make copy of argument string\n");
            MemCheck_UnRegisterMiscBlock (arg_string);
            return &_ppp_errblk;
        }

        if( arg_count > 20 )
            /* limit set by size of margv array */
            arg_count = 20;

        margc = 0;
        cp = w_arg_string;
        while (*cp && arg_count-- > 0)
        {
            while (*cp == ' ' || *cp == '\t')
                cp++;

            if (*cp < ' ')
            {
                *cp = '\0';
                break;
            }

            *argp++ = cp;
            margc++;
            while (*cp >= ' ' && *cp != ' ' && *cp != '\t')
                cp++;

            if (*cp < ' ')
            {
                *cp = '\0';
                break;
            }

            *cp++ = '\0';
        }

        *argp++ = 0;
    }
    else
    {
        /* its a help request */

        /* This is very, very, very yucky. But it has to work on 3.10, and
           CMHG won't co-operate */
        switch (cmd_no)
        {
          char *help_string = (char *) arg_string;
          case CMD_PPPLog:
            sprintf(help_string, "*PPPLog prints the entries stored in the PPP driver's "
                                "log. "
                                "This allows you to see the negotiation between the two "
                                "ends of the PPP link. This command is not useful to the "
                                "average user.\r"
                                "Syntax: *PPPLog");
            break;

          case CMD_PPPConnect:
            _swix(OS_PrettyPrint, _INR(0,1),
                         "*PPPConnect initiates a PPP link. Default options are "
                         "looked up in InetDbase:PPP.options. Further options "
                         "can be entered at the command line. These include:\r\r", 0);
            _swix(OS_Write0, _IN(0), usage_string);
            _swix(OS_PrettyPrint, _INR(0,1),
                         "\rSyntax: *PPPConnect [arguments]", 0);
            MemCheck_UnRegisterMiscBlock (arg_string);
            return NULL;

          case CMD_PPPDisconnect:
            sprintf(help_string, "*PPPDisconnect closes down a PPP link.\r"
                                "Syntax: *PPPDisconnect");
            break;

          case CMD_PPPInfo:
            sprintf(help_string, "*PPPInfo displays PPP driver statistics.\r"
                                "Syntax: *PPPInfo");
            break;

          default:
            MemCheck_UnRegisterMiscBlock (arg_string);
            return NULL;
        }

        MemCheck_UnRegisterMiscBlock (arg_string);
        return help_PRINT_BUFFER;
    }

    callp = &ppp_cli_call[cmd_no];
    e = callp->cli_call(margc, margv);
    free (w_arg_string);
    MemCheck_UnRegisterMiscBlock (arg_string);
    return e;

    NOT_USED(pw);
}

/**********************************************************************/

/* EOF pppmodule.c */
