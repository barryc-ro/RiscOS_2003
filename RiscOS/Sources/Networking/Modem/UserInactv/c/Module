/************************************************************************/
/* File:    Module.c                                                    */
/* Purpose: RISC OS module related code.                                */
/*                                                                      */
/* Author:  David Cotton <mailto:david.cotton@pacemicro.com             */
/* History: 0.01  2000-01-07                                            */
/*                Initial version.                                      */
/************************************************************************/

/* ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

/* Risc OS Includes */
#include "kernel.h"
#include "swis.h"
#include "NVRAM.h"
#include "Global/RISCOS.h"

/* Other libraries */
#include "Debuglib/Debuglib.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

/* Local Includes */
#include "Module.h"
#include "Header.h"



/* Module housekeeping globals */
static void *module_wsp = NULL;
static int  inactivity_period = 0; /* Default is off */
#ifndef IGNORE_POINTER_MOVEMENTS
static char mouse_status[5];
#endif /* IGNORE_POINTER_MOVEMENTS */
static bool module_active = false;

/* Forward prototypes */
static _kernel_oserror *setcallafter(unsigned int seconds);
static _kernel_oserror *setcallback(void);
static _kernel_oserror *removecallback(void);
static void module_releasev(void);
static _kernel_oserror *module_claimv(void);
static _kernel_oserror *module_event_disable(void);
static _kernel_oserror *module_event_enable(void);
static int get_nvram_tag_numeric(char* tag);
char* get_nvram_tag_string(char* tag);

/* Define anything else that we need */
#ifndef NCDial_Hangup
  #define NCDial_Hangup      0x4EC01
#endif
#define Event_Enable         14
#define Event_Disable        13




/*********************************************************************************/
/* module_initialise                                                             */
/*                                                                               */
/* Module initialisation entry point.                                            */
/*                                                                               */
/* Parameters:  const char* cmd_tail                                             */
/*              int         podule_base                                          */
/*              void*       pw                                                   */
/*                                                                               */
/* Returns:     _kernel_oserror*                                                 */
/*                                                                               */
/*********************************************************************************/
_kernel_oserror *module_initialise (const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs r;
  int nvram_tag_contents = 0;

  NOT_USED(cmd_tail);
  NOT_USED(podule_base);
  NOT_USED(r);

  module_wsp = pw;

#ifdef MemCheck_MEMCHECK
  MemCheck_Init();
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_RedirectToFilename ("izipfs:$.in_memch");
  atexit (MemCheck_OutputBlocksInfo);
  MemCheck_SetReadChecking (0);
#endif

  debug_initialise (Module_Title, "izipfs:$.inactivout", "");
  debug_output_device (PDEBUG_OUTPUT);
  debug_set_stamp_debug(TRUE);
  debug_atexit ();

  /* Set a CallEvery for every 20 centiseconds. */
  r.r[0] = (int) 19; /* Call takes the value in centiseconds -1, hence 19 */
  r.r[1] = (int) ticker_event_veneer;
  r.r[2] = (int) module_wsp;
  err = _kernel_swi(OS_CallEvery, &r, &r);

  /* Read the contents of the NVRAM tag. */
  nvram_tag_contents = get_nvram_tag_numeric("InactivityTimeout");
  if (nvram_tag_contents >= 0) /* Tag exists */
  {
    int new_period = nvram_tag_contents;
    dprintf(("", "module_initialise(): New period requested is %d.\n", new_period));
    if (new_period == 0)
    {
      module_active = false;
    }
    if (new_period != 0 && (new_period < 60 || new_period > 3600))
    {
      printf ("The period can only be 0 seconds or between 60 and 3600 seconds.\n");
    }
    else
    {
      module_active = true;
      inactivity_period = new_period;
    }
  }
  else
  {
    dprintf(("", "module_initialise(): NVRAM tag InactivityTimeout is unset.\n"));
    module_active = false;
    inactivity_period = 0;
  }

  /* Set the initial callafter */
  setcallafter(inactivity_period);

  /* Claim the required events */
  err = module_claimv();
  err = module_event_enable();

  dprintf(("", "module_initialise(): Finished.\n"));

  return (err);
}





/*********************************************************************************/
/* module_finalise                                                               */
/*                                                                               */
/* Module exit handler                                                           */
/*                                                                               */
/* Parameters:  int         fatal                                                */
/*              int         podule                                               */
/*              void*       pw                                                   */
/*                                                                               */
/* Returns:     _kernel_oserror*                                                 */
/*                                                                               */
/*********************************************************************************/
_kernel_oserror *module_finalise (int fatal, int podule, void *pw)
{
  _kernel_oserror *err = NULL;

  NOT_USED(fatal);
  NOT_USED(podule);
  NOT_USED(pw);

  /* Cancel any registered callafters */
  _swix(OS_RemoveTickerEvent, _INR(0, 1), module_callafter_entry, module_wsp);      /* ...then remove the event... */
  _swix(OS_RemoveTickerEvent, _INR(0,1), (void *)(int)ticker_event_veneer, module_wsp);

  /* Remove any outstanding callbacks */
  removecallback();

  /* Release the events... */
  module_event_disable();
  module_releasev();

  return  (err);
}




/*********************************************************************************/
/* module_cmd_handler                                                            */
/*                                                                               */
/* Module command handler                                                        */
/*                                                                               */
/* Parameters:  const char* arg_string                                           */
/*              int         argc                                                 */
/*              int         cmd_no                                               */
/*              void*       pw                                                   */
/*                                                                               */
/* Returns:     _kernel_oserror*                                                 */
/*                                                                               */
/*********************************************************************************/
_kernel_oserror *module_cmd_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{
  int new_period;
  dprintf (("", "module_cmd_handler()\n"));

  NOT_USED(pw);

  switch (cmd_no)
  {
    /* The * command below deals with attempts to alter the period of user inactivity needed before the line drops. */
    case CMD_UserInactivity_Period:
      if (argc == 0) /* No arguments passed in - just display the current setting. */
      {
        printf("The period before the line is dropped is %d seconds.\n", inactivity_period);
      }
      if (argc > 1)
      {
        printf("You cannot pass more than one parameter into The UserInactivity module.\n");
      }
      if (argc == 1)
      {
        dprintf(("module_cmd_handler(): Parameter passed in is %s\n", arg_string));
        new_period=atoi(arg_string);
        if (new_period == 0)
        {
          module_active = false;
        }
        if (new_period != 0 && (new_period < 60 || new_period > 3600))
        {
          printf ("The period can only be 0 seconds or between 60 and 3600 seconds.\n");
        }
        else
        {
          module_active = true;
          inactivity_period = new_period;
        }
      }
    break;
  }

  return((_kernel_oserror *)NULL);
}






/* Ths routine deals with service calls intercepted by this module. */
void module_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
  NOT_USED(pw);

  dprintf(("", "module_sc_handler(): service call 0x%x reason code: 0x%x\n",sn,r->r[2]));

  switch(sn)
  {
    case Service_Standby:
      dprintf(("", "module_sc_handler(): service call : Service_Standby\n"));
      if((r->r[0] & 1) == 0)
      {
        /* The box is waking up */
        dprintf(("", "module_sc_handler(): NC is coming out of standby\n"));
        module_active = true;
      }
      else
      {
        /* The box is going to sleep */
        dprintf(("", "module_sc_handler(): NC is going into standby\n"));
        module_active = false;
      }
      break;

    default:
      dprintf(("", "module_sc_handler(): service call : unrecognized service call\n"));
      break;
  }
}




_kernel_oserror *module_callback_handler(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs swi_regs;

  NOT_USED(r);
  NOT_USED(pw);

  dprintf(("","module_callback_handler(): A key has not been pressed for %d seconds. Hanging up the line.\n", inactivity_period));
  err = _kernel_swi(NCDial_Hangup, &swi_regs, &swi_regs);
  if (err != NULL)
  {
    dprintf(("", "module_callback_handler(): HUP SWI failed\n"));
    return(err);
  }

  return(NULL);
}





_kernel_oserror * module_callafter_handler(_kernel_swi_regs *r, void *pw)
{
  NOT_USED(pw);
  NOT_USED(r);

  setcallback();

  return(NULL);
}




_kernel_oserror *removecallback(void)
{
  _kernel_swi_regs r;
  _kernel_oserror* return_val;

  /* Remove callback */
  r.r[0] = (int) module_callback_entry;
  r.r[1] = (int) module_wsp;
  return_val = _kernel_swi(OS_RemoveCallBack, &r, &r);
  return (return_val);
}



_kernel_oserror *setcallback(void)
{
  _kernel_swi_regs r;
  _kernel_oserror* return_val;

  /* Set callback */
  r.r[0] = (int) module_callback_entry;
  r.r[1] = (int) module_wsp;
  return_val = _kernel_swi(OS_AddCallBack, &r, &r);
  return (return_val);
}






_kernel_oserror *setcallafter(unsigned int seconds)
{
  _kernel_swi_regs r;
  _kernel_oserror* return_val;

  /* Cancel any previous callafter */
  _swix(OS_RemoveTickerEvent, _INR(0, 1), module_callafter_entry, module_wsp);      /* ...then remove the event... */

  /* Set callafter */
  r.r[0] = seconds * 100;
  r.r[1] = (int) module_callafter_entry;
  r.r[2] = (int) module_wsp;
  return_val = _kernel_swi(OS_CallAfter, &r, &r);
  return (return_val);
}








/*********************************************************************************/
/* ticker_event                                                                  */
/*                                                                               */
/* This routine is called on every ticker event. It reads the current mouse      */
/*  position, and if it is different from the previous one it sets a             */
/*  callafter for the required period.                                           */
/*                                                                               */
/* Parameters:  _kernel_swi_regs*                                                */
/*              void*                                                            */
/*                                                                               */
/* Returns:    1                                                                 */
/*                                                                               */
/*********************************************************************************/
int ticker_event(_kernel_swi_regs *rr, void *pw)
{

#ifdef IGNORE_POINTER_MOVEMENTS
   /* This section left intenionally blank */
#else /* We want to cope with mouse pointer movements */
  _kernel_swi_regs r;
  _kernel_oserror* return_val;
  char osw_data[9];

  osw_data[0] = 4; /* subfunction for "get pointer position" */

  // We need to read the mouse state, and if it has altered set the callafter.
  r.r[0] = 21;
  r.r[1] = (int) &osw_data[0];

  return_val = _kernel_swi(OS_Word, &r, &r);
  if (osw_data[1] != mouse_status[0] ||
      osw_data[2] != mouse_status[1] ||
      osw_data[3] != mouse_status[2] ||
      osw_data[4] != mouse_status[3])
  {
    mouse_status[0] = osw_data[1]; // reset the value to the latest one.
    mouse_status[1] = osw_data[2];
    mouse_status[2] = osw_data[3];
    mouse_status[3] = osw_data[4];
    if (module_active)
    {
      dprintf(("", "Mouse position changed. {%d %d %d %d}. Setting a callafter for %d seconds.\n", mouse_status[0], mouse_status[1], mouse_status[2], mouse_status[3], inactivity_period));
      setcallafter(inactivity_period); // Set a callafter for the required time period
    }
  }
#endif /* IGNORE_POINTER_MOVEMENTS */

  NOT_USED(rr);
  NOT_USED(pw);

  return (1);
}





/*********************************************************************************/
/* get_nvram_tag_string                                                          */
/*                                                                               */
/* This routine returns the string held in the NVRAM tag passed in.              */
/*                                                                               */
/* Parameters: char* tag. The tag we wish to acquire a string from.              */
/*                                                                               */
/* Returns:    Null if the required tag was not found, otherwise the string      */
/*              value held in the tag (which could be NULL itself).              */
/*                                                                               */
/*********************************************************************************/
char* get_nvram_tag_string(char* tag)
{
  _kernel_oserror *er = NULL;
  int tag_size = 0;
  char* tag_contents = NULL;

  dprintf (("", "get_nvram_tag_string()\n"));

  er = _swix(NVRAM_Read, _INR(0,1)|_OUT(0), tag, 0, &tag_size);
  if (tag_size > 0)
  {
      dprintf (("", "get_nvram_tag_string(): Tag size is %d\n", tag_size));
      tag_contents = malloc(tag_size);
      if (tag_contents)
      {
        er = _swix(NVRAM_Read, _INR(0,2), tag, tag_contents, tag_size);
        dprintf (("", "get_nvram_tag_string(): Tag contents are '%s' (length %d)\n", tag_contents, strlen(tag_contents)));
        return (tag_contents);
      }
  }

  return (NULL);
}





/*********************************************************************************/
/* get_nvram_tag_numeric                                                         */
/*                                                                               */
/* This routine returns the integer held in the NVRAM tag passed in.             */
/*                                                                               */
/* Parameters: char* tag. The tag we wish to acquire the integer from.           */
/*                                                                               */
/* Returns:    -1 if the tag was not found, otherwise the integer value held     */
/*              in the tag.                                                      */
/*                                                                               */
/*********************************************************************************/
static int get_nvram_tag_numeric(char* tag)
{
  _kernel_oserror *err= NULL;
  int tag_size = 0;
  int tag_contents = 0;

  dprintf (("", "get_nvram_tag_numeric()\n"));

  err = _swix(NVRAM_Read, _INR(0,1)|_OUT(0), tag, 0, &tag_size);
  if (tag_size > 0)
  {
    dprintf (("", "get_nvram_tag_numeric(): Tag size is %d\n", tag_size));
    err = _swix(NVRAM_Read, _INR(0,2), tag, &tag_contents, 0);
    dprintf (("", "get_nvram_tag_numeric(): Tag contents are %d\n", tag_contents));
    return (tag_contents);
  }

  return (-1);
}



_kernel_oserror *module_claimv(void)
{
  _kernel_swi_regs r;
  dprintf(("", "module_claimv()\n"));

  r.r[0] = EventV;
  r.r[1] = (int)module_event_entry;
  r.r[2] = (int)module_wsp;
  return (_kernel_swi(OS_Claim, &r, &r));
}




_kernel_oserror *module_event_enable(void)
{
  _kernel_swi_regs r;
  dprintf(("", "module_event_enable()\n"));

  r.r[0] = Event_Enable;
  r.r[1] = Event_Keyboard;
  return (_kernel_swi(OS_Byte, &r, &r));
}




_kernel_oserror *module_event_disable(void)
{
  _kernel_swi_regs r;
  dprintf(("", "module_event_disable()\n"));

  r.r[0] = Event_Disable;
  r.r[1] = Event_Keyboard;
  return (_kernel_swi(OS_Byte, &r, &r));
}



void module_releasev(void)
{
  _kernel_swi_regs r;
  dprintf(("", "module_releasev()\n"));

  /* Disable the event */
  module_event_disable();

  /* Release the vector */
  r.r[0] = EventV;
  r.r[1] = (int)module_event_entry;
  r.r[2] = (int)module_wsp;
  (void) _kernel_swi(OS_Release, &r, &r);
}





int module_event_handler(_kernel_swi_regs *r, void *pw)
{
  NOT_USED(pw);

  if (r->r[0] == Event_Keyboard)
  {
    /* We only reset the callafter if the module is active - this essentially ignores keypresses when in standby */
    if (module_active)
    {
      dprintf(("", "module_event_handler(): Key_Pressed event received. Setting a callafter for %d seconds.\n", inactivity_period));
      setcallafter(inactivity_period); /* Set a callafter for the required time period */
      return (1);
    }

    return(1);
  }

    return(1);
}

