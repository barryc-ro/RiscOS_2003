/****************************************************************************
/
/     Copyright 1988,1989,1990,1991,1992,1993,1994,1995.
/     All Rights Reserved by:
/        RSA
/        7701 Six Forks Road
/        Suite 120
/        Raleigh, NC  27615
/        (919) 846-7171
/
/     This document contains material confidential to RSA its contents must
/     not be revealed, used or disclosed to anyone or company with out
/     written permission by RSA.  The information contained herein is solely
/     for the use of RSA.
/
/     File:             ac00cmat.c
/
/     Module Version:   ACU 5.00
/
/     Function:         This file contains the code for the basic AT command
/                       set.
/
/     Product:          ACU core code
/
/     History:          ac00cmat.c v3.90
/                       ac00cmat.c v3.91
/                       ac00cmat.c v3.92
/                       ac00cmat.c v3.93
/                       ac00cmat.c v3.94
/                       ac00cmat.c v3.95
/                       ac00cmat.c v3.96
/                       ac00cmat.c v4.02
/
/      Created:         10/7/91
/                       10/17/91
/                       11/16/91
/                       12/04/91
/                       1/21/92
/                       3/10/92
/                       1/12/93
/                       12/12/94
/
/        ---------------------------------------------------------
/        -                   Modifications                       -
/        ---------------------------------------------------------
/
/        Author & Date:  RSA
/        Description:
/        Reason:
/
*****************************************************************************/

#include "sys_def.h"
#include "ee_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "acu_vce.h"
#include "mt_pro.h"


/* Local Prototypes */
void at_B(ubyte *);
void at_C(ubyte *);
void at_E(ubyte *);
void at_F(ubyte *);
void at_H(ubyte *);
void at_I(ubyte *);
void at_L(ubyte *);
void at_M(ubyte *);
void at_N(ubyte *);
void at_O(ubyte *);
void at_P(void);
void at_Q(ubyte *);
void at_S(ubyte *);
void at_equal(ulong *);
void chk_sreg_range(ulong);
void at_quest(void);
void at_T(void);
void at_V(ubyte *);
void at_W(ubyte *);
void at_X(ubyte *);
void at_Y(ubyte *);
void at_Z(ubyte *);
void at_comma(void);
void get_rom_components(void);


/*******************************************************************************
/
/     Routine:       at_A
/
/     Author:        RSA
/
/     Creation Date: 12/07/94
/
/     Description:   This routine is called to implement the Answer command:
/                    "ATA."  The ATA command is used answer a call.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr.27.Bell_mode, atB
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_A(void)
{
   /* No parameter for ATA command */
   send_ok = FALSE;

   /* ATA is invalid for Voice IS-101 */
   if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
   {
       error_occurred = TRUE;
   }
   /* ATA is invalid if we're already connected */
   else if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
       build_event(E_ANSW,UNUSED);
   }
   else
   {
       error_occurred = TRUE;
   }
}


/*******************************************************************************
/
/     Routine:       at_B
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine will select the communication mode to
/                    be used.
/
/                    ATB   0  - CCITT mode (V.22 at 1200bps)
/                          1  - Bell mode (Bell 212A at 1200bps)
/                          2  - V23 mode if originating T75/R1200 BPS
/                                if answering T1200/R75 BPS
/                          3  - V23 mode if originating T1200/R75 BPS
/                                if answering T75/R1200 BPS
/
/                          15 - V.21 (at 300 bps)
/                          16 - Bell 103 (at 300 bps)
/
/                          30 - V.22bis (at 2400 bps)
/                          31 - V.34 (at 2400 bps)
/
/                          41 - V.32 (at 4800 bps)
/                          42 - V.34 (at 4800 bps)
/
/                          52 - V.32 (at 7200 bps)
/                          53 - V.34 (at 7200 bps)
/
/                          60 - V.32 (at 9600 bps)
/                          61 - V.34 (at 9600 bps)
/
/                          70 - V.32 (at 12000 bps)
/                          71 - V.34 (at 12000 bps)
/
/                          75 - V.32 (at 14400 bps)
/                          76 - V.34 (at 14400 bps)
/
/                          80 - V.34 (at 16800 bps)
/
/                          85 - V.34 (at 19200 bps)
/
/                          90 - V.34 (at 21600 bps)
/
/                          95 - V.34 (at 24000 bps)
/
/                         100 - V.34 (at 26400 bps)
/
/                         105 - V.34 (at 28800 bps)
/
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr.27.Bell_mode, atB
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_B(ubyte *param_ptr)
{
   ubyte num;

   /* Ubyte parameter for ATB command */
   num = *param_ptr;

   /* If parameter on ATB is greater then what is allowed for V.22bis then
      need to return error. */
   if (acu_cfg.mode == CFG_V22BIS)
   {
      if (num >= 40)
      {
         error_occurred = TRUE;
         return;
      }
   }
   /* If parameter on ATB is not allowed for V.32 then need to return error */
   else if (acu_cfg.mode == CFG_V32)
   {
      if (((num >= 50) && (num <= 59)) || (num >= 70))
      {
         error_occurred = TRUE;
         return;
      }
   }
   /* If parameter on ATB is greater then what is allowed for V.32bis then
      need to return error. */
   else if (acu_cfg.mode == CFG_V32BIS)
   {
      if (num >= 80)
      {
         error_occurred = TRUE;
         return;
      }
   }
   /* If parameter on ATB is greater then what is allowed for V.34 then
      need to return error. */
   else if( (acu_cfg.mode == CFG_V34) || (acu_cfg.mode == CFG_V34BIS) )
   {
      if (num > 110)
      {
         error_occurred = TRUE;
         return;
      }
   }


   /* See if value is in group 1 (1200 bps) */
   if (num <= 9)
   {
      /* See if valid value for group 1 */
      switch (num)
      {
         case 0: /* Bell 212 */
            sr27.BELL_mode = FALSE;
            atB.group1 = num;
            atB.group3 = 15;
            break;

         case 1: /* V.22 */
            sr27.BELL_mode = TRUE;
            atB.group1 = num;
            atB.group3 = 16;
            break;

         case 2: /* V.23 */
         case 3: /* V.23R */
            if (acu_cfg.v23)
               atB.group1 = num;
            else
               error_occurred = TRUE;
            break;

         default: error_occurred = TRUE;
            break;
      }
   }
   /* See if value is in group 2 (Transmit 75 bps)    */
   else if ((num >= 10) && (num <= 14 ))
   {
      error_occurred = TRUE;
   }
   /* See if value is in group 3 (300 bps)   */
   else if ((num >= 15) && (num <= 19 ))
   {
      /* See if valid value for group 3 */
      switch (num)
      {
         case 15:    /* Bell 103 */
            sr27.BELL_mode = FALSE;
            atB.group3 = num;
            break;

         case 16:    /* V.21 */
            sr27.BELL_mode = TRUE;
            atB.group3 = num;
            break;

         default: error_occurred = TRUE;
            break;
      }
   }
   /* See if value is in group 4 (600 bps)   */
   else if ((num >= 20) && (num <= 29 ))
   {
      error_occurred = TRUE;
   }
   /* See if value is in group 5 (2400 bps) */
   else if ((num >= 30) && (num <= 39 ))
   {
      /* See if valid value for group 5 */
      switch (num)
      {
         case 30:    /* V.22bis */
         case 32:    /* V.34 */
            atB.group5 = num;
            break;

         default: error_occurred = TRUE;
            break;
      }
   }
   /* See if value is in group 6 (4800 bps) */
   else if ((num >= 40) && (num <= 49 ))
   {
      /* See if valid value for group 6 */
      switch (num)
      {
         case 41:    /* V.32 */
         case 42:    /* V.34 */
            atB.group6 = num;
            break;

         default: error_occurred = TRUE;
            break;
      }
   }
   /* See if value is in group 7 (7200 bps) */
   else if ((num >= 50) && (num <= 59 ))
   {
      /* See if valid value for group 7 */
      switch (num)
      {
         case 52:    /* V.32 */
         case 53:    /* V.34 */
            atB.group7 = num;
            break;

         default: error_occurred = TRUE;
            break;
      }
   }
   /* See if value is in group 8 (9600 bps) */
   else if ((num >= 60) && (num <= 69 ))
   {
      /* See if valid value for group 8 */
      switch (num)
      {
         case 60:    /* V.32 */
         case 61:    /* V.34 */
            atB.group8 = num;
            break;

         default: error_occurred = TRUE;
            break;
      }
   }
   /* See if value is in group 9 (12000 bps) */
   else if ((num >= 70) && (num <= 74 ))
   {
      /* See if valid value for group 9 */
      switch (num)
      {
         case 70:    /* V.32 */
         case 71:    /* V.34 */
            atB.group9 = num;
            break;

         default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 10 (14400 bps) */
   else if ((num >= 75) && (num <= 99 ))
   {
      /* See if valid value for group 10 */
      switch (num)
      {
         case 75:    /* V.32 */
         case 76:    /* V.34 */
            atB.group10 = num;
            break;

         default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 11 (16800 bps) */
   else if ((num >= 80) && (num <= 84 ))
   {
      /* See if valid value for group 11 */
      switch (num)
      {
         case 80:    /* V.34 */
            atB.group11 = num;
            break;
         default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 12 (19200 bps) */
   else if ((num >= 85) && (num <= 89))
   {
      /* See if valid value for group 12 */
      switch (num)
      {
         case 85:    /* V.34 */
            atB.group12 = num;
            break;
         default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 13 (21600 bps) */
   else if ((num >= 90) && (num <= 94))
   {
      /* See if valid value for group 13 */
      switch (num)
      {
         case 90:    /* V.34 */
            atB.group13 = num;
            break;
         default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 14 (24000 bps) */
   else if ((num >= 95) && (num <= 99))
   {
      /* See if valid value for group 14 */
      switch (num)
      {
         case 95:    /* V.34 */
            atB.group14 = num;
            break;
         default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 15 (26400 bps) */
   else if ((num >= 100) && (num <= 104))
   {
      /* See if valid value for group 15 */
      switch (num)
      {
         case 100:   /* V.34 */
            atB.group15 = num;
            break;

         default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 16 (28800 bps) */
   else if ((num >= 105) && (num <= 109))
   {
      /* See if valid value for group 16 */
      switch (num)
      {
         case 105:   /* V.34 */
            atB.group16 = num;
            break;

         default: error_occurred = TRUE;
      }
   }
   else
   {
      error_occurred = TRUE;
   }
}


/*******************************************************************************
/
/     Routine:       at_C
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the carrier control option
/
/                    ATC   0 - transmit carrier always off  (not supported)
/                          1 - normal transmit carrier switching
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_C(ubyte *param_ptr)
{
   /* Ubyte parameter for ATC command */
   if (*param_ptr != 1)
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_D
/
/     Author:        RSA
/
/     Creation Date: 12/07/94
/
/     Description:   This routine is called to implement the Dial command:
/                    "ATD."  The ATD command is used originate a call.
/
/     Input Parameters: pointer to the command's parameter (a NULL terminated
/                       string)
/
/     Output Parameters: none
/
/     Global Variables Changed:
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_D(ubyte *param_ptr)
{
   /* Save Address of the Address String Buffer for later use */
   acu_dial_string_ptr = param_ptr;
   send_ok = FALSE;

   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
       build_event(E_ORIG,UNUSED);
   }
   else
       error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_E
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the command character echo option
/
/                    ATE   0 - off-line character echo disabled
/                          1 - off-line character echo enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.echo_cmd_flag, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_E(ubyte *param_ptr)
{
   /* Ubyte parameter for ATE command */
   switch (*param_ptr)
   {
      case 0:
         sr14.echo_cmd_flag = FALSE;
         modem_serial_echo(OFF);
         break;

      case 1:
         sr14.echo_cmd_flag = TRUE;
         break;

      default:
         error_occurred = TRUE;
         return;
   }
}


/*******************************************************************************
/
/     Routine:       at_F
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:  This Routine selects the data character echo option
/
/                    ATF   0 - on-line character echo enabled (not supported)
/                          1 - on-line character echo disabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_F(ubyte *param_ptr)
{
   /* Only ATF1 is supported */
   if (*param_ptr != 1)
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_H
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine controls the switch hook.
/
/                    ATH   0 - execute hang up process
/                          1 - go off hook, but no handshake
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed: error_occurred, at_h_command
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_H(ubyte *param_ptr)
{
   /* Ubyte parameter for ATH command */
   switch (*param_ptr)
   {
      case 0:
         /* Terminate the link */
         if (on_line_command && !test_in_progress && fax_class == 0)
            hangup_connection(NONE);
         /* Else queue HANGUP event to terminate the test */
         else
            build_event(E_HANGUP,NONE);

         at_h_command = TRUE;
         user_initiated_hangup = TRUE;
         break;

      case 1:
         /* ATH1 is not allowed in TIA voice */
         if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
         {
            error_occurred = TRUE;
            return;
         }
         modem_td_relay(ON);
         off_hook();

         if (sr21.auxiliary_relay_ctrl)
            modem_AA1_relay(ON);
         break;

      default:
         error_occurred = TRUE;
         return;
   }
}

/*******************************************************************************
/
/     Routine:       at_I
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine is uded to display hardware description.
/
/                    ATI   0 - Display product code
/                          1 - Calculate and display ROM checksum
/                          2 - Verify ROM checksum
/                          3 - Display part numbers and revision levels
/                          4 - Display modem capabilities
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_I(ubyte *param_ptr)
{
   ubyte *string;
   ubyte checksum;

   if (voice_cmd_set == TIA_IS_101)
   {
      error_occurred = TRUE;
      return;
   }

   /* Ubyte parameter for ATI command */
   switch (*param_ptr)
   {
      case 0:
         string = modem_product_code();
         output_info(string,(ubyte)sr14.verbose_form);
         break;

      case 1:
         checksum = modem_rom_checksum();
         string = d_to_a(checksum);
         output_info(string,(ubyte)sr14.verbose_form);
         break;

      case 2:
         if (!modem_rom_test())
            string = (ubyte *)"ERROR";
         else
            string = (ubyte *)"OK";
         output_info(string,(ubyte)sr14.verbose_form);
         break;

      case 3:
         get_rom_components();
         break;

      case 4:
         string = modem_capability_descript();
         output_info(string,(ubyte)sr14.verbose_form);
         break;

      default:
         error_occurred = TRUE;
         return;
   }
}


/*******************************************************************************
/
/     Routine:       get_rom_components
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine builds the information string containing
/                    part numbers and revision levels of the ROM components
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users: at_I()
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void get_rom_components(void)
{
   ubyte rom_data[15];
   ubyte *ptr;

   ptr = &rom_data[0];
   *ptr++ = 'A';
   *ptr++ = 'C';
   *ptr++ = 'U';
   *ptr++ = ' ';
   *ptr++ = 'V';
   *ptr++ = version_num[0];
   *ptr++ = '.';
   *ptr++ = version_num[1];
   *ptr++ = version_num[2];
   *ptr= 0x00;

   ptr = &rom_data[0];
   output_info(ptr,(ubyte)sr14.verbose_form);
}

/*******************************************************************************
/
/     Routine:       at_L
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the speaker volume.
/                    ATL   0 - Low volume
/                          1 - Low volume
/                          2 - Medium volume
/                          3 - High volume
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.speaker_vol, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_L(ubyte *param_ptr)
{
   ubyte num;

   /* Not allowed in voice mode */
   if (voice_cmd_set == TIA_IS_101)
   {
      error_occurred = TRUE;
      return;
   }

   num = *param_ptr;
   if (num <= 3)
   {
      sr22.speaker_vol = num;
      modem_speaker_vol(num);
   }
   else
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_M
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the speaker control.
/
/                    ATM   0 - Speaker always off
/                          1 - Speaker on until carrier present
/                          2 - Speaker always on
/                          3 - Speaker off during dialing and on until carrier
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.speaker_control, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_M(ubyte *param_ptr)
{
   if (voice_cmd_set == TIA_IS_101)
   {
      error_occurred = TRUE;
      return;
   }

   switch (*param_ptr)
   {
      case 0:
         sr22.speaker_ctrl = ALWAYS_OFF;
         modem_speaker(OFF);
         break;

      case 1:
         sr22.speaker_ctrl = ON_UNTIL_CD;
         if (!hook)
            modem_speaker(OFF);
         break;

      case 2:
         sr22.speaker_ctrl = ALWAYS_ON;
         if (!hook)
            modem_speaker(ON);
         break;

      case 3:
         sr22.speaker_ctrl = OFF_DIALING;
         if (!hook)
            modem_speaker(OFF);
         break;

      default: error_occurred = TRUE;
         return;
   }
}

/*******************************************************************************
/
/     Routine:       at_N
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the auto-mode/V.8 option. (bit mapped)
/                    ATNn  0 - Automode disabled, V.8 disabled
/                          1 - Automode enabled,  V.8 disabled
/                          2 - Automode disabled, V.8 enabled
/                          3 - Automode enabled,  V.8 enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  automode, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_N(ubyte *param_ptr)
{
   /* Test for automode and V.8 */
   if (*param_ptr <= 3)
      automode = *param_ptr;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_O
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to tell the modem to return to
/                    a previously established connection.
/
/                    ATO   0 - Go to on-line state
/                          1 - Go to on-line state and retrain adaptive equalizer
/                             (V.22bis,V.32,V.32bis, and V.34 modulations only)
/                          3 - Go to on-line state and rate renegotiate
/                             (V.32bis, and V.34 modulations only)
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred, result_message_sent,
/                    send_ok, on_line_command, modem_baud, acu_state
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_O(ubyte *param_ptr)
{
   ubyte num, tmp;

   if (voice_cmd_set == TIA_IS_101)
   {
       error_occurred = TRUE;
       return;
   }

   /* Allow ATO to return online from some tests... */
   switch (test_in_progress)
   {
      case 0: /* No Test in progress - do nothing */
         break;

      case ALB:
      case RDL:
         /* Return back to the test (AT&T1,6) */
         build_event(E_TEST,TEST_RETURN);
         return;

      default:
         error_occurred = TRUE;
         return;
   }

   /* If on hook, the command is not vaild */
   if ((hook == TRUE) || (slU == TRUE))
   {
      error_occurred = TRUE;
      return;
   }

   /* Get AT command parameter local */
   num = *param_ptr;

   /* Update modem's retrain operation in case it has changed while in on
      line command mode. */
   tmp = ((((slN != DIRECT) && (!bps_adjust)) ||
      (comm_mode != ASYNC)) && (autofallback));
   modem_retrain_enable(perE,s[110],tmp);

   /* Update the modem's possible rates in case they have changed while in
      on line command mode */
   update_modem_rate_seq();

   /* If running MNP 10 do not allow the ACU to force a retrain or rate
      renegotiation. These should be controlled by the MNP 10 code only. */
   if (v42_running_mnp10)
      num = 0;

   /* Which ATO command */
   switch (num)
   {
      case 0:
         if (on_line_command)
         {
            /* Build CONNECT event and cleanup after parse state */
            parse_return_online();

            return; /* Do not fall through and reconfigure the
                     system. It is done by the return online function */
         }
         else
         {
            /* Originate w/out dialing */
            if (sr14.originate_flag)
               build_event(E_ORIG,NO_DIAL);
            else
               build_event(E_ANSW,UNUSED);
         }
         break;

       case 3:
         /* If V.32bis operation is not enabled then need to
            return error if trying to issue a rate renegotiation. */
         /* V.34 allows RRNS too */
         if ((v32bis_enable == 0) &&
            (modem_mode != V34 && modem_mode != V34_ASYMETRIC))
         {
            error_occurred = TRUE;
            return;
         }

         /* Intentionally fall through */

      case 1:
         if (on_line_command)
         {
            /* Execute retrain */
            if (num == 1)
               modem_retrain();
            else /* num == 3 */
               modem_renegotiate();

            timer1 = 1500;    /* Retrain to complete delay time */

            /* Move the parse state to wait for retrain to complete,
               then issue the CONNECT from the parse state */
            st_parse.state = CMD7;

            return; /* Do not fall through and reconfigure the system yet.
                        It is done after the parse_to_online_retain state */
         }
         else if (sr14.originate_flag)
            build_event(E_ORIG,NO_DIAL);
         else
            build_event(E_ANSW,UNUSED);
         break;

      default:
         error_occurred = TRUE;
         return;
   }

   send_ok = FALSE;
   on_line_command = FALSE;

   system_reconfigure();
   autobaud_off();
}


/*******************************************************************************
/
/     Routine:       at_P
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects pulse dialing.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.pulse
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_P(void)
{
   sr14.pulse = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_Q
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the result code display option
/
/                    ATQ   0 - Result codes enabled
/                          1 - Result codes disabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.disable_result_code, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_Q(ubyte *param_ptr)
{
   if (voice_cmd_set == TIA_IS_101)
   {
      error_occurred = TRUE;
      return;
   }

   if (*param_ptr == 0)
      sr14.disable_result_code = FALSE;
   else if (*param_ptr == 1)
      sr14.disable_result_code = TRUE;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_S
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:  This Routine selects a register for next read or write
/                    operation. It will allow any value to be selected even
/                    if the register does not exist.
/
/                    ATS   0 - 27,30,37,63,91,95...
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  current_register
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_S(ubyte *param_ptr)
{
   current_register = *param_ptr;
}

/*******************************************************************************
/
/     Routine:       at_equal
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine will change the selected register value.
/
/                    ATS   0 - 27,30,37,63,91,108,109,110...
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  current_register
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_equal(ulong *param_ptr)
{
   ulong num;

   /* Can't set some S-Regs in Voice mode */
   if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101) &&
      ((current_register == 0) || (current_register == 10)))
   {
      error_occurred = TRUE;
      return;
   }

   if ((current_register > 27) && (current_register != 30) &&
      (current_register != 37) && (current_register != 63) &&
      (current_register != 91) && (current_register != 95) &&
      (current_register != 108) && (current_register != 109) &&
      (current_register != 110) &&
      (!((current_register >= 112) && (current_register <= 118))))
   {
      error_occurred = TRUE;
      return;
   }

   num = *param_ptr;

   if (error_occurred == TRUE)
   {
      /* If value is greater than 255, and register is bit mapped then
         return error. Else set value entered to 255 */
      if ((current_register == 14) || (current_register == 16) ||
         (current_register == 21) || (current_register == 22) ||
         (current_register == 23) || (current_register == 27))
      {
         return;
      }
      else
      {
         num = 255;
         error_occurred = FALSE;
      }
   }

   /* Else check the range of the input value */
   chk_sreg_range(num);

   if ((current_register == 7) || (current_register == 9) || (current_register == 10) ||
      (current_register == 63) || (current_register == 91) || (current_register == 108))
   {
      if (sr27.leased_line == TRUE)
      {
         modem_set_parameters(s[9],s[7],255,v32_retrain,s[63],
            receive_threshold,s[108]);
         modem_speaker(OFF);
      }
      else
         modem_set_parameters(s[9],s[7],s[10],v32_retrain,s[91],
                receive_threshold,s[108]);
   }

   /* Need to turn on or turn off the auto-answer LED depending upon the
      value of s[0]. */
   if (current_register == 0)
   {
      if (num > 0)
         modem_aa_led(ON);
      else
         modem_aa_led(OFF);
   }
}


/*******************************************************************************
/
/     Routine:       chk_sreg_range
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine checks the input value against the accepted
/                    ranges for the selected S register.
/
/     Input Parameters: ubyte num - value to be checked
/
/     Output Parameters: none
/
/     Global Variables Changed:  selected register
/
/     Users:   at_equal
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void chk_sreg_range(ulong num)
{
   ulong count,i;

   count = s_range[current_register][0];
   if (count == 0)
   {
      error_occurred = TRUE;
      return;
   }

   i=1;
   while (count != 0)
   {
      if ((s_range[current_register][i++] <= num) &&
         (num <= s_range[current_register][i++]))
      {
         *srptr[current_register] = num;
         return;
      }
      count--;
   }

   /* If value entered is greater then maximum allowed value need to set the
      S register to the max value   */
   i--;
   if (num > s_range[current_register][i])
      *srptr[current_register] = s_range[current_register][i];

   /* If value entered is less then minimum allowed value need to set the
      S register to the min value   */
   if (num < s_range[current_register][1])
      *srptr[current_register] = s_range[current_register][1];
}


/*******************************************************************************
/
/     Routine:       at_quest
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine reads the selected register and will
/                    display it to the user.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  none
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_quest(void)
{
   ubyte *string;

   /* If register selected is not inplimented then return 000 to the terminal */
   if ((current_register > 27) && (current_register != 30) &&
      (current_register != 37) && (current_register != 63) &&
      (current_register != 91) && (current_register != 95) &&
      (current_register != 108) && (current_register != 109) &&
      (current_register != 110) && (current_register != 112) &&
      (!((current_register >= 112) && (current_register <= 118))))
      string = d_to_a(0);
   else
      string = d_to_a(*srptr[current_register]);

   output_info(string,(ubyte)sr14.verbose_form);
}


/*******************************************************************************
/
/     Routine:       at_T
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects tone dialing.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.pulse
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_T(void)
{
   sr14.pulse = FALSE;
}

/*******************************************************************************
/
/     Routine:       at_V
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the result code format.
/
/                    ATV   0 - Displayed in numeric form
/                          1 - Displayed in verbose form
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.verbose_form, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_V(ubyte *param_ptr)
{
   switch (*param_ptr)
   {
      case 0:
         sr14.verbose_form = FALSE;
         break;

      case 1:
         sr14.verbose_form = TRUE;
         break;

      default:
         error_occurred = TRUE;
         return;
   }
}

/*******************************************************************************
/
/     Routine:       at_W
/
/     Author:        RSA
/
/     Creation Date: 07/17/91
/
/     Description:   This Routine will determine the modems connect message
/                    if S95 = 0.  a_to_d() will retrieve a number causing
/                    the following behavior:
/
/                       0 -  If S95 = 0, CONNECT result code reports
/                             DTE speed and all extended result codes
/                             are disabled.
/
/                       1 -  If S95 = 0, CONNECT result code reports
/                             DTE speed and CARRIER and PROTOCOL result
/                             codes are enabled.
/
/                       2 -  If S95 = 0, CONNECT result code reports
/                             DCE speed and all extended result codes
/                             are disabled.
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameter: None
/
/     Global Variables Changed: atW
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_W(ubyte *param_ptr)
{
   if (*param_ptr <= 2)
      atW = *param_ptr;
   else
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_X
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects tone detection options and the
/                    associated result codes.
/
/                    ATX   0 - Result codes 0-4 enabled. Busy and dial tone
/                              detect disabled
/                          1 - Result codes 0-4,10 enabled. Busy and dial tone
/                              detect disabled
/                          2 - Result codes 0-6,10 enabled. Busy detect disabled
/                              dial tone detect enabled
/                          3 - Result codes 0-5,7,10 enabled. Busy detect enabled
/                              dial tone detect disabled
/                          4 - Result codes 0-7,10 enabled. Busy and dial tone
/                              detect enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.busy_enable, sr22.dialtone_enable,
/               sr22.enable_result5, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_X(ubyte *param_ptr)
{
   if (voice_cmd_set == TIA_IS_101)
   {
      error_occurred = TRUE;
      return;
   }

   /* What is the AT command input? */
   switch (*param_ptr)
   {
      case 0:
         sr22.busy_enable = FALSE;
         sr22.dialtone_enable = FALSE;
         sr22.enable_result5 = FALSE;
         break;

      case 1:
         sr22.busy_enable = FALSE;
         sr22.dialtone_enable = FALSE;
         sr22.enable_result5 = TRUE;
         break;

      case 2:
         sr22.busy_enable = FALSE;
         sr22.dialtone_enable = TRUE;
         sr22.enable_result5 = TRUE;
         break;

      case 3:
         sr22.busy_enable = TRUE;
         sr22.dialtone_enable = FALSE;
         sr22.enable_result5 = TRUE;
         break;

      case 4:
         sr22.busy_enable = TRUE;
         sr22.dialtone_enable = TRUE;
         sr22.enable_result5 = TRUE;
         break;

      default:
         error_occurred = TRUE;
         return;
   }

   valueX = *param_ptr;
}

/*******************************************************************************
/
/     Routine:       at_Y
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine sets long space disconnect option
/
/                    ATY   0 - Disable long space disconnect
/                          1 - Enable long space disconnect
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr21.long_space_discon, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_Y(ubyte *param_ptr)
{
   /* Verify input bounds */
   if (*param_ptr == 0)
      sr21.long_space_discon = FALSE;
   else if (*param_ptr == 1)
      sr21.long_space_discon = TRUE;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_Z
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine recalls stored profile
/
/                    ATZ   0 - Recall stored profile 0
/                          1 - Recall stored profile 1
/                          2 - Recall stored profile 2
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_Z(ubyte *param_ptr)
{
   #ifdef TMLDEBUG
   Printf("at_Z\n");
   #endif
   /* Profile ZERO counts */
   if (*param_ptr < NUMBER_OF_PROFILES)
   {
      /* If a test is currently running then need to terminate it */
      if (test_in_progress)
         build_event(E_HANGUP,NONE);

      /* If modem is online, need to hangup the connection */
      if (!hook || on_line_command)
      {
         build_event(E_HANGUP,OK);
         user_initiated_hangup = TRUE;
         at_z_command = TRUE;
      }

    #ifdef TMLDEBUG
    Printf("About to call acu_load_defaults()\n");
    #endif
      /* Load AT command defaults */
      acu_load_defaults(AT_Z_COMMAND);

    #ifdef TMLDEBUG
    Printf("About to call retrieve_profile()\n");
    #endif
      /* Load Stored command defaults */
      retrieve_profile(*param_ptr,COMMAND);
   }
   else
      error_occurred = TRUE;
   #ifdef TMLDEBUG
   Printf("at_Z exit\n");
   #endif
}

/*******************************************************************************
/
/     Routine:       at_comma
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to pause for the time specified
/                    by s8.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  timer1
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author &       Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_comma(void)
{
   /* Start delay timer */
   timer1 = dial_pause_time * 100;

   /* Change parse states to time the delay in the BG */
   st_parse.state = CMD6;  /* Parse command delay */
}
