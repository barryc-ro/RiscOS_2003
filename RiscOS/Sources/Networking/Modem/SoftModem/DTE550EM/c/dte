/************************************************************************
/
/   Copyright 1994, 1995.
/   All Rights Reserved by:
/   RSA
/   7701 Six Forks Road
/   Suite 120
/   Raleigh, NC  27615
/   (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File:      DTE.C
/
/   Version:   1.00
/
/   Function:  This file contains the DTE IO code
/
/   Product:   PC development
/
/   Platform:
/
/   History:   acu.c v1.00
/
/   Created:   12/08/94
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
#include "sys_def.h"
#include "acuiomem.h"
#include "acu_def.h"
#include "acu_mem.h"

#include "dteequ.h"
#include "dte.edf"

extern ubyte acu_enabled;  /* route data to ACU I/O code or DTE I/O code */

/* unified DTE I/O routines */
uword dte_from_num(void);
ubyte dte_from_char(void);
void  dte_from_clear(void);
void  dte_to_clear(void);
uword dte_to_free(void);
void  dte_to_char (ubyte);
ubyte dte_to_num(void);
ubyte dte_rx_resume(void);
void  dte_tx_resume(void);
void dte_rx_int(void);
ubyte dte_rx_suspend(void);
void  dte_tx_suspend(void);
void dte_start_tx_break(void);
void dte_finish_tx_break(void);
void  dte_timer (void);
void  dte_to_break (ubyte type, ubyte length);
void dte_check_hardware_flow(void);
void  dte_init(ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte);

void  dte_reconfigure(ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte);
void  dte_port_init(void);
void  common_dte_init(ubyte, ubyte, ubyte);

/* block DTE I/O routines */
uword dte_from_block_num(void);

void  dte_from_block_update(uword);

ubyte *dte_from_block_pointer(void);
uword dte_to_block_free(void);
void  dte_to_block_update(uword);
ubyte *dte_to_block_pointer(void);
void  dte_info(ubyte *);
void dte_tx_int(void);

extern void acu_tx_int(void);
extern void PCterminal_cts_on(void);
extern void PCterminal_cts_off(void);
extern void PCterminal_to_char (unsigned char);
extern int PCterminal_to_free(void);
extern int PCterminal_rts_status(void);
extern void PCterminal_to_break(void);
extern void PCterminal_to_break_end(void);

ubyte bTxRunning = 0;

/* fax only DTE I/O routines */
void fax_dte_reset(void);
void fax_dte_init(ubyte, ubyte, ubyte);
ubyte fax_dte_flowed_on(void);

/* Voice only DTE I/O routines */
void voice_dte_init(ubyte, ubyte, ubyte);

/* stubbed routine prototypes */
void  dte_falling_back_to_speed (void);
void  dte_end_falling_back_to_speed (void);
void  dte_reset(void);

void  dte_dest_break_clear(void);
ubyte set_cntl_parity(ubyte in_char, ubyte parity );
void dte_enable(void);
void dte_disable(void);
ubyte io_read_switches(void);
void  io_set_LEDS(ubyte bb_LED_long);
void  io_DAAWrite (ubyte io);

void io_DAAWrite( ubyte io)
{
ubyte dummy;
dummy = io;
}

void io_set_LEDS(ubyte bb_LED_long)
{
ubyte dummy;
dummy =bb_LED_long;
}

ubyte io_read_switches(void)
{
return 0;
}


ubyte set_cntl_parity(ubyte in_char, ubyte parity )
{
ubyte a;
  a = in_char;a= parity;
  return (a);
}

void dte_cts_on (void);
void dte_cts_off (void);

/************************************************************************
/
/   Routine: dte_cts_on
/
/   Author: RSA
/
/   Creation Date:   10/28/94
/
/   Description:   This routine will assert CTS to the DTE
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   dte_rx_suspend, dte_rx_resume
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_cts_on(void)
{
     PCterminal_cts_on();
}

/************************************************************************
/
/   Routine: dte_cts_off
/
/   Author: RSA
/
/   Creation Date:   10/28/94
/
/   Description:   This routine will deassert CTS to the DTE
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   dte_rx_suspend, dte_rx_resume
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_cts_off(void)
{
    PCterminal_cts_off();
}



/************************************************************************
/
/            dte_from_num
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine returns the number of chars received from
/                  the dte and waiting in the buffer.
/
/   Input Parameters: None
/
/   Output Parameters: uword dte_rx_count
/
/   Global Variables Changed:  None
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
uword dte_from_num(void)
{
   if( dte_mode != ACU )
       return(dte_rx_count);
   else
       return(0);
}

/************************************************************************
/
/            dte_from_clear
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine resets all variables associated with
/                  receiving characters from the DTE.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_from_clear(void)
{


   ENTER_CRITICAL_SECTION


   dte_rx_insert = 0;            /* reset buffer pointers */
   dte_rx_remove = 0;
   dte_rx_count = 0;

   if ((dte_mode == DTE) || (dte_mode == FAX))
   {
      dte_20_mSec_timer = 2;      /* reset 20 Msec timer */
      /*  reset escape variables */
      dte_tesc_count = 0;
      dte_guard_time = FALSE;          /* leading guard time not found */
      dte_guard_time = esc_guard_time;/* reset guard time counter */
   }

   /* If all other modes should to flow control */
   /* If rx was flowed off, start it back up */
   if (rx_suspended)
   {
      if (dte_tx_interrupt_expected)
         rx_resume_pending = TRUE;
      else
         dte_rx_resume();
   }
   LEAVE_CRITICAL_SECTION

}

/************************************************************************
/
/            dte_to_clear
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine resets all variables associated with
/                  transmitting all characters to the DTE.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_to_clear(void)
{
   ENTER_CRITICAL_SECTION

   if ((dte_mode == ACU) && pp_enabled)
      pp_to_clear();          /* run packet protocol routine */
   dte_tx_insert = 0;         /* fall through and use this routine too */
   dte_tx_remove = 0;
   dte_tx_count = 0;
   dte_tx_interrupt_expected = FALSE;

   LEAVE_CRITICAL_SECTION

}

/************************************************************************
/
/            dte_from_char
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine retrieves the next char from the buffer
/
/   Input Parameters: None
/
/   Output Parameters: ubyte rxchar
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
ubyte dte_from_char(void)
{
   ubyte rxchar;

   ENTER_CRITICAL_SECTION

   rxchar = dte_rx_buffer[dte_rx_remove++];
   dte_rx_remove &= BUFFER_POINTER_MASK;
   dte_rx_count--;

   /* If rx was flowed off in DTE mode, start it back up */
   if (((dte_mode == DTE) || (dte_mode == FAX)) && rx_suspended)
   {
      if ( dte_rx_count < DTE_NEAR_EMPTY )
      {
         if ( dte_tx_interrupt_expected || tx_suspended_for_break )
            rx_resume_pending = TRUE;
         else
            dte_rx_resume();
      }
   }

   LEAVE_CRITICAL_SECTION


   return(rxchar);
}

/************************************************************************
/
/            dte_to_free
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine returns the available space in the DTE
/                  transmit buffer
/
/   Input Parameters: None
/
/   Output Parameters: uword space-in-buffer
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
uword dte_to_free(void)
{
   uword temp;

    if (dte_mode == ACU)
    {
        acu_tx_int();
    }
    else
    {
        dte_tx_int();
    }

   ENTER_CRITICAL_SECTION


   if ((dte_mode == ACU) && acu_installed && pp_enabled)
   {
      temp = pp_to_free() & 0x00ff;
   }
   else
      temp = DTE_BUFFER_SIZE - dte_tx_count;

   LEAVE_CRITICAL_SECTION


   return(temp);
}

/************************************************************************
/
/            dte_to_char
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine buffers a character to go to the DTE
/
/   Input Parameters: ubyte ch
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_to_char(ubyte ch)
{
   dte_check_hardware_flow();

   if ((dte_mode == ACU) && acu_installed && pp_enabled)
      pp_to_char(ch);
   else
   {
       ENTER_CRITICAL_SECTION

       dte_tx_buffer[dte_tx_insert++] = ch;
       dte_tx_insert &= BUFFER_POINTER_MASK;
       dte_tx_count++;
       LEAVE_CRITICAL_SECTION


      /* As long as we aren't suspended, keep Xmtr alive */
      if( !(dte_tx_suspended_by_terminal || tx_suspended_for_break) )
       {
           dte_tx_interrupt_expected = TRUE;

           if (dte_mode == ACU)
            {
                acu_tx_int();
            }
            else
            {
                dte_tx_int();
            }
       }
   }
}
/******************************************************************************
/
/       Routine: dte_check_hardware_flow
/
/       Author: RSA
/
/       Creation Date:  June 28, 1996
/
/       Description:    Check this status of hardware flow control. Will
/                       call suspend/resume as needed.
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed:
/
/       Users:  dte_tx_int, dte_to_char
/
/       *************************************************************
/       *                       Modifications                       *
/       *************************************************************
/
/       Author & Date:  RSA
/       Description:
/
******************************************************************************/

void dte_check_hardware_flow(void)
{
   /* If we are using RTS/CTS flow control */

    if(dte_to_modem_flow_cntl & RTS_AND_CTS )
    {

       /* If Host has dropped RTS, then we are flowed OFF */

        if( !PCterminal_rts_status())
        {
            if(!dte_tx_suspended_by_terminal)
                    dte_tx_suspend();
        }

       /* If Host has Raised RTS, then we are flowed ON */
        else
        {
            if(dte_tx_suspended_by_terminal)
                    dte_tx_resume();
        }
   }
}

/************************************************************************
/
/   Procedure:    dte_to_num
/
/   Author :    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine returns the # of characters waiting to
/         be transmitted to the terminal, used by the modem code
/         to do an orderly take-over of the dte during AT command
/          processing.  If there is a char in the process of being
/          transmitted, then the character count is incremented by
/         1.
/
/   Input Parameters: None
/
/   Output Parameters: uword
/
/   Global Variables Changed: None
/
/   Users:
/
/   -------------------------------------------------------------
/   -         Modifications             -
/   -------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
ubyte dte_to_num(void)
{
   uword temp;

    if (dte_mode == ACU) /* Avoid endless loops */
    {
        acu_tx_int();
    }
    else
    {
        dte_tx_int();
    }

   ENTER_CRITICAL_SECTION

   if ((dte_mode == ACU) && acu_installed && pp_enabled)
   {
      temp = pp_to_num() & 0x00ff;
   }
   else
   {
      temp = dte_tx_count;
   }

   LEAVE_CRITICAL_SECTION

   return((ubyte)temp);

}

/************************************************************************
/
/            dte_rx_resume
/
/   Author: RSA (drc)
/
/   Creation Date:   12/16/94
/
/   Description:   This routine will resume receive operations
/
/   Input Parameters: None
/
/   Output Parameters: (ubyte)
/                      TRUE = char sent
/                      FALSE = no char sent
/
/   Global Variables Changed: rx_suspended, rx_resume_pending
/
/   Users:   dte_from_clear, dte_from_char, dte_tx_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte dte_rx_resume(void)
{
   if (modem_to_dte_flow_cntl & RTS_AND_CTS)
   {
      /* No longer suspended */
      rx_suspended = FALSE;
      rx_resume_pending = FALSE;
      dte_cts_on();      /* assert clear to send */
   }

   if (modem_to_dte_flow_cntl & XON_AND_XOFF )
   {
       rx_suspended = TRUE;
       rx_resume_pending = TRUE;
       dte_tx_interrupt_expected = FALSE;
       terminal_tx_enable();

   }
   return(FALSE);
}

/************************************************************************
/
/            dte_rx_suspend
/
/   Author: RSA (drc)
/
/   Creation Date:   12/16/94
/
/   Description:   This routine will suspend receive operations
/
/   Input Parameters: None
/
/   Output Parameters: (ubyte)
/                      TRUE = char sent
/                      FALSE = no char sent
/
/   Global Variables Changed: rx_suspended, rx_resume_pending
/
/   Users:   dte_rx_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte dte_rx_suspend(void)
{
   if (modem_to_dte_flow_cntl & RTS_AND_CTS)
   {
      rx_suspended = TRUE;
      rx_suspend_pending = FALSE;
      dte_cts_off();     /* negate clear to send */
   }

   if (modem_to_dte_flow_cntl & XON_AND_XOFF)
   {
        rx_suspended = TRUE;
        rx_suspend_pending = TRUE;
        dte_tx_interrupt_expected = TRUE;
        terminal_tx_enable();
   }

   return(FALSE);
}

/************************************************************************
/
/            dte_timer
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/13/94
/
/   Description:   Called every 10ms by the control code, this routine
/                  processes the DTE IO timers and maintains break and
/                    escape sequence mechanisms
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_timer (void)
{
   dte_20_mSec_timer--;

/*   Break Timing   */


   if ( dte_tx_break_state == TX_BREAK_STATE_TIMING )
   {
      dte_tx_break_count--;
      if ( dte_tx_break_count == 0 )
         dte_finish_tx_break();
   }


   if ( dte_rx_break_running == TRUE )
      if ( dte_rx_break_timer < 0xff )
         dte_rx_break_timer++;


/*   Escape Timing   */
   if (dte_20_mSec_timer == 0)
   {
      dte_20_mSec_timer = 2;

      /* If timer already 0 do nothing */
      if (dte_guard_time != 0)
      {
         dte_guard_time-- ;
         if ( dte_guard_time == 0 )
         {
            if ( dte_lead_guard == FALSE )
               dte_lead_guard = TRUE;
            else
            {
            if (dte_tesc_count == 3 )
               {
                  dte_tesc_count = 0;
                  dte_lead_guard = FALSE;
                  dte_guard_time = esc_guard_time;
                  system_rcv_escape();
               }
            }
         }
      }
   }
}

/******************************************************************************
/
/       Routine: dte_to_break
/
/       Author: RSA
/
/       Creation Date:  September 16, 1992
/
/       Description:    This routine will send a break to the terminal with
/                       buffering if required
/
/       Input Parameters: (ubyte) Break type
/                               0 = ignore
/                               1 = expedited/destructive
/                               2 = expedited/nondestructive
/                               3 = nonexpedited/nondestructive
/
/                         (ubyte) Break length in 10 mSec increments
/                               0 value indicates usage of default break length
/
/       Output Parameters: None
/
/       Global Variables Changed:  dte_tx_break_psn, dte_tx_break_count,
/                                       dte_tx_break_state
/
/       Users:  receive_background, mnp_bg, lapm_bg, deliver_break
/
/       *************************************************************
/       *                       Modifications                       *
/       *************************************************************
/
/       Author & Date:  RSA
/       Description:
/
******************************************************************************/
void dte_to_break(ubyte break_type, ubyte break_length)
{
  /*  If already in break condition, exit */
     if ( tx_suspended_for_break )
          return;

  /*  Set break duration */
  if ( break_length /* >0 */ )
      dte_tx_break_count = break_length;
     else
          dte_tx_break_count = BREAK_TIME;

  /*  Set break type */
     switch ( break_type ) {

          case EXPEDITED_DESTRUCTIVE :
        /*  Reset the buffer mechanisms */
               dte_tx_remove = 0;
               dte_tx_insert = 0;
               dte_tx_count = 0;
               dte_rx_remove = 0;
               dte_rx_insert = 0;
               dte_rx_count = 0;

        /*  Reset escape detection variables  */
               dte_tesc_count = 0;
               dte_lead_guard = FALSE;
               dte_guard_time = esc_guard_time;
               dte_20_mSec_timer = 2;

        /*  Just 0 buffers, if XOFF'ed release pending data */
               if ( rx_suspended )
                 {
                   if ( dte_tx_interrupt_expected )
                         rx_resume_pending = TRUE;
                   else
                         dte_rx_resume();
               }

        /*  If the fifo is busy, buffer the break */
               if ( dte_tx_interrupt_expected )
               {
                      dte_tx_break_psn = 0;
                    dte_tx_break_state = TX_BREAK_STATE_PSN;
               }
               else  /* Else initiate the break now */
               {
                    dte_start_tx_break();
               }

         break;


        case EXPEDITED_NONDESTRUCTIVE:

        /*  If the fifo is busy, buffer the break */
               if ( dte_tx_interrupt_expected )
                 {
          /*  Save position & update state */
                 dte_tx_break_psn = dte_tx_remove;
               dte_tx_break_state = TX_BREAK_STATE_PSN;
               }
               else  /* Else initiate the break now */
               {
                   dte_start_tx_break();
               }

             break;

      case NONEXPEDITED_NONDESTRUCTIVE:
    default:

        /* If we shouldn't send the break now, buffer it */
               if ( dte_tx_count || dte_tx_suspended_by_terminal
                    || dte_tx_interrupt_expected )
               {
           /*  Save pos. in stream  & update state */
                    dte_tx_break_psn = dte_tx_insert;
                    dte_tx_break_state = TX_BREAK_STATE_PSN;
               }
           else  /* else send it now */
               {
                    dte_start_tx_break();
               }

                break;


    case IGNORE:

                break;

     } /* switch */

} /* procedure */



/******************************************************************************
/
/       Routine: dte_start_tx_break
/
/       Author: RSA
/
/       Creation Date:  September 16, 1992
/
/       Description:    This routine will start the break sequence to the
/                       terminal
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed:  dte_tx_break_state
/
/       Users:  dte_tx_resume
/
/       *************************************************************
/       *                       Modifications                       *
/       *************************************************************
/
/       Author & Date:  RSA
/       Description:
/
******************************************************************************/
void dte_start_tx_break(void)
{

    tx_suspended_for_break = TRUE ;

    /*  Update break state machine */

    dte_tx_break_state = TX_BREAK_STATE_TIMING;

    /* If in bypass mode, set UART's line control to indicate break condition */

    PCterminal_to_break();

}



/******************************************************************************
/
/       Routine: dte_finish_tx_break
/
/       Author: RSA
/
/       Creation Date:  September 16, 1992
/
/       Description:    This routine will end the break sequence to the terminal
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed:  tx_suspended_for_break
/                                  dte_tx_interrupt_expected
/
/       Users:  dte_timer
/
/       *************************************************************
/       *                       Modifications                       *
/       *************************************************************
/
/       Author & Date:  RSA
/       Description:
/
******************************************************************************/
void dte_finish_tx_break(void)
{


  /*  Update break state machine */
    dte_tx_break_state = TX_BREAK_STATE_IDLE;
    tx_suspended_for_break = FALSE ;

    /* if bypass mode clear UART break condition */
    PCterminal_to_break_end();


  /*       If we have an XOFF to send pending, send it now */
     if ( rx_suspend_pending )
          dte_rx_suspend();

  /*       If we have an XON to send pending, send it now */
     if ( rx_resume_pending )
          dte_rx_resume();

  /*  Release any data for the terminal if not XOFF'ed */
     if ( ! dte_tx_suspended_by_terminal )
          dte_tx_resume();



}


/************************************************************************
/
/            dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/13/94
/
/   Description:   This routine initializes the DTE IO code
/
/   Input Parameters: ubyte baud_rate
/                     ubyte data bits
/                     ubyte stop bits
/                     ubyte parity
/                     ubyte dte_to_modem flow control
/                     ubyte dte_to_modem xon char
/                     ubyte dte_to_modem xoff char
/                     ubyte modem_to_dte flow control
/                     ubyte modem_to_dte xon char
/                     ubyte modem_to_dte xoff char
/                     ubyte pass_through_flow_control
/                     ubyte escape_char
/                     ubyte escape_guard_time
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_init( ubyte in_baud_rate,
      ubyte in_data_bits,
      ubyte in_stop_bits,
      ubyte in_parity,
      ubyte in_term_to_modem_flow_cntl,
      ubyte in_term_to_modem_xon,
      ubyte in_term_to_modem_xoff,
      ubyte in_modem_to_term_flow_cntl,
      ubyte in_modem_to_term_xon,
      ubyte in_modem_to_term_xoff,
      ubyte in_pass_through_flow_cntl,
      ubyte in_esc_char,
      ubyte in_esc_guard_time,
      ubyte escape_mode)
{
   ubyte temp;

   ENTER_CRITICAL_SECTION

/* initialize DTE parameters */
   dte_mode = DTE;

   dte_guard_time = esc_guard_time = in_esc_guard_time;
   temp = escape_mode;
   esc_chr = in_esc_char;
   dte_20_mSec_timer = 2;
   dte_tesc_count = 0;
   dte_lead_guard = FALSE;
   flow_cntl_pass = in_pass_through_flow_cntl;

   dte_rx_break_running = FALSE;
   rx_suspend_pending = FALSE;
   rx_resume_pending = FALSE;
   rx_suspended = FALSE;

   dte_tx_suspended_by_terminal= FALSE;
   tx_suspended_for_break = FALSE;
   dte_tx_interrupt_expected = FALSE;
   dte_tx_break_state = TX_BREAK_STATE_IDLE;

   dte_port_init();

/*    Set flow control variables    */
   modem_to_dte_xoff_char = in_modem_to_term_xoff;
   modem_to_dte_xon_char = in_modem_to_term_xon;
   modem_to_dte_flow_cntl = in_modem_to_term_flow_cntl;

   dte_to_modem_xoff_char = in_term_to_modem_xoff;
   dte_to_modem_xon_char = in_term_to_modem_xon;
   dte_to_modem_flow_cntl = in_term_to_modem_flow_cntl;

   LEAVE_CRITICAL_SECTION

   if (dte_to_modem_flow_cntl & RTS_AND_CTS)
      if(!PCterminal_rts_status())
         dte_tx_suspend();

}

/************************************************************************
/
/            dte_port_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/19/94
/
/   Description:   This routine resets the DTE port buffer mechanisms
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_port_init(void)
{
   dte_rx_remove = 0;
   dte_rx_insert = 0;
   dte_rx_count = 0;
   dte_tx_remove = 0;
   dte_tx_insert = 0;
   dte_tx_count = 0;
}

/************************************************************************
/
/            dte_from_block_num
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description:  Called to request the number of characters in the DTE
/            receive buffer from the last character removed to the end
/            of the buffer.
/
/   Input Parameters:  NONE
/
/   Output Parameters: uword - Number of characters in the DTE rx buffer
/
/   Global Variables Changed: NONE
/
/   Users: LAPM_BTLZ_balance, LAPM_BTEncode_driver
/
/   ************************************************************
/   *         Modifications                                    *
/   ************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
uword dte_from_block_num(void)
{
   uword temp;

   ENTER_CRITICAL_SECTION

   if (dte_mode != ACU)
   {
      /* test for non-wraparound case */
      if (dte_rx_remove > dte_rx_insert)
      {
         temp = DTE_BUFFER_SIZE - dte_rx_remove;
      }
      else
         temp = dte_rx_insert - dte_rx_remove;
   }
   else
      temp = 0;

   LEAVE_CRITICAL_SECTION

   return(temp);
}

/************************************************************************
/
/            dte_from_block_update
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to indicate to the DTE code the number of
/           of characters removed from the receive buffer.
/
/   Input Parameters: word - The number of chars removed from the rx buffer
/
/   Output Parameters: NONE
/
/   Global Variables Changed: DTE_RX_REMOVE, DTE_TOTAL_RX, DTE_RX_BUFF_CNT,
/              DTE_CB
/
/   Users: LAPM_BTEncode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_from_block_update(uword num)
{
   ENTER_CRITICAL_SECTION

   if (num)
   {
      dte_rx_remove = dte_rx_remove + num;
      dte_rx_remove &= BUFFER_POINTER_MASK;
      dte_rx_count = dte_rx_count - num;

      /* check to see if we should flow the DTE on */
      if ((rx_suspended) && (dte_rx_count < DTE_NEAR_EMPTY))
      {
         if (dte_tx_interrupt_expected)
            rx_resume_pending = TRUE;
         else
            dte_rx_resume();
      }
   }
   LEAVE_CRITICAL_SECTION
}

/************************************************************************
/
/            dte_from_block_pointer
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to get a pointer to the next available character
/           in the DTE receive buffer
/
/   Input Parameters:  NONE
/
/   Output Parameters: ubyte * - The pointer to the next available character
/
/   Global Variables Changed: NONE
/
/   Users: LAPM_BTEncode_driver
/
/   ************************************************************
/   *         Modifications                                    *
/   ************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte *dte_from_block_pointer(void)
{
   ubyte *ptr;
   ENTER_CRITICAL_SECTION
   ptr = ((ubyte *)(&dte_rx_buffer)) + dte_rx_remove;
   LEAVE_CRITICAL_SECTION
   return(ptr);
}

/************************************************************************
/
/            dte_to_block_free
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to request the number of characters the DTE
/           transmit buffer can accept before the buffer is full
/
/   Input Parameters:  NONE
/
/   Output Parameters: uword - space available in buffer
/
/   Global Variables Changed: NONE
/
/   Users: LAPM_BTDecode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
uword dte_to_block_free(void)
{
   uword temp;

   if (dte_mode != ACU)
   {
      dte_tx_int();

      /* Start Change 2/23/1995. */
      /* test for non-wraparound case */

      ENTER_CRITICAL_SECTION

      if (dte_tx_insert >= dte_tx_remove)
      {
         temp = DTE_BUFFER_SIZE - dte_tx_insert;
      }
      else
         temp = dte_tx_remove - dte_tx_insert;

      LEAVE_CRITICAL_SECTION

/* End Change 2/23/1995. */
   }
   else
      temp = 0;

   return(temp);
}

/************************************************************************
/
/            dte_to_block_update
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to indicate to the DTE code the number of
/           characters added to the transmit buffer
/
/   Input Parameters: word - Number of characters added to tx buffer
/
/   Output Parameters: NONE
/
/   Global Variables Changed: DTE_TX_INSERT, DTE_TX_COUNT, DTE_NTF,
/              DTE_TX_BUFFER
/
/   Users: LAPM_BTDecode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_to_block_update(uword num)
{
   if (num)
   {
      ENTER_CRITICAL_SECTION

      dte_tx_insert = dte_tx_insert + num;
      dte_tx_insert &= BUFFER_POINTER_MASK;
      dte_tx_count = dte_tx_count + num;
      dte_tx_interrupt_expected = TRUE;

      LEAVE_CRITICAL_SECTION
   }
}

/************************************************************************
/
/            dte_to_block_pointer
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to get a pointer to the next available free
/           space in the DTE transmit buffer
/
/   Input Parameters:  NONE
/
/   Output Parameters: ubyte * - Pointer to the next available space.
/
/   Global Variables Changed: EXEC_DTE_BLOCK
/
/   Users: LAPM_BTDecode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte *dte_to_block_pointer(void)
{
   ubyte *ptr;
   ENTER_CRITICAL_SECTION
   ptr = (ubyte *)(&dte_tx_buffer) + dte_tx_insert;
   LEAVE_CRITICAL_SECTION
   return(ptr);
}

/************************************************************************
 *                    FAX SPECIFIC DTE I/O ROUTINES                     *
 ************************************************************************/

/************************************************************************
/
/            fax_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will initialize the DTE fax code
/
/   Input Parameters:
/         ubyte - Baud Rate
/             0 = Reserved
/             1 = Reserved
/             2 = Reserved
/             3 = Reserved
/             4 = Reserved
/             5 = Reserved
/             6 = Reserved
/             7 = Reserved
/             8 = Reserved
/             9 = Reserved
/            10 = Reserved
/            11 = 19200
/            12 = 38400
/
/         ubyte - Terminal to modem flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/         ubyte - Modem to terminal flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
*************************************************************************/
void fax_dte_init( ubyte in_baud_rate,
         ubyte in_dte_to_modem_flow_cntl,
         ubyte in_modem_to_dte_flow_cntl )
{
   ENTER_CRITICAL_SECTION
   dte_mode = FAX;
   common_dte_init(in_baud_rate, in_dte_to_modem_flow_cntl, in_modem_to_dte_flow_cntl);
   pp_control(ON);
   LEAVE_CRITICAL_SECTION
}

/******************************************************************************
/
/            fax_dte_reset
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will halt the fax DTE code to allow take-
/         over by the ACU for command line processing
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  dte_mode
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
******************************************************************************/
void fax_dte_reset(void)
{
   ENTER_CRITICAL_SECTION
   dte_mode = ACU;
   pp_control(OFF);
/* should we call dte_port_init()? */
   LEAVE_CRITICAL_SECTION
}

/******************************************************************************
/
/            vcv_dte_reset
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will halt the vcv DTE code to allow take-
/         over by the ACU for command line processing
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  dte_mode
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
******************************************************************************/
void vcv_dte_reset(void)
{

   ENTER_CRITICAL_SECTION
   dte_mode = ACU;
   LEAVE_CRITICAL_SECTION
}

/************************************************************************
/
/            vcv_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will initialize the DTE vcv code
/
/   Input Parameters:
/         ubyte - Baud Rate
/             0 = Reserved
/             1 = Reserved
/             2 = Reserved
/             3 = Reserved
/             4 = Reserved
/             5 = Reserved
/             6 = Reserved
/             7 = Reserved
/             8 = Reserved
/             9 = Reserved
/            10 = Reserved
/            11 = 19200
/            12 = 38400
/
/         ubyte - Terminal to modem flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/         ubyte - Modem to terminal flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
*************************************************************************/
void vcv_dte_init( ubyte in_baud_rate,
         ubyte in_dte_to_modem_flow_cntl,
         ubyte in_modem_to_dte_flow_cntl )
{
   ENTER_CRITICAL_SECTION
   dte_mode = FAX;
   common_dte_init(in_baud_rate, in_dte_to_modem_flow_cntl, in_modem_to_dte_flow_cntl);

   /* Set dte baud rate */
   acu_set_tx_baud(in_baud_rate);
   LEAVE_CRITICAL_SECTION
}

/************************************************************************
/
/            fax_dte_info
/
/   Author:    RSA (drc)
/
/   Creation Date: 12/23/94
/
/   Description:   This routine will setup a table with info on the DTE
/                  buffer for fax mode.
/
/   Input Parameters: (uword *) tx buffer size
/                     (uword *) tx buffer count
/                     (uword *) rx buffer size
/                     (uword *) rx buffer count
/
/   Output Parameters: None
/
/   Global Variables Changed: None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void fax_dte_info(uword *tx_buffer_size, uword *tx_buffer_count,
uword *rx_buffer_size, uword *rx_buffer_count)
{
   *tx_buffer_size = DTE_BUFFER_SIZE;
   *tx_buffer_count = dte_tx_count;
   *rx_buffer_size = DTE_BUFFER_SIZE;
   *rx_buffer_count = dte_rx_count;
}


/************************************************************************
/
/            voice_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/23/94
/
/   Description:   This routine will initialize the DTE code for voice
/
/   Input Parameters:
/         ubyte - Baud Rate
/            0 = 300
/            1 = 1200
/            2 = 2400
/            3 = 4800
/            4 = 7200
/            5 = 9600
/            6 = 12000
/            7 = 14400
/            8 = 16800
/            9 = 19200
/           10 = 38400
/
/         ubyte - Terminal to modem flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = RTS
/             3 = Both XON/XOFF and RTS
/             5 = Transparent XON/XOFF
/
/         ubyte - Modem to terminal flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS
/             3 = Both XON/XOFF and CTS
/             5 = Transparent XON/XOFF
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
*************************************************************************/
void voice_dte_init( ubyte in_baud_rate,
         ubyte in_dte_to_modem_flow_cntl,
         ubyte in_modem_to_dte_flow_cntl )
{
   ENTER_CRITICAL_SECTION
   dte_mode = T_VOICE;
   common_dte_init(in_baud_rate, in_dte_to_modem_flow_cntl, in_modem_to_dte_flow_cntl);
   LEAVE_CRITICAL_SECTION
}

/************************************************************************
/
/            voice_dte_info
/
/   Author:    RSA (drc)
/
/   Creation Date: 12/23/94
/
/   Description:   This routine will setup a table with info on the DTE
/                  buffer for voice mode.
/
/   Input Parameters: (ubyte *) DTE buffer size
/                     (ubyte *) XOFF level
/                     (ubyte *) XON level
/
/   Output Parameters: None
/
/   Global Variables Changed: None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void voice_dte_info(ubyte *dte_buffer_size, ubyte *xoff_level,
ubyte *xon_level)
{
   *dte_buffer_size = DTE_BUFFER_SIZE;
   *xoff_level = DTE_NEAR_FULL;
   *xon_level = DTE_NEAR_EMPTY;
}

/************************************************************************
/
/            common_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/23/94
/
/   Description:  This routine will initialize the DTE code for
/                 fax or voice
/
/   Input Parameters:
/         <<<<< VOICE >>>>>                         <<<<<< FAX >>>>>>
/         ubyte - Baud Rate                         ubyte - Baud Rate
/            0 = 300                                    0 = Reserved
/            1 = 1200                                   1 = Reserved
/            2 = 2400                                   2 = Reserved
/            3 = 4800                                   3 = Reserved
/            4 = 7200                                   4 = Reserved
/            5 = 9600                                   5 = Reserved
/            6 = 12000                                  6 = Reserved
/            7 = 14400                                  7 = Reserved
/            8 = 16800                                  8 = Reserved
/            9 = 19200                                  9 = Reserved
/           10 = 38400                                 10 = Reserved
/                                                      11 = 19200
/         ubyte - Terminal to modem flow control       12 = 38400
/             0 = Disabled
/             1 = XON/XOFF                          ubyte - Terminal to modem flow control
/             2 = RTS                                   0 = Disabled
/             3 = Both XON/XOFF and RTS                 1 = XON/XOFF
/             5 = Transparent XON/XOFF                  2 = CTS/RTS
/                                                       3 = Both XON/XOFF and CTS/RTS
/         ubyte - Modem to terminal flow control
/             0 = Disabled                          ubyte - Modem to terminal flow control
/             1 = XON/XOFF                              0 = Disabled
/             2 = CTS                                   1 = XON/XOFF
/             3 = Both XON/XOFF and CTS                 2 = CTS/RTS
/             5 = Transparent XON/XOFF                  3 = Both XON/XOFF and CTS/RTS
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
*************************************************************************/
void common_dte_init(ubyte in_baud_rate, ubyte in_dte_to_modem_flow_cntl,
ubyte in_modem_to_dte_flow_cntl)
{
   /* S/W flow control chars */
   modem_to_dte_xoff_char = XOFF_CHAR;
   dte_to_modem_xoff_char = XOFF_CHAR;
   modem_to_dte_xon_char = XON_CHAR;
   dte_to_modem_xon_char = XON_CHAR;

   modem_to_dte_flow_cntl = in_modem_to_dte_flow_cntl;
   dte_to_modem_flow_cntl = in_dte_to_modem_flow_cntl;

   /* Init status vars */
   rx_suspended = FALSE;
   rx_suspend_pending = FALSE;
   rx_resume_pending = FALSE;
   dte_tx_interrupt_expected = FALSE;
   dte_tx_suspended_by_terminal= FALSE;
   tx_suspended_for_break = FALSE;

   dte_port_init();

}

/************************************************************************
/
/            dte_info
/
/   Author:    RSA (drc)
/
/   Creation Date: 12/21/94
/
/   Description:   This routine will setup a table with info on the DTE
/                  buffer for fax and voice data modes.
/
/   Input Parameters: (ubyte *) pointer to table
/
/   Output Parameters: None
/
/   Global Variables Changed: None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_info( ubyte *in_table_address )
{
   uword *word_ptr;

   word_ptr = (uword *)in_table_address;

   *word_ptr++ = DTE_BUFFER_SIZE;
   *word_ptr++ = DTE_NEAR_FULL;
   *word_ptr++ = DTE_NEAR_EMPTY;
   *word_ptr++ = dte_rx_count;
}

/******************************************************************************
/
/	Routine: dte_reconfigure
/
/	Author: RSA
/
/	Creation Date:	3/14/96
/
/	Description:	This routine will reconfigure the DTE code
/
/	Input Parameters:
/
/	Output Parameters: None
/
/	Global Variables Changed:  Flow control characters, Escape character
/
/	Users:	system_reconfigure
/
/	*************************************************************
/	*			Modifications			    *
/	*************************************************************
/
/	Author & Date:	RSA
/	Description:
/
*****************************************************************************/
void dte_reconfigure( ubyte in_baud_rate,
			ubyte in_data_bits,
			ubyte in_stop_bits,
			ubyte in_parity,
			ubyte in_term_to_modem_flow_cntl,
			ubyte in_term_to_modem_xon,
			ubyte in_term_to_modem_xoff,
			ubyte in_modem_to_term_flow_cntl,
			ubyte in_modem_to_term_xon,
			ubyte in_modem_to_term_xoff,
			ubyte in_pass_through_flow_cntl,
			ubyte in_esc_char,
			ubyte in_esc_guard_time,
			ubyte in_esc_mode)
{

	dte_guard_time = esc_guard_time = in_esc_guard_time;
	esc_chr = in_esc_char;
   dte_20_mSec_timer = 2;
   dte_tesc_count = 0;
   dte_lead_guard = FALSE;

	flow_cntl_pass = in_pass_through_flow_cntl;
	modem_to_dte_xoff_char = in_modem_to_term_xoff;
	modem_to_dte_xon_char = in_modem_to_term_xon;
	modem_to_dte_flow_cntl = in_modem_to_term_flow_cntl;

	dte_to_modem_xoff_char = in_term_to_modem_xoff;
	dte_to_modem_xon_char = in_term_to_modem_xon;
	dte_to_modem_flow_cntl = in_term_to_modem_flow_cntl;
}


void dte_falling_back_to_speed (void)
{
}

void dte_end_falling_back_to_speed (void)
{
}

void dte_reset(void)
{
}

void dte_dest_break_clear(void)
{
}

void acu_set_tx_rate(ubyte rate)
{
   rate = rate;
}

ubyte acu_get_autobaud_rate(void)
{
   return( get_autobaud_rate() );
}

/******************************************************************************
/
/   Routine: dte_enable
/
/   Author: RSA
/
/   Creation Date:  September 16, 1992
/
/   Description:    This routine will inform the dte I/O that it has control/           over the ACU/DTE port.
/               NOTE : interrupts should be disabled when calling
/           this routine
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  acu_enabled, rx_resume_pending
/
/   Users:
/
/   *************************************************************
/   *           Modifications               *
/   *************************************************************
/
/   Author & Date:  RSA
/   Description:
/
******************************************************************************/
void dte_enable(void)
{
  // CHECK THIS CODE -- NO SAMPLE WAS AVAILABLE
  acu_enabled = 0;   // Tell DTE layer that ACU layer no longer has control
                     // of transmitting and receiving data.
}

/******************************************************************************
/
/   Routine: dte_disable
/   Author: RSA
/
/   Creation Date:  September 16, 1992
/
/   Description:    This routine informs the dte I/O code that the acu is
/           taking over the SCC port and to suspend any processes.
/           NOTE:   Interrupts should be disabled before calling
/           this routine.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  acu_enabled
/
/   Users:  acu_start_clamp()
/
/   *************************************************************
/   *           Modifications               *
/   *************************************************************
/
/   Author & Date:  RSA
/   Description:
/
******************************************************************************/
void dte_disable(void)
{
  // CHECK THIS CODE -- NO SAMPLE WAS AVAILABLE
  acu_enabled = 1;   // Tell DTE layer that ACU layer should have control
                                // of transmitting and receiving data now.
}



/******************************************************************************
/
/       Routine: dte_tx_resume
/
/       Author: RSA
/
/       Creation Date:  September 16, 1992
/
/       Description:    This routine will resume transmit operations
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed:  dte_tx_suspended_by_terminal, dte_tx_remove,
/                   dte_tx_interrupt_expected, dte_tx_buffer, dte_tx_count
/
/       Users:  dte_finish_tx_break, dte_cts_int, dte_ccr_int
/
/       *************************************************************
/       *                       Modifications                       *
/       *************************************************************
/
/       Author & Date:  RSA
/       Description:
/
******************************************************************************/
void dte_tx_resume(void)
{
     dte_tx_suspended_by_terminal = FALSE;

     if ( tx_suspended_for_break )
     return;

     if ( dte_tx_break_state == TX_BREAK_STATE_PSN &&
          dte_tx_remove == dte_tx_break_psn )
     {
          dte_start_tx_break();
          return;
     }

  /* If the FIFO is busy allow the tx_int isr to resume */
     if ( dte_tx_interrupt_expected )
          return;


     dte_tx_interrupt_expected = TRUE;

} /* procedure */



/******************************************************************************
/
/       Routine: dte_tx_suspend
/
/       Author: RSA
/
/       Creation Date:  September 16, 1992
/       Creation Date:  05/27/92
/
/       Description:    This routine will suspend transmit operations
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed: dte_tx_interrupt_expected,
/                       dte_tx_suspended_by_terminal
/
/       Users:
/
/       *************************************************************
/       *                       Modifications                       *
/       *************************************************************
/
/       Author & Date:  RSA
/       Description:
/
******************************************************************************/
void dte_tx_suspend(void)
{
     dte_tx_suspended_by_terminal = TRUE;
     dte_tx_interrupt_expected = FALSE;
}

/******************************************************************************
/
/       Routine: dte_tx_int
/
/       Author: RSA
/
/       Creation Date:  September 16, 1992
/
/       Description:    Called when the SCC TX FIFO is empty, this routine will
/                       fill the FIFO with the next available data for terminal
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed:  dte_tx_interrupt_expected, dte_tx_buffer,
/                                       dte_tx_remove, dte_tx_count
/
/       Users:  rsa_main_isr()
/
/       *************************************************************
/       *                       Modifications                       *
/       *************************************************************
/
/       Author & Date:  RSA
/       Description:
/
******************************************************************************/
void dte_tx_int(void)
{

  int fifo_count;

  // Since this is really reentrant, if we are currently in the
  // process of running this code, DON'T reenter it!
  if (bTxRunning)
  {

    return;
  }
  bTxRunning = 1;

  /* Check Hardware flow control lines */
  dte_check_hardware_flow();

  /* Assume we won't send a char */
     dte_tx_interrupt_expected = FALSE;

  /*  If we're waiting on a buffered break, check if its arrived  */
  if (dte_tx_break_state == TX_BREAK_STATE_PSN &&
     dte_tx_remove == dte_tx_break_psn )
     {
          dte_start_tx_break();
     bTxRunning = 0;
          return;
     }

  /*  If we're waiting to send an XOFF, send it now */
     if ( rx_suspend_pending )
         dte_rx_suspend();

  /*  If we're waiting to send an XON, send it now */
     if ( rx_resume_pending )
          dte_rx_resume();


  /*  If there's data to send, and not suspended, send it now */
     if ( ! dte_tx_suspended_by_terminal && dte_tx_count &&
             ! tx_suspended_for_break )
     {

     /* While there's data and room in the FIF0, send it */

          fifo_count = PCterminal_to_free();

          while ( dte_tx_count && fifo_count)
          {
                PCterminal_to_char (dte_tx_buffer[dte_tx_remove]);
                dte_tx_count--;
                dte_tx_remove++;
                fifo_count--;

                if ( dte_tx_remove == DTE_BUFFER_SIZE )
                     dte_tx_remove = 0;

       /* Did we find a buffered break ? */
                if ( dte_tx_break_state == TX_BREAK_STATE_PSN )
                {
                    if (dte_tx_remove == dte_tx_break_psn )
                          break;
                }
          }

          dte_tx_interrupt_expected = TRUE;

     } /* if ! suspended_by_terminal */

  // Clear status that says we're in the DTE TX INT
  bTxRunning = 0;

}/* procedure */

void dte_to_terminal (ubyte ch)
{
   /* If H/W is on, then put char in outgoing buffer */
   if( (dte_mode == ACU) && (CONFIG_ECHO == 1) )
   {
      acu_to_char(ch);
   }

   /* Stash away for ACU or whomever */
   rx_char = ch;
   dte_rx_int();


}

/************************************************************************
/
/            dte_rx_int
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will confirm the reception of a data
/         buffer from the terminal
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  ACU_RX_COUNT, ACU_RX_INSERT, ACU_RX_BUFFER
/
/   Users:   None
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/

void dte_rx_int(void)
{
  // if ((dte_mode == ACU) && acu_installed && pp_enabled)
  //    if(!(dte_pp_rx_int()));

   if (dte_mode == DTE)
   {
      /* Check for escape characters */
      if ( rx_char == esc_chr )
      {
         /* Increment the no. of escape chars rx'ed by one */
         dte_tesc_count++;

         /* Switch on the no. of escape chars rx'ed so far */
         switch ( dte_tesc_count )
         {
            case 1 : /* one escape char received */
               if(dte_lead_guard == 0)
                  dte_tesc_count = 0;
               break;

            case 2 : /* two or three escapes received */
            case 3 :
               if( dte_guard_time == 0)
               {
                  dte_lead_guard = 0;
                  dte_tesc_count = 0;
               }
               break;

            case 4 : /* four escape chars received */
            default:
               dte_lead_guard = 0;
               dte_tesc_count = 0;
               break;

         }

         /* reload guard timer from dte_timer() variable */
         dte_guard_time = esc_guard_time;

      } /* if esc_chr */
      /* Else it's a regular char so reset the escape detection */
      else
      {
         dte_lead_guard = 0;
         dte_tesc_count = 0;
         dte_guard_time = esc_guard_time;
      }
   } /* if dte_mode == DTE */

   /* Modified the code so all modes will do flow control, regardless */
   if (dte_mode != ACU)
   {
      /* Check for flow control characters */
      if (dte_to_modem_flow_cntl & XON_AND_XOFF)
      {
         if (rx_char == dte_to_modem_xon_char)
         {
            dte_tx_resume();
            if (flow_cntl_pass == FALSE)
               goto DO_NOT_BUFFER;
         }
         else if (rx_char == dte_to_modem_xoff_char)
         {
            dte_tx_suspend();
            if (flow_cntl_pass == FALSE)
               goto DO_NOT_BUFFER;
         }
      }
   } /* !ACU */


   /*
       Save character in buffer if there is room. Some of you
       may wonder why the "-2", well heres the scoop. If we have
       a BUFF_SIZE == 10 and rx_count == 9, then rx_insert == 10
       or 0 when wrapped back to the beginning of the buffer. Now
       suppose that no data has been removed, thus rx_remove == 0.

       Heres the killer, the dte_BLOCK interface (compressed connection)
       wants to know how data we have. We can't tell it the rx_count
       because its not smart enough to wrap around the buffer, so we tell
       it a small lie IF the rx_remove > rx_insert. We tell it the
       amount of data left until the EOB. Then the next time it asks
       (rx_remove == SOB), we then tell it (rx_insert - rx_remove) is
       available.

       Remember that if we let the buffer fill, then rx_insert = rx_remove = 0,
       thus we can't distinguish between a FULL or EMPTY buffer. So by only
       allowing BUFF_SIZE - 2, chars then rx_insert == BUFF_SIZE - 1, or in
       our senario == 9 not 0!!

       And now you know the real story!!
   */

   if( dte_rx_count < (DTE_BUFFER_SIZE - 2) )
   {
       dte_rx_buffer[dte_rx_insert++] = rx_char;
       dte_rx_insert &= BUFFER_POINTER_MASK;
       dte_rx_count++;
   }

   if (dte_mode != ACU)
   {
      /* If buffer's near full and flow cntl is active... */
      if (dte_rx_count==DTE_NEAR_FULL )
      {
         if (!rx_suspended)
         {
            if (modem_to_dte_flow_cntl & XON_XOFF)          /* software flow control */
            {
               if (dte_tx_interrupt_expected || tx_suspended_for_break)
                  rx_suspend_pending = TRUE;
               else
                  dte_rx_suspend();
            }
            else
               dte_rx_suspend();
         }
      }
   }

DO_NOT_BUFFER:
   rx_char = 0;
}

/************************************************************************
/
/            fax_dte_flowed_on
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description: Indicate the DTE was flowed off and then on
/
/   Input Parameters: NONE
/
/   Output Parameters: FALSE
/
/   Global Variables Changed: None
/
/   Users:
/
/   ----------------------------
/   -   Modificatons      -
/   ----------------------------
/
/   Author & Date:
/   Descrition:
/   Reason:
/
*************************************************************************/
ubyte fax_dte_flowed_on(void)
{
   return(0);
}


