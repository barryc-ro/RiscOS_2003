/******************************************************************************
/
/     Copyright, 1988, 1989, 1990, 1991, 1992, 1993, 1994. All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/     This document contains material confidential to R. Scott Associates.
/     its contents must not be revealed, used or disclosed to anyone or
/     company with out written permission by R. Scott Associates.  the
/     information contained herein is solely for the use of R. Scott
/     Associates.
/
/
/   Function:  This module is the front end to the RSA Core code
/              running on a PC in a DOS environment,
/              this version was developed on an 486/66 with an 8250
/              serial adapter. Dos 6.02 was used, Microsoft VC++ 1.5
/              memory model = large
/              compile options /al /gs
/
/     Product:    BluPrint
/
/       ------------------------------------------------------
/       -        Modifications               -
/       ------------------------------------------------------
/
/   $Logfile: /core4.2/drivers/dte/16550_em/TERMINAL.C $
/   $Date$
/   $Revision$
/   $Workfile: TERMINAL.C $
/   $Author$
/
/   Revision History
/   2.9  RPT   Break Handling (Track #106)
/   2.8  RPT   Bypass Flow control fixes for DSR,CTS
/   2.7  RPT   Bypass DTR support (Track #86), parameter initialization fixes,
/              prevent lockup in modem_init(), fixed -f switch
/
******************************************************************************/


/* include files */

#include <stdio.h>
#include <ctype.h>
#include <dos.h>
#include <bios.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>

#include "sys_def.h"
#include "dteedf.h"     /* DTE external variable definitions */
#include "dte.edf"
#include "serialio.h"
#include "tracemac.h"

#include "mt_codef.h"
#include "mt_coext.h"
#include "mt_copro.h"
#include "dsp_drv.h"
#include "icd_msgs.h"
#include "dosapp.h"


/* Constants */
#define TRUE 1
#define FALSE 0
#define EOS '\0'

/* definitions for the 8259 programmable interrupt controller */

#define P8259_0 0x20   /* interrupt control register */
#define P8259_1 0x21   /* interrupt mask register */
#define END_OF_INT 0x20  /* non-specific eof of interrupt */

#define P8253_MODE   0x43 /* PIT Mode Control */
#define P8253_CNT0   0x40 /* PIT Counter 0 */

#define NO_TRACE     0x00  /* Command Tracing Disabled */
#define TX_TRACE     0x01  /* TX Command Tracing enabled */
#define RX_TRACE     0x02  /* RX Command Tracing enabled */
#define TXRX_TRACE   0x03  /* TX & RX Command Tracing enabled */

#define NUM_USER_MACROS 20
#define NUM_CMMD_TRACE  20

#define FLOW_COUNT    250


/* Macros */
#define CONTROL(x) (x-0x40)
#define ESC_KEY   CONTROL('[')


/* Structure declarations */
struct cmd_rec
    {
    int indx;
    int nSource;                  /* Source or direction of transfer */
    unsigned char data[12];
    unsigned long tstamp;
    };

struct macro_rec
    {
    int indx;
    unsigned char data[80];
    };

typedef struct cmd_rec   cmd_t;
typedef struct macro_rec macro_t;


/* Function prototypes */
int ParseCommandLine ( int argc, char *argv[]);
void s_sendchar(int);
int s_rcvchar(unsigned char*);
int DSPSetup(int DSP_Interrupt);
int DSPRestore(void);
void reprogram_pit(unsigned int count);

void _interrupt _far DSP_IntHandler(void);
void _interrupt _far PIT_IntHandler(void);
void (_interrupt _far *old_DSPhandler)(void);
void (_interrupt _far *old_PIThandler)(void);
void serialbypass (void);
void simulateTerminal (void);
int process_control_key(unsigned char ch);
void display_cmmd_trace (void);
void display_dte_buffer(int bfrFlag);
void display_macros (void);
void load_macros_from_disk(void);
void execute_macro(int indx);
void load_data_from_disk(void);
void sendTestData(void);
void displayStats(void);
int storeScreen(void);
char *GetTraceMode(void);
void EnableCommPortAddrDecoding(void);
void ResetDSP(void);

void cursor(int row, int col);
void setup_flow_control_display (void);
void show_flow_control (void);
void clearscreen(void);
void init_trace (void);
void menu(void);
void prevent_pc_lockup (void);
void send_test_pkt (void);
void dte_to_string (char *string);
void restore_screen_attrib(void);

/* External function prototypes */
extern void set_register(uword addr, ubyte data);
extern void dspdrv_CommRamISR(void);
extern void dte_to_char(ubyte out_char);
extern void dte_to_terminal (ubyte ch);
extern int SendCommChar(unsigned char);
extern int ReceiveCommChar(unsigned char *);
extern int PCSerialInit(int port_number, unsigned long baud_rate);
extern int CommRestore(void);
extern void acu_timer(void);
extern void softFlowControl (int cntrl);
extern int received_xoff(void);
extern int PCterminal_rts_status(void);

extern int PCterminal_to_free(void);
extern void terminal_tx_enable(void);
extern void InitPktDescriptors(void);
extern void line_int(void);
extern void dspdrv_SetCramISRCallBack(void (*callback)(void) );
extern void ACU_Main(void);
extern void master_init (void);
extern void dspdrv_clear_dsp_interrupt (void);
extern void dspdrv_reset_dsp (void);

extern void PCterminal_cts_on(void);
extern void PCterminal_cts_off(void);
extern void PCterminal_dsr_on(void);
extern void PCterminal_dsr_off(void);

/* Global variables */
union REGS regs;                   /* Register variables */
ubyte   dsp_polled = TRUE;         /* default to poll  */
int     DSP_IRQ = 0;               /* IRQ 3/4 for Cutlass EEB*/
int     DSPint_number;                 /* DSP Interrupt data */
int     DSPint_enable_mask;
int     DSPint_disable_mask;
int     PITint_number = 8;             /* Programable Interval Timer */
int     PITint_enable_mask  = 0xfe;
int     PITint_disable_mask = 0x01;
unsigned char sumode = 1;          /* Tell modem to use PSTN mode -- needed for modem task */

unsigned long DSP_int_cnt=0;
unsigned long PIT_int_cnt=0;
unsigned long main_loop =0;
int TraceEnabled = TXRX_TRACE;
int BypassEnabled=FALSE;
int nCommPort = 2;                          /* Serial Bypass Com port where, 2 = COM3 */
unsigned long BaudRate;
unsigned int  cmd_trace_enabled = FALSE;
int major_rev=2, minor_rev=10;               /* revision information */
int trace_cnt=0;
int packet_cnt = 0;
int rx_packet_cnt = 0;
int tx_packet_cnt = 0;
int DataModeContinuous = FALSE;              /* set data mode to counting */
int BeginDataSend = FALSE;

uword COMports[4] = {COM1, COM2, COM3, COM4};

cmd_t cmmd_trace [NUM_CMMD_TRACE] = {0};
macro_t macros[NUM_USER_MACROS];
char testData[80] = "The quick brown fox jumps over the lazy dog's tail.\r\n";

char show_flow = 0;
unsigned int flow_counter = 0;


/* External variables */
extern ubyte dte_baud;
extern char *PktDescr[0xff];
extern unsigned char acu_loop;
extern ubyte Cdata[MAX_PACKET_SIZE];
extern UART_STATUS uart;
extern unsigned char fatal_error_occurred;
extern ubyte CommPort;              /* Com port used by cutlass i/o interface */

/*---------------------------- Main -----------------------------------*/
/* This is the MAIN procedure for the terminal application             */
/*---------------------------------------------------------------------*/

main(int argc, char *argv[])
{
    char *polled;

    clearscreen();                       /* clear screen */
    cursor(0,0);                         /* move cursor to home position */

    prevent_pc_lockup ();

    init_trace();                        /* initialize command tracing */

    BaudRate = 19200L;
    load_macros_from_disk();             /* load macros file */
    load_data_from_disk();               /* load test data */

    InitPktDescriptors();                /* init Packet Descriptors */

    if (ParseCommandLine (argc,argv) == TRUE)   /* parse command line */
        return (-1);

    /* User may have requested a different COM port */
    EnableCommPortAddrDecoding();

    dspdrv_clear_dsp_interrupt();
    dspdrv_SetCramISRCallBack(line_int);

    if (DSPSetup(DSP_IRQ) == FALSE)             /* initialize dsp */
    {
        return (-2);
    }

    if (DSP_IRQ == 0)
        polled = "(Polled)\n\r";
    else
        polled = "\n\r";

    printf("\n---------------------------------\t\t---------\n\r");
    printf("RSA PC uController Simulation %d.%d\t\tDSP IRQ=%d %s",
         major_rev, minor_rev, DSP_IRQ,polled);

    printf("---------------------------------\t\t---------\n\r");
    printf("\n\rCutlass IO enabled on COM%d  (%x)\n\r", CommPort+1,COMports[CommPort]);

    if (BypassEnabled)
    {
        if (PCSerialInit(nCommPort,BaudRate) == FALSE)   /* initialize serial port */
        {
            return (-3);
        }
        if (!PCterminal_rts_status())                   /* check if ready to send */
        {
            printf ("\n\rWarning RTS not asserted - unable to communicate with com device !!!\n\r");
        }
    }
    else
      BaudRate = 57600L;  /* DEFAULT for Terminal mode */

    while (TRUE)
    {
        main_loop++;

        if( !acu_loop )
           master_init();

        if (!BypassEnabled)
        {
            simulateTerminal();      /* simulate a terminal */
        }
        else
        {
            serialbypass();          /* use data from com port as dte data */
        }
         /* If DSP is operating in polled mode, do so */
         if( dsp_polled )
            line_int();
    }

    return (-2);  /* should never get here */
}

/*---------------------------- DebugMsg--------------------------------*/
/* This procedure is to support debug message printing                 */
/*---------------------------------------------------------------------*/

void DebugMsg (char * sptr)
{
printf (sptr);
}


/*---------------------------- ParseCommandLine------------------------*/
/* This procedure parses the command line for switches and invalid     */
/* arguments                                                           */
/*---------------------------------------------------------------------*/

int ParseCommandLine ( int argc, char *argv[])
{
   int i;
   char ch;
   char *baudstr;

   int invalid_usage = FALSE;

    for (i=1; i<argc;i++)
    {
        if ((argv[i][0] == '-') || (argv[i][0] =='/') || (argv[i][0] =='\\'))
        {
            ch = toupper(argv[i][1]);
            switch(ch)
            {
                case 'B': /* serial Bypass enable and comport selection */


                    BypassEnabled = TRUE;
                    nCommPort = argv[i][2] - '1';  /* 0 = COM1 */

                    if ((nCommPort < 0 ) || (nCommPort > 4))
                        invalid_usage = TRUE;
                    else
                        if (argv[i][3] == ':')
                        {
                        baudstr = (char *)argv[i] + 4;
                        BaudRate = atol(baudstr);
                        if (BaudRate == 0)
                            invalid_usage = TRUE;
                        }

                    break;

                case 'C': /* Cutlass support */

                    CommPort = argv[i][2] - '1';  /* 1 = COM1 */

                    if (CommPort > 3)             /* COM4 is the max comport*/
                        invalid_usage = TRUE;
                    else if (CommPort != 2)
                    {
                        printf ("Warning: I/O address specified is not Default\n\r");
                    }

                    break;

                case 'D': /* DSP interrupt selection */


                    DSP_IRQ = argv[i][2] - '0';

                    if( DSP_IRQ != 0 )
                    {
                        if ((DSP_IRQ != 3) && (DSP_IRQ != 4))
                            invalid_usage = TRUE;
                        else
                            dsp_polled = FALSE;
                    }

                    break;


    //          case 'S':
    //               softFlowControl (TRUE);
    //
    //               break;

                case 'T':
                    printf ("Modem Command Packet Tracing Enabled on Ctrl-T \n\r");
                    cmd_trace_enabled = TRUE;
                    break;

                case 'F':
                    printf ("Flow control status will be displayed.\n\r");
                    show_flow = TRUE;
                    break;

                case '?':
                default:
                    invalid_usage = TRUE;
                    break;

            }
        }
    }

if ((show_flow) && (!BypassEnabled))
{
    printf ("\n\rHardware flow control signals are only valid in bypass mode");
    invalid_usage = TRUE;
}


    if (invalid_usage)
    {
    printf ("\n\rRSA PC Terminal Revision %d.%d\n\r",major_rev, minor_rev);
    printf ("\n\rUsage: Terminal [/B] [/D] ");
    printf ("\n\rWhere: /B[port]:[Baud] Specifies Bypass COMM Port");
    printf ("\n\rWhere: /C[1-4] Specifies Cutlass and associated COM port");
    printf ("\n\rWhere: /D[3-4] Specifies DSP IRQ used (0=Polled mode)");
    printf ("\n\rWhere: /F Specifies to display BYPASS HARDWARE SIGNALS");
    printf ("\n\rWhere: /? Help on Usage and revision information\n\r");
    printf ("\n\rI.E: /B2:19200 Specifies COM2 at 19.2kb");
    printf ("\n\rI.E: /C3 Specifies Cutlass DSP on COM3\n\r");
    printf ("\n\rI.E: /D3 Specifies DSP IRQ = 3\n\r");
    printf ("\n\rI.E: /D0 Specifies DSP is polled\n\r");
    }
    return (invalid_usage);
}

/*---------------------------- serialbypass----------------------------*/
/* This procedure is used to receive data from the com port and deliver*/
/* it to the dte layer. It will also the check the dte layer for data  */
/* which is to be transmitted to the user.                             */
/*---------------------------------------------------------------------*/

void serialbypass (void)
{

unsigned char ch;

    if ((show_flow) && ((flow_counter++ % FLOW_COUNT) == 0))
    {
      show_flow_control ();
      flow_counter = 0;
    }

    if( acu_loop == TRUE )
       ACU_Main();

  /*  If there's data to send, and not suspended, send it now */

     if ( ! dte_tx_suspended_by_terminal  && ! tx_suspended_for_break )
        if (PCterminal_to_free())      /* is there room in the txq? */
            if ((s_rcvchar(&ch)))      /* get dte char  */
                SendCommChar(ch);      /* send it */

    if (PCterminal_to_free() != TXQSIZE)  /* if data in queue send it */
            terminal_tx_enable();

    if ( kbhit() != 0)               /* allow user to break out */
    {
        ch = (unsigned char)_getch();

        if (ch == ESC_KEY)
        {
            DSPRestore();           /* restore dsp setup */
            CommRestore();          /* restore comm setup */
            restore_screen_attrib();
            exit(0);
        }
        else
        {
            process_control_key(ch); /* check for control keys ignore rest */
        }
    }
}

/*---------------------------- SimulateTerminal------------------------*/
/* This procedure will simulate a terminal's operation                 */
/*---------------------------------------------------------------------*/

void simulateTerminal (void)
{

unsigned char ch;
static int i=0;

    if ((s_rcvchar(&ch)))                   /* get ACU ECHO characters */
      _putch(ch);

    ACU_Main();

    if ( kbhit() != 0)
    {
        ch = (unsigned char)_getch();

        if (ch == ESC_KEY)                  /* terminate on escape key */
        {
            DSPRestore();
            printf("\nProgram terminating normally\n");
            restore_screen_attrib();
            exit(0);
        }
        else
        {   if (!process_control_key(ch))    /* check for control/menu keys */
                dte_to_terminal (ch);        /* send other chars to dte */
        }
    }

    if (DataModeContinuous && BeginDataSend) /* check if streaming test data */
    {
        if (i==(int)strlen(testData))
        {
            i=0;
        }

        dte_to_terminal (testData[i++]);
    }


}

/*--------------------------------------------------------
  | DSPSetup will setup the serial port on the pc.        |
  --------------------------------------------------------
*/
int DSPSetup(int DSP_Interrupt)
{
   int intmask;
   ubyte valid_dsp_irq = TRUE;

   switch (DSP_Interrupt)
   {

       case 3: /* IRQ 3 */

        DSPint_enable_mask  = 0xf7;
        DSPint_disable_mask = 0x08;
        DSPint_number = 11;
        break;


       case 4:/* IRQ4 */

        DSPint_enable_mask  = 0xef;
        DSPint_disable_mask = 0x10;
        DSPint_number = 12;
        break;


       case 5: /* IRQ 5 */
        DSPint_enable_mask  = 0xdf;
        DSPint_disable_mask = 0x20;
        DSPint_number = 13;
       break;

       case 7: /* IRQ 7 */

        DSPint_enable_mask  = 0x7f;
        DSPint_disable_mask = 0x80;
        DSPint_number = 15;
        break;

       default:
         valid_dsp_irq = FALSE;

   }

   _disable();                    /* disable interrupts */

   if( valid_dsp_irq )
   {
      old_DSPhandler = _dos_getvect(DSPint_number);
      _dos_setvect(DSPint_number,DSP_IntHandler);   /* set new int vector */
      intmask = inp(P8259_1) & DSPint_enable_mask;
      outp(P8259_1,intmask);
   }

   old_PIThandler = _dos_getvect(PITint_number);
   _dos_setvect(PITint_number,PIT_IntHandler);   /* set new int vector */

   reprogram_pit(11930);   /* reprogram to 10ms */

   _enable();                      /* enable interrupts */

   return(TRUE);

}

void _interrupt _far DSP_IntHandler(void)
{

  _enable();      /* allow higher priority interrupts */

  DSP_int_cnt++;
  dspdrv_CommRamISR();


  outp(P8259_0,END_OF_INT);   /* return if all done */
}


/* This function will handle the 8254 Timer Interrupt */
void _interrupt _far PIT_IntHandler(void)

{

    acu_timer();

    if ( (PIT_int_cnt++ % 5) == 0)
    {
        (*old_PIThandler)();/* Call Old handler based on a rate of ~54ms */
    }
    else
    {
        outp(P8259_0,END_OF_INT);   /* return if all done */
    }

}

void displayStats(void)
{
printf ("\n\rDSP Interrupts:%lx, Timer Ticks: %lx,    ",DSP_int_cnt, PIT_int_cnt);
printf ("Main Loop : %lx", main_loop);
}

int DSPRestore(void)
{
    int intmask;

    _disable();

  /* if not in polled mode then restore the original interrupt vector */

    if (DSP_IRQ != 0)
    {
        intmask = inp(P8259_1) | DSPint_disable_mask;
        outp(P8259_1,intmask);
        _dos_setvect(DSPint_number,old_DSPhandler);
    }

    /* Reset the PIT interrupt vector */

    _dos_setvect(PITint_number,old_PIThandler);

    reprogram_pit(0xffff);   /* reprogram to 54ms */

    _enable();

  return(0);

}

/*--------------------------------------------------------
  | s_sendchar                                           |
  | puts a character into transmit queue. return 1 if    |
  | successful, else 0.                                  |
  --------------------------------------------------------
*/
void s_sendchar(int ch)
{

  /*  Copy char and bump indices */

     asm mov dx,06002H
     asm mov ax, 2
     asm out dx,ax

ENTER_CRITICAL_SECTION

     dte_rx_buffer[dte_rx_insert] = ch;
     dte_rx_count++ ;
     dte_rx_insert++;

     if (dte_tx_insert == DTE_BUFFER_SIZE)
        dte_tx_insert = 0;


LEAVE_CRITICAL_SECTION

}  /* end s_sendchar */


/* This function will write the contents of the desired dte buffer to the
   screen using direct video access to avoid character loss in real-time due
   to screen I/O handling routines.
*/
void display_dte_buffer(int bfrFlag)
{
int i;
int    bfr_cnt,bfr_remove,bfr_insert;
unsigned char *bfr;
unsigned char *bfr_str;
int _far *farptr;
int col,row;
unsigned char *ch, *format,pbuffer[80];


if (bfrFlag)
    {
    bfr_cnt    = dte_tx_count;
    bfr_remove = dte_tx_remove;
    bfr_insert = dte_tx_insert;
    bfr        = dte_tx_buffer ;
    bfr_str    = "DTE TX Buffer";

    }
else
    {
    bfr_cnt    = dte_rx_count;
    bfr_remove = dte_rx_remove;
    bfr_insert = dte_rx_insert;
    bfr        = dte_rx_buffer;
    bfr_str    = "DTE RX Buffer";

    }

    clearscreen();
    cursor(0,0);

    farptr = (int _far *) 0xB8000000; /* color graphics */

    /* Display header using sprintf() and direct video access */

    sprintf (pbuffer,"%s Count=%4d Remove=%4d, Insert=%d",
            bfr_str, bfr_cnt, bfr_remove, bfr_insert);

    ch  = pbuffer;
    row = 0;

    for (col=0;col <(int)strlen(pbuffer); col++,ch++)
        *(farptr + row*80 + col) = *ch | 0x0700;


    /* Display format strings to aid in indentifing characters within the buffer  */

    format="0         10        20        30        40        50        60        70";
    ch  = format;
    row = 2;

    for (col=0;col <(int)strlen(format); col++,ch++)
        *(farptr + row*80 + col) = *ch | 0x0700;


    format="01234567890123456789012345678901234567890123456789012345678901234567890123456789";
    ch  = format;
    row = 3;

    for (col=0;col <(int)strlen(format); col++,ch++)
        *(farptr + row*80 + col) = *ch | 0x0700;

    /* Display contents for buffer */

    ch = bfr;
    for (i=0,row=5; row < 25, i<DTE_BUFFER_SIZE; row++)
        for (col=0;col < 80,i<DTE_BUFFER_SIZE ; col++,ch++,i++)
            *(farptr + row*80 + col) = *ch | 0x0700;

    cursor(20,0);

}


/*--------------------------------------------------------
  |  s_rcvchar                                           |
  | returns a character from the dte queue.              |
  | returns 0, if queue is empty                         |
  --------------------------------------------------------
*/
int s_rcvchar(unsigned char * TxChar)
{

int retval = FALSE;


ENTER_CRITICAL_SECTION

    if (dte_tx_count)
    {

    *TxChar  = (unsigned char) dte_tx_buffer[dte_tx_remove];
    dte_tx_remove++;
    dte_tx_count--;

    /* Reset buffer ptr ? */


    if ( dte_tx_remove == DTE_BUFFER_SIZE )
         dte_tx_remove = 0;


    retval = TRUE;
    }

LEAVE_CRITICAL_SECTION

return(retval);

}   /* end s_rcvchar */

void PCterminal_to_char(ubyte ch)
{
if (BypassEnabled)
    SendCommChar(ch);
else
    _putch(ch);
}

void reprogram_pit(unsigned int count)
{

/* Reprogram the PIT's Counter 0
   This will control the frequency of the Timer interrupt

   The count value is base on the 1.19318Mhz square wave which
   is divided down by the count value

   i.e a value of 65536 would yield a timer value of ~54ms

   (1/1.19318+6) = ~800ns
                    x 65536 = ~54.93ms


*/

asm {
   mov dx, P8253_MODE
   mov al, 036h
   out dx,al

   mov dx, P8253_CNT0
   mov ax, count
   out dx,al
   mov al,ah
   out dx,al
   }
}

/*---------------------------- cursor  --------------------------------*/
/* This procedure will move the cursor to the desired row,col position */
/*---------------------------------------------------------------------*/

void cursor(int row, int col)
{
  regs.h.ah = 2;             /* set cursor pos service */
  regs.h.dl =(char) col;     /* column position */
  regs.h.dh =(char) row;     /* row position */
  regs.h.bh = 0;             /* page */
  int86(0x10,&regs,&regs);       /* Call Video interrupt */

}


/*---------------------------- clear screen ------------------------*/
/* This procedure will clear the display screen             */
/*------------------------------------------------------------------*/

void clearscreen(void)
{
   int _far *farptr;
   int col,row;
   unsigned char ch;

   farptr = (int _far *) 0xB8000000; /* color graphics */
   ch = ' ';
     for (row=0; row < 25; row++)
       for (col=0;col < 80; col++)
     *(farptr + row*80 + col) = ch | 0x0700;
}

/*---------------------------- store screen ------------------------
/* This procedure will store the display screen to a disk file      */
/*------------------------------------------------------------------*/

int storeScreen(void)
{
    int _far *farptr;
    int col,row;

    FILE *filePtr;
    unsigned char line[81];
    int retval = FALSE;

    farptr = (int _far *) 0xB8000000;       /* color graphics adapter */


    filePtr = fopen ("terminal.scr", "a+"); /* open file for appending */

    if (filePtr != 0)
    {
        for (row=0; row < 25; row++)
        {
            for (col=0;col < 80; col++)
            {
                line[col] = *(farptr + row*80 + col)  & 0x00FF;
            }
            line[80] = '\n';                /* append newline character */

            fwrite( line, sizeof( char ), 81, filePtr );
        }

        fclose (filePtr);
        retval = TRUE;
    }

    return (retval);
}


/*---------------------------- Menu -----------------------------------*/
/* This procedure will bring up the operator menu. This menu will give */
/* the operator a list of all the help commands                */
/*---------------------------------------------------------------------*/

void menu(void)
{
char *test_mode = "COUNT";
char *trace_mode;

    trace_mode = GetTraceMode();

    if (DataModeContinuous == TRUE)
        test_mode = "CONTINUOUS";


    clearscreen();
    cursor(0,0);
    printf("     Terminal - Help Menu \n\n");
    printf("     <F1>      Main Menu, <Alt><F1>Debug Menu\n");
    printf("     <F2>      Display Command Packets Trace, Mode [%s]\n",trace_mode);
    printf("     <F3>      Clear Screen\n");
    printf("     <F4>      Display DTE RX Buffer\n");
    printf("     <F5>      Display DTE TX Buffer\n");
    printf("     <F6>      Reload  Macros File [terminal.cmd]\n");
    printf("     <F7>      Display Available Macros\n");
    printf("     <F8>      Reload TEST data [terminal.tst]\n");
    printf("     <F9>      Send TEST Data, Mode [%s]\n",test_mode);
    printf("     <F10>     Copy Screen to disk [terminal.scr]\n");

    printf("\n     <ESC>     Exit program\n\n");



} /* menu */

/*-------------------------Debug Menu -----------------------------------*/
/* This procedure will bring up the Debug menu. This menu will give */
/* the operator a list of all the debug commands                */
/*---------------------------------------------------------------------*/

char *GetTraceMode(void)
{
char *trace_mode;

    switch (TraceEnabled)
    {
        case NO_TRACE:
            trace_mode = "DISABLED";
            break;

        case TX_TRACE:
            trace_mode = "TX";
            break;

        case RX_TRACE:
            trace_mode = "RX";
            break;

        case TXRX_TRACE :
            trace_mode = "TX,RX";
            break;

        default:
            trace_mode = "ERROR";
            break;
    }

return (trace_mode);

}


void DebugMenu(void)
{

char *test_mode = "COUNT";
char *trace_mode;

    trace_mode = GetTraceMode();

    if (DataModeContinuous == TRUE)
        test_mode = "CONTINUOUS";

    clearscreen();
    cursor(0,0);

    printf("     Terminal - Debug Menu \n\n");
    printf("    <Alt><F1>   Debug Menu, <F1>Main Menu\n");
    printf("    <Alt><F2>   Toggle Command Packets Trace, Mode [%s]\n",trace_mode);
    printf("    <Alt><F3>   Toggle CTS\n");
    printf("    <Alt><F4>   Toggle DSR\n");
    printf("    <Alt><F9>   Toggle Test Mode [%s]\n",test_mode);
    printf("    <Alt><F5>   Clear command packet trace\n");

    printf("\n     <ESC>     Exit program\n\n");



} /* menu */


/*------------------------load_data_from_disk ----------------------*/
/* This procedure will read the test data file from disk in         */
/* into the test data buffer                                        */
/*------------------------------------------------------------------*/

void load_data_from_disk(void)
{

FILE *stream;

    if( (stream = fopen( "terminal.tst", "r" )) != NULL )
    {
        if( fgets( testData, 80, stream ) == NULL)
        {
            memset (testData, 0, sizeof (testData));
            printf ("Error reading terminal.tst \n\r");
        }

        fclose( stream );
    }

}

/*--------------------------- execute_macro ------------------------*/
/* This procedure will execute the macro by sending it to the dte   */
/* Note this is currently configured to work in terminal mode only  */
/* Addition logic is required for serial bypass mode to accept      */
/* macros, as it would have to coordinate access to the dte         */
/*------------------------------------------------------------------*/

void sendTestData(void)
{
int i;

    /* Don't allow test data to be sent in bypass mode as that would
       corrupt the data stream between the two modems by injecting characters
       at asynchronuous interval
     */

    if (BypassEnabled == TRUE)
    {
        clearscreen();
        cursor(0,0);
        printf ("\n\rTest Data cannot be sent in Bypass mode.");
        printf ("\n\rThat would corrupt the data stream between the two modems\n\r");
        return;
    }

    /* Check if continuous mode is being used if not send data immediately.
       Note where not checking if there is enough space in the dte buffer to
       store the 80 (max) characters in the testData buffer. The DTE will ignore
       the extra characters if the 512 byte dte buffer is full.
     */

    if (DataModeContinuous == FALSE)   /* Send Data if in count mode */
    {
        for (i=0; i < (int)strlen (testData); i++)
            {
            dte_to_terminal (testData[i]);
            }
        BeginDataSend = FALSE;
    }
    else
    {
        BeginDataSend = TRUE;
    }
}




/*------------------------load_macros_from_disk --------------------*/
/* This procedure will read the macros command file from disk in    */
/* into the macros command buffer                                   */
/*------------------------------------------------------------------*/

void load_macros_from_disk(void)
{

FILE *stream;
int i;

    memset (macros, 0, sizeof (macros));

    if( (stream = fopen( "terminal.cmd", "r" )) != NULL )
    {
        for (i=0; i<NUM_USER_MACROS;i++)
        {
            if( fgets( macros[i].data, 80, stream ) == NULL)
            {
                break;
            }
            else
            {
                macros[i].indx = i+1;
            }
        }
        fclose( stream );
        printf ("Macros Loaded from terminal.cmd \n\r");
    }
    else
    {
    printf ("Macro file [terminal.cmd] NOT found - No Macros Loaded!!\n\r");
    }

}

/*--------------------------- execute_macro ------------------------*/
/* This procedure will execute the macro by sending it to the dte   */
/* Note this is currently configured to work in terminal mode only  */
/* Addition logic is required for serial bypass mode to accept      */
/* macros, as it would have to coordinate access to the dte         */
/*------------------------------------------------------------------*/

void execute_macro(int indx)
{
int i;
char *str;


    if (macros[indx].indx != 0)
    {

    /* send macro characters to dte, excluding the termination character */

    for (i=0; i< (int)strlen (macros[indx].data)-1; i++)
        {
        dte_to_terminal (macros[indx].data[i]);
        }
    }
    else
    {
        if (indx+1 > 10)
        {
            str = "<ctrl>";
            indx -= 10;
        }
        else
            str = "<shift>";

        printf("Macro for %s<F%d> is undefined \n\r",str,indx+1);
    }
}

/*---------------------------- display_macros ----------------------*/
/* This procedure will display the macros which are currently       */
/* available to the user.                                           */
/*------------------------------------------------------------------*/

void display_macros (void)

{
int i,indx;
char *str;

    if (macros[0].indx == 0)
        printf ("NO Available Macros\n\r");
    else
    {
        clearscreen();                       /* clear screen */
        cursor(0,0);                         /* move cursor to home position */

        printf ("\n\rAvailable Macros\n\n");
        for (i=0; i<NUM_USER_MACROS;i++)
        {
            if (macros[i].indx != 0)
            {
                indx = macros[i].indx;
                if (macros[i].indx > 10)
                {
                    str="<ctrl>";
                    indx -= 10;
                }
                else
                    str = "<shift>";

             printf( "%s<F%d> = %s",str,indx, macros[i].data);
            }
        }
    }
}

/*--------------------------- init_trace    ------------------------*/
/* This procedure will initialize the DSP trace variables           */
/*------------------------------------------------------------------*/

void init_trace (void)
{
int i;

    trace_cnt = 0;
    packet_cnt = 0;
    tx_packet_cnt = 0;
    rx_packet_cnt = 0;

    for (i=0 ; i< NUM_CMMD_TRACE ; i++)
    {
        cmmd_trace[i].indx = i;
        memset( cmmd_trace[i].data, 0, sizeof(cmmd_trace[i].data) );
    }

}

/*---------------------------- display_cmmd_trace ------------------- */
/* This procedure will display the last N DSP packets which were sent */
/*------------------------------------------------------------------  */

void display_cmmd_trace (void)
{
int i,j;
int display_cnt;
char *direction;
char *trace_mode;

    clearscreen();
    cursor(0,0);
    trace_mode = GetTraceMode();

    printf ("Num: Dir ID   Data                                 (10ms)  Description\n\r");

    if (packet_cnt > NUM_CMMD_TRACE )
        display_cnt = NUM_CMMD_TRACE ;
    else
        display_cnt = trace_cnt;

    /* Display trace buffer in sorted order, because of the wrap around
       buffer the newest packet may be in the front of the buffer. We want
       to display the oldest packets first.
     */

    for (i=trace_cnt ; i< display_cnt; i++)
    {

        direction =  (cmmd_trace[i].nSource == TX_TRACE) ? "Tx" : "Rx";

        printf ("%4d %2s %3x  ",cmmd_trace[i].indx,direction,cmmd_trace[i].data[0]);

        for (j=0; j < 12; j++)
        {
            printf ("%3x",cmmd_trace[i].data[j]);
        }
        printf ("   %4lx   %.20s\n\r",cmmd_trace[i].tstamp,PktDescr[cmmd_trace[i].data[0]]);


    }

    for (i=0 ; i< trace_cnt; i++)
    {

        direction =  (cmmd_trace[i].nSource == TX_TRACE) ? "Tx" : "Rx";

        printf ("%4d %2s %3x  ",cmmd_trace[i].indx,direction,cmmd_trace[i].data[0]);

        for (j=0; j < 12; j++)
        {
            printf ("%3x",cmmd_trace[i].data[j]);
        }
        printf ("   %4lx   %.20s\n\r",cmmd_trace[i].tstamp,PktDescr[cmmd_trace[i].data[0]]);

    }


    cursor(22,0);

    printf ("Packets  RX=%d,  TX=%d, Command Trace/Capture Mode [%6.8s]",
                rx_packet_cnt,tx_packet_cnt,trace_mode);
    cursor(23,0);
}

/*------------------------ UpdateCommandTrace-----------------------*/
/* This procedure is the interface for the RSA code to call when    */
/* packets are sent to the DSP. See send_pkt_to_dsp()               */
/*------------------------------------------------------------------*/

void UpdateCommandTrace (void *cmmd_packet, uword source)
{
  ubyte *current_packet;

  if (source & TraceEnabled)
    {
    if (trace_cnt == NUM_CMMD_TRACE ) /* check for wrap around */
        trace_cnt = 0;

    /* Since the command trace has been added as a generic part of
       the modem task, ignore the packet pointer passed in.  Decide
       where to read the packet data based on the source - TX or RX. */
    if (source == TRACE_TRANSMIT)
      current_packet = (ubyte *) &current_command[0];    /* send_pkt_to_dsp() */
    else
      current_packet = (ubyte *) &Cdata[0];         /* data received from DSP */

    cmmd_trace[trace_cnt].indx = ++packet_cnt;
    cmmd_trace[trace_cnt].tstamp = PIT_int_cnt;
    cmmd_trace[trace_cnt].nSource = source;

    if (source == TX_TRACE)
        tx_packet_cnt++;
    else
        rx_packet_cnt++;

    memcpy ((void *)cmmd_trace[trace_cnt].data, (void *)current_packet, 12);

    trace_cnt++;
    }

}

/*--------------------------- process_control_key ------------------*/
/* This procedure will process the user function keys               */
/*------------------------------------------------------------------*/

int process_control_key(unsigned char ch)
{
int retval = FALSE; /* Assume it's not a control key */

/* Function Keys and cursor movement keys require two reads using _getch(). The
   first byte for these extended codes are 0x0 or 0xe0, the second is the
   scan code. If we called INT 16H ourselves we could avoid this as the
   codes are returned in AL:AH
 */

    if ((ch == 00) || (ch == 0xE0))  /* extended codes */
    {
        ch = (unsigned char)_getch();  /* get the scan code */
        retval = TRUE;

        switch(ch)
        {

        case 59:            /* F1 display help */
            menu();
            break;

        case 60:            /* F2 display command packets */
            display_cmmd_trace ();
            break;


        case 61:            /* F3 clear screen */
            clearscreen ();
            cursor(0,0);
            break;

        case 62:            /* F4 Display dte rx buffer */
            display_dte_buffer(0);
            break;


        case 63:            /* F5 Display dte tx buffer */
            display_dte_buffer(1);
            break;

        case 64:            /* F6 Load Macros from Disk */
            load_macros_from_disk();
            break;

        case 65:            /* F7 Display available macros */
            display_macros ();
            break;

        case 66:             /* F8  Load test data from disk */
            load_data_from_disk();
            printf ("Test Data:");
            printf ("%s\n\r",testData);
            break;

        case 67:             /* F9 Send test data to dte */
            sendTestData();
            break;


        case 68:                /* F10 */
             if (!storeScreen())
                printf("Unable to write to file ->terminal.scr");
             else
                printf("Screen data appended to file ->terminal.scr");
            break;


        case 104: /* alt-F1 */
            DebugMenu();
            break;

        case 106: /* alt-F3 Lower RTS (Remote CTS) in bypass mode*/
            if (BypassEnabled)
            {
                if (uart.cts)
                    PCterminal_cts_off();
                else
                    PCterminal_cts_on();
            }
            else
                printf ("CTS Toggle only valid in Bypass mode\n\r");
            break;


        case 107: /* alt-F4 Lower DTR (Remote DSR) in Bypass mode */
            if (BypassEnabled)
            {
                if (uart.cts)
                    PCterminal_dsr_off();
                else
                    PCterminal_dsr_on();
            }
            else
                printf ("DSR Toggle only valid in Bypass mode\n\r");
            break;

        case 109: /* alt-F6 */
        case 110: /* alt-F7 */
        case 111: /* alt-F8 */
            printf ("Alt-Function Key Not Defined F%d\n\r", ch-103);
            break;

        case 108: /* alt-F5 */
            init_trace ();
            printf ("Command packet trace cleared.\n");
            break;

        case 105: /* alt-F2 toggle Command Trace Mode */
            if (++TraceEnabled > TXRX_TRACE)
                TraceEnabled = NO_TRACE;


            break;

        case 112:            /* alt F9 toggle data mode */

            if (DataModeContinuous == TRUE)
                {
                DataModeContinuous = FALSE;
                BeginDataSend = FALSE;
                }
            else
               DataModeContinuous = TRUE;

            menu();         /* redisplay menu */

            break;

        case 113:             /* Alt-F10 */
            displayStats();
            break;


        /* 84-103 are designated for Macro executation */

        case 84:             /* Shift F1 - execute macro[0] */
        case 85:             /* Shift F2 */
        case 86:             /* Shift F3 */
        case 87:             /* Shift F4 */
        case 88:             /* Shift F5 */
        case 89:             /* Shift F6 */
        case 90:             /* Shift F7 */
        case 91:             /* Shift F8 */
        case 92:             /* Shift F9 */
        case 93:             /* Shift F10 */

        case 94:             /* Ctrl F1 */
        case 95:             /* Ctrl F2 */
        case 96:             /* Ctrl F3 */
        case 97:             /* Ctrl F4 */
        case 98:             /* Ctrl F5 */
        case 99:             /* Ctrl F6 */
        case 100:            /* Ctrl F7 */
        case 101:            /* Ctrl F8 */
        case 102:            /* Ctrl F9 */
        case 103:            /* Ctrl F10 */

            execute_macro ((int)(ch-84));
            break;


        default:
            retval = FALSE;  /* not a control key we are scanning for */
            break;

        } /* end switch */

    }

    return (retval);
}



void debugTracePoint(void)
{}

void debugTracePoint2(void)
{}



void prevent_pc_lockup (void)
{
  uword temp;
  ubyte scrap;

  printf( "Resetting DSP to use Internal Code with patches...\n");

  /* Enable APPs default COM port for now */
  EnableCommPortAddrDecoding();

  ResetDSP();
}


void show_flow_control (void)
{
    int col;
    char ch[2] = "-+";
    unsigned char *screen;
    char pbuffer[80];
    int _far *farptr;

    farptr = (int _far *) 0xB8000000; /* color graphics */

    /* Display header using sprintf() and direct video access */

    sprintf (pbuffer,"DTR%c RTS%c DSR%c CTS%c CD%c",
           ch[uart.dtr], ch[uart.rts], ch[uart.dsr], ch[uart.cts], ch[uart.rlsd]);

    screen  = pbuffer;

    for (col=0;col <(int)strlen(pbuffer); col++,screen++)
        *(farptr + 24*80 + col) = *screen | 0x0E00;


  cursor(22,0);

}

void restore_screen_attrib (void)
{
    int col;
    int _far *farptr;

    farptr = (int _far *) 0xB8000000; /* color graphics */


    for (col=0;col <80; col++)
        *(farptr + 24*80 + col) = 0x0700;

    cursor(22,0);

}

#define TEST_TIMER_INIT 100000

void send_test_pkt (void)
{
   ubyte i;
   unsigned long test_timer;

   dsp_cp_packet = PACKET_PROGRAM_MEMORY_READBACK;
   test_timer = TEST_TIMER_INIT;

   while ( --test_timer )
   {
	  if( cp_dsp() == DSP_DONE )
		 break;
   }

   /* If timeout expires, the DSP did not respond in time.  Report
      an error with the packet number. */
   if( !test_timer )
   {
      fatal_error_occurred = 1;
      printf ("  Packet write timed out!\n");
      return;
   }

   test_timer = TEST_TIMER_INIT;

   while ( --test_timer )
   {
      if( dsp_cp() == DSP_DONE )
        break;
   }

   /* If timeout expires, the DSP did not respond in time.  Report
      an error with the packet number. */
   if( !test_timer )
   {
      fatal_error_occurred = 1;
      printf ("  Packet readback timed out!\n");
      return;
   }
}

/****************************************************************************
 *
 *   Routine:           EnableCommPortAddrDecoding()
 *
 *   Author:            RSA
 *
 *   Creation Data:     11/7/1996
 *
 *   Description: The Cutlass downloader leaves the the EEB decoding
 *                on COM3. Other verions of the downloader, leave it
 *                on COM1, and we have a default set of COM2. So we
 *                need to set it ourselves!!
 *
 *   Input Parameters:  None
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/

void EnableCommPortAddrDecoding(void)
{
#ifndef BETA_BOARD

  /* Set EEB REG1 for Host based control on 'CommPort'. The
     Beta Brd doesn't have register x310, writing to it will
     cause a startup problem.
  */
  printf( "Setting port 0x310 to %x\n", (0x80|CommPort));
  outportb(0x310,(0x80 | CommPort));

#endif
}

/****************************************************************************
 *
 *   Routine:           ResetDSP()
 *
 *   Author:            RSA
 *
 *   Creation Data:     25/10/1996
 *
 *   Description: Will boot the DSP code for INTERNAL/EXTERNAL program
 *                execution.
 *
 *   Input Parameters:  None
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/

void ResetDSP(void)
{
  dspdrv_reset_dsp();
}
