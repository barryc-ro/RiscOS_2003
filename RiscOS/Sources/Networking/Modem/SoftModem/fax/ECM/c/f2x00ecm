/******************************************************************************
/
/   Copyright, 1991,1992,1993,1994,1995.
/     All Rights Reserved by:
/        RSA
/        7701 Six Forks Road
/        Suite 201
/        Raleigh, NC  27615
/        (919) 846-7171
/
/    This document contains material confidential to RSA. Its contents
/    must not be revealed, used or disclosed to anyone or company without
/    written permission by RSA. The information contained herein is solely
/    for the use of RSA.
/
/        File     : f2x00ecm.c
/
/        Module Version: 4.04
/
/        Function : Main routines implementing the T.30, Annex A ECM protocol
/                   for Class 2 and 2.0.
/
/        Product  : Class 2/2.0 ECM Submodule.
/
/        History  : 4.03
/
/        Created :
/
/            -----------------------------------------------------------
/            -                       Modifications                     -
/            -----------------------------------------------------------
/
/            Author & Date :
/            Description   :
/            Reason        :
/
******************************************************************************/
#include "sys_def.h"
#include "f2x_def.h"
#include "f2x_mem.h"
#include "f2x_ecd.h"
#include "f2x_bmd.h"
#include "f2x_ecp.h"
#include "f2x_emm.h"
#include "f2x_pro.h"

/*******************************************************************************
/
/	Routine: fax2_ECM_installed
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: Indicates if ECM module is present or not.
/
/	Input Parameters: None
/
/	Output Parameters: ECM Presence     TRUE if present
/                                           FALSE otherwise
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_ECM_installed(void)
{
    return(TRUE);
}

/*******************************************************************************
/
/	Routine: fax2_ECM_rcv_init
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: Called once per DCS reception if the receiver has
/                    realized ECM has been negotiated by the transmitter's DCS.
/
/	Input Parameters: None
/
/	Output Parameters: None
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void fax2_ECM_rcv_init(void)
{
    fax2_ECM_schedule_sub_state = ECM_CFG_RX_NEW_FAX_DOCUMENT;
    /* Assume ECM is not going to schedule a long train, receive */
    fax2_ECM_schedulelongtrain = FALSE;
}

/*******************************************************************************
/
/	Routine: fax2_phaseC_receive_ECM
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/   Description: This routine will implement the class 2/2.0 T.30 phase C
/                receive functions for ECM.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/	Description:
/
/	Input Parameters: None
/
/	Output Parameters: None
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_phaseC_receive_ECM(void)
{
    ubyte return_code;

    return_code = STAY_ONLINE;
    switch (fax2_sub_state)
    {
        /* WAIT_FOR_DC2 is really the "ECM_RX_ROUTER" */
        case WAIT_FOR_DC2:
        case ECM_RX_ROUTER:
            fax2_sub_state = fax2_ECM_schedule_sub_state;
            break;
        case ECM_CFG_RX_NEW_FAX_DOCUMENT:
            /* This substate entered once per document reception
            (i.e., CFR transmitted in phase B).  */
            /* ECM framesize should already have been determined by a call
            to fax2_accept_ECM_framesize() when DCS was received during
            phase B (i.e., bit 28 of DCS) */
            fax2_ECM_rx_configure(fax2_ECM_framesizeless1);
            fax2_ECM_pgnumless1 = 0xFF; /* pre-increments to 0 */
            fax2_sub_state = ECM_CFG_RX_NEW_FAX_PAGE;
            /* break intentionally omitted */
        case ECM_CFG_RX_NEW_FAX_PAGE:
            /* This substate entered once per reception of a new FAX
            document page. */
            fax2_response_page(CONNECT_RESPONSE, NULL);
            /* increment page counter module 256 */
            fax2_ECM_pgnumless1 = (fax2_ECM_pgnumless1 == 0xFF) ?
                0 : fax2_ECM_pgnumless1 + 1;
            fax2_ECM_blknumless1 = 0xFF; /* pre-increments to 0 */
            fax2_sub_state = ECM_CFG_RX_NEW_ECM_PART_PAGE;
            /* break intentionally omitted */
        case ECM_CFG_RX_NEW_ECM_PART_PAGE:
            /* This substate entered once per reception of a NEW ECM
            partial page (or block) */

            fax2_ECM_schedulelongtrain = FALSE;

            fax2_ECM_rx_init(RX_NEW_PP_MODE);
            /* increment block counter module 256 */
            fax2_ECM_blknumless1 = (fax2_ECM_blknumless1 == 0xFF) ?
                0 : fax2_ECM_blknumless1 + 1;
            fax2_ECM_rx_1st_PPSQ_received = FALSE; /* 1st PPS-Q not received */

            /*fax2_ECM_dte_bg() concurrent task should have been idle until now*/
            fax2_ECM_dte_bg_init();
            fax2_sub_state = ECM_RX_DATA;

            if (fax2_ECM_schedule_sub_state == ECM_CFG_RX_NEW_ECM_PART_PAGE)
                /* This is not the first partial page of the FAX page;
                consequently, do not look for <DC2> */
                fax2_ECM_dte_bg_run(EXECUTE_IMMEDIATELY);
            else
            {
                /* assume that the stats are zero (due to ECM) */
                fax2_stats.LC = 0;   /* N/A; 592 says we may leave this */
                                     /* zero if not applicable */
                fax2_stats.BLC = 0;  /* assume ECM makes zero */
                fax2_stats.CBLC = 0; /* assume ECM makes zero */
                fax2_stats.LBC = 0;  /* assume zero */
                /*Look for DC2 this is the first partial page of the FAX page */
                fax2_ECM_dte_bg_run(EXECUTE_AFTER_FOUND_DC2);
            }
            /* break intentionally omitted */
        case ECM_RX_DATA:
            /* Note: We have an "asynchronous" task fax2_ECM_dte_bg() pulling
            characters out of the 16K/64K ECM buffer and transmitting them
            to the PC; This task also detects CAN, DC2, etc. from the APP*/
            if (fax2_ECM_rx_pp_bg() != ECRXSTAT_RECEIVING)
            {
                /* distant end has finished transmitting partial page!
                goto Phase B */
                fax2_state = PHASE_B_RECEIVE;
                fax2_sub_state = RX_COMMAND_OR_DATA;
            }
            break;
        case ECMRX_CFG_RE_RECV_ECMPP:
            /* thus substate is entered once per RE-RECEPTION of an ECM
            partial page (or block) */
            fax2_ECM_rx_init(RE_RX_PP_MODE);
            fax2_sub_state = ECM_RX_DATA;
            break;
    } /* switch */

    return(return_code);
}

/******************************************************************************
/
/   Routine: fax2_phaseC_transmit_ECM
/
/   Author: RSA
/
/   Creation Date: 9/23/93
/
/   Description: This routine will implement the class 2 T.30 phase C transmit
/                functions for ECM
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/
/   Global Variables Changed: Class 2 FAX vairiables
/
/   Users: fax2_bg()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_phaseC_transmit_ECM(void)
{
    ubyte return_code;
    ubyte tmp;

    return_code = STAY_ONLINE;
/* Each phase C transmit session generates a partial page (pp) to
   be transmitted. */

    switch(fax2_sub_state)
    {
        case CONFIGURE_TX_DATA:
        case ECM_CFG_TX_NEW_FAX_DOCUMENT:
            /* This substate entered once per document transmission
            (i.e., CFR received in phase B).  */
            /* prepare to transmit a new partial page */
            /* Note fax2_ECM_framsize should already be set by a call to
            fax2_get_ECM_framesize when bit 28 of the DCS is being "built" */

            fax2_ECM_tx_configure(fax2_ECM_framesizeless1);

            /* reset pointer used to indicate if we were in the middle
            of transmitting an RTC when a partial page break occured
            (i.e., partial page was completed) */
            fax2_ECM_RTC_ptr = NULL;

            /* Reset page counter per document transmitted.  Counter is
            set to 255 because it is pre-incremented, modulo 256 to 0
            (i.e., 1+255 modulo 256 = 0) */
            fax2_ECM_pgnumless1 = 0xFF;

            fax2_sub_state = ECM_CFG_TX_NEW_FAX_PAGE;
            /* Break intentionally omitted */
        case ECM_CFG_TX_NEW_FAX_PAGE:
            /* This substate entered once per transmission of a new FAX
            document page. */

            fax2_ECM_pgnumless1 = (fax2_ECM_pgnumless1 == 0xFF) ?
                0 : fax2_ECM_pgnumless1 + 1;

            /* reset pointer used to indicate if we were in the middle
            of transmitting an RTC when a partial page break occured
            (i.e., partial page was completed) */
            fax2_ECM_RTC_ptr = NULL;

            /* Send the initial response that goes out per FAX
               document page */
            fax2_response_page(CONNECT_RESPONSE, NULL);
            /* wait until the complete response has been sent */
            while (fax_dte_to_num());
            /* turn off packet protocol */
            fax_dte_packet_protocol(OFF);
            fax_dte_to_char(XON);
            fax2_last_data_dle = FALSE; /* reset DLE indication */
            fax2_local_generated_interrupt = FALSE;

            /* Reset block counter per document transmitted.  Counter is
            set to 255 because it is pre-incremented, modulo 256 to 0
            (i.e., 1+255 modulo 256 = 0) */
            fax2_ECM_blknumless1 = 0xFF;
            /* Reset the "ungetchar" mechanism */
            fax2_ECM_ungetchar.count = 0;
            fax2_sub_state = ECM_CFG_TX_NEW_ECM_PART_PAGE;
            /* Break intentionally omitted */
        case ECM_CFG_TX_NEW_ECM_PART_PAGE:
            /* This substate entered once per transmission of a NEW ECM
            partial page (or block) */

            /* no post message command has been detected for this partial page!
               (e.g., PPS-NULL, PPS-EOM, etc.) */
            fax2_pp_command = NO_PPC;

            fax2_ECM_schedulelongtrain = FALSE;

            fax2_ECM_blknumless1 = (fax2_ECM_blknumless1 == 0xFF) ?
                0 : fax2_ECM_blknumless1 + 1;
            /* a new ecm partial page always has short train */
            fax2_ECM_tx_init(TX_NEW_PP_MODE, SHORT_TRAIN);
            /* Initialize partial page retry count */
            fax2_ECM_ppr_retrycount = ((uword) fax2_ECM_retry_count + 1) << 2;
            fax2_sub_state = ECM_WAIT_CFG_TX_PP;
            /* break intentionally omitted */
        case ECM_WAIT_CFG_TX_PP: /* wait for ECM to configure data pump */
            fax2_ECM_tx_pp_bg();    /* Give ECM TX processing power */
            if (!fax2_ECM_tx_configured_tx_pp())
                break;

            /* else ready to transmit new ECM partial page (or block). */
            if (fax2_ECM_RTC_ptr != NULL)
                /* The last phase C transition was in the middle of sending
                an RTC when the ECM partial page was completed. So,
                complete sending the RTC */
                fax2_sub_state = ECM_SEND_RTC;
            else
            {   /* Start sending a new PP */
                /* Send any pending "unget" char(s) before
                starting a new partial page */
                for (tmp = 0; tmp < fax2_ECM_ungetchar.count; ++tmp)
                    fax2_ECM_tx_to_char(fax2_ECM_ungetchar.ungetchar[tmp]);
                fax2_ECM_ungetchar.count = 0; /* Reset ungetchar count */
                fax2_sub_state = ECM_TX_PP;
            }
            break;
        case ECM_TX_PP:
            fax2_ECM_tx_pp();
            break;
        case ECM_SEND_RTC: /* Class 2 only */
            fax2_ECM_tx_pp_bg(); /* Give ECM TX processing power */
            if (fax2_ECM_tx_pp_complete())
            {
                /* partial page is complete before entire RTC went out! We
                will have to finish sending the RTC on the next transition
                into Phase C */
                fax2_sub_state = ECM_FLUSH_LINE_PPS_NULL;
                break;
            }
            fax2_ECM_tx_to_char(*fax2_ECM_RTC_ptr);
            if (*(++fax2_ECM_RTC_ptr) == 0xFF)
            {
                /* RTC has been transmitted! */
                fax2_ECM_RTC_ptr = NULL;
                fax2_ECM_tx_flush_pp_to_line();  /*Close partial page */
                fax2_sub_state = ECM_FLUSH_LINE_NON_PPS_NULL;
            }
            break;
        case ECM_FLUSH_LINE_PPS_NULL:
            /* wait until ECM has finish sending entire pp */
            fax2_ECM_tx_pp_bg(); /* Give ECM TX processing power */
            if (fax2_ECM_tx_pp_transmitted())
            {
                /* Want to enter phase D to transmit a PPS-NULL post
                page command -- transparent to the application ...*/
                fax2_pp_command = PPS_NULL_PPC;
                /* transition to T.30 phase D */
                fax2_state = PHASE_D_TRANSMIT;
                fax2_sub_state = ECM_SCHEDULE_TX_PMC;
            }
            break;
        case ECM_FLUSH_LINE_NON_PPS_NULL:
            /* wait until ECM has finish sending entire pp */
            fax2_ECM_tx_pp_bg(); /* Give ECM TX processing power */
            if (fax2_ECM_tx_pp_transmitted())
            {
                /* wait until the complete response has been sent */
                while (fax_dte_to_num());
                /* turn off packet protocol */
                fax_dte_packet_protocol(ON);

                if (fax2_class == STANDARD_2388)   /* Class 2 */
                {
                    /* setup a timeout for receiveing the +FET command */
                    fax2_interaction_timer = fax2_timeout * TENTHS_SECOND;
                    /* setup command flag indication */
                    fax2_received_command = EMPTY_COMMAND;
                    fax2_sub_state = ECM_WAIT_FOR_FET;
                    /* respond with OK to indicate completion of transmit data */
                    return_code = GOTO_PARSE_OK;
                }
                else                    /* Class 2.0 */
                {
                    /* if APP asked for a procedure interrupt, modify
                    post message command appropriately */
                    if (fax2_local_generated_interrupt)
                        fax2_pp_command += PPS_Q_TO_PRI_Q;
                    /* We have the post message command; need to transmit it! */
                    fax2_state = PHASE_D_TRANSMIT;
                    fax2_sub_state = ECM_SCHEDULE_TX_PMC;
                }
            }
            break;
        case ECM_WAIT_FOR_FET:
            if (fax2_received_command == FET_COMMAND)
            {
                /* post page (message) command has been assigned by the +FET command */
                fax2_state = PHASE_D_TRANSMIT;
                fax2_sub_state = ECM_SCHEDULE_TX_PMC;
                /* the +FET command toke us online, and we need to stay there */
            }
            else if (!fax2_interaction_timer) /* have we timedout on the +FET ? */
            {
                /* if timedout send an end of procedure post page command */
                fax2_pp_command = PPS_EOP_PPC;
                /* transition to T.30 phase D */
                fax2_state = PHASE_D_TRANSMIT;
                fax2_sub_state = ECM_SCHEDULE_TX_PMC;
                /* disable flow control, not expecting anything from DTE */
                fax2_configure_dte = NO_FLOW;
                /* put the ACU back online since we gave up on the command */
                /* and we need the DTE port to continue the connection */
                return_code = GOTO_ONLINE_BG;
            }
            else
                return_code = STAY_PARSE;
            break;
        case ECM_RXMIT_CFG_TX_ECM_PART_PAGE:
            /* This substate entered once per RE-TRANSMISSION of an ECM
            partial page (or block) */

            /* Perform long train if scheduled (i.e., after CTC/CTR pair per
            T.30, page 97) */
            if (fax2_ECM_schedulelongtrain)
            {
                fax2_ECM_tx_init(REXMIT_PP_MODE, LONG_TRAIN);
                fax2_ECM_schedulelongtrain = FALSE;
            }
            else
                fax2_ECM_tx_init(REXMIT_PP_MODE, SHORT_TRAIN);
            fax2_sub_state = ECM_RXMIT_PP;
            /* break intentionally omitted */
        case ECM_RXMIT_PP: /* wait for ECM to configure data pump */
            fax2_ECM_tx_pp_bg();
            if (fax2_ECM_tx_pp_transmitted())
            {
                /* We have JUST completed transmitting an ECM block.
                Because we are re-transmitting frames of an ECM block,
                the block counter (i.e., fax2_ECM_blknumless1) and the
                post message command (i.e., fax2_pp_command) are already
                up to date and we do not have to set them. And so, we
                transition to T.30 phase D ... */

                fax2_state = PHASE_D_TRANSMIT;
                fax2_sub_state = ECM_SCHEDULE_TX_PMC;
            }
            break;
    }
    return(return_code);
}

/*******************************************************************************
/
/	Routine: fax2_phaseD_receive_ECM
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/       Description: This routine will implement the class 2 T.30 phase D receive
/                functions for ECM.
/
/       Input Parameters: none
/
/       Output Parameters: ubyte    return code
/                          0        Stay online
/                          1        Stay in the parse state
/                          2        Go to parse and respond with
/                                   OK message.
/                          3        Go to parse and respond with
/                                   NO CARRIER message.
/                          4        Go to parse and respond with
/                                   ERROR message.
/                          5        Go to hangup connection
/                          6        Go to online
/                          7        Go to parse and respond with
/                                   FCERROR message.
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_phaseD_receive_ECM(void)
{
    ubyte return_code;

    return_code = STAY_ONLINE; /* default to staying online */

    switch (fax2_sub_state)
    {
        case ROUTE_COMMAND:
        case ECM_RX_ROUTE_COMMAND:
            fax2_pp_command = fax2_ECM_ppcfrompacket(fax2_packet_opcode,
                                  fax2_buffer_ptr->data[FIF_1]);
            if (fax2_pp_command == UNRECOGNIZED_ECMPPC)
            {
                /* a DCN packet or an unexpected packet */
                fax2_state = PHASE_E; /* terminate the protocol */
                fax2_sub_state = TERMINATE;
                /* if expecting a DCN then we terminated properly */
                if (fax2_packet_opcode == DCN_PACKET && fax2_DCN_expected)
                    fax2_hangup_status = PROPER_END_OF_CONNECTION;
                /* if DCN in response to a procedure interrupt request */
                else if (fax2_packet_opcode == DCN_PACKET &&
                    fax2_local_generated_interrupt)
                    fax2_hangup_status = RX_D_UNABLE_PIP_PIN_ERROR;
                else
                    /* packet not expected */
                    fax2_hangup_status = RX_D_RSPREC_ERROR;
                break;
            }

            fax2_sub_state = ECM_RX_PROCESS_PPC;
            /* break intentionally omitted */
        case ECM_RX_PROCESS_PPC:
            if (fax2_pp_command <= PPS_Q_MAX_INDEX ||
                fax2_pp_command == RR_PPC)
            /* PMC (post message command) is a PPS-Q or PPS-PRI-Q command, or
            a RR PMC (because a RNR is only issued after a PPS-Q,  */
            {
                if (fax2_pp_command <= PPS_Q_MAX_INDEX)
                {
                    /* Did we receive the correct page number and block count? */
                    if (fax2_ECM_pgnumless1 != fax2_buffer_ptr->data[FIF_2] ||
                     fax2_ECM_blknumless1 != fax2_buffer_ptr->data[FIF_3])
                    /* No! Transmitter is in error condition. Terminate */
                    {
                        fax2_ECM_dte_send_DLE_ETX(); /* DLE ETX */
                        fax2_state = PHASE_E; /* send a DCN packet then hangup */
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        fax2_hangup_status = RX_C_GENERAL_ERROR;
                        break;
                    }
                    /* if we this is the first PPS-Q for the partial page,
                    then accept framecount.  Subsequent, PPS-Q's for the
                    same partial page (i.e., partial page requests) reflect
                    the number of frames re-transmitted and not the number
                    of total frames the partial page is supposed to contain */
                    if (!fax2_ECM_rx_1st_PPSQ_received)
                    {
                        fax2_ECM_rx_1st_PPSQ_received = TRUE;
                        /* inform ECM of frame count */
                        fax2_ECM_rx_framecount(fax2_buffer_ptr->data[FIF_4]);
                        /* Given the fax2_ECM_dte_bg() some energy so that the
                        coming call fax2_ECM_dte_pp_sent() can take into
                        account the frame number in the PPS-Q command
                        (i.e., the function call just made:
                        fax2_ECM_rx_framecount(fax2_buffer_ptr->dat[FIF4]).
                        Specifically fax2_ECM_dte_pp_sent() returns TRUE if
                        it realizes it has sent the frame number specified
                        in PPS-Q */
                        fax2_ECM_dte_bg();
                    }
                }

                if (!fax2_ECM_rx_cq_ok())
                {
                    /* copy quality not okay; schedule PPR, transparently
                    to APP!*/
                    fax2_pp_response = PPR_PPR;
                    fax2_sub_state = ECM_RX_SCHEDULE_PMR;
                    break;
                }

                if (!fax2_ECM_dte_pp_sent())
                {
                    /* ECM buffer has not been completely sent to the DTE;
                    schedule a RNR pmr because our receiver is "NOT READY" (i.e,
                    fax2_ECM_rx_pp_bg() is still in the processing of sending
                    the current PP to the APP */
                    fax2_pp_response = RNR_PPR;
                    /* save the transmitted PMC for later (see below) if this
                    is a non RR pp command (also meaning the receiver is first
                    proclaiming its RNR condition)*/
                    if (fax2_pp_command != RR_PPC)
                        fax2_ECM_save_pp_command = fax2_pp_command;
                    fax2_sub_state = ECM_RX_SCHEDULE_PMR;
                    break;
                }

                /* we have a ECM buffer is clear; we have a "RECEIVER READY"
                condition */

                if (fax2_pp_command == RR_PPC)
                    /* if the transmitter is issuing a RR, then recall
                    the original PMC it sent us */
                    fax2_pp_command = fax2_ECM_save_pp_command;

                /* copy quality is okay, so assume MCF */
                fax2_pp_response = MCF_PPR;

                /* if we sent a procedure interrupt and it was responded to positively */
                if (fax2_pp_command >= PPS_PRI_Q_MIN_INDEX &&
                    fax2_pp_command <= PPS_PRI_Q_MAX_INDEX)
                {
                    /* remote is acknowledging our PRI*/
                    if (fax2_local_generated_interrupt)
                    {
                        /* indicate a procedure interrupt established (VOICE) */
                        fax2_response_page(VOICE_RESPONSE, NULL);
                        fax2_state = IDLE; /* idle waitting for an ATA or an ATD */
                        return_code = GOTO_PARSE_OK;
                        break;
                    }
                    /* remote requesting PRI */
                    else if (fax2_interrupts_enabled) /* if configured to accept */
                    {
                        fax2_remote_generated_interrupt = TRUE; /* flag the case */
                        /* indicate acceptance (i.e., PIP_PPR!) */
                        fax2_pp_response = PIP_PPR;
                    }
                    else /* not configured to accept procedure interrupts */
                        /* translate PPS-PRI-Q to a PPS-Q */
                        fax2_pp_command -= PRI_Q_TO_PPS_Q;
                }

                /* if not first time through phase D per this transmission */
                /* or received PPS_NULL PMC, we want this PMR to be transparent to
                   APP */
                if (fax2_FDR_received ||
                    fax2_pp_command == PPS_NULL_PPC)
                {
                    /* don't wait dor +FDR command to retransmit the post page response */
                    fax2_sub_state = ECM_RX_SCHEDULE_PMR;
                    break;
                }

                fax2_ECM_dte_send_DLE_ETX();
                while (fax_dte_to_num());
                fax2_utility_timer = ECM_FPS_DELAY;
                fax2_sub_state = ECM_RX_DELAY_RESPONSE;
            }
            else if (fax2_pp_command >= EOR_Q_MIN_INDEX &&
                     fax2_pp_command <= EOR_Q_MAX_INDEX)
            /* PMC (post message command) is a EOR-Q or EOR-PRI-Q command.*/
            /* We are entering a grey area.  2388/592 do not discuss
            how modem is to react to an EOR-Q. */
            {
                /* stop fax2_ECM_dte_bg() from sending PP data to DTE */
                fax2_ECM_dte_bg_init();

                fax2_pp_response = ERR_PPR; /* assume non PRI */

                /* if we sent a procedure interrupt and it was responded to positively */
                if (fax2_pp_command >= EOR_PRI_Q_MIN_INDEX &&
                    fax2_pp_command <= EOR_PRI_Q_MAX_INDEX)
                {
                    /* remote is acknowledging our PRI*/
                    if (fax2_local_generated_interrupt)
                    {
                        /* indicate a procedure interrupt established (VOICE) */
                        fax2_response_page(VOICE_RESPONSE, NULL);
                        fax2_state = IDLE; /* idle waitting for an ATA or an ATD */
                        return_code = GOTO_PARSE_OK;
                        break;
                    }
                    /* remote requesting PRI */
                    else if (fax2_interrupts_enabled) /* if configured to accept */
                    {
                        fax2_remote_generated_interrupt = TRUE; /* flag the case */
                        /* indicate acceptance (i.e., PIP_PPR! ) */
                        fax2_pp_response = PIN_PPR;
                    }
                    else /* not configured to accept procedure interrupts */
                        /* translate EOR-PRI-Q to a EOR-Q */
                        fax2_pp_command -= EOR_PRI_Q_TO_EOR_Q;
                }

                /* if not first time through phase D per this PMR transmission */
                /* or EOR_NULL PMC */
                if (fax2_FDR_received ||
                    fax2_pp_command == EOR_NULL_PPC)
                {
                    /* send ERR transparently to APP */
                    fax2_sub_state = ECM_RX_SCHEDULE_PMR;
                    break;
                }

                /* wait for +FDR command to send the post page response */
                fax2_FDR_received = TRUE;

                /* Hope the APP does not pre-empt the post message response of
                ERR, because there is no other pmr that is valid to send! */
                /* indicate post page command received to the APP */

                fax2_ECM_dte_send_DLE_ETX();
                while (fax_dte_to_num());
                fax2_utility_timer = ECM_FPS_DELAY;
                fax2_sub_state = ECM_RX_DELAY_RESPONSE;
            }
            else if (fax2_pp_command == CTC_PPC)
            {
                /* get new receive speed in CTC */
                fax2_accept_CTC_page();
                fax2_pp_response = CTR_PPR;
                /* A long train is required after CTC/CTR ECM message pair */
                fax2_ECM_schedulelongtrain = TRUE;
                fax2_sub_state = ECM_RX_SCHEDULE_PMR;
            }
            break;
        case ECM_RX_DELAY_RESPONSE:
                if (!fax2_utility_timer)
                {
                    /* indicate PPR and stats to the APP */
                    fax2_response_page(PPR_RESPONSE, NULL);
                    /* indicate post page command received to the APP */
                    fax2_response_page(PPC_RESPONSE, NULL);
                    /* wait for +FDR command to send the post page response */
                    fax2_FDR_received = TRUE;

                    /* allow the APP to change the post page response before sending it */
                    fax2_sub_state = ECM_RX_WAIT_FOR_FDR;
                    fax2_received_command = EMPTY_COMMAND;
                    return_code = GOTO_PARSE_OK;
                }
            break;
        case ECM_RX_WAIT_FOR_FDR:
            /* look for command to send the post page response */
            if (fax2_received_command == FDR_COMMAND)
                fax2_sub_state = ECM_RX_SCHEDULE_PMR;
            else
                return_code = STAY_PARSE; /* keep waitting for command */
            break;
        case ECM_RX_SCHEDULE_PMR:
            fax2_schedule_tx_packet_page(fax2_ECM_pmrfcftable[fax2_pp_response],
                                         UNUSED);
            fax2_sub_state = ECM_RX_XMIT_PMR;
            /* break intentionally omitted */
        case ECM_RX_XMIT_PMR:
            if (!fax2_transmit_packet_page())
                break;
            /* default fax2_ECM_schedule_sub_state; this variable is relevant
            only if a data modulation is detected in Phase B receive */
            fax2_ECM_schedule_sub_state = ECM_CFG_RX_NEW_FAX_DOCUMENT;
            switch (fax2_pp_response) /* next action depends on response */
            {
                case MCF_PPR: /* the receiver accepts the message */
                case ERR_PPR: /* receiver accepts EOR-Q */
                    switch (fax2_pp_command)
                    {
                        case PPS_MPS_PPC:
                        case PPS_PRI_MPS_PPC:
                        case EOR_MPS_PPC:
                        case EOR_PRI_MPS_PPC:
                            fax2_data_expected = TRUE; /* look next page */
                            fax2_ECM_schedule_sub_state = ECM_CFG_RX_NEW_FAX_PAGE;
                            break;
                        case PPS_EOM_PPC:
                        case PPS_PRI_EOM_PPC:
                        case EOR_EOM_PPC:
                        case EOR_PRI_EOM_PPC:
                            /* delay 6 seconds and send a DIS block */
                            fax2_EOM_processing = TRUE;
                            fax2_ECM_schedule_sub_state = ECM_CFG_RX_NEW_FAX_DOCUMENT;
                            break;
                        case PPS_EOP_PPC:
                        case PPS_PRI_EOP_PPC:
                        case EOR_EOP_PPC:
                        case EOR_PRI_EOP_PPC:
                            fax2_DCN_expected = TRUE; /* looking for DCN */
                            break;
                        case PPS_NULL_PPC: /* transparent to APP */
                        case EOR_NULL_PPC: /* transparent to APP */
                            fax2_ECM_schedule_sub_state = ECM_CFG_RX_NEW_ECM_PART_PAGE;
                            break;
                    }
                    fax2_state = PHASE_B_RECEIVE; /* phase B state (F) */
                    fax2_sub_state = RX_COMMAND_OR_DATA;
                    break;
                case PIN_PPR:
                case PIP_PPR:
                    /* did we respond to a remote procedure interrupt */
                    if (fax2_remote_generated_interrupt)
                    {
                        /* indicate a procedure interrupt established (VOICE) */
                        fax2_response_page(VOICE_RESPONSE, NULL);
                        fax2_state = IDLE; /* idle waitting for an ATA or an ATD */
                        return_code = GOTO_PARSE_OK;
                    }
                    else /* fax2_local_generated_interrupt == TRUE */
                    {
                        fax2_state = PHASE_B_RECEIVE; /* phase B state (F) */
                        fax2_sub_state = RX_COMMAND_OR_DATA;
                    }
                    break;
                case PPR_PPR:
                case CTR_PPR:
                    fax2_state = PHASE_B_RECEIVE; /* phase B state (F) */
                    fax2_sub_state = RX_COMMAND_OR_DATA;
                    fax2_ECM_schedule_sub_state = ECMRX_CFG_RE_RECV_ECMPP;
                    break;
                case RNR_PPR:
                    fax2_state = PHASE_B_RECEIVE; /* phase B state (F) */
                    fax2_sub_state = RX_COMMAND_OR_DATA;
                    break;
            }
            break;
    }
    return(return_code);
}

/*******************************************************************************
/
/	Routine: fax2_phaseD_transmit_ECM
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/   	Description: This routine will implement the class 2 T.30 phase D transmit
/                functions for ECM.
/
/   	Input Parameters: none
/
/   	Output Parameters: ubyte    return code
/                          0        Stay online
/                          1        Stay in the parse state
/                          2        Go to parse and respond with
/                                   OK message.
/                          3        Go to parse and respond with
/                                   NO CARRIER message.
/                          4        Go to parse and respond with
/                                   ERROR message.
/                          5        Go to hangup connection
/                          6        Go to online
/                          7        Go to parse and respond with
/                                   FCERROR message.
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_phaseD_transmit_ECM(void)
{
    ubyte return_code;
    return_code = STAY_ONLINE; /* default to stay in online state */

    switch (fax2_sub_state)
    {
        case ECM_SCHEDULE_TX_PMC:
           /* queue up to send the post message command */
            fax2_schedule_tx_packet_page(fax2_ECM_pmcfcftable[fax2_pp_command][0],
                                    fax2_ECM_pmcfcftable[fax2_pp_command][1]);
            fax2_sub_state = ECM_TX_PMC;
            /* break intentionally omitted */
        case ECM_TX_PMC:
            if (!fax2_transmit_packet_page()) /* configure and transmit */
                break;
            fax2_sub_state = ECM_RX_PMR;
            /* break intentionally omitted */
        case ECM_RX_PMR:
            /* look to receive the post message response */
            fax2_ECM_rx_pmr();
            /* allow an intentional fall-through if successfully
            interpreted a fax post message response */
            if (fax2_sub_state != ECM_PROCESS_PPR || fax2_state != PHASE_C_TRANSMIT)
                break;
        case ECM_PROCESS_PPR:/* act appropriately to the post message response */
            switch (fax2_pp_response)
            {
                case PIP_PPR:
                case PIN_PPR:
                    /* if procedure interrupt and we initiated it */
                    if (fax2_ECM_pri_initiated[fax2_pp_command])
                    {
                        /* indicate a procedure interrupt established (VOICE) */
                        fax2_response_page(VOICE_RESPONSE, NULL);
                        fax2_state = IDLE; /* idle waitting for an ATA or an ATD */
                        /* indicate acceptance or rejection of the page */
                        return_code = (fax2_class == STANDARD_592 &&
                                       fax2_pp_response == PIN_PPR) ?
                                      GOTO_PARSE_ERROR : GOTO_PARSE_OK;
                    }
                    /* else the remote started it. If we accept procedure interrupts */
                    else if (fax2_interrupts_enabled)
                        /* respond to remote with a procedure interrupt */
                        /* version of the post page command previously sent */
                        fax2_sub_state = ECM_SCHEDULE_PRIQ;
                    else /* remote initiated a procedure interrupt, */
                         /* and we're not configured to accept it */
                    {
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        fax2_hangup_status = TX_D_UNABLE_PIP_PIN_ERROR;
                    }
                    break;
                case MCF_PPR: /* Hooray! ECM block has been received correctly! */
                case ERR_PPR: /* Or at least we are skipping to next ECM block ! */
                    switch (fax2_pp_command)
                    {
                        case PPS_MPS_PPC:
                        case PPS_PRI_MPS_PPC:
                        case EOR_MPS_PPC:
                        case EOR_PRI_MPS_PPC:
                            fax2_next_state = PHASE_C_TRANSMIT;
                            fax2_next_sub_state = ECM_CFG_TX_NEW_FAX_PAGE;
                            /* go back to phase C to send the next page */
                            /* wait for the +FDT command to continue */
                            fax2_sub_state = ECM_WAIT_FOR_FDT;
                            fax2_received_command = EMPTY_COMMAND;
                            /* respond with OK, the +FPTS already indicated */
                            /* the post page response received */
                            /* respond with ERROR if Class 2.0 and pmr was */
                            /* ERR per 592 */
                            return_code = (fax2_class == STANDARD_592 &&
                                fax2_pp_response == ERR_PPR) ?
                                GOTO_PARSE_ERROR : GOTO_PARSE_OK;
                            break;
                        case PPS_EOP_PPC:
                        case PPS_PRI_EOP_PPC:
                        case EOR_EOP_PPC:
                        case EOR_PRI_EOP_PPC:
                            /* end of procedure */
                            /* since the remote accepted the page and there */
                            /* are no more pages or documents to send */
                            /* we'll send a disconnect packet and hangup */
                            fax2_state = PHASE_E;
                            fax2_sub_state = SCHEDULE_DCN_PACKET;
                            fax2_hangup_status = PROPER_END_OF_CONNECTION;
                            break;
                        case PPS_EOM_PPC:
                        case PPS_PRI_EOM_PPC: /* end of message */
                        case EOR_EOM_PPC:
                        case EOR_PRI_EOM_PPC: /* end of message */
                            /* the page was accepted but we have another */
                            /* document to send. Go to state (T) */
                            fax2_EOM_processing = TRUE; /* indicate parse state */
                            fax2_state = PHASE_B_TRANSMIT;
                            fax2_sub_state = INITIALIZE;
                            /* clear received command flag */
                            fax2_received_command = EMPTY_COMMAND;
                            /* respond with OK and wait for a goahead command */
                            /* while receiving the DIS block */
                            /* respond with ERROR if Class 2.0 and pmr was */
                            /* ERR per 592 */
                            return_code = (fax2_class == STANDARD_592 &&
                                fax2_pp_response == ERR_PPR) ?
                                GOTO_PARSE_ERROR : GOTO_PARSE_OK;
                            break;
                        case PPS_NULL_PPC: /* partial page boundary */
                        case EOR_NULL_PPC: /* partial page boundary */
                            fax2_state = PHASE_C_TRANSMIT;
                            fax2_sub_state = ECM_CFG_TX_NEW_ECM_PART_PAGE;
                            break;
                    }
                    break;
                case PPR_PPR:
                    /* Sigh! Some frames in ECM block have been corrupted and
                    must be re-sent */
                    fax2_ECM_accept_PPR();
                    /* if in the middle of an attempt block */
                    if ((--fax2_ECM_ppr_retrycount) & 0x03)
                    {
                        /* Every four attempts represent an attempt block;
                        this is not the end of a attempt block; retry pp
                        at same speed */
                        fax2_state = PHASE_C_TRANSMIT;
                        fax2_sub_state = ECM_RXMIT_CFG_TX_ECM_PART_PAGE;
                    }
                    else
                    {   /* Every four attempts represent an attempt block;
                           we have made an attempt block;
                           decide whether to send a CTC or a EOR */

                        /* send CTC; go to lower speed if possible */
                        if ((fax2_negotiated.BR > BR_14400 ? fax2_negotiated.BR-4 :
                            fax2_negotiated.BR) > fax2_minimum_speed)
                        {
                            /* if falling from V.17 7200, go to v.27 4800 */
                            if (--fax2_negotiated.BR == BR_14400)
                                fax2_negotiated.BR = BR_4800;
                            /* reset the number of attempt blockes */
                            fax2_ECM_ppr_retrycount =
                                    ((uword) fax2_ECM_retry_count + 1) << 2;
                        }

                        /* if all attempt blocks have been exhausted */
                        if (!fax2_ECM_ppr_retrycount)
                        {
                            /* send a DCN and terminate the connection */
                            fax2_state = PHASE_E; /* terminate the protocol */
                            fax2_sub_state = SCHEDULE_DCN_PACKET;
                            fax2_hangup_status = TX_C_UNSPECIFIED_ERROR;
                        }
                        else /* try another attempt block */
                        {
                            /* although we treat CTC/CTR as a Phase D response, the
                            T.30 considers it a pre-message command/response pair. */
                            fax2_sub_state = ECM_SCHEDULE_TX_PMC;

                            /* save the original post message command to re-transmit
                            after the partial page if the downshift is successful.*/
                            fax2_ECM_save_pp_command = fax2_pp_command;
                            fax2_pp_command = CTC_PPC;
                        }
                    }

                    break;
                case RNR_PPR:
                    fax2_T5_timer = T5_TIMEOUT; /* start T5 inactivity timer */
                    fax2_sub_state = ECM_SCHEDULE_TX_RR;
                    break;
                case CTR_PPR:
                    /* use FIF of last sent PPR when retransmitting requested
                    frames */
                    fax2_state = PHASE_C_TRANSMIT;
                    fax2_sub_state = ECM_RXMIT_CFG_TX_ECM_PART_PAGE;

                    /* A long train is required after CTC/CTR ECM message pair */
                    fax2_ECM_schedulelongtrain = TRUE;

                    /* restore the original post message command to re-transmit
                    after the partial page. */
                    fax2_pp_command = fax2_ECM_save_pp_command;

                    break;
            }
            break;
        case ECM_WAIT_FOR_FDT: /* wait for a +FDT to continue with the protocol */
            if (fax2_received_command == FDT_COMMAND)
            {
                /* assign the previously determined T.30 state */
                fax2_state = fax2_next_state;
                fax2_sub_state = fax2_next_sub_state;
                return_code = STAY_ONLINE;
            }
            else
                return_code = STAY_PARSE;
            break;
        case ECM_SCHEDULE_TX_RR:
            fax2_schedule_tx_packet_page(RR_PACKET,UNUSED);
            fax2_sub_state = ECM_TX_RR;
            /* break intentionally omitted */
        case ECM_TX_RR:
            if (!fax2_transmit_packet_page()) /* configure and transmit */
                break;
            fax2_sub_state = ECM_RX_RR_RESPONSE;
            /* break intentionally omitted */
        case ECM_RX_RR_RESPONSE:
            fax2_ECM_rcv_RR_response();
            break;
        case ECM_SCHEDULE_PRIQ:
            /* post a procedure interrupt version of the */
            /* post page command previously sent */
            /* fax2_ECM_rx_pmr_ok() guarantees PIN/PIP was not
               received on a XXX-NULL (partial page/non-FAX page) boundary;*/
            fax2_pp_command += PPS_Q_TO_PRI_Q;
            fax2_schedule_tx_packet_page(fax2_ECM_pmcfcftable[fax2_pp_command][0],
                                    fax2_ECM_pmcfcftable[fax2_pp_command][1]);
            fax2_sub_state = ECM_TX_PRIQ;
            /* break intentionally omitted */
        case ECM_TX_PRIQ:
            if (fax2_transmit_packet_page()) /* configure and transmit */
            {
                /* indicate a procedure interrupt established (VOICE) */
                fax2_response_page(VOICE_RESPONSE, NULL);
                fax2_state = IDLE; /* idle waitting for an ATA or an ATD */
                /* indicate acceptance or rejection of the page */
                return_code = (fax2_class == STANDARD_592 && fax2_pp_response == PIN_PPR)
                              ? GOTO_PARSE_ERROR : GOTO_PARSE_OK;
            }
            break;
    }
    return(return_code);
}

/*******************************************************************************
/
/	Routine: fax2_ECM_pagenumless1
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: Returns the ECM page just transmitted.
/
/	Input Parameters: None
/
/	Output Parameters: None
/
/	Global Variables Changed:
/
/	Users: fax2_schedule_tx_packet
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_ECM_pagenumless1(void)
{
    return(fax2_ECM_pgnumless1);
}

/*******************************************************************************
/
/	Routine: fax2_ECM_blocknumless1
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: Returns the ECM block just transmitted.
/
/	Input Parameters: None
/
/	Output Parameters: None
/
/	Global Variables Changed:
/
/	Users: fax2_schedule_tx_packet
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_ECM_blocknumless1(void)
{
    return(fax2_ECM_blknumless1);
}

/*******************************************************************************
/
/	Routine: fax2_ECM_numframesless1
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: Returns the how many ECM frames comprised the ECM
/                    block just transmitted.
/
/	Input Parameters: None
/
/	Output Parameters: None
/
/	Global Variables Changed:
/
/	Users: fax2_schedule_tx_packet
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_ECM_numframesless1(void)
{
    return(fax2_ECM_framesless1xmitted());
}

/*******************************************************************************
/
/	Routine: fax2_ECM_accept_framesize
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: If ECM has been negotiated, called when DCS has
/                    been received to accept the ECM framesize as dictated
/                    by the transmitting ECM machine (i.e., we, the receiver,
/                    accept bit 28 of the transmitter's DCS)
/
/	Input Parameters: framesize64       TRUE  -> 64 bytes/frame accepted
/                                           FALSE -> 256 bytes/frame accepted
/
/	Output Parameters: None
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void fax2_ECM_accept_framesize(ubyte framesize64)
{
    fax2_ECM_framesizeless1 = framesize64 ? FRAMESIZE64 : FRAMESIZE256;
}

/*******************************************************************************
/
/	Routine: fax2_ECM_determine_framesize
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: If ECM has been negotiated, called when DCS is to
/                    be transmitted to determine what ECM framesize is to be
/                    negotiated (i.e., we, the transmitter configure for 64
/                    or 256 bytes/frame and determine but 28 of the DCS
/                    appropriately).
/
/	Input Parameters: None
/
/	Output Parameters: return code  TRUE    ->  64 bytes/frame
/                                       FALSE   ->  256 bytes/frame
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_ECM_determine_framesize(void)
{
    /* Determine whether ECM is capable of buffering 256 frames
    of frame length 256 bytes or 64 bytes */
    fax2_ECM_framesizeless1 =
        (fax2_ECM_bm_maxnum_frames_less1(FRAMESIZE256) >= NUMFRAMES256) ?
         FRAMESIZE256 : FRAMESIZE64;
    return fax2_ECM_framesizeless1 == FRAMESIZE64;
}

/*******************************************************************************
/
/	Routine: fax2_ECM_fax2_ECM_PPR_FIF_ptr
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: Called when an ECM PPR post message response is about
/                    to be sent.
/
/
/	Input Parameters: None
/
/	Output Parameters: Address of 32 byte array to be transmitted in the
/                          FIF of the PPR.
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte *fax2_ECM_fax2_ECM_PPR_FIF_ptr(void)
{
    return fax2_ECM_PPR_FIF;
}

/*******************************************************************************
/
/	Routine: fax2_ECM_rcv_data_longtrain()
/
/	Author: RSA
/
/	Creation Date: 9/23/93
/
/	Description: Called during phase B receive, entry point F (T.30)
/                    when the receiver must configure for either
/                    long train or short train
/
/	Input Parameters: None
/
/	Output Parameters: TRUE     Configure for long train receive
/                          FALSE    Configure for short train receive
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fax2_ECM_rcv_data_longtrain(void)
{
    if (fax2_ECM_schedulelongtrain)
    {
        fax2_ECM_schedulelongtrain = FALSE;
        return(TRUE);
    }
    return(FALSE);
}

