/****************************************************************************
/
/   Copyright, 1991,1992,1993,1994,1996.       All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File: f20x00cm.c
/
/   Module Version: 4.04 (change the FMR_IDENTIFICATION when changing this number)
/
/   Function: This file contains the command execution code for the
/             FAX class 2.0 (TIA/EIA-592)
/
/   Product: Class 2 FAX Module.
/
/   History: fx00cmd2.c 1.00
/
/   Created: 9/21/92
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
****************************************************************************/
#include "sys_def.h"

#include "f2x_def.h"
#include "f2x_mem.h"
#include "f2x_pro.h"

#define FAX20_FBO_CAPABILITY    "\r\n(0-3)\r\n"
#define FAX20_FBU_CAPABILITY    "\r\n(0-1)\r\n"
#define FAX20_FCC96_CAPABILITY  "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX20_FCC96ECM_CAPABILITY "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX20_FCC144_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX20_FCC144ECM_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX20_FCQ_CQ_CAPABILITY "\r\n(0-1),(0)\r\n"
#define FAX20_FCQ_NOCQ_CAPABILITY "\r\n(0),(0)\r\n"
#define FAX20_FCR_CAPABILITY    "\r\n(0-1)\r\n"
#define FAX20_FCT_CAPABILITY    "\r\n(0-FF)\r\n"
#define FAX20_FEA_CAPABILITY    "\r\n0\r\n"
#define FAX20_FFC_CAPABILITY    "\r\n(0),(0),(0),(0)\r\n"
#define FAX20_FIE_CAPABILITY    "\r\n(0-1)\r\n"
#define FAX20_FIS96_CAPABILITY  "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX20_FIS96ECM_CAPABILITY "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX20_FIS144_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX20_FIS144ECM_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX20_FLI_CAPABILITY    "\r\n(20-7E)\r\n"
#define FAX20_FLP_CAPABILITY    "\r\n(0-1)\r\n"

#define FAX20_FMM_IDENTIFICATION "\r\nFAX CLASS 2.0 (TIA/EIA-592)\r\n"
/* Need the space between the 0 and CR to obay the spec. sec. 8.2.4 */
#define FAX20_FMR_IDENTIFICATION "\r\nRSA REV 4.04 \r\n"
#define FAX20_FMS96_CAPABILITY  "\r\n(0-3)\r\n"
#define FAX20_FMS144_CAPABILITY "\r\n(0-5)\r\n"
#define FAX20_FNR_CAPABILITY    "\r\n(0-1),(0-1),(0-1),(0-1)\r\n"
#define FAX20_FNS_CAPABILITY    "\r\n5A\r\n"
#define FAX20_FPI_CAPABILITY    "\r\n(20-7E)\r\n"
#define FAX20_FPS_CAPABILITY    "\r\n(1-5)\r\n"
#define FAX20_FRQ_CAPABILITY    "\r\n(0-64),(0-FF)\r\n"
#define FAX20_FRY_CAPABILITY    "\r\n(0-FF)\r\n"
#define FAX20_FSP_CAPABILITY    "\r\n(0-1)\r\n"

/* MAX values for T.30 Session Subparm Codes (TIA/592- table 8.4) */
static const ubyte fax20_T30_range_array[] = {1, 5, 4, 2, 3, 1, 1, 7};

ubyte fax20_execute_command(uword, ubyte *, ubyte **);
void fax20_store_string(ubyte *, ubyte **);

/******************************************************************************
/
/   Routine: fax20_execute_command
/
/   Author: RSA
/
/   Creation Date: 09/24/92
/
/   Description: This routine is called from the FAX parser to execute
/                a FAX class 2.0 592 command.
/
/   Input Parameters: uword     command
/                               FAX20_FBO_COMMAND   200
/                               FAX20_FBU_COMMAND   201
/                               FAX20_FCC_COMMAND   202
/                               FAX20_FCQ_COMMAND   203
/                               FAX20_FCR_COMMAND   204
/                               FAX20_FCT_COMMAND   205
/                               FAX20_FDR_COMMAND   206
/                               FAX20_FDT_COMMAND   207
/                               FAX20_FEA_COMMAND   208
/                               FAX20_FFC_COMMAND   209
/                               FAX20_FIE_COMMAND   210
/                               FAX20_FIS_COMMAND   211
/                               FAX20_FKS_COMMAND   212
/                               FAX20_FLI_COMMAND   213
/                               FAX20_FLP_COMMAND   214
/                               FAX20_FMS_COMMAND   215
/                               FAX20_FNR_COMMAND   216
/                               FAX20_FNS_COMMAND   217
/                               FAX20_FPI_COMMAND   218
/                               FAX20_FPS_COMMAND   219
/                               FAX20_FRQ_COMMAND   220
/                               FAX20_FRY_COMMAND   221
/                               FAX20_FSP_COMMAND   222
/                               FAX20_FBS_REQUEST   223
/                               FAX20_FBO_REQUEST   224
/                               FAX20_FBU_REQUEST   225
/                               FAX20_FCC_REQUEST   226
/                               FAX20_FCQ_REQUEST   227
/                               FAX20_FCR_REQUEST   228
/                               FAX20_FCS_REQUEST   229
/                               FAX20_FCT_REQUEST   230
/                               FAX20_FEA_REQUEST   231
/                               FAX20_FFC_REQUEST   232
/                               FAX20_FHS_REQUEST   233
/                               FAX20_FIE_REQUEST   234
/                               FAX20_FIS_REQUEST   235
/                               FAX20_FLI_REQUEST   236
/                               FAX20_FLP_REQUEST   237
/                               FAX20_FMI_REQUEST   238
/                               FAX20_FMM_REQUEST   239
/                               FAX20_FMR_REQUEST   240
/                               FAX20_FMS_REQUEST   241
/                               FAX20_FNR_REQUEST   242
/                               FAX20_FNS_REQUEST   243
/                               FAX20_FPI_REQUEST   244
/                               FAX20_FPS_REQUEST   245
/                               FAX20_FRQ_REQUEST   246
/                               FAX20_FRY_REQUEST   247
/                               FAX20_FSP_REQUEST   248
/                               FAX20_FBO_QUERY     249
/                               FAX20_FBU_QUERY     250
/                               FAX20_FCC_QUERY     251
/                               FAX20_FCQ_QUERY     252
/                               FAX20_FCR_QUERY     253
/                               FAX20_FCT_QUERY     254
/                               FAX20_FDR_QUERY     255
/                               FAX20_FDT_QUERY     256
/                               FAX20_FEA_QUERY     257
/                               FAX20_FFC_QUERY     258
/                               FAX20_FIE_QUERY     259
/                               FAX20_FIS_QUERY     260
/                               FAX20_FKS_QUERY     261
/                               FAX20_FLI_QUERY     262
/                               FAX20_FLP_QUERY     263
/                               FAX20_FMS_QUERY     264
/                               FAX20_FNR_QUERY     265
/                               FAX20_FNS_QUERY     266
/                               FAX20_FPI_QUERY     267
/                               FAX20_FPS_QUERY     268
/                               FAX20_FRQ_QUERY     269
/                               FAX20_FRY_QUERY     270
/                               FAX20_FSP_QUERY     271
/
/                     ubyte     *command_parm_ptr
/                               Pointer to single parameter or pointer to a
/                               list of parameters with the first byte
/                               indicating the parameter count. In the list
/                               format, a parameter with a value of -1 indicates
/                               no change from the previous value. This does not
/                               apply to the last parameter in the list.
/
/                     ubyte     **response_ptr_ptr
/                               A pointer to a location where the address of
/                               the response string should be placed.
/
/
/   Output Parameters: ubyte    function return code
/                      0        Go to online
/                      1        Continue parsing
/                      2        Discard rest of command line
/                               and respond with ERROR message
/
/   Global Variables Changed: FAX parameter variables
/
/   Users:
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax20_execute_command(uword command, ubyte *command_parm_ptr, ubyte **response_ptr_ptr)
{
   ubyte return_code, *info_ptr;
   uword tx_size, tx_count, rx_size, rx_count, total_tx_size, total_rx_size;
   ubyte field,value;

   return_code = CONTINUE_PARSING;  /* default to successful execution */

   /* assign the first location of the string to the ACU pointer */
   *response_ptr_ptr = (ubyte *)fax2_info_array;

   /* initialize a working pointer to load in the data */
   info_ptr = (ubyte *)fax2_info_array;

   switch (command)
   {
      case FAX20_FBS_REQUEST:
         fax_dte_info(&tx_size, &tx_count, &rx_size, &rx_count);
         total_tx_size = rx_size;
         total_rx_size = tx_size;
         fax_line_info(&tx_size, &tx_count, &rx_size, &rx_count);
         total_tx_size += tx_size;
         total_rx_size += rx_size;
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_word_page(total_tx_size, &info_ptr);
         *info_ptr++ = ',';
         fax2_store_hex_word_page(total_rx_size, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FBO_REQUEST:
         value = fax2_data_bit_ordering + (fax2_hdlc_bit_ordering * 2);
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(value, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FBO_QUERY:
         fax20_store_string((ubyte *)FAX20_FBO_CAPABILITY, &info_ptr);
         break;

      case FAX20_FBO_COMMAND:
         /* Do error checking on command input */
         value = *command_parm_ptr;
         if (value <= 3)
         {
            fax2_data_bit_ordering = value % 2; /* bit 0 */
            fax2_hdlc_bit_ordering = value / 2; /* bit 1 */
         }
         else
         {
            return_code = TERMINATE_WITH_ERROR;
         }
         break;

      case FAX20_FBU_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_debug, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FBU_QUERY:
         fax20_store_string((ubyte *)FAX20_FBU_CAPABILITY, &info_ptr);
         break;

      case FAX20_FBU_COMMAND:
         /* Do error checking on command input */
         value = *command_parm_ptr;
         if (value <= 1)
            fax2_debug = value;
         else
            return_code = TERMINATE_WITH_ERROR;
         break;

      case FAX20_FCC_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_configuration_page(&fax2_capabilities, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FCC_QUERY:
         if (fax2_ECM_installed_page())
            if (modem_fax_capability() == BR_14400)
               fax20_store_string((ubyte *)FAX20_FCC144ECM_CAPABILITY, &info_ptr);
            else
               fax20_store_string((ubyte *)FAX20_FCC96ECM_CAPABILITY, &info_ptr);
         else
            if (modem_fax_capability() == BR_14400)
               fax20_store_string((ubyte *)FAX20_FCC144_CAPABILITY, &info_ptr);
            else
               fax20_store_string((ubyte *)FAX20_FCC96_CAPABILITY, &info_ptr);
         break;

      case FAX20_FCC_COMMAND:
         /*
            Structure of AT command parameter array for compound byte values:
            [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
               Examples:
               AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
               AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,,,,8  => [0x5,0x8, 0x00]
               AT+F=       => [0x00]
         */
         /* Eight Sub-Parameters this command:
            FCC=<vr>,<br>,<wd>,<ln>,<df>,<ec>,<bf>,<st> */
         do
         {
            /* Get AT command values from Parser array */
            field = *command_parm_ptr++;
            value = *command_parm_ptr++;

            /* Check bounds/range of paramter */
            if (field && (value > fax20_T30_range_array[field-1]))
               return TERMINATE_WITH_ERROR;

            /* Set valid paramter */
            switch (field)
            {
               case 0:  /* End of Parsed Parameters */
                  /* Initialize the T.30 session parameters with the
                     capability parameters */
                  fax2_session = fax2_capabilities;
                  break;

               case 1:  /* Vertical Res */
                  fax2_capabilities.VR = value;
                  break;

               case 2:  /* Bit Rate */
                  fax2_capabilities.BR = value;
                  break;

               case 3:  /* Page Width */
                  fax2_capabilities.WD = value;
                  break;

               case 4:  /* Page Length */
                  fax2_capabilities.LN = value;
                  break;

               case 5:  /* Compression */
                  fax2_capabilities.DF = value;
                  break;

               case 6:  /* Error Correction */
                  /* ECM is optionally installed... */
                  if (fax2_ECM_installed_page() || (value == 0))
                     fax2_capabilities.EC = value;
                  else
                     return TERMINATE_WITH_ERROR;
                  break;

               case 7:  /* Binary file transfer */
                  /* ECM (and BFT) is optionally installed... */
                  if (fax2_ECM_installed_page() || (value == 0))
                     fax2_capabilities.BF = value;
                  else
                     return TERMINATE_WITH_ERROR;
                  break;

               case 8:  /* Scan Time */
                  fax2_capabilities.ST = value;
                  break;

               default:  /* field out of bounds */
                  return TERMINATE_WITH_ERROR;
            } /* switch */
         } while (field);
         break;

      case FAX20_FCQ_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_qc_rx, &info_ptr);
         *info_ptr++ = ',';
         fax2_store_hex_byte_page(fax2_qc_tx, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FCQ_QUERY:
         if (fax2_qc_installed_page())
            fax20_store_string((ubyte *)FAX20_FCQ_CQ_CAPABILITY, &info_ptr);
         else
            fax20_store_string((ubyte *)FAX20_FCQ_NOCQ_CAPABILITY, &info_ptr);
         break;

      case FAX20_FCQ_COMMAND:
         /*
            Structure of AT command parameter array for compound byte values:
               [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
            Examples:
               AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
               AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,,,,8  => [0x5,0x8, 0x00]
               AT+F=       => [0x00]
         */
         /* Only 2 fields for +FCQ=<rq>,<tq> */
         do
         {
            /* Get AT command values from Parser */
            field = *command_parm_ptr++;
            value = *command_parm_ptr++;

            /* Verfiy and set AT command paramter */
            switch (field)
            {
               case 0:  /* End of Parsed Parameters */
                  break;

               case 1:  /* Rx Copy Quality parameter */
                  /* We currently not support receive quality correction
                     +FCQ=2. Only disabled (=0) and reporting (=1) */
                  if (value == 0 || value == 1 && fax2_qc_installed_page())
                     fax2_qc_rx = value;
                  else
                     return TERMINATE_WITH_ERROR;
                  break;

               case 2:  /* Tx Copy Quality parameter */
                  /* We currently do not support transmit quality
                     checking or correction */
                  if (!value)
                     fax2_qc_tx = 0;
                  else
                     return TERMINATE_WITH_ERROR;
                  break;

               default:  /* field out of bounds */
                  return TERMINATE_WITH_ERROR;
            } /* switch */
         } while (field);
         break;

      case FAX20_FCR_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_capability_receive, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FCR_QUERY:
         fax20_store_string((ubyte *)FAX20_FCR_CAPABILITY, &info_ptr);
         break;

      case FAX20_FCR_COMMAND:
         /* Only 0-1 are valid inputs for the +FCR command */
         if (*command_parm_ptr < 2)
            fax2_capability_receive= *command_parm_ptr;
         else
            return_code = TERMINATE_WITH_ERROR; /* command not allowed */
         break;

      case FAX20_FCS_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_configuration_page(&fax2_negotiated, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FCT_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_timeout, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FCT_QUERY:
         fax20_store_string((ubyte *)FAX20_FCT_CAPABILITY, &info_ptr);
         break;

      case FAX20_FCT_COMMAND:
         /* 0-0xFF bounds on this ubyte parameter */
         fax2_timeout = *command_parm_ptr;
         break;

      case FAX20_FDR_QUERY:
         break;

      case FAX20_FDR_COMMAND:
         if (fax2_connected) /* command only valid during a connection */
         {
            /* setup for background to execute the command */
            fax2_received_command = FDR_COMMAND; /* indicate command received */
            return_code = GOTO_ONLINE; /* continue with protocol */
            /* configure for APP to modem flow control */
            fax2_configure_dte = APP_TO_MODEM_FLOW;
         }
         else
            return_code = TERMINATE_WITH_ERROR; /* command not allowed */
         break;

      case FAX20_FDT_QUERY:
         break;

      case FAX20_FDT_COMMAND:
         if (fax2_connected) /* command only valid during a connection */
         {
            /* setup for background to execute the command */
            fax2_received_command = FDT_COMMAND; /* indicate command received */
            return_code = GOTO_ONLINE; /* continue with protocol */
            /* configure for modem to APP flow control */
            fax2_configure_dte = MODEM_TO_APP_FLOW;
         }
         else
            return_code = TERMINATE_WITH_ERROR; /* command not allowed */
         break;

      case FAX20_FEA_REQUEST:
         /* Intnetionally fall through */
      case FAX20_FEA_QUERY:
         fax20_store_string((ubyte *)FAX20_FEA_CAPABILITY, &info_ptr);
         break;

      case FAX20_FEA_COMMAND: /* not supported */
         /* Only 0 is currently supported for FEA command */
         if (*command_parm_ptr != 0)
            return_code = TERMINATE_WITH_ERROR;
         break;

      case FAX20_FFC_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         *info_ptr++ = '0'; *info_ptr++ = ',';
         *info_ptr++ = '0'; *info_ptr++ = ',';
         *info_ptr++ = '0'; *info_ptr++ = ',';
         *info_ptr++ = '0';
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FFC_QUERY:
         fax20_store_string((ubyte *)FAX20_FFC_CAPABILITY, &info_ptr);
         break;

      case FAX20_FFC_COMMAND:
         /*
            Structure of AT command parameter array for compound byte values:
               [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
            Examples:
               AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
               AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,,,,8  => [0x5,0x8, 0x00]
               AT+F=       => [0x00]
         */
         /* 4 fields for +FFC=<vcr>,<dfc>,<lmnc>,<wdc> */
         do
         {
            /* Get AT command values from Parser array */
            field = *command_parm_ptr++;
            value = *command_parm_ptr++;

            /* Only "disable" values are supported for all fields of the
               FFC (format conversion) command */
            if (field > 4 || value > 0)
               return TERMINATE_WITH_ERROR;
         } while (field);
         break;

      case FAX20_FHS_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_hangup_status, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FIE_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_interrupts_enabled, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FIE_QUERY:
         fax20_store_string((ubyte *)FAX20_FIE_CAPABILITY, &info_ptr);
         break;

      case FAX20_FIE_COMMAND:
         /* Only 0-1 are valid inputs for the +FIE command */
         if (*command_parm_ptr < 2)
            fax2_interrupts_enabled = *command_parm_ptr;
         else
            return_code = TERMINATE_WITH_ERROR; /* command not allowed */
         break;

      case FAX20_FIS_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_configuration_page(&fax2_session, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FIS_QUERY:
         if (fax2_ECM_installed_page())
            if (modem_fax_capability() == BR_14400)
               fax20_store_string((ubyte *)FAX20_FIS144ECM_CAPABILITY, &info_ptr);
            else
               fax20_store_string((ubyte *)FAX20_FIS96ECM_CAPABILITY, &info_ptr);
         else
            if (modem_fax_capability() == BR_14400)
               fax20_store_string((ubyte *)FAX20_FIS144_CAPABILITY, &info_ptr);
            else
               fax20_store_string((ubyte *)FAX20_FIS96_CAPABILITY, &info_ptr);
         break;

      case FAX20_FIS_COMMAND:
         /*
            Structure of AT command parameter array for compound byte values:
               [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
            Examples:
               AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
               AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
               AT+F=,,,,8  => [0x5,0x8, 0x00]
               AT+F=       => [0x00]
         */

         /* Eight Sub-Parameters this command:
            FIS =<vr>,<br>,<wd>,<ln>,<df>,<ec>,<bf>,<st> */
         do
         {
            /* Get AT command values from Parser array */
            field = *command_parm_ptr++;
            value = *command_parm_ptr++;

            /* Check bounds/range of paramter */
            if (field && (value > fax20_T30_range_array[field-1]))
               return TERMINATE_WITH_ERROR;

            /* Set field parameter */
            switch (field)
            {
               case 0:  /* End of Parsed Parameters */
                  break;

               case 1:  /* Vertical Res */
                  fax2_session.VR = value;
                  break;

               case 2:  /* Bit Rate */
                  fax2_session.BR = value;
                  break;

               case 3:  /* Page Width */
                  fax2_session.WD = value;
                  break;

               case 4:  /* Page Length */
                  fax2_session.LN = value;
                  break;

               case 5:  /* Compression */
                  fax2_session.DF = value;
                  break;

               case 6:  /* Error Correction */
                  /* ECM is optionally installed... */
                  if (fax2_ECM_installed_page() || (value == 0))
                     fax2_session.EC = value;
                  else
                     return TERMINATE_WITH_ERROR;
                  break;

               case 7:  /* Binary file transfer */
                  /* ECM (and BFT) is optionally installed... */
                  if (fax2_ECM_installed_page() || (value == 0))
                     fax2_session.BF = value;
                  else
                     return TERMINATE_WITH_ERROR;
                  break;

               case 8:  /* Scan Time */
                  fax2_capabilities.ST = value;
                  break;

               default:  /* field out of bounds */
                  return TERMINATE_WITH_ERROR;
            } /* switch */
         } while (field);
         break;

      case FAX20_FKS_QUERY:
         break;

      case FAX20_FKS_COMMAND:
         if (fax2_connected) /* command only valid during a connection */
         {
            if (fax2_line_configured) /* if line configured */
               fax2_cleanup_page(); /* terminate all configurations */
            fax2_state = PHASE_E; /* setup to disconnect */
            fax2_sub_state = SCHEDULE_DCN_PACKET;
            fax2_utility_state = INITIALIZE;
            fax2_hangup_status = FKS_ABORTED_CONNECTION;
            return_code = GOTO_ONLINE; /* continue with protocol */
         }
         break;

      case FAX20_FLI_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax20_store_string((ubyte *)fax2_local_id_string, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FLI_QUERY:
         fax20_store_string((ubyte *)FAX20_FLI_CAPABILITY, &info_ptr);
         break;

      case FAX20_FLI_COMMAND:
         /* The parser passes in a formatted string (\",...,\",0x0).
            So we only have to verify length */
         /* But first prepare for the null string (+FLI="") condition */
         field = 0;

         /* Test for non-null string */
         if (*command_parm_ptr++ == '"')
         {
            /* Only 20 chars are allowed in the string */
            while (field < 20 && *command_parm_ptr != '"')
               fax2_local_id_string[field++] = *command_parm_ptr++;

            /* Test for more than 20 chars on command line (string
               will not end with a \" char) */
            if (*command_parm_ptr != '"')
            {
               /* Set null string and error condition */
               field = 0;
               return_code = TERMINATE_WITH_ERROR;
            }
         }
         fax2_local_id_string[field] = '\0';
         break;

      case FAX20_FLP_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_capability_transmit_poll, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FLP_QUERY:
         fax20_store_string((ubyte *)FAX20_FLP_CAPABILITY, &info_ptr);
         break;

      case FAX20_FLP_COMMAND:
         /* Only 0-1 are valid inputs for the +FLP command */
         if (*command_parm_ptr < 2)
            fax2_capability_transmit_poll = *command_parm_ptr;
         else
            return_code = TERMINATE_WITH_ERROR; /* command not allowed */
         break;

      case FAX20_FMI_REQUEST:
         fax20_store_string((ubyte *)FAX20_FMI_IDENTIFICATION, &info_ptr);
         break;

      case FAX20_FMM_REQUEST:
         fax20_store_string((ubyte *)FAX20_FMM_IDENTIFICATION, &info_ptr);
         break;

      case FAX20_FMR_REQUEST:
         fax20_store_string((ubyte *)FAX20_FMR_IDENTIFICATION, &info_ptr);
         break;

      case FAX20_FMS_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_minimum_speed, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FMS_QUERY:
         if (modem_fax_capability() == BR_14400)
            fax20_store_string((ubyte *)FAX20_FMS144_CAPABILITY, &info_ptr);
         else
            fax20_store_string((ubyte *)FAX20_FMS96_CAPABILITY, &info_ptr);
         break;

      case FAX20_FMS_COMMAND:
         /* Only 0-5 are valid inputs for the +FMS command */
         if (*command_parm_ptr < 6)
            fax2_minimum_speed = *command_parm_ptr;
         else
            return_code = TERMINATE_WITH_ERROR; /* command not allowed */
         break;

      case FAX20_FNR_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_message_reporting.RPR, &info_ptr);
         *info_ptr++ = ',';
         fax2_store_hex_byte_page(fax2_message_reporting.TPR, &info_ptr);
         *info_ptr++ = ',';
         fax2_store_hex_byte_page(fax2_message_reporting.IDR, &info_ptr);
         *info_ptr++ = ',';
         fax2_store_hex_byte_page(fax2_message_reporting.NSR, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FNR_QUERY:
         fax20_store_string((ubyte *)FAX20_FNR_CAPABILITY, &info_ptr);
         break;

      case FAX20_FNR_COMMAND:
         /*
            Structure of AT command parameter array for compound byte values:
               [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
            Examples:
               AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
               AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
                  AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
                  AT+F=,,,,8  => [0x5,0x8, 0x00]
                  AT+F=       => [0x00]
         */

         /* Four Sub-Parameters this command: +FNR=<rpr>,<tpr>,<idr>,<nsr> */
         do
         {
            /* Get AT command values from Parser array */
            field = *command_parm_ptr++;
            value = *command_parm_ptr++;

            /* Check bounds of paramter: all values are 0-1 for +FNR= */
            if (field && value > 2)
               return TERMINATE_WITH_ERROR;

            /* Else set values */
            switch (field)
            {
               default:  /* field out of bounds */
                  return_code = TERMINATE_WITH_ERROR;
                  /* Intentionally fall-through to "End" case */

               case 0:  /* End of Parsed Parameters */
                  break;

               case 1:  /* RX parameter reporting */
                  fax2_message_reporting.RPR = value;
                  break;

               case 2:  /* TX parameter reporting */
                  fax2_message_reporting.TPR = value;
                  break;

               case 3:  /* ID string parameter reporting */
                  fax2_message_reporting.IDR = value;
                  break;

               case 4:  /* Non-Standard frame reporting */
                  fax2_message_reporting.NSR = value;
                  break;
            } /* switch */
         } while (field);
         break;

      case FAX20_FNS_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax20_store_string((ubyte *)fax2_nonstandard_string, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FNS_QUERY:
         fax20_store_string((ubyte *)FAX20_FNS_CAPABILITY, &info_ptr);
         break;

      case FAX20_FNS_COMMAND:
         /* This command appends the newly assigned string to the existing */
         /* string. The string is cleared by assigning a null string */
         /* The parser passes in a formatted string (\",...,\",0x0).
            So we only have to verify length */

         field = 0;  /* Prepare for null-string */
         if ((*command_parm_ptr++ == '"') && (*command_parm_ptr != '"'))
         {
            /* First find the end of the current string... */
            for (; fax2_nonstandard_string[field]; field++);

            /* Only 180 chars total are allowed in the string */
            for (; field<180; field++)
            {
               /* Get character from parser */
               value = *command_parm_ptr++;

               /* Only hexadecimal pairs (per spec.) */
               if ((value>='0' && value<='9') || (value>='A' && value<='F'))
                  fax2_nonstandard_string[field] = value;
               /* Also ignore space characters */
               else if (value == ' ')
                  ;
               /* Test for end of string */
               else if (value == '"')
               {
                  /* Error if not in pairs */
                  if (field % 2)
                  {
                     field=0;
                     return_code = TERMINATE_WITH_ERROR;
                  }
                  break; /* Exit for-loop */
               }
               /* Else invalid char input */
               else
               {
                  return_code = TERMINATE_WITH_ERROR;
                  break; /* Exit for-loop */
               }
            }
         }
         fax2_nonstandard_string[field] = 0;
         break;

      case FAX20_FPI_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax20_store_string((ubyte *)fax2_polling_id_string, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FPI_QUERY:
         fax20_store_string((ubyte *)FAX20_FPI_CAPABILITY, &info_ptr);
         break;

      case FAX20_FPI_COMMAND:
         /* The parser passes in a formatted string (\",...,\",0x0).
            So we only have to verify length */
         /* But first prepare for the null string (+FPI="") condition */
         field = 0;

         /* Test for non-null string */
         if (*command_parm_ptr++ == '"')
         {
            /* Only 20 chars are allowed in the string */
            while (field < 20 && *command_parm_ptr != '"')
               fax2_polling_id_string[field++] = *command_parm_ptr++;

            /* Test for more than 20 chars on command line (string
               will not end with a \" char) */
            if (*command_parm_ptr != '"')
            {
               /* Set null string and error condition */
               field = 0;
               return_code = TERMINATE_WITH_ERROR;
            }
         }
         fax2_polling_id_string[field] = '\0';
         break;

      case FAX20_FPS_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_pp_response, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FPS_QUERY:
         fax20_store_string((ubyte *)FAX20_FPS_CAPABILITY, &info_ptr);
         break;

      case FAX20_FPS_COMMAND:
         /* NOTE: Do not allow RTP/RTN if in ECM per T.30 Annex A */
         switch (*command_parm_ptr)
         {
            case MCF_PPR:
               break;

            case RTN_PPR:
            case RTP_PPR:
               /* Do not allow RTP/RTN if in ECM per T.30 Annex A */
               if (fax2_negotiated.EC)
                  return_code = TERMINATE_WITH_ERROR;
               break;

            case PIN_PPR:
               /* Do not allow RTP/RTN if in ECM per T.30 Annex A */
               if (fax2_negotiated.EC)
                  return_code = TERMINATE_WITH_ERROR;
               /* If a procedure interrupt is requested and one has not been
                  received from the remote end, set an appropriate flag */
               else
                  fax2_local_generated_interrupt = TRUE;
               break;

            case PIP_PPR:
               /* If a procedure interrupt is requested and one has not been
                  received from the remote end, set an appropriate flag */
               fax2_local_generated_interrupt = TRUE;
               break;

            default:
               return_code = TERMINATE_WITH_ERROR;
               break;
         }
         if (return_code != TERMINATE_WITH_ERROR)
            fax2_pp_response = *command_parm_ptr;
         break;

      case FAX20_FRQ_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_qt_pgl, &info_ptr);
         *info_ptr++ = ',';
         fax2_store_hex_byte_page(fax2_qt_cbl, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FRQ_QUERY:
         fax20_store_string((ubyte *)FAX20_FRQ_CAPABILITY, &info_ptr);
         break;

      case FAX20_FRQ_COMMAND:
         /*
            Structure of AT command parameter array for compound byte values:
               [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
            Examples:
               AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
               AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
                  AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
                  AT+F=,,,,8  => [0x5,0x8, 0x00]
                  AT+F=       => [0x00]
         */

         /* Two Sub-Parameters this command: +FRQ=<pgl>,<cbl> */
         do
         {
            /* Get AT command values from Parser array */
            field = *command_parm_ptr++;
            value = *command_parm_ptr++;

            /* Else set values */
            switch (field)
            {
               case 0:  /* End of Parsed Parameters */
                  break;

               case 1:  /* Percentage of good lines parameter */
                  if (value > 0x64)
                     return_code = TERMINATE_WITH_ERROR;
                  else
                     fax2_qt_pgl = value;
                  break;

               case 2:  /* max tolerable bad lines parameter */
                  /* No bounds on this parm. */
                  fax2_qt_cbl = value;
                  break;

               default:  /* field out of bounds */
                  return_code = TERMINATE_WITH_ERROR;
            } /* switch */
         } while (field);
         break;

      case FAX20_FRY_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_ECM_retry_count, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FRY_QUERY:
         fax20_store_string((ubyte *)FAX20_FRY_CAPABILITY, &info_ptr);
         break;

      case FAX20_FRY_COMMAND:
         fax2_ECM_retry_count = *command_parm_ptr;
         break;

      case FAX20_FSP_REQUEST:
         *info_ptr++ = CR; *info_ptr++ = LF;
         fax2_store_hex_byte_page(fax2_capability_receive_poll, &info_ptr);
         *info_ptr++ = CR; *info_ptr++ = LF;
         break;

      case FAX20_FSP_QUERY:
         fax20_store_string((ubyte *)FAX20_FSP_CAPABILITY, &info_ptr);
         break;

      case FAX20_FSP_COMMAND:
         /* Only 0-1 are valid inputs for the +FSP command */
         if (*command_parm_ptr < 2)
            fax2_capability_receive_poll = *command_parm_ptr;
         else
            return_code = TERMINATE_WITH_ERROR; /* command not allowed */
         break;

      default: /* this should never be reached */
         return_code = TERMINATE_WITH_ERROR;
         break;
   }

   /* terminate the response string */
   *info_ptr = '\0';

   return(return_code);
}

/******************************************************************************
/
/   Routine: fax20_store_string
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine copys a string.
/
/   Input Parameters: ubyte *   pointer to string (NULL terminated)
/                     ubyte **  string_ptr_ptr
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax20_execute_command()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax20_store_string(ubyte *string_ptr, ubyte **string_ptr_ptr)
{
   while (*string_ptr) /* copy all characters until a NULL is reached */
      *(*string_ptr_ptr)++ = *string_ptr++;
   *(*string_ptr_ptr)++ = '\0';
}
