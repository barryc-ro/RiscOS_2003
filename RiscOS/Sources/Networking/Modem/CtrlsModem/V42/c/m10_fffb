/****************************************************************************
/
/       Copyright, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995.
/       All Rights Reserved by:
/               RSA
/               7701 Six Forks Road
/               Suite 120
/               Raleigh, NC  27615
/               (919) 846-7171
/
/
/       This document contains material confidential to RSA its contents must
/       not be revealed, used or disclosed to anyone or company with out
/       written permission by RSA.  The information contained herein is solely
/       for the use of RSA.
/
/       File:           M10_FFFB.C
/
/       Module Version: 4.02
/
/       Function:       This file contains the MNP 10 Fallforward and
/                       Fallback code.
/
/       Product:        V.42/V.42bis
/
/       History:
/
/           Created:
/                       11/1/94 (V4.01) - Add ETC and MNP10 updates
/
/           ---------------------------------------------------------
/           -                   Modifications                       -
/           ---------------------------------------------------------
/
/           Author & Date:	RSA
/           Description:
/           Reason:
/
*****************************************************************************/
#include "sys_def.h"
#include "m10_def.h"

#include "v42.edf"
#include "mnp_if.edf"
#include "m10_lib.edf"
#include "m10_lm.edf"
#include "dp10.edf"

ubyte proc_mnp10_retrain_bg(void);
ubyte process_nonv32_fallback(void);
ubyte process_v32_speed_shift(void);
ubyte fallback_allowed(void);
ubyte process_nonv32_fallforward(void);
ubyte fallforward_allowed(void);

extern ubyte mnp10_BLER;
extern ubyte mnp10_initial_upshift;
extern ubyte mnp10_fffb_state;
extern ubyte mnp10_fb_retry_count;
extern uword shift_timer;
extern uword mnp10_100ms_timer;
extern ubyte mnp10_100ms_timer_started;
extern uword mnp10_answ_timer;
extern ubyte mnp10_rcv_lm__fb_cmd;
extern ubyte mnp10_rcv_lm__fb_ack;
extern ubyte mnp10_failed_fallforward;
extern uword mnp10_cd_wait_time;
extern ubyte mnp10_rr_fail_flag;
extern ubyte mnp10_v32bis;
extern ubyte mnp10_current_speed;
extern uword mnp10_possible_rates;
extern ubyte mnp10_fb_negot;
extern uword FFI_timer;
extern ubyte mnp10_ff_negot;
extern ubyte mnp10_startup_mode;
extern ubyte mnp_startup_mode;
extern ubyte mnp10_initiator;
extern ubyte mnp10_neg_cellular;
extern ubyte mnp10_tx_level;
extern ubyte mnp10_fallback_APS_count;
extern ubyte mnp10_carrier_loss;
extern ubyte mnp10_rcv_lm__ff_nak;
extern ubyte mnp10_rcv_lm__ff_ack;
extern ubyte mnp10_rcv_lm__ff_cmd;
extern ubyte mnp10_orig_speed;
extern ubyte mnp10_frame_rcvd;
extern ubyte mnp10_resend_packet_count;
extern ubyte mnp10_number_of_retrains;
extern ubyte mnp10_rcvd_non_lm__ff_ack;
extern ubyte mnp10_EQM10_value;
extern ubyte mnp10_retrain_state;
extern uword FFI_default_time;
extern uword FBI_timer;
extern ubyte baud_rate;

extern uword dynamic_txmax;
extern ubyte tx_busy_flag;
extern ubyte *tx_holding;


/*******************************************************************************
/
/	Routine: proc_mnp10_retrain_bg
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine perform the background processing for the
/		      MNP 10 retrain, fallback, or fallforward procedures.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte background status
/				0  -  Operation in progress
/				1  -  fallforward succeeded
/				2  -  fallforward failed
/				3  -  fallback succeeded
/				4  -  fallback failed
/				5  -  Retrain succeeded
/				6  -  Retrain failed
/				7  -  Disconnect link
/				8  -  Halt link
/
/	Global Variables Changed: mnp10_100ms_timer, mnp10_retrain_state, shift_timer
/				  mnp10_number_of_retrains, mnp10_initiator,
/				  mnp10_resend_packet_count,mnp10_rcv_lm__fb_cmd,
/				  mnp10_rcv_lm__fb_ack, mnp10_fb_retry_count,
/				  mnp10_fffb_state, mnp10_current_speed,
/				  FFI_timer, mnp10_rcv_lm__ff_ack,
/				  mnp10_rcv_lm__ff_cmd, mnp10_lm_ack_count,
/				  mnp10_rcvd_non_lm__ff_ack, mnp10_failed_fallforward
/
/	Users: mnp_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte proc_mnp10_retrain_bg(void)
{
    ubyte status,speed;

    switch (mnp10_retrain_state)
    {
        case INIT_RETRAIN:
            /*	Set up staggered delay before retrain times so that if the line
                has noise in both directions, both modems will not retrain
                at the same time. */
            if (!mnp_startup_mode)
                mnp10_100ms_timer = RETRAIN_DELAY_ORIG;
            else
                mnp10_100ms_timer = RETRAIN_DELAY_ANSW;

            mnp10_retrain_state = WAIT_RTDET;
            break;

        case WAIT_RTDET:
            if (!mnp10_100ms_timer)
            {
                mnp10_retrain_state = ISSUE_RETRAIN;
            }

            if (dp10_detect_retrain())
            {
                mnp10_100ms_timer = WAIT_FOR_RETRAIN_TIME;
                mnp10_retrain_state = WAIT_RETRAIN_COMPLETE;
            }
            break;

        case ISSUE_RETRAIN:
            /*	Update the transmit level before issuing retrain.	*/
            if (mnp10_neg_cellular)
            {
                update_tx_level();
                dp10_set_tx_level(mnp10_tx_level);
            }

            dp10_retrain();

            /* How long should the retrain last? */
            if (mnp10_current_speed == BPS2400)
                mnp10_100ms_timer = V22BIS_RETRAIN_TIME;
            else
                mnp10_100ms_timer = WAIT_FOR_RETRAIN_TIME;

            mnp10_retrain_state = WAIT_RETRAIN_COMPLETE;
            break;

        case WAIT_RETRAIN_COMPLETE:
            status = dp10_rtrn_rr_status();
            if ((status == DP10_RTRN_RR_STATUS__FAIL) ||
                !mnp10_100ms_timer)
            {
                mnp10_retrain_state = INIT_RETRAIN;
                mnp10_number_of_retrains++;
                if (mnp10_number_of_retrains == 3)
                {
                    if (fallback_allowed())
                    {
                        mnp10_retrain_state = INITIATE_FALLBACK;
                        return (MNP10_RETRAIN__RETRAIN_FAIL);
                    }
                    else
                    {
                        return (MNP10_RETRAIN__HALT);
                    }
                }
            }
            else if (status == DP10_RTRN_RR_STATUS__OK)
            {
                mnp10_retrain_state = RETRAIN_TX_MNP_FRAME;
            }
            break;

        case RETRAIN_TX_MNP_FRAME:
            if (!tx_busy_flag)
            {
                mnp10_100ms_timer = mnp10_cd_wait_time;
                mnp10_resend_packet_count = 100;
                mnp10_frame_rcvd = FALSE;
                mpg_build_la_init();
                mpg_send_la();
                mnp10_retrain_state = RETRAIN_COMPLETE_FALLBACK;
            }
            break;

        case RETRAIN_COMPLETE_FALLBACK:
            if (mnp10_resend_packet_count == 0)
                mnp10_resend_packet_count = 100;

            /* If the retrain times out...*/
            if (mnp10_100ms_timer == 0)
            {
                mnp10_resend_packet_count = 0;
                /* If no ACK for our 100 LA's, fallback or retrain again */
                if (fallback_allowed())
                    mnp10_retrain_state = INITIATE_FALLBACK;
                else
                    mnp10_retrain_state = INIT_RETRAIN;
            }

            if (mnp10_frame_rcvd)
            {
                mnp10_resend_packet_count = 0;
                return (MNP10_RETRAIN__RETRAIN_OK);
            }
            break;

        case ACCEPT_FALLBACK:
            /* Send a fallback ACK if we're not sending data AND
                we're not sending another LM-I */
            if ((!tx_busy_flag) && mnp10_clear_to_build_lm())
            {
                mnp10_build_lm(LM_TYPE__FB_ACK);
                mnp10_send_lm();
                mnp10_initiator = FALSE;
                mnp10_retrain_state = FB_DETERMINE_TYPE;
                mnp10_100ms_timer = MSEC_200;
            }
            break;

        case INITIATE_FALLBACK:
            /* Wait for all packets to be sent before sending the
                FB CMD - including buffered LM-I's */
            if ((!tx_busy_flag) && mnp10_clear_to_build_lm())
            {
                mnp10_build_lm(LM_TYPE__FB_CMD);
                mnp10_resend_packet_count = 6;
                mnp10_send_lm();
                mnp10_retrain_state = WAIT_TO_SEND_FB_CMD;
                mnp10_rcv_lm__fb_cmd = FALSE;
                mnp10_rcv_lm__fb_ack = FALSE;
            }
            break;

        case WAIT_TO_SEND_FB_CMD:
            if (!mnp10_resend_packet_count)
            {
                mnp10_100ms_timer = SEC_1;
                mnp10_retrain_state = INIT_FB_WAIT_RESPONSE;
            }
            break;

        case INIT_FB_WAIT_RESPONSE:
            if (mnp10_rcv_lm__fb_cmd)
            {
                mnp10_rcv_lm__fb_cmd = FALSE;
                mnp10_retrain_state = ACCEPT_FALLBACK;
            }

            if (mnp10_rcv_lm__fb_ack || !dp10_check_CD() ||
                !mnp10_100ms_timer)
            {
                mnp10_100ms_timer = 0;
                mnp10_rcv_lm__fb_ack = FALSE;
                mnp10_retrain_state = FB_DETERMINE_TYPE;
                mnp10_initiator = TRUE;
            }
            break;

        case FB_DETERMINE_TYPE:
            mnp10_fb_retry_count = 0;
            mnp10_fffb_state = INIT;
            mnp10_startup_mode = mnp_startup_mode;
            /*	If initial upshift failed need to fallback to the
                original connect speed. */
            if (mnp10_initial_upshift)
            {
                mnp10_current_speed = mnp10_orig_speed;
            }
            else
            {
                mnp10_current_speed = update_mnp10_speed(FALLBACK);
            }

            /*	Update the transmit level based upon the old modulation rate */
            update_tx_level();

            dp10_set_line_speed(mnp10_current_speed);
            mnp10_retrain_state = PROC_FALLBACK;
            break;

        case PROC_FALLBACK:
            if (mnp10_current_speed >= BPS4800 &&
                mnp10_current_speed <= BPS14400)
            {
                status = process_v32_speed_shift();
            }
            else
            {
                status = process_nonv32_fallback();
            }

            if (status == FALLBACK_SUCCESSFUL)
            {
                mnp10_100ms_timer = SEC_1 * 5;
                mnp10_frame_rcvd = FALSE;
                mnp10_retrain_state = TRANSMIT_MNP_FRAME;
            }
            else if (status == FALLBACK_FAILED)
            {
                mnp10_retrain_state = FAILED_FALLBACK;
            }
            break;

        case TRANSMIT_MNP_FRAME:
            if (!tx_busy_flag)
            {
                mnp10_resend_packet_count = 100;
                mpg_build_la_init();
                mpg_send_la();
                mnp10_retrain_state = COMPLETE_FALLBACK;
            }
            break;

        case COMPLETE_FALLBACK:
            /* Stream LA's until time out */
            if (mnp10_resend_packet_count == 0)
                mnp10_resend_packet_count = 100;

            if (!mnp10_100ms_timer)
            {
                mnp10_resend_packet_count = 0;
                if (mnp10_current_speed > BPS1200)
                {
                    mnp10_retrain_state = FB_DETERMINE_TYPE;
                }
                else
                {
                    mnp10_retrain_state = FAILED_FALLBACK;
                }
            }
            if (mnp10_frame_rcvd)
            {
                /*	Reinitialize variables after successful fallback	*/
                FBI_timer = SEC_1 * 10;
                FFI_timer = FFI_default_time = MIN_1;
                mnp10_EQM10_value = 0;
                mnp10_fb_retry_count = 0;
                mnp10_resend_packet_count = 0;
                mnp10_fallback_APS_count = APS_FALLBACK_COUNT;
                /* Reset "initial_upshift" after upshift (may have) failed */
                mnp10_initial_upshift = FALSE;
                return (MNP10_RETRAIN__FB_OK);
            }
            break;

        case FAILED_FALLBACK:
            if (mnp10_neg_cellular && mnp10_fb_retry_count <= 2)
            {
                mnp10_current_speed = BPS1200;
                dp10_set_line_speed(mnp10_current_speed);
                mnp10_retrain_state = PROC_FALLBACK;
                mnp10_fffb_state = INIT;
            }
            else
            {
                /*	If fallback due to carrier lost and the fallback fails,
                    we want to halt V.42 and not try to send out the
                    LD packets. */
                if (mnp10_carrier_loss)
                {
                    mnp10_carrier_loss = FALSE;
                    return (MNP10_RETRAIN__HALT);
                }
                return (MNP10_RETRAIN__DISCONN);
            }
            break;

        case ACCEPT_FALLFORWARD:
            /* If the remote aborts the FF, it'll send a data packet
                so abort as well */
            if (mnp10_frame_rcvd)
                return (MNP10_RETRAIN__FF_OK);

            /* Send the FF ACK as soon as the holding ptr clears */
            if (tx_holding == 0)
            {
                mnp10_build_lm(LM_TYPE__FF_ACK);
                mnp10_send_lm();
                mnp10_retrain_state = FF_DETERMINE_TYPE;
                mnp10_initiator = FALSE;
                mnp10_100ms_timer = MSEC_200;
            }
            break;

        case INITIATE_FALLFORWARD:
            /* Wait for all packets to be sent before sending the
                FF CMD - including buffered LM-I's */
            if ((!tx_busy_flag) && mnp10_clear_to_build_lm())
            {
                mnp10_build_lm(LM_TYPE__FF_CMD);
                mnp10_send_lm();
                mnp10_100ms_timer = SEC_1 * 4;
                mnp10_retrain_state = FF_WAIT_RESPONSE;
                mnp10_rcv_lm__ff_nak = FALSE;
                mnp10_rcv_lm__ff_ack = 0;
                mnp10_rcv_lm__ff_cmd = FALSE;
            }
            break;

        case FF_WAIT_RESPONSE:
            if (!mnp10_100ms_timer)
            {
                /*	If timer expires before response is received need to
                    double the fallforward interval timer. */
                if (FFI_default_time < MIN_1 * 32)
                    FFI_default_time *= 2;
                FFI_timer = FFI_default_time;
                return (MNP10_RETRAIN__FF_FAIL);
            }
            else if (mnp10_rcv_lm__ff_nak)
            {
                /*	If fallforward command was NAKed need to set the
                    fallforward interval timer to 2 seconds. */
                mnp10_rcv_lm__ff_nak = FALSE;
                FFI_timer = FFI_default_time = MIN_1 * 2;
                return (MNP10_RETRAIN__FF_FAIL);
            }
            else if (mnp10_rcv_lm__ff_ack)
            {
                mnp10_rcv_lm__ff_ack = 0;
                mnp10_retrain_state = FF_DETERMINE_TYPE;
                mnp10_initiator = TRUE;
                mnp10_100ms_timer = 0;
            }
            else if (mnp10_rcv_lm__ff_cmd)
            {
                mnp10_rcv_lm__ff_cmd = FALSE;
                mnp10_retrain_state = ACCEPT_FALLFORWARD;
            }
            break;

        case FF_DETERMINE_TYPE:
            mnp10_fffb_state = INIT;
            mnp10_startup_mode = mnp_startup_mode;
            /*	If this is the initial upshift do not update
                mnp10_current_speed. It was set in mnp10_retrain_init(). */
            if (!mnp10_initial_upshift)
            {
                mnp10_current_speed = update_mnp10_speed(FALLFORWARD);
            }
            /* Else compute feasable speed for V.32 initial upshift */
            else if (mnp10_orig_speed >= BPS4800)
            {
                /* This is the last upshfit */
                mnp10_initial_upshift = FALSE;

                /* Get "feasible" speed from data pump */
                speed = dp10_get_v32_upshift_speed();

                /* If the pump thinks we should be lower or equal
                    to the current speed, stay at the same rate.
                    This is a fallforward state, not fallback. */
                if (speed <= mnp10_orig_speed)
                {
                    mnp10_current_speed = mnp10_orig_speed;
                }
                /* Else if the pump thinks we should be lower than
                    the max rate, use the pump's "feasible" rate */
                else if (speed < mnp10_current_speed)
                {
                    mnp10_current_speed = speed;
                }
                /* Else use the rate from retrain init() already in
                    "mnp10_current_speed" */
            }

            /*	Update the transmit level based upon the old modulation rate */
            update_tx_level();

            dp10_set_line_speed(mnp10_current_speed);
            mnp10_retrain_state = PROC_FALLFORWARD;
            break;

        case PROC_FALLFORWARD:
            if (mnp10_orig_speed >= BPS4800 &&
                mnp10_orig_speed <= BPS14400)
            {
                status = process_v32_speed_shift();
            }
            else
            {
                status = process_nonv32_fallforward();
            }
            if (status == FALLFORWARD_SUCCESSFUL)
            {
                if (mnp10_initiator)
                {
                    mnp10_retrain_state = COMPLETE_FALLFORWARD;
                }
                else
                {
                    mnp10_rcv_lm__ff_ack = 0;
                    mnp10_retrain_state = COMPLETE_ACCEPT_FALLFORWARD;
                }
            }
            else if (status == FALLFORWARD_FAILED)
            {
                mnp10_retrain_state = FALLFORWARD_PROC_FAILED;
            }
            break;

        case COMPLETE_ACCEPT_FALLFORWARD:
            if (!shift_timer || mnp10_rcv_lm__fb_cmd || !dp10_check_CD())
            {
                mnp10_retrain_state = FALLFORWARD_PROC_FAILED;
            }

            if (mnp10_rcv_lm__ff_ack >= 10)
            {
                mnp10_rcv_lm__ff_ack = 0;
                mnp10_retrain_state = COMPLETE_FALLFORWARD;
            }

            /*	Fallforward acceptance is skipped when a non-FF_ACK is rx'ed */
            if (mnp10_frame_rcvd)
            {
                mnp10_frame_rcvd = FALSE;
                mnp10_resend_packet_count = 0;
                mnp10_retrain_state = FALLFORWARD_IS_SUCCESSFUL;
            }
            break;

        case COMPLETE_FALLFORWARD:
            /* Wait for all packets to be sent before sending the
                FF ACK - including buffered LM-I's */
            if ((!tx_busy_flag) && mnp10_clear_to_build_lm())
            {
                mnp10_resend_packet_count = 100;
                mnp10_build_lm(LM_TYPE__FF_ACK);
                mnp10_send_lm();
                mnp10_frame_rcvd = FALSE;
                mnp10_rcv_lm__ff_ack = 0;
                mnp10_retrain_state = WAIT_COMPLETE_ACK;
            }
            break;

        case WAIT_COMPLETE_ACK:
            /* Stream LA's until time-out */
            if (mnp10_resend_packet_count == 0)
                mnp10_resend_packet_count = 100;

            if (!shift_timer || mnp10_rcv_lm__fb_cmd ||
                !dp10_check_CD())
            {
                mnp10_rcv_lm__fb_cmd = FALSE;
                mnp10_resend_packet_count = 0;
                mnp10_retrain_state = FALLFORWARD_PROC_FAILED;
            }

            /*	Fallforward is complete when a MNP frame is received	*/
            if (mnp10_frame_rcvd)
            {
                mnp10_frame_rcvd = FALSE;
                mnp10_resend_packet_count = 0;
                mnp10_retrain_state = FALLFORWARD_IS_SUCCESSFUL;
            }
            if (mnp10_initiator && (mnp10_rcv_lm__ff_ack >= 10))
            {
                mnp10_rcv_lm__ff_ack = 0;
                mnp10_resend_packet_count = 0;
                mnp10_retrain_state = FALLFORWARD_IS_SUCCESSFUL;

                /* If *h1 and )m1 upshift send a on non-ff_ack end
                    answerer's FF verification */
                if (mnp10_initial_upshift && mnp10_neg_cellular &&
                    (mnp10_current_speed == BPS4800))
                {
                    mpg_build_la_init();
                    mpg_send_la();
                }
            }

            /* Code for initial upshifting when cellular and connecting
                w/an older Microcom.  The older Microcoms change
                tx levels durring the rate regegotiation, so we need
                to force a retrain.
            */
            else if (mnp10_initial_upshift &&
                mnp10_neg_cellular &&
                (mnp10_rcv_lm__ff_ack >= 35) &&
                (mnp10_current_speed >= BPS4800))
            {
                mnp10_rr_fail_flag = FORCE_RETRAIN;
                mnp10_retrain_state = PROC_FALLFORWARD;
            }
            break;

        case FALLFORWARD_IS_SUCCESSFUL:
            /*	Reinitialize variables after successful fallforward	*/
            FFI_timer = FFI_default_time = MIN_1;
            FBI_timer = SEC_1 * 10;
            mnp10_EQM10_value = 0;
            shift_timer = 0;
            mnp10_rcvd_non_lm__ff_ack = FALSE;

            /*	If cellular and initial upshift to 4800 was completed then
                determine if a higher V.32 and/or V.32bis speed is available.
                If so then upshift to this higher speed. */
            speed = highest_negot_speed();
            if (mnp10_neg_cellular && mnp10_initial_upshift &&
                (mnp10_current_speed == BPS4800) &&
                (speed > BPS4800) )
            {
                /* If originator, allow time for remote to calculate
                    new tx level.   Required for Micrcom s/w rev. 2.2 */
                if (mnp10_orig_speed == BPS1200 &&
                    mnp10_startup_mode == ORIGINATE)
                    mnp10_100ms_timer = 2; /* Delay for process_v32_speed_shift() */
                else
                    mnp10_100ms_timer = 0;

                mnp10_retrain_state = FF_DETERMINE_TYPE;
                mnp10_orig_speed = mnp10_current_speed;
                mnp10_current_speed = speed;
                return (MNP10_RETRAIN__IN_PROG);
            }
            mnp10_initial_upshift = FALSE;
            mnp10_fallback_APS_count = APS_FALLBACK_COUNT;

            return (MNP10_RETRAIN__FF_OK);

        case FALLFORWARD_PROC_FAILED:
            if (FFI_default_time < MIN_1 * 32)
                FFI_default_time *= 2;
            FFI_timer = FFI_default_time;
            mnp10_resend_packet_count = 0;
            mnp10_retrain_state = FB_DETERMINE_TYPE;
            mnp10_failed_fallforward = TRUE;
            return (MNP10_RETRAIN__FF_FAIL);
    } /* switch */

    return (MNP10_RETRAIN__IN_PROG);
}


/*******************************************************************************
/
/	Routine: process_nonv32_fallback
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine will execute a fallback to a NON-V32
/		      speed.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte background status
/				0  -  Operation in progress
/				1  -  fallback succeeded
/				2  -  fallback failed
/
/	Global Variables Changed: mnp10_fffb_state, mnp10_100ms_timer, shift_timer
/				  mnp10_fb_retry_count, mnp10_current_speed
/				  mnp10_rcv_lm__fb_cmd, mnp10_rcv_lm__fb_ack,
/				  mnp10_failed_fallforward
/
/	Users: mnp10_retrain_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte process_nonv32_fallback(void)
{
    ubyte status;

    switch (mnp10_fffb_state)
    {
        case INIT:
            if (!mnp10_100ms_timer)
            {
                /*	Turn off the transmitter	*/
                dp10_mute_transmitter();
                mnp10_fb_retry_count++;
                mnp10_100ms_timer = SEC_1 * 8;
                mnp10_fffb_state = FB_WAIT_FOR_CD_LOSS;
            }
            break;

        case FB_WAIT_FOR_CD_LOSS:
            if (!dp10_check_CD())
            {
                mnp10_initial_upshift = FALSE;
                dp10_reset_connection();
                mnp10_fffb_state = START_FALLBACK;
                mnp10_100ms_timer = MSEC_250;
            }
            else if (!mnp10_100ms_timer)
            {
                if (mnp10_initial_upshift)
                {
                    mnp10_initial_upshift = FALSE;
                    dp10_reset_connection();
                    mnp10_fffb_state = START_FALLBACK;
                    mnp10_100ms_timer = MSEC_250;
                }
                else
                    return (FALLBACK_FAILED);
            }
            break;


        case START_FALLBACK:
            if (!mnp10_100ms_timer)
            {
                /*	This timer is set to 25 seconds.	*/
                shift_timer = SEC_1 * 25;
                if (mnp10_startup_mode)
                {
                    mnp10_fffb_state = PROC_ANSW_FB;
                }
                else
                {
                    mnp10_fffb_state = PROC_ORIG_FB;
                }
            }
            break;

        case PROC_ANSW_FB:
            /*	Setup modem to look for Answer tone (2100hz)	*/
            dp10_init_answ_tone_detc();
            mnp10_100ms_timer = SEC_1 * 12;
            mnp10_fffb_state = WAIT_FOR_ANSW_TONE;
            break;

        case WAIT_FOR_ANSW_TONE:
            if (!mnp10_100ms_timer)
            {
                mnp10_fffb_state = CHECK_FB_CONTINUE;
            }
            /*	Look for 200 msecs of answer tone (2100hz)	*/
            else if (dp10_answ_tone_detc() == TRUE)
            {
                mnp10_100ms_timer = SEC_1 * 3;
                mnp10_100ms_timer_started = FALSE;
                mnp10_fffb_state = WAIT_FOR_SILENCE;
            }
            break;

        case WAIT_FOR_SILENCE:
            if (!mnp10_100ms_timer)
            {
                mnp10_fffb_state = CHECK_FB_CONTINUE;
            }

            /*	Look for Answer tone to not be present for 200 msecs	*/
            if (dp10_answ_tone_detc() == FALSE)
            {
                if (!mnp10_100ms_timer_started)
                {
                    mnp10_100ms_timer_started = TRUE;
                    mnp10_answ_timer = MSEC_200;
                }
                else if (!mnp10_answ_timer)
                {
                    /*	Indicate to DP code to not time carrier with s9 during
                        initial upshift	*/
                    dp10_start_handshake(mnp10_startup_mode,
							     mnp10_initial_upshift,
                                mnp10_tx_level);
                    mnp10_fffb_state = FB_PROC_HANDSHAKE;
                    mnp10_answ_timer = SEC_1 * 3;
                }
            }
            else
            {
                mnp10_100ms_timer_started = FALSE;
                mnp10_answ_timer = 0;
            }
            break;

        case CHECK_FB_CONTINUE:
            if (mnp10_rcv_lm__fb_cmd || mnp10_rcv_lm__fb_ack ||
                mnp10_current_speed == BPS1200 ||
                mnp10_failed_fallforward)
            {
                mnp10_rcv_lm__fb_cmd = FALSE;
                mnp10_rcv_lm__fb_ack = FALSE;
                mnp10_failed_fallforward = FALSE;
                dp10_start_handshake(mnp10_startup_mode,
                    mnp10_initial_upshift,mnp10_tx_level);
                mnp10_fffb_state = FB_PROC_HANDSHAKE;
            }
            else
            {
                mnp10_fffb_state = WAIT_FOR_FB_TIMER;
            }
            break;

        case WAIT_FOR_FB_TIMER:
            if (!shift_timer)
            {
                return (FALLBACK_FAILED);
            }
            break;

        case PROC_ORIG_FB:
            dp10_send_answer_tone();
            mnp10_fffb_state = ORIG_WAIT_TO_SEND_TONE;
            mnp10_100ms_timer = MSEC_100 * 4;
            break;

        case ORIG_WAIT_TO_SEND_TONE:
            if (!shift_timer)
            {
                return (FALLBACK_FAILED);
            }

            if (!mnp10_100ms_timer)
            {
                /*	Indicate to DP code to not time carrier with s9 during
                    initial upshift	*/
                dp10_start_handshake(mnp10_startup_mode,
                    mnp10_initial_upshift,mnp10_tx_level);
                mnp10_100ms_timer = SEC_1 * 3;
                mnp10_100ms_timer_started = TRUE;
                mnp10_fffb_state = FB_PROC_HANDSHAKE;
            }
            break;

        case FB_PROC_HANDSHAKE:
            if (!shift_timer)
            {
                return (FALLBACK_FAILED);
            }
            if ((!mnp10_startup_mode) &&
                (mnp10_100ms_timer_started && !mnp10_100ms_timer))
            {
                dp10_reset_connection();
                mnp10_100ms_timer_started = FALSE;
                mnp10_fffb_state = PROC_ORIG_FB;
            }

            status = dp10_handshake_status();
            /*	Once answer tone is detected, do not look for 3 second time out */
            if (status == DP10_HNDSHK_STATUS__ANSW)
            {
                mnp10_100ms_timer_started = FALSE;
            }
            else if (status == DP10_HNDSHK_STATUS__CONN)
            {
                baud_rate = mnp10_current_speed = dp10_get_line_speed();

                /* Check if remote modem is V.32 or V.32bis */
                if (dp10_get_line_mode() == V32BIS)
                    mnp10_v32bis = TRUE;
                else
                    mnp10_v32bis = FALSE;

                /*	Inform V.42 of new line baud rate	*/
                current_baud_rate(mnp10_current_speed);
                return (FALLBACK_SUCCESSFUL);
            }
            break;
    }

    return (FALLBACK_IN_PROGRESS);
}


/*******************************************************************************
/
/	Routine: process_v32_speed_shift
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine will execute a speed shift to a V32/V32BIS
/		      speed.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte background status
/				0  -  Operation in progress
/				1  -  speed shift succeeded
/				2  -  speed shift failed
/
/	Global Variables Changed: shift_timer, mnp10_fffb_state, mnp10_100ms_timer,
/				  mnp10_startup_mode, mnp10_rr_fail_flag,
/
/	Users: mnp10_retrain_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte process_v32_speed_shift(void)
{
    switch (mnp10_fffb_state)
    {
        case INIT:
            if (!mnp10_100ms_timer)
            {
                shift_timer = mnp10_cd_wait_time;
                if (mnp10_startup_mode)
                {
                    mnp10_100ms_timer = MSEC_500;
                    mnp10_fffb_state = PROC_ANSW;
                }
                else
                {
                    mnp10_100ms_timer = MSEC_100;
                    mnp10_fffb_state = PROC_ORIG;

                    /* Don't clear the RRN fail flag if we're supose to
                        retrain */
                    if (mnp10_rr_fail_flag != FORCE_RETRAIN)
                        mnp10_rr_fail_flag = FALSE;
                }
            }
            break;

        case PROC_ANSW:
            if (!mnp10_100ms_timer)
            {
                mnp10_fffb_state = INIT;
                mnp10_startup_mode = ORIGINATE;
            }

            if (!shift_timer)
            {
                return (SPEED_SHIFT_FAILED);
            }

            if (dp10_detect_retrain())
            {
                mnp10_100ms_timer = WAIT_FOR_RETRAIN_TIME;
                mnp10_fffb_state = WAIT_FOR_RR_COMPLETE;
            }

            if (dp10_detect_rate_renegot())
            {
                mnp10_100ms_timer = WAIT_FOR_RENEGOT_TIME;
                mnp10_fffb_state = WAIT_FOR_RR_COMPLETE;
            }
            break;

        case PROC_ORIG:
            if (!mnp10_100ms_timer)
            {
                if (mnp10_v32bis && !mnp10_rr_fail_flag)
                {
                    dp10_rate_renegot();
                    mnp10_100ms_timer = WAIT_FOR_RENEGOT_TIME;
                }
                else
                {
                    /* Adjust transmit level before retrains only */
                    if (mnp10_neg_cellular)
                    {
                        dp10_set_tx_level(mnp10_tx_level);
                    }
                    dp10_retrain();
                    mnp10_100ms_timer = WAIT_FOR_RETRAIN_TIME;
                }
                mnp10_fffb_state = WAIT_FOR_RR_COMPLETE;
            }
            break;

        case WAIT_FOR_RR_COMPLETE:
            if (!shift_timer)
            {
                return (SPEED_SHIFT_FAILED);
            }

            if (!mnp10_100ms_timer)
            {
                mnp10_rr_fail_flag = TRUE;
                mnp10_fffb_state = PROC_ORIG;
            }

            if (dp10_rtrn_rr_status() == DP10_RTRN_RR_STATUS__OK)
            {
                mnp10_rr_fail_flag = FALSE;
                baud_rate = mnp10_current_speed = dp10_get_line_speed();

                /*	Inform V.42 of new line baud rate	*/
                current_baud_rate(mnp10_current_speed);
                return (SPEED_SHIFT_SUCCESSFUL);
            }

            if ((mnp10_startup_mode == ORIGINATE) &&
                (dp10_detect_retrain() || dp10_detect_rate_renegot()))
            {
                mnp10_startup_mode = ANSWER;
                mnp10_100ms_timer = SEC_1 * 2;
            }
            break;
    }

    return (SPEED_SHIFT_IN_PROGRESS);
}


/*******************************************************************************
/
/	Routine: fallback_allowed
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine will determine if fallback is possible.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte background status
/				FALSE - Fallback not possible
/				TRUE - Fallback possible
/
/	Global Variables Changed: None
/
/	Users: mnp10_bg(), mnp10_retrain_init(), mnp10_retrain_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fallback_allowed(void)
{
	ubyte lower_rate_enabled;

	switch (mnp10_current_speed)
	{
		case BPS1200:
			lower_rate_enabled = FALSE;
			break;

		case BPS2400:
			lower_rate_enabled = mnp10_possible_rates & MASK_2400;
			break;

		case BPS4800:
			lower_rate_enabled = mnp10_possible_rates & MASK_4800;
			break;

		case BPS7200:
			lower_rate_enabled = mnp10_possible_rates & MASK_7200;
			break;

		case BPS9600:
			lower_rate_enabled = mnp10_possible_rates & MASK_9600;
			break;

		case BPS12000:
			lower_rate_enabled = mnp10_possible_rates & MASK_12000;
			break;

		case BPS14400:
			lower_rate_enabled = mnp10_possible_rates & MASK_14400;
			break;
	}

	if (mnp10_fb_negot && lower_rate_enabled)
	{
		return (TRUE);
	}
	return (FALSE);
}

/*******************************************************************************
/
/	Routine: process_nonv32_fallforward
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine will execute a fallforward to a NON-V32
/		      speed.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte background status
/				0  -  Operation in progress
/				1  -  fallforward succeeded
/				2  -  fallforward failed
/
/	Global Variables Changed: mnp10_fffb_state, mnp10_100ms_timer, shift_timer
/
/	Users: mnp10_retrain_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte process_nonv32_fallforward(void)
{
    ubyte status;

    switch (mnp10_fffb_state)
    {
        case INIT:
            if (!mnp10_100ms_timer)
            {
                /*	Turn off the transmitter	*/
                dp10_mute_transmitter();
                mnp10_100ms_timer = SEC_1 * 4;
                mnp10_fffb_state = FF_WAIT_FOR_CD_LOSS;
            }
            break;

        case FF_WAIT_FOR_CD_LOSS:
            if (!dp10_check_CD())
            {
                dp10_reset_connection();
                mnp10_fffb_state = START_FALLFORWARD;
                mnp10_100ms_timer = MSEC_250;
            }
            else if (!mnp10_100ms_timer)
            {
                if(mnp10_initial_upshift)
                {
                    dp10_reset_connection();
                    mnp10_fffb_state = START_FALLFORWARD;
                    mnp10_100ms_timer = MSEC_250;
                }
                else
                {
                    if (mnp10_initiator)
                    {
                        dp10_reset_connection();
                        mnp10_fffb_state = START_FALLFORWARD;
                        mnp10_100ms_timer = MSEC_250;
                    }
                    else
                    {
                        return (FALLFORWARD_FAILED);
                    }
                }
            }
            break;

        case START_FALLFORWARD:
            if (!mnp10_100ms_timer)
            {
                shift_timer = SEC_1 * 25;
                mnp10_100ms_timer = SEC_1 *3;
                mnp10_fffb_state = PROC_FF_HANDSHAKE;
                /*	Indicate to DP code to not time carrier with s9 during
                    initial upshift	*/
                dp10_start_handshake(mnp10_startup_mode,
                    mnp10_initial_upshift,mnp10_tx_level);
            }
            break;

        case PROC_FF_HANDSHAKE:
            if (!shift_timer)
            {
                dp10_reset_connection();
                return (FALLFORWARD_FAILED);
            }

            status = dp10_handshake_status();
            if (status == DP10_HNDSHK_STATUS__CONN)
            {
                baud_rate = mnp10_current_speed = dp10_get_line_speed();

                if (dp10_get_line_mode() == V32BIS)
                    mnp10_v32bis = TRUE;
                else
                    mnp10_v32bis = FALSE;

                /*	Inform V.42 of new line baud rate	*/
                current_baud_rate(mnp10_current_speed);
                return (FALLFORWARD_SUCCESSFUL);
            }
    }
    return (FALLFORWARD_IN_PROGRESS);
}




/*******************************************************************************
/
/	Routine: fallforward_allowed
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine will determine if fallfallforward is possible.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte background status
/				FALSE - Fallforward not possible
/				TRUE - Fallforward possible
/
/	Global Variables Changed: None
/
/	Users: mnp10_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte fallforward_allowed(void)
{
	if ((mnp10_BLER == 0) && higher_speed_avail() && (dynamic_txmax == 256) &&
	     mnp10_ff_negot && (dp10_EQM_status() == DP10_EQM_STATUS__FF_LEVEL))
	{
		return (TRUE);
	}

	return (FALSE);
}
