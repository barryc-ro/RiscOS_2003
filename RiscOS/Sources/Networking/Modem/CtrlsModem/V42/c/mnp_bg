/****************************************************************************
/
/       Copyright, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996.
/       All Rights Reserved by:
/          RSA
/          110 Horizon Drive
/          Raleigh, NC  27615
/          (919) 846-7171
/
/
/       This document contains material confidential to RSA its contents must
/       not be revealed, used or disclosed to anyone or company with out
/       written permission by RSA.  The information contained herein is solely
/       for the use of RSA.
/
/       File:           MNP_BG.C
/
/       Module Version: 4.02
/
/       Function:       Contains MNP background code.
/
/       Product:        V.42/V.42bis
/
/       History:
/
/           Created:    8/25/92
/                       11/1/94 (V4.01) - Add ETC and update MNP10
/
/           ---------------------------------------------------------
/           -                   Modifications                       -
/           ---------------------------------------------------------
/
/           Author & Date:	RSA
/           Description:
/           Reason:
/
*****************************************************************************/

#include "SYS_DEF.H"
#include "EDF.V42"
#include "EDF.MNP"
#include "EDF.MNP_LIB"
#include "EDF.MNP_AF"
#include "EDF.MNP_LA"
#include "EDF.MNP_LD"
#include "EDF.MNP_LN"
#include "EDF.MNP_LNA"
#include "EDF.MNP_LR"
#include "EDF.MNP_QUE"
#include "EDF.MNP_LRR"
#include "EDF.MNP_LT"
#include "EDF.M10_IF"
#include "EDF.DCE_LINE"
#include "EDF.DTE"
#include "EDF.BTINIT"
#include "MNP_DEF.H"
#include "MNP_STRU.H"
#include "M10_DEF.H"

extern ubyte baud_rate;
extern ubyte timer_timeout;
extern ubyte *tx_holding;
extern ubyte mnp10_status;
extern ubyte tx_attention_flag;
extern ubyte idle_flag;
extern ubyte *tx_data_holding;
extern ubyte receive_attention_flag;
extern ubyte tx_attention_mode_flag;
extern ubyte send_credits;
extern ubyte tx_send_pointer;
extern ubyte tx_input_pointer;
extern ubyte data_frame_sent;
extern struct buffer_entry transmit_buffer [NUMBER_OF_MNP_BUFFERS];
extern ubyte la_received_flag;
extern ubyte la_receive_sequence;
extern ubyte tx_oldest_pointer;
extern ubyte la_credit_amount;
extern ubyte re_send_flag;
extern ubyte send_sequence_number;
extern ubyte mnp_attention_process;
extern ubyte clear_receive_buffers_flag;
extern ubyte clear_transmit_buffers_flag;
extern ubyte send_attention_flag;
extern ubyte lna_delayed_flag;
extern uword lna_delay_count;
extern ubyte attention_retry_count;
extern ubyte mnp_max_retries;
extern ubyte timer_attn_timeout;
extern ubyte mnp_state;
extern ubyte mnp_disconnect_code;
extern ubyte send_sel_recover_rqst_flag;
extern ubyte timer_recovery;
extern ubyte sel_max_retries;
extern ubyte *tx_current;
extern struct extra_short_buffer_entry la_send_segment;
extern ubyte la_window;
extern ubyte last_la_window;
extern ubyte mnp_negotiated_class;
extern ubyte timer_window;
extern ubyte timer_acknowledge;
extern ubyte send_acknowledge_flag;
extern ubyte bad_lt_frame_flag;
extern ubyte max_window;
extern ubyte mnp10_lmi_rcvd;
extern ubyte negot_data_optimization;
extern ubyte mnp_negotiated_service;
extern ubyte peer_missing_frame_flag;
extern ubyte peer_missing_frame_sequence;
extern ubyte *transmit_active_frame;
extern ubyte tx_busy_flag;
extern ubyte mnp10_enabled;
extern ubyte mnp10_lmi_timer;
extern ubyte tx_packet_to_finish;
extern ubyte ack_rcv_sequence_number;
extern ubyte receive_sequence_number;
extern ubyte last_la_credits;
extern ubyte empty_sequence_number;
extern ubyte empty_lt_in_progress;
extern ubyte process_que__in;
extern ubyte process_que__out;
extern struct buffer_entry *process_que[NUMBER_OF_MNP_BUFFERS+1];
extern struct buffer_entry *rx_buf_ptr;
extern ubyte mnp_send_dte_brk;
extern ubyte ln_attention_type;
extern ubyte mnp_attention_length;
extern ubyte timer_tick;
extern ubyte timer_tick_counter;
extern ubyte timer_transmit_delay;
extern uword timer_inactivity;
extern ubyte mnp_status;
extern ubyte ld_reason_code;
extern ubyte disconnect_flag;
extern ubyte mnp_retry_limit;
extern ubyte rcv_working_frame_ptr;
extern ubyte received_disconnect_reason;
extern ubyte received_user_disconnect_reas;
extern ubyte ld_user_reason;
extern ubyte frame_received_flag;
extern ubyte *rx_current;
extern ubyte mnp10_LT_acked;
extern ubyte buffering_enabled_flag;
extern ubyte mnp_fallback_active;
extern ubyte mnp_length_lbrk;
extern ubyte dce_delayed_flag;
extern uword dce_delay_count;
extern ubyte mnp_length_tbrk;
extern ubyte V42bis_P0;
extern ubyte negot_data_compression;
extern uword negot_v42bis_dict_size;
extern ubyte negot_v42bis_str_len;
extern ubyte *tx_data_ptr;
extern ubyte *rx_data_ptr;
extern ubyte bad_lt_done;

ubyte mnp_bg(void);

const ubyte timer_timeout_time[max_baud+1] = {

	    10, 			     /* 1200(tx)/75(rx) */
	    10, 			     /* 75(tx)/1200(rx) */
	    10, 			     /* 300  */
	     5, 			     /* 1200 */
	     3, 			     /* 2400 */
	     3, 			     /* 4800 */
	     3, 			     /* 7200	*/
	     3, 			     /* 9600	*/
	     2, 			     /* 12000	*/
	     2, 			     /* 14400	*/
	     2, 			     /* 16800	*/
	     2, 			     /* 19200	*/
	     2, 			     /* 38400	*/
	 };

void reset_LR_timeout_timer()
{
    if (baud_rate < max_baud)
		 timer_timeout = timer_timeout_time[baud_rate];
    else
	 timer_timeout = timer_timeout_time[max_baud];
}


/*******************************************************************************
/
/	Routine: transmit_background
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine perform the packet transmission portion of
/		      MNP.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte stat_hold - status of the transmit background
/				0 - Ok status
/				4 - Retry limit reached
/
/	Global Variables Changed:  send_credits, data_frame_sent,
/				   tx_data_holding, mnp_state,
/				   mnp_disconnect_code,send_attention_flag,
/				   tx_attention_flag, clear_receive_buffers_flag,
/				   clear_transmit_buffers_flag,la_window,
/				   lna_delayed_flag, lna_delay_count,
/				   la_received_flag, re_send_flag,
/				   receive_attention_flag,last_la_window,
/				   la_send_segment.pdu_data[],tx_holding,
/				   send_acknowledge_flag,tx_busy_flag,
/				   peer_missing_frame_flag,tx_current,
/				   transmit_active_frame,
/				   tx_packet_to_finish,tx_input_pointer,
/				   transmit_buffer[].pdu_length,
/				   last_la_credits
/
/	Users: mnp_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte transmit_background(void)
{
    ubyte lrr_scan;
    ubyte stat_hold;
    ubyte subscript;

    /* Don't build V.42bis PDUs if attempting to Fallforward */
    if (mnp10_status != MNP10_BG__FF_INIT)
        if (V42bis_P0 & 1)
            build_lt();

    if (tx_holding != 0)
    {
        if (mnp10_status != MNP10_BG__FF_INIT)
        {
            if (!tx_attention_flag &&
                (tx_buffer_available() == OK) &&
                !idle_flag)
            {
                if ( ((V42bis_P0 & 1) && (dte_from_num())) ||
                    (dte_from_num() >= holding_data_in_dte_size))
                {
                    build_lt();
                    reset_inactivity_timer();
                }
            }

            if ((tx_data_holding == 0) && (!receive_attention_flag) &&
                (!tx_attention_flag) && (!tx_attention_mode_flag))
            {
                if ((send_credits != 0) && (tx_send_pointer != tx_input_pointer))
                {
                    send_credits -= 1;
                    reset_timeout_timer();
                    data_frame_sent = TRUE;
                    tx_data_holding = (ubyte *)&transmit_buffer[get_send_entry()].io_status;

                    /* Update MNP10 Block Error Rate every time a LT is tx'ed */
                    mnp10_calc_BLER();
                }
            }
        }
        return(OK);
    }
    else
    if ( la_received_flag )
    {
        la_received_flag = FALSE;
        update_tx_buffers(la_receive_sequence);

        send_credits = tx_send_pointer - tx_oldest_pointer;
        if ((send_credits & 0x80) != 0)
            send_credits += NUMBER_OF_MNP_BUFFERS;

        send_credits = la_credit_amount - send_credits;
        if ((send_credits & 0x80) != 0)
            send_credits = 0;

        if ( re_send_flag )
        {
            re_send_flag = FALSE;
            if (stat_hold = resend_oldest_lt() != OK)
                return(stat_hold);
        }
    }

    if ((timer_timeout == 0) && (la_receive_sequence != send_sequence_number))
    {
        reset_timeout_timer();
        if (stat_hold = resend_oldest_lt() != OK)
            return(stat_hold);
    }

    if (receive_attention_flag)
    {
        receive_attention_flag = FALSE;
        build_lna();
        send_lna();
        return(OK);
    }
    else
    if (tx_attention_flag)
        switch (mnp_attention_process)
        {
            case(MNP_ATTEN_EXP_DEST):
                tx_attention_flag = FALSE;
                clear_receive_buffers_flag =
                    clear_transmit_buffers_flag =
                    send_attention_flag = TRUE;
                if (negot_data_compression)
                    ad_frq_init();
                if (V42bis_P0)
                    BTInit(V42bis_P0,negot_v42bis_dict_size,negot_v42bis_str_len);
                break;

            case(MNP_ATTEN_EXP_NON_D):
                tx_attention_flag = FALSE;
                send_attention_flag = TRUE;
                break;

            case(MNP_ATTEN_NON_E_NON_D):
                if (lna_delay_count != 0)
                {
                    if (tx_buffer_available() == OK)
                        build_lt();
                }
                else
                {
                    if (tx_input_pointer == tx_oldest_pointer)
                    {
                        lna_delayed_flag = FALSE;
                        send_attention_flag = TRUE;
                        tx_attention_flag = FALSE;
                    }
                }
                break;

            default:
                tx_attention_flag = FALSE;
                break;
        }

    if (clear_transmit_buffers_flag)
    {
        clear_transmit_buffers_flag = FALSE;
        clear_transmit_buffers();
        send_sequence_number = 0;
        tx_data_ptr = NULL;
        dte_from_clear();
    }

    if ((send_attention_flag) && (!tx_attention_mode_flag))
    {
        send_attention_flag = FALSE;
        build_ln();
        send_ln();
        tx_attention_mode_flag = TRUE;
        attention_retry_count = mnp_max_retries;
        reset_attn_timeout_timer();
        return(OK);
    }

    if (tx_attention_mode_flag)
    {
        if (timer_attn_timeout == 0)
            if (--attention_retry_count == 0)
            {
                if (mnp10_enabled != 0)
                {
                    return (mnp10_proc_retry_limit());
                }
                else
                {
                    mnp_disconnect_code = DISCONNECT_CODE_RETRY_LIMIT_X;
                    return (DISCONNECT_CODE_RETRY_LIMIT_X);
                }
            }
            else {
                send_ln();
                reset_attn_timeout_timer();
            }

        return(OK);
    }
    if (send_sel_recover_rqst_flag)
    {
        if (timer_recovery == 0)
        {
            if (--sel_max_retries == 0)
            {
                if (mnp10_enabled != 0)
                {
                    return (mnp10_proc_retry_limit());
                }
                else
                {
                    mnp_disconnect_code = DISCONNECT_CODE_RETRY_LIMIT_X;
                    return (DISCONNECT_CODE_RETRY_LIMIT_X);
                }
            }
            build_lrr();
            send_lrr();
            reset_recovery_timer();
            return(OK);
        }
    }
    else
    {
        if (bad_lt_done)
            bad_lt_frame_flag = FALSE;

        if ((tx_current != &la_send_segment.io_status)
            && (!clear_receive_buffers_flag)
            && (!clear_transmit_buffers_flag)
            && ( ((la_window == 0) && (last_la_window != 0) &&
            (mnp_negotiated_class != MNP_SERVICE_CLASS_1_CREDIT))||
            (timer_window == 0) ||
            (timer_acknowledge == 0) ||
            send_acknowledge_flag ||
            bad_lt_frame_flag))
        {
            build_la();
            mnp10_build_lk();

            if (la_window > max_window)
                la_window = max_window;
            last_la_window = la_window;

            if (!send_sel_recover_rqst_flag)
            {
                if (mnp10_lmi_rcvd == TRUE)
                {
                    mnp10_lmi_rcvd = FALSE;
                    mnp10_send_lk();
                }
                else
                {
                    if (negot_data_optimization)
                    {
                        subscript = 1;
                    }
                    else
                    {
                        subscript = 5;
                    } /* end if (negot_data_optimization) */

                    if (mnp_negotiated_service == MNP_SERVICE_MINIMAL)
                        la_send_segment.pdu_data[subscript] = 1;
                    if (idle_flag)
                        la_send_segment.pdu_data[subscript] = 0;
                    send_la();
                }
                reset_window_retry_timer();
                reset_acknowledge_timer();
                send_acknowledge_flag = FALSE;

                if (bad_lt_frame_flag)
                {
                    bad_lt_frame_flag = FALSE;
                    send_acknowledge_flag = TRUE;
                    bad_lt_done = TRUE;
                }
            }
            return(OK);
        }
    } /* end the else */

    if (peer_missing_frame_flag)
    {
        proclaim_error();
        peer_missing_frame_flag = FALSE;
        lrr_scan = scan_transmit_buffer(peer_missing_frame_sequence);

        if((lrr_scan != TRANSMIT_BUFFER_EMPTY) &&
            (lrr_scan != TRANSMIT_SCAN_NOT_FOUND))
        {
            transmit_active_frame = &transmit_buffer[(uword)lrr_scan].io_status;
            start_tx();
        }
        return(OK);
    }

    if (tx_data_holding != 0)
    {
        reset_inactivity_timer();
        tx_holding = tx_data_holding;
        tx_busy_flag = TRUE;

        if (tx_current == 0)
        {
            tx_current = tx_holding;
            tx_holding = 0;
            line_tx_block(tx_current);
        }

        tx_data_holding = 0;
        return(OK);
    }

    if ((mnp10_enabled != 0) && (mnp10_lmi_timer == 0) && (baud_rate >= BAUD_1200)
        && ((dte_from_num() == 0) || (send_credits == 0)))
    {
        if ((stat_hold = mnp10_check_lmi_seq_num()) != CONTINUE)
            return (stat_hold);
    }

    if ( send_credits == 0)
    {
        if ((dte_from_num() >= holding_data_in_dte_size) &&
            !tx_attention_flag &&
            (tx_buffer_available() == OK) &&
            !idle_flag &&
            (mnp10_status != MNP10_BG__FF_INIT))
        {
            build_lt();
        }
        return(OK);
    }

    if (tx_send_pointer != tx_input_pointer)   /* LTs ready to send. */
    {
        send_lt();
        send_credits -= 1;
        reset_timeout_timer();
        reset_inactivity_timer();

        if ((dte_from_num() >= holding_data_in_dte_size) &&
            !tx_attention_flag &&
            (tx_buffer_available() == OK) &&
            !idle_flag &&
            (mnp10_status != MNP10_BG__FF_INIT))
        {
            build_lt();
        }
        return (OK);
    }
    else if (!tx_attention_flag &&
        ((dte_from_num() != 0) || (tx_packet_to_finish == TRUE)) &&
        (!idle_flag) && (tx_buffer_available() == OK) &&
        (mnp10_status != MNP10_BG__FF_INIT))
    {
        /* no LT's ready to send, but we have data and buffers, therefore: */
        reset_inactivity_timer();
        build_lt();
        if (mnp10_check_v42bis_flush())
        {
            send_lt();
            --send_credits;
            reset_timeout_timer();
        }
    }
    else if (ack_rcv_sequence_number != receive_sequence_number)
    /* no LT's ready to send, not ready to build one, then lets send an LA */
        send_acknowledge_flag = TRUE;

    if (tx_input_pointer == tx_oldest_pointer)
        /* not transmitting, prevent unnecessary retransmit if do start tx */
        last_la_credits = 0xff;

    return(OK);
}

/*============================================================================*/
/*============================================================================*/
ubyte receive_background(void)
{
    ubyte temp_ptr;

    if (clear_receive_buffers_flag)
    {
        clear_receive_buffers_flag = FALSE;
        clear_receive_buffers();
        receive_sequence_number = ack_rcv_sequence_number = empty_sequence_number = 0;
        empty_lt_in_progress = FALSE;
        rx_data_ptr = NULL;
    }

    do
    {
        if (process_que__in == process_que__out)
            break;
        if ((process_que[process_que__out]->user_flag & MNP_BUFFER_EMPTY) != MNP_BUFFER_EMPTY)
            break;
        rx_buf_ptr = (struct buffer_entry *)get_process();
        put_empty((ubyte *)rx_buf_ptr);
    }
    while (TRUE);

    if (idle_flag)
        return(OK);
    else
    {
        if (mnp_send_dte_brk == TRUE)
        {
            mnp_send_dte_brk = FALSE;
            dte_to_break(ln_attention_type,mnp_attention_length);
        } /* need to send break? */

        if (dte_to_free() >= 64)
        {
            if (empty_lt_in_progress)
            {
                empty_lt_continue();
                reset_inactivity_timer();
                return(OK);
            }
        }

        if (process_que__in == process_que__out)
            return(OK);

        rx_buf_ptr = process_que[process_que__out];

        switch (rx_buf_ptr->pdu_type)
        {
            case(PDU_TYPE_LN):
                dte_to_break(3,mnp_attention_length);
                rx_buf_ptr = (struct buffer_entry *)get_process();
                put_empty((ubyte *)rx_buf_ptr);
                break;

            case(PDU_TYPE_LT):
                if (dte_to_free() >= 64)
                {
                    if (empty_lt_in_progress)
                    {
                        empty_lt_continue();
                        reset_inactivity_timer();
                        return(OK);
                    }
                    else {
                        temp_ptr = process_que__out;
                        do {
                            rx_buf_ptr = process_que[temp_ptr];
                            if (negot_data_optimization )
                            {
                                if ((rx_buf_ptr->pdu_type == PDU_TYPE_LT) &&
                                    (rx_buf_ptr->pdu_data[0] == inc_seq_ptr(empty_sequence_number)))
                                {
                                    empty_sequence_number = inc_seq_ptr(empty_sequence_number);
                                    empty_lt();
                                    reset_inactivity_timer();
                                    /* if (empty_lt_in_progress)	*/
                                    return(OK);
                                }
                            }
                            else
                            {
                                if ((rx_buf_ptr->pdu_type == PDU_TYPE_LT) &&
                                    (rx_buf_ptr->pdu_data[2] == inc_seq_ptr(empty_sequence_number)))
                                {
                                    empty_sequence_number = inc_seq_ptr(empty_sequence_number);
                                    empty_lt();
                                    reset_inactivity_timer();
                                    /* if (empty_lt_in_progress)	*/
                                    return(OK);
                                }
                            }
                            inc(temp_ptr);
                        }
                        while (temp_ptr != process_que__in);
                    }
                }
                break;

            default:
                rx_buf_ptr = (struct buffer_entry *)get_process();
                put_empty((ubyte *)rx_buf_ptr);
                return(BAD_PDU_TYPE_IN_BUFFER);
        }
    }
    return(OK);
}

/*******************************************************************************
/
/	Routine: mnp_bg
/
/	Author : RSA
/
/	Creation Date: 03/13/92
/
/	Description : This Routine will provide the background processing for
/		      the MNP code.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte mnp_status - status of the MNP background
/				0 - Halted status
/				1 - Connecting status
/				2 - Idling status
/				3 - Running status
/				4 - Disconnecting status
/				5 - Running speed matching
/
/	Global Variables Changed: timer_tick, timer_inactivity, mnp_state,
/				  ld_reason_code,mnp_disconnect_code,
/				  disconnect_flag, timer_timeout,timer_recovery,
/				  timer_window, timer_attn_timeout,
/				  timer_acknowledge, tx_attention_flag,
/				  mnp_retry_limit, rx_buf_ptr, rcv_working_frame_ptr,
/				  received_disconnect_reason,frame_received_flag,
/				  received_user_disconnect_reas,send_credits,
/				  mnp_fallback_active, mnp_status,
/				  lna_delayed_flag
/
/	Users: v42_bg()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte mnp_bg(void)
{
    ubyte pdu_type,t_b_status;

    if (mnp_state != BGND_STATE_BUFFERING_DATA)
        mnp_line_bg();	     /* call LINE_BG once every loop */

    while (timer_tick != 0)
    {
        timer_tick_counter++;

        if (mnp10_enabled)
            mnp10_timer();

        if (timer_transmit_delay != 0)
            timer_transmit_delay--;

        timer_tick--;
    }

    if (timer_tick_counter >= 10)
    {
        timer_tick_counter -= 10;
        if (timer_inactivity != 0)
        {
            timer_inactivity -= 1;
            if (timer_inactivity == 0)
            {
                /* If speed matching */
                if (mnp_state == BGND_STATE_BUFFERING_DATA)
                {
                    mnp_state = BGND_STATE_HALTED;
                    ld_reason_code = DISCONNECT_CODE_INACTIVITY_X;
                    mnp_disconnect_code = DISCONNECT_CODE_INACTIVITY_X;
                }
                else  /* MNP */
                {
                    mnp_disconnect_code = DISCONNECT_CODE_INACTIVITY_X;
                    disconnect_flag = TRUE;
                }
            }
        }
        if (timer_timeout != 0)
            timer_timeout -= 1;
        if (timer_recovery != 0)
            timer_recovery -= 1;
        if (timer_window != 0)
            timer_window -= 1;
        if (timer_attn_timeout != 0)
            timer_attn_timeout -= 1;
        if (timer_acknowledge != 0)
            timer_acknowledge -= 1;
    }
    if (disconnect_flag)
    {
        disconnect_flag = FALSE;
        if (mnp_state == BGND_STATE_DATA_STATE)
            mnp_state = BGND_STATE_DISCONNECT_SEND;
        else
            mnp_state = BGND_STATE_DISCONNECT_SHUT;
    }
    switch (mnp_state)
    {
        case(BGND_STATE_ORIG_INITIAL):
            mnp_state = BGND_STATE_ORIG_INITIAL;
            if (timer_transmit_delay != 0) /* WAIT FOR LINE TO STABILIZE */
                return(mnp_status);

            if (mnp10_enabled != 0)
                mnp_retry_limit = 15;
            else
                mnp_retry_limit = mnp_max_retries;

            build_lr();
            send_lr();
            reset_LR_timeout_timer();
            mnp_state = BGND_STATE_ORIG_WAIT_LR;
            return(mnp_status);

        case(BGND_STATE_ORIG_WAIT_LR):
            mnp_state = BGND_STATE_ORIG_WAIT_LR;
            rx_buf_ptr = (struct buffer_entry *)get_process();
            if (rx_buf_ptr == NULL)
            {
                if (timer_timeout != 0)
                    return(mnp_status);
                if ((mnp_retry_limit -= 1) != 0)
                {
                    reset_LR_timeout_timer();
                    send_lr();
                    return(mnp_status);
                }
                else
                {
                    mnp_disconnect_code = DISCONNECT_CODE_RETRY_LIMIT_X;
                    goto bgnd_disconnect_send;
                }
            }
            turnoff_autoreliable();

            rcv_working_frame_ptr = get_rx_offset_num((ubyte *)rx_buf_ptr);
            pdu_type = rx_buf_ptr->pdu_type;
            if (pdu_type == PDU_TYPE_LR)
                if (negotiate_parameters() != OK)
                    goto bgnd_disconnect_send;
                else
                {
                    put_empty((ubyte *)rx_buf_ptr);
                    build_la_init();
                    send_la();
                    reset_timeout_timer();
                    reset_retries();
                    clear_receive_buffers();
                    clear_transmit_buffers();
                    goto bgnd_orig_send_la;
                }

            if (pdu_type == PDU_TYPE_LD)
            {
                empty_ld();
                received_disconnect_reason = ld_reason_code;
                received_user_disconnect_reas = ld_user_reason;
            }
            mnp_disconnect_code = DISCONNECT_CODE_NOT_LR;
            goto bgnd_disconnect_send;

        case(BGND_STATE_ORIG_SEND_LA):
bgnd_orig_send_la:
            mnp_state = BGND_STATE_ORIG_SEND_LA;
            if (!tx_busy_flag)
            {
                send_la();
                reset_timeout_timer();
                reset_retries();
                clear_receive_buffers();
                clear_transmit_buffers();
                goto bgnd_orig_send_la_2;
            }
            return(mnp_status);

        case(BGND_STATE_ORIG_SEND_LA_2):
bgnd_orig_send_la_2:
            mnp_state = BGND_STATE_ORIG_SEND_LA;
            if (!tx_busy_flag)
            {
                reset_transmit_delay(TRANSMIT_DELAY_TIME);
            }
            else
            {
                if (timer_transmit_delay == 0)
                    goto bgnd_data_initial;
            }
            return(mnp_status);

        case(BGND_STATE_ANSW_INITIAL):
            mnp_state = BGND_STATE_ANSW_INITIAL;
            rx_buf_ptr = (struct buffer_entry *)get_process();
            if (rx_buf_ptr != NULL)
            {
                frame_received_flag = FALSE;
            }
            else
            {
                return(mnp_status);
            }
            turnoff_autoreliable();
            rcv_working_frame_ptr = get_rx_offset_num((ubyte *)rx_buf_ptr);
            pdu_type = rx_buf_ptr->pdu_type;
            if (pdu_type == PDU_TYPE_LR)
                if (negotiate_parameters() != OK)
                    goto bgnd_disconnect_send;
                else
                {
                    put_empty((ubyte *)rx_buf_ptr);
                    build_lr();
                    send_lr();
/* start change keh 11/6/96 => defect #99: answ sends max of 2 LRs per V.42/A.7.1.3 */
/*                    reset_retries(); */
/*                    reset_timeout_timer();*/

                   /* MNP10 Answerer sends max of 15 LRs, BUT only after rcving
                       an LR, for up to 30 secs, per MNP10 Ver.1.1, Sec.2.2 */
                   if (mnp10_enabled)
                   {
                       timer_timeout = MNP10_ANSW_ESTABLISH_TIME;
                       mnp_retry_limit = MNP10_ANSW_ESTABLISH_RETRY_LIMIT;
                   }
                   /* Non-MNP10 Answerer sends max of 2 LRs, per V.42/A.7.1.3 */
                   else
                   {
                       reset_timeout_timer();
                       mnp_retry_limit = MNP_ANSW_ESTABLISH_RETRY_LIMIT;
                   }
/* end change keh 11/6/96 => defect #99: answ sends max of 2 LRs per V.42/A.7.1.3 */
                   goto bgnd_answ_wait_la;
                }

            if (pdu_type == PDU_TYPE_LD)
            {
                empty_ld();
                received_disconnect_reason = ld_reason_code;
                received_user_disconnect_reas = ld_user_reason;
            }
            mnp_disconnect_code = DISCONNECT_CODE_NOT_LR;
            goto bgnd_disconnect_send;

        case(BGND_STATE_ANSW_WAIT_LA):
bgnd_answ_wait_la:
            mnp_state = BGND_STATE_ANSW_WAIT_LA;
            rx_buf_ptr = (struct buffer_entry *)get_process();
/* start change keh 11/6/96 => defect #99: answ sends max of 2 LRs per V.42/A.7.1.3 */
#if 0
*            if (rx_buf_ptr == NULL)
*               if (timer_timeout != 0)
*                    return(mnp_status);
*                else
*got_answer_lr:
*                    if ((mnp_retry_limit -= 1) == 0)
*                        goto bgnd_disconnect_send;
*                    else
*                    {
*                        reset_timeout_timer();
*                        restart_tx();
*                        return(mnp_status);
*                    }
#endif

           if (rx_buf_ptr == NULL)
           {
               if (timer_timeout != 0)
               {
                   return(mnp_status);
               }
               else
               {
got_answer_lr:
                   /* Has retry limit been reached? */
                   if (mnp_retry_limit == 0)
                   {
                       goto bgnd_disconnect_send;
                   }
                   /* If not, resend the LR frame */
                   else
                   {
                       /* MNP10 Answerer sends max of 15 LRs, BUT only
                           after rcving an LR, for up to 30 secs per
                           MNP10 Ver.1.1, Sec.2.2 */
                       if (!mnp10_enabled)
                       {
                           reset_timeout_timer();
                       }
                       restart_tx();
                       mnp_retry_limit--;
                       return(mnp_status);
                   }
               }
            }
/* end change keh 11/6/96 => defect #99: answ sends max of 2 LRs per V.42/A.7.1.3 */

            frame_received_flag = FALSE;
            rcv_working_frame_ptr = get_rx_offset_num((ubyte *)rx_buf_ptr);
            pdu_type = rx_buf_ptr->pdu_type;
            if (pdu_type == PDU_TYPE_LD)
            {
                empty_ld();
                received_disconnect_reason = ld_reason_code;
                received_user_disconnect_reas = ld_user_reason;
                mnp_disconnect_code = DISCONNECT_CODE_NO_REASON;
                goto bgnd_disconnect_shut;
            }
            if (pdu_type == PDU_TYPE_LR)
            {
                put_empty((ubyte *)rx_buf_ptr);
                goto got_answer_lr;
            }

bsai_process_la:

            turnoff_autoreliable();

            if (pdu_type == PDU_TYPE_LA)
            {
                empty_la();
                send_credits = la_credit_amount;
                put_empty((ubyte *)rx_buf_ptr);
                clear_receive_buffers();
                clear_transmit_buffers();
                goto bgnd_data_initial;
            }
            if (pdu_type == PDU_TYPE_LT)
            {
                put_empty((ubyte *)rx_buf_ptr);
                clear_transmit_buffers();
                goto bgnd_data_initial;
            }
            mnp_disconnect_code = DISCONNECT_CODE_PROTOCOL_ERROR;
            goto bgnd_disconnect_send;

        case(BGND_STATE_DATA_INITIAL):
bgnd_data_initial:
            mnp_state = BGND_STATE_DATA_INITIAL;
            reset_retries();
            if (tx_busy_flag)
            {
                reset_transmit_delay(TRANSMIT_DELAY_TIME);
                return(mnp_status);
            }
            if (timer_transmit_delay != 0)
            {
                return(mnp_status);
            }
            else
            {
                if (mnp_negotiated_class == MNP_SERVICE_CLASS_FULL_D_SYNC)
                {
                    line_init(LINK_MNP_SYNC);
                    if (rx_current != 0)
                        put_empty(rx_current);
                    restart_receive();
                    reset_transmit_delay(TRANSMIT_DELAY_TIME);
                }

                if (mnp10_enabled != 0)
                {
                    /*	If upshift is allowed then process it, else continue with the link	*/
                    if (mnp10_retrain_init(MNP10_RETR_INIT__UPSHIFT_INIT) ==
                        MNP10_RETR_INIT__OK)
                    {
                        mnp_state = BGND_STATE_MNP10_INIT_UPSHIFT;
                    }
                    else
                    {
                        mnp_state = BGND_STATE_DATA_WAIT_SYNC;
                    }
                }
                else
                {
                    mnp_state = BGND_STATE_DATA_WAIT_SYNC;
                }
            }
            return (mnp_status);

        case(BGND_STATE_MNP10_INIT_UPSHIFT):
            mnp10_init_upshift();
            return (mnp_status);

        case(BGND_STATE_DATA_WAIT_SYNC):
            if (timer_transmit_delay != 0)
                return(mnp_status);
            send_acknowledge_flag = TRUE;
            mnp_status = MNP_STATUS_RUNNING;

            mnp10_init_vars();
            mnp10_LT_acked = TRUE;

            reset_inactivity_timer();
            mnp_state = BGND_STATE_DATA_STATE;
            return (mnp_status);

        case(BGND_STATE_DATA_STATE):
            if (mnp10_enabled)
            {
                if (t_b_status = mnp10_bg() != CONTINUE)
                    return (mnp_status);
            }
            if (transmit_background() == DISCONNECT_CODE_RETRY_LIMIT_X)
                goto bgnd_disconnect_send;

            mnp_line_bg();
            t_b_status = receive_background();

            mnp10_BTLZ_Balance();

            return(mnp_status);

        case(BGND_STATE_RETRAIN_INIT):

            if (tx_current != NULL)
            {
                return(mnp_status);
            }

            mnp_state = BGND_STATE_RETRAIN_WAIT;
            return(mnp_status);


        case(BGND_STATE_RETRAIN_WAIT):

            mnp10_retrain_bg();

            /* Send an LA after retrains are complete, typically we flow off
                the remote before attempting speed changes */
            if (mnp_state == BGND_STATE_DATA_STATE)
            {
                build_la();
                send_la();
            }

            return(mnp_status);

        case(BGND_STATE_DISCONNECT_SEND):
bgnd_disconnect_send:
            mnp_status = MNP_STATUS_DISCONNECTING;
            mnp_state = BGND_STATE_DISCONNECT_SEND;
            if (tx_busy_flag)
                return(mnp_status);
            /* IF USER DISCONNECT CODE != 0, SEND AS PART OF LD */
            build_ld();
            send_ld();
            reset_timeout_timer();

        case(BGND_STATE_DISCONNECT_WAIT):
            mnp_state = BGND_STATE_DISCONNECT_WAIT;
            if (tx_busy_flag)
            {
                reset_transmit_delay(TRANSMIT_DELAY_LONG_TIME);
                return(mnp_status);
            }
            if (timer_transmit_delay != 0)
                return(mnp_status);
            else
            {
                send_ld();
                reset_timeout_timer();
            }

        case(BGND_STATE_DISCONNECT_WAIT_2):
            mnp_state = BGND_STATE_DISCONNECT_WAIT_2;
            if (tx_busy_flag)
            {
                reset_transmit_delay(TRANSMIT_DELAY_LONG_TIME);
                return(mnp_status);
            }
            if (timer_transmit_delay != 0)
                return(mnp_status);

        case(BGND_STATE_DISCONNECT_SHUT):
bgnd_disconnect_shut:
            mnp_status = MNP_STATUS_DISCONNECTING;
            mnp_state = BGND_STATE_DISCONNECT_SHUT;
            if (tx_busy_flag)
            {
                reset_transmit_delay(TRANSMIT_DELAY_TIME); /* 2/10 SECONDS */
                return(mnp_status);
            }
            if (timer_transmit_delay != 0)
                return(mnp_status);

            if ((process_que__in != process_que__out) && (!idle_flag))
            {
                if (dte_to_free() != 0)
                {
                    receive_background(); /* deliver all packets received */
                    return(mnp_status);
                }
            }

            if (buffering_enabled_flag == FALSE)
            {
                line_reset();
                goto bgnd_halted;
            }

            if (mnp_fallback_active == TRUE)
            {
                /*	Indicate to V.42 that MNP 10 is no longer running	*/
                negotiate_mnp10(0);
                mnp10_enabled = FALSE;
                line_setup_speed();
                mnp_fallback_active = FALSE;
                mnp_state = BGND_STATE_BUFFERING_DATA;
                mnp_status = MNP_STATUS_MATCHING;
                reset_inactivity_timer();
                return(mnp_status);
            }

        case(BGND_STATE_BUFFERING_INIT):
            mnp_state = BGND_STATE_BUFFERING_INIT;
            if (buffering_enabled_flag == FALSE)
                goto bgnd_disconnect_shut;
            line_init(LINK_BUFFER_ASYNC);
            reset_inactivity_timer();
            mnp_state = BGND_STATE_BUFFERING_DATA;
            mnp_status = MNP_STATUS_MATCHING;

            /*	Indicate to V.42 that MNP 10 is no longer running	*/
            negotiate_mnp10(0);
            mnp10_enabled = FALSE;

            return(mnp_status);

        case(BGND_STATE_BUFFERING_DATA):

            mnp_state = BGND_STATE_BUFFERING_DATA;

            if ((lna_delayed_flag == TRUE) && (lna_delay_count == 0))
            {
                lna_delayed_flag = FALSE;
                tx_attention_flag = TRUE;
            }

            if (tx_attention_flag == TRUE)
            {
                tx_attention_flag = FALSE;
                line_to_break(mnp_attention_process,mnp_length_lbrk);
                reset_inactivity_timer();
            }

            if (idle_flag == TRUE)
                return(mnp_status);

            if ((dce_delayed_flag == TRUE) && (dce_delay_count == 0))
            {
                dce_delayed_flag = FALSE;
                receive_attention_flag = TRUE;
            }

            if (receive_attention_flag == TRUE)
            {
                receive_attention_flag = FALSE;
                dte_to_break(mnp_attention_process,mnp_length_tbrk);
                reset_inactivity_timer();
            }
            while((line_to_free() != 0) && (dte_from_num() != 0))
            {
                line_to_char(dte_from_char());
                reset_inactivity_timer();
                if (lna_delay_count != 0)
                {
                    lna_delay_count--;
                    if (lna_delay_count == 0)
                        break;
                }
            }
            while((dte_to_free() != 0) && (line_from_num() != 0))
            {
                dte_to_char(line_from_char());
                reset_inactivity_timer();
                if (dce_delay_count != 0)
                {
                    dce_delay_count--;
                    if (dce_delay_count == 0)
                        break;
                }
            }
            return(mnp_status);

        case(BGND_STATE_LAPM_ANSW_INITIAL):
            rx_buf_ptr = (struct buffer_entry *)get_process();
            if (rx_buf_ptr == NULL)
            {
                return(mnp_status);
            }

            frame_received_flag = FALSE;
            rcv_working_frame_ptr = get_rx_offset_num((ubyte *)rx_buf_ptr);
            pdu_type = rx_buf_ptr->pdu_type;
            if (pdu_type == PDU_TYPE_LAPM_LR)
            {
                put_empty((ubyte *)rx_buf_ptr);
                send_lr();
                return(mnp_status);
            }
            goto bsai_process_la;

        case(BGND_STATE_HALTED):
        default:
bgnd_halted:
            mnp_state = BGND_STATE_HALTED;
            mnp_status = MNP_STATUS_HALTED;
            mnp_reset();
            return(mnp_status);
    }
}

