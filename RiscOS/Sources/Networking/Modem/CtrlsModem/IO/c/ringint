
/* ringint.c 1-24-96 */

#include   <string.h>

#include   "sys_def.h"
#include   "acu_def.h"
#include    "callerid.h"
#include    "ptt.h"

extern ubyte  sleep_timer_val;       /* for sleep mode */
extern ubyte line_io_enabled;
extern void  output_info(ubyte *,ubyte);

ubyte    tembuf[4];
ubyte    ringff;       /* for debounce ring int */

uword    msec_counter = 0;
uword    ringon_time = 0;

ubyte    cidbuf[BUFLEN];
ubyte    ring_pattern[8];
ubyte    seq = 0;
ubyte    calling  = FALSE;
ubyte    pattern_start = FALSE;
ubyte    osilating = FALSE;
ubyte    ring_on = FALSE;
ubyte    first_on = TRUE;

ubyte  date[8], time[8], nmbr[16], name[16], mesg[81];

extern  ubyte cid_result;
extern  ubyte fax_class;
extern  ubyte voice_dist_ring_time;
extern  ubyte voice_dist_ring_active;


extern   ubyte s[];
extern   ubyte voice_caller_id;

extern   void  set_callerid_relay(uword);
extern   ubyte callerid_msg_seg(ubyte*);
extern   void  set_dsp_cid(ubyte);
extern   void  output_send_cr_lf(void);
extern   void  init_cid(void);
extern   ubyte get_cid_data(ubyte buf[]);
extern   country_ring_table PTT_Ring[7];
extern   ubyte CountryInfo;
/*mrm8896*/
extern   ubyte  caller_id_end ;

void    init_varibles(void);
void    validate_ring(void);
void    process_cadence(void);
void    d_to_a2(ubyte val, ubyte buf[]);


extern ubyte vce_mode;
#define	TRANSMIT_MODE	2
#define	RECEIVE_MODE	3

void  init_varibles()
{
  msec_counter = 0;
  ringon_time = 0;
  seq = 0;
  calling = FALSE;
  pattern_start = FALSE;
  osilating = FALSE;  
  ring_on = FALSE;
  first_on = TRUE;
  sleep_timer_val = 0;       /* for sleep mode */
}

/****************************************************************************
/
/    Routine: validate_ring
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 01/24/96
/
/    Description : This Routine is called when a ring Interrupt happen
/                  to sum all ring on time  
/
/    Users: coming ring
/
/       Reason: Needed for the +VDR and +VDT.
/
/
****************************************************************************/
void  validate_ring()
{
/* for hardware Int bug, each int comes with 10-20 redudant ints */
  if( msec_counter == 0 ) return;
          
  if( ringff == 0 )  ringff = 1;
  else { ringff = 0; return; }
/* 5/16/96 */

  if(pattern_start == TRUE )
  {
      if(osilating == TRUE)  {

/* stardard ring frq 15.3 - 68, i.e. period 65.4 - 14.7 mSec */
/* test ring frq     14.0 - 75 Hz,   period 71   - 13.3 */
/* validate ring from period */

         if(ringon_time<220 && ( msec_counter < PTT_Ring[CountryInfo].TimeMin/*14*/ || msec_counter > PTT_Ring[CountryInfo].TimeMax/*66*/) ) ;
         else  ringon_time = ringon_time + msec_counter;
      }

/* osilating == FALSE */
      else   {

/* in USA, ring frequency is about 20Hz (50mSec), do related adjustment */
         ring_pattern[seq] = (msec_counter-25+50)/100; /* 0.1s unit */

         if(voice_dist_ring_active)   {
             voice_dist_ring_time  = ring_pattern[seq];
             d_to_a2(voice_dist_ring_time,tembuf);

             strcpy((char *)cidbuf,"DROF=");
             strcat((char *)cidbuf,(char *)tembuf);

             output_info(cidbuf,NUMERIC_FORM);  /* CR, LF after */

/* ring off time, but not the final */
         }
      }
/* osilating == FALSE */
  }

/* pattern_start == FALSE */
  else   
  {  
     if(seq != 0)  {

/* for preventing wrong int */
        if(msec_counter < 1000)   return;

/* ring off time, final */
        ring_pattern[seq] = (msec_counter-25+50)/100;   

        if(voice_dist_ring_active)  {
            voice_dist_ring_time  = ring_pattern[seq];
            d_to_a2(voice_dist_ring_time,tembuf);

            strcpy((char *)cidbuf,"DROF=");
            strcat((char *)cidbuf,(char *)tembuf);

            if( fax_class == 8 ) strcat((char *)cidbuf,"\x0d\x0a\x10.");

            output_info(cidbuf,NUMERIC_FORM);  /* CR, LF after */
/* <DLE><.>, Voice message end   */
        }

        seq++;
        ring_pattern[seq] = 0xff;  
        seq = 0;
    
        first_on = TRUE;

        if( voice_caller_id !=0 && s[1]==1 && msec_counter >= 1000 &&
          ((vce_mode != TRANSMIT_MODE) && (vce_mode != RECEIVE_MODE)))  
/* ramn 4/5/96 */
        {         
            set_dsp_cid(0);
            set_callerid_relay( CID_RELAY_OFF);
        }
     }  
/* seq != 0  */

     calling = TRUE;
     pattern_start = TRUE;
     ringon_time = 0;
  }
/* pattern_start == FALSE */

  osilating = TRUE;
  msec_counter = 0;
} /* end */
  

/*******************************************************************************
/
/    Routine: process_cadence
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 01/24/96
/
/    Description : This Routine is called every 10msec  
/                  caculate the time passed, save it into ring_pattern[seq] 
/             to get cadence, ex: 4 2 4 20 
/
/    Users: acu_timer() in acu.c
/
/    Reason: Needed for the +VDR and +VDT.
/
/
*************************************************************************/

void    process_cadence()  /* be called every 10 msec */
{
  if(calling == TRUE)
  {
      if(osilating == TRUE)    {
/*consider minimum fr 15Hz, 15% error, period~=75 msec */
/* silent time 125 - 490 msec */
         if( msec_counter > 80 && msec_counter < 120)    {
             if( voice_caller_id !=0 && s[1]==1 &&
                ((vce_mode != TRANSMIT_MODE) && 
                (vce_mode != RECEIVE_MODE) )    )  /* ramn 4/5/96 */
             {
                   cid_result = get_cid_data(cidbuf);     
             }
         }
/* move data from comram into cidbuf[] */
/* this code is in 10msec background, will be called 5 times; */

/* m sec */        
         else if( msec_counter > 120)    {

/* min and max duration */
              if(ringon_time > 220 && ringon_time < 4450 )     {
/*ring on time, .1s*/
                 ring_pattern[seq] = (ringon_time+25+50)/100;  

/*mrm8896*/

                 if( voice_caller_id !=0 && s[1]==1 && (caller_id_end == 0) && 
                    ( (vce_mode != TRANSMIT_MODE) && 
                    (vce_mode != RECEIVE_MODE) )     )  /* ramn 4/5/96 */
                 {         
                     if(cid_result == OK)
                     cid_result = callerid_msg_seg(cidbuf);
/* move data from cidbuf[] into date[], time[], nmbr[], name[], mesg[] */

                     if(voice_caller_id == 1 && cid_result == OK)    {

                        if( fax_class == 8 ) 
                            strcpy((char*)cidbuf,"\x10X\x0d\x0a"); /* ramn 6/28/96 */

                        if( fax_class ==8 ) strcat((char *)cidbuf,"DATE=");
                        else                strcpy((char *)cidbuf,"DATE=");

                        strcat((char *)cidbuf,(char *)date);

                        strcat((char *)cidbuf,"\x0d\x0aTIME=");	/* ramn 6/28/96 */
                        strcat((char *)cidbuf,(char *)time);

                        strcat((char *)cidbuf,"\x0d\x0aNMBR=");	/* ramn 6/28/96 */
                        strcat((char *)cidbuf,(char *)nmbr);

                        if(name[0] != 0)    {  
                           strcat((char *)cidbuf,"\x0d\x0aNAME=");	/* ramn 6/28/96 */
                           strcat((char *)cidbuf,(char *)name);
                        }

                        if(mesg[0] != 0)    {  
                           strcat((char *)cidbuf,"\x0d\x0aMESG=");	/* ramn 6/28/96 */
                           strcat((char *)cidbuf,(char *)mesg);
                        }

                        if( fax_class ==8 )
                            strcat((char *)cidbuf,"\x0d\x0a\x10.");	/* ramn 6/28/96 */

                        output_info(cidbuf,VERBOSE_FORM);
/*mrm8896*/
                     		caller_id_end = 1;
	                  }
/* if(voice_caller_id == 1 && cid_result == OK)    */

                     else if(voice_caller_id == 2 && cid_result == OK)   { 
                        if( fax_class ==8 )  {
                            strcpy((char *)cidbuf,"\x10X\x0d\x0a");	/* ramn 6/28/96 */
                            strcat((char *)cidbuf,"MESG=");
                        }
                        else   strcpy((char *)cidbuf,"MESG=");

                        strcat((char *)cidbuf,(char *)mesg);
              
                        if( fax_class ==8 )
                            strcat((char *)cidbuf,"\x0d\x0a\x10.");	/* ramn 6/28/96 */

                        output_info(cidbuf,VERBOSE_FORM);
/*mrm8896*/
								caller_id_end = 1;
                     }

                     else if(voice_caller_id !=0 && cid_result == CID_ERROR) {
                        if( fax_class ==8 )  {
                           strcpy((char *)cidbuf,"\x10X\x0d\x0a");	/* ramn 6/28/96 */
                           strcat((char *)cidbuf,"ERRM=ICLID_202");
                        }
                        else    strcpy((char *)cidbuf,"ERRM=ICLID_202");

                        if( fax_class ==8 )
                           strcat((char *)cidbuf,"\x0d\x0a\x10.");	/* ramn 6/28/96 */
          
                        output_info(cidbuf,VERBOSE_FORM);
                     }
                     else   ;

/* to prevent repeat drof info, because cidbuf is shared by cid and vdr */
                 }

                 if(voice_dist_ring_active)         {
                    voice_dist_ring_time  = ring_pattern[seq];
                    d_to_a2(voice_dist_ring_time,tembuf);

                    if( fax_class == 8 && first_on != FALSE)    {
                        strcpy((char *)cidbuf,"\x10X\x0d\x0a");	/* ramn 6/28/96 */
                        strcat((char *)cidbuf,"DRON=");
                    }
                    else                 strcpy((char *)cidbuf,"DRON=");

                    strcat((char *)cidbuf,(char *)tembuf);

                    output_info(cidbuf,VERBOSE_FORM);  
/*VERVOSE_FORM => CR,LF before & after */

                    first_on = FALSE;
                 }

                 seq++;              /* ring on time */
                 ringon_time = 0;
                 ring_on = TRUE;
                 osilating = FALSE;  /* no osilating on the line */
             }
/* if(ringon_time > 220 && ringon_time < 4450 ) */

             else init_varibles();
         }
         else ; /* if msec_counter > 100 */
      }

/* osilating == FALSE */
      else      {
/*max ring off time is 4450 */  
         if( msec_counter > 5000  )     {

            if( voice_caller_id !=0 &&
                ( (vce_mode != TRANSMIT_MODE) &&
                ( vce_mode != RECEIVE_MODE ) )    )  /* ramn 4/5/96 */
            {
                 set_dsp_cid(0);
                 set_callerid_relay( CID_RELAY_OFF);
            }
            ring_pattern[seq] = 50;   /* 0.1 sec as unit */
/* ring off time, end */


            if(voice_dist_ring_active)     {   
               voice_dist_ring_time  = ring_pattern[seq];
               d_to_a2(voice_dist_ring_time,tembuf);

               strcpy((char *)cidbuf,"DROF=");
               strcat((char *)cidbuf,(char *)tembuf);

               if( fax_class == 8 )   strcat((char *)cidbuf,"\x0d\x0a\x10.");		/* ramn 6/28/96 */

               output_info(cidbuf,VERBOSE_FORM);  /* CR, LF after */
            }

            seq++;      
            ring_pattern[seq] = 0xff;   /* end indicator */
            init_varibles();
        }  

/* max case, 490 msec */  
        else if(msec_counter > REPORT )   {

/* 2-26-96 shujin, for callerid */
           if( voice_caller_id !=0 && s[1] == 0 && 
	            (vce_mode != TRANSMIT_MODE) && 
               (vce_mode != RECEIVE_MODE)       )  /* ramn 4/5/96 */
           {
              set_callerid_relay( CID_RELAY_ON);
              init_cid();

/* for prevent DCE stealing info from COMRAM, no callerid info available */       
              line_io_enabled = FALSE;

              set_dsp_cid(1);
           }  

           ring_on = FALSE;
           pattern_start = FALSE;
           sleep_timer_val = 0;       /* init the variable */

        }   /* else if(msec_counter > REPORT */
     }      /* else ( osilating == FALSE */
  }         /*  if(calling == TRUE) */
}           /* end */


void d_to_a2(ubyte val, ubyte buf[])
{
  ubyte tem2,tem1, i;

  i=0;
  tem1 = val % 10;
  tem2 = val / 10;
  tem2 = tem2 % 10;

  if(tem2 == 0) buf[i++] = tem1 + '0';
  else  { buf[i++]=tem2+'0'; buf[i++]=tem1+'0'; }   

  buf[i] = 0; 
}
