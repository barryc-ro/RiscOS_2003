/****************************************************************************
/
/   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994.  All Rights 
/   Reserved by: 
/   RSA 
/   7701 Six Forks Road 
/   Suite 120 
/   Raleigh, NC  27615 
/   (919) 846-7171 
/
/   This document contains material confidential to RSA. Its contents 
/   must not be revealed, used or disclosed to anyone or company without 
/   written permission by RSA. The information contained herein is solely 
/   for the use of RSA. 
/
/   File:                dte_v80.c
/
/   Module Version: 
/
/   Function: 
/
/   Product: 
/
/   -----------------------------------------------------------
/   -                       Modifications                     -
/   -----------------------------------------------------------
/
/   Author & Date:     RSA 
/   Description: 
/   Reason: 
/
****************************************************************************/

#include "sys_def.h"
#include "acuiomem.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "dteequ.h"
#include "dte.edf"
#include "v80_pro.h"

extern void enable_int(void);
extern void disable_int(void);

/************************************************************************
/
/  Routine:          v80_dte_init
/
/  Author:           RSA
/
/  Creation Date:    08/14/96
/
/  Description:      This routine initializes the DTE IO code
/                    for V.80 operation.
/
/  Input Parameters: None
/
/  Output Parameters: None
/
/  Global Variables Changed:  
/
/  Users:   
/
/  -------------------------------
/  -        Modifications        -
/  -------------------------------
/
/  Author & Date: RSA 
/  Description: 
/  Reason:
/
************************************************************************/
void v80_dte_init(ubyte in_baud_rate,ubyte in_dte_to_modem_flow_cntl,
                  ubyte in_modem_to_dte_flow_cntl )
{
   disable_int();
   dte_mode = V80_SAM;
   dte_sub_mode = TRANSPARENT_SUB_MODE;

   /* S/W flow control chars */
   modem_to_dte_xoff_char = XOFF_CHAR;
   dte_to_modem_xoff_char = XOFF_CHAR;
   modem_to_dte_xon_char = XON_CHAR; 
   dte_to_modem_xon_char = XON_CHAR; 

   modem_to_dte_flow_cntl = in_modem_to_dte_flow_cntl;
   dte_to_modem_flow_cntl = in_dte_to_modem_flow_cntl;

   /* Init status vars */
   rx_suspended = FALSE;
   rx_suspend_pending = FALSE;
   rx_resume_pending = FALSE;
   dte_tx_interrupt_expected = FALSE;
   dte_tx_suspended_by_terminal= FALSE;
   tx_suspended_for_break = FALSE;

   dte_port_init();
   enable_int();
}


/************************************************************************
/
/  Routine:          dte_conf_ITF_flow
/
/  Author:           RSA
/
/  Creation Date:    08/14/96
/
/  Description:      Sets new XON and XOFF buffer threshold values.
/                    This values are set by the +ITF command.
/
/  Input Parameters:
/
/     uword xoff_value:
/        0x0000 - 0xFFFF
/
/     uword xon_value:
/        0x0000 - 0xFFFF
/
/  Output Parameters: None
/
/  Global Variables Changed: None
/
/  Users:
/
/  ----------------------------
/  -       Modificatons       -
/  ----------------------------
/
/  Author & Date:
/  Descrition:
/  Reason:
/
*************************************************************************/
void dte_conf_ITF_flow(uword xoff_value,uword xon_value)
{
   dte_xoff_threshold = xoff_value;
   dte_xon_threshold = xon_value;
}


/************************************************************************
/
/  Routine:          dte_process_unum
/
/  Author:           RSA
/
/  Creation Date:    08/14/96
/
/  Description:      Used to immediately indicate that a transmit
/                    underrun occurred in the DCE I/O while during
/                    V.80 Framed Sub-Mode in mid-frame.
/
/  Input Parameters: ubyte character
/
/  Output Parameters: None
/
/  Global Variables Changed: None
/
/  Users:
/
/  ----------------------------
/  -       Modificatons       -
/  ----------------------------
/
/  Author & Date:
/  Descrition:
/  Reason:
/
*************************************************************************/
void dte_process_unum(void)
{
#if 0
   /* if no data to transmit, send <EM><UNDER> code now */
   if ((dte_tx_count == 0) && (last_pc_tx_byte != EM_CODE) &&
       (dte_tx_underrun == FALSE) && (dte_tx_unum_pending == FALSE))
   {
      /* transmit the <EM><UNDER> code now */
      PCterminal_to_char(EM_CODE);
      PCterminal_to_char(UNDER_CODE);
      discard_byte_count = 0;
      dte_tx_underrun = TRUE;
   }
   else if ((dte_tx_underrun == FALSE) && (dte_tx_unum_pending == FALSE))
   {
      discard_byte_count = 0;
      dte_tx_underrun = TRUE;
      dte_tunder_pending = TRUE;
   }
#endif
}


/************************************************************************
/
/  Routine:          dte_sub_mode
/
/  Author:           RSA
/
/  Creation Date:    08/18/96
/
/  Description:      Used to notify the DTE I/O of the current
/                    V.80 SAM Sub-Mode.  This is necessary to know
/                    what action to take upon TX_OVERRUN.
/
/  Input Parameters: ubyte character
/
/  Output Parameters: None
/
/  Global Variables Changed: None
/
/  Users:
/
/  ----------------------------
/  -       Modificatons       -
/  ----------------------------
/
/  Author & Date:
/  Descrition:
/  Reason:
/
*************************************************************************/
void dte_set_sub_mode(ubyte sub_mode)
{
   dte_sub_mode = sub_mode;
}


/************************************************************************
/
/  Routine:          dte_v80_configure
/
/  Author:           RSA
/
/  Creation Date:    08/18/96
/
/  Description:      Used to notify the DTE I/O of the current
/                    +ESA command settings.  This is necessary to
/                    know what action to take upon TX_OVERRUN.
/
/  Input Parameters: ubyte character
/
/  Output Parameters: None
/
/  Global Variables Changed: None
/
/  Users:
/
/  ----------------------------
/  -       Modificatons       -
/  ----------------------------
/
/  Author & Date:
/  Descrition:
/  Reason:
/
*************************************************************************/
void dte_v80_configure(ubyte framed_un_ov)
{
   dte_framed_un_ov = framed_un_ov;
}


/************************************************************************
/
/  Routine:          dte_v80_rx
/
/  Author:           RSA
/
/  Creation Date:    08/14/96
/
/  Description:      Uses the passed character to update the
/                    DTE V80 state machine.
/
/  Input Parameters: ubyte character
/
/  Output Parameters: None
/
/  Global Variables Changed: None
/
/  Users:
/
/  ----------------------------
/  -       Modificatons       -
/  ----------------------------
/
/  Author & Date:
/  Descrition:
/  Reason:
/
*************************************************************************/
void dte_v80_rx(ubyte ch)
{
#if 0
   switch (dte_v80_rx_state)
   {
      case V80_RX_START:
      default:
         if (ch == EM_CODE)
         {
            /* goto next state and do not store the byte */
            dte_v80_rx_state = V80_RX_FOUND_EM;
         }
         else
         {
            /* store the received byte */
            if ((dte_tx_overrun || dte_tx_underrun) && (dte_mode != ACU))
            {
               /* increment the UNUM discard count */
               discard_byte_count++;
            }
            else
            {
               dte_rx_buffer[dte_rx_insert++] = ch;
               dte_rx_insert &= BUFFER_POINTER_MASK;
               dte_rx_count++;
            }
         }
         break;

      case V80_RX_FOUND_EM:
         switch (ch)
         {
            case RESUME_CODE:
               /* clear all flags after resume detected */
               dte_tx_overrun = FALSE;
               dte_tover_pending = FALSE;
               dte_tx_underrun = FALSE;
               dte_tunder_pending = FALSE;

/* START CHANGE - 09/03/96 - mlc */
               /* pass the <EM><RESUME> code to the V.80 Module */
               dte_rx_buffer[dte_rx_insert++] = EM_CODE;
               dte_rx_insert &= BUFFER_POINTER_MASK;
               dte_rx_count++;
               dte_rx_buffer[dte_rx_insert++] = RESUME_CODE;
               dte_rx_insert &= BUFFER_POINTER_MASK;
               dte_rx_count++;
/* END CHANGE - 09/03/96 - mlc */

               if ((dte_tx_count == 0) && (last_pc_tx_byte != EM_CODE))
               {
                  PCterminal_to_char(EM_CODE);
                  PCterminal_to_char(UNUM_CODE);
                  PCterminal_to_char((ubyte)((discard_byte_count>>7) & 0x00FE) );
                  PCterminal_to_char((ubyte)(discard_byte_count<<1 & 0x00FE) );
                  discard_byte_count = 0;
               }
               else
               {
                  dte_tx_unum_pending = TRUE;
               }
               break;

            default:
               if ((dte_tx_overrun || dte_tx_underrun) && (dte_mode != ACU))
               {
                  /* increment the UNUM discard count by two */
                  discard_byte_count += 2;
               }
               else
               {
                  dte_rx_buffer[dte_rx_insert++] = EM_CODE;
                  dte_rx_insert &= BUFFER_POINTER_MASK;
                  dte_rx_count++;
                  dte_rx_buffer[dte_rx_insert++] = ch;
                  dte_rx_insert &= BUFFER_POINTER_MASK;
                  dte_rx_count++;
               }
               break;
         }
         dte_v80_rx_state = V80_RX_START;
         break;
   }
#endif
}

/************************************************************************
/
/  Routine:          dte_v80_tx
/
/  Author:           RSA
/
/  Creation Date:    08/14/96
/
/  Description:      Inserts <EM> character code in-band with the
/                    DTE I/O transmit data.
/
/  Input Parameters: ubyte character
/
/  Output Parameters: None
/
/  Global Variables Changed: None
/
/  Users:
/
/  ----------------------------
/  -       Modificatons       -
/  ----------------------------
/
/  Author & Date:
/  Descrition:
/  Reason:
/
*************************************************************************/
void dte_v80_tx(void)
{
#if 0
   if ((dte_tover_pending == TRUE) && (last_pc_tx_byte != EM_CODE) &&
       (fifo_count >= 3))
   {
      PCterminal_to_char(EM_CODE);
      PCterminal_to_char(TOVER_CODE);
      fifo_count -= 2;
      dte_tover_pending = FALSE;

/* DEBUG ONLY - mlc+ */
/* INSERT LATER WHEN PATCHES ARE FINISHED */
#if 0
      /* insert the appropriate <EM> command to the V.80 module */
      if (dte_sub_mode == FRAMED_SUB_MODE)
      {
         dte_rx_buffer[dte_rx_insert++] = EM_CODE;
         dte_rx_insert &= BUFFER_POINTER_MASK;
         dte_rx_count++;

         /* insert an ABORT or FLAG into the rx data stream */
         if (dte_framed_un_ov == 0)
         {
            dte_rx_buffer[dte_rx_insert++] = ERR_CODE;
            dte_rx_insert &= BUFFER_POINTER_MASK;
            dte_rx_count++;
         }
         else
         {
            dte_rx_buffer[dte_rx_insert++] = FLAG_CODE;
            dte_rx_insert &= BUFFER_POINTER_MASK;
            dte_rx_count++;
         }
      }
#endif
/* INSERT LATER WHEN PATCHES ARE FINISHED */
/* DEBUG ONLY - mlc- */

   }

   else if ((dte_tx_unum_pending == TRUE) && (last_pc_tx_byte != EM_CODE) &&
            (fifo_count >= 5))
   {
      PCterminal_to_char(EM_CODE);
      PCterminal_to_char(UNUM_CODE);
      PCterminal_to_char((ubyte)((discard_byte_count>>7) & 0x00FE) );
      PCterminal_to_char((ubyte)(discard_byte_count<<1 & 0x00FE) );
      dte_tx_unum_pending = FALSE;
      fifo_count -= 4;
      discard_byte_count = 0;
   }
   else if ((dte_tunder_pending == TRUE) && (last_pc_tx_byte != EM_CODE) &&
            (fifo_count >= 3))
   {
      PCterminal_to_char(EM_CODE);
      PCterminal_to_char(UNDER_CODE);
      fifo_count -= 2;
      dte_tunder_pending = FALSE;
   }

   /* transmit the buffered byte */
   PCterminal_to_char(last_pc_tx_byte=dte_tx_buffer[dte_tx_remove]);

   dte_tx_count--;
   dte_tx_remove++;   
   fifo_count--;
#endif
}

