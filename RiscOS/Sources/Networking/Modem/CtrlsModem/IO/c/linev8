/*********************************************************************
/
/   Copyright, 1988 - 1995.  All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC 27615
/       (919) 846-7171
/
/   This document contains material confidential to RSA.
/   Its contents must not be revealed, used or disclosed to
/   anyone or company with out written permission by RSA.
/   The information contained herein is solely for the use of RSA.
/
/   File:       linev8.c
/
/   Version:    1.0
/
/   Function:   This file contains all I/O procedures relavent to the
/           detection phase of the V.42 protocols.
/
/   Product:
/
/   History:    Modified from linedetc.c
/
/   Created:    July 31, 1995
/
/   ----------------------------
/   -   Modifications      -
/   ----------------------------
/
/   Author & Date:  RSA
/   Description:
/   Reason:
/
******************************************************************************/
#include "sys_def.h"
#include "lineequ.h"           /* line constant defs */
#include "lineedf.h"           /* line external variable defs */
#include "iohw_equ.h"          /* hardware equates, CRAM etc */
#include "local.h"             /* typedefs for DSP drivers */
#include "dsp_drv.h"           /* DSP driver header file */
#include "mt_coext.h"          /* MT variables */
#include "mt_v8v34.h"

ubyte v8_status = V8_RX_IDLE;
ubyte jm_seq_match = FALSE;
ubyte length;
ubyte old_length;
ubyte vx2_enabled = 0;
/*****************************************************************************
/
/   Procedure:  v8_tx_int
/
/   Author: RSA
/
/   Creation Date:   7/31/95
/
/   Description:
/
/   Input Parameters:  None
/
/   Output Parameters:  None
/
/   Global Variables Changed:
/
/   Users:
/
/   -------------------------
/   -     Modifications -
/   -------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
********************************************************************/
void v8_tx_int(void)
{
   ubyte length, status, i;

   if (sending_JM || sending_CM)
   {
      length = V8_tx_msg_size;

   #if defined (DEBUG_PORT)
   PrintOutChars("V8 Tx: ");
   #endif
   for (i=0; i<V8_tx_msg_size;i++)
   {
   #if defined (DEBUG_PORT)
      outhex(v8_tx_buffer[i]);
      outchar(' ');
   #endif
   } 
   #if defined (DEBUG_PORT)
   outchar(0x0d);
   outchar(0x0a);
   #endif
     
      dspdrv_WriteCram(CP_DSP_DATA_AREA_BASE, &v8_tx_buffer[0], length);  /* sets semaphore */
      status = 0; /* status */
      dspdrv_WriteCram(CP_DSP_DATA_STATUS, &status, 1);  /* sets semaphore */
      dspdrv_WriteCram(CP_DSP_DATA_LENGTH, &length, 1);  /* sets semaphore */
      if (sending_JM)
     JM_count++;
      else
     CM_count++;
   }
}

/*****************************************************************************
/
/   Procedure:  v8_rx_int
/
/   Author: RSA
/
/   Creation Date: July 31, 1995
/
/   Description: This routine will handle the RX READY interrupts from the
/       Merlin.
/
/   Input Parameters:  None
/
/   Output Parameters:  None
/
/   Global Variables Changed:
/
/   Users:
/
/   -------------------------
/   -     Modifications -
/   -------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
****************************************************************************/

void v8_rx_int(void)
{
   ubyte data;
   ubyte address;

   address = DSP_CP_DATA_AREA_BASE;

    while(dce_length_semaphore)
    {
    dspdrv_ReadCram(address, &data, 1);
    address += WORD_OR_BYTE_ADD_INC;
    dce_length_semaphore --;
    switch(v8_status)
    {
        case WAITING_FOR_CM_SEQ: /*validate the first byte of the JM packet*/
            if (data == CM_SEQ)
            {
                v8_status  = SAVING_CM_SEQ;
                old_length = 0;
                length = 0;
                dce_rx_buffer[length++] = data;
            }
            break;

         case SAVING_CM_SEQ: /*
             if first time copy the data in the dce_rx_buffer
             */
             if (data != CM_SEQ)
             {
                dce_rx_buffer[length++] = data;
             }
             else
             {

/*mrm5396*/
                /*if(length <4)*/
                if(length <3)
                {
                 length=1;
                 break;
                }

                v8_status = COMPARE_CM_SEQ;
                old_length = length -1  ;
                length = 1;
              }
              break;

         case COMPARE_CM_SEQ:   /*
               compare the data in the Cram with the data in the
               the dce_rx_buffer
               */
                if( dce_rx_buffer[length] == data )
                {

                dce_rx_buffer[length++] = data;
                old_length --;
                break;

                }
                else if (data != CM_SEQ)
                {
                v8_status = SAVING_CM_SEQ;
                dce_rx_buffer[length++] = data;
                }
                else
                {
                if ( old_length == 0)
                {

                   if (vx2_enabled == 1)
                   {


                    /* Stash away CM stuff into something MT can use */
                    V8_rx_msg_size = length;
                    #if defined (DEBUG_PORT)
                    PrintOutChars("V8 Rx: ");
                    #endif
                    for(length=0;length<V8_rx_msg_size;length++)
                    { 
                      #if defined (DEBUG_PORT)
                      outhex(dce_rx_buffer[length]);
                      outchar(' ');
                      #endif
                      V8_rx_msg[length] = dce_rx_buffer[length];
                    }
                    #if defined (DEBUG_PORT)
                    outchar(0x0d);
                    outchar(0x0a);
                    #endif
                    
                    V8_rx_msg[length] = 0; /* mark end of msg */
                    jm_seq_match = TRUE;
                    dce_length_semaphore = 0;
                    v8_status = CM_SEQ_FOUND;
                    vx2_enabled = 0;
                    }
                    else
                    {
                        vx2_enabled++;
                        v8_status = SAVING_CM_SEQ;
                    }

                }

                else
                {

/*mrm5396*/
                    /*if(length <4)*/
                    if( length < 3)
                    {
                       length    = 1;
                       v8_status = SAVING_CM_SEQ;
                    }
                    else
                    {
                       old_length = length -1  ;
                       length = 1;
                    }
                }
                }
                break;

         case WAITING_FOR_CJ_SEQ:
               /* Check for CJ_SEQ */
               if( data == CJ_SEQ )
               {
                  /* IF I have 3 consequtive 0's turn off */
                  if( ++CJ_received == 3 )
                  {
                 v8_status = V8_RX_IDLE;
                 dce_length_semaphore = 0;
                  }
               }
               else
                  CJ_received=0;
               break;

        case CM_SEQ_FOUND:
          case V8_RX_IDLE:
          default:
               /* Don't need to save anything */
               dce_length_semaphore=0;
               break;

    }

    }

    dce_status_semaphore = 0;

    /* clear semaphores */
    dspdrv_WriteCram(DSP_CP_DATA_LENGTH, &dce_length_semaphore, 1);
    dspdrv_WriteCram(DSP_CP_DATA_STATUS, &dce_status_semaphore, 1);
}

