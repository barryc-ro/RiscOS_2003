/************************************************************************
/
/   Copyright 1994, 1995. All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File:      ACU.C
/
/   Version:   1.00
/
/   Function:  This file contains the ACU IO code
/
/   Product:   H8/3002 IO code
/
/   Platform:  H8/3002 + TI 16PC564 PCMCIA UART (TIPU)
/
/   History:   acu.c v1.00
/
/   Created:   10/27/94
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
#include "mod_def.h" /* added by ramn on 2/5/96 */
#include "sys_def.h"
#include "acuiomem.h"
#include "acu_def.h"
#include "dte_drv.h"
#include "acu_mem.h"
#include "dteequ.h"

/* External prototypes */
extern void dp_int(void);
extern void dp_vce_timer(void);

/* RJM040396 */
/* VCV support */
extern void vcv_timer(void);
#if TIES_HAYES_ESCAPE                           /* ciy021596 */

extern void enable_acu_on_terminal(void);
extern void output_result(ubyte type);
extern void disable_acu_on_terminal(void);
extern void build_event(ubyte, ubyte);
extern void system_rcv_escape(void);
extern uword str_len(ubyte *str);
extern uword DteNearFullValue;

void exit_ties_esc(void);

ubyte ties_esc_state;

#endif

/* Internal prototypes */

void dte_rx_int(void);
void dte_tx_int(void);
void dte_tx_suspend(void);
void dte_tx_resume(void);
void dte_interrupt_tx(void);
void dte_interrupt_rx(void);

/*mrm9195*/
/*place the routines inside the serial.s file*/

extern void enable_int(void);
extern void disable_int(void);

void process_one_msec(void);


ubyte get_autobaud_rate(void);
uword acu_from_num(void);

extern ubyte dte_data_ready(void);
extern ubyte dte_transmit_empty(void);
extern ubyte dte_read_char_from_uart(void);
extern void dte_write_char_to_uart(ubyte);
extern void dte_port_init(void);
extern ubyte dte_rx_resume(void);
extern ubyte dte_rx_suspend(void);
extern void dte_pp_tx_int(void);
extern void dte_pp_rx_int(void);

/* External variables */
extern uword mt_cp_timer;
extern uword mt_cp_timer;
extern ubyte atb_rx_char;
extern ubyte atb_rx_bypass;
extern ubyte dte_auto_baud_rate;
extern void dte_cts_off(void);
extern void dte_cts_on(void);
extern ubyte modem_control_reg_rts(void);


extern void dte_timer(void);
extern void line_timer(void);
extern void modem_timer(void);
extern void fax_timer(void);
extern void dp_vce_timer(void);
extern void PutByte(ubyte);
extern ubyte fifo_not_full(void);
extern void time_out_on_fifo(void);
extern void stop_fifo_timer(void);
extern void start_fifo_timer(void);
extern ubyte uart_fifo_enable;
extern ubyte fax_class;

void 	reload_fifo_timer(void);
void	reload_no_fifo_timer(void);
void	reload_no_fifo_fax_timer(void);


/* Local data */



ubyte autobaud_control;        /* Tracks whether autobaud is active or not */
ubyte	fifo_timeout_to_uart = 0;

/*22296shujin,ring detec*/
extern uword msec_counter;
extern void	process_cadence(void);

extern ubyte Tx_char;
extern void parity(void);
extern ubyte parity_enabled;
ubyte old_serial_dte_baud; /* ramn 4/17/96 */
/*SLei added*/
extern void ToneModeStateSwitch(void);
extern void UpdateBlackListDelayTimer(void);
/* RJM050196 */
ubyte check_all_sent(void);
/*mrm72796*/
extern ubyte ToneModeSwitch;

/*mrm8796*/
/*sw flow cntl data mode only fix*/
extern ubyte poll_mode_enable;

extern void reload_voice_fifo_timer_fast(void);  /* ramn 8/29/96 */
extern void reload_voice_fifo_timer_slow(void);
extern ubyte vce_mode;

/************************************************************************
/
/            acu_port_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/09/94
/
/   Description:   This routine will initialize the dte io code for
/                  the ACU
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  All TIPU registers
/
/   Users:   master_init
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void acu_port_init(void)
{
   dte_port_init();        /* call common routine */
   dte_mode = ACU;
   acu_installed = TRUE;   /* set flag indicating acu interrupts installed */
   acu_status = 0x10;      /* transmmit disabled */
/*mrm8895*/
#if 0
   pp_init(NULL, NULL);    /* void pp_init(ubyte mode, uword time) */
#endif
   atb_rx_bypass=0;
   autobaud_control = 0;
}

/************************************************************************
/
/            hardware_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   10/27/94
/
/   Description:   This routine will initialize the paltform dependent
/                  hardware
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed
/
/   Users:   master_init
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void hardware_init()
{
/*mrm8895*/
#if 0

   uword i;
   ubyte reg_val;
   ulong vect_adr;
   ulong *vect_tbl;



#endif
/*
/   extern void TraceInit(void);
/
/   TraceInit();
*/
}

/************************************************************************
/
/            acu_timer
/
/   Author:    RSA
/
/   Creation Date:   10/27/94
/
/   Description:   This routine will increment the acu interrupt timer
/         ticks.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  acu_10msec_timer, acu_100msec_timer
/               acu_1sec_timer, timer100mS, timer1sec
/
/   Users:   timer_10msec_int
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
void acu_timer(void)
{
/*mrm8895*/

/*22296shujin, ring detec*/

/*mrm72796*/

	if (ToneModeSwitch )
	{	

		ToneModeStateSwitch(); /*SLei added*/
	}

   dte_timer();
   line_timer();
   modem_timer();

	if (!(dte_mode == DTE))
	{

		process_cadence();
   	fax_timer();
   	/*dp_vce_timer();*/ /* ramn 8/19/96 */

/* RJM040396 */
/* VCV Support */
   	vcv_timer();
	
	}

   acu_10msec_timer++;
   if (! --timer100mS )
   {
	 timer100mS = 10;

/*mrm8895*/
#if 0
	 pp_timer();
#endif

	 acu_100msec_timer++;
	 if (! --timer1sec )
	 {
   	 UpdateBlackListDelayTimer(); /*SLei added*/
	    timer1sec = 10;
	    acu_1sec_timer++;
	    if (! --timer1min )
	    {
		  timer1min = 60;
		  acu_1min_timer++;
	    }
	 }
   }
/*mrm9695*/
	 /* Check for RTS/CTS TX suspension */
	 if( dte_tx_suspended_by_terminal && (dte_to_modem_flow_cntl & RTS_AND_CTS) )
	  {
		 /* Host says its OK to continue, well, who are we to argue */
		/*
		 if( UART_MCR & RTS )
		*/

		if( modem_control_reg_rts() )
			dte_tx_resume();
	  }


/*mrm8895*/
#if 0
	wireless_timer();
#endif
}

/************************************************************************
/
/            dte_interrupt
/
/   Author:    RSA (drc)
/
/   Creation Date:   11/18/94
/
/   Description:   This routine will process all TIPU interrupts for
/         the DTE I/O code
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   Timer interrupt for TIPU
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/

#if PARALLEL_MODE == 1



void dte_interrupt_rx(void)
{

ubyte poll_count;

/*mrm82295*/
/*voice mode does not work properly at hi sampling rate so slow 
down the clock and get more data*/

   if (!((dte_mode == ACU) && (acu_halted)))
   {

		if(dte_mode == T_VOICE)/* ramn 8/22/96 */
	 		poll_count = 0;

	  while(dte_data_ready())
	  {
		 	rx_char = dte_read_char_from_uart();
		 	dte_rx_int();

/*mrm82295*/
			if(dte_mode == T_VOICE)  /* ramn 8/22/96 */
			{
	 			poll_count ++;
			   if (poll_count == 115)
					break;
			}


/*mrm82295*/

/*mrm8796*/
/*sw flow cntl data mode only fix*/
			else						/* ramn 8/22/96 */
			{
				if (poll_mode_enable)
					break;
			}
	
	  }


	  /*mrm8895*/
	  /*
	  with the current UART in the arm610 module we do not
	  support the break this function should be enabled when musket
	  chip is preset.
	  */
#if 0

	  if(dte_mode == DTE)     /* DTE mode only for breaks */
	  {
		 if(!dte_rx_break_running && (UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = TRUE;
			dte_rx_break_timer = 0;
		 }
		 if(dte_rx_break_running && !(UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = FALSE;
			v42_dte_break_time = dte_rx_break_timer;
			system_rcv_terminal_break();
		 }
	  }
#endif

   }
}



void dte_interrupt_tx(void)
{



/*mrm8895*/
   if (!((dte_mode == ACU) && (acu_halted)))
   {

	  ubyte fifo_fill_up ;

/*mrm21896*/

/*service the 16550 and 16450*/

	fifo_fill_up = fifo_not_full();
	 if (uart_fifo_enable)
	 {

		if(fax_class != 8)		  /* ramn 8/29/96 */
			reload_fifo_timer();
		else 
		{
			if (vce_mode == 2)  			/* 2 means record mode */
				reload_voice_fifo_timer_fast();
			else 						  /* 3 means playback mode */
				reload_voice_fifo_timer_slow();
		}
	 }
	 else
	 {
   	if ((dte_mode == 3 ) || (fax_class == 1))

			reload_no_fifo_fax_timer();
		else
			reload_no_fifo_timer();

	 }


		if (uart_fifo_enable)
		  fifo_fill_up = 16;
		else
		  fifo_fill_up = 1;



	  while ( fifo_fill_up)
	  {
	  	if((dte_transmit_empty())||(fifo_not_full()))
		{
		 	dte_tx_int();

			fifo_fill_up --;

		}
		else
			fifo_fill_up =0;
	  }




	 /* Check for RTS/CTS TX suspension */
	 if( dte_tx_suspended_by_terminal && (dte_to_modem_flow_cntl & RTS_AND_CTS) )
	  {
		if( modem_control_reg_rts() )
			dte_tx_resume();
	  }


	  /*mrm8895*/
	  /*
	  with the current UART in the arm610 module we do not
	  support the break this function should be enabled when musket
	  chip is preset.
	  */
#if 0

	  if(dte_mode == DTE)     /* DTE mode only for breaks */
	  {
		 if(!dte_rx_break_running && (UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = TRUE;
			dte_rx_break_timer = 0;
		 }
		 if(dte_rx_break_running && !(UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = FALSE;
			v42_dte_break_time = dte_rx_break_timer;
			system_rcv_terminal_break();
		 }
	  }
#endif

   }
}


#endif







#if SERIAL_MODE == 1



void dte_interrupt_rx(void)
{

/*mrm8895*/
   if (!((dte_mode == ACU) && (acu_halted)))
   {


	  if(dte_data_ready())
	  {

		 rx_char = dte_read_char_from_uart();
		 dte_rx_int();


	  }


	  /*mrm8895*/
	  /*
	  with the current UART in the arm610 module we do not
	  support the break this function should be enabled when musket
	  chip is preset.
	  */
#if 0

	  if(dte_mode == DTE)     /* DTE mode only for breaks */
	  {
		 if(!dte_rx_break_running && (UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = TRUE;
			dte_rx_break_timer = 0;
		 }
		 if(dte_rx_break_running && !(UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = FALSE;
			v42_dte_break_time = dte_rx_break_timer;
			system_rcv_terminal_break();
		 }
	  }
#endif

   }
}



void dte_interrupt_tx(void)
{



/*mrm8895*/
   if (!((dte_mode == ACU) && (acu_halted)))
   {
	  /*
	  if(dte_data_ready())
	  {
		 rx_char = dte_read_char_from_uart();
		 dte_rx_int();
	  }
	  */
/*
	  if(dte_transmit_empty())
*/
		 dte_tx_int();
/*ramn 2/6/96 */
	 /* Check for RTS/CTS TX suspension */
	 if( dte_tx_suspended_by_terminal && (dte_to_modem_flow_cntl & RTS_AND_CTS) )
	  {
		if( modem_control_reg_rts() )
			dte_tx_resume();
	  }



	  /*mrm8895*/
	  /*
	  with the current UART in the arm610 module we do not
	  support the break this function should be enabled when musket
	  chip is preset.
	  */
#if 0

	  if(dte_mode == DTE)     /* DTE mode only for breaks */
	  {
		 if(!dte_rx_break_running && (UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = TRUE;
			dte_rx_break_timer = 0;
		 }
		 if(dte_rx_break_running && !(UART_LCR & RX_BREAK))
		 {
			dte_rx_break_running = FALSE;
			v42_dte_break_time = dte_rx_break_timer;
			system_rcv_terminal_break();
		 }
	  }
#endif

   }
}


#endif







/************************************************************************
/
/            dte_tx_int
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will confirm the transmission of a data
/         buffer to the terminal
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  ACU_NTS, ACU_NTF, ACU_TX_COUNT, ACU_TX_INSERT
/               ACU_TX_BUFFER, ACU_STATUS
/
/   Users:   None
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_tx_int(void)
{
   ubyte tx_char;

   if ((dte_mode == ACU) && acu_installed && pp_enabled)
	 dte_pp_tx_int();
   else
   {

	   if ( rx_resume_pending )
		   dte_rx_resume();


		if (dte_to_modem_flow_cntl & XON_AND_XOFF)
		{
	 	/* If we're waiting to send an XOFF, send it now */

	   if ( rx_suspend_pending )
		   dte_rx_suspend();

	 	/* If we're waiting to send an XON, send it now */
	   if ( rx_resume_pending )
		   dte_rx_resume();
		}

	   if (!dte_tx_suspended_by_terminal && dte_tx_count &&
			!tx_suspended_for_break )
	   {

		dte_write_char_to_uart(dte_tx_buffer[dte_tx_remove++]);
	    dte_tx_remove &= BUFFER_POINTER_MASK;
	    dte_tx_count--;
	 	}

#if PARALLEL_MODE == 1

		else if((!(dte_transmit_empty())) && !(dte_tx_count) )
		{
			if (uart_fifo_enable)
			{
		 		fifo_timeout_to_uart++;

		 		if(fifo_timeout_to_uart >= 40)
				{
					time_out_on_fifo();
			 		fifo_timeout_to_uart = 0;
				}
			}
		}

#endif

   }


}

/************************************************************************
/
/            dte_rx_int
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will confirm the reception of a data
/         buffer from the terminal
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  ACU_RX_COUNT, ACU_RX_INSERT, ACU_RX_BUFFER
/
/   Users:   None
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_rx_int(void)
{

#if TIES_HAYES_ESCAPE                           /* ciy021596 */

ubyte masked_rx_char;

#define ESC_NONE     0

#endif

   if ((dte_mode == ACU) && acu_installed && pp_enabled)
	(dte_pp_rx_int());

#if (TIES_HAYES_ESCAPE == 0)                         /* ciy021596 */

   if (dte_mode == DTE)
   {
	 /* Check for escape characters */
	 if ( rx_char == esc_chr )
	 {
	    /* Increment the no. of escape chars rx'ed by one */
	    dte_tesc_count++;

	    /* Switch on the no. of escape chars rx'ed so far */
	    switch ( dte_tesc_count )
	    {
		  case 1 : /* one escape char received */
			if(dte_lead_guard == 0)

			   dte_tesc_count = 0;

			break;

		  case 2 : /* two or three escapes received */
		  case 3 :
			if( dte_guard_time == 0)
			{

			   dte_lead_guard = 0;
			   dte_tesc_count = 0;

			}
			break;

		  case 4 : /* four escape chars received */
		  default:
			dte_lead_guard = 0;
			dte_tesc_count = 0;
			break;

	    }

	    /* reload guard timer from dte_timer() variable */
	    /*mrm8895*/

	    dte_guard_time = esc_guard_time;

	 } /* if esc_chr */
	 /* Else it's a regular char so reset the escape detection */
	 else
	 {
	    dte_lead_guard = 0;
	    dte_tesc_count = 0;
	    dte_guard_time = esc_guard_time;
	 }
   } /* if dte_mode == DTE */
#endif                                             /* ciy021596 */


/*mrm3896*/

	if (parity_enabled == TRUE)
	{
		Tx_char = rx_char;
		parity();
		rx_char = Tx_char;
	}



   /* Modified the code so all modes will do flow control, regardless */
   if (dte_mode != ACU)
   {
	 /* Check for flow control characters */
	 if (dte_to_modem_flow_cntl & XON_AND_XOFF)
	 {
	    if (rx_char == dte_to_modem_xon_char)
	    {
		  dte_tx_resume();
		  if (flow_cntl_pass == FALSE)
  
			goto DO_NOT_BUFFER;
	    }
	    else if (rx_char == dte_to_modem_xoff_char)
	    {
		  dte_tx_suspend(); 
		  if (flow_cntl_pass == FALSE)

			goto DO_NOT_BUFFER;
	    }
	 }
   } /* !ACU */


   /*
	  Save character in buffer if there is room. Some of you
	  may wonder why the "-2", well heres the scoop. If we have
	  a BUFF_SIZE == 10 and rx_count == 9, then rx_insert == 10
	  or 0 when wrapped back to the beginning of the buffer. Now
	  suppose that no data has been removed, thus rx_remove == 0.

	  Heres the killer, the dte_BLOCK interface (compressed connection)
	  wants to know how data we have. We can't tell it the rx_count
	  because its not smart enough to wrap around the buffer, so we tell
	  it a small lie IF the rx_remove > rx_insert. We tell it the
	  amount of data left until the EOB. Then the next time it asks
	  (rx_remove == SOB), we then tell it (rx_insert - rx_remove) is
	  available.

	  Remember that if we let the buffer fill, then rx_insert = rx_remove = 0,
	  thus we can't distinguish between a FULL or EMPTY buffer. So by only
	  allowing BUFF_SIZE - 2, chars then rx_insert == BUFF_SIZE - 1, or in
	  our senario == 9 not 0!!

	  And now you know the real story!!
   */

   if( dte_rx_count < (DTE_BUFFER_SIZE - 2) )
   {
	  dte_rx_buffer[dte_rx_insert++] = rx_char;
	  dte_rx_insert &= BUFFER_POINTER_MASK;
	  dte_rx_count++;
   }



   if (dte_mode != ACU)
   {
	 /* If buffer's near full and flow cntl is active... */
	 if ((dte_rx_count>=DteNearFullValue) && (modem_to_dte_flow_cntl))
	 {
	    if (!rx_suspended)
	    {
		  /*
		  if (dte_tx_interrupt_expected || tx_suspended_for_break)
		  {
			rx_suspend_pending = TRUE;
		  }
		  */
		  rx_suspend_pending = FALSE;
		  dte_rx_suspend();
	    }
	 }
   }
#if TIES_HAYES_ESCAPE                        /* ciy021596 */

   if ( dte_mode == DTE )                   /* for TIES escape */
   {
     if ( rx_char == esc_chr )              /* Check for escape characters */
     {  dte_tesc_count++;                   /* Increment the no. of escape chars rx'ed by one */
        switch ( dte_tesc_count )           /* Switch on the no. of escape chars rx'ed so far */
        {
        case 1 :
        case 2 :                            /* do nothing for 1 or 2 esc char */
                break;
        case 3 :
                dte_lead_guard = FALSE;             /* clear guard time flag */
                dte_guard_time = esc_guard_time;    /* set s[12] timer */
                ties_esc_state = ESC_NONE;          /* init esc state */
                break;
        case 4 :                            /* four escape chars received */
        default:
                exit_ties_esc();        /* to prevent +++,s12,+ case */
                break;
        }
     }                                      /* end if esc_chr */
     else               /* Else it's a regular char so perform at detection */
     {
        if ( dte_tesc_count == 3)
        {
            masked_rx_char = ( rx_char & CHAR_MASK );
            switch ( ties_esc_state )               /* char in after three esc chsrs */
            {
            case ESC_NONE :                         /* set when detect +++ */
                    if ( ( masked_rx_char == 'A') || ( masked_rx_char == 'a') )
                    {
                       ties_esc_state = 'A';
                       dte_guard_time = 0;          /* to clear timer if running */
                    }
                    else
                        exit_ties_esc();
                    break;
            case 'A' :
                    if (( masked_rx_char == 'T') || ( masked_rx_char == 't') )
                    {
                       ties_esc_state = 'T';
                       dte_guard_time = 0;         /* to clear timer if running */
                       cmd_line[0] = '\0';         /* Null out the command line incase first thing entered is A/ */
                       cmd_ptr = (ubyte *)&cmd_line[0];  /* setup buffer to save the rest */
                    }
                    else
                    {                               /* the second char is NOT 'T' */
                       switch ( masked_rx_char )
                       {
                       case 0x0A :
/* ciy 5/2/96 9:06AM, Do NOT check S4, just ignore
 *                                    if ( ( s[4] & CHAR_MASK ) == 0x0A )  / * LF, and equal s[4] * /
 *                                      exit_ties_esc();
 *                                  break;
 * -------------------------------------------------- */
                       case 0x20 :                 /* ignore */
                                   break;
                       case 0x0D :
                                   if ( ( s[3] & CHAR_MASK ) != 0x0D )  /* CR, but not s[3] */
                                      break;        /* ignore */
                                                    /* intentionally fall thru */
                       default   :
                                   exit_ties_esc();
                                   break;
                       }
                    }
                    break;
            case 'T' :
                    if ( masked_rx_char == ( s[3] & CHAR_MASK ) )
                    {
                        dte_tesc_count = 0;
                        dte_guard_time = 2;  /* set timer to go check buffered command in dte_timer() of DTE.C */
                    }
                    else
                    {
                        switch ( masked_rx_char )
                        {
                        case 0x0A :
/* ciy 5/2/96 9:06AM, Do NOT check S4, just ignore
 *                                   if ( ( s[4] & CHAR_MASK ) != 0x0A )  / * LF, but not s[4] * /
 *                                       break;
 *                                   *cmd_ptr++ = masked_rx_char ;
 *                                   *cmd_ptr = '\0';
 *                                   if ( str_len((ubyte *)&cmd_line[0]) > 39 )
 *                                         exit_ties_esc();
 *                                   break;
 * -------------------------------------------------- */
                        case 0x20 :                 /* ignore */
                                    break;
                        case 0x0D :
                                    if ( ( s[3] & CHAR_MASK ) != 0x0D )  /* not CR */
                                       break;       /* ignore */
                                                    /* intentionally fall thru */
                        default   :
                                    if ( masked_rx_char == (s[5] & CHAR_MASK) ) /* cit041996 this if part to allow BACKSPACE */
                                    {
                                        *cmd_ptr--;                             /* ciy041986 it is BACKSPACE, decrease pointer */
                                        masked_rx_char = *cmd_ptr;              /* ciy041996 get CHAR */
                                        if ( masked_rx_char == 'T')
                                            *cmd_ptr++;                         /* ciy041996 if T, no action */
                                        else
                                            *cmd_ptr = '\0';                    /* ciy041996 if NOT T, delete and terminate it */
                                    }
                                    else                                        /* cit041996 end if part to allow BACKSPACE */
                                    {
                                    *cmd_ptr++ = masked_rx_char ;
                                    *cmd_ptr = '\0';
                                    if ( str_len((ubyte *)&cmd_line[0]) > 39 )
                                         exit_ties_esc();
                                    }
                                    break;
                        }
                    }
                    break;
            default:                            /* should NOT be here */
                    exit_ties_esc();
                    break;
            }
        }
        else
            dte_tesc_count = 0;
     }
   }                                                        /* if dte_mode == DTE */
#endif

return;

DO_NOT_BUFFER:
   rx_char = 0;

}

/************************************************************************
/
/   Routine: exit_ties_esc
/
/   Author: Cirrus Logic
/
/   Creation Date:   February 28, 1996
/
/   Description:   This routine will clear bytes, flags and output CONNECT if needed
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed: dte_guard_time, dte_tsec_count, ties_esc_state
/
/   Users: dte_rx_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Author & Date:   Cirrus Logic
/   Description:
/
************************************************************************/
#if TIES_HAYES_ESCAPE
void exit_ties_esc(void)
{
 if ( dte_lead_guard == TRUE )
     dte_guard_time = 1;       /* Set timer to output CONNECT in dte_timer() of DTE.C */
 else
     dte_guard_time = 0;
 dte_tesc_count = 0;
 ties_esc_state = ESC_NONE;
}
#endif




/************************************************************************
/
/   Routine: dte_tx_suspend
/
/   Author: RSA
/
/   Creation Date:   September 16, 1992
/   Creation Date:   05/27/92
/
/   Description:   This routine will suspend transmit operations
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed: dte_tx_interrupt_expected,
/         dte_tx_suspended_by_terminal
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_tx_suspend(void)
{
   dte_tx_suspended_by_terminal = TRUE;
   dte_tx_interrupt_expected = FALSE;
   DISABLE_XMTR();
}

/************************************************************************
/
/   Routine: dte_tx_resume
/
/   Author: RSA
/
/   Creation Date:   September 16, 1992
/
/   Description:   This routine will resume transmit operations
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  dte_tx_suspended_by_terminal, dte_tx_remove,
/          dte_tx_interrupt_expected, dte_tx_buffer, dte_tx_count
/
/   Users:   dte_finish_tx_break, dte_cts_int, dte_ccr_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_tx_resume(void)
{
   if (tx_suspended_for_break)
		return;

   dte_tx_suspended_by_terminal = FALSE;
   dte_tx_interrupt_expected = TRUE;
   ENABLE_XMTR();

/* no way to send breaks to DTE
*   if ( dte_tx_break_state == TX_BREAK_STATE_PSN &&
*       dte_tx_remove == dte_tx_break_psn )
*   {
*      dte_start_tx_break();
*      return;
*   }
*/
} /* procedure */


/******************************************************************************
/
/            acu_from_num
/
/   Author:    RSA (drc)
/
/   Creation Date:   02/06/95
/
/   Description:   returns number of chars in buffer for ACU
/
/   Input Parameters: none
/
/   Output Parameters: uword - number of chars
/
/   Global Variables Changed:
/
/   Users:   set_parms
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
uword acu_from_num(void)
{
   if (dte_mode == ACU)
	 return(dte_rx_count);
   else
	 return(0);
}

/******************************************************************************
/
/            acu_set_parms
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will set SCC's parity, data bits, and stop
/         bits as detected by the 'AT'
/
/   Input Parameters: ubyte - number of data bits
/                     ubyte - type of parity
/                     ubyte - number of stop bits
/
/   Output Parameters: None
/
/   Global Variables Changed:  DTE_SCM
/
/   Users:   set_parms
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_set_parms(ubyte a, ubyte b, ubyte c)
{
}

/******************************************************************************
/
/            acu_set_tx_baud
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will set the transmit baud rate
/
/   Input Parameters: SP + 7 - baud rate
/            1 - 110
/            2 - 300
/            3 - 1200
/            4 - 2400
/            5 - 4800
/            6 - 7200
/            7 - 9600
/            8 - 12000
/            9 - 14400
/           10 - 16800
/           11 - 19200
/           12 - 38400
/           13 - 57600
/           14 - 600
/           15 - 115200
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   check_for_ring, acu_originate, acu_answer, set_parms
/      status_check, hang_up, output_test_message
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_set_tx_baud(ubyte dte_baud)
{
/*ramn 4/9/96*/
#if SERIAL_MODE == 1

	ubyte rate;
	uword serial_baud_rate,*baud_rate;

/*switch (dte_auto_baud_rate)*/

	if(old_serial_dte_baud == dte_baud)
		return; 			/* ramn 4/17/96 */

	switch (dte_baud)
   {
	   case BPS115200:
	 		serial_baud_rate = BR115200;        /* 115.2k   */
	    	break;

	   case BPS57600:
	 		serial_baud_rate = BR57600;         /* 57.6k    */
	    	break;

		case BPS38400:
	 		serial_baud_rate = BR38400;         /* 38.4k    */
	 		break;

	   case BPS19200:
	 		serial_baud_rate = BR19200;         /* 19.2k    */
	    	break;

	 #if 0
	   case BPS16800:
	 		serial_baud_rate = BPS6;            /* 16.8k    */
	    	break;

	   case BPS14400:
	 		serial_baud_rate = BR14400;         /* 14.4k    */
	    	break;

	   case BPS12000
	 		serial_baud_rate = BPS6;            /* 12k    */
	    	break;
	 #endif

	   case BPS9600:
	 		serial_baud_rate = BR9600;          /* 9600     */
	    	break;

	   case BPS7200:
	 		serial_baud_rate = BR7200;          /* 7200     */
	    	break;

	   case BPS4800:
	 		serial_baud_rate = BR4800;          /* 4800     */
	    	break;

	   case BPS2400:
	 		serial_baud_rate = BR2400;          /* 2400     */
	    	break;

	   case BPS1200:
	 		serial_baud_rate = BR1200;          /* 1200     */
	    	break;

	   case BPS600:
	 		serial_baud_rate = BR600;           /* 600      */
	    	break;

	   case BPS300:
	 		serial_baud_rate = BR300;           /* 300      */
	    	break;

#if 0
		case BPS110:
	 		serial_baud_rate = BR110;           /* 110      */
	    	break;

#endif

		default:
	    serial_baud_rate = BR115200;          /* 115.2k   */
	    break;
   }

/* RJM050196 */
   /* Make sure all TX data is gone */
   while(!check_all_sent())
       ;

/* RJM050196 */
   /* Stash new value */
	old_serial_dte_baud = dte_baud;

#if 0
/* RJM050196 */
   /* Still need to give the UART a bit more time */
   for( rate=0; rate<255; rate++ );
#endif

	baud_rate = (uword *)(SERIAL_UART_LOCATION + SBRR);

	*baud_rate = serial_baud_rate ;


#endif

}

/******************************************************************************
/
/            check_all_sent
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will return the value of the all sent flag
/         flag is set to FALSE when ACU_TO_NUM determines that
/         there are no more buffers to send. It is set to TRUE
/         when a transmit interrupt occurs.                /
/
/   Input Parameters: None
/
/   Output Parameters: ubyte - Status of all sent flag
/                      TRUE  - if SCC shift register is empty
/                      FALSE - if SCC shift register is not empty
/
/   Global Variables Changed:  None
/
/   Users:   auto_dialer, check_for_ring, build_cmd_line, at_O
/      disable_acu_on_terminal, output_test_messge
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
ubyte check_all_sent(void)
{
	if(!dte_tx_count && dte_transmit_empty())
		return(TRUE);
	else
		return(FALSE);

}

/******************************************************************************
/
/            acu_reset_port
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will set SCC up to receive in data mode
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   disable_acu_on_terminal
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_reset_port(void)
{
}

/******************************************************************************
/
/            get_autobaud_rate
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will take the SCON value programmed
/                       by autobaud and compare it with the calculated values
/                       in the autobaud table to determine the dte baud rate.
/
/   Input Parameters: None
/
/   Output Parameters: D0 - baud rate (bps)
/                 1 - 110
/                 2 - 300
/                 3 - 1200
/                 4 - 2400
/                 5 - 4800
/                 6 - 7200
/                 7 - 9600
/                 8 - 12000
/                 9 - 14400
/                10 - 16800
/                11 - 19200
/                12 - 38400
/                13 - 57600
/                14 - 600
/                15 - 115200
/
/   Global Variables Changed:  None
/
/   Users:   get_rx_baud_rate
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte get_autobaud_rate(void)
{

#if PARALLEL_MODE == 1

	ubyte rate,*lobyte,*hibyte;
	uword parallel_baud_rate;

	lobyte = (ubyte *)(PARALLEL_16550_LOCATION + HDLLS);
	hibyte = (ubyte *)(PARALLEL_16550_LOCATION + HDLMS);

	parallel_baud_rate  = *hibyte;
	parallel_baud_rate  = parallel_baud_rate << 8;
	parallel_baud_rate |= *lobyte;




/*switch (dte_auto_baud_rate)*/


	switch (parallel_baud_rate)
   {
	 case BR115200:               /* 115.2k   */
	    rate = 0x0f;
	    break;

	 case BR57600:                /* 57.6k    */
	    rate = 0x0d;
	    break;

	 case BR38400:          /* 38.4k    */
	    rate = 0x0c;
	 break;

	 case BR19200:          /* 19.2k    */
	    rate = 0x0b;
	    break;

	 #if 0
	 case 0x06:             /* 16.8k    */
	    rate = 0x0a;
	    break;

	 case BR14400:           /* 14.4k    */
	    rate = 0x09;
	    break;

	 case 0x06:                   /* 12k    */
	    rate = 0x08;
	    break;
	 #endif

	 case BR9600:            /* 9600     */
	    rate = 0x07;
	    break;

	 case BR7200:            /* 7200     */
	    rate = 0x06;
	    break;

	 case BR4800:            /* 4800     */
	    rate = 0x05;
	    break;

	 case BR2400:            /* 2400     */
	    rate = 0x04;
	    break;

	 case BR1200:            /* 1200     */
	    rate = 0x03;
	    break;

	 case BR600:             /* 600      */
	    rate = 0x0e;
	    break;

	 case BR300:                  /* 300      */
	    rate = 0x02;
	    break;

	 case BR110:                  /* 110      */
	    rate = 0x01;
	    break;

	 default:
	    rate = 0x0f;              /* 115.2k   */
	    break;
   }

   return(rate);
#endif

#if SERIAL_MODE == 1

	ubyte rate;
	uword serial_baud_rate,*baud_rate;

	baud_rate = (uword *)(SERIAL_UART_LOCATION + SBRR);

	serial_baud_rate  = *baud_rate;




/*switch (dte_auto_baud_rate)*/


	switch (serial_baud_rate)
   {
	 case BR115200:               /* 115.2k   */
	    rate = 0x0f;
	    break;

	 case BR57600:                /* 57.6k    */
	    rate = 0x0d;
	    break;

	 case BR38400:          /* 38.4k    */
	    rate = 0x0c;
	 break;

	 case BR19200:          /* 19.2k    */
	    rate = 0x0b;
	    break;

	 #if 0
	 case 0x06:             /* 16.8k    */
	    rate = 0x0a;
	    break;

	 case BR14400:           /* 14.4k    */
	    rate = 0x09;
	    break;

	 case 0x06:                   /* 12k    */
	    rate = 0x08;
	    break;
	 #endif

	 case BR9600:            /* 9600     */
	    rate = 0x07;
	    break;

	 case BR7200:            /* 7200     */
	    rate = 0x06;
	    break;

	 case BR4800:            /* 4800     */
	    rate = 0x05;
	    break;

	 case BR2400:            /* 2400     */
	    rate = 0x04;
	    break;

	 case BR1200:            /* 1200     */
	    rate = 0x03;
	    break;

	 case BR600:             /* 600      */
	    rate = 0x0e;
	    break;

	 case BR300:                  /* 300      */
	    rate = 0x02;
	    break;

#if 0
	 case BR110:                  /* 110      */
	    rate = 0x01;
	    break;

#endif

	 default:
	    rate = 0x0f;              /* 115.2k   */
	    break;
   }

  	old_serial_dte_baud = rate; /* ramn 4/17/96 */
   return(rate);
#endif




}

/******************************************************************************
/
/            acu_halt
/
/   Author:    RSA
/
/   Creation Date:   12/19/94
/
/   Description:   This routine will stop all acu interrupts.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   at_plus()
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_halt(void)
{
/* shut down tx and rx interrupts */
   acu_halted = TRUE;

}

/************************************************************************
/
/            acu_restart
/
/   Author:    RSA
/
/   Creation Date:   12/19/94
/
/   Description:   This routine will restart the acu interrupt
/         processing.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   at_plus()
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_restart(void)
{
/* enable tx and rx interrupts */
   acu_halted = FALSE;
   acu_port_init();
   pp_control(OFF);
}

/************************************************************************
/
/            acu_io_enable
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/09/94
/
/   Description:   This routine will set the I/O mode to route the
/         data through the ACU code
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  Reinitialize buffer descriptor tables
/               ACU_STATUS, DTE_STATUS
/
/   Users:   enable_acu_on_terminal
/
/   -----------------------------------------------------------------
/   -         Modifications                                         -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_io_enable(void)
{
   dte_mode = ACU;
   acu_installed = TRUE;
}

/************************************************************************
/
/            acu_io_disable
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will switch the I/O ports to route the
/         data through the DTE code
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  Reinitialize buffer descriptor tables
/               Reset acu SCC interrupt vector
/               ACU_STATUS, DTE_STATUS
/
/   Users:   disable_acu_on_terminal
/
/       ------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
void acu_io_disable(void)
{
   dte_mode = DTE;
   acu_installed = FALSE;
}

/************************************************************************
/
/            dte_disable
/
/   Author:    RSA
/
/   Creation Date:   10/28/94
/
/   Description: Stub file for start/end_clamp mechanism.  Used by some hardware
/              platforms for SCC switching (not used by the H8 I/O code).
/
/   Input Parameters:  NONE
/
/   Output Parameters: NONE
/
/   Global Variables Changed: NONE
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_disable(void)
{}

/************************************************************************
/
/            dte_enable
/
/   Author:    RSA
/
/   Creation Date:   10/28/94
/
/   Description: Stub file for start/end_clamp mechanism.  Used by some hardware
/              platforms for SCC switching (not used by the H8 I/O code).
/
/   Input Parameters:  NONE
/
/   Output Parameters: NONE
/
/   Global Variables Changed: NONE
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_enable(void)
{}


/************************************************************************
/
/            Process one msec timer
/
/   Input Parameters:  NONE
/
/   Output Parameters: NONE
/
/   Global Variables Changed: NONE
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/

void process_one_msec(void)
{
   if(modem_1ms_timer)
	 modem_1ms_timer--;

/*22296shujin, ring detec*/
		msec_counter++;

   /*
   if(one_ms_timer)
	 one_ms_timer--;
   */
   if(dial_timer)
	 dial_timer--;

   /*
   if(mt_cp_timer)
	 mt_cp_timer--;
   */
}


/************************************************************************
/
/            acu_to_free
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine returns the available space in the acu
/                  transmit buffer
/
/   Input Parameters: None
/
/   Output Parameters: uword space-in-buffer
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
/*RJM51796*/
uword acu_to_free(void)
{
   return (OTHER_BUFFER_SIZE - dte_tx_count -1);
}

