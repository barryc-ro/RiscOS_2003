/************************************************************************
/
/   Copyright 1994, 1995. All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File:      ACU.C
/
/   Version:   1.00
/
/   Function:  This file contains the ACU IO code
/
/   Product:   H8/3002 IO code
/
/   Platform:  H8/3002 + TI 16PC564  UART (TIPU)
/
/   History:   acu.c v1.00
/
/   Created:   10/27/94
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
#include "mod_def.h" /* added by ramn on 2/5/96 */
#include "sys_def.h"
#include "acuiomem.h"
#include "acu_def.h"
#include "dte_drv.h"
#include "acu_mem.h"
#include "dteequ.h"
#include "homolig1.h"


void    reload_timer2(void);

/* External prototypes */
extern void dp_int(void);
extern void dp_vce_timer(void);

/* RJM040396 */
/* VCV support */
extern void vcv_timer(void);

#if TIES_HAYES_ESCAPE                           /* ciy021596 */

extern void enable_acu_on_terminal(void);
extern void output_result(ubyte type);
extern void disable_acu_on_terminal(void);
extern void build_event(ubyte, ubyte);
extern void system_rcv_escape(void);
extern uword str_len(ubyte *str);

void exit_ties_esc(void);

ubyte ties_esc_state;

#define ESC_NONE     0
ubyte masked_rx_char;   /* ciy021596 */

#endif


/* Internal prototypes */
void dte_tx_suspend(void);
void dte_tx_resume(void);
void dte_interrupt_tx(void);
void dte_interrupt_rx(void);

/*mrm9195*/
/*place the routines inside the serial.s file*/

extern void enable_int(void);
extern void disable_int(void);

void process_one_msec(void);
ubyte get_autobaud_rate(void);
uword acu_from_num(void);

extern ubyte dte_transmit_empty(void);
extern ubyte dte_data_ready(void);
extern ubyte dte_read_char_from_uart(void);
extern void dte_write_char_to_uart(ubyte);


extern void dte_port_init(void);
extern ubyte dte_rx_resume(void);
extern ubyte dte_rx_suspend(void);
extern void dte_pp_tx_int(void);
extern void dte_pp_rx_int(void);

/* External variables */
extern uword mt_cp_timer;
extern uword mt_cp_timer;
extern ubyte atb_rx_char;
extern ubyte atb_rx_bypass;
extern ubyte dte_auto_baud_rate;
extern void dte_cts_off(void);
extern void dte_cts_on(void);
extern ubyte modem_control_reg_rts(void);


extern void dte_timer(void);
extern void line_timer(void);
extern void modem_timer(void);
extern void fax_timer(void);
extern void dp_vce_timer(void);
extern void PutByte(ubyte);
extern ubyte fifo_not_full(void);
extern void time_out_on_fifo(void);


extern ubyte uart_fifo_enable;
extern ubyte fax_class;

extern void   reload_fifo_timer(void);
extern void   reload_no_fifo_timer(void);


/* Local data */


ubyte autobaud_control;        /* Tracks whether autobaud is active or not */
ubyte   fifo_timeout_to_uart = 0;

extern uword  msec_counter;
extern void   process_cadence(void);

extern ubyte Tx_char;
extern void parity(void);
extern ubyte parity_enabled;
ubyte old_serial_dte_baud; /* ramn 4/17/96 */
/*SLei added*/
extern void ToneModeStateSwitch(void);
extern void UpdateBlackListDelayTimer(void);
/* RJM050196 */
ubyte check_all_sent(void);
/*mrm72796*/
extern ubyte ToneModeSwitch;


/*
extern ubyte rx_char;
*/

extern ubyte dte_flag_count;
/* MH120397 */
/* insert new function: ath1_problem ... */
extern void Update_ath1_timer(void);
/* end change ... */

/************************************************************************
/
/            acu_port_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/09/94
/
/   Description:   This routine will initialize the dte io code for
/                  the ACU
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  All TIPU registers
/
/   Users:   master_init
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void acu_port_init(void)
{
   dte_port_init();        /* call common routine */
   dte_mode = ACU;
   acu_installed = TRUE;   /* set flag indicating acu interrupts installed */
   acu_status = 0x10;      /* transmmit disabled */

/*mrm8895*/
#if 0
   pp_init(NULL, NULL);    /* void pp_init(ubyte mode, uword time) */
#endif

   atb_rx_bypass=0;
   autobaud_control = 0;
}

/************************************************************************
/
/            hardware_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   10/27/94
/
/   Description:   This routine will initialize the paltform dependent
/                  hardware
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed
/
/   Users:   master_init
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/

/*   shujin 9/9/97
void hardware_init()
{
   install_poll_dte_interrupt();
}
*/


/************************************************************************
/
/            acu_timer
/
/   Author:    RSA
/
/   Creation Date:   10/27/94
/
/   Description:   This routine will increment the acu interrupt timer
/         ticks.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  acu_10msec_timer, acu_100msec_timer
/               acu_1sec_timer, timer100mS, timer1sec
/
/   Users:   timer_10msec_int
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
extern void dte_check_parity_bit(void);


void acu_timer(void)
{

   if (ToneModeSwitch )
   {   

      ToneModeStateSwitch(); /*SLei added*/
   }

   dte_timer();
   line_timer();
   modem_timer();

   if (!(dte_mode == DTE) && !(dte_mode == DTE_V80_SAM) )
   {
      process_cadence();
      fax_timer();
      /*dp_vce_timer();*/ /* ramn 8/19/96 */

/* RJM040396 */
/* VCV Support */
      vcv_timer();
   
   }

   acu_10msec_timer++;

   if (! --timer100mS )
   {

    timer100mS = 10;

/*mrm8895*/
#if 0
    pp_timer();
#endif

    acu_100msec_timer++;

/* shujin 9/9/97 */
#if PARALLEL_MODE == 1
      dte_check_parity_bit();
#endif


    if (! --timer1sec )
    {
       UpdateBlackListDelayTimer(); /*SLei added*/
#if INTERNATIONAL_CODE == 1
        /* MH120397, ath1_problem ... */
        Update_ath1_timer();
        /* end of change ... */
#endif

       timer1sec = 10;

/* shujin 9/9/97 */
#if PARALLEL_MODE == 1
    reload_timer2();
#endif


       acu_1sec_timer++;

       if (! --timer1min )
       {
        timer1min = 60;
        acu_1min_timer++;
       }

    }
   }
/*mrm9695*/
    /* Check for RTS/CTS TX suspension */
    if( dte_tx_suspended_by_terminal && (dte_to_modem_flow_cntl & RTS_AND_CTS) )
     {
       /* Host says its OK to continue, well, who are we to argue */
      /*
       if( UART_MCR & RTS )
      */

      if( modem_control_reg_rts() )
         dte_tx_resume();
     }


/*mrm8895*/
#if 0
   wireless_timer();
#endif
}

/************************************************************************
/
/            dte_interrupt
/
/   Author:    RSA (drc)
/
/   Creation Date:   11/18/94
/
/   Description:   This routine will process all TIPU interrupts for
/         the DTE I/O code
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   Timer interrupt for TIPU
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/

#define  UARTBASE    0x000B0000L
extern ubyte   DebugPortOutput;


ubyte    timer2_flag = 0;
extern   ubyte bit_mask;



#if PCMCIA_SPECIAL == 1
   #define  MAX_FILL    16
   ubyte tx_disable;
#else
   #define  MAX_FILL    28
#endif
  


/* P Uart Int assert condition: tx_fifo_empty !=0 and Host write 1st char ! */


void dte_interrupt_rx(void)
{
   ubyte dte_last_ch;
   ubyte rx_char;


#if PCMCIA_SPECIAL == 1
   if ( 
            (dte_rx_count >= dte_xoff_threshold) 
         && (!rx_suspended)                      
         && (modem_to_dte_flow_cntl)             
         && (dte_mode != ACU)                        
      )  
         dte_rx_suspend();
#endif


/* 10/31/97 shujin
   to disable Host Int - THREIE 
   to prevent Hardware IREQ toggle too quick, unable followed by 6832
*/

#if PCMCIA_SPECIAL == 1
   if(  (*(ubyte *)(PARALLEL_16550_LOCATION + HIER) & 0x02) == 0x02) 
   {  
      tx_disable = TRUE;
      *(ubyte *)(PARALLEL_16550_LOCATION + HIER) &= 0x0d; 
   }
#endif


/* if fifo not empty, read it */

#if PARALLEL_MODE == 1

  while( ( *(ubyte *)(PARALLEL_16550_LOCATION + HLSR) & 
            TRANSMIT_EMPTY_MASK ) == 0 )
  {
     rx_char = *(ubyte *)(PARALLEL_16550_LOCATION + HTHR);

#endif


#if SERIAL_MODE == 1

  if ( (dte_mode == ACU) && (acu_halted) ) return;


/* if UART has a char, read it */
  if( ( *(ubyte *)(SERIAL_UART_LOCATION + SLSR) & DATA_READY_MASK )  )
  {
      rx_char = *(ubyte *)(SERIAL_UART_LOCATION + STHR); 

#endif




/*    dte_rx_int(); ************************************ */



#if (TIES_HAYES_ESCAPE == 0)                         /* ciy021596 */

   if (dte_mode == DTE)
   {
    /* Check for escape characters */
    if ( rx_char == esc_chr )
    {
       /* Increment the no. of escape chars rxed by one */
       dte_tesc_count++;

       /* Switch on the no. of escape chars rx'ed so far */
       switch ( dte_tesc_count )
       {
        case 1 : /* one escape char received */
         if(dte_lead_guard == 0)

            dte_tesc_count = 0;

         break;

        case 2 : /* two or three escapes received */
        case 3 :
         if( dte_guard_time == 0)
         {

            dte_lead_guard = 0;
            dte_tesc_count = 0;

         }
         break;

        case 4 : /* four escape chars received */
        default:
         dte_lead_guard = 0;
         dte_tesc_count = 0;
         break;

       }

       /* reload guard timer from dte_timer() variable */
       /*mrm8895*/

       dte_guard_time = esc_guard_time;

    } /* if esc_chr */
    /* Else it's a regular char so reset the escape detection */
    else
    {
       dte_lead_guard = 0;
       dte_tesc_count = 0;
       dte_guard_time = esc_guard_time;
    }
   } /* if dte_mode == DTE */
#endif                                             /* ciy021596 */

/* #if (TIES_HAYES_ESCAPE == 0) */



/* mrm3896 */

   if (parity_enabled == TRUE)
   {
      Tx_char = rx_char;
      parity();
      rx_char = Tx_char;
   }



/* Check for flow control characters */
/* Modified the code so all modes will do flow control, regardless */

   if (dte_to_modem_flow_cntl & XON_AND_XOFF && dte_mode != ACU )
   {
          if (rx_char == dte_to_modem_xon_char)
          {
              dte_tx_resume();

              if (flow_cntl_pass == FALSE)
                  goto DO_NOT_BUFFER;
           }
           else if (rx_char == dte_to_modem_xoff_char)
           {
               dte_tx_suspend(); 

               if (flow_cntl_pass == FALSE)
                  goto DO_NOT_BUFFER;
           }
   } /* !ACU */


   /*
     Save character in buffer if there is room. Some of you
     may wonder why the "-2", well heres the scoop. If we have
     a BUFF_SIZE == 10 and rx_count == 9, then rx_insert == 10
     or 0 when wrapped back to the beginning of the buffer. Now
     suppose that no data has been removed, thus rx_remove == 0.

     Heres the killer, the dte_BLOCK interface (compressed connection)
     wants to know how data we have. We can't tell it the rx_count
     because its not smart enough to wrap around the buffer, so we tell
     it a small lie IF the rx_remove > rx_insert. We tell it the
     amount of data left until the EOB. Then the next time it asks
     (rx_remove == SOB), we then tell it (rx_insert - rx_remove) is
     available.

     Remember that if we let the buffer fill, then rx_insert = rx_remove = 0,
     thus we can't distinguish between a FULL or EMPTY buffer. So by only
     allowing BUFF_SIZE - 2, chars then rx_insert == BUFF_SIZE - 1, or in
     our senario == 9 not 0!!

     And now you know the real story!!
   */

   if( dte_rx_count < (DTE_BUFFER_SIZE - 2) )
   {

      if (( dte_last_ch == 0x19 ) && ( rx_char == 0xb1 ))
         dte_flag_count++;

      dte_last_ch = rx_char;


      dte_rx_buffer[dte_rx_insert++] = rx_char;
      dte_rx_insert &= BUFFER_POINTER_MASK;
      dte_rx_count++;
   }

/* RJM100896 */
/* V.80 support */

   else if (dte_mode == DTE_V80_SAM)
   {
      PrintMsg( "---DTE TX_OVERRUN_ISR---" );

      /* TX_OVERRUN's are handled V80 SAM */
      /* signal transmit overrun and initialize the count */

      if ((dte_to_free() >= 2) && (last_pc_tx_byte != EM_CODE) &&
          (dte_tx_overrun == FALSE) && (dte_tx_unum_pending == FALSE))
      {

         /* put <EM><TOVER> into DTE tx buffer */
         dte_to_char(EM_CODE);
         dte_to_char(TOVER_CODE);

         discard_byte_count = 0;
         dte_tx_overrun = TRUE;
      }
      else if((dte_tx_overrun == FALSE) && (dte_tx_unum_pending == FALSE))
      {
         discard_byte_count = 0;
         dte_tx_overrun = TRUE;
         dte_tover_pending = TRUE;
      }

      #if (FCLASS_80 == 1)
      /* process the received character */
      dte_v80_rx(rx_char);
      #endif
   }


/* If buffer's near full and flow cntl is active... */

#if PCMCIA_SPECIAL == 0
       if (    
               ( dte_rx_count >= dte_xoff_threshold )
            && ( !rx_suspended )
            && ( modem_to_dte_flow_cntl )
            && ( dte_mode != ACU )
          )
            dte_rx_suspend();
#endif

/* 11/18/97
   Don't move CTS-drop out of while loop for regular parallel mode.
   For PENTIUM 133 and above, we could receive hundreds of chars in
   one rx Int. If CTS-drop is out of while loop, flow control could 
   fail.

   But for pcmcia special, we disable THREIE, have no this problem.
   We can put CTS-drop in frone of the while loop, and improve the
   full duplex throughput for pcmcia code.
*/



/* *********************************************************************** */

#if TIES_HAYES_ESCAPE                        /* ciy021596 */

   if ( dte_mode == DTE )                   /* for TIES escape */
   {
     if ( rx_char == esc_chr )              /* Check for escape characters */
     {  
         dte_tesc_count++;                   /* Increment the no. of escape chars rx'ed by one */
         switch ( dte_tesc_count )           /* Switch on the no. of escape chars rx'ed so far */
         {
            case 1 :
            case 2 :                            /* do nothing for 1 or 2 esc char */
                break;
            case 3 :
                dte_lead_guard = FALSE;             /* clear guard time flag */
                dte_guard_time = esc_guard_time;    /* set s[12] timer */
                ties_esc_state = ESC_NONE;          /* init esc state */
                break;
           case 4 :                            /* four escape chars received */
           default:
                exit_ties_esc();        /* to prevent +++,s12,+ case */
                break;
          }
     }                                      /* end if esc_chr */
     else               /* Else it's a regular char so perform at detection */
     {
        if ( dte_tesc_count == 3)
        {
            masked_rx_char = ( rx_char & CHAR_MASK );
            switch ( ties_esc_state )               /* char in after three esc chsrs */
            {
            case ESC_NONE :                         /* set when detect +++ */
                    if ( ( masked_rx_char == 'A') || ( masked_rx_char == 'a') )
                    {
                       ties_esc_state = 'A';
                       dte_guard_time = 0;          /* to clear timer if running */
                    }
                    else
                        exit_ties_esc();
                    break;
            case 'A' :
                    if (( masked_rx_char == 'T') || ( masked_rx_char == 't') )
                    {
                       ties_esc_state = 'T';
                       dte_guard_time = 0;         /* to clear timer if running */
                       cmd_line[0] = '\0';         /* Null out the command line incase first thing entered is A/ */
                       cmd_ptr = (ubyte *)&cmd_line[0];  /* setup buffer to save the rest */
                    }
                    else
                    {                               /* the second char is NOT 'T' */
                       switch ( masked_rx_char )
                       {
                       case 0x0A :

/* ciy 5/2/96 9:06AM, Do NOT check S4, just ignore
 *                                    if ( ( s[4] & CHAR_MASK ) == 0x0A )  / * LF, and equal s[4] * /
 *                                      exit_ties_esc();
 *                                  break;
 * -------------------------------------------------- */
                       case 0x20 :                 /* ignore */
                                   break;
                       case 0x0D :
                                   if ( ( s[3] & CHAR_MASK ) != 0x0D )  /* CR, but not s[3] */
                                      break;        /* ignore */
                                                    /* intentionally fall thru */
                       default   :
                                   exit_ties_esc();
                                   break;
                       }
                    }
                    break;
               case 'T' :
                    if ( masked_rx_char == ( s[3] & CHAR_MASK ) )
                    {
                        dte_tesc_count = 0;
                        dte_guard_time = 2;  /* set timer to go check buffered command in dte_timer() of DTE.C */
                    }
                    else
                    {
                        switch ( masked_rx_char )
                        {
                        case 0x0A :

/* ciy 5/2/96 9:06AM, Do NOT check S4, just ignore
 *                                   if ( ( s[4] & CHAR_MASK ) != 0x0A )  / * LF, but not s[4] * /
 *                                       break;
 *                                   *cmd_ptr++ = masked_rx_char ;
 *                                   *cmd_ptr = '\0';
 *                                   if ( str_len((ubyte *)&cmd_line[0]) > 39 )
 *                                         exit_ties_esc();
 *                                   break;
 * -------------------------------------------------- */
                        case 0x20 :                 /* ignore */
                                    break;
                        case 0x0D :
                                    if ( ( s[3] & CHAR_MASK ) != 0x0D )  /* not CR */
                                       break;       /* ignore */
                                                    /* intentionally fall thru */
                        default   :
                                    if ( masked_rx_char == (s[5] & CHAR_MASK) ) /* cit041996 this if part to allow BACKSPACE */
                                    {
                                        *cmd_ptr--;                             /* ciy041986 it is BACKSPACE, decrease pointer */
                                        masked_rx_char = *cmd_ptr;              /* ciy041996 get CHAR */
                                        if ( masked_rx_char == 'T')
                                            *cmd_ptr++;                         /* ciy041996 if T, no action */
                                        else
                                            *cmd_ptr = '\0';                    /* ciy041996 if NOT T, delete and terminate it */
                                    }
                                    else                                        /* cit041996 end if part to allow BACKSPACE */
                                    {
                                    *cmd_ptr++ = masked_rx_char ;
                                    *cmd_ptr = '\0';
                                    if ( str_len((ubyte *)&cmd_line[0]) > 39 )
                                         exit_ties_esc();
                                    }
                                    break;
                        }
                    }
                    break;

            default:                            /* should NOT be here */
                    exit_ties_esc();
                    break;
            }
        }
        else
            dte_tesc_count = 0;
     }
   }                                                        /* if dte_mode == DTE */
#endif
/* #if TIES_HAYES_ESCAPE ************************************************* */

DO_NOT_BUFFER: ;
  
/* end dte_rx_int() ************************************ */

  }  /* while */        


}


void dte_interrupt_tx(void)
{
   ubyte fifo_fill_up;


/*  11/04/97
   if ( (dte_mode == ACU) && acu_halted )  return;
*/


/* Check for RTS TX suspension */
   if( (dte_to_modem_flow_cntl & RTS_AND_CTS) )
   {
#if PARALLEL_MODE == 1
      if( (*(ubyte *)(PARALLEL_16550_LOCATION + HMCR)) & RTS_BAR_MASK)
#endif                  


#if SERIAL_MODE == 1
      if( (*(ubyte *)(SERIAL_UART_LOCATION    + SECR)) & RTS_BAR_MASK)
#endif                  

      {
         if( dte_tx_suspended_by_terminal == TRUE )
               dte_tx_resume();
      }
      
/* RTS dropped */
      else 
      {
         if( dte_tx_suspended_by_terminal == FALSE )
              dte_tx_suspend();
      }
   }


#if PARALLEL_MODE == 1

   if ( *(ubyte *)(PARALLEL_16550_LOCATION + HFCR) & 0x01)
                 fifo_fill_up = MAX_FILL;
   else          fifo_fill_up = 1;

#endif


#if SERIAL_MODE == 1
   fifo_fill_up = 1;
#endif



/* If we're waiting to send an flow OFF, send it now */
   if ( rx_suspend_pending )  
   {
        dte_rx_suspend();
        fifo_fill_up--;
   }

/* If we're waiting to send an flow ON, send it now */
   if ( rx_resume_pending )
   {
        dte_rx_resume();
        fifo_fill_up--;
   }



   if ( dte_tx_suspended_by_terminal )   
      goto  END_OF_TX;
   

/* to disable the Host Int - RDAIE */
#if PCMCIA_SPECIAL == 1
   *(ubyte *)(PARALLEL_16550_LOCATION + HIER) &= 0x0e; 
#endif


   while (  fifo_fill_up &&  dte_tx_count )
   {

#if PARALLEL_MODE == 1
      if ( (*(ubyte *)(PARALLEL_16550_LOCATION+CR550) & 
            RECEIVE_FIFO_NOT_FULL) != 0 )                   break;  
#endif

      fifo_fill_up --;


/* start dte_tx_int(); *********************************** */
/*  get the char from the buffer and write it into UART */

      if ( dte_mode != DTE_V80_SAM )
      {

#if PARALLEL_MODE == 1
          *(ubyte *)(PARALLEL_16550_LOCATION + HRHR) =
                  dte_tx_buffer[ dte_tx_remove++ ] & bit_mask; 
#endif


#if SERIAL_MODE == 1
          *(ubyte *)(SERIAL_UART_LOCATION + SRHR) =
                  dte_tx_buffer[ dte_tx_remove++ ]; 
#endif

            dte_tx_remove &= BUFFER_POINTER_MASK_TX;
            dte_tx_count--;
      }

/* RJM100896 */
/* V.80 support */
      else 
      {
      #if (FCLASS_80 == 1)
            dte_v80_tx();
      #endif      
      }

/* end dte_tx_int(); *********************************** */

   }  /* end while() loop */

/* testing
      *(ubyte *)UARTBASE = (MAX_FILL - fifo_fill_up + 0x57);
*/


/* to enable the Int of RDAIE */
#if PCMCIA_SPECIAL == 1
   *(ubyte *)(PARALLEL_16550_LOCATION + HIER) |= 0x01; 
#endif


END_OF_TX: ;


/* fifo enabled, if no writing and fifo has data, possible below threshold,
   prepare to force Int */

#if PARALLEL_MODE == 1

      if( fifo_fill_up == MAX_FILL &&
          (*(ubyte *)(PARALLEL_16550_LOCATION + HLSR) & DATA_READY_MASK ) )
      {
          fifo_timeout_to_uart ++;

          if( fifo_timeout_to_uart >= 10 )
          {
                *(ubyte *)(PARALLEL_16550_LOCATION + CR550) |= FIFO_TIME_OUT; 

               fifo_timeout_to_uart = 0;
          }
      }

#endif


/* to enable the Host Int - THREIE */
#if PCMCIA_SPECIAL == 1
   if(tx_disable == TRUE )
   {
      tx_disable = FALSE;
      *(ubyte *)(PARALLEL_16550_LOCATION + HIER) |= 0x02; 
   }
#endif


}



/************************************************************************
/
/   Routine: exit_ties_esc
/
/   Author: Cirrus Logic
/
/   Creation Date:   February 28, 1996
/
/   Description:   This routine will clear bytes, flags and output CONNECT if needed
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed: dte_guard_time, dte_tsec_count, ties_esc_state
/
/   Users: dte_rx_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Author & Date:   Cirrus Logic
/   Description:
/
************************************************************************/

#if TIES_HAYES_ESCAPE
void exit_ties_esc(void)
{
 if ( dte_lead_guard == TRUE )
     dte_guard_time = 1;       /* Set timer to output CONNECT in dte_timer() of DTE.C */
 else
     dte_guard_time = 0;
 dte_tesc_count = 0;
 ties_esc_state = ESC_NONE;
}
#endif




/************************************************************************
/
/   Routine: dte_tx_suspend
/
/   Author: RSA
/
/   Creation Date:   September 16, 1992
/   Creation Date:   05/27/92
/
/   Description:   This routine will suspend transmit operations
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed: dte_tx_interrupt_expected,
/         dte_tx_suspended_by_terminal
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_tx_suspend(void)
{
   dte_tx_suspended_by_terminal = TRUE;
   dte_tx_interrupt_expected = FALSE;
   DISABLE_XMTR();
}

/************************************************************************
/
/   Routine: dte_tx_resume
/
/   Author: RSA
/
/   Creation Date:   September 16, 1992
/
/   Description:   This routine will resume transmit operations
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  dte_tx_suspended_by_terminal, dte_tx_remove,
/          dte_tx_interrupt_expected, dte_tx_buffer, dte_tx_count
/
/   Users:   dte_finish_tx_break, dte_cts_int, dte_ccr_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_tx_resume(void)
{
   if (tx_suspended_for_break)
      return;

   dte_tx_suspended_by_terminal = FALSE;
   dte_tx_interrupt_expected = TRUE;
   ENABLE_XMTR();

/* no way to send breaks to DTE
*   if ( dte_tx_break_state == TX_BREAK_STATE_PSN &&
*       dte_tx_remove == dte_tx_break_psn )
*   {
*      dte_start_tx_break();
*      return;
*   }
*/
} /* procedure */


/******************************************************************************
/
/            acu_from_num
/
/   Author:    RSA (drc)
/
/   Creation Date:   02/06/95
/
/   Description:   returns number of chars in buffer for ACU
/
/   Input Parameters: none
/
/   Output Parameters: uword - number of chars
/
/   Global Variables Changed:
/
/   Users:   set_parms
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
uword acu_from_num(void)
{
   if (dte_mode == ACU)
    return(dte_rx_count);
   else
    return(0);
}

/******************************************************************************
/
/            acu_set_parms
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will set SCC's parity, data bits, and stop
/         bits as detected by the 'AT'
/
/   Input Parameters: ubyte - number of data bits
/                     ubyte - type of parity
/                     ubyte - number of stop bits
/
/   Output Parameters: None
/
/   Global Variables Changed:  DTE_SCM
/
/   Users:   set_parms
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_set_parms(ubyte a, ubyte b, ubyte c)
{
}

/******************************************************************************
/
/            acu_set_tx_baud
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will set the transmit baud rate
/
/   Input Parameters: SP + 7 - baud rate
/            1 - 110
/            2 - 300
/            3 - 1200
/            4 - 2400
/            5 - 4800
/            6 - 7200
/            7 - 9600
/            8 - 12000
/            9 - 14400
/           10 - 16800
/           11 - 19200
/           12 - 38400
/           13 - 57600
/           14 - 600
/           15 - 115200
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   check_for_ring, acu_originate, acu_answer, set_parms
/      status_check, hang_up, output_test_message
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_set_tx_baud(ubyte dte_baud)
{
/*ramn 4/9/96*/
#if SERIAL_MODE == 1

   ubyte rate;
   uword serial_baud_rate,*baud_rate;

/*switch (dte_auto_baud_rate)*/

   if(old_serial_dte_baud == dte_baud)
      return;          /* ramn 4/17/96 */

   switch (dte_baud)
   {
      case BPS115200:
          serial_baud_rate = BR115200;        /* 115.2k   */
          break;

      case BPS57600:
          serial_baud_rate = BR57600;         /* 57.6k    */
          break;

      case BPS38400:
          serial_baud_rate = BR38400;         /* 38.4k    */
          break;

      case BPS19200:
          serial_baud_rate = BR19200;         /* 19.2k    */
          break;

    #if 0
      case BPS16800:
          serial_baud_rate = BPS6;            /* 16.8k    */
          break;

      case BPS14400:
          serial_baud_rate = BR14400;         /* 14.4k    */
          break;

      case BPS12000
          serial_baud_rate = BPS6;            /* 12k    */
          break;
    #endif

      case BPS9600:
          serial_baud_rate = BR9600;          /* 9600     */
          break;

      case BPS7200:
          serial_baud_rate = BR7200;          /* 7200     */
          break;

      case BPS4800:
          serial_baud_rate = BR4800;          /* 4800     */
          break;

      case BPS2400:
          serial_baud_rate = BR2400;          /* 2400     */
          break;

      case BPS1200:
          serial_baud_rate = BR1200;          /* 1200     */
          break;

      case BPS600:
          serial_baud_rate = BR600;           /* 600      */
          break;

      case BPS300:
          serial_baud_rate = BR300;           /* 300      */
          break;

#if 0
      case BPS110:
          serial_baud_rate = BR110;           /* 110      */
          break;

#endif

      default:
       serial_baud_rate = BR115200;          /* 115.2k   */
       break;
   }

/* RJM050196 */
   /* Make sure all TX data is gone */
   while(!check_all_sent())
       ;

/* RJM050196 */
   /* Stash new value */
   old_serial_dte_baud = dte_baud;

#if 0
/* RJM050196 */
   /* Still need to give the UART a bit more time */
   for( rate=0; rate<255; rate++ );
#endif

   baud_rate = (uword *)(SERIAL_UART_LOCATION + SBRR);

   *baud_rate = serial_baud_rate ;


#endif

}

/******************************************************************************
/
/            check_all_sent
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will return the value of the all sent flag
/         flag is set to FALSE when ACU_TO_NUM determines that
/         there are no more buffers to send. It is set to TRUE
/         when a transmit interrupt occurs.                /
/
/   Input Parameters: None
/
/   Output Parameters: ubyte - Status of all sent flag
/                      TRUE  - if SCC shift register is empty
/                      FALSE - if SCC shift register is not empty
/
/   Global Variables Changed:  None
/
/   Users:   auto_dialer, check_for_ring, build_cmd_line, at_O
/      disable_acu_on_terminal, output_test_messge
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
ubyte check_all_sent(void)
{
   if( !dte_tx_count && dte_transmit_empty())
      return(TRUE);
   else
      return(FALSE);

}

/******************************************************************************
/
/            acu_reset_port
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will set SCC up to receive in data mode
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   disable_acu_on_terminal
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_reset_port(void)
{
}

/******************************************************************************
/
/            get_autobaud_rate
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will take the SCON value programmed
/                       by autobaud and compare it with the calculated values
/                       in the autobaud table to determine the dte baud rate.
/
/   Input Parameters: None
/
/   Output Parameters: D0 - baud rate (bps)
/                 1 - 110
/                 2 - 300
/                 3 - 1200
/                 4 - 2400
/                 5 - 4800
/                 6 - 7200
/                 7 - 9600
/                 8 - 12000
/                 9 - 14400
/                10 - 16800
/                11 - 19200
/                12 - 38400
/                13 - 57600
/                14 - 600
/                15 - 115200
/
/   Global Variables Changed:  None
/
/   Users:   get_rx_baud_rate
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte get_autobaud_rate(void)
{

#if PARALLEL_MODE == 1

   ubyte rate,*lobyte,*hibyte;
   uword parallel_baud_rate;

   lobyte = (ubyte *)(PARALLEL_16550_LOCATION + HDLLS);
   hibyte = (ubyte *)(PARALLEL_16550_LOCATION + HDLMS);

   parallel_baud_rate  = *hibyte;
   parallel_baud_rate  = parallel_baud_rate << 8;
   parallel_baud_rate |= *lobyte;




/*switch (dte_auto_baud_rate)*/


   switch (parallel_baud_rate)
   {
    case BR115200:               /* 115.2k   */
       rate = 0x0f;
       break;

    case BR57600:                /* 57.6k    */
       rate = 0x0d;
       break;

    case BR38400:          /* 38.4k    */
       rate = 0x0c;
    break;

    case BR19200:          /* 19.2k    */
       rate = 0x0b;
       break;

    #if 0
    case 0x06:             /* 16.8k    */
       rate = 0x0a;
       break;

    case BR14400:           /* 14.4k    */
       rate = 0x09;
       break;

    case 0x06:                   /* 12k    */
       rate = 0x08;
       break;
    #endif

    case BR9600:            /* 9600     */
       rate = 0x07;
       break;

    case BR7200:            /* 7200     */
       rate = 0x06;
       break;

    case BR4800:            /* 4800     */
       rate = 0x05;
       break;

    case BR2400:            /* 2400     */
       rate = 0x04;
       break;

    case BR1200:            /* 1200     */
       rate = 0x03;
       break;

    case BR600:             /* 600      */
       rate = 0x0e;
       break;

    case BR300:                  /* 300      */
       rate = 0x02;
       break;

    case BR110:                  /* 110      */
       rate = 0x01;
       break;

    default:
       rate = 0x0f;              /* 115.2k   */
       break;
   }

   return(rate);
#endif

#if SERIAL_MODE == 1

   ubyte rate;
   uword serial_baud_rate,*baud_rate;

   baud_rate = (uword *)(SERIAL_UART_LOCATION + SBRR);

   serial_baud_rate  = *baud_rate;




/*switch (dte_auto_baud_rate)*/


   switch (serial_baud_rate)
   {
    case BR115200:               /* 115.2k   */
       rate = 0x0f;
       break;

    case BR57600:                /* 57.6k    */
       rate = 0x0d;
       break;

    case BR38400:          /* 38.4k    */
       rate = 0x0c;
    break;

    case BR19200:          /* 19.2k    */
       rate = 0x0b;
       break;

    #if 0
    case 0x06:             /* 16.8k    */
       rate = 0x0a;
       break;

    case BR14400:           /* 14.4k    */
       rate = 0x09;
       break;

    case 0x06:                   /* 12k    */
       rate = 0x08;
       break;
    #endif

    case BR9600:            /* 9600     */
       rate = 0x07;
       break;

    case BR7200:            /* 7200     */
       rate = 0x06;
       break;

    case BR4800:            /* 4800     */
       rate = 0x05;
       break;

    case BR2400:            /* 2400     */
       rate = 0x04;
       break;

    case BR1200:            /* 1200     */
       rate = 0x03;
       break;

    case BR600:             /* 600      */
       rate = 0x0e;
       break;

    case BR300:                  /* 300      */
       rate = 0x02;
       break;

#if 0
    case BR110:                  /* 110      */
       rate = 0x01;
       break;

#endif

    default:
       rate = 0x0f;              /* 115.2k   */
       break;
   }

     old_serial_dte_baud = rate; /* ramn 4/17/96 */
   return(rate);
#endif




}

/******************************************************************************
/
/            acu_halt
/
/   Author:    RSA
/
/   Creation Date:   12/19/94
/
/   Description:   This routine will stop all acu interrupts.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   at_plus()
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_halt(void)
{
/* shut down tx and rx interrupts */
   acu_halted = TRUE;

}

/************************************************************************
/
/            acu_restart
/
/   Author:    RSA
/
/   Creation Date:   12/19/94
/
/   Description:   This routine will restart the acu interrupt
/         processing.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:   at_plus()
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_restart(void)
{
/* enable tx and rx interrupts */
   acu_halted = FALSE;
   acu_port_init();
   pp_control(OFF);
}

/************************************************************************
/
/            acu_io_enable
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/09/94
/
/   Description:   This routine will set the I/O mode to route the
/         data through the ACU code
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  Reinitialize buffer descriptor tables
/               ACU_STATUS, DTE_STATUS
/
/   Users:   enable_acu_on_terminal
/
/   -----------------------------------------------------------------
/   -         Modifications                                         -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void acu_io_enable(void)
{
/* RJM100896 */
/* V.80 support */
   /* Remember who is currently active */
   if (dte_mode == DTE_V80_SAM)
   {
      v80_online_cmd = TRUE;
   }

   dte_mode = ACU;
   acu_installed = TRUE;
}

/************************************************************************
/
/            acu_io_disable
/
/   Author:    RSA
/
/   Creation Date:   01/24/91
/
/   Description:   This routine will switch the I/O ports to route the
/         data through the DTE code
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  Reinitialize buffer descriptor tables
/               Reset acu SCC interrupt vector
/               ACU_STATUS, DTE_STATUS
/
/   Users:   disable_acu_on_terminal
/
/       ------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
void acu_io_disable(void)
{
/* RJM100896 */
/* V.80 support */
   /* If V80 was previously active, make active again */
   if (v80_online_cmd == TRUE)
   {
      dte_mode = DTE_V80_SAM;
      v80_online_cmd = FALSE;
   }
   else
      dte_mode = DTE;

   acu_installed = FALSE;
}

/************************************************************************
/
/            dte_disable
/
/   Author:    RSA
/
/   Creation Date:   10/28/94
/
/   Description: Stub file for start/end_clamp mechanism.  Used by some hardware
/              platforms for SCC switching (not used by the H8 I/O code).
/
/   Input Parameters:  NONE
/
/   Output Parameters: NONE
/
/   Global Variables Changed: NONE
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_disable(void)
{}

/************************************************************************
/
/            dte_enable
/
/   Author:    RSA
/
/   Creation Date:   10/28/94
/
/   Description: Stub file for start/end_clamp mechanism.  Used by some hardware
/              platforms for SCC switching (not used by the H8 I/O code).
/
/   Input Parameters:  NONE
/
/   Output Parameters: NONE
/
/   Global Variables Changed: NONE
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_enable(void)
{}


/************************************************************************
/
/            Process one msec timer
/
/   Input Parameters:  NONE
/
/   Output Parameters: NONE
/
/   Global Variables Changed: NONE
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/

void process_one_msec(void)
{
   if(modem_1ms_timer)
    modem_1ms_timer--;

    msec_counter++;                             /*22296shujin, ring detec*/


    if(dial_timer)    dial_timer--;
}


/************************************************************************
/
/            acu_to_free
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine returns the available space in the acu
/                  transmit buffer
/
/   Input Parameters: None
/
/   Output Parameters: uword space-in-buffer
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
/*RJM51796*/
uword acu_to_free(void)
{
   return (OTHER_BUFFER_SIZE - dte_tx_count -1);
}



/* we only need take care fifo ro non_fifo cases,
   because full duplex throuphput already be improved greadtly
  shujin 9/10/97 
*/

#if PARALLEL_MODE == 1

void  reload_timer2()
{

     if ( *(ubyte *)(PARALLEL_16550_LOCATION + HFCR) & 0x01)
     {
         if( timer2_flag != MAX_FILL )
         {
            timer2_flag = MAX_FILL;
            reload_fifo_timer();
         } 
     }
     else
     {
         if( timer2_flag != 1 )
         {
            timer2_flag = 1;
            reload_no_fifo_timer();
         } 
     }

}
#endif
