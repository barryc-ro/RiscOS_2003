/************************************************************************
/
/   Copyright 1994, 1995.
/   All Rights Reserved by:
/   RSA
/   7701 Six Forks Road
/   Suite 120
/   Raleigh, NC  27615
/   (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File:      DTE.C
/
/   Version:   1.00
/
/   Function:  This file contains the DTE IO code
/
/   Product:   H8/3002 IO code
/
/   Platform:  H8/3002 + TI 16PC564 PCMCIA UART (TIPU)
/
/   History:   acu.c v1.00
/
/   Created:   12/08/94
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
#include "sys_def.h"
#include "acuiomem.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "dteequ.h"
#include "edf.dte"
#include "par_def.h"

#ifdef __riscos
#include "riscos.h"
#endif



/* unified DTE I/O routines */
uword dte_from_num(void);
ubyte dte_from_char(void);
void  dte_from_clear(void);
void  dte_to_clear(void);
uword dte_to_free(void);
void  dte_to_char (ubyte);
ubyte dte_to_num(void);
ubyte dte_rx_resume(void);
ubyte dte_rx_suspend(void);
void  dte_timer (void);
void  dte_to_break (ubyte type, ubyte length);

void  dte_init(ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte);

void  dte_reconfigure(ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte, ubyte,\
         ubyte, ubyte);
void  dte_port_init(void);
void  common_dte_init(ubyte, ubyte, ubyte);

/* block DTE I/O routines */
uword dte_from_block_num(void);

void  dte_from_block_update(uword num);

ubyte *dte_from_block_pointer(void);
uword dte_to_block_free(void);
void  dte_to_block_update(uword num);
ubyte *dte_to_block_pointer(void);

/* RJM 09/09/96 */
/* V80 support */
void dte_info(uword*,uword*,uword*,uword*,uword*,uword*,uword*,uword*);

/* fax only DTE I/O routines */
void fax_dte_reset(void);
void fax_dte_init(ubyte, ubyte, ubyte);
ubyte fax_dte_flowed_on(void);

/* RJM040396 */
/* VView prototypes */
void vcv_dte_reset(void);
void vcv_dte_init( ubyte, ubyte);

/* Start Change 6/14/1995. */
/* Voice DTE prototypes */
void voice_dte_init(ubyte, ubyte, ubyte, uword, uword, uword);
/* End Change 6/14/1995. */


/* stubbed routine prototypes */
void  dte_falling_back_to_speed (void);
void  dte_end_falling_back_to_speed (void);
void  dte_reset(void);

void  dte_dest_break_clear(void);

extern ubyte dte_data_ready(void);
extern ubyte dte_transmit_empty(void);
extern ubyte dte_read_char_from_uart(void);
extern void dte_write_char_to_uart(ubyte);
extern ubyte modem_control_reg_rts(void);
extern void enable_int(void);
extern void disable_int(void);
extern void dte_cts_on(void);
extern void dte_cts_off(void);
extern void dte_tx_suspend(void);
extern void system_rcv_escape(void);

/* ramn defined variables */
extern ubyte vce_mode;
extern ubyte line_io_enabled;

/*mrm8796*/
/*sw flow cntl data mode only fix
extern void	install_poll_voice_dte_interrupt(void);
*/
/* ramn 8/22/96 */

/*mrm82096*/
/*sw flow cntl data mode only fix*/

#if 0
extern void	start_fifo_timer(void);
extern void	stop_fifo_timer(void);
#endif

/*mrm9296*/
/*mct when no flow control*/
extern void install_dte_poll_no_flow (void);

void PrintMsg(char *);
void outchar(unsigned char);

extern uword v80_tx_timer;

/************************************************************************
/
/            dte_from_num
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine returns the number of chars received from
/                  the dte and waiting in the buffer.
/
/   Input Parameters: None
/
/   Output Parameters: uword dte_rx_count
/
/   Global Variables Changed:  None
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
uword dte_from_num(void)
{
#ifdef __riscos
    _kernel_swi_regs r;

    if (OutputStream.buffer_privid == -1)
        return 0;

    r.r[0] = BM_UsedSpace;
    r.r[1] = OutputStream.buffer_privid;
    CallBufMan(&r);

    return r.r[2];
#else
   if( dte_mode != ACU )
       return(dte_rx_count);
   else
       return(0);
#endif
}

/************************************************************************
/
/            dte_from_clear
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine resets all variables associated with
/                  receiving characters from the DTE.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_from_clear(void)
{
#ifdef __riscos
    _kernel_swi_regs r;

    if (OutputStream.buffer_privid == -1)
        return;

    r.r[0] = BM_PurgeBuffer;
    r.r[1] = OutputStream.buffer_privid;
    CallBufMan(&r);
#else
   ubyte rx_char;

   extern ubyte dte_flag_count;

   disable_int();
/*mrm8895*/
#if 0
   do {
      rx_char = READ_UART();
   }
   while (!(UART_LSR & TEMT));
#endif

   do {
      rx_char = dte_read_char_from_uart();
   }
   while (dte_data_ready());

   dte_rx_insert = 0;            /* reset buffer pointers */
   dte_rx_remove = 0;
   dte_rx_count = 0;
#endif

   if (dte_mode == DTE)
   {
      dte_20_mSec_timer = 2;      /* reset 20 Msec timer */
      /*  reset escape variables */
      dte_tesc_count = 0;
      dte_guard_time = FALSE;          /* leading guard time not found */
      dte_guard_time = esc_guard_time;/* reset guard time counter */
   }

#ifndef __riscos
   /* If all other modes should to flow control */
   /* If rx was flowed off, start it back up */
   if (rx_suspended)
   {
      if (dte_tx_interrupt_expected)
         rx_resume_pending = TRUE;
      else
         dte_rx_resume();
   }

   dte_flag_count = 0;

   enable_int();
#endif

if( dte_mode != ACU )
   PrintMsg( "dte_from_clear()" );
}

/************************************************************************
/
/            dte_to_clear
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine resets all variables associated with
/                  transmitting all characters to the DTE.
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_to_clear(void)
{
   #ifdef __riscos
    _kernel_swi_regs r;

    if (InputStream.buffer_privid == -1)
        return;

    r.r[0] = BM_PurgeBuffer;
    r.r[1] = InputStream.buffer_privid;
    CallBufMan(&r);
   #else
   disable_int();
/*mrm8895*/
#if 0
   if ((dte_mode == ACU) && pp_enabled)
      pp_to_clear();          /* run packet protocol routine */
#endif
   dte_tx_insert = 0;         /* fall through and use this routine too */
   dte_tx_remove = 0;
   dte_tx_count = 0;
   dte_tx_interrupt_expected = FALSE;
   enable_int();
#endif
}

/************************************************************************
/
/            dte_from_char
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine retrieves the next char from the buffer
/
/   Input Parameters: None
/
/   Output Parameters: ubyte rxchar
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
ubyte dte_from_char(void)
{
#ifdef __riscos
    _kernel_swi_regs r;

    r.r[0] = BM_RemoveByte;
    r.r[1] = OutputStream.buffer_privid;
    CallBufMan(&r);

    return r.r[2];
#else
   ubyte rxchar;

   disable_int();

   rxchar = dte_rx_buffer[dte_rx_remove++];

   dte_rx_remove &= BUFFER_POINTER_MASK;
   dte_rx_count--;

   /* If rx was flowed off in DTE mode, start it back up */
/* T_VOICE chk added by ramn on 10/10/95 */

/*
   if (((dte_mode == DTE) || ( dte_mode == T_VOICE ) || (dte_mode == FAX)) && rx_suspended)
*/

/* RJM052996 */
/* All modes except ACU are checked */

   if ( (dte_rx_count < dte_xon_threshold) &&
        rx_suspended && (dte_mode != ACU) )
   {
/* RJM 09/09/96 */
/* V80 support */
         if ( dte_tx_interrupt_expected || tx_suspended_for_break )
            rx_resume_pending = TRUE;
         else
            dte_rx_resume();
   }


   enable_int();


#if 0
outchar(rxchar);
#endif

   return(rxchar);
#endif
}

/************************************************************************
/
/            dte_to_free
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine returns the available space in the DTE
/                  transmit buffer
/
/   Input Parameters: None
/
/   Output Parameters: uword space-in-buffer
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
/*RJM51796*/
/*dte lockup problem online esc sequence with receiving data*/
/* Correct in dte.c */
uword dte_to_free(void)
{
 #ifdef __riscos
    _kernel_swi_regs r;

    if (InputStream.buffer_privid == -1)
        return 0;

    r.r[0] = BM_FreeSpace;
    r.r[1] = InputStream.buffer_privid;
    CallBufMan(&r);

    return r.r[2];
#else
   uword temp;

   disable_int();

/*mrm8895*/
#if 0

   if ((dte_mode == ACU) && acu_installed && pp_enabled)
   {
      temp = pp_to_free() & 0x00ff;
   }
   else
#endif

   if( dte_mode == ACU )
   {
      temp = 0;
   }
   else
/* shujin 9/29/97 for zmode uploading, set DTE buf rx0x800, tx0x400 */
     temp = DTE_BUFFER_SIZE_TX - dte_tx_count;

   enable_int();
   return(temp);
#endif
}
/************************************************************************
/
/            dte_to_char
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine buffers a character to go to the DTE
/
/   Input Parameters: ubyte ch
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_to_char(ubyte ch)
{
#ifdef __riscos
    #if 0 /*KJBD*/
    _kernel_swi_regs r;

    r.r[0] = BM_InsertBlock;
    r.r[1] = InputStream.buffer_privid;
    r.r[2] = (int)"dte_to_char()=\"";
    r.r[3] = strlen("dte_to_char()=\"");
    CallBufMan(&r);

    r.r[0] = BM_InsertByte;
    r.r[1] = InputStream.buffer_privid;
    r.r[2] = ch;
    CallBufMan(&r);

    r.r[0] = BM_InsertByte;
    r.r[1] = InputStream.buffer_privid;
    r.r[2] = '"';
    CallBufMan(&r);
    #else
    _kernel_swi_regs r;

    r.r[0] = BM_InsertByte;
    r.r[1] = InputStream.buffer_privid;
    r.r[2] = ch;
    CallBufMan(&r);
    #endif
#else
/* If we are using RTS/CTS flow control */

/* shujin 9/24/97 , move it into dte_interrutp_tx() */

#if 0

   if(dte_to_modem_flow_cntl & RTS_AND_CTS )
   {

/* If Host has dropped RTS, then we are flowed OFF */
       if( !(modem_control_reg_rts()) )
           dte_tx_suspend();
   }
#endif



/*mrm8895*/
#if 0
   if ((dte_mode == ACU) && acu_installed && pp_enabled)
      pp_to_char(ch);
   else
   {
#endif


       disable_int();
       dte_tx_buffer[dte_tx_insert++] = ch;
/* shujin 9/29/97 for zmode uploading, set DTE buf rx0x800, tx0x400 */
       dte_tx_insert &= BUFFER_POINTER_MASK_TX;
       dte_tx_count++;
       enable_int();


/* As long as we aren't suspended, keep Xmtr alive */

/* shujin 9/24/97 , not necessary here? could we comment this ? */
       if( !(dte_tx_suspended_by_terminal || tx_suspended_for_break) )
       {
           dte_tx_interrupt_expected = TRUE;
           ENABLE_XMTR();
       }

#endif

}









/************************************************************************
/
/   Procedure:    dte_to_num
/
/   Author :    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine returns the # of characters waiting to
/         be transmitted to the terminal, used by the modem code
/         to do an orderly take-over of the dte during AT command
/          processing.  If there is a char in the process of being
/          transmitted, then the character count is incremented by
/         1.
/
/   Input Parameters: None
/
/   Output Parameters: uword
/
/   Global Variables Changed: None
/
/   Users:
/
/   -------------------------------------------------------------
/   -         Modifications             -
/   -------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/   Reason:
/
************************************************************************/
ubyte dte_to_num(void)
{
#ifdef __riscos
    /*
     * This is not really necessary under RISC OS, as effectively all characters are
     * transmitted immediately to the terminal.
     */
    return 0;
#else
   uword temp;

   disable_int();

/*mrm8895*/
#if 0

   if ((dte_mode == ACU) && acu_installed && pp_enabled)
   {
      temp = pp_to_num() & 0x00ff;
   }
   else
   {

#endif

/*    If the buffer has data return that value */
   if (dte_tx_count)
      temp = dte_tx_count;
   else
      temp = 0;

/*    The buffer is empty, so return the # of chars the FIFO has */
/* >>>can't do this with the current version of TIPU<<< */
/*mrm8895*/
#if 0

   }
#endif
   enable_int();
   return(temp);
#endif

}

#ifndef __riscos
/************************************************************************
/
/            dte_rx_resume
/
/   Author: RSA (drc)
/
/   Creation Date:   12/16/94
/
/   Description:   This routine will resume receive operations
/
/   Input Parameters: None
/
/   Output Parameters: (ubyte)
/                      TRUE = char sent
/                      FALSE = no char sent
/
/   Global Variables Changed: rx_suspended, rx_resume_pending
/
/   Users:   dte_from_clear, dte_from_char, dte_tx_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte dte_rx_resume(void)
{



   if (modem_to_dte_flow_cntl & RTS_AND_CTS)
   {

      /* No longer suspended */
      rx_suspended = FALSE;
      rx_resume_pending = FALSE;

/*  logicly we should add following line here, shujin
   rx_suspend_pending = FALSE;
*/

      dte_cts_on();      /* assert clear to send */
   }


/*mrm41796*/
/*XON XOFF flow control fix*/

#if 0

   if (dte_mode == 3 )
   {

       if(dte_transmit_empty())
       {
           rx_suspended = FALSE;
           rx_resume_pending = FALSE;
           dte_tx_interrupt_expected = TRUE;

           dte_write_char_to_uart(modem_to_dte_xon_char);     /* send an XON character */

           ENABLE_XMTR();
           return(TRUE);
       }
       else
       {
           rx_suspended = TRUE;
           rx_resume_pending = TRUE;
           dte_tx_interrupt_expected = FALSE;
       }
   }

#endif


   	if (modem_to_dte_flow_cntl & XON_AND_XOFF )
   	{

/*mrm82096*/
/*zmodem fix for parallel mode*/

/* shujin 9/9/97, no timer3 anymore
				if (dte_mode == DTE)
					start_fifo_timer();
*/


/*mrm41796*/
/*XON XOFF flow control fix*/

		 	/*if(dte_transmit_empty())*/

		 	if((dte_transmit_empty())||(fifo_not_full()))
       	{

/*mrm41796*/
/*XON XOFF flow control fix*/


			  if(dte_mode == FAX)
      	  		dte_cts_on();      /* assert clear to send */

     		  rx_suspended = FALSE;
           rx_resume_pending = FALSE;
           dte_tx_interrupt_expected = TRUE;
           dte_write_char_to_uart(modem_to_dte_xon_char);     /* send an XON character */


/*mrm41796*/
/*XON XOFF flow control fix*/


/*
			  if(dte_mode == FAX)
*/

/* RJM062596 */
			  if(dte_mode != ACU)

      	  	  time_out_on_fifo();

           ENABLE_XMTR();
           return(TRUE);
       	}
       	else
       	{
           rx_suspended = TRUE;
           rx_resume_pending = TRUE;
           dte_tx_interrupt_expected = FALSE;
       	}
   	}



   return(FALSE);
}

/************************************************************************
/
/            dte_rx_suspend
/
/   Author: RSA (drc)
/
/   Creation Date:   12/16/94
/
/   Description:   This routine will suspend receive operations
/
/   Input Parameters: None
/
/   Output Parameters: (ubyte)
/                      TRUE = char sent
/                      FALSE = no char sent
/
/   Global Variables Changed: rx_suspended, rx_resume_pending
/
/   Users:   dte_rx_int
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte dte_rx_suspend(void)
{


   if (modem_to_dte_flow_cntl & RTS_AND_CTS)
   {
      rx_suspended = TRUE;
      rx_suspend_pending = FALSE;

/* testing
  rx_resume_pending = FALSE;
*/

      dte_cts_off();     /* negate clear to send */


   }


/*mrm41796*/
/*XON XOFF flow control fix*/

#if 0

	if(dte_mode == 3)
   {

       if(dte_transmit_empty())
       {
           rx_suspended = TRUE;
           rx_suspend_pending = FALSE;
           dte_tx_interrupt_expected = TRUE;


           dte_write_char_to_uart(modem_to_dte_xoff_char);     /* send an XOFF character */

           ENABLE_XMTR();
           return(TRUE);
       }
       else
       {
           rx_suspended = FALSE;
           rx_suspend_pending = TRUE;
           dte_tx_interrupt_expected = FALSE;
       }
   }



#endif



	if (modem_to_dte_flow_cntl & XON_AND_XOFF)
   	{
       /* If there is room in the UART */


/*mrm82096*/
/* zmodem fix for parallel mode */
/* no timer3 anymore, shujin 9/9/97

				if (dte_mode == DTE)
			  		stop_fifo_timer();
*/


/*mrm41796*/
/*XON XOFF flow control fix*/

/*if(dte_transmit_empty())*/

		   if((dte_transmit_empty())||(fifo_not_full()))
			{
           dte_write_char_to_uart(modem_to_dte_xoff_char);     /* send an XOFF character */

/*mrm41796*/
/*XON XOFF flow control fix*/

/*			  if(dte_mode == FAX)
*/
/* RJM062596 */

			  if(dte_mode != ACU)
			  		time_out_on_fifo();

           rx_suspended = TRUE;
           rx_suspend_pending = FALSE;
           dte_tx_interrupt_expected = TRUE;


/*mrm41796*/
/*XON XOFF flow control fix*/

			  if(dte_mode == FAX)
      			dte_cts_off();     /* negate clear to send */

           ENABLE_XMTR();
           return(TRUE);
       	}
       	else
       	{
           rx_suspended = FALSE;
           rx_suspend_pending = TRUE;
           dte_tx_interrupt_expected = FALSE;
       	}
		}


   return(FALSE);
}

#endif

#if TIES_HAYES_ESCAPE                                            /* ciy021596 */

extern void set_acu_at_cmds(ubyte);
extern void set_acu_data_cmds(ubyte);
extern void set_acu_phbk_cmds(ubyte);
extern void at_parser_reset(ubyte *);
extern void execute_cmd(void);
extern ubyte parse_current_table;
extern ubyte *parse_cmd_ptr;
extern PARSE_PARAM_BUFFER parse_p_buffer;
extern ubyte parse_state;
extern PARSE_CMD_TABLE_STRUCT *parse_table_ptr;
extern PARSE_CMD_TABLE_STRUCT *parse_tbls_array[MAX_PARSE_TABLES];

extern void build_event(ubyte, ubyte);
extern ubyte ties_esc_state;
extern void set_acu_ties_esc_data_cmds(ubyte);

extern ubyte atW ;

#define ESC_NONE     0
#define ESC_DONE     1

void reset_ties_cmd_table(void);
void reset_ties_cmd_table(void)
{                                       /* To take out TIES escape command table out, and put AT's back */
    set_acu_ties_esc_data_cmds(OFF);
    set_acu_at_cmds(ON);
    set_acu_data_cmds(ON);
}

void clean_ties_flags(void);
void clean_ties_flags(void)
{
    ties_esc_state = ESC_NONE;
    error_occurred = FALSE;
    dte_lead_guard = FALSE;
    dte_guard_time = 0;
    dte_tesc_count = 0;
}

#endif

#ifndef __riscos

/************************************************************************
/
/            dte_timer
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/13/94
/
/   Description:   Called every 10ms by the control code, this routine
/                  processes the DTE IO timers and maintains break and
/                    escape sequence mechanisms
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_timer (void)
{
   if(dte_20_mSec_timer)
   dte_20_mSec_timer--;


   if(v80_tx_timer)
   v80_tx_timer--;

/*   Break Timing   */

/*
   if ( dte_tx_break_state == TX_BREAK_STATE_TIMING )
   {
      dte_tx_break_count--;
      if ( dte_tx_break_count == 0 )
         dte_finish_tx_break();
   }

   if ( dte_rx_break_running == TRUE )
      if ( dte_rx_break_timer < 0xff )
         dte_rx_break_timer++;
*/

/*   Escape Timing   */
   if (dte_20_mSec_timer == 0)
   {
      dte_20_mSec_timer = 2;

      /* If timer already 0 do nothing */
      if (dte_guard_time != 0)
      {
         dte_guard_time-- ;
         if ( dte_guard_time == 0 )
         {
#if TIES_HAYES_ESCAPE                                            /* ciy021596 */

            if ( ties_esc_state == 'T')
            {                                   /* Rceived ATxxx<CR> */
                if ( dte_lead_guard == FALSE )
                {
                     build_event(E_MSG,OK);     /* out OK, because not for +++ before */
                     dte_lead_guard = TRUE;
                     dte_guard_time = 2;
                     return;
                }
                else
                     dte_lead_guard = FALSE;

                ties_esc_state = ESC_DONE;
                dte_tesc_count = 0;
                error_occurred = FALSE;

                set_acu_ties_esc_data_cmds(ON);

                set_acu_at_cmds(OFF);
                set_acu_data_cmds(OFF);

                st_parse.state = CMD4;        /* Next state */
                timer1 = 0;                             /* to execute immediately */

                cmd_ptr = (ubyte *)&cmd_line[0];        /* setup buffer pointer */

                parse_cmd_ptr = cmd_ptr;
                                                        /* Reset command parse vars */
                parse_p_buffer.ldata[0] = 0;            /* Reset Parameter Buffer       */
                parse_state = PARSE_STATE__FILTER;      /* Reset AT parser state        */
                parse_current_table = 0;                /* Reset current command table  */
                parse_table_ptr = parse_tbls_array[parse_current_table];

                while ( st_parse.state == CMD4)
                            execute_cmd();

                if ( error_occurred )
                    {
                        switch ( ties_esc_state)
                        {
                            case 'H' :                      /* got ATH0 right after +++, at AT&Tn */
                                                            /* action: clean up TIES setup and let ATH0 routine to drop */
                                clean_ties_flags();
                                ties_esc_state = ESC_DONE;  /* to trigger parser reset */
                                break;

                           default:                        /* Back to online mode */
/*mrm62796*/
/*mrm71096*/
							 				if ((atW != 2) && (atW != 4))
            								build_event(E_MSG,CONNECT_XXXX);
											else
			    								build_event(E_MSG,CARRIER_XXXX);

/*                                build_event(E_MSG,CONNECT_XXXX);*/
                                break;
                        }
                    }
                else
                    {
                        clean_ties_flags();
                        system_rcv_escape();        /* to excute command, output OK, and go to online command mode */
                    }
                error_occurred = FALSE;
                reset_ties_cmd_table();     /* ciy041996 in case remote drop, the parse table has to recover */
            }
            else
            {
                if ( dte_lead_guard == FALSE )
                {
                     dte_lead_guard = TRUE;
                     if ( dte_tesc_count == 3 )
                          build_event(E_MSG,OK);
                }
                else
                {
/*mrm62796*/
/*mrm71096*/
               	if ((atW != 2) && (atW != 4))
            			build_event(E_MSG,CONNECT_XXXX);
				 		else
			    			build_event(E_MSG,CARRIER_XXXX);
      				/*build_event(E_MSG,CONNECT_XXXX);*/
                     dte_lead_guard = FALSE;
                }
            }
#else
                                            /* Hayes escape sequence */
            if ( dte_lead_guard == FALSE )
               dte_lead_guard = TRUE;
            else
            {
            if (dte_tesc_count == 3 )
               {
                  dte_tesc_count = 0;
                  dte_lead_guard = FALSE;
                  dte_guard_time = esc_guard_time;
                  system_rcv_escape();
               }
            }
#endif                                  /* ciy021596 */
         }
      }
   }
}

#endif

/************************************************************************
/
/            dte_to_break
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/08/94
/
/   Description:   This routine processes the DTE IO timers
/
/   Input Parameters: ubyte type
/                     ubyte length
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_to_break (ubyte type, ubyte length)
{
   type = length;
/* currently no way to send breaks to dte in parallel mode! */
}

/************************************************************************
/
/            dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/13/94
/
/   Description:   This routine initializes the DTE IO code
/
/   Input Parameters: ubyte baud_rate
/                     ubyte data bits
/                     ubyte stop bits
/                     ubyte parity
/                     ubyte dte_to_modem flow control
/                     ubyte dte_to_modem xon char
/                     ubyte dte_to_modem xoff char
/                     ubyte modem_to_dte flow control
/                     ubyte modem_to_dte xon char
/                     ubyte modem_to_dte xoff char
/                     ubyte pass_through_flow_control
/                     ubyte escape_char
/                     ubyte escape_guard_time
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_init( ubyte in_baud_rate,
      ubyte in_data_bits,
      ubyte in_stop_bits,
      ubyte in_parity,
      ubyte in_term_to_modem_flow_cntl,
      ubyte in_term_to_modem_xon,
      ubyte in_term_to_modem_xoff,
      ubyte in_modem_to_term_flow_cntl,
      ubyte in_modem_to_term_xon,
      ubyte in_modem_to_term_xoff,
      ubyte in_pass_through_flow_cntl,
      ubyte in_esc_char,
      ubyte in_esc_guard_time,
      ubyte escape_mode)
{
   ubyte temp;

PrintMsg( "dte_init()" );

#ifndef __riscos
   disable_int();
#endif
/* initialize DTE parameters */
   dte_mode = DTE;

/* RJM 09/09/96 */
/* V80 support */
   /* initialize the XON/XOFF threshold values */

   dte_xoff_threshold = DTE_NEAR_FULL;
   dte_xon_threshold = DTE_NEAR_EMPTY;

   dte_guard_time = esc_guard_time = in_esc_guard_time;
   temp = escape_mode;
   esc_chr = in_esc_char;
   dte_20_mSec_timer = 2;
   dte_tesc_count = 0;
   dte_lead_guard = FALSE;
   flow_cntl_pass = in_pass_through_flow_cntl;

   dte_rx_break_running = FALSE;
   rx_suspend_pending = FALSE;
   rx_resume_pending = FALSE;
   rx_suspended = FALSE;

   dte_tx_suspended_by_terminal= FALSE;
   tx_suspended_for_break = FALSE;
   dte_tx_interrupt_expected = FALSE;
   dte_tx_break_state = TX_BREAK_STATE_IDLE;

#ifndef __riscos
   dte_port_init();
#endif

/*    Set flow control variables    */
   modem_to_dte_xoff_char = in_modem_to_term_xoff;
   modem_to_dte_xon_char = in_modem_to_term_xon;
   modem_to_dte_flow_cntl = in_modem_to_term_flow_cntl;

   dte_to_modem_xoff_char = in_term_to_modem_xoff;
   dte_to_modem_xon_char = in_term_to_modem_xon;
   dte_to_modem_flow_cntl = in_term_to_modem_flow_cntl;


#ifndef __riscos
/* no timer3 int, no necessary keep those codes, shujin 9/9/97 */
#if 0
		if (modem_to_dte_flow_cntl == 0)
		{
			install_dte_poll_no_flow ();
		}
		else
		{
/*mrm82096*/
/*changed to poll mode to prevent reboot*/
			install_poll_dte_interrupt();
		}
#endif



/*
 * If h/w flow cntl is enabled, check RTS @ TIPU.   If RTS is down, then
 *  we're suspended by the terminal.
 */

   if (dte_to_modem_flow_cntl & RTS_AND_CTS)
/*mrm8895*/
#if 0
       if( !(UART_MCR & RTS) )
#endif
       if( !(modem_control_reg_rts()) )

         dte_tx_suspend();

   enable_int();
#endif
}

/************************************************************************
/
/            dte_port_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/19/94
/
/   Description:   This routine resets the DTE port buffer mechanisms
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:
/
/   Users:
/
/       -----------------------------------------------------------------
/   -         Modifications                 -
/   -----------------------------------------------------------------
/
/   Author & Date:   RSA
/   Description:
/       Reason:
/
************************************************************************/
void dte_port_init(void)
{
   dte_rx_remove = 0;
   dte_rx_insert = 0;
   dte_rx_count = 0;
   dte_tx_remove = 0;
   dte_tx_insert = 0;
   dte_tx_count = 0;
}

/************************************************************************
/
/            dte_from_block_num
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description:  Called to request the number of characters in the DTE
/            receive buffer from the last character removed to the end
/            of the buffer.
/
/   Input Parameters:  NONE
/
/   Output Parameters: uword - Number of characters in the DTE rx buffer
/
/   Global Variables Changed: NONE
/
/   Users: LAPM_BTLZ_balance, LAPM_BTEncode_driver
/
/   ************************************************************
/   *         Modifications                                    *
/   ************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
uword dte_from_block_num(void)
{
#ifdef __riscos
    _kernel_swi_regs r;

    if (OutputStream.buffer_privid == -1)
        return 0;

    r.r[0] = BM_NextFilledBlock;
    r.r[1] = OutputStream.buffer_privid;
    r.r[3] = 0;
    CallBufMan(&r);

    return r.r[3];
#else
   uword temp;

   disable_int();
   if (dte_mode != ACU)
   {
      /* test for non-wraparound case */
      if (dte_rx_remove > dte_rx_insert)
      {
         temp = DTE_BUFFER_SIZE - dte_rx_remove;

      }
      else
         temp = dte_rx_insert - dte_rx_remove;
   }
   else
      temp = 0;

   enable_int();
   return(temp);
#endif
}

/************************************************************************
/
/            dte_from_block_update
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to indicate to the DTE code the number of
/           of characters removed from the receive buffer.
/
/   Input Parameters: word - The number of chars removed from the rx buffer
/
/   Output Parameters: NONE
/
/   Global Variables Changed: DTE_RX_REMOVE, DTE_TOTAL_RX, DTE_RX_BUFF_CNT,
/              DTE_CB
/
/   Users: LAPM_BTEncode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_from_block_update(uword num)
{
   #ifdef __riscos
    _kernel_swi_regs r;

    r.r[0] = BM_NextFilledBlock;
    r.r[1] = OutputStream.buffer_privid;
    r.r[3] = num;
    CallBufMan(&r);
   #else
   disable_int();
   if (num)
   {
      dte_rx_remove = dte_rx_remove + num;
      dte_rx_remove &= BUFFER_POINTER_MASK;

      dte_rx_count = dte_rx_count - num;

      /* check to see if we should flow the DTE on */
/* RJM 09/09/96 */
/* V80 support */
      if ((rx_suspended) && (dte_rx_count < dte_xon_threshold))
      {
         if (dte_tx_interrupt_expected)
            rx_resume_pending = TRUE;
         else
            dte_rx_resume();
      }
   }
   enable_int();
  #endif
}

/************************************************************************
/
/            dte_from_block_pointer
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to get a pointer to the next available character
/           in the DTE receive buffer
/
/   Input Parameters:  NONE
/
/   Output Parameters: ubyte * - The pointer to the next available character
/
/   Global Variables Changed: NONE
/
/   Users: LAPM_BTEncode_driver
/
/   ************************************************************
/   *         Modifications                                    *
/   ************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte *dte_from_block_pointer(void)
{
   #ifdef __riscos
    _kernel_swi_regs r;

    r.r[0] = BM_NextFilledBlock;
    r.r[1] = OutputStream.buffer_privid;
    r.r[3] = 0;
    CallBufMan(&r);

    return (ubyte *) r.r[2];
   #else
   ubyte *ptr;
   disable_int();
   ptr = ((ubyte *)(&dte_rx_buffer)) + dte_rx_remove;
   enable_int();
   return(ptr);
   #endif
}

#ifdef __riscos
static ubyte to_block[128];
#endif

/************************************************************************
/
/            dte_to_block_free
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to request the number of characters the DTE
/           transmit buffer can accept before the buffer is full
/
/   Input Parameters:  NONE
/
/   Output Parameters: uword - space available in buffer
/
/   Global Variables Changed: NONE
/
/   Users: LAPM_BTDecode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
uword dte_to_block_free(void)
{
   #ifdef __riscos
    _kernel_swi_regs r;

    if (InputStream.buffer_privid == -1)
        return 0;

    r.r[0] = BM_FreeSpace;
    r.r[1] = InputStream.buffer_privid;
    CallBufMan(&r);

    if (r.r[2] < sizeof to_block)
        return r.r[2];
    else
        return sizeof to_block;
   #else
   uword temp;

   disable_int();

   if (dte_mode != ACU)
   {

/* Start Change 2/23/1995. */
      /* test for non-wraparound case */
      if (dte_tx_insert >= dte_tx_remove)
      {
/* shujin 9/29/97 for zmode uploading, set DTE buf rx0x800, tx0x400 */
         temp = DTE_BUFFER_SIZE_TX - dte_tx_insert;
      }
      else
         temp = dte_tx_remove - dte_tx_insert;
/* End Change 2/23/1995. */
   }
   else
      temp = 0;

   enable_int();

   return(temp);
   #endif
}

/************************************************************************
/
/            dte_to_block_update
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to indicate to the DTE code the number of
/           characters added to the transmit buffer
/
/   Input Parameters: word - Number of characters added to tx buffer
/
/   Output Parameters: NONE
/
/   Global Variables Changed: DTE_TX_INSERT, DTE_TX_COUNT, DTE_NTF,
/              DTE_TX_BUFFER
/
/   Users: LAPM_BTDecode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void dte_to_block_update(uword num)
{
   #ifdef __riscos
       #if 0 /*KJBD*/
       _kernel_swi_regs r;
       char buf[100];

       sprintf(buf, "dte_to_block_update(%d):\"", num);

       r.r[0] = BM_InsertBlock;
       r.r[1] = InputStream.buffer_privid;
       r.r[2] = (int) buf;
       r.r[3] = strlen(buf);
       CallBufMan(&r);

       r.r[0] = BM_InsertBlock;
       r.r[1] = InputStream.buffer_privid;
       r.r[2] = (int) to_block;
       r.r[3] = num;
       CallBufMan(&r);

       r.r[0] = BM_InsertBlock;
       r.r[1] = InputStream.buffer_privid;
       r.r[2] = (int) "\"";
       r.r[3] = 1;
       CallBufMan(&r);

       #else
       _kernel_swi_regs r;

       r.r[0] = BM_InsertBlock;
       r.r[1] = InputStream.buffer_privid;
       r.r[2] = (int) to_block;
       r.r[3] = num;
       CallBufMan(&r);
       #endif
   #else
   /* If we are using RTS/CTS flow control */
   if(dte_to_modem_flow_cntl & RTS_AND_CTS )
   {

       /* If Host has dropped RTS, then we are flowed OFF */
       if( !(modem_control_reg_rts()) )
           dte_tx_suspend();
   }

   if (num)
   {
      disable_int();
      dte_tx_insert = dte_tx_insert + num;
/* shujin 9/29/97 for zmode uploading, set DTE buf rx0x800, tx0x400 */
      dte_tx_insert &= BUFFER_POINTER_MASK_TX;
      dte_tx_count = dte_tx_count + num;
      enable_int();

      /* As long as we aren't suspended, keep Xmtr alive */
      if( !(dte_tx_suspended_by_terminal || tx_suspended_for_break) )
      {
           dte_tx_interrupt_expected = TRUE;
           ENABLE_XMTR();
      }
   }
   #endif
}

/************************************************************************
/
/            dte_to_block_pointer
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/20/94
/
/   Description: Called to get a pointer to the next available free
/           space in the DTE transmit buffer
/
/   Input Parameters:  NONE
/
/   Output Parameters: ubyte * - Pointer to the next available space.
/
/   Global Variables Changed: EXEC_DTE_BLOCK
/
/   Users: LAPM_BTDecode_driver
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
ubyte *dte_to_block_pointer(void)
{
   #ifdef __riscos
   return to_block;
   #else
   ubyte *ptr;
   disable_int();
   ptr = (ubyte *)(&dte_tx_buffer) + dte_tx_insert;
   enable_int();
   return(ptr);
   #endif
}

/* RJM040396 */
/************************************************************************
 *                    VCV SPECIFIC DTE I/O ROUTINES                     *
 ************************************************************************/

/******************************************************************************
/
/            vcv_dte_reset
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will halt the vcv DTE code to allow take-
/         over by the ACU for command line processing
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  dte_mode
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
******************************************************************************/
void vcv_dte_reset(void)
{
   disable_int();
   dte_mode = ACU;

/* should we call dte_port_init()? */
   enable_int();
}

/************************************************************************
/
/            vcv_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will initialize the DTE vcv code
/
/   Input Parameters:
/         ubyte - Baud Rate
/             0 = Reserved
/             1 = Reserved
/             2 = Reserved
/             3 = Reserved
/             4 = Reserved
/             5 = Reserved
/             6 = Reserved
/             7 = Reserved
/             8 = Reserved
/             9 = Reserved
/            10 = Reserved
/            11 = 19200
/            12 = 38400
/
/         ubyte - Terminal to modem flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/         ubyte - Modem to terminal flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
*************************************************************************/
void vcv_dte_init(ubyte in_dte_to_modem_flow_cntl,
         ubyte in_modem_to_dte_flow_cntl )
{

/*RJM*/
/*
   disable_int();
   dte_mode = FAX;
*/

#if 0
 	common_dte_init(in_baud_rate, in_dte_to_modem_flow_cntl, in_modem_to_dte_flow_cntl);

   /* Set dte baud rate */
   acu_set_tx_baud(in_baud_rate);
   enable_int();
#endif


   dte_mode = VCV;



   modem_to_dte_xon_char = XON_CHAR;
   dte_to_modem_xon_char = XON_CHAR;
   modem_to_dte_xoff_char = XOFF_CHAR;
   dte_to_modem_xoff_char = XOFF_CHAR;

   dte_to_modem_flow_cntl = in_dte_to_modem_flow_cntl;
   modem_to_dte_flow_cntl = in_modem_to_dte_flow_cntl;


}

/************************************************************************
 *                    FAX SPECIFIC DTE I/O ROUTINES                     *
 ************************************************************************/

/************************************************************************
/
/            fax_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will initialize the DTE fax code
/
/   Input Parameters:
/         ubyte - Baud Rate
/             0 = Reserved
/             1 = Reserved
/             2 = Reserved
/             3 = Reserved
/             4 = Reserved
/             5 = Reserved
/             6 = Reserved
/             7 = Reserved
/             8 = Reserved
/             9 = Reserved
/            10 = Reserved
/            11 = 19200
/            12 = 38400
/
/         ubyte - Terminal to modem flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/         ubyte - Modem to terminal flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS/RTS
/             3 = Both XON/XOFF and CTS/RTS
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
*************************************************************************/
void fax_dte_init( ubyte in_baud_rate,
         ubyte in_dte_to_modem_flow_cntl,
         ubyte in_modem_to_dte_flow_cntl )
{
   disable_int();
   dte_mode = FAX;
   common_dte_init(in_baud_rate, in_dte_to_modem_flow_cntl, in_modem_to_dte_flow_cntl);
/*mrm8895*/
#if 0
   pp_control(ON);
#endif
/*mrm82096*/
/*changed to poll mode to prevent reboot
			install_poll_dte_interrupt();
*/

   enable_int();
}

/******************************************************************************
/
/            fax_dte_reset
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description:   This routine will halt the fax DTE code to allow take-
/         over by the ACU for command line processing
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  dte_mode
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
******************************************************************************/
void fax_dte_reset(void)
{
   disable_int();
   dte_mode = ACU;
/*mrm8895*/
#if 0
   pp_control(OFF);
#endif

/* should we call dte_port_init()? */
   enable_int();
}

/************************************************************************
/
/            fax_dte_info
/
/   Author:    RSA (drc)
/
/   Creation Date: 12/23/94
/
/   Description:   This routine will setup a table with info on the DTE
/                  buffer for fax mode.
/
/   Input Parameters: (uword *) tx buffer size
/                     (uword *) tx buffer count
/                     (uword *) rx buffer size
/                     (uword *) rx buffer count
/
/   Output Parameters: None
/
/   Global Variables Changed: None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
void fax_dte_info(uword *tx_buffer_size, uword *tx_buffer_count,
uword *rx_buffer_size, uword *rx_buffer_count)
{
   *tx_buffer_size = OTHER_BUFFER_SIZE;
   *tx_buffer_count = dte_tx_count;
   *rx_buffer_size = OTHER_BUFFER_SIZE;
   *rx_buffer_count = dte_rx_count;
}

/************************************************************************
/
/            fax_dte_flowed_on
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/21/94
/
/   Description: Indicate the DTE was flowed off and then on
/
/   Input Parameters: NONE
/
/   Output Parameters: FALSE
/
/   Global Variables Changed: None
/
/   Users:
/
/   ----------------------------
/   -   Modificatons      -
/   ----------------------------
/
/   Author & Date:
/   Descrition:
/   Reason:
/
*************************************************************************/
ubyte fax_dte_flowed_on(void)
{
/*mrm8895*/
/*
compiler warning this function should return value
*/
#if 0
   ubyte temp;

   disable_int();
   temp = FAX_FLOWED_ON;
   FAX_FLOWED_ON = 0;
   enable_int();
   return(temp);
#endif
   return(0);
}

/************************************************************************
/
/            voice_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/23/94
/
/   Description:   This routine will initialize the DTE code for voice
/
/   Input Parameters:
/         ubyte - Baud Rate
/            0 = 300
/            1 = 1200
/            2 = 2400
/            3 = 4800
/            4 = 7200
/            5 = 9600
/            6 = 12000
/            7 = 14400
/            8 = 16800
/            9 = 19200
/           10 = 38400
/
/         ubyte - Terminal to modem flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = RTS
/             3 = Both XON/XOFF and RTS
/             5 = Transparent XON/XOFF
/
/         ubyte - Modem to terminal flow control
/             0 = Disabled
/             1 = XON/XOFF
/             2 = CTS
/             3 = Both XON/XOFF and CTS
/             5 = Transparent XON/XOFF
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
/  Author & Date: RSA 6/14/1995.
/  Description: Added the correct parmeters to this routine.
/  Reason: Compiler warnings?  Not correct.
/
*************************************************************************/
/* Start Change 6/14/1995. */
void voice_dte_init( ubyte in_baud_rate,
         ubyte in_dte_to_modem_flow_cntl,
         ubyte in_modem_to_dte_flow_cntl,
         uword XOFF_level, uword XON_level, uword FIFO_level)
{
   uword XOFF_l,XON_l,FIFO_l;

/* to supress compiler warnings */
   XOFF_l = XOFF_level;
   XON_l = XON_level;
   FIFO_l = FIFO_level;

   disable_int();
   dte_mode = T_VOICE;
#if 0
	if(vce_mode == 3)			  /* ramn 10/10/95 */
 	{
		line_io_enabled = TRUE;
	}
	else if(vce_mode == 2)
	{
		line_io_enabled = FALSE;
	}
#endif		/* ramn 2/15/96 */
		line_io_enabled = TRUE; /* ramn 2/15/96 */


/*mrm82096*/
/*changed to poll mode to prevent reboot*/

/*mrm83196*/
/* shujin 9/9/97, no timer3
  	install_poll_voice_dte_interrupt();
*/

   common_dte_init(in_baud_rate, in_dte_to_modem_flow_cntl, in_modem_to_dte_flow_cntl);



   enable_int();
}
/* End Change 6/14/1995. */

/************************************************************************
/
/            voice_dte_info
/
/   Author:    RSA (drc)
/
/   Creation Date: 12/23/94
/
/   Description:   This routine will setup a table with info on the DTE
/                  buffer for voice mode.
/
/   Input Parameters: (ubyte *) DTE buffer size
/                     (ubyte *) XOFF level
/                     (ubyte *) XON level
/
/   Output Parameters: None
/
/   Global Variables Changed: None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
/*mrm8895*/
/*
All the variables are defined to be a byte size which will results in
an overflow
*/
void voice_dte_info(uword *dte_buffer_size, uword *xoff_level,
uword *xon_level)
{
   *dte_buffer_size = OTHER_BUFFER_SIZE;
   *xoff_level = OTHER_NEAR_FULL;
   *xon_level = OTHER_NEAR_EMPTY;
}

/************************************************************************
/
/            common_dte_init
/
/   Author:    RSA (drc)
/
/   Creation Date:   12/23/94
/
/   Description:  This routine will initialize the DTE code for
/                 fax or voice
/
/   Input Parameters:
/         <<<<< VOICE >>>>>                         <<<<<< FAX >>>>>>
/         ubyte - Baud Rate                         ubyte - Baud Rate
/            0 = 300                                    0 = Reserved
/            1 = 1200                                   1 = Reserved
/            2 = 2400                                   2 = Reserved
/            3 = 4800                                   3 = Reserved
/            4 = 7200                                   4 = Reserved
/            5 = 9600                                   5 = Reserved
/            6 = 12000                                  6 = Reserved
/            7 = 14400                                  7 = Reserved
/            8 = 16800                                  8 = Reserved
/            9 = 19200                                  9 = Reserved
/           10 = 38400                                 10 = Reserved
/                                                      11 = 19200
/         ubyte - Terminal to modem flow control       12 = 38400
/             0 = Disabled
/             1 = XON/XOFF                          ubyte - Terminal to modem flow control
/             2 = RTS                                   0 = Disabled
/             3 = Both XON/XOFF and RTS                 1 = XON/XOFF
/             5 = Transparent XON/XOFF                  2 = CTS/RTS
/                                                       3 = Both XON/XOFF and CTS/RTS
/         ubyte - Modem to terminal flow control
/             0 = Disabled                          ubyte - Modem to terminal flow control
/             1 = XON/XOFF                              0 = Disabled
/             2 = CTS                                   1 = XON/XOFF
/             3 = Both XON/XOFF and CTS                 2 = CTS/RTS
/             5 = Transparent XON/XOFF                  3 = Both XON/XOFF and CTS/RTS
/
/   Output Parameters: None
/
/   Global Variables Changed:  All DTE variables are initialized
/
/   Users:
/
/   *************************************************************
/   *         Modifications                                     *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
*************************************************************************/
void common_dte_init(ubyte in_baud_rate, ubyte in_dte_to_modem_flow_cntl,
ubyte in_modem_to_dte_flow_cntl)
{
   /* S/W flow control chars */
   modem_to_dte_xoff_char = XOFF_CHAR;
   dte_to_modem_xoff_char = XOFF_CHAR;
   modem_to_dte_xon_char = XON_CHAR;
   dte_to_modem_xon_char = XON_CHAR;

   modem_to_dte_flow_cntl = in_modem_to_dte_flow_cntl;
   dte_to_modem_flow_cntl = in_dte_to_modem_flow_cntl;

   /* Init status vars */
   rx_suspended = FALSE;
   rx_suspend_pending = FALSE;
   rx_resume_pending = FALSE;
   dte_tx_interrupt_expected = FALSE;
   dte_tx_suspended_by_terminal= FALSE;
   tx_suspended_for_break = FALSE;

/* RJM 09/09/96 */
/* V80 support */
   /* initialize the XON/XOFF threshold values */
   if (dte_mode == DTE)
   {
/* 9/28/97 for zmodem uploading */
      dte_xoff_threshold = DTE_NEAR_FULL;
      dte_xon_threshold = DTE_NEAR_EMPTY;
   }
   else
   {
      dte_xoff_threshold = OTHER_NEAR_FULL;
      dte_xon_threshold = OTHER_NEAR_EMPTY;
   }
   dte_port_init();

/*
 * If h/w flow cntl is enabled, check RTS @ TIPU.   If RTS is down, then
 *  we're suspended by the terminal.
 */
   if (dte_to_modem_flow_cntl & RTS_AND_CTS)
/*mrm8895*/
#if 0
       if( !(UART_MCR & RTS) )
#endif
       if( !(modem_control_reg_rts()) )

         dte_tx_suspend();
}

/************************************************************************
/
/            dte_info
/
/   Author:    RSA (drc)
/
/   Creation Date: 12/21/94
/
/   Description:   This routine will setup a table with info on the DTE
/                  buffer for fax and voice data modes.
/
/   Input Parameters: (ubyte *) pointer to table
/
/   Output Parameters: None
/
/   Global Variables Changed: None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:   RSA
/   Description:
/
************************************************************************/
/* RJM 09/09/96 */
/* V80 support */
void dte_info(uword* buffer_size,uword* xoff_val,uword* xon_val,
              uword* xoff_min,uword* xoff_max,uword* xon_min,
              uword* xon_max,uword* buffer_count)
{
   if (dte_mode == DTE)
      *buffer_size = DTE_BUFFER_SIZE;
   else
      *buffer_size = OTHER_BUFFER_SIZE;

   *xoff_val = dte_xoff_threshold;
   *xon_val = dte_xon_threshold;
   *xoff_min = DTE_XOFF_MIN;
   *xoff_max = DTE_XOFF_MAX;
   *xon_min = DTE_XON_MIN;
   *xon_max = DTE_XON_MAX;
   *buffer_count = dte_rx_count;
}

/* stubbed routines */


/* ramn 4/17/96 */
void dte_reconfigure( ubyte in_baud_rate,
			ubyte in_data_bits,
			ubyte in_stop_bits,
			ubyte in_parity,
			ubyte in_term_to_modem_flow_cntl,
			ubyte in_term_to_modem_xon,
			ubyte in_term_to_modem_xoff,
			ubyte in_modem_to_term_flow_cntl,
			ubyte in_modem_to_term_xon,
			ubyte in_modem_to_term_xoff,
			ubyte in_pass_through_flow_cntl,
			ubyte in_esc_char,
			ubyte in_esc_guard_time,
			ubyte in_esc_mode)
{

	dte_guard_time = esc_guard_time = in_esc_guard_time;
	esc_chr = in_esc_char;
   dte_20_mSec_timer = 2;
   dte_tesc_count = 0;
   dte_lead_guard = FALSE;

	flow_cntl_pass = in_pass_through_flow_cntl;
	modem_to_dte_xoff_char = in_modem_to_term_xoff;
	modem_to_dte_xon_char = in_modem_to_term_xon;
	modem_to_dte_flow_cntl = in_modem_to_term_flow_cntl;

	dte_to_modem_xoff_char = in_term_to_modem_xoff;
	dte_to_modem_xon_char = in_term_to_modem_xon;
	dte_to_modem_flow_cntl = in_term_to_modem_flow_cntl;

/* RJM 09/09/96 */
/* V80 support */
   /* initialize the XON/XOFF threshold values */
   if (dte_mode)
   {
/* 9/28/97 for zmodem uploading */
       dte_xoff_threshold = DTE_NEAR_FULL;
       dte_xon_threshold = DTE_NEAR_EMPTY;
   }
   else
   {
       dte_xoff_threshold = OTHER_NEAR_FULL;
       dte_xon_threshold = OTHER_NEAR_EMPTY;
   }
}


#if 0	/* ramn 4/9/96 */
void dte_reconfigure(ubyte a, ubyte b, ubyte c,\
         ubyte d, ubyte e, ubyte f,\
         ubyte g, ubyte h, ubyte i,\
         ubyte j, ubyte k, ubyte l,\
         ubyte m, ubyte n)
{
   a = b = c = d = e = f = g = h = i = j = k = l = m = n;
}
#endif




void dte_falling_back_to_speed (void)
{
}

void dte_end_falling_back_to_speed (void)
{
}

void dte_reset(void)
{
}

void dte_dest_break_clear(void)
{
}
