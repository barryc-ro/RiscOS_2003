/**************************************************************************
/
/                                 "routines for 56k modem "
/
/
/        CIRRUS LOGIC Inc
/        3100 West Warren Ave
/        Fremont, CA. 94538
/        (510) 623-8300
/
/
/    This document contains material confidential to CIRRUS LOGIC its
/    contents must not be revealed, used or disclosed to anyone or
/    company with out written permission by CIRRUS LOGIC.
/    The information contained herein is solely for the use of CIRRUS LOGIC.
/
/
/    Creation Date: 01/29/97
/
/    Description:
/
/
/
/
/
/
/
/    Input Parameters:  none
/
/
/
/    Output Parameter:
/
/
/    Global Variables Changed:
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/


#include "sys_def.h"
#include "mt_pro.h"
#include "cp_dsp.h"
#include "mt_macro.h" /* ramn 4/22/96 */
#include "mt_codef.h" /* ramn 4/22/96 */
#include "mod_def.h" /* jlin 01/31/97 */
#include "io\dte_drv.h" /* jlin 01/31/97 */
#include "mdm_56k.h" /* jlin 08/21/97 */
#include "bldflags.h"

extern ubyte pt[];
extern ubyte dsp_response_data[15]; /* ramn 4/18/96 */
extern ubyte dsp_cp_packet;
extern void  send_pkt_to_dsp(void);
extern uword dsp_peek(uword addr);
extern void dsp_poke(uword, uword);

#if 1
void dsp_poke2 (uword data, uword addr, uword mcon_16);
uword dsp_peek2(uword addr, uword mcon_16);
#endif

ubyte dsp_ext_mem32k_test(uword dmy_mem_bank, uword dmy_WhatRange_Mapped_to_Which_Chip_Select);
ubyte dnld_bootx_code(const uword dmy_bootx_array[]);

#if DNLD_X2_FROM_HOST == 0
 ubyte fillup_dsp_32K_extram(const uword dmy_32k_array[], uword dmy_mem_bank, uword);
#endif

ubyte fillup_dsp_32K_extram_2(const uword dmy_32k_array[], uword dmy_mem_bank, uword);

#if (PATCHLESS_EXTERNAL == 1)
 ubyte RSA_fillup_1(const uword dmy_32k_array[], uword dmy_WhatRange_Mapped_to_Which_Chip_Select);
#endif

ubyte Check_For_55_AA_Token(ubyte dmy_token);
ubyte Change_PLL_Freqency(ubyte dmy_value);
//ubyte hlsr_bit6_value(void);
void loop_on_no_OK_semaphore(void);
void WriteDSP_MemThruBootx(uword addr_tmp1, uword data_tmp1);
uword ReadDSP_MemThruBootx(uword addr_tmp1);

#if DNLD_X2_FROM_HOST == 0
 void CheckAndDownload32k_DSP_SRAM();
#endif

extern void wait_a_while(void);
extern ubyte dial_timer;

extern ubyte ext_DspMemErrorFlag;
extern const uword bootx_array[];
extern const uword x2_page_array[];
extern ubyte *d_to_a(ubyte);

extern void wait_a_while(void);

#if DNLD_X2_FROM_HOST == 0
 void BootUpDsp1();
#endif

//void double_check_a(void);

void modem_get_pcm_info();
void symbol_rate(ubyte rate,ubyte tx_rx);
extern void  output_info(ubyte *,ubyte);

#if 1
/*******************************************************************************
/
/    Routine: dsp_peek2
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This Routine is called to peek DSP internal registers or
/                  external memory.
/                  mcon_16 value has to be set correctly!!
/
/    Input Parameters: uword addr, uword mcon_16
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
uword dsp_peek2(uword addr, uword mcon_16)
{
 ubyte mcon_lo;
 ubyte mcon_hi;
 ubyte pram_addr_lo;
 ubyte pram_addr_hi;
 uword data_byte;

            mcon_lo = 0x00ff & mcon_16;
            mcon_hi = 0x00ff & (mcon_16 >> 8);
            pram_addr_lo = addr & 0x00FF;
            pram_addr_hi = (addr >> 8) & 0x00FF;

             LOAD_DSP_PROGRAM_MEMORY_READ

            dsp_cp_packet = PACKET_PROGRAM_MEM_READBACK;
           ack_or_response = RESPONSE;
           send_pkt_to_dsp();

            data_byte = (dsp_response_data[1] << 8);   /* was dsp_response_data[6] */
            data_byte |= dsp_response_data[0];         /* was dsp_response_data[7] */

    /*        data_byte = (data_byte | 8000);  jlin 01/21/97 */

         return(data_byte);

}

#endif


#if 1
/*******************************************************************************
/
/    Routine: dsp_poke2
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This Routine is called to poke DSP internal registers or
/                  external memory.
/                  mcon_16 value has to be set correctly!!
/
/    Input Parameters: uword data, uword addr, uword mcon_16
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
void dsp_poke2(uword data, uword addr, uword mcon_16)
{
   ubyte mcon_lo;
   ubyte mcon_hi;
    ubyte *temp;

    mcon_lo = 0x00ff & mcon_16;
    mcon_hi = 0x00ff & (mcon_16 >> 8);
    current_command [0] = PACKET_DSP_PROGRAM_MEMORY_WRITE;
    current_command [1] = 0x00;
   current_command [2] = PACKET_DSP_PROGRAM_MEMORY_WRITE_LEN;
   current_command [3] = 0x00;
   current_command [4] = addr;
   current_command [5] = addr>>8;
   current_command [6] = mcon_lo;
   current_command [7] = mcon_hi;
   current_command [8] = data;
   current_command [9] = data>>8;

     temp = (ubyte *)(COM_RAM);
    *temp = 0x0c0;

   ack_or_response = ACK;
   send_pkt_to_dsp();

}
#endif

/*******************************************************************************
/
/    Routine: dsp_ext_mem32k_test(uword dmy_mem_bank, uword dmy_WhatRange_Mapped_to_Which_Chip_Select)
/
/    Author : CIRRUS
/
/    Creation Date: 01/24/97
/
/    Description : This Routine is called to test DSP
/                  external memory.
/
/    Input Parameters: none
/
/    Output Parameters: none
/
/    Global Variables Changed:  ext_dsp_mem_error
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
ubyte dsp_ext_mem32k_test(uword dmy_mem_bank, uword dmy_WhatRange_Mapped_to_Which_Chip_Select)
{
   ulong length;
   ulong addr_tmp1;
   uword data_tmp1;
   uword data_tmp2;
   uword data_tmp3;
   ubyte bank_hi, bank_lo;
   ubyte *temp;
   ubyte dmy_32k_mem_err_flag1;
   ubyte jj32k_ii;
   uword stuck_count1;
   ulong addr_tmp1_old;
   uword data_tmp2_old;
   ubyte continue_flag;


   dmy_32k_mem_err_flag1 = 0x00;
   temp    = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);

   bank_lo = 0x00;
   bank_hi = 0x00;
   *PORT_e8_bank_adrs_lo = bank_lo;
   *PORT_e9_bank_adrs_hi = bank_hi;

   data_tmp2 = ReadDSP_MemThruBootx(CCON_REG);
/*   data_tmp2 = B3CF_MappedTo_CS3; */
   data_tmp2 = dmy_WhatRange_Mapped_to_Which_Chip_Select;

/* map Bank 3 of DSP external program memory to CS3 */
   WriteDSP_MemThruBootx(CCON_REG, data_tmp2);
   data_tmp1 = ReadDSP_MemThruBootx(CCON_REG);
   if (data_tmp1 != data_tmp2)
   {
      dmy_32k_mem_err_flag1 = DSP_REG_WR_RD_ERROR;
      return(dmy_32k_mem_err_flag1);
   }


   Change_PLL_Freqency(PLL_30MHz);  /* select 30.04 MHz */

/*    set the CCON value to map EPGM_CS3_N to 30000-37fff, bank 6  */
/*   the addr of ccon is 0012h. */
   length  = CONST_64K;

/* program bank bits for 30000-37fff, set mcon[7-5] to 110 */





   bank_lo = (dmy_mem_bank & 0x00ff);
   bank_hi = (dmy_mem_bank & 0xff00) >> 8;
   *PORT_e8_bank_adrs_lo = bank_lo;
   *PORT_e9_bank_adrs_hi = bank_hi;


/* write_1 all data patterns */
   data_tmp1 = 0;
   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
     WriteDSP_MemThruBootx(addr_tmp1, data_tmp1);
     data_tmp1++;
   }

/* read_1 back all data patterns */
#if 0
//   data_tmp1 = 0;
//   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
//   {
//     data_tmp2 = ReadDSP_MemThruBootx(addr_tmp1);
//
//     if(data_tmp1 != data_tmp2)
//     {
//      dmy_32k_mem_err_flag1 |= DSP_32K_MEM_WR_RD_ERROR;
   /*   while(1); */
//      break;
//     }
//     data_tmp1++;

//   }
#endif


/* read_1 back all data patterns */
   addr_tmp1_old = 0x500;
   for(addr_tmp1 = 0; addr_tmp1 < addr_tmp1_old; addr_tmp1++)
      wait_a_while();

   data_tmp1 = 0;
   addr_tmp1_old = 0;
   data_tmp2_old = 0;
   stuck_count1 = 0;

   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
     data_tmp2 = ReadDSP_MemThruBootx(addr_tmp1);

     if(data_tmp1 != data_tmp2)
     {
        dmy_32k_mem_err_flag1 |= READ_BACK_ALL_FFFF;
        return(dmy_32k_mem_err_flag1);
     }
     data_tmp1++;
     if(addr_tmp1 == CONST_32K)
       data_tmp2_old = data_tmp2;

   }

   if(dmy_32k_mem_err_flag1 != 0) return(dmy_32k_mem_err_flag1);


/* write_2 all data patterns */
   data_tmp1 = 0;
   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
     data_tmp3 = CONST_64K - data_tmp1 - 1;
     WriteDSP_MemThruBootx(addr_tmp1, data_tmp3);
     data_tmp1++;
   }

/* read_2 back all data patterns */
   data_tmp1 = 0;
   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
     data_tmp3 = CONST_64K - data_tmp1 - 1;
     data_tmp2 = ReadDSP_MemThruBootx(addr_tmp1);

     if(data_tmp3 != data_tmp2)
     {
      dmy_32k_mem_err_flag1 |= DSP_32K_MEM_WR_RD_ERROR1;
   /*   while(1); */
      return(dmy_32k_mem_err_flag1);
     }
     data_tmp1++;
   }


   Change_PLL_Freqency(PLL_34MHz); /* select 30.04 MHz */
   return(dmy_32k_mem_err_flag1);





#if 0
//   ulong ii_32k;
//   uword data_tmp1;  /* jlin 01/20/97 */
//   uword data_tmp2;  /* jlin 01/20/97 */
//   uword data_tmp3;  /* jlin 01/20/97 */
//   uword dmy_error_count;
//   uword addr_tmp1;


/*    set the CCON value to map EPGM_CS3_N to 30000-37fff, bank 6  */
/*   the addr of ccon is 0012h. */
//   addr_tmp1 = 0x0012;
//   data_tmp1 = dsp_peek(addr_tmp1);
//   data_tmp1 = data_tmp1 | 0x0300;     /* set ccon bit[9,8] to 11 */
//    dsp_poke(data_tmp1, addr_tmp1);

/* program bank bits for 30000-37fff, set mcon[7-5] to 110 */


//   data_tmp1 = 0;
//   dmy_error_count = 0;
/* banking window 8000Hex -- FFFFhex */
//   for(ii_32k=CONST_32K; ii_32k<CONST_64K ; ii_32k+=1)
//   {
//      dsp_poke2(data_tmp1, ii_32k, 0x1fc0);
//     data_tmp2 = dsp_peek2(ii_32k, 0x1fc0);
//     if ( data_tmp1 !=  data_tmp2 )
//     {
//       dmy_error_count = 1;
//       break;
//     }
//     data_tmp3 = CONST_64K - data_tmp1 - 1;

//      dsp_poke2(data_tmp3, ii_32k, 0x1fc0);
//     data_tmp2 = dsp_peek2(ii_32k, 0x1fc0);
//     if ( data_tmp3 !=  data_tmp2 )
//     {
//       dmy_error_count = 1;
//       break;
//     }
//
//     data_tmp1++;
//   }
//   return(dmy_error_count);
#endif

}


/* copy a piece of code to DSP address  0 0800hex  */
/*******************************************************************************
/
/    Routine: dnld_bootx_code(const uword dmy_bootx_array[])
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This routine copies a piece of assembly code to 2.5K
/                  bank0 DSP internal RAM and reset and boot up from 0800h.
/
/
/    Input Parameters: const uword dmy_program_array[]
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
ubyte  dnld_bootx_code(const uword dmy_bootx_array[])
{
        uword length,count,address,data,add,data_byte ;
      uword data_tmp2;
        ubyte *temp;
      ubyte *temp_f8;
      ubyte *temp_f9;
      ubyte *temp_fa;
      ubyte db_hi, db_lo, add_hi, add_lo;
      ubyte bootx_download_status1;


       temp_f8 = (ubyte *)(COM_RAM + UPLD_DNLD_REGIS_F8     );
       temp_f9 = (ubyte *)(COM_RAM + UPLD_DNLD_REGIS_F9     );
       temp_fa = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);
       temp    = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);

      bootx_download_status1 = 0;
        address = LOCATION_OF_ADDRS1;
        data = LOCATION_OF_DATA1;
        length  = dmy_bootx_array [LOCATION_OF_LENGTH1];


 /* boot up from 08000h, tri-state DSP prog mem bus, assert reset */



      *temp = CP_DNLD_ENABLE_FLAG;  /* 0x0A */

       add = dmy_bootx_array [address];
      add_lo = add & 0x00ff;
      add_hi = (add >> 8) & 0x00ff;

      *temp_f9 = add_hi;
      *temp_f8 = add_lo;

        for (count = 0; count < length; count++)
        {
            data_byte = dmy_bootx_array [data];

         db_lo     = data_byte & 0x00ff;
         db_hi     = (data_byte >> 8) & 0x00ff;

         *DATA_PORT_FA = db_lo;
         *DATA_PORT_FA = db_hi;

            data +=1;

        }

      data = LOCATION_OF_DATA1;

      *temp_f8 = add_lo;
      *temp_f9 = add_hi;

        for (count = 0; count < length; count++)
        {
            data_byte = dmy_bootx_array [data];

         db_lo     =        *DATA_PORT_FA ;
         db_hi     =        *DATA_PORT_FA ;
         data_tmp2 = (db_hi << 8) | db_lo ;
         if (data_tmp2 != data_byte)
         {
          bootx_download_status1 = BOOTX_DOWNLOAD_ERROR;
    /*      while(1);  */
          break;
         }

            data +=1;
        }

       *temp = CP_RESET_AND_RUN_BOOT_CODE;   /* 0x09 */
      return(bootx_download_status1);
}

/* download 56k-modem code to dsp */
/*******************************************************************************
/
/    Routine: fillup_dsp_32K_extram(dmy_32k_array);
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This routine downloads DSP code into 32K Ram
/
/
/
/    Input Parameters: const uword dmy_program_array[]
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
#if DNLD_X2_FROM_HOST == 0
ubyte fillup_dsp_32K_extram(const uword dmy_32k_array[],
                           uword dmy_mem_bank,
                           uword dmy_WhatRange_Mapped_to_Which_Chip_Select)
{
     ulong length;
    uword address, data_ptr1;
    ulong addr_tmp1;
    uword data_tmp1;
    uword data_tmp2;
    ubyte bank_hi, bank_lo;
    ubyte *temp;
    ubyte dmy_32k_mem_err_flag2;
     uword i;

#if 0
//    ubyte db_hi, db_lo, add_hi, add_lo;
//    ubyte *temp_e8_bank_adrs_lo;
//    ubyte *temp_e9_bank_adrs_hi;
//    ubyte *temp_ea_addr_lo;
//    ubyte *temp_eb_addr_hi;
//    ubyte *temp_ec_data_lo;
//    ubyte *temp_ed_data_hi;
//    ubyte *temp_ee_semph_adr_lo;
//    ubyte *temp_ef_semph_adr_hi;
#endif


    dmy_32k_mem_err_flag2 = 0x00;
    temp    = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);

#if 0
//    temp_e8_bank_adrs_lo = (ubyte *)(COM_RAM + BOOTX_BANK_ADRS_LO);
//    temp_e9_bank_adrs_hi = (ubyte *)(COM_RAM + BOOTX_BANK_ADRS_HI);
//    temp_ea_addr_lo = (ubyte *)(COM_RAM + BOOTX_ADRS_LO);
//    temp_eb_addr_hi = (ubyte *)(COM_RAM + BOOTX_ADRS_HI);
//    temp_ec_data_lo = (ubyte *)(COM_RAM + BOOTX_DATA_LO);
//    temp_ed_data_hi = (ubyte *)(COM_RAM + BOOTX_DATA_HI);
//    temp_ee_semph_adr_lo = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_LO);
//    temp_ef_semph_adr_hi = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_HI);
#endif



   bank_lo = 0x00;
   bank_hi = 0x00;
   *PORT_e8_bank_adrs_lo = bank_lo;
   *PORT_e9_bank_adrs_hi = bank_hi;

   data_tmp2 = ReadDSP_MemThruBootx(CCON_REG);

  /*  data_tmp2 = B3CF_MappedTo_CS3;  */
   data_tmp2 = dmy_WhatRange_Mapped_to_Which_Chip_Select;

   WriteDSP_MemThruBootx(CCON_REG, data_tmp2);
   data_tmp1 = ReadDSP_MemThruBootx(CCON_REG);
   if (data_tmp1 != data_tmp2)
   {
      dmy_32k_mem_err_flag2 = DSP_REG_WR_RD_ERROR;
   }





    Change_PLL_Freqency(PLL_30MHz);  /* select 30.04 MHz */

/*    set the CCON value to map EPGM_CS3_N to 30000-37fff, bank 6  */
/*   the addr of ccon is 0012h. */


     data_ptr1 = LOCATION_OF_DATA1;
     length  = dmy_32k_array[LOCATION_OF_LENGTH1] + CONST_32K;

/* program bank bits for 30000-37fff, set mcon[7-5] to 110 */





   data_tmp1 = 0;

   bank_lo = (dmy_mem_bank & 0x00ff);
   bank_hi = (dmy_mem_bank & 0xff00) >> 8;
   *PORT_e8_bank_adrs_lo = bank_lo;
   *PORT_e9_bank_adrs_hi = bank_hi;

   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
      data_tmp1 = dmy_32k_array [data_ptr1++];

#if 0  /* -------------------------------------------- */
//     add_lo = (addr_tmp1 & 0x00ff);
//     add_hi = (addr_tmp1 & 0xff00) >> 8;
//     db_lo = (data_tmp1 & 0x00ff);
//     db_hi = (data_tmp1 & 0xff00) >> 8;

//     *temp_eb_addr_hi = add_hi;
//     *temp_ea_addr_lo = add_lo;
//     *temp_ec_data_lo = db_lo;
//     *temp_ed_data_hi = db_hi;
//     *temp_ef_semph_adr_hi = WRITE_SEMAPHORE_HI;
//     *temp_ee_semph_adr_lo = WRITE_SEMAPHORE_LO;

//     loop_on_no_OK_semaphore();
//     loop_on_no_OK_semaphore();
#endif /* -------------------------------------------- */

     WriteDSP_MemThruBootx(addr_tmp1, data_tmp1);
   }

   data_ptr1 = LOCATION_OF_DATA1;
/* read back and compare */
   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
      data_tmp1 = dmy_32k_array [data_ptr1++];

#if 0  /* -------------------------------------------- */
//     add_lo = (addr_tmp1 & 0x00ff);
//     add_hi = (addr_tmp1 & 0xff00) >> 8;

//     *temp_eb_addr_hi = add_hi;
//     *temp_ea_addr_lo = add_lo;
//     *temp_ee_semph_adr_lo =READ_SEMAPHORE_LO;
//     *temp_ef_semph_adr_hi =READ_SEMAPHORE_HI;

//     loop_on_no_OK_semaphore();
//     loop_on_no_OK_semaphore();

//     db_hi = *temp_ed_data_hi;
//     db_lo = *temp_ec_data_lo;
//     data_tmp2 = (db_hi << 8) | db_lo;
#endif /* -------------------------------------------- */

     data_tmp2 = ReadDSP_MemThruBootx(addr_tmp1);

     if(data_tmp1 != data_tmp2)
     {
      dmy_32k_mem_err_flag2 |= DSP_32K_MEM_WR_RD_ERROR2;
      addr_tmp1 = length;
      break;
     }

   }

   for (addr_tmp1 = length; addr_tmp1 < CONST_64K; addr_tmp1++)
   {
   /* fill the unused area with 0x0000 */
     WriteDSP_MemThruBootx(addr_tmp1, TWO_BYTE_ZERO);
   }




   bank_lo = 0x00;
   bank_hi = 0x00;
   *PORT_e8_bank_adrs_lo = bank_lo;
   *PORT_e9_bank_adrs_hi = bank_hi;

   data_tmp2 = ReadDSP_MemThruBootx(WCON_REG);

   data_tmp2 &= 0x000f;  /* clear upper 12 bits */
   data_tmp2 |= DSP_ONE_W_STATE_FOR_8000_FFFF;
/* set one wait state for  8000-ffff */
   WriteDSP_MemThruBootx(WCON_REG, data_tmp2);

   data_tmp1 = ReadDSP_MemThruBootx(WCON_REG);

/*   Change_PLL_Freqency(PLL_34MHz); */ /* select 30.04 MHz */


   *temp = RESET_DSP_AND_BOOT_FROM_FFFF; /* 0x00 */
    for(i=0;i< 0x100;i++)
     wait_a_while();
   *temp = KILL_DSP_RES_N;   /* 0x01 */
    for(i=0;i< 0xffff;i++)
     wait_a_while();


   Change_PLL_Freqency(PLL_30MHz);  /* select 30.04 MHz */


   dsp_poke(DSP_ONE_W_STATE_FOR_8000_FFFF, WCON_REG);  /* 0x2490 */


#if (PATCHLESS_EXTERNAL == 1)
   dsp_poke(0x8007, BCON_REG);
#else 
   dsp_poke(0x8000, BCON_REG);
#endif


/*   dsp_poke(B5CF_MappedTo_CS3, CCON_REG);  taken out for demo */ /* 0x00C0 */


   return(dmy_32k_mem_err_flag2);

}
#endif



/*******************************************************************************
/
/    Routine:Check_For_55_AA_Token
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This routine writes 0x55 to address 0x90000 and DSP should
/                  respond, only to 0x55 pattern, by writing back 0xAA.
/                  Thus Musket knows that DSP is running as expected.
/
/
/    Input Parameters: const uword dmy_program_array[]
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
ubyte Check_For_55_AA_Token(ubyte dmy_token)
{
        ubyte *temp;
      ubyte Flag_55_Came_In;
      ubyte Flag_AA_Received;
      ulong temp_count1;
      ulong temp_kk;
      ubyte dmy_temp;

      temp_count1 = 0xffff;
      Flag_55_Came_In = 0;
      Flag_AA_Received =0;

      if (dmy_token == 0x55){ Flag_55_Came_In = 1;}
       temp    = (ubyte *)(COM_RAM);
      *temp = dmy_token;

      if ( Flag_55_Came_In == 1)
      {
       for(temp_kk = temp_count1; temp_kk > 0; temp_kk--)
        {
            process_wait();

          dmy_temp = *temp;
          if (dmy_temp == 0xAA)
          {
            Flag_AA_Received = 1;
            break;
          }

        }
      }

  /*     return(Flag_AA_Received); */
      return(dmy_temp);


}



/*******************************************************************************
/
/    Routine:Change_PLL_Freqency(ubyte dmy_value)
/
/    Author : CIRRUS
/
/    Creation Date: 01/30/97
/
/    Description : Change PLL frequency to dm_value.
/                  Appropriate steps have to be followed.
/                  Return old freq valuee.
/
/
/    Input Parameters: dmy_valuee
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
ubyte Change_PLL_Freqency(ubyte dmy_value)
{
      ubyte *temp_cp_control_reg;
      ubyte *temp_PLL_freq_sel;
      ubyte temp_hold1;
      ubyte temp_hold2;
      ubyte old_freq_value;
      ubyte i;


       temp_cp_control_reg = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER );

      temp_PLL_freq_sel   = (ubyte *)(COM_RAM + PLL_FREQ_SEL_REG );



      temp_hold1 = 100;

      temp_hold2 = *CLK_SEL_STAT_PORT;
      temp_hold2 |= 0x01; /* select 23.4 MHz clock */
      *CLK_SEL_STAT_PORT = temp_hold2;

      old_freq_value = *temp_PLL_freq_sel; /* save old value */
      *temp_PLL_freq_sel = dmy_value; /* put in new value */

      for(i=0; i<temp_hold1; i++)
      {
            process_wait();
      /* delay 100ms for PLL output to stabilize */

      }

      temp_hold2 = *CLK_SEL_STAT_PORT;
      temp_hold2 &= 0xfe; /* switch back to PLL clock */
      *CLK_SEL_STAT_PORT = temp_hold2;

      return(old_freq_value);

}


/************************************************************************
/
/   Routine: hlsr_bit6_value(void)
/
/   Author: CRUS
/
/   Creation Date:
/
/   Description:
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/
#if 0
//ubyte hlsr_bit6_value(void)
//{
//    ubyte *temp,xmit_empty_bit;
//
//    temp = (ubyte *)(PARALLEL_16550_LOCATION + HLSR);
//    xmit_empty_bit = *temp;

/* bit6 1 means both xmit shift reg and xmit holding reg are both empty */
//    xmit_empty_bit &= 0x40;

//   return(xmit_empty_bit);

//}

#endif

/************************************************************************
/
/   Routine: loop_on_no_OK_semaphore
/
/   Author: CRUS
/
/   Creation Date:
/
/   Description:
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/
void loop_on_no_OK_semaphore(void)
{
  ubyte flag_tmp_hi, flag_tmp_lo;

#if 0
//  ubyte *temp_ee_semph_adr_lo;
//  ubyte *temp_ef_semph_adr_hi;
//
//  temp_ee_semph_adr_lo = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_LO);
//  temp_ef_semph_adr_hi = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_HI);
#endif

  while(1)
  {
    flag_tmp_hi =  *PORT_ef_semph_adr_hi;
    flag_tmp_lo =  *PORT_ee_semph_adr_lo;

    if((flag_tmp_lo == OK_SEMAPHORE_LO) && (flag_tmp_hi == OK_SEMAPHORE_HI))
    {
      break;
    }
  }

}



/************************************************************************
/
/   Routine: WriteDSP_MemThruBootx
/
/   Author: CRUS
/
/   Creation Date:
/
/   Description:
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/
void WriteDSP_MemThruBootx(uword addr_tmp1, uword data_tmp1)
{
    ubyte db_hi, db_lo, add_hi, add_lo;

#if 0
//    ubyte *temp_ea_addr_lo;
//    ubyte *temp_eb_addr_hi;
//    ubyte *temp_ec_data_lo;
//    ubyte *temp_ed_data_hi;
//    ubyte *temp_ee_semph_adr_lo;
//    ubyte *temp_ef_semph_adr_hi;


//    temp_ea_addr_lo = (ubyte *)(COM_RAM + BOOTX_ADRS_LO);
//    temp_eb_addr_hi = (ubyte *)(COM_RAM + BOOTX_ADRS_HI);
//    temp_ec_data_lo = (ubyte *)(COM_RAM + BOOTX_DATA_LO);
//    temp_ed_data_hi = (ubyte *)(COM_RAM + BOOTX_DATA_HI);
//    temp_ee_semph_adr_lo = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_LO);
//    temp_ef_semph_adr_hi = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_HI);
#endif

    add_lo = (addr_tmp1 & 0x00ff);
    add_hi = (addr_tmp1 & 0xff00) >> 8;
    db_lo = (data_tmp1 & 0x00ff);
    db_hi = (data_tmp1 & 0xff00) >> 8;

    *PORT_eb_addr_hi = add_hi;
    *PORT_ea_addr_lo = add_lo;
    *PORT_ec_data_lo = db_lo;
    *PORT_ed_data_hi = db_hi;
    *PORT_ef_semph_adr_hi = WRITE_SEMAPHORE_HI;
    *PORT_ee_semph_adr_lo = WRITE_SEMAPHORE_LO;

    loop_on_no_OK_semaphore();
    loop_on_no_OK_semaphore();

}


/************************************************************************
/
/   Routine: ReadDSP_MemThruBootx
/
/   Author: CRUS
/
/   Creation Date:
/
/   Description:
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/
uword ReadDSP_MemThruBootx(uword addr_tmp1)
{
    ubyte db_hi, db_lo, add_hi, add_lo;
    uword dmy_data_tmp2;

#if 0
//    ubyte *temp_ea_addr_lo;
//    ubyte *temp_eb_addr_hi;
//    ubyte *temp_ec_data_lo;
//    ubyte *temp_ed_data_hi;
//    ubyte *temp_ee_semph_adr_lo;
//    ubyte *temp_ef_semph_adr_hi;

//    temp_ea_addr_lo = (ubyte *)(COM_RAM + BOOTX_ADRS_LO);
//    temp_eb_addr_hi = (ubyte *)(COM_RAM + BOOTX_ADRS_HI);
//    temp_ec_data_lo = (ubyte *)(COM_RAM + BOOTX_DATA_LO);
//    temp_ed_data_hi = (ubyte *)(COM_RAM + BOOTX_DATA_HI);
//    temp_ee_semph_adr_lo = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_LO);
//    temp_ef_semph_adr_hi = (ubyte *)(COM_RAM + BOOTX_SEMAPHORE_ADRS_HI);
#endif

    add_lo = (addr_tmp1 & 0x00ff);
    add_hi = (addr_tmp1 & 0xff00) >> 8;

    *PORT_eb_addr_hi = add_hi;
    *PORT_ea_addr_lo = add_lo;
    *PORT_ee_semph_adr_lo =READ_SEMAPHORE_LO;
    *PORT_ef_semph_adr_hi =READ_SEMAPHORE_HI;

    loop_on_no_OK_semaphore();
    loop_on_no_OK_semaphore();

    db_hi = *PORT_ed_data_hi;
    db_lo = *PORT_ec_data_lo;
    dmy_data_tmp2 = (db_hi << 8) | db_lo;

    return(dmy_data_tmp2);
}


/************************************************************************
/
/   Routine: CheckAndDownload32k_DSP_SRAM()
/
/   Author: CRUS
/
/   Creation Date:
/
/   Description:
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/
#if DNLD_X2_FROM_HOST == 0
void CheckAndDownload32k_DSP_SRAM()
{

  uword dmy_bank_num1;

  dmy_bank_num1 = x2_page_array[LOCATION_OF_BANK_NO_2];
  ext_DspMemErrorFlag  = 0;

  dsp_cfg(ON);
  ext_DspMemErrorFlag  = dnld_bootx_code(bootx_array);

  if(ext_DspMemErrorFlag != 0) return;
  ext_DspMemErrorFlag |= dsp_ext_mem32k_test(dmy_bank_num1, B5CF_MappedTo_CS3);

  if(ext_DspMemErrorFlag != 0)
  {
   BootUpDsp1();
   return;
  }
  ext_DspMemErrorFlag |= fillup_dsp_32K_extram(x2_page_array, dmy_bank_num1, B5CF_MappedTo_CS3 );

}
#endif

/************************************************************************
/
/   Routine: BootUpDsp1()
/
/   Author: CRUS
/
/   Creation Date:
/
/   Description:
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   *************************************************************
/   *         Modifications             *
/   *************************************************************
/
/   Author & Date:
/   Description:
/
************************************************************************/
#if DNLD_X2_FROM_HOST == 0
void BootUpDsp1()
{
   ubyte bank_hi, bank_lo;
   ubyte *temp;
   uword data_tmp2;
   uword data_tmp1;


   temp    = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);
   bank_lo = 0x00;
   bank_hi = 0x00;
   *PORT_e8_bank_adrs_lo = bank_lo;
   *PORT_e9_bank_adrs_hi = bank_hi;

   data_tmp2 = ReadDSP_MemThruBootx(WCON_REG);

   data_tmp2 &= 0x000f;  /* clear upper 12 bits */
   data_tmp2 |= DSP_ONE_W_STATE_FOR_8000_FFFF;
/* set one wait state for  8000-ffff */
   WriteDSP_MemThruBootx(WCON_REG, data_tmp2);

   data_tmp1 = ReadDSP_MemThruBootx(WCON_REG);

   Change_PLL_Freqency(PLL_34MHz);  /* select 30.04 MHz */

   *temp = RESET_DSP_AND_BOOT_FROM_FFFF; /* 0x00 */


   *temp = KILL_DSP_RES_N;   /* 0x01 */


}
#endif





//void double_check_a(void)
//{
// uword data_tmp1;
// uword data_tmp2;
// uword addr_tmp1;
// ulong ii_32k;
// uword tmp_mcon1;

/* ---------------------------------------- */

/*    set the CCON value to map EPGM_CS3_N to 18000-1ffff, bank 3  */
/*   the addr of ccon is 0012h. */

//   addr_tmp1 = CCON_REG;
//   data_tmp1 = dsp_peek(addr_tmp1);
//   data_tmp1 = B5CF_MappedTo_CS3;     /* set ccon bit[5,4] to 11 */
//    dsp_poke(data_tmp1, addr_tmp1);


/*     tmp_mcon1 = 0x1f80; */       /* bank 4 */
//     tmp_mcon1 = 0x1f60;          /* bank 3 */
/*     tmp_mcon1 = 0x1fc0; */       /* bank 6 */

//     ii_32k = 0x8002;
//     data_tmp1 =  0x0022;
/*      dsp_poke2(data_tmp1, ii_32k, tmp_mcon1); */

//     data_tmp2 = dsp_peek2(ii_32k, tmp_mcon1);
//     if ( data_tmp1 !=  data_tmp2 )
//     {
//      while(1);
//     }

//     ii_32k = 0x8001;
//     data_tmp1 =  0x0011;
/*      dsp_poke2(data_tmp1, ii_32k, tmp_mcon1); */

//     data_tmp2 = dsp_peek2(ii_32k, tmp_mcon1);
//     if ( data_tmp1 !=  data_tmp2 )
//     {
//      while(1);
//     }

/* ---------------------------------------- */

//}







/* Use peek/poke to download x2_page_array to dsp */
/*******************************************************************************
/
/    Routine: fillup_dsp_32K_extram_2(dmy_32k_array);
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This routine downloads DSP code into 32K Ram
/
/
/
/    Input Parameters: const uword dmy_program_array[]
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/

ubyte fillup_dsp_32K_extram_2(const uword dmy_32k_array[],
                           uword dmy_mem_bank,
                           uword dmy_WhatRange_Mapped_to_Which_Chip_Select)
{
     ulong length;
    uword address, data_ptr1;
    ulong addr_tmp1;
    uword data_tmp1;
    uword data_tmp2;
    ubyte bank_hi, bank_lo;
    ubyte *temp;
    ubyte dmy_32k_mem_err_flag2;
     uword i;
    uword dmy_mcon1;


  /* We don't want to use bootx.l in this routine */
    ext_DspMemErrorFlag  = 0x00 ;   /* watch out here */
    dmy_32k_mem_err_flag2 = 0x00;

    Change_PLL_Freqency(PLL_30MHz);  /* select 30.04 MHz */
    temp    = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);

   dmy_mcon1 = MCON_MASK1 | (dmy_mem_bank << 5);
   dmy_mcon1 = 0x3f60;

 #if 0     /* for cs0, bank 3 only */
  /*  data_tmp2 = ReadDSP_MemThruBootx(CCON_REG); */
//   data_tmp2 = dsp_peek2(CCON_REG, 0x0000);

//   data_tmp2 = dmy_WhatRange_Mapped_to_Which_Chip_Select;

  /*  WriteDSP_MemThruBootx(CCON_REG, data_tmp2);  */
//   dsp_poke2(data_tmp2, CCON_REG, 0x0000);

  /*  data_tmp1 = ReadDSP_MemThruBootx(CCON_REG); */
//   data_tmp1 = dsp_peek2(CCON_REG, 0X0000);

//   if (data_tmp1 != data_tmp2)
//   {
//      dmy_32k_mem_err_flag2 = DSP_REG_WR_RD_ERROR;
//   }


//   data_tmp2 = 0xffff;
//   dsp_poke2(data_tmp2, WCON_REG, 0x0000);
//   data_tmp1 = dsp_peek2(WCON_REG, 0X0000);

//   if (data_tmp1 != data_tmp2)
//   {
//      dmy_32k_mem_err_flag2 = DSP_REG_WR_RD_ERROR;
//   }
#endif




/*    set the CCON value to map EPGM_CS3_N to 30000-37fff, bank 6  */
/*   the addr of ccon is 0012h. */


     data_ptr1 = LOCATION_OF_DATA1;
     length  = dmy_32k_array[LOCATION_OF_LENGTH1] + CONST_32K;

/* program bank bits for 30000-37fff, set mcon[7-5] to 110 */





   data_tmp1 = 0;


   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
      data_tmp1 = dmy_32k_array [data_ptr1++];


    /* WriteDSP_MemThruBootx(addr_tmp1, data_tmp1); */
     dsp_poke2(data_tmp1, addr_tmp1, dmy_mcon1);
   }

   data_ptr1 = LOCATION_OF_DATA1;
/* read back and compare */
   for (addr_tmp1 = CONST_32K; addr_tmp1 < length; addr_tmp1++)
   {
      data_tmp1 = dmy_32k_array [data_ptr1++];


    /*  data_tmp2 = ReadDSP_MemThruBootx(addr_tmp1); */
     data_tmp2 = dsp_peek2(addr_tmp1, dmy_mcon1);

     if(data_tmp1 != data_tmp2)
     {
      dmy_32k_mem_err_flag2 |= DSP_32K_MEM_WR_RD_ERROR3;
      addr_tmp1 = length;
      break;
     }

   }

   for (addr_tmp1 = length; addr_tmp1 < CONST_64K; addr_tmp1++)
   {
   /* fill the unused area with 0x0000 */
     /* WriteDSP_MemThruBootx(addr_tmp1, TWO_BYTE_ZERO); */
      dsp_poke2(TWO_BYTE_ZERO, addr_tmp1, dmy_mcon1);
   }



   /* data_tmp2 = ReadDSP_MemThruBootx(WCON_REG); */
   data_tmp2 = dsp_peek2(WCON_REG, 0x0000);

   data_tmp2 &= 0x000f;  /* clear upper 12 bits */
   data_tmp2 |= DSP_ONE_W_STATE_FOR_8000_FFFF;
/* set one wait state for  8000-ffff */

   /* WriteDSP_MemThruBootx(WCON_REG, data_tmp2); */
   dsp_peek2(data_tmp2, WCON_REG);

   /* data_tmp1 = ReadDSP_MemThruBootx(WCON_REG); */
   data_tmp1 = dsp_peek2(WCON_REG, 0X0000);

/*   Change_PLL_Freqency(PLL_34MHz); */ /* select 30.04 MHz */


#if 0   /* don't boot up in this case */
//   *temp = RESET_DSP_AND_BOOT_FROM_FFFF; /* 0x00 */
//    for(i=0;i< 0x100;i++)
//     wait_a_while();

//   *temp = KILL_DSP_RES_N;   /* 0x01 */
//    for(i=0;i< 0xffff;i++)
//     wait_a_while();
#endif

   Change_PLL_Freqency(PLL_30MHz);  /* select 30.04 MHz */


   dsp_poke(DSP_ONE_W_STATE_FOR_8000_FFFF, WCON_REG);  /* 0x2490 */

#if (PATCHLESS_EXTERNAL == 1)
   dsp_poke(0x8007, BCON_REG);
#else
   dsp_poke(0x8000, BCON_REG);
#endif

   return(dmy_32k_mem_err_flag2);

}

/*******************************************************************************
/
/    Routine: RSA_fillup_1(const uword dmy_32k_array[],
/                   uword dmy_WhatRange_Mapped_to_Which_Chip_Select)
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This routine downloads DSP code into 32K Ram
/
/
/
/    Input Parameters: const uword dmy_program_array[]
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/

#if DNLD_X2_FROM_HOST == 0

ubyte RSA_fillup_1(const uword dmy_32k_array[],
                   uword dmy_WhatRange_Mapped_to_Which_Chip_Select)
{
   uword dmy_bank_num2;
   ubyte dmy_32k_mem_err_flag3;

 /* fetch bank number from x2 array */
   dmy_bank_num2 = x2_page_array[LOCATION_OF_BANK_NO_2];

   dmy_32k_mem_err_flag3 = fillup_dsp_32K_extram_2(x2_page_array,
                dmy_bank_num2, dmy_WhatRange_Mapped_to_Which_Chip_Select );


   return(dmy_32k_mem_err_flag3);


}

#endif

ubyte *d1_to_hex(ubyte num)
{
    ubyte i = 2;

    do {
        i--;
        pt[i] = num % 16;
      if (pt[i] < 10)
        pt[i] = pt[i] + '0';
      else
        pt[i] = pt[i] - 10 + 'A';
        num = num / 16;
    } while (i != 0);

    pt[2] = 0;
    return ((ubyte *)&pt[0]);
}


/*******************************************************************************
/
/    Routine: modem_get_pcm_info(void) 
/                   
/
/    Author : CIRRUS
/
/    Creation Date: 01/22/97
/
/    Description : This routine display PCM status.
/                  
/                  
/
/    Input Parameters: none
/
/    Output Parameters: none
/
/    Global Variables Changed:  none
/
/    Users:    ???
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
*******************************************************************************/
void modem_get_pcm_info()
{

   ubyte value;
   ubyte *ptr,str[14];
   ubyte crlf[] = "\r\n";
   ubyte index=0;

   LOAD_MODEM_GET_PCM_INFO
    dsp_cp_packet = PACKET_DP_PCM_INFO;          
    ack_or_response = RESPONSE;
    send_pkt_to_dsp();
/*
   value = dsp_response_data[index] & 0x01 ;
   if (value == 0x00)
   {
      output_info((ubyte *)"Carrier Frequency           : LOW",UNFORMATTED);
      output_info((ubyte *)crlf,UNFORMATTED);
   }
   else if (value == 0x01)                        
   {
      output_info((ubyte *)"Carrier Frequency           : HIGH",UNFORMATTED);
      output_info((ubyte *)crlf,UNFORMATTED);
   }
             
   value = (dsp_response_data[index] >> 1) & 0x07; 
   symbol_rate(value,0); 

   value = (dsp_response_data[index] >> 4) & 0x07;
   symbol_rate(value,1); 
*/
   output_info((ubyte *)"PCM Signature       : ",UNFORMATTED);
   ptr = d1_to_hex(dsp_response_data[index+3]);    /* ptr =&pt[0] */
   str[0] = *ptr++;
   str[1] = *ptr;
   str[2] = ',';
   ptr = d1_to_hex(dsp_response_data[index+2]);    /* ptr =&pt[0] */
   str[3] = *ptr++;
   str[4] = *ptr;
   str[5] = ',';
   ptr = d1_to_hex(dsp_response_data[index+1]);    /* ptr =&pt[0] */
   str[6] = *ptr++;
   str[7] = *ptr;
   str[8] = ',';
   ptr = d1_to_hex(dsp_response_data[index]);    /* ptr =&pt[0] */
   str[9] = *ptr++;
   str[10] = *ptr;
   str[11] = 0;
   output_info(str,UNFORMATTED);   
   output_info((ubyte *)crlf,UNFORMATTED);

   output_info((ubyte *)"Timing Offset       : ",UNFORMATTED);
   ptr = d1_to_hex(dsp_response_data[index+5]);    /* ptr =&pt[0] */
   str[0] = *ptr++;
   str[1] = *ptr;
   str[2] = ',';
   ptr = d1_to_hex(dsp_response_data[index+4]);    /* ptr =&pt[0] */
   str[3] = *ptr++;
   str[4] = *ptr;
   str[5] = 0;
   output_info(str,UNFORMATTED);   
   output_info((ubyte *)crlf,UNFORMATTED);

   output_info((ubyte *)"Sqrint              : ",UNFORMATTED);
   ptr = d1_to_hex(dsp_response_data[index+7]);    /* ptr =&pt[0] */
   str[0] = *ptr++;
   str[1] = *ptr;
   str[2] = ',';
   ptr = d1_to_hex(dsp_response_data[index+6]);    /* ptr =&pt[0] */
   str[3] = *ptr++;
   str[4] = *ptr;
   str[5] = 0;
   output_info(str,UNFORMATTED);   
   output_info((ubyte *)crlf,UNFORMATTED);
}


void symbol_rate(ubyte rate,ubyte tx_rx)

{
   ubyte crlf[] = "\r\n";

   switch (rate)
   {      
      case 0:
         if (tx_rx == 0)
            output_info((ubyte *)"symbol rate tx              : 2400",UNFORMATTED);
         else if (tx_rx == 1)
            output_info((ubyte *)"symbol rate rx              : 2400",UNFORMATTED);
         break;                                 
      case 1:
         if (tx_rx == 0)
            output_info((ubyte *)"symbol rate tx              : 2743",UNFORMATTED);
         else if (tx_rx == 1)                    
            output_info((ubyte *)"symbol rate rx              : 2743",UNFORMATTED);
         break;
      case 2:
         if (tx_rx == 0)
            output_info((ubyte *)"symbol rate tx              : 2800",UNFORMATTED);
         else if (tx_rx == 1)                      
            output_info((ubyte *)"symbol rate rx              : 2800",UNFORMATTED);
         break;
      case 3:
         if (tx_rx == 0)
            output_info((ubyte *)"symbol rate tx              : 3000",UNFORMATTED);
         else if (tx_rx == 1)
            output_info((ubyte *)"symbol rate rx              : 3000",UNFORMATTED);
         break;
      case 4:
         if (tx_rx == 0)
            output_info((ubyte *)"symbol rate tx              : 3200",UNFORMATTED);
         else if (tx_rx == 1)
            output_info((ubyte *)"symbol rate rx              : 3200",UNFORMATTED);
         break;
      case 5:
         if (tx_rx == 0)
            output_info((ubyte *)"symbol rate tx              : 3429",UNFORMATTED);
         else if (tx_rx == 1)
            output_info((ubyte *)"symbol rate rx              : 2400",UNFORMATTED);
         break;
      case 6:
         if (tx_rx == 0)
            output_info((ubyte *)"symbol rate tx              : 3429",UNFORMATTED);
         else if (tx_rx == 1)
            output_info((ubyte *)"symbol rate rx              : 3429",UNFORMATTED);
         break;

   }
   output_info((ubyte *)crlf,UNFORMATTED);

}

