/****************************************************************************
/
/    Copyright, 1988 - 1991.     All Rights Reserved by:
/        RSA
/        7701 Six Forks Road
/        Suite 120
/        Raleigh, NC  27615
/        (919) 846-7171
/
/
/    This document contains material confidential to RSA its contents must
/    not be revealed, used or disclosed to anyone or company with out
/    written permission by RSA.  The information contained herein is solely
/    for the use of RSA.
/
/    File:          linematc.c
/
/    Version:  1.0
/
/    Function:      This file contains the DCE I/O routines specific to the
/              speed matching protocol.
/
/    Product:  CP Line I/O for Merlin DSP
/
/    Platform: First Flight -- Merlin/Cutlass DSP
/
/    History:       developed from LINELMATC.C
/
/    Created:  October 25, 1994
/
/    ---------------------------------------------------------
/    -              Modifications            -
/    ---------------------------------------------------------
/
/    Author & Date: RSA  
/    Description:
/
*****************************************************************************/

#include "sys_def.h"
#include "lineequ.h"            /* line constant defs */
#include "lineedf.h"            /* line external variable defs */
#include "iohw_equ.h"           /* first flight hardware defs */
#include "linelink.h"           /* linelink.c prototypes */
#include "dsp_drv.h"            /* first flight dsp drivers */
#include "local.h"
#include "cp_dsp.h"
/* Will be changed later */   
#include "mt_codef.h"
#include "mt_macro.h"
#include "linev80.h"

extern ubyte V80_tx_frm_spacing_complete;
extern ubyte V80_wait_DCE_empty;

/***************** external procedures used locally *************************/

/*** from file linedetc.c ***/
extern void detection_timer(void);

/*** from file lineint.c ***/
extern void line_special_int(void);

/*** from file lineasyn.c ***/
extern void got_auto_fallback(ubyte);


/************************** local procedures *******************************/
void line_from_clear(void);
uword line_from_num(void);
ubyte line_from_char(void);
ubyte line_from_char_bg(void);
void line_to_clear(void);
uword line_to_free(void);
void line_to_char(ubyte);
void line_to_char_bg (ubyte);
void line_to_break(ubyte, ubyte );
void line_timer(void);
ubyte dce_rx_resume(void);
ubyte dce_rx_suspend(void);
void spd_match_tx_int(void);
void spd_match_rx_int(void);

/****************** external variables used locally *********************/
    /*** v42 variables ***/
extern ubyte v42_line_break_time;
extern ubyte v42_got_line_break;

extern ubyte current_command [];
extern void send_pkt_to_dsp(void);
extern ubyte ack_or_response;

/******************************************************************************
/
/    Procedure: line_from_clear
/
/    Author : RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will clear out all pending rx data 
/              by resetting the buffer indicies and SCC rx fifo
/
/    Input Parameters: None
/
/    Output Parameters: None
/
/    Global Variables Changed:  dte_rx_remove, dte_rx_count, dte_rx_insert
/                   dte_tesc_count, dte_guard_time, dte_guard_time, 
/                   dte_20_mSec_timer 
/
/    Users:    
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
****************************************************************************/
void line_from_clear(void)
{
   ubyte buffer_type;

   extern ubyte dce_flag_count;

    line_disable_interrupts();

/*  Reset buffer mechanisms */
    dce_rx_remove = 0;       
    dce_rx_insert = 0;  
    dce_rx_count = 0;

/*  If any rx data was suspended release it because the buffer is empty */
    if ( dce_rx_suspended )
        dce_rx_resume();

/* BRG */
/* if v80 SAM flush dsp too */
   if ( v80_sam )        
   {
      buffer_type = 1;   /* Clear RX buffer */
      LOAD_MODEM_CLEAR_DATA_BUFFER
      ack_or_response = ACK;
      send_pkt_to_dsp();

   }

   dce_flag_count = 0;

    line_enable_interrupts();
}

/**************************************************************************
/
/    Routine: line_from_num
/
/    Author : RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will return the number of characters
/              contained in the line receive buffer
/
/    Input Parameters: None
/
/    Output Parameters: (uword) # of chars in rx buffer
/
/    Global Variables Changed:  None
/
/    Users:    
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
***********************************************************************/
uword line_from_num(void)
{
     return(dce_rx_count);
}


/******************************************************************************
/
/    Routine: line_from_char
/
/    Author: RSA
/
/    Creation Date: July 30, 1992
/
/    Description:   This routine will remove a character from the current
/              process buffer
/
/    Input Parameters: None
/
/    Output Parameters:  (ubyte) character from buffer
/
/    Global Variables Changed:  
/
/    Users:    
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
******************************************************************************/
ubyte line_from_char(void)
{
    ubyte c;

    
    line_disable_interrupts();


/*   Pop char from buffer and bump indicies */
    c = dce_rx_buffer[dce_rx_remove];  
    dce_rx_remove++ ;   
    dce_rx_count-- ;              

/*   Reset buffer ptr ? */
    if (dce_rx_remove == DCE_BUFFER_SIZE )
        dce_rx_remove = 0;

/*   If any rx data was suspended release it because the buffer has room */
    if ( dce_rx_suspended )
    {
/*        Check if this char fell below the buffer threshhold */
        if ( dce_rx_count < DCE_NEAR_EMPTY )
            dce_rx_resume();
    }

    line_enable_interrupts();

    return(c);
}


/******************************************************************************
/
/    Procedure:     line_to_clear
/
/    Author :  RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will clear out all pending tx data 
/              by resetting the buffer indicies and SCC tx fifo
/
/    Input Parameters: None
/
/    Output Parameters: None
/
/    Global Variables Changed:  dce_tx_remove, dce_tx_count, dce_tx_insert
/
/    Users:    
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
****************************************************************************/
void line_to_clear(void)
{
    line_disable_interrupts();

/*   Reset buffer mechanisms */
    dce_tx_remove = 0;       
    dce_tx_insert = 0;  
    dce_tx_count = 0;

/*   Reset tx break mechanisms */
    dce_tx_break_pending = FALSE;

/* RJM100896 */
/* V.80 support */
    v80_frame_count = 0;

    line_enable_interrupts();
}

/* RJM100796 */
/* V.80 support */
/**************************************************************************
/
/    Routine:        line_to_num
/
/    Author :        RSA
/
/    Creation Date:  09/05/96
/
/    Description:    This routine will return the number of characters
/                    contained in the line transmit buffer
/
/    Input Parameters: None
/
/    Output Parameters: (uword) # of chars in tx buffer
/
/    Global Variables Changed:  None
/
/    Users:    
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
***********************************************************************/
uword line_to_num(void)
{
   return(dce_tx_count);
}

/******************************************************************************
/
/    Routine: line_to_free
/
/    Author:   RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will return the amount of space available
/              in the dce transmit buffer.
/
/    Input Parameters: None
/
/    Output Parameters: (uword) space available 
/
/    Global Variables Changed:  None
/
/    Users:    
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
******************************************************************************/
uword line_to_free(void)
{
    return( DCE_BUFFER_SIZE - dce_tx_count - 2 );
}


/******************************************************************************
/
/    Routine: line_to_char
/
/    Author: RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will send a character to the DCE
/              with buffering if required.
/
/    Input Parameters: (ubyte) character to be transmitted 
/
/    Output Parameters: None
/
/    Global Variables Changed:  dce_tx_buffer, dce_tx_insert, dce_tx_count,
/                        dce_tx_interrupt_expected 
/
/    Users:    
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
******************************************************************************/
void line_to_char(ubyte out_char)
{
    ubyte need_to_kickstart = FALSE;

    line_disable_interrupts();

/*   If buffer has no data and a tx int is not expected will need to kickstart */

/* RJM100796 */
/* V.80 support */
    if (!dce_tx_count && !dce_tx_interrupt_expected && !v80_sam )
    {
            need_to_kickstart = TRUE;
    }

/*   If there's room in the buffer, stuff and bump, else ignore char */
    if (dce_tx_count < DCE_BUFFER_SIZE)
    {
        dce_tx_buffer[dce_tx_insert++] = out_char;
        dce_tx_count++ ;

        /* reset buffer ptr ? */
        if (dce_tx_insert == DCE_BUFFER_SIZE)
            dce_tx_insert = 0;
    }

/* RJM100796 */
/* V.80 support */
    /* In V.80 mode, we want to "batch" up some data
      before we start to TX, thus no DSP FIFO underruns 
      occur. Also, do NOT ping DSP if we're already
      transmitting - its BUSY!!!
    */
    if( v80_sam && (dce_tx_count >= 64) && !dce_tx_interrupt_expected )
        need_to_kickstart = TRUE;

    if (need_to_kickstart)
    {
        dspdrv_ping_cram_intr();
        dce_tx_interrupt_expected =TRUE;
    }

  line_enable_interrupts();

} /* procedure */

/******************************************************************************
/
/    Routine: line_to_block
/
/    Author: RSA
/
/    Creation Date: October 7, 1996
/
/    Description:   This routine take all bytes in supplied buffer
/                   and stick them into the DCE_TX_BUFFER[].
/
/    Input Parameters: ubyte * - character buffer to be transmitted 
/                      ubyte   - number of bytes in buffer
/
/    Output Parameters: None
/
/    Global Variables Changed:  dce_tx_buffer, dce_tx_insert, dce_tx_count,
/                        dce_tx_interrupt_expected 
/
/    Users:    
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
******************************************************************************/
void line_to_block(ubyte *array, ubyte count)
{
    ubyte i;
    ubyte tflag = FALSE;
    ubyte need_to_kickstart = FALSE;

#if 0
   for(i=0;i<count;i++)
   {
      outchar( *(array+i) );
   }
#endif

    line_disable_interrupts();

   if ((v80_sam == TRUE) && (current_sub_mode == FRAMED_SUB_MODE))
   {
       if (dce_tx_count >= 64)
       {
           need_to_kickstart = TRUE;

           if (!dce_tx_interrupt_expected && !v80_frame_count)
           {
               v80_pframe_count=1;
           }
       }

       if(count >= 2)
       {
            /* If buffer contains <EM><FLAG> */
           if (((array[0] == 0x19) || ( array[0] == 0x99 )) && ((array[1] == 0xB1) || ( array[1] == 0xB2 )))
           {
               need_to_kickstart = TRUE;
               v80_pframe_count = 0;

               if( array[1] == 0xB1 )
               {
                   v80_frame_count++;
               }
           }
       }
   }
   else if((v80_sam == TRUE) && (current_sub_mode == TRANSPARENT_SUB_MODE))
   {
       if( count > 2 )
       {
            /* If buffer contains <EM><MARK> */
           if ((array[0] == 0x19) && (array[1] == 0xB0))
           {
               need_to_kickstart = TRUE;
               tflag = TRUE;
           }
       }

       if (dce_tx_count >= 64)
       {
           need_to_kickstart = TRUE;
           tflag = TRUE;
       }
   }

   /* If there's room in the buffer, stuff and bump, else ignore char */
   if (tflag != TRUE)
   {
      for (i=0; i<count; i++)
      {
          if (dce_tx_count < DCE_BUFFER_SIZE)
          {
              dce_tx_buffer[dce_tx_insert++] = array[i];

              dce_tx_count++ ;
   
              /* reset buffer ptr ? */
              if (dce_tx_insert == DCE_BUFFER_SIZE)
                  dce_tx_insert = 0;
          }
          else
          {
              PrintMsg( "---dce_tx_buf full!!!---" );
          }
      }
   }

   /* the line tx isr starts a timer when the flag ending frame is sent to com ram.
    * the v80 background monitors the timer, setting v80_tx_frm_spacing_complete 
    * true when the timer expires. wake up the dsp for tx data when 
    * the timer has expired.
   */

    if (need_to_kickstart && !dce_tx_interrupt_expected && V80_tx_frm_spacing_complete )
    {
        dspdrv_ping_cram_intr();
        dce_tx_interrupt_expected =TRUE;
      V80_tx_frm_spacing_complete = FALSE;
    }

   line_enable_interrupts();
} /* procedure */





/******************************************************************************
/
/    Routine: v80_purge_line
/
/    Author: RSA
/
/    Creation Date: December 19, 1996
/
/    Description:   This routine kickstarts the dsp to remove data from dce tx buf
/
/    Output Parameters: None
/
/    Global Variables Changed:  V80_wait_DCE_empty,
/                               dce_tx_interrupt_expected,
/                               v80_tx_frm_spacing_complete
/
/    Users:    
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
*****************************************************************************/

void v80_purge_line(void)
{
outchar('^');
      V80_wait_DCE_empty = TRUE;
      if (dce_tx_interrupt_expected == FALSE )
      {
           dspdrv_ping_cram_intr();
           dce_tx_interrupt_expected = TRUE;
         V80_tx_frm_spacing_complete = FALSE;
      }
}

/******************************************************************************
/
/    Routine: line_to_break
/
/    Author: RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will send a break to the line 
/
/    Input Parameters: (ubyte) Break type
/                   0 = ignore
/                   1 = expedited/destructive
/                   2 = expedited/nondestructive
/                   3 = nonexpedited/nondestructive
/
/                (ubyte) Break length in 10 mSec increments
/                   0 value indicates usage of default break length
/
/    Output Parameters: None
/
/    Global Variables Changed:  dce_tx_break_psn, dce_tx_break_count, 
/                        dce_tx_break_pending
/
/    Users:    
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
*****************************************************************************/
void line_to_break(ubyte break_type, ubyte break_length)
{
    /*mrm91995*/
    /*ubyte break_packet[PCKT_SIZE_TX_X_BREAK];*/
    ubyte cp_dsp_data_semaphore;
    ubyte length;
    ubyte status;

    line_disable_interrupts();

/*   Set break length duration */
    if ( break_length )
        dce_tx_break_count = break_length;
    else
        dce_tx_break_count = DCE_BREAK_TIME;

    switch ( break_type ) {

        case EXPEDITED_DESTRUCTIVE :

/*                  Flush DCE buffers */
                dce_rx_remove = 0;
                dce_rx_insert = 0;
                dce_rx_count = 0;
                dce_tx_remove = 0;
                dce_tx_insert = 0;
                dce_tx_count = 0;

/*                  Reset tx break mechanisms */
                dce_tx_break_pending = FALSE;
    
/*                  Just cleared buffers, so release any suspended data */
                if ( dce_rx_suspended )
                    dce_rx_resume();
             
                /* Send break via commmand message*/
             
                /* Setup packet to send to DSP */
                
                /*
                current_command[0] = PACKET_MODEM_TX_BREAK;
                current_command[1] = 0;  
                current_command[2] = 2;  
                current_command[3] = 0;  
                current_command[4] = dce_tx_break_count; 
                current_command[5] = DESTRUCTIVE;
                 
                while (error_occured= cp_dsp());
                while (error_occured= dsp_acknowledge_packet());     
                */
                
                LOAD_MODEM_TX_BREAK_DEST
                ack_or_response = FALSE;
                send_pkt_to_dsp();

                break;
            
        case EXPEDITED_NONDESTRUCTIVE:

                /* Setup packet to send to DSP */
                /*
                current_command[0] = PACKET_MODEM_TX_BREAK;
                current_command[1] = 0; 
                current_command[2] = 2; 
                current_command[3] = 0; 
                current_command[4] = dce_tx_break_count;
                current_command[5] = NON_DESTRUCTIVE;
                 
                while (error_occured= cp_dsp());
                while (error_occured= dsp_acknowledge_packet());     
                */

                LOAD_MODEM_TX_BREAK_NONE
                ack_or_response = FALSE;
                send_pkt_to_dsp();
                
                break;

        case NONEXPEDITED_NONDESTRUCTIVE:
                
                dspdrv_ReadCram(CP_DSP_DATA_LENGTH, &cp_dsp_data_semaphore, 1);

/*                  If data is buffered, buffer the BREAK after the data */
                if ( dce_tx_count ||  dce_tx_interrupt_expected ||
                        cp_dsp_data_semaphore !=0)
                {
                    dce_tx_break_psn = dce_tx_insert; 
                    dce_tx_break_pending = TRUE;
                }
                else 
                {
                    /* send break to DSP via data area */
                    /* write break lenght into data area */
                    dspdrv_WriteCram(CP_DSP_DATA_AREA_BASE,
                                            &dce_tx_break_count, 1);

                    status = TX_BREAK;
                    length = 1;    /* just the break length byte */
                    dspdrv_WriteCram(CP_DSP_DATA_STATUS, &status, 1);
                    dspdrv_WriteCram(CP_DSP_DATA_LENGTH,
                                                &length, 1);
                }

                break;

        case IGNORE:
        default:
                break;

    } /* switch */
            
    line_enable_interrupts();

} /* procedure */




/******************************************************************************
/
/    Routine: line_timer
/
/    Author: RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   Called every 10 mSec by the control code, this routine
/              maintains break and escape sequence timer mechanisms 
/              for the DCE code.
/
/    Input Parameters: None
/
/    Output Parameters: None
/
/    Global Variables Changed:  
/
/    Users:    acu_timer (10 msec interrupt)
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
*****************************************************************************/
void line_timer(void)
{
/*    Run the detection timer if enabled */
     if (detection_enabled)
          detection_timer();


/*   Run the autoreliable timer if enabled */
    if (auto_fallback_timer)
    {
        auto_seconds-- ; 
        
/*        If 1 Second has passed */
        if ( ! auto_seconds )
        {
            auto_seconds = 100;  /* reload 1 Second */
            auto_fallback_timer-- ; /* advance the 4 second timer */

/*             If autoreliable timer expired proclaim fallback */
            if ( ! auto_fallback_timer )
                got_auto_fallback(FALLBACK_TIMEOUT);
        }
    }
        

    /* Is the line I/O waiting on a frame to be sent out the DSP? */
    /* ie: as in Fax hdlc mode.  If so call special int */
    if (line_hdlc_waiting_CRC_sent == TRUE)
    {
        line_disable_interrupts();
        line_special_int();
        line_enable_interrupts();
    }

/* RJM100796 */
/* V.80 support */    
   /* This V.80 waiting timer allows the DSP to flush out the
      remaining received data before disabling hunt mode and
      sending back the <EM><ERR> sequence */
   if (hunt_end_wait_timer)
   {
      if (--hunt_end_wait_timer == 0)
      {
         hunt_mode_en = FALSE;
      }
   }
} /* procedure */


/******************************************************************************
/
/    Routine: dce_rx_resume
/
/    Author: RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will resume rx operations for the line
/
/    Input Parameters: None
/
/    Output Parameters: (ubyte)  TRUE = char sent
/                       FALSE = no char sent
/
/    Global Variables Changed: dce_rx_suspended 
/
/    Users:    dce_from_clear, dce_from_char, dce_tx_int
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
*****************************************************************************/
ubyte dce_rx_resume(void)
{
    ubyte packet[PCKT_SIZE_TX_FLOW_CHAR];
    ubyte char_was_sent;

    dce_rx_suspended = FALSE;

/*   If flow control's enabled send an xon char */
    if (modem_to_modem_flow_cntl ) 
    {
        /*packet[0] = PACKET_MODEM_TX_FLOW_CTL;*/
        packet[1] = 0;    /* filler */
        packet[2] = 2;    /* length */
        packet[3] = 0;    /* filler */
        packet[4] = modem_to_modem_xon_char;
        packet[5] = 0;    /* filler */
        /*QueuePutMsg((Queue*)DspTxQue,(BYTE*) packet);*/
        char_was_sent = TRUE;
    }
    else 
        char_was_sent = FALSE;

    return(char_was_sent);
}



/******************************************************************************
/
/    Routine: dce_rx_suspend
/
/    Author: RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will suspend rx operations for the line
/
/    Input Parameters: None
/
/    Output Parameters: (ubyte)  TRUE = char sent
/                       FALSE = no char sent
/
/    Global Variables Changed:  dce_rx_suspended 
/
/    Users:    
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
*****************************************************************************/
ubyte dce_rx_suspend(void)
{
    ubyte packet[PCKT_SIZE_TX_FLOW_CHAR];
    ubyte char_was_sent;
    
    dce_rx_suspended = TRUE;

/*   Is flow control's enabled send and xoff char */
    if (modem_to_modem_flow_cntl )                
    {
        /*packet[0] = PACKET_MODEM_TX_FLOW_CTL;*/
        packet[1] = 0;    /* filler */
        packet[2] = 2;    /* length */
        packet[3] = 0;    /* filler */
        packet[4] = modem_to_modem_xoff_char;
        packet[5] = 0;    /* filler */
        /*QueuePutMsg((Queue*)DspTxQue,(BYTE*) packet);*/
        char_was_sent = TRUE;
    }
    else 
        char_was_sent = FALSE;

    return(char_was_sent);
}



/******************************************************************************
/
/    Routine: spd_match_tx_int
/
/    Author: RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will handles the SCC special interrupts 
/         durring the speed matching protocol.
/
/    Input Parameters: None
/
/    Output Parameters: None
/
/    Global Variables Changed:  dce_tx_interrupt_expected, dce_tx_buffer, 
/                        dce_tx_remove, dce_tx_count
/
/    Users:    line_tx_int
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/
*****************************************************************************/
void spd_match_tx_int(void)
{
    ubyte status; /* status byte of data area semaphore to write */
    ubyte data_count;  /* count of number of data bytes to send to Comm RAM */
    uword address; /* address of Comm RAM to write data to */

/*   If we're waiting on a buffered break & it's arrived, start the break */
    
    if (dce_tx_break_pending == TRUE &&
            dce_tx_remove == dce_tx_break_psn)
    {
        dce_tx_break_pending = FALSE;
        
        /* send break to DSP via data area */
        
        /* write break length into data area */
        dspdrv_WriteCram(CP_DSP_DATA_AREA_BASE, &dce_tx_break_count, 1);

        status = TX_BREAK;
        data_count = 1;
        dspdrv_WriteCram(CP_DSP_DATA_STATUS, &status, 1);
        dspdrv_WriteCram(CP_DSP_DATA_LENGTH, &data_count, 1);
        return;
    }

    if (dce_tx_count == 0)
    {
       dce_tx_interrupt_expected = FALSE; 
        return;
    }
    
    /* init variables */
    address = CP_DSP_DATA_AREA_BASE;
    data_count = 0;

    while (dce_tx_count && (data_count < DATA_AREA_SIZE))
    {
        if (dce_tx_break_pending == TRUE && dce_tx_remove == dce_tx_break_psn)
            break;

        dspdrv_WriteCram(address, &dce_tx_buffer[dce_tx_remove], 1);

        address += WORD_OR_BYTE_ADD_INC;
        data_count++;
        dce_tx_count--;
        dce_tx_remove++;
/*        Reset buffer ptr ? */
        if (dce_tx_remove == DCE_BUFFER_SIZE)
            dce_tx_remove = 0;
    }

    /* set semaphore, status then length */
    status = NO_STATUS;
    dspdrv_WriteCram(CP_DSP_DATA_STATUS, &status, 1);
    dspdrv_WriteCram(CP_DSP_DATA_LENGTH, &data_count, 1);
    
    return;

}/* procedure */


/******************************************************************************
/
/    Routine: spd_match_rx_int
/
/    Author: RSA
/
/    Creation Date: October 25, 1994
/
/    Description:   This routine will handles the SCC RX READY interrupts 
/         durring the speed matching protocol.
/
/    Input Parameters: None
/
/    Output Parameters: None
/
/    Global Variables Changed:  
/
/    Users:    line_rx_int
/
/    *************************************************************
/    *              Modifications                *
/    *************************************************************
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*****************************************************************************/
void spd_match_rx_int(void)
{
    ubyte address;

    /* check status for break rx'd */
    if (dce_status_semaphore == RX_BREAK)
    {
      /* last byte in CRAM data area is break length */
        dce_length_semaphore--;
        v42_got_line_break = TRUE;
        dspdrv_ReadCram(DSP_CP_DATA_AREA_BASE +
                     (dce_length_semaphore * WORD_OR_BYTE_ADD_INC),
                     &v42_line_break_time, 1);
    }

    address = DSP_CP_DATA_AREA_BASE;
  
    while (dce_length_semaphore)
    {
        
        dspdrv_ReadCram(address, &dce_rx_buffer[dce_rx_insert], 1);

/*        Check if flow control is enabled, check for XON, XOFF */
/* if !flowctl or passthru or (flowctl and !passthru and flowctlchar  */

        if (  (!modem_to_modem_flow_cntl) || (dce_pass_through_flow_cntl) ||
         ( (modem_to_modem_flow_cntl) && (dce_pass_through_flow_cntl == FALSE) &&
         ( (dce_rx_buffer[dce_rx_insert] != modem_to_modem_xon_char) && 
                                (dce_rx_buffer[dce_rx_insert] != modem_to_modem_xoff_char)) ))

        {
            /*        Buffer the char if there's room */
                    if (dce_rx_count < (DCE_BUFFER_SIZE - 2))
                    {
            /*            Pop in buffer and bump indicies */
                        dce_rx_insert++;  /* array index */
                       dce_rx_count++;   /* dce recieve buffer */
            
            /*            Reset buffer ptr ? */
                        if (dce_rx_insert == DCE_BUFFER_SIZE)
                            dce_rx_insert = 0;
            
            /*            If buffer's full and flw cntl's active, and we haven't already
             *            XOFF'ed the remote, do it now
             */
                        if (dce_rx_count == DCE_NEAR_FULL && 
                                        modem_to_modem_flow_cntl && ! dce_rx_suspended)
                            dce_rx_suspend();
                    }/* end if room in buffer */        
        } /* end flow control check */

        address += WORD_OR_BYTE_ADD_INC;
        dce_length_semaphore--;
    } /* end while */

    dce_status_semaphore = 0;

    /* clear semaphores */
    dspdrv_WriteCram(DSP_CP_DATA_LENGTH, &dce_length_semaphore, 1);
    dspdrv_WriteCram(DSP_CP_DATA_STATUS, &dce_status_semaphore, 1);

} /* procedure */
    
    
    



