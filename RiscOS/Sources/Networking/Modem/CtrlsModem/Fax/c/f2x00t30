/****************************************************************************
/
/   Copyright, 1991,1992,1993,1994.       All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File: f2x00t30.c
/
/   Module Version: 4.03
/
/   Function: This file contains routines which implement the T30 protocol
/             needed for fax class 2 (TIA/EIA PS-2388 and 592). The 592
/             phase C, and ECM functions are implemented in separate files.
/
/   Product: Class 2 FAX Module.
/
/   History: fx00cl2.c 3.99
/            f2x00cl.c 4.00
/
/   Created: 9/21/92
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
****************************************************************************/
#include "sys_def.h"

#include "f2x_def.h"
#include "f2x_mem.h"
#include "f2x_pro.h"

ubyte fax2_bg();
ubyte fax2_phaseB_receive(void);
ubyte fax2_phaseD_receive(void);
ubyte fax2_phaseB_transmit(void);
ubyte fax2_phaseD_transmit(void);
ubyte fax2_phaseE(void);

/******************************************************************************
/
/   Routine: fax2_bg
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will process the FAX class 2 background functions.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/
/   Global Variables Changed: Class 2 FAX vairiables
/
/   Users: fax_bg()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_bg()
{
    ubyte return_code;

     /* if +FXX command transitioned to online, or */
     /* back online from parse via a request from fax2_bg */
    if (fax2_configure_dte)
    {
        /* chack the flow control direction */
        switch (fax2_configure_dte)
        {
            case NO_FLOW:
                fax_dte_init(fax2_dte_baud, NO_FLOW_CONTROL, NO_FLOW_CONTROL);
                break;
            case MODEM_TO_APP_FLOW:
                fax_dte_init(fax2_dte_baud, NO_FLOW_CONTROL, fax2_flow_control);
                break;
            case APP_TO_MODEM_FLOW:
                fax_dte_init(fax2_dte_baud, fax2_flow_control, NO_FLOW_CONTROL);
                break;
        }
        /* clear the configuration flag */
        fax2_configure_dte = FALSE;
    }

    switch (fax2_state)
    {
        case IDLE:  /* FAX not active; No connection or procedure interrupt */
            return_code = STAY_PARSE;
            break;
        case PHASE_B_RECEIVE:
            return_code = fax2_phaseB_receive();
            /* give processing power to ECM DTE task if negotiated */
            if (fax2_negotiated.EC)
                fax2_ECM_dte_bg_page();
            break;
        case PHASE_C_RECEIVE:   /* 2388, 592, or ECM */
            if (fax2_negotiated.EC)
            {
                return_code = fax2_phaseC_receive_ECM_page();
                fax2_ECM_dte_bg_page();
            }
            else
                return_code = fax2_phaseC_receive_page();
            break;
        case PHASE_D_RECEIVE:   /* normal or ECM */
            if (fax2_negotiated.EC)
            {
                return_code = fax2_phaseD_receive_ECM_page();
                fax2_ECM_dte_bg_page();
            }
            else
                return_code = fax2_phaseD_receive();
            break;
        case PHASE_B_TRANSMIT:
            return_code = fax2_phaseB_transmit();
            break;
        case PHASE_C_TRANSMIT:  /* 2388, 592, or ECM */
            if (fax2_negotiated.EC)
                return_code = fax2_phaseC_transmit_ECM_page();
            else
                return_code = fax2_phaseC_transmit();
            break;
        case PHASE_D_TRANSMIT:  /* normal or ECM */
            if (fax2_negotiated.EC)
                return_code = fax2_phaseD_transmit_ECM_page();
            else
                return_code = fax2_phaseD_transmit();
            break;
        case PHASE_E:
            return_code = fax2_phaseE();
            break;
    }

    /* if transitioning the ACU to parse state */
    if (return_code > STAY_PARSE && return_code != GOTO_ONLINE_BG)
    {
        while (fax_dte_to_num()); /* flush the DTE port */
        fax_dte_reset();    /* release it */
    }

    return(return_code);
}

/******************************************************************************
/
/   Routine: fax2_phaseB_receive
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will implement the class 2 T.30 phase B receive
/                functions.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/
/   Global Variables Changed: Class 2 FAX vairiables
/
/   Users: fax2_bg()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_phaseB_receive(void)
{
    ubyte return_code;

    return_code = STAY_ONLINE;  /* default to keep ACU in online state */

    switch (fax2_sub_state)
    {
        /* T.30 (R) state */
        case INITIALIZE: /* setup T.30 T1 timer for establishing phase B */
            fax2_T1_timer = T1_TIMEOUT;
            /* look to send DTC if polling is elected */
            fax2_sub_state = fax2_send_DTC ? SCHEDULE_DTC_BLOCK :
                                             SCHEDULE_DIS_BLOCK;
            break;
        case SCHEDULE_DIS_BLOCK:
            /* transmit the DIS block */
            if (fax2_nonstandard_string[0])
                fax2_schedule_tx_packet(NSF_PACKET, UNUSED); /* non-standard */
            if (fax2_local_id_string[0])
                fax2_schedule_tx_packet(CSI_PACKET, UNUSED); /* local ID */
            fax2_schedule_tx_packet(DIS_PACKET, UNUSED); /* negotiation */
            fax2_received_valid_DIS = 0; /* assume receiving a valid DIS response */
            fax2_sub_state = TX_DIS_DTC_BLOCK;
            break;
        case SCHEDULE_DTC_BLOCK:
            /* transmit the DTC block */
            if (fax2_nonstandard_string[0])
                fax2_schedule_tx_packet(NSC_PACKET, UNUSED); /* non-standard */
            if (fax2_polling_id_string[0])
                fax2_schedule_tx_packet(CIG_PACKET, UNUSED); /* local ID */
            fax2_schedule_tx_packet(DTC_PACKET, UNUSED); /* negotiation */
            fax2_sub_state = TX_DIS_DTC_BLOCK;
            break;
        case TX_DIS_DTC_BLOCK:
            if (fax2_transmit_packet()) /* configure and transmit */
                fax2_sub_state = RX_DCS_DTC_BLOCK;
            break;
        case RX_DCS_DTC_BLOCK:
            /* receive a response block to the DIS or DTC */
            switch (fax2_response_receive())
            {
                case PROCESSING: /* looking for packet */
                    break;
                case RECEIVED_RESPONSE: /* non-optional packet received */
                    fax2_send_DTC = FALSE; /* reset polling indication */
                    fax2_sub_state = ROUTE_COMMAND;
                    break;
                case NO_RESPONSE: /* T4 timeout or flags w/o proper packet */
                    if (fax2_T1_timer) /* if T1 not out try keep tring */
                        fax2_sub_state = fax2_send_DTC ? SCHEDULE_DTC_BLOCK :
                                                         SCHEDULE_DIS_BLOCK;
                    else /* tried for T1 time w/o success, so disconnect */
                    {
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        fax2_hangup_status = fax2_EOM_processing ?
                                             RX_B_T1_TIMEOUT_ERROR :
                                             TX_A_T1_TIMEOUT_ERROR;
                    }
                    break;
                case TRANSMIT_DCN: /* packet larger than 3 sec */
                    fax2_state = PHASE_E;
                    fax2_sub_state = SCHEDULE_DCN_PACKET; /* transmit DCN */
                    fax2_hangup_status = RX_B_RSPREC_ERROR;
                    break;
                case TERMINATE_SESSION: /* DCN received, terminate w/o DCN */
                    fax2_state = PHASE_E;
                    fax2_sub_state = TERMINATE;
                    fax2_hangup_status = RX_B_RSPREC_ERROR;
                    break;
            }
            break;
        /* T.30 (F) state */
        case RX_COMMAND_OR_DATA: /* setup T2 timer for receiving command or data */
            fax2_T2_timer = T2_TIMEOUT;
            fax2_sub_state = CONFIGURE_RX_DATA;
            break;
        case CONFIGURE_RX_DATA: /* configure receive data while looking for V.21 */
            switch (fax2_configure_rx_data(EXECUTE))
            {
                case DETECTED_DATA:
                    fax2_tries = 3; /* reset retry count */
                    fax2_data_expected = FALSE; /* reset error indication flag */
                    fax2_FDR_received = FALSE; /* wait for +FDR command */
                    fax2_local_generated_interrupt = FALSE;/* no procedure if */
                    /* allow EOM command/response bypassing */
                    fax2_page_data_received = TRUE;
                    if (fax2_DCS_count > 1) /* if more than one DCS received */
                        fax2_response(DCS_RESPONSE, NULL); /* indicate last DCS */
                    /* indicate "CONNECT" to prepare the APP for received data
                    if not in ECM; otherwise, let ECM handle CONNECT message (since
                    some Phase C initiations are transparent to the APP) */
                    if (!fax2_negotiated.EC)
                        fax2_response(CONNECT_RESPONSE, NULL);
                    /* transition to phase C 2388, 592 or ECM */
                    fax2_state = PHASE_C_RECEIVE;
                    fax2_sub_state = WAIT_FOR_DC2;
                    break;
                case DETECTED_COMMAND:
                    /* V.21 detected, configure to receive a command */
                    fax2_sub_state = RX_COMMAND;
                    break;
                case STILL_LOOKING: /* no carrier detected */
                    if (!fax2_T2_timer) /* if T2 expired */
                    {
                        fax2_configure_rx_data(ABORT); /* terminate configuration */
                        if (fax2_EOM_processing) /* if delaying after EOM */
                            fax2_sub_state = INITIALIZE; /* start at T.30 (R) */
                        /* if ECM running try three times */
                        else if (fax2_negotiated.EC && --fax2_tries)
                            fax2_sub_state = RX_COMMAND_OR_DATA;
                        else /* transmitter disappeared, so terminate */
                        {
                            fax2_state = PHASE_E;
                            fax2_sub_state = TERMINATE;
                            fax2_hangup_status = fax2_data_expected ?
                                                 RX_B_T2_TIMEOUT_ERROR :
                                                 RX_B_COMREC_ERROR;
                        }
                    }
                    break;
            }
            break;
        case RX_COMMAND: /* V.21 detected, configure to receive command */
            switch (fax2_command_receive(EXECUTE))
            {
                case NO_COMMAND: /* still looking for command */
                    if (!fax2_T2_timer) /* if T2 expired */
                    {
                        fax2_command_receive(ABORT); /* terminate configuration */
                        if (fax2_EOM_processing) /* if delaying after EOM */
                            fax2_sub_state = INITIALIZE; /* start at T.30 (R) */
                        /* if ECM running try three times */
                        else if (fax2_negotiated.EC && --fax2_tries)
                            fax2_sub_state = RX_COMMAND_OR_DATA;
                        else /* transmitter disappeared, so terminate */
                        {
                            fax2_state = PHASE_E;
                            fax2_sub_state = TERMINATE;
                            fax2_hangup_status = fax2_data_expected ?
                                                 RX_B_T2_TIMEOUT_ERROR :
                                                 RX_B_COMREC_ERROR;
                        }
                    }
                case PROCESSING: /* can not abort in this state */
                    /* there will be a transition out of this state */
                    break;
                case RECEIVED_COMMAND: /* got one */
                    fax2_tries = 3; /* reset number of tries for next time */
                    fax2_data_expected = FALSE; /* next (F) looks for command */
                    fax2_sub_state = ROUTE_COMMAND; /* route the received command */
                    break;
                case TERMINATE_SESSION: /* DCN received or larger than 3 sec */
                    fax2_state = PHASE_E;
                    fax2_sub_state = TERMINATE;
                    /* if expecting a DCN then we terminated properly */
                    if (fax2_packet_opcode == DCN_PACKET && fax2_DCN_expected)
                        fax2_hangup_status = PROPER_END_OF_CONNECTION;
                    /* if DCN in response to a procedure interrupt request */
                    else if (fax2_packet_opcode == DCN_PACKET &&
                        fax2_local_generated_interrupt)
                        fax2_hangup_status = RX_D_UNABLE_PIP_PIN_ERROR;
                    else
                        /* packet not expected */
                        fax2_hangup_status = RX_B_RSPREC_ERROR;
                    break;
            }
            break;
        case ROUTE_COMMAND: /* just past command receive from state (F) */
            switch (fax2_packet_opcode) /* figure command or go to phase D */
            {
                case DTC_PACKET: /* remote would like to poll */
                    /* do not indicate a document to transmit in next DIS */
                    fax2_capability_transmit_poll = FALSE;
                    /* command not received */
                    fax2_received_command = EMPTY_COMMAND;
                    /* switch to transmit T.30 (D) state */
                    fax2_state = PHASE_B_TRANSMIT;
                    fax2_sub_state = PROCESS_COMMAND;
                    break;
                case DIS_PACKET:
                    /* received a valid DIS, indicate bit in opcodes */
                    fax2_received_valid_DIS = 1;
                    /* command not received */
                    fax2_received_command = EMPTY_COMMAND;
                    /* switch to transmit T.30 (A) state */
                    fax2_state = PHASE_B_TRANSMIT;
                    fax2_sub_state = PROCESS_COMMAND;
                    break;
                case DCS_PACKET:
                    /* keep track of DCS count for response purposes */
                    fax2_DCS_count++;
                    fax2_accept_DCS(); /* get negotiated T.30 parameters */
                    if (fax2_DCS_count == 1) /* if first DCS */
                    {
                        fax2_response(DCS_RESPONSE, NULL); /* send APP response */
                        /* if EOM was received as a post page command */
                        if (fax2_EOM_processing && fax2_page_data_received)
                            fax2_received_command = FDR_COMMAND;
                        else
                        {
                            fax2_received_command = EMPTY_COMMAND; /* wait FDR */
                            return_code = GOTO_PARSE_OK; /* respond with OK */
                        }
                    }
                    else
                        /* fake receiving an FDR command */
                        fax2_received_command = FDR_COMMAND;
                    fax2_sub_state = RX_TCF; /* get ready to receive TCF */
                    break;
                default: /* must be a command for phase D */
                    fax2_state = PHASE_D_RECEIVE;
                    fax2_sub_state = ROUTE_COMMAND;
                    break;
            }
            /* not processing EOM so look for +FDR next time */
            fax2_EOM_processing = FALSE;
            break;
        case RX_TCF:
            if (fax2_receive_TCF()) /* process receiving TCF */
                /* if FDR received chaeck TCF, otherwise wait for command */
                fax2_sub_state = fax2_received_command == FDR_COMMAND ?
                                 CHECK_TCF : WAIT_FOR_FDR;
            /* if FDR received stay online, otherwise stay parsing */
            if (fax2_received_command != FDR_COMMAND)
                return_code = STAY_PARSE;
            break;
        case WAIT_FOR_FDR:
            if (fax2_received_command == FDR_COMMAND) /* if FDR command received */
                fax2_sub_state = CHECK_TCF; /* chaeck TCF quality */
            else
                return_code = STAY_PARSE;
            break;
        case CHECK_TCF:
            if (fax2_TCF_ok()) /* was the line quality OK */
            {
                fax2_schedule_tx_packet(CFR_PACKET, UNUSED); /* send a positive response */
                if (fax2_class == STANDARD_2388 && fax2_respond_TCF_OK)
                {
                    /* indicate a positive TCF reception to the APP */
                    fax2_response(CFR_RESPONSE, NULL);
                    fax2_respond_TCF_OK = FALSE; /* respond only once */
                }
                fax2_data_expected = TRUE; /* expecting to receive data */
            }
            else
                fax2_schedule_tx_packet(FTT_PACKET, UNUSED); /* send negative indication */
            fax2_sub_state = TX_TCF_RESPONSE; /* send the response */
            break;
        case TX_TCF_RESPONSE:
            if (fax2_transmit_packet()) /* configure and transmit */
            {
                /* do not allow NSS and TSI indications to the APP */
                fax2_process_optional_packets = FALSE;
                fax2_sub_state = RX_COMMAND_OR_DATA; /* get page or DCS again */
            }
            break;
    }
    return(return_code);
}

/******************************************************************************
/
/   Routine: fax2_phaseD_receive
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will implement the class 2 T.30 phase D receive
/                functions.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/
/   Global Variables Changed: Class 2 FAX vairiables
/
/   Users: fax2_bg()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_phaseD_receive(void)
{
    ubyte return_code;

    return_code = STAY_ONLINE; /* default to staying online */

    switch (fax2_sub_state)
    {
        case ROUTE_COMMAND:
            switch (fax2_packet_opcode) /* decipher the received opcode */
            {
                case MPS_PACKET: /* multi-page send */
                    fax2_pp_command = MPS_PPC;
                    break;
                case EOM_PACKET: /* end of message */
                    fax2_pp_command = EOM_PPC;
                    break;
                case EOP_PACKET: /* end of procedure */
                    fax2_pp_command = EOP_PPC;
                    break;
                case PRI_MPS_PACKET: /* procedure interrupt MPS */
                    fax2_pp_command = PRI_MPS_PPC;
                    break;
                case PRI_EOM_PACKET: /* procedure interrupt EOM */
                    fax2_pp_command = PRI_EOM_PPC;
                    break;
                case PRI_EOP_PACKET: /* procedure interrupt EOP */
                    fax2_pp_command = PRI_EOP_PPC;
                    break;
                default: /* a DCN packet or an unexpected packet */
                    fax2_state = PHASE_E; /* terminate the protocol */
                    fax2_sub_state = TERMINATE;
                    /* packet not expected */
                    fax2_hangup_status = RX_D_RSPREC_ERROR;
                    return(STAY_ONLINE);
            }

            /* if not first time through phase D per this transmission */
            if (fax2_FDR_received)
            {
                /* don't wait for +FDR command to retransmit the post page response */
                fax2_sub_state = SCHEDULE_PP_RESPONSE;
                return(STAY_ONLINE);
            }
            else
                /* wait for +DFR command to send the post page response */
                fax2_FDR_received = TRUE;

            /* if procedure interrupt requested */
            if (fax2_pp_command > EOP_PPC)
                if (fax2_interrupts_enabled) /* if configured to accept */
                {
                    /* translate the post page response to indicate acceptance */
                    if (fax2_pp_response  == RTN_PPR) /* if a negative response */
                        fax2_pp_response = PIN_PPR; /* translate accordingly */
                    else /* else it's a positive response. this includes RTP */
                        fax2_pp_response = PIP_PPR;
                }
                else /* not configured to accept procedure interrupts */
                    fax2_pp_command -= 3; /* translate PPC to a non pri-Q */

            /* indicate post page command received to the APP */
            fax2_response(PPC_RESPONSE, NULL);
            /* allow the APP to change the post page response before sending it */
            fax2_sub_state = WAIT_FOR_FDR;
            fax2_received_command = EMPTY_COMMAND;
            /* if +FCLASS=2.0 indicate if response is positive or negative */
            if (fax2_class == STANDARD_592 &&
                (fax2_pp_response == RTN_PPR || fax2_pp_response == PIN_PPR))
                return_code = GOTO_PARSE_ERROR;
            else
                /* +FCLASS=2 always indicates an OK */
                return_code = GOTO_PARSE_OK;
            break;
        case WAIT_FOR_FDR:
            /* look for command to send the post page response */
            if (fax2_received_command == FDR_COMMAND)
                fax2_sub_state = SCHEDULE_PP_RESPONSE;
            else
                return_code = STAY_PARSE; /* keep waitting for command */
            break;
        case SCHEDULE_PP_RESPONSE:
            /* get the response opcode and schedule the packet for transmission */
            fax2_schedule_tx_packet(fax2_ppr_table[fax2_pp_response], UNUSED);
            fax2_sub_state = TX_PP_RESPONSE;
            break;
        case TX_PP_RESPONSE:
            if (fax2_transmit_packet()) /* configure and transmit */
                switch (fax2_pp_response) /* according to the response */
                {
                    case MCF_PPR: /* if page was accepted */
                        /* This will allow for a DCS/OK response and wait */
                        /* for a +FDR at the reception of the next DCS packet */
                        fax2_DCS_count = 0; /* reset DCS count */
                        /* allow the +FCFR response */
                        fax2_respond_TCF_OK = TRUE;
                        /* allow for NSS and TSI on next round */
                        fax2_process_optional_packets = TRUE;
                        /* if procedure interrupts were enabled but the APP */
                        /* decided to change the ppr before transmission */
                        switch (fax2_pp_command % 3)
                        {
                            case EOP_PPC:
                                fax2_DCN_expected = TRUE; /* looking for DCN */
                                break;
                            case MPS_PPC:
                                fax2_data_expected = TRUE; /* look next page */
                                break;
                            case EOM_PPC:
                                /* delay 6 seconds and send a DIS block */
                                fax2_EOM_processing = TRUE;
                                break;
                        }
                        /* no break intentionaly */
                    case RTP_PPR: /* will be expecting a new DCS for retrain */
                    case RTN_PPR: /* will be expecting a new DCS for retrain */
                        fax2_state = PHASE_B_RECEIVE; /* phase B state (F) */
                        fax2_sub_state = RX_COMMAND_OR_DATA;
                        break;
                    case PIP_PPR:
                    case PIN_PPR:
                        /* if a local interrupt was just initiated */
                        if (fax2_local_generated_interrupt)
                        {
                            /* wait for the remote response */
                            fax2_local_generated_interrupt = FALSE;
                            fax2_state = PHASE_B_RECEIVE; /* phase B state (F) */
                            fax2_sub_state = RX_COMMAND_OR_DATA;
                        }
                        else /* remote interrupt generated, or */
                             /* response to remote interrupt acknowledge */
                        {
                            /* indicate a procedure interrupt established (VOICE) */
                            fax2_response(VOICE_RESPONSE, NULL);
                            fax2_state = IDLE; /* idle waitting for an ATA or an ATD */
                            return_code = GOTO_PARSE_OK;
                        }
                        break;
                }
            break;
    }
    return(return_code);
}

/******************************************************************************
/
/   Routine: fax2_phaseB_transmit
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will implement the class 2 T.30 phase B transmit
/                functions.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/
/   Global Variables Changed: Class 2 FAX vairiables
/
/   Users: fax2_bg()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_phaseB_transmit(void)
{
    ubyte return_code;

    return_code = STAY_ONLINE;

    switch (fax2_sub_state)
    {
        /* T.30 (T) state */
        case INITIALIZE: /* setup T.30 T1 timer for establishing phase B */
            fax2_T1_timer = T1_TIMEOUT;
            fax2_sub_state = RX_COMMAND;
            if (fax2_EOM_processing) /* if EOM then we're looking for a command */
                return_code = STAY_PARSE;
            break;
        case RX_COMMAND:
            /* configure to receive a command */
            switch (fax2_command_receive(EXECUTE))
            {
                case NO_COMMAND: /* still looking for command */
                    if (!fax2_T1_timer) /* if T2 expired */
                    {
                        /* transmitter disappeared */
                        fax2_command_receive(ABORT); /* terminate configuration */
                        fax2_state = PHASE_E; /* hangup connection */
                        fax2_sub_state = TERMINATE;
                        fax2_hangup_status = TX_A_T1_TIMEOUT_ERROR;
                        /* if waitting for a command after EOM */
                        if (fax2_EOM_processing && !fax2_received_command)
                        {
                            /* quit parse and go back online */
                            /* configure DTE port next time into background */
                            fax2_configure_dte = NO_FLOW;
                            return(GOTO_ONLINE_BG);
                        }
                    }
                case PROCESSING: /* can not abort in this state */
                    /* there will be a transition out of this state */
                    break;
                case RECEIVED_COMMAND: /* got one */
                    fax2_sub_state = PROCESS_COMMAND;
                    break;
                case TERMINATE_SESSION: /* DCN received or larger than 3 sec */
                    fax2_state = PHASE_E;
                    fax2_sub_state = TERMINATE;
                    fax2_hangup_status = TX_B_COMREC_ERROR;
                    /* if waitting for a command after EOM */
                    if (fax2_EOM_processing && !fax2_received_command)
                    {
                        /* quit parse and go back online */
                        /* configure DTE port next time into background */
                        fax2_configure_dte = NO_FLOW;
                        return(GOTO_ONLINE_BG);
                    }
                    break;
            }
            /* if still looking for a command after an EOM */
            if (fax2_EOM_processing && !fax2_received_command)
                return_code = STAY_PARSE;
            break;
        case PROCESS_COMMAND:
            /* we're looking for a DIS or DTC */
            if (fax2_packet_opcode == DIS_PACKET ||
                fax2_packet_opcode == DTC_PACKET)
            {
                if (fax2_packet_opcode == DIS_PACKET)
                    /* this sets the valid DIS received bit in most opcodes */
                    fax2_received_valid_DIS = 1;
                /* don't process a DIS if received after an EOM */
                if (!fax2_EOM_processing)
                {
                    /* translate DIS/DTC packet into a class 2 parameter format */
                    fax2_translate_DIS_DTC();
                    /* send DIS or DTC indication to the APP */
                    fax2_response(fax2_packet_opcode == DIS_PACKET ?
                                  DIS_RESPONSE : DTC_RESPONSE, NULL);
                    /* if we want to poll and the remote has a document to be */
                    /* polled and we have the capability to receive */
                    if (fax2_capability_receive_poll &&
                        fax2_remote_indicated_poll && fax2_capability_receive)
                        /* indicate a document to poll */
                        fax2_response(POLL_RESPONSE, NULL);
                    /* Do not check the receive capability bit. Rockwell does */
                    /* not set this bit, and their modems work with fax machiens */
                    /* else if (!fax2_remote_indicated_receive)
                    {
                           if we're not polling and the remote doesn't have
                           receive capabilities we're Incompatable, so disconnect
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;    send DCN packet
                        fax2_hangup_status = TX_B_NO_TX_RX_ERROR;
                        return(STAY_ONLINE);
                    } */
                    /* respont with OK and wait for a goahead command */
                    fax2_received_command = EMPTY_COMMAND;
                    return_code = GOTO_PARSE_OK;
                }
                fax2_sub_state = WAIT_FOR_FDT_FDR;
            }
            else /* not a DIS or a DTC. packet not expected. T.30 says hangup */
            {
                fax2_state = PHASE_E;
                fax2_sub_state = TERMINATE;
                fax2_hangup_status = TX_B_COMREC_INVALID_COMMAND_ERROR;
                /* if looking for a command go back online to disconnect */
                if (fax2_EOM_processing && !fax2_received_command)
                {
                    /* next time into fax2_bg() reconfigure the DTE port */
                    fax2_configure_dte = NO_FLOW;
                    return(GOTO_ONLINE_BG);
                }
            }
                break;
        case WAIT_FOR_FDT_FDR:
            switch (fax2_received_command) /* wait for an +FDT or +FDR command */
            {
                case EMPTY_COMMAND: /* no command received yet */
                    return_code = STAY_PARSE;
                    break;
                case FDT_COMMAND:
                    /* no need to keeptrack of EOM */
                    fax2_EOM_processing = FALSE;
                    /* negotiate transmission parameters */
                    fax2_accept_DIS_DTC();
                    /* send a DCS block in response to the DIS */
                    fax2_sub_state = SCHEDULE_DCS_BLOCK;
                    /* make sure negotiated speed meets minimum requirements */
                    if ((fax2_negotiated.BR > BR_14400 ? fax2_negotiated.BR-4 :
                        fax2_negotiated.BR) < fax2_minimum_speed)
                    {
                        /* if too slow then send a DCN and hangup */
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        fax2_hangup_status = TX_B_COMREC_INVALID_COMMAND_ERROR;
                    }
                    break;
                case FDR_COMMAND:
                    /* no need to keeptrack of EOM */
                    fax2_EOM_processing = FALSE;
                    /* we'd like to poll a document */
                    /* send a DTC in response to the DIS */
                    fax2_send_DTC = TRUE; /* indicate DTC instead of DIS */
                    fax2_state = PHASE_B_RECEIVE;
                    fax2_sub_state = INITIALIZE;
                    break;
            }
            break;
        case SCHEDULE_DCS_BLOCK:
            /* transmit the DCS block */
            if (fax2_nonstandard_string[0])
                fax2_schedule_tx_packet(NSS_PACKET, UNUSED); /* non-standard */
            if (fax2_local_id_string[0])
                fax2_schedule_tx_packet(TSI_PACKET, UNUSED); /* local ID */
            fax2_schedule_tx_packet(DCS_PACKET, UNUSED); /* negotiated parameters */
            fax2_sub_state = TX_DCS_BLOCK;
            break;
        case TX_DCS_BLOCK:
            if (fax2_transmit_packet()) /* configure and transmit */
                fax2_sub_state = TX_TCF;
            break;
        case TX_TCF:
            if (fax2_transmit_TCF()) /* configure and transmit the TCF */
                fax2_sub_state = RX_TCF_RESPONSE;
            break;
        case RX_TCF_RESPONSE:
            /* receive a response to the TCF */
            switch (fax2_response_receive())
            {
                case PROCESSING: /* looking for packet */
                    break;
                case RECEIVED_RESPONSE: /* non-optional packet received */
                    fax2_sub_state = ROUTE_RESPONSE;
                    break;
                case NO_RESPONSE: /* T4 timeout or flags w/o proper packet */
                    if (--fax2_tries) /* check number of attempts */
                        fax2_sub_state = SCHEDULE_DCS_BLOCK;
                    else
                    {
                        /* tried three times with no response */
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        fax2_hangup_status = TX_B_3DCS_NO_RESPONSE_ERROR;
                    }
                    break;
                case TRANSMIT_DCN: /* packet larger than 3 sec */
                    fax2_state = PHASE_E;
                    fax2_sub_state = SCHEDULE_DCN_PACKET; /* transmit DCN */
                    fax2_hangup_status = TX_B_RSPREC_ERROR;
                    break;
                case TERMINATE_SESSION: /* DCN received, terminate w/o DCN */
                    fax2_state = PHASE_E;
                    fax2_sub_state = TERMINATE;
                    fax2_hangup_status = TX_B_RSPREC_ERROR;
                    break;
            }
            break;
        /* T.30 after box "transmit phasing/training TCF" */
        case ROUTE_RESPONSE:
            switch (fax2_packet_opcode) /* according to opcode received */
            {
                case DIS_PACKET: /* DCS block not received, so retransmit it */
                    /* this sets the valid DIS received bit in most opcodes */
                    fax2_received_valid_DIS = 1;
                case DTC_PACKET: /* DCS block not received, so retransmit it */
                    fax2_tries = 3;
                    if (--fax2_tries_DIS) /* check number of tries is within range */
                    {
                        /* negotiate the parameters in the DIS to form the DCS */
                        fax2_accept_DIS_DTC();
                        fax2_sub_state = SCHEDULE_DCS_BLOCK;
                    }
                    else /* three tries and no success, T.30 says to send a DCN */
                    {
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        fax2_hangup_status = TX_B_3DIS_DTC_NO_DCS_ERROR;
                    }
                    break;
                case FTT_PACKET: /* remote not very happy with TCF */
                    /* check to see if the speed can be reduced */
                    if ((fax2_negotiated.BR > BR_14400 ? fax2_negotiated.BR-4 :
                        fax2_negotiated.BR) > fax2_minimum_speed)
                    {
                        /* reset the number of tries at the lowest speed */
                        fax2_tries = 3;
                        fax2_tries_DIS = 3;
                        /* if falling from V.17 7200, go to v.27 4800 */
                        if (--fax2_negotiated.BR == BR_14400)
                            fax2_negotiated.BR = BR_4800;
                        /* send the DCS block followed by th TCF */
                        fax2_sub_state = SCHEDULE_DCS_BLOCK;
                    }
                    else if (--fax2_tries) /* decrement the number of tries */
                    {
                        /* if not zero then try again at the same speed */
                        fax2_sub_state = SCHEDULE_DCS_BLOCK;
                    }
                    else
                    {
                        /* it doesn't look good for our hero */
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        fax2_hangup_status = TX_B_FAILURE_TO_TRAIN_ERROR;
                    }
                    break;
                case CFR_PACKET: /* remote accepted */
                    fax2_tries = 3; /* reset the number of tries */
                    fax2_tries_DIS = 3;
                    /* indicateto the APP the DCS received by the remote */
                    fax2_response(DCS_RESPONSE, NULL);
                    /* transition to phase C transmit */
                    fax2_state = PHASE_C_TRANSMIT;
                    fax2_sub_state = CONFIGURE_TX_DATA;
                    break;
                default: /* unexpected opcode, send a DCN and hangup */
                    fax2_state = PHASE_E;
                    fax2_sub_state = SCHEDULE_DCN_PACKET;
                    fax2_hangup_status = TX_B_RSPREC_INVALID_RESPONSE_ERROR;
                    break;
            }
            break;
    }
    return(return_code);
}

/******************************************************************************
/
/   Routine: fax2_phaseD_transmit
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will implement the class 2 T.30 phase D transmit
/                functions.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/
/   Global Variables Changed: Class 2 FAX vairiables
/
/   Users: fax2_bg()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_phaseD_transmit(void)
{
    ubyte return_code;

    return_code = STAY_ONLINE; /* default to stay in online state */

    switch (fax2_sub_state)
    {
        case SCHEDULE_PP_COMMAND:
            /* queue up to send the post page command */
            fax2_schedule_tx_packet(fax2_ppc_table[fax2_pp_command], UNUSED);
            fax2_sub_state = TX_PP_COMMAND;
            break;
        case TX_PP_COMMAND:
            if (fax2_transmit_packet()) /* configure and transmit */
                fax2_sub_state = RX_PP_RESPONSE;
            break;
        case RX_PP_RESPONSE:
            /* look to receive the post page response */
            switch (fax2_response_receive())
            {
                case PROCESSING: /* looking for a packet */
                    break;
                case RECEIVED_RESPONSE: /* non-optional packet received */
                    fax2_tries = 3; /* reset the number of tries */
                    /* act on the post page response */
                    fax2_sub_state = PROCESS_PP_RESPONSE;
                    /* translate the pp response into class 2 terminology */
                    switch (fax2_packet_opcode)
                    {
                        case MCF_PACKET: /* message confermation */
                            fax2_pp_response = MCF_PPR;
                            break;
                        case RTN_PACKET: /* retrain negative */
                            fax2_pp_response = RTN_PPR;
                            break;
                        case RTP_PACKET: /* retrain positive */
                            fax2_pp_response = RTP_PPR;
                            break;
                        case PIN_PACKET: /* procedure interrupt negative */
                            fax2_pp_response = PIN_PPR;
                            break;
                        case PIP_PACKET: /* procedure intrrupt positive */
                            fax2_pp_response = PIP_PPR;
                            break;
                        default: /* not a proper response */
                            fax2_state = PHASE_E;
                            fax2_sub_state = SCHEDULE_DCN_PACKET;
                            /* the hangup status depends on the PP command */
                            switch (fax2_pp_command % 3) /* translate pri-Q */
                            {
                                case MPS_PPC:
                                    fax2_hangup_status =
                                    TX_D_INVALID_RESPONSE_MPS_ERROR;
                                    break;
                                case EOP_PPC:
                                    fax2_hangup_status =
                                    TX_D_INVALID_RESPONSE_EOP_ERROR;
                                    break;
                                case EOM_PPC:
                                    fax2_hangup_status =
                                    TX_D_INVALID_RESPONSE_EOM_ERROR;
                                    break;
                            }
                            break;
                    }
                    if (fax2_state != PHASE_E && fax2_class == STANDARD_2388)
                        /* indicate the type of post page response to the APP */
                        fax2_response(FPTS_RESPONSE, NULL);
                    break;
                case NO_RESPONSE: /* T4 timeout or flags w/o proper packet */
                    if (--fax2_tries) /* check number of attempts */
                        fax2_sub_state = SCHEDULE_PP_COMMAND;
                    else
                    {
                        /* tried three times with no response */
                        fax2_state = PHASE_E;
                        fax2_sub_state = SCHEDULE_DCN_PACKET;
                        /* the hangup status depends on the PP command */
                        switch (fax2_pp_command % 3)
                        {
                            case MPS_PPC:
                                fax2_hangup_status = TX_D_NO_RESPONSE_MPS_ERROR;
                                break;
                            case EOP_PPC:
                                fax2_hangup_status = TX_D_NO_RESPONSE_EOP_ERROR;
                                break;
                            case EOM_PPC:
                                fax2_hangup_status = TX_D_NO_RESPONSE_EOM_ERROR;
                                break;
                        }
                    }
                    break;
                case TRANSMIT_DCN: /* packet larger than 3 sec */
                    fax2_state = PHASE_E;
                    fax2_sub_state = SCHEDULE_DCN_PACKET;
                    fax2_hangup_status = TX_D_RSPREC_ERROR;
                    break;
                case TERMINATE_SESSION: /* DCN received, terminate w/o DCN */
                    fax2_state = PHASE_E;
                    fax2_sub_state = TERMINATE;
                    fax2_hangup_status = TX_D_RSPREC_ERROR;
                    break;
            }
            break;
        case PROCESS_PP_RESPONSE: /* act appropriately to the post page response */
            switch (fax2_pp_response)
            {
                case PIP_PPR:
                case PIN_PPR:
                    /* if procedure interrupt and we initiated it or */
                    /* the remote started it and we accept procedure interrupts */
                    if (fax2_pp_command > EOP_PPC || fax2_interrupts_enabled)
                    {
                        /* respond to remote with a procedure interrupt */
                        /* version of the post page command previously sent */
                        if (fax2_pp_command <= EOP_PPC)
                            fax2_pp_command+= 3;
                        fax2_sub_state = SCHEDULE_PRIQ;
                    }
                    else if (fax2_pp_response == PIN_PPR)
                         /* remote initiated a procedure interrupt, */
                         /* we're not configured to accept it, */
                         /* and the page was in error */
                    {
                        /* check to see if the speed can be reduced */
                        if ((fax2_negotiated.BR > BR_14400 ? fax2_negotiated.BR-4 :
                            fax2_negotiated.BR) > fax2_minimum_speed)
                        {
                            /* if falling from V.17 7200, go to v.27 4800 */
                            if (--fax2_negotiated.BR == BR_14400)
                                fax2_negotiated.BR = BR_4800;
                        }
                        /* resend the DCS block the TCF and the page */
                        fax2_next_state = PHASE_B_TRANSMIT;
                        fax2_next_sub_state = SCHEDULE_DCS_BLOCK;
                        fax2_sub_state = WAIT_FOR_FDT;
                        fax2_received_command = EMPTY_COMMAND;
                        /* indicate ERROR since the page was not accepted */
                        return_code = GOTO_PARSE_ERROR;
                    }
                    else
                         /* remote initiated a procedure interrupt, */
                         /* we're not configured to accept it, */
                         /* and the page was received OK */
                    {
                        switch (fax2_pp_command)
                        {
                            case MPS_PPC:
                                /* resend the DCS block and TCF */
                                fax2_next_state = PHASE_B_TRANSMIT;
                                fax2_next_sub_state = SCHEDULE_DCS_BLOCK;
                                /* wait for the +FDT command to continue */
                                fax2_sub_state = WAIT_FOR_FDT;
                                fax2_received_command = EMPTY_COMMAND;
                                /* respone with OK, the +FPTS already indicated */
                                /* the post page response received */
                                return_code = GOTO_PARSE_OK;
                                break;
                            case EOM_PPC:
                                /* the page was accepted but we have another */
                                /* document to send/receive. Wait for +FDT/+FDR */
                                fax2_EOM_processing = TRUE; /* indicate parse state */
                                fax2_state = PHASE_B_TRANSMIT;
                                fax2_sub_state = WAIT_FOR_FDT_FDR;
                                /* clear received command flag */
                                fax2_received_command = EMPTY_COMMAND;
                                /* respond with OK and wait for a goahead command */
                                return_code = GOTO_PARSE_OK;
                                break;
                            case EOP_PPC:
                                /* no more documents to send, send a DCN */
                                fax2_state = PHASE_E;
                                fax2_sub_state = SCHEDULE_DCN_PACKET;
                                fax2_hangup_status = PROPER_END_OF_CONNECTION;
                                break;
                        }
                    }
                    break;
                case MCF_PPR: /* message conformation */
                case RTP_PPR: /* retrain positive */
                    switch (fax2_pp_command % 3)
                    {
                        case MPS_PPC: /* we have more pages to send */
                            /* if the last page was accepted */
                            if (fax2_pp_response == MCF_PPR)
                            {
                                /* go back to phase C to send the next one */
                                fax2_next_state = PHASE_C_TRANSMIT;
                                fax2_next_sub_state = CONFIGURE_TX_DATA;
                            }
                            else
                            {
                                /* resend the DCS block and TCF */
                                fax2_next_state = PHASE_B_TRANSMIT;
                                fax2_next_sub_state = SCHEDULE_DCS_BLOCK;
                            }
                            /* wait for the +FDT command to continue */
                            fax2_sub_state = WAIT_FOR_FDT;
                            fax2_received_command = EMPTY_COMMAND;
                            /* respone with OK, the +FPTS already indicated */
                            /* the post page response received */
                            return_code = GOTO_PARSE_OK;
                            break;
                        case EOP_PPC: /* end of procedure */
                            /* since the remote accepted the page and there */
                            /* are no more pages or documents to send */
                            /* we'll send a disconnect packet and hangup */
                            fax2_state = PHASE_E;
                            fax2_sub_state = SCHEDULE_DCN_PACKET;
                            fax2_hangup_status = PROPER_END_OF_CONNECTION;
                            break;
                        case EOM_PPC: /* end of message */
                            /* the page was accepted but we have another */
                            /* document to send. Go to state (T) */
                            fax2_EOM_processing = TRUE; /* indicate parse state */
                            fax2_state = PHASE_B_TRANSMIT;
                            fax2_sub_state = INITIALIZE;
                            /* clear received command flag */
                            fax2_received_command = EMPTY_COMMAND;
                            /* respond with OK and wait for a goahead command */
                            /* while receiving the DIS block */
                            return_code = GOTO_PARSE_OK;
                            break;
                    }
                    break;
                case RTN_PPR: /* retrain negative (i.e. remote didn't like */
                              /* the quality of the page */
                    /* check to see if the speed can be reduced */
                    if ((fax2_negotiated.BR > BR_14400 ? fax2_negotiated.BR-4 :
                        fax2_negotiated.BR) > fax2_minimum_speed)
                    {
                        /* if falling from V.17 7200, go to v.27 4800 */
                        if (--fax2_negotiated.BR == BR_14400)
                            fax2_negotiated.BR = BR_4800;
                    }
                    /* resend the DCS block the TCF and the page */
                    fax2_next_state = PHASE_B_TRANSMIT;
                    fax2_next_sub_state = SCHEDULE_DCS_BLOCK;
                    fax2_sub_state = WAIT_FOR_FDT;
                    fax2_received_command = EMPTY_COMMAND;
                    /* indicate ERROR since the page was not accepted */
                    return_code = GOTO_PARSE_ERROR;
                    break;
            }
            break;
        case SCHEDULE_PRIQ:
            /* complete the procedure interrupt negotiation */
            fax2_schedule_tx_packet(fax2_ppc_table[fax2_pp_command], UNUSED);
            fax2_sub_state = TX_PRIQ;
            break;
        case TX_PRIQ:
            if (fax2_transmit_packet()) /* configure and transmit */
            {
                /* indicate a procedure interrupt established (VOICE) */
                fax2_response(VOICE_RESPONSE, NULL);
                fax2_state = IDLE; /* idle waitting for an ATA or an ATD */
                /* indicate acceptance or rejection of the page */
                return_code = fax2_pp_response == PIN_PPR ?
                              GOTO_PARSE_ERROR : GOTO_PARSE_OK;
            }
            break;
        case WAIT_FOR_FDT: /* wait for a +FDT to continue with the protocol */
            if (fax2_received_command == FDT_COMMAND)
            {
                /* assign the previously determined T.30 state */
                fax2_state = fax2_next_state;
                fax2_sub_state = fax2_next_sub_state;
                return_code = STAY_ONLINE;
            }
            else
                return_code = STAY_PARSE;
            break;
    }
    /* the 2388 version always respond with OK */
    if (return_code == GOTO_PARSE_ERROR && fax2_class == STANDARD_2388)
        return_code = GOTO_PARSE_OK;
    return(return_code);
}

/******************************************************************************
/
/   Routine: fax2_phaseE
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will implement the class 2 T.30 phase E functions.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    return code
/                      0        Stay online
/                      1        Stay in the parse state
/                      2        Go to parse and respond with
/                               OK message.
/                      3        Go to parse and respond with
/                               NO CARRIER message.
/                      4        Go to parse and respond with
/                               ERROR message.
/                      5        Go to hangup connection
/                      6        Go to online
/                      7        Go to parse and respond with
/                               FCERROR message.
/
/   Global Variables Changed: Class 2 FAX vairiables
/
/   Users: fax2_bg()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_phaseE(void)
{
    ubyte return_code;

    return_code = STAY_ONLINE; /* default to stay online */

    switch (fax2_sub_state)
    {
        /* T.30 (B) state */
        case SCHEDULE_DCN_PACKET:
            fax2_connected = FALSE; /* indicate connection terminated */
            fax2_schedule_tx_packet(DCN_PACKET, UNUSED); /* setup sending a DCN */
            fax2_sub_state = TX_DCN_PACKET;
            break;
        case TX_DCN_PACKET:
            if (fax2_transmit_packet()) /* configure and transmit */
                fax2_sub_state = TERMINATE;
            break;
        /* T.30 (C) state */
        case TERMINATE:
            fax2_connected = FALSE; /* indicate connection terminated */
            fax2_response(HANGUP_RESPONSE, NULL); /* indicate hangup cause */
            fax2_state = IDLE;
            /* holding place so the variable doesn't float and confuse debugging */
            fax2_sub_state = INITIALIZE;
            return_code = GOTO_HANGUP; /* request the ACU to process a hangup */
            break;
    }
    return(return_code);
}

