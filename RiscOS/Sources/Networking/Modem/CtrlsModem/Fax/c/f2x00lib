/****************************************************************************
/
/   Copyright, 1991,1992,1993,1994,1995.
/       All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File: f2x00lib.c
/
/   Module Version: 4.03
/
/   Function: This file contains routines which implement the T30 protocol
/             needed for fax class 2 (TIA/EIA PS-2388 and 592). These routines
/             are sub-functions used by the higher level T.30 functions.
/
/   Product: FAX class 2 core code
/
/   History: fx00lib2.c 3.99
/
/   Created: 9/21/92
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
****************************************************************************/
#include "sys_def.h"

#include "f2x_def.h"
#include "f2x_mem.h"
#include "f2x_pro.h"
#include "f2x_ecd.h"

/* Functions defined in this file. Needed by some compilers */
void fax2_connect(ubyte);
void fax2_configure(ubyte, ubyte, ubyte, ubyte);
void fax2_timer(void);
ubyte *fax2_tx(void);
ubyte *fax2_rx(void);
void fax2_init(ubyte);
void fax2_hangup(void);
void fax2_cleanup(void);
ubyte fax2_determine_mod(ubyte);
ubyte fax2_hex_a_to_d(ubyte *);
void fax2_hex_d_to_a(ubyte, ubyte *, ubyte *);
void fax2_dec_d_to_a(ubyte, ubyte *, ubyte *, ubyte *);
void fax2_respond_dec_byte(ubyte);
void fax2_store_dec_byte(ubyte, ubyte **);
void fax2_respond_hex_byte(ubyte);
void fax2_store_hex_byte(ubyte, ubyte **);
void fax2_respond_dec_word(uword);
void fax2_store_dec_word(uword, ubyte **);
void fax2_respond_hex_word(uword);
void fax2_store_hex_word(uword, ubyte **);
void fax2_respond_hex_string(hdlc_buffer_type *, ubyte);
void fax2_respond_string(ubyte *);
void fax2_respond_configuration(T30_parms_type *);
void fax2_store_configuration(T30_parms_type *, ubyte **);
void fax2_display_debug(ubyte, hdlc_buffer_type *);
void fax2_response(ubyte, hdlc_buffer_type *);
ubyte fax2_configure_tx_data(void);
ubyte fax2_transmit_TCF(void);
ubyte fax2_configure_rx_data(ubyte);
ubyte fax2_receive_TCF(void);
ubyte fax2_TCF_ok(void);
void fax2_send_RTC(void);
ubyte fax2_response_receive(void);
ubyte fax2_command_receive(ubyte);
ubyte fax2_transmit_packet(void);
void fax2_generate_CTC(hdlc_buffer_type *);
void fax2_generate_PPR(hdlc_buffer_type *);
void fax2_schedule_tx_packet(ubyte,ubyte);
void fax2_accept_DIS_DTC(void);
void fax2_translate_DIS_DTC(void);
void fax2_accept_DCS(void);
void fax2_generate_DIS_DTC(hdlc_buffer_type *);
void fax2_generate_DCS(hdlc_buffer_type *);
void fax2_accept_CTC(void);

/* start change 2/10/95 rjm */
static ubyte fax2_num_tx_packets;
/* end change 2/10/95 rjm */

/******************************************************************************
/
/   Routine: fax2_connect
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will start the class 2 fax after the
/                physical connection has been established.
/
/   Input Parameters: ubyte     direction
/                     0         answer
/                     1         originate
/
/   Output Parameters: none
/
/   Global Variables Changed: Many FAX 2 protocol variables
/
/   Users: ACU connection processing
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date:
/   Description:
/   Reason:
/
*******************************************************************************/
void fax2_connect(ubyte direction)
{

    fax2_connected = TRUE; /* FAX is considered connected */

    /* setup the state machine for the start of phase B */
    fax2_state = direction == ORIGINATE ? PHASE_B_TRANSMIT : PHASE_B_RECEIVE;
    fax2_sub_state = INITIALIZE;
    /* configure for no flow control */
    fax2_configure_dte = NO_FLOW;

    /* configure run time variables, but not the class 2 parameters */
    fax2_hangup_status = 0;             /* normal and proper hangup */
    fax2_pp_response = MCF_PPR;         /* post page response, page OK */
    fax2_pp_command = MPS_PPC;          /* post page command, multi-page */
    fax2_head_index = 0;                /* buffer queue head pointer */
    fax2_tail_index = 0;                /* buffer queue tail pointer */
    fax2_line_configured = FALSE;       /* line side not configured */
    fax2_utility_state = INITIALIZE;    /* utility state machines start state */
    fax2_received_valid_DIS = 0;        /* valid DIS bit in FCF */
    fax2_respond_FCON = TRUE;           /* indicate FAX connection at first flag */
    fax2_received_command = EMPTY_COMMAND;  /* no FAX command received */
    fax2_tries = 3;                     /* FAX tries are always three */
    fax2_tries_DIS = 3;                 /* FAX DIS receive tries for transmit */
    fax2_data_expected = FALSE;         /* T.30 state (F) not expecting dtata */
    fax2_DCN_expected = FALSE;          /* T.30 phase D is not expecting a DCN */
    fax2_send_DTC = FALSE;              /* send DIS and not DTC */
    fax2_EOM_processing = FALSE;        /* phse B processing not after an EOM */
    fax2_DCS_count = 0;                 /* APP response on first and last DCS */
    fax2_respond_TCF_OK = TRUE;         /* respond TCF acceptance to APP */
    fax2_local_generated_interrupt = FALSE; /* no localy requested interrupt */
    fax2_remote_generated_interrupt = FALSE; /* no remotely requested interrupt */
    fax2_process_optional_packets = TRUE;   /* indicate optional packets to APP */
    /* don't wait for +FDR command if phase D was entered before phase C */
    fax2_FDR_received = TRUE;
   /* don't allow EOM command/response bypassing until a data page is received */
   fax2_page_data_received = FALSE;

    /* initialize the negotiated T.30 parameters */
    fax2_negotiated.VR = 0;             /* normal resolution */
    fax2_negotiated.BR = 0;             /* 2400 bit rate */
    fax2_negotiated.WD = 0;             /* width 1728 pixels in215 mm */
    fax2_negotiated.LN = 0;             /* length A4 297 mm */
    fax2_negotiated.DF = 0;             /* data format 1-D */
    fax2_negotiated.EC = 0;             /* ECM disabled */
    fax2_negotiated.BF = 0;             /* BFT disabled */
    fax2_negotiated.ST = 0;             /* minimum scan time 0 ms */
    fax2_ECM_dte_bg_init_page();         /* Ensure this concurrent ECM is initially inactive*/
}

/******************************************************************************
/
/   Routine: fax2_configure
/
/   Author: RSA
/
/   Creation Date: 12/11/92
/
/   Description: This routine is called to inform the FAX module of
/                environment settings.
/
/   Input Parameters: ubyte     fclass
/                     0         data mode
/                     1         class 1 (TIA-578)
/                     2         class 2 (TIA-PN2388)
/                     20        class 2.0 (TIA-592)
/
/                     ubyte     response type
/                     0         numeric
/                     1         verbose
/
/                     ubyte     DTE baudrate
/                     2         300
/                     3         1200
/                     4         2400
/                     5         4800
/                     6         7200
/                     7         9600
/                     8         12000
/                     9         14400
/                     10        16800
/                     11        19200
/                     12        38400
/                     13        57600
/                     14        600
/                     15        115200
/
/                     ubyte     flow control
/                     0         no flow control
/                     1         XON/XOFF
/                     2         CTS/RTS
/                     3         XON/XOFF and CTS/RTS
/
/   Output Parameters: none
/
/   Global Variables Changed: fax2_response_type, fax2_dte_baud,
/                             fax2_flow_control
/
/   Users: fax_configure()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date:
/   Description:
/   Reason:
/
*******************************************************************************/
void fax2_configure(ubyte fclass, ubyte response_type, ubyte dte_baud, ubyte flow_control)
{
    fax2_class = fclass;                /* +FCLASS = 2 or 2.0 */
    fax2_response_type = response_type; /* <CR><LF>CONNECT<CR><LF> or <CR>1 */
    fax2_dte_baud = dte_baud;           /* DTE port baud rate */
    fax2_flow_control = flow_control;   /* DTE port flow control method */
}

/******************************************************************************
/
/   Routine: fax2_timer
/
/   Author: RSA
/
/   Creation Date: 12/11/92
/
/   Description: This routine is called every 10 ms to update FAX timer variables
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: fax2_T1_timer, fax2_T2_timer, fax2_T3_timer,
/                             fax2_T4_timer, fax2_utility_timer,
/                             fax2_interaction_timer
/
/
/   Users: fax_timer()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date:
/   Description:
/   Reason:
/
*******************************************************************************/
void fax2_timer(void)
{
    if (fax2_T1_timer)
        fax2_T1_timer--;
    if (fax2_T2_timer)
        fax2_T2_timer--;
    if (fax2_T3_timer)
        fax2_T3_timer--;
    if (fax2_T4_timer)
        fax2_T4_timer--;
    if (fax2_T5_timer)
        fax2_T5_timer--;
    if (fax2_utility_timer)
        fax2_utility_timer--;
    if (fax2_interaction_timer)
        fax2_interaction_timer--;
}

/******************************************************************************
/
/   Routine: fax2_init
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will initialize the class 2 parameters.
/
/   Input Parameters: ubyte     init_type
/                     0         powerup initialization
/                     1         AT&F or ATZ initialization
/                     2         AT+FIP initialization
/
/   Output Parameters: none
/
/   Global Variables Changed: Class 2 parameters.
/
/   Users: Powerup initialization, &F, Z and +FIP commands.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: 3/27/95 - mlc
/   Description: initialize the FAX2_NONSTANDARD_STRING to null
/   Reason: The string should be initialized to NULL so that an
/           NSF/NSS packet is not inadvertently transmitted. The
/           fax code looks for an empty string to determine
/           whether or not the NSF/NSS packet should be scheduled
/           for transmission.
/
*******************************************************************************/
void fax2_init(ubyte init_type)
{

    /* class 2.0 does not perform initialization with &F but class 2 does */
    if (init_type == INIT_AND_F && fax2_class == STANDARD_592)
        return;

    /* if modem init_type initialization */
    if (init_type != INIT_FIP)
    {
        fax2_ECM_dte_bg_init_page();   /* must be powerup initialized */
        fax2_state = IDLE;  /* class 2 FAX not active */
        /* holding place so the variable doesn't float and confuse debugging */
        fax2_sub_state = INITIALIZE;
        /* utility state machines always start at an initialization state */
        fax2_utility_state = INITIALIZE;
        fax2_connected = FALSE; /* FAX connection not in progress */
        fax2_configure_dte = FALSE; /* reset indication to configure in BG */
        fax2_class = 0; /* +FCLASS = 0 */
    }

    /* initialize all the class 2 parameters to their default settings */
    fax2_data_bit_ordering = DIRECT;
    fax2_hdlc_bit_ordering = DIRECT;
    fax2_interrupts_enabled = 0;
    fax2_capability_transmit_poll = 0;
    fax2_capability_receive_poll = 0; 
    fax2_capability_receive = 1;
    fax2_debug = FALSE;
    fax2_qc_rx = fax2_qc_installed_page();
    fax2_qc_tx = 0;
    fax2_qt_pgl = 0;
    fax2_qt_cbl = 0;
    fax2_timeout = 0x1E;
    fax2_minimum_speed = BR_2400;

/* start change 3/27/95 mlc */
    fax2_nonstandard_string[0] = '\0';
/* end change 3/27/95 mlc */

    fax2_local_id_string[0] = '\0';
    fax2_polling_id_string[0] = '\0';
    fax2_pp_response = MCF_PPR;
    fax2_ECM_retry_count = 0;
    fax2_hangup_status = 0;

    /* initialize the negotiated T.30 parameters */
    fax2_negotiated.VR = 0;
    fax2_negotiated.BR = 0;
    fax2_negotiated.WD = 0;
    fax2_negotiated.LN = 0;
    fax2_negotiated.DF = 0;
    fax2_negotiated.EC = 0;
    fax2_negotiated.BF = 0;
    fax2_negotiated.ST = 0;

    /* initialize the T.30 capability parameters */
    fax2_capabilities.VR = 1;
    fax2_capabilities.BR = modem_fax_capability();
    fax2_capabilities.WD = 0;
    fax2_capabilities.LN = 2;
    fax2_capabilities.DF = 0;
    fax2_capabilities.EC = fax2_ECM_installed_page();
    fax2_capabilities.BF = 0;
    fax2_capabilities.ST = 0;

    /* initialize the T.30 session parameters with the capability parameters */
    fax2_session = fax2_capabilities;

    /* initialize the negotiation message reporting parameters */
    fax2_message_reporting.RPR = 0;
    fax2_message_reporting.TPR = 0;
    fax2_message_reporting.IDR = 0;
    fax2_message_reporting.NSR = 0;
}

/******************************************************************************
/
/   Routine: fax2_hangup
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will abruptly terminate the fax connection,
/                if one is ongoing. It will reinitialize the session
/                capablities.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: Class 2 session parameters (DIS capabilities).
/
/   Users: ACU hangup processing.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void fax2_hangup(void)
{
    if (fax2_connected) /*only true if ATH0 or DTR dropped during connection*/
    {
        if (fax2_line_configured)   /* if line side configured */
            fax2_cleanup();         /* terminate interfaces */
        /* look to see if not looking for an AT command */
        if (fax2_received_command != EMPTY_COMMAND) /*if so giveup the DTE port*/
        {
            if (fax2_negotiated.EC) /* Let ECM send DLE ETX if necessary */
                fax2_ECM_dte_send_DLE_ETX_page();
            else if (fax2_state == PHASE_C_RECEIVE)  /* if receiving data */
            {
                fax_dte_to_char(DLE);   /* terminate the data stream */
                fax_dte_to_char(ETX);
            }
            while (fax_dte_to_num());   /* flush DTE buffer */
            fax_dte_reset();    /* give up port */
        }
        /* FAX did not terminate it self so it was performed with ATH ATZ or DTR */
        fax2_hangup_status = FKS_ABORTED_CONNECTION;
        /* put FAX in an IDLE state */
        fax2_state = IDLE;
        /* holding place so the variable doesn't float and confuse debugging */
        fax2_sub_state = INITIALIZE;
        fax2_utility_state = INITIALIZE;
        /* FAX is no longer connected */
        fax2_connected = FALSE;
    }

    fax2_class = 0; /* +FCLASS = 0 */
    /* initialize the T.30 session parameters with the capability parameters */
    fax2_session = fax2_capabilities;

}

/******************************************************************************
/
/   Routine: fax2_tx
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will be called by the fax I/O transmit interrupt
/                service routine. It indicates the complete transmission of an
/                hdlc packet. If the returned pointer is non-NULL, the new
/                packet is transmitted, otherwise no new transmission is
/                performed.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte *  address of hdlc buffer to transmit.
/                               NULL indicates no buffer.
/
/   Global Variables Changed: None
/
/   Users: FAX DCE I/O
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte *fax2_tx(void)
{
    if (fax2_negotiated.EC && fax2_state == PHASE_C_TRANSMIT)
        return (fax2_ECM_tx_page());

    fax2_head_index++; /* update the head queue pointer */
    /* if at the end of the ring list then rotate to the top */
    if (fax2_head_index == HDLC_BUFFER_COUNT)
        fax2_head_index = 0;

    /* if the head and tail pointers are equal then no more packets to transmit */
    if (fax2_head_index == fax2_tail_index)
        return(NULL); /* indicate no more buffers to transmit */
    else
    {
        /* return the next buffer for transmission */
        return((ubyte *)&fax2_buffer_array[fax2_head_index]);
    }
}

/******************************************************************************
/
/   Routine: fax2_rx
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will be called by the fax I/O receive interrupt
/                service routine. It indicates the complete reception of an
/                hdlc packet. If the returned pointer is non-NULL, the new
/                packet is setup for a receive, otherwise no new packet is
/                received.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte *  address of hdlc buffer to receive into.
/                               NULL indicates no buffer.
/
/   Global Variables Changed: None
/
/   Users: FAX DCE I/O
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte *fax2_rx(void)
{
    if (fax2_negotiated.EC && fax2_state == PHASE_C_RECEIVE)
        return (fax2_ECM_rx_page());

    /* get rid of the checksum at the end of the data */
    fax2_tail_index++; /* update the tail pointer to indicate the new receive */
    /* if at the end of the ring list then rotate to the top */
    if (fax2_tail_index == HDLC_BUFFER_COUNT)
        fax2_tail_index = 0;

    /* return the address of the next free buffer */
    return((ubyte *)&fax2_buffer_array[fax2_tail_index]);
}

/******************************************************************************
/
/   Routine: fax2_cleanup
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine is used to reset the line I/O code to not receive
/                any more data, and terminate the data pump configuration.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: None
/
/   Users: class 2 protocols
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_cleanup(void)
{
    fax_line_reset();       /* terminate the DCE I/O, don't clear rx buffer */
    modem_terminate_link(); /* terminate the DP modulation, put in idle */
    fax2_head_index = 0;    /* reset the buffer queue head pointer */
    fax2_tail_index = 0;    /* reset the buffer queue head pointer */
    fax2_line_configured = FALSE;   /* indicate the line configuration reset */
}

/******************************************************************************
/
/   Routine: fax2_determine_mod
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine translates the T.30 negotiated bit rate and
/                an indication of training into the apropriate Modem Task
/                modulation parameter to be used for configuring the DP.
/
/   Input Parameters: ubyte     0   configure for page transfer
/                               1   configure for TCF (training) transfer
/
/   Output Parameters: none
/
/   Global Variables Changed: None
/
/   Users: fax2_configure_rx_data(), fax2_receive_TCF(), fax2_transmit_TCF()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_determine_mod(ubyte train)
{
    /* index into a two dimentional array for the proper modulation scheme */
    return(fax2_modulation_table[train][fax2_negotiated.BR]);
}

/******************************************************************************
/
/   Routine: fax2_hex_a_to_d
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a pointer to a two character ASCII
/                hex string. It will be converted to decimal and return.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_schedule_tx_packet
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_hex_a_to_d(ubyte *string_ptr)
{
    ubyte i, data_byte;

    data_byte = 0;
    /* two ASCII hex characters go into one byte */
    for (i = 0 ; i < 2 ; i++)
    {
        data_byte <<= 4;
        /* if 0-9 then subtract from 0 to get the offset */
        if (*string_ptr >= '0' && *string_ptr <='9')
            data_byte |= *string_ptr - '0';
        else
            /* else subtract from A to get the offset and add 10 (e.g B == 11) */
            data_byte |= *string_ptr - 'A' + 10;

        string_ptr++; /* point to the next ASCII character */
    }
    return(data_byte); /* return the translated byte */
}

/******************************************************************************
/
/   Routine: fax2_hex_d_to_a
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and returns an
/                equivalent two hex ASCII character representation.
/
/   Input Parameters: ubyte decimal number
/
/   Output Parameters: ubyte    most significant ASCII character
/                      ubyte    least significant ASCII character
/
/   Global Variables Changed: none
/
/   Users: fax2_schedule_tx_packet
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_hex_d_to_a(ubyte data_char, ubyte *upper_char_ptr, ubyte *lower_char_ptr)
{
    ubyte temp_char;

    /* get the upper nible */
    temp_char = (data_char >> 4) & 0x0F;
    /* translate into ASCII */
    *upper_char_ptr = temp_char < 10 ? temp_char + '0' : temp_char - 10 + 'A';
    /* get the lower nible */
    temp_char = data_char & 0x0F;
    /* translate into ASCII */
    *lower_char_ptr = temp_char < 10 ? temp_char + '0' : temp_char - 10 + 'A';
}

/******************************************************************************
/
/   Routine: fax2_dec_d_to_a
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and returns an
/                equivalent three decimal ASCII character representation.
/
/   Input Parameters: ubyte decimal number
/
/   Output Parameters: ubyte    most significant ASCII character
/                      ubyte    middle ASCII character
/                      ubyte    least significant ASCII character
/
/   Global Variables Changed: none
/
/   Users: fax2_respond_dec_byte, fax2_response
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_dec_d_to_a(ubyte data_char, ubyte *upper_char_ptr, ubyte *middle_char_ptr, ubyte *lower_char_ptr)
{
    /* get and translate the handreds digit */
    *upper_char_ptr = (data_char / 100) + '0';
    data_char %= 100;
    /* get and translate the tens digit */
    *middle_char_ptr = (data_char / 10) + '0';
    /* get and translate the singles digit */
    *lower_char_ptr = (data_char % 10) + '0';
}

/******************************************************************************
/
/   Routine: fax2_respond_dec_byte
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and responds to
/                the dte with an equivalent decimal ASCII representation.
/
/   Input Parameters: ubyte decimal number
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: Class 2 (2388) request commands.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_respond_dec_byte(ubyte data_byte)
{
    ubyte upper_char, middle_char, lower_char;

    /* translate the data byte into an ASCII equivalent */
    fax2_dec_d_to_a(data_byte, &upper_char, &middle_char, &lower_char);

    /* if the most significant character is non-zero */
    if (upper_char != '0')
    {
        fax_dte_to_char(upper_char);
        fax_dte_to_char(middle_char);
    }
    else if (middle_char != '0') /* if middle character is non-zero */
        fax_dte_to_char(middle_char);

    /* always display the least significat digit */
    fax_dte_to_char(lower_char);
}

/******************************************************************************
/
/   Routine: fax2_store_dec_byte
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and a string pointer.
/                It converts the number to decimal ASCII and stores it in the
/                string.
/
/   Input Parameters: ubyte     decimal number
/                     ubyte **  string_ptr_ptr   
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_execute_command()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_store_dec_byte(ubyte data_byte, ubyte **string_ptr_ptr)
{
    ubyte upper_char, middle_char, lower_char;

    /* translate the data byte into an ASCII equivalent */
    fax2_dec_d_to_a(data_byte, &upper_char, &middle_char, &lower_char);

    /* if the most significant character is non-zero */
    if (upper_char != '0')
    {
        *(*string_ptr_ptr)++ = upper_char;
        *(*string_ptr_ptr)++ = middle_char;
    }
    else if (middle_char != '0') /* if middle character is non-zero */
        *(*string_ptr_ptr)++ = middle_char;

    /* always display the least significat digit */
    *(*string_ptr_ptr)++ = lower_char;
}

/******************************************************************************
/
/   Routine: fax2_respond_hex_byte
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and responds to
/                the dte with an equivalent hex ASCII representation.
/
/   Input Parameters: ubyte decimal number
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax20_execute_command() request commands.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_respond_hex_byte(ubyte data_byte)
{
    ubyte upper_char, lower_char;

    /* translate the data byte into an ASCII equivalent */
    fax2_hex_d_to_a(data_byte, &upper_char, &lower_char);

    /* if the most significant character is non-zero */
    if (upper_char != '0')
        fax_dte_to_char(upper_char);

    /* always display the least significat digit */
    fax_dte_to_char(lower_char);
}

/******************************************************************************
/
/   Routine: fax2_store_hex_byte
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and a string pointer.
/                It converts the number to hex ASCII and stores it in the
/                string.
/
/   Input Parameters: ubyte     decimal number
/                     ubyte **  string_ptr_ptr   
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax20_execute_command() request commands.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_store_hex_byte(ubyte data_byte, ubyte **string_ptr_ptr)
{
    ubyte upper_char, lower_char;

    /* translate the data byte into an ASCII equivalent */
    fax2_hex_d_to_a(data_byte, &upper_char, &lower_char);

    /* if the most significant character is non-zero */
    if (upper_char != '0')
        *(*string_ptr_ptr)++ = upper_char;

    /* always display the least significat digit */
    *(*string_ptr_ptr)++ = lower_char;
}

/******************************************************************************
/
/   Routine: fax2_respond_dec_word
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and responds to
/                the dte with an equivalent decimal ASCII representation.
/
/   Input Parameters: uword decimal number
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_execute_command() +FBUF? request command.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_respond_dec_word(uword data_word)
{

    ubyte ascii_char, leading_zero;

    leading_zero = TRUE;

    /* get translate and display the ten thousands digit */
    if ((ascii_char = (data_word / 10000) + '0') != '0')
    {
        leading_zero = FALSE;
        fax_dte_to_char(ascii_char);
    }
    data_word %= 10000;

    /* get translate and display the thousands digit */
    if ((ascii_char = (data_word / 1000) + '0') != '0' || !leading_zero)
    {
        leading_zero = FALSE;
        fax_dte_to_char(ascii_char);
    }
    data_word %= 1000;

    /* get translate and display the handreds digit */
    if ((ascii_char = (data_word / 100) + '0') != '0' || !leading_zero)
    {
        leading_zero = FALSE;
        fax_dte_to_char(ascii_char);
    }
    data_word %= 100;

    /* get translate and display the tens digit */
    if ((ascii_char = (data_word / 10) + '0') != '0' || !leading_zero)
        fax_dte_to_char(ascii_char);

    /* always display the least significat digit */
    ascii_char = data_word % 10;
    fax_dte_to_char(ascii_char + '0');

}

/******************************************************************************
/
/   Routine: fax2_store_dec_word
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and a string pointer.
/                It converts the number to decimal ASCII and stores it in the
/                string.
/
/   Input Parameters: uword     decimal number
/                     ubyte **  string_ptr_ptr   
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_execute_command()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_store_dec_word(uword data_word, ubyte **string_ptr_ptr)
{

    ubyte ascii_char, leading_zero;

    leading_zero = TRUE;

    /* get translate and display the ten thousands digit */
    if ((ascii_char = (data_word / 10000) + '0') != '0')
    {
        leading_zero = FALSE;
        *(*string_ptr_ptr)++ = ascii_char;
    }
    data_word %= 10000;

    /* get translate and display the thousands digit */
    if ((ascii_char = (data_word / 1000) + '0') != '0' || !leading_zero)
    {
        leading_zero = FALSE;
        *(*string_ptr_ptr)++ = ascii_char;
    }
    data_word %= 1000;

    /* get translate and display the handreds digit */
    if ((ascii_char = (data_word / 100) + '0') != '0' || !leading_zero)
    {
        leading_zero = FALSE;
        *(*string_ptr_ptr)++ = ascii_char;
    }
    data_word %= 100;

    /* get translate and display the tens digit */
    if ((ascii_char = (data_word / 10) + '0') != '0' || !leading_zero)
        *(*string_ptr_ptr)++ = ascii_char;

    /* always display the least significat digit */
    ascii_char = data_word % 10;
    *(*string_ptr_ptr)++ = ascii_char + '0';
}

/******************************************************************************
/
/   Routine: fax2_respond_hex_word
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and responds to
/                the dte with an equivalent hex ASCII representation.
/
/   Input Parameters: uword decimal number
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax20_execute_command() +FBS? request command.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_respond_hex_word(uword data_word)
{
    ubyte temp_byte, upper_char, lower_char, responded_upper;

    responded_upper = FALSE;
    /* grab the upper byte */
    temp_byte = (ubyte)(data_word >> 8);
    if (temp_byte) /* in non-zero */
    {
        responded_upper = TRUE;
        /* translate the data byte into an ASCII equivalent */
        fax2_hex_d_to_a(temp_byte, &upper_char, &lower_char);
        /* if the most significant character is non-zero */
        if (upper_char != '0')
            fax_dte_to_char(upper_char);
        fax_dte_to_char(lower_char);
    }
    /* grab the lower byte */
    temp_byte = (ubyte) data_word;
    /* translate the data byte into an ASCII equivalent */
    fax2_hex_d_to_a(temp_byte, &upper_char, &lower_char);
    /* if any previously displayed digits or the upper character is non-zero */
    if (responded_upper || upper_char != '0')
        fax_dte_to_char(upper_char);

    /* always display the least significat character */
    fax_dte_to_char(lower_char);
}

/******************************************************************************
/
/   Routine: fax2_store_hex_word
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine receives a decimal number and a string pointer.
/                It converts the number to hex ASCII and stores it in the
/                string.
/
/   Input Parameters: uword     decimal number
/                     ubyte **  string_ptr_ptr   
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax20_execute_command()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_store_hex_word(uword data_word, ubyte **string_ptr_ptr)
{
    ubyte temp_byte, upper_char, lower_char, responded_upper;

    responded_upper = FALSE;
    /* grab the upper byte */
    temp_byte = (ubyte)(data_word >> 8);
    if (temp_byte) /* in non-zero */
    {
        responded_upper = TRUE;
        /* translate the data byte into an ASCII equivalent */
        fax2_hex_d_to_a(temp_byte, &upper_char, &lower_char);
        /* if the most significant character is non-zero */
        if (upper_char != '0')
            *(*string_ptr_ptr)++ = upper_char;
        *(*string_ptr_ptr)++ = lower_char;
    }
    /* grab the lower byte */
    temp_byte = (ubyte) data_word;
    /* translate the data byte into an ASCII equivalent */
    fax2_hex_d_to_a(temp_byte, &upper_char, &lower_char);
    /* if any previously displayed digits or the upper character is non-zero */
    if (responded_upper || upper_char != '0')
        *(*string_ptr_ptr)++ = upper_char;

    /* always display the least significat character */
    *(*string_ptr_ptr)++ = lower_char;
}

/******************************************************************************
/
/   Routine: fax2_respond_hex_string
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine outputs to the dte an ASCII string representing
/                the hdlc data found in the packet. If the packet is a
/                non-standard fascilities packet then only the facsimile
/                information field.
/
/   Input Parameters: hdlc_buffer_type *    pointer to packet
/                     ubyte                 0 non-standard fascilities response
/                     ubyte                 1 hdlc debug response
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_display_debug(), fax2_response()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_respond_hex_string(hdlc_buffer_type *buffer_ptr, ubyte debug)
{
    ubyte i, offset, data_char, upper_char, lower_char;
    uword count;

    i = 0;
    /* offest into the received packet to start displaying from */
    /* do not display the address, CF, and FCF if not a debug packet */
    offset = debug ? 0 : BASE_COUNT;
    /* display all bytes from the offset to the end */
    count = buffer_ptr->count > offset ? buffer_ptr->count - offset : 0;
    /* while more data to display */
    while (count--)
    {
        /* wait until there's enough room */
        while (fax_dte_to_free() < 3);
        /* if not the first byte then prefix the hax chars with a space */
        if (i)
            fax_dte_to_char(' ');
        /* if debug information then look to reverse the bits */
        if (debug && fax2_hdlc_bit_ordering == REVERSE)
            data_char = fax2_reverse_table[buffer_ptr->data[i + offset]];
        else
            data_char = buffer_ptr->data[i + offset];
        /* translate the data byte into a hex represantation */
        fax2_hex_d_to_a(data_char, &upper_char, &lower_char);
        /* display both hex characters regaurdless of value */
        fax_dte_to_char(upper_char);
        fax_dte_to_char(lower_char);
        i++; /* increment the number of bytes handled */
    }
}

/******************************************************************************
/
/   Routine: fax2_respond_string
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine outputs an ASCII string to the dte.
/
/   Input Parameters: ubyte *   pointer to string (NULL terminated)
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_display_debug(), fax2_response()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_respond_string(ubyte *string_ptr)
{
    while (*string_ptr) /* display all characters until a NULL is reached */
        fax_dte_to_char(*string_ptr++);
}

/******************************************************************************
/
/   Routine: fax2_respond_configuration
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine outputs a class 2 T.30 parameter set to the APP
/
/   Input Parameters: T30_parms_type *  pointer to the parameter structure
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_response()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_respond_configuration(T30_parms_type *parms_struct_ptr)
{
    fax2_respond_dec_byte(parms_struct_ptr->VR);
    fax_dte_to_char(',');
    /* if BR is greater the 5 then V.17 was negtiated */
    /* return the equivalent speed setting */
    fax2_respond_dec_byte(parms_struct_ptr->BR > BR_14400 ?
                          parms_struct_ptr->BR - 4 : parms_struct_ptr->BR);
    fax_dte_to_char(',');
    fax2_respond_dec_byte(parms_struct_ptr->WD);
    fax_dte_to_char(',');
    fax2_respond_dec_byte(parms_struct_ptr->LN);
    fax_dte_to_char(',');
    fax2_respond_dec_byte(parms_struct_ptr->DF);
    fax_dte_to_char(',');
    fax2_respond_dec_byte(parms_struct_ptr->EC);
    fax_dte_to_char(',');
    fax2_respond_dec_byte(parms_struct_ptr->BF);
    fax_dte_to_char(',');
    fax2_respond_dec_byte(parms_struct_ptr->ST);
}

/******************************************************************************
/
/   Routine: fax2_store_configuration
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine converts the class 2 T.30 parameter set to
/                ASCII and places them in a string to be outputed to the APP
/
/   Input Parameters: T30_parms_type *  pointer to the parameter structure
/                     ubyte **          string_ptr_ptr   
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_execute_command()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_store_configuration(T30_parms_type *parms_struct_ptr, ubyte **string_ptr_ptr)
{
    fax2_store_dec_byte(parms_struct_ptr->VR, string_ptr_ptr);
    *(*string_ptr_ptr)++ = ',';
    /* if BR is greater the 5 then V.17 was negtiated */
    /* return the equivalent speed setting */
    fax2_store_dec_byte(parms_struct_ptr->BR > BR_14400 ?
                        parms_struct_ptr->BR - 4 : parms_struct_ptr->BR,
                        string_ptr_ptr);
    *(*string_ptr_ptr)++ = ',';
    fax2_store_dec_byte(parms_struct_ptr->WD, string_ptr_ptr);
    *(*string_ptr_ptr)++ = ',';
    fax2_store_dec_byte(parms_struct_ptr->LN, string_ptr_ptr);
    *(*string_ptr_ptr)++ = ',';
    fax2_store_dec_byte(parms_struct_ptr->DF, string_ptr_ptr);
    *(*string_ptr_ptr)++ = ',';
    fax2_store_dec_byte(parms_struct_ptr->EC, string_ptr_ptr);
    *(*string_ptr_ptr)++ = ',';
    fax2_store_dec_byte(parms_struct_ptr->BF, string_ptr_ptr);
    *(*string_ptr_ptr)++ = ',';
    fax2_store_dec_byte(parms_struct_ptr->ST, string_ptr_ptr);
}

/******************************************************************************
/
/   Routine: fax2_display_debug
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine performs the class 2 hdlc debug response.
/
/   Input Parameters: ubyte                 direction of packet (tx or rx)
/                     hdlc_buffer_type *    pointer to packet
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_response_receive(), fax2_command_receive(),
/          fax2_schedule_tx_packet()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_display_debug(ubyte direction, hdlc_buffer_type *buffer_ptr)
{
    /* make sure there's enough room for the +FHT: or +FHR: indication */
    while (fax_dte_to_free() < 5);

    /* indicate the direction flow of the packet */
    if (direction == TX_MODE)
        fax2_respond_string((ubyte *)FHT_592);
    else
        fax2_respond_string((ubyte *)FHR_592);

    /* display the entire packet in hex */
    fax2_respond_hex_string(buffer_ptr, TRUE);

    /* make sure there's room for the CR and LF */
    while (fax_dte_to_free() < 2);

    fax_dte_to_char(CR); /* this properly terminates the information response */
    fax_dte_to_char(LF);
}

/******************************************************************************
/
/   Routine: fax2_response
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine performs the majority of the class 2 dte
/                responses. The class12 variable is used to distinguish between
/                the 2388 and 592 standards.
/
/   Input Parameters: ubyte                 response type (2388 or 592)
/                     hdlc_buffer_type *    pointer to packet
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: Much of the class 2 protocol.
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_response(ubyte response_type, hdlc_buffer_type *buffer_ptr)
{
    ubyte i, *string_ptr, upper_char, lower_char;

    /* if running 592 then checkout the +FNR settings to suppress responses */
    if (fax2_class == STANDARD_592)
        switch (response_type)
        {
            case CSI_RESPONSE:
            case TSI_RESPONSE:
            case CIG_RESPONSE:
                if (!fax2_message_reporting.IDR)
                    return;
                break;
            case NSF_RESPONSE:
            case NSS_RESPONSE:
            case NSC_RESPONSE:
                if (!fax2_message_reporting.NSR)
                    return;
                break;
            case DIS_RESPONSE:
            case DTC_RESPONSE:
                if (!fax2_message_reporting.RPR)
                    return;
                break;
            case DCS_RESPONSE:
                if (!fax2_message_reporting.TPR)
                    return;
                break;
            default:
                break;
        }

    /* make sure there's enough room for the largest possible response */
    while (fax_dte_to_free() < MAX_RESPONSE_LENGTH);

    /* need a <CR><LF> prefix to all information text responses */
    /* a numeric CONNECT code result response is not prefixed */
    if (response_type != CONNECT_RESPONSE || fax2_response_type != NUMERIC)
    {
        fax_dte_to_char(CR);
        fax_dte_to_char(LF);
    }

    switch (response_type)
    {
        case DIS_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)DIS_592);
            else
                fax2_respond_string((ubyte *)DIS_2388);
            fax2_respond_configuration(&fax2_translate);
            break;
        case DTC_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)DTC_592);
            else
                fax2_respond_string((ubyte *)DTC_2388);
            fax2_respond_configuration(&fax2_translate);
            break;
        case DCS_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)DCS_592);
            else
                fax2_respond_string((ubyte *)DCS_2388);
            fax2_respond_configuration(&fax2_negotiated);
            break;
        case CSI_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)CSI_592);
            else
                fax2_respond_string((ubyte *)CSI_2388);
            /* grab the address of the last data byte in the id string */
            string_ptr = &buffer_ptr->data[BASE_COUNT + ID_LENGTH - 1];
            /* display the entire string in reverse */
            for (i = 0 ; i < ID_LENGTH ; i++)
                fax_dte_to_char(*string_ptr--);
            fax_dte_to_char('"'); /* append a quote */
            break;
        case TSI_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)TSI_592);
            else
                fax2_respond_string((ubyte *)TSI_2388);
            /* grab the address of the last data byte in the id string */
            string_ptr = &buffer_ptr->data[BASE_COUNT + ID_LENGTH - 1];
            /* display the entire string in reverse */
            for (i = 0 ; i < ID_LENGTH ; i++)
                fax_dte_to_char(*string_ptr--);
            fax_dte_to_char('"'); /* append a quote */
            break;
        case CIG_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)CIG_592);
            else
                fax2_respond_string((ubyte *)CIG_2388);
            /* grab the address of the last data byte in the id string */
            string_ptr = &buffer_ptr->data[BASE_COUNT + ID_LENGTH - 1];
            /* display the entire string in reverse */
            for (i = 0 ; i < ID_LENGTH ; i++)
                fax_dte_to_char(*string_ptr--);
            fax_dte_to_char('"'); /* append a quote */
            break;
        case NSF_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)NSF_592);
            else
                fax2_respond_string((ubyte *)NSF_2388);
            /* display the FIF in hex format with space separation */
            fax2_respond_hex_string(buffer_ptr, FALSE);
            break;
        case NSS_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)NSS_592);
            else
                fax2_respond_string((ubyte *)NSS_2388);
            /* display the FIF in hex format with space separation */
            fax2_respond_hex_string(buffer_ptr, FALSE);
            break;
        case NSC_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)NSC_592);
            else
                fax2_respond_string((ubyte *)NSC_2388);
            /* display the FIF in hex format with space separation */
            fax2_respond_hex_string(buffer_ptr, FALSE);
            break;
        case PPR_RESPONSE:
            if (fax2_class == STANDARD_592)
            {
                fax2_respond_string((ubyte *)PPR_592);
                /* indicate the proposed post page response with all the */
                /* collected statistics */
                fax_dte_to_char(fax2_pp_response + '0'); fax_dte_to_char(',');
                fax2_respond_hex_word(fax2_stats.LC);    fax_dte_to_char(',');
                fax2_respond_hex_word(fax2_stats.BLC);   fax_dte_to_char(',');
                fax2_respond_hex_word(fax2_stats.CBLC);  fax_dte_to_char(',');
                fax2_respond_hex_word(fax2_stats.LBC);
            }
            else
            {
                fax2_respond_string((ubyte *)PPR_2388);
                /* indicate the proposed post page response with all the */
                /* collected statistics */
                fax_dte_to_char(fax2_pp_response + '0'); fax_dte_to_char(',');
                fax2_respond_dec_word(fax2_stats.LC);    fax_dte_to_char(',');
                fax2_respond_dec_word(fax2_stats.BLC);   fax_dte_to_char(',');
                fax2_respond_dec_word(fax2_stats.CBLC);  fax_dte_to_char(',');
                fax2_respond_dec_word(fax2_stats.LBC);
            }

            break;
        case PPC_RESPONSE:
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)PPC_592);
            else
                fax2_respond_string((ubyte *)PPC_2388);
            /* indicate the post page command */
            fax_dte_to_char(fax2_pp_command + (ubyte)'0');
            break;
        case VOICE_RESPONSE:
            /* indicate a procedure interrupt to the APP */
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)VOICE_592);
            else
                fax2_respond_string((ubyte *)VOICE_2388);
            break;
        case FCON_RESPONSE:
            /* indicate the detection of flags at the begining of a connection */
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)FCON_592);
            else
                fax2_respond_string((ubyte *)FCON_2388);
            break;
        case CONNECT_RESPONSE:
            /* indicate "CONNECT" to start phase C */
            if (fax2_response_type == NUMERIC)
                fax_dte_to_char('1');
            else
                fax2_respond_string((ubyte *)CONNECT_592);
            break;
        case HANGUP_RESPONSE:
            /* indicate the hangup status to the APP */
            if (fax2_class == STANDARD_592)
            {
                fax2_respond_string((ubyte *)HANGUP_592);
                fax2_hex_d_to_a(fax2_hangup_status, &upper_char, &lower_char);
                /* always indicate both digits regardless of leading zero */
                fax_dte_to_char(upper_char);
                fax_dte_to_char(lower_char);
            }
            else
            {
                fax2_respond_string((ubyte *)HANGUP_2388);
                /* convert the status value to its 2388 equivalent */
                fax2_respond_dec_byte(fax2_error_translate_table[fax2_hangup_status]);
            }
            break;
        case POLL_RESPONSE:
            /* indicate reception of a DIS packet with the transmitter bit set */
            if (fax2_class == STANDARD_592)
                fax2_respond_string((ubyte *)POLL_592);
            else
                fax2_respond_string((ubyte *)POLL_2388);
            break;
        case FPTS_RESPONSE:
            /* 2388 transmit phase D indicates the post page response */
            fax2_respond_string((ubyte *)PPR_2388);
            fax_dte_to_char(fax2_pp_response + '0');
            break;
        case CFR_RESPONSE:
            /* indicate the transmission of the first CFR packet at the */
            /* begining of a document phase B transmission */
            fax2_respond_string((ubyte *)CFR_2388);
            break;
        default:
            break;
    }

    fax_dte_to_char(CR);
    /* numeric responses are not postfixed by line-feed */
    if (response_type == CONNECT_RESPONSE && fax2_response_type == NUMERIC)
        return;
    fax_dte_to_char(LF);
}
/******************************************************************************
/
/   Routine: fax2_configure_tx_data
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will configure to transmit FAX data mode
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    status indication
/                      0        in progress
/                      1        complete
/
/   Global Variables Changed: fax2_utility_timer, fax2_utility_state
/
/   Users: fax2_phaseC_transmit()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date:
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_configure_tx_data(void)
{
    switch (fax2_utility_state)
    {
        case INITIALIZE:
            /* allow the remote time to configure */
            fax2_utility_timer = DELAY_TO_CONFIGURE_TX;
            fax2_utility_state = WAIT_TO_CONFIGURE;
            break;
        case WAIT_TO_CONFIGURE:
            /* if delay is complete */
            if (!fax2_utility_timer)
            {
                /* configure the data pump and line I/O */
                fax2_line_configured = TRUE;
                fax_line_init(DATA_MODE, TX_MODE, CONTROL_PACKET_SIZE);
                modem_fax_configure(fax2_determine_mod(SHORT_TRAIN), TX_MODE);
                fax2_utility_state = WAIT_FOR_CTS;
            }
            break;
        case WAIT_FOR_CTS:
            /* wait for the data pump to indicate the completion of training */
            /* transmission and the readiness to transmit data */
            if (modem_dp_CTS_status())
            {
                fax2_utility_state = INITIALIZE;
                return(TRUE); /* TCF transmission complete */
            }
            break;
    }
    return(FALSE); /* configuration in progress */
}

/******************************************************************************
/
/   Routine: fax2_transmit_TCF
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will configure and transmit the TCF (1.5 sec NULLS).
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    status indication
/                      0        in progress
/                      1        complete
/
/   Global Variables Changed: fax2_utility_timer, fax2_utility_state
/
/   Users: fax2_phaseB_transmit()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_transmit_TCF(void)
{
    switch (fax2_utility_state)
    {
        case INITIALIZE:
            /* allow the remote time to configure */
            fax2_utility_timer = DELAY_TO_CONFIGURE_TX;
            fax2_utility_state = WAIT_TO_CONFIGURE;
            break;
        case WAIT_TO_CONFIGURE:
            /* if delay is complete */
            if (!fax2_utility_timer)
            {
                /* configure the data pump and line I/O */
                fax2_line_configured = TRUE;
                fax_line_init(DATA_MODE, TX_MODE, CONTROL_PACKET_SIZE);
                modem_fax_configure(fax2_determine_mod(LONG_TRAIN), TX_MODE);
                /* kick start the I/O. It will underrun with NULLs */
                /* the initial NULLs will not go out on the line but its OK */
                fax_line_to_char(0);
                fax2_utility_state = WAIT_FOR_CTS;
            }
            break;
        case WAIT_FOR_CTS:
            /* wait for the data pump to indicate the completion of training */
            /* transmission and the readiness to transmit data */
            if (modem_dp_CTS_status())
            {
                /* delay for the length of the TCF */
                fax2_utility_timer = TCF_TRANSMIT_TIMEOUT;
                fax2_utility_state = TRANSMIT_TCF;
            }
            break;
        case TRANSMIT_TCF:
            /* if the timer is out, then the TCF has been transmitted */
            if (!fax2_utility_timer)
            {
                fax2_cleanup(); /* drop the carrier and cleanup the line */
                fax2_utility_state = INITIALIZE;
                return(TRUE); /* TCF transmission complete */
            }
            break;
    }
    return(FALSE); /* TCF transmission in progress */
}

/******************************************************************************
/
/   Routine: fax2_configure_rx_data
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will configure to receive the data modulation
/                negotiated in the DCS packet. As per T.30 receive state (F)
/                it also looks for a command carrier.
/
/   Input Parameters: ubyte     command
/                     0         execute configuration
/                     1         abort configuration
/
/   Output Parameters: ubyte    status indication
/                      0        detected the data carrier negotiated
/                      1        detected a V.21 ch2 carrier
/                      2        no carrier has been detected
/
/   Global Variables Changed: fax2_utility_state
/
/   Users: fax2_phaseB_receive()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
*******************************************************************************/
ubyte fax2_configure_rx_data(ubyte command)
{
    ubyte carrier_type;

    /* The following IF statement facilitates the receptions of FAX's */
    /* for modems which do not have the capability to detect V21 ch2  */
    /* while configured to detected and receive V.27/V.29/V.17 */
/*
    if (!fax2_data_expected)
        return(DETECTED_COMMAND);
*/

    /* timed out waiting for the carrier. terminate the configuration */
    if (command == ABORT)
    {
        fax2_utility_state = INITIALIZE;
        fax2_cleanup();
        return(NULL);
    }

    switch (fax2_utility_state)
    {
        case INITIALIZE:
            /* configure the data pump and line I/O */
            fax2_line_configured = TRUE;
            /* determine the proper modulation and configure */
            /* If ECM is negotiated, let ECM decide whether or not a long
            train is to be configured */
            fax_line_init(DATA_MODE, RX_MODE, CONTROL_PACKET_SIZE);
            modem_fax_configure(fax2_determine_mod(
                (fax2_negotiated.EC && fax2_ECM_rcv_data_longtrain_page()) ?
                LONG_TRAIN : SHORT_TRAIN), RX_MODE);

            fax2_utility_state = WAIT_FOR_CD;
            break;
        case WAIT_FOR_CD:
            /* look for a crrier indication */
            if ((carrier_type = modem_check_CD()))
            {
                fax2_utility_state = INITIALIZE;
                /* if V.21 ch2 is detected */
                if (carrier_type == V21_CARRIER)
                {
                    /* put the data pump in idle */
                    fax2_cleanup();
                    /* indicate the detection of V.21 ch2 */
                    return(DETECTED_COMMAND);
                }
                else
                    /* indicate the detection of configured data carrier */
                    return(DETECTED_DATA);
            }
            else
            {
                /* the I/O collects chars due to the active data pump clocks */
                /* these characters are usually FF's and should be discarded */
                while (fax_line_from_num() > DATA_CHARS_IN_DCE)
                    fax_line_from_char();
            }
            break;
    }
    /* have not detected a carrier */
    return(STILL_LOOKING);
}

/******************************************************************************
/
/   Routine: fax2_receive_TCF
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will configure and receive the TCF at the data
/                speed negotiated in the DCS packet. One second of the TCF
/                one and a half seconds of nulls is received. The number of
/                none NULL characters received in the one second counted.
/                This number will indicate the quality of the physical link.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    status indication
/                      0        procedure not complete
/                      1        procedure complete
/
/   Global Variables Changed: fax2_utility_state, fax2_utility_timer,
/                             fax2_error_count, fax2_training_count
/
/   Users: fax2_phaseB_receive()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_receive_TCF(void)
{
    switch (fax2_utility_state)
    {
        case INITIALIZE:
            /* configure the data pump and line I/O */
            fax2_line_configured = TRUE;

            /* determine the proper modulation and configure */
            fax_line_init(DATA_MODE, RX_MODE, CONTROL_PACKET_SIZE);
            modem_fax_configure(fax2_determine_mod(LONG_TRAIN), RX_MODE);
            /* setup a timer to abort waiting for carrier */
            fax2_utility_timer = NO_TCF_TIMEOUT;
            fax2_utility_state = WAIT_FOR_CD;
            break;
        case WAIT_FOR_CD:
            /* look for receiving a data carrier only */
            if (modem_check_CD() == CONFIGURED_CARRIER)
            {
                /* number of NULL characters to be received at the baud rate */
                fax2_training_count = fax2_training_count_table[fax2_negotiated.BR];
                /* number of consecutive NULL characters before starting the */
                /* quality checking.  This allows the data pump time to train */
                fax2_error_count = NULLS_BEFORE_TCF;
                /* how long to pursue receiving the TCF */
                fax2_utility_timer = TCF_RECEIVE_TIMEOUT;
                fax2_utility_state = LOOK_FOR_NULLS;
            }
            else
            {
                /* the I/O collects chars due to the active data pump clocks */
                /* these characters are usually FF's and should be discarded */
                while (fax_line_from_num() > DATA_CHARS_IN_DCE)
                    fax_line_from_char();

                /* timed out looking for carrier ? */
                if (!fax2_utility_timer)
                {
                    /* cleanup line configuration */
                    fax2_cleanup();
                    fax2_utility_state = INITIALIZE;
                    /* assign an unacceptable number of bad TCF chars */
                    fax2_error_count = UNACCEPTABLE_BAD_COUNT;
                    return(TRUE); /* done receiving the TCF */
                }
            }
            break;
        case LOOK_FOR_NULLS:
            /* while discarding preamble and there's more data */
            while (fax2_error_count && fax_line_from_num())
                /* if the character is non NULL */
                if (fax_line_from_char())
                    /* then restart looking for the preamble */
                    fax2_error_count = NULLS_BEFORE_TCF;
                else
                    /* one more preamble character found */
                    fax2_error_count--;
            /* if the preamble has been received */
            if (!fax2_error_count)
                /* start checking the quality of the TCF */
                fax2_utility_state = RECEIVE_TCF;

            /* timed out looking for a clean preamble ? */
            if (!fax2_utility_timer)
            {
                /* cleanup line configuration */
                fax2_cleanup();
                fax2_utility_state = INITIALIZE;
                /* assign an unacceptable number of bad TCF chars */
                fax2_error_count = UNACCEPTABLE_BAD_COUNT;
                return(TRUE); /* done receiving the TCF */
            }
            break;
        case RECEIVE_TCF:
            /* while more characters to receive for the TCF quality checking */
            while (fax2_training_count && fax_line_from_num())
            {
                /* if character is not NULL */
                if (fax_line_from_char())
                    fax2_error_count++; /* increment the number of bad chars */
                /* all character are counted at this point */
                fax2_training_count--;
            }

            /* if all the characters needed have been collected */
            if (!fax2_training_count)
                /* wait for the remote to drop carrier */
                fax2_utility_state = WAIT_CD_LOSS;

            if (!fax2_utility_timer)
            {
                /* cleanup line configuration */
                fax2_cleanup();
                fax2_utility_state = INITIALIZE;
                /* assign an unacceptable number of bad TCF chars */
                fax2_error_count = UNACCEPTABLE_BAD_COUNT;
                return(TRUE); /* done receiving the TCF */
            }
            break;
        case WAIT_CD_LOSS:
            /* if carrier is lost or timed out receiving TCF */
            if (!modem_check_CD() || !fax2_utility_timer)
            {
                /* cleanup line configuration */
                fax2_cleanup();
                fax2_utility_state = INITIALIZE;
                return(TRUE); /* done receiving the TCF */
            }
            break;
    }
    return(FALSE); /* still working on receiving the TCF */
}

/******************************************************************************
/
/   Routine: fax2_TCF_ok
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine determines the acceptance or rejection of the TCF.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    acceptance indication
/                      0        reject
/                      1        accept
/
/   Global Variables Changed: none
/
/   Users: fax2_phaseB_receive()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_TCF_ok(void)
{
    /* if the bad char count is larger than the acceptable count then */
    /* FTT, otherwise CFR */
    return(fax2_error_count > fax2_bad_TCF_table[fax2_negotiated.BR] ?
            FALSE : TRUE);
}

/******************************************************************************
/
/   Routine: fax2_send_RTC
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine will send the RTC sequence on the line link.
/                This sequence consists of 6 EOL bit paterns.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_phaseB_transmit()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_send_RTC(void)
{
    ubyte i;

    /* make sure there's room in the DCE transmit buffer */
    while (fax_line_to_free() < 9);
    /* send a 2 EOL sequence 3 times. That is 6 EOL's which makes up an RTC */
    for (i = 0 ; i < 3 ; i++)
    {
        /* eleven 0's and one 1 makes up an EOL */
        fax_line_to_char(RTC_BYTE1);
        fax_line_to_char(RTC_BYTE2);
        fax_line_to_char(RTC_BYTE3);
    }
}

/******************************************************************************
/
/   Routine: fax2_response_receive
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine implements the T.30 response receive function.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    status indication
/                      0        no response received
/                      1        transmit a DCN packet and hangup
/                      2        processing the protocol
/                      3        terminate with a phase E hangup (no DCN)
/                      4        received a packet with the final frame bit set
/
/   Global Variables Changed: fax_utility_state, fax2_utility_timer
/                             fax2_line_configured, fax2_T4_timer,
/                             fax2_respond_FCON, fax2_head_index,
/                             fax2_packet_opcode
/
/   Users: fax2_phaseB_receive(), fax2_phaseB_transmit()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
*******************************************************************************/
ubyte fax2_response_receive(void)
{
    ubyte opcode;

    switch (fax2_utility_state)
    {
        case INITIALIZE:
            /* configure to receive commands at V.21 ch2 */
            fax2_line_configured = TRUE;
/* Start Change 5/5/1995. */
            modem_fax_configure(MOD_V21_300, RX_MODE);
            fax_line_init(HDLC_MODE, RX_MODE, CONTROL_PACKET_SIZE);
/* End Change 5/5/1995. */
            fax_line_rx_block((ubyte *)&fax2_buffer_array[fax2_tail_index]);
            /* start the T.30 T4 timer waiting for flags */
            fax2_T4_timer = T4_TIMEOUT;
            fax2_utility_state = WAIT_FOR_FLAG;
        case WAIT_FOR_FLAG:
            /* look for carrier and the first flag */
            if (modem_check_CD() && fax_line_flag())
            {
                /* if the first flag in the present connection */
                if (fax2_respond_FCON)
                {
                    /* indicate to the APP */
                    fax2_response(FCON_RESPONSE, NULL);
                    fax2_respond_FCON = FALSE;
                }
                fax2_utility_state = WAIT_FOR_PACKET;
                /* don't allow for a packet larger than 3 seconds */
                fax2_utility_timer = THREE_SECONDS;
            }
            /* if T4 timed out looking for a flag */
            else if (!fax2_T4_timer)
            {
                /* cleanup line configuration */
                fax2_cleanup();
                fax2_utility_state = INITIALIZE;
                return(NO_RESPONSE); /* packet not received */
            }
            break;
        case WAIT_FOR_PACKET:
            /* if no packet found */
            if (fax2_head_index == fax2_tail_index)
                if (modem_check_CD()) /* has carrier been lost */
                {
                    /* if 3 second timed out */
                    if (!fax2_utility_timer)
                    {
                        /* cleanup line configurations */
                        fax2_cleanup();
                        fax2_utility_state = INITIALIZE;
                        /* T.30 says to give up on the connection */
                        return(TRANSMIT_DCN);
                    }
                }
                else /* carrier lost and T4 not expired */
                {
                    fax2_cleanup();
                    fax2_utility_state = INITIALIZE;
                    return(NO_RESPONSE); /* packet not received */
                }
            else /* packet received */
            {
                /* get a pointer to the received packet */
                fax2_buffer_ptr = &fax2_buffer_array[fax2_head_index++];
                if (fax2_head_index == HDLC_BUFFER_COUNT)
                    fax2_head_index = 0;

                /* if debug is on then indicate packet contants to the APP */
                if (fax2_debug)
                    fax2_display_debug(RX_MODE, fax2_buffer_ptr);

                /* if the packet is in error or a command repeat packet */
                if (fax2_buffer_ptr->status
                   || (fax2_buffer_ptr->data[FCF] & VD_MASK) == CRP_PACKET)
                {
                    /* setup to wait for carrier loss */
                    fax2_utility_state = WAIT_TO_TERMINATE;
                    fax2_utility_timer = THREE_SECONDS;
                }
                /* if a disconnect packet is received */
                else if ((fax2_buffer_ptr->data[FCF] & VD_MASK) == DCN_PACKET)
                {
                    /* cleanup line configurations */
                    fax2_cleanup();
                    fax2_utility_state = INITIALIZE;
                    /* terminate the FAX connection */
                    return(TERMINATE_SESSION);
                }
                /* if the final frame bit is set */
                else if (fax2_buffer_ptr->data[CF] & FINAL_FRAME_MASK)
                {
                    /* this is the last packet sent in the set */
                    fax2_cleanup(); /* cleanup line configurations */
                    fax2_utility_state = INITIALIZE;
                    /* get the opcode of the packet */
                    fax2_packet_opcode = fax2_buffer_ptr->data[FCF];
                    fax2_packet_opcode = fax2_packet_opcode & DIS_DTC_MASK ?
                                         fax2_packet_opcode & VD_MASK :
                                         fax2_packet_opcode;
                    return(RECEIVED_RESPONSE);
                }
                else /* the packet is an optional one */
                {
                    /* get the opcode */
                    opcode = fax2_buffer_ptr->data[FCF];
                    opcode = opcode & DIS_DTC_MASK ? opcode & VD_MASK : opcode;

                    switch (opcode)
                    {
                        /* local ID packets */
                        case TSI_PACKET:
                            fax2_response(TSI_RESPONSE, fax2_buffer_ptr);
                            break;
                        case CSI_PACKET:
                            fax2_response(CSI_RESPONSE, fax2_buffer_ptr);
                            break;
                        case CIG_PACKET:
                            fax2_response(CIG_RESPONSE, fax2_buffer_ptr);
                            break;
                        /* non-standard packets */
                        case NSS_PACKET:
                            fax2_response(NSS_RESPONSE, fax2_buffer_ptr);
                            break;
                        case NSF_PACKET:
                            fax2_response(NSF_RESPONSE, fax2_buffer_ptr);
                            break;
                        case NSC_PACKET:
                            fax2_response(NSC_RESPONSE, fax2_buffer_ptr);
                            break;
                        default: /* there shouldn't be other optional packets */
                            break;
                    }
                    /* go to the top of the control loop */
                    fax2_utility_state = WAIT_FOR_FLAG;
                }
            }
            break;
        case WAIT_TO_TERMINATE:
            /* if carrier is present */
            if (modem_check_CD())
            {
                /* if 3 second timer has expired */
                if (!fax2_utility_timer)
                {
                    fax2_cleanup();
                    fax2_utility_state = INITIALIZE;
                    /* T.30 says to giveup and send a disconnect */
                    return(TRANSMIT_DCN);
                }
            }
            else /* carrier is lost so cleanup */
            {
                fax2_cleanup();
                fax2_utility_state = INITIALIZE;
                /* packet was not received but it's OK to continue */
                return(NO_RESPONSE);
            }
            break;
    }
    return(PROCESSING); /* working on it; "just hangout and wait !!" */
}

/******************************************************************************
/
/   Routine: fax2_command_receive
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine implements the T.30 command receive function.
/
/   Input Parameters: none
/
/   Output Parameters: ubyte    status indication
/                      2        processing the protocol, do not abort!
/                      3        terminate with a phase E hangup (no DCN)
/                      5        received a packet with the final frame bit set
/                      6        no command found yet, abort acceptable
/
/
/   Global Variables Changed: fax_utility_state, fax2_utility_timer
/                             fax2_line_configured, fax2_T2_timer,
/                             fax2_respond_FCON, fax2_head_index,
/                             fax2_packet_opcode
/
/   Users: fax2_phaseB_receive(), fax2_phaseB_transmit()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
*******************************************************************************/
ubyte fax2_command_receive(ubyte command)
{
    ubyte opcode;

    /* timed out waiting. terminate the configuration */
    if (command == ABORT)
    {
        /* if carrier was already lost and the protocol had not been restarted */
        if (fax2_utility_state == INITIALIZE)
            return(NULL);
        /* cleanup the ongoing protocol */
        fax2_utility_state = INITIALIZE;
        fax2_cleanup();
        /* the return value is not relevant in this case */
        return(NO_COMMAND);
    }

    switch (fax2_utility_state)
    {
        case INITIALIZE:
            /* configure to receive commands at V.21 ch2 */
            fax2_line_configured = TRUE;
/* Start Change 5/5/1995. */
            modem_fax_configure(MOD_V21_300, RX_MODE);
            fax_line_init(HDLC_MODE, RX_MODE, CONTROL_PACKET_SIZE);
/* End Change 5/5/1995. */
            fax_line_rx_block((ubyte *)&fax2_buffer_array[fax2_tail_index]);
            fax2_utility_state = WAIT_FOR_FLAG;
            return(NO_COMMAND);
        case WAIT_FOR_FLAG:
            /* look for carrier and the first flag */
            if (modem_check_CD() && fax_line_flag())
            {
                /* if the first flag in the present connection */
                if (fax2_respond_FCON)
                {
                    /* indicate to the APP */
                    fax2_response(FCON_RESPONSE, NULL);
                    fax2_respond_FCON = FALSE;
                }
                /* reset the T2 timer */
                fax2_T2_timer = T2_TIMEOUT;
                fax2_utility_state = WAIT_FOR_PACKET;
                /* don't allow for a packet larger than 3 seconds */
                fax2_utility_timer = THREE_SECONDS;
                return(PROCESSING);
            }
            return(NO_COMMAND);
        case WAIT_FOR_PACKET:
            /* if no packet found */
            if (fax2_head_index == fax2_tail_index) /* has carrier been lost */
                if (modem_check_CD())
                {
                    /* if 3 second timed out */
                    if (!fax2_utility_timer)
                    {
                        /* cleanup line configurations */
                        fax2_cleanup();
                        fax2_utility_state = INITIALIZE;
                        /* T.30 allows the capability to try again */
                        return(NO_COMMAND);
                    }
                }
                else /* carrier lost while looking for packet */
                {
                    /* clear configuration and setup to try again */
                    fax2_cleanup();
                    fax2_utility_state = INITIALIZE;
                    return(NO_COMMAND);
                }
            else /* packet received */
            {
                /* get a pointer to the received packet */
                fax2_buffer_ptr = &fax2_buffer_array[fax2_head_index++];
                if (fax2_head_index == HDLC_BUFFER_COUNT)
                    fax2_head_index = 0;

                /* if debug is on then indicate packet contants to the APP */
                if (fax2_debug && !fax2_EOM_processing)
                    fax2_display_debug(RX_MODE, fax2_buffer_ptr);

                /* if the packet is in error */
                if (fax2_buffer_ptr->status)
                {
                    /* setup to wait for carrier loss */
                    fax2_utility_state = WAIT_TO_TERMINATE;
                    fax2_utility_timer = THREE_SECONDS;
                }
                /* if a disconnect packet is received */
                else if ((fax2_buffer_ptr->data[FCF] & VD_MASK) == DCN_PACKET)
                {
                    /* termination due to DCN reception */
                    fax2_packet_opcode = DCN_PACKET;
                    /* cleanup line configurations */
                    fax2_cleanup();
                    fax2_utility_state = INITIALIZE;
                    /* terminate the FAX connection */
                    return(TERMINATE_SESSION);
                }
                /* if the final frame bit is set */
                else if (fax2_buffer_ptr->data[CF] & FINAL_FRAME_MASK)
                {
                    /* this is the last packet sent in the set */
                    fax2_cleanup(); /* cleanup line configurations */
                    fax2_utility_state = INITIALIZE;
                    /* get the opcode of the packet */
                    fax2_packet_opcode = fax2_buffer_ptr->data[FCF];
                    fax2_packet_opcode = fax2_packet_opcode & DIS_DTC_MASK ?
                                         fax2_packet_opcode & VD_MASK :
                                         fax2_packet_opcode;
                    return(RECEIVED_COMMAND);
                }
                /* the packet is an optional one. If a TCF response or an EOM */
                /* packet has been sent do not display the optional packets */
                else if (fax2_process_optional_packets && !fax2_EOM_processing)
                {
                    opcode = fax2_buffer_ptr->data[FCF];
                    opcode = opcode & DIS_DTC_MASK ? opcode & VD_MASK : opcode;

                    switch (opcode)
                    {
                        /* local ID packets */
                        case TSI_PACKET:
                            fax2_response(TSI_RESPONSE, fax2_buffer_ptr);
                            break;
                        case CSI_PACKET:
                            fax2_response(CSI_RESPONSE, fax2_buffer_ptr);
                            break;
                        case CIG_PACKET:
                            fax2_response(CIG_RESPONSE, fax2_buffer_ptr);
                            break;
                        /* non-standard packets */
                        case NSS_PACKET:
                            fax2_response(NSS_RESPONSE, fax2_buffer_ptr);
                            break;
                        case NSF_PACKET:
                            fax2_response(NSF_RESPONSE, fax2_buffer_ptr);
                            break;
                        case NSC_PACKET:
                            fax2_response(NSC_RESPONSE, fax2_buffer_ptr);
                            break;
                        default:
                            break;
                    }
                    /* go to the top of the control loop */
                    fax2_utility_state = WAIT_FOR_FLAG;
                }
                else
                    /* go to the top of the control loop */
                    fax2_utility_state = WAIT_FOR_FLAG;
            }
            break;
        case WAIT_TO_TERMINATE:
            /* if carrier is present */
            if (modem_check_CD())
            {
                /* if 3 second timer has expired */
                if (!fax2_utility_timer)
                {
                    /* termination NOT DUE to DCN reception */
                    fax2_packet_opcode = ~DCN_PACKET;
                    fax2_cleanup();
                    fax2_utility_state = INITIALIZE;
                    /* FCS error and carrier not going away */
                    return(TERMINATE_SESSION);
                }
            }
            else
            {
                /* cleanup line configurations and get ready to try again */
                fax2_cleanup();
                fax2_utility_state = INITIALIZE;
                return(NO_COMMAND);
            }
            break;
    }
    return(PROCESSING); /* working on it; "just hangout and wait !!" */
}

/******************************************************************************
/
/   Routine: fax2_transmit_packet
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine configures for and transmits all scheduled packets.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: fax_utility_state, fax2_line_configured,
/
/   Users: fax2_phaseB_receive(), fax2_phaseB_transmit(),
/          fax2_phaseD_receive(), fax2_phaseD_transmit(),
/          fax2_phaseE
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
ubyte fax2_transmit_packet(void)
{
    switch (fax2_utility_state)
    {
        case INITIALIZE:
            /* allow the remote time to configure */
            fax2_utility_timer = DELAY_TO_CONFIGURE_TX;
            fax2_utility_state = WAIT_TO_CONFIGURE;
/* start change 2/10/95 rjm */
            /*
               We are going to send out 1 HDLC frame at a time, allowing
               for some time lag between them so that FAX Class 1 Rx
               modems have some time to deliver the packet to the Host,
               then have the Host configure for another incoming
               frame. Some modems are a little slow and if we send
               back-to-back, well they miss the subsequent frames.

               We determine how many frames we want to send, which is
               the difference in fax2_buffer_array[] indecies, then fool
               the Tx ISR (and the reset of our Tx machinery) into thinking
               we only have 1 frame to send. However, before we shut down,
               we decrement the original 'num_packets' counter and check
               to see if we are really donw. If not, then repoint the
               'fax2_tail_index' to the next packet and kick the xmitr
               again. Repeat until 'num_packets' == 0, then shut down.
            */
            fax2_num_tx_packets = (fax2_tail_index - fax2_head_index);
            fax2_tail_index = fax2_head_index+1;
/* end change 2/10/95 rjm */
            break;
        case WAIT_TO_CONFIGURE:
            /* if delay is complete */
            if (!fax2_utility_timer)
            {
                /* configure the data pump and line I/O */
                fax2_line_configured = TRUE;
/* Start Change 5/5/1995. */
                modem_fax_configure(MOD_V21_300, TX_MODE);
                fax_line_init(HDLC_MODE, TX_MODE, CONTROL_PACKET_SIZE);
/* End Change 5/5/1995. */
                fax2_utility_state = WAIT_FOR_CTS;
            }
            break;
        case WAIT_FOR_CTS:
            /* wait for the data pump to indicate the completion of training */
            /* transmission and the readiness to transmit data */
            if (modem_dp_CTS_status())
            {
                /* provide one second of flags to allow the remote PLL to sync */
                fax2_utility_timer = DELAY_1SECOND_FLAGS;
                fax2_utility_state = WAIT_FOR_FLAG;
            }
            break;
        case WAIT_FOR_FLAG:
            /* is one second flags complete */
            if (!fax2_utility_timer)
            {
                /* start transmission of the first packet */
                fax_line_tx_block((ubyte *)&fax2_buffer_array[fax2_head_index]);
                fax2_utility_state = WAIT_TX_COMPLETE;
            }
            break;
        case WAIT_TX_COMPLETE:
            /* if all scheduled packets have been transmitted */
            if (fax2_head_index == fax2_tail_index)
            {
                /* allow enough time for the end flag of the last packet */
                /* to propagate through both data pumps before dropping carrier */
                fax2_utility_timer = DELAY_HDLC_PROPAGATE;
                fax2_utility_state = WAIT_TO_TERMINATE;
            }
            break;
        case WAIT_TO_TERMINATE:
            /* if propagation delay is complete */
            if (!fax2_utility_timer)
            {
/* start change 2/10/95 rjm */
                /*
                   Here is where we determine if we are truley
                   completed Tx'ing the HDLC frames. Decrement
                   the outgoing packet counter, if not '0' then
                   repoint the 'fax2_tail_index' at the next
                   frame and let it go.
                */
                if( --fax2_num_tx_packets )
                  {
                     fax2_tail_index = fax2_head_index+1;
                     /* start transmission of the next packet */
                     fax_line_tx_block((ubyte *)&fax2_buffer_array[fax2_head_index]);
                     fax2_utility_state = WAIT_TX_COMPLETE;
                  }
                else
                  {
                     /* terminate line configuration */
                     fax2_cleanup();
                     fax2_utility_state = INITIALIZE;
                     /* indicate transmission complete */
                     return(TRUE);
                  }
/* end change 2/10/95 rjm */
            }
            break;
    }
    /* transmission in progress */
    return(FALSE);
}

/* creates the CTC packet containing the first 16 bits of the DCS. Although
all 16 bits are specified, the T.30 Annex A specifies that the receiver is 
supposed to use only bits 11-14 to determine the new Phase C message carrier
data rate */
void fax2_generate_CTC(hdlc_buffer_type *buffer_ptr)
{

    /* clear all the FIF fields */
    buffer_ptr->data[FIF_1] = 0;
    buffer_ptr->data[FIF_2] = 0;

    /* indicate the capability to receive */
    buffer_ptr->data[FIF_2] |= fax2_capability_receive ? DCS_RECEIVE : 0;
    /* indicate the negotiated modulation and speed */
    buffer_ptr->data[FIF_2] |= fax2_generate_DCS_BR_table[fax2_negotiated.BR];
    /* indicate the negotiated vertical resolution */
    buffer_ptr->data[FIF_2] |= fax2_negotiated.VR ? DCS_VR : 0;
    /* indicate the negotiated encoding scheme */
    buffer_ptr->data[FIF_2] |= fax2_negotiated.DF >= DF_MR ? DCS_DF_MR : 0;

    /* two bytes of FIF are going to be transmitted */
    buffer_ptr->count += 2;
}

void fax2_generate_PPR(hdlc_buffer_type *buffer_ptr)
{
    ubyte *copy_from;
    ubyte *copy_to;
    ubyte i;

    buffer_ptr->count += PPR_FIF_SIZE; /* 32 bytes in FIF */

    copy_from = fax2_ECM_fax2_ECM_PPR_FIF_ptr_page();
    copy_to = &(buffer_ptr->data[FIF_1]);
    for (i=0; i <= (PPR_FIF_SIZE-1); ++i)
        *(copy_to++) = *(copy_from++);
}

/******************************************************************************
/
/   Routine: fax2_schedule_tx_packet
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine prepares the indicated packet and queues it up
/                for transmission.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: fax2_tail_index
/
/   Users: fax2_phaseB_receive(), fax2_phaseB_transmit(),
/          fax2_phaseD_receive(), fax2_phaseD_transmit(),
/          fax2_phaseE
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_schedule_tx_packet(ubyte packet_opcode, ubyte packet_opcode2)
{
    hdlc_buffer_type *buffer_ptr;
    ubyte i, j, *temp_ptr;

    /* get a pointer to the next free packet */
    buffer_ptr = &fax2_buffer_array[fax2_tail_index++];
    if (fax2_tail_index == HDLC_BUFFER_COUNT)
            fax2_tail_index = 0;

    /* configure the basic packet header */
    buffer_ptr->data[AF] = ADDRESS_VALUE;
    buffer_ptr->data[CF] = CONTROL_VALUE;
    buffer_ptr->data[FCF] = packet_opcode;
    buffer_ptr->count = BASE_COUNT;

    /* build the facsimile information field according to the opcode */
    switch (packet_opcode)
    {
        case DIS_PACKET:
        case DTC_PACKET:
            /* last packet in the set */
            buffer_ptr->data[CF] |= FINAL_FRAME_MASK;
            /* build a capabilities packet */
            fax2_generate_DIS_DTC(buffer_ptr);
            break;
        case DCS_PACKET:
            /* last packet in the set */
            buffer_ptr->data[CF] |= FINAL_FRAME_MASK;
            buffer_ptr->data[FCF] |= fax2_received_valid_DIS;
            /* build the negotiation packet */
            fax2_generate_DCS(buffer_ptr);
            break;
        case TSI_PACKET:
            buffer_ptr->data[FCF] |= fax2_received_valid_DIS;
        case CSI_PACKET:
            /* ID packet have a constant length */
            buffer_ptr->count = BASE_COUNT + ID_LENGTH;
            /* copy the ID string into the packet */
            /* reverse the character ordering and space pad at the end */
            temp_ptr = fax2_local_id_string;
            /* count the number of chars in the string */
            for (j = 0 ; *temp_ptr++ ; j++);
            /* pad the unused characters with spaces */
            for (i = BASE_COUNT + j ; i < BASE_COUNT+ID_LENGTH ; i++)
                buffer_ptr->data[i] = ' ';
            /* start copying in after the pad bytes */
            i = BASE_COUNT + j - 1;
            /* get a pointer to the string */
            temp_ptr = fax2_local_id_string;
            while (*temp_ptr)
                buffer_ptr->data[i--] = *temp_ptr++;
            break;
        case CIG_PACKET:
            /* ID packet have a constant length */
            buffer_ptr->count = BASE_COUNT + ID_LENGTH;
            /* copy the ID string into the packet */
            /* reverse the character ordering and space pad at the end */
            temp_ptr = fax2_polling_id_string;
            /* count the number of chars in the string */
            for (j = 0 ; *temp_ptr++ ; j++);
            /* pad the unused characters with spaces */
            for (i = BASE_COUNT + j ; i < BASE_COUNT+ID_LENGTH ; i++)
                buffer_ptr->data[i] = ' ';
            /* start copying in after the pad bytes */
            i = BASE_COUNT + j - 1;
            /* get a pointer to the string */
            temp_ptr = fax2_polling_id_string;
            while (*temp_ptr)
                buffer_ptr->data[i--] = *temp_ptr++;
            break;
        case NSS_PACKET:
            buffer_ptr->data[FCF] |= fax2_received_valid_DIS;
        case NSF_PACKET:
        case NSC_PACKET:
            temp_ptr = fax2_nonstandard_string;
            i = BASE_COUNT;
            /* convert the string from hex ASCII to decimal and put in string */
            while (*temp_ptr)
            {
                buffer_ptr->data[i++] = fax2_hex_a_to_d(temp_ptr);
                temp_ptr += 2;
            }
            /* write the new packet size into the packet header */
            buffer_ptr->count = i;
            break;
        case CFR_PACKET:
        case FTT_PACKET:
        case EOM_PACKET:
        case MPS_PACKET:
        case EOP_PACKET:
        case PRI_EOM_PACKET:
        case PRI_MPS_PACKET:
        case PRI_EOP_PACKET:
        case MCF_PACKET:
        case RTP_PACKET:
        case RTN_PACKET:
        case PIP_PACKET:
        case DCN_PACKET:
        case CRP_PACKET:
        case ERR_PACKET:
        case RR_PACKET:
        case RNR_PACKET:
        case CTR_PACKET:
            /* last packet in the set */
            buffer_ptr->data[CF] |= FINAL_FRAME_MASK;
            buffer_ptr->data[FCF] |= fax2_received_valid_DIS;
            break;
        case PPS_FCF1_PACKET:
        case EOR_FCF1_PACKET:
            buffer_ptr->data[CF] |= FINAL_FRAME_MASK;
            buffer_ptr->data[FCF] |= fax2_received_valid_DIS;
            /*Write in the second byte of the PPS-XXX facsimile control field.
            Note that this second byte occupies what would be the "facsimile
            information field #1" in a packet with a one-byte FCF*/
            buffer_ptr->data[FIF_1] = packet_opcode2;
            buffer_ptr->count++; /* 2nd opcode */

            if (packet_opcode == EOR_FCF1_PACKET)
                break; /* no other information needed for EOR */

            /* Get partial page information (i.e., counter, block counter,
            and number of frames */
            buffer_ptr->data[FIF_2] = fax2_ECM_pagenumless1_page(); /* page counter */
            buffer_ptr->data[FIF_3] = fax2_ECM_blocknumless1_page(); /* block counter */
            buffer_ptr->data[FIF_4] = fax2_ECM_numframesless1_page(); /* num frames*/

            /* FIF2+FIF3+FIF4 = 3 bytes in "facsimile control field", if
            FCF2 is regardes as being the first byte in the FIF! */    
            buffer_ptr->count += 3;
            break;
        case CTC_PACKET:
            buffer_ptr->data[CF] |= FINAL_FRAME_MASK;
            buffer_ptr->data[FCF] |= fax2_received_valid_DIS;
            fax2_generate_CTC(buffer_ptr);
            break;
       case PPR_PACKET:
            buffer_ptr->data[CF] |= FINAL_FRAME_MASK;
            buffer_ptr->data[FCF] |= fax2_received_valid_DIS;
            fax2_generate_PPR(buffer_ptr);
            break;
    }
    /* if APP debug is active then display all packets before transmission */
    if (fax2_debug)
        fax2_display_debug(TX_MODE, buffer_ptr);
}

/******************************************************************************
/
/   Routine: fax2_accept_DIS_DTC
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine negotiates the T.30 transmition parameters.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: fax2_negotiated
/
/   Users: fax2_phaseB_transmit()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_accept_DIS_DTC(void)
{
    ubyte fax2_temp_WD;

    /* index into a two dimentional array with the local and remote capabilities */
    fax2_negotiated.BR = fax2_accept_DIS_BR_table[fax2_session.BR]
                         [(fax2_buffer_ptr->data[FIF_2] & BR_MASK) >> BR_FLUSH];

    /* if both sides are capable of fine resolution */
    if ((fax2_buffer_ptr->data[FIF_2] & VR_MASK) && fax2_session.VR)
        fax2_negotiated.VR = TRUE;
    else
        /* normal resolution */
        fax2_negotiated.VR = FALSE;

    /* if both sides are capable of two dimentional encoding */
    if ((fax2_buffer_ptr->data[FIF_2] & TWO_D_MASK) &&
       fax2_session.DF >= DF_MR)
        fax2_negotiated.DF = DF_MR;
    else
        /* one dimentional encoding */
        fax2_negotiated.DF = DF_MH;

    /* this field handles widths up to 2432 */
    /* if the width can be larger it will be handled in another field */
    if (fax2_session.WD > WD_2432)
        fax2_temp_WD = WD_2432;
    else
        fax2_temp_WD = fax2_session.WD;

    /* index into a two dimentional array with the local and remote capabilities */
    fax2_negotiated.WD = fax2_accept_DIS_WD_table[fax2_temp_WD]
                         [fax2_buffer_ptr->data[FIF_3] & WD_MASK];
    fax2_negotiated.LN = fax2_accept_DIS_LN_table[fax2_session.LN]
                         [(fax2_buffer_ptr->data[FIF_3] & LN_MASK) >> LN_FLUSH];
    fax2_negotiated.ST = fax2_accept_DIS_ST_table[fax2_session.ST]
                         [(fax2_buffer_ptr->data[FIF_3] & ST_MASK) >> ST_FLUSH];

    /* assume no ECM incase the DIS FIF stops at this point */
    fax2_negotiated.EC = FALSE;
    fax2_negotiated.BF = FALSE;

    /* are there any more fields to negotiate */
    if (!(fax2_buffer_ptr->data[FIF_3] & EXTEND_FIELD))
        return;

    /* uncommpressed mode is independent of one or two dimentional encoding */
    if ((fax2_buffer_ptr->data[FIF_4] & UNCOMPRESSED_MASK) &&
       fax2_session.DF >= DF_UM)
        fax2_negotiated.DF = DF_UM;

    /* if both sides are capable of ECM */
    if ((fax2_buffer_ptr->data[FIF_4] & ECM_MASK) && fax2_session.EC)
    {
        fax2_negotiated.EC = TRUE;
        fax2_negotiated.ST = ST_0;
    }

    /* ECM neotiated and both sides are capable of T.6 */
    if (fax2_negotiated.EC && 
       (fax2_buffer_ptr->data[FIF_4] & T6_MASK) && fax2_session.DF == DF_MMR)
        fax2_negotiated.DF = DF_MMR;

    /* are there any more fields to negotiate */
    if (!(fax2_buffer_ptr->data[FIF_4] & EXTEND_FIELD))
        return;

    /* if the extended width bits are active and both sides can do 1216 */
    if ((fax2_buffer_ptr->data[FIF_5] & WD_FBI_MASK) &&
       (fax2_buffer_ptr->data[FIF_5] & WD_1216_MASK) &&
       fax2_session.WD >= WD_1216)
        fax2_negotiated.WD = WD_1216;

    /* if the extended width bits are active and both sides can do 864 */
    if ((fax2_buffer_ptr->data[FIF_5] & WD_FBI_MASK) &&
       (fax2_buffer_ptr->data[FIF_5] & WD_864_MASK) &&
       fax2_session.WD == WD_864)
        fax2_negotiated.WD = WD_864;

    /* are there any more fields to negotiate */
    if (!(fax2_buffer_ptr->data[FIF_5] & EXTEND_FIELD) ||
        !(fax2_buffer_ptr->data[FIF_6] & EXTEND_FIELD))
        return;

    /* ECM neotiated and both sides are capable of BFT */
    if (fax2_negotiated.EC && (fax2_buffer_ptr->data[FIF_7] & BF_MASK) &&
       fax2_session.BF)
        fax2_negotiated.BF = TRUE;

}

/******************************************************************************
/
/   Routine: fax2_translate_DIS_DTC
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine translates the DIS or DTC parameters into a
/                class 2 format to be to responded to the APP.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: fax2_remote_indicated_poll,
/                             fax2_remote_indicated_receive, fax2_translate
/
/   Users: fax2_phaseB_transmit()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_translate_DIS_DTC(void)
{

    /* does the remote have a document to be polled */
    fax2_remote_indicated_poll = fax2_buffer_ptr->data[FIF_2] & TRANSMIT_MASK ?
                                 TRUE : FALSE;
    /* does the remote have the capability to receive a document */
    fax2_remote_indicated_receive = fax2_buffer_ptr->data[FIF_2] & RECEIVE_MASK ?
                                    TRUE : FALSE;
    /* get the remotes receive baud rate capability */
    fax2_translate.BR = fax2_translate_DIS_BR_table
                        [(fax2_buffer_ptr->data[FIF_2] & BR_MASK) >> BR_FLUSH];
    /* get the remotes vertical resolution capability */
    fax2_translate.VR = fax2_buffer_ptr->data[FIF_2] & VR_MASK ? TRUE : FALSE;
    /* determine the remote one or two dimentional encoding capability */
    fax2_translate.DF = fax2_buffer_ptr->data[FIF_2] & TWO_D_MASK ? DF_MR : DF_MH;
    /* determine the remote width capability */
    fax2_translate.WD = fax2_translate_DIS_WD_table
                        [fax2_buffer_ptr->data[FIF_3] & WD_MASK];
    /* determine the remote length capability */
    fax2_translate.LN = fax2_translate_DIS_LN_table
                        [(fax2_buffer_ptr->data[FIF_3] & LN_MASK) >> LN_FLUSH];
    /* determine the remote minimum scan time capability */
    fax2_translate.ST = fax2_translate_DIS_ST_table
                        [(fax2_buffer_ptr->data[FIF_3] & ST_MASK) >> ST_FLUSH];

    /* assume the remote is not capable of ECM or BFT */
    fax2_translate.EC = FALSE;
    fax2_translate.BF = FALSE;

    /* are there any more fields to translate */
    if (!(fax2_buffer_ptr->data[FIF_3] & EXTEND_FIELD))
        return;

    /* determine the remote uncompressed encoding capability */
    if (fax2_buffer_ptr->data[FIF_4] & UNCOMPRESSED_MASK)
        fax2_translate.DF = DF_UM;

    /* determine the remote ECM capability */
    if (fax2_buffer_ptr->data[FIF_4] & ECM_MASK)
        fax2_translate.EC = TRUE;

    /* determine the remote T.6 encoding capability */
    if (fax2_buffer_ptr->data[FIF_4] & T6_MASK)
        fax2_translate.DF = DF_MMR;

    /* are there any more fields to translate */
    if (!(fax2_buffer_ptr->data[FIF_4] & EXTEND_FIELD))
        return;

    /* determine the remotes extended width capabilities */
    if (fax2_buffer_ptr->data[FIF_5] & WD_FBI_MASK)
    {
        if (fax2_buffer_ptr->data[FIF_5] & WD_1216_MASK)
            fax2_translate.WD = WD_1216;
        if (fax2_buffer_ptr->data[FIF_5] & WD_864_MASK)
            fax2_translate.WD = WD_864;
    }

    /* are there any more fields to translate */
    if (!(fax2_buffer_ptr->data[FIF_5] & EXTEND_FIELD) ||
        !(fax2_buffer_ptr->data[FIF_6] & EXTEND_FIELD))
        return;

    /* determine the remote BFT capability */
    if (fax2_buffer_ptr->data[FIF_7] & BF_MASK)
        fax2_translate.BF = TRUE;

}

/******************************************************************************
/
/   Routine: fax2_accept_DCS
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine translates the received DCS parameters into a
/                class 2 format. It will be used for APP responses, and T.30
/                configuration.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: fax2_negotiated
/
/   Users: fax2_phaseB_receive()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_accept_DCS(void)
{

    /* translate the negotiated baud rate into a class 2 format */
    fax2_negotiated.BR = fax2_accept_DCS_BR_table
                         [(fax2_buffer_ptr->data[FIF_2] & BR_MASK) >> BR_FLUSH];
    /* determine the negotiated T.30 vertical resolution */
    fax2_negotiated.VR = fax2_buffer_ptr->data[FIF_2] & VR_MASK ? TRUE : FALSE;
    /* determine if the encoding is one or two dimentional */
    fax2_negotiated.DF = fax2_buffer_ptr->data[FIF_2] & TWO_D_MASK ? DF_MR : DF_MH;
    /* translate the negotiated width into a class 2 format */
    fax2_negotiated.WD = fax2_accept_DCS_WD_table
                         [fax2_buffer_ptr->data[FIF_3] & WD_MASK];
    /* translate the negotiated length into a class 2 format */
    fax2_negotiated.LN = fax2_accept_DCS_LN_table
                         [(fax2_buffer_ptr->data[FIF_3] & LN_MASK) >> LN_FLUSH];
    /* translate the negotiated scan time into a class 2 format */
    fax2_negotiated.ST = fax2_accept_DCS_ST_table
                         [(fax2_buffer_ptr->data[FIF_3] & ST_MASK) >> ST_FLUSH];

    /* assume ECM and BFT capabilities are not negotiated */
    fax2_negotiated.EC = FALSE;
    fax2_negotiated.BF = FALSE;

    /* are there any more fields to note */
    if (!(fax2_buffer_ptr->data[FIF_3] & EXTEND_FIELD))
        return;

    /* determine the negotiated uncompressed encoding capability */
    if (fax2_buffer_ptr->data[FIF_4] & UNCOMPRESSED_MASK)
        fax2_negotiated.DF = DF_UM;

    /* determine the negotiated ECM capability */
    if (fax2_buffer_ptr->data[FIF_4] & ECM_MASK)
    {
        /* Allow ECM receiver a change to initialize itself*/
        fax2_ECM_rcv_init_page();
        fax2_negotiated.EC = TRUE;
        fax2_ECM_accept_framesize_page(
            (fax2_buffer_ptr->data[FIF_4] & ECM_64FS_MASK) ? TRUE : FALSE);
    }

    /* determine the negotiated T.6 encoding capability */
    if (fax2_buffer_ptr->data[FIF_4] & T6_MASK)
        fax2_negotiated.DF = DF_MMR;

    /* are there any more fields to note */
    if (!(fax2_buffer_ptr->data[FIF_4] & EXTEND_FIELD))
        return;

    /* determine the negotiated extended width capabilities */
    if (fax2_buffer_ptr->data[FIF_5] & WD_FBI_MASK)
    {
        if (fax2_buffer_ptr->data[FIF_5] & WD_1216_MASK)
            fax2_negotiated.WD = WD_1216;
        if (fax2_buffer_ptr->data[FIF_5] & WD_864_MASK)
            fax2_negotiated.WD = WD_864;
    }

    /* are there any more fields to note */
    if (!(fax2_buffer_ptr->data[FIF_5] & EXTEND_FIELD) ||
        !(fax2_buffer_ptr->data[FIF_6] & EXTEND_FIELD))
        return;

    /* determine the negotiated BFT capability */
    if (fax2_buffer_ptr->data[FIF_7] & BF_MASK)
        fax2_negotiated.BF = TRUE;

}

/******************************************************************************
/
/   Routine: fax2_generate_DIS_DTC
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine creates a DIS/DTC packet from the class 2
/                configured T.30 parameters.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_schedule_tx_packet()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_generate_DIS_DTC(hdlc_buffer_type *buffer_ptr)
{

    /* clear all the FIF fields */
    buffer_ptr->data[FIF_1] = 0;
    buffer_ptr->data[FIF_2] = 0;
    buffer_ptr->data[FIF_3] = 0;
    buffer_ptr->data[FIF_4] = 0;
    buffer_ptr->data[FIF_5] = 0;
    buffer_ptr->data[FIF_6] = 0;
    buffer_ptr->data[FIF_7] = 0;

    /* indicate if there's a document to be polled */
    buffer_ptr->data[FIF_2] |= fax2_capability_transmit_poll ? DIS_TRANSMIT : 0;
    /* indicate the capability to receive */
    buffer_ptr->data[FIF_2] |= fax2_capability_receive ? DIS_RECEIVE : 0;
    /* indicate the highest V-series modulation that can be fully supported */
    buffer_ptr->data[FIF_2] |= fax2_generate_DIS_BR_table[fax2_session.BR];
    /* indicate the vertical resolution capability */
    buffer_ptr->data[FIF_2] |= fax2_session.VR ? DIS_VR : 0;
    /* indicate one or two dimentional encoding capability */
    buffer_ptr->data[FIF_2] |= fax2_session.DF >= DF_MR ? DIS_DF_MR : 0;

    /* if the width capability is not an extended one, indicate it */
    if (fax2_session.WD <= WD_2432)
        buffer_ptr->data[FIF_3] |= fax2_generate_DIS_WD_table[fax2_session.WD];

    /* indicate the length capability */
    buffer_ptr->data[FIF_3] |= fax2_generate_DIS_LN_table[fax2_session.LN];
    /* indicate the scan time capability */
    buffer_ptr->data[FIF_3] |= fax2_generate_DIS_ST_table[fax2_session.ST];

    /* three bytes of FIF have been configured */
    buffer_ptr->count += 3;

    /* if there is no need for the extended configuration fields, stop here */
    if (!(fax2_session.DF >= DF_UM || fax2_session.EC ||
        fax2_session.WD >= WD_1216))
        return;

    /* indicate another configuration byte */
    buffer_ptr->data[FIF_3] |= EXTEND_FIELD;
    /* configure uncompressed capability */
    buffer_ptr->data[FIF_4] |= fax2_session.DF >= DF_UM ? DIS_DF_UM : 0;
    /* configure ECM capability */
    buffer_ptr->data[FIF_4] |= fax2_session.EC ? DIS_ECM : 0;
    /* if ECM and T.6 capability, indicate T.6 capability */
    buffer_ptr->data[FIF_4] |= fax2_session.EC && fax2_session.DF == DF_MMR ?
                               DIS_DF_MMR : 0;
    /* add one to the packet size */
    buffer_ptr->count++;

    /* if there is no need for the extended configuration fields, stop here */
    if (fax2_session.WD < WD_1216 && !(fax2_session.BF && fax2_session.EC))
        return;

    /* indicate another configuration byte */
    buffer_ptr->data[FIF_4] |= EXTEND_FIELD;
    /* configure the extended width capability */
    buffer_ptr->data[FIF_5] |= fax2_session.WD >= WD_1216 ? DIS_WD_FBI : 0;
    buffer_ptr->data[FIF_5] |= fax2_session.WD >= WD_1216 ? DIS_WD_1216 : 0;
    buffer_ptr->data[FIF_5] |= fax2_session.WD == WD_864 ? DIS_WD_864 : 0;

    /* add one to the packet size */
    buffer_ptr->count ++;

    /* if there is no need for the extended configuration fields, stop here */
    if (!(fax2_session.BF && fax2_session.EC))
        return;

    /* indicate another configuration byte */
    buffer_ptr->data[FIF_5] |= EXTEND_FIELD;
    /* indicate another configuration byte */
    buffer_ptr->data[FIF_6] |= EXTEND_FIELD;

    /* indicate BFT capability */
    buffer_ptr->data[FIF_7] |= DIS_BF;

    /* add two to the packet size */
    buffer_ptr->count +=2;
}

/******************************************************************************
/
/   Routine: fax2_generate_DCS
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine creates a DCS packet from the class 2 negotiated
/                T.30 parameters.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_schedule_tx_packet()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void fax2_generate_DCS(hdlc_buffer_type *buffer_ptr)
{

    /* clear all the FIF fields */
    buffer_ptr->data[FIF_1] = 0;
    buffer_ptr->data[FIF_2] = 0;
    buffer_ptr->data[FIF_3] = 0;
    buffer_ptr->data[FIF_4] = 0;
    buffer_ptr->data[FIF_5] = 0;
    buffer_ptr->data[FIF_6] = 0;
    buffer_ptr->data[FIF_7] = 0;

    /* indicate the capability to receive */
    buffer_ptr->data[FIF_2] |= fax2_capability_receive ? DCS_RECEIVE : 0;
    /* indicate the negotiated modulation and speed */
    buffer_ptr->data[FIF_2] |= fax2_generate_DCS_BR_table[fax2_negotiated.BR];
    /* indicate the negotiated vertical resolution */
    buffer_ptr->data[FIF_2] |= fax2_negotiated.VR ? DCS_VR : 0;
    /* indicate the negotiated encoding scheme */
    buffer_ptr->data[FIF_2] |= fax2_negotiated.DF >= DF_MR ? DCS_DF_MR : 0;

    /* if the width capability is not an extended one, indicate it */
    if (fax2_negotiated.WD <= WD_2432)
        buffer_ptr->data[FIF_3] |= fax2_generate_DCS_WD_table[fax2_negotiated.WD];

    /* indicate the negotiated length */
    buffer_ptr->data[FIF_3] |= fax2_generate_DCS_LN_table[fax2_negotiated.LN];
    /* indicate the negotiated scan time */
    buffer_ptr->data[FIF_3] |= fax2_generate_DCS_ST_table[fax2_negotiated.VR]
                                                         [fax2_negotiated.ST];

    /* three bytes of FIF have been configured */
    buffer_ptr->count += 3;

    /* if there is no need for the extended configuration fields, stop here */
    if (!(fax2_negotiated.DF >= DF_UM || fax2_negotiated.EC ||
        fax2_negotiated.WD >= WD_1216))
        return;

    /* indicate another configuration byte */
    buffer_ptr->data[FIF_3] |= EXTEND_FIELD;

    /* indicate the negotiated ECM capability */
    buffer_ptr->data[FIF_4] |= fax2_negotiated.EC ? DCS_ECM : 0;
    /* negotiated 64/256 byte ECM framesize */
    buffer_ptr->data[FIF_4] |=
        fax2_ECM_determine_framesize_page() ? DCS_ECM_FS64 : 0;
    /* indicate the negotiated uncompressed encoding scheme */
    buffer_ptr->data[FIF_4] |= fax2_negotiated.DF >= DF_UM ? DCS_DF_UM : 0;
    /* indicate the negotiated T.6 capability */
    buffer_ptr->data[FIF_4] |= fax2_negotiated.DF == DF_MMR ? DCS_DF_MMR : 0;

    /* add one to the packet size */
    buffer_ptr->count ++;

    /* if there is no need for the extended configuration fields, stop here */
    if (fax2_negotiated.WD < WD_1216 && !fax2_negotiated.BF)
        return;

    /* indicate another configuration byte */
    buffer_ptr->data[FIF_4] |= EXTEND_FIELD;

    /* indicate the negotiated extended width capability */
    buffer_ptr->data[FIF_5] |= fax2_negotiated.WD >= WD_1216 ? DCS_WD_FBI : 0;
    buffer_ptr->data[FIF_5] |= fax2_negotiated.WD == WD_1216 ? DCS_WD_1216 : 0;
    buffer_ptr->data[FIF_5] |= fax2_negotiated.WD == WD_864 ? DCS_WD_864 : 0;

    /* add one to the packet size */
    buffer_ptr->count ++;

    /* if there is no need for the extended configuration fields, stop here */
    if (!fax2_negotiated.BF)
        return;

    /* indicate another configuration byte */
    buffer_ptr->data[FIF_5] |= EXTEND_FIELD;
    /* indicate another configuration byte */
    buffer_ptr->data[FIF_6] |= EXTEND_FIELD;

    /* indicate BFT negotiated */
    buffer_ptr->data[FIF_7] |= DCS_BF;

    /* add two to the packet size */
    buffer_ptr->count += 2;
}

/* ECM CTC packets dictate new baud rates */
void fax2_accept_CTC(void)
{
    /* translate the negotiated baud rate into a class 2 format */
    fax2_negotiated.BR = fax2_accept_DCS_BR_table
                         [(fax2_buffer_ptr->data[FIF_2] & BR_MASK) >> BR_FLUSH];
}

