/****************************************************************************
/
/   Copyright, 1991,1992,1993,1994.       All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/   File: f2x00cm.c
/
/   Module Version: 4.03 (change the FREV_IDENTIFICATION when changing this number)
/
/   Function: This file contains the command execution code for the
/             FAX class 2 (SP-2388).
/
/   Product: Class 2 FAX Module
/
/   History: fx00cmd2.c 1.00
/
/   Created: 9/21/92
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
****************************************************************************/
#include "sys_def.h"

#include "f2x_def.h"
#include "f2x_mem.h"
#include "f2x_pro.h"

#define FAX2_FAXERR_CAPABILITY  "\r\n(0-103)\r\n"
#define FAX2_FBADLIN_CAPABILITY "\r\n0\r\n"
#define FAX2_FBADMUL_CAPABILITY "\r\n0\r\n"
#define FAX2_FBOR_CAPABILITY    "\r\n(0-3)\r\n"
#define FAX2_FBUG_CAPABILITY    "\r\n(0-1)\r\n"
#define FAX2_FCQ_CQ_CAPABILITY "\r\n(0-1)\r\n"
#define FAX2_FCQ_NOCQ_CAPABILITY "\r\n0\r\n"
#define FAX2_FCQ_CAPABILITY     "\r\n0\r\n"
#define FAX2_FCR_CAPABILITY     "\r\n(0-1)\r\n"
#define FAX2_FCTCRTY_CAPABILITY "\r\n(0-255)\r\n"
#define FAX2_FDFFC_CAPABILITY   "\r\n0\r\n"
#define FAX2_FDCC96_CAPABILITY  "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX2_FDCC96ECM_CAPABILITY "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX2_FDCC144_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX2_FDCC144ECM_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX2_FDIS96_CAPABILITY  "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX2_FDIS96ECM_CAPABILITY "\r\n(0-1),(0-3),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX2_FDIS144_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0),(0),(0-7)\r\n"
#define FAX2_FDIS144ECM_CAPABILITY "\r\n(0-1),(0-5),(0-4),(0-2),(0-3),(0-1),(0-1),(0-7)\r\n"
#define FAX2_FECM_CAPABILITY    "\r\n0\r\n"
#define FAX2_FET_CAPABILITY     "\r\n(0-2)\r\n"
#define FAX2_FLID_CAPABILITY    "\r\n(20)(32-126)\r\n"
#define FAX2_FLNFC_CAPABILITY   "\r\n0\r\n"
#define FAX2_FLPL_CAPABILITY    "\r\n(0-1)\r\n"
#define FAX2_FMDL_IDENTIFICATION "\r\nFAX CLASS 2 (TIA/EIA SP-2388)\r\n"

#define FAX2_FMINSP96_CAPABILITY "\r\n(0-3)\r\n"
#define FAX2_FMINSP144_CAPABILITY "\r\n(0-5)\r\n"
#define FAX2_FPHCTO_CAPABILITY  "\r\n(0-255)\r\n"
#define FAX2_FPTS_CAPABILITY    "\r\n(1-3)\r\n"
#define FAX2_FREV_IDENTIFICATION "\r\nRSA REV 4.03 \r\n"
#define FAX2_FRBC_CAPABILITY    "\r\n0\r\n"
#define FAX2_FREL_CAPABILITY    "\r\n0\r\n"
#define FAX2_FSPL_CAPABILITY    "\r\n(0-1)\r\n"
#define FAX2_FTBC_CAPABILITY    "\r\n0\r\n"
#define FAX2_FVRFC_CAPABILITY   "\r\n0\r\n"
#define FAX2_FWDFC_CAPABILITY   "\r\n0\r\n"

/* start change keh 12/94 => add new parser */
/* MAX values for T.30 Session Subparm Codes (TIA/592- table 8.4) */
static const ubyte fax2_T30_range_array[] = {1, 5, 4, 2, 3, 1, 1, 7};
/* end change keh 12/94 => add new parser */

ubyte fax2_execute_command(uword, ubyte *, ubyte **);
void fax2_store_string(ubyte *, ubyte **);

/******************************************************************************
/
/   Routine: fax2_execute_command
/
/   Author: RSA
/
/   Creation Date: 09/24/92
/
/   Description: This routine is called from the FAX parser to execute
/                a FAX class 2 2388 command.
/
/   Input Parameters: uword     command
/                               FAX2_FBADLIN_COMMAND    100
/                               FAX2_FBADMUL_COMMAND    101
/                               FAX2_FBOR_COMMAND       102
/                               FAX2_FBUG_COMMAND       103
/                               FAX2_FCQ_COMMAND        104
/                               FAX2_FCR_COMMAND        105
/                               FAX2_FCTCRTY_COMMAND    106
/                               FAX2_FDCC_COMMAND       107
/                               FAX2_FDFFC_COMMAND      108
/                               FAX2_FDIS_COMMAND       109
/                               FAX2_FDR_COMMAND        110
/                               FAX2_FDT_COMMAND        111
/                               FAX2_FECM_COMMAND       112
/                               FAX2_FET_COMMAND        113
/                               FAX2_FK_COMMAND         114
/                               FAX2_FLID_COMMAND       115
/                               FAX2_FLNFC_COMMAND      116
/                               FAX2_FLPL_COMMAND       117
/                               FAX2_FMINSP_COMMAND     118
/                               FAX2_FPHCTO_COMMAND     119
/                               FAX2_FPTS_COMMAND       120
/                               FAX2_FRBC_COMMAND       121
/                               FAX2_FREL_COMMAND       122
/                               FAX2_FSPL_COMMAND       123
/                               FAX2_FTBC_COMMAND       124
/                               FAX2_FVRFC_COMMAND      125
/                               FAX2_FWDFC_COMMAND      126
/                               FAX2_FAXERR_REQUEST     127
/                               FAX2_FBADLIN_REQUEST    128
/                               FAX2_FBADMUL_REQUEST    129
/                               FAX2_FBOR_REQUEST       130
/                               FAX2_FBUF_REQUEST       131
/                               FAX2_FBUG_REQUEST       132
/                               FAX2_FCQ_REQUEST        133
/                               FAX2_FCR_REQUEST        134
/                               FAX2_FCTCRTY_REQUEST    135
/                               FAX2_FDCC_REQUEST       136
/                               FAX2_FDCS_REQUEST       137
/                               FAX2_FDFFC_REQUEST      138
/                               FAX2_FDIS_REQUEST       139
/                               FAX2_FECM_REQUEST       140
/                               FAX2_FET_REQUEST        141
/                               FAX2_FLID_REQUEST       142
/                               FAX2_FLNFC_REQUEST      143
/                               FAX2_FLPL_REQUEST       144
/                               FAX2_FMDL_REQUEST       145
/                               FAX2_FMFR_REQUEST       146
/                               FAX2_FREV_REQUEST       147
/                               FAX2_FMINSP_REQUEST     148
/                               FAX2_FPHCTO_REQUEST     149
/                               FAX2_FPTS_REQUEST       150
/                               FAX2_FRBC_REQUEST       151
/                               FAX2_FREL_REQUEST       152
/                               FAX2_FSPL_REQUEST       153
/                               FAX2_FTBC_REQUEST       154
/                               FAX2_FVRFC_REQUEST      155
/                               FAX2_FWDFC_REQUEST      156
/                               FAX2_FAXERR_QUERY       157
/                               FAX2_FBADLIN_QUERY      158
/                               FAX2_FBADMUL_QUERY      159
/                               FAX2_FBOR_QUERY         160
/                               FAX2_FBUG_QUERY         161
/                               FAX2_FCQ_QUERY          162
/                               FAX2_FCR_QUERY          163
/                               FAX2_FCTCRTY_QUERY      164
/                               FAX2_FDCC_QUERY         165
/                               FAX2_FDCS_QUERY         166
/                               FAX2_FDFFC_QUERY        167
/                               FAX2_FDIS_QUERY         168
/                               FAX2_FDR_QUERY          169
/                               FAX2_FDT_QUERY          170
/                               FAX2_FECM_QUERY         171
/                               FAX2_FET_QUERY          172
/                               FAX2_FK_QUERY           173
/                               FAX2_FLID_QUERY         174
/                               FAX2_FLNFC_QUERY        175
/                               FAX2_FLPL_QUERY         176
/                               FAX2_FMINSP_QUERY       177
/                               FAX2_FPHCTO_QUERY       178
/                               FAX2_FPTS_QUERY         179
/                               FAX2_FRBC_QUERY         180
/                               FAX2_FREL_QUERY         181
/                               FAX2_FSPL_QUERY         182
/                               FAX2_FTBC_QUERY         183
/                               FAX2_FVRFC_QUERY        184
/                               FAX2_FWDFC_QUERY        185
/
/                     ubyte     *command_parm_ptr
/                               Pointer to single parameter or pointer to a
/                               list of parameters with the first byte
/                               indicating the parameter count. In the list
/                               format, a parameter with a value of -1 indicates
/                               no change from the previous value. This does not
/                               apply to the last parameter in the list.
/
/                     ubyte     **response_ptr_ptr
/                               A pointer to a location where the address of
/                               the response string should be placed.
/
/   Output Parameters: ubyte    function return code
/                      0        Go to online
/                      1        Continue parsing
/                      2        Discard rest of command line
/                               and respond with ERROR message
/
/   Global Variables Changed: FAX parameter variables
/
/   Users: fax2_parse()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Description:
/   Reason:
/
*******************************************************************************/
ubyte fax2_execute_command(uword command, ubyte *command_parm_ptr, ubyte **response_ptr_ptr)
{
/* start change keh 6/27/95 => rewrite for cleaner code */
/*   ubyte return_code, i, count, *info_ptr; */
   ubyte return_code, *info_ptr;
/* end change keh 6/27/95 => rewrite for cleaner code */
   uword tx_size, tx_count, rx_size, rx_count, total_tx_size, total_count;
/* start change keh 12/94 >> add new parser */
   ubyte field,value;
/* end change keh 12/94 >> add new parser */

   return_code = CONTINUE_PARSING; /* default to successful execution */

   /* assign the first location of the string to the ACU pointer */
   *response_ptr_ptr = (ubyte *)fax2_info_array;
   /* initialize a working pointer to load in the data */
   info_ptr = (ubyte *)fax2_info_array;

   switch (command)
   {
       case FAX2_FAXERR_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           /* convert the status value to its 2388 equivalent */
           fax2_store_dec_byte_page(fax2_error_translate_table[fax2_hangup_status], &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FAXERR_QUERY:
           fax2_store_string((ubyte *)FAX2_FAXERR_CAPABILITY, &info_ptr);
           break;

       case FAX2_FBADLIN_REQUEST:
           /* Intentionally fall through */
       case FAX2_FBADLIN_QUERY:
           fax2_store_string((ubyte *)FAX2_FBADLIN_CAPABILITY, &info_ptr);
           break;

       case FAX2_FBADLIN_COMMAND: /* not supported */
           if (*command_parm_ptr != 0)
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FBADMUL_REQUEST:
           /* Intentionally fall through */
       case FAX2_FBADMUL_QUERY:
           fax2_store_string((ubyte *)FAX2_FBADMUL_CAPABILITY, &info_ptr);
           break;

       case FAX2_FBADMUL_COMMAND:  /* not supported */
           if (*command_parm_ptr != 0)
               return_code = TERMINATE_WITH_ERROR;
           break;

        case FAX2_FBOR_REQUEST:
/* start change keh 6/27/95 => rename vars for new parser */
#if 0 /* orig code */
           i = fax2_data_bit_ordering + (fax2_hdlc_bit_ordering * 2);
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(i, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
#endif /* orig code */
           value = fax2_data_bit_ordering + (fax2_hdlc_bit_ordering * 2);
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(value, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
/* end change keh 6/27/95 => rename vars for new parser */
           break;

       case FAX2_FBOR_QUERY:
           fax2_store_string((ubyte *)FAX2_FBOR_CAPABILITY, &info_ptr);
           break;

       case FAX2_FBOR_COMMAND:
/* start change keh 6/27/95 => fix new parser bugs */
#if 0 /* orig code */
            fax2_data_bit_ordering = *command_parm_ptr % 2; /* bit 0 */
            fax2_hdlc_bit_ordering = *command_parm_ptr / 2; /* bit 1 */
#endif /* orig code */

           /* Get parameter from Parser */
           value = *command_parm_ptr;

           /* Check bounds on parameter: +FBOR=(0-3) */
           if (value < 3)
           {
               fax2_data_bit_ordering = *command_parm_ptr % 2; /* bit 0 */
               fax2_hdlc_bit_ordering = *command_parm_ptr / 2; /* bit 1 */
           }
           else
           {
               return_code = TERMINATE_WITH_ERROR;
           }
/* end change keh 6/27/95 => fix new parser bugs */
           break;

       case FAX2_FBUF_REQUEST:
           fax_dte_info(&tx_size, &tx_count, &rx_size, &rx_count);
           total_tx_size = rx_size;
           total_count = rx_count;
           fax_line_info(&tx_size, &tx_count, &rx_size, &rx_count);
           total_tx_size += tx_size;
           total_count += tx_count;
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_word_page(total_tx_size, &info_ptr); *info_ptr++ = ',';
           *info_ptr++ = '0';  *info_ptr++ = ',';
           *info_ptr++ = '0';  *info_ptr++ = ',';
           fax2_store_dec_word_page(total_count, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FBUG_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_debug, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FBUG_QUERY:
           fax2_store_string((ubyte *)FAX2_FBUG_CAPABILITY, &info_ptr);
           break;

       case FAX2_FBUG_COMMAND:
/* start change keh 6/27/95 => fix new parser bugs */
#if 0 /* orig code */
           fax2_debug = *command_parm_ptr;
#endif /* orig code */
           /* +FBUB=(0-1) only */
           if (*command_parm_ptr < 2)
               fax2_debug = *command_parm_ptr;
           else
               return_code = TERMINATE_WITH_ERROR;
/* end change keh 6/27/95 => fix new parser bugs */
           break;

       case FAX2_FCQ_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_hex_byte_page(fax2_qc_rx, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FCQ_QUERY:
           if (fax2_qc_installed_page())
               fax2_store_string((ubyte *)FAX2_FCQ_CQ_CAPABILITY, &info_ptr);
           else
               fax2_store_string((ubyte *)FAX2_FCQ_NOCQ_CAPABILITY, &info_ptr);
           break;

       case FAX2_FCQ_COMMAND:
/* start change keh 6/27/95 => fix new parser bugs */
#if 0 /* orig code */
           /* if quality checking not installed */
           if ((*command_parm_ptr == 1 && !fax2_qc_installed_page()) ||
               *command_parm_ptr == 2)
           {
               return_code = TERMINATE_WITH_ERROR;
               break;
           }
           /* a setting of "1" will check both 1-D and 2-D */
           /* This allows for compatability with class 2.0 */
           fax2_qc_rx = *command_parm_ptr;
#endif /* orig code */

           /* AT+FCQ=(0-2), but we only support "0-1", and "1" only
               if the optional quality checking is installed */
           switch (*command_parm_ptr)
           {
               case 1:
                   /* If optional quality checking is NOT installed */
                   if (!fax2_qc_installed_page())
                   {
                       return_code = TERMINATE_WITH_ERROR;
                       break;
                   }
                   /* Else Intentionally fall through */

               case 0:
                   /* a setting of "1" will check both 1-D and 2-D */
                   /* This allows for compatability with class 2.0 */
                   fax2_qc_rx = *command_parm_ptr;
                   break;

               default:
                   return_code = TERMINATE_WITH_ERROR;
                   break;
           }
/* end change keh 6/27/95 => fix new parser bugs */
           break;

       case FAX2_FCR_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_capability_receive, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FCR_QUERY:
           fax2_store_string((ubyte *)FAX2_FCR_CAPABILITY, &info_ptr);
           break;

       case FAX2_FCR_COMMAND:
/* start change keh 6/23/95 => add 2.0 to new parser */
#if 0 /* orig code */
           fax2_capability_receive = *command_parm_ptr;
#endif /* orig code */
           /* AT+FCR=(0-1) command */
           if (*command_parm_ptr < 2)
               fax2_capability_receive= *command_parm_ptr;
           else
               return_code = TERMINATE_WITH_ERROR; /* command not allowed */
/* end change keh 6/23/95 => add 2.0 to new parser */
           break;

       case FAX2_FCTCRTY_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_ECM_retry_count, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FCTCRTY_QUERY:
           fax2_store_string((ubyte *)FAX2_FCTCRTY_CAPABILITY, &info_ptr);
           break;

       case FAX2_FCTCRTY_COMMAND:
           fax2_ECM_retry_count = *command_parm_ptr;
           break;

       case FAX2_FDCS_REQUEST:
           /* if BR is greater the 5 then V.17 was negtiated */
           /* return the equivalent speed setting */
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_configuration_page(&fax2_negotiated, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FDFFC_COMMAND:
           if (*command_parm_ptr != 0) /* not supported */
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FDFFC_REQUEST:
           /* Intentionally fall through */
       case FAX2_FDFFC_QUERY:
           fax2_store_string((ubyte *)FAX2_FDFFC_CAPABILITY, &info_ptr);
           break;

       case FAX2_FDCC_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_configuration_page(&fax2_capabilities, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FDCC_QUERY:
           if (fax2_ECM_installed_page())
               if (modem_fax_capability() == BR_14400)
                   fax2_store_string((ubyte *)FAX2_FDCC144ECM_CAPABILITY, &info_ptr);
               else
                   fax2_store_string((ubyte *)FAX2_FDCC96ECM_CAPABILITY, &info_ptr);
           else
               if (modem_fax_capability() == BR_14400)
                   fax2_store_string((ubyte *)FAX2_FDCC144_CAPABILITY, &info_ptr);
               else
                   fax2_store_string((ubyte *)FAX2_FDCC96_CAPABILITY, &info_ptr);
           break;

       case FAX2_FDCC_COMMAND:
/* start change keh 12/94 => add new parser */
#if 0 /* keh orig */
           i = *command_parm_ptr;
           /* allow ECM only if ECM is installed */
           if (i > 5 && *(command_parm_ptr+6) == 1 && !fax2_ECM_installed_page())
           {
               return_code = TERMINATE_WITH_ERROR;
               break;
           }
           /* allow BFT only if ECM is installed */
           if (i > 6 && *(command_parm_ptr+7) == 1 && !fax2_ECM_installed_page())
           {
               return_code = TERMINATE_WITH_ERROR;
               break;
           }

           if (i > 0 && *++command_parm_ptr != 0xff)
               fax2_capabilities.VR = *command_parm_ptr;
           if (i > 1 && *++command_parm_ptr != 0xff)
               fax2_capabilities.BR = *command_parm_ptr;
           if (i > 2 && *++command_parm_ptr != 0xff)
               fax2_capabilities.WD = *command_parm_ptr;
           if (i > 3 && *++command_parm_ptr != 0xff)
               fax2_capabilities.LN = *command_parm_ptr;
           if (i > 4 && *++command_parm_ptr != 0xff)
               fax2_capabilities.DF = *command_parm_ptr;
           if (i > 5 && *++command_parm_ptr != 0xff)
               fax2_capabilities.EC = *command_parm_ptr;
           if (i > 6 && *++command_parm_ptr != 0xff)
               fax2_capabilities.BF = *command_parm_ptr;
           if (i > 7)
               fax2_capabilities.ST = *++command_parm_ptr;

           /* initialize the T.30 session parameters with the capability parameters */
           fax2_session = fax2_capabilities;
#endif /* keh orig */

           /*
               Structure of AT command parameter array for compound byte values:
                   [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
               Examples:
                   AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
                   AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
                   AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
                   AT+F=,,,,8  => [0x5,0x8, 0x00]
                   AT+F=       => [0x00]
           */
/* start change keh 6/27/95 => rewrite code with do-while loop */
           /* Eight Sub-Parameters this command:
               FDCC=<vr>,<br>,<wd>,<ln>,<df>,<ec>,<bf>,<st> */
           do
           {
               /* Get AT command values from Parser array */
               field = *command_parm_ptr++;
               value = *command_parm_ptr++;

               /* Check bounds of paramter */
               if (field && (value > fax2_T30_range_array[field-1]))
                   return TERMINATE_WITH_ERROR;

               /* Set valid paramter */
               switch (field)
               {
                   case 0:  /* End of Parsed Parameters */
                       /* Initialize the T.30 session parameters with the
                           capability parameters */
                       fax2_session = fax2_capabilities;
                       break;

                   case 1:  /* Vertical Res */
                       fax2_capabilities.VR = value;
                       break;

                   case 2:  /* Bit Rate */
                       fax2_capabilities.BR = value;
                       break;

                   case 3:  /* Page Width */
                       fax2_capabilities.WD = value;
                       break;

                   case 4:  /* Page Length */
                       fax2_capabilities.LN = value;
                       break;

                   case 5:  /* Compression */
                       fax2_capabilities.DF = value;
                       break;

                   case 6:  /* Error Correction */
                       /* ECM is optionally installed... */
                       if (fax2_ECM_installed_page() || (value == 0))
                           fax2_capabilities.EC = value;
                       else
                           return TERMINATE_WITH_ERROR;
                       break;

                   case 7:  /* Binary file transfer */
                       /* ECM (and BFT) is optionally installed... */
                       if (fax2_ECM_installed_page() || (value == 0))
                           fax2_capabilities.BF = value;
                       else
                           return TERMINATE_WITH_ERROR;
                       break;

                   case 8:  /* Scan Time */
                       fax2_capabilities.ST = value;
                       break;

                   default:  /* field out of bounds */
                       return TERMINATE_WITH_ERROR;
               } /* switch */
           } while (field);
/* end change keh 6/27/95 => rewrite code with do-while loop */
/* end change keh 12/94 => add new parser */
           break;

       case FAX2_FDIS_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_configuration_page(&fax2_session, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FDIS_QUERY:
           if (fax2_ECM_installed_page())
               if (modem_fax_capability() == BR_14400)
                   fax2_store_string((ubyte *)FAX2_FDIS144ECM_CAPABILITY, &info_ptr);
               else
                   fax2_store_string((ubyte *)FAX2_FDIS96ECM_CAPABILITY, &info_ptr);
           else
               if (modem_fax_capability() == BR_14400)
                   fax2_store_string((ubyte *)FAX2_FDIS144_CAPABILITY, &info_ptr);
               else
                   fax2_store_string((ubyte *)FAX2_FDIS96_CAPABILITY, &info_ptr);
           break;

       case FAX2_FDIS_COMMAND:
/* start change keh 12/94 => add new parser */
#if 0 /* keh orig */
            i = *command_parm_ptr;
            /* allow ECM only if ECM is installed */
            if (i > 5 && *(command_parm_ptr+6) == 1 && !fax2_ECM_installed_page())
            {
                return_code = TERMINATE_WITH_ERROR;
                break;
            }
            /* allow BFT only if ECM is installed */
            if (i > 6 && *(command_parm_ptr+7) == 1 && !fax2_ECM_installed_page())
            {
                return_code = TERMINATE_WITH_ERROR;
                break;
            }

            if (i > 0 && *++command_parm_ptr != 0xff)
                fax2_session.VR = *command_parm_ptr;
            if (i > 1 && *++command_parm_ptr != 0xff)
                fax2_session.BR = *command_parm_ptr;
            if (i > 2 && *++command_parm_ptr != 0xff)
                fax2_session.WD = *command_parm_ptr;
            if (i > 3 && *++command_parm_ptr != 0xff)
                fax2_session.LN = *command_parm_ptr;
            if (i > 4 && *++command_parm_ptr != 0xff)
                fax2_session.DF = *command_parm_ptr;
            if (i > 5 && *++command_parm_ptr != 0xff)
                fax2_session.EC = *command_parm_ptr;
            if (i > 6 && *++command_parm_ptr != 0xff)
                fax2_session.BF = *command_parm_ptr;
            if (i > 7)
                fax2_session.ST = *++command_parm_ptr;
#endif /* keh orig */

           /*
               Structure of AT command parameter array for compound byte values:
                   [f,v,f,v,...,0] (f=field, v=value, 0 is end of array).
               Examples:
                   AT+F=5,6,7  => [0x1,0x5, 0x2,0x6, 0x3,0x7, 0x00]
                   AT+F=5,6,,8 => [0x1,0x5, 0x2,0x6, 0x4,0x8, 0x00]
                   AT+F=,6,,8  => [0x2,0x6, 0x4,0x8, 0x00]
                   AT+F=,,,,8  => [0x5,0x8, 0x00]
                   AT+F=       => [0x00]
           */
/* start change keh 6/27/95 => rewrite code with do-while loop */
           /* Eight Sub-Parameters this command:
               FDIS=<vr>,<br>,<wd>,<ln>,<df>,<ec>,<bf>,<st> */
           do
           {
               /* Get AT command values from Parser array */
               field = *command_parm_ptr++;
               value = *command_parm_ptr++;

               /* Check bounds of paramter */
               if (field && (value > fax2_T30_range_array[field-1]))
                   return TERMINATE_WITH_ERROR;

               /* Set valid paramter */
               switch (field)
               {
                   case 0:  /* End of Parsed Parameters */
                       break;

                   case 1:  /* Vertical Res */
                       fax2_session.VR = value;
                       break;

                   case 2:  /* Bit Rate */
                       fax2_session.BR = value;
                       break;

                   case 3:  /* Page Width */
                       fax2_session.WD = value;
                       break;

                   case 4:  /* Page Length */
                       fax2_session.LN = value;
                       break;

                   case 5:  /* Compression */
                       fax2_session.DF = value;
                       break;

                   case 6:  /* Error Correction */
                       /* ECM is optionally installed... */
                       if (fax2_ECM_installed_page() || (value == 0))
                           fax2_session.EC = value;
                       else
                           return TERMINATE_WITH_ERROR;
                       break;

                   case 7:  /* Binar file transfer */
                       /* ECM (and BFT) is optionally installed... */
                       if (fax2_ECM_installed_page() || (value == 0))
                           fax2_session.BF = value;
                       else
                           return TERMINATE_WITH_ERROR;
                       break;

                   case 8:  /* Scan Time */
                       fax2_session.ST = value;
                       break;

                   default:  /* field out of bounds */
                       return TERMINATE_WITH_ERROR;
               } /* switch */
           } while (field);
/* end change keh 6/27/95 => rewrite code with do-while loop */
/* end change keh 12/94 => add new parser */
            break;

       case FAX2_FDR_QUERY:
           break;

       case FAX2_FDR_COMMAND:
           if (fax2_connected) /* command only valid during a connection */
           {
               /* setup for background to execute the command */
               fax2_received_command = FDR_COMMAND; /* indicate command received */
               return_code = GOTO_ONLINE; /* continue with protocol */
               /* configure for APP to modem flow control */
               fax2_configure_dte = APP_TO_MODEM_FLOW;
           }
           else
               return_code = TERMINATE_WITH_ERROR; /* command not allowed */
           break;

       case FAX2_FDT_QUERY:
           break;

       case FAX2_FDT_COMMAND:
           if (fax2_connected) /* command only valid during a connection */
           {
               /* setup for background to execute the command */
               fax2_received_command = FDT_COMMAND; /* indicate command received */
               return_code = GOTO_ONLINE; /* continue with protocol */
               /* configure for modem to APP flow control */
               fax2_configure_dte = MODEM_TO_APP_FLOW;
           }
           else
               return_code = TERMINATE_WITH_ERROR; /* command not allowed */
           break;

       case FAX2_FECM_COMMAND: /* not supported */
           if (*command_parm_ptr != 0)
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FECM_REQUEST:
           /* Intentionally fall through */
       case FAX2_FECM_QUERY:
           fax2_store_string((ubyte *)FAX2_FECM_CAPABILITY, &info_ptr);
           break;

       case FAX2_FET_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_pp_command, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FET_QUERY:
           fax2_store_string((ubyte *)FAX2_FET_CAPABILITY, &info_ptr);
           break;

       case FAX2_FET_COMMAND:
           /* command only valid during a connection */
           if (*command_parm_ptr <= EOP_PPC && fax2_connected &&
               fax2_state == PHASE_C_TRANSMIT)
           {
               /* setup for background to execute the command */
               fax2_pp_command = *command_parm_ptr;
               fax2_received_command = FET_COMMAND;
               return_code = GOTO_ONLINE; /* continue with protocol */
               /* configure for modem to APP flow control */
               fax2_configure_dte = MODEM_TO_APP_FLOW;
           }
           else
               return_code = TERMINATE_WITH_ERROR; /* command not allowed */
           break;

       case FAX2_FK_QUERY:
           break;

       case FAX2_FK_COMMAND:
           if (fax2_connected) /* command only valid during a connection */
           {
               if (fax2_line_configured) /* if line configured */
                   fax2_cleanup(); /* terminate all configurations */
               fax2_state = PHASE_E; /* setup to disconnect */
               fax2_sub_state = SCHEDULE_DCN_PACKET;
               fax2_utility_state = INITIALIZE;
               fax2_hangup_status = FKS_ABORTED_CONNECTION;
               return_code = GOTO_ONLINE; /* continue with protocol */
               /* configure for modem to no flow control */
               fax2_configure_dte = NO_FLOW;
           }
           break;

       case FAX2_FLID_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_string((ubyte *)fax2_local_id_string, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FLID_QUERY:
           fax2_store_string((ubyte *)FAX2_FLID_CAPABILITY, &info_ptr);
           break;

       case FAX2_FLID_COMMAND:
/* start change keh 12/94 => add new parser */
#if 0 /* keh orig */
            count = *command_parm_ptr++;
            for (i = 0 ; i < count ; i++) /* copy the local id string */
                fax2_local_id_string[i] = *command_parm_ptr++;
            fax2_local_id_string[i] = '\0';
#endif
           /* The parser passes in a formatted string. We only have
               to qualify the string size */
/* start change keh 6/27/95 => rewrite for cleaner code */
           field = 0;  /* prepare for the null string (+FLI="") condition */

           /* Test for non-null string */
           if (*command_parm_ptr++ == '"')
           {
               /* Only 20 chars are allowed in the string */
               while (field < 20 && *command_parm_ptr != '"')
                   fax2_local_id_string[field++] = *command_parm_ptr++;

               /* Test for more than 20 chars on command line (the
                   parameter string will not end with a \" char) */
               if (*command_parm_ptr != '"')
               {
                   /* Set null string and error condition */
                   field = 0;
                   return_code = TERMINATE_WITH_ERROR;
               }
           }
           fax2_local_id_string[field] = '\0'; /* EndOfString */
/* end change keh 6/27/95 => rewrite for cleaner code */
/* end change keh 12/94 => add new parser */
           break;

       case FAX2_FLNFC_COMMAND:
           if (*command_parm_ptr != 0) /* not supported */
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FLNFC_REQUEST:
           /* Intentionally fall through */
       case FAX2_FLNFC_QUERY:
           fax2_store_string((ubyte *)FAX2_FLNFC_CAPABILITY, &info_ptr);
           break;

       case FAX2_FLPL_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_capability_transmit_poll, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FLPL_QUERY:
           fax2_store_string((ubyte *)FAX2_FLPL_CAPABILITY, &info_ptr);
           break;

       case FAX2_FLPL_COMMAND:
/* start change keh 12/94 => add new parser */
#if 0
           fax2_capability_transmit_poll = *command_parm_ptr;
#endif
/* start change keh 6/27/95 => rewrite old changes for cleaner code */
           /* AT+FLPL=(0-1) */
           if (*command_parm_ptr < 2)
               fax2_capability_transmit_poll = *command_parm_ptr;
           else
               return_code = TERMINATE_WITH_ERROR;
/* end change keh 6/27/95 => rewrite old changes for cleaner code */
/* end change keh 12/94 => add new parser */
           break;

       case FAX2_FMDL_REQUEST:
           fax2_store_string((ubyte *)FAX2_FMDL_IDENTIFICATION, &info_ptr);
           break;

       case FAX2_FMFR_REQUEST:
           fax2_store_string((ubyte *)FAX2_FMFR_IDENTIFICATION, &info_ptr);
           break;

       case FAX2_FMINSP_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_minimum_speed, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FMINSP_QUERY:
           if (modem_fax_capability() == BR_14400)
               fax2_store_string((ubyte *)FAX2_FMINSP144_CAPABILITY, &info_ptr);
           else
               fax2_store_string((ubyte *)FAX2_FMINSP96_CAPABILITY, &info_ptr);
           break;

       case FAX2_FMINSP_COMMAND:
/* start change keh 6/27/95 => fix new parser bugs */
#if 0 /* orig code */
           fax2_minimum_speed = *command_parm_ptr;
#endif /* orig code */
           /* AT+FMINSP=(0-MAX_BR) */
           if (*command_parm_ptr > modem_fax_capability())
               return_code = TERMINATE_WITH_ERROR;
           else
               fax2_minimum_speed = *command_parm_ptr;
/* end change keh 6/27/95 => fix new parser bugs */
           break;

       case FAX2_FPHCTO_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_timeout, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FPHCTO_QUERY:
           fax2_store_string((ubyte *)FAX2_FPHCTO_CAPABILITY, &info_ptr);
           break;

       case FAX2_FPHCTO_COMMAND:
           /* AT+FPHCTO=(0-255) */
           fax2_timeout = *command_parm_ptr;
           break;

       case FAX2_FPTS_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_pp_response, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FPTS_QUERY:
           fax2_store_string((ubyte *)FAX2_FPTS_CAPABILITY, &info_ptr);
           break;

       case FAX2_FPTS_COMMAND:
           /* Do not allow RTP/RTN if in ECM per T.30 Annex A */
           if (*command_parm_ptr == MCF_PPR || (!fax2_negotiated.EC &&
               (*command_parm_ptr == RTN_PPR || *command_parm_ptr == RTP_PPR)))
               fax2_pp_response = *command_parm_ptr;
           else
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FREV_REQUEST:
           fax2_store_string((ubyte *)FAX2_FREV_IDENTIFICATION, &info_ptr);
           break;

       case FAX2_FRBC_COMMAND:
/* start change keh 12/94 => add new parser */
/*            if (*command_parm_ptr != 0) */ /* not supported */
           if (*(uword *)command_parm_ptr != 0) /* not supported */
/* end change keh 12/94 => add new parser */
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FRBC_REQUEST:
           /* Intentionally fall through */
       case FAX2_FRBC_QUERY:
           fax2_store_string((ubyte *)FAX2_FRBC_CAPABILITY, &info_ptr);
           break;

       case FAX2_FREL_COMMAND:
           if (*command_parm_ptr != 0) /* not supported */
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FREL_REQUEST:
           /* Intentionally fall through */
       case FAX2_FREL_QUERY:
           fax2_store_string((ubyte *)FAX2_FREL_CAPABILITY, &info_ptr);
           break;

       case FAX2_FSPL_REQUEST:
           *info_ptr++ = CR; *info_ptr++ = LF;
           fax2_store_dec_byte_page(fax2_capability_receive_poll, &info_ptr);
           *info_ptr++ = CR; *info_ptr++ = LF;
           break;

       case FAX2_FSPL_QUERY:
           fax2_store_string((ubyte *)FAX2_FSPL_CAPABILITY, &info_ptr);
           break;

       case FAX2_FSPL_COMMAND:
/* start change keh 12/94 => add new parser */
#if 0
            fax2_capability_receive_poll = *command_parm_ptr;
#endif
/* start change keh 6/27/95 => rewrite old changes for cleaner code */
           /* AT+FSPL=(0-1) */
           if (*command_parm_ptr < 2)
               fax2_capability_receive_poll = *command_parm_ptr;
           else
               return_code = TERMINATE_WITH_ERROR;
/* end change keh 6/27/95 => rewrite old changes for cleaner code */
/* end change keh 12/94 => add new parser */
           break;

       case FAX2_FTBC_COMMAND:
/* start change keh 12/94 => add new parser */
/*            if (*command_parm_ptr != 0) */ /* not supported */
           if (*(uword *)command_parm_ptr != 0) /* not supported */
/* end change keh 12/94 => add new parser */
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FTBC_REQUEST:
           /* Intentionally fall through */
       case FAX2_FTBC_QUERY:
           fax2_store_string((ubyte *)FAX2_FTBC_CAPABILITY, &info_ptr);
           break;

       case FAX2_FVRFC_COMMAND:
           if (*command_parm_ptr != 0) /* not supported */
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FVRFC_REQUEST:
           /* Intentionally fall through */
       case FAX2_FVRFC_QUERY:
           fax2_store_string((ubyte *)FAX2_FVRFC_CAPABILITY, &info_ptr);
           break;

       case FAX2_FWDFC_COMMAND:
           if (*command_parm_ptr != 0) /* not supported */
               return_code = TERMINATE_WITH_ERROR;
           break;

       case FAX2_FWDFC_REQUEST:
           /* Intentionally fall through */
       case FAX2_FWDFC_QUERY:
           fax2_store_string((ubyte *)FAX2_FWDFC_CAPABILITY, &info_ptr);
           break;

       default:
           return_code = TERMINATE_WITH_ERROR;
           break;
   }

   /* terminate the response string */
   *info_ptr = '\0';

   return(return_code);
}

/******************************************************************************
/
/   Routine: fax2_store_string
/
/   Author: RSA
/
/   Creation Date: 09/21/92
/
/   Description: This routine copys a string.
/
/   Input Parameters: ubyte *   pointer to string (NULL terminated)
/                     ubyte **  string_ptr_ptr
/
/   Output Parameters: none
/
/   Global Variables Changed: none
/
/   Users: fax2_execute_command()
/
/   -------------------------------------------------------------
/   -                       Modifications                       -
/   -------------------------------------------------------------
/
/   Author & Date: RSA
/   Descritpion:
/   Reason:
/
*******************************************************************************/
void fax2_store_string(ubyte *string_ptr, ubyte **string_ptr_ptr)
{
   while (*string_ptr) /* copy all characters until a NULL is reached */
       *(*string_ptr_ptr)++ = *string_ptr++;
   *(*string_ptr_ptr)++ = '\0';
}


