/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00cman.c
/
/	Module Version: ACU 4.02
/
/	Function:	This file contains the code for the AT commands beginning
/			with '&'.
/
/	Product:	ACU core code
/
/	History:	ac00cman.c v3.90
/			ac00cman.c v3.91
/			ac00cman.c v3.92
/			ac00cman.c v3.94
/			ac00cman.c v3.96
/
/		Created: 10/7/91
/			10/17/91
/			12/04/91
/			3/10/92
/			1/12/93
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date: RSA/keh 7/1/94
/		Description: Add new parse routine for ETC specified commands:
/                   void and_I(void);
/		      Also, modify and_F() for ETC.
/		Reason: Add ETC support to core ACU
/
/		Author & Date:	RSA
/		Description:
/		Reason:
/
*****************************************************************************/
#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "ee_def.h"
#include "acu_pro.h"
#include "mt_pro.h"
#include "v25_pro.h"
#include "ll_pro.h"
#include "ptt.h"
/* TIA Start change 03/17/94 */
#include "acu_vce.h"
/* TIA End change 03/17/94 */
/* start change keh 7/1/94 => Add ETC interface */
#include "acu_epro.h"       /* ACU ETC Driver interface prototypes */
/* end change keh 7/1/94 => Add ETC interface */

/* start change keh 12/94 => modify routines for new parser */
#if 0 /* original */
*void at_and(void);
*void and_C(void);
*void and_B(void);
*void and_D(void);
*void and_F(ubyte);
*void and_G(void);
*/* start change keh 7/1/94 => Add ETC AT&I parser */
*void and_I(void);
*/* end change keh 7/1/94 => Add ETC AT&I parser */
*void and_J(void);
*void and_K(void);
*void and_M(void);
*void and_P(void);
*void and_Q(void);
*void and_R(void);
*void and_S(void);
*void and_U(void);
#endif

void and_C(ubyte *);
void and_B(ubyte *);
void and_D(ubyte *);
void and_F(ubyte *);
void and_G(ubyte *);
void and_J(ubyte *);
void and_K(ubyte *);
void and_M(ubyte *);
void and_P(ubyte *);
void and_Q(ubyte *);
void and_R(ubyte *);
void and_S(ubyte *);
void and_U(ubyte *);
/*SLei added*/
extern country_Make_Break_Time PTT_MakeBreak_Time[7];
extern ubyte CountryInfo;
/* end change keh 12/94 => modify routines for new parser */
extern   ubyte voice_caller_id;

/* start change keh 12/94 => modify routines for new parser */
#if 0
*/*******************************************************************************
*/
*/	Routine: at_and
*/
*/	Author : RSA
*/
*/	Creation Date: 06/17/91
*/
*/	Description : This Routine will call the Routine needed to perform a
*/		          command beginning with an '&'.
*/
*/	Input Parameters: None
*/
*/	Output Parameters: none
*/
*/	Global Variables Changed:  None
*/
*/	Users: execute_cmd
*/
*/	-------------------------------------------------------------
*/	-			Modifications			    -
*/	-------------------------------------------------------------
*/
*/	Author & Date: RSA/keh 7/1/94
*/	Description: Add interface for new parse routine "and_I()".
*/	Reason: Add ETC support to core ACU
*/
*/	Author & Date:	RSA
*/	Description:
*/	Reason:
*/
********************************************************************************/
*void at_and(void)
*{
*	switch (get_next_char())
*	{
*		case 'C': and_C();
*			  break;
*
*		case 'B': and_B();
*			  break;
*
*		case 'D': and_D();
*			  break;
*
*		case 'F': and_F(COMMAND);
*			  break;
*
*		case 'G': and_G();
*			  break;
*
*/* start change keh 7/1/94 => Add ETC AT&I parser */
*		case 'I': and_I();
*			  break;
*/* end change keh 7/1/94 => Add ETC AT&I parser */
*
*		case 'J': and_J();
*			  break;
*
*		case 'K': and_K();
*			  break;
*
*       /* The following command controls Leased line operation.  It is
*           located in the Leased line code. */
*		case 'L': and_L();
*			  break;
*
*		case 'M': and_M();
*			  break;
*
*		case 'P': and_P();
*			  break;
*
*		case 'Q': and_Q();
*			  break;
*
*		case 'R': and_R();
*			  break;
*
*		case 'S': and_S();
*			  break;
*
*		case 'T': and_T();
*			  break;
*
*		case 'U': and_U();
*			  break;
*
*		case 'V': and_V();
*			  break;
*
*		case 'W': and_W();
*			  break;
*
*		case 'X': and_X();
*			  break;
*
*		case 'Y': and_Y();
*			  break;
*
*		case 'Z': and_Z();
*			  break;
*
*		default: error_occurred = TRUE;
*	}
*}
#endif
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_C
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the data carrier detect option
/	       AT&C	0 - RLSD circuit is always on
/			1 - RLSD circuit reflects the state of the carrier
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr21.RLSD_reflects_CD,
/				   RLSD_reflects_CD_temp
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_C(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*	switch (num)
*	{
*		case 0: if (on_line_command == FALSE)
*			{
*				sr21.RLSD_reflects_CD = FALSE;
*				RLSD_reflects_CD_temp = FALSE;
*			}
*			else
*				RLSD_reflects_CD_temp = FALSE;
*			break;
*
*		case 1: if (on_line_command == FALSE)
*			{
*				sr21.RLSD_reflects_CD = TRUE;
*				RLSD_reflects_CD_temp = TRUE;
*			}
*			else
*				RLSD_reflects_CD_temp = TRUE;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif
void and_C(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
        case 0:
            if (on_line_command == FALSE)
            {
                sr21.RLSD_reflects_CD = FALSE;
                RLSD_reflects_CD_temp = FALSE;
            }
            else
                RLSD_reflects_CD_temp = FALSE;
            break;

        case 1:
            if (on_line_command == FALSE)
            {
                sr21.RLSD_reflects_CD = TRUE;
                RLSD_reflects_CD_temp = TRUE;
            }
            else
                RLSD_reflects_CD_temp = TRUE;
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_B
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the V.32 carrier detection method
/	       AT&B	0 - Hang up if bad EQM
/			1 - Retrain if failure in S7 then hang up
/			2 - Do not hangup, do not retrain
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, v32_retrain
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_B(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*
*        /* If this software is for a V.22bis modem this command is not allowed	*/
*	if (acu_cfg.mode == CFG_V22BIS)
*	{
*		error_occurred = TRUE;
*		return;
*	}
*
*	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 2)))
*		v32_retrain = num;
*	else
*		error_occurred = TRUE;
*}
#endif
void and_B(ubyte *param_ptr)
{
    /* If this software is for a V.22bis modem this command is not allowed	*/
    if (acu_cfg.mode == CFG_V22BIS)
    {
        error_occurred = TRUE;
        return;
    }

/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 2)) */
    if (*param_ptr <= 2)
/* end change keh 8/15/95 => ubytes are never  < 0 */
        v32_retrain = *param_ptr;
    else
        error_occurred = TRUE;
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_D
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine determines how the modem is to respond to DTR.
/		     depends upon selected &Q
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr21.DTR_control
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_D(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*
*/* JAY - TIA Conversion Start 1/20/1994 */
*        if ((voice_cmd_set == TIA_IS_101) && (num == 1))
*            error_occurred = TRUE;
*/* JAY - TIA Conversion End 1/20/1994 */
*
*	if ((error_occurred == FALSE) && ((num >= 0) && (num <=3)))
*		sr21.DTR_control = num;
*	else
*		error_occurred = TRUE;
*}
#endif

void and_D(ubyte *param_ptr)
{
    switch(*param_ptr)
    {
        case 0:
            break;

        case 1:
/* JAY - TIA Conversion Start 1/20/1994 */
            if (voice_cmd_set == TIA_IS_101)
            {
                error_occurred = TRUE;
                return;
            }
/* JAY - TIA Conversion End 1/20/1994 */
            break;

        case 2:
            break;

        case 3:
            break;

        default:
            error_occurred = TRUE;
            return;
    }

    sr21.DTR_control = *param_ptr;
}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/       Routine: and_F
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine is called to load the factory defaults.
/		          AT&F0 = load standard factory defaults.
/		          AT&F5 = load standard and ETC Mobile factory defaults.
/		          AT&F6 = load standard and ETC PSTN factory defaults.
/
/       Input Parameters: ubyte type - Tells if it is being called during
/				       powerup or command mode.
/
/       Output Parameters: none
/
/       Global Variables Changed:  variables with factory defaults
/
/       Users:	at_and(), acu_reset()
/
/	      -------------------------------------------------------------
/	      -                   Modifications                           -
/	      -------------------------------------------------------------
/
/       Author & Date: RSA/keh 7/1/94
/	      Description: Add ETC AT&Fn interface
/		  Reason: Add ETC support to core ACU
/
/	      Author & Date: RSA
/	      Description:
/	      Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_F(ubyte type)
*{
*    ubyte *string,i;
*    ubyte temp_parity,temp_data,temp_stop,temp_baud,temp_char;
*    ubyte temp_sr23_parity;
*
*    if (on_line_command == TRUE && type != AT_Z_COMMAND)
*    {
*        error_occurred = TRUE;
*        return;
*    }
*
*    /* Need to save these variables in case this has not been called on
*       power up */
*    temp_data = acu_data_bits;
*    temp_stop = acu_stop_bits;
*    temp_baud = dte_baud;
*    temp_parity = acu_parity;
*    temp_sr23_parity = (ubyte)sr23.acu_parity;
*
*    temp_char = char_size;
*
*    string = (ubyte *)&factory_defaults[0];
*
*    for (i = 0; i <= DEFAULT_SIZE-2; i++)
*        *variable_addr[i] = *string++;
*
*    /* Reset power up profile to 0 */
*    temp_array[0] = *string++;
*    modem_write_data(POWER_UP_PROFILE,1,(ubyte *)&temp_array[0]);
*
*    temp_array[0] = modem_eeprom_checksum();
*    modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,(ubyte *)&temp_array[0]);
*
*    /* If this is being called during powerup then reset baud rate, data bits,
*	   parity, and stop bits to their defaults */
*    if (type != POWERUP)
*    {
*        /* Set baud rate parameters */
*        acu_data_bits = temp_data;
*        acu_stop_bits = temp_stop;
*        dte_baud = temp_baud;
*        acu_parity = temp_parity;
*        char_size = temp_char;
*        sr23.acu_parity = temp_sr23_parity;
*    }
*
*    if ((dte_baud >= BPS2400 && dte_baud <= BPS57600) ||
*        dte_baud == BPS115200)
*        modem_hs_led(dte_baud);
*
*    modem_speaker_vol((ubyte)sr22.speaker_vol);
*    modem_rdl_enable((ubyte)sr23.grant_rdl);
*
*    dial_pause_time = s[8];
*
*    v25_set_defaults();
*    ll_set_defaults();
*
*    modem_aa_led(OFF);
*    RLSD_reflects_CD_temp = (ubyte)sr21.RLSD_reflects_CD;
*
*    initialize_fax(FAX_INIT_AND_F);
*
*/* start change keh 7/1/94 => Add ETC AT&F parser */
*    /* Execute ETC powerup and AT&F command parsing */
*    if (acu_ETC_installed())
*    {
*/* start change keh 7/6/94 => Reset ETC Driver after power up */
*        if (type == POWERUP)
*        {
*            /* Configure ETC Driver from ACU factory defaults list */
*            acu_ETC_reset();
*        }
*/* end change keh 7/6/94 => Reset ETC Driver after power up */
*        /* Else parse ETC AT&F command */
*        else
*        {
*            /* Get AT command parameter */
*            temp_char = a_to_d();
*
*            /* If no parameter error, parse the AT&F parameter */
*            if (error_occurred == FALSE)
*            {
*                switch (temp_char)
*                {
*                    case 0:
*                    case 5:
*                    case 6:
*                        /* Update acu variable for AT&V strings */
*                        andF = temp_char;
*
*                        /* Send command to ETC Driver */
*                        acu_ETC_and_F(temp_char);
*                        break;
*
*                    default:
*                        error_occurred = TRUE;
*                        break;
*                }  /* Switch */
*            } /* If no parameter error */
*        }  /* Else !powerup */
*    } /* If ETC installed */
*/* end change keh 7/1/94 => Add ETC AT&F parser */
*}
#endif

void and_F(ubyte *param_ptr)
{
    /* Can't all change parameters during a call */
    if (on_line_command)
    {
        error_occurred = TRUE;
        return;
    }

	voice_caller_id = 0;		/* ramn 1/2/97 */

    switch (*param_ptr)
    {
        case 0:
            break;

        case 5:
        case 6:
            /* ETC AT&F5,6 command */
            if (acu_ETC_installed())
                break;

            /* Intentionally fall through if not ETC */

        default:
            error_occurred = TRUE;
            return;
    }

    /* AT command variable */
    andF = *param_ptr;

    /* Load factory defaults */
    acu_load_defaults(COMMAND);

	voice_caller_id = 0;		/* ramn 1/2/97 */


/* start change keh 12/94 => add new parser */
    if (acu_ETC_installed())
        acu_ETC_and_F(*param_ptr);
/* end change keh 12/94 => add new parser  */
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_G
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This routine selects the the guard tone that the modem is to send
/	       AT&G	0 - Guard tone disabled
/			1 - 550 Hz guard tone enabled
/			3 - 1800 Hz guard tone enabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr23.guard_tone
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* star change keh 12/94 => modify routines for new parser */
#if 0
*void and_G(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*	switch (num)
*	{
*		case 0: sr23.guard_tone = GUARD_DISABLE;
*			break;
*
*		case 1: sr23.guard_tone = GUARD_550;
*			break;
*
*		case 2: sr23.guard_tone = GUARD_1800;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif

void and_G(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
        case 0:
            sr23.guard_tone = GUARD_DISABLE;
            break;

        case 1:
            sr23.guard_tone = GUARD_550;
            break;

        case 2:
            sr23.guard_tone = GUARD_1800;
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */

/* start change keh 2/25/95 => add new parser (move to etc files) */
#if 0
*
*/* start change keh 7/1/94 => Add ETC AT&I parser */
/*******************************************************************************
/
/       Routine: and_I
/
/       Author : RSA
/
/       Creation Date: 07/01/94
/
/       Description:    This Routine will parse the ETC specified AT&I command.
/
/                       The purpose of this command is to set the modem's
/                       transmit level.
/
/                       The command has the form: AT&In
/                        10 -25 = Transmit level in dBm
/                        99     = Enable ETC Cellular Transmit Level Adjust
/                                   Algorithm
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed:  error_occurred
/
/       Users: at_and()
/
/       -------------------------------------------------------------
/       -                   Modifications	                          -
/       -------------------------------------------------------------
/
/       Author & Date:	RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void and_I(void)
{
    ubyte num;

    /* If ETC is installed in the modem, parse the ETC &I command */
    if (acu_ETC_installed())
    {
        /* Get the command parameter */
        num = a_to_d();

        /* Send parmaeter to ETC driver if it's in bounds */
        if ((error_occurred == FALSE) && (((num >= 10) && (num <= 25)) || (num == 99)) )
        {
            /* Update ACU AT&V variable */
            andI = num;

            acu_ETC_and_I(num);
        }
        else
            error_occurred=TRUE;
    }
    else
    {
        error_occurred = TRUE;
    }
}
/* end change keh 7/1/94 => Add ETC AT&I parser */
#endif
/* start change keh 2/25/95 => add new parser */

/*******************************************************************************
/
/	Routine: and_J
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the auxiliary relay control
/	       AT&J	0 - Relay is never operated
/			1 - The A lead is connected to the A1 lead while modem
/			    is off hook.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr21.auxiliary_relay_ctrl
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_J(void)
*{
*	ubyte num;
*	num = a_to_d();
*
*	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
*		sr21.auxiliary_relay_ctrl = num;
*	else
*		error_occurred = TRUE;
*}
#endif

void and_J(ubyte *param_ptr)
{
/* start change keh 4/14/95 => IAR compiler gags on "struct.mem = *ubyte;" */
/*
    if ((*param_ptr == 0) || (*param_ptr == 1))
        sr21.auxiliary_relay_ctrl = *param_ptr;
*/
   if (*param_ptr == 0)
       sr21.auxiliary_relay_ctrl = 0;
   else if (*param_ptr == 1)
       sr21.auxiliary_relay_ctrl = 1;
/* end change keh 4/14/95 => IAR compiler gags on "struct.mem = *ubyte;" */
    else
        error_occurred = TRUE;
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_K
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the flow control implementation.
/	       AT&K	0 - No flow control
/			3 - Hardware FC (default)
/			4 - software FC
/			5 - transparent software FC
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slQ, reconfigure
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_K(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*
*	switch (num)
*	{
*		case 0:
*			andK = 0;
*			slQ = 0;
*			break;
*
*		case 3:
*			andK = 3;
*			slQ = 3;
*			break;
*
*		case 4:
*			andK = 4;
*			slQ = 1;
*			break;
*
*		case 5:
*
*                        /* Force ERROR if transparent flow control is selected.
*                           Most of the I/O code	does not support transparent
*                           flow control. */
*/*			slQ = 9;*/
*/*			break;*/
*
*		default:
*			error_occurred = TRUE;
*			return;
*	}
*
*     	if (num == 2 || num == 3)
*
*     		alt_fax_flow_control = CTS_RTS;
*     	else
*     		alt_fax_flow_control = XON_XOFF;
*
*	reconfigure = TRUE;
*}
#endif

void and_K(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
        /* DISABLE Flow control */
        case 0:
            andK = 0;
            slQ = 0;
            break;

        /* Enable Hardware flow control (RTS/CTS) */
        case 3:
            andK = 3;
            slQ = 3;
            break;

        /* Enable Software flow control (XON/XOFF) */
        case 4:
            andK = 4;
            slQ = 1;
            break;

        /* Transparent flow control */
        case 5:
            /* Force ERROR if transparent flow control is selected.
                Most of the I/O code	does not support transparent
                flow control. */
            /*			slQ = 9;*/
            /*			break;*/

        default:
            error_occurred = TRUE;
            return;
    }

    if (*param_ptr == 2 || *param_ptr == 3)
        alt_fax_flow_control = CTS_RTS;
    else
        alt_fax_flow_control = XON_XOFF;

    reconfigure = TRUE;
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_M
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the communication mode
/	       AT&M	0 - Normal in idle state, Asynchronous in on-line
/			1 - Normal in idle state, Synchronous in on-line
/			2 - Dial with DTR=1, Hang up when DTR=0 in idle state
/			    Synchronous in on-line
/			3 - Talk/data, DTR = 0/1, Synchronous in on-line
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr27.comm_mode
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_M(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*
*	if ((on_line_command == TRUE) || (error_occurred == TRUE) ||
*            (num > 3))
*	{
*		error_occurred = TRUE;
*		return;
*	}
*
*        sr27.autosync = 0;
*
*
*	switch (num)
*	{
*		case 0: sr27.comm_mode = ASYNC;
*			break;
*
*		case 1: sr27.comm_mode = SYNC_NORMAL;
*			break;
*
*		case 2: sr27.comm_mode = SYNC_DTR;
*			break;
*
*		case 3: sr27.comm_mode = SYNC_TALK;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif

void and_M(ubyte *param_ptr)
{
/* ciy 5/2/96 10:23AM, take out, to compatable with TIES
 *
 *   if (on_line_command == TRUE)
 *   {
 *       error_occurred = TRUE;
 *       return;
 *  }
 * --------------------------------------------------*/

    switch (*param_ptr)
    {
        case 0:
            sr27.comm_mode = ASYNC;
            break;

/* 4/03/96 shujin, we only suport async mode */
#if 0
        case 1:
            sr27.comm_mode = SYNC_NORMAL;
            break;

        case 2:
            sr27.comm_mode = SYNC_DTR;
            break;

        case 3:
            sr27.comm_mode = SYNC_TALK;
            break;
#endif

        default:
            error_occurred = TRUE;
            return;
    }

    sr27.autosync = 0;
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_P
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the dial pulse ratio
/	       AT&C	0 - Make = 39%, Break = 61%
/			1 - Make = 33%, Break = 67%
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, make_time, break_time
/				   sr22.uk_hook
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_P(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*	switch(num)
*	{
*		case 0: make_time = US_MAKE_TIME;
*			break_time = US_BREAK_TIME;
*			sr22.uk_hook = num;
*			break;
*
*		case 1: make_time = UK_MAKE_TIME;
*			break_time = UK_BREAK_TIME;
*			sr22.uk_hook = num;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif

void and_P(ubyte *param_ptr)
{
    switch(*param_ptr)
    {
        case 0:
/*SLei added*/
            make_time  = PTT_MakeBreak_Time[CountryInfo].P0_make_time;
            break_time = PTT_MakeBreak_Time[CountryInfo].P0_break_time;
#if 0
            make_time = US_MAKE_TIME;
            break_time = US_BREAK_TIME;
#endif
/* start change keh 4/14/95 => IAR compiler gags on struct.mem = *ubyte; */
/*            sr22.uk_hook = *param_ptr; */
            sr22.uk_hook = 0;
/* start change keh 4/14/95 => IAR compiler gags on struct.mem = *ubyte; */
            break;

        case 1:
/*SLei added*/
            make_time  = PTT_MakeBreak_Time[CountryInfo].P1_make_time;
            break_time = PTT_MakeBreak_Time[CountryInfo].P1_break_time;
#if 0
            make_time = UK_MAKE_TIME;
            break_time = UK_BREAK_TIME;
#endif
/* start change keh 4/14/95 => IAR compiler gags on struct.mem = *ubyte; */
/*            sr22.uk_hook = *param_ptr; */
            sr22.uk_hook = 1;
/* start change keh 4/14/95 => IAR compiler gags on struct.mem = *ubyte; */
            break;
/*SLei added*/
		  case 2:
			   if (CountryInfo == Japan) {
	            make_time  = PTT_MakeBreak_Time[CountryInfo].P0_make_time;
					make_time /= 2;
   	         break_time = PTT_MakeBreak_Time[CountryInfo].P0_break_time;
					break_time /= 2;
					}
				else {
   	         error_occurred = TRUE;
					return ;
					}
				break;
		  case 3:
			   if (CountryInfo == Japan) {
	            make_time  = PTT_MakeBreak_Time[CountryInfo].P1_make_time;
					make_time /= 2;
   	         break_time = PTT_MakeBreak_Time[CountryInfo].P1_break_time;
					break_time /= 2;
					}
				else {
   	         error_occurred = TRUE;
					return ;
					}
				break;
        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/	Routine: and_Q
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the communication mode
/	       AT&Q	0 - Normal in idle state, Asynchronous in on-line
/			1 - Normal in idle state, Synchronous in on-line
/			2 - Dial with DTR=1, Hang up when DTR=0 in idle state
/			    Synchronous in on-line
/			3 - Talk/data, DTR = 0/1, Synchronous in on-line
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr27.comm_mode
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_Q(void)
*{
*	ubyte num;
*
*        num = a_to_d();
*
*	if ((on_line_command == TRUE) || (error_occurred == TRUE) ||
*             (num > 4))
*	{
*		error_occurred = TRUE;
*		return;
*	}
*
*        sr27.comm_mode = sr27.autosync = 0;
*
*	switch (num)
*	{
*		case 0: sr27.comm_mode = ASYNC;
*			break;
*
*		case 1: sr27.comm_mode = SYNC_NORMAL;
*			break;
*
*		case 2: sr27.comm_mode = SYNC_DTR;
*			break;
*
*		case 3: sr27.comm_mode = SYNC_TALK;
*			break;
*
*                case 4: sr27.autosync = 1;
*                        break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif
void and_Q(ubyte *param_ptr)
{
/* ciy 5/2/96 10:23AM, take out, to compatable with TIES
 *
 *   if (on_line_command == TRUE)
 *   {
 *       error_occurred = TRUE;
 *       return;
 *  }
 * --------------------------------------------------*/

    /* Reset current &Q setting */
    sr27.comm_mode = sr27.autosync = 0;

    switch (*param_ptr)
    {
        case 0:
            sr27.comm_mode = ASYNC;
            break;

/* 4/03/96 shujin, we only suport async mode */
#if 0
        case 1:
            sr27.comm_mode = SYNC_NORMAL;
            break;

        case 2:
            sr27.comm_mode = SYNC_DTR;
            break;

        case 3:
            sr27.comm_mode = SYNC_TALK;
            break;

        case 4:
            sr27.autosync = 1;
            break;
#endif

        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/	Routine: and_R
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects relationship of CTS to RTS
/	       AT&R	0 - CTS tracks RTS while on-line and &Q1-&Q3
/			1 - RTS is ignored. CTS on while modem is on-line
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr21.CTS_on
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_R(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*	switch (num)
*	{
*		case 0: sr21.CTS_on = FALSE;
*			break;
*
*		case 1: sr21.CTS_on = TRUE;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif

void and_R(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
        case 0:
            sr21.CTS_on = FALSE;
            break;

        case 1:
            sr21.CTS_on = TRUE;
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_S
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description: This routine selects the use of DSR
/	       AT&S	0 - DSR always on
/			1 - DSR on at start of handshake and off in test and
/			    idle state. DSR off when carrier is lost
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr21.DSR_only_at_handshaking
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_S(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*	switch (num)
*	{
*		case 0: sr21.DSR_only_at_handshaking = FALSE;
*			break;
*
*		case 1: sr21.DSR_only_at_handshaking = TRUE;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif
void and_S(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
        case 0:
            sr21.DSR_only_at_handshaking = FALSE;
            break;

        case 1:
            sr21.DSR_only_at_handshaking = TRUE;
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_U
/
/	Author : RSA
/
/	Creation Date: 10/17/91
/
/	Description: This routine will enable/disable V.32 trellis coding
/	       AT&U	1 - Disable
/			0 - Enable
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, andU
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_U(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*
*	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
*		trellis = num;
*	else
*		error_occurred = TRUE;
*}
*
#endif

void and_U(ubyte *param_ptr)
{
	if ((*param_ptr == 0) || (*param_ptr == 1))
		trellis = *param_ptr;
	else
		error_occurred = TRUE;
}
/* end change keh 12/94 => modify routines for new parser */
