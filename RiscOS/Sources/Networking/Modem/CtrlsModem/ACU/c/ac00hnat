/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00hnat.c
/
/	Module Version: ACU 4.02
/
/	Function:	This file contains action routines contained in the
/			st_hangup_at[] table. They are performed when the ACU
/			is in the HANGUP state.
/
/	Product:	ACU core code
/
/	History:	ac00hnat.c v3.90
/			ac00hnat.c v3.91
/			ac00hnat.c v3.96
/
/		Created: 11/16/91
/			3/10/92
/			1/12/93
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date:	RSA
/		Description:
/		Reason:
/
*****************************************************************************/

#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "mt_pro.h"

void proc_hangup_at(void);
void hangup_at_bg(void);
void proc_at_hangup(void);
void hang_up(ubyte);
void hangup_at_idle(void);

#if TIES_HAYES_ESCAPE                                /* ciy021596 */

extern void at_parser_reset(ubyte *);                   /* ciy021596 */
extern void set_acu_ties_esc_data_cmds(ubyte);          /* ciy021596 */
extern ubyte ties_esc_state;                            /* ciy021596 */
extern ubyte dte_mode;              /* mode byte for common dte io code */
extern ubyte dte_lead_guard;                            /* ciy050296 */
extern ubyte dte_guard_time;                            /* ciy050296 */
extern ubyte dte_tesc_count;                            /* ciy050296 */

#endif

/*******************************************************************************
/
/	Routine: proc_hangup_at
/
/	Author : RSA
/
/	Creation Date: 07/17/91
/
/	Description : This Routine will process the event by determining the
/		      next state and the action to be performed for the HANGUP
/		      state of type AT_PSTN.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  acu_state, acu_proc
/
/	Users: proc_hangup
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void proc_hangup_at(void)
{
    acu_state = st_hangup_at[acu_event->type].new_state;
    acu_proc = st_hangup_at[acu_event->type].fnc_ptr;
}


/*******************************************************************************
/
/	Routine: hangup_at_bg
/
/	Author : RSA
/
/	Creation Date: 07/17/91
/
/	Description : This Routine will perform the backgroung functions for
/		      the HANGUP state of type AT_PSTN.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  st_parse.type, at_h_comand
/
/	Users: hangup_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/       Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void hangup_at_bg(void)
{
/* start change 1/16/94 keh => no stalled loops for OS support */
#if 0 /* original code */
*    /*	Do not perform the hang up until the error correction software indicates
*        that it has disconnected. */
*    if (!delay_before_hangup)
*    {
*        /*	Will enable V.32 clear down sequence if in DIRECT mode or
*            running speed matching */
*        hang_up((ubyte)(((operating_mode == DIRECT) || (operating_mode == NORMAL))
*            && (tone_disconnect == FALSE)));
*
*        /*	If ATH was entered then return back to parse the rest of the command */
*        if (at_h_command == TRUE)
*        {
*            st_parse.type = AT_OFFLINE;
*            at_h_command = FALSE;
*            build_event(E_PARSE,UNUSED);
*        }
*        /*	Else need to return to IDLE and return result message to the user */
*        else
*        {
*            build_event(E_IDLE,UNUSED);
*            enable_acu_on_terminal();
*            build_event(E_MSG,hangup_result_type);
*        }
*    }
#endif

    switch (st_hangup.state)
    {
        case HANGUP_INIT:
            hangup_at_init();
            break;

        case HANGUP_LOGICAL_LINK_WAIT:
            hangup_at_system();
            break;

        case HANGUP_PHYSICAL_INIT:
            hangup_at_physical_init();
            break;

        case HANGUP_LONG_SPACE_DISC_WAIT:
            hangup_at_lsdisc_wait();
            break;

        case HANGUP_PHYSICAL_LINK:
            hangup_at_physical();
            break;

        case HANGUP_PHYSICAL_WAIT:
            hangup_at_physical_wait();
            break;

       case HANGUP_HOOK:
            hangup_at_hook();

            /* Allow a break between 'hook' and 'complete' so other modules
               can configure the acu *.type indicators */
            break;

        case HANGUP_COMPLETE:
            hangup_at_complete();
#if TIES_HAYES_ESCAPE                    /* ciy021596 */

#define ACU             1
#define ESC_NONE        0
#define ESC_DONE        1

/* ciy 5/2/96 9:15AM, To prevent remote drops, or local DTR drops, and not back to normal operation
 *           if ( ties_esc_state == ESC_DONE )
 * --------------------------------------------------*/
            if ( ties_esc_state != ESC_NONE )
            {
                ties_esc_state = ESC_NONE;
                error_occurred = FALSE;
                dte_lead_guard = FALSE;
                dte_guard_time = 0;
                dte_tesc_count = 0;
                at_parser_reset(cmd_ptr);
                dte_mode = ACU;
            }
#endif
            break;

        case HANGUP_FAX_INIT:
            hangup_at_fax_init();
            break;
    }
/* end change 1/16/94 keh => no stalled loops for OS support */
}

/*******************************************************************************
/
/	Routine: proc_at_hangup
/
/	Author : RSA
/
/	Creation Date: 07/17/91
/
/	Description : This Routine will change states to the HANGUP state of
/		      type AT_PSTN.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  hangup_result_type, st_hangup.type
/
/	Users: st_idle_offline[], st_idle_online[], st_orig_at[], st_answ_at[],
/	       st_online_at[]
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void proc_at_hangup(void)
{
/* start change 1/16/94 keh => no stalled loops for OS support */
   hangup_result_type = (ubyte)acu_event->parm;

   /* Hangup data modem */
   st_hangup.type = AT_PSTN;
   st_hangup.state = HANGUP_INIT;

/* end change 1/16/94 keh => no stalled loops for OS support */
}

/* start change 1/16/94 keh => no stalled loops for OS support */
/* This routine is done in ac00hnps.c (hangup processing) now */
#if 0
*/*******************************************************************************
*/
*/	Routine: hang_up
*/
*/	Author : RSA
*/
*/	Creation Date: 05/07/91
*/
*/	Description : This Routine is called cause the ACU to terminate the
*/		      PSTN connection.
*/
*/	Input Parameters: ubyte type - determines if V.32 clear down sequence should be
*/				       sent or not
*/
*/	Output Parameters: none
*/
*/	Global Variables Changed:  timer1, operating_mode, slU, s[1]
*/				   acu_state
*/
*/	Users:	called from HANG_UP state, at_O, at_Z
*/
*/	-------------------------------------------------------------
*/	-			Modifications			    -
*/	-------------------------------------------------------------
*/
*/       Author & Date: RSA
*/       Description:
*/       Reason:
*/
********************************************************************************/
*void hang_up(ubyte type)
*{
*    process_fax_hangup((ubyte) (at_h_command || at_z_command));
*
*    at_z_command = FALSE;
*
*    /* Used to Turn off the External V.23 clock generation hardware */
*    if ((modem_mode == V23_HDX) || (modem_mode == V23_ADX))
*        line_reset_v23();
*
*    modem_serial_direct(NORMAL);
*
*    /*	Send long space disconnect if not hanging up because one was received */
*    if ((long_space_disconnect == FALSE) && (sr21.long_space_discon))
*    {
*        if (operating_mode != RELIABLE)
*        {
*            system_send_long_space_disc();
*
*            /*	Delay to allow long space disconnect to go out	  */
*            timer1 = long_space_send_time;
*            while (timer1 > 0)
*            {
**                process_wait();
*                modem_task();
*            }
*        }
*    }
*    else
*        long_space_disconnect = FALSE;
*
*    /*	Release the line */
*    modem_drop(type);
*
*    while (modem_check_CD())
*    {
**        process_wait();
*        modem_task();
*    }
*
*    fp_mode_led_off();
*
*    /*	Reset the error correcting software	*/
*    system_reset();
*
*    /*	Reset if changed due to RELIABLE connection	*/
*    if (sr23.grant_rdl == ENABLED)
*        modem_rdl_enable(ENABLED);
*
*    slU = FALSE;
*
*/* start change keh 3/31/95 >> redo VNH */
*#if 0
*/* JAY - TIA Conversion Start 11/29/1993 */
*    if (!voice_VNH_active || !voice_VNH_upper_word)
*        on_hook();
*/* JAY - TIA Conversion End 11/29/1993 */
*#endif
*    /* Test automatic hangup hook control before going on-hook.  This is
*        used for voice call discrimination */
*    if (!voice_automatic_hangup)
*        on_hook();
*/* end change keh 3/31/95 >> redo VNH */
*
*    modem_shrt_relay(OFF);
*
*    modem_td_relay(OFF);
*    modem_AA1_relay(OFF);
*    modem_init_call_progress(ON_HOOK);
*
*    if ((comm_mode == ASYNC) && (!DSR_only_at_handshaking))
*        modem_dte_dsr(ON);
*    else
*        modem_dte_dsr(OFF);
*
*    modem_ec_led(OFF);
*    modem_dc_led(OFF);
*    modem_cd_led(OFF);
*
*    /*	Need to turn off RI led and signal incase hang_up is called in the
*        middle of a ring	*/
*    modem_ri_led(OFF);
*    modem_dte_ri(OFF);
*
*    /*	Clear ring count	*/
*    s[1] = 0;
*
*    if (sr21.RLSD_reflects_CD != RLSD_reflects_CD_temp)
*        sr21.RLSD_reflects_CD = RLSD_reflects_CD_temp;
*
*    /*	Reset 400Hz disconnect tone detection variables */
*    tone_disconnect = FALSE;
*
*    on_line_command = FALSE;
*
*    /*	Reset operating mode so it will be NORMAL while offline */
*    operating_mode = NORMAL;
*
*    v42_running_mnp10 = FALSE;
*    dial_K = FALSE;
*    dial_J = FALSE;
*}
#endif
/* end change 1/16/94 keh => no stalled loops for OS support */

/*******************************************************************************
/
/	Routine: hangup_at_idle
/
/	Author : RSA
/
/	Creation Date: 07/17/91
/
/	Description : This Routine will change states from the HANGUP AT_PSTN
/		      state to the IDLE OFFLINE state.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  st_idle.type
/
/	Users: st_hangup_at[]
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void hangup_at_idle(void)
{
    st_idle.type = AT_OFFLINE;
}

