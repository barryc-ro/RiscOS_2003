/*****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00cmex.c
/
/	Module Version: ACU 4.02
/
/	Function:	This file contains the code for the Microcom extended
/			command set.
/
/	Product:	ACU core code
/
/	History:	ac00cmex.c v3.90
/			ac00cmex.c v3.91
/			ac00cmex.c v3.92
/			ac00cmex.c v3.93
/			ac00cmex.c v3.95
/			ac00cmex.c v3.96
/
/		Created: 9/16/91
/			10/17/91
/			11/16/91
/			1/21/92
/			3/10/92
/			1/12/93
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date: RSA/keh 7/1/94
/		Description: Add 3 new parse routines for ETC commands:
/                   void ast_A(void);
/                   void ast_B(void);
/                   void per_B(void);
/		      And, modify sl_N() and sl_A() for ETC.
/		Reason: Add ETC support to core ACU
/
/		Author & Date: RSA
/		Description: 
/		Reason: 
/
*****************************************************************************/
#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "ll_pro.h"
#include "v25_pro.h"
#include "mt_pro.h"
#if 0 /* keh ETC has own cmd file for new parser */
/* start change keh 7/1/94 => Add ETC interface */
#include "acu_epro.h"       /* ACU ETC Driver interface routines */
/* end change keh 7/1/94 => Add ETC interface */
#endif


/* start change keh 12/94 => modify routines for new parser */
#if 1
void at_sl(void);
void at_per(void);
void at_hy(void);
void at_qu(void);
void at_ast(void);
void at_prn(void);

void sl_A(ubyte *);
void per_A(ubyte *);
void sl_B(ubyte *);
void sl_C(ubyte *);
void per_C(ubyte *);
void per_E(ubyte *);
void per_G(ubyte *);
void per_T(ubyte *);
void sl_G(ubyte *);
void sl_I(ubyte *);
void sl_J(ubyte *);
void sl_K(ubyte *);
void sl_L(ubyte *);
void sl_N(ubyte *);
void sl_O(void);
void sl_Q(ubyte *);
void sl_T(ubyte *);
void sl_T_eq(ubyte *);	/* ramn 6/27/96 */
void sl_U(void);
void sl_V(ubyte *);
void sl_X(ubyte *);
void sl_Y(void);
void sl_Z(void);
void hy_J(ubyte *);
void hy_B(void);
void hy_C(ubyte *);
void hy_K(ubyte *);
void hy_Q(ubyte *);
void hy_U(void);
void hy_V(void);
void qu_H(ubyte *);
void qu_M(ubyte *);
void qu_N(ubyte *);
void qu_O(ubyte *);
void ast_H(ubyte *);
void prn_M(ubyte *);

#else
void at_sl(void);
void at_per(void);
void at_hy(void);
void at_qu(void);
void at_ast(void);
void at_prn(void);
void sl_A(void);
void per_A(void);
void sl_B(void);
void sl_C(void);
void per_C(void);
void per_E(void);
void per_G(void);
void per_T(void);
void sl_G(void);
void sl_I(void);
void sl_J(void);
void sl_K(void);
void sl_L(void);
void sl_N(void);
void sl_O(void);
void sl_Q(void);
void sl_T(void);
void sl_U(void);
void sl_V(void);
void sl_X(void);
void sl_Y(void);
void sl_Z(void);
void hy_J(void);
void hy_B(void);
void hy_C(void);
void hy_K(void);
void hy_Q(void);
void hy_U(void);
void hy_V(void);
void qu_H(void);
void qu_M(void);
void qu_N(void);
void qu_O(void);
void ast_H(void);
void prn_M(void);
/* start change keh 7/1/94 => add local prototypes for ETC */
void ast_A(void);
void ast_B(void);
void per_B(void);
/* end change keh 7/1/94 => add local prototypes for ETC */
#endif
/* end change keh 12/94 => modify routines for new parser */

/* start change keh 12/94 => prefix calls are unused for new parser */
#if 0
/*******************************************************************************
/
/	Routine: at_sl
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will call the Routine needed to perform a
/		      command beginning with an '\'.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_sl(void)
{
	switch (get_next_char())
	{
		case 'A': sl_A();
			  break;

		case 'B': sl_B();
			  break;

		case 'C': sl_C();
			  break;

		case 'G': sl_G();
			  break;

		case 'I': sl_I();
			  break;

		case 'J': sl_J();
			  break;

		case 'K': sl_K();
			  break;

		case 'L': sl_L();
			  break;

		case 'N': sl_N();
			  break;

		case 'O': sl_O();
			  break;

		case 'Q': sl_Q();
			  break;

		case 'T': sl_T();
			  break;

		case 'U': sl_U();
			  break;

		case 'V': sl_V();
			  break;

		case 'X': sl_X();
			  break;

		case 'Y': sl_Y();
			  break;

		case 'Z': sl_Z();
			  break;

		default: error_occurred = TRUE;
	}
}

/*******************************************************************************
/
/       Routine:        at_per
/
/       Author:         RSA
/
/       Creation Date:  06/17/91
/
/       Description :   This Routine will call the Routine needed to perform a
/                       command beginning with an '%'.
/
/       Input Parameters: None
/
/       Output Parameters: none
/
/       Global Variables Changed:  None
/
/       Users: execute_cmd
/
/	      -------------------------------------------------------------
/       -	                  Modifications	                          -
/	      -------------------------------------------------------------
/
/       Author & Date: RSA/keh 7/1/94
/       Description: add per_B() to AT% parse list
/		  Reason: Add ETC support to core ACU
/
/       Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_per(void)
{
	switch (get_next_char())
	{
		case 'A': per_A();
			  break;
/* start change keh 7/1/94 => add AT%B command per ETC */
		case 'B': per_B();
			  break;
/* end change keh 7/1/94 => add AT%B command per ETC */
		case 'C': per_C();
			  break;

		case 'E': per_E();
			  break;

		case 'G': per_G();
			  break;

                /* The following two commands control Leased line operation.  They
                   are located in the Leased line code. */
		case 'M': 
				/*per_M();*/  /* ramn 9/23/96 */
			  break;

		case 'R': 
				/*per_R();*/  /* ramn 9/23/96 */
			  break;

		case 'T': per_T();
			  break;

                /* The following are commands to control V.25bis. They located
                   in the V.25bis code. */
		case 'D': /*per_D();    
		  			   break;
 					 */    /* ramn 9/27/96 */

		case 'F': /*per_F();
			  			break;
					 */    /* ramn 9/27/96 */

		case 'V': /* per_V();  */    /* ramn 9/27/96 */
			  break;

		default: error_occurred = TRUE;
	}
}



/*******************************************************************************
/
/	Routine: at_hy
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will call the Routine needed to perform a
/		      command beginning with an '-'.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void at_hy(void)
{
	switch (get_next_char())
	{
		case 'B': hy_B();
			  break;

		case 'C': hy_C();
			  break;

		case 'J': hy_J();
			  break;

		case 'K': hy_K();
			  break;

		case 'Q': hy_Q();
			  break;

		case 'U': hy_U();
			  break;

		case 'V': hy_V();
			  break;

		default: error_occurred = TRUE;
	}
}



/*******************************************************************************
/
/	Routine: at_qu
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will call the Routine needed to perform a
/		      command beginning with an '"'.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void at_qu(void)
{
	switch (get_next_char())
	{
		case 'H': qu_H();
			  break;

		case 'M': qu_M();
			  break;

		case 'N': qu_N();
			  break;

		case 'O': qu_O();
			  break;

		default: error_occurred = TRUE;
	}
}

/*******************************************************************************
/
/       Routine:        at_ast
/
/       Author:         RSA
/
/       Creation Date:  07/17/91
/
/       Description:    This routine is called during the CMD3 state. It will
/                       call the routine needed to perform a command beginning
/                       with '*'
/
/       Input Parameters: None
/
/       Output Parameters: None
/
/       Global Variables Changed: error_occurred
/
/       Users: execute_cmd()
/
/       -------------------------------------------------------------
/       -                   Modifications	                          -
/       -------------------------------------------------------------
/
/       Author & Date: RSA/keh 7/1/94
/       Description: add per_B() to AT% parse list
/		  Reason: Add ETC support to core ACU
/
/       Author & Date:	RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_ast(void)
{
	switch (get_next_char())
	{
/* start change keh 7/1/94 => add AT*A AT*B commands for ETC */
		case 'A': ast_A();
			  break;

		case 'B': ast_B();
			  break;
/* end change keh 7/1/94 => add AT*A AT*B commands for ETC */

		case 'H': ast_H();
			  break;

		default: error_occurred = TRUE;
	}
}

/*******************************************************************************
/
/	Routine: at_prn
/
/	Author : RSA
/
/	Creation Date: 07/17/91
/
/	Description: This routine is called during the CMD3 state. It will call
/		     the routine needed to perform a command beginning with ')'
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed: error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_prn(void)
{
	switch (get_next_char())
	{
		case 'M': prn_M();
			  break;

		default: error_occurred = TRUE;
	}
}

#endif /* No prefix routines for new parser */
/* end change keh 12/94 => prefix calls are unused for new parser */

/*******************************************************************************
/
/       Routine:        sl_A
/
/       Author:         RSA
/
/       Creation Date:  06/17/91
/
/       Description :   This Routine selects the maximum MNP block size
/
/	          AT\An	  0 - Set block size max 64 characters
/			          1 - Set block size max 128 characters
/			          2 - Set block size max 192 characters
/			          3 - Set block size max 256 characters
/			          4 - Set block size max 32 characters
/
/       Input Parameters: None
/
/       Output Parameters: none
/
/       Global Variables Changed:  error_occurred, slA, reconfigure
/
/       Users: at_sl()
/
/       -------------------------------------------------------------
/       -                   Modifications	                          -
/       -------------------------------------------------------------
/
/       Author & Date: RSA/keh 7/1/94
/       Description: Add AT\A4 (32 byte frames) for ETC
/		  Reason: Add ETC support to core ACU
/
/       Author & Date:	RSA
/       Description:
/       Reason:
/
*******************************************************************************/
#if 0
void sl_A(void)
{
    ubyte num;

    num = a_to_d();

/* start change keh 7/1/94 => add AT\A4 command for ETC */
/*	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 3))) */
    if ((error_occurred == FALSE) && ((num >= 0) && (num <= 4)))
/* end change keh 7/1/94 => add AT\A4 command for ETC */
    {
        slA = num;
        reconfigure = TRUE;
    }
    else
        error_occurred = TRUE;
}
#else

void sl_A(ubyte *param_ptr)
{
/* start change keh 7/1/94 => add AT\A4 command for ETC */
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 4)) */
    if (*param_ptr <= 4)
/* end change keh 8/15/95 => ubytes are never  < 0 */
/* end change keh 7/1/94 => add AT\A4 command for ETC */
    {
        slA = *param_ptr;
        reconfigure = TRUE;
    }
    else
        error_occurred = TRUE;
#endif
}

/*******************************************************************************
/
/	Routine: per_A
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine sets the autoreliable fallback character
/	       AT%An	0 - 127  ASCII character
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, perA
/
/	Users: at_per()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void per_A(void)
#else
void per_A(ubyte *param_ptr)
#endif
{
#if 0
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 127)))
		perA = num;
	else
		error_occurred = TRUE;
#else

   
/* start change keh 8/15/95 => ubytes are never  < 0 */
  /* if ((*param_ptr >= 0) && (*param_ptr <= 127)) */
   if (*param_ptr <= 127)
/* end change keh 8/15/95 => ubytes are never  < 0 */
        perA = *param_ptr;
    else
        error_occurred = TRUE;
#endif
}


/* start change keh 2/25/95 => add new parser */
#if 0

/* start change keh 7/1/94 => add AT%B command for ETC */
/*******************************************************************************
/
/       Routine:        per_B
/
/       Author:         RSA
/
/       Creation Date:  07/01/94
/
/       Description:    This Routine will parse the ETC specified AT%B command.
/
/                       The purpose of this command is to limit the maximum
/                       V.32bis DCE rate.
/
/                       The command has the form:
/                       AT%B 4800 - decimal number representing max V.32bis rate
/                       AT%B 7200 - decimal number representing max V.32bis rate
/                       AT%B 9600 - decimal number representing max V.32bis rate
/                       AT%B12000 - decimal number representing max V.32bis rate
/                       AT%B14400 - decimal number representing max V.32bis rate
/
/       Input Parameters: None
/
/       Output Parameters: none
/
/       Global Variables Changed:  error_occurred
/
/       Users: at_per()
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:	RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void per_B(void)
{
    uword num;
    ubyte speed = 0;

    /* This command only applies to ETC modems */
    if (acu_ETC_installed())
    {
        /* Get AT parameter from command string, Exit if parameter error */
        num = word_a_to_d();
        if (error_occurred == FALSE)
        {
            /* Which AT%B parameter ? */
            switch (num)
            {
                case 4800:
                    speed = BPS4800;
                    break;
                
                case 7200:
                    speed = BPS7200;
                    break;

                case 9600:
                    speed = BPS9600;
                    break;

                case 12000:
                    speed = BPS12000;
                    break;

                case 14400:
                    speed = BPS14400;
                    break;

                default:
                    error_occurred = TRUE;
                    break;
            }

            /* If no error, send command to ETC driver */
            if (!error_occurred)
            {
                /* Update ACU AT&V variable */
                perB = speed;

                acu_ETC_per_B(speed);
            }
        } /* if (error_occurred == FALSE) */
    }
    /* Else ETC is not installed */
    else
    {
        error_occurred = TRUE;
    }
}
/* end change keh 7/1/94 => add AT%B command for ETC */

#endif 
/* end change keh 2/25/95 => add new parser */


/*******************************************************************************
/
/	Routine: sl_B
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine causes b break to be transmitted
/	       AT\Bn	1 - 9 length of break
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  break_length
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
#if 0
void sl_B(void)
#else
void sl_B(ubyte *param_ptr)
#endif
{
#if 0
	ubyte num;

	num = a_to_d();

/*	Return indication of NO CARRIER if the modem is not connected */
	if (!on_line_command)
	{
		build_event(E_IDLE,UNUSED);
		build_event(E_MSG,NO_CARRIER);
		return;
	}

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 9)))
	{
		break_length = num * 10;
		system_send_break(break_length);
	}
	else
		error_occurred = TRUE;
#else
    /*	Return indication of NO CARRIER if the modem is not connected */
    if (!on_line_command)
    {
        build_event(E_IDLE,UNUSED);
        build_event(E_MSG,NO_CARRIER);
        return;
    }

/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 9)) */
    if (*param_ptr <= 9)
/* end change keh 8/15/95 => ubytes are never  < 0 */
    {
        break_length = *param_ptr * 10;
        system_send_break(break_length);
    }
    else
        error_occurred = TRUE;
#endif
}

/*******************************************************************************
/
/	Routine: sl_C
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the auto-reliable fallback option
/	       AT\Cn	0 - Does not buffer data
/			1 - Buffers data for 4 sec, until 200 characters have
/			    been buffered.
/			2- Does not buffer data. Switches to normal upon
/			   receipt of character defined by the %A command
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slC
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_C(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 2)))
		slC = num;
	else
		error_occurred = TRUE;
}
#else
void sl_C(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 2)) */
    if (*param_ptr <= 2)
/* end change keh 8/15/95 => ubytes are never  < 0 */
        slC = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: per_C
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the MNP data compression option
/	       AT%Cn	0 - Class 5 disabled
/			1 - Class 5 enabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, perC
/
/	Users: at_per()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void per_C(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
		perC = num;
	else
		error_occurred = TRUE;
}
#else
void per_C(ubyte *param_ptr)
{
    if ((*param_ptr == 0) || (*param_ptr == 1))
        perC = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: per_E
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects auto-retrain option
/	       AT%En	0 - Auto-retrain disabled
/			1 - Auto-retrain enabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, perE
/
/	Users: at_per()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void per_E(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
		perE = num;
	else
		error_occurred = TRUE;
}
#else
void per_E(ubyte *param_ptr)
{
    if ((*param_ptr == 0) || (*param_ptr == 1))
        perE = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: per_G
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the auto-fallback option
/	       AT%Gn	0 - Auto-fallback disabled
/			1 - Auto-fallback enabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, autofallback
/
/	Users: at_per()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void per_G(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
		autofallback = num;
	else
		error_occurred = TRUE;
}

#else
void per_G(ubyte *param_ptr)
{
    if ((*param_ptr == 0) || (*param_ptr == 1))
        autofallback = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: sl_G
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will set modem port flow control
/	       AT\G	0 - Disables modem port flow control
/			1 - Enables modem port flow control
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slG
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_G(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
	{
		slG = num;
		reconfigure = TRUE;
	}
	else
		error_occurred = TRUE;
}
#else
void sl_G(ubyte *param_ptr)
{
    if ((*param_ptr == 0) || (*param_ptr == 1))
    {
        slG = *param_ptr;
        reconfigure = TRUE;
    }
    else
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: sl_I
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the interface protocol
/	       AT\In	0 - Disables the interface protocol
/			1 - Enables the interface protocol (not supported)
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_I(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && (num != 0))
		error_occurred = TRUE;
}
#else
void sl_I(ubyte *param_ptr)
{
    /* 0 - Disables the interface protocol (only command supported) */
    if (*param_ptr != 0)
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: sl_J
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects BPS adjust option
/	       AT\Jn	0 - Disable BPS adjust
/			1 - Enable BPS adjust
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, bps_adjust
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_J(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && (num <= 1))
		bps_adjust = num;
	else
		error_occurred = TRUE;
}
#else
void sl_J(ubyte *param_ptr)
{
    if ((*param_ptr == 0) || (*param_ptr == 1))
        bps_adjust = *param_ptr;
    else
        error_occurred = TRUE;
}    
#endif


/*******************************************************************************
/
/	Routine: sl_K
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects break control
/	       AT\Kn	0 - 5
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slK, reconfigure
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_K(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 5)))
	{
		slK = num;
		reconfigure = TRUE;
		system_reconfigure();
	}
	else
		error_occurred = TRUE;
}
#else
void sl_K(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) || (*param_ptr <= 5)) */
    if (*param_ptr <= 5)
/* end change keh 8/15/95 => ubytes are never  < 0 */
    {
        slK = *param_ptr;
        reconfigure = TRUE;
        system_reconfigure();
    }
    else
        error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: sl_L
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects MNP link type
/	       AT\Ln	0 - Initiates stream link
/			1 - Initiates block link
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slL
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
#if 0
void sl_L(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && (num == 0))
		slL = num;
	else
		error_occurred = TRUE;
}
#else
void sl_L(ubyte *param_ptr)
{
    /* 0 - Is the only supported command */
    if (*param_ptr == 0)
        slL = 0;
    else
        error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/       Routine:        sl_N
/
/       Author:         RSA
/
/       Creation Date:  06/13/91
/
/       Description:    This routine selects the Protocol Operating mode.
/
/               AT\Nn	  0 - Normal mode
/                       1 - Direct mode
/                       2 - Auto-reliable MNP mode
/                       3 - Auto-reliable V.42 mode
/                       4 - Reliable V.42 mode
/                       5 - LAP-M Reliable mode (LAP-M or disconnect)
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  error_occurred, slN
/
/       Users: at_sl()
/
/
/       -------------------------------------------------------------
/       -                   Modifications	                          -
/       -------------------------------------------------------------
/
/       Author & Date: RSA/keh 7/1/94
/       Description: add AT\N5 (LAPM Reliable mode) for ETC
/		  Reason: Add ETC support to core ACU
/
/       Author & Date:	RSA
/       Description:
/       Reason:
/
*******************************************************************************/
#if 0
void sl_N(void)
{
    ubyte num;

    if (on_line_command == TRUE)
    {
        error_occurred = TRUE;
        return;
    }

    num = a_to_d();

/* start change keh 7/1/94 => add AT\N5 (lapm reliable) command for ETC */
/* 	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 4)))*/
    if ((error_occurred == FALSE) && ((num >= 0) && (num <= 5)))
/* end change keh 7/1/94 => add AT\N5 (lapm reliable) command for ETC */
    {
        if (num == DIRECT)
        {
            if (acu_cfg.direct)
                slN = num;
            else
                error_occurred = TRUE;
        }
        else
            slN = num;
    }
    else
        error_occurred = TRUE;
}
#else

void sl_N(ubyte *param_ptr)
{
    if (on_line_command == TRUE)
    {
        error_occurred = TRUE;
        return;
    }

/* start change keh 7/1/94 => add AT\N5 (lapm reliable) command for ETC */
/* 	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 4)))*/
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 5)) */

/* 4/15/96 shujin, old if (*param_ptr <= 5) */
    if (*param_ptr <= 4)  
    {
        if (*param_ptr == DIRECT)
        {
            if (acu_cfg.direct)

/*mrm31396*/

#if 0
                slN = *param_ptr;
#endif

                slN = NORMAL;

            else
                error_occurred = TRUE;
        }
        else
            slN = *param_ptr;
    }
    else
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: sl_O
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine causes the modem to originate a MNP link from
/		      a normal or direct connection.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slO, send_ok, on_line_command
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_O(void)
{
        /* Return ERROR if the modem has been configured not to perform this command */
        if (!acu_cfg.extended_cmds)
        {
		error_occurred = TRUE;
		return;
        }

	if (hook)
	{
		build_event(E_IDLE,UNUSED);
		build_event(E_MSG,NO_CARRIER);
		return;
	}

	if ((operating_mode == RELIABLE) || (sr27.comm_mode != ASYNC))
	{
		error_occurred = TRUE;
		return;
	}

	if (operating_mode == DIRECT)
		modem_serial_direct(NORMAL);
	slO = TRUE;
	system_reset();
	system_init();
	system_start(ORIGINATE);
	build_event(E_CONNECT,UNUSED);
	send_ok = FALSE;
	on_line_command = FALSE;
}
#else

void sl_O(void)
{
    /* No parameter for AT\O command */

    /* Return ERROR if the modem has been configured not to perform this command */
    if (!acu_cfg.extended_cmds)
    {
        error_occurred = TRUE;
        return;
    }

    if (hook)
    {
        build_event(E_IDLE,UNUSED);
        build_event(E_MSG,NO_CARRIER);
        return;
    }

    if ((operating_mode == RELIABLE) || (sr27.comm_mode != ASYNC))
    {
        error_occurred = TRUE;
        return;
    }

    if (operating_mode == DIRECT)
        modem_serial_direct(NORMAL);

    slO = TRUE;
    system_reset();
    system_init();
    system_start(ORIGINATE);
    build_event(E_CONNECT,UNUSED);
    send_ok = FALSE;
    on_line_command = FALSE;
}
#endif

/*******************************************************************************
/
/	Routine: sl_Q
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the serial port flow control
/	       AT\Qn	0 - Disables flow control
/			1 - Sets flow control to XON/XOFF
/			2 - Enables unidirectional hardware flow control
/			3 - Enables bidirectional hardware flow control
/			9 - Enables transparent flow control. This value
/			    will return error at this time because the
/			    current I/O code does not support this flow
/			    control method.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slQ, reconfigure
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_Q(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) &&

	    ((num >= 0) && (num <= 3)))
	{
		slQ = num;

		andK = num;
		if (num == 1)
			andK = 4;

		reconfigure = TRUE;

		if (num == 2 || num == 3)
			alt_fax_flow_control = CTS_RTS;
		else
			alt_fax_flow_control = XON_XOFF;
	}
	else
		error_occurred = TRUE;
}
#else
void sl_Q(ubyte *param_ptr)
{
    ubyte num;

   /* Get parameter from parser */
    num = *param_ptr;
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((num >= 0) && (num <= 3)) */
    if (num <= 3)
/* end change keh 8/15/95 => ubytes are never  < 0 */
    {
        reconfigure = TRUE;
        slQ = num;
        andK = num;

        switch (num)
        {
            case 3:
            case 2:
                alt_fax_flow_control = CTS_RTS;
                break;

            case 1:
                andK = 4;
                /* Intentionally Fall through */

            case 0:
                alt_fax_flow_control = XON_XOFF;
                break;
        }
    }
    else
    {
        error_occurred = TRUE;
    }
}
#endif

/*******************************************************************************
/
/	Routine: sl_T
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selectes the inactivity timer limit.
/	       AT\Tn	0 - 90 minutes
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, s[3], reconfigure
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_T(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 90)))
	{
		s[30] = num;
		reconfigure = TRUE;
	}
	else
		error_occurred = TRUE;
}
#else

void sl_T(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*	if ((*param_ptr >= 0) && (*param_ptr <= 90)) */
	if (*param_ptr <= 90)
/* end change keh 8/15/95 => ubytes are never  < 0 */
	{
		s[30] = *param_ptr;
		
		if(*param_ptr)			 /* ramn 6/27/96 */
			reconfigure = TRUE;
		else
			reconfigure = FALSE;
	}
	else
		error_occurred = TRUE;
}
#endif


/* ramn 6/27/96 */
void sl_T_eq(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*	if ((*param_ptr >= 0) && (*param_ptr <= 90)) */
	if (*param_ptr <= 90)
/* end change keh 8/15/95 => ubytes are never  < 0 */
	{
		s[30] = *param_ptr;
		
		if(*param_ptr)			 /* ramn 6/27/96 */
			reconfigure = TRUE;
		else
			reconfigure = FALSE;
	}
	else
		error_occurred = TRUE;
}




/*******************************************************************************
/
/	Routine: sl_U
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine causes the modem to wait in online command
/		      state to accept a MNP link.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slU, on_line_command, send_ok
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/       Author & Date: RSA
/       Description:
/
*******************************************************************************/
void sl_U(void)
{
    /* No parameter for AT\U command */

    /* Return ERROR if the modem has been configured not to perform this command */
    if (!acu_cfg.extended_cmds)
    {
        error_occurred = TRUE;
        return;
    }

    if (hook)
    {
        build_event(E_IDLE,UNUSED);
        build_event(E_MSG,NO_CARRIER);
        return;
    }

    if ((operating_mode == RELIABLE) || (sr27.comm_mode != ASYNC))
    {
        error_occurred = TRUE;
        return;
    }

    if (operating_mode == DIRECT)
        modem_serial_direct(NORMAL);

    slU = TRUE;
    system_reset();
    system_init();
    system_start(ANSWER);
    build_event(E_CONNECT,UNUSED);
    send_ok = FALSE;
    on_line_command = FALSE;
}

/*******************************************************************************
/
/	Routine: sl_V
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the modified result code form
/	       AT\Vn	0 - Enable result codes defined by ATV command
/			1 - Enable modified MNP result codes
/			2 - Enable modified V.42 result codec
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr95.arq
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_V(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 1)))
		sr95.arq = num;
	else
		error_occurred = TRUE;
}
#else
void sl_V(ubyte *param_ptr)
{
/* start change keh 4/14/95 => IAR compiler gags on "struct.mem = *ubyte;" */
#if 0
    switch (*param_ptr)
    {
        case 0:
        case 1:
            sr95.arq = *param_ptr;
            break;

        default:
            error_occurred = TRUE;
            break;
    }
#endif

   if (*param_ptr == 0)
       sr95.arq = 0;
   else if (*param_ptr == 1)
       sr95.arq = 1;
   else
       error_occurred = TRUE;

/* end change keh 4/14/95 => IAR compiler gags on "struct.mem = *ubyte;" */
}
#endif

/*******************************************************************************
/
/	Routine: sl_X
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the pass through flow control option
/	       AT\Xn	0 - Processes XON/XOFF flow control characters
/			1 - Processes XON/XOFF flow control characters and
/			    passes them through to the local or remote system
/			    so that they can also process the characters
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slX, reconfigure
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void sl_X(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
	{
		slX = num;
		reconfigure = TRUE;
	}
	else
		error_occurred = TRUE;
}
#else
void sl_X(ubyte *param_ptr)
{
    if ((*param_ptr == 0) || (*param_ptr == 1))
    {
        slX = *param_ptr;
        reconfigure = TRUE;
    }
    else
        error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: sl_Y
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine causes the modem to switch from a normal or
/		      direct connection to a MNP connection. Originate or answer
/		      is determined by the last connect type.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slY, on_line_command, send_ok
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/       Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void sl_Y(void)
{
    /* Return ERROR if the modem has been configured not to perform this command */
    if (!acu_cfg.extended_cmds)
    {
        error_occurred = TRUE;
        return;
    }

    if (hook)
    {
        build_event(E_IDLE,UNUSED);
        build_event(E_MSG,NO_CARRIER);
        return;
    }

    if ((operating_mode == RELIABLE) || (sr27.comm_mode != ASYNC))
    {
        error_occurred = TRUE;
        return;
    }

    if (operating_mode == DIRECT)
        modem_serial_direct(NORMAL);

    slY = TRUE;
    system_reset();
    system_init();

    if (sr14.originate_flag)
        system_start(ORIGINATE);
    else
        system_start(ANSWER);

    build_event(E_CONNECT,UNUSED);
    send_ok = FALSE;
    on_line_command = FALSE;
}

/*******************************************************************************
/
/	Routine: sl_Z
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine causes the modem to switch from a MNP
/		      connection to a normal connection.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, slU, slZ, operating_mode,
/				   send_ok, on_line_command
/
/	Users: at_sl()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/       Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void sl_Z(void)
{
    /* Return ERROR if the modem has been configured not to perform this command */
    if (!acu_cfg.extended_cmds)
    {
        error_occurred = TRUE;
        return;
    }

    if (hook)
    {
        build_event(E_IDLE,UNUSED);
        build_event(E_MSG,NO_CARRIER);
        return;
    }

    if ((slU == TRUE) || (operating_mode == RELIABLE))
    {
        slU = FALSE;
        slZ = TRUE;
        operating_mode = RELIABLE;
        system_halt(FALL_TO_SPEED);
        build_event(E_CONNECT,UNUSED);
        send_ok = FALSE;
        on_line_command = FALSE;
    }
    else
        error_occurred = TRUE;
}


/*******************************************************************************
/
/	Routine: hy_J
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the detection option.
/	       AT-Jn	0 - Disables detection
/			1 - Enables detection
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, hyJ
/
/	Users: at_hy()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void hy_J(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
		hyJ = num;
	else
		error_occurred = TRUE;
}
#else

void hy_J(ubyte *param_ptr)
{
	if ((*param_ptr == 0) || (*param_ptr == 1))
		hyJ = *param_ptr;
	else
		error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: hy_B
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will force a speed downshift during MNP 10
/		      operation.
/	       AT-B
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed: error_occurred
/
/	Users: at_hy()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void hy_B(void)
{
    /*	Return ERROR if MNP 10 has not been negotiated with the peer */
    if (system_force_rate(FALLBACK))
        error_occurred = TRUE;
}


/*******************************************************************************
/
/	Routine: hy_C
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine enable/disable calling tone.
/	       AT-Cn	0 - Disables calling tone
/			1 - Enables calling tone
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, calling_tone
/
/	Users: at_hy()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void hy_C(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num == 0) || (num == 1)))
		calling_tone = num;
	else
		error_occurred = TRUE;
}
#else

void hy_C(ubyte *param_ptr)
{

/*mrm32196*/
/*added the new calling tone command to generate CI tone in v34 mode*/

	if ((*param_ptr == 0) || (*param_ptr == 1) || (*param_ptr == 2))
		calling_tone = *param_ptr;
	else
		error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: hy_K
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will enable/disable MNP extended services
/		      for MNP 10 operation.
/	       AT-Kn	0 - Disables MNP extended services
/			1 - Enables MNP extended services
/			2 - Enables MNP extended services without MNP indication
/			    during the answer detect phase
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed: error_occurred, hyK
/
/	Users: at_hy()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void hy_K(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 2)))
		hyK = num;
	else
		error_occurred = TRUE;
}
#else
void hy_K(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 2)) */
    if (*param_ptr <= 2)
/* end change keh 8/15/95 => ubytes are never  < 0 */
        hyK = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: hy_Q
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will enable/disable fallback to 2400 and
/		      1200 bps.
/	       AT-Qn	0 - Disables fallback to 2400 and 1200 bps
/			1 - Enables fallback to 2400 bps
/			2 - Enables fallback to 2400 or 1200 bps
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed: error_occurred, hyQ
/
/	Users: at_hy()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void hy_Q(void)
{
	ubyte num;

	num = a_to_d();

	if (error_occurred == TRUE)
		return;

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 2)))
		hyQ = num;
	else
		error_occurred = TRUE;
}
#else
void hy_Q(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 2)) */
    if (*param_ptr <= 2)
/* end change keh 8/15/95 => ubytes are never  < 0 */
        hyQ = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: hy_U
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will force a speed upshift during MNP 10
/		      operation.
/	       AT-U
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed: error_occurred
/
/	Users: at_hy()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void hy_U(void)
{
    /* No parameter for AT-U command */

    /*	Return ERROR if MNP 10 has not been negotiated with the peer */
    if (system_force_rate(FALLFORWARD))
        error_occurred = TRUE;
}


/*******************************************************************************
/
/	Routine: hy_V
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will display the firmware version number.
/	       AT-V
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred
/
/	Users: at_hy()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void hy_V(void)
{
    /* No parameter for AT-U command */
/* start change keh => add custom version msg for Temic */
/*    output_info((ubyte *)VERSION_MSG,(ubyte)sr14.verbose_form); */
    output_info((ubyte *)"Date: September 21, 1995; Version: 1.03s",
       (ubyte)sr14.verbose_form);
/* end change keh => add custom version msg for Temic */
}


/*******************************************************************************
/
/	Routine: qu_H
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the V.42bis compression type.
/	       AT"Hn    0 - Disables compression
/			1 - Enable V.42bis in transmit direction only
/			2 - Enable V.42bis in receive direction only
/			3 - Enable V.42bis in both directions
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, quH
/
/	Users: at_qu()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void qu_H(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 3)))
		quH = num;
	else
		error_occurred = TRUE;
}
#else
void qu_H(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr <= 3)) */
    if (*param_ptr <= 3)
/* end change keh 8/15/95 => ubytes are never  < 0 */
        quH = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: qu_M
/
/	Author : RSA
/
/	Creation Date: 1/6/1993
/
/	Description : This Routine enables/disables MNP 10.
/	       AT"Mn    0 - Disables MNP 10
/			1 - Enables MNP 10
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, quM
/
/	Users: at_qu()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void qu_M(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 1)))
		quM = num;
	else
		error_occurred = TRUE;
}
#else
void qu_M(ubyte *param_ptr)
{
	if ((*param_ptr == 0) || (*param_ptr == 1))
		quM = *param_ptr;
	else
		error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: qu_N
/
/	Author : RSA
/
/	Creation Date: 1/6/1993
/
/	Description : This Routine sets the V.42bis dictionary size.
/	       AT"Nn    512+
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, btlz_dict_size
/
/	Users: at_qu()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void qu_N(void)
{
	uword num;

	num = word_a_to_d();

	if ((!error_occurred) && ((num >= 512) && (num <= DSIZE)))
		btlz_dict_size = num;
	else
		error_occurred = TRUE;
}

#else
void qu_N(ubyte *param_ptr)
{
    uword num;

    num = *(uword *)param_ptr;

    if ((num >= 512) && (num <= DSIZE))
        btlz_dict_size = num;
    else
        error_occurred = TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: qu_O
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine sets the V.42bis string length
/	       AT"On    6 - 250 characters
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, quO
/
/	Users: at_qu()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void qu_O(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 6) && (num <= 250)))
		quO = num;
	else
		error_occurred = TRUE;
}
#else
void qu_O(ubyte *param_ptr)
{
    if ((*param_ptr >= 6) && (*param_ptr <= 250))
        quO = *param_ptr;
    else
        error_occurred = TRUE;
}
#endif

/*******************************************************************************
/
/	Routine: per_T
/
/	Author : RSA
/
/	Creation Date: 11/04/91
/
/	Description: This routine enables SN tone disconnection
/	       AT%T	0 - Enable SN tone disconnection
/			1 - Disable SN tone disconnection
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, detect_400hz_enabled
/
/	Users: at_per()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void per_T(void)
{
	ubyte num;

	num = a_to_d();
	if (error_occurred == TRUE)
		return;
	switch (num)
	{
		case 0: detect_disconnect_tone = TRUE;
			break;

		case 1: detect_disconnect_tone = FALSE;
			break;

		default: error_occurred = TRUE;
			 return;
	}
}
#else
void per_T(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
        case 0:
            detect_disconnect_tone = TRUE;
            break;

        case 1:
            detect_disconnect_tone = FALSE;
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}
#endif

/* start change keh 2/25/95 => add new parser */
#if 0

/* start change keh 7/1/94 => add AT*A command for ETC */
/*******************************************************************************
/
/       Routine:        ast_A
/
/       Author:         RSA
/
/       Creation Date:  07/01/94
/
/       Description:    This Routine will parse the AT*A command for ETC.
/
/                       The purpose of this command is to select the ETC
/                       Autorate level.
/
/                       The command has the form:
/                       AT*A0 - Disable ETC Autorate
/                           1 - Enable ETC Autorating, start at max DCE Speed
/                           2 - Enable ETC Autorating, start at 9600 BPS
/                           3 - Enable ETC Autorating, start at 4800 BPS
/
/       Input Parameters: None
/
/       Output Parameters: none
/
/       Global Variables Changed:  error_occurred
/
/       Users: at_per()
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:	RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void ast_A(void)
{
    ubyte num;

    /* This command only applies to ETC modems */
    if (acu_ETC_installed())
    {
        /* Get AT command parameter */
        num = a_to_d();

        /* If the parameter is in bounds, pass it to the ACU ETC Driver */
        if ((error_occurred == FALSE) && ((num >= 0) && (num <= 3)))
        {
            /* Update ACU AT&V variable */
            astA = num;

            acu_ETC_ast_A(num);
        }
        else
            error_occurred=TRUE;
    }
    else
    {
        error_occurred=TRUE;
    }
}
/* end change keh 7/1/94 => add AT*A command for ETC */

/* start change keh 7/1/94 => add AT*B command for ETC */
/*******************************************************************************
/
/       Routine:        ast_B
/
/       Author:         RSA
/
/       Creation Date:  07/01/94
/
/       Description:    This Routine will parse the AT*B command for ETC.
/
/                       The purpose of this command is to select the
/                       ETC Cellular Hardware configuration.
/
/                       The command has the form:
/                       AT*B  0 = PSTN modem (default)
/                             1 = Unknown (run auto-detect if available)
/
/                             5 = Direct connect: AT&T 3610
/                             6 = Direct connect: AT&T 3760
/                             7 = Direct connect: AT&T 3730
/                             8 = Direct connect: Nokia 12/PT128
/                             9 = Direct connect: Technophone PC415
/                            10 = Direct connect: NEC P110/P120
/                            11 = Direct connect: OKI 1150
/                            12 = Direct connect: OKI 900
/                            13 = Direct connect: Ericsson/GE
/                         14-19 = Direct connect: Reserved for future types
/
/                            20 = RJ11 Adapter: Motorola Cellular Connection
/                            21 = RJ11 Adapter: Spectrum Cellular AXCELL
/                         22-29 = RJ11 Adapter: Reserved for future types
/
/                            30 = Modem Pool: Ericsson base equipment
/                            31 = Modem Pool: Motorola base equipment
/                            32 = Modem Pool: AT&T base equipment
/                        33-39 = Modem Pool: Reserved for future types
/
/       Input Parameters: None
/
/       Output Parameters: none
/
/       Global Variables Changed:  error_occurred
/
/       Users: at_per()
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:	RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void ast_B(ubyte *param_ptr)
{
    /* This command only applies to ETC modems */
    if (!acu_ETC_installed())
    {
        error_occurred=TRUE;
        return;
    }

    /* If the parameter is in bounds, pass it to the ACU ETC Driver */
    if (((*param_ptr >= 0) && (*param_ptr <= 1)) ||
        ((*param_ptr >= 5) && (*param_ptr <= 13)) ||
        ((*param_ptr >= 20) && (*param_ptr <= 21)) ||
        ((*param_ptr >= 30) && (*param_ptr <= 32)))
    {
        /* Update ACU AT&V variable */
        astB = *param_ptr;
        acu_ETC_ast_B(*param_ptr);
    }
    else
        error_occurred=TRUE;
}
/* end change keh 7/1/94 => add AT*B command for ETC */

#endif
/* end change keh 2/25/95 => add new parser */

/*******************************************************************************
/
/	Routine: ast_H
/
/	Author : RSA
/
/	Creation Date: 5/27/92
/
/	Description: This routine selects the initial link speed.
/	       AT*H	0 - Link negotiation occurs at highest supported speed.
/			1 - Link negotiation occurs at 1200 bps
/			2 - Link negotiation occurs at 4800 bps
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, link_negot
/
/	Users: at_ast()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void ast_H(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 2)))
		link_negot = num;
	else
		error_occurred=TRUE;
}

#else
void ast_H(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*	if ((*param_ptr >= 0) && (*param_ptr <= 2)) */
	if (*param_ptr <= 2)
/* end change keh 8/15/95 => ubytes are never  < 0 */
		link_negot = *param_ptr;
	else
		error_occurred=TRUE;
}
#endif


/*******************************************************************************
/
/	Routine: prn_M
/
/	Author : RSA
/
/	Creation Date: 5/27/92
/
/	Description: This routine enables/disables cellular operation.
/	       AT)M	0 - For central site modems: Auto-adjustment (adjusts
/			    power level if remote modem is set to )M1)
/			1 - For cellular site modems: Forces adjustment of
/			    power level
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, prnM
/
/	Users: at_prn()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void prn_M(void)
{
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 1)))
		prnM = num;
	else
		error_occurred=TRUE;
}
#else
void prn_M(ubyte *param_ptr)
{
	if ((*param_ptr == 0) || (*param_ptr == 1))
		prnM = *param_ptr;
	else
		error_occurred=TRUE;
}
#endif



