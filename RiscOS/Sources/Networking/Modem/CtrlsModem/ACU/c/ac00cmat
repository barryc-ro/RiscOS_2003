/****************************************************************************
/
/     Copyright 1988,1989,1990,1991,1992,1993,1994,1995.
/     All Rights Reserved by:
/     Cirrus Logic, Inc.
*****************************************************************************/

#include "sys_def.h"
#include "ee_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "acu_vce.h"
#include "mt_pro.h"
#include "v34_rate.h"
#include "ptt.h"
#include "mdm_56k.h" 
#include "bldflags.h"
#include "resp_cod.h" 
#include "dsppatch.h"
#include "mt_macro.h"
#include "mod_def.h"
#include "homolig1.h"
#include "bldflags.h"

#define COMMON_PATCH_VER_NUM    "Com Patch = "
#define DATA_PATCH_VER_NUM      "Dat Patch = "
#define TRAINING_PATCH_VER_NUM  "Trn Patch = "
#define VOICE_PATCH_VER_NUM     "Vce Patch = "
#define SERIAL_NUMBER_LOCATION     0
#define ATI10 "252"
#define ATI11 "254"
#define SAFE  "MD:1724T"

extern ubyte shunt_timer;        /* MH110697 */
extern ubyte shunt_timer_en;    
extern ubyte in_pulse_dial;        /* MH121697 */
extern const uword data_patch[];
extern const uword common_patch[];
extern const uword training_patch[];
extern const uword voice_patch[];
void word_to_a(uword num,ubyte *ptr);
extern void set_safe1_en_relay(ubyte);
extern const ubyte gen_country_name[];


void at_B(ubyte *);
void at_C(ubyte *);
void at_E(ubyte *);
void at_F(ubyte *);
void at_H(ubyte *);
void at_I(ubyte *);
void at_L(ubyte *);
void at_M(ubyte *);
void at_N(ubyte *);
void at_O(ubyte *);
void at_P(void);
void at_Q(ubyte *);
void at_S(ubyte *);
void at_equal(ulong *);
void chk_sreg_range(ulong);
void at_quest(void);
void at_T(void);
void at_V(ubyte *);
void at_W(ubyte *);
void at_X(ubyte *);
void at_Y(ubyte *);
void at_Z(ubyte *);
void at_comma(void);

#if MODEM_X2_MODE == 1
void modem_get_pcm_info(void);
#endif

void at_serial_number_amd(ubyte *);
void at_serial_q(void);
void at_serial_number_atmel(ubyte *);
void at_amd(void);
void at_atmel(void);
void write_serial_number_amd(void);
void write_serial_number_atmel(void);

#if DNLD_X2_FROM_HOST == 1
 void bang_X_e(uword *parm_ptr);
#endif

extern void main_dnld_flash_amd(void); 
extern void main_dnld_flash_atmel(void); 
extern void write_serial_number(void);

void str_WP(ubyte *);
void str_WD(ubyte *);

extern ubyte X2_MuOrA_Law;

void plus_ms(ubyte *);
void at_comma(void);
void print_dsp_version(void);
uword get_dsp_version(void);

#if TIES_HAYES_ESCAPE                    /* ciy021596 */
extern void online_at_esc(void);
extern ubyte ties_esc_state;
extern ubyte dte_mode;
#define ESC_DONE     1
#define ACU          1
#endif

#define STORED_NUM  2
#define UNFORMATTED     3
ubyte *d_to_a_two(ubyte num);

ubyte ms_mode;
ubyte ms_min_rate;
ubyte v34_bis_mode;
uword ms_min_speed = 0;

void output_send_cr_lf(void); 
extern ubyte ack_or_response; 
extern ubyte current_command[];
void send_pkt_to_dsp(void);
extern uword dsp_code[];

#define ACK 0
extern ubyte CountryInfo; 
extern InitiateToneATaps(void);
extern void CountryDependSRegRangeCheck(ubyte); 
extern ubyte LineCurrent(void); 
extern struct SREG22 s22orig;
extern   void  set_dsp_cid(ubyte); 
extern   void  set_callerid_relay(uword);
extern ubyte voice_caller_id; 
#define   CID_RELAY_OFF  0x0200
ubyte s0_value_changed = 0;     
ubyte value_of_s0_reg;
extern ubyte   line_mode; 
ubyte dsp_packet_id_msg[1];

#define UPGRADE_56K "Present, 32K DSP RAM."
#define NO_UPGRADE_56K "Not Found, Ext DSP RAM  "

#define X2_SRAM_PRESENT "Available 32K DSP RAM"
#define X2_SRAM_ABSENT  "Missing 32K DSP RAM"
#define WRONG_PARM1  "Incorrect Paramters!! "

void dsp_poke2 (uword data, uword addr, uword mcon_16);
uword dsp_peek2(uword addr, uword mcon_16);
ubyte dsp_ext_mem32k_test(uword dmy_mem_bank, uword dmy_WhatRange_Mapped_to_Which_Chip_Select);
ubyte dnld_bootx_code(const uword dmy_bootx_array[]);

ubyte Check_For_55_AA_Token(ubyte dmy_token);
ubyte Change_PLL_Freqency(ubyte dmy_value);
void loop_on_no_OK_semaphore(void);
void WriteDSP_MemThruBootx(uword addr_tmp1, uword data_tmp1);
uword ReadDSP_MemThruBootx(uword addr_tmp1);

void wait_a_while(void);
extern ubyte dial_timer;

extern ubyte ext_DspMemErrorFlag;
extern const uword bootx_array[];
extern const uword x2_page_array[];
ubyte *d_to_a(ubyte);

ubyte modem_control_reg_rts(void);
ubyte get_dte_DTR_status(void);
extern uword msec_counter;
extern void mt_driver_error_handler(ubyte);
extern const ubyte ati4[60];
extern const ubyte ati7[60];

/*******************************************************************************
/
/     Routine:       at_A
/
/     Author:        RSA
/
/     Creation Date: 12/07/94
/
/     Description:   This routine is called to implement the Answer command:
/                    "ATA."  The ATA command is used answer a call.
/
/     Input Parameters: none
/
/     Output Parameters: none   
/
/     Global Variables Changed:  sr.27.Bell_mode, atB
/
/     Users:    execute_cmd
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_A(void)
{
    if (CountryInfo == German){
        if ((!LineCurrent()) && (s[1] != 0)) {
            }
        else {
           error_occurred = TRUE;
             return ;
            }
        }
   /* No parameter for ATA command */
   send_ok = FALSE;

   if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
   {
       error_occurred = TRUE;
         return; /* if voice do not execute ata,ramn 7/31/96 */
   }
/*    if caller id enabled and we are going off-hook after 1 ring
    disable caller id 
*/
    if((voice_caller_id != 0) && (*srptr[1] == 1))
    {
         s0_value_changed = TRUE;       
         value_of_s0_reg = *srptr[0];
         *srptr[0] = 1;

#if 0
       set_dsp_cid(0);
        set_callerid_relay( CID_RELAY_OFF); 
        /* voice_caller_id = 0;*/
#endif
    }
   else if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
#if (PATCHLESS_EXTERNAL == 0)
 
#if CUTLASS_C6 == 1
        if(fax_class == 0)      /* issue th v34 config packet only in data mode */
        {
         current_command [0] = 0x90;        /* clamps the max symbol rate to < 3429 */
         current_command [1] = 0x00;        /* hence 33.6 not possible */
          current_command [2] = 0x08;
         current_command [3] = 0x00;
      current_command [4] = 0x79;
         current_command [5] = 0x21;
      current_command [6] = 0x7f;
         current_command [7] = 0x75;
          current_command [8] = 0x1b;
         current_command [9] = 0x01;
         current_command [9] = 0x07;
         current_command [9] = 0x00;

         ack_or_response = ACK;
      send_pkt_to_dsp();
        }
#endif
#endif
       build_event(E_ANSW,UNUSED);
   }
   else
       error_occurred = TRUE;

#if 0
   /* No parameter for ATA command */
   send_ok = FALSE;

   /* ATA is invalid for Voice IS-101 */
   if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
   {
       error_occurred = TRUE;
   }
   /* ATA is invalid if we're already connected */
   else if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
       build_event(E_ANSW,UNUSED);
   }
   else
   {
       error_occurred = TRUE;
   }
#endif
}

/*******************************************************************************
/
/     Routine:       at_B
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine will select the communication mode to
/                    be used.
/
/                    ATB   0  - CCITT mode (V.22 at 1200bps)
/                          1  - Bell mode (Bell 212A at 1200bps)
/                          2  - V23 mode if originating T75/R1200 BPS
/                                if answering T1200/R75 BPS
/                          3  - V23 mode if originating T1200/R75 BPS
/                                if answering T75/R1200 BPS
/
/                          15 - V.21 (at 300 bps)
/                          16 - Bell 103 (at 300 bps)
/
/                          30 - V.22bis (at 2400 bps)
/                          31 - V.34 (at 2400 bps)
/
/                          41 - V.32 (at 4800 bps)
/                          42 - V.34 (at 4800 bps)
/
/                          52 - V.32 (at 7200 bps)
/                          53 - V.34 (at 7200 bps)
/
/                          60 - V.32 (at 9600 bps)
/                          61 - V.34 (at 9600 bps)
/
/                          70 - V.32 (at 12000 bps)
/                          71 - V.34 (at 12000 bps)
/
/                          75 - V.32 (at 14400 bps)
/                          76 - V.34 (at 14400 bps)
/
/                          80 - V.34 (at 16800 bps)
/
/                          85 - V.34 (at 19200 bps)
/
/                          90 - V.34 (at 21600 bps)
/
/                          95 - V.34 (at 24000 bps)
/
/                         100 - V.34 (at 26400 bps)
/
/                         105 - V.34 (at 28800 bps)
/
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none  
/
/     Global Variables Changed:  sr.27.Bell_mode, atB
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_B(ubyte *param_ptr)
{
   ubyte num;

   /* Ubyte parameter for ATB command */
   num = *param_ptr;

#if 0
   /* If parameter on ATB is greater then what is allowed for V.22bis then
      need to return error. */
   if (acu_cfg.mode == CFG_V22BIS)
   {
      if (num >= 40)
      {
     error_occurred = TRUE;
     return;
      }
   }
   /* If parameter on ATB is not allowed for V.32 then need to return error */
   else if (acu_cfg.mode == CFG_V32)
   {
      if (((num >= 50) && (num <= 59)) || (num >= 70))
      {
     error_occurred = TRUE;
     return;
      }
   }
   /* If parameter on ATB is greater then what is allowed for V.32bis then
      need to return error. */
   else if (acu_cfg.mode == CFG_V32BIS)
   {
      if (num >= 80)
      {
     error_occurred = TRUE;
     return;
      }
   }
   /* If parameter on ATB is greater then what is allowed for V.34 then
      need to return error. */
   else if (acu_cfg.mode == CFG_V34)
   {
      if (num > 110)
      {
     error_occurred = TRUE;
     return;
      }
   }

#endif

   /* See if value is in group 1 (1200 bps) */
   if (num <= 9)
   {
      /* See if valid value for group 1 */
      switch (num)
      {
     case 0: /* Bell 212 */
        sr27.BELL_mode = FALSE;
        atB.group1 = num;
        atB.group3 = 15;
        break;

     case 1: /* V.22 */
        sr27.BELL_mode = TRUE;
        atB.group1 = num;
        atB.group3 = 16;
        break;

     case 2: /* V.23 */
     case 3: /* V.23R */
        if (acu_cfg.v23)
           atB.group1 = num;
        else
           error_occurred = TRUE;
        break;
     
     default: error_occurred = TRUE;

      }
   }

#if 0
   /* See if value is in group 2 (Transmit 75 bps)    */
   else if ((num >= 10) && (num <= 14 ))
   {
      error_occurred = TRUE;
   }
   /* See if value is in group 3 (300 bps)   */
   else if ((num >= 15) && (num <= 19 ))
   {
      /* See if valid value for group 3 */
      switch (num)
      {
     case 15:    /* Bell 103 */
        sr27.BELL_mode = FALSE;
        atB.group3 = num;
        break;
        
     case 16:    /* V.21 */
        sr27.BELL_mode = TRUE;
        atB.group3 = num;
        break;

     default: error_occurred = TRUE;
        break;
      }
   }
   /* See if value is in group 4 (600 bps)   */
   else if ((num >= 20) && (num <= 29 ))
   {
      error_occurred = TRUE;
   }
   /* See if value is in group 5 (2400 bps) */
   else if ((num >= 30) && (num <= 39 ))
   {
      /* See if valid value for group 5 */
      switch (num)
      {
     case 30:    /* V.22bis */
     case 32:    /* V.34 */
        atB.group5 = num;
        break;
     
     default: error_occurred = TRUE;
        break;
      }
   }
   /* See if value is in group 6 (4800 bps) */
   else if ((num >= 40) && (num <= 49 ))
   {
      /* See if valid value for group 6 */
      switch (num)
      {
     case 41:    /* V.32 */
     case 42:    /* V.34 */
        atB.group6 = num;
        break;
        
     default: error_occurred = TRUE;
        break;
      }
   }
   /* See if value is in group 7 (7200 bps) */
   else if ((num >= 50) && (num <= 59 ))
   {
      /* See if valid value for group 7 */
      switch (num)
      {
     case 52:    /* V.32 */
     case 53:    /* V.34 */
        atB.group7 = num;
        break;
     
     default: error_occurred = TRUE;
        break;
      }
   }
   /* See if value is in group 8 (9600 bps) */
   else if ((num >= 60) && (num <= 69 ))
   {
      /* See if valid value for group 8 */
      switch (num)
      {
     case 60:    /* V.32 */
     case 61:    /* V.34 */
        atB.group8 = num;
        break;
     
     default: error_occurred = TRUE;
        break;
      }
   }
   /* See if value is in group 9 (12000 bps) */
   else if ((num >= 70) && (num <= 74 ))
   {
      /* See if valid value for group 9 */
      switch (num)
      {
     case 70:    /* V.32 */
     case 71:    /* V.34 */
        atB.group9 = num;
        break;

     default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 10 (14400 bps) */
   else if ((num >= 75) && (num <= 99 ))
   {
      /* See if valid value for group 10 */
      switch (num)
      {
     case 75:    /* V.32 */
     case 76:    /* V.34 */
        atB.group10 = num;
        break;

     default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 11 (16800 bps) */
   else if ((num >= 80) && (num <= 84 ))
   {
      /* See if valid value for group 11 */
      switch (num)
      {
     case 80:    /* V.34 */
        atB.group11 = num;
        break;
     default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 12 (19200 bps) */
   else if ((num >= 85) && (num <= 89))
   {
      /* See if valid value for group 12 */
      switch (num)
      {
     case 85:    /* V.34 */
        atB.group12 = num;
        break;
     default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 13 (21600 bps) */
   else if ((num >= 90) && (num <= 94))
   {
      /* See if valid value for group 13 */
      switch (num)
      {
     case 90:    /* V.34 */
        atB.group13 = num;
        break;
     default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 14 (24000 bps) */
   else if ((num >= 95) && (num <= 99))
   {
      /* See if valid value for group 14 */
      switch (num)
      {
     case 95:    /* V.34 */
        atB.group14 = num;
        break;
     default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 15 (26400 bps) */
   else if ((num >= 100) && (num <= 104))
   {
      /* See if valid value for group 15 */
      switch (num)
      {
     case 100:   /* V.34 */
        atB.group15 = num;
        break;

     default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 16 (28800 bps) */
   else if ((num >= 105) && (num <= 109))
   {
      /* See if valid value for group 16 */
      switch (num)
      {
     case 105:   /* V.34 */
        atB.group16 = num;
        break;

     default: error_occurred = TRUE;
      }
   }
#endif
   else
   {
      error_occurred = TRUE;
   }

}


/*******************************************************************************
/
/     Routine:       at_C
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the carrier control option
/
/                    ATC   0 - transmit carrier always off  (not supported)
/                          1 - normal transmit carrier switching
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_C(ubyte *param_ptr)
{
   /* Ubyte parameter for ATC command */
   if (*param_ptr != 1)
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_D
/
/     Author:        RSA
/
/     Creation Date: 12/07/94
/
/     Description:   This routine is called to implement the Dial command:
/                    "ATD."  The ATD command is used originate a call.
/
/     Input Parameters: *param_ptr - pointer to the command's parameter
/                      (a NULL terminated string)
/
/     Output Parameters: none   
/
/     Global Variables Changed:  
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_D(ubyte *param_ptr)
{
    if (CountryInfo == German)
    {
        s22orig = sr22;
        if (!LineCurrent())
        {
            if (*param_ptr == NULL)
            {
                sr22.busy_enable = FALSE;
                sr22.dialtone_enable = FALSE;
                sr22.enable_result5 = FALSE;
            }
        }
        else 
        {
           error_occurred = TRUE;
             return ;
        }
    }
   /* Save the Dial String Buffer for later use */
   acu_dial_string_ptr = param_ptr;
   send_ok = FALSE;

/*   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
*/

   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && !test_in_progress))
   {
        if(on_line_command)
        {
            if(fax_class == 8)
            {
                state_type[S_PARSE] = AT_OFFLINE; 
            }
            else
            {
        error_occurred = TRUE;
                return;
            }
        }

#if (PATCHLESS_EXTERNAL == 0)
#if CUTLASS_C6 == 1
        if(fax_class == 0)      /* issue th v34 config packet only in data mode */
        {
         current_command [0] = 0x90;        /* clamps the max symbol rate to < 3429 */
         current_command [1] = 0x00;        /* hence 33.6 not possible */
          current_command [2] = 0x08;
         current_command [3] = 0x00;
      current_command [4] = 0x79;
         current_command [5] = 0x21;
      current_command [6] = 0x7f;
         current_command [7] = 0x75;
          current_command [8] = 0x1b;
         current_command [9] = 0x01;
         current_command [9] = 0x07;
         current_command [9] = 0x00;

         ack_or_response = ACK;
      send_pkt_to_dsp();
        }
#endif
#endif

#if INTERNATIONAL_CODE == 1
    set_shunt_relay(DEACTIVATE);    /* MH121697 OUTPUT = 0 */
    shunt_timer=20;
    shunt_timer_en=1;


    if( (*param_ptr == 'P') || 
        ((*param_ptr != 'T') && (sr14.pulse == 1)) 
      )
    {
         in_pulse_dial = 1;    /* MH121697 */
    }



#endif
    InitiateTransmitLevel(1);  // 1 is for dtmf. atd could mean atdt.
    build_event(E_ORIG,UNUSED);
   }
   else
       error_occurred = TRUE;
#if 0
   /* Save Address of the Address String Buffer for later use */
   acu_dial_string_ptr = param_ptr;
   send_ok = FALSE;

   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
       build_event(E_ORIG,UNUSED);
   }
   else
       error_occurred = TRUE;
#endif

}


/*******************************************************************************
/
/     Routine:       at_E
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the command character echo option
/
/                    ATE   0 - off-line character echo disabled
/                          1 - off-line character echo enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.echo_cmd_flag, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_E(ubyte *param_ptr)
{
   /* Ubyte parameter for ATE command */
   switch (*param_ptr)
   {
      case 0:
     sr14.echo_cmd_flag = FALSE;
     /* modem_serial_echo(OFF);*/ /* ramn 9/20/96 */
     break;

      case 1:
     sr14.echo_cmd_flag = TRUE;
     break;
      
      default:
     error_occurred = TRUE;
     return;
   }
}


/*******************************************************************************
/
/     Routine:       at_F
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:  This Routine selects the data character echo option
/
/                    ATF   0 - on-line character echo enabled (not supported)
/                          1 - on-line character echo disabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_F(ubyte *param_ptr)
{
    /* Only ATF1 is supported */
    if (*param_ptr != 1)
    error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_H
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine controls the switch hook.
/
/                    ATH   0 - execute hang up process
/                          1 - go off hook, but no handshake
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed: error_occurred, at_h_command
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_H(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
    case 0:
#if TIES_HAYES_ESCAPE                    /* ciy021596 */

        {
        if (test_in_progress)
        {
            build_event(E_HANGUP,NONE);
            if ( dte_mode != ACU )
            {
            ties_esc_state = 'H';
            error_occurred = TRUE;
            }
        }
        else
        {
            if ( (on_line_command && !test_in_progress && fax_class == 0 )
            || ( ties_esc_state == ESC_DONE ) )
            {
            if ( !on_line_command )
                {
                send_ok = TRUE;
                ties_esc_state = 'H';
                error_occurred = TRUE;
                }
            hangup_connection(NONE);
            }
            else

/* MH092297 */
#if INTERNATIONAL_CODE == 1          
          set_loc_line_relay(ON_HOOK);
          set_safe1_en_relay(ACTIVATE);    /* mh103197 output = HI */
          set_shunt_relay(ACTIVATE); /* MH112697 */
          shunt_timer_en=0;
            in_pulse_dial = 0;    
#else
          set_safe1_en_relay(ACTIVATE);    /* mh103197 output = HI */
#endif    

                build_event(E_HANGUP,NONE);
        }
        }
#else
        /* Queue E_HANGUP event to terminate the test */
        if (test_in_progress)
        build_event(E_HANGUP,NONE);
        else
        /* Terminate the link */
        if (on_line_command && !test_in_progress && fax_class == 0)
        hangup_connection(NONE);
        else
        build_event(E_HANGUP,NONE);
#endif
        at_h_command = TRUE;
        user_initiated_hangup = TRUE;
        break;

    case 1:
        if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
        {
        error_occurred = TRUE;
        return;
        }

/* MH092297 */
#if INTERNATIONAL_CODE == 1          
    set_loc_line_relay(OFF_HOOK_NOT_DIALED);
                ath1_timer_init();
    set_shunt_relay(DEACTIVATE);    /* MH121697 OUTPUT = 0 */
    shunt_timer=20;
    shunt_timer_en=1;
#endif

        off_hook();

#if 0
        modem_td_relay(ON);
        if (sr21.auxiliary_relay_ctrl)
        modem_AA1_relay(ON);
#endif
        break;

    default:
        error_occurred = TRUE;
        return;
    }

#if 0
   /* Ubyte parameter for ATH command */
   switch (*param_ptr)
   {
      case 0:
     /* Terminate the link */
     if (on_line_command && !test_in_progress && fax_class == 0)
        hangup_connection(NONE);
     /* Else queue HANGUP event to terminate the test */
     else
        build_event(E_HANGUP,NONE);

     at_h_command = TRUE;
     user_initiated_hangup = TRUE;
     break;

      case 1:
     /* ATH1 is not allowed in TIA voice */
     if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
     {
        error_occurred = TRUE;
        return;
     }
     modem_td_relay(ON);
     off_hook();

     if (sr21.auxiliary_relay_ctrl)
        modem_AA1_relay(ON);
     break;

      default:
     error_occurred = TRUE;
     return;
   }
#endif
}

/*******************************************************************************
/
/     Routine:       at_I
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine is uded to display hardware description.
/
/                    ATI   0 - Display product code
/                          1 - Calculate and display ROM checksum
/                          2 - Verify ROM checksum
/                          3 - Display part numbers and revision levels
/                          4 - Display modem capabilities
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/

void at_I(ubyte *param_ptr)
{
    ubyte *string,*temp;
    ubyte val1, val2;
    #if (PATCHLESS_EXTERNAL == 0)
    ubyte string99[6];
    #endif
    
    if (voice_cmd_set == TIA_IS_101)
    {
    error_occurred = TRUE;
    return;
    }

    /* Ubyte parameter for ATI command */
    switch (*param_ptr)
    {
       case 0:
            output_info( (ubyte *) MODEM_PRODUCT_CODE,
                         (ubyte)sr14.verbose_form);
       break;

        case 1:
            print_dsp_version();
            output_send_cr_lf();  
        break;

    case 2:
        if (!modem_rom_test())
        string = (ubyte *)"ROM TEST ERROR";
        else
        string = (ubyte *)"ROM TEST OK";

        output_info(string,(ubyte)sr14.verbose_form);
        break;

    case 3:
        output_info((ubyte *)MODEM_CHIPSET_NAME,(ubyte)sr14.verbose_form);
        break;

    case 4: 
#if INTERNATIONAL_CODE == 1
        string = (ubyte*)ati4;
        output_info(string,STORED_NUM);
#endif
        break;

    case 5:

     if( ext_DspMemErrorFlag == 0)
     {
       string = (ubyte*) UPGRADE_56K;              
     }
     else
     {
       string = (ubyte*) NO_UPGRADE_56K;           
     }
 
       /* indicates if the external DSP SRAM exists */                    
        output_info(string,STORED_NUM);   
          
    string = d_to_a(ext_DspMemErrorFlag);
            output_info(string,UNFORMATTED);

            string = (ubyte*) HOSTIF;

            output_info(string,STORED_NUM);
            temp = (ubyte *) HICSR;
/* if ring not present then value is 65 if ring presnet value is 25 */
            if ((*temp == 0x65) || (*temp == 0x25)) 
            {
                string = (ubyte*) PARALLEL;
                output_info(string,UNFORMATTED);

            }
/* if ring not present then value is 71 if ring presnet value is 31 */
                else if ((*temp == 0x71) || (*temp == 0x31))

            {
                string = (ubyte*) SERIAL;
                output_info(string,UNFORMATTED);

            }

            string = (ubyte*) PMMODE;
            output_info(string,STORED_NUM);
            temp = (ubyte *) CSCR1;

            val1= *temp & 0x0f;
            val2 = *temp;
            val2= val2>>4;

            if(val1==2)
              val1=32;
            if(val1==1)
              val1=16;
            if(val1==0)
              val1=8;

            string = d_to_a(val1);
            output_info(string,UNFORMATTED);

            string = (ubyte*) BIT;
            output_info(string,UNFORMATTED);

            string = d_to_a(val2);
            output_info(string,UNFORMATTED);

            string = (ubyte*) WAIT;
            output_info(string,UNFORMATTED);

            string = (ubyte*) DMMODE;
            output_info(string,STORED_NUM);
            temp = (ubyte *) CSCR3;

            val1= *temp & 0x0f;
            val2 = *temp;
            val2= val2>>4;

            if(val1==2)
              val1=32;
            if(val1==1)
              val1=16;
            if(val1==0)
              val1=8;
    
            string = d_to_a(val1);
            output_info(string,UNFORMATTED);

            string = (ubyte*) BIT;
            output_info(string,UNFORMATTED);

            string = d_to_a(val2);
            output_info(string,UNFORMATTED);

            string = (ubyte*) WAIT;
            output_info(string,UNFORMATTED);

            string = (ubyte*) DSP_CODE_MODE;               
            output_info(string,STORED_NUM);   
            /* indicates the location of
             DSP code int ROM or ext SRAM */
    
        break;


    case 6: 
            CountryInfo &= 0x0f;
            if (CountryInfo == 0) {
                string = (ubyte *) US;
                }
            else {
                if (CountryInfo == 1) {
                    string = (ubyte*) JAPAN;
                    }
                else {
                    if (CountryInfo == 2) {
                        string = (ubyte*) ENGLAND;
                        }
                    else {
                        if (CountryInfo == 3) {
                            string = (ubyte*) GERMANY;
                            }
                        else {
                            if (CountryInfo == 4) {
                                string = (ubyte*) FRANCE;
                                }
                            else {
                                if (CountryInfo == 5) {
                                    string = (ubyte*) NETHERLAND;
                                    }
                                else {
                                    if (CountryInfo == 6) {
//                                        string = (ubyte*) ITALY;
                                        string = (ubyte*) gen_country_name;
                                        }
                                    else {
                                        string = (ubyte *) US; /*Default Country*/
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            output_info(string,STORED_NUM);
            break;
           
    case 7: 
           string = (ubyte*)ati7;
           output_info(string,STORED_NUM);
      
           break;
           
    case 8:
           temp = (ubyte *)MDM_FIRMWARE_FEATURES;
           string = temp + 8;
           output_info(string,STORED_NUM);
           break;
                
    case 9: 
    case 12: 
    case 13: 
    case 21: 
    case 23: 
    case 24: 
    case 25: 
                break;
    case 10: 
                output_info((ubyte *)ATI10, STORED_NUM);
                break;
                
    case 11: 
                output_info((ubyte *)ATI11,STORED_NUM);
                break;

    case 14: 
                output_info((ubyte *)SAFE,STORED_NUM);
                break;

#if MODEM_X2_MODE == 1
   /* for x2 pcm status */
   case 20:
        if (line_mode == VX2)
             modem_get_pcm_info();
        break;
#endif

    case 22: 
        output_info((ubyte *)MODEM_MANUFACTURER_IDENTIFICATION, 
                     STORED_NUM);
        break;
        
        case 99:
         #if (PATCHLESS_EXTERNAL == 0)
            string = (ubyte *) COMMON_PATCH_VER_NUM;
            output_info(string,STORED_NUM);
            word_to_a(common_patch[3],string99);
            output_info(string99,UNFORMATTED);

            string = (ubyte *) DATA_PATCH_VER_NUM;
            output_info(string,STORED_NUM);
            word_to_a(data_patch[3],string99);
            output_info(string99,UNFORMATTED);

            string = (ubyte *) TRAINING_PATCH_VER_NUM;
            output_info(string,STORED_NUM);
            word_to_a(training_patch[3],string99);
            output_info(string99,UNFORMATTED);

            string = (ubyte *) VOICE_PATCH_VER_NUM;
            output_info(string,STORED_NUM);
            word_to_a(voice_patch[3],string99);
            output_info(string99,UNFORMATTED);
         #else 
            output_info( (ubyte *) "PATCHLESS EXTERNAL",STORED_NUM);
     
         #endif
        break;

    default:
        error_occurred = TRUE;
        break;
    }
}

/*******************************************************************************
/
/     Routine:       at_L
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the speaker volume.
/                    ATL   0 - Low volume
/                          1 - Low volume
/                          2 - Medium volume
/                          3 - High volume
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.speaker_vol, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_L(ubyte *param_ptr)
{
   ubyte num;

   num = *param_ptr;
   if (num <= 3)
   {
      sr22.speaker_vol = num;
      modem_speaker_vol(num);
   }
   else
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_M
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the speaker control.
/
/                    ATM   0 - Speaker always off
/                          1 - Speaker on until carrier present
/                          2 - Speaker always on
/                          3 - Speaker off during dialing and on until carrier
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.speaker_control, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_M(ubyte *param_ptr)
{
   switch (*param_ptr)
   {
      case 0:
     sr22.speaker_ctrl = ALWAYS_OFF;
     modem_speaker(OFF);
     break;

      case 1:
     sr22.speaker_ctrl = ON_UNTIL_CD;
     if (!hook)
        modem_speaker(OFF);
     break;

      case 2:
     sr22.speaker_ctrl = ALWAYS_ON;
     if (!hook)
        modem_speaker(ON);
     break;
    
      case 3:
     sr22.speaker_ctrl = OFF_DIALING;
     if (!hook)
        modem_speaker(OFF);
     break;

      default: error_occurred = TRUE;
     return;
   }
}

/*******************************************************************************
/
/     Routine:       at_N
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the auto-mode/V.8 option. (bit mapped)
/                    ATNn  0 - Automode disabled
/                          1 - Automode enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  automode, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_N(ubyte *param_ptr)
{
   /* Test for automode and V.8 */
    if (*param_ptr <= 1)
    {
         switch(        *param_ptr)
         {
            case 0:
                N = 0;
                automode = 0;
#if MODEM_X2_MODE == 1
                if ((ms_mode == VX2)||(ms_mode == V90))
                    automode = 2;
                else
#endif
                if( (ms_mode == V34) || (ms_mode == V34S) )
                    automode = 2;

                break;

            case 1:
                N = 1;
                automode = 1;
#if MODEM_X2_MODE == 1
                if ((ms_mode == VX2)||(ms_mode == V90))
                    automode = 3;
                else
#endif
                if( (ms_mode == V34) || (ms_mode == V34S) )
                    automode = 3;

                break;
            }

    }
    else
        error_occurred = TRUE;

}

/*******************************************************************************
/
/     Routine:       at_O
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to tell the modem to return to
/                    a previously established connection.
/
/                    ATO   0 - Go to on-line state
/                          1 - Go to on-line state and retrain adaptive equalizer
/                             (V.22bis,V.32,V.32bis, and V.34 modulations only)
/                          3 - Go to on-line state and rate renegotiate 
/                             (V.32bis, and V.34 modulations only)
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred, result_message_sent,
/                    send_ok, on_line_command, modem_baud, acu_state
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_O(ubyte *param_ptr)
{
   ubyte num, tmp;

   if (voice_cmd_set == TIA_IS_101)
   {
       error_occurred = TRUE;
       return;
   }

   /* Allow ATO to return online from some tests... */
   switch (test_in_progress)
   {
      case 0: /* No Test in progress - do nothing */
     break;

      case ALB:
      case RDL:
     /* Return back to the test (AT&T1,6) */
     build_event(E_TEST,TEST_RETURN);
     return;

      default:
     error_occurred = TRUE;
     return;
   }

   /* If on hook, the command is not vaild */
   if ((hook == TRUE) || (slU == TRUE))
   {
      error_occurred = TRUE;
      return;
   }

   /* Get AT command parameter local */
   num = *param_ptr;

   /* Update modem's retrain operation in case it has changed while in on
      line command mode. */

   /* if operating V80 SAM */
   if (slN == 6)
   {
      /* disable automatic retrains and renegotiations for the host */
      modem_retrain_enable(FALSE,FALSE,FALSE);
   }
   else
   {
      tmp = ((((operating_mode != DIRECT) && (!bps_adjust)) ||
        (comm_mode != ASYNC)) && (autofallback));

      modem_retrain_enable(perE,s[110],tmp);
   }

#if TIES_HAYES_ESCAPE                    /* ciy021596 */

    if ( on_line_command )
    update_modem_rate_seq();

    /* If running MNP 10 do not allow the ACU to force a retrain or rate
    renegotiation. These should be controlled by the MNP 10 code only. */
    if (v42_running_mnp10)
    num = 0;

    /* Which ATO command */
    switch (num)
    {
    case 0 :
        if (on_line_command)
        {
        /* Build CONNECT event and cleanup after parse state */
        parse_return_online();

        return; /* Do not fall through and reconfigure the
            system. It is done by the return online function */
        }
        else
        {
        if (sr14.originate_flag)
            build_event(E_ORIG,NO_DIAL);
        else
            build_event(E_ANSW,UNUSED);
        }
        break;

    case 3:
        /* If V.32bis operation is not enabled then need to
        return error if trying to issue a rate renegotiation. */
        if ((v32bis_enable == 0) &&
           (modem_mode != V34 && modem_mode != V34_ASYMETRIC))
        {
        error_occurred = TRUE;
        return;
        }

        /* Intentionally fall through */

    case 1:
        if (on_line_command)
        {
        if (num == 1)
            modem_retrain();
        else /* num == 3 */
            modem_renegotiate();
        st_parse.state = CMD7; 
        timer1 = 1500;      /* Retrain to complete delay time */

        return; /* Do not fall through and reconfigure the
            system yet. It is done after the
            parse_to_online_retain state */
        }
        else
        if (sr14.originate_flag)
            build_event(E_ORIG,NO_DIAL);
        else
            build_event(E_ANSW,UNUSED);
        break;

    default: error_occurred = TRUE;
        return;
    }

    send_ok = FALSE;
    on_line_command = FALSE;

    system_reconfigure();
    autobaud_off();
}

#else


   /* Update the modem's possible rates in case they have changed while in
      on line command mode */
   update_modem_rate_seq();

   /* If running MNP 10 do not allow the ACU to force a retrain or rate
      renegotiation. These should be controlled by the MNP 10 code only. */
   if (v42_running_mnp10)
      num = 0;

   /* Which ATO command */
   switch (num)
   {
      case 0:
     if (on_line_command)
     {
        /* Build CONNECT event and cleanup after parse state */
        parse_return_online();

        return; /* Do not fall through and reconfigure the
             system. It is done by the return online function */
     }
     else
     {
        /* Originate w/out dialing */
        if (sr14.originate_flag)
           build_event(E_ORIG,NO_DIAL);
        else
           build_event(E_ANSW,UNUSED);
     }
     break;
      
       case 3:
     /* If V.32bis operation is not enabled then need to
        return error if trying to issue a rate renegotiation. */
     /* V.34 allows RRNS too */
     if ((v32bis_enable == 0) &&
        (modem_mode != V34 && modem_mode != V34_ASYMETRIC))
     {
        error_occurred = TRUE;
        return;
     }

     /* Intentionally fall through */
    
      case 1:
     if (on_line_command)
     {
        /* Execute retrain */
        if (num == 1)
           modem_retrain();
        else /* num == 3 */
           modem_renegotiate();

        timer1 = 1500;    /* Retrain to complete delay time */

        /* Move the parse state to wait for retrain to complete,
           then issue the CONNECT from the parse state */
        st_parse.state = CMD7;     

        return; /* Do not fall through and reconfigure the system yet.
            It is done after the parse_to_online_retain state */
     }
     else if (sr14.originate_flag) 
        build_event(E_ORIG,NO_DIAL);
     else
        build_event(E_ANSW,UNUSED);
     break;

      default:
     error_occurred = TRUE;
     return;
   }

   send_ok = FALSE;
   on_line_command = FALSE;

   system_reconfigure();
   autobaud_off();
}

#endif

/*******************************************************************************
/
/     Routine:       at_P
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects pulse dialing.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.pulse
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_P(void)
{
   sr14.pulse = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_Q
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the result code display option
/
/                    ATQ   0 - Result codes enabled
/                          1 - Result codes disabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.disable_result_code, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_Q(ubyte *param_ptr)
{
   if (voice_cmd_set == TIA_IS_101)
   {
      return;
   }

   if (*param_ptr == 0)
      sr14.disable_result_code = FALSE;
   else if (*param_ptr == 1)
      sr14.disable_result_code = TRUE;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_S
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:  This Routine selects a register for next read or write
/                    operation. It will allow any value to be selected even
/                    if the register does not exist.
/
/                    ATS   0 - 27,30,37,63,91,95...
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  current_register
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_S(ubyte *param_ptr)
{
   current_register = *param_ptr;
}

/*******************************************************************************
/
/     Routine:       at_equal
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine will change the selected register value.
/
/                    ATS   0 - 27,30,37,63,91,108,109,110...
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  current_register
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_equal(ulong *param_ptr)
{
   ubyte num;

   /* Can't set some S-Regs in Voice mode */
     if((*param_ptr) && (current_register))
     {              
        if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101) &&
         ((current_register == 0) || (current_register == 10)))
        {
         error_occurred = TRUE;
      return;
        }
     }
   if ((current_register == 19) || (current_register == 20))
   {
      error_occurred = TRUE;
      return;
   }

/* change 63 to 33(sleep timer) */        
   if ((current_register > 27) && (current_register != 30) &&
      (current_register != 37) && (current_register != 33) &&
      (current_register != 91) && (current_register != 92) &&
      (current_register != 108) && (current_register != 109) &&
      (current_register != 110) && 
      (!((current_register >= 112) && (current_register <= 118))))
   {
      error_occurred = TRUE;
      return;
   }

   num = (ubyte)*param_ptr;

   if (error_occurred == TRUE)
   {
      /* If value is greater than 255, and register is bit mapped then
     return error. Else set value entered to 255 */
      if ((current_register == 14) || (current_register == 16) ||
     (current_register == 21) || (current_register == 22) ||
     (current_register == 23) || (current_register == 27))
      {
     return;
      }
      else
      {
     num = 255;
     error_occurred = FALSE;
      }
   }

   /* Else check the range of the input value */
   chk_sreg_range(num);

   if ((current_register == 7) || (current_register == 9) || (current_register == 10) ||
      (current_register == 63) || (current_register == 91) || (current_register == 108))
   {
      if (sr27.leased_line == TRUE)
      {
     modem_set_parameters(s[9],s[7],255,v32_retrain,s[63],
        receive_threshold,s[108]);
     modem_speaker(OFF);
      }
      else
     modem_set_parameters(s[9],s[7],s[10],v32_retrain,s[91],
        receive_threshold,s[108]);
   }

   /* Need to turn on or turn off the auto-answer LED depending upon the
      value of s[0]. */
   if (current_register == 0)
   {
      if (num > 0)
     modem_aa_led(ON);
      else
     modem_aa_led(OFF);
   }
}


/*******************************************************************************
/
/     Routine:       chk_sreg_range
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine checks the input value against the accepted
/                    ranges for the selected S register.
/
/     Input Parameters: ubyte num - value to be checked
/
/     Output Parameters: none
/
/     Global Variables Changed:  selected register
/
/     Users:   at_equal
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void chk_sreg_range(ulong num)
{
   ulong count,i;


    switch (current_register) 
    { /*SLei added*/
        case 0:
        case 6:
        case 7:
        case 8:
        case 10:
        case 11:
        case 91:
        case 92:
            CountryDependSRegRangeCheck( (ubyte)num); 
            break;
        default:
    count = s_range[current_register][0];
       i=1;
/* IAR compiler error  - */

    if (count == 0)
       {
       error_occurred = TRUE;
    return;
       }

       i=1;
    while (count != 0)
       {
       if ((s_range[current_register][i++] <= num) &&
       (num <= s_range[current_register][i++]))
          {
          *srptr[current_register] = (ubyte)num;
       return;
          }
       count--;
       }

    /* If value entered is greater then maximum allowed value need to set the
          S register to the max value   */
    i--;
       if (num > s_range[current_register][i])
       *srptr[current_register] = s_range[current_register][i];

       /* If value entered is less then minimum allowed value need to set the
       S register to the min value   */
       if (num < s_range[current_register][1])
       *srptr[current_register] = s_range[current_register][1];
    }
}


/*******************************************************************************
/
/     Routine:       at_quest
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine reads the selected register and will
/                    display it to the user.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  none
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_quest(void)
{
   ubyte *string;

   /* If register selected is not inplimented then return 000 to the terminal */
/* change 63 to 33(sleep timer), s63 not in use */        
   if ((current_register > 27) && (current_register != 30) &&
      (current_register != 37) && (current_register != 33) &&
      (current_register != 91) && (current_register != 92) &&
      (current_register != 108) && (current_register != 109) &&
      (current_register != 110) && (current_register != 112) &&
      (!((current_register >= 112) && (current_register <= 118))))
      string = d_to_a(0);
   else
      string = d_to_a(*srptr[current_register]);

   output_info(string,(ubyte)sr14.verbose_form);
}


/*******************************************************************************
/
/     Routine:       at_T
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects tone dialing.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.pulse
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_T(void)
{
   sr14.pulse = FALSE;
}

/*******************************************************************************
/
/     Routine:       at_V
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the result code format.
/
/                    ATV   0 - Displayed in numeric form
/                          1 - Displayed in verbose form
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.verbose_form, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
extern ubyte numeric_response;
void at_V(ubyte *param_ptr)
{
   switch (*param_ptr)
   {
      case 0:
     sr14.verbose_form = FALSE;
            numeric_response = FALSE; 
     break;

      case 1:
     sr14.verbose_form = TRUE;
            numeric_response = TRUE;
     break;

      default:
     error_occurred = TRUE;
     return;
   }
}

/*******************************************************************************
/
/     Routine:       at_W
/
/     Author:        RSA
/
/     Creation Date: 07/17/91
/
/     Description:   This Routine will determine the modems connect message
/
*******************************************************************************/
void at_W(ubyte *param_ptr)
{
    if (*param_ptr <= 4)
      atW = *param_ptr;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_X
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects tone detection options and the
/                    associated result codes.
/
/                    ATX   0 - Result codes 0-4 enabled. Busy and dial tone
/                              detect disabled
/                          1 - Result codes 0-4,10 enabled. Busy and dial tone
/                              detect disabled
/                          2 - Result codes 0-6,10 enabled. Busy detect disabled
/                              dial tone detect enabled
/                          3 - Result codes 0-5,7,10 enabled. Busy detect enabled
/                              dial tone detect disabled
/                          4 - Result codes 0-7,10 enabled. Busy and dial tone
/                              detect enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.busy_enable, sr22.dialtone_enable,
/               sr22.enable_result5, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_X(ubyte *param_ptr)
{
#if 0                
    if (voice_cmd_set == TIA_IS_101)
    {
    return;
    }
#endif

   /* What is the AT command input? */
   switch (*param_ptr)
   {
      case 0:
     sr22.busy_enable = FALSE;
     sr22.dialtone_enable = FALSE;
     sr22.enable_result5 = FALSE;
     break;

      case 1:
     sr22.busy_enable = FALSE;
     sr22.dialtone_enable = FALSE;
     sr22.enable_result5 = TRUE;
     break;

      case 2:
     sr22.busy_enable = FALSE;
     sr22.dialtone_enable = TRUE;
     sr22.enable_result5 = TRUE;
     break;

      case 3:
     sr22.busy_enable = TRUE;
     sr22.dialtone_enable = FALSE;
     sr22.enable_result5 = TRUE;
     break;
      
      case 4:
     sr22.busy_enable = TRUE;
     sr22.dialtone_enable = TRUE;
     sr22.enable_result5 = TRUE;
     break;

      default:
     error_occurred = TRUE;
     return;
   }

   valueX = *param_ptr;
}

/*******************************************************************************
/
/     Routine:       at_Y
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine sets long space disconnect option
/
/                    ATY   0 - Disable long space disconnect
/                          1 - Enable long space disconnect
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr21.long_space_discon, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_Y(ubyte *param_ptr)
{
   /* Verify input bounds */
   if (*param_ptr == 0)
      sr21.long_space_discon = FALSE;
   else if (*param_ptr == 1)
      sr21.long_space_discon = TRUE;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_Z
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine recalls stored profile
/
/                    ATZ   0 - Recall stored profile 0
/                          1 - Recall stored profile 1
/                          2 - Recall stored profile 2
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
extern ubyte ext_DspMemErrorFlag;        
extern void  auto_config_ms(void); 
extern uword modem_eeprom_checksum(void);

void at_Z(ubyte *param_ptr)
{
   ubyte value;
   uword val;

   /* Profile ZERO counts */
   if (*param_ptr < NUMBER_OF_PROFILES)
   {


#if TIES_HAYES_ESCAPE                   

    /* If a test is currently running then need to terminate it, for at&t1, +++, at, atz */
    if (test_in_progress )
    {
/*            test_in_progress = FALSE;   */

/* should return OK after terminating test */
        /*build_event(E_HANGUP,NONE);*/    
                build_event(E_HANGUP,OK);  
    }
    /* If modem is online, need to hangup the connection */
    if (!hook || on_line_command || ( ties_esc_state == ESC_DONE ))
    {
        if ( dte_mode != ACU )
        {
        if ( !on_line_command )
        {
            send_ok = TRUE;
            ties_esc_state = 'H';
            error_occurred = TRUE;
            dte_mode = ACU;
        }
        }
        hangup_connection(NONE);

        user_initiated_hangup = TRUE;
        at_z_command = TRUE;
        at_h_command = TRUE;
    }
#else
      /* If a test is currently running then need to terminate it */
      if (test_in_progress)
/* should return OK after terminating test */
        build_event(E_HANGUP,OK);                      

      /* If modem is online, need to hangup the connection */
      if (!hook || on_line_command)
      {
     build_event(E_HANGUP,OK);
     user_initiated_hangup = TRUE;
     at_z_command = TRUE;
      }

#endif 

#if INTERNATIONAL_CODE == 1      
         set_loc_line_relay(ON_HOOK);
         set_safe1_en_relay(ACTIVATE);    /* mh103197 output = HI */
            set_shunt_relay(ACTIVATE);
             shunt_timer_en=0;
            in_pulse_dial = 0;
#else
         set_safe1_en_relay(ACTIVATE);    /* mh103197 output = HI */
#endif

        if (Default_Country == 0xFF) {
           modem_read_data(COUNTRY_CODE,COUNTRY_CODE_SIZE,&CountryInfo);
      
         if(CountryInfo > MAX_COUNTRY_CODE )  {
                CountryInfo = 0;

              modem_write_data(COUNTRY_CODE,COUNTRY_CODE_SIZE,&CountryInfo);

/* write back the checksum */
            val = modem_eeprom_checksum();

                value = val;
            modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,&value);
            
                value = val >> 8;
            modem_write_data( (CHECKSUM_ADDR+1),CHECKSUM_SIZE,&value);
         }

        }
        else {
            CountryInfo = Default_Country;
        }

    acu_load_defaults(AT_Z_COMMAND);

    retrieve_profile(*param_ptr,COMMAND);
          operating_mode = slN; 

    }
    else
    error_occurred = TRUE;

/* if ext dsp ram does not exist, autoconfig ms paras */
   auto_config_ms(); 
}

void plus_ms(ubyte *param_ptr)
{
    ubyte data,count;
    ulong data1=0;

    data = *param_ptr;

    count = 0;

    if ((data == 'V') || 
       ((*param_ptr == 'X') && (*(param_ptr+1) == '2') && 
       (*(param_ptr+2) == ',')))
    {
        if (data == 'V')
        {
           param_ptr++;
           /* don't accept VX2 -- Lowercase 'x' allows rejection of VX2 */   
           if ((*param_ptr == 'X') && (*(param_ptr+1) == '2') && 
              (*(param_ptr+2) == ','))
              *param_ptr = 'x';
         }     

        while (*param_ptr != ',')
        {

            data1 = data1 << 8;
            data1 |= *param_ptr;
            param_ptr++;
            count ++;
            if(count >= 4)
                break;
        }

/*mod mode*/
        switch (data1)
         {
#if MODEM_V90_MODE == 1
            case '90':
                    ms_mode = V90;
                    v34_bis_mode = 1;
                     break;
#endif
         
#if (DSP_SERIES == 408)         
#if MODEM_X2_MODE == 1
            case 'X2':
                    ms_mode = VX2;
                    v34_bis_mode = 1;
                break;
#endif
#endif
            case '34B':
                    ms_mode = V34;
                    v34_bis_mode = 1;
                break;

            case '34BS':
                    ms_mode = V34S;
                    v34_bis_mode = 1;

                break;

            case '34S':
                    ms_mode = V34S;
                    v34_bis_mode = 0;
                break;


            case '34':
                    ms_mode = V34;
                    v34_bis_mode = 0;

                break;

            case '32B':
                    ms_mode = V32BIS;
                    v34_bis_mode = 0;
                break;

            case '32':
                    ms_mode = V32;
                    v34_bis_mode = 0;
                break;

            case '22B':
                    ms_mode = V22BIS;
                    v34_bis_mode = 0;
            break;

            case '22':
                    ms_mode = V22;
                    v34_bis_mode = 0;

                break;

            case '23C':
                    ms_mode = V23_ADX;
                    v34_bis_mode = 0;

                break;

            case '21':
                    ms_mode = V21;
                    v34_bis_mode = 0;
                break;


            default: error_occurred = TRUE;
                        v34_bis_mode = 0;
                break;


          }


        param_ptr++;
        data1 = 0;
        count = 0;
/*auto mode */

        while (*param_ptr != ',')
        {
            count ++;
            data1 = data1 << 8;
            data1 |= *param_ptr;
            param_ptr++;

            if (count >= 2)
                break;

        }

        switch (data1)

         {
            case '0':

                N = 0;
                automode = 0;

#if MODEM_X2_MODE == 1
                if ((ms_mode == VX2)||(ms_mode == V90))
                    automode = 2;
                else
#endif
                if ((ms_mode == V34)|| (ms_mode == V34S))
                    automode = 2;
                break;

            case '1':

                N = 1;
                automode = 1;
#if MODEM_X2_MODE == 1
                if ((ms_mode == VX2)||(ms_mode == V90))
                    automode = 3;
                else
#endif
                if ((ms_mode == V34)|| (ms_mode == V34S))
                    automode = 3;

                break;

            default: error_occurred = TRUE;
                return;

         }

        param_ptr++;
        data1=0;
        count = 0;

        while (*param_ptr != ',')
        {
            count ++;
            if(count <=4 )
            {
                data1 = data1 << 8;
                data1 |= *param_ptr;
            }
                param_ptr++;

            if (count >= 6)
                break;

        }

/*min speed */

        switch (data1)

         {

            case '0':
            case '300':
/* #if MODEM_X2_MODE == 1
                ms_min_rate = BPS300;
                ms_min_speed = BPS33333MIN;
#else */
                ms_min_rate = BPS300;
                ms_min_speed = BPS2400MIN;
/* #endif */
                break;

            case '1200':

                if( count == 5)
                {
                    ms_min_rate = BPS12000;
                    ms_min_speed = BPS12000MIN;
                }
                else

                {
                    ms_min_rate = BPS1200;
                    ms_min_speed = BPS2400MIN;
                }
                break;


            case '2400':
                if (count == 5)
                {
                    ms_min_rate = BPS24000;
                    ms_min_speed = BPS24000MIN;
                }
                else
                {
                    ms_min_rate = BPS2400;
                    ms_min_speed = BPS2400MIN;
                }
                break;

            case '4800':
#if MODEM_X2_MODE == 1
                if (count == 5)
                {
                    ms_min_rate = BPS48000;
                    ms_min_speed = BPS48000MIN;
                }
                else
#endif
                {
                    ms_min_rate = BPS4800;
                    ms_min_speed = BPS4800MIN;
                }

                break;

            case '7200':
                ms_min_rate = BPS7200;
                ms_min_speed = BPS7200MIN;

                break;

            case '9600':
                ms_min_rate = BPS9600;
                ms_min_speed = BPS9600MIN;

                break;


            case '1440':
                if(count == 5)
                {
                    ms_min_rate = BPS14400;
                    ms_min_speed = BPS14400MIN;
                }
                else
                    error_occurred = TRUE;

                break;

            case '1680':
                if(count == 5)
                {
                    ms_min_rate = BPS16800;
                    ms_min_speed = BPS16800MIN;
                }
                else
                    error_occurred = TRUE;

                break;

            case '1920':
                if(count == 5)
                {
                    ms_min_rate = BPS19200;
                    ms_min_speed = BPS19200MIN;
                }
                else
                    error_occurred = TRUE;

                break;

            case '2160':
                if(count == 5)
                {
                    ms_min_rate = BPS21600;
                    ms_min_speed = BPS21600MIN;
                }
                else
                    error_occurred = TRUE;

                break;


            case '2640':

                if(count == 5)
                {
                    ms_min_rate = BPS26400;
                    ms_min_speed = BPS26400MIN;
                }
                else
                    error_occurred = TRUE;

                break;

            case '2880':

                if(count == 5)
                {
                    ms_min_rate = BPS28800;
                    ms_min_speed = BPS28800MIN;
                }
                else
                    error_occurred = TRUE;

                break;

            case '3120':

                if(count == 5)
                {
                    ms_min_rate = BPS31200;
                    ms_min_speed = BPS31200MIN;
                }
                else
                    error_occurred = TRUE;


                break;


            case '3360':
                if(count == 5)
                {
                    ms_min_rate = BPS33600;
                    ms_min_speed = BPS33600MIN;
                }
                else
                    error_occurred = TRUE;

                break;
#if MODEM_X2_MODE == 1
            case '3333':
                if(count == 5)
                {
                    ms_min_rate = BPS33333;
                    ms_min_speed = BPS33333MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '3733':
                if(count == 5)
                {
                    ms_min_rate = BPS37333;
                    ms_min_speed = BPS37333MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '4133':
                if(count == 5)
                {
                    ms_min_rate = BPS41333;
                    ms_min_speed = BPS41333MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '4266':
                if(count == 5)
                {
                    ms_min_rate = BPS42666;
                    ms_min_speed = BPS42666MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '4400':
                if(count == 5)
                {
                    ms_min_rate = BPS44000;
                    ms_min_speed = BPS44000MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '4533':
                if(count == 5)
                {
                    ms_min_rate = BPS45333;
                    ms_min_speed = BPS45333MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '4666':
                if(count == 5)
                {
                    ms_min_rate = BPS46666;
                    ms_min_speed = BPS46666MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '4933':
                if(count == 5)
                {
                    ms_min_rate = BPS49333;
                    ms_min_speed = BPS49333MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '5066':
                if(count == 5)
                {
                    ms_min_rate = BPS50666;
                    ms_min_speed = BPS50666MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '5200':
                if(count == 5)
                {
                    ms_min_rate = BPS52000;
                    ms_min_speed = BPS52000MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '5333':
                if(count == 5)
                {
                    ms_min_rate = BPS53333;
                    ms_min_speed = BPS53333MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '5466':
                if(count == 5)
                {
                    ms_min_rate = BPS54666;
                    ms_min_speed = BPS54666MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '5600':
                if(count == 5)
                {
                    ms_min_rate = BPS56000;
                    ms_min_speed = BPS56000MIN;
                }
                else
                    error_occurred = TRUE;
                break;
            case '5733':
                if(count == 5)
                {
                    ms_min_rate = BPS57333;
                    ms_min_speed = BPS57333MIN;
                }
                else
                    error_occurred = TRUE;
                break;
#endif
            default: error_occurred = TRUE;
                return;
          }

        param_ptr++;
        data1=0;
        count=0;

        while ((*param_ptr != NULL) && (*param_ptr >= 0x30) && (*param_ptr <= 0x39))
        {
            count ++;
            if(count <=4 )
            {
                data1 = data1 << 8;
                data1 |= *param_ptr;
            }
                param_ptr++;

            if (count >= 6)
                break;
        }
/*max speed */

        switch (data1)
         {
            case '300':
                s[37] = S37_300_BPS;
                break;

            case '1200':
                if (count == 5)
                    s[37] = S37_12000_BPS;
                else
                    s[37] = S37_1200_BPS;
                break;

            case '2400':
                if (count == 5)
                    s[37] = S37_24000_BPS;
                else
                    s[37] = S37_2400_BPS;
                break;

            case '4800':
#if MODEM_X2_MODE == 1
                if (count == 5)
                    s[37] = S37_48000_BPS;
                else
#endif
                    s[37] = S37_4800_BPS;
                break;

            case '7200':
                s[37] = S37_7200_BPS;
                break;

            case '9600':
                s[37] = S37_9600_BPS;
                break;

            case '1440':
                if(count == 5)
                {
                    s[37] = S37_14400_BPS;
                }
                else
                     error_occurred = TRUE;

                break;

            case '1680':
                if(count == 5)
                {
                    s[37] = S37_16800_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '1920':
                if(count == 5)
                {
                    s[37] = S37_19200_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '2160':
                if(count == 5)
                {
                    s[37] = S37_21600_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '2640':
                if(count == 5)
                {
                    s[37] = S37_26400_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '2880':
                if(count == 5)
                {
                    s[37] = S37_28800_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '3120':
                if(count == 5)
                {
                    s[37] = S37_31200_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '3360':
                if(count == 5)
                {
                    s[37] = S37_33600_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

#if MODEM_X2_MODE == 1
            case '3333':
                if(count == 5)
                {
                    s[37] = S37_33333_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '3733':
                if(count == 5)
                {
                    s[37] = S37_37333_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '4133':
                if(count == 5)
                {
                    s[37] = S37_41333_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '4266':
                if(count == 5)
                {
                    s[37] = S37_42666_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '4400':
                if(count == 5)
                {
                    s[37] = S37_44000_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '4533':
                if(count == 5)
                {
                    s[37] = S37_45333_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '4666':
                if(count == 5)
                {
                    s[37] = S37_46666_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '4933':
                if(count == 5)
                {
                    s[37] = S37_49333_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '5066':
                if(count == 5)
                {
                    s[37] = S37_50666_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '5200':
                if(count == 5)
                {
                    s[37] = S37_52000_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '5333':
                if(count == 5)
                {
                    s[37] = S37_53333_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '5466':
                if(count == 5)
                {
                    s[37] = S37_54666_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '5600':
                if(count == 5)
                {
                    s[37] = S37_56000_BPS;
                }
                else
                    error_occurred = TRUE;
                break;

            case '5733':
                if(count == 5)
                {
                    s[37] = S37_57333_BPS;
                }
                else
                    error_occurred = TRUE;
                break;
#endif

            case '0':
                    s[37] = 0;
                break;

            default: error_occurred = TRUE;
                return;
          }
    }
    else
    error_occurred = TRUE;
}

void plus_ms_q(void);

void plus_ms_q(void)
{
   ubyte  string[20], i; /*fix garbage after the string problem */

    for (i=0 ; i < 20 ; i++)
      {
        string[i] = 0;
      }

   switch(ms_mode)
   {
#if MODEM_V90_MODE == 1
        case  V90:
       strcpy((char *) string, "V90");
      break;
#endif

#if MODEM_X2_MODE == 1
     case  VX2:
       strcpy((char *) string,VX2_MODE);
      break;
#endif
     case  V34:
      if(v34_bis_mode == 1)  strcpy((char *) string,V34B_MODE);
      else                   strcpy((char *) string,V34_MODE);
      break;

     case  V34S:
      if(v34_bis_mode == 1)  strcpy((char *) string,V34B_MODE);
      else                   strcpy((char *) string,V34_MODE);
      break;

     case  V32BIS:
      strcpy((char *) string,V32BIS_MODE);
      break;

     case  V32:
      strcpy((char *) string,V32_MODE);
      break;

     case  V22BIS:
      strcpy((char *) string,V22BIS_MODE);
      break;

     case  V22:
      strcpy((char *) string,V22_MODE);
      break;

     case  V23_ADX:
      strcpy((char *) string,V23_MODE);
      break;

     case  V21:
      strcpy((char *) string,V21_MODE);
      break;

     default:
      strcpy((char *) string,"V?");
      break;
   }

   strcat((char *) string,",");

   switch(N)
   {
     case 0:
     strcat((char *) string,"0,");
     break;

     case 1:
     strcat((char *) string,"1,");
     break;

     default:
     strcat((char *) string,"?,");
     break;
   }


   switch(ms_min_rate)
   {
      case BPS300:
      strcat((char *)string,"300,");
      break;

      case BPS1200:
      strcat((char *)string,"1200,");
      break;

      case BPS12000:
      strcat((char *)string,"12000,");
      break;

      case BPS2400:
      strcat((char *)string,"2400,");
      break;

      case BPS24000:
      strcat((char *)string,"24000,");
      break;

      case BPS4800:
      strcat((char *)string,"4800,");
      break;

      case BPS7200:
      strcat((char *)string,"7200,");
      break;

      case BPS9600:
      strcat((char *)string,"9600,");
      break;

      case BPS14400:
      strcat((char *)string,"14400,");
      break;

      case BPS16800:
      strcat((char *)string,"16800,");
      break;

      case BPS19200:
      strcat((char *)string,"19200,");
      break;

      case BPS21600:
      strcat((char *)string,"21600,");
      break;

      case BPS26400:
      strcat((char *)string,"26400,");
      break;

      case BPS28800:
      strcat((char *)string,"28800,");
      break;

      case BPS31200:
      strcat((char *)string,"31200,");
      break;

      case BPS33600:
      strcat((char *)string,"33600,");
      break;
#if MODEM_X2_MODE == 1
            case BPS33333:
        strcat((char *)string,"33333,");
                break;
            case BPS37333:
        strcat((char *)string,"37333,");
                break;
            case BPS41333:
        strcat((char *)string,"41333,");
                break;
            case BPS42666:
        strcat((char *)string,"42666,");
                break;
            case BPS44000:
        strcat((char *)string,"44000,");
                break;
            case BPS45333:
        strcat((char *)string,"45333,");
                break;
            case BPS46666:
        strcat((char *)string,"46666,");
                break;
            case BPS48000:
        strcat((char *)string,"48000,");
                break;
            case BPS49333:
        strcat((char *)string,"49333,");
                break;
            case BPS50666:
        strcat((char *)string,"50666,");
                break;
            case BPS52000:
        strcat((char *)string,"52000,");
                break;
            case BPS53333:
        strcat((char *)string,"53333,");
                break;
            case BPS54666:
        strcat((char *)string,"54666,");
                break;
            case BPS56000:
        strcat((char *)string,"56000,");
                break;
            case BPS57333:
        strcat((char *)string,"57333,");
                break;
#endif

      case 0:
      strcat((char *)string,"0,");
      break;

      default:
      strcat((char *)string,"?,");
      break;
   }

   switch(s[37])
   {
      case S37_300_BPS:
      strcat((char *)string,"300");
      break;

      case S37_1200_BPS:
      strcat((char *)string,"1200");
      break;

      case S37_12000_BPS:
      strcat((char *)string,"12000");
      break;

      case S37_2400_BPS:
      strcat((char *)string,"2400");
      break;

      case S37_24000_BPS:
      strcat((char *)string,"24000");
      break;

      case S37_4800_BPS:
      strcat((char *)string,"4800");
      break;

      case S37_7200_BPS:
      strcat((char *)string,"7200");
      break;

      case S37_9600_BPS:
      strcat((char *)string,"9600");
      break;

      case S37_14400_BPS:
      strcat((char *)string,"14400");
      break;

      case S37_16800_BPS:
      strcat((char *)string,"16800");
      break;

      case S37_19200_BPS:
      strcat((char *)string,"19200");
      break;

      case S37_21600_BPS:
      strcat((char *)string,"21600");
      break;

      case S37_26400_BPS:
      strcat((char *)string,"26400");
      break;

      case S37_28800_BPS:
      strcat((char *)string,"28800");
      break;

      case S37_31200_BPS:
      strcat((char *)string,"31200");
      break;

      case S37_33600_BPS:
      strcat((char *)string,"33600");
      break;
#if MODEM_X2_MODE == 1
            case S37_33333_BPS:
        strcat((char *)string,"33333,");
                break;
            case S37_37333_BPS:
        strcat((char *)string,"37333,");
                break;
            case S37_41333_BPS:
        strcat((char *)string,"41333,");
                break;
            case S37_42666_BPS:
        strcat((char *)string,"42666,");
                break;
            case S37_44000_BPS:
        strcat((char *)string,"44000,");
                break;
            case S37_45333_BPS:
        strcat((char *)string,"45333,");
                break;
            case S37_46666_BPS:
        strcat((char *)string,"46666,");
                break;
            case S37_48000_BPS:
        strcat((char *)string,"48000,");
                break;
            case S37_49333_BPS:
        strcat((char *)string,"49333,");
                break;
            case S37_50666_BPS:
        strcat((char *)string,"50666,");
                break;
            case S37_52000_BPS:
        strcat((char *)string,"52000,");
                break;
            case S37_53333_BPS:
        strcat((char *)string,"53333,");
                break;
            case S37_54666_BPS:
        strcat((char *)string,"54666,");
                break;
            case S37_56000_BPS:
        strcat((char *)string,"56000,");
                break;
            case S37_57333_BPS:
        strcat((char *)string,"57333,");
                break;
#endif

      case 0:
      strcat((char *)string,"0");
      break;

      default:
      strcat((char *)string,"?");
      break;
   }
   output_info( string,(ubyte)sr14.verbose_form);

}

/*******************************************************************************
/
/     Routine:       at_comma
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to pause for the time specified
/                    by s8.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  timer1
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author &       Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_comma(void)
{
   /* Start delay timer */
   timer1 = (dial_pause_time * 100);

   /* Change parse states to time the delay in the BG */
   st_parse.state = CMD6;  /* Parse command delay */
}

void bang_P_q(void);
void bang_P_eq(void);
void bang_P_e(ubyte *parm_ptr);

/* at!p?, band_P_q, command */
void bang_P_q(void)
{
    ubyte i,j,k, *ptr, str[16], pnp[4];

/*   read 4 pnp bytes from NVRAM */
       modem_read_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

       k=0;
       for(i=0; i<4; i++)
       {
/* convert num to ascii, put into pt[] */
         ptr = d_to_a(pnp[i]);             /* ptr =&pt[0] */

/* put pt[0],pt[1],pt[2] into pnp string */
         for(j=0; j<3; j++)
             str[k++] = *ptr++;
         str[k++] = ',';
       }
       str[--k] = 0;         /*1st decrease, then assign val, pnp[16]=0 */
       output_info(str,(ubyte)sr14.verbose_form);
}

/* at!p=? (0-255),(0-255),(0-255) command, see ac00pro.h */
void bang_P_eq(void)
{
    output_info((ubyte *)BANG_P_QUERY_INFO,(ubyte)sr14.verbose_form);
}

/* Command format ex: at!p=100,101,102,103 CR or at!p=100,,,200CR */
/* 4 fields to parse, serial #, bytes 0,1,2,3, */
void bang_P_e(ubyte *parm_ptr)
{

/*changed the check sum to 16 bit*/
    ubyte  field, value,cksum, i, pnp[4];
    uword  val;

/* get pnp vender id from NVRAM */
    modem_read_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

    for (i=0; i< 5; i++)
    {
        field = *parm_ptr++;
        value = *parm_ptr++;

        switch (field)
        {
          case 0:
/* saved values */
            modem_write_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

/* should take care of eeprom checksum */
/*changed the check sum to 16 bit*/

#if 0
            value = modem_eeprom_checksum();
            modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,&value);
#endif

                cksum = CHECKSUM_ADDR;
            val = modem_eeprom_checksum();
                value = val;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);
            
                cksum = CHECKSUM_ADDR +1;
                value = val >> 8;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

           return ;

        case 1:
             pnp[0] = value;
             break;
/* If field 1 is present,save it into pnp[0], and so on */

        case 2:
             pnp[1] = value;
             break;

        case 3:
             pnp[2] = value;
             break;

        case 4:
             pnp[3] = value;
             break;

        default:
             error_occurred = TRUE;
             return;
/* If more than 4 parameters for the command, means an error */
        }  /* switch on parameter field */
    } /* for */
    error_occurred = TRUE;
}

void bang_C_e(ubyte *parm_ptr);
void  bangC_pkt_to_from_dsp (ubyte read_dsp_mb[]);
ubyte *d_to_hex(ubyte num);

/* max 40 fields to parse */
#define PACKET_LEN_BYTE            40
/* max 20 bytes of DSP RESPONSE LENGTH */
#define DSP_RESP_LENGTH            20

void bang_C_e(ubyte *parm_ptr)
{
    ubyte  field, value, i;
    ubyte  j, k, *ptr, str[DSP_RESP_LENGTH*3];
    ubyte  dsp_response_data[DSP_RESP_LENGTH];


    for (i=0; i <= PACKET_LEN_BYTE; i++)
    {
        field = *parm_ptr++;
        value = *parm_ptr++;

        if (field)
            current_command [i] = value;
        else
/* end of cmd string*/
        {
            if (i < 4)
               {
                  error_occurred = TRUE;
                  return;
               }
            else

/* action here */
               {

                  bangC_pkt_to_from_dsp(dsp_response_data);

                  k=0;
                  for(i = 0; i < dsp_response_data[2] + 4; i++)
                  {
/* convert num to hex display, put into pt[] */
                     ptr = d_to_hex(dsp_response_data[i]);    /* ptr =&pt[0] */

/* put pt[0],pt[1] into str[] */
                     for(j=0; j<2; j++)
                     str[k++] = *ptr++;
                     str[k++] = ',';
                  }

                  str[--k] = 0;         /*1st decrease, then assign val, pnp[16]=0 */

                  output_info(str,(ubyte)sr14.verbose_form);
                  return ;
               }
         }
    } /* for */
    error_occurred = TRUE;
}

extern ubyte dsp_timer;
extern void process_wait (void);
extern ubyte cp_dsp (void);
#define DSP_TIMEOUT       100    /* waiting for DSP to READ or WRITE */
#define DSP_DONE            1

void  bangC_pkt_to_from_dsp (ubyte read_dsp_mb[])
{

   ubyte i, *temp;

   dsp_timer = DSP_TIMEOUT;
   while ( dsp_timer )
   {
       process_wait();

      if( cp_dsp() == DSP_DONE )
         break;
   }

   /* Did we have trouble */
   if( !dsp_timer )
    {
        mt_driver_error_handler(current_command[0]);
    }

/* done with sending packet, now try to get dsp packet back */

   dsp_timer = DSP_TIMEOUT;
   temp = (ubyte *)(COM_RAM + DSP_CP_CMD_START);

   while ( dsp_timer )
   {
       process_wait();

     if( *temp != 0x00)
         break;
   }

        for (i = 0 ; i < 4 ; i++)
        read_dsp_mb [i] = *temp++;

          /*if packet_length is > zero then the data should follow */

        if (read_dsp_mb [2] > 0)
          {
               for (i = 4 ; i < read_dsp_mb[2] + 4; i++)
                    read_dsp_mb [i] = *temp++;
           }

          /*write the semaphore*/
          temp = (ubyte *) (COM_RAM + DSP_CP_CMD_START);
          *temp = 00;

          return;

}



ubyte *d_to_hex(ubyte num)
{
    ubyte i = 2;

    do {
        i--;
        pt[i] = num % 16;
      if (pt[i] < 10)
        pt[i] = pt[i] + '0';
      else
        pt[i] = pt[i] - 10 + 'A';
        num = num / 16;
    } while (i != 0);

    pt[2] = 0;
    return ((ubyte *)&pt[0]);
}


/*******************************************************************************
/
/       Routine: at_W
/
/       Author:  RSA
/
/       Creation Date:  07/17/91
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed: str_WP
/
/       Users: execute_cmd()
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description:
/
*******************************************************************************/
void str_WP(ubyte *param_ptr)
{

    ubyte wait,*value,wait_val;


   if (*param_ptr <= 7)
    {
        value = (ubyte*)CSCR1;
        wait = *param_ptr << 4;
    wait_val = *value & 0x0f;
    *value = wait_val | wait;
    }
    else
      error_occurred = TRUE;    
    

}
/*******************************************************************************
/
/       Routine: at_W
/
/       Author:  RSA
/
/       Creation Date:  07/17/91
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed: str_WD
/
/       Users: execute_cmd()
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description:
/
*******************************************************************************/
void str_WD(ubyte *param_ptr)
{


    ubyte wait,*value,wait_val;


   if (*param_ptr <= 7)
    {
        value = (ubyte*)CSCR3;
        wait = *param_ptr << 4;
    wait_val = *value & 0x0f;
    *value = wait_val | wait;
    }
    else
      error_occurred = TRUE;    


}

/*******************************************************************************
/
/       Routine: at_serial_number_amd
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_serial_number_amd(ubyte *param_ptr)
{
    ubyte i=0;
    ubyte value,serial_1[9],cksum;
    ubyte *temp1;
   uword  val;


   if (*param_ptr == NULL)
   {  error_occurred = TRUE;    
      return;
   }

   for (i=0;i<8;i++)
    {
        serial_1[i] = 0x00;
    }

    temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0x7fff0);
    for(i=0;i<8;i++)
   {   
       if (*temp1 != 0x0ff)     
      {  error_occurred = TRUE;    
         return;
      }
      else
         temp1 +=1; 
 
   }
   
   while(*param_ptr == 0x30)
       param_ptr++;

   i=0;
    while (*param_ptr != NULL)
    {

      if ((*param_ptr < 0x30) || (*param_ptr > 0x39))
      {
            error_occurred = TRUE;    
            return;
      }

        if (i < 8)
            serial_1[i++] = *param_ptr;
        else
      {
         error_occurred = TRUE;    
         return;
        }

        ++param_ptr;
    }

    serial_1[8] = '\0';

   modem_write_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,serial_1);

                cksum = CHECKSUM_ADDR;
            val = modem_eeprom_checksum();
                value = val;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);
            
                cksum = CHECKSUM_ADDR +1;
                value = val >> 8;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

    temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);
    
    for(i=0;i<8;i++)
    {
           *temp1 = 0x00;
           temp1 += 1;
    }

    temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);
 
    for(i=0;i<8;i++)
    {
           *temp1 = serial_1[i];
           temp1 += 1;
    }

    write_serial_number_amd();
}

/*******************************************************************************
/
/       Routine: at_serial_q
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_serial_q(void)
{
    ubyte    *temp;
   ubyte i;
    ubyte str[10],str1[8];

   modem_read_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,str1);
    
    temp = (ubyte *) (SERIAL_NUMBER_LOCATION + 0x7fff0);
    for(i=0;i<8;i++)
    {  
       str[i] = *(temp+i);    
         
      if (str1[i] != str[i])
      {
        error_occurred = TRUE;    
        return;
      }

   }
   str[8] = '\0';
   output_info((ubyte *)str,VERBOSE_FORM);
}


/*******************************************************************************
/
/       Routine: at_serial_number_atmel
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_serial_number_atmel(ubyte *param_ptr)
{
    ubyte i=0;
    ubyte value,serial_1[9],cksum;
    ubyte *temp1;
   uword  val;

   if (*param_ptr == NULL)
   {  error_occurred = TRUE;    
      return;
   }

   for (i=0;i<8;i++)
    {
        serial_1[i] = 0x00;
    }

    temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0x7fff0);
    for(i=0;i<8;i++)
   {   
       if (*temp1 != 0x0ff)     
      {  error_occurred = TRUE;    
         return;
      }
      else
         temp1 +=1; 
 
   }
   
   while(*param_ptr == 0x30)
       param_ptr++;

   i=0;
    while (*param_ptr != NULL)
    {

      if ((*param_ptr < 0x30) || (*param_ptr > 0x39))
      {
            error_occurred = TRUE;    
            return;
      }

        if (i < 8)
            serial_1[i++] = *param_ptr;
        else
      {
         error_occurred = TRUE;    
         return;
        }

        ++param_ptr;
    }

    serial_1[8] = '\0';

   modem_write_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,serial_1);

                cksum = CHECKSUM_ADDR;
            val = modem_eeprom_checksum();
                value = val;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);
            
                cksum = CHECKSUM_ADDR +1;
                value = val >> 8;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

    temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);
    
    for(i=0;i<8;i++)
    {

           *temp1 = 0x00;
           temp1 += 1;
    }

    temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);
 
    for(i=0;i<8;i++)
    {

           *temp1 = serial_1[i];
           temp1 += 1;
    }

    write_serial_number_atmel();
}

/*******************************************************************************
/
/       Routine: at_amd
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_amd(void)
{
    uword i;
    output_info((ubyte *)"DOWNLOAD AMD FLASH BEGIN",VERBOSE_FORM); 
    for(i=0;i<65500;i++);
    for(i=0;i<65500;i++);

    main_dnld_flash_amd(); 
}

/*******************************************************************************
/
/       Routine: at_atmel
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_atmel(void)
{
    uword i;
    output_info((ubyte *)"DOWNLOAD ATMEL FLASH BEGIN",VERBOSE_FORM); 
    for(i=0;i<65500;i++);
    for(i=0;i<65500;i++);

    main_dnld_flash_atmel(); 
}

/*******************************************************************************
/
/       Routine: at*FID
/
/       Author:  RSA
/
/       Creation Date:  08/27/96
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed: 
/
/       Users: execute_cmd()
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description: dsp not resp. message
/
*******************************************************************************/
void str_FID(void)
{
    ubyte str1[9];

            output_send_cr_lf();
            output_info(d_to_a(dsp_packet_id_msg[0]),UNFORMATTED);
            dsp_packet_id_msg [0] = 0x00;

   modem_read_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,str1);

    str1[8] = '\0';
   output_info((ubyte *)str1,VERBOSE_FORM);
}


/*******************************************************************************
/
/       Routine: at!X= 65536(number of bytes to be transferred).
/
/       Author:  Fremont Modem
/
/       Creation Date:  08/13/97
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed: 
/
/       Users: host software that downloads x2_page.c
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description: 
/
*******************************************************************************/
#if DNLD_X2_FROM_HOST == 1
void bang_X_e(uword *parm_ptr)
{
   ulong addr_tmp1;
   uword i;
   uword data_tmp1;
   uword data_tmp2;
   uword b_count;
   uword x2_page_start_adrs;
   ubyte *string;
   ubyte dmy_mem_bank;
   ubyte *temp;
   ubyte acu_data_bits_tmp;
   ubyte acu_stop_bits_tmp;
   ubyte acu_parity_tmp;
   ubyte terminal_DTE_flowctrl_tmp;
   ubyte modem_DTE_flowctrl_tmp;

   dmy_mem_bank = *parm_ptr++;             /* skip the index byte */
   dmy_mem_bank = (*parm_ptr++) & 0x00ff ; /* get one word of data */

   /* num of words to be sent to DSP SRAM */
   *parm_ptr++;
   b_count = *parm_ptr++; 

   if(*parm_ptr++ != 03)  // This cmd has only three parameters.
   {
     string = (ubyte*) WRONG_PARM1;            
     output_info(string,STORED_NUM);
     ext_DspMemErrorFlag = READ_BACK_ALL_FFFF;
     acu_loop = FALSE;
     return;
   }
   else
   {
    x2_page_start_adrs =  *parm_ptr++;
   }

   acu_data_bits_tmp =            acu_data_bits;
   acu_stop_bits_tmp =            acu_stop_bits;
   acu_parity_tmp    =            acu_parity; 
   terminal_DTE_flowctrl_tmp =    terminal_DTE_flowctrl;
   modem_DTE_flowctrl_tmp    =    modem_DTE_flowctrl;

   acu_data_bits         =  8;
   acu_stop_bits         =  1;
   acu_parity            =  DISABLED;
   terminal_DTE_flowctrl =  CTS_RTS;
   modem_DTE_flowctrl    =  CTS_RTS;

   dte_init(dte_init_baud,acu_data_bits,acu_stop_bits,acu_parity,terminal_DTE_flowctrl,
   terminal_DTE_xon_char,terminal_DTE_xoff_char,
   modem_DTE_flowctrl,modem_DTE_xon_char,modem_DTE_xoff_char,
   pass_flowctrl,s[2],s[12],escape_mode);

#if (PATCHLESS_EXTERNAL == 0)
   dsp_cfg(ON);
#else
   dsp_cfg(OFF);
#endif

 //   data_tmp2 = dsp_peek2(WCON_REG, 0x0000);

  /* Download boot code into internal DSP RAM */
   ext_DspMemErrorFlag  = dnld_bootx_code(bootx_array);
// After boot code is downloaded, WCON is reset to 0xFFFF;

   if(ext_DspMemErrorFlag != 0) 
   {
      acu_loop = FALSE;
      return;
   }

   Change_PLL_Freqency(PLL_30MHz);  /* select 30.04 MHz */
   temp    = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);

  /* scan all 32K words of external SRAM */
   ext_DspMemErrorFlag |= dsp_ext_mem32k_test(dmy_mem_bank, B5CF_MappedTo_CS3);


   /* indicates if the external DSP SRAM exists */  
   if(ext_DspMemErrorFlag != 0)
   {
    string = (ubyte*) X2_SRAM_ABSENT;            
    output_info(string,STORED_NUM);   
    acu_loop = FALSE;
    return;
   }
   else
   {
    string = (ubyte*) X2_SRAM_PRESENT;           
    output_info(string,STORED_NUM);   
   }

   string = d_to_a(dmy_mem_bank);  /* need these two lines for BA TRAN */
    output_info(string,STORED_NUM);

 /* setup bank number to access Cutlass registers */
   *PORT_e8_bank_adrs_lo = 0x00;
   *PORT_e9_bank_adrs_hi = 0x00;

   data_tmp2 = B5CF_MappedTo_CS3;

   WriteDSP_MemThruBootx(CCON_REG, data_tmp2);
   data_tmp1 = ReadDSP_MemThruBootx(CCON_REG);
   if (data_tmp1 != data_tmp2)
   {
      ext_DspMemErrorFlag |= DSP_REG_WR_RD_ERROR;
   }

 /* setup bank number to access DSP SRAM */
   *PORT_e8_bank_adrs_lo = (dmy_mem_bank & 0x00ff);
   *PORT_e9_bank_adrs_hi = (dmy_mem_bank & 0xff00) >> 8;


  /* send two bytes to dsp per write */
   addr_tmp1 = x2_page_start_adrs; /* word addressing */
   msec_counter = 0;
   while(b_count > 0)
   {
      while(dte_from_num() > 1)
      {
        data_tmp1 = dte_from_char();
        data_tmp1 = (data_tmp1 << 8) | dte_from_char();
        WriteDSP_MemThruBootx(addr_tmp1, data_tmp1);

        b_count --;
        msec_counter = 0;

        data_tmp2 = ReadDSP_MemThruBootx(addr_tmp1);

        if(data_tmp1 != data_tmp2)
        {
           ext_DspMemErrorFlag |= DSP_32K_MEM_WR_RD_ERROR2;
           b_count = 0;
           break;
        }
        addr_tmp1++;
 ///       if(b_count == 0) break;
      }

/* ---------------------------------------------------- */
// debug code.  Should never use it on half card.

//      tmp_char = (ubyte) ((b_count >> 8) & 0x00ff);
//       outhex(tmp_char);
//      tmp_char = (ubyte) (b_count & 0x00ff);
//       outhex(tmp_char);
//      outchar(' ');

//      tmp_char = (ubyte) ((msec_counter >> 8) & 0x00ff);
//       outhex(tmp_char);
//      tmp_char = (ubyte) (msec_counter & 0x00ff);
//       outhex(tmp_char);
//      outchar(' ');


//       outchar('\r');
//       outchar('\n');
/* ---------------------------------------------------- */

      if(msec_counter > 3000)  /* check if timeout occured */
      {
         ext_DspMemErrorFlag |= TIMEOUT_ERROR;
         acu_loop = FALSE;
         return;
      }
      process_wait();
   }

  /* End of test code, read back and compare */

  /* fill the unused area with 0x0000 */
    for (addr_tmp1 = addr_tmp1; addr_tmp1 < CONST_64K; addr_tmp1++)
    {
      WriteDSP_MemThruBootx(addr_tmp1, TWO_BYTE_ZERO);
    }
   *PORT_e8_bank_adrs_lo = 0x00;
   *PORT_e9_bank_adrs_hi = 0x00;

//   data_tmp2 = (ReadDSP_MemThruBootx(WCON_REG) & 0x000f);

//   data_tmp2 &= 0x000f;  /* clear upper 12 bits */

//   data_tmp2 |= DSP_ONE_W_STATE_FOR_8000_FFFF;
/* set one wait state for  8000-ffff */
//   WriteDSP_MemThruBootx(WCON_REG, data_tmp2);

//   data_tmp1 = ReadDSP_MemThruBootx(WCON_REG);

   *temp = RESET_DSP_AND_BOOT_FROM_FFFF; /* 0x00 */
    for(i=0;i< 0x100;i++)
     wait_a_while();
   *temp = KILL_DSP_RES_N;   /* 0x01 */
    for(i=0;i< 0xffff;i++)
     wait_a_while();

//   dsp_poke(DSP_ONE_W_STATE_FOR_8000_FFFF, WCON_REG);  /* 0x2490 */

//   acu_data_bits =            acu_data_bits_tmp;
//   acu_stop_bits =            acu_stop_bits_tmp;
//   acu_parity    =            acu_parity_tmp; 
//   terminal_DTE_flowctrl =    terminal_DTE_flowctrl_tmp;
//   modem_DTE_flowctrl    =    modem_DTE_flowctrl_tmp;

//   dte_init(dte_init_baud,acu_data_bits,acu_stop_bits,acu_parity,terminal_DTE_flowctrl,
//   terminal_DTE_xon_char,terminal_DTE_xoff_char,
//   modem_DTE_flowctrl,modem_DTE_xon_char,modem_DTE_xoff_char,
//   pass_flowctrl,s[2],s[12],escape_mode);

   acu_loop = FALSE;

}
#endif


void print_dsp_version(void)
{
   ubyte *string;
   uword tmp_version;
   
   tmp_version = get_dsp_version();
   string = (ubyte*) DSP_FIRMWARE_VER_STRING;
   output_info(string,STORED_NUM);

   string = d_to_a_two(tmp_version>>8);
   output_info(string,UNFORMATTED);
   output_info( (ubyte *)".", UNFORMATTED);
   
   string = d_to_a_two(tmp_version&0xFF);
   output_info(string, UNFORMATTED);

   string = (ubyte*)MODEM_FIRMWARE_VER_STRING;
   output_info(string,UNFORMATTED);

#if (PARALLEL_MODE == 1)
   output_info( (ubyte *)" Parallel", UNFORMATTED);
#else
   output_info( (ubyte *)" Serial", UNFORMATTED);
#endif

/* shujin, 10/23/97
   for pcmcia hardware bug, need special firmware, see prll_mod.h, acu.c 
*/
#if (PCMCIA_SPECIAL == 1)
   output_info( (ubyte *)" (PCMCIA) ", UNFORMATTED);
#endif

   string = (ubyte*)    SPEAKER_PHONE_VER_STRING;
   output_info(string,UNFORMATTED);
   output_info(d_to_a_two(dsp_code[6]),UNFORMATTED);
}


