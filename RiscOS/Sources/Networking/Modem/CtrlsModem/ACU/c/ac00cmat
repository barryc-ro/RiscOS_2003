/****************************************************************************
/
/     Copyright 1988,1989,1990,1991,1992,1993,1994,1995.
/     All Rights Reserved by:
/     Cirrus Logic, Inc.
*****************************************************************************/

#include "sys_def.h"
#include "ee_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "acu_vce.h"
#include "mt_pro.h"
#include "v34_rate.h"
#include "ptt.h"
#include "mdm_56k.h"
#include "bldflags.h"
#include "resp_cod.h"
#include "dsppatch.h"
#include "mt_macro.h"
#include "mod_def.h"
#include "homolig1.h"
#include "bldflags.h"
#include "hmg_mem1.h"

#define COMMON_PATCH_VER_NUM    "Com Patch = "
#define DATA_PATCH_VER_NUM      "Dat Patch = "
#define TRAINING_PATCH_VER_NUM  "Trn Patch = "
#define VOICE_PATCH_VER_NUM     "Vce Patch = "
#define SERIAL_NUMBER_LOCATION 	0
#define ATI10 "252"
#define ATI11 "254"
#define SAFE  "MD:1724T"

extern ubyte st_crnt_boost1;
extern const uword data_patch[];
extern const uword common_patch[];
extern const uword training_patch[];
extern const uword voice_patch[];
void word_to_a(uword num,ubyte *ptr);
extern void set_safe1_en_relay(ubyte);
extern ubyte read_dsp_xmit_status_reg(void);	/* MH030398 */
extern ubyte read_dsp_dbmthr_level_reg(void);
extern ubyte Read_signal_level(void);
#if INTERNATIONAL_CODE == 1
extern ubyte ath1_timer;
extern ubyte ath1_activate ;
extern ubyte Tone_signal_level_lo;
extern uword msec2_count;
extern uword msec3_count;
extern struct Homg_var1_Tag	homg_var1;
void Per_TTNR_eq(ubyte *parm_ptr);
void Per_TTNR_q(void);
void bang_Tb_eq(ubyte *parm_ptr);
void bang_Tb_q(ubyte *parm_ptr);
void bang_Tr_eq(ubyte *parm_ptr);
#endif
extern PTT_General_Flags_Tag1  ptt_general_flags[];
extern Cntry_List_Tag  cntry_list[];
extern void InitiateTransmitLevel(ubyte for_dtmf_txlevel);

void at_B(ubyte *);
void at_C(ubyte *);
void at_E(ubyte *);
void at_F(ubyte *);
void at_H(ubyte *);
void at_I(ubyte *);
void at_L(ubyte *);
void at_M(ubyte *);
void at_N(ubyte *);
void at_O(ubyte *);
void at_P(void);
void at_Q(ubyte *);
void at_S(ubyte *);
void at_equal(ulong *);
void chk_sreg_range(ulong);
void at_quest(void);
void at_T(void);
void at_V(ubyte *);
void at_W(ubyte *);
void at_X(ubyte *);
void at_Y(ubyte *);
void at_Z(ubyte *);
void at_comma(void);

#if MODEM_X2_MODE == 1
void modem_get_pcm_info(void);
#endif

void at_serial_number_amd(ubyte *);
void at_serial_q(void);
void at_serial_number_atmel(ubyte *);
void at_amd(void);
void at_atmel(void);
void write_serial_number_amd(void);
void write_serial_number_atmel(void);

#if DNLD_X2_FROM_HOST == 1
 void bang_X_e(uword *parm_ptr);
#endif

extern void main_dnld_flash_amd(void);
extern void main_dnld_flash_atmel(void);
extern void write_serial_number(void);

void str_WP(ubyte *);
void str_WD(ubyte *);

extern ubyte X2_MuOrA_Law;

void plus_ms(ubyte *);
void at_comma(void);
void print_dsp_version(void);
uword get_dsp_version(void);

#if TIES_HAYES_ESCAPE                    /* ciy021596 */
extern void online_at_esc(void);
extern ubyte ties_esc_state;
extern ubyte dte_mode;
#define ESC_DONE     1
#define ACU          1
#endif

#define STORED_NUM  2
#define UNFORMATTED     3
ubyte *d_to_a_two(ubyte num);

ubyte ms_mode;
ubyte ms_min_rate;
ubyte v34_bis_mode;
uword ms_min_speed = 0;

void output_send_cr_lf(void);
extern ubyte ack_or_response;
extern ubyte current_command[];
void send_pkt_to_dsp(void);
extern uword dsp_code[];

#define ACK 0
extern ubyte CountryInfo;
extern InitiateToneATaps(void);
extern void CountryDependSRegRangeCheck(ubyte);
extern ubyte LineCurrent(void);
extern struct SREG22 s22orig;
extern   void  set_dsp_cid(ubyte);
extern   void  set_callerid_relay(uword);
extern ubyte voice_caller_id;
#define   CID_RELAY_OFF  0x0200
ubyte s0_value_changed = 0;
ubyte value_of_s0_reg;
extern ubyte   line_mode;
ubyte dsp_packet_id_msg[1];

#define UPGRADE_56K "Present, 32K DSP RAM."
#define NO_UPGRADE_56K "Not Found, Ext DSP RAM  "

#define X2_SRAM_PRESENT "Available 32K DSP RAM"
#define X2_SRAM_ABSENT  "Missing 32K DSP RAM"
#define WRONG_PARM1  "Incorrect Paramters!! "

void dsp_poke2 (uword data, uword addr, uword mcon_16);
uword dsp_peek2(uword addr, uword mcon_16);
ubyte dsp_ext_mem32k_test(uword dmy_mem_bank, uword dmy_WhatRange_Mapped_to_Which_Chip_Select);
ubyte dnld_bootx_code(const uword dmy_bootx_array[]);

ubyte Check_For_55_AA_Token(ubyte dmy_token);
ubyte Change_PLL_Freqency(ubyte dmy_value);
void loop_on_no_OK_semaphore(void);
void WriteDSP_MemThruBootx(uword addr_tmp1, uword data_tmp1);
uword ReadDSP_MemThruBootx(uword addr_tmp1);

void wait_a_while(void);
extern ubyte dial_timer;

extern ubyte ext_DspMemErrorFlag;
extern const uword bootx_array[];
extern const uword x2_page_array[];
ubyte *d_to_a(ubyte);

ubyte modem_control_reg_rts(void);
ubyte get_dte_DTR_status(void);
extern uword msec_counter;
extern void mt_driver_error_handler(ubyte);
extern const ubyte ati4[60];
extern const ubyte ati7[60];
extern ubyte num_dialed ; /* ramn 8/15/96 */
extern ubyte CheckStoredNumZ0123(ubyte Znum);
ubyte ATDcheckforS(ubyte * ptr2);

/*******************************************************************************
/
/     Routine:       at_A
/
/     Author:        RSA
/
/     Creation Date: 12/07/94
/
/     Description:   This routine is called to implement the Answer command:
/                    "ATA."  The ATA command is used answer a call.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr.27.Bell_mode, atB
/
/     Users:    execute_cmd
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_A(void)
{
	if (country_area_code1 == German){
		if ((!LineCurrent()) && (s[1] != 0)) {
			}
		else {
	       error_occurred = TRUE;
			 return ;
			}
		}
   /* No parameter for ATA command */
   send_ok = FALSE;

   if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
   {
       error_occurred = TRUE;
		 return; /* if voice do not execute ata,ramn 7/31/96 */
   }
/*	if caller id enabled and we are going off-hook after 1 ring
	disable caller id
*/
	if((voice_caller_id != 0) && (*srptr[1] == 1))
	{
		 s0_value_changed = TRUE;
		 value_of_s0_reg = *srptr[0];
		 *srptr[0] = 1;

#if 0
       set_dsp_cid(0);
	    set_callerid_relay( CID_RELAY_OFF);
		/* voice_caller_id = 0;*/
#endif
	}
   else if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
#if (PATCHLESS_EXTERNAL == 0)

#if CUTLASS_C6 == 1
		if(fax_class == 0)      /* issue th v34 config packet only in data mode */
		{
	     current_command [0] = 0x90;        /* clamps the max symbol rate to < 3429 */
	     current_command [1] = 0x00;        /* hence 33.6 not possible */
		  current_command [2] = 0x08;
	     current_command [3] = 0x00;
	  current_command [4] = 0x79;
	     current_command [5] = 0x21;
	  current_command [6] = 0x7f;
	     current_command [7] = 0x75;
		  current_command [8] = 0x1b;
	     current_command [9] = 0x01;
	     current_command [9] = 0x07;
	     current_command [9] = 0x00;

	     ack_or_response = ACK;
	  send_pkt_to_dsp();
		}
#endif
#endif
       build_event(E_ANSW,UNUSED);
   }
   else
       error_occurred = TRUE;

#if 0
   /* No parameter for ATA command */
   send_ok = FALSE;

   /* ATA is invalid for Voice IS-101 */
   if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
   {
       error_occurred = TRUE;
   }
   /* ATA is invalid if we're already connected */
   else if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
       build_event(E_ANSW,UNUSED);
   }
   else
   {
       error_occurred = TRUE;
   }
#endif
}

/*******************************************************************************
/
/     Routine:       at_B
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine will select the communication mode to
/                    be used.
/
/                    ATB   0  - CCITT mode (V.22 at 1200bps)
/                          1  - Bell mode (Bell 212A at 1200bps)
/                          2  - V23 mode if originating T75/R1200 BPS
/                                if answering T1200/R75 BPS
/                          3  - V23 mode if originating T1200/R75 BPS
/                                if answering T75/R1200 BPS
/
/                          15 - V.21 (at 300 bps)
/                          16 - Bell 103 (at 300 bps)
/
/                          30 - V.22bis (at 2400 bps)
/                          31 - V.34 (at 2400 bps)
/
/                          41 - V.32 (at 4800 bps)
/                          42 - V.34 (at 4800 bps)
/
/                          52 - V.32 (at 7200 bps)
/                          53 - V.34 (at 7200 bps)
/
/                          60 - V.32 (at 9600 bps)
/                          61 - V.34 (at 9600 bps)
/
/                          70 - V.32 (at 12000 bps)
/                          71 - V.34 (at 12000 bps)
/
/                          75 - V.32 (at 14400 bps)
/                          76 - V.34 (at 14400 bps)
/
/                          80 - V.34 (at 16800 bps)
/
/                          85 - V.34 (at 19200 bps)
/
/                          90 - V.34 (at 21600 bps)
/
/                          95 - V.34 (at 24000 bps)
/
/                         100 - V.34 (at 26400 bps)
/
/                         105 - V.34 (at 28800 bps)
/
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr.27.Bell_mode, atB
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_B(ubyte *param_ptr)
{
   ubyte num;

   /* Ubyte parameter for ATB command */
   num = *param_ptr;

#if 0
   /* If parameter on ATB is greater then what is allowed for V.22bis then
      need to return error. */
   if (acu_cfg.mode == CFG_V22BIS)
   {
      if (num >= 40)
      {
	 error_occurred = TRUE;
	 return;
      }
   }
   /* If parameter on ATB is not allowed for V.32 then need to return error */
   else if (acu_cfg.mode == CFG_V32)
   {
      if (((num >= 50) && (num <= 59)) || (num >= 70))
      {
	 error_occurred = TRUE;
	 return;
      }
   }
   /* If parameter on ATB is greater then what is allowed for V.32bis then
      need to return error. */
   else if (acu_cfg.mode == CFG_V32BIS)
   {
      if (num >= 80)
      {
	 error_occurred = TRUE;
	 return;
      }
   }
   /* If parameter on ATB is greater then what is allowed for V.34 then
      need to return error. */
   else if (acu_cfg.mode == CFG_V34)
   {
      if (num > 110)
      {
	 error_occurred = TRUE;
	 return;
      }
   }

#endif

   /* See if value is in group 1 (1200 bps) */
   if (num <= 9)
   {
      /* See if valid value for group 1 */
      switch (num)
      {
	 case 0: /* Bell 212 */
	    sr27.BELL_mode = FALSE;
	    atB.group1 = num;
	    atB.group3 = 15;
	    break;

	 case 1: /* V.22 */
	    sr27.BELL_mode = TRUE;
	    atB.group1 = num;
	    atB.group3 = 16;
	    break;

	 case 2: /* V.23 */
	 case 3: /* V.23R */
	    if (acu_cfg.v23)
	       atB.group1 = num;
	    else
	       error_occurred = TRUE;
	    break;

	 default: error_occurred = TRUE;

      }
   }

#if 0
   /* See if value is in group 2 (Transmit 75 bps)    */
   else if ((num >= 10) && (num <= 14 ))
   {
      error_occurred = TRUE;
   }
   /* See if value is in group 3 (300 bps)   */
   else if ((num >= 15) && (num <= 19 ))
   {
      /* See if valid value for group 3 */
      switch (num)
      {
	 case 15:    /* Bell 103 */
	    sr27.BELL_mode = FALSE;
	    atB.group3 = num;
	    break;

	 case 16:    /* V.21 */
	    sr27.BELL_mode = TRUE;
	    atB.group3 = num;
	    break;

	 default: error_occurred = TRUE;
	    break;
      }
   }
   /* See if value is in group 4 (600 bps)   */
   else if ((num >= 20) && (num <= 29 ))
   {
      error_occurred = TRUE;
   }
   /* See if value is in group 5 (2400 bps) */
   else if ((num >= 30) && (num <= 39 ))
   {
      /* See if valid value for group 5 */
      switch (num)
      {
	 case 30:    /* V.22bis */
	 case 32:    /* V.34 */
	    atB.group5 = num;
	    break;

	 default: error_occurred = TRUE;
	    break;
      }
   }
   /* See if value is in group 6 (4800 bps) */
   else if ((num >= 40) && (num <= 49 ))
   {
      /* See if valid value for group 6 */
      switch (num)
      {
	 case 41:    /* V.32 */
	 case 42:    /* V.34 */
	    atB.group6 = num;
	    break;

	 default: error_occurred = TRUE;
	    break;
      }
   }
   /* See if value is in group 7 (7200 bps) */
   else if ((num >= 50) && (num <= 59 ))
   {
      /* See if valid value for group 7 */
      switch (num)
      {
	 case 52:    /* V.32 */
	 case 53:    /* V.34 */
	    atB.group7 = num;
	    break;

	 default: error_occurred = TRUE;
	    break;
      }
   }
   /* See if value is in group 8 (9600 bps) */
   else if ((num >= 60) && (num <= 69 ))
   {
      /* See if valid value for group 8 */
      switch (num)
      {
	 case 60:    /* V.32 */
	 case 61:    /* V.34 */
	    atB.group8 = num;
	    break;

	 default: error_occurred = TRUE;
	    break;
      }
   }
   /* See if value is in group 9 (12000 bps) */
   else if ((num >= 70) && (num <= 74 ))
   {
      /* See if valid value for group 9 */
      switch (num)
      {
	 case 70:    /* V.32 */
	 case 71:    /* V.34 */
	    atB.group9 = num;
	    break;

	 default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 10 (14400 bps) */
   else if ((num >= 75) && (num <= 99 ))
   {
      /* See if valid value for group 10 */
      switch (num)
      {
	 case 75:    /* V.32 */
	 case 76:    /* V.34 */
	    atB.group10 = num;
	    break;

	 default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 11 (16800 bps) */
   else if ((num >= 80) && (num <= 84 ))
   {
      /* See if valid value for group 11 */
      switch (num)
      {
	 case 80:    /* V.34 */
	    atB.group11 = num;
	    break;
	 default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 12 (19200 bps) */
   else if ((num >= 85) && (num <= 89))
   {
      /* See if valid value for group 12 */
      switch (num)
      {
	 case 85:    /* V.34 */
	    atB.group12 = num;
	    break;
	 default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 13 (21600 bps) */
   else if ((num >= 90) && (num <= 94))
   {
      /* See if valid value for group 13 */
      switch (num)
      {
	 case 90:    /* V.34 */
	    atB.group13 = num;
	    break;
	 default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 14 (24000 bps) */
   else if ((num >= 95) && (num <= 99))
   {
      /* See if valid value for group 14 */
      switch (num)
      {
	 case 95:    /* V.34 */
	    atB.group14 = num;
	    break;
	 default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 15 (26400 bps) */
   else if ((num >= 100) && (num <= 104))
   {
      /* See if valid value for group 15 */
      switch (num)
      {
	 case 100:   /* V.34 */
	    atB.group15 = num;
	    break;

	 default: error_occurred = TRUE;
      }
   }
   /* See if value is in group 16 (28800 bps) */
   else if ((num >= 105) && (num <= 109))
   {
      /* See if valid value for group 16 */
      switch (num)
      {
	 case 105:   /* V.34 */
	    atB.group16 = num;
	    break;

	 default: error_occurred = TRUE;
      }
   }
#endif
   else
   {
      error_occurred = TRUE;
   }

}


/*******************************************************************************
/
/     Routine:       at_C
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the carrier control option
/
/                    ATC   0 - transmit carrier always off  (not supported)
/                          1 - normal transmit carrier switching
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_C(ubyte *param_ptr)
{
   /* Ubyte parameter for ATC command */
   if (*param_ptr != 1)
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_D
/
/     Author:        RSA
/
/     Creation Date: 12/07/94
/
/     Description:   This routine is called to implement the Dial command:
/                    "ATD."  The ATD command is used originate a call.
/
/     Input Parameters: *param_ptr - pointer to the command's parameter
/                      (a NULL terminated string)
/
/     Output Parameters: none
/
/     Global Variables Changed:
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_D(ubyte *param_ptr)
{
	ubyte *string;  //debug1
#if INTERNATIONAL_CODE == 1
	st_crnt_boost1 = 0;
#endif
    num_dialed = 0; /* ramn 8/15/96 */
	if (country_area_code1 == German)
	{
		s22orig = sr22;
		if (!LineCurrent())
		{
			if (*param_ptr == NULL)
			{
				sr22.busy_enable = FALSE;
				sr22.dialtone_enable = FALSE;
				sr22.enable_result5 = FALSE;
			}
		}
		else
		{
	       error_occurred = TRUE;
			 return ;
		}
	}
   /* Save the Dial String Buffer for later use */
   acu_dial_string_ptr = param_ptr;
   send_ok = FALSE;

/*   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
*/

   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && !test_in_progress))
   {
		if(on_line_command)
		{
			if(fax_class == 8)
			{
				state_type[S_PARSE] = AT_OFFLINE;
			}
			else
			{
				error_occurred = TRUE;
				return;
			}
		}

#if (PATCHLESS_EXTERNAL == 0)
#if CUTLASS_C6 == 1
		if(fax_class == 0)      /* issue th v34 config packet only in data mode */
		{
	   	current_command [0] = 0x90;        /* clamps the max symbol rate to < 3429 */
		   current_command [1] = 0x00;        /* hence 33.6 not possible */
			current_command [2] = 0x08;
		   current_command [3] = 0x00;
			current_command [4] = 0x79;
		   current_command [5] = 0x21;
			current_command [6] = 0x7f;
		   current_command [7] = 0x75;
			current_command [8] = 0x1b;
		   current_command [9] = 0x01;
		   current_command [9] = 0x07;
		   current_command [9] = 0x00;

	   	ack_or_response = ACK;
	   	send_pkt_to_dsp();
		}
#endif
#endif

#if INTERNATIONAL_CODE == 1
		if(ATDcheckforS(param_ptr) != ATD_IS_GOOD)
		{
	     		build_event(E_HANGUP,ERROR);
		}
		else
		{
			InitiateTransmitLevel(1);  // 1 is for dtmf. atd could mean atdt.
		   build_event(E_ORIG,UNUSED);
			if(st_crnt_boost1 != 0) // make sure it's OK to dial
			{
				set_shunt_relay(DEACTIVATE);	/* MH121697 OUTPUT = 0 */
				msec2_count = SHUNT_OFFHOOK_DELAY;
			}
		}
#else

		InitiateTransmitLevel(1);  // 1 is for dtmf. atd could mean atdt.
	   build_event(E_ORIG,UNUSED);
#endif
   }
   else
       error_occurred = TRUE;
#if 0
   /* Save Address of the Address String Buffer for later use */
   acu_dial_string_ptr = param_ptr;
   send_ok = FALSE;

   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
       build_event(E_ORIG,UNUSED);
   }
   else
       error_occurred = TRUE;
#endif

}


/*******************************************************************************
/
/     Routine:       at_E
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the command character echo option
/
/                    ATE   0 - off-line character echo disabled
/                          1 - off-line character echo enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.echo_cmd_flag, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_E(ubyte *param_ptr)
{
   /* Ubyte parameter for ATE command */
   switch (*param_ptr)
   {
      case 0:
	 sr14.echo_cmd_flag = FALSE;
	 /* modem_serial_echo(OFF);*/ /* ramn 9/20/96 */
	 break;

      case 1:
	 sr14.echo_cmd_flag = TRUE;
	 break;

      default:
	 error_occurred = TRUE;
	 return;
   }
}


/*******************************************************************************
/
/     Routine:       at_F
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:  This Routine selects the data character echo option
/
/                    ATF   0 - on-line character echo enabled (not supported)
/                          1 - on-line character echo disabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_F(ubyte *param_ptr)
{
    /* Only ATF1 is supported */
    if (*param_ptr != 1)
	error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_H
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine controls the switch hook.
/
/                    ATH   0 - execute hang up process
/                          1 - go off hook, but no handshake
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed: error_occurred, at_h_command
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_H(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
	case 0:
#if TIES_HAYES_ESCAPE                    /* ciy021596 */

	    {
		if (test_in_progress)
		{
		    build_event(E_HANGUP,NONE);
		    if ( dte_mode != ACU )
		    {
			ties_esc_state = 'H';
			error_occurred = TRUE;
		    }
		}
		else
		{
		    if ( (on_line_command && !test_in_progress && fax_class == 0 )
			|| ( ties_esc_state == ESC_DONE ) )
		    {
			if ( !on_line_command )
			    {
				send_ok = TRUE;
				ties_esc_state = 'H';
				error_occurred = TRUE;
			    }
			hangup_connection(NONE);
		    }
		    else

/* MH092297 */
#if INTERNATIONAL_CODE == 1
          set_loc_line_relay(ON_HOOK);
          set_safe1_en_relay(ACTIVATE);	/* mh103197 output = HI */
          set_shunt_relay(ACTIVATE); /* MH112697 */
		  st_crnt_boost1 = 0;
		  ath1_activate = FALSE;
		  ath1_timer = 0;
		Tone_signal_level_lo = 0;		/* initialize level detection */
#else
          set_safe1_en_relay(ACTIVATE);	/* mh103197 output = HI */
#endif

			    build_event(E_HANGUP,NONE);
		}
	    }
#else
	    /* Queue E_HANGUP event to terminate the test */
	    if (test_in_progress)
		build_event(E_HANGUP,NONE);
	    else
	    /* Terminate the link */
	    if (on_line_command && !test_in_progress && fax_class == 0)
		hangup_connection(NONE);
	    else
		build_event(E_HANGUP,NONE);
#endif
	    at_h_command = TRUE;
	    user_initiated_hangup = TRUE;
	    break;

	case 1:
	    if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
	    {
		error_occurred = TRUE;
		return;
	    }

/* MH092297 */
#if INTERNATIONAL_CODE == 1
	set_loc_line_relay(OFF_HOOK_NOT_DIALED);
	set_shunt_relay(DEACTIVATE);	/* MH121697 OUTPUT = 0 */
	st_crnt_boost1 = SHUNT_ATH1_START;
	msec2_count = SHUNT_OFFHOOK_DELAY;
	if(ptt_general_flags[CountryInfo].ath1_timer_disabled == 0)
	{
	ath1_activate = TRUE;
	ath1_timer = s[7];
	}
#endif

	    off_hook();

#if 0
	    modem_td_relay(ON);
	    if (sr21.auxiliary_relay_ctrl)
		modem_AA1_relay(ON);
#endif
	    break;

	default:
	    error_occurred = TRUE;
	    return;
    }

#if 0
   /* Ubyte parameter for ATH command */
   switch (*param_ptr)
   {
      case 0:
	 /* Terminate the link */
	 if (on_line_command && !test_in_progress && fax_class == 0)
	    hangup_connection(NONE);
	 /* Else queue HANGUP event to terminate the test */
	 else
	    build_event(E_HANGUP,NONE);

	 at_h_command = TRUE;
	 user_initiated_hangup = TRUE;
	 break;

      case 1:
	 /* ATH1 is not allowed in TIA voice */
	 if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
	 {
	    error_occurred = TRUE;
	    return;
	 }
	 modem_td_relay(ON);
	 off_hook();

	 if (sr21.auxiliary_relay_ctrl)
	    modem_AA1_relay(ON);
	 break;

      default:
	 error_occurred = TRUE;
	 return;
   }
#endif
}

/*******************************************************************************
/
/     Routine:       at_I
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine is uded to display hardware description.
/
/                    ATI   0 - Display product code
/                          1 - Calculate and display ROM checksum
/                          2 - Verify ROM checksum
/                          3 - Display part numbers and revision levels
/                          4 - Display modem capabilities
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/

void at_I(ubyte *param_ptr)
{
	ubyte Tone_Thr_level;
	ubyte ToneStatus;
	ubyte *string,*temp;
	ubyte val1, val2;
//    #if (PATCHLESS_EXTERNAL == 0)
    ubyte string99[6];	   // needed for ati6
//	#endif

 	for (val2=0 ; val2<6; val2++)
  		string99[val2] = 0x00;

    if (voice_cmd_set == TIA_IS_101)
    {
	error_occurred = TRUE;
	return;
    }

    /* Ubyte parameter for ATI command */
    switch (*param_ptr)
    {
       case 0:

            output_info( (ubyte *) MODEM_PRODUCT_CODE,
                         (ubyte)sr14.verbose_form);

	/* MH020398 for test */

#if 0
  	    	string = (ubyte *)"Status";
		output_info(string,VERBOSE_FORM);  	/* before and after */
		ToneStatus = read_dsp_xmit_status_reg();
         	string = d_to_a(ToneStatus);
		output_info(string,UNFORMATTED);  	/* before and after */


    	string = (ubyte *)"signal level";
		output_info(string,VERBOSE_FORM);  	/* before and after */
/*		Tone_Thr_level = Read_signal_level(); */
		Tone_Thr_level = Tone_signal_level_lo;
     	string = d_to_a(Tone_Thr_level);
		output_info(string,UNFORMATTED);  	/* before and after */
#endif

       break;

		case 1:
			print_dsp_version();
			output_send_cr_lf();
		break;

	case 2:
	    if (!modem_rom_test())
		string = (ubyte *)"ROM TEST ERROR";
	    else
		string = (ubyte *)"ROM TEST OK";

	    output_info(string,(ubyte)sr14.verbose_form);
	    break;

	case 3:
		output_info((ubyte *)MODEM_CHIPSET_NAME,(ubyte)sr14.verbose_form);
	    break;

	case 4:
#if INTERNATIONAL_CODE == 1
        string = (ubyte*)ati4;
        output_info(string,STORED_NUM);
#endif
	    break;

	case 5:

	 if( ext_DspMemErrorFlag == 0)
	 {
	   string = (ubyte*) UPGRADE_56K;
	 }
	 else
	 {
	   string = (ubyte*) NO_UPGRADE_56K;
	 }

       /* indicates if the external DSP SRAM exists */
		output_info(string,STORED_NUM);

	string = d_to_a(ext_DspMemErrorFlag);
			output_info(string,UNFORMATTED);

			string = (ubyte*) HOSTIF;

			output_info(string,STORED_NUM);
			#ifdef __riscos
			output_info((ubyte *) " Expansion bus",STORED_NUM);
			#else
			temp = (ubyte *) HICSR;
/* if ring not present then value is 65 if ring presnet value is 25 */
			if ((*temp == 0x65) || (*temp == 0x25))
			{
				string = (ubyte*) PARALLEL;
				output_info(string,UNFORMATTED);

			}
/* if ring not present then value is 71 if ring presnet value is 31 */
				else if ((*temp == 0x71) || (*temp == 0x31))

			{
				string = (ubyte*) SERIAL;
				output_info(string,UNFORMATTED);

			}

			string = (ubyte*) PMMODE;
			output_info(string,STORED_NUM);
			temp = (ubyte *) CSCR1;

			val1= *temp & 0x0f;
			val2 = *temp;
			val2= val2>>4;

			if(val1==2)
			  val1=32;
			if(val1==1)
			  val1=16;
			if(val1==0)
			  val1=8;

			string = d_to_a(val1);
			output_info(string,UNFORMATTED);

			string = (ubyte*) BIT;
			output_info(string,UNFORMATTED);

			string = d_to_a(val2);
			output_info(string,UNFORMATTED);

			string = (ubyte*) WAIT;
			output_info(string,UNFORMATTED);

			string = (ubyte*) DMMODE;
			output_info(string,STORED_NUM);
			temp = (ubyte *) CSCR3;

			val1= *temp & 0x0f;
			val2 = *temp;
			val2= val2>>4;

			if(val1==2)
			  val1=32;
			if(val1==1)
			  val1=16;
			if(val1==0)
			  val1=8;

			string = d_to_a(val1);
			output_info(string,UNFORMATTED);

			string = (ubyte*) BIT;
			output_info(string,UNFORMATTED);

			string = d_to_a(val2);
			output_info(string,UNFORMATTED);

			string = (ubyte*) WAIT;
			output_info(string,UNFORMATTED);

			string = (ubyte*) DSP_CODE_MODE;
			output_info(string,STORED_NUM);
			/* indicates the location of
			 DSP code int ROM or ext SRAM */
			#endif

	    break;


	case 6:
			CountryInfo &= 0x0f;
			if(CountryInfo < NUM_OF_COUNTRIES_SUPPORTED)
			{
				string = (ubyte *) cntry_list[CountryInfo].cntry_n;
			    output_info(string,STORED_NUM);

				string = (ubyte *) " ";
				output_info(string,UNFORMATTED);

				word_to_a(country_area_code1, string99);
				output_info(string99,UNFORMATTED);
			}
 			else
 			{
 				string = (ubyte *) cntry_list[0].cntry_n;
			    output_info(string,STORED_NUM);
 			}
		    break;

	case 7:
		   string = (ubyte*)ati7;
		   output_info(string,STORED_NUM);

		   break;

	case 8:
           temp = (ubyte *)MDM_FIRMWARE_FEATURES;
           string = temp + 8;
		   output_info(string,STORED_NUM);
    	   break;

	case 9:
	case 12:
	case 13:
	case 21:
	case 23:
	case 24:
	case 25:
                break;
	case 10:
				output_info((ubyte *)ATI10, STORED_NUM);
				break;

	case 11:
				output_info((ubyte *)ATI11,STORED_NUM);
				break;

	case 14:
				output_info((ubyte *)SAFE,STORED_NUM);
				break;

#if MODEM_X2_MODE == 1
   /* for x2 pcm status */
   case 20:
		if (line_mode == VX2)
         	modem_get_pcm_info();
        break;
#endif

	case 22:
        output_info((ubyte *)MODEM_MANUFACTURER_IDENTIFICATION,
                     STORED_NUM);
	    break;

		case 99:
         #if (PATCHLESS_EXTERNAL == 0)
			string = (ubyte *) COMMON_PATCH_VER_NUM;
			output_info(string,STORED_NUM);
			word_to_a(common_patch[3],string99);
			output_info(string99,UNFORMATTED);

			string = (ubyte *) DATA_PATCH_VER_NUM;
			output_info(string,STORED_NUM);
			word_to_a(data_patch[3],string99);
			output_info(string99,UNFORMATTED);

			string = (ubyte *) TRAINING_PATCH_VER_NUM;
			output_info(string,STORED_NUM);
			word_to_a(training_patch[3],string99);
			output_info(string99,UNFORMATTED);

			string = (ubyte *) VOICE_PATCH_VER_NUM;
			output_info(string,STORED_NUM);
			word_to_a(voice_patch[3],string99);
			output_info(string99,UNFORMATTED);
         #else
			output_info( (ubyte *) "PATCHLESS EXTERNAL",STORED_NUM);

         #endif
		break;

	default:
	    error_occurred = TRUE;
	    break;
	}
}

/*******************************************************************************
/
/     Routine:       at_L
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the speaker volume.
/                    ATL   0 - Low volume
/                          1 - Low volume
/                          2 - Medium volume
/                          3 - High volume
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.speaker_vol, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_L(ubyte *param_ptr)
{
   ubyte num;

   num = *param_ptr;
   if (num <= 3)
   {
      sr22.speaker_vol = num;
      modem_speaker_vol(num);
   }
   else
      error_occurred = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_M
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the speaker control.
/
/                    ATM   0 - Speaker always off
/                          1 - Speaker on until carrier present
/                          2 - Speaker always on
/                          3 - Speaker off during dialing and on until carrier
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.speaker_control, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_M(ubyte *param_ptr)
{
   switch (*param_ptr)
   {
      case 0:
	 sr22.speaker_ctrl = ALWAYS_OFF;
	 modem_speaker(OFF);
	 break;

      case 1:
	 sr22.speaker_ctrl = ON_UNTIL_CD;
	 if (!hook)
	    modem_speaker(OFF);
	 break;

      case 2:
	 sr22.speaker_ctrl = ALWAYS_ON;
	 if (!hook)
	    modem_speaker(ON);
	 break;

      case 3:
	 sr22.speaker_ctrl = OFF_DIALING;
	 if (!hook)
	    modem_speaker(OFF);
	 break;

      default: error_occurred = TRUE;
	 return;
   }
}

/*******************************************************************************
/
/     Routine:       at_N
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the auto-mode/V.8 option. (bit mapped)
/                    ATNn  0 - Automode disabled
/                          1 - Automode enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  automode, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_N(ubyte *param_ptr)
{
   /* Test for automode and V.8 */
	if (*param_ptr <= 1)
	{
		 switch(        *param_ptr)
		 {
			case 0:
				N = 0;
				automode = 0;
#if MODEM_X2_MODE == 1
				if ((ms_mode == VX2)||(ms_mode == V90))
					automode = 2;
				else
#endif
				if( (ms_mode == V34) || (ms_mode == V34S) )
					automode = 2;

				break;

			case 1:
				N = 1;
				automode = 1;
#if MODEM_X2_MODE == 1
				if ((ms_mode == VX2)||(ms_mode == V90))
					automode = 3;
				else
#endif
				if( (ms_mode == V34) || (ms_mode == V34S) )
					automode = 3;

				break;
			}

	}
	else
		error_occurred = TRUE;

}

/*******************************************************************************
/
/     Routine:       at_O
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to tell the modem to return to
/                    a previously established connection.
/
/                    ATO   0 - Go to on-line state
/                          1 - Go to on-line state and retrain adaptive equalizer
/                             (V.22bis,V.32,V.32bis, and V.34 modulations only)
/                          3 - Go to on-line state and rate renegotiate
/                             (V.32bis, and V.34 modulations only)
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  error_occurred, result_message_sent,
/                    send_ok, on_line_command, modem_baud, acu_state
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_O(ubyte *param_ptr)
{
   ubyte num, tmp;

   if (voice_cmd_set == TIA_IS_101)
   {
       error_occurred = TRUE;
       return;
   }

   /* Allow ATO to return online from some tests... */
   switch (test_in_progress)
   {
      case 0: /* No Test in progress - do nothing */
	 break;

      case ALB:
      case RDL:
	 /* Return back to the test (AT&T1,6) */
	 build_event(E_TEST,TEST_RETURN);
	 return;

      default:
	 error_occurred = TRUE;
	 return;
   }

   /* If on hook, the command is not vaild */
   if ((hook == TRUE) || (slU == TRUE))
   {
      error_occurred = TRUE;
      return;
   }

   /* Get AT command parameter local */
   num = *param_ptr;

   /* Update modem's retrain operation in case it has changed while in on
      line command mode. */

   /* if operating V80 SAM */
   if (slN == 6)
   {
      /* disable automatic retrains and renegotiations for the host */
      modem_retrain_enable(FALSE,FALSE,FALSE);
   }
   else
   {
      tmp = ((((operating_mode != DIRECT) && (!bps_adjust)) ||
	    (comm_mode != ASYNC)) && (autofallback));

      modem_retrain_enable(perE,s[110],tmp);
   }

#if TIES_HAYES_ESCAPE                    /* ciy021596 */

    if ( on_line_command )
	update_modem_rate_seq();

    /* If running MNP 10 do not allow the ACU to force a retrain or rate
	renegotiation. These should be controlled by the MNP 10 code only. */
    if (v42_running_mnp10)
	num = 0;

    /* Which ATO command */
    switch (num)
    {
	case 0 :
	    if (on_line_command)
	    {
		/* Build CONNECT event and cleanup after parse state */
		parse_return_online();

		return; /* Do not fall through and reconfigure the
			system. It is done by the return online function */
	    }
	    else
	    {
		if (sr14.originate_flag)
		    build_event(E_ORIG,NO_DIAL);
		else
		    build_event(E_ANSW,UNUSED);
	    }
	    break;

	case 3:
	    /* If V.32bis operation is not enabled then need to
		return error if trying to issue a rate renegotiation. */
	    if ((v32bis_enable == 0) &&
	       (modem_mode != V34 && modem_mode != V34_ASYMETRIC))
	    {
		error_occurred = TRUE;
		return;
	    }

	    /* Intentionally fall through */

	case 1:
	    if (on_line_command)
	    {
		if (num == 1)
		    modem_retrain();
		else /* num == 3 */
		    modem_renegotiate();
		st_parse.state = CMD7;
		timer1 = 1500;      /* Retrain to complete delay time */

		return; /* Do not fall through and reconfigure the
			system yet. It is done after the
			parse_to_online_retain state */
	    }
	    else
		if (sr14.originate_flag)
		    build_event(E_ORIG,NO_DIAL);
		else
		    build_event(E_ANSW,UNUSED);
	    break;

	default: error_occurred = TRUE;
	    return;
    }

    send_ok = FALSE;
    on_line_command = FALSE;

    system_reconfigure();
    autobaud_off();
}

#else


   /* Update the modem's possible rates in case they have changed while in
      on line command mode */
   update_modem_rate_seq();

   /* If running MNP 10 do not allow the ACU to force a retrain or rate
      renegotiation. These should be controlled by the MNP 10 code only. */
   if (v42_running_mnp10)
      num = 0;

   /* Which ATO command */
   switch (num)
   {
      case 0:
	 if (on_line_command)
	 {
	    /* Build CONNECT event and cleanup after parse state */
	    parse_return_online();

	    return; /* Do not fall through and reconfigure the
		     system. It is done by the return online function */
	 }
	 else
	 {
	    /* Originate w/out dialing */
	    if (sr14.originate_flag)
	       build_event(E_ORIG,NO_DIAL);
	    else
	       build_event(E_ANSW,UNUSED);
	 }
	 break;

       case 3:
	 /* If V.32bis operation is not enabled then need to
	    return error if trying to issue a rate renegotiation. */
	 /* V.34 allows RRNS too */
	 if ((v32bis_enable == 0) &&
	    (modem_mode != V34 && modem_mode != V34_ASYMETRIC))
	 {
	    error_occurred = TRUE;
	    return;
	 }

	 /* Intentionally fall through */

      case 1:
	 if (on_line_command)
	 {
	    /* Execute retrain */
	    if (num == 1)
	       modem_retrain();
	    else /* num == 3 */
	       modem_renegotiate();

	    timer1 = 1500;    /* Retrain to complete delay time */

	    /* Move the parse state to wait for retrain to complete,
	       then issue the CONNECT from the parse state */
	    st_parse.state = CMD7;

	    return; /* Do not fall through and reconfigure the system yet.
			It is done after the parse_to_online_retain state */
	 }
	 else if (sr14.originate_flag)
	    build_event(E_ORIG,NO_DIAL);
	 else
	    build_event(E_ANSW,UNUSED);
	 break;

      default:
	 error_occurred = TRUE;
	 return;
   }

   send_ok = FALSE;
   on_line_command = FALSE;

   system_reconfigure();
   autobaud_off();
}

#endif

/*******************************************************************************
/
/     Routine:       at_P
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects pulse dialing.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.pulse
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_P(void)
{
   sr14.pulse = TRUE;
}


/*******************************************************************************
/
/     Routine:       at_Q
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the result code display option
/
/                    ATQ   0 - Result codes enabled
/                          1 - Result codes disabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.disable_result_code, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_Q(ubyte *param_ptr)
{
   if (voice_cmd_set == TIA_IS_101)
   {
      return;
   }

   if (*param_ptr == 0)
      sr14.disable_result_code = FALSE;
   else if (*param_ptr == 1)
      sr14.disable_result_code = TRUE;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_S
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:  This Routine selects a register for next read or write
/                    operation. It will allow any value to be selected even
/                    if the register does not exist.
/
/                    ATS   0 - 27,30,37,63,91,95...
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  current_register
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_S(ubyte *param_ptr)
{
   current_register = *param_ptr;
}

/*******************************************************************************
/
/     Routine:       at_equal
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine will change the selected register value.
/
/                    ATS   0 - 27,30,37,63,91,108,109,110...
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  current_register
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_equal(ulong *param_ptr)
{
   ubyte num;

   /* Can't set some S-Regs in Voice mode */
	 if((*param_ptr) && (current_register))
	 {
	    if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101) &&
	     ((current_register == 0) || (current_register == 10)))
	    {
	     error_occurred = TRUE;
	  return;
	    }
	 }
   if ((current_register == 19) || (current_register == 20))
   {
      error_occurred = TRUE;
      return;
   }

/* change 63 to 33(sleep timer) */
   if ((current_register > 27) && (current_register != 30) &&
      (current_register != 37) && (current_register != 33) &&
      (current_register != 91) && (current_register != 92) &&
      (current_register != 108) && (current_register != 109) &&
      (current_register != 110) &&
      (!((current_register >= 112) && (current_register <= 118))))
   {
      error_occurred = TRUE;
      return;
   }

   num = (ubyte)*param_ptr;

   if (error_occurred == TRUE)
   {
      /* If value is greater than 255, and register is bit mapped then
	 return error. Else set value entered to 255 */
      if ((current_register == 14) || (current_register == 16) ||
	 (current_register == 21) || (current_register == 22) ||
	 (current_register == 23) || (current_register == 27))
      {
	 return;
      }
      else
      {
	 num = 255;
	 error_occurred = FALSE;
      }
   }

   /* Else check the range of the input value */
   chk_sreg_range(num);

   if ((current_register == 7) || (current_register == 9) || (current_register == 10) ||
      (current_register == 63) || (current_register == 91) || (current_register == 108))
   {
      if (sr27.leased_line == TRUE)
      {
	 modem_set_parameters(s[9],s[7],255,v32_retrain,s[63],
	    receive_threshold,s[108]);
	 modem_speaker(OFF);
      }
      else
	 modem_set_parameters(s[9],s[7],s[10],v32_retrain,s[91],
		receive_threshold,s[108]);
   }

   /* Need to turn on or turn off the auto-answer LED depending upon the
      value of s[0]. */
   if (current_register == 0)
   {
      if (num > 0)
	 modem_aa_led(ON);
      else
	 modem_aa_led(OFF);
   }
}


/*******************************************************************************
/
/     Routine:       chk_sreg_range
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine checks the input value against the accepted
/                    ranges for the selected S register.
/
/     Input Parameters: ubyte num - value to be checked
/
/     Output Parameters: none
/
/     Global Variables Changed:  selected register
/
/     Users:   at_equal
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void chk_sreg_range(ulong num)
{
   ulong count,i;


	switch (current_register)
	{ /*SLei added*/
		case 0:
		case 6:
		case 7:
		case 8:
		case 10:
		case 11:
		case 91:
		case 92:
			CountryDependSRegRangeCheck( (ubyte)num);
			break;
		default:
			count = s_range[current_register][0];
	   	i=1;
/* IAR compiler error  - */

			if (count == 0)
	   	{
	   		error_occurred = TRUE;
				return;
	   	}

	   	i=1;
			while (count != 0)
	   	{
	   		if ((s_range[current_register][i++] <= num) &&
	   		(num <= s_range[current_register][i++]))
	      	{
	      		*srptr[current_register] = (ubyte)num;
	   			return;
	      	}
	   		count--;
	   	}

	/* If value entered is greater then maximum allowed value need to set the
	      S register to the max value   */
			i--;
	   	if (num > s_range[current_register][i])
	   		*srptr[current_register] = s_range[current_register][i];

	   /* If value entered is less then minimum allowed value need to set the
	   S register to the min value   */
	   	if (num < s_range[current_register][1])
	   		*srptr[current_register] = s_range[current_register][1];
	}
}


/*******************************************************************************
/
/     Routine:       at_quest
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine reads the selected register and will
/                    display it to the user.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  none
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_quest(void)
{
   ubyte *string;

   /* If register selected is not inplimented then return 000 to the terminal */
/* change 63 to 33(sleep timer), s63 not in use */
   if ((current_register > 27) && (current_register != 30) &&
      (current_register != 37) && (current_register != 33) &&
      (current_register != 91) && (current_register != 92) &&
      (current_register != 108) && (current_register != 109) &&
      (current_register != 110) && (current_register != 112) &&
      (!((current_register >= 112) && (current_register <= 118))))
      string = d_to_a(0);
   else
      string = d_to_a(*srptr[current_register]);

   output_info(string,(ubyte)sr14.verbose_form);
}


/*******************************************************************************
/
/     Routine:       at_T
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects tone dialing.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.pulse
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_T(void)
{
   sr14.pulse = FALSE;
}

/*******************************************************************************
/
/     Routine:       at_V
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects the result code format.
/
/                    ATV   0 - Displayed in numeric form
/                          1 - Displayed in verbose form
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr14.verbose_form, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
extern ubyte numeric_response;
void at_V(ubyte *param_ptr)
{
   switch (*param_ptr)
   {
      case 0:
	 sr14.verbose_form = FALSE;
			numeric_response = FALSE;
	 break;

      case 1:
	 sr14.verbose_form = TRUE;
			numeric_response = TRUE;
	 break;

      default:
	 error_occurred = TRUE;
	 return;
   }
}

/*******************************************************************************
/
/     Routine:       at_W
/
/     Author:        RSA
/
/     Creation Date: 07/17/91
/
/     Description:   This Routine will determine the modems connect message
/
*******************************************************************************/
void at_W(ubyte *param_ptr)
{
	if (*param_ptr <= 4)
      atW = *param_ptr == 2 ? 3 : *param_ptr; // temporary hack: ATW2 appears to surpress "CONNECT"
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_X
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine selects tone detection options and the
/                    associated result codes.
/
/                    ATX   0 - Result codes 0-4 enabled. Busy and dial tone
/                              detect disabled
/                          1 - Result codes 0-4,10 enabled. Busy and dial tone
/                              detect disabled
/                          2 - Result codes 0-6,10 enabled. Busy detect disabled
/                              dial tone detect enabled
/                          3 - Result codes 0-5,7,10 enabled. Busy detect enabled
/                              dial tone detect disabled
/                          4 - Result codes 0-7,10 enabled. Busy and dial tone
/                              detect enabled
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr22.busy_enable, sr22.dialtone_enable,
/               sr22.enable_result5, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_X(ubyte *param_ptr)
{
#if 0
    if (voice_cmd_set == TIA_IS_101)
    {
	return;
    }
#endif

   /* What is the AT command input? */
   switch (*param_ptr)
   {
      case 0:
	 sr22.busy_enable = FALSE;
	 sr22.dialtone_enable = FALSE;
	 sr22.enable_result5 = FALSE;
	 break;

      case 1:
	 sr22.busy_enable = FALSE;
	 sr22.dialtone_enable = FALSE;
	 sr22.enable_result5 = TRUE;
	 break;

      case 2:
	 sr22.busy_enable = FALSE;
	 sr22.dialtone_enable = TRUE;
	 sr22.enable_result5 = TRUE;
	 break;

      case 3:
	 sr22.busy_enable = TRUE;
	 sr22.dialtone_enable = FALSE;
	 sr22.enable_result5 = TRUE;
	 break;

      case 4:
	 sr22.busy_enable = TRUE;
	 sr22.dialtone_enable = TRUE;
	 sr22.enable_result5 = TRUE;
	 break;

      default:
	 error_occurred = TRUE;
	 return;
   }

   valueX = *param_ptr;
}

/*******************************************************************************
/
/     Routine:       at_Y
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine sets long space disconnect option
/
/                    ATY   0 - Disable long space disconnect
/                          1 - Enable long space disconnect
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  sr21.long_space_discon, error_occurred
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_Y(ubyte *param_ptr)
{
   /* Verify input bounds */
   if (*param_ptr == 0)
      sr21.long_space_discon = FALSE;
   else if (*param_ptr == 1)
      sr21.long_space_discon = TRUE;
   else
      error_occurred = TRUE;
}

/*******************************************************************************
/
/     Routine:       at_Z
/
/     Author:        RSA
/
/     Creation Date: 06/17/91
/
/     Description:   This Routine recalls stored profile
/
/                    ATZ   0 - Recall stored profile 0
/                          1 - Recall stored profile 1
/                          2 - Recall stored profile 2
/
/     Input Parameters: pointer to the byte numeric value of the AT comand.
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
extern ubyte ext_DspMemErrorFlag;
extern void  auto_config_ms(void);
extern uword modem_eeprom_checksum(void);

void at_Z(ubyte *param_ptr)
{
   ubyte value;
   uword val;

   /* Profile ZERO counts */
   if (*param_ptr < NUMBER_OF_PROFILES)
   {


#if TIES_HAYES_ESCAPE

	/* If a test is currently running then need to terminate it, for at&t1, +++, at, atz */
	if (test_in_progress )
	{
/*            test_in_progress = FALSE;   */

/* should return OK after terminating test */
	    /*build_event(E_HANGUP,NONE);*/
				build_event(E_HANGUP,OK);
	}
	/* If modem is online, need to hangup the connection */
	if (!hook || on_line_command || ( ties_esc_state == ESC_DONE ))
	{
	    if ( dte_mode != ACU )
	    {
		if ( !on_line_command )
		{
		    send_ok = TRUE;
		    ties_esc_state = 'H';
		    error_occurred = TRUE;
		    dte_mode = ACU;
		}
	    }
	    hangup_connection(NONE);

	    user_initiated_hangup = TRUE;
	    at_z_command = TRUE;
		at_h_command = TRUE;
	}
#else
      /* If a test is currently running then need to terminate it */
      if (test_in_progress)
/* should return OK after terminating test */
		build_event(E_HANGUP,OK);

      /* If modem is online, need to hangup the connection */
      if (!hook || on_line_command)
      {
	 build_event(E_HANGUP,OK);
	 user_initiated_hangup = TRUE;
	 at_z_command = TRUE;
      }

#endif

#if INTERNATIONAL_CODE == 1
         set_loc_line_relay(ON_HOOK);
         set_safe1_en_relay(ACTIVATE);	/* mh103197 output = HI */
    		set_shunt_relay(ACTIVATE);
			st_crnt_boost1 = 0;
#else
         set_safe1_en_relay(ACTIVATE);	/* mh103197 output = HI */
#endif

		if (Default_Country == 0xFF) {
   		modem_read_data(COUNTRY_CODE,COUNTRY_CODE_SIZE,&CountryInfo);

         if(CountryInfo > MAX_COUNTRY_CODE )  {
				CountryInfo = 0;

      		modem_write_data(COUNTRY_CODE,COUNTRY_CODE_SIZE,&CountryInfo);

/* write back the checksum */
            val = modem_eeprom_checksum();

				value = val;
            modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,&value);

				value = val >> 8;
            modem_write_data( (CHECKSUM_ADDR+1),CHECKSUM_SIZE,&value);
         }

		}
		else {
#ifndef __riscos
			CountryInfo = Default_Country;
#endif
		}

	acu_load_defaults(AT_Z_COMMAND);

	retrieve_profile(*param_ptr,COMMAND);
		  operating_mode = slN;
    }
    else
	error_occurred = TRUE;

/* if ext dsp ram does not exist, autoconfig ms paras */
   auto_config_ms();
	country_area_code1 = cntry_list[CountryInfo].cntry_areacode2;
	/* KJB 980818 - changed to get Sweden to pass all Scandinavia */
	if(country_area_code1 == Denmark_a_code1 || country_area_code1 == Sweden_a_code1)
	   length_of_dialtone = 124;       /* Length of dialtone needed to be detected */
	else
	   length_of_dialtone = 100;       /* Length of dialtone needed to be detected */
}

void plus_ms(ubyte *param_ptr)
{
	ubyte data,count;
	ulong data1=0;

	data = *param_ptr;

	count = 0;

	if ((data == 'V') ||
       ((*param_ptr == 'X') && (*(param_ptr+1) == '2') &&
       (*(param_ptr+2) == ',')))
	{
        if (data == 'V')
        {
           param_ptr++;
           /* don't accept VX2 -- Lowercase 'x' allows rejection of VX2 */
           if ((*param_ptr == 'X') && (*(param_ptr+1) == '2') &&
              (*(param_ptr+2) == ','))
              *param_ptr = 'x';
         }

		while (*param_ptr != ',')
		{

			data1 = data1 << 8;
			data1 |= *param_ptr;
			param_ptr++;
			count ++;
			if(count >= 4)
				break;
		}

/*mod mode*/
		switch (data1)
		 {
#if MODEM_V90_MODE == 1
			case '90':
					ms_mode = V90;
					v34_bis_mode = 1;
         			break;
#endif

#if (DSP_SERIES == 408)
#if MODEM_X2_MODE == 1
			case 'X2':
					ms_mode = VX2;
					v34_bis_mode = 1;
				break;
#endif
#endif
			case '34B':
					ms_mode = V34;
					v34_bis_mode = 1;
				break;

			case '34BS':
					ms_mode = V34S;
					v34_bis_mode = 1;

				break;

			case '34S':
					ms_mode = V34S;
					v34_bis_mode = 0;
				break;


			case '34':
					ms_mode = V34;
					v34_bis_mode = 0;

				break;

			case '32B':
					ms_mode = V32BIS;
					v34_bis_mode = 0;
				break;

			case '32':
					ms_mode = V32;
					v34_bis_mode = 0;
				break;

			case '22B':
					ms_mode = V22BIS;
					v34_bis_mode = 0;
			break;

			case '22':
					ms_mode = V22;
					v34_bis_mode = 0;

				break;

			case '23C':
					ms_mode = V23_ADX;
					v34_bis_mode = 0;

				break;

			case '21':
					ms_mode = V21;
					v34_bis_mode = 0;
				break;


			default: error_occurred = TRUE;
						v34_bis_mode = 0;
				break;


		  }


		param_ptr++;
		data1 = 0;
		count = 0;
/*auto mode */

		while (*param_ptr != ',')
		{
			count ++;
			data1 = data1 << 8;
			data1 |= *param_ptr;
			param_ptr++;

			if (count >= 2)
				break;

		}

		switch (data1)

		 {
			case '0':

				N = 0;
				automode = 0;

#if MODEM_X2_MODE == 1
				if ((ms_mode == VX2)||(ms_mode == V90))
					automode = 2;
				else
#endif
				if ((ms_mode == V34)|| (ms_mode == V34S))
					automode = 2;
				break;

			case '1':

				N = 1;
				automode = 1;
#if MODEM_X2_MODE == 1
				if ((ms_mode == VX2)||(ms_mode == V90))
					automode = 3;
				else
#endif
				if ((ms_mode == V34)|| (ms_mode == V34S))
					automode = 3;

				break;

			default: error_occurred = TRUE;
				return;

		 }

		param_ptr++;
		data1=0;
		count = 0;

		while (*param_ptr != ',')
		{
			count ++;
			if(count <=4 )
			{
				data1 = data1 << 8;
				data1 |= *param_ptr;
			}
				param_ptr++;

			if (count >= 6)
				break;

		}

/*min speed */

		switch (data1)

		 {

			case '0':
			case '300':
/* #if MODEM_X2_MODE == 1
				ms_min_rate = BPS300;
				ms_min_speed = BPS33333MIN;
#else */
				ms_min_rate = BPS300;
				ms_min_speed = BPS2400MIN;
/* #endif */
				break;

			case '1200':

				if( count == 5)
				{
					ms_min_rate = BPS12000;
					ms_min_speed = BPS12000MIN;
				}
				else

				{
					ms_min_rate = BPS1200;
					ms_min_speed = BPS2400MIN;
				}
				break;


			case '2400':
				if (count == 5)
				{
					ms_min_rate = BPS24000;
					ms_min_speed = BPS24000MIN;
				}
				else
				{
					ms_min_rate = BPS2400;
					ms_min_speed = BPS2400MIN;
				}
				break;

			case '4800':
#if MODEM_X2_MODE == 1
				if (count == 5)
				{
					ms_min_rate = BPS48000;
					ms_min_speed = BPS48000MIN;
				}
				else
#endif
				{
					ms_min_rate = BPS4800;
					ms_min_speed = BPS4800MIN;
				}

				break;

			case '7200':
				ms_min_rate = BPS7200;
				ms_min_speed = BPS7200MIN;

				break;

			case '9600':
				ms_min_rate = BPS9600;
				ms_min_speed = BPS9600MIN;

				break;


			case '1440':
				if(count == 5)
				{
					ms_min_rate = BPS14400;
					ms_min_speed = BPS14400MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '1680':
				if(count == 5)
				{
					ms_min_rate = BPS16800;
					ms_min_speed = BPS16800MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '1920':
				if(count == 5)
				{
					ms_min_rate = BPS19200;
					ms_min_speed = BPS19200MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '2160':
				if(count == 5)
				{
					ms_min_rate = BPS21600;
					ms_min_speed = BPS21600MIN;
				}
				else
					error_occurred = TRUE;

				break;


			case '2640':

				if(count == 5)
				{
					ms_min_rate = BPS26400;
					ms_min_speed = BPS26400MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '2880':

				if(count == 5)
				{
					ms_min_rate = BPS28800;
					ms_min_speed = BPS28800MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '3120':

				if(count == 5)
				{
					ms_min_rate = BPS31200;
					ms_min_speed = BPS31200MIN;
				}
				else
					error_occurred = TRUE;


				break;


			case '3360':
				if(count == 5)
				{
					ms_min_rate = BPS33600;
					ms_min_speed = BPS33600MIN;
				}
				else
					error_occurred = TRUE;

				break;
#if MODEM_X2_MODE == 1
			case '3333':
				if(count == 5)
				{
					ms_min_rate = BPS33333;
					ms_min_speed = BPS33333MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '3733':
				if(count == 5)
				{
					ms_min_rate = BPS37333;
					ms_min_speed = BPS37333MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '4133':
				if(count == 5)
				{
					ms_min_rate = BPS41333;
					ms_min_speed = BPS41333MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '4266':
				if(count == 5)
				{
					ms_min_rate = BPS42666;
					ms_min_speed = BPS42666MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '4400':
				if(count == 5)
				{
					ms_min_rate = BPS44000;
					ms_min_speed = BPS44000MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '4533':
				if(count == 5)
				{
					ms_min_rate = BPS45333;
					ms_min_speed = BPS45333MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '4666':
				if(count == 5)
				{
					ms_min_rate = BPS46666;
					ms_min_speed = BPS46666MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '4933':
				if(count == 5)
				{
					ms_min_rate = BPS49333;
					ms_min_speed = BPS49333MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '5066':
				if(count == 5)
				{
					ms_min_rate = BPS50666;
					ms_min_speed = BPS50666MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '5200':
				if(count == 5)
				{
					ms_min_rate = BPS52000;
					ms_min_speed = BPS52000MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '5333':
				if(count == 5)
				{
					ms_min_rate = BPS53333;
					ms_min_speed = BPS53333MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '5466':
				if(count == 5)
				{
					ms_min_rate = BPS54666;
					ms_min_speed = BPS54666MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '5600':
				if(count == 5)
				{
					ms_min_rate = BPS56000;
					ms_min_speed = BPS56000MIN;
				}
				else
					error_occurred = TRUE;
				break;
			case '5733':
				if(count == 5)
				{
					ms_min_rate = BPS57333;
					ms_min_speed = BPS57333MIN;
				}
				else
					error_occurred = TRUE;
				break;
#endif
			default: error_occurred = TRUE;
				return;
		  }

		param_ptr++;
		data1=0;
		count=0;

		while ((*param_ptr != NULL) && (*param_ptr >= 0x30) && (*param_ptr <= 0x39))
		{
			count ++;
			if(count <=4 )
			{
				data1 = data1 << 8;
				data1 |= *param_ptr;
			}
				param_ptr++;

			if (count >= 6)
				break;
		}
/*max speed */

		switch (data1)
		 {
			case '300':
				s[37] = S37_300_BPS;
				break;

			case '1200':
				if (count == 5)
					s[37] = S37_12000_BPS;
				else
					s[37] = S37_1200_BPS;
				break;

			case '2400':
				if (count == 5)
					s[37] = S37_24000_BPS;
				else
					s[37] = S37_2400_BPS;
				break;

			case '4800':
#if MODEM_X2_MODE == 1
				if (count == 5)
					s[37] = S37_48000_BPS;
				else
#endif
					s[37] = S37_4800_BPS;
				break;

			case '7200':
				s[37] = S37_7200_BPS;
				break;

			case '9600':
				s[37] = S37_9600_BPS;
				break;

			case '1440':
				if(count == 5)
				{
					s[37] = S37_14400_BPS;
				}
				else
					 error_occurred = TRUE;

				break;

			case '1680':
				if(count == 5)
				{
					s[37] = S37_16800_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '1920':
				if(count == 5)
				{
					s[37] = S37_19200_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '2160':
				if(count == 5)
				{
					s[37] = S37_21600_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '2640':
				if(count == 5)
				{
					s[37] = S37_26400_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '2880':
				if(count == 5)
				{
					s[37] = S37_28800_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '3120':
				if(count == 5)
				{
					s[37] = S37_31200_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '3360':
				if(count == 5)
				{
					s[37] = S37_33600_BPS;
				}
				else
					error_occurred = TRUE;
				break;

#if MODEM_X2_MODE == 1
			case '3333':
				if(count == 5)
				{
					s[37] = S37_33333_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '3733':
				if(count == 5)
				{
					s[37] = S37_37333_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '4133':
				if(count == 5)
				{
					s[37] = S37_41333_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '4266':
				if(count == 5)
				{
					s[37] = S37_42666_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '4400':
				if(count == 5)
				{
					s[37] = S37_44000_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '4533':
				if(count == 5)
				{
					s[37] = S37_45333_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '4666':
				if(count == 5)
				{
					s[37] = S37_46666_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '4933':
				if(count == 5)
				{
					s[37] = S37_49333_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '5066':
				if(count == 5)
				{
					s[37] = S37_50666_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '5200':
				if(count == 5)
				{
					s[37] = S37_52000_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '5333':
				if(count == 5)
				{
					s[37] = S37_53333_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '5466':
				if(count == 5)
				{
					s[37] = S37_54666_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '5600':
				if(count == 5)
				{
					s[37] = S37_56000_BPS;
				}
				else
					error_occurred = TRUE;
				break;

			case '5733':
				if(count == 5)
				{
					s[37] = S37_57333_BPS;
				}
				else
					error_occurred = TRUE;
				break;
#endif

			case '0':
					s[37] = 0;
				break;

			default: error_occurred = TRUE;
				return;
		  }
	}
	else
	error_occurred = TRUE;
}

void plus_ms_q(void);

void plus_ms_q(void)
{
   ubyte  string[20], i; /*fix garbage after the string problem */

	for (i=0 ; i < 20 ; i++)
	  {
	    string[i] = 0;
	  }

   switch(ms_mode)
   {
#if MODEM_V90_MODE == 1
        case  V90:
	   strcpy((char *) string, "V90");
	  break;
#endif

#if MODEM_X2_MODE == 1
     case  VX2:
	   strcpy((char *) string,VX2_MODE);
	  break;
#endif
     case  V34:
	  if(v34_bis_mode == 1)  strcpy((char *) string,V34B_MODE);
	  else                   strcpy((char *) string,V34_MODE);
	  break;

     case  V34S:
	  if(v34_bis_mode == 1)  strcpy((char *) string,V34B_MODE);
	  else                   strcpy((char *) string,V34_MODE);
	  break;

     case  V32BIS:
	  strcpy((char *) string,V32BIS_MODE);
	  break;

     case  V32:
	  strcpy((char *) string,V32_MODE);
	  break;

     case  V22BIS:
	  strcpy((char *) string,V22BIS_MODE);
	  break;

     case  V22:
	  strcpy((char *) string,V22_MODE);
	  break;

     case  V23_ADX:
	  strcpy((char *) string,V23_MODE);
	  break;

     case  V21:
	  strcpy((char *) string,V21_MODE);
	  break;

     default:
	  strcpy((char *) string,"V?");
	  break;
   }

   strcat((char *) string,",");

   switch(N)
   {
     case 0:
	 strcat((char *) string,"0,");
	 break;

     case 1:
	 strcat((char *) string,"1,");
	 break;

     default:
	 strcat((char *) string,"?,");
	 break;
   }


   switch(ms_min_rate)
   {
      case BPS300:
	  strcat((char *)string,"300,");
	  break;

      case BPS1200:
	  strcat((char *)string,"1200,");
	  break;

      case BPS12000:
	  strcat((char *)string,"12000,");
	  break;

      case BPS2400:
	  strcat((char *)string,"2400,");
	  break;

      case BPS24000:
	  strcat((char *)string,"24000,");
	  break;

      case BPS4800:
	  strcat((char *)string,"4800,");
	  break;

      case BPS7200:
	  strcat((char *)string,"7200,");
	  break;

      case BPS9600:
	  strcat((char *)string,"9600,");
	  break;

      case BPS14400:
	  strcat((char *)string,"14400,");
	  break;

      case BPS16800:
	  strcat((char *)string,"16800,");
	  break;

      case BPS19200:
	  strcat((char *)string,"19200,");
	  break;

      case BPS21600:
	  strcat((char *)string,"21600,");
	  break;

      case BPS26400:
	  strcat((char *)string,"26400,");
	  break;

      case BPS28800:
	  strcat((char *)string,"28800,");
	  break;

      case BPS31200:
	  strcat((char *)string,"31200,");
	  break;

      case BPS33600:
	  strcat((char *)string,"33600,");
	  break;
#if MODEM_X2_MODE == 1
			case BPS33333:
		strcat((char *)string,"33333,");
				break;
			case BPS37333:
		strcat((char *)string,"37333,");
				break;
			case BPS41333:
		strcat((char *)string,"41333,");
				break;
			case BPS42666:
		strcat((char *)string,"42666,");
				break;
			case BPS44000:
		strcat((char *)string,"44000,");
				break;
			case BPS45333:
		strcat((char *)string,"45333,");
				break;
			case BPS46666:
		strcat((char *)string,"46666,");
				break;
			case BPS48000:
		strcat((char *)string,"48000,");
				break;
			case BPS49333:
		strcat((char *)string,"49333,");
				break;
			case BPS50666:
		strcat((char *)string,"50666,");
				break;
			case BPS52000:
		strcat((char *)string,"52000,");
				break;
			case BPS53333:
		strcat((char *)string,"53333,");
				break;
			case BPS54666:
		strcat((char *)string,"54666,");
				break;
			case BPS56000:
		strcat((char *)string,"56000,");
				break;
			case BPS57333:
		strcat((char *)string,"57333,");
				break;
#endif

      case 0:
	  strcat((char *)string,"0,");
	  break;

      default:
	  strcat((char *)string,"?,");
	  break;
   }

   switch(s[37])
   {
      case S37_300_BPS:
	  strcat((char *)string,"300");
	  break;

      case S37_1200_BPS:
	  strcat((char *)string,"1200");
	  break;

      case S37_12000_BPS:
	  strcat((char *)string,"12000");
	  break;

      case S37_2400_BPS:
	  strcat((char *)string,"2400");
	  break;

      case S37_24000_BPS:
	  strcat((char *)string,"24000");
	  break;

      case S37_4800_BPS:
	  strcat((char *)string,"4800");
	  break;

      case S37_7200_BPS:
	  strcat((char *)string,"7200");
	  break;

      case S37_9600_BPS:
	  strcat((char *)string,"9600");
	  break;

      case S37_14400_BPS:
	  strcat((char *)string,"14400");
	  break;

      case S37_16800_BPS:
	  strcat((char *)string,"16800");
	  break;

      case S37_19200_BPS:
	  strcat((char *)string,"19200");
	  break;

      case S37_21600_BPS:
	  strcat((char *)string,"21600");
	  break;

      case S37_26400_BPS:
	  strcat((char *)string,"26400");
	  break;

      case S37_28800_BPS:
	  strcat((char *)string,"28800");
	  break;

      case S37_31200_BPS:
	  strcat((char *)string,"31200");
	  break;

      case S37_33600_BPS:
	  strcat((char *)string,"33600");
	  break;
#if MODEM_X2_MODE == 1
			case S37_33333_BPS:
		strcat((char *)string,"33333,");
				break;
			case S37_37333_BPS:
		strcat((char *)string,"37333,");
				break;
			case S37_41333_BPS:
		strcat((char *)string,"41333,");
				break;
			case S37_42666_BPS:
		strcat((char *)string,"42666,");
				break;
			case S37_44000_BPS:
		strcat((char *)string,"44000,");
				break;
			case S37_45333_BPS:
		strcat((char *)string,"45333,");
				break;
			case S37_46666_BPS:
		strcat((char *)string,"46666,");
				break;
			case S37_48000_BPS:
		strcat((char *)string,"48000,");
				break;
			case S37_49333_BPS:
		strcat((char *)string,"49333,");
				break;
			case S37_50666_BPS:
		strcat((char *)string,"50666,");
				break;
			case S37_52000_BPS:
		strcat((char *)string,"52000,");
				break;
			case S37_53333_BPS:
		strcat((char *)string,"53333,");
				break;
			case S37_54666_BPS:
		strcat((char *)string,"54666,");
				break;
			case S37_56000_BPS:
		strcat((char *)string,"56000,");
				break;
			case S37_57333_BPS:
		strcat((char *)string,"57333,");
				break;
#endif

      case 0:
	  strcat((char *)string,"0");
	  break;

      default:
	  strcat((char *)string,"?");
	  break;
   }
   output_info( string,(ubyte)sr14.verbose_form);

}

/*******************************************************************************
/
/     Routine:       at_comma
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to pause for the time specified
/                    by s8.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  timer1
/
/     Users: PARSE_CMD_TABLE_STRUCT data_commands[]
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author &       Date:   RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void at_comma(void)
{
   /* Start delay timer */
   timer1 = (dial_pause_time * 100);

   /* Change parse states to time the delay in the BG */
   st_parse.state = CMD6;  /* Parse command delay */
}

void bang_P_q(void);
void bang_P_eq(void);
void bang_P_e(ubyte *parm_ptr);

/* at!p?, band_P_q, command */
void bang_P_q(void)
{
	ubyte i,j,k, *ptr, str[16], pnp[4];

/*   read 4 pnp bytes from NVRAM */
       modem_read_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

       k=0;
       for(i=0; i<4; i++)
       {
/* convert num to ascii, put into pt[] */
         ptr = d_to_a(pnp[i]);             /* ptr =&pt[0] */

/* put pt[0],pt[1],pt[2] into pnp string */
         for(j=0; j<3; j++)
             str[k++] = *ptr++;
         str[k++] = ',';
       }
       str[--k] = 0;         /*1st decrease, then assign val, pnp[16]=0 */
       output_info(str,(ubyte)sr14.verbose_form);
}

/* at!p=? (0-255),(0-255),(0-255) command, see ac00pro.h */
void bang_P_eq(void)
{
    output_info((ubyte *)BANG_P_QUERY_INFO,(ubyte)sr14.verbose_form);
}

/* Command format ex: at!p=100,101,102,103 CR or at!p=100,,,200CR */
/* 4 fields to parse, serial #, bytes 0,1,2,3, */
void bang_P_e(ubyte *parm_ptr)
{

/*changed the check sum to 16 bit*/
    ubyte  field, value,cksum, i, pnp[4];
    uword  val;

/* get pnp vender id from NVRAM */
    modem_read_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

    for (i=0; i< 5; i++)
    {
        field = *parm_ptr++;
        value = *parm_ptr++;

        switch (field)
        {
          case 0:
/* saved values */
            modem_write_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

/* should take care of eeprom checksum */
/*changed the check sum to 16 bit*/

#if 0
            value = modem_eeprom_checksum();
            modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,&value);
#endif

   	 		cksum = CHECKSUM_ADDR;
            val = modem_eeprom_checksum();
				value = val;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

				cksum = CHECKSUM_ADDR +1;
				value = val >> 8;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

           return ;

        case 1:
             pnp[0] = value;
             break;
/* If field 1 is present,save it into pnp[0], and so on */

        case 2:
             pnp[1] = value;
             break;

        case 3:
             pnp[2] = value;
             break;

        case 4:
             pnp[3] = value;
             break;

        default:
             error_occurred = TRUE;
             return;
/* If more than 4 parameters for the command, means an error */
        }  /* switch on parameter field */
    } /* for */
    error_occurred = TRUE;
}

void bang_C_e(ubyte *parm_ptr);
void  bangC_pkt_to_from_dsp (ubyte read_dsp_mb[]);
ubyte *d_to_hex(ubyte num);

/* max 40 fields to parse */
#define PACKET_LEN_BYTE            40
/* max 20 bytes of DSP RESPONSE LENGTH */
#define DSP_RESP_LENGTH            20

void bang_C_e(ubyte *parm_ptr)
{
    ubyte  field, value, i;
    ubyte  j, k, *ptr, str[DSP_RESP_LENGTH*3];
    ubyte  dsp_response_data[DSP_RESP_LENGTH];


    for (i=0; i <= PACKET_LEN_BYTE; i++)
    {
        field = *parm_ptr++;
        value = *parm_ptr++;

        if (field)
            current_command [i] = value;
        else
/* end of cmd string*/
        {
            if (i < 4)
               {
                  error_occurred = TRUE;
                  return;
               }
            else

/* action here */
               {

                  bangC_pkt_to_from_dsp(dsp_response_data);

                  k=0;
                  for(i = 0; i < dsp_response_data[2] + 4; i++)
                  {
/* convert num to hex display, put into pt[] */
                     ptr = d_to_hex(dsp_response_data[i]);    /* ptr =&pt[0] */

/* put pt[0],pt[1] into str[] */
                     for(j=0; j<2; j++)
                     str[k++] = *ptr++;
                     str[k++] = ',';
                  }

                  str[--k] = 0;         /*1st decrease, then assign val, pnp[16]=0 */

                  output_info(str,(ubyte)sr14.verbose_form);
                  return ;
               }
         }
    } /* for */
    error_occurred = TRUE;
}

extern ubyte dsp_timer;
extern void process_wait (void);
extern ubyte cp_dsp (void);
#define DSP_TIMEOUT       100    /* waiting for DSP to READ or WRITE */
#define DSP_DONE            1

void  bangC_pkt_to_from_dsp (ubyte read_dsp_mb[])
{

   ubyte i, *temp;

   dsp_timer = DSP_TIMEOUT;
   while ( dsp_timer )
   {
   	process_wait();

	  if( cp_dsp() == DSP_DONE )
		 break;
   }

   /* Did we have trouble */
   if( !dsp_timer )
	{
		mt_driver_error_handler(current_command[0]);
	}

/* done with sending packet, now try to get dsp packet back */

   dsp_timer = DSP_TIMEOUT;
   temp = (ubyte *)(COM_RAM + DSP_CP_CMD_START);

   while ( dsp_timer )
   {
   	process_wait();

     if( *temp != 0x00)
		 break;
   }

        for (i = 0 ; i < 4 ; i++)
        read_dsp_mb [i] = *temp++;

          /*if packet_length is > zero then the data should follow */

        if (read_dsp_mb [2] > 0)
          {
               for (i = 4 ; i < read_dsp_mb[2] + 4; i++)
                    read_dsp_mb [i] = *temp++;
           }

          /*write the semaphore*/
          temp = (ubyte *) (COM_RAM + DSP_CP_CMD_START);
          *temp = 00;

          return;

}



ubyte *d_to_hex(ubyte num)
{
	ubyte i = 2;

	do {
		i--;
		pt[i] = num % 16;
      if (pt[i] < 10)
		pt[i] = pt[i] + '0';
      else
		pt[i] = pt[i] - 10 + 'A';
		num = num / 16;
	} while (i != 0);

	pt[2] = 0;
	return ((ubyte *)&pt[0]);
}


/*******************************************************************************
/
/       Routine: at_W
/
/       Author:  RSA
/
/       Creation Date:  07/17/91
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed: str_WP
/
/       Users: execute_cmd()
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description:
/
*******************************************************************************/
#ifndef __riscos
void str_WP(ubyte *param_ptr)
{

	ubyte wait,*value,wait_val;


   if (*param_ptr <= 7)
	{
		value = (ubyte*)CSCR1;
		wait = *param_ptr << 4;
	wait_val = *value & 0x0f;
	*value = wait_val | wait;
	}
	else
      error_occurred = TRUE;


}
#endif
/*******************************************************************************
/
/       Routine: at_W
/
/       Author:  RSA
/
/       Creation Date:  07/17/91
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed: str_WD
/
/       Users: execute_cmd()
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description:
/
*******************************************************************************/
#ifndef __riscos
void str_WD(ubyte *param_ptr)
{


	ubyte wait,*value,wait_val;


   if (*param_ptr <= 7)
	{
		value = (ubyte*)CSCR3;
		wait = *param_ptr << 4;
	wait_val = *value & 0x0f;
	*value = wait_val | wait;
	}
	else
      error_occurred = TRUE;


}
#endif

/*******************************************************************************
/
/       Routine: at_serial_number_amd
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_serial_number_amd(ubyte *param_ptr)
{
	ubyte i=0;
	ubyte value,serial_1[9],cksum;
	ubyte *temp1;
   uword  val;


   if (*param_ptr == NULL)
   {  error_occurred = TRUE;
      return;
   }

   for (i=0;i<8;i++)
	{
		serial_1[i] = 0x00;
	}

	temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0x7fff0);
	for(i=0;i<8;i++)
   {
	   if (*temp1 != 0x0ff)
      {  error_occurred = TRUE;
         return;
      }
      else
         temp1 +=1;

   }

   while(*param_ptr == 0x30)
       param_ptr++;

   i=0;
	while (*param_ptr != NULL)
	{

      if ((*param_ptr < 0x30) || (*param_ptr > 0x39))
      {
            error_occurred = TRUE;
            return;
      }

		if (i < 8)
			serial_1[i++] = *param_ptr;
		else
      {
         error_occurred = TRUE;
         return;
		}

		++param_ptr;
	}

	serial_1[8] = '\0';

   modem_write_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,serial_1);

   	 		cksum = CHECKSUM_ADDR;
            val = modem_eeprom_checksum();
				value = val;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

				cksum = CHECKSUM_ADDR +1;
				value = val >> 8;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

	temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);

	for(i=0;i<8;i++)
	{
		   *temp1 = 0x00;
		   temp1 += 1;
	}

	temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);

	for(i=0;i<8;i++)
	{
		   *temp1 = serial_1[i];
		   temp1 += 1;
	}

	write_serial_number_amd();
}

/*******************************************************************************
/
/       Routine: at_serial_q
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_serial_q(void)
{
	ubyte	*temp;
   ubyte i;
	ubyte str[10],str1[8];

   modem_read_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,str1);

	temp = (ubyte *) (SERIAL_NUMBER_LOCATION + 0x7fff0);
	for(i=0;i<8;i++)
	{
   	str[i] = *(temp+i);

      if (str1[i] != str[i])
      {
        error_occurred = TRUE;
        return;
      }

   }
   str[8] = '\0';
   output_info((ubyte *)str,VERBOSE_FORM);
}


/*******************************************************************************
/
/       Routine: at_serial_number_atmel
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_serial_number_atmel(ubyte *param_ptr)
{
	ubyte i=0;
	ubyte value,serial_1[9],cksum;
	ubyte *temp1;
   uword  val;

   if (*param_ptr == NULL)
   {  error_occurred = TRUE;
      return;
   }

   for (i=0;i<8;i++)
	{
		serial_1[i] = 0x00;
	}

	temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0x7fff0);
	for(i=0;i<8;i++)
   {
	   if (*temp1 != 0x0ff)
      {  error_occurred = TRUE;
         return;
      }
      else
         temp1 +=1;

   }

   while(*param_ptr == 0x30)
       param_ptr++;

   i=0;
	while (*param_ptr != NULL)
	{

      if ((*param_ptr < 0x30) || (*param_ptr > 0x39))
      {
            error_occurred = TRUE;
            return;
      }

		if (i < 8)
			serial_1[i++] = *param_ptr;
		else
      {
         error_occurred = TRUE;
         return;
		}

		++param_ptr;
	}

	serial_1[8] = '\0';

   modem_write_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,serial_1);

   	 		cksum = CHECKSUM_ADDR;
            val = modem_eeprom_checksum();
				value = val;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

				cksum = CHECKSUM_ADDR +1;
				value = val >> 8;
            modem_write_data(cksum,CHECKSUM_SIZE,&value);

	temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);

	for(i=0;i<8;i++)
	{

		   *temp1 = 0x00;
		   temp1 += 1;
	}

	temp1 = (ubyte *) (SERIAL_NUMBER_LOCATION + 0xFF2c00);

	for(i=0;i<8;i++)
	{

		   *temp1 = serial_1[i];
		   temp1 += 1;
	}

	write_serial_number_atmel();
}

/*******************************************************************************
/
/       Routine: at_amd
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_amd(void)
{
	uword i;
	output_info((ubyte *)"DOWNLOAD AMD FLASH BEGIN",VERBOSE_FORM);
	for(i=0;i<65500;i++);
	for(i=0;i<65500;i++);

	main_dnld_flash_amd();
}

/*******************************************************************************
/
/       Routine: at_atmel
/
/       Author : RSA
/
/       Creation Date: 05/07/91
/
/       Description : This routine's for download into flash
/
/       Input Parameters: none
/
/       Output Parameters: none
/
/       Global Variables Changed:  current_register
/
/       Users:  error_occurred, selected register
/
/       -------------------------------------------------------------
/       -                       Modifications                       -
/       -------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_atmel(void)
{
	uword i;
	output_info((ubyte *)"DOWNLOAD ATMEL FLASH BEGIN",VERBOSE_FORM);
	for(i=0;i<65500;i++);
	for(i=0;i<65500;i++);

	main_dnld_flash_atmel();
}

/*******************************************************************************
/
/       Routine: at*FID
/
/       Author:  RSA
/
/       Creation Date:  08/27/96
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed:
/
/       Users: execute_cmd()
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description: dsp not resp. message
/
*******************************************************************************/
void str_FID(void)
{
    ubyte str1[9];

			output_send_cr_lf();
			output_info(d_to_a(dsp_packet_id_msg[0]),UNFORMATTED);
			dsp_packet_id_msg [0] = 0x00;

   modem_read_data(SERIAL_SEC_NO_ADD,SERIAL_SEC_NO_SIZE,str1);

	str1[8] = '\0';
   output_info((ubyte *)str1,VERBOSE_FORM);
}


/*******************************************************************************
/
/       Routine: at!X= 65536(number of bytes to be transferred).
/
/       Author:  Fremont Modem
/
/       Creation Date:  08/13/97
/
/       Input Parameters: None
/
/       Output Parameter: None
/
/       Global Variables Changed:
/
/       Users: host software that downloads x2_page.c
/
/       -----------------------------------------------------------------
/       -                         Modifications                         -
/       -----------------------------------------------------------------
/
/       Author & Date:
/       Description:
/
*******************************************************************************/
#if DNLD_X2_FROM_HOST == 1
void bang_X_e(uword *parm_ptr)
{
   ulong addr_tmp1;
   uword i;
   uword data_tmp1;
   uword data_tmp2;
   uword b_count;
   uword x2_page_start_adrs;
   ubyte *string;
   ubyte dmy_mem_bank;
   ubyte *temp;
   ubyte acu_data_bits_tmp;
   ubyte acu_stop_bits_tmp;
   ubyte acu_parity_tmp;
   ubyte terminal_DTE_flowctrl_tmp;
   ubyte modem_DTE_flowctrl_tmp;

   dmy_mem_bank = *parm_ptr++;             /* skip the index byte */
   dmy_mem_bank = (*parm_ptr++) & 0x00ff ; /* get one word of data */

   /* num of words to be sent to DSP SRAM */
   *parm_ptr++;
   b_count = *parm_ptr++;

   if(*parm_ptr++ != 03)  // This cmd has only three parameters.
   {
     string = (ubyte*) WRONG_PARM1;
     output_info(string,STORED_NUM);
     ext_DspMemErrorFlag = READ_BACK_ALL_FFFF;
     acu_loop = FALSE;
     return;
   }
   else
   {
    x2_page_start_adrs =  *parm_ptr++;
   }

   acu_data_bits_tmp =            acu_data_bits;
   acu_stop_bits_tmp =            acu_stop_bits;
   acu_parity_tmp    =            acu_parity;
   terminal_DTE_flowctrl_tmp =    terminal_DTE_flowctrl;
   modem_DTE_flowctrl_tmp    =    modem_DTE_flowctrl;

   acu_data_bits         =  8;
   acu_stop_bits         =  1;
   acu_parity            =  DISABLED;
   terminal_DTE_flowctrl =  CTS_RTS;
   modem_DTE_flowctrl    =  CTS_RTS;

   dte_init(dte_init_baud,acu_data_bits,acu_stop_bits,acu_parity,terminal_DTE_flowctrl,
   terminal_DTE_xon_char,terminal_DTE_xoff_char,
   modem_DTE_flowctrl,modem_DTE_xon_char,modem_DTE_xoff_char,
   pass_flowctrl,s[2],s[12],escape_mode);

#if (PATCHLESS_EXTERNAL == 0)
   dsp_cfg(ON);
#else
   dsp_cfg(OFF);
#endif

 //   data_tmp2 = dsp_peek2(WCON_REG, 0x0000);

  /* Download boot code into internal DSP RAM */
   ext_DspMemErrorFlag  = dnld_bootx_code(bootx_array);
// After boot code is downloaded, WCON is reset to 0xFFFF;

   if(ext_DspMemErrorFlag != 0)
   {
      acu_loop = FALSE;
      return;
   }

   Change_PLL_Freqency(PLL_30MHz);  /* select 30.04 MHz */
   temp    = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);

  /* scan all 32K words of external SRAM */
   ext_DspMemErrorFlag |= dsp_ext_mem32k_test(dmy_mem_bank, B5CF_MappedTo_CS3);


   /* indicates if the external DSP SRAM exists */
   if(ext_DspMemErrorFlag != 0)
   {
    string = (ubyte*) X2_SRAM_ABSENT;
    output_info(string,STORED_NUM);
    acu_loop = FALSE;
    return;
   }
   else
   {
    string = (ubyte*) X2_SRAM_PRESENT;
    output_info(string,STORED_NUM);
   }

   string = d_to_a(dmy_mem_bank);  /* need these two lines for BA TRAN */
	output_info(string,STORED_NUM);

 /* setup bank number to access Cutlass registers */
   *PORT_e8_bank_adrs_lo = 0x00;
   *PORT_e9_bank_adrs_hi = 0x00;

   data_tmp2 = B5CF_MappedTo_CS3;

   WriteDSP_MemThruBootx(CCON_REG, data_tmp2);
   data_tmp1 = ReadDSP_MemThruBootx(CCON_REG);
   if (data_tmp1 != data_tmp2)
   {
      ext_DspMemErrorFlag |= DSP_REG_WR_RD_ERROR;
   }

 /* setup bank number to access DSP SRAM */
   *PORT_e8_bank_adrs_lo = (dmy_mem_bank & 0x00ff);
   *PORT_e9_bank_adrs_hi = (dmy_mem_bank & 0xff00) >> 8;


  /* send two bytes to dsp per write */
   addr_tmp1 = x2_page_start_adrs; /* word addressing */
   msec_counter = 0;
   while(b_count > 0)
   {
      while(dte_from_num() > 1)
      {
        data_tmp1 = dte_from_char();
        data_tmp1 = (data_tmp1 << 8) | dte_from_char();
        WriteDSP_MemThruBootx(addr_tmp1, data_tmp1);

        b_count --;
        msec_counter = 0;

        data_tmp2 = ReadDSP_MemThruBootx(addr_tmp1);

        if(data_tmp1 != data_tmp2)
        {
           ext_DspMemErrorFlag |= DSP_32K_MEM_WR_RD_ERROR2;
           b_count = 0;
           break;
        }
        addr_tmp1++;
 ///       if(b_count == 0) break;
      }

/* ---------------------------------------------------- */
// debug code.  Should never use it on half card.

//      tmp_char = (ubyte) ((b_count >> 8) & 0x00ff);
//   	outhex(tmp_char);
//      tmp_char = (ubyte) (b_count & 0x00ff);
//   	outhex(tmp_char);
//      outchar(' ');

//      tmp_char = (ubyte) ((msec_counter >> 8) & 0x00ff);
//   	outhex(tmp_char);
//      tmp_char = (ubyte) (msec_counter & 0x00ff);
//   	outhex(tmp_char);
//      outchar(' ');


//   	outchar('\r');
//	   outchar('\n');
/* ---------------------------------------------------- */

      if(msec_counter > 3000)  /* check if timeout occured */
      {
         ext_DspMemErrorFlag |= TIMEOUT_ERROR;
         acu_loop = FALSE;
         return;
      }
      process_wait();
   }

  /* End of test code, read back and compare */

  /* fill the unused area with 0x0000 */
    for (addr_tmp1 = addr_tmp1; addr_tmp1 < CONST_64K; addr_tmp1++)
    {
      WriteDSP_MemThruBootx(addr_tmp1, TWO_BYTE_ZERO);
    }
   *PORT_e8_bank_adrs_lo = 0x00;
   *PORT_e9_bank_adrs_hi = 0x00;

//   data_tmp2 = (ReadDSP_MemThruBootx(WCON_REG) & 0x000f);

//   data_tmp2 &= 0x000f;  /* clear upper 12 bits */

//   data_tmp2 |= DSP_ONE_W_STATE_FOR_8000_FFFF;
/* set one wait state for  8000-ffff */
//   WriteDSP_MemThruBootx(WCON_REG, data_tmp2);

//   data_tmp1 = ReadDSP_MemThruBootx(WCON_REG);

   *temp = RESET_DSP_AND_BOOT_FROM_FFFF; /* 0x00 */
	for(i=0;i< 0x100;i++)
     wait_a_while();
   *temp = KILL_DSP_RES_N;   /* 0x01 */
	for(i=0;i< 0xffff;i++)
     wait_a_while();

//   dsp_poke(DSP_ONE_W_STATE_FOR_8000_FFFF, WCON_REG);  /* 0x2490 */

//   acu_data_bits =            acu_data_bits_tmp;
//   acu_stop_bits =            acu_stop_bits_tmp;
//   acu_parity    =            acu_parity_tmp;
//   terminal_DTE_flowctrl =    terminal_DTE_flowctrl_tmp;
//   modem_DTE_flowctrl    =    modem_DTE_flowctrl_tmp;

//   dte_init(dte_init_baud,acu_data_bits,acu_stop_bits,acu_parity,terminal_DTE_flowctrl,
//   terminal_DTE_xon_char,terminal_DTE_xoff_char,
//   modem_DTE_flowctrl,modem_DTE_xon_char,modem_DTE_xoff_char,
//   pass_flowctrl,s[2],s[12],escape_mode);

   acu_loop = FALSE;

}
#endif


void print_dsp_version(void)
{
   ubyte *string;
   uword tmp_version;

   tmp_version = get_dsp_version();
   string = (ubyte*) DSP_FIRMWARE_VER_STRING;
   output_info(string,STORED_NUM);

   string = d_to_a_two(tmp_version>>8);
   output_info(string,UNFORMATTED);
   output_info( (ubyte *)".", UNFORMATTED);

   string = d_to_a_two(tmp_version&0xFF);
   output_info(string, UNFORMATTED);

   string = (ubyte*)MODEM_FIRMWARE_VER_STRING;
   output_info(string,UNFORMATTED);

#if (PARALLEL_MODE == 1)
   output_info( (ubyte *)" Parallel", UNFORMATTED);
#else
   output_info( (ubyte *)" Serial", UNFORMATTED);
#endif

/* shujin, 10/23/97
   for pcmcia hardware bug, need special firmware, see prll_mod.h, acu.c
*/
#if (PCMCIA_SPECIAL == 1)
   output_info( (ubyte *)" (PCMCIA) ", UNFORMATTED);
#endif

   string = (ubyte*)	SPEAKER_PHONE_VER_STRING;
   output_info(string,UNFORMATTED);
   output_info(d_to_a_two(dsp_code[6]),UNFORMATTED);
}



/*******************************************************************************
/
/	Routine: void Per_TTNR_eq(ubyte *parm_ptr)
/
/	Author : Cirrus Logic
/
/	Creation Date: 02/18/98
/
/	Description: This disables a range of values for sreg0
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/
#if INTERNATIONAL_CODE == 1
void Per_TTNR_eq(ubyte *parm_ptr)
{
	ubyte  field, value, i;
	ubyte *string;


//		string = (ubyte *)"T9";
//		output_info(string,STORED_NUM);

   for (i=0; i< 2; i++)
   {
   	field = *parm_ptr++;
      value = *parm_ptr++;
      switch (field)
      {
      	case 1:
				homg_var1.Forced_sreg0_min1 = value;
            break;
        	case 2:
				homg_var1.Forced_sreg0_max1 = value;
            break;
        	default:
            error_occurred = TRUE;
			  break;
				/* If more than 2 parameters for the command, error occurred */
        }  /* switch on parameter field */
   } /* for */
//			string = d_to_a(homg_var1.Forced_sreg0_min1);
//			output_info(string,STORED_NUM);
//			string = d_to_a(homg_var1.Forced_sreg0_max1);
//			output_info(string,STORED_NUM);
			if(homg_var1.Forced_sreg0_min1 > homg_var1.Forced_sreg0_max1)
			{
				homg_var1.Forced_sreg0_min1 = 0;
				homg_var1.Forced_sreg0_max1 = 0;
            error_occurred = TRUE;
			}

}

void Per_TTNR_q(void)
{
	ubyte *string;

	string = d_to_a(homg_var1.Forced_sreg0_min1);
	output_info(string,STORED_NUM);
	string = d_to_a(homg_var1.Forced_sreg0_max1);
	output_info(string,STORED_NUM);

//		string = (ubyte *)"T9";
//		output_info(string,STORED_NUM);
}



void bang_Tb_eq(ubyte *parm_ptr)
{
	homg_var1.disable_blacklist = *parm_ptr;
}

void bang_Tb_q(ubyte *parm_ptr)
{
	ubyte *string;
	string = d_to_a(homg_var1.disable_blacklist);
	output_info(string,STORED_NUM);

	string = (ubyte *) " NC= ";
	output_info(string,STORED_NUM);
	string = d_to_a(CountryInfo);
	output_info(string,STORED_NUM);
}

void bang_Tr_eq(ubyte *parm_ptr)
{
//	ubyte *string;
//	ubyte tmp11;

	homg_var1.Display_Rng_T = *parm_ptr;

//	string = (ubyte *)" Z0123= ";
//	output_info(string,VERBOSE_FORM);  	/* before and after */
//	tmp11 = CheckStoredNumZ0123();
//	string = d_to_a(tmp11);
//   output_info(string,STORED_NUM); // degub only j988

//	string = (ubyte *)" End Z0123 ";
//	output_info(string,VERBOSE_FORM);  	/* before and after */
}
#endif



ubyte ATDcheckforS(ubyte *ptr2)
{
	ubyte Zidx1, s_char_found1, tmp_flag2, tmp_flag3;
	ubyte	*param_ptr, tmp_result1, *ptr;
	ubyte	*string;

	param_ptr = ptr2;
	ptr = ptr2;
	s_char_found1 = 0;
	tmp_flag2 = 0;
	tmp_flag3 = 0xe0;
	tmp_result1 = ATD_IS_GOOD;
	Zidx1 = 9;
	while(*ptr2 != '\0')
	{
		if(*ptr2 == 'S')
		{
			s_char_found1 = 1;
			ptr	= ptr2;
			break;
		}
		else
			ptr2++;
	}

//   	string = (ubyte *)" s_char_found1? ";
//		output_info(string,VERBOSE_FORM);  	/* before and after */
//         	string = d_to_a(s_char_found1);
//		output_info(string,UNFORMATTED);  	/* before and after */
//   	string = (ubyte *) ptr;
//		output_info(string,VERBOSE_FORM);  	/* before and after */


//	ptr = param_ptr;
	if(s_char_found1 == 1)
	{
		if(*ptr++ == 'S')
		{
			if(*ptr == '\0')
			  Zidx1 = 0;
			else if(*ptr++ == '=')
			{
				if(*ptr > '3')
				{
					Zidx1 = N_OUT_OF_RANGE_FOR_S_DIAL; // n in Sn out of range.
				}
				else if(*ptr == '\0')
					Zidx1 = 0;
				else if((*ptr >= '0') && (*ptr <= '3'))
				{
					Zidx1 = *ptr - '0';
				}
			}
		}
	} //if(s_char_found1 == 1)
	else
		Zidx1 = S_MODIFIER_NOT_FOUND;	// S modifier not found.


//   	string = (ubyte *)" Zidx1-a ";
//		output_info(string,VERBOSE_FORM);  	/* before and after */
//         	string = d_to_a(Zidx1);
//		output_info(string,UNFORMATTED);  	/* before and after */

	if((Zidx1 >= 0) && (Zidx1 <= 3))
	{
		tmp_flag2 = (1 << Zidx1);
		tmp_flag3 = CheckStoredNumZ0123(Zidx1);
	}

//   	string = (ubyte *)" tmp_flag3 ";
//		output_info(string,VERBOSE_FORM);  	/* before and after */
//         	string = d_to_a(tmp_flag3);
//		output_info(string,UNFORMATTED);  	/* before and after */

	if(((Zidx1 >=0) && (Zidx1 <= 3) && (tmp_flag3 == tmp_flag2)) ||
		(Zidx1 == S_MODIFIER_NOT_FOUND))
	{
//   	string = (ubyte *)" atds_gd1 ";
//		output_info(string,VERBOSE_FORM);  	/* before and after */

		if( (*param_ptr == 'P') ||
		    ((*param_ptr != 'T') && (sr14.pulse == 1))
		  )/* pulse dial */
		{
//		string = (ubyte *)"A2";	  // debug1
			if(ptt_general_flags[CountryInfo].disable_pulse_dial == TRUE)
				tmp_result1 = ATDP_NOT_ALLOWED;
////	     		build_event(E_HANGUP,ERROR);
			else
				st_crnt_boost1 = SHUNT_AT_D_ONLY;

		}
		else  /* dtmf dial */
		{
			st_crnt_boost1 = SHUNT_AT_D_T;
//			string = (ubyte *)"A3";	  // debug1
		}
//		output_info(string,(ubyte)sr14.verbose_form); // debug1

	}
	else if(((Zidx1 >=0) && (Zidx1 <= 3) && (tmp_flag3 != tmp_flag2)) ||
			  (Zidx1 == N_OUT_OF_RANGE_FOR_S_DIAL))
	{
		tmp_result1 = ATDS_DIAL_ERROR;

//   	string = (ubyte *)" atds_bd1 ";
//		output_info(string,VERBOSE_FORM);  	/* before and after */
	}

	return(tmp_result1);
}
