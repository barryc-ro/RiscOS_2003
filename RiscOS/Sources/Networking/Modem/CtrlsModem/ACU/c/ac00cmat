
/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00cmat.c
/
/	Module Version: ACU 4.02
/
/	Function:	This file contains the code for the basic AT command
/			set.
/
/	Product:	ACU core code
/
/	History:	ac00cmat.c v3.90
/			ac00cmat.c v3.91
/			ac00cmat.c v3.92
/			ac00cmat.c v3.93
/			ac00cmat.c v3.94
/			ac00cmat.c v3.95
/			ac00cmat.c v3.96
/
/		Created: 10/7/91
/			10/17/91
/			11/16/91
/			12/04/91
/			1/21/92
/			3/10/92
/			1/12/93
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/       Author & Date:  RSA
/		Description:
/		Reason:
/
*****************************************************************************/

#include "sys_def.h"
#include "ee_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "acu_vce.h"
#include "mt_pro.h"
#include "resp_cod.h" /* ramn 1/12/96 */
#include "v34_rate.h" /* 3/09/96 shujin */

#include "fab.h" 	/* ramn 4/18/96 */
#include "dsp_cod.h" /* ramn 5/7/96 */
#include "ptt.h"
#include "../mt_ctls1/mt_macro.h" /* ramn 12/11/96 */

/* start change keh 12/94 => modify routines for new parser */
#if 0 /* original */
*void at_B(void);
*void at_C(void);
*void at_E(void);
*void at_F(void);
*void at_H(void);
*void at_I(void);
*void at_L(void);
*void at_M(void);
*void at_N(void);
*void at_O(void);
*void at_P(void);
*void at_Q(void);
*void at_S(void);
*void at_equal(void);
*void chk_sreg_range(ubyte);
*void at_quest(void);
*void at_T(void);
*void at_V(void);
*void at_W(void);
*void at_X(void);
*void at_Y(void);
*void at_Z(void);
*void at_comma(void);
*void get_rom_components(void);
#endif

void at_B(ubyte *);
void at_C(ubyte *);
void at_E(ubyte *);
void at_F(ubyte *);
void at_H(ubyte *);
void at_I(ubyte *);
void at_L(ubyte *);
void at_M(ubyte *);
void at_N(ubyte *);
void at_O(ubyte *);
void at_P(void);
void at_Q(ubyte *);
void at_S(ubyte *);
void at_equal(ubyte *);
void chk_sreg_range(ubyte);
void at_quest(void);
void at_T(void);
void at_V(ubyte *);
void at_W(ubyte *);
void at_X(ubyte *);
void at_Y(ubyte *);
void at_Z(ubyte *);
void str_WP(ubyte *);
void str_WD(ubyte *);

/*mrm22196*/
void plus_ms(ubyte *);

void at_comma(void);
void get_rom_components(void);
/* end change keh 12/94 => modify routines for new parser */

/*mrm22596*/
/*added the AT+MS command*/

extern void mm_dsp_version(void);

#if TIES_HAYES_ESCAPE                    /* ciy021596 */

extern void online_at_esc(void);

extern ubyte ties_esc_state;
extern ubyte dte_mode;

#define ESC_DONE     1
#define ACU          1


#endif

ubyte ms_mode;
ubyte ms_min_rate;
ubyte v34_bis_mode;

/*mrm22996*/

extern void output_send_cr_lf(void); /* ramn 3/4/96 */

uword ms_min_speed = 0;

extern ubyte ack_or_response; /* ramn 4/18/96 */
extern ubyte current_command[];
extern void send_pkt_to_dsp(void);
#define ACK 0
/*SLei added*/
extern ubyte CountryInfo; /*Shiang */
extern BlackList BlackLst[10];
extern InitiateToneATaps(void);
extern void CountryDependSRegRangeCheck(ubyte);
extern ubyte LineCurrent(void); /*SLEI 7/24/96*/
extern struct SREG22 s22orig;
/* start change keh 12/94 =>  add new parser */



/* ramn 7/31/96 */
extern   void  set_dsp_cid(ubyte); /* ramn 7/31/96 */
extern   void  set_callerid_relay(uword);
extern ubyte voice_caller_id; /*ramn 7/31/96 */
#define   CID_RELAY_OFF  0x0200 /* ramn 7/31/96 */

/* ramn 7/31/96 */
ubyte s0_value_changed = 0;
ubyte	value_of_s0_reg;

ubyte dsp_packet_id_msg[1];
extern const ubyte ati1[60];
extern const ubyte ati10[4];
/*extern const ubyte ati11[1];*/
/*******************************************************************************
/
/  Routine: at_A
/
/  Author : RSA
/
/  Creation Date: 12/07/94
/
/  Description:    This routine is called to implement the Answer command:
/                    "ATA."  The ATA command is used answer a call.
/
/  Input Parameters: none
/
/  Output Parameters: none
/
/  Global Variables Changed:  sr.27.Bell_mode, atB
/
/  Users:	execute_cmd
/
/  -------------------------------------------------------------
/  -			Modifications			                        -
/  -------------------------------------------------------------
/
/  Author & Date:   RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void at_A(void)
{
	if (CountryInfo == German){
		if (LineCurrent()){
			}
		else {
	       error_occurred = TRUE;
			 return ;
			}
		}
   /* No parameter for ATA command */
   send_ok = FALSE;

/* start TIA change 04/06/94 */
   if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
   {
       error_occurred = TRUE;
		 return; /* if voice do not execute ata,ramn 7/31/96 */
   }
/*
	ramn 7/31/96 if caller id enabled and we are going off-hook after 1 ring
	disable caller id
*/
	if((voice_caller_id != 0) && (*srptr[1] == 1))
	{
		 s0_value_changed = TRUE;
		 value_of_s0_reg = *srptr[0];
		 *srptr[0] = 1;

#if 0
       set_dsp_cid(0);
	    set_callerid_relay( CID_RELAY_OFF);	/* 7/15/96 */
		/* voice_caller_id = 0;*/
#endif
	}
/* end TIA change 04/06/94 */
   else if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
   {
/* ramn 4/18/96 */
#if DSP_CODE_INTERNAL == 1

#if CUTLASS_C6 == 1
		if(fax_class == 0)  	/* issue th v34 config packet only in data mode */
		{
	     current_command [0] = 0x90;	/* clamps the max symbol rate to < 3429 */
	     current_command [1] = 0x00;	/* hence 33.6 not possible */
  		  current_command [2] = 0x08;
	     current_command [3] = 0x00;
   	  current_command [4] = 0x79;
	     current_command [5] = 0x21;
   	  current_command [6] = 0x7f;
	     current_command [7] = 0x75;
		  current_command [8] = 0x1b;
	     current_command [9] = 0x01;
	     current_command [9] = 0x07;
	     current_command [9] = 0x00;

	     ack_or_response = ACK;
   	  send_pkt_to_dsp();
		}
#endif
#endif
       build_event(E_ANSW,UNUSED);
   }
   else
       error_occurred = TRUE;
}
/* end change keh 12/94 >  add new parser */


/*******************************************************************************
/
/	Routine: at_B
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine will select the communication mode to
/		      be used.
/	       ATB	0 - CCITT mode
/			1 - Bell mode
/			2 - V23 mode  if originating T75/R1200 BPS
/					if answering T1200/R75 BPS
/			3 - V23 mode  if originating T1200/R75 BPS
/					if answering T75/R1200 BPS
/
/   Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr.27.Bell_mode, atB
/
/	Users:	execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/   Author & Date:  RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void at_B(void)
*{
*    ubyte num;
*
*    num = a_to_d();
*    if (error_occurred == TRUE)
*        return;
#endif
/*mrm22596*/
/*removed the B command*/

void at_B(ubyte *param_ptr)
{
   ubyte num;

   /* Ubyte parameter for ATB command */

   num = *param_ptr;


   if (num <= 9)
   {
       /* See if valid value for group 1 */
       switch (num)
       {
           case 0: /* Bell 212 */
               sr27.BELL_mode = FALSE;
               atB.group1 = num;
               atB.group3 = 15;
               break;

           case 1: /* V.22 */
               sr27.BELL_mode = TRUE;
               atB.group1 = num;
               atB.group3 = 16;
               break;

           case 2: /* V.23 */
           case 3: /* V.23R */
               if (acu_cfg.v23)
                   atB.group1 = num;
               else
                   error_occurred = TRUE;
               break;

           default: error_occurred = TRUE;
       }
   }

   else
   {
       error_occurred = TRUE;
   }

}


/*******************************************************************************
/
/	Routine: at_C
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the carrier control option
/	       ATC	0 - transmit carrier always off  (not supported)
/			1 - normal transmit carrier switching
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0 /* original */
*void at_C(void)
*{
*    ubyte num;
*
*    num = a_to_d();
*
*    if (num != 1)
*        error_occurred = TRUE;
*}
#endif
void at_C(ubyte *param_ptr)
{

   /* Ubyte parameter for ATC command */
   if (*param_ptr != 1)
       error_occurred = TRUE;

}
/* end change keh 12/94 => modify routines for new parser */


/* start change keh 12/94 >  add new parser */
/*******************************************************************************
/
/  Routine: at_D
/
/  Author : RSA
/
/  Creation Date: 12/07/94
/
/  Description:    This routine is called to implement the Dial command:
/                    "ATD."  The ATD command is used originate a call.
/
/  Input Parameters: *param_ptr - pointer to the command's parameter
/                      (a NULL terminated string)
/
/  Output Parameters: none
/
/  Global Variables Changed:
/
/  Users:	execute_cmd
/
/  -------------------------------------------------------------
/  -			Modifications			                        -
/  -------------------------------------------------------------
/
/  Author & Date:   RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void at_D(ubyte *param_ptr)
{
	if (CountryInfo == German){
		s22orig = sr22;
		if (LineCurrent()){
			if (*param_ptr == NULL){
		  		sr22.busy_enable = FALSE;
				sr22.dialtone_enable = FALSE;
				sr22.enable_result5 = FALSE;
				}
			}
		else {
	       error_occurred = TRUE;
			 return ;
			}
		}
   /* Save the Dial String Buffer for later use */
   acu_dial_string_ptr = param_ptr;
   send_ok = FALSE;

/*   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && (!test_in_progress) && !on_line_command))
*/	/* ramn 2/25/96 */

   if (fax_connected ||
       (((sr27.comm_mode == ASYNC) || (sr27.comm_mode == SYNC_NORMAL))
       && !test_in_progress))
   {
		if(on_line_command)
		{
			if(fax_class == 8)
			{
				st_parse.type = AT_OFFLINE;
			}
			else
			{
   	   	error_occurred = TRUE;
				return;
			}
		}



/* ramn 4/18/96 */
#if DSP_CODE_INTERNAL == 1
#if CUTLASS_C6 == 1
		if(fax_class == 0)  	/* issue th v34 config packet only in data mode */
		{
	     current_command [0] = 0x90;	/* clamps the max symbol rate to < 3429 */
	     current_command [1] = 0x00;	/* hence 33.6 not possible */
  		  current_command [2] = 0x08;
	     current_command [3] = 0x00;
   	  current_command [4] = 0x79;
	     current_command [5] = 0x21;
   	  current_command [6] = 0x7f;
	     current_command [7] = 0x75;
		  current_command [8] = 0x1b;
	     current_command [9] = 0x01;
	     current_command [9] = 0x07;
	     current_command [9] = 0x00;

	     ack_or_response = ACK;
   	  send_pkt_to_dsp();
		}
#endif
#endif
       build_event(E_ORIG,UNUSED);
   }
   else
       error_occurred = TRUE;
}
/* end change keh 12/94 >  add new parser */


/*******************************************************************************
/
/	Routine: at_E
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the command character echo option
/	       ATE	0 - off-line character echo disabled
/			1 - off-line character echo enabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr14.echo_cmd_flag, error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void at_E(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*	switch (num)
*	{
*		case 0: sr14.echo_cmd_flag = FALSE;
*			modem_serial_echo(OFF);
*			break;
*
*		case 1: sr14.echo_cmd_flag = TRUE;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
#endif
void at_E(ubyte *param_ptr)
{
    /* Ubyte parameter for ATE command */
    switch (*param_ptr)
    {
        case 0:
            sr14.echo_cmd_flag = FALSE;
           /* modem_serial_echo(OFF);*/ /* ramn 9/20/96 */
            break;

        case 1:
            sr14.echo_cmd_flag = TRUE;
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: at_F
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the data character echo option
/	       ATF	0 - on-line character echo enabled (not supported)
/			1 - on-line character echo disabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_F(ubyte *param_ptr)
{
/* start change keh 12/94 => modify routines for new parser */
#if 1
    /* Ubyte parameter for ATF command */
    if (*param_ptr != 1)
        error_occurred = TRUE;

#else
    ubyte num;

	num = a_to_d();

	if (num != 1)
		error_occurred = TRUE;
#endif
/* end change keh 12/94 => modify routines for new parser */
}


/*******************************************************************************
/
/	Routine: at_H
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine controls the switch hook.
/	       ATH	0 - execute hang up process
/			1 - go off hook, but no handshake
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, at_h_command
/
/	Users: execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void at_H(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*	switch (num)
*
#endif

void at_H(ubyte *param_ptr)
{
    /* Ubyte parameter for ATH command */
    switch (*param_ptr)
/* end change keh 12/94 => modify routines for new parser */
    {
        case 0:
#if TIES_HAYES_ESCAPE                    /* ciy021596 */

            {
                if (test_in_progress)
                {
                    build_event(E_HANGUP,NONE);
                    if ( dte_mode != ACU )
                    {
                        ties_esc_state = 'H';
                        error_occurred = TRUE;
                    }
                }
                else
                {
                    if ( (on_line_command && !test_in_progress && fax_class == 0 )
                        || ( ties_esc_state == ESC_DONE ) )
                    {
                        if ( !on_line_command )
                            {
                                send_ok = TRUE;
                                ties_esc_state = 'H';
                                error_occurred = TRUE;
                            }
                        hangup_connection(NONE);
                    }
                    else
                        build_event(E_HANGUP,NONE);
                }
            }
#else
            /* Queue E_HANGUP event to terminate the test */
            if (test_in_progress)
                build_event(E_HANGUP,NONE);
/* start change keh 3/23/95 => no longer have long loop for hangup */
            /* Test state will hangup link based on at_h_command */
            else
/* end change keh 3/23/95 => no longer have long loop for hangup */

            /* Terminate the link */
            if (on_line_command && !test_in_progress && fax_class == 0)
                hangup_connection(NONE);
            else
                build_event(E_HANGUP,NONE);
#endif
            at_h_command = TRUE;
            user_initiated_hangup = TRUE;
            break;

        case 1:
/* start change 4/6/94 */
            if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101))
            {
                error_occurred = TRUE;
                return;
            }
/* end change 4/6/94 */
            off_hook();

#if 0
            modem_td_relay(ON);
            if (sr21.auxiliary_relay_ctrl)
                modem_AA1_relay(ON);
#endif /* ramn 1/17/96 */
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}

/*******************************************************************************
/
/	Routine: at_I
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is uded to display hardware description.
/	       ATI	0 - Display product code
/			1 - Calculate and display ROM checksum
/			2 - Verify ROM checksum
/			3 - Display part numbers and revision levels
/			4 - Display modem capabilities
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void at_I(void)
*{
*	ubyte num;
*	ubyte *string;
*	ubyte checksum;
*
*	num = a_to_d();
*/* JAY - TIA Conversion Start 1/20/1994 */
*        if (voice_cmd_set == TIA_IS_101)
*            error_occurred = TRUE;
*/* JAY - TIA Conversion End 1/20/1994 */
*
*	if (error_occurred == TRUE)
*		return;
*
*	switch (num)
*
#endif

void at_I(ubyte *param_ptr)
{
	ubyte *string,*temp;
	ubyte checksum,val1,val2;
	ubyte xx[60];


/* JAY - TIA Conversion Start 1/20/1994 */
    if (voice_cmd_set == TIA_IS_101)
    {
        error_occurred = TRUE;
        return;
    }
/* JAY - TIA Conversion End 1/20/1994 */

    /* Ubyte parameter for ATI command */
    switch (*param_ptr)
/* end change keh 12/94 => modify routines for new parser */
    {
       case 0:
			string = modem_product_code();
         output_info(string,(ubyte)sr14.verbose_form);
       break;

		case 1:
#if 0  /* ramn 1/12/96 cirrus ati1 gives firmware ver # */
			checksum = modem_rom_checksum();
			string = d_to_a(checksum);
			output_info((ubyte *)MODEM_FIRMWARE_VER_STRING,(ubyte)sr14.verbose_form);

#endif
/*mrm21296*/

			mm_dsp_version();
			output_send_cr_lf();  /* ramn 3/4/96 */


		break;

        case 2:
            if (!modem_rom_test())
                string = (ubyte *)"ERROR";
            else
                string = (ubyte *)"OK";

            output_info(string,(ubyte)sr14.verbose_form);
            break;

        case 3:
			/* ramn 1/12/96. cirrus ati3 is chip set name and number */
			/*get_rom_components();*/
				output_info((ubyte *)MODEM_CHIPSET_NAME,(ubyte)sr14.verbose_form);
            break;

        case 4:
#if 0
				string = modem_capability_descript();
            output_info(string,(ubyte)sr14.verbose_form);
#endif /* ramn 6/27/96 */
            break;


        case 5:

			string = (ubyte*) HOSTIF;

			output_info(string,STORED_NUM);
			#ifdef __riscos
			output_info((ubyte *) " Expansion bus",STORED_NUM);
			#else
			temp = (ubyte *) HICSR;
/* if ring not present then value is 65 if ring presnet value is 25 */
/* ramn 5/7/96 */
			if ((*temp == 0x65) || (*temp == 0x25))
			{
			 	string = (ubyte*) PARALLEL;
				output_info(string,UNFORMATTED);

			}
/* if ring not present then value is 71 if ring presnet value is 31 */
/* ramn 5/7/96 */
				else if ((*temp == 0x71) || (*temp == 0x31))

			{
				string = (ubyte*) SERIAL;
				output_info(string,UNFORMATTED);

			}

			string = (ubyte*) PMMODE;
			output_info(string,STORED_NUM);
			temp = (ubyte *) CSCR1;



			val1= *temp & 0x0f;
			val2 = *temp;
			val2= val2>>4;

			if(val1==2)
			  val1=32;
			if(val1==1)
			  val1=16;
			if(val1==0)
			  val1=8;


			string = d_to_a(val1);
			output_info(string,UNFORMATTED);

			string = (ubyte*) BIT;
			output_info(string,UNFORMATTED);


			string = d_to_a(val2);
			output_info(string,UNFORMATTED);


			string = (ubyte*) WAIT;
			output_info(string,UNFORMATTED);





			string = (ubyte*) DMMODE;
			output_info(string,STORED_NUM);
			temp = (ubyte *) CSCR3;



			val1= *temp & 0x0f;
			val2 = *temp;
			val2= val2>>4;

			if(val1==2)
			  val1=32;
			if(val1==1)
			  val1=16;
			if(val1==0)
			  val1=8;


			string = d_to_a(val1);
			output_info(string,UNFORMATTED);

			string = (ubyte*) BIT;
			output_info(string,UNFORMATTED);


			string = d_to_a(val2);
			output_info(string,UNFORMATTED);


			string = (ubyte*) WAIT;
			output_info(string,UNFORMATTED);

			string = (ubyte*) DSP_CODE_MODE;		/* ramn 5/7/96 */
			output_info(string,STORED_NUM);	  /* indicates the location of
							DSP code int ROM or ext SRAM */
			#endif

            break;


        case 6: /*SLei added */
			CountryInfo &= 0x0f;
			if (CountryInfo == 0) {
				string = (ubyte *) US;
				}
			else {
				if (CountryInfo == 1) {
					string = (ubyte*) JAPAN;
					}
				else {
					if (CountryInfo == 2) {
						string = (ubyte*) ENGLAND;
						}
					else {
						if (CountryInfo == 3) {
							string = (ubyte*) GERMANY;
							}
						else {
							if (CountryInfo == 4) {
								string = (ubyte*) FRANCE;
								}
							else {
								if (CountryInfo == 5) {
									string = (ubyte*) NETHERLAND;
									}
								else {
									if (CountryInfo == 6) {
										string = (ubyte*) ITALY;
										}
									else {
										string = (ubyte *) US; /*Default Country*/
										}
									}
								}
							}
						}
					}
				}
			output_info(string,STORED_NUM);
			break;
        case 7: /*SLei added */
				for (val1=0; val1 < 60 && ati1[val1] != NULL; val1++){
					xx[val1] = ati1[val1];
					}
				if (val1 < 60){
					xx[val1]=0;
					}
				else {
					xx[59]=0;
					}
				string = (ubyte*)xx;
				output_info(string,STORED_NUM);
				break;
        case 10: /*SLei added */
			   val2 = ati10[0];
				string = d_to_a(val2);
				output_info(string,STORED_NUM);
				break;
        case 11: /*SLei added */
			   val2 = ati10[1];
				string = d_to_a(val2);
				output_info(string,STORED_NUM);
				break;
        default: /*error_occurred = TRUE;*/	/* ramn 6/27/96 */
            return;
	}
}


/*******************************************************************************
/
/	Routine: get_rom_components
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine builds the information string containing
/		      part numbers and revision levels of the ROM components
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: at_I()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
void get_rom_components(void)
{
/* start change 2/22/95 => use acu version num */
#if 0
	ubyte *string;

	string = modem_rom_components();
	output_info(string,(ubyte)sr14.verbose_form);
#endif

	ubyte rom_data[15];
	ubyte *ptr;

   ptr = &rom_data[0];
    *ptr++ = 'A';
	*ptr++ = 'C';
	*ptr++ = 'U';
	*ptr++ = ' ';
	*ptr++ = 'V';
    *ptr++ = version_num[0];
	*ptr++ = '.';
	*ptr++ = version_num[1];
	*ptr++ = version_num[2];
	*ptr= 0x00;

   ptr = &rom_data[0];
	output_info(ptr,(ubyte)sr14.verbose_form);
/* end change 1/15/95 => keh implement checksum for DB4000 */
}

/*******************************************************************************
/
/	Routine: at_L
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the speaker volume.
/	       ATL	0 - Low volume
/			1 - Low volume
/			2 - Medium volume
/			3 - High volume
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr22.speaker_vol, error_occurred
/
/	Users: execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/       Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void at_L(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*
*/* JAY - TIA Conversion Start 1/20/1994 */
*    if (voice_cmd_set == TIA_IS_101)
*       error_occurred = TRUE;
*/* JAY - TIA Conversion End 1/20/1994 */
*
*	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 3)))
*	{
*		sr22.speaker_vol = num;
*		modem_speaker_vol(num);
*	}
*	else
*	    error_occurred = TRUE;
*
*}
#endif
void at_L(ubyte *param_ptr)
{
   ubyte num;

/* JAY - TIA Conversion Start 1/20/1994 */

/*mrm12496*/

/*
    if (voice_cmd_set == TIA_IS_101)
    {
        error_occurred = TRUE;
        return;
    }
*/

/* JAY - TIA Conversion End 1/20/1994 */

/* start change keh 4/14/95 => IAR compiler gags on "struct.mem = *bptr;" */
/*
    if ((*param_ptr >= 0) && (*param_ptr <= 3))
    {
        sr22.speaker_vol = *param_ptr;
        modem_speaker_vol(*param_ptr);
    }
*/

   num = *param_ptr;
/* start change keh 8/15/95 => ubytes are never < 0 */
/*   if ((num >= 0) && (num <= 3)) */
   if (num <= 3)
/* end change keh 8/15/95 => ubytes are never < 0 */
   {
       sr22.speaker_vol = num;
       modem_speaker_vol(num);
   }
/* end change keh 4/14/95 => IAR compiler gags on "struct.mem = *bptr;" */
   else
       error_occurred = TRUE;
}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/	Routine: at_M
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the speaker control.
/	       ATM	0 - Speaker always off
/			1 - Speaker on until carrier present
/			2 - Speaker always on
/			3 - Speaker off during dialing and on until carrier
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr22.speaker_control, error_occurred
/
/	Users: execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void at_M(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*/* JAY - TIA Conversion Start 1/20/1994 */
*        if (voice_cmd_set == TIA_IS_101)
*            error_occurred = TRUE;
*/* JAY - TIA Conversion End 1/20/1994 */
*
*	if (error_occurred == TRUE)
*		return;
*	switch (num)
*
#endif
void at_M(ubyte *param_ptr)
{
/* JAY - TIA Conversion Start 1/20/1994 */

/*mrm12496*/

/*
    if (voice_cmd_set == TIA_IS_101)
    {
        error_occurred = TRUE;
        return;
    }
*/
/* JAY - TIA Conversion End 1/20/1994 */

    switch (*param_ptr)
/* end change keh 12/94 => modify routines for new parser */
    {
        case 0:
            sr22.speaker_ctrl = ALWAYS_OFF;
            modem_speaker(OFF);
            break;

        case 1:
            sr22.speaker_ctrl = ON_UNTIL_CD;
            if (!hook)
                modem_speaker(OFF);
            break;

        case 2:
            sr22.speaker_ctrl = ALWAYS_ON;
            if (!hook)
                modem_speaker(ON);
            break;

        case 3:
            sr22.speaker_ctrl = OFF_DIALING;
            if (!hook)
                modem_speaker(OFF);
            break;

        default : error_occurred = TRUE;
            return;
    }
}

/*******************************************************************************
/
/	Routine: at_N
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the auto-mode/V.8 option. (bit mapped)
/	       ATNn	    0 - Automode disabled, V.8 disabled
/			        1 - Automode enabled,  V.8 disabled
/			        2 - Automode disabled, V.8 enabled
/			        3 - Automode enabled,  V.8 enabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  automode, error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_N(ubyte *param_ptr)
{
/*mrm22596*/
/*N command can accept only 0 or 1*/

   /* Test for automode and V.8 */
	if (*param_ptr <= 1)
	{


		 switch(	*param_ptr)
		 {
		 	case 0:

/*mrm22896*/
				N = 0;
				automode = 0;

/*mrm71696*/
/*at+ms=v34bs command*/

				if( (ms_mode == V34) || (ms_mode == V34S) )
					automode = 2;

				break;

		 	case 1:

/*mrm22896*/
				N = 1;
				automode = 1;

/*mrm71696*/
/*at+ms=v34bs command*/
				if( (ms_mode == V34) || (ms_mode == V34S) )
					automode = 3;

				break;
			}


	}
	else
		error_occurred = TRUE;

}

/*******************************************************************************
/
/	Routine: at_O
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine is called to tell the modem to return to
/		      a previously established connection.
/	       ATO   0 - Go to on-line state
/               1 - Go to on-line state and retrain adaptive equalizer
/                   (V.22bis, V.32, and V.32bis modulations only)
/               3 - Go to on-line state and rate renegotiate
/                   (V.32bis modulations only)
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, result_message_sent,
/				   send_ok, on_line_command, modem_baud,
/				   acu_state
/
/	Users:	execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_O(ubyte *param_ptr)
{
/* start change 1/18/94 keh => no stalled loops for OS support */
/*	ubyte num, rate, tmp; */
   ubyte num, tmp;
/* end change 1/18/94 keh => no stalled loops for OS support */

/* JAY - TIA Conversion Start 1/20/1994 */
/* start change keh => add new parser */
/*
 *  if (voice_cmd_set == TIA_IS_101)
 *      error_occurred = TRUE;
 */

   if (voice_cmd_set == TIA_IS_101)
   {
       error_occurred = TRUE;
       return;
   }
/* end change keh => add new parser */
/* JAY - TIA Conversion End 1/20/1994 */

/* start change keh 1/20/95 => allow AT&T1 to return to the test */
/*
 *   if ((test_in_progress) || (hook == TRUE) || (slU == TRUE))
 *   {
 *       error_occurred = TRUE;
 *       return;
 *   }
 */
    /* Currently running AT&T tests */
    switch (test_in_progress)
    {
        case 0:     /* No Test in progress - do nothing */
            break;

        case ALB:
        case RDL:
            /* Return back to the test (AT&T1,6) */
            build_event(E_TEST,TEST_RETURN);
            return;

        default:
            error_occurred = TRUE;
            return;
    }


    if ((hook == TRUE) || (slU == TRUE))
    {
        error_occurred = TRUE;
        return;
    }

/* end change keh 1/20/95 => allow AT&T1 to return to the test */

#if 0
    num = a_to_d();
    if (error_occurred == TRUE)
        return;
#else
    num = *param_ptr;
#endif
    /* Update modem's retrain operation in case it has changed while in on
        line command mode. */
    tmp = ((((slN != DIRECT) && (!bps_adjust)) ||
        (comm_mode != ASYNC)) && (autofallback));
    modem_retrain_enable(perE,s[110],tmp);

    /* Update the modem's possible rates in case they have changed while in
        on line command mode */
#if TIES_HAYES_ESCAPE                    /* ciy021596 */

    if ( on_line_command )
        update_modem_rate_seq();

    /* If running MNP 10 do not allow the ACU to force a retrain or rate
        renegotiation. These should be controlled by the MNP 10 code only. */
    if (v42_running_mnp10)
        num = 0;

    /* Which ATO command */
    switch (num)
    {
        case 0 :
            if (on_line_command)
            {
                /* Build CONNECT event and cleanup after parse state */
                parse_return_online();

                return; /* Do not fall through and reconfigure the
                        system. It is done by the return online function */
            }
            else
            {
                if (sr14.originate_flag)
                    build_event(E_ORIG,NO_DIAL);
                else
                    build_event(E_ANSW,UNUSED);
            }
            break;

        case 3:
            /* If V.32bis operation is not enabled then need to
                return error if trying to issue a rate renegotiation. */
/* start change keh 6/28/95 => V.34 RRN bug */
/*            if (v32bis_enable == 0) */
				/* V.34 allows RRNS too */
            if ((v32bis_enable == 0) &&
               (modem_mode != V34 && modem_mode != V34_ASYMETRIC))
/* end change keh 6/28/95 => V.34 RRN bug */
            {
                error_occurred = TRUE;
                return;
            }

            /* Intentionally fall through */

        case 1:
            if (on_line_command)
            {
                if (num == 1)
                    modem_retrain();
                else /* num == 3 */
                    modem_renegotiate();
                st_parse.state = PARSE_TO_ONLINE_RETRAIN;
                timer1 = 1500;      /* Retrain to complete delay time */

                return; /* Do not fall through and reconfigure the
                        system yet. It is done after the
                        parse_to_online_retain state */
            }
            else
                if (sr14.originate_flag)
                    build_event(E_ORIG,NO_DIAL);
                else
                    build_event(E_ANSW,UNUSED);
            break;

        default: error_occurred = TRUE;
            return;
    }

    send_ok = FALSE;
    on_line_command = FALSE;

    system_reconfigure();
    autobaud_off();
}

#else

    update_modem_rate_seq();

    /* If running MNP 10 do not allow the ACU to force a retrain or rate
        renegotiation. These should be controlled by the MNP 10 code only. */
    if (v42_running_mnp10)
        num = 0;

    /* Which ATO command */
    switch (num)
    {
        case 0 :
            if (on_line_command)
            {
/* start change 1/18/94 keh => no stalled loops for OS support */
#if 0
*                build_event(E_CONNECT,UNUSED);
*
*                if ( (comm_mode == ASYNC) &&
*                    (operating_mode != DIRECT) )
*                    system_start(CONTINUE);
*                else
*                    build_event(E_MSG,CONNECT_XXXX);
*
*                get_modem_baud_and_mode();
*                if ((modem_mode == V23_ADX) || (modem_mode == V23_HDX))
*                    system_set_line_baud();
*
*                /* Added to have the HS LED reflect the line
*                    speed while connected */
*                if (modem_baud >= BPS2400 && modem_baud <= BPS57600)
*                    modem_hs_led(modem_baud);
*                else
*                    modem_hs_led(OFF);
#endif
                /* Build CONNECT event and cleanup after parse state */
                parse_return_online();

                return; /* Do not fall through and reconfigure the
                        system. It is done by the return online function */
/* end change 1/18/94 keh => no stalled loops for OS support */
            }
            else
            {
                if (sr14.originate_flag)
                    build_event(E_ORIG,NO_DIAL);
                else
                    build_event(E_ANSW,UNUSED);
            }
            break;

        case 3:
            /* If V.32bis operation is not enabled then need to
                return error if trying to issue a rate renegotiation. */
/* start change keh 6/28/95 => V.34 RRN bug */
/*            if (v32bis_enable == 0) */
                /* V.34 allows RRNS too */
            if ((v32bis_enable == 0) &&
               (modem_mode != V34 && modem_mode != V34_ASYMETRIC))
/* end change keh 6/28/95 => V.34 RRN bug */
            {
                error_occurred = TRUE;
                return;
            }

            /* Intentionally fall through */

        case 1:
            if (on_line_command)
            {
                if (num == 1)
                    modem_retrain();
                else /* num == 3 */
                    modem_renegotiate();

/* start change 1/18/94 keh => no stalled loops for OS support */
#if 0 /* ORig code */
*                modem_task();
*
*                /* Wait while modem task is retraining	*/
*                while (modem_status == RETRAINING_STATUS)
*                {
*                    process_wait();
*                    modem_task();
*                }
*
*                /* If retrain failed then disconnect */
*                if (modem_status == IDLE_STATUS)
*                {
*                    build_event(E_HANGUP,NO_CARRIER);
*                    return;
*                }
*
*                /* If retrain is complete, need to get new
*                    connection baud rate if it has changed */
*                rate = modem_baud;
*
*                get_modem_baud_and_mode();
*
*                /* Reset line baud rate to the value detected by
*                    retrain */
*                if ((modem_baud != rate) || (modem_mode == V23_ADX) ||
*                    (modem_mode == V23_HDX))
*                    system_set_line_baud();
*                build_event(E_CONNECT,UNUSED);
*
*                if ( (comm_mode == ASYNC) &&
*                    (operating_mode != DIRECT) )
*                    system_start(CONTINUE);
*                else
*                    build_event(E_MSG,CONNECT_XXXX);
*
*                /* Added to have the HS LED reflect the line
*                    speed while connected */
*                if (modem_baud >= BPS2400 && modem_baud <= BPS57600)
*                    modem_hs_led(modem_baud);
*                else
*                    modem_hs_led(OFF);
#endif
                st_parse.state = PARSE_TO_ONLINE_RETRAIN;
                timer1 = 1500;      /* Retrain to complete delay time */

                return; /* Do not fall through and reconfigure the
                        system yet. It is done after the
                        parse_to_online_retain state */
/* end change 1/18/94 keh => no stalled loops for OS support */
            }
            else
                if (sr14.originate_flag)
                    build_event(E_ORIG,NO_DIAL);
                else
                    build_event(E_ANSW,UNUSED);
            break;

        default: error_occurred = TRUE;
            return;
    }

    send_ok = FALSE;
    on_line_command = FALSE;

    system_reconfigure();
    autobaud_off();
}

#endif


/*******************************************************************************
/
/	Routine: at_P
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects pulse dialing.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr14.pulse
/
/	Users: execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_P(void)
{
    /* No parameter for ATP command */
    /* param_ptr = 0; */
    sr14.pulse = TRUE;
}


/*******************************************************************************
/
/	Routine: at_Q
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the result code display option
/	       ATQ	0 - Result codes enabled
/			1 - Result codes disabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr14.disable_result_code, error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_Q(ubyte *param_ptr)
{
#if 0
	ubyte num;

	num = a_to_d();

/* JAY - TIA Conversion Start 1/20/1994 */
    if (voice_cmd_set == TIA_IS_101)
/* start change keh => add new parser */
/*        error_occurred = TRUE; */
    {
        error_occurred = TRUE;
        return;
    }
/* end change keh => add new parser */
/* JAY - TIA Conversion End 1/20/1994 */

	if (error_occurred == TRUE)
		return;
	switch (num)
	{
		case 0: sr14.disable_result_code = FALSE;
			break;

		case 1: sr14.disable_result_code = TRUE;
			break;

		default: error_occurred = TRUE;
	}
#else
/* JAY - TIA Conversion Start 1/20/1994 */
    if (voice_cmd_set == TIA_IS_101)
/* start change keh => add new parser */
/*        error_occurred = TRUE; */
    {
/*
 do not return error, this command is sent in voice mode my TAPI apllications
	ramn 9/13/96
*/
        /*error_occurred = TRUE;*/
        return;
    }
/* end change keh => add new parser */
/* JAY - TIA Conversion End 1/20/1994 */
    if (*param_ptr == 0)
    {
		sr14.disable_result_code = FALSE;
    }
    else if (*param_ptr == 1)
    {
		sr14.disable_result_code = TRUE;
    }
    else
    {
        error_occurred = TRUE;
    }
#endif
}

/*******************************************************************************
/
/	Routine: at_S
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine selects a register for next read or write
/		      operation. It will allow any value to be selected even
/		      if the register does not exist.
/	       ATS	0 - 27,30,37,63,91,95
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  current_register
/
/	Users:	execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/
*******************************************************************************/
void at_S(ubyte *param_ptr)
{
#if 0
	ubyte num;

	num = a_to_d();

	current_register = num;
	error_occurred = FALSE;
#else

	current_register = *param_ptr;

#endif
}

/*******************************************************************************
/
/	Routine: at_equal
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine will change the selected register value.
/	       ATS	0 - 27,30,37,63,91,108,109,110
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  current_register
/
/	Users:	error_occurred, selected register
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/       Author & Date:  RSA
/       Description:
/       Reason:
/
*******************************************************************************/
void at_equal(ubyte *param_ptr)
{
    ubyte num;

/* ramn 9/13/96 , in IS 101 ats0=0 is allowed */
	 if((*param_ptr) && (current_register))
	 {
	    if ((fax_class == 8) && (voice_cmd_set == TIA_IS_101) &&
   	     ((current_register == 0) || (current_register == 10)))
	    {
   	     error_occurred = TRUE;
      	  return;
	    }
	 }

/* 04/30/96 shd, change 63 to 33(sleep timer) */
    if ((current_register > 27) && (current_register != 30) &&
        (current_register != 37) && (current_register != 33) &&
        (current_register != 91) && (current_register != 95) &&
        (current_register != 108) && (current_register != 109) &&
/* start change keh 8/14/95 => add v.34 to temic */
/*        (current_register != 110) && (current_register != 112)) */
        (current_register != 110) &&
        (!((current_register >= 112) && (current_register <= 118))))
/* end change keh 8/14/95 => add v.34 to temic */
    {
        error_occurred = TRUE;
        return;
    }

#if 0
    num = a_to_d();
#else
    num = *param_ptr;
#endif

    if (error_occurred == TRUE)
    {
        /* If value is greater than 255, and register is bit mapped then
            return error. Else set value entered to 255 */
        if ((current_register == 14) || (current_register == 16) ||
            (current_register == 21) || (current_register == 22) ||
            (current_register == 23) || (current_register == 27))
        {
            return;
        }
        else
        {
            num = 255;
            error_occurred = FALSE;
        }
    }

    /* Else check the range of the input value */
    chk_sreg_range(num);

    if ((current_register == 7) || (current_register == 9) || (current_register == 10) ||
        (current_register == 63) || (current_register == 91) || (current_register == 108))
    {
        if (sr27.leased_line == TRUE)
        {
            modem_set_parameters(s[9],s[7],255,v32_retrain,s[63],
                receive_threshold,s[108]);
            modem_speaker(OFF);
        }
        else
            modem_set_parameters(s[9],s[7],s[10],v32_retrain,s[91],
                receive_threshold,s[108]);
    }

    /* Need to turn on or turn off the auto-answer LED depending upon the
        value of s[0]. */
    if (current_register == 0)
    {
        if (num > 0)
            modem_aa_led(ON);
        else
            modem_aa_led(OFF);
    }
}


/*******************************************************************************
/
/	Routine: chk_sreg_range
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine checks the input value against the accepted
/		      ranges for the selected S register.
/
/	Input Parameters: ubyte num - value to be checked
/
/	Output Parameters: none
/
/	Global Variables Changed:  selected register
/
/	Users:	at_equal
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/   Author & Date:  RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void chk_sreg_range(ubyte num)
{
    ubyte count,i;

/* IAR compiler error +
    i = 0;
    count = s_range[current_register][i++];
*/
	switch (current_register) { /*SLei added*/
		case 0:
		case 6:
		case 7:
		case 8:
		case 10:
		case 11:
		case 91:
			CountryDependSRegRangeCheck(num);
			break;
		default:
   count = s_range[current_register][0];
   i=1;
/* IAR compiler error  - */

    if (count == 0)
    {
        error_occurred = TRUE;
        return;
    }

    while (count != 0)
    {
        if ((s_range[current_register][i++] <= num) &&
            (num <= s_range[current_register][i++]))
        {
            *srptr[current_register] = num;
            return;
        }
        count--;
    }

    /* If value entered is greater then maximum allowed value need to set the
        S register to the max value	*/
    i--;
    if (num > s_range[current_register][i])
        *srptr[current_register] = s_range[current_register][i];

    /* If value entered is less then minimum allowed value need to set the
        S register to the min value	*/
    if (num < s_range[current_register][1])
        *srptr[current_register] = s_range[current_register][1];
		}
}


/*******************************************************************************
/
/	Routine: at_quest
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine reads the selected register and will
/		      display it to the user.
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  none
/
/	Users:	execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/       Author & Date:
/       Description:
/       Reason:
/
*******************************************************************************/
void at_quest(void)
{
    ubyte *string;

    /* If register selected is not inplimented then return 000 to the terminal */
/* 04/30/96 shd, change 63 to 33(sleep timer), s63 not in use */
    if ((current_register > 27) && (current_register != 30) &&
        (current_register != 37) && (current_register != 33) &&
        (current_register != 91) && (current_register != 95) &&
        (current_register != 108) && (current_register != 109) &&
/* start change keh 8/14/95 => add v.34 to temic */
/*        (current_register != 110) && (current_register != 112)) */
        (current_register != 110) && (current_register != 112) &&
        (!((current_register >= 112) && (current_register <= 118))))
/* end change keh 8/14/95 => add v.34 to temic */
        string = d_to_a(0);
    else
        string = d_to_a(*srptr[current_register]);

    output_info(string,(ubyte)sr14.verbose_form);
}


/*******************************************************************************
/
/	Routine: at_T
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects tone dialing.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr14.pulse
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_T(void)
{
    /* No parameter for ATT command */
    /* param_ptr = 0; */
    sr14.pulse = FALSE;
}

/*******************************************************************************
/
/	Routine: at_V
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine selects the result code format.
/	       ATV	0 - Displayed in numeric form
/			1 - Displayed in verbose form
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr14.verbose_form, error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
extern ubyte numeric_response;
void at_V(ubyte *param_ptr)
{
#if 0
	ubyte num;

	num = a_to_d();
	if (error_occurred == TRUE)
		return;

	switch (num)
#else
    switch (*param_ptr)
#endif
    {
        case 0:
            sr14.verbose_form = FALSE;
				numeric_response = FALSE; /* ramn 1/16/96 */
            break;

        case 1:
            sr14.verbose_form = TRUE;
				numeric_response = TRUE; /* ramn 1/16/96 */
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}

/*******************************************************************************
/
/	Routine: at_W
/
/	Author:  RSA
/
/	Creation Date:	07/17/91
/
/	Description:	This Routine will determine the modems connect message
/			if S95 = 0.  a_to_d() will retrieve a number causing
/			the following behavior:
/
/				0 -  If S95 = 0, CONNECT result code reports
/				     DTE speed and all extended result codes
/				     are disabled.
/
/				1 -  If S95 = 0, CONNECT result code reports
/				     DTE speed and CARRIER and PROTOCOL result
/				     codes are enabled.
/
/				2 -  If S95 = 0, CONNECT result code reports
/				     DCE speed and all extended result codes
/				     are disabled.
/
/	Input Parameters: None
/
/	Output Parameter: None
/
/	Global Variables Changed: atW
/
/	Users: execute_cmd()
/
/	-----------------------------------------------------------------
/	-			  Modifications 			-
/	-----------------------------------------------------------------
/
/	Author & Date:
/	Description:
/
*******************************************************************************/
void at_W(ubyte *param_ptr)
{
#if 0
	ubyte num;

	num = a_to_d();

	if ((error_occurred == FALSE) && ((num >= 0) && (num <= 2)))
		atW = num;
	else
		error_occurred = TRUE;
#else
/* start change keh 8/15/95 => ubytes are never < 0 */
/*	if ((*param_ptr >= 0) && (*param_ptr <= 2)) */
/*mrm224*/
/*	if (*param_ptr <= 3)*/
/*mrm71096*/

	if (*param_ptr <= 4)
/* end change keh 8/15/95 => ubytes are never < 0 */
		atW = *param_ptr;
	else
		error_occurred = TRUE;
#endif
}


/*******************************************************************************
/
/	Routine: at_X
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description:  This Routine selects tone detection options and the
/		      associated result codes.
/	       ATX	0 - Result codes 0-4 enabled. Busy and dial tone
/			    detect disabled
/			1 - Result codes 0-4,10 enabled. Busy and dial tone
/			    detect disabled
/			2 - Result codes 0-6,10 enabled. Busy detect disabled
/			    dial tone detect enabled
/			3 - Result codes 0-5,7,10 enabled. Busy detect enabled
/			    dial tone detect disabled
/			4 - Result codes 0-7,10 enabled. Busy and dial tone
/			    detect enabled
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr22.busy_enable, sr22.dialtone_enable,
/				   sr22.enable_result5, error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_X(ubyte *param_ptr)
{
#if 0
	ubyte num;

	num = a_to_d();

/* JAY - TIA Conversion Start 1/20/1994 */
        if (voice_cmd_set == TIA_IS_101)
            error_occurred = TRUE;
/* JAY - TIA Conversion End 1/20/1994 */

	if (error_occurred == TRUE)
		return;

	switch (num)
	{
		case 0: sr22.busy_enable = FALSE;
			sr22.dialtone_enable = FALSE;
			sr22.enable_result5 = FALSE;
			break;

		case 1: sr22.busy_enable = FALSE;
			sr22.dialtone_enable = FALSE;
			sr22.enable_result5 = TRUE;
			break;

		case 2: sr22.busy_enable = FALSE;
			sr22.dialtone_enable = TRUE;
			sr22.enable_result5 = TRUE;
			break;

		case 3: sr22.busy_enable = TRUE;
			sr22.dialtone_enable = FALSE;
			sr22.enable_result5 = TRUE;
			break;

		case 4: sr22.busy_enable = TRUE;
			sr22.dialtone_enable = TRUE;
			sr22.enable_result5 = TRUE;
			break;

		default: error_occurred = TRUE;
			 return;
	}
	valueX = num;
#else

#if 0			/* ramn 9/21/96 */
    if (voice_cmd_set == TIA_IS_101)
    {
        /*error_occurred = TRUE;*/	/* ramn 6/27/96 */
        return;
    }
#endif

    switch (*param_ptr)
    {
        case 0:
            sr22.busy_enable = FALSE;
            sr22.dialtone_enable = FALSE;
            sr22.enable_result5 = FALSE;
            break;

        case 1:
            sr22.busy_enable = FALSE;
            sr22.dialtone_enable = FALSE;
            sr22.enable_result5 = TRUE;
            break;

        case 2:
            sr22.busy_enable = FALSE;
            sr22.dialtone_enable = TRUE;
            sr22.enable_result5 = TRUE;
            break;

        case 3:
            sr22.busy_enable = TRUE;
            sr22.dialtone_enable = FALSE;
            sr22.enable_result5 = TRUE;
				break;

        case 4:
            sr22.busy_enable = TRUE;
            sr22.dialtone_enable = TRUE;
            sr22.enable_result5 = TRUE;
            break;


        default:
            error_occurred = TRUE;
            return;
    }

	valueX = *param_ptr;
#endif
}

/*******************************************************************************
/
/	Routine: at_Y
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description:  This Routine sets long space disconnect option
/	       ATY	0 - Disable long space disconnect
/			1 - Enable long space disconnect
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr21.long_space_discon, error_occurred
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void at_Y(ubyte *param_ptr)
{
#if 0
	ubyte num;

	num = a_to_d();
	if (error_occurred == TRUE)
		return;
	switch (num)
	{
		case 0: sr21.long_space_discon = FALSE;
			break;

		case 1: sr21.long_space_discon = TRUE;
			break;

		default: error_occurred = TRUE;
			 return;
	}
#else
    if (*param_ptr == 0)
        sr21.long_space_discon = FALSE;
    else if (*param_ptr == 1)
        sr21.long_space_discon = TRUE;
    else
        error_occurred = TRUE;
#endif
}

/*******************************************************************************
/
/	Routine: at_Z
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description:  This Routine recalls stored profile
/	       ATZ	0 - Recall stored profile 0
/			1 - Recall stored profile 1
/			2 - Recall stored profile 2
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0
void at_Z(void)
{
    ubyte num;

    num = a_to_d();

/* JAY - TIA Conversion Start 1/20/1994 - *NOT* needed !
    if (voice_cmd_set == TIA_IS_101)
        error_occurred = TRUE;
JAY - TIA Conversion End 1/20/1994 */

    if ((error_occurred == FALSE) && ((num >= 0) && (num <NUMBER_OF_PROFILES)))
    {
        /* If a test is currently running then need to terminate it */
        if (test_in_progress)
            build_event(E_HANGUP,NONE);

        /* If modem is online, need to hangup the connection */
        if (!hook || on_line_command)
        {
            build_event(E_HANGUP,OK);
            user_initiated_hangup = TRUE;
            at_z_command = TRUE;

/*mrm3996*/
				at_h_command = TRUE;

        }

        initialize_voice(VOICE_INIT_ATZ);
        and_F(AT_Z_COMMAND);
        retrieve_profile(num,COMMAND);
    }
    else
        error_occurred = TRUE;
}

#else

void at_Z(ubyte *param_ptr)
{
	int i;
/* start change keh 8/15/95 => ubytes are never < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr < NUMBER_OF_PROFILES)) */
    if (*param_ptr < NUMBER_OF_PROFILES)
/* end change keh 8/15/95 => ubytes are never < 0 */
    {
#if TIES_HAYES_ESCAPE                    /* ciy021596 */

        /* If a test is currently running then need to terminate it, for at&t1, +++, at, atz */
        if (test_in_progress )
        {
/*            test_in_progress = FALSE;   */

/* should return OK after terminating test */
            /*build_event(E_HANGUP,NONE);*/	/* ramn 6/20/96 */
				build_event(E_HANGUP,OK);			/* ramn 6/20/96 */
        }
        /* If modem is online, need to hangup the connection */
        if (!hook || on_line_command || ( ties_esc_state == ESC_DONE ))
        {
            if ( dte_mode != ACU )
            {
                if ( !on_line_command )
                {
                    send_ok = TRUE;
                    ties_esc_state = 'H';
                    error_occurred = TRUE;
                    dte_mode = ACU;
                }
            }
/*            build_event(E_HANGUP,OK);     */
            hangup_connection(NONE);

            user_initiated_hangup = TRUE;
            at_z_command = TRUE;
/*mrm3996*/
				at_h_command = TRUE;
        }
#else
        /* If a test is currently running then need to terminate it */
        if (test_in_progress)
/* should return OK after terminating test */
            /*build_event(E_HANGUP,NONE);*/	/* ramn 6/20/96 */
				build_event(E_HANGUP,OK);			/* ramn 6/20/96 */

        /* If modem is online, need to hangup the connection */
        if (!hook || on_line_command)
        {
            build_event(E_HANGUP,OK);
            user_initiated_hangup = TRUE;
            at_z_command = TRUE;
        }
#endif

/* start change keh 12/94 => add new parser */
/*        initialize_voice(VOICE_INIT_ATZ); */
/*      and_F(AT_Z_COMMAND); */

/*SLei added*/
		if (Default_Country == 0xFF) {
			if (modem_read_data(COUNTRY_CODE,COUNTRY_CODE_SIZE,&CountryInfo)) {
				CountryInfo = 0; /* If error occurred, set country to USA*/
				}
			}
		else {
			CountryInfo = Default_Country;
			}

        acu_load_defaults(AT_Z_COMMAND);
/* end change keh 12/94 => add new parser  */

        retrieve_profile(*param_ptr,COMMAND);
		  operating_mode = slN;	/*ramn 6/10/96 */


	for (i = 0; i < 12; i++) {
		BlackLst[i].status = 0;
		}

    }
    else
        error_occurred = TRUE;
}
#endif
/*******************************************************************************
/
/	Routine: at_Z
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description:  This Routine recalls stored profile
/	       ATZ	0 - Recall stored profile 0
/			1 - Recall stored profile 1
/			2 - Recall stored profile 2
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: execute_cmd()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
/*mrm22596*/
/*added the AT+MS command*/

void plus_ms(ubyte *param_ptr)
{
	ubyte data,count;
	ulong data1=0;


	data = *param_ptr;

	count = 0;

	if (data == 'V')
	{
		param_ptr++;

		while (*param_ptr != ',')
		{

			data1 = data1 << 8;
			data1 |= *param_ptr;
			param_ptr++;
			count ++;
		 	if(count >= 4)
				break;
		}

/*mod mode*/
		switch (data1)
		 {
			case '34B':
					ms_mode = V34;
					v34_bis_mode = 1;
				break;

			case '34BS':
					ms_mode = V34S;
					v34_bis_mode = 1;

				break;

			case '34S':
					ms_mode = V34S;
					v34_bis_mode = 0;
				break;


			case '34':
					ms_mode = V34;
					v34_bis_mode = 0;

				break;

			case '32B':
					ms_mode = V32BIS;
					v34_bis_mode = 0;
		 		break;

			case '32':
					ms_mode = V32;
					v34_bis_mode = 0;
				break;

			case '22B':
					ms_mode = V22BIS;
					v34_bis_mode = 0;
  			break;

			case '22':
					ms_mode = V22;
					v34_bis_mode = 0;

				break;

			case '23C':
					ms_mode = V23_ADX;
					v34_bis_mode = 0;

				break;

			case '21':
					ms_mode = V21;
					v34_bis_mode = 0;
				break;


			default: error_occurred = TRUE;
						v34_bis_mode = 0;
				break;


		  }

		 /*
			we need to check if the legacy patch was
			dnlded if yes check if we are in v34 mode if yes we need to
			dnld the v34 patch again.

			if we are not in v34 mode then dnld the legacy patch.

			ramn 12/11/96
		 */
			if((ms_mode == V34) || (ms_mode == V34S))
			{
				dsppatch();							/* ramn 12/11/96 */

				LOAD_MODEM_INIT
				ack_or_response = ACK;
				send_pkt_to_dsp();
				voice_patch_dnlded = FALSE;

				if(!hook)
					modem_init_call_progress(OFF_HOOK_NOT_DIALED);
				else
					modem_init_call_progress(ON_HOOK);
			}
/*
			else if((!voice_patch_dnlded) &&
					  ((ms_mode != V34) || (ms_mode != V34S))
					 )
*/
			else
			{
			   voice_dnld_patch(vcepatch);
				voice_patch_dnlded = TRUE;		/* ramn 12/11/96 */

				LOAD_MODEM_INIT
				ack_or_response = ACK;
				send_pkt_to_dsp();

				if(!hook)
					modem_init_call_progress(OFF_HOOK_NOT_DIALED);
				else
					modem_init_call_progress(ON_HOOK);
				}

  		param_ptr++;
	 	data1 = 0;
		count = 0;
/*auto mode */

		while (*param_ptr != ',')
		{
			count ++;
			data1 = data1 << 8;
			data1 |= *param_ptr;
			param_ptr++;

			if (count >= 2)
				break;

		}

		switch (data1)

		 {
			case '0':

/*mrm22896*/

				N = 0;
				automode = 0;

				if ((ms_mode == V34)|| (ms_mode == V34S))
					automode = 2;

				break;

			case '1':

/*mrm22896*/
				N = 1;
				automode = 1;

				if ((ms_mode == V34)|| (ms_mode == V34S))
					automode = 3;


				break;

		 	default: error_occurred = TRUE;
				return;

		 }

		param_ptr++;
	 	data1=0;
		count = 0;

		while (*param_ptr != ',')
		{
			count ++;
			if(count <=4 )
			{
				data1 = data1 << 8;
				data1 |= *param_ptr;
			}
				param_ptr++;

			if (count >= 6)
				break;

		}

/*min speed */

		switch (data1)

		 {

			case '0':
			case '300':
				ms_min_rate = BPS300;
				ms_min_speed = BPS2400MIN;
				break;

			case '1200':

				if( count == 5)
				{
					ms_min_rate = BPS12000;
					ms_min_speed = BPS12000MIN;
				}
				else

				{
					ms_min_rate = BPS1200;
					ms_min_speed = BPS2400MIN;
				}
				break;


			case '2400':
				if (count == 5)
				{
					ms_min_rate = BPS24000;
					ms_min_speed = BPS24000MIN;
				}
				else
				{
					ms_min_rate = BPS2400;
					ms_min_speed = BPS2400MIN;
				}
				break;

			case '4800':
				ms_min_rate = BPS4800;
				ms_min_speed = BPS4800MIN;

				break;

			case '7200':
				ms_min_rate = BPS7200;
				ms_min_speed = BPS7200MIN;

				break;

			case '9600':
				ms_min_rate = BPS9600;
				ms_min_speed = BPS9600MIN;

				break;


			case '1440':
				if(count == 5)
				{
					ms_min_rate = BPS14400;
					ms_min_speed = BPS14400MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '1680':
				if(count == 5)
				{
					ms_min_rate = BPS16800;
					ms_min_speed = BPS16800MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '1920':
				if(count == 5)
				{
					ms_min_rate = BPS19200;
					ms_min_speed = BPS19200MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '2160':
				if(count == 5)
				{
					ms_min_rate = BPS21600;
					ms_min_speed = BPS21600MIN;
				}
				else
					error_occurred = TRUE;

				break;


			case '2640':

				if(count == 5)
				{
					ms_min_rate = BPS26400;
					ms_min_speed = BPS26400MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '2880':

				if(count == 5)
				{
					ms_min_rate = BPS28800;
					ms_min_speed = BPS28800MIN;
				}
				else
					error_occurred = TRUE;

				break;

			case '3120':

				if(count == 5)
				{
					ms_min_rate = BPS31200;
					ms_min_speed = BPS31200MIN;
				}
				else
					error_occurred = TRUE;


				break;


			case '3360':
				if(count == 5)
				{
					ms_min_rate = BPS33600;
					ms_min_speed = BPS33600MIN;
				}
				else
					error_occurred = TRUE;

				break;



			default: error_occurred = TRUE;
				return;


		  }

		param_ptr++;
	 	data1=0;
		count=0;

/*		while (*param_ptr != NULL)*/

		while ((*param_ptr != NULL) && (*param_ptr >= 0x30) && (*param_ptr <= 0x39))
		{


			count ++;
			if(count <=4 )
			{
				data1 = data1 << 8;
				data1 |= *param_ptr;
			}
				param_ptr++;

			if (count >= 6)
				break;


		}
/*max speed */

		switch (data1)

		 {


			case '300':

				s[37] = S37_300_BPS;

				break;

			case '1200':


				if (count == 5)
					s[37] = S37_12000_BPS;
				else
					s[37] = S37_1200_BPS;

				break;

			case '2400':

				if (count == 5)
					s[37] = S37_24000_BPS;
				else
					s[37] = S37_2400_BPS;

				break;

			case '4800':
				s[37]	= S37_4800_BPS;

				break;

			case '7200':
				s[37] = S37_7200_BPS;

				break;

			case '9600':
				s[37] = S37_9600_BPS;

				break;


			case '1440':
				if(count == 5)
				{
					s[37] = S37_14400_BPS;
				}
				else
					 error_occurred = TRUE;

				break;

			case '1680':
				if(count == 5)
				{
					s[37] = S37_16800_BPS;
				}
				else
					error_occurred = TRUE;


				break;

			case '1920':
				if(count == 5)
				{
					s[37] = S37_19200_BPS;
				}
				else
					error_occurred = TRUE;


				break;

			case '2160':
				if(count == 5)
				{
					s[37] = S37_21600_BPS;
				}
				else
					error_occurred = TRUE;


				break;


			case '2640':
				if(count == 5)
				{
					s[37] = S37_26400_BPS;
				}
				else
					error_occurred = TRUE;

				break;

			case '2880':

				if(count == 5)
				{
					s[37] = S37_28800_BPS;
				}
				else
			 		error_occurred = TRUE;

				break;

			case '3120':

				if(count == 5)
				{
					s[37] = S37_31200_BPS;
				}
				else
					error_occurred = TRUE;

				break;

			case '3360':

				if(count == 5)
				{
					s[37] = S37_33600_BPS;
				}
				else
					error_occurred = TRUE;

				break;

			case '0':

					s[37] = 0;

				break;



			default: error_occurred = TRUE;
				return;



		  }





	}
	else
        error_occurred = TRUE;



}

#include <string.h>

void plus_ms_q(void);

void plus_ms_q(void)
{
   ubyte  string[20];

   switch(ms_mode)
   {
     case  V34:
          if(v34_bis_mode == 1)  strcpy((char *) string,V34B_MODE);
          else                   strcpy((char *) string,V34_MODE);
          break;

     case  V34S:
          if(v34_bis_mode == 1)  strcpy((char *) string,V34B_MODE);
          else                   strcpy((char *) string,V34_MODE);
          break;

     case  V32BIS:
          strcpy((char *) string,V32BIS_MODE);
          break;

     case  V32:
          strcpy((char *) string,V32_MODE);
          break;

     case  V22BIS:
          strcpy((char *) string,V22BIS_MODE);
          break;

     case  V22:
          strcpy((char *) string,V22_MODE);
          break;

     case  V23_ADX:
          strcpy((char *) string,V23_MODE);
          break;

     case  V21:
          strcpy((char *) string,V21_MODE);
          break;

     default:
          strcpy((char *) string,"V?");
          break;
   }
   strcat((char *) string,",");


   switch(N)
   {
     case 0:
         strcat((char *) string,"0,");
         break;

     case 1:
         strcat((char *) string,"1,");
         break;

     default:
         strcat((char *) string,"?,");
         break;
   }


   switch(ms_min_rate)
   {
      case BPS300:
          strcat((char *)string,"300,");
          break;

      case BPS1200:
          strcat((char *)string,"1200,");
          break;

      case BPS12000:
          strcat((char *)string,"12000,");
          break;

      case BPS2400:
          strcat((char *)string,"2400,");
          break;

      case BPS24000:
          strcat((char *)string,"24000,");
          break;

      case BPS4800:
          strcat((char *)string,"4800,");
          break;

      case BPS7200:
          strcat((char *)string,"7200,");
          break;

      case BPS9600:
          strcat((char *)string,"9600,");
          break;

      case BPS14400:
          strcat((char *)string,"14400,");
          break;

      case BPS16800:
          strcat((char *)string,"16800,");
          break;

      case BPS19200:
          strcat((char *)string,"19200,");
          break;

      case BPS21600:
          strcat((char *)string,"21600,");
          break;

      case BPS26400:
          strcat((char *)string,"26400,");
          break;

      case BPS28800:
          strcat((char *)string,"28800,");
          break;

      case BPS31200:
          strcat((char *)string,"31200,");
          break;

      case BPS33600:
          strcat((char *)string,"33600,");
          break;

      case 0:
          strcat((char *)string,"0,");
          break;

      default:
          strcat((char *)string,"?,");
          break;
   }

   switch(s[37])
   {
      case S37_300_BPS:
          strcat((char *)string,"300");
          break;

      case S37_1200_BPS:
          strcat((char *)string,"1200");
          break;

      case S37_12000_BPS:
          strcat((char *)string,"12000");
          break;

      case S37_2400_BPS:
          strcat((char *)string,"2400");
          break;

      case S37_24000_BPS:
          strcat((char *)string,"24000");
          break;

      case S37_4800_BPS:
          strcat((char *)string,"4800");
          break;

      case S37_7200_BPS:
          strcat((char *)string,"7200");
          break;

      case S37_9600_BPS:
          strcat((char *)string,"9600");
          break;

      case S37_14400_BPS:
          strcat((char *)string,"14400");
          break;

      case S37_16800_BPS:
          strcat((char *)string,"16800");
          break;

      case S37_19200_BPS:
          strcat((char *)string,"19200");
          break;

      case S37_21600_BPS:
          strcat((char *)string,"21600");
          break;

      case S37_26400_BPS:
          strcat((char *)string,"26400");
          break;

      case S37_28800_BPS:
          strcat((char *)string,"28800");
          break;

      case S37_31200_BPS:
          strcat((char *)string,"31200");
          break;

      case S37_33600_BPS:
          strcat((char *)string,"33600");
          break;

      case 0:
          strcat((char *)string,"0");
          break;

      default:
          strcat((char *)string,"?");
          break;
   }
   output_info( string,(ubyte)sr14.verbose_form);

}

/*******************************************************************************
/
/	Routine: at_comma
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine is called to pause for the time specified
/		      by s8.
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  timer1
/
/	Users:	execute_cmd
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/
*******************************************************************************/
void at_comma(void)
{
   /* Start delay timer */
   timer1 = (dial_pause_time * 100);

/* start change 1/18/94 keh => no stalled loops for OS support */
/*
 *   while (timer1)
 *       process_wait();
 */
   /* Change parse states to time the delay in the BG */
   st_parse.state = PARSE_CMD_DELAY;

/* end change 1/18/94 keh => no stalled loops for OS support */
}

void bang_P_q(void);
void bang_P_eq(void);
void bang_P_e(ubyte *parm_ptr);

/* 3/08/96 shujin, for pnp */  /* at!p?, band_P_q, command */
void bang_P_q(void)
{
	ubyte i,j,k, *ptr, str[16], pnp[4], error;

/*   read 4 pnp bytes from NVRAM */
       modem_read_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

       k=0;
       for(i=0; i<4; i++)
       {
/* convert num to ascii, put into pt[] */
         ptr = d_to_a(pnp[i]);             /* ptr =&pt[0] */

/* put pt[0],pt[1],pt[2] into pnp string */
         for(j=0; j<3; j++)
             str[k++] = *ptr++;
         str[k++] = ',';
       }

       str[--k] = 0;         /*1st decrease, then assign val, pnp[16]=0 */

       output_info(str,(ubyte)sr14.verbose_form);
}

/* at!p=? (0-255),(0-255),(0-255) command, see ac00pro.h */
void bang_P_eq(void)
{
    output_info((ubyte *)BANG_P_QUERY_INFO,(ubyte)sr14.verbose_form);
}

extern ubyte modem_eeprom_checksum();

/* Command format ex: at!p=100,101,102,103 CR or at!p=100,,,200CR */
/* 4 fields to parse, serial #, bytes 0,1,2,3, */
void bang_P_e(ubyte *parm_ptr)
{
    ubyte  field, value, i, pnp[4];

/* get pnp vender id from NVRAM */
    modem_read_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

    for (i=0; i< 5; i++)
    {
        field = *parm_ptr++;
        value = *parm_ptr++;

        switch (field)
        {
          case 0:
/* saved values */
            modem_write_data(PNP_SERIAL_ID_ADDR,PNP_SERIAL_ID_SIZE,pnp);

/* should take care of eeprom checksum */

            value = modem_eeprom_checksum();
            modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,&value);
            return ;

        case 1:
             pnp[0] = value;
             break;
/* If field 1 is present,save it into pnp[0], and so on */

        case 2:
             pnp[1] = value;
             break;

        case 3:
             pnp[2] = value;
             break;

        case 4:
             pnp[3] = value;
             break;

        default:
             error_occurred = TRUE;
             return;
/* If more than 4 parameters for the command, means an error */
        }  /* switch on parameter field */
    } /* for */
    error_occurred = TRUE;
}

/* JT03196 , for comram packet at!c direct access*/

void bang_C_e(ubyte *parm_ptr);
void  bangC_pkt_to_from_dsp (ubyte read_dsp_mb[]);
ubyte *d_to_hex(ubyte num);

/* max 40 fields to parse */
#define PACKET_LEN_BYTE            40
/* max 20 bytes of DSP RESPONSE LENGTH */
#define DSP_RESP_LENGTH            20

void bang_C_e(ubyte *parm_ptr)
{
    ubyte  field, value, i;
    ubyte  j, k, *ptr, str[DSP_RESP_LENGTH*3];
    ubyte  dsp_response_data[DSP_RESP_LENGTH];


    for (i=0; i <= PACKET_LEN_BYTE; i++)
    {
        field = *parm_ptr++;
        value = *parm_ptr++;

        if (field)
            current_command [i] = value;
        else
/* end of cmd string*/
        {
            if (i < 4)
               {
                  error_occurred = TRUE;
                  return;
               }
            else

/* action here */
               {

                  bangC_pkt_to_from_dsp(dsp_response_data);

                  k=0;
                  for(i = 0; i < dsp_response_data[2] + 4; i++)
                  {
/* convert num to hex display, put into pt[] */
                     ptr = d_to_hex(dsp_response_data[i]);    /* ptr =&pt[0] */

/* put pt[0],pt[1] into str[] */
                     for(j=0; j<2; j++)
                     str[k++] = *ptr++;
                     str[k++] = ',';
                  }

                  str[--k] = 0;         /*1st decrease, then assign val, pnp[16]=0 */

                  output_info(str,(ubyte)sr14.verbose_form);
                  return ;
               }
         }
    } /* for */
    error_occurred = TRUE;
}

extern ubyte dsp_timer;
extern void process_wait (void);
extern ubyte cp_dsp (void);
#define DSP_TIMEOUT       100    /* waiting for DSP to READ or WRITE */
#define DSP_DONE            1

void  bangC_pkt_to_from_dsp (ubyte read_dsp_mb[])
{

   ubyte i, *temp;

   dsp_timer = DSP_TIMEOUT;
   while ( dsp_timer )
   {
   	process_wait();

	  if( cp_dsp() == DSP_DONE )
		 break;
   }

   /* Did we have trouble */
   if( !dsp_timer )
	{
		/*mt_driver_error_handler(MT_ERR_SEND_PKT_DSP);*/
		mt_driver_error_handler(current_command[0]);
	}

/* done with sending packet, now try to get dsp packet back */

   dsp_timer = DSP_TIMEOUT;
   temp = (ubyte *)(COM_RAM + DSP_CP_CMD_START);

   while ( dsp_timer )
   {
   	process_wait();

     if( *temp != 0x00)
		 break;
   }

        for (i = 0 ; i < 4 ; i++)
        read_dsp_mb [i] = *temp++;

          /*if packet_length is > zero then the data should follow */

        if (read_dsp_mb [2] > 0)
          {
               for (i = 4 ; i < read_dsp_mb[2] + 4; i++)
                    read_dsp_mb [i] = *temp++;
           }

          /*write the semaphore*/
          temp = (ubyte *) (COM_RAM + DSP_CP_CMD_START);
          *temp = 00;

          return;

}



ubyte *d_to_hex(ubyte num)
{
	ubyte i = 2;

	do {
		i--;
		pt[i] = num % 16;
      if (pt[i] < 10)
		pt[i] = pt[i] + '0';
      else
		pt[i] = pt[i] - 10 + 'A';
		num = num / 16;
	} while (i != 0);

	pt[2] = 0;
	return ((ubyte *)&pt[0]);
}

#ifndef __riscos
#define P_MEM_LOCATION 0xffff04
#define D_MEM_LOCATION 0xffff0c
#endif

/*******************************************************************************
/
/	Routine: at_W
/
/	Author:  RSA
/
/	Creation Date:	07/17/91
/
/	Input Parameters: None
/
/	Output Parameter: None
/
/	Global Variables Changed: str_WP
/
/	Users: execute_cmd()
/
/	-----------------------------------------------------------------
/	-			  Modifications 			-
/	-----------------------------------------------------------------
/
/	Author & Date:
/	Description:
/
*******************************************************************************/
#ifndef __riscos
void str_WP(ubyte *param_ptr)
{

 	ubyte wait,*value,wait_val;


   if (*param_ptr <= 7)
	{
		value = (ubyte*)	P_MEM_LOCATION;
		wait = *param_ptr << 4;
   	wait_val = *value & 0x0f;
   	*value = wait_val | wait;
	}
	else
      error_occurred = TRUE;


}
#endif
/*******************************************************************************
/
/	Routine: at_W
/
/	Author:  RSA
/
/	Creation Date:	07/17/91
/
/	Input Parameters: None
/
/	Output Parameter: None
/
/	Global Variables Changed: str_WD
/
/	Users: execute_cmd()
/
/	-----------------------------------------------------------------
/	-			  Modifications 			-
/	-----------------------------------------------------------------
/
/	Author & Date:
/	Description:
/
*******************************************************************************/
#ifndef __riscos
void str_WD(ubyte *param_ptr)
{


	ubyte wait,*value,wait_val;


   if (*param_ptr <= 7)
	{
		value = (ubyte*)	D_MEM_LOCATION;
		wait = *param_ptr << 4;
   	wait_val = *value & 0x0f;
   	*value = wait_val | wait;
	}
	else
      error_occurred = TRUE;


}
#endif

/*******************************************************************************
/
/	Routine: at*FID
/
/	Author:  RSA
/
/	Creation Date:	08/27/96
/
/	Input Parameters: None
/
/	Output Parameter: None
/
/	Global Variables Changed:
/
/	Users: execute_cmd()
/
/	-----------------------------------------------------------------
/	-			  Modifications 			-
/	-----------------------------------------------------------------
/
/	Author & Date:
/	Description: dsp not resp. message
/
*******************************************************************************/
void str_FID(void)
{


			output_send_cr_lf();
			output_info(d_to_a(dsp_packet_id_msg[0]),UNFORMATTED);
		  	dsp_packet_id_msg [0] = 0x00;


}
