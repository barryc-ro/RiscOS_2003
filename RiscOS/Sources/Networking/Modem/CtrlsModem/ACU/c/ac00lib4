/****************************************************************************
/
/     Copyright 1988,1989,1990,1991,1992,1993,1994,1995.
/     All Rights Reserved by:
/        RSA
/        7701 Six Forks Road
/        Suite 120
/        Raleigh, NC  27615
/        (919) 846-7171
/
/     This document contains material confidential to RSA its contents must
/     not be revealed, used or disclosed to anyone or company with out
/     written permission by RSA.  The information contained herein is solely
/     for the use of RSA.
/
/     File:             ac00lib4.c
/
/     Module Version:   ACU 5.01
/
/     Function:         This file contains the misc Routines for the ACU code
/
/     Product:          ACU core code
/
/     History:          ac00lib4.c v3.90
/                       ac00lib4.c v3.91
/                       ac00lib4.c v3.92
/                       ac00lib4.c v3.94
/                       ac00lib4.c v3.96
/                       ac00lib4.c v4.02
/                       ac00lib4.c v5.01
/
/        Created:       10/7/91
/                       10/21/91
/                       12/04/91
/                       3/10/91
/                       1/12/93
/                       12/12/94
/                       01/23/97
/        ---------------------------------------------------------
/        -                   Modifications                       -
/        ---------------------------------------------------------
/
/        Author & Date:  RSA
/        Description:
/        Reason:
/
*****************************************************************************/

#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "mt_pro.h"
#include "v25_pro.h"
#include "ll_pro.h"
#include "fp_pro.h"
#include "fax_pro.h"
#include "vce_pro.h"
#include "acu_vce.h"
#include "acu_epro.h"           /* ACU ETC Driver interface prototypes */
#include "sleep_if.h"
#include "v34_rate.h"
#include "ptt.h"
#include "homolig1.h"

void x2_tx_message(ubyte type);
void x2_rx_message(ubyte type);
void output_result(ubyte);      /* MH different in V326 */
void output_result_message(ubyte,ubyte);
void process_acu_timer(void);
void check_char_rcvd(void);
ubyte translate_modem_mode(ubyte);
void check_modem_status(void);
ubyte ring_was_on_before = FALSE;

/*mrm2795*/
/*atx6 command for Tx and Rx rate in v34 mode*/

void v34_tx_rx_message(ubyte type);
extern ubyte callch;
extern ubyte answerch;
extern ubyte v34_tx_rx_display;
ubyte v34_type;
extern line_mode;
extern void rate_message(void);
extern ubyte ms_mode;
/* 30196 shujin */
extern ubyte date[];
extern ubyte time[];
extern ubyte nmbr[];
extern ubyte name[];
extern ubyte mesg[];

extern uword vce_send_tone_timer; /* ramn 3/20/96 */
extern ubyte sleep_timer_val;
extern ubyte alb_timer1sec ; /* ramn 11/21/96 */

extern ubyte vce_mode; /* ramn 12/3/96 */
extern ubyte spkr_phn_mode; /* ramn 12/3/96 */
extern ubyte CountryInfo;         /* MH110997 */
extern ubyte shunt_timer_en;    
extern ubyte shunt_timer;
void process_sleep_timer(void);
void retrain_bg(void);

/*******************************************************************************
/
/     Routine:       output_result
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to out put a result message to the
/            terminal.  It will decide what messages are to be sent
/            and it will send them to output_result_message to place
/            then on the DTE.
/
/     Input Parameters: ubyte type  - type of result message to be sent
/                    0  - OK
/                    1  - CONNECT
/                    2  - RING
/                    3  - NO CARRIER
/                    4  - ERROR
/                    5  - CONNECT 1200
/                    6  - NO DIALTONE
/                    7  - BUSY
/                    8  - NO ANSWER
/                    9  - CONNECT 0600
/                    10 - CONNECT 2400
/                    11 - CONNECT 4800
/                    12 - CONNECT 9600
/                    13 - NONE
/                    14 - CONNECT 19200
/                    15 - CONNECT XXXX
/                    16 - CARRIER XXXX
/                    17 to 24 - Reserved
/
/                    25 - CONNECT 75/1200
/                    26 - CONNECT 1200/75
/                    27 - Reserved
/                    28 - CONNECT 38400
/                    28 to 39 - Reserved
/
/                    40 - CARRIER 300
/                    41 - Reserved
/                    42 - CARRIER 75/1200
/                    43 - CARRIER 1200/75
/                    44 - Reserved
/                    45 - Reserved
/                    46 - CARRIER 1200
/                    47 - CARRIER 2400
/                    48 - CARRIER 4800
/                    49 - Reserved
/                    50 - CARRIER 9600
/                    51 - CARRIER 12000
/                    52 - CARRIER 14400
/                    53 - CARRIER 16800
/                    54 - CARRIER 19200
/                    55 - CARRIER 21600
/                    56 - CARRIER 24000
/                    57 - CARRIER 26400
/                    58 - CARRIER 28800
/                    59 - CONNECT 16800
/                    61 - CONNECT 21600
/                    62 - CONNECT 24000
/                    63 - CONNECT 26400
/                    64 - CONNECT 28800
/                    65 - Reserved
/                    66 - COMPRESSIION_MNP5
/                    67 - COMPRESSIION_V42BIS
/                    68 - Reserved
/                    69 - COMPRESSIION_NONE
/                    70 - PROTOCOL NONE
/                    71 to 76 - Reserved
/                    77 - PROTOCOL LAP_M
/                    78 - PROTOCOL LAP_M/ETC
/                    79 - Reserved
/                    80 - PROTOCOL MNP
/                    81 - PROTOCOL MNP2
/                    82 - PROTOCOL MNP3
/                    83 - PROTOCOL MNP4
/                    84 - Reserved
/                    85 - RING_BACK
/                    86 - CONNECT 57600
/                    87 - CONNECT 115200
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users:   execute_cmd
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date: RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void output_result(ubyte type)
{

    ubyte ptr[SYSTEM_INFO_SIZE];
    ubyte tmp_byte;
    ubyte modem_dce_baud;
    ubyte arq_en,*string;

/*mrm22596*/
/*Changed the connect messages per our user guide*/
     v34_type = 1;

    modem_serial_direct(NORMAL);
    /*modem_serial_echo(OFF);*/ /* ramn 9/20/96 */
    set_parms(acu_data_bits,acu_parity,acu_stop_bits);

    arq_en = NONE;

    /* Output CARRIER message */
    if (type == CARRIER_XXXX)
    {
         if ((atW == 4) )
          {

/*MRM22896*/
/*added the condition for the test mode*/

/*       string = (ubyte*) SLASH;
            output_info(string,UNFORMATTED);
*/
            v34_type = 0;

/*       type = 69;
*/
            type = PROTOCOL_W4;

            output_send_cr_lf();

            output_result_message(type, arq_en);

           system_info((ubyte *)&ptr[0]);

             /* Print protocol type */

             if ((system_status == V42_SPEED) ||
                (operating_mode == DIRECT) || (test_in_progress))
                type = PROTOCOL_NONE;

          else if (operating_mode == V80_SAM)
             type = PROTOCOL_V80_SAM;


             if (system_status == V42_LAPM)
             {
                    type = PROTOCOL_LAP_M;
             }

             if (system_status == V42_MNP)
             {

                if (ptr[OFFSET_ASYNC_SYNC])
                       type = PROTOCOL_MNP3;
                    else
                       type = PROTOCOL_MNP2;
                    if (ptr[OFFSET_OPTIMIZATION])
                       type += PROTOCOL_MNP4;
                    if (ptr[OFFSET_NEGOT_MNP10])
                       type += PROTOCOL_MNP10;

             }

            v34_type = 0;

            output_result_message(type, arq_en);
            output_send_cr_lf();
          }


         if ((atW == 4) )

          {

/*MRM22896*/
/*added the condition for the test mode*/

             /* Printing compression type */
            v34_type = 0;

/*
            type = 70;
*/
            type = COMPRESSION_W4;

            output_result_message(type, arq_en);

             /* Printing compression type */

             if ((ptr[OFFSET_COMPRESSION] == 0) ||
                (operating_mode == DIRECT)|| (test_in_progress) ||
           (operating_mode == V80_SAM))
                type = COMPRESSION_NONE;
             else
             {
                if (system_status == V42_LAPM)
                    type = COMPRESSION_V42BIS;
                else
                {
                    if (ptr[OFFSET_COMPRESSION] == 1)
                       type = COMPRESSION_MNP5;
                    else
                       type = COMPRESSION_V42BIS;
                }
             }


                /*v34_type = 0;*/

                output_result_message(type, arq_en);
                output_send_cr_lf();

          }




       if ( ((atW == 2 ) && (sr22.enable_result5)) ||  ((atW == 4 ) && (sr22.enable_result5)) )

       {

#if MODEM_X2_MODE == 1
   if (line_mode == 22)
      modem_dce_baud = answerch;
   else
      modem_dce_baud = modem_baud;
#endif
          switch (modem_dce_baud)           /* DCE Speed */
          {
             case BPS1200_75: 
               type = CONNECT_1200_75;
                break;
             case BPS75_1200: 
                if (line_mode == 22)
               type = CONNECT_33333;
            else
               type = CONNECT_75_1200;
                break;

             case BPS300: 
                if (line_mode == 22)
                   type = CONNECT_37333;
            else
               type = CONNECT;
                break;

             case BPS1200: 
                if (line_mode == 22)
                   type = CONNECT_41333;
            else
               type = CONNECT_1200;
                break;

             case BPS2400: 
                if (line_mode == 22)
                   type = CONNECT_42666;
            else
               type = CONNECT_2400;
                break;

             case BPS4800: 
                if (line_mode == 22)
                   type = CONNECT_44000;
            else
               type = CONNECT_4800;
                break;

             case BPS7200: 
                if (line_mode == 22)
                   type = CONNECT_45333;
            else
               type = CONNECT_7200;
                break;

             case BPS9600: 
                if (line_mode == 22)
                   type = CONNECT_46666;
            else
               type = CONNECT_9600;
                break;

             case BPS12000: 
                if (line_mode == 22)
                   type = CONNECT_48000;
            else
               type = CONNECT_12000;
                break;

             case BPS14400: 
                if (line_mode == 22)
                   type = CONNECT_49333;
            else
               type = CONNECT_14400;
                break;

             case BPS16800: 
                if (line_mode == 22)
                   type = CONNECT_50666;
            else
               type = CONNECT_16800;
                break;

             case BPS19200: 
                if (line_mode == 22)
                   type = CONNECT_52000;
            else
               type = CONNECT_19200;
                break;
#if MODEM_X2_MODE == 1
             case BPS38400: 
               type = CONNECT_53333;
                break;
             case BPS57600: 
               type = CONNECT_54666;
                break;
             case BPS115200: 
               type = CONNECT_57333;
                break;
#endif
             case BPS600: 
                if (line_mode == 22)
                   type = CONNECT_56000;
            else
               type = CONNECT_0600;
                break;

             case BPS21600: type = CONNECT_21600;
                break;

             case BPS24000: type = CONNECT_24000;
                break;

             case BPS26400: type = CONNECT_26400;
                break;

             case BPS28800: type = CONNECT_28800;
                break;

             case BPS31200: type = CONNECT_31200;
                break;

             case BPS33600: type = CONNECT_33600;
                break;

             default: type = NONE;
                break;
          }
       }
/*mrm62796*/
       else if((atW == 2 ) || (atW == 4 ))

                type = CONNECT;

        else
          type = NONE;

        if(atW == 4)
        {
            v34_type = 0;
            output_result_message(type, arq_en);
            output_send_cr_lf();
                return;

        }
    }

    if ((type == CONNECT_XXXX) && ((atW == 0 ) || (atW == 1 ) || (atW == 3 )))
    {
       if (sr22.enable_result5)                /* ATX > 0 */
       {

            tmp_byte = dte_baud;

          switch (tmp_byte)
          {
             case BPS300: type = CONNECT;
                break;

             case BPS600: type = CONNECT_0600;
                break;

             case BPS1200_75: type = CONNECT_1200_75;
                break;

             case BPS75_1200: type = CONNECT_75_1200;
                break;

             case BPS1200: type = CONNECT_1200;
                break;

             case BPS2400: type = CONNECT_2400;
                break;

             case BPS4800: type = CONNECT_4800;
                break;

             case BPS7200: type = CONNECT_7200;
                break;

             case BPS9600: type = CONNECT_9600;
                break;

             case BPS12000: type = CONNECT_12000;
                break;

             case BPS14400: type = CONNECT_14400;
                break;

             case BPS19200: type = CONNECT_19200;
                break;

             case BPS38400: type = CONNECT_38400;
                break;

             case BPS57600: type = CONNECT_57600;
                break;

             case BPS115200: type = CONNECT_115200;
                break;

             case BPS16800: type = CONNECT_16800;
                    break;

             case BPS21600: type = CONNECT_21600;
                break;

             case BPS24000: type = CONNECT_24000;
                break;

             case BPS26400: type = CONNECT_26400;
                break;

             case BPS28800: type = CONNECT_28800;
                break;

             case BPS31200: type = CONNECT_31200;
                break;

             case BPS33600: type = CONNECT_33600;
                break;



             default: type = NONE;
                break;
          }
                arq_en = FALSE;

             if ((atW == 0) || (atW == 1) || !(sr14.verbose_form) )
                    v34_type = 1;
             else
             {
                    output_send_cr_lf();
                    v34_type = 0;
             }
             output_result_message(type, arq_en);

         if ((atW == 0) || (atW == 1) || !(sr14.verbose_form) )
                    return;

                string = (ubyte*) SLASH;
                output_info(string,UNFORMATTED);

                if((atW == 3) &&  (sr14.verbose_form))
                    rate_message();

                string = (ubyte*) SLASH;
                output_info(string,UNFORMATTED);

          system_info((ubyte *)&ptr[0]);

         if ((atW == 3) )

          {

/*MRM22896*/
/*added the condition for the test mode*/

             /* Print protocol type */
             if ((system_status == V42_SPEED) ||
                (operating_mode == DIRECT) || (test_in_progress))
                type = PROTOCOL_NONE;

             if (system_status == V42_LAPM)
             {
                    type = PROTOCOL_LAP_M;
             }

             if (system_status == V42_MNP)
             {

                if (ptr[OFFSET_ASYNC_SYNC])
                       type = PROTOCOL_MNP3;
                    else
                       type = PROTOCOL_MNP2;
                    if (ptr[OFFSET_OPTIMIZATION])
                       type += PROTOCOL_MNP4;
                    if (ptr[OFFSET_NEGOT_MNP10])
                       type += PROTOCOL_MNP10;

             }

                output_result_message(type, arq_en);
                string = (ubyte*) SLASH;
                output_info(string,UNFORMATTED);

          }


         if ((atW == 3) )

          {

/*MRM22896*/
/*added the condition for the test mode*/

             /* Printing compression type */

             if ((ptr[OFFSET_COMPRESSION] == 0) ||
                (operating_mode == DIRECT)|| (test_in_progress))
                type = COMPRESSION_NONE;
             else
             {
                if (system_status == V42_LAPM)
                    type = COMPRESSION_V42BIS;
                else
                {
                    if (ptr[OFFSET_COMPRESSION] == 1)
                       type = COMPRESSION_MNP5;
                    else
                       type = COMPRESSION_V42BIS;
                }
             }

            output_result_message(type, arq_en);

            if((atW == 3) &&  (sr14.verbose_form))
            {


                string = (ubyte*) CALL_CH;
                output_info(string,UNFORMATTED);

#if MODEM_X2_MODE == 1

         if (line_mode == 22)
         {
                    x2_tx_message(callch);
                   string = (ubyte*) ANSWER_CH;
                   output_info(string,UNFORMATTED);
                    x2_rx_message(answerch);
         }
         else
         {

                if(sr14.originate_flag)

                    v34_tx_rx_message(callch);
                else
                    v34_tx_rx_message(answerch);



                string = (ubyte*) ANSWER_CH;
                output_info(string,UNFORMATTED);

                if(sr14.originate_flag)

                    v34_tx_rx_message(answerch);
                else
                    v34_tx_rx_message(callch);

          }
                v34_type = FALSE;

#else
                if(sr14.originate_flag)

                    v34_tx_rx_message(callch);
                else
                    v34_tx_rx_message(answerch);


                string = (ubyte*) ANSWER_CH;
                output_info(string,UNFORMATTED);

                if(sr14.originate_flag)

                    v34_tx_rx_message(answerch);
                else
                    v34_tx_rx_message(callch);

                v34_type = FALSE;
#endif

            }


          }


        }
       else
        {
            type = CONNECT;
            output_result_message(type, arq_en);
            return;

        }

        output_send_cr_lf();
        return;


    }





    v34_type = 1;
    output_result_message(type, arq_en);
}


/*******************************************************************************
/
/     Routine:       output_result_message
/
/     Author:        RSA
/
/     Creation Date: 07/18/91
/
/     Description:   This Routine is called to out put the selected result
/                    message to the terminal.
/
/     Input Parameters: byte type - type of result message to be sent
/                    0  - OK
/                    1  - CONNECT
/                    2  - RING
/                    3  - NO CARRIER
/                    4  - ERROR
/                    5  - CONNECT 1200
/                    6  - NO DIALTONE
/                    7  - BUSY
/                    8  - NO ANSWER
/                    9  - CONNECT 0600
/                    10 - CONNECT 2400
/                    11 - CONNECT 4800
/                    12 - CONNECT 9600
/                    13 - NONE
/                    14 - CONNECT 19200
/                    15 - CONNECT XXXX
/                    16 - CARRIER XXXX
/                    17 to 24 - Reserved
/                    25 - CONNECT 75/1200
/                    26 - CONNECT 1200/75
/                    27 - Reserved
/                    28 - CONNECT 38400
/                    28 to 39 - Reserved
/                    40 - CARRIER 300
/                    41 - Reserved
/                    42 - CARRIER 75/1200
/                    43 - CARRIER 1200/75
/                    44 - Reserved
/                    45 - Reserved
/                    46 - CARRIER 1200
/                    47 - CARRIER 2400
/                    48 - CARRIER 4800
/                    49 - Reserved
/                    50 - CARRIER 9600
/                    51 - CARRIER 12000
/                    52 - CARRIER 14400
/                    53 - CARRIER 16800
/                    54 - CARRIER 19200
/                    55 - CARRIER 21600
/                    56 - CARRIER 24000
/                    57 - CARRIER 26400
/                    58 - CARRIER 28800
/                    59 - CONNECT 16800
/                    61 - CONNECT 21600
/                    62 - CONNECT 24000
/                    63 - CONNECT 26400
/                    64 - CONNECT 28800
/                    65 - Reserved
/                    66 - COMPRESSIION_MNP5
/                    67 - COMPRESSIION_V42BIS
/                    68 - Reserved
/                    69 - COMPRESSIION_NONE
/                    70 - PROTOCOL NONE
/                    71 to 76 - Reserved
/                    77 - PROTOCOL LAP_M
/                    78 - PROTOCOL LAP_M/ETC
/                    79 - Reserved
/                    80 - PROTOCOL MNP
/                    81 - PROTOCOL MNP2
/                    82 - PROTOCOL MNP3
/                    83 - PROTOCOL MNP4
/                    84 - Reserved
/                    85 - RING_BACK
/                    86 - CONNECT 57600
/                    87 - CONNECT 115200
/
/               arq  0 - /ARQ not displayed
/                    1 - /ARQ displayed
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users:   output_result
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date: RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void output_result_message(ubyte type,ubyte arq_en)
{

    char *msg;

/*mrm22596*/
/*Changed the connect messages per our user guide*/

    if ((!sr14.disable_result_code) && (type != NONE))
    {
       result_message_sent = TRUE;
/* start change keh 9/28/95 => add inter module messaging for VoiceView */
/*        if (!sr14.verbose_form) */
       if (!sr14.verbose_form && type != ACU_MESSAGE_PTR)
/* end change keh 9/28/95 => add inter module messaging for VoiceView */
       {
          if (type == FCERROR)
          {
             acu_to_char('+');
             acu_to_char('F');
             acu_to_char('4');
          }
          else
          {
             msg = (char *)d_to_a(type);
             msg++;
             if (*msg != '0')
                acu_to_char(*msg);
             msg++;
             acu_to_char(*msg);
          }

          if (s[3] != NULL)
             acu_to_char(s[3]);
       }
/* RJM101096 */
/* V.80 support */
      else if ((type == V80_ECS_OK) || (type == V80_NO_CARRIER))
      {
     /* point to the beginning of the V.80 response and message */
     msg = (char*)(*(out_put + type))[0];

     /* send out the response */
     acu_to_char(*msg++);
     acu_to_char(*msg++);

     /* separate the response and message by <CR><LF> */
     output_send_cr_lf();

     /* send the message */
     while (*msg != NULL)
        acu_to_char(*msg++);

     /* send the closing <CR><LF> */
     output_send_cr_lf();
      }
/* Start Change 8/1/1994. */
       else if ((type == CPOF) || (type == CPON))
       {
          while (acu_to_free() <= 25){}

/* start change keh 3/29/95 => send spacing before CPOFF */
          /* Add spacing between CPOF/CPON messages if not in voice mode */
          if ((type == CPOF) && (voice_cmd_set != TIA_IS_101))
             output_send_cr_lf();
/* end change keh 3/29/95 => send spacing before CPOFF */

          /* Output Voice Distinctive Cadence message */
          msg =  (*(out_put + type))[0];
          while (*msg != NULL)
             acu_to_char(*msg++);

          /* Output value of distinctive cadence time */
          if (type == CPOF)
             msg = (char *)d_to_a(voice_ctl_tone_off);
          else if (type == CPON)
             msg = (char *)d_to_a(voice_ctl_tone_on);

          /* Send only 2 least significant digits of ASCII number */
          msg++;
          if (*msg != '0')
             acu_to_char(*msg);
          msg++;
          acu_to_char(*msg);
          output_send_cr_lf();

       }

/*  3/27/96 shujin */
       else if((type == SHIELDED_RING) || (type == COMPLEX_PACKET_START) ||
          (type == COMPLEX_PACKET_END) )
       {
          while (acu_to_free() <= 25){}

         msg =  (*(out_put + type))[0];

          while (*msg != NULL)
             acu_to_char(*msg++);

         output_send_cr_lf();
      }
/* end 30196 shujin */

/* End Change 8/1/1994. */
       else
       {
          while (acu_to_free() <= 25){}

            if (v34_type == 1)
                 output_send_cr_lf();

         if (type == ACU_MESSAGE_PTR)
            msg = (char *)message_ptr;

         /* Else use canned ACU messages */

         else
            msg =  (*(out_put + type))[0];

/* end change keh 9/28/95 => add inter module messaging for VoiceView */

          while (*msg != NULL)
             acu_to_char(*msg++);

          /* Output ARQ message     */
          if (arq_en == TRUE)
          {
             msg = (char *)"/ARQ";
             while (*msg != NULL)
                acu_to_char(*msg++);
          }

          if (v34_type == 1)

             output_send_cr_lf();

       }
    }
}

/*******************************************************************************
/
/     Routine:       process_acu_timer
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called every 10 msecs to provide timing
/                    for the modules of the ACU.
/
/     Input Parameters: none
/
/     Output Parameters: none
/
/     Global Variables Changed:  All timer varables
/
/     Users:   timer interrupt
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date: RSA
/     Description:
/     Reason:
/
*******************************************************************************/
extern ulong MySystemTimer;

void process_acu_timer(void)
{
   /* Process 0.01 second timers   */
   while (acu_10msec_timer != 0)
   {
#ifdef DEBUG_PORT
   MySystemTimer++;
#endif

#if CUSTOMER35 == TRUE
      /* While this timer is not zero,  Check to see if the RJ11 Jack is a Digital Line */
      if (CheckDigLineTimer != 0)
      {
        CheckDigLineTimer--;
        if (Diglin_Read() == TRUE)
        {
            on_hook();
        }
      }
#endif

      acu_10msec_timer--;

#if INTERNATIONAL_CODE == 1
/* MH110697 */
                       if(shunt_timer != 0)
                          shunt_timer--;
                       else
                          shunt_timer_en=0;
#endif

      /* v25_10ms_timer();     */    /* ramn 9/27/96 */

/* 9/9/97 shujin, here is redundant, it is called in Acu_main()  
      process_customer_timer();
*/


      /*check_frontpan_switches();*/                /* ramn 9/26/96 */

      /* Determine if DTR change is valid or just a glitch   */
      if ((!modem_dte_DTR_status()) && (!DTR_always_on))
      {
     if (dte_DTR_flag)
     {
        dtr_timer = s[25];
        dte_DTR_flag = FALSE;
     }
     else if ((dtr_timer == 0) && (DTR_valid_up_flag))
     {
        DTR_valid_up_flag = FALSE;
            /*if ((comm_mode != ASYNC) || (sr21.DTR_control != 0))
                modem_tr_led(OFF);*/ /* ramn 9/20/96 */
     }
      }
      else
      {
     if (!dte_DTR_flag)
     {
        dtr_timer = s[25];
        dte_DTR_flag = TRUE;
     }
     else if ((dtr_timer == 0) && (!DTR_valid_up_flag))
     {
        DTR_valid_up_flag = TRUE;
            /*modem_tr_led(ON);*/ /* ramn 9/20/96 */
     }
      }

      if (dtr_timer) dtr_timer--;
      if (cts_timer) cts_timer--;
      if (timer1) timer1--;
      if (timer2) timer2--;
      if (timer3) timer3--;
      if (timer5) timer5--;

      if (vce_send_tone_timer)  /* ramn 3/20/96 */
            vce_send_tone_timer--;

      /* Process Leased line 10 msec timers */
      /*ll_10msec_timer();*/  /* ramn 9/23/96 */

      /* Process Fax 10 msec timers   */
      process_fax_timer();
   }

   /* Process 0.1 second timers   */
   while (acu_100msec_timer != 0)
   {
      acu_100msec_timer--;
      system_timer();

      /* Process Front panel 100 msec timers    */
      /*fp_100msec_timer();*/               /* ramn 9/26/96 */

      /* Process voice 100 msec timers */
      voice_timer();

      if (voice_ring_rpt_timer)
      {
     voice_ring_rpt_timer--;
     if (!voice_ring_rpt_timer)
     {
        build_event(E_MSG,RING);
        if (voice_cmd_set == TIA_IS_101)
           build_event(E_MSG,COMPLEX_PACKET_END);
     }
      }

      voice_ring_timer++;
    }

   /* Process 1 second timers */
   while (acu_1sec_timer != 0)
   {
      acu_1sec_timer--;

      if(alb_timer1sec)
          alb_timer1sec-- ; /* ramn 11/21/96 */

      if (dtr_timer1sec)
      {
     dtr_timer1sec--;
     if (dtr_timer1sec==0)
     {
        if (!DTR_valid_up_flag)
           build_event(E_V24,DTR_OFF);
     }
      }
      /* Process Leased line 1 sec timers      */
      /*ll_1sec_timer();*/  /* ramn 9/23/96 */

      /* Process V.25bis 1 sec timers    */
      /*v25_1sec_timer();    */    /* ramn 9/27/96 */

      /* Run sleep timer if idle */
      /*
          In voice go to sleep only if in OFFLINE COMMAND mode and
          also not in speaker phone mode

          ramn 12/3/96
        */
      if (acu_state == S_IDLE && !on_line_command
            && (vce_mode == 0) && (spkr_phn_mode != TRUE)           /* ramn 12/3/96 */
          )

      process_sleep_timer();
/* 5/1/96 shd, add the next line for sleep mode */
        else
            sleep_timer_val = 0;      /* used in sleep.c */
   }

   while (acu_1min_timer != 0)
   {
      acu_1min_timer--;

      /* Process Leased line 1 min timers      */
      /*ll_1min_timer();*/  /* ramn 9/23/96 */

      /* Process V.25bis 1 min timers    */
      /*v25_1min_timer();    */    /* ramn 9/27/96 */
   }
}

/*******************************************************************************
/
/     Routine:       check_char_rcvd
/
/     Author:        RSA
/
/     Creation Date: 06/13/91
/
/     Description:   This Routine is called to check if a character has been
/                    received from the terminal.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users:   main
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date: RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void check_char_rcvd(void)
{
   if (acu_from_num())
      build_event(E_CHAR_RCVD,UNUSED);
}

/*******************************************************************************
/
/     Routine:       translate_modem_mode
/
/     Author:        RSA
/
/     Creation Date: 05/07/91
/
/     Description:   This Routine is called to translate the baud rate passed
/                    in into parameter values for modem_connect()
/
/     Input Parameters: ubyte baud_rate - baud rate to be used to select the mode
/
/     Output Parameters: ubyte mode - type of mode for the connection
/                    0 - Bell 103
/                    1 - Bell 212
/                    2   V21
/                    3   V21_CHAN2
/                    4   V23_ADX
/                    5   V23_HDX
/                    6   V22
/                    7   V22BIS
/                    8   V27_SHORT
/                    9   V27_LONG
/                    10  V27_TER
/                    11  V29
/                    12  V32
/                    13  V32_TCM
/                    14  V17
/                    15  V33
/                    16  V32bis
/                    17  V34
/                    18  V34 Asymetric
/
/     Global Variables Changed:  none
/
/     Users:   answ_init_modem, orig_init_modem, init_ALB_test
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date: RSA
/     Description:
/     Reason:
/
*******************************************************************************/
ubyte translate_modem_mode(ubyte baud_rate)
{

   ubyte mode;

/*mrm22596*/
/*removed the b commands group 2-16*/

   /* If baud rate is greater than 2400 need to force the rate to 2400
      if this is a V.22bis modem. */
   if ((baud_rate > BPS2400) && (baud_rate != BPS600))
      if (acu_cfg.mode == CFG_V22BIS)
         baud_rate = BPS2400;

   switch (baud_rate)
    {
        case BPS75_1200:
         mode = V23_ADX;
         break;

        case BPS300:
            switch (atB.group3)
            {
                case 15: mode = V21;
                     break;

                case 16: mode = BELL_103;
                     break;
            }
            break;

        case BPS600:
            mode = V22;
            break;

        case BPS1200:
            switch (atB.group1)
            {
                case 0: mode = V22;
                    break;

                case 1: mode = BELL_212;
                    break;

                case 2:
                case 3: mode = V23_ADX;
            }
            break;

        case BPS2400:

            mode = ms_mode;
            break;

        case BPS4800:

            mode = ms_mode;
            break;

      case BPS7200:
            mode = ms_mode;
         break;

        case BPS9600:
            mode = ms_mode;
            break;

        case BPS12000:
            mode = ms_mode;

         break;

        case BPS14400:
            mode = ms_mode;
              break;

        case BPS16800:
        case BPS19200:
        case BPS38400:
        case BPS57600:
        case BPS115200:
      case BPS21600:
      case BPS24000:
      case BPS26400:
      case BPS28800:
      case BPS31200:
      case BPS33600:
      case BPS36000:
        mode = ms_mode;
         break;

#if MODEM_X2_MODE == 1
        case BPS33333:
        case BPS37333:
        case BPS41333:
        case BPS42666:
        case BPS44000:
        case BPS45333:
        case BPS46666:
        case BPS48000:
        case BPS49333:
        case BPS50666:
        case BPS52000:
        case BPS53333:
        case BPS54666:
        case BPS56000:
        case BPS57333:
            mode = ms_mode;
            break;
#endif

        default:
            mode = 0;
    }
    
    return (mode);
}

/*******************************************************************************
/
/     Routine:       check_modem_status
/
/     Author:        RSA
/
/     Creation Date: 06/24/91
/
/     Description:   This Routine is called to build events based upon
/                    the status of the modem.
/
/     Input Parameters: None
/
/     Output Parameters: none
/
/     Global Variables Changed:  None
/
/     Users:  master_bg
/
/     -------------------------------------------------------------
/     -                       Modifications                       -
/     -------------------------------------------------------------
/
/     Author & Date: RSA
/     Description:
/     Reason:
/
*******************************************************************************/
void check_modem_status(void)
{
   /* Don't check modem status in VoiceView mode */
   if ((fax_class == 80) || (fax_class == 8)) /* added by ramn on 10/10/95 */
      return;

     acu_cd_loss_time = s[10];              /* ramn 3/5/96 */

   /* Test for Carrier signal */
   if (!modem_check_CD())
      build_event(E_DP_CD_OFF,UNUSED);

   /* Test for change in modem status */
   if (last_modem_status != modem_status)
   {
      last_modem_status = modem_status;

      /* If under RDL, build test event */
      if ((modem_status == REMOTE_TEST_STATUS) && (!test_in_progress))
      {
     build_event(E_TEST,RMT_TEST);
     previous_acu_state = acu_state;
      }
      /* Else if retrain, build retrain event */
      else if (modem_status == RETRAINING_STATUS)
     build_event(E_RETRAIN,UNUSED);
   }

   /* Execute ACU's retrain background processing */
   if (st_retrain.state == S_RETRAIN)
   {
      retrain_bg();
   }

   /* Test modem call progress RING detection and CP tone reporting */
   switch (modem_call_progress())
   {
      case UNDETERMINED:
      case SILENCE:
      case LINE_SIGNAL:
      default:
     /* Reset control tone reporting trigger */
     voice_dist_ctl_sent = FALSE;
     break;

      case RINGON:
     /* Ring is posted in the voice driver under voice mode */
     if (fax_class != 8)
        build_event(E_RING,RINGON);
             ring_was_on_before = TRUE;
     break;

      case BUSY_SIGNAL:
      case RINGBACK:
     /* Report Control Tone Cadences if enabled */
     if (voice_dist_ctl_active && !voice_dist_ctl_sent)
     {
        voice_dist_ctl_sent = TRUE;
        modem_ctl_tone_energy(&voice_ctl_tone_on,&voice_ctl_tone_off);
        build_event(E_MSG,CPOF);
        build_event(E_MSG,CPON);
     }
     break;

      case RINGOFF:
/*ring detc*/

          /* Ring is posted in the voice driver under voice mode */
          if ((fax_class != 8) && (ring_was_on_before))
             build_event(E_RING,RINGOFF);
/*22296shujin*/
             ring_was_on_before = FALSE;
     break;
   }
}

ubyte v23c_message=0;    /* MH 030797 Fix 75/1200 message in V23 */

void v34_tx_rx_message(ubyte type)

{
 ubyte *string;
   switch (type)           /* DCE Speed */
   {
     case BPS300:
    string = (ubyte*) V34_300;
    break;

     case BPS1200:
        string = (ubyte*) V34_1200;
      if (line_mode ==4)
       {    
          if (atB.group1 == 2)
          {
             if (v23c_message == 0)
              {
                 if(sr14.originate_flag)
                     string = (ubyte*) V34_75;
                else
                  string = (ubyte*) V34_1200;
                v23c_message = 1;
              }
             else
        {
           if(sr14.originate_flag)
              string = (ubyte*) V34_1200;
           else
              string = (ubyte*) V34_75;
              v23c_message = 0;
        }
    }
            if (atB.group1 == 3)
            {
                if (v23c_message == 0)
                 {
                   if(sr14.originate_flag)
                      string = (ubyte*) V34_1200;
                    else
                      string = (ubyte*) V34_75;
                      v23c_message = 1;
                }
               else
               {
                  if(sr14.originate_flag)
                     string = (ubyte*) V34_75;
                   else
                    string = (ubyte*) V34_1200;
                      v23c_message = 0;
                }
            }

        }

        break;



             case BPS2400:          string = (ubyte*) V34_2400;
                break;

             case BPS4800:  string = (ubyte*) V34_4800;
                break;

             case BPS7200:  string = (ubyte*) V34_7200;
                break;

             case BPS9600:  string = (ubyte*) V34_9600;
                break;

             case BPS12000:         string = (ubyte*) V34_12000;
                break;

             case BPS14400: string = (ubyte*) V34_14400;
                break;

             case BPS16800: string = (ubyte*) V34_16800;
                break;

             case BPS19200:         string = (ubyte*) V34_19200;
                break;

             case BPS21600:         string = (ubyte*) V34_21600;
                break;

             case BPS24000:         string = (ubyte*) V34_24000;
                break;

             case BPS26400:         string = (ubyte*) V34_26400;
                break;

             case BPS28800:         string = (ubyte*) V34_28800;
                break;

             case BPS31200:         string = (ubyte*) V34_31200;
                break;

             case BPS33600:         string = (ubyte*) V34_33600;
                break;
      
         default: type = NONE;
                break;
          }

            output_info(string,UNFORMATTED);



}

#if MODEM_X2_MODE == 1

void x2_tx_message(ubyte type)

{
        ubyte *string;


          switch (type)           /* DCE Speed */
          {


             case X2_BPS2400:          string = (ubyte*) V34_2400;
                break;

             case X2_BPS4800:          string = (ubyte*) V34_4800;
                break;

             case X2_BPS7200:          string = (ubyte*) V34_7200;
                break;

             case X2_BPS9600:          string = (ubyte*) V34_9600;
                break;

             case X2_BPS12000:         string = (ubyte*) V34_12000;
                break;

             case X2_BPS14400:         string = (ubyte*) V34_14400;
                break;

             case X2_BPS16800:         string = (ubyte*) V34_16800;
                break;

             case X2_BPS19200:         string = (ubyte*) V34_19200;
                break;

             case X2_BPS21600:         string = (ubyte*) V34_21600;
                break;

             case X2_BPS24000:         string = (ubyte*) V34_24000;
                break;

             case X2_BPS26400:         string = (ubyte*) V34_26400;
                break;

             case X2_BPS28800:         string = (ubyte*) V34_28800;
                break;

             case X2_BPS31200:         string = (ubyte*) V34_31200;
                break;

             case X2_BPS33600:         string = (ubyte*) V34_33600;
                break;




             default: type = NONE;
                break;
          }

            output_info(string,UNFORMATTED);



}

void x2_rx_message(ubyte type)

{
        ubyte *string;


          switch (type)           /* DCE Speed */
          {


          case X2_BPS33333:      string = (ubyte*) VX2_33333;

                break;
            case X2_BPS37333:      string = (ubyte*) VX2_37333;

                break;
            case X2_BPS41333:      string = (ubyte*) VX2_41333;

                break;
            case X2_BPS42666:      string = (ubyte*) VX2_42666;

                break;
            case X2_BPS44000:      string = (ubyte*) VX2_44000;

                break;
            case X2_BPS45333:      string = (ubyte*) VX2_45333;

                break;
            case X2_BPS46666:      string = (ubyte*) VX2_46666;

                break;
            case X2_BPS48000:      string = (ubyte*) VX2_48000;

                break;
            case X2_BPS49333:      string = (ubyte*) VX2_49333;

                break;
            case X2_BPS50666:      string = (ubyte*) VX2_50666;

                break;
            case X2_BPS52000:      string = (ubyte*) VX2_52000;

                break;
            case X2_BPS53333:      string = (ubyte*) VX2_53333;

                break;
            case X2_BPS54666:      string = (ubyte*) VX2_54666;

                break;
            case X2_BPS56000:      string = (ubyte*) VX2_56000;

                break;
            case X2_BPS57333:      string = (ubyte*) VX2_57333;

                break;

             default: type = NONE;
                break;
          }

            output_info(string,UNFORMATTED);



}
#endif



void rate_message(void)

{
        ubyte *string;

    
          switch (line_mode)           /* DCE Mode*/
          {
 

/*mrm31496*/

             case 0:        string = (ubyte*) BELL103_MODE;
                break;

             case 1:
                        if (atB.group1 == 1)
                            string = (ubyte*) BELL212_MODE;
                        else
                            string = (ubyte*) V22_MODE;

                break;

             case 2:        string = (ubyte*) V21_MODE;
                break;

             case 4:        string = (ubyte*) V23_MODE;
                break;

             case 6:
                        if (atB.group1 == 1)
                            string = (ubyte*) BELL212_MODE;
                        else
                            string = (ubyte*) V22_MODE;

                break;



             case 7:        string = (ubyte*) V22BIS_MODE;
                break;

             case 12:       string = (ubyte*) V32_MODE;
                break;

             case 16:       string = (ubyte*) V32BIS_MODE;
                break;

             case 17:
             case 18:       string = (ubyte*) V34_MODE;
                break;

#if MODEM_X2_MODE == 1
             case 22:       string = (ubyte*) VX2_MODE;
                break;
#endif


             default:
                break;
          }

            output_info(string,UNFORMATTED);



}
