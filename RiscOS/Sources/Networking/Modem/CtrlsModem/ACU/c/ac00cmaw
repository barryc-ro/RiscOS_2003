/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00cmaw.c
/
/	Module Version: ACU 4.02
/
/	Function:	This file contains the code to process the AT&W, &X,
/			&Y, and &Z commands.
/
/	Product:	ACU core code
/
/	History:	ac00cmaw.c v3.90
/
/		Created: 11/17/91
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date:	RSA
/		Description:
/		Reason:
/
*****************************************************************************/
#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "ee_def.h"
#include "acu_pro.h"
#include "mt_pro.h"

/* start change keh 12/94 => modify routines for new parser */
#if 0
void and_W(void );
void and_X(void );
void and_Y(void );
void and_Z(void );
#endif
void and_W(ubyte *);
void and_X(ubyte *);
void and_Y(ubyte *);
void and_Z(ubyte *);
/* end change keh 12/94 => modify routines for new parser */
ubyte valid_character(ubyte ch);


/*******************************************************************************
/
/	Routine: and_W
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will store the active profile
/	       AT&W	0 - Store profile in location 0
/			1 - Store profile in location 1
/			2 - Store profile in location 2
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_W(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*
*	if ((error_occurred == FALSE) && ((num >= 0) && (num < NUMBER_OF_PROFILES)))
*		store_profile(num);
*	else
*		error_occurred = TRUE;
*}
#else
void and_W(ubyte *param_ptr)
{
/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr < NUMBER_OF_PROFILES)) */
    if (*param_ptr < NUMBER_OF_PROFILES)
/* end change keh 8/15/95 => ubytes are never  < 0 */
        store_profile(*param_ptr);
    else
        error_occurred = TRUE;
}
#endif
/* start change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: and_X
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will select the synchronous data clock
/		      source
/	       AT&X	0 - Modem genetates the transmit clock and applies
/			    it to pin 15
/			1 - The DTE generates the clock on pin 24 and the
/			    modem applies this clock to pin 15
/			2 - The modem derives the transmit clock from the
/			    receive carrier signal and applies it to pin 15
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, sr27.clock_source
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_X(void)
*{
*	ubyte num;
*
*	num = a_to_d();
*	if (error_occurred == TRUE)
*		return;
*
*	switch (num)
*	{
*		case 0: sr27.clock_source = TO_PIN_15;
*			break;
*
*		case 1: sr27.clock_source = TO_PIN_24;
*			break;
*
*		case 2: sr27.clock_source = FROM_CD;
*			break;
*
*		default: error_occurred = TRUE;
*			 return;
*	}
*}
#endif

void and_X(ubyte *param_ptr)
{
    switch (*param_ptr)
    {
        case 0:
            sr27.clock_source = TO_PIN_15;
            break;

        case 1:
            sr27.clock_source = TO_PIN_24;
            break;

        case 2:
            sr27.clock_source = FROM_CD;
            break;

        default:
            error_occurred = TRUE;
            return;
    }
}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/	Routine: and_Y
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will select the stored profile to be used
/		      on power up.
/	       AT&Y	0 - Select stored profile 0 on power up
/			1 - Select stored profile 1 on power up
/			2 - Select stored profile 2 on power up
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_Y(void)
*{
*	ubyte num,eeprom_error;
*
*	num = a_to_d();
*
*	if ((error_occurred == FALSE) && ((num >= 0) && (num < NUMBER_OF_PROFILES)))
*	{
*		temp_array[0] = num;
*		eeprom_error = modem_write_data(POWER_UP_PROFILE,1,(ubyte *)&temp_array[0]);
*
*		if (eeprom_error == TRUE)
*			error_occurred = TRUE;
*		else
*		{
*			temp_array[0] = modem_eeprom_checksum();
*			modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,(ubyte *)&temp_array[0]);
*		}
*	}
*	else
*		error_occurred = TRUE;
*}
#endif

void and_Y(ubyte *param_ptr)
{
    ubyte eeprom_error;

/* start change keh 8/15/95 => ubytes are never  < 0 */
/*    if ((*param_ptr >= 0) && (*param_ptr < NUMBER_OF_PROFILES)) */
    if (*param_ptr < NUMBER_OF_PROFILES)
/* end change keh 8/15/95 => ubytes are never  < 0 */
    {
        temp_array[0] = *param_ptr;

        eeprom_error = modem_write_data(POWER_UP_PROFILE,1,
            (ubyte *)&temp_array[0]);
        if (eeprom_error == TRUE)
        {
			error_occurred = TRUE;
        }
        else
        {
            temp_array[0] = modem_eeprom_checksum();
            modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,
                (ubyte *)&temp_array[0]);
        }
    }
    else
        error_occurred = TRUE;
}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/	Routine: and_Z
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will store the entered telephone number
/	       AT&Z	0 - Store number in location 0
/			1 - Store number in location 1
/			2 - Store number in location 2
/			3 - Store number in location 3
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  error_occurred, cmd_ptr
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void and_Z(void)
*{
*	ubyte num;
*	ubyte ch;
*	ubyte next_ch;
*	uword num_size;
*
*	ubyte *ptr;
*	uword address;
*	ubyte eeprom_error;
*
*	ch = get_next_char();
*	if (ch == '=')
*		num = 0;
*	else
*	{
*		next_ch = get_next_char();
*		if (next_ch == '=')
*		{
*			num = ch - '0';
*			if (num > 3)
*			{
*				error_occurred = TRUE;
*				return;
*			}
*		}
*		else
*		{
*			num = 0;
*			cmd_ptr--;
*			cmd_ptr--;
*		}
*	}
*	ptr = (ubyte *)&temp_array[0];
*	while ((ch = get_next_char()) != NULL)
*	{
*		if (valid_character(ch) == TRUE)
*			*ptr++ = ch;
*	}
*	*ptr = '\0';
*	cmd_ptr--;
*
*	if ((num_size = str_len((ubyte *)&temp_array[0])) > 36)
*	{
*		error_occurred = TRUE;
*		return;
*	}
*
*	switch (num)
*	{
*		case 0: address = TELE_NUMBER_0_ADD;
*			break;
*
*		case 1: address = TELE_NUMBER_1_ADD;
*			break;
*
*		case 2: address = TELE_NUMBER_2_ADD;
*			break;
*
*		case 3: address = TELE_NUMBER_3_ADD;
*			break;
*
*		default:
*			error_occurred = TRUE;
*			return;
*	}
*	eeprom_error = modem_write_data(address,num_size+1,(ubyte *)&temp_array[0]);
*
*	if (eeprom_error == TRUE)
*		error_occurred = TRUE;
*	else
*	{
*		temp_array[0] = modem_eeprom_checksum();
*		modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,(ubyte *)&temp_array[0]);
*	}
*}
#endif

void and_Z(ubyte *param_ptr)
{
    uword num_size;
    ubyte *ptr;
    uword address;
    ubyte eeprom_error;

    switch (*param_ptr)
    {
        /* AT&Z0, AT&Z=, AT&Z, AT&Z0= all imply AT&Z0 */
        case '0':   /* AT&Z0??? */
        case '=':   /* AT&Z=??? */
            param_ptr++;

        case '\0':   /* AT&Z<CR> */
/* According to Hayes, if the delimiter '=' is not present,
   the characters following the &Z are treated as phone
   numbers for storage # zero.   Non-storable characters
   should be ignored */
 
           address = TELE_NUMBER_0_ADD;
           break;

        case '1':
            if( *(param_ptr+1) != '=')   address = TELE_NUMBER_0_ADD;
            else  {  address = TELE_NUMBER_1_ADD; param_ptr++; }

            break;

        case '2':
            if( *(param_ptr+1) != '=')   address = TELE_NUMBER_0_ADD;
            else { address = TELE_NUMBER_2_ADD; param_ptr++; }

            break;

        case '3':
            if( *(param_ptr+1) != '=')   address = TELE_NUMBER_0_ADD;
            else {  address = TELE_NUMBER_3_ADD; param_ptr++;  }

            break;

        default:    /* AT&Z??? */
            if( *(param_ptr+1) != '=')   address = TELE_NUMBER_0_ADD;
            else {  error_occurred = TRUE;   return; }

            break;
    }

    ptr = (ubyte *)&temp_array[0];
    while (*param_ptr != NULL)
    {
        if (valid_character(*param_ptr))
            *ptr++ = *param_ptr++;
        else
            param_ptr++;
    }
    *ptr = '\0';

    if ((num_size = str_len((ubyte *)&temp_array[0])) > 30 )
    {
        error_occurred = TRUE;
        return;
    }

#if0
/*testing */
    eeprom_error = modem_write_data(address,num_size,(ubyte *)&temp_array[0]);
#endif

    eeprom_error = modem_write_data(address,num_size+1,(ubyte *)&temp_array[0]);

    if (eeprom_error == TRUE)
    {
        error_occurred = TRUE;
    }    
    else
    {
        temp_array[0] = modem_eeprom_checksum();
        modem_write_data(CHECKSUM_ADDR,CHECKSUM_SIZE,(ubyte *)&temp_array[0]);
    }

}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/	Routine: valid_character
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine determines if the character in the telephone
/		      number is valid for the dial string.
/
/	Input Parameters: ubyte ch - character to be validated
/
/	Output Parameters: ubyte TRUE - if character is valid
/				 FALSE - if character is not valid
/
/	Global Variables Changed:  none
/
/	Users: at_and()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte valid_character(ubyte ch)
{
	if ((ch >= '0') && (ch <= '9'))
		return (TRUE);
	if ((ch >= 'A') && (ch <= 'D'))
		return (TRUE);
	switch (ch)
	{
		case '#':
		case '*':
		case 'T':
		case 'P':
		case 'R':
		case 'W':
		case '@':
		case ',':
		case '!':
		case ';': return (TRUE);

		default: return (FALSE);
	}
}

