/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    Cirrus Logic, Inc.
/	    3100 West Warren Avenue
/	    Fremont, CA 94538
/	    (510) 623-8300
/
/
/   This document contains material confidential to Cirrus Logic its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by Cirrus Logic.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00ptt.c
/
/	Module Version: ACU
/
/	Function:	This file contains code for international call progress tone,
/               ring detection, transmission level setting, and black list
/
/	Product:	ACU core code
/
/   History:    ac00ptt.c
/
/
/		Created: 5/2/96
/
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date:	Cirrus
/		Description:
/		Reason:
/
*****************************************************************************/
#include   <string.h>
#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "mt_pro.h"
#include "acu_pro.h"
#include "ee_def.h"
#include "ptt.h"
#include "icd_msgs.h"
#include "bldflags.h"
#include "homolig1.h"
#include "hmg_mem1.h"

extern ubyte dsp_response_data[];
extern ubyte dsp_cp_packet;
extern ubyte read_dsp_xmit_status_reg(void);
extern ubyte Read_signal_level(void);
extern ubyte voice_dist_ring_active;
extern void  send_pkt_to_dsp(void);

void BlackListInit(void);
ubyte BlackListInProgress(void);
void BlackListInsert(void);
void UpdateBlackListDelayTimer(void);
void InitiateDelayTimer(void);
void InitToneModeDetection(void);
void ast_NC(ubyte *);
void InitiateToneATaps(void);
void InitiateDTMFLevel(void);
void InitiateTransmitLevel(ubyte for_dtmf_txlevel);
void InitiateCountryDependSReg(ubyte);
void CountryDependSRegRangeCheck(ubyte);
void SetPulseRelay(uword);
void SetOnHookRelay(ubyte);
ubyte LineCurrent(void);
void SetVORelay(ubyte);
uword get_dsp_address(ubyte);

/*mrm83196*/
/*variable for redial the same number*/
ubyte match_number = 0;
uword dsp_address;

extern ubyte MinimumDelayTimer;
extern const uword PTT_DialToneTimeOut[];
extern const uword PTT_HookFlash[];
extern ubyte CountryInfo;
extern ubyte BlackNoEntry;
extern ubyte AvailableCell;
extern ubyte ToneModeSwitch;
extern ubyte ToneResult;
extern ubyte ack_or_response;
extern ubyte ToneStatus;
extern ubyte DigitCode;
extern ubyte black_size;
extern ubyte ErrorCode;
extern ubyte BlackListDialed;
extern ubyte TmpPhoneCell[30];
extern ubyte *TmpDialPtr;
extern int OnTime;
extern int OffTime;
extern BlackList BlackLst[BLACKLIST_MAX_CELL_NUM];
extern ToneModeEntry Tone[NoOfTonesPerCountry];
extern country_black_list_table PTTBlackLst[];
extern country_tone_table PTT_Tone[];
extern country_ring_table PTT_Ring[];
extern country_filter_taps PTT_Taps[];
extern country_DTMF_Level PTT_DTMF_Level[];
extern country_transmit_level PTT_TransmitLevel[];
extern country_depend_S_registers PTT_SReg[];
extern country_Nominal_RingBack_Cadence PTT_RingBack[];
extern const uword S91_PTT_TransmitLevel[18];
extern country_Make_Break_Time PTT_MakeBreak_Time[];
extern Cntry_List_Tag  cntry_list[];
extern country_dbmthr PTT_dbmthr[];
extern Country_Valid_dbmthr_Level PTT_dbmthr_Level[];
//extern uword tempp1;
extern ubyte busy_count[4];

/* MH120397 insert new function: ath1_problem ... */
#include "mt_def.h"

#if INTERNATIONAL_CODE == 1
extern ubyte ath1_timer;
extern ubyte ath1_activate ;
ubyte Tone_signal_level_lo;
extern ubyte old_st_crnt_boost1;
extern ubyte st_crnt_boost1;
uword msec2_count;
uword msec3_count;
extern struct Homg_var1_Tag homg_var1;
#endif

#define	 DBMADJUST	0          /* KJB 980818 - changed from 5 to 0 - everything was about 5dB too insensitive... */
#ifndef __riscos
#define  GPCR0          0xffc210   /* config reg, 0 input, 1 output */
#define  GPR0           0xffc204   /* if as output,value reg */
#define  HOOK_MASK		0x0080
#endif

/****************************************************************************
/
/    Routine: Black List Init
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 11/09/97
/
/    Description : This Routine is called to reset the blacklist mechanism
/
/    Users: AC00MSTR.C
/
/
****************************************************************************/
void BlackListInit(void)
{
	int	i;

	for (i = 0; i < BLACKLIST_MAX_CELL_NUM; i++) {
		BlackLst[i].status = NULL;
	}
	BlackListDialed = FALSE;
   MinimumDelayTimer = 0;
}


/****************************************************************************
/
/    Routine: Black List In Progres ?
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 11/09/97
/
/    Description : This Routine is called check if blacklist is in progress
/
/    Users: sleep.c
/
/
****************************************************************************/
ubyte BlackListInProgress(void)
{
	ubyte i, BLStatus;

	BLStatus = FALSE;
	for (i = 0; i < BLACKLIST_MAX_CELL_NUM; i++) {
#if 1
      outchar(BlackLst[i].status);
#endif
		if (BlackLst[i].status != NULL)
			BLStatus = TRUE;
	}

   if(MinimumDelayTimer)
      BLStatus = TRUE;

	return(BLStatus);
}


/****************************************************************************
/
/    Routine: Black List Insert
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description : This Routine is called when the ACU start dial a number
/
/    Users:
/
/
****************************************************************************/
void BlackListInsert(void)
{

	ubyte ix, ix1;
	TmpDialPtr = acu_dial_string_ptr;

	BlackListDialed = TRUE;
	ErrorCode = 0;
// just for Scandinavian countries.
	if((country_area_code1 == Finland_a_code1) ||
//		(country_area_code1 == Norway_a_code1) ||
		(country_area_code1 == Sweden_a_code1) ||
		(country_area_code1 == Denmark_a_code1))
	{
		return;
	}

	if (country_area_code1 == USA) {
		return;
	}

#if INTERNATIONAL_CODE == 1
	if(homg_var1.disable_blacklist > 0)
		return;
#endif

   if (MinimumDelayTimer) {
		ErrorCode = DelayedCall;
	   BlackListDialed = FALSE;
      return;
   }
	for ( ix = 0; ix < 36; ix++) {
		TmpPhoneCell[ix] = NULL;
	}

	/*Get the phone number from the command buffer*/

	DigitCode = *TmpDialPtr;
	if (DigitCode == 's' || DigitCode == 'S')
		return;  /* Get the phone number after fetched from the NVRAM */

	for (ix = 0; (DigitCode = *TmpDialPtr) != NULL; TmpDialPtr++) {
		switch (DigitCode) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			TmpPhoneCell[ix] = DigitCode;
			ix++;
			break;
		default:
			break;
		}
	}

#if INTERNATIONAL_CODE == 1
	if (country_area_code1 == German) {
		/* MH120397 reset ath1 - timer ... */
//			ath1_timer_reset();
		/* this change ath1 ... */

		AvailableCell = 0;
		if (BlackLst[AvailableCell].status != NULL) {
			ErrorCode = DelayedCall;
		}
		return;
	}
#endif


	AvailableCell = 255;    // assume all cells are taken up
	black_size = PTTBlackLst[CountryInfo].MaxPhoneCell;

	for (ix = 0; ix < black_size; ix++) {  // loop thru all cells

		if (BlackLst[ix].status != NULL) {

			/* Compare the current phone number with the number in the current cell*/
			for ( ix1 = 0; ix1 < 30; ix1++) {
				if ( TmpPhoneCell[ix1] != BlackLst[ix].PhoneCell[ix1]) {
					match_number = 0;
					break;
				}
			}

			if (ix1 == 30)
				match_number = 1;

			if (country_area_code1 == German)
				ix1 = 30;

			if (ix1 == 30) {  // check if dialed num matches one in current cell

				if ((BlackLst[ix].status == RedListNo) && (BlackLst[ix].DelayTimer == 0)) {

					BlackLst[ix].RetryTimes++;

#if 1
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(0x77);
			   outchar(BlackLst[ix].RetryTimes);
			   outchar(0x78);
#endif
 					if (BlackLst[ix].RetryTimes == PTTBlackLst[CountryInfo].MaxRetry) {
						BlackLst[ix].status = BlackListNo;
						BlackLst[ix].DelayTimer = PTTBlackLst[CountryInfo].CycleTime;
						AvailableCell = 255;
						ErrorCode = DelayedCall;
					} else					 {
						AvailableCell = ix;  /* For BlackListDelete purpose */
						BlackLst[ix].status = RedListNo;
					}
				} else				 {
					ErrorCode = DelayedCall;
				}

				break;
			}
		} else		 { /* BlackLst[ix].status == NULL */

			if (match_number == 0)
				AvailableCell = ix;

		}
	}

   // Search process complete, see if we need to store the current number

	if ( (AvailableCell != 255) && (match_number == 0) ) {
		BlackLst[AvailableCell].RetryTimes = 0;
		BlackLst[AvailableCell].status = RedListNo;
		BlackLst[AvailableCell].DelayTimer = 0;
		BlackLst[AvailableCell].RedListTimer = PTTBlackLst[CountryInfo].CycleTime;
		for ( ix = 0; ix < 30; ix++) {
			BlackLst[AvailableCell].PhoneCell[ix] = TmpPhoneCell[ix];
		}
	} else		 {
		if (AvailableCell == 255)
			ErrorCode = DelayedCall;
	}

	match_number = 0;                   // needed ???

}


/****************************************************************************
/
/    Routine: UpdateBlackListDelayTimer
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description : This Routine is called when a call has failed because of busy
/
/    Users:
/
/
****************************************************************************/
void UpdateBlackListDelayTimer(void)
{
	ubyte ix;
	if (country_area_code1 == USA)
		return;

   if (MinimumDelayTimer)
      MinimumDelayTimer--;

	black_size = PTTBlackLst[CountryInfo].MaxPhoneCell;
	for (ix = 0; ix < black_size; ix++) {

      // Update DelayTimer

		if ((BlackLst[ix].status != NULL) && (BlackLst[ix].DelayTimer != 65535)) {
			if (BlackLst[ix].DelayTimer != 0) {
				BlackLst[ix].DelayTimer--;
#if 1
			   outchar(0x88);
			   outchar(BlackLst[ix].DelayTimer);
			   outchar(0x89);
#endif
         }
		}

		if(country_area_code1 != Norway_a_code1)	 // fix #6
		{
			if ((BlackLst[ix].status == BlackListNo) && (BlackLst[ix].DelayTimer == 0)) {
				BlackLst[ix].RetryTimes = 0;
				BlackLst[ix].status = 0;
				BlackListDialed = FALSE;
			}

      // Update RedListTimer in parallel

			if ((BlackLst[ix].status == RedListNo) && (BlackLst[ix].RedListTimer != 0)
         	  && (BlackLst[ix].RedListTimer != 65535)) {
				BlackLst[ix].RedListTimer--;
				if (BlackLst[ix].RedListTimer == 0) {
					BlackLst[ix].RetryTimes = 0;
					BlackLst[ix].status = 0;
				}
			}
		} // fix #6

	}
}


/****************************************************************************
/
/    Routine: BlackListDelete
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/    Users:
/
/     Reason:
/
/
****************************************************************************/
void BlackListDelete(void)
{

	if (country_area_code1 == USA)
		return;

	BlackLst[AvailableCell].status = 0;
	BlackLst[AvailableCell].RetryTimes = 0;
	BlackListDialed = FALSE;
}



/****************************************************************************
/
/    Routine: Initiate Delay Timer
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/
/    Users:
/
/    Reason:
/
/
****************************************************************************/
void InitiateDelayTimer(void)
{
	if (country_area_code1 == USA)
		return;

	if (BlackListDialed == FALSE)
		return;

   if (MinimumDelayTimer == 0) // donot init if already running
      MinimumDelayTimer = PTTBlackLst[CountryInfo].DelayTimer[0];

	if (country_area_code1 == German) {
		AvailableCell = 0;
		if (BlackLst[AvailableCell].status == NULL) {
			BlackLst[AvailableCell].status = BlackListNo;
			BlackLst[AvailableCell].DelayTimer = PTTBlackLst[CountryInfo].CycleTime;
		}
		return;
	}

	if (country_area_code1 == UK) {
	   if (BlackLst[AvailableCell].status == RedListNo) {
		   BlackLst[AvailableCell].DelayTimer = PTTBlackLst[CountryInfo].DelayTimer[0];

			outchar(0xAA);
			outchar(BlackLst[AvailableCell].DelayTimer);
			outchar(0xAA);
 	   }
		return;
   }

	if (BlackLst[AvailableCell].status == RedListNo) {
		BlackLst[AvailableCell].DelayTimer = PTTBlackLst[CountryInfo].DelayTimer[BlackLst[AvailableCell].RetryTimes];
	}
}

/****************************************************************************
/
/    Routine: InitToneModeDetection
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 01/24/96
/
/    Description : This Routine is called when a ring Interrupt happen
/                  to sum all ring on time
/
/    Users: coming ring
/
/       Reason: Needed for the +VDR and +VDT.
/
/
****************************************************************************/

void InitToneModeDetection(void)
{
   ubyte ii;

   for(ii=0; ii < NoOfTonesPerCountry; ii++)
   {
    Tone[ii].status  = 1;                /* Look for Tone-A on condition */
    Tone[ii].tonetype= PTT_Tone[CountryInfo]._tonex[ii].tonetype;
    Tone[ii].ontime= 0;
    Tone[ii].offtime= 0;
    Tone[ii].ontimemax  = PTT_Tone[CountryInfo]._tonex[ii].ontimemax;
    Tone[ii].ontimemin  = PTT_Tone[CountryInfo]._tonex[ii].ontimemin;
    Tone[ii].offtimemax = PTT_Tone[CountryInfo]._tonex[ii].offtimemax;
    Tone[ii].offtimemin = PTT_Tone[CountryInfo]._tonex[ii].offtimemin;
    Tone[ii].tonecode = PTT_Tone[CountryInfo]._tonex[ii].tonecode;
   }

	OnTime = PTT_RingBack[CountryInfo].OnTime;
	OffTime = PTT_RingBack[CountryInfo].OffTime;
   ToneResult = 0;
	for(ii=0; ii<4; ii++)
    	busy_count[ii] = 0;
   ToneModeSwitch = 1;                 /* Start Tone Mode detection */
Tone_signal_level_lo = 0;		/* initialize level detection */
}



/****************************************************************************
/
/    Routine: ToneModeDetection
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/    Users:
/
/    Reason:
/
/
****************************************************************************/
extern  ubyte  cidbuf[128];
extern  ubyte  voice_dist_ring_time;
extern  ubyte  tembuf[4];
extern  void   output_info(ubyte *,ubyte);
void   d2_to_a2(uword val, ubyte buf[]);

void ToneModeDetection(void)
{
  ubyte Tone_Thr;
  ubyte *string;

	ubyte ix, false_cond, false_cond1;

	ToneStatus = read_dsp_xmit_status_reg();
   ToneResult = UNDETERMINED;

//          	    	string = (ubyte *)"####";
//					output_info(string,VERBOSE_FORM);  	/* before and after */
//                   string = d_to_a(ix);
//					output_info(string,ToneStatus);  	/* before and after */
   for (ix = 0; ix < NoOfTonesPerCountry; ix++)
   {
		if (Tone[ix].status == 1)
      { /* Look for tone A on */
			if (ToneStatus & 0x01)
         {

				/* Look for tone A on, and tone A IS on */

				Tone[ix].ontime++;
				if (Tone[ix].tonetype & 1) // KJB 980819 - new tonetype for Sweden
            {
						/* This is a continuous tone */
						/* Comparing the max and min of ontime */
					if (Tone[ix].ontime >= Tone[ix].ontimemin)
               {
					   if(country_area_code1 != USA)
					   {
					     Tone_signal_level_lo = Read_signal_level();
					     Tone_signal_level_lo += DBMADJUST;
					     Tone_Thr = PTT_dbmthr_Level[CountryInfo].dial_thr;
					      if(Tone_Thr >= Tone_signal_level_lo)
					      {
					        ToneResult = Tone[ix].tonecode;
					      }
					   }
					   else
					   {
					     ToneResult = Tone[ix].tonecode;
					   }

					}
				}
				else
            {
					/* Do nothing */
				}
			}
			else
         {
				/* Look for tone A on, but tone A IS off */
				Tone[ix].status = 0;  /* Change to look for tone A off*/
				Tone[ix].offtime = 1; /* Initiate tone offtime */
				/* KJB - for Sweden */
				if (Tone[ix].tonetype == 3)
				{
				    ToneResult = Tone[ix].tonecode;
				}

			}
		}
		else
      {
			/* Look for tone A off */

			if ((ToneStatus & 0x01) == 0)
         {

				/* Look for tone A off, and tone A IS off */
				Tone[ix].offtime ++;
				/* KJB 980818 - stuff for Swedish approvals */
				if (Tone[ix].tonetype == 3)
				{
				    if (Tone[ix].offtime <= Tone[ix].offtimemax)
				    {
				        ToneResult = Tone[ix].tonecode;
				    }
				}
			}
			else
         {

				/* Look for tone A off, but tone A IS on */
				false_cond =  0; /* Glitch exist within Tone A on if it is TRUE*/
				false_cond1 = 0;
//				tempp1 = 0;
				Tone[ix].status = 1;

		/* De-glitch during the Ring back period*/
//				if (ix == 2)
//            {
//					if (Tone[ix].offtime < 55 && Tone[ix].offtime > 15)
//               {/*UK ring back has 200ms off time*/
//						Tone[ix].ontime += Tone[ix].offtime;
//						Tone[ix].offtime = 0;
//						false_cond = TRUE; /* Calling Tone exist with cadence ON */
//					}
//
//					if (Tone[ix].offtime > OffTime)
//               {
//						tempp1 = Tone[ix].offtime - OffTime;
//						Tone[ix].offtime = OffTime;
//
//						if ((OnTime - Tone[ix].ontime) > 5)
//                  {
//							Tone[ix].ontime += tempp1;
//							false_cond1 = TRUE; /* add to next on time */
//						}
//					}
//				}
		/* End of ring back De-glitch function*/
				/* Reporting the Cadence for debugging purpose*/
				if ((voice_dist_ring_active == 0xC7)  && (false_cond == 0))
//				if ((voice_dist_ring_active == 0x04)  && (false_cond == 0))
            {
					if ( /*ix == 2 || ix == 1  ix == jjjj_tmp1 */ ix == 1 )
               {
              //     string = & (tembuf[0]);

          	    	string = (ubyte *)"^^^";
//                   string = d_to_a(ix);
						output_info(string,VERBOSE_FORM);  	/* before and after */
//						output_info(string,STORED_NUM);
//						output_info(string,NUMERIC_FORM);  /* CR LF after --- */

	            	d2_to_a2(Tone[ix].ontime,tembuf);
   	         	strcpy((char *)cidbuf,"CADENCE_ON=");
      	      	strcat((char *)cidbuf,(char *)tembuf);
						output_info(cidbuf,NUMERIC_FORM);

		            d2_to_a2(Tone[ix].offtime,tembuf);
   		         strcpy((char *)cidbuf,"CADENCE_OF=");
      		      strcat((char *)cidbuf,(char *)tembuf);
         	   	output_info(cidbuf,NUMERIC_FORM);  /* CR, LF after */

					}
				}

				if (Tone[ix].tonetype == 2 && false_cond == 0)
	         {	/* Two segments tone, make decision here*/
					if( (Tone[ix].ontime >= Tone[ix].ontimemin)
						 && (Tone[ix].ontime <= Tone[ix].ontimemax)
						 && (Tone[ix].offtime >= Tone[ix].offtimemin)
						 && (Tone[ix].offtime <= Tone[ix].offtimemax)
                 )
    	         {
			 			if ((ix >= 1) && (ix <= 4))
                  {
			 				if (busy_count[ix-1])
				         {
							  if(country_area_code1 != USA)
							  {
		          		     Tone_signal_level_lo = Read_signal_level();
							     Tone_signal_level_lo += DBMADJUST;


							    if(ix == 1)
							    {
								Tone_Thr = PTT_dbmthr_Level[CountryInfo].busy1_thr;
								if(Tone_Thr >= Tone_signal_level_lo)
			 					ToneResult = Tone[ix].tonecode;
							    }

							    if(ix == 2)
							    {
								Tone_Thr = PTT_dbmthr_Level[CountryInfo].busy2_thr;
								if(Tone_Thr >= Tone_signal_level_lo)
					 			ToneResult = Tone[ix].tonecode;
							    }

							    if(ix == 3)
							    {
								Tone_Thr = PTT_dbmthr_Level[CountryInfo].conj1_thr;
								if(Tone_Thr >= Tone_signal_level_lo)
					 			ToneResult = Tone[ix].tonecode;
							    }
							    if(ix == 4)
							    {
								Tone_Thr = PTT_dbmthr_Level[CountryInfo].conj2_thr;
								if(Tone_Thr >= Tone_signal_level_lo)
					 			ToneResult = Tone[ix].tonecode;
							    }

							  }
							  else
							  {
				 			    ToneResult = Tone[ix].tonecode;
							  }
//                          		string = (ubyte *)"R++";
//   					            output_info(string,STORED_NUM);  /* CR, LF before */
//                           string = d_to_a(ix);
//					            output_info(string,STORED_NUM);  /* CR, LF before */
//
//            	            d2_to_a2(Tone[ix].ontime,tembuf);
//   	                     strcpy((char *)cidbuf,"CADENCE_ON=");
//                  	      strcat((char *)cidbuf,(char *)tembuf);
//				            	output_info(cidbuf,STORED_NUM);  /* CR, LF before */
//
//            		         d2_to_a2(Tone[ix].offtime,tembuf);
//   		                  strcpy((char *)cidbuf,"CADENCE_OF=");
//                  		   strcat((char *)cidbuf,(char *)tembuf);
//                     	   output_info(cidbuf,STORED_NUM);  /* CR, LF after */
//
////                           string = d_to_a(busy_count[ix-1]);
//                           string = d_to_a(ToneResult);
//            				output_info(string,STORED_NUM);  /* CR, LF before */

                                 Tone[ix].ontime = 1;
                                 break;
										}
										else
		                                {
											busy_count[ix-1]++;
										}

                         /*  		string = (ubyte *)"R+";	 */
   					       /*     output_info(string,STORED_NUM); */ /* CR, LF before */

									}
									else
          			                {

#if 0
							  if(ix > 4)
							  {
								Tone_Thr = PTT_dbmthr_Level[CountryInfo].rinbk_thr;
								if(Tone_Thr >= Tone_signal_level_lo)
								ToneResult = Tone[ix].tonecode;
							   }
#endif
								ToneResult = Tone[ix].tonecode;
						}

					}
               else
               {
                 if ((ix >= 1) && (ix <= 4))
                    busy_count[ix-1] = 0;
               }

				}

//				if (country_area_code1 == Italy)
//	            {
//					if (ToneResult == 1)
//    	           {
//						ToneModeSwitch = ToneModeIdle;
//						break;
//					}
//				}

//				if (false_cond == 0)
//            {
//					if (false_cond1 == TRUE)
//               {
//						Tone[ix].ontime = 0;
//					}
//					else
//               {
//						Tone[ix].ontime = tempp1; /* New on time*/
//					}
//				}
               // More Swedish faff - KJB 980914
               if (Tone[ix].tonetype == 3 && Tone[ix].offtime <= Tone[ix].offtimemax)
               {
                   /* Tone just came on after short pause */
                       ToneResult = Tone[ix].tonecode;
               }
               else
            Tone[ix].ontime = 1;

			}
		}
	}
}



/****************************************************************************
/
/    Routine: ToneModeStateSwitch
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/
/    Users:
/
/    Reason: Needed for the +VDR and +VDT.
/
/
****************************************************************************/


void ToneModeStateSwitch(void) {

	switch (ToneModeSwitch){
		case ToneModeIdle:
			break;
		case ToneModeStart:
			ToneModeDetection();
			break;
		default:
			break;
		}
	}


/*******************************************************************************
/
/	Routine: ast_NC
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine change the country code
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users: at_ast()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void ast_NC(ubyte *param_ptr)
{
#ifndef __riscos
	if (Default_Country == 0xFF)
	{	/* Only when Default_Country == 0xFF*/
#endif
		if (*param_ptr > MAX_COUNTRY_CODE)
		{
   	   error_occurred = TRUE;
		}
		else
		{
			CountryInfo = *param_ptr;
			country_area_code1 = cntry_list[CountryInfo].cntry_areacode2;
			InitiateCountryDependSReg(0);
			length_of_dialtone = 100;       /* Length of dialtone needed to be detected */
/*			acu_load_defaults(AT_Z_COMMAND);*/
			}
		}
#ifndef __riscos
	else
	{
   	   error_occurred = TRUE;
		}
	}
#endif


/*******************************************************************************
/
/	Routine: d2_to_a2
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void d2_to_a2(uword val, ubyte buf[])
{
  ubyte temp3, temp2, temp1;
  int www;

  temp3 = val / 100;
  www = val % 100;

  temp2 = www / 10;
  temp1 = www % 10;

  buf[0] = temp3 + '0';
  buf[1] = temp2 + '0';
  buf[2] = temp1 + '0';
  buf[3] = 0;

}


/*******************************************************************************
/
/	Routine: InitiateToneATaps
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateToneATaps(void) {
	ubyte *temp;
	ONE_WORD ab[7];
/*    uword dsp_address; */

#ifdef DEBUG_PORT
   	PrintMsg( "InitiateToneATaps");
#endif

#if (DSP_SERIES == 700)
   /*  programming taps not working yet */
   return;
#endif

//	if (country_area_code1 == USA)
//		return;


   current_command [0] = 0x0d;
  	current_command [1] = 0x00;
  	current_command [2] = 0x04;
   current_command [3] = 0x00;

   dsp_address = get_dsp_address(24);
   current_command [4] = (ubyte)(dsp_address & 0x00FF);
   current_command [5] = (dsp_address >> 8);

   current_command [6]  = 0xdf;
   current_command [7]  = 0xdf;
	temp = (ubyte *)(COM_RAM);
	*temp = 0x0c0;
  	ack_or_response = 0;
   send_pkt_to_dsp();


		ab[0].w = PTT_Taps[CountryInfo].b12;
		ab[1].w = PTT_Taps[CountryInfo].b11;
		ab[2].w = PTT_Taps[CountryInfo].b10;
		ab[3].w = PTT_Taps[CountryInfo].a12;
		ab[4].w = PTT_Taps[CountryInfo].a11;
		ab[5].w = PTT_Taps[CountryInfo].b22;
		ab[6].w = PTT_Taps[CountryInfo].b21;
		current_command [0] = 0x0e;
   	current_command [1] = 0x00;
	  	current_command [2] = 0x10;
	   current_command [3] = 0x00;
/* Tone A Taps CommRAM location*/

   dsp_address = get_dsp_address(48);
   current_command [4] = (ubyte)(dsp_address & 0x00FF);
   current_command [5] = (dsp_address >> 8);

	   current_command [6]  = ab[0].b.b0; /* b12 */
	   current_command [7]  = ab[0].b.b1;
		current_command [8]  = ab[1].b.b0; /* b11 */
		current_command [9]  = ab[1].b.b1;
	   current_command [10] = ab[2].b.b0; /* b10 */
   	current_command [11] = ab[2].b.b1;
		current_command [12] = ab[3].b.b0; /* a12 */
		current_command [13] = ab[3].b.b1;
		current_command [14] = ab[4].b.b0; /* a11 */
	   current_command [15] = ab[4].b.b1;
		current_command [16] = ab[5].b.b0; /* b22 */
		current_command [17] = ab[5].b.b1;
   	current_command [18] = ab[6].b.b0; /* b21 */
	   current_command [19] = ab[6].b.b1;
		temp = (ubyte *)(COM_RAM);
		*temp = 0x0c0;
   	ack_or_response = 0;
	   send_pkt_to_dsp();

		ab[0].w = PTT_Taps[CountryInfo].b20;
		ab[1].w = PTT_Taps[CountryInfo].a22;
		ab[2].w = PTT_Taps[CountryInfo].a21;
	   current_command [0] = 0x0e;
	   current_command [1] = 0x00;
	  	current_command [2] = 0x08;
	   current_command [3] = 0x00;

       /* Tone A Taps CommRAM location*/
       dsp_address += 7;
       current_command [4] = (ubyte)(dsp_address & 0x00FF);
       current_command [5] = (dsp_address >> 8);

	   current_command [6]  =ab[0].b.b0; /* b20 */
	   current_command [7]  =ab[0].b.b1;
	   current_command [8]  =ab[1].b.b0;	/* a22 */
	   current_command [9]  =ab[1].b.b1;
	   current_command [10] =ab[2].b.b0;	/* a21 */
	   current_command [11] =ab[2].b.b1;
		temp = (ubyte *)(COM_RAM);
		*temp = 0x0c0;
		ack_or_response = 0;
	   send_pkt_to_dsp();
	}

/***********************************************************/
/* In file ac00ptt.c Initialize Filter threshold			  */
/***********************************************************/
void InitiateThresoldLevel(void)
{
   ubyte     *temp;
   ONE_WORD  ThrsoldLvl[2];

#ifdef DEBUG_PORT
   	PrintMsg( "InitiateThresoldLevel");
#endif

/* MH021098 Put the correct value in the Threshold varriables */
	ThrsoldLvl[0].w = PTT_dbmthr[CountryInfo].dbmonthr;
	ThrsoldLvl[1].w = PTT_dbmthr[CountryInfo].dbmoffthr;

		current_command [0] = 0x0d;
	  	current_command [1] = 0x00;
	  	current_command [2] = 0x06;
		current_command [3] = 0x00;
	   	dsp_address = get_dsp_address(25);
	   	current_command [4] = (ubyte)(dsp_address & 0x00FF);
   		current_command [5] = (dsp_address >> 8);
/*		current_command [4] = 0x92;
		current_command [5] = 0x00; */
		current_command [6] = ThrsoldLvl[0].b.b0;
		current_command [7] = ThrsoldLvl[0].b.b1;
		current_command [8] = ThrsoldLvl[1].b.b0;
		current_command [9] = ThrsoldLvl[1].b.b1;

		temp = (ubyte *)(COM_RAM);
		*temp = 0x0c0;
		ack_or_response = 0;
		send_pkt_to_dsp();
}

/*******************************************************************************
/
/	Routine: InitiateDTMFLevel
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateDTMFLevel(void)
{
   ubyte *temp;

#ifdef DEBUG_PORT
   	PrintMsg( "InitiateDTMFLevel");
#endif

   current_command [0] = 0x88;
   current_command [1] = 0x00;
   current_command [2] = 0x02;
   current_command [3] = 0x00;
   current_command [4] = PTT_DTMF_Level[CountryInfo].DTMF_Level.level1;
   current_command [5] = PTT_DTMF_Level[CountryInfo].DTMF_Level.level2;
   temp = (ubyte *)(COM_RAM);

   ack_or_response = 0;
   send_pkt_to_dsp();
}

/*******************************************************************************
/
/	Routine: InitiateTransmitLevel
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateTransmitLevel(ubyte for_dtmf_txlevel)
{
   ONE_WORD  TxLvl;

   /*  use the same S91_PTT_TransmitLevel table for
       data and fax, but index s91 for data and s92 for fax */
   current_command[0] = PACKET_MODEM_SET_TX_LEVEL;
   current_command[1] = 0;
   current_command[2] = 4;
   current_command[3] = 0;

   if (fax_class == 1)
   {
      TxLvl.w = S91_PTT_TransmitLevel[s[92]];
   	  current_command[4] = TxLvl.b.b0;
	  current_command[5] = TxLvl.b.b1;
      #ifdef DEBUG_PORT
      PrintOutChars("InitiateTransmitLevel for fax: ");
      outhex(TxLvl.b.b0);
	  outchar(' ');
      outhex(TxLvl.b.b1);
      outchar(0x0D);
      outchar(0x0A);
      #endif
   }
   else if (fax_class == 0)
   {
      if((for_dtmf_txlevel == 1) /* && (CUSTOMER35 == TRUE) */)
     	 TxLvl.w = S91_PTT_TransmitLevel[(PTT_SReg[CountryInfo].S91.DefaultValue)];  // value to be fine tuned. Goaded by AIWA.
	  else
     	 TxLvl.w = S91_PTT_TransmitLevel[s[91]];

      current_command[4] = TxLvl.b.b0;
      current_command[5] = TxLvl.b.b1;

      #ifdef DEBUG_PORT
      PrintOutChars( "InitiateTransmitLevel for data: ");
      outhex(TxLvl.b.b0);
	  outchar(' ');
      outhex(TxLvl.b.b1);
      outchar(0x0D);
      outchar(0x0A);
      #endif
  }
   else
      return;

   ack_or_response = 0;
   send_pkt_to_dsp();
}

/*******************************************************************************
/
/	Routine: InitiateCountryDependSReg
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateCountryDependSReg(ubyte type) {
	ubyte dummy;
	dummy=0;

	(PTT_SReg[CountryInfo].S0.DefaultValue!=0)?s[0]=PTT_SReg[CountryInfo].S0.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S6.DefaultValue!=0)?s[6]=PTT_SReg[CountryInfo].S6.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S7.DefaultValue!=0)?s[7]=PTT_SReg[CountryInfo].S7.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S8.DefaultValue!=0)?s[8]=PTT_SReg[CountryInfo].S8.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S10.DefaultValue!=0)?s[10]=PTT_SReg[CountryInfo].S10.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S11.DefaultValue!=0)?s[11]=PTT_SReg[CountryInfo].S11.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S22.DefaultValue!=0)?s[22]=PTT_SReg[CountryInfo].S22.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S23.DefaultValue!=0)?s[23]=PTT_SReg[CountryInfo].S23.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S27.DefaultValue!=0)?s[27]=PTT_SReg[CountryInfo].S27.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S30.DefaultValue!=0)?s[30]=PTT_SReg[CountryInfo].S30.DefaultValue:dummy++;

    if (type == 0)
	{
	   (PTT_SReg[CountryInfo].S91.DefaultValue!=0)?s[91]=PTT_SReg[CountryInfo].S91.DefaultValue:dummy++;
	   (PTT_SReg[CountryInfo].S91.DefaultValue!=0)?s[92]=PTT_SReg[CountryInfo].S91.DefaultValue:dummy++;
	}

   switch (sr22.uk_hook) {
     	case 0:
	       make_time  = PTT_MakeBreak_Time[CountryInfo].P0_make_time;
   	    break_time = PTT_MakeBreak_Time[CountryInfo].P0_break_time;
			 break;
	  	case 1:
	       make_time  = PTT_MakeBreak_Time[CountryInfo].P1_make_time;
   	    break_time = PTT_MakeBreak_Time[CountryInfo].P1_break_time;
			 break;
	  	case 2:
	       make_time  = (PTT_MakeBreak_Time[CountryInfo].P0_make_time+1)/2;
	       break_time = (PTT_MakeBreak_Time[CountryInfo].P0_break_time+1)/2;
    		 break;
	  	case 3:
		    make_time  = (PTT_MakeBreak_Time[CountryInfo].P1_make_time+1)/2;
   		 break_time = (PTT_MakeBreak_Time[CountryInfo].P1_break_time+1)/2;
			 break;
	   }
	   dialtone_wait_limit = PTT_DialToneTimeOut[CountryInfo];
	   flash_time = PTT_HookFlash[CountryInfo];
	}

/*******************************************************************************
/
/	Routine: CountryDependSRegRangeCheck
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void CountryDependSRegRangeCheck(ubyte number)
{
	ubyte max, min;

	switch (current_register)
	{
		case 0:
			max = PTT_SReg[CountryInfo].S0.max;
			min = PTT_SReg[CountryInfo].S0.min;
			break;
		case 6:
			max = PTT_SReg[CountryInfo].S6.max;
			min = PTT_SReg[CountryInfo].S6.min;
			break;
		case 7:
			max = PTT_SReg[CountryInfo].S7.max;
			min = PTT_SReg[CountryInfo].S7.min;
			break;
		case 8:
			max = PTT_SReg[CountryInfo].S8.max;
			min = PTT_SReg[CountryInfo].S8.min;
			break;
		case 10:
			max = PTT_SReg[CountryInfo].S10.max;
			min = PTT_SReg[CountryInfo].S10.min;
			break;
		case 11:
			max = PTT_SReg[CountryInfo].S11.max;
			min = PTT_SReg[CountryInfo].S11.min;
			break;
		case 91:
			max = PTT_SReg[CountryInfo].S91.max;
			min = PTT_SReg[CountryInfo].S91.min;
			break;
		case 92:  /* Use 91 table */
			max = PTT_SReg[CountryInfo].S91.max;
			min = PTT_SReg[CountryInfo].S91.min;
			break;

		}
	if (number >= min && number <= max)
	{
		s[current_register] = number;
		}
	else
	{
		if (number < min)
		{
			s[current_register] = min;
			}
		else
		{
			s[current_register] = max;
			}
		}

	if((country_area_code1 == Denmark_a_code1) ||
		(country_area_code1 == Finland_a_code1))
	{
		if((current_register == 0) && (number == 1))
			s[current_register] = 0;
	}


// block out values in the range for sreg0
	if((homg_var1.Forced_sreg0_max1 > 0) && (current_register == 0))
	{
		if((number >= homg_var1.Forced_sreg0_min1) &&
			(number <= homg_var1.Forced_sreg0_max1))
		{
         error_occurred = TRUE;
			s[current_register] = 0;
		}
	}
}

/*******************************************************************************
/
/	Routine: SetPulseRelay
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void SetPulseRelay(uword status) {
	uword *gpio;

#if INTERNATIONAL_CODE == 1
/*	if (country_area_code1 != USA) */
	return;	/* MH092397 */
#endif
#ifndef __riscos
	gpio = (uword *) GPCR1 ;
	*gpio = PULSE_DIAL_MASK | 0x0002 ; /* config Pulse dial bit as output */

	gpio = (uword *) GPR1 ;
	*gpio = PULSE_DIAL_MASK | status;
/* if status =0000, output a 0, relay on -- make time */
/* if status =0002, output a 1, relay off-- break time */

	if(status == 0x0002){
		gpio = (uword *) GPCR1 ;
		*gpio = PULSE_DIAL_MASK | 0 ;       /* config as input */
	}
/* config CID bit as input for prevent misoperation from other codes*/
#endif

	}

/*******************************************************************************
/
/	Routine: SetOnHookRelay
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/
void SetOnHookRelay(ubyte status)
{
#ifdef __riscos
        set_hook_relay(status);
#else
	uword *gpio;

	gpio = (uword *)GPCR0 ;
	*gpio = HOOK_MASK | 0x0008 ; /* config Pulse dial bit as output */

	gpio = (uword *) GPR0 ;
	if (status == 0){
		*gpio = HOOK_MASK | 0x0000;
		}
	else {
		*gpio = HOOK_MASK | 0x0008;
		}
#endif
}

/*******************************************************************************
/
/	Routine: LineCurrent
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/
#define  LPOHD_MASK				0x0000
#define  LPOHD_RELAY_MASK		0x8000

ubyte LineCurrent(void){
#ifdef __riscos
        return 1;
#else
	uword *gpio;

	gpio = (uword *)GPCR0 ;
	*gpio = LPOHD_MASK | 0x0800 ; /* config LPOHD bit as input */

	gpio = (uword *)GPR0;

	if (*gpio & 0x0800){
		return 0;
		}
	else {
		return 1;
		}
#endif
	}

#define VORELAY_MASK 	0x1000

void SetVORelay(ubyte status) {
#ifndef __riscos
	uword *gpio;

	gpio = (uword *)GPCR0 ;
	*gpio = VORELAY_MASK | 0x0100 ; /* config Pulse dial bit as output */

	gpio = (uword *) GPR0 ;
	if (status == 0){
		*gpio = VORELAY_MASK | 0x0000;
		}
	else {
		*gpio = VORELAY_MASK | 0x0100;
		}
#endif
	}

uword get_dsp_address(ubyte lower_var_offset)
{
/*   uword dsp_address; */

#if (DSP_SERIES == 700)
   current_command[0] = PACKET_MODEM_GET_ADDRESS;
   current_command[1] = 0;
   current_command[2] = 3;
   current_command[3] = 0;
   current_command[4] = lower_var_offset;
   current_command[5] = 0;
   current_command[6] = 0;  /* P1 sublink */
   current_command[7] = 0;

   dsp_cp_packet = PACKET_DP_ADDRESS_LOC;
   ack_or_response = 1;   /* RESPONSE */
   send_pkt_to_dsp ();

   dsp_address  = ((uword)dsp_response_data[1] << 8);
   dsp_address |= dsp_response_data[0];

#else
   switch (lower_var_offset)
   {
      case (48):
         dsp_address = 0x01D8;
         break;

      case (24):
         dsp_address = 0x004D;
         break;

      case (25):
         dsp_address = 0x0092;
         break;

      default:
         #ifdef DEBUG_PORT
         PrintMsg("FATAL - invalid variable offset selected");
         #endif
         break;
   }
#endif
   return (dsp_address);
}
#include "ac00intl.h"
#include "ac00intl.c"



/*******************************************************************************
/
/	Routine: shunt_ath1_task()
/
/	Author : Cirrus Logic
/
/	Creation Date: 02/18/98
/
/	Description: This routine handles shunt relay and ath1 hangup
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  st_crnt_boost1
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/
#if INTERNATIONAL_CODE == 1
void shunt_ath1_task()
{
	ubyte *string;  //debug2
	if(hook == FALSE)
	{
     	if((st_crnt_boost1 != 0) && (msec2_count == 0))
      {
	      switch (st_crnt_boost1)
    	   {
			   case SHUNT_AT_D_T:
           	case SHUNT_AT_D_ONLY:
				case SHUNT_ATH1_START:
//				case SHUNT_NORWAY_DIAL_TONE_FOUND1:
				case SHUNT_AFTER_FLASH_BEGINS:
				  	if(st_crnt_boost1 == SHUNT_AT_D_T)
				  	{
				  		st_crnt_boost1 = SHUNT_ATDT_DELAY1_DONE;  ///
				  	}
				  	else if (st_crnt_boost1 == SHUNT_ATH1_START)
				  	{
				  		st_crnt_boost1 = SHUNT_ATH1_DONE;		  ///
				  	}
				  	else if(st_crnt_boost1 == SHUNT_AT_D_ONLY)
				  	{
				  		st_crnt_boost1 = SHUNT_DELAY1_DONE;
				  	}
//				  	else if(st_crnt_boost1 == SHUNT_AT_D_ONLY)
//				  	{
//				  		st_crnt_boost1 = SHUNT_NORWAY_DIAL_TONE_FOUND2;
//				  	}
				  	else // SHUNT_AFTER_FLASH_BEGINS
				  	{
				  		if(sr14.pulse == 1)
				  		{
				  		// restore st_crnt_boost1 and continue pulse dialing.
	     		  		 	st_crnt_boost1 = old_st_crnt_boost1;
				  		}
				  		else
				  		{
				  			st_crnt_boost1 = SHUNT_AFTER_FLASH_ENDS;
				  		}
				  	}

//				  	string = (ubyte *)"B1";	  // debug1
//				    output_info(string,(ubyte)sr14.verbose_form); // debug1
					break;

				case SHUNT_WAIT_DELAY2:
						st_crnt_boost1 = SHUNT_DELAY2_DONE;
//						string = (ubyte *)"B2";	  // debug1
//				    	output_info(string,(ubyte)sr14.verbose_form); // debug1
					break;

				case SHUNT_END_OF_STRING:
						st_crnt_boost1 = SHUNT_DELAY3_DONE;
//						string = (ubyte *)"B3";	  // debug1
//			    		output_info(string,(ubyte)sr14.verbose_form); // debug1
					break;

				default:
					break;
			} //end of switch
		}// if((st_crnt_boost1 != 0) && (msec2_count == 0))


/* check if need to toggle relay or hangup */
		if(st_crnt_boost1 == SHUNT_DELAY1_DONE)
	  	{
			set_shunt_relay(ACTIVATE);
			st_crnt_boost1 = SHUNT_WAIT_FOR_DIGIT;
//			string = (ubyte *)"C1";	  // debug1
//		    output_info(string,(ubyte)sr14.verbose_form); // debug1
	  	}
		else if((st_crnt_boost1 == SHUNT_DELAY3_DONE)    ||
			  (st_crnt_boost1 == SHUNT_ATDT_DELAY1_DONE) ||
			  (st_crnt_boost1 == SHUNT_ATH1_DONE)        ||
//			  (st_crnt_boost1 == SHUNT_NORWAY_DIAL_TONE_FOUND2)   ||
			  (st_crnt_boost1 == SHUNT_AFTER_FLASH_ENDS))
	  	{
			set_shunt_relay(ACTIVATE);
		 	st_crnt_boost1 = 0;
//			string = (ubyte *)"C2";	  // debug1
//			output_info(string,(ubyte)sr14.verbose_form); // debug1
	    }


		if((ath1_activate == TRUE) && (ath1_timer == 0))
		{
			ath1_activate = FALSE;
		    set_loc_line_relay(OFF);
    	    set_safe1_en_relay(ACTIVATE);
		    build_event(E_HANGUP,NONE);
		}
	}
}
#endif




#if INTERNATIONAL_CODE == 1
ubyte CheckStoredNumZ0123(ubyte Znum)
{
	ubyte eeprom_error1;
	ubyte *string;
	uword address;
	ubyte tmpf_z0123;
	ubyte i;


   if (Znum >= 4)
	{
      error_occurred = TRUE;
		return(0xf0);
	}
   tmpf_z0123 = 0;
	i = Znum;


      address = TELE_NUMBER_0_ADD + (TELE_NUMBER_SIZE * i);

      /* Use the temp array for storeage */
      string = (ubyte *)&temp_array[0];

      /* Get stored number from the eeprom */
      eeprom_error1 = modem_read_data(address,TELE_NUMBER_SIZE,string);

      /* If no EEPROM read error, continue */
      if (!eeprom_error1)
      {
         /* Force EndOfString char */
         temp_array[TELE_NUMBER_SIZE] = '\0';

         /* Echo the number to the Terminal */
//         output_info(string,STORED_NUM); //

			if(str_len((ubyte *)&temp_array[0]) > 0)
				tmpf_z0123 |= (1 << i);
		}
		else
	      error_occurred = TRUE;

	return(tmpf_z0123);
}
#endif

