/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    Cirrus Logic, Inc.
/	    3100 West Warren Avenue
/	    Fremont, CA 94538
/	    (510) 623-8300
/
/
/   This document contains material confidential to Cirrus Logic its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by Cirrus Logic.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00ptt.c
/
/	Module Version: ACU
/
/	Function:	This file contains code for international call progress tone,
/               ring detection, transmission level setting, and black list
/
/	Product:	ACU core code
/
/   History:    ac00ptt.c
/
/
/		Created: 5/2/96
/
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date:	Cirrus
/		Description:
/		Reason:
/
*****************************************************************************/
#include   <string.h>
#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "mt_pro.h"
#include "acu_pro.h"
#include "ee_def.h"
#include "ptt.h"
extern ubyte read_dsp_xmit_status_reg(void);
extern ubyte voice_dist_ring_active;
extern void  send_pkt_to_dsp(void);

void BlackListInsert(void);
void UpdateBlackListDelayTimer(void);
void InitiateDelayTimer(void);
void InitToneModeDetection(void);
void ast_NC(ubyte *);
void InitiateToneATaps(void);
void InitiateDTMFLevel(void);
void InitiateTransmitLevel(void);
void InitiateCountryDependSReg(void);
void CountryDependSRegRangeCheck(ubyte);
void SetPulseRelay(uword);
void SetOnHookRelay(ubyte);
ubyte LineCurrent(void);
void SetVORelay(ubyte);
/*mrm83196*/
/*variable for redial the same number*/
ubyte match_number = 0;

extern ubyte CountryInfo;
extern ubyte BlackNoEntry;
extern ubyte AvailableCell;
extern ubyte ToneModeSwitch;
extern ubyte ToneResult;
extern ubyte ack_or_response;
extern ubyte ToneStatus;
extern ubyte DigitCode;
extern ubyte black_size;
extern ubyte ErrorCode;
extern ubyte TmpPhoneCell[30];
extern ubyte *TmpDialPtr;
extern int OnTime;
extern int OffTime;
extern BlackList BlackLst[12];
extern ToneModeEntry Tone[3];
extern country_black_list_table PTTBlackLst[7];
extern country_tone_table PTT_Tone[7];
extern country_ring_table PTT_Ring[7];
extern country_filter_taps PTT_Taps[7];
extern country_DTMF_Level PTT_DTMF_Level[7];
extern country_transmit_level PTT_TransmitLevel[7];
extern country_depend_S_registers PTT_SReg[7];
extern country_Nominal_RingBack_Cadence PTT_RingBack[7];
extern const uword S91_PTT_TransmitLevel[18];
extern country_Make_Break_Time PTT_MakeBreak_Time[7];

extern uword tempp1;
extern ubyte busy_count;
/****************************************************************************
/
/    Routine: Black List Insert
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description : This Routine is called when the ACU start dial a number
/
/    Users:
/
/
****************************************************************************/
void BlackListInsert(void){

   ubyte ix, ix1;
   TmpDialPtr = acu_dial_string_ptr;

/*Clear TmpPhoneCell to stroed the current call number*/
	ErrorCode = 0;
	if (CountryInfo == USA){
		return;
		}

   for ( ix = 0; ix < 36; ix++) {
      TmpPhoneCell[ix] = NULL;
	   }

/*Get the phone number from the command buffer*/

   DigitCode = *TmpDialPtr;
   if (DigitCode == 's' || DigitCode == 'S')
		return;  /* Get the phone number after fetched from the NVRAM */

   for (ix = 0;(DigitCode = *TmpDialPtr) != NULL; TmpDialPtr++) {
		switch (DigitCode) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
				TmpPhoneCell[ix] = DigitCode;
            ix++;
            break;
         default:
            break;
   	   }
		}

/* Check if the number already in the Black_List*/
/* black_size: black list size defined in the ac00mem.h -- temporarily*/
/*             This constant eventually will go to international PTT definition*/

/* AvailableCell equals to 255 after comparison means all the phone cell has been occupied*/

	AvailableCell = 255;

   black_size = PTTBlackLst[CountryInfo].MaxPhoneCell;  /* Maximum phone number can be in the black list */

	for (ix = 0; ix < black_size; ix++) {

      if (BlackLst[ix].status != NULL) {

			/* Compare the current phone number with the number in the current cell*/
			for ( ix1 = 0; ix1 < 30; ix1++) {
				if ( TmpPhoneCell[ix1] != BlackLst[ix].PhoneCell[ix1]) {
					match_number = 0;
					break;
					}
				}


/*mrm83196*/
/*variable for redial the same number*/

			if (ix1 == 30)
			  	match_number = 1;

			if (CountryInfo == German)
				ix1 = 30;

			/* If ix1 equals to 30 that means the two number are the same */

			if (ix1 == 30)
			{

				if (BlackLst[ix].DelayTimer == 0)
				{
					BlackLst[ix].RetryTimes++;

               if (BlackLst[ix].RetryTimes == PTTBlackLst[CountryInfo].MaxRetry)
					{
            		BlackLst[ix].status = BlackListNo;
                  BlackLst[ix].DelayTimer = PTTBlackLst[CountryInfo].CycleTime;
						AvailableCell = 255;
						ErrorCode = DelayedCall;
					}
					else
					{
						AvailableCell = ix;  /* For BlackListDelete purpose */
            		BlackLst[ix].status = RedListNo;
					}
				}
				else
				{
					ErrorCode = DelayedCall;
				}

          	break;
        	}
      }
      else
		{ /* BlackLst[ix].status == NULL */

			if(match_number == 0)
					AvailableCell = ix;

			/* No Phone number in this cell or being deleted by BlackListDelete*/
			/* This entry available for storing the new telephone number */
      }

    }



/*mrm83196*/
/*did not store the next new number in the proper array*/

/* ix equates to black_size means this is a new phone number*/

 /*  if ( ix == black_size) */

		if ( (AvailableCell != 255) && (match_number == 0) )
		{
	      BlackLst[AvailableCell].RetryTimes = 0;
   	   BlackLst[AvailableCell].status = RedListNo;
	      BlackLst[AvailableCell].DelayTimer = 0;
	      for ( ix = 0; ix < 30; ix++)
			{
   	     BlackLst[AvailableCell].PhoneCell[ix] = TmpPhoneCell[ix];
			}
		}
		else
		{
			if(AvailableCell == 255)
				ErrorCode = DelayedCall;
		}

/*mrm83196*/
/*variable for redial the same number*/

		match_number = 0;

}


/****************************************************************************
/
/    Routine: UpdateBlackListDelayTimer
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description : This Routine is called when a call has failed because of busy
/
/    Users:
/
/
****************************************************************************/
void UpdateBlackListDelayTimer(void)
{
   ubyte ix;
	if (CountryInfo == USA)return;
   black_size = PTTBlackLst[CountryInfo].MaxPhoneCell;
	for (ix = 0; ix < black_size; ix++)
	{
		if (BlackLst[ix].status != 0)
		{
			if (BlackLst[ix].DelayTimer != 0 && BlackLst[ix].DelayTimer != 65535)
			{
				BlackLst[ix].DelayTimer--;
			}

		}
/*mrm83196*/
/*clear the status if timeout*/

		if ((BlackLst[ix].status == 2) && (BlackLst[ix].DelayTimer == 0))
		{
	      BlackLst[ix].RetryTimes = 0;
			BlackLst[ix].status = 0;
		}

	}
}

/****************************************************************************
/
/    Routine: BlackListDelete
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/    Users:
/
/     Reason:
/
/
****************************************************************************/
void BlackListDelete(void) {

	 if (CountryInfo == USA)
		return;

    BlackLst[AvailableCell].status = 0;
	}



/****************************************************************************
/
/    Routine: Initiate Delay Timer
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/
/    Users:
/
/    Reason:
/
/
****************************************************************************/
void InitiateDelayTimer(void) {
	if (CountryInfo == 0)return;
	if (BlackLst[AvailableCell].status == RedListNo) {
        BlackLst[AvailableCell].DelayTimer = PTTBlackLst[CountryInfo].DelayTimer[BlackLst[AvailableCell].RetryTimes];
		}
	}


/****************************************************************************
/
/    Routine: InitToneModeDetection
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 01/24/96
/
/    Description : This Routine is called when a ring Interrupt happen
/                  to sum all ring on time
/
/    Users: coming ring
/
/       Reason: Needed for the +VDR and +VDT.
/
/
****************************************************************************/

void InitToneModeDetection(void) {
   Tone[0].status  = 1;                /* Look for Tone-A on condition */
   Tone[0].tonetype= PTT_Tone[CountryInfo].dial.tonetype;
	Tone[0].ontime= 0;
	Tone[0].offtime= 0;
   Tone[0].ontimemax  = PTT_Tone[CountryInfo].dial.ontimemax;
   Tone[0].ontimemin  = PTT_Tone[CountryInfo].dial.ontimemin;
   Tone[0].offtimemax = PTT_Tone[CountryInfo].dial.offtimemax;
   Tone[0].offtimemin = PTT_Tone[CountryInfo].dial.offtimemin;
   Tone[0].tonecode = PTT_Tone[CountryInfo].dial.tonecode;

	Tone[1].status  = 1;
   Tone[1].tonetype= PTT_Tone[CountryInfo].busy.tonetype;
	Tone[1].ontime= 0;
	Tone[1].offtime= 0;
   Tone[1].ontimemax  = PTT_Tone[CountryInfo].busy.ontimemax;
   Tone[1].ontimemin  = PTT_Tone[CountryInfo].busy.ontimemin;
   Tone[1].offtimemax = PTT_Tone[CountryInfo].busy.offtimemax;
   Tone[1].offtimemin = PTT_Tone[CountryInfo].busy.offtimemin;
   Tone[1].tonecode = PTT_Tone[CountryInfo].busy.tonecode;

	Tone[2].status  = 1;
   Tone[2].tonetype= PTT_Tone[CountryInfo].ringback.tonetype;
	Tone[2].ontime= 0;
	Tone[2].offtime= 0;
   Tone[2].ontimemax  = PTT_Tone[CountryInfo].ringback.ontimemax;
   Tone[2].ontimemin  = PTT_Tone[CountryInfo].ringback.ontimemin;
   Tone[2].offtimemax = PTT_Tone[CountryInfo].ringback.offtimemax;
   Tone[2].offtimemin = PTT_Tone[CountryInfo].ringback.offtimemin;
   Tone[2].tonecode = PTT_Tone[CountryInfo].ringback.tonecode;
	OnTime = PTT_RingBack[CountryInfo].OnTime;
	OffTime = PTT_RingBack[CountryInfo].OffTime;
   ToneResult = 0;
	busy_count = 0;
   ToneModeSwitch = 1;                 /* Start Tone Mode detection */
	}



/****************************************************************************
/
/    Routine: ToneModeDetection
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/    Users:
/
/    Reason:
/
/
****************************************************************************/
extern  ubyte  cidbuf[128];
extern  ubyte  voice_dist_ring_time;
extern  ubyte  tembuf[4];
extern  void   output_info(ubyte *,ubyte);
void   d2_to_a2(uword val, ubyte buf[]);

void ToneModeDetection(void) {

	ubyte ix, false_cond, false_cond1;

	ToneStatus = read_dsp_xmit_status_reg();

	for (ix = 0; ix < 3; ix++)	{
		if (Tone[ix].status == 1) { /* Look for tone A on */
			if (ToneStatus & 0x01) {

				/* Look for tone A on, and tone A IS on */

				Tone[ix].ontime++;
				if (Tone[ix].tonetype == 1){
						/* This is a continuous tone */
						/* Comparing the max and min of ontime */
					if (Tone[ix].ontime >= Tone[ix].ontimemin)	{
						ToneResult = Tone[ix].tonecode;
						}
					}
				else {
					/* Do nothing */
					}
				}
			else {
				/* Look for tone A on, but tone A IS off */
				Tone[ix].status = 0;  /* Change to look for tone A off*/
				Tone[ix].offtime = 0; /* Initiate tone offtime */

				}
			}
		else {
			/* Look for tone A off */

			if ((ToneStatus & 0x01) == 0) {

				/* Look for tone A off, and tone A IS off */
				Tone[ix].offtime ++;
				}
			else {

				/* Look for tone A off, but tone A IS on */
				false_cond =  0; /* Glitch exist within Tone A on if it is TRUE*/
				false_cond1 = 0;
				tempp1 = 0;
				Tone[ix].status = 1;

		/* De-glitch during the Ring back period*/
				if (ix == 2) {
					if (Tone[ix].offtime < 55 && Tone[ix].offtime > 15) {/*UK ring back has 200ms off time*/
						Tone[ix].ontime += Tone[ix].offtime;
						Tone[ix].offtime = 0;
						false_cond = TRUE; /* Calling Tone exist with cadence ON */
						}

					if (Tone[ix].offtime > OffTime) {
						tempp1 = Tone[ix].offtime - OffTime;
						Tone[ix].offtime = OffTime;

						if ((OnTime - Tone[ix].ontime) > 5) {
							Tone[ix].ontime += tempp1;
							false_cond1 = TRUE; /* add to next on time */
							}
						}
					}
		/* End of ring back De-glitch function*/
				/* Reporting the Cadence for debugging purpose*/
				if ((voice_dist_ring_active == 0xC7)  && (false_cond == 0)) {
					if ( ix == 2 || ix == 1) {
	            	d2_to_a2(Tone[ix].ontime,tembuf);
   	         	strcpy((char *)cidbuf,"CADENCE_ON=");
      	      	strcat((char *)cidbuf,(char *)tembuf);
						output_info(cidbuf,VERBOSE_FORM);  /* CR, LF before and after */

		            d2_to_a2(Tone[ix].offtime,tembuf);
   		         strcpy((char *)cidbuf,"CADENCE_OF=");
      		      strcat((char *)cidbuf,(char *)tembuf);
         	   	output_info(cidbuf,NUMERIC_FORM);  /* CR, LF after */
						}
					}

				if (Tone[ix].tonetype == 2 && false_cond == 0) {	/* Two segments tone, make decision here*/
					if (Tone[ix].ontime >= Tone[ix].ontimemin)	{
						if (Tone[ix].ontime <= Tone[ix].ontimemax) {
							if (Tone[ix].offtime >= Tone[ix].offtimemin) {
								if (Tone[ix].offtime <= Tone[ix].offtimemax) {
									if (ix == 1) {
										if (busy_count){
											ToneResult = Tone[ix].tonecode;
											}
										else {
											busy_count++;
											}
										}
									else {
										ToneResult = Tone[ix].tonecode;
										}
									}
								}
							}
						}
					}
				if (CountryInfo == Italy){
					if (ToneResult == 1) {
						ToneModeSwitch = ToneModeIdle;
						break;
						}
					}

				if (false_cond == 0) {
					if (false_cond1 == TRUE) {
						Tone[ix].ontime = 0;
						}
					else {
						Tone[ix].ontime = tempp1; /* New on time*/
						}
					}
				}
			}
		}
	}


/****************************************************************************
/
/    Routine: ToneModeStateSwitch
/
/    Author : CIRRUS LOGIC
/
/    Creation Date: 05/02/96
/
/    Description :
/
/
/    Users:
/
/    Reason: Needed for the +VDR and +VDT.
/
/
****************************************************************************/


void ToneModeStateSwitch(void) {

	switch (ToneModeSwitch){
		case ToneModeIdle:
			break;
		case ToneModeStart:
			ToneModeDetection();
			break;
		default:
			break;
		}
	}


/*******************************************************************************
/
/	Routine: ast_NC
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine change the country code
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users: at_ast()
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void ast_NC(ubyte *param_ptr) {
	if (Default_Country == 0xFF) {	/* Only when Default_Country == 0xFF*/
		if (*param_ptr > MAX_COUNTRY_CODE) {
   	   error_occurred = TRUE;
			}
		else {
			CountryInfo = *param_ptr;
			InitiateCountryDependSReg();
/*			acu_load_defaults(AT_Z_COMMAND);*/
			}
		}
	else {
   	   error_occurred = TRUE;
		}
	}

/*******************************************************************************
/
/	Routine: d2_to_a2
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void d2_to_a2(uword val, ubyte buf[])
{
  ubyte temp3, temp2, temp1;
  int www;

  temp3 = val / 100;
  www = val % 100;

  temp2 = www / 10;
  temp1 = www % 10;

  buf[0] = temp3 + '0';
  buf[1] = temp2 + '0';
  buf[2] = temp1 + '0';
  buf[3] = 0;

}


/*******************************************************************************
/
/	Routine: InitiateToneATaps
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateToneATaps(void) {
	ubyte *temp;
	ONE_WORD ab[7];

	if (CountryInfo == USA)
		return ;
   current_command [0] = 0x0d;
  	current_command [1] = 0x00;
  	current_command [2] = 0x04;
   current_command [3] = 0x00;
   current_command [4] = 0x4d;
	current_command [5] = 0x00;
   current_command [6]  = 0xdf;
   current_command [7]  = 0xdf;
	temp = (ubyte *)(COM_RAM);
	*temp = 0x0c0;
  	ack_or_response = 0;
   send_pkt_to_dsp();

	if ((CountryInfo == Japan) || (CountryInfo == UK)/* || (CountryInfo == USA)*/){

		ab[0].w = PTT_Taps[CountryInfo].b12;
		ab[1].w = PTT_Taps[CountryInfo].b11;
		ab[2].w = PTT_Taps[CountryInfo].b10;
		ab[3].w = PTT_Taps[CountryInfo].a12;
		ab[4].w = PTT_Taps[CountryInfo].a11;
		ab[5].w = PTT_Taps[CountryInfo].b22;
		ab[6].w = PTT_Taps[CountryInfo].b21;
		current_command [0] = 0x0e;
   	current_command [1] = 0x00;
	  	current_command [2] = 0x10;
	   current_command [3] = 0x00;
/* Tone A Taps CommRAM location*/
	   current_command [4] = 0xD8;
  		current_command [5] = 0x01;
	   current_command [6]  = ab[0].b.b0; /* b12 */
	   current_command [7]  = ab[0].b.b1;
		current_command [8]  = ab[1].b.b0; /* b11 */
		current_command [9]  = ab[1].b.b1;
	   current_command [10] = ab[2].b.b0; /* b10 */
   	current_command [11] = ab[2].b.b1;
		current_command [12] = ab[3].b.b0; /* a12 */
		current_command [13] = ab[3].b.b1;
		current_command [14] = ab[4].b.b0; /* a11 */
	   current_command [15] = ab[4].b.b1;
		current_command [16] = ab[5].b.b0; /* b22 */
		current_command [17] = ab[5].b.b1;
   	current_command [18] = ab[6].b.b0; /* b21 */
	   current_command [19] = ab[6].b.b1;
		temp = (ubyte *)(COM_RAM);
		*temp = 0x0c0;
   	ack_or_response = 0;
	   send_pkt_to_dsp();

		ab[0].w = PTT_Taps[CountryInfo].b20;
		ab[1].w = PTT_Taps[CountryInfo].a22;
		ab[2].w = PTT_Taps[CountryInfo].a21;
	   current_command [0] = 0x0e;
	   current_command [1] = 0x00;
	  	current_command [2] = 0x08;
	   current_command [3] = 0x00;
/* Tone A Taps CommRAM location*/
	   current_command [4] = 0xDF;
   	current_command [5] = 0x01;
	   current_command [6]  =ab[0].b.b0; /* b20 */
	   current_command [7]  =ab[0].b.b1;
	   current_command [8]  =ab[1].b.b0;	/* a22 */
	   current_command [9]  =ab[1].b.b1;
	   current_command [10] =ab[2].b.b0;	/* a21 */
	   current_command [11] =ab[2].b.b1;
		temp = (ubyte *)(COM_RAM);
		*temp = 0x0c0;
		ack_or_response = 0;
	   send_pkt_to_dsp();
		}
	}

/*******************************************************************************
/
/	Routine: InitiateDTMFLevel
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateDTMFLevel(void){
	ubyte *temp;
   current_command [0] = 0x88;
  	current_command [1] = 0x00;
  	current_command [2] = 0x02;
   current_command [3] = 0x00;
   current_command [4] = PTT_DTMF_Level[CountryInfo].DTMF_Level.level1;
	current_command [5] = PTT_DTMF_Level[CountryInfo].DTMF_Level.level2;
	temp = (ubyte *)(COM_RAM);

/*MRM12796*/
/*donot need to set ack if sending packets*/
/*
	*temp = 0x0c0;
*/
  	ack_or_response = 0;
   send_pkt_to_dsp();
	}


/*******************************************************************************
/
/	Routine: InitiateTransmitLevel
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateTransmitLevel(void) {
	ubyte *temp,s91Lvl;
	ONE_WORD FaxLvl, DataLvl;

/*	if (CountryInfo == USA)	return;*/

	if (fax_class != 1 && fax_class != 0) return;

	s91Lvl = s[91];
	if (s91Lvl < PTT_SReg[CountryInfo].S91.min)
		s91Lvl = PTT_SReg[CountryInfo].S91.min;

	if (s91Lvl > PTT_SReg[CountryInfo].S91.max)
		s91Lvl = PTT_SReg[CountryInfo].S91.max;

	DataLvl.w = S91_PTT_TransmitLevel[s[91]];
	FaxLvl.w = S91_PTT_TransmitLevel[s[91]];

/*
	if (CountryInfo == Japan){
		DataLvl.w = S91_PTT_TransmitLevel[s[91]];
		FaxLvl.w = S91_PTT_TransmitLevel[s[91]];
		}
	else {
		DataLvl.w = PTT_TransmitLevel[CountryInfo].Data_Level;
		FaxLvl.w = PTT_TransmitLevel[CountryInfo].Fax_Level;
		}
*/

	current_command [0] = 0x0C;
  	current_command [1] = 0x00;
  	current_command [2] = 0x06;
   current_command [3] = 0x00;
   current_command [4] = 0x5F;
   current_command [5] = 0x16;
   current_command [6] = 0x00;
   current_command [7] = 0x00;
	if (fax_class) {
   	current_command [8] = FaxLvl.b.b0;
	   current_command [9] = FaxLvl.b.b1;
		}
	else {
   	current_command [8] = DataLvl.b.b0;
	   current_command [9] = DataLvl.b.b1;
 		}
	temp = (ubyte *)(COM_RAM);
	*temp = 0x0c0;
  	ack_or_response = 0;
   send_pkt_to_dsp();
	}

/*******************************************************************************
/
/	Routine: InitiateCountryDependSReg
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void InitiateCountryDependSReg(void) {
	ubyte dummy;
	dummy=0;

	(PTT_SReg[CountryInfo].S0.DefaultValue!=0)?s[0]=PTT_SReg[CountryInfo].S0.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S6.DefaultValue!=0)?s[6]=PTT_SReg[CountryInfo].S6.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S7.DefaultValue!=0)?s[7]=PTT_SReg[CountryInfo].S7.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S8.DefaultValue!=0)?s[8]=PTT_SReg[CountryInfo].S8.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S10.DefaultValue!=0)?s[10]=PTT_SReg[CountryInfo].S10.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S11.DefaultValue!=0)?s[11]=PTT_SReg[CountryInfo].S11.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S22.DefaultValue!=0)?s[22]=PTT_SReg[CountryInfo].S22.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S23.DefaultValue!=0)?s[23]=PTT_SReg[CountryInfo].S23.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S27.DefaultValue!=0)?s[27]=PTT_SReg[CountryInfo].S27.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S31.DefaultValue!=0)?s[31]=PTT_SReg[CountryInfo].S31.DefaultValue:dummy++;
	(PTT_SReg[CountryInfo].S91.DefaultValue!=0)?s[91]=PTT_SReg[CountryInfo].S91.DefaultValue:dummy++;

   switch (sr22.uk_hook) {
     	case 0:
	       make_time  = PTT_MakeBreak_Time[CountryInfo].P0_make_time;
   	    break_time = PTT_MakeBreak_Time[CountryInfo].P0_break_time;
			 break;
	  	case 1:
	       make_time  = PTT_MakeBreak_Time[CountryInfo].P1_make_time;
   	    break_time = PTT_MakeBreak_Time[CountryInfo].P1_break_time;
			 break;
	  	case 2:
	       make_time  = PTT_MakeBreak_Time[CountryInfo].P0_make_time/2;
	       break_time = PTT_MakeBreak_Time[CountryInfo].P0_break_time/2;
    		 break;
	  	case 3:
		    make_time  = PTT_MakeBreak_Time[CountryInfo].P1_make_time/2;
   		 break_time = PTT_MakeBreak_Time[CountryInfo].P1_break_time/2;
			 break;
	   }
	}

/*******************************************************************************
/
/	Routine: CountryDependSRegRangeCheck
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void CountryDependSRegRangeCheck(ubyte number) {
	ubyte max, min;

	switch (current_register) {
		case 0:
			max = PTT_SReg[CountryInfo].S0.max;
			min = PTT_SReg[CountryInfo].S0.min;
			break;
		case 6:
			max = PTT_SReg[CountryInfo].S6.max;
			min = PTT_SReg[CountryInfo].S6.min;
			break;
		case 7:
			max = PTT_SReg[CountryInfo].S7.max;
			min = PTT_SReg[CountryInfo].S7.min;
			break;
		case 8:
			max = PTT_SReg[CountryInfo].S8.max;
			min = PTT_SReg[CountryInfo].S8.min;
			break;
		case 10:
			max = PTT_SReg[CountryInfo].S10.max;
			min = PTT_SReg[CountryInfo].S10.min;
			break;
		case 11:
			max = PTT_SReg[CountryInfo].S11.max;
			min = PTT_SReg[CountryInfo].S11.min;
			break;
		case 91:
			max = PTT_SReg[CountryInfo].S91.max;
			min = PTT_SReg[CountryInfo].S91.min;
			break;
		}
	if (number >= min && number <= max) {
		s[current_register] = number;
		}
	else {
		if (number < min)	{
			s[current_register] = min;
			}
		else {
			s[current_register] = max;
			}
		}
	}


/*******************************************************************************
/
/	Routine: SetPulseRelay
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/

void SetPulseRelay(uword status) {
#ifndef __riscos
	uword *gpio;

	gpio = (uword *) GPCR1 ;
	*gpio = PULSE_DIAL_MASK | 0x0002 ; /* config Pulse dial bit as output */

	gpio = (uword *) GPR1 ;
	*gpio = PULSE_DIAL_MASK | status;
/* if status =0000, output a 0, relay on -- make time */
/* if status =0002, output a 1, relay off-- break time */

	if(status == 0x0002){
		gpio = (uword *) GPCR1 ;
		*gpio = PULSE_DIAL_MASK | 0 ;       /* config as input */
	}
/* config CID bit as input for prevent misoperation from other codes*/
#endif

	}

/*******************************************************************************
/
/	Routine: SetOnHookRelay
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/
#ifndef __riscos
#define  GPCR0          0xffc210   /* config reg, 0 input, 1 output */
#define  GPR0           0xffc204   /* if as output,value reg */
#define  HOOK_MASK		0x0080
#endif

void SetOnHookRelay(ubyte status) {
#ifdef __riscos
        set_hook_relay(status);
#else
	uword *gpio;

	gpio = (uword *)GPCR0 ;
	*gpio = HOOK_MASK | 0x0008 ; /* config Pulse dial bit as output */

	gpio = (uword *) GPR0 ;
	if (status == 0){
		*gpio = HOOK_MASK | 0x0000;
		}
	else {
		*gpio = HOOK_MASK | 0x0008;
		}
#endif
	}


/*******************************************************************************
/
/	Routine: LineCurrent
/
/	Author : Cirrus Logic
/
/	Creation Date: 5/8/96
/
/	Description: This routine shows the CADENCE timing
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	Cirrus Logic
/	Description:
/	Reason:
/
*******************************************************************************/
#define  LPOHD_MASK				0x0000
#define  LPOHD_RELAY_MASK		0x8000

ubyte LineCurrent(void){
    #ifdef __riscos
    return 1;
    #else
	uword *gpio, temp1;

	gpio = (uword *)GPCR0 ;
	*gpio = LPOHD_MASK | 0x0800 ; /* config LPOHD bit as input */

	gpio = (uword *)GPR0;

	if (*gpio & 0x0800){
		return 0;
		}
	else {
		return 1;
		}
    #endif
	}

#define VORELAY_MASK 	0x1000

void SetVORelay(ubyte status) {
    #ifndef __riscos
	uword *gpio;

	gpio = (uword *)GPCR0 ;
	*gpio = VORELAY_MASK | 0x0100 ; /* config Pulse dial bit as output */

	gpio = (uword *) GPR0 ;
	if (status == 0){
		*gpio = VORELAY_MASK | 0x0000;
		}
	else {
		*gpio = VORELAY_MASK | 0x0100;
		}
    #endif
	}
