/****************************************************************************
/
/   Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/       RSA
/       7701 Six Forks Road
/       Suite 120
/       Raleigh, NC  27615
/       (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.  The information contained herein is solely
/   for the use of RSA.
/
/       File:           ac00mstr.c
/
/       Module Version: ACU 4.02
/
/       Function:       This file contains the control code for the ACU.
/
/       Product:        ACU core code
/
/       History:        ac00mstr.c v3.90
/                       ac00mstr.c v3.91
/                       ac00mstr.c v3.96
/
/           Created:    10/7/91
/                       3/6/92
/                       1/12/93
/
/           ---------------------------------------------------------
/           -                 Modifications                         -
/           ---------------------------------------------------------
/
/           Author & Date: RSA/keh 7/1/94
/           Description: Add ACU ETC Driver interface for initialization
/           Reason: Add ETC support to core ACU
/
/           Author & Date:    RSA
/           Description:
/           Reason:
/
*****************************************************************************/

#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "v25_def.h"
#include "v25_mem.h"
#include "acu_pro.h"
#include "mt_pro.h"
#include "ll_pro.h"
#include "v25_pro.h"
#include "fp_pro.h"
#include "ds_pro.h"
#include "ee_def.h"
#include "ptt.h"

#include "fab.h"
extern void send_pkt_to_dsp(void);

/* start change keh 5/11/95 => Unused v.42 i/fs */
/*
*#include "dte.edf"
*#include "dce_line.edf"
*#include "v42.edf"
*/
/* end change keh 5/11/95 => Unused v.42 i/fs */
/* start change keh 7/1/94 => Add ETC interface */
#include "acu_epro.h"       /* ACU ETC Driver interface prototypes */
/* end change keh 7/1/94 => Add ETC interface */
/* start change keh 1/25/94 => add amps */
#include "wl_pro.h"
/* end change keh 1/25/94 => add amps */

/* Start Change PHONEBOOK SUBMODULE 9/6/1995. */
#include "phbk_pro.h"
/* End Change  PHONEBOOK SUBMODULE 9/6/1995. */

void main(void);
void master_init(void);
void acu_bg(void);
void master_bg(void);
extern void process_one_msec(void);

/* start change keh >> redo VNH */
#if 0
/* JAY - TIA Conversion Start 11/29/1993 */
/* void build_event(ubyte,ubyte); */
void build_event(uword,ubyte);
/* JAY - TIA Conversion End 11/29/1993 */
#endif

void build_event(ubyte,ubyte);
/* end change keh >> redo VNH */

/* start change 10/31/94 drc */
extern void hardware_init(void);
/* end change 10/31/94 drc */
extern void acu_phbk_init(void);
extern void disable_int(void);
extern void enable_int(void);

extern ubyte one_hundred_microsec;
extern void acu_timer(void);
extern ubyte dte_mode;
extern void Install_Int(void);
extern ubyte count_for_msec_timer;

ubyte last_event,last_built;
extern void dce_line_tx_int(void);
extern void dce_line_rx_int(void);
/*flag to display the dsp not responding*/
/*mrm2896*/
extern ubyte display_msg_one_time;

/*mrm32796*/
/*dsp patch code for program memory*/

extern void dsppatch(void);
extern ubyte CountryInfo;
/*******************************************************************************
/
/    Routine: main
/
/    Author : RSA
/
/    Creation Date: 06/13/91
/
/    Description : This Routine is the main controlling code for this
/               system.
/
/    Input Parameters: None
/
/    Output Parameters: none
/
/    Global Variables Changed:  None
/
/    Users:
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
#ifndef __riscos
void main(void)
{
    while (-1)
    {
	   master_init();

	   while (acu_loop == TRUE)
	   {
	          ACU_Main();
	   }
    }
}
#endif

void ACU_Main(void)
{
		  mmu_force_acu_pg
		  process_acu_timer();

		  /* Process background functions  */
		  mmu_force_acu_pg

		  if ((operating_mode != DIRECT) && (!test_in_progress))
			 system_bg();

		  process_fax_bg();

		  process_voice_bg();

/* start change keh 9/21/95 => move vcv_bg to online_vv_bg and idle_vv_bg */
#if 0
/* RAK start 5/17/95 */
		  process_vcv_bg();
/* RAK end 5/17/95 */
#endif
/* end change keh 9/21/95 => move vcv_bg to online_vv_bg and idle_vv_bg */

		  /* Need to prevent the modem_task from being called if
			 MNP 10 is running .     All data pump operations should
			 be handled by the MNP 10 code. */
		  if (!v42_running_mnp10)
			 modem_task();

/* start change keh 1/25/94 => add amps */
		  /*wireless_bg();*/ /* ramn 9/26/96 */
/* end change keh 1/25/94 => add amps */

		  acu_bg();
		  master_bg();


		  /*frontpanel_bg();*/		/* ramn 9/26/96 */


/*mrm5996*/
/*The base timer for serial and parallel mode are the same for the new musket
chip.
*/


/*
if PARALLEL_MODE == 1
*/
#ifndef __riscos
	  	  if ( count_for_msec_timer >= 2)

		  {
			disable_int();
			count_for_msec_timer -= 2;
			enable_int();
			process_one_msec();

		  }

/*one_hundred_microsec used to be 100 m sec but it changed to 500 m sec*/

		  if (one_hundred_microsec >= 20)
		  {
			disable_int();
			one_hundred_microsec -= 20;
			enable_int();
     		acu_timer();
		  }
#endif
/*
endif
*/

#if 0
if SERIAL_MODE == 1

	  	  if ( count_for_msec_timer >= 10)

		  {
			disable_int();
			count_for_msec_timer = 0;
			enable_int();
			process_one_msec();

		  }
		  if (one_hundred_microsec >= 100)
		  {
			disable_int();
			one_hundred_microsec = 0;
			enable_int();
     		acu_timer();
		  }
endif
#endif

}


/*******************************************************************************
/
/    Routine: master_init
/
/    Author : RSA
/
/    Creation Date: 06/13/91
/
/    Description : This Routine is called to initialize the modules needed
/               in this system.
/
/    Input Parameters: None
/
/    Output Parameters: none
/
/    Global Variables Changed:  acu_loop
/
/    Users:    main
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/ Author & Date: RSA/keh 7/1/94
/ Description: Add ACU ETC Driver initialization call "acu_ETC_init()"
/ Reason: Add ETC support to core ACU
/
/ Author & Date: RSA
/ Description:
/ Reason:
/
*******************************************************************************/
void master_init(void)
{

	ubyte pram_addr_hi,pram_addr_lo,pram_data_hi,pram_data_lo; /* ramn 4/18/96 */
	ubyte mcon_lo,mcon_hi;
	ubyte *temp;
	ubyte eeprom_error;



    mmu_pg_init

/* start change 10/31/94 drc */
	hardware_init();
/* end change 10/31/94 drc */

	 /*dsppatch();*/ /* ramn 4/22/96 */

    acu_loop = TRUE;

	Install_Int();

	dsppatch(); /* ramn 4/22/96 */
	voice_patch_dnlded = FALSE;		/* ramn 12/11/96 */




/* added by ramn on 4/18/96 */
/*#if CUTLASS_C6 == 1*/

#if 0
/*
	set the FREQ_SEL register to value of 24 i.e. 33.1776MHz
	the addr of FREQ_SEL is 03fbh.
*/
	pram_addr_hi = 0x03;
	pram_addr_lo =	0xfb;
	pram_data_hi =	0x0;
	pram_data_lo = 0x24;
	mcon_lo = 0;
	mcon_hi = 0;


  /*	LOAD_DSP_PROGRAM_MEMORY_WRITE */

     current_command [0] = 0x09;
     current_command [1] = 0x00;
  	  current_command [2] = 0x06;
     current_command [3] = 0x00;
     current_command [4] = pram_addr_lo;
     current_command [5] = pram_addr_hi;
     current_command [6] = mcon_lo;
     current_command [7] = mcon_hi;
	  current_command [8] = pram_data_lo;
     current_command [9] = pram_data_hi;
     current_command [10] = 0;



/* need to do this because the poke commands donot send ack packet C0 */
	 temp = (ubyte *)(COM_RAM);
	 *temp = 0x0c0;

	 ack_or_response = 0;
	 send_pkt_to_dsp();

/*
	this is 500 micro-sec tick hence wait for (90/2) = 45 milli-sec
	for PLL to stabilize
*/

	count_for_msec_timer = 0;
	while(count_for_msec_timer < 90)
		;

#endif
/* till here ramn 4/18/96 */





/*flag to display the dsp not responding*/
/*mrm2896*/

   s[3] = DEFAULT_S3;
   s[4] = DEFAULT_S4;

    /* initialize the acu and modem, and reset v42 */
    system_reset();

/*mrm2896*/
/*moved the interrupt disable after acu_init*/

   /* modem_disable_interrupts();*/
    /*modem_ram_init();*/ /* ramn 9/20/96 */

    modem_init();

/* Initialize counrty information from EEPROM*/
/* Shiang Lei */
	if (Default_Country == 0xFF) {
		eeprom_error = 0;
		eeprom_error = modem_read_data(COUNTRY_CODE,COUNTRY_CODE_SIZE,&CountryInfo);
		if (eeprom_error != 0 || CountryInfo > MAX_COUNTRY_CODE) {
			CountryInfo = 0;
			}
		}
	else {
			CountryInfo = Default_Country;
		}

    acu_init();

/*mrm2896*/

    modem_disable_interrupts();

    mmu_force_parse_pg

/*mrm2896*/

/*    acu_init();*/

    init_event_que();

    initialize_voice(POWERUP);

/* RAK start 5/17/95 */
    initialize_vcv();
/* RAK end 5/17/95 */

/* Start Change PHONEBOOK SUBMODULE 9/6/1995. */
   /*acu_phbk_init();*/		/* ramn 9/26/96 */
/* End Change  PHONEBOOK SUBMODULE 9/6/1995. */

    /* Included if there is a front pannel   */
    mmu_force_acu_pg
    /*frontpanel_init();*/		/* ramn 9/26/96 */

    /* Included if V25bis code is included   */
    /*v25bis_init();    */    /* ramn 9/27/96 */

    /* Included if Leased line code is included     */
    /*    mmu_force_acu_pg    not needed, done above for frontpanel */
    /*ll_init();*/  /* ramn 9/23/96 */

/* start change keh 7/1/94 => Add ETC Driver initialization call */
    acu_ETC_init();
/* end change keh 7/1/94 => Add ETC Driver initialization call */

    /* initialize the ACU io code */
    acu_port_init();

    mmu_force_parse_pg

	initialize_fax(FAX_INIT_POWERUP);


    /* give control of the terminal to the acu */
    mmu_force_acu_pg
    enable_acu_on_terminal();

    /* start the system running */
    modem_enable_interrupts();

    /*modem_mr_led(ON);*/ /* ramn 9/20/96 */

    mmu_force_parse_pg
    if (init_dipswitch_parms() == 0)
    {
/*        mmu_force_parse_pg      Not Needed, Done above for init_dipswitch_parms */
	   acu_reset();

	   if (sr27.leased_line)
	   {
		  if (sr14.originate_flag)
			 build_event(E_ORIG,UNUSED);
		  else
			 build_event(E_ANSW,UNUSED);
		  return;
	   }
	   else
		  modem_line_select(PSTN);

	   /* if (v25bis_active)
		  init_v25_communication();     */    /* ramn 9/27/96 */
    }

    if (!v25bis_active)
    {
	   autobaud_on();

	   /*if (sr14.echo_cmd_flag)
		  modem_serial_echo(ON);
	   else
		  modem_serial_echo(OFF);*/ /* ramn 9/20/96 */
    }


    /* If ignore DTR is selected, turn the TR LED on   */
    /* if ((sr27.comm_mode == ASYNC) && (sr21.DTR_control == 0))
	   modem_tr_led(ON);*/ /* ramn 9/20/96 */

/*flag to display the dsp not responding*/
/*mrm2896*/

			display_msg_one_time = 0;
}


/*******************************************************************************
/
/    Routine: acu_bg
/
/    Author : RSA
/
/    Creation Date: 06/13/91
/
/    Description : This Routine is called to process the ACU background
/               functions.
/
/    Input Parameters: None
/
/    Output Parameters: none
/
/    Global Variables Changed:  None
/
/    Users:    main
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void acu_bg(void)
{
    switch (acu_state)
    {
	   case S_IDLE: /*mmu_force_acu_pg*/
		  idle_bg();
		  break;

	   case S_PARSE:/*mmu_force_parse_pg*/
		  parse_bg();
		  break;

	   case S_ORIG: /*mmu_force_acu_pg*/
		  orig_bg();
		  break;

	   case S_ANSW: /*mmu_force_acu_pg*/
		  answ_bg();
		  break;

	   case S_ONLINE: /*mmu_force_acu_pg*/
		  online_bg();
		  break;

	   case S_HANGUP: /*mmu_force_acu_pg*/
		  hangup_bg();
		  break;

	   case S_TEST: /*mmu_force_acu_pg*/
		  test_bg();
		  break;
    }
}

/*******************************************************************************
/
/    Routine: master_bg
/
/    Author : RSA
/
/    Creation Date: 09/16/91
/
/    Description : This Routine is called to process the core code for the
/               autodialer.
/
/    Input Parameters: None
/
/    Output Parameters: none
/
/    Global Variables Changed:  acu_event
/
/    Users:    main
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void master_bg(void)
{
    /*mmu_force_acu_pg*/
    check_char_rcvd();

    /* This Routine needs the ACU page to be open */
    check_V24_transition();

    /* This Routine needs the ACU page to be open */
    check_modem_status();

    /* See if there are events to be processed */
    if ((struct ACU_event *)event_que.fill_begin != NULL)
    {
	   /* Remove event from the queue  */
	   acu_event = dq_event();

	   /* Process all events that are on the queue    */
	   while (acu_event != NULL)
	   {
		  /* This code is used for DEBUG   */

		  if (last_event != acu_event->type)
			 last_event = (ubyte)acu_event->type;

		  switch (acu_state)
		  {
			 case S_IDLE: /*mmu_force_acu_pg*/
				proc_idle();
				break;

			 case S_PARSE: /*mmu_force_parse_pg*/
				proc_parse();
				break;

			 case S_ORIG: /*mmu_force_acu_pg*/
				proc_orig();
				break;

			 case S_ANSW: /*mmu_force_acu_pg*/
				proc_answ();
				break;

			 case S_ONLINE: /*mmu_force_acu_pg*/
				proc_online();
				break;

			 case S_HANGUP: /*mmu_force_acu_pg*/
				proc_hangup();
				break;

			 case S_TEST: /*mmu_force_acu_pg*/
				proc_test();
				break;
		  }

		  /* Process the event Routine     */
		  /*mmu_force_acu_pg*/
		  (*acu_proc)();

		  /* Place the event buffer back onto the empty queue  */
		  fq_event(acu_event);

		  /* See if there is another event to process     */
		  acu_event = dq_event();
	   }
    }
}



/*******************************************************************************
/
/    Routine: build_event
/
/    Author : RSA
/
/    Creation Date: 06/17/91
/
/    Description : This Routine is called allocate an event buffer, set
/               the event and parameter fields, and queue it to be
/               processed later.
/
/    Input Parameters: ubyte type - type of event to be built
/                ubyte parm - parameter to be placed in the event buffer
/
/    Output Parameters: none
/
/    Global Variables Changed:  None
/
/    Users:
/
/    -------------------------------------------------------------
/    -              Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void build_event(ubyte type, ubyte parm)

{
    struct ACU_event *add;

    /* Get event buffer address    */
    add = aq_event();

    /* Build event if there is an event buffer available    */
    if (add != NULL)
    {
/* end change keh >> redo VNH */

	   /* This code is used for DEBUG   */

	  last_built = type;

	   add->type = type;
	   add->parm = parm;
	   qq_event(add);
    }
}

