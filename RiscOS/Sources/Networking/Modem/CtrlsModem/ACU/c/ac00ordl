
/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00ordl.c
/
/	Module Version: ACU 4.02
/
/	Function:	This file contains code for dialing a number.
/
/	Product:	ACU core code
/
/	History:	ac00ordl.c v3.90
/                       ac00ordl.c v3.91
/
/		Created: 11/16/91
/                       1/12/93
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date:	RSA
/		Description:
/		Reason:
/
*****************************************************************************/
#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "ee_def.h"
#include "acu_pro.h"
#include "mt_pro.h"
#include "ptt.h"
#include "acu_vce.h"		/* ramn 12/3/96 */



void orig_wait_for_dialtone(void);
void originate_dial(void);
void tone_char(ubyte);
void pulse_char(ubyte);
ubyte quiet_answer(void);
/* start change keh 12/94 => modify routines for new parser */
#if 0
void dial_stored_num(void);
#else
void build_stored_dial_string(void);
#endif
/* end change keh 12/94 => modify routines for new parser */
ubyte wait_for_tone(void);
void flash(void);
void process_modifiers(void);
/*SLei added */
extern ubyte ToneResult;
extern ubyte ErrorCode;
extern void  BlackListInsert(void);
extern void	 InitToneModeDetection(void);



/* ramn 6/19/96 */
extern ubyte vce_mode;	 /* this is online command */
extern ubyte thru_line;           
extern ubyte vls_cmd_value;	
extern ubyte vce_state;
/* slei 7/23/96 */
extern ubyte CountryInfo; 
extern SetPulseRelay(uword);
extern SetOnHookRelay(ubyte);
extern void SetVORelay(ubyte);

ubyte num_dialed = 0; /* ramn 8/15/96 */

/*******************************************************************************
/
/	Routine: orig_wait_for_dialtone
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called while the ACU is waiting to
/		      detect dialtone. If detected the ACU will continue dialing,
/		      if not then the ACU will hang up.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  st_orig.state, timer2
/
/	Users: orig_pstn_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void orig_wait_for_dialtone(void)
{
	ubyte type;

	if (timer1)
	{
		type = modem_call_progress();
		if (/*type*/ ToneResult == DIALTONE) /* SLei added for International*/
		{
			if (timer2 == 0)
			{
				modem_config_dtmf_dial(s[11],s[11]);
				st_orig.state = ORIG_DIAL;
				if(fax_class ==  8)			 /*ramn 2/26/96 */
					st_orig.type = VOICE;
				return;
			}
		}
		else
			timer2 = length_of_dialtone;
	}
	else
		if(fax_class ==  8)			 /*ramn 12/3/96 */
		{
			st_orig.type = VOICE;
         st_orig.state = ORIG_HANDSHAKING;
			voice_connect(VOICE_DIAL_HANGUP_NODT); /* ramn 12/3/96 */
		}
		else
			build_event(E_HANGUP,NO_DIALTONE);
}


/*******************************************************************************
/
/	Routine: originate_dial
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called to perform any dialing function
/		      needed.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr14.pulse, timer2, timer1, look_for_signal
/				   at_orig.state, modifier_type, return_to_idle
				  valid_char, R_mode, dial_J, dial_K
/
/	Users: orig_pstn_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void originate_dial(void);
*{
*	ubyte ch;
*
*	if (timer3 == 0)   /* remainder of billing delay */
*	{
*		if ((valid_char) && (!error_flag))
*		{
*			ch = get_next_char();
*			switch (ch)
*			{
*				case '*':
*				case 'B':
*				case 'C':
*				case 'D':
*				case '#':
*				case 'A': if (sr14.pulse)
*						break;
*
*				case '0':
*				case '1':
*				case '2':
*				case '3':
*				case '4':
*				case '5':
*				case '6':
*				case '7':
*				case '8':
*				case '9':  if (sr14.pulse)
*						pulse_char(ch);
*					   else
*						tone_char(ch);
*					   break;
*
*				case 'T': sr14.pulse = FALSE;
*					  modem_shrt_relay(OFF);
*					  break;
*
*				case 'P': sr14.pulse = TRUE;
*					  break;
*
*				case '@': timer1 = (s[7] * 100);
*					  timer2 = 0;
*					  look_for_signal = TRUE;
*					  line_signal_seen = FALSE;
*					  modem_shrt_relay(OFF);
*					  modem_init_call_progress(OFF_HOOK_DIALED);
*					  st_orig.state = PROCESS_DIAL_MOD;
*					  modifier_type = QUIET_ANSWER;
*					  break;
*
*				case '!': flash();
*					  break;
*
*				case ',': timer1 = (dial_pause_time * 100);
*					  st_orig.state = PROCESS_DIAL_MOD;
*					  modifier_type = PAUSE;
*					  break;
*
*				case 'R': R_mode = TRUE;
*					  break;
*
*				case 'S': dial_stored_num();
*					  break;
*
*				case 'W': timer1 = (s[7] * 100);
*					  timer2 = 0;
*					  look_for_signal = TRUE;
*					  modem_shrt_relay(OFF);
*					  modem_init_call_progress(OFF_HOOK_DIALED);
*					  st_orig.state = PROCESS_DIAL_MOD;
*					  modifier_type = WAIT_TONE;
*					  break;
*
*				case ';': return_to_idle = TRUE;
*					  valid_char = FALSE;
*					  break;
*
*				case 'J': dial_J = TRUE;
*					  break;
*
*				case 'K': dial_K = TRUE;
*					  break;
*
*				case '\0': valid_char = FALSE;
*			}
*		}
*		else
*		{
*			modem_shrt_relay(OFF);
*
*			if (R_mode)
*			{
*				R_mode = FALSE;
*				build_event(E_ANSW,UNUSED);
*			}
*			else if (return_to_idle)
*			{
*				return_to_idle = FALSE;
*				timer1 = 0;
*				build_event(E_PARSE,UNUSED);
*				send_ok = TRUE;
*			}
*			else
*				st_orig.state = INIT_MODEM_ORIG;
*
*			if (sr22.speaker_ctrl == OFF_DIALING)
*				modem_speaker(ON);
*		}
*	}
*}
#endif

void originate_dial(void)
{
	/*SLei added error code for black list*/
   ubyte ch;
   if (timer3 == 0)   /* remainder of billing delay */
   {
/* keh => + unsued error_flag */
/*        if ((valid_char) && (!error_flag)) */
       if (valid_char)
/* keh => - unsued error_flag */
       {
           ch = *acu_dial_string_ptr++;
           switch (ch)
           {
               case '*':
               case 'B':
               case 'C':
               case 'D':
               case '#':
               case 'A':
                   if (sr14.pulse)
                       break;

               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':

						 num_dialed = TRUE; /* ramn 8/15/96 */

                   if (sr14.pulse)
                       pulse_char(ch);
                   else
                       tone_char(ch);
                   break;

               case 'T':   /* Tone dial */
                   sr14.pulse = FALSE;
/*mrm121696*/
	  					 InitiateDTMFLevel(); /* SLei added for international DTMF Level*/
                   modem_shrt_relay(OFF);
                   break;
                
               case 'P':   /* Pulse dial */
						 if (CountryInfo == German){
							SetPulseRelay(PULSE_DIAL_MAKE);
							SetVORelay(0);
							SetOnHookRelay(1);
							}
                   sr14.pulse = TRUE;
                   break;
                
               case '@':  /* Quiet Answer */
                   timer1 = (s[7] * 100);
                   timer2 = 0;
                   look_for_signal = TRUE;
                   line_signal_seen = FALSE;
                   modem_shrt_relay(OFF);
                   modem_init_call_progress(OFF_HOOK_DIALED);
                   st_orig.state = PROCESS_DIAL_MOD;
                   modifier_type = QUIET_ANSWER;
                   break;

               case '!':   /* Hook flash */
                   flash();
                   break;

               case ',':   /* Pause */
                   timer1 = (dial_pause_time * 100);
                   st_orig.state = PROCESS_DIAL_MOD;
                   modifier_type = PAUSE;
                   break;
               
               case 'R':   /* Reverse mode */
                   R_mode = TRUE;
                   break;

               case 'S':   /* Dial stored number */
                   /* Modify "acu_dial_string_ptr" to point to a
                       number stored in EEPROM */
                   build_stored_dial_string();
						/*SLei added for black list*/
						 BlackListInsert();
						 if (ErrorCode){
					 		build_event(E_HANGUP,DELAYED_CALL);
							return;
							}
                   break;

               case 'W':   /* Wait for tone */
                   timer1 = (s[7] * 100);
                   timer2 = 0;
                   look_for_signal = TRUE;
                   modem_shrt_relay(OFF);
                   modem_init_call_progress(OFF_HOOK_DIALED);
                   st_orig.state = PROCESS_DIAL_MOD;
                   modifier_type = WAIT_TONE;
                   break;
               
               case ';':   /* Return to idle */
                   return_to_idle = TRUE;
                   valid_char = FALSE;
						 
						 if(fax_class==80)	/* ramn 10/25/96 */
						 {
						   /* Prep data pump for busy detection */
						   modem_init_call_progress(OFF_HOOK_DIALED);

						   /* Prep data pump for VV answer tone detection */
						   modem_init_vcv_call_progress(OFF_HOOK_DIALED);
						 }	

						 if(fax_class == 8) 		/* ramn 6/19/96 */
						 {
                      vce_mode = 1;	 /* this is online command */
							 thru_line = TRUE;           
							 vls_cmd_value = 1;	
			             vce_state = 5; 	/* voice_orig_complete ramn 6/28/96 */

						 }
                    break;
                
               case 'J':   /* MNP10 J modifier (Connect at 1200) */
                   dial_J = TRUE;
                   break;

               case 'K':   /* MNP10 K modifier (Cellular mode) */
                   dial_K = TRUE;
                   break;

               case '\0':  /* End of dial string */
                   valid_char = FALSE;
#if 0
						 if(fax_class == 8)   /* ramn 10/10/95 */
						 	return_to_idle = TRUE;	/* if in voice mode exe ';' */
#endif
                   break;
           } /* switch */
       }
       else
       {
			if ((CountryInfo == German) && sr14.pulse){
				SetOnHookRelay(0);
				SetVORelay(1);
				SetPulseRelay(PULSE_DIAL_BREAK);
				}
		     InitToneModeDetection();
		     
           modem_shrt_relay(OFF);

/* start change 4/10/95 keh => add phone mode */
           /* No Modem action for phone mode */
           if (st_orig.type == PSTN_PHONE)
           {
               build_event(E_CONNECT,UNUSED);
           }
           else
/* end change 4/10/95 keh => add phone mode */
               if (R_mode)
           {
               R_mode = FALSE;
               build_event(E_ANSW,UNUSED);
           }
           else if (return_to_idle)
           {
               return_to_idle = FALSE;
               timer1 = 0;
               build_event(E_PARSE,UNUSED);
               send_ok = TRUE;
           }
           else
               st_orig.state = INIT_MODEM_ORIG;

           if ((sr22.speaker_ctrl == OFF_DIALING) && (num_dialed == TRUE))	/* ramn 8/15/96 */
               modem_speaker(ON);

			  num_dialed = FALSE; /* ramn 8/15/96 */	
       }
   }
}
/* start change keh 12/94 => modify routines for new parser */


/*******************************************************************************
/
/	Routine: tone_char
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called to tone dial the selected
/		      character.
/
/	Input Parameters: ubyte ch - character to be dialed
/
/	Output Parameters: none
/
/	Global Variables Changed:  dial_timer
/
/	Users: originate_dial
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void tone_char(ubyte ch)
{
/* start change 1/16/94 keh => no stalled loops for OS support */
#if 0 /* original code...*/
*    /*	Turn on tone	*/
*    modem_tone_on(ch);
*    dial_timer = s[11];
*    while (dial_timer)
*        process_wait();
*
*    modem_tone_off();
*    dial_timer = s[11];
*    while (dial_timer)
*        process_wait();
#endif

    /* Start DTMF tone generation at the physical level */
    modem_tone_on(ch);
    dial_flag = TRUE;      /* Flag denoting that DTMF is ON */
    dial_timer = s[11];    /* Tone-on time */

    /* Use "dial modifier" sub-state to wait until the entire tone is
        generated AND until an equal delay of tone-off has passed */
    st_orig.state = PROCESS_DIAL_MOD;
    modifier_type = DIAL_DIGIT_WAIT;

/* end change 1/16/94 keh => no stalled loops for OS support */
}


/*******************************************************************************
/
/	Routine: pulse_char
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called to pulse dial a selected
/		      character.
/
/	Input Parameters: ubyte ch - character to be dialed
/
/	Output Parameters: none
/
/	Global Variables Changed:  dial_timer, timer1
/
/	Users: originate_dial
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void pulse_char(ubyte ch)
{
/* start change 1/16/94 keh => no stalled loops for OS support */
#if 0 /* orig code */
*    ubyte num;
*    ubyte i;
*
*    modem_shrt_relay(ON);
*
*    if (!(num = ch - '0'))
*        num = 10;
*
*    for (i = 0; i < num; i++)
*    {
*        on_hook();
*        dial_timer = break_time;
*        while (dial_timer)
**            process_wait();
*        off_hook();
*        dial_timer = make_time;
*        while (dial_timer)
**            process_wait();
*    }
*
*    /*	Delays before pulsing the next character   */
*    timer1 = inter_digit_delay;
*    while (timer1)
**        process_wait();
*
#endif

    /* Set hold relay */
    modem_shrt_relay(ON);

    /* The '0' digit is 10 pulses */
    if (!(number_of_pulses = ch - '0'))
        number_of_pulses = 10;

    /* Use "dial modifier" sub-state to wait until the entire pulse is
        generated AND until an equal amount of post pulse delay has passed */
    st_orig.state = PROCESS_DIAL_MOD;
    modifier_type = DIAL_DIGIT_WAIT;

    /* Background flag denoting the pulse required is ON */
    dial_flag = TRUE;
/* end change 1/16/94 keh => no stalled loops for OS support */
}

/* start change 1/16/94 keh => no stalled loops for OS support */
/*******************************************************************************
/
/	Routine: wait_for_digit
/
/	Author : RSA
/
/	Creation Date: 01/16/95
/
/	Description : This Routine is called to perform background timing
/               on TONE and PULSE dialed digits.
/
/	Input Parameters: none
/
/	Output Parameters: 0 (FALSE) digit not finished, otherwise finished.
/
/	Global Variables Changed:  dial_timer, number_of_pulses,dial_flag
/
/	Users: orig_pstn_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte wait_for_digit(void)
{
   if (!dial_timer)
   {
       /* First test for PULSE dialing delays */
       if (sr14.pulse)
       {
           /* A pulse consists of on/off-hook sequence "n" times.  Where
               "n" is the digit number */
           /* Any pulses left in the digit? */
           if (number_of_pulses)
           {
               /* On-hook sequence? */
               if (dial_flag)
               {
  						if (CountryInfo == German)	{
							SetPulseRelay(PULSE_DIAL_BREAK);
							}
						else {
                   	on_hook();
							}
                   dial_timer = break_time;

/* 5/7/96 shd, for the result has 1 msec longer than spec time */
                   dial_timer-- ;

                   dial_flag = FALSE;
               }
               /* Else Off-hook sequence */
               else
               {
						if (CountryInfo == German)	{
							SetPulseRelay(PULSE_DIAL_MAKE);
							}
						else {
                   	off_hook();
							}
                   dial_timer = make_time;

/* 5/7/96 shd, for the result has 1 msec longer than spec time */
                   dial_timer-- ;

                   dial_flag = TRUE;
                   number_of_pulses--;
               }
           }
           /* Else no pulses left in the digit so time the interdigit
               delay time */
           else
           {
               /*	Interdigit delay still running? */
               if (dial_flag)
               {
                   /*	Reuse the dial timer (8bit, 10 msec) to time
                       the 750 (3 x 250) msec interdigit delay */
                   dial_timer = 250;
                   /* Set delay complete flag after 750 msecs */
                   if (dial_flag >= 3)
                       dial_flag = FALSE;
                   else
                       dial_flag++;
               }
               /*	Else the interdigit delay is complete, so return to the
                   main dialing state */
               else
               {
                   return TRUE;
               }
           }
       }
       /* Else TONE dialing */
       else
       {
           /* If the tone was ON */
           if (dial_flag)
           {
               /* The tone was on, so turn the tone off, and wait an
                   equal amount of tone-off time */
               modem_tone_off();
               dial_timer = s[11];
               /* Set tone-off flag */
               dial_flag = FALSE;
           }
           /* Else the tone was OFF */
           else
           {
               /* The tone off time has expired, so return to the
                   main dial state */
               return TRUE;   /* Digit timing is complete */
           }
       }
   }
   return FALSE;   /* Digit timing not complete */
}
/* end change 1/16/94 keh => no stalled loops for OS support */

/*******************************************************************************
/
/	Routine: quiet_answer
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called to process the wait for quiet
/		      answer dial modifier '@'.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte TRUE - if quiet answer was detected
/				 FALSE - If not detected
/
/	Global Variables Changed:  timer2, look_for_signal
/
/	Users: originate_dial
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
/* start change keh 4/5/95 >> re-write routine > '@' fails */
#if 0 /* orig routine */
*ubyte quiet_answer(void)
*{
*	ubyte type;
*
*	if (timer1)
*	{
*		type = modem_call_progress();
*		if (type == BUSY_SIGNAL)
*		{
*			build_event(E_HANGUP,BUSY);
*			return (FALSE);
*		}
*
*		if (type == LINE_SIGNAL)
*			line_signal_seen = TRUE;
*
*		else if ((type == SILENCE) && (line_signal_seen))
*		{
*			if (timer2 == 0)
*			{
*
*/*	If first time silence is detected then set up for the 5 second wait    */
*				if (look_for_signal)
*				{
*					timer2 = mod_quiet_answ_length;
*					look_for_signal = FALSE;
*				}
*
*/*	Else silence detection is valid        */
*				else
*					return (TRUE);
*			}
*		}
*
*/*	If silence is not detected within the 5 seconds then wait again        */
*		else
*		{
*			timer2 = 0;
*			look_for_signal = TRUE;
*		}
*	}
*
*/*	Silence was not detected within S7 seconds     */
*	else
*		build_event(E_HANGUP,NO_ANSWER);
*
*	return (FALSE);
*}
#endif

ubyte quiet_answer(void)
{
   ubyte type;

   /* Silence was not detected within S7 seconds */
   if (!timer1)
   {
       build_event(E_HANGUP,NO_ANSWER);
       return (FALSE);
   }

   /* Get CP from modem task */
   type = modem_call_progress();

   /* Always check for BUSY first */
	/* SLei changed */
   if (/*type*/ ToneResult == BUSY_SIGNAL)
   {
       build_event(E_HANGUP,BUSY);
   }
   /* Else look for any other Call Progress signal to start the timer */
	else if (!line_signal_seen)
   {
	/*SLei changed*/
       if ((type == LINE_SIGNAL) || (/*type*/ ToneResult == RINGBACK))
       {
			line_signal_seen = TRUE;

           /* Reuse "look_for_signal" as quiet timer started flag */
			look_for_signal = FALSE;
       }
   }
   /* Else wait for 5 secs of Quiet */
   else
   {
       if ((type == SILENCE) || (type == NO_ANSWER_TONE))
		{
           /* Reuse "look_for_signal" as quiet timer started flag */
           /* If first time silence is detected set up for the 5 sec. wait */
           if (!look_for_signal)
           {
               timer2 = mod_quiet_answ_length;
               look_for_signal = TRUE;
           }
           /* If silence is qualified */
           else if (!timer2)
			{
               return (TRUE);
			}
		}
       /* Else reset silence timer */
		else
		{
		    look_for_signal = FALSE;
		}
	}

	return (FALSE);
}
/* end change keh 4/5/95 >> re-write routine > '@' fails */



/*******************************************************************************
/
/	Routine: dial_stored_num
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine dials a number stored by the &Zn command.
/		      The number is determined by the S=n dial modifier.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: originate_dial
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/	Description:
/	Reason:
/
*******************************************************************************/
/* start change keh 12/94 => modify routines for new parser */
#if 0
*void dial_stored_num(void)
*{
*	ubyte ch;
*	ubyte *string,*temp_ptr;
*	uword length;
*
*	ubyte num;
*	uword address;
*	ubyte eeprom_error;
*
*	ch = get_next_char();
*
*/*	If the delimiter (=) is not present then use the number in location 0	*/
*	if (ch == NULL)
*	{
*		eeprom_error = modem_read_data(TELE_NUMBER_0_ADD,TELE_NUMBER_SIZE,(ubyte *)&temp_array[0]);
*
*/*	If an EEPROM read error occurres, return error and hang up */
*		if (eeprom_error == TRUE)
*		{
*			build_event(E_HANGUP,ERROR);
*			return;
*		}
*	}
*	else
*	{
*		if (ch == '=')
*		{
*			ch = get_next_char();
*
*/*	If there is no number after the (=) then use the number in location 0	*/
*			if (ch == NULL)
*			{
*				eeprom_error = modem_read_data(TELE_NUMBER_0_ADD,TELE_NUMBER_SIZE,(ubyte *)&temp_array[0]);
*
*/*	If an EEPROM read error occurres, return error and hang up */
*				if (eeprom_error == TRUE)
*				{
*					build_event(E_HANGUP,ERROR);
*					return;
*				}
*			}
*
*/*	Else determine the number	*/
*			else
*			{
*				num = ch - '0';
*				if (num > 3)
*				{
*					build_event(E_HANGUP,ERROR);
*					return;
*				}
*
*				switch (num)
*				{
*					case 0: address = TELE_NUMBER_0_ADD;
*						break;
*
*					case 1: address = TELE_NUMBER_1_ADD;
*						break;
*
*					case 2: address = TELE_NUMBER_2_ADD;
*						break;
*
*					case 3: address = TELE_NUMBER_3_ADD;
*						break;
*				}
*
*				eeprom_error = modem_read_data(address,TELE_NUMBER_SIZE,(ubyte *)&temp_array[0]);
*
*/*	If an EEPROM read error occurres, return error and hang up */
*				if (eeprom_error == TRUE)
*				{
*					build_event(E_HANGUP,ERROR);
*					return;
*				}
*			}
*		}
*		else
*		{
*			build_event(E_HANGUP,ERROR);
*			return;
*		}
*	}
*	string = (ubyte *)&temp_array[0];
*
*	output_info(string,STORED_NUM);
*	temp_ptr = (ubyte *)&cmd_line[0];
*	length = str_len(temp_ptr);
*
*/*	Check to see if the length of stored number + command line is not too
*	long.
**/
*	if ((str_len(string) + length) > MAX_CMD_LINE)
*	{
*		build_event(E_HANGUP,ERROR);
*		return;
*	}
*
*/*	Place into command line buffer to be processed	*/
*	temp_ptr = cmd_ptr;
*	while (*string != NULL)
*		*temp_ptr++ = *string++;
*
*	*temp_ptr = NULL;
*}
#endif

void build_stored_dial_string(void)
{
   ubyte *string;
   uword address = 0;
   ubyte error = FALSE;

   /* Determine which stored number to dial.
    * The AT command has the form: "S=n", but the "S" has already
    *  been determined by originate_dial() */

   /* First test ATDS case (implies num 0)*/
   if (*acu_dial_string_ptr == '\0')
   {
       address = TELE_NUMBER_0_ADD;
   }
   /* Then parse for any '=' */
   else if (*acu_dial_string_ptr == '=')
   {
       /* Get char after the '=' */
       switch (*++acu_dial_string_ptr)
       {
           case NULL:  /* ATDS= defaults to zero */
           case '0':   /* ATDS=0 */
               address = TELE_NUMBER_0_ADD;
               break;

           case '1':   /* ATDS=1 */
               address = TELE_NUMBER_1_ADD;
               break;

           case '2':   /* ATDS=2 */
               address = TELE_NUMBER_2_ADD;
               break;

           case '3':   /* ATDS=3 */
               address = TELE_NUMBER_3_ADD;
               break;

           default:
               error = TRUE;
               break;
       } /* switch */
   }
   else
   {
       error = TRUE;
   }

   /*	If no parse error, get stored number from EEPROM */
   if (!error)
   {
       /* Use the temp array for storeage */
       string = (ubyte *)&temp_array[0];

       /* Get stored number from the eeprom */
       error = modem_read_data(address,TELE_NUMBER_SIZE,string);

       /*	If no EEPROM read error, continue */
       if (!error)
       {
           /* Force EndOfString char */
           temp_array[TELE_NUMBER_SIZE] = '\0';

           /* Echo the number to the Terminal */
           output_info(string,STORED_NUM);

           /* Move the dial string to the stored number */
           acu_dial_string_ptr = string;
       }
   }

   /* Any dial error results in hangup */
   if (error)
       build_event(E_HANGUP,ERROR);
}
/* end change keh 12/94 => modify routines for new parser */

/*******************************************************************************
/
/	Routine: wait_for_tone
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called to process the wait for dial tone
/		      dial modifier 'W'.
/
/	Input Parameters: None
/
/	Output Parameters: ubyte TRUE - dial tone was detected
/				 FALSE - dial tone was not detected
/
/	Global Variables Changed:  timer2, look_for_signal
/
/	Users: originate_dial
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte wait_for_tone(void)
{
   ubyte type;

   /*	Wait for time specified in S7	*/
   if (timer1)
   {
       type = modem_call_progress();
/*SLei changed*/
       if (/*type*/ ToneResult == BUSY_SIGNAL)
       {
           build_event(E_HANGUP,BUSY);
           return (FALSE);
       }
       else if (/*type*/ ToneResult == DIALTONE)
       {
           if (timer2 == 0)
           {
               /*	If first time dialtone is detected then set up for
                   the 3 second wait	*/
               if (look_for_signal)
               {
                   timer2 = mod_dialtone_length;
                   look_for_signal = FALSE;
               }
               /*	Else dialtone detection is valid	*/
               else
                   return (TRUE);
           }
       }
       /*	If dialtone is not detected within the 3 seconds then wait again	*/
       else
       {
           timer2 = 0;
           look_for_signal = TRUE;
       }
   }
   /*	Dialtone was not detected within S7 seconds	*/
   else
       build_event(E_HANGUP,NO_DIALTONE);

   return (FALSE);
}


/*******************************************************************************
/
/	Routine: flash
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called to process the flash '!' dial
/		      modifier.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  timer1
/
/	Users: originate_dial
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void flash(void)
{
/* start change 1/16/94 keh => no stalled loops for OS support */
#if 0  /* Original code: */
*	on_hook();
*   timer1 = flash_time;
*
*	while(timer1)
**		process_wait();
*
*	off_hook();
*	timer1 = flash_time;
*
*	while(timer1)
*		process_wait();
#endif

   /* Start the falsh sequence (on- then off-hook) now, and do the
       timing in the orig_pstn_bg() */
   on_hook();
   timer1 = flash_time;
   dial_flag = TRUE;

   /* Set orig_pstn_bg to time the flash in the background */
   st_orig.state = PROCESS_DIAL_MOD;
   modifier_type = DIAL_FLASH_WAIT;
/* end change 1/16/94 keh => no stalled loops for OS support */
}

/* start change 1/16/94 keh => no stalled loops for OS support */
/*******************************************************************************
/
/	Routine: wait_for_flash
/
/	Author : RSA
/
/	Creation Date: 01/16/95
/
/	Description : This Routine is called to perform background timing
/               for hook flashes
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  timer1, dial_flag
/
/	Users: orig_pstn_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
ubyte wait_for_flash(void)
{
   /* A FLASH consists of on/off-hook sequence.  This routine times the
       on-hook delay (done by flash()), returns the hook back off, times
       the off-hook delay, and returns to TRUE to indicate flash is complete */
   /* Flash time complete? */
   if (!timer1)
   {
       /* Currently on-hook? */
       if (dial_flag)
       {
           off_hook();
           timer1 = flash_time;
           dial_flag = FALSE;
       }
       /* Else currently off-hook, so flash is complete */
       else
       {
           return TRUE; /* Flash complete */
       }
   } /* timer1 time-out */

   return FALSE;   /* Flash not complete */
}

/* end change 1/16/94 keh => no stalled loops for OS support */



/*******************************************************************************
/
/	Routine: process_modifiers
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine is called to process any dial modifiers that
/		      will take time to process.
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  st_orig.state
/
/	Users: orig_pstn_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void process_modifiers(void)
{
   switch (modifier_type)
   {
       case WAIT_TONE:
           if (wait_for_tone())
               st_orig.state = ORIG_DIAL;
           break;

       case PAUSE:
           if (timer1 == 0)
               st_orig.state = ORIG_DIAL;
           break;

       case QUIET_ANSWER:
           if (quiet_answer())
               st_orig.state = ORIG_DIAL;
           break;

/* start change 1/16/94 keh => no stalled loops for OS support */
       case DIAL_DIGIT_WAIT:
           /* When the dial timer times-out, change back to
               dialing digit state */
           if (wait_for_digit())
               st_orig.state = ORIG_DIAL;
           break;

       case DIAL_FLASH_WAIT:
           /* When the dial timer times-out, change back to
               dialing digit state */
           if (wait_for_flash())
               st_orig.state = ORIG_DIAL;
           break;
/* end change 1/16/94 keh => no stalled loops for OS support */
   }
}

