/****************************************************************************
/
/	Copyright 1988,1989,1990,1991,1992,1993,1994. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/	File:		ac00anps.c
/
/	Module Version: ACU 4.02
/
/	Function:	This file contains the action Routines for the ANSW
/			state of type AT_PSTN and V25_PSTN.
/
/	Product:	ACU core code
/
/	History:	ac00anps.c v3.90
/			ac00anps.c v3.91
/			ac00anps.c v3.92
/			ac00anps.c v3.93
/			ac00anps.c v3.94
/			ac00anps.c v3.96
/
/		Created: 10/7/91
/			 10/8/91
/			 10/16/91
/			 1/21/92
/			 3/6/92
/			 1/12/93
/
/		---------------------------------------------------------
/		-			Modifications			-
/		---------------------------------------------------------
/
/		Author & Date: RSA/keh 7/1/94
/		Description: Add interface to signal an ETC physical handshake
/		Reason: Add ETC support to core ACU
/
/		Author & Date:	RSA/keh 8/14/95
/		Description: add V.34 i/f calls
/		Reason: 
/
/		Author & Date:	RSA 
/		Description: 
/		Reason: 
/
*****************************************************************************/
#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "ds_def.h"
#include "ds_mem.h"
#include "acu_pro.h"
#include "mt_pro.h"

/*MRM32996*/
#include "fab.h"


/* start change keh 7/1/94 => Add ETC interface */
#include "acu_epro.h"       /* ACU ETC Driver interface prototypes */
/* end change keh 7/1/94 => Add ETC interface */

void proc_answ_at(void);
void answ_pstn_bg(void);
void acu_answer(void);
void answ_init_modem(void);
void answ_handshaking(void);

/*mrm32896*/
/*V329poke*/
/*for version 3.29 dsp code the Tx level is reduced to meet the Fcc requirements*/

extern void send_pkt_to_dsp(void);
extern ubyte ms_mode;
/*SLei added*/
extern void InitiateTransmitLevel(void);


/* ramn 7/31/96 */
extern ubyte s0_value_changed;	
extern ubyte	value_of_s0_reg; 



/*******************************************************************************
/
/	Routine: proc_answ_at
/
/	Author : RSA
/
/	Creation Date: 07/17/91
/
/	Description : This Routine will process the event by determining the
/		      next state and the action to be performed for the ANSW
/		      state of type AT_PSTN.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  acu_state, acu_proc
/
/	Users: proc_answ
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void proc_answ_at(void)
{
	acu_state = st_answ_at[acu_event->type].new_state;
	acu_proc = st_answ_at[acu_event->type].fnc_ptr;
}


/*******************************************************************************
/
/	Routine: answ_pstn_bg
/
/	Author : RSA
/
/	Creation Date: 06/17/91
/
/	Description : This Routine will process the background functions for
/		      the ANSW state of type AT_PSTN and V25_PSTN.
/
/	Input Parameters: None
/
/	Output Parameters: none
/
/	Global Variables Changed:  None
/
/	Users: proc_answ
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void answ_pstn_bg(void)
{
	switch (st_answ.state)
	{
		case INIT_ACU_ANSW:
		            /* In this state the ACU is being initialized for
                               answer mode. */
			     acu_answer();
			     break;

		case INIT_MODEM_ANSW:
		            /*In this state the ACU sets up the modem chips to
                              send answer tone.*/
			     answ_init_modem();
			     break;

		case ANSW_HANDSHAKE:
		            /* In this state the ACU performs handshaking in
                               the answer mode. */
			     answ_handshaking();
			     break;
	}
}

/*******************************************************************************
/
/	Routine: acu_answer
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine is called while the ACU is in the
/		      INIT_ACU_ANSW state. It will set up the ACU to start a
/		      connection as the answerer.
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  sr14.originate_flag, timer1 , st_answ.state
/
/	Users:	answ_pstn_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA
/	Description:
/	Reason:
/
*******************************************************************************/
void acu_answer(void)
{
   if (modem_call_progress() != RINGON)
   {
       sr14.originate_flag = FALSE;

       /*modem_serial_echo(OFF);*/ /* ramn 9/20/96 */

       /* Turn off RI indications incase ATA in the middle of a RING */
       /*modem_ri_led(OFF);*/ /* ramn 9/20/96 */
       modem_dte_ri(OFF);


		 if(s0_value_changed == TRUE)		/* ramn 7/31/96 */
		 {
		 	s0_value_changed = FALSE;	
		 	*srptr[0] = value_of_s0_reg ;
		 }

       off_hook();

       /* if adaptive answering the calling delay is in the modem task.
           the MT will be silent for 4 sec looking for calling tones */
       timer1 = fax_adaptive_answer ? 0 : answ_tone_delay;

#if 0
       if (sr21.auxiliary_relay_ctrl == 1)
           modem_AA1_relay(ON);
       modem_td_relay(ON);
#endif /* ramn 1/17/96 */

       modem_guard_tone((ubyte)sr23.guard_tone);

/* start change 4/10/95 keh => add phone mode */
/*       st_answ.state = INIT_MODEM_ANSW; */ /* go to send answer tone process */
       /* Phone mode goes to connect. */
       if (st_answ.type == PSTN_PHONE)
       {
           build_event(E_CONNECT,UNUSED);
       }
       else
       {
           st_answ.state = INIT_MODEM_ANSW;  /* go to send answer tone process */
       }
/* end change 4/10/95 keh => add phone mode */
   }
}


/*******************************************************************************
/
/	Routine: answ_init_modem
/
/	Author : RSA
/
/	Creation Date: 05/07/91
/
/	Description : This Routine will initialize the modem to start a
/		      connection as the answerer after a 2 second delay.
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:  modem_modem, modem_baud, last_async_sync
/				   st_answ.state
/
/	Users:	answ_pstn_bg
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date: RSA/keh 8/14/95 
/	Description: Add vars and tests and calls for mt_v8_config(),mt_v34_config
/	Reason: ACU support V.34    
/
/	Author & Date: RSA/keh 11/1/94 
/	Description: Add "etc_enabled" into modem_connect() call
/	Reason: ACU support for ETC.
/
/	Author & Date: RSA/keh 7/1/94 
/	Description: Add "acu_ETC_init_modem()" call for ETC connections
/	Reason: ACU support for ETC.
/
*******************************************************************************/
void answ_init_modem(void)
{

/*mrm32896*/
/*V329poke*/
/*for version 3.29 dsp code the Tx level is reduced to meet the Fcc requirements*/
	 ubyte *temp;


/*mrm22096*/
/*v32bis fix*/


   ubyte temp_tx_level,modem_baud1,baud2,automode1;

/* start change keh 8/14/95 => add v.34 */
   ubyte lapm_en,cellular_en;
/* end  change keh 8/14/95 => add v.34 */

    if (timer1 == 0)
    {
/* start change keh 8/14/95 => add v.34 */
       /* Program pump w/ V.34 configuration */
       modem_v34_configure(sr116.asym_rates,sr116.asym_symbols,sr116.aux_channel,
                       s[115],s[115],*(ubyte *)&sr114);

       /* V8 enabled? */
       if (automode & V8_ENABLED_BIT)
       {
           /* LAPM enabled for V.8 announcement? */
           if ((slN > 2) && !hyK)
               lapm_en= TRUE;
           else
               lapm_en= FALSE;


           /* Cellular call for V.8 announcement? */
           cellular_en = FALSE;

           modem_v8_configure(V8_DUPLEX_DATA,lapm_en,cellular_en);
       }
/* end change keh 8/14/95 => add v.34 */

        /* If cellular operation is enabled, Need to force the transmit
           level to be -10 dB. */
        if ((prnM || dial_K) && (dial_J || (link_negot == CONNECT_1200BPS)))
            temp_tx_level = 10;
        else
            temp_tx_level = s[91];

        modem_set_parameters(s[9],s[7],s[10],v32_retrain,temp_tx_level,
                     receive_threshold,s[108]);

        modem_baud = translate_modem_baud();
        modem_mode = translate_modem_mode(modem_baud);

/*mrm22096*/
/*v32bis fix*/
/*	
 modem_baud1 = BPS14400;
*/

	if (((s[37]== 0) || (s[37] >= 12)) && 	((ms_mode == V34) || (ms_mode == V34S)))
	{ 	 
	 	modem_baud1 = BPS14400;
	}
	else
 	{
		modem_baud1 = modem_baud;
	}


/*MRM32996*/

#if CUTLASS_C6 == 1


/*mrm32896*/
/*V329poke*/
/*for version 3.29 dsp code the Tx level is reduced to meet the Fcc requirements*/

	if ((ms_mode == V34) || (ms_mode == V34S) )
	{

     current_command [0] = 0x0c;
     current_command [1] = 0x00;
  	  current_command [2] = 0x06;
     current_command [3] = 0x00;
     current_command [4] = 0x5F;
     current_command [5] = 0x16;
     current_command [6] = 0x00;
     current_command [7] = 0x00;
	  current_command [8] = 0x84;
     current_command [9] = 0x1e;

	
	  temp = (ubyte *)(COM_RAM); 
	  *temp = 0x0c0;

     ack_or_response = 0;
     send_pkt_to_dsp();
	}

#endif
	baud2 = get_autobaud_rate();

		automode1 = automode;

 	if (baud2 == 3)
	{
	 	modem_baud1 = BPS1200;
		modem_mode = V22;
		automode1=1;
	}


        if (dial_J || (link_negot == CONNECT_1200BPS))
        {
            dial_J = FALSE;
            modem_baud = BPS1200;
            modem_mode = V22;
        }

        /* Need to update the modem with the selected baud rates */
        update_modem_rate_seq();

        /* Reset the system and determine the type of connection to be tried */
        system_reset();
        system_set_parameters();

        if ((operating_mode == DIRECT) && (init_type == HARDWARE))
            modem_char(last_async_sync,dipsw_char_size,dipsw_overspeed);
        else
            modem_char(last_async_sync,char_size,overspeed);

        /* Determine what type of connection should be attempted */
        if (fax_adaptive_answer)
            connect_type = CONNECT_DATA_FAX;
        else if (fax_class == 0)
            connect_type = CONNECT_DATA_ONLY;
        else
            connect_type = CONNECT_FAX_ONLY;

/*mrm22096*/
/*v32bis fix*/


        modem_connect((ubyte)sr14.originate_flag,modem_baud1,modem_mode,
                  (ubyte)sr27.clock_source,(ubyte)sr27.leased_line,automode1,
/* start change keh 11/94 => Change ETC interface */
/*                  connect_type ,calling_tone); */
                  connect_type ,calling_tone,
                 (acu_ETC_enabled() && !fax_class));
/* end change keh 11/94 => Change ETC interface */

/* start change keh 7/1/94 => Add ETC interface */
        /* If ETC and no FAX, signal the modem task to make an ETC connection */
        if (acu_ETC_enabled() && (fax_class == 0))
            acu_ETC_init_modem();
/* end change keh 7/1/94 => Add ETC interface */
/*SLei added*/
		InitiateTransmitLevel();
        st_answ.state = ANSW_HANDSHAKE;
    }
}


/*******************************************************************************
/
/    Routine: answ_handshaking
/
/    Author : RSA
/
/    Creation Date: 05/07/91
/
/    Description : This Routine will wait for carrier to be detected or
/              the modem task to go idle. If carrier is present then
/              the ACU will move to the ONLINE state. If modem task goes
/              to idle the ACU will move to the IDLE state.
/
/    Input Parameters: none
/
/    Output Parameters: none
/
/    Global Variables Changed:  None
/
/    Users:    answ_pstn_bg
/
/    -------------------------------------------------------------
/    -            Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void answ_handshaking(void)
{
    if (modem_status != IDLE_STATUS)
    {
        if (modem_check_dsr())
            if ((DSR_only_at_handshaking) || (comm_mode != ASYNC))
                modem_dte_dsr(ON);

        if (modem_status == FAX_CONNECTED)
        {
            start_fax_connection();
        }
        else if (modem_status == CONNECTED_STATUS)
        {
            /* Inform the terminal that a Data connection has been established  */
            if (connect_type == CONNECT_DATA_FAX)
            {
                if (fax_class == 20) /* if +FCLASS=2.0 (592) */
                                    /* <CR><LF>+FDM<CR><LF> */
                    output_info((ubyte *)DATA_FDM,VERBOSE_FORM); /* +FDM */
                else
                {
                    if (sr14.verbose_form)  /* class 1 & 2 Rockwell solution */
                                            /* <CR><LF>DATA<CR><LF> */
                        output_info((ubyte *)DATA_ROCKWELL_VERBOSE,VERBOSE_FORM);
                    else
                        /* 13<CR> */
                        output_info((ubyte *)DATA_ROCKWELL_NUMERIC,NUMERIC_FORM);

                    /* some sort of escape sequence should be implemented here*/
                }
                /* set +FCLASS=0, and turn off packet protocol after the response */
                process_fax_hangup(FALSE);
            }
            acu_connect();
        }
    }
    else
/* start change keh 3/31/95 >> redo VNH */
#if 0
/* JAY - TIA Conversion Start 11/29/1993 */
        build_event(E_HANGUP_VNH,NO_CARRIER);
/* JAY - TIA Conversion End 11/29/1993 */
#endif
    {
        /* Allow for Voice call discrimination (hangup w/out acutally
            hanging up */
        if (acu_cntrld_hangup)
        {
            acu_hangup_line = FALSE;
            build_event(E_HANGUP,OK);
        }
        else
        {
            build_event(E_HANGUP,NO_CARRIER);
        }
    }
/* end change keh 3/31/95 >> redo VNH */
}




