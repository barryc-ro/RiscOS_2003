/****************************************************************************
/
/	Copyright 1994,1995. All Rights Reserved by:
/	    RSA
/	    7701 Six Forks Road
/	    Suite 120
/	    Raleigh, NC  27615
/	    (919) 846-7171
/
/
/	This document contains material confidential to RSA its contents must
/	not be revealed, used or disclosed to anyone or company with out
/	written permission by RSA.  The information contained herein is solely
/	for the use of RSA.
/
/  File:		    ac00hnps.c
/
/	Module Version: ACU 4.02
/
/	Function:       This file contains routines that perform the hangup process.
/                  They are called from the hangup background loop.
/
/	Product:        ACU core code
/
/	History:        Re-write of hang_up() routine which would not return
/                  for up to 5 seconds.
/
/      Created: 12/16/94
/
/		---------------------------------------------------------
/		-                   Modifications                       -
/		---------------------------------------------------------
/
/		Author & Date:	RSA
/		Description:
/		Reason:
/
*****************************************************************************/

#include "sys_def.h"
#include "acu_def.h"
#include "acu_mem.h"
#include "acu_pro.h"
#include "mt_pro.h"
#include "dce_line.edf"

void hangup_at_init(void);
void hangup_at_system(void);
void hangup_at_physical_init(void);
void hangup_at_lsdisc_wait(void);
void hangup_at_physical(void);
void hangup_at_physical_wait(void);
void hangup_at_hook(void);
void hangup_at_complete(void);
void hangup_at_fax_init(void);
extern ubyte retrain_started;

/*mrm32096*/
/*added the return to idle to generate a modem init*/
extern void modem_return_to_idle(void);

/*MRM91896*/
/*CD TOGGLE FOR WINDOW APPLICATION*/
extern dcd_toggle;


/*******************************************************************************
/
/  Routine:            hangup_at_init
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will initialize the hangup background
/                      process for the DATA modem.  It selects the first
/                      hangup sub-states based on error corrected links.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: timer1,st_hangup
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
extern void orig_voice_hangup(void); 
void hangup_at_init(void)
{
/* ramn 1/15/96 */
	if(fax_class == 8)		  
	{ 
		orig_voice_hangup();
	}
	else
	{ 
	   /*	Do not perform the hang up until the error correction
   	    software indicates that it has disconnected. */
	   if (delay_before_hangup)
   	{
      	 timer1 = LOGICAL_HANGUP_DELAY_TIME;
	       st_hangup.state = HANGUP_LOGICAL_LINK_WAIT;
   	}

	   else
   	{
      	 /*	Reset the error correcting software	now */
	       timer1 =10;
	       st_hangup.state = HANGUP_LOGICAL_LINK_WAIT;
   	    /*hangup_at_system();*/
	   }

  	}

#if 0
/* ramn 3/11/96 */
		orig_voice_hangup();
	   /*	Do not perform the hang up until the error correction
   	    software indicates that it has disconnected. */
	   if (delay_before_hangup)
   	{
      	 timer1 = LOGICAL_HANGUP_DELAY_TIME;
	       st_hangup.state = HANGUP_LOGICAL_LINK_WAIT;
   	}
	   else
   	{
      	 /*	Reset the error correcting software	now */
	       timer1 = 0;
   	    hangup_at_system();
	   }
#endif
}

/*******************************************************************************
/
/  Routine:            hangup_at_system
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will wait until the logical link is
/                      disconnected before proceding to hangup the physical
/                      link.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: timer1,st_hangup
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_system(void)
{
   /*	Wait until the error correction software indicates that it has
       disconnected before proceding - or until we time-out waiting */
   if (!delay_before_hangup || !timer1)
   /*if (!timer1)*/
   {

       if ((operating_mode = RELIABLE) && (timer1 != 0))
			return;

       timer1 = 0;
       st_hangup.state = HANGUP_PHYSICAL_INIT;

       /*	Reset the error correcting software	*/
       system_reset();

       /*	This ACU/MNP10 variable disables the Modem Task from running
           when MNP10 is active, so this variable should also be reset
           after the system is reset.  This allows the MT to run during
           the DROP phase */
       v42_running_mnp10 = FALSE;
   }
}

/*******************************************************************************
/
/  Routine:            hangup_at_physical_init
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will initiate hangup for the physical
/                      link.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: timer1,st_hangup,long_space_disconnect 
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_physical_init(void)
{
   /* Remove the Terminal from the datapump durring the physical hangup */
   modem_serial_direct(NORMAL);

   /*	Three conditions to send a long space disconnect:
       1) If it's enabled (ATY1)
       2) If we haven't received one
       3) If it's a non-error corrected data link
   */
   if (sr21.long_space_discon && (long_space_disconnect == FALSE) &&
       (operating_mode != RELIABLE))
   {
       system_send_long_space_disc();

       /*	Delay to allow long space disconnect to go out	  */
       timer1 = long_space_send_time;

       /* Change states to time the LS delay */
       st_hangup.state = HANGUP_LONG_SPACE_DISC_WAIT;
   }
   /*	Else not a LS DISC so change states to drop the line */
   else
   {
       long_space_disconnect = FALSE;

       /* Change states to drop the physical link */
       hangup_at_physical();
   }
}

/*******************************************************************************
/
/  Routine:            hangup_at_lsdisc_wait
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will wait for a long space disconnect to
/                      complete before hanging up the physical link.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: timer1
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_lsdisc_wait(void)
{
   /* Do nothing until the long space disconnect is complete */
   if (!timer1)
   {
       /* Change states to drop the physical link */
       st_hangup.state = HANGUP_PHYSICAL_LINK;
   }
}

/*******************************************************************************
/
/  Routine:            hangup_at_physical
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will hang up the physical link.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: timer1,st_hangup
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_physical(void)
{
   ubyte cleardown_enabled;

   /*	Decide on a V.32 clear down sequence if in DIRECT mode or running
       speed matching, but prempted by LL tone disconnect */


/* by ramn 6/25/96 */
/* enable cleardown only in data mode */
	if((modem_status == CONNECTED_STATUS) || (modem_status == CONNECTING_STATUS))
	{
		cleardown_enabled = 
		(ubyte)(((operating_mode == DIRECT)||(operating_mode == NORMAL) ||
					(system_status == V42_SPEED)
										||(slN == DIRECT) || (slN == NORMAL)) &&
                                (tone_disconnect == FALSE));

	}
/*	else
		cleardown_enabled = FALSE;
*/

/*
	if((operating_mode == DIRECT)||(operating_mode == NORMAL)
		||(slN == DIRECT) || (slN == NORMAL))
		cleardown_enabled = TRUE;
*/

   /*	Release the line with or w/out a V.32 cleardown */
   modem_drop(cleardown_enabled);

   /* Change states to drop the physical link */
   st_hangup.state = HANGUP_PHYSICAL_WAIT;

   /* Set a watch dog timer to wait for carrier drop */
   if (hangup_result_type == NO_CARRIER)
       timer1 = HANGUP_PHYS_TIME__NO_CARRIER;
   else
       timer1 = HANGUP_PHYS_TIME__CARRIER;
}


/*******************************************************************************
/
/  Routine:            hangup_at_physical_wait
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will wait for the physical link to drop.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: timer1,st_hangup
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_physical_wait(void)
{
   /* Wait for the datapump to drop carrier OR to carrier drop
       to take too long */
   if (!modem_check_CD() || !timer1)
   {
       /* Reset timer, it's used in following states */
       timer1 = 0;
       /* Change states to go off hook */
       st_hangup.state = HANGUP_HOOK;
   }
}

/*******************************************************************************
/
/  Routine:            hangup_at_hook
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will move the modem "on-hook."
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: 
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_hook(void)
{
/* start change keh 3/31/95 >> redo VNH */
    /* Return the line on-hook ? */

/*mrm3196*/
	retrain_started = 0;

/*mrm32096*/
/*ath problem if modem status reg is not dropping*/
/*added the modem_return_to_idle to generate a modem init*/
	modem_return_to_idle();
		
   if (acu_hangup_line)
/* end change keh 3/31/95 >> redo VNH */
   {
       on_hook();
       modem_shrt_relay(OFF);
       modem_td_relay(OFF);
       modem_AA1_relay(OFF);
       modem_init_call_progress(ON_HOOK);
   }
/* JAY - TIA Conversion End 11/29/1993 */

   st_hangup.state = HANGUP_COMPLETE;
}


/*******************************************************************************
/
/  Routine:            hangup_at_complete
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will clean up after the hangup process.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: 
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_complete(void)
{
   if ((comm_mode == ASYNC) && (!DSR_only_at_handshaking))
       modem_dte_dsr(ON);
   else
       modem_dte_dsr(OFF);

   modem_ec_led(OFF);
   /*modem_dc_led(OFF);*/ /* ramn 9/20/96 */
   /*modem_cd_led(OFF);*/ /* ramn 9/20/96 */

/*MRM91896*/
/*CD TOGGLE FOR WINDOW APPLICATION*/

   if (sr21.RLSD_reflects_CD)
   {
		 dcd_toggle = 1;
       modem_dte_rlsd(OFF);
       /*modem_cd_led(OFF);*/ /* ramn 9/20/96 */
   }

   /*	Need to turn off RI led and signal incase hang_up is called in the
       middle of a ring	*/
   /*modem_ri_led(OFF);*/ /* ramn 9/20/96 */
   modem_dte_ri(OFF);

   /*fp_mode_led_off();*/	/* ramn 9/20/96 */

   /*	Reset if changed due to RELIABLE connection	*/
   if (sr23.grant_rdl == ENABLED)
       modem_rdl_enable(ENABLED);
   /*	Clear ring count */
   s[1] = 0;

   if (sr21.RLSD_reflects_CD != RLSD_reflects_CD_temp)
       sr21.RLSD_reflects_CD = RLSD_reflects_CD_temp;

   /*	Reset 400Hz disconnect tone detection variables */
   tone_disconnect = FALSE;

   /* Turn off any external V.23 clock generation hardware */
   if ((modem_mode == V23_HDX) || (modem_mode == V23_ADX))
       line_reset_v23();

   /*	Reset operating mode so it will be NORMAL while offline */
   operating_mode = NORMAL;
   at_z_command = FALSE;
   on_line_command = FALSE;
   delay_before_hangup = FALSE;

/* start change keh 3/31/95 >> redo VNH */
   acu_hangup_line = TRUE;
/* end change keh 3/31/95 >> redo VNH */

   /* keh: move to system_reset() */
 /*    v42_running_mnp10 = FALSE; */
   dial_K = FALSE;
   dial_J = FALSE;
   slU = FALSE;
   
   /*	If ATH was entered then return back to parse the rest of the command */
   if (at_h_command == TRUE)
   {
       at_h_command = FALSE;

       if (st_hangup.type == AT_PSTN)
           st_parse.type = AT_OFFLINE;

       build_event(E_PARSE,UNUSED);
   }
   /*	Else need to return to IDLE and return result message to the user */
   else
   {
       build_event(E_IDLE,UNUSED);
       enable_acu_on_terminal();
       build_event(E_MSG,hangup_result_type);
   }
}            


/*******************************************************************************
/
/  Routine:            hangup_at_fax_init
/
/  Author:             RSA
/
/  Creation Date:      12/17/95
/
/  Description:        This Routine will initialize the hangup background
/                      process for the FAX modem.
/
/  Input Parameters:   None
/
/  Output Parameters:  None
/
/  Global Variables Changed: hangup_w_cleardown,st_hangup.state
/
/  Users: hangup_at_bg()
/
/  -------------------------------------------------------------
/  -                       Modifications                       -
/  -------------------------------------------------------------
/
/  Author & Date:	RSA
/  Description:
/  Reason:
/
*******************************************************************************/
void hangup_at_fax_init(void)
{
   process_fax_hangup((ubyte) (at_h_command || at_z_command));

   /* Use data hangup up states to complete fax hangup */
   st_hangup.state = HANGUP_PHYSICAL_LINK;
}

