/******************************************************************************
/
/     Copyright, 1988, 1989, 1990, 1991, 1992, 1993, 1994. All Rights Reserved by:
/     Cirrus Logic, Inc.
/
******************************************************************************/
#include "mod_def.h" /* ramn 2/5/96 */
#include  "SYS_DEF.H"
#include  "cp_dsp.h"
#include  "MT_CODEF.H"
#include  "MT_HWDEF.H"
#include  "MT_COPRO.H"
#include  "MT_HWPRO.H"
#include  "MT_COEXT.H"
#include  "mt_macro.h" 
#include "dte_drv.h"
#include "tracemac.h"
#include "bldflags.h"
#include  "resp_cod.h"
#include  "acu_pro.h"
#include "lineequ.h"
#include "mt_gpio.h"
#include "ee_def.h"
#include "homolig1.h"
#include "hmg_mem1.h"

#define VOC_RELAY_OFF_HOOK		0x1000
#define VOC_RELAY_ON_HOOK 		0x1100
#define OH_RELAY_OFF_HOOK		0x0080
#define OH_RELAY_ON_HOOK		0x0088

ubyte *rom_components(void);
ubyte *capability_descript(void);
ubyte read_dipswitch(void);
ubyte write_eeprom_data(uword, uword, ubyte *);
ubyte read_eeprom_data(uword, uword, ubyte *);
ubyte calc_eeprom_checksum(void);
ubyte calc_rom_checksum(void);
void set_hs_led(ubyte);
void set_dte_cts(ubyte);
void set_aa_led(ubyte);
void set_ec_led(ubyte);

/* RJM040396 */
/* Host based Support */
void process_timers (void);

/* RJM040396 */
/* VCV Support */
void  gpio_hook_relay (ubyte state);
void  set_dsvd_relay (ubyte state);
void  set_cid_relay (ubyte state);
void  set_voice_relay (ubyte state);
void  set_spk_hs_relay (ubyte state);
ubyte get_phone_relay (void);
void  set_gpio_bit (uword *gpr, ubyte bit_location, ubyte state);
void  set_gpio_reg (uword *gpio_register, ubyte value);

/* RJM040396 */
/* Moved call_progress() from MT00CUST.C for Host based
   RING Detectandthese vars go with it.
*/
extern ubyte ring_on; /*22296shujin	*/
extern ubyte ring_was_on_before;

extern ubyte dsp_response_data[15];
extern ubyte fax_class;
extern ubyte do_it_once; /* ramn 7/9/96 */
extern osilating; /* ramn 9/26/96 */
ubyte dsp_acknowledge_packet(void);     
#define DCE_BUFFER_SIZE 512
extern ubyte dce_rx_buffer[DCE_BUFFER_SIZE];

/*mrm91896*/
/*dcd toggle for window application*/
ubyte dcd_toggle = 0;
extern ubyte handset_offhook_flag; /* ramn 10/25/96 */

#define   CID_RELAY_OFF  0x0200 			/* ramn 12/19/96 */
extern void	set_callerid_relay( uword);	/* ramn 12/19/96 */
void relay_init(void);
uword get_dsp_version(void);

#if INTERNATIONAL_CODE == 1
void set_safe1_en_relay( ubyte state);
void set_loc_line_relay( ubyte state);
void set_shunt_relay( ubyte state);
extern uword msec2_count;             // Finland only
extern const uword ringreport_delay;  // Finland only
extern ubyte delay_ring_report_flag1; // Finland only
#endif

/*******************************************************************************
/
/                    modem_rom_components
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will return a string which contains the
/                   modem part number, revision level, and hardware
/                   location of all ROM components.
/
/    Input Parameters:   None
/
/    Output Parameter:   *string
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  get_rom_components
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte *modem_rom_components(void)
{
    ubyte *temp;
    temp = rom_components();
    return(temp);
}

/*******************************************************************************
/
/                   "calc_rom_checksum"
/
/    Author:   RSA
/
/    Creation Date: 02/07/91
/
/    Description:   This routine will calculate and return the modem ROM
/              checksum.
/
/    Input Parameters:   None
/
/    Output Parameter:   rom_cs value
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_rom_checksum
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason
/
*******************************************************************************/
ubyte calc_rom_checksum(void)
{
   return (0x55);
}

/*******************************************************************************
/
/                   "set_hs_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   Sets the hs led to the desired state (on or off).
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_hs_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_hs_led(ubyte state)
{
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_HS_LED, GPIO_BIT_HS_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_HS_LED, GPIO_BIT_HS_LED, DEACTIVATE);
/*#else*/
#endif
}

/*******************************************************************************
/
/                   "set_aa_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the aa led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_aa_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_aa_led(ubyte state)
{
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_AA_LED, GPIO_BIT_AA_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_AA_LED, GPIO_BIT_AA_LED, DEACTIVATE);
#endif
}

/*******************************************************************************
/
/                   "set_ec_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the ec led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_ec_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_ec_led(ubyte state)
{
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_EC_LED, GPIO_BIT_EC_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_EC_LED, GPIO_BIT_EC_LED, DEACTIVATE);
#endif
}

/*******************************************************************************
/
/                   "set_dte_cts"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the CTS relay to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_dte_cts
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void set_dte_cts(ubyte state)
{
	ubyte *temp;
  
#if PARALLEL_MODE == 1
    if (state)
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
		*temp |=  CTS_ON;
	 }
	 else
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
		*temp &=  CTS_OFF; 
 	 }
#endif  

/*mrm5896*/

#if SERIAL_MODE == 1
    if (state)
	 {
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
		*temp =  CTS_ON; 

	 }
	 else
	 {
		temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
		*temp =  CTS_OFF; 
 	 }
#endif  
}

/******************************************************************************
/
/    Procedure: set_dte_dsr
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the DSR line depending
/              on the parameter passed in.
/
/    Input Parameters:
/                   0 - Raise DSR (off)
/                   1 - Lower DSR (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_dsr
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_dsr(ubyte state)
{
	ubyte *temp;

#if PARALLEL_MODE == 1
    if (state)
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
		*temp |=  DSR_ON;
	 }
	 else
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
		*temp &=  DSR_OFF; 
 	 }
#endif  /* ramn 2/5/96 */

#if SERIAL_MODE == 1
    if (state)
	 {
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
		*temp =  DSR_ON; 

	 }
	 else
	 {
		temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
		*temp =  DSR_OFF; 
 	 }
#endif  /* ramn 2/5/96 */
}

/******************************************************************************
/
/    Procedure: set_dte_ri
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the RI line depending on
/              the parameter passed in.
/
/    Input Parameters: 
/                   0 - Raise RI (off)
/                   1 - Lower RI (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_ri
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_ri(ubyte state)
{

}

/******************************************************************************
/
/    Procedure: set_dte_rlsd
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the RLSD line depending
/              on the parameter passed in.
/
/    Input Parameters:
/                   0 - Raise RLSD (off)
/                   1 - Lower RLSD (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_rlsd
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_rlsd(ubyte state)
{
	ubyte *temp;

#if PARALLEL_MODE == 1
    if (state)
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
		*temp |=  DCD_ON;
	 }
	 else
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 

			if (dcd_toggle)
			{
				*temp |=  DCD_ON;
				dcd_toggle = 0;
			}

		*temp &=  DCD_OFF; 
 	 }

#endif  /* ramn 2/5/96 */

#if SERIAL_MODE == 1
    if (state)
	 {
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
		*temp =  DCD_ON; 

	 }
	 else
	 {
		temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
		*temp =  DCD_OFF; 
 	 }
#endif  /* ramn 2/5/96 */
}

/******************************************************************************
/
/    Procedure: get_dte_CTS_status
/
/    Author: RSA
/
/    Creation Date: 10/28/91
/
/    Description: This routine will return the status of the CTS pin.
/
/    Input Parameters: none
/
/    Output Parameters:  D0 - Status of CTS pin:
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_CTS_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_CTS_status()
{
    
    ubyte status;
    status = ON;
    return status;
}

/******************************************************************************
/
/    Procedure: get_dte_RTS_status
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will return the status of the RTS pin.
/
/    Input Parameters: none
/
/    Output Parameters: Status of RTS pin
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_RTS_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_RTS_status()
{
    ubyte status;
    status = ON;
    return status;
}

/******************************************************************************
/
/    Procedure: get_dte_DTR_status
/
/    Author: RSA
/
/    Creation Date: 3/01/95
/
/    Description: This routine will return the status of the DTE pin.
/
/    Input Parameters: none
/
/    Output Parameters: 
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_DTR_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_DTR_status()
{
    ubyte status,dtr_stat;
    ubyte *temp;
    status = OFF;     

#if PARALLEL_MODE == 1
	temp = (ubyte *)(PARALLEL_16550_LOCATION + HMCR); 
	dtr_stat =  *temp;
	
	if(dtr_stat &= DTR_BAR_MASK)
		  status = ON;
    
#endif /* ramn 2/5/96 */

#if SERIAL_MODE == 1
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SECR); 
		dtr_stat = *temp; 

		if(dtr_stat &= DTR_BAR_MASK)
			status = ON;
#endif /* ramn 2/5/96 */

    return status;
}

/******************************************************************************
/
/    Procedure: rom_test
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will calculate the checksum for the entire ROM
/
/    Input Parameters: none
/
/    Output Parameters:1 if checksum is okay
/                        - 0 if checksum error occured
/
/    Global Variables Changed: none
/
/    Users: modem_rom_test
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte rom_test(void)
{
    return (1);     
}

/******************************************************************************
/
/    Procedure: ram_test
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will test the modem's ram
/
/    Input Parameters: none
/
/    Output Parameters:  = 0 = Fail
/                        = 1 = Pass
/
/    Global Variables Changed: none
/
/    Users: modem_ram_test
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte ram_test(void)
{
    return (1);     
}

/*
|---------------------------------------------------------------------------
|
| dspdrv_WriteCram() - writes data into CommRam
|
|---------------------------------------------------------------------------
| PURPOSE:
|         Places a packet into the Tx CommRam. 
|
| PARAMETERS:
|   <or INPUTS>
|
| RETURN VALUE:
|   <or OUTPUTS UPON EXIT>
|
| NOTES:
|   <indicate any restrictions or dependencies>
|
|
|
*/

void dspdrv_WriteCram(int addr, ubyte *data, int len)
{
	
	ubyte i;
	ubyte *dest; 
	
	dest = (ubyte *) COM_RAM;

	/* set to end of data packet */
	dest += addr;

   for (i=0;i<len;i++) {
		*dest++ = *data++;
		/* 
		dest +=4;
		*/
	}


}


/*
|---------------------------------------------------------------------------
|
| dspdrv_ReadCram() - read data from CommRam
|
|---------------------------------------------------------------------------
| PURPOSE:
|         Gets a packet from Rx CommRam.
|
| PARAMETERS:
|   <or INPUTS>
|
| RETURN VALUE:
|   <or OUTPUTS UPON EXIT>
|
| NOTES:
|   <indicate any restrictions or dependencies>
|
|
|
*/

void dspdrv_ReadCram(int addr, ubyte *data, int len)
{

   ubyte i;
   ubyte *src; 
		
   src = (ubyte *) COM_RAM;

   /* set to end of data packet */
   src += addr;

   for (i=0;i<len;i++) {
	 *data++ = *src++;
	/* 
	src += 4;
	*/
   }

}

void dspdrv_ReadCram_buffer(int addr, ubyte *data, int len)
{

   ubyte i;
   ubyte *src; 
   ubyte *ptr;
   /*disable_int();*/
   ptr = (ubyte *)(&dce_rx_buffer) + DCE_BUFFER_SIZE;

   src = (ubyte *) COM_RAM;

   /* set to end of data packet */
   src += addr;

   for (i=0;i<len;i++) {
	 *data++ = *src++;
	 /*src += 4;*/
	 if (data == ptr)
		data =  (ubyte *)(&dce_rx_buffer);
   }

}

void issue_debug_callback (void)
{
}

ubyte cp_dsp(void)
{    
	ubyte *temp, byte_count,i;
	
	byte_count = 0;
	
	
	temp = (ubyte *)(COM_RAM + (CP_DSP_CMD_START * WORD_OR_BYTE_ADD_INC)); 

	
	if (*temp == 0)
	{
		
		temp = temp + WORD_OR_BYTE_ADD_INC;     
		
		/*write the filler + packet_length + filler byte to com_ram*/
		
		for (i = 1 ; i < 4 ; i++)
		{
			*temp = current_command[i];
			temp = temp + WORD_OR_BYTE_ADD_INC;
		}
		
		/*if packet_length is > zero then the data should follow */
		
		if (current_command[2] > 0 )
		{
			byte_count = current_command[2];
			
			for (i = 4 ; i < byte_count + 4 ; i++)
			{
				*temp = current_command[i];
				temp = temp + WORD_OR_BYTE_ADD_INC;
			}
			
			
		 }
		 /*MRM73195*/
		 /*If the number of bytes are odd add a filler byte*/
		 if (current_command[2] % 2 )               
		 { 
			*temp = 0x00;
		 }

		
		/*write the semaphore*/
		
		temp = (ubyte *) (COM_RAM + (CP_DSP_CMD_START * WORD_OR_BYTE_ADD_INC));

		*temp = current_command[0];
		
		/*
		  Write dummy 00 to location 0xFE byte or 0x3F8 word aligned 
		  inorder to notify the dsp to read the CP->DSP mail box 
		*/  
		
		temp = (ubyte *) (COM_RAM + (CP_DSP_INT * WORD_OR_BYTE_ADD_INC));

		
		*temp = 0x00;

		return (1);
	}
	else
	{
	 return (0);
	}
}

ubyte dsp_cp (void)
{    
	
	ubyte *temp, byte_count, i;
	
	byte_count = 0;
	
	
	temp = (ubyte *)(COM_RAM + (DSP_CP_CMD_START * WORD_OR_BYTE_ADD_INC)); 

	
	if (*temp == dsp_cp_packet)
	{
		/*advance the address to the length byte*/
		temp = temp + (WORD_OR_BYTE_ADD_INC * 2);     
		
		/*if packet_length is > zero then the data should follow */
		
		if (*temp > 0 )
		{
			byte_count = *temp;
			
			/*MRM82595*/
			/*
			If the response is more than one byte this routine must to
			modified for the multible returns
			*/

			temp = temp + (WORD_OR_BYTE_ADD_INC * 2);     
			
			for (i = 0 ; i < byte_count ; i++)
			{
				
				dsp_response_data [i] = *temp;
				temp = temp + WORD_OR_BYTE_ADD_INC;
			}
			
		 }

		
		/*write the semaphore*/
		
		temp = (ubyte *) (COM_RAM + (DSP_CP_CMD_START * WORD_OR_BYTE_ADD_INC));

		*temp = 00;
		return(1);
	}
	else
	{
		return (0);     
	}
}

void fatal_error( ubyte error )
{
   while(1);
}

/* RJM040396 */
/* VCV Support to File end */
/*************************************
   Timer Support
**************************************/
void process_timers (void)
{
  process_wait ();
}

/*************************************
   GPIO control for Modem Task
**************************************/
/*******************************************************************************
/
/    Procedure:     set_voice_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of voice relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_voice_relay (ubyte state)
{
  if(state )
      set_gpio_bit ((uword *) GPR_VOICE_RELAY, GPIO_BIT_VOICE_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_VOICE_RELAY, GPIO_BIT_VOICE_RELAY, DEACTIVATE);
}


/*******************************************************************************
/
/    Procedure:     set_cid_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of
/                   caller ID relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_cid_relay (ubyte state)
{
  if( state )
      set_gpio_bit ((uword *) GPR_CID_RELAY, GPIO_BIT_CID_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_CID_RELAY, GPIO_BIT_CID_RELAY, DEACTIVATE);
}


/*******************************************************************************
/
/    Procedure:     set_dsvd_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of DSVD relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_dsvd_relay (ubyte state)
{
  if( state )
      set_gpio_bit ((uword *) GPR_DSVD_RELAY, GPIO_BIT_DSVD_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_DSVD_RELAY, GPIO_BIT_DSVD_RELAY, DEACTIVATE);
}

/*******************************************************************************
/
/    Procedure:     set_hook_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of hook relay.
/                   This method bypasses the Cutlass chip and uses Musket to
/                   directly access its hook GPIO pin, instead of sending
/                   a PACKET_MODEM_HOOK_RELAY to Cutlass.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_hook_relay (ubyte state)
{
	/*
		if ring is on do not go off hook, wait for ring to go away then go off 
		hook. 
		value 2 is really RINGON .
		ramn 9/26/96 

	*/
   while (osilating)
		process_wait();

  if( state )
      set_gpio_bit ((uword *) GPR_HOOK_RELAY, GPIO_BIT_HOOK_RELAY, ACTIVATE);
  else
  {
      set_gpio_bit ((uword *) GPR_HOOK_RELAY, GPIO_BIT_HOOK_RELAY, DEACTIVATE);

/* this is flag used to set when we go offhook for dialing invoice mode
	need to reset it here */

		do_it_once = FALSE;  /* ramn 9/23/96 */
		handset_offhook_flag = FALSE;		/* ramn 10/25/96 */
	/*
		when hanging up make sure that the callerid relay is also off
		This may be needed if +VCID=1 and some how call answered on first
		ring
	*/
	set_callerid_relay( CID_RELAY_OFF);	/* ramn 12/19/96 */
  }	
}

/*******************************************************************************
/
/    Procedure:     get_hook_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine returns the status of
/                   Hook Relay.
/
/    Input Parameters:   None
/
/    Output Parameter:   ubyte - OHREL state (ON, OFF)
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_hook_relay (void)
{
  uword gpio_state, *reg;
  uword mask;

  /* 1st read the state of the register that contains HOOK relay */
  reg = (uword *) GPR_HOOK_RELAY;
  gpio_state = (uword) *reg;
  mask = (1 << GPIO_BIT_HOOK_RELAY);

  /* If HOOK bit is set, return OFF */
  if (gpio_state & mask)
    return 0;
  else
    return 1;
}

/*******************************************************************************
/
/    Procedure:     get_phone_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine returns the status of
/                   Local Phone Off Hook Detect.
/
/    Input Parameters:   None
/
/    Output Parameter:   ubyte - LPOHD state (ON, OFF, UNDETERMINED)
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_phone_relay (void)
{
  uword gpio_state, *reg;
  uword mask;

  /* First read the state of the register that contains LPOHD
     (local phone off-hook detect). */
  reg = (uword *) GPR_PHONE_RELAY;
  gpio_state = (uword) *reg;
  mask = (1 << GPIO_BIT_LOCAL_PHONE_RELAY);

  /* If LPOHD bit is set, return ON */
/*rjmw95*/

  if (gpio_state & mask)
  {
     phone_relay_timer = 0;
     return 0;
  }
  else
  {
     /*  debounce for 100ms -- incoming ring falsely triggers phone relay  */
     if (phone_relay_timer ==  0)
     {
        phone_relay_timer = 11;
        return (0);
     }
     else
     {
        if (phone_relay_timer == 1)
           return 1;
        else
           return 0;
     }
  }
}

/****************************************************************************
 *
 *   Routine:           set_spk_hs_relay()
 *
 *   Author:            RSA
 *
 *   Creation Data:     17/2/1996
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/
void set_spk_hs_relay( ubyte state)
{
	if(fax_class == 8)	/* added by ramn on 5/31/96 */
	{
	   if( state )
   	   set_gpio_bit ((uword *)GPR_SPK_HS_RELAY, GPIO_BIT_SPK_HS_RELAY, ACTIVATE);
	   else
   	   set_gpio_bit ((uword *)GPR_SPK_HS_RELAY, GPIO_BIT_SPK_HS_RELAY, DEACTIVATE);
	}
}

/****************************************************************************
 *
 *   Routine:           set_safe1_en_relay()
 *
 *   Author:            MH
 *
 *   Creation Data:     16/9/1997
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 ****************************************************************************/
void set_safe1_en_relay( ubyte state)
{
   if( state )
 	   set_gpio_bit ((uword *)GPR_SAFE1_EN_RELAY, GPIO_BIT_SAFE1_EN_RELAY, ACTIVATE);
   else
 	   set_gpio_bit ((uword *)GPR_SAFE1_EN_RELAY, GPIO_BIT_SAFE1_EN_RELAY, DEACTIVATE);
}

/****************************************************************************
 *
 *   Routine:           set_loc_line_relay()
 *
 *   Author:            MH
 *
 *   Creation Data:     16/9/1997
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 ****************************************************************************/
#if INTERNATIONAL_CODE == 1
void set_loc_line_relay( ubyte state)
  {
	   if( state )
   	   set_gpio_bit ((uword *)GPR_LOC_LINE_RELAY, GPIO_BIT_LOC_LINE_RELAY, ACTIVATE);
	   else
   	   set_gpio_bit ((uword *)GPR_LOC_LINE_RELAY, GPIO_BIT_LOC_LINE_RELAY, DEACTIVATE);
  }
#endif
/****************************************************************************
 *
 *   Routine:           set_shunt_relay()
 *
 *   Author:            MH
 *
 *   Creation Data:     16/9/1997
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 ****************************************************************************/
#if INTERNATIONAL_CODE == 1
void set_shunt_relay( ubyte state)
  {
	   if( state )
   	   set_gpio_bit ((uword *)GPR_SHUNT_RELAY, GPIO_BIT_SHUNT_RELAY, ACTIVATE);
	   else
   	   set_gpio_bit ((uword *)GPR_SHUNT_RELAY, GPIO_BIT_SHUNT_RELAY, DEACTIVATE);
  }
#endif
/* MH092397 till here */

/*******************************************************************************
/
/    Procedure:     set_gpio_bit
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets or clears the state of the selected
/                   GPIO pin (SINGLE BIT) on the selected GPIO register.
/                   Changing the bit requires also setting its mask bit to 1.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/                      ubyte bit_location - Which bit to change in the
/                        register specified by *gpr.
/
/                      ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
/*-------------------------------------------------------------------

   GPR0, GPCR0 contains GPIO pins 0-7
   GPR1, GPCR1 contains GPIO pins 8-15
   GPR2, GPCR2 contains GPIO pins 16-23

   Each GPR register is 16 bits wide, with alternating sequences
   of 4 mask bits and 4 GPIO bits, as shown below for GPR0:

   15 14 13 12  11 10 09 08   07 06 05 04  03 02 01 00
   M3 M2 M1 M0  G7 G6 G5 G4   M3 M2 M1 M0  G3 G2 G1 G0

   When writing to the GPR register, only those GPIO bits whose
   corresponding Mask bits are 1 will be affected.

   To set,   write 1 to the pin's bit and 1 to its mask bit.
   To clear, write 0 to the pin's bit and 1 to its mask bit.

   GPPFR (GPIO Pin Function Register) contains only 6 bits with
   no mask bits, so it can be set like a normal register.

------------------------------------------------------------------ */
void set_gpio_bit (uword *gpr, ubyte bit_location, ubyte state)
{
  uword gpio_snapshot, new_bitmask;

  /* First read the state of the selected register.
     gpr points to the actual on-chip memory address of the register. */
  gpio_snapshot = (uword) *gpr;

  /* Set the mask bit that corresponds to the selected GPIO pin.
     Its mask bit location is 4 bits to the left of the GPIO bit. */
  gpio_snapshot |= (1 << (bit_location + 4));

  /* Set or clear the GPIO bit based on the requested state */
  new_bitmask = (1 << bit_location);

  if (state)
    gpio_snapshot |= new_bitmask;
  else
    gpio_snapshot &= ~new_bitmask;

  /* Now write the new word to the GPIO register */
  *gpr = (uword) gpio_snapshot;
}

/*******************************************************************************
/
/    Procedure:     set_gpio_reg
/
/    Author:   RSA
/
/    Creation Date: 1/5/96
/
/    Description:   This routine sets the value of the selected GPIO register.
/                   For GPR and GPCR registers, it formats the bits to match
/                   the register definition.  For GPPFR, it just writes the
/                   new value to the register.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/                      ubyte value - Value to write to GPIO register
/                        specified by *gpr.
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_gpio_reg (uword *gpio_register, ubyte value)
{
  uword new_bitmask;

  /* GPPFR register is 8 bits, but the other GPIO registers are
     16 bits with mask bits.  If not the GPPFR, then format the
     register value accordingly. */
  if (gpio_register != (uword *) GPPFR)
  {
    /* First create the register word based on the requested pin value.
       The word format is:  M7 M6 M5 M4 G7 G6 G5 G4   M3 M2 M1 M0 G3 G2 G1 G0

       GPIO pins 0-3 are represented in the lower nibble of the pin value byte
       GPIO pins 4-7 are represented in the high nibble of the pin value byte
    */
    new_bitmask = (value & 0xF0);  /* Set low byte to GPIO pins 4-7 */
    new_bitmask <<= 4;             /* Shift value into high byte / low nibble */
    new_bitmask |= (value & 0x0F); /* OR in GPIO pins 0-3 into low byte */
    new_bitmask |= 0xF0F0;         /* Set all mask bits to 1 to enable change */

    /* Write the new register value to the register memory address */
    *gpio_register = new_bitmask;
  }

  /* For GPPFR, just write the ubyte bitmask passed in */
  else
  {
    *gpio_register = value;
  }
}

/*******************************************************************************
/
/    Procedure:     get_gpio_reg
/
/    Author:   RSA
/
/    Creation Date: 1/5/96
/
/    Description:   This routine returns the value of the selected GPIO register.
/                   For GPR and GPCR registers, it removes the mask bits and
/                   formats the return byte as GPIO pins 0-7 in bits 0-7.
/                   For GPPFR, it just returns the current value.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/    Output Parameter:   ubyte - Value of selected register
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_gpio_reg (uword *gpio_register)
{
  /* GPPFR register is 8 bits, but the other GPIO registers are
     16 bits with mask bits.  If not the GPPFR, then format the
     register value accordingly. */
  if (gpio_register != (uword *) GPPFR)
  {
    uword gpio_state;
    ubyte gpio_pins_lower, gpio_pins_upper;

    gpio_state = (uword) *gpio_register;
    gpio_pins_lower = gpio_state & 0x000F;        /* Low byte to low nibble */
    gpio_pins_upper = (gpio_state & 0x0F00) >> 4; /* High byte to high nibble */
    return (gpio_pins_lower | gpio_pins_upper);
  }

  else
  {
    uword *gppfr;

    gppfr = (uword *) GPPFR;
    return ((ubyte) *gppfr);
  }
}

/* RJM040396 */
/* Moved from MT00CUST.C for Host based support */
/*******************************************************************************
/
/                                  call_progress
/
/       Author:         RSA
/
/       Creation Date:  03/01/94
/
/       Description:    This routine will return the progress of the calling
/                       sequence.  USA only
/
/       Input Parameters:       None
/
/       Output Parameter:       0 - undetermined
/                               1 - dial tone
/                               2 - ring on
/                               3 - busy
/                               4 - silence
/                               5 - ring back
/                               6 - answer tone
/                               7 - ring off
/
/       Global Variables Changed:
/
/       Users: (routines that used this)  modem_call_progress
/
/       *****************************************************************
/       *                         Modifications                         *
/       *****************************************************************
/
/       Author & Date:
/       Description:
/       Reason:
/
*******************************************************************************/
/*22296shujin, for distinctive ring */
ubyte call_progress(void)
{
   ubyte tmp;
	ubyte *string; // debug Finland.
//	static DelayedRing_Status;

//	DelayedRing_Status = UNDETERMINED;
   tmp = read_dsp_call_progress_reg();

#if INTERNATIONAL_CODE == 1
	if(ring_on /* && hook*/ && (delay_ring_report_flag1 == 0 ))
	{
		delay_ring_report_flag1 = 1;
	   //For other countries we may set ringreport_delay to 0.
	    if(country_area_code1 == Finland_a_code1)
		{
			msec2_count = ringreport_delay; // for one second delay set to 1000
		}
		else
		{
			msec2_count = 0;
		}
										// set value to 0 for no delay.
		tmp = UNDETERMINED;
  		return tmp;
	}
	else if(/* hook && */ (msec2_count == 0) &&
		(delay_ring_report_flag1 == 1))
	{
		delay_ring_report_flag1 = 2;
		return RING_ON;
	}
#else
	if ( ring_on )
	{
//	   ringStatus = RING_ON;
      tmp = RING_ON;
	 	return tmp;
	}
#endif

	else if ( (ring_on==FALSE) && (ring_was_on_before == TRUE)	)
	{
#if INTERNATIONAL_CODE == 1
		delay_ring_report_flag1 = 0;
#endif
      tmp = RING_OFF;
//      ringStatus = UNDETERMINED;
	 	return tmp;
	}
	else
   {
		if(tmp== RING_ON || tmp==RING_OFF)
		   tmp = UNDETERMINED;

//      ringStatus = UNDETERMINED;
  		return tmp;
	}
}

/* added by ramn on 4/16/96 */
/* these routines were added in accordance to the new modem task 
	done by Rob miller */

void dsp_reset( ubyte state)
{
   if( state )
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, DEACTIVATE);
   else
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, ACTIVATE);
}

void dsp_cfg( ubyte state)
{
   if( state )
      set_gpio_bit ((uword *)GPR_DSP_CFG_RELAY, GPIO_BIT_DSP_CFG_RELAY, DEACTIVATE);
   else
      set_gpio_bit ((uword *)GPR_DSP_CFG_RELAY, GPIO_BIT_DSP_CFG_RELAY, ACTIVATE);
}


/*** till here by ramn *****/

/* RJM052996 */
/* Beta App support */
void set_register(ubyte addr, ubyte data)
{
  ubyte *temp;

  temp = (ubyte *)(COM_RAM + (addr * WORD_OR_BYTE_ADD_INC));
  *temp = data;
}

ubyte get_register(ubyte addr)
{
  ubyte *temp;

  temp = (ubyte *)(COM_RAM + (addr * WORD_OR_BYTE_ADD_INC));
  return (*temp);
}

void relay_init(void) 
{
#if INTERNATIONAL_CODE == 1     
     set_loc_line_relay(ON_HOOK);
	  set_shunt_relay(ACTIVATE);
     set_safe1_en_relay(ACTIVATE);	/* mh110597 output = HI */
#else
     set_safe1_en_relay(ACTIVATE);	/* mh110597 output = HI */
#endif
}

uword get_dsp_version(void)
{
   LOAD_MODEM_GET_VERSION
   dsp_cp_packet = PACKET_DP_VERSION_INFO;          

   ack_or_response = RESPONSE;
   send_pkt_to_dsp();
   return ( (uword)(dsp_response_data[2] << 8) |
            (uword) dsp_response_data[0]);
}

