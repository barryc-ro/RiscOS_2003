/******************************************************************************
/
/     Copyright, 1988, 1989, 1990, 1991, 1992, 1993, 1994. All Rights Reserved by:
/     Cirrus Logic, Inc.
/
******************************************************************************/
#include "mod_def.h" /* ramn 2/5/96 */
#include  "SYS_DEF.H"
#include  "cp_dsp.h"
#include  "MT_CODEF.H"
#include  "MT_HWDEF.H"
#include  "MT_COPRO.H"
#include  "MT_HWPRO.H"
#include  "MT_COEXT.H"
#include  "mt_macro.h" 
#include "dte_drv.h"
#include "tracemac.h"
#include "bldflags.h"
#include  "resp_cod.h"
#include  "acu_pro.h"
#include "lineequ.h"
#include "mt_gpio.h"
#include "ee_def.h"
#include "homolig1.h"

#define VOC_RELAY_OFF_HOOK        0x1000
#define VOC_RELAY_ON_HOOK         0x1100
#define OH_RELAY_OFF_HOOK        0x0080
#define OH_RELAY_ON_HOOK        0x0088

ubyte *rom_components(void);
ubyte *capability_descript(void);
ubyte read_dipswitch(void);
ubyte write_eeprom_data(uword, uword, ubyte *);
ubyte read_eeprom_data(uword, uword, ubyte *);
ubyte calc_eeprom_checksum(void);
ubyte calc_rom_checksum(void);
void set_hs_led(ubyte);
void set_dte_cts(ubyte);
void set_aa_led(ubyte);
void set_ec_led(ubyte);
extern ubyte CountryInfo;            /* MH102397 */
extern ubyte shunt_timer_en;    
extern ubyte shunt_timer;        /* MH110697 */

/* RJM040396 */
/* Host based Support */
void process_timers (void);

/* RJM040396 */
/* VCV Support */
void  gpio_hook_relay (ubyte state);
void  set_dsvd_relay (ubyte state);
void  set_cid_relay (ubyte state);
void  set_voice_relay (ubyte state);
void  set_spk_hs_relay (ubyte state);
ubyte get_phone_relay (void);
void  set_gpio_bit (uword *gpr, ubyte bit_location, ubyte state);
void  set_gpio_reg (uword *gpio_register, ubyte value);

/* RJM040396 */
/* Moved call_progress() from MT00CUST.C for Host based
   RING Detectandthese vars go with it.
*/
extern ubyte ring_on; /*22296shujin    */
extern ubyte ring_was_on_before;

extern ubyte dsp_response_data[15];
extern ubyte fax_class;
extern ubyte do_it_once; /* ramn 7/9/96 */
extern osilating; /* ramn 9/26/96 */
ubyte dsp_acknowledge_packet(void);     
#define DCE_BUFFER_SIZE 512
extern ubyte dce_rx_buffer[DCE_BUFFER_SIZE];

/*mrm91896*/
/*dcd toggle for window application*/
ubyte dcd_toggle = 0;
extern ubyte handset_offhook_flag; /* ramn 10/25/96 */

#define   CID_RELAY_OFF  0x0200             /* ramn 12/19/96 */
extern void    set_callerid_relay( uword);    /* ramn 12/19/96 */
void relay_init(void);
uword get_dsp_version(void);

#if INTERNATIONAL_CODE == 1
void set_safe1_en_relay( ubyte state);
void set_loc_line_relay( ubyte state);
void set_shunt_relay( ubyte state);
#endif

/*******************************************************************************
/
/                    modem_rom_components
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will return a string which contains the
/                   modem part number, revision level, and hardware
/                   location of all ROM components.
/
/    Input Parameters:   None
/
/    Output Parameter:   *string
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  get_rom_components
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte *modem_rom_components(void)
{
    ubyte *temp;
    temp = rom_components();
    return(temp);
}

/*******************************************************************************
/
/                   "calc_rom_checksum"
/
/    Author:   RSA
/
/    Creation Date: 02/07/91
/
/    Description:   This routine will calculate and return the modem ROM
/              checksum.
/
/    Input Parameters:   None
/
/    Output Parameter:   rom_cs value
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_rom_checksum
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason
/
*******************************************************************************/
ubyte calc_rom_checksum(void)
{
   return (0x55);
}

/*******************************************************************************
/
/                   "set_hs_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   Sets the hs led to the desired state (on or off).
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_hs_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_hs_led(ubyte state)
{
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_HS_LED, GPIO_BIT_HS_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_HS_LED, GPIO_BIT_HS_LED, DEACTIVATE);
/*#else*/
#endif
}

/*******************************************************************************
/
/                   "set_aa_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the aa led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_aa_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_aa_led(ubyte state)
{
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_AA_LED, GPIO_BIT_AA_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_AA_LED, GPIO_BIT_AA_LED, DEACTIVATE);
#endif
}

/*******************************************************************************
/
/                   "set_ec_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the ec led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_ec_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_ec_led(ubyte state)
{
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_EC_LED, GPIO_BIT_EC_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_EC_LED, GPIO_BIT_EC_LED, DEACTIVATE);
#endif
}

/*******************************************************************************
/
/                   "set_dte_cts"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the CTS relay to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_dte_cts
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void set_dte_cts(ubyte state)
{
    ubyte *temp;
  
#if PARALLEL_MODE == 1
    if (state)
     {
        temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
        *temp |=  CTS_ON;
     }
     else
     {
        temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
        *temp &=  CTS_OFF; 
      }
#endif  

/*mrm5896*/

#if SERIAL_MODE == 1
    if (state)
     {
         temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
        *temp =  CTS_ON; 

     }
     else
     {
        temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
        *temp =  CTS_OFF; 
      }
#endif  
}

/******************************************************************************
/
/    Procedure: set_dte_dsr
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the DSR line depending
/              on the parameter passed in.
/
/    Input Parameters:
/                   0 - Raise DSR (off)
/                   1 - Lower DSR (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_dsr
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_dsr(ubyte state)
{
    ubyte *temp;

#if PARALLEL_MODE == 1
    if (state)
     {
        temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
        *temp |=  DSR_ON;
     }
     else
     {
        temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
        *temp &=  DSR_OFF; 
      }
#endif  /* ramn 2/5/96 */

#if SERIAL_MODE == 1
    if (state)
     {
         temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
        *temp =  DSR_ON; 

     }
     else
     {
        temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
        *temp =  DSR_OFF; 
      }
#endif  /* ramn 2/5/96 */
}

/******************************************************************************
/
/    Procedure: set_dte_ri
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the RI line depending on
/              the parameter passed in.
/
/    Input Parameters: 
/                   0 - Raise RI (off)
/                   1 - Lower RI (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_ri
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_ri(ubyte state)
{

}

/******************************************************************************
/
/    Procedure: set_dte_rlsd
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the RLSD line depending
/              on the parameter passed in.
/
/    Input Parameters:
/                   0 - Raise RLSD (off)
/                   1 - Lower RLSD (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_rlsd
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_rlsd(ubyte state)
{
    ubyte *temp;

#if PARALLEL_MODE == 1
    if (state)
     {
        temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 
        *temp |=  DCD_ON;
     }
     else
     {
        temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR); 

            if (dcd_toggle)
            {
                *temp |=  DCD_ON;
                dcd_toggle = 0;
            }

        *temp &=  DCD_OFF; 
      }

#endif  /* ramn 2/5/96 */

#if SERIAL_MODE == 1
    if (state)
     {
         temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
        *temp =  DCD_ON; 

     }
     else
     {
        temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR); 
        *temp =  DCD_OFF; 
      }
#endif  /* ramn 2/5/96 */
}

/******************************************************************************
/
/    Procedure: get_dte_CTS_status
/
/    Author: RSA
/
/    Creation Date: 10/28/91
/
/    Description: This routine will return the status of the CTS pin.
/
/    Input Parameters: none
/
/    Output Parameters:  D0 - Status of CTS pin:
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_CTS_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_CTS_status()
{
    
    ubyte status;
    status = ON;
    return status;
}

/******************************************************************************
/
/    Procedure: get_dte_RTS_status
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will return the status of the RTS pin.
/
/    Input Parameters: none
/
/    Output Parameters: Status of RTS pin
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_RTS_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_RTS_status()
{
    ubyte status;
    status = ON;
    return status;
}

/******************************************************************************
/
/    Procedure: get_dte_DTR_status
/
/    Author: RSA
/
/    Creation Date: 3/01/95
/
/    Description: This routine will return the status of the DTE pin.
/
/    Input Parameters: none
/
/    Output Parameters: 
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_DTR_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_DTR_status()
{
    ubyte status,dtr_stat;
    ubyte *temp;
    status = OFF;     

#if PARALLEL_MODE == 1
    temp = (ubyte *)(PARALLEL_16550_LOCATION + HMCR); 
    dtr_stat =  *temp;
    
    if(dtr_stat &= DTR_BAR_MASK)
          status = ON;
    
#endif /* ramn 2/5/96 */

#if SERIAL_MODE == 1
         temp = (ubyte *)(SERIAL_UART_LOCATION + SECR); 
        dtr_stat = *temp; 

        if(dtr_stat &= DTR_BAR_MASK)
            status = ON;
#endif /* ramn 2/5/96 */

    return status;
}

/******************************************************************************
/
/    Procedure: rom_test
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will calculate the checksum for the entire ROM
/
/    Input Parameters: none
/
/    Output Parameters:1 if checksum is okay
/                        - 0 if checksum error occured
/
/    Global Variables Changed: none
/
/    Users: modem_rom_test
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte rom_test(void)
{
    return (1);     
}

/******************************************************************************
/
/    Procedure: ram_test
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will test the modem's ram
/
/    Input Parameters: none
/
/    Output Parameters:  = 0 = Fail
/                        = 1 = Pass
/
/    Global Variables Changed: none
/
/    Users: modem_ram_test
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte ram_test(void)
{
    return (1);     
}

/*
|---------------------------------------------------------------------------
|
| dspdrv_WriteCram() - writes data into CommRam
|
|---------------------------------------------------------------------------
| PURPOSE:
|         Places a packet into the Tx CommRam. 
|
| PARAMETERS:
|   <or INPUTS>
|
| RETURN VALUE:
|   <or OUTPUTS UPON EXIT>
|
| NOTES:
|   <indicate any restrictions or dependencies>
|
|
|
*/

void dspdrv_WriteCram(int addr, ubyte *data, int len)
{
    
    ubyte i;
    ubyte *dest; 
    
    dest = (ubyte *) COM_RAM;

    /* set to end of data packet */
    dest += addr;

   for (i=0;i<len;i++) {
        *dest++ = *data++;
        /* 
        dest +=4;
        */
    }


}


/*
|---------------------------------------------------------------------------
|
| dspdrv_ReadCram() - read data from CommRam
|
|---------------------------------------------------------------------------
| PURPOSE:
|         Gets a packet from Rx CommRam.
|
| PARAMETERS:
|   <or INPUTS>
|
| RETURN VALUE:
|   <or OUTPUTS UPON EXIT>
|
| NOTES:
|   <indicate any restrictions or dependencies>
|
|
|
*/

void dspdrv_ReadCram(int addr, ubyte *data, int len)
{

   ubyte i;
   ubyte *src; 
        
   src = (ubyte *) COM_RAM;

   /* set to end of data packet */
   src += addr;

   for (i=0;i<len;i++) {
     *data++ = *src++;
    /* 
    src += 4;
    */
   }

}

void dspdrv_ReadCram_buffer(int addr, ubyte *data, int len)
{

   ubyte i;
   ubyte *src; 
   ubyte *ptr;
   /*disable_int();*/
   ptr = (ubyte *)(&dce_rx_buffer) + DCE_BUFFER_SIZE;

   src = (ubyte *) COM_RAM;

   /* set to end of data packet */
   src += addr;

   for (i=0;i<len;i++) {
     *data++ = *src++;
     /*src += 4;*/
     if (data == ptr)
        data =  (ubyte *)(&dce_rx_buffer);
   }

}

void issue_debug_callback (void)
{
}

ubyte cp_dsp(void)
{    
    ubyte *temp, byte_count,i;
    
    byte_count = 0;
    
    
    temp = (ubyte *)(COM_RAM + (CP_DSP_CMD_START * WORD_OR_BYTE_ADD_INC)); 

    
    if (*temp == 0)
    {
        
        temp = temp + WORD_OR_BYTE_ADD_INC;     
        
        /*write the filler + packet_length + filler byte to com_ram*/
        
        for (i = 1 ; i < 4 ; i++)
        {
            *temp = current_command[i];
            temp = temp + WORD_OR_BYTE_ADD_INC;
        }
        
        /*if packet_length is > zero then the data should follow */
        
        if (current_command[2] > 0 )
        {
            byte_count = current_command[2];
            
            for (i = 4 ; i < byte_count + 4 ; i++)
            {
                *temp = current_command[i];
                temp = temp + WORD_OR_BYTE_ADD_INC;
            }
            
            
         }
         /*MRM73195*/
         /*If the number of bytes are odd add a filler byte*/
         if (current_command[2] % 2 )               
         { 
            *temp = 0x00;
         }

        
        /*write the semaphore*/
        
        temp = (ubyte *) (COM_RAM + (CP_DSP_CMD_START * WORD_OR_BYTE_ADD_INC));

        *temp = current_command[0];
        
        /*
          Write dummy 00 to location 0xFE byte or 0x3F8 word aligned 
          inorder to notify the dsp to read the CP->DSP mail box 
        */  
        
        temp = (ubyte *) (COM_RAM + (CP_DSP_INT * WORD_OR_BYTE_ADD_INC));

        
        *temp = 0x00;

        return (1);
    }
    else
    {
     return (0);
    }
}

ubyte dsp_cp (void)
{    
    
    ubyte *temp, byte_count, i;
    
    byte_count = 0;
    
    
    temp = (ubyte *)(COM_RAM + (DSP_CP_CMD_START * WORD_OR_BYTE_ADD_INC)); 

    
    if (*temp == dsp_cp_packet)
    {
        /*advance the address to the length byte*/
        temp = temp + (WORD_OR_BYTE_ADD_INC * 2);     
        
        /*if packet_length is > zero then the data should follow */
        
        if (*temp > 0 )
        {
            byte_count = *temp;
            
            /*MRM82595*/
            /*
            If the response is more than one byte this routine must to
            modified for the multible returns
            */

            temp = temp + (WORD_OR_BYTE_ADD_INC * 2);     
            
            for (i = 0 ; i < byte_count ; i++)
            {
                
                dsp_response_data [i] = *temp;
                temp = temp + WORD_OR_BYTE_ADD_INC;
            }
            
         }

        
        /*write the semaphore*/
        
        temp = (ubyte *) (COM_RAM + (DSP_CP_CMD_START * WORD_OR_BYTE_ADD_INC));

        *temp = 00;
        return(1);
    }
    else
    {
        return (0);     
    }
}

void fatal_error( ubyte error )
{
   while(1);
}

/* RJM040396 */
/* VCV Support to File end */
/*************************************
   Timer Support
**************************************/
void process_timers (void)
{
  process_wait ();
}

/*************************************
   GPIO control for Modem Task
**************************************/
/*******************************************************************************
/
/    Procedure:     set_voice_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of voice relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_voice_relay (ubyte state)
{
  if(state )
      set_gpio_bit ((uword *) GPR_VOICE_RELAY, GPIO_BIT_VOICE_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_VOICE_RELAY, GPIO_BIT_VOICE_RELAY, DEACTIVATE);
}


/*******************************************************************************
/
/    Procedure:     set_cid_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of
/                   caller ID relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_cid_relay (ubyte state)
{
  if( state )
      set_gpio_bit ((uword *) GPR_CID_RELAY, GPIO_BIT_CID_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_CID_RELAY, GPIO_BIT_CID_RELAY, DEACTIVATE);
}


/*******************************************************************************
/
/    Procedure:     set_dsvd_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of DSVD relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_dsvd_relay (ubyte state)
{
  if( state )
      set_gpio_bit ((uword *) GPR_DSVD_RELAY, GPIO_BIT_DSVD_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_DSVD_RELAY, GPIO_BIT_DSVD_RELAY, DEACTIVATE);
}

/*******************************************************************************
/
/    Procedure:     set_hook_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of hook relay.
/                   This method bypasses the Cutlass chip and uses Musket to
/                   directly access its hook GPIO pin, instead of sending
/                   a PACKET_MODEM_HOOK_RELAY to Cutlass.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_hook_relay (ubyte state)
{
    /*
        if ring is on do not go off hook, wait for ring to go away then go off 
        hook. 
        value 2 is really RINGON .
        ramn 9/26/96 

    */
   while (osilating)
        process_wait();

  if( state )
      set_gpio_bit ((uword *) GPR_HOOK_RELAY, GPIO_BIT_HOOK_RELAY, ACTIVATE);
  else
  {
      set_gpio_bit ((uword *) GPR_HOOK_RELAY, GPIO_BIT_HOOK_RELAY, DEACTIVATE);

/* this is flag used to set when we go offhook for dialing invoice mode
    need to reset it here */

        do_it_once = FALSE;  /* ramn 9/23/96 */
        handset_offhook_flag = FALSE;        /* ramn 10/25/96 */
    /*
        when hanging up make sure that the callerid relay is also off
        This may be needed if +VCID=1 and some how call answered on first
        ring
    */
    set_callerid_relay( CID_RELAY_OFF);    /* ramn 12/19/96 */
  }    
}

/*******************************************************************************
/
/    Procedure:     get_hook_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine returns the status of
/                   Hook Relay.
/
/    Input Parameters:   None
/
/    Output Parameter:   ubyte - OHREL state (ON, OFF)
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_hook_relay (void)
{
  uword gpio_state, *reg;
  uword mask;

  /* 1st read the state of the register that contains HOOK relay */
  reg = (uword *) GPR_HOOK_RELAY;
  gpio_state = (uword) *reg;
  mask = (1 << GPIO_BIT_HOOK_RELAY);

  /* If HOOK bit is set, return OFF */
  if (gpio_state & mask)
    return 0;
  else
    return 1;
}

/*******************************************************************************
/
/    Procedure:     get_phone_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine returns the status of
/                   Local Phone Off Hook Detect.
/
/    Input Parameters:   None
/
/    Output Parameter:   ubyte - LPOHD state (ON, OFF, UNDETERMINED)
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_phone_relay (void)
{
  uword gpio_state, *reg;
  uword mask;

  /* First read the state of the register that contains LPOHD
     (local phone off-hook detect). */
  reg = (uword *) GPR_PHONE_RELAY;
  gpio_state = (uword) *reg;
  mask = (1 << GPIO_BIT_LOCAL_PHONE_RELAY);

  /* If LPOHD bit is set, return ON */
/*rjmw95*/

  if (gpio_state & mask)
  {
     phone_relay_timer = 0;
     return 0;
  }
  else
  {
     /*  debounce for 100ms -- incoming ring falsely triggers phone relay  */
     if (phone_relay_timer ==  0)
     {
        phone_relay_timer = 11;
        return (0);
     }
     else
     {
        if (phone_relay_timer == 1)
           return 1;
        else
           return 0;
     }
  }
}

/****************************************************************************
 *
 *   Routine:           set_spk_hs_relay()
 *
 *   Author:            RSA
 *
 *   Creation Data:     17/2/1996
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/
void set_spk_hs_relay( ubyte state)
{
    if(fax_class == 8)    /* added by ramn on 5/31/96 */
    {
       if( state )
          set_gpio_bit ((uword *)GPR_SPK_HS_RELAY, GPIO_BIT_SPK_HS_RELAY, ACTIVATE);
       else
          set_gpio_bit ((uword *)GPR_SPK_HS_RELAY, GPIO_BIT_SPK_HS_RELAY, DEACTIVATE);
    }
}

/****************************************************************************
 *
 *   Routine:           set_safe1_en_relay()
 *
 *   Author:            MH
 *
 *   Creation Data:     16/9/1997
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 ****************************************************************************/
void set_safe1_en_relay( ubyte state)
{
   if( state )
        set_gpio_bit ((uword *)GPR_SAFE1_EN_RELAY, GPIO_BIT_SAFE1_EN_RELAY, ACTIVATE);
   else
        set_gpio_bit ((uword *)GPR_SAFE1_EN_RELAY, GPIO_BIT_SAFE1_EN_RELAY, DEACTIVATE);
}

/****************************************************************************
 *
 *   Routine:           set_loc_line_relay()
 *
 *   Author:            MH
 *
 *   Creation Data:     16/9/1997
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 ****************************************************************************/
#if INTERNATIONAL_CODE == 1
void set_loc_line_relay( ubyte state)
  {
       if( state )
          set_gpio_bit ((uword *)GPR_LOC_LINE_RELAY, GPIO_BIT_LOC_LINE_RELAY, ACTIVATE);
       else
          set_gpio_bit ((uword *)GPR_LOC_LINE_RELAY, GPIO_BIT_LOC_LINE_RELAY, DEACTIVATE);
  }
#endif
/****************************************************************************
 *
 *   Routine:           set_shunt_relay()
 *
 *   Author:            MH
 *
 *   Creation Data:     16/9/1997
 *
 *   Description: 
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:       
 ****************************************************************************/
#if INTERNATIONAL_CODE == 1
void set_shunt_relay( ubyte state)
  {
       if( state )
          set_gpio_bit ((uword *)GPR_SHUNT_RELAY, GPIO_BIT_SHUNT_RELAY, ACTIVATE);
       else
          set_gpio_bit ((uword *)GPR_SHUNT_RELAY, GPIO_BIT_SHUNT_RELAY, DEACTIVATE);
  }
#endif
/* MH092397 till here */

/*******************************************************************************
/
/    Procedure:     set_gpio_bit
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets or clears the state of the selected
/                   GPIO pin (SINGLE BIT) on the selected GPIO register.
/                   Changing the bit requires also setting its mask bit to 1.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/                      ubyte bit_location - Which bit to change in the
/                        register specified by *gpr.
/
/                      ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
/*-------------------------------------------------------------------

   GPR0, GPCR0 contains GPIO pins 0-7
   GPR1, GPCR1 contains GPIO pins 8-15
   GPR2, GPCR2 contains GPIO pins 16-23

   Each GPR register is 16 bits wide, with alternating sequences
   of 4 mask bits and 4 GPIO bits, as shown below for GPR0:

   15 14 13 12  11 10 09 08   07 06 05 04  03 02 01 00
   M3 M2 M1 M0  G7 G6 G5 G4   M3 M2 M1 M0  G3 G2 G1 G0

   When writing to the GPR register, only those GPIO bits whose
   corresponding Mask bits are 1 will be affected.

   To set,   write 1 to the pin's bit and 1 to its mask bit.
   To clear, write 0 to the pin's bit and 1 to its mask bit.

   GPPFR (GPIO Pin Function Register) contains only 6 bits with
   no mask bits, so it can be set like a normal register.

------------------------------------------------------------------ */
void set_gpio_bit (uword *gpr, ubyte bit_location, ubyte state)
{
  uword gpio_snapshot, new_bitmask;

  /* First read the state of the selected register.
     gpr points to the actual on-chip memory address of the register. */
  gpio_snapshot = (uword) *gpr;

  /* Set the mask bit that corresponds to the selected GPIO pin.
     Its mask bit location is 4 bits to the left of the GPIO bit. */
  gpio_snapshot |= (1 << (bit_location + 4));

  /* Set or clear the GPIO bit based on the requested state */
  new_bitmask = (1 << bit_location);

  if (state)
    gpio_snapshot |= new_bitmask;
  else
    gpio_snapshot &= ~new_bitmask;

  /* Now write the new word to the GPIO register */
  *gpr = (uword) gpio_snapshot;
}

/*******************************************************************************
/
/    Procedure:     set_gpio_reg
/
/    Author:   RSA
/
/    Creation Date: 1/5/96
/
/    Description:   This routine sets the value of the selected GPIO register.
/                   For GPR and GPCR registers, it formats the bits to match
/                   the register definition.  For GPPFR, it just writes the
/                   new value to the register.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/                      ubyte value - Value to write to GPIO register
/                        specified by *gpr.
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_gpio_reg (uword *gpio_register, ubyte value)
{
  uword new_bitmask;

  /* GPPFR register is 8 bits, but the other GPIO registers are
     16 bits with mask bits.  If not the GPPFR, then format the
     register value accordingly. */
  if (gpio_register != (uword *) GPPFR)
  {
    /* First create the register word based on the requested pin value.
       The word format is:  M7 M6 M5 M4 G7 G6 G5 G4   M3 M2 M1 M0 G3 G2 G1 G0

       GPIO pins 0-3 are represented in the lower nibble of the pin value byte
       GPIO pins 4-7 are represented in the high nibble of the pin value byte
    */
    new_bitmask = (value & 0xF0);  /* Set low byte to GPIO pins 4-7 */
    new_bitmask <<= 4;             /* Shift value into high byte / low nibble */
    new_bitmask |= (value & 0x0F); /* OR in GPIO pins 0-3 into low byte */
    new_bitmask |= 0xF0F0;         /* Set all mask bits to 1 to enable change */

    /* Write the new register value to the register memory address */
    *gpio_register = new_bitmask;
  }

  /* For GPPFR, just write the ubyte bitmask passed in */
  else
  {
    *gpio_register = value;
  }
}

/*******************************************************************************
/
/    Procedure:     get_gpio_reg
/
/    Author:   RSA
/
/    Creation Date: 1/5/96
/
/    Description:   This routine returns the value of the selected GPIO register.
/                   For GPR and GPCR registers, it removes the mask bits and
/                   formats the return byte as GPIO pins 0-7 in bits 0-7.
/                   For GPPFR, it just returns the current value.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/    Output Parameter:   ubyte - Value of selected register
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_gpio_reg (uword *gpio_register)
{
  /* GPPFR register is 8 bits, but the other GPIO registers are
     16 bits with mask bits.  If not the GPPFR, then format the
     register value accordingly. */
  if (gpio_register != (uword *) GPPFR)
  {
    uword gpio_state;
    ubyte gpio_pins_lower, gpio_pins_upper;

    gpio_state = (uword) *gpio_register;
    gpio_pins_lower = gpio_state & 0x000F;        /* Low byte to low nibble */
    gpio_pins_upper = (gpio_state & 0x0F00) >> 4; /* High byte to high nibble */
    return (gpio_pins_lower | gpio_pins_upper);
  }

  else
  {
    uword *gppfr;

    gppfr = (uword *) GPPFR;
    return ((ubyte) *gppfr);
  }
}

/* RJM040396 */
/* Moved from MT00CUST.C for Host based support */
/*******************************************************************************
/
/                                  call_progress
/
/       Author:         RSA
/
/       Creation Date:  03/01/94
/
/       Description:    This routine will return the progress of the calling
/                       sequence.  USA only
/
/       Input Parameters:       None
/
/       Output Parameter:       0 - undetermined
/                               1 - dial tone
/                               2 - ring on
/                               3 - busy
/                               4 - silence
/                               5 - ring back
/                               6 - answer tone
/                               7 - ring off
/
/       Global Variables Changed:
/
/       Users: (routines that used this)  modem_call_progress
/
/       *****************************************************************
/       *                         Modifications                         *
/       *****************************************************************
/
/       Author & Date:
/       Description:
/       Reason:
/
*******************************************************************************/
/*22296shujin, for distinctive ring */
ubyte call_progress(void)
{
   ubyte tmp;
   static ringStatus= UNDETERMINED;

   tmp = read_dsp_call_progress_reg();

    if ( ring_on )
    {
       ringStatus = RING_ON;
      tmp = RING_ON;
         return tmp;
    }
    else if ( (ring_on==FALSE) && (ring_was_on_before == TRUE)    )
    {
      tmp = RING_OFF;
      ringStatus = UNDETERMINED;
         return tmp;
    }
    else
   {
        if(tmp== RING_ON || tmp==RING_OFF)
           tmp = UNDETERMINED;

      ringStatus = UNDETERMINED;
          return tmp;
    }
}

/* added by ramn on 4/16/96 */
/* these routines were added in accordance to the new modem task 
    done by Rob miller */

void dsp_reset( ubyte state)
{
   if( state )
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, DEACTIVATE);
   else
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, ACTIVATE);
}

void dsp_cfg( ubyte state)
{
   if( state )
      set_gpio_bit ((uword *)GPR_DSP_CFG_RELAY, GPIO_BIT_DSP_CFG_RELAY, DEACTIVATE);
   else
      set_gpio_bit ((uword *)GPR_DSP_CFG_RELAY, GPIO_BIT_DSP_CFG_RELAY, ACTIVATE);
}


/*** till here by ramn *****/

/* RJM052996 */
/* Beta App support */
void set_register(ubyte addr, ubyte data)
{
  ubyte *temp;

  temp = (ubyte *)(COM_RAM + (addr * WORD_OR_BYTE_ADD_INC));
  *temp = data;
}

ubyte get_register(ubyte addr)
{
  ubyte *temp;

  temp = (ubyte *)(COM_RAM + (addr * WORD_OR_BYTE_ADD_INC));
  return (*temp);
}

void relay_init(void) 
{
#if INTERNATIONAL_CODE == 1     
     set_loc_line_relay(ON_HOOK);
      set_shunt_relay(ACTIVATE);
     set_safe1_en_relay(ACTIVATE);    /* mh110597 output = HI */
      shunt_timer = 0;
      shunt_timer_en =0;
#else
     set_safe1_en_relay(ACTIVATE);    /* mh110597 output = HI */
#endif
}

uword get_dsp_version(void)
{
   LOAD_MODEM_GET_VERSION
   dsp_cp_packet = PACKET_DP_VERSION_INFO;          

   ack_or_response = RESPONSE;
   send_pkt_to_dsp();
   return ( (uword)(dsp_response_data[2] << 8) |
            (uword) dsp_response_data[0]);
}

