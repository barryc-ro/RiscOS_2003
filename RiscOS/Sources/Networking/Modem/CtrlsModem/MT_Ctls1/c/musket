/******************************************************************************
/
/     Copyright, 1988, 1989, 1990, 1991, 1992, 1993, 1994. All Rights Reserved by:
/        RSA
/        7701 Six Forks Road
/        Suite 120
/        Raleigh, NC  27615
/        (919) 846-7171
/
/     This document contains material confidential to R. Scott Associates.
/     its contents must not be revealed, used or disclosed to anyone or
/     company with out written permission by R. Scott Associates.  the
/     information contained herein is solely for the use of R. Scott
/     Associates.
/
/    File:             hardware.c
/
/       Version:
/
/       Function:   Hardware specific file.
/
/     Product:    Musket
/
/       History:
/
/     Created:    10/25/95
/
/         ------------------------------------------------------
/         -          Modifications                -
/         ------------------------------------------------------
/
/    Author & Date:
/    Description:
/    Reason:
/
******************************************************************************/
#include "mod_def.h" /* ramn 2/5/96 */
#include  "SYS_DEF.H"
#include  "cp_dsp.h"
#include  "MT_CODEF.H"
#include  "MT_HWDEF.H"
#include  "MT_COPRO.H"
#include  "MT_HWPRO.H"
#include  "MT_COEXT.H"
#include  "mt_macro.h"
#include "dte_drv.h"
#include "tracemac.h"
#include  "resp_cod.h"
#include  "acu_pro.h"

/* RJM040396 */
/* VCV Support */
#include "lineequ.h"
#include "mt_gpio.h"
#include "ee_def.h"

#ifdef __riscos
#include  "mt_voice.h"
#include  "dsp_drv.h"
#include  "riscos.h"
#endif

/* RJM040396 */
/* VCV Support */
#define VOC_RELAY_OFF_HOOK		0x1000
#define VOC_RELAY_ON_HOOK 		0x1100
#define OH_RELAY_OFF_HOOK		0x0080
#define OH_RELAY_ON_HOOK		0x0088

ubyte *rom_components(void);
ubyte *capability_descript(void);
ubyte read_dipswitch(void);
ubyte write_eeprom_data(uword, uword, ubyte *);
ubyte read_eeprom_data(uword, uword, ubyte *);
ubyte calc_eeprom_checksum(void);
ubyte calc_rom_checksum(void);
void set_hs_led(ubyte);
void set_dte_cts(ubyte);
void set_aa_led(ubyte);
void set_ec_led(ubyte);

#if 0 /* ramn 9/20/96 */
void set_ri_led(ubyte);
void set_dc_led(ubyte);
void set_oh_led(ubyte);
void set_tr_led(ubyte);
void set_cts_led(ubyte);
void set_fax_led(ubyte);
void set_mr_led(ubyte);
void set_cd_led(ubyte);
void set_v32_led(ubyte);
void set_v23_led(ubyte);
void set_b2l_led(ubyte);
void set_v21_led(ubyte);
void set_v22_led(ubyte);
void set_v22bis_led(ubyte);
void reset_watchdog(void);
void ram_init(void);
void init_ports(void);
void set_dte_112(ubyte);
void set_dte_117(ubyte);
void set_dte_test(ubyte);
#endif

ubyte *product_code(void); /* ramn 1/12/96 */
extern ubyte *d_to_a_two(ubyte num);

/* RJM040396 */
/* Host based Support */
void process_timers (void);

/* RJM040396 */
/* VCV Support */
void  gpio_hook_relay (ubyte state);
void  set_dsvd_relay (ubyte state);
void  set_cid_relay (ubyte state);
void  set_voice_relay (ubyte state);
void  set_spk_hs_relay (ubyte state);
ubyte get_phone_relay (void);
void  set_gpio_bit (uword *gpr, ubyte bit_location, ubyte state);
void  set_gpio_reg (uword *gpio_register, ubyte value);

/* RJM040396 */
/* Moved call_progress() from MT00CUST.C for Host based
   RING Detectandthese vars go with it.
*/
extern ubyte ring_on; /*22296shujin	*/
extern ubyte ring_was_on_before;

#define STORED_NUM  2
#define UNFORMATTED     3

#ifdef __riscos
void HaltDSP(void);
void RunDSP(void);
#endif

extern ubyte dsp_response_data[15];

/*mrm91896*/
/*dcd toggle for window application*/
ubyte dcd_toggle = 0;
ubyte dsp_done;

extern ubyte handset_offhook_flag; /* ramn 10/25/96 */

#define   CID_RELAY_OFF  0x0200 			/* ramn 12/19/96 */
extern void	set_callerid_relay( uword);	/* ramn 12/19/96 */


/*******************************************************************************
/
/                     "modem_write_data"
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will store the given string of data in
/                        EEPROM at the given offset.
/
/    Input Parameters:   offset - storage location in EEPROM
/                        length - length of data string
/                            ptr    - pointer to data string to be stored
/
/    Output Parameter:   0 - write succeded
/                            1 - Write failed
/
/    Global Variables Changed:     eeprom memory
/
/    Users: (routines that used this)  Many places
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0
ubyte modem_write_data(uword offset, uword length, ubyte *ptr)
{
    ubyte tmp_byte;

    mmu_open_modem_task_pg
    tmp_byte = write_eeprom_data(offset, length, ptr);
    mmu_restore_stored_pg
    return (tmp_byte);
}
#endif /* ramn 1/31/96 */


/*******************************************************************************
/
/                     "modem_read_data"
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will retrieve a string of data from the
/                   given offset in EEPROM (NVRAM).  The parameter PTR
/                   will contain the data retrieved.
/
/    Input Parameters:   offset - storage location in EEPROM
/                            length - length of data string to retrieve
/                            ptr    - pointer to nell data string
/
/    Output Parameter:   0 - Read succeded
/                            1 - Read failed
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  Many places
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0
ubyte modem_read_data( uword offset, uword length, ubyte *ptr)
{
    ubyte tmp_byte;

    mmu_open_modem_task_pg
    tmp_byte = read_eeprom_data(offset, length, ptr);
    mmu_restore_stored_pg
    return (tmp_byte);
}
#endif /* ramn 1/31/96 */

/*******************************************************************************
/
/                      modem_dte_test
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will set the TEST relay to the given state.
/
/    PARAMETERS IN: state = ON or OFF
/
/    PARAMETERS OUT: none
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void modem_dte_test( ubyte state)
{
	ubyte temp;
	temp = state;
}
#endif


/*******************************************************************************
/
/                      modem_dte_112
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will set the 112 relay to the given state.
/
/
/    PARAMETERS IN: state = ON or OFF
/
/    PARAMETERS OUT: none
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void modem_dte_112(ubyte state)
{
	ubyte temp;
	temp = state;
}

#endif

/*******************************************************************************
/
/                      modem_dte_117
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will set the 117 relay to the given state.
/
/
/    PARAMETERS IN: state = ON or OFF
/
/    PARAMETERS OUT: none
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void modem_dte_117( ubyte state)

{
	ubyte temp;
	temp = state;
}
#endif

/*******************************************************************************
/
/                     modem_serial_echo
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will set DTE hardware echo to the given
/                        state.
/
/    Input Parameters:   state  ON
/                               OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0	/* ramn 9/20/96 */
void modem_serial_echo(ubyte state)
{

    set_echo(state);

}
#endif

/*******************************************************************************
/
/                   modem_product_code
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will return a string which contains the
/                        modem product code.
/
/    Input Parameters:   None
/
/    Output Parameter:   *string
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  at_I
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
/* ramn 1/12/96 */
#if 0
ubyte *modem_product_code(void)
{
    ubyte *temp;


    temp = product_code();

    return(temp);
}
#endif
ubyte *product_code(void)
{
    return ((ubyte *) MODEM_PRODUCT_CODE);
}


/*******************************************************************************
/
/                   modem_product_code
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will return a string which contains the
/                        modem product code.
/
/    Input Parameters:   None
/
/    Output Parameter:   *string
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  at_I
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/

extern uword dsp_code[];
void mm_dsp_version(void)
{
	  ubyte *string,*temp;

		LOAD_MODEM_GET_VERSION
		dsp_cp_packet = PACKET_DP_VERSION_INFO;

		ack_or_response = RESPONSE;
		send_pkt_to_dsp();

		string = (ubyte*) DSP_FIRMWARE_VER_STRING;
		output_info(string,STORED_NUM);


/* RJM040396 */
/* Direct COMRAM access will not work for Host based */
#if 0
	  temp = (ubyte * )	V34_RATE_RESP_BYTE;
#else
	  temp  = &dsp_response_data[2];
#endif

		string = d_to_a_two(*temp);
		output_info(string,UNFORMATTED);

		string = (ubyte*) DOT;
		output_info(string,UNFORMATTED);

/* RJM040396 */
/* Direct COMRAM access will not work for Host based */
#if 0
	  temp = (ubyte * ) V34_RATE_RESP;
#else
	  temp  = &dsp_response_data[0];
#endif

		string = d_to_a_two(*temp);
		output_info(string,UNFORMATTED);



		string = (ubyte*)	MODEM_FIRMWARE_VER_STRING;
		output_info(string,UNFORMATTED);

#ifndef __riscos
/*speaker phone version report*/
/*mrm83096*/
		string = (ubyte*)	SPEAKER_PHONE_VER_STRING;
		output_info(string,UNFORMATTED);
		output_info(d_to_a_two(dsp_code[6]),UNFORMATTED);
#endif

}




/*******************************************************************************
/
/                    modem_rom_components
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will return a string which contains the
/                   modem part number, revision level, and hardware
/                   location of all ROM components.
/
/    Input Parameters:   None
/
/    Output Parameter:   *string
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  get_rom_components
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/

ubyte *modem_rom_components(void)
{
    ubyte *temp;


    temp = rom_components();

    return(temp);
}

#if 0
/*******************************************************************************
/
/                   "read_dipswitch"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will read the dipswitches
/
/    Input Parameters:   None
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_read_dipswitch
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0	/* ramn 9/20/96 */
ubyte read_dipswitch(void)

{
/* no dipswitches on Merlin */
    return;
}
#endif


/*******************************************************************************
/
/     Routine:       "write_eeprom_data"
/
/     Author:      RSA
/
/     Creation Date:       06/10/94
/
/     Description:    This routine will store the given string of data in
/                         EEPROM at the given offset.
/
/     Input Parameters:  offset - storage location in EEPROM
/                               length - length of data string
/                               ptr    - pointer to data string to be stored
/
/     Output Parameter:  1 - Read failure occured
/                               0 - Read failure did not occure
/
/     Global Variables Changed:    None
/
/     Users: (routines that used this)  modem_write_data
/
/     *****************************************************************
/     *               Modifications               *
/     *****************************************************************
/
/     Author & Date:
/     Description:
/     Reason:
/
*******************************************************************************/
ubyte write_eeprom_data(uword eeprom_addr, uword byte_count, ubyte *str_ptr)

{
    ubyte i;
    ubyte ok;
    BYTE *eeprom_address;
    BYTE *src_adr;

    eeprom_address = eeprom_addr + PSTN_E2_BASE;
    src_adr = str_ptr;

	 for (i=0; i<byte_count; i++)
	 {
		  ok = EE_writeData(eeprom_address++, src_adr++, 1);

	   /*      EEPROM write has failed if 1 is returned */
		if (!ok) return(1);

	}
	  return(0);
}


/*******************************************************************************
/
/     Routine:       "read_eeprom_data"
/
/     Author:      RSA
/
/     Creation Date:  06/10/94
/
/     Description:    This routine will retrieve a string of data from the
/                         given offset in EEPROM.  The parameter PTR
/                         will contain the data retrieved.
/
/     Input Parameters:  offset - storage location in EEPROM
/                               length - length of data string to retrieve
/                               ptr    - pointer to null data string
/
/     Output Parameter:  1 - Read failure occured
/                               0 - Read failure did not occure
/
/     Global Variables Changed:    None
/
/     Users: (routines that used this)  modem_read_data
/
/     *****************************************************************
/     *               Modifications               *
/     *****************************************************************
/
/     Author & Date:
/     Description:
/     Reason:
/
*******************************************************************************/

ubyte read_eeprom_data(uword eeprom_addr, uword byte_count,ubyte *str_ptr)

{
    ubyte ok;
    BYTE *eeprom_ptr, *src_ptr;
    ubyte i;

    eeprom_ptr = eeprom_addr + PSTN_E2_BASE;
    src_ptr = str_ptr;

    for (i=0; i<byte_count; i++) {

	    ok = EE_read(src_ptr++, eeprom_ptr++, 1);
	  /*      EEPROM write has failed if 1 is returned     */

	  if (!ok) return(1);
    }
    return (0);

}



/*******************************************************************************
/
/     Routine:     "calc_eeprom_checksum"
/
/     Author:      RSA
/
/     Creation Date:       12/20/92
/
/     Description:  This routine will calculate and return modem EEPROM
/                         pseudo checksum as defined in the ACU code.
/
/     Input Parameters:  none
/
/     Output Parameter:  checksum value
/
/     Global Variables Changed:    None
/
/     Users: (routines that used this)  modem_eeprom_checksum
/
/     *****************************************************************
/     *               Modifications               *
/     *****************************************************************
/
/     Author & Date:
/     Description:
/     Reason:
/
*******************************************************************************/
ubyte calc_eeprom_checksum(void)

{
    uword ee_size,sum;
    ubyte eetmp;
    uword ee_addr;
    ubyte new_eeprom = TRUE;

    /* ONLY checksum the length of the PSTN area in the EEPROM */
    ee_size = PSTN_EE_END_ADDR - (CHECKSUM_ADDR + CHECKSUM_SIZE);

    /* We start right after the PSTN checksum itself */
    ee_addr = (uword)PSTN_E2_BASE + 1;
    sum = 0;

    /* Read each byte in the eeprom area to build checksum */
    for ( ; ee_size > 0 ; ee_size--)
    {
	   read_eeprom_data(ee_addr, 1, &eetmp);
	   /* New eeproms are either all 0's or all 1's */
	   if ((eetmp != 0x00) || (eetmp != 0xff))
		  new_eeprom = FALSE;
	   sum += eetmp;
		ee_addr++;
    }

    if (new_eeprom == TRUE)
    {
	   /*  If empty eeprom, return a bogus value so the ACU will
		  update with factory defaults */
	   return(0x55);
    }

    return((ubyte)sum);
}
#endif


/*******************************************************************************
/
/                   "calc_rom_checksum"
/
/    Author:   RSA
/
/    Creation Date: 02/07/91
/
/    Description:   This routine will calculate and return the modem ROM
/              checksum.
/
/    Input Parameters:   None
/
/    Output Parameter:   rom_cs value
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_rom_checksum
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason
/
*******************************************************************************/
ubyte calc_rom_checksum(void)

{
   return (0x55);
}



/*******************************************************************************
/
/                   "set_hs_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   Sets the hs led to the desired state (on or off).
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_hs_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_hs_led(ubyte state)

{
#ifndef __riscos
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_HS_LED, GPIO_BIT_HS_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_HS_LED, GPIO_BIT_HS_LED, DEACTIVATE);
/*#else*/
#endif

#if 0 /* ramn 9/20/96 */

   if (state)
	 bb_LED_long |= HS_LED_POS;
   else
	 bb_LED_long &= ~HS_LED_POS;

   /* io_set_LEDS was called here jeb */
#endif
#endif

}

/*******************************************************************************
/
/                   "set_mr_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the MR led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_mr_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0  /* ramn 9/18/96 */
void set_mr_led(ubyte state)

{

   if (state)
	 bb_LED_long |= MR_LED_POS;
   else
	 bb_LED_long &= ~MR_LED_POS;

   /* io_set_LEDS was called here jeb */
}
#endif


/*******************************************************************************
/
/                   "set_cd_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the cd led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_cd_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_cd_led(ubyte state)

{
   if (state)
	 bb_LED_long |= CD_LED_POS;
   else
	 bb_LED_long &= ~CD_LED_POS;

   /* io_set_LEDS was called here jeb */
}
#endif


/*******************************************************************************
/
/                   "set_aa_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the aa led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_aa_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_aa_led(ubyte state)
{
#ifndef __riscos
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_AA_LED, GPIO_BIT_AA_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_AA_LED, GPIO_BIT_AA_LED, DEACTIVATE);
/*#else*/
#endif

#if 0 /* ramn 9/20/96 */
   if (state)
	 bb_LED_long |= AA_LED_POS;
   else
	 bb_LED_long &= ~AA_LED_POS;

   /* io_set_LEDS was called here jeb */

#endif
#endif
}


/*******************************************************************************
/
/                   "set_fax_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the FAX led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  start_fax_conection, fax_hangup
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_fax_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif


/*******************************************************************************
/
/                   "set_ec_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the ec led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_ec_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void set_ec_led(ubyte state)
{
#ifndef __riscos
#if SERIAL_MODE == 1 /* ramn 7/16/96 */

  if( state )
      set_gpio_bit ((uword *) GPR_EC_LED, GPIO_BIT_EC_LED, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_EC_LED, GPIO_BIT_EC_LED, DEACTIVATE);
/*#else*/
#endif

#if 0 /* ramn 9/20/96 */

    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
#endif
#endif
}


/*******************************************************************************
/
/                   "set_ri_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the ri led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/

/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_ri_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_ri_led(ubyte state)
{
   if (state)
	 bb_LED_long |= RI_LED_POS;
   else
	 bb_LED_long &= ~RI_LED_POS;

   /* io_set_LEDS was called here jeb */

}
#endif

/*******************************************************************************
/
/                   "set_dc_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the dc led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_dc_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_dc_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif


/*******************************************************************************
/
/                   "set_oh_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the oh led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_oh_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_oh_led(ubyte state)

{
   if (state)
	 bb_LED_long |= OH_LED_POS;
   else
	 bb_LED_long &= ~OH_LED_POS;

   /* io_set_LEDS was called here jeb */
}
#endif


/*******************************************************************************
/
/                   "set_tr_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the tr led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_tr_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_tr_led(ubyte state)

{
   if (state)
	 bb_LED_long |= TR_LED_POS;
   else
	 bb_LED_long &= ~TR_LED_POS;

   /* io_set_LEDS was called here jeb */
}
#endif


/*******************************************************************************
/
/                   "set_v32_led"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the v32 led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_v32_led
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_v32_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif

/*******************************************************************************
/
/                   set_cts_led
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the cts led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_cts_led(ubyte state)
{

   if (state)
	 bb_LED_long |= CTS_LED_POS;
   else
	 bb_LED_long &= ~CTS_LED_POS;

   /* io_set_LEDS was called here jeb */
}
#endif


/*******************************************************************************
/
/                   set_v23_led
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the v23 led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_v23_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif

/*******************************************************************************
/
/                   set_b2l_led
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the b21 led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_b2l_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif

/*******************************************************************************
/
/                   set_v21_led
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the v21 led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_v21_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif

/*******************************************************************************
/
/                   set_v22_led
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the v22 led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_v22_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif

/*******************************************************************************
/
/                   set_v22bis_led
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the v22bis led to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_v22bis_led(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif

/*******************************************************************************
/
/                   set_dte_112
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the dte 112 to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_dte_112(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif


/*******************************************************************************
/
/                   set_dte_117
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the dte 117 to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_dte_117(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif


/*******************************************************************************
/
/                   set_dte_test
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the dte circuit 142 to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_dte_test(ubyte state)
{
    /* to suppress Archimedes compiler warnings */
    ubyte temp;
    temp = state;
}
#endif



/*******************************************************************************
/
/                   "reset_watchdog"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine is called to reset the watchdog timer
/                   so that it will not expire
/
/    Input Parameters:   None
/
/    Output Parameter:   0 = Fail
/                        1 = Pass
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_watch_dog
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void reset_watchdog(void)
{

}
#endif


/*******************************************************************************
/
/                   "ram_init"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:
/
/    Input Parameters:
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void ram_init(void)

{

}
#endif

/*******************************************************************************
/
/                   "init_default_DAA"
/
/    Author:   RSA
/
/    Creation Date: 7/01/94
/
/    Description:
/
/    Input Parameters:
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)  mt_init
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void init_default_DAA(void)

{
}
#endif

/*******************************************************************************
/
/                   "init_ports"
/
/    Author:   RSA
/
/    Creation Date: 8/01/94
/
/    Description:    Init port A and port B for DTE controls and ring
/
/    Input Parameters:       None
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
#if 0 /* ramn 9/20/96 */
void init_ports(void)

{
return;


}
#endif



/*******************************************************************************
/
/                   "set_dte_cts"
/
/    Author:   RSA
/
/    Creation Date: 3/01/94
/
/    Description:   This routine will set the CTS relay to the given state.
/
/    Input Parameters:   ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users: (routines that used this)  modem_dte_cts
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void set_dte_cts(ubyte state)
{


	ubyte *temp;
#ifdef __riscos

    extern int RO_cts;

    RO_cts=state;
#else

#if 0
    if (state)
	   *pbdr &= ~CTS_MASK;
    else
	   *pbdr |= CTS_MASK;
#endif

/*mrm5896*/

#if PARALLEL_MODE == 1
    if (state)
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR);
		*temp |=  CTS_ON;
	 }
	 else
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR);
		*temp &=  CTS_OFF;
 	 }
#endif

/*mrm5896*/

#if SERIAL_MODE == 1
    if (state)
	 {
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR);
		*temp =  CTS_ON;

	 }
	 else
	 {
		temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR);
		*temp =  CTS_OFF;
 	 }
#endif


#endif



}

/******************************************************************************
/
/    Procedure: set_dte_dsr
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the DSR line depending
/              on the parameter passed in.
/
/    Input Parameters:
/                   0 - Raise DSR (off)
/                   1 - Lower DSR (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_dsr
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_dsr(ubyte state)
{
#ifdef __riscos
        extern int RO_dsr;

        RO_dsr=state;
#else
	ubyte *temp;

#if PARALLEL_MODE == 1
    if (state)
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR);
		*temp |=  DSR_ON;
	 }
	 else
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR);
		*temp &=  DSR_OFF;
 	 }
#endif  /* ramn 2/5/96 */

#if SERIAL_MODE == 1
    if (state)
	 {
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR);
		*temp =  DSR_ON;

	 }
	 else
	 {
		temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR);
		*temp =  DSR_OFF;
 	 }
#endif  /* ramn 2/5/96 */




    #if 0
    if (state)
	   *pbdr &= ~DSR_MASK;
    else
	   *pbdr |= DSR_MASK;
    #endif
#endif
}


/******************************************************************************
/
/    Procedure: set_dte_ri
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the RI line depending on
/              the parameter passed in.
/
/    Input Parameters:
/                   0 - Raise RI (off)
/                   1 - Lower RI (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_ri
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_ri(ubyte state)
{
    #ifdef __riscos
    extern int RO_ring;
    RO_ring=state;
    #else
    #if 0
    if (state)
	   *pbdr &= ~RI_MASK;
    else
	   *pbdr |= RI_MASK;
    #endif
    #endif
}



/******************************************************************************
/
/    Procedure: set_dte_rlsd
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will raise or lower the RLSD line depending
/              on the parameter passed in.
/
/    Input Parameters:
/                   0 - Raise RLSD (off)
/                   1 - Lower RLSD (on)
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_dte_rlsd
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void set_dte_rlsd(ubyte state)
{
#ifdef __riscos
        extern int RO_dcd;
        RO_dcd = state;
#else

	ubyte *temp;

#if PARALLEL_MODE == 1
    if (state)
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR);
		*temp |=  DCD_ON;
	 }
	 else
	 {
		temp = (ubyte *)(PARALLEL_16550_LOCATION + HMSR);

/*mrm91896*/
/*dcd toggle for window application*/

			if (dcd_toggle)
			{
				*temp |=  DCD_ON;
				dcd_toggle = 0;
			}

		*temp &=  DCD_OFF;
 	 }

#endif  /* ramn 2/5/96 */

#if SERIAL_MODE == 1
    if (state)
	 {
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR);
		*temp =  DCD_ON;

	 }
	 else
	 {
		temp = (ubyte *)(SERIAL_UART_LOCATION + SMSR);
		*temp =  DCD_OFF;
 	 }
#endif  /* ramn 2/5/96 */



    #if 0
    if (state)
	   *pbdr &= ~CD_MASK;
    else
	   *pbdr |= CD_MASK;
    #endif
#endif
}



/******************************************************************************
/
/    Procedure: get_dte_CTS_status
/
/    Author: RSA
/
/    Creation Date: 10/28/91
/
/    Description: This routine will return the status of the CTS pin.
/
/    Input Parameters: none
/
/    Output Parameters:  D0 - Status of CTS pin:
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_CTS_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_CTS_status()
{
    #ifdef __riscos
    extern int RO_cts;
    return RO_cts;
    #else
    ubyte status;
    status = ON;
    #if 0
    /* check CTS bit of port b data register (active low) */
    if (*pbdr & CTS_MASK)
	   status = OFF;
    #endif
    return status;
    #endif
}


/******************************************************************************
/
/    Procedure: get_dte_RTS_status
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will return the status of the RTS pin.
/
/    Input Parameters: none
/
/    Output Parameters: Status of RTS pin
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_RTS_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_RTS_status()
{
    ubyte status;
    status = ON;
    #if 0
    /* check RTS bit of port b data register (active low) */
    if (*pbdr & RTS_MASK)
	   status = OFF;
    #endif
    return status;
}

/******************************************************************************
/
/    Procedure: get_dte_DTR_status
/
/    Author: RSA
/
/    Creation Date: 3/01/95
/
/    Description: This routine will return the status of the DTE pin.
/
/    Input Parameters: none
/
/    Output Parameters:
/                   0 - Off
/                   1 - On
/
/    Global Variables Changed: none
/
/    Users: modem_dte_DTR_status
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte get_dte_DTR_status()
{
    ubyte status,dtr_stat;
    ubyte *temp;
#ifdef __riscos
    extern int RO_dtr;
    status = RO_dtr ? ON : OFF;
#else
    status = OFF;

#if PARALLEL_MODE == 1
	temp = (ubyte *)(PARALLEL_16550_LOCATION + HMCR);
	dtr_stat =  *temp;

	if(dtr_stat &= DTR_BAR_MASK)
		  status = ON;

#endif /* ramn 2/5/96 */

#if SERIAL_MODE == 1
	 	temp = (ubyte *)(SERIAL_UART_LOCATION + SECR);
		dtr_stat = *temp;

		if(dtr_stat &= DTR_BAR_MASK)
			status = ON;
#endif /* ramn 2/5/96 */

#endif
    return status;

    #if 0
    /* check DTR bit of port b data register (active low) */
    if (*pbdr & DTR_MASK)
	   status = OFF;
    #endif

}

 #if 0
/******************************************************************************
/
/    Procedure: disable_int
/
/    Author: RSA
/
/    Creation Date: 10/28/91
/
/    Description: This routine will disable all interrupts.
/
/    Input Parameters: none
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_disable_interrupts
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void disable_int(void)
{
  ;
}

/******************************************************************************
/
/    Procedure: enable_int
/
/    Author: RSA
/
/    Creation Date: 10/28/91
/
/    Description: This routine will enable all interrupts.
/
/    Input Parameters: none
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_enable_interrupts
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
void enable_int(void)
{
  ;
}
#endif


/******************************************************************************
/
/    Procedure: set_echo
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will turn echo on or off depending on the
/              parameter passed in.
/
/    Input Parameters:  SP + 4 - state of ECHO
/                   0 - Turn echo off
/                   1 - Turn echo on
/
/    Output Parameters: none
/
/    Global Variables Changed: none
/
/    Users: modem_serial_echo
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
#if 0 /* ramn 9/20/96 */
void set_echo(ubyte status)
{
  ;
}
#endif


/******************************************************************************
/
/    Procedure: rom_test
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will calculate the checksum for the entire ROM
/
/    Input Parameters: none
/
/    Output Parameters:1 if checksum is okay
/                        - 0 if checksum error occured
/
/    Global Variables Changed: none
/
/    Users: modem_rom_test
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte rom_test(void)
{
/* always return 1, guess we're not really testing are we? */
    return (1);
}



/******************************************************************************
/
/    Procedure: ram_test
/
/    Author: RSA
/
/    Creation Date: 03/01/95
/
/    Description: This routine will test the modem's ram
/
/    Input Parameters: none
/
/    Output Parameters:  = 0 = Fail
/                        = 1 = Pass
/
/    Global Variables Changed: none
/
/    Users: modem_ram_test
/
/    -------------------------
/    -     Modifications -
/    -------------------------
/
/    Author & Date: RSA
/    Description:
/    Reason:
/
******************************************************************************/
ubyte ram_test(void)
{
/* always return 1, guess we're not really testing are we? */
    return (1);
}

#define DCE_BUFFER_SIZE 512
extern ubyte dce_rx_buffer[DCE_BUFFER_SIZE];

/*
|---------------------------------------------------------------------------
|
| dspdrv_WriteCram() - writes data into CommRam
|
|---------------------------------------------------------------------------
| PURPOSE:
|         Places a packet into the Tx CommRam.
|
| PARAMETERS:
|   <or INPUTS>
|
| RETURN VALUE:
|   <or OUTPUTS UPON EXIT>
|
| NOTES:
|   <indicate any restrictions or dependencies>
|
|
|
*/

void dspdrv_WriteCram(int addr, ubyte *data, int len)
{

	ubyte i;
	ubyte *dest;

	dest = (ubyte *) COM_RAM;

	/* set to end of data packet */
	dest += addr;

   for (i=0;i<len;i++) {
		*dest = *data++;
	        dest += WORD_OR_BYTE_ADD_INC;
		/*
		dest +=4;
		*/
	}


}


/*
|---------------------------------------------------------------------------
|
| dspdrv_ReadCram() - read data from CommRam
|
|---------------------------------------------------------------------------
| PURPOSE:
|         Gets a packet from Rx CommRam.
|
| PARAMETERS:
|   <or INPUTS>
|
| RETURN VALUE:
|   <or OUTPUTS UPON EXIT>
|
| NOTES:
|   <indicate any restrictions or dependencies>
|
|
|
*/

void dspdrv_ReadCram(int addr, ubyte *data, int len)
{

   ubyte i;
   volatile ubyte *src;

   src = (ubyte *) COM_RAM;

   /* set to end of data packet */
   src += addr;

   for (i=0;i<len;i++) {
	 *data++ = *src;
	 src += WORD_OR_BYTE_ADD_INC;
	/*
	src += 4;
	*/
   }

}

void dspdrv_ReadCram_buffer(int addr, ubyte *data, int len)
{

   ubyte i;
   volatile ubyte *src;
   ubyte *ptr;
   /*disable_int();*/
   ptr = (ubyte *)(&dce_rx_buffer) + DCE_BUFFER_SIZE;

   src = (ubyte *) COM_RAM;

   /* set to end of data packet */
   src += addr;

   for (i=0;i<len;i++) {
	 *data++ = *src;
	 src += WORD_OR_BYTE_ADD_INC;
	 /*src += 4;*/
	 if (data == ptr)
		data =  (ubyte *)(&dce_rx_buffer);
   }

}

void issue_debug_callback (void)
{
   /* Do nothing */
}

ubyte cp_dsp(void)
{
#ifdef __riscos
   dsp_done = FALSE;

   /* If Tx semaphore clear */
   if ( get_register(CP_DSP_SEMAPHORE) == 0 )
   {
     dspdrv_PutCRAM(current_command);
     return(1);
   }

   return(0);
#else
	ubyte byte_count,i;
	volatile ubyte *temp;

	byte_count = 0;


	temp = (ubyte *)(COM_RAM + (CP_DSP_CMD_START * WORD_OR_BYTE_ADD_INC));


	if (*temp == 0)
	{

		temp = temp + WORD_OR_BYTE_ADD_INC;

		/*write the filler + packet_length + filler byte to com_ram*/

		for (i = 1 ; i < 4 ; i++)
		{
			*temp = current_command[i];
			temp = temp + WORD_OR_BYTE_ADD_INC;
		}

		/*if packet_length is > zero then the data should follow */

		if (current_command[2] > 0 )
		{
			byte_count = current_command[2];

			for (i = 4 ; i < byte_count + 4 ; i++)
			{
				*temp = current_command[i];
				temp = temp + WORD_OR_BYTE_ADD_INC;
			}


		 }
		 /*MRM73195*/
		 /*If the number of bytes are odd add a filler byte*/
		 if (current_command[2] % 2 )
		 {
			*temp = 0x00;
		 }


		/*write the semaphore*/

		temp = (ubyte *) (COM_RAM + (CP_DSP_CMD_START * WORD_OR_BYTE_ADD_INC));

		*temp = current_command[0];

		/*
		  Write dummy 00 to location 0xFE byte or 0x3F8 word aligned
		  inorder to notify the dsp to read the CP->DSP mail box
		*/

		temp = (ubyte *) (COM_RAM + (CP_DSP_INT * WORD_OR_BYTE_ADD_INC));


		*temp = 0x00;

		return (1);
	}
	else
	{
	 return (0);
	}
#endif
}

ubyte dsp_acknowledge_packet(void);



   extern ubyte Cdata[];


/*************************************
   DSP Command Packet Callback
**************************************/
void cmd_packet_callback( ubyte id )
{
  /* No extra Debug checking needed for DOS app, so just set DONE flag. */
   dsp_done = TRUE;
}

ubyte dsp_cp (void)
{
#ifdef __riscos
   dspdrv_CommRamHandler();

   if (dsp_done == TRUE)
   {
     memcpy ((ubyte*)&dsp_response_data,(ubyte*)&Cdata[4], Cdata[2]);

     return(1);
   }

   return(0);
#else

	ubyte byte_count, i;
	volatile ubyte *temp;

	byte_count = 0;


	temp = (ubyte *)(COM_RAM + (DSP_CP_CMD_START * WORD_OR_BYTE_ADD_INC));


	if (*temp == dsp_cp_packet)
	{
		/*advance the address to the length byte*/
		temp = temp + (WORD_OR_BYTE_ADD_INC * 2);

		/*if packet_length is > zero then the data should follow */

		if (*temp > 0 )
		{
			byte_count = *temp;

			/*MRM82595*/
			/*
			If the response is more than one byte this routine must to
			modified for the multible returns
			*/

			temp = temp + (WORD_OR_BYTE_ADD_INC * 2);

			for (i = 0 ; i < byte_count ; i++)
			{

				dsp_response_data [i] = *temp;
				temp = temp + WORD_OR_BYTE_ADD_INC;
			}

		 }


		/*write the semaphore*/

		temp = (ubyte *) (COM_RAM + (DSP_CP_CMD_START * WORD_OR_BYTE_ADD_INC));

		*temp = 00;

		/*
		done in send_pkt_to_dsp
		current_command [0] = 0x00;
		current_command [1] = 0x00;
		current_command [2] = 0x00;
		current_command [3] = 0x00;
		current_command [4] = 0x00;
		current_command [5] = 0x00;
		current_command [6] = 0x00;
		current_command [7] = 0x00;
		current_command [8] = 0x00;
		current_command [9] = 0x00;
		*/

		return(1);



	}
	else
	{
		return (0);
	}
#endif
}

void fatal_error( ubyte error )
{
   while(1);
}

/* RJM040396 */
/* VCV Support to File end */
/*************************************
   Timer Support
**************************************/
void process_timers (void)
{
  process_wait ();
}


/*************************************
   GPIO control for Modem Task
**************************************/
/*******************************************************************************
/
/    Procedure:     set_voice_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of voice relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_voice_relay (ubyte state)
{
  #ifndef __riscos
  if(state )
      set_gpio_bit ((uword *) GPR_VOICE_RELAY, GPIO_BIT_VOICE_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_VOICE_RELAY, GPIO_BIT_VOICE_RELAY, DEACTIVATE);
  #endif
}


/*******************************************************************************
/
/    Procedure:     set_cid_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of
/                   caller ID relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_cid_relay (ubyte state)
{
  #ifdef __riscos
  if( state )
    dp_voice_set_gpio (~GPIO_CID_RELAY, GPIO_WRITE_AND_BYTE,
                        GPIO_BANK_INTERNAL);
  else
    dp_voice_set_gpio (GPIO_CID_RELAY, GPIO_WRITE_OR_BYTE,
                       GPIO_BANK_INTERNAL);
  #else
  if( state )
      set_gpio_bit ((uword *) GPR_CID_RELAY, GPIO_BIT_CID_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_CID_RELAY, GPIO_BIT_CID_RELAY, DEACTIVATE);
  #endif
}


/*******************************************************************************
/
/    Procedure:     set_dsvd_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of DSVD relay.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_dsvd_relay (ubyte state)
{
  #ifndef __riscos
  if( state )
      set_gpio_bit ((uword *) GPR_DSVD_RELAY, GPIO_BIT_DSVD_RELAY, ACTIVATE);
  else
      set_gpio_bit ((uword *) GPR_DSVD_RELAY, GPIO_BIT_DSVD_RELAY, DEACTIVATE);
  #endif
}

/*******************************************************************************
/
/    Procedure:     set_hook_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets GPIO bits to change status of hook relay.
/                   This method bypasses the Cutlass chip and uses Musket to
/                   directly access its hook GPIO pin, instead of sending
/                   a PACKET_MODEM_HOOK_RELAY to Cutlass.
/
/    Input Parameters:   ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
extern ubyte do_it_once; /* ramn 7/9/96 */
extern osilating; /* ramn 9/26/96 */

void set_hook_relay (ubyte state)
{

	/*
		if ring is on do not go off hook, wait for ring to go away then go off
		hook.
		value 2 is really RINGON .
		ramn 9/26/96

	*/
   while (osilating)
		process_wait();

  if( state )
    #ifdef __riscos
      dp_voice_set_gpio (~GPIO_OFF_HOOK_RELAY, GPIO_WRITE_AND_BYTE,
                          GPIO_BANK_INTERNAL);
    #else
      set_gpio_bit ((uword *) GPR_HOOK_RELAY, GPIO_BIT_HOOK_RELAY, ACTIVATE);
    #endif
  else
  {
    #ifdef __riscos
      dp_voice_set_gpio (GPIO_OFF_HOOK_RELAY, GPIO_WRITE_OR_BYTE,
                         GPIO_BANK_INTERNAL);
    #else
      set_gpio_bit ((uword *) GPR_HOOK_RELAY, GPIO_BIT_HOOK_RELAY, DEACTIVATE);
    #endif

/* this is flag used to set when we go offhook for dialing invoice mode
	need to reset it here */
		do_it_once = FALSE;  /* ramn 10/23/96 */
		handset_offhook_flag = FALSE;		/* ramn 10/25/96 */

	/*
		when hanging up make sure that the callerid relay is also off
		This may be needed if +VCID=1 and some how call answered on first
		ring
	*/
	set_callerid_relay( CID_RELAY_OFF);	/* ramn 12/19/96 */

  }
}

/*******************************************************************************
/
/    Procedure:     get_hook_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine returns the status of
/                   Hook Relay.
/
/    Input Parameters:   None
/
/    Output Parameter:   ubyte - OHREL state (ON, OFF)
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_hook_relay (void)
{
  #ifdef __riscos
  ubyte relay_state;

  relay_state = dp_voice_set_gpio (GPIO_OFF_HOOK_RELAY, GPIO_READ_BYTE,
                                   GPIO_BANK_INTERNAL);
  if (relay_state & GPIO_OFF_HOOK_RELAY)        /* Pins are active LOW */
    return (0);
  else
    return (1);
  #else
  uword gpio_state, *reg;
  uword mask;

  /* 1st read the state of the register that contains HOOK relay */
  reg = (uword *) GPR_HOOK_RELAY;
  gpio_state = (uword) *reg;
  mask = (1 << GPIO_BIT_HOOK_RELAY);

  /* If HOOK bit is set, return OFF */
  if (gpio_state & mask)
    return 0;
  else
    return 1;
  #endif

}

/*******************************************************************************
/
/    Procedure:     get_phone_relay
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine returns the status of
/                   Local Phone Off Hook Detect.
/
/    Input Parameters:   None
/
/    Output Parameter:   ubyte - LPOHD state (ON, OFF, UNDETERMINED)
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_phone_relay (void)
{
  #ifdef __riscos
  return 0;
  #else
  uword gpio_state, *reg;
  uword mask;

  /* First read the state of the register that contains LPOHD
     (local phone off-hook detect). */
  reg = (uword *) GPR_PHONE_RELAY;
  gpio_state = (uword) *reg;
  mask = (1 << GPIO_BIT_LOCAL_PHONE_RELAY);

  /* If LPOHD bit is set, return ON */
#if 0
  if (gpio_state & mask)
    return 0;
  else
    return 1;
#endif

  /* If LPOHD bit is set, return ON */
/*rjmw95*/

  if (gpio_state & mask)
  {
     phone_relay_timer = 0;
     return 0;
  }
  else
  {
     /*  debounce for 100ms -- incoming ring falsely triggers phone relay  */
     if (phone_relay_timer ==  0)
     {
        phone_relay_timer = 11;
        return (0);
     }
     else
     {
        if (phone_relay_timer == 1)
           return 1;
        else
           return 0;
     }
  }
  #endif
}

/****************************************************************************
 *
 *   Routine:           set_spk_hs_relay()
 *
 *   Author:            RSA
 *
 *   Creation Data:     17/2/1996
 *
 *   Description:
 *
 *   Input Parameters:  ubyte state
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/

extern ubyte fax_class;

void set_spk_hs_relay( ubyte state)
{
	if(fax_class == 8)	/* added by ramn on 5/31/96 */
	{
	   #ifdef __riscos
	   if( state )
             dp_voice_set_gpio (~GPIO_SPK_HS_RELAY, GPIO_WRITE_AND_BYTE,
                                 GPIO_BANK_INTERNAL);
	   else
             dp_voice_set_gpio (GPIO_SPK_HS_RELAY, GPIO_WRITE_OR_BYTE,
                                GPIO_BANK_INTERNAL);
	   #else
	   if( state )
   	   set_gpio_bit ((uword *)GPR_SPK_HS_RELAY, GPIO_BIT_SPK_HS_RELAY, ACTIVATE);
	   else
   	   set_gpio_bit ((uword *)GPR_SPK_HS_RELAY, GPIO_BIT_SPK_HS_RELAY, DEACTIVATE);
   	   #endif
	}
}

#ifndef __riscos
/*******************************************************************************
/
/    Procedure:     set_gpio_bit
/
/    Author:   RSA
/
/    Creation Date: 12/21/95
/
/    Description:   This routine sets or clears the state of the selected
/                   GPIO pin (SINGLE BIT) on the selected GPIO register.
/                   Changing the bit requires also setting its mask bit to 1.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/                      ubyte bit_location - Which bit to change in the
/                        register specified by *gpr.
/
/                      ubyte state - ON or OFF
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
/*-------------------------------------------------------------------

   GPR0, GPCR0 contains GPIO pins 0-7
   GPR1, GPCR1 contains GPIO pins 8-15
   GPR2, GPCR2 contains GPIO pins 16-23

   Each GPR register is 16 bits wide, with alternating sequences
   of 4 mask bits and 4 GPIO bits, as shown below for GPR0:

   15 14 13 12  11 10 09 08   07 06 05 04  03 02 01 00
   M3 M2 M1 M0  G7 G6 G5 G4   M3 M2 M1 M0  G3 G2 G1 G0

   When writing to the GPR register, only those GPIO bits whose
   corresponding Mask bits are 1 will be affected.

   To set,   write 1 to the pin's bit and 1 to its mask bit.
   To clear, write 0 to the pin's bit and 1 to its mask bit.

   GPPFR (GPIO Pin Function Register) contains only 6 bits with
   no mask bits, so it can be set like a normal register.

------------------------------------------------------------------ */
void set_gpio_bit (uword *gpr, ubyte bit_location, ubyte state)
{
  uword gpio_snapshot, new_bitmask;

  /* First read the state of the selected register.
     gpr points to the actual on-chip memory address of the register. */
  gpio_snapshot = (uword) *gpr;

  /* Set the mask bit that corresponds to the selected GPIO pin.
     Its mask bit location is 4 bits to the left of the GPIO bit. */
  gpio_snapshot |= (1 << (bit_location + 4));

  /* Set or clear the GPIO bit based on the requested state */
  new_bitmask = (1 << bit_location);

  if (state)
    gpio_snapshot |= new_bitmask;
  else
    gpio_snapshot &= ~new_bitmask;

  /* Now write the new word to the GPIO register */
  *gpr = (uword) gpio_snapshot;
}


/*******************************************************************************
/
/    Procedure:     set_gpio_reg
/
/    Author:   RSA
/
/    Creation Date: 1/5/96
/
/    Description:   This routine sets the value of the selected GPIO register.
/                   For GPR and GPCR registers, it formats the bits to match
/                   the register definition.  For GPPFR, it just writes the
/                   new value to the register.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/                      ubyte value - Value to write to GPIO register
/                        specified by *gpr.
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
void set_gpio_reg (uword *gpio_register, ubyte value)
{
  uword new_bitmask;

  /* GPPFR register is 8 bits, but the other GPIO registers are
     16 bits with mask bits.  If not the GPPFR, then format the
     register value accordingly. */
  if (gpio_register != (uword *) GPPFR)
  {
    /* First create the register word based on the requested pin value.
       The word format is:  M7 M6 M5 M4 G7 G6 G5 G4   M3 M2 M1 M0 G3 G2 G1 G0

       GPIO pins 0-3 are represented in the lower nibble of the pin value byte
       GPIO pins 4-7 are represented in the high nibble of the pin value byte
    */
    new_bitmask = (value & 0xF0);  /* Set low byte to GPIO pins 4-7 */
    new_bitmask <<= 4;             /* Shift value into high byte / low nibble */
    new_bitmask |= (value & 0x0F); /* OR in GPIO pins 0-3 into low byte */
    new_bitmask |= 0xF0F0;         /* Set all mask bits to 1 to enable change */

    /* Write the new register value to the register memory address */
    *gpio_register = new_bitmask;
  }

  /* For GPPFR, just write the ubyte bitmask passed in */
  else
  {
    *gpio_register = value;
  }
}


/*******************************************************************************
/
/    Procedure:     get_gpio_reg
/
/    Author:   RSA
/
/    Creation Date: 1/5/96
/
/    Description:   This routine returns the value of the selected GPIO register.
/                   For GPR and GPCR registers, it removes the mask bits and
/                   formats the return byte as GPIO pins 0-7 in bits 0-7.
/                   For GPPFR, it just returns the current value.
/                   See MT_GPIO.H for a description of the GPR registers and
/                   the method for updating their values.
/
/    Input Parameters: uword * gpr - Actual register address in on-chip memory.
/                        This selects GPR0, GPR1, GPR2, GPCR0, GPCR1, GPCR2,
/                        or GPPFR.
/
/    Output Parameter:   ubyte - Value of selected register
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:     RSA 12/21/95
/    Description:
/    Reason:
/
*******************************************************************************/
ubyte get_gpio_reg (uword *gpio_register)
{
  /* GPPFR register is 8 bits, but the other GPIO registers are
     16 bits with mask bits.  If not the GPPFR, then format the
     register value accordingly. */
  if (gpio_register != (uword *) GPPFR)
  {
    uword gpio_state;
    ubyte gpio_pins_lower, gpio_pins_upper;

    gpio_state = (uword) *gpio_register;
    gpio_pins_lower = gpio_state & 0x000F;        /* Low byte to low nibble */
    gpio_pins_upper = (gpio_state & 0x0F00) >> 4; /* High byte to high nibble */
    return (gpio_pins_lower | gpio_pins_upper);
  }

  else
  {
    uword *gppfr;

    gppfr = (uword *) GPPFR;
    return ((ubyte) *gppfr);
  }
}

#endif

/* RJM040396 */
/* Moved from MT00CUST.C for Host based support */
/*******************************************************************************
/
/                                  call_progress
/
/       Author:         RSA
/
/       Creation Date:  03/01/94
/
/       Description:    This routine will return the progress of the calling
/                       sequence.  USA only
/
/       Input Parameters:       None
/
/       Output Parameter:       0 - undetermined
/                               1 - dial tone
/                               2 - ring on
/                               3 - busy
/                               4 - silence
/                               5 - ring back
/                               6 - answer tone
/                               7 - ring off
/
/       Global Variables Changed:
/
/       Users: (routines that used this)  modem_call_progress
/
/       *****************************************************************
/       *                         Modifications                         *
/       *****************************************************************
/
/       Author & Date:
/       Description:
/       Reason:
/
*******************************************************************************/
#ifdef __riscos
ubyte call_progress(void)
{
   static ubyte last_call_progress=RING_OFF;
   ubyte temp;

   temp = read_dsp_call_progress_reg();

   if ((temp == RING_OFF) && (last_call_progress != RING_ON))
      temp = UNDETERMINED;
   last_call_progress = temp;
   return(temp);
}
#else
/*22296shujin, for distinctive ring */
ubyte call_progress(void)
{
   ubyte tmp;
   static ringStatus= UNDETERMINED;

   tmp = read_dsp_call_progress_reg();

	if ( ring_on )
	{
	   ringStatus = RING_ON;
      tmp = RING_ON;
	 	return tmp;
	}
	else if ( (ring_on==FALSE) && (ring_was_on_before == TRUE)	)
	{
      tmp = RING_OFF;
      ringStatus = UNDETERMINED;
	 	return tmp;
	}
	else
   {
		if(tmp== RING_ON || tmp==RING_OFF)
		   tmp = UNDETERMINED;

      ringStatus = UNDETERMINED;
  		return tmp;
	}
}
#endif



/* added by ramn on 4/16/96 */
/* these routines were added in accordance to the new modem task
	done by Rob miller */


void dsp_reset( ubyte state)
{
   #ifdef __riscos
   #define IOMD_DA_REGISTER ((volatile ubyte *)0x032000E8)
   #define IOMD_DA_RESET 0x10
   #define IOMD_DA_CFG 0x20

   #if 0 /* PAUL */
   unsigned reg = *IOMD_DA_REGISTER;

   if (state)
      *IOMD_DA_REGISTER = reg &~ IOMD_DA_RESET;
   else
      *IOMD_DA_REGISTER = reg | IOMD_DA_RESET;
   #else
   if (state)
   {
    set_register(DSP_CFG_REG, DSP_BOOT_INT_ROM);
    set_register(CP_CONTROL, 0);
   }
   else
   {
    set_register(CP_CONTROL, 2);
   }

   #endif
   #else
   if( state )
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, DEACTIVATE);
   else
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, ACTIVATE);
   #endif
}

void dsp_hardware_reset( ubyte state) /* PAUL */
{
   #ifdef __riscos
   #define IOMD_DA_REGISTER ((volatile ubyte *)0x032000E8)
   #define IOMD_DA_RESET 0x10
   #define IOMD_DA_CFG 0x20

   unsigned reg = *IOMD_DA_REGISTER;

   if (state)
      *IOMD_DA_REGISTER = reg &~ IOMD_DA_RESET;
   else
      *IOMD_DA_REGISTER = reg | IOMD_DA_RESET;
   #else
   if( state )
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, DEACTIVATE);
   else
      set_gpio_bit ((uword *)GPR_DSP_RESET_RELAY, GPIO_BIT_DSP_RESET_RELAY, ACTIVATE);
   #endif
}

void dsp_cfg( ubyte state)
{
   #ifdef __riscos
   unsigned reg = *IOMD_DA_REGISTER;

   if (state)
      *IOMD_DA_REGISTER = reg &~ IOMD_DA_CFG;
   else
      *IOMD_DA_REGISTER = reg | IOMD_DA_CFG;
   #else
   if( state )
      set_gpio_bit ((uword *)GPR_DSP_CFG_RELAY, GPIO_BIT_DSP_CFG_RELAY, DEACTIVATE);
   else
      set_gpio_bit ((uword *)GPR_DSP_CFG_RELAY, GPIO_BIT_DSP_CFG_RELAY, ACTIVATE);
   #endif
}



/*** till here by ramn *****/

/* RJM052996 */
/* Beta App support */
void set_register(ubyte addr, ubyte data)
{
  ubyte *temp;

  temp = (ubyte *)(COM_RAM + (addr * WORD_OR_BYTE_ADD_INC));
  *temp = data;
}

ubyte get_register(ubyte addr)
{
  ubyte *temp;

  temp = (ubyte *)(COM_RAM + (addr * WORD_OR_BYTE_ADD_INC));
  return (*temp);
}


#ifdef __riscos
/****************************************************************************
 *
 *   Routine:           RunDSP()
 *
 *   Author:            RSA
 *
 *   Creation Data:     03/05/1997
 *
 *   Description: Beta Card/EEB routine to take the DSP out of tristate.
 *
 *   Input Parameters:  None
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/

void RunDSP(void)
{
   ulong time;

   set_register(CP_CONTROL, DSP_RUN);

   /* Settling time */
   for( time=0; time<0xFFFFL; time++ );
       /* dum dee dum dum */

}

/****************************************************************************
 *
 *   Routine:           HaltDSP()
 *
 *   Author:            RSA
 *
 *   Creation Data:     03/05/1997
 *
 *   Description: Beta Card/EEB routine to halt the DSP.
 *
 *   Input Parameters:  None
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/

void HaltDSP(void)
{
   ulong time;

   set_register(DSP_CFG_REG, DSP_BOOT_INT_ROM);
   set_register(CP_CONTROL, DSP_RESET);

   /* Settling time */
   for( time=0; time<0xFFFFL; time++ );
       /* dum dee dum dum */

}

/****************************************************************************
 *
 *   Routine:           ResetDSP()
 *
 *   Author:            RSA
 *
 *   Creation Data:     17/12/1996
 *
 *   Description: Beta Card/EEB reset routine for DSP internal code.
 *
 *   Input Parameters:  None
 *
 *   Output Parameters: Nothing
 *
 *   Global Variables Changed: None
 *
 *   Users:
 *
 *   -----------------------------------------------------------
 *   -                       Modifications                     -
 *   -----------------------------------------------------------
 *
 *   Author & Date:  RSA
 *   Description:
 *   Reason:
 *
 ****************************************************************************/

void ResetDSP(void)
{
   #ifdef DEBUG
   extern void dump_svc_stack(void);
   dump_svc_stack();
   #endif
   HaltDSP();

   RunDSP();

   /*  wake up the DSP  */
   LOAD_MODEM_WAKEUP_DSP
        ack_or_response = ACK;
   send_pkt_to_dsp();

   /* Need to download patches again */
   //dsppatch();  /* Download the Cutlass DSP patch file */
//
        LOAD_MODEM_INIT
        ack_or_response = ACK;
        send_pkt_to_dsp();
        voice_patch_dnlded = FALSE;
}

#endif
