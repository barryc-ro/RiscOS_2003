/******************************************************************************
/
/     Copyright, 1988, 1989, 1990, 1991, 1992, 1993, 1994. All Rights Reserved by:
/        RSA
/        7701 Six Forks Road
/        Suite 120
/        Raleigh, NC  27615
/        (919) 846-7171
/
/     This document contains material confidential to R. Scott Associates.
/     its contents must not be revealed, used or disclosed to anyone or
/     company with out written permission by R. Scott Associates.  the
/     information contained herein is solely for the use of R. Scott
/     Associates.
/
/       File:            mt00mn10.c
/
/       Version:        1.00
/
/       Function:       Main
/
/       Product:        Modem Task Driver for Merlin Chip Sets
/
/       History:
/
/       Created:        3/01/94
/
/        ------------------------------------------------------
/        -               Modifications             -
/        ------------------------------------------------------
/
/
******************************************************************************/

#include  "SYS_DEF.H"
#include  "cp_dsp.h"
#include  "MT_CODEF.H"
#include  "MT_HWDEF.H"
#include  "MT_COPRO.H"
#include  "MT_HWPRO.H"
#include  "MT_V8V34.H"
#include  "MT_COEXT.H"
#include  "mt_macro.h"

/* RJM040396 */
/* VCV support */
#include "vcv_def.h"
#include "vcv_cpro.h"

void update_modem_status(void);
void mt_bg(void);
void mt_timer(void);
void mt_reset(void);
void mt_drop(ubyte);
void mt_connect(ubyte, ubyte, ubyte, ubyte, ubyte, ubyte, ubyte, ubyte,ubyte);
/**start change for v8/v34 support ***************************************/
/* void mt_set_rate_seq(ubyte);                                          */
void mt_set_rate_seq(uword,uword);
void v8_orig(void);
void v8_answ(void);
void set_v8_tx_msg(void);
/****end change for v8/v34 support ***************************************/
void mt_return_to_idle(void);

/*MRM22096*/
/*timer for v32bis timeout when in v34 mode */
uword     v8_timer ;
uword     sq_timer ;
uword cd_timer = 0; /* ramn 3/2/96 */
uword sig_chk_timer = 0; /* ramn 3/5/96 */
extern ubyte spd_of_prv_conn_up; /* ramn 3/16/96 */
extern ubyte spd_of_prv_conn_dn; /* ramn 3/16/96 */
extern ubyte rtr_timer; /* ramn 3/19/96 */
extern ubyte modem_mode;  /* ramn 3/12/96 */

void disable_tap_display(void); /* ramn 4/18/96 */
extern ubyte dsp_response_data[15]; /* ramn 4/18/96 */
extern uword rtrn_timer_set; /* ramn 11/21/96 */

/*******************************************************************************
/
/    update_modem_status
/
/    Author:   RSA
/
/    Creation Date: 10/01/94
/
/    Description:   This routine will read modem status from the DSP
/                       and map it from CONNECTED to REMOTE_TEST when
/                       necessary.  It also needs to map RENEGOTIATING
/                       to RETRAIN.
/
/    Input Parameters:   None
/
/    Output Parameter:   None
/
/    Global Variables Changed:   modem_status
/
/    Users: (routines that used this)   mt_bg
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
*******************************************************************************/

void update_modem_status(void)

{
   modem_status = read_dsp_modem_status_reg() & MODEM_STATUS_MASK;

   /*   map modem status RENEGOTIATING to RETRAINING   */
   /*if (modem_status == 9)*/	 /* rate reneg value changed from 9 to 0xD */
   if (modem_status == 13)	  /* ramn 11/21/96 */
	modem_status = RETRAINING;

   else if ((modem_status == CONNECTED) &&
	    (received_RDL || digital_loopback_on))
	modem_status = REMOTE_TEST;

   /*   look for case where DP drops   */
   if (modem_status == DROPPING)
	modem_state = DROP1;

}


/*******************************************************************************
/
/                     mt_bg
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine is called by the host to update the modem
/                   task state machine.
/
/    Input Parameters:   None
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)   modem_task
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
*******************************************************************************/
void mt_bg(void)
{
   update_modem_status();

   switch  (modem_state)
   {
	case (IDLE):
	   break;

	case (ORIG):
	  if (!s7_timer)
	  	modem_state = DROP1;

	  if (modem_status == CONNECTED)
		modem_state = CON;
	  else if (modem_status == IDLE)
		modem_state = DROP1;

/**start change for v8/v34 support **********/
	  if (v8_configured)
		   v8_orig();
/**end change for v8/v34 support ************/

/* ramn 4/18/96 */
		disable_tap_display();
	break;

	case (ANSW):
	  if (!s7_timer)
	   modem_state = DROP1;

	  if (modem_status == CONNECTED)
		modem_state = CON;
	  else if (modem_status == IDLE)
		modem_state = DROP1;

/**start change for v8/v34 support **********/
	  if (v8_configured)
		   v8_answ();
/**end change for v8/v34 support ************/

/* ramn 4/18/96 */
		disable_tap_display();

	break;

	case (CON):
	connect_processor();
	   check_rdl();
	   break;

	case (DROP1):
	   /*   reset variables   */
	   fall_back_en = TRUE;
	   fall_frwd_en = FALSE;
	   fall_back_attempt = FALSE;
	   fall_frwd_attempt = FALSE;
	   received_RDL = FALSE;
	   digital_loopback_on = FALSE;
	   modem_state = DROP2;
	   drop_flag = FALSE;
		rtrn_timer_set = FALSE;	/* ramn 11/21/96 */

/* reset the speed variable used in reneg for next conn */
/* ramn 3/14/96 */
			spd_of_prv_conn_up = 0 ;
			spd_of_prv_conn_dn = 0 ;


	   /*
	   current_command [0] = PACKET_MODEM_INIT;
	   current_command [1] = 0x00;
	   current_command [2] = PACKET_MODEM_INIT_LEN;
	   current_command [3] = 0x00;
	   while (error_occured = cp_dsp());
	   while (error_occured = dsp_acknowledge_packet());
	   */

	   LOAD_MODEM_INIT
	   ack_or_response = ACK;
	   send_pkt_to_dsp();

	   init_call_progress(ON_HOOK);
	   break;

	case (DROP2):
		rtrn_timer_set = FALSE;	/* ramn 11/21/96 */
	   if (modem_status == IDLE)
		modem_state = IDLE;
	   break;

	case (RETRAIN):
	   retrain_processor();
	   break;

	case (FAX_ANSW):
	   if (modem_status == FAX_CONNECTED)
		 modem_state = FAX_CON;
	   else if (modem_status == IDLE)
		modem_state = FAX_DROP;
	   break;

	case (FAX_ORIG):
	   if (modem_status == FAX_CONNECTED)
		modem_state = FAX_CON;
	   else if (modem_status == IDLE)
		modem_state = FAX_DROP;
	   break;

	case (FAX_CON):
	   if (modem_status == IDLE)
		modem_state = FAX_DROP;
	   break;

	case (FAX_DROP):
	   if (modem_status == IDLE)
		modem_state = IDLE;
	   break;

	case (FAX_AUTO_ANSWER):
	   if (modem_status == FAX_CONNECTED)
		modem_state = FAX_CON;
	   else if (modem_status == IDLE)
		modem_state = IDLE;
	   break;

	case (VOICE_CON):
	   break;

   /* RJM042696 */
/* VCV V.29 Rx workaround */
   case VCV_WAIT_RDATA:
     /* Read DSP location 0x2D (ESTATE) until it becomes > RDATA1(0X0E) */
     low_location = 0x2d;
     high_location = 0x00;
     LOAD_MODEM_READ_DSP_PACKET_BANK0

	  dsp_cp_packet = 0x15;
     ack_or_response = RESPONSE;
     send_pkt_to_dsp();

     switch( dsp_response_data[0] )
     {
         case 0x0E:  /* RDATA1 */
         case 0x0F:  /* RDATA2 */
             /* Set data state to RDATA3 */
             low_value=0x10;
             high_value=0x00;
             LOAD_MODEM_WRITE_DSP_PACKET_BANK0

             ack_or_response = NO_REPLY;
             send_pkt_to_dsp();
             break;

         case 0x10:  /* RDATA3 */
             modem_state = VCV_WAIT_ETIMER_DEC;
             break;

         default:
             break;
     }
     break;

   case VCV_WAIT_ETIMER_DEC:
     /* Get initial value of ETIMER */
     low_location = 0xdd;
     high_location = 0x00;
     LOAD_MODEM_READ_DSP_PACKET_BANK0

     dsp_cp_packet = 0x15;
     ack_or_response = RESPONSE;
     send_pkt_to_dsp();

     if( dsp_response_data[0] < 4 )
     {
         /* Write 0x20 to DSP location 0x3E (ETIMER) */
         low_value=0x20;
         high_value=0x00;
         LOAD_MODEM_WRITE_DSP_PACKET_BANK0

         ack_or_response = NO_REPLY;
         send_pkt_to_dsp();

         modem_state = VOICE_CON;
     }
     break;
   }


}

/*******************************************************************************
/
/                      mt_timer
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will update modem task timers.
/                       It should be called every 10 ms.
/                   All timers in the modem task are 10ms timers
/
/    Input Parameters:   None
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)  modem_timer
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
*******************************************************************************/
void mt_timer(void)
{
   /*  These timers count down to one.  Zero is the inactive state  */
   if (mse_poor_timer > 1)
	 mse_poor_timer--;

   if (mse_good_timer > 1)
	 mse_good_timer--;

   if (mse_invalid_timer > 1)
	 mse_invalid_timer--;

   if (retrain_timer > 1)
	 retrain_timer--;

/*rjmw95*/

	if (phone_relay_timer > 1)
	 phone_relay_timer--;

   if (dsp_timer)
	dsp_timer--;

/*MRM22096*/
/*timer for v32bis timeout when in v34 mode */

	if   (v8_timer)
		v8_timer--;

/*MRM22996*/

	if   (sq_timer)
		sq_timer--;

	if(cd_timer)
		cd_timer--; /* ramn 3/2/96 */

	if(sig_chk_timer)     /* ramn 3/5/96 */
		sig_chk_timer--;

    if (mt_cts_timer)
	mt_cts_timer--;

   if (s7_timer)
	s7_timer--;

/**start change for v8/v34 support **********/
   if (CI_silence_timer)
	CI_silence_timer--;
/**end change for v8/v34 support ************/

}

/*******************************************************************************
/
/                   mt_reset
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will terminate all activities and return
/                       the modem to its initial power-up IDLE state.
/
/    Input Parameters:   None
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/                                       dtmf_tone_duration
/                                       dtmf_interdigit_delay
/
/    Users: (routines that used this)  modem_reset
/                                              acu_reset
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void mt_reset(void)
{
   /*   Disconnect modem processing   */
   set_hook_relay(OFF);
   set_speaker(OFF);

   modem_state = IDLE;

   dtmf_tone_duration = default_dtmf_tone_duration;
   dtmf_interdigit_delay = default_dtmf_interdigit_delay;

    /*
    current_command [0] = PACKET_MODEM_INIT;
    current_command [1] = 0x00;
    current_command [2] = PACKET_MODEM_INIT_LEN;
    current_command [3] = 0x00;
    while (error_occured = cp_dsp());
    while (error_occured = dsp_acknowledge_packet());
    */

    LOAD_MODEM_INIT
    ack_or_response = ACK;
    send_pkt_to_dsp();

   init_call_progress(ON_HOOK);

   fall_back_en = TRUE;
   fall_frwd_en = FALSE;
   fall_back_attempt = FALSE;
   fall_frwd_attempt = FALSE;
   received_RDL = FALSE;
   check_RDL_flag = FALSE;
   drop_flag = FALSE;
	rtrn_timer_set = FALSE;	/* ramn 11/21/96 */
}


/*******************************************************************************
/
/                     mt_drop
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will force the modem task to DROP1 state.
/
/    Input Parameters:   v32_cleardown_enabled = 0 Disabled
/                                  1 Enabled
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users: (routines that used this)  modem_drop
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void mt_drop(ubyte v32_cleardown_enable)
{
   if ( (modem_status != IDLE) && (v32_cleardown_enable) &&
	  /*chk_if_v32_line_mode() &&*/ (!drop_flag) )
   {
/**start change for v8/v34 support **********/
/* mt_set_rate_seq(0);                      */
   mt_set_rate_seq(0,0);
/**end change for v8/v34 support ************/

	  bit_rate = 0;
	  dsp_mode = modem_mode;

	  current_command[4] = 0;  /* ramn 3/5/96 */
	  current_command[5] = 0;
	  LOAD_MODEM_RENEGOTIATE
	  ack_or_response = ACK;
  	  send_pkt_to_dsp();
	  mt_renegotiate();	/* ramn 6/10/96 */
	  /*modem_state = DROP1;*/ 	/* ramn 6/10/96 */
	  drop_flag = TRUE;
   }

   /*   send modem init to drop   */
   else
	modem_state=DROP1;
}


/*******************************************************************************
/
/                     mt_connect
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will initiate the handshake process.
/              It sets modem_state to either ANS1 or ORG1 state.
/
/
/    Input Parameters:
/         ubyte answer:
/                   0 = answer mode
/                   1 = originate mode
/
/         ubyte bit rate:
/                   0 = 75/600 bps
/                   1 = 75/1200 bps
/                   2 = 300 bps
/                   3 = 1200 bps
/                   4 = 2400 bps
/                   5 = 4800 bps
/                   6 = 7200 bps
/                   7 = 9600 bps
/                   8 = 12000 bps
/                   9 = 14400 bps
/                 10 = 16800 bps
/                 11 = 19200 bps
/                 12 = 24000 bps
/                 13 = 28800 bps
/                 14 = reserved
/           15 = reserved
/
/         ubyte configuration mode:
/                   0 = Bell 103
/                   1 = Bell 212A
/                   2 = V.21
/                   3 = V.21 Channel 2
/                   4 = V.23 ADX
/                   5 = V.23 HDX
/                   6 = V.22
/                   7 = V.22bis
/                   8 = V.27 short
/                   9 = V.27 long
/                   10 = V.27 ter
/                   11 = V.29
/                   12 = V.32 bis
/                   13 = V.17 short
/                   14 = V.17 long
/                   15 = voice
/
/         ubyte clock_code:
/                   0 = TXC from modem
/                   1 = TXC from DTE, pin 24
/                   2 = TXC from RXC
/
/         ubyte leased:
/                   0 = PSTN
/                   1 = 2 wire leased
/                   2 = 4 wire leased
/
/         ubyte automode:
/                   0 = off
/                   1 = on
/
/         ubyte fax connection type:
/                   0 = data only
/                   1 = fax only
/                   2 = data and fax
/
/         ubyte call_tone_enabled:
/                   0 = call tone off
/                   1 = call tone on
/
/      fax connection type is not used in this version
/
/    Output Parameter:   None
/
/    Global Variables Changed:
/
/    Users:    modem_connect()
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
*******************************************************************************/
void mt_connect(ubyte orig, ubyte bit_rate, ubyte mode, ubyte clock_code,
		   ubyte leased, ubyte automode, ubyte fax, ubyte call_tone_enabled,ubyte etc_enabled)
{
    ubyte dsp_mode, trellis;
    ubyte line_select,v25_procedure,etc_mode,v8_mode,v23_mode,modem_b_loop;

    line_select = 0;
    etc_mode = 0;
    v8_mode = 0 ;
    v23_mode = 0;
    modem_b_loop = 0;

/***start change for v8/v34 support ***************/
    /* save connect params for issuing V8 second connect to DSP */
    mt_conn_orig       = orig;
    mt_conn_bit_rate   = bit_rate;
    mt_conn_mode       = mode;
    mt_conn_clock_code = clock_code;
    mt_conn_leased     = leased;
    mt_conn_automode   = automode;
    mt_conn_fax        = fax;
    mt_conn_etc_enabled= etc_enabled;
    mt_conn_call_tone_enabled = call_tone_enabled;

   /* set modem module word based on connect paramter */

   if (automode)
   {
	 v8_mod_modes = V8_MOD_MODE_DEFAULT;
	 if (mode < MT_V34)
	 {
	    v8_mod_modes &= ~V34FULL_MASK;
	    v8_mod_modes &= ~V34HALF_MASK;
	 }
	 if (mode < MT_V32)
	 {
	    v8_mod_modes &= ~V32_MASK;
	 }
	 if (mode < MT_V29)
	 {
	    v8_mod_modes &= ~V29HALF_MASK;
	 }
	 if (mode < MT_V23_HDX)
	 {
	    v8_mod_modes &= ~V23FULL_MASK;
	    v8_mod_modes &= ~V23HALF_MASK;
	 }
	 if (mode < MT_V21)
	 {
	    v8_mod_modes &= ~V21_MASK;
	 }
   }
   else /* NOT automoding, issue only 1 connect rate */
   {
	 v8_mod_modes = 0;
	 switch (mode)
	 {
	    case (MT_V34):
		  v8_mod_modes |= V34HALF_MASK;
	    break;

	    case (MT_V32):
		  v8_mod_modes |= V32_MASK;
	    break;

	    case (MT_V29):
		  v8_mod_modes |= V29HALF_MASK;
	    break;

	    case (MT_V23_HDX):
		  v8_mod_modes |= V23FULL_MASK;
		  v8_mod_modes |= V23HALF_MASK;
	    break;

	    case (MT_V21):
		  v8_mod_modes |= V21_MASK;
	    break;
	 }
   }

   set_v8_tx_msg();
/***end change for v8/v34 support ***************/

    /*    set modem_state    */
    if ( (fax == 2) && (!orig) )
	 modem_state = FAX_AUTO_ANSWER;
    else if (fax == 1)
    {
	   if (!orig)
		{
	    modem_state=FAX_ANSW;
/*MRM2296 no v8 mode and auto mode in fax mode*/
			v8_configured = FALSE;
			automode = FALSE;
		}
	 else    /* originating */
		{
/*MRM2296 no v8 mode and auto mode in fax mode*/
			modem_state=FAX_ORIG;
			v8_configured = FALSE;
			automode = FALSE;
		}

    }
    else if (fax == 3)
	 {
/*MRM2296 no v8 mode and auto mode in voice mode*/
	modem_state = VOICE_CON;
		v8_configured = FALSE;
		automode = FALSE;
	 }
    /* process answer or originate mode */
    else if (!orig)
    {
	 modem_state=ANSW;
	 if (CM_received)
	    v8_mode = CM_RXD;
    }
    else /*originate*/
    {
	 modem_state=ORIG;
	 if (JM_received)
	    v8_mode = JM_RXD;
    }

/***start change for v8/v34 support *************/
/*   if (mode > MT_V22BIS)                      */
/*     dsp_mode = 0x0C;                         */
/*   else                                       */
/***end change for v8/v34 support ***************/
	  dsp_mode = mode;


   if (mode == MT_V32)
	trellis = 1;
   else
	trellis = 0;


/*mrm31496*/
/*if v23 mode and we are originating*/

   if ((mode == 4) || (mode == 5))

	{
		if(orig)
			v23_mode = 1;
   }
    /*
    current_command [0] = PACKET_MODEM_CONNECT;
    current_command [1] = 0x00;
    current_command [2] = PACKET_MODEM_CONNECT_LEN;
    current_command [3] = 0x00;

   packetize_parameter(bit_rate, CONNECT_BIT_RATE_BYTE, CONNECT_BIT_RATE_START_BIT);
   packetize_parameter(clock_code, CLOCK_SOURCE_BYTE, CLOCK_SOURCE_START_BIT);
   packetize_parameter(dsp_mode, CONFIG_MODE_BYTE, CONFIG_MODE_START_BIT);
   packetize_parameter(line_select, LINE_SELECT_BYTE, LINE_SELECT_START_BIT);
   packetize_parameter(call_tone_enabled, V25_PROCEDURE_BYTE, V25_PROCEDURE_START_BIT);
   packetize_parameter(answer, CHANNEL_BYTE, CHANNEL_START_BIT);
   packetize_parameter(automode, AUTOMODE_V8_BYTE, AUTOMODE_V8_START_BIT);
   packetize_parameter(fax, CONNECTION_TYPE_BYTE, CONNECTION_TYPE_START_BIT);
   packetize_parameter(etc_mode, ENHANCED_THRO_CELL_BYTE, ENHANCED_THRO_CELL_START_BIT);
   packetize_parameter(v8_mode, V8_INFORMATION_BYTE, V8_INFORMATION_START_BIT);
   packetize_parameter(v23_mode, V23_FRWD_BKWD_CH_BYTE, V23_FRWD_BKWD_CH_START_BIT);
   packetize_parameter(mt_retrain_enable, V22SQ_RETRAIN_BYTE, V22SQ_RETRAIN_START_BIT);
   packetize_parameter(modem_b_loop, MODEM_B_LOOP2_BYTE, MODEM_B_LOOP2_START_BIT);
   packetize_parameter(trellis, TRELLIS_BYTE, TRELLIS_DISABLE_START_BIT);
   while (error_occured = cp_dsp());
   while (error_occured = dsp_acknowledge_packet());
   */
   LOAD_MODEM_CONNECT
   ack_or_response = ACK;
   send_pkt_to_dsp();

   /*   set timers inactive   */
   retrain_timer = 0;
   mse_good_timer = 0;
   mse_poor_timer = 0;
   mse_invalid_timer = 0;
   s7_timer = cd_wait_time;

   fall_frwd_en = FALSE;
   fall_back_attempt = FALSE;
   fall_frwd_attempt = FALSE;
   determine_fall_back_en();
}


/*******************************************************************************
/
/                     mt_set_rate_seq
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine will inform the modem task the selected
/                        baud rates for the connection
/
/    Input Parameters: ubyte rates - selected baud rates. Values may be added
/                             together to specify several speeds.
/                              When viewed as 8 bit number the value is
/                              bit mapped.
/
/                          Value     Baud Rate
/                              1      reserved
/                              2      4800
/                               4     7200
/                               8     9600
/                              16     12000
/                              32     14400
/                              64     reserved
/                             128     reserved
/
/    Output Parameter:   None
/
/    Global Variables Changed: possible_rates, max_rate
/
/    Users: modem_set_rate_seq()
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
/***start change for v8/v34 support **************/
/* void mt_set_rate_seq(ubyte rates)             */
/* {                                             */
/*    possible_rates = rates;                    */
void mt_set_rate_seq(uword tx_rx,uword rx_only)
{
/***end change for v8/v34 support ***************/

   /*
   current_command [0] = PACKET_MODEM_SET_RATE_SEQ;
   current_command [1] = 0x00;
   current_command [2] = PACKET_MODEM_SET_RATE_SEQ_LEN;
   current_command [3] = 0x00;
   current_command [4] = rates;

   while (error_occured = cp_dsp());
   while (error_occured = dsp_acknowledge_packet());
   */

   LOAD_MODEM_SET_RATE_SEQ
   ack_or_response = ACK;
   send_pkt_to_dsp();

   #if 0
   command_packet[RATE_SEQ_BYTE] = rates;
   send_pkt_to_dsp(PACKET_MODEM_SET_RATE_SEQ, MODEM_SET_RATE_SEQ_LEN, ACK_NEEDED);
   #endif
}

/*******************************************************************************
/
/    Procedure:     mt_return_to_idle
/
/    Author:   RSA
/
/    Creation Date: 03/01/94
/
/    Description:   This routine cause the modem task to return to the
/                       IDLE state.
/
/    Input Parameters:   None
/
/    Output Parameter:   None
/
/    Global Variables Changed:     None
/
/    Users:
/
/    *****************************************************************
/    *                Modifications               *
/    *****************************************************************
/
/    Author & Date:
/    Description:
/    Reason:
/
*******************************************************************************/
void mt_return_to_idle(void)
{
    /*
    ubyte error_occured;
    current_command [0] = PACKET_MODEM_INIT;
    current_command [1] = 0x00;
    current_command [2] = PACKET_MODEM_INIT_LEN;
    current_command [3] = 0x00;
    while (error_occured = cp_dsp());
    while (error_occured = dsp_acknowledge_packet());
    */

    LOAD_MODEM_INIT
    ack_or_response = ACK;
    send_pkt_to_dsp();

	 if(drop_flag)				 /* ramn 6/10/96 */
			drop_flag = FALSE; /* ramn 6/10/96 */

    /* Return data pump to idle state */
    modem_state = IDLE;
    init_call_progress(ON_HOOK);
}




/***************************************************************************
*
*  added by ramn 4/18/96
*
*  this routine disables the tap display routine that is running in the dsp
*	this code needs to be disabled for both J5 and C6 codes
*
*
****************************************************************************/

void disable_tap_display(void)
{
    #ifndef __riscos
	uword peek_value;
	ubyte dram_bank1_addr_lo, dram_bank1_addr_hi,dram_bank1_data_lo,dram_bank1_data_hi;
	ubyte pram_addr_lo, pram_addr_hi,mcon_lo,mcon_hi;

	ubyte *temp;

	mcon_lo = 0;
	mcon_hi = 0;
	pram_addr_lo = 2;
	pram_addr_hi = 0;

 	LOAD_DSP_PROGRAM_MEMORY_READ

	dsp_cp_packet = PACKET_PROGRAM_MEM_READBACK;
   ack_or_response = RESPONSE;
   send_pkt_to_dsp();


	peek_value = (dsp_response_data[6] << 8);
	peek_value |= dsp_response_data[7];

	if(peek_value == 0x0307)
	{
		dram_bank1_addr_lo = 0xdc;
		dram_bank1_addr_hi = 0;
		dram_bank1_data_lo = 0x6;
		dram_bank1_data_hi = 0;

		LOAD_DATA_MEM_WRITE_BANK1

/* need to do this because the poke commands donot send ack packet C0 */
		temp = (ubyte *)(COM_RAM);
		*temp = 0x0c0;

	 	ack_or_response = 0;
	 	send_pkt_to_dsp();
	}
	else
		return;
    #endif
}


/*************** till here by ramn ******************************************/
