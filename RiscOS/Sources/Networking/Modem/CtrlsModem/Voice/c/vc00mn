/******************************************************************************
/
/   Copyright 1994, 1995
/   All Rights Reserved by :
/	 RSA
/	 7701 Six Forks Road
/	 Suite 120
/	 Raleigh, NC  27615
/	 (919) 846-7171
/
/   This document contains material confidential to RSA. Its contents
/   must not be revealed, used or disclosed to anyone or company without
/   written permission by RSA. The information contained herein is solely
/   for the use of RSA.
/
/   File     : vc00mn.c
/
/   Version  : 1.00
/
/   Function : Contains the core routines for the voice module.
/
/   Product  : Voice Core Code
/
/   History  :
/
/   Created  : 1/14/93
/
/   -----------------------------------------------------------
/   -			    Modifications		      -
/   -----------------------------------------------------------
/
/   Author & Date:
/   Description:
/   Reason:
/
******************************************************************************/
#include "sys_def.h"
#include "vce_def.h"
#include "vce_mem.h"
#include "vce_cpro.h"
#include "func_mac.h"
#include "voc_icd.h"
#include "..\mt_ctls1\cp_dsp.h"
#include "..\mt_ctls1\mt_macro.h"

void vce_init(ubyte);
ubyte vce_bg(ubyte **);
ubyte process_dle_command(void);
void send_voice_data(ubyte);
void vce_timer(void);
void vce_configure(ubyte, ubyte, ubyte, ubyte, ubyte);
void vce_hangup(void);
void vce_connect(ubyte);
void vce_start(void);
void vce_reset(void);
void vce_enable_inact_timer(void);
void vce_enable_cadence_rpt(ubyte, ubyte);
void vce_rpt_ctl_cadence(ubyte, ubyte *, ubyte *);

void unpack_and_send_data(ubyte ch); /* ramn 2/16/96 */
void pack_data_and_send(void); /* ramn 2/16/96 */

ubyte time_since_entering_plbmode; /* ramn 6/25/96 */

/*******************************************************************************
/
/   Routine: vce_init
/
/   Author: RSA
/
/   Creation Date: 10/7/92
/
/   Description: This routine is called to determine the voice capabilities.
/
/   Input Parameters: ubyte type - type of hangup
/                       0 - Do not reset parameters
/                       1 - Reset parameters
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:     
/   Description: 
/   Reason:
/
*******************************************************************************/
void vce_init(ubyte type)
{
    ubyte i;
        
    voice_dte_info(&vce_buffer_size,&vce_dte_XOFF_level,&vce_dte_XON_level);

    dp_vce_get_capability((ubyte *)&vce_num_of_methods,
	                 (ubyte *)&vce_rcv_gain_range[0],
		         (ubyte *)&vce_receive_gain,
		         (ubyte *)&vce_tx_vol_range[0],
		         (ubyte *)&vce_transmit_volume,
		         (uword *)&vce_io_devices,
		         (ubyte *)&vce_comp_index,
		         (ubyte *)&vce_bits_per_sample,
		         (uword *)&vce_sampling_rate,
		         (uword *)&vce_dp_buf_size);

    /* Setup the compression structures for the different methods   */
    for (i=0; i<vce_num_of_methods; i++)
	dp_vce_get_compression_info(i,&vce_comp_method[i]);

    /* Setup working variables for the possible events in each mode */
    vce_tx_events = vce_comp_method[vce_comp_index].tx_mode_events;
    vce_rx_events = vce_comp_method[vce_comp_index].rx_mode_events;
    vce_idl_events = vce_comp_method[vce_comp_index].idl_mode_events;

    if (type == INIT_ATZ)
    {
         vce_cmd_set = NONE;
         vce_class = 0;
/* 
	ramn 9/23/96 , 
	if any vls command issued during conv rec terminate conv rec
*/
			if(conv_rec_going_on == TRUE)
				exit_conv_rec_vls17();

			if((acu_cntrld_hangup < 2) && (vls_cmd_value != 0)) /* ramn 5/22/96 */
            execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,OFF,OFF,OFF,OFF); /* +vls=0 */
			vls_cmd_value = 0;
    }

/*    vce_message_sent = FALSE; */ /* ramn 2/13/96 */
/*    vce_cancel_control = 1; */ /* ramn 2/13/96 */
/*    vce_on_hook = TRUE; */ /* ramn 2/13/96 */
/*    vce_line_select = 0; */ /* ramn 2/13/96 */
/*    vce_frequency_f1 = 0; */ /* ramn 2/13/96 */
/*    vce_frequency_f2 = 0; */ /* ramn 2/13/96 */
/* Start Change 8/24/1995. */
/*    vce_timing_marks = 0; */ /* ramn 2/13/96 */
/* End Change 8/24/1995. */

	 if(type != INIT_VIP)
	 {
	    vce_state = VOICE_NOT_RUNNING;
   	 vce_mode = OFFLINE_COMMAND;
	 }
	 else
	 {
	    vce_state = INIT_OFFLINE_COMMAND;
   	 vce_mode = OFFLINE_COMMAND;
	 }


    vce_silence_detc_timer = 0;
    vce_inactivity_timer_on = FALSE;
    vce_inactivity_time = 0;

/*    vce_mod_term_fctrl = CTS_RTS;
    vce_term_mod_fctrl = CTS_RTS;
*/
    vce_mod_term_fctrl = fax_flow_control;
    vce_term_mod_fctrl = fax_flow_control;

    vce_fifo_size = 0;

	voice_cmd_init();  /* ramn 10/10/95 */
	thru_mic = FALSE;  /* ramn 1/15/96 */
	thru_spkr = FALSE;
	thru_phone = FALSE;
   voice_event_rept = vce_idl_events; /* ramn 1/15/96 */
#if 0	/* ramn 8/7/96 */
	local_phn_on_hook_status_sent = FALSE; /* 1/24/96 */
	local_phn_off_hook_status_sent = FALSE; /* 1/24/96 */
#endif
	dle_h_sent = FALSE; /* 7/11/96 */
	dle_H_sent = FALSE; /* 7/11/96 */

	first_time = TRUE;
	phn_status = 0;

	tele_emul_value = 0; /* ramn 2/23/96 */
	spkr_phn_mode = 0; 	/* 7/11/96 */
	executing_spkr_phn = FALSE; /* ramn 7/18/96 */
	was_in_spkr_phn_mode = FALSE;	/* ramn 6/25/96 */

	/* ramn 6/10/96 */
	if(type == INIT_VIP)
	{
		if(hook)					
			vls_cmd_value = 0;
		else
		{
			vls_cmd_value = 1;
		   vce_state = INIT_ONLINE_COMMAND;
   		vce_mode = ONLINE_COMMAND;
			thru_line = TRUE;				/* ramn 3/13/96 till here */
		}
	}

	debounce_timer = 0;   /* ramn 2/25/96 */
	relay_off_hook_flag = FALSE;
	relay_on_hook_flag = FALSE;

}

/*******************************************************************************
/
/   Routine: vce_bg
/
/   Author: RSA
/
/   Creation Date: 10/26/92
/
/   Description: This routine will preform the voice processing.
/
/   Input Parameters: ubyte *msg - Pointer used to send information to the
/                                  terminal if needed. If no message then
/                                  return NULL pointer.
/
/   Output Parameters: ubyte status - status of the voice code
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
 -			Modifications			    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
/  Author & Date: RSA 5/18/1995.
/  Description: Fixed the problems with reporting the OK and the VCON messages
/               in the IS101 and Rockwell voice code.
/  Reason: There was a problem with the IS101 code inadvertently reporting
/          VCON during the issuance of a +VLS command. The +VLS connect now
/          issues an OK in IS101 voice mode.
/
*******************************************************************************/
ubyte vce_bg(ubyte **msg)
{
    ubyte return_code, ch;
    uword count_rec;

    /* Set pointer initially to NULL */
    vce_array[0] = '\0';
    *msg = (ubyte *)&vce_array[0];

    return_code = STAY_ONLINE;

	if ((tele_emul_value != TRUE) && (spkr_phn_mode != TRUE))
	{
	    if (vce_state != VOICE_NOT_RUNNING && vce_state != INIT_ONLINE_COMMAND &&
   	     vce_state != INIT_OFFLINE_COMMAND) 
	   	     ch = vce_call_progress(msg);
	}	/* ramn 5/29/96 */

	vce_local_phn_hook_status();  /* ramn 7/11/96*/

   switch (vce_state)
   {
      case VOICE_NOT_RUNNING:
	      return_code = STAY_PARSE;
      break;

      case INIT_OFFLINE_COMMAND:
         /* Initialize the data pump to detect call progress while in offline
            command state */
         /*dp_vce_init_call_progress(OFFLINE_COMMAND,vce_cmd_set);*/ /* ramn 2/21/96 */

         vce_mode = OFFLINE_COMMAND;
        	voice_event_rept = vce_idl_events; /* ramn 1/15/96 */
	      vce_state = VOICE_OFFLINE_COMMAND;

			/* ramn 2/21/96 */
         dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                                   vce_sampling_rate,vce_speaker_vol);
	   break;

   	case VOICE_OFFLINE_COMMAND:
         /* If ring on or off was detected need to inform the terminal. */
         if (ch)
         {
            if (ch == DETECTED_RING_ON)
            {
               if (vce_mode == OFFLINE_COMMAND)
	               return_code = RING_ON_DETECTED;
            }
            else if (ch == DETECTED_RING_OFF) 
            {
               if (vce_mode == OFFLINE_COMMAND)
	               return_code = RING_OFF_DETECTED;
            }
         }
         else
	         return_code = STAY_PARSE;
	      break;

		case DIAL_FAILED:			/* ramn 6/27/96 */
			return_code = GOTO_IDLE_NONE;
			vce_state = INIT_OFFLINE_COMMAND;
         *msg = (ubyte *)&RESULT_NOANSWER;
			vce_mode = OFFLINE_COMMAND;
		break;

		case DIAL_FAILED_KB:			/* ramn 6/27/96 */
			return_code = GOTO_IDLE_NONE;
			vce_state = INIT_OFFLINE_COMMAND;
         *msg = (ubyte *)&RESULT_NOCARRIER;
	      voice_event_rept = vce_idl_events; /* ramn 12/3/96 */
			vce_mode = OFFLINE_COMMAND;
		break;

		case DIAL_FAILED_NODT:			/* ramn 12/3/96 */
	      voice_event_rept = vce_idl_events; /* ramn 12/3/96 */
			return_code = GOTO_IDLE_NONE;
			vce_state = INIT_OFFLINE_COMMAND;
         *msg = (ubyte *)&RESULT_NODIALTONE;
			vce_mode = OFFLINE_COMMAND;
		break;

      case WAIT_FOR_1ST_RB:
         /* If ringback is detected then start the timer to determine if
            ringback has gone away. */
         if (ch == DETECTED_RINGBACK)
         {
				if(vce_rb_away_timer < 70) /* ramn 3/16/96 */
	            vce_rb_away_timer = 70;
				else
					vce_rb_away_timer = vce_rb_away_time;

            vce_state = WAIT_FOR_RB_AWAY;

            /*if (vce_ctl_tone_rpt_active)
               return (RINGBACK_DETECTED);
            else*/ /* ramn 2/26/96 */

               return (RINGBACK_DETECTED); 
         }
         else if (ch == DETECTED_BUSY) 
         {
            /*if (vce_mode == OFFLINE_COMMAND)*/ /* ramn 2/27/96 */

				/* reset both the ringback timers. If you get busy then 
					you won't get ringback so do not let the timers expire */

				if(vce_rb_away_timer < 70) /* ramn 3/16/96 */
	            vce_rb_away_timer = 70;
				else
					vce_rb_away_timer = vce_rb_away_time;

				if(vce_rb_never_timer < 70) /* ramn 3/16/96 */
	            vce_rb_never_timer = 70;
				else
					vce_rb_never_timer = vce_rb_never_time;


		      return_code = BUSY_DETECTED;
         }

         /* If ringback is not detected before the ring back never came timer
            assume the peer has gone off hook */
         else if (!vce_rb_never_timer) /* ramn 2/27/96 */
            vce_state = VOICE_ORIG_COMPLETE;
         break;

      case WAIT_FOR_RB_AWAY:
         /* If the timer expires then move to on line command state.  If
            ringback is detected before the timer expires then reset the
            timer. */
         if (ch == DETECTED_RINGBACK)
         {
				if(vce_rb_away_timer < 70) /* ramn 3/16/96 */
	            vce_rb_away_timer = 70;
				else
					vce_rb_away_timer = vce_rb_away_time;

               /*return (RINGBACK_DETECTED);*/
					return(RINGBACK_DETECTED);/* was stay_online *//* ramn 2/26/96 */
         }
         else if (ch == DETECTED_BUSY) 
         {
            /*if (vce_mode == OFFLINE_COMMAND)*/

				/* reset both the ringback timers. If you get busy then 
					you won't get ringback so do not let the timers expire */
				if(vce_rb_away_timer < 70) /* ramn 3/16/96 */
	            vce_rb_away_timer = 70;
				else
					vce_rb_away_timer = vce_rb_away_time;

				if(vce_rb_never_timer < 70) /* ramn 3/16/96 */
	            vce_rb_never_timer = 70;
				else
					vce_rb_never_timer = vce_rb_never_time;

	         return_code = BUSY_DETECTED;	  /* ramn 2/27/96 */
         }
         else if (!vce_rb_away_timer)   /* ramn 2/27/96 */
             vce_state = VOICE_ORIG_COMPLETE;

         break;

      case VOICE_ORIG_COMPLETE:
         /* Setup the return message for the ACU */

/*         if (vce_cmd_set == TIA_IS_101)
            *msg = (ubyte *)&RESULT_OK;
         else
            *msg = (ubyte *)&RESULT_VCON;
*/ /* ramn 1/16/96 */

         vce_mode = ONLINE_COMMAND;
        voice_event_rept = vce_idl_events; /* ramn 1/15/96 */

         /*vce_state = VOICE_ONLINE_COMMAND;*/ /* ramn 2/26/96 */
	      /*return_code = GOTO_IDLE_NONE;*/
         vce_state = INIT_ONLINE_COMMAND; /* ramn 2/26/96 */
	      return_code = GOTO_IDLE_OK;  /* ramn 2/26/96 */

			if(spkr_phn_mode == TRUE)	/* ramn 6/28/96 */
			{
	         dp_vce_compression_init(VOICE_IDLE, 
												vce_comp_method[vce_comp_index].id,
                                    vce_sampling_rate,vce_speaker_vol);

				vce_send_tone_timer = 6; 
				while(vce_send_tone_timer)
				{
					process_wait();
				}	
				
				executing_spkr_phn = FALSE; /* ramn 10/23/96 */

				tele_emul_enable(ON);	/* ramn 6/28/96 */
	         vce_mode = OFFLINE_COMMAND;
   	     	voice_event_rept = vce_idl_events;  
	   	   vce_state = VOICE_OFFLINE_COMMAND;
			}		  
      break;

      case INIT_ONLINE_COMMAND:
         /* Place the data pump into voice mode */
         dp_vce_init();

         /* Initialize the data pump to detect call progress while in online
            command state */
          /*dp_vce_init_call_progress(ONLINE_COMMAND,vce_cmd_set);*/ /* ramn 2/21/96 */

         /* Setup the return message for the ACU if it has not already
            been sent back */
         if (vce_mode != TRANSMIT_MODE && vce_mode != RECEIVE_MODE &&
             vce_mode != TRANSLATE_MODE)
/* Start Change 5/18/1995. */
			{		/* added brace brackets by ramn on 10/10/95 */
/*         	if (vce_cmd_set == TIA_IS_101)
            	*msg = (ubyte *)&RESULT_OK;
         	else
            	*msg = (ubyte *)&RESULT_VCON;
*//*ramn 1/16/96 */			}		/* added brace brackets by ramn on 10/10/95 */
/* End Change 5/18/1995. */
         vce_mode = ONLINE_COMMAND;
	      voice_event_rept = vce_idl_events; /* ramn 1/15/96 */
         vce_state = VOICE_ONLINE_COMMAND;

			/* ramn 2/21/96 */
         dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                                   vce_sampling_rate,vce_speaker_vol);

#if 0
/* added by ramn on 6/25/96
   when dialing ACU turns on the speaker. 
	in voice mode keep speaker on onlyif required by the VLS command
*/
			if((vls_cmd_value == 5) || (vls_cmd_value == 7))
			{
			   dp_vce_speaker(ON,ON);
			}
			else
			{
			   dp_vce_speaker(OFF,OFF);
			}
#endif

         break;

      case VOICE_ONLINE_COMMAND:
      /* If a call progress message was sent back to the terminal, need have
         the controller take back the SCC's transmit path. */
         if (ch)
         {
	         return_code = ENABLE_TRANSMIT;
         }
         else
	         return_code = STAY_PARSE;
	      break;

	   case INIT_VOICE_TRANSMIT:
         /* Set the voice transmit level */
         dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);

	      /* Need to disable flow control in the direction of the data because
	         the XON/XOFF characters could be found in the data stream. */
         /*dp_vce_init_call_progress(TRANSMIT_MODE,vce_cmd_set);*/ /* ramn 2/21/96 */
			
			/* vce_mode has to be set before voice_dte_init is called */
         vce_mode = TRANSMIT_MODE;
        voice_event_rept = vce_tx_events; /* ramn 1/15/96 */

/* ramn 1/16/96 */
/*	      voice_dte_init(vce_baudrate,DISABLED,fax_flow_control, 
		         	      vce_dte_XOFF_level,vce_dte_XON_level, vce_fifo_size);
*/  

	      vce_rcv_dle = FALSE;


			/* dp_vce_compression has to be called after dp_vce_init_call_progress */
         dp_vce_compression_init(VOICE_TRANSMIT, vce_comp_method[vce_comp_index].id,
                                    vce_sampling_rate,vce_speaker_vol);

			trans_underrun_sent = FALSE; /* ramn 1/16/96 */

/* ramn 6/25/96, 
	wait 500ms on entering play back mode before sending first DLE-U 
*/
			time_since_entering_plbmode = 5; 

			if(vce_comp_method[vce_comp_index].id == AD4_PCM) /* ramn 9/5/96 */
			{
				stop_fifo_timer();
				vce_state = WAIT_100MS_IN_AD4;
				wait_100ms_timer_on = TRUE;
				vce_send_tone_timer = 13;		/* this is a 10 ms timer */
			}
			else
			{
		      voice_dte_init(vce_baudrate,DISABLED,vce_mod_term_fctrl, 
		         	      vce_dte_XOFF_level,vce_dte_XON_level, vce_fifo_size);
		      /*dp_vce_dte_cts(ON);*/
				CTSon();	/* changed by ramn on 10/10/95 */
			
		      vce_state = TRANSMIT_DELAY_SENDING; 
	
			/* to start,load timer now ramn 1/16/96 */
				if(vce_inactivity_time) /* turn timer on only if non zero */
				{
      	   	vce_inactivity_timer = vce_inactivity_time; 
					vce_inactivity_timer_on = TRUE;
				}
			}
	      break;

		case WAIT_100MS_IN_AD4: 		/* ramn 9/5/96 */

			if((wait_100ms_timer_on) && (!vce_send_tone_timer))
			{
				start_fifo_timer();

		      voice_dte_init(vce_baudrate,DISABLED,vce_mod_term_fctrl, 
		         	      vce_dte_XOFF_level,vce_dte_XON_level, vce_fifo_size);
		      /*dp_vce_dte_cts(ON);*/
				CTSon();	/* changed by ramn on 10/10/95 */
			
			/* to start,load timer now ramn 1/16/96 */
				if(vce_inactivity_time) /* turn timer on only if non zero */
				{
      	   	vce_inactivity_timer = vce_inactivity_time; 
					vce_inactivity_timer_on = TRUE;
				}
	
			 	wait_100ms_timer_on = FALSE;
				vce_state = TRANSMIT_DELAY_SENDING;
			}
			else
			{
   	  		dp_vce_to_char_buffer(0);
			}

		break;
			
							
			

	   case INIT_VOICE_RECEIVE:
         /* Set the voice receive gain */
         dp_vce_set_level(VOICE_RECEIVE,vce_receive_gain);

	      /* Need to disable flow control in the direction of the data because
	         the XON/XOFF characters could be found in the data stream.   */

/* ramn 10/10/95, for cutlass the data direction is controlled in */
/*	dp_vce_compression_init */
         /*dp_vce_set_data_direction(VOICE_RECEIVE); */ /* ramn 8/19/96 */

         /*dp_vce_init_call_progress(RECEIVE_MODE,vce_cmd_set);*//* ramn 2/21/96 */

			/* vce_mode has to be set before voice_dte_init is called */
         vce_mode = RECEIVE_MODE;
        voice_event_rept = vce_rx_events; /* ramn 1/15/96 */

	      voice_dte_init(vce_baudrate,vce_term_mod_fctrl,DISABLED,
			      vce_dte_XOFF_level,vce_dte_XON_level,vce_fifo_size);

			/* dp_vce_compression has to be called after dp_vce_init_call_progress */
	      dp_vce_compression_init(VOICE_RECEIVE, vce_comp_method[vce_comp_index].id,
                                  vce_sampling_rate,vce_speaker_vol); 

	      /* dp_vce_dte_cts(ON); */
			CTSon(); /* changed by ramn 10/10/95 */

	      vce_timer_started = FALSE;
	      vce_rcv_dle = FALSE;
	      vce_rcv_dp_dle = FALSE;

		   /* ramn 2/23/96 */
			/* set the timer to report DLE-s 1 second more than normal silence detc */
			vce_silence_detc_timer = (vce_silence_detc_interval + 10);
			/*tmp_wrd = 0;*/ /* for testing only */

	      vce_state = PROCESS_VOICE_RECEIVE;
	      break;

      case TRANSMIT_DELAY_SENDING:
         /* Delay until the CODEC has buffer some characters */
	      if (!dp_vce_dte_DTR_status())
	      {
            /*dp_vce_start_tx();*/ /* ramn 8/19/96 */
		      vce_state = FINISH_DATA_TRANSMIT;
		      return (return_code);
	      }

         /* Reset the inactivity timer if data passing */
         if (count = voice_dte_from_num())
         {
	         vce_inactivity_timer = vce_inactivity_time; 
 				trans_underrun_sent = FALSE; /* ramn 1/16/96 */
         }
			else		 /* ramn 1/16/96 */
			{
				/* this is transmit buffer underrun condition
					send <DLE> u to DTE */

				/* ramn 6/25/96, added chk for time_since_entering_plbmode */
				if((trans_underrun_sent == FALSE) && !time_since_entering_plbmode)
				{
					voice_dte_to_char(DLE);
        			voice_dte_to_char('u');
					trans_underrun_sent = TRUE;
				}
				/* chk if inac timer expired if yes exit */
				if((vce_inactivity_timer_on == TRUE) && (!vce_inactivity_timer)) 
				{									/* ramn 1/16/96 */
			      return_code = GOTO_IDLE_INACTIVITY;
					vce_inactivity_timer_on = FALSE;
					vce_reset();
			      return (return_code);
				}
			}

         while ((dp_vce_to_free() > 3) && count)
         {
				if(ad3_count <	3)
				{
	            ch = voice_dte_from_char();
					count--;
				}  /* ramn 2/13/96 */
            /* If end of data need to start the data transmission */
#if 0
            if (ch == ETX && vce_rcv_dle)
            {
               dp_vce_start_tx();
    				vce_state = FINISH_DATA_TRANSMIT;  /* ramn 10/10/95 */
		      	return (return_code);
	         } 
#endif
            send_voice_data(ch);
				
	      }

         if (!dp_vce_to_free())
         {
            /*dp_vce_start_tx();*/ /* ramn 8/19/96 */
            if (vce_mode == TRANSLATE_MODE)
               vce_state = PROCESS_VOICE_TRANSLATE;
            else
            {
               vce_state = PROCESS_VOICE_TRANSMIT;
               vce_transmit_flag = 1;
            }
         }
         break;

	   case PROCESS_VOICE_TRANSMIT:
	      if (!dp_vce_dte_DTR_status())
	      {
		      vce_state = FINISH_DATA_TRANSMIT;
		      return (return_code);
	      }

         if (vce_transmit_flag)
         {
/* ramn 10/10/95, for cutlass the data direction is controlled in */
/*	dp_vce_compression_init */
             /*dp_vce_set_data_direction(VOICE_TRANSMIT);*/ /* ramn 8/19/96 */
            vce_transmit_flag = 0;
         }

         /* Reset the inactivity timer if data passing */
         if (count = voice_dte_from_num())
         {
	         vce_inactivity_timer = vce_inactivity_time; 
 				trans_underrun_sent = FALSE; /* ramn 1/16/96 */
         }
			else		 /* ramn 1/16/96 */
			{
				/* this is transmit buffer underrun condition
					send <DLE> u to DTE */
				if(trans_underrun_sent == FALSE)
				{
					voice_dte_to_char(DLE);
        			voice_dte_to_char('u');
					trans_underrun_sent = TRUE;
				}
				/* chk if inac timer expired if yes exit */
				if((vce_inactivity_timer_on == TRUE) && (!vce_inactivity_timer)) 
				{									/* ramn 1/16/96 */
			      return_code = GOTO_IDLE_INACTIVITY;
					vce_inactivity_timer_on = FALSE;
					vce_reset();
			      return (return_code);
				}
			}

         while ((dp_vce_to_free() > 3) && count)
         {
				/* changed by ramn 10/10/95 */
				if(ad3_count <	3)
				{
	            ch = voice_dte_from_char();
					count--;
			  	}  /* ramn 2/13/96 */

            /* If end of data need to start the data transmission */
#if 0
            if (ch == ETX && vce_rcv_dle)
            {
               dp_vce_start_tx();
    				vce_state = FINISH_DATA_TRANSMIT;  /* ramn 10/10/95 */
		      	return (return_code);
	         } 
#endif
            send_voice_data(ch);
				/* till here ramn */
	      }                                 
	      break;

	   case FINISH_DATA_TRANSMIT:
         /* Reset the inactivity timer if data passing */
         if (count = voice_dte_from_num())
         {
	         vce_inactivity_timer = vce_inactivity_time; 
         }

         while ((dp_vce_to_free() > 3) && count)
         {
				if(ad3_count <	3)
				{
	            ch = voice_dte_from_char();
					count--;
				}  /* ramn 2/13/96 */
				send_voice_data(ch);
	      }

	      if (!voice_dte_from_num())
         {
	         vce_state = FLUSH_LINE;
         }
	      break;

	   case FLUSH_LINE:
         /* Wait until all data has been transmitted to the codec, then place
            the data pump and voice code in to the on line command state */
/*         if (!dp_vce_to_num()) */
			if(!dce_tx_count)
         {
	         /*dp_vce_return_to_idle();*/ /* ramn 2/21/96 */

            /* Setup the return message for the ACU */
/* Start Change 5/18/1995. */
/*
            if (vce_cmd_set == TIA_IS_101)
               *msg = (ubyte *)&RESULT_OK;
            else
               *msg = (ubyte *)&RESULT_VCON;
*/ 	/* ramn 10/10/95 */
/* End Change 5/18/1995. */
            vce_state = INIT_ONLINE_COMMAND;
            return_code = GOTO_IDLE_NONE;
				/* ramn 2/21/96 */
   	      dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
	                                  vce_sampling_rate,vce_speaker_vol);

         }
	      break;

	   case PROCESS_VOICE_RECEIVE:

		   if (!dp_vce_dte_DTR_status())		 /* added by ramn on 10/10/95 */
	      {
		      vce_state = FINISH_DATA_RECEIVE;
		      return (return_code);
	      }

        /* Move the data from the codec buffers to the DTE buffers.  Need to
            perform DLE insertion in to the data stream */

         count = dp_vce_from_num();
	      while((voice_dte_to_free() > 4) && (count > 2)) /* ramn 2/16/96 */
         {
         /* See what data has been received from the terminal. If not a DLE
            shielded command then terminate reception */

           	if (voice_dte_from_num())
            	if (!process_dle_command())
	            	vce_state = FINISH_DATA_RECEIVE;

#if 0
	         ch = dp_vce_from_char();
            if (ch == DLE)         
    	      	voice_dte_to_char(DLE);
            voice_dte_to_char(ch);
            count--;
#endif /* ramn 2/16/96 */

			  pack_data_and_send();	/* ramn 2/16/96 */

			}/* while */

         /* Determine if the receive buffer has overflowed */
         if (voice_dte_to_free() < 3) /* ramn 1/16/96 */
         {
            if (dp_vce_from_num() == vce_dp_buf_size)
               /*vce_receive_overrun = TRUE;*/
				{
         		voice_dte_to_char(DLE);
         		voice_dte_to_char('o');
				}					
         }

#if 0
        /* if (dp_vce_detect_silence(vce_silence_detc_sen))*/
			if((ch = dp_vce_call_progress()) == SILENCE) /* ramn 2/21/96 */
			{
				/*tmp_wrd++;*/ /* for testing */
				while (voice_dte_to_free() < 2)
            	   ;
				if(vce_silence_detc_timer) /* ramn 2/23/96 */
				{
					voice_dte_to_char(DLE);
					voice_dte_to_char('s');
				}
				else
				{
         		voice_dte_to_char(DLE);
         		voice_dte_to_char('q');
				}
  			}
#endif

		break;









#if 0
         /* See what data has been received from the terminal. If not a DLE
            shielded command then terminate reception */
         if (voice_dte_from_num())
            if (!process_dle_command())
	            vce_state = FINISH_DATA_RECEIVE;

	      if (!dp_vce_dte_DTR_status())		 /* added by ramn on 10/10/95 */
	      {
		      vce_state = FINISH_DATA_RECEIVE;
		      return (return_code);
	      }

         /* Move the data from the codec buffers to the DTE buffers.  Need to
            perform DLE insertion in to the data stream */
         count = dp_vce_from_num();

	      if (voice_dte_to_free() < count)
         {
            count = voice_dte_to_free();

            /* Determine if the receive buffer has overflowed */
            if (!count)
            {
               if (dp_vce_from_num() == vce_dp_buf_size)
                 /* vce_receive_overrun = TRUE; */ /* ramn 2/13/96 */
            }
         }

         while (count)
         {
            if (vce_rcv_dp_dle)
	         {
	            voice_dte_to_char(DLE);
               vce_rcv_dp_dle = FALSE;
	         }
	         else
            {  
	            ch = dp_vce_from_char();
               if (ch == DLE)         
               {
    	            vce_rcv_dp_dle = TRUE;
               }
               voice_dte_to_char(ch);
               count--;
            }
         }
         if (dp_vce_detect_silence(vce_silence_detc_sen))
	      {
	         if (!vce_timer_started)
	         {
	            vce_silence_detc_timer = vce_silence_detc_interval; 
	            vce_timer_started = TRUE;
	         }
	         else
	         {
	            if (!vce_silence_detc_timer)
	            {
/* Start Change 6/7/1995. */
/*                 if (vce_cmd_set == TIA_IS_101)
*                  {
*                     while (voice_dte_to_free() < 2)
*                        ;
*                     voice_dte_to_char(DLE);
*                     voice_dte_to_char('q');
*	    	            vce_timer_started = FALSE; 
*                  }
*                  else
*                  {
*	    	            vce_state = FINISH_DATA_RECEIVE;
*	    	            vce_timer_started = FALSE;
*                  }
*/
/* Start Change 6/12/1995. */
                    while (voice_dte_to_free() < 2)
                        ;
                    voice_dte_to_char(DLE);
                    voice_dte_to_char('q');
	    	           vce_timer_started = FALSE; 
/* End Change 6/12/1995. */
	            }
	         }
	      }
	      else
	      {
	         vce_timer_started = FALSE;
	      }
			break;	
#endif	      
/* till here ramn 10/10/95 */


	   case FINISH_DATA_RECEIVE:
         /* See what data has been received from the terminal. If not a DLE
            shielded command then ignore the character */
         if (voice_dte_from_num())
            process_dle_command(); /* ramn */

         /* Place end of data indication in the buffer and take the data pump
            out of the voice mode.   */
	      if (voice_dte_to_free() > 2)
	      {
		      voice_dte_to_char(DLE);
		      voice_dte_to_char(ETX);
		      vce_state = FLUSH_DTE;
	      }
	      break;

	   case FLUSH_DTE:
         /* When all data has been transmitted to the DTE, place the voice code
            into the online command state.  */
	      if (!voice_dte_to_num())
	      {
	         /* dp_vce_return_to_idle();*/ /* ramn 2/19/96 */

            /* Setup the return message for the ACU */
/*            if (vce_cmd_set == TIA_IS_101)
                *msg = (ubyte *)&RESULT_OK;
            else
                *msg = (ubyte *)&RESULT_VCON;
*/ /* ramn 1/12/96 OK sent from ACU */
                vce_state = INIT_ONLINE_COMMAND;
                return_code = GOTO_IDLE_NONE;
				/* ramn 2/21/96 */
   	      dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
	                                  vce_sampling_rate,vce_speaker_vol);

	      }
	      break;       

/***************************************************************************
*
*
*		this code added by ramn on 2/23/96 
*
*		this code is for tele emulation
*
*
****************************************************************************/

#if 0
		case INIT_TELE_EMUL:					/* ramn 2/23/96 */	

         vce_mode = OFFLINE_COMMAND;
        	voice_event_rept = vce_idl_events;  
	      vce_state = VOICE_OFFLINE_COMMAND;


         /* Set the voice transmit level */
         dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);

			tele_emul_enable(ON);

			CTSon();
		break;
#endif

#if 0
		case EXEC_TELE_EMUL:				 /* ramn 2/23/96 */
		   if (!dp_vce_dte_DTR_status())		 /* added by ramn on 10/10/95 */
	      {
		      vce_state = FINISH_DATA_RECEIVE;
		      return (return_code);
	      }

         /* See what data has been received from the terminal.*/

           	if (voice_dte_from_num())
				{
				    ch = voice_dte_from_char();

			    /* Need to see if DLE shilded commands have been received from the terminal */

			    if (ch == DLE)
			    {
			        vce_rcv_dle = TRUE;
			    }
			    else if (vce_rcv_dle == TRUE)
			    {
					switch (ch)
					{
						case 'd': /* decrease the receive gain */
		      		  vce_rcv_dle = FALSE;
	      			  vce_receive_gain--;
				        if (vce_receive_gain <= vce_rcv_gain_range[0])
   	   			      vce_receive_gain = vce_rcv_gain_range[0];
				        dp_vce_set_level(VOICE_RECEIVE,vce_receive_gain);
						break;

	    				/* Increase the receive gain */
	   	 			case 'u':
				        vce_rcv_dle = FALSE;
      				  vce_receive_gain++;
		   	   	  if (vce_receive_gain >= vce_rcv_gain_range[1])
      			   	   vce_receive_gain = vce_rcv_gain_range[1];
			      	  dp_vce_set_level(VOICE_RECEIVE,vce_receive_gain);
						break;

		    			/* check to see if the abort character was sent */
						case 'ETX':
							vce_rcv_dle = FALSE;
		      			vce_state = END_TELE_EMUL;
						break;
					} /*switch */
				 }	 /* elseif */
 
				}
		break;
#endif

		case END_TELE_EMUL:				 /* ramn 2/23/96 */
			vce_state = INIT_OFFLINE_COMMAND;
			vce_mode = OFFLINE_COMMAND;

			tele_emul_enable(OFF);
		break;

/***************** till here by ramn 2/23/96 *******************************/

#if 0
      case INIT_VOICE_TRANSLATE:
	      /* Need to disable flow control in the direction of the data because
	         the XON/XOFF characters could be found in the data stream. */
/*	      voice_dte_init(vce_baudrate,DISABLED,vce_mod_term_fctrl, 
			   vce_dte_XOFF_level,vce_dte_XON_level,vce_fifo_size);
*/ /* ramn 1/16/96 */
	      voice_dte_init(vce_baudrate,DISABLED,fax_flow_control, 
		         	      vce_dte_XOFF_level,vce_dte_XON_level, vce_fifo_size);

/* start change 02/06/95 drc */
 	      dp_vce_compression_init(VOICE_TRANSLATE, vce_comp_method[vce_comp_index].id,
/* end change 02/06/95 drc */
                               vce_sampling_rate,vce_speaker_vol);

/* ramn 10/10/95, for cutlass the data direction is controlled in */
/*	dp_vce_compression_init */
          /*dp_vce_set_data_direction(VOICE_TRANSLATE);*/  /* ramn 8/19/96 */
         /*dp_vce_init_call_progress(TRANSLATE_MODE,vce_cmd_set);*//* ramn 2/21/96 */
	      vce_rcv_dle = FALSE;
         vce_mode = TRANSLATE_MODE;
	      vce_state = TRANSMIT_DELAY_SENDING;

  	      /* dp_vce_dte_cts(ON); */
			CTSon(); /* changed by ramn 10/10/95 */

	      break;

      case PROCESS_VOICE_TRANSLATE:
	      if (!dp_vce_dte_DTR_status())
	      {
		      vce_state = FINISH_DATA_TRANSLATE;
		      return (return_code);
	      }

         /* Reset the inactivity timer if data passing */
         if (count = voice_dte_from_num())
	         vce_inactivity_timer = vce_inactivity_time; 

         while (dp_vce_to_free() && count)
         {
            send_voice_data(voice_dte_from_char());
            count--;
         }

	      if (count_rec = voice_dte_to_free())
         {
            while (voice_dte_to_free() && count_rec)
            {
               if (vce_rcv_dp_dle)
	            {
	               voice_dte_to_char(DLE);
                  vce_rcv_dp_dle = FALSE;
	            }
	            else
               {  
	               ch = dp_vce_from_char();
                  if (ch == DLE)
    	               vce_rcv_dp_dle = TRUE;
                     voice_dte_to_char(ch);
                     count_rec--;
               }
            }
         }
	      break;

      case FINISH_DATA_TRANSLATE:
	      if (!voice_dte_to_num())
	      {
            /* Setup the return message for the ACU */
/* Start Change 5/18/1995. */
            if (vce_cmd_set == TIA_IS_101)
                *msg = (ubyte *)&RESULT_OK;
            else
                *msg = (ubyte *)&RESULT_VCON;
/* End Change 5/18/1995. */
            vce_state = INIT_ONLINE_COMMAND;
            return_code = GOTO_IDLE_NONE;
	      }
	      break;
#endif /* ramn 4/5/96 */

	   default:
	      break;
      }

    /* if no data passing from the dte and the inactivity timer expires
       then go onhook and reset voice to acu control */
   if ((!vce_inactivity_timer) && (vce_inactivity_timer_on))
   {
      vce_inactivity_timer_on = FALSE;
      vce_reset();
	   return_code = GOTO_IDLE_INACTIVITY;
   }

   return (return_code);
}


/*******************************************************************************
/
/   Routine:  process_dle_command
/
/   Author: RSA
/
/   Creation Date: 3/30/1993
/
/   Description: This routine will determine if the terminal has sent a DLE
/                shielded command or is trying to abort data reception.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte Indicates if the terminal has sent a DLE shielded
/                            command or not.
/                               TRUE - DLE shielded command
/                               FALSE - Not DLE shielded command. abort data
/                                       reception
/
/   Global Variables Changed:  None
/                                      
/   Users: vce_bg()
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
ubyte process_dle_command(void)
{ 
   ubyte ch;

    ch = voice_dte_from_char();

    /* Need to see if DLE shilded commands have been received from the terminal */
    if (ch == DLE)
    {
        vce_rcv_dle = TRUE;
    }
    else if (vce_rcv_dle == TRUE)
    {
			switch (ch)
			{
				case 'd': /* decrease the receive gain */
		        vce_rcv_dle = FALSE;
      		  vce_receive_gain--;
		        if (vce_receive_gain <= vce_rcv_gain_range[0])
      		      vce_receive_gain = vce_rcv_gain_range[0];
		        dp_vce_set_level(VOICE_RECEIVE,vce_receive_gain);
				break;

    			/* Increase the receive gain */
    			case 'u':
		        vce_rcv_dle = FALSE;
      		  vce_receive_gain++;
		        if (vce_receive_gain >= vce_rcv_gain_range[1])
      		      vce_receive_gain = vce_rcv_gain_range[1];
		        dp_vce_set_level(VOICE_RECEIVE,vce_receive_gain);
				break;

    			/* check to see if the abort character was sent */
				case '!':
					vce_rcv_dle = FALSE;
		      	voice_dte_to_char(DLE);
		      	voice_dte_to_char(ETX);
		      	vce_state = FLUSH_DTE;
					/*dp_vce_return_to_idle();*/
					/* ramn 2/21/96 */
	   	      dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
	                                  vce_sampling_rate,vce_speaker_vol);


				break;
				
				case ESC:
		        	vce_rcv_dle = FALSE;
					vce_state = FINISH_DATA_RECEIVE;
				break;
			} /*switch */
		}	 /* elseif */
    else
        return (FALSE);

    return (TRUE);
}





#if 0  /* by ramn on 1/12/96 */
{
    ubyte ch;

    ch = voice_dte_from_char();

    /* Need to see if DLE shilded commands have been received from the terminal */
    if (ch == DLE)
    {
        vce_rcv_dle = TRUE;
    }
    /* decrease the receive gain */
    else if (ch == 'd' && vce_rcv_dle)
    {
        vce_rcv_dle = FALSE;
        vce_receive_gain--;
        if (vce_receive_gain <= vce_rcv_gain_range[0])
            vce_receive_gain = vce_rcv_gain_range[0];
        dp_vce_set_level(VOICE_RECEIVE,vce_receive_gain);
    }
    /* Increase the receive gain */
    else if (ch == 'u' && vce_rcv_dle)
    {
        vce_rcv_dle = FALSE;
        vce_receive_gain++;
        if (vce_receive_gain >= vce_rcv_gain_range[1])
            vce_receive_gain = vce_rcv_gain_range[1];
        dp_vce_set_level(VOICE_RECEIVE,vce_receive_gain);
    }

    /* check to see if the abort character was sent */
    else if ((ch == '!' && vce_rcv_dle) && (vce_cmd_set == TIA_IS_101))
    {
        vce_rcv_dle = FALSE;
	vce_state = FINISH_DATA_RECEIVE;
    }
    /* buffer size inquiry */    

 /* this is tobe done only in voice transmit and command modes */
    else if ((ch == '?' && vce_rcv_dle) && (vce_cmd_set == TIA_IS_101))
    {
        vce_rcv_dle = FALSE;
        voice_dte_to_char(DLE);
        voice_dte_to_char('X');
        voice_dte_to_char(DLE);
        voice_dte_to_char('.');
    }
    else
        return (FALSE);

    return (TRUE);
}
#endif
/*******************************************************************************
/
/   Routine: send_voice_data
/
/   Author: RSA
/
/   Creation Date: 3/10/1993
/
/   Description: This routine will determine if the character passed in should
/                be <DLE> shielded or sent to the codec buffer. It also checks
/                for <DLE><ETX> and stops data transmission.
/
/   Input Parameters: ubyte ch - character to be sent to the codec.
/
/   Output Parameters: none
/
/   Global Variables Changed:  vce_rcv_idle, vce_state
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
/  Author & Date: RSA 6/8/1995.
/  Description: Added code for the pause and resume.
/  Reason: Needed for the specification.
/
/  Author & Date: RSA 6/15/1995.
/  Description: Added code to handle the <DLE><SUB> chars.
/  Reason: Need for processing the <DLE><DLE> in the data stream.
/
*******************************************************************************/
void send_voice_data(ubyte ch)
{
	ubyte i,pt[6],*loc_ptr;
	uword num;

    if((ch == DLE) && (vce_rcv_dle != TRUE))
    {
		  vce_rcv_dle = TRUE;
	 }
	 else if (vce_rcv_dle == TRUE)
	 {
	  /*	ch = voice_dte_from_char();
		count--;	*/
		switch(ch)
		{
			case DLE:
         	/*dp_vce_to_char_buffer(ch);*/
				unpack_and_send_data(ch); /* ramn 2/16/96 */
				vce_rcv_dle = FALSE;
			break;

			case SUB:
				/* dp_vce_to_char_buffer(DLE); */
        		/* dp_vce_to_char_buffer(DLE); */
				unpack_and_send_data(DLE); /* ramn 2/16/96 */
				unpack_and_send_data(DLE); /* ramn 2/16/96 */
				vce_rcv_dle = FALSE;
			break;

			case ETX: 
         	vce_state = FINISH_DATA_TRANSMIT;
				vce_rcv_dle = FALSE;
			break;

			case CAN:
        		/*voice_dte_from_clear();*/
				dp_vce_to_clear();  /* ramn 3/15/96 */
   
		      /* Set the voice transmit level */ 	/* ramn 3/15/96 */
      	   dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);

				/* ramn 3/15/96 */
				/* dp_vce_compression has to be called after dp_vce_init_call_progress */
   	      dp_vce_compression_init(VOICE_TRANSMIT, vce_comp_method[vce_comp_index].id,
                                    vce_sampling_rate,vce_speaker_vol);
	
				vce_rcv_dle = FALSE;
			break;

    		case NUL:					/* stroke the Voice Inactivity Timer */
        		vce_inactivity_timer = vce_inactivity_time;
				vce_rcv_dle = FALSE;
			break;

    		case 'd':				/* decrease the transmit volume */
        		vce_transmit_volume--;
        		if (vce_transmit_volume <= vce_tx_vol_range[0])
            	vce_transmit_volume = vce_tx_vol_range[0];
        		dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);
				vce_rcv_dle = FALSE;
			break;

    		case 'u':    /* Increase the transmit volume */
        		vce_transmit_volume++;
        		if (vce_transmit_volume >= vce_tx_vol_range[1])
            	vce_transmit_volume = vce_tx_vol_range[1];
        		dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);
				vce_rcv_dle = FALSE;
			break;

    		case 'p':        /* Need to pause the TX data stream. */
        		/*dp_vce_pause(ON);*/	/* ramn 8/19/96 */
				vce_rcv_dle = FALSE;
			break;

			case 'r':        /* Need to resume the RX data. */
	      	/*dp_vce_pause(OFF);*/ /* ramn 8/19/96 */
				vce_rcv_dle = FALSE;
			break;

    		case '?':
        		voice_dte_to_char(DLE);
        		voice_dte_to_char('X');

				voice_dte_to_char('A');
				voice_dte_to_char('S');
				voice_dte_to_char('T');
				voice_dte_to_char('B');
				voice_dte_to_char('=');

			 num = dp_vce_to_free();
		    loc_ptr = (ubyte *)&pt[0];
		    for (i=0; i<5; i++)
		    {
				*loc_ptr++ = (num % 10) + '0';
				num = num / 10;
		    }

		    /* Remove all leading 0's */
		    for (i=5; i>0; i--)
		    {
				if (*--loc_ptr != '0')
			    break;
		    }

		    if (!i)
				voice_dte_to_char('0');

		    while (i>0)
		    {
				voice_dte_to_char(*loc_ptr--);
				i--;
		    }
        	 voice_dte_to_char(DLE);
        	 voice_dte_to_char('.');
			 vce_rcv_dle = FALSE;
			break;
		
			case '/':
			case '~':
				vce_rcv_dle = FALSE;
			break;		/* if DTMF shield chars recieved do not send them to dsp */

			default:
				vce_rcv_dle = FALSE;
			break;	
		} /* switch */
	 } /* else if */
/* modified by ramn on 2/13/96 */
	 else
    {
		unpack_and_send_data(ch);
	 }	
}


void unpack_and_send_data(ubyte ch)
{
	switch(vce_comp_method[vce_comp_index].id)
	{

		case CL1: 	/* CL1, 8bit linear */
		case SIGNED_PCM:
#if 0
		case UNSIGNED_PCM:
#endif
   	  dp_vce_to_char_buffer(ch);
		break;

		case UNSIGNED_PCM:
	  /*	case UNSIGNED_PCM_2:*//* ramn 2/19/96 */	/* 16 bit linear */
	
		  if(dp_vce_to_free() > 2)
		  {
   	  		dp_vce_to_char_buffer(ch);
   	  		dp_vce_to_char_buffer(ch);
		  }	

/*
		  if(dp_vce_to_free() > 2)
		  {
   	  		dp_vce_to_char_buffer(ch);
   	  		dp_vce_to_char_buffer(ch);
		  }	
*/
		break;
	
		case AD4_PCM:
	  /*	case AD4_PCM_2:*//* ramn 2/19/96 */ 	/* AD4 */
			if(dp_vce_to_free() > 2)
			{
				dp_ad3_byte = ch;
				dp_ad3_byte = (dp_ad3_byte & 0x0f);
				dp_vce_to_char_buffer(dp_ad3_byte);
			
				dp_ad3_byte = (ch >> 4);
				dp_vce_to_char_buffer(dp_ad3_byte);
			}
		break;
	
		case AD3_PCM:	/* AD3 */
			switch(ad3_count)
			{
				case 0:
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = ad3_long_wrd_1;
					ad3_count++;
				break;

				case 1:
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 8));
					ad3_count++;
				break;

				case 2:
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 16)); 
					ad3_count++;
				break;

			}

			if((ad3_sampl_count == 8) && ( ad3_count == 3))
			{
				ad3_count = 0;
				ad3_dp_long_wrd = ad3_long_wrd_2;
				ad3_sampl_count = 0;
			}

			if((ad3_sampl_count < 8) && (dp_vce_to_free() > 2))
			{
				dp_ad3_byte = (ubyte)ad3_dp_long_wrd;
				dp_ad3_byte = (dp_ad3_byte & 0x07);
				dp_ad3_byte = (dp_ad3_byte << 1);
	      	dp_vce_to_char_buffer(dp_ad3_byte);

				dp_ad3_byte = (byte)ad3_dp_long_wrd;
				dp_ad3_byte = (dp_ad3_byte & 0x38);
				dp_ad3_byte = (dp_ad3_byte >> 2 );
	      	dp_vce_to_char_buffer(dp_ad3_byte);

				ad3_dp_long_wrd = (ad3_dp_long_wrd >> 6);
				ad3_sampl_count = ad3_sampl_count + 2;
			}
		break;
	

	}
}


/* commented by ramn on 11/16/95 */
/*ramn rewrote this to make it more time efficient */

#if 0
{
    if (ch == DLE)
    {
        if (vce_rcv_dle)
        {
          dp_vce_to_char_buffer(ch);
    	    vce_rcv_dle = FALSE;
        }
        else
        {
    	    vce_rcv_dle = TRUE;
        }
    }

/* Start Change 6/15/1995. */
    else if (ch == SUB && vce_rcv_dle)
    {
        dp_vce_to_char_buffer(DLE);
        dp_vce_to_char_buffer(DLE);
        vce_rcv_dle = FALSE;
    }
/* End Change 6/15/1995. */
    else if (ch == ETX && vce_rcv_dle)
    {
        vce_state = FLUSH_LINE;
        vce_rcv_dle = FALSE;
    }
    else if (ch == CAN && vce_rcv_dle)
    {
        vce_rcv_dle = FALSE;
        voice_dte_from_clear();
    }

    /* stroke the Voice Inactivity Timer */
    else if (ch == NUL && vce_rcv_dle)
    {
        vce_rcv_dle = FALSE;
        vce_inactivity_timer = vce_inactivity_time;
    }

    /* decrease the transmit volume */
    else if (ch == 'd' && vce_rcv_dle)
    {
        vce_rcv_dle = FALSE;
        vce_transmit_volume--;
        if (vce_transmit_volume <= vce_tx_vol_range[0])
            vce_transmit_volume = vce_tx_vol_range[0];
        dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);
    }
    else if (ch == 'p' && vce_rcv_dle)
    {
/* Start Change 6/8/1995. */
        /* Need to pause the TX data stream. */
        vce_rcv_dle = FALSE;
        /*dp_vce_pause(ON);*/ /* ramn 8/19/96 */
/* End Change 6/8/1995. */
    }
    else if (ch == 'r' && vce_rcv_dle)
    {
/* Start Change 6/8/1995. */
        /* Need to resume the RX data. */
        vce_rcv_dle = FALSE;
        /*dp_vce_pause(OFF);*/ /* ramn 8/19/96 */
/* End Change 6/8/1995. */
    }
    /* Increase the transmit volume */
    else if (ch == 'u' && vce_rcv_dle)
    {
        vce_rcv_dle = FALSE;
        vce_transmit_volume++;
        if (vce_transmit_volume >= vce_tx_vol_range[1])
            vce_transmit_volume = vce_tx_vol_range[1];
        dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);
    }
    else
    {
        vce_rcv_dle = FALSE;
        dp_vce_to_char_buffer(ch);
    }
}
#endif


/************************************************************************
*
* this routine added by ramn on 2/16/96
*
* this routine is needed for record mode
* in this mode the data may need to be packed and sent to DTE
*
*************************************************************************/

void pack_data_and_send(void)
{
	ubyte ch;
	switch(vce_comp_method[vce_comp_index].id)
	{
		case CL1: 	/* CL1, 8bit linear */
		case SIGNED_PCM:
		/*case SIGNED_PCM_2:*//* ramn 2/19/96 */
		/*case UNSIGNED_PCM:*/
			ch = dp_vce_from_char();
		   if (ch == DLE)         
   			voice_dte_to_char(DLE);
		   voice_dte_to_char(ch);
		   count--;
		break;

		case UNSIGNED_PCM:
		/*case UNSIGNED_PCM_2:*//* ramn 2/19/96 */	/* 16 bit linear */

			if((voice_dte_to_free() > 4) && (count > 2))
			{			
				ch = dp_vce_from_char();
				if (ch == DLE)         
   				voice_dte_to_char(DLE);
		   	voice_dte_to_char(ch);
			   count--;
		
			  	ch = dp_vce_from_char();
			   if (ch == DLE)         
   				voice_dte_to_char(DLE);
			   voice_dte_to_char(ch);
			   count--;

		  	}

			if((voice_dte_to_free() > 4) && (count > 2))
			{			
				ch = dp_vce_from_char();
				if (ch == DLE)         
   				voice_dte_to_char(DLE);
		   	voice_dte_to_char(ch);
			   count--;
		
			  	ch = dp_vce_from_char();
			   if (ch == DLE)         
   				voice_dte_to_char(DLE);
			   voice_dte_to_char(ch);
			   count--;

		  	}
			break;
	

		case AD4_PCM:
		/*case AD4_PCM_2:*//* ramn 2/19/96 */ 	/* AD4 */
		/* need to have atleast 2 samples from Cutlass before packing
			need 2 bytes to store DLE o (receive buffer overrun) and 1 byte
			for the packed 2 samples
		*/
			if((voice_dte_to_free() > 4) && (count > 2))
			{ 
				ch = dp_vce_from_char();
				count--;
				dp_ad3_byte = ch;
				ch = dp_vce_from_char();
				count--;
				ch = (ch << 4);
				dp_ad3_byte = (dp_ad3_byte | ch);

            if (dp_ad3_byte == DLE)         
    	      	voice_dte_to_char(DLE);

				voice_dte_to_char(dp_ad3_byte);

		  	} 
		break;
	
		case AD3_PCM:	/* AD3 */
			ch = dp_vce_from_char();
			ch = (ch >> 1);
			switch(ad3_count)
			{
				case 0:
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = ad3_long_wrd_1;

					ch = dp_vce_from_char();
					ch = (ch >> 1);
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 3));
					ad3_count = ad3_count + 2;
					count =count - 2;
				break;

				case 2:
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 6)); 

					ch = dp_vce_from_char();
					ch = (ch >> 1);
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 9)); 
					ad3_count = ad3_count + 2;
					count =count - 2;
					break;

				case 4:
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 12)); 

					ch = dp_vce_from_char();
					ch = (ch >> 1);
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 15)); 
					ad3_count = ad3_count + 2;
					count =count - 2;
				break;
				
				case 6:
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 18)); 

					ch = dp_vce_from_char();
					ch = (ch >> 1);
					ad3_long_wrd_1 = (ulong)ch;
					ad3_long_wrd_2 = (ad3_long_wrd_2 | (ad3_long_wrd_1 << 21)); 
					ad3_count = ad3_count + 2;
					count =count - 2;

					if(dp_ad3_byte == 0)
					{
						dp_ad3_byte = 3;
						ad3_dp_long_wrd = ad3_long_wrd_2;

						ad3_count = 0;
						ad3_long_wrd_1 = 0;
						ad3_long_wrd_2 = 0;
					}
			 	break;
			}

			switch(dp_ad3_byte)
			{
				case 3:
					ch = (ubyte)ad3_dp_long_wrd;

				   if (ch == DLE)         
   					voice_dte_to_char(DLE);

				   voice_dte_to_char(ch);
					dp_ad3_byte--;
				break;

				case 2:
					ad3_dp_long_wrd = (ad3_dp_long_wrd >> 8);
					ch = (byte)ad3_dp_long_wrd;

			   	if (ch == DLE)         
   					voice_dte_to_char(DLE);

			   	voice_dte_to_char(ch);
					dp_ad3_byte--;
				break;

				case 1:
					ad3_dp_long_wrd = (ad3_dp_long_wrd >> 8);
					ch = (byte)ad3_dp_long_wrd;
			
				   if (ch == DLE)         
 					voice_dte_to_char(DLE);

			   	voice_dte_to_char(ch);
					dp_ad3_byte--;
				break;
			}
		break;
	
	}

}

/*******************************************************************************
/
/   Routine: vce_timer
/																	  
/   Author: RSA
/
/   Creation Date: 10/7/92
/
/   Description: This routine is called every 100msecs to process the voice
/                timers
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void vce_timer(void)
{
    if (vce_silence_detc_timer)
	   vce_silence_detc_timer--;
    if (vce_rb_never_timer)
        vce_rb_never_timer--;
    if (vce_rb_away_timer)
        vce_rb_away_timer--;
    if (vce_2100hz_msg_delay)
        vce_2100hz_msg_delay--;
    if (vce_busy_msg_delay)
        vce_busy_msg_delay--;
    if (vce_1100hz_msg_delay)
        vce_1100hz_msg_delay--;
    if (vce_dialtone_msg_delay)
        vce_dialtone_msg_delay--;
    if (vce_1300hz_msg_delay)
        vce_1300hz_msg_delay--;
    if (vce_2225hz_msg_delay)
        vce_2225hz_msg_delay--;
    if (vce_inactivity_timer)
        vce_inactivity_timer--;
	 if (debounce_timer)	  			/* ramn 2/25/96 */
			debounce_timer--;
#if 0
	 if (ring_away_timer)		/* ramn 4/5/96 */
			ring_away_timer--;
#endif
	if(time_since_entering_plbmode)	/* ramn 6/25/96 */
		time_since_entering_plbmode--;


}


/*******************************************************************************
/
/   Routine: vce_configure
/
/   Author: RSA
/
/   Creation Date: 2/16/1993
/
/   Description: This routine is used to configure the voice code based upon
/                AT commands.
/
/   Input Parameters: ubyte baud - Terminal baud rate
/
/                     ubyte cmd_set - User selected command set
/                           0 - None selected
/                           1 - TIA IS 101 spec
/                           2 - Rockwell spec
/
/                     ubyte speaker_vol - User selected speaker volume
/	        	    0 - Low volume
/			    1 - Low volume
/			    2 - Medium volume
/			    3 - High volume
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void vce_configure(ubyte baud, ubyte cmd_set, ubyte speaker_vol,
                   ubyte flow_ctl, ubyte caller_id)
{
    vce_baudrate = baud;

    /* Setup the user defined speaker volume for the dp code */
    vce_speaker_vol = speaker_vol;

    /* Setup the speaker parameters */
    /*dp_vce_init_speaker_vol(vce_speaker_vol);*/ /* ramn 8/19/96 */

    /* Setup the flow control to be used by the voice module */
    vce_mod_term_fctrl = flow_ctl;
    vce_term_mod_fctrl = flow_ctl;

    /* Setup the caller id configuration */
    vce_caller_id = caller_id;    
        
    /* If the command set type has changed then initialize the variables for
       that set */
    vce_cmd_set = cmd_set;
}

/*******************************************************************************
/
/   Routine: vce_hangup
/
/   Author: RSA
/
/   Creation Date: 2/16/1993
/
/   Description: This routine will hangup the current voice connection and place
/                the voice code into the offline command state.
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  vce_state, vce_mode
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void vce_hangup(void)
{
	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	ubyte voice_mode_parameter;

#if 0
    /* Move the data pump out of the voice mode and into idle */
    dp_vce_return_to_idle();

    /* Reset all of the line select relays */
    dp_vce_hook_relay(OFF);
    dp_vce_phone_relay(TELCO);
/* Start Change 7/28/1995. */
    dp_vce_speaker(OFF,OFF);
    dp_vce_microphone(OFF,OFF);
/* End Change 7/28/1995. */
#endif /* ramn 1/16/96 */

/* ramn 8/7/96 */
	 if((tele_emul_value == 1) || (spkr_phn_mode == TRUE)) /* ramn 7/11/96 */
	 {	
		 tele_emul_enable(OFF);	/* ramn 7/11/96 */
   	 spkr_phn_mode = FALSE;
	  	 tele_emul_value = FALSE;
	    executing_spkr_phn = FALSE; /* ramn 7/18/96 */

#if 0
			afe_choice = AFE1;	  			/* configure AFE1 for spkr phn mode */
			first_low_byte = 0x0;
			first_high_byte = 0x0;		
			second_low_byte = 0x00;
			second_high_byte = 0x0; 
			LOAD_PACKET_MODEM_VCE_PGC_INIT
			ack_or_response = FALSE;
			send_pkt_to_dsp();

			afe_choice = AFE2;				/* configure AFE2 for spkr phn mode */
			first_low_byte = 0x0;
			first_high_byte = 0x0;		
			second_low_byte = 0x00;
			second_high_byte = 0x0; 
			LOAD_PACKET_MODEM_VCE_PGC_INIT
			ack_or_response = FALSE;
			send_pkt_to_dsp();
#endif

	 }

/* 
	ramn 9/23/96 , 
	if any vls command issued during conv rec terminate conv rec
*/
			if(conv_rec_going_on == TRUE)
				exit_conv_rec_vls17();


	if(acu_cntrld_hangup < 2) /* ramn 1/16/96 */
	   execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,OFF,OFF,OFF,OFF); /* +vls=0 */
	vls_cmd_value = 0;
	
   vce_state = INIT_OFFLINE_COMMAND;
}
    

/*******************************************************************************
/
/   Routine: vce_connect
/
/   Author: RSA 2/12/1993
/
/   Creation Date: 3/10/1993
/
/   Description: This routine will start the voice connection.  If parameter
/                passed in indicates answer mode the voice code will move
/                immedately to the online command state.  If it is originate
/                not dialed this routine will only take the modem off hook
/                and wait for the indication of dialed before moving to
/                a new state.
/
/
/   Input Parameters: ubyte state - State of the connection
/                       0 - Originate dialed
/                       1 - Answer connection
/                       2 - Originate not dialed
/
/   Output Parameters: none
/
/   Global Variables Changed:  vce_state, vce_rb_never_timer
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA/keh 3/27/95
/   Description: Redefine connect types for vce_connect()
/   Reason: Bad connect types between ACU and voice_connect()
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void vce_connect(ubyte state)
{
    /* If Answer mode then need to move to the online state.
        Else need to make sure the remote has picked up the phone before
        moving to the online command state.  This is done by detecting Ringback. */
    if (state == VOICE_ANSW_CONN)
    {
        dp_vce_hook_relay(ON);
		  vls_cmd_value = 1;				/* ramn 9/11/96 */	
		  dp_vce_phone_relay(ON);		/* ramn 9/11/96 */
        vce_state = INIT_ONLINE_COMMAND;
    }
    else if (state == VOICE_ORIG_NOT_DIALED)
    {
		  vls_cmd_value = 1;				/* ramn 9/11/96 */	
		  dp_vce_phone_relay(ON);		/* ramn 9/11/96 */
        dp_vce_hook_relay(ON);
    }
    /* Else test for originate, but not yet dialed command */
    else if (state == VOICE_ORIG_CONN)
    {
        /* Place the data pump into voice mode */
        /*dp_vce_init();*/	/* ramn 2/21/96 */

        /* Initialize the data pump to detect call progress while in online
            command state */
        /*dp_vce_init_call_progress(ONLINE_COMMAND,vce_cmd_set);*/ /* ramn 2/21/96 */

			/* ramn 2/21/96 */
         dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                                   vce_sampling_rate,vce_speaker_vol);


#if 0	/* ramn 6/28/96 disable ring back detection */
        /* If VRN (ringback never came timer) is 0 then enter online command mode
            immediately. */
        if (!vce_rb_never_time)
        {
            vce_state = VOICE_ORIG_COMPLETE;
        }
        else
        {
            vce_rb_never_timer = vce_rb_never_time;
            vce_state = WAIT_FOR_1ST_RB;
        }
#endif
		  dp_vce_phone_relay(ON);		/* ramn 9/11/96 */
		  vls_cmd_value = 1;				/* ramn 9/11/96 */	

		  vce_state = VOICE_ORIG_COMPLETE; /* ramn 6/28/96 */

    }
	 else if(state == VOICE_DIAL_HANGUP) 	/* ramn 6/27/96 */
	 {
		vce_reset();
		vce_state = DIAL_FAILED;
	 }
	 else if(state == VOICE_KB_ABORT)
	 {
	 	vce_reset();
		vce_state = DIAL_FAILED_KB;	

      dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                                   vce_sampling_rate,vce_speaker_vol);
		vce_mode_hangup();	/* ramn 12/3/96 */

	 }
	 else if(state == VOICE_DIAL_HANGUP_NODT) 	/* ramn 12/3/96 */
	 {
		vce_reset();
		vce_state = DIAL_FAILED_NODT;
      dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                                   vce_sampling_rate,vce_speaker_vol);
		vce_mode_hangup();	/* ramn 12/3/96 */


	 }
	
}

/*******************************************************************************
/
/   Routine: vce_start
/
/   Author: RSA
/
/   Creation Date: 3/10/1993
/
/   Description: This routine will place the voice code into the offline command
/                state.
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  vce_state, vce_mode
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void vce_start(void)
{
    vce_state = INIT_OFFLINE_COMMAND;

}

/*******************************************************************************
/
/   Routine: vce_reset
/
/   Author: RSA
/
/   Creation Date: 2/16/1993
/
/   Description: This routine will shut down the voice code and force the data
/                pump out of voice operation.
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void vce_reset(void)
{
    /* Move the data pump out of the voice mode and into idle */
    dp_vce_return_to_idle();

    /* Reset all of the line select relays */
    dp_vce_hook_relay(OFF);
    dp_vce_phone_relay(TELCO);
/* Start Change 7/28/1995. */
    dp_vce_speaker(OFF,OFF);
    dp_vce_microphone(OFF,OFF);
/* End Change 7/28/1995. */
	vls_cmd_value = 0; /* reset the status of the vls cmd */ /* ramn 1/16/96 */

    /* Stop the voice code from running */
    vce_mode = OFFLINE_COMMAND;
        voice_event_rept = vce_idl_events; /* ramn 1/15/96 */

    vce_state = VOICE_NOT_RUNNING;

}

/*******************************************************************************
/
/   Routine: vce_enable_inact_timer
/
/   Author: RSA
/
/   Creation Date: 3/29/1994.
/
/   Description: This routine will turn the inactivity timer on
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  vce_inactivity_timer_on
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/

#if 0	/* ramn 9/13/96 */
void vce_enable_inact_timer(void)
{
    if (vce_inactivity_time)
    {
       vce_inactivity_timer_on = TRUE;        
       vce_inactivity_timer = vce_inactivity_time;
    }     
}
#endif

/*******************************************************************************
/
/   Routine: vce_enable_cadence_rpt
/
/   Author: RSA
/
/   Creation Date: 5/9/1994.
/
/   Description: This routine will enable the cadence time for ringback,
/                busy, and fast busy.                               
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  none
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/

#if 0	/* ramn 9/13/96 */
void vce_enable_cadence_rpt(ubyte enable, ubyte rpt_time)
{
     vce_ctl_tone_rpt_active = enable;
     vce_ctl_tone_rpt_time = rpt_time;

}
#endif

/*******************************************************************************
/
/   Routine: vce_rpt_ctl_cadence
/
/   Author: RSA
/
/   Creation Date: 3/29/1994.
/
/   Description: This routine will report the cadence time for ringback,
/                busy, and fast busy.                               
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  none
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date: RSA/keh 3/29/95
/   Description: add dp_vce_last_energy_pres and dp_vce_last_energy_abs to
/                  to "vce_rpt_ctl_cadence"
/   Reason: incorrect reporting of some cadences (fast busy CPOF is 2 not 3)
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/

#if 0	/* ramn 9/13/96 */
void vce_rpt_ctl_cadence(ubyte type, ubyte *tone_on, ubyte *tone_off)
{
        if (type == RINGBACK_DETECTED)
        {
                *tone_on = vce_ring_back_timer_on/10;
                *tone_off = vce_ring_back_timer_off/10;
        }
        else if (type == BUSY_DETECTED)
        {
                *tone_on = vce_busy_timer_on/10;
                *tone_off = vce_busy_timer_off/10;
        }
}
#endif



