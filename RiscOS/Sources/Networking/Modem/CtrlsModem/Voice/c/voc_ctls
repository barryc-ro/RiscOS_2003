/******************************************************************************
/
/   Copyright 1994, 1995
/   All Rights Reserved by :
/	 RSA
/	 7701 Six Forks Road
/	 Suite 120
/	 Raleigh, NC  27615
/	 (919) 846-7171
/
/   This document contains material confidential to RSA. Its contents
/   must not be revealed, used or disclosed to anyone or company without
/   written permission by RSA. The information contained herein is solely
/   for the use of RSA.
/
/   File     : dv02mn09.c
/
/   Version  : 1.00
/
/   Function : Contains the data pump support code for the
/              for the Rockwell RCV144DPL voice module
/
/   Product  : Voice Core Code
/
/   Platform : Hitachi H8
/
/   History  :
/
/   Created  : 01/19/94 
/
/   -----------------------------------------------------------
/   -			    Modifications		      -
/   -----------------------------------------------------------
/
/   Author & Date : RSA 
/   Description   : 
/   Reason        : 
/
******************************************************************************/
#include "sys_def.h"
#include "dv_def.h" 
#include "dv_mem.h"
#include "dv_pro.h"

#include "..\io\linepro.h" 
#include "dsp_cod.h" /* ramn 6/7/96 */

/* added by ramn on 10/10/95 */
#include "vce_def.h"
#include "..\mt_ctls1\cp_dsp.h"
#include "..\mt_ctls1\mt_macro.h"
#include "vce_cpro.h"
#include "vc00mem.h"
#include "voc_icd.h"
#include "func_mac.h"

#include "fab.h" 	/* ramn 6/13/96 */

#define UPLD_DNLD_ADDR_LOW 			0xf8	/* ramn 3/20/96 */
#define UPLD_DNLD_ADDR_HIGH 			0xf9
#define UPLD_DNLD_DATA_REGIS			0xfa
#define CP_CONTROL_REGISTER 			0xfc
#define INTERNAL_RST_VECTOR			0x800

#define ERR_MSG4 "ERROR in dnlding PWR ON PATCH"
#define ERR_MSG3 "ERROR in dnlding PWR ON PATCH INT RESET Vec"
#define OK_MSG4 "Dnlding PWR ON PATCH OK"
#define OK_MSG3 "Dnlding PWR ON PATCH INT RESET Vec OK"
#define RESPONSE           1
extern void dsp_poke(uword, uword);	/* ramn 6/12/96 */
#define SPKR_PKT_SENT "Speaker phone packet sent to DSP"
#define ACK 0


ubyte wait_time = 5;
extern ubyte spkr_phn_dnl;	/* ramn 4/22/96 */
void wait_a_while(void);
extern void dnld_patch();   /* ramn 5/18/96 */


extern void enable_int(void);
extern void disable_int(void);

void end_spkr_phn_mode(void); /* ramn 3/19/96 */
void dnld_spkr_phn_code(uword *);	/* ramn 4/22/96 */
void enable_spkr_phone(void);		/* ramn 5/13/96 */

void tele_emul_enable(ubyte); /* ramn 2/23/96 */
void vce_local_phn_hook_status(void); /* ramn 1/24/96*/
void send_dle(ubyte); /* 1/24/96 */

void dp_vce_get_capability(ubyte *, ubyte *, ubyte *, ubyte *,
	               ubyte *, uword *, ubyte *, ubyte *,uword *,uword *);
void dp_vce_get_compression_info(ubyte, struct vce_comp_struct *);
void dp_vce_set_level(ubyte, ubyte);
void dp_vce_send_tone(uword, uword, uword);
void dp_vce_send_dtmf_tone(ubyte, uword);
ubyte dp_vce_call_progress(void);
void dp_vce_compression_init(ubyte, ubyte, uword, ubyte);
void dp_vce_return_to_idle(void);
void dp_vce_speaker(ubyte,ubyte);
void dp_vce_microphone(ubyte,ubyte);
void dp_set_speaker(ubyte,ubyte);
void set_spkr_phn_mic_vol(void);		/* ramn 7/18/96 */
void 	set_spkr_phn_spkr_vol(void);
void after_exit_spkrphn_init_for_voice(void);  /* ramn 10/1/96 */


#if 0
void dp_vce_timer(void);
void dp_vce_init_call_progress(ubyte, ubyte);  /* ramn 2/21/96 */
ubyte dp_vce_detect_silence(ubyte);				  /* ramn 2/21/96 */
void set_voice_compression(ubyte, uword);
void set_sampling_rate(uword);
uword dp_vce_to_free(void);
void dp_vce_to_char(ubyte);
uword dp_vce_to_num(void);
uword dp_vce_from_num(void);
ubyte dp_vce_from_char(void);
void dp_vce_to_char_buffer(ubyte);
void dp_vce_phone_relay(ubyte);
void dp_vce_hook_relay(ubyte); 
void dp_vce_headset(ubyte);

void set_frequency(ubyte, uword);
void dp_vce_init_speaker_vol(ubyte);
ubyte read_dp_vce_ram(uword);
void write_dp_vce_ram(uword,uword);
void write_byte_dp_vce_ram(uword,ubyte);
void dp_vce_set_data_direction(ubyte);
void dp_vce_change_voice_params(void);
void dp_vce_translate_voice(ubyte,ubyte);
void dp_vce_pause(ubyte pause);
#endif /* ramn */

/* Start Change 5/17/1995. */
/* interrupt void dp_vce_int(void);*/ /* ramn 10/10/95 */
/* End Change 5/17/1995. */

extern void line_select_vector(ubyte);

/* ramn 9/10/96 */
extern uword pwr_on_patch[500];
extern void set_7_wait_states(void);		/* this sets 7 wait states for musket-cp interf*/
ubyte patch_re_dnlded = 1;
extern uword dsp_code[4096];	/* ramn 4/22/96 */




/* ramn 9/16/96 */
#define PBA     			0xFFC000			/* Musket Peripheral Base Address*/
#define GPR1    			(PBA + 0x208)
#define GPR_TNKL 			GPR1
#define GPIO_BIT_TNKL	2        		/* GPIO 10 - GPR1, GPCR1 */
#define ACTIVATE        0
#define DEACTIVATE      1

#define   CID_RELAY_ON   0x0000                  /* low active */
#define   CID_RELAY_OFF  0x0200

extern void set_gpio_bit(uword *, ubyte, ubyte);

void exit_conv_rec_vls17(void);
ubyte conv_rec_vls17(void);

ubyte	conv_rec_going_on	= 0;

/* ramn 11/18/96 */
extern const uword vcepatch[];
extern void voice_dnld_patch(const uword tbl[]);
extern const uword vcepatch[];

void	wakeup_from_sleep_in_voice(void);	/* ramn 12/3/96 */


/*******************************************************************************
/
/   Routine: dp_vce_init
/
/   Author: RSA 
/
/   Creation Date: 01/19/1994
/
/   Description: This routine will place the data pump into the VOICE mode
/                and initialize any parameters needed.                
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  dp_vce_data_direction, dp_vce_receiver_idle
/                              dp_vce_sampling_rate, dp_vce_int_tone_count
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
/  Author & Date: RSA 6/13/1995.
/  Description: Initialized a DTMF variable to FALSE.
/  Reason: Needed for proper shielded DTMF reporting.
/
*******************************************************************************/
void dp_vce_init(void)
{ /* changed by ramn on 1/8/95 */
  /*	ubyte voice_mode_parameter;*/
	/* Initialize direction to an idle state and the sampling rate to 7200 Hz */
/*	dp_vce_data_direction = IDLE; *//* may not need this variable */

	/* Reset the flag indicating it is OK to issue a read DSP command */
	dp_vce_receiver_idle = TRUE;
	dp_vce_sampling_rate = 8000; /* was 4800 changed by ramn on 7/15/96
												after checking with mikeW */
/*
 	dp_vce_tx_busy = FALSE;
	dp_vce_DTMF_shield_sent = FALSE; 
*/ /* ramn 2/13/96 */
	
#if 0	 /* this packet sent in dp_vce_compression_init */
/* need to implement the other modes i.e. 8 to 20 */
	if((vce_mode != RECEIVE_MODE) && (vce_mode != TRANSMIT_MODE)) /* ramn 2/21/96 */
		voice_mode_parameter = 0;
	else if((vce_mode == RECEIVE_MODE) && thru_phone)
		voice_mode_parameter =2;
	else if((vce_mode == TRANSMIT_MODE) && thru_phone)
		voice_mode_parameter = 3;

	else if((vce_mode == RECEIVE_MODE) && thru_line)
		voice_mode_parameter = 4;
	else if((vce_mode == TRANSMIT_MODE) &&thru_line)
		voice_mode_parameter = 5;

	else if((vce_mode == RECEIVE_MODE) && thru_mic)
		voice_mode_parameter = 6;
	else if((vce_mode == TRANSMIT_MODE) && thru_spkr)
		voice_mode_parameter = 7;

	LOAD_PACKET_MODEM_VCE_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();
#endif 
}

/*******************************************************************************
/
/   Routine: dp_vce_get_capability
/
/   Author: RSA
/
/   Creation Date: 10/8/92
/
/   Description: This routine will inform the voice module of the capability
/		 of the selected voice parameter.
/
/   Input Parameters: ubyte *num_methods - 1 byte value indicating the number of
/					   compression methods available.
/		      ubyte *rcv_range - 2 ubyte value indicating the available
/					 receive gain range.
/		      ubyte *rcv_default - 1 ubyte value indicating the default
/					   receive gain value
/		      ubyte *tx_range - 2 ubyte value indicating the available
/					transmit volume range
/		      ubyte *tx_default - 1 ubyte value indicating the default
/					  transmit volume value
/		      uword *line_sel - Bit mapped value indicating the possible
/                                       voice I/O devices that are components
/                                       in the possible hardware configurations
/                                       0 - On hook; Local Phone connected to telco
/                                       1 - Off hook; Local phone detecting off hook
/                                       2 - On hook; Local phone connected to DCE
/                                       3 - Off hook; Local phone connected to telco
/                                       4 - On hook; Internal speaker connected
/                                           to DCE; local phone connected to telco
/                                       5 - Off hook; Internal speaker connected
/                                           to telco; local phone detecting off hook
/                                       6 - On hook; Internal microphone connected
/                                           to DCE; local phone connected to telco
/                                       7 - Off hook; Internal microphone and
/                                           internal speaker connected to telco; 
/                                           local phone detecting off hook
/                                       8 - On hook; External speaker connected
/                                           to DCE; local phone connected to telco
/                                       9 - Off hook; External speaker connected
/                                           to telco; local phone detecting off hook
/                                       10- Off hook; Internal microphone and
/                                           external speaker connected to telco; 
/                                           local phone detecting off hook
/                                       11- On hook; External microphone connected
/                                           to DCE; local phone connected to telco
/                                       12- Off hook; External microphone and
/                                           internal speaker connected to telco; 
/                                           local phone detecting off hook
/                                       13- Off hook; External microphone and
/                                           external speaker connected to telco; 
/                                           local phone detecting off hook
/                                       14- On hook; External microphone and
/                                           speaker combo connected to DCE; 
/                                           local phone connected to telco
/                                       15- Off hook; External microphone and
/                                           speaker combo connected to DCE; 
/                                           local phone detecting off hook
/		     ubyte *comp_default - 1 ubyte value indicating the default
/					   compression method index.
/		     ubyte *bps_default - 1 ubyte value indicating the default
/					   number of bits per sample
/		     uword *samp_rate - 1 word values indicating the default
/					sampling rate for the default
/					compression method.
/
/		     uword *buf_size - 1 word values indicating the receive 
/					buffer size.
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
*******************************************************************************/
void dp_vce_get_capability(ubyte *num_methods, ubyte *rcv_range, 
									ubyte *rcv_default,ubyte *tx_range,
									ubyte *tx_default, uword *line_sel,
		       					ubyte *comp_default, ubyte *bps_default, 
									uword *samp_rate, uword *buf_size)
{
	*num_methods = NUMBER_OF_COMP_METHODS;
	*rcv_range++ = RECEIVE_GAIN_LOW;
	*rcv_range = RECEIVE_GAIN_HIGH;
	*rcv_default = RECEIVE_GAIN_DEFAULT;
	*tx_range++ = TRANSMIT_VOL_LOW;
	*tx_range = TRANSMIT_VOL_HIGH;
	*tx_default = TRANSMIT_VOL_DEFAULT;
   *line_sel = VOICE_IO_DEVICES;

	/* Indicate that the default method corresponds to the 2nd entry in the
	   compression structure. */
	*comp_default = 6; /* cl1 */ /* ramn 2/23/96 */
	comp_byte = 140;	/* set this to CL1 */ /* ramn 2/23/96 */

	*bps_default = 8;  /*was 4 changed by ramn 10/10/95 */
	*samp_rate = 8000; /* was 4800 changed by ramn on 7/15/96
												after checking with mikeW */

	*buf_size = DP_VCE_BUFFER_SIZE;
	/* dp_vce_spk_vol_mirror = 0;*/ /* ramn 2/13/96 */
}

/*******************************************************************************
/
/   Routine: dp_vce_get_compression_info
/
/   Author: RSA
/
/   Creation Date: 10/8/92
/
/   Description: This routine will place the compression information for the
/		 selected method into the input structure.
/
/   Input Parameters: ubyte method - Selected compression method
/		      struct comp_struct *ptr - Pointer to the compression structure
/			struct {
/			    ubyte id;		Compression id number
/			    ubyte *comp;	ASCII string describing the
/						compression method
/			    ubyte *company;	ASCII string describing the
/						company
/			    ubyte bps_range[]; 	Pointer to the allowed bits per sample
/						1st byte indicates number of entries
/						Next bytes indicate the values
/			    ubyte samp_range[]; Range of allowed sampling rates
/						1st byte indicates number of ranges
/						Next byte pairs indicate the range
/			    ubyte timing_marks; Time interval between timing marks
/			    ubyte silence_sen;	Range of silence compression sensitivity
/			    ubyte silence_exp;	Range of silence expansion
/			}
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_get_compression_info(ubyte method, struct vce_comp_struct *ptr)
{
	ubyte i;            /* Index into various arrays */

	ptr->id = id_tbl[method];
	ptr->company = (ubyte *)company_tbl[method];

	/* Get the bits per sample range from the defined table */
	for (i=0; i<=bps_tbl[method][0]; i++)
	{
		ptr->bps_range[i] = bps_tbl[method][i];
	}

	/* Get the possible sampling rates for the different methods */
	for (i=0; i<=samp_range_tbl[method][0]; i++)
	{
		ptr->samp_range[i] = samp_range_tbl[method][i];
	}

	/* Get the possible event reporting for the transmit state */
	ptr->tx_mode_events = tx_event_tbl[method];

	/* Get the possible event reporting for the receive state */
	ptr->rx_mode_events = rx_event_tbl[method];

	/* Get the possible event reporting for the idle state */
	ptr->idl_mode_events = idl_event_tbl[method];

	/* Get the number of timing marks for the compression scheme */
        ptr->timing_marks = timing_marks_tbl[method];

	/* Get the silence sensitivity setting for the compression scheme */
        ptr->silence_sen = silence_sen_tbl[method];

	/* Get the silence expansion setting for the compression scheme */
        ptr->silence_exp = silence_exp_tbl[method];
}

/*******************************************************************************
/
/   Routine: dp_vce_set_level
/
/   Author: RSA
/
/   Creation Date: 10/22/92
/
/   Description: This routine will set the receive gain.
/
/   Input Parameters: ubyte type - selects receive gain or transmit volume
/			0 - transmit volume
/			1 - receive gain
/
/		      ubyte value - New receive gain or transmit volume
/			0 - 255
/			128 corresponds to the nominal value
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_set_level(ubyte type, ubyte value)	/* changed by ramn on 10/10/95 */
{
	/* value is the level needed for record or playback level */
	/* parameter type is not used cutlass will interpret the value
		correctly depending on whether the DSP is set for record or playback	*/

	if((type == VOICE_RECEIVE) && (thru_mic == TRUE))
	{
		if(value > 123)
			value = value - 2;
		else
			value = 121;
	}


	LOAD_PACKET_MODEM_VCE_SET_AUDIO_LEVEL  /* ramn 10/10/95 */
	ack_or_response = FALSE;
	send_pkt_to_dsp();
}

/*******************************************************************************
/
/   Routine: dp_vce_send_tone
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will send a tone at the specified frequency for
/		 the specified time period.
/
/   Input Parameters: uword f1 - frequency (Hz) of the 1st tone
/
/		      uword f2 - frequency (Hz) of the 2nd tone
/
/		      uword time - length of the tone (milliseconds)
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_send_tone(uword f1, uword f2, uword time)
{ 
  /* changed by ramn on 3/12/96 */

/*    ubyte error_occured; */
	ubyte tone_on_off, tone2_level,tone1_level,x1,ch;

/* to generate tones in spkr phn mode exit spkr phn mode,
	generate tone and then reenter the skr phn mode */

	patch_re_dnlded = TRUE;	/* ramn 9/12/96 */


	if(spkr_phn_mode == TRUE) /* ramn 9/24/96 */
	{
		after_exit_spkrphn_init_for_voice();		/* ramn 10/1/96 */
	}
	patch_re_dnlded = FALSE;  /* ramn 9/12/96 */

	if(f1)		
		tone1_level = 100;	/* if tone present tone level = -10db */
	else
		tone1_level = 255;	/* if tone absent turn off (255 turns off tone ) */

	if(f2)
		tone2_level = 100;
	else
		tone2_level = 255;

	/* set the level in the dsp before giving freq info */
	LOAD_PACKET_MODEM_SET_VCE_DTMF_LEVELS   
	ack_or_response = FALSE;
	send_pkt_to_dsp();


	if(f1)
		f1 = ((f1*32767)/4800);		/* scale as needed by  cutlass */
	if(f2)
		f2 = ((f2*32767)/4800);
	tone_on_off = ON;

	LOAD_PACKET_MODEM_SEND_TONE
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	vce_send_tone_timer = (time/10); /* set dial timer so that the tone is sent out first */
	while(vce_send_tone_timer)
	{
		process_wait();
	}		/* wait till tone completely sent out */

	f1 = 0;
	f2 = 0;
	tone_on_off = OFF;

	LOAD_PACKET_MODEM_SEND_TONE
	ack_or_response = FALSE;

/* ramn clear the detected tone before shuting the tone off 3/19/96 */
	dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;   
	ch = dsp_cp();

	send_pkt_to_dsp();

	dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;/* ramn clear the detected tone 3/19/96 */   
	ch = dsp_cp();

	vce_send_tone_timer = (time/10); /* now wait for inter tone delay */
	while(vce_send_tone_timer)
	{
		process_wait();
	}	/* wait till inter tone delay is complete */

	dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;/* ramn clear the detected tone 3/19/96 */   
	ch = dsp_cp();

	x1 = *srptr[11];
	config_dtmf_dial(x1,x1); /* reconfigure dsp for dtmf mode after tone sent */

 	if((tele_emul_value == 1) || (spkr_phn_mode == TRUE)) /* ramn 3/20/96 */
	{
	  	vce_mode = OFFLINE_COMMAND;
    	voice_event_rept = vce_idl_events;  
	  	vce_state = VOICE_OFFLINE_COMMAND;

		/*dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);*/ /* ramn 3/18/96 */
		tele_emul_enable(ON);
		CTSon();

		if(vls_cmd_value == 17)			/* ramn 9/26/96 */
	 		x1 = conv_rec_vls17(); 
	}
 

/*	while (error_occured = cp_dsp());
	while (error_occured = dsp_acknowledge_packet());     
*/  /* commented by ramn on 10/10/95 */
}

/*******************************************************************************
/
/   Routine: set_frequency
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will determine the sin and cos constants for
/		 selected frequency and set the appropiate ram locations in the
/      Rockwell RCV144DPL.
/
/   Input Parameters: ubyte num - Determines if this is the 1st or 2nd tone
/				  to be set.
/
/		      uword freq - frequency of tone to be generated
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users: dp_vce_send_tone()
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0 /* ramn 8/19/96 */
void set_frequency(ubyte num, uword freq)
{ 	/* changed by ramn on 10/10/95 */
	/* this routine is not needed for cutlass as yet */
	ubyte x1;
	uword x2;
	
	x1 = num;
	x2 = freq;
}
#endif
/*******************************************************************************
/
/   Routine: dp_vce_send_dtmf_tone
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will send the specified DTMF tone for the specified
/		 time period.
/
/   Input Parameters: ubyte digit - DTMF digit
/
/		      uword time - length of the tone (milliseconds)
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_send_dtmf_tone(ubyte digit, uword time)
{ 	/* changed by ramn on 10/10/95 */
	uword f1,f2;

#if 0
/* added by ramn to enable the speaker directly */
/* from here speaker */
	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	
/* to generate tones in spkr phn mode exit spkr phn mode,
	generate tone and then reenter the skr phn mode */
	patch_re_dnlded = TRUE; /* ramn 9/12/96 */
	if(spkr_phn_mode == TRUE) /* ramn 3/20/96 */
		end_spkr_phn_mode();		
	patch_re_dnlded = TRUE;	/* ramn 9/12/96 */

	afe_choice = AFE1;
	first_low_byte = 0xdc;
	first_high_byte = 0x33;		/* speaker vol = med
											speaker_on = both Tx and Rx
											recv_gain = +12db */
	second_low_byte = 0x00;
	second_high_byte = 0x3a;

	LOAD_PACKET_MODEM_VCE_PGC_INIT

	ack_or_response = FALSE;
	send_pkt_to_dsp();

/* till here speaker */
#endif

#if 0
	if((digit >= '0') && (digit <='9'))
	{
		digit = digit - '0';
	}

#endif

	switch(digit)
	{
		case '0':
			f1 = 941;
			f2 = 1336;
		break;

		case '1':
			f1 = 697;
			f2 = 1209;
		break;

		case '2':
			f1 = 697;
			f2 = 1336;
		break;

		case '3':
			f1 = 697;
			f2 = 1477;
		break;

		case '4':
			f1 = 770;
			f2 = 1209;
		break;

		case '5':
			f1 = 770;
			f2 = 1336;
		break;

		case '6':
			f1 = 770;
			f2 = 1477;
		break;

		case '7':
			f1 = 852;
			f2 = 1209;
		break;

		case '8':
			f1 = 852;
			f2 = 1336;
		break;

		case '9':
			f1 = 852;
			f2 = 1477;
		break;

		case 'A':
		case 'a':
			/*digit = 10;*/
			f1 = 697;
			f2 = 1633;
		break;

		case 'B':
		case 'b':
			/*digit = 11;*/
			f1 = 770;
			f2 = 1633; /* ramn 6/5/96 was 1336 */
		break;

		case 'C':
		case 'c':
			/*digit = 12;*/
			f1 = 852;
			f2 = 1633;
		break;

		case 'D':
		case 'd':
			/*digit = 13 ;*/
			f1 = 941;
			f2 = 1633;
		break;

		case '*':
			/*digit = 14;*/
			f1 = 941;
			f2 = 1209;
		break;

		case '#':
			/*digit = 15;*/
			f1 = 941;
			f2 = 1477;
		break;

	}

	dp_vce_send_tone(f1,f2,time);


#if 0
	x2 = (ubyte)(time/10);
	x1 = x2 ;

	config_dtmf_dial(x1,x2);
	tone_on(digit);

	vce_send_tone_timer = (time/10); /* set dial timer so that the tone is sent out first */
	while(vce_send_tone_timer)
	{
		process_wait();
	}		/* wait till tone completely sent out */

	vce_send_tone_timer = (time/10); /* now wait for inter tone delay */
	while(vce_send_tone_timer)
	{
		process_wait();
	}	/* wait till inter tone delay is complete */

	if((tele_emul_value == 1) || (spkr_phn_mode == TRUE)) /* ramn 3/20/96 */
	{
	  vce_mode = OFFLINE_COMMAND;
    	voice_event_rept = vce_idl_events;  
	  vce_state = VOICE_OFFLINE_COMMAND;

		/*dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);*/ /* ramn 3/18/96 */
	tele_emul_enable(ON);
	CTSon();
	}
#endif 
}

/*******************************************************************************
/
/   Routine: dp_vce_init_call_progress
/
/   Author: RSA
/
/   Creation Date: 10/28/92
/
/   Description: This routine will setup the data pump to perform the selected
/                call progress events.
/
/   Input Parameters: ubyte mode - The mode of the voice code 
/                           0 - Offline command mode 
/                           1 - Online command mode
/                           2 - Receive data mode
/                           3 - Transmit data mode
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
*******************************************************************************/
#if 0
/* ramn 2/21/96 call progress init now done on dp_vce_call_progress */
void dp_vce_init_call_progress(ubyte mode, ubyte cmd_set)
{  	/* changed by ramn on 10/10/95 */
	/* which packet is used to initialize the call progress for the voice
		mode check with Billy Chen */
/* parameters changed by the RSA code
	dp_vce_1100hz_state = LOOK_FOR_TONE;
	dp_vce_tone_timer = 0;
	dp_vce_ring_state = LOOK_FOR_RINGON;
	dp_vce_ring_detected = FALSE;
	dp_vce_ring_timer = 0;
	dp_vce_call_progress_tick = 0; 
	dp_vce_energy_on = 0;
	dp_vce_energy_off = 0;
	dp_vce_last_energy_state = 0;
	dp_vce_last_energy_abs = 0;
	dp_vce_last_energy_pres = 0;
	dp_vce_silence_level =  0;
   dp_vce_cmd_set = cmd_set;

may need to do this in our implementation of the stub
*/
	ubyte prog_mode;

/* this will send the silence detection
	level and time period to the cutlass */																											

/*	LOAD_PACKET_MODEM_VCE_SET_PARAMS 
	ack_or_response = FALSE;
	send_pkt_to_dsp();
*/ /* may not be needed here */

	if(mode == OFFLINE_COMMAND)
		prog_mode =  PACKET_MODEM_INIT_CALL_PROGRESS_ON_HOOK;
	else
		prog_mode =  PACKET_MODEM_INIT_CALL_PROGRESS_OFF_HOOK_DIALED;

	LOAD_MODEM_INIT_CALL_PROGRESS  /* this will init the dsp for call prog */
	ack_or_response = FALSE;		 /* dp will detect silence, ringback,busy,
												 ans tone */
	send_pkt_to_dsp();

	/* initialize all the msg delay timers to zero */
	vce_dtmf_report_delay = 0;	
	vce_2100hz_msg_delay	= 0;
	vce_busy_msg_delay = 0;
	vce_1100hz_msg_delay = 0;
	vce_dialtone_msg_delay = 0;
	vce_1300hz_msg_delay	= 0;
	vce_2225hz_msg_delay = 0;
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_call_progress
/
/   Author: RSA
/
/   Creation Date: 10/28/92
/
/   Description: This routine will determine if a DTMF tone has been detected
/		 and return the appropiate value indicating tone.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte temp - tone detected
/			0 - DTMF 0
/			1 - DTMF 1
/			2 - DTMF 2
/			3 - DTMF 3
/			4 - DTMF 4
/			5 - DTMF 5
/			6 - DTMF 6
/			7 - DTMF 7
/			8 - DTMF 8
/			9 - DTMF 9
/			10- DTMF *
/			11- DTMF #
/			12- DTMF A
/			13- DTMF B
/			14- DTMF C
/			15- DTMF D
/			0xFF - No tone detected
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
/  Author & Date: RSA 6/7/1995.
/  Description: Fix for the 2225hz Bell Answer Tone reporting.
/  Reason: Was not an option in previous versions.
/
/  Author & Date: RSA 6/13/1995.
/  Description: Revamped the DTMF detection and reporting for
/                 the IS101 voice specification.
/  Reason: The IS101 would only report a single DTMF tone (shielded)
/           instead of multiple (every 70ms) shielded tones for DTMF.
/
*******************************************************************************/
ubyte dp_vce_call_progress(void)
{   	/* changed by ramn on 10/10/95 */
/* 
 dsp_cp(dsp_cp_packet) will detect dtmf, calling tones both fax and data, 
  and also dial tone.
 read_call_progress_reg will detect silence,ringback, busy,ans tone if online
 	and will detect ring and dial tone if on hook ie offline
*/
	ubyte ch;

/* rewritten 3/16/96 */
	dspdrv_ReadCram(ANSTONE_LOC,&ch,1);
	ch = (ch & 0x02);
	if(ch == 0x02)
		return(DETECTED_2100HZ);

	dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;          
	if(dsp_cp())
   	return(dsp_response_data[0]);

	ch = acu_call_progress();		
	if((ch == RINGON) || (ch == RINGOFF))
		return(ch);
	else
		return(NOTHING_DETECTED);


#if 0
	dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;          
	if(dsp_cp())
	{
   	return(dsp_response_data[0]);
 	}
	else
	{
	  /*	ch = read_dsp_call_progress_reg(); */

		ch = acu_call_progress();		/* ramn 2/23/96 */
		switch(ch)
		{	
			case ANSWER_TONE:
				return (ch);
			break;
			
		/* ramn 2/16/96 */
			case RINGON:
			case RINGOFF: /* report ring only if not thru_line ot not thru_phone */
				/*if((thru_line != TRUE) || (thru_phone != TRUE))*/
					return(ch);
			default:
				return (NOTHING_DETECTED);
		}
/*		return(NOTHING_DETECTED);*/

	}
#endif

}

/*******************************************************************************
/
/   Routine: dp_vce_detect_silence
/
/   Author: RSA
/
/   Creation Date: 10/26/92
/
/   Description: This routine will determine if silence has been detected based
/		 upon the sensitivity level passed in to dp_vce_voice_data_config()
/
/   Input Parameters: ubyte silence_sen - silence sensitivity level
/                       0 - 255
/
/   Output Parameters: ubyte status - TRUE - if silence has been detected
/				      FALSE - if silence has not been detected
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
/  Author & Date: RSA 6/9/1995.
/  Description: Added code for the setting of the silence detection level.
/  Reason: Needed for the +VSD, silence detection, command.
/
*******************************************************************************/
#if 0
/* ramn 2/21/96 silence detection now done on dp_vce_call_progress */
ubyte dp_vce_detect_silence(ubyte silence_sen)
{   	/* changed by ramn on 10/10/95 */
    ubyte silence_status;

/* In the RSA code looks like the decision of whether there is 
	silence here or not is decided by the controller 

	In the cutlass this decision is done by the DP 
*/
	silence_status = read_dsp_call_progress_reg();

	if(silence_status == SILENCE)
		{
			return(TRUE);
		}
	else
		{
			return(FALSE);
		}
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_compression_init
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will congifure the data pump to either transmit
/		 or receive voice data using the selected compression method.
/
/   Input Parameters: ubyte direction - Direction of the data
/			0 - transmit
/			1 - receive
/
/		      ubyte id - Compression Method
/			2 - 16 bit linear PCM
/			3 - A-Law
/			4 - æ-Law
/			17- GSM
/
/		      uword rate - Sampling rate
/			4800Hz
/			7200Hz
/			8000Hz
/			9600Hz
/			11000Hz
/
/           ubyte spk_vol - Used defined speaker volume
/        0 - Low volume
/		   1 - Low volume
/		   2 - Medium volume
/		   3 - High volume
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
******************************************************************************/
void dp_vce_compression_init(ubyte direction, ubyte id, uword rate, ubyte spk_vol)
{    	/* changed by ramn on 10/10/95 */
	ubyte ctls_sampling_rate_code;
	ubyte ctls_compression_scheme;
	ubyte	rec_playback;
	ubyte voice_mode_parameter;

	ubyte *temp;
#if 0	
	uword i;
	dce_tx_count = 0;  /* init needed for dce I/O */
	dce_tx_insert = 0;
	dce_rx_count = 0;
	dce_rx_insert =0;

	dce_rx_remove = 0; /* ramn 2/16/96 */
	dce_tx_remove = 0;

	for (i=0;i<DCE_BUFFER_SIZE;i++)
	{
		dce_rx_buffer[i] = 0xff;
	}

	for (i=0;i<DCE_BUFFER_SIZE;i++)
	{
		dte_tx_buffer[i] = 0xff;
	}
#endif

	dp_vce_to_clear();  /* ramn 2/27/96 */
	dp_vce_from_clear();



	ad3_count = 0;  /* ramn 2/13/96 */

/* need to implement the other modes i.e. 8 to 20 */
	if((vce_mode != RECEIVE_MODE) && (vce_mode != TRANSMIT_MODE)) /* ramn 2/21/96 */
		voice_mode_parameter = 0;
	else if((vce_mode == RECEIVE_MODE) && thru_phone)
		voice_mode_parameter =2;
	else if((vce_mode == TRANSMIT_MODE) && thru_phone)
		voice_mode_parameter = 3;

	else if((vce_mode == RECEIVE_MODE) && thru_line)
		voice_mode_parameter = 4;
	else if((vce_mode == TRANSMIT_MODE) &&thru_line)
		voice_mode_parameter = 5;

	else if((vce_mode == RECEIVE_MODE) && thru_mic)
		voice_mode_parameter = 6;
	else if((vce_mode == TRANSMIT_MODE) && thru_spkr)
		voice_mode_parameter = 7;

	LOAD_PACKET_MODEM_VCE_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

  	switch(rate)
	{
		case 4800:
			ctls_sampling_rate_code = 0;
		break;

		case 7200:
			ctls_sampling_rate_code = 1;
		break;
		
		case 8000:
			ctls_sampling_rate_code = 2;
		break;

		case 9600:
			ctls_sampling_rate_code = 3;
		break;
	
		case 11025:		/* was 11200 changed by ramn on 7/8/96 */
			ctls_sampling_rate_code = 4;
		break;

		default:
  			ctls_sampling_rate_code = 0; /* was 0 ramn 10/1/96 */
	}

	switch(id)
	{
		case SIGNED_PCM:
		/*case SIGNED_PCM_2: *//* ramn 2/19/96 */ /* 8 bit linear */
			ctls_compression_scheme = 2;
		break;

		case UNSIGNED_PCM:
		/*case UNSIGNED_PCM_2:*//* ramn 2/19/96 */	/* 16 bit linear */
			ctls_compression_scheme = 1;
		break;
	
		case AD4_PCM:
	  /*	case AD4_PCM_2: *//* ramn 2/19/96 */ 	/* AD4 */
			ctls_compression_scheme = 6;
		break;
	
		case CL1: 	/* CL1 */
			ctls_compression_scheme = 0;
		break;
		
		case AD3_PCM:	/* AD3 */

			/* 2/13/96 for ad3 ramn*/
			ad3_sampl_count = 8;
			ad3_long_wrd_1 = 0;
			ad3_long_wrd_2 = 0;
			ad3_dp_long_wrd = 0;
			dp_ad3_byte = 0;

			ctls_compression_scheme = 5;
		break;
	
		default: 	/* CL1 */
			ctls_compression_scheme = 0;		/* was 0 ramn 10/1/96 */
	}

	if(direction == VOICE_TRANSMIT)
		rec_playback = CTLS_PLAYBACK;
	else if(direction == VOICE_RECEIVE)
		rec_playback = CTLS_RECORD;
	else
		rec_playback = CTLS_IDLE;

/* the chk the notes in the print out of the RSA code */
	LOAD_PACKET_MODEM_VCE_REC_PLAYBACK_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	/* this will send the silence detection
		level and time period to the cutlass */																											
	if(vce_mode == RECEIVE_MODE)  /* ramn 3/11/96 */
	{
		LOAD_PACKET_MODEM_VCE_SET_PARAMS 	
		ack_or_response = FALSE;
		send_pkt_to_dsp();
	}
	
/*	state = spk_vol;
	LOAD_MODEM_SPEAKER
	ack_or_response = FALSE;
	send_pkt_to_dsp();
*/ /* ramn 2/27/96 */

	/* initialize all the msg delay timers to zero */
	/* ramn 2/21/96 */
	vce_dtmf_report_delay = 0;	
	vce_2100hz_msg_delay	= 0;
	vce_busy_msg_delay = 0;
	vce_1100hz_msg_delay = 0;
	vce_dialtone_msg_delay = 0;
	vce_1300hz_msg_delay	= 0;
	vce_2225hz_msg_delay = 0;


/* added by ramn on 7/18/96 
	on advise from wess
	the value 9c of bank0 has 100h and location 9d has value 166h
	wess wants these reduced by 30h each . hence the new values poked 
	are d0 and 136 respectively.

	this is supposed to help with the false detection of dtmf during playback

*/
#if 0
	current_command[0] = 0xd;		
	current_command[1] = 0x00;
	current_command[2] = 0x04;
	current_command[3] = 0x00;
	current_command[4] = 0x9c;
	current_command[5] = 0x0;
	current_command[6] = 0x0;
	current_command[7] = 0x0;
	current_command[11] = 0x00;

	/* need to do this because the poke commands donot send ack packet C0 */
	temp = (ubyte *)(COM_RAM); 
	*temp = 0x0c0;

	ack_or_response = 0;
	send_pkt_to_dsp();


	current_command[0] = 0xd;		
	current_command[1] = 0x00;
	current_command[2] = 0x04;
	current_command[3] = 0x00;
	current_command[4] = 0x9d;
	current_command[5] = 0x0;
	current_command[6] = 0xb3;
	current_command[7] = 0x0;
	current_command[11] = 0x00;

	/* need to do this because the poke commands donot send ack packet C0 */
	temp = (ubyte *)(COM_RAM); 
	*temp = 0x0c0;

	ack_or_response = 0;
	send_pkt_to_dsp();
#endif




}

/*******************************************************************************
/
/   Routine: set_voice_compression
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will set the selected compression method and
/		 sampling rate.  However, Rockwell currently only supports ADPCM.
/
/   Input Parameters: ubyte id - Compression Method
/			2 - 16 bit linear PCM
/			3 - A-Law
/			4 - æ-Law
/			17- GSM
/
/		      uword rate - Sampling rate
/			4800Hz
/			7200Hz
/			8000Hz
/			9600Hz
/			11000Hz
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users: dp_vce_init()
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0
void set_voice_compression(ubyte id, uword rate)
{     	/* changed by ramn on 10/10/95 */
	ubyte x1;
	uword x2;
	x1 = id;
	x2 = rate;
}
#endif /* ramn */

/*******************************************************************************
/
/   Routine: set_sampling_rate
/
/   Author: RSA
/
/   Creation Date: 10/21/92
/
/   Description: This routine will determine the numerator and denominator for
/		 the selected sampling rate and set the appropiate data pump
/		 registers.
/
/   Input Parameters: uword rate - Sampling rate
/			4800Hz
/			7200Hz
/			8000Hz
/			9600Hz
/			11000Hz
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users: set_voice_compression()
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0
void set_sampling_rate(uword rate)
{ /* changed by ramn on 10/10/95 */
	uword x1 = rate;
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_return_to_idle
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will force the data pump out of voice mode and
/                back into idle mode.
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_return_to_idle(void)
{ /* changed by ramn on 10/10/95 */
#if 0
	LOAD_PACKET_MODEM_VCE_RETURN_TO_IDLE
	ack_or_response = FALSE;
	send_pkt_to_dsp();
#endif
}
/*******************************************************************************
/
/   Routine: dp_vce_to_free
/
/   Author: RSA
/
/   Creation Date: 11/16/92
/
/   Description: This routine will return the number of free buffer spaces in
/                the transmit buffer
/
/   Input Parameters: None
/
/   Output Parameters: uword count - Number of free buffer locations.
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
/  Author & Date: RSA 6/5/1995.
/  Description: Removed the enable and disable voice int routine calls.
/  Reason: Masked off and on the bits in the DP to handle this task for
/          TPDM mode.
/
*******************************************************************************/
#if 0
uword dp_vce_to_free(void)
{ /* changed by ramn on 10/10/95 */
	uword count = 10;
	return(count);
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_to_char_buffer
/
/   Author: RSA
/
/   Creation Date: 11/16/92
/
/   Description: This routine will place the passed in character in to the
/                transmit buffer.
/
/   Input Parameters: ubyte ch - Character to be placed in to the transmit
/                                buffer.
/
/   Output Parameters: none
/
/   Global Variables Changed: dp_vce_tx_buffer, dp_vce_tx_count, dp_vce_tx_insert
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
/  Author & Date: RSA 6/5/1995.
/  Description: Removed the enable and disable voice int routine calls.
/  Reason: Masked off and on the bits in the DP to handle this task for
/          TPDM mode. Also only reenable the interrupt after transmission
/          has started (ie. the voice buffer was initially full.
/
*******************************************************************************/
#if 0
void dp_vce_to_char_buffer(ubyte ch)
{ /* changed by ramn on 10/10/95 */
	ubyte x1;
	x1 = ch;
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_start_tx
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will start the transmission of the voice data.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed: dp_vce_tx_busy
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
/  Author & Date: RSA 6/5/1995.
/  Description: Revamped the entire routine for the Temic platform.
/  Reason: We were having trouble with the voice configuration using the
/          current scheme after the voice buffer was filled up by the
/          background code.
/
*******************************************************************************/
#if 0 /* ramn 8/19/96 */
void dp_vce_start_tx(void)
{ /* changed by ramn on 10/10/95 */
/* this routine called from voice background when in voice translate mode
	we do not support this at the present time  i.e. AT+VXT */
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_to_num
/
/   Author: RSA
/
/   Creation Date: 11/16/92
/
/   Description: This routine will return the number of character in the
/                transmit buffer.
/
/   Input Parameters: None
/
/   Output Parameters: uword dp_vce_tx_count - Number of characters in buffer
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0
uword dp_vce_to_num(void)
{ /* changed by ramn on 10/10/95 */

	return(dp_vce_tx_count);
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_from_num
/
/   Author: RSA
/
/   Creation Date: 11/16/92
/
/   Description: This routine will return the number of characters in the receive
/                buffer.
/
/   Input Parameters: None
/
/   Output Parameters: uword dp_vce_rx_count - Number of receive characters
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0
uword dp_vce_from_num(void)
{
	return (dp_vce_rx_count);
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_from_char
/
/   Author: RSA
/
/   Creation Date: 11/16/92
/
/   Description: This routine will return a character from the receive buffer
/
/   Input Parameters: None
/
/   Output Parameters: ubyte ch - character from the receive buffer
/
/   Global Variables Changed: dp_vce_rx_buffer, dp_vce_rx_remove, dp_vce_rx_count
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
/  Author & Date: RSA 6/5/1995.
/  Description: Removed the enable and disable voice int routine calls.
/  Reason: Masked off and on the bits in the DP to handle this task for
/          TPDM mode.
/
*******************************************************************************/
#if 0
ubyte dp_vce_from_char(void)
{ /* changed by ramn on 10/10/95 */

	ubyte ch = 'A';
	return (ch);
}
#endif

/*******************************************************************************
/
/			    read_dp_vce_ram
/
/	Author: 	RSA 
/
/	Creation Date:	01/20/94
/
/	Description:	This routine will return the byte read at the given
/			DP RAM location
/
/	Input Parameters:	address
/
/	Output Parameter: ubyte read
/
/	Global Variables Changed: 
/
/	Users:
/
/	*****************************************************************
/	*			  Modifications
/	*****************************************************************
/
/       Author & Date: RSA 
/	Description:
/       Reason:
/
*******************************************************************************/
#if 0 /* ramn 8/19/96 */
ubyte read_dp_vce_ram(uword address)
{ /* changed by ramn on 10/10/95 */
	uword addr;
	ubyte ch = 'A';
	addr = address;	
	return (ch);

}
#endif

/*******************************************************************************
/
/			    write_dp_vce_ram
/
/	Author: 	RSA 
/
/	Creation Date:	01/20/94
/
/	Description:	This routine will write the given word to the given
/                 DP RAM location. (Rockwell method 3)
/
/	Input Parameters:	address
/				         word_to_write
/
/	Output Parameter:	None
/
/	Global Variables Changed: 
/
/	Users: 
/
/	*****************************************************************
/	*			  Modifications 			*
/	*****************************************************************
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0 /* ramn 8/19/96 */
void write_dp_vce_ram(uword address,uword word_to_write)
{ /* changed by ramn on 10/10/95 */
    uword x1 = address;
    uword x2 = word_to_write;
}
#endif
/*******************************************************************************
/
/			    write_byte_dp_vce_ram
/
/	Author: 	RSA 
/
/	Creation Date:	01/20/94
/
/	Description:	This routine will write the given byte to the given
/                 DP RAM location.  (Rockwell method 2)
/
/	Input Parameters:	address
/				         byte_to_write
/
/	Output Parameter:	None
/
/	Global Variables Changed: 
/
/	Users: 
/
/	*****************************************************************
/	*			  Modifications 			*
/	*****************************************************************
/
/	Author & Date:
/	Description:
/	Reason:
/
*******************************************************************************/
#if 0 /* ramn 8/19/96 */
void write_byte_dp_vce_ram(uword address,ubyte byte_to_write)
{  /* changed by ramn on 10/10/95 */

	uword hi_byte_a = address;
	ubyte lo_byte_a = byte_to_write;
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_int
/
/   Author: RSA 
/
/   Creation Date: 1/20/1994
/
/   Description: This routine will process the data pump interrupt. 
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:
/   Description:
/   Reason:
/
/
/  Author & Date: RSA 6/5/1995.
/  Description: Added code to turn on the TPDM bit.
/  Reason: Needed for the Temic platform.
/
/  Author & Date: RSA 6/5/1995.
/  Description: Removed the code to handle the underrun problem where
/               the interrupt filled the TBUFFER with an xFF.
/  Reason: We now disable the interrupt at this point and refill the
/          buffer.
/
*******************************************************************************/
#if 0
void dp_vce_int(void)
{	/* changed by ramn on 10/10/95 */
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_change_voice_params
/
/   Author: RSA 
/
/   Creation Date: 02/25/94
/
/   Description: This routine will change the voice parameters after the
/						first sample is sent or received.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0	/* ramn 8/19/96 */
void dp_vce_change_voice_params(void)
{/* changed by ramn on 10/10/95 */
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_phone_relay
/
/   Author: RSA 
/
/   Creation Date: 12/17/93
/
/   Description: This routine will set the local phone relay ON or OFF
/
/   Input Parameters: ubyte num: 1 = ON  0 = OFF
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0
void dp_vce_phone_relay(ubyte num)
{ /* changed by ramn on 10/10/95 */
	ubyte x1;
	x1 = num;
}
#endif	/* ramn 1/8/96*/

/*******************************************************************************
/
/   Routine: dp_vce_microphone
/
/   Author: RSA
/
/   Creation Date: 10/22/92
/
/   Description: This routine will set the internal and external
/                microphone relays to the selected value
/
/   Input Parameters: ubyte num - Selected setting
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_microphone(ubyte int_micr, ubyte ext_micr)
{ /* changed by ramn on 1/8/96 */
/* if either is on then set the flags to turn the micorphone on 
	in the voice_init packet */

	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	
	if (spkr_phn_mode == TRUE)		/* ramn 7/11/96 */
		afe_choice = AFE2;
	else
		afe_choice = AFE1;


	if(int_micr == ON)
	{
		first_low_byte = 0xdc;	/* turn mic on and leave spk setting as is */
		second_low_byte = 0x0c;

/* 
	the handling of recv gain when setting microphone on and off is changed
	The new boards give a 6db boost to the mic signal into AFE1. hence for
	normal voice record we reduce this by 6db. ie if afe1 then recv gain is 
	6db if afe2 recv gain is 12db. 

	ramn 9/18/96
*/

		first_high_byte = 0x3f;	 /* was 3f */ 
#if 0

		if (spkr_phn_mode != TRUE)		/* ramn 7/11/96 */
			second_high_byte = 0x01;  /* was 0, ramn 9/17/96 */
		else 
			second_high_byte = 0x02;
#endif
			second_high_byte = 0x02;  /* was 0, ramn 9/17/96 */

		thru_mic = TRUE;
	}
	else
	{
		first_low_byte = 0xd0; /* turn mic off and leave spk setting as is */
		second_low_byte = 0x00;

		first_high_byte = 0x3f;	  /* was 3f */	
		second_high_byte = 0x02;  /* was 0, ramn 9/17/96 */
		thru_mic = FALSE;
	}
	LOAD_PACKET_MODEM_VCE_PGC_INIT

	ack_or_response = FALSE;
	send_pkt_to_dsp();
}

/*******************************************************************************
/
/   Routine:  dp_vce_hook_relay
/
/   Author: RSA 
/
/   Creation Date: 1/20/1994
/
/   Description: This routine will set the hook relay based upon the parameter
/                passed in.
/
/   Input Parameters: ubyte state - State of the hook relay
/                       0 - On hook. Disconnect from line
/                       1 - Off hook. Connect to line
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0
void dp_vce_hook_relay(ubyte state)
{  /* changed by ramn on 10/10/95 */
	ubyte x1;
	x1 = state;

/* if state is on then go offhook
	if not stay onhook */
}
#endif /* this function is macroed to call modem_hook_relay in func_mac.h */

/*******************************************************************************
/
/   Routine: dp_vce_speaker
/
/   Author: RSA
/
/   Creation Date: 4/12/1993
/
/   Description: This routine will control the speaker based upon the parameter
/                passed in.
/
/   Input Parameters: ubyte state - State of the speaker
/                           0 - Speaker OFF
/                           1 - Speaker ON
/
/   Output Parameters: none
/
/   Global Variables Changed:  dp_vce_spk_vol_mirror
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
*******************************************************************************/
extern ubyte spkr_on;
void dp_vce_speaker(ubyte int_state, ubyte ext_state)
{ /* changed by ramn on 1/8/95 */


#if 0
/* use the dsp packet to control spk */
		dp_vce_set_speaker(int_state); 	/* ramn 3/1/96 */
		if(int_state)
			thru_spkr = TRUE;
		else
			thru_spkr = FALSE;
#endif



/* if int_state or ext_state is on turn the speaker on */

	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	
	if (spkr_phn_mode == TRUE)		/* ramn 7/11/96 */
		afe_choice = AFE2;
	else
		afe_choice = AFE1;

	if(int_state == ON)
	{
		first_low_byte = 0xdc;	/* spk vol = med,spk_on = both Tx and Rx
											recv_gain = unchanged */
		second_low_byte = 0x00;	/* ramn 2/22/96 */ /* should be 0 */

		first_high_byte = 0x03;		
		second_high_byte = 0x3a; /* was 38, ramn 9/17/96 */
		thru_spkr = TRUE;
	}
	else
	{
		first_low_byte = 0xdc; /* turn mic off and leave spk setting as is */
		second_low_byte = 0x00;

		first_high_byte = 0x33;		/* was 03 changed by ramn 8/12/96 */
		second_high_byte = 0x02;	/* was 0 , ramn 9/17/96 */
		thru_spkr = FALSE;
/* ramn 7/16/96 if spkr set in data mode turnoff the flag */
		if(spkr_on)
			spkr_on = FALSE; 

	}
	LOAD_PACKET_MODEM_VCE_PGC_INIT

	ack_or_response = FALSE;
	send_pkt_to_dsp();

}

/*******************************************************************************
/
/   Routine: dp_vce_headset
/
/   Author: RSA
/
/   Creation Date: 7/31/1995.
/
/   Description: This routine will control the headset based upon the parameter
/                passed in.
/
/   Input Parameters: ubyte state - State of the headset
/                           0 - Speaker OFF
/                           1 - Speaker ON
/
/   Output Parameters: none
/
/   Global Variables Changed:  
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
*******************************************************************************/
#if 0
void dp_vce_headset(ubyte state)
{ /* changed by ramn on 1/23/96 */
}
#endif

/*******************************************************************************
/
/   Routine: dp_set_speaker
/
/   Author: RSA 
/
/   Creation Date: 01/19/1994
/
/   Description: This routine will control the speaker based upon the parameter
/                passed in.
/
/   Input Parameters: uses variable dp_vce_spk_vol_mirror
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_set_speaker(ubyte afe_select, ubyte spkr_gain)
{ /* changed by ramn on 3/18/96 */

/* if int_state or ext_state is on turn the speaker on */

	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	
	afe_choice = afe_select;

	first_low_byte = 0xdc;	/* spk_on = both Tx and Rx,recv_gain = unchanged */
	second_low_byte = 0x00;	

	first_high_byte = 0x03;		
	if(spkr_gain == LOW)
		second_high_byte = 0x34;	
	else if(spkr_gain == MEDIUM)
		second_high_byte = 0x38; /* 38*/
	else if (spkr_gain == HIGH)
		second_high_byte = 0x3c;		
	
	thru_spkr = TRUE;

	LOAD_PACKET_MODEM_VCE_PGC_INIT

	ack_or_response = FALSE;
	send_pkt_to_dsp();

}

/*******************************************************************************
/
/   Routine: dp_vce_timer
/
/   Author: RSA
/
/   Creation Date: 10/7/92
/
/   Description: This routine is called every 10 msecs to process the codec
/                timers
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
/  Author & Date: RSA 6/7/1995.
/  Description: Fix for the 2225hz Bell Answer Tone reporting.
/  Reason: Was not an option in previous versions.
/
*******************************************************************************/
#if 0 	/* ramn 8/19/96 */
void dp_vce_timer(void)
{ /* changed by ramn on 10/10/95 */
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_set_data_direction
/
/   Author: RSA 
/
/   Creation Date: 01/19/94
/
/   Description: This routine is called to initialize the DSP
/                to the transmit or recieve direction (mode).
/
/   Input Parameters: ubyte direction
/
/   Output Parameters: none
/
/   Global Variables Changed:  ubyte dp_vce_data_direction
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/       Author & Date: 
/       Description:
/       Reason:
/
/  Author & Date: RSA 6/9/1995.
/  Description: Added the setting of the scde bit in the DSP.
/  Reason: Needed for proper silence detection and deletion.
/
*******************************************************************************/
#if 0 	/* ramn 8/19/96 */
void dp_vce_set_data_direction(ubyte direction)
{ /* changed by ramn on 10/10/95 */
	ubyte x1;
	x1 = direction;
/* this routine is called from voice background. It is called from 
 voice receive and from voice translate */
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_translate_voice
/
/   Author: RSA
/
/   Creation Date: 12/8/1993.
/
/   Description: This procedure does nothing
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:
/   Description: 
/   Reason: 
/
*******************************************************************************/
#if 0  /* ramn 8/19/96 */
void dp_vce_translate_voice(ubyte direction, ubyte bps)
{ /* changed by ramn on 10/10/95 */
	direction = bps;
/* we do not implement this function at the present time */
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_dte_cts
/
/   Author: RSA (drc)
/
/   Creation Date: 01/19/94
/
/   Description: This routine will either turn ON or OFF the DTE CTS bit
/
/   Input Parameters: ubyte state - Setting of CTS
/                       0 - Turn CTS OFF
/                       1 - Turn CTS ON
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0  /* ramn 8/19/96 */
void dp_vce_dte_cts(ubyte state)
{ /* changed by ramn on 10/10/95 */
	ubyte x1;
	x1 = state;
}
#endif 

/*******************************************************************************
/
/   Routine: dp_vce_init_speaker_vol
/
/   Author: RSA 
/
/   Creation Date: 02/24/94
/
/   Description: This routine will set the speaker volume mirror bits
/
/   Input Parameters: spk_vol
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:  vce_configure
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0 /* ramn 8/19/96 */
void dp_vce_init_speaker_vol(ubyte spk_vol)
{ /* changed by ramn on 10/10/95 */
	ubyte x1;
	x1 = spk_vol;
}
#endif

/*******************************************************************************
/
/   Routine: dp_vce_pause
/
/   Author: RSA 
/
/   Creation Date: 06/07/95
/
/   Description: This routine will pause and resume the voice data
/
/   Input Parameters: ubyte pause
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:  vce_configure
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/   Author & Date:	RSA
/   Description:
/   Reason:
/
*******************************************************************************/
#if 0 /* ramn 8/19/96 */
/* Start Change 6/8/1995. */
void dp_vce_pause(ubyte pause)
{  /* changed by ramn on 10/10/95 */
	ubyte x1;
	x1 = pause;
}
#endif

#if0
/****************************************************************************/
* added by ramn on 1/24/96
* this routine will check the status of thelocal phone and send the status 
* to dte as required
*
/****************************************************************************/
#endif


void vce_local_phn_hook_status(void) /* ramn 1/24/96*/
{
	ubyte pair;

	if(dp_vce_local_phone_on_hook())
		{
			/* this is reuired by ms-phone if on hook when entering voice mode
				report it. ramn 8/15/96 */
/* first_time commented out by ramn 9/4/96 */
		if((dle_H_sent) /*|| (first_time == TRUE)*/ ) 
		{
			if(relay_on_hook_flag == FALSE)
			{
				debounce_timer = DEBOUNCE_TIME;
				relay_on_hook_flag = TRUE;
				relay_off_hook_flag = FALSE;
			}			
			else if((relay_on_hook_flag == TRUE) && (!debounce_timer))
			{
				dle_h_sent = TRUE;
				dle_H_sent = FALSE;
				first_time = FALSE;
				phn_status = 0;
				relay_on_hook_flag = FALSE; /* ramn 2/25/96 */
				pair = 'h';
				send_dle(pair);
			}
		}
		else
		{
			if(debounce_timer)
				debounce_timer = DEBOUNCE_TIME;
		}
	}
	else 
	{
		if(!dle_H_sent)
		{
			if(relay_off_hook_flag == FALSE)
			{
				debounce_timer = DEBOUNCE_TIME;
				relay_off_hook_flag = TRUE;
				relay_on_hook_flag = FALSE;
			}
			else if((relay_off_hook_flag == TRUE) && (!debounce_timer))
			{
				dle_h_sent = FALSE;
				dle_H_sent = TRUE;
				first_time = FALSE;
				phn_status = 0;
				relay_off_hook_flag = FALSE; 
				pair = 'H';
				send_dle(pair);

/*
	if someone picks up the handset then let home talkon the line by hanging
	up the voice and hook relays. this needs to be done only in modes given 
	below. visshy agrees with this scheme.

	ramn 9/18/96 
*/
				if((vls_cmd_value == 1) || (vls_cmd_value == 5) ||
					(vls_cmd_value == 7) || (vls_cmd_value == 17))
				{
					if(conv_rec_going_on == TRUE)
						exit_conv_rec_vls17();

 	           	execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,OFF,OFF,OFF,OFF); /* +vls=0 */
					vls_cmd_value = 0;

 				   /*dp_vce_phone_relay(OFF);
				   dp_vce_hook_relay(OFF);*/
				}

			}
		}
		else
		{
			if(debounce_timer)
				debounce_timer = DEBOUNCE_TIME;
		}
	}


#if 0
	ubyte pair;

	if(dp_vce_local_phone_on_hook())
	{
		if((!first_time) && (!local_phn_on_hook_status_sent))
		{
			if(relay_on_hook_flag == FALSE)
			{
				debounce_timer = DEBOUNCE_TIME;
				relay_on_hook_flag = TRUE;
				relay_off_hook_flag = FALSE;
			}			
			else if((relay_on_hook_flag == TRUE) && (!debounce_timer))
			{
				local_phn_on_hook_status_sent = TRUE;
				local_phn_off_hook_status_sent = FALSE;
				first_time = FALSE;
				phn_status = 0;
				relay_on_hook_flag = FALSE; /* ramn 2/25/96 */
				pair = 'h';
				send_dle(pair);
			}
		}
	}
	else 
	{
		if(!local_phn_off_hook_status_sent)
		{
			if(relay_off_hook_flag == FALSE)
			{
				debounce_timer = DEBOUNCE_TIME;
				relay_off_hook_flag = TRUE;
				relay_on_hook_flag = FALSE;
			}
			else if((relay_off_hook_flag == TRUE) && (!debounce_timer))
			{
				local_phn_on_hook_status_sent = FALSE;
				local_phn_off_hook_status_sent = TRUE;
				first_time = FALSE;
				phn_status = 0;
				relay_off_hook_flag = FALSE; 
				pair = 'H';
				send_dle(pair);
			}
		}	
	}
#endif
}





#if 0
void vce_local_phn_hook_status(void) /* ramn 1/24/96*/
{
	ubyte pair;

	if(dp_vce_local_phone_on_hook())
	{
		if((!first_time) && (!local_phn_on_hook_status_sent))
		{
			if(relay_on_hook_flag == FALSE)
			{
				debounce_timer = DEBOUNCE_TIME;
				relay_on_hook_flag = TRUE;
				relay_off_hook_flag = FALSE;
			}			
			else if((relay_on_hook_flag == TRUE) && (!debounce_timer))
			{
				local_phn_on_hook_status_sent = TRUE;
				local_phn_off_hook_status_sent = FALSE;
				first_time = FALSE;
				phn_status = 0;
				relay_on_hook_flag = FALSE; /* ramn 2/25/96 */
				pair = 'h';
				send_dle(pair);
			}
		}
	}
	else 
	{
		if(!local_phn_off_hook_status_sent)
		{
			if(relay_off_hook_flag == FALSE)
			{
				debounce_timer = DEBOUNCE_TIME;
				relay_off_hook_flag = TRUE;
				relay_on_hook_flag = FALSE;
			}
			else if((relay_off_hook_flag == TRUE) && (!debounce_timer))
			{
				local_phn_on_hook_status_sent = FALSE;
				local_phn_off_hook_status_sent = TRUE;
				first_time = FALSE;
				phn_status = 0;
				relay_off_hook_flag = FALSE; 
				pair = 'H';
				send_dle(pair);
			}
		}	
	}
}
#endif

void send_dle(ubyte value)
{
	  ubyte *info_ptr;

		/* If currently sending or receiving data then place the call progress
     information into the voice DTE buffers. Else the info goes back 
     through the ACU */
	  if (vce_mode == TRANSMIT_MODE || vce_mode == RECEIVE_MODE)
	  {
   	   while (voice_dte_to_free() < 2)
      	    ;
			voice_dte_to_char(DLE);
			voice_dte_to_char(value);
	  }
	  else
	  {
	      vce_array[0] = DLE;
   		vce_array[1] = value;
         vce_array[2] = '\0';

			/* ramn 7/11/96 */
			info_ptr = (ubyte *)&vce_array[0];
			output_info(info_ptr,UNFORMATTED); 
			vce_array[0] = '\0';
     }
}



/*************************************************************************
*
* 		by ramn 2/23/96
*
*		will enter tele emulation mode or exit depending on para passed
*
**************************************************************************/

void tele_emul_enable(ubyte tele_emul_state) /* ramn 2/23/96 */
{
	ubyte voice_mode_parameter;

	if(tele_emul_state == ON)
	{
		
		if(tele_emul_value == TRUE) /* ramn 3/20/96 */
		{
			if(thru_mic) 	/* moved here by ramn 7/18/96 */
		     	dp_vce_set_level(VOICE_TRANSMIT,spk_phn_mic_level); /* ramn 2/29/96 */
			if(thru_spkr)
				dp_set_speaker(AFE1,tele_emul_spk_level);

			voice_mode_parameter = 9;
			LOAD_PACKET_MODEM_VCE_INIT
			ack_or_response = FALSE;
			send_pkt_to_dsp();
		}
		else if(spkr_phn_mode == TRUE) /* ramn 3/20/96 */
		{
/*
			dp_vce_microphone(ON,OFF);
			dp_set_speaker(AFE1,tele_emul_spk_level);

			voice_mode_parameter = 20;
			LOAD_PACKET_MODEM_VCE_INIT
			ack_or_response = FALSE;
			send_pkt_to_dsp();
*/
			enable_spkr_phone();
		}
	}
	else
	{
		if(spkr_phn_mode == TRUE) /* ramn 5/13/96 */
		{
			end_spkr_phn_mode();
		}
		else
		{			
   		dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                              vce_sampling_rate,vce_speaker_vol);
		}
	}
}



/****************************************************************************
*
*		these routines are for speaker phone
*
*				for dnld spkr phn code, exit spkr phn mode, 
*				and init spkr phn after dnld
*
*
*
****************************************************************************/


/* this routine will take the code out of spkr phn mode */
/* ramn 3/19/96 */
void end_spkr_phn_mode(void) /* ramn 3/19/96 */
{

	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	ubyte ctls_sampling_rate_code,ctls_compression_scheme,rec_playback,ch;
	


	LOAD_PACKET_MODEM_VCE_RETURN_TO_IDLE
	ack_or_response = FALSE;
	send_pkt_to_dsp();

  	ctls_sampling_rate_code = 0;
	ctls_compression_scheme = 0;
	rec_playback = CTLS_IDLE;
	LOAD_PACKET_MODEM_VCE_REC_PLAYBACK_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	afe_choice = AFE1;	  			/* configure AFE1 for spkr phn mode */
	first_low_byte = 0x0;
	first_high_byte = 0x0;		
	second_low_byte = 0x00;
	second_high_byte = 0x32; 		/* was 3a, we now mute the spkr when exiting
												spkr phn mode , ramn 9/22/96 */
	LOAD_PACKET_MODEM_VCE_PGC_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();


	afe_choice = AFE2;				/* configure AFE2 for spkr phn mode */
	first_low_byte = 0x0;
	first_high_byte = 0x0;		
	second_low_byte = 0x00;
	second_high_byte = 0x0;
	LOAD_PACKET_MODEM_VCE_PGC_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	executing_spkr_phn = FALSE;	/* ramn 7/18/96 */

	if(!patch_re_dnlded)		/* ramn 9/10/96 */
	{
		dsp_cp_packet = 0xC4;          
		ch = dsp_cp();

		LOAD_MODEM_INIT
		ack_or_response = ACK;
		send_pkt_to_dsp();

		dnld_spkr_phn_code(pwr_on_patch);	
		set_7_wait_states();		/* this sets 7 wait states for musket-cp interf*/

    	dnld_patch();   /* why parameter list is empty? */
    /* dsppatch(COMMON_PATCH) loads common_patch[], training_patch[] and
       do Cam Jam
    */
      /*dsppatch(COMMON_PATCH);*/  /* jlin, for dynamic patch 10/31/96 */

      voice_dnld_patch(vcepatch);

		LOAD_MODEM_INIT
		ack_or_response = ACK;
		send_pkt_to_dsp();
	
		dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                           vce_sampling_rate,vce_speaker_vol);
		patch_re_dnlded = TRUE;
	  
		spkr_phn_mode = FALSE; 

		if((vls_cmd_value == 6) || (vls_cmd_value == 7))
			dp_vce_microphone(ON,ON);

		if((vls_cmd_value == 4) || (vls_cmd_value == 5) || (vls_cmd_value == 7))
		{
	   	dp_vce_speaker(OFF,OFF);
		  	wait_a_while();
	   	dp_vce_speaker(ON,ON);
		  	wait_a_while();
		}
		spkr_phn_mode = TRUE; /* ramn 3/20/96 */

	}
}

extern ubyte dsp_sleep;

void dnld_spkr_phn_code(uword *spk_phn_array)	/* ramn 4/22/96 */
{
	ubyte *temp;
	uword error= 0;
	uword temp1,temp2,i,length;

	/* needed for mcon and Bcon poke */
	uword add,data_byte;
	ubyte mcon_lo, mcon_hi, pram_addr_lo, pram_addr_hi;



	dsp_cfg(ON);	/* set dsp_reset and dsp_cfg to 1 */	
	dsp_reset(ON);

	dial_timer = 250; 	/* was 250 ms */
	while(dial_timer)
	{
		process_wait();
	}		


/*	vce_b_to_a_resp(dsp_sleep);
	 output_info(vce_array,VERBOSE_FORM);
*/	

	dsp_reset(OFF);	/* release the reset */

/* dnld the reset vector */
	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
	temp1 = INTERNAL_RST_VECTOR;		
	wait_a_while();
	*temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
	temp1 = INTERNAL_RST_VECTOR;		
	wait_a_while();
	*temp = (ubyte)temp1;		/* write the low addr in the reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);
	wait_a_while();
  	*temp = spk_phn_array[2];
	temp1 = spk_phn_array[2];
	wait_a_while();
	*temp = temp1 >> 8;

/* dnld rest of code */
	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
	temp1 = spk_phn_array[2];		/* start addr of the spk phn code in temp1 */
	wait_a_while();
	*temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
	wait_a_while();
	*temp = (ubyte)spk_phn_array[2];		/* write the low addr in the reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);

	length = (spk_phn_array[1]-1);
	temp1 = 0;

	for(i=0; i<= length; i++)
	{
		temp1 = spk_phn_array[i+3];
		wait_a_while();
		*temp = (ubyte)temp1;				  /* write low byte then high byte */
		wait_a_while();
		*temp = (ubyte)(temp1 >> 8) & 0xFF;
	}

/* dnld done now verify */
	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
	wait_a_while();
	*temp = (ubyte)spk_phn_array[2];		/* write the low addr in the reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
	temp1 = spk_phn_array[2];		/* start addr of the spk phn code in temp1 */
	wait_a_while();
	*temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);

	temp2 = 0;
	temp1 = 0;
	
	error = 0;
	for(i=0; i<= length; i++)
	{
		wait_a_while();
		temp1 = *temp;
		temp2 = temp1;
		wait_a_while();
		temp1 = *temp;
		temp2 = temp2 | (temp1 << 8);

		if(temp2 != spk_phn_array[i+3])
		{
			error++;
			break;
		}
		temp2=0;
	}

#if 0 	/* ramn 6/25/96, do not need to show msgs for production code */
	if(error != 0)
	{
		if(spkr_phn_dnl)
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)ERR_MSG,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
		else
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)ERR_MSG4,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
 /* ramn 6/12/96 we do not need to show these for power on patch*/
	}
	else
	{
		if(spkr_phn_dnl)
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)OK_MSG1,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
		else
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)OK_MSG4,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
 /* ramn 6/12/96 we do not need to show these for power on patch*/		
	}
#endif

	error = 0;

/* now verify the reset vector */
	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
	temp1 = INTERNAL_RST_VECTOR;		
	wait_a_while();
	*temp = (ubyte)temp1;		/* write the low addr in the reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
	temp1 = INTERNAL_RST_VECTOR;		
	wait_a_while();
	*temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

	temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);
	
	temp2 = 0;
	temp1 = 0;
	wait_a_while();
	temp1 = *temp;
	temp2 = temp1;
	wait_a_while();
	temp1 = *temp;
	temp2 = temp2 | (temp1 << 8);

	temp1 = spk_phn_array[2];
	if(temp2 != temp1)
		error = 0xffff;

#if DSP_CODE_INTERNAL == 0
  	if(spkr_phn_dnl)
		dsp_cfg(OFF);		/* set dsp_cfg to off before soft reset of dsp */
#endif

	dial_timer = 100; 		/*was 100 ms */
	while(dial_timer)
	{
		process_wait();
	}		

#if 0	/* ramn 6/25/96, do not need to show msgs for production code */
	if(error != 0)
	{
		if(spkr_phn_dnl)
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)ERR_MSG2,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
		else
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)ERR_MSG3,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
 /* ramn 6/12/96 we do not need to show these for power on patch*/
	}
	else
	{
		if(spkr_phn_dnl)
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)OK_MSG2,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
		else
		{
			temp = (ubyte *)&vce_array[0];
   		vce_store_string_null((ubyte *)OK_MSG3,temp);
	   	output_info(temp,VERBOSE_FORM);   
		}
/* ramn 6/12/96 we do not need to show these for power on patch*/
	}
#endif

	temp = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);
	wait_a_while();
	*temp = 0x08;		/* release dsp reset and exec from int p-ram */

	dial_timer = 150; 	/* was 150 */
	while(dial_timer)
	{
		process_wait();
	}		


	temp = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);
	wait_a_while();
	*temp = 0x09;		/* release dsp reset and exec from int p-ram */

	dial_timer = 50; 	 /* was 50 */
	while(dial_timer)
	{
		process_wait();
	}		

/*
	if this is to put dsp to stop return without doing the pokes
	ramn 7/29/96 
*/
	if(spkr_phn_dnl == 2)	
		return;

/***********
 	added by ramn on 6/13/96
	these pokes were moved here beacuase they are needed after the spkr phn
	code is downloaded also.
	remember this routine is used to download both the speaker phone code 
	and teh poweron patch

************/
/* 
	poke MCON (hex addr 13) if in ROM environment 

	HOwever we poke the shadow location on int PRAM the dsp code
	copies this shadow location to the MCON. the shadow location
	is different for C6 and J5
*/

#if DSP_CODE_INTERNAL == 1
#if CUTLASS_C6 == 1
			add = 0x17e3;
#endif

#if CUTLASS_J5 == 1
			add = 0x17e4;
#endif
			dsp_poke(0x7c00,add); /* poke mcon shadow register */		
			if(spkr_phn_dnl)
			{
				dsp_poke(0x0025,0x03fb); /* poke freq_sel also */
				dsp_poke(0x0000,0x0010); /* poke wcon also */
				dsp_poke(0x7c20,0x0013); /* poke mcon directly as well */
			}

#endif /* endif for dsp_code_internal */

/* 
	peek BCON onlyif running external code 
	turn bit 15 to 0 to enable the second AFE
*/
#if DSP_CODE_INTERNAL == 0
/*			mcon_lo = 0;
			mcon_hi = 0;
			pram_addr_lo = 0x11;	
			pram_addr_hi = 0;
		
		 	LOAD_DSP_PROGRAM_MEMORY_READ

			dsp_cp_packet = PACKET_PROGRAM_MEM_READBACK;
		   ack_or_response = RESPONSE;
   		send_pkt_to_dsp();

			data_byte = (dsp_response_data[6] << 8);
			data_byte |= dsp_response_data[7];

			data_byte = (data_byte | 8000); 
*/
			dsp_poke(0x0007,0x0011);
#endif

/* 
	turn on bit 15 of BCON, so that second codec interface mapped to second
 	channel 
*/

#if DSP_CODE_INTERNAL == 1
	dsp_poke(0x0000,0x0011);
#endif
			

			dsp_poke(0x0000,0x0059);	/* ramn on 5/31/96 */
			dsp_poke(0x0000,0x005a);	/* poke the value of codec 2 data */
			dsp_poke(0x0002,0x005b);
			dsp_poke(0x0000,0x005c);
}

void wait_a_while(void)
{
	ubyte j;

	for(j=0;j<=wait_time;j++)
		;
}

/* 
	these next two functions added by ramn on 7/18/96
	these functions are for control of volume in spkr phone mode
	one is for speaker control and the other is for mic control

	the byte that need to be changed is lower byte of word 0b in the data ram 
	bank1.

	the upper nibble of this byte is for control of mic voleume and the lower
	nibble is for spkr vol control
*/

void enable_spkr_phone(void)
{
	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	ubyte voice_mode_parameter;
	ubyte *temp;


/* ramn 9/12/96 */
	if(patch_re_dnlded)		/* ramn 9/10/96 */
	{
		spkr_phn_dnl = 1;	
		dnld_spkr_phn_code(dsp_code); 	
		patch_re_dnlded = FALSE;	
	}
	
	if((patch_re_dnlded == FALSE) && (executing_spkr_phn == TRUE))
		return;

	afe_choice = AFE1;	  			/* configure AFE1 for spkr phn mode */
	first_low_byte = 0x0;
	first_high_byte = 0x0;		
	second_low_byte = 0x00;
/* gain from remote line */
	second_high_byte = 0x12; /* was 12 changed on 7/9/96 */
	LOAD_PACKET_MODEM_VCE_PGC_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	afe_choice = AFE2;				/* configure AFE2 for spkr phn mode */
	first_low_byte = 0x0;
	first_high_byte = 0x0;		
	second_low_byte = 0x0c;
/* gain of mic to remote end */
	second_high_byte = 0x1e; /* was 1c changed on 7/9/96 */
	LOAD_PACKET_MODEM_VCE_PGC_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	voice_mode_parameter = SPKR_PHN_MODE;
	LOAD_PACKET_MODEM_VCE_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	set_spkr_phn_mic_vol();		/* ramn 7/18/96 */
 	set_spkr_phn_spkr_vol();
	executing_spkr_phn = TRUE;
}

void 	set_spkr_phn_spkr_vol(void)
{
	ubyte num;	
	ubyte dram_bank1_addr_lo;
   ubyte	dram_bank1_addr_hi;
	ubyte dram_bank1_data_lo;
	ubyte dram_bank1_data_hi;
	ubyte peek_value;
	ubyte *temp; 

	/* adjust for values outside the range 121 to 131 */
	if(vgs_comm_value <= 121)
		vgs_comm_value = 122;
	else if(vgs_comm_value >= 131)
		vgs_comm_value = 131;

	/* for dsp if vol = 131 then send 0 ; if vol 122 or lower send 9 */
	num = 131 - vgs_comm_value;		

	if(spk_phn_mic_level == 121)
		spk_phn_mic_level = 122;

	peek_value = num;
	num = (131 - spk_phn_mic_level);
	peek_value = (peek_value | (num << 4));


#if 0
	/* first peek the last byte because the higher nibble is for mic vol */
	dram_bank1_addr_lo = 0x00;
	dram_bank1_addr_hi = 0x0b;

	LOAD_DATA_MEM_READ_BANK1			

	dsp_cp_packet = 0x15 ;  /*PACKET_DATA_MEM_READBACK*/
	ack_or_response = RESPONSE;
	send_pkt_to_dsp();
 
	/* or the current vol with the lower nibble */
	peek_value = dsp_response_data[6];
	peek_value = (peek_value & 0xf0);
	peek_value = (peek_value | num);
		
	/* now poke the volume byte in */
	dram_bank1_addr_lo = 0x00;
	dram_bank1_addr_hi = 0x0b;
	dram_bank1_data_lo = 0x00;
	dram_bank1_data_hi = peek_value;

	LOAD_DATA_MEM_WRITE_BANK1
#endif  

	current_command[0] = 0xe;		/* speaker phone control packet */
	current_command[1] = 0x00;
	current_command[2] = 0x04;
	current_command[3] = 0x00;

#if 0
	current_command[4] = 0x6c;  /* was 0x0b, changed ramn 9/12/96 */
	current_command[5] = 0x04;	 /* was 0x00, changed ramn 9/12/96 */
#endif

/*mrm11797*/
/*new address for digital gain*/
	current_command[4] = 0x04;  
	current_command[5] = 0x07;	 

	current_command[6] = 0x0;
	current_command[7] = peek_value;
	current_command[11] = 0x00;

	/* need to do this because the poke commands donot send ack packet C0 */
	temp = (ubyte *)(COM_RAM); 
	*temp = 0x0c0;

	ack_or_response = 0;
	send_pkt_to_dsp();
}



void set_spkr_phn_mic_vol(void)
{
	ubyte num;	
	ubyte dram_bank1_addr_lo;
   ubyte	dram_bank1_addr_hi;
	ubyte dram_bank1_data_lo;
	ubyte dram_bank1_data_hi;
	ubyte peek_value;
	ubyte *temp; 

	/* adjust for values outside the range 121 to 131 */
	if(vgs_comm_value <= 121)
		vgs_comm_value = 122;
	else if(vgs_comm_value >= 131)
		vgs_comm_value = 131;

	/* for dsp if vol = 131 then send 0 ; if vol 122 or lower send 9 */
	num = 131 - vgs_comm_value;		

	if(spk_phn_mic_level == 121)
		spk_phn_mic_level = 122;

	peek_value = num;
	num = (131 - spk_phn_mic_level);
	peek_value = (peek_value | (num << 4));

#if 0
	/* first peek the last byte because the higher nibble is for mic vol */
	dram_bank1_addr_lo = 0x00;
	dram_bank1_addr_hi = 0x0b;

	LOAD_DATA_MEM_READ_BANK1			

	dsp_cp_packet = 0x15;      /*PACKET_DATA_MEM_READBACK*/
	ack_or_response = RESPONSE;
	send_pkt_to_dsp();
 
	/* or the current vol with the lower nibble */
	peek_value = dsp_response_data[6];
	peek_value = (peek_value & 0x0f);
	peek_value = (peek_value | (num <<4));
					
	/* now poke the volume byte in */
	dram_bank1_addr_lo = 0x00;
	dram_bank1_addr_hi = 0x0b;
	dram_bank1_data_lo = 0x00;
	dram_bank1_data_hi = peek_value;

	LOAD_DATA_MEM_WRITE_BANK1
#endif

	current_command[0] = 0xe;		/* speaker phone control packet */
	current_command[1] = 0x00;
	current_command[2] = 0x04;
	current_command[3] = 0x00;

#if 0
	current_command[4] = 0x6c;  /* was 0x0b, changed ramn 9/12/96 */
	current_command[5] = 0x04;	 /* was 0x00, changed ramn 9/12/96 */
#endif

/*mrm11797*/
/*new address for digital gain*/

	current_command[4] = 0x04;  /* was 0x0b, changed ramn 9/12/96 */
	current_command[5] = 0x07;	 /* was 0x00, changed ramn 9/12/96 */

	current_command[6] = 0x0;
	current_command[7] = peek_value;
	current_command[11] = 0x00;

	/* need to do this because the poke commands donot send ack packet C0 */
	temp = (ubyte *)(COM_RAM); 
	*temp = 0x0c0;

	ack_or_response = 0;
	send_pkt_to_dsp();
}
	

/**********************************************************************
*
*	The following two routines were added by ramn so as to do conversation
*  record on the date plam board. The command to enter conversation record
*	is +VLS=17. THis command is valid only on the DATE-PALM board and also
*	only in speaker phone mode.
*
*	Conversation reocrd only works with the COM-Central software given by 
*	Packard Bell.
*
*	the algorithm for this is given by vishy canadam, as required by packard 
*	bell. 
*
*	ramn 9/16/96
*
*
*************************************************************************/


ubyte conv_rec_vls17(void)
{
	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	
	if((vls_cmd_value != 0) && (spkr_phn_mode != TRUE))
		return(TERMINATE_WITH_ERROR);
		
	conv_rec_going_on	= TRUE;
	
	afe_choice = AFE1;
	first_low_byte = 0xdc;	/* spk vol = med,spk_on = Tx */
	second_low_byte = 0x00;	/* ramn 2/22/96 */ /* should be 0 */

	first_high_byte = 0x03;		
	
	if(!hook)
	{
		second_high_byte = 0x1a; /* turn only tx on */
	}
	else if(!dp_vce_local_phone_on_hook())
	{
	   set_callerid_relay(CID_RELAY_ON);	
		
		second_high_byte = 0x2a; /* turn only rx on*/
	}
	else
   	return(TERMINATE_WITH_ERROR);

   set_gpio_bit ((uword *) GPR_TNKL, GPIO_BIT_TNKL, ACTIVATE);

	LOAD_PACKET_MODEM_VCE_PGC_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();

	return(GOTO_ONLINE_COMMAND);
}


void exit_conv_rec_vls17(void)
{
	ubyte afe_choice,first_low_byte,first_high_byte;
	ubyte second_low_byte,second_high_byte;
	
/*	if(!dp_vce_local_phone_on_hook())
	{
*/
	   set_callerid_relay(CID_RELAY_OFF);	
		
      set_gpio_bit ((uword *) GPR_TNKL, GPIO_BIT_TNKL, DEACTIVATE);
/*	}
*/
	afe_choice = AFE1;
	first_low_byte = 0xdc;	/* spk vol = med,spk_on = Tx */
	second_low_byte = 0x00;	/* ramn 2/22/96 */ /* should be 0 */

	first_high_byte = 0x03;		

/*
	when restoring the afe values chk if we are still in spkr phn mode
	if yes then resotre the corrct afe1 value 
	ramn 9/17/96
*/

	if(executing_spkr_phn == TRUE)
		second_high_byte = 0x12; 
	else
		second_high_byte = 0x3a; /* turn only rx on*/

	LOAD_PACKET_MODEM_VCE_PGC_INIT
	ack_or_response = FALSE;
	send_pkt_to_dsp();
	
	conv_rec_going_on	= FALSE;
}



/*
	this routine will exit the spkr phn mode and also will set the spkr
	setting in tune with the vls command. 
	this rouitne is used when we send dtmf tones in spkr phn mode, when
	we go to record or playback mode directly from spkr mode

	ramn 10/1/96
*/

void after_exit_spkrphn_init_for_voice(void)
{
	end_spkr_phn_mode();		

	if(vls_cmd_value == 17)			/* ramn 9/26/96 */
		exit_conv_rec_vls17();

	if((vls_cmd_value == 4) || (vls_cmd_value == 5) || (vls_cmd_value == 7) ||
		(vls_cmd_value == 17))
	{
		spkr_phn_mode = FALSE; 
		/*dp_vce_speaker(OFF,OFF);
	  	wait_a_while();*/
		dp_vce_speaker(ON,ON);
	  	/*wait_a_while();*/
		spkr_phn_mode = TRUE; /* ramn 9/24/96 */
	}
}




/*
	this function is called when we wake up from sleep and we are in voice
	mode .

	we need to dnld the correct patch in this case

	ramn 12/3/96 
*/
void	wakeup_from_sleep_in_voice(void)	/* ramn 12/3/96 */
{

	if(spkr_phn_mode)		/* ramn 9/10/96 */
	{
		spkr_phn_dnl = 1;	
		dnld_spkr_phn_code(dsp_code); 	
		patch_re_dnlded = FALSE;	
	}
	else
	{
      voice_dnld_patch(vcepatch);

		LOAD_MODEM_INIT
		ack_or_response = ACK;
		send_pkt_to_dsp();
	
		dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                           vce_sampling_rate,vce_speaker_vol);
		patch_re_dnlded = TRUE;
	  
		if((vls_cmd_value == 6) || (vls_cmd_value == 7))
			dp_vce_microphone(ON,ON);

		if((vls_cmd_value == 4) || (vls_cmd_value == 5) || (vls_cmd_value == 7))
		{
	   	dp_vce_speaker(OFF,OFF);
		  	wait_a_while();
	   	dp_vce_speaker(ON,ON);
		  	wait_a_while();
		}
	}
	



}





/************* till here ramn ***************************************/


#if 0
/*
	commented out by ramn 11/19/96
	ROB MILLER if yo want to move this here let me know the reason why
	DO NOT CHANGE THIS WITHOUT INFORMING US
*/

/* RJM111296 */
/* Dynamic Download support */

/* Moved from the old io\dsppatch.c file */
void dsp_poke(uword data, uword addr)
{
	ubyte mcon = 0;
	ubyte *temp;

	current_command [0] = PACKET_DSP_PROGRAM_MEMORY_WRITE;
	current_command [1] = 0x00;
   current_command [2] = PACKET_DSP_PROGRAM_MEMORY_WRITE_LEN;
   current_command [3] = 0x00;
   current_command [4] = addr;
   current_command [5] = addr>>8;
   current_command [6] = mcon;
   current_command [7] = mcon>>8;
   current_command [8] = data;
   current_command [9] = data>>8;

 	temp = (ubyte *)(COM_RAM); 
	*temp = 0x0c0;
	
   ack_or_response = ACK;
   send_pkt_to_dsp();

}
#endif




