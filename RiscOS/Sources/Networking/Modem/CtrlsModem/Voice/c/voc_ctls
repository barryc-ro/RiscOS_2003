/******************************************************************************
/
/   Copyright 1994, 1995
/   All Rights Reserved by :
/    Cirrus Logic, Inc.
******************************************************************************/

#include "sys_def.h"
#include "dv_def.h" 
#include "dv_mem.h"
#include "dv_pro.h"
#include "..\io\linepro.h" 
#include "vce_def.h"
#include "..\mt_ctls1\cp_dsp.h"
#include "..\mt_ctls1\mt_macro.h"
#include "vce_cpro.h"
#include "vce_mem.h"
#include "voc_icd.h"
#include "func_mac.h"
#include "ptt.h"

#include "..\mt_ctls1\dsppatch.h" /* jlin 11/01/96 */
#include "bldflags.h"

#define UPLD_DNLD_ADDR_LOW             0xf8    /*  3/20/96 */
#define UPLD_DNLD_ADDR_HIGH             0xf9
#define UPLD_DNLD_DATA_REGIS            0xfa
#define CP_CONTROL_REGISTER             0xfc
#define INTERNAL_RST_VECTOR            0x800
#define ERR_MSG4 "ERROR in dnlding PWR ON PATCH"
#define ERR_MSG3 "ERROR in dnlding PWR ON PATCH INT RESET Vec"
#define OK_MSG4 "Dnlding PWR ON PATCH OK"
#define OK_MSG3 "Dnlding PWR ON PATCH INT RESET Vec OK"

extern void dsp_poke(uword, uword);    /*  6/12/96 */
#define SPKR_PKT_SENT "Speaker phone packet sent to DSP"
#define ACK 0
ubyte wait_time = 5;
extern ubyte spkr_phn_dnl;    /*  4/22/96 */
void wait_a_while(void);
extern void dnld_patch(const uword tbl[]);    /*  5/18/96 */
extern void enable_int(void);
extern void disable_int(void);
void end_spkr_phn_mode(void); /*  3/19/96 */
void dnld_spkr_phn_code(uword *);    /*  4/22/96 */
void enable_spkr_phone(void);        /*  5/13/96 */
void tele_emul_enable(ubyte); /*  2/23/96 */
void vce_local_phn_hook_status(void); /*  1/24/96*/
void send_dle(ubyte); /* 1/24/96 */
void dp_vce_get_capability(ubyte *, ubyte *, ubyte *, ubyte *,
                   ubyte *, uword *, ubyte *, ubyte *,uword *,uword *);
void dp_vce_get_compression_info(ubyte, struct vce_comp_struct *);
void dp_vce_set_level(ubyte, ubyte);
void dp_vce_send_tone(uword, uword, uword, ubyte);
void dp_vce_send_dtmf_tone(ubyte, uword);
ubyte dp_vce_call_progress(void);
void dp_vce_compression_init(ubyte, ubyte, uword, ubyte);
void dp_vce_return_to_idle(void);
void dp_vce_speaker(ubyte,ubyte);
void dp_vce_microphone(ubyte,ubyte);
void dp_set_speaker(ubyte,ubyte);
void set_spkr_phn_mic_vol(void);        /*  7/18/96 */
void     set_spkr_phn_spkr_vol(void);
void after_exit_spkrphn_init_for_voice(void);  /*  10/1/96 */

extern void line_select_vector(ubyte);

extern uword pwr_on_patch[];
extern void set_7_wait_states(void);        /* this sets 7 wait states for musket-cp interf*/
ubyte patch_re_dnlded = 1;
extern uword dsp_code[];    /*  4/22/96 */

#define PBA                 0xFFC000            /* Musket Peripheral Base Address*/
#define GPR1                (PBA + 0x208)
#define GPR_TNKL             GPR1
#define GPIO_BIT_TNKL    2                /* GPIO 10 - GPR1, GPCR1 */
#define ACTIVATE        0
#define DEACTIVATE      1

#define   CID_RELAY_ON   0x0000                  /* low active */
#define   CID_RELAY_OFF  0x0200

extern void set_gpio_bit(uword *, ubyte, ubyte);

void exit_conv_rec_vls17(void);
ubyte conv_rec_vls17(void);

ubyte    conv_rec_going_on    = 0;

extern const uword vcepatch[];
extern void voice_dnld_patch(const uword tbl[]);
extern const uword vcepatch[];

void    wakeup_from_sleep_in_voice(void);    /*  12/3/96 */
extern ubyte ToneResult;  
extern ubyte handset_offhook_flag; 
extern country_DTMF_Level PTT_DTMF_Level[7];
extern ubyte CountryInfo;                 
extern country_DTMF_Level PTT_dual_freq_Level[7];

/*******************************************************************************
/
/   Routine: dp_vce_init
/
/   Author: RSA 
/
/   Creation Date: 01/19/1994
/
/   Description: This routine will place the data pump into the VOICE mode
/                and initialize any parameters needed.                
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  dp_vce_data_direction, dp_vce_receiver_idle
/                              dp_vce_sampling_rate, dp_vce_int_tone_count
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
/  Author & Date: RSA 6/13/1995.
/  Description: Initialized a DTMF variable to FALSE.
/  Reason: Needed for proper shielded DTMF reporting.
/
*******************************************************************************/
void dp_vce_init(void)
{
    dp_vce_receiver_idle = TRUE;
    dp_vce_sampling_rate = 8000;
}

/*******************************************************************************
/
/   Routine: dp_vce_get_capability
/
/   Author: RSA
/
/   Creation Date: 10/8/92
/
/   Description: This routine will inform the voice module of the capability
/         of the selected voice parameter.
/
/   Input Parameters: ubyte *num_methods - 1 byte value indicating the number of
/                       compression methods available.
/              ubyte *rcv_range - 2 ubyte value indicating the available
/                     receive gain range.
/              ubyte *rcv_default - 1 ubyte value indicating the default
/                       receive gain value
/              ubyte *tx_range - 2 ubyte value indicating the available
/                    transmit volume range
/              ubyte *tx_default - 1 ubyte value indicating the default
/                      transmit volume value
/              uword *line_sel - Bit mapped value indicating the possible
/                                       voice I/O devices that are components
/                                       in the possible hardware configurations
/                                       0 - On hook; Local Phone connected to telco
/                                       1 - Off hook; Local phone detecting off hook
/                                       2 - On hook; Local phone connected to DCE
/                                       3 - Off hook; Local phone connected to telco
/                                       4 - On hook; Internal speaker connected
/                                           to DCE; local phone connected to telco
/                                       5 - Off hook; Internal speaker connected
/                                           to telco; local phone detecting off hook
/                                       6 - On hook; Internal microphone connected
/                                           to DCE; local phone connected to telco
/                                       7 - Off hook; Internal microphone and
/                                           internal speaker connected to telco; 
/                                           local phone detecting off hook
/                                       8 - On hook; External speaker connected
/                                           to DCE; local phone connected to telco
/                                       9 - Off hook; External speaker connected
/                                           to telco; local phone detecting off hook
/                                       10- Off hook; Internal microphone and
/                                           external speaker connected to telco; 
/                                           local phone detecting off hook
/                                       11- On hook; External microphone connected
/                                           to DCE; local phone connected to telco
/                                       12- Off hook; External microphone and
/                                           internal speaker connected to telco; 
/                                           local phone detecting off hook
/                                       13- Off hook; External microphone and
/                                           external speaker connected to telco; 
/                                           local phone detecting off hook
/                                       14- On hook; External microphone and
/                                           speaker combo connected to DCE; 
/                                           local phone connected to telco
/                                       15- Off hook; External microphone and
/                                           speaker combo connected to DCE; 
/                                           local phone detecting off hook
/             ubyte *comp_default - 1 ubyte value indicating the default
/                       compression method index.
/             ubyte *bps_default - 1 ubyte value indicating the default
/                       number of bits per sample
/             uword *samp_rate - 1 word values indicating the default
/                    sampling rate for the default
/                    compression method.
/
/             uword *buf_size - 1 word values indicating the receive 
/                    buffer size.
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
*******************************************************************************/
void dp_vce_get_capability(ubyte *num_methods, ubyte *rcv_range, 
                                    ubyte *rcv_default,ubyte *tx_range,
                                    ubyte *tx_default, uword *line_sel,
                                   ubyte *comp_default, ubyte *bps_default, 
                                    uword *samp_rate, uword *buf_size)
{
    *num_methods = NUMBER_OF_COMP_METHODS;
    *rcv_range++ = RECEIVE_GAIN_LOW;
    *rcv_range = RECEIVE_GAIN_HIGH;
    *rcv_default = RECEIVE_GAIN_DEFAULT;
    *tx_range++ = TRANSMIT_VOL_LOW;
    *tx_range = TRANSMIT_VOL_HIGH;
    *tx_default = TRANSMIT_VOL_DEFAULT;
   *line_sel = VOICE_IO_DEVICES;

    /* Indicate that the default method corresponds to the 2nd entry in the
       compression structure. */
    *comp_default = 6; /* cl1 */ /*  2/23/96 */
    comp_byte = 140;    /* set this to CL1 */ /*  2/23/96 */

    *bps_default = 8;  /*was 4 changed by  10/10/95 */
    *samp_rate = 8000; /* was 4800 changed by  on 7/15/96
                                                after checking with mikeW */

    *buf_size = DP_VCE_BUFFER_SIZE;
    /* dp_vce_spk_vol_mirror = 0;*/ /*  2/13/96 */
}

/*******************************************************************************
/
/   Routine: dp_vce_get_compression_info
/
/   Author: RSA
/
/   Creation Date: 10/8/92
/
/   Description: This routine will place the compression information for the
/         selected method into the input structure.
/
/   Input Parameters: ubyte method - Selected compression method
/              struct comp_struct *ptr - Pointer to the compression structure
/            struct {
/                ubyte id;        Compression id number
/                ubyte *comp;    ASCII string describing the
/                        compression method
/                ubyte *company;    ASCII string describing the
/                        company
/                ubyte bps_range[];     Pointer to the allowed bits per sample
/                        1st byte indicates number of entries
/                        Next bytes indicate the values
/                ubyte samp_range[]; Range of allowed sampling rates
/                        1st byte indicates number of ranges
/                        Next byte pairs indicate the range
/                ubyte timing_marks; Time interval between timing marks
/                ubyte silence_sen;    Range of silence compression sensitivity
/                ubyte silence_exp;    Range of silence expansion
/            }
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_get_compression_info(ubyte method, struct vce_comp_struct *ptr)
{
    ubyte i;            /* Index into various arrays */

    ptr->id = id_tbl[method];
    ptr->company = (ubyte *)company_tbl[method];

    /* Get the bits per sample range from the defined table */
    for (i=0; i<=bps_tbl[method][0]; i++)
    {
        ptr->bps_range[i] = bps_tbl[method][i];
    }

    /* Get the possible sampling rates for the different methods */
    for (i=0; i<=samp_range_tbl[method][0]; i++)
    {
        ptr->samp_range[i] = samp_range_tbl[method][i];
    }

    /* Get the possible event reporting for the transmit state */
    ptr->tx_mode_events = tx_event_tbl[method];

    /* Get the possible event reporting for the receive state */
    ptr->rx_mode_events = rx_event_tbl[method];

    /* Get the possible event reporting for the idle state */
    ptr->idl_mode_events = idl_event_tbl[method];

    /* Get the number of timing marks for the compression scheme */
        ptr->timing_marks = timing_marks_tbl[method];

    /* Get the silence sensitivity setting for the compression scheme */
        ptr->silence_sen = silence_sen_tbl[method];

    /* Get the silence expansion setting for the compression scheme */
        ptr->silence_exp = silence_exp_tbl[method];
}

/*******************************************************************************
/
/   Routine: dp_vce_set_level
/
/   Author: RSA
/
/   Creation Date: 10/22/92
/
/   Description: This routine will set the receive gain.
/
/   Input Parameters: ubyte type - selects receive gain or transmit volume
/            0 - transmit volume
/            1 - receive gain
/
/              ubyte value - New receive gain or transmit volume
/            0 - 255
/            128 corresponds to the nominal value
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_set_level(ubyte type, ubyte value)    /* changed by  on 10/10/95 */
{
    /* value is the level needed for record or playback level */
    /* parameter type is not used cutlass will interpret the value
        correctly depending on whether the DSP is set for record or playback    */

    if((type == VOICE_RECEIVE) && (thru_mic == TRUE))
    {
        if(value > 123)
            value = value - 2;
        else
            value = 121;
    }


    LOAD_PACKET_MODEM_VCE_SET_AUDIO_LEVEL  /*  10/10/95 */
    ack_or_response = FALSE;
    send_pkt_to_dsp();
}

/*******************************************************************************
/
/   Routine: dp_vce_send_tone
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will send a tone at the specified frequency for
/         the specified time period.
/
/   Input Parameters: uword f1 - frequency (Hz) of the 1st tone
/
/              uword f2 - frequency (Hz) of the 2nd tone
/
/              uword time - length of the tone (milliseconds)
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_send_tone(uword f1, uword f2, uword time, ubyte dtmf_flag)
{
    ubyte tone_on_off, tone2_level,tone1_level,x1,ch;

    patch_re_dnlded = TRUE;    /*  9/12/96 */

    if(spkr_phn_mode == TRUE) /*  9/24/96 */
    {
        after_exit_spkrphn_init_for_voice();        /*  10/1/96 */
    }
    patch_re_dnlded = FALSE;  /*  9/12/96 */

   if(dtmf_flag == 1)
    {
        /* if tone present tone level = -10db */
        tone1_level =  PTT_DTMF_Level[CountryInfo].DTMF_Level.level1;    
        tone2_level =  PTT_DTMF_Level[CountryInfo].DTMF_Level.level2;

   }
    else
   {
      // table driven again here!

      if(f1)        
       /* if tone present tone level = -10db */
         tone1_level = PTT_dual_freq_Level[CountryInfo].DTMF_Level.level1;    
      else
         tone1_level = 255;    /* if tone absent turn off (255 turns off tone ) */

      if(f2)
         tone2_level = PTT_dual_freq_Level[CountryInfo].DTMF_Level.level2;
      else
         tone2_level = 255;
   }

    /* set the level in the dsp before giving freq info */
    LOAD_PACKET_MODEM_SET_VCE_DTMF_LEVELS   /* 0x88 */
    ack_or_response = FALSE;
    send_pkt_to_dsp();


    if(f1)
        f1 = ((f1*32767)/4800);        /* scale as needed by  cutlass */
    if(f2)
        f2 = ((f2*32767)/4800);
    tone_on_off = ON;

    LOAD_PACKET_MODEM_SEND_TONE      /* 0x7c */
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    vce_send_tone_timer = (time/10); /* set dial timer so that the tone is sent out first */
    while(vce_send_tone_timer)
    {
        process_wait();
    }        /* wait till tone completely sent out */

    f1 = 0;
    f2 = 0;
    tone_on_off = OFF;

    LOAD_PACKET_MODEM_SEND_TONE
    ack_or_response = FALSE;

/*  clear the detected tone before shuting the tone off 3/19/96 */
    dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;   
    ch = dsp_cp();

    send_pkt_to_dsp();

    dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;/*  clear the detected tone 3/19/96 */   
    ch = dsp_cp();

    vce_send_tone_timer = (time/10); /* now wait for inter tone delay */
    while(vce_send_tone_timer)
    {
        process_wait();
    }    /* wait till inter tone delay is complete */

    dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;/*  clear the detected tone 3/19/96 */   
    ch = dsp_cp();

    x1 = *srptr[11];
    config_dtmf_dial(x1,x1); /* reconfigure dsp for dtmf mode after tone sent */

     if((tele_emul_value == 1) || (spkr_phn_mode == TRUE)) /*  3/20/96 */
    {
          vce_mode = OFFLINE_COMMAND;
        voice_event_rept = vce_idl_events;  
          vce_state = VOICE_OFFLINE_COMMAND;

        /*dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);*/ /*  3/18/96 */
        tele_emul_enable(ON);
        CTSon();

        if(vls_cmd_value == 17)            /*  9/26/96 */
             x1 = conv_rec_vls17(); 
    }
}

/*******************************************************************************
/
/   Routine: dp_vce_send_dtmf_tone
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will send the specified DTMF tone for the specified
/         time period.
/
/   Input Parameters: ubyte digit - DTMF digit
/
/              uword time - length of the tone (milliseconds)
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_send_dtmf_tone(ubyte digit, uword time)
{ 
    uword f1,f2;
    ubyte is_dtmf;

    is_dtmf = 1;
    switch(digit)
    {
        case '0':
            f1 = 941;
            f2 = 1336;
        break;

        case '1':
            f1 = 697;
            f2 = 1209;
        break;

        case '2':
            f1 = 697;
            f2 = 1336;
        break;

        case '3':
            f1 = 697;
            f2 = 1477;
        break;

        case '4':
            f1 = 770;
            f2 = 1209;
        break;

        case '5':
            f1 = 770;
            f2 = 1336;
        break;

        case '6':
            f1 = 770;
            f2 = 1477;
        break;

        case '7':
            f1 = 852;
            f2 = 1209;
        break;

        case '8':
            f1 = 852;
            f2 = 1336;
        break;

        case '9':
            f1 = 852;
            f2 = 1477;
        break;

        case 'A':
        case 'a':
            /*digit = 10;*/
            f1 = 697;
            f2 = 1633;
        break;

        case 'B':
        case 'b':
            /*digit = 11;*/
            f1 = 770;
            f2 = 1633; /*  6/5/96 was 1336 */
        break;

        case 'C':
        case 'c':
            /*digit = 12;*/
            f1 = 852;
            f2 = 1633;
        break;

        case 'D':
        case 'd':
            /*digit = 13 ;*/
            f1 = 941;
            f2 = 1633;
        break;

        case '*':
            /*digit = 14;*/
            f1 = 941;
            f2 = 1209;
        break;

        case '#':
            /*digit = 15;*/
            f1 = 941;
            f2 = 1477;
        break;

        default:
            is_dtmf = 0;
        break;

    }

    dp_vce_send_tone(f1,f2,time, is_dtmf);
}

/*******************************************************************************
/
/   Routine: dp_vce_call_progress
/
/   Author: RSA
/
/   Creation Date: 10/28/92
/
/   Description: This routine will determine if a DTMF tone has been detected
/         and return the appropiate value indicating tone.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte temp - tone detected
/            0 - DTMF 0
/            1 - DTMF 1
/            2 - DTMF 2
/            3 - DTMF 3
/            4 - DTMF 4
/            5 - DTMF 5
/            6 - DTMF 6
/            7 - DTMF 7
/            8 - DTMF 8
/            9 - DTMF 9
/            10- DTMF *
/            11- DTMF #
/            12- DTMF A
/            13- DTMF B
/            14- DTMF C
/            15- DTMF D
/            0xFF - No tone detected
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
/  Author & Date: RSA 6/7/1995.
/  Description: Fix for the 2225hz Bell Answer Tone reporting.
/  Reason: Was not an option in previous versions.
/
/  Author & Date: RSA 6/13/1995.
/  Description: Revamped the DTMF detection and reporting for
/                 the IS101 voice specification.
/  Reason: The IS101 would only report a single DTMF tone (shielded)
/           instead of multiple (every 70ms) shielded tones for DTMF.
/
*******************************************************************************/
ubyte dp_vce_call_progress(void)
{
    ubyte ch;
    dspdrv_ReadCram(ANSTONE_LOC,&ch,1);
    ch = (ch & 0x02);
    if(ch == 0x02)
        return(DETECTED_2100HZ);

   if(handset_offhook_flag == 1)  //
   {
     if(ToneResult == DIALTONE)
        return(DETECTED_DIALTONE);
   }

   if(ToneResult == BUSY_SIGNAL)
   {
      return(DETECTED_BUSY);
   }

   if(ToneResult == RINGBACK)
      return(DETECTED_RINGBACK);  //


    dsp_cp_packet = PACKET_DP_VCE_DTMF_DIGIT;          
    if(dsp_cp())
    {
       if( (ch == DIALTONE) || (ch == BUSY_SIGNAL) || (ch == RINGBACK) )
            return(NOTHING_DETECTED);
        else
          return(dsp_response_data[0]);
   }

    ch = acu_call_progress();        
    if((ch == RINGON) || (ch == RINGOFF))
        return(ch);
    else
        return(NOTHING_DETECTED);
}

/*******************************************************************************
/
/   Routine: dp_vce_compression_init
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will congifure the data pump to either transmit
/         or receive voice data using the selected compression method.
/
/   Input Parameters: ubyte direction - Direction of the data
/            0 - transmit
/            1 - receive
/
/              ubyte id - Compression Method
/            2 - 16 bit linear PCM
/            3 - A-Law
/            4 - µ-Law
/            17- GSM
/
/              uword rate - Sampling rate
/            4800Hz
/            7200Hz
/            8000Hz
/            9600Hz
/            11000Hz
/
/           ubyte spk_vol - Used defined speaker volume
/        0 - Low volume
/           1 - Low volume
/           2 - Medium volume
/           3 - High volume
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
******************************************************************************/
void dp_vce_compression_init(ubyte direction, ubyte id, uword rate, ubyte spk_vol)
{    
    ubyte ctls_sampling_rate_code;
    ubyte ctls_compression_scheme;
    ubyte    rec_playback;
    ubyte voice_mode_parameter;

    dp_vce_to_clear();  /*  2/27/96 */
    dp_vce_from_clear();

    ad3_count = 0;  /*  2/13/96 */

/* need to implement the other modes i.e. 8 to 20 */
    if((vce_mode != RECEIVE_MODE) && (vce_mode != TRANSMIT_MODE)) /*  2/21/96 */
        voice_mode_parameter = 0;
    else if((vce_mode == RECEIVE_MODE) && thru_phone)
        voice_mode_parameter =2;
    else if((vce_mode == TRANSMIT_MODE) && thru_phone)
        voice_mode_parameter = 3;

    else if((vce_mode == RECEIVE_MODE) && thru_line)
        voice_mode_parameter = 4;
    else if((vce_mode == TRANSMIT_MODE) &&thru_line)
        voice_mode_parameter = 5;

    else if((vce_mode == RECEIVE_MODE) && thru_mic)
        voice_mode_parameter = 6;
    else if((vce_mode == TRANSMIT_MODE) && thru_spkr)
        voice_mode_parameter = 7;

    LOAD_PACKET_MODEM_VCE_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

      switch(rate)
    {
        case 4800:
            ctls_sampling_rate_code = 0;
        break;

        case 7200:
            ctls_sampling_rate_code = 1;
        break;
        
        case 8000:
            ctls_sampling_rate_code = 2;
        break;

        case 9600:
            ctls_sampling_rate_code = 3;
        break;
    
        case 11025:        /* was 11200 changed by  on 7/8/96 */
            ctls_sampling_rate_code = 4;
        break;

        default:
              ctls_sampling_rate_code = 0; /* was 0  10/1/96 */
    }

    switch(id)
    {
        case SIGNED_PCM:
        /*case SIGNED_PCM_2: *//*  2/19/96 */ /* 8 bit linear */
            ctls_compression_scheme = 2;
        break;

        case UNSIGNED_PCM:
        /*case UNSIGNED_PCM_2:*//*  2/19/96 */    /* 16 bit linear */
            ctls_compression_scheme = 1;
        break;
    
        case AD4_PCM:
      /*    case AD4_PCM_2: *//*  2/19/96 */     /* AD4 */
            ctls_compression_scheme = 6;
        break;
    
        case CL1:     /* CL1 */
            ctls_compression_scheme = 0;
        break;
        
        case AD3_PCM:    /* AD3 */

            /* 2/13/96 for ad3 */
            ad3_sampl_count = 8;
            ad3_long_wrd_1 = 0;
            ad3_long_wrd_2 = 0;
            ad3_dp_long_wrd = 0;
            dp_ad3_byte = 0;

            ctls_compression_scheme = 5;
        break;
    
        default:     /* CL1 */
            ctls_compression_scheme = 0;        /* was 0  10/1/96 */
    }

    if(direction == VOICE_TRANSMIT)
        rec_playback = CTLS_PLAYBACK;
    else if(direction == VOICE_RECEIVE)
        rec_playback = CTLS_RECORD;
    else
        rec_playback = CTLS_IDLE;

/* the chk the notes in the print out of the RSA code */
    LOAD_PACKET_MODEM_VCE_REC_PLAYBACK_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    /* this will send the silence detection
        level and time period to the cutlass */                                                                                                            
    if(vce_mode == RECEIVE_MODE)  /*  3/11/96 */
    {
        LOAD_PACKET_MODEM_VCE_SET_PARAMS     
        ack_or_response = FALSE;
        send_pkt_to_dsp();
    }
    
    vce_dtmf_report_delay = 0;    
    vce_2100hz_msg_delay    = 0;
    vce_busy_msg_delay = 0;
    vce_1100hz_msg_delay = 0;
    vce_dialtone_msg_delay = 0;
    vce_1300hz_msg_delay    = 0;
    vce_2225hz_msg_delay = 0;
}

/*******************************************************************************
/
/   Routine: dp_vce_return_to_idle
/
/   Author: RSA 
/
/   Creation Date: 01/20/94
/
/   Description: This routine will force the data pump out of voice mode and
/                back into idle mode.
/
/   Input Parameters: None
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_return_to_idle(void)
{
}

/*******************************************************************************
/
/   Routine: dp_vce_microphone
/
/   Author: RSA
/
/   Creation Date: 10/22/92
/
/   Description: This routine will set the internal and external
/                microphone relays to the selected value
/
/   Input Parameters: ubyte num - Selected setting
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_vce_microphone(ubyte int_micr, ubyte ext_micr)
{
    ubyte afe_choice,first_low_byte,first_high_byte;
    ubyte second_low_byte,second_high_byte;
    
    if (spkr_phn_mode == TRUE)        /*  7/11/96 */
        afe_choice = AFE2;
    else
        afe_choice = AFE1;


    if(int_micr == ON)
    {
        first_low_byte = 0xdc;    /* turn mic on and leave spk setting as is */
        second_low_byte = 0x0c;

        first_high_byte = 0x3f;     /* was 3f */ 
        second_high_byte = 0x02;  /* was 0,  9/17/96 */

        thru_mic = TRUE;
    }
    else
    {
        first_low_byte = 0xd0; /* turn mic off and leave spk setting as is */
        second_low_byte = 0x00;

        first_high_byte = 0x3f;      /* was 3f */    
        second_high_byte = 0x02;  /* was 0,  9/17/96 */
        thru_mic = FALSE;
    }
    LOAD_PACKET_MODEM_VCE_PGC_INIT

    ack_or_response = FALSE;
    send_pkt_to_dsp();
}

/*******************************************************************************
/
/   Routine: dp_vce_speaker
/
/   Author: RSA
/
/   Creation Date: 4/12/1993
/
/   Description: This routine will control the speaker based upon the parameter
/                passed in.
/
/   Input Parameters: ubyte state - State of the speaker
/                           0 - Speaker OFF
/                           1 - Speaker ON
/
/   Output Parameters: none
/
/   Global Variables Changed:  dp_vce_spk_vol_mirror
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
*******************************************************************************/
extern ubyte spkr_on;
void dp_vce_speaker(ubyte int_state, ubyte ext_state)
{
    ubyte afe_choice,first_low_byte,first_high_byte;
    ubyte second_low_byte,second_high_byte;
    
    if (spkr_phn_mode == TRUE)        /*  7/11/96 */
        afe_choice = AFE2;
    else
        afe_choice = AFE1;

    if(int_state == ON)
    {
        first_low_byte = 0xdc;    /* spk vol = med,spk_on = both Tx and Rx
                                            recv_gain = unchanged */
        second_low_byte = 0x00;    /*  2/22/96 */ /* should be 0 */

        first_high_byte = 0x03;        
        second_high_byte = 0x3a; /* was 38,  9/17/96 */
        thru_spkr = TRUE;
    }
    else
    {
        first_low_byte = 0xdc; /* turn mic off and leave spk setting as is */
        second_low_byte = 0x00;

        first_high_byte = 0x33;        /* was 03 changed by  8/12/96 */
        second_high_byte = 0x02;    /* was 0 ,  9/17/96 */
        thru_spkr = FALSE;
/*  7/16/96 if spkr set in data mode turnoff the flag */
        if(spkr_on)
            spkr_on = FALSE; 

    }
    LOAD_PACKET_MODEM_VCE_PGC_INIT

    ack_or_response = FALSE;
    send_pkt_to_dsp();

}

/*******************************************************************************
/
/   Routine: dp_set_speaker
/
/   Author: RSA 
/
/   Creation Date: 01/19/1994
/
/   Description: This routine will control the speaker based upon the parameter
/                passed in.
/
/   Input Parameters: uses variable dp_vce_spk_vol_mirror
/
/   Output Parameters: none
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                -
/   -------------------------------------------------------------
/
/   Author & Date:    RSA
/   Description:
/   Reason:
/
*******************************************************************************/
void dp_set_speaker(ubyte afe_select, ubyte spkr_gain)
{
    ubyte afe_choice,first_low_byte,first_high_byte;
    ubyte second_low_byte,second_high_byte;
    
    afe_choice = afe_select;

    first_low_byte = 0xdc;    /* spk_on = both Tx and Rx,recv_gain = unchanged */
    second_low_byte = 0x00;    

    first_high_byte = 0x03;        
    if(spkr_gain == LOW)
        second_high_byte = 0x34;    
    else if(spkr_gain == MEDIUM)
        second_high_byte = 0x38; /* 38*/
    else if (spkr_gain == HIGH)
        second_high_byte = 0x3c;        
    
    thru_spkr = TRUE;

    LOAD_PACKET_MODEM_VCE_PGC_INIT

    ack_or_response = FALSE;
    send_pkt_to_dsp();

}

void vce_local_phn_hook_status(void) /*  1/24/96*/
{
    ubyte pair;

    if(dp_vce_local_phone_on_hook())
        {
            /* this is reuired by ms-phone if on hook when entering voice mode
                report it.  8/15/96 */
        if(dle_H_sent)
        {
            if(relay_on_hook_flag == FALSE)
            {
                debounce_timer = DEBOUNCE_TIME;
                relay_on_hook_flag = TRUE;
                relay_off_hook_flag = FALSE;
            }            
            else if((relay_on_hook_flag == TRUE) && (!debounce_timer))
            {
                dle_h_sent = TRUE;
                dle_H_sent = FALSE;
                first_time = FALSE;
                phn_status = 0;
                relay_on_hook_flag = FALSE; /*  2/25/96 */
                pair = 'h';
                send_dle(pair);
            }
        }
        else
        {
            if(debounce_timer)
                debounce_timer = DEBOUNCE_TIME;
        }
    }
    else 
    {
        if(!dle_H_sent)
        {
            if(relay_off_hook_flag == FALSE)
            {
                debounce_timer = DEBOUNCE_TIME;
                relay_off_hook_flag = TRUE;
                relay_on_hook_flag = FALSE;
            }
            else if((relay_off_hook_flag == TRUE) && (!debounce_timer))
            {
                dle_h_sent = FALSE;
                dle_H_sent = TRUE;
                first_time = FALSE;
                phn_status = 0;
                relay_off_hook_flag = FALSE; 
                pair = 'H';
                send_dle(pair);

/*
    if someone picks up the handset then let home talkon the line by hanging
    up the voice and hook relays. this needs to be done only in modes given 
    below. visshy agrees with this scheme.
*/
                if((vls_cmd_value == 1) || (vls_cmd_value == 5) ||
                    (vls_cmd_value == 7) || (vls_cmd_value == 17))
                {
                    if(conv_rec_going_on == TRUE)
                        exit_conv_rec_vls17();

                    execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,OFF,OFF,OFF,OFF); /* +vls=0 */
                    vls_cmd_value = 0;
                }

            }
        }
        else
        {
            if(debounce_timer)
                debounce_timer = DEBOUNCE_TIME;
        }
    }
}

void send_dle(ubyte value)
{
      ubyte *info_ptr;

        /* If currently sending or receiving data then place the call progress
     information into the voice DTE buffers. Else the info goes back 
     through the ACU */
      if (vce_mode == TRANSMIT_MODE || vce_mode == RECEIVE_MODE)
      {
          while (voice_dte_to_free() < 2)
              ;
            voice_dte_to_char(DLE);
            voice_dte_to_char(value);
      }
      else
      {
          vce_array[0] = DLE;
           vce_array[1] = value;
         vce_array[2] = '\0';

            /*  7/11/96 */
            info_ptr = (ubyte *)&vce_array[0];
            output_info(info_ptr,UNFORMATTED); 
            vce_array[0] = '\0';
     }
}



/*************************************************************************
*
*         by  2/23/96
*
*        will enter tele emulation mode or exit depending on para passed
*
**************************************************************************/

void tele_emul_enable(ubyte tele_emul_state) /*  2/23/96 */
{
    ubyte voice_mode_parameter;

    if(tele_emul_state == ON)
    {
        
        if(tele_emul_value == TRUE) /*  3/20/96 */
        {
            if(thru_mic)     /* moved here by  7/18/96 */
                 dp_vce_set_level(VOICE_TRANSMIT,spk_phn_mic_level); /*  2/29/96 */
            if(thru_spkr)
                dp_set_speaker(AFE1,tele_emul_spk_level);

            voice_mode_parameter = 9;
            LOAD_PACKET_MODEM_VCE_INIT
            ack_or_response = FALSE;
            send_pkt_to_dsp();
        }
        else if(spkr_phn_mode == TRUE) /*  3/20/96 */
        {
            enable_spkr_phone();
        }
    }
    else
    {
        if(spkr_phn_mode == TRUE) /*  5/13/96 */
        {
            end_spkr_phn_mode();
        }
        else
        {            
           dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                              vce_sampling_rate,vce_speaker_vol);
        }
    }
}

/****************************************************************************
*
*        these routines are for speaker phone
*
*                for dnld spkr phn code, exit spkr phn mode, 
*                and init spkr phn after dnld
*
*
*
****************************************************************************/


/* this routine will take the code out of spkr phn mode */
/*  3/19/96 */
void end_spkr_phn_mode(void) /*  3/19/96 */
{

    ubyte afe_choice,first_low_byte,first_high_byte;
    ubyte second_low_byte,second_high_byte;
    ubyte ctls_sampling_rate_code,ctls_compression_scheme,rec_playback,ch;
    


    LOAD_PACKET_MODEM_VCE_RETURN_TO_IDLE
    ack_or_response = FALSE;
    send_pkt_to_dsp();

      ctls_sampling_rate_code = 0;
    ctls_compression_scheme = 0;
    rec_playback = CTLS_IDLE;
    LOAD_PACKET_MODEM_VCE_REC_PLAYBACK_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    afe_choice = AFE1;                  /* configure AFE1 for spkr phn mode */
    first_low_byte = 0x0;
    first_high_byte = 0x0;        
    second_low_byte = 0x00;
    second_high_byte = 0x32;         /* was 3a, we now mute the spkr when exiting
                                                spkr phn mode ,  9/22/96 */
    LOAD_PACKET_MODEM_VCE_PGC_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();


    afe_choice = AFE2;                /* configure AFE2 for spkr phn mode */
    first_low_byte = 0x0;
    first_high_byte = 0x0;        
    second_low_byte = 0x00;
    second_high_byte = 0x0;
    LOAD_PACKET_MODEM_VCE_PGC_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    executing_spkr_phn = FALSE;    /*  7/18/96 */

    if(!patch_re_dnlded)        /*  9/10/96 */
    {
        dsp_cp_packet = 0xC4;          
        ch = dsp_cp();

        LOAD_MODEM_INIT
        ack_or_response = ACK;
        send_pkt_to_dsp();

        dnld_spkr_phn_code(pwr_on_patch);    
        set_7_wait_states();
      
      dsppatch(COMMON_PATCH);  /* jlin, for dynamic patch 10/31/96 */

        LOAD_MODEM_INIT
        ack_or_response = ACK;
        send_pkt_to_dsp();

      dsppatch(VOICE_PATCH);

        dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                           vce_sampling_rate,vce_speaker_vol);
        patch_re_dnlded = TRUE;
      
        spkr_phn_mode = FALSE; 

        if((vls_cmd_value == 6) || (vls_cmd_value == 7))
            dp_vce_microphone(ON,ON);

        if((vls_cmd_value == 4) || (vls_cmd_value == 5) || (vls_cmd_value == 7))
        {
           dp_vce_speaker(OFF,OFF);
              wait_a_while();
           dp_vce_speaker(ON,ON);
              wait_a_while();
        }
        spkr_phn_mode = TRUE; /*  3/20/96 */

    }
}

extern ubyte dsp_sleep;

void dnld_spkr_phn_code(uword *spk_phn_array)    /*  4/22/96 */
{
//#if (PATCHLESS_EXTERNAL == 1)
//        dsp_cfg(OFF);        /* set dsp_cfg to off before soft reset of dsp */
//#endif

#if (PATCHLESS_EXTERNAL == 0)
    ubyte *temp;
    uword error= 0;
    uword temp1,temp2,i,length;

    /* needed for mcon and Bcon poke */
    uword add;

    dsp_cfg(ON);    /* set dsp_reset and dsp_cfg to 1 */    
    dsp_reset(ON);

    dial_timer = 250;     /* was 250 ms */
    while(dial_timer)
    {
        process_wait();
    }        
    dsp_reset(OFF);    /* release the reset */
/* dnld the reset vector */
    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
    temp1 = INTERNAL_RST_VECTOR;        
    wait_a_while();
    *temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
    temp1 = INTERNAL_RST_VECTOR;        
    wait_a_while();
    *temp = (ubyte)temp1;        /* write the low addr in the reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);
    wait_a_while();
      *temp = spk_phn_array[2];
    temp1 = spk_phn_array[2];
    wait_a_while();
    *temp = temp1 >> 8;

/* dnld rest of code */
    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
    temp1 = spk_phn_array[2];        /* start addr of the spk phn code in temp1 */
    wait_a_while();
    *temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
    wait_a_while();
    *temp = (ubyte)spk_phn_array[2];        /* write the low addr in the reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);

    length = (spk_phn_array[1]-1);
    temp1 = 0;

    for(i=0; i<= length; i++)
    {
        temp1 = spk_phn_array[i+3];
        wait_a_while();
        *temp = (ubyte)temp1;                  /* write low byte then high byte */
        wait_a_while();
        *temp = (ubyte)(temp1 >> 8) & 0xFF;
    }

/* dnld done now verify */
    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
    wait_a_while();
    *temp = (ubyte)spk_phn_array[2];        /* write the low addr in the reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
    temp1 = spk_phn_array[2];        /* start addr of the spk phn code in temp1 */
    wait_a_while();
    *temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);

    temp2 = 0;
    temp1 = 0;
    
    error = 0;
    for(i=0; i<= length; i++)
    {
        wait_a_while();
        temp1 = *temp;
        temp2 = temp1;
        wait_a_while();
        temp1 = *temp;
        temp2 = temp2 | (temp1 << 8);

        if(temp2 != spk_phn_array[i+3])
        {
            error++;
            break;
        }
        temp2=0;
    }

    error = 0;

/* now verify the reset vector */
    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_LOW);
    temp1 = INTERNAL_RST_VECTOR;        
    wait_a_while();
    *temp = (ubyte)temp1;        /* write the low addr in the reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_ADDR_HIGH);
    temp1 = INTERNAL_RST_VECTOR;        
    wait_a_while();
    *temp = (ubyte)(temp1 >> 8) & 0xFF; /* get high byte of addr in addr high reg */

    temp = (ubyte *)(COM_RAM + UPLD_DNLD_DATA_REGIS);
    
    temp2 = 0;
    temp1 = 0;
    wait_a_while();
    temp1 = *temp;
    temp2 = temp1;
    wait_a_while();
    temp1 = *temp;
    temp2 = temp2 | (temp1 << 8);

    temp1 = spk_phn_array[2];
    if(temp2 != temp1)
        error = 0xffff;

#if (PATCHLESS_EXTERNAL == 1)
      if(spkr_phn_dnl)
        dsp_cfg(OFF);        /* set dsp_cfg to off before soft reset of dsp */
#endif

    dial_timer = 100;         /*was 100 ms */
    while(dial_timer)
    {
        process_wait();
    }        

    temp = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);
    wait_a_while();
    *temp = 0x08;        /* release dsp reset and exec from int p-ram */

    dial_timer = 150;     /* was 150 */
    while(dial_timer)
    {
        process_wait();
    }        


    temp = (ubyte *)(COM_RAM + CP_CONTROL_REGISTER);
    wait_a_while();
    *temp = 0x09;        /* release dsp reset and exec from int p-ram */

    dial_timer = 50;      /* was 50 */
    while(dial_timer)
    {
        process_wait();
    }        

    if(spkr_phn_dnl == 2)    
        return;

/***********
     added by  on 6/13/96
    these pokes were moved here beacuase they are needed after the spkr phn
    code is downloaded also.
    remember this routine is used to download both the speaker phone code 
    and teh poweron patch

************/
/* 
    poke MCON (hex addr 13) if in ROM environment 

    HOwever we poke the shadow location on int PRAM the dsp code
    copies this shadow location to the MCON. the shadow location
    is different for C6 and J5
*/

#if (PATCHLESS_EXTERNAL == 0)
#if CUTLASS_C6 == 1
            add = 0x17e3;
#else
            add = 0x17e4;
#endif
            dsp_poke(0x7c00,add); /* poke mcon shadow register */        
            if(spkr_phn_dnl)
            {
                dsp_poke(0x0025,0x03fb); /* poke freq_sel also */
                dsp_poke(0x0000,0x0010); /* poke wcon also */
                dsp_poke(0x7c20,0x0013); /* poke mcon directly as well */
            }

#endif /* endif for dsp_code_internal */

/* 
    peek BCON onlyif running external code 
    turn bit 15 to 0 to enable the second AFE
*/
#if (PATCHLESS_EXTERNAL == 1)
/*            mcon_lo = 0;
            mcon_hi = 0;
            pram_addr_lo = 0x11;    
            pram_addr_hi = 0;
        
             LOAD_DSP_PROGRAM_MEMORY_READ

            dsp_cp_packet = PACKET_PROGRAM_MEM_READBACK;
           ack_or_response = RESPONSE;
           send_pkt_to_dsp();

            data_byte = (dsp_response_data[6] << 8);
            data_byte |= dsp_response_data[7];

            data_byte = (data_byte | 8000); 
*/
            dsp_poke(0x0007,0x0011);
#endif

/* 
    turn on bit 15 of BCON, so that second codec interface mapped to second
     channel 
*/

#if (PATCHLESS_EXTERNAL == 0)
    dsp_poke(0x0000,0x0011);
#endif
            

            dsp_poke(0x0000,0x0059);    /*  on 5/31/96 */
            dsp_poke(0x0000,0x005a);    /* poke the value of codec 2 data */
            dsp_poke(0x0002,0x005b);
            dsp_poke(0x0000,0x005c);
#endif
}

void wait_a_while(void)
{
    ubyte j;

    for(j=0;j<=wait_time;j++)
        ;
}

/* 
    these next two functions added by  on 7/18/96
    these functions are for control of volume in spkr phone mode
    one is for speaker control and the other is for mic control

    the byte that need to be changed is lower byte of word 0b in the data ram 
    bank1.

    the upper nibble of this byte is for control of mic voleume and the lower
    nibble is for spkr vol control
*/

void enable_spkr_phone(void)
{
    ubyte afe_choice,first_low_byte,first_high_byte;
    ubyte second_low_byte,second_high_byte;
    ubyte voice_mode_parameter;

    if(patch_re_dnlded)        /*  9/10/96 */
    {
        spkr_phn_dnl = 1;    
        dnld_spkr_phn_code(dsp_code);     
        patch_re_dnlded = FALSE;    
    }
    
    if((patch_re_dnlded == FALSE) && (executing_spkr_phn == TRUE))
        return;

    afe_choice = AFE1;                  /* configure AFE1 for spkr phn mode */
    first_low_byte = 0x0;
    first_high_byte = 0x0;        
    second_low_byte = 0x00;
/* gain from remote line */
    second_high_byte = 0x12; /* was 12 changed on 7/9/96 */
    LOAD_PACKET_MODEM_VCE_PGC_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    afe_choice = AFE2;                /* configure AFE2 for spkr phn mode */
    first_low_byte = 0x0;
    first_high_byte = 0x0;        
    second_low_byte = 0x0c;
/* gain of mic to remote end */
    second_high_byte = 0x1e; /* was 1c changed on 7/9/96 */
    LOAD_PACKET_MODEM_VCE_PGC_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    voice_mode_parameter = SPKR_PHN_MODE;
    LOAD_PACKET_MODEM_VCE_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    set_spkr_phn_mic_vol();        /*  7/18/96 */
     set_spkr_phn_spkr_vol();
    executing_spkr_phn = TRUE;
}

void     set_spkr_phn_spkr_vol(void)
{
    ubyte num;    
    ubyte peek_value;
    ubyte *temp; 

    /* adjust for values outside the range 121 to 131 */
    if(vgs_comm_value <= 121)
        vgs_comm_value = 122;
    else if(vgs_comm_value >= 131)
        vgs_comm_value = 131;

    /* for dsp if vol = 131 then send 0 ; if vol 122 or lower send 9 */
    num = 131 - vgs_comm_value;        

    if(spk_phn_mic_level == 121)
        spk_phn_mic_level = 122;

    peek_value = num;
    num = (131 - spk_phn_mic_level);
    peek_value = (peek_value | (num << 4));

    current_command[0] = 0xe;        /* speaker phone control packet */
    current_command[1] = 0x00;
    current_command[2] = 0x04;
    current_command[3] = 0x00;

    current_command[4] = 0x04;  
    current_command[5] = 0x07;     

    current_command[6] = 0x0;
    current_command[7] = peek_value;
    current_command[11] = 0x00;

    /* need to do this because the poke commands donot send ack packet C0 */
    temp = (ubyte *)(COM_RAM); 
    *temp = 0x0c0;

    ack_or_response = 0;
    send_pkt_to_dsp();
}

void set_spkr_phn_mic_vol(void)
{
    ubyte num;    
    ubyte peek_value;
    ubyte *temp; 

    /* adjust for values outside the range 121 to 131 */
    if(vgs_comm_value <= 121)
        vgs_comm_value = 122;
    else if(vgs_comm_value >= 131)
        vgs_comm_value = 131;

    /* for dsp if vol = 131 then send 0 ; if vol 122 or lower send 9 */
    num = 131 - vgs_comm_value;        

    if(spk_phn_mic_level == 121)
        spk_phn_mic_level = 122;

    peek_value = num;
    num = (131 - spk_phn_mic_level);
    peek_value = (peek_value | (num << 4));

    current_command[0] = 0xe;        /* speaker phone control packet */
    current_command[1] = 0x00;
    current_command[2] = 0x04;
    current_command[3] = 0x00;
    current_command[4] = 0x04;  /* was 0x0b, changed  9/12/96 */
    current_command[5] = 0x07;     /* was 0x00, changed  9/12/96 */

    current_command[6] = 0x0;
    current_command[7] = peek_value;
    current_command[11] = 0x00;

    /* need to do this because the poke commands donot send ack packet C0 */
    temp = (ubyte *)(COM_RAM); 
    *temp = 0x0c0;

    ack_or_response = 0;
    send_pkt_to_dsp();
}
    
/**********************************************************************
*
*    The following two routines were added by  so as to do conversation
*  record on the date plam board. The command to enter conversation record
*    is +VLS=17. THis command is valid only on the DATE-PALM board and also
*    only in speaker phone mode.
*
*    Conversation reocrd only works with the COM-Central software given by 
*    Packard Bell.
*
*    the algorithm for this is given by vishy canadam, as required by packard 
*    bell. 
*
*     9/16/96
*
*
*************************************************************************/

ubyte conv_rec_vls17(void)
{
    ubyte afe_choice,first_low_byte,first_high_byte;
    ubyte second_low_byte,second_high_byte;
    
    if((vls_cmd_value != 0) && (spkr_phn_mode != TRUE))
        return(TERMINATE_WITH_ERROR);
        
    conv_rec_going_on    = TRUE;
    
    afe_choice = AFE1;
    first_low_byte = 0xdc;    /* spk vol = med,spk_on = Tx */
    second_low_byte = 0x00;    /*  2/22/96 */ /* should be 0 */

    first_high_byte = 0x03;        
    
    if(!hook)
    {
        second_high_byte = 0x1a; /* turn only tx on */
    }
    else if(!dp_vce_local_phone_on_hook())
    {
       set_callerid_relay(CID_RELAY_ON);    
        
        second_high_byte = 0x2a; /* turn only rx on*/
    }
    else
       return(TERMINATE_WITH_ERROR);

   set_gpio_bit ((uword *) GPR_TNKL, GPIO_BIT_TNKL, ACTIVATE);

    LOAD_PACKET_MODEM_VCE_PGC_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();

    return(GOTO_ONLINE_COMMAND);
}

void exit_conv_rec_vls17(void)
{
    ubyte afe_choice,first_low_byte,first_high_byte;
    ubyte second_low_byte,second_high_byte;
   set_callerid_relay(CID_RELAY_OFF);    
        
      set_gpio_bit ((uword *) GPR_TNKL, GPIO_BIT_TNKL, DEACTIVATE);
    afe_choice = AFE1;
    first_low_byte = 0xdc;    /* spk vol = med,spk_on = Tx */
    second_low_byte = 0x00;    /*  2/22/96 */ /* should be 0 */

    first_high_byte = 0x03;        
    if(executing_spkr_phn == TRUE)
        second_high_byte = 0x12; 
    else
        second_high_byte = 0x3a; /* turn only rx on*/

    LOAD_PACKET_MODEM_VCE_PGC_INIT
    ack_or_response = FALSE;
    send_pkt_to_dsp();
    
    conv_rec_going_on    = FALSE;
}

/*
    this routine will exit the spkr phn mode and also will set the spkr
    setting in tune with the vls command. 
    this rouitne is used when we send dtmf tones in spkr phn mode, when
    we go to record or playback mode directly from spkr mode
*/

void after_exit_spkrphn_init_for_voice(void)
{
    end_spkr_phn_mode();        

    if(vls_cmd_value == 17)            /*  9/26/96 */
        exit_conv_rec_vls17();

    if((vls_cmd_value == 4) || (vls_cmd_value == 5) || (vls_cmd_value == 7) ||
        (vls_cmd_value == 17))
    {
        spkr_phn_mode = FALSE; 
        dp_vce_speaker(ON,ON);
        spkr_phn_mode = TRUE; /*  9/24/96 */
    }
}

/*
    this function is called when we wake up from sleep and we are in voice
    mode .
    we need to dnld the correct patch in this case
*/

void    wakeup_from_sleep_in_voice(void)    /*  12/3/96 */
{
    if(spkr_phn_mode)        /*  9/10/96 */
    {
        spkr_phn_dnl = 1;    
        dnld_spkr_phn_code(dsp_code);     
        patch_re_dnlded = FALSE;    
    }
    else
    {
      dsppatch(COMMON_PATCH);  /* jlin, for dynamic patch 10/31/96 */
      dsppatch(VOICE_PATCH);
        LOAD_MODEM_INIT
        ack_or_response = ACK;
        send_pkt_to_dsp();
    
        dp_vce_compression_init(VOICE_IDLE, vce_comp_method[vce_comp_index].id,
                           vce_sampling_rate,vce_speaker_vol);
        patch_re_dnlded = TRUE;
      
        if((vls_cmd_value == 6) || (vls_cmd_value == 7))
            dp_vce_microphone(ON,ON);

        if((vls_cmd_value == 4) || (vls_cmd_value == 5) || (vls_cmd_value == 7))
        {
           dp_vce_speaker(OFF,OFF);
              wait_a_while();
           dp_vce_speaker(ON,ON);
              wait_a_while();
        }
    }
}





