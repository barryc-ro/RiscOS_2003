/*****************************************************************************
/
/        Copyright 1994,1995.
/        All Rights Reserved by:
/	 RSA
/	 7701 Six Forks Road
/	 Suite 120
/	 Raleigh, NC  27615
/	 (919) 846-7171
/
/
/   This document contains material confidential to RSA its contents must
/   not be revealed, used or disclosed to anyone or company with out
/   written permission by RSA.	The information contained herein is solely
/   for the use of RSA.
/
/   File:	vc00ex.c
/
/   Version:	1.00
/
/   Function:	This file contains the code to execute the voice commands
/               as specified in the tia 101 document.
/
/   Product  : Voice Core Code
/
/   History:
/
/   Created: 1/14/93
/
/	---------------------------------------------------------
/	-	     Modifications	      -
/	---------------------------------------------------------
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*****************************************************************************/
#include "sys_def.h"
#include "vce_def.h"
#include "vce_mem.h"
#include "vce_cpro.h"
#include "func_mac.h"

#define UNUSED 0
#define E_IDLE  5

ubyte execute_voice_command(uword, ubyte *, ubyte **);
void voice_cmd_init(void);
void execute_VLS_query(ubyte *, ubyte *, ubyte **);
/* Start Change 7/28/1995. */
void execute_VLS_command(ubyte,ubyte,ubyte,ubyte,ubyte,ubyte,ubyte,ubyte);
/* End Change 7/28/1995. */

#define IDLE  0;
#define   CID_RELAY_OFF  0x0200 /* ramn 7/15/96 */

/*******************************************************************************
/
/   Routine:  execute_voice_command
/
/   Author : RSA
/
/   Creation Date: 8/24/93
/
/   Description : This routine will execute the voice commands as
/                 specified by the tia 101 document.  
/
/   Input Parameters: uword cmd - Command to be executed
/
/                           VBT_COMMAND     1       
/                           VBT_REQUEST     2       
/                           VBT_QUERY       3       
/                           VDR_REQUEST	    5      
/                           VDT_COMMAND	    6      
/                           VDT_REQUEST	    7      
/                           VEM_COMMAND     8      
/                           VEM_REQUEST     9      
/                           VEM_QUERY       10      
/                           VGR_COMMAND	    11      
/                           VGR_REQUEST	    12      
/                           VGT_COMMAND	    13      
/                           VGT_REQUEST	    14      
/                           VIP_COMMAND	    15      
/                           VIP_REQUEST	    16      
/                           VIT_COMMAND	    17      
/                           VIT_REQUEST	    18      
/                           VIT_QUERY	    19      
/                           VLS_COMMAND	    20      
/                           VLS_REQUEST	    21      
/                           VLS_QUERY	    22      
/                           VNH_COMMAND	    23      
/                           VNH_REQUEST	    24      
/                           VPP_COMMAND	    25      
/                           VPP_REQUEST	    26      
/                           VRA_COMMAND	    27      
/                           VRA_REQUEST	    28      
/                           VRN_COMMAND	    29      
/                           VRN_REQUEST	    30      
/                           VRX_COMMAND	    31      
/                           VSD_COMMAND	    32      
/                           VSD_REQUEST	    33      
/                           VSM_COMMAND	    34      
/                           VSM_REQUEST	    35      
/                           VSM_QUERY	    36      
/                           VTD_COMMAND	    37      
/                           VTD_REQUEST	    38      
/                           VTD_QUERY	    39      
/                           VTS_COMMAND	    40      
/                           VTS_QUERY  	    41      
/                           VTX_COMMAND	    42      
/                           VXT_COMMAND	    43      
/                           VXT_REQUEST	    44      
/                           VXT_QUERY  	    45      
/                                 
/                           FMR_REQUEST	    46      
/                           FMI_REQUEST	    47      
/                           FMM_REQUEST	    48      
/                                             
/                       ubyte *param_ptr - Pointer to the parameter passed in
/
/                      ubyte **msg_ptr
/                               Pointer to information string to be sent to the 
/                               terminal.
/
/   Output Parameters:  ubyte   function return code
/                           0       Go to online
/                           1       Continue parsing
/                           2       Discard rest of command line
/                                   and respond with ERROR message
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/
/       Author & Date: RSA 
/       Description: 
/       Reason:
/
/  Author & Date: RSA 5/18/1995.
/  Description: Completely updated the +VLS command execution.
/  Reason: The hook setting and the ONLINE_VOICE_COMMAND setting were incorrect.
/
*****************************************************************************/
/* debug */
ubyte execute_voice_command(uword cmd, ubyte *param_ptr, ubyte **msg_ptr)
{
	ubyte peek_value;
	struct vce_comp_struct *method_ptr;
   ubyte return_code,i,j,num,*ptr1, *ptr, found, tmp_byte, *info_ptr;
   uword f1,f2,d,k,*wrd_ptr, tmp_word;
   ulong tmp_long;
/* start change keh 2/15/95 => implement new parser for voice */
   uword *w_param_ptr;
/* start change keh 3/30/95 >> new parser */
   uword field,value;
/* end change keh 3/30/95 >> new parser */
/* end change keh 2/15/95 => implement new parser for voice */

   /* Return ERROR if not excecuting TIA command set */
   if (vce_cmd_set != TIA_IS_101)
       return (TERMINATE_WITH_ERROR);

   /* Load the address of vce_array in to the input pointer.  Any information
       that needs to be returned to the terminal should be placed into
       vce_array[].  */
   vce_array[0] = '\0';
   *msg_ptr = (ubyte *)&vce_array[0];
   info_ptr = (ubyte *)vce_array;

   return_code = CONTINUE_PARSING;

   switch (cmd)
   {
      case VBT_COMMAND:
/* start change keh 2/15/95 => implement new parser for voice */
#if 0		
			vce_cmd_ptr = param_ptr;
         vce_dte_XON_level = ((uword)vce_parse_a_to_d());
         if ((vce_dte_XON_level < 20) || (vce_dte_XON_level > 100))
             return (TERMINATE_WITH_ERROR);
         vce_cmd_ptr++;
         vce_dte_XOFF_level = ((uword)vce_parse_a_to_d());
         if ((vce_dte_XOFF_level < 150) || (vce_dte_XOFF_level > 180))
             return (TERMINATE_WITH_ERROR);
#endif
         /* Structure of AT command parameter array for compound byte
             values (f = field, p = parameter, 0 is end of array)
             [f,p,f,p,...0]
            Examples:
             AT+VBT=100,300  => [0x0001,0x0064, 0x0002,0x012C, 0x0000] 
             AT+VBT=,300     => [0x0002,0x012C, 0x0000]
             AT+VBT=         => [0x0000]
         */
         wrd_ptr = (uword *)param_ptr;  /* get Field */
         for (i=1; i <= 2; i++)
         {
         	field = *wrd_ptr++;     /* get Field */
            value = *wrd_ptr++;     /* get associated value */
            switch ((ubyte)field)
            {
                case 0:
                    /* End of Parameters */
                    i=3;
                    break;

                case 1:
                    /* Field #1 */
                    if (value != 192) /* ramn 2/20/96*/
								return (TERMINATE_WITH_ERROR);
                    else
                        vce_dte_XON_level = value;
                    break;

                case 2:
                    /* Field #2 */
                    if (value != 320)
                        return (TERMINATE_WITH_ERROR);
                    else
                        vce_dte_XOFF_level = value;
                    break;

                default:
                    return (TERMINATE_WITH_ERROR);
                    break;
            } /* switch */
         } /* for */
/* end change keh 2/15/95 => implement new parser for voice */
      break;

      case VBT_QUERY:
         vce_store_string_null((ubyte *)VBT_QUERY_INFO,info_ptr);
	   	/* output_info(info_ptr,VERBOSE_FORM);   */	/* ramn 10/10/95 */
      break;

		case vbt_request: 			/* ramn 10/10/95 */
	  		tmp_word = vce_dte_XON_level;
	  		ptr1 = (ubyte *)&vce_array[0];
		  /*	*ptr1++ = CR;
			*ptr1++ = LF; */ /* ramn 1/16/96 */
	  		vce_store_word_to_a(tmp_word, &ptr1);
	  		*ptr1++ = ',';
			tmp_word = vce_dte_XOFF_level;
			vce_store_word_to_a(tmp_word,&ptr1);
	  		*ptr1++ = '\0';
	  		/* output_info(info_ptr,VERBOSE_FORM); */
		break;

      case VEM_COMMAND:
/* stat change keh 2/15/95 => implement new parser for voice */
#if 0
          vce_cmd_ptr = param_ptr;
          tmp_long = vce_a_to_h_long();
          if (vce_long_error_occurred)
          {
              vce_long_error_occurred = FALSE;
              return (TERMINATE_WITH_ERROR);
          }
          else
          {
              vce_tx_events = tmp_long;
              vce_rx_events = tmp_long;
              vce_idl_events = tmp_long;
              /* vce_TIA_events = tmp_long;*/ /* ramn 2/13/96 */
          }
#endif
           tmp_long = *(ulong *)param_ptr;
           vce_tx_events = tmp_long;
           vce_rx_events = tmp_long;
           vce_idl_events = tmp_long;
           /* vce_TIA_events = tmp_long; */ /* ramn 2/13/96 */
/* endchange keh 2/15/95 => implement new parser for voice */
          break;

      case VEM_QUERY:
          ptr1 = (ubyte *)&vce_array[0];

      	 /* *ptr1++ = CR;
          *ptr1++ = LF; */ /* ramn 1/16/96 */
          *ptr1++ = QUOTE;
          *ptr1++ = SERVICE_LEVEL;
          *ptr1++ = QUOTE;
          *ptr1++ = CR;
          *ptr1++ = LF;

          method_ptr = &vce_comp_method[vce_comp_index];
          vce_store_hex_long_to_a(method_ptr->tx_mode_events,&ptr1);
          *ptr1++ = CR;
          *ptr1++ = LF;

          vce_store_hex_long_to_a(method_ptr->rx_mode_events,&ptr1);
          *ptr1++ = CR;
          *ptr1++ = LF;

          vce_store_hex_long_to_a(method_ptr->idl_mode_events,&ptr1);
          /* *ptr1++ = CR;
          *ptr1++ = LF; */ /* ramn 1/16/96 */
          *ptr1++ = '\0';
			 /* output_info(info_ptr,VERBOSE_FORM);	 */	/* ramn 10/10/95 */
      break;


		case vem_request:
         ptr1 = (ubyte *)&vce_array[0];

			if(vce_mode == TRANSMIT_MODE)
			{
				vce_store_hex_long_to_a(vce_tx_events,&ptr1);
				*ptr1++ = '\0';
			}
			else if(vce_mode == RECEIVE_MODE)
			{
				vce_store_hex_long_to_a(vce_rx_events,&ptr1);
				*ptr1++ = '\0';
			}
			else
			{
				vce_store_hex_long_to_a(vce_idl_events,&ptr1);
				*ptr1++ = '\0';
			}
		break;




      case VGR_COMMAND:
          num = *param_ptr;

#if 0
         if ( num == 0) 				/* added by ramn on 10/10/95 */
			{
				vce_receive_gain = num;	/* vgr = 0 means agc */
			}
			else
			{
	          /*  Need to adjust the value entered to be in the
              range of the data pump.  */
         	 if ((num >= vce_rcv_gain_range[0]) &&
              (num <= vce_rcv_gain_range[1]))
          	 {
             	 vce_receive_gain = num;
          	 }
          	 else
          	 {
             	 return (TERMINATE_WITH_ERROR);
          	 }
			}
#endif /* ramn 2/29/96 */
		/* ramn removed the agc support */
	          /*  Need to adjust the value entered to be in the
              range of the data pump.  */
         	 if ((num >= vce_rcv_gain_range[0]) &&
              (num <= vce_rcv_gain_range[1]))
          	 {
             	 vce_receive_gain = num;
          	 }
          	 else
          	 {
             	 return (TERMINATE_WITH_ERROR);
          	 }
	
		break;

		case vgr_request:		/* vgr? */		/* added by ramn on 10/10/95 */
			vce_b_to_a_resp(vce_receive_gain);
			/* output_info(vce_array,VERBOSE_FORM); */
		break;

		case vgr_query:		/* vgr = ? */		/* added by ramn on 10/10/95 */
		   vce_store_string_null((ubyte *)vgr_query_info,info_ptr);
			/* output_info(info_ptr,VERBOSE_FORM); 	  */
		break;

      case VGT_COMMAND:
          num = *param_ptr;

#if 0
			if ( num == 0 )					/* added by ramn on 10/10/95 */
			{
				vce_transmit_volume = num;	/* vgt = 0 means AVC */
			}
			else
			{
	          if ((num >= vce_tx_vol_range[0]) &&
              (num <= vce_tx_vol_range[1]))
         	 {
             	 vce_transmit_volume = num;
         	 }
         	 else
         	 {
             	 return (TERMINATE_WITH_ERROR);
         	 }
			}
#endif /* ramn 2/29/96 */
		/* ramn rmoved the AGC support */
	          if ((num >= vce_tx_vol_range[0]) &&
              (num <= vce_tx_vol_range[1]))
         	 {
             	 vce_transmit_volume = num;
         	 }
         	 else
         	 {
             	 return (TERMINATE_WITH_ERROR);
         	 }
	
		break;

		case vgt_request:					/* added by ramn on 10/10/95 */
			vce_b_to_a_resp(vce_transmit_volume);
			/* output_info(vce_array,VERBOSE_FORM); */
		break;

		case vgt_query:				/* added by ramn on 10/10/95 */
			vce_store_string_null((ubyte*)vgt_query_info,info_ptr);
			/* output_info(info_ptr,VERBOSE_FORM); */
		break;

      case VIT_COMMAND:
          vce_inactivity_time = *param_ptr * 10;
          /*vce_inactivity_timer = vce_inactivity_time;*//* load timer only when needed ramn 1/16/96 */
			 vce_inactivity_timer_on = FALSE; /* ramn 1/16/96 */
      break;

      case VIT_QUERY:
          vce_store_string_null((ubyte *)VIT_QUERY_INFO,info_ptr);
      	 /* output_info(info_ptr,VERBOSE_FORM);  */	  /* ramn 10/10/95 */
	   break;

		case vit_request:				/* added by ramn on 10/10/95 */
			tmp_byte = (vce_inactivity_time/10);
			vce_b_to_a_resp(tmp_byte);
			/*output_info(vce_array,VERBOSE_FORM); */
		break;

		case VLS_COMMAND:
/* Stat Change 7/28/1995. */
          return_code = TERMINATE_WITH_ERROR;
			
/* 
	ramn 9/16/96 , 
	if any vls command issued during conv rec terminate conv rec
*/
			if((*param_ptr != 17) && (conv_rec_going_on == TRUE))
				exit_conv_rec_vls17();

          switch (*param_ptr)
          {
              case 0:
/*                  if (vce_io_devices & DEVICE_NONE)*/
                  {
                      /* PARAMS:  Return to idle?, Hook relay, local phone relay,
                                  internal microphone, external microphone
                                  internal speaker, external speaker, headset */
			  				 vce_mode_hangup(); /* ramn 2/27/96 */	
                      execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,OFF,OFF,OFF,OFF);
                      return_code = GOTO_OFFLINE_COMMAND;

							 modem_state = IDLE;
							 vce_mode = OFFLINE_COMMAND; /* ramn 2/24/96 */
				          voice_event_rept = vce_idl_events; /* ramn 2/24/96 */

                  }
                  break;

              case 1:
/*                  if ((vce_io_devices & DEVICE_T) && vce_mode == OFFLINE_COMMAND)*/
/*                  if (vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,DP,OFF,OFF,OFF,OFF,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
							 thru_line = TRUE;           
						  /*	if (spkr_phn_mode)
								tele_emul_enable(OFF);*/ /* ramn 7/8/96 */
						}
                  break;

              case 2:
/*                  if (vce_io_devices & DEVICE_L) */
/*           			if (vce_mode == OFFLINE_COMMAND)*/
				      {
                      execute_VLS_command(VOICE_IDLE,OFF,DP,OFF,OFF,OFF,OFF,OFF);
                      return_code = GOTO_ONLINE_COMMAND; 
							 vce_mode = ONLINE_COMMAND;
							 thru_phone = TRUE;
                  }
                  break;

#if 0
              case 3:
/*                  if ((vce_io_devices & DEVICE_LT) && vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,TELCO,OFF,OFF,OFF,OFF,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
                  }
                  break;
#endif /* no +VLS=3 for cirrus logic ramn 1/8/96 */

              case 4:
/*                  if (vce_io_devices & DEVICE_S)*/
                  {
                      execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,OFF,DP,OFF,OFF);
                      return_code = GOTO_OFFLINE_COMMAND;
                  }
                  break;

              case 5:
/*                  if ((vce_io_devices & DEVICE_ST) && vce_mode == OFFLINE_COMMAND)*/
/*                if (vce_mode == OFFLINE_COMMAND)*/
                {
                      execute_VLS_command(OFFLINE_COMMAND,ON,DP,OFF,OFF,DP,OFF,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
						/*if (spkr_phn_mode)
							tele_emul_enable(OFF); */ /* ramn 7/8/96 */
                  }
                  break;

              case 6:
/*                  if (vce_io_devices & DEVICE_M) */
                  {
                      execute_VLS_command(VOICE_IDLE,OFF,TELCO,DP,OFF,OFF,OFF,OFF);
                      return_code = GOTO_OFFLINE_COMMAND;
                  }
                  break;

              case 7:
/*                  if ((vce_io_devices & DEVICE_MST) && vce_mode == OFFLINE_COMMAND)*/
/*                  if (vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,DP,DP,OFF,DP,OFF,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
                  }
                  break;

#if 0
              case 8:
                  /*if (vce_io_devices & DEVICE_S1)*/
                  {
                      execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,OFF,OFF,DP,OFF);
                      return_code = GOTO_OFFLINE_COMMAND;
                  }
                  break;

              case 9:
                  /*if ((vce_io_devices & DEVICE_S1T) && vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,DP,OFF,OFF,OFF,
                                           DP,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
                  }
                  break;

              case 10:
                  /*if ((vce_io_devices & DEVICE_MS1T) && vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,TELCO,DP,OFF,
                                           OFF,DP,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
                  }
                  break;

              case 11:
                  /*if (vce_io_devices & DEVICE_M1) */
                  {
                      execute_VLS_command(VOICE_IDLE,OFF,TELCO,OFF,DP,OFF,OFF,OFF);
                      return_code = GOTO_OFFLINE_COMMAND;
                  }
                  break;

              case 12:
                  /*if ((vce_io_devices & DEVICE_M1ST) && vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,TELCO,OFF,DP,
                                           OFF,OFF,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
                  }
                  break;

              case 13:
                  /*if ((vce_io_devices & DEVICE_M1S1T) && vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,TELCO,OFF,DP,
                                           OFF,DP,OFF);
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
                  }
                  break;
#endif /* there are no +VLS=8-13 allowed for cirrus modems */

              case 14:
/*                  if (vce_io_devices & DEVICE_H)*/
                  {
                      execute_VLS_command(VOICE_IDLE,OFF,TELCO,DP,OFF,DP,OFF,ON);
                      return_code = GOTO_OFFLINE_COMMAND;
                  }
                  break;

              case 15:
/*                  if ((vce_io_devices & DEVICE_HT) && vce_mode == OFFLINE_COMMAND)*/
/*                  if (vce_mode == OFFLINE_COMMAND)*/
                  {
                      execute_VLS_command(OFFLINE_COMMAND,ON,DP,OFF,OFF,OFF,OFF,ON);            
                      vce_mode = ONLINE_COMMAND;
                      return_code = GOTO_ONLINE_COMMAND; 
                  }
                  break;
				  
				  case 16:
						return_code = GOTO_ONLINE_COMMAND;	
				  break;			

              case 17:		/* ramn 9/16/96 */
                      return_code = conv_rec_vls17(); 
              break;


              default:
                  return_code = TERMINATE_WITH_ERROR;
          }
			
			 if(return_code != TERMINATE_WITH_ERROR) /* 9/16/96 */
			 	vls_cmd_value = *param_ptr;

          /* Determine the action voice should take based upon the +VLS comand */
          if (return_code == GOTO_ONLINE_COMMAND)
          {
              vce_state = INIT_ONLINE_COMMAND;
          }
          else if (return_code == GOTO_OFFLINE_COMMAND)
          {
              vce_state = INIT_OFFLINE_COMMAND;
          }


			 if((tele_emul_value == 1) || (spkr_phn_mode == TRUE)) /* ramn 3/20/96 */
			 {
	         vce_mode = OFFLINE_COMMAND;
   	     	voice_event_rept = vce_idl_events;  
	   	   vce_state = VOICE_OFFLINE_COMMAND;

	       	/*dp_vce_set_level(VOICE_TRANSMIT,vce_transmit_volume);*/ /* ramn 3/20/96 */
				
	         if (return_code == GOTO_ONLINE_COMMAND)		/* ramn 5/13/96 */
				{
/* 
	ramn 7/8/96 
	only in vls =7 can you have spkr phn mode when vls =1 it is hold and when
	vls=5 it is mute 
*/
					if(vls_cmd_value == 7) 
						tele_emul_enable(ON);
					CTSon();
				}
          	else if (return_code == GOTO_OFFLINE_COMMAND)
          	{
						tele_emul_enable(OFF);
				}
 	
			 }
          /* vce_line_select = *param_ptr;*/ /* ramn 2/13/96 */
	       break;

		case vls_request:				/* added by ramn on 1/12/96 */
			vce_b_to_a_resp(vls_cmd_value);
		break;

      case VLS_QUERY:

          ptr1 = (ubyte *)&vce_array[0];
         /*  *ptr1++ = CR;
          *ptr1++ = LF; */   /* ramn 1/16/96 */

          /*if (vce_io_devices & DEVICE_NONE)*/  /* ramn 2/20/96 */
              execute_VLS_query((ubyte *)"0",(ubyte *)DEV_NONE,&ptr1);

          /*if (vce_io_devices & DEVICE_T)*/
              execute_VLS_query((ubyte *)"1",(ubyte *)DEV_T,&ptr1);

          /*if (vce_io_devices & DEVICE_L)*/
              execute_VLS_query((ubyte *)"2",(ubyte *)DEV_L,&ptr1);

#if 0 /* ramn 9/12/96 */
          /*if (vce_io_devices & DEVICE_LT)*/
              execute_VLS_query((ubyte *)"3",(ubyte *)DEV_LT,&ptr1);
#endif

          /*if (vce_io_devices & DEVICE_S)*/
              execute_VLS_query((ubyte *)"4",(ubyte *)DEV_S,&ptr1);

          /*if (vce_io_devices & DEVICE_ST)*/
              execute_VLS_query((ubyte *)"5",(ubyte *)DEV_ST,&ptr1);

          /*if (vce_io_devices & DEVICE_M)*/
              execute_VLS_query((ubyte *)"6",(ubyte *)DEV_M,&ptr1);

          /*if (vce_io_devices & DEVICE_MST)*/
              execute_VLS_query((ubyte *)"7",(ubyte *)DEV_MST,&ptr1);

#if 0 /* ramn 9/12/96 */
          /*if (vce_io_devices & DEVICE_S1)*/
              execute_VLS_query((ubyte *)"8",(ubyte *)DEV_S1,&ptr1);

          /*if (vce_io_devices & DEVICE_S1T)*/
              execute_VLS_query((ubyte *)"9",(ubyte *)DEV_S1T,&ptr1);

          /*if (vce_io_devices & DEVICE_MS1T)*/
              execute_VLS_query((ubyte *)"10",(ubyte *)DEV_MS1T,&ptr1);

          /*if (vce_io_devices & DEVICE_M1)*/
              execute_VLS_query((ubyte *)"11",(ubyte *)DEV_M1,&ptr1);

          /*if (vce_io_devices & DEVICE_M1ST)*/
              execute_VLS_query((ubyte *)"12",(ubyte *)DEV_M1ST,&ptr1);

          /*if (vce_io_devices & DEVICE_M1S1T)*/
              execute_VLS_query((ubyte *)"13",(ubyte *)DEV_M1S1T,&ptr1);
#endif

          /*if (vce_io_devices & DEVICE_H)*/
              execute_VLS_query((ubyte *)"14",(ubyte *)DEV_H,&ptr1);

          /*if (vce_io_devices & DEVICE_HT)*/
              execute_VLS_query((ubyte *)"15",(ubyte *)DEV_HT,&ptr1);

          *ptr1++ = '\0';
          break;

 

       case VRA_COMMAND:
          vce_rb_away_time = *param_ptr;
      break;

/* stat change 3/27/95 keh => add cmds to voice */
      case VRA_REQUEST:
         vce_b_to_a_resp(vce_rb_away_time);
     		/*output_info(vce_array,VERBOSE_FORM);*/ /* added by ramn on 10/10/95 */
		break;
/* endchange 3/27/95 keh => add cmds to voice */

		case vra_query:			/* added by ramn on 10/10/95 */
			vce_store_string_null((ubyte*)vra_query_info,info_ptr);
			/* output_info(info_ptr,VERBOSE_FORM); */
		break;


      case VRN_COMMAND:
          vce_rb_never_time = (*param_ptr * 10);
      break;

	case VRN_REQUEST:				/* added by ramn on 10/10/95 */
		tmp_byte = vce_rb_never_time/10;
		vce_b_to_a_resp(tmp_byte);
		/* output_info(vce_array,VERBOSE_FORM); */
	break;

	case vrn_query:			/* added by ramn on 10/10/95 */
		vce_store_string_null((ubyte*)vrn_query_info,info_ptr);
		/* output_info(info_ptr,VERBOSE_FORM); */
	break;

#if 0			/* added by ramn on 10/10/95 */
/* stat change 3/27/95 keh => add cmds to voice */
      case VRN_REQUEST:
          vce_b_to_a_resp(vce_rb_never_time);
          break;
/* endchange 3/27/95 keh => add cmds to voice */
#endif

      case VRX_COMMAND:
          if ((vce_mode == ONLINE_COMMAND) || (thru_mic == TRUE))
          {
              return_code = GOTO_ONLINE;
				  tele_emul_value = 0; /* ramn 2/24/96 */	
				  if(spkr_phn_mode)			/* ramn 9/4/96 */
				  {	
						after_exit_spkrphn_init_for_voice();  /* ramn 10/1/96 */
						/*end_spkr_phn_mode();*/	/* ramn 10/1/96 */
					  	spkr_phn_mode = 0;		
				  }	
              vce_state = INIT_VOICE_RECEIVE;
              	/* dp_vce_dte_cts(OFF); */
					CTSoff(); /* changed by ramn 10/10/95 */
          
              /* Setup the return message for the ACU */
					  if(numeric_response)  /* 1/16/96 ramn */
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT,info_ptr);
						else
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT_NUM,info_ptr);
          }
          else
              return_code = TERMINATE_WITH_ERROR;
          break;

      case VSD_COMMAND:
/* stat change keh 2/15/95 => implement new parser for voice */
#if 0
          vce_cmd_ptr = param_ptr;
          tmp_byte = ((ubyte)vce_parse_a_to_d());

          /* Make sure that the value is within the limits of silence detection */
          if ((tmp_byte < MOST_SENS_SILENCE_DETC) ||
              (tmp_byte > LEAST_SENS_SILENCE_DETC))
              return (TERMINATE_WITH_ERROR);
          else
              vce_silence_detc_sen = tmp_byte;

          vce_cmd_ptr++;

          /* Set the silence detection interval */
          tmp_byte = ((ubyte)vce_parse_a_to_d());
          vce_silence_detc_interval = tmp_byte;
#endif
          /* For each possible parameter field of the command */
          for (i=1; i <= 2; i++)
          {
              switch (*param_ptr++)
              {
                  /* End of Parameter Buffer */
                  case 0:
                      return CONTINUE_PARSING;

                  case 1: /* SDS */
                      /* Make sure that the value is within the limits of
                          silence detection */
                     /* if ((*param_ptr < MOST_SENS_SILENCE_DETC) ||
                          (*param_ptr > LEAST_SENS_SILENCE_DETC))
                          return TERMINATE_WITH_ERROR;  */ /* ramn 10/10/95 */

                      /* Set silence detection */
                      if ((*param_ptr <= MOST_SENS_SILENCE_DETC) &&
                          (*param_ptr >= LEAST_SENS_SILENCE_DETC))
							 {
                      	vce_silence_detc_sen = *param_ptr++;
							 }
							 else
								return (TERMINATE_WITH_ERROR);
                      break;

                  case 2: /* SDI */ /* ramn 10/10/95 */
                      /* Set the silence detection interval */
							 if((*param_ptr <= MAX_SILENCE_INTERVAL) &&
								 (*param_ptr >= LEAST_SILENCE_INTERVAL))
							 {
                      	vce_silence_detc_interval = *param_ptr++;
							 }
							 else
								return(TERMINATE_WITH_ERROR);
                      break;

                  default: return TERMINATE_WITH_ERROR;
              }
          } /* for */
/* endchange keh 2/15/95 => implement new parser for voice */
      break;

		case vsd_query:			/* added by ramn on 10/10/95 */
			vce_store_string_null((ubyte*)vsd_query_info,info_ptr);
			/* output_info(info_ptr,VERBOSE_FORM); */
		break;

		case vsd_request:			/* added by ramn on 10/10/95 */
			ptr1 = (ubyte *)&vce_array[0];
			/* *ptr1++ = CR;
			*ptr1++ = LF; */ /* ramn 1/16/96 */
			num = vce_silence_detc_sen;
			vce_store_b_to_a(num,&ptr1);
			*ptr1++ = ',';
			num = vce_silence_detc_interval;
			vce_store_b_to_a(num,&ptr1);
			*ptr1= '\0';
			/* output_info(info_ptr,VERBOSE_FORM); */
		break;

      case VSM_COMMAND:
/* stat change keh 2/15/95 => implement new parser for voice */
#if 0
          vce_cmd_ptr = param_ptr;
          /* Determine the id number for the selected compression method.
              Validate the id. */
          tmp_byte = ((ubyte)vce_parse_a_to_d());
          found = FALSE;
          i = 0;
          while (!found && (i <= vce_num_of_methods-1))
          {
              method_ptr = &vce_comp_method[i];
              if (tmp_byte == (method_ptr->id))
                  found = TRUE;
              else
                  i++;
          }
          if (!found)
              return (TERMINATE_WITH_ERROR);
          else
              vce_comp_index = i;

          vce_comp_id = tmp_byte;
          vce_cmd_ptr++;

          /* Determine the number of sampling rate ranges for the selected
             compression method. Validate the selected rate. */
          tmp_word = vce_a_to_word();
          method_ptr = &vce_comp_method[vce_comp_index];
          num = (ubyte)*method_ptr->samp_range;

          /* Point to the first sampling rate */
          wrd_ptr = (uword *)&vce_comp_method[vce_comp_index].samp_range;
          wrd_ptr++;

          found = FALSE;
          while (num)
          {
              if (tmp_word == *wrd_ptr++)
              {
                  found = TRUE;
              }
              num--;
          }

          if (!found)
          {
              return (TERMINATE_WITH_ERROR);
          }
          vce_sampling_rate = tmp_word;
          vce_cmd_ptr++;

          /* Determine the silence sensitivity for the selected compression
              method. Validate the silence sensitivity. */
          tmp_byte = ((ubyte)vce_parse_a_to_d());
          method_ptr = &vce_comp_method[vce_comp_index];

          if (tmp_byte != (method_ptr->silence_sen))
              return (TERMINATE_WITH_ERROR);
          vce_silence_sen = tmp_byte;
          vce_cmd_ptr++;

          /* Determine the silence expansion for the selected compression
              method. Validate the silence expansion. */
          tmp_byte = ((ubyte)vce_parse_a_to_d());
          method_ptr = &vce_comp_method[vce_comp_index];

          if (tmp_byte != (method_ptr->silence_exp))
              return (TERMINATE_WITH_ERROR);
          vce_silence_exp = tmp_byte;
#endif

          w_param_ptr = (uword *)param_ptr;

          /* For each possible field in the +VSM= command */
          for (j=1; j <= 4; j++)
          {
              /* Which field in the parameter array? */
              switch (*w_param_ptr)
              {
                  case 0: /* End of Parameter Buffer */
                      return CONTINUE_PARSING;
                      break;

                  case 1: /* VSM_CML_FIELD: */

                      /* Skip Parameter Field to Parameter Value */
                      w_param_ptr++;

                      /* Determine the id number for the selected
                          compression method, and Validate the id. */
                      found = FALSE;
                      comp_byte = (ubyte)*w_param_ptr++;
								
							 switch(comp_byte) /* ramn 2/19/96 */
							 {
							 	case 0:
								case 128:
									tmp_byte = 0;
								break;

							 	case 1:
								case 129:
									tmp_byte = 1;
								break;

							 	case 2:
								case 132:
									tmp_byte = 2;
								break;

								default:
									tmp_byte = comp_byte;
								break;
							 }


                      for (i=0; i<=vce_num_of_methods-1;i++)
                      {
                          method_ptr = &vce_comp_method[i];
                          if (tmp_byte == (method_ptr->id))
                          {
                              found = TRUE;
                              vce_comp_index = i;
                              vce_comp_id = tmp_byte;
                              break;
                          }    
                      }
                      if (!found)
                          return (TERMINATE_WITH_ERROR);
                      break;

                  case 2: /* VSM_VSR_FIELD: */

                      /* Skip Parameter Field to Parameter Value */
                      w_param_ptr++;

                      /* Determine the number of sampling rate ranges
                          for the selected compression method. Validate the
                          selected rate. */

                      tmp_word = *w_param_ptr++;  /* Get parameter value */
                      method_ptr = &vce_comp_method[vce_comp_index];
                      num = (ubyte)*method_ptr->samp_range;

                      /* Point to the first sampling rate */
                      wrd_ptr = (uword *)&vce_comp_method[vce_comp_index].samp_range;
                      wrd_ptr++;
                      found = FALSE;
                      while (num)
                      {
                          if (tmp_word == *wrd_ptr++)
                          {
                              found = TRUE;
                          }
                          num--;
                      }

                      if (!found)
                          return (TERMINATE_WITH_ERROR);

                      vce_sampling_rate = tmp_word;
                      vce_cmd_ptr++;
                      break;

                  case 3: /* VSM_SCS_FIELD: */
                      /* Determine the silence sensitivity for the selected
                          compression method. Validate the silence sensitivity. */

                      /* Skip Parameter Field to get Parameter Value */
                      w_param_ptr++;
                      tmp_byte = (ubyte)*w_param_ptr++;
                      method_ptr = &vce_comp_method[vce_comp_index];

                      if (tmp_byte != (method_ptr->silence_sen))
                          return (TERMINATE_WITH_ERROR);
                      vce_silence_sen = tmp_byte;
                      break;

                  case 4: /* VSM_SEL_FIELD: */

                      /* Determine the silence expansion for the selected
                          compression method. Validate the silence expansion. */

                      /* Skip Parameter Field to get Parameter Value */
                      w_param_ptr++;
                      tmp_byte = (ubyte)*w_param_ptr++;
                      method_ptr = &vce_comp_method[vce_comp_index];
                  
                      if (tmp_byte != (method_ptr->silence_exp))
                          return (TERMINATE_WITH_ERROR);
                      vce_silence_exp = tmp_byte;
                      break;
              } /* switch field */
          } /* for */
/* endchange keh 2/15/95 => implement new parser for voice */
          break;

      case VSM_QUERY:
          ptr1 = (ubyte *)&vce_array[0];
          i = 0;

          /* *ptr1++ = CR;
          	 *ptr1++ = LF; */ /* added by ramn on 10/10/95 */

          method_ptr = &vce_comp_method[0];

          /* print the compression id value for all methods */
          while(i <= vce_num_of_methods-1)
          {
              j = TRUE;

             /* while(voice_dte_to_free() <= 50)
                  ; */		/* comment to be removed ramn  while doing actual implementation */

              vce_store_b_to_a((method_ptr->id),&ptr1);
              *ptr1++ = ',';
              *ptr1++ = QUOTE;
/***************************************************************************/
/* modified by ramn on 10/10/95 */

				/* commented by ramn on 10/10/95 */
            /*  vce_store_string((ubyte *)comp_msg[(method_ptr->id)-128],&ptr1); */
           
				switch(method_ptr->id)
				{
					case SIGNED_PCM:
						vce_store_string((ubyte *)signed_pcm_msg,&ptr1);
					break;
				
					case UNSIGNED_PCM:
						vce_store_string((ubyte *)u_pcm_msg,&ptr1);		
					break;

					case AD4_PCM:
						vce_store_string((ubyte *)ad4_pcm_msg,&ptr1);
					break;

					case SIGNED_PCM_2:
						vce_store_string((ubyte *)signed_pcm_2_msg,&ptr1);
					break;

					case UNSIGNED_PCM_2:
						vce_store_string((ubyte *)u_pcm_2_msg,&ptr1);
					break;

					case AD4_PCM_2:
						vce_store_string((ubyte *)ad4_pcm_2_msg,&ptr1);
					break;

					case CL1:
						vce_store_string((ubyte *)cl1_msg,&ptr1);
					break;

/*					case TRUE_SPEECH:
						vce_store_string((ubyte *)true_speech_msg,&ptr1);
					break;
*/ /* ramn 2/19/96*/  
	
					case AD3_PCM:
						vce_store_string((ubyte *)ad3_pcm_msg,&ptr1);
					break;
	
				}
/********** till here by ramn on 10/10/95 **********************************/	       
				  *ptr1++ = QUOTE;
              *ptr1++ = ',';

              /* report the bit/sample range for all methods */
              ptr = (ubyte *)&vce_comp_method[i].bps_range[0];
              num = *ptr++;
              while(num)
              {
                  if (!j)
                      *ptr1++ = ',';
                  vce_store_b_to_a(method_ptr->bps_range[num],&ptr1);
                  num--;
                  j = FALSE;
              }
              *ptr1++ = ',';

              /* report the timing marks for all methods */
              vce_store_b_to_a(method_ptr->timing_marks,&ptr1);
              *ptr1++ = ',';

              j = TRUE;
              *ptr1++ = '(';

              /* print the sampling range for all compression methods */
              num = (ubyte)*method_ptr->samp_range;

              wrd_ptr = (uword *)&vce_comp_method[i].samp_range;
              wrd_ptr++;
              while(num)
              {
                  if (!j)
                      *ptr1++ = ',';
                  vce_store_word_to_a(*wrd_ptr++,&ptr1);
                  num--;
                  j = FALSE;
              }
              *ptr1++ = ')';
              *ptr1++ = ',';
              *ptr1++ = '(';

              /* print the silence deletion range for
                  all compression methods */
              vce_store_b_to_a(method_ptr->silence_sen,&ptr1);
              *ptr1++ = ')';
              *ptr1++ = ',';
              *ptr1++ = '(';
              /* print the silence expansion range for
                  all compression methods */
              vce_store_b_to_a(method_ptr->silence_exp,&ptr1);
              *ptr1++ = ')';
              *ptr1++ = CR;
              *ptr1++ = LF;
              i++;
              method_ptr++;
          }
          *ptr1 = '\0';
			 /* output_info(info_ptr,VERBOSE_FORM); */ /* added by ramn on 10/10/95 */
      break;

		case vsm_request:			/* ramn 1/23/96 */
	  		ptr1 = (ubyte *)&vce_array[0];
			/* vce_store_b_to_a(vce_comp_method[vce_comp_index].id,&ptr1);*/
			vce_store_b_to_a(comp_byte,&ptr1); /* ramn 2/19/96 */

			*ptr1++ = ',';		
	  		vce_store_word_to_a(vce_sampling_rate, &ptr1);
	  		*ptr1++ = ',';
			vce_store_b_to_a(vce_silence_sen,&ptr1);
			*ptr1++ = ',';		
			vce_store_b_to_a(vce_silence_exp,&ptr1);
	  		*ptr1 = '\0';
		break;

      case VTD_COMMAND:
			if(*param_ptr >= 5)  /* ramn 4/5/96 */
			{
         	vce_beep_tone_time = *param_ptr;
			}
			else
				return(TERMINATE_WITH_ERROR);
      break;

      case VTD_QUERY:
          vce_store_string_null((ubyte *)VTD_QUERY_INFO,info_ptr);
  			 /*output_info(info_ptr,VERBOSE_FORM); */ /* added by ramn on 10/10/95 */
		break;

		case vtd_request:				/* added by ramn on 10/10/95 */
			vce_b_to_a_resp(vce_beep_tone_time);
			/* output_info(vce_array,VERBOSE_FORM); */
		break;

      case VTS_COMMAND:
          /* Command is only vaild in voice-online mode, and if a
              default tone time is set (+vtd) */

          /* if (vce_mode != ONLINE_COMMAND)	  
              return (TERMINATE_WITH_ERROR); */ /* added by ramn on 10/10/95 */

          if (!vce_beep_tone_time)
              return (CONTINUE_PARSING);

/* stat change keh 3/3/94 => modify voice for parser support */
          /* Input parameter is a word array for the +VTS command */
          wrd_ptr = (uword *)param_ptr;

          /*
              Compound DTMF parameters have the following form:
                     AT#VTS=,D1,{},{D2,T2},[],[F1,F2,T3]
              
              This parameter has the following field format in the Parse
              Parameter Buffer:
                    Buffer field #       AT Parmater
                   0 (DTMF_BUF_END)  -   END of Buffer
                   1 (DTMF_EMPTY)    -   ,   empty field   
                   2 (DTMF_DIGIT)    -   D1  DTMF digit    
                   3 (EMPTY_BRACES)  -   {}  empty braces  
                   4 (DTMF_BRACES)   -   D2  DTMF digit    
                   5 (TIME_BRACES)   -   T2  DTMF time     
                   6 (EMPTY_BRACKET) -   []  empty brackets
                   7 (FREQ1_BRACKET) -   F1  frequency1    
                   8 (FREQ2_BRACKET) -   F2  frequency2    
                   9 (TIME_BRACKET)  -   T3  freq. time    
                0xFF (PREMATURE_END) -   Premature end of mulit parameter
                                          field
                     
              Examples:
              AT+F=5,,{2,4}  => [0x2,0x5, 0x1, 0x4,0x02, 0x5,0x04, 0x00] 
              AT+F=[f1,f2,t] => [0x7,f1, 0x8,f2, 0x9,t, 0x00] 
              AT+F=0         => [0x2,0x0, 0x00]    
              AT+F=          => [0x00]
              AT+F=[f],{d}   => [0x7,f,0xFF, 0x4,d,0xFF, 0x00]
          */           

          /* While there's tone parameters to send... */
          while (*wrd_ptr)
          {
              /* Tones are reset every time for TIA */
              f1 = 0;
              f2 = 0;
              num = 0;
              d = vce_beep_tone_time * 10;   /* 100 msec units */

              field = *wrd_ptr++;
              value = *wrd_ptr++;

              /* Act based on parameter field header */
              switch ((ubyte)field)
              {
                  case DTMF_BUF_END:
                      return CONTINUE_PARSING;

                  case DTMF_EMPTY:
                      /* Empty DTMF (,,) is silence for the default time */
                      dp_vce_send_dtmf_tone(0,d);

                      /* Back the pointer up. this is only a one byte field */
                      wrd_ptr--;
                      break;

                  case DTMF_DIGIT:
                      num = (ubyte)value;
                      if (((num >= '0') && (num <= '9')) ||
                          ((num >= 'A') && (num <= 'D')) ||
                          (num == '*') || (num == '#') ||(num == '!')	/* ramn 6/28/96 */
								 )
           				 {
								if(num == '!')	  /* ramn 6/28/96 */	
								{
									d = 750;		/* if hook flash set time to 750 ms */
								   dp_vce_hook_relay(OFF);
									vce_send_tone_timer = d/10;
									while(vce_send_tone_timer)
									{
										process_wait();
									}	
								   dp_vce_hook_relay(ON);
								}
								else
								{
									d = 70;		/* else default to 70ms */
					          	dp_vce_send_dtmf_tone(num,d);
								}
							 }
                      else
                          return TERMINATE_WITH_ERROR;
                      break;

#if 0	/* ramn 3/18/96 */
                  case EMPTY_BRACES:
                      /* Empty braces ({}) is silence for the default time */
                      dp_vce_send_dtmf_tone(0,d);


                      /* Back the pointer up. this is only a one byte field */
                      wrd_ptr--;
                      break;
#endif

                  case DTMF_BRACES:
                      num = (ubyte)value; /* DTMF digit */
                      if (!(((num >= '0') && (num <= '9')) ||
                            ((num >= 'A') && (num <= 'D')) ||
                            (num == '*') || (num == '#') ||
									 (num == '!') 		/* ramn 6/28/96 */
									)
								 )
                          return TERMINATE_WITH_ERROR;

                      /* If next parameter is not Timed DTMF,
                          send DTMF w/ default time */
                      if (*wrd_ptr == TIME_BRACES)
                      {
                          field = *wrd_ptr++;
                          value = *wrd_ptr++;
                      }

                      /* Intentionally fallthrough */

                  case TIME_BRACES:
                      if (field == TIME_BRACES)
                      {
                          d = (ubyte)value;
                          
                          /* Verify bounds (time must be greater than zero) */
                          /*if (!d || (d > TIA_MAX_VBT_TIME))*/
									if (!d || (d > FREQ_GEN_MAX_TIME)
										  || (d < FREQ_GEN_MIN_TIME)) /* ramn 4/5/96 */
                              return TERMINATE_WITH_ERROR;
                          d *= 10;  /* make 100 msec units */

                          /* Set default DTMF for time-only parameters */
                          if (!num)
                              num = '*';
                      }
							 /* in send dtmf functions use time in msec
								 so there is no need to convert to 10ms scale */

							 if (num == '!')	/* ramn 6/28/96 */
							 {
								   dp_vce_hook_relay(OFF);
									vce_send_tone_timer = d/10;
									while(vce_send_tone_timer)
									{
										process_wait();
									}	
								   dp_vce_hook_relay(ON);
							 }
							 else
	                      dp_vce_send_dtmf_tone(num,d);
                      break;

                  case EMPTY_BRACES: /* ramn 3/18/96 */
                  case EMPTY_BRACKET:
                      /* Send NULL tone generate command to pump */
                      dp_vce_send_tone(0,0,d);

                      /* Back the pointer up. this is only a one byte field */
                      wrd_ptr--;
                      break;

                  case FREQ1_BRACKET:
                      /* Bounds check */
                      f1 = value;
                      if (!((f1 == 0) || ((f1 >= 200) && (f1 <= 3000))))
                          return TERMINATE_WITH_ERROR;
                      
                      if (*wrd_ptr == FREQ2_BRACKET)
                      {
                          field = *wrd_ptr++;
                          value = *wrd_ptr++;
                      }
                      
                      /* Intentionally fall through */

                  case FREQ2_BRACKET:
                      if (field == FREQ2_BRACKET)
                      {
                          f2 = value;
                          if (!((f2 == 0) || ((f2 >= 200) && (f2 <= 3000))))
                              return TERMINATE_WITH_ERROR;
                      }
                      
                      if (*wrd_ptr == TIME_BRACKET)
                      {
                          field = *wrd_ptr++;
                          value = *wrd_ptr++;
                      }
                      /* Intentionally fall through */

                  case TIME_BRACKET:
                      if (field == TIME_BRACKET)
                      {
                          /* Verify bounds (time must be greater than zero) */
                          d = value;
                          /*if (!d || (d > TIA_MAX_VBT_TIME))*/
									if (!d || (d > FREQ_GEN_MAX_TIME)
										  || (d < FREQ_GEN_MIN_TIME)) /* ramn 4/5/96 */
                              return TERMINATE_WITH_ERROR;

                          d *= 10; 
                      }

                      /* Send tone generate command to pump */
                      dp_vce_send_tone(f1,f2,d);
                      break;

                  case PREMATURE_END:
                      /* Back the pointer up. this is only a one byte field */
                      wrd_ptr--;
                      break;
              } /* switch */

          } /* while */

#if 0 /* original */
      case VTS _COMMAND:
          if (vce_mode != ONLINE_COMMAND)
              return (TERMINATE_WITH_ERROR);
          if (!vce_beep_tone_time)
              return (CONTINUE_PARSING);
          f1 = 0;
          f2 = 0;
          d = vce_beep_tone_time;

          /* Load the command string in to a voice global parameter */
          vce_cmd_ptr = param_ptr;

          while (*vce_cmd_ptr != '\0')
          {
              if (*vce_cmd_ptr == '[')
              {
                  /* If the first freq is not specified, need to use the most
                      recent setting of f1, or if not specified on this command
                      line then need to use 0. */
                  if (*++vce_cmd_ptr != ',')
                  {
                      /* Validate the first freq  */
                      tmp_long = vce_parse_a_to_d();
                      if ((tmp_long == 0) || ((tmp_long >= 200) && (tmp_long <= 3000)))
                      {
                          f1 = (uword)tmp_long;
                      }
                      else
                          return (TERMINATE_WITH_ERROR);
                  }

                  /* If the second freq is not specified, need to use the most
                      recent setting of f2, or if not specified on this command
                      line then need to use 0. */
                  if (*++vce_cmd_ptr != ',')
                  {
                      /* Validate the second freq  */
                      tmp_long = vce_parse_a_to_d();
                      if ((tmp_long == 0) || ((tmp_long >= 200) && (tmp_long <= 3000)))
                      {
                          f2 = (uword)tmp_long;
                      }
                      else
                          return (TERMINATE_WITH_ERROR);
                  }

                  /* If the duration of the tones is not specified, need to
                      use the most recent setting of d, or if not specified on this command
                      line then need to use the #VBT setting. */
                  if (*++vce_cmd_ptr != ']')
                  {
                      /* validate tone duration */
                      tmp_long = vce_parse_a_to_d();
                      if (tmp_long < 256)
                      {
                          d = (uword)tmp_long;
                      }
                      else
                          return (TERMINATE_WITH_ERROR);

                      /* See if the next char is the ending ']' */
                      if (*vce_cmd_ptr++ != ']')
                          return (TERMINATE_WITH_ERROR);
                  }
                  /* Increment pointer to the next entry */
                  if (*vce_cmd_ptr == ',')
                      vce_cmd_ptr++;
                  /* Convert duration to 10 msec */
                  dp_vce_send_tone(f1,f2,(d * 10));
              }
              else if (*vce_cmd_ptr == '{')
              {
                  /* If DTMF digit is not specified default to '*'    */
                  if (*++vce_cmd_ptr == ',')
                  {
                      i = '*';
                      vce_cmd_ptr++;
                  }
                  else
                  {
                      i = *vce_cmd_ptr++;
                      vce_cmd_ptr++;
                  }

                  /* If the duration is not specified then use setting of +VDT */
                  if (*vce_cmd_ptr == '}')
                  {
                      k = vce_beep_tone_time;
                      vce_cmd_ptr++;
                  }
                  else
                  {
                      /* validate tone duration */
                      tmp_long = vce_parse_a_to_d();
                      if (tmp_long < 256)
                      {
                          k = (uword)tmp_long;
                      }
                      else
                          return (TERMINATE_WITH_ERROR);
                      if (*vce_cmd_ptr++ != '}')
                          return (TERMINATE_WITH_ERROR);
                  }

                  /* NOTE: +VDT indicates that the inter-digit delay should be
                      s[11].  Need to check with Rockwell.
                  */
                  /* Convert duration to 10 msec */
                  dp_vce_send_dtmf_tone(i,(k * 10));
                  if (*vce_cmd_ptr == ',')
                      vce_cmd_ptr++;
              }
              else
              {
                  /* NOTE: +VTD indicates that the inter-digit delay should be
                      s[11].  Need to check with Rockwell.
                  */
                  /* Convert duration to 10 msec */
                  dp_vce_send_dtmf_tone(*vce_cmd_ptr++,(vce_beep_tone_time * 10));
                  if (*vce_cmd_ptr == ',')
                      vce_cmd_ptr++;
              }
          }
#endif
/* endchange keh 2/16/95 => implement new parser for voice */
          break;

      case VTS_QUERY:
          vce_store_string_null((ubyte *)VTS_QUERY_INFO,info_ptr);
			 /* output_info(info_ptr,VERBOSE_FORM); */  /* added by ramn on 10/10/95 */
      break;

      case VTX_COMMAND:
          if ((vce_mode == ONLINE_COMMAND) || (thru_spkr == TRUE))
          {
				  tele_emul_value = 0; /* ramn 2/24/96 */	

				  if(spkr_phn_mode)			/* ramn 9/4/96 */
				  {	
						after_exit_spkrphn_init_for_voice();  /* ramn 10/1/96 */
						/*end_spkr_phn_mode();*/	/* ramn 10/1/96 */
					  	spkr_phn_mode = 0;		
				  }	
              return_code = GOTO_ONLINE;
              vce_state = INIT_VOICE_TRANSMIT;
              	/* dp_vce_dte_cts(OFF); */
					CTSoff(); /* changed by ramn 10/10/95 */

              /* Setup the return message for the ACU */
					  if(numeric_response)  /* 1/16/96 ramn */
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT,info_ptr);
						else
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT_NUM,info_ptr);
	          }
          else
              return_code = TERMINATE_WITH_ERROR;
          break;

#if 0	/* ramn 8/19/96 */
      case VXT_COMMAND:
/* stat change keh 2/15/95 => implement new parser for voice */
#if 0
          vce_cmd_ptr = param_ptr;
          tmp_byte = ((ubyte)vce_parse_a_to_d());

          /* Make sure that the value is 0 or 1, only  */
          if (!tmp_byte)
              vce_translate_direction = VXT_FROM_INTCHG_FORMAT;
          else if (tmp_byte)
              vce_translate_direction = VXT_TO_INTCHG_FORMAT;
          else
              return (TERMINATE_WITH_ERROR);

          vce_cmd_ptr++;

          /* Set the bps capability for the translation */
          tmp_byte = ((ubyte)vce_parse_a_to_d());

          if ((tmp_byte == 8) || (tmp_byte == 12) ||
              (tmp_byte == 16))
              vce_translate_bps = tmp_byte;
          else
              return (TERMINATE_WITH_ERROR);

          if (vce_mode == ONLINE_COMMAND)
          {
              /* set up GSM to linear or linear to GSM translation */
              dp_vce_translate_voice(vce_translate_direction,
                                     vce_translate_bps);

              return_code = GOTO_ONLINE;
              vce_state = INIT_VOICE_TRANSLATE;
              	/* dp_vce_dte_cts(OFF); */
					CTSoff(); /* changed by ramn 10/10/95 */

              /* Setup the return message for the ACU */
					  if(numeric_response)  /* 1/16/96 ramn */
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT,info_ptr);
						else
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT_NUM,info_ptr);
	          }
          else
              return_code = TERMINATE_WITH_ERROR;

          param_ptr = vce_cmd_ptr;
#endif

          /* For each possible parameter field of the command */
          while (*param_ptr)
          {
              field = *param_ptr++;
              value = *param_ptr++;
              switch (field)
              {
                  case 0: /* End of parameters */
                      if (vce_mode == ONLINE_COMMAND)
                      {
                          /* set up GSM to linear or linear to GSM
                              translation */
                          dp_vce_translate_voice(vce_translate_direction,
                              vce_translate_bps);

                          return_code = GOTO_ONLINE;
                          vce_state = INIT_VOICE_TRANSLATE;
                          	/* dp_vce_dte_cts(OFF); */
									CTSoff(); /* changed by ramn 10/10/95 */

                          /* Setup the return message for the ACU */
					  if(numeric_response)  /* 1/16/96 ramn */
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT,info_ptr);
						else
	   	           vce_store_string_null((ubyte *)RESULT_CONNECT_NUM,info_ptr);
	                      }
                      else
                          return_code = TERMINATE_WITH_ERROR;
                      break;

                  case 1: /* CONV */
                      /* Make sure that the value is 0 or 1, only  */
                      if (!value)
                          vce_translate_direction = VXT_FROM_INTCHG_FORMAT;
                      else if (value == 1)
                          vce_translate_direction = VXT_TO_INTCHG_FORMAT;
                      else
                          return (TERMINATE_WITH_ERROR);
                      break;

                  case 2: /* BPS */
                      /* Set the bps capability for the translation */
                      if ((value == 8) || (value == 12) || (value == 16))
                          vce_translate_bps = (ubyte)value;
                      else
                          return (TERMINATE_WITH_ERROR);
                      break;

                  default:
                      return TERMINATE_WITH_ERROR;
              }
          } /* for */
/* endchange keh 2/15/95 => implement new parser for voice */
          break;

      case VXT_QUERY:
          vce_store_string_null((ubyte *)VXT_QUERY_INFO,info_ptr);
          break;
#endif

		case TELE_EMUL_COMMAND :		/* ramn 2/23/96 */

			if((*param_ptr == 1) || (*param_ptr == 2))
			{			
				if(vsps_comm_value == 0)
				{
					tele_emul_value = *param_ptr;
					if(spkr_phn_mode)
						end_spkr_phn_mode();
					spkr_phn_mode = FALSE;
				}
				else
				{
					spkr_phn_mode = TRUE;
					tele_emul_value = 0;
					if(*param_ptr != 2)
					{
					  	if(!was_in_spkr_phn_mode)	/* ramn 7/18/96 */
						{
							spkr_phn_dnl = 1;	/* ramn 4/22/96 */
						  	dnld_spkr_phn_code(dsp_code); 	/* ramn 4/22/96 */
							patch_re_dnlded = FALSE;	/* ramn 9/10/96 */
							/*patch_dnld_spkr_phn(dsp_code);*/

							spkr_phn_dnl = 0;	/* ramn 4/22/96 */
							was_in_spkr_phn_mode = TRUE;	/* ramn 6/25/96,cleared in ac00vc2.c*/
						}
						if((vls_cmd_value == 1) || (vls_cmd_value == 5) ||
							(vls_cmd_value == 7)
				 		  )
								tele_emul_enable(ON);		/* ramn 6/28/96 */
					}	
					else
					{
					  	vce_store_string_null((ubyte *)TELE_EMUL_MSG,info_ptr);
					   output_info(info_ptr,VERBOSE_FORM);   
					}
				}
			}
			else if(*param_ptr == 0)
			{
				/*if(spkr_phn_mode)
					end_spkr_phn_mode();*/

				if(vsps_comm_value == 0)
				{
					tele_emul_value = FALSE;
					vce_state = END_TELE_EMUL;
					spkr_phn_mode = FALSE;
				}
				else
				{
					/*vce_state = END_SPKR_PHN_MODE;*/
					vce_state = INIT_OFFLINE_COMMAND;
					vce_mode = OFFLINE_COMMAND;
					tele_emul_value = FALSE;
					end_spkr_phn_mode();
					spkr_phn_mode = FALSE;
				}
			}
			else
           return_code = TERMINATE_WITH_ERROR;

#if 0
			if((tele_emul_value) && (vce_mode != RECEIVE_MODE) && 
				(vce_mode != TRANSMIT_MODE))
			{

         }
			else if((!tele_emul_value) && (vce_mode != RECEIVE_MODE) && 
				(vce_mode != TRANSMIT_MODE))
			{
				vce_state = END_TELE_EMUL;
			}
         else
           return_code = TERMINATE_WITH_ERROR;
#endif

		break;

		case TELE_EMUL_REQS :
			vce_b_to_a_resp(tele_emul_value);
		break;


		break;

		case TELE_EMUL_QUERY	:
          vce_store_string_null((ubyte *)TELE_EMUL_QUERY_INFO,info_ptr);
		break;


/* ramn 2/29/96 */
		case vgm_query:
          vce_store_string_null((ubyte *)vgm_query_info,info_ptr);
		break;

		case vgm_command:
          num = *param_ptr;
#if 0/* ramn 6/28/96 */
      	if ((num >= SPK_PHN_MIC_RANG_LO) &&
          (num <= SPK_PHN_MIC_RANG_HI))
         {
         	 spk_phn_mic_level = num;
         }
         else
         {
         	 return (TERMINATE_WITH_ERROR);
         }

#endif
		/* ramn 6/28/96 */
      	if ((num >= SPK_PHN_MIC_RANG_LO) &&
          (num <= SPK_PHN_MIC_RANG_HI))
         {
         	 spk_phn_mic_level = num;
         }
 			else if (num < SPK_PHN_MIC_RANG_LO)
         	 spk_phn_mic_level = 121;
 			else if (num > SPK_PHN_MIC_RANG_HI)
         	 spk_phn_mic_level = 131;

		/* if in tele_emul mode reinitialize the tele emul mode */
		/* ramn 6/28/96, if in spkr_phn */
			if(tele_emul_value  && thru_mic) /* ramn 3/20/96 */
     			dp_vce_set_level(VOICE_TRANSMIT,spk_phn_mic_level);
			else if(executing_spkr_phn == TRUE) /* ramn 7/18/96 */
				set_spkr_phn_mic_vol();
		break;

		case vgm_request:
			vce_b_to_a_resp(spk_phn_mic_level);
		break;

		case vgs_query:
          vce_store_string_null((ubyte *)vgs_query_info,info_ptr);
		break;

		case vgs_command:
			num = *param_ptr;
			
#if 0		/* ramn 6/28/96 */
			if((num >= TELE_EMUL_SPK_LOW) && (num <= TELE_EMUL_SPK_MED))
				tele_emul_spk_level = LOW;
			else if((num > TELE_EMUL_SPK_MED) && (num <= TELE_EMUL_SPK_HIGH))
				tele_emul_spk_level = MEDIUM;
			else if((num > TELE_EMUL_SPK_HIGH) && (num <= TELE_EMUL_SPK_MAX))
				tele_emul_spk_level = HIGH;
			else
				return(TERMINATE_WITH_ERROR);
#endif

			if(num <= TELE_EMUL_SPK_MED)		/* ramn 6/28/96 */
				tele_emul_spk_level = LOW;
			else if((num > TELE_EMUL_SPK_MED) && (num <= TELE_EMUL_SPK_HIGH))
				tele_emul_spk_level = MEDIUM;
			else if(num > TELE_EMUL_SPK_HIGH) 
				tele_emul_spk_level = HIGH;
	
			vgs_comm_value = num;			

		/* ramn 6/28/96, if in spkr_phn mode donot do vol control now */
			if(tele_emul_value  && thru_spkr) /* ramn 3/20/96 */
			{
#if 0
				dp_vce_set_speaker(ON);		/* turn spk on then set voulme */
				dp_vce_set_volume(tele_emul_spk_level);
#endif
				dp_set_speaker(AFE1,tele_emul_spk_level); 
			}
			else if(executing_spkr_phn == TRUE) /* ramn 7/18/96 */
			{
			  	set_spkr_phn_spkr_vol();


#if 0
				/* adjust for values outside the range 121 to 131 */
				if(vgs_comm_value <= 121)
					vgs_comm_value = 122;
				else if(vgs_comm_value >= 131)
					vgs_comm_value = 131;
			
				/* for dsp if vol = 131 then send 0 ; if vol 122 or lower send 9 */
				num = 131 - vgs_comm_value;		

				if(spk_phn_mic_level == 121)
					spk_phn_mic_level = 122;
				peek_value = 0;

				peek_value = num;
				num = (131 - spk_phn_mic_level);
				peek_value = (peek_value | (num << 4));

				current_command[0] = 0xe;		/* speaker phone control packet */
				current_command[1] = 0x00;
				current_command[2] = 0x04;
				current_command[3] = 0x00;
				current_command[4] = 0x0b;
				current_command[5] = 0x0;
				current_command[6] = 0x0;
				current_command[7] = 0x0;
				current_command[11] = 0x00;

				/* need to do this because the poke commands donot send ack packet C0 */
				temp = (ubyte *)(COM_RAM); 
				*temp = 0x0c0;
			
				ack_or_response = 0;
				send_pkt_to_dsp();
#endif
			}


	break;

		case vgs_request:
			vce_b_to_a_resp(vgs_comm_value);
		break;
/* till here ramn 2/29/96 */


/* from here by ramn on 3/19/96 */

		case vsps_query:
          vce_store_string_null((ubyte *)vsps_query_info,info_ptr);
		break;

		case vsps_command:
			if((*param_ptr == 0) || (*param_ptr == 1))
				vsps_comm_value = *param_ptr;
			else
				return(TERMINATE_WITH_ERROR);
		break;

		case vsps_request:
			vce_b_to_a_resp(vsps_comm_value);
		break;


/*  till here by ramn on 3/19/96 */




      default: return_code = TERMINATE_WITH_ERROR;
          break;
   }
   return (return_code);
}

/*******************************************************************************
/
/   Routine:  execute_VLS_query
/
/   Author : RSA
/
/   Creation Date: 9/21/1993
/
/   Description : This routine will execute the +vls=? voice command query as
/                 specified by the tia 101 document.  
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*****************************************************************************/
/* Start Change 7/28/1995. */
void execute_VLS_query(ubyte *num, ubyte *str, ubyte **p1)
{
    struct vce_comp_struct *method_ptr;

    method_ptr = &vce_comp_method[vce_comp_index];

    /*  Print the device number, comma and the initial double quote */
    while (*num)
      *(*p1)++ = *num++;
    *(*p1)++ = ',';
    *(*p1)++ = QUOTE;
/* End Change 7/28/1995. */

    /*  Print the variable length string of the device */
    while (*str)
        *(*p1)++ = *str++;

    *(*p1)++ = QUOTE;
    *(*p1)++ = ',';

    /*  Print the 3 (tx,rx, and idle) masks that are used in the query */
    vce_store_hex_long_to_a(method_ptr->tx_mode_events,p1);
    *(*p1)++ = ',';
    vce_store_hex_long_to_a(method_ptr->rx_mode_events,p1);
    *(*p1)++ = ',';
    vce_store_hex_long_to_a(method_ptr->idl_mode_events,p1);
    *(*p1)++ = CR;
    *(*p1)++ = LF;
}

/*******************************************************************************
/
/   Routine:  execute_VLS_command
/
/   Author : RSA
/
/   Creation Date: 7/28/1995.
/
/   Description :  This routine completes all the routine calls for the
/                  +VLS and #VLS commands to function properly.
/
/   Input Parameters: ubyte mode, ubyte hook_relay, ubyte phone_relay,
/                     ubyte microphone, ubyte int_spkr, ubyte ext_spkr
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*****************************************************************************/
/* Start Change 7/28/1995. */
void execute_VLS_command(ubyte mode, ubyte hook_relay, ubyte phone_relay,
ubyte int_micr,ubyte ext_micr, ubyte int_spkr, ubyte ext_spkr, ubyte headset)
{
   ubyte temp_ext_spk;

   temp_ext_spk = ext_spkr;

/*   if (mode == VOICE_IDLE)
      dp_vce_return_to_idle();
*/ /* ramn 2/22/96 */


	if(hook_relay) 	/* ramn 3/11/96 */
		hook = FALSE;
	else
		hook = TRUE;



/*
	ramn 7/9/96 if caller id enabled and we are going off-hook after 1 ring
	disable caller id 
*/

/* was *srptr == 1 ramn 9/11/96 */
	if((voice_caller_id != 0) && (*srptr[1] >= 1) && (hook_relay == ON)) 
	{
		voice_caller_id = 0;
	}

	if(conv_rec_going_on == FALSE)
	   set_callerid_relay( CID_RELAY_OFF);	/* ramn 12/16/96 */


   dp_vce_hook_relay(hook_relay);

	debounce_timer = 0;   			/* ramn 9/26/96 */
	relay_off_hook_flag = FALSE;
	relay_on_hook_flag = FALSE;


   dp_vce_phone_relay(phone_relay);

   dp_vce_microphone(int_micr,ext_micr);
   dp_vce_speaker(int_spkr,ext_spkr);

/* jay */
   dp_vce_headset(headset); 
}
/* End Change 7/28/1995. */

/*******************************************************************************
/
/   Routine:  voice_cmd_init
/
/   Author : RSA
/
/   Creation Date: 8/24/93
/
/   Description : This routine will initialize the voice command variables as
/                 specified by the tia 101 document.  
/
/   Input Parameters: None
/
/   Output Parameters: None
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -			Modifications			    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*****************************************************************************/
void voice_cmd_init(void)
{
    /* Determine the value based upon the default compression method */
    vce_cmd_set = TIA_IS_101;
/*    vce_vbs_value = (vce_comp_index * 17) + vce_bits_per_sample; */ /* ramn 2/13/96 */
/*    vce_silence_del_control = 0; */ /* ramn 2/13/96 */
/*    vce_buffer_skid = 255; */ /* ramn 2/13/96 */
/*    vce_vss_value = 2; */ /* ramn 2/13/96 */

    vce_silence_detc_interval = 50;	 /* was 550 changed by ramn 10/10/95 */
    vce_silence_detc_sen = 128;
    vce_beep_tone_time = 100;
    vce_rb_away_time = 50;
    vce_rb_never_time = 100;

	 vgs_comm_value = 128;		/* ramn 2/29/96 */
    spk_phn_mic_level = 128;
	 tele_emul_spk_level = 2;
	 vsps_comm_value = 1;		/* ramn 3/20/96 */	

}


