/****************************************************************************
/
/     Copyright 1996.
/     All Rights Reserved by:
/     RSA                                           
/     110 Horizon Drive
/     Raleigh, NC  27615
/     (919) 846-7171
/
/
/  This document contains material confidential to RSA its contents must
/  not be revealed, used or disclosed to anyone or company with out
/  written permission by RSA.  The information contained herein is solely
/  for the use of RSA.
/
/  File:             v80_mn.c
/
/  Module Version:   1.00
/
/  Function:         This file contains the control code for V.80
/
/
/  Product:          Core 4.3
/
/
/  History:
/
/  Created:          07/31/1996
/
/      ---------------------------------------------------------
/      -         Modifications         -
/      ---------------------------------------------------------
/
/      Author & Date:   RSA  
/      Description:   
/      Reason: 
/
*****************************************************************************/

extern void acu_v80_hangup(void);
extern void system_rcv_escape(void);


#include "v80_def.h"
#include "v80_pro.h"
#include "dce_line.edf"
#include "dte.edf"
#include "v80_mem.h"
#include "mt_def.h"

/* DEBUG ONLY - mlc */
ubyte V80_flag_detected = FALSE;
ubyte V80_first_frame = FALSE;
/* DEBUG ONLY - mlc */


/******************************************************************************
/
/   Routine: V80_configure
/
/   Author : RSA
/
/   Creation Date: 07/31/1996
/
/   Description : this routine provides an interface used by the ACU to 
/                input the +ESA parameters for V.80. V80 maintains the params
/                and provides them to the line upon detection of <EM> <MARK>
/                in the data stream.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed:
/
/   Users:
/
/   -------------------------------------------------------------
/   -                 Modifications             -
/   -------------------------------------------------------------
/
/   Author & Date:   RSA 
/   Description: 
/   Reason: 
/
******************************************************************************/

void V80_configure(ubyte trans_idle, ubyte framed_idle, ubyte framed_un_ov, \
    ubyte hd_auto, ubyte crc_type, ubyte nrzi_en, ubyte syn1, ubyte syn2)
{
    V80_trans_idle = trans_idle;
    V80_framed_idle = framed_idle;
    V80_framed_un_ov = framed_un_ov;
    V80_hd_auto = hd_auto;
    V80_crc_type = crc_type;
    V80_nrzi_en = nrzi_en;
    V80_syn1 = syn1;
    V80_syn2 = syn2;
    line_v80_configure(trans_idle, framed_idle, framed_un_ov, hd_auto, \
        crc_type, nrzi_en, syn1, syn2);

    dte_v80_configure(framed_un_ov);

}

/*******************************************************************************
/
/   Routine: V80_process_bg
/
/   Author : RSA
/
/   Creation Date: 07/31/1996
/
/   Description : this routine will perform the main background processing
/                for V.80. it is called by the master ACU tasking function.
/                this routine checks for in-band commands and control chars
/                in the data stream.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/    Global Variables Changed:
/
/    Users:
/
/    -------------------------------------------------------------
/    -            Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date:    RSA 
/    Description: 
/    Reason: 
/
*******************************************************************************/
void V80_process_bg(void)
{

   if (!V80_idle)
   { 
      V80_DTE_ch();
      V80_DCE_ch();
   }
}


/*******************************************************************************
/
/    Routine: V80_DTE_ch
/
/    Author : RSA
/
/    Creation Date: 07/31/1996
/
/    Description : process DTE char applying V80 requirements to data
/                
/
/    Input Parameters: none
/
/    Output Parameters: none
/
/    Global Variables Changed:
/
/    Users:
/
/    -------------------------------------------------------------
/    -            Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date:    RSA
/    Description:
/    Reason:
/
*******************************************************************************/
void V80_DTE_ch(void)
{
   uword temp_word;

/* DEBUG ONLY - mlc */
    ubyte temp_array[3];
    extern void line_to_block(ubyte*,ubyte);
/* DEBUG ONLY - mlc */


   /*
    * while DTE has data for DCE and
    * DCE has room for this char
   */

   if (V80_flag_hunt == TRUE)
   {
      temp_word = line_get_flag_count();
      if ( temp_word != V80_flag_count )    /* flags received! */
      {
         line_hunt_complete();  /* inform line that flags have been detected */
         V80_flag_hunt = FALSE;
      }
      return;
   }

    /* for MARK, FLAG, or EOT, wait for DCE buffer to send everything */
    if ( V80_wait_DCE_empty )
    {
        if ( !line_to_num() )               /* if DCE buffer is empty */
        {
            V80_wait_DCE_empty = FALSE;     /* now process the command */
            switch (V80_ch)
            {
                case (EM_DTE_MARK):
                    V80_DTE_mark();
                    break;
                case (EM_DTE_FLAG):
                    V80_DTE_flag();
                    break;
                case (EM_DTE_EOT):
                    acu_v80_hangup();
                    break;
                case (EM_DTE_HUNT):
                    if (V80_sub_mode == FSM)
                    {
                        line_enter_hunt_mode();
                        line_from_clear();
                        dte_to_clear();
                        V80_flag_count = line_get_flag_count();
                        V80_flag_hunt = TRUE;
                    }
                    break;
                default:
                    /* big time error here */
                    break;
            }
        }

        /* exit now; do not transfer data */
        return;
    }

   while (dte_from_num() && ( line_to_free() > V80_MAX_DCE_XLATE_BUF ))
    {
        /* process each character from the DTE buffer */
        V80_ch = dte_from_char();

        /* if this char is EM and
        * previous char was not DM set flag
        */
        if (( EM == ( V80_ch & V80_7BIT_MASK )) && ( V80_rcvd_EM_DTE == FALSE ))
        {
            V80_rcvd_EM_DTE = TRUE;
        }
        else
        {

/* DEBUG ONLY - mlc */
            /* toggle flag back off */
            if (V80_flag_detected && V80_rcvd_EM_DTE && (V80_ch == EM_DTE_FLAG))
               V80_flag_detected = TRUE;
            else
               V80_flag_detected = FALSE;
/* DEBUG ONLY - mlc */

            /* last char was EM, check this char
             * for valid V80 command.
            */
            if ( V80_rcvd_EM_DTE == TRUE )
            {
                switch ( V80_ch )
                {
                   case (V80_CMD_IND_T1):
                        V80_dce_send_EM( V80_EM_19 );
                        break;
                    case (V80_CMD_IND_T2):
                        V80_dce_send_EM( V80_EM_99 );
                        break;
                    case (V80_CMD_IND_T3):
                        line_to_char(DC1);
                        break;
                    case (V80_CMD_IND_T4):
                        line_to_char(DC3);
                        break;
                    case (V80_CMD_IND_T5):
                        V80_dce_send_EM( V80_EM_19 );
                        V80_dce_send_EM( V80_EM_19 );
                        break;
                    case (V80_CMD_IND_T6):
                        V80_dce_send_EM ( V80_EM_99 );
                        V80_dce_send_EM ( V80_EM_99 );
                        break;
                    case (V80_CMD_IND_T7):
                        line_to_char(DC1);
                        line_to_char(DC1);
                        break;
                    case (V80_CMD_IND_T8):
                        line_to_char(DC3);
                        line_to_char(DC3);
                        break;
                    case (V80_CMD_IND_T9):
                        V80_dce_send_EM( V80_EM_19 );
                        V80_dce_send_EM( V80_EM_99 );
                        break;
                    case (V80_CMD_IND_T10):
                        V80_dce_send_EM( V80_EM_19 );
                        line_to_char(DC1);
                        break;
                    case (V80_CMD_IND_T11):
                        V80_dce_send_EM( V80_EM_19 );
                        line_to_char(DC3);
                        break;
                    case (V80_CMD_IND_T12):
                        V80_dce_send_EM( V80_EM_99 );
                        V80_dce_send_EM( V80_EM_19 );
                        break;
                    case (V80_CMD_IND_T13):
                        V80_dce_send_EM( V80_EM_99 );
                        line_to_char(DC1);
                        break;
                    case (V80_CMD_IND_T14):
                        V80_dce_send_EM( V80_EM_99 );
                        line_to_char(DC3);
                        break;
                    case (V80_CMD_IND_T15):
                        line_to_char(DC1);
                        V80_dce_send_EM( V80_EM_19 );
                        break;
                    case (V80_CMD_IND_T16):
                        line_to_char(DC1);
                        V80_dce_send_EM( V80_EM_99 );
                        break;
                    case (V80_CMD_IND_T17):
                        line_to_char(DC1);
                        line_to_char(DC3);
                        break;
                    case (V80_CMD_IND_T18):
                        line_to_char(DC3);
                        V80_dce_send_EM( V80_EM_19 );
                        break;
                    case (V80_CMD_IND_T19):
                        line_to_char(DC3);
                        V80_dce_send_EM( V80_EM_99 );
                        break;
                    case (V80_CMD_IND_T20):
                        line_to_char(DC3);
                        line_to_char(DC1);
                        break;

                    case (EM_DTE_MARK):             /* begin TSM, when DCE buf is empty */
                        V80_wait_DCE_empty = TRUE;
                        break;

                    case (EM_DTE_FLAG):
                        if (V80_sub_mode == TSM)
                        {
                           V80_wait_DCE_empty = TRUE;
                        }
                        else
                        {
                           /* insert the FLAG into user data */
                           V80_DTE_flag();
                        }
                        break;

                    case (EM_DTE_ERR):              /* send abort */
                        if ( V80_sub_mode == FSM )
                        {
/* DEBUG ONLY - mlc */
#if 0
                            line_to_char(EM);
                            line_to_char(ABORT);
#endif
                            temp_array[0] = EM;
                            temp_array[1] = ABORT;
                            line_to_block(&temp_array[0],2);
/* DEBUG ONLY - mlc */
                        }
                        break;
                    case (EM_DTE_HUNT):             /* enter hunt mode */

                        V80_wait_DCE_empty = TRUE;
                        break;

                    case (EM_DTE_RESUME):     /*  should never see this */
                        line_tx_resume();
                        break;


                    case (EM_DTE_EOT):        /* hang up when DCE buf is empty */
                        V80_wait_DCE_empty = TRUE;
                        break;

                    case (EM_DTE_ECS):        /* goto online cmd state */
                        V80_idle = TRUE;      /* stop v80 cmd processing */
                        system_rcv_escape();
                        break;

                    case (EM_DTE_RRN):        /* req. rate reneg */
                        modem_renegotiate();
                        break;

                    case (EM_DTE_RTN):        /* req. retrain */
                        modem_retrain();
                        break;

                    case (EM_DTE_RATE):       /* set max tx, rx rate */
                        V80_inband_rate_chg = TRUE;
                        V80_rate = 0;
                        break;

                    /*
                     * unsupported half duplex V34 commands
                    */

                    case (EM_DTE_CTL):        /* go to ctl chan not supported */
                    case (EM_DTE_RTNC):       /* ctl chan retrain unsupported */
                        break;

                    default:                  /* not a valid cmd */

/* DEBUG ONLY - mlc */
#if 0
                        line_to_char(EM);     /* send the EM rcvd previously */
                        line_to_char(V80_ch); /* send this char */
#endif
                        temp_array[0] = EM;
                        temp_array[1] = V80_ch;
                        line_to_block(&temp_array[0],2);
/* DEBUG ONLY - mlc */
                        break;
                }
                   V80_rcvd_EM_DTE = FALSE;
            }
            else                                   
            {
                if ( V80_inband_rate_chg )    /* this ch is max tx or rx rate */
                {
                    if ( V80_rate == 0 )      /*  tx / rx rate data now avail.*/
                        V80_rate = V80_ch;

                    else
                    {
                        /* take the lowest of max rates for tx and rx */
                        if ( V80_rate > V80_ch )
                            V80_rate = V80_ch;

                        V80_inband_rate_chg = FALSE;
                        V80_rate &= V80_RATE_MASK;
                        modem_set_rate_seq( ( 1 << V80_rate ) - 1, FALSE);
                    }
                }
                else                          /* not an <EM> or cmd or rate */
                    line_to_char(V80_ch);
            }
        }

    }
}


/*******************************************************************************
/
/	Routine: V80_DCE_ch
/
/    Author : RSA
/
/    Creation Date: 07/31/1996
/
/    Description : process DTE char applying V80 requirements to data
/                
/
/    Input Parameters: none
/
/    Output Parameters: none
/
/    Global Variables Changed:
/
/    Users:
/
/    -------------------------------------------------------------
/    -            Modifications                -
/    -------------------------------------------------------------
/
/    Author & Date:    RSA 
/    Description: 
/    Reason: 
/
*******************************************************************************/
void V80_DCE_ch(void)
{
   ubyte ch;

   /* if retrain or renegotiation detected,
    * send EM and indication
   */

   if ((V80_new_rate_data_valid != FALSE) && \
        (dte_to_free() > V80_RATE_DATA_SPACE_REQD))
   {
      dte_to_char(EM);

      if (V80_new_rate_data_valid == RETRAINING)
         dte_to_char(EM_DTE_RTN);
      else
         dte_to_char(EM_DTE_RRN);

      dte_to_char(V80_tx_rate);
      dte_to_char(V80_rx_rate);
      V80_new_rate_data_valid = FALSE;
   }

    while (line_from_num() && (dte_to_free() > V80_MAX_DTE_XLATE_BUF) \
        && !V80_idle)
    {
        /* process each character from the DCE buffer */
        ch = line_from_char();

        /* if this char is EM and
         * previous char was not DM set flag
        */

/* START CHANGE - 09/13/96 - mlc */
        dte_to_char(ch);
#if 0
        if (( EM == ( ch  & V80_7BIT_MASK )) && ( FALSE == V80_rcvd_EM_DCE ))
            V80_rcvd_EM_DCE = TRUE;
        else
        {
            /* If last char was EM, check this
             * char for valid V80 command.
            */
            if ( TRUE == V80_rcvd_EM_DCE )
            {
                switch ( ch )
                {
                    case (V80_CMD_IND_T1):
                        V80_dte_send_EM( V80_EM_19 );
                        break;
                    case (V80_CMD_IND_T2):
                        V80_dte_send_EM( V80_EM_99 );
                        break;
                    case (V80_CMD_IND_T3):
                        dte_to_char(DC1);
                        break;
                    case (V80_CMD_IND_T4):
                        dte_to_char(DC3);
                        break;
                    default:
                        /*
                         * command was not valid so don't translate
                        */

                        /* send EM char */
                        /* send ch */
                        dte_to_char(EM);
                        dte_to_char(ch);
                        break;
                 }
                 V80_rcvd_EM_DCE = FALSE;
            }
            else                      /* normal char handling */
                dte_to_char(ch);
        }
#endif
/* END CHANGE - 09/13/96 - mlc */

    }
}



/*******************************************************************************
/
/    Routine: V80_init
/
/	Author : RSA
/
/	Creation Date: 07/31/1996
/
/	Description : entry point used by the ACU module to initialize the V.80 
/                
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description:
/	Reason: 
/
*******************************************************************************/
void V80_init(void)
{

    V80_sub_mode = TSM;
    V80_inband_detc = TRUE;
    V80_rcvd_EM_DTE = FALSE;
    V80_rcvd_EM_DCE = FALSE;
    V80_tx_rate = 0;
    V80_rx_rate = 0;
    V80_new_rate_data_valid = FALSE;

    V80_flag_hunt = 0;
    V80_flag_count = 0;

    /* set to idle, let v80_resume() call enable */
    V80_idle = TRUE; /* on training V8 uses this buffer, ACU will enable us */

    V80_modem_status = 0;

    line_from_clear();  /* ensure V8 data is expunged */

}


/*******************************************************************************
/
/	Routine: V80_modem_state_ind
/
/	Author : RSA
/
/	Creation Date: 07/31/1996
/
/	Description : interface routine used by Modem Task
/                    to provide retrain info
/                
/
/	Input Parameters: type
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void V80_modem_state_ind(ubyte type, ubyte tx, ubyte rx)
{

   switch (type)
   {
      case CONNECTED:

         /* if the DSP is currently retraining */
         if (V80_modem_status == RETRAINING)
         {
            V80_modem_status = CONNECTED;
            V80_new_rate_data_valid = RETRAINING;
         }
         /* if the DSP is currently renegotiating */
         else if (V80_modem_status == RENEGOTIATING)
         {
            V80_modem_status = CONNECTED;
            V80_new_rate_data_valid = RENEGOTIATING;
         }

         /* update the connected speed */
        if ( tx <= MT_BPS2400 )
        {
            V80_tx_rate = MT_BPS2400 + V80_XLATE_RATE1;
            V80_rx_rate = V80_tx_rate;
        }
        else if (tx <= MT_BPS19200 )
        {
            V80_tx_rate = tx + V80_XLATE_RATE1;
            V80_rx_rate = V80_tx_rate;
        }
        else
        {
            V80_tx_rate = tx + V80_XLATE_RATE2;
            V80_rx_rate = V80_tx_rate;
        }

        break;

      case IDLE:
         /* if the setting is not cleared after a cleardown */
         if (V80_new_rate_data_valid != FALSE)
            V80_new_rate_data_valid = FALSE;
         V80_modem_status = type;
         break;

      case RETRAINING:
      case RENEGOTIATING:
      default:
         V80_modem_status = type;
         break;
   }
}




/*******************************************************************************
/
/	Routine: V80_dte_send_EM
/
/	Author : RSA
/
/	Creation Date: 07/31/1996
/
/	Description : 
/                
/
/	Input Parameters: hi_bit_flag determines if 0x99 or 0x19 is DM char
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/   ASSUMES: room is available in destination
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description:
/	Reason: 
/
*******************************************************************************/
void V80_dte_send_EM( ubyte hi_bit_flag )
{
    if ( hi_bit_flag == V80_EM_99 )       /* send 0x99 as DM char */
	    dte_to_char(EM | HI_BIT);
    else
	    dte_to_char(EM);                  /* send 0x19 as DM char */

}



/*******************************************************************************
/
/	Routine: V80_dce_send_EM
/
/	Author : RSA
/
/	Creation Date: 07/31/1996
/
/	Description : 
/                
/
/	Input Parameters: hi_bit_flag determines if 0x99 or 0x19 is DM char
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/   ASSUMES: room is available in destination
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void V80_dce_send_EM( ubyte hi_bit_flag )
{
    if ( hi_bit_flag == V80_EM_99 )       /* send 0x99 as DM char */
	    line_to_char(EM | HI_BIT);
	else
	    line_to_char(EM);                 /* send 0x19 as DM char */

}


/*******************************************************************************
/
/	Routine: V80_conf_inband_detc
/
/	Author : RSA
/
/	Creation Date: 07/31/1996
/
/	Description : entry point used by ACU parser to enable and disable the
/                   processing if in-band commands when entering SAM using
/                   +ES= command.
/                
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void V80_conf_inband_detc(ubyte condition)
{
    if (condition == FALSE)
        V80_inband_detc = FALSE;
    else
        V80_inband_detc = TRUE;
    V80_init();
}


/*******************************************************************************
/
/	Routine: V80_idle_state
/
/	Author : RSA
/
/	Creation Date: 08/18/1996
/
/	Description : used to set the V.80 module to an idle state while
/                in online command mode
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void V80_resume(void)
{
   V80_idle = FALSE;
}


/*******************************************************************************
/
/	Routine: V80_DTE_mark
/
/	Author : RSA
/
/	Creation Date: 08/18/1996
/
/	Description : mark detected in data stream, DCE buffer is empty
/                in online command mode
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void V80_DTE_mark(void)
{
    if ( V80_sub_mode == FSM )
    {
        V80_sub_mode = TSM;
        line_enter_sub_mode(TSM);
        dte_set_sub_mode(TSM);
    }

}


/*******************************************************************************
/
/	Routine: V80_DTE_flag
/
/	Author : RSA
/
/	Creation Date: 08/18/1996
/
/	Description : flag detected in data stream, DCE buffer is empty
/                
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void V80_DTE_flag(void)
{
/* DEBUG ONLY - mlc */
    ubyte temp_array[3];
    extern void line_to_block(ubyte*,ubyte);
/* DEBUG ONLY - mlc */

    if (V80_sub_mode == TSM)
    {
        V80_sub_mode = FSM;
        line_enter_sub_mode(FSM);
        dte_set_sub_mode(FSM);
        V80_flag_count = line_get_flag_count();
        V80_flag_hunt = TRUE;
    }
    else
    {

/* DEBUG ONLY - mlc */
#if 0
      line_to_char(EM);
      line_to_char(FLAG);
#else
      /* discard back-to-back <EM><FLAG>s */
      if (V80_first_frame == FALSE)
      {
         /* discard the opening flag of the first frame */
         V80_first_frame = TRUE;
         V80_flag_detected = FALSE;
      }
      if (V80_flag_detected == FALSE)
      {

/* DEBUG ONLY - mlc */
#if 0
         line_to_char(EM);
         line_to_char(FLAG);
#endif
         temp_array[0] = EM;
         temp_array[1] = FLAG;
         line_to_block(&temp_array[0],2);
/* DEBUG ONLY - mlc */
      
         V80_flag_detected = TRUE;
      }
#endif
/* DEBUG ONLY - mlc */

    }

}


/*******************************************************************************
/
/	Routine: V80_rcv_escape
/
/	Author : RSA
/
/	Creation Date: 08/18/1996
/
/	Description : flag detected in data stream, DCE buffer is empty
/                
/
/	Input Parameters: none
/
/	Output Parameters: none
/
/	Global Variables Changed:
/
/	Users:
/
/	-------------------------------------------------------------
/	-			Modifications			    -
/	-------------------------------------------------------------
/
/	Author & Date:	RSA 
/	Description: 
/	Reason: 
/
*******************************************************************************/
void V80_rcv_escape(void)
{
}
