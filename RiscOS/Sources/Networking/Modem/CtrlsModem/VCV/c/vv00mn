/*****************************************************************************
/
/   Copyright, 1988,1989,1990,1991,1992,1993,1994, 1995.
/        All Rights Reserved by :
/     RSA
/     7701 Six Forks Road
/     Suite 201
/     Raleigh, NC  27615
/     (919) 846-7171
/
/   This document contains material confidential to RSA. Its contents
/   must not be revealed, used or disclosed to anyone or company without
/   written permission by RSA. The information contained herein is solely
/   for the use of RSA.
/
/   File     : vv00mn.c
/
/   Version  : 1.00
/
/   Function : Contains the core routines for the VoiceView module.
/
/   Product  :
/
/   History  :
/
/   Created  : 9/6/94
/
/   -----------------------------------------------------------
/   -                Modifications              -
/   -----------------------------------------------------------
/
/   Author & Date: 
/   Description:
/   Reason:
/
******************************************************************************/
#include "sys_def.h"
#include "vcv_def.h"
#include "vcv_mem.h"
#include "vcv_cpro.h"
#include "assert.h"
#include "tracemac.h"
#include "audio_if.h"

ubyte vcv_bg(ubyte **msg);
ubyte vcv_tx_startseq_state();
ubyte vcv_wait_ua_state();
ubyte vcv_starttone_state();
ubyte vcv_tx_capquery_state();
ubyte vcv_rx_capquery_state();
ubyte vcv_capresp_state(ubyte);
ubyte vcv_verify_startseq_state();

extern void vcv_line_init(ubyte, ubyte, uword);
extern void vcv_line_rx_block(ubyte *);
extern void vcv_line_tx_block(ubyte *);
extern void vcv_dte_reset(void);

extern void modem_terminate_link(void);
extern void vcv_line_reset(void);

extern ubyte acu_data_bits;
extern ubyte acu_parity;
extern ubyte acu_stop_bits;
extern void set_parms(ubyte, ubyte, ubyte);

#if defined(WeWantTrace)
  #include <stdio.h>
  #include <string.h>

  static ubyte TraceLevel = 0;
  static byte  *MyName = "vv00mn";
  static byte  tracebuf[80];
#endif

/* Uncomment this define for VoiceView state trace */
/*#define VOICEVIEWTRACE*/

extern uword vcv_tone_time;
extern ubyte vcv_tone_state;

/* RJM051196 */
ubyte rjm_vcv_state;
ubyte rjm_vcv_rx_state;
ubyte rjm_vcv_rx_window_state;
ubyte rjm_vcv_tx_state;
ubyte rjm_vcv_dle_state;
ubyte rjm_vcv_tx_rnr_state;

#if defined (VOICEVIEWTRACE)
extern void outchar(ubyte);
#endif

/*******************************************************************************
/
/   Routine: vcv_bg
/
/   Author: RSA
/
/   Creation Date: 9/6/94
/
/   Description: This routine will perform the VoiceView background processing.
/
/   Input Parameters: msg - pointer to return message.
/
/   Output Parameters: ubyte status - status of the VoiceView code
/
/   Global Variables Changed:  None
/
/   Users: (ACU)
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_bg(ubyte **msg)
{
   ubyte return_code,rc;
   AUDIO_CONTROL audiomsg;

   /* Set pointer initially to NULL */
   vcv_array[0] = '\0';
   *msg = (ubyte *)&vcv_array[0];

   /* Init return code to indicate that no change has taken place */
   return_code = VVBG_IGNORE;

#if defined (VOICEVIEWTRACE)
   if( rjm_vcv_state != vcv_state )
   {
      outchar( '[' );
      outchar( vcv_state );
      outchar( ']' );

      rjm_vcv_state = vcv_state;
   }

   if( rjm_vcv_rx_state != vcv_rx_state )
   {
      outchar( '{' );
      outchar( vcv_rx_state );
      outchar( '}' );

      rjm_vcv_rx_state = vcv_rx_state;
   }

   if( rjm_vcv_rx_window_state != vcv_rx_window_state )
   {
      outchar( '!' );
      outchar( vcv_rx_window_state );
      outchar( '!' );

      rjm_vcv_rx_window_state = vcv_rx_window_state;
   }
   if( rjm_vcv_tx_state != vcv_tx_state )
   {
      outchar( '(' );
      outchar( vcv_tx_state );
      outchar( ')' );

      rjm_vcv_tx_state = vcv_tx_state;
   }
   if( rjm_vcv_tx_rnr_state != vcv_tx_rnr_state )
   {
      outchar( '~' );
      outchar( vcv_tx_rnr_state );
      outchar( '~' );

      rjm_vcv_tx_rnr_state = vcv_tx_rnr_state;
   }

   if( rjm_vcv_dle_state != vcv_dle_state )
   {
      outchar( '^' );
      outchar( vcv_dle_state );
      outchar( '^' );

      rjm_vcv_dle_state = vcv_dle_state;
   }
#endif

   /* Poll to get current local telephone hookswitch state. */
   /* Act on the current state of VoiceView */
   switch (vcv_state)
   {
       case VV_INITIALIZE:
           rjm_vcv_state            = 0x99;
           rjm_vcv_rx_state         = 0x99;
           rjm_vcv_rx_window_state  = 0x99;
           rjm_vcv_tx_state         = 0x99;
           rjm_vcv_dle_state        = 0x99;
           rjm_vcv_tx_rnr_state     = 0x99;

           /* Put the Audio Path into Conversation mode */
           audiomsg.type = AUDIO_VOICE_VIEW;
           audiomsg.data = VV_AUDIO_CONVERSATION;
           audio_control( &audiomsg );

           modem_vcv_configure_tone_rx(STARTTONE);

            /* We should get here after the PARSE state got the FCLASS=80
             *
             * Initialize all timers. Set up the DP to detect Start Tone.
             *
             * Goto VV_CONVERSATION state.
             */

           vcv_head_index = 0;
           vcv_tail_index = 0;

           /* Initialize all state machines */
           vcv_ss_state=VCV_STARTTONE;
           vcv_cq_state=VCV_INITIALIZE;
           vcv_rx_cq_state=VCV_INITIALIZE;
           vcv_mi_state=VCV_INITIALIZE;
           vcv_st_state=VCV_INITIALIZE;
           vcv_wua_state=VCV_INITIALIZE;
           vcv_cr_state=VCV_INITIALIZE;
           vcv_ac_state=VCV_INITIALIZE;
           vcv_verify_ss_state=VCV_INITIALIZE;
           vcv_rx_state=INITIALIZE;
           vcv_tx_state=INITIALIZE;
           vcv_tx_rnr_state=INITIALIZE;
           vcv_rx_window_state=INITIALIZE;
           vcv_state=VV_CONVERSATION;

           vcv_time_critical=TRUE;
           vcv_accept_vcv_request=FALSE;
           vcv_switch_flag=FALSE;
           vcv_dle_state=DLE_NONE;

           vcv_tone_state=FALSE;
           vcv_tone_time=0;

           modem_terminate_link();
           vcv_line_reset();
           modem_config_vcv(RECEIVE_MODE, vcv_data_rate[BURST_RATE]);
           vcv_line_init(HDLC_MODE, RECEIVE_MODE, VV_HDLC_DATA_SIZE);
           vcv_line_rx_block((ubyte *)&vcv_buffer_array[vcv_head_index]);
           vcv_config_dte=FALSE;
           modem_vcv_configure_tone_rx(STARTTONE);
           break;

       case VV_CONVERSATION:
           check_tone_state ();

           if (vcv_tone_state==TRUE)
           {
               vcv_state=VV_VERIFY_STARTTONE;
           }
           break;

       case VV_VERIFY_STARTTONE:
           check_tone_state ();
           rc = vcv_verify_startseq_state();
       
           switch(rc)
           {
               case VCV_STAY:
                   /* Do nothing, state not complete */
                   break;

               case VCV_VOICEVIEW_MODE:
                   /* Start sequence detection ok'd */

                   /* Put the Audio Path into Data mode (play pleasing tone) */
                   audiomsg.type = AUDIO_VOICE_VIEW;
                   audiomsg.data = VV_AUDIO_DATA_MODE;
                   audio_control( &audiomsg );

                   *msg = (ubyte *)&RESULT_VOICEVIEW;
                   vcv_state=VV_RX_DATA; /*CONVERSATION; */
                   vcv_control_flag=0x02;
                   break;

               case VCV_MODEM_MODE:
                   /* Start sequence detection ok'd */
                   *msg = (ubyte *)&RESULT_MODEM;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION; */
                   break;

               case VCV_FAX_MODE:
                   /* Start sequence detection ok'd */
                   return_code = VVBG_GOTO_ONLINE_FAX;
                   *msg = (ubyte *)&RESULT_FAX;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION; */
                   break;

               case VCV_CAPQUERY_MODE:
                   /* Start sequence has completed */

                   /* Put the Audio Path into Data mode (play pleasing tone) */
                   audiomsg.type = AUDIO_VOICE_VIEW;
                   audiomsg.data = VV_AUDIO_DATA_MODE;
                   audio_control( &audiomsg );

                   *msg = (ubyte *)&RESULT_CAS;
                   vcv_state=VV_RX_CAPQUERY; /*CONVERSATION; */
                   break;

               case VCV_TALKOFF:
                   *msg = (ubyte *)&RESULT_TALKOFF;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION; */
                   break;

               case VCV_FALSE_ALARM:
                   vcv_state=VV_INITIALIZE; /*CONVERSATION; */
                   break;

               default:
                   break;
           }
           break;

       case VV_TX_STARTSEQ:
           rc = vcv_tx_startseq_state();
           switch(rc)
           {
               case VCV_STAY:
                   /* Do nothing, state not complete */
                   break;
           
               case VCV_OK:
                   /* Start sequence has completed */

                   vcv_state = VV_START_DATA_MODE;
                   break;

               case VCV_ERROR:
                   /* Error condition */
                   *msg = (ubyte *)&RESULT_ERROR;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION; */
                   break;

               default:
                   break;
           }
           break;

       case VV_START_DATA_MODE:
           switch (vcv_data_mode)
           {
               case VCV_MODEM_MODE:
                   return_code = VVBG_GOTO_ONLINE_MODEM;
                   break;

               case VCV_FAX_MODE: 
                   vcv_state=VV_DATA;
                   return_code = VVBG_GOTO_ONLINE_FAX;
                   break;

               /* VoiceView data mode */
               case VCV_VOICEVIEW_MODE:
                   vcv_state=VV_TX_DATA;
                   vcv_control_flag=0x02;

                   return_code = VVBG_GOTO_ONLINE_VOICEVIEW;
                   break;

               /* Invalid data mode */
               default:
                   break;
           }
           break;

       case VV_TX_CAPQUERY:
           rc=vcv_tx_capquery_state();
           switch(rc)
           {
               case VCV_STAY:
                   /* Do nothing, state not complete */
                   break;

               case VCV_OK:
                   /* Capabilities Query Complete*/
                   *msg = (ubyte *)&vcv_array[0];
                   vcv_state=VV_INITIALIZE; /*CONVERSATION*/

                   return_code = VVBG_GOTO_PARSE_TX_QUERY;
                   break;

               case VCV_ERROR:
                   /* Error condition */
                   *msg = (ubyte *)&RESULT_ERROR;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION*/

                   return_code = VVBG_GOTO_PARSE_TX_QUERY;
                   break;

               case VCV_TIMEOUT:
                   /* Error condition */
                   *msg = (ubyte *)&RESULT_ERROR;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION*/

                   return_code = VVBG_GOTO_PARSE_TX_QUERY;
                   break;

               default:
                   break;
           }
           break;

       case VV_RX_CAPQUERY:
           rc=vcv_rx_capquery_state();
           switch(rc)
           {
               case VCV_STAY:
                   /* Do nothing, state not complete */
                   break;

               case VCV_OK:
                   /* Capabilities Query Complete*/
                   *msg = (ubyte *)&vcv_array[0];
                   vcv_state=VV_INITIALIZE; /*CONVERSATION*/

                   return_code = VVBG_GOTO_PARSE_RX_QUERY;
                   break;

               case VCV_ERROR:
                   /* Error condition */
                   *msg = (ubyte *)&RESULT_ERROR;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION*/

                   return_code = VVBG_GOTO_PARSE_RX_QUERY;
                   break;

               case VCV_TIMEOUT:
                   /* Error condition */
                   *msg = (ubyte *)&RESULT_ERROR;
                   vcv_state=VV_INITIALIZE; /*CONVERSATION*/

                   return_code = VVBG_GOTO_PARSE_RX_QUERY;
                   break;

               default:
                   break;
           }
           break;

       case VV_DATA:
           /* In this state, there is nothing for the VoiceView background
            * process to do.  We are waiting for the host to issue AT
            * commands to proceed with the MODEM or FAX data modes. Once
            * the AT+FCLASS command is issued, the VoiceView background
            * process will be suspended.
            */
           break;

       /* VoiceView Data Mode receive state machine */
       case VV_RX_DATA:
           rc=vcv_control_rx();
           switch(rc)
           {
               case VCV_STAY:
                   break;

               case VCV_OK:
                   vcv_state=VV_INITIALIZE;
                   vcv_dte_reset();

                     /* Put the Audio Path into Conversation mode */
                     audiomsg.type = AUDIO_INIT;
                     audio_control( &audiomsg );

                   /* Send ACU to idle mode w/an OK */
                   return_code = VVBG_GOTO_PARSE_OK;
                   break;

               case VCV_ERROR:
                   vcv_state=VV_INITIALIZE;
                   vcv_dte_reset();

                     /* Put the Audio Path into Conversation mode */
                     audiomsg.type = AUDIO_INIT;
                     audio_control( &audiomsg );

                   /* Send ACU to idle mode w/an ok */
                   return_code = VVBG_GOTO_PARSE_ERROR;
                   break;

               case VCV_TIMEOUT:
                   /* Didnt get AT-SAC before timeout */
                   vcv_state=VV_INITIALIZE;
                   vcv_dte_reset();

                     /* Put the Audio Path into Conversation mode */
                     audiomsg.type = AUDIO_INIT;
                     audio_control( &audiomsg );

                   /* Send ACU to idle mode w/an ERROR */
                   return_code = VVBG_GOTO_PARSE_ERROR;
                   break;

               case VCV_SWITCH_TO_TX:
                  vcv_set_statevars(RX, SAVE);
                  modem_vcv_timer_delay(55);
                  modem_terminate_link();
                  
                  vcv_state=VV_TX_DATA;
                  if (vcv_control_flag==0x02)
                  {
                     vcv_control_flag=0x00;
                  }
                  else
                  {
                     vcv_control_flag=0x02;
                  }

                  vcv_switch_flag=TRUE;
                  break;

               default:
                   /* shouldnt be here */
                   while(1);
           }
           break;

       /* VoiceView Data Mode transmit state machine */
       case VV_TX_DATA:
           rc=vcv_control_tx();
           switch(rc)
           {
               case VCV_STAY:
                   break;

               case VCV_OK:
                    vcv_state=VV_INITIALIZE;
                    vcv_dte_reset();

                     /* Put the Audio Path into Conversation mode */
                     audiomsg.type = AUDIO_INIT;
                     audio_control( &audiomsg );

                    return_code = VVBG_GOTO_PARSE_OK;
                    break;

                case VCV_ERROR:
                    vcv_state=VV_INITIALIZE;
                    vcv_dte_reset();

                     /* Put the Audio Path into Conversation mode */
                     audiomsg.type = AUDIO_INIT;
                     audio_control( &audiomsg );

                    return_code = VVBG_GOTO_PARSE_ERROR;
                    break;

                case VCV_SWITCH_TO_RX:
                    vcv_set_statevars(TX, SAVE);
                    vcv_accept_vcv_request=TRUE;
                    vcv_state=VV_RX_DATA;

                    if (vcv_control_flag==0x02)
                    {
                       vcv_control_flag=0x00;
                    }
                    else
                    {
                       vcv_control_flag=0x02;
                    }

                    vcv_switch_flag=TRUE;
                    break;

                default:
                    /* shouldnt be here */
                    while(1);
           }
           break;
        
       case VV_SAC_STATE:
           vcv_accept_vcv_request=TRUE;

           vcv_state=VV_RX_DATA;
           vcv_config_dte=TRUE;    /* Set DTE to VoiceView at next occasion */

           return_code = VVBG_GOTO_ONLINE_VOICEVIEW;
           break;

       default:
           break;
           /* Invalid state */
   }

   return(return_code);
}


/*******************************************************************************
/
/   Routine: vcv_starttone_state
/
/   Author: RSA
/
/   Creation Date: 9/6/94
/
/   Description: State machine to control the transmission of the start tone
/                and mode indicator.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte status - status of the state machine
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_starttone_state()
{
    ubyte return_code;
    ubyte index;
    ubyte frame[10];
    AUDIO_CONTROL audiomsg;

    return_code = VCV_STAY;

    switch(vcv_st_state)
    {
        case VCV_INITIALIZE:
            /* Put the Audio Path into Data mode (play pleasing tone) */
            audiomsg.type = AUDIO_VOICE_VIEW;
            audiomsg.data = VV_AUDIO_DATA_MODE;
            audio_control( &audiomsg );

            /* Initialize DP to transmit dual freq start tone */
            modem_vcv_config_starttone();

            /* Set up the required delay prior to sending tone */
            vcv_utility_timer=VV_TIMER_STARTTONE_DELAY;
            vcv_st_state=VCV_WAIT;
            break;

        case VCV_WAIT:
            /* Check to see if timer has expired */
            if (vcv_utility_timer)
            {
                /* Timer has not expired */
                break;
            }

            /* Begin sending the tone */
            modem_vcv_transmitter(ON);

            /* Start Timer */
            vcv_utility_timer = VV_TIMER_STARTTONE_LEN; /* MUST not be >18 (180ms)*/
            vcv_st_state = VCV_STARTTONE_COMPLT;
            break;

        case VCV_STARTTONE_COMPLT:
            /* Check timer */
            if (vcv_utility_timer)
            {
                /* Timer has not expired, continue sending tone */
                break;
            }

            /* Timer has expired, turn off the tone */
            modem_vcv_transmitter(OFF);
            modem_vcv_timer_delay(85);

            vcv_line_reset();
            modem_config_vcv(TRANSMIT_MODE, vcv_data_rate[BURST_RATE]);
            vcv_line_init(HDLC_MODE, TRANSMIT_MODE, VV_HDLC_DATA_SIZE);

            vcv_st_state=VCV_SEND_MI_FRAME;
            vcv_utility_timer=10;
            break;

        case VCV_SEND_MI_FRAME:
            if (vcv_utility_timer)
            {
                break;
            }

            /* Build & Tx mode indicator frame. */
            index=0;

            /* Build Mode Indicator Frame */
            switch (vcv_data_mode)
            {
                /* Modem Data Mode */
                case VCV_MODEM_MODE:
                    frame[index++]=0x10;
                    frame[index++]=0x00;
                    frame[index++]='\0';
                    break;

                /* Fax data mode */
                case VCV_FAX_MODE:
                    frame[index++]=0x10;
                    frame[index++]=0x01;
                    frame[index++]='\0';
                    break;

                /* VoiceView data mode */
                case VCV_VOICEVIEW_MODE:
                    vcv_get_mi_string(vcv_data_rate[PRIORITY_RATE], frame);
                    break;

                /* Invalid data mode */
                default:
                    break;
            }

            vcv_schedule_tx_packet(MODE_INDICATOR_FRAME, frame,0);

            /* kick start the DCE by giving it the first receive buffer */
            vcv_line_tx_block((ubyte *)&vcv_buffer_array[vcv_tail_index]);

            /* Reset this state machine */
            vcv_st_state=VCV_WAIT_TX_COMPLETE;
            break;

        case VCV_WAIT_TX_COMPLETE:
            if (vcv_tail_index != vcv_head_index)
            {
                break;
            }

            vcv_utility_timer=8;
            vcv_st_state=VCV_MI_FINAL_FLAGS;
            break;

        case VCV_MI_FINAL_FLAGS:
            if (vcv_utility_timer)
            {
                break;
            }

            modem_vcv_transmitter(OFF);

            vcv_st_state=VCV_INITIALIZE;
            return_code=VCV_OK;
            break;

        default:
            break;
    }

    return(return_code);
}
        

/*******************************************************************************
/
/   Routine: vcv_adsicas_state
/
/   Author: RSA
/
/   Creation Date: 9/6/94
/
/   Description: State machine to control transmission of ADSI CAS tone
/
/   Input Parameters: None
/
/   Output Parameters: ubyte status - status of the state machine
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_adsicas_state()
{
    ubyte return_code;

    return_code = VCV_STAY;

    switch(vcv_ac_state)
    {
        case VCV_INITIALIZE:
            /* Initialize DP to transmit dual freq start tone */
            modem_vcv_config_adsicas();

            /* Set up the required delay prior to sending tone */
            vcv_utility_timer=VV_TIMER_ADSICAS_DELAY;
            vcv_ac_state=VCV_WAIT;
            break;

        case VCV_WAIT:
            /* Check to see if timer has expired */
            if (vcv_utility_timer)
            {
                /* Timer has not expired */
                break;
            }

            /* Timer has expired */

            /* Turn on RTS, which will begin sending the tone */
            modem_vcv_transmitter(ON);

            /* Start Timer */
            vcv_utility_timer = VV_TIMER_ADSICAS_LEN;

            vcv_ac_state = VCV_ADSICAS_COMPLT;
            break;

        case VCV_ADSICAS_COMPLT:
            /* Check timer */
            if (vcv_utility_timer)
            {
                /* Timer has not expired, continue sending tone */
                break;
            }

            /* Timer has expired, turn off the tone */
            modem_vcv_transmitter(OFF);

            /* Reset this state machine */
            vcv_ac_state=VCV_INITIALIZE;

            /* Return indication that this state machine has completed */
            return_code = VCV_OK;
            break;

        default:
            break;
    }

    return(return_code);
}
        
            
/*******************************************************************************
/
/   Routine: vcv_wait_ua_state
/
/   Author: RSA
/
/   Creation Date: 9/6/94
/
/   Description: Waits for a UA ack.  This is mainly for the modem and
/                fax data modes which send an ack prior to any data
/                transfer taking place.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte status - status of the state machine
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_wait_ua_state()
{
    ubyte return_code;

    return_code=VCV_STAY;

    switch(vcv_wua_state)
    {
        case VCV_INITIALIZE:
            modem_vcv_transmitter(OFF);
            vcv_utility_timer=VV_TIMER_T200;
            vcv_wua_state=VCV_WAIT;
            break;

        case VCV_WAIT:
            if (vcv_utility_timer==0)
            {
                /* Timeout waiting for ack */
                return_code=VCV_ERROR;
                vcv_error(ADD, 0x27);
                vcv_wua_state=VCV_INITIALIZE;
                break;
            }

            /* Check to see if complete frame received */
            if (vcv_frame_head != vcv_frame_tail)
            {
                /* We got HDLC Frame - verify that it is a
                 * supported data mode.  If mode is supported, send
                 * OK to app. We are now in a state waiting for DTE to
                 * configure us for fax or modem data modes.
                 * If DISC or undetermined frame rcvd,
                 * send ERROR message to DTE.  Set appropriate variable
                 * so that DTE can query error cause.
                 */

                /* Reset this state machine */
                vcv_wua_state=VCV_INITIALIZE;
                return_code=VCV_OK;
                break;
            }
            else
            {
                /* Check for a DTMF A */
            }
            break;

        default:
            break;
    }

    return(return_code);
}

/*******************************************************************************
/
/   Routine: vcv_capresp_state
/
/   Author: RSA
/
/   Creation Date: 9/6/94
/
/   Description: State machine which gets the respose to a capabilities
/                query.  Also checks to see if a two way exchange is
/                requested.  If so, it will tx the capabilities back.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte status - status of the state machine.
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_capresp_state(ubyte mode)
{
    ubyte return_code;
    ubyte *data_ptr;
    ubyte length,num,temp,index,i,control;
    ubyte capabilities_length;
    struct vcv_hdlc_packet *temp_packet;

    length=0xFF;

    return_code=VCV_STAY;

    switch(vcv_cr_state)
    {
        case VCV_INITIALIZE:
            modem_config_vcv(RECEIVE_MODE, vcv_data_rate[BURST_RATE]);
            vcv_line_init(HDLC_MODE, RECEIVE_MODE, VV_HDLC_DATA_SIZE);

            /* kick start the DCE by giving it the first receive buffer */
            vcv_line_rx_block((ubyte *)&vcv_buffer_array[vcv_head_index]);

            vcv_utility_timer=VV_TIMER_T301; /* Capabilities timer T301? */
            vcv_cr_state=VCV_WAIT;

            break;

        case VCV_WAIT:
            if (vcv_utility_timer==0)
            {
                /* Timeout waiting for ack */
                return_code=VCV_TIMEOUT;
                vcv_error(ADD,0x24);
                vcv_cr_state=VCV_INITIALIZE;
                break;
            }

            /* Check to see if complete frame received */
            if (vcv_head_index != vcv_tail_index)
            {
                /* Get a pointer to the packet */
                temp_packet=&vcv_buffer_array[vcv_tail_index++];


                /* Check for queue wraparound */
                if (vcv_tail_index == VCV_HDLC_BUFFER_COUNT)
                    vcv_tail_index =0;

                /* Point to the data portion of packet */
                data_ptr=temp_packet->data;

                index=0;

                /* Examine Address */
                if (data_ptr[index++] != 0x01)
                {
                    return_code=VCV_ERROR;
                    vcv_error(ADD,0x82);
                    vcv_cr_state=VCV_INITIALIZE;
                    break;
                }

                control = data_ptr[index++];

                /* Examine Control field */
                if ((control != 0x03) && (control != 0x13))
                {
                    return_code=VCV_ERROR;
                    vcv_error(ADD,0x25);
                    vcv_cr_state=VCV_INITIALIZE;
                    break;
                }

                /* Examine message type */
                if (data_ptr[index++] != 0x05)
                {
                    return_code=VCV_ERROR;
                    vcv_error(ADD,0x25);
                    vcv_cr_state=VCV_INITIALIZE;
                    break;
                }

                /* Determine length of remainder of message */
                capabilities_length = data_ptr[index++];

                if (capabilities_length>254)
                {
                    return_code=VCV_ERROR;
                    vcv_error(ADD,0x25);
                    vcv_cr_state=VCV_INITIALIZE;
                    break;
                } 

                i=0;
                vcv_array[i++] = '\r';
                vcv_array[i++] = '\n';
                vcv_array[i++] = '-';
                vcv_array[i++] = 'S';
                vcv_array[i++] = 'R';
                vcv_array[i++] = 'C';
                vcv_array[i++] = ':';
                vcv_array[i++] = '"';

                while (capabilities_length-- > 0)
                {
                    num = data_ptr[index++];
                    if (num<0x10)
                    {
                        vcv_array[i++]='0';
                        if (num>0x09)
                        {
                            vcv_array[i++]=num+'7';
                        }
                        else
                        {
                            vcv_array[i++]=num+'0';
                        }
                    }
                    else
                    {
                        temp=(num/0x10);
                        if (temp>0x09)
                        {
                            vcv_array[i++]=(num/0x10)+'7';
                        }
                        else
                        {
                            vcv_array[i++]=(num/0x10)+'0';
                        }

                        temp=(num%0x10);
                        if (temp>0x09)
                        {
                            vcv_array[i++]=(num%0x10)+'7';
                        }
                        else
                        {
                            vcv_array[i++]=(num%0x10)+'0';
                        }
                    }

                    vcv_array[i++]=' ';
                }

                i--;

                /* Check for a two-way capabilities reply */
                if ((control & 0x10) && (mode==TX))
                {
                   vcv_array[i++] = '"';
                   vcv_array[i++] = '\r';
                   vcv_array[i++] = '\n';
                   vcv_array[i++] = '-';
                   vcv_array[i++] = 'S';
                   vcv_array[i++] = 'R';
                   vcv_array[i++] = 'Q';
                   vcv_array[i++] = '\0';
                   vcv_cr_state = VCV_CAPREPLY;
                   break;
                }
                else
                {
                         vcv_array[i++] = '"';
                   vcv_array[i++] = '\r';
                   vcv_array[i++] = '\n';
                   vcv_array[i++] = 'O';
                   vcv_array[i++] = 'K';
                   vcv_array[i++] = '\r';
                   vcv_array[i++] = '\n';
                   vcv_array[i++] = '\0';

                   /* Reset this state machine */
                   vcv_cr_state=VCV_INITIALIZE;
                   return_code=VCV_OK;
                }

                break;
            }
            else
            {
                /* Check for a DTMF A */
            }
            break;
                 
        case VCV_CAPREPLY:
            modem_config_vcv(TRANSMIT_MODE, vcv_data_rate[BURST_RATE]);
            vcv_line_init(HDLC_MODE, TRANSMIT_MODE, VV_HDLC_DATA_SIZE);

            vcv_cr_state=VCV_SEND_MI_FRAME;
            vcv_utility_timer=8;
            break;

        case VCV_SEND_MI_FRAME:
            if (vcv_utility_timer)
            {
                break;
            }

            vcv_schedule_tx_packet(CAPABILITIES_FRAME, vcv_cap_struct,0x02);

            /* kick start the DCE by giving it the first receive buffer */
            vcv_line_tx_block((ubyte *)&vcv_buffer_array[vcv_tail_index]);

            vcv_cr_state=VCV_WAIT_TX_COMPLETE;
            break;

        case VCV_WAIT_TX_COMPLETE:
            if (vcv_tail_index != vcv_head_index)
            {
                break;
            }

            vcv_utility_timer=3;
            vcv_cr_state=VCV_MI_FINAL_FLAGS;
            break;

        case VCV_MI_FINAL_FLAGS:
            if (vcv_utility_timer)
            {
                break;
            }

            modem_vcv_transmitter(OFF);

            /* Reset this state machine */
            vcv_cr_state=VCV_INITIALIZE;
            i=0;
            vcv_array[i++] = 'O';
            vcv_array[i++] = 'K';
            vcv_array[i++] = '\r';
            vcv_array[i++] = '\n';
            vcv_array[i++] = '\0';
            return_code=VCV_OK;

            break;

        default:
            break;
    }

    return(return_code);
}

/*******************************************************************************
/
/   Routine: vcv_capquery_state
/
/   Author: RSA
/
/   Creation Date: 9/6/94
/
/   Description: State machine which controls the complete capaibilies
/                query exchange.  Calls other state machines as needed.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte status - status of the VoiceView code
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_tx_capquery_state()
{

    ubyte rc, return_code;
   AUDIO_CONTROL audiomsg;

    return_code = VCV_STAY;

    switch(vcv_cq_state) {

        case VCV_INITIALIZE: {

/* start change keh 1/27/95 => add Wireless VV */
#if 0
*           /* Mute the audio */
*           audiomsg.type = AUDIO_RX_MUTE;
*           audiomsg.data = 1;
*           audio_control( &audiomsg );
*       
*           audiomsg.type = AUDIO_TX_MUTE;
*           audiomsg.data = 1;
*           audio_control( &audiomsg );
#endif

           /* Put the Audio Path into Data mode (play pleasing tone) */
           audiomsg.type = AUDIO_VOICE_VIEW;
           audiomsg.data = VV_AUDIO_DATA_MODE;
           audio_control( &audiomsg );
/* end change keh 1/27/95 => add Wireless VV */

            /* Initialize DP to transmit dual freq start tone */
            modem_vcv_config_starttone();

            /* Set up the required delay prior to sending tone */
            vcv_utility_timer=VV_TIMER_STARTTONE_DELAY;
            vcv_cq_state=VCV_WAIT;
            break;
        }

        case VCV_WAIT: {

            /* Check to see if timer has expired */
            if (vcv_utility_timer) {
                /* Timer has not expired */
                break;
            }

            /* Timer has expired */


            /* Turn on RTS, which will begin sending the tone */
            modem_vcv_transmitter(ON);

            /* Start Timer */
            vcv_utility_timer = VV_TIMER_STARTTONE_LEN;
            vcv_cq_state = VCV_STARTTONE_COMPLT;

            break;

        }

        case VCV_STARTTONE_COMPLT: {
            /* Check timer */
            if (vcv_utility_timer) {
                /* Timer has not expired, continue sending tone */
                break;
            }

            /* Timer has expired, turn off the tone */
            modem_vcv_transmitter(OFF);

            vcv_cq_state = VCV_ADSICAS;

            break;
        }

        case VCV_ADSICAS: {
            rc=vcv_adsicas_state();
            if (rc==VCV_OK) {
                vcv_cq_state=VCV_CAPRESP;
                break;
            }
            break;
        }

        case VCV_CAPRESP: {
            rc=vcv_capresp_state(TX);
            switch(rc) {

                case VCV_STAY: {
                    break;
                }

                case VCV_OK: {
                    vcv_cq_state=VCV_INITIALIZE;
                    return_code=VCV_OK;
                    break;
                }

                case VCV_ERROR: {
                    vcv_cq_state=VCV_INITIALIZE;
                    return_code=VCV_ERROR;
                    break;
                }

                case VCV_TIMEOUT: {
                    vcv_cq_state=VCV_INITIALIZE;
                    return_code=VCV_TIMEOUT;
                    break;
                }
                default: {
                    break;
                }
            } 
            break;
        }

        default: {
            break;
        }

    } /*switch*/

    return(return_code);
}
    

/*******************************************************************************
/
/   Routine: vcv_startseq_state
/
/   Author: RSA
/
/   Creation Date: 9/6/94
/
/   Description:  State machine to control the complete transmission of
/                 the start tone sequence.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte status - status of the state machine.
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_tx_startseq_state()
{
    ubyte return_code=VCV_STAY;
    ubyte rc;
    
    switch(vcv_ss_state) {

        case VCV_STARTTONE: {
            rc=vcv_starttone_state();
            if (rc==VCV_OK) {
                vcv_ss_state=VCV_WAIT_UA;
                break;
            }
            break;
        }

        case VCV_WAIT_UA: {
            if (vcv_data_mode==VCV_VOICEVIEW_MODE) {
                    vcv_ss_state=VCV_STARTTONE;
                return(VCV_OK);
            }

            rc=vcv_wait_ua_state();
            switch(rc) {
                case VCV_STAY: {
                    break;
                }

                case VCV_OK: {
                    vcv_ss_state=VCV_STARTTONE;
                    return_code =VCV_OK;
                    break;
                }
                case VCV_ERROR: {
                    vcv_ss_state=VCV_STARTTONE;
                    return_code = VCV_ERROR;
                    break;
                }
                default: {
                    break;
                }
            }
            break;
        }

        default: {
            break;
        }

    }
    return(return_code);
}






/*******************************************************************************
/
/   Routine: vcv_verify_startseq_state
/
/   Author: RSA
/
/   Creation Date: 01/30/95
/
/   Description: Verifies the starttone sequence, checks for a possible
/               capabilities query, and verifies the mode indicator.
/
/   Input Parameters: None
/
/   Output Parameters: Returns the status of the start tone sequence.
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_verify_startseq_state()
{

    ubyte rc, return_code;

    return_code = VCV_STAY;

    switch(vcv_verify_ss_state)
    {
        case VCV_INITIALIZE:
            vcv_verify_ss_state=VCV_DEBOUNCE_TONE;
            vcv_utility_timer=300;
            while((vcv_tone_state==TRUE) && (vcv_utility_timer!=0))
            {
              check_tone_state();
              process_wait();
            }

            modem_vcv_configure_tone_rx(ADSI_CAS);

            /* Fall through on purpose!! */


        case VCV_DEBOUNCE_TONE:
            if (vcv_tone_state==FALSE)
            {
                if (vcv_tone_time<3)
                {
                    vcv_verify_ss_state=VCV_INITIALIZE;
                    return_code=VCV_FALSE_ALARM;
                    break;
                }

                if ((vcv_tone_time<10) || (vcv_tone_time>24))
                {
                    return_code=VCV_TALKOFF;
                    vcv_verify_ss_state=VCV_INITIALIZE;
                    break;
                }

                /* Tone was present for the minimum amount of time,
                 * configure to get mode indicator OR adsi CAS.
                 */
                vcv_verify_ss_state=VCV_V21_OR_CAS;
                vcv_utility_timer = 50;
                break;
            }
            else
            {
                if (vcv_st_timer==0)
                {
                    return_code=VCV_TALKOFF;
                    vcv_verify_ss_state=VCV_INITIALIZE;
                    break;
                }
            }
            break;

        case VCV_V21_OR_CAS:
            if (vcv_tone_state==TRUE)
            {
                vcv_verify_ss_state=VCV_VERIFY_CAS;
                vcv_utility_timer=5;
                break;
            }

            /* Moved here during L3NVV1 fix*/
            if (vcv_utility_timer == 0)
            {
                return_code=VCV_TALKOFF;
                vcv_verify_ss_state=VCV_INITIALIZE;
                break;
            }

            if (vcv_tail_index != vcv_head_index)
            {
                /* Got a V.21 frame */
                rc=vcv_check_mi(&vcv_buffer_array[vcv_tail_index]);
                vcv_tail_index++;

                /* Check for queue wraparound */
                if (vcv_tail_index == VCV_HDLC_BUFFER_COUNT)
                  vcv_tail_index =0;

                switch (rc)
                {
                    case VCV_VOICEVIEW_MODE:
                        return_code=VCV_VOICEVIEW_MODE;
                        vcv_verify_ss_state=VCV_INITIALIZE;
                        break;

                    case VCV_MODEM_MODE:
                        return_code = VCV_MODEM_MODE;
                        vcv_head_index=vcv_tail_index=0;
                        modem_config_vcv(TRANSMIT_MODE, vcv_data_rate[BURST_RATE]);
                        vcv_line_init(HDLC_MODE, TRANSMIT_MODE, VV_HDLC_DATA_SIZE);
                        rc=vcv_send_supervisory(UA, 0, 0);

                        /* kick start the DCE by giving it the first transmit buffer */
                        vcv_line_tx_block((ubyte *)&vcv_buffer_array[vcv_tail_index]);

                        while (vcv_tail_index != vcv_head_index);

                        modem_vcv_timer_delay(200);
                        modem_vcv_transmitter(OFF);
                        vcv_verify_ss_state=VCV_INITIALIZE;
                        break;

                    case VCV_FAX_MODE:
                        return_code = VCV_FAX_MODE;
                        vcv_head_index=0;
                        vcv_tail_index=0;
                        modem_config_vcv(TRANSMIT_MODE, vcv_data_rate[BURST_RATE]);
                        vcv_line_init(HDLC_MODE, TRANSMIT_MODE, VV_HDLC_DATA_SIZE);
                        rc=vcv_send_supervisory(UA, 0, 0);

                        /* kick start the DCE by giving it the first transmit buffer */
                        vcv_line_tx_block((ubyte *)&vcv_buffer_array[vcv_tail_index]);

                        while (vcv_tail_index != vcv_head_index);

                        modem_vcv_timer_delay(200);
                        modem_vcv_transmitter(OFF);
                        vcv_verify_ss_state=VCV_INITIALIZE;
                        break;

                    default:
                        /* We could get here also due to a bad MI or inactive
                         * MI.
                         */
                        return_code=VCV_TALKOFF;
                        vcv_verify_ss_state=VCV_INITIALIZE;
                        break;
                }
            }
            break;

        case VCV_VERIFY_CAS:
            if (vcv_tone_state==TRUE)
            {
                break;
            }

            if (vcv_tone_time>3 && vcv_tone_time<8)
            {
                return_code = VCV_CAPQUERY_MODE;
                vcv_verify_ss_state=VCV_INITIALIZE;
            }
            else
            {
                return_code=VCV_TALKOFF;
                vcv_verify_ss_state=VCV_INITIALIZE;
            }
            break;
    }

    return(return_code);
}



                
/*******************************************************************************
/
/   Routine: vcv_rx_capquery_state
/
/   Author: RSA
/
/   Creation Date: 01/30/95
/
/   Description: State machine to control the request for a capabilites
/                query.  Will transmit current capabilities.
/
/   Input Parameters: None
/
/   Output Parameters: ubyte status - status of the state machine.
/
/   Global Variables Changed:  None
/
/   Users:
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
ubyte vcv_rx_capquery_state()
{

    ubyte rc, return_code;

    return_code = VCV_STAY;

    switch(vcv_rx_cq_state)
    {
        case VCV_INITIALIZE:
            vcv_utility_timer=6;
            vcv_rx_cq_state=VCV_WAIT;
            break;

        case VCV_WAIT:
            if (vcv_utility_timer == 0)
            {
                modem_config_vcv(TRANSMIT_MODE, vcv_data_rate[BURST_RATE]);
                vcv_line_init(HDLC_MODE, TRANSMIT_MODE, VV_HDLC_DATA_SIZE);
                vcv_rx_cq_state=VCV_SEND_MI_FRAME;
                vcv_utility_timer=8; /*8*/
                break;
            }
            break;

        case VCV_SEND_MI_FRAME:
            if (vcv_utility_timer)
            {
                break;
            }

            vcv_schedule_tx_packet(CAPABILITIES_FRAME, vcv_cap_struct,0);

            /* kick start the DCE by giving it the first transmit buffer */
            vcv_line_tx_block((ubyte *)&vcv_buffer_array[vcv_tail_index]);
            vcv_rx_cq_state=VCV_WAIT_TX_COMPLETE;
            break;

        case VCV_WAIT_TX_COMPLETE:
            if (vcv_tail_index != vcv_head_index)
            {
                break;
            }

            vcv_utility_timer=8;
            vcv_rx_cq_state=VCV_MI_FINAL_FLAGS;
            break;

        case VCV_MI_FINAL_FLAGS:
            if (vcv_utility_timer)
            {
                break;
            }

            modem_vcv_transmitter(OFF);

            /** SQR=1 support CQB2.a **/
            if (vcv_sqr_switch==TRUE)
            {
               vcv_rx_cq_state=VCV_CAPRESP;
            }
            else
            {
               vcv_rx_cq_state=VCV_INITIALIZE;
               return_code=VCV_OK;
            }
            break;

        case VCV_CAPRESP:
            rc=vcv_capresp_state(RX);
            switch(rc)
            {
                case VCV_STAY:
                    break;

                case VCV_OK:
                    vcv_rx_cq_state=VCV_INITIALIZE;
                    return_code=VCV_OK;
                    break;

                case VCV_ERROR:
                    vcv_rx_cq_state=VCV_INITIALIZE;
                    return_code=VCV_ERROR;
                    break;

                case VCV_TIMEOUT:
                    vcv_rx_cq_state=VCV_INITIALIZE;
                    return_code=VCV_TIMEOUT;
                    break;

                default:
                    break;
            } 
            break;

         default:
            /* never get here */
            while(1);
    }

    return(return_code);
}

    
/*******************************************************************************
/
/   Routine: vcv_reset
/
/   Author: RSA
/
/   Creation Date: 9/27/95
/
/   Description: This routine will reset VoiceView to begin detecting start tone
/                  by reseting the background state to initailize.
/
/   Input Parameters: none
/
/   Output Parameters: none
/
/   Global Variables Changed:  vcv_state
/
/   Users: (ACU)
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
void vcv_reset(void)
{
   /* Run bg from init. */
   vcv_state = VV_INITIALIZE;
}

/*******************************************************************************
/
/   Routine: vcv_dte_config
/
/   Author: RSA
/
/   Creation Date: 9/27/95
/
/   Description: This routine is called to inform the VoiceView module of
/                environment settings. This routine should be called by
/                the ACU after any environment change, and before the
/                next entry into the VoiceView module.
/
/   Input Parameters:
/
/                     ubyte     fax class
/
/                     ubyte     response type
/                     0         numeric
/                     1         verbose
/
/                     ubyte     DTE baudrate
/                     2         300
/                     3         1200
/                     4         2400
/                     5         4800
/                     6         7200
/                     7         9600
/                     8         12000
/                     9         14400
/                     10        16800
/                     11        19200
/                     12        38400
/                     13        57600
/                     14        600
/                     15        115200
/
/                     ubyte     flow control
/                     0         no flow control
/                     1         XON/XOFF
/                     2         CTS/RTS
/                     3         XON/XOFF and CTS/RTS
/
/
/   Output Parameters: none
/
/   Global Variables Changed:  vcv_dte_rate,vcv_dte_flow
/
/   Users: (ACU)
/
/   -------------------------------------------------------------
/   -            Modifications                    -
/   -------------------------------------------------------------
/
/
/       Author & Date: 
/       Description: 
/       Reason:
/
*******************************************************************************/
void vcv_dte_config(ubyte fclass, ubyte response_type, ubyte dte_baud,
                   ubyte flow_control)
{
   /* Ignore */
   fclass = 0;
   response_type = 0;

   /* Assign */
   vcv_dte_rate = dte_baud;
   vcv_dte_flow_control = flow_control;
}


