/*###########################################################################*
*                                                                            *
* FILE:    module.c                                                          *
*                                                                            *
* PROJECT: NCDialCtrl module - Funai                                         *
*                                                                            *
* PURPOSE: Main module source code                                           *
*                                                                            *
* VERSION: Version 1.00, Steve Revill 2nd/March/1998                         *
*                                                                            *
*###########################################################################*/

#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include "module.h"
#include "filegen.h"
#include "cmhg_modem.h"
#include "kernel.h"
#include "swis.h"
#include "wimp.h"
#include "sys/types.h"
#include "netinet/in.h"

#define vdu4() _swix(0x104, 0)
#define os_removecursors()  _swix(OS_RemoveCursors, 0)
#define os_restorecursors() _swix(OS_RestoreCursors, 0)
#define int16 short
#define int32 long
/* Service call numbers */
#define Service_ResourceFSStarting 0x60
#define Service_ShutDown           0x7E
#define Service_ShutdownComplete   0x80
#define Service_DiallerStatus      0xB4
#define Service_DiallerB           0xC4
#define Service_NCRegistryStatus   0xBA
/* DiallerB service call status word (byte one) meanings */
#define dialB_svc0_not_contd       0x00
#define dialB_svc0_dialng          0x01
#define dialB_svc0_contng          0x02
/* DiallerB service call status word (byte zero) meanings */
#define dialB_svc_idle             0x00
#define dialB_svc_nodial           0x08
#define dialB_svc_busy             0x09
#define dialB_svc_nocarrier        0x06
#define dialB_svc_noserver         0x10
#define dialB_svc_timeout          0x05
#define dialB_svc_error0           0x04
#define dialB_svc_error1           0x07
#define dialB_svc_error2           0x11
#define dialB_svc_dialling         0x01
/* NCDialCtrl service call status meanings */
#define ctrl_svc_nodial            0x81
#define ctrl_svc_busy              0x82
#define ctrl_svc_nocarrier         0x83
#define ctrl_svc_noserver          0x84
#define ctrl_svc_timeout           0x85
#define ctrl_svc_error             0x86
#define ctrl_svc_dialling          0x91
#define ctrl_svc_connecting        0x92
/* NCDialCtrl_modinit definitions */
#define SERIALDEV_VAR "SerialDev$Path"
#define SERIALDEV_TXT "Resources:$.Resources.NCDialCtrl."
#define INET_VAR      "Inet$Path"
#define INET_TXT      "Resources:$.Resources.NCDialCtrl."
#define DYNAMIC_VAR   "FileDyn$Path"
#define DYNAMIC_TXT   "<Wimp$ScrapDir>.NCDialCtrl."
#define INETDBASE_VAR "InetDBase$Path"
#define INETDBASE_TXT "Inet:Files.,FileDyn:Files."
/* DiallerB SWI numbers */
#define DiallerB_Dial   0x50C80
#define DiallerB_HangUp 0x50C81
/* Possible connection states */
#define state_offline     0  /* There is no connection or activity                         */
#define state_dialling    1  /* A PPPConnect has been issued but no IPUp received          */
#define state_ppp_goingup 2  /* IPUp received issuing a SWI DiallerB_Dial                  */
#define state_online      3  /* SVC call received from DaillerB saying we're connected     */
#define state_hanging     4  /* Issuing a PPPDisconnect, no IPDown yet                     */
                             /* We issue a SWI DiallerB_Hangup when we get IPDown from PPP */
typedef void (*P_FSStartingFN)(void *r0);

#ifndef TRUE
#define FALSE 0
#define TRUE (!FALSE)
#endif

carddata card;
void       *pwp;                       /* Private word pointer  */
BOOL       silent    = TRUE;          /* Debug output flag     */
static int mod_state = state_offline;  /* Current state of the connection */

char *cmos_number(void);
char *expand_special(char *temp);
void LED_State(BOOL state);
void DiallerService(int reason);
void Commence(void);
void not_connected_svc(int byte);
void dialling_svc(int byte);
void connecting_svc(int byte);
void Handle_diallerB_svc(int status);
void safe_hangup(void);



/*############################################################*/
/*                                                            */
/*                       Misc routines                        */
/*                                                            */
/*############################################################*/



/************************
*
* FUNCTION: convert_digit
*
* PURPOSE:  Pack decimal digits into four bits
*
*/
static char *convert_digit(char *tag, int len, char *phone, BOOL pulse)
{
  char *chars = "0123456789*#,";
  int failed, nibble, packed, shift = 0;

  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), tag, &packed, 0, &failed);
  if (failed >= 0 && packed)
  {
    while (shift < (4 * (len - 1)))
    {
      nibble = (packed >> (shift ^ 4)) & 0xF;
      if (0 == nibble)
      {
        break;
      }
      if (pulse && chars[nibble - 1] == '*')
      {
        *phone = '1';
        phone++;
        *phone = '1';
        phone++;
      }
      else
      {
        *phone = chars[nibble - 1];
        phone++;
      }
      shift += 4;
    }
  }

if(!silent)fprintf(stderr, "convert_digit gives '%s'\n", phone);

  return(phone);
}

/***********************
*
* FUNCTION: cmos_number
*
* PURPOSE:  Extract some value from the CMOS
*
*/
char *cmos_number(void)
{
  static char phone[80];
  char  *ptr = NULL;
  int   pulse, callwaiting, failed, ignore, outside, wait;
  strcpy(phone, "AT");
  ptr = phone + strlen(phone);

  /* Blind dialling switch */
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemDialIgnore", &ignore, 0, &failed);
  if (failed >= 0 && ignore)
  {
    *ptr = 'X';
    ptr++;
    *ptr = '3';
    ptr++;
  }

  /* Dialling type */
  *ptr = 'D';
  ptr++;
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemDialType", &pulse, 0, &failed);
  if (failed >= 0 && pulse)
  {
    *ptr = 'P';
    ptr++;
  }
  else
  {
    *ptr = 'T';
    ptr++;
  }

  /* Outside line */
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemPrefixStatus", &outside, 0, &failed);
  if (failed >= 0 && outside)
  {
    int len;
    _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemPrefix", 0, 0, &len);
    if (len > 0)
    {
      ptr = convert_digit("ModemPrefix", len*2, ptr, pulse);
      _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemDialTone", &wait, 0, &failed);
      if (failed >= 0 && wait)
      {
        *ptr = 'W';
        ptr++;
      }
      else
      {
        *ptr = ',';
        ptr++;
      }
    }
  }

  /* Call waiting defeat stuff */
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemCallWaitingStatus", &callwaiting, 0, &failed);
  if (failed >= 0 && callwaiting)
  {
    int len;
    _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemCallWaiting", 0, 0, &len);
    if (len > 0)
    {
      ptr = convert_digit("ModemCallWaiting", len*2, ptr, pulse);
      *ptr = ',';
      ptr++;
    }
  }
  *ptr = '\0';
  ptr++;
if(!silent)fprintf(stderr, "cmos gave '%s'\n", phone);

  return(phone);
}

/***************
*
* FUNCTION: expand_special
*
* PURPOSE:  Replace the username and password with smart card data
*
*/
char *expand_special(char *temp)
{
if(!silent)fprintf(stderr,"   NOPE. Expand things like 'send-user'\n");
  if (strlen(temp) > 0)
  {
    if (0 == strcmp(temp, "ATDT"))
    {
if(!silent)fprintf(stderr,"   Calling cmos_number()\n");
      temp = cmos_number();
      strcat(temp, card.pstnnum);
if(!silent)fprintf(stderr,"   Back from cmos_number() %s\n", temp);
    }
    else
    if (0 == strcmp(temp, "send_user"))
    {
      temp = card.loginid;
if(!silent)fprintf(stderr,"   Reading card.loginid %s\n", temp);
    }
    else
    if (0 == strcmp(temp, "send_pass"))
    {
      temp = card.loginsecret;
if(!silent)fprintf(stderr,"   Reading card.logsecret %s\n", temp);
    }
  }

  return(temp);
}

/*********************
*
* FUNCTION: LED_State
*
* PURPOSE:  Set the state of the NC's LEDs to reflect the online/offline state
*
*/
void LED_State(BOOL state)
{
  _swix(LED_Control, _INR(0, 2), 0, ~(1), state ? 1 : 0);
}



/*###########################################################################*/
/*                                                                           */
/*                        Application Specific Routines                      */
/*                                                                           */
/*###########################################################################*/



/**************************
*
* FUNCTION: DiallerService
*
* PURPOSE:  Issue a dialler service call (to the DiallerUI) and update the NC LEDs
*
*/
void DiallerService(int reason)
{
  if (reason == NCDialler_IPDown)
  {
    LED_State(FALSE);
  }
  if (reason == NCDialler_IPUp)
  {
    LED_State(TRUE);
  }
if(!silent){vdu4();fprintf(stderr, "Issuing service call %d\n", reason);}
  _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, reason);
  if (0x80 == (reason & 0xF0))
  {
if(!silent)fprintf(stderr, "Issuing service call NCDialler_IPDown\n");
    mod_state = state_offline;
    _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, NCDialler_IPDown);
  }
}

/********************
*
* FUNCTION: Commence
*
* PURPOSE:  Initialise the dialler to start a call
*
*/
void Commence(void)
{
  switch (mod_state)
  {
    case (state_online):
    {
      DiallerService(NCDialler_IPUp);
      break;
    }
    case (state_offline):
    {
      mod_state = state_dialling;
      DiallerService(NCDialler_Starting);
      if (FALSE == CreateFiles(&card))
      {
        DiallerService(NCDialler_Error);     /* mod_state becomes state_offline as a side-effect of this call */
      }
      else
      {
        _kernel_oserror *err_block;
        err_block = _swix(DiallerB_Dial, _INR(0, 4), 0, device_name, scrap_dial_scr, scrap_hang_scr, dial_speed);
        if (err_block)
        {
if(!silent)fprintf(stderr,"Swi returned error num: %d  str: %s\n",err_block->errnum,err_block->errmess);
          DiallerService(NCDialler_Error);   /* mod_state becomes state_offline as a side-effect of this call */
        }
        else
        {
if(!silent)fprintf(stderr, "Issuing a dialling svc call\n");
          DiallerService(NCDialler_Dialling);
        }
      }
    }
  }
}

/**************************
*
* FUNCTION: not_connected_svc
*
* PURPOSE:  Handle a service call where byte 1 indicates that there is no connection (eg: an error)  (from the POV of the UI)
*
*/
void not_connected_svc(int byte)
{
  switch (byte)
  {
    case dialB_svc_idle:
    {
if(!silent){vdu4();fprintf(stderr, "Now DiallerB is offline and PPP is disconnected\n");}
      if (state_dialling != mod_state)
      {
        mod_state = state_offline;
      }
      break;
    }
    case dialB_svc_nodial:
    {
if(!silent)fprintf(stderr, "dialB_svc_nodial\n");
      DiallerService(ctrl_svc_nodial);
      break;
    }
    case dialB_svc_busy:
    {
if(!silent)fprintf(stderr, "dialB_svc_busy\n");
      DiallerService(ctrl_svc_busy);
      break;
    }
    case dialB_svc_nocarrier:
    {
if(!silent)fprintf(stderr, "dialB_svc_nocarrier\n");
      DiallerService(ctrl_svc_nocarrier);
      break;
    }
    case dialB_svc_noserver:
    {
if(!silent)fprintf(stderr, "dialB_svc_noserver\n");
      DiallerService(ctrl_svc_noserver);
      break;
    }
    case dialB_svc_timeout:
    {
if(!silent)fprintf(stderr, "dialB_svc_timeout\n");
      DiallerService(ctrl_svc_timeout);
      break;
    }
    case dialB_svc_error0:
    {
if(!silent)fprintf(stderr, "dialB_svc_error0\n");
      DiallerService(ctrl_svc_timeout);
      break;
    }
    case dialB_svc_error1:
    {
if(!silent)fprintf(stderr, "dialB_svc_error1\n");
      DiallerService(ctrl_svc_timeout);
      break;
    }
    case dialB_svc_error2:
    {
if(!silent)fprintf(stderr, "dialB_svc_error2\n");
      DiallerService(ctrl_svc_error);
      break;
    }
    default:
    {
if(!silent)fprintf(stderr, "unknown diallerB byte 0 (not_connected_svc)\n");
      break;
    }
  }
}

/**************************
*
* FUNCTION: dialling_svc
*
* PURPOSE:  Handle a service call where byte 1 indicates that the modem is dialling (from the POV of the UI)
*
*/
void dialling_svc(int byte)
{
  if (byte == dialB_svc_dialling)
  {
if(!silent)fprintf(stderr, "dialB_svc_dialling\n");
    DiallerService(ctrl_svc_dialling);
  }
}

/**************************
*
* FUNCTION: connecting_svc
*
* PURPOSE:  Handle a service call where byte 1 indicates that the modem is connecting (from the POV of the UI)
*
*/
void connecting_svc(int byte)
{
  if (byte == dialB_svc_idle)
  {
    if (state_dialling == mod_state)
    {
if(!silent){vdu4();fprintf(stderr, "In handler for svc_connecting\n");}
      DiallerService(ctrl_svc_connecting);
if(!silent)fprintf(stderr, "Issuing a PPP connect\n");
      mod_state = state_ppp_goingup;
      oscli("PPPConnect");
    }
  }
}

/**************************
*
* FUNCTION: Handle_diallerB_service
*
* PURPOSE:  On receiving a service call from DiallerB, issue the correct service call to the UI
*
*/
void Handle_diallerB_svc(int status)
{
  int byte_zero, byte_one;
  byte_zero = status & 0xFF;
  byte_one  = (status >> 8) & 3;

  switch (byte_one)
  {
    case dialB_svc0_not_contd:
    {
if(!silent)fprintf(stderr, "Not connected SVC received\n");
      not_connected_svc(byte_zero);
      break;
    }
    case dialB_svc0_dialng:
    {
if(!silent)fprintf(stderr, "Dialling SVC received\n");
      dialling_svc(byte_zero);
      break;
    }
    case dialB_svc0_contng:
    {
if(!silent)fprintf(stderr, "Connecting SVC received\n");
      connecting_svc(byte_zero);
      break;
    }
    default:
    {
if(!silent)fprintf(stderr, "Unexpected diallerB service call (connected incoming)\n");
      break;
    }
  }
}



/*#################################################################*/
/*                                                                 */
/*                   Standard Module Routines                      */
/*                                                                 */
/*#################################################################*/



/***********************
*
* FUNCTION: safe_hangup
*
* PURPOSE:  If the dialler is dialling, stop it. If the connection is online, hangup.
*
*/
void safe_hangup(void)
{
if(!silent)fprintf(stderr, "Entering the hangup routine\n");
  switch (mod_state)
  {
    case (state_dialling):
    {
if(!silent)fprintf(stderr, "We're dialling but not online. Issue a SWI DiallerB_Hangup\n");
      mod_state = state_offline;
      _swix(DiallerB_HangUp, _IN(0), 0);
      break;
    }
    case (state_online):
    {
if(!silent)fprintf(stderr, "We're online. Issue a PPP Disconnect\n");
      mod_state = state_hanging;
      oscli("PPPDisconnect");
      break;
    }
  }
}

/***********************
*
* FUNCTION: NCDialCtrl_swis
*
* PURPOSE:  SWI handler
*
*/
_kernel_oserror *NCDialCtrl_swis(int swi_no, _kernel_swi_regs *r, void *pw)
{
if(!silent){vdu4();fprintf(stderr,"Entering SWI NCDialCtrl\n");}
  switch (swi_no)
  {
    case (NCDial_Dial - NCDial_00):
    {
      Commence();
      break;
    }
    case (NCDial_Hangup - NCDial_00):
    {
      safe_hangup();
      break;
    }
    case (NCDial_Silent - NCDial_00):
    {
      silent = r->r[0];
      break;
    }
    default:
    {
if(!silent)fprintf(stderr, "unknown SWI (NCDialCtrl_swis)\n");
      break;
    }
  }

  return(NULL);
}

/*************************
*
* FUNCTION: NCDialCtrl_cmd
*
* PURPOSE:  *Command handler
*
*/
_kernel_oserror *NCDialCtrl_cmd(char *arg_string, int argc, int cmd_no, void *pw)
{
if(!silent){vdu4();fprintf(stderr,"Entering NCDialCtrl_cmd\n");}
  switch (cmd_no)
  {
    case CMD_NCDial_Dial:
    {
if(!silent)fprintf(stderr,"*NCDial_Dial\n");
      Commence();
      break;
    }
    case CMD_NCDial_Hangup:
    {
if(!silent)fprintf(stderr,"*NCDial_Hangup\n");
      safe_hangup();
      break;
    }
    case CMD_NCDial_Silent:
    {
if(!silent)fprintf(stderr,"*NCDial_Silent\n");
      silent = (0 != atoi(arg_string));
      break;
    }
    case CMD_NCDial_StartUp:
    {
if(!silent){vdu4();fprintf(stderr,"We've got a *NCDial_StartUp from PPP\n");}
      mod_state = state_online;
      DiallerService(NCDialler_IPUp);
      break;
    }
    case CMD_NCDial_GoingDown:
    {
if(!silent)fprintf(stderr,"We've got a *NCDial_GoingDown from PPP\n");
      mod_state = state_hanging;
      DiallerService(NCDialler_IPDown);
      _swix(DiallerB_HangUp, _IN(0), 0);
      break;
    }
    case CMD_NCDial_Repoint:
    {
if(!silent)fprintf(stderr,"*NCDial_Repoint\n");
/*       message_block mb;                                                   */
/*       memset (&mb, '\0', sizeof(message_block));                          */
/*       mb.header.size   = 32;                                              */
/*       mb.header.action = 0x4AF84;                                         */
/*       _swix(TaskModule_SendMessage, _INR(0, 5), 0, &mb, 0, 0, 0, 0);      */
      break;
    }
    case CMD_NCDial_MakeFiles:
    {
if(!silent)fprintf(stderr,"*NCDial_MakeFiles\n");
      CreateFiles(&card);
      break;
    }
    default:
    {
if(!silent)fprintf(stderr, "Unknown *Cmd (NCDialCtrl_cmd)\n");
      break;
    }
  }

  return (NULL);
}

/******************************
*
* FUNCTION: NCDialCtrl_modfinal
*
* PURPOSE:  Module finalise routine
*
*/
_kernel_oserror *NCDialCtrl_modfinal(int fatal, int podule, void *pw)
{
#ifndef DONT_BUILD_RESOURCES
  _swix(ResourceFS_DeregisterFiles, _IN(0), resources_base());
#endif

  return(NULL);
}

/**************************
*
* FUNCTION: NCDialCtrl_service
*
* PURPOSE:  Service call handler
*
*/
void NCDialCtrl_service(int service, _kernel_swi_regs *r, void *pw)
{
  switch (service)
  {
#ifndef DONT_BUILD_RESOURCES
    case Service_ResourceFSStarting:
    {
      /* This obscure line has the address of the start of a function passed in R2, and   */
      /* type casts that to a pointer to a function. This call takes resources_base() as  */
      /* it's only parameter. */
      ((P_FSStartingFN) (r->r[2])) (resources_base());
      break;
    }
#endif
    case Service_DiallerB:
    {
if(!silent)fprintf(stderr, "Entering Handle_diallerB_svc()\n");
      Handle_diallerB_svc(r->r[0]);
if(!silent)fprintf(stderr, "Exited Handle_diallerB_svc()\n");
      r->r[1] = 0;
      break;
    }
    default:
    {
/* if(!silent)fprintf(stderr, "unexpected service call received\n"); */
      break;
    }
  }
}

/*****************************
*
* FUNCTION: NCDialCtrl_modinit
*
* PURPOSE:  Module initialisation routine
*
*/
_kernel_oserror *NCDialCtrl_modinit(char *cmd_tail, int podule_base, void *pw)
{
  pwp = pw;
#ifndef DONT_BUILD_RESOURCES
  _swix(ResourceFS_RegisterFiles, _IN(0), resources_base());
#endif
  memset(&card, '\0', sizeof(carddata));
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), SERIALDEV_VAR, SERIALDEV_TXT, strlen(SERIALDEV_TXT), 0);
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), INET_VAR,      INET_TXT,      strlen(INET_TXT),      0);
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), DYNAMIC_VAR,   DYNAMIC_TXT,   strlen(DYNAMIC_TXT),   2);
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), INETDBASE_VAR, INETDBASE_TXT, strlen(INETDBASE_TXT), 2);
  /* twiddle modem to make sure it's offline here... */

  return(NULL);
}
