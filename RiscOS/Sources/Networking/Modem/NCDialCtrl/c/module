/*###########################################################################*
*                                                                            *
* FILE:    module.c                                                          *
*                                                                            *
* PROJECT: NCDialCtrl module - Funai                                         *
*                                                                            *
* PURPOSE: Main module source code                                           *
*                                                                            *
* VERSION: Version 1.12, Steve Revill 30th/June/1998                         *
*                                                                            *
*###########################################################################*/

#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "stddef.h"
#include "module.h"
#include "filegen.h"
#include "cmhg_modem.h"
#include "kernel.h"
#include "swis.h"
#include "wimp.h"
#include "sys/types.h"
#include "netinet/in.h"

#define os_removecursors()  _swix(OS_RemoveCursors,  0)
#define os_restorecursors() _swix(OS_RestoreCursors, 0)
#define int16 short
#define int32 long
/* Service call numbers */
#define Service_ResourceFSStarting 0x60
#define Service_ShutDown           0x7E
#define Service_ShutdownComplete   0x80
#define Service_DiallerStatus      0xB4
#define Service_DiallerB           0xC4
#define Service_NCRegistryStatus   0xBA
/* DiallerB service call status word (byte one) meanings */
#define dialB_svc0_not_contd       0x00
#define dialB_svc0_dialng          0x01
#define dialB_svc0_contng          0x02
/* DiallerB service call status word (byte zero) meanings */
#define dialB_svc_idle             0x00
#define dialB_svc_nodial           0x08
#define dialB_svc_busy             0x09
#define dialB_svc_nocarrier        0x06
#define dialB_svc_noserver         0x10
#define dialB_svc_timeout          0x05
#define dialB_svc_error0           0x04
#define dialB_svc_error1           0x07
#define dialB_svc_error2           0x11
#define dialB_svc_dialling         0x01
#define dialB_svc_hanging          0x02
#define dialB_svc_answering        0x03

/* NCDialCtrl_modinit definitions */
#define SERIALDEV_VAR "SerialDev$Path"
#define INET_VAR      "Inet$Path"
#define DYNAMIC_VAR   "FileDyn$Path"
#define INETDBASE_VAR "InetDBase$Path"
#define SERIALDEV_TXT "Resources:$.Resources.NCDialCtrl."
#define INET_TXT      "Resources:$.Resources.NCDialCtrl."
#define DYNAMIC_TXT   "<Wimp$ScrapDir>.NCDialCtrl."
#define INETDBASE_TXT "Inet:Files.,FileDyn:Files."
/* DiallerB SWI numbers */
#define DiallerB_Dial   0x50C80
#define DiallerB_HangUp 0x50C81
#define DiallerB_Status 0x50C82
/* Possible connection states */
#define state_offline     0  /* There is no connection or activity                         */
#define state_dialling    1  /* A PPPConnect has been issued but no IPUp received          */
#define state_ppp_goingup 2  /* IPUp received issuing a SWI DiallerB_Dial                  */
#define state_online      3  /* SVC call received from DaillerB saying we're connected     */
#define state_hanging     4  /* Issuing a PPPDisconnect, no IPDown yet                     */
                             /* We issue a SWI DiallerB_Hangup when we get IPDown from PPP */
#define PPP_TIMEOUT 30       /* Timeout for failiure at the ppp_goingup state              */

typedef void (*P_FSStartingFN)(void *r0);

#ifndef TRUE
#define FALSE 0
#define TRUE (!FALSE)
#endif

carddata    card;
void        *pwp;                        /* Private word pointer                        */
static int  mod_state  = state_offline;  /* Current state of the connection             */

/* When we do a *PPPConnect, we also issue a call after so we can detect if the connect */
/* failed (when 'verifying' in on the screen.                                           */
BOOL report_err = FALSE;                 /* Semaphore for reporting verifying timeouts  */
/* The callback handler seems to get called at more points the just when I use a        */
/* call after to generate a call back                                                   */


#ifdef developing
  BOOL debug = TRUE;  /* Debug output flag can be toggled with  SWI Silent  and  *Silent  */
#else
  BOOL debug = FALSE;
#endif

extern void callback(void (*irq_entry)(), void *);
extern void callafter(int, void (*irq_entry)(), void *);

char *cmos_number(void);
char *expand_special(char *temp);
void pause(int cs);
void LED_State(BOOL state);
void DiallerService(int reason);
void Commence(void);
void not_connected_svc(int byte);
void changing_svc(int byte);
void connecting_svc(int byte);
void Handle_diallerB_svc(int status);
void discon_func(void);
void safe_hangup(void);
void new_state(int new);



/*############################################################*/
/*                                                            */
/*                       Misc routines                        */
/*                                                            */
/*############################################################*/



void new_state(int new)
{
#ifdef developing
  DEBUG_TOP("Before: ");
  switch (mod_state)
  {
    case (state_offline):
    {
      DEBUG_PRINT("state = offline");
      break;
    }
    case (state_dialling):
    {
      DEBUG_PRINT("state = dialling");
      break;
    }
    case (state_ppp_goingup):
    {
      DEBUG_PRINT("state = ppp_goingup");
      break;
    }
    case (state_online):
    {
      DEBUG_PRINT("state = online");
      break;
    }
    case (state_hanging):
    {
      DEBUG_PRINT("state = hanging");
      break;
    }
  }
#endif
  mod_state = new;
#ifdef developing
  DEBUG_PRINT("  now: ");
  switch (mod_state)
  {
    case (state_offline):
    {
      DEBUG_PRINT("state = offline\n");
      break;
    }
    case (state_dialling):
    {
      DEBUG_PRINT("state = dialling\n");
      break;
    }
    case (state_ppp_goingup):
    {
      DEBUG_PRINT("state = ppp_goingup\n");
      break;
    }
    case (state_online):
    {
      DEBUG_PRINT("state = online\n");
      break;
    }
    case (state_hanging):
    {
      DEBUG_PRINT("state = hanging\n");
      break;
    }
  }
#endif
}

/********************************************************************************
 *
 * FUNCTION: pause
 *
 * PURPOSE:  Wait for a given number of centi-seconds
 *
 */
void pause(int cs)
{
  int finish;

  finish = monotonic_time() + cs;
  while (monotonic_time() < finish) {};
}

/************************
*
* FUNCTION: convert_digit
*
* PURPOSE:  Pack decimal digits into four bits
*
*/
static char *convert_digit(char *tag, int len, char *phone, BOOL pulse)
{
  char *chars = "0123456789*#,";
  int failed, nibble, packed, shift = 0;

  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), tag, &packed, 0, &failed);
  if (failed >= 0 && packed)
  {
    while (shift < (4 * (len - 1)))
    {
      nibble = (packed >> (shift ^ 4)) & 0xF;
      if (0 == nibble)
      {
        break;
      }
      if (pulse && chars[nibble - 1] == '*')
      {
        *phone = '1';
        phone++;
        *phone = '1';
        phone++;
      }
      else
      {
        *phone = chars[nibble - 1];
        phone++;
      }
      shift += 4;
    }
  }

  return(phone);
}

/***********************
*
* FUNCTION: cmos_number
*
* PURPOSE:  Extract some value from the CMOS
*
*/
char *cmos_number(void)
{
  static char phone[80];
  char  *ptr = NULL;
  int   pulse, callwaiting, failed, ignore, outside, wait;
  strcpy(phone, "AT");
  ptr = phone + strlen(phone);

  /* Blind dialling switch */
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemDialIgnore", &ignore, 0, &failed);
  if (failed >= 0 && ignore)
  {
    *ptr = 'X';
    ptr++;
    *ptr = '3';
    ptr++;
  }

  /* Dialling type */
  *ptr = 'D';
  ptr++;
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemDialType", &pulse, 0, &failed);

  if (failed >= 0 && pulse)
  {
/*     *ptr = 'P';           SAR 17/3/1998 - Controllerless modem won't do pulse dialling */
    *ptr = 'T';
    ptr++;
  }
  else
  {
    *ptr = 'T';
    ptr++;
  }

  /* Outside line */
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemPrefixStatus", &outside, 0, &failed);
  if (failed >= 0 && outside)
  {
    int len;
    _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemPrefix", 0, 0, &len);
    if (len > 0)
    {
      ptr = convert_digit("ModemPrefix", len*2, ptr, pulse);
      _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemDialTone", &wait, 0, &failed);
      if (failed >= 0 && wait)
      {
        *ptr = 'W';
        ptr++;
      }
      else
      {
        *ptr = ',';
        ptr++;
      }
    }
  }

  /* Call waiting defeat stuff */
  _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemCallWaitingStatus", &callwaiting, 0, &failed);
  if (failed >= 0 && callwaiting)
  {
    int len;
    _swix(NVRAM_Read, _INR(0, 2) | _OUT(0), "ModemCallWaiting", 0, 0, &len);
    if (len > 0)
    {
      ptr = convert_digit("ModemCallWaiting", len*2, ptr, pulse);
      *ptr = ',';
      ptr++;
    }
  }
  *ptr = '\0';
  ptr++;

  return(phone);
}

/***************
*
* FUNCTION: expand_special
*
* PURPOSE:  Replace the username and password with smart card data
*
*/
char *expand_special(char *temp)
{
  if (strlen(temp) > 0)
  {
    if (0 == strcmp(temp, "ATDT"))
    {
      temp = cmos_number();
      strcat(temp, card.pstnnum);
      strcat(temp, ";");
    }
    else
    if (0 == strcmp(temp, "send_user"))
    {
      temp = card.loginid;
    }
    else
    if (0 == strcmp(temp, "send_pass"))
    {
      temp = card.loginsecret;
    }
  }

  return(temp);
}

/*********************
*
* FUNCTION: LED_State
*
* PURPOSE:  Set the state of the NC's LEDs to reflect the online/offline state
*
*/
void LED_State(BOOL state)
{
  _swix(LED_Control, _INR(0, 2), 0, ~(1), state ? 1 : 0);
}



/*###########################################################################*/
/*                                                                           */
/*                        Application Specific Routines                      */
/*                                                                           */
/*###########################################################################*/



/**************************
*
* FUNCTION: DiallerService
*
* PURPOSE:  Issue a dialler service call (to the DiallerUI) and update the NC LEDs
*
*/
void DiallerService(int reason)
{
  if (reason == NCDialCtrl_IPDown)
  {
    LED_State(FALSE);
  }
  if (reason == NCDialCtrl_IPUp)
  {
    LED_State(TRUE);
  }

  if (0x80 == (reason & 0xF0))
  {
    if ((state_dialling == mod_state) || (state_ppp_goingup == mod_state))
    {
      DEBUG_TOPM((stderr, "Issuing a service call: %d\n", reason));
      DEBUG_ECHOM((d_file, "      Issuing a service call: %d\n", reason));
      _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, reason);
    }
    DEBUG_PRINT("          Svc indicates an error from DiallerB. Issuing svc call IPDown\n");
    new_state(state_offline);
    _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, NCDialCtrl_IPDown);
  }
  else
  {
    DEBUG_TOPM((stderr, "Issuing a service call: %d\n", reason));
    DEBUG_ECHOM((d_file, "      Issuing a service call: %d\n", reason));
    _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, reason);
  }

}

/********************
*
* FUNCTION: Commence
*
* PURPOSE:  Initialise the dialler to start a call
*
*/
void Commence(void)
{
  switch (mod_state)
  {
    case (state_online):
    {
      DEBUG_PRINT("    WARNING: 'Commence' state = online. Issue an IPUp svc\n")
      DiallerService(NCDialCtrl_IPUp);
      break;
    }

    case (state_offline):
    {
      DEBUG_PRINT("    state = offline\n");
      new_state(state_dialling);
      DiallerService(NCDialCtrl_Starting);
      if (FALSE == CreateFiles(&card))
      {
        DiallerService(NCDialCtrl_Error);     /* mod_state becomes state_offline as a side-effect of this call */
      }
      else
      {
        _kernel_oserror *err_block;

#ifdef force_reinit
        _swix(OS_Module, _INR(0, 1), 3, force_reinit);
#endif

        err_block = _swix(DiallerB_Dial, _INR(0, 4), 0, device_name, scrap_dial_scr, scrap_hang_scr, dial_speed);
        if (err_block)
        {
          DEBUG_PRINTM((stderr,"    Swi returned error num: %d  str: %s\n",err_block->errnum,err_block->errmess));
          DEBUG_ECHO("    Swi returned error\n");
          DiallerService(NCDialCtrl_Error);   /* mod_state becomes state_offline as a side-effect of this call */
        }
        else
        {
          DEBUG_PRINT("    Issuing a dialling svc call\n");
          DiallerService(NCDialCtrl_Dialling);
        }
      }
      break;
    }

    case (state_dialling):
    {
      DEBUG_PRINT("    WARNING: 'Commence' state = dialling. Issue a dialling svc\n");
      break;
    }

    case (state_ppp_goingup):
    {
      DEBUG_PRINT("    WARNING: 'Commence' state = ppp_goingup. Issue a connecting svc\n");
      break;
    }

    case (state_hanging):
    {
      DEBUG_PRINT("    WARNING: 'Commence' state = hanging\n");
      break;
    }
  }
}

/**************************
*
* FUNCTION: NCDialCtrl_callback_handler
*
* PURPOSE:  Callback handler
*
*/
_kernel_oserror *NCDialCtrl_callback_handler(_kernel_swi_regs *r, void *pw)
{
  if (pw == pwp)
  {
    DEBUG_PRINT("Entering the callback handler\n");

    if (report_err)
    {
      DiallerService(NCDialCtrl_NoServer);
    }
    report_err = FALSE;
    new_state(state_offline);
    _swix(DiallerB_HangUp, _IN(0), 0);

    DEBUG_PRINT("Exiting the callback handler\n");
  }

  return(NULL);
}

/**************************
*
* FUNCTION: NCDialCtrl_callafter_handler
*
* PURPOSE:  Callafter handler
*
*/
_kernel_oserror *NCDialCtrl_callafter_handler(_kernel_swi_regs *r, void *pw)
{
  if (pw == pwp)
  {
    if (state_ppp_goingup == mod_state)
    {
      callback(NCDialCtrl_callback_entry, pw);
    }
  }

  return(NULL);
}

/**************************
*
* FUNCTION: temp_func
*
* PURPOSE:  Handle a disconnected svc call from DiallerB
*
*/
void discon_func(void)
{
  switch (mod_state)
  {
    case (state_offline):
    {
      DEBUG_PRINT("    state = offline (no change)\n");
      break;
    }

    case (state_dialling):
    {
      DEBUG_PRINT("    WARNING: 'not_connected_svc' state = dialling\n");
//      new_state(state_offline);
      break;
    }

    case (state_ppp_goingup):
    {
      new_state(state_offline);
      break;
    }

    case (state_online):
    {
      DEBUG_PRINT("    WARNING: 'temp_func' state = online\n");
      new_state(state_offline);
      break;
    }

    case (state_hanging):
    {
      new_state(state_offline);
      break;
    }
  }
}

/**************************
*
* FUNCTION: not_connected_svc
*
* PURPOSE:  Handle a service call where byte 1 indicates that there is no connection (eg: an error)  (from the POV of the UI)
*
*/
void not_connected_svc(int byte)
{
  switch (byte)
  {
    case (dialB_svc_idle):
    {
      discon_func();
      break;
    }

    /* Main service calls are either echoed or useful for debug */
    case (dialB_svc_dialling):
    {
      DEBUG_PRINT("    Executing dial script\n");
      break;
    }
    case (dialB_svc_hanging):
    {
      DEBUG_PRINT("    Executing hangup script\n");
      break;
    }
    case (dialB_svc_answering):
    {
      DEBUG_PRINT("    Executing answer script\n");
      break;
    }
    case (dialB_svc_timeout):
    {
      DEBUG_PRINT("    Issue svc call timeout\n");
      DiallerService(NCDialCtrl_Timeout);
      break;
    }
    case (dialB_svc_error0):
    {
      DEBUG_PRINT("    Issue svc call error0\n");
      DiallerService(NCDialCtrl_Timeout);
      break;
    }
    case (dialB_svc_error1):
    {
      DEBUG_PRINT("    Issue svc call error1\n");
      DiallerService(NCDialCtrl_Timeout);
      break;
    }
    case (dialB_svc_nodial):
    {
      DEBUG_PRINT("    Issue svc call nodial\n");
      DiallerService(NCDialCtrl_NoDial);
      break;
    }
    case (dialB_svc_busy):
    {
      if (state_offline != mod_state)
      {
        DEBUG_PRINT("    Issue svc call busy\n");
        DiallerService(NCDialCtrl_Busy);
      }
      break;
    }
    case (dialB_svc_nocarrier):
    {
      if (state_offline != mod_state)
      {
        DEBUG_PRINT("    Issue svc call nocarrier\n");
        DiallerService(NCDialCtrl_NoCarrier);
      }
      break;
    }
    case (dialB_svc_error2):
    {
      if (state_offline != mod_state)
      {
        DEBUG_PRINT("    Issue svc call error2\n");
        DiallerService(NCDialCtrl_Error);
      }
      break;
    }
    case (dialB_svc_noserver):
    {
      if (state_offline != mod_state)
      {
        DEBUG_PRINT("    Issue svc call noserver\n");
        DiallerService(NCDialCtrl_NoServer);
      }
      break;
    }

    /* Catch-all for debug use only */
    default:
    {
      DEBUG_PRINT("    WARNING: 'not_connected_svc' ignored DiallerB byte 0\n");
      break;
    }
  }
}

/**************************
*
* FUNCTION: changing_svc
*
* PURPOSE:  Handle a service call where byte 1 indicates that the modem is dialling (from the POV of the UI)
*
*/
void changing_svc(int byte)
{
  switch (byte)
  {
    case (dialB_svc_dialling):
    {
      DEBUG_PRINT("    Ignore DiallerB svc call (executing dial script)\n");
      break;
    }
    case (dialB_svc_hanging):
    {
      DEBUG_PRINT("    DiallerB is executing the hangup script and the state is changing (force offline state)\n");
      new_state(state_offline);
/* Hack - temporary to fix problem with PPP timeout after period of innactivity, then, when you try */
/* to move the browser, you get an error (saying it was unable to fetch the page). When you try */
/* again, the line is brought back up correctly. I'm trying to make it work right first time... */
/* DiallerService(NCDialCtrl_IPDown); */
/* End of hack */
      break;
    }
    default:
    {
      DEBUG_PRINT("    Some connection state changing service call\n");
      break;
    }
  }
}

/**************************
*
* FUNCTION: connecting_svc
*
* PURPOSE:  Handle a service call where byte 1 indicates that the modem is connecting (from the POV of the UI)
*
*/
void connecting_svc(int byte)
{
  if (byte == dialB_svc_idle)
  {
    switch (mod_state)
    {
      case (state_offline):
      {
        DEBUG_PRINT("    WARNING: 'connecting_svc' state = offline\n");
        break;
      }

      case (state_dialling):
      {
        new_state(state_ppp_goingup);
        DiallerService(NCDialCtrl_Connected);

        DEBUG_PRINT("    Issuing a callafter for failed PPP connects\n");
        callafter(100 * PPP_TIMEOUT, NCDialCtrl_callafter_entry, pwp);
        report_err = TRUE;

        DEBUG_PRINT("    Issuing a PPP connect\n");
        oscli("PPPConnect");
        break;
      }

      case (state_ppp_goingup):
      {
        DEBUG_PRINT("    WARNING: 'connecting_svc' state = ppp_goingup\n");
        break;
      }

      case (state_online):
      {
        DEBUG_PRINT("    WARNING: 'connecting_svc' state = online\n");
        break;
      }

      case (state_hanging):
      {
        DEBUG_PRINT("    WARNING: 'connecting_svc' state = hanging\n");
        break;
      }
    }
  }
  else
  {
    DEBUG_PRINT("    Byte0 is not idle. So it's not a (dis)connecting svc call\n");
  }
}

/**************************
*
* FUNCTION: new_status_string
*
* PURPOSE:  If DiallerB indicates that it's status has changed, see if it is a Dialled status (that
*           we inserted in the dial script). If it is, issue a connecting service call.
*
*/
static void new_status_string(void)
{
  int  len     = 0;
  char *buffer = NULL;

  _swix(DiallerB_Status, _INR(0, 1) | _OUT(0), 2, 0, &len);
  if (len > 0)
  {
    buffer = malloc(len);
    _swix(DiallerB_Status, _INR(0, 2), 2, buffer, len);
    if (0 == strcmp(buffer, finish_dial))
    {
      DiallerService(NCDialCtrl_Connecting);
    }
    free(buffer);
  }
}

/**************************
*
* FUNCTION: Handle_diallerB_service
*
* PURPOSE:  On receiving a service call from DiallerB, issue the correct service call to the UI
*
*/
void Handle_diallerB_svc(int status)
{
  int byte_zero, byte_one;

  if (status & (1 << 18))
  {
    new_status_string();
  }

  byte_zero = status & 0xFF;
  byte_one  = (status >> 8) & 3;

  DEBUG_PRINTM((stderr, "  SVC NUMBER WAS %d %d\n", byte_one, byte_zero));
  DEBUG_ECHOM((d_file, "  SVC NUMBER WAS %d %d\n", byte_one, byte_zero));
  switch (byte_one)
  {
    case (dialB_svc0_not_contd):
    {
      DEBUG_PRINT("  Not connected SVC received\n");
      not_connected_svc(byte_zero);
      break;
    }
    case (dialB_svc0_dialng):
    {
      DEBUG_PRINT("  Connection state changing SVC received from DiallerB\n");
      changing_svc(byte_zero);
      break;
    }
    case (dialB_svc0_contng):
    {
      DEBUG_PRINT("  Connecting SVC received\n");
      connecting_svc(byte_zero);
      break;
    }
    default:
    {
      DEBUG_PRINT("  Unexpected DiallerB service call (connected incoming)\n");
      break;
    }
  }
}



/*#################################################################*/
/*                                                                 */
/*                   Standard Module Routines                      */
/*                                                                 */
/*#################################################################*/



/***********************
*
* FUNCTION: safe_hangup
*
* PURPOSE:  If the dialler is dialling, stop it. If the connection is online, hangup.
*
*/
void safe_hangup(void)
{
  DEBUG_PRINT("  Entering the hangup routine\n");
  switch (mod_state)
  {
    case (state_offline):
    {
      DEBUG_PRINT("    WARNING: 'safe_hangup' state = offline\n");
      break;
    }

    case (state_dialling):
    {
      DEBUG_PRINT("    We're dialling but not online. Issue a SWI DiallerB_Hangup\n");
      new_state(state_offline);
      _swix(DiallerB_HangUp, _IN(0), 0);
      break;
    }

    case (state_ppp_goingup):
    {
      DEBUG_PRINT("    WARNING: 'safe_hangup' state = ppp_goingup\n");
      new_state(state_offline);
      _swix(DiallerB_HangUp, _IN(0), 0);
      break;
    }

    case (state_online):
    {
      DEBUG_PRINT("    We're online. Issue a PPP Disconnect\n");
      new_state(state_hanging);
      oscli("PPPDisconnect");
      break;
    }

    case (state_hanging):
    {
      DEBUG_PRINT("    WARNING: 'safe_hangup' state = hanging\n");
      break;
    }
  }
  DEBUG_PRINT("  Exiting the hangup routine\n");
}

/***********************
*
* FUNCTION: NCDialCtrl_swis
*
* PURPOSE:  SWI handler
*
*/
_kernel_oserror *NCDialCtrl_swis(int swi_no, _kernel_swi_regs *r, void *pw)
{
  DEBUG_TOP("Entering SWI NCDialCtrl\n");
  switch (swi_no)
  {
    case (NCDial_Dial - NCDial_00):
    {
      DEBUG_PRINT("  SWI Dial\n");
      Commence();
      break;
    }
    case (NCDial_Hangup - NCDial_00):
    {
      DEBUG_PRINT("  SWI Hangup\n");
      safe_hangup();
      break;
    }
#ifndef developing
    case (NCDial_Silent - NCDial_00):
    {
      DEBUG_PRINT("  SWI Silent\n");
      debug = (0 == (r->r[0]));
      break;
    }
#endif
    default:
    {
      DEBUG_PRINT("  unknown SWI (NCDialCtrl_swis)\n");
      break;
    }
  }
  DEBUG_PRINT("Exiting SWI NCDialCtrl\n");

  return(NULL);
}

/*************************
*
* FUNCTION: NCDialCtrl_cmd
*
* PURPOSE:  *Command handler
*
*/
_kernel_oserror *NCDialCtrl_cmd(const char *arg_string, int argc, int cmd_no, void *pw)
{
  DEBUG_TOP("Entering *cmd handler\n");
  switch (cmd_no)
  {
    case (CMD_NCDial_Dial):
    {
      DEBUG_PRINT("  *NCDial_Dial\n");
      Commence();
      break;
    }
    case (CMD_NCDial_Hangup):
    {
      DEBUG_PRINT("  *NCDial_Hangup\n");
      safe_hangup();
      break;
    }
    case (CMD_NCDial_StartUp):
    {
      DEBUG_PRINT("  *NCDial_StartUp from PPP\n");
      report_err = FALSE;                           /* When the callback happens, it won't report an error */
      new_state(state_online);
      DiallerService(NCDialCtrl_IPUp);
      break;
    }
    case (CMD_NCDial_GoingDown):
    {
      new_state(state_hanging);
      DEBUG_PRINT("  *NCDial_GoingDown from PPP\n");
      DiallerService(NCDialCtrl_IPDown);
      DEBUG_PRINT("    Issuing SWI HangUp\n");
      _swix(DiallerB_HangUp, _IN(0), 0);
      break;
    }
    case (CMD_NCDial_Repoint):
    {
      DEBUG_PRINT("  *NCDial_Repoint\n");
/*       message_block mb;                                                   */
/*       memset (&mb, '\0', sizeof(message_block));                          */
/*       mb.header.size   = 32;                                              */
/*       mb.header.action = 0x4AF84;                                         */
/*       _swix(TaskModule_SendMessage, _INR(0, 5), 0, &mb, 0, 0, 0, 0);      */
      break;
    }
    case (CMD_NCDial_MakeFiles):
    {
      DEBUG_PRINT("  *NCDial_MakeFiles\n");
      CreateFiles(&card);
      break;
    }
#ifndef developing
    case (CMD_NCDial_Silent):
    {
      DEBUG_PRINT("  *NCDial_Silent\n");
      debug = (0 == atoi(arg_string));
      break;
    }
#endif
    default:
    {
      DEBUG_PRINT("  Unknown *Cmd (NCDialCtrl_cmd)\n");
      break;
    }
  }
  DEBUG_PRINT("Exiting the *cmd handler\n");

  return (NULL);
}

/******************************
*
* FUNCTION: NCDialCtrl_modfinal
*
* PURPOSE:  Module finalise routine
*
*/
_kernel_oserror *NCDialCtrl_modfinal(int fatal, int podule, void *pw)
{
#ifdef BUILD_RESOURCES
  _swix(ResourceFS_DeregisterFiles, _IN(0), resources_base());
#endif

  return(NULL);
}

/**************************
*
* FUNCTION: NCDialCtrl_service
*
* PURPOSE:  Service call handler
*
*/
void NCDialCtrl_service(int service, _kernel_swi_regs *r, void *pw)
{
  switch (service)
  {
#ifdef BUILD_RESOURCES
    case (Service_ResourceFSStarting):
    {
      /* This obscure line has the address of the start of a function passed in R2, and  */
      /* type casts that to a pointer to a function. This call takes resources_base() as */
      /* it's only parameter.                                                            */
      ((P_FSStartingFN) (r->r[2])) (resources_base());
      break;
    }
#endif
    case (Service_DiallerB):
    {
      DEBUG_TOP("DiallerB has issued a service call\n");
      Handle_diallerB_svc(r->r[0]);
      r->r[1] = 0;   /* Don't pass this svc call on... */
      break;
    }
    case (Service_ShutdownComplete):
    {
      DEBUG_PRINT("  Standby mode (svc Shutdown)\n");
      safe_hangup();
      break;
    }
  }
}

/*****************************
*
* FUNCTION: NCDialCtrl_modinit
*
* PURPOSE:  Module initialisation routine
*
*/
_kernel_oserror *NCDialCtrl_modinit(const char *cmd_tail, int podule_base, void *pw)
{
  pwp = pw;
#ifdef BUILD_RESOURCES
  _swix(ResourceFS_RegisterFiles, _IN(0), resources_base());
#endif
  memset(&card, '\0', sizeof(carddata));
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), SERIALDEV_VAR, SERIALDEV_TXT, strlen(SERIALDEV_TXT), 0);
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), INET_VAR,      INET_TXT,      strlen(INET_TXT),      0);
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), DYNAMIC_VAR,   DYNAMIC_TXT,   strlen(DYNAMIC_TXT),   2);
  _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), INETDBASE_VAR, INETDBASE_TXT, strlen(INETDBASE_TXT), 2);

  DEBUG_TOP("STARTING\n");
  new_state(state_offline);

  return(NULL);
}
