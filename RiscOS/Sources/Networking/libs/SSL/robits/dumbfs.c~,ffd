/* x509_dum.c - Wrapper layer for dumb filing systems that don't have softlinks. */
/* (C) ANT Limited 1995. All rights reserved. */

/***************************************************************/
/*                                                             */
/* Each directory holds a set of records. Each record holds    */
/* a type, a 'big' name and a 'small' local name. This permits */
/* nearly arbitary filenames to be stored on FAT and RISCOS    */
/* file partitions by providing a layer of indirection. By     */
/* permitting multiple big names to point at a single small    */
/* name, much the same effect as soft links may be achieved.   */
/*                                                             */
/* A real file or directory always lies at the end of a        */
/* successful 'dereference'. This means only a few points      */
/* of interception are necessary.                              */
/*                                                             */
/***************************************************************/


#include <stdio.h>
#include <ctype.h>
#include "kernel.h"
#include <string.h>
#include <unistd.h>

#define DUMBFS_MAXLINE			256

/*

Line format:

TBIGNAME SMALLNAME

T           Type - single digit
BIGNAME     Pretend name
SMALLNAME   Real name - meets local restrictions

*/

/* How many characters from this filename specify the directory? */

static int dumbfs_dirlen(char *fname)
{
    char *cp = strrchr(fname, DUMBFS_DIRSEP);
    if (cp == NULL)
    {
        return 0;
    }
    else
    {
        return cp - fname;
    }
}

static char *dumbfs_findnonspace(char *cp)
{
    if (cp == NULL)
        return NULL;

    while (*cp != 0)
    {
        if ( isspace(*cp) )
            cp++;
        else
            break;
    }

    return cp;
}

static char *dumbfs_findspace(char *cp)
{
    if (cp == NULL)
        return NULL;

    while (*cp != 0)
    {
        if ( ! isspace(*cp) )
            cp++;
        else
            break;
    }

    return cp;
}


static char *dumbfs_lookup(char *fname, int *type, char **realname)
{
    static char buffer[DUMBFS_MAXLINE+1];
    const int dirlen = dumbfs_dirlen(fname);
    const int cmplen = strlen(fname) - dirlen - 1;
    FILE *fp;

    sprintf(buffer, "%.*s%c%s", dirlen, fname, DUMBFS_DIRSEP, DUMBFS_DBNAME);
    fprintf(stderr, "dumbfs_lookup('%s', .., ..) using DB %s\n", fname, buffer);
    fp = fopen(buffer, "r");

    while ( fgets(buffer, DUMBFS_MAXLINE, fp) != NULL )
    {
        if (strlen(buffer) < 3) 
            continue;
        if ( strncmp(fname + dirlen + 1, buffer + 1, cmplen) == 0)
        {
            char *cp1, *cp2;    
            int endlen;

            fprintf(stderr, "Matched on line: %s", buffer);

            cp1 = dumbfs_findspace(&buffer[0] + 1);
            cp1 = dumbfs_findnonspace(cp1);
            cp2 = dumbfs_findspace(cp1);
            endlen = cp2 - cp1;
            memmove(buffer + DUMBFS_MAXLINE - endlen, cp1, endlen);
            sprintf(buffer, "%.*s%c%.*s", dirlen, fname, DUMBFS_DIRSEP, endlen, cp1);

            if (type != NULL)
                *type = buffer[0] - '0';
            if (realname)
                *realname = buffer;

            fprintf(stderr, "Returning new name '%s'\n", buffer);
            fclose(fp);
            return buffer;
        }
    }

    fclose(fp);

    if (type != NULL)
        *type = DUMBFS_UNKNOWN;
    if (realname)
        *realname = fname;

    return fname;
}


extern FILE *dumbfs_fopen(char *fname, char *mode)
{
    FILE *fp;
    char *newname = dumbfs_lookup(fname,NULL,NULL);
    return fopen(newname, mode);
}


extern int dumbfs_fclose(FILE *fp)
{
    return fclose(fp);
}


/* @@@@ the contents of a struct stat get used as pseudo-random */
/* data for initialising various bits of the crypto stuff. As all */
/* we do is fill in one word, this won't be very secure. */

/* The st_size and st_mode fields are the only fields directly examined. */

extern int stat(char *fname, struct stat *st)
{
#ifdef __riscos
	_kernel_osfile_block bk;
	
	if ( _kernel_osfile(17, fname, &bk) < 0 )
		{
	        return -1;
	        }
	
        st->st_size = bk.start;
        return 0;
#endif
}




extern int dumbfs_stat(char *fname, struct stat *st)
{
    return stat(dumbfs_lookup(fname, NULL, NULL), st);
}


extern int getch(void)
{
   return _kernel_osrdch();
}

/* eof */



