; -*-As-*-
;
; $Header$
; $Source$
;
; Copyright (c) 1995 Acorn Computers Ltd., Cambridge, UK
;
; makecall.s - based upon code generated by Norcroft RISC OS ARM C
;              vsn 5.06 (Acorn Computers Ltd) [Jun 26 1995]
;
; $Log$
; Revision 1.1  95/08/17  18:41:56  kwelton
; Initial revision
; 

	AREA |As$$code|, CODE, READONLY

	IMPORT	__rt_stkovf_split_small
	IMPORT	_kernel_swi

;
; **********************************************************************
;
; makecall - call the Internet module, and deal with the return value
;
; int _makecall(int swinum, _kernel_swi_regs *in, _kernel_swi_regs *out)
;

;
; this is "_makecall", for the benefit of stack backtracing
;
	DCB	&5f, &6d, &61, &6b
	DCB	&65, &63, &61, &6c
	DCB	&6c, &00, &00, &00
	DCD	&ff00000c

	EXPORT	_makecall
_makecall
	MOV	 ip, sp
	STMDB	 sp!, {a1-a4}
	STMDB	 sp!, {v1-v3, fp, ip, lr, pc}
	SUB	 fp, ip, #&14

;
; stack limit checking
;
	CMP	 sp, sl
	BLLT	 __rt_stkovf_split_small

;
; SWI &16 is OS_EnterOS: by making the call to the Internet module
; from SVC mode, we can make sure that no callbacks go off between
; detecting an error and copying the error block into _inet_error.
;
	SWI	&16

;
; make the SWI call, result into v3, setting Z flag in the process
;
	MOV	v1, a3
	BL	_kernel_swi
	MOVS	v3, a1

	LDR	lr, adrerrno
	MOVEQ	a1, #0
	STREQ	a1, [lr, #0]
	BEQ	OKreturn

;
; SWI call failed - fill in errno, and copy error block into _inet_error
; first step is to read the error number, and decide whether it is a
; properly formatted inet error (inet errorblock should start at 0x20e00,
; but it currently starts at 0 because of all the applications out there
; that expect this to be the case).
;
	LDR	a1, [v3, #0]
	BIC	a2, a1, #&ff
	SUB	a4, a2, #&20c00
	TEQ	a4, #&200
	BNE	noerrblock

;
; using inet error block: offsets 0-7f should be converted to an errno
; style number, other errors should be left alone.
;
	AND	a2, a1, #&ff
	CMP	a2, #&80
	ANDLT	a1, a1, #&7f

noerrblock
	STR	a1, [lr, #0]
	LDR	v2, adr_inet_error

;
; copy error block into _inet_error which is 256 bytes long
;
	MOV	ip, #&2

0
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	LDMIA	v3!, {a1-a4}
	STMIA	v2!, {a1-a4}
	SUBS	ip, ip, #1
	BNE	%b0

;
; if( errno > EREMOTE )
;     errno = ESRCH;
;
	CMP	a1, #&47
	MOVGT	a1, #3
	STRGT	a1, [lr, #0]

;
; back to user mode before returning error to caller
;
	TEQP	pc, #0

	MVN	a1, #0				; non-banked register: OK
	LDMDB	fp, {v1-v3, fp, sp, pc}^

;
; back to user mode before returning to caller
;
OKreturn
	TEQP	pc, #0

	LDR	a1, [v1, #0]			; non-banked registers: OK
	LDMDB	fp, {v1-v3, fp, sp, pc}^

adrerrno
	DCD	errno
adr_inet_error
	DCD	_inet_error

; **********************************************************************

	AREA |As$$data|, DATA

	EXPORT	errno
errno
	DCD	&00000000

	EXPORT	_inet_error
_inet_error
	DCD	&00000000
	%	252

	END

; EOF makecall.s
