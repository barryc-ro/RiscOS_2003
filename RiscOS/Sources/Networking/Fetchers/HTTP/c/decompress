/*
 * HTTP (c.decompress)
 *
 * © Acorn Computers Ltd. 1998
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "sys/errno.h"
#include "module.h"
#include "socklib.h"
#include "cookie.h"
#include "protocol.h"
#include "writedata.h"
#include "header.h"
#include "generic.h"

#ifdef COMPRESSION

int decompress(Session *ses, char *buffer, int bufsize, int toread, int *rawread)
{
        int dataread;
        int orig_toread = toread;

        ses->zstream.next_out = (Bytef *) buffer;
        ses->zstream.avail_out = bufsize;

        for (;;) {

            switch (ses->compstate) {
                case compress_INFLATE:
                    #ifdef TRACE
                    protocol_debug("decompress: INFLATE\n");
                    #endif

                    if (ses->zstream.avail_in) {
                            /* Something left over from last time */
                            int ret = inflate(&ses->zstream, Z_NO_FLUSH);
                            if (ret == Z_STREAM_END) {
                                    inflateEnd(&ses->zstream);
                                    ses->compression = compression_NONE;
                                    ses->compstate = compress_FINISHED;
                            }
                            else if (ret != Z_OK) {
                                    #ifdef TRACE
                                    protocol_debug("inflate error: %s\n", ses->zstream.msg);
                                    #endif
                                    *rawread = orig_toread - toread;
                                    return 0;
                            }
                    }
                    while (ses->zstream.avail_in == 0 && ses->zstream.avail_out > 0 && toread > 0 && ses->compstate == compress_INFLATE) {
                            int ret;
                            dataread = ses->op->s_recv(ses->sd, ses->compbuf, toread > ses->compbufsize ? ses->compbufsize : toread, 0);
                            if (dataread > 0) {
                                    toread -= dataread;
                                    ses->zstream.next_in = ses->compbuf;
                                    ses->zstream.avail_in = dataread;
                                    ret = inflate(&ses->zstream, Z_NO_FLUSH);
                                    if (ret == Z_STREAM_END) {
                                            inflateEnd(&ses->zstream);
                                            ses->compression = compression_NONE;
                                            ses->compstate = compress_FINISHED;
                                    }
                                    else if (ret != Z_OK) {
                                            #ifdef TRACE
                                            protocol_debug("inflate error: %s\n", ses->zstream.msg);
                                            #endif
                                            *rawread = orig_toread - toread;
                                            return 0;
                                    }
                            }
                            else if (dataread == 0) {
                                    inflateEnd(&ses->zstream);
                                    ses->compression = compression_NONE;
                                    ses->compstate = compress_FINISHED;
                                    *rawread = orig_toread - toread;
                                    return dataread;
                            }
                            else {
                                    *rawread = orig_toread - toread;
                                    return dataread;
                            }
                    }
                    *rawread = orig_toread - toread;
                    return (char *) ses->zstream.next_out - buffer;

                case compress_READ_GZIP_HEADER:
                    #ifdef TRACE
                    protocol_debug("decompress: READ_GZIP_HEADER\n");
                    #endif

                    if (ses->zstream.next_in == Z_NULL) {
                            ses->zstream.next_in = ses->compbuf;
                            ses->zstream.avail_in = 0;
                    }

                    dataread = ses->op->s_recv(ses->sd, ses->zstream.next_in, toread > 10 - ses->zstream.avail_in ? 10 - ses->zstream.avail_in : toread, 0);
                    if (dataread <= 0) {
                            *rawread = orig_toread - toread;
                            return dataread;
                    }

                    toread -= dataread;
                    ses->zstream.avail_in += dataread;
                    if (ses->zstream.avail_in < 10) {
                            *rawread = orig_toread - toread;
                            errno = EWOULDBLOCK;
                            return -1;
                    }

                    if (ses->compbuf[0] != 0x1F || ses->compbuf[1] != 0x8B ||
                        ses->compbuf[2] != 8) {
                            *rawread = orig_toread - toread;
                            return 0;
                    }

                    ses->compflags = ses->compbuf[3];
                    ses->compstate = compress_READ_GZIP_EXTRA;
                    ses->zstream.next_in = ses->compbuf;
                    ses->zstream.avail_in = 0;
                    /* Fall through */

                case compress_READ_GZIP_EXTRA:
                    #ifdef TRACE
                    protocol_debug("decompress: READ_GZIP_EXTRA\n");
                    #endif

                    if (ses->compflags & 0x04) {
                            int s;
                            if (ses->zstream.avail_in < 2) {
                                    dataread = ses->op->s_recv(ses->sd, ses->zstream.next_in, toread > 2 - ses->zstream.avail_in ? 2 - ses->zstream.avail_in : toread, 0);
                                    if (dataread <= 0) {
                                            *rawread = orig_toread - toread;
                                            return dataread;
                                    }
                                    toread -= dataread;
                                    ses->zstream.avail_in += dataread;
                                    if (ses->zstream.avail_in < 2) {
                                            *rawread = orig_toread - toread;
                                            errno = EWOULDBLOCK;
                                            return -1;
                                    }
                                    ses->zstream.avail_out = ses->compbuf[0] + 256 * ses->compbuf[1];
                            }
                          suck_more:
                            s = ses->compbufsize > ses->zstream.avail_out ? ses->compbufsize : ses->zstream.avail_out;
                            s = toread > s ? s : toread;
                            dataread = ses->op->s_recv(ses->sd, ses->compbuf, s, 0);
                            toread -= dataread;
                            if (dataread <= 0) {
                                    *rawread = orig_toread - toread;
                                    return dataread;
                            }

                            ses->zstream.avail_out -= dataread;
                            if (ses->zstream.avail_out > 0)
                                    goto suck_more;
                    }

                    ses->compstate = compress_READ_GZIP_NAME;
                    ses->zstream.next_in = ses->compbuf;
                    ses->zstream.avail_in = 0;
                    /* Fall through */

                case compress_READ_GZIP_NAME:
                    #ifdef TRACE
                    protocol_debug("decompress: READ_GZIP_NAME\n");
                    #endif

                    if (ses->compflags & 0x08) {
                            suck_more_fname:
                            dataread = ses->op->s_recv(ses->sd, ses->compbuf, toread > ses->compbufsize ? ses->compbufsize : toread, 0);
                            if (dataread <= 0) {
                                    *rawread = orig_toread - toread;
                                    return dataread;
                            }
                            toread -= dataread;
                            for (ses->zstream.next_in=ses->compbuf,
                                 ses->zstream.avail_in=dataread;
                                 ses->zstream.avail_in;
                                 ses->zstream.next_in++,
                                 ses->zstream.avail_in--) {
                                    if (*ses->zstream.next_in == 0) goto finished_fname;
                            }

                            goto suck_more_fname;

                    }
                    finished_fname:
                    ses->compstate = compress_READ_GZIP_COMMENT;
                    /* Fall through */

                case compress_READ_GZIP_COMMENT:
                    #ifdef TRACE
                    protocol_debug("decompress: READ_GZIP_COMMENT\n");
                    #endif

                    if (ses->compflags & 0x10) {
                          suck_more_comment:
                            for ( ; ses->zstream.avail_in;
                                ses->zstream.next_in++,
                                 ses->zstream.avail_in--) {
                                    if (*ses->zstream.next_in == 0) goto finished_comment;
                            }
                            dataread = ses->op->s_recv(ses->sd, ses->compbuf, toread > ses->compbufsize - 2 ? ses->compbufsize - 2 : toread, 0); /* Leave room for CRC... */
                            if (dataread <= 0) {
                                    *rawread = orig_toread - toread;
                                    return dataread;
                            }
                            toread -= dataread;
                            ses->zstream.next_in = ses->compbuf;
                            ses->zstream.avail_in = dataread;
                            goto suck_more_comment;

                    }
                  finished_comment:
                    ses->compstate = compress_READ_GZIP_HCRC;
                    /* Fall through */

                case compress_READ_GZIP_HCRC:
                    #ifdef TRACE
                    protocol_debug("decompress: READ_GZIP_HCRC\n");
                    #endif

                    if (ses->compflags & 0x02) {
                            if (ses->zstream.avail_in < 2) {
                                    dataread = ses->op->s_recv(ses->sd, ses->zstream.next_in, toread > 2 - ses->zstream.avail_in ? 2 - ses->zstream.avail_in : toread, 0);
                                    if (dataread <= 0) {
                                            *rawread = orig_toread - toread;
                                            return dataread;
                                    }

                                    toread -= dataread;
                                    ses->zstream.next_in += dataread;
                                    ses->zstream.avail_in += dataread;
                                    if (ses->zstream.avail_in < 2) {
                                            *rawread = orig_toread - toread;
                                            errno = EWOULDBLOCK;
                                            return -1;
                                    }
                            }
                            ses->zstream.avail_in -= 2;
                    }
                    ses->compstate = compress_INFLATE;
                    break;

                case compress_FINISHED:
                    dataread=0;

            }
        }

        *rawread = orig_toread - toread;
        return dataread;
}

#endif
