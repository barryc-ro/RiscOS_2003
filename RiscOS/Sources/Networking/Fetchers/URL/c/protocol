/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source$
 *
 * $Log$
 * Revision 1.1.1.1  1998/01/29 18:32:35  sbrodie
 * Import from SrcFiler of Browser fetchers
 *
 * Revision 1.1  95/09/08  09:35:04  pwain
 * Initial revision
 *
 * © Acorn Computers Ltd. 1995-1997
 *
 * Protocol handler. Deals with all the protocol modules;
 * registering, deregistering and assiging requests to the correct
 * SWI base.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "swis.h"
#include "url.h"
#include "protocol.h"
#include "utils.h"
#include "externs.h"
#include "generic.h"
#include "URLHdr.h"
#include "protoflags.h"

typedef struct proto {
	char *url_base;		/* base that protocol deals with */
	unsigned int swi_base; 	/* SWI Base for module */
	unsigned int version;	/* Module version number */
	unsigned int port_no;	/* Default TCP port number for this protocol */
	int flags;		/* Protocol flags */
	char info[50];		/* Small info string */
	struct proto *next;	/* wibble! */
} Protocol;

static Protocol *protocols=NULL;

static int proto_default_flags(const char *);
static unsigned int protocol_default_port_number(const char *url);

static void lower_string(char *ptr)
{
        while (*ptr) {
                if (isupper(*ptr)) {
                        *ptr = tolower(*ptr);
                }
                ++ptr;
        }
}

_kernel_oserror *protocol_register(_kernel_swi_regs *r)
{
        Protocol *proto;
	unsigned int swibase;
	char *protostr = Strdup((char *) r->r[2]);

	if (protostr == NULL) {
                return make_error(url_ERROR_MEMORY_EXHAUSTED, 0);
	}

	lower_string(protostr);

	/* check to see if a protocol already has the same URL_Base */
	swibase = protocol_get_swibase(protostr);
	if (swibase != 0) {
		return make_error(url_ERROR_PROTOCOL_EXISTS, 0);
	}

    	proto = malloc(sizeof(Protocol));
    	if (proto == NULL) {
    	        return make_error(url_ERROR_MEMORY_EXHAUSTED, 0);
    	}
    	else {
    	        proto->next=protocols;
    		protocols=proto;
    	}

    	/* save the swi base, protocol base & version number */
    	proto->swi_base = r->r[1];
    	proto->version = r->r[3];
    	proto->url_base = protostr;

	proto->info[0] = '\0';
    	if (r->r[4] != 0) {
      		strncat(proto->info, (char *) r->r[4], sizeof(proto->info));
    	}

	if (r->r[0] & 1) {
                proto->flags = r->r[5];
	}
	else {
	        proto->flags = proto_default_flags(proto->url_base);
	}

	if (r->r[0] & 2) {
	        proto->port_no = r->r[6];
	}
	else {
	        proto->port_no = protocol_default_port_number(proto->url_base);
	}

	_swix(OS_ServiceCall, _INR(0,4), 0, URL_00+1, proto->url_base, proto->swi_base,
		proto->info);

    	return NULL;
}

_kernel_oserror *protocol_deregister(_kernel_swi_regs *r)
{
	const unsigned int swibase = r->r[1];
	char *protostr = (r->r[0] & 1) ? (char *) r->r[2] : NULL;
	Protocol *proto;
	Protocol *owner=NULL;

	for (proto=protocols; proto; owner=proto, proto=proto->next) {
		if (proto->swi_base != swibase) continue;
		if (protostr != NULL) {
		        if (Strcmp_ci(proto->url_base, protostr) != 0) {
                                continue;
		        }
		}
		if (owner == NULL) {
			protocols = proto->next;
		}
		else {
			owner->next = proto->next;
		}
		_swix(OS_ServiceCall, _INR(0,4), 1, URL_00+1, proto->url_base, proto->swi_base,
			proto->info);
		free(proto->url_base);
		free(proto);
	}

	return NULL;
}

int protocol_get_details(int ctr, char **name, char **help, int *swibase, int *version)
{
	Protocol *proto;
        int count = 0;

        for (proto = protocols; proto && count < ctr; proto = proto->next) {
                ++count;
        }

	if (proto == NULL) {
	        return -1;
	}
	else {
	        *name = proto->url_base;
	        *help = proto->info;
	        *swibase = proto->swi_base;
	        *version = proto->version;
	        return count + 1;
	}
}

static const Protocol *protocol_locate(const char *url)
{
        const Protocol *proto;
	const size_t lenurl = strlen(url);

	for (proto=protocols; proto; proto=proto->next) {
	        size_t protolen = strlen(proto->url_base);
	        if (protolen == (lenurl + 1)) --protolen;
		if (!Strncmp_ci(proto->url_base, url, protolen)) {
			return proto;
		}
	}

	return NULL;
}

int protocol_get_flags(const char *url)
{
	const Protocol *proto = protocol_locate(url);
	return proto ? proto->flags : proto_default_flags(url);
}

/*
 * Given a URL, scan through the list of avaliable protocols and
 * establish which SWI base to use.
 */
unsigned int protocol_get_swibase(const char *url)
{
	const Protocol *proto = protocol_locate(url);
	return proto ? proto->swi_base : 0;
}

_kernel_oserror *protocol_list(void)
{
        const char *buffer = NULL;
        size_t len;
        _kernel_oserror *e;

	if (protocols==NULL) {
	        e = read_message("PS00", &buffer, &len);
	        if (e != NULL) return e;
                printf("%.*s\n", len, buffer);
	}
	else {
	        e = read_message("PS01", &buffer, &len);
	        if (e != NULL) {
	                return e;
	        }
	        else {
			const Protocol *proto;

			printf("%.*s\n", len, buffer);
			for (len=0; len<8; ++len) {
			        printf("==========");
			}
			printf("\n");

			printf("%-10s  0x%5x    %03d    %s\n",
				" --- ", URL_00, Module_VersionNumber, Module_Help
				" © Acorn 1997-8 (Built: " Module_Date ")");

			for (proto=protocols; proto; proto=proto->next) {
			printf("%-10s  0x%5x    %03d    %s\n",
				proto->url_base,proto->swi_base,
				proto->version, proto->info);
		        }
	        }
	}

	return NULL;
}



#ifdef USE_SYSLOG
#include "<syslog$dir>.C-veneer.h.syslog"
#endif

/*#define DEBUG_FILENAME	"ADFS::4.$.Trace.ProtoURL"*/
#define DEBUG_FILENAME  "RAM:$.URL_Trace"

/*************************************************************/
/* static void protocol_debug(const char *format, ...	     */
/*************************************************************/
/* Output trace information to the TRACE_FILE		     */
/*************************************************************/
#ifdef TRACE
#include <stdarg.h>
void protocol_debug(const char *format, ...)
{
	#ifdef TRACE
	if (getenv("NoTrace$URL")) return; else {
		va_list ap;
		#ifdef USE_SYSLOG
		static char buffer[1024];
		va_start(ap, format);
		vsprintf(buffer, format, ap);
		va_end(ap);
		(void) xsyslog_logmessage("URL", buffer, 100);
		#else
		FILE *fp = fopen(DEBUG_FILENAME, "a");

		if (fp != 0) {
			va_start(ap, format);
			(void) vfprintf(fp, format, ap);
			va_end(ap);
			fclose(fp);
		}
		#endif
	}
	#else
	(void) format;
	#endif
}
#endif


#ifdef TRACE

#ifndef USE_SYSLOG
static char *filter(char *buf, const char *ptr, int max)
{
	int i;
	for (i=0; i<=max; ++i) {
		int p = ptr[i];
		if (p<32 || p == 127) buf[i] = '.'; else buf[i] = p;
	}
	buf[i] = '\0';
	return buf;
}
#endif

void protocol_dump(const char *ptr, int size)
{
	#ifdef TRACE
	if (getenv("NoTrace$URL") || getenv("NoTrace$URL")) return; else {
		#ifdef USE_SYSLOG
		(void) xsyslog_logdata("URL", 100, ptr, size, 0);
		#else
		FILE *fp = fopen(DEBUG_FILENAME, "a");
		if (fp != NULL) {
			int ctr;
			char buf[48];
			fprintf(fp, "%08x: ", 0);
			for (ctr=0; ctr<size; ++ctr) {
				fprintf(fp, "%02x ", ptr[ctr]);
				if ((ctr & 31) == 31) {
					fprintf(fp, "  %s",
						filter(buf, ptr+(ctr & ~31), ctr & 31));
					fprintf(fp, "\n%08x: ", ctr+1);
				}
			}
			if (ctr & 31) {
				const char *start = ptr + (ctr & ~31);
				while (ctr & 31) {
					fprintf(fp, "   ");
					++ctr;
				}
				fprintf(fp, "  %s", filter(buf, start, (size & 31)-1));
			}
			fputc('\n', fp);
			fclose(fp);
		}
		#endif
	}
	#else
	(void) ptr;
	(void) size;
	#endif
}
#endif

static struct proto_default_details {
        const char *scheme;
        int flags;
        unsigned int port_no;
} proto_default_setups[] = {
        { "mailto:", 	proto_HAS_NO_NETLOC,  				25 },
        { "telnet:", 	proto_DOES_NOT_PARSE, 				23 },
        { "finger:", 	proto_DOES_NOT_PARSE, 				79 },
        { "file:"  , 	proto_HOST_ALLOW_HASH | proto_HAS_NO_NETLOC, 	0 },
        { "filer_"  , 	proto_HOST_ALLOW_HASH | proto_HAS_NO_NETLOC, 	0 },
        { "local:"  , 	proto_HOST_ALLOW_HASH | proto_HAS_NO_NETLOC, 	0 },
        { "gopher:", 	proto_PATH_NOT_UNIX,  				70 },
        { "ftp:", 	proto_HAS_USER,  				21 },
        { "http:", 	proto_STRIP_DOT_DOT,  				80 },
        { "https:", 	proto_STRIP_DOT_DOT,  				443 },
        { "whois:",	proto_DOES_NOT_PARSE,				43 },
        { NULL,		0,						0  }
};


static struct proto_default_details *proto_find_default_settings(const char *url)
{
        struct proto_default_details *proto;
        char *colon = strchr(url, ':');
        size_t length;

        if (!colon) colon = strchr(url, '\0') - 1;
        length = colon + 1 - url;
        if (length < 2) return 0;

        for (proto=proto_default_setups; proto->scheme; proto++) {
                if (strncmp(proto->scheme, url, length) == 0) return proto;
        }

        return proto;
}

static int proto_default_flags(const char *url)
{
        struct proto_default_details *proto = proto_find_default_settings(url);
        return proto ? proto->flags : 0;
}

static unsigned int protocol_default_port_number(const char *url)
{
        struct proto_default_details *proto = proto_find_default_settings(url);
        return proto ? proto->port_no : 0U;
}

unsigned int protocol_get_default_port(const char *url)
{
        const Protocol *p = protocol_locate(url);

	if (p) {
	        if (p->port_no != 0) return p->port_no;
	}

	return protocol_default_port_number(url);
}
