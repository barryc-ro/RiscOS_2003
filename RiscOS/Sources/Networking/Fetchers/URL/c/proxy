/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source$
 *
 * $Log$
 * Revision 1.1.1.1  1998/01/29 18:32:35  sbrodie
 * Import from SrcFiler of Browser fetchers
 *
 * Revision 1.1  95/09/08  09:35:09  pwain
 * Initial revision
 *
 *
 * SetProxy sets up a proxy service for all or some requests.
 */

#include <stdio.h>
#include <stdlib.h>
#include "swis.h"
#include "url.h"
#include "strings.h"
#include "protocol.h"
#include "utils.h"
#include "generic.h"
#include "externs.h"

static void freeproxylist(Proxy *p)
{
    	while (p) {
        	Proxy *const next=p->next;
        	free(p->proxy);
        	free(p->url_base);
        	free(p);
        	p=next;
        }
}

static _kernel_oserror *deleteproxy(int r)
{
    	if (r == 0) {
        	/* Global proxies */
        	freeproxylist(no_proxy_list);
        	no_proxy_list=NULL;
        	freeproxylist(global_proxy_list);
        	global_proxy_list=NULL;
        	return NULL;
        }
    	else {
	        /* Client proxies */
        	Client *c = find_client(r);
        	if (c == NULL) {
        	        return make_error(url_ERROR_CLIENT_ID_NOT_FOUND, 0);
        	}

        	freeproxylist(c->client.proxy);
        	c->client.proxy=NULL;
        	freeproxylist(c->client.no_proxy);
        	c->client.no_proxy=NULL;
        	return NULL;
        }
}

static Proxy *proxy_new_entry(void)
{
        Proxy *p = malloc(sizeof(Proxy));

        if (p == NULL) return p;
        p->proxy = NULL;
        p->url_base = NULL;
        p->next = NULL;
        return p;
}

enum {
        op_proxy,
        op_no_proxy
};

_kernel_oserror *setproxy(_kernel_swi_regs *r)
{
	Client *list;
	Proxy *proxy;
	Proxy **p;

	char *base = (char *) r->r[2];
	char *method = (char *) r->r[3];
	int op = r->r[4];

	#ifdef TRACE
	protocol_debug("setproxy: flags: %08x  Session: %08x  Base: `%s'  Method: `%s'  <%sProxy>\n",
		r->r[0], r->r[1], base?base:"<NULL>", method?method:"<NULL>",
		r->r[4] == op_no_proxy ? "Don't ": "");
	#endif

	if (base == NULL) {
        	return deleteproxy(r->r[1]);
        }

	/*
	 * if r1=0 we are dealing with the global case, so look to see if we
	 * are dealing with an individual one 1st
	 */
    	if (r->r[1] != 0) {
		/* try and find the client reference */
        	list = find_client(r->r[1]);

		/* failed */
		if (list == NULL) {
			return make_error(url_ERROR_CLIENT_ID_NOT_FOUND, 0);
		}

		/* get its proxy record */
		if (op == op_proxy) {
	    		p = &list->client.proxy;
	        }
        	else {
        	        p = &list->client.no_proxy;
	        }
        }
    	else {
    	        if (op == op_proxy) {
    	                p = &global_proxy_list;
    	        }
    	        else {
    	                p = &no_proxy_list;
    	        }
    	}

	if (*p != NULL) {
	        Proxy *list = *p, *last = NULL;
	        const char *const user_base = method;

	        for (list = *p; list != NULL;) {
	                if (strcmp(list->url_base, user_base) == 0) {
	                        /* Found a duplicate - free it */
				Proxy *const next = list->next;
				if (last == NULL) {
				        *p = next;
				}
				else {
		                        last->next = next;
		                }
	                        free(list->proxy);
	                        free(list->url_base);
				free(list);
	                        list = next;
	                        continue;
	                }
			last = list;
			list = list->next;
	        }

	        proxy = last->next = proxy_new_entry();
	}
	else {
	        proxy = *p = proxy_new_entry();
	}

	if (proxy == NULL) {
	        return make_error(url_ERROR_MEMORY_EXHAUSTED, 0);
	}

    	/* fill in the details */
        proxy->proxy = Strdup(base);
       	proxy->url_base = Strdup(method);

    	return NULL;
}
