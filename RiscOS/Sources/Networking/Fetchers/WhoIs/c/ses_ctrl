/*
 * Generic (c.ses_ctrl)
 * 
 * NOTE: Requires customised kill_session_data function.
 *
 * © Acorn Computers Ltd. 1997
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "sys/errno.h"
#include "module.h"
#include "generic.h"
#include "protocol.h"
#include "headers.h"

/*
 * This file contains the routines needed to manipulate sessions
 * within the contect of multiple clients of the module.
 */

static Session *session_list = NULL;

/*************************************************************/
/* Session *find_session(unsigned int id)		     */
/*************************************************************/
/* Given a session ID, return the session control block	     */
/* associated with it.					     */
/*************************************************************/
Session *find_session(unsigned int id)
{
	Session *session;

	for (session = session_list; session; session = session->next) {
		if (session->id == id) return session;
	}

	return NULL;
}

/*************************************************************/
/* Session *new_session(void)				     */
/*************************************************************/
/* Create a new session, taking into account starting the    */
/* sessions list					     */
/*************************************************************/
Session *new_session(void)
{
	Session *ses = calloc(1, sizeof(Session));

	if (ses == NULL) {
		return ses;
	}

	ses->sd = -1;

	if (session_list == NULL) {
		/* no list so create a new one */
		session_list = ses;
	}
	else {
		/* else find end of list and add an element */
		Session *s;

		for (s=session_list; s->next; s=s->next) ;;
		s->next = ses;
	}

	return ses;
}

static Session *kill_session_data(Session *s)
{
	Session *result = s->next;

	close_socket(&s->sd);
	http_free_headers(&s->headers);
	free(s->command.data);
	free(s->response.data);
	free(s->client_pump.data);
	free(s->uri);
	free(s->url);
	free(s->host);
	free(s->data);
	free(s->agent);

	/* Insert protocol specific stuff here */
	free(s->selector);
	/* End protocol specific stuff here */
	
	memset(s, '\0', sizeof(*s)); /* Let's be careful */
	free(s);
	
	return result;
}
	        

/*************************************************************/
/* void kill_session(Session *s)			     */
/*************************************************************/
/* Given the location of the session block, delete the	     */
/* session cleanly, taking into account the session next     */
/* pointers and any memory associated with it		     */
/*************************************************************/
void kill_session(Session *s)
{
	Session *ses = session_list, *prev_ses = NULL;

	for (ses = session_list; ses; prev_ses = ses, ses = ses->next) {
		if (ses == s) {
			Session *const next = kill_session_data(s);
			if (prev_ses == NULL) {
				session_list = next;
			}
			else {
				prev_ses->next = next;
			}
			break;
		}
	}

	#ifdef TRACE
	protocol_debug("\nkill_session %p completed.  Dump of session chain\n", s);
	for (ses=session_list; ses; ses=ses->next) {
		protocol_debug("%p (socket %d) URL %s\n", ses, ses->sd, ses->url);
	}
	protocol_debug("End of session chain\n\n");
	#endif
}

/*************************************************************/
/* void ses_kill_all(void)				     */
/*************************************************************/
/* A small routine to kill off all sessions at module shut-  */
/* down.						     */
/*************************************************************/
void ses_kill_all(void)
{
	while (session_list) {
		kill_session(session_list);
	}
}


/* session_check is called by the callback routine in order to
 * timeout any inactive connections or anything.  Currently, it
 * does nothing, however nothing is lost by having it here, since
 * callbacks are required for the connection pool monitoring
 * anyway.
 */
void session_check(void)
{
	/* Nothing */
}
