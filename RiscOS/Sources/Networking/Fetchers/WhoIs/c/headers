/*
 * Generic (c.headers)
 *
 * THIS FILE NEEDS TO BE CUSTOMISED
 *
 * © Acorn Computers Ltd. 1997
 */
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "headers.h"
#include "protocol.h"
#include "generic.h"


/* This function takes the header and value supplied and stores them in the header list
 * It takes a pointer to the head pointer so it can insert at the head of the list if
 * necessary.
 */
void http_add_header(http_header **list, const char *header, const char *value)
{
        const size_t header_len = strlen(header) + 1;
        const size_t value_len = strlen(value) + 1;
        const size_t size = header_len + value_len + offsetof(http_header, text);
        http_header *h = malloc(size);
        
        if (h == NULL) return;
        
        h->next = NULL;
        h->header = h->text;
        memcpy(h->text, header, header_len);
	h->value = h->text + header_len;
        memcpy(h->value, value, value_len);

	if (*list == NULL) {
	        *list = h;
	}
	else {
                http_header *plist;
                
                for (plist = *list; plist->next; plist = plist->next) ;;
                plist->next = h;
	}
}

void http_delete_header(http_header **list, http_header *header)
{
        if (header == NULL) return;
        if (*list == header) {
                *list = header->next;
        }
        else {
                http_header *plist;
                
                for (plist=*list; plist->next; plist=plist->next) {
                        if (plist->next == header) {
                                plist->next = header->next;
                                break;
                        }
                }
        }
        free(header);
}

http_header *http_find_header(http_header *list, char *header)
{
        for (; list; list=list->next) {
                if (Strcmp_ci(list->header, header) == 0) break;
        }

	return list;
}

void http_free_headers(http_header **list)
{
        while (*list) http_delete_header(list, *list);
}


/* This function takes the list of tokens specified as the value for the Connection header
 * and removes any headers with matching names.  This is required behaviour for HTTP/1.1.
 */
void http_filter_connection_tokens(http_header **list, char *tokens)
{        
        for (;;) {
	        char *comma, *end, saved;

		while (*tokens == ',' || (*tokens != '\0' && isspace(*tokens))) ++tokens;
		if (*tokens == '\0') break;

	        comma = strchr(tokens, ',');
		if (comma != NULL) {
		        end = comma++;
		}
		else {
		        comma = end = strchr(tokens, '\0');
		}

		/* We now know we are not looking at an empty list member token */
		for (--end; isspace(*end); --end) ;;
		++end;
		/* Found it! Do NOT get fooled by removing ourselves! Shouldn't happen but ... */
		if (Strncmp_ci(tokens, "connection", sizeof("connection")) != 0) {
			#ifdef TRACE
			protocol_debug("Filtering header named in connection: %.*s\n", end-tokens, tokens);
			#endif
			saved = *end;
			*end = '\0';
			for (;;) {
				http_header *h = http_find_header(*list, tokens);
				if (h == NULL) break;
				#ifdef TRACE
				protocol_debug("Deleting `%s' header\n", h->header);
				#endif
				http_delete_header(list, h);
			}
			*end = saved;
		}
                tokens = comma;
        }
        
}

/* This function generates a full request or response header into ses->current_header
 * using the data in ses->headers.  The remembered header list is then DELETED from ses->headers
 * The current header pointer is set to a null pointer if unable to claim space for the buffer
 */
size_t http_construct_header_buffer(Session *ses, size_t extra)
{
	http_header	*h;
        char 		*ptr;
        size_t 		header_size = extra + sizeof("\r\n");
        
        for (h=ses->headers; h; h=h->next) {
                header_size += strlen(h->header) + strlen(h->value) + sizeof(": \r\n") - 1;
        }
        
	#ifdef TRACE
	protocol_debug("Need %d bytes to hold the entire header\n", header_size);
	#endif
        ses->current_header = malloc(header_size);
        if (ses->current_header == NULL) {
                /* This will have the effect of persuading the browser we are HTTP 0.9
                 * but hell, it is at least a legal response to an HTTP request!
                 */
                return 0;
        }

	ptr = ses->current_header;
	for (h=ses->headers; h; h=h->next) {
		#ifdef TRACE
		protocol_debug("Writing `%s' header to buffer (value `%s')\n", h->header, h->value);
		#endif
	        ptr += sprintf(ptr, "%s%s %s\r\n", h->header, h == ses->headers ? "" : ":", h->value);
	}
	ptr += sprintf(ptr, "\r\n");
	http_free_headers(&ses->headers);
	return (ptr - ses->current_header);
}


/* This function takes a buffer containing an HTTP header and splits it into the
 * header itself and its value.  It returns zero for an unparsable block of data
 * and pointers.  It DOES modify the input string.  I wouldn't rely on eobuffer
 * if I were you.
 */
static int http_delimit_header(char *buffer, char **eobuffer, char **header, char **value)
{
	char *ptr;

	ptr = buffer + strcspn(buffer, "\n\r");	/* Locate line terminator (if present) else string term.*/
	if (*ptr) {
		*ptr = '\0';			/* terminate buffer */
		if (eobuffer) {
			*eobuffer = ptr + 1;	/* Return that there was more than one line in buffer */
		}
	}
	else {
		if (eobuffer) *eobuffer = 0;	/* Return that there was no more data in buffer */
	}
	while (ptr > buffer) {
		if (isspace(ptr[-1])) {		/* Strip trailing spaces */
			*--ptr = '\0';
		}
		else break;
	}
	buffer += strspn(buffer, " \t");	/* Skip leading spaces */
	if (!*buffer) {				/* String was empty? Bail out */
		*header = 0;
		*value = 0;
		return 0;
	}
	*header = buffer;
	buffer += strcspn(buffer, " :\t");	/* Skip over header name */
	if (!*buffer) {
		*value = 0;			/* No data for this header - corrupt? */
		return 0;
	}
	*buffer++ = 0;				/* Terminate header name and move along */
	*value = buffer + strspn(buffer, " :\t");	/* Locate start of header value and store it */
	return 1;
}

/* This function returns non-zero if it managed to locate a complete header line */
static int http_check_found_header(char *buffer, char **next, int continuations)
{
	char *ptr, *nl;

	#ifdef TRACE
	protocol_debug("http_check_found_header(%.*s)\n", 96, buffer);
	#endif

	/* Find the first \r and \n characters in the buffer, if any */
	ptr = strchr(buffer, '\r');
	nl = strchr(buffer, '\n');
	
	if (!ptr || (nl && ptr && (nl < ptr))) {
		/* If there was a \n and \r AND \n occurred before \r, make ptr
		 * point at the \n instead (because we're using EOL of \n and
		 * it looks as if we might have picked up a \r somewhere in the
		 * object body which we DON'T want to see yet
		 */
		ptr = nl;
	}
	/* At this point, ptr can only be NULL if nl is also NULL */

	if (ptr && !nl) {
		/* found a \r but didn't find a \n */
		if (ptr[1] == ' ' || ptr[1] == '\t') {
		        /* Was this a continuation line? */
		        ptr[0] = ' '; /* blank the spurious \r character out */
		        return http_check_found_header(buffer, next, continuations);
		}
		
		if (!ptr[1]) {
			/* BUT the \r happened to be at the end of the buffer
			 * so we'll go around again in order to forcibly pick
			 * up the \n on the next read.
			 */
			*next = NULL;
			return 0;
		}

		/* To get here, ptr points to a lonely \r character at a real header end */
	}
	else if (!ptr) {
		/* neither \r nor \n found */
		*next = NULL;
		return 0;
	}
	else {
		if (ptr != nl) {
			/* To get here, we have found both a \r and a \n */
			if (ptr[1] == '\n') {
				nl = ptr+1;
				*ptr++ = ' '; /* Blank out the \r */
			}
		}
		else {
		        /* Found just a \n - check at end of buffer */
		        if (nl[1] == '\0' && continuations) {
		                /* At end of buffer */
		                *next = NULL;
		                return 0;
		        }
		}
	}
	
	/* To get here, ptr is non NULL and points at the end of line character 
	 * which WILL be either \r or \n, BUT the next character ptr[1] will not
	 * be another newline indicator unless this is the end of the headers */

	if (ptr == buffer || (ptr == (buffer+1) && buffer[0] == ' ')) {
	        /* Was the last header - send blank string back */
	        *buffer = '\0';
	        *next = ptr+1;
	        return 1;
	}

	if (ptr[1] == ' ' || ptr[1] == '\t') {
	        /* This was a continuation line */
	        *ptr = ' ';  /* exterminate the previous end of line */
	        return http_check_found_header(buffer, next, continuations);
	}
	
	*ptr++ = '\0';
	*next = ptr;
        return 1;
}

/* This function parses the user supplied headers.  We use this to "fix up" any problems in the
 * headers - such as removing things we don't like the look of - like Host headers.  We supply
 * our own Host headers - and our ones are correct!  We also object to Connection headers (our
 * client has no business interfering with our connections to servers) and user-agent headers
 * (we provide a perfectly good API for altering the user-agent already).
 */
int parse_user_header(char *buffer, int buflen, Session *ses)
{
        char *next, *eob, *header, *value;
        int consumed = 0, ended = 0;

	#ifdef TRACE
	protocol_debug("Parsing user supplied header block\n");
	protocol_dump(buffer, buflen);
	#endif
        
        while (!ended && http_check_found_header(buffer, &next, 1)) {
		if (http_delimit_header(buffer, &eob, &header, &value)) {
		        if (header != NULL) {
		                if (Strcmp_ci(header, "host") != 0 && Strcmp_ci(header, "connection") != 0 &&
		                	Strcmp_ci(header, "user-agent") != 0) {
			                http_add_header(&ses->headers, header, value ? value : "");
			        }
		        }
		}
		consumed += (next - buffer);
		buffer = next;
                if (consumed >= buflen) ended = TRUE;
		if (header == NULL && value == NULL) {
		        ended = TRUE;
		}
        }

	#ifdef TRACE
	protocol_debug("End parse user supplied header block.  Data remaining: %d bytes\n", buflen - consumed);
	protocol_dump(buffer, buflen - consumed);
	#endif
        
        return consumed;
}
