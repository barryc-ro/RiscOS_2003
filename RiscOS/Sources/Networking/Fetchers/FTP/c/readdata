/*
 * FTP (c.readdata)
 *
 * © Acorn Computers Ltd. 1996-1997
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include <string.h>
#include "sys/errno.h"
#include "sys/types.h"
#include "sys/socket.h"
#include "unixlib.h"
#include "inetlib.h"
#pragma no_warn_deprecated
#include "netdb.h"
#pragma warn_deprecated
#include "socklib.h"
#include "sys/ioctl.h"
#include "module.h"
#include "processdir.h"
#include "generic.h"
#include "protocol.h"
#include "utils.h"
#include "commands.h"
#include "FTPhdr.h"
#include "ftptext.h"
#include "servertype.h"
#include "rewrite.h"
#include "ftperrors.h"

#define MimeMap_Translate	     0x050b00

extern _kernel_oserror *usermode_donothing(void);
static _kernel_oserror *ftp_exec_readdata(_kernel_swi_regs */*r*/);
static char *ftp_copy_message_token(const char *tag);

static _kernel_oserror *ftp_wait_dns(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_acct_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_pass_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_user_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_syst_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_initial_greeting(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_wait_initial_greeting(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_logged_in_ok(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_pasv_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_port_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_pwd_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_send_cwd_home(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_cwd_home_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_rnfr_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_rnto_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_rmdir_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_mkdir_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_dele_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_initiate_file_transfer(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_initiate_directory_transfer(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_cwd_dir_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_wait_data_connection(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_stor_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_retr_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_retr_dir_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_list_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_size_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_stat_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_got_abor_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_dir_xfer_complete(Session *s, _kernel_swi_regs *r);

static _kernel_oserror *ftp_pump_client_response(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_return_no_more_data(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_transfer_completed(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_initiate_command(Session *s, _kernel_swi_regs *r);

static _kernel_oserror *ftp_read_data_connection(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_read_dir_data_connection(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_reading_data(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_reading_dir_data(Session *s, _kernel_swi_regs *r);
static _kernel_oserror *ftp_write_data_connection(Session *s, _kernel_swi_regs *r);


/*************************************************************/
/* _kernel_oserror *ftp_readdata(_kernel_swi_regs *r)	     */
/*************************************************************/
/* The call to get the actual data from a site. The values   */
/* in the registers are:				     */
/*			 r0 = flags word		     */
/*			 r1 = poll word			     */
/*			 r2 = buffer			     */
/*			 r3 = sizeof(buffer)		     */
/*							     */
/* On exit:						     */
/*			 r0 = protocol status		     */
/*			 r1 = pollword of client	     */
/*			 r2 = buffer (contents modified)     */
/*			 r3 = unchanged			     */
/*			 r4 = bytes read		     */
/*			 r5 = bytes left (-1 if unknown)     */
/*************************************************************/
_kernel_oserror *ftp_readdata(_kernel_swi_regs *r)
{
	/* This wrapper is used to ensure that R2 and R3 are preserved across the SWI
	 * This is needed because in order to generate the client's data buffer piecemeal
	 * (we are rewriting the headers to help the browser out and removing some that
	 * do not concern it at all), we keep updating R2 and R3 to avoid writing off
	 * the end of the buffer.
	 * We also take the opportunity to initialise R4 and R5 safely.
	 */
	const int const_buffer = r->r[2];
	const int const_buflen = r->r[3];
	_kernel_oserror *result;

	#ifdef TRACE
	protocol_debug("Buffer (R2) is &%08x; Size (R3) = %d\n", const_buffer, const_buflen);
	#endif

	r->r[0] = status_READING_REPLY;
	r->r[4] = 0;  /* No data in client buffer yet */
	r->r[5] = -1; /* Unknown how much more data to read */
	result = ftp_exec_readdata(r);
	r->r[2] = const_buffer;	/* Restore buffer address */
	r->r[3] = const_buflen; /* Restore buffer size */
	#ifdef TRACE
	protocol_debug("<< Exit SWI ReadData.  Bytes read: %d\n", r->r[4]);
	protocol_dump((void *)r->r[2], r->r[4]);
	#endif
	return result;
}

#ifdef TRACE
static const char *ftp_state_name(int state)
{
	switch (state) {
		case FTP_DISCONNECTED: return "FTP_DISCONNECTED";
		case FTP_STATUS_DNS: return "FTP_STATUS_DNS";
		case FTP_CONNECTED: return "FTP_CONNECTED";
		case FTP_GREETING_RECEIVED: return "FTP_GREETING_RECEIVED";
		case FTP_SYST_RECEIVED: return "FTP_SYST_RECEIVED";
		case FTP_USER_RESP_RECEIVED: return "FTP_USER_RESP_RECEIVED";
		case FTP_PASS_RESP_RECEIVED: return "FTP_PASS_RESP_RECEIVED";
		case FTP_ACCT_RESP_RECEIVED: return "FTP_ACCT_RESP_RECEIVED";
		case FTP_LOGGED_IN: return "FTP_LOGGED_IN";
		case FTP_GOT_PWD_RESP: return "FTP_GOT_PWD_RESP";
		case FTP_SEND_CWD_HOME: return "FTP_SEND_CWD_HOME";
		case FTP_GOT_CWD_HOME_RESP: return "FTP_GOT_CWD_HOME_RESP";
		case FTP_INITIATE_COMMAND: return "FTP_INITIATE_COMMAND";
		case FTP_DELE_RESP_RECEIVED: return "FTP_DELE_RESP_RECEIVED";
		case FTP_MKDIR_RESP_RECEIVED: return "FTP_MKDIR_RESP_RECEIVED";
		case FTP_RMDIR_RESP_RECEIVED: return "FTP_RMDIR_RESP_RECEIVED";
		case FTP_RNFR_RESP_RECEIVED: return "FTP_RNFR_RESP_RECEIVED";
		case FTP_RNTO_RESP_RECEIVED: return "FTP_RNTO_RESP_RECEIVED";
		case FTP_CWD_DIR_RESP_RECEIVED: return "FTP_CWD_DIR_RESP_RECEIVED";
		case FTP_LIST_RESP_RECEIVED: return "FTP_LIST_RESP_RECEIVED";
		case FTP_PASV_RESP_RECEIVED: return "FTP_PASV_RESP_RECEIVED";
		case FTP_PORT_RESP_RECEIVED: return "FTP_PASV_PORT_RECEIVED";
		case FTP_WAIT_DATA_CONNECTION: return "FTP_WAIT_DATA_CONNECTION";
		case FTP_INITIATE_DIR_TRANSFER: return "FTP_INITIATE_DIR_TRANSFER";
		case FTP_INITIATE_FILE_TRANSFER: return "FTP_INITIATE_FILE_TRANSFER";
		case FTP_STOR_RESP_RECEIVED: return "FTP_STOR_RESP_RECEIVED";
		case FTP_RETR_RESP_RECEIVED: return "FTP_RETR_RESP_RECEIVED";
		case FTP_RETR_DIR_RESP_RECEIVED: return "FTP_RETR_DIR_RESP_RECEIVED";
		case FTP_DIR_RESP_RECEIVED: return "FTP_DIR_RESP_RECEIVED";
		case FTP_SIZE_RESP_RECEIVED: return "FTP_SIZE_RESP_RECEIVED";
		case FTP_STAT_RESP_RECEIVED: return "FTP_STAT_RESP_RECEIVED";
		case FTP_READ_DATA: return "FTP_READ_DATA";
		case FTP_READ_DIR_DATA: return "FTP_READ_DIR_DATA";
		case FTP_WRITE_DATA: return "FTP_WRITE_DATA";
		case FTP_XFER_RESP_RECEIVED: return "FTP_XFER_RESP_RECEIVED";
		case FTP_XFER_DONE_RECEIVED: return "FTP_XFER_DONE_RECEIVED";
		case FTP_DIR_XFER_COMPLETE: return "FTP_DIR_XFER_COMPLETE";
		case FTP_SENDING_COMMAND: return "FTP_SENDING_COMMAND";
		case FTP_RECEIVING_RESPONSE: return "FTP_RECEIVING_RESPONSE";
		case FTP_RECEIVING_DIR_RESPONSE: return "FTP_RECEIVING_DIR_RESPONSE";
		case FTP_PUMPING_CLIENT_RESPONSE: return "FTP_PUMPING_CLIENT_RESPONSE";
		case FTP_ABOR_RESP_RECEIVED: return "FTP_ABOR_RESP_RECEIVED";
		case FTP_STATUS_ENDED: return "FTP_STATUS_ENDED";
		case FTP_STATUS_DEAD: return "FTP_STATUS_DEAD";
		case FTP_STATUS_ERROR_CREATE: return "FTP_STATUS_ERROR_CREATE";
		case FTP_STATUS_ERROR_CONN: return "FTP_STATUS_ERROR_CONN";
		case FTP_STATUS_ERROR_MEM: return "FTP_STATUS_ERROR_MEM";
		case FTP_STATUS_ERROR_WRITE: return "FTP_STATUS_ERROR_WRITE";
		case FTP_STATUS_ERROR_CLOSE: return "FTP_STATUS_ERROR_CLOSE";
		case FTP_STATUS_ERROR_READ: return "FTP_STATUS_ERROR_READ";
		case FTP_STATUS_ERROR_BADRD: return "FTP_STATUS_ERROR_BADRD";
		case FTP_STATUS_TOKEN_NOT_FOUND: return "FTP_STATUS_TOKEN_NOT_FOUND";
		case FTP_STATUS_ERROR_UNEXPECTED: return "FTP_STATUS_ERROR_UNEXPECTED";
		default:
			return "**Unknown**";
	}

}
static void ftp_show_state(const Session *s)
{
	protocol_debug("FTP session %p status now %s\n", s, ftp_state_name(s->state));
}
#else
#define ftp_show_state(s) ((void)(s))
#endif

/* ftp_readdata_dispatch is the main state table dispatch routine.  In order to avoid any problems
 * with overflowing the SVC stack, it sits in a while loop dispatching on the session state until
 * one of the routines returns an error or the special value "state_BLOCKING".  Errors are real
 * errors reported to the caller of the ReadData SWI.  state_BLOCKING indicates that the SWI code
 * should exit with no error.  NULL indicates that the loop should be executed again.	This means
 * that the code can arrange for the maximum amount of work to be done on each SWI call, which
 * basically means that the caller is guaranteed that on exit from these calls, either an error has
 * occurred, or there is buffered data waiting to be written to the client because not all of it
 * could be transferred, or a network wait is in progress.  The state handlers that are called MAY
 * choose to rely on tail-call optimisation to avoid overflowing the stack, but if unsure, it is
 * better to set Session.state to the new state and return NULL, which will force this dispatcher
 * to call the new state handler.
 *
 * However, during testing, a counter "ctr" was introduced to ensure that the SWI will exit after
 * a maximum number of iterations.  This number is sufficiently large that it will likely rarely be
 * seen during transfers (very long directory listings are the only cause I can foresee).  This
 * emergency exit mechanism means that the machine will return to USR mode so Alt-Break can be used
 * to get control of the machine back should things have gone disastrously wrong.
 *
 */
static _kernel_oserror *ftp_readdata_dispatch(Session *s, _kernel_swi_regs *r)
{
	_kernel_oserror *e = NULL;
	int ctr = 0;

	while (ftp_show_state(s), e == NULL && ctr++<100) switch (s->state) {
		case FTP_STATUS_DNS:		e = ftp_wait_dns(s, r);	break;
		case FTP_CONNECTED:		e = ftp_wait_initial_greeting(s, r); break;
		case FTP_GREETING_RECEIVED:	e = ftp_got_initial_greeting(s, r); break;
		case FTP_SYST_RECEIVED:		e = ftp_got_syst_response(s, r); break;
		case FTP_USER_RESP_RECEIVED:	e = ftp_got_user_response(s, r); break;
		case FTP_PASS_RESP_RECEIVED:	e = ftp_got_pass_response(s, r); break;
		case FTP_ACCT_RESP_RECEIVED:	e = ftp_got_acct_response(s, r); break;
		case FTP_LOGGED_IN:		e = ftp_logged_in_ok(s, r); break;
		case FTP_GOT_PWD_RESP:		e = ftp_got_pwd_response(s, r); break;
		case FTP_SEND_CWD_HOME:		e = ftp_send_cwd_home(s, r); break;
		case FTP_GOT_CWD_HOME_RESP:	e = ftp_got_cwd_home_response(s, r); break;
		case FTP_INITIATE_COMMAND:	e = ftp_initiate_command(s, r); break;
		case FTP_DELE_RESP_RECEIVED:	e = ftp_got_dele_response(s, r); break;
		case FTP_MKDIR_RESP_RECEIVED:	e = ftp_got_mkdir_response(s, r); break;
		case FTP_RMDIR_RESP_RECEIVED:	e = ftp_got_rmdir_response(s, r); break;
		case FTP_RNFR_RESP_RECEIVED:	e = ftp_got_rnfr_response(s, r); break;
		case FTP_RNTO_RESP_RECEIVED:	e = ftp_got_rnto_response(s, r); break;

		case FTP_CWD_DIR_RESP_RECEIVED:	e = ftp_got_cwd_dir_response(s, r); break;
		case FTP_LIST_RESP_RECEIVED:	e = ftp_got_list_response(s, r); break;
		case FTP_PASV_RESP_RECEIVED:	e = ftp_got_pasv_response(s, r); break;
		case FTP_PORT_RESP_RECEIVED:	e = ftp_got_port_response(s, r); break;
		case FTP_WAIT_DATA_CONNECTION:	e = ftp_wait_data_connection(s, r); break;

		case FTP_INITIATE_DIR_TRANSFER:	e = ftp_initiate_directory_transfer(s, r); break;
		case FTP_INITIATE_FILE_TRANSFER:e = ftp_initiate_file_transfer(s, r); break;

		case FTP_STOR_RESP_RECEIVED:	e = ftp_got_stor_response(s, r); break;
		case FTP_RETR_RESP_RECEIVED:	e = ftp_got_retr_response(s, r); break;
		case FTP_RETR_DIR_RESP_RECEIVED:e = ftp_got_retr_dir_response(s, r); break;
		case FTP_DIR_RESP_RECEIVED:	e = ftp_got_list_response(s, r); break;
		case FTP_SIZE_RESP_RECEIVED:	e = ftp_got_size_response(s, r); break;
		case FTP_STAT_RESP_RECEIVED:	e = ftp_got_stat_response(s, r); break;
		case FTP_ABOR_RESP_RECEIVED:	e = ftp_got_abor_response(s, r); break;

		case FTP_SENDING_COMMAND:	e = commands_continue_sending(s); break;
		case FTP_RECEIVING_RESPONSE:	e = ftp_reading_data(s, r); break;
		case FTP_RECEIVING_DIR_RESPONSE:e = ftp_reading_dir_data(s, r); break;
		case FTP_DIR_XFER_COMPLETE:	e = ftp_dir_xfer_complete(s, r); break;

		case FTP_READ_DATA:		e = ftp_read_data_connection(s, r); break;
		case FTP_READ_DIR_DATA:		e = ftp_read_dir_data_connection(s, r); break;
		case FTP_WRITE_DATA:		e = ftp_write_data_connection(s, r); break;

		case FTP_PUMPING_CLIENT_RESPONSE: e = ftp_pump_client_response(s, r); break;

		case FTP_STATUS_ENDED:		e = ftp_return_no_more_data(s, r); break;
		case FTP_XFER_DONE_RECEIVED:	e = ftp_transfer_completed(s, r); break;

		case FTP_STATUS_ERROR_READ:
		case FTP_STATUS_ERROR_CLOSE:
		case FTP_STATUS_ERROR_WRITE:
			if (s->error_state == FTP_GREETING_RECEIVED) {
			        return make_error(FTP_ERROR_READ_FAILED_INITIAL, 0);
			}
			return make_error(FTP_ERROR_READ_WRITE_FAILED, 0);

		case FTP_STATUS_ERROR_CREATE:
			return make_error(FTP_ERROR_BAD_SOCKET, 0);
		case FTP_STATUS_ERROR_CONN:
			return make_error(FTP_ERROR_CONNECT_FAIL, 0);
		case FTP_STATUS_ERROR_MEM:
			return make_error(FTP_ERROR_NO_MEMORY, 0);

		case FTP_STATUS_ERROR_BADRD:
			return make_error(FTP_ERROR_UNEXPECTED_RESPONSE, 0);

		case FTP_STATUS_TOKEN_NOT_FOUND:
		case FTP_STATUS_ERROR_UNEXPECTED:
			e = make_error(FTP_ERROR_INTERNAL, 0);
			break;

		case FTP_DISCONNECTED:
		case FTP_STATUS_DEAD:
		default:
			s->state = FTP_STATUS_DEAD;
			return make_error(FTP_ERROR_INTERNAL, 0);
	}

	if (e != NULL) {
		if (e == state_BLOCKING) {
			e = NULL;
		}
		else {
			s->state = FTP_STATUS_DEAD;
		}
	}
	return e;
}


static _kernel_oserror *ftp_exec_readdata(_kernel_swi_regs *r)
{
	Session *ses  = NULL;

	/*
	 * Check to see session exists and has connected cleanly first
	 * If it doesn't/hasn't, reject this request cleanly
	 */

	r->r[5] = 0;

	ses = find_session(r->r[1]);
	if (ses == NULL) {
		return make_error(FTP_ERROR_BAD_SESSION, 0);
	}

	if (ses->control_sd == -1) {
		return make_error(FTP_ERROR_BAD_SOCKET, 0);
	}

	ses->r = r;

	r->r[0] = *((int *)r->r[1]) = ses->reported_state;
	r->r[5] = ses->size;

	return ftp_readdata_dispatch(ses, r);
}

static _kernel_oserror *gen_error(Session *s, char *errmess)
{
	_kernel_oserror *e = find_error();
	(void) s;
	#ifdef TRACE
	protocol_debug("FTP session %p error --> %s\n", s, errmess);
	#endif
	strncpy(e->errmess, errmess, sizeof(e->errmess));
	return e;
}

static _kernel_oserror *ftp_transfer_completed(Session *s, _kernel_swi_regs *r)
{
	switch (ftp_class(s->response_code)) {
		case ftp_OK:
			/* OK */
			break;

		case ftp_INFORMATIONAL:
			/* Come back later when we've read the real final response */
			#ifdef TRACE
			protocol_debug("In ftp_transfer_completed, but need to wait for the final response\n");
			#endif
			return commands_recv(s, FTP_XFER_DONE_RECEIVED);

		default:
			return gen_error(s, s->response.data);
	}

	r->r[5] = 0;
	s->state = FTP_STATUS_ENDED;
	s->cacheable = 1;
	return state_BLOCKING;
}



static _kernel_oserror *ftp_return_no_more_data(Session *s, _kernel_swi_regs *r)
{
	s->reported_state = *((int *)r->r[1]) = r->r[0] = status_ALL_DATA_RECEIVED;
	r->r[5] = 0;
	if (s->data_sd != -1) {
		close_socket(&s->data_sd);
	}
	if (s->listen_sd != -1) {
		close_socket(&s->listen_sd);
	}
	if (s->control_sd != -1) {
		/*s->cacheable = 1;*/
		new_connection(s);
		#ifdef TRACE
		protocol_debug("Sockets being dissociated with session %p\n", s);
		#endif
	}
	return state_BLOCKING;
}

static _kernel_oserror *ftp_reading_data(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return commands_continue_reading(s, &s->response);
}

static _kernel_oserror *ftp_reading_dir_data(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return commands_continue_reading(s, &s->directory);
}

static _kernel_oserror *ftp_dir_xfer_complete(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return ftp_start_client_pump_va(s, FTP_XFER_DONE_RECEIVED, FTP_DIR_HEAD_4, NULL);
}

static _kernel_oserror *ftp_read_dir_data_connection(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return commands_recv_dir(s, FTP_DIR_XFER_COMPLETE);
}

static _kernel_oserror *ftp_read_data_connection(Session *s, _kernel_swi_regs *r)
{
	if (r->r[3] <= 0) {
		return state_BLOCKING;
	}
	else {
		int result;

		errno = 0;
		result = recv(s->data_sd, (char *) r->r[2], r->r[3], 0);
		#ifdef TRACE
		protocol_debug("recv on data channel returned %d (errno now %d)\n", result, errno);
		#endif
		if (result == 0) {
			close_socket(&s->data_sd);
			if (s->had_final_response > 0) {
				s->state = FTP_XFER_DONE_RECEIVED;
				s->response_code = s->had_final_response;
				return NULL;
			}
			return commands_recv(s, FTP_XFER_DONE_RECEIVED);
		}
		else if (result > 0) {
			#ifdef TRACE
			protocol_debug("Managed to read %d byte(s)\n", result);
			#endif
			r->r[2] += result;
			r->r[3] -= result;
			r->r[4] += result;
			s->total_bytes_transferred += result;
			return state_BLOCKING;
		}
		if (errno == EWOULDBLOCK || errno == ENOTCONN) {
			#ifdef TRACE
			protocol_debug("We will block - EWOULDBLOCK/ENOTCONN (%d/%d) yet\n", EWOULDBLOCK, ENOTCONN);
			#endif
			return state_BLOCKING;
		}
		else {
			char errnum[16];
			sprintf(errnum, "Error %d", errno);
			return gen_error(s, errnum);
		}
	}

}

static _kernel_oserror *ftp_write_data_connection(Session *s, _kernel_swi_regs *r)
{
	const size_t remaining = s->put_data.length - s->put_data.done;
	int result = send(s->data_sd, s->put_data.data + s->put_data.done, remaining, 0);

	(void) r;

	if (result > 0) {
		s->put_data.done += result;
		if (s->put_data.done == s->put_data.length) {
			close_socket(&s->data_sd);
			if (s->had_final_response > 0) {
				s->state = FTP_XFER_DONE_RECEIVED;
				s->response_code = s->had_final_response;
				return NULL;
			}
			return commands_recv(s, FTP_XFER_DONE_RECEIVED);
		}
		return state_BLOCKING;
	}
	if (result == 0) {
		return state_BLOCKING;
	}
	if (errno == EWOULDBLOCK || errno == ENOTCONN) {
		return state_BLOCKING;
	}
	else {
		char errnum[16];
		sprintf(errnum, "Error %d", errno);
		return gen_error(s, errnum);
	}
}

static _kernel_oserror *ftp_pump_data(Session *s, _kernel_swi_regs *r, ftp_arbitrary_data *data)
{
	if (r->r[3] <= 0) {
		return state_BLOCKING;
	}
	else {
		const size_t remaining = data->length - data->done;
		size_t size = r->r[3] > remaining ? remaining : r->r[3];

		#ifdef TRACE
		protocol_debug("ftp_pump_data> copying %d bytes to client\n", size);
		#endif
		memcpy((char *)r->r[2], data->data + data->done, size);
		r->r[2] += size;
		r->r[3] -= size;
		r->r[4] += size;
		s->total_bytes_transferred += size;
		data->done += size;
		if (data->done != data->length) {
			return state_BLOCKING;
		}
		free(data->data);
		data->data = NULL;
		s->state = data->next_state;
		return NULL;
	}
}

static _kernel_oserror *ftp_pump_client_response(Session *s, _kernel_swi_regs *r)
{
	return ftp_pump_data(s, r, &s->client_pump);
}

static char *ftp_copy_data_type(const char *uri)
{
	const char *slash = strrchr(uri, '/'), *dot;

	if (slash == NULL) slash = uri;

	#ifdef TRACE
	protocol_debug("Attempting to determine MIME type for `%s' - slash = `%s'\n", uri, slash);
	#endif

	dot = strrchr(slash, '.');
	if (dot == NULL) {
		return Strdup("text/plain");
	}
	else {
		char buffer[100]; /* Arbitrary size - MimeMap module has totally broken API */
		_kernel_oserror *e;

		e = _swix(MimeMap_Translate, _INR(0,3), 3 /* extension */, dot,
			2 /* MIME */, buffer);
		if (e) {
			return Strdup("text/plain");
		}
		return Strdup(buffer);
	}
}

static _kernel_oserror *ftp_init_read_file(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	s->is_dir = 0;
	if (s->headers_sent == 0) {
		_kernel_oserror *e;
		char *data = ftp_copy_data_type(s->uri);
		s->headers_sent = 1;
		e = ftp_start_client_pump_va(s, FTP_READ_DATA, FTP_OK_DATA_1,
			data ? data : "application/octet-stream",
			FTP_OK_DATA_2, NULL);
		free(data);
		return e;
	}
	else {
		s->state = FTP_READ_DATA;
		return NULL;
	}
}

static _kernel_oserror *ftp_init_write_file(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	s->state = FTP_WRITE_DATA;
	return NULL;
}

static _kernel_oserror *ftp_init_read_directory(Session *s, _kernel_swi_regs *r)
{
        const int verbatim = (s->flags & flags_QUOTE_RESPONSE_VERBATIM);
        const int next_state = verbatim ? FTP_READ_DATA : FTP_READ_DIR_DATA;

	(void) r;
	s->is_dir = 1;

	if (s->headers_sent == 0) {
		_kernel_oserror *e;

		s->headers_sent = 1;
		if (verbatim) {
		        e = ftp_start_client_pump_va(s, next_state, FTP_DIR_VERB_1, s->url,
		        	FTP_DIR_VERB_2, NULL);
		}
		else {
			char *data = ftp_copy_message_token("DL01");
			e = ftp_start_client_pump_va(s, next_state, FTP_DIR_HEAD_1, s->url ? s->url :
				(data ? data : ""),
				FTP_DIR_HEAD_2, s->url, FTP_DIR_HEAD_3, NULL);
			free(data);
		}

		return e;
	}
	else {
		s->state = next_state;
		return NULL;
	}
}

static _kernel_oserror *ftp_wait_data_connection(Session *s, _kernel_swi_regs *r)
{
        int res = accept(s->listen_sd, NULL, 0);

	if (res >= 0) {
	        ftp_callback cb = s->next_state;
	        if (cb == NULL) {
	                s->state = FTP_STATUS_DEAD;
	                return NULL;
	        }
	        s->next_state = NULL;
	        s->data_sd = res;
	        close_socket(&s->listen_sd);
	        return (cb)(s, r);
	}
	else if (errno == EINPROGRESS) {
        	return state_BLOCKING;
	}
	else {
	        s->state = FTP_STATUS_ERROR_CONN;
	        return NULL;
	}
}

static _kernel_oserror *ftp_accept_data_connection(Session *s, _kernel_swi_regs *r, ftp_callback fn)
{
	(void) r;
        s->next_state = fn;
        s->state = FTP_WAIT_DATA_CONNECTION;
        return NULL;
}

static _kernel_oserror *ftp_got_retr_dir_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;

	if (ftp_class(s->response_code) != ftp_OK) {
		return gen_error(s, s->response.data);
	}
	else {
		/* It was a directory */
		char *data = ftp_copy_message_token("RE01");
		_kernel_oserror *e = ftp_start_client_pump_va(s,  FTP_STATUS_ENDED, FTP_FORCE_DIR_HEADER,
			s->url, data ? "/\r\nContent-Type: text/html\r\n\r\n" : "/\r\n\r\n",
			data, NULL);
		if (data) free(data);
		return e;
	}
}

static _kernel_oserror *ftp_got_retr_response(Session *s, _kernel_swi_regs *r)
{
	switch (ftp_class(s->response_code)) {
		case ftp_OK:
			/* ERK!  Transfer can't be done already!
			 * Still, remember the flag and read the data.
			 * Fall through here
			 */
		case ftp_INFORMATIONAL:
			s->had_final_response = s->response_code;
			if (s->listen_sd != -1) {
			        return ftp_accept_data_connection(s, r, ftp_init_read_file);
			}
			return ftp_init_read_file(s, r);

		case ftp_SERVER_ERROR:
			/* It may have been a directory */
			return vcommands_send(s, FTP_RETR_DIR_RESP_RECEIVED, "CWD", s->target_name);

		default:
			return gen_error(s, s->response.data);
	}
}

static _kernel_oserror *ftp_got_stor_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	switch (ftp_class(s->response_code)) {
		case ftp_OK:
			/* ERK!  Transfer can't be done already!
			 * Still, remember the flag and read the data.
			 * Fall through here.
			 */
		case ftp_INFORMATIONAL:
			s->had_final_response = s->response_code;
			if (s->listen_sd != -1) {
			        return ftp_accept_data_connection(s, r, ftp_init_write_file);
			}
			return ftp_init_write_file(s, r);

		default:
			return gen_error(s, s->response.data);
	}
}

static _kernel_oserror *ftp_got_list_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	switch (ftp_class(s->response_code)) {
		case ftp_OK:
			/* ERK!  Transfer can't be done already!
			 * Still, remember the flag and read the data.
			 * Fall through here
			 */
		case ftp_INFORMATIONAL:
			s->had_final_response = s->response_code;
			if (s->listen_sd != -1) {
			        return ftp_accept_data_connection(s, r, ftp_init_read_directory);
			}
			return ftp_init_read_directory(s, r);

		default:
			return gen_error(s, s->response.data);
	}
}

static char *ftp_copy_message_token(const char *tag)
{
	const char *token = NULL;
	size_t token_length;
	_kernel_oserror *result;

	result = read_message(tag, &token, &token_length);
	if (result != NULL) {
		return NULL;
	}
	else {
		if (token == NULL) {
			tag = strchr(tag, ':');
			if (tag != NULL) {
				return Strdup(tag + 1);
			}
			return NULL;
		}
		else {
			char *data = malloc(token_length+1);
			if (data == NULL) {
				return NULL;
			}
			memcpy(data, token, token_length);
			data[token_length] = '\0';
			return data;
		}
	}
}

static void ftp_vstart_client_pump(char *buffer, const char *h1, va_list ap)
{
	for (*buffer = '\0'; h1; h1 = va_arg(ap, char *)) {
		#ifdef TRACE
		/*protocol_debug("Copying string `%s'\n", h1);*/
		#endif
		buffer = strcat(buffer, h1);
	}
}

_kernel_oserror *ftp_start_client_pump_va(Session *s, int next_state, const char *h, ...)
{
	const char *h1 = h;
	va_list ap;
	size_t total_length = 0;

	s->client_pump.next_state = next_state;
	s->client_pump.done = 0;

	va_start(ap, h);
	while (h1 != NULL) {
		#ifdef TRACE
		/*protocol_debug("Adding length of `%s'\n", h1);*/
		#endif
		total_length += strlen(h1);
		h1 = va_arg(ap, const char *);
	}
	va_end(ap);

	s->client_pump.length = total_length;
	s->client_pump.data = malloc(total_length+1);
	if (s->client_pump.data == NULL) {
		s->state = FTP_STATUS_ERROR_MEM;
		return NULL;
	}

	va_start(ap, h);
	ftp_vstart_client_pump(s->client_pump.data, h, ap);
	va_end(ap);

	s->state = FTP_PUMPING_CLIENT_RESPONSE;
	return NULL;
}

static _kernel_oserror *ftp_start_client_pump(Session *s, int next_state, const char *h1, const char *mt_h2)
{
	char *const token = ftp_copy_message_token(mt_h2);

	if (token == NULL) {
		s->state = FTP_STATUS_TOKEN_NOT_FOUND;
		return NULL;
	}
	else {
		_kernel_oserror *result;
		result = ftp_start_client_pump_va(s, next_state, h1, token, NULL);
		free(token);
		return result;
	}
}

static _kernel_oserror *ftp_start_client_pump_url(Session *s, int next_state, const char *h1, const char *mt_h2,
		const char *url)
{
	char *const token = ftp_copy_message_token(mt_h2);

	if (token == NULL) {
		s->state = FTP_STATUS_TOKEN_NOT_FOUND;
		return NULL;
	}
	else {
		_kernel_oserror *result;
		result = ftp_start_client_pump_va(s, next_state, h1, token, url, NULL);
		free(token);
		return result;
	}
}

static _kernel_oserror *ftp_got_cwd_dir_response(Session *s, _kernel_swi_regs *r)
{
	/* Server has responded to our attempt to change into the directory
	 * Possibly responses are: OK, not a directory, doesn't exist/no permission
	 */
	(void) r;

	switch (ftp_class(s->response_code)) {
		case ftp_OK:
			/* It appears to have been a directory.  We're OK - LIST it
			 * but check first that we were asked for a directory and
			 * issue a redirect it we were not.
			 */
			for(;;) {
				char *last_slash = strrchr(s->url, '/');
				if (last_slash == NULL) {
					/* None at all?? */
					return make_error(FTP_ERROR_BAD_URI, 0);
				}
				if (last_slash[1] != '\0') {
					return ftp_start_client_pump_url(s, FTP_STATUS_ENDED,
						FTP_FORCE_DIR_HEADER, "ID01", s->url);
				}
				break;
			}
			return commands_send(s, FTP_LIST_RESP_RECEIVED, "LIST");

		case ftp_SERVER_ERROR:
			/* Error is: not a directory, doesn't exist, no permission */
			/* Was it a file? */
			return gen_error(s, s->response.data);

		default:
			return gen_error(s, s->response.data);
	}
}

static _kernel_oserror *ftp_got_stat_response(Session *s, _kernel_swi_regs *r)
{
        int cl = ftp_class(s->response_code);
	(void) r;

	if (cl != ftp_OK && cl != ftp_SERVER_ERROR) {
		return gen_error(s, s->response.data);
	}
	s->size = -1;
	return vcommands_send(s, FTP_RETR_RESP_RECEIVED, "RETR", s->target_name);
}

static _kernel_oserror *ftp_got_size_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;

	if (ftp_class(s->response_code) != ftp_OK) {
		return vcommands_send(s, FTP_STAT_RESP_RECEIVED, "STAT", s->target_name);
	}
	s->size = atoi(s->response.data + 4);
	return vcommands_send(s, FTP_RETR_RESP_RECEIVED, "RETR", s->target_name);
}

static _kernel_oserror *ftp_initiate_directory_transfer(Session *s, _kernel_swi_regs *r)
{
	(void) r;

	if (ftp_class(s->response_code) != ftp_OK) {
		return gen_error(s, s->response.data);
	}

	if (s->target_name[0] == '\0') {
		s->state = FTP_CWD_DIR_RESP_RECEIVED;
		return NULL;
	}

	return vcommands_send(s, FTP_CWD_DIR_RESP_RECEIVED, "CWD", s->target_name);
}

static _kernel_oserror *ftp_initiate_file_transfer(Session *s, _kernel_swi_regs *r)
{
	(void) r;

	if (ftp_class(s->response_code) != ftp_OK) {
		return gen_error(s, s->response.data);
	}

	switch (s->method) {
		case method_FTP_STOR:
			return vcommands_send(s, FTP_STOR_RESP_RECEIVED, "STOR", s->target_name);
		case method_FTP_STOU:
			return vcommands_send(s, FTP_STOR_RESP_RECEIVED, "STOU", s->target_name);
		case method_FTP_RETR:
			return vcommands_send(s, FTP_SIZE_RESP_RECEIVED, "SIZE", s->target_name);
		default:
			return make_error(FTP_ERROR_UNSUPPORTED_METHOD, 0);
	}
}

static _kernel_oserror *ftp_start_transfer_request(Session *s, _kernel_swi_regs *r)
{
	/* This is a simple set-up function, to avoid any potential stack overflowing
	 * due to the PASV response handler.
	 */
	(void) r;
	if (s->is_dir) {
		return commands_send(s, FTP_INITIATE_DIR_TRANSFER, "TYPE A");
	}
	else {
		return commands_send(s, FTP_INITIATE_FILE_TRANSFER, "TYPE I");
	}
}

static int ftp_process_pwd_response(Session *s, char **buffer)
{
	*buffer = Strdup(s->response.data + 5);

	if (*buffer == NULL) {
		s->state = FTP_STATUS_ERROR_MEM;
		return 1;
	}
	else {
		/* Undo the quoting */
		char *last_quote = *buffer;
		for (;;) {
			char *next_quote = strchr(last_quote, '\"');

			if (next_quote == NULL) {
				s->state = FTP_STATUS_ERROR_UNEXPECTED;
				free(*buffer);
				*buffer = NULL;
				return 1;
			}
			if (next_quote[1] == '\"') {
				memmove(next_quote+1, next_quote+2, strlen(next_quote)-1);
				last_quote = next_quote + 1;
				continue;
			}
			last_quote = next_quote;
			break;
		}

		*last_quote = '\0';
		/* We have now removed any quoted quotes from the given directory string */
	}

	return 0;
}


static _kernel_oserror *ftp_got_dele_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	s->server_code = s->response_code;
	if (ftp_class(s->response_code) == ftp_OK) {
		return ftp_start_client_pump(s, FTP_STATUS_ENDED, FTP_OK_HEADER, "DE01");
	}
	return gen_error(s, s->response.data);
}

static _kernel_oserror *ftp_got_mkdir_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	s->server_code = s->response_code;
	if (ftp_class(s->response_code) == ftp_OK) {
		char *dir;
		ftp_process_pwd_response(s, &dir);
		free(dir);
		return ftp_start_client_pump(s, FTP_STATUS_ENDED, FTP_OK_HEADER, "MD01");
	}
	return gen_error(s, s->response.data);
}

static _kernel_oserror *ftp_got_rmdir_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	s->server_code = s->response_code;
	if (ftp_class(s->response_code) == ftp_OK) {
		return ftp_start_client_pump(s, FTP_STATUS_ENDED, FTP_OK_HEADER, "RD01");
	}
	return gen_error(s, s->response.data);
}

static _kernel_oserror *ftp_got_rnto_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	s->server_code = s->response_code;
	if (ftp_class(s->response_code) == ftp_OK) {
		return ftp_start_client_pump(s, FTP_STATUS_ENDED, FTP_OK_HEADER, "RN01");
	}
	return gen_error(s, s->response.data);
}

static _kernel_oserror *ftp_got_rnfr_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	s->server_code = s->response_code;
	if (ftp_class(s->response_code) == ftp_PENDING) {
		/* Server accepted the command so far - send the destination URL */
		return vcommands_send(s, FTP_RNTO_RESP_RECEIVED, "RNTO", s->rename_uri);
	}
	return gen_error(s, s->response.data);
}

static _kernel_oserror *ftp_initiate_delete(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return vcommands_send(s, FTP_DELE_RESP_RECEIVED, "DELE", s->target_name);
}

static _kernel_oserror *ftp_initiate_mkdir(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return vcommands_send(s, FTP_MKDIR_RESP_RECEIVED, "MKD", s->target_name);
}

static _kernel_oserror *ftp_initiate_rmdir(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return vcommands_send(s, FTP_RMDIR_RESP_RECEIVED, "RMD", s->target_name);
}

static _kernel_oserror *ftp_initiate_rename(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	if (s->rename_uri == NULL) {
		return make_error(FTP_ERROR_BAD_DATA, 0);
	}
	else {
		if (ftp_rewrite_path(s, s->rename_uri, &s->rename_name) == NULL) {
			s->state = FTP_STATUS_ERROR_MEM;
			return NULL;
		}
	}
	return vcommands_send(s, FTP_RNFR_RESP_RECEIVED, "RNFR", s->target_name);
}

static _kernel_oserror *ftp_got_pasv_response(Session *s, _kernel_swi_regs *r)
{
	/* Find out to where we need to connect - parse response to find out */

	if (s->response_code != 227) {
	        if (s->response_code == 425) {
	                /* 425: Unable to build data connection: permission denied - almost certainly */
	                char port_data[sizeof("123,123,123,123,123,123")], *ptr;
	                struct sockaddr_in sin;
	                int sk;

			#ifdef TRACE
			if (s->connectionflags & connectionflags_NO_PASV) {
			        protocol_debug("We remember this server - it didn't like PASV earlier\n");
			}
			else {
				protocol_debug("Server rejected PASV with permission denied - I think\n");
			}
			protocol_debug("We'll remember this server and try PORT instead\n");
			#endif

			/* Remember that this server doesn't like PASV connections */
			s->connectionflags |= connectionflags_NO_PASV;

	                sk = ftp_bindsock(s->control_sd, &sin);
	                if (sk<0) {
	        		s->state = FTP_STATUS_ERROR_CONN;
	                        return gen_error(s, s->response.data);
	                }
	                s->listen_sd = sk;
	                /* This is OK - inet_ntoa not allowed to generate IPv6 strings */
	                strcpy(port_data, inet_ntoa(sin.sin_addr));
			for (ptr=port_data;*ptr;++ptr) {
			        if (*ptr == '.') *ptr = ',';
			}
			sprintf(ptr, ",%d,%d", sin.sin_port & 0xFF, (sin.sin_port >> 8) & 0xFF);
			#ifdef TRACE
			protocol_debug("Sending PORT command to `%s'\n", port_data);
			#endif
	                return vcommands_send(s, FTP_PORT_RESP_RECEIVED, "PORT", port_data);
	        }
	        else {
			return gen_error(s, s->response.data);
	        }
	}
	else {
		int ip[6];
		char *first_digit = NULL;
		char *digits;
		int digit_count = 0;
		for (digits = s->response.data+3; *digits && digit_count<sizeof("1,2,3,4,5"); ++digits) {
			if (isdigit(*digits) || *digits == ',') {
				if (digit_count == 0 && *digits != ',') {
					first_digit = digits;
				}
				++digit_count;
			}
		}
		if (!*digits) {
			return make_error(FTP_ERROR_BAD_DATA, 0);
		}
		if (sscanf(first_digit, "%d,%d,%d,%d,%d,%d", ip, ip+1, ip+2, ip+3, ip+4, ip+5) != 6) {
			return make_error(FTP_ERROR_BAD_DATA, 0);
		}
		else {
			char ip_address[sizeof("123.123.123.123")];
			int ctr, state;

			for (ctr=0; ctr<6; ++ctr) {
				if (ip[ctr] < 0 || ip[ctr] > 255) {
					return make_error(FTP_ERROR_BAD_DATA, 0);
				}
			}

			sprintf(ip_address, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
			s->data_sd = opensock(ip_address, ip[4]*256+ip[5], NULL, &state, -1);
			if (s->data_sd < 0 || state != FTP_CONNECTED) {
				return make_error(FTP_ERROR_NO_DATA_CONNECTION, 0);
			}
			/* To get here, we have created the data socket and started it off connecting
			 * to the remote server.
			 */
		}
	}
	/* This statement is left at the top-level so that all those local variables go out of scope */
	return ftp_start_transfer_request(s, r);
}

static _kernel_oserror *ftp_got_port_response(Session *s, _kernel_swi_regs *r)
{
	/* Find out to where we need to connect - parse response to find out */

	if (s->response_code != 200) {
		return gen_error(s, s->response.data);
	}
	else {
		return ftp_start_transfer_request(s, r);
	}
}

#if 0
static _kernel_oserror *ftp_initiate_null_redirect(Session *s, _kernel_swi_regs *r)
{
	/* It was a root directory request */
	char *data = ftp_copy_message_token("RE02");
	_kernel_oserror *e = ftp_start_client_pump_va(s,  FTP_STATUS_ENDED, FTP_FORCE_DIR_HEADER,
		s->url, data ? "\r\nContent-Type: text/html\r\n\r\n" : "\r\n\r\n",
		data, NULL);
	if (data) free(data);

	(void) r;
	return e;
}
#endif

static _kernel_oserror *ftp_initiate_command(Session *s, _kernel_swi_regs *r)
{
	if (ftp_rewrite_path(s, s->uri, &s->target_name) == NULL) {
	        s->state = FTP_STATUS_ERROR_MEM;
	        return NULL;
	}

	#ifdef TRACE
	protocol_debug("Rewritten path is `%s'\n", s->target_name);
	#endif

	switch (s->method) {
		case method_FTP_RETR:
		case method_FTP_STOR:
			/*
			if (s->target_name[0] == '\0' && s->is_) {
                                return ftp_initiate_null_redirect(s, r);
			}
			*/
                        if (s->connectionflags & connectionflags_NO_PASV) {
				/* Previous experience of this server shows that it is
				 * a waste of time trying PASV connections
				 */
                                /* We will "pretend" that we have just received the PASV
                                 * refusal and fall into the code directly
                                 */
                                s->state = FTP_PASV_RESP_RECEIVED;
                                s->response_code = 425;
                                return ftp_got_pasv_response(s, r);
                        }
		        return commands_send(s, FTP_PASV_RESP_RECEIVED, "PASV");
		case method_FTP_MKDIR:
			return ftp_initiate_mkdir(s, r);
		case method_FTP_RMDIR:
			return ftp_initiate_rmdir(s, r);
		case method_FTP_RENAME:
			return ftp_initiate_rename(s, r);
		case method_FTP_DELETE:
			return ftp_initiate_delete(s, r);
		default:
			return make_error(FTP_ERROR_UNSUPPORTED_METHOD, 0);
	}
}

static _kernel_oserror *ftp_got_cwd_home_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	if (ftp_class(s->response_code) != ftp_OK) {
		return gen_error(s, s->response.data);
	}

	s->state = FTP_INITIATE_COMMAND;
	return NULL;
}

static _kernel_oserror *ftp_send_cwd_home(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return vcommands_send(s, FTP_GOT_CWD_HOME_RESP, "CWD", s->home ? s->home : "/");
}

static _kernel_oserror *ftp_got_pwd_response(Session *s, _kernel_swi_regs *r)
{
	/* User has logged in successfully, now we can consider executing the requested
	 * command, but first we need to discover our home directory.
	 */

	(void) r;

	if ((s->response_code / 10) != 25) {
		return gen_error(s, s->response.data);
	}
	if (s->response.data[4] != '\"') {
		s->state = FTP_STATUS_ERROR_UNEXPECTED;
		return NULL;
	}
	else {
		char *buffer;
		if (ftp_process_pwd_response(s, &buffer)) {
			return NULL;
		}
		s->home = buffer;
	}

	s->state = FTP_INITIATE_COMMAND;
	return NULL;
}

static _kernel_oserror *ftp_logged_in_ok(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return commands_send(s, FTP_GOT_PWD_RESP, "PWD");
}

static _kernel_oserror *ftp_got_acct_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	switch (ftp_class(s->response_code)) {
		default:
			return gen_error(s, s->response.data);
		case ftp_OK:
			s->state = FTP_LOGGED_IN;
			return NULL;
	}
}

static _kernel_oserror *ftp_got_pass_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	switch (ftp_class(s->response_code)) {
		default:
			return gen_error(s, s->response.data);
		case ftp_PENDING:
			return vcommands_send(s, FTP_ACCT_RESP_RECEIVED, "ACCT", s->acct ? s->acct : "FTPUser@");
		case ftp_OK:
			s->state = FTP_LOGGED_IN;
			return NULL;
	}
}

static _kernel_oserror *ftp_got_user_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	switch (ftp_class(s->response_code)) {
		default:
			return gen_error(s, s->response.data);
		case ftp_PENDING:
			if (s->user != NULL && (s->pass == NULL || s->pass[0] == '\0'))  {
				s->cacheable = 0;
				return ftp_start_client_pump_va(s, FTP_STATUS_ENDED, FTP_AUTH_REQUIRED,
					s->user, FTP_AUTH_REQD_2, s->user, FTP_AUTH_REQD_3, NULL);
			}
			return vcommands_send(s, FTP_PASS_RESP_RECEIVED, "PASS", s->pass ? s->pass : "FTPUser@");
		case ftp_OK:
			s->state = FTP_LOGGED_IN;
			return NULL;
	}
}

static _kernel_oserror *ftp_got_syst_response(Session *s, _kernel_swi_regs *r)
{
	(void) r;

	#ifdef TRACE
	protocol_debug("Server type is `%s'\n", s->response.data + 4);
	#endif

	if (!strncmp(s->response.data + 4, "UNIX Type: L8 MAC-OS MachTen", 28)) {
		s->server_type = ftp_server_MACHTEN;
	}
	if (strstr(s->response.data + 4, "UNIX")) {
		s->server_type = ftp_server_UNIX;
	}
	else if (!Strncmp_ci(s->response.data + 4, "NETWARE", 7)) {
		s->server_type = ftp_server_NETWARE;
	}
	else if (!Strncmp_ci(s->response.data + 4, "Windows_NT", 10)) {
		s->server_type = ftp_server_WINNT;
	}
	else if (strstr(s->response.data+4, "MAC-OS TCP/Connect II") != NULL) {
		s->server_type = ftp_server_TCPC;
	}
	else if (!strncmp(s->response.data+4, "MACOS Peter's Server", 20)) {
		s->server_type = ftp_server_PLEWIS;
	}
	else if (!strncmp(s->response.data+4, "MACOS AppleShare IP FTP Server", 30)) {
		s->server_type = ftp_server_APPLESHARE_IP;
	}
	else if (!strncmp(s->response.data + 4, "VMS", 3)) {
		s->server_type = ftp_server_VMS;
	}
	else {
		s->server_type = ftp_server_OTHER;
	}

	return vcommands_send(s, FTP_USER_RESP_RECEIVED, "USER", s->user ? s->user : "anonymous");
}

static _kernel_oserror *ftp_got_initial_greeting(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	if (ftp_class(s->response_code) != ftp_OK) {
		return gen_error(s, s->response.data);
	}
	if (s->response_code == 221) {
		/* Probably a connection timed out failure */
		close_socket(&s->control_sd);
		/* Then establish the connection */
		s->control_sd = opensock(s->host, s->port, NULL, &s->state, -1);

		/* We failed to connect! */
		if (s->control_sd == -1) {
			kill_session(s);
			r->r[0] = *((int *)r->r[1]) = status_ABORTED;
			return make_error(FTP_ERROR_CONNECT_FAIL, 0);
		}
		return NULL;
	}
	return commands_send(s, FTP_SYST_RECEIVED, "SYST");
}

static _kernel_oserror *ftp_wait_initial_greeting(Session *s, _kernel_swi_regs *r)
{
	(void) r;
	return commands_recv(s, FTP_GREETING_RECEIVED);
}


static _kernel_oserror *ftp_wait_dns(Session *ses, _kernel_swi_regs *r)
{
	int *pollword = (int *)r->r[1];

	ses->control_sd = opensock(ses->host, ses->port, NULL, &ses->state, ses->control_sd);
	if (ses->control_sd < 0) {
	        ses->control_sd = -1;
		*pollword = status_ABORTED;
		return make_error(FTP_ERROR_CONNECT_FAIL, 0);
	}

	*pollword = r->r[0] = ses->reported_state =
		(ses->state == FTP_STATUS_DNS) ? status_NOT_YET_CONNECTED : status_CONNECTED_TO_SERVER;

	return NULL;
}


_kernel_oserror *ftp_abort(Session *ses, _kernel_swi_regs *r)
{
	int code = 1;
	char buffer[4];
	int *pollword = (int *)r->r[1];
	_kernel_oserror *e;

	if (ses->control_sd == -1) {
		return NULL;
	}

	while (code > 0) {
		usermode_donothing();
		code = socketread(ses->control_sd,buffer,sizeof(buffer));	/* drain command channel */
	}

	buffer[0] = 255;	/* telnet IAC */
	buffer[1] = 244;	/* telnet IP  */
	buffer[2] = 255;	/* telnet IAC */
	send(ses->control_sd, buffer, 3, 0);
	buffer[0] = 242;	/* telnet DM  */
	send(ses->control_sd, buffer, 1, MSG_OOB);	/* Send DM, marked URGENT */

	*pollword  = ses->reported_state = r->r[0] = status_ABORTED;
	r->r[4]	   = 0;	 /* Bytes read */
	r->r[5]	   = 0;	 /* Bytes pending */

	pollword = malloc(sizeof(int));
	if (pollword != NULL) {
		ses->id = (int) pollword;
		module_call_after();
	}

	e = commands_send(ses, FTP_ABOR_RESP_RECEIVED, "ABOR");
	if (ses->state == FTP_STATUS_ENDED) {
		/* We already saw the response */
		return e;
	}
	else {
		ses->aborting = 1;
		ses->outstanding_response = 1;
		return state_BLOCKING;
	}
}

static _kernel_oserror *ftp_got_abor_response(Session *ses, _kernel_swi_regs *r)
{
	int *pollword = (int *)r->r[1];

	/* We'll ignore the response */

	*pollword  = ses->reported_state = r->r[0] = status_ABORTED | status_ALL_DATA_RECEIVED;
	r->r[2]	   = ses->response_code;
	r->r[4]	   = 0;	 /* Bytes read */
	r->r[5]	   = 0;	 /* Bytes pending */
	ses->state = FTP_STATUS_ENDED;
	ses->aborting = 0;
	ses->outstanding_response = 0;
	new_connection(ses);

	return NULL;
}
