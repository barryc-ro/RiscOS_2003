/*
 * FTP (c.module)
 *
 * © Acorn Computers Ltd. 1996-1997
 *
 */
 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "sys/errno.h"
#include "module.h"
#include "FTPhdr.h"
#include "utils.h"
#include "protocol.h"

#include "MemCheck:MemCheck.h"

#define NO_SUCH_SWI	(0x1E6)

#define URL_PROTOCOL_REGISTER 0x83e20
#define URL_PROTOCOL_DEREGISTER 0x83e21

static int callback_pending_flag;
extern int resources_area(void);


/* Sets clibrary_realloc_routine_is_buggy to 1 if RISC OS 3.1 or earlier (ROM realloc is broken) */
static int clibrary_realloc_routine_is_buggy;
static void module_check_os_version(void)
{
        int os;
        (void) _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 0, 255, &os);
        clibrary_realloc_routine_is_buggy = (os <= 0xA4);
}


static int registered;

static _kernel_oserror *try_to_register(void)
{
        _kernel_oserror *e;
        
	if (registered) return NULL;
	e = _swix(URL_PROTOCOL_REGISTER, _INR(0,4), 0, FTPFetcher_00, "ftp:",
		Module_VersionNumber, Module_Help " © Acorn 1997 (Built: " Module_Date ")");
	if (e == NULL) {
	        registered = 1;
	}
        return e;
}

static _kernel_oserror *try_to_deregister(void)
{
        if (!registered) {
                return NULL;
        }
        else {
                registered = 0;
		return _swix(URL_PROTOCOL_DEREGISTER, _INR(0,1), 0, FTPFetcher_00);
        }
}

static _kernel_oserror *register_with_url(void)
{
        _kernel_oserror *e;
        
	e = try_to_register(); 
	if (e == NULL) return e;
	if (e->errnum != NO_SUCH_SWI) return e;
	e = _swix(OS_Module, _INR(0,1), 1 /* Load */, "System:Modules.Network.URL.URL");
	return try_to_register();
}

/*************************************************************/
/* _kernel_oserror *module_init(char *cmd_fail, int podu...  */
/*************************************************************/
/* Start up and register ourselves with the URL module       */
/*************************************************************/
_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw)
{
    	_kernel_oserror *e;
    
    	(void) podule_base;
    	(void) cmd_tail;

	registered = 0;

	module_check_os_version();
	init_sessions();

  	MemCheck_InitNoDebug();
        MemCheck_SetQuitting(0,0);
  	MemCheck_RedirectToFilename("adfs::4.Trace.FTP_mem");
  	MemCheck_InterceptSCLStringFunctions();
  	MemCheck_RegisterMiscBlock((void *)0x01c0001c,8164);
  	MemCheck_SetStoreMallocFunctions(1);
  	MemCheck_SetReportFrees(1);
  	MemCheck_SetChecking(0,0);

  	e = register_with_url();
  	if (e) {
  	        if (e->errnum == NO_SUCH_SWI) {
  	                _kernel_oserror *newe = find_error();
  	                const size_t length = strlen(strcpy(newe->errmess, e->errmess));

  	                newe->errnum = NO_SUCH_SWI;
			strncat(newe->errmess, " (Load the URL module)", sizeof(newe->errmess) - length);
			return newe;
  	        }
    		return e;
    	}

  	e = _swix(ResourceFS_RegisterFiles, _IN(0), resources_area());
  	if (e) {
  	        (void) try_to_deregister();
    		return e;
        }
  
  	e = messages_file_open("Resources:$.Resources.FTPFetcher.Messages");
  	if (e) {
    		(void) _swix(ResourceFS_DeregisterFiles, _IN(0), resources_area());
  	        (void) try_to_deregister();
    		return e;
    	}

  	callback_pending_flag = 0;
  	e = _swix(OS_CallEvery, _INR(0,2), 15*100-1, callevery_entry, pw);
  	if (e) {
    		messages_file_close();
    		(void) _swix(ResourceFS_DeregisterFiles, _IN(0), resources_area());
  	        (void) try_to_deregister();
    		return e;
        }

  	return NULL;
}


void service_handler(int service_number, _kernel_swi_regs *r, void *pw)
{
        #ifdef TRACE
        protocol_debug("Service &%X: R0 = %d for URL version  %03d\n", service_number, r->r[0], r->r[2]);
        #endif
        (void) pw;
        (void) service_number;

	switch (r->r[0]) {
	        case 0:
	        	(void) try_to_register();
	        	break;
	        case 1:
	        	(void) try_to_deregister();
	        	break;
	        default:
	        	break;
	}
}


static void *current_pw;

_kernel_oserror *module_call_after(void)
{
        if (callback_pending_flag == 0) {
	        (void) _swix(OS_CallAfter, _INR(0,2), 100-1, callevery_entry, current_pw);
	}
	return NULL;
}

_kernel_oserror *module_kill(int fatal, int podule, void *pw)
{
    	(void) fatal;
    	(void) podule;

	/* Do I need to do this twice?  I have a ticker event AND a possible callback
	 * in the pending list, so for safety, I'm going to do it twice
	 */
	(void) _swix(OS_RemoveTickerEvent, _INR(0,1), callevery_entry, pw);
	(void) _swix(OS_RemoveTickerEvent, _INR(0,1), callevery_entry, pw);
    	if (callback_pending_flag) {
      		(void) _swix(OS_RemoveCallBack, _INR(0,1), callback_entry, pw);
    	}
    	messages_file_close();
    	(void) _swix(ResourceFS_DeregisterFiles, _IN(0), resources_area());

	ses_kill_all();
	conn_kill_all();

       (void) try_to_deregister();

    	return NULL;
}


_kernel_oserror *swi_handler(int swi_offset, _kernel_swi_regs *r, void *pw)
{
	current_pw = pw;

  	switch (swi_offset) {
     		case FTPFetcher_GetData - FTPFetcher_00:
       			return(ftp_start(r));

     		case FTPFetcher_Status - FTPFetcher_00:
       			return(ftp_status(r));

     		case FTPFetcher_ReadData - FTPFetcher_00:
       			return(ftp_readdata(r));

     		case FTPFetcher_Stop - FTPFetcher_00:
		       return (ftp_stop(r));

     		default:
       			return(error_BAD_SWI);
        }
}


int callback_handler(_kernel_swi_regs *r, void *pw)
{
    	int time;
    	Connection *c;
    	Session *s;

    	(void) pw;
    	(void) r;

    	if (!callback_pending_flag) {
      		return 1;
      	}

    	(void) _swix(OS_ReadMonotonicTime, _OUT(0), &time);

    	for (c = find_first_connection(); c;) {
        	if ((time - c->last_use) > CONNECTION_TIMEOUT) {
            		Connection *temp = c->next;
        	        #ifdef TRACE
        	        protocol_debug("Closing cached connection\n");
        	        #endif
            		kill_connection(c);
            		c = temp;
            		continue;
                }
        	c = c->next;
        }

	/* Continue processing aborting sessions */
	for (s = find_first_session(); s;) {
	        if (s->aborting) {
	                _kernel_swi_regs r;
	                char buffer[16];
	                
	                #ifdef TRACE
	                protocol_debug("Processing abandonned session %p to completion ...\n", s);
	                #endif
	                r.r[0] = 0;
	                r.r[1] = s->id;
	                r.r[2] = (int) buffer;
	                r.r[3] = sizeof(buffer);
	                if (swi_handler(FTPFetcher_ReadData - FTPFetcher_00, &r, pw) || !s->aborting) {
	                        Session *next = s->next;
				free((void *)s->id);
	                        kill_session(s);
	                        s = next;
	                        continue;
	                }
	        }
                s = s->next;
	}

    	callback_pending_flag = 0;
	return 1;
}

int callevery_handler(_kernel_swi_regs *r, void *pw)
{
        (void) r;
  	if (callback_pending_flag) {
   		return 1;
   	}
  	callback_pending_flag = 1;
  	(void) _swix(OS_AddCallBack, _INR(0,1), callback_entry, pw);
  	return 1;
}



/* RISC OS 3.1 SVC mode realloc is broken, so we must provide our own */
char *module_realloc(void *ptr, size_t size)
{
        #ifdef TRACE
        protocol_debug("module_realloc(%p, %d)\n", ptr, size);
        #endif
	if (!clibrary_realloc_routine_is_buggy) return realloc(ptr, size);
	        
        if (ptr == NULL) {
                return malloc(size);
        }
        if (size == 0) {
                free(ptr);
		return NULL;
        }
	else {
	        const int *rma_block = ptr;
	        const size_t newsize = size - (rma_block[-1] - 4);
	        char *newptr;

		if (_swix(OS_Module, _IN(0)|_INR(2,3)|_OUT(2), 0xD, ptr, newsize, &newptr) != NULL) {
		        return NULL;
		}
		
		return newptr;
	}
}
