/*
 * SSL (c.acornssl)
 *
 * © Acorn Computers Ltd. 1998
 *
 */


/* This code is heavily influenced by SSLeay's apps.c.s_client */

#define USE_SOCKETS

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "sys/errno.h"
#include "SSLHdr.h"
#include "utils.h"
#include "module.h"
#include "sys/types.h"
#include "socklib.h"
#include "acornssl.h"
#include "protocol.h"
#include "memory.h"

/* RISC OS 3.1 needs to reset the memory functions to avoid realloc fault */


void acornssl_init_mem_functions(enum mem_scheme m)
{
	extern int CRYPTO_set_mem_functions(void *(*)(size_t), void *(*)(void *, size_t),
		void (*)(void *));
        if (m == mem_USE_DYNAMIC_AREA) {
		CRYPTO_set_mem_functions(acornssl_mem_malloc, acornssl_mem_realloc, acornssl_mem_free);
        }
        else {
		CRYPTO_set_mem_functions(malloc, module_realloc, free);
        }
}

#define SHUTDOWN(s) {shutdown(s,2);socketclose(s);}

static SSL_METHOD *meth = NULL;
static BIO *outputsink;



int acornssl_ioctl(Session *_s, unsigned long op, void *data)
{
	int s;

	if (_s->state < sslstate_working) {
		s = _s->s;
	}
	else {
		s = SSL_get_fd(_s->con);
	}
	return socketioctl(s, op, data);
}

/*
int acornssl_socket(int pf, int ss, int pr)
{
	return socket(pf, ss, pr);
}
*/

int acornssl_connect(Session *_s, const struct sockaddr *sin, int slen)
{
	BIO *sbio;
	int ret = connect(_s->s, sin, slen);

	if (ret < 0 && errno != EINPROGRESS) {
		return ret;
	}

	sbio = BIO_new_socket(_s->s, BIO_NOCLOSE);
	if (sbio == NULL) {
		SHUTDOWN(_s->s);
		errno = ENOBUFS;
		_s->s = -1;
		return -1;
	}

	SSL_set_bio(_s->con, sbio, sbio);

	if (ret < 0) {
		/* OK - we are waiting for completion of connection */
		_s->state = sslstate_connect_in_progress;
	}
	else {
		_s->state = sslstate_working;
		SSL_set_connect_state(_s->con);
		_s->s = -1;
	}


	return ret;
}

/* Fuction returns zero if the connection is not yet established yet, or has been broken,
 * and non-zero if it has completed making the connection.
 */
static int acornssl_check_for_connect_completion(Session *_s)
{
	if (_s->state == sslstate_finalise) {
		errno = 0;
		return 0;
	}

	if (_s->state == sslstate_initial) {
		DEBUG(("Socket has not been connect()'ed yet!  ENOTCONN returned\n"));
		errno = ENOTCONN;
		return 0;
	}
	else if (_s->state == sslstate_connect_in_progress) {
		struct timeval tv;
		int sd = _s->s;
		fd_set fd;
		FD_ZERO(&fd);
		FD_SET(sd, &fd);
		timerclear(&tv);
		if (select(sd+1, NULL, &fd, NULL, &tv) > 0) {
			DEBUG(("Socket is ready for writing!  Move to working state\n"));
			_s->state = sslstate_working;
			SSL_set_connect_state(_s->con);
			_s->s = -1;
			errno = 0;
		}
		else {
			DEBUG(("Socket is NOT ready (says select) - Keep waiting - ENOTCONN\n"));
			errno = ENOTCONN;
		}
	}

	return _s->state > sslstate_connect_in_progress;
}

int acornssl_shutdown(Session *_s, int how)
{
	/* Ignore such calls for now - no obvious call to make */
	(void) _s;
	(void) how;
	return 0;
}

int acornssl_close(Session *_s)
{
	/* _s has already been validated by the SWI veneers */
	kill_session(_s);
	return 0;
}

int acornssl_getsockopt(Session *_s, int sol, int var, void *ptr, int *szptr)
{
	int s;

	if (_s->state < sslstate_working) {
		s = _s->s;
	}
	else {
		s = SSL_get_fd(_s->con);
	}

	return getsockopt(s, sol, var, ptr, szptr);
}

int acornssl_write(Session *_s, const void *ptr, size_t amt)
{
	SSL *con = _s->con;

	if (!con) {
		errno = ENOTSOCK;
		return -1;
	}
	else if (!acornssl_check_for_connect_completion(_s)) {
		return -(errno != 0);
	}
	/*
	else if (SSL_in_init(con)) {
		DEBUG(("SSL initialisation code is executing - defer writing\n"));
		errno = ENOTCONN;
		return -1;
	}
	*/
	else {
		struct timeval tv;
		static fd_set fd;
		const int sd = SSL_get_fd(con);
		int k;

		DEBUG(("SSL write operation - examining socket %d writeworthiness\n", sd));


		timerclear(&tv);
		FD_ZERO(&fd);
		FD_SET(sd, &fd);
		switch (select(sd+1, NULL, &fd, NULL, &tv)) {
			case 0:
				errno = EWOULDBLOCK;
				/*FALLTHROUGH*/
			case -1:
				DEBUG(("SSL_write: pre-select says no possibility to write\n"));
				return -1;
			default:
				break;
		}

		DEBUG(("SSL_write: socket was writable.  Writing data!\n"));

		k = SSL_write(con, (void *) ptr, amt);
		switch (SSL_get_error(con, k)) {
			case SSL_ERROR_NONE:
				DEBUG(("SSL_ERROR_NONE\n"));
				return k;
			case SSL_ERROR_ZERO_RETURN:
				DEBUG(("SSL_ERROR_ZERO_RETURN\n"));
				return 0;
			case SSL_ERROR_WANT_READ:
				DEBUG(("SSL_ERROR_WANT_READ\n"));
			case SSL_ERROR_WANT_WRITE:
			case SSL_ERROR_WANT_X509_LOOKUP:
				DEBUG(("SSL_ERROR_WANT_READ/WRITE/X509_LOOKUP\n"));
				if (SSL_in_init(con)) {
					errno = ENOTCONN;
				}
				else {
					errno = EWOULDBLOCK;
				}
				DEBUG(("Returning errno=%d (%s)\n", errno, errstring(errno)));
				return -1;
			case SSL_ERROR_SYSCALL:
				DEBUG(("SSL_ERROR_SYSCALL: errno=%d (%s)\n", errno, errstring(errno)));
				if (SSL_in_init(con) && errno == EWOULDBLOCK) {
					DEBUG(("SSL_in_init is still TRUE - return ENOTCONN\n"));
					errno = ENOTCONN;
				}
				return -1;
			default:
			case SSL_ERROR_SSL:
				/* Internal error */
				DEBUG(("SSL_ERROR_SSL\n"));
				errno = ECONNABORTED;
				return -1;
		}
	}
}

int acornssl_recv(Session *_s, void *ptr, size_t max, int flags)
{
	SSL *con = _s->con;

	if (!con) {
		errno = ENOTSOCK;
		return -1;
	}
	else if (!acornssl_check_for_connect_completion(_s)) {
		return -(errno != 0);
	}
	/*
	else if (SSL_in_init(con)) {
		errno = ENOTCONN;
		return -1;
	}
	*/
	else {
		struct timeval tv;
		static fd_set fd;
		const int sd = SSL_get_fd(con);
		int k;

		DEBUG(("SSL read operation - examining socket %d readworthiness\n", sd));

		timerclear(&tv);
		FD_ZERO(&fd);
		FD_SET(sd, &fd);
		switch (select(sd+1, &fd, NULL, NULL, &tv)) {
			case 0:
				DEBUG(("SSL_read: pre-select says no possibility to read\n"));
				if (_s->bufptr == 0) {
					errno = EWOULDBLOCK;
					return -1;
				}
				break;
			case -1:
			        DEBUG(("SSL_read: select error: %d (%s)\n", errno, errstring(errno)));
				return -1;
			default:
				break;
		}

		if (flags & MSG_PEEK) {
			int new_max = TMPBUFSIZ - _s->bufptr;

			if (new_max == 0) {
			        const size_t amt_to_store = max > _s->bufptr ? _s->bufptr : max;
			        memcpy(ptr, _s->buffer, amt_to_store);
			        return amt_to_store;
			}

			k = SSL_read(con, _s->buffer + _s->bufptr, new_max);
			switch (SSL_get_error(con, k)) {
				case SSL_ERROR_NONE:
					DEBUG(("P SSL_ERROR_NONE\n"));
					break;
				case SSL_ERROR_ZERO_RETURN:
					DEBUG(("P SSL_ERROR_ZERO_RETURN\n"));
					k = 0;
					break;
				default:
				case SSL_ERROR_SSL:
					/* Internal error */
					k = -1;
					errno = EWOULDBLOCK;
					break;
			}

			if (k != -1) {
			        _s->bufptr += k;
			}

			if (_s->bufptr > 0) {
			        const size_t amt_to_store = max > _s->bufptr ? _s->bufptr : max;
			        memcpy(ptr, _s->buffer, amt_to_store);
			        return amt_to_store;
			}

			return k;
		}
		else {
			DEBUG(("SSL_read: socket was readable.  READING the data\n"));
			if (_s->bufptr > 0) {
			        const size_t amt_to_store = max > _s->bufptr ? _s->bufptr : max;
				/* Copy data block to client */
			        memcpy(ptr, _s->buffer, amt_to_store);
			        if (amt_to_store == _s->bufptr) {
			                _s->bufptr = 0;
			        }
			        else {
				        memmove(_s->buffer, _s->buffer + amt_to_store,
				        	_s->bufptr - amt_to_store);
				        _s->bufptr -= amt_to_store;
			        }
			        return amt_to_store;
			}
			k = SSL_read(con, ptr, max);
		}
		switch (SSL_get_error(con, k)) {
			case SSL_ERROR_NONE:
				DEBUG(("R SSL_ERROR_NONE\n"));
				return k;
			case SSL_ERROR_ZERO_RETURN:
				DEBUG(("R SSL_ERROR_ZERO_RETURN\n"));
				return 0;
			case SSL_ERROR_WANT_READ:
				DEBUG(("R SSL_ERROR_WANT_READ\n"));
			case SSL_ERROR_WANT_WRITE:
			case SSL_ERROR_WANT_X509_LOOKUP:
				DEBUG(("R SSL_ERROR_WANT_READ/WRITE/X509_LOOKUP\n"));
				if (SSL_in_init(con)) {
					errno = ENOTCONN;
				}
				else {
					errno = EWOULDBLOCK;
				}
				/*FALLTHROUGH*/
			case SSL_ERROR_SYSCALL:
				DEBUG(("R SSL_ERROR_SYSCALL: errno=%d (%s)\n", errno, errstring(errno)));
				if (errno == 0) {
					_s->state = sslstate_finalise;
					return 0;
				}
				return -1;
			default:
			case SSL_ERROR_SSL:
				/* Internal error */
				DEBUG(("R SSL_ERROR_SSL\n"));
				errno = ECONNABORTED;
				return -1;
		}
	}
}



void acornssl_destroy_session(Session *ses)
{
	if (ses->con) {
		if (ses->state > sslstate_connect_in_progress) {
			DEBUG(("Destroying the connected socket (SSL_shutdown)\n"));
			SSL_shutdown(ses->con);
			DEBUG(("Destroying the connected socket (SHUTDOWN)\n"));
			SHUTDOWN(SSL_get_fd(ses->con));
		}
		DEBUG(("Destroying the SSL context (SSL_free)"));
		SSL_free(ses->con);
	}
	DEBUG(("Destroying the extra information associated with the request\n"));
	if (ses->con2 != NULL) SSL_free(ses->con2);
	if (ses->ctx != NULL) SSL_CTX_free(ses->ctx);
	if (ses->s != -1) SHUTDOWN(ses->s);
}

int acornssl_init_session(Session *ses)
{
	ses->verify_depth = 0;
	ses->verify_error = X509_V_OK;
	ses->ctx = SSL_CTX_new(meth);
	if (ses->ctx == NULL) return 0;
	/*SSL_CTX_set_verify(ctx, verify, verify_callback);*/
	#ifdef DOING_CERTS
	if (!set_cert_stuff(ses->ctx, NULL, NULL)) {
		SSL_CTX_free(ses->ctx);
		ses->ctx = NULL;
		return 0;
	}
	#endif

	if (!SSL_CTX_load_verify_locations(ses->ctx, NULL, NULL) ||
			(!SSL_CTX_set_default_verify_paths(ses->ctx))) {
		SSL_CTX_free(ses->ctx);
		ses->ctx = NULL;
		return 0;
	}
	ses->con = (SSL *) SSL_new(ses->ctx);
	if (!ses->con) {
		SSL_CTX_free(ses->ctx);
		ses->ctx = NULL;
		return 0;
	}

	ses->s = socket(AF_INET, SOCK_STREAM, 0);
	if (ses->s < 0) {
		SSL_free(ses->con);
		SSL_CTX_free(ses->ctx);
		return 0;
	}
	else {
		int i = 0;
		(void) setsockopt(ses->s, SOL_SOCKET, SO_KEEPALIVE, &i, sizeof(i));
		DEBUG(("Socket has been created!  Handle is %d\n", ses->s));
	}

	return 1;
}

void acornssl_finalise(void)
{
	if (outputsink) BIO_free(outputsink);
}

_kernel_oserror *acornssl_initialise(void)
{
	SSLeay_add_ssl_algorithms();
	SSL_load_error_strings();
	outputsink = BIO_new(BIO_s_null());
	if (outputsink == NULL) {
		return make_error(HTTPS_ERROR_SSL_NO_INIT, 0);
	}

#if !defined(NO_SSL2) && !defined(NO_SSL3)
	meth = SSLv23_client_method();
#elif !defined(NO_SSL3)
	meth = SSLv3_client_method();
#elif !defined(NO_SSL2)
	meth = SSLv2_client_method();
#endif

	return NULL;
}


static void print_stuff(BIO *bio, SSL *s, int full)
{
	X509 *peer;
	char *p;
	static char *space = "                ";
	static char buf[BUFSIZ];
	STACK *sk;
	SSL_CIPHER *c;
	X509_NAME *xn;
	int j, i;

	if (full) {
		sk = SSL_get_peer_cert_chain(s);
		if (sk != NULL) {
			BIO_printf(bio, "---\nCertficate chain\n");
			for (i = 0; i < sk_num(sk); i++) {
				X509_NAME_oneline(X509_get_subject_name((X509 *)
					     sk_value(sk, i)), buf, BUFSIZ);
				BIO_printf(bio, "%2d s:%s\n", i, buf);
				X509_NAME_oneline(X509_get_issuer_name((X509 *)
					     sk_value(sk, i)), buf, BUFSIZ);
				BIO_printf(bio, "   i:%s\n", buf);
			}
		}

		BIO_printf(bio, "---\n");
		peer = SSL_get_peer_certificate(s);
		if (peer != NULL) {
			BIO_printf(bio, "Server certificate\n");
			/*PEM_write_bio_X509(bio, peer);*/
			X509_NAME_oneline(X509_get_subject_name(peer),
					  buf, BUFSIZ);
			BIO_printf(bio, "subject=%s\n", buf);
			X509_NAME_oneline(X509_get_issuer_name(peer),
					  buf, BUFSIZ);
			BIO_printf(bio, "issuer=%s\n", buf);
			X509_free(peer);
		}
		else
			BIO_printf(bio, "no peer certificate available\n");

		sk = SSL_get_client_CA_list(s);
		if ((sk != NULL) && (sk_num(sk) > 0)) {
			BIO_printf(bio, "---\nAcceptable client certificate CA names\n");
			for (i = 0; i < sk_num(sk); i++) {
				xn = (X509_NAME *) sk_value(sk, i);
				X509_NAME_oneline(xn, buf, sizeof(buf));
				BIO_write(bio, buf, strlen(buf));
				BIO_write(bio, "\n", 1);
			}
		}
		else {
			BIO_printf(bio, "---\nNo client certificate CA names sent\n");
		}
		p = SSL_get_shared_ciphers(s, buf, BUFSIZ);
		if (p != NULL) {
			BIO_printf(bio, "---\nCiphers common between both SSL endpoints:\n");
			j = i = 0;
			while (*p) {
				if (*p == ':') {
					BIO_write(bio, space, 15 - j);
					i++;
					j = 0;
					BIO_write(bio, ((i % 3) ? " " : "\n"), 1);
				}
				else {
					BIO_write(bio, p, 1);
					j++;
				}
				p++;
			}
			BIO_write(bio, "\n", 1);
		}

		BIO_printf(bio, "---\nSSL handshake has read %ld bytes and written %ld bytes\n",
			   BIO_number_read(SSL_get_rbio(s)),
			   BIO_number_written(SSL_get_wbio(s)));
	}
	BIO_printf(bio, ((s->hit) ? "---\nReused, " : "---\nNew, "));
	c = SSL_get_current_cipher(s);
	BIO_printf(bio, "%s, Cipher is %s\n",
		   SSL_CIPHER_get_version(c),
		   SSL_CIPHER_get_name(c));
	SSL_SESSION_print(bio, SSL_get_session(s));
	BIO_printf(bio, "---\n");
}

void acornssl_command_dump(Session *s, int full)
{
	BIO *bio = BIO_new_fp(stdout, BIO_NOCLOSE);
	if (bio) {
		print_stuff(bio, s->con, full);
		BIO_free(bio);
	}
}
