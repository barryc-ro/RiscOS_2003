/*
 * HTTP (c.ses_ctrl)
 *
 * © Acorn Computers Ltd. 1997
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "sys/errno.h"
#include "module.h"
#include "socklib.h"
#include "protocol.h"
#include "acornssl.h"

/*
 * This file contains the routines needed to manipulate sessions
 * within the contect of multiple clients of the module.
 */

static Session *session_list = NULL;

/*************************************************************/
/* Session *find_session(unsigned int id)		     */
/*************************************************************/
/* Given a session ID, return the session control block	     */
/* associated with it.					     */
/*************************************************************/
Session *find_session(unsigned int id)
{
	Session *session;

	for (session = session_list; session; session = session->next) {
		if (session->id == id) return session;
	}

	return NULL;
}

/*************************************************************/
/* Session *new_session(void)				     */
/*************************************************************/
/* Create a new session, taking into account starting the    */
/* sessions list					     */
/*************************************************************/
Session *new_session(void)
{
	Session *ses = calloc(1, sizeof(Session));

	if (ses == NULL) {
		return ses;
	}

	if (!acornssl_init_session(ses)) {
		free(ses);
		return NULL;
	}

	if (session_list == NULL) {
		/* no list so create a new one */
		session_list = ses;
	}
	else {
		/* else find end of list and add an element */
		Session *s;

		for (s=session_list; s->next; s=s->next) ;;
		s->next = ses;
	}

	return ses;
}

static Session *kill_session_data(Session *s)
{
	Session *result = s->next;

	acornssl_destroy_session(s);
	memset(s, '\0', sizeof(*s)); /* Let's be careful */
	free(s);

	return result;
}

/*************************************************************/
/* void kill_session(Session *s)			     */
/*************************************************************/
/* Given the location of the session block, delete the	     */
/* session cleanly, taking into account the session next     */
/* pointers and any memory associated with it		     */
/*************************************************************/
void kill_session(Session *s)
{
	Session *ses = session_list, *prev_ses = NULL;

	for (ses = session_list; ses; prev_ses = ses, ses = ses->next) {
		if (ses == s) {
			Session *const next = kill_session_data(s);
			if (prev_ses == NULL) {
				session_list = next;
			}
			else {
				prev_ses->next = next;
			}
			break;
		}
	}

	#ifdef TRACE
	protocol_debug("\nkill_session %p completed.  Dump of session chain\n", s);
	for (ses=session_list; ses; ses=ses->next) {
		protocol_debug("%p\n", ses);
	}
	protocol_debug("End of session chain\n\n");
	#endif
}

/*************************************************************/
/* void ses_kill_all(void)				     */
/*************************************************************/
/* A small routine to kill off all sessions at module shut-  */
/* down.						     */
/*************************************************************/
void ses_kill_all(void)
{
	while (session_list) {
		kill_session(session_list);
	}
}


/* session_check is called by the callback routine in order to
 * timeout any inactive connections or anything.  Currently, it
 * does nothing, however nothing is lost by having it here, since
 * callbacks are required for the connection pool monitoring
 * anyway.
 */
void session_check(void)
{
	/* Nothing */
}

void session_init(void)
{
        session_list = NULL;
}
