/*
 *
 *  Copyright (c) 1999 by Pace Micro Technologies plc. All Rights Reserved.
 *
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Pace Micro Techonologies
 * plc.
 *
 *
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */

#include "multicaster.h"

static fd_set open_sockets;

bmc_status platform_create_socket(multicast_socket *ms)
{
        *ms = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if (*ms >= 0) {
                int tos = IPTOS_LOWDELAY;
                int one = 1;
                u_char m_ttl = 4;

		fprintf(stderr, "socket() -> %d\n", *ms);

                socketioctl(*ms, FIOSLEEPTW, &one);
                socketioctl(*ms, FIONBIO, &one);

        	setsockopt(*ms, IPPROTO_IP, IP_RECVDSTADDR, &one, sizeof(one));
                setsockopt(*ms, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
                setsockopt(*ms, IPPROTO_IP, IP_MULTICAST_TTL, &m_ttl, sizeof(m_ttl));

                FD_SET(*ms, &open_sockets);
        }
        return *ms < 0 ? bmc_SYSCALL : bmc_OK;
}

bmc_status platform_close_socket(multicast_socket ms)
{
        if (ms != multicaster_INVALID_SOCKET) {
                fprintf(stderr, "Closed socket %d\n", ms);
	        (void) socketclose(ms);
	        FD_CLR(ms, &open_sockets);
        }
        return bmc_OK;
}

bmc_status platform_transmit_to(multicaster_object *mo, struct sockaddr_in *dest)
{
        struct msghdr msg;
	struct iovec iov[MSG_MAXIOVLEN];

	memset(&msg, '\0', sizeof(msg));
	msg.msg_name = (caddr_t) dest;
	msg.msg_namelen = sizeof(*dest);
	msg.msg_iov = iov;
	msg.msg_iovlen = multicaster_set_iovec(mo, iov);
	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

	fprintf(stderr, "[%s] -> %s:%d (socket %d) (vector %p:%d %p:%d (%d))\n",
		i18n_translate_tftp_opcode(iov[0].iov_base[1]),
		inet_ntoa(dest->sin_addr), ntohs(dest->sin_port),
		multicaster_get_socket(mo),
		iov[0].iov_base, iov[0].iov_len,
		iov[1].iov_base, iov[1].iov_len,
		msg.msg_iovlen
		);

	return sendmsg(multicaster_get_socket(mo), &msg, 0) < 0 ? bmc_SYSCALL : bmc_OK;
}

bmc_status platform_transmit(multicaster_object *mo)
{
        return platform_transmit_to(mo, multicaster_get_target(mo));
}

bmc_status platform_bind_socket(multicast_socket ms, u_long interface, short netorderport)
{
        struct sockaddr_in sin;
        memset(&sin, '\0', sizeof(sin));
        sin.sin_family = AF_INET;
        sin.sin_len = sizeof(sin);
        sin.sin_addr.s_addr = interface;
        sin.sin_port = netorderport;
        return bind(ms, (struct sockaddr *)&sin, sizeof(sin)) < 0 ? bmc_SYSCALL : bmc_OK;
}

bmc_status platform_listen(multicast_socket ms, int queue_length)
{
        return listen(ms, queue_length) < 0 ? bmc_SYSCALL : bmc_OK;
}

bmc_status platform_receive_datagram(multicast_socket ms, void *buffer,
	int *length, struct sockaddr_in *sender, struct in_addr *arrival_if)
{
        struct msghdr msg;
        char cmsgbuf[sizeof(struct cmsghdr) + sizeof(struct in_addr)];
        struct iovec data[1];

	msg.msg_name = (caddr_t) sender;
	msg.msg_namelen = sizeof(*sender);
	msg.msg_iov = data;
	data[0].iov_len = *length;
	data[0].iov_base = buffer;
	msg.msg_iovlen = 1;
	msg.msg_control = cmsgbuf;
	msg.msg_controllen = sizeof(cmsgbuf);
	msg.msg_flags = 0;

        *length = recvmsg(ms, &msg, 0);
        if (*length <= 0) {
                return bmc_SYSCALL;
        }

        if (msg.msg_flags & MSG_TRUNC) {
                return bmc_DATAGRAM_TRUNCATED;
        }

	if (arrival_if) {
	        arrival_if->s_addr = INADDR_ANY;
	        while (msg.msg_controllen >= sizeof(struct cmsghdr)) {
		        struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
		        if (cmsg->cmsg_len > msg.msg_controllen) {
		                break;
		        }
	        	if (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_RECVDSTADDR) {
                                memcpy(arrival_if, CMSG_DATA(cmsg), sizeof(*arrival_if));
                                break;
	                }
	                else {
	                        int gap = sizeof(*cmsg) + ((cmsg->cmsg_len + 3) & ~3);
	                        msg.msg_control += gap;
	                        msg.msg_controllen -= gap;
	                }
	        }
	}

	return bmc_OK;
}

bmc_status platform_unicast(multicast_socket ms, struct sockaddr_in *dest,
	void *buffer, int length)
{
        struct msghdr msg;
        struct iovec data[1];

	memset(&msg, '\0', sizeof(msg));
        msg.msg_name = (caddr_t) dest;
        msg.msg_namelen = sizeof(*dest);
        msg.msg_iov = data;
        data[0].iov_len = length;
        data[0].iov_base = buffer;
        msg.msg_iovlen = 1;
	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

        return sendmsg(ms, &msg, 0) < 0 ? bmc_SYSCALL : bmc_OK;
}

const char *platform_translate_errno(void)
{
        return _inet_err();
}

bmc_status platform_report_error(const char *id, bmc_status status)
{
        if (status != bmc_OK) {
                (void) fprintf(stderr, "%s: %s\n", id, i18n_translate_status(status));
                if (status == bmc_SYSCALL) {
                        fprintf(stderr, "%s\n", platform_translate_errno());
                }
        }

        return status;
}

/* This routine must return either bmc_OK or bmc_SYSCALL.
 */
bmc_status platform_select(fd_set *fd, int secs, int *ready)
{
        struct timeval tv;
        int max_sd = FD_SETSIZE;

	/* Find the topmost set bit.  If no bits are set, just implement
	 * a delay loop and say that the select() worked and that there
	 * are no sockets with data pending (because there aren't!)
	 */
        while (--max_sd >= 0) {
                if (FD_ISSET(max_sd, fd)) {
                        break;
                }
        }
        if (max_sd < 0) {
                /* We didn't have a socket - enforce the delay "manually" */
                const clock_t wait_until = clock() + secs * CLOCKS_PER_SEC;
                while (clock() < wait_until) {
                        platform_idle();
                }
                *ready = 0;
                return bmc_OK;
        }
        else {
	        timerclear(&tv);
        	tv.tv_sec = secs;
	        *ready = select(max_sd + 1, fd, NULL, NULL, secs == INT_MAX ? NULL : &tv);
        	if (*ready >= 0) {
                	return bmc_OK;
	        }
        	else {
                	return bmc_SYSCALL;
	        }
        }
}


bmc_status platform_get_local_port(multicast_socket ms, unsigned short *pport)
{
        struct sockaddr_in sin;
        int size = sizeof(sin);

        if (getsockname(ms, (struct sockaddr *) &sin, &size) < 0) {
                return bmc_SYSCALL;
        }
        else {
                *pport = sin.sin_port;
                return bmc_OK;
        }
}

void platform_idle(void)
{
	/* Idle */
	(void) _swix(OS_UpCall, _INR(0,1), 6, 0x3800000);
}

static void platform_exit(void)
{
        int i;

        for (i=0; i<FD_SETSIZE; ++i) {
                if (FD_ISSET(i, &open_sockets)) {
                        fprintf(stderr, "Discarding unclosed socket (%d)\n", i);
                        socketclose(i);
                }
        }
}

void platform_init(void)
{
        atexit(platform_exit);
        FD_ZERO(&open_sockets);
}
