/*
 *
 *  Copyright (c) 1999 by Pace Micro Technologies plc. All Rights Reserved.
 *
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Pace Micro Techonologies
 * plc.
 *
 *
 *		  PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */

#include "multicaster.h"

/* This file manages the configuration of the TFTP server software.  It calls
 * platform_* functions to open and close configuration files.  This may be
 * useful if the platform-specific implementation needs to obtain data from
 * somewhere other than a file, as it can export the data to a file and then
 * return a handle to it to here and then discard the exported data when asked
 * to close the file.  Configuration data is cached in the configuration structure.
 */

/*
 * Parser not yet present.  Most values hard-wired for now.
 */

typedef struct configuration {
        /* The number of "lives" a client gets before being killed off
         * as unreliable by the multicaster_object retry/timeout handlers */
        short		default_lives;
        /* Multicasts are sent to this port number by default */
        u_short		default_port;
        /* Multicasts are sent to this multicast address by default */
        struct in_addr	default_address;
        /* Multicasts are sent with this TTL by default */
        u_char		default_ttl;
	/* Maximum multicasters to transmit the same file on the same
	 * interface with different block sizes (excluding SEGSIZE)
	 */
        int		multicaster_threshold;
        /* Non-zero means that unicast clients are supported.  Zero means
         * that RRQs which do not contain the multicast option are errored. */
        int		support_unicast_clients;
        /* An absolute limit on the MTU of outgoing packets */
        int		mtu_ceiling;
        /* The amount of time (in seconds) after election as a master that
         * the client has to establish data transfer for the purpose of
         * calculating the sustained transfer rate */
        int		rate_grace_period;
        /* Rate in bytes/sec that a master client must sustain in order to
         * avoid being deposed as master.  see also rate_grace_period */
        unsigned long	minimum_master_rate;
        /* The time (in centiseconds) that the client has to response to any
         * packet (excluding retransmissions) before being deemed dead and
         * losing a life. */
        int		total_client_timeout;
        /* The root for all served files.  UNIX implementations will attempt
         * to chroot to this directory.  OSes without this capability should
         * always verify files live under this subtree. */
        const char *	root_directory;
} configuration;

static configuration conf;

static const char *default_root = "/tftpboot";

void configure_establish_defaults(void)
{
	conf.default_address.s_addr = inet_addr("239.192.0.2");
	conf.default_lives = 5;
	conf.default_port = 1758; /* tftp-mcast is the well-known port */
	conf.default_ttl = 5;
	conf.multicaster_threshold = 2;
	conf.support_unicast_clients = 1;
	conf.rate_grace_period = 10;
	conf.mtu_ceiling = 9212;
	conf.minimum_master_rate = 60 * 1024;
	conf.total_client_timeout = 100 * 5;
	conf.root_directory = Strdup(default_root);
}

static void configure_parse(FILE *f)
{
        (void) f;
}

void configure_reread_configuration_file(void)
{
        FILE *f = platform_configuration_open();

        if (f != NULL) {
                configure_parse(f);
                fclose(f);
        }
}

void configure_init(void)
{
        configure_establish_defaults();
        configure_reread_configuration_file();
}

void configure_create_permanent_file_cache(void)
{
	/* At this point, it is safe to call multicast_file_create.  This can be done
	 * to pre-load various objects and ensure that they are never discarded (since
	 * we create them and then forget about them, the reference count will never
	 * decrement to zero
	 */
}


struct in_addr configure_read_target_address(const char *filename, struct in_addr *interface)
{
	(void) filename;
	(void) interface;

	return conf.default_address;
}

struct in_addr configure_read_file_address(multicast_file *mf, struct in_addr *interface)
{
	return configure_read_target_address(multicast_file_get_filename(mf), interface);
}

void configure_set_target_address(const char *filename, const char *ip_string)
{
	/* Store away this configuration information one day */
	(void) filename;
	(void) ip_string;
}

size_t configure_clamp_mtu(size_t suggested, size_t if_support)
{
	/* Remember: Special case: 0 => client didn't sent a blksize option */

	/* Enforce the overall ceiling on packet sizes */
	if (if_support > conf.mtu_ceiling) {
		if_support = conf.mtu_ceiling;
	}

	/* Strategy: limit blksize choice to the interface MTU (minus IP, UDP headers) */
	if (suggested > if_support) {
		suggested = if_support;
	}

	return suggested;
}

short configure_default_lives(void)
{
        return conf.default_lives;
}

u_short configure_read_default_port(void)
{
	return conf.default_port;
}

u_char configure_read_default_ttl(void)
{
        return conf.default_ttl;
}

int configure_read_multiple_multicaster_threshold(void)
{
	return conf.multicaster_threshold;
}

int configure_support_unicast_clients(void)
{
	return conf.support_unicast_clients;
}

int configure_read_rate_grace_period(void)
{
        return conf.rate_grace_period;
}

unsigned long configure_read_minimum_master_rate(void)
{
        return conf.minimum_master_rate;
}

int configure_read_total_client_timeout(void)
{
        return conf.total_client_timeout;
}

const char *configure_read_root_directory(void)
{
	return conf.root_directory ? conf.root_directory : default_root;
}

