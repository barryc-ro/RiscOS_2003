/*
 *
 *  Copyright (c) 1999 by Pace Micro Technologies plc. All Rights Reserved.
 *
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Pace Micro Techonologies
 * plc.
 *
 *
 *		  PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */

#include "multicaster.h"

/* This file will probably end up calling platform_* functions to obtain
 * configuration information from whatever local source is appropriate.
 * ie. NT registry, a UNIX /etc/something.conf file, a RISC OS Choices: file etc.
 *
 * Most values hard-wired for now
 */

static struct in_addr default_address;

void configure_init(void)
{
	default_address.s_addr = inet_addr("239.192.0.2");
}

struct in_addr configure_read_target_address(const char *filename, struct in_addr *interface)
{
	(void) filename;
	(void) interface;

	return default_address;
}

struct in_addr configure_read_file_address(multicast_file *mf, struct in_addr *interface)
{
	return configure_read_target_address(multicast_file_get_filename(mf), interface);
}

void configure_set_target_address(const char *filename, const char *ip_string)
{
	/* Store away this configuration information one day */
	(void) filename;
	(void) ip_string;
}

int configure_read_multiple_multicaster_threshold(void)
{
	/* Allow two multicasters to transmit the same file on the same
	 * interface with different block sizes
	 */
	return 2;
}

const char *configure_read_root_directory(void)
{
	return "/tftpboot";
}

u_short configure_read_default_port(void)
{
	/* Well-known port for tftp-mcast is 1758 */
	return 1758;
}

int configure_support_unicast_clients(void)
{
	return 1;
}

size_t configure_clamp_mtu(size_t suggested, size_t if_support)
{
	/* Remember: Special case: 0 => client didn't sent a blksize option */


	/* Unable to send more than this amount in a packet over loopback it seems */
	if (if_support > 9212) {
		if_support = 9212;
	}

	/* Strategy: limit blksize choice to the interface MTU (minus IP, UDP headers) */
	if (suggested > if_support) {
		suggested = if_support;
	}

	return suggested;
}

void configure_create_permanent_file_cache(void)
{
	/* At this point, it is safe to call multicast_file_create.  This can be done
	 * to pre-load various objects and ensure that they are never discarded (since
	 * we create them and then forget about them, the reference count will never
	 * decrement to zero
	 */
}

int configure_read_total_client_timeout(void)
{
        return 100 * 5;
}

u_char configure_read_default_ttl(void)
{
        return 5;
}
