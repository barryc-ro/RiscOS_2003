/*
 *
 *  Copyright (c) 1999 by Pace Micro Technologies plc. All Rights Reserved.
 *
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Pace Micro Techonologies
 * plc.
 *
 *
 *		  PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>

#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"
#include "arpa/inet.h"
#include "sys/uio.h"

#include "multicaster.h"
#include "tftpserver.h"
#include "platform.h"
#include "mofile.h"

struct multicast_file {
	multicast_file *next;

	/* Usage counter */
        int usage_count;
	/* A file handle for this file */
	FILE *f;

        /* The details of the file */
        char *filename;
        unsigned long total_length;

        /* Buffer which holds the file's contents */
        char *buffer;
        unsigned long bufsize;
};

static multicast_file *mf_list = NULL;

int multicast_file_name_match(multicast_file *mf, const char *filename)
{
	return Strcmp_ci(mf->filename, filename);
}

static multicast_file *multicast_file_search(const char *filename)
{
	multicast_file *mf;

	for (mf = mf_list; mf != NULL; mf = mf->next) {
		if (multicast_file_name_match(mf, filename) == 0) {
			break;
		}
	}

	return mf;
}

static void multicast_file_length(multicast_file *mf)
{
        char tmpbuf[BUFSIZ];
	mf->total_length = 0;

	for (;;) {
		size_t bytes;

		bytes = fread(tmpbuf, 1, sizeof(tmpbuf), mf->f);
		if (bytes == 0) {
			/* No bytes read */
			if (feof(mf->f)) {
				/* Yes, it really was the end of the file */
				break;
			}
			/* It wasn't - oh dear */
			mf->total_length = 0;
			break;
		}
		mf->total_length += bytes;
		if (bytes < sizeof(tmpbuf)) {
			break;
		}
	}

	rewind(mf->f);
}

multicast_file *multicast_file_create(const char *filename)
{
	multicast_file *mf;

	mf = multicast_file_search(filename);
	if (mf != NULL) {
	        fprintf(stderr, "Incrementing usage count for file %s to %d\n",
		        filename, mf->usage_count);
		++mf->usage_count;
		return mf;
	}

	fprintf(stderr, "New file `%s'\n", filename);

	mf = malloc(sizeof(*mf));

	if (mf != NULL) {
		mf->f = NULL;
		mf->buffer = NULL;
		mf->usage_count = 1;
		mf->filename = Strdup(filename);
		if (mf->filename != NULL) {
			mf->f = fopen(filename, "rb");
			if (mf->f != NULL) {
				multicast_file_length(mf);
				mf->bufsize = mf->total_length;
				mf->buffer = malloc(mf->bufsize);
				if (mf->buffer != NULL) {
					size_t bytes;
					bytes = fread(mf->buffer, 1, mf->bufsize, mf->f);
					if (bytes != mf->bufsize) {
						free(mf->buffer);
						mf->buffer = NULL;
					}
					else {
						fclose(mf->f);
						mf->f = NULL;
					}
				}
			        mf->next = mf_list;
				mf_list = mf;
				return mf;
			}
			free(mf->filename);
		}
		free(mf);
	}

	return NULL;
}

void multicast_file_destroy(multicast_file *mf)
{
	if (--mf->usage_count <= 0) {
		multicast_file **ptr = &mf_list;
		for (; *ptr != NULL; ptr = &((*ptr)->next)) {
			if (*ptr == mf) {
				*ptr = mf->next;
				break;
			}
		}
		if (mf->filename != NULL) {
			free(mf->filename);
		}
		if (mf->buffer != NULL) {
			free(mf->buffer);
		}
		if (mf->f != NULL) {
			fclose(mf->f);
		}
	}
}

size_t multicast_file_get_size(multicast_file *mf)
{
        return mf->total_length;
}

const char *multicast_file_get_filename(multicast_file *mf)
{
        return mf->filename;
}

/* Strategy independent method of sending a file */
size_t multicast_file_read(void *buffer, size_t from, size_t n, multicast_file *mf)
{
	if (n == 0 || from >= mf->total_length) {
		return 0;
	}
	else if (mf->f != NULL) {
		/* XXX: Seek on binary files is undefined strictly speaking */
		fseek(mf->f, (long) from, SEEK_SET);
		return fread(buffer, 1, n, mf->f);
	}
	else {
		size_t to_copy = n;
		if (from + n > mf->total_length) {
			to_copy = mf->total_length - from;
		}
		if (to_copy > 0) {
			(void) memcpy(buffer, mf->buffer + from, to_copy);
		}
		return to_copy;
	}
}

static void multicast_file_atexit(void)
{
        while (mf_list) {
                multicast_file_destroy(mf_list);
        }
}

void multicast_file_initialise(void)
{
	mf_list = NULL;
	atexit(multicast_file_atexit);
}
