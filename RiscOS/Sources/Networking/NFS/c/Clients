/*
        RISC OS NFS CLIENT routines. Get/Release clients and turn errors from RPCs into
        RISC OS error structures.
*/
/* Modification history
   05/05/95, RWB - commented out extern int errno
   04-Mar-97 jmf - add comments on usage of rpcnfs_to_riscos_err (was used incorrectly)
   29-Apr-97 jmf - fix bug of *NFS:timeout not taking effect for pre-alloctaed clients
 */
#ifndef __NFS_H
#include "NFS.h"
#endif

#include "TimeOut.h"
#include "rquota.h"

_kernel_oserror *errno_to_riscos_err
(
        void
)
{
        return &_inet_error;
}

typedef int errmap( _kernel_oserror **err, int errno );

static _kernel_oserror *general_rpcthingy_to_riscos_err
(
        int *res,
        CLIENT *client,
        char *fillin_name,
        _kernel_oserror *ukerr,
        errmap errors
)
{
        _kernel_oserror *err;

        if ( res )
        {
                if ( !errors( &err, *res ) )
                {
                        err = (_kernel_oserror *)return_buffer;
                        err->errnum = ukerr->errnum;
                        sprintf( err->errmess, "%s (number %d)", ukerr->errmess, *res );
                }

                return err;
        }
        else if ( errno == EINTR )
        {
              	return mb_escape;
        }
        else
        {
                _kernel_oserror *err = (_kernel_oserror *)return_buffer;

                err->errnum = mb_rpc_failed->errnum;
                sprintf( err->errmess, mb_rpc_failed->errmess, clnt_sperror( client, fillin_name ));

                return err;
        }
}

static int nfs_errmap(
        _kernel_oserror **err,
        int errno
)
{
        switch( errno )
        {
        case NFS_OK:
                *err = NULL;
                return Yes;
        case NFSERR_PERM:
                *err = mb_nfserr_perm;
                return Yes;
        case NFSERR_NOENT:
                *err = mb_nfserr_noent;
                return Yes;
        case NFSERR_IO:
                *err = mb_nfserr_io;
                return Yes;
        case NFSERR_NXIO:
                *err = mb_nfserr_nxio;
                return Yes;
        case NFSERR_ACCES:
                *err = mb_nfserr_acces;
                return Yes;
        case NFSERR_EXIST:
                *err = mb_nfserr_exist;
                return Yes;
        case NFSERR_NODEV:
                *err = mb_nfserr_nodev;
                return Yes;
        case NFSERR_NOTDIR:
                *err = mb_nfserr_noent; /* Must be noent for IFSs to work */
                return Yes;
        case NFSERR_ISDIR:
                *err = mb_nfserr_noent; /* Must be noent for IFSs to work */
                return Yes;
        case NFSERR_FBIG:
                *err = mb_nfserr_fbig;
                return Yes;
        case NFSERR_NOSPC:
                *err = mb_nfserr_nospc;
                return Yes;
        case NFSERR_ROFS:
                *err = mb_nfserr_rofs;
                return Yes;
        case NFSERR_NAMETOOLONG:
                *err = mb_nfserr_nametoolong;
                return Yes;
        case NFSERR_NOTEMPTY:
                *err = mb_nfserr_notempty;
                return Yes;
        case NFSERR_DQUOT:
                *err = mb_nfserr_dquot;
                return Yes;
        case NFSERR_REMOTE:
                *err = mb_nfserr_remote;
                return Yes;
        case NFSERR_STALE:
                *err = mb_nfserr_stale;
                return Yes;
        case NFSERR_WFLUSH:
                *err = mb_nfserr_wflush;
                return Yes;
        case NFSERR_INVAL:
                *err = mb_nfserr_BadParameters;
                return Yes;
        default:
                return No;
        }
}

/*
        Generate appropriate error blocks for failed rpc nfs calls

	'res' points to the return value of the NFS procedure, or NULL if the RPC failed.

	'mount_point' is the NFS mount on which the operation was being attempted.  This is
	used to obtain the name of the mount for inclusion in the error message for some cases.

	'nfs_client' is a pointer to the RPC client handle on which the error occurred.  
	This is used to obtain the RPC error status that was stored by the RPC library. 


	NOTE: There are two cases in which this routine is used:
	
	a) The remote NFS procedure returned an NFS error.  The error is pointed to by
	   'res', and 'nfs_client' is not used.

	b) The RPC itself failed (status != RPC_SUCCESS) and so the NFS result is
	   not set.  In this case, 'res' MUST be passed as NULL, and 'nfs_client'
	   is then used to obtain the RPC error information.

*/
_kernel_oserror *rpcnfs_to_riscos_err
(
        void *res,
        MountPoint *mount_point,
        CLIENT *nfs_client
)
{
        return general_rpcthingy_to_riscos_err( res, nfs_client, mount_point->mount_point_name, mb_nfserr_unknown, nfs_errmap );
}

/*
        Generate appropriate error blocks for failed rpc nfs calls
*/
_kernel_oserror *rpcmount_to_riscos_err
(
        void *res,
        MountPoint *mount_point,
        CLIENT *mount_client
)
{
        return general_rpcthingy_to_riscos_err( res, mount_client, mount_point->mount_point_name, mb_mounterr_unknown, nfs_errmap );
}

static _kernel_oserror *clntcreate_to_riscos_err( void )
{
        _kernel_oserror *err;
        
        switch ( rpc_createerr.cf_stat )
        {
        case RPC_SYSTEMERROR:
                errno = rpc_createerr.cf_error.re_errno;
                err = errno_to_riscos_err();
                break;

        default:
                err = (_kernel_oserror *)return_buffer;
                err->errnum = mb_rpc_failed->errnum;
                sprintf( err->errmess, mb_rpc_failed->errmess, clnt_sperrno( rpc_createerr.cf_stat ));
                break;
        }

        return err;
}

static int pcnfsd_pi_errmap
(
        _kernel_oserror **err,
        int errno
)
{
        switch( errno )
        {
        case PI_RES_OK:
                *err = NULL;
                return Yes;
        case PI_RES_NO_SUCH_PRINTER:
                *err = mb_no_such_printer;
                return Yes;
        case PI_RES_FAIL:
                *err = mb_print_init_failed;
                return Yes;
        default:
                return No;
        }
}

_kernel_oserror *rpcpcnfsd_pi_to_riscos_err
(
        void *res,
        CLIENT *client,
        char *mountname
)
{
        return general_rpcthingy_to_riscos_err( res, client, mountname, mb_pcnfsd_pi_err_unknown, pcnfsd_pi_errmap );
}

static int pcnfsd_ps_errmap( _kernel_oserror **err, int errno )
{
        switch( errno )
        {
        case PS_RES_OK:
        case PS_RES_NULL:
                *err = NULL;
                return Yes;
        case PS_RES_ALREADY:
                *err = mb_file_printing_already;
                return Yes;
        case PS_RES_NO_FILE:
                *err = mb_spool_file_disappeared;
                return Yes;
        case PS_RES_FAIL:
                *err = mb_spooling_failed;
                return Yes;
        default:
                return No;
        }
}

_kernel_oserror *rpcpcnfsd_ps_to_riscos_err
(
        void *res,
        CLIENT *client,
        char *mountname
)
{
        return general_rpcthingy_to_riscos_err( res, client, mountname, mb_pcnfsd_ps_err_unknown, pcnfsd_ps_errmap );
}

/*
        Release a client back to whatever pool it lies in
*/
void release_client
(
        unused_client *client
)
{
        client->in_use = No;
}

static _kernel_oserror *allocate_client
(
        unused_client   **clientp,
        Chain_Header    *clients,
        char            *host_name,
        u_long          program,
        u_long          version,
        char            *protocol,
        AUTH            *auth
)
{
        Chain_Link *link;
        unused_client *try_client;


        /*
                Enumerate NFS clients, trying to find one which is available for use
        */
        for ( link = clients->forwards;
                link->forwards;
                link = link->forwards )
        {
                try_client = Link_Wrapper( link );

                if ( !try_client->in_use )
                {
                        /*
                                Found one, use it
                        */
                        try_client->in_use = Yes;

                        if ( auth )
                                try_client->client->cl_auth = auth;

			clnt_control(try_client->client, CLSET_TIMEOUT, &TIMEOUT);
        		clnt_control(try_client->client, CLSET_RETRY_TIMEOUT, &TIMERETRY);

                        *clientp = try_client;

                        return NULL;
                }
        }

        /*
                None available, create a new one
        */
        try_client = (unused_client *)malloc( sizeof( *try_client ));

        if ( try_client == NULL )
        {
                return mb_malloc_failed;
        }

        try_client->in_use = Yes;

        pmap_set_tot_timeout( TIMEOUT );


        try_client->client = clnt_create( host_name, program, version, protocol );


        if ( try_client->client == NULL )
        {
                free( try_client );

                return clntcreate_to_riscos_err();
        }

        clnt_control(try_client->client, CLSET_TIMEOUT, &TIMEOUT);
        clnt_control(try_client->client, CLSET_RETRY_TIMEOUT, &TIMERETRY);

        /*
                Attach it to NFS client pool for this host
        */
        insert_before_header( &try_client->link, try_client, clients );

        /*
                Set its auth for this transaction
        */
        if ( auth )
                try_client->client->cl_auth = auth;

        *clientp = try_client;


        return NULL;
}

/*
        Construct an unused nfs client for a mount point
*/
_kernel_oserror *get_nfs_client_for_mp
(
        unused_client **nfs_clientp,
        MountPoint *mount_point
)
{
        return allocate_client
        (
                nfs_clientp,
                &mount_point->host->nfs_clients,
                mount_point->host->host_name,
                NFS_PROGRAM,
                NFS_VERSION,
                NFS_PROTOCOL,
                mount_point->user->authorisation
        );
}

/*
        Construct an unused mount client for a mount point
*/
_kernel_oserror *get_mount_client_for_mp
(
        unused_client **mount_clientp,
        MountPoint *mount_point
)
{
        return allocate_client
        (
                mount_clientp,
                &mount_point->host->mount_clients,
                mount_point->host->host_name,
                MOUNTPROG,
                MOUNTVERS,
                MOUNTPROTO,
                mount_point->user->authorisation
        );
}

/*
        Construct an unused pcnfsd client for a host
*/
_kernel_oserror *get_pcnfsd_client_for_host
(
        unused_client **pcnfsd_clientp,
        Host *host
)
{
        return allocate_client
        (
                pcnfsd_clientp,
                &host->pcnfsd_clients,
                host->host_name,
                PCNFSDPROG,
                PCNFSDVERS,
                PCNFSDPROTO,
                NULL
        );
}

/*
        Get a client for a quota rpc
*/
_kernel_oserror *get_quota_client
(
        unused_client **quota_clientp,
        MountPoint *mount_point
)
{
        return allocate_client
        (
                quota_clientp,
                &mount_point->host->quota_clients,
                mount_point->host->host_name,
                RQUOTAPROG,
                RQUOTAVERS,
                "udp",
                mount_point->user->authorisation
        );
}
