/*	COMMANDS

Purpose : Command processors for RISC OS NFS

History :
Date	Who    Comments
-----------------------------------------------------------------------------

10/02/95  CP   Added code to print out network accesses
23/02/95  KSR  Added nfs_boot() function
19/02/96  DNW  Added Timeout and CacheSize stuff
20/02/96  KJB  Removed TimeOffset command
19/10/96  AJS  Added udp retry-time option to *timeout
***************************************************************************/

#ifndef __NFSNFS_H
#include "NFS.h"
#endif

#include "TimeOut.h"
#include "callbacks.h"

#ifdef NETACCESSCOUNT
extern unsigned int NetAccessCountG;
#endif

#ifdef PACKETSIZE_COMMAND
int NFS_MAXDATA = 8192;
#endif

/*
        Select NFS for a *NFS command
*/
_kernel_oserror *command_nfs
(
        char *arg_string,
        int argc
)
{
        arg_string = arg_string;
        argc = argc;

        return _swix(OS_FSControl, _INR(0,1), FSControl_SelectFilingSystem,
                                              NFSFilingSystemName );
}

/*
        Encrypt a string for name checking
*/
static char *encryptstring
(
        char *string
)
{
        char *result = malloc( strlen( string ) + 1 );
        int i;

        if ( result )
        {
                for ( i = 0;
                        string[ i ];
                        i++ )
                {
                        result[ i ] = string[ i ] ^ 0x5b;
                }
                result[ i ] = '\0';
        }

        return result;
}

/*
        Switch to given user with password
*/
_kernel_oserror *process_nfsname
(
        char *username,
        char *password
)
{
        AUTH *authorisation;
        _kernel_oserror *err;
        v2_auth_args aargs;
        v2_auth_results *ares;
        unused_client *pcnfsd_client;
        char machname[MAX_MACHINE_NAME + 1];
        int len;
        u_long version;
        int gids[NGRPS];
        gid_t *gp;

        /*
                Is the user nobody?
        */
        if ( caseless_strcmp( username, User_Nobody ) == 0 )
        {
                err = new_user(
                        &current_user,
                        User_Nobody,
                        NULL,
                        UNIX_MagicNumber_UID_Nobody,
                        UNIX_MagicNumber_GID_Nobody,
                        authunix_create_default(),
                        0,
                        NULL,
                        -1);
                return err;
        }

        /*
                The user isn't nobody, so we jolly well aught to have a host
        */
        if ( current_nameing_host == NULL )
        {
                return mb_no_nameing_host;
        }

        /*
                No password, so assume empty string
        */
        if ( password == NULL )
        {
                password = "";
        }

        version = current_nameing_host->pcnfs_version;

        err = get_pcnfsd_client_for_host( &pcnfsd_client, current_nameing_host, version );
        if ( err )
                return err;

        gethostname(machname, MAX_MACHINE_NAME);
        machname[MAX_MACHINE_NAME] = 0;

        aargs.system = machname;
        aargs.id = encryptstring( username );
        aargs.pw = encryptstring( password );
        aargs.cm = "";

        if ( version == PCNFSDVERS)
        {
                static v2_auth_results ar2;
                auth_args a;
                auth_results *ar;
                a.id = aargs.id;
                a.pw = aargs.pw;
                ar = pcnfsd_auth_1( &a, pcnfsd_client->client );
                if (ar == NULL)
                {
                        ares = NULL;
                }
                else {
                        ares = &ar2;
                        ar2.stat = ar->stat;
                        ar2.uid = ar->uid;
                        ar2.gid = ar->gid;
                        ar2.gids.gids_len = 0;
                        ar2.def_umask = -1;
                }
        }
        else
        {
                ares = pcnfsd2_auth_2( &aargs, pcnfsd_client->client );
        }

        free( aargs.id );
        free( aargs.pw );

        if ( ares )
        {
                release_client( pcnfsd_client );

                if (ares->def_umask == 0) ares->def_umask = -1;

                switch( ares->stat )
                {
                case AUTH_RES_OK:
                        /* do nothing */
                        break;

                case AUTH_RES_FAKE:
                        return mb_authorisation_failed;
                        break;
                default:
                case AUTH_RES_FAIL:
                        return mb_authorisation_failed;
                        break;
                }
        }
        else
        {
                _kernel_oserror *err = (_kernel_oserror *)return_buffer;

                err->errnum = 0;
                strcpy( err->errmess, clnt_sperror( pcnfsd_client->client, "Authorising" ));

                release_client( pcnfsd_client );

                return err;
        }

        if (version == PCNFSDVERS || ares->gids.gids_len == 0)
        {
                len = getgroups( NGRPS, gids );
                gp = (gid_t *) gids;
        }
        else
        {
                len = ares->gids.gids_len;
                gp = (gid_t *) ares->gids.gids_val;
        }

        authorisation = authunix_create( machname, ares->uid, ares->gid, len, gp );

        err = new_user( &current_user, username, current_nameing_host, (int)ares->uid, (int)ares->gid, authorisation,
                len, (gid3 *) gp, ares->def_umask);

        if ( err )
                return err;

        memset( current_user->gnames, 0, sizeof current_user->gnames );

        if (version == PCNFSDV2)
        {
                /* PCNFS version 2 - attempt to find the group names; ignore errors */
                v2_mapid_results *res;
                mapreq_res gids;
                v2_mapid_args args;
                static mapreq_arg_item items[NGRPS+1];
                int i;

                if ( get_pcnfsd_client_for_host( &pcnfsd_client, current_nameing_host, version ) )
                        return NULL;

                args.cm = "";
                args.req_list = items;
                /* The irregular loop termination condition is because we are looking up the
                 * primary GID as well as the supplementary GIDs
                 */
                for (i = 0; i <= NGRPS; ++i) {
                        if (i <= len)
                        {
                                items[i].mapreq_next = items + i + 1;
                                items[i].req = MAP_REQ_GID;
                                items[i].name = "";
                                if ( i == 0 )
                                        items[i].id = (int) ares->gid;
                                else
                                        items[i].id = (int) gp[i - 1];
                        }
                        else
                        {
                                items[i-1].mapreq_next = NULL;
                        }
                }

                res = pcnfsd2_mapid_2( &args, pcnfsd_client->client );

                release_client( pcnfsd_client );

                if ( res ==  NULL)
                        return NULL;

                for (i = 0, gids = res->res_list; gids != NULL && i <= NGRPS; ++i)
                {
                        if ( gids->stat == MAP_RES_OK )
                        {
                                strncpy( current_user->gnames[i].name, gids->name, sizeof current_user->gnames[i].name );
                                if ( i == 0 )
                                {
                                        dprintf(("", "Primary GID %d -> %s\n", ares->gid, gids->name));
                                }
                                else
                                {
                                        dprintf(("", "Supplementary GID %ld -> %s\n", gp[i-1], gids->name));
                                }

                        }

                        gids = gids->mapreq_next;
                }

                xdr_free( xdr_v2_mapid_results, res );
        }

        return NULL;
}

/*
        Process *NFS:Logon command
*/
_kernel_oserror *command_nfsname
(
        char *arg_string,
        int argc
)
{
        int *readargs_buffer;
        _kernel_oserror *err;
        char *hostname;
        char *username;
        char *password;

        if ( argc == 0 )
        {
                /*
                        *Logon
                          Display the current NFSName.
                */
                if ( current_user == NULL )
                {
                        return mb_no_user;
                }
                else
                {
                        err = lightweight_printf( "The current user is %0s\n", current_user->name );

                        if ( !err )
                        {
                                if ( current_nameing_host )
                                {
                                        err = lightweight_printf( "The current name server is %0s\n", current_nameing_host->host_name );
                                }
                                else
                                {
                                        err = lightweight_printf( "There is no current name server\n" );
                                }
                        }

                        return err;
                }
        }
        else
        {
                /*
                        *Logon [-Host <hostname>] [<username> [<password>]]
                          Set the current user
                */

                readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

                if ( readargs_buffer == NULL )
                        return mb_malloc_failed;

                err = _swix(OS_ReadArgs, _INR(0,3), "host=h/k/g,username/g,password/g",
                                                    arg_string, readargs_buffer,
                                                    ReadArgsBufferLen);

                if ( err )
                {
                        free( readargs_buffer );
                        return err;
                }

                hostname = username = password = NULL;

                err = readargs_getstring( &hostname, readargs_buffer, 0 );
                if ( !err )
                        err = readargs_getstring( &username, readargs_buffer, 1 );
                if ( !err )
                        err = readargs_getstring( &password, readargs_buffer, 2 );
                free( readargs_buffer );

                if ( !err )
                        err = new_host( &current_nameing_host, hostname );

                free( hostname );

                if ( err )
                {
                        if ( password )
                                free( password );
                        if ( username )
                                free( username );

                        return err;
                }

                /*
                        Are we specifying the user in this call?
                */
                if ( username == NULL )
                {
                        free( password );

                        return NULL;
                }

                /*
                        If user is not nobody and no password given then ask for one
                */
                if ( caseless_strcmp( username, User_Nobody ) != 0 &&
                     password == NULL &&
                     current_nameing_host != NULL )
                {
                        err = lightweight_printf( "Enter your password : " );
                        if ( !err )
                                err = askfor_password( &password );

                        if ( err )
                        {
                                free( username );
                                return err;
                        }
                }

                err = process_nfsname( username, password );

                free( username );
                free( password );

                return err;
        }
}

static _kernel_oserror *list_mountpoints_for_host
(
        char *hostname
)
{
        Chain_Link *link;
        char *last_hostname;
        MountPoint *mount_point;
        _kernel_oserror *err;

        /*
                Set link to point to the first element in the relevant list
                of mount points.
        */
        if ( hostname == NULL )
        {
                link = mount_point_list.forwards;
        }
        else
        {
                /*
                        Find the host with the given name
                */
                for ( link = host_list.forwards;
                      link->forwards != NULL &&
                          strcmp( ((Host *)Link_Wrapper( link ))->host_name, hostname ) != 0;
                      link = link->forwards )
                {
                        /* do nothing */
                }

                /*
                        Start along the list of mount points
                */
                if ( link->forwards != NULL )
                {
                        link = ((Host *)Link_Wrapper( link ))->mount_points.forwards;
                }
        }

        /*
                print column titles
        */
        err = lightweight_printf( Format_MountPoint_List, "Mount Name", "User", "Mount Path" );

        /*
                This is used to find out when the host changes and to print
                a line giving the new host
        */
        last_hostname = NULL;

        for ( ;
              !err &&
                  link->forwards;
              link = link->forwards )
        {
                mount_point = Link_Wrapper( link );

                /*
                        Check for the host changing. Note, a direct pointer to
                        the string comparison is appropriate here.
                */
                if ( mount_point->host->host_name != last_hostname )
                {
                        last_hostname = mount_point->host->host_name;
                        err = lightweight_printf( "Host: %0s\n", last_hostname );
                }

                if ( !err )
                        err = lightweight_printf( Format_MountPoint_List,
                                mount_point->mount_point_name,
                                mount_point->user->name,
                                mount_point->mount_path );
        }

        return err;
}

_kernel_oserror *nfs_mount_internal( char *mountname, char *mountpath, Host *host, UserSpecification *user)
{
        _kernel_oserror *err;
        MountPoint *new_mount_point;
        Chain_Link *link;
        union {
                void *res;
	        mountres3 *res3;
        	fhstatus *res1;
        } res;
        unused_client *mount_client;
        xdrproc_t freeproc;



        /*
                Find the mount point ge this in the list of all mount points.
        */
        for ( link = mount_point_list.forwards;
              link->forwards != NULL &&
                caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) < 0;
              link = link->forwards )
        {
                /* do nothing */
        }


        /*
                If eq return an error
        */
        if ( link->forwards != NULL &&
               caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) == 0 )
                return mb_duplicate_mount_point;

        new_mount_point = (MountPoint *)malloc( sizeof( MountPoint ));

        if ( new_mount_point == NULL )
                return mb_malloc_failed;

        new_mount_point->mount_point_name = malloc( strlen( mountname ) + 1 );

        if ( new_mount_point->mount_point_name == NULL )
        {
                free( new_mount_point );
                return mb_malloc_failed;
        }

        strcpy( new_mount_point->mount_point_name, mountname );

        new_mount_point->mount_path = malloc( strlen( mountpath ) + 1 );

        if ( new_mount_point->mount_path == NULL )
        {
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                return mb_malloc_failed;
        }

        strcpy( new_mount_point->mount_path, mountpath );

        new_mount_point->host = host;
        new_mount_point->user = user;
        new_mount_point->being_dismounted = No;


        err = get_mount_client_for_mp( &mount_client, new_mount_point );

        if ( err )
        {
                free( new_mount_point->mount_path );
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                return err;
        }

	if (mount_client->version == MOUNTVERS3) {
	        res.res3 = mountproc_mnt_3( &new_mount_point->mount_path, mount_client->client );
	        freeproc = xdr_mountres3;
	}
	else {
	        res.res1 = mountproc_mnt_1( &new_mount_point->mount_path, mount_client->client );
	        freeproc = xdr_fhstatus;
	}


        err = rpcmount_to_riscos_err( res.res, new_mount_point, mount_client->client );


        release_client( mount_client );

        if ( err )
        {
                free( new_mount_point->mount_path );
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                if (res.res) xdr_free(freeproc, res.res);

                return err;
        }

	if ( freeproc == xdr_mountres3 ) {
	        /* mount_client is "gone" */
	        fh3cpy_from_xdr(&new_mount_point->fhandle, (nfs_fh3 *)&res.res3->mountres3_u.mountinfo.fhandle);
	}
	else {
	        static nfs_fh3 fh3;
	        fh3cpy_from_fhandle(&fh3, (nfs_fh *) &res.res1->fhstatus_u.fhs_fhandle);
		fh3cpy_from_xdr(&new_mount_point->fhandle, &fh3);
	}
	xdr_free(freeproc, res.res);


        host->usage_count++;
        user->usage_count++;


        initialise_header( &new_mount_point->open_files );


        insert_before_link( &new_mount_point->all_mount_points_link, new_mount_point, link );

        /*
                Find the mount point ge this in the list of mount points
                on this host.
        */
        for ( link = current_mounting_host->mount_points.forwards;
              link->forwards != NULL &&
                caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) <= 0;
              link = link->forwards )
        {
                /* do nothing */
        }


        insert_before_link( &new_mount_point->mount_points_per_host_link, new_mount_point, link );

        /*
                Create two clients ready for use to allow CLI *copy to work
                Re-use mount_client variable here to save a variable.
        */
        if (!get_nfs_client_for_mp( &mount_client, new_mount_point ))
        {
                unused_client *client;
                if (!get_nfs_client_for_mp( &client, new_mount_point ))
                {
                        release_client( client );
                }
                release_client( mount_client );
        }

        /*
                Tell the world about the new mount
        */

        return _swix(OS_ServiceCall, _IN(1), Service_NFS);
}

/*
        All the parameters should be verified by here
*/
_kernel_oserror *nfs_mount( char *hostname, char *mountname, char *mountpath)
{
        _kernel_oserror *err;
        char *dirpath;



        /*
                Process the hostname into the current mounting host
        */
        err = new_host( &current_mounting_host, hostname );


        if ( !err &&
                current_mounting_host == NULL )
                err = mb_no_mounting_host;

        if ( err )
                return err;

        if ( current_user == NULL )
                return mb_no_user;

        /*
                Only mount if a mountpath is given, otherwise
                drop through to the directory setting bit.
        */
        if ( mountpath )
        {
                err = nfs_mount_internal( mountname, mountpath, current_mounting_host, current_user );
                if ( err )
                {
                        return err;
                }
        }

        if ( !find_mount( mountname ))
                return mb_no_mount_point_found;

        /*
                Set directories to the mount.
                Don't winge if one of these fails.
        */

        dirpath = malloc( strlen( mountname ) + sizeof ":.$" );
        if (dirpath)
        {
            sprintf( dirpath, ":%s.$", mountname );

            /* Set CSD */
            _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, dirpath, 0, NFSFilingSystemName, 0);
            /* Leave PSD alone */

            /* Unset URD - will default to "$" */
            _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, 0, 2, NFSFilingSystemName, 0);
            /* Unset Library - will default to "$.Library" */
            _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, 0, 3, NFSFilingSystemName, 0);

            free(dirpath);
        }

        return NULL;
}

_kernel_oserror *command_nfsmount( char *arg_string, int argc)
{
        int *readargs_buffer;
        char *hostname;
        char *mountname;
        char *mountpath;
        _kernel_oserror *err;

        argc = argc;

        readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

        if ( readargs_buffer == NULL )
                return mb_malloc_failed;

        err = _swix(OS_ReadArgs, _INR(0,3), "host=h/k/g,mountname/g,mountpath/g",
                                            arg_string, readargs_buffer,
                                            ReadArgsBufferLen);

        if ( err )
        {
                free( readargs_buffer );
                return err;
        }

        hostname = mountname = mountpath = NULL;

        err = readargs_getstring( &hostname, readargs_buffer, 0 );
        if ( !err )
                err = readargs_getstring( &mountname, readargs_buffer, 1 );
        if ( !err )
                err = readargs_getstring( &mountpath, readargs_buffer, 2 );
        free( readargs_buffer );

        if ( mountname == NULL &&
             mountpath != NULL )
        {
                err = mb_path_no_mount;
        }
        else if ( mountname == NULL &&
                  mountpath == NULL )
        {
                err = list_mountpoints_for_host( hostname );
        }
        else
        {
                if ( strchr( mountname, ' ' ) != NULL || strchr( mountname, ':' ) != NULL )
                        err = mb_no_spaces_in_mount_name;

                if ( !err )
                        err = nfs_mount( hostname, mountname, mountpath );
        }

        free( hostname );
        free( mountname );
        free( mountpath );

        return err;

}

/*
        Call FileSwitch to close the given file
*/
static _kernel_oserror *nfs_forceclose
(
        OpenFile *file
)
{
    int success;

    success=_kernel_osfind(0, (char *) file->fileswitch_handle);

    return success == _kernel_ERROR ? _kernel_last_oserror() : NULL;
}

/*
 * Check to see if one of NFS's special directories is on a given mount.
 * If it is, then unset it. The possible directory values are
 *    0 - @, 1 - \, 2 - &, 3 - %
 */
static void void_directory_if_on_mount(const char *mount, int directory)
{
    char *buffer, *p;
    int size;
    _kernel_oserror *e;

    e=_swix(OS_FSControl, _INR(0,3)|_IN(5)|_OUT(5), 54, 0, directory, NFSFilingSystemName, 0, &size);

    if (e || size==0)
    	return;

    buffer=(char *)malloc(-size);
    if (buffer==NULL)
    	return;

    /* Read the canonical path name of the given directory, eg
               ":Home.$.Library"
     */
    e=_swix(OS_FSControl, _INR(0,3)|_IN(5), 54, buffer, directory, NFSFilingSystemName, -size);

    if (e)
    {
        free(buffer);
    	return;
    }

    /* Find the . after the mount name */
    p=strchr(buffer, '.');

    if (!p)
    {
        free(buffer);
    	return;
    }

    *p='\0';

    /* Compare the mount name with our argument - if it matches then unset
       that directory.
     */
    if (caseless_strcmp(mount, buffer+1) == 0)
        _swix(OS_FSControl, _INR(0,3)|_IN(6), 53, 0, directory, NFSFilingSystemName, 0);

    free(buffer);
}

/*
        Close all files on the given mount and remove it from the mount
        chain.
*/
_kernel_oserror *nfs_dismount
(
        MountPoint *mount
)
{
        _kernel_oserror *err = NULL;
        _kernel_oserror *error_to_return = NULL;
        OpenFile *lastfile;
        FSEntry_Close_Parameter closeparm;
        unused_client *mount_client;
        void *(*umnt_fn)(dirpath *, CLIENT *);
        char *DiscName;

        /*
                If dismount called as a result of a dismount, do nothing
                at this level and let the top level dismount handle it.
                This occurs if a dismount of a spool mount is done - the
                top level dismount closes all files, thus causing the spool
                mount to be dismounted.
        */
        if ( mount->being_dismounted == Yes )
                return NULL;
        mount->being_dismounted = Yes;

        /*
                If FileSwitch failed to cause this file to close, then
                call FSEntry_Close ourselves. These parameters are set
                to 0 to indicate no change.

                THIS SHOULD ONLY BE NEEDED IN DIRE EMERGENCIES.
        */
        closeparm.info.load_exec.load_address = 0;
        closeparm.info.load_exec.execute_address = 0;

        while ( mount->open_files.forwards->forwards )
        {
                /*
                        Hold lastfile just in case FileSwitch botches is
                */
                lastfile = Link_Wrapper( mount->open_files.forwards );

                err = nfs_forceclose( lastfile );

                /*
                        Check that FileSwitch got it right
                */
                if ( lastfile == Link_Wrapper( mount->open_files.forwards ) )
                {
                        /*
                                FileSwitch botched it, so do it ourselves.
                                Errors at this stage are ignored.
                        */
                        closeparm.handle = (int)lastfile;
                        fsentry_close( &closeparm );
                }

                /*
                        Only return the first error
                */
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        /*
                Void all the directories:
                @, \, & and %
                Void the current mount point (used for nfs:$.)
        */
        void_directory_if_on_mount(mount->mount_point_name, 0);
        void_directory_if_on_mount(mount->mount_point_name, 1);
        void_directory_if_on_mount(mount->mount_point_name, 2);
        void_directory_if_on_mount(mount->mount_point_name, 3);


        err = get_mount_client_for_mp( &mount_client, mount );
        if ( err && !error_to_return )
                error_to_return = err;

	umnt_fn = mount_client->version == MOUNTVERS3 ? mountproc_umnt_3 : mountproc_umnt_1;

        err = rpcmount_to_riscos_err( umnt_fn ( &mount->mount_path, mount_client->client ), mount, mount_client->client );
        release_client( mount_client );

        if ( err && !error_to_return )
                error_to_return = err;

        cancel_all_caches_by_mount_point( mount );

        /* Make a note of the disc name for issuing the service call later */
        DiscName=(char *)malloc(strlen(mount->mount_point_name)+
                                sizeof (NFSFilingSystemName "::")+1);
        if (DiscName)
            sprintf(DiscName, NFSFilingSystemName "::%s", mount->mount_point_name);

        free( mount->mount_point_name );
        free( mount->mount_path );
        remove_link( &mount->all_mount_points_link );
        remove_link( &mount->mount_points_per_host_link );

        err = release_host( mount->host );
        if ( err && !error_to_return )
                error_to_return = err;

        err = release_user( mount->user );
        if ( err && !error_to_return )
                error_to_return = err;

        free( mount );

        /*
                Tell everybody about the dismount
        */
        err = _swix(OS_ServiceCall, _IN(1), Service_NFS);
        if ( err && !error_to_return )
                error_to_return = err;

        if (DiscName)
        {
            err = _swix(OS_ServiceCall, _INR(1,2), Service_DiscDismounted, DiscName);
            if ( err && !error_to_return )
                error_to_return = err;
            free(DiscName);
        }

        return error_to_return;
}

_kernel_oserror *nfs_dismount_host
(
        Host *host
)
{
        _kernel_oserror *err;
        _kernel_oserror *error_to_return = NULL;

        while( host->mount_points.forwards->forwards )
        {
                err = nfs_dismount( Link_Wrapper( host->mount_points.forwards ));
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        return error_to_return;
}

_kernel_oserror *nfs_dismount_all
(
        void
)
{
        _kernel_oserror *err;
        _kernel_oserror *error_to_return = NULL;

        while( mount_point_list.forwards->forwards )
        {
                err = nfs_dismount( Link_Wrapper( mount_point_list.forwards ));
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        return error_to_return;
}

_kernel_oserror *command_nfsdismount
(
        char *arg_string,
        int argc
)
{
        int *readargs_buffer;
        _kernel_oserror *err;
        YesNoAnswer is_host;
        char *objname;
        Chain_Link *link;
        MountPoint *mp;

        argc = argc;

        readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

        if ( readargs_buffer == NULL )
                return mb_malloc_failed;

        err = _swix(OS_ReadArgs, _INR(0,3), "host=/s,/g", arg_string,
                                            readargs_buffer, ReadArgsBufferLen );

        if ( err )
        {
                free( readargs_buffer );
                return err;
        }

        objname = NULL;

        is_host = readargs_buffer[0] != 0;

        err = readargs_getstring( &objname, readargs_buffer, 1 );

        free( readargs_buffer );

        if ( !err )
        {
                if ( is_host )
                {
                        for ( link = host_list.forwards;
                                link->forwards != NULL &&
                                        strcmp( ((Host *)Link_Wrapper( link ))->host_name, objname ) != 0;
                                link = link->forwards )
                        {
                                /* do nothing */
                        }

                        if ( link->forwards )
                        {
                                err = nfs_dismount_host( Link_Wrapper( link ));
                        }
                        else
                        {
                                err = mb_no_host_found;
                        }
                }
                else if ( objname )
                {
                        /*
                                Not a host, so must be a mount point
                        */

                        mp = find_mount( objname );

                        if ( mp )
                        {
                                err = nfs_dismount( mp );
                        }
                        else
                        {
                                err = mb_no_mount_point_found;
                        }
                }
                else
                {
                        /*
                                Nothing specified, dismount the whole lot
                        */

                        err = nfs_dismount_all();
                }
        } /* endif readargs etc worked */

        if ( objname )
                free( objname );

        return err;
}

_kernel_oserror *command_nfsinfo
(
        char *arg_string,
        int argc
)
{
        Chain_Link *link;
        Host *host;
        UserSpecification *user;
        _kernel_oserror *err = NULL;

        arg_string = arg_string;
        argc = argc;

        err = lightweight_printf( "Host list:\n" );
        for ( link = host_list.forwards;
                !err && link->forwards != NULL;
                link = link->forwards )
        {
                host = Link_Wrapper( link );
                err = lightweight_printf( "name=<%0s>, usage = %1d, NFS version = %2d\n", host->host_name, host->usage_count, host->nfs_version );
        }

        if ( !err )
                err = lightweight_printf( "\nCache hits %0d; Cache misses %1d\n", cache_hits, cache_misses);

        if ( !err && cache_hits+cache_misses > 0)
        {
            /* Do this fixed point, for simplicity */
            int percent;

            percent=(cache_hits*1000)/(cache_hits+cache_misses);
            err = lightweight_printf("Cache hit rate %0d.%1d%%\n", percent / 10, percent % 10);
        }

#ifdef NETACCESSCOUNT
        if ( !err )
                err = lightweight_printf( "\nTotal network accesses %0d\n", NetAccessCountG);

#endif

        if ( !err )
                err = lightweight_printf( "\nUser list:\n" );
        for ( link = user_list.forwards;
                !err && link->forwards != NULL;
                link = link->forwards )
        {
                user = Link_Wrapper( link );
                err = lightweight_printf( "name=<%0s>, uid=<%1d>, group=<%5s>, gid=<%2d>, default umask=<%4o> usage = %3d\n",
                        user->name, user->uid, user->gid, user->usage_count, user->umask & 0777, user->gnames[0].name );
                if (!err && user->len > 0)
                {
                        int i;
                        lightweight_printf("  groups:");
                        for (i = 0; i < user->len; ++i)
                        {
                                if (i)
                                        lightweight_printf( "," );

                                if (user->gnames[i+1].name[0])
                                {
                                        lightweight_printf( " %1s <%0d>", user->gids[i], user->gnames[i+1].name );
                                }
                                else
                                {
                                        lightweight_printf( " <%0d>", user->gids[i] );
                                }
                        }
                        lightweight_printf("\n");
                }
        }

        return err;
}

static _kernel_oserror *pr_justified
(
        char *string,
        int width
)
{
        _kernel_oserror *err = NULL;
        int slen = strlen( string );

        while ( !err && slen < width )
        {
                err = lightweight_printf( " " );
                slen++;
        }

        if ( !err )
                lightweight_printf( "%0s", string );

        return err;
}

static _kernel_oserror *convertswi(int swinum, long num, char *buffer, int len)
{
        return _swix(swinum, _INR(0,2), num, buffer, len);
}


#define ConvBufSize 20

static _kernel_oserror *prtime(long time)
{
        _kernel_oserror *err;
        int i;
        char buf[ConvBufSize];
        static struct {
                int c_secs;             /* conversion units in secs */
                char * c_str;           /* unit string */
        } cunits [] = {
                {60*60*24*28, "months"},
                {60*60*24*7, "weeks"},
                {60*60*24, "days"},
                {60*60, "hours"},
                {60, "mins"},
                {1, "secs"}
        };

        if (time <= 0) {
                return lightweight_printf("EXPIRED\n");
        }
        for (i = 0; i < sizeof(cunits)/sizeof(cunits[0]); i++) {
                if (time >= cunits[i].c_secs)
                        break;
        }
        err = convertswi( OS_ConvertSpacedInteger4, time/cunits[i].c_secs, buf, sizeof( buf ));
        if (!err)
                err = lightweight_printf(buf);
        if (!err)
                err = lightweight_printf(" %0s", cunits[i].c_str);
        return err;
}

#define kb(b) ((b)/1024)

static _kernel_oserror *warn( utils_spacestr *space, char *mount_name )
{
        _kernel_oserror *err;
        utils_quotastr *squota = &space->sp.quota.space,
                       *fquota = &space->sp.quota.files;
        if (squota->hlim &&
             squota->usage >= squota->hlim)
        {
                err = lightweight_printf(
"Block limit reached on %0s\n",
                      mount_name );
                if (err) return err;
        }
        else if (squota->slim &&
             squota->usage >= squota->slim)
        {
                err = lightweight_printf(
"Over disk quota on %0s, remove %1dK",
                      mount_name,
                      kb(squota->usage - squota->slim + 1 ) );
                if (err) return err;
                if (squota->timeleft > 0)
                {
                        err = lightweight_printf(" within ");
                        if (err) return err;
                        err = prtime(squota->timeleft);
                        if (err) return err;
                }
                err = lightweight_printf("\n");
                if (err) return err;
        }

        if (fquota->hlim &&
            fquota->usage >= fquota->hlim)
        {
                err = lightweight_printf(
"File count limit reached on %0s\n",
                      mount_name );
                if (err) return err;
        }
        else if (fquota->slim &&
            fquota->usage >= fquota->slim)
        {
                err = lightweight_printf(
"Over file quota on %0s, remove %1d file%2s",
                       mount_name,
                       fquota->usage - fquota->slim + 1,
                       ((fquota->usage - fquota->slim + 1) > 1 ? "s" : "" ) );
                if (err) return err;
                if (fquota->timeleft > 0)
                {
                        err = lightweight_printf(" within ");
                        if (err) return err;
                        err = prtime(fquota->timeleft);
                        if (err) return err;
                }
                err = lightweight_printf("\n");
                if (err) return err;
        }
        return NULL;
}


_kernel_oserror *command_free
(
        char *arg_string,
        int argc
)
{
        _kernel_oserror *err;
        utils_spacestr space;
        char user_free_buf[ConvBufSize];
        char usage_buf[ConvBufSize];
        char quota_buf[ConvBufSize];
        char limit_buf[ConvBufSize];
        char *buffer=NULL;
        utils_quotastr *squota = &space.sp.quota.space,   /* space quota struct */
                       *fquota = &space.sp.quota.files;   /* files quota struct */
        int maxwid = 0;

        if ( argc == 0 )
        {
            int bufsize;
            char *pc, *pd;

            /* Need to get CSD off FileSwitch */

            _swix(OS_FSControl, _INR(0,3)|_IN(5)|_OUT(5),
                                54, NULL, 0, NFSFilingSystemName, 0, &bufsize);

            if ( bufsize == 0 )
                return mb_no_current_mount_point;

            buffer=(char *)malloc(-bufsize);
            _swix(OS_FSControl, _INR(0,3)|_IN(5),
                                54, buffer, 0, NFSFilingSystemName, -bufsize);

            pc=strchr(buffer, ':');
            pd=strchr(pc, '.');
            if (pc==NULL || pd==NULL)
            {
                free(buffer);
                return mb_no_current_mount_point;
            }
            *pd='\0';
            arg_string = pc+1;
        }
        else
        {
                space_reduce( arg_string );
        }

        err = utils_getfsspace( &space, arg_string );

        if (space.active_quota)
        {
                u_long free = (squota->slim > squota->usage) ? squota->slim - squota->usage : 0;
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (free), user_free_buf, sizeof( user_free_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->usage), usage_buf, sizeof( usage_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->slim), quota_buf, sizeof( quota_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, (squota->hlim), limit_buf, sizeof( limit_buf ));
                strcat(user_free_buf, "K");
                strcat(usage_buf, "K");
                strcat(quota_buf, "K");
                strcat(limit_buf, "K");
        }
        else
        {
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.bfree, user_free_buf, sizeof( user_free_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.bavail, quota_buf, sizeof( quota_buf ));
                usage_buf[0] = '\0';
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.blocks, limit_buf, sizeof( limit_buf ));
                strcat(user_free_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
                strcat(quota_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
                strcat(limit_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
        }

        if ( !err )
        {
                if ( strlen( user_free_buf ) > maxwid )
                        maxwid = strlen( user_free_buf );
                if ( strlen( usage_buf ) > maxwid )
                        maxwid = strlen( usage_buf );
                if ( strlen( quota_buf ) > maxwid )
                        maxwid = strlen( quota_buf );
                if ( strlen( limit_buf ) > maxwid )
                        maxwid = strlen( limit_buf );
        }
        if ( space.active_quota )
        {
                if ( !err )
                        err = lightweight_printf( "Bytes free   " );
                if ( !err )
                        err = pr_justified( user_free_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes used   " );
                if ( !err )
                        err = pr_justified( usage_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes quota  " );
                if ( !err )
                        err = pr_justified( quota_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes limit  " );
                if ( !err )
                        err = pr_justified( limit_buf, maxwid );
        }
        else  /* no quota; print out statfs info */
        {
                if ( !err )
                        err = lightweight_printf( "No quota on %0s\n", arg_string);
                if ( !err )
                        err = lightweight_printf( "Space on filing system:\nFree      " );
                if ( !err )
                        err = pr_justified( user_free_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nAvailable " );
                if ( !err )
                        err = pr_justified( quota_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nSize      " );
                if ( !err )
                        err = pr_justified( limit_buf, maxwid );
        }

        if ( !err )
                err = lightweight_printf( "\n" );

        if ( !err && space.active_quota
           && ( ( (squota->slim > 0) && (squota->usage > squota->slim) )
             || ( (fquota->slim > 0) && (fquota->usage > fquota->slim) ) ) )
        {
                err = warn( &space, arg_string );
        }

        free(buffer);

        return err;
}

_kernel_oserror *command_cachetime( char *arg_string, int argc)
{
        if (argc == 0)
            printf("The current cache expiry time is %d.%02d seconds.\n", out_of_date_time / 100, out_of_date_time % 100);
        else
            out_of_date_time = atoi(arg_string);

        return NULL;
}


static char *Commands_set_varname(char varbuf[20], int count)
{
        (void) strcpy(varbuf, "Inet$BootServer");
        if (count > 1) {
                sprintf(strchr(varbuf, '\0'), "%d", count);
        }
        return varbuf;
}

_kernel_oserror *nfs_boot(void)
{
        int first, nsecs, flags;
        int lasttime, curtime, elapsedtime, firsttime;
        char server_adr[32], mount_path[64], bootserver_varname[20];
        _kernel_oserror *err, *mnterr;
        int server_count, looped;
        unsigned int badservers = (-1U) & ~1; /* When this gets to zero, all servers have returned hard errors */

        err = _kernel_getenv(Commands_set_varname(bootserver_varname, 0), server_adr, sizeof server_adr);
        if ( err )
            return ( err );

        err = _kernel_getenv("Inet$MountPath", mount_path, sizeof mount_path);
        if (err || mount_path[0]=='\0')
            strcpy(mount_path, "/nfsboot");

#ifdef SILENTBOOT
#else
        lightweight_printf("Trying to mount %0s on server %1s\n", mount_path, server_adr);
#endif
        first = 1;
        nsecs = 0;
        looped = 0;
        server_count = 1;
        lasttime = time(0);
        firsttime = lasttime + 30;
        do
        {
                _swix(OS_ReadEscapeState, _OUT(_FLAGS), &flags);
                if (flags & _C)
                {
                    _kernel_osbyte(OSByte_CancelEscape, 0, 0);
                    return mb_escape;
                }
                mnterr = err = nfs_mount( server_adr, "NFSBoot", mount_path );
                if (!err)
                       break;
                usermode_donothing();
                curtime = time(0);
                elapsedtime = curtime - lasttime;
                if (err == mb_nfserr_noent || err == mb_nfserr_acces)
                       badservers &= ~(1<<server_count);
                else if (elapsedtime < 5)
                       continue;
                nsecs += elapsedtime;
                ++server_count;
                err = _kernel_getenv(Commands_set_varname(bootserver_varname, server_count), server_adr, sizeof server_adr);
                if ( err ) {
                        badservers &= ((1<<server_count)-1);
                        server_count = 1;
                        err = _kernel_getenv(Commands_set_varname(bootserver_varname, server_count), server_adr, sizeof server_adr);
                        if ( err )
                                return ( err );
                }
                if (first && server_count == 1)
                {
#ifdef SILENTBOOT
#else
                        lightweight_printf("Waiting for response from a boot server\n");
#endif
                        first = 0;
                }
                else if (first)
                {
#ifdef SILENTBOOT
#else
                        lightweight_printf("Trying to mount %0s on server %1s\n", mount_path, server_adr);
#endif
                }
                else
                {
#ifdef SILENTBOOT
#else
                        lightweight_printf("Elapsed time: %0d seconds\r", nsecs);
#endif
                }
                lasttime = time(0);
        } while ((time(0) < firsttime) && badservers != 0);

        if ( mnterr )
                return ( mnterr );

        /* Set current directory */
        err=_swix(OS_FSControl, _INR(0,1), 0, NFSFilingSystemName "::NFSBoot.$");

        if (!err)
        {
            int success=_kernel_oscli("/" NFSFilingSystemName "::NFSBoot.$.!NFSBoot");
            if (success == _kernel_ERROR)
                err=_kernel_last_oserror();
        }

        return err;
}


_kernel_oserror *command_timeout( char *arg_string, int argc)
{
int now;

	if ( argc == 0) /* no params ...  */
		{
		lightweight_printf("The current timeout is %0d seconds.\n", TIMEOUT.tv_sec);
		lightweight_printf("The current retry time is %0d seconds.\n", TIMERETRY.tv_sec);
		}
	else if (argc == 1) /* timeout value only */
		{
	        now = atoi( arg_string );
	        TIMEOUT.tv_sec = now;
		}
	else { /* timeout and retry values */
	        now = atoi( arg_string );
	        TIMEOUT.tv_sec = now;
	        while(*arg_string != 0x20) {
	          if(*arg_string < 0x20) return NULL;
	          arg_string++;
	        }
	        now = atoi( arg_string );
	        TIMERETRY.tv_sec = now;
	}
        return NULL;
}


_kernel_oserror *command_cachesize( char *arg_string, int argc)
{
    int size;

    if (argc == 1) /* want to set size  */
    {
	size = atoi(arg_string);
	if (size == 0)
	    return mb_nfs_cache_size_zero;
	else
	    set_cache_size (size);
    }
    else	/* ie want to know size  */
    {
        lightweight_printf("The current cache size is %0d entries.\n", get_cache_size());
    }

    return (NULL);
}


#ifdef PACKETSIZE_COMMAND

_kernel_oserror *command_packetsize( char *arg_string, int argc )
{
	int size;

	if (argc == 1) /* want to set size */
	{
		size = atoi(arg_string);
		if ((size < 1) || (size > 8))
			return mb_nfserr_BadParameters;
		else
			NFS_MAXDATA = size * 1024;
	}
	else /* want to know size */
	{
		lightweight_printf("The current NFS packet size is %0d bytes.\n", NFS_MAXDATA);
	}

	return (NULL);
}

#endif
