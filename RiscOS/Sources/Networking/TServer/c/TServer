/*****************************************************************************
* $Id$
* $Name$
*
* Author(s):  Daniel R Ellis
* Project(s): IA Next Generation (A148)
*
* ----------------------------------------------------------------------------
* Copyright [2000] Pace Micro Technology PLC.  All rights reserved.
*
* The copyright in this material is owned by Pace Micro Technology PLC
* ("Pace").  This material is regarded as a highly confidential trade secret
* of Pace.  It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Pace.
*
* ----------------------------------------------------------------------------
* Purpose: This program provides a simple telnet server running under RISC OS
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/

/*****************************************************************************
* Include header files
*****************************************************************************/

#include "TServer.h"
#include "modhead.h"

#include <stdio.h>
#include <stdlib.h>
#include "sys/types.h"
#include "sys/socket.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netinet/in.h"
#include "netdb.h"
#include "unixlib.h"
#include "socklib.h"
#include "arpa/telnet.h"

#include "swis.h"
#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "wimp.h"
#include "wimplib.h"

#include "DebugLib/DebugLib.h"

/*****************************************************************************
* MACROS
*****************************************************************************/

#define NOTUSED(A) ((A)=(A))
#define RECVBUFSIZE 240


/*****************************************************************************
* New enumerated types
*****************************************************************************/

/* states for receive character state machine */
#define    TS_DATA        0    /* base state */
#define    TS_IAC         1    /* look for double IAC's */
#define    TS_CR          2    /* CR-LF ->'s CR */
#define    TS_SB          3    /* throw away begin's... */
#define    TS_SE          4    /* ...end's (suboption negotiation) */
#define    TS_WILL        5    /* will option negotiation */
#define    TS_WONT        6    /* wont " */
#define    TS_DO          7    /* do " */
#define    TS_DONT        8    /* dont " */


/*****************************************************************************
* File scope Global variables
*****************************************************************************/

static int sock = -1, msgsock = -1;
static int task_id = 0;
static int child = 0;
static int pollword = 0;
static int i = 1;

/* need this to find out if we are the CAO */
extern void __module_header (void);

/* turn off stack limit checking for the SVC part of the code */
#pragma -s1


/*****************************************************************************
* FunctionName
*  module_init
*
* Description of the function
*  perform any activities necessary for the module to function correctly
*
* Assumptions
*  Sets up debug lib.
*
* Inputs
*  char* cmd_tail:  the string following the command starting the module
*  int podule_base: the address of the base of the podule areas
*  void* pw:        the private word for this module
*
* Outputs
*  none
*
* Returns
*  _kernel_oserror*: any error produced trying to initialise
*****************************************************************************/

_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw)
{
    _kernel_oserror* e = 0;
    struct sockaddr_in server;
    NOTUSED(cmd_tail);
    NOTUSED(podule_base);

    /* set up debugging */
    debug_initialise (Module_Title, "", "");
    debug_set_device(FILE_OUTPUT);
    debug_set_unbuffered_files (TRUE);

    dprintf (("Module", "Starting Module\n"));

    /* create socket */
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) return &_inet_error;

    /* make the socket generate events */
    if (socketioctl(sock, FIOASYNC, &i) < 0) e = &_inet_error;

    /* mark the socket as non-blocking */
    if (!e && socketioctl(sock, FIONBIO, &i) < 0) e = &_inet_error;

    /* resuse the address so that if we start again we don't fail */
    if (!e && setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i))
        e = &_inet_error;

    /* name socket using wildcards */
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(23);
    if (!e && bind(sock, (struct sockaddr*) &server, sizeof server))
        e = &_inet_error;

    /* start accepting connections */
    if (!e && listen (sock, 5)) e = &_inet_error;

    /* claim the internet event */
    if (!e) _swix (OS_Claim, _INR(0, 2), EventV, internetv_entry, pw);
    if (!e) _kernel_osbyte (Event_Enable, Event_Internet, 0);

    /* if there was an error, close the socket */
    if (e) socketclose (sock);

    return e;
}


/*****************************************************************************
* FunctionName
*  module_final
*
* Description of the function
*  do any tidying up necessary to leave the system intact
*
* Assumptions
*  Kills any outstanding wimptasks and closes sockets.
*
* Inputs
*  int fatal:  1 if fatal, 0 if just a tidy
*  int podule: the instantiation number of the module being killed
*  void* pw:   the private word
*
* Outputs
*  none
*
* Returns
*  _kernel_oserror*:  any error produced during finalisation
*****************************************************************************/

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
    NOTUSED(fatal);
    NOTUSED(podule);

    /* if we have a child, kill it now */
    if (child) {
        WimpPollBlock b;
        b.user_message.hdr.size = sizeof b.user_message.hdr;
        b.user_message.hdr.action_code = Wimp_MQuit;
        wimp_send_message (Wimp_EUserMessage, &b, child, 0, 0);
    }

    /* if we started as a wimp task, stop ourselves */
    if (task_id) {
        wimp_close_down (task_id);
        task_id = 0;
    }

    /* disable and deregister for the internet event */
    _kernel_osbyte (Event_Disable, Event_Internet, 0);
    _swix (OS_Release, _INR(0, 2), EventV, internetv_entry, pw);

    /* close our sockets if they're not already closed */
    if (sock != -1) socketclose (sock);
    if (msgsock != -1) socketclose (msgsock);

    return 0;
}

/*****************************************************************************
* FunctionName
*  eventv
*
* Description of the function
*  handles internet events
*
* Assumptions
*  We assume that we never get data for both sockets within a wimp poll, as
*  thee pollword would only reflect the last connection attempt made.
*
* Inputs
*  _kernel_swi_regs* r: the state of the registers when the call was made
*  void* pw:            the private word for this module
*
* Outputs
*  _kernel_swi_regs* r: the state of the registers to return
*
* Returns
*  0 to claim, 1 to pass on.
*****************************************************************************/

int internetv(_kernel_swi_regs *r, void *pw)
{
    NOTUSED(pw);

    if (r->r[1] != 1 || (r->r[2] != sock && r->r[2] != msgsock)) return 1;

    /* set the pollword to our socket if it's for us. */
    pollword = r->r[2];
    return 1;
}


/*****************************************************************************
* FunctionName
*  module_services
*
* Description of the function
*  handle service calls for the module
*
* Assumptions
*  if r->r[0] = 0 then the call was claimed, otherwise passed on.
*
* Inputs
*  int service_number:  the number of the service call
*  _kernel_swi_regs* r: the state of the registers when the call was made
*  void* pw:            the private word for this module
*
* Outputs
*  _kernel_swi_regs* r: the state of the registers to return
*
* Returns
*  void
*****************************************************************************/

void module_services(int service_number, _kernel_swi_regs *r, void *pw)
{
    NOTUSED(pw);

    switch (service_number) {

    /* if it's our CAO, claim the service call to leave our memory */
    case Service_Memory:
        if (r->r[2] == (int) __module_header) r->r[1] = 0;
        break;

    /* if we haven't started yet then return the star command to start us and
    claim the service */
    case Service_StartWimp:
        if (task_id == 0) {
            task_id = -1;
            r->r[0] = (int) "Desktop_TServer";
            r->r[1] = 0;
        }
        break;

    /* if the wimp starts without issuing our start command clear the -1
    condition */
    case Service_StartedWimp:
        if (task_id == -1) task_id = 0;
        break;

    /* upon reset, zero task_id so that we can get started again */
    case Service_Reset:
        task_id = 0;
        break;

    default:
        break;
    }
}

/*****************************************************************************
* FunctionName
*  module_services
*
* Description of the function
*  handle service calls for the module
*
* Assumptions
*  if r->r[0] = 0 then the call was claimed, otherwise passed on.
*
* Inputs
*  int service_number:  the number of the service call
*  _kernel_swi_regs* r: the state of the registers when the call was made
*  void* pw:            the private word for this module
*
* Outputs
*  _kernel_swi_regs* r: the state of the registers to return
*
* Returns
*  void
*****************************************************************************/

_kernel_oserror *commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
    switch (cmd_no) {

    case CMD_Desktop_TServer:
        /* Don't start the task if it's already started */
        if (task_id == -1 || task_id == 0) {
            wimp_slot_size (TServer_SlotSize, -1, 0, 0, 0);
            _swix (OS_Module, _INR(0, 2), Module_Enter, Module_Title, 0);
        }
        break;
    }

    return 0;
}

/* Turn stack limit checking back on again */
#pragma -s0

/*****************************************************************************
* FunctionName
*  recv_char
*
* Description of the function
*  state machine for receiving characters
*
* Assumptions
*
* Inputs
*  char c, the character to be processed
*
* Outputs
*
* Returns
*  character to output, or -1 if character has been eaten
*****************************************************************************/

static int recv_char (char c) {

    /* start in DATA state */
    static int state = TS_DATA;
    dprintf (("", "State is %d\n", state));
    switch (state) {

    case TS_CR:
        state = TS_DATA;
        /* Strip off \n or \0 after a \r */
        if ((c == 0) || (c == '\n')) {
            break;
        }
        /* FALL THROUGH */

    case TS_DATA:
        if (c == IAC) {
            state = TS_IAC;
            break;
        }
        /*
         * We now map \r\n ==> \r for pragmatic reasons.
         * Many client implementations send \r\n when
         * the user hits the CarriageReturn key.
         *
         * We USED to map \r\n ==> \n, since \r\n says
         * that we want to be in column 1 of the next
         * printable line, and \n is the standard
         * unix way of saying that (\r is only good
         * if CRMOD is set, which it normally is).
         */
        if (c == '\r')
            state = TS_CR;
        return c;
        break;

    case TS_IAC:
gotiac:
        switch (c) {

        /*
         * Send the process on the pty side an
         * interrupt.  Do this with a NULL or
         * interrupt char; depending on the tty mode.
         */
        case IP:
            return -1;

        case BREAK:
            return -1;

        /*
         * Are You There?
         */
        case AYT:
            socketwrite(msgsock, "\r\n[Yes]\r\n", 9);
            return -1;

        /*
         * Abort Output
         */
        case AO:
            return -1;

        /*
         * Erase Character and
         * Erase Line
         */
        case EC:
        case EL:
            return -1;

        /*
         * Check for urgent data...
         */
        case DM:
            return -1;

        /*
         * Begin option subnegotiation...
         */
        case SB:
            state = TS_SB;
                return -1;

        case WILL:
            state = TS_WILL;
                return -1;

        case WONT:
            state = TS_WONT;
                return -1;

        case DO:
            state = TS_DO;
                return -1;

        case DONT:
            state = TS_DONT;
                return -1;
        case EOR:
            return -1;

        /*
         * Handle RFC 10xx Telnet linemode option additions
         * to command stream (EOF, SUSP, ABORT).
         */
        case xEOF:
            return -1;

        case SUSP:
            return -1;

        case ABORT:
            return -1;

        case IAC:
            return c;
            return -1;
        }
        state = TS_DATA;
        break;

    case TS_SB:
        if (c == IAC) {
            state = TS_SE;
        } else {
//            SB_ACCUM(c);
        }
        break;

    case TS_SE:
        if (c != SE) {
            if (c != IAC) {
                state = TS_IAC;
                goto gotiac;
            }
//            SB_ACCUM(c);
            state = TS_SB;
        } else {
            state = TS_DATA;
        }
        break;

    case TS_WILL:
        state = TS_DATA;
            break;

    case TS_WONT:
        state = TS_DATA;
            break;

    case TS_DO:
        state = TS_DATA;
            break;

    case TS_DONT:
        state = TS_DATA;
            break;

    default:
        printf("telnetd: panic state=%d\n", state);
        exit(1);
    }
    return -1;
}


/*****************************************************************************
* FunctionName
*  pollword_nonzero
*
* Description of the function
*  handle pollword going nonzero i.e. internet event
*
* Assumptions
*  We can only handle the last internet event that occurred since the last
*  wimp poll.
*
* Inputs
*  WimpPollBlock* block: the wimp poll block.
*
* Outputs
*
* Returns
*****************************************************************************/

static void pollword_nonzero (WimpPollBlock* block)
{
    int rval = 0;
    int temp = pollword;

    /* zero the pollword as soon as possible */
    pollword = 0;

    /* If we receive a message on our listening socket: */
    if (temp == sock) {

        char buf[256];

        /* If we've already got a connection, kill it, and start a new one */
        if (child != 0) {
            socketclose (msgsock);
            block->user_message.hdr.size = sizeof block->user_message.hdr;
            block->user_message.hdr.action_code = TaskWindow_Morite;
            wimp_send_message (Wimp_EUserMessage, block, child, 0, 0);
        }

        /* accept the connection */
        if ((msgsock = accept (sock, 0, 0)) == 0) return;

        /* enable internet events on the socket */
        if (socketioctl(msgsock, FIOASYNC, &i) < 0) return;

        /* mark it non-blocking */
        if (socketioctl(msgsock, FIONBIO, &i) < 0) return;

        /* tell the telnet terminal that we echo characters */
        socketwrite(msgsock, "\xff\xfb\1", 3);

        /* start the taskwindow */
        sprintf (buf, "TaskWindow -name TServerTW -ctrl -txt 1 -task %d", task_id);
        wimp_start_task (buf, 0);

    /* If we receive a message on our comms socket: */
    } else if (temp == msgsock) {
        static char recvbuf[RECVBUFSIZE];

        /* Read the data */
        rval = socketread(msgsock, recvbuf, RECVBUFSIZE);

        /* if rval == 0 then the client has ended the connection */
        if (rval == 0) {
            block->user_message.hdr.size = sizeof block->user_message.hdr;
            block->user_message.hdr.action_code = TaskWindow_Morite;
            wimp_send_message (Wimp_EUserMessage, block, child, 0, 0);

        /* if rval is positive, it's the number of characters received */
        } else if (rval > 0) {
            int i;

            /* we're going to write data directly into the message block */
            char* iptr = block->user_message.data.bytes + 4;

            /* loop through the recieved data passing the characters through
            the state machine */
            for (i = 0; i < rval; ++i) {
                int c = recv_char (recvbuf[i]);
                dprintf (("", "%d\n", recvbuf[i]));
                if (c != -1) *iptr++ = c;
            }

            /* set up the wimp message and send it */
            block->user_message.hdr.action_code = TaskWindow_Input;
            block->user_message.hdr.size = 256;
            block->user_message.data.words[0] = iptr -
                block->user_message.data.bytes - 4;
            wimp_send_message (Wimp_EUserMessage, block, child, 0, 0);
        }
    }
}


/*****************************************************************************
* FunctionName
*  taskwindow_output
*
* Description of the function
*  Handle output from the taskwindow (back to the client)
*
* Assumptions
*
* Inputs
*  WimpPollBlock* block: the wimp poll block.
*
* Outputs
*
* Returns
*****************************************************************************/

static void taskwindow_output (WimpPollBlock* block)
{
    /* Don't do anything if we don't have a message socket */
    if (msgsock != -1) {
        int i, j;
        char* ptr = block->user_message.data.bytes + 4;
        int size = block->user_message.data.words[0];
        for (i = 0; i < size; ++i) {

            /* count up to the first control character */
            for (j = i; j < size; ++j) {
                dprintf(("", "TW:%d\n", ptr[j]));
                switch (ptr[j]) {
                case 10:
                case 13:
                    continue;
                case 127:
                    break;
                default:
                    if (ptr[j] >= 127) {

                        /* zero out these characters as they can cause
                        strange effects in the client */
                        ptr[j] = 0;
                        continue;
                    }
                    if (ptr[j] >=32) continue;
                }
                break;
            }

            /* if we've got anywhere, send out the characters */
            if (j > i) socketwrite(msgsock, ptr + i, j - i);

            /* if we hit a control character, send an escape
               sequence (and bump j) */
            if (j < size && (ptr[j] < 32 || ptr[j] == 127))
                switch (ptr[j]) {
                    case 127:
                        dprintf(("","erase\n"));
                        socketwrite(msgsock, "\x08 \x08", 3);
                        break;
                }

            /* bring i up to date */
            i = j;
        }
    }
}


/*****************************************************************************
* FunctionName
*  main
*
* Description of the function
*  The main entry point for the wimp part of the module
*
* Assumptions
*
* Inputs
*  int argc: ignored
*  char* argv[]: ignored
*
* Outputs
*
* Returns
*  program exit status
*****************************************************************************/

int main (int argc, char* argv[]) {
    WimpPollBlock block;
    int event_code;
    int messages[3] = {TaskWindow_Output, TaskWindow_Ego, 0};
    NOTUSED(argc);
    NOTUSED(argv);

    /* don't attempt to start the task again */
    if (task_id != -1) return 0;

    wimp_initialise (310, "TServer", messages, 0, &task_id);

    for (;;) {
        wimp_poll (
            Wimp_Poll_NullMask | Wimp_Poll_PollWord,
            &block,
            &pollword,
            &event_code);

        switch (event_code) {
        case Wimp_EPollWordNonZero: pollword_nonzero (&block); break;
        case Wimp_EUserMessage:
        case Wimp_EUserMessageRecorded:
            switch (block.user_message.hdr.action_code) {
            case Wimp_MQuit: _swix (OS_ExitAndDie, _IN (0) | _IN (3),
                0, Module_Title);
                break;
            case TaskWindow_Output: taskwindow_output (&block); break;
            case TaskWindow_Ego: child = block.user_message.hdr.sender; break;
            break;
            }
        }
    }
}
