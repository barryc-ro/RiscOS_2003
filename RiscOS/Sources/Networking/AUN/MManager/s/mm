;
; Mbuf Manager - mm.s
;
; (C) ANT Ltd 1994. All rights reserved.
; ANT Ltd. PO BOX 300. Cambridge, UK, CB1 2EG.
;
; Author: Borris
;
; History:
;
; 210994 DAF    Started in earnest
;
; Many things in this file stomp v1-v6 without caring
; It is up to the caller to save v1-v6 if needed - ideally,
; only once around a loop with an inner call to such stomping
; routines, saving some stack work.
;


; NOW LNKED FROM MODULE SO THAT WE CAN DO ARITHMETIC ON THE SYMBOLS
; FOR THE EXPORTED ROUTINES TO BE ABLE TO GENERATE THE USER AND
; NON-USER MODE FUNCTION POINTER TABLES FOR THE OPEN SESSION ACTION.


;
;-----------------------------------------------------------------------------
;

;       GET     mmhdr.s

;       AREA    mbuf_manager, CODE


;-----------------------------------------------------------------------------

        ;; Imports

        IMPORT  memset          ; equiv C function
        IMPORT  min             ; mbuf copy in
        IMPORT  mout            ; mbuf copy out
        IMPORT  bcopy           ; memory block copier

;-----------------------------------------------------------------------------

        ;; Exports


        EXPORT  alloc
        EXPORT  alloc_g
        EXPORT  alloc_s
        EXPORT  alloc_u
        EXPORT  alloc_c
        EXPORT  free
        EXPORT  core_free
        EXPORT  freem
        EXPORT  dtom_free
        EXPORT  dtom_freem
        EXPORT  ensure_safe
        EXPORT  ensure_contig
        EXPORT  dtom
        EXPORT  this_unsafe
        EXPORT  any_unsafe
        EXPORT  count_bytes
        EXPORT  cat
        EXPORT  trim
        EXPORT  copy
        EXPORT  copy_p
        EXPORT  copy_u
        EXPORT  import
        EXPORT  export
 [ DEBUG
        EXPORT  mprint
 ]

;-----------------------------------------------------------------------------

 [ DEBUG

;
; Dump an mbuf - used for debugging
;
; a1 is ptr to mbuf
;

mprint  ROUT
        ENTER   "a1, a2"
        TEQ     a1, #0
        BEQ     %f10

        DREG    a1, "mbuf: "

        MACRO
        FIELDPRINT      $field, $cc
        LDR     a2, [a1, #$field]
        DREG    a2, " $field=", $cc
        MEND

        FIELDPRINT      m_next, cc
        FIELDPRINT      m_list, cc
        FIELDPRINT      m_off, cc
        FIELDPRINT      m_len
        FIELDPRINT      m_inioff, cc
        FIELDPRINT      m_inilen, cc
        FIELDPRINT      m_ctrl, cc
        FIELDPRINT      m_actoff, cc
        FIELDPRINT      m_actlen

        DLINE           ""

        EXIT
10
        DLINE   "NULL mbuf pointer to mprint"
        DLINE           ""

        EXIT


mcprint ROUT
        ENTER   "a1, a2"
        MOV     a2, #0

 DREG a1, "Mbuf chain head is "

00      TEQ     a1, #0
        BEQ     %f10
        ADD     a2, a2, #1
        BL      mprint
        LDR     a1, [a1, #m_next]
        B       %b00

10
        DREG    a2, "Mbufs in chain: "
        EXIT

 ]


;-----------------------------------------------------------------------------
;
; Direct entry point interface routines.
;
; The addresses of these routines are entered into the mbctl structure during
; an Mbuf_OpenSession SWI. Every single one of these routine supplies a1 (r0) as a pointer
; to the mbctl supplied during the Mbuf_OpenSession SWI. The LDCTX macro loads
; our context from this value (for now, this is a simple load, but future
; versions might place an additional block of memory between these two
; pointers to provide quick access to information on a per-client basis.
;
;-----------------------------------------------------------------------------
;
; alloc
;
; Purpose:
;
; Default allocation strategy allocator (MBC_DEFAULT).
;
; Entry:
;
; a1    context
; a2    bytes
; a3    ptr
;
; Exit:
;
; a1    mbuf chain ptr or NULL
;

alloc           LDCTX

core_alloc      ROUT

        [ DEBUG
                CDIRQS  a1
                SADD    a1, a4, ALLOC_CALLS
                CRIRQS  a1

                TEQ     a3, #0
                BEQ     %f00
                CDIRQS  a1
                SADD    a1, a4, ALLOC_PTR_0_CALLS
                CRIRQS  a1
        ]

00              MOV     a4, #0
                B       core_alloc_g

;-----------------------------------------------------------------------------
;
; alloc_g
;
; Purpose:
;
; Entry:
;
; a1    context
; a2    bytes
; a3    pointer
; a4    flags
;
; Exit:
;
; a1    allocated chain
;
; Errors:
;
; Interrupts:
;
; Notes:
;
;
;    MBC_UNSAFE  bytes       MBC_SINGLE  type
;
;    0           0           ?           first safe
;    0           \= 0        0           many sized
;    0           \= 0        1           single sized
;
;    1           0           ?           single unsafe
;    1           \= 0        ?           single unsafe sized
;
; Any/all can get trashed on copying and clearing - below applies
; from entry until 50, where copying/clearing are done.
; v1    trashed
; v2    trashed
; v3    trashed
; v4    spare?
; v5    spare?
; v6    flags to restore against

alloc_g

        LDCTX

 [ DEBUG
        CDIRQS  a1
        STMFD   sp!, {lr}               ; need a temp reg: shame
        SADD    a1, lr, ALLOC_G_CALLS
        LDMFD   sp!, {lr}
        CRIRQS  a1
 ]

core_alloc_g ROUT

        ENTER   "a2-a4, v1-v6"

        MOV     v6, pc                  ; current IRQ state
        IRQSOFF lr

        ; IRQS DISABLED FROM HERE TO EXIT OR %50

 [ DEBUG
        SADD    a1, v1, CORE_ALLOC_G_CALLS
 ]

        TST     a4, #MBC_UNSAFE
        BNE     %f00               ; allocation of unsafe mbufs
        TEQ     a2, #0
        BEQ     %f10               ; allocation of first available mbuf
        TST     a4, #MBC_SINGLE
        BNE     %f20               ; allocation of precisely one mbuf

; allocation of an mbuf chain

; DLINE "Alloction of an mbuf chain"

        MOV     v1, a2              ; bytes left count (assert not zero)
        MOV     v2, #0              ; chain built so far

31      CMP     v1, #min_msize
        BLE     %f30               ; try and use small mbufs
        LDR     a1, [ws, #big_chain]
        TEQ     a1, #0
        BEQ     %f30               ; no big mbufs so no choice

        LDR     v3, [a1, #m_next]   ; remove from big chain
        STR     v3, [ws, #big_chain]
        STR     v2, [a1, #m_next]   ; add into our chain
        MOV     v2, a1              ; side effect of reversing list

 [ DEBUG
	STMFD	sp!, {lr}
	BL	note_alloc_large
	LDMFD	sp!, {lr}
 ]

        LDR     v3, [a1, #m_len]
        SUBS    v1, v1, v3          ; adjust for this. continue?
        BGT     %b31               ; continue trying big mbufs

        ADDLT   v1, v1, v3
        STRLT   v1, [a1, #m_len]    ; set size to precise amount
        MOV     a1, v2
        B       %f50               ; one mbuf chain allocated

; here cause either only small required or no large available
; know need at least one mbuf still
30

; DLINE "No large or need only small"

        LDR     a1, [ws, #small_chain]
        TEQ     a1, #0
        BEQ     %f32

        LDR     v3, [a1, #m_next]   ; remove from small chain
        STR     v3, [ws, #small_chain]
        STR     v2, [a1, #m_next]   ; add into our chain
        MOV     v2, a1              ; side effect of reversing list

 [ DEBUG
	STMFD	sp!, {lr}
	BL	note_alloc_small
	LDMFD	sp!, {lr}
 ]

        LDR     v3, [a1, #m_len]
        SUBS    v1, v1, v3          ; adjust for this. continue?
        BGT     %b30               ; continue trying small mbufs

        ADDLT   v1, v1, v3
        STRLT   v1, [a1, #m_len]    ; set size to precise amount
        MOV     a1, v2
        B       %f50               ; one mbuf chain allocated

; no small mbufs - if no big then fail allocation and free result so far
32

; DLINE "No small mbufs available"

        LDR     a1, [ws, #big_chain]
        TEQ     a1, #0
        BEQ     %f33               ; failed the allocation

        LDR     v3, [a1, #m_next]   ; remove from big chain
        STR     v3, [ws, #big_chain]
        STR     v2, [a1, #m_next]   ; add into our chain
        MOV     v2, a1              ; side effect of reversing list

 [ DEBUG
	STMFD	sp!, {lr}
	BL	note_alloc_large
	LDMFD	sp!, {lr}
 ]

        LDR     v3, [a1, #m_len]
        SUBS    v1, v1, v3          ; adjust for this. continue?
        BGT     %b32               ; continue trying big mbufs

        ADDLT   v1, v1, v3
        STRLT   v1, [a1, #m_len]    ; set size to precise amount
        MOV     a1, v2
        B       %f50               ; one mbuf chain allocated

; Failed the allocation. Need to release whatever chain we built.
; In the long run (and with an alternative dtom strategy) this is
; a point where we might try and extend the heap!
; IRQs must be disabled at this point for the freeing
; v2 holds chain allocated so far to be freed
33

; MCDUMP v2, "Alloction failed: chain so far to free"

        MOV     a2, v2              ; the chain so far (correctly terminated)
        BL      core_freem          ; skip the context loading!

; Failed allocation with nothing to free
01
        SADD    a1, lr, MBUF_EXHAUSTIONS
        MOV     a1, #0              ; return value that says failed
        EXIT

; allocation of unsafe mbufs
00
        ALLOC   a1, v1, v2, "small_chain"
        BEQ     %b01

        STR     a2, [a1, #m_len]    ; m_len is bytes
        STR     a2, [a1, #m_inilen] ; m_inilen is bytes
        TEQ     a2, #0
        MOVEQ   a3, #0              ; ptr is zero if bytes is zero
        SUB     a3, a3, a1
        STR     a3, [a1, #m_off]    ; data described
        STR     a3, [a1, #m_inioff]
        MOV     a3, #1
        STRB    a3, [a1, #m_safe]  ; say this one is unsafe

        EXIT                        ; no clear or copy phase for unsafe

; allocation of first available mbuf
10

; DLINE "Allocation of first available mbuf"

        ALLOC   a1, v1, v2, "small_chain"
        BNE     %f50
        BEQ     %b01
;        B       %f50

; allocation of precisely one mbuf
20

; DLINE "Allocation of a single mbuf"

        CMP     a2, #min_msize
        BLE     %f21
        CMP     a2, #max_msize

        MOVGT   a1, #0
        LDRLE   a1, [ws, #big_chain]
        TEQ     a1, #0
        BEQ     %b01

        LDR     v1, [a1, #m_next]
        STR     v1, [ws, #big_chain]
        STR     a2, [a1, #m_len]
        MOV     v1, #0

 [ DEBUG
	STMFD	sp!, {lr}
	BL	note_alloc_large
	LDMFD	sp!, {lr}
 ]

        STR     v1, [a1, #m_next]
        B       %f50

21
        ALLOC   a1, v1, v2, "small_chain"
        BEQ     %b01
        STR     a2, [a1, #m_len]
;        B       %f50

        ; CHECK FALL THROUGH CONTINUES TO HOLD!

; a1 now holds the mbuf (chain) - the allocation phase has succeeded
50
        ; RESTORE IRQS TO ENTRY STATE FROM HERE TO END

        TEQP    v6, # 0

        LDMFD   sp, {a2, a3, a4}        ; restore these for re-examination
        TST     a4, #MBC_CLEAR

; This instruction used to implement the requirement that the clear phase
; only occurs if ptr (a3) is not null.
;        TEQNE   a3, #0

        BEQ     %f60               ; no clearing phase

; zero the underlying storage for the entire mbuf chain described by a1

; DLINE "Zeroing underlying storage"

        STMFD   sp!, {a1}
        STMFD   sp!, {a1}

51      LDMFD   sp!, {a1}
        TEQ     a1, #0
        BEQ     %f52
        LDR     lr, [a1, #m_next]
        STMFD   sp!, {lr}
        LDR     a2, [a1, #m_actlen]
        LDR     a3, [a1, #m_actoff]
        ADD     a1, a1, a3
        MOV     a3, #0
        BL      memset
        B       %b51

52      LDMFD   sp!, {a1}
        LDMFD   sp, {a2, a3, a4}

; the copying phase
60      TEQ     a3, #0
        EXIT    EQ                  ; no copy phase, so completed

; copy from ptr to mbuf chain in a1 for length of mbuf chain (M_COPYALL)

; DLINE "Performing copy phase"

        STMFD   sp!, {a1}

        MOV     a2, a1                  ; mbuf ptr
        MOV     a1, #0                  ; no bias
        MOV     a4, a3                  ; ptr
        MOV     a3, #M_COPYALL          ; do the entire chain
        BL      min

        LDMFD   sp!, {a1}

; DREG a1, "Return value after copy phase "

        EXIT




;-----------------------------------------------------------------------------
;
; alloc_u
;
; Purpose:
;
; Entry:
;
; Exit:
;
; Errors:
;
; Interrupts:
;
; Notes:
;

alloc_u         ROUT

                LDCTX

	[ DEBUG
                CDIRQS  a1
                SADD    a1, a4, ALLOC_U_CALLS
                CRIRQS  a1
	]

core_alloc_u	ROUT

                MOV     a4, #MBC_UNSAFE
                B       core_alloc_g

;-----------------------------------------------------------------------------
;
; alloc_s
;
; Purpose: Single mbuf allocation whatever size is requested
;
; Entry:
;
; a1    context
; a2    bytes
; a3    ptr
;
; Exit:
;
; a1    chain ptr or NULL
;

alloc_s         ROUT
                LDCTX

        [ DEBUG
                CDIRQS  a1
                SADD    a1, a4, ALLOC_S_CALLS
                CRIRQS  a1

                TEQ     a3, #0
		BEQ	%f00

                CDIRQS  a1
                SADD    a1, a4, ALLOC_S_PTR_0_CALLS
                CRIRQS  a1
        ]
00              MOV     a4, #MBC_SINGLE
                B       core_alloc_g

;-----------------------------------------------------------------------------
;
; alloc_c
;
; Purpose: Allocate an mbuf with underlying storage being zerod
;
; Entry:
;
; a1    context
; a2    bytes
; a3    ptr
;
; Exit:
;
; a1    chain ptr or NULL
;

alloc_c         ROUT
                LDCTX

        [ DEBUG
                CDIRQS  a1
                SADD    a1, a4, ALLOC_C_CALLS
                CRIRQS  a1

                TEQ     a3, #0
		BEQ	%f00

                CDIRQS  a1
                SADD    a1, a4, ALLOC_C_PTR_0_CALLS
                CRIRQS  a1
        ]

00              MOV     a4, #MBC_CLEAR
                B       core_alloc_g

;-----------------------------------------------------------------------------
;
; ensure_safe
;
; Purpose:
;
; Entry:
;
; a1    context
; a2    mbuf chain ptr
;
; Exit:
;
; a1    safe mbuf chain ptr
; Errors:
;
; Interrupts:
;
; Notes:
;

ensure_safe     LDCTX

core_ensure_safe ROUT

        [ DEBUG
                CDIRQS  a1
                SADD    a1, a4, ENSURE_SAFE_CALLS
                CRIRQS  a1
        ]
                STMFD   sp!, {a2, lr}
                BL      core_any_unsafe
                TEQ     a1, #0
                LDMEQFD sp!, {a1, pc}^

        [ DEBUG
                CDIRQS  a1
                SADD    a1, a4, ENSURE_SAFE_DID_SOMETHING
                CRIRQS  a1
        ]

; there are some unsafe mbufs somewhere in the chain. For now, be very
; crude and just take a copy of the chain.
; guess this has to be an m_type preserving action unless we want
; many variants of this (ie copy_p variant of copy)

                LDMFD   sp, {a2}

                MOV     a3, #0                  ; offset of zero
                MOV     a4, #M_COPYALL          ; all data
                BL      core_copy_p

;                LDMFD   sp, {a2}
;                STMFD   sp, {a1}

		LDR	a2, [sp, # 0]
		STR	a1, [sp, # 0]

                BL      core_freem

                LDMFD   sp!, {a1, pc}^

;-----------------------------------------------------------------------------
;
; ensure_contig
;
; Purpose:
;
; Ensure that the specified number of bytes at the start of the mbuf chain
; are all in the first mbuf and that they are at least word aligned. We
; notionally have an upper limit of the smallest mbuf size for the number
; of bytes we will contiguify, but we will actually do the simpler cases
; for larger mbufs as well (if no allocations are involved).
;
; Entry:
;
; a1    context
; a2    mbuf
; a3    byte count
;
; Exit:
;
; a1    ensured mbuf chain ptr
;       NULL if failed and entire supplied chain freed
;

ensure_contig   ROUT

                LDCTX

         [ DEBUG
                CDIRQS  a1
                SADD    a1, a4, ENSURE_CONTIG_CALLS
                CRIRQS  a1
         ]

                MOVS    a4, a2
                TEQNE   a3, #0
                MOVEQ   a1, a4
                MOVEQS  pc, lr                          ; give NULL, get NULL

                CMP     a3, # min_msize                 ; be strict: more predictable!
;                BGT     %f80                            ; do allocation if big
  BGT %f91 ; fail for now

                LDRB    a1, [a4, #m_safe]
                TEQ     a1, # 0
                BNE     %f91                            ; can't ensure unsafe!

                LDR     a1, [a4, #m_len]
                CMP     a1, a3
                BLT     %f50
; DREG a1, "1st mbuf big enough for request "
                MOV     a3, a1                          ; num bytes in this mbuf

                LDR     a1, [a4, # m_off]
                TST     a1, # 3

                MOVEQ   a1, a4
        [ DEBUG
                BNE     %f00
                IRQSOFF a2
                SADD    a2, a3, ENSURE_CONTIG_QUICK
                MOVS    pc, lr                          ; at least enough and aligned
00
        |
                MOVEQS  pc, lr                          ; at least enough and aligned
        ]

                STMFD   sp!, {a4, v1-v6, lr}

                ADD     a1, a1, a4

                LDR     a2, [a4, # m_actoff]
                STR     a2, [a4, # m_off]
                ADD     a2, a2, a4

                BL      bcopy

         [ DEBUG
                CDIRQS  v1
                SADD    v1, v2, ENSURE_CONTIG_SIMPLE
                CRIRQS  v1
         ]

                LDMFD   sp!, {a1, v1-v6, pc}^

; Don't have enough data in 1st mbuf yet
; Rephrase request as a trim with copy operation with a correction
; a1    m_len for first mbuf
; a2	users mbuf ptr
; a3	user byte count to ensure contig on
; a4    copy of a2 (and it is not zero)
; a4 hence needs skipping first

50              STMFD   sp!, {a3, lr}
; DLINE "Using trim to perform ensure contig"
51              LDR     a4, [a4, #m_next]
                TEQ     a4, #0
                LDRNE   lr, [a4, #m_len]
                ADDNE   a1, a1, lr
                BNE     %b51
; DREG a1, "Total length of mbuf chain "
                CMP     a1, a3                          ; enough bytes in mbuf?
                BLT     %f90

                LDR     a4, [a2, #m_actoff]             ; will end up here
                ADD     a4, a4, a2                      ; raw ptr is mtod of underlying 1st mbuf
; DBG4 "ensure_contig into trim"
                BL      core_trim                       ; a2=mp, a3=bytes, a4=ptr
; DBG4 "trim back to ensure_contig"
                LDMFD   sp!, {a3}
		TEQ	a1, # 0

                STRNE   a3, [a1, #m_len]

                LDRNE   a4, [a1, #m_actoff]
                STRNE   a4, [a1, #m_off]
; DREG a3, "Set new len to ", cc
; DREG a4, " and new offset to "


        [ DEBUG
                IRQSOFF a2
                SADD    a2, a3, ENSURE_CONTIG_SLOW
        ]
                LDMFD   sp!, {pc}^

90              LDMFD   sp!, {a3, lr}
91

         [ DEBUG
                CDIRQS  a1
                SADD    a1, a3, ENSURE_CONTIG_FAILS
                CRIRQS  a1
         ]

                B       core_freem

;----------------------------------------------------------------------------

; Produce a copy of the data supplied for when the data is large.

;-----------------------------------------------------------------------------

 [ {FALSE}

        ; Can fit data into 1st mbuf and there is enough room

        LDMFD   sp, {a4}                        ; restore mbuf head

        ; shuffle first mbuf up

        LDR     a1, [a4, #m_off]
        ADD     a1, a1, a4                      ; mtod existing data
        LDR     a2, [a4, #m_actoff]
        STR     a2, [a4, #m_off]
        ADD     a2, a2, a4                      ; mtod where want data
        LDR     a3, [a4, #m_len]                ; bytes so far
        BL      bcopy

        ; copy into 1st mbuf from other mbufs

        LDMFD   sp, {v1, v2}                    ; mbuf ptr and byte count
        LDR     a4, [v1, #m_len]
        SUB     v2, v2, a4                      ; bytes to go

        MOV     v3, v1                          ; chain head

        LDR     v1, [v1, #m_next]

        ; v1    mbuf to do next
        ; v2    bytes left
        ; v3    chain head

51      LDR     a3, [v1, #m_len]
        SUBS    v2, v2, a3
        BLT     %f52

        ; at least this mbuf

        LDR     a1, [v1, #m_off]
        ADD     a1, a1, v1                      ; mtod for src

        LDR     a2, [v3, #m_off]
        LDR     a4, [v3, #m_len]
        ADD     a2, a2, a4                      ; mtod for dest
        ADD     a2, a2, v3                      ; at END of data

        ADD     a4, a4, a3
        STR     a4, [v3, #m_len]                ; length will become

        MOV     a4, # 0
        STR     a4, [v1, #m_len]                ; these bytes removed

        LDR     v1, [v1, #m_next]               ; advance to next mbuf

        STMFD   sp!, {v1, v2, v3}

        BL      bcopy

        LDMFD   sp!, {v1, v2, v3}

        B       %b51

52      ADDS    v2, v2, a3                      ; v2 now how much to do



        MOVGES  pc, lr                          ; yep - quick out
        CMP     a3, #max_msize                  ; ever possible?
        BGT     core_freem                      ; exits with a1=0

; currently ignores the case of the 1st mbuf has unused underlying
; storage. Should also do a bit extra in case called repeatedly.
; Does not cater for byte count being bigger than chain itself.
; If this happens, the chain will grow and collect garbage!

        STMFD   sp!, {a2, a3, lr}               ; mbuf, count
        MOV     a2, a3                          ; bytes
        MOV     a3, #0                          ; ptr
        MOV     a4, #MBC_SINGLE                 ; whole point!

; DLINE "Allocating contig storage"

        BL      core_alloc_g
        LDMFD   sp!, {a2, a3}
        TEQ     a1, #0                          ; managed it?
        LDMEQFD sp!, {lr}
        BEQ     core_freem                      ; free a2, exits with a1=0
        LDR     a4, [a1, #m_off]
        ADD     a4, a4, a1                      ; mtod on new contig mbuf
        STMFD   sp!, {a1}

; DLINE "Copy and trim to perform the contig operation"

        BL      core_trim
        MOV     a2, a1
        LDMFD   sp!, {a1, lr}
        STR     a2, [a1, #m_next]               ; make complete chain

; MCDUMP a1, "Final chain with start contig"

        MOVS    pc, lr                          ; ignore wasted empty mbufs


 ] ; FALSE

;-----------------------------------------------------------------------------
;
; free
;
; Purpose:
;
; Entry:
;
; a1    context
; a2    mbuf ptr
;
; Exit:
;
; Errors:
;
; Interrupts:
;
; Notes:
;

free    ROUT

        LDCTX

core_free

        CDIRQS  a1

 [ DEBUG
        SADD    a1, a3, FREE_CALLS
 ]

        TEQ     a2, #0
        MOVEQS  pc, lr
        FREE    a2, a1, a3
        MOVS    pc, lr

;-----------------------------------------------------------------------------
;
; freem
;
; Purpose:
;
; Free an entire mbuf chain and return NULL.
;
; Entry:
;
; a1    context
; a2    mbuf chain ptr
;
; Exit:
;
; a1    zero
;
; Notes:
;
; Other code relies upon the NULL return value

freem   ROUT

        LDCTX

core_freem ROUT

        CDIRQS  a1

 [ DEBUG
        SADD    a1, a4, FREEM_CALLS
 ]

00
        MOVS    a1, a2
        MOVEQS  pc, lr                  ; ALWAYS EXIT WITH A1=0
        LDR     a2, [a1, #m_next]
        FREE    a1, a3, a4
        B       %b00

;-----------------------------------------------------------------------------
;
; dtom_free
;
; Purpose:
;
; Entry:
;
; a1    context
; a2    data pointer (for single mbuf)
;
; Exit:
;
; Errors:
;
; Interrupts:
;
; Notes:
;

dtom_free ROUT

        LDCTX

core_dtom_free

        CDIRQS  a1

 [ DEBUG
        SADD    a1, a4, DTOM_FREE_CALLS
 ]

        ;       ptr, res, w1, w2, w3
        DTOM    a2,  a1,  a1, a3, a4
        MOV$dn.S pc, lr
        FREE    a1, a2, a3
        MOVS    pc, lr

;-----------------------------------------------------------------------------
;
; dtom_freem
;
; Purpose:
;
; Entry:
;
; a1    context
; a2    ptr to mbuf chain
;
; Exit:
;
;       nowt
;
; Errors:
;
; Interrupts:
;
; Notes:
;

dtom_freem ROUT

        LDCTX

        CDIRQS  a1

 [ DEBUG
        SADD    a1, a4, DTOM_FREEM_CALLS
 ]

        ;       ptr, res, w1, w2, w3, ws
        DTOM    a2,  a1,  a1, a3, a4

        MOV$dn  a1, #0
00      MOVS    a2, a1
        MOVEQS  pc, lr
        LDR     a1, [a2, #m_next]
        FREE    a2, a3, a4
        B       %b00

;-----------------------------------------------------------------------------
;
; dtom
;
; Purpose:
;
; Entry
;
; a1    Context handle
; a2    Address within an mbuf (allegedly)
;
; Exit
;
; a1    NULL if address isn't within our controlled region
;       address of underlying storage owning mbuf otherwise
;
; Errors:
;
; Interrupts:
;
; Notes:
;
; This implementation constrains us to a single block of underlying
; storage. Multiple blocks might be supported by a number of range
; checks (undesirable!) or by placing mbufs at a more fixed position,
; in relation to the underlying block it controls.
;

dtom    LDCTX

 [ DEBUG

        CDIRQS  a1
        SADD    a1, a3, DTOM_CALLS
        CRIRQS  a1

        ;       ptr, res, w1, w2, w3, ws
        DTOM    a2,  a1,  a1, a3, a4
        MOV$dy.S pc, lr              ; blunt quick exit

        IRQSOFF a1
        SADD    a1, a2, FAILED_DTOMS

        MOV     a1, #0                  ; consider this case less likely
        MOVS    pc, lr

 |

        ;       ptr, res, w1, w2, w3, ws
        DTOM    a2,  a1,  a1, a3, a4
        MOV$dy.S pc, lr              ; blunt quick exit
        MOV     a1, #0                  ; consider this case less likely
        MOVS    pc, lr

 ]



;-----------------------------------------------------------------------------
;
; any_unsafe
;
; Purpose:
;
; ENTER:
;
; a1    context
; a2    mbuf chain pointer
;
; Exit:
;
; a1    0 = no unsafe mbufs, 1 = unsafe mbufs
;
; Errors:
;
; Interrupts:
;
; Notes: DOES NOT REQUIRE CONTEXT, APART FROM DEBUGGING STAT.
;

any_unsafe

 [ DEBUG

        LDCTX

core_any_unsafe ROUT

        CDIRQS  a1
        SADD    a1, a3, ANY_UNSAFE_CALLS
        CRIRQS  a1

 |

core_any_unsafe ROUT

 ]

        MOV     a1, #0
00      TEQ     a2, #0
        MOVEQS  pc, lr
        LDRB    a4, [a2, #m_safe]
        ORRS    a1, a1, a4
        MOVNES  pc, lr
        LDR     a2, [a2, #m_next]
        B       %b00

;-----------------------------------------------------------------------------
;
; this_unsafe
;
; Purpose:
;
; ENTER:
;
; a1    context
; a2    single mbuf pointer
;
; Exit:
;
; a1    0 = this mbuf is safe, 1 = this mbuf is unsafe
;
; Errors:
;
; Interrupts:
;
; Notes:
;

this_unsafe ROUT

 [ DEBUG
        LDCTX

        CDIRQS  a1
        SADD    a1, a3, THIS_UNSAFE_CALLS
        CRIRQS  a1
 ]
        MOVS    a1, a2
        LDRNEB  a1, [a1, #m_safe]
        MOVS    pc, lr

;-----------------------------------------------------------------------------
;
; count_bytes
;
; Purpose:
;
; Count the number of bytes described by the mbuf chain supplied.
;
; ENTER:
;
; a1    context
; a2    mbuf chain pointer
;
; Exit:
;
; a1    number of bytes
;
; Errors:
;
; Supplying a null pointer returns zero bytes.
;
; Notes:
;
; a1, a2, a3 and the flags are the only things trashed. All
; else MUST be preserved.
;
; DOES NOT REQUIRE CONTEXT, APART FROM DEBUGGING STATISTICS.
;

count_bytes

 [ DEBUG

        LDCTX

core_count_bytes ROUT

        CDIRQS  a1
        SADD    a1, a3, COUNT_BYTES_CALLS
        CRIRQS  a1
 |

core_count_bytes ROUT

 ]

        MOV     a1, #0
00      TEQ     a2, #0
        MOVEQS  pc, lr
        LDR     a3, [a2, #m_len]
        ADD     a1, a1, a3
        LDR     a2, [a2, #m_next]
        B       %b00

;-----------------------------------------------------------------------------
;
; cat
;
; Purpose:
;
; Concatentate two mbuf chains.
;
; ENTER:
;
; a1    context
; a2    first mbuf chain (gets appended to)
; a3    second mbuf chain (gets appended)
;
; Exit:
;
; a1    value of a2 on ENTER
;
; Errors:
;
; If a3 is NULL, a2 is returned.
; Else if a2 is NULL, a3 is returned
;
; Interrupts:
;
; Notes:
;

cat     ROUT

 [ DEBUG
        LDCTX

        CDIRQS  a1
        SADD    a1, a4, CAT_CALLS       ; no puns please
        CRIRQS  a1
 ]
        MOVS    a1, a2              ; if a2 is null
        MOVEQ   a1, a3              ; then return a3
        TEQNE   a3, #0              ; else if a3 is null
        MOVEQS  pc, lr              ; then return a2.

00      LDR     a4, [a2, #m_next]
        TEQ     a4, #0              ; end of 1st chain?
        MOVNE   a2, a4              ; no, so follow more
        BNE     %b00

        STR     a3, [a2, #m_next]   ; tag 2nd on end of first

        MOVS    pc, lr              ; and return first


;-----------------------------------------------------------------------------
;
; copy
;
; Purpose:
;
; ENTER:
;
; a1    context
; a2    mbuf chain pointer
; a3    offset
; a4    length (maybe M_COPYALL)
;
; Exit:
;
; a1    new ptr or NULL
;
; Notes:
;
; If the length is zero bytes, then return an empty chain. Don't factor
; out M_COPYALL - must always cope with going beyond the end of the mbuf
; chain anyway (this is partly why M_COPYALL is what it is!).
;

copy            LDCTX

core_copy       ROUT

                STMFD   sp!, {lr}

	[ DEBUG
                CDIRQS  a1
                SADD    a1, lr, COPY_CALLS
                CRIRQS  a1
        ]

                MOVS    a1, a2
                LDMEQFD sp!, {pc}^

                STMFD   sp!, {a2-a4, v1-v6}

                ; a2 is mbuf ptr

                BL      core_count_bytes

                ; a1 is bytes in chain

                LDMFD   sp, {a2, a3, a4}                ; entry ptr, offset, bytes

                SUBS    a1, a1, a3                      ; calc bytes to do
                BLE     %f10                            ; no bytes - empty mbuf chain

                TEQ     a4, #0
                BEQ     %f10                            ; special case

                ; a1 is max number bytes avail

                CMP     a1, a4                          ; meet users desired byte count?

                MOVLT   a2, a1                          ; no - limit to bytes avail
                MOVGE   a2, a4                          ; yes - chooses users figure
                MOV     a3, #0                          ; ptr
                BL      core_alloc

                ; a1 is eventual yield value. it is precisely the correct length
                ; for what needs copying into it.
                TEQ     a1, #0
                BEQ     %f01                            ; failed alloc

                ; find first mbuf of source chain to start copying within


                STMFD   sp!, {a1}                       ; save return value ####


                LDR     a1, [sp, #8]                    ; offset into mbuf
                LDR     a2, [sp, #4]


00              LDR     a3, [a2, #m_len]
                SUBS    a1, a1, a3
                LDRGE   a2, [a2, #m_next]
                BGE     %b00

                ADD     a1, a1, a3                      ; offset into this mbuf

                LDR     v1, [sp, #0]


02              TEQ     v1, #0
;                BEQ     %f03
                LDMEQFD sp!, {a1-a4, v1-v6, pc}^


                LDR     a3, [v1, #m_len]
                LDR     a4, [v1, #m_off]
                ADD     a4, a4, v1
                LDR     v1, [v1, #m_next]

                STMFD   sp!, {v1}
                BL      mout
                LDMFD   sp!, {v1}
                B       %b02

;03              LDMFD   sp!, {a1-a4, v1-v6, pc}^

;-----------------------------------------------------------------------------

; failed new allocation
01
        MOV     a1, #0
        LDMFD   sp!, {a2-a4, v1-v6, pc}^

 [ False
        LDMFD   sp!, {a2-a4}
        BL      core_freem
        MOV     a1, #0
        LDMFD   sp!, {v1-v6, pc}^
 ]

;-----------------------------------------------------------------------------

; Yielding zero bytes
10

; DLINE "Yielding an empty mbuf chain from copy"

	LDMFD	sp!, {a2-a4, v1-v6, lr}
	B	alloc_empty_chain;

 [ {FALSE}
        MOV     a2, #0
        MOV     a3, #0
        BL      core_alloc
        TEQ     a1, #0
        MOVNE   a2, #0
        STRNE   a2, [a1, #m_len]
        LDMFD   sp!, {a2-a4, v1-v6, pc}^
 ]


 [ False
        LDMFD   sp!, {a2, a3, a4}
        BL      core_freem                      ; free the old chain 1st
        MOV     a2, #0                          ; any only mbuf
        MOV     a3, #0                          ; no ptr
        BL      core_alloc

        ; a1 is eventual yield value
        TEQ     a1, #0
        LDMEQFD sp!, {v1-v6, pc}^               ; failed - return NULL

        MOV     a2, #0
        STR     a2, [a1, #m_len]                ; make zero bytes described
        LDMFD   sp!, {v1-v6, pc}^
 ]

;-----------------------------------------------------------------------------
;
; skip_bytes:   skip the specified number of bytes in an mbuf chain.
;               also skips any empty mbufs after skipping specified number
;               of bytes.
;               caller MUST catch the negative case (often MOVS a1, reg)
;               and EQ case is not efficient to call here (but correct).
;
;               NOTE THE DUAL RETURN VALUES
;
; In pseudo code
;
;
; struct (int, mbuf *) skip_n_bytes(int n, mbuf *mp)
; {
;         while (mp != NULL && n != 0)
;         {
;                 len = mp->m_len;
;                 if (len > n)
;                         return (n, mp);
;                 mp = mp->m_next;
;                 n -= len;
;         }
;
;         while (mp != NULL && mp->m_len == 0)
;                 mp = mp->m_next;
;
;         return (n, mp);
; }
;
; Entry
; a1    bytes to skip
; a2    mbuf chain ptr
;
; Exit
; a1    bytes in this mbuf remaining to skip
; a2    update mbuf ptr or NULL
;
; All other registers preserved
;

skip_bytes      ROUT
 [ DEBUG
; DBG2 "skip_bytes"
 ]
                ENTER   "a3"

00              TEQ     a2, # 0
                TEQNE   a1, # 0
                BEQ     %f01

                LDR     a3, [a2, # m_len]
                CMP     a3, a1
                EXIT    GT

                LDR     a2, [a2, #m_next]
                SUB     a1, a1, a3
                B       %b00

01              TEQ     a2, # 0
                EXIT    EQ
                LDR     a3, [a2, # m_len]
                TEQ     a3, # 0
                EXIT    NE
                LDR     a2, [a2, # m_next]
                B       %b01

;-----------------------------------------------------------------------------
;
; stamp_type    Write the given m_type value into all mbufs of the chain
;               given.
;
; Entry
;
; a1            m_type value
; a2            mbuf chain ptr
;
; Exit
;
; a1            preserved
; a2            preserved
;

stamp_type      ROUT
 [ DEBUG
; DBG2 "stamp_type"
 ]
                ENTER   "a1, a2"
00              TEQ     a2, # 0
                EXIT    EQ
                STRB    a1, [a2, # m_type]
                LDR     a2, [a2, # m_next]
                B       %b00

;-----------------------------------------------------------------------------
;
; alloc_empty_chain:
;
; Allocate an mbuf and set the length to zero. Caters for my cockup in
; specifying magic meaning to allocation of zero bytes.
;

alloc_empty_chain
 [ DEBUG
; DLINE "alloc_empty_chain"
 ]
                ENTER
                MOV     a2, # 0
                MOV     a3, # 0
                BL      core_alloc
                MOV     a2, # 0
                TEQ     a1, # 0
                STRNE   a2, [a1, # m_len]
                EXIT

;-----------------------------------------------------------------------------
;
; copy_p:       copy and mbuf chain preserving type information
;
; copy the intersection between the described data and offset/length specified
; bit of chain. Always try to return an actual pointer even if it describes
; no data.
;
; We don't try to perform small to large mbuf merging. This is based on the
; following set of circumstances - for any benefit to ever be obtainable from
; merging, one or more of these must have occurred:
;
; no large mbufs (is it worth trying again?)
; allocation size not warrant large mbufs (recode or not worth it?)
; deliberatly used small mbufs (pref recode)
; obtained chain from elswhere (pref recode)
; allocated with bytes==0 case (pref recode)
;
; Thus, I don't currently think merging is actually worth it.
;
; if returning zero bytes, then no effort is made to find an m_type
; value to try and associate with the returned mbuf.
;
; Quick pseudo code version:
;
; mbuf * copy_p(mbuf *mp, int offset, int length)
; {
;         if (mp == NULL)
;                 return NULL;
;
;         answer = NULL;
;         current = NULL;
;         x, tp;
;
;         (offset, mp) = skip_bytes(offset, mp);
;
;         if (mp == NULL || length == 0)
;                 return alloc_empty_chain();
;
;         do
;         {
;                 x = mp->m_len - offset;
;
;                 if (x > length)
;                         x = length;
;
;                 tp = alloc(x, mtod(mp) + offset);
;
;                 offset = 0;
;                 length -= x;
;
;                 if (tp == NULL)
;                         return core_freem(answer);
;
;                 stamp_type(tp, mp->m_type);
;
;                 if (mp->m_flags & M_PKTHDR)
;                 {
;                         tp->m_flags = (mp->m_flags & M_COPYFLAGS);
;                         tp->m_pkthdr = mp->m_pkthdr
;                 }
;
;                 if (answer == NULL)
;                         current = answer = tp;
;                 else
;                         current->m_next = tp;
;
;                 while (current->m_next != NULL)
;                         current = current->m_next;
;
;                 mp = mp->m_next;
;
;         } while (mp != NULL && length != 0);
;
;         return answer;
; }
;
; Entry
;
; a1            context
; a2            mbuf chain ptr
; a3            offset
; a4            length (maybe M_COPYALL)
;
; Exit
;
; a1            mbuf ptr or NULL
;
; v1    answer
; v2    current
; v3    x
; v4    offset
; v5    length
; v6    mp
;
;mbuf * copy_p(mbuf *mp, int offset, int length)
;{


copy_p          LDCTX
core_copy_p     ROUT

; DBG4 "copy_p"

                ENTER   "v1-v6"

 [ DEBUG
                CDIRQS  a1
                SADD    a1, lr, COPY_P_CALLS
                CRIRQS  a1
 ]

; if (mp == NULL) return NULL;

                MOVS    a1, a2
                EXIT    EQ

; answer = NULL; current = NULL; x, tp

                MOV     v1, # 0                 ; answer
                MOV     v2, # 0                 ; current
                MOVS    v5, a4                  ; length
                BEQ     %f10                    ; return alloc_empty_chain

; (offset, mp) = skip_bytes(offset, mp);

                MOVS    a1, a3
                MOVLE   v4, # 0
                BLGT    skip_bytes
                MOVGT   v4, a1                  ; offset

; if (mp == NULL || length == 0) return alloc_empty_chain();

                MOVS    v6, a2                  ; mp
                BEQ     %f10

; do {
00

; x = mp->m_len - offset;

                LDR     v3, [v6, # m_len]
                SUB     v3, v3, v4

; if (x > length) x = length;

                CMP     v3, v5
                MOVGT   v3, v5

; if x == 0 then skip allocating an mbuf

;                TEQ     v3, # 0

; tp = alloc(x, mtod(mp) + offset);

                MOV   a2, v3
                LDR   a3, [v6, # m_off]
                ADD   a3, a3, v6
                ADD   a3, a3, v4
                BL      core_alloc              	; preserves flags

; offset = 0; length -= x;

                MOV     v4, # 0
                SUB     v5, v5, v3

; if (tp == NULL) return core_freem(answer);

		MOVS	a2, a1
                BEQ     %f20

; fudge to handle 0 bytes special allocation case

		TEQ	v3, # 0				; 0 byte alloc?
		STREQ	v3, [a2, # m_len]

; stamp_type(tp, mp->m_type);

                LDRB    a1, [v6, # m_type]
                BL      stamp_type

; if (mp->m_flags & M_PKTHDR) {

		LDRB	a1, [v6, # m_flags]
		TSTS	a1, #M_PKTHDR
		BEQ	%f02

; tp->m_flags = mp->m_flags & M_COPYFLAGS

		AND	a1, a1, #M_COPYFLAGS
		STRB	a1, [a2, # m_flags]

; tp->m_pkthdr = mp->m_pkthdr

		LDR	a1, [v6, # m_pkthdr]
		STR	a1, [a2, # m_pkthdr]
		LDR	a1, [v6, # m_pkthdr+4]
		STR	a1, [a2, # m_pkthdr+4]

; }
; if (answer == NULL) current = answer = tp; else current->m_next = tp;

02              TEQ     v1, # 0
                MOVEQ   v1, a2
                MOVEQ   v2, a2
                STRNE   a2, [v2, # m_next]
                MOVNE   v2, a2                          ; 1st short circuit

; while (current->m_next != NULL) current = current->m_next;

01              LDR     a1, [v2, # m_next]
                TEQ     a1, # 0
                MOVNE   v2, a1
                BNE     %b01

; mp = mp->m_next;

                LDR     v6, [v6, # m_next]

; } while (mp != NULL && length != 0);

                TEQ     v6, # 0
                TEQNE   v5, # 0
                BNE     %b00

; return answer;

                MOV     a1, v1
                EXIT

10
              POP
                B       alloc_empty_chain

20              MOV     a2, v1
                POP
                B       core_freem

;-----------------------------------------------------------------------------
;
; copy_u        Generate an unsafe copy of an mbuf chain
;
;
; Entry
;
; a1            context
; a2            mbuf chain ptr
; a3            offset
; a4            length (maybe M_COPYALL)
;
; Exit
;
; a1            mbuf ptr or NULL
;
; v1    answer
; v2    current
; v3    offset
; v4    length
; v5    x
; v6    mp
;
;
; mbuf * copy_u(mbuf *mp, int offset, int length)
; {
; 	mbuf *current, *answer, *tp;
; 	int x;
;
; 	if (mp == NULL)
; 		return NULL;
;
; 	if (offset < 0)
; 		offset = 0;
;
; 	(offset, mp) = skip_bytes(offset, mp)
;
; 	if (mp == NULL || length == 0)
; 		return alloc_empty_chain();
;
; 	answer = NULL;
; 	current = NULL;
;
; 	do
; 	{
; 		x = mp->m_len - offset;
;
; 		if (x > length)
; 			x = length;
;
; 		tp = alloc_u(x, mtod(mp) + offset);
;
; 		if (tp == NULL)
; 			return core_freem(answer);
;
; 		tp->m_type = mp->m_type;
; 		tp->m_flags = mp->m_flags;
; 		tp->m_pkthdr = mp->m_pkthdr;
;
; 		offset = 0;
; 		length -= x;
;
; 		if (answer == NULL)
; 			answer = tp;
; 		else
; 			current->m_next = tp;
;
; 		current = tp;
;
; 		mp = mp->m_next;
;
; 	} while (mp != NULL && length != 0)
;
; 	return answer;
; }
;


copy_u		LDCTX
core_copy_u	ROUT

		ENTER	"v1-v6"

; DBG4 "copy_u"

	[ DEBUG
		CDIRQS	a1
		SADD	a1, lr, COPY_U_CALLS
		CRIRQS	a1
	]


; if (mp == NULL) return NULL;

		MOVS	a1, a2
		EXIT	EQ

; if (offset < 0) offset = 0;

		MOVS	a1, a3
		MOVLT	a1, # 0

		MOV	v4, a4				; length

; (offset, mp) = skip_bytes(offset, mp)

		BL	skip_bytes

		MOV	v3, a1				; offset

; if (mp == NULL || length == 0) return alloc_empty_chain();

		MOVS	v6, a2
		TEQNE	v4, # 0
		BEQ	%f10

; answer = NULL; current = NULL;

		MOV	v1, # 0
		MOV	v2, # 0
; do {

00

; x = mp->m_len - offset;

		LDR	v5, [v6, # m_len]
		SUB	v5, v5, v3

; if (x > length) x = length;

		CMP	v5, v4
		MOVGT	v5, v4

; tp = alloc_u(x, mtod(mp) + offset);

		MOV	a2, v5
		LDR	a3, [v6, # m_off]
		ADD	a3, a3, v6
		ADD	a3, a3, v3

		MOV	a4, # MBC_SINGLE + MBC_UNSAFE

		BL	core_alloc_g

; if (tp == NULL) return core_freem(answer);

		MOVS	a2, a1
		BEQ	%f20

; tp->m_type = mp->m_type;
; tp->m_flags = mp->m_flags;

		LDRB	a1, [v6, # m_type]
		LDRB	v3, [v6, # m_flags]

		STRB	a1, [a2, # m_type]
		STRB	v3, [a2, # m_flags]

; tp->m_pkthdr = mp->m_pkthdr;
		LDR	a1, [v6, # m_pkthdr]
		LDR	v3, [v6, # m_pkthdr+4]
		STR	a1, [a2, # m_pkthdr]
		STR	v3, [a2, # m_pkthdr+4]

; offset = 0; length -= x;

		MOV	v3, # 0
		SUB	v4, v4, v5

; if (answer == NULL) answer = tp;
; else 	current->m_next = tp;

		TEQ	v1, # 0
		MOVEQ	v1, a2
		STRNE	a2, [v2, # m_next]

; current = tp;

		MOV	v2, a2

; mp = mp->m_next;

		LDR	v6, [v6, # m_next]

; } while (mp != NULL && length != 0)

		TEQ	v6, # 0
		TEQNE	v4, # 0
		BNE	%b00

; return answer;

		MOV	a1, v1
		EXIT

10
		POP
		B	alloc_empty_chain

20		MOV	a2, v1
		POP
		B	core_freem

;-----------------------------------------------------------------------------
;
; trim		Trim bytes from the head or tail of an mbuf by adjusting the
;		m_off and m_len fields only (ie no freeing of mbufs). Also
;		optionally copy the 'trimmed' bytes into a user-supplied block
;		of memory. M_COPYALL may be supplied to indicate the entire
;		chain.
;
; ENTER:
;
; a1    context
; a2    mbuf chain ptr
; a3    count value
; a4    raw memory ptr
;
; Exit:
;
; a1    ENTER mbuf chain ptr
;
; Internal:
;
; a1	tp
; a2	mp
; a3	count
; a4	mp
; v1	bytes
; lr	temp
;
;
; mbuf *trim(mbuf *mp, int count, void *ptr)
; {
; 	if (mp == NULL)
; 		return NULL;
;
; 	if (count == 0)
; 		return mp;
;
; 	if (ptr != NULL)
; 		return trim_with_copy(mp, count, ptr);
;
; 	if (count < 0) /* Tail trim */
; 	{
; 		count = -count;
; 		bytes = 0;
; 		tp = mp;
; label1:
; 		bytes += tp->m_len;
;
; 		if (tp->m_next != NULL)
; 		{
; 			tp = tp->m_next;
; 			goto label1;
; 		}
;
; 		if (tp->m_len >= count)
; 		{
; 			tp->m_len -= count;
; 			goto done;
; 		}
;
; 		tp = mp;
;
; 		bytes -= count;
;
; 		if (bytes < 0)
; 			bytes = 0;
; label2:
; 		if (tp->m_len <= bytes)
; 		{
; 			bytes -= tp->m_len;
; 			tp = tp->m_next;
; 			goto label2;
; 		}
;
; label3:
; 		tp->m_len = bytes;
; 		bytes = 0;
; 		tp = tp->m_next;
; 		if (tp != NULL)
; 			goto label3;
;
; 	}
; 	else /* Head trim */
; 	{
; 		while (mp != NULL && count > 0)
; 		{
; 			adj = mp->m_len;
;
; 			if (adj > count)
; 				adj = count;
;
; 			mp->m_len -= adj;
; 			mp->m_off += adj;
;
; 			count -= adj;
; 			mp = mp->m_next;
; 		}
; 	}
;
; done:
; 	return entry_mp;
; }



trim		LDCTX
core_trim	ROUT

; DBG4 "trim"

; if (ptr != NULL) return trim_with_copy(mp, count, ptr);

		TEQ	a4, # 0
		BNE	core_trim_with_copy

	[ DEBUG
		CDIRQS	a1
		SADD	a1, a4, TRIM_CALLS
		CRIRQS	a1
	]

; if (mp == NULL) return NULL;

		MOVS	a1, a2

; if (count == 0) return mp;

		TEQNE	a3, # 0
		MOVEQS	pc, lr

		ENTER	"a1, v1"		; a1 is a2 is return value

; if (count < 0) /* Tail trim */ {

		CMP	a3, # 0
		BGE	%f50

; count = -count; bytes = 0; tp = mp;

		RSB	a3, a3, # 0
		MOV	v1, # 0
		MOV	a1, a2

; label1:

01

; bytes += tp->m_len;

		LDR	lr, [a1, # m_len]
		ADD	v1, v1, lr

;if (tp->m_next != NULL)
;{
;	tp = tp->m_next;
;	goto label1;
;}

		LDR	lr, [a1, # m_next]
		TEQ	lr, # 0
		MOVNE	a1, lr
		BNE	%b01

;if (tp->m_len >= count)
;{
;	tp->m_len -= count;
;	goto done;
;}

		LDR	lr, [a1, # m_len]
		SUBS	lr, lr, a3
 		STRHS	lr, [a1, # m_len]
		EXIT	HS

; tp = mp;
		MOV	a1, a2

; bytes -= count;
; if (bytes < 0) bytes = 0;


		SUBS	v1, v1, a3
		MOVLT	v1, # 0
		BLE	%f03

; label2:

02

;if (tp->m_len <= bytes)
;{
;	bytes -= tp->m_len;
;	tp = tp->m_next;
;	goto label2;
;}
;

		LDR	lr, [a1, # m_len]
		CMP	lr, v1
		SUBLE	v1, v1, lr
		LDRLE	a1, [a1, # m_next]
		BLE	%b02

; label3:

03

; 		tp->m_len = bytes;
; 		bytes = 0;
; 		tp = tp->m_next;
; 		if (tp != NULL)
; 			goto label3;

		STR	v1, [a1, # m_len]
		MOV	v1, # 0
		LDR	a1, [a1, # m_next]
		TEQ	a1, # 0
		BNE	%b03

		EXIT

; }
;else /* Head trim */ {

50

;while (mp != NULL && count > 0) {

		TEQ	a2, # 0
		CMPNE	a3, # 0
		EXIT	LE

;adj = mp->m_len;

		LDR	a4, [a2, # m_len]

;if (adj > count) adj = count;

		CMP	a4, a3
		MOVGT	a4, a3

;mp->m_len -= adj;
;mp->m_off += adj;

		LDR	lr, [a2, # m_len]
		SUB	lr, lr, a4
		STR	lr, [a2, # m_len]
		LDR	lr, [a2, # m_off]
		ADD	lr, lr, a4
		STR	lr, [a2, # m_off]

;count -= adj;

		SUB	a3, a3, a4

;mp = mp->m_next;

		LDR	a2, [a2, # m_next]
;}
		B	%b50

;-----------------------------------------------------------------------------

core_trim_with_copy ROUT

; DBG4 "trim_with_copy"

		MOVS	a1, a2
		CMPNE	a3, # 0
		MOVEQS	pc, lr
		BLT	%f50

		STMFD	sp!, {a2, a3, lr}
		MOV	a1, # 0			; skip no bytes into mbuf
		BL	mout			; perform the copying phase
		LDMFD	sp!, {a2, a3, lr}	; then do a trim without copying
		MOV	a4, # 0			; no copy with time

		B	core_trim		; and re-use existing code

50		STMFD	sp!, {a2, a3, lr}
		BL	core_count_bytes	; a4 preserved
		LDMFD	sp, {a2, a3}		; but a2,a3 trashed

		RSB	a3, a3, # 0		; how many to trim
		SUBS	a1, a1, a3		; bytes not to skip
		MOVLE	a1, # 0
		BLGT	skip_bytes

		BL	mout			; perform the copying phase
		LDMFD	sp!, {a2, a3, lr}	; then do a trim without copying
		MOV	a4, # 0			; no copy with time

		B	core_trim		; and re-use existing code


;-----------------------------------------------------------------------------
;
; import
;
; Purpose:
;
; ENTER:
;
; a1    context
; a2    mbuf chain ptr
; a3    byte count
; a4    raw ptr
;
; Exit:
;
; Errors:
;
; Interrupts:
;
; Notes:
;
; M_COPYALL assumed to be larger than any chain will ever so, so let
; normal trimming handle this as well.

import          LDCTX

core_import     ROUT

                STMFD   sp!, {a2, lr}

	[ DEBUG
                CDIRQS  a1
                SADD    a1, lr, IMPORT_CALLS
                CRIRQS  a1
	]

                MOVS    a1, a2
                TEQNE   a3, #0
                TEQNE   a4, #0

                LDMEQFD sp!, {a2, pc}^          ; prefer current a1 value

                MOV     a1, #0

                BL      min

                LDMFD   sp!, {a1, pc}^

;-----------------------------------------------------------------------------
;
; export
;
; Purpose:
;
; ENTER:
;
; a1    context
; a2    mbuf chain ptr
; a3    byte count (incl M_COPYALL)
; a4    raw ptr
;
; Exit:
;
; Errors:
;
; Interrupts:
;
; Notes:
;
; M_COPYALL assumed to be larger than any chain will ever so, so let
; normal trimming handle this as well.

; a1    bias into mbuf
; a2    mbuf ptr
; a3    byte count
; a4    raw memory ptr

export          LDCTX

core_export     ROUT

                STMFD   sp!, {a2, lr}

	[ DEBUG
                CDIRQS  a1
                SADD    a1, lr, EXPORT_CALLS
                CRIRQS  a1
	]

                MOVS    a1, a2
                TEQNE   a3, #0
                TEQNE   a4, #0

                LDMEQFD sp!, {a2, pc}^          ; prefer current a1 value

                MOV     a1, #0

                BL      mout

                LDMFD   sp!, {a1, pc}^

;-----------------------------------------------------------------------------

 [ DEBUG

how_many_mbufs ROUT
        ENTER   "a1, a2"

        LDR     a1, [ws, #small_chain]
        MOV     a2, #0
00      TEQ     a1, #0
        ADDNE   a2, a2, #1
        LDRNE   a1, [a1, #m_next]
        BNE     %b00

; DREG  a2, "Number small mbufs free: ", cc

        LDR     a1, [ws, #big_chain]
        MOV     a2, #0
01      TEQ     a1, #0
        ADDNE   a2, a2, #1
        LDRNE   a1, [a1, #m_next]
        BNE     %b01

; DREG  a2, ", Number big mbufs free: "

        EXIT

;       InsertDebugRoutines

 ]

;-----------------------------------------------------------------------------
;
; Debug statistics to keep track of high water marks
;

	[ DEBUG


note_alloc
	ENTER
	TEQ	a1, # 0
	EXIT	EQ

	LDRB	lr, [a1, # m_big]
	TEQ	lr, # 0
	BLEQ	note_alloc_small
	BLNE	note_alloc_large

	EXIT

note_alloc_small
	ENTER	"a1, a2"

	IRQSOFF	a1
	SADD	a1, a2, SMALL_ALLOCS

	LDR	a1, [ws, # small_in_use]
	ADD	a1, a1, # 1
	STR	a1, [ws, # small_in_use]
	LDR	a2, [ws, # small_hwm]
	CMP	a1, a2
	STRGT	a1, [ws, # small_hwm]

	EXIT

note_small_free
	ENTER	"a1, a2"

	IRQSOFF	a1
	SADD	a1, a2, SMALL_FREES

	LDR	a1, [ws, # small_in_use]
	SUBS	a1, a1, # 1
	STRGE	a1, [ws, # small_in_use]

	EXIT

note_alloc_large
	ENTER	"a1, a2"

	IRQSOFF	a1
	SADD	a1, a2, LARGE_ALLOCS

	LDR	a1, [ws, # large_in_use]
	ADD	a1, a1, # 1
	STR	a1, [ws, # large_in_use]
	LDR	a2, [ws, # large_hwm]
	CMP	a1, a2
	STRGT	a1, [ws, # large_hwm]

	EXIT

note_large_free
	ENTER	"a1, a2"

	IRQSOFF	a1
	SADD	a1, a2, LARGE_FREES

	LDR	a1, [ws, # large_in_use]
	SUBS	a1, a1, # 1
	STRGE	a1, [ws, # large_in_use]

	EXIT

	]

;-----------------------------------------------------------------------------

        END

; eof mm.s
