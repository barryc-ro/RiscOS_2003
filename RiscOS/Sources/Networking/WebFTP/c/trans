/* webftp.c - WebFTP core routines */
/*
 * (C) Copyright ANT Limited 1995. All rights reserved.
 *
 * Contacts:
 *
 * Postal:  ANT Ltd., PO BOX 300, Cambridge, CB1 2EG, UK.
 * Voice:   01223 567808
 * Fax:     01223 567801
 * Email:   Support@ant.co.uk
 *
 * Author:  Borris
 *
 * Music:   Skid Row - Subhuman Race
 *
 * History: Derived from Nicko's http module, especially the non-blocking
 *          handling and the error numbers!
 *
 * 130695   Borris  Created
 * 290695   Borris  Much editting
 * 030795   Borris  Multi-line responses, bits and pieces
 */


#include <stdio.h>
#include <stdlib.h>

#include <sys/socket.h>
#include <sys/select.h>

#include "files.h"          /* Nicko's quick RO file library from the http module */

#define COMPILING_WEBFTP
#include "webftp.h"

/*****************************************************************************/



/*****************************************************************************/

static volatile int     readings,
                        writings;

static volatile BOOL    callback_scheduled,
                        callback_threaded,
                        consider_pending,
                        doing_multiline;

static int              last_status;

static PSESS            sessions[FD_SETSIZE],
                        pending_list,
                        connecting_list,
                        active_list,
                        done_list;

static fd_set           rd_set, 
                        wr_set, 
                        er_set;

static _kernel_oserror  errblk;

static char             databuf[4096];

/*****************************************************************************/

static _kernel_oserror *make_error(int ecode)
{

}

/*****************************************************************************/

static _kernel_oserror *claim_events(void)
{
    _kernel_oserror *ep;
    _kernel_swi_regs r;

    r.r[0] = TICKER_RATE;
    r.r[1] = (int) timer_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(OS_CallEvery, &r, &r);

    if (ep)
        return ep;

    r.r[0] = 0x10;
    r.r[1] = (int) &inetevent_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(XOS_Bit + OS_Claim, &r, &r);

    if (ep)
    {
        r.r[0] = (int) timer_entry;
        r.r[1] = (int) private_word;

        _kernel_swi(OS_RemoveTickerEvent, &r, &r);

        return ep;
    }

    _kernel_osbyte(14, Event_Internet, 0);

    return NULL;
}

/*****************************************************************************/

static void release_events(void)
{
    _kernel_swi_regs r;

    _kernel_osbyte(13, Event_Internet, 0);

    r.r[0] = 0x10;
    r.r[1] = (int) inetevent_entry;
    r.r[2] = (int) private_word;

    _kernel_swi(OS_Release, &r, &r);

    r.r[0] = (int) timer_entry;
    r.r[1] = (int) private_word;

    _kernel_swi(OS_RemoveTickerEvent, &r, &r);
}

/*****************************************************************************/

static char *strdup(char *str)
{
    char *new = malloc(str == NULL ? 1 : (strlen(str) + 1) );

    if (new != NULL)
    {
        if (str == NULL)
        {
            *new = 0;
        }
        else
        {
            strcpy(new, str);
        }
    }

    return new;
}


/*****************************************************************************/

static void add_to_list(PSESS *listp, PSESS sess)
{
    sess->prev = NULL;
    sess->next = *listp;
    if (sess->next != NULL)
    {
        sess->next->prev = sess;
    }
    *listp = sess;
}




/*****************************************************************************/

static void rem_from_list(PSESS *listp, PSESS sess)
{

}




/****************************************************************/
/*                                                              */
/* Ensure that the counts of active sockets and the fdsets are  */
/* all correct. Used when we are not certain that we can get    */
/* things correct by applying deltas.                           */
/*                                                              */
/****************************************************************/

static void recalculate_counts(void)
{

}


/*****************************************************************************/


static _kernel_oserror *check_session_valid(PSESS sess)
{
    if (sess == NULL)
    {
        return make_error(no session);
    }
    else if (sess->magic == MAGIC
    {
        return NULL;
    }
    else if (sess->magic == ~ MAGIC)
    {
        return make_error(session already closed);
    }
    else
    {
        return make_error(not a valid session);
    }
}


/*****************************************************************************/




/***************************************************************/
/*                                                             */
/* Receive from a socket and queue the data. When the socket   */
/* is closed, the closed flag in the queue is set.             */
/*                                                             */
/***************************************************************/

static int recv_till_block(PSESS sess, int sock)
{
    while (1)
    {
        const int rc = recv(sock, databuf, sizeof(databuf), 0);
    
        if (rc < 0)
        {
            if (errno == EWOULDBLOCK)
            {
                return GROUP_OKAY;
            }
            else
            {
                last_status = errno;
                return GROUP_SOCKET;
            }
        }
        else if (rc == 0)
        {
            sess->reading = FALSE;
            readings -= 1;
            sess->queue.closed = TRUE;
            return GROUP_OKAY;
        }
        else
        {
            if ( ! queue_add(&sess->queue, databuf, rc) )
            {
                return GROUP_MEMORY;
            }
        }
    }
}

/******************************************************/
/*                                                    */
/* Read a line from the session's queue into databuf. */
/* A line on input is either CRLF or LF terminated.   */
/* The line is null terminated when returned. The LF  */
/* is absorbed. Any present CR is also absorbed.      */
/* Returns:                                           */
/*                                                    */
/* Successful      GROUP_OKAY                         */
/* None present    GROUP_BLOCK                        */
/* Other error     GROUP_SOCKET                       */
/*                                                    */
/******************************************************/

static int get_a_line(PSESS sess)
{
    const int code = queue_search(&sess->queue, LF, FALSE);

    if (code == -1)
        return sess->queue.closed ? GROUP_SOCKET : GROUP_BLOCK;

    if ( code > sizeof(databuf) )
        return GROUP_SOCKET;

    if ( ! queue_remove(&sess->queue, databuf, code) )
        return GROUP_SOCKET;

    if (code > 2)
    {
        databuf[ databuf[code - 1] == CR ? code - 1 : code ] = 0;
    }
    else
    {
        databuf[ code - 1] = 0;
    }
    
    return GROUP_OKAY;
}

/*******************************************************/
/*                                                     */
/* Advance as far as possible in seeking the end of    */
/* a multiline response. Return GROUP_BLOCK when the   */
/* end has not been received, the initial status       */
/* code when the end has been received, and any other  */
/* error codes as they occur.                          */
/*                                                     */
/*******************************************************/

static int do_multiline_response(PSESS sess)
{
    int code;
    char dig1, dig2, dig3, dig4;
    BOOL invalid;

    while (1)
    {
        if ( !sess->queue.closed )
        {
            code = recv_till_block(sess, sess->sock);

            if (code != GROUP_OKAY)
                return code;
        }

        code = get_a_line(sess);

        if (code == GROUP_BLOCK && sess->queue.closed)
            return GROUP_SOCKET;

        if (code != GROUP_OKAY && code != GROUP_BLOCK)
            return code;

        if (strlen(databuf) < 4)
            continue;

        dig1 = databuf[0];
        dig2 = databuf[1];
        dig3 = databuf[2];
        dig4 = databuf[3];

        invalid = !isdigit(dig1) || !isdigit(dig2) || !isdigit(dig3) 
                       || (dig4 != ' ' && dig4 != '-');

        invalid |= dig1 != sess->resp1 || dig2 != sess->resp2 || dig3 != sess->resp3;

        if (invalid)
            continue;

        if (dig4 == ' ')
        {
            last_status = dig1 * 100 + dig2 * 10 + dig3;
            sess->resp4 = ' ';
            return dig1;
        }
    }

    return GROUP_SOCKET;            /* NEVER REACHED */
}


/*****************************************************************/
/*                                                               */
/* Return the next status code to the process. The code is       */
/* currently the first digit only, giving the broad category.    */
/* The last_status variable is set to the full value when        */
/* available. We have some extended groups as well. Group 0      */
/* indicates no progress can be made yet. Group 6 is a memory    */
/* error, Group 7 a socket error and Group 8 a local file        */
/* error. Group 9 is not used (yet). Multi-line responses are    */
/* absorbed.                                                     */
/*                                                               */
/*****************************************************************/

static int next_status(PSESS sess)
{
    int code;
    char dig1, dig2, dig3, dig4;
    BOOL invalid;

    if (sess->resp4 == '-')
        return do_multiline_response(sess);

    code = recv_till_block(sess, sess->sock);

    if (code != GROUP_OKAY)
        return code;

    code = get_a_line(sess);

    if (code != CODE_OKAY)
        return code;

    if (strlen(databuf) < 4)
        return GROUP_SOCKET;

    dig1 = databuf[0];
    dig2 = databuf[1];
    dig3 = databuf[2];
    dig4 = databuf[3];

    invalid = !isdigit(dig1) || !isdigit(dig2) || !isdigit(dig3) 
                   || (dig4 != ' ' && dig4 != '-');

    if (invalid)
        return GROUP_SOCKET;

    sess->resp1 = dig1;
    sess->resp2 = dig2;
    sess->resp3 = dig3;
    sess->resp4 = dig4;

    if (dig4 == ' ')
    {
        last_status = dig1 * 100 + dig2 * 10 + dig3;
        return dig1;
    }

    return do_multiline_response(sess);
}



/***************************************************************************/
/*                                                                         */
/* Yeah, it's a messy set of constants. Each represents a node in a state  */
/* machine, indicating what action to perform next time this session has   */
/* a chance to run. These nodes aren't readily nameable.                   */
/*                                                                         */
/* Note that a sequence like                                               */
/*     sess->state = xx;                                                   */
/*     send_BLAH(sess);                                                    */
/* must be ordered like this so the send_BLAH can overwrite                */
/* the state if it fails. Swapping them around will cause                  */
/* errors to be ignored - not good!                                        */
/*                                                                         */
/*                                                                         */
/***************************************************************************/

static void progress_transfer(PSESS sess)
{
    switch (sess->state)
    {
        /* Section 1 - establish communication */

        case 0:     
            /* Starting point after connection made */
            /* Establish some state */

            sess->reading = TRUE;
            readings += 1;
            FD_SET(sess->sock, rd_set);
            sess->ftp_status = FTP_AUTHENTICATING;

            switch ( next_status(sess) )
            {
                case 0:         /* Indicates nothing to do yet */
                    sess->state = 9;
                    break;
                case 2:         /* General okay */
                    sess->state = 1;
                    send_USER(sess);
                    break;
                default:        /* Something wrong */
                    sess->state = 99;
                    break;
            }
            break;


        case 1:     /* The USER command has been sent */
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->state = 10;
                    more = TRUE;
                    break;
                case 3:         /* Require authentication */
                    sess->state = 2;
                    send_PASS(sess);
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        case 2:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->state = 10;
                    more = TRUE;
                    break;
                case 3:         /* Account required */
                    sess->state = 3;
                    send_ACCT(sess);
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        case 3:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->state = 10;
                    more = TRUE;
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        /* Section 2 - locate target directory */

        case 10:
            if ( (cp = strrchr(sess->leaf, '/')) == NULL )
            {
                sess->state = 20;
                more = TRUE;
                break;
            }

            sess->leaf = cp + 1;

            if (*sess->dir != '/')
            {
                sess->state = 12;
                more = TRUE;
            }
            else
            {
                sess->state = 11;
                send_CWD(sess, "/", 1);
            }
            break;

        case 9:
            switch ( next_status(sess) )
            {
                case 0:         /* Indicates nothing to do yet */
                    break;
                case 2:         /* General okay */
                    sess->state = 1;
                    send_USER(sess);
                    break;
                default:        /* Something wrong */
                    sess->state = 99;
                    break;
            }
            break;


        case 11:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->dir += 1;
                    sess->state = 12;
                    more = TRUE;
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        case 12:
            if (sess->dir == sess->leaf || (cp = strchr(sess->dir, '/')) == NULL )
            {
                sess->state = 20;
                more = TRUE;
            }
            else
            {
                sess->state = 13;
                send_CWD(sess, sess->dir, cp - sess->dir);
            }
            break;

        case 13:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->dir = strchr(sess->dir, '/') + 1;
                    sess->state = 12;
                    more = TRUE;
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        /* Section 3 - establish port details */


        case 20:
            sess->state = 21;
            send_TYPE(sess, 'I');
            break;

        case 21:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->state = 22;
                    more = TRUE;
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        case 22:        /* Catch! */
            sess->state = 23;
            send_PASV(sess);
            break;

        case 23:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->state = 30;       /* Support PASV command */
                    more = TRUE;
                    break;
                case 4:
                case 5:
                    sess->state = 40;       /* PASV not supported */
                    more = TRUE;
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        /* Perform transfer - PASV mode - server listens */

        case 30:
            decode_host_port(sess);
            sess->state = 31;
            send_RETR(sess, sess->leaf, strlen(sess->leaf));
            sess->conn_on = sess->datasock;
            sess->conn_addr = sess->dataaddr;
            sess->conn_state = 32;

            /* Get fd_set bit, etc, out of the way first */

            rem_reader(sess->sock);     /* Stop noting command connection */

            rc = connect(sess->conn_on, (struct sockaddr *) &sess->conn_addr, sizeof(struct sockaddr));

            if (rc < 0)
            {
                switch (errno)
                {
                case EISCONN:
                    add_reader(sess->datasock);     /* Start noting data connection */
                    sess->state = 32;
                    more = TRUE;
                    break;
                case EALREADY:
                case EINPROGRESS:
                    add_sess(sess);
                    break;
                default:
                    sess->rc = SOCKET_GROUP;
                    sess->state = 99;
                    break;
                }
            }
            else
            {
                add_reader(sess->datasock);
                sess->state = 32;
                more = TRUE;
            }
            break;

        /* Should not happen, but usable placeholder just in case */

        case 31:        
            break;

        /* Now perform the actual data transfer */

        case 32:
            rc = recv(sess->datasock, databuf, DBSIZE, 0);

            if (rc == 0)
            {
                rem_reader(sess->datasock);
                rc = soclose(sess->datasock);
                sess->datasock = -1;

                if (rc == 0)
                {
                    add_reader(sess->sock);
                    sess->state = 33;
                    more = TRUE;
                }
                else
                {
                    sess->state = 99;
                    sess->rc = SOCKET_GROUP;
                }
            }
            else if (rc == -1)
            {
                sess->state = 99;
                sess->rc = SOCKET_GROUP;
            }
            else if ( ro_fwrite(databuf, rc, 1, sess->ro_handle) != rc )
            {
                sess->state = 99;
                sess->rc = FILE_GROUP;
            }
            else    
            {
                sess->bytes_so_far += rc;
            }

            break;

        case 33:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->state = 34;
                    more = TRUE;
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        case 34:
            sess->state = 35;
            send_QUIT(sess);
            break;

        case 35:
            switch ( next_status(sess) )
            {
                case 0:
                    break;
                case 2:
                    sess->state = 36;
                    more = TRUE;
                    break;
                default: 
                    sess->state = 99;
                    break;
            }
            break;

        case 36:
            rem_reader(sess->sock);
            if ( soclose(sess->sock) == 0 )
            {
                sess->state = 37;
                more = TRUE;
            }
            else
            {
                sess->state = 99;
                sess->rc = SOCKET_GROUP;
            }
            sess->sock = -1;
            break;

        case 37:
            if ( ro_fclose(sess->ro_handle) >= 0 )
            {
                sess->state = 80;
            }
            else
            {
                sess->state = 99;
                sess->rc = FILE_GROUP;
            }
            sess->ro_handle = -1;
            break;

        /* Perform transfer - not PASV mode - we listen */

        case 40:
            break;



        /* Some form of error condition. We need to record the */
        /* error category and perform any necessary tidy up. */
        /* Given the range of places that can call here, the */
        /* tidyup has quite a bit of careful work to do. */

        case 99:



    }

}



/****************************************************/
/*                                                  */
/* The session may now progress to connection.      */
/* Any error must now be picked up through status   */
/* polling. The session is on the connecting list   */
/* on entry. Reposition as appropriate.             */
/*                                                  */
/****************************************************/

static void start_connecting(PSESS sess)
{
    int i,j,k,l;
    _kernel_oserror *ep;
    BOOL flag = FALSE;

    /* Open the sockets and file */

    sess->ftp_status = FTP_CONNECTING;

    sess->sock = socket(AF_INET, SOCK_STREAM, 0);
    sess->datasock = socket(AF_INET, SOCK_STREAM, 0);
    sess->ro_handle = ro_fopen(local_name, RO_OPEN_WRITE);

    if (sess->sock == -1 || sess->datasock == -1 || sess->ro_handle < 0)
    {
        rc = sess->ro_handle < 0 ? FILE_GROUP : SOCKET_GROUP;
        goto bad
    }

    sess->conn_on = sess->sock;
    sess->conn_addr = sess->addr;
    sess->conn_state = 0;

    sessions[sess->sock] = sess;
    sessions[sess->datasock] = sess;

    i = j = k = l = 1;

    if (socketioctl(sess->sock, FIONBIO, &i) == -1
    ||  socketioctl(sess->sock, FIOASYNC, &j) == -1
    ||  socketioctl(sess->datasock, FIONBIO, &k) == -1
    ||  socketioctl(sess->datasock, FIOASYNC, &l) == -1)
    {
        rc = SOCKET_GROUP;
        goto bad;
    }

    /*
     * Legal return values are:
     *	36	EINPROGRESS	The connection process has been started but no result as yet.
     *	22	EINVAL		The connection process failed, either due to a timeout or a rejection.
     *	37	EALREADY	The connection process is still going on and may yet finnish.
     *	56	EISCONN		The connection process succeded and we are now connected.
     */

    rc = connect(sess->conn_on, (struct sockaddr *) &(sess->conn_addr), sizeof(struct sockaddr));

    if (rc < 0)
    {
        switch (errno)
        {
        case EISCONN:
            flag = TRUE;
            break;
        case EALREADY:
        case EINPROGRESS:
            break;
        default: 
            rc = SOCKET_GROUP;
            goto bad;
            break;
        }
    }
    else
    {
        flag = TRUE;
    }

    if (flag)
    {
        rem_from_list(&connecting_list, sess);
        add_to_list(&active_list, sess);
        sess->state = sess->conn_state;
        sess->conn_on = -1;
        progress_transfer(sess);
    }

    return;

    /* In this case, we mark it as bad, although the */
    /* user must still poll to find this out */
bad:
    sess->ftp_status = FTP_FINISHED_BAD;
    sess->rc = rc;
    rem_from_list(&connecting_list, sess);
    add_to_list(&done_list, sess);
    tidy_up(sess);
}



/*****************************************************************************/



static void progress_transfers(void)
{
    static fd_set rd_local, wr_local, ex_local;
    static struct timeval tv;

    fd_set *rd_ptr, *wr_ptr;
    int rc, i, j;

    tv.tv_sec = 0;
    tv.tv_usec = 0;

    if (readings)
    {
        rd_ptr = &rd_local;
        rd_local = rd_set;
    }
    else
    {
        rd_ptr = NULL;
    }

    if (writings)
    {
        wr_ptr = &wr_local;
        wr_local = wr_set;
    }
    else
    {
        wr_ptr = NULL;
    }

    ex_local = ex_set;

    i = highest(readings, &rd_set);
    j = highest(writings, &wr_set);

    if (j > i)
    {
        i = j;
    }

    rc = select(i, rd_ptr, wr_ptr, &ex_local, &tv);

    if (rc == -1)
    {
        /* Who does this get attached to? Either it's transient, */
        /* in which case we ignore it, or it's permanent, in */
        /* which case we fault all outstanding transactions */

        /* just ignore for now XXXX @@@@ */

        select_errors += 1;
    }
    else
    {
        for (i = 0; i < FD_SETSIZE && rc > 0; i++)
        {
            /* Always give service if doing a multi-line */
            /* response - easier this way! Fix someday!  */

            BOOL more = FD_ISSET(i, &rd_local) 
                     || FD_ISSET(i, &wr_local) 
                     || FD_ISSET(i, &ex_local)
                     || sess->resp4 == '-';

            if ( more )
            {
                progress_transfer(session[i]);
                rc -= 1;
            }
        }
    }
}



/*****************************************************************************/

static void progress_connectings(void)
{
    PSESS sess = connecting_list;
    
    connecting_list = NULL;

    while (sess != NULL)
    {
        int rc = connect(sess->conn_on, (struct sockaddr *) &(sess->conn_addr), sizeof(struct sockaddr));
        BOOL connd = FALSE;
    
        if (rc < 0)
        {
            switch (errno)
            {
            case EISCONN:
                connd = TRUE;
                break;
    
            case EALREADY:
                break;
    
            default:
                sess->rc = SOCKET_GROUP;
                sess->ftp_status = FTP_FINISHED_BAD;
                add_to_list(&done_list, sess);
                tidy_up(sess);
                sess = NULL;
                break;
            }
        }
        else
        {
            connd = TRUE;
        }
 
        if ( connd == TRUE )
        {
            add_to_list(&active_list, sess);
            sess->state = sess->conn_state;
            sess->conn_on = -1;
            progress_transfer(sess);
        }
        else if (sess != NULL)
        {
            add_to_list(&connecting_list, sess);
        }
    }
}


/***********************************************************************/
/*                                                                     */
/* A pending connection is pending for one of the following reasons:   */
/*                                                                     */
/* a) Pended but now ready to progress                                 */
/* b) Another connection to destination already open                   */
/*                                                                     */
/***********************************************************************/

static void progress_pendings(void)
{
    PSESS list = pending_list;

    consider_pending = FALSE;
    pending_list = NULL;

    while (list != NULL)
    {
        PSESS sess = rem_from_list(&list, list);
        PSESS alist = active_list;    
        const unsigned long addr = sess->addr->sin_addr.s_addr;
        BOOL already = FALSE;

        while (alist != NULL)
        {
            if (alist->addr->sin_addr.s_addr == addr)
            {
                already = TRUE;
                break;
            }
        }

        if (! already)
        {
            add_to_list(&connecting_list, sess);
            start_connecting(sess);
        }
        else
        {
            add_to_list(&pending_list, sess);
        }
    }
}

/****************************************************************************/
/*                                                                          */
/* The callback handler is entered whenever either a ticker or an internet  */
/* event indicate that there might be further work to perform.              */
/*                                                                          */
/****************************************************************************/

extern RETURN_METHOD callback_handler(_kernel_swi_regs *regs, void *pw)
{
    ENTER_MUTEX

        callback_scheduled = FALSE;
        callback_active = TRUE;

    EXIT_MUTEX

    if (consider_pending)
    {
        progress_pendings();

        if (pending_list != NULL)
        {
            ensure_poll(PENDING_TIMER);
        }
    }

    if (connecting_list != NULL)
    {
        progress_connectings();

        if (connecting_list != NULL)
        {
            ensure_poll(CONNING_TIMER);
        }
    }

    if (active_list != NULL)
    {
        progress_transfers();

        if (active_list != NULL)
        {
            ensure_poll(XFERING_TIMER);
        }
    }

    callback_active = FALSE;

    return VIA_R14;
}

/*****************************************************************************/

static void schedule_callback(void)
{
    ENTER_MUTEX

        if ( ! callback_scheduled )
        {
            _kernel_swi_regs r;

            r.r[0] = (int) &callback_entry;
            r.r[1] = (int) private_word;

            if ( _kernel_swi(OS_AddCallBack, &r, &r) == NULL )
                callback_scheduled = TRUE;
        }

    EXIT_MUTEX
}


/*****************************************************************************/

static void callback_remove(void)
{
    ENTER_MUTEX

        if ( ! callback_scheduled )
        {
            _kernel_swi_regs r;

            r.r[0] = (int) &callback_entry;
            r.r[1] = (int) private_word;

            _kernel_swi(OS_RemoveCallBack, &r, &r);
            callback_scheduled = FALSE;
        }

    EXIT_MUTEX
}

/*****************************************************************************/

extern RETURN_METHOD inetevent_handler(_kernel_swi_regs *regs, void *pw)
{
    if (regs->r[0] == Internet_Event)
    {
        if ( FD_ISSET(regs->r[2], &rd_set))
        {
            schedule_callback();
        }
    }

    return VIA_R14;

    UNUSED(pw);
}

/*****************************************************************************/

extern RETURN_METHOD timer_handler( _kernel_swi_regs *r, void *pw )
{
    /* Make conditional on something */

    schedule_callback();

    return VIA_R14;
}


/*****************************************************************************/


/*************************************************************/
/*                                                           */
/* Free all memory associated with a session structure       */
/* and close any sockets or files that are open,             */
/* and then free the session structure. Check that pointers  */
/* are non-NULL as may be used when allocation partially     */
/* failed, etc.                                              */
/*                                                           */
/*************************************************************/

static void free_PSESS(PSESS sess)
{
    if (sess == NULL || sess->magic != MAGIC)
    {
        return;
    }

    sess->magic = ~MAGIC;

    if (sess->sock != -1)
        soclose(sess->sock);

    if (sess->datasock != -1)
        soclose(sess->datasock);

    if (sess->addr != NULL)
        free(sess->addr);

    if (sess->dataaddr != NULL)
        free(sess->dataaddr);

    if (sess->user_name != NULL)
        free(sess->user_name);

    if (sess->passwd != NULL)
        free(sess->passwd);

    if (sess->path != NULL)
        free(sess->path);

    if (sess->local_name != NULL)
        free(sess->local_name);

    if (sess->ro_handle != 0)
        ro_fclose(sess->ro_handle);

    free(sess);
}


/*****************************************************************/
/*                                                               */
/* Put the session into as stable a state as possible, closing   */
/* anything that looks 'open'. The result of the session has     */
/* been committed to by now.                                     */
/*                                                               */
/*****************************************************************/

static void tidy_up(PSESS sess)
{
    if (sess->ro_handle > 0)
    {
        ro_fclose(sess->ro_handle);
        sess->ro_handle = -1;
    }

    if (sess->sock >= 0)
    {
        (void) soclose(sess->sock);
        sess->sock = -1;
    }

    if (sess->datasock >= 0)
    {
        (void) soclose(sess->datasock);
        sess->datasock = -1;
    }

    while (queue_count(&sess->queue) != 0)
    {
        (void) queue_remove(&sess->queue, databuf, sizeof(databuf));
    }
}



/*******************************************************************/
/*                                                                 */
/*  Create a new session structure from the parameters supplied.   */
/*                                                                 */
/*******************************************************************/

static _kernel_oserror *allocate_SESS(ftp_open * args, PSESS *sessp)
{
    _kernel_oserror *ep;
    PSESS sess;
    char *lname;

    if ( (sess = calloc(1, sizeof(*sess))) == NULL)
    {
        GUARDED( make_error(MEMORY_GROUP) );
    }

    sess->sock = -1;
    sess->datasock = -1;
    sess->ro_handle = -1;

    lname = inp->local == NULL ? tmpnam() : inp->local;

    sess->addr = malloc(sizeof(*sess->addr));
    sess->dataaddr = malloc(sizeof(*sess->addr));
    sess->user_name = strdup(inp->user_name);
    sess->passwd = strdup(inp->passwd);
    sess->path = strdup(inp->path);
    sess->local_name = strdup(lname);

    if (sess->addr == NULL 
    || sess->dataaddr == NULL
    || sess->user_name == NULL 
    || sess->passwd == NULL 
    || sess->path == NULL 
    || sess->local_name == NULL)
    {
        GUARDED( make_error(MEMORY_GROUP) );
    }

    if (! queue_init(&sess->queue, 512) )       /* 512 bytes of queue */
    {
        GUARDED( make_error(MEMORY_GROUP) );
    }

    sess->magic = MAGIC;
    *sess->addr = *args->in->addr;
    sess->leaf = sess->dir = sess->path;
    *sessp = sess;

    return NULL;

bad:
    if (sess != NULL)
    {
        free_SESS(sess);
    }

    return ep;
}



/*****************************************************************************/





/*******************************************************/
/*                                                     */
/* SWI Interface: open a session                       */
/*                                                     */
/* Start the process of opening an FTP connection and  */
/* GETting a file. Progresss in the background. Return */
/* a session identifier by which this request can be   */
/* referred to later by the status and close SWIs.     */
/*                                                     */
/*******************************************************/

extern _kernel_oserror *do_swi_open(ftp_open * args)
{
    _kernel_oserror *ep;
    PSESS sess = NULL;

    GUARDED( allocate_SESS(args, &sess) );

    add_to_list(&pending_list, sess);
    consider_pending = TRUE;
    schedule_callback();

    args->out.session = sess;

    return NULL;

    /* Error return - free structure as failed to establish */

bad:
    if (sess != NULL)
    {
        free_PSESS(sess);
    }

    return ep;
}

/***********************************************/
/*                                             */
/* SWI Interface: return session status        */
/*                                             */
/* Check the status of a previous request.     */
/* This does not ever lead to a request being  */
/* closed.                                     */
/*                                             */
/***********************************************/

extern _kernel_oserror *do_swi_status(ftp_status * args)
{
    _kernel_oserror *ep;
    PSESS sess = args->in.session;

    GUARDED( check_session_valid(sess) );

    args->out.status = sess->ftp_status;
    args->data_so_far = sess->bytes_so_far;
    args->local_name = sess->local_name;
    args->ro_handle = sess->ro_handle;

    return NULL;

bad:
    return ep;
}

/***********************************************************/
/*                                                         */
/* SWI Interface: close a session                          */
/*                                                         */
/* Indicate that the user has finished with a request. If  */
/* the request is still in progress, we need to close it.  */
/* Once the user has called here with a particular         */
/* request, that request cannot be referred to again.      */
/*                                                         */
/***********************************************************/

extern _kernel_oserror *do_swi_close(ftp_close * args)
{
    _kernel_oserror *ep = NULL;
    PSESS sess = args->in.session;

    GUARDED( check_session_valid(sess) );

    args->out.status = sess->ftp_status;
    args->out.rc = sess->rc;

    if (sess->ftp_status != FTP_FINISHED_OK && sess->ftp_status != FTP_FINISHED_BAD)
    {
        tidy_up(sess);
    }

    sess->magic = ~ MAGIC;      /* Which cannot be MAGIC */
    free_SESS(sess);

    return NULL;

bad:
    return ep;
}



/***********************/
/*                     */
/*                     */
/*   The SWI handler   */
/*                     */
/*                     */
/***********************/

extern _kernel_oserror *swi_handler(unsigned int swinum, _kernel_swi_regs *regs, void *pw)
{
    _kernel_oserror *ep = NULL;

    switch (swinum)
    {
        case 0:
            GUARDED( do_swi_open((ftp_open *) regs) );
            break;

        case 1:
            GUARDED( do_swi_status((ftp_status *) regs) );
            break;

        case 2:
            GUARDED( do_swi_close((ftp_close *) regs) );
            break;

        default:
            GUARDED( make_error(no such swi) );
            break;
    }

    return NULL;

    UNUSED(pw);

bad:
    return ep;
}

/*****************************************************************************/

extern void service_call_handler(register int sn, _kernel_swi_regs *r)
{
    return;
}




/*****************************************************************************/
/*
 * module_cli_handler:
 *
 * Module CLI handler: despatch any *commands that we provide. Note that the
 * string passed MUST NOT BE OVERWRITTEN.
 */

extern _kernel_oserror *cli_handler(char *arg_string, int arg_count, unsigned int cmd_no, void *pw)
{
    typedef _kernel_oserror *(*fn)(char *arg_string, int arg_count);

    static fn fns[] =
    {
        do_cli_status
    };

    if (cmd_no <= sizeof(fns) / sizeof(fn))
        return (*fns[cmd_no]) (arg_string, arg_count);
    else
    {
        debugstr("invalid cli command number\n");
        return makeerror(NOCARDUNIT, EBADARGS);
    }

    UNUSED(pw);
}



/*****************************************************************************/


static void quit(void)
{
    release_events();
    callback_remove();




    return;
}


/*****************************************************************************/



extern _kernel_oserror *initialise(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *ep = NULL;

    module_wsp = pw;

    GUARDED( claim_events() );
    recalculate_counts();
    atexit(quit);

    return NULL;

bad:
    return ep;

    UNUSED(pbase);
    UNUSED(cmd_tail);

}


