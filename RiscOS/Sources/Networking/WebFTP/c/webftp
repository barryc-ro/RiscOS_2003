
/* webftp.c - WebFTP core routines */
/*
 * (C) Copyright ANT Limited 1995. All rights reserved.
 *
 * Contacts:
 *
 * Postal:  ANT Ltd., PO BOX 300, Cambridge, CB1 2EG, UK.
 * Voice:   01223 567808
 * Fax:     01223 567801
 * Email:   Support@ant.co.uk
 *
 * Author:  Borris
 *
 * Music:   Skid Row - Slave to the Grind, Subhuman Race
 *          Slash's Snake Pit - It's five o'clock somewhere
 *
 * History: Derived (beyond recognition) from Nicko's http module,
 *          especially the non-blocking handling and the error numbers.
 *
 * 130695   Borris  Created
 * 290695   Borris  Much editting
 * 030795   Borris  Multi-line responses, bits and pieces
 * 070795   Borris  Make consistent, finish initial writing
 * 180795   Borris  Made compiler. Debugging (0.01)
 * 210795   Borris  Manages simple test program.
 * 250795   Borris  Better state machines, start of HTML page gen. bits
 * 270795   Borris  Basic operation working. Corruption bug lurks though
 * 310795   Borris  Correct SWI numbers, OS/2 directory recognition,
 *                  split public definitions out into seperate file,
 *                  along with pads.h, multline responses recorded in
 *                  file, file extent setting forced whenever changes,
 *                  final CWD of leaf_name if trying for a directory so
 *                  get any .msg comments. This is version 0.07.
 * 170895   Borris  Version 0.08. Changed to USING official SWI number.
 *                  Stopped using reopen() gratuitously. Spot file size
 *                  in 150 responses and pass this on in the status call.
 *                  Added flag for close swi to cause the file to be
 *                  deleted.
 * 180895   Borris  Removes "." and ".." if supplied as names for a
 *                  directory listing. Also 0.08.
 * 250895   Borris  Alter </a> for directory listing to not include all
 *                  the padding spaces. This is 0.09.
 * 070995   Borris  Start changes for 0.10. Only close xfer file when
 * 110995           the close swi is issued, so Fresco can do progressive
 *                  rendering. Use icontype: scheme for directory listings
 *                  so the right sort of icon can also be displayed. Alter
 *                  state machine so a connection is different from a
 *                  request - multiple requests can now reuse a single
 *                  connection. Cater for other end terminating login after
 *                  any length of pause, but always locally enforce a logoff
 *                  after N minutes. Tidy up status printing code to not
 *                  require large state name tables when compiled without
 *                  debugging - reduces final image size by a worthwhile
 *                  amount. Extra swi to close background sessions.
 *                  Checked disable IRQs for the minimum and use
 *                  own semaphore the rest of the time. Fixed lurking bug
 *                  if the acct field was required.
 * 200995   Borris  Introduced FTP_TRANSFERRING_FILE and
 *                  FTP_TRANSFERRING_DIRECTORY ftp status codes to help with
 *                  progressive rendering.
 * 041095   Borris  Added maxidle field for session open arguments.
 * 061095   Borris  This is version 0.11
 * 111095   Borris  Added code to do PWD at start for restoring position
 *                  on server re-use. Considered mandatory for reuse of
 *                  a server - prime failure example is ftp.ant.co.uk !!
 *                  When choosing a name, uses last dot, so handles
 *                  fred.tar.gz has .gz and not .tar.gz . Checked around
 *                  various servers. Looked carefully at OS/2 and NT
 *                  directory listings and put code in for them. ** Need to
 *                  look at presenting IP names rather than numbers **
 *                  Replaced my status codes with Nicko's standard status.h
 *                  header file, and added a few more.
 *                  Version 0.12X
 * 081295   Borris  Changed 0.12X into 0.13 as a release version. Minor
 * 	    	    tweaks to the way icontype: scheme is used.
 * 111295   Borris  Minor tweaks to make 0.14 (including callback threaded
 * 	    	    flag observations).
 * 230197   Peter   Fix "closes socket 0" bug of, er, 9 Jul 96.
 *
 */

#include "all.h"
#if REMOTE_DEBUG && DEBUG
#include <stdarg.h>
#endif
/*****************************************************************************/

volatile BOOL           callback_scheduled,
                        callback_threaded,
                        consider_pending,
                        worth_tidying_up,
                        worth_scheduling,
                        divert_lines,
                        want_cmd_followup = TRUE;

int                     last_status,
                        select_errors,
                        timer_calls,
                        event_calls,
                        callback_calls,
                        servers_to_quit;

PSESS                   pending_list,       /* Waiting server availability */
                        active_list,        /* Conversing with server */
                        done_list;          /* Completed, awaiting close swi */

PSERVER                 server_list;

_kernel_oserror         errblk;

char                    databuf[4096];

void *                  private_word;

#if REMOTE_DEBUG && DEBUG
debug_session *db=NULL;
#endif
/*****************************************************************************/

/* Strings for printing status */

#define string_new  "Pending initialisation"
#define string_connecting "Connecting"
#define string_authenticating  "Authenticating with server"
#define string_cwd  "Changing directory"
#define string_requesting  "Requesting item"
#define string_getting  "Transferring data"
#define string_quitting  "Closing connection"
#define string_okay_file  "Retrieved file successfully"
#define string_okay_dir  "Retrieved directory listing"
#define string_bad_connect  "Failed to contact server"
#define string_bad_request  "Server refused connection"

static struct { transfer_status status; char *msg; } status_table[] =
{
    {
        status_NEW,			/*     New, untouched connection state variable */
        string_new
    },

        /* Before we have a connection */
    {
        status_DNS,			/* HGF Waiting for the DNS lookup to complete */
        string_connecting
    },

    {
        status_AWAITING_CONNECTION,		/*   F Queued waiting for service (e.g. sequential FTPs) */
        string_connecting
    },

    {
        status_CONNECTING,			/* HGF Connect call made but not yet connected */
        string_connecting
    },

        /* Sorting out getting at data */
    {
        status_AUTHENTICATING,	/*   F Sending authication information and waiting for a reply */
        string_authenticating
    },

    {
        status_REUSE_CHECKING,              /*   F Seeing if can reuse an existing connection */
        string_authenticating
    },

    {
        status_DIRECTORY_CHANGING,		/*   F Getting to the right place to fetch the data */
        string_cwd
    },

    {
        status_NEGOTIATING,			/*   F Agreeing how we are going to get the data back */
        string_requesting
    },

    {
        status_REQUESTING,			/* HGF Requested the item */
        string_requesting
    },

        /* Getting data back */
    {
        status_WAITING,		/* HGF Waiting for some sort of reply */
        string_getting
    },

        /* Data all done */
    {
        status_FINISHING,		/*   F Tidying up after a transfer */
        string_quitting
    },

        /* OK to close */
    {
        status_COMPLETED_FILE,	 /* HGF File fetched */
        string_okay_file
    },

    {
        status_COMPLETED_DIR,		/*   F Directory fetched */
        string_okay_dir
    },

    {
        status_FAIL_CONNECT,		/* HGF Failed to get through to the remote host */
        string_bad_connect
    },

    {
        status_FAIL_REQUEST,		/* H F Request truned down by remote host */
        string_bad_request
    },

    {
        -1,                         /* end of table marker */
        string_bad_connect
    }
};

/*****************************************************************************/



#if DEBUG
extern void dump_sockaddr(struct sockaddr_in *addr, char *msg)
{
    if (addr == NULL)
    {
        dbg(("%s: NULL ptr\n", msg));
        printf("%s: unknown address\n", msg);
    }
    else
    {
        printf("%s: family %d, address %s port %d\n", msg,
            addr->sin_family, inet_ntoa(addr->sin_addr), ntohs(addr->sin_port) );
        if ( memcmp( "\0\0\0\0\0\0\0\0", &addr->sin_zero[0], 8) != 0 )
        {
            int *ip = (int*) &addr->sin_zero[0];
            printf("NOTE: mbz isn't! %x %x %x %x\n", ip[0], ip[1], ip[2], ip[3]);
        }
        printf("%s: %s\n", msg, inet_ntoa(addr->sin_addr));
    }
}
#endif

static void dump_sess(PSESS sess)
{
    int x;

    if (sess->magic != MAGIC)
    {
        printf("NB: Magic value %x is not correct magic value %x\n", sess->magic, MAGIC);
    }

    printf("Request for %s from %s\n",
        sess->origpath, MKHOSTNAME(sess->servaddr.sin_addr));

    for (x = 0; status_table[x].status != -1 && status_table[x].status != sess->ftp_status; x++)
        ;

    printf("Status of request: %s\n", status_table[x].msg);

    if (sess->bytes_so_far || sess->total_bytes)
    {
        printf("Transferred %d bytes", sess->bytes_so_far);
        if (sess->total_bytes)
            printf(" of %d bytes", sess->total_bytes);
        printf("\n");
    }

    printf("\n");

#if DEBUG
    dbg(("\nSession @ %p, prev %p, next %p, user %s\n",
        sess, sess->prev, sess->next, sess->user_name));

    dump_sockaddr(sess->server == NULL ? NULL : &sess->server->contaddr, "Control sockaddr");
    dump_sockaddr(&sess->dataaddr, "Data sockaddr");
    dump_sockaddr(sess->addr, "Current connection sockaddr");

    printf("Account %s\nName %s\nLocal name %s\n",
        sess->acct == NULL ? "*NULL*" : sess->acct, sess->origpath, sess->local_name);

    printf("File handle %d, control socket %d\ndata socket %d, active socket %d\n",
        sess->ro_handle, sess->server->contsock, sess->datasock, *sess->sock);

    printf("RC %s (%d), state  (%d), public status %s (%d)\n%d bytes so far, response %c%c%c%c\n",
        error_code_names[sess->rc],
        sess->rc,
        state_code_names[sess->state],
        sess->state,
/*        ftp_status_names[sess->ftp_status],*/
        sess->ftp_status,
        sess->bytes_so_far,
        sess->resp1,
        sess->resp2,
        sess->resp3,
        sess->resp4);
#endif
}

static void dump_sess_list(PSESS list, char *title)
{
    if (list == NULL)
    {
        printf("%s: no sessions listed\n", title);
        return;
    }

    printf("%s\n", title);

    while (list != NULL)
    {
        dump_sess(list);
        list = list->next;
    }
}


static void dump_active_servers(void)
{
    PSERVER serv = server_list;

    if (serv == NULL)
        return;

    printf("Servers currently connected to:\n\n");

    while (serv != NULL)
    {
        dbg(("Server %p, session %p, sock %d\n"
               "last %d, maxidle %d, uses %d, absorb %d, dont-reuse %d, sent quit %d\n",
                serv, serv->sess, serv->contsock,
                serv->last_used, serv->maxidle, serv->uses, serv->absorb_error, serv->dont_reuse, serv->sent_quit));

        printf("Address %s\n", MKHOSTNAME(serv->contaddr.sin_addr));

        if (serv->uses > 1)
            printf("Reuses count = %d\n", serv->uses - 1);
        if (serv->dont_reuse)
            printf("Connection flag as not re-usable\n");
        if (serv->sess != NULL)
        {
            printf("Retrieving %s\n", serv->sess->origpath);

            if (pending_list != NULL)
            {
                PSESS pend = pending_list;
                const unsigned long addr = serv->sess->servaddr.sin_addr.s_addr;
                for (; pend != NULL; pend = pend->next)
                    if (addr == pend->servaddr.sin_addr.s_addr)
                        printf("Waiting %s\n", pend->origpath);
            }
        }
        else
        {
            const int secs = (serv->maxidle - (MONONOW - serv->last_used)) / 100;
            const int secsmod = secs % 60;
            const int mins = secs / 60;

            printf("Connection will timeout in %d minute%s, %d second%s\n",
                mins, mins == 1 ? "" : "s", secsmod, secsmod == 1 ? "" : "s");
        }

        serv = serv->next;
        printf("\n");
    }

    printf("\n");
}



static void dump_state(void)
{
    printf("WebFTP active state. This code version dated " __DATE__ ".\n\n");
#if DEBUG
    printf("DEBUGGING VERSION\n");
#endif

    dump_active_servers();
    dump_sess_list(pending_list, "Pending transfers");
    dump_sess_list(active_list, "Active transfers");
    dump_sess_list(done_list, "Completed transfers");

    dbg((" callback_scheduled %d\n", callback_scheduled  ));
    dbg((" callback_threaded %d\n", callback_threaded  ));
    dbg((" consider_pending %d\n", consider_pending  ));
    dbg((" worth_tidying_up %d\n", worth_tidying_up  ));
    dbg((" worth_scheduling %d\n", worth_scheduling  ));
    dbg((" divert_lines %d\n", divert_lines  ));
    dbg((" want_cmd_followup %d\n", want_cmd_followup  ));
    dbg((" last_status %d\n", last_status  ));
    dbg((" select_errors %d\n", select_errors  ));
    dbg((" timer_calls %d\n", timer_calls  ));
    dbg((" event_calls %d\n", event_calls  ));
    dbg((" callback_calls %d\n", callback_calls  ));
    dbg((" servers_to_quit %d\n", servers_to_quit  ));
    dbg((" timenow %d\n", MONONOW ));

    if (select_errors != 0)
    {
        printf("CAUTION: %d unattributable background select() error%s",
            select_errors, select_errors == 1 ? "\n" : "s\n");
    }
}

/********************************************************************/
/*                                                                  */
/* Open a socket and make it async and non-blocking. Any error is   */
/* associated with the session supplied. Returns the socket opened  */
/* or minus one.                                                    */
/*                                                                  */
/********************************************************************/

extern int my_socket(PSESS sess)
{
    int rc, i = 1, j = 1;

    dbg2(("socket(%d, %d, %d)", AF_INET, SOCK_STREAM, 0));

    /* Getting zero back seems to fail in strange fashions. */
    /* Never been quite trusting of this, but a better reason */
    /* why my code has problems is desired. */

again:
    rc = socket(AF_INET, SOCK_STREAM, 0);

    if (rc == 0)
        goto again;

    if  (   rc < 0
        ||  socketioctl(rc, FIONBIO, &i) == -1
        ||  socketioctl(rc, FIOASYNC, &j) == -1
        )
    {
        if (rc >= 0)
            socketclose(rc);
        sess->state = state_error;
        sess->rc = GROUP_SOCKET;
        rc = -1;
    }
    dbg2((" = %d, errno %d\n", rc, errno));

    return rc;
}

/*****************************************************************************/

static int my_connect(PSESS sess, int sock, struct sockaddr_in *addr)
{
    int rc;

/*    dump_sockaddr( (struct sockaddr_in *) addr, "About to connect on this");*/
    dbg2(("connect(%d, %p, %d)", sock, addr, sizeof(*addr) ));

    rc = connect(sock, (struct sockaddr *) addr, sizeof(*addr) );

    dbg2((" = %d, errno %d\n", rc, errno));

    return rc;

    UNUSED(sess);
}

/*****************************************************************************/

static int my_accept(PSESS sess, int sock)
{
    int rc;

    dbg2(("accept(%d, 0, 0)", sock));
    rc = accept(sock, NULL, NULL );

    dbg2((" = %d, errno %d\n", rc, errno));

    return rc;

    UNUSED(sess);
}

/*****************************************************************************/

static int my_recv(PSESS sess, int sock, char *buf, int bytes)
{
    int rc;

    dbg2(("recv(%d, %p, %d, %d)", sock, buf, bytes, 0));

    rc = recv(sock, buf, bytes, 0);

    if (rc == -1 && errno != EWOULDBLOCK)
    {
        sess->state = state_error;
        sess->rc = GROUP_SOCKET;
    }

    dbg2((" = %d, errno %d\n", rc, errno));

    return rc;
}

/*****************************************************************************/


static int my_send(PSESS sess, int sock, char *buf, int bytes)
{
    int rc;

    dbg2(("send(%d, %p, %d, %d)", sock, buf, bytes, 0));

#if 1
    rc = send(sock, buf, bytes, 0);
#else
    /* force testing for now */
    rc = -1;
    errno = EWOULDBLOCK;
#endif

    dbg2((" = %d, errno %d\n", rc, errno));

    if (rc < 0)
    {
        if (errno != EWOULDBLOCK)
        {
            sess->state = state_error;
            sess->rc = GROUP_SOCKET;
            return GROUP_SOCKET;
        }
    }
    else
    {
        buf += rc;
        bytes -= rc;
    }

    if (bytes == 0)
        return GROUP_OKAY;

    sess->send_buffer = malloc(bytes);

    if (sess->send_buffer == NULL)
        return GROUP_MEMORY;

    sess->send_offs = 0;
    sess->send_left = bytes;
    memcpy(sess->send_buffer, buf, bytes);

    dbg2(("Queued data for blocking\n"));

    return GROUP_BLOCK;
}


static int push_send_buffer(PSESS sess)
{
    char *cp = sess->send_buffer;
    int offs = sess->send_offs;
    int bytes = sess->send_left;
    int rc;

    rc = send(*sess->sock, cp + offs, bytes, 0);

    dbg2(("delayed send gives %d %d\n", rc, errno));

    if (rc == -1)
    {
        if (errno == EWOULDBLOCK)
        {
            return GROUP_BLOCK;
        }
        else
        {
            sess->state = state_error;
            sess->rc = GROUP_SOCKET;
            return GROUP_SOCKET;
        }
    }

    if (rc != bytes)
    {
        sess->send_offs += rc;
        sess->send_left -= rc;
        return GROUP_BLOCK;
    }
    else
    {
        free(sess->send_buffer);
        sess->send_buffer = NULL;
        return GROUP_OKAY;
    }
}


/*****************************************************************************/

extern int my_socketclose(int *sock)
{
    int rc;

    dbg2(("socketclose(%d)", *sock));

    rc = socketclose(*sock);
    dbg2(("socket return code %d\n",rc));
    *sock = -1;

    dbg2((" = %d, errno %d\n", rc, errno));

    return rc;
}

/*****************************************************************************/

static int my_listen(PSESS sess, int sock, int backlog)
{
    int rc;

    dbg2(("listen(%d, %d)", sock, backlog));

    rc = listen(sock, backlog);

    if (rc < 0)
    {
        sess->state = state_error;
        sess->rc = GROUP_SOCKET;
    }

    dbg2((" = %d, errno %d\n", rc, errno));

    return rc;
}

/*****************************************************************************/

static int my_bind(PSESS sess, int sock, struct sockaddr *addr)
{
    int rc;

    dbg2(("bind(%d, %p, %d)", sock, addr, sizeof(*addr)));

    rc = bind(sock, addr, sizeof(*addr));

    if (rc < 0)
    {
        sess->state = state_error;
        sess->rc = GROUP_SOCKET;
    }

    dbg2((" = %d, errno %d\n", rc, errno));

    return rc;
}


/*****************************************************************************/

static int my_getsockname(PSESS sess, int sock, struct sockaddr *addr)
{
    int rc, x = sizeof(*addr);

    dbg2(("getsockname(%d, %p, %d)", sock, addr, x));

    rc = getsockname(sock, addr, &x);

    if (rc < 0 || x != sizeof(*addr))
    {
        sess->state = state_error;
        sess->rc = GROUP_SOCKET;
    }

    dbg2((" = %d, errno %d\n", rc, errno));
    /*dump_sockaddr( (struct sockaddr_in *) addr, "getsockname results");*/

    return rc;
}


/*****************************************************************************/

static void my_gethostid(PSESS sess)
{
    struct sockaddr s;
    int x = sizeof(s);

    if ( getsockname(sess->server->contsock, &s, &x) != 0 )
    {
        sess->state = state_error;
        sess->rc = GROUP_SOCKET;
        return;
    }

    sess->addr->sin_addr = ((struct sockaddr_in *)&s)->sin_addr;
}

/*************************************************************/
/*                                                           */
/* Free all memory associated with a session structure       */
/* and close any sockets or files that are open,             */
/* and then free the session structure. Check that pointers  */
/* are non-NULL as may be used when allocation partially     */
/* failed, etc.                                              */
/*                                                           */
/*************************************************************/

static void free_PSESS(PSESS sess)
{
    if (sess == NULL || sess->magic != MAGIC)
    {
        return;
    }

    if (sess->passwd != NULL)
    {
        memset(sess->passwd, 0, strlen(sess->passwd));  /* Zap password */
        free(sess->passwd);
    }

    sess->magic = ~MAGIC;

    if (sess->datasock != -1)
        my_socketclose(&sess->datasock);

    if (sess->user_name != NULL)
        free(sess->user_name);

    if (sess->origpath != NULL)
        free(sess->origpath);

    if (sess->acct != NULL)
        free(sess->acct);

    if (sess->origdir != NULL)
        free(sess->origdir);

    if (sess->leaf != NULL)
        free(sess->leaf);

    if (sess->local_name != NULL)
        free(sess->local_name);

    if (sess->send_buffer != NULL)
        free(sess->send_buffer);

    if (sess->ro_handle >= 0)
    {
      dbg(("(7) free session - close file"));
        ro_fclose(sess->ro_handle);
    }

    if (sess->extra != NULL)
        free(sess->extra);

#ifdef CSFS
    if (sess->error_msg != NULL)
        free(sess->error_msg);
#endif

    free(sess);
}

/*****************************************************************/
/*                                                               */
/* Put the session into as stable a state as possible, closing   */
/* anything that looks 'open'. The result of the session has     */
/* been committed to by now.                                     */
/*                                                               */
/*****************************************************************/

static void tidy_up(PSESS sess)
{
    int i;

    if (in_list(sess, &pending_list))
    {
        rem_from_list(&pending_list, sess);
    }
    else if (in_list(sess, &active_list))
    {
        rem_from_list(&active_list, sess);
    }
    else if (in_list(sess, &done_list))
    {
        rem_from_list(&done_list, sess);
    }

    add_to_list(&done_list, sess);

    /* Should now be on the done list precisely once */

    if (sess->ro_handle >= 0)
    {
        (void) ro_fclose(sess->ro_handle);
        sess->ro_handle = -1;
    }

    if (sess->datasock >= 0)
    {
        (void) my_socketclose(&sess->datasock);
        sess->datasock = -1;
    }

    for (i = 0; i < NUMQS; i++)
        queue_free(&sess->Q[i]);

    consider_pending = TRUE;

    if (sess->passwd != NULL)
    {
        memset(sess->passwd, 0, strlen(sess->passwd));
    }
}


/*****************************************************************************/

static void free_finished_with_sessions(void)
{
    PSESS list;

    ENTER_MUTEX

        list = done_list;
        done_list = NULL;

    EXIT_MUTEX

    while ( list != NULL )
    {
        PSESS sess = rem_from_list(&list, list);

        if (sess->closed)
        {
            free_PSESS(sess);
        }
        else
        {
            add_to_list(&done_list, sess);
        }
    }
}


/*****************************************************************/
/*                                                               */
/* Decode the IP address and port number from a PASV response.   */
/* The line received is currently in databuf, awaiting further   */
/* parsing. The information is entered into the addr field       */
/* of the session. In the event of a failure, a suitable GROUP_  */
/* code is returned. For success, a GROUP_OKAY is returned.      */
/* Blocking is not applicable.                                   */
/*                                                               */
/*****************************************************************/

static int decode_host_port(PSESS sess)
{
    char *cp;
    unsigned long a,b,c,d,e,f;
    unsigned long addr;
    unsigned short port;

    if (sess->resp1 != '2' && sess->resp2 != '2' && sess->resp3 != '7')
    {
        return GROUP_SOCKET;
    }

    cp = strchr(databuf, '(');

    if (cp == NULL)
    {
        return GROUP_SOCKET;
    }

    /* also cope with (a.b.c.d,ef) format */

    if ( sscanf(cp, "(%ld,%ld,%ld,%ld,%ld,%ld)", &a, &b, &c, &d, &e, &f) != 6 )
    {
        return GROUP_SOCKET;
    }

    if (a > 255 || b > 255 || c > 255 || d > 255 || e > 255 || f > 255)
    {
        return GROUP_SOCKET;
    }

    addr = (d << 24) | (c << 16) | (b << 8) | a;
    port = (unsigned short) ( (f << 8) | e );

    memset(sess->addr, 0, sizeof(*sess->addr) );

    sess->addr->sin_family = AF_INET;
    sess->addr->sin_port = port;
    sess->addr->sin_addr.s_addr = addr;

    return GROUP_OKAY;
}



/***************************************************************/
/*                                                             */
/* Receive from a socket and queue the data. When the socket   */
/* is closed, the closed flag in the queue is set.             */
/*                                                             */
/***************************************************************/

static int recv_till_block(PSESS sess, int sock, PQUEUE pq)
{
    while ( ! pq->closed )
    {
        const int rc = my_recv(sess, sock, databuf, sizeof(databuf));

        if (rc < 0)
        {
            if (errno == EWOULDBLOCK)
            {
                return GROUP_OKAY;
            }
            else
            {
                last_status = errno;
                dbg(("Error reading from socket in recv till block\n"));
                return GROUP_SOCKET;
            }
        }
        else if (rc == 0)
        {
            pq->closed = TRUE;
            dbg2(("recv_till_block found the socket closed (correctly)\n"));
            return GROUP_OKAY;
        }
        else
        {
            if ( ! queue_append(pq, databuf, rc) )
            {
                dbg(("No memory to add to queue\n"));
                return GROUP_MEMORY;
            }
        }
    }

    return GROUP_OKAY;
}

/******************************************************/
/*                                                    */
/* Read a line from the session's queue into databuf. */
/* A line on input is either CRLF or LF terminated.   */
/* The line is null terminated when returned. The LF  */
/* is absorbed. Any present CR is also absorbed.      */
/* Returns:                                           */
/*                                                    */
/* Successful      GROUP_OKAY                         */
/* None present    GROUP_BLOCK                        */
/* Other error     GROUP_SOCKET                       */
/*                                                    */
/******************************************************/

/* ls lines from unix boxes for LIST command can also */
/* be only CR terminated. F'in consistent at least.   */

extern int get_a_line(PSESS sess, PQUEUE pq)
{
    const int code1 = queue_search(pq, LF);
    const int code2 = queue_search(pq, CR);
    int code;

    if (code1 == -1 && code2 == -1)
    {
        return pq->closed ? GROUP_SOCKET : GROUP_BLOCK;
    }

    if (code2 == -1)
    {
        code = code1;
    }
    else if (code1 == -1)
    {
        code = code2;
    }
    else if (code1 == code2 + 1)
    {
        code = code1;
    }
    else
    {
        code = code2;
    }

    if ( code > sizeof(databuf) )
    {
        dbg(("line too long\n"));
        return GROUP_MEMORY;
    }

    if ( ! queue_remove(pq, databuf, code) )
    {
        dbg(("queue removal failed\n"));
        return GROUP_MEMORY;
    }

    if (code > 2)
    {
        databuf[ databuf[code - 2] == CR ? code - 2 : code - 1] = 0;
    }
    else
    {
        databuf[ code - 1 ] = 0;
    }

    dbg(("(7) RECV: %s\n", databuf));

    if (sess->diverted_lines != NULL)
    {
        (*sess->diverted_lines)(sess);
    }

    return GROUP_OKAY;
}

/*******************************************************/
/*                                                     */
/* Advance as far as possible in seeking the end of    */
/* a multiline response. Return GROUP_BLOCK when the   */
/* end has not been received, the initial status       */
/* code when the end has been received, and any other  */
/* error codes as they occur.                          */
/*                                                     */
/*******************************************************/

static int do_multiline_response(PSESS sess)
{
    int code;
    char dig1, dig2, dig3, dig4;
    BOOL invalid;

    dbg2(("(7) Progress multiline response\n"));

    while (1)
    {
        if ( !sess->Q[INPUTQ].closed )
        {
            code = recv_till_block(sess, *sess->sock, &sess->Q[INPUTQ]);

            if (code != GROUP_OKAY)
            {
                dbg(("recv_till_block failure in multi\n"));
                return code;
            }
        }

        code = get_a_line(sess, &sess->Q[INPUTQ]);

        if (code == GROUP_BLOCK && sess->Q[INPUTQ].closed)
        {
            dbg(("no more lines for multi response\n"));
            return GROUP_SOCKET;
        }

        if (code != GROUP_OKAY /* && code != GROUP_BLOCK */)
        {
            if (code != GROUP_BLOCK)
                dbg(("multi failure 1\n"));
            return code;
        }

        if ( ! queue_append(&sess->Q[MULTIQ], databuf, strlen(databuf))
        ||   ! queue_append(&sess->Q[MULTIQ], "\r\n", 2) )
        {
            dbg(("Failure writing multiline response into queue\n"));
            return sess->rc = GROUP_MEMORY;
        }

        if (strlen(databuf) < 4)
            continue;

        dig1 = databuf[0];
        dig2 = databuf[1];
        dig3 = databuf[2];
        dig4 = databuf[3];

        invalid = !isdigit(dig1) || !isdigit(dig2) || !isdigit(dig3)
                       || (dig4 != ' ' && dig4 != '-');

        invalid |= dig1 != sess->resp1 || dig2 != sess->resp2 || dig3 != sess->resp3;

        if (invalid)
            continue;

        if (dig4 == ' ')
        {
            last_status = (dig1 - '0') * 100 + (dig2 - '0') * 10 + (dig3- '0');
            sess->resp4 = ' ';
            return dig1 - '0';
        }
    }

    dbg(("never reached multi point\n"));

    return GROUP_SOCKET;            /* NEVER REACHED */
}

/*****************************************************************/
/*                                                               */
/* Return the next status code to the process. The code is       */
/* currently the first digit only, giving the broad category.    */
/* The last_status variable is set to the full value when        */
/* available. We have some extended groups as well. Group 0      */
/* indicates no progress can be made yet. Group 6 is a memory    */
/* error, Group 7 a socket error and Group 8 a local file        */
/* error. Group 9 is not used (yet). Multi-line responses are    */
/* absorbed.                                                     */
/*                                                               */
/*****************************************************************/

static int next_status_core(PSESS sess)
{
    int code;
    char dig1, dig2, dig3, dig4;
    BOOL invalid;

    /* Continuation of existing multiline response */

    if (sess->resp4 == '-')
        return do_multiline_response(sess);

    code = recv_till_block(sess, *sess->sock, &sess->Q[INPUTQ]);

    if (code != GROUP_OKAY)
    {
        dbg(("recv_till_block failure\n"));
        return code;
    }

    code = get_a_line(sess, &sess->Q[INPUTQ]);

    if (code != GROUP_OKAY)
    {
        if (code != GROUP_BLOCK)
            dbg(("get_a_line failure"));
        return code;
    }

    if (strlen(databuf) < 4)
    {
        dbg(("line too small\n"));
        return GROUP_SOCKET;
    }

    dig1 = databuf[0];
    dig2 = databuf[1];
    dig3 = databuf[2];
    dig4 = databuf[3];

    invalid = !isdigit(dig1) || !isdigit(dig2) || !isdigit(dig3)
                   || (dig4 != ' ' && dig4 != '-');

    if (invalid)
    {
        dbg(("bad format return code"));
        return GROUP_SOCKET;
    }

    sess->resp1 = dig1;
    sess->resp2 = dig2;
    sess->resp3 = dig3;
    sess->resp4 = dig4;

    /* Start of new multiline response */

    queue_drain(&sess->Q[MULTIQ]);

    if (dig1 == '4' || dig1 == '5' || dig4 == '-')
    {

        if ( ! queue_append(&sess->Q[MULTIQ], databuf, strlen(databuf))
        ||   ! queue_append(&sess->Q[MULTIQ], "\r\n", 2) )
        {
            dbg(("Failure writing multiline response into queue\n"));
            return sess->rc = GROUP_MEMORY;
        }
    }

    if (dig4 == ' ')
    {
        last_status = (dig1 - '0') * 100 + (dig2 - '0') * 10 + (dig3 - '0');
        return dig1 - '0';
    }

    return do_multiline_response(sess);
}

static int next_status(PSESS sess)
{
    int rc;

    if (sess->send_buffer)
    {
        switch ( push_send_buffer(sess) )
        {
            case GROUP_BLOCK:
                dbg2(("delayed send still waiting\n"));
                return GROUP_BLOCK;
                break;
            case GROUP_OKAY:
                dbg2(("delayed send finished\n"));
                break;
            default:
                dbg2(("delayed send failed\n"));
                return GROUP_SOCKET;
        }
    }

    rc = next_status_core(sess);

    dbg2(("Next Status is %d\n", rc));

    return rc;
}


/*****************************************************************************/

static void send_command(PSESS sess, char *cmd)
{
    const int rc = my_send(sess, *sess->sock, cmd, strlen(cmd));

    dbg(("(7) SEND: %s", cmd));

    switch (rc)
    {
        case GROUP_BLOCK:
        case GROUP_OKAY:
            if ( want_cmd_followup )
            {
                stack_push(sess, sess->state);
                if (sess->state != state_error)
                    sess->state = state_pop_okay;
            }
            break;
        default:
            sess->rc = rc;
            sess->state = state_error;
            break;
    }

    want_cmd_followup = TRUE;
}

/*****************************************************************************/

static void send_one_part(PSESS sess, char *part1)
{
    sprintf(databuf, "%s\r\n", part1);
    send_command(sess, databuf);
}

static void send_two_part(PSESS sess, char *part1, char *part2)
{
    sprintf(databuf, "%s %s\r\n", part1, part2);
    send_command(sess, databuf);
}

/*****************************************************************************/

static void send_LIST(PSESS sess)
{
    send_one_part(sess, "LIST");
}

/*****************************************************************************/

static void send_USER(PSESS sess)
{
    send_two_part(sess, "USER", sess->user_name);
}

/*****************************************************************************/

static void send_PASS(PSESS sess)
{
    send_two_part(sess, "PASS", sess->passwd);
}

/*****************************************************************************/

static void send_ACCT(PSESS sess)
{
    send_two_part(sess, "ACCT", sess->acct);
}

/*****************************************************************************/

static void send_CWD(PSESS sess, char *newdir, int len)
{
    const char saved = newdir[len];

    newdir[len] = 0;

    if (len == 0)
        send_one_part(sess, "CWD");
    else
        send_two_part(sess, "CWD", newdir);

    newdir[len] = saved;
}

/*****************************************************************************/

static void send_PWD(PSESS sess)
{
    send_one_part(sess, "PWD");
}

/*****************************************************************************/

static void send_TYPE(PSESS sess, char *type)
{
    send_two_part(sess, "TYPE", type);
}

/*****************************************************************************/

static void send_PASV(PSESS sess)
{
    send_one_part(sess, "PASV");
}

/*****************************************************************************/

static void send_RETR(PSESS sess)
{
    send_two_part(sess, "RETR", sess->leaf);
}

/*****************************************************************************/
#ifdef FTP_PUT
static void send_STOR(PSESS sess)
{
    send_two_part(sess, "STOR", sess->leaf);
}
#endif

/*****************************************************************************/

static void send_GENERIC_CMD(PSESS sess, char *cmd, char *arg1, char *arg2)
{
  if (arg1==NULL)
    send_one_part(sess, cmd);
  else
  {
    if (arg2==NULL)
      send_two_part(sess, cmd, arg1);
    else
    {
      if ((arg1[strlen(arg1)-1]=='/') || (arg2[0]=='/'))
        sprintf(databuf, "%s %s%s\r\n", cmd, arg1, arg2);
      else
        sprintf(databuf, "%s %s/%s\r\n", cmd, arg1, arg2);
      send_command(sess, databuf);
    }
  }
}

/*****************************************************************************/

static void send_QUIT(PSESS sess)
{
    send_one_part(sess, "QUIT");
}

/*****************************************************************************/

static void send_PORT(PSESS sess)
{
    const unsigned long addr = ntohl(sess->addr->sin_addr.s_addr);
    const unsigned short port = ntohs(sess->addr->sin_port);

    sprintf(databuf, "PORT %ld,%ld,%ld,%ld,%d,%d\r\n",
        addr >> 24,
        (addr >> 16) & 0xff,
        (addr >> 8) & 0xff,
        addr & 0xff,
        port >> 8,
        port & 0xff);

    send_command(sess, databuf);
}

/***********************************************************************/
/*                                                                     */
/* Each state name represents a node in a state machine, generally     */
/* indicating what action to perform next time this session has        */
/* a chance to run.                                                    */
/*                                                                     */
/* Note that a sequence like                                           */
/*                                                                     */
/*     sess->state = xx;                                               */
/*     send_BLAH(sess);                                                */
/*                                                                     */
/* must be ordered like this so the send_BLAH can overwrite            */
/* the state if it fails. Swapping them around will cause              */
/* errors to be ignored - not good!                                    */
/*                                                                     */
/*                                                                     */
/***********************************************************************/


static void progress_transfer(PSESS sess)
{
    BOOL more;
    int rc;
    char *cp;
    int xfersleft = 5;
    static last_state = 0;

    do
    {
        more = FALSE;

#if 1
        if (sess->state!=last_state)
        {
          dbg(("(7) STATE %s (%2d)\n", sess->state >= 0 &&
            sess->state < state_last_state ? state_code_names[sess->state] : "Bad state", sess->state));
          last_state = sess->state;
        }
/*         printf("%s",MKHOSTNAME(sess->servaddr.sin_addr)); */
/*         printf("<<<\n"); */
#endif

        switch (sess->state)
        {
            /* Section 1 - establish communication */

            case state_initialise:
                {
                    PSERVER server = find_existing_server(sess);

                    if (server != NULL)
                    {
                        if (  strcmp(sess->user_name, server->user_name) != 0
                           || strcmp(sess->passwd, server->passwd) != 0
                           || strcmp(sess->acct, server->acct ) != 0)
                        {
                            dbg(("(6) Rejecting found server due to name, passwd or account differences\n"));
                            server->dont_reuse = TRUE;
                            servers_to_quit += 1;
                            server = NULL;
                        }
                        else
                        {
                            sess->state = state_check_existing_server;
                            ENTER_MUTEX
                                join_server_session(server, sess);
                                sess->sock = &server->contsock;
                            EXIT_MUTEX
                            /*cli_handler(NULL, 0, 0, NULL);*/
                        }
                    }

                    if (server == NULL)
                    {
                        dbg(("(6) Requesting a new server as none found is suitable\n"));
                        sess->state = state_no_existing_server;
                    }

                    more = TRUE;
                }
                break;


            case state_check_existing_server:
                sess->diverted_lines = NULL;
                sess->ftp_status = status_REUSE_CHECKING;
                want_cmd_followup = FALSE;
                sess->state = state_check_sent_cwd;
                send_CWD(sess, sess->server->login_pwd, strlen(sess->server->login_pwd) );
                break;


            case state_check_sent_cwd:
                switch (next_status(sess))
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_ready_to_go;
                        sess->datasock = my_socket(sess);

                        if (sess->state == state_error)
                            break;

                        sess->sock = &sess->server->contsock;
                        sess->addr = &sess->server->contaddr;

/*                         if (sess->ro_handle < 0)
                        {
                            sess->rc = GROUP_FILE;
                            sess->state = state_error;
                            break;
                        }
 */
                        more = TRUE;
                        break;
                    default:
                        /* Might actually be able to continue but deem */
                        /* it simpler not to try. */
                        servers_to_quit += 1;
                        dbg(("(6) Quitting server as CWD failed\n"));
                        disconnect_server(sess, FALSE);
                        sess->state = state_no_existing_server;
                        more = TRUE;
                        break;
                }
                break;


            case state_no_existing_server:
                {
                    PSERVER server;

                    if (sess->created_server)
                    {
                        sess->state = state_error;
                        sess->rc = GROUP_MEMORY;
                        break;
                    }

                    if ( (server = calloc(1, sizeof(SERVER))) == NULL)
                    {
                        sess->state = state_error;
                        sess->rc = GROUP_MEMORY;
                        break;
                    }

                    sess->created_server = TRUE;
                    server->contsock  = -1;
                    server->user_name = strdup(sess->user_name);
                    server->passwd    = strdup(sess->passwd   );
                    server->acct      = strdup(sess->acct     );

                    if (server->user_name == NULL || server->passwd == NULL || server->acct == NULL)
                    {
                        dbg(("(6) Server failed to allocate some memory\n"));
                        free_server(server);
                        sess->state = state_error;
                        sess->rc = GROUP_MEMORY;
                        break;
                    }

                    server->contaddr = sess->servaddr;
                    server->contsock = my_socket(sess);

                    if (server->contsock < 0)
                    {
                        dbg(("(6) Server failed to allocate the control socket\n"));
                        free_server(server);
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                    }

                    sess->state = state_initialise_new_server;
                    ENTER_MUTEX
                        join_server_session(server, sess);
                        server->next = server_list;
                        if (server->next != NULL)
                            server->next->prev = server;
                        server_list = server;
                    EXIT_MUTEX
                    break;
                }


            case state_initialise_new_server:
                sess->ftp_status = status_CONNECTING;
                sess->diverted_lines = NULL;
                dbg2(("allocating new data sock\n"));
                sess->datasock = my_socket(sess);

                if (sess->state == state_error)
                    break;

                sess->sock = &sess->server->contsock;
                sess->addr = &sess->server->contaddr;

/*                 if (sess->ro_handle < 0)
                {
                    sess->rc = GROUP_FILE;
                    sess->state = state_error;
                    break;
                }
 */
                sess->state = state_subr_connect;
                stack_push(sess, state_opened_control_socket);
                more = TRUE;
                break;


            case state_opened_control_socket:
                sess->ftp_status = status_AUTHENTICATING;
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:         /* Indicates nothing to do yet */
                        break;
                    case GROUP_OKAY:         /* General okay */
                        sess->state = state_auth_sent_user;
                        want_cmd_followup = FALSE;
                        send_USER(sess);
                        break;
                    case CODE_1YZ:
                    case CODE_3YZ:
                    case CODE_4YZ:
                    case CODE_5YZ:
                        sess->state = state_diagnostics;
                        more = TRUE;
                        break;
                    default:        /* Something wrong */
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;


            case state_auth_sent_user:     /* The USER command has been sent */
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_ready_to_go;
                        more = TRUE;
                        break;
                    case CODE_3YZ:         /* Require authentication */
                        sess->state = state_auth_sent_pass;
                        want_cmd_followup = FALSE;
                        send_PASS(sess);
                        break;
                    case CODE_1YZ:
                    case CODE_4YZ:
                    case CODE_5YZ:
                        sess->state = state_diagnostics;
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;


            case state_auth_sent_pass:
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_ready_to_go;
                        more = TRUE;
                        break;
                    case CODE_3YZ:         /* Account required */
                        sess->state = state_ready_to_go;
                        send_ACCT(sess);
                        break;
                    case CODE_1YZ:
                    case CODE_4YZ:
                    case CODE_5YZ:
                    	sess->rc = status_FAIL_PASSWORD;    /* close enough */
                        sess->state = state_diagnostics;
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;


            /* Section 2 - locate target directory */

            case state_ready_to_go:
                if (sess->server->login_pwd != NULL)
                {
                    sess->state = state_directory_change;
                    more = TRUE;
                    break;
                }
                want_cmd_followup = FALSE;
                sess->state = state_sent_pwd;
                send_PWD(sess);
                break;

            case state_sent_pwd:
                switch (next_status(sess))
                {
                    case GROUP_BLOCK:
                        break;
                    case CODE_2YZ:
                        if (sess->resp2 == '5' && sess->resp3 == '7')
                            extract_pwd(sess);
                        else
                            sess->server->dont_reuse = TRUE;
                        sess->state = state_directory_change;
                        more = TRUE;
                        break;
                    case CODE_4YZ:
                        sess->rc = CODE_4YZ;
                        sess->state = state_error;
                        break;
                    case CODE_5YZ:
                        sess->state = state_directory_change;
                        sess->server->dont_reuse = TRUE;
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;

            case state_directory_change:
                if ( *sess->dir == 0 )
                {
                    switch (sess->ftp_cmd)
                    {
                      case FTP_CMD_GET : case FTP_CMD_PUT :
                        sess->state = state_start_negotiating;
                        break;
                      case FTP_CMD_RENAME :
                        sess->state = state_sent_rename_from;
                        want_cmd_followup = FALSE;
                        send_GENERIC_CMD(sess,"RNFR",sess->leaf,NULL);
                        break;
                      default :
                        sess->ftp_status = status_SENDING_GENERIC_COMMAND;
                        sess->state = state_sent_generic_command;
                        want_cmd_followup = FALSE;
                        switch (sess->ftp_cmd)
                        {
                          case FTP_CMD_DELETE :
                            send_GENERIC_CMD(sess,"DELE",sess->leaf,NULL);
                            break;
                          case FTP_CMD_RMDIR :
                            send_GENERIC_CMD(sess,"RMD",sess->leaf,NULL);
                            break;
                          case FTP_CMD_MKDIR :
                            send_GENERIC_CMD(sess,"MKD",sess->leaf,NULL);
                            break;
                        }
                        break;
                    }
                    more = TRUE;
                    break;
                }

                sess->ftp_status = status_DIRECTORY_CHANGING;

                if (*sess->dir == '/')
                {
                    sess->dir += 1;
                }
                more = TRUE;
                sess->state = state_send_directory;
                break;

            case state_send_directory:
                if ( *sess->dir == 0 )
                {
                    switch (sess->ftp_cmd)
                    {
                      case FTP_CMD_GET : case FTP_CMD_PUT :
                        sess->state = state_start_negotiating;
                        break;
                      case FTP_CMD_RENAME :
                        sess->state = state_sent_rename_from;
                        want_cmd_followup = FALSE;
                        send_GENERIC_CMD(sess,"RNFR",sess->leaf,NULL);
                        break;
                      default :
                        sess->ftp_status = status_SENDING_GENERIC_COMMAND;
                        sess->state = state_sent_generic_command;
                        want_cmd_followup = FALSE;
                        switch (sess->ftp_cmd)
                        {
                          case FTP_CMD_DELETE :
                            send_GENERIC_CMD(sess,"DELE",sess->leaf,NULL);
                            break;
                          case FTP_CMD_RMDIR :
                            send_GENERIC_CMD(sess,"RMD",sess->leaf,NULL);
                            break;
                          case FTP_CMD_MKDIR :
                            send_GENERIC_CMD(sess,"MKD",sess->leaf,NULL);
                            break;
                        }
                        break;
                    }
                    more = TRUE;
                    break;
                }
                else
                {
                    sess->state = state_sent_cwd;
                    want_cmd_followup = FALSE;
                    cp = strchr(sess->dir, DIRSEP);
                    send_CWD(sess, sess->dir, cp == NULL ? strlen(sess->dir) : cp - sess->dir);
                }
                break;

            case state_sent_cwd:
                switch (next_status(sess))
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_sent_cwd_post;
                        more = TRUE;
                        break;
                    case CODE_5YZ:
                        if (sess->resp2 == '5' && sess->resp3 == '0')
                        {
                            sess->server->absorb_error = TRUE;
                        }
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;

            case state_sent_cwd_post:
                cp = strchr(sess->dir, DIRSEP);
                sess->dir = cp == NULL ? sess->dir + strlen(sess->dir) : cp + 1;
                sess->state = state_send_directory;
                more = TRUE;
                break;

            /* Section 3 - establish port details */

            case state_start_negotiating:
                sess->ftp_status = status_NEGOTIATING;
                sess->file_failed = FALSE;
                if (*sess->leaf == 0)
                {
                    sess->state = state_is_it_a_directory;
                    more = TRUE;
                }
                else
                {
#ifdef FTP_PUT
                    switch (sess->ftp_cmd)
                    {
                      case FTP_CMD_PUT :
                        sess->retrieve_action = send_STOR;
                        break;
		      case FTP_CMD_GET :
                        sess->retrieve_action = send_RETR;
                        break;
                    }
#else
                    sess->retrieve_action = send_RETR;
#endif
                    sess->state = state_sent_type;
                    send_TYPE(sess, "I");
                }
                break;

            case state_sent_generic_command :
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_done_transfer2;
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;

            case state_sent_rename_from :
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_POSITIVE_INTERMEDIATE:
                        sess->state = state_sent_rename_to;
                        want_cmd_followup = FALSE;

                        send_GENERIC_CMD(sess,"RNTO",sess->server->login_pwd,sess->extra);
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;

            case state_sent_rename_to :
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_done_transfer2;
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;

            /* Abort the file transfer operations and try for a directory */


            case state_is_it_a_directory_pre:
                if (sess->file_failed)
                {
                    dbg(("Seem to want to loop getting directory - forcing error\n"));
                    sess->state = state_error;
                    sess->rc = GROUP_SOCKET;
                    break;
                }

                my_socketclose(&sess->datasock);
                if (sess->state == state_error)
                    break;

                sess->datasock = my_socket(sess);
                if (sess->state == state_error)
                    break;

                sess->addr = &sess->server->contaddr;
                sess->sock = &sess->server->contsock;

                sess->state = state_is_it_a_directory;
                if (*sess->leaf != 0)
                {
                    send_CWD(sess, sess->leaf, strlen(sess->leaf));
                }
                else
                {
                    more = TRUE;
                }
                break;

            case state_is_it_a_directory:
                sess->file_failed = TRUE;
#ifdef CSFS
                if (sess->flags & webftp_open_NotHTML)
                  csfs_directory_header(sess);
                else
                  do_ftpdir_header(sess);
#else
                do_ftpdir_header(sess);
#endif
                if (sess->state == state_error)
                {
                    dbg(("Error writing header\n"));
                    break;
                }
                sess->retrieve_action = send_LIST;
                sess->diverted_lines = ftp_dir_spotter;
                sess->state = state_sent_type;
                send_TYPE(sess, "A");
                break;



            case state_sent_type:
#if 1	    	/* production */
                sess->state = state_sent_pasv;
                want_cmd_followup = FALSE;
                send_PASV(sess);
#else           /* testing only */
                sess->state = state_pasv_not_supported;
                more = TRUE;
#endif
                break;

            case state_sent_pasv:
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_pasv_supported;
                        more = TRUE;
                        break;
                    case CODE_4YZ:
                    case CODE_5YZ:
                        sess->state = state_pasv_not_supported;
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;

            /* Perform transfer - PASV mode - server listens */

            case state_pasv_supported:
                sess->addr = &sess->dataaddr;
                switch ( decode_host_port(sess) )
                {
                    case GROUP_OKAY:
                        sess->state = state_pasv_connect1;
                        want_cmd_followup = FALSE;
                        (*sess->retrieve_action) (sess);
                        more = TRUE;
                        break;
                    default:
                        sess->addr = &sess->server->contaddr;
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                        break;
                }
                break;

            case state_pasv_connect1:
                sess->sock = &sess->datasock;
                sess->state = state_subr_connect;
                stack_push(sess, state_pasv_connect2);
                more = TRUE;
                break;

            case state_pasv_connect2:
                sess->sock = &sess->server->contsock;
                sess->state = state_pop_prelim;
                stack_push(sess, state_pasv_connect3);
                more = TRUE;
                break;

            case state_pasv_connect3:
                sess->sock = &sess->datasock;
                sess->state = state_data_transfer;
                more = TRUE;
                break;

            /* Perform transfer - not PASV mode - we listen */

            case state_pasv_not_supported:
                sess->addr = &sess->dataaddr;
                sess->sock = &sess->datasock;
                sess->state = state_subr_ready_for_accept;
                stack_push(sess, state_no_pasv1);
                more = TRUE;
                break;

            case state_no_pasv1:
                sess->sock = &sess->server->contsock;
                sess->state = state_no_pasv2;
                send_PORT(sess);
                break;

            case state_no_pasv2:
                sess->state = state_no_pasv2a;
                want_cmd_followup = FALSE;
                more = TRUE;
                (*sess->retrieve_action) (sess);
                break;

            case state_no_pasv2a:
                sess->state = state_pop_prelim;
                stack_push(sess, state_no_pasv3);
                more = TRUE;
                break;

            case state_no_pasv3:
                sess->sock = &sess->datasock;
                sess->state = state_subr_do_accept;
                stack_push(sess, state_data_transfer);
                more = TRUE;
                break;

            /* Now perform the actual data transfer */

            case state_data_transfer:
#ifdef FTP_PUT
                sess->state = (sess->ftp_cmd==FTP_CMD_PUT)?state_data_transferPUT:state_data_transfer1;
#else
                sess->state = state_data_transfer1;
#endif
                if (sess->file_failed)
                {
                    sess->ftp_status = status_GETTING_DIRECTORY;
                }
                else
                {
                    sess->bytes_so_far = 0;
#ifdef FTP_PUT
                    if (sess->ftp_cmd==FTP_CMD_PUT)
                    {
                      sess->ftp_status = status_PUTTING_BODY;
                    }
                    else
                    {
#endif
                      sess->ftp_status = status_GETTING_BODY;
                      dbg(("\nSetting output filesize back to zero\n\n"));
                      if (reopen_file(sess) != GROUP_OKAY)
                          break;
#ifdef FTP_PUT
                    }
#endif
                }
                more = TRUE;
                break;

            case state_data_transfer1:
                /* Otherwise very fast links cause it to never get out of this */
                /* loop until the transfer is fully completed. */

                if (xfersleft-- < 0)
                    break;

                rc = my_recv(sess, *sess->sock, databuf, sizeof(databuf));

                if (rc == 0)
                {
                    rc = my_socketclose(&sess->datasock);
                    sess->datasock = -1;
                    sess->diverted_lines = NULL;

                    if (rc == 0)
                    {
                        sess->sock = &sess->server->contsock;
                        sess->state = state_done_transfer;
                        more = TRUE;
                    }
                    else
                    {
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                    }
                    break;
                }

                if (rc == -1)
                {
                    if (errno != EWOULDBLOCK)
                    {
                        sess->diverted_lines = NULL;
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                    }
                    break;
                }

                if ( sess->file_failed )
                {
                    if ( ! queue_append(&sess->Q[DATAQ], databuf, rc) )
                    {
                        dbg(("failed to add to queue\n"));
                        sess->state = state_error;
                        sess->rc = GROUP_MEMORY;
                    }
                    else
                    {
                        while (1)
                        {
                            if ( recv_till_block(sess, *sess->sock, &sess->Q[DATAQ]) != GROUP_OKAY )
                                    break;

                            /* Use side effect of sending line to diverted line */
                            /* handler, so we can spot directory listings. This */
                            /* is how the code turned out!                      */

                            if ( get_a_line(sess, &sess->Q[DATAQ]) != GROUP_OKAY )
                                    break;
                        }
                        more = sess->Q[DATAQ].closed;
                    }

                    break;
                }

                if ( to_file(sess, databuf, rc) != GROUP_OKAY )
                {
                    dbg(("Error receiving data to file\n"));
                }
                else
                {
                    more = TRUE;
                }
                break;

#ifdef FTP_PUT
            case state_data_transferPUT:
	        if (sess->send_buffer)    /* We have data queued */
		{
		    switch ( push_send_buffer(sess) )
        	    {
            	      case GROUP_BLOCK:
                        dbg2(("delayed send still waiting\n"));
                        break;
            	      case GROUP_OKAY:
                        dbg2(("delayed send finished\n"));
                        break;
            	      default:
                        dbg2(("delayed send failed\n"));
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                    }
                }

	        if (sess->send_buffer)    /* We still have data queued */
	          break;

		if (sess->bytes_so_far<sess->total_bytes) /* Not finished */
		{
                  if (from_file(sess, databuf,sizeof(databuf), &rc)!=GROUP_OKAY)
                    dbg(("Error receiving data from file\n"));

  		  sess->bytes_so_far+=rc;
                  dbg2(("bytes read so far %d\n",sess->bytes_so_far));

   		  rc = my_send(sess, *sess->sock, databuf, rc);
                  if (rc == -1)
                  {
                      if (errno != EWOULDBLOCK) /* Blocked data is queued */
                      {
                          sess->diverted_lines = NULL;
                          sess->state = state_error;
                          sess->rc = GROUP_SOCKET;
                      }
                      break;
                  }
                }
                else
		{
		    dbg(("(7) transfer complete, closing socket\n"));
                    rc = my_socketclose(&sess->datasock);
                    sess->diverted_lines = NULL;

                    if (rc == 0)
                    {
                        sess->sock = &sess->server->contsock;
                        sess->state = state_done_transfer1;
                        more = TRUE;
                    }
                    else
                    {
                        sess->state = state_error;
                        sess->rc = GROUP_SOCKET;
                    }
                }
                break;
#endif

            case state_done_transfer:
                sess->state = state_done_transfer1;
                more = TRUE;
                if (sess->file_failed && !(sess->flags & webftp_open_NotHTML))
                    do_ftpdir_trailer(sess);
                break;

            case state_done_transfer1:
                switch ( next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = state_done_transfer2;
                        more = TRUE;
                        break;
                    default:
                        sess->state = state_error;
                        break;
                }
                break;


            case state_done_transfer2:
                sess->state = state_finished;
                more = TRUE;
                rem_from_list(&active_list, sess);
                add_to_list(&done_list, sess);
                switch (sess->ftp_cmd)
                {
                  case FTP_CMD_GET : case FTP_CMD_PUT :
                    sess->ftp_status = sess->file_failed ? status_COMPLETED_DIR : status_COMPLETED_FILE;
                    break;
                  default :
                    sess->ftp_status = status_COMPLETED_GENERIC_COMMAND;
                }

                dbg(("(6) Quitting server as finished with correctly\n"));
                disconnect_server(sess, TRUE);
                break;


            case state_subr_send_quit:
                sess->state = state_sent_quit;
                send_QUIT(sess);
                break;

            case state_subr_sent_quit:
                sess->state = state_wait_other_close;
                more = TRUE;
                break;

            case state_subr_wait_other_close:
                sess->rc = recv_till_block(sess, *sess->sock, &sess->Q[INPUTQ]);

                if ( sess->rc != GROUP_OKAY )
                {
                    sess->state = state_error;
                    break;
                }

                if ( sess->Q[INPUTQ].closed )
                {
                    sess->state = stack_pop(sess);
                    more = TRUE;
                }
                break;


            /* Subroutine state */
            /* Connect on the socket in sess->sock to the address in */
            /* sess->addr. Once complete, pop the stack for the next state. */

            case state_subr_connect:
                /*
                 * Legal return values are:
                 *	36	EINPROGRESS	The connection process has been started but no result as yet.
                 *	22	EINVAL		The connection process failed, either due to a timeout or a rejection.
                 *	37	EALREADY	The connection process is still going on and may yet finnish.
                 *	56	EISCONN		The connection process succeded and we are now connected.
                 */

                rc = my_connect(sess, *sess->sock, sess->addr);

                if (rc < 0)
                {
                    switch (errno)
                    {
                    case EISCONN:
                        more = TRUE;
                        break;
                    case EALREADY:
                    case EINPROGRESS:
                        break;
                    default:
                        sess->rc = GROUP_SOCKET;
                        sess->state = state_error;
                        break;
                    }
                }
                else
                {
                    more = TRUE;
                }

                if (more)
                {
                    sess->state = stack_pop(sess);
                }

                break;


            case state_subr_ready_for_accept:
                memset(sess->addr, 0, sizeof(*sess->addr));
                sess->addr->sin_family = AF_INET;
                sess->addr->sin_port = 0;                   /* Use whatever is convenient */
                my_gethostid(sess);

                if ( sess->state == state_error || my_bind(sess, *sess->sock, (struct sockaddr *) sess->addr) != 0 )
                {
                    sess->rc = GROUP_SOCKET;
                    sess->state = state_error;
                    break;
                }

                if ( my_getsockname(sess, *sess->sock, (struct sockaddr *) sess->addr) != 0 )
                {
                    sess->rc = GROUP_SOCKET;
                    sess->state = state_error;
                    break;
                }

                /* Backlog of 1 - only expect/want a single connection! */

                if ( my_listen(sess, *sess->sock, 1) != 0 )
                {
                    sess->rc = GROUP_SOCKET;
                    sess->state = state_error;
                    break;
                }

                sess->state = stack_pop(sess);
                more = TRUE;
                break;

            /* Issue the RETR command, wait a preliminary response */
            /* and pop the stack for the next state */

            case state_subr_send_retr:
                sess->state = state_pop_prelim;
                want_cmd_followup = FALSE;
                (*sess->retrieve_action) (sess);
                /*send_RETR(sess);*/
                break;


            /* Issue an accept call until it accepts */
            /* Then pop the next state off the stack */

            case state_subr_do_accept:
                rc = my_accept(sess, *sess->sock);
                if (rc == -1 && errno == EWOULDBLOCK)
                {
                    break;
                }
                else if (rc == -1)
                {
                    sess->state = state_error;
                    sess->rc = GROUP_SOCKET;
                    break;
                }
                else
                {
                    my_socketclose(sess->sock);
                    *sess->sock = rc;
                    if (sess->state != state_error)
                    {
                        sess->state = stack_pop(sess);
                        more = TRUE;
                    }
                }
                break;

            case state_pop_prelim:
                switch ( sess->rc = next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_POSITIVE_PRELIMINARY:
                        sess->state = stack_pop(sess);
                        try_to_extract_size(sess);  /* After in case of errors */
                        more = TRUE;
                        break;
                    case CODE_3YZ:
                    case CODE_4YZ:
                    case CODE_5YZ:
                        if (sess->resp1 == '5' && sess->resp2 == '5' && sess->resp3 == '0')
                        {
                            sess->state = state_is_it_a_directory_pre;
                            more = TRUE;
                        }
                        else
                        {
                            sess->state = state_diagnostics;
                            more = TRUE;
                        }
                        break;
                    default:
                        dbg2(("pop prelim failure"));
                        sess->state = state_error;
                        break;
                }
                break;



            case state_pop_okay:
                switch ( sess->rc = next_status(sess) )
                {
                    case GROUP_BLOCK:
                        break;
                    case GROUP_OKAY:
                        sess->state = stack_pop(sess);
                        more = TRUE;
                        break;
                    case CODE_1YZ:
                    case CODE_3YZ:
                    case CODE_4YZ:
                    case CODE_5YZ:
                        sess->state = state_diagnostics;
                        more = TRUE;
                        break;
                    default:
                        dbg2(("pop okay failure"));
                        sess->state = state_error;
                        break;
                }
                break;


            /* Terminal state for successful transfer operation */

            case state_finished:
                more = FALSE;           /* Prevent further processing */
                break;

            case state_diagnostics:
                dbg(("(5) Quitting server as enter state_diagnostics\n"));
                disconnect_server(sess, FALSE);
                if (sess->Q[MULTIQ].used_bytes)
                {
                    multi_to_file(sess);
                }
                tidy_up(sess);
                more = FALSE;
                sess->state = state_finished;
                sess->ftp_status = status_FAIL_REQUEST; /* but have a report why */
                break;


            /* Some form of error condition. We need to record the */
            /* error category and perform any necessary tidy up. */
            /* Given the range of places that can call here, the */
            /* tidyup has quite a bit of careful work to do. */

            case state_error:
                dbg(("(5) Quitting server as entered state_error\n"));
                disconnect_server(sess, FALSE);
                tidy_up(sess);
                more = FALSE;
                sess->state = state_finished;
                sess->ftp_status = status_FAIL_REQUEST;
                break;

            default:
                dbg(("(5) Unknown internal state %d\n", sess->state));
                sess->state = state_error;
                break;
        }
    } while (more || sess->state == state_error);


    return;
}


/*****************************************************************************/


static void progress_active(void)
{
    PSESS list;

    ENTER_MUTEX

        list = active_list;
        active_list = NULL;

    EXIT_MUTEX

    while ( list != NULL )
    {
        PSESS sess = rem_from_list(&list, list);

        if (sess->closed)
        {
            add_to_list(&done_list, sess);
            worth_tidying_up = TRUE;
        }
        else
        {
            add_to_list(&active_list, sess);
            progress_transfer(sess);
        }
    }
}


/***********************************************************************/
/*                                                                     */
/* A pending connection is pending for one of the following reasons:   */
/*                                                                     */
/* a) Pended but now ready to progress                                 */
/* b) Another connection to destination already open                   */
/*                                                                     */
/* If another session has the same address, then back off. If not,then */
/* no session can be using the server (if available).                  */
/*                                                                     */
/***********************************************************************/

static void progress_pendings(void)
{
    PSESS list = pending_list;

    consider_pending = FALSE;
    pending_list = NULL;

    while (list != NULL)
    {
        PSESS sess = rem_from_list(&list, list);
        PSESS alist = active_list;
        const unsigned long addr = sess->servaddr.sin_addr.s_addr;
        BOOL already = FALSE;

        for ( ;alist != NULL; alist = alist->next)
        {
            if (alist->servaddr.sin_addr.s_addr == addr)
            {
                already = TRUE;
                break;
            }
        }

        if (! already)
        {
            add_to_list(&active_list, sess);
            sess->state = state_initialise;
        }
        else
        {
            add_to_list(&pending_list, sess);
        }
    }
}

/**************************************************************/
/*                                                            */
/* Run down the list of servers and progress the shutdown of  */
/* any server requiring it. We attempt to gracefully send a   */
/* QUIT command and await a response, but will abruptly close */
/* the socket if necessary.                                   */
/*                                                            */
/**************************************************************/

static void quit_servers(void)
{
    PSERVER * servp = &server_list, serv;

    while ( (serv = *servp) != NULL )
    {
        if (serv->sess == NULL)
        {
            if (serv->dont_reuse)
            {
                dbg2(("Server marked no no reuse - closing it\n"));
                if (serv->sent_quit)
                {
                    char buf[16];
                    int rc = recv(serv->contsock, buf, sizeof(buf), 0);
                    dbg2(("Response code to QUIT is %d\n", rc));
                    if (rc == -1 && errno == EWOULDBLOCK)
                    {
                        ;
                    }
                    else if (rc != 0)
                    {
                        dbg2(("Closing control socket\n"));
                        (void) my_socketclose(&serv->contsock);
                    }
                }
                else
                {
                    dbg2(("Sending QUIT to server\n"));
                    if (send(serv->contsock, "QUIT\r\n", 6, 0) != 6)
                        (void) my_socketclose(&serv->contsock);
                    serv->sent_quit = 1;
                }

                if (serv->contsock == -1)
                {
                    dbg2(("Server control is closed - removing server\n"));
                    *servp = serv->next;
                    free_server(serv);
                    servers_to_quit -= 1;
                    worth_tidying_up = TRUE;
                }
                else
                    servp = &serv->next;
            }
            else
            {
                if ((MONONOW - serv->last_used) > serv->maxidle)
                {
                    dbg2(("Marking server for closure due to timeout\n"));
                    serv->dont_reuse = TRUE;
                }
                servp = &serv->next;
            }
        }
        else
            servp = &serv->next;
    }
}


/****************************************************************************/
/*                                                                          */
/* The callback handler is entered whenever either a ticker or an internet  */
/* event indicate that there might be further work to perform.              */
/*                                                                          */
/****************************************************************************/

extern RETURN_METHOD callback_handler(_kernel_swi_regs *regs, void *pw)
{
    int ex;

    ENTER_MUTEX

        callback_scheduled = FALSE;

        if (callback_threaded)
            ex = 1;
        else
        {
            callback_threaded = TRUE;
            callback_calls += 1;
            ex = 0;
        }

    EXIT_MUTEX

    if (ex)
        return VIA_R14;

    if (consider_pending)
    {
        progress_pendings();
    }

    if (active_list != NULL)
    {
        progress_active();
    }

    if ( worth_tidying_up )
    {
        free_finished_with_sessions();

        if ( pending_list == NULL && active_list == NULL && done_list == NULL && server_list == NULL )
        {
            dbg(("(6) No longer worth scheduling"));
            worth_scheduling = FALSE;
        }

        worth_tidying_up = FALSE;
    }

    if ( /*servers_to_quit > 0*/ server_list != NULL )
    {
        quit_servers();
    }

    callback_threaded = FALSE;

    return VIA_R14;

    UNUSED(regs);
    UNUSED(pw);
}

/*******************************************************************/
/*                                                                 */
/*  Create a new session structure from the parameters supplied.   */
/*                                                                 */
/*******************************************************************/
/*
 *   "" filtered out earlier
 *   "/"
 *   "/blah"
 *   "/blah/"
 *   "blah"
 *   "blah/"
 */

static _kernel_oserror *allocate_SESS(ftp_open_args * args, PSESS *sessp)
{
    _kernel_oserror *ep;
    PSESS sess;
    char *lname, *cp;
    int i;

    if ( (sess = calloc(1, sizeof(*sess))) == NULL)
    {
        GUARDED( make_error(GROUP_MEMORY) );
    }

#ifdef OLDCODE
    sess->contsock = -1;
#endif
    sess->datasock = -1;        /* ] pdh: these were inside ifdef too */
    sess->ro_handle = -1;       /* ]                                  */

    sess->resp1 = ' ';
    sess->resp2 = ' ';
    sess->resp3 = ' ';
    sess->resp4 = ' ';
    sess->ftp_status = status_AWAITING_CONNECTION;
    sess->flags      = args->in.flags;
    sess->ftp_cmd    = (args->in.flags&webftp_open_ftpcmd)?args->in.ftp_cmd:0;
    sess->extra      = NULL;
    /*
     * only check local name if doing a put or get
     */
    switch (sess->ftp_cmd)
    {
      case FTP_CMD_GET : case FTP_CMD_PUT :
        lname = args->in.local_name == NULL?tmpnam(NULL):args->in.local_name;
        sess->local_name = strdup(lname);
        if (sess->local_name == NULL)
          GUARDED( make_error(GROUP_MEMORY) );
        break;
      case FTP_CMD_RENAME :
        sess->extra = strdup((args->in.flags&webftp_open_extra)?args->in.extra:NULL);
        if (sess->extra == NULL)
          GUARDED( make_error(GROUP_MEMORY) );
        break;
      default :
        sess->local_name = NULL;
    }

    cp = strrchr(args->in.path, DIRSEP);

    if (cp == NULL)
    {
        sess->origdir = strdup("");
        sess->dir = sess->origdir;
        sess->leaf = strdup(args->in.path);
        sess->pathtype = TYPE_UNKNOWN;
    }
    else if (cp[1] == 0)
    {
        sess->origdir = strdup(args->in.path);
        sess->dir = sess->origdir;
        sess->pathtype = TYPE_DIR;
        sess->leaf = strdup("");
        if (cp != args->in.path && sess->origdir != NULL)
            sess->origdir[strlen(sess->origdir) - 1] = 0;
    }
    else
    {
        sess->origdir = strdup(args->in.path);
        sess->dir = sess->origdir;
        sess->leaf = strdup(cp + 1);
        sess->pathtype = TYPE_UNKNOWN;
        if (sess->origdir != NULL)
            sess->origdir[ cp - args->in.path ] = 0;
    }

    sess->origpath   = strdup(args->in.path);
    sess->user_name  = strdup(args->in.user_name);
    sess->passwd     = strdup(args->in.passwd);
    sess->acct       = strdup(args->in.acct);

    if (sess->user_name  == NULL
    ||  sess->origpath   == NULL
    ||  sess->passwd     == NULL
    ||  sess->acct       == NULL
    ||  sess->origdir    == NULL
    ||  sess->leaf       == NULL)
    {
        GUARDED( make_error(GROUP_MEMORY) );
    }
#ifdef FTP_PUT
    /* if we are doing a put, open file for read, otherwise write */
    if (sess->local_name)
    {
      switch (sess->ftp_cmd)
      {
        case FTP_CMD_PUT :
          sess->ro_handle = ro_fopen(sess->local_name,RO_OPEN_READ);
          ro_get_extent(sess->ro_handle, &sess->total_bytes);
          break;
        case FTP_CMD_GET :
          sess->ro_handle = ro_fopen(sess->local_name,RO_OPEN_WRITE);
          sess->total_bytes = -1;         /* Don't know by default */
	  break;
      }
      if ( sess->ro_handle < 0)
        GUARDED( make_error(GROUP_FILE) );
    }
#else
    if (sess->local_name)
    {
      if (sess->ftp_cmd == FTP_CMD_GET)
      {
        sess->ro_handle = ro_fopen(sess->local_name, RO_OPEN_WRITE);
        if ( sess->ro_handle < 0 || reopen_file(sess) != GROUP_OKAY )
          GUARDED( make_error(GROUP_FILE) );
      }
    }
#endif

    for (i = 0; i < NUMQS; i++)
    {
        if (! queue_init(&sess->Q[i], 0) )
        {
            GUARDED( make_error(GROUP_MEMORY) );
        }
    }

    sess->magic = MAGIC;
    sess->maxidle = args->in.maxidle;
    memcpy(&sess->servaddr, args->in.addr, sizeof(struct sockaddr));
#ifdef CSFS
    sess->error_msg=NULL;
#endif
    *sessp = sess;

    return NULL;

bad:
    *sessp = NULL;

    if (sess != NULL)
    {
        free_PSESS(sess);
    }

    return ep;
}

/*******************************************************/
/*                                                     */
/* SWI Interface: open a session                       */
/*                                                     */
/* Start the process of opening an FTP connection and  */
/* GETting a file. Progresss in the background. Return */
/* a session identifier by which this request can be   */
/* referred to later by the status and close SWIs.     */
/*                                                     */
/*******************************************************/

extern _kernel_oserror *do_swi_open(ftp_open_args * args)
{
    _kernel_oserror *ep;
    PSESS sess = NULL;

    /* Avoid totally empty paths for now - maybe force to / later */
    /* or even try and cope with no directory and no file */

    if (args->in.path == NULL || *args->in.path == 0)
    {
        GUARDED( make_error(GROUP_FILE) );
    }

    GUARDED( allocate_SESS(args, &sess) );

    add_to_list(&pending_list, sess);
    consider_pending = TRUE;

    args->out.session = sess;

    worth_scheduling = TRUE;
    schedule_callback();

    return NULL;

    /* Error return - free structure as failed to establish */

bad:
    if (sess != NULL)
    {
        free_PSESS(sess);
    }

    return ep;
}

/***********************************************/
/*                                             */
/* SWI Interface: return session status        */
/*                                             */
/* Check the status of a previous request.     */
/* This does not ever lead to a request being  */
/* closed.                                     */
/*                                             */
/***********************************************/

extern _kernel_oserror *do_swi_status(ftp_status_args * args)
{
    _kernel_oserror *ep;
    PSESS sess = args->in.session;

    GUARDED( check_session_valid(sess) );

    args->out.status = sess->ftp_status;
    args->out.rc = sess->rc;
    args->out.data_so_far = sess->bytes_so_far;
    args->out.data_total = sess->total_bytes;
    args->out.local_name = sess->local_name;        /* or strdup? */
    args->out.ro_handle = sess->ro_handle;

    return NULL;

bad:
    return ep;
}

/***********************************************************/
/*                                                         */
/* SWI Interface: close a session                          */
/*                                                         */
/* Indicate that the user has finished with a request. If  */
/* the request is still in progress, we need to close it.  */
/* Once the user has called here with a particular         */
/* request, that request cannot be referred to again.      */
/*                                                         */
/***********************************************************/

extern _kernel_oserror *do_swi_close(ftp_close_args * args)
{
    _kernel_oserror *ep = NULL;
    PSESS sess = args->in.session;
    unsigned int flags = args->in.flags;

    GUARDED( check_session_valid(sess) );

    args->out.status = sess->ftp_status;
    args->out.rc = sess->rc;
    sess->closed = TRUE;
    sess->state = state_error;
    if ( (flags & webftp_close_DELETE_FILE) != 0 && sess->local_name != NULL )
        ro_unlink(sess->local_name);
    tidy_up(sess);
    sess->magic = ~ MAGIC;      /* Which cannot be MAGIC */
    worth_tidying_up = TRUE;

    return NULL;

bad:
    return ep;
}

/***********************************************************/
/*                                                         */
/* SWI interface: close background sessions                */
/*                                                         */
/* This causes any inactive servers (ie currently have     */
/* an open control socket) to be closed. If two different  */
/* client programs are being used, this is not idle, but   */
/* anything else is difficult to define.                   */
/*                                                         */
/***********************************************************/

extern _kernel_oserror *do_swi_closeidle(ftp_closeidle_args * args)
{

    return NULL;
}

#ifdef CSFS
/*
 * munge the filename
 */
_kernel_oserror *
munge_filename(char *mount_path, char *input_filename, int file_type, char **output_file)
{
  int i;
  char *input_path=NULL;
  char *output_path=NULL;

  input_path=input_filename;   /* make sure we don't trash input string */

  if (input_path!=NULL)       /* is it a null string */
    if (*input_path==0)
      input_path=NULL;

  /*
   * need our own copy of string to play with
   */
  output_path = malloc((mount_path==NULL?0:strlen(mount_path))+
                       (input_path==NULL?1:strlen(input_path))+5);
  if (output_path==NULL)
    return (make_error(GROUP_MEMORY));

  if (mount_path)
    strcpy(output_path,mount_path);
  else
    strcpy(output_path,"");

  if (output_path[strlen(output_path)-1]!='/')
    strcat(output_path,"/");

  if (input_path)
  {
    i=strlen(output_path);
    strcat(output_path,input_path);  /* take a copy */
    while (output_path[i]!=0)        /* swap '.' with '/' */
    {
      if (output_path[i]=='.')
        output_path[i]='/';
      else if (output_path[i]=='/')
        output_path[i]='.';
      i++;
    }
  }

  /*
   * sort filetype out
   */
  if (file_type!=0 && file_type !=0xfff)  /* append the file type to filename */
  {
    char exten[6];
    sprintf(exten,",%03x",file_type);
    strcat(output_path,exten);
  }
  *output_file = output_path;

  return (NULL);
}

/*
 * implement the CSFS service swi
 */
extern _kernel_oserror *do_swi_csfs_service(_kernel_swi_regs *r)
{
  ftp_open_args open_args;
  ftp_close_args close_args;
  ftp_status_args status_args;
  _kernel_oserror *err=NULL;
  struct sockaddr_in sockaddr_in;
  char *path=NULL;
  char *new_path=NULL;
  char *remote_filename=NULL;
  char *mount_path=NULL;
  int  file_type;
  csfs_info *file_info;
  settype_info *type_info;
  int abort_command=0; /* used to stop command */
  struct sess *session;
  static progress_info file_progress;

  memset(&sockaddr_in, 0, sizeof(sockaddr_in));

  switch (r->r[0])
  {
    case CSFS_CLOSE :
      close_args.in.session = (struct sess*)r->r[2];
      ERR_GOTO(err,do_swi_close(&close_args));

      break;
    case CSFS_STATUS :
      session = (struct sess*)r->r[2];
      status_args.in.session = session;
      ERR_GOTO(err,do_swi_status(&status_args));

      if (status_args.out.status >= status_COMPLETED_FILE)
      {
        switch (status_args.out.status)
        {
          case status_COMPLETED_FILE : case status_COMPLETED_DIR :
          case status_COMPLETED_GENERIC_COMMAND :
            r->r[0] = 0;
            dbg(("(5) finished things"));
            break;
          default :
            dbg(("(5) generating CSFS transport error\n"));
            err=make_error(ERROR_CSFS);
            if (session->error_msg)
            {
              int space = 251-strlen(err->errmess); /* number of safe chars */
              if (space>0)
              {
                strcat(err->errmess," ");
                strncat(err->errmess,session->error_msg,space);
              }
            }
	}
      }
      else
       r->r[0] = -1;  /* still progressing */

      r->r[3] = NULL;  /* assume the worst */
      switch (session->ftp_cmd)
      {
        case FTP_CMD_GET : case FTP_CMD_PUT :
          if (session->total_bytes == -1)
            break;

          file_progress.total = session->total_bytes;
          file_progress.sofar = session->bytes_so_far;
          r->r[3] = (int)&file_progress;
      }
      break;
    default :
      mount_path = (char*)r->r[3];
      remote_filename = (char*)r->r[4];
      sockaddr_in.sin_family = AF_INET;
      /*
       * deal with port number being specified
       */
      if (r->r[1] & 1<<0)
      {
        host_info *host = (host_info*)r->r[2];
        /* default to port 21 */
        sockaddr_in.sin_port = htons((host->port==0)?21:host->port);
        sockaddr_in.sin_addr.s_addr = (unsigned int)htonl(host->addr);
      }
      else
      {
        sockaddr_in.sin_port = htons(21);
        sockaddr_in.sin_addr.s_addr = (unsigned int)htonl(r->r[2]);
      }

      open_args.in.addr = &sockaddr_in;
      open_args.in.user_name = (char*)r->r[5];
      open_args.in.passwd = (char*)r->r[6];
      if (r->r[0]==CSFS_SETTYPE)
      {
        type_info = (settype_info*)r->r[8];
        file_type = type_info->old;
      }
      else
      {
        file_info = (csfs_info*)r->r[8];
        /*
         * extract file type info from supplied data
         */
        if (file_info==NULL)
          file_type = 0;
        else
          file_type = (file_info->load_addr)>>8&0xfff; /* load addr */
      }
      ERR_GOTO(err,munge_filename(mount_path,remote_filename,file_type,&path));

      /*
       * fill in the args
       */
      open_args.in.path = path;
      open_args.in.acct = NULL;
      open_args.in.local_name = (char*)r->r[7];
      open_args.in.flags = webftp_open_NotHTML | webftp_open_ftpcmd |
      			   webftp_open_extra;
      open_args.in.maxidle = 500; /* timeout after 5 seconds */
      open_args.in.extra = NULL;

      dbg(("(6) path '%s'\n",path));
      dbg(("(6) host 0x%08x\n",r->r[2]));
      dbg(("(6) user '%s'\n",open_args.in.user_name));

      switch (r->r[0])
      {
        case CSFS_GET :
          open_args.in.ftp_cmd = FTP_CMD_GET;
          break;
        case CSFS_PUT :
          open_args.in.ftp_cmd = FTP_CMD_PUT;
          break;
        case CSFS_DELETE :
          open_args.in.ftp_cmd = FTP_CMD_DELETE;
          break;
        case CSFS_RMDIR :
          open_args.in.ftp_cmd = FTP_CMD_RMDIR;
          break;
        case CSFS_MKDIR :
          open_args.in.ftp_cmd = FTP_CMD_MKDIR;
          break;
	case CSFS_RENAME :
          open_args.in.ftp_cmd = FTP_CMD_RENAME;
          if (r->r[7])
          {
            ERR_GOTO(err,munge_filename(mount_path,(char*)r->r[7],file_type,&new_path));
            open_args.in.extra = new_path;
          }
          else
            abort_command = 1;
          break;
        case CSFS_SETTYPE :
          open_args.in.ftp_cmd = FTP_CMD_RENAME;
          ERR_GOTO(err,munge_filename(mount_path,remote_filename,type_info->new,&new_path));
          open_args.in.extra = new_path;

          break;
        default :
          abort_command = 1;
      }
      dbg2(("CSFS cmd %d\n",open_args.in.ftp_cmd));
      if (abort_command)
      {
        ERR_GOTO(err,make_error(ERROR_CSFS));
      }
      else
      {
        ERR_GOTO(err,do_swi_open(&open_args));
        r->r[0] = (int)open_args.out.session;
      }
  }
exit_gracefully:
  if (path)
    free(path);
  if (new_path)
    free(new_path);

  return (err);
}
#endif

/***********************/
/*                     */
/*                     */
/*   The SWI handler   */
/*                     */
/*                     */
/***********************/

extern _kernel_oserror *swi_handler(unsigned int swinum, _kernel_swi_regs *regs, void *pw)
{
    _kernel_oserror *ep = NULL;

    switch (swinum)
    {
        case 0:
            GUARDED( do_swi_open((ftp_open_args *) regs) );
            break;

        case 1:
            GUARDED( do_swi_status((ftp_status_args *) regs) );
            break;

        case 2:
            GUARDED( do_swi_close((ftp_close_args *) regs) );
            break;

        case 3:
            GUARDED( do_swi_closeidle((ftp_closeidle_args *) regs) );
            break;
#ifdef CSFS
        case 4:
            GUARDED( do_swi_csfs_service(regs) );
            break;
#endif
        default:
            GUARDED( make_error(ERROR_NO_SUCH_SWI) );
            break;
    }

    return NULL;

    UNUSED(pw);

bad:
    return ep;
}

/*****************************************************************************/
/*
 * module_cli_handler:
 *
 * Module CLI handler: despatch any *commands that we provide. Note that the
 * string passed MUST NOT BE OVERWRITTEN.
 */

extern _kernel_oserror *cli_handler(char *arg_string, int arg_count, unsigned int cmd_no, void *pw)
{
    switch (cmd_no)
    {
        case 0:
            dump_state();
            return NULL;
            break;

        default:
            return make_error(ERROR_UNKNOWN_COMMAND);
            break;
    }

    UNUSED(arg_string);
    UNUSED(arg_count);
    UNUSED(cmd_no);
    UNUSED(pw);
}

/*****************************************************************************/

static void quit_list(PSESS *listp)
{
    while (*listp != NULL)
    {
        PSESS sess = rem_from_list(listp, *listp);
        tidy_up(sess);
    }
}

/*
 * pick up on the CSFS starting service call and register ourselves
 */
#ifdef CSFS
void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs reg;

  reg.r[0] = 0;
  reg.r[1] = (int)CSFS_ServiceName;
  reg.r[2] = WebFTP_CSFSService;
  reg.r[3] = WebFTP_CSFSFeatures;
  /*
   * ignore error
   */
  _kernel_swi(CSFS_Register,&reg,&reg);
}
#endif
/*****************************************************************************/

extern void module_finalise(int fatal, int podule, void *pw)
{
#ifdef CSFS
    _kernel_swi_regs reg;
#endif

    debug_printf(db,"(5) finalisation");
    remote_debug_close(db);

    ENTER_MUTEX

        release_events();
        callback_remove();

    EXIT_MUTEX;

#ifdef CSFS
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceName;
    /*
     * ignore error
     */
    _kernel_swi(CSFS_DeRegister,&reg,&reg);
#endif
    quit_list(&pending_list);
    quit_list(&active_list);

    while (done_list != NULL)
    {
        PSESS sess = done_list;
        rem_from_list(&done_list, sess);
        free_PSESS(sess);
    }

    while (server_list != NULL)
    {
        PSERVER next = server_list->next;
        free_server(server_list);
        server_list = next;
    }
}

/*****************************************************************************/
#if REMOTE_DEBUG && DEBUG
void
_debug_printf(char *format, ...)
{
  char debug_line[256];
  va_list list;

  va_start (list, format);
  vsprintf(debug_line,format, list);
  va_end(list);

  debug_printf(db,"%s",debug_line);
}

#endif

extern _kernel_oserror *initialise(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *ep = NULL;
#ifdef CSFS
    _kernel_swi_regs reg;
#endif
    private_word = pw;

    GUARDED( claim_events() );

#ifdef CSFS
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceName;
    reg.r[2] = WebFTP_CSFSService;
    reg.r[3] = WebFTP_CSFSFeatures;
    /*
     * ignore error
     */
    _kernel_swi(CSFS_Register,&reg,&reg);
#endif

    remote_debug_open("WebFTP",&db);

    return NULL;

bad:
    return ep;

    UNUSED(pbase);
    UNUSED(cmd_tail);
}

/* eof  webftp.c */
