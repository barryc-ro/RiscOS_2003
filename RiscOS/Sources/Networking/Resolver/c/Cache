/*
 * Program:	Cache.c - cache lookup for Resolver module
 *
 * Project:	DNS Resolver module
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@ant.co.uk
 *
 * Date:	7 Febuary 1995
 * Last Edited:	25 December 1995
 *
 * Copyright 1995 by ANT Limited
 */

#include "kernel.h"
#include <stdio.h>
#include <string.h>
#include "netdb.h"
#include "libs/desklib/Core.h"
#include "libs/desklib/LinkList.h"
#include "libs/desklib/Time.h"
#include "Core.h"
#include "Cache.h"
#include "ExtLib.h"
#include "Debug.h"
#include "Hosts.h"

extern char *lcase(char *s);


/* List of cache item records */
extern linklist_header	cache_anchor = {NULL, NULL};
/* extern linklist_header	cpend_anchor = {NULL, NULL}; */

/* Timestamp for /etc/hosts file last read */
extern int 		cache_hoststime = 0;

/* Monotonic time of last /etc/hosts file check (only check every 30 sec max) */
extern int 		cache_hostscheck = 0;

/* Cache control flags word */
extern int 		cache_control = ctrlbit_DISABLEFAIL;

/* Number of retries on bad address (default is cache_RETRIES) */
extern int 		cache_retries = cache_RETRIES;

/* Delay between retries (default is cache_DELAY) */
extern int 		cache_delay = cache_DELAY;


/*  Remove cache entry from linked list.
 */
extern void cacheclear(cache_rec *cr)
{
  if (!cr) return;
  TRACE1("cacheclear: %x\n", (int) cr);
  if (cr->host)
  {
    /* Clear elements from hosts struct */
    if (cr->host->h_name) heap_free(cr->host->h_name);
    if (cr->host->h_aliases)
    {
      int loop = 0;
      while (cr->host->h_aliases[loop]) heap_free(cr->host->h_aliases[loop++]);
      heap_free(cr->host->h_aliases);
    }
    if (cr->host->h_addr_list)
    {
      int loop = 0;
      while (cr->host->h_addr_list[loop]) heap_free(cr->host->h_addr_list[loop++]);
      heap_free(cr->host->h_addr_list);
    }
    heap_free(cr->host);
  }
  if (cr->hostname)
  {
    TRACE1("cacheclear: '%s'\n", cr->hostname);
    heap_free(cr->hostname);
  }
  if (cr->dns) heap_free(cr->dns);
  LinkList_Unlink(&cache_anchor, &(cr->header));
  heap_free(cr);
  TRACE("cacheclear: exit\n");
}


/*  Locate a cache entry, by hostname if hostname != NULL, else by flags word.
 *  Uses cased strcmp() - cached items have already been converted to lower case.
 */
extern cache_rec *cachefind(char *hostname, int flags)
{
  cache_rec *cr = (cache_rec *) cache_anchor.next;
  register char **cp;
  int maxtime = cache_VALID;

  /* Look for hostname in local cache */
  /* TRACE2("cachefind: '%s' %x\n", hostname ? hostname : "", flags); */
  if (hostname)
  {
    char s[96];
    int s_addr;

    /* Check for numeric dotted IP address */
    if ((s_addr = _inetaddr(hostname)) == -1)
    {
      /* IP host name */
      strcpy(s, lcase(hostname));
      while (cr)
      {
        /* TRACE2("cachefind: cmp '%s' '%s'\n", cr->hostname, s); */
        if (!strcmp(cr->hostname, s)) goto found;
        if (cr->host)
        {
          if (!strcmp(cr->host->h_name, s)) goto found;
          for (cp = cr->host->h_aliases; *cp != 0; cp++) if (!strcmp(*cp, s)) goto found;
        }
        cr = (cache_rec *) cr->header.next;
      }
    }
    else
    {
      /* IP host address */
      while (cr)
      {
        /* TRACE2("cachefind: num cmp '%s' '%s'\n", cr->hostname, hostname); */
        if (s_addr == _inetraddr(cr->hostname)) goto found;
        if (cr->host)
        {
          for (cp = cr->host->h_addr_list; *cp != 0; cp++)
            if (!memcmp(*cp, (char *) &s_addr, 4)) goto found;
        }
        cr = (cache_rec *) cr->header.next;
      }
    }
  }
  else
  {
    while (cr)
    {
      if ((cr->flags & flags) == flags) goto found;
      cr = (cache_rec *) cr->header.next;
    }
  }
  TRACE("cachefind: not found\n");
  return(NULL);
found:

  /* If cached entry is older than given timeout, then state change or purge it */
  if (cr->flags & flags_FAILED) maxtime = cache_FAILED;
    else if (cr->flags & flags_PENDING) maxtime = cache_PENDING;
  if ((cr) && (Time_Monotonic() > cr->time + maxtime))
  {
    TRACE("cachefind: purge!\n");
    if (cr->flags & flags_PENDING)
    {
      cr->flags &= ~flags_PENDING;
      cr->flags |= flags_FAILED;
      if (cr->dns)
      {
        heap_free(cr->dns);
        cr->dns = NULL;
      }
    }
    else
    {
      cacheclear(cr);
      cr = NULL;
    }
  }

  /* If cached entry is from hosts file, check hosts file to ensure not updated */
  if (cr && (cr->flags & flags_HOST))
  {
    int cachetime;

    cachetime = Time_Monotonic();
    if (cache_hostscheck > cachetime) return(cr);

    /* Check time/date stamp of /etc/hosts file */
    cache_hostscheck = cachetime + 3000;
    cachetime = filedate(_PATH_HOSTS);

    /* Is the time-changed more recent than our last-read-hosts-file stamp? */
    if (cachetime > cache_hoststime)
    {
      /* Invalidate all cache entries that came from this file */
      TRACE("cachefind: invalidate hosts file\n");
      cachefini(FALSE);
      /* Update last-read-hosts-file stamp */
      cache_hoststime = cachetime;
      cr = NULL;
    }
  }

  /* Return with cache entry, or NULL */
  /* TRACE1("cachefind: found %x\n", (int) cr); */
  return(cr);
}


/*  Add a new cache entry.
 */
extern cache_rec *cacheadd(char *hostname, struct hostent *host, int flags)
{
  cache_rec *r;

  if (!hostname) return(NULL);
  r = heap_alloc(sizeof(cache_rec));
  if (!r) return(NULL);
  r->hostname = cpystr(lcase(hostname));
  r->host = host;
  r->flags = flags;
  r->time = Time_Monotonic();
  r->failure = 0;
  r->dns = NULL;
  r->retry = 0;
  TRACE2("cacheadd: %x %x ", (int) host, flags);
  TRACE1("%x\n", r->time);
  LinkList_AddToHead(&cache_anchor, &(r->header));
  return(r);
}


/*  Cache Initialisation.
 */
extern void cacheinit(void)
{
  TRACE("cacheinit:\n");
  LinkList_Init(&cache_anchor);
  cache_hoststime = filedate(_PATH_HOSTS);
  cache_hostscheck = Time_Monotonic();
}


/*  Cache Finalisation.
 *  Kills all records if all = TRUE on entry, or just those that came from the
 *  /etc/hosts file if FALSE.
 */
extern void cachefini(BOOL all)
{
  cache_rec *cr = (cache_rec *) cache_anchor.next;
  TRACE("cachefini:\n");
  while (cr)
  {
    cache_rec *cr_tmp = (cache_rec *) cr->header.next;
    if ((cr->flags & flags_HOST) || (all)) cacheclear(cr);
    cr = cr_tmp;
  }
  if (all) cacheinit();
}


/*  Get entry out of cache for user.
 */
extern void cacheget(_kernel_swi_regs *r)
{
  cache_rec *cr = (cache_rec *) r->r[0];

  TRACE("cacheget:\n");
  if (!cr) cr = (cache_rec *) cache_anchor.next;
  if (cr)
  {
    TRACE2("cacheget: %x %d ", (int) cr->host, cr->flags);
    TRACE1("%x\n", cr->time);
    r->r[0] = (int) cr->header.next;
    if (!cr->header.next) r->r[0] = -1;
    r->r[1] = (int) cr->host;
    r->r[2] = (int) cr->hostname;
    r->r[3] = cr->flags;
    r->r[4] = cr->time;
    r->r[5] = cr->failure;
    r->r[6] = (int) cr->dns;
  }
  else
  {
    r->r[0] = -1;
    r->r[1] = 0;
  }
}


/*  Flush cache of any items with any of the passed bits set.
 */
extern void cacheflush(int flags)
{
  cache_rec *cr = (cache_rec *) cache_anchor.next;

  TRACE1("cacheflush: %x\n", flags);
  while (cr)
  {
    cache_rec *cr_tmp = (cache_rec *) cr->header.next;
    if (cr->flags & flags) cacheclear(cr);
    cr = cr_tmp;
  }
}

