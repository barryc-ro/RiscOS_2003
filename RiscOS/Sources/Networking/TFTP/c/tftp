#include <sys/types.h>
#include <sys/param.h>
#include <sys/errno.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>

#include <arpa/inet.h>
#include <arpa/tftp.h>

#include <netdb.h>

#include <socklib.h>
#include <inetlib.h>
#include <unixlib.h>

#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <time.h>

#include <swis.h>

#include "tftp.h"


#ifdef TRACE
static void log_packet(const char *prefix, const struct tftphdr *t, int len)
{
    static const char *const packnames[] = { NULL, "RRQ", "WRQ", "DATA", "ACK", "ERROR", "OACK" };
    int opcode = ntohs(t->th_opcode);
    const char *packname = opcode <= OACK ? packnames[opcode] : NULL;
    char buf[32];
    const char *p;

    if (packname == NULL)
    {
        sprintf(buf, "%d", opcode);
        packname = buf;
    }

    printf("%s [%s] ", prefix, packname);

    switch (opcode)
    {
        case RRQ:
        case WRQ:
        case OACK:
        default:
            p = t->th_stuff;
            len -= offsetof(struct tftphdr, th_stuff);
            while (len--)
            {
                if (*p >= 32)
                    putchar(*p);
                else
                    printf("\\%o", *p);
                p++;
            }
            putchar('\n');
            break;

        case DATA:
            printf("block %d, %d byte%s\n", ntohs(t->th_block), len - offsetof(struct tftphdr, th_data),
                                            len - offsetof(struct tftphdr, th_data) == 1 ? "" : "s");
            break;

        case ACK:
            printf("block %d\n", ntohs(t->th_block));
            break;

        case ERROR:
            printf("code %d: %s\n", ntohs(t->th_code), t->th_msg);
            break;
    }
}
#endif

static unsigned systime()
{
    unsigned s;
    _swix(OS_ReadMonotonicTime, _OUT(0), &s);
    return s;
}

/* Bitfield manipulations */
#define SETMAPBIT(n) (map[(n)>>5] |= (1<<((n) & 31)))
#define GETMAPBIT(n) ((map[(n)>>5]>>((n) & 31))&1)

/*
 * Give the number of the first clear bit in map.
 * We start from bit "start" - allows optimisation if
 * the caller remembers our previous results.
 */
static int first_clear_bit(const u_int *map, int start)
{
    int n=start &~ 31;
    u_int b;

    map += start >> 5;

    while ((b = *map) == 0xFFFFFFFF)
    {
        n += 32;
        map++;
    }

    while (b & 1)
    {
        n++;
        b >>= 1;
    }

    return n;
}

static void send_error(int s, struct tftphdr *buf, int errnum, const char *errmess,
                       const struct sockaddr_in *to)
{
    int n;

    buf->th_opcode = htons(ERROR);
    buf->th_code = htons(errnum);
    n = sprintf(buf->th_msg, "%s", errmess);
    sendto(s, buf,
           offsetof(struct tftphdr, th_msg) + n + 1,
           0, (const struct sockaddr *) to, sizeof *to);
    #ifdef TRACE
    log_packet("->", buf, offsetof(struct tftphdr, th_msg) + n + 1);
    #endif

    if (errmess != _inet_error.errmess)
    {
        _inet_error.errnum = errnum + ERRORBASE;
        strcpy(_inet_error.errmess, errmess);
    }
}

static int send_ack(int s, struct tftphdr *buf, const u_int *map, int *last_acked)
{
    int block = first_clear_bit(map, *last_acked);

    *last_acked = block;

    buf->th_opcode = htons(ACK);
    buf->th_block = htons(block);

    send(s, buf, sizeof buf->th_opcode + sizeof buf->th_block, 0);

    #ifdef TRACE
    log_packet("->", buf, sizeof buf->th_opcode + sizeof buf->th_block);
    #endif

    return sizeof buf->th_opcode + sizeof buf->th_block;
}

static _kernel_oserror *no_mem_error()
{
    _inet_error.errnum = ERRORBASE + ENOSPACE;
    strcpy(_inet_error.errmess, "Out of memory");
    return &_inet_error;
}

static bool check_escape()
{
    int flags;
    _swix(OS_ReadEscapeState, _OUT(_FLAGS), &flags);
    if (flags & _C)
    {
        _swix(OS_Byte, _IN(0), 126);
        return true;
    }
    else
        return false;
}

static int new_socket(int proto)
{
    int s;
    int one = 1;
    int tos = IPTOS_LOWDELAY; /* RFC 1700 says low delay for TFTP */

    if ((s = socket(PF_INET, proto == IPPROTO_UDP ? SOCK_DGRAM : SOCK_RAW, proto)) < 0)
        return s;

    if (socketioctl(s, FIONBIO, &one) < 0 ||
        socketioctl(s, FIOSLEEPTW, &one) < 0)
        goto error;

    if (proto == IPPROTO_UDP &&
        setsockopt(s, IPPROTO_IP, IP_TOS, &tos, sizeof tos) < 0)
        goto error;

    return s;

  error:
    socketclose(s);
    return -1;
}

/*
 * Contact server, and request "filename". For each new block of data that
 * arrives, recvfunc will be called. If an error occurs, the transfer
 * is aborted, and an error is returned.
 */
_kernel_oserror *tftpreadfile(const char *filename, struct in_addr server,
                              _kernel_oserror *(*recvfunc)(const void *data, u_long offset,
                                                           size_t len, void *handle),
                              void *client_handle)
{
    int unicast_socket = -1;
    int multicast_socket = -1;
    int icmp_socket = -1;
    struct sockaddr_in sin, from;
    int fromlen = sizeof from;
    int n, len;
    int num_blocks = -1;
    int highest_block = -1;
    int blocksize = 512;
    int one = 1;
    int last_acked = 0;
    bool connected = false;
    bool finished = false;
    bool master_client = true;
    bool expecting_oack = true;
    bool already_transmitted = false;
    fd_set fds;
    int nfds, s;
    _kernel_oserror *e = &_inet_error, *e2;
    u_int *map = NULL;
    struct tftphdr *in = NULL, *out = NULL;
    struct timeval tv;
    long rexmtval = BASE_RETRANSMIT;
    int lasttime;

    out = malloc(SEGSIZE);
    in = malloc(offsetof(struct tftphdr, th_data) + SEGSIZE);
    map = malloc(8192); /* One bit per possible block number */
    if (!out || !in || !map)
    {
        e = no_mem_error();
        goto error;
    }

    memset(map, 0, 8192);

    if ((unicast_socket = new_socket(IPPROTO_UDP)) < 0)
        goto error;

    if ((icmp_socket = new_socket(IPPROTO_ICMP)) < 0)
        goto error;

    nfds = MAX(unicast_socket, icmp_socket) + 1;

    sin.sin_family = AF_INET;
    sin.sin_len = sizeof sin;
    sin.sin_port = htons(69);
    sin.sin_addr = server;
    memset(sin.sin_zero, 0, sizeof sin.sin_zero);

    out->th_opcode = htons(RRQ);
    n = sprintf(out->th_stuff, "%s%c"
                               "octet%c"
                               "multicast%c%c"
                               "blksize%c%d%c"
                               "tsize%c0",
                               filename, 0,
                               0,
                               0, 0,
                               0, MAXBLKSIZE, 0,
                               0);

    len = offsetof(struct tftphdr, th_stuff) + n + 1;
    lasttime = systime();

    while (!finished)
    {
        bool was_multicast = false;

        if (master_client && !already_transmitted &&
            sendto(unicast_socket, out, len, 0,
                   connected ? NULL : (const struct sockaddr *) &sin, sizeof sin) < 0)
        {
            goto error;
        }
        #ifdef TRACE
        if (master_client && !already_transmitted)
            log_packet("->", out, len);
        #endif

        already_transmitted = false;

        if (out->th_opcode == htons(RRQ))
            expecting_oack = true;

     reselect:
        FD_ZERO(&fds);
        FD_SET(unicast_socket, &fds);
        FD_SET(icmp_socket, &fds);
        if (multicast_socket >= 0)
        {
            FD_SET(multicast_socket, &fds);
        }

        tv.tv_sec = rexmtval;
        tv.tv_usec = 0;
        if (select(nfds, &fds, NULL, NULL, &tv) < 0 && errno != EINTR)
        {
            if (connected)
                send_error(unicast_socket, in, EUNDEF, _inet_err(), NULL);
            goto error;
        }

        if (check_escape())
        {
            if (connected)
                send_error(unicast_socket, in, EUNDEF, "Escape", NULL);
            _inet_error.errnum = 17;
            goto error;
        }

        if (FD_ISSET(unicast_socket, &fds))
            s = unicast_socket;
        else if (multicast_socket >= 0 && FD_ISSET(multicast_socket, &fds))
            s = multicast_socket;
        else if (FD_ISSET(icmp_socket, &fds))
            s = icmp_socket;
        else
            s = -1;

        if (s != -1)
        {
            if ((n = recvfrom(s, in, offsetof(struct tftphdr, th_data) + blocksize, 0,
                              (struct sockaddr *) &from, &fromlen)) < 0)
            {
                if (errno != EWOULDBLOCK)
                {
                    if (connected)
                        send_error(unicast_socket, in, EUNDEF, _inet_err(), NULL);
                    goto error;
                }
            }
        }
        else
            n = -1;

        if (n <= 0)
        {
            /* No data received. Check overall timeout. If still want to
             * continue, double the wait interval and retransmit packet.
             */
            if (systime() - lasttime > TOTAL_TIMEOUT * 100)
            {
                _inet_error.errnum = ERROR_TIMEDOUT;
                strcpy(_inet_error.errmess, "Timed out");
                if (connected)
                    send_error(unicast_socket, in, EUNDEF, _inet_error.errmess, NULL);
                goto error;
            }

            rexmtval *= 2;
            if (rexmtval > MAX_RETRANSMIT)
                rexmtval = MAX_RETRANSMIT;
            continue;
        }
        else if (s == icmp_socket)
        {
            /* Pick our way through IP/ICMP/IP/UDP header chain
             * to find out if it is an ICMP Destination Unreachable
             * message generated in response to a UDP packet sent
             * to our server's port.
             * Internet module will have done basic checking,
             * including ICMP checksum.
             * This is needed to catch ICMP bounces to initial
             * RRQ - Internet module will only deal with them
             * automatically once we're connected.
             */
            struct ip *ip = (struct ip *) in;
            struct icmp *icmp;

            #ifdef ICMP_DEBUG
            {
                int i;
                for (i=0; i < n; i++)
                {
                    printf("%02X%c", ((char*)in)[i], (i & 15)==15?'\n':' ');
                }
            }
            #endif

            icmp = (struct icmp *)((char *) ip + (ip->ip_hl << 2));
            if (icmp->icmp_type == ICMP_UNREACH)
            {
                ip = (struct ip *) icmp->icmp_data;
                if (ip->ip_p == IPPROTO_UDP &&
                    ip->ip_dst.s_addr == sin.sin_addr.s_addr)
                {
                    struct udphdr *udp;
                    udp = (struct udphdr *)((char *) ip + (ip->ip_hl << 2));

                    /* Check length at least once :) Okay to do it late as
                     * we can't actually run off of a buffer - we may just
                     * have read duff values. Check we've got the whole UDP
                     * header bounced back.
                     */
                    if ((char *) udp + sizeof(struct udphdr) - (char *) in <= n)
                    {
                        if (udp->uh_dport == sin.sin_port)
                        {
                            if (icmp->icmp_code == ICMP_UNREACH_PORT)
                            {
                                _inet_error.errnum = 0x20E00 + ECONNREFUSED;
                                strcpy(_inet_error.errmess, "Connection refused");
                            }
                            else
                            {
                                _inet_error.errnum = 0x20E00 + EHOSTUNREACH;
                                sprintf(_inet_error.errmess, "Server unreachable (%d)",
                                                             icmp->icmp_code);
                            }
                            goto error;
                        }
                    }
                }
            }
            /* It wasn't an ICMP message to do with us. Just loop around.
             * This will delay retransmission, but not really
             * something worth worrying about as ICMP messages are very rare.
             */
            goto reselect;
        }

        /* Start of UDP input processing */

        was_multicast = (s == multicast_socket);

        #ifdef TRACE
        log_packet(was_multicast ? "<=" : "<-", in, n);
        #endif

        if (!connected && from.sin_addr.s_addr != sin.sin_addr.s_addr)
        {
            /* This can only happen if not connected - if we are connected we
             * won't see any packets from the wrong source - the Internet module
             * will fire back a port unreachable ICMP message.
             */
            send_error(unicast_socket, in, EBADID, "Unknown transfer ID", &from);
            /* Loop around again (see comments above about ICMP) */
            goto reselect;
        }

        /* Note where the server's coming from */
        if (!connected)
        {
            sin.sin_port = from.sin_port;
            if (connect(unicast_socket, (struct sockaddr *) &sin, sizeof sin) < 0)
            {
                send_error(unicast_socket, in, EUNDEF, _inet_err(), &from);
                goto error;
            }
            connected = true;
        }

        /* We have a response! Reset the retransmit timer. */
        rexmtval = BASE_RETRANSMIT;
        lasttime = systime();

        switch (ntohs(in->th_opcode))
        {
            case OACK:
            {
                /* Parse the returned options. Check they're OK. */
                char *p = in->th_stuff;
                char *eop = in->th_stuff + n - offsetof(struct tftphdr, th_stuff);

                while (p < eop)
                {
                    char *val = p + strlen(p) + 1;
                    if (strcasecmp(p, "multicast") == 0)
                    {
                        if (*val != ',' && multicast_socket == -1)
                        {
                            char *comma = val;
                            struct sockaddr_in la, ma;
                            struct ip_mreq mreq;
                            int lalen = sizeof la;

                            /* Extract multicast group */
                            while (*comma != ',') comma++;
                            *comma = '\0';
                            ma.sin_addr.s_addr = inet_addr(val);

                            /* Extract multicast destination port */
                            val = comma + 1;
                            ma.sin_port = htons(atoi(val));

                            /* Create socket */
                            if ((multicast_socket = new_socket(IPPROTO_UDP)) < 0)
                            {
                                send_error(unicast_socket, in, EUNDEF, _inet_err(), NULL);
                                goto error;
                            }

                            /* Bind to the required destination port, and mark non-blocking */
                            ma.sin_family = AF_INET;
                            ma.sin_len = sizeof la;
                            memset(ma.sin_zero, 0, sizeof ma.sin_zero);

                            if (setsockopt(multicast_socket, SOL_SOCKET, SO_REUSEPORT, &one, sizeof one) < 0 ||
                                setsockopt(multicast_socket, SOL_SOCKET, SO_REUSEADDR, &one, sizeof one) < 0 ||
                                bind(multicast_socket, (struct sockaddr *) &ma, sizeof ma) < 0 ||
                                connect(multicast_socket, (struct sockaddr *) &sin, sizeof sin) < 0 ||
                                getsockname(unicast_socket, (struct sockaddr *) &la, &lalen) < 0)
                            {
                                send_error(unicast_socket, in, EBADOPTS, _inet_err(), NULL);
                                goto error;
                            }

                            mreq.imr_multiaddr = ma.sin_addr;
                            mreq.imr_interface = la.sin_addr;

                            if (setsockopt(multicast_socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof mreq) < 0)
                            {
                                send_error(unicast_socket, in, EBADOPTS, _inet_err(), NULL);
                                goto error;
                            }

                            if (multicast_socket + 1 > nfds)
                                nfds = multicast_socket + 1;
                        }
                        else
                        {
                            val++;
                        }
                        /* Advance to third field */
                        while (*val++ != ',') continue;
                        master_client = atoi(val);

                    }
                    else if (strcasecmp(p, "blksize") == 0)
                    {
                        blocksize = atoi(val);
                        in = realloc(in, offsetof(struct tftphdr, th_data) + blocksize);
                        if (!in)
                        {
                            e = no_mem_error();
                            send_error(unicast_socket, in, EBADOPTS, e->errmess, NULL);
                            goto error;
                        }
                    }
                    else if (strcasecmp(p, "tsize") == 0)
                    {
                        int tsize = atoi(val);
                        /* Dummy zero length reception to mark endpoint */
                        if ((e2 = recvfunc(in->th_data, tsize, 0, client_handle)) != NULL)
                            goto client_error;
                    }
                    else
                    {
                        send_error(unicast_socket, in, EBADOPTS, "Unknown option", NULL);
                        goto error;
                    }

                    p = val + strlen(val) + 1;
                }

                if (expecting_oack || master_client)
                {
                    len = send_ack(unicast_socket, out, map, &last_acked);
                    last_acked = ntohs(out->th_block);
                    already_transmitted = true;
                }
                break;
            }

            case DATA:
            {
                int blocknum = ntohs(in->th_block) - 1;
                int size = n - offsetof(struct tftphdr, th_data);
                bool new_block = !GETMAPBIT(blocknum);

                /* Quick check of block number */
                if (num_blocks != -1 && blocknum >= num_blocks)
                {
                    send_error(unicast_socket, in, EBADOP, "Block number too high", NULL);
                    goto error;
                }

                SETMAPBIT(blocknum);

                /* ACK as soon as possible */
                if (master_client)
                {
                    len = send_ack(unicast_socket, out, map, &last_acked);
                    already_transmitted = true;
                }
                else
                    last_acked = first_clear_bit(map, last_acked);

                /* Tell our client */
                if (new_block)
                {
                    e2 = recvfunc(in->th_data, (u_long) blocknum * blocksize, size, client_handle);
                    if (e2)
                    {
                        int errnum;

                      client_error:
                        if (e2->errnum >= ERRORBASE && e2->errnum < ERRORBASE + 0x80)
                            errnum = e2->errnum - ERRORBASE;
                        else
                            errnum = EUNDEF;

                        send_error(unicast_socket, in, errnum, e->errmess, NULL);
                        goto error;
                    }
                }

                if (blocknum > highest_block)
                    highest_block = blocknum;

                /* Spot end of file */
                if (size < blocksize)
                {
                    /* Check we haven't received any higher-numbered blocks */
                    if (blocknum < highest_block)
                    {
                        send_error(unicast_socket, in, EBADOP, "Block too small", NULL);
                        goto error;
                    }
                    num_blocks = blocknum + 1;
                }

                if (last_acked == num_blocks)
                {
                    /* We've got everything. Hooray! */
                    finished = true;
                }

                break;
            }

            case ERROR:
                _inet_error.errnum = ntohs(in->th_code) + ERRORBASE;
                sprintf(_inet_error.errmess, "TFTP error %d: %s", ntohs(in->th_code), in->th_msg);
                goto error;

            default:
                send_error(unicast_socket, in, EBADOP, "Unknown TFTP operation", NULL);
                goto error;
        }
    }

    /* Successful exit */
    e = NULL;

  error:
    if (multicast_socket >= 0)
        socketclose(multicast_socket);
    if (icmp_socket >= 0)
        socketclose(icmp_socket);
    if (unicast_socket >= 0)
        socketclose(unicast_socket);
    free(map);
    free(out);
    free(in);

    return e;
}

