/*	Caradon Dialler for ISDN
	------------------------


Authors:	Anthony Frost, Acorn wrote the original Caradon dialler
		Paul Skirrow, Octopus Systems made the changes for ISDN:
		
		Paul Skirrow		Tel:		01473 728943
		Octopus Systems		Fax:		01473 270643
		9 Randwell Close	Email:		pskirrow@octosys.co.uk
		IPSWICH  IP4 5ES	WWW:		www.octosys.co.uk

Version:	0.18 (ISDN variant)

Compiler:	Acorn C release 5

Description:	Device interface for Omnitel ISDN code 

Manuals:	All PRM references refer to the RISC OS 3 PRM volumes 1-4 and 5a

Overview: 

Caradon is a dialler for the Acorn NC. It was originally for use with the modem
code,  but it was taken over by Paul Skirrow on 12th June 1997 to make it work with
the NC ISDN card. This version is based on the modem Caradon v0.14.


PPP and DeviceFS Versions
-------------------------
This dialler needs the serial stream variant of the PPP module for use with ISDN
(as opposed to the block driver variant). 

This module is for use with PPP v1.15 and it uses the device name "ISDNdata"
in the PPP.options file. If you are using a later version of PPP (1.16 onwards)
the device name must be changed to "ISDNdata:". It will also be necessary to
use DeviceFS v0.35 or later as PPP v1.16 uses the non-blocking I/O calls 
prvided in this version of DeviceFS and will crash with earlier versions.

Unfortunately we cannot simply include DeviceFS v0.35 in the ISDN card ROM
as it causes a problem with the Smart Card reader (it appears that the
DeviceFS in the NC ROM starts first and it is then replaced by the new DeviceFS
in the ISDN ROM but the Smart Card software doesn't know that its files
have been closed and fails to read the Smart Card).

We have also been using a version of PPP built which has a low stack usage
(the standard PPP module creates two 1024 byte buffers on the supervisor
stack and this caused the system to crash when used on an NC with ISDN).
It appears that this wasn't a problem and we're now using a standard
version of PPP.


Caradon Background
------------------
This version of Caradon originally came from Anthony Frost who says
it is version 1.14.  However, it differs from version 1.14 in the SrcFiler,
and there is no version 1.14 in CVS, so who knows what version it really was.

The source file "ticker.c" appears to do the same job using callbacks (so the
system will multi-task while dialling), but we're not sure whether that file
was ever used, so we started from the "module.c" file.


ISDN Dialling
-------------
The dialler opens devices#ctrl.$.ISDNdata initially and uses this for AT commands
and for the login phase (when using a Unix style login). It then closes this
file and starts PPP using just the ISDNdata device (since PPP doesn't want to use
AT commands ot see responses). 

PPP can disconnect by twiddling the DTR bit on ISDNdata and the dialler
can disconnect by twiddling the DT bit on ISDNctrl (which PPP doesn't
use).


Command Scripts
---------------
The command script comprises a series of send and expect strings, with one string
per line.

To ensure that standard modem scripts work with ISDN we disregard some
error messages. If the IGNORE_ERROR flag is set then we regard an "ERROR"
reply from ISDN as meaning "OK". This ensures that unknown configuration
commands, such as AT&C2, don't stop the script working. (Note that if ATDT
gives an error it will still be caught as the script will not look for an
OK reply).


PPP Communication
-----------------
Caradon and PPP work together. When Caradon has successfully dialled and
logged in (if a Unix style login is being used) it issues a PPPconnect command
with no parameters to start a PPP connecton. PPP looks in the InetDB:PPP.options
file for the options (which are generated by filegen).

PPP uses * commands to tell Caradon what state it is in. CDN_StartUp is issued
when PPP has connected and CDN_GoingDown is issued when PPP goes down.


GenRes
------
GenRes is a program in the Caradon source directory to put various files
from the d directory into a linkable object file. It creates a pointer to the
file in memory using the filename and it creates an integer variable holding
the files length using the name filename_len. For example, the onhook file
will cause two variables to be generated:
	onhook		points to file in memory
	onhook_len	holds the length of the file

cmhg v5.02
----------
This module uses cmhg502 to create the module header using irq entry
veneers and irq handlers. Later versions of cmhg work differently, so ensure
that cmhg502 is used when making this module.

Tue 22nd July 1997
------------------
Modified to make twiddle use ISDNctrl - so it can be used while PPP is using ISDNdata
Close files after completing dial script and before running PPP


Thu 24th July 1997
------------------
Bug fix: ISDN can return characters very rapidly and in blocks. The old Caradon
code didn't expect this and sometimes set the expect string after it had already
occurred. This has been fixed by looking for a match in the incoming string even
when no more characters are received (in case the expect string has changed).

Bug fix: old Caradon didn't check for incoming string buffer overflow. 

Thu 31st July 1997
------------------
Made Caradon work in NC model 1. Previous problems were caused by DeviceFS 0.34
in NC1 which didn't work with our PPP 1.16. Reverted to PPP 1.15 for now, but
note that this uses different device name syntax in the PPPconnect command.

Mon 04th August 1997
--------------------
Added ISDN messages for clear codes

Tue 05th August 1997
--------------------
Added code to read CMOS RAM and set ISDN configurations

Thu 07th August 1997
--------------------
Tidied up, removd unnecessary ATZs
Only send ISDN configs before dial the first time or if they have changed since last dial
When configs changed RMreinit ISDN module

Tue 12th August 1997
--------------------
Added code to return to PROCEED or PROCEEDC when CANCEL button clicked on retry screen

Thu 28th August 1997 (jfarrell)
-------------------------------
Changed to do DumpIt() and *rmreinit PPP on a callback instead of from registry service call.  
Switching into user mode in the service call caused further smart card events to be delivered
recursively to the registry state machine - which caused the state machine to break and the 
smart card not to be recognised.

Ditto for CARDVALID transition - registry enquiries and file I/O are not good things to
be doing from a service call handler!

Mon 8 September 1997 (jfarrell)
-------------------------------
Fix bug of failure to make NFS mount on next login after "connect, standby, un-standby, redial, 
card-out" sequence.  The problem was old filesystems left mounted under the names "NFSBoot" 
and "NCDHome" preventing new mounts being made.
Removed 5 second delay after IP-UP.

Thu 11 September 1997 (jfarrell)
--------------------------------
Fix bug of supervisor stack overflow caused by IPCP going up and down during MLPPP
connection establishment.  Only run NFSInit the first time IP comes up on the link (!online).  
Could be a bug in MLPPP that it doesn't hide the member link IPCP, but this works around it.

Fri 26 September 1997 (jfarrell)
--------------------------------
Previous change prevents crash but still getting IPCP loops with MLPPP.  Turn off VJ header
compression as a workaround - seems to prevent the IPCP loop.
*/

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <stdarg.h>
#include <ctype.h>
#include "kernel.h"


#ifdef ETHERNET
#include "cmhg_ether.h"
#else
#include "cmhg_modem.h"
#endif
#ifdef ISDN
#include "serial.h"
#include "callback.h"
#endif
#include "driver.h"
#include "screen.h"
#include "smartcard.h"
#include "swis.h"
#include "wimp.h"
#include "configs.h"

#include "Sockets/in.h"

#include "log.h"

#ifndef TRUE
#define FALSE 0
#define TRUE (!FALSE)
#endif


/*	Misc Constants
	--------------
*/

#define MAXSTRING 80		/* Max length of send or expect string in dial script */
#define INCOMINGLEN 256		/* Length if incoming string buffer */
#define IGNORE_ERROR TRUE 	/* Ignore ERROR response and treat it as OK except on ATDT command */

/*	ISDN Constants
	--------------

Ensure that we are compiling ISDN version. (In theory we
can support ETHERNET and MODEM versions too, but it is
untested with this version.
*/

#ifdef ETHERNET
error "Please compile using ISDN flag"
#endif

#ifdef MODEM
error "Please compile using ISDN flag"
#endif

#ifndef ISDN
error "Please compile using ISDN flag"
#endif



#ifdef MODEM
#define BUSY_STRING	"BUSY"
#define UNSUITABLE_STRING "NO CARRIER"
#define CANTDIAL_STRING	"NO DIALTONE"
#define SCRIPT_TIMEOUT	6000		/* Timeout if no response within 60s */
#endif

/*	ISDN Constants
	--------------
*/

#ifdef ISDN
#define ISDN_PATH 	"devices#ctrl:$.ISDNdata"
#define ISDNCTRL_PATH	"devices:$.ISDNctrl"
static char isdn_stream[] =  ISDN_PATH;
static char isdnctrl_stream[] = ISDNCTRL_PATH;
	
#define PROCEEDC	"file:/WWWDyn:ProceedC"			/* Main screen with change details button */
#define PROCEED		"file:/WWWDyn:Proceed"			/* Main screen without change details button */
#define TEMPFILE	"<Wimp$ScrapDir>.Sennen.HTMLtemp"	/* Temporary HTML filename */
#define TEMPPAGE 	"file:/WWWDyn:HTMLtemp" 		/* Temporary HTML, url for NewPage */
#if 0
#define BUSY_STRING	"CLEAR 17"		/* Not used for ISDN - we decode all CLEAR codes */
#define UNSUITABLE_STRING "CLEAR 63"		/* Not used for ISDN - we decode all CLEAR codes */
#define CANTDIAL_STRING	"CLEAR 145"		/* Not used for ISDN - we decode all CLEAR codes */
#endif
#define SCRIPT_TIMEOUT	2000			/* Timeout if no response within 20s */

extern char *clearmsg;				/* HTML template from source d directory */


/*	ISDN Clear Messages
	-------------------
	
Note that these messages may include HTML codes.
Move to messages file.
*/

struct clear_cause
{
  int clearcode;
  char *reason;
};


const static struct clear_cause clear_causes[] = 
{
  1, 	"Unassigned number - check the number. (For "		/* Unassigned number */
        "international calls ensure that you have a digital link "
        "- in some countries you need to use a special prefix such as 000)",
  2, 	"No route to specified transit network",
  3, 	"No route to destination",
  6, 	"B channel indicated is unacceptable",
  7, 	"Call awarded and being delivered in an established channel",
  16, 	"Normal (successful) call clearing",
  17, 	"The server is busy (try again later)",				/* Busy */
  18, 	"The server is not responding",
  19, 	"No answer from server",
  21, 	"Call rejected",
  22, 	"Number changed (called number is no longer assigned)",
  26, 	"Non-selected user clearing",
  27, 	"Destination out of order",
  28, 	"Invalid number format",
  29, 	"Facility rejected",
  30, 	"Response to STATUS enquiry",
  31, 	"Normal, unspecified clear",
  34, 	"No circuit/channel available",
  38, 	"Network out of order",
  41, 	"Temporary failure (try again later)",
  42, 	"Switching equipment congestion",
  43, 	"Access information discarded",
  44, 	"Requested circuit/channel not available",
  47, 	"Resources unavailable, unspecified",
  49, 	"Quality of service unavailable",
  50, 	"Requested facility not subscribed",
  57, 	"Bearer capability not authorized",
  58, 	"Bearer capability not presently available",
  63, 	"ISDN service is not available on the dialled number",	/* UDI service not available on dialled number */
  65, 	"Bearer capability not implemented",
  66, 	"Channel type not implemented",
  69, 	"Requested facility not implemented",
  70, 	"Only restricted digital information bearer capability is available",
  79, 	"Service or option not implemented, unspecified",
  81, 	"Invalid call reference value",
  82, 	"Identified channel does not exist",
  83, 	"A suspended call exists, but this call identity does not",
  84, 	"Call identity in use",
  85, 	"No call suspended",
  86, 	"Call having the requested call identity has been cleared",
  88, 	"Incompatible destination",
  91, 	"Invalid transit network selection",
  95, 	"Invalid message, unspecified",
  96, 	"Mandatory information element is missing",
  97, 	"Message type non-existent or not implemented",
  98, 	"Message not compatible with call state or message type "
  	"non-existent, or not implemented",
  99, 	"Information element non-existent or not implemented",
  100, 	"Invalid information element contents",
  101, 	"Message not compatible with call state",
  102, 	"Recovery on timer expiry",
  111, 	"Protocol error, unspecified",
  127, 	"Interworking, unspecified",
  145, 	"Data link could not be established -<br>check ISDN lead is plugged in",	/* No data link */
  162, 	"No line activation",
  255, 	"Reason unknown",
};


#endif



/*	CMHG Interface
	--------------
	
cmhg entry veneers for callbacks and upcalls
*/

extern int CDN_callback_entry  (_kernel_swi_regs *r, void *pw);
extern int CDN_callafter_entry (_kernel_swi_regs *r, void *pw);
extern int CDN_upcall_entry    (_kernel_swi_regs *r, void *pw);

/*	Misc/OS Routines
	----------------

*/

extern void *resources_base(void);

extern void render(char *, int, int *);
extern void osmodfree(char *);
extern char *osmodget(int);
extern void callback(int (*irq_entry)(), void *);
extern void callafter(int, int (*irq_entry)(), void *);
extern void removeticker(int (*irq_entry)(), void *);
extern int  ncregenq(char *, void *, int);
extern int  monotonic_time(void);
extern void oscli(char *);
extern void cliprompt(void);

#define vdu4() _swix(0x104, 0)
#define os_removecursors()  _swix(OS_RemoveCursors, 0)
#define os_restorecursors() _swix(OS_RestoreCursors, 0)


/*	Services that we respond to
	---------------------------

*/

#define Service_ModeChange         0x46
#define Service_ResourceFSStarting 0x60
#define Service_ShutDown           0x7E
#define Service_ShutdownComplete   0x80
#define Service_DiallerStatus      0xB4
#define Service_NCRegistryStatus   0xBA
 
#define int16 short
#define int32 long

typedef void (*P_FSStartingFN)(void *r0);

extern int matrix[], mini[];

/*	Serial Driver Interface for Modem Card
	--------------------------------------
*/

#ifdef MODEM
char *driver_name = "ModemCard";
int driver_dev    = 0;
int driver_baud   = 115200;
#endif

#ifndef ETHERNET
extern void Driver_Send(char *, int stream);
extern char *backdrop,    *connect,     *onhook,    *offhook,    *ppp;
extern int   backdrop_len, connect_len,  onhook_len, offhook_len, ppp_len;
#endif

/*	ISDN Variables
	--------------
*/

#ifdef ISDN
int instream = 0;	/* Input and output streams for ISDN */
int outstream = 0;	/* 0 is used to indicate stream is cloed */
#endif
int cardwrite=FALSE;	/* True if we can write to smart card or FALSE if card locked */


/*	Global Variables
	----------------

*/

void *pwp;			/* Module private word pointer */

int now;

int oldptr = 1;

int dialplease = CALLBACK_NOOP;	/* State of dialling system: no operation initially */

char *incoming;			/* Incoming response string from ISDN */
char *buffer;

char goodcode[20], lastcode[20];
char *nocode = "\xFFSaDdEAd";

BOOL restart   = FALSE;		/* restart flag is set if dial script has failed */
BOOL online    = FALSE;		/* online flag is set when connected */
BOOL redial    = FALSE;		/* true if we are redialling (ie *redial used) after a timeout disconnect */
BOOL silent    = TRUE;
BOOL doingit   = FALSE;		/* doingit is set when we schedule DoDial */
BOOL semaphore = FALSE;		/* callafter() ticker scheduled */

carddata card;			/* Smart card data */

struct in_addr innfs;

extern block_driver driver;

void DoDial(void);

extern char *dialscr[][2];


/*	Write Debug String to Log Buffer and optionally to Screen
	---------------------------------------------------------

Log a message to the cyclic message buffer, from where it may be retrieved for
later display with *CDN_Log.  Syntax as for printf(3s).

The debug message is also written to the screen if 'silent' is non-zero and 
this can be set by pressing DD in the browser or typeing *CDN_Silent 1 at the CLI.

*/

void debug(char *fmtstring, ...)
{
    va_list args;
    char buffer[256];
    
    va_start(args, fmtstring);
    vsprintf(buffer, fmtstring, args);
    va_end(args);

    message_add(buffer);
        
    if (!silent)
    {
        vdu4();
        printf("%s", buffer);
    }
}


/*	Replace \n and \r with \0
	-------------------------

*/

static char *Rip(char *text)
{
  char *c;

  while (c = strchr(text, '\n'), c)
    *c = '\0';
  while (c = strchr(text, '\r'), c)
    *c = '\0';
  return(text);
}


/*	Find String t in String s
	-------------------------

Returns pointer to first occurence of string t in string s
(using case insensitive comparison) or NULL of not present.

Similar to strstr but comparison is case insensitive.
Strings are null terminated.
If t is an empty string, s is returned.
*/

char *stristr (char *s, char *t)
{
  char *ss, *tt;
  int ls, lt;

  ls = strlen(s);
  lt = strlen(t);

  ss = s;
  tt = t;

  while (ls >= lt)
  {
    s = ss++;
    ls--;
    t = tt;

    while ((tolower(*s) == tolower(*t)) && *t != '\0')
    {
      s++;
      t++;
    }
    if ( *t == '\0' )
      return(--ss);
    else if ( *s == '\0' )
      return(0);
  }
  return(0);
}

/*	Close Input and Output Streams if Open
	--------------------------------------

Closes instream and outstream and sets both handles to 0 to indicate that they have been closed.

*/

static void close_streams(void)
{
  if (instream)
    serial_close_stream(instream);
  instream = 0;
  if (outstream)
    serial_close_stream(outstream);
  outstream = 0;
}

/*	Pause for cs Centiseconds
	-------------------------

Wait for cs centiseconds (using monotonic_time).

Note that start and monotonic_time are both 32 bit integers
so monotonic_time will go negative after 248 days. This isn't
a problem since the subtraction is also 32 bit signed, so we
won't ever get stuck waiting.

*/

void pause(int cs)
{
  int start = monotonic_time();

  while ((monotonic_time() - start) < cs)
  {
#ifdef MODEM
    (*driver) (DRIVER_POLL, driver_dev);
#endif
#ifdef ISDN
    flush_callbacks();	/* Ensure ISDN stack is runnning while we're waiting */
#endif
  }
}

#ifndef ETHERNET


/*	Display HTML Page with Variables Filled in 
	------------------------------------------
	
NewPagef(char *template, ...)

template is the HTML template string (which may be generated from a file in
the Caradon.d directory). The HTML template file may contain standard C printf
specifiers, such as %s and %d and whenever one is encountered it is replaced with
the next parameter.

Take care when using this function as it is important that the supplied parameters
match those needed by the template file (in type as well as number).

Returns 0 if successul, non-zero if failed.
*/

int NewPagef(char *fmtstring, ...)
{
  va_list args;
  FILE *out;

  debug ("Creating %s\n", TEMPFILE);
  if (out = fopen(TEMPFILE, "w"), out)
  {
    va_start(args, fmtstring);
    vfprintf(out, fmtstring, args);
    va_end(args);
    /* Set type of new file to HTML (0xFAF) : */
    _swix(OS_File, _INR(0, 2), 18, TEMPFILE, 0xFAF);
    fclose(out);
    debug ("Displaying: %s\n", TEMPPAGE);
    NewPage(TEMPPAGE);  /* Display the new page */
    return 0;
  }
  return 1;
}

/*	Display CLEAR Message for User
	------------------------------

A CLEAR has occurred while attempting to dial and connect so display an HTML
page telling the user what has happened.

On entry:	clear contains "CLEAR n" where n is the clear cause as a decimal string.

We display:

                     Sorry, the ISDN connection could not be established
                     
                     <reason>
                     
                     (CLEAR n)

<reason> is a simple explanation telling the user why it failed and perhaps
what could be wrong. The CLEAR code is displayed in brackets to help the user
identify or report the problem.

*/
#ifdef ISDN
void display_clear_msg(char *clear)
{
  char *reason="\0";
  int clearcode;
  int i;
  
  sscanf(clear, "CLEAR %d", &clearcode);	/* Extract clear code from CLEAR string */
  debug ("Display: clear %d\n", clearcode);
  
  for (i=0; i<sizeof(clear_causes)/sizeof(struct clear_cause); i++)  /* Table lookup of clear code */
  {
    if (clear_causes[i].clearcode==clearcode)
    {
      reason=clear_causes[i].reason;
      break;
    }
  }

  /* Use NewPagef to display HTML page with extra information */
  if (NewPagef(clearmsg, reason, clear, cardwrite ? PROCEEDC : PROCEED))
    NewPage("file:/WWWRoot:BootFail");    /* NewPagef failed, so just display the standard 
    					     "Network connecton could not be established" */
}
#endif

/*	Get Character from Modem/ISDN
	-----------------------------

On entry:	expect string contains test to look for in incoming string
On exit:	returns TRUE if expect string is in incoming string received so far 
		(case insensitive comparison using stristr).
		returns FALSE if no match is found and sets restart to
		TRUE if ERROR or CLEAR is found in incoming string

Read characters from modem or ISDN stream and build incoming string until
no more characters are available or expect string is found in the incoming
string.

New characters are appended to incoming string which is checked against
the expect string after every character. String is re-started if a \r or
\c is received or if the expect string appears in it.

If the incoming string already contains the expect string and no more characters
are received the match will still be found. Empty expect string will
always generate a match.

Sets restart variable and displays suitable message for user if a
bad response is received (including BUSY, no response etc).
*/

BOOL Driver_Get(char *expect, int stream)
{
  int c;
  static int rxchars = 0;	/* Number of characters on line (since last expect newline or last expect match) */

  do 
  {
#ifdef ISDN
    c = serial_read_byte(stream);
#endif
#ifdef MODEM
    c = ((*driver) (DRIVER_GETBYTE, driver_dev)), c >= 0 && !restart;
#endif
 
    if (isprint(c))
    { 
      debug("%c", c);
      incoming[rxchars++] = c;
      if (rxchars>=INCOMINGLEN) rxchars=0;  /* Restart the buffer if more than 256 chars received - shouldn't normally happen*/
      incoming[rxchars]   = '\0';
    }
  
    /* Check whether incoming string includes expect string, even if no new chars received.
    (this is important with ISDN as we may already have received the Login: prompt
    before our expect string was set to look for it!)
    */
    if (expect && stristr(incoming, expect))
    {
        rxchars = 0;
        return(TRUE);
    }

#ifdef ISDN
#if IGNORE_ERROR
    /* If IGNORE_ERROR option is set at compile time then we regard ISDN "ERROR" messages
       as meaning "OK" to ensure that modem command scripts with odd commands will still work
       on ISDN */
    if  (expect && toupper(expect[0])=='O' && toupper(expect[1])=='K' && stristr(incoming, "ERROR") )
    {
        rxchars = 0;
        return(TRUE);
    }
#endif
#endif

    if (c>=0)	/* Check for CLEAR or ERROR etc if a new char was received */
    {
#ifdef ISDN
    if ((strstr(incoming, "CLEAR")) !=NULL && (c == '\r' || c == '\n'))
      {
        debug("Clear detected\n");
        display_clear_msg(incoming);
        restart = TRUE;
        rxchars = 0;
      }
#else  
      if (strstr(incoming, BUSY_STRING))
      {
        NewPage("file:/WWWRoot:ServerB");
        restart = TRUE;
        rxchars = 0;
      }
      else if (strstr(incoming, UNSUITABLE_STRING))
      {
        NewPage("file:/WWWRoot:ErrorNC");
        restart = TRUE;
        rxchars = 0;
      }
      else if (strstr(incoming, CANTDIAL_STRING))
      {
        NewPage("file:/WWWRoot:ErrorDT");
        restart = TRUE;
        rxchars = 0;
      }
#endif
      else if (strstr(incoming, "ERROR") )
      {
        NewPage("file:/WWWRoot:BootFail");
        restart = TRUE;
        rxchars = 0;
      }
  
      if (c == '\r' || c == '\n')
      {
        rxchars = 0;
      }
    }
  }
  while (c >= 0 && !restart);

  return(strlen(expect) == 0);
}

/*	Wait for sleep cs
	-----------------
	
Wait for sleep cs calling Driver_Get while we are waiting.
*/

void delay(int sleep)
{
  int now = monotonic_time();
 
  while ((monotonic_time() - now) < sleep)
  {
    
#ifdef MODEM
    (*driver) (DRIVER_POLL, driver_dev);
#endif
#ifdef ISDN
    flush_callbacks();	/* Ensure ISDN stack is runnning while we're waiting */
#endif

    /* Allow input into out line buffer while waiting */
    if (instream) Driver_Get("", instream);
  }
}


/*	Send ISDN Configurations
	------------------------

Read ISDN configs from NC CMOS and send to the ISDN module using AT#
commands over the ISDNctrl stream. 

On exit:	Returns 0 if successful or non-zero if it fails.
		ISDN streams are closed and instream and oustream will both be 0

Doesn't check for errors from ISDNctrl.

If we are sending configurations for the first time we simply use the AT#
commands and follow it with an ATZ.

However, if we are changing the configurations we rmreinit the ISDN module
first to ensure that the Omnitel stack will accept and use the new configs.

*/

int send_config(void)
{
  NCConfig_ISDN_CMOS config;		/* NC configs read from NV RAM */
  static NCConfig_ISDN_CMOS lastconfig;	/* Configs as last sent to ISDN */
  static already_sent=FALSE;		/* Flag whether we have already sent configs */
  int config_changed=FALSE;

  close_streams();			/* Important before RMreinit */
  
  NCConfig_ISDN_ReadCMOS (&config);	/* Read configs from CMOS */

  /* Check whether any of the config fields are different to what we used before */
  if (already_sent)
  {
    /* Could do a memcmp here if we zeroed config before reading and were sure that
       NCConfig never wrote any spurious data into the structure - probably safer
       to do it this way but remember to update the comparisons if new configs are added */
    config_changed =  config.country != lastconfig.country
                   || config.operator !=lastconfig.operator
                   || strcmp(config.directory_number, lastconfig.directory_number)
                   || strcmp(config.subaddress, lastconfig.subaddress);
  }

  if (already_sent && config_changed)	/* RMreinit ISDN if we are changing configs */
  {
    debug ("RMreinit ISDN\n");
    oscli("RMreinit ISDN");
    debug ("Rmreinit OK");
  }

  if (!already_sent || config_changed)
  {
    outstream = serial_open_stream(isdnctrl_stream, SERIAL_OUTPUT);
    instream = serial_open_stream(isdnctrl_stream, SERIAL_INPUT);
    
    if (instream && outstream)
    {
      char buf[20];  /* Buffer for holding numeric configurations as strings */
      
      Driver_Send("AT#country=", outstream);
      sprintf(buf, "%d\n", config.country);
      Driver_Send(buf, outstream);
      Driver_Send("AT#operator=", outstream);
      sprintf(buf, "%d\n", config.operator);
      Driver_Send(buf, outstream);
      Driver_Send("AT#calling_number1=", outstream);
      Driver_Send(config.directory_number, outstream);
      Driver_Send("\nAT#calling_subaddress1=", outstream);
      Driver_Send(config.subaddress, outstream);
      Driver_Send("\nATZ\n", outstream);

      lastconfig=config;	/* Record what was sent to ISDN */
      already_sent=TRUE;	/* Flag that configs have been sent */
      close_streams();

      return 0;  /* Configs sent successfully */
    }
    close_streams();
  }
  return 1; /* Failed to open file, so return non-zero */
}


/*	Ensure that we are offline
	--------------------------

Ensure that we are off-line, as follows:
	Issue PPPdisconect to ensure PPP isn't connected
	Clear DTR line to make ISDN disconnect if connected
	
*/

void Twiddle(void)
{
  ioctl_t param;
  serial_ctrl_t ctrl;

  debug("*PPPDisconnect\n");
  oscli("PPPDisconnect");
  delay(100);
  
#ifdef MODEM
  (*driver) (DRIVER_CONTROLLINES, driver_dev, 0);
  delay(100);
  Driver_Send("ATZ\r", outstream);
#endif

#ifdef ISDN
  close_streams();
  if (outstream = serial_open_stream(isdnctrl_stream, SERIAL_OUTPUT), outstream)
  {
    memset(&param, '\0', sizeof(ioctl_t));

    debug("Twiddle 1 ");
    param.reason = IOCTL_CTRL_LINES;
    param.write = 0;
    param.read  = 1;
    ctrl.data   = serial_ioctl(outstream, &param);
  
    /* assert dtr */
    ctrl.bits.dtr = 1;
    param.write   = 1;
    param.data    = ctrl.data;
    serial_ioctl(outstream, &param);
  
#ifdef MODEM
    delay(50);
#endif
  
    /* clear dtr */
    debug("Twiddle 0 ");

    ctrl.bits.dtr = 0;
    param.write   = 1;
    param.data    = ctrl.data;
    serial_ioctl(outstream, &param);

#ifdef MODEM
    debug ("Twiddle ATZ ");
    delay(50);
    Driver_Send("ATZ\r", outstream);
#endif
    close_streams();
    debug("Twiddle OK\n");
  }
#endif
}

void DumpIt(BOOL filestoo)
{
  debug("DumpIt(%d)\n", filestoo);
  restart = TRUE;
  if (dialplease != CALLBACK_NOOP)
  {
    removeticker(CDN_callafter_entry, pwp);
    dialplease = CALLBACK_NOOP;
  }

  /*  Unmount NFS filesystems if requested (e.g. on Card Out event).
   *  We do this regardless of whether or not we think we have anything 
   *  currently mounted since it's harmless and far better than the
   *  alternative of possibly leaving mount names in use and being unable
   *  to remount them on next login.
   */
  if (filestoo)
  {
    _kernel_oserror *err;
    
    if ((err = _swix(NFS_Dismount, _INR(0, 1), 0, "NFSBoot")) != NULL)
    	debug("DumpIt: Dismount of NFSBoot failed: %s (%d)\n", err->errmess, err->errnum);

    if ((err =_swix(NFS_Dismount, _INR(0, 1), 0, "NCDHome")) != NULL)
    	debug("DumpIt: Dismount of NCDHome failed: %s (%d)\n", err->errmess, err->errnum);    
  }

  Twiddle();
#ifdef MODEM
  pause(100);
#endif  

  doingit = FALSE;
}


/*	Mount NFS
	---------
*/

static BOOL DoNFS(struct in_addr ina)
{
  char *mount;
  int length;
  _kernel_oserror *err;
  
  length = ncregenq("NFS_MOUNT", mount, 0);
  mount = malloc(length + 4);
  if (length == 0 || mount == NULL)
    return(FALSE);
  ncregenq("NFS_MOUNT", mount, length + 2);
  debug("NFS_MOUNT: %s\n", mount);
  
  if ((err = _swix(NFS_SetUser, _INR(0, 2), inet_ntoa(ina), "nobody", "")) != NULL)
  {
    debug("DoNFS: login failed: %s (%d)\n", err->errmess, err->errnum);
    free(mount);
    return(FALSE);
  }

  if ((err = _swix(NFS_Mount,   _INR(0, 2), inet_ntoa(ina), "NFSBoot", mount)) != NULL)
  {
    debug("DoNFS: mount failed: %s (%d)\n", err->errmess, err->errnum);
    free(mount);
    return(FALSE);
  }

  free(mount);
  return(TRUE);
}
#endif

#ifdef ETHERNET

static void DumpIt(BOOL filestoo)
{
  if (dialplease != CALLBACK_NOOP)
  {
    removeticker(CDN_callafter_entry, pwp);
    dialplease = CALLBACK_NOOP;
  }
  if (filestoo)
    _swix(NFS_Dismount, _INR(0, 1), 0, "NCDHome");
}

static BOOL DoNFS(struct in_addr ina)
{
  char *mount;
  int length;

  length = ncregenq("NFS_MOUNT", mount, 0);
  mount = malloc(length + 4);
  if (length == 0 || mount == NULL)
    return(FALSE);
  ncregenq("NFS_MOUNT", mount, length + 2);

  if (_swix(NFS_SetUser, _INR(0, 2), inet_ntoa(ina), card.loginid,
            card.loginsecret))
  {
    free(mount);
    return(FALSE);
  }

  if (_swix(NFS_Mount, _INR(0, 2), inet_ntoa(ina), "NCDHome", mount))
  {
    free(mount);
    return(FALSE);
  }
  free(mount);
  return(TRUE);
}
#endif

void NFS_Init(void)
{
  char *url = NULL;
  int nfsfl, urllen;
  proxy server;
  struct in_addr ina;

  if (!redial)
  {
    urllen = ncregenq("URL_INIT", url, 0);
    url = malloc(urllen + 4);
    if (url && urllen)
    {
      ncregenq("URL_INIT", url, urllen + 2);
      debug("URL_INIT: %s\n", url);
      NewPage(url);
      sprintf(buffer, "-url %s", url);
      _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), "NCFresco$Home",
                        buffer, strlen(buffer), 0);
      _swix(OS_SetVarVal, _INR(0, 2) | _IN(4), "NCFresco$Welcome",
                        buffer, strlen(buffer), 0);
      free(url);
    }
  }
  ncregenq("NFS_TYPE", &nfsfl, 4);
  debug("NFS_TYPE: %d\n", nfsfl);  
  if (nfsfl)
  {
    ncregenq("FSERV_PRIMARY", &server, sizeof(proxy));
    ina.s_addr = server.addr;
    if (DoNFS(ina))
    {
      innfs = ina;
    }
    else
    {
      ncregenq("FSERV_BACKUP", &server, sizeof(proxy));
      ina.s_addr = server.addr;
      if (DoNFS(ina))
        innfs = ina;
      else
        memset(&innfs, '\0', sizeof(struct in_addr));
    }
    if (innfs.s_addr)
    {
      message_block mb;

      memset (&mb, '\0', sizeof(message_block));
      mb.header.size   = 32;
      mb.header.action = 0x4AF84;
      _swix(TaskModule_SendMessage, _INR(0, 5), 0, &mb, 0, 0, 0, 0);
#ifndef ETHERNET
      if (!silent)
        vdu4();
      if (redial)
      {
        _swix(TaskModule_StartTask, _INR(0, 2),
              "Obey -c NFS::NFSBoot.$.!NFSBoot.!Redial", 0, 0);
      }
      else
      {
        _swix(TaskModule_StartTask, _INR(0, 2),
              "Obey -c NFS::NFSBoot.$.!NFSBoot.!Run", 0, 0);
      }
#endif
    }
  }
}


/*	Caradon Module Callback Handler
	-------------------------------


Action depends on the state of dialplease:

	0 CALLBACK_NOOP		No action
	1 CALLBACK_DODIAL	Dial ISP, log in and start PPP
	2 CALLBACK_CONNECT	Display connect message and schedule SAYUP to run 5s time
	3 CALLBACK_BADCARD	Display "bad card" message
	4 CALLBACK_NOSERVER	Display no server message
	5 CALLBACK_WRITE	Writes data to Smart card
	6 CALLBACK_SAYUP	?
	7 CALLBACK_NOCARD	Drop the line	
        8 CALLBACK_CARDVALID    Read smartcard bootblock, create files, present Proceed screen.

*/

int CDN_callback_handler (_kernel_swi_regs *r, void *pw)
{
  if (pw != pwp)
    return(1);

  debug("Callback: %d\n", dialplease);    
  switch(dialplease)
  {
  case CALLBACK_WRITE:
    {
      int ret;
      static int tries = 0;
    
      err = _swix(NCRegistry_Write, _INR(0, 2) | _OUT(0), 0, 0, 0, &ret);
      if (err == NULL && ret == -7 && tries < 10)
      {
        dialplease = CALLBACK_WRITE;
        callafter(100, CDN_callafter_entry, pwp);
      }
      else if (err != NULL || tries > 9)
      {
        NewPage("file:/WWWRoot:DamageCrd");
        tries = 0;
      }
      else
      {
        tries = 0;
      }
    }
    break;

  case CALLBACK_BADCARD:
    NewPage("file:/WWWRoot:InvalidCrd");
    dialplease = CALLBACK_NOOP;
    semaphore  = FALSE;
    break;

  case CALLBACK_NOSERVER:
    NewPage("file:/WWWRoot:ServerNR");
    dialplease = CALLBACK_NOOP;
    doingit = FALSE;
    Twiddle();
    break;

  case CALLBACK_NOCARD:
    /* Card removed, or smartcard layer (re-)starting - drop the connection (if any).
     */
    dialplease = CALLBACK_NOOP;
    doingit = FALSE;
    DumpIt(TRUE);

#if 0
    /* The following seems not to be necessary with PPP 1.16, and it caused the
       registry to crash on card re-insertion due to the DCI driver list having
       become invalid.
     */

    /* PPP sometimes remembers username/password across connects, so *rmreinit it */
    _swix(OS_Module, _INR(0, 1), 3, "PPP");

#endif

    break;
 
  case CALLBACK_CARDVALID:
    dialplease = CALLBACK_NOOP;
    doingit = FALSE;
   
    if (strcmp(lastcode, nocode) == NULL)
    {
      lastcode[0] = '\0';
    }
    strcpy(goodcode, lastcode);
    
    CreateFiles(&card);
     
    if (ncregenq("CLIENT_UPDATE", &cardwrite, 4) < 0)
    {
      NewPage("file:/WWWRoot:DamageCrd");
      break;
    }

#ifndef ETHERNET
    if (card.loginid == NULL || card.pstnnum == NULL
        || card.loginsecret == NULL || strlen(card.loginid) == 0
        || strlen(card.pstnnum) == 0 || strlen(card.loginsecret) == 0)
    {
      NewPage("file:/WWWDyn:EnterNNPC");
    }
    else 
      NewPage (cardwrite ? PROCEEDC : PROCEED);
#else
    if (card.loginid == NULL || card.loginsecret == NULL
        || strlen(card.loginid) == 0 || strlen(card.loginsecret) == 0)
    {
      NewPage("file:/WWWDyn:EnterNPC");
    }
    else
    {
      _swix(OS_SetVarVal, _IN(0) | _IN(2) | _IN(4), "Sennen$Newpage", -1, 0);
      NFS_Init();
    }
#endif
    break;
    
#ifndef ETHERNET
  case CALLBACK_DODIAL:
    {
      dialplease = CALLBACK_NOOP;
      online = FALSE;
      DoDial();
    }
    break;

  case CALLBACK_SAYUP:
    dialplease = CALLBACK_NOOP;
    _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, 4); /* Up */
    screen_redraw(-1);
    if (!online)
    {
        online = TRUE;
        NFS_Init();
    }
    break;

  case CALLBACK_CONNECT:
    {
      debug("Callback_connect\n");
      doingit = FALSE;
      
      /* If 'online' is true, IPCP went up and down but the link wasn't lost.
       */
      if (!online)
      {
        render(connect, connect_len, scale());
        removeticker(CDN_callafter_entry, pw);
      }
      
      debug("Up\n");

      dialplease = CALLBACK_SAYUP;
#ifdef ISDN
      callafter(1, CDN_callafter_entry, pwp);   /* why wait? */
#else
      callafter(500, CDN_callafter_entry, pwp);
#endif
    }
    break;
#endif
  }
  return(1);
}

/*	Caradon Module Callafter Handler
	--------------------------------

*/

int CDN_callafter_handler (_kernel_swi_regs *r, void *pw)
{
  if (pw == pwp)
    callback(CDN_callback_entry, pw);

  return(1);
}


/*	Send String to Driver
	---------------------

Send string to the driver, which may be a modem on a block driver 
serial port, or the ISDN device.                                                                                                                                                                                                                                                                                                                                        
Just sends bytes in string - doesn't add \n or \r
*/

#ifndef ETHERNET
void Driver_Send(char *string, int sendstream)
{
  debug("%s", string);
  while (*string)
  {
#ifdef MODEM
  while ((*driver) (DRIVER_PUTBYTE, driver_dev, string[loop]) == -1)
    (*driver) (DRIVER_POLL, driver_dev);
#endif
#ifdef ISDN
    if (sendstream)	/* Ensure stream is open */
    {
      while (serial_write_byte(sendstream, *string) != 1)
        ;
    }
    flush_callbacks();	/* Give ISDN stack a chance to send the character */

#endif   
    string++;
  }
}


/*	Get Number Prefix from CMOS
	---------------------------

Read CMOS byte to determine number prefix.
Bits in CMOS byte 0x9E are:

	5	Set for P (pulse dialling), clear for T (Tone dialling)
	0-3	Value 0 indicates no other prefix
		Values 1-10 indicate prefix digit 0-9
		Value 11 indicates *
		Value 12 indicates #
	4	If set add 'W' to dial string (after above prefix), otherwise add ','
		 
Typical returned strings:
	T	Tone dial
	P	Pulse dial
	T9,	Tone dial, 9 for outside line

Note that the ISDN module will ignore T or P for Tone or
Pulse dialling, so we just pass it on here.

*/

char *cmos_number(void)
{
  static char phone[20];
  int byte;

  _swix(OS_Byte, _INR(0, 1) | _OUT(2), 161, 0x9E, &byte);

#ifdef modem
  if (byte & 0x20)
    phone[0] = 'P';
  else
    phone[0] = 'T';
#endif
  if (byte & 0x0F)
  {
    if ((byte & 0x0F) < 11)
      phone[1] = (byte & 0x0F) - 1 + 0x30;
    else if ((byte & 0x0F) == 11)
      phone[1] = '*';
    else if ((byte & 0x0F) == 12)
      phone[1] = '#';
    if (byte & 0x10)
      phone[2] = 'W';
    else
      phone[2] = ',';
    phone[3] = '\0';
  }
  else
  {
    phone[1] = '\0';
  }
  return(phone);
}


/*	Do Dial Operation
	-----------------

Dial the service provider and display suitable status messages.
The dial operation is controlled by a script file containing commands
and expect strings.

If the script doesn't complete within SCRIPT_TIMEOUT we report "Sorry, the
server is not responding". Note that this doesn't indicate whether we saw
an ALERT or a CONNECT or where the problem was.

*/

void DoDial(void)
{
  char expect[MAXSTRING], send[MAXSTRING];
  FILE *fin;
  int step = 0;

  if (!silent)
  {
    vdu4();
  }

  Screen_CacheModeInfo();
  render(backdrop, backdrop_len, scale());

  send_config();		/* Send configuration from NVRAM to ISDN */

  if (CreateFiles(&card) == FALSE)
  {
    doingit = FALSE;
    return;
  }

  debug("CreateFiles completed\n");
  os_removecursors();

#ifdef MODEM
  (*driver) (DRIVER_INITIALISE,   driver_dev);
  (*driver) (DRIVER_WORDFORMAT,   driver_dev, 0);
  (*driver) (DRIVER_CONTROLLINES, driver_dev, 3);
  (*driver) (DRIVER_TXSPEED,      driver_dev, driver_baud);
  (*driver) (DRIVER_RXSPEED,      driver_dev, driver_baud);
#endif

#ifdef ISDN
  debug("Opening ISDN stream\n");
  instream  = serial_open_stream(isdn_stream, SERIAL_INPUT);
  outstream = serial_open_stream(isdn_stream, SERIAL_OUTPUT);
  debug("Serial_open_stream OK\n");

  if (instream == 0 || outstream == 0)
  {
    debug("Closing streams\n");
    close_streams();
    doingit = FALSE;
    return;
  }

#ifdef ISDN
  debug ("Flush ISDN\n");
  serial_flush(instream); 
  serial_flush(outstream);
#else
  do  /* Flush input stream */
  {
    c = serial_read_byte(instream);
  } while (c >= 0);
  debug("Flush OK\n");
#endif

#endif

#ifdef MODEM
  delay(50);  /* WHY? */
#endif
  if (fin)
    fclose(fin);
  debug("Opening script\n");
  if (fin = fopen("<Wimp$ScrapDir>.Sennen.Files.Script", "r"), fin == NULL)
  {
    close_streams();
    doingit = FALSE;
    return;
  }

  debug("render onhook\n");
  render(onhook, onhook_len, scale());
#ifdef MODEM
  delay(50);
#endif
  do
  {
    step = 0;
    if (restart)
    {
      render(onhook, onhook_len, scale());
      Twiddle();
      restart = FALSE;
      delay(500);
    }
    render(offhook, offhook_len, scale());
   
    debug ("Running dial script\n");
    fseek(fin, 0, SEEK_SET);	/* Start at beginning of script file */
    while (!restart && fgets(expect, MAXSTRING, fin))
    {
      int sentat = monotonic_time();
      
      Rip(expect);		/* Null terminate the string */
      debug ("Expect: %s\n", expect);
      if (fgets(send, MAXSTRING, fin))
        Rip(send);
      else
        send[0]='\0';	/* Failed to read string, so use empty string */
      debug("<");
      do
      {
#ifdef MODEM
        (*driver) (DRIVER_POLL, driver_dev);
#endif
#ifdef ISDN
        flush_callbacks();	/* Ensure ISDN stack is runnning while we're waiting */
#endif

        /* If script doesn't complete within SCRIPT_TIMEOUT period then generate an error:
           "Sorry, the server is not responding" */
        if ((monotonic_time() - sentat) > SCRIPT_TIMEOUT)
        {
          restart = TRUE;
          NewPage("file:/WWWRoot:ErrorNC");
        }
      } while (!Driver_Get(expect, instream) && !restart);
 
      debug("Send:%s\n", send);
      
      /* Send the send string and a \r unless it is empty or a single space
         or the restart flag is set in which case send nothing, not even the \r */
      if (!restart && strlen(send) > 0 && strcmp(send, " ")!=0)
      {
#ifdef MODEM
        delay(50);
#endif
        Driver_Send(send, outstream);
        if (strcmp(send, "ATDT") == 0)
        {
          Driver_Send(cmos_number(), outstream);
          Driver_Send(card.pstnnum, outstream);
        }
        Driver_Send("\r", outstream);
      }
    }
  } while (FALSE && restart);
  fclose(fin);
  
  delay(10);			/* Ensure output data has been written from buffer 
  				   (DeviceFS will block when we try to close the stream if there is
  				   any data in the buffer and the system will freeze as callbacks
  				   will not be running for the ISDN stack) */
  debug("script end  ");
  close_streams();		/* Close the ISDNdata#ctrl stream so we can just open the data stream */
  debug("streams closed");
  if (!restart)
  { 
    debug("PPP render");
    render(ppp, ppp_len, scale());
 
    flush_callbacks();
    debug ("PPPconnect\n");
    oscli("PPPConnect");
    debug("PPP OK\n");
    flush_callbacks();

    dialplease = CALLBACK_NOSERVER;	/* Generate "No Server" message if no response in 30s */
    callafter(3000, CDN_callafter_entry, pwp);
    restart = TRUE;
  }
  else /* if (!redial) */
  {
    debug("Failed...\n");
    dialplease = CALLBACK_NOOP;
    doingit = FALSE;
    Twiddle();
    _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, 0); /* down */
  }
  os_restorecursors();
  debug ("End...");
}
#endif

/* undo URL translation of '+' for ' ' in place */
void plus_to_space(char *linebuff, int len)
{
  for (; len; linebuff++, len--)
  {
    if (*linebuff == '+')
      *linebuff = 0x20;
  }
}

/*	Undo URL & Encoding of Special Characters
	-----------------------------------------

Undo URL translation of special chars to %xx format in place -
returns new string length 
*/

char *UnEscape(char *i)
{
  char hex, *l, *o = i;
  int bytes, len;

  len = strlen(i);
  plus_to_space(i, len);
 
  while (len)
  {
    if (*i++ == '%')
    {
      hex = (*i >= 'A' ? ((*i & 0xdf) - 'A') + 10 : *i - '0') * 16 + (*(i + 1) >= 'A' ? ((*(i + 1) & 0xdf) - 'A') + 10 : *(i + 1) - '0');
      *(++i - 2) = hex;

      for (l = ++i, bytes = len - 3; bytes; bytes--,l++)
        *(l-2) = *l;
      len -= 3;
      i   -= 2;
      continue;
    }
    len--;
  }
  *i = 0;
  return(o);
}

/*	Caradon Module * Commands
	-------------------------


*/

_kernel_oserror *Caradon_cmd (char *arg_string, int argc, int cmd_no, void *pw)
{
  switch (cmd_no)
  {
#ifndef ETHERNET
  case CMD_ReDial:
    debug("*CDN_Redial\n");
    if (doingit)
    {
      NewPage("file:/WWWRoot:BahHumbug"); 
    }
    else
    {
      ioctl_t param;
      int dcd=0;

#ifdef ISDN
      if (outstream)	/* Use IOctl 6 to read ISDN emulated DCD line */
      {
        memset(&param, '\0', sizeof(ioctl_t));
        param.reason = 6;
        param.read = TRUE;
        _swix(OS_Args, _INR(0, 2), 9, outstream, &param);
        dcd=( (param.data>>19) & 1);
      }
#else
      int lines = ((*driver) (DRIVER_MODEMCONTROL, driver_dev));
      dcd=(lines & 8);	/* DCD state from block driver*/
#endif
      if (!dcd)		/* DCD offline */
      {
        restart = FALSE;
        redial  = TRUE;
        doingit = TRUE;
        dialplease = CALLBACK_DODIAL;
        callafter(100, CDN_callafter_entry, pwp);
      }
      else
      {
        _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, 4); /* Up */
      }
    }
    break;

  case CMD_Twiddle:
    {
      debug("*CDN_Twiddle\n");
      Twiddle();
      _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, 0); /* down */
    }
    break;

  case CMD_CDN_StartUp:
    {
      debug("*CDN_Startup\n");
      dialplease = CALLBACK_CONNECT;
      callafter(10, CDN_callafter_entry, pwp);            
    }
    break;

  case CMD_CDN_GoingDown:
    {
    debug("*CDN_GoingDown\n");

/*       Twiddle(); */
      _swix(OS_ServiceCall, _INR(1, 2), Service_DiallerStatus, 0); /* down */
    }
    break;

  case CMD_CDN_Dial:
    debug("*CDN_Dial\n");
    if (doingit)
    {
      NewPage("file:/WWWRoot:BahHumbug"); 
    }
    else
    {
      restart = FALSE;
      redial  = FALSE;
      doingit = TRUE;
      dialplease = CALLBACK_DODIAL;
      callafter(100, CDN_callafter_entry, pwp);
     }
    break;

#endif
  case CMD_MWait:
    {
      debug("*CDN_MWait\n");
      pause(500);
    }
    break;

#ifdef ETHERNET
  case CMD_CDN_StartNFS:
    {
      NFS_Init();
    }
    break;
#endif
  case CMD_CDN_Change:
    {
      BOOL needssaving = FALSE;
      char *and, *endbit, *nextbit, *value;
      char buffer[256], code1[20], code2[20], codec[20];
      int codes = 0, length, ret;
   
   
      debug("*CDN_Change\n");
      strcpy(buffer, strchr(arg_string, '?') + 1);
      Rip(buffer);
      nextbit = buffer;
      endbit  = buffer + strlen(buffer);
#ifndef ETHERNET
      NewPage(PROCEEDC);
#endif   
      while (nextbit < endbit)
      {
        if (and = strchr(nextbit, '&'), and != NULL)
          *and = '\0';
        length = strlen(nextbit);
     
        if (strncmp(nextbit, "num=", strlen("num=")) == NULL)
        {
          value = nextbit + strlen("num=");
          if (card.pstnnum)
            free(card.pstnnum);
          card.pstnnum = malloc(strlen(value) + 4);
          if (card.pstnnum == NULL)
            break;
          strcpy(card.pstnnum, UnEscape(value));
          _swix(NCRegistry_Write, _INR(0, 2) | _OUT(0),
                "PSTN_NUM", card.pstnnum, strlen(card.pstnnum) + 1, &ret);
          needssaving = TRUE;
        }
        else if (strncmp(nextbit, "name=", strlen("name=")) == NULL)
        {
          value = nextbit + strlen("name=");
          if (card.loginid)
            free(card.loginid);
          card.loginid = malloc(strlen(value) + 4);
          if (card.loginid == NULL)
            break;
          strcpy(card.loginid, UnEscape(value));
          _swix(NCRegistry_Write, _INR(0, 2) | _OUT(0),
                "LOGIN_ID", card.loginid, strlen(card.loginid) + 1, &ret);
          needssaving = TRUE;
        }
        else if (strncmp(nextbit, "pass=", strlen("pass=")) == NULL)
        {
          value = nextbit + strlen("pass=");
          if (card.loginsecret)
            free(card.loginsecret);
          card.loginsecret = malloc(strlen(value) + 4);
          if (card.loginsecret == NULL)
            break;
          strcpy(card.loginsecret, UnEscape(value));
          _swix(NCRegistry_Write, _INR(0, 2) | _OUT(0),
                "LOGIN_SECRET", card.loginsecret, strlen(card.loginsecret) + 1, &ret);
          needssaving = TRUE;
        }
        else if (strncmp(nextbit, "code=", strlen("code=")) == NULL)
        {
          value = nextbit + strlen("code=");
          UnEscape(value);
          _swix(NCRegistry_Authenticate, _INR(0, 1), value, strlen(value));
          strcpy(lastcode, value);
          NewPage("file:/WWWRoot:Checking");
          if (!semaphore)
          {
            semaphore  = TRUE;
            dialplease = CALLBACK_BADCARD;
            callafter(1000, CDN_callafter_entry, pwp);
          }
        }
        else if (strncmp(nextbit, "code1=", strlen("code1=")) == NULL)
        {
          value = nextbit + strlen("code1=");
          strcpy(code1, value);
          codes |= 1;
        }
        else if (strncmp(nextbit, "code2=", strlen("code2=")) == NULL)
        {
          value = nextbit + strlen("code2=");
          strcpy(code2, value);
          codes |= 2;
        }
        else if (strncmp(nextbit, "codec=", strlen("codec=")) == NULL)
        {
          value = nextbit + strlen("codec=");
          strcpy(codec, value);
          codes |= 4;
        }
        nextbit += (length + 1);
      }
      if (needssaving)
      {
        _swix(NCRegistry_Write, _INR(0, 2) | _OUT(0), 0, 0, 0, &ret);
        if (ret == -7)
        {
          dialplease = CALLBACK_WRITE;
          callafter(50, CDN_callafter_entry, pwp);
        }
        CreateFiles(&card);
      }

      if (codes == 7)
      {
        if (strcmp(code1, code2) || strcmp(codec, goodcode))
        {
          NewPage("file:/WWWRoot:BadCodes");
        }
        else
        {
          codes = 8; /* Write locking code */
          _swix(NCRegistry_ChangeSmartCardCHV, _INR(0, 2), 1, code1, strlen(code1));
#ifndef ETHERNET
          NewPage(PROCEEDC);
#else
          NewPage("ncfrescointernal:close");
#endif
        }
      }
    }
    break;

  case CMD_CDN_MakeFiles:
    {
      debug("*CDN_Makefiles\n");
      CreateFiles(&card);
    }
    break;

  case CMD_CDN_Repoint:
    {
      message_block mb;

      debug("*CDN_Repoint\n");
      memset (&mb, '\0', sizeof(message_block));
      mb.header.size   = 32;
      mb.header.action = 0x4AF84;
      _swix(TaskModule_SendMessage, _INR(0, 5), 0, &mb, 0, 0, 0, 0);
    }
    break;

  case CMD_CDN_Silent:
    {
      silent = (atoi(arg_string) != 0);
    }
    break;
 
  case CMD_CDN_Log:
    {
      int i;
      
      for (i = message_num(); i >= 0; i--)
          printf("%s", message_str(i));
    }
    break;
 }
  return (NULL);
}

/*	Caradon Module Finalisation Code
	--------------------------------
*/

_kernel_oserror *Caradon_modfinal (int fatal, int podule, void *pw)
{
  _swix(ResourceFS_DeregisterFiles, _IN(0), resources_base());
  osmodfree(incoming);
  osmodfree(buffer);
  return(NULL);
}

/*	Caradon Module Service Handler
	------------------------------

*/

_kernel_oserror *main_service(int service, _kernel_swi_regs *r, void *pw)
{
  int scstatus, scchange;
 
  switch (service)
  {
  case Service_ResourceFSStarting:
    debug("Service_ResourceFSStarting\n");
    ((P_FSStartingFN)(r->r[2]))(resources_base());
    break;

  case Service_NCRegistryStatus:
    scstatus = r->r[2];
    scchange = r->r[4];
    if (semaphore && (scstatus & scchange) != 0)
    {
      removeticker(CDN_callafter_entry, pw);
      semaphore = FALSE;
    }
    debug("Service_NCRegistryStatus - status %02X delta %02X\n", scstatus, scchange);
#if FALSE
    {
      FILE *fout;
      if (fout = fopen("<Wimp$ScrapDir>.Sennen.Service", "a"), fout != NULL)
      {
        fprintf(fout, "Status %02X Delta %02X\n", scstatus, scchange);
        fclose(fout);
      }
    }
#endif
    if ((scstatus & 0x01) == 0) /* No card */
    {
      strcpy(goodcode, nocode);
      strcpy(lastcode, nocode);
      if ((screen_size.x >> screen_eig.x) >= 1024)
      {
        NewPage("file:/WWWRoot:InsertCVB");
      }
      else if ((screen_size.x >> screen_eig.x) >= 800)
      {
        NewPage("file:/WWWRoot:InsertCB");
      }
      else
      {
        NewPage("file:/WWWRoot:InsertC");
      }
      _swix(Wimp_CreateMenu, _IN(1), -1);

      /* no semaphore - using callback() not callafter() */
      dialplease = CALLBACK_NOCARD;
      callback(CDN_callback_entry, pwp);
    }
    else if ((scstatus & 0x10 & scchange) != 0) /* Card Locked */
    {
      NewPage("file:/WWWRoot:EnterC");
    }
    else if ((scstatus & 0x01 & scchange) != 0) /* Card just inserted */
    {
      NewPage("file:/WWWRoot:Checking");
      if (!semaphore)
      {
        semaphore  = TRUE;
        dialplease = CALLBACK_BADCARD;
        callafter(1000, CDN_callafter_entry, pwp);
      }
    }
    else if ((scstatus & 0x20 & scchange) != 0)
    {
      if ((scstatus & 0x08) == 0)
        NewPage("file:/WWWRoot:SaveCode");
    }
    else if ((scstatus & 0x100 & scchange) != 0) /* Bad Auth */
    {
      if ((scstatus & 0x08) == 0)
      {
        NewPage("file:/WWWRoot:DamageCrd");
      }
      else
      {
        NewPage("file:/WWWRoot:InvalidCde");
      }
    }
    else if ((scstatus & 0x04 & scchange) != 0) /* Card inserted and valid */
    {
      /* no semaphore - using callback() not callafter() */
      dialplease = CALLBACK_CARDVALID;
      callback(CDN_callback_entry, pwp);
  
    }
    else if ((scstatus & scchange) != 0)
    {
      NewPage("file:/WWWRoot:InvalidCrd");
    }
    break;

  case Service_ModeChange:
    debug("Service_ModeChange\n");
    Screen_CacheModeInfo();
    break;

  case Service_ShutDown:
    debug("Service_Shutdown\n");
    if (doingit)
    {
      r->r[1] = 0;
    }
    break;

  case Service_ShutdownComplete:
    debug("Service_ShutdownComplete\n");
    DumpIt(FALSE);
    break;
  }

  return(NULL);
}

/*	Caradon Module Initialisation
	-----------------------------

*/

_kernel_oserror *Caradon_modinit (char *cmd_tail, int podule_base, void *pw)
{
  pwp = pw;

  _swix(ResourceFS_RegisterFiles, _IN(0), resources_base());
  incoming = osmodget(INCOMINGLEN);
  buffer   = osmodget(BUFSIZ);
  Screen_CacheModeInfo();
  memset(&card, '\0', sizeof(carddata));

  return(NULL);
}
