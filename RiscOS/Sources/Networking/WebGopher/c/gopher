/* -*-c-*- */

/*
 * Program:	Gopher.c - main source file for Gopher transport module
 *
 * Project:	Fresco project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@ant.co.uk
 *
 * Date:	11 May 1995
 * Last Edited:	13 May 1995
 *
 * Copyright 1995 by ANT Limited
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"
#if 0
#include "netdb.h"
#include "socket.h"
#include "ioctl.h"
#include "in.h"
#include "sys/time.h"
#include "sys/types.h"
#include "sock_errno.h"
#else
#include "tcplibs.h"
#endif

#include "status.h"

#include "gopherpub.h"

#include "gopher.h"
#include "files.h"

extern int errno;

/**********************************************************************/
/*
 * Global definitions
 */

#ifndef DEBUG
#define DEBUG 0
#endif

#ifndef TESTMODE
#define TESTMODE 0
#endif

#define Internet_Event	19

/**********************************************************************/
/*
 * Error definitions
 */

/* Error definitions */
typedef enum
{
    err_NO_SUCH_HOST,
    err_CANT_FIND_SERVICE,
    err_CANT_FIND_PROTOCOL,
    err_CANT_MAKE_SOCKET,
    err_CANT_CONNECT,
    err_BAD_IOCTL,
    err_NO_MEMORY,
    err_BAD_MAGIC,
    err_CANT_OPEN_FILE,
    err_CANT_OPEN_BODY,
    
    err_LAST_ERROR
    } error_numbers;

static char *err_strings[] =
{
    "Can't find host in database",
    "Can't find service in database",
    "Can't find protocol in database",
    "Can't make socket",
    "Can't connect to server",
    "Bad IOCTL call",
    "Not enough free memory",
    "Invalid connection handle",
    "Can't open output file",
    "Can't open posting body file",
    
    "Unknown error"
    };

/**********************************************************************/
/*
 * Global variable definitions
 */

void *private_word;
fd_set fd_read, fd_write;
gopher_connection *gopher_cons[FD_SETSIZE];     /* Array of pointers */
gopher_connection *gopher_cons_list;
volatile int tick_pending, data_pending, callback_pending;

/* Count of sockets in the process of connection (i.e. still need to be polled) */
static int sockets_connecting;

#define TMP_BUF_SIZE    1024
char tmp_buffer[TMP_BUF_SIZE];

/* static char gopher_version[] = GOPHER_VERSION; */

/**********************************************************************/
/*
 * Forward declarations of functions static to this file
 */

static _kernel_oserror *setup_ticker_and_event(void);
static void clear_ticker_and_event(void);
static void setup_callback(void);
static void clear_callback(void);

/**********************************************************************/
/*
 * This structure is a prototype for a connection.
 */
static gopher_connection proto_con =
{
    GOPHER_MAGIC,         /* Magic number */
    NULL,                 /* Next pointer */
    NULL,                 /* Prev pointerb */
    0,                    /* Poll word */
    status_NEW,           /* Status */
    NULL,                 /* Object name */
    NULL,                 /* Outgoing headers */
    -1,                   /* Socket number */
    { 0, },               /* Socket address */
    NULL,                 /* File name */
    0,                    /* File handle */
    NULL,                 /* Body file name */
    0,                    /* Body file handle */
    -1,                   /* Data size */
    -1,                   /* Data so far */
    NULL,                 /* List of fetched headers */
    -1,                   /* Return code */
    NULL,                 /* Return message */
    0,                    /* Buffer offset */
    0,                    /* Buffer used */
    NULL                  /* Buffer data */
};

/**********************************************************************/
/*
 * The bcmp and bzero functions are needed by various internet library
 * calls.  I just pass them through to the memXXX versions.
 */

int bcmp(void *s1, void *s2, size_t s)
{
    return memcmp(s1, s2, s);
}

void bzero(void *p, int s)
{
    memset(p, 0, s);
}

/**********************************************************************/
/*
 * Error generation function
 */

static _kernel_oserror *make_error(int err)
{
    static _kernel_oserror e;
    
    if (err > err_LAST_ERROR) err = err_LAST_ERROR;
    e.errnum = err;
    strncpy(e.errmess, err_strings[err], 252);
#if DEBUG
    printf("Making error number %d: %s\n", err, err_strings[err]);
#endif
    return &e;
}

/**********************************************************************/
/*
 * Module finalisation function
 */
static void module_final(void)
{
    gopher_connection *c, *next_one;
    
#if TESTMODE
    printf("Module finalisation called\n");
#endif
    clear_ticker_and_event();
    clear_callback();
    for (c = gopher_cons_list; c != NULL; c = next_one)
    {
	next_one = c->next;
#if DEBUG
	fprintf(stderr, "Closeing connection at %p on socket %d\n", c, c->socket);
#endif
	gopher_close_handle(c, gopher_close_DELETE_FILE);
    }
}

/**********************************************************************/
/*
 * Module initialisation function
 */
extern _kernel_oserror *module_initialise(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *ep;
    private_word = pw;
    
#if TESTMODE
    printf("Module initialisation called.\n");
#endif
    FD_ZERO(&fd_read);
    bzero(gopher_cons, sizeof(gopher_cons));
    gopher_cons_list = NULL;
    tick_pending = data_pending = callback_pending = 0;
    sockets_connecting = 0;
    ep = setup_ticker_and_event();
    if (ep) goto err;
    atexit(&module_final);
    return 0;
    
 err:
    return ep;
    UNUSED(cmd_tail);
    UNUSED(pbase);
}

/**********************************************************************/
/*
 * Module CLI handler function
 */
extern _kernel_oserror *module_cli_handler(char *arg_string, int arg_count,
					   unsigned int cmd_no, void *pw)
{
    gopher_connection *c;
    
#if DEBUG
    printf("CLI handler called, command number %d\n", cmd_no);
#endif
    switch(cmd_no)
    {
    case 0:
	printf("Gopher transport module status information\n");
	if (gopher_cons_list)
	{
	    for (c = gopher_cons_list; c != NULL; c = c->next)
	    {
		printf("Connection at %p on socket %d, status = %d, data fetched = %d/%d,\n",
		       c, c->socket, c->status, c->data_so_far, c->data_size);
		printf("file name = '%s', rc = %d, message = '%s'\n",
		       c->fname ? c->fname : "<garbage>", c->rc, c->message ? c->message : "<none>");
	    }
	} else printf("No current connections\n");
	break;
    }
    return 0;
    
    UNUSED(arg_string);
    UNUSED(arg_count);
    UNUSED(pw);
}

/**********************************************************************/
/*
 * Module SWI handler function
 */
extern _kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *regs, void *pw)
{
#if DEBUG
    printf("SWI handler called, SWI number 0x%02x\n", swinum);
#endif
    switch(swinum)
    {
    case 0:
	/* Open */
	return gopher_open((gopher_open_args *) regs);
	break;
    case 1:
	/* Status */
	return gopher_status((gopher_status_args *) regs);
	break;
    case 2:
	/* Close */
	return gopher_close((gopher_close_args *) regs);
	break;
    }
    return NULL;
    UNUSED(pw);
}

/**********************************************************************/
/*
 * A function to handle the internet events.
 */
extern int inetevent_handler(_kernel_swi_regs *regs, void *pw)
{
    if (regs->r[0] == Internet_Event)
    {
	if ( FD_ISSET(regs->r[2], &fd_read))
	{
	    /* take some action */
	    data_pending = 1;
	    setup_callback();
	}
    }
    return VIA_R14;
    UNUSED(pw);
}

int timer_handler( _kernel_swi_regs *r, void *pw )
{
    tick_pending = 1;
    setup_callback();
    return VIA_R14;
}

/**********************************************************************/
/*
 * A function to handle the callbacks caused by internet events.
 */
extern int callback_handler(_kernel_swi_regs *regs, void *pw)
{
    int max_sock = 0;
    int i;
    
#if DEBUG
    /* printf("Callback handler entered\n"); */
#endif
    
    /*  @@@@ N.B. There is potentially a race state around here.  If the callback pending
     *  flag gets cleared before the select call then there can be a spurious callback
     *  that has nothing to do.  If the flag gets cleared after the call then there is
     *  a small chance that the module will miss data.  Since the cost of an extra callback
     *  is not great we err on the safe side.
     */
    callback_pending = 0;
    
    if (tick_pending)
    {
	int i;
	
	if (sockets_connecting)
	{
	    for (i=0; i<FD_SETSIZE; i++)
	    {
		gopher_connection *c = gopher_cons[i];
		if (c)
		{
		    int rc;
		    
		    if (c->status == status_CONNECTING)
		    {
#if DEBUG
			fprintf(stderr, "Trying another connect of %d\n", c->socket);
#endif
			rc = connect(c->socket, (struct sockaddr *) &(c->sa), sizeof(struct sockaddr));
			if (rc > -1)
			{
			    /* This should not happen, but we will catch it anyway */
			    c->status = status_REQUESTING;
			}
			else
			{
			    switch (errno)
			    {
			    case EISCONN:
				/* The connection is through now */
				c->status = status_REQUESTING;
				break;
			    case EALREADY:
				/* The connection is still going through */
				/* Do nothing */
				break;
			    default:
				/* The connection failed */
				c->status = status_FAIL_CONNECT;
				if (c->fh)
				{
				    ro_fclose(c->fh);
				    c->fh = NULL;
				}
				break;
			    }
			}
		    }
		    if (c->status == status_REQUESTING)
		    {
			gopher_send_request(c);
		    }
		    rc = 0;
		}
	    }
	}
	tick_pending = 0;
    }
    
    for (i = 0; i < FD_SETSIZE; i++)
	if (FD_ISSET(i, &fd_read) || FD_ISSET(i, &fd_write)) max_sock = i + 1;
    
    if (data_pending  || max_sock)
    {
	fd_set fd_read_tmp, fd_write_tmp, fd_excep_tmp;
	int n;
	struct timeval tv = {0};
	
	/* This function gets called when there has been an event on a socket */
	data_pending = 0;
	memcpy(&fd_read_tmp, &fd_read, sizeof(fd_set));
	memcpy(&fd_write_tmp, &fd_write, sizeof(fd_set));
	memcpy(&fd_excep_tmp, &fd_read, sizeof(fd_set));
	
	n = select(max_sock, &fd_read_tmp, &fd_write_tmp, &fd_excep_tmp, &tv);
	
#if DEBUG
	if (n) fprintf(stderr, "Select gave a result of %d (errno = %d)\n", n, errno);
#endif
	
	if (n > 0)
	{
	    for( i = 0; i < FD_SETSIZE; i++)
	    {
		if (FD_ISSET(i,&fd_read_tmp) ||
		    FD_ISSET(i,&fd_write_tmp) ||
		    FD_ISSET(i,&fd_excep_tmp) )
		{
		    gopher_connection *c = gopher_cons[i];
		    
		    if (c == 0)
		    {
			/* This should not happen, try to patch things up */
			FD_CLR(i, &fd_read);
			FD_CLR(i, &fd_write);
#if DEBUG
			fprintf(stderr, "Socket %i spuriously in fd_sets, now removed\n", i);
#endif
		    }
		    else
		    {
			int rc;
			
			switch (c->status)
			{
			case status_REQUEST_HEADERS:
			    break;
			case status_WAITING:
			    /* Expecting a response line */
			    /* At this stage we have had no data */
			    rc = recv(c->socket, tmp_buffer, TMP_BUF_SIZE, 0);
#if DEBUG
			    fprintf(stderr, "Recv (body) gave %d\n", rc);
#endif
			    if (rc > 0)
			    {
				if (c->fh)
				    ro_fwritepos(tmp_buffer, rc, 1, c->fh, 0);
				c->data_so_far = rc;
				c->status = status_GETTING_BODY;
			    }
			    break;
			case status_GETTING_HEADERS:
			    /* This state should never be reached */
			    break;
			case status_GETTING_BODY:
			    while (1)
			    {
				rc = recv(c->socket, tmp_buffer, TMP_BUF_SIZE, 0);
#if DEBUG
				fprintf(stderr, "Recv (body) gave %d\n", rc);
#endif
				if (rc <= 0)
				{
				    if (rc == 0 || errno != EWOULDBLOCK)
				    {
#if DEBUG
					fprintf(stderr, "Completing connection on socket %d, errno=%d\n",
						c->socket, errno);
#endif
					c->status = status_COMPLETED_FILE;
					if (c->fh)
					{
					    ro_fclose(c->fh);
					    c->fh = NULL;
					}
				    }
				    break; /* NOTE:  This is a break for the WHILE loop, not the switch() */
				}
				else
				{
				    if (c->fh)
					ro_fwritepos(tmp_buffer, rc, 1, c->fh, c->data_so_far);
				    c->data_so_far += rc;
				}
			    }
			    break;
			default:
			    break;
			}
			if (c->status == status_FAIL_CONNECT ||
			    c->status == status_FAIL_REQUEST ||
			    c->status == status_COMPLETED_FILE)
			{
			    gopher_socket_close(c);
			}
		    }
		    n--;
		}
	    }
#if DEBUG
	    if (n != 0) fprintf(stderr, "%d unknown select items\n", n);
#endif
	}
    }
    return VIA_R14;
    UNUSED(pw);
}

_kernel_oserror *gopher_check_handle(gopher_connection *c)
{
    if (c == NULL || c->magic != GOPHER_MAGIC) return make_error(err_BAD_MAGIC);
    return 0;
}

int gopher_file_size(char *fname)
{
    _kernel_osfile_block fb;
    
    if (_kernel_osfile(5, fname, &fb) != 1) /* If it is not a plain file */
	return -1;
    else
	return fb.start;
}

_kernel_oserror *gopher_close_handle(gopher_connection *c, int flags)
{
    /* Note that we do NOT free the outgoing headers because we don't know where they came from */
#if DEBUG
    fprintf(stderr, "Closing the connection at %p\n", c);
#endif
    gopher_cons[c->socket] = NULL;
    if (c->fh != NULL)
    {
#if DEBUG
	fprintf(stderr, "Closing output file\n");
#endif
	ro_fclose(c->fh);
    }
    
    /* Ignore gopher_close_SET_TYPE flags */
    /* if (flags & gopher_close_SET_TYPE) gopher_set_file_type(c); */
    
    if (flags & gopher_close_DELETE_FILE)
    {
	if (c->fname)
	{
#if DEBUG
	    fprintf(stderr, "Removing file '%s'\n", c->fname);
#endif
	    remove(c->fname);
	}
    }
    if (flags & gopher_close_DELETE_BODY)
    {
	if (c->bname)
	{
#if DEBUG
	    fprintf(stderr, "Removing file '%s'\n", c->bname);
#endif
	    remove(c->bname);
	}
    }
    gopher_socket_close(c); /* This does its own check for the validity of the socket number */
    if (c->fname)
    {
#if DEBUG
	fprintf(stderr, "Freeing output file name\n");
#endif
	free(c->fname);
    }
    if (c->bname)
    {
#if DEBUG
	fprintf(stderr, "Freeing body file name\n");
#endif
	free(c->bname);
    }
    if (c->message)
    {
#if DEBUG
	fprintf(stderr, "Freeing message string\n");
#endif
	free(c->message);
    }
    if (c->object)
    {
#if DEBUG
	fprintf(stderr, "Freeing object name\n");
#endif
	free(c->object);
    }
    
    /* Finally, zap the magic number */
    c->magic = 0;
    
#if DEBUG
    fprintf(stderr, "Unlinking from list\n");
#endif
    if (c->prev == NULL) gopher_cons_list = c->next;
    else c->prev->next = c->next;
    if (c->next != NULL) c->next->prev = c->prev;
#if DEBUG
    fprintf(stderr, "Freeing connection structure\n");
#endif
    free(c);
#if DEBUG
    fprintf(stderr, "Connection closed.\n");
#endif
    return 0;
}

static _kernel_oserror *gopher_open(gopher_open_args *args)
{
    gopher_connection *new;
    int i;
    int rc;
    gopher_open_args args2 = *args;
    
#if DEBUG
    fprintf(stderr, "Opening new conection.  Host = 0x%08x, port = 0x%04x, object = '%s', ",
	    args2.in.host, args2.in.port, args2.in.object);
    fprintf(stderr, "fname = '%s'.\n", args2.in.fname ? args2.in.fname : "");
#endif
    args->out.handle = NULL;
    new = malloc(sizeof(gopher_connection) + MAX_INPUT);
    if (new == 0) return make_error(err_NO_MEMORY);
    *new = proto_con;           /* Fill in with a prototype connection */
    new->buffer = (char*) (new + 1);
    new->buffer[0] = 0;

    memcpy((char *)&(new->sa),(char *) args2.in.addr,  sizeof(new->sa) );

    if ((new->socket = socket(AF_INET, SOCK_STREAM, 0)) <0)
	return make_error(err_CANT_MAKE_SOCKET);
    
#if DEBUG
    fprintf(stderr, "New socket is %d\n", new->socket);
#endif
    
    i = 1;
    rc = socketioctl(new->socket, FIONBIO, (char *) &i);
    if (rc == -1) return make_error(err_BAD_IOCTL);
    i = 1;
    rc = socketioctl(new->socket, FIOASYNC, (char *) &i);
    if (rc == -1) return make_error(err_BAD_IOCTL);
    
#if DEBUG
    fprintf(stderr, "About to connect...");
#endif
    rc = connect(new->socket, (struct sockaddr *) &(new->sa), sizeof(struct sockaddr));
#if DEBUG
    fprintf(stderr, "connect rc=%d errno=%x einprogress %x\n", rc, errno, EINPROGRESS);
#endif
    
    /*
     * Legal return values are:
     *   36   EINPROGRESS     The connection process has been started but no result as yet.
     *   22   EINVAL          The connection process failed, either due to a timeout or a rejection.
     *   37   EALREADY        The connection process is still going on and may yet finnish.
     *   56   EISCONN         The connection process succeded and we are now connected.
     */
    
    if (rc < 0 && errno != EINPROGRESS) return make_error(err_CANT_CONNECT);
#if DEBUG
    fprintf(stderr, "Connect rc = %d, error number %d\n", rc, errno);
#endif
    
    /*
     * The connection process may take a little time.  So we go off and make
     * the data file and come back in a moment to check if we are done.
     */
    
    new->object = strdup(args2.in.object);
    if (new->object == NULL)
    {
	return make_error(err_NO_MEMORY);
    }

    if (args2.in.fname == NULL)
    {
	args2.in.fname = tmpnam(NULL);
    }
    new->fname = strdup(args2.in.fname);
    if (new->fname == NULL)
    {
	return make_error(err_NO_MEMORY);
    }
    
#if DEBUG
    fprintf(stderr, "Opening file '%s'\n", new->fname);
#endif
    
    new->fh = ro_fopen(new->fname, RO_OPEN_WRITE);
    if (new->fh == NULL)
    {
	return make_error(err_CANT_OPEN_FILE);
    }

    rc = connect(new->socket, (struct sockaddr *) &(new->sa), sizeof(struct sockaddr));
    /* What do we do if this call succeeds?  I guess we just leave it */
    if (rc < 0)
    {
	switch (errno)
	{
	case EISCONN:
	    new->status = status_REQUESTING;
	    break;
	case EALREADY:
	    new->status = status_CONNECTING;
	    sockets_connecting++;
	    break;
	default:
	    return make_error(err_CANT_CONNECT);
	    break;
	}
    }
    else
    {
	new->status = status_REQUESTING;
    }
    
    /* Get this in before we send anything */
    gopher_cons[new->socket] = new;
    
    FD_SET(new->socket, &fd_write);
    
#if DEBUG
    fprintf(stderr, "ISSET: %ld %ld\n", FD_ISSET(new->socket, &fd_read),
	    FD_ISSET(new->socket, &fd_write) );
#endif
    
    if (new->status == status_REQUESTING)
    {
	gopher_send_request(new);
    }
    
    rc = 0;
    
    new->next = gopher_cons_list;
    /* new->prev is set to NULL in the prototype */
    
    if (gopher_cons_list) gopher_cons_list->prev = new;
    gopher_cons_list = new;
    
    args->out.handle = new;
    return NULL;
}

static _kernel_oserror *gopher_status(gopher_status_args *args)
{
    gopher_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = gopher_check_handle(c);
    if (ep)
	return ep;

    args->out.status = c->status ;
    args->out.ro_fh = c->fh ;
    args->out.fname = c->fname ;
    args->out.data_size = c->data_size ;
    args->out.data_so_far = c->data_so_far ;
    args->out.rc = c->rc ;
    args->out.message = c->message ;

    return NULL;
}

static _kernel_oserror *gopher_close(gopher_close_args *args)
{
    gopher_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = gopher_check_handle(c);
    if (ep)
	return ep;

    return gopher_close_handle(c, args->in.flags);
}

static _kernel_oserror *setup_ticker_and_event(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *ep;
    
    r.r[0] = 0x10;
    r.r[1] = (int) &inetevent_entry;
    r.r[2] = (int) private_word;
    ep = _kernel_swi(XOS_Bit + OS_Claim, &r, &r);
    if (ep) return ep;
    _kernel_osbyte(14, Event_Internet, 0);
    r.r[0] = TICKER_RATE;
    r.r[1] = (int) timer_entry;
    r.r[2] = (int) private_word;
    ep = _kernel_swi(OS_CallEvery, &r, &r);
    if (ep)
    {
	clear_ticker_and_event();
	return ep;
    }
    return NULL;
}

static void clear_ticker_and_event(void)
{
    _kernel_swi_regs r;
    
    _kernel_osbyte(13, Event_Internet, 0);
    r.r[0] = 0x10;
    r.r[1] = (int) inetevent_entry;
    r.r[2] = (int) private_word;
    _kernel_swi(OS_Release, &r, &r);
    r.r[0] = (int) timer_entry;
    r.r[1] = (int) private_word;
    _kernel_swi(OS_RemoveTickerEvent, &r, &r);
}

static void setup_callback(void)
{
    if (callback_pending == 0)
    {
	_kernel_swi_regs r;
	
	r.r[0] = (int) &callback_entry;
	r.r[1] = (int) private_word;
	callback_pending = 1;
	
	_kernel_swi(OS_AddCallBack, &r, &r);
    }
}

static void clear_callback(void)
{
    if (callback_pending)
    {
	_kernel_swi_regs r;
	
	r.r[0] = (int) &callback_entry;
	r.r[1] = (int) private_word;
	callback_pending = 0;
	_kernel_swi(OS_RemoveCallBack, &r, &r);
    }
}

char *strdup(char *s)
{
    char *ss;
    
    ss = malloc(strlen(s) + 1);
    if (ss) strcpy(ss, s);
    return ss;
}

void gopher_send_request(gopher_connection *c)
{
    sprintf(tmp_buffer, "%s\r\n", c->object);
#if DEBUG
    /* You dont want a \n on this printf */
    fprintf(stderr, "Sending request: %s", tmp_buffer);
#endif
    if (send(c->socket, tmp_buffer, strlen(tmp_buffer), 0) < 0)
    {
	c->status = status_FAIL_REQUEST;
	if (c->fh)
	{
	    ro_fclose(c->fh);
	    c->fh = NULL;
	}
    }
    else
    {
	c->status = status_WAITING;
    }
}

void gopher_socket_close(gopher_connection *c)
{
    if (c->socket != -1)
    {
#if DEBUG
	fprintf(stderr, "Closing socket %d\n", c->socket);
#endif
	FD_CLR(c->socket, &fd_read);
	FD_CLR(c->socket, &fd_write);
	gopher_cons[c->socket] = NULL;
	socketclose(c->socket);
	c->socket = -1;
    }
}

int strcasecmp(char *s1, char *s2)
{
    int c1, c2, t;
    
    while (1)
    {
	c1 = *s1++;
	c2 = *s2++;
	if (c1 == 0 || c2 == 0)
	    return c1-c2;
	else
	{
	    t = toupper(c1) - toupper(c2);
	    if (t) return t;
	}
    }
}
