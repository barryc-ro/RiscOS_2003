/*
 * IPConfig (module.c)
 *
 *
 * Copyright (C) Acorn Computers Ltd. 1998
 *
 *
 * Originally based upon DoBootP/module.c
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "sys/dcistructs.h"
#include "sys/types.h"
#include "sys/uio.h"
#include "sys/socket.h"
#include "sys/errno.h"
#include "sys/time.h"
#include "sys/ioctl.h"
#include "netinet/in.h"
#include "net/if.h"
#include "socklib.h"

#include "module.h"
#include "editconfig.h"
#include "ifrconfig.h"
#include "utils.h"
#include "sysvars.h"
#ifdef TRACE
#  include "IPConfHdrD.h"
#else
#  include "IPConfHdr.h"
#endif

static int establish_addresses(void);
static void read_device_name(char *buf, char *macadr);
static void setadrvar(int ifcnt, char *adr);

#ifdef TRACE
/* This variable is set to non-zero if the dynamic boot is to be executed
 * on the primary interface EVEN IF it already satisfies this module's
 * conditions that the dynamic boot is unnecessary.  This allows trace
 * builds to force requests to be issued under direct control from CLI.
 */
static int trace_DO_BOOTP = 0;
#endif


static void *module_wsp = 0;
static int ifcnt = 0;

/* module_read_command_options
 *
 *  This function parses the supplied command-line (if any) and sets the state
 *  flag according to the options which were specified in the command-line.
 *
 *  If no command-line is supplied, the stored state is returned.
 *  If a command-line was supplied (only the case during module initialisation), then
 *  the return value is -1 if the module should die, otherwise the stored state is
 *  returned.
 *
 */
int module_read_command_options(const char *cmd_tail)
{
        static int state = 0;

        if (cmd_tail != NULL) {
                int switches[3];
                _kernel_oserror *e;
                const char *msg = 0;
		char *args = 0;
                size_t msg_len = 0;

		/* Discover the command-line parameter match string - must be three switches */
                e = read_message("Args", &msg, &msg_len);
                if (e != NULL) {
                        (void) fprintf(stderr, "%s\n", e->errmess);
                        return -1;
                }
                args = malloc(msg_len+1);
                if (args != NULL) {
                	memcpy(args, msg, msg_len);
                        args[msg_len] = '\0';
                }
                else {
                	return -1;
                }

		/* Parse command-tail */
                e = _swix(OS_ReadArgs, _INR(0,3), args, cmd_tail, switches, sizeof(switches));
                free(args);
                /* Error or -help was specified */
                if (e != NULL || switches[2]) {
                        e = make_error(error_REFUSE_INIT_SYNTAX_ERROR, 0);
                	(void) fprintf(stderr, "%s\n", e->errmess);
                	return -1;
                }
                if (switches[0]) state |= 1;
                if (switches[1]) state |= 2;
        }

        return state;
}

/* release_module_resources closes and removes the messages file from the RMA
 * if necessary.
 */
static void release_module_resources(void)
{
        (void) messages_file_close();
        #ifndef ROM
        (void) utils_deregister_msgs();
        #endif
}

/* Module initialisation code
 *
 * Calls the editor's initialisation routine to see if we need to edit the configuration.
 * If we do, we get NULL back and allow module initialisation to complete.
 * If we do not, we get an error (which we ignore) and check the address tables.  If
 * the dynamic boot is already done, we return an error in order to die immediately,
 * otherwise we allow module initialisation to succeed, and wait for service calls to arrive.
 *
 */
_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw)
{
        _kernel_oserror *e;

        (void) podule_base;
        module_wsp = pw;

        #ifndef ROM
        e = utils_register_msgs();
        if (e != NULL) {
                return e;
        }
        #endif

        if (getenv(Module_Title "$Path") != NULL) {
                e = messages_file_open(Module_Title ":Messages");
        }
        else {
                e = messages_file_open("Resources:$.Resources." Module_Title ".Messages");
        }
        if (e != NULL) {
		#ifndef ROM
                utils_deregister_msgs();
		#endif
                return e;
        }

        if (module_read_command_options(cmd_tail)<0) {
                _kernel_oserror *e = make_error(error_REFUSE_INIT_BOOTP_ALREADY_DONE, 0);
		release_module_resources();
                return e;
        }

        if (editconfig_initialise() == NULL) {
                return NULL;
        }

        (void) establish_addresses();
        if (ifcnt != 0) {
                _kernel_oserror *e = make_error(error_REFUSE_INIT_BOOTP_ALREADY_DONE, 0);
                release_module_resources();
                return e;
        }

        return NULL;
}

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
        (void) fatal;
        (void) podule;
        (void) pw;

	release_module_resources();

        return 0;
}

/* Set a system variable.  If the variable setting would be empty,
 * then the variable is not set at all.
 */
static void setvar(const char *var, const char *str)
{
        if (*str != '\0') {
                (void) _kernel_setenv(var, str);
        }
}

/* Gets the value of a system variable.  If the variable is unset or the value
 * is the empty string, then the buffer is filled with an empty string (if the
 * buffer was at least 1 byte long!) otherwise at most len-1 bytes are copied
 * into the user buffer and a terminating NUL appended.
 *
 * If an empty string is/would have been returned, the return value is 0.
 * Otherwise the return value is non-zero.
 */
static int getvar(char *var, char *str, int len)
{
        char *v = getenv(var);
        if (len > 0) {
                *str = '\0';
        }
        if (v != NULL && v[0] != '\0') {
                if (len > 0) {
                        (void) strncat(str, v, len);
                }
                return 1;
        }
        else {
                return 0;
        }
}

static int establish_addresses_sub(int s)
{
        char buf[512], name[16], macadr[6];
        struct ifconf ifc;
        struct ifreq ifreq, *ifr;
        struct sockaddr_in *sin;
        int n, retried = 0;
        char var_buf[64];

        read_device_name(name, macadr);
again:
        ifc.ifc_len = sizeof (buf);
        ifc.ifc_buf = buf;
        if (socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) return 1;
        ifcnt = 0;
        ifr = ifc.ifc_req;
        for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++) {
                ifreq = *ifr;
                /*
                 * RWB - fix to prevent each interface being marked twice until
                 * 4.4BSD Internet module (each interface also has an AF_LINK address)
                 */
                if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
                        continue;

                /*
                 * Check to see if its the loop back device. We dont want this
                 */
                if (socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 || ifreq.ifr_flags & IFF_LOOPBACK)
                        continue;
                /*
                 * The card also needs to be able to broadcast
                 */
                if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP))
                        continue;

                /*
                 * Get the address of the interface
                 */
                if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
                        continue;
                sin = (struct sockaddr_in *)&ifreq.ifr_addr;
                (void) sprintf(name, "%lx", sin->sin_addr.s_addr);
                setadrvar(ifcnt, name);
                if (getvar(SYSVAR_INET_BOOTFILE, var_buf, sizeof(var_buf))) {
                        setvar(SYSVAR_INET_MOUNTPATH, var_buf);
                }

                if (getvar(SYSVAR_INET_HOSTNAME, var_buf, sizeof(var_buf)) == 0) {
                        (void) strcpy(var_buf, "ARM");
                        format_mac_address(macadr, strchr(var_buf, '\0'), '\0');
                        setvar(SYSVAR_INET_HOSTNAME, var_buf);
                }
                ifcnt++;
        }
#ifdef TRACE
        if (trace_DO_BOOTP) ifcnt = 0;
        trace_DO_BOOTP = 0;
        read_device_name(name, macadr);
        printf("read_device_name: `%s' at `", name);
        { char macbuf[20]; format_mac_address(macadr, macbuf, ':'); printf("%s", macbuf); }
        printf("'\n");
#endif

        if (ifcnt == 0 && !retried) {
                (void) strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));
                if (socketioctl(s, SIOCGIFFLAGS, (caddr_t)&ifreq) < 0) {
#ifdef TRACE
			printf("ioctl() -> %s\n", _inet_err());
#endif
                        return 1;
                }
#ifdef TRACE
                printf("Executing ifrconfig(%s)\n", ifreq.ifr_name);
#endif
                if (!ifrconfig(s, name)) {
                        return (0);
                }
                retried = 1;
                goto again;
        }
        return (1);
}

/* establish_addresses
 *
 * This routine is the entry point to the interface table discovery code in
 * establish_addresses_sub.  To simplify socket handle management, this function
 * creates the socket, calls the subroutine and then closes the socket.
 */
static int establish_addresses(void)
{
        int s, result;

        s = socket(PF_INET, SOCK_DGRAM, 0);
        if (s < 0) {
                result = 1;
        }
        else {
                result = establish_addresses_sub(s);
                #ifdef TRACE
                printf("establish_addresses_sub(...) completed - returned %d\n", result);
                #endif
                (void) socketclose(s);
        }
        return result;
}

/* read_device_name
 *
 * This function fills in the interface name and MAC address of the first interface
 * in the chain returned by the network driver enumeration service call.  The supplied
 * buffer must be long enough to accept any interface name.  The Ethernet MAC address
 * will be 6 bytes long.
 *
 */
static void read_device_name(char *buf, char *macadr)
{
        _kernel_oserror *e;
        struct chaindib *d;

	/* Enumerate the network drivers */
        e = _swix(OS_ServiceCall, _INR(0,1)|_OUT(0), 0, Service_EnumerateNetworkDrivers, &d);
        if( e != 0 || d == NULL) {
                buf[0] = 0;
                return;
        }

	/* Construct the complete interface name fom the unit name and the unit number */
        (void) strcat(strcpy(buf, (char *) d->chd_dib->dib_name), "0");

	/* Copy the 6-byte Ethernet MAC address */
	(void) memcpy(macadr, d->chd_dib->dib_address, 6);

        while (d) {
                struct chaindib *d_next = d->chd_next;
                /* specification requires chain blocks be in the RMA.   C library detects blocks
                 * in RMA and frees them correctly with OS_Module
                 */
                free(d);
                d = d_next;
        }
}

static void setadrvar(int ifcnt, char *adr)
{
        const char *v = SYSVAR_INET_LOCALADDR;
        char varname[sizeof(SYSVAR_INET_LOCALADDR) + 4];
        const char *val;

        if (ifcnt == 0)
                val = v;
        else {
                (void) sprintf(varname, "%s%d", v, ifcnt);
                val = varname;
        }
        (void) _kernel_setenv(val, adr);
}


/* Callback management.  The dynamic boot cannot be performed during module initialisation
 * so these routines manage the callback settings and the top-level call into the
 * establish_addresses() function when the callback fires.
 */
static volatile int callbackflag = 0;

_kernel_oserror *callb_handler(_kernel_swi_regs *r, void *pw)
{
        (void) r;
        (void) pw;
        if (callbackflag != 0) {
                callbackflag = 0;
                if (ifcnt == 0) {
                        (void) establish_addresses();
                }
        }
        return 0;
}

static void setcallback(void)
{
        if (callbackflag == 0) {
                callbackflag = 1;
                if (_swix(OS_AddCallBack, _INR(0,1), callb_entry, module_wsp)) {
                        callbackflag = 0;
                }
        }
}

/* Module service call handler */
void module_service(int sn, _kernel_swi_regs *r, void *pw)
{
        switch (sn) {
                case Service_DCIDriverStatus:
                        if (r->r[2] == 0 && ifcnt == 0) {
                                setcallback();
                        }
                        break;
                case Service_InternetStatus:
                        break;
                default:
                        /* Must be Service_Reset */
                        (void) editconfig_service(pw);
                        break;
        }
}

#ifdef TRACE
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
        (void) arg_string;
        (void) argc;

        switch (cmd_no) {
                case CMD_IPConfig_Configure:
                        (void) editconfig_service(pw);
                        break;
                case CMD_IPConfig_ExecBootP:
                        trace_DO_BOOTP = 1;
                        setcallback();
                        break;
                default:
                        break;
        }

        return 0;
}
#endif
