/*
 * IPConfig (module.c)
 *
 *
 * Copyright (C) Acorn Computers Ltd. 1998
 *
 *
 */

/*
 * Modification history
 *
 * RWB 15-Oct-96 (08-Jan-97) Fixed incompatability with Internet 5
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#include "dci4.h"
#include "module.h"
#include "editconfig.h"
#include "ifrconfig.h"
#ifdef TRACE
#  include "IPConfHdrD.h"
#else
#  include "IPConfHdr.h"
#endif
#include "utils.h"

#include "sys/types.h"
#include "sys/uio.h"
#include "sys/socket.h"
#include "sys/errno.h"
#include "sys/time.h"
#include "sys/ioctl.h"
#include "netinet/in.h"
#include "net/if.h"

#include "socklib.h"

static int establish_addresses(void);
static void read_device_name(char *buf, char *macadr);
static void setadrvar(int ifcnt, char *adr);


static void *module_wsp = 0;
static int ifcnt = 0;

#ifdef TRACE
/* Trace builds only */
int module_ram_force_config(const char *cmd_tail)
{
        static int state = 0;
        if (cmd_tail != NULL) {
        	if (strstr(cmd_tail, "conf")) state |= 1;
        	if (strstr(cmd_tail, "noboot")) state |= 2;
        	if (strstr(cmd_tail, "-help") || strstr(cmd_tail, "-?")) {
                        printf(Module_Title ": This is a test build\nCommand tail is used for ");
                        printf("parameters to simulate keypresses.\nOS_Reset will NOT be called.\n");
                        printf("Parameters are:\n   conf      Enter configuration (L.Alt+R.Alt)\n");
                        printf("   noboot    Abort BOOTP process and don't do anything\n\n");
                        return -1;
                }
        }
	return state;
}
#endif

/* Module initialisation code
 *
 * Calls the "StaticIP" initialisation to see if we need to edit the configuration.
 * If we do, we get NULL back and allow module init to complete.
 * If we do not, we get an error (which we ignore) and check the addresses.  If
 * the BOOTP is already done, we return an error, otherwise we allow module init
 * to succeed, and wait for service calls to arrive.
 *
 */
_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw)
{
        _kernel_oserror *e;

	module_wsp = pw;

	(void) cmd_tail;
	(void) podule_base;

	#ifdef TRACE
	if (module_ram_force_config(cmd_tail)<0) {
	        static _kernel_oserror e = { 0, Module_Title " exits" };
	        return &e;
	}
	#endif
	#ifndef ROM
        e = utils_register_msgs();
        if (e != NULL) return e;
        #endif

        if (getenv(Module_Title "$Path") != NULL) {
		e = messages_file_open(Module_Title ":Messages");
        }
	else {
		e = messages_file_open("Resources:$.Resources." Module_Title ".Messages");
	}
  	if (e != NULL) {
        	utils_deregister_msgs();
                return e;
        }

        if (editconfig_initialise() == NULL) return NULL;

	(void) establish_addresses();
	if (ifcnt != 0) {
	        _kernel_oserror *e = make_error(error_REFUSE_INIT_BOOTP_ALREADY_DONE, 0);
	        messages_file_close();
	        #ifndef ROM
	        utils_deregister_msgs();
	        #endif
	        return e;
	}

	return NULL;
}

_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
        (void) fatal;
        (void) podule;
        (void) pw;

        messages_file_close();
        #ifndef ROM
        utils_deregister_msgs();
        #endif

        return 0;
}

static void setvar(const char *var, const char *str)
{
        if (*str != '\0') {
                _kernel_setenv(var, str);
        }
}

static int getvar(char *var, char *str, int len)
{
        char *v = getenv(var);
        *str = '\0';
        if (v != NULL && v[0] != '\0') {
                strncat(str, v, len);
                return 1;
        }
        else {
                return 0;
        }
}

static int establish_addresses_sub(int s)
{
    	char buf[512], name[16], macadr[6];
    	struct ifconf ifc;
    	struct ifreq ifreq, *ifr;
    	struct sockaddr_in *sin;
    	int n, retried = 0;
    	char var_buf[64];

    	read_device_name(name, macadr);
again:
    	ifc.ifc_len = sizeof (buf);
    	ifc.ifc_buf = buf;
    	if (socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) return 1;
    	ifcnt = 0;
    	ifr = ifc.ifc_req;
    	for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++) {
        	ifreq = *ifr;
                /*
                 * RWB - fix to prevent each interface being marked twice until
                 * 4.4BSD Internet module (each interface also has an AF_LINK address)
                 */
                if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
                    	continue;

        	/*
        	 * Check to see if its the loop back device. We dont want this
        	 */
                if (socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 || ifreq.ifr_flags & IFF_LOOPBACK)
                    	continue;
        	/*
        	 * The card also needs to be able to broadcast
        	 */
                if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP))
                    	continue;

        	/*
        	 * Get the address of the interface
        	 */
                if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
                    	continue;
                sin = (struct sockaddr_in *)&ifreq.ifr_addr;
                sprintf(name, "%lx", sin->sin_addr.s_addr);
                setadrvar(ifcnt, name);
                getvar("Inet$BootFile", var_buf, sizeof(var_buf));
                if (var_buf[0])
                    	setvar("Inet$MountPath", var_buf);

                if (getvar("Inet$HostName", var_buf, sizeof(var_buf)) == 0) {
                    	sprintf(var_buf, "%s%x%x", "OmSTB", macadr[4]&0xff, macadr[5]&0xff);
                    	setvar("Inet$HostName", var_buf);
                }
                ifcnt++;
        }
    	if (ifcnt == 0 && !retried) {
        	strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));
        	if (socketioctl(s, SIOCGIFFLAGS, (caddr_t)&ifreq) < 0)
            		return 1;
        	if (!ifrconfig(s, name)) {
            		return (0);
                }
        	retried = 1;
        	goto again;
        }
    	return (1);
}

static int establish_addresses(void)
{
        int s, result;

        s = socket(PF_INET, SOCK_DGRAM, 0);
        if (s < 0) {
                result = 1;
        }
        else {
                result = establish_addresses_sub(s);
	        socketclose(s);
        }
        return result;
}

static void read_device_name(char *buf, char *macadr)
{
    	_kernel_oserror *e;
    	struct chaindib *d;
    	int i;

    	e = _swix(OS_ServiceCall, _INR(0,1)|_OUT(0), 0, Service_EnumerateNetworkDrivers, &d);
    	if( e != 0 || d == NULL) {
       		buf[0] = 0;
       		return;
        }

    	strcpy(buf, d->chd_dib->dib_name);
    	strcat(buf, "0");

    	for( i = 0; i < 6; i++ ) {
        	macadr[i] = d->chd_dib->dib_address[i];
        }
    	while (d) {
        	struct chaindib *d_next = d->chd_next;
		/* specification requires chain blocks be in the RMA.   C library detects blocks
		 * in RMA and frees them correctly with OS_Module
		 */
            	free(d);
            	d = d_next;
        }
}

static void setadrvar(int ifcnt, char *adr)
{
    	static const char v[] = "Inet$LocalAddr";
    	char varname[32];
        const char *val;

    	if (ifcnt == 0)
        	val = v;
        else {
        	sprintf(varname, "%s%d", v, ifcnt);
        	val = varname;
        }
        (void) _kernel_setenv(val, adr);
}


static volatile int callbackflag = 0;

_kernel_oserror *callb_handler(_kernel_swi_regs *r, void *pw)
{
        (void) r;
        (void) pw;
    	if (callbackflag != 0) {
    		callbackflag = 0;
    		if (ifcnt == 0) {
        		(void) establish_addresses();
                }
        }
    	return 0;
}

static void setcallback(void)
{
    	if (callbackflag == 0) {
        	callbackflag = 1;
        	if (_swix(OS_AddCallBack, _INR(0,1), callb_entry, module_wsp)) {
            		callbackflag = 0;
                }
        }
}

void module_service(int sn, _kernel_swi_regs *r, void *pw)
{
        switch (sn) {
                case Service_DCIDriverStatus:
                        if (r->r[2] == 0 && ifcnt == 0) setcallback();
                        break;
                case Service_InternetStatus:
                        break;
                default:
                        /* Must be Service_Reset */
                        editconfig_service(pw);
                        break;
        }
}

#ifdef TRACE
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
        (void) arg_string;
        (void) argc;
        (void) pw;

        switch (cmd_no) {
                case CMD_IPConfig_Configure:
                        editconfig_service(pw);
                        break;
                default:
                        break;
        }

        return 0;
}
#endif
