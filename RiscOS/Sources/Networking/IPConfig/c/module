/*
 * IPConfig (module.c)
 *
 *
 * Copyright (C) Acorn Computers Ltd. 1998
 *
 *
 * Originally based upon DoBootP/module.c
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "sys/dcistructs.h"
#include "sys/types.h"
#include "sys/uio.h"
#include "sys/socket.h"
#include "sys/errno.h"
#include "sys/time.h"
#include "sys/ioctl.h"
#include "netinet/in.h"
#include "net/if_arp.h"
#include "net/if.h"
#include "netinet/if_ether.h"
#include "socklib.h"

#include "module.h"
#include "editconfig.h"
#include "ifrconfig.h"
#include "utils.h"
#include "sysvars.h"
#ifdef TRACE
#  include "IPConfHdrD.h"
#else
#  include "IPConfHdr.h"
#endif

#define Service_Reset 0x27

static void setcallback(void);
static void clearcallback(void);

#ifdef TRACE
/* This variable is set to non-zero if the dynamic boot is to be executed
 * on the primary interface EVEN IF it already satisfies this module's
 * conditions that the dynamic boot is unnecessary.  This allows trace
 * builds to force requests to be issued under direct control from CLI.
 */
static int trace_DO_BOOTP = 0;
#endif


static void *module_wsp = 0;
static int ifcnt = 0;

/* module_set_command_options
 *
 *  This function parses the supplied command-line and sets the state
 *  flag according to the options which were specified in the command-line.
 *  It stores the result so that it can be returned via module_read_command_options()
 *
 *  If the return value is non-NULL, an error occurred which should be returned to
 *  prevent module initialisation.
 *
 */
static int cli_state = 0;
int module_read_command_options(void)
{
        return cli_state;
}

static void module_set_flags(int set)
{
	cli_state |= set;
}

static void module_clear_flags(int clear)
{
	cli_state &= ~clear;
}

static _kernel_oserror *module_set_command_options(const char *cmd_tail)
{
        int switches[4];
        _kernel_oserror *e;
        const char *msg = 0;
        char *args = 0;
        size_t msg_len = 0;

        /* Discover the command-line parameter match string - must be four switches */
        e = read_message("Args", &msg, &msg_len);
        if (e != NULL) {
                return e;
        }
        args = malloc(msg_len+1);
        if (args != NULL) {
                memcpy(args, msg, msg_len);
                args[msg_len] = '\0';
        }
        else {
                return 0;
        }

        /* Parse command-tail */
        e = _swix(OS_ReadArgs, _INR(0,3), args, cmd_tail, switches, sizeof(switches));
        free(args);
        /* Error or -help was specified */
        if (e != NULL || switches[3]) {
                return make_error(error_REFUSE_INIT_SYNTAX_ERROR, 0);
        }
        cli_state = 0;
        if (switches[0]) {
                cli_state |= flag_RUN_EDITOR;
        }
        if (switches[1]) {
                cli_state |= flag_NO_DO_BOOT;
        }
        else {
                if (switches[2]) {
                        cli_state |= flag_FORCE_BOOT;
                }
        }

        return 0;
}

/* release_module_resources closes and removes the messages file from the RMA
 * if necessary, and removes any pending callback if there was one.
 */
static void release_module_resources(void)
{
	clearcallback();
	module_clear_flags(-1);
        (void) messages_file_close();
        #ifndef ROM
        (void) utils_deregister_msgs();
        #endif
}

static _kernel_oserror *module_open_messages(void)
{
        _kernel_oserror *e;

        if (getenv(Module_Title "$Path") != NULL) {
                e = messages_file_open(Module_Title ":Messages");
                if (e == NULL) {
                        (void) messages_file_open(Module_Title ":Custom");
                }
        }
        else {
                e = messages_file_open("Resources:$.Resources." Module_Title ".Messages");
                if (e == NULL) {
                        (void) messages_file_open("Resources:$.Resources." Module_Title ".Custom");
                }
        }

        return e;
}


/* Module initialisation code
 *
 * Calls the editor's initialisation routine to see if we need to edit the configuration.
 * If we do, we get NULL back and allow module initialisation to complete.
 * If we do not, we get an error (which we ignore) and check the address tables.  If
 * the dynamic boot is already done, we return an error in order to die immediately,
 * otherwise we allow module initialisation to succeed, and wait for service calls to arrive.
 *
 */
static _kernel_oserror *module_init_sub(const char *cmd_tail)
{
        _kernel_oserror *e;
        int opts;

        e = module_open_messages();
        if (e == NULL) e = module_set_command_options(cmd_tail);
        if (e != NULL) {
                return e;
        }

	opts = module_read_command_options();
        if (opts<0) {
                return make_error(error_REFUSE_INIT_BOOTP_ALREADY_DONE, 0);
        }

#ifdef TRACE
	fprintf(stderr, Module_Title ": press interrupt keys NOW\a\n");
	{ int i; for (i=0; i<100; ++i) (void) _kernel_osbyte(19,0,0); }
#endif

        if (editconfig_initialise() == NULL) {
                module_set_flags(flag_RUN_EDITOR);
        }
        else if ((opts & flag_NO_DO_BOOT) && !(opts & flag_FORCE_BOOT)) {
                /* Do we need to perform our boot operations? */
                return make_error(error_REFUSE_INIT_BOOTP_ALREADY_DONE, 0);
        }

        return NULL;
}

_kernel_oserror *module_init(const char *cmd_tail, int podule_base, void *pw)
{
        _kernel_oserror *e;


#ifdef TRACE
	fprintf(stderr, Module_Title ": initialisation\n");
	{ int i; for (i=0; i<100; ++i) (void) _kernel_osbyte(19,0,0); }
#endif

        (void) podule_base;
        module_wsp = pw;

        #ifndef ROM
        e = utils_register_msgs();
        if (e != NULL) {
                return e;
        }
        #endif

        e = module_init_sub(cmd_tail);
        if (e != NULL) {
                release_module_resources();
        }
        else {
                setcallback();
        }

        return e;
}


_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
        (void) fatal;
        (void) podule;
        (void) pw;

        release_module_resources();

#ifdef TRACE
	fprintf(stderr, Module_Title ": finalisation\n");
	{ int i; for (i=0; i<100; ++i) (void) _kernel_osbyte(19,0,0); }
#endif

        return 0;
}

/* Set a system variable.  If the variable setting would be empty,
 * then the variable is not set at all.
 */
static void setvar(const char *var, const char *str)
{
        if (*str != '\0') {
                (void) _kernel_setenv(var, str);
        }
}

/* Gets the value of a system variable.  If the variable is unset or the value
 * is the empty string, then the buffer is filled with an empty string (if the
 * buffer was at least 1 byte long!) otherwise at most len-1 bytes are copied
 * into the user buffer and a terminating NUL appended.
 *
 * If an empty string is/would have been returned, the return value is 0.
 * Otherwise the return value is non-zero.
 */
static int getvar(char *var, char *str, int len)
{
        char *v = getenv(var);
        if (len > 0) {
                *str = '\0';
        }
        if (v != NULL && v[0] != '\0') {
                if (len > 0) {
                        (void) strncat(str, v, len);
                }
                return 1;
        }
        else {
                return 0;
        }
}

/* Set the Inet$LocalAddr<n> variable to the given address string */
static void setadrvar(int ifcnt, struct in_addr in)
{
        char hex_address[12];
        const char *v = SYSVAR_INET_LOCALADDR;
        char varname[sizeof(SYSVAR_INET_LOCALADDR) + 4];
        const char *val;

        (void) sprintf(hex_address, "%lx", in.s_addr);

        if (ifcnt == 0)
                val = v;
        else {
                (void) sprintf(varname, "%s%d", v, ifcnt);
                val = varname;
        }
        (void) setvar(val, hex_address);
}


/* read_device_name
 *
 * This function fills in the interface name and MAC address of the first interface
 * in the chain returned by the network driver enumeration service call.  The supplied
 * buffer must be long enough to accept any interface name.  The Ethernet MAC address
 * will be 6 bytes long.  The service call is sent around and all the drivers attach
 * a struct chaindib to the head of the list which must be in the RMA so that we can
 * free it when we're done.
 *
 */
static void read_device_name(char *buf, struct ether_addr *macadr)
{
        _kernel_oserror *e;
        struct chaindib *d;

        /* Enumerate the network drivers */
        e = _swix(OS_ServiceCall, _INR(0,1)|_OUT(0), 0, Service_EnumerateNetworkDrivers, &d);
        if( e != 0 || d == NULL) {
                buf[0] = 0;
                return;
        }

        /* Construct the complete interface name from the unit name and the unit number */
        (void) strcat(strcpy(buf, (char *) d->chd_dib->dib_name), "0");

        /* Copy the 6-byte Ethernet MAC address */
        (void) memcpy(macadr, d->chd_dib->dib_address, sizeof(struct ether_addr));

        while (d) {
                struct chaindib *d_next = d->chd_next;
                /* specification requires chain blocks be in the RMA.   C library detects blocks
                 * in RMA and frees them correctly with OS_Module.
                 * ATM drivers have device names starting with an 'a'
                 */
                if (d->chd_dib->dib_name[0] == 'a') {
                        found_atm_card();
                }
                free(d);
                d = d_next;
        }
}


static void module_start_editor(void *pw)
{

#ifdef TRACE
	fprintf(stderr, Module_Title ": module_start_editor() invoked\n");
	{ int i; for (i=0; i<100; ++i) (void) _kernel_osbyte(19,0,0); }
#endif

        {
                /* Rather than duplicate code, we might as well "discover" the interface
                 * list through the read_device_name function and just throw away the
                 * results.  This is in a sub-block so that the call to editconfig_service
                 * is performed tail-recursively and without this baggage on the stack.
                 * This call is performed solely to allow us to detect ATM drivers.
                 */
                char buf[16];
                struct ether_addr macadr;

                read_device_name(buf, &macadr);
        }

        module_clear_flags(flag_RUN_EDITOR);
        editconfig_service(pw);
}

static int establish_addresses_sub(int s)
{
        char buf[512], name[16], var_buf[64];
        struct ether_addr macadr;
        struct ifconf ifc;
        struct ifreq ifreq, *ifr;
        int n, retried = 0;

        read_device_name(name, &macadr);
again:
        ifc.ifc_len = sizeof (buf);
        ifc.ifc_buf = buf;
        if (socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) return 1;
        ifcnt = 0;
        ifr = ifc.ifc_req;
        for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++) {
                ifreq = *ifr;
                /*
                 * RWB - fix to prevent each interface being marked twice until
                 * 4.4BSD Internet module (each interface also has an AF_LINK address)
                 */
                if (((struct sockaddr *)&ifreq.ifr_addr)->sa_family != AF_INET)
                        continue;

                /*
                 * Check to see if its the loop back device. We dont want this
                 */
                if (socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 || ifreq.ifr_flags & IFF_LOOPBACK)
                        continue;
                /*
                 * The card also needs to be able to broadcast
                 */
                if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP))
                        continue;

                /*
                 * Get the address of the interface
                 */
                if (socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0)
                        continue;
                setadrvar(ifcnt, ((struct sockaddr_in *)&ifreq.ifr_addr)->sin_addr);
                if (getvar(SYSVAR_INET_BOOTFILE, var_buf, sizeof(var_buf))) {
                        setvar(SYSVAR_INET_MOUNTPATH, var_buf);
                }

                if (getvar(SYSVAR_INET_HOSTNAME, var_buf, sizeof(var_buf)) == 0) {
                        (void) strcpy(var_buf, "ARM");
                        format_mac_address(&macadr, strchr(var_buf, '\0'), '\0');
                        setvar(SYSVAR_INET_HOSTNAME, var_buf);
                }
                ifcnt++;
        }
#ifdef TRACE
        if (trace_DO_BOOTP) ifcnt = 0;
        trace_DO_BOOTP = 0;
        read_device_name(name, &macadr);
        printf("read_device_name: `%s' at `", name);
        { char macbuf[20]; format_mac_address(&macadr, macbuf, ':'); printf("%s", macbuf); }
        printf("' %s\n", (ifcnt == 0 && !retried) ? "executing ifrconfig" : "");
#endif

        if (ifcnt == 0 && !retried) {
                int ifrconfig_result;
                (void) strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));
                if (socketioctl(s, SIOCGIFFLAGS, (caddr_t)&ifreq) < 0) {
                        return 1;
                }
                (void) _swix(Hourglass_On, 0);
                ifrconfig_result = ifrconfig(s, name);
                (void) _swix(Hourglass_Off, 0);
                switch (ifrconfig_result) {
                        case -1:
                                module_start_editor(module_wsp);
                                return (0);
                        case 0:
                                return (0);
                        default:
                                break;
                }
                retried = 1;
                goto again;
        }
        return (1);
}

/* establish_addresses
 *
 * This routine is the entry point to the interface table discovery code in
 * establish_addresses_sub.  To simplify socket handle management, this function
 * creates the socket, calls the subroutine and then closes the socket.
 */
static int establish_addresses(void)
{
        int s, result;

        s = socket(PF_INET, SOCK_DGRAM, 0);
        if (s < 0) {
                result = 1;
        }
        else {
		#ifdef TRACE
		fprintf(stderr, Module_Title ": establish_addresses()\n");
		{ int i; for (i=0; i<100; ++i) (void) _kernel_osbyte(19,0,0); }
		#endif
                result = establish_addresses_sub(s);
		#ifdef TRACE
		fprintf(stderr, Module_Title ": establish_addresses() - returned %d\n", result);
		{ int i; for (i=0; i<100; ++i) (void) _kernel_osbyte(19,0,0); }
		#endif
                (void) socketclose(s);
        }
        return result;
}


/* Callback management.  The dynamic boot cannot be performed during module initialisation
 * so these routines manage the callback settings and the top-level call into the
 * establish_addresses() function when the callback fires.
 */
static volatile int callbackflag = 0;

_kernel_oserror *callb_handler(_kernel_swi_regs *r, void *pw)
{
        (void) r;
        (void) pw;
        if (callbackflag != 0) {
                callbackflag = 0;
                if (module_read_command_options() & flag_RUN_EDITOR) {
                        module_start_editor(pw);
                }
                else if (ifcnt == 0) {
                        module_clear_flags(flag_FORCE_BOOT);
                        (void) establish_addresses();
                }
        }
        return 0;
}

static void setcallback(void)
{
        if (callbackflag == 0) {
                int opts = module_read_command_options();
                if ((ifcnt == 0 && !(opts & flag_NO_DO_BOOT)) || (opts & flag_FORCE_BOOT)) {
                        if (_swix(OS_AddCallBack, _INR(0,1), callb_entry, module_wsp) == NULL) {
                                callbackflag = 1;
                                module_set_flags(flag_NO_DO_BOOT);
                        }
                }
        }
}

static void clearcallback(void)
{
  	if (callbackflag != 0) {
                callbackflag = 0;
                (void) _swix(OS_RemoveCallBack, _INR(0,1), callb_entry, module_wsp);
        }
}

/* Module service call handler */
void module_service(int sn, _kernel_swi_regs *r, void *pw)
{

#ifdef TRACE
	fprintf(stderr, Module_Title ": service &%x (R0=%d; R2=%d)\n", sn, r->r[0], r->r[2]);
	{ int i; for (i=0; i<100; ++i) (void) _kernel_osbyte(19,0,0); }
#endif

        switch (sn) {
                case Service_DCIDriverStatus:
                        /* An interface has just gone UP, so set the callback to investigate
                         * new status of modules.
                         */
                        if (r->r[2] == 0) {
                                setcallback();
                        }
                        break;
                case Service_Reset:
                        /* Must be Service_Reset - invoke the editor now if required */
                        if (module_read_command_options() & flag_RUN_EDITOR) {
                                module_start_editor(pw);
                        }
                        break;
                default:
                        break;
        }
}

#ifdef TRACE
_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
        (void) arg_string;
        (void) argc;

        switch (cmd_no) {
                case CMD_IPConfig_Configure:
                        module_start_editor(pw);
                        break;
                case CMD_IPConfig_ExecBootP:
                        trace_DO_BOOTP = 1;
                        setcallback();
                        break;
                default:
                        break;
        }

        return 0;
}
#endif
