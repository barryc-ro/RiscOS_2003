/*
 * IPConfig (editconfig.c)
 *
 * Copyright (C) Acorn Computers Ltd. 1998
 *
 * Based upon StaticIP/module.c
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <signal.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"

#include "sys/types.h"
#include "netinet/in.h"
#include "net/if_arp.h"
#include "net/if.h"
#include "netinet/if_ether.h"
#include "arpa/inet.h"
#include "netdb.h"

#ifdef TRACE
#  include "IPConfHdrD.h"
#else
#  include "IPConfHdr.h"
#endif
#include "editconfig.h"
#include "module.h"
#include "utils.h"
#include "lineedit.h"

/* Number of spaces to pre-pend to display lines to ensure output is visible
 * Messages file tag:  LMargin
 */
static int left_indent = 8;

/* Number of blank lines from top of logical display to ensure text is visible
 * Messages file tag:  VSkip
 */
static int vertical_gap = 10;

/* Width of titles in printed out configuration
 * Messages file tag:  HdrWidth
 */
static int field_width = 24;

/* Number of IP extra addresses to prompt for
 */
static int extra_ip = 1;

/* Non-zero if we find an ATM interface
 */
static int got_atm_card = 0;

/* Time to wait for the keypresses to activate
 */
static int keywait_delay = 20;


/* Maximum length of buffer into which to read allowable Yes keypressed
 * plus the actual characters allowed.
 * Messages file tags:  YesChars, NoChars
 */
#define MAX_YES_CHARS	7
static char yeschars[MAX_YES_CHARS+1] = { '\0' };
static char nochars[MAX_YES_CHARS+1] = { '\0' };


#define MAX_UNSET_BUFFER	23
static char unset[MAX_UNSET_BUFFER+1] = { '\0' };

/* OS_Byte reason codes */
enum {
	osbyte_KEY_SCAN = 121,
	osbyte_READ_CMOS = 161,
	osbyte_WRITE_CMOS = 162
};


static void SetMask(struct in_addr *ip, int bits);


/* This routine fills in the four bytes of CMOS RAM used to hold the value
 * identified by the first location specified - see NVRAMConf.h for these
 * values
 */
static void get_cmos_vector(const int location, int vector[])
{
	vector[0] = location;
	vector[1] = location+1;
	vector[2] = location+2;
	/* Handle the non-contiguous allocations */
	if (location == cmos_HOST_IP) {
		vector[3] = cmos_HOST_IP_OCTET_4;
	}
	else if (location == cmos_NBNS_IP) {
		vector[3] = cmos_NBNS_IP_OCTET_4;
	}
	else {
		vector[3] = location+3;
	}
}


static unsigned int read_cmos_byte(int location)
{
	int val = _kernel_osbyte(osbyte_READ_CMOS, location, 0);
	return val < 0 ? 0 : (val >> 8) & 0xFF;
}

static void write_cmos_byte(int location, unsigned int value)
{
	if (location != 0) {
		(void) _kernel_osbyte(osbyte_WRITE_CMOS, location, value);
	}
	else {
		iicpoke(value);
	}
}

/* This function reads and then corrects the CMOS checksum if it is wrong */
static void verify_cmos_checksum(void)
{
	unsigned int sum, location;

	for (location = 0, sum = 1; location < 239; ++location) {
		sum += read_cmos_byte(location);
	}
	sum = sum & 0xFF;
	if (sum != read_cmos_byte(cmos_CHECKSUM)) {
		write_cmos_byte(cmos_CHECKSUM, sum);
	}
}

/* Read an IP address (or 4 byte value) from CMOS.
 */
static void ReadIPCMOS( int location, struct in_addr *ip )
{
	int i;
	int vector[4];
	unsigned char *p = (unsigned char *) ip;

	get_cmos_vector(location, vector);

	for ( i = 0; i < 4; i++ ) {
		*p++ = (unsigned char) read_cmos_byte(vector[i]);
	}
}


/* Write an IP address (or 4 byte value) to CMOS.
 */
static void WriteIPCMOS( int location, const struct in_addr *ip )
{
	int i;
	int vector[4];
	const unsigned char *p = (const unsigned char *) ip;

	get_cmos_vector(location, vector);

	for ( i = 0; i < 4; i++ ) {
		write_cmos_byte(vector[i], *p++);
	}
}

static void ReadATMCMOS( int location_lo, int location_hi, unsigned short *pvc)
{
	*pvc = read_cmos_byte(location_lo) | (read_cmos_byte(location_hi) << 8);
}

static void WriteATMCMOS( int location_lo, int location_hi, unsigned short pvc)
{
	write_cmos_byte(location_lo, pvc & 0xFF);
	write_cmos_byte(location_hi, pvc >> 8);
}

/* Read a \0 terminated string from CMOS.
 */
static void ReadStringCMOS( int location, char *p, int bufsz )
{
	while ( --bufsz ) {
		if ((*p++ = read_cmos_byte(location++)) == '\0') return;
	}
	*p = '\0';
}


/* Write a \0 terminated string to CMOS.
 */
static void WriteStringCMOS( int location, char *p )
{
	do {
		write_cmos_byte(location++, *p);
	} while ( *p++ != '\0' );
}


/* Read all static IP data from CMOS.
 */
void ReadIPData( ip_data *ip )
{
	unsigned int flags;

	ReadIPCMOS( cmos_HOST_IP, &ip->client_ip );
	ReadIPCMOS( cmos_SERVER_IP, &ip->server_ip );
	ReadIPCMOS( cmos_GATEWAY_IP, &ip->gateway_ip );
	ReadIPCMOS( cmos_DNS_IP, &ip->dns_ip );
	ReadIPCMOS( cmos_IP_ADDR_1, &ip->addr1_ip );
	ReadIPCMOS( cmos_IP_ADDR_2, &ip->addr2_ip );
	ReadIPCMOS( cmos_IP_ADDR_3, &ip->addr3_ip );
	ReadIPCMOS( cmos_IP_ADDR_4, &ip->addr4_ip );
	ReadStringCMOS( cmos_BOOT_MOUNT, ip->boot_mount, cmos_BOOT_MOUNT_SZ );
	ReadATMCMOS( cmos_ATM_PVC_LOW, cmos_ATM_PVC_HIGH, &ip->atm_pvc );

	flags = read_cmos_byte(cmos_NETMASK);
	ip->netmask = (flags & cmos_NETMASK_MASK) >> cmos_NETMASK_SHIFT;

	if (cmos_NETMASK != cmos_STATIC_FLAG) flags = read_cmos_byte(cmos_STATIC_FLAG);
	ip->static_flag = (flags & cmos_STATIC_FLAG_BIT_MASK) != 0;

	ip->terminator = '\0';
	SetMask(&ip->netmask_ip, ip->netmask);
}


/*
 * Write all static IP data to CMOS.
 */
void WriteIPData( ip_data *ip )
{
	unsigned int flags;

	WriteIPCMOS( cmos_HOST_IP, &ip->client_ip );
	WriteIPCMOS( cmos_SERVER_IP, &ip->server_ip );
	WriteIPCMOS( cmos_GATEWAY_IP, &ip->gateway_ip );
	WriteIPCMOS( cmos_DNS_IP, &ip->dns_ip );
	WriteIPCMOS( cmos_IP_ADDR_1, &ip->addr1_ip );
	WriteIPCMOS( cmos_IP_ADDR_2, &ip->addr2_ip );
	WriteIPCMOS( cmos_IP_ADDR_3, &ip->addr3_ip );
	WriteIPCMOS( cmos_IP_ADDR_4, &ip->addr4_ip );
	WriteStringCMOS( cmos_BOOT_MOUNT, ip->boot_mount );
	WriteATMCMOS ( cmos_ATM_PVC_LOW, cmos_ATM_PVC_HIGH, ip->atm_pvc );

	flags = read_cmos_byte(cmos_NETMASK);
	flags = (flags & ~cmos_NETMASK_MASK) | (ip->netmask << cmos_NETMASK_SHIFT);
	if (cmos_NETMASK != cmos_STATIC_FLAG) {
		write_cmos_byte(cmos_NETMASK, flags);
		flags = read_cmos_byte(cmos_STATIC_FLAG);
	}
	flags = (flags & ~cmos_STATIC_FLAG_BIT_MASK) |
		(ip->static_flag ? cmos_STATIC_FLAG_BIT_MASK:0);
	write_cmos_byte(cmos_STATIC_FLAG, flags);

	verify_cmos_checksum();
}

/* Returns the number of extra addresses we are going to prompt
 * for.
 */
int read_address_count(void)
{
	return extra_ip;
}

/* Returns the delay we are willing to sit and wait for a delayed keypress
 */
int read_keywait_delay(void)
{
	return keywait_delay;
}

/* Returns whether we have an ATM interface card present
 */
int using_atm_card(void)
{
	return got_atm_card;
}

/* Called if read_device_name discovers an ATM card
 */
void found_atm_card(void)
{
	got_atm_card = 1;
}

#pragma -v1
/* Pragma enables the printf style format checking */
static int lm_printf(const char *format, ...)
{
	va_list ap;
	int i;

	for (i = 0; i < left_indent; ++i) {
		fputc(' ', stdout);
	}

	va_start(ap, format);
	i += vprintf(format, ap);
	va_end(ap);

	return i;
}
#pragma -v0

/*  Determines if the IP address is not set
 */
static int editconfig_is_inaddr_any(const struct in_addr *p)
{
	return p->s_addr == INADDR_ANY;
}


/* Write a newline character
 */
static void newline(void)
{
	fputc('\n', stdout);
}

/* Clear the screen.
 */
static void Cls(void)
{
	int newlines = vertical_gap;
	(void) _swix(OS_WriteC, _IN(0), 12);

	while (newlines--) {
		newline();
	}
}

/* Format a 6-byte MAC address into the given buffer.  Buffer must be 18
 * characters long (13 if sep is '\0') .  If sep is '\0' then no separator
 * is placed between bytes of the MAC address.
 */
void format_mac_address(const struct ether_addr *mac, char *buffer, char sep)
{
	int i;

	for (i=0; i<6; ++i) {
		if (i > 0 && sep != '\0') {
			*buffer++ = sep;
		}
		buffer += sprintf(buffer, "%02x", mac->octet[i]);
	}
	*buffer = '\0';
}

/* Write a string (reads tag from Messages file)
 */
size_t write_tag_msg(const char *tag)
{
	const char *ptr = NULL;
	size_t inoutlength = 0;

	lm_printf("");
	(void) read_message(tag, &ptr, &inoutlength);
	return fwrite(ptr, 1, inoutlength, stdout);
}

void write_tag_msg_nl(const char *tag)
{
	write_tag_msg(tag);
	newline();
}

void write_tag_nl_msg_nl(const char *tag)
{
	newline();
	write_tag_msg_nl(tag);
	newline();
}

static void lm_print_hdr(const char *message)
{
	int i;

	i = field_width - write_tag_msg(message);
	fputc(':', stdout);
	for (; i > 0; --i) {
		fputc(' ', stdout);
	}
}


/* Read a message
 */
_kernel_oserror *read_msg(const char *tag, char *buffer, size_t msg)
{
	const char *ptr = buffer;
	size_t inoutlength = msg;

	return read_message(tag, &ptr, &inoutlength);
}

/* Print an IP address.
 */
static char *FormatIP( const struct in_addr *ip, char *buf )
{
	return strcpy(buf, inet_ntoa(*ip));
}

static void SetMask(struct in_addr *ip, int bits)
{
	unsigned char *p = (unsigned char *) ip;
	int i, j;

	p[0] = p[1] = p[2] = p[3] = '\0';
	bits = bits & 0x1F;
	if (bits == 0) bits = 32;

	for (i=0; i<4; ++i) {
		for (j=7; j>=0; --j) {
			if (--bits < 0) return;
			p[i] |= (1<<j);
		}
	}

}

void GetMask(const struct in_addr *ip, int *bits)
{
	int i, j, bit = 0;
	const unsigned char *p = (const unsigned char *) ip;

	for (i=0; i<4; ++i) {
		for (j=7; j>=0; --j) {
			if (p[i] & (1<<j)) {
				++bit;
			}
			else {
				*bits = bit;
				return;
			}
		}
	}
	*bits = bit;
}

static void PrintIP( const struct in_addr *p )
{
	/* If you want to change this to fputs, then show some Clue (read some C library docs
	 * to find out what extra stuff you need to do too)
	 */
	if (editconfig_is_inaddr_any(p)) {
		puts(unset);
	}
	else {
		char buf[sizeof("123.123.123.123")];
		puts(FormatIP(p, buf));
	}
}

/* Reads message and pads it, prints data out
 */
static void ShowIPConfigLine(const char *tag, const struct in_addr *p)
{
	(void) lm_print_hdr(tag);
	PrintIP(p);
}

/* Print all static IP data.
 */
static void PrintIPData( const ip_data *ip )
{
	char msg[64];

	Cls();

	ShowIPConfigLine("IPAddr", &ip->client_ip);
	ShowIPConfigLine("SNMask", &ip->netmask_ip);
	ShowIPConfigLine("GwIPAddr", &ip->gateway_ip);
	ShowIPConfigLine("BTSvAddr", &ip->server_ip);
	if (extra_ip > 0) ShowIPConfigLine("IPAddr1", &ip->addr1_ip);
	if (extra_ip > 1) ShowIPConfigLine("IPAddr2", &ip->addr2_ip);
	if (extra_ip > 2) ShowIPConfigLine("IPAddr3", &ip->addr3_ip);
	if (extra_ip > 3) ShowIPConfigLine("IPAddr4", &ip->addr4_ip);
	ShowIPConfigLine("DNSIPAddr", &ip->dns_ip);

	lm_print_hdr("BootMount");
	puts(ip->boot_mount);

	if (using_atm_card()) {
		lm_print_hdr("ATMPVCAddr");
		if (ip->atm_pvc != 0) {
			printf("%hu\n", ip->atm_pvc);
		}
		else {
			puts(unset);
		}
	}

	lm_print_hdr("StatBFlag");
	read_msg(ip->static_flag ? "Enabled" : "Disabled", msg, sizeof(msg));
	puts(msg);
	newline();
}


/* Get a string from stdin. If return is pressed straight away then the
 * buffer is left with a zero byte in the first position.
 */
static void GetString( const char *message, char *buf, int bufsz, char *def_value )
{
	int c;

	write_tag_msg(message);
	fputc(' ', stdout);
	fflush(stdout);
	/* Copy the default as the new value - terminator NOT required */
	strncpy(buf, def_value, bufsz);
	/* Get a line of text (using code pinched from C library) */
	c = lineedit_getline((unsigned char *) buf, bufsz);
	if (c < 0) {
		/* EOF or error */
		buf[0] = '\0';
	}
	else {
		buf[bufsz-c-1] = '\0';
	}
}

/* Get an ATM PVC address from stdin.
 */
static void GetPVC( const char *message, unsigned short *pvc)
{
	for (;;) {
		char buf[16];

		if (*pvc != 0) {
			(void) sprintf(buf, "%hu", *pvc);
		}
		else {
			*buf = '\0';
		}

		GetString(message, buf, sizeof(buf), buf);
		if (buf[0] != '\0') {
			int base = 0;
			int offs = 0;
			unsigned long new_val;
			if (buf[0] == '$' || buf[0] == '&') {
				base = 16;
				offs = 1;
			}
			new_val = strtoul(buf + offs, NULL, base);
			if (new_val == 65535 || (new_val >> 16) != 0) {
				write_tag_msg_nl("NeedOKPVC");
				newline();
				continue;
			}
			*pvc = (unsigned short) new_val;
		}
		else {
			write_tag_msg_nl("FldUnXed");
		}
		newline();
		break;
	}
}


/* Get an IP address from stdin.  The following formats are allowed:
 *
 *    136.170.131.2
 *    0xfffff800
 *    0Xfffff800
 *    &77aa1123
 *    $11bb4afe
 *    d1ad0987
 *
 *  Hex digits are not case-sensitive.  The $ prefix is supported for the benefit
 *  of people not used to the Acorn usage of & as a base 16 prefix indicator.
 *
 */
static void GetIP( char *message, struct in_addr *p, int *bits )
{
	int i, j, mask, d[4];
	if (bits != NULL) *bits = -1;

	do {
		char buf[24];
		int was_inaddr_any = editconfig_is_inaddr_any(p);

		if (was_inaddr_any) {
			buf[0] = '\0'; /* Don't prime with 0.0.0.0 */
		}
		else {
			FormatIP(p, buf);
		}
		GetString( message, buf, sizeof(buf), buf);
		if ( buf[0] == '\0' ) {
			if (!was_inaddr_any) {
				write_tag_msg_nl("FldUnXed");
			}
			newline();
			return;
		}
		i = sscanf( buf, "%d.%d.%d.%d/%d", d, d+1, d+2, d+3, &mask);
		if (i < 4 && strlen(buf) >= 8) {
			/* Perhaps this is a hexadecimal string */
			char *b = buf;
			if (*b == '$' || *b == '&') ++b;
			else if (b[0] == '0' && (b[1] == 'x' || b[1] == 'X')) b+=2;
			if (strlen(b) >= 8) {
				char numbuf[4];
				int j;
				for (j=0; j<4; ++j) {
					if ((isxdigit)(b[j*2]) && (isxdigit)(b[j*2+1])) {
						numbuf[0] = b[j*2];
						numbuf[1] = b[j*2+1];
						numbuf[2] = 0;
						d[j] = (int) strtoul(numbuf, NULL, 16);
					}
					else {
						break;
					}
				}
				i=j;
				b += 8;
				if (*b == '/') {
					mask = (int) strtoul(b+1, NULL, 0);
					++i;
				}
			}
		}
		newline();
		if (i >= 4) {
			/* Are all the numbers in the inclusive range 0 to 255 */
			for (j = 0; j<4; ++j) {
				if (d[j] < 0 || d[j] >= 256) {
					i = 0;
				}
			}
		}
		if (i == 5 && (mask < 1 || mask > 32)) {
			/* Was the netmask invalid?  If so, pretend it wasn't there */
			i = 4;
			mask = -1;
		}
		if ( i < 4 ) {
			write_tag_msg_nl("IPReqd");
			newline();
		}
	} while ( i < 4 );

	for ( i = 0; i < 4; i++ ) {
		unsigned char *pp = (unsigned char *) p;
		pp[i] = (unsigned char)d[i];
	}
	if (bits != NULL) *bits = mask;
}

/* Get a yes/no response from the user. Returns true if yes.
 * Returns a default of defstate if no answer was given.
 */
static int Yes(const char *message, int defstate)
{
	char yesbuf[8];

	/* It is irritating to have to delete the prompted answer
	 * so don't provide one for yes/no questions */
	yesbuf[0] = '\0';
	GetString(message, yesbuf, sizeof(yesbuf)-1, yesbuf);
	if (yesbuf[0] == '\0') return defstate;
	return (strpbrk(yesbuf, yeschars) == yesbuf);
}


/* Reboot the machine - unless we are a trace build
 */
_kernel_oserror *reboot(_kernel_swi_regs *r, void *pw)
{
	(void) r;
	(void) pw;
	#ifdef TRACE
	printf("\n>> " Module_Title " trace build: Normal ROM/RAM build would call OS_Reset now\n\n");
	return 0;
	#else
	return _swix(OS_Reset, 0);
	#endif
}

/* Read a numeric value of a given message tag, and constrain the value to
 * the supplied range, returning the value read.
 */
static int ReadNumMsg(const char *tag, int min, int max)
{
	char msg[64];
	int val;

	val = (read_msg(tag, msg, sizeof(msg)) != NULL) ? 0 : atoi(msg);
	if (val < min) val = min;
	if (val > max) val = max;
	return val;
}

/* Read basic screen layout configuration information (ifrconfig uses these values too)
 */
static void ReadMainVars(void)
{
	vertical_gap = ReadNumMsg("VSkip:10", 0, 100);
	left_indent = ReadNumMsg("LMargin:8", 0, 100);
	field_width = ReadNumMsg("HdrWidth:24", 0, 100);
	keywait_delay = ReadNumMsg("KeyDelay:20", 0, 1024);
	read_msg("YesChars:yY", yeschars, sizeof(yeschars));
	read_msg("NoChars:nN", nochars, sizeof(nochars));
	read_msg("IPCount:0", unset, sizeof(unset));
	extra_ip = atoi(unset);
	if (extra_ip < 0) extra_ip = 0; else if (extra_ip > 4) extra_ip = 4;
	read_msg("NoIP:Unset", unset, sizeof(unset));
}

/* Validates the client, net mask and destination address to ensure that they
 * are consistent (ie. the destination must be reachable on the addressable sub-net!)
 */
static int editconfig_address_reachable(const struct in_addr *client,
		const struct in_addr *mask, const struct in_addr *dest)
{
	return (client->s_addr & mask->s_addr) == (dest->s_addr & mask->s_addr);
}

/* Pokes the ATM driver during startup if necessary */
void editconfig_exec_atm_start(ip_data *ip)
{
	struct in_addr *pvc_dest;
	char IParg[sizeof("123.123.123.123")];
	char pvc_address[sizeof("12345")];
	char cmdbuf[64];
	const char *pcmdbuf;
	size_t inoutlength;

	/* Can we see the boot server?  If so, establish the PVC to the boot server.
	 * If not, then we establish the PVC to the gateway instead
	 */
	if (editconfig_address_reachable(&ip->client_ip, &ip->netmask_ip, &ip->server_ip)) {
		pvc_dest = &ip->server_ip;
	}
	else {
		pvc_dest = &ip->gateway_ip;
	}

	(void) sprintf(pvc_address, "%hu", ip->atm_pvc);
	(void) FormatIP(pvc_dest, IParg);
	pcmdbuf = &cmdbuf[0];
	inoutlength = sizeof(cmdbuf);
	if (read_message_2("ATMStart:||", &pcmdbuf, &inoutlength, IParg, pvc_address) == NULL) {
		(void) _kernel_oscli(pcmdbuf);
	}
}

/* This function validates the IP address of the host in the context of the
 * netmask and will return non-zero if the host address is the network or
 * broadcast address corresponding to the specified netmask.  It will NOT
 * fault 0.0.0.0 though, as this is the special value indicating that the
 * host address remains unset.
 */
static int editconfig_host_address_invalid(const ip_data *ip)
{
	if (ip->client_ip.s_addr == INADDR_ANY) return 0;

	if ((ip->netmask_ip.s_addr | ip->client_ip.s_addr) == INADDR_BROADCAST) {
		write_tag_msg_nl("IPNotBC");
		return 1;
	}

	if ((~ip->netmask_ip.s_addr & ip->client_ip.s_addr) == INADDR_ANY) {
		write_tag_msg_nl("IPNotNAddr");
		return 1;
	}

	return 0;
}

/*
 * The main routine controlling the reconfiguration of the CMOS.  Does not
 * exit (in non-trace builds).
 */
void editconfig_service(void *pw)
{
	#ifndef TRACE
	/* Set the default escape handler to reboot the machine. Don't need
	 * to remember old handler as we always reboot after getting this far.
	 */

	(void) _swix(OS_ChangeEnvironment, _INR(0,3), 9, veneer_reboot, pw, 0);
	#else
	(void) pw;
	#endif

	ReadMainVars();

	for (;;) {
		ip_data ip;
		int bits;
		char buf[cmos_BOOT_MOUNT_SZ];

		ReadIPData( &ip );
		PrintIPData( &ip );

		if ( !Yes("QChange", 0)) {
			reboot(0,0);
			#ifdef TRACE
			break;
			#endif
		}

		PrintIPData( &ip );

		newline();
		write_tag_msg_nl("BlkPresv");
		newline();

		for (;;) {
			SetMask(&ip.netmask_ip, ip.netmask);
			GetIP( "QIPAddr", &ip.client_ip, &bits );
			if (IN_MULTICAST(htonl(ip.client_ip.s_addr))) {
				newline();
				write_tag_msg_nl("IPNotMulti");
				newline();
				continue;
			}
			if (bits > -1 && bits < 32) {
				SetMask(&ip.netmask_ip, bits);
			}
			for (;;) {
				GetIP( "QSNMask", &ip.netmask_ip, NULL );
				GetMask(&ip.netmask_ip, &bits);
				if (editconfig_host_address_invalid(&ip)) {
					bits = -1;
					break;
				}
				if (bits > 0 && bits <= 32) break;
				write_tag_msg_nl("NeedOKMask");
			}
			if (bits == -1) continue;
			ip.netmask = bits;
			SetMask(&ip.netmask_ip, ip.netmask);

			GetIP( "QGwIPAddr", &ip.gateway_ip, NULL );

			if (editconfig_is_inaddr_any(&ip.gateway_ip)) {
				write_tag_msg_nl("NoGWNoRte1");
				write_tag_msg_nl("NoGWNoRte2");
				newline();
				if (!Yes("QSureNoGW", 1)) {
					newline();
					continue;
				}
				newline();
				break;
			}

			if (editconfig_address_reachable(&ip.client_ip,
					&ip.netmask_ip, &ip.gateway_ip)) {
				break;
			}
			newline();
			write_tag_msg_nl("NeedLocGW1");
			write_tag_msg_nl("NeedLocGW2");
			newline();
		}

		GetIP( "QDNSIPAddr", &ip.dns_ip, NULL );
		GetIP( "QBTSvAddr", &ip.server_ip, NULL );
		if (extra_ip > 0) GetIP( "QAddr1", &ip.addr1_ip, NULL );
		if (extra_ip > 1) GetIP( "QAddr2", &ip.addr2_ip, NULL );
		if (extra_ip > 2) GetIP( "QAddr3", &ip.addr3_ip, NULL );
		if (extra_ip > 3) GetIP( "QAddr4", &ip.addr4_ip, NULL );

		GetString( "QBootMount", buf, cmos_BOOT_MOUNT_SZ, ip.boot_mount);
		ip.boot_mount[0] = '\0';
		(void) strncat(ip.boot_mount, buf, cmos_BOOT_MOUNT_SZ);
		newline();

		if (using_atm_card()) {
			GetPVC( "QATMPVC", &ip.atm_pvc);
		}

		ip.static_flag = (Yes("QStaticB", ip.static_flag)) != 0;

		PrintIPData( &ip );

		if ( Yes("QCommitNV", 1) ) {
			WriteIPData( &ip );
			newline();
			write_tag_msg_nl("NVWrtDone");
			(void)getchar();
			reboot(0,0);
			#ifdef TRACE
			break;
			#endif
		}

	/* Changes not committed so go round and ask again. */
	}
}

static int is_key_down(int key)
{
	(void) _swix(OS_Byte, _INR(0,1)|_OUT(1), osbyte_KEY_SCAN, key, &key);
	return key;
}

/* Internal key numbers are XOR'ed with &80 to effect a single key scan */
enum {
	key_LEFT_ALT = 5 | 0x80,
	key_RIGHT_ALT = 8 | 0x80,

	key_LEFT_SHIFT = 3 | 0x80,
	key_RIGHT_SHIFT = 6 | 0x80,

	key_LEFT_CTRL = 4 | 0x80,
	key_RIGHT_CTRL = 7 | 0x80
};

/* Return true if the all of the keyboard combination keys are down
 */
int editconfig_check_keys(keycheck_set which)
{
	int k;

	k = module_read_command_options();
	if (which == keycheck_BOTH_ALTS_AND_SHIFTS && (k & flag_NO_DO_BOOT)) return 1;
	if (which == keycheck_BOTH_ALTS && (k & flag_RUN_EDITOR)) return 1;

	k = is_key_down(key_LEFT_ALT) && is_key_down(key_RIGHT_ALT);
	if (k && which == keycheck_BOTH_ALTS_AND_SHIFTS) {
		k = is_key_down(key_LEFT_SHIFT) && is_key_down(key_RIGHT_SHIFT);
	}

	return k != 0;
}

/*------------------------------------------------------------------------------
 * called from module initialisation to check initialisation state
 */
_kernel_oserror *editconfig_initialise(void)
{
	ReadMainVars();
	return editconfig_check_keys(keycheck_BOTH_ALTS) ?
		NULL : make_error(error_REFUSE_INIT_KEYS_NOT_PRESSED, 0);
}
