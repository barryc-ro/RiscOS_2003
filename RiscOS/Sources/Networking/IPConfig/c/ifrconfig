/*
 * IFConfig (ifrconfig.c)
 *
 * Copyright (C) Acorn Computers Ltd. 1998
 *
 *
 * Originally based upon DoBootp/ifrconfig.c
 *
 */

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#include "kernel.h"
#include "swis.h"

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/ioctl.h"
#include "net/route.h"
#include "netinet/in.h"
#include "net/if.h"
#include "sys/errno.h"
#include "arpa/inet.h"

#include "socklib.h"

#include "editconfig.h"
#include "ifrconfig.h"
#include "module.h"
#include "sysvars.h"
#include "Strncmp_ci.h"
#ifdef TRACE
#  include "IPConfHdrD.h"
#else
#  include "IPConfHdr.h"
#endif



/*
 *  Don't bother defining this.  BOOTP/DHCP can do it all on its own
 */
#undef GET_NETMASK_VIA_ICMP


static struct sockaddr_in ipaddr = { 0 };

#ifdef GET_NETMASK_VIA_ICMP
static struct sockaddr_in broadcast = { 0 };
struct sockaddr_in netmask = { 0 };
#endif

/*
 * If this value is set to one, then you will NOT be able to use
 * BOOTP through BOOTP gateways, because relay agents typically
 * defer copying the request to subnets until the first retry is
 * received (to avoid flooding the whole network unnecessarily).
 *
 * I assume that, by induction, this means that if the request needs
 * to be relayed N times, then this value needs to be at least (N+1)
 */
#define MAX_TRIES 10

/*
 * ifrconfig_set_default_route
 *
 * - takes as parameter an open socket id
 * - reads the system variable Inet$Gateway (string a.b.c.d)
 * - converts the var string to u_long inet address
 * - establishes that address as the default route
 *
*/

static int ifrconfig_set_default_route(int sockid)
{
    char *gwvar;
    unsigned long gateway_adr;
    struct sockaddr_in *sin;
    struct in_addr gw_in;

    /* If variable is not set then return success. */
    gwvar = getenv(SYSVAR_INET_GATEWAY);
    if (gwvar == NULL || gwvar[0] == '\0') return (1);

    if (inet_aton(gwvar, &gw_in) == 0 || gw_in.s_addr == INADDR_ANY)
        return (0);
    gateway_adr = gw_in.s_addr;

    if (socketversion() < 500)
    {
        struct ortentry route;

        sin = (struct sockaddr_in *)&route.rt_dst;
        sin->sin_family = AF_INET;
        sin->sin_addr = inet_makeaddr(0, INADDR_ANY);
        sin = (struct sockaddr_in *)&route.rt_gateway;
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = gateway_adr;
        route.rt_flags = RTF_UP;
        route.rt_flags |= RTF_GATEWAY;

        if (socketioctl(sockid, SIOCADDRT, (caddr_t)&route) < 0)
            return (0);
        return (1);
    }
    else
    {
        static int rtm_seq;
        int routes;
        struct {
    	    struct rt_msghdr	hdr;
    	    struct nsockaddr_in	dst;
    	    struct nsockaddr_in	gway;
    	    struct nsockaddr_in	mask;
        } rtmsg;

        if ((routes = socket(PF_ROUTE, SOCK_RAW, AF_INET)) < 0) {
            return 0;
        }

        memset(&rtmsg, 0, sizeof(rtmsg));
        rtmsg.hdr.rtm_type = RTM_ADD;
        rtmsg.hdr.rtm_flags = RTF_UP | RTF_GATEWAY;
        rtmsg.hdr.rtm_version = RTM_VERSION;
        rtmsg.hdr.rtm_seq = ++rtm_seq;
        rtmsg.hdr.rtm_addrs = RTA_DST | RTA_GATEWAY | RTA_NETMASK;
        rtmsg.dst.sin_len = sizeof(rtmsg.dst);
        rtmsg.dst.sin_family = AF_INET;
        rtmsg.gway.sin_len = sizeof(rtmsg.gway);
        rtmsg.gway.sin_family = AF_INET;
        rtmsg.gway.sin_addr.s_addr = gateway_adr;
        rtmsg.mask.sin_len = sizeof(rtmsg.dst);
        rtmsg.mask.sin_family = AF_INET;

        rtmsg.hdr.rtm_msglen = sizeof(rtmsg);
        if (socketwrite(routes, &rtmsg, sizeof(rtmsg)) < 0) {
            return (0);
        }

        socketclose(routes);
        return 1;
    }
}

/*
 * set_netmask
 *
 * - takes as parameter an open socket id
 * - reads the system variable Inet$EtherIPMask (string a.b.c.d)
 * - converts the var string to u_long value
 * - establishes that value as the netmask
 *
*/

static int set_netmask(int sockid, char *ifname)
{
    unsigned long net_mask;
    struct sockaddr_in *sin;
    struct  ifreq ifr;
    char *maskvar;
    struct in_addr nm_in;

    /* If variable is not set then return success. */
    maskvar = getenv(SYSVAR_INET_ETHERIPMASK);
    if (maskvar == NULL || maskvar[0] == '\0') return (1);

    if (inet_aton(maskvar, &nm_in) == 0)
        return (0);
    net_mask = nm_in.s_addr;

    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
    sin = (struct sockaddr_in *)&ifr.ifr_addr;
    sin->sin_addr.s_addr = net_mask;
    sin->sin_family = AF_INET;
    if (socketioctl(sockid, SIOCSIFNETMASK, (caddr_t)&ifr) < 0)
        return (0);
    return (1);
}


#ifdef USECMOS

static void SetVarVal( const char *var, const char *val )
{
        _kernel_setenv(var, val);
}

static int set_ipaddr( int s, char *ifname, struct in_addr *v )
{
    	struct ifreq ifr;
    	struct sockaddr_in *sin;

    	if (v->s_addr == INADDR_ANY) {
        	return 0;
        }
    	(void) memset(&ifr, 0, sizeof(ifr));
    	(void) strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
    	sin = (struct sockaddr_in *)&ifr.ifr_addr;
    	sin->sin_addr.s_addr = v->s_addr;
    	sin->sin_family = AF_INET;
    	if (socketioctl(s, SIOCSIFADDR, (caddr_t)&ifr) < 0) {
        	return (0);
        }
    	return 1;
}

static void ifrconfig_set_var(const char *var, const struct in_addr ip)
{
        SetVarVal(var, inet_ntoa(ip));
}

static int use_configured_info( int s, char *ifname, ip_data *ip )
{

    	if (ip->static_flag) {
     		if ( set_ipaddr(s, ifname, (struct in_addr *) &ip->client_ip) != 0 ) {
                        const int ac = read_address_count();
	    		write_tag_msg_nl("IFRUsingSt");

            		SetVarVal( SYSVAR_INET_BOOTFILE, ip->boot_mount);
            		SetVarVal( SYSVAR_INET_MOUNTPATH, ip->boot_mount );

	    		ifrconfig_set_var(SYSVAR_INET_BOOTSERVER, ip->server_ip);
	    		ifrconfig_set_var(SYSVAR_INET_GATEWAY, ip->gateway_ip);
	    		ifrconfig_set_var(SYSVAR_INET_RESOLVERS, ip->dns_ip);
	    		if (ac>0) ifrconfig_set_var(SYSVAR_INET_ADDR_1, ip->addr1_ip);
	    		if (ac>1) ifrconfig_set_var(SYSVAR_INET_ADDR_2, ip->addr2_ip);
	    		if (ac>2) ifrconfig_set_var(SYSVAR_INET_ADDR_3, ip->addr3_ip);
	    		if (ac>3) ifrconfig_set_var(SYSVAR_INET_ADDR_4, ip->addr4_ip);
	    		ifrconfig_set_var(SYSVAR_INET_ETHERIPMASK, ip->netmask_ip);
			/* Inform the ATM driver what is going on (if necessary) */
			if (using_atm_card()) {
			        editconfig_exec_atm_start(ip);
			}
            		return 1;
                }
                else {
                        /* Static configuration has failed - reset CMOS flag bits so that
                         * a dynamic boot occurs next time
                         */
                        ip->static_flag = 0;
                        WriteIPData(ip);
                }
        }

    	return 0;
}


static int GetIPVar(struct in_addr *in, const char *env)
{
        struct in_addr i;
        const char *val = getenv(env);

        if (val != NULL && inet_aton(val, &i)) {
                *in = i;
                return 1;
        }
        return 0;
}

/* Searches the comma-separated string for the given keyword, case insensitively.
 * Returns 1 if it found it, 0 if it did not.  env may not be NULL on entry.
 */
static int ifrconfig_find_keyword(const char *env, const char *keyword)
{
        const size_t len = strlen(keyword);

        while (*env != '\0') {
        	if (Strncmp_ci(env, keyword, len) == 0) {
                	if (env[len] == '\0' || env[len] == ',') return 1;
                }
                /* Skip to next keyword */
                while (*env != '\0' && *env != ',') {
                        ++env;
                }
        }

        return 0;
}

/*
 *  This function examines the private data returned by the boot server (if any)
 *  to determine whether we are required to write the dynamically discovered
 *  data into the NVRAM and switch to static booting for future boot attempts.
 */
static void check_switch_to_static_boot(ip_data *ip)
{
        const int ac = read_address_count();
        const char *env = getenv(SYSVAR_INET_PRIVATEDATA);

        if (env == NULL) return;
        if (!ifrconfig_find_keyword(env, "static")) return;

#ifdef TRACE
	write_tag_msg_nl("IFRStore");
#endif

        /* Write new data to CMOS and set next boot to use static data */
        ReadIPData(ip);
        ip->client_ip = ipaddr.sin_addr;
	(void) GetIPVar(&ip->server_ip, SYSVAR_INET_BOOTSERVER);
	(void) GetIPVar(&ip->gateway_ip, SYSVAR_INET_GATEWAY);
	(void) GetIPVar(&ip->dns_ip, SYSVAR_INET_RESOLVERS);
	if (ac>0) (void) GetIPVar(&ip->addr1_ip, SYSVAR_INET_ADDR_1);
	if (ac>1) (void) GetIPVar(&ip->addr2_ip, SYSVAR_INET_ADDR_2);
	if (ac>2) (void) GetIPVar(&ip->addr3_ip, SYSVAR_INET_ADDR_3);
	if (ac>3) (void) GetIPVar(&ip->addr4_ip, SYSVAR_INET_ADDR_4);
	if (GetIPVar(&ip->netmask_ip, SYSVAR_INET_ETHERIPMASK)) {
	        GetMask(&ip->netmask_ip, (int *) &ip->netmask);
	}
	env = getenv(SYSVAR_INET_BOOTFILE);
	if (env != NULL) {
	        (void) strncpy(ip->boot_mount, env, cmos_BOOT_MOUNT_SZ);
	}
        ip->static_flag = 1;
        WriteIPData(ip);
}
#endif


/* ifrconfig
 *
 * This function controls the dynamic booting process.
 */
int ifrconfig(int s, char *ifname)
{
        ip_data ip;
        struct  ifreq ifr;
        int	retries;

	write_tag_msg_nl("IFRInit");
	ReadIPData(&ip);

#ifdef USECMOS
        /* Try static IP information first.
         */
        if ( use_configured_info(s, ifname, &ip) == 0 ) {
#endif
               	if (editconfig_check_keys(keycheck_BOTH_ALTS_AND_SHIFTS)) {
                	return 0;
                }

		for (retries = 0; retries < MAX_TRIES; ++retries) {
	            	(void) strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
	            	if (socketioctl(s, SIOCGWHOIAMB, (caddr_t)&ifr) < 0) {
	                	newline();
	            		write_tag_msg_nl("IFRSrchBS");
                		continue;
                        }
                        else break;
		}
		if (retries == MAX_TRIES) {
		        /* OK - had enough - give up and reboot */
            		write_tag_msg_nl("IFRNoBS");
               		reboot(0,0);
                	#ifndef ROM
       	        	return 0;
               		#endif
            	}
#ifdef USECMOS
        }
#endif

        (void) strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
        if (socketioctl(s, SIOCGIFADDR, (caddr_t)&ifr) < 0) {
            	newline();
            	write_tag_msg_nl("IFRNoRNA");
            	return (0);
        }

        ipaddr.sin_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;

#ifdef TRACE
	write_tag_msg("IFRMNAIs");
        printf(": %s\n", inet_ntoa(ipaddr.sin_addr));
#endif

        /* Try to set the default route if necessary. */
        if (ifrconfig_set_default_route(s) == 0) {
            	write_tag_msg_nl("IFRNDRt");
        }

        /* Try to set the sub-net mask if necessary. */
        if (set_netmask(s, ifname) == 0) {
            	write_tag_msg_nl("IFRNDNM");
        }

#ifdef GET_NETMASK_VIA_ICMP
        /* Gets netmask via ICMP (no longer required).
         */
#  ifdef TRACE
	write_tag_msg_nl("IFRSrchNM");
#  endif
        (void) socketioctl(s, SIOCGWHOIAMM, (caddr_t)&ifr);
        strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
        if (socketioctl(s, SIOCGIFNETMASK, (caddr_t)&ifr) < 0) {
        	write_tag_msg_nl("IFRNoNM");
            	return (0);
        }
        netmask.sin_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
#  ifdef TRACE
	write_tag_msg("IFRNMIs");
        printf(": %s\n", inet_ntoa(netmask.sin_addr));
#  endif
#endif

#ifdef USECMOS
	if (ip.static_flag == 0) {
		check_switch_to_static_boot(&ip);
	}
#endif

        return 1;
}
