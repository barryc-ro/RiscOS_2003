/*	IFRCONFIG.C

Project : DEC Westminster trial
Module:

Purpose:


History:

Date      Who     Description of change
===========================================
24/10/95   CP     Changed bootp loop to do MAX_TRIES bootp, and reset if it
                  fails rather than retry 8 times, then go to desktop.

                  This is to get around a bug in bootp which means that
                  only one bootp request is sent, even though there may be
                  many requests to do it.

***************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#include "kernel.h"
#include "swis.h"

#include "editconfig.h"
#include "ifrconfig.h"
#include "module.h"
#ifdef TRACE
#  include "IPConfHdrD.h"
#else
#  include "IPConfHdr.h"
#endif

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/ioctl.h"
#include "net/route.h"
#include "netinet/in.h"
#include "net/if.h"
#include "sys/errno.h"
#include "arpa/inet.h"

#include "socklib.h"


/*
 *  Don't bother defining this.  BOOTP/DHCP can do it all on its own
 */
#undef GET_NETMASK_VIA_ICMP


static struct sockaddr_in ipaddr = { 0 };

#ifdef GET_NETMASK_VIA_ICMP
static struct sockaddr_in broadcast = { 0 };
struct sockaddr_in netmask = { 0 };
#endif

/*
 * If this value is set to one, then you will NOT be able to use
 * BOOTP through BOOTP gateways, because relay agents typically
 * defer copying the request to subnets until the first retry is
 * received (to avoid flooding the whole network unnecessarily).
 *
 * I assume that, by induction, this means that if the request needs
 * to be relayed N times, then this value needs to be at least (N+1)
 */
#define MAX_TRIES 4

/*
 * ifrconfig_set_default_route
 *
 * - takes as parameter an open socket id
 * - reads the system variable Inet$Gateway (string a.b.c.d)
 * - converts the var string to u_long inet address
 * - establishes that address as the default route
 *
*/

int ifrconfig_set_default_route(int sockid)
{
    char *gwvar;
    unsigned long gateway_adr;
    struct sockaddr_in *sin;
    struct in_addr gw_in;

    /* If variable is not set then return success. */
    gwvar = getenv("Inet$Gateway");
    if (gwvar == NULL || gwvar[0] == NULL) return (1);

    if (inet_aton(gwvar, &gw_in) == 0)
        return (0);
    gateway_adr = gw_in.s_addr;

    if (socketversion() < 500)
    {
        struct ortentry route;

        sin = (struct sockaddr_in *)&route.rt_dst;
        sin->sin_family = AF_INET;
        sin->sin_addr = inet_makeaddr(0, INADDR_ANY);
        sin = (struct sockaddr_in *)&route.rt_gateway;
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = gateway_adr;
        route.rt_flags = RTF_UP;
        route.rt_flags |= RTF_GATEWAY;

        if (socketioctl(sockid, SIOCADDRT, (caddr_t)&route) < 0)
            return (0);
        return (1);
    }
    else
    {
        static int rtm_seq;
        int routes;
        struct {
    	    struct rt_msghdr	hdr;
    	    struct nsockaddr_in	dst;
    	    struct nsockaddr_in	gway;
    	    struct nsockaddr_in	mask;
        } rtmsg;

        if ((routes = socket(PF_ROUTE, SOCK_RAW, AF_INET)) < 0) {
            return 0;
        }

        memset(&rtmsg, 0, sizeof(rtmsg));
        rtmsg.hdr.rtm_type = RTM_ADD;
        rtmsg.hdr.rtm_flags = RTF_UP | RTF_GATEWAY;
        rtmsg.hdr.rtm_version = RTM_VERSION;
        rtmsg.hdr.rtm_seq = ++rtm_seq;
        rtmsg.hdr.rtm_addrs = RTA_DST | RTA_GATEWAY | RTA_NETMASK;
        rtmsg.dst.sin_len = sizeof(rtmsg.dst);
        rtmsg.dst.sin_family = AF_INET;
        rtmsg.gway.sin_len = sizeof(rtmsg.gway);
        rtmsg.gway.sin_family = AF_INET;
        rtmsg.gway.sin_addr.s_addr = gateway_adr;
        rtmsg.mask.sin_len = sizeof(rtmsg.dst);
        rtmsg.mask.sin_family = AF_INET;

        rtmsg.hdr.rtm_msglen = sizeof(rtmsg);
        if (socketwrite(routes, &rtmsg, sizeof(rtmsg)) < 0) {
            return (0);
        }

        socketclose(routes);
        return 1;
    }
}

/*
 * set_netmask
 *
 * - takes as parameter an open socket id
 * - reads the system variable Inet$EtherIPMask (string a.b.c.d)
 * - converts the var string to u_long value
 * - establishes that value as the netmask
 *
*/

static int set_netmask(int sockid, char *ifname)
{
    unsigned long net_mask;
    struct sockaddr_in *sin;
    struct  ifreq ifr;
    char *maskvar;
    struct in_addr nm_in;

    /* If variable is not set then return success. */
    maskvar = getenv("Inet$EtherIPMask");
    if (maskvar == NULL || maskvar[0] == '\0') return (1);

    if (inet_aton(maskvar, &nm_in) == 0)
        return (0);
    net_mask = nm_in.s_addr;

    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
    sin = (struct sockaddr_in *)&ifr.ifr_addr;
    sin->sin_addr.s_addr = net_mask;
    sin->sin_family = AF_INET;
    if (socketioctl(sockid, SIOCSIFNETMASK, (caddr_t)&ifr) < 0)
        return (0);
    return (1);
}


#ifdef USECMOS

/* Read an IP address (or 4 byte value) from CMOS.
 */
static u_long
ReadLongIPCMOS( int location )
{
        union {
                unsigned char d[4];
                u_long l;
        } address;

        ReadIPCMOS(location, address.d);
        return address.l;
}

static void SetVarVal( char *var, char *val )
{
        _kernel_setenv(var, val);
}

static int set_ipaddr( int s, char *ifname, struct in_addr *v )
{
    struct ifreq ifr;
    struct sockaddr_in *sin;

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
    sin = (struct sockaddr_in *)&ifr.ifr_addr;
    sin->sin_addr.s_addr = v->s_addr;
    sin->sin_family = AF_INET;
    if (socketioctl(s, SIOCSIFADDR, (caddr_t)&ifr) < 0)
        return (0);
    return 1;
}

static int use_configured_info( int s, char *ifname )
{
    if (read_cmos_byte(FLAGCMOS) & FLAGBIT) {
        struct in_addr v;

        v.s_addr = ReadLongIPCMOS( NCIPCMOS );
     	if ( set_ipaddr(s, ifname, &v) != 0 )
     	{
            char buf[PATHSZ];

	    write_tag_msg_nl("IFRUsingSt");

            v.s_addr = ReadLongIPCMOS( SERVERIPCMOS );
            SetVarVal( "Inet$BootServer", inet_ntoa(v) );

            v.s_addr = ReadLongIPCMOS( GATEWAYIPCMOS );
            SetVarVal( "Inet$Gateway", inet_ntoa(v) );

            v.s_addr = ReadLongIPCMOS( NETMASKCMOS );
            SetVarVal( "Inet$EtherIPMask", inet_ntoa(v) );

            v.s_addr = ReadLongIPCMOS( DNSIPCMOS );
            SetVarVal( "Inet$Resolvers", inet_ntoa(v) );

            ReadStringCMOS( BOOTMOUNTCMOS, buf, PATHSZ );
            SetVarVal( "Inet$BootFile", buf );
            SetVarVal( "Inet$MountPath", buf );

            return 1;
        }
    }

    return 0;
}

#endif


int ifrconfig(s, ifname)
int s;
char *ifname;
{
        struct  ifreq ifr;

#ifdef USECMOS
        /* Try static IP information first.
         */
        if ( use_configured_info(s, ifname) == 0 )
        {
#endif
            write_tag_msg_nl("IFRSrchBS");
            strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
            if (socketioctl(s, SIOCGWHOIAMRB, (caddr_t)&ifr) < 0)
            {
                if (editconfig_check_keys(keycheck_BOTH_ALTS_AND_SHIFTS))
                    return (0);

                newline();
                write_tag_msg_nl("IFRNoBS");

                /* reset box */
                reboot(0,0);
                #ifndef ROM
                return 0;
                #endif
            }
#ifdef USECMOS
        }
#endif

        strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
        if (socketioctl(s, SIOCGIFADDR, (caddr_t)&ifr) < 0) {
            newline();
            write_tag_msg_nl("IFRNoRNA");
            return (0);
        }
        ipaddr.sin_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
	write_tag_msg("IFRMNAIs");
        printf(": %s\n", inet_ntoa(ipaddr.sin_addr));

        /* Try to set the default route if necessary. */
        if (ifrconfig_set_default_route(s) == 0)
            write_tag_msg_nl("IFRNDRt");

        /* Try to set the sub-net mask if necessary. */
        if (set_netmask(s, ifname) == 0)
            write_tag_msg_nl("IFRNDNM");

#ifdef GET_NETMASK_VIA_ICMP
        /* Gets netmask via ICMP (no longer required).
         */
	write_tag_msg_nl("IFRSrchNM");
        (void) socketioctl(s, SIOCGWHOIAMM, (caddr_t)&ifr);
        strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
        if (socketioctl(s, SIOCGIFNETMASK, (caddr_t)&ifr) < 0) {
            write_tag_msg_nl("IFRNoNM");
            return (0);
        }
        netmask.sin_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
	write_tag_msg("IFRNMIs");
        printf(": %x\n", ntohl(netmask.sin_addr.s_addr));
#endif

        return (1);
}
