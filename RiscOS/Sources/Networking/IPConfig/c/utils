/*
 * IPConfig (utils.c)
 *
 * Copyright (C) Acorn Computers Ltd. 1995-1997
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "utils.h"

static int messages_fd[4];
static int messages_custom[4];

/* This is set to 1 when we have opened the Messages file, 2 if we opened the Custom file too
 * This code will check the Custom messages file before the Messages file itself to allow
 * individual tokens to be overloaded.
 */
static int opened = 0;


_kernel_oserror *read_message (const char *token, const char **buffer, size_t *inoutlength)
{
        _kernel_oserror *e = 0;

	if (opened > 1) {
        	e = _swix(MessageTrans_Lookup, _INR(0,7)|_OUTR(2,3), messages_custom,
        		token, *buffer,	*inoutlength, 0, 0, 0, 0, buffer, inoutlength);
        }
        if (opened < 2 || e != NULL) {
                e = _swix(MessageTrans_Lookup, _INR(0,7)|_OUTR(2,3), messages_fd,
                	token, *buffer, *inoutlength, 0, 0, 0, 0, buffer, inoutlength);
        }

        return e;
}

#ifndef ROM
extern void *messages_file(void);

_kernel_oserror *utils_register_msgs(void)
{
	return _swix(ResourceFS_RegisterFiles, _IN(0), messages_file());
}

_kernel_oserror *utils_deregister_msgs(void)
{
	return _swix(ResourceFS_DeregisterFiles, _IN(0), messages_file());
}
#endif

/* ------------------------------------ raising errors ---------------------------------------- */

static _kernel_oserror *find_error (void)
{
	static _kernel_oserror global_error_block;
	return &global_error_block;
}

_kernel_oserror *make_error (int err_num, int num_args, ...)
{
   	/*
    	 * Generate a RISC OS error block.
    	 */

   	va_list	     	ap;
   	char		*s;
   	int		i=4;
   	_kernel_oserror *ptr = find_error(), *e = 0;
   	char		*sub[4]={0,0,0,0};

   	ptr->errnum = err_num + ERROR_BASE;
   	sprintf (ptr->errmess, "E%02x:Error %x", err_num&0xff, err_num);

   	num_args = (num_args>4)?4:num_args;

   	for (va_start (ap, num_args); num_args--; i++) {
      		s = va_arg (ap, char *);
      		sub[i] = (s && *s) ? s : NULL; /* copy (pointer to args)s into registers */
   	}
   	va_end(ap);

	if (opened > 1) {
	   	e = _swix(MessageTrans_ErrorLookup, _INR(0,7), ptr, messages_custom, 0, 0,
   			sub[0], sub[1], sub[2], sub[3]);
	}
   	if (opened < 2 || e->errnum != ptr->errnum) {
   		e = _swix(MessageTrans_ErrorLookup, _INR(0,7), ptr, messages_fd,
   			0, 0, sub[0], sub[1], sub[2], sub[3]);
        }
   	return e;
}


/* --------------------------------------- message file handling ------------------------------ */


_kernel_oserror *messages_file_open (const char *messages_filename)
{
        _kernel_oserror *e;
        void *mblock = opened ? messages_custom : messages_fd;

    	e = _swix(MessageTrans_OpenFile, _INR(0,2), mblock, messages_filename, 0);
    	if (e == NULL) {
                ++opened;
        }
        return e;
}


_kernel_oserror *messages_file_close (void)
{
        if (opened > 1) {
                (void) _swix(MessageTrans_CloseFile, _IN(0), messages_custom);
        }
        if (opened > 0) {
                (void) _swix(MessageTrans_CloseFile, _IN(0), messages_fd);
        }
        opened = 0;
        return NULL;
}

