/* listen.c -- handle our table of listening sockets */
#include <stdio.h>
#include "kernel.h"
#include "swis.h"
#include "strings.h"

#include "sys/types.h"
#include "services.h"

#define PROTOTYPES_INTERNAL
#include "listen.h"

#include "module.h"
#include "mast.h"
#include "atmsock.h"
#include "utils.h"
#include "nbit_mask.h"

int init_listen(void) /* set up listen table and system listens */
{
  struct listen *l;
  int n;
  int listen_addr = 0;
  int socket_handle;

  for(l = &listentab[0]; l < &listentab[LISTENTAB_SIZE]; l++)
    memset((char *)l, 0, sizeof(struct listen));

  for(n = LISTENTAB_SYSTEM_IP, l = &listentab[0]; (n>0) && (l < &listentab[LISTENTAB_SIZE]); l++, n--) {

    if((socket_handle = get_handle(handle_wspace))<0) return -1; /* failed to allocate socket handle */

     if(!do_vc) {
      if(sock_listen((unsigned int)socket_handle, (unsigned char *)&listen_addr, M_LLC)<0) {
#ifdef DEBUG
       printf("init_listen: called free_handle() & got %d\n", free_handle(handle_wspace, socket_handle));
#else
        free_handle(handle_wspace, socket_handle);
#endif
        return -1; /* LISTEN failed */
      }

      l->local_port = M_LLC;
      l->muxtype = LLC_MULTIPLEX;

     } else {

        if(sock_listen((unsigned int)socket_handle, (unsigned char *)&listen_addr, M_IP)<0) {
#ifdef DEBUG
       printf("init_listen: called free_handle() & got %d\n", free_handle(handle_wspace, socket_handle));
#else
        free_handle(handle_wspace, socket_handle);
#endif
          return -1; /* LISTEN failed */
        }

        l->local_port = M_IP;
        l->muxtype = VC_MULTIPLEX;
     }

     l->handle = (unsigned int)socket_handle;
     l->flags = L_SYSTEM | L_REANIMATE;
  }

  return 0;
}

struct listen *locate_listen(unsigned int handle) /* find a listentab entry based on a socket handle */
{
  struct listen *l;

  if(handle==0) return((struct listen *)NULL); /* never doing a listen on handle 0, so skip it */

  for(l = &listentab[0]; l < &listentab[LISTENTAB_SIZE]; l++)
    if(l->handle == handle) return l;

  return((struct listen *)NULL);
}


struct listen *locate_listen_port(unsigned int port) /* find a listentab entry based on a local port */
{
  struct listen *l;

  for(l = &listentab[0]; l < &listentab[LISTENTAB_SIZE]; l++)
    if(l->local_port == port) return l;

  return((struct listen *)NULL);
}




struct listen *add_listen(unsigned int port, unsigned int muxtype) /* set up a listen on a local port */
{
  struct listen *l;
  unsigned int listen_addr = 0;
  int socket_handle;

  for(l = &listentab[0]; l < &listentab[LISTENTAB_SIZE]; l++)
    if(l->handle == 0) {
      if((socket_handle=get_handle(handle_wspace))<0) {
#ifdef DEBUG
       printf("add_listen: get_handle() returned %d\n", socket_handle);
#endif
        return((struct listen *)NULL); /* failed to get socket handle */
      }

      if(sock_listen((unsigned int)socket_handle, (unsigned char *)&listen_addr, port)<0) {
#ifdef DEBUG
       printf("add_listen: called free_handle() & got %d\n", free_handle(handle_wspace, socket_handle));
#else
        free_handle(handle_wspace, socket_handle);
#endif
        return((struct listen *)NULL);
      }

      l->handle = (unsigned int)socket_handle;
      l->local_port = port;
      l->muxtype = muxtype;
      l->flags = 0;
      return(l);
    }

    return((struct listen *)NULL);
}

int reanimate_listen(struct listen *l) /* reanimate a system socket! */
{
  unsigned int listen_addr = 0;
  int socket_handle;

      if((socket_handle=get_handle(handle_wspace))<0) return -1; /* failed to allocate socket handle */
      if(sock_listen((unsigned int)socket_handle, (unsigned char *)&listen_addr, l->local_port)<0) {
#ifdef DEBUG
       printf("reanimate_listen: called free_handle() & got %d\n", free_handle(handle_wspace, socket_handle));
#else
        free_handle(handle_wspace, socket_handle);
#endif

        free_handle(handle_wspace, socket_handle);
        return -1;
      }
      l->handle = (unsigned int)socket_handle;

      return 0;
}






