/* various utility bits and pieces */

#include "swis.h"
#include "kernel.h"
#include "ctype.h"
#define PROTOTYPES_INTERNAL
#include "utils.h"
#include "types.h"


unsigned int MonotonicTime(void)
{
  _kernel_swi_regs r;

  _kernel_swi(OS_ReadMonotonicTime, &r, &r);
  return ((unsigned int)(r.r[0]));
}

unsigned int FileStat(char *s)
{
  _kernel_swi_regs r;

  r.r[0] = 17;
  r.r[1] = (int)s;

  _kernel_swi(OS_File, &r, &r);
  return((unsigned int)(r.r[4]));
}

void time_delay(const int timeout)
{
  int time_then;

  time_then = MonotonicTime();

  while((MonotonicTime() - time_then) < timeout);
  return;
}


int caseless_strcmp(char *a, char *b)
{
    int d;

    while ( *a || *b ) {
        d = toupper( *(a++) ) - toupper( *(b++) );
        if ( d )
            return d;
    }
    return 0;
}


u_long htonl(u_long x)
{
    return ( ntohl(x) );
}

u_long ntohl(u_long x)
{
    return( ((x & 0xff) << 24) | ((x & 0xff00) << 8) | ((x & 0xff0000) >> 8) | ((x & 0xff000000) >> 24) );
}

u_long inet_addr(register char *cp)
{
        u_long val, base, n;
        char c;
        u_long parts[4], *pp = parts;

again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*cp == '0')
                base = 8, cp++;
        if (*cp == 'x' || *cp == 'X')
                base = 16, cp++;
        while ((c = *cp)!=0) {
                if (isdigit(c)) {
                        val = (val * base) + c - '0';/* was ( +c - '0') */
                        cp++;
                        continue;
                }
                if (base == 16 && isxdigit(c)) {
                        val = (val << 4) + c + 10 - (islower(c) ? 'a' : 'A');
                        cp++;
                        continue;
                }
                break;
        }
        if (*cp == '.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                if (pp >= parts + 4)
                        return (-1);
                *pp++ = val, cp++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*cp && !isspace(*cp))
                return (-1);
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = pp - parts;
        switch (n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                return (-1);
        }
        val = htonl(val);
        return (val);
}


unsigned int chtoui(unsigned char *s) /* convert a SIX byte (not FOUR!) unsigned char MAST address */
{	     		     	      /* to an ATML packed decimal format address */
  unsigned int w;		      /* 00.00.a.b.c.d => 0xDDCCBBAA */
  s = s + 2; /* skip past initial 2 zero bytes */
  w = *s++;
  w |= (*s++ << 8);
  w |= (*s++ << 16);
  w |= (*s++ << 24);   /* ok, so it's gross. Sue me.  */
  return(w);
}


unsigned char *uitoch(unsigned int i) /* does the reverse - returned char * is only valid between calls */
{	      		       	      /* copy it if you need a safe version */
  static unsigned char s[6];

  s[0] = 0;
  s[1] = 0;
  s[2] = i & 0xff;
  s[3] = (i & 0xff00) >> 0x8;
  s[4] = (i & 0xff0000) >> 0x10;
  s[5] = (i & 0xff000000) >> 0x18;
  return(s);
}

unsigned int portword(unsigned int i) /* convert a Binary Packed Decimal port word to our */
{	     		       	     /* internal format */
   static unsigned int w;

   w = ((i & 0xff000000) >> 24) |
       ((i & 0x00ff0000) >> 8)  |
       ((i & 0x0000ff00) << 8)  |
       ((i & 0x000000ff) << 24);

   return(w);
}

unsigned int portpacked(unsigned int i) /* convert internal port number to Binary Packed Decimal  */
{	     			      /* as understood by the nic */

   static unsigned int w;

   w = ((i & 0x000000ff) << 24) |
       ((i & 0x00ff0000) << 8)  |
       ((i & 0x0000ff00) >> 8)  |
       ((i & 0x000000ff) >> 24);

   return(w);
}




char *ether_sprintf(register unsigned char *ap)
{
    register i;
    static char etherbuf[18];
    register char *cp = etherbuf;
    static char digits[] = "0123456789abcdef";

    for (i = 0; i < 6; i++) {
        *cp++ = digits[*ap >> 4];
        *cp++ = digits[*ap++ & 0xf];
        *cp++ = ':';
    }
    *--cp = 0;
    return (etherbuf);
}

int htons(int x)
{
    return ( ntohs(x) );
}

int ntohs(int x)
{
    return ( (x & 0xff) << 8 | (x & 0xff00) >> 8 );
}

int min(int a, int b)
{
    return (a < b ? a : b);
}






