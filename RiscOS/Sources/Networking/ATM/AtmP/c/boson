/* File:    boson.c
   Purpose: Talk to the Boson ASIC.  Must be C becuase our C++ implementation
            doesn't support volatile.
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-06-02: BAL
   Created.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include "kernel.h"
#include <stdio.h>
#include <string.h>
#include "swis.h"

/* Miscellaneous */
#include "DebugLib/DebugLib.h"

/* Local */
#include "boson.h"
#include "defs.h"
#include "header.h"
#include "message.h"
#include "module.h"
#include "mpeg.h"
#include "utils.h"




/* =============================================================================
 * Constants definitions
 */

#ifdef DEBUG_TRAIL
enum
{
    MESSAGE_TRAIL_SIZE = 2048
};
#endif

enum
{
    DiscardMsg_MESSAGE = 1,
    FLUSH_FIFO
};


/* BOSON SYNC phase defined constants */
#define SYNC0      0xf378cd09
#define SYNC1      0xda7b8217

#define TIMEOUT    500

/* BOSON BOOT phase defined commands */
#define BOOT_BOOT    0x426f6f74 /* literally, 'B', 'o', 'o', 't'  */
#define BOOT_ACK     0x41434b20 /* an ACK from NIC->HOST, not really a command, lit "ACK " */
#define BOOT_ADDR    0x41646472 /* lit. "Addr"  */
#define BOOT_GO      0x474f2020 /* lit. "GO  " */

/* Post image download ack constants  */
#define ROM_ACK      0x41544d4c



/* 32bit-mode raw addresses */
#define Boson_VersionAddr       ((volatile unsigned int *)(0x88800200 + (podule<<24)))
#define Boson_FromARMAddr       ((volatile unsigned int *)(0x88800240 + (podule<<24)))
#define Boson_ToARMAddr         ((volatile unsigned int *)(0x88800240 + (podule<<24)))
#define Boson_BlockFromARMAddr  ((volatile unsigned int *)(0x88800280 + (podule<<24)))
/*
#define Boson_BlockToARMAddr    (volatile unsigned int *)(0x88800280 + (podule<<24))
#define Boson_CommitFromARMAddr (volatile unsigned int *)(0x888002c0 + (podule<<24))
*/
#define Boson_CommitToARMAddr   ((volatile unsigned int *)(0x888002c0 + (podule<<24)))


/* 16bit-mode raw addresses */
#define Boson_MaskedStatusAddr  ((volatile unsigned int *)(0x88c00300 + (podule<<24)))
#define Boson_StatusAddr        ((volatile unsigned int *)(0x88c00340 + (podule<<24)))
#define Boson_StatusAddr        ((volatile unsigned int *)(0x88c00340 + (podule<<24)))
#define Boson_CommandAddr       ((volatile unsigned int *)(0x88c00340 + (podule<<24)))


/* Boson main IRQ flag */
/* defined by the EASI interface, not by the Panther card */
/* these define the address of the register (for OS_DeviceClaimVector)
   and also a macro to read it. NB: the IRQ bit in this register is not
   latched, and may be changing as it is read!!! Use Check_Boson_IRQ
   repeatedly until 2 reads are the same!
*/

#define Boson_IRQ       ((volatile unsigned int)(0x88400000 + (podule<<24)))
#define Check_Boson_IRQ (*((volatile unsigned int *)(0x88400000 + (podule<<24))) & 0x2)


#define BOSON_FIFO_SIZE 2048

/* BOSON status register bits */
enum
{
    Boson_Status_Tx384        = 0x0001,
    Boson_Status_Tx128        = 0x0002,
    Boson_Status_Tx16         = 0x0004,
    Boson_Status_RxBlock      = 0x0008,
    Boson_Status_NotEmpty     = 0x0010,
    Boson_Status_Alarm        = 0x0020,
    Boson_Status_Tx384Mask    = 0x0040,
    Boson_Status_Tx128Mask    = 0x0080,
    Boson_Status_Tx16Mask     = 0x0100,
    Boson_Status_RxBlockMask  = 0x0200,
    Boson_Status_NotEmptyMask = 0x0400,
    Boson_Status_AlarmMask    = 0x0800,
    Boson_Status_ReadTop16    = 0x1000,
    Boson_Status_WriteTop16   = 0x2000,
    Boson_Status_ToArmAlarm   = 0x4000
};


/* BOSON Command register bits */
enum
{
    Boson_Cmd_SetNotEmptyMask = 0x0410,
    Boson_Cmd_ClrNotEmptyMask = 0x0400,
    Boson_Cmd_SetRxBlockMask  = 0x0208,
    Boson_Cmd_ClrRxBlockMask  = 0x0200,
    Boson_Cmd_SetTX384Mask    = 0x0041,
    Boson_Cmd_ClrTX384Mask    = 0x0040,
    Boson_Cmd_SetTX128Mask    = 0x0082,
    Boson_Cmd_ClrTX128Mask    = 0x0080,
    Boson_Cmd_SetTX16Mask     = 0x0104,
    Boson_Cmd_ClrTX16Mask     = 0x0100,
    Boson_Cmd_ClrAll          = 0x0fc0  /* clear all interrupt masks */
};


/* BOSON Masked Status register bits */
enum
{
    Boson_MaskedStatus_NotEmpty = 0x0010
};




/* =============================================================================
 * Macro definitions
 */

/* BOSON read registers -- 32 bit mode for various FIFO regs */
#define r_Boson_Version          *Boson_VersionAddr
#define r_Boson_FromARM          *Boson_FromARMAddr
#define r_Boson_BlockFromARM     *Boson_BlockFromARMAddr
#define r_Boson_CommitFromARM    *Boson_CommitFromARMAddr

/* BOSON read registers -- 16 bit mode for various status regs */
#define r_Boson_MaskedStatus     *Boson_MaskedStatusAddr
#define r_Boson_Status           *Boson_StatusAddr

/* BOSON write registers - 32 bit mode for various FIFO regs */
#define w_Boson_ToARM(x)         *Boson_ToARMAddr       = (x)
#define w_Boson_BlockToARM(x)    *Boson_BlockToARMAddr  = (x)
#define w_Boson_CommitToARM(x)   *Boson_CommitToARMAddr = (x)

/* BOSON write registers -- 16 bit mode for various status/ctrl regs */
#define w_Boson_IRQMask(x)       *Boson_IRQMaskAddr     = ((x) & 0xffff)
#define w_Boson_Command(x)       *Boson_CommandAddr     = ((x) & 0xffff)
#define w_Boson_CommitToARM16(x) *Boson_CommitToARMAddr = ((x) & 0xffff)

/* some handy macros -- access the BOSON regs. in 16bit addressing mode */
#define Boson_RX_NotEmpty        (r_Boson_Status & Boson_Status_NotEmpty)
#define Boson_RX_Block           (r_Boson_Status & Boson_Status_RxBlock)
#define Boson_TX_384             (r_Boson_Status & Boson_Status_Tx384)
#define Boson_TX_128             (r_Boson_Status & Boson_Status_Tx128)
#define Boson_TX_16              (r_Boson_Status & Boson_Status_Tx16)




/* =============================================================================
 * Type definitions
 */

typedef struct
{
    NICMessage    msg;
    NICExtension  ext;
} message_trail;




/* =============================================================================
 * Global variable declarations
 */

int timeoutError = 0;

int irq_closes = 0;
int irq_closeds = 0;
int irq_errors = 0;
int irq_connects = 0;
int irq_connect_reqs = 0;
int irq_data_lengths = 0;
int irq_data_aborts = 0;
int irq_data_ends = 0;
int irq_datas = 0;
int irq_refusals = 0;
int irq_packets = 0;
int irq_rx_discards = 0;
int irq_rx_errors = 0;
int irq_con_req_errors = 0;
int irq_con_ack_errors = 0;
int irq_con_req_acks = 0;
int irq_con_refusals = 0;
int irq_connection_errors = 0;
int irq_bogus_pkts = 0;
int irq_pkt_hiwm = 0;
int irq_buffer_recovers = 0;
int irq_ip_pkts_dropped = 0;

int boson_rx_pkts = 0;
int boson_cmd_pkts = 0;
int boson_msg_pkts = 0;

unsigned char    irq_buffer[BOSON_FIFO_SIZE];

#ifdef DEBUG_TRAIL
static message_trail    msg_trail[MESSAGE_TRAIL_SIZE];
static message_trail *  msg_trail_next = msg_trail;
static unsigned int     msg_trail_num = 0;
static unsigned int     msg_trail_lock = 0;
#endif




/* =============================================================================
 * Function prototype declarations
 */

/* This function is the interface to the C++ code */
extern MessageHandlerRC  ServiceManager_DespatchMessage (NICMessage    msg,
                                                         NICExtension  ext);

#ifdef DEBUGLIB
static void  ddisplay_message_trail_entry (const message_trail *const  m);
#endif

/* Some assembler routines */
extern void asm_enable_podule_irqs (unsigned int);
extern void asm_disable_podule_irqs (unsigned int);
extern void asm_buffer_recover (unsigned int *);

extern void multi_status (unsigned int *,
                          unsigned int *,
                          unsigned int);



/* =============================================================================
 * Function definitions
 */

/* -----------------------------------------------------------------------------
   More complicated routines which do several reads (but use the registers
   directly so you don't get the speed hit of repeatedly calling the routines
   above.
 */

_kernel_oserror *  boson_irq_handler  (_kernel_swi_regs *  r,
                                       void *              pw)
{
    NICMessage        msg;
    NICExtension      ext;

    // Stop the card from generating interrupts
    w_Boson_Command (Boson_Cmd_ClrRxBlockMask);    // mask out the NotEmpty bit

    // Enable system interrupts
    _kernel_irqs_on ();

    M_unused (r);
    M_unused (pw);


    while (Boson_RX_Block)    /* IRQ triggered on RxBlock */
    {
        boson_rx_pkts++;

        msg.header = r_Boson_BlockFromARM; /* get msg header */

        if (msg.common.type == NIC_DataMessage)
        {
            if (msg.data.ext)
            {
                unsigned int  ext_attempts = 0;

                do
                {
                    /* read extension word */
                    ext.extension = r_Boson_CommitFromARM;
                    ++ext_attempts;
                }
                while (ext_attempts < 8 && ext.bits.reserved != 0);

                if (ext.bits.reserved != 0)
                {
                    continue; /* abort */
                }
            } /* endif data extend */
            else
            {
                ext.bits.size = msg.data.size;
            }

            irq_packets = msg.data.size;
            boson_msg_pkts++;
            if (msg.data.size > irq_pkt_hiwm)
            {
                irq_pkt_hiwm = msg.data.size;
            }
        }
        else
        {
            ext.bits.size = 0;
            boson_cmd_pkts++;
        }

        #ifdef DEBUG_TRAIL
        if (msg_trail_lock == 0)
        {
            msg_trail_next->msg = msg;
            if (msg.common.type == NIC_DataMessage && msg.data.ext)
            {
                msg_trail_next->ext = ext;
            }

            #ifdef DEBUGLIB
            ddisplay_message_trail_entry (msg_trail_next);
            #endif

            msg_trail_next++;
            msg_trail_num++;

            if (msg_trail_next >= msg_trail + MESSAGE_TRAIL_SIZE)
            {
                msg_trail_next = msg_trail;
            }
        }
        #endif

        /* Find out what service this handle is bound to (if it is even
         * bound at all.
         */
        switch (ServiceManager_DespatchMessage (msg, ext))
        {
            case HandledMsg:
                break;

            case DiscardMsg:
                /* asm_junk_msg(Boson_CommitFromARMAddr, packet_bytes); */
                ASM_GET_MSG ((unsigned int *) Boson_CommitFromARMAddr,
                             irq_buffer,
                             msg.data.size);
                break;

            case FlushFIFO:
                irq_bogus_pkts++;
                asm_buffer_recover ((unsigned int *) Boson_CommitFromARMAddr);
                irq_buffer_recovers++;
                break;

            default:
                break;
        }
    } /* endof FIFO RX Block loop */

    /* does MPEG system need feeding? */
    mpeg_check_feed ();

    #ifdef FIFO_RECOVER
    /* 1999-02-03: BAL
     * This strikes me as a dodgy thing to do - what guarantee is
     * there that valid new data will not arrive in the FIFO between
     * the RXBlock check at the top of the above while loop and the
     * RXNotEmpty check here?
     */
    if (Boson_RX_NotEmpty)
    {
        asm_buffer_recover (Boson_CommitFromARMAddr);
        irq_buffer_recovers++;
    }
    #endif

    // Allow the NIC to generate interrupts again
    w_Boson_Command (Boson_Cmd_SetRxBlockMask);

    return NULL;

} /* end of irq handler */




/* -----------------------------------------------------------------------------
   boson_block_write

   write word to BlockToARM register
   does FIFO freespace check and h/w timeout
 */

void boson_block_write (unsigned int  w)
{
    static int freeW = 0;
    unsigned int tInit;

    if (timeoutError)
    {
        return;
    }

    tInit = MonotonicTime();

    while (freeW == 0)
    {
        if (Boson_TX_384)
        {
            freeW = 384;
        }
        else if (Boson_TX_128)
        {
            freeW = 128;
        }
        else if (Boson_TX_16)
        {
            freeW = 16;
        }

        else if (MonotonicTime() - tInit > TIMEOUT)
        {
            dprintf(("", "BlockWrite: Timeout error - no free words in toARM fifo.\n"));
            timeoutError++;
            return;
        }
    }
    w_Boson_BlockToARM (w);
    freeW--;
}




/* -----------------------------------------------------------------------------
   boson_block_read

   read word from BlockFromARM register
   does polling and timeout
 */
unsigned int boson_block_read (void)
{
    unsigned int w;
    unsigned int tInit;

    if (timeoutError)
    {
        return 0;
    }

    tInit = MonotonicTime();

    while (!Boson_RX_NotEmpty)
    {
        if (MonotonicTime() - tInit > TIMEOUT)
        {
            dprintf (("", "Timeout error on block read op\n"));
            timeoutError++;
            return 0;
        }
    }

    w = r_Boson_BlockFromARM;
    return w;
}




/* Number of bytes free in FIFO */
int  boson_fifo_space (void)
{
    for (;;)
    {
        if (Boson_TX_384)
        {
            return (384 * 4);
        }

        if (Boson_TX_128)
        {
            return (128 * 4);
        }

        if (Boson_TX_16)
        {
            return (16 * 4);
        }
    }
}




/* -----------------------------------------------------------------------------
   boson_tx_data

   Send a packet of data to the Virata NIC.

   This does not behave as specified in the "Virata Link Hardware Interface"
   document due to a suspected bug in the Virata code.  The Virata
   documentation could also be clearer as to what messages to use in what
   circumstances.

   Firstly, we do not make use of the AS_DATA command at all.  This is for
   streaming data, where you don't know how much data is in the packet when
   you start sending it.  Protocol modules always give us complete packets
   via the DCI-4 Transmit interface.

   We always use AS_DATA_END, which is used either to transfer the final
   data for a streaming operation when you finally do know the amount of data
   in the packet (so this is not applicable to us), or if you know that you
   have the whole packet right from the outset (as we do).

   The largest amount of data that can be transferred across the Virata Link
   interface at one time is 1536 bytes (including message headers), so if
   we have a large packet then we need to split it into sub-blocks as
   described in the Virata Link Hardware Interface document and send an
   AS_DATA_END message for each block.

   It is in doing this sub-block fragmentation that we run into problems...
   The Link Hardware Interface does not impose any requirements on the data
   size for AS_DATA_END commands, whereas it states that AS_DATA commands
   may only send data blocks of 48 byte multiples (even though the Viarata
   firmware clearly does not obey this when sending data to us using AS_DATA).

   When we fragment data into sub-blocks, the largest amount that can be sent
   in the first sub-block is 1528 bytes.  Everything works fine for packets
   with a total size of up to 1624 bytes inclusive (note that this is 96 bytes
   (2 * 48) beyond the first sub-block of 1528 bytes.  At this point, and at
   every 48 byte interval thereafter, there is an 8 range of total packet size
   that the card appears to not transmit (e.g. 1625 <= packet size <= 1632 does
   not work, neither does 1673 <= packet size <= 1680 etc.).

   A work-around was found after some experimentation.  As much data as possible
   (still up to 1528 bytes) is sent in the first sub-block.  Any middle blocks
   only send 48 byte multiples of data.  The last block sends whatever's left
   (always <= 48 bytes).

   Another proviso for this work-around is that it only works if we wait
   for 1536 bytes to become free in the Boson FIFO - if we try to use smaller
   blocks then things break again!  This was only found once the debugging
   code had been removed, when the time between attempts to write to the FIFO
   shortened...
 */

int  boson_tx_data (const int             handle,
                    const unsigned int *  data,
                    int                   data_bytes)
{
    int         fifo_bytes = 0;
    NICMessage  msg;

    dprintf (("", "%d\n", data_bytes));

    msg.header       = 0;
    msg.data.handle  = handle;
    msg.data.type    = NIC_DataMessage;
    msg.data.command = AS_DATA_END;
    msg.data.first   = 1;

    fifo_bytes = boson_fifo_space ();
    if (data_bytes > fifo_bytes - sizeof (NICMessage))
    {
        int           block_bytes;
        NICExtension  ext;

        ext.extension = 0;

        // First block can do maximum of (fifo_space - 8) words (accounting for
        // message header and extension word).
        block_bytes = fifo_bytes - (sizeof (NICMessage) +
                                    sizeof (NICExtension));

        msg.data.ext     = 1;
        msg.data.size    = block_bytes;
        ext.bits.size    = data_bytes;

        dprintf (("", "%d ", block_bytes));

        // Number of bytes that will remain after this block
        data_bytes -= block_bytes;

        // Write message
        w_Boson_CommitToARM (msg.header);

        // Write extenstion word
        w_Boson_CommitToARM (ext.extension);

        // Write all but last word of block
        while (block_bytes -= 4, block_bytes > 0)
        {
            w_Boson_CommitToARM (*data++);
        }

        // Write last word of packet and increment block counter
        w_Boson_BlockToARM (*data++);

        msg.data.first   = 0;
        msg.data.ext     = 0;

        fifo_bytes = boson_fifo_space ();

        while (data_bytes > fifo_bytes - sizeof (NICMessage))
        {
            // Middle blocks can do maximum of (fifo_space - 4) bytes
            // (accounting for message header), and must be multiples of 48
            // bytes.
            block_bytes  = fifo_bytes - sizeof (NICMessage);
            msg.data.size = block_bytes;

            dprintf (("", "%d ", block_bytes));

            // Number of bytes that will remain after this block
            data_bytes -= block_bytes;

            // Write message
            w_Boson_CommitToARM (msg.header);

            // Write all but last word of packet
            while (block_bytes -= 4, block_bytes > 0)
            {
                w_Boson_CommitToARM (*data++);
            }

            // Write last word of block and increment block counter */
            w_Boson_BlockToARM (*data++);

            fifo_bytes = boson_fifo_space ();
        }
    }

    // Either sending all data in one go, or last block of multi-block message.
    // If the latter then data size is always <= 48 bytes.
    msg.data.last    = 1;
    msg.data.size    = data_bytes;

    dprintf (("", "%d\n\n", data_bytes));

    // Write message
    w_Boson_CommitToARM (msg.header);

    // Write all but last '<= 4 bytes' of block
    while (data_bytes -= 4, data_bytes > 0)
    {
        w_Boson_CommitToARM (*data++);
    }

    // Write last few bytes of packet and increment block counter. May not
    // actually be a whole word though, but this shouldn't matter - the NIC
    // should ignore any junk bytes at the end if we've got our byte count
    // correct.
    w_Boson_BlockToARM (*data);

    return 0;
}




#ifdef DEBUG_TRAIL

#ifdef DEBUGLIB

void  ddisplay_message_trail_entry (const message_trail *const  m)
{
    dprintf (("", "0x%08x [%s cmd:%02d, hndl:%02d",
              m->msg.header,
              m->msg.common.type == NIC_CommandMessage ? "CMD, " : "DATA,",
              m->msg.common.command,
              m->msg.common.handle));

    if (m->msg.common.type == NIC_DataMessage)
    {
        dprintf (("", ", E: %s, L: %s, F: %s, bytes: %d]\n",
                  m->msg.data.ext   ? "Y" : "N",
                  m->msg.data.last  ? "Y" : "N",
                  m->msg.data.first ? "Y" : "N",
                  m->msg.data.size));
    }
    else
    {
        dprintf (("", "]\n"));
    }

    if (m->msg.data.ext)
    {
        dprintf (("", "0x%08x [EXT,  bytes: %d]\n",
                  m->ext.extension,
                  m->ext.bits.size));
    }
}

#endif

static void  display_message_trail_entry (const message_trail *const  m)
{
    printf ("0x%08x [%s cmd:%02d, hndl:%02d",
            m->msg.header,
            m->msg.common.type == NIC_CommandMessage ? "CMD, " : "DATA,",
            m->msg.common.command,
            m->msg.common.handle);

    if (m->msg.common.type == NIC_DataMessage)
    {
        printf (", E: %s, L: %s, F: %s, bytes: %d]\n",
                m->msg.data.ext   ? "Y" : "N",
                m->msg.data.last  ? "Y" : "N",
                m->msg.data.first ? "Y" : "N",
                m->msg.data.size);
    }
    else
    {
        printf ("]\n");
    }

    if (m->msg.data.ext)
    {
        printf ("0x%08x [EXT,  bytes: %d]\n",
                m->ext.extension,
                m->ext.bits.size);
    }
}



_kernel_oserror *  boson_display_trail (int  argc, char *  argv[])
{
    message_trail *  m;


    M_unused (argc);
    M_unused (argv);

    /* Don't want to add entries to the trail while we're displaying it or
     * our loops could go wrong (msg_trail_next could change under our feet).
     */
    msg_trail_lock = 1;

    printf ("BOSON MESSAGE TRAIL\n"
            "Displaying %d messages of %d received\n",
            msg_trail_num > MESSAGE_TRAIL_SIZE ? MESSAGE_TRAIL_SIZE :
                                                 msg_trail_num,
            msg_trail_num);

    /* If > MESSAGE_TRAIL_SIZE messages have been received then the *start* of
     * the trail will most likely not be at the start of the trail array.
     */
    if (msg_trail_num > MESSAGE_TRAIL_SIZE)
    {
        for (m = msg_trail_next;
             m < msg_trail + MESSAGE_TRAIL_SIZE;
             m++)
        {
            display_message_trail_entry (m);
        }
    }

    for (m = msg_trail; m < msg_trail_next; m++)
    {
        display_message_trail_entry (m);
    }

    msg_trail_lock = 0;

    return NULL;
}

#else

_kernel_oserror *  boson_display_trail (int  argc, char *  argv[])
{
    M_unused (argc);
    M_unused (argv);

    printf ("BOSON MESSAGE TRAIL disabled in this build\n");

    return NULL;
}

#endif





_kernel_oserror *  boson_display_status (int  argc, char *  argv[])
{
    int           i;
    unsigned int  status[256];

    M_unused (argc);
    M_unused (argv);

    multi_status ((unsigned int *) Boson_StatusAddr, status, M_array_size (status));
    for (i = 0; i < M_array_size (status); i++)
    {
        printf ("%08x\n", status[i]);
    }

    return NULL;
}




_kernel_oserror *  boson_display_info (int argc, char *  argv[])
{
    int w = 0;

    M_unused (argc);
    M_unused (argv);

    w = boson_fifo_space() / (sizeof (unsigned int));

    printf ("There are %d words free in the TX FIFO\n", w);

    printf ("There are %spending words in the RX FIFO\n",
            Boson_RX_NotEmpty ? "" : "no ");

    printf ("There are %spending blocks in the RX FIFO\n",
            Boson_RX_Block ? "" : "no ");

    printf ("Attempted %d Boson FIFO recovers.\n",
            irq_buffer_recovers);

    if (!Boson_RX_Block && Boson_RX_NotEmpty)
    {
        printf ("\nThe Boson FIFO is in an inconsistent state.\n");
    }
    else
    {
        printf ("\nThe Boson FIFO is in a valid state.\n");
    }

    return NULL;
}




_kernel_oserror *  boson_claim_interrupts (void)
{
    _kernel_oserror *  e;

    e = _swix (OS_ClaimDeviceVector,
               _INR (0, 4),

               13,    // expansion card device number
               boson_irq_entry,
               module_wsp,
               Boson_IRQ,
               0x2);    // 0x2 bit 1 is interrupt request
    if (!e)
    {
        asm_enable_podule_irqs (podule);
    }

    return e;
}




_kernel_oserror *  boson_release_interrupts (void)
{
    asm_disable_podule_irqs (podule);

    return _swix (OS_ReleaseDeviceVector,
                  _INR (0, 4),

                  13,    // expansion card device number
                  boson_irq_entry,
                  module_wsp,
                  Boson_IRQ,
                  0x2);    // 0x2 bit 1 is interrupt request
}




void  boson_enable_interrupts (void)
{
    // use the command register to mask in the NotEmpty bit IRQ thus generated
    // when NIC has data available
    w_Boson_Command (Boson_Cmd_SetRxBlockMask);
}




void  boson_disable_interrupts (void)
{
    w_Boson_Command (Boson_Cmd_ClrRxBlockMask);    // mask out the NotEmpty bit
}




void  boson_disable_all_interrupts (void)
{
    w_Boson_Command (Boson_Cmd_ClrAll);    // mask out all NIC interrupts
}
