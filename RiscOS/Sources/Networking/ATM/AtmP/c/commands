/*	COMMANDS.C

Project : ATML ATM25 card driver

Purpose: RiscOS module command handlers.


History:

Date      Who     Description of change
===========================================
20/1/97    CP      Picked up existing code, added header.

	 	  Replaced all occurrences of N_BS_BUFFERS with
		  number_of_bs_buffersG

		  Added call to bswait_init after resizing buffers

29/1/97   CP      Added in a header to each bs_buffer structure.  No-one's
	 	  quite sure what it is, but it's length is defined in
		  buffers.h (around 20 bytes)

30/4/98   CP      Changed arguments for various functions to const inorder to
                  protect incoming data/fit with prototypes defined in cmhg.h

***************************************************************************/
/* commands.c */
#include <stdio.h>
#include <assert.h>
#include "kernel.h"
#include "swis.h"
#include "module.h"
#include "types.h"
#include "mast.h"
#include "headers.h"
#include "utils.h"
#include "panther.h"
#include "atmswis.h"
#include "services.h"
#include "listen.h"
#include "boson.h"
#include "buffers.h"
#include "sockcmds.h"
#include "ctype.h"
#include "resources.h"
#include "macros.h"
#include "atmio.h"
#include "pvc.h"
#include "ipconv.h"
#include "nbit_mask.h"

/* 20/1/97:CP:globals needed for rest of code.  Should expand to a constant! */
/* size of a FULL bs_buffer (including header and payload) */
unsigned int bs_buffer_sizeG = sizeof(struct bs_buffer) - sizeof(int) + DEFAULT_BS_BUFFER_PAYLOAD + BS_DATA_HEADER;

/* number of bs_buffers available - ie. however many full bs_buffers fit into the memory pool
   Got to initialise it like this since it needs to be a constant.  Messy.  */
unsigned int number_of_bs_buffersG = DEFAULT_MEMORY_POOL / (sizeof(struct bs_buffer) - sizeof(int) + DEFAULT_BS_BUFFER_PAYLOAD + BS_DATA_HEADER);

/** 20/1/97:CP:end of added code **/



/******* atm_changebufferpool **********************************************

Purpose: Change the size of the bs_buffer chain payload.  This will trash the
	 current set of buffers and recreate the new ones using
	 init_bs_buffers().

Inputs:  char * arguments (NULL => display current values)
		-b buffer payload size
		-m memory pool size

Outputs: none

***************************************************************************/

void atm_changebufferpool(const char *args)
{
/* start off with the defaults */
  static unsigned int buffer_payload = DEFAULT_BS_BUFFER_PAYLOAD;
  static unsigned int memorypool = DEFAULT_MEMORY_POOL;

  char *s; /* temporary ptr */
  int newvalue; /* temporary storage */


  /* search for first non-character, and mark this as end of string */
  s = (char *)args;

  while(!iscntrl(*s))
  {
    s++;
  }
  *s = 0;

  s = strtok((char *)args, "-"); /* find 1st token */

  if(s == NULL)
  {
    /* no tokens, so print current values */
    printf("MPEG Buffer Pool details:\n");
    printf("\tBuffer payload %u bytes (overall size of a buffer %u bytes)\n", buffer_payload, bs_buffer_sizeG);
    printf("\tTotal memory available for MPEG buffers %u bytes\n", memorypool);
    printf("\tTotal number of buffers available %u\n", number_of_bs_buffersG);
  }

  else
  {
    do /* while (s != NULL) */
    {
      if(strncmp(s, "b ", 2) == 0)
      {
        /* change the buffer payload */
	newvalue = atoi(&s[2]);

	if(newvalue == 0) /* validate value */
	{
	  printf("changebufs error: Cannot set the buffer payload to value given\n");
	}

	else
	{
	  buffer_payload = newvalue;
	  printf("changebufs: changed value of buffer payload to %u bytes\n", buffer_payload);
	}
      }

      else
      {
         if(strncmp(s, "m ", 2) == 0)
         {
           /* change the memory pool size */
            newvalue = atoi(&s[2]);

            if(newvalue == 0) /* validate value */
            {
              printf("changebufs error: Cannot set the buffer memory pool to value given\n");
            }

            else
            {
              memorypool = newvalue;
              printf("changebufs: changed value of buffer memory pool to %u bytes\n", memorypool);
            }
         }

         else
         {
           /* not recognised, print help stuff */
           printf("changebufs syntax error\n");
         }
      }

      s = strtok(NULL, "-"); /* find next token */

    } while (s != NULL);

    /*
       work out the size of a bs_buffer with given payload, then find out how
       many whole bs_buffers fit into the memory pool, then shrink the memory
       pool to get rid of any bytes due to fractions
    */
    bs_buffer_sizeG = sizeof(struct bs_buffer) - sizeof(int) + buffer_payload + BS_DATA_HEADER;
    number_of_bs_buffersG = memorypool / bs_buffer_sizeG;

    memorypool = bs_buffer_sizeG * number_of_bs_buffersG; /* got minimal memory now! */

    init_bs_buffers(memorypool);
    bswait_init();

  } /* endif(s == NULL) */
}


void atm_info(void)
{
/*   unsigned int test, portnum, portpak; */
/*   unsigned char *src; */
/*     test = chtoui(macadr); */
/*     src = uitoch(test); */
/*     portpak = portpacked(42); */
/*     portnum = portword(portpak); */

    printf("\nMAC addr    : %2x.%2x.%2x.%2x.%2x.%2x\n", macadr[0], macadr[1], macadr[2], macadr[3], macadr[4], macadr[5]);
    printf("MAST address: %d.%d.%d.%d\n", macadr[2], macadr[3], macadr[4], macadr[5]);

    if(!do_vc) printf("IP encapsulation: LLC_SNAP\n\n");
    else printf("IP encapsulation: VC\n\n");


/*     printf("chtoui test: 0x%x\n", test); */
/*     printf("uitoch test: %d.%d.%d.%d.%d.%d\n", src[0], src[1], src[2], src[3], src[4], src[5]); */
/*     printf("portpacked test on '42': 0x%x\n", portpak); */
/*     printf("portword test: 0x%x\n\n", portnum); */
    printf("MAST unused circuit check interval: ");
    if(ticker_period) printf("%d cS  done %d checks\n", ticker_period, ticker_tally);
    else printf("Off\n");
    printf("IP service handle: %d  ECHO service handle: %d MPEG service handle:%d\n", ip_listen, ip_echo, mpeg_listen);
    printf("Free socket handles: %d Busy socket handles: %d\n\n",
    		 enumerate_free_handles(handle_wspace), enumerate_busy_handles(handle_wspace));

    printf("IP frames   --> rx: %d (discards: %d, errors: %d, pkts dropped: %d)   tx: %d\n", ip_rx, irq_rx_discards, irq_rx_errors,
    	       irq_ip_pkts_dropped, ip_tx);
    printf("MPEG frames --> rx: %d (discards: %d + %d + %d= %d)   tx: %d\n\n", mpeg_rx, mpeg_discards1,
    		 mpeg_discards2, mpeg_discards3, (mpeg_discards1+mpeg_discards2+mpeg_discards3), mpeg_tx);
    printf("ARP: requests: %d (local: %d  discard: %d  bcast: %d)\n\n", arp_count, local_arp_count, discard_arp_count, bcast_arp_count);
    printf("Callbacks: %d (startups: %d echo_acks: %d teardowns: %d arps: %d)\n", callbs, callb_startups,
    		       	  	     		      		    	  callb_echos, callb_teardowns, callb_arps);
    printf("\nIRQ packets: %d (Cmd: %d, Msg: %d)\n\n", boson_rx_pkts, boson_cmd_pkts, boson_msg_pkts);

    printf("CloseREQs: %d CloseACKs: %d Errors: %d\nConnectACKs: %d (refusals: %d, error: %d)\nConnectREQs: %d (error: %d, refused: %d acks: %d)\nData: %d Dataend: %d \nMAST errors: %d  Bogus packets: %d\n",
    		irq_closes, irq_closeds, irq_errors, irq_connects, irq_refusals, irq_con_ack_errors,
    		irq_connect_reqs, irq_con_req_errors, irq_con_refusals, irq_con_req_acks, irq_datas, irq_data_ends, irq_mast_errors, irq_bogus_pkts);
    printf("IRQ word: %d Packet HIWM: %d\n", irq_packets, irq_pkt_hiwm);
    printf("\nATM Connections: %d     ATM Listens: %d\n", atm_connections, atm_listens);
}

void atm_mast_show(void)
{
  struct mast *m;
  unsigned char port_string[32];

   printf("MAST connection table:\n");
   for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)

#ifdef LIMIT_TABLES
     if(m->m_port != M_FREE) {
#else
     if(1) {
#endif
            ipuitos(m->m_port, port_string,'.');
            printf("    %s: %d.%d.%d.%d, port: %s  handle: %u",
                    (m->m_status & M_PERMANENT) ? "PVC" : "SVC",
                    m->m_macadr[2], m->m_macadr[3],
                    m->m_macadr[4], m->m_macadr[5], port_string,
                    m->m_socket_handle);

            if(m->m_status != 0) {
              printf("     [ ");
              if(m->m_status & M_SWITCHED) printf("M_SWITCHED ");
              if(m->m_status & M_PERMANENT) printf("M_PERMANENT ");
              if(m->m_status & M_USED) printf("M_USED ");
              if(m->m_status & M_PENDING) printf("M_PENDING ");
              if(m->m_status & M_CONNECT) printf("M_CONNECT ");
              if(m->m_status & M_LISTEN) printf("M_LISTEN ");
              if(m->m_status & M_PURGE) printf("M_PURGE ");
              printf(" ]");
            }

            if (m->m_muxtype)
                printf(", muxtype: %s", m->m_muxtype == LLC_MULTIPLEX ? "LLC" : "VC");
            else printf(", muxtype: <uninitialised>");
            if ((m->m_status & M_PERMANENT) == 0) {
                if(m->m_originator) printf(", Party: ORIGINATOR (local port: %s)",
                		    (ipuitos(m->m_local_port, port_string, '.'), port_string));
                else printf(", Party: CALLEE (local port: %s)",
                     	       	    (ipuitos(m->m_local_port, port_string, '.'), port_string));
            }
            else {
                printf(", VCN: %u (emulating port: %s)", m->m_pvc_vcn,
                	       	    (ipuitos(m->m_port, port_string, '.'), port_string));
            }
            printf("\n");
     }
}

void atm_boson(void)
{
  int w = 0;
  if(Boson_TX_384) w = 384;
  else if(Boson_TX_128) w = 128;
  else if(Boson_TX_16) w = 16;

  printf("There are %d words free in the TX FIFO\n", w);
  printf("There are %spending words in the RX FIFO\n", Boson_RX_NotEmpty?"":"no ");
  printf("There are %spending blocks in the RX FIFO\n", Boson_RX_Block?"":"no ");
  printf("Attempted %d Boson FIFO recovers.\n", irq_buffer_recovers);
  if((!Boson_RX_Block) && Boson_RX_NotEmpty) printf("\nThe Boson FIFO is in a really bad way. Try rebooting.\n");
  else printf("\nThe Boson FIFO looks pretty healthy to me.\n");
}

void atm_pibs(void)
{
  struct dci4pi *p;

  for(p = pibs; p; p=p->pi_next)
    printf("Unit: %d  Frametype: 0x%x Framelevel: 0x%x Addr. level: 0x%x Error level: 0x%x Handle: 0x%8x Entry: 0x%8x\n",
            p->pi_unit, p->pi_ftype, p->pi_flevel, p->pi_alevel, p->pi_elevel, p->pi_handle,
            (unsigned int)p->pi_handler);
}

void atm_trail(void)
{
  unsigned int *n = boson_trail;
  unsigned int m, e;

  printf("BOSON COMMAND BLOCK TRAIL(%d blocks)\n", boson_num);
  while(n!=boson_next) {
    m = *n++;
    e = *n++;
    printf("0x%x [cmd:%d  hndl:%d  DATA: %s", m, (m & DATA_CMD)>>DATA_CMD_SHIFT, (m & DATA_HANDLE), (m & CMD_MESSAGE)?"No":"Yes");
    if(!(m & CMD_MESSAGE)) printf("---  E: %s L: %s F: %s bytes: %d ]", (m & DATA_EXTEND)?"Y":"N", (m & DATA_LAST)?"Y":"N",
    	      		   	     (m & DATA_FIRST)?"Y":"N", (m >> 21) & 0x7ff);
    else printf(" ]");

    if(e!=0x0) printf("  Ext: 0x%x [%d bytes]\n", e, (e >> 16) & 0xffff);
    else printf("\n");
  }


}

void atm_cci(const char *s)
{
  int n;

  n = atoi(s);

  if((n<0) || (n>300)) printf("Circuit check interval must be between 0(off) and 300 seconds.\n");
  else {
    if(ticker_period) disable_ticker_handler(); /* if the ticker handler is running, kill it */
    ticker_period = 100 * n; /* set new ticker interval */
    if(n) enable_ticker_handler(); /* if new interval <>0, re-enable ticker handler */
  }
  return;
}

void atm_listen(void)
{
  struct listen *l;
  unsigned char listen_port[32];

  printf("ATM25 Listening sockets:\n");
  for(l = &listentab[0]; l < &listentab[LISTENTAB_SIZE]; l++) {

#ifdef LIMIT_TABLES
    if(l->handle) {
#else
    if(1) {
#endif
      ipuitos(l->local_port, listen_port, '.');
      printf("Handle: %d  Local port: %s Muxtype: %s", l->handle, listen_port, (l->muxtype==LLC_MULTIPLEX)?"LLC":"VC");
      if(l->flags!=0) {
        printf(" [ ");
        if(l->flags & L_SYSTEM) printf("L_SYSTEM ");
        if(l->flags & L_REANIMATE) printf("L_REANIMATE ");
        printf(" ] ");
      }
      printf("\n");
    }
  }
}

void atm_status(void)
{
  unsigned int loop;
  multi_status(BosonStatusAddr, status_buffer, 256);

  for(loop=0; loop<256; loop++) printf("--> 0x%x\n", status_buffer[loop]);
}

void atm_buffers(void)
{
  unsigned int nbufs=0, ebufs=0;
  struct bs_buffer *b;

  printf("ATM25 MPEG Buffers:\n");

printf("bs_empty_q = %x\n", (int)bs_empty_q);

  for(b = bs_empty_q; b; b = b->bs_next)
  {
  printf("b = %x\t", (int)b);
  printf("b->bs_next = %x\n", (int)b->bs_next);
     nbufs++;
  }

  for(b = bs_full_q; b; b = b->bs_next)
  {
    ebufs++;
  }

  printf("Total buffers: %d   Available buffers: %d Full buffers: %d\n", number_of_bs_buffersG, nbufs, ebufs);
  printf("Buffers returned: %d  Buffers sent: %d\n", bs_received, bs_sent);
  printf("Buffers used: %d Hiwatermark: %d  Fails: %d\n", bufs_used, bufs_hiwat, wasempty);
  printf("wait_supply state: %d  wait_consume_state: %d\n", bsw.w_supply, bsw.w_consume);
  printf("Full  buffer head: 0x%x   tail: 0x%x\n", (unsigned int)bs_full_q, (unsigned int)bs_fullp);
  printf("Empty buffer head: 0x%x   tail: 0x%x\n", (unsigned int)bs_empty_q, (unsigned int)bs_emptyp);
}


void atm_pvc(char *s)
{
  char *dst_s, *port_s, *vcn_s, *eh_s;
  unsigned int vcn, port;

  eh_s = s;
  dst_s = s;
  while(!isspace(*s)) s++; /* -> first w/s char */
  *s++ = 0; /* terminate */
  while(isspace(*s)) s++; /* -> first non-w/s char */
  port_s = s;
  while(!isspace(*s)) s++; /* -> first w/s char */
  *s++ = 0; /* terminate */
  while(isspace(*s)) s++; /* -> first non-w/s char */
  vcn_s = s;
  while(!iscntrl(*s)) s++; /* -> first non-alphanumeric */
  *s = 0;
  // printf("ARGS--> %s\n", eh_s);

  port = atoi(port_s);
  vcn = atoi(vcn_s);
  pvc_create((unsigned char *)dst_s, port, vcn);
}


void atm_pvcdelete(char *s)
{
  char *dst_s, *port_s, *vcn_s, *eh_s;
  unsigned int port, vcn;

  eh_s = s;
  dst_s = s;
  while(!isspace(*s)) s++; /* -> first w/s char */
  *s++ = 0; /* terminate */
  while(isspace(*s)) s++; /* -> first non-w/s char */
  port_s = s;
  while(!isspace(*s)) s++; /* -> first w/s char */
  *s++ = 0; /* terminate */
  while(isspace(*s)) s++; /* -> first non-w/s char */
  vcn_s = s;
  while(!iscntrl(*s)) s++; /* -> first non-alphanumeric */
  *s = 0;
  // printf("ARGS--> %s\n", eh_s);

  port = atoi(port_s);
  vcn = atoi(vcn_s);

  // printf("STRINGS--> Host: %s Port: %s VCN: %s\n", dst_s, port_s, vcn_s);
  pvc_delete((unsigned char *)dst_s, port, vcn);

}

void atm_mast_data(void)
{
  struct mast *m;
  unsigned char port_string[32];

   printf("MAST connection data stats:\n");
   for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)

#ifdef LIMIT_TABLES
     if(m->m_port != M_FREE) {
#else
     if(1) {
#endif
            ipuitos(m->m_port, port_string,'.');
            printf("    %s: %d.%d.%d.%d, port: %s  handle: %u",
                    (m->m_status & M_PERMANENT) ? "PVC" : "SVC",
                    m->m_macadr[2], m->m_macadr[3],
                    m->m_macadr[4], m->m_macadr[5], port_string,
                    m->m_socket_handle);

	    printf("  received by driver: %d lost by stack: %d (%d%% loss)\n",
	    		     m->m_datacount, m->m_datalost, m->m_datacount?(100*m->m_datalost)/m->m_datacount:0);
     }

}



