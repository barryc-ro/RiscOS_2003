
/* ******************************************************************************** */
/* Various low level read and write calls to talk to the ATM25 podule's registers   */
/* Modified quite extensively to accomodate the EASI bus address space, not ISA	    */
/* ******************************************************************************** */
#include "kernel.h"
#include "swis.h"

#include "DebugLib/debuglib.h"

#include "headers.h"
#include "module.h"
#include "services.h"
#define PROTOTYPES_INTERNAL
#include "atmio.h"
#include "utils.h"


/* ******************************** */
/* write to various BOSON registers */
/* ******************************** */

unsigned int CommitRead(void) /* read word from CommitFromARM register */
{      		    		     /* polls and times out */
  unsigned int w;
  unsigned int tInit;

  if(timeoutError) return -1;

  tInit=MonotonicTime();

  while(!Boson_RX_NotEmpty)
    if(MonotonicTime() -tInit > TIMEOUT) {
/*       QUIET printf("\nTimeout error on commit read op\n"); */
      timeoutError++;
      return -1;
    }

  w = r_Boson_CommitFromARM;
  return w;
}

void BlockWrite(int w)   /* write word to BlockToARM register  */
{      	    		   	/* does FIFO freespace check and h/w timeout */
  static int freeW = 0;
  unsigned int tInit;

  if(timeoutError) return;

  tInit=MonotonicTime();

  while(freeW == 0) {
    if(Boson_TX_384) freeW=384;
    else if(Boson_TX_128) freeW=128;
    else if(Boson_TX_16) freeW=16;

    else if(MonotonicTime() - tInit > TIMEOUT) {
/*       printf("BlockWrite: Timeout error - no free words in toARM fifo.\n"); */
      timeoutError++;
      return;
    }
  }
  w_Boson_BlockToARM(w);
  freeW--;
}


unsigned int BlockRead(void)  /* read word from BlockFromARM register */
{      		    		     /* does polling and timeout */
  unsigned int w;
  unsigned int tInit;

  if(timeoutError) return -1;

  tInit=MonotonicTime();

  while(!Boson_RX_NotEmpty)
    if(MonotonicTime() -tInit > TIMEOUT) {
/*       QUIET printf("\nTimeout error on block read op\n"); */
      timeoutError++;
      return -1;
    }

  w = r_Boson_BlockFromARM;
  return w;
}

int Read_Data_Msg(unsigned int duration, unsigned char *buffer,
    			       unsigned int max_bytes, unsigned int *msg_type, unsigned int *msg_handle, unsigned int *msg_cmd)
{
  unsigned int time_now, temp, tempW, tempE;
  int packet_bytes=0, packet_bytes2=0, total_bytes=0, total_bytes2=0;
  int first_packet = FALSE, bytes_received = 0;

  time_now = MonotonicTime();
  max_bytes &= ~3;

  while((MonotonicTime() - time_now) < duration) {


    timeoutError = 0;
    temp = BlockRead();
    if (timeoutError>0) continue;


/*     printf("*** Boson BLOCK read: 0x%8x\n", temp); */
/*     if((temp & CMD_MESSAGE) == 0) { */
/*       printf("*** DATA_FIRST FLAG : %s\n", (temp & DATA_FIRST) ? "Set" : "Unset"); */
/*       printf("*** DATA_EXTEND FLAG: %s\n", (temp & DATA_EXTEND) ? "Set" : "Unset"); */
/*       printf("*** DATA_LAST FLAG  : %s\n", (temp & DATA_LAST) ? "Set" : "Unset"); */
/*     } */


    *msg_handle = (temp & DATA_HANDLE);
    *msg_cmd = ((temp & DATA_CMD) >> DATA_CMD_SHIFT);

    if(temp & CMD_MESSAGE) {
      *msg_type = 1;
/*       DBUG printf("Got a command packet.\n"); */
      return 0;
    }
    else *msg_type = 0;

/*     DBUG printf("\nGot a data packet.\n"); */

    packet_bytes2 = packet_bytes = (int)(temp >> 21); /* bytes in this packet */

    if (temp & DATA_FIRST) {  /* first packet */
       first_packet = TRUE;
/*        DBUG printf("First packet.\n"); */

       if(temp & DATA_EXTEND)  { /* extension bit set? */

          do {
              timeoutError = 0;

              if((MonotonicTime() - time_now) > duration) {
/*                 printf("Timed out while waiting for extension word for 1st valid packet\n"); */
                return -1;
              }
              tempE = CommitRead();
          } while(timeoutError>0);

          total_bytes = (int)((tempE & 0xffff0000) >> 16);
          total_bytes2 = total_bytes;
/*           DBUG printf("Got an extension word, total size: %d bytes\n", total_bytes2); */

       } /* no extension word */
    } /* first packet */

/*     DBUG printf("Expecting %d/%d bytes\n", packet_bytes2, total_bytes2?total_bytes2:packet_bytes2); */

    while(packet_bytes>0) {                /* read the packet */
      do {
        timeoutError = 0;
        if((MonotonicTime() - time_now) > duration) {
/*           printf("Timed out while reading %svalid data word (%d/%d/%d)\n", */
/*            		first_packet?"":"in", (packet_bytes2 - packet_bytes), packet_bytes2, */
/*                        		total_bytes?total_bytes2:packet_bytes2); */
          return -1;
        }
        tempW = CommitRead();

      } while(timeoutError>0);

      packet_bytes -= sizeof(unsigned int);

      if(first_packet) { /* do we want this data? */
        if(bytes_received < max_bytes) {    	      /* proc. only transfers max_bytes of data to given buffer */
          *(unsigned int *)buffer = tempW;	      /* but reads all packet data from Boson FIFO */
          buffer += sizeof(unsigned int);
          bytes_received += sizeof(unsigned int);
        }

        if(total_bytes2>0) total_bytes -= sizeof(unsigned int);
      } /* endif first_packet */
    } /* endwhile packet_bytes */

/*    DBUG printf("Got %d bytes in partial data packet.\n", packet_bytes2); */

   if(temp & DATA_LAST) {        /* 'last' bit is set */
/*       DBUG printf("Got last packet.\n"); */
      return bytes_received+packet_bytes;
   } /* 'last' bit */



  } /* end main-while */

  return -2; /* if we've got to here, then we've timed out */
}




#define DATA_MESSAGE 0

typedef union
{
    /* 'raw' header */
    unsigned int  header;

    /* command message */
    struct
    {
        unsigned int  handle   : 10;
        unsigned int  type     :  1;    /* always 1 for command message */
        unsigned int  command  :  4;
        unsigned int  reserved :  1;    /* zero */
        unsigned int  param    : 16;
    } command;

    /* data message */
    struct
    {
        unsigned int  handle   : 10;
        unsigned int  type     :  1;
        unsigned int  command  :  4;
        unsigned int  first    :  1;
        unsigned int  last     :  1;
        unsigned int  ext      :  1;
        unsigned int  reserved :  3;
        unsigned int  size     : 11;
    } data;

    /* elements common to both */
    struct
    {
        unsigned int  handle   : 10;
        unsigned int  type     :  1;
        unsigned int  command  :  4;
    } common;
} message;


typedef union
{
    unsigned int  extension;

    struct
    {
        unsigned int  reserved : 16;
        unsigned int  size     : 16;
    } bits;
} extension;




/* Number of bytes free in FIFO */
static int  fifo_space (void)
{
    for (;;)
    {
        if (Boson_TX_384)
        {
            return (384 * 4);
        }
        else if (Boson_TX_128)
        {
            return (128 * 4);
        }
        else if (Boson_TX_16)
        {
            return (16 * 4);
        }
    }
}




void  Write_Data_Msg (const int             handle,
                      const unsigned int *  data,
                      int                   data_bytes)
{
    int      fifo_bytes = 0;
    message  msg;

    dprintf (("", "Write_Data_Msg: %d bytes\n", data_bytes));

    msg.header      = 0;
    msg.data.handle = handle;
    msg.data.type   = DATA_MESSAGE;
    msg.data.first  = 1;

    fifo_bytes = fifo_space ();
    if (data_bytes > fifo_bytes - sizeof (message))
    {
        int        packet_bytes;
        extension  ext;

        dprintf (("", "Fragmenting data\n"));

        ext.extension = 0;
        /* Have to send data in blocks (each block sent with AS_DATA must be
         * a multiple of 48 bytes.
         */

        /* First block can do maximum of (fifo_space - 8) words (accounting for
         * message header and extension word), and must be multiples of 48
         * bytes.
         */
        packet_bytes     =
            ((fifo_bytes - (sizeof (message) + sizeof (extension))) / 48) * 48;
        msg.data.command = AS_DATA;
        msg.data.ext     = 1;
        msg.data.size    = packet_bytes;
        ext.bits.size    = data_bytes;

        dprintf (("", "%d\n", packet_bytes));

        /* Number of bytes that will remain after this block */
        data_bytes -= packet_bytes;

        /* Write message */
        w_Boson_CommitToARM (msg.header);

        /* Write extenstion word */
        w_Boson_CommitToARM (ext.extension);

        /* Write all but last word of packet */
        while (packet_bytes -= 4, packet_bytes > 0)
        {
            w_Boson_CommitToARM (*data++);
        }

        /* Write last word of packet and increment block counter */
        w_Boson_BlockToARM (*data++);


        msg.data.first   = 0;
        msg.data.last    = 0;
        msg.data.ext     = 0;

        fifo_bytes = fifo_space ();

        while (data_bytes > fifo_bytes - sizeof (message))
        {
            /* Middle blocks can do maximum of (fifo_space - 4) bytes
             * (accounting for message header), and must be multiples of 48
             * bytes.
             */
            packet_bytes  = ((fifo_bytes - sizeof (message)) / 48) * 48;
            msg.data.size = packet_bytes;

            dprintf (("", "%d\n", packet_bytes));

            /* Number of bytes that will remain after this block */
            data_bytes -= packet_bytes;

            /* Write message */
            w_Boson_CommitToARM (msg.header);

            /* Write all but last word of packet */
            while (packet_bytes -= 4, packet_bytes > 0)
            {
                w_Boson_CommitToARM (*data++);
            }

            /* Write last word of packet and increment block counter */
            w_Boson_BlockToARM (*data++);

            fifo_bytes = fifo_space ();
        }
    }

    /* Either sending all data in one go, or last block of multi-block message.
     */
    msg.data.command = AS_DATA_END;
    msg.data.last    = 1;
    msg.data.size    = data_bytes;

    dprintf (("", "%d\n", data_bytes));

    /* Write message */
    w_Boson_CommitToARM (msg.header);

    /* Write all but last '<= 4 bytes' of packet */
    while (data_bytes -= 4, data_bytes > 0)
    {
        w_Boson_CommitToARM (*data++);
    }

    /* Write last few bytes of packet and increment block counter. May not
     * actually be a whole word though, but this shouldn't matter - the NIC
     * should ignore any junk bytes at the end if we've got our byte count
     * correct.
     */
    w_Boson_BlockToARM (*data);

    dprintf (("", "done\n\n"));
}
