
/* ******************************************************************************** */
/* Various low level read and write calls to talk to the ATM25 podule's registers   */
/* Modified quite extensively to accomodate the EASI bus address space, not ISA	    */
/* ******************************************************************************** */
#include "kernel.h"
#include "swis.h"

#include "headers.h"
#include "module.h"
#include "services.h"
#define PROTOTYPES_INTERNAL
#include "atmio.h"
#include "utils.h"


/* ******************************** */
/* write to various BOSON registers */
/* ******************************** */

void CommitWrite(int w) /* write word to CommitToARM register */
{      	    		       /* checks for available FIFO space & h/w failure */
  static int freeW = 0;
  unsigned int tInit;

  if(timeoutError) return;

  tInit=MonotonicTime();

  while(freeW == 0) {
    if(Boson_TX_384) freeW=384;
    else if(Boson_TX_128) freeW=128;
    else if(Boson_TX_16) freeW=16;

    else if(MonotonicTime() - tInit > TIMEOUT) {
/*       printf("CommitWrite: timeout error - no free words in toARM fifo.\n"); */
      timeoutError++;
      return;
    }
  }
  w_Boson_CommitToARM(w);
  freeW--;
}


unsigned int CommitRead(void) /* read word from CommitFromARM register */
{      		    		     /* polls and times out */
  unsigned int w;
  unsigned int tInit;

  if(timeoutError) return -1;

  tInit=MonotonicTime();

  while(!Boson_RX_NotEmpty)
    if(MonotonicTime() -tInit > TIMEOUT) {
/*       QUIET printf("\nTimeout error on commit read op\n"); */
      timeoutError++;
      return -1;
    }

  w = r_Boson_CommitFromARM;
  return w;
}

void BlockWrite(int w)   /* write word to BlockToARM register  */
{      	    		   	/* does FIFO freespace check and h/w timeout */
  static int freeW = 0;
  unsigned int tInit;

  if(timeoutError) return;

  tInit=MonotonicTime();

  while(freeW == 0) {
    if(Boson_TX_384) freeW=384;
    else if(Boson_TX_128) freeW=128;
    else if(Boson_TX_16) freeW=16;

    else if(MonotonicTime() - tInit > TIMEOUT) {
/*       printf("BlockWrite: Timeout error - no free words in toARM fifo.\n"); */
      timeoutError++;
      return;
    }
  }
  w_Boson_BlockToARM(w);
  freeW--;
}


unsigned int BlockRead(void)  /* read word from BlockFromARM register */
{      		    		     /* does polling and timeout */
  unsigned int w;
  unsigned int tInit;

  if(timeoutError) return -1;

  tInit=MonotonicTime();

  while(!Boson_RX_NotEmpty)
    if(MonotonicTime() -tInit > TIMEOUT) {
/*       QUIET printf("\nTimeout error on block read op\n"); */
      timeoutError++;
      return -1;
    }

  w = r_Boson_BlockFromARM;
  return w;
}

/* **************************************************** */
/* handle multi-packet data transactions with the BOSON */
/* **************************************************** */


int Write_Data_Msg(unsigned int handle, const int command, unsigned char *data, unsigned int bytes)
{
  unsigned int *ip_ptr;
  int bytes_left, packet_bytes, total_bytes = 0;
  unsigned int first_packet = TRUE, last_packet = FALSE, need_extend = FALSE;
  unsigned int data_tx_word = 0;
  unsigned int last_word = 0;
  unsigned int fifo_space = 0;
  unsigned int alloc_attempts = 0;



  data_tx_word = (handle & 0x3ff) | ((command & 0xf) << 11); /* set up the handle and command fields */

  ip_ptr = (unsigned int *)data;

  bytes_left = bytes;


  while(bytes_left>0) {

    for(fifo_space = 0; (alloc_attempts<10) && (fifo_space==0); alloc_attempts++) {
      if(Boson_TX_384) fifo_space = 384;
      else if(Boson_TX_128) fifo_space = 128;
      else if(Boson_TX_16) fifo_space = 16;
    }


    if(fifo_space==0) {
/*       printf("No TX FIFO space!!\n"); */
      return -1;
/*     } else printf("FIFO space: %d\n", fifo_space); */
  }

    packet_bytes = bytes_left>fifo_space ? fifo_space : bytes_left;

/*     DBUG printf("Sending packet: %d bytes, FIFO: %d\n", packet_bytes, fifo_space); */
    total_bytes += packet_bytes;

    if(first_packet) { /* set the 'first' flag */
      data_tx_word |= DATA_FIRST;
      first_packet = FALSE;

      if(bytes_left > fifo_space) { /* if first block, we have the option of extending */
         data_tx_word |= DATA_EXTEND; /* block is bigger than the buffer - extend */
         need_extend = TRUE;
      }
    }

      if(bytes_left <= fifo_space) {
         data_tx_word |= DATA_LAST;  /* set the last flag */
         last_packet = TRUE;
      }

    data_tx_word |= (packet_bytes & 0x7ff) << 21; /* mask in the packet size */

/*     DBUG printf("Data block header word: 0x%8x\n", data_tx_word); */
/*     DBUG { if(data_tx_word & DATA_EXTEND) printf("Data block extension word: 0x%8x\n", (bytes & 0xffff) << 16); } */

    timeoutError = 0;
    CommitWrite(data_tx_word);
    if(data_tx_word & DATA_EXTEND) CommitWrite((bytes & 0xffff) << 16);
    data_tx_word = (handle & 0x3ff) | ((command & 0xf) << 11); /* reset the header word */

    bytes_left -= packet_bytes;

    while(packet_bytes>0) {
      timeoutError = 0;
      if(packet_bytes <= 4) {
        last_word = 0;
        memcpy((char *)&last_word, (char *)ip_ptr, packet_bytes);
        BlockWrite(last_word);
/*         DBUG printf("Written last word.\n"); */
      }
      else CommitWrite(*ip_ptr++);

        packet_bytes -= sizeof(unsigned int);
    } /* endwhile packet_bytes */
  } /* endwhile bytes_left */

/*   DBUG printf("Bytes left: %d of bytes: %d. Total bytes record = %d\n", bytes_left, bytes, total_bytes); */
  return 0;
}



int Read_Data_Msg(unsigned int duration, unsigned char *buffer,
    			       unsigned int max_bytes, unsigned int *msg_type, unsigned int *msg_handle, unsigned int *msg_cmd)
{
  unsigned int time_now, temp, tempW, tempE;
  int packet_bytes=0, packet_bytes2=0, total_bytes=0, total_bytes2=0;
  int first_packet = FALSE, bytes_received = 0;

  time_now = MonotonicTime();
  max_bytes &= ~3;

  while((MonotonicTime() - time_now) < duration) {


    timeoutError = 0;
    temp = BlockRead();
    if (timeoutError>0) continue;


/*     printf("*** Boson BLOCK read: 0x%8x\n", temp); */
/*     if((temp & CMD_MESSAGE) == 0) { */
/*       printf("*** DATA_FIRST FLAG : %s\n", (temp & DATA_FIRST) ? "Set" : "Unset"); */
/*       printf("*** DATA_EXTEND FLAG: %s\n", (temp & DATA_EXTEND) ? "Set" : "Unset"); */
/*       printf("*** DATA_LAST FLAG  : %s\n", (temp & DATA_LAST) ? "Set" : "Unset"); */
/*     } */


    *msg_handle = (temp & DATA_HANDLE);
    *msg_cmd = ((temp & DATA_CMD) >> DATA_CMD_SHIFT);

    if(temp & CMD_MESSAGE) {
      *msg_type = 1;
/*       DBUG printf("Got a command packet.\n"); */
      return 0;
    }
    else *msg_type = 0;

/*     DBUG printf("\nGot a data packet.\n"); */

    packet_bytes2 = packet_bytes = (int)(temp >> 21); /* bytes in this packet */

    if (temp & DATA_FIRST) {  /* first packet */
       first_packet = TRUE;
/*        DBUG printf("First packet.\n"); */

       if(temp & DATA_EXTEND)  { /* extension bit set? */

          do {
              timeoutError = 0;

              if((MonotonicTime() - time_now) > duration) {
/*                 printf("Timed out while waiting for extension word for 1st valid packet\n"); */
                return -1;
              }
              tempE = CommitRead();
          } while(timeoutError>0);

          total_bytes = (int)((tempE & 0xffff0000) >> 16);
          total_bytes2 = total_bytes;
/*           DBUG printf("Got an extension word, total size: %d bytes\n", total_bytes2); */

       } /* no extension word */
    } /* first packet */

/*     DBUG printf("Expecting %d/%d bytes\n", packet_bytes2, total_bytes2?total_bytes2:packet_bytes2); */

    while(packet_bytes>0) {                /* read the packet */
      do {
        timeoutError = 0;
        if((MonotonicTime() - time_now) > duration) {
/*           printf("Timed out while reading %svalid data word (%d/%d/%d)\n", */
/*            		first_packet?"":"in", (packet_bytes2 - packet_bytes), packet_bytes2, */
/*                        		total_bytes?total_bytes2:packet_bytes2); */
          return -1;
        }
        tempW = CommitRead();

      } while(timeoutError>0);

      packet_bytes -= sizeof(unsigned int);

      if(first_packet) { /* do we want this data? */
        if(bytes_received < max_bytes) {    	      /* proc. only transfers max_bytes of data to given buffer */
          *(unsigned int *)buffer = tempW;	      /* but reads all packet data from Boson FIFO */
          buffer += sizeof(unsigned int);
          bytes_received += sizeof(unsigned int);
        }

        if(total_bytes2>0) total_bytes -= sizeof(unsigned int);
      } /* endif first_packet */
    } /* endwhile packet_bytes */

/*    DBUG printf("Got %d bytes in partial data packet.\n", packet_bytes2); */

   if(temp & DATA_LAST) {        /* 'last' bit is set */
/*       DBUG printf("Got last packet.\n"); */
      return bytes_received+packet_bytes;
   } /* 'last' bit */



  } /* end main-while */

  return -2; /* if we've got to here, then we've timed out */
}


/* do the same sort of thing but under IRQs, so forget about timeouts */

int Read_Fifo_Fast(unsigned char *buffer, unsigned int max_bytes,
    			   unsigned int *msg_type, unsigned int *msg_handle,
    			   	    unsigned int *msg_cmd, int *last_packet)
{
  unsigned int temp, tempW, tempE;
  int packet_bytes=0;
  int bytes_received = 0;

  max_bytes &= ~3; /* round max. packet buffer down to nearest word boundary */


  temp = r_Boson_BlockFromARM; /* do a raw BlockRead() */

  *msg_handle = (temp & DATA_HANDLE);
  *msg_cmd = ((temp & DATA_CMD) >> DATA_CMD_SHIFT);

  if ((temp & DATA_FIRST) && (temp & DATA_LAST)) *last_packet = 2; /* self contained */
  else if (temp & DATA_FIRST) *last_packet = 1;
  else if (temp & DATA_LAST) *last_packet = 0;

  *msg_type = 0;

  if(temp & CMD_MESSAGE) {
    *msg_type = 1;
    return 0;
  }


  packet_bytes = (int)(temp >> 21); /* bytes in this packet */
  tempE = (temp >> 21) & 0x7ff;
  tempE = (tempE +3 ) & ~0x3;
  packet_bytes = (int)tempE;


  if (temp & DATA_FIRST) {  /* first packet */
/*      first_packet = TRUE; */

     if(temp & DATA_EXTEND)  { /* extension bit set? */
        tempE = r_Boson_CommitFromARM; /* do a raw CommitRead() */
/*         total_bytes = (int)((tempE & 0xffff0000) >> 16); */
/*         total_bytes2 = total_bytes; */
     } /* no extension word */
  } /* first packet */


  while(packet_bytes>0) {                /* read the packet */

    tempW = r_Boson_CommitFromARM;     /* do a raw CommitRead() */
    packet_bytes -= sizeof(unsigned int);

    /* if(first_packet) {  */                             /* do we want this data? */
      if(bytes_received < max_bytes) {    	      /* proc. only transfers max_bytes of data to given buffer */
        *(unsigned int *)buffer = tempW;	      /* but reads all packet data from Boson FIFO */
        buffer += sizeof(unsigned int);
        bytes_received += sizeof(unsigned int);
      }

/*       if(total_bytes2>0) total_bytes -= sizeof(unsigned int); */
   /*  } */ /* endif first_packet */
  } /* endwhile packet_bytes */


/*    if(temp & DATA_LAST) return bytes_received+packet_bytes; */
 /* return -1; */ /* if we've got to here, then something went wrong */
 return bytes_received;
}


/* Faster version of FIFO write - no timeout ops */
int Write_Fifo_Fast(unsigned int handle, const int command, unsigned char *data, unsigned int bytes)
{
  unsigned int *ip_ptr;
  int bytes_left, packet_bytes, total_bytes = 0;
  unsigned int first_packet = TRUE, last_packet = FALSE, need_extend = FALSE;
  unsigned int data_tx_word = 0;
  unsigned int last_word = 0;
  unsigned int fifo_space = 0;
  unsigned int alloc_attempts = 0;

//  char banana[40];


  data_tx_word = (handle & 0x3ff) | ((command & 0xf) << 11); /* set up the handle and command fields */

  ip_ptr = (unsigned int *)data;

  bytes_left = bytes;


  while(bytes_left>0) {

/*     for(fifo_space = 0; (alloc_attempts<10) && (fifo_space==0); alloc_attempts++) { */
    for(fifo_space = 0; fifo_space == 0; alloc_attempts++) { /* possible disastrous consequences */
      /* these values have had 8 subtracted, to accomodate the possible 2 header words */
      if(Boson_TX_16) fifo_space = 56;    /*  16 words available, -2 for headers =  14*4 bytes = 56   bytes */
      if(Boson_TX_128) fifo_space = 504;  /* 128 words available, -2 for headers = 126*4 bytes = 504  bytes */
      if(Boson_TX_384) fifo_space = 1528; /* 384 words available, -2 for headers = 382*4 bytes = 1528 bytes */
    }
#ifdef RUNS_ON_ARM700
    // sprintf(banana, "%d%d%d%d", fifo_space, alloc_attempts, bytes_left, bytes);
#else
    // sprintf(banana,"%d", fifo_space);
#endif

/*      sprintf(banana,"%d\n", alloc_attempts); */
    if(fifo_space==0) {
      return -1;
  }


    packet_bytes = bytes_left>fifo_space ? fifo_space : bytes_left;

    total_bytes += packet_bytes;

    if(first_packet) { /* set the 'first' flag */
      data_tx_word |= DATA_FIRST;
      first_packet = FALSE;

      if(bytes_left > fifo_space) { /* if first block, we have the option of extending */
         data_tx_word |= DATA_EXTEND; /* block is bigger than the buffer - extend */
         need_extend = TRUE;
      }
    } /* endof first packet */

      if(bytes_left <= fifo_space) {
         data_tx_word |= DATA_LAST;  /* set the last flag */
         last_packet = TRUE;
      }

    data_tx_word |= (packet_bytes & 0x7ff) << 21; /* mask in the packet size */


    w_Boson_CommitToARM(data_tx_word);
    if(data_tx_word & DATA_EXTEND) w_Boson_CommitToARM((bytes & 0xffff) << 16);
    data_tx_word = (handle & 0x3ff) | ((command & 0xf) << 11); /* reset the header word */

    bytes_left -= packet_bytes;

    while(packet_bytes > 0) {
      if(packet_bytes <= 4) {
        last_word = 0;
        memcpy((char *)&last_word, (char *)ip_ptr, packet_bytes);
        w_Boson_BlockToARM(last_word);
        ip_ptr++; /* skip final word in packet */
      }
      else w_Boson_CommitToARM(*ip_ptr++);

        packet_bytes -= sizeof(unsigned int);
    } /* endwhile packet_bytes */

  } /* endwhile bytes_left */



  return 0;
}
