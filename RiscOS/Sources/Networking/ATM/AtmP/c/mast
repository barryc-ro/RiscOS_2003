
#include "sys/types.h"
#define PROTOTYPES_INTERNAL
#include "mast.h"
#include "ctype.h"
#include "string.h"
#include "atmsock.h"
#include "services.h"
#include "utils.h"
#include "resources.h"
#include "atmio.h"
#include "macros.h"
#include "listen.h"
#include "nbit_mask.h"
#include <stdio.h>

/* clear_masttab() clears a single given entry in the MAST connection table
   without trashing the rx buffer pointer */

void clear_masttab(struct mast *m)
{
    char *b = m->m_rxbuf;
    memset((char *)m, 0, sizeof(struct mast));
    m->m_rxbuf = b;
}

/* clear_mast(), on the other hand, bins the whole thing */

void clear_mast(void)
{
    struct mast *m;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++) {
        if (!(m->m_status & M_PERMANENT))
            clear_masttab(m);
    }
}

/* mast_user_locate() returns a mast tab entry based on a REMOTE MAST address
   and a REMOTE port number */

struct mast *mast_user_locate(unsigned char *dst, unsigned int port)
{
    struct mast *m;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)
      if((memcmp(&dst[2], &m->m_macadr[2],4)==0) && port == m->m_port) return(m);

    return ((struct mast *)0);
}

/* mast_local_locate() returns a mast tab entry based on a REMOTE MAST address
   and a LOCAL port number */

struct mast *mast_local_locate(unsigned char *dst, unsigned int port)
{
    struct mast *m;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)
      if((memcmp(&dst[2], &m->m_macadr[2],4)==0) && port == m->m_local_port) return(m);

    return ((struct mast *)0);
}

/* mast_service_locate() returns a mast tab entry based on a REMOTE MAST address
   and either a LOCAL port number or a REMOTE port number */

struct mast *mast_service_locate(unsigned char *dst, unsigned int port)
{
    struct mast *m;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)
    {
      if(memcmp(&dst[2], &m->m_macadr[2],4)!=0)
      {
        continue; /* wrong MSNL address */
      }

      if((port == m->m_local_port) || (port == m->m_port))
      {
        return(m);
      }
    }

    return ((struct mast *)0);
}

/* mast_handle_locate() returns a mast tab entry based on remote addr. and remote port */

struct mast *mast_handle_locate(unsigned int socket_handle)
{
    struct mast *m;

    if(socket_handle == 0) return ((struct mast *)NULL);

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++) {
        if (m->m_socket_handle == socket_handle)
            return (m);
    }
    return ((struct mast *)NULL);
}

/* mast_mux_locate() returns a mast tab entry based on MAST address and multiplex-type info */

struct mast *mast_mux_locate(unsigned char *dst, unsigned int mux)
{
    struct mast *m;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++) {
        if (m->m_muxtype == mux && memcmp(&dst[2], &m->m_macadr[2], 4) == 0)
            return (m);
    }
    return ((struct mast *)0);
}


/* modified to include sock_handle param to mast_add()
   and to take NULL as a *dst parameter -ie MAST address 0.0.0.0

   DANGER - for some reason, the param *dst below points to macadr[2],
   	    not macadr[0] like every other call in these sources  */

struct mast *mast_add(unsigned char *dst, unsigned int port,
       unsigned int oflag, unsigned int *exists, unsigned int status,
       unsigned int sock_handle)
{
    struct mast *m, *mp = 0;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)
    {
        if (m->m_port == M_FREE)
        {
#ifdef DEBUG
            printf("mast_add: found a free entry!\n");
#endif
            if (mp == 0)
            {
                mp = m;
            }
        }
        else
        {
          if((m->m_port == port) && (memcmp(dst, &m->m_macadr[2], 4) == 0))
          {
            *exists = 1;
#ifdef DEBUG
            printf("mast_add: exists!\n");
#endif
            return (m);
          } /* endof exists */
        }
    } /* end loop */

    if (mp)
    {
#ifdef DEBUG
          printf("Adding MAST entry: %d.%d.%d.%d - %d\n", dst[0], dst[1], dst[2], dst[3], port);
#endif
        mp->m_macadr[0] = 0;
        mp->m_macadr[1] = 0;
        memcpy(&mp->m_macadr[2], dst, 4);

        mp->m_port = port;
        mp->m_originator = oflag; /* if 1, then we originated this call (ie a 'connect') else it's a 'listen' */
        mp->m_status = status;
        mp->m_socket_handle = sock_handle;
    } /* endif mp */

    *exists = 0; /* no previous entry was found */
    return (mp); /* mp indicates whether we were successful in allocating anew one */
}

/* fills out a connection table entry and attempts to get the NIC to connect
   mast_listen() seems to take a destination parameter! :)  This is ignored by sock_listen()
   I left it in for a laff - there's precious few gags in this code.  */

/* Since I've sorted out the whole listening socket scenario, we now re-direct this call
   to add_listen(), although I'm pretty certain mast_listen() is now never called. */

struct mast *mast_listen(unsigned char *dst, unsigned int port, unsigned int muxtype)
{
  add_listen(port, muxtype);
  return((struct mast *)NULL);
/*     unsigned int exists; */
/*     struct mast *m; */

/*     if((m=mast_add(&dst[2], port, 0, &exists, (M_SWITCHED | M_PENDING), next_free_socket_handle))==0) */
/*        return((struct mast *)NULL); */

/*       if(sock_listen(next_free_socket_handle, chtoui(dst), portpacked(port))) { */
/*         INC_SOCK_HANDLE; */
/*         return(m); */
/*       } */
        /* NIC connection has failed -- timeout/network error */
    /* clear_masttab(m); */ /* clear the entry. I don't move n_f_sock_handle back again, because it could be
        		     a problem with that socket resource in the NIC image */
/*     return((struct mast *)NULL); */

}

/* mast_connect() attempts to connect to a remote service - has been stripped down to
   do LLC_SNAP or VC encapsulated IP and MPEG over AAL5 ONLY
   converted char *dst (a bad idea) to unsigned char *dst */

struct mast *mast_connect(unsigned char *dst, unsigned int port)
{
    struct mast *m = 0;
    unsigned int exists;
    int socket_handle;

    switch(port) {

        case M_LLC:     /* LLC-SNAP encapsulation */
        case M_IP:	/* VC encapsulation */
            break;

        case M_MPEG_AAL5:
            break;

        default:
#ifdef DEBUG
            printf("mast_connect: unrecognized port number.\n");
#endif
            return (m);
    }

    if((socket_handle=get_handle(handle_wspace))<0) {
#ifdef DEBUG
       printf("mast_connect: get_handle() failed, returned %d\n", socket_handle);
#endif
      return((struct mast *)NULL); /* failed to get socket handle */
    }
    m = mast_add(&dst[2], port, 1, &exists, (M_SWITCHED | M_PENDING), (unsigned int)socket_handle);
    if(!m) {
#ifdef DEBUG
      printf("mast_connect: No MAST entry available.\n");
      printf("mast_connect: free_handle() returned %d\n", free_handle(handle_wspace, socket_handle));
#else
      free_handle(handle_wspace, socket_handle);
#endif
      return(m);
    }

    if(exists) {
#ifdef DEBUG
       printf("mast_connect: MAST entry already exists!\n");
#endif
       return(m);
    }


    if(sock_connect((unsigned int)socket_handle, dst, port)==0) {
#ifdef DEBUG
      printf("mast_connect: connection successful.\n");
#endif
      return(m);
    } else {
#ifdef DEBUG
      printf("mast_connect: failed, clearing entry\n");
#endif
      clear_masttab(m); /* connect failed - clear mast tab entry */
#ifdef DEBUG
       printf("mast_connect: free_handle() returned %d\n", free_handle(handle_wspace, socket_handle));
#else
      free_handle(handle_wspace, socket_handle); /* free socket_handle */
#endif
      return((struct mast *)NULL);
    }
}

/* disconnect a connection, based on REMOTE MSNL and REMOTE port no.  */

struct mast *mast_disconnect(unsigned char *dst, unsigned int port)
{
  struct mast*m;

  m = mast_user_locate(dst, port);
  if(m) {
#ifdef DEBUG
    printf("mast_disconnect: found the connection - terminating it.\n");
#endif
    BlockWrite(CMD_MSG(m->m_socket_handle, AS_CLOSE, 0));
    BlockWrite(CMD_MSG(CMD_HANDLE, SO_DETACH, m->m_socket_handle));
#ifdef DEBUG
       printf("mast_disconnect: free_handle() returned %d\n", free_handle(handle_wspace, (int)(m->m_socket_handle)));
#else
    free_handle(handle_wspace, (int)(m->m_socket_handle));
#endif

    clear_call_resources(m);
    clear_masttab(m);
  }

   return(struct mast *)NULL;
}



void mast_circuits(int *nbr, int *happy)
{
    struct mast *m;
    int n_circuits = 0;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++) {
        if (m->m_port == M_FREE) continue;
        n_circuits++;
    }
    *nbr = n_circuits;
    *happy = 0;
}

