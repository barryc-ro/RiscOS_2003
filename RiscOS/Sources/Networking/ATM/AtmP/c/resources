/* various calls to handle call resource */
/* in other words, call resources for call resources! */
#include <stdio.h>
#include <stdlib.h>
#include "strings.h"
#include "sys/types.h"
#include "kernel.h"
#include "swis.h"
#include "mast.h"
#include "module.h"
#define PROTOTYPES_INTERNAL
#include "resources.h"
#include "buffers.h"
#include "panther.h"

/* provide a buffer for each mast entry, pointed to by m->m_rxbuf
   -If a mast entry subsequently governs an IP connection, this buffer will be used
    to cache IP Protocol Data Units.
   -If the mast entry governs an MPEG connection, this buffer will be ignored, and the
    pending data will instead be stored in an area claimed from the MPEG buffer handling
    system (see buffers.c, buffers.h)
*/

int claim_call_resources(void)
{
    struct mast *m;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++) {
        memset((char *)m, 0x0, sizeof(struct mast));
        m->m_rxbuf = malloc(MAST_RXBUFSIZE+2);
         if (m->m_rxbuf == 0)
            return (0);
    }
    return(1);
}

/* release any MPEG buffer resources which may have been claimed by this mast connection
   if this connection referred to an IP transaction, the call exits immediately.
*/

void clear_call_resources(struct mast *mp)
{
  struct bs_buffer *bs;
  unsigned int service_type;

    service_type = mp->m_originator?mp->m_port:mp->m_local_port;

    if (service_type == M_MPEG_AAL5) {
        interrupt_disable();
        bs = (struct bs_buffer *)mp->m_rbuf;

        if (bs != 0) {
            bs->bs_len = 0;
            atm_return_empty_buf(bs);
            mp->m_rbuf = 0;
        }
        if (bs_full_q && bswait_supply(bs_full_q)) {
            bs_full_q = 0;
            bs_fullp = 0;
            setcallback();
        }
        interrupt_enable();

    }

}

/* initialise the call resources for a new connection - buffer pools are allocated from
   MPEG buffer resources if required, otherwise the internal buffer for the relevant MAST
   connection table entry is used. Various pointers/counters are reset to safe initial states.
*/

void init_call_resources(struct mast *mp)
{
  unsigned int service_type;

    service_type = mp->m_originator?mp->m_port:mp->m_local_port;

    interrupt_disable();

    if ((service_type == M_LLC) || (service_type == M_IP)) {
        mp->m_rbuf = mp->m_rxbuf;
        mp->m_datacount = 0;
        mp->m_datalost = 0;
        mp->m_offset = 0;
    }
    else {
        bs_empty_q = 0;
        bs_full_q = 0;
        bs_emptyp = 0;
        bs_fullp = 0;
        bswait_init();
        reinit_bs_buffers();

        mp->m_rbuf = (char *)get_empty_buffer();
        mp->m_offset = 0;
        mp->m_datacount = 0;
        mp->m_datalost = 0;
    }
    interrupt_enable();
}
