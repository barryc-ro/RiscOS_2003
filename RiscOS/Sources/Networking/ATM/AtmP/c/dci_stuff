/*	DCI_STUFF.C

© Acorn Computers Ltd

Project :
Module:

Purpose


History:

Date      Who     Description of change
===========================================
5/6/98     CP     Header added.

                  Changed to use Acorn's DCI headers.

***************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"

#include "DebugLib/debuglib.h"

#define PROTOTYPES_INTERNAL
#include "dci_stuff.h"
#define MBCTL_NAME mbctl
#include "sys/mbuf.h"
//#include "mbuftypes.h"
#include "mbuf.h"
/*#include "dci4.h"*/
#include "sys/dcistructs.h"
#include "sys/types.h"
#include "mast.h"
#include "atmswis.h"
#include "strings.h"
#include "panther.h"
#include "localarp.h"
#include "module.h"
#include "resources.h"
#include "atmio.h"
#include "services.h"
#include "headers.h"
#include "boson.h"


extern Dib dib;
extern int callproto(Dib *, struct mbuf *, void (*pi_handler)(), int);
int txbuf[ATM_MTU  / sizeof (int)];
unsigned char hw_bcast_adr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
unsigned char arpserver[6] = { 0, 0, 0xff, 0xff, 0xff, 0xff };


/* various routines that deal with the dci interface */


/* rx_dci - forward a packet to protocol
   	    called from irq handler when we have an IP packet of some sort
*/

int rx_dci(char *packet, int datalen, unsigned short type)
{

/************************************************************************
 * NOTE: great improvements in efficiency can be made here by using the *
 * mbufmanager routines to throw data around!!!!                        *
 ************************************************************************/

    struct mbuf *pd, *m0;
    struct dci4pi *p;
    RxHdr *hdr;
    char *pp = packet;

    for (p = pibs; p; p = p->pi_next)
    {
        if (p->pi_ftype == type)
        {
           break;
        }
    }

    /* allocate a single mbuf */
    if ( p == 0 || ((m0 = m_alloc_s(MINCONTIG, NULL))) == (struct mbuf *)NULL )
    {
        return (0);
    }

/*    m0->m_type = MT_DATA;*/
    m0->m_type = MT_HEADER; /* 22oct98:CP:new DCI4 spec */

    hdr = mtod(m0, RxHdr *);  /* (RxHdr *)(m0->data) */
    m0->m_len = sizeof(RxHdr);
    hdr->rx_tag = 0;
    memset(hdr->rx_src_addr, 0, HW_ADDR_LEN);
    memset(hdr->rx_dst_addr, 0, HW_ADDR_LEN);
    hdr->rx_frame_type = type;
    hdr->rx_error_level = 0;
    *(u_short *)(&hdr->_spad[0]) = 0;
    *(u_short *)(&hdr->_dpad[0]) = 0;

    /* allocate an mbuf chain of size datalen */
    m0->m_next = m_alloc(datalen, NULL);

    if (m0->m_next == NULL)
    {
        m_freem(m0);
        return (0);
    }
    /*
     * run down the mbufs, filling them in
     */
    for( pd = m0->m_next; pd; pd = pd->m_next )
    {
        pd->m_type = MT_DATA;
        memcpy(mtod(pd, char *), pp, pd->m_len);
        pp += pd->m_len;
        datalen -= pd->m_len;  /* don't need this?? */
    }
    callproto( &dib, m0, p->pi_handler, p->pi_handle);
    return (1);
}


#define MAX_DUMP_BYTES  128

#ifdef DEBUGLIB

static void dump_pkt (u_char *  rptr, int pktlen)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    static const char digits[] = "0123456789abcdef";

    while (pktlen--)
    {
        if (bp > buf + sizeof(buf) - 3)
            goto done;
        *bp++ = digits[*rptr >> 4]; /* convert byte to ascii hex */
        *bp++ = digits[*rptr++ & 0xf];
        *bp++ = ' ';
    }

done:
    *bp = 0;
    dprintf (("", "%s\n", buf));
}



static void dumpm(struct mbuf *m0, int pktlen)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    struct mbuf *m;
    static const char digits[] = "0123456789abcdef";

    for (m = m0; m && pktlen; m = m->m_next)
    {
        int l = m->m_len;
        u_char *rptr = mtod(m, u_char *);

        if (pktlen > 0)
        {
            if (l > pktlen)
                l = pktlen;
            pktlen -= l;
        }
        while (l--)
        {
            if (bp > buf + sizeof(buf) - 4)
                goto done;
            *bp++ = digits[*rptr >> 4]; /* convert byte to ascii hex */
            *bp++ = digits[*rptr++ & 0xf];
            *bp++ = ' ';
        }

        if (m->m_next)
        {
            if (bp > buf + sizeof(buf) - 3)
                goto done;
            *bp++ = '|';
        }
        else
            *bp++ = ' ';
    }
done:
    if (m && pktlen)
        *bp++ = '>';
    *bp = 0;
    dprintf (("", "%s\n", buf));
}

#endif

int atm_transmit(_kernel_swi_regs *r)
{
    int flags, type, unit, datalen;
    char *t;
    struct mbuf *m, *m0;
    u_char *dst, mdst[HW_ADDR_LEN];
    int mref, llc_needed, discard = 0;
    int i = 0;
    static int atm_transmit_inuse = 0;

    struct mast *ant_tmp;

    if(atm_transmit_inuse)
    {
       dprintf (("", "atm_transmit: re-entered.\n"));
       return(0x20e86); /* transmission is blocked */
    }

    atm_transmit_inuse = 1;

    flags = r->r[0];
    unit = r->r[1];
    type = r->r[2];
    m0 = (struct mbuf *)(r->r[3]);
    dst = (u_char *)r->r[4];

    if (unit != 0 || m0 == 0)
    {
        atm_transmit_inuse = 0;
        dprintf (("", "atm_transmit: wrong unit.\n"));
        return (EINVAL);
    }
    /*
     * If configured to access remote arp/broadcast server,
     * filter out broadcast transmissions and re-route
     * to the arpserver MAST address.
     *
     * If not configured for remote arp, loop an ARP message back
     * internally, mapping a remote ip address directly into a
     * remote MAST address.
     */
    if (memcmp(dst, hw_bcast_adr, HW_ADDR_LEN) == 0) /* is it a BROADCAST packet? */
    {
        if (!do_arp)
        { /* are we processing ARP messages internally? */
            if (type == MESSAGE_TYPE_ARP)
            { /* is it, in fact, an ARP message? */
                arp_count++;
                for( datalen = 0, m = m0; m; m = m->m_next )
                {
                    datalen += m->m_len;
                }
                if( datalen <= sizeof(arpbuf) )
                { /* is the message small enough to swallow whole? */
                    t = arpbuf;
                    for(m = m0; m; m = m->m_next )
                    {
                        memcpy(t, mtod(m, char *), m->m_len);
                        t += m->m_len;
                    }
                    arplen = datalen;
                    local_arp_count++;
                    do_local_arp = 1;
                    setcallback(); /* if all these conditions are OK, copy the msg and set a callback to process it */
                } /* the msg was too big, and will be ignored */
                else
                {
                    discard_arp_count++;
                    dprintf (("", "atm_transmit: discarding ARP %i\n", discard_arp_count));
                }
            } /* it wasn't an ARP message - ignore this broadcast */
            discard = 1;
        }

        else
        {
            memcpy(mdst, arpserver, HW_ADDR_LEN); /* so redirect this msg to the arpserver */
	    bcast_arp_count++;
        }
    } /* it's not a BROADCAST type packet */

    else
    {
        memcpy(mdst, dst, HW_ADDR_LEN); /* store the dest. address */
    }

    if (!discard)
    {
        atm_ref(mdst, &mref, &llc_needed); /* find the conection resources */
        if (mref == 0)
        {
            dprintf (("", "atm_transmit: couldn't find connection resources\n"));
            discard = 1; /* dump the packet if we couldn't find / connect to the peer */
        }
    }

    if(!discard)
    { /* ANT added - 15/10/95 - think this is causing the post mortems! */
      ant_tmp = (struct mast *)mref;

      if(!(ant_tmp->m_status & M_CONNECT))
      { /* this connection is not yet established - drop the packet */
/*       printf("atm_transmit: dropping packet pending connection\n"); */
         dprintf (("", "atm_transmit: connection resource not yet ready\n"));
         discard = 1;
      }

      else
      {
         ant_tmp->m_status |= M_USED; /* keep connection alive */
      }
    } /* endif ANT added */


    do
    {
        for( datalen = 0, m = m0; m; m = m->m_next ) /* figure out how much buffer space we have */
        {
            datalen += m->m_len;
        }

#ifdef DEBUGLIB
        /* dumpm (m0, datalen); */
#endif

        if( datalen > ATM_MTU )
        {/* not enough? DUmp it */
            // discard = 1;
            dprintf (("", "atm_transmit: ATM_MTU exceeded.\n"));
            atm_transmit_inuse = 0;
	    return(EMSGSIZE); /* added in the Great Internet Errors Rethink */
        }



        if (!discard)
        {
            dprintf (("", "tx_atm: handle:%d port:%d size:%d LLC:%d\n",
                      ant_tmp->m_socket_handle, ant_tmp->m_port, datalen, llc_needed));

            t = (char *)txbuf;

            if (llc_needed != 0)
            {
                /* insert LLC value indicating
                   SNAP header is present*/
                *t++ = 0xAA;
                *t++ = 0xAA;
                *t++ = 0x03;
                /* insert SNAP header */
                *t++ = 0;
                *t++ = 0;
                *t++ = 0;
                *t++ = (type >> 8) & 0xff;
                *t++ = type & 0xff;
                datalen += LLC_HDR_SIZE;
            }

            for(m = m0; m; m = m->m_next )
            {
                memcpy(t, mtod(m, char *), m->m_len);
                t += m->m_len;
            }

#ifdef DEBUGLIB
            dump_pkt ((u_char *) txbuf, datalen);
#endif

//            ip_tx++;


            /* 1999-03-02: BAL
             * Replaced with new Write_Data_Msg - asm_write_fifo can't cope with blocks >1536 bytes
             */
#if 0
	    if(asm_write_fifo(ant_tmp->m_socket_handle, AS_DATA_END, (unsigned char *)txbuf, (unsigned int)datalen,BlockToARMAddr)<0)
	    {
	      dprintf (("", "atm_transmit: ran out of FIFO space!\n"));
	    }

	    else
	    {
	      ip_tx++;
	    }
#else
            Write_Data_Msg (ant_tmp->m_socket_handle,
                            (unsigned int *) txbuf,
                            datalen);
/* 	    Write_Fifo_Fast(ant_tmp->m_socket_handle, AS_DATA_END, (unsigned char *)txbuf, (unsigned int)datalen); */
            ip_tx++;
#endif
	    ant_tmp->m_status |= M_USED;
        }/* endif !discard */



        m = m0;
        m0 = m->m_list;
        m->m_list = 0;
        if( !(flags & TX_PROTOSDATA) )
        {
            m_freem(m);
        }
        i++;
    } while (m0 != NULL);

    atm_transmit_inuse = 0;
    return (0);
}


int atm_filter(_kernel_swi_regs *r) /* claim or release Ethernet frame types */
    				    /* protocol modules register frame types with us -
    				       they also pass handler entry points and wspace pointers */
{
    int unit = r->r[1];
    struct dci4pi *p, *p1;  /* pointers to our protocol-information structures */

    for (p = pibs; p ; p = p->pi_next) { /* search thru pibs */
        if (p->pi_unit == unit && p->pi_handle == r->r[5] && /* have we seen this request already? */
            p->pi_ftype == (r->r[2] & 0xffff))
        break;
    }

    if (r->r[0] & 0x1) { /* remove entry */
        if (!p) /* did we find the matching entry? */
            return (EINVAL); /* nope, raise an error */ /* was ENOPIB - never heard of it */

        if ((pibs = p) != 0) {
            pibs = p->pi_next;
        } else {
             for (p1 = pibs; p1 ; p1 = p1->pi_next)
                 if (p1->pi_next == p)
                     break;
             if (p1)
                 p1->pi_next = p->pi_next;
        }
        free(p);
/*         atm_stop(); */
        return(0);
    } /* end of remove-frametype */

    /* if we're not releasing a frame, then we must be claiming one */

    if (!p)
    { /* don't have an entry already, so make one */
        if ((p = (struct dci4pi *) malloc(sizeof(struct dci4pi)))==0) /* get some memory */
            return (EINVAL); /* was ENOMEM - never heard of it */
        p->pi_next = pibs;
        pibs = p;
        p->pi_unit = r->r[1];
        p->pi_ftype = r->r[2] & 0xffff;
        p->pi_handle = r->r[5];
/*         atm_startup(ATM_MTU+LLC_HDR_SIZE); */
    }

    /* if we had a matching entry, then we're merely updating these parameters */
    p->pi_flevel = 0;
    p->pi_alevel = r->r[3];
    p->pi_elevel = r->r[4];
    p->pi_handler = (void (*)(void))(r->r[6]); /* cast register to ptr2fn returning void * with void args */
    return (0);
}

/* try and find connection resources for an IP packet.
   Attempts to trace these as both LLC and IP multiplexed, and tries
   to create a VC multiplexed connection if nothing is found
*/

void atm_ref(unsigned char *dst, int *mref, int *needs_llc)
{
    struct mast *m;

/* 22oct98:CP:swapped around the search order since everything is now LLC/SNAP */
    m = mast_service_locate(dst, M_LLC); /* look for a VC mux connection */

    if (!m)
    {
        m = mast_service_locate(dst, M_IP); /* look for an LLC mux connection */
    }

    if (!m)
    {
      if(!do_vc)
      {
        m = mast_connect(dst, M_LLC); /* if neither exist, create an LLC_SNAP mux connection */
        if (m)
        {
            init_call_resources(m);
            m->m_muxtype = LLC_MULTIPLEX;
        }
      }
      else
      {
        m = mast_connect(dst, M_IP); /* if neither exist, create an IP mux connection */
        if (m)
        {
            init_call_resources(m);
            m->m_muxtype = VC_MULTIPLEX;
        }
      }
    }


    *mref = (int)m;
    *needs_llc = (m && (m->m_muxtype == LLC_MULTIPLEX)) ? 1 : 0;
}

