/* c.podule
 * Exported variables for STB2 podule version of code
 * (Hardware is in podule 1)
 */
#include "kernel.h"
#include "swis.h"
#include "sys/types.h"
#include "mast.h"
#define PROTOTYPES_INTERNAL
#include "panther.h"
#include "atmio.h"
#include "macros.h"
#include "ASSERTION.H"
#include "headers.h"
#include "module.h"
#include "services.h"
#include "atmsock.h"
#include "utils.h"
#include "boson.h"


void reset_panther(void)
{
  w_Boson_Command(BosonCmd_ClrAll);  /* mask out all Panther interrupts */
}


void interrupt_enable(void)
{

  w_Boson_Command(BosonCmd_SetRxBlockMask); /* use the command register to mask in the NotEmpty bit */
  					     /* IRQ thus generated when NIC has data available */
}

void interrupt_disable(void)
{
  w_Boson_Command(BosonCmd_ClrRxBlockMask); /* mask out the NotEmpty bit */
}



void atm_claim_device (int irq_code, int irq_ws)
{
     _kernel_swi_regs r;

     r.r[0] = 13; /* device number, 13 = expansion card */
     r.r[1] = irq_code;
     r.r[2] = irq_ws;
     r.r[3] = Boson_IRQ;
     r.r[4] = 0x2; /* 0x2 bit 1 is interrupt request */
     (void) _kernel_swi(XOS_Bit | OS_ClaimDeviceVector, &r, &r);
     return;
}

void atm_release_device (int irq_code, int irq_ws)
{
     _kernel_swi_regs r;

     r.r[0] = 13;
     r.r[1] = irq_code;
     r.r[2] = irq_ws;
     r.r[3] = Boson_IRQ;
     r.r[4] = 0x2; /* 0x2 bit 1 is interrupt request */
     (void) _kernel_swi(XOS_Bit | OS_ReleaseDeviceVector, &r, &r);
     return;
}


void read_mac_adr(void)
{
  unsigned int recv_bytes, msg_type, msg_handle, msg_cmd;
  unsigned char mast_addr[20];
  unsigned char mast_var[] = "ATM25$IPaddress\0";
  _kernel_swi_regs r;


  BlockWrite(CMD_MSG(CMD_HANDLE, SO_GET_MAC, 0)); /* request MAC addr. from cmd service */
  recv_bytes = Read_Data_Msg(200, macadr, 8, &msg_type, &msg_handle, &msg_cmd);


  sprintf((char *)&mast_addr[0], "%u.%u.%u.%u", (unsigned int)macadr[2], (unsigned int)macadr[3],
  		(unsigned int)macadr[4], (unsigned int)macadr[5]);

  r.r[0] = (unsigned int)&mast_var[0];
  r.r[1] = (unsigned int)&mast_addr[0];
  r.r[2] = strlen((char *)mast_addr);
  r.r[3] = 0;
  r.r[4] = 4;
  _kernel_swi(OS_SetVarVal, &r, &r);

  DBUG printf("read_mac_adr: %d bytes type: %d handle: %d cmd: %d\n", recv_bytes, msg_type, msg_handle, msg_cmd);


}


int panther_happy(void)  /* check Panther is happy by waiting for magick word to be echoed */
{   			 /* do not use before init_panther() has been called, or the check will fail */
    int temp;
        		 /* it's probably best not to use this when the IRQ handler is running too */
    BlockWrite(HAPPY_PANTHER); /* write this to the echo service */
    timeoutError = 0;
    temp = BlockRead();     /* read it back */
    if(timeoutError) return -1; /* timed out? return error */
    if(temp != HAPPY_PANTHER) return -1; /* didn't get what we expected? return error */
    return 1;
}



int init_panther(void)   /* set up echo service, and M_LLC listen */
{
    BlockWrite(CMD_MSG(CMD_HANDLE, SO_ATTACHX, (ECHO_SERVICE << 12) | ECHO_HANDLE)); /* set up echo */

/*     ip_listen = next_free_socket_handle++; */
/*     ip_echo = next_free_socket_handle++; */
/*     mpeg_listen = next_free_socket_handle++; */
/*     if(sock_listen(ip_listen, 0, portpacked(M_IP))<0) return -1;  *//* oh dear, MAST listen op failed */
/*     if(sock_listen(mpeg_listen, 0, portpacked(M_MPEG_AAL5))<0) return -1;  *//* oh dear, MAST listen op failed */

/*     if(sock_listen(ip_echo, 0, portpacked(M_ECHO))<0) return -1; */ /* open conns on echo */
    return 0;

}



/* this routine is now largely obsolete, due to its sinplicity, the call overheads aren't worth it */
int tx_atm(unsigned char *buf, unsigned int len, unsigned int t, unsigned char *dst, struct mast *m)
{
    if (!m) return (0);
    asm_write_fifo(m->m_socket_handle, AS_DATA_END, (unsigned char *)buf, (unsigned int)len,BlockToARMAddr);
    m->m_status |= M_USED;
    return (1);
}


