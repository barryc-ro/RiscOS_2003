/* File:    configure.c
   Purpose: Configuration
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-02-18: BAL
   Created.  Merged atm_conf file - history of that file was:
       Date      Who     Description of change
       ===========================================
       20/6/97    CP     Added control header

                         Tidied up formatting.

       6/2/98     CP     Added function atm_changeupstreambandwidth() to cope
                         with new NVRAM allocation for configuring upstream
                         bandwidth/ratepacing of card.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "configure.h"
#include "defs.h"
#include "error.h"
#include "header.h"
#include "nvparams.h"




/* =============================================================================
 * Constants definitions
 */

#define NVRAM_PRIMARY_ATM_1_LOCATION  0x1e
#define NVRAM_PRIMARY_ATM_1_SIZE      12
#define NVRAM_PRIMARY_ATM_2_LOCATION  0x2f
#define NVRAM_PRIMARY_ATM_2_SIZE      8




/* =============================================================================
 * Function definitions
 */

/* -----------------------------------------------------------------------------
 */


int  configure_pvc (const bootconfig_action_t  action,
                    unsigned int *const        pvc)
{
    int  error = 0;

    if (action != BootConfig_Action_Sanitise && pvc == NULL)
    {
        error = Error_ATM_InvalidOption;
    }
    else
    {
        switch (action)
        {
            case BootConfig_Action_Sanitise:
                /* Nothing we can do */
                break;

            case BootConfig_Action_Read:
                *pvc = nvparams_read_pvc ();
                break;

            case BootConfig_Action_Validate:
                /* Nothing we can do */
                break;

            case BootConfig_Action_Update:
                nvparams_write_pvc (*pvc);
                break;

            default:
                error = Error_ATM_InvalidOption;
                break;
        }
    }

    return error;
}




int  configure_primary_atm (const bootconfig_action_t  action,
                            unsigned char *            atm_addr)
{
    int  error = 0;

    if (action != BootConfig_Action_Sanitise && atm_addr == NULL)
    {
        error = Error_ATM_InvalidOption;
    }
    else
    {
        switch (action)
        {
            case BootConfig_Action_Sanitise:
                /* Nothing we can do */
                break;

            case BootConfig_Action_Read:
                nvparams_read_primary_server (atm_addr);
                break;

            case BootConfig_Action_Validate:
                /* Nothing we can do */
                break;

            case BootConfig_Action_Update:
                if (atm_addr == NULL)
                {
                    error = Error_ATM_InvalidOption;
                }
                else
                {
                    nvparams_write_primary_server (atm_addr);
                }
                break;

            default:
                error = Error_ATM_InvalidOption;
                break;
        }
    }

    return error;
}




_kernel_oserror *  atm_conf_arp (int  argc, char *  argv[])
{
    _kernel_oserror *  e = NULL;
    int                do_config;

    switch (argc)
    {
        case ConfigCommand_Status:
        {
            do_config = nvparams_read_dynamic_arp ();
            printf("ATM25arp\t%s\n", do_config ? "on" : "off");
            break;
        }

        case 0:
            e = M_gen_error (ErrorNumber_Syntax);
            /* return syntax error as message rather than just printing it */
            break;

        case 1:
            if (strcmp (argv[1], "on") == 0)
            {
                do_config = 1;
            }
            else if (strcmp (argv[1], "off") == 0)
            {
                do_config = 0;
            }
            else
            {
                do_config = -1;
            }

            if (do_config >= 0)
            {
                nvparams_write_dynamic_arp (do_config);
            }
            else
            {
                e = M_gen_error (ErrorNumber_Syntax);
            }
            break;

        default:
            e = configure_TOO_MANY_PARAMS;
            break;
    }

    return e;
}




_kernel_oserror *  atm_conf_llc (int  argc, char *  argv[])
{
    _kernel_oserror *  e = NULL;

    M_unused (argv);

    switch (argc)
    {
        case ConfigCommand_Status:
        {
            int is_vc = nvparams_read_multiproto_enc ();
            printf ("ATM25llc\t%s\n", is_vc ? "off" : "on");
            break;
        }

        case 0:
            nvparams_write_multiproto_enc (0);
            break;

        default:
            e = configure_TOO_MANY_PARAMS;
            break;
    }

    return e;
}




_kernel_oserror *  atm_conf_vc (int  argc, char *  argv[])
{
    _kernel_oserror *  e = NULL;

    M_unused (argv);

    switch (argc)
    {
        case ConfigCommand_Status:
        {
            int is_vc = nvparams_read_multiproto_enc ();
            printf ("ATM25vc\t%s\n", is_vc ? "on" : "off");
            break;
        }

        case 0:
            nvparams_write_multiproto_enc (1);
            break;

        default:
            e = configure_TOO_MANY_PARAMS;
            break;
    }

    return e;
}




/******* atm_changeupstreambandwidth ***************************************

Purpose: Modifies/displays NVRAM holding rate pacing parameters

Inputs: char * argument string

            if ((int) args == 0)
            {*configure called with no parameters, return syntax string}

            if ((int) args == 1)
            {*status called, print value}

            else
            {args is a pointer to the argument(s) from the CLI}

Cf. PRMs, 1-215, "Information Word".  Specifically, bit 30.....the cmhg
veneer checks this bit when 'configure:' is defined in the CLI table entry,
and sorts everything out to the CLI handler.

Outputs: none

***************************************************************************/

_kernel_oserror *  atm_changeupstreambandwidth (int argc, char *  argv[])
{
    unsigned int  bandwidth;
    _kernel_oserror *   e = NULL;

    switch (argc)
    {
        case ConfigCommand_Status:
            bandwidth = nvparams_read_upstream_bandwidth ();
            printf ("ATM25bw\t");

            if (bandwidth == 0)
            {
                printf("unlimited\n");
            }

            else
            {
                printf("%d kb/s\n", bandwidth);
            }
            break;

        case 1:
            bandwidth = (unsigned int) strtoul (argv[1], NULL, 0);
            nvparams_write_upstream_bandwidth (bandwidth);
            break;

        default:
            e = configure_TOO_MANY_PARAMS;
            break;
    }

    return e;
}
