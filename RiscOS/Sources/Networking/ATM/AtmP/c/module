/*	MODULE.C

Project : ATML ATM25 card driver

Purpose: Risc OS module type stuff

History:

Date      Who     Description of change
===========================================
20/1/97    CP      Picked up the existing code, added header.

		   Modified calls to init_bs_buffers to reflect changes made
		   to the function in buffer.c

		   Replaced all occurrences of BS_BUFFER_SIZE with
		   bs_buffer_size_G, and imported the variable.

21/1/97    CP      Added changebufferpool CLI to CLIhandler

28/1/97    CP      Added goof-proofing veneer for asm_get_msg().

22/12/97   CP      Fixed tragically broken chaindib structure (used in
                   enumerate driver service call).  It was a global, but
                   should have been dynamically allocated since the calling
                   routine frees the memory!

                   Removed a stray debugging printf from the IRQ handler.
                   This was crashing the box whenever mbufs could not be
                   allocated.

                   Tidied up #includes, using <...> where appropriate.

6/2/98     CP      Added new command to use NVRAM for bandwidth

30/4/98    CP      Added cmhg.h, which is auto-generated by cmhg
                   Fixed calls to cmhg functions

28/5/98    CP      Changed definition of swi base to ATM_00 from cmhg.h

1/6/98     CP      Moved handling of chaindibs entirely within service
                   handler (there's a possibility that memory could be yanked
                   from under us otherwise!).  Fixed chaindib handling so it
                   works properly with multiple NICs (previously it assumed
                   that it was the only dib on the block!)

5/6/98     CP      Added definition of dib.dib_inquire.

                   Restructured SWI handler to be more robust.

22/10/98   CP      Added stats SWI to handler.
                   Changed Inquire word to reflect nature of ATM.

***************************************************************************/

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>

#include <kernel.h>
#include <swis.h>

#include "DebugLib/debuglib.h"

#include "header.h"

#include "headers.h"
#define PROTOTYPES_INTERNAL
#include "module.h"

#include "sys/mbuf.h"
#include "mbuf.h"
//#include "mbuftypes.h"
#include "buffers.h"
#include "sys/types.h"
#include "utils.h"
/*#include "dci4.h"*/
#include "sys/dcistructs.h"
#include "dci_stuff.h"
#include "mast.h"
#include "localarp.h"

#include "atmio.h"
#include "macros.h"
#include "services.h"
#include "panther.h"
#include "atmswis.h"
#include "sockcmds.h"
#include "resources.h"
#include "commands.h"
#include "boson.h"
#include "listen.h"
#include "nvparams.h"
#include "pvc.h"
#include "atm_conf.h"
#include "ipconv.h"
// bit nasty - make nbit_mask.h internal to this source, as nbit_mask routines are in assembler
#define PROTOTYPES_INTERNAL
#include "nbit_mask.h"
#include "error.h"

/* 28/1/97:CP:added prototype */
void _asm_get_msg(unsigned int, unsigned char *, unsigned int);

void atm_changeupstreambandwidth (const char *);



/* 20/1/97:CP:import variable from commands.c */
extern unsigned int bs_buffer_sizeG;

extern int atmcnt;

volatile int callbackflag = 0;
volatile int do_check_happy = 0;
int check_happy_interval = 0;


struct {
    int  e_num;
    char e_mess[32];
} _atm_errblk = { 0 };

void *module_wsp = 0;
unsigned char *irq_buffer;
#define BOSON_FIFO_SIZE 2048


struct dib dib = { 0 };
int nextblock = 0;

/*
 * Module Initialization code.
 */
_kernel_oserror *module_init(const char *cmd_tail, int pbase, void *pw)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    int handle_ret;

    static char var_name[] = "PnP$Podule\0";
    _kernel_oserror a = {0x42424250, "Failed to initialise panther card."};
    // _kernel_oserror b = {0x42424251, "Panther card is unhappy - check hardware."};
    _kernel_oserror c = {0x42424252, "Couldn't allocate buffers."};
    _kernel_oserror d = {0x42424253, "Couldn't allocate ATM call resources."};
    _kernel_oserror f = {0x42424254, "Couldn't claim TickerV resource."};
    _kernel_oserror g = {0x42424255, "Couldn't talk to Plug'n'Play module."};
    _kernel_oserror h = {0x42424256, "Plug'n'Play init has not completed."};
    _kernel_oserror i = {0x42424257, "Plug'n'Play didn't find any compatible cards."};
    _kernel_oserror j = {0x42424258, "Listen on system sockets failed."};
    _kernel_oserror k = {0x42424259, "Insufficient workspace for socket handler."};
    _kernel_oserror l = {0x4242425a, "Bad handle limit passed to socket handler."};

    module_wsp = pw;

    debug_initialise (NULL, NULL, NULL);
    debug_output_device (TML_OUTPUT);

/*     ASSERT(SIZEOF_AS_CONNECT_REQ_PARAMS == sizeof(AS_CONNECT_REQ_PARAMS)); */
/*     ASSERT(SIZEOF_AS_CONNECT_ACK_PARAMS == sizeof(AS_CONNECT_ACK_PARAMS)); */

    DBUG printf("atm25: module init\n");

    if((irq_buffer=(unsigned char *)malloc(sizeof(unsigned char) * BOSON_FIFO_SIZE))==NULL) return(&c);
    if((boson_trail = (unsigned int *)malloc(sizeof(unsigned int) * 2048))==NULL) return(&c);
    if((status_buffer=(unsigned int *)malloc(sizeof(unsigned int) *256))==NULL) return(&c);
    if((handle_wspace=(unsigned int *)malloc(MAX_SOCKET_HANDLE/8+8))==NULL) return(&c);
    boson_next = boson_trail;
    boson_num = 0;

    DBUG printf("atm25: Done mallocs.\n");

    /* we need to know the podule number of the ATM25 card. Plug'n'play has this info,
       and passes it to us using one of 2 mechanisms. On a STB, Plug'n'Play exits immediately
       after it has finished to conserve memory in the RMA. In this case, it sets the
       environment variable PnP$Podule to be the podule number.
       On a RPC, PnP doesn't exit, because this causes a nasty error box. PnP stays alive,
       and _doesn't_ set the PnP$Podule variable. In this case, the atm25driver communicates
       with it using the PnP_RegisterDDI to obtain information about the card.
    */

    /* see if the plug and play module has set PnP$Podule */

    r.r[0] = (unsigned int) &var_name[0];
    r.r[1] = (unsigned int)&podule;
    r.r[2] = 4;
    r.r[3] = 0;
    r.r[4] = 0;
    _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);

    if(r.r[2] == 0) { /* variable didn't exist, try the SWI */
    /* talk to the Plug'n'Play module, to get card status & podule no.  */

      DBUG printf("Failed reading PnP$Podule - trying PnP SWI...");

      if(_kernel_swi(XOS_Bit | PnP_RegisterDDI, &r, &r)!=NULL) return(&g);
      switch(r.r[0]) {
        case -1: return(&h);
        case -2: return(&i);
        default: podule = r.r[0];
      }
      DBUG printf("Read PnP podule number as %d\n", podule);
    }
    else {
      DBUG printf("Read PnP$Podule as %d\n", podule);
    }

    if (nvparams_init (podule))
    {
        return &i;
    }

    if(claim_call_resources() == 0) return(&d); /* set up MAST buffers */

    DBUG printf("Reading NVRAM parameters...\n");

    do_vc  = nvparams_read_multiproto_enc ();
    do_arp = nvparams_read_dynamic_arp ();
    do_pvc = nvparams_read_pvc ();

    DBUG printf("Read NVRAM parameters.\n");

    handle_ret = init_handle_handler(handle_wspace, MAX_SOCKET_HANDLE, MAX_SOCKET_HANDLE/8+8);
    switch(handle_ret) {
      case 0:  DBUG printf("sock_handle handler init OK.\n");
      	       break;
      case -1: return(&k);
      case -2: return(&l);
    }

    init_bs_buffers(DEFAULT_MEMORY_POOL); /* claim some space for MPEG buffers- but it's not initialized yet */

    reset_panther();     /* mask out all the interrupts */

    read_mac_adr();      /* one time call to get the MAC address from the card */

    if(init_panther()<0) return(&a);

    /* 1999-02-01: BAL
     * Temporary hack to disable auto-binding of PVC on intiialisation if
     * CMOS is set.  Should make it coexist better with IPConfig.
     */
#if 0
    if(do_pvc == 0) {
       if(init_listen()<0) return(&j);
       } else {
         pvc_connect_boot();
       }
#else
    if(do_pvc == 0)
    {
       if(init_listen()<0) return(&j);
    }
#endif

/*     if(panther_happy()<0) return(&b); */

/* 30/4/98:CP:Not needed.  Done by cmhg
    atexit(module_final);
*/

    atm_claim_device ((int) atm_irq_entry, (int) module_wsp);
    asm_enable_podule_irqs(podule);
    interrupt_enable();

    if(ticker_period && enable_ticker_handler()<0) return(&f);

    /* Initialize Driver Information Block */

    dib.dib_swibase = ATM_00; /* 28may98:CP:from cmhg.h */
    dib.dib_name = (unsigned char *)"ap";  /* "A"TML "P"anther */
    dib.dib_unit = 0;
    dib.dib_address = macadr;
    dib.dib_module = (unsigned char *)"ATM25stb";
    dib.dib_location = (unsigned char *)"STB expansion slot";
    dib.dib_slot.sl_slotid = 1;
//    dib.dib_inquire = INQ_HWADDRVALID | INQ_POINTOPOINT; /* 5jun98:CP:features of i/f as per DCI4 */
    dib.dib_inquire = INQ_HWADDRVALID | INQ_HASSTATS;

    r.r[0] = (int)"Inet$EtherType";
    r.r[1] = (int)"ap0";
    r.r[2] = 3;
    r.r[3] = 0;
    r.r[4] = 0;
    _kernel_swi(XOS_Bit | OS_SetVarVal, &r, &r);


    if( !managerstarted && mb_present() ) { /* mbuf manager is loaded - initialise entry points */
        if( (e = mb_entryinit()) != NULL )  /* open an mbufman session - register our control block */
            return (e);

         /* OK - set a callback to issue Service_DCIDriverStatus */

        do_start = 1;
        setcallback();
        managerstarted = 1;
    }
    return ((_kernel_oserror *)0);
}

/* Module Finalization code */

_kernel_oserror * module_final(int fatal, int podule, void *pw)
{
    _kernel_swi_regs r;

    interrupt_disable();
    asm_disable_podule_irqs(podule);

    (void)mb_closesession();

    atm_release_device ((int) atm_irq_entry, (int) module_wsp);
    disable_ticker_handler();

    r.r[0] = (int)&dib;
    r.r[1] = Service_DCIDriverStatus;
    r.r[2] = 1;
    r.r[3] = DCIVERSION;
    (void) _kernel_swi(XOS_Bit | OS_ServiceCall,&r, &r);

    free_bs_buffers();
    free_cmd_handle(handle_wspace);

    return NULL;
}


/* Module Service Call handler */


void module_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    struct chaindib *chd = NULL; /* 22/12/97:CP:Corrected to be a ptr, dynamically allocated */

    switch(sn)
    {
        case Service_EnumerateNetworkDrivers:

/*
   22/12/97:CP:changed chd to be a dynamically allocated structure, like wot
               the manual sez

   1/6/98:CP:moved code to here otherwise memory can be yanked from under us!
             Code changed to behave properly with multiple NICs.

*/
           chd = (struct chaindib *) malloc (sizeof (struct chaindib) );

           if (NULL != chd)
           {
              chd->chd_next = NULL;
              chd->chd_dib = &dib;

              if (NULL != r->r[0])
              {
                 ( (struct chaindib *)(r->r[0]) )->chd_next = chd;
              }

              r->r[0] = (int) chd;
           }

           /* 1/6/98:CP:if no memory available, simply ignore the call */

        break;

        case Service_MbufManagerStatus:
            if(!managerstarted) handle_managerstatus(r);
        break;

        /*
         * Service_PreReset - reset card prior to system shutdown
         */
        case Service_PreReset:
            interrupt_disable();
/*             asm_disable_podule_irqs(podule); */
        break;

	/* add pre_reset code to handle stb2 standby state */
        default:
        break;
    }
}


/* Module SWI handler */
_kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
/*
   5jun98:CP:restructured SWI handler to cope with bad SWIs.
             Simplified structure, too.
             Links in with cmhg.h (which is auto-generated from cmhg.header)
*/

    int error = 0;
    _kernel_oserror *oserr = NULL;

    switch (swinum + ATM_00)
    {
       case ATM_DCIVersion:
          error = atm_version (r);
       break;

       case ATM_Inquire:
          error = atm_inquire(r);
       break;

       case ATM_GetNetworkMTU:
          error = atm_getmtu(r);
       break;

       case ATM_SetNetworkMTU:
          error = atm_setmtu(r);
       break;

       case ATM_Transmit:
/*
HEAVYWEIGHT DEBUGGING ON TRANSMIT
         printf("atm_transmit:");

         switch(r->r[2])
         {
           case MESSAGE_TYPE_IP:
             printf("IP\n");
           break;

           case MESSAGE_TYPE_ARP:
             printf("ARP\n");
           break;

           case MESSAGE_TYPE_REVARP:
             printf("REVARP\n");
           break;

           default:
             printf("UNKNOWN\n");
           break;
         }

         {
           char *tmp = (char *)r->r[4];
         printf("Destination %d.%d.%d.%d.%d.%d\n", tmp[0], tmp[1],tmp[2],tmp[3],tmp[4],tmp[5]);
         printf("Destination %x.%x.%x.%x.%x.%x\n", tmp[0], tmp[1],tmp[2],tmp[3],tmp[4],tmp[5]);
         }
*/
          error = atm_transmit(r);
       break;

       case ATM_Filter:
          error = atm_filter(r);
       break;

       case ATM_Stats:
          atm_stats(r);
       break;

       case ATM_EmptyBuffer:
          error = atm_empty_buf(r);
       break;

       case ATM_DoNothing:
          error = atm_nullswi(r); /* was atm_txstream */
       break;

       case ATM_EndOfPlay:
          error = atm_endofplay(r);
       break;

       case ATM_StartOfPlay:
          error = atm_startofplay(r);
       break;

       case ATM_ReadMacAddr:
          error = atm_readmacadr(r);
       break;

       case ATM_OpenConn:
          error = atm_openconn(r);
       break;

       case ATM_ClearConn:
          error = atm_clearconn(r);
       break;

       case ATM_SetMacAdr:
          error = atm_setmacadr(r);
       break;

       case ATM_SetBufs:
          error = atm_setbufs(r);
       break;

       case ATM_GetStats:
          error = atm_getstats(r);
       break;

       case ATM_TxFrame:
          error = atm_txframe(r);
       break;

       /* Temporary grotty hack-in so other people can start using the API */
       case ATM_BootConfig:
            error = atm_bootconfig (r);
            if (error)
            {
                oserr = error_table[error - 1];
                error = 0;
            }
            break;

       default:
          oserr = error_BAD_SWI;
       break;
    }

    if ( 0 != error )
    {
       oserr = atm_error (error);
    }


    return oserr;
}




/* -----------------------------------------------------------------------------
   str_ctrl_dup

   Create a 0 terminated duplicate of a control character terminated string.
   Client is responsible for freeing memory.

   Inputs
   s: pointer to string to duplicate

   Returns
   success: pointer to duplicated string
   failure: NULL
 */

static char *str_ctrl_dup (const char *const s)
{
    size_t len = 0;
    const char *c = s;
    char *p;

    while (!iscntrl (*c))
    {
        ++c;
        ++len;
    }

    p = malloc (len + 1);
    if (p)
    {
        memcpy (p, s, len);
        p[len] = 0;
    }

    return p;
}




_kernel_oserror *atm_cli_handler(const char *arg_string, int arg_count, int cmd_no, void *pw)
{
  char *  writeable_arg_string = str_ctrl_dup (arg_string);

  if (!writeable_arg_string)
  {
      puts ("Out of memory");
      return NULL;
  }

  printf ("%d %p\n%s\n", arg_count, arg_string, writeable_arg_string);

  switch(cmd_no) {

    case 0:   atm_info();
    	      break;

    case 1:   atm_mast_show();
    	      break;

    case 2:   atm_boson();
    	      break;

    case 3:   atm_pibs();
    	      break;

    case 4:   atm_trail();
    	      break;

    case 5:   atm_cci(writeable_arg_string);
    	      break;

    case 6:   atm_listen();
    	      break;

    case 7:   atm_status();
    	      break;

    case 8:   atm_buffers();
    	      break;

    case 9:   atm_pvc(writeable_arg_string);
    	      break;

    case 10:  atm_pvcdelete(writeable_arg_string);
    	      break;

    case 11:  atm_conf_arp(writeable_arg_string);
    	      break;

    case 12:  atm_conf_llc(writeable_arg_string);
    	      break;

    case 13:  atm_conf_vc(writeable_arg_string);
    	      break;

    case 14:  atm_conf_pvc(writeable_arg_string);
    	      break;

    case 15:  atm_mast_data();
    	      break;

    /* 21/1/97:CP:Added new command */
    case 16:  atm_changebufferpool(writeable_arg_string);
    	      break;

    /* 6/2/97:CP:Added new command */
    case 17:  atm_changeupstreambandwidth(writeable_arg_string);
              break;

  }

  free (writeable_arg_string);

  return((_kernel_oserror *)(NULL));


}

_kernel_oserror *atm_error(int error)
{
    if (error)
    {
        _atm_errblk.e_num = error;
        strncpy(_atm_errblk.e_mess, "ATM25 module error", 30);
        return ((_kernel_oserror *)&_atm_errblk);
    }

    return ((_kernel_oserror *)0);
}


void setcallback(void)
{
    if (callbackflag == 0) {
        callbackflag = 1;
        if (callback((int (*)(void)) callb_entry) != 0)
            callbackflag = 0;
    }
}

int callback(int (* func)(void))
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    return (_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
}

_kernel_oserror * callb_handler(_kernel_swi_regs *rr, void *pw)
{
  struct mast *m;
  static char echo_msg[] = "OK\n";
  _kernel_swi_regs r;

    if (callbackflag == 0)
    {
        return (NULL);
    }

    callbs++;
    callbackflag = 0;

    if (do_start) {  /* DCI Start-up callback from module init code */
        callb_startups++;

        do_start = 0;
        r.r[0] = (int)&dib;
        r.r[1] = Service_DCIDriverStatus;
        r.r[2] = 0;
        r.r[3] = DCIVERSION;
        (void) _kernel_swi(XOS_Bit | OS_ServiceCall,&r, &r);
    }

    if (tear_down)
    {
       tear_down = 0;
       callb_teardowns++;
#ifdef DEBUG
       printf("callb_handler: purging MAST entry.\n");
#endif

       for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)
       {
          if (!(m->m_status & M_PURGE))
          {
             clear_masttab(m);
          }
       }
    }

    if(echo_ack)
    {
      echo_ack = 0;
      callb_echos++;
      asm_write_fifo(ip_echo, AS_DATA_END, (unsigned char *)echo_msg, 3,BlockToARMAddr);
    }


    if (do_local_arp)
    {
       callb_arps++;
       do_local_arp = 0;
       local_arp();
    }

    send_buffers();
    return (NULL);
}

/* this routine sits on tickerV (OS_CallEvery) and clears any unused MAST connections */
_kernel_oserror *ticker_handler(_kernel_swi_regs *r, void *pw)
{
  struct mast *m;

  ticker_tally++;

    for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++) {
        if (m->m_status & M_USED) m->m_status = m->m_status & ~M_USED; /* if active, mark inactive */
        else if(m->m_socket_handle) {  /* if inactive, disconnect and clear table entry */
          BlockWrite(CMD_MSG(m->m_socket_handle, AS_CLOSE, 0));
          clear_masttab(m);
        }

    }
    return (NULL);
}

/* this routine sets it up */
int enable_ticker_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = ticker_period;
  r.r[1] = (int)ticker_entry;
  r.r[2] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_CallEvery, &r, &r) != 0 ? -1 : 0);

}

/* this routine shuts it down */
int disable_ticker_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = (int)ticker_entry;
  r.r[1] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_RemoveTickerEvent, &r, &r) != 0 ? -1 : 0);
}


/******* asm_get_msg *******************************************************

Purpose: veneer for _atm_get_message to trap stupid calls to it.

	 If all the parameters validate OK, then call the assembler routine.
         If not, then print an error message.

Inputs: unsigned int EASI space to get data from
	unsigned char * buffer to put data into
	unsigned int bytes to read

	(not my choice of parameters....)

Outputs:  none

***************************************************************************/

void asm_get_msg(unsigned int ReadFrom, unsigned char *ReadTo, unsigned int NumBytes)
{
  if((ReadFrom != (unsigned int)NULL) && (ReadTo != NULL) && (NumBytes != 0))
  {
    _asm_get_msg(ReadFrom, ReadTo, NumBytes);
  }

  else
  {
    if(ReadFrom == (unsigned int)NULL)
    {
      printf("asm_get_msg: Address to read data from is invalid (NULL)\n");
    }

    if(ReadTo == NULL)
    {
      printf("asm_get_msg: Address to read data to is invalid (NULL)\n");
    }

#ifndef NDEBUG
/* won't blow up if passed 0 bytes */
    if(NumBytes == 0)
    {
      printf("asm_get_msg: Number of bytes to read is 0\n");
    }
#endif
  }
}


/* Ant's funky new irq_handler */

/* heavy duty IRQ debugging.... :-)  */
/*  26mar98:CP:QDF - removed to suppress debug message; if the params are broken, just don't call it.
#define ASM_GET_MSG(x, y, z) if ((x == 0) || (y == NULL) || (z == 0)) printf("\t\tmodule.c:%s, %u\n", __FILE__, __LINE__); else asm_get_msg(x, y, z)
*/
#define ASM_GET_MSG(x, y, z) if ((x == 0) || (y == NULL) || (z == 0)) {} else asm_get_msg(x, y, z)


_kernel_oserror * atm_irq_handler(_kernel_swi_regs *r, void *pw)
{
	unsigned int msg_handle = 0;
	unsigned int msg_cmd = 0;
	unsigned int msg_type = 0;
	unsigned int exists;

	struct mast *m = NULL;
	struct listen *l = NULL;
	struct bs_buffer *bs = NULL;

	unsigned char msnl[6];
	unsigned int connect_ack_buffer[3];

	int ftype;
	char *rb;

	// AS_CONNECT_ACK_PARAMS *connect_ack;
	// AS_CONNECT_REQ_PARAMS *connect_req;

	unsigned int is_mpeg;
	unsigned char *cp;

	unsigned int temp, tempE;
	unsigned int packet_bytes, total_bytes, bytes_left;
	unsigned int service_type;

	unsigned int tempE_attempts;


/* 	_kernel_irqs_off(); */
	/* the dispatch order in this irq handler may look funny, but it's been carefully
	   optimized so that the quickest commands are processed first. */

	while(Boson_RX_Block) {/* IRQ triggered on RxBlock */
		boson_rx_pkts++;

		temp = r_Boson_BlockFromARM; /* get msg header */
		msg_type = (temp & CMD_MESSAGE)?1:0;
		msg_handle = temp & DATA_HANDLE;
		msg_cmd = ((temp & DATA_CMD) >> DATA_CMD_SHIFT);

		if(!msg_type) { /* is it a DATA message? */
			if ((temp & DATA_EXTEND) && (temp & DATA_FIRST)){
			      for(tempE_attempts=0;tempE_attempts<8;tempE_attempts++) {
				tempE = r_Boson_CommitFromARM; /* read extension word */
			        if((tempE & 0xffff) == 0x0) break; /* if it's a valid word, break out */
			      }

			      if(tempE_attempts == 8) continue; /* abort */
		              total_bytes = (int)((tempE & 0xffff0000) >> 16);


			} /* endif data extend */
			packet_bytes = (temp >> 21) & 0x7ff;
			irq_packets = packet_bytes;
			boson_msg_pkts++;
			if(packet_bytes > irq_pkt_hiwm) irq_pkt_hiwm = packet_bytes;
		}
		else {
		  packet_bytes = 0;
		  boson_cmd_pkts++;
		}
#ifdef DEBUG_TRAIL
       *boson_next++ = temp;
       if(temp & DATA_EXTEND) *boson_next++ = tempE;
       else *boson_next++ = 0x0;
       boson_num++;
       if(boson_next >= (boson_trail + 2048)) boson_next = boson_trail;
#endif

		if((msg_cmd == AS_ERROR) && msg_type) { /* some sort of error */
			irq_errors++;
			continue;
		}

		else if((msg_cmd == AS_CONNECT) && !msg_type) { /* It's a connection request */
#if 0 // old ddi interface
			if(packet_bytes != SIZEOF_AS_CONNECT_REQ_PARAMS) {
				irq_con_req_errors++;
#ifdef PACKET_JUNKING
/* 				asm_junk_msg(CommitFromARMAddr, packet_bytes); */
				ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
				continue;
			}
#endif

			ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
//			connect_req = (AS_CONNECT_REQ_PARAMS *)irq_buffer;

			if(ipstouc((unsigned char *)(irq_buffer+8), &msnl[2], 4) != 4) {
			  irq_con_req_errors++;
			  continue;
			}

//			msnl = uitoch(connect_req->address.sockaddr.address.msnl.satm_msnl);

			if((l = locate_listen(msg_handle))==NULL) { /* we have no listen record for this handle */
			   *connect_ack_buffer = 1; /* status code: reject */
			   *(connect_ack_buffer+1) = 0; /* no send QoS params */
			   *(connect_ack_buffer+2) = 0; /* no recv QoS params */
			   asm_write_fifo(msg_handle, AS_CONNECT_ACK, (unsigned char *)connect_ack_buffer, 12, BlockToARMAddr);
//			   w_Boson_BlockToARM(CMD_MSG(msg_handle, AS_LISTEN_ACK, 1)); /* refuse connection */
			   irq_con_refusals++;
			   continue;
			}

			m = mast_add(&msnl[2], ipstoui((unsigned char *)irq_buffer+40),
					0, &exists, (M_SWITCHED | M_PENDING), msg_handle);

			if(m) { /* a connection table entry was returned */
				if(exists) { /* but it was already active */
					w_Boson_BlockToARM(CMD_MSG(m->m_socket_handle, AS_CLOSE, 0)); /* close orig. socket */
					w_Boson_BlockToARM(CMD_MSG(CMD_HANDLE, SO_DETACH, m->m_socket_handle)); /* detach handle */
					clear_masttab(m); /* get rid of connection info */
					// w_Boson_BlockToARM(CMD_MSG(msg_handle, AS_LISTEN_ACK, 1)); /* refuse connection */
			   		*connect_ack_buffer = 1; /* status code: reject */
			   		*(connect_ack_buffer+1) = 0; /* no send QoS params */
			   		*(connect_ack_buffer+2) = 0; /* no recv QoS params */
			   		asm_write_fifo(msg_handle, AS_CONNECT_ACK, (unsigned char *)connect_ack_buffer, 12, BlockToARMAddr);

					irq_con_refusals++;
				} else { /* no prior convictions */
			                *connect_ack_buffer = 0; /* status code: accept */
			   		*(connect_ack_buffer+1) = 0; /* no send QoS params */
			   		*(connect_ack_buffer+2) = 0; /* no recv QoS params */
			   		asm_write_fifo(msg_handle, AS_CONNECT_ACK, (unsigned char *)connect_ack_buffer, 12, BlockToARMAddr);

					// w_Boson_BlockToARM(CMD_MSG(msg_handle, AS_LISTEN_ACK, 0)); /* accept connection */
					m->m_local_port = l->local_port; /* record our local port number */
					m->m_muxtype = l->muxtype; /* record our mux type for ip encapsulation */
					m->m_status = (m->m_status | M_CONNECT | M_SWITCHED) & ~M_PENDING; /* validate */
					irq_connect_reqs++;
					init_call_resources(m);

					if(l->flags & L_REANIMATE) reanimate_listen(l); /* immortal listen? */
					else {
					  l->handle = 0; /* if not, clear listentab entry */
					  l->local_port = 0;
					}
				}
			} else {
			        *connect_ack_buffer = 1; /* status code: reject */
			   	*(connect_ack_buffer+1) = 0; /* no send QoS params */
			   	*(connect_ack_buffer+2) = 0; /* no recv QoS params */
			   	asm_write_fifo(msg_handle, AS_CONNECT_ACK, (unsigned char *)connect_ack_buffer, 12, BlockToARMAddr);

				// w_Boson_BlockToARM(CMD_MSG(msg_handle, AS_LISTEN_ACK, 1)); /* refuse connection */
				irq_con_refusals++;
			}

			continue;
		}


		/* all other cmd types require connection resources */

		if(msg_handle == last_msg_handle) m = last_m;  /* do the contiguous-blocks speed up  */

		else {
		  last_msg_handle = 0xffffffff;
                  last_m = (struct mast *)NULL;

                  for (m = &masttab[0]; ((m < &masttab[MASTTAB_SIZE]) && (last_m == (struct mast *)NULL)); m++) /* else do it the hard way */
                  /* Ant! Don't check m->m_status here! You've already tried it, and it doesn't work
                     because incoming connectacks get dropped.
                  */
                  /* But we _do_ check status, to make sure we're matching an actual connection of some sort,
                     not just a blank MASTtab entry.
                  */

                    if((m->m_socket_handle == msg_handle) && (m->m_status & (M_SWITCHED | M_PERMANENT))) {
                        last_m = m; /* stash mast entry for next time */
                        last_msg_handle = msg_handle; /* and associate handle */
        		m->m_status |= M_USED; /* keep mast connection alive */
                        break;
                    }

		}

		if(m==NULL) { /* it's bogus */
			irq_mast_errors++;

			/* the NIC software has a habit of sending data on unconnected sockets - check to see
			   if we're listening on this socket handle, and if so, junk the packet
		        */

			if(locate_listen(msg_handle)!=NULL) {
#ifdef PACKET_JUNKING
/*        			   asm_junk_msg(CommitFromARMAddr, packet_bytes); */
				   ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
			}
			continue;
		}

		if(m->m_originator) service_type = m->m_port;
		else service_type = m->m_local_port;

		if (!msg_type &&
		    (msg_cmd == AS_DATA ||
		     msg_cmd == AS_DATA_END ||
		     msg_cmd == AS_DATA_LENGTH ||
		     msg_cmd == AS_DATA_ABORT))
		{

		  	if(!(m->m_status & M_CONNECT)) { /* no data on unconnected socket, thank you */
#ifdef PACKET_JUNKING
/* 		  	  asm_junk_msg(CommitFromARMAddr, packet_bytes); */
			  ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
		  	  irq_mast_errors++;
		  	  continue;
		  	}

			is_mpeg = 0;
			if(msg_cmd == AS_DATA)
			{
				irq_datas++;
			}
			else
			{
				irq_data_ends++;
			}

			/* 1999-03-04: BAL */
			if (msg_cmd == AS_DATA_LENGTH)
			{
				if (packet_bytes == sizeof (U32))
				{
					ASM_GET_MSG (CommitFromARMAddr, (unsigned char *) &m->m_offset, sizeof (U32));
				}
				else
				{
					/* larger than expected message - read, but ignore */
					ASM_GET_MSG (CommitFromARMAddr, irq_buffer, packet_bytes);
				}
			}
			else if (msg_cmd == AS_DATA_ABORT)
			{
#ifdef PACKET_JUNKING
				ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
				if (service_type == M_MPEG_AAL5)
				{
					bs->bs_len = m->m_offset;
					m->m_offset = 0;
					/* bs->bs_handle = m->m_streamhandle; */
					bs->bs_handle = streamhandle;
					save_full_buf(bs, 0);
					m->m_rbuf = (char *)get_empty_buffer();
					mpeg_discards2++;
					continue;
				}

				if (service_type == M_IP || service_type == M_LLC)
				{
					irq_rx_discards++;
					m->m_offset = 0;
					continue;
				}
			}
			else	/* actually have data (AS_DATA or AS_DATA_END) */
			{
				if(service_type == M_MPEG_AAL5)
				{ /* it's video data */
					is_mpeg = 1;
					if(m->m_rbuf == NULL)
					{ /* got no buffer! */
						mpeg_discards1++;
#ifdef PACKET_JUNKING
						/* asm_junk_msg(CommitFromARMAddr, packet_bytes); */
						ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
						m->m_rbuf = (char *)get_empty_buffer();
						continue;
					}

					bytes_left = bs_buffer_sizeG - m->m_offset;
					bs = (struct bs_buffer *)m->m_rbuf;
					if(packet_bytes > bytes_left)
					{
						bs->bs_len = m->m_offset;
						m->m_offset = 0;
						/* bs->bs_handle = m->m_streamhandle; */
						bs->bs_handle = streamhandle;
						save_full_buf(bs, 0);
						m->m_rbuf = (char *)get_empty_buffer();
						mpeg_discards2++;
#ifdef PACKET_JUNKING
						/* asm_junk_msg(CommitFromARMAddr, packet_bytes); */
						ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
						continue;
					}

					/* 28/1/97:CP:bs->bs_data is no longer an array, so need to explicitly define address */
					cp = (unsigned char *)&bs->bs_data;
				} /* endof MPEG AAL5 */

				if((service_type == M_IP) || (service_type == M_LLC))
				{ /* IP data */
					bytes_left = ATM_MTU - m->m_offset;
					cp = (unsigned char *)m->m_rbuf;

					if(packet_bytes > bytes_left) {
						irq_rx_discards++;
						m->m_offset = 0;
#ifdef PACKET_JUNKING
 						/* asm_junk_msg(CommitFromARMAddr, packet_bytes); */
						ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
						continue;
					}
				} /* endof IP data */


				cp += m->m_offset;
				ASM_GET_MSG(CommitFromARMAddr, cp, packet_bytes);
				m->m_offset += packet_bytes;
				m->m_datacount += packet_bytes;
			}

			if ((msg_cmd == AS_DATA_END || msg_cmd == AS_DATA_LENGTH) &&
			    (temp & DATA_LAST))
			{ /* end of frame */
				if(is_mpeg)
				{
					mpeg_rx++;
					bs->bs_len = m->m_offset;
					/* bs->bs_handle = m->m_streamhandle; */
					bs->bs_handle = streamhandle;
					save_full_buf(bs, 0);
					m->m_offset = 0;
					m->m_rbuf = (char *)get_empty_buffer();
				}

				else if(service_type == M_LLC)
				{
					ip_rx++;
					rb = m->m_rbuf;
					ftype = (rb[6] << 8) | rb[7]; /* determine frame type from LLC_SNAP header */

					/* pass IP packet (ie. AAL5 payload less LLC header) up to protocol */
					if(rx_dci(rb+LLC_HDR_SIZE, m->m_offset-LLC_HDR_SIZE, ftype)==0)
					{
						irq_ip_pkts_dropped++;
						m->m_datalost += (m->m_offset-LLC_HDR_SIZE);
					}

					m->m_offset = 0;
					/* m->m_datacount = 0; */
				}

				else if(service_type == M_IP)
				{ /* CP:This is now redundant; vc encapsulation */
					ip_rx++;
					rb = m->m_rbuf;
					if(rx_dci(rb, m->m_offset, FRAME_TYPE_IP)==0) {
					  irq_ip_pkts_dropped++;
					  m->m_datalost += m->m_offset;
					}
					m->m_offset = 0;
					/* m->m_datacount = 0; */
				}
			}



			continue;
		} /* end of data commands */

		else if((msg_cmd == AS_CLOSE) && !msg_type) { /* has changed to DATA command in latest ddi spec! */
			/* w_Boson_BlockToARM(CMD_MSG(msg_handle, AS_CLOSED, 0)); ddi spec. has dropped this requirement */
			ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes); /* and added this one */
                        w_Boson_BlockToARM(CMD_MSG(CMD_HANDLE, SO_DETACH, msg_handle));
                        free_handle(handle_wspace, (int)msg_handle); /* free the socket handle */
                        clear_call_resources(m);
			clear_masttab(m);
			irq_closes++;
			continue;
		}

		else if((msg_cmd == AS_CLOSE_ACK) && !msg_type) { /* msg was AS_CLOSED - now DATA based in latest ddi spec */
			ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes); /* get new param word */
			irq_closeds++;
			// clear_masttab(m);  /* shouldn't need to do anything on a close ack */
			continue;
		}

		else if((msg_cmd == AS_CONNECT_ACK) && !msg_type) {
#if 0	/* can't do this sort of thing any more! */
			if(packet_bytes != SIZEOF_AS_CONNECT_ACK_PARAMS) {
				irq_con_ack_errors++;
#ifdef PACKET_JUNKING
/* 				asm_junk_msg(CommitFromARMAddr, packet_bytes); */
				ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
#endif
				continue;
			}
#endif
			ASM_GET_MSG(CommitFromARMAddr, irq_buffer, packet_bytes);
			// connect_ack = (AS_CONNECT_ACK_PARAMS *)irq_buffer;
			if(m->m_originator) { /* is this an ACK for one of our CONNECT_REQs ?? */
        			if(*((S32 *)irq_buffer) != 0) { /* connection was refused */
        				irq_refusals++;
        				w_Boson_BlockToARM(CMD_MSG(msg_handle, AS_CLOSE, 0));
        				w_Boson_BlockToARM(CMD_MSG(CMD_HANDLE, SO_DETACH, msg_handle));
        				free_handle(handle_wspace, (int)msg_handle); /* free socket handle */
        				clear_masttab(m);
        			}
        			else {
        			  m->m_status = (m->m_status | M_CONNECT | M_SWITCHED) & ~M_PENDING; /* validate */
                                  irq_connects++;
                                }
        			continue;
                        } else  /* or is it the pointless new CONNECT_ACK after we've just sent a successful CONNECT_ACK ? */
                               irq_con_req_acks++;

		}




		/* if we've got here, then the command hasn't been recognized
		   we don't purge the FIFO - because if the cmd was bogus, presumably so too was the byte count
		   and reading more bytes than are in the FIFO makes it churn out megabytes of garbage, & it takes
		   ages to settle down. Far better to read <2048 bogus commands and drop them!  */
		/* If we've got here, then we've got an unrecognized command on a valid msg handle and MAST
		   entry. Bad news. Consider doing a FIFO buffer recover.
		*/
        	   else
                   {
                       irq_bogus_pkts++;
                       asm_buffer_recover(CommitFromARMAddr);
                       irq_buffer_recovers++;
                   }
	} /* endof FIFO RX Block loop */


	  if(bs_full_q && bswait_supply(bs_full_q)) { /* does MPEG system need feeding? */
	    bs_full_q = NULL;
	    bs_fullp = NULL;
	    setcallback();
	  }


#ifdef FIFO_RECOVER

	if(Boson_RX_NotEmpty) {
	  asm_buffer_recover(CommitFromARMAddr);
	  irq_buffer_recovers++;
	}

#endif

/* 	_kernel_irqs_on(); */

	return(NULL);

} /* end of irq handler */

