/* File:    arp.h
   Purpose: Interface to ARP / ATMARP handling
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1998-06-05: CP
   Header added
   Converted to use Acorn's DCI headers

   1999-04-22: BAL
   Changed header for consistency with other files
   Added ATMARP capability
 */




// =============================================================================
// Include header files

// CLib
#include "kernel.h"
#include <string.h>
#include "swis.h"

// TCPIPLibs
extern "C"
{
    #include "sys/types.h"
    #include "inetlib.h"
    #include "netinet/in.h"
    #include "net/if.h"
    #include "net/if_arp.h"
    #include "netinet/if_ether.h"
    #include "sys/dcistructs.h"
    #include "sys/socket.h"
    #include "sys/sockio.h"
    #include "socklib.h"
}

// Misc
#include "DebugLib/debuglib.h"

// Local
#include "address.h"
#include "arp.h"
#include "dci.h"
#include "defs.h"
#include "ip.h"
#include "nic.h"
#include "utils.h"




// =============================================================================
// Constants

enum
{
    ATMARP_Request   = 1,
    ATMARP_Reply     = 2,
    InATMARP_Request = 8,
    InATMARP_Reply   = 9,
    ATMARP_NAK       = 10
};




// =============================================================================
// Macros

// Access type in ATMARP type & length field
#define M_TL_Type(x) (((x) & 0x40) >> 6)

// Access length in ATMARP type & length field
#define M_TL_Length(x) ((x) & 0x3f)




// =============================================================================
// Type definitions

typedef struct ATMARP_header
{
    u_short  ar_hrd;
    u_short  ar_pro;
    u_char   ar_shtl;
    u_char   ar_sstl;
    u_short  ar_op;
    u_char   ar_spln;
    u_char   ar_thtl;
    u_char   ar_tstl;
    u_char   ar_tpln;
};

typedef struct ATMARP
{
    ATMARP_header    header;
    unsigned char *  data;

    IPConnection *   connection;

    // The data field are variable length, so store pointers to them for easy
    // access
    unsigned char *  sha;
    unsigned char *  ssa;
    unsigned char *  spa;
    unsigned char *  tha;
    unsigned char *  tsa;
    unsigned char *  tpa;
};




// =============================================================================
// Global variable declarations

struct mbuf *  arpbuf;
ATMARP atmarp;




// =============================================================================
// Function prototype declarations

static void  set_vardata_ptr (unsigned char *&  ptr,
                              unsigned char *&  base,
                              const size_t      size);

static void  write_vardata (unsigned char *&  dest,
                            void *            src,
                            const size_t      size);

//static void  inatmarp_request (ATMARP *  request);

static void  inatmarp_reply (ATMARP *  request);

static const struct sockaddr *  get_if_addr ();




// =============================================================================
// Function definitions

void local_arp ()
{
    struct ether_arp *  ea;

    PULLUP (arpbuf, sizeof (struct ether_arp));
    ea = mtod (arpbuf, struct ether_arp *);
    u_short  op = ntohs (ea->arp_op);

    if (ntohs (ea->arp_op) == ARPOP_REQUEST)
    {
        #ifdef DEBUGLIB
        char  spa[16];
        char  tpa[16];
        char  sha[18];
        char  tha[18];

        num_to_sep_str (ea->arp_spa, 4, spa, '.');
        num_to_sep_str (ea->arp_tpa, 4, tpa, '.');

        num_to_sep_str (ea->arp_sha, MACAddr_Size, sha, ':');
        num_to_sep_str (ea->arp_tha, MACAddr_Size, tha, ':');

        dprintf (("", "spa=%s, sha=%s\ntpa=%s, tha=%s\n", spa, sha, tpa, tha));
        #endif

        // Don't handle ARP requests for our own address
        if (memcmp (ea->arp_spa, ea->arp_tpa, 4) != 0)
        {
            u_long                 ip_addr;
            const unsigned char *  mac_addr;

            memcpy (&ip_addr, ea->arp_tpa, 4);
            mac_addr = ip_map_mac_from_ip (ip_addr);
            if (mac_addr)
            {
                dprintf (("", "found IP<->MAC mapping\n"));

                // Construct 'fake' ARP REPLY
                memcpy (ea->arp_spa, ea->arp_tpa, 4);
                memcpy (ea->arp_sha, mac_addr, MACAddr_Size);
                ea->arp_op = htons (ARPOP_REPLY);

                // Send the ARP REPLY back up the stack
                dci_receive (0, arpbuf, ETHERTYPE_ARP);
            }
        }
    }
}




void  arp_rx_atmarp (IPConnection *   connection,
                     struct mbuf *    m)
{
    //ATMARP  atmarp;
    if (do_atmarp)
    {
        return;
    }

    PULLUP (m, mbctl.count_bytes (&mbctl, m));
    unsigned char *  data = mtod (m, unsigned char *);

    memcpy (&atmarp.header, data, sizeof (ATMARP_header));

    // If protocol isn't IP then give up straight away
    if (ntohs (atmarp.header.ar_pro) != ETHERTYPE_IP)
    {
        return;
    }
    data += sizeof (ATMARP_header);
    atmarp.data = data;

    atmarp.connection = connection;

    set_vardata_ptr (atmarp.sha, data, M_TL_Length (atmarp.header.ar_shtl));
    set_vardata_ptr (atmarp.ssa, data, M_TL_Length (atmarp.header.ar_sstl));
    set_vardata_ptr (atmarp.spa, data, atmarp.header.ar_spln);
    set_vardata_ptr (atmarp.tha, data, M_TL_Length (atmarp.header.ar_thtl));
    set_vardata_ptr (atmarp.tsa, data, M_TL_Length (atmarp.header.ar_tstl));
    set_vardata_ptr (atmarp.tpa, data, atmarp.header.ar_tpln);

    switch (ntohs (atmarp.header.ar_op))
    {
        case ATMARP_Request:
            break;

        case ATMARP_Reply:
            break;

        case InATMARP_Request:
            //inatmarp_request (&atmarp);
            do_atmarp = 1;
            setcallback ();
            break;

        case InATMARP_Reply:
            break;

        case ATMARP_NAK:
            break;

        default:
            break;
    }
    m_freem (m);
}




int  get_if_addr (struct sockaddr *  if_addr)
{
    int                      s;
    struct ifreq             ifr;

    // assume only one unit for now
    s = socket (PF_INET, SOCK_DGRAM, 0);
    if (s >= 0)
    {
        (void) strncpy (ifr.ifr_name, "ap0", sizeof (ifr.ifr_name));
        if (socketioctl (s, SIOCGIFADDR, &ifr) >= 0)
        {
            memcpy (if_addr, &ifr.ifr_addr, ifr.ifr_addr.sa_len);
        }

        (void) socketclose (s);
        return 0;
    }

    return  1;
}




void  set_vardata_ptr (unsigned char *&  ptr,
                       unsigned char *&  base,
                       const size_t      size)
{
    if (size > 0)
    {
        ptr = base;
        base += size;
    }
    else
    {
        ptr = 0;
    }
}



void  write_vardata (unsigned char *&  dest,
                     void *            src,
                     const size_t      size)
{
    if (size > 0)
    {
        memcpy (dest, src, size);
        dest += size;
    }
}





void  inatmarp_request (void)
{
    if (memcmp (atmarp.tha,
                NIC::Instance()->GetUNIAddr(),
                M_TL_Length (atmarp.header.ar_thtl)) == 0)
    {
        inatmarp_reply (&atmarp);
    }
}




void  inatmarp_reply (ATMARP *  request)
{
    size_t              reply_size = sizeof (ATMARP_header);
    struct sockaddr_in  spa;

    if (get_if_addr ((struct sockaddr *) &spa) || spa.sin_family != PF_INET)
    {
        dprintf (("", "rejecting PF %d\n", spa.sin_family));
        return;
    }
    dprintf (("", "spa %s\n", inet_ntoa (spa.sin_addr)));

    size_t  shl = M_TL_Length (request->header.ar_shtl);
    size_t  ssl = M_TL_Length (request->header.ar_sstl);
    size_t  thl = M_TL_Length (request->header.ar_thtl);
    size_t  tsl = M_TL_Length (request->header.ar_tstl);

    reply_size += shl;
    reply_size += ssl;
    reply_size += request->header.ar_spln;
    reply_size += thl;
    reply_size += tsl;
    reply_size += sizeof (struct in_addr);

    struct mbuf *  m = ALLOC_S (reply_size, NULL);
    if (!m)
    {
        return;
    }

    ATMARP_header *  reply = mtod (m, ATMARP_header *);
    memcpy (reply, &request->header, sizeof (ATMARP_header));
    reply->ar_op = htons (InATMARP_Reply);

    unsigned char *  reply_data = (unsigned char *) (reply + 1);

    write_vardata (reply_data, request->tha, thl);
    write_vardata (reply_data, request->tsa, tsl);
    write_vardata (reply_data, (void *) &spa.sin_addr, sizeof (struct in_addr));
    write_vardata (reply_data, request->sha, shl);
    write_vardata (reply_data, request->ssa, ssl);
    write_vardata (reply_data, request->spa, request->header.ar_spln);

    request->connection->TxMBufChain (ETHERTYPE_ARP, m, true);
}
