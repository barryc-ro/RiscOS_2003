/* File:    connection.c++
   Purpose: Connection superclass
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-03-20: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include "kernel.h"
#include <stdio.h>
#include "swis.h"

// TCPIPLibs
extern "C"
{
    #include "inetlib.h"
}

// Misc
#include "DebugLib/debuglib.h"

// Local
#include "connection.h"
#include "defs.h"
#include "ip.h"
#include "mpeg.h"
#include "socket.h"




// =============================================================================
// Static attribute definitions

Connection::ConnectionListItem *  Connection::connection_list = 0;




// =============================================================================
// Function prototype declarations

extern "C" void  asm_status_changed ();




// =============================================================================
// Member function definitions

/* -----------------------------------------------------------------------------
 */

Connection::Connection (const ATML_SOCKADDR *const  atm_addr,
                        const Service               service,
                        const Origin                origin,
                        int &                       error)
    : usage (0),
      service (service),
      origin (origin),
      client_list (0),
      immortal_listen (false),
      error (0)
{
    error = 0;
    vc = VC::Create (atm_addr, this, error);
    if (vc)
    {
        if (!error)
        {
            ConnectionListItem *  item = new ConnectionListItem ();
            if (item)
            {
                item->connection = this;
                item->next = connection_list;
                connection_list = item;
            }
            //socket = vc->GetSocket ();
            // Add ourselves to the list of known connections
            //known_connections[next_free++] = this;
        }
    }
    else
    {
        error = Error_ATM_NoMemory;
    }
}




Connection::~Connection ()
{
    // Remove ourselves from the list of known connections
    ConnectionListItem **  item_ptr = &connection_list;

    while (*item_ptr && (*item_ptr)->connection != this)
    {
        item_ptr = &(*item_ptr)->next;
    }

    if (*item_ptr)
    {
        ConnectionListItem *  item = *item_ptr;
        *item_ptr = item->next;
        delete item;
    }
    //known_connections[socket->GetHandle()] = 0;

    delete vc;
}




int  Connection::AddClient (ClientConnection *  client)
{
    int  error = 0;
    ClientListItem *  item = new ClientListItem ();
    if (item)
    {
        item->client = client;
        item->next = client_list;
        client_list = item;

        if (usage++ == 0)
        {
            //socket->Attach ();
        }
        else
        {
            // If this is not the first client of the connection then the
            // connection may well already be in the 'connected' state, so
            // force a call to the client to notify it of this.
            client->Notify (vc->GetState ());
        }
    }
    else
    {
        error = Error_ATM_NoMemory;
    }

    return error;
}




void  Connection::RemoveClient (ClientConnection *  client)
{
    ClientListItem **  item_ptr = &client_list;

    while (*item_ptr && (*item_ptr)->client != client)
    {
        item_ptr = &(*item_ptr)->next;
    }

    if (*item_ptr)
    {
        ClientListItem *  item = *item_ptr;
        *item_ptr = item->next;
        delete item;
        if (--usage == 0)
        {
            Close ();
        }
    }
}




void  Connection::StateChanged (const SocketService::State  state)
{
    ClientListItem *  item = client_list;

    while (item)
    {
        item->client->Notify (state);
        item = item->next;
    }

    if (state == SocketService::Closed && usage == 0)
    {
        delete this;
    }
}




Connection *  Connection::Find (const ATML_SOCKADDR *const  atm_addr,
                                const Service               service,
                                const Connection::Origin    origin,
                                int &                       error)
{
    Connection *  connection = 0;
    ConnectionListItem *item = Connection::connection_list;

    error = 0;

    while (item && !connection && !error)
    {
        connection = item->connection->CheckConflict (atm_addr,
                                                      service,
                                                      origin,
                                                      error);
        item = item->next;
    }

    return connection;
}




VC *  Connection::GetVC ()
{
    return vc;
}




int  Connection::GetError ()
{
    return error;
}




void  Connection::Error (const int   error,
                         const bool  fatal)
{
    if (fatal)
    {
        Close ();
    }
    else
    {
        this->error = error;
    }
}




void  Connection::Connect ()
{
    vc->Connect ();
}




int  Connection::Listen ()
{
    ((SVC *) vc)->Listen ();
    return 0;
}




void  Connection::Close ()
{
    vc->Close ();
}




bool  Connection::Unused ()
{
    bool used = this->used;
    used = false;
    return used;
}




Connection::Origin  Connection::GetOrigin ()
{
    return origin;
}




void  Connection::CloseUnused ()
{
    ConnectionListItem *item = Connection::connection_list;

    while (item)
    {
        if (item->connection->Unused())
        {
            item->connection->Close ();
        }
        item = item->next;
    }
}




_kernel_oserror *  Connection::DisplayAll (int     argc,
                                           char *  argv[])
{
    ConnectionListItem *  item = Connection::connection_list;

    M_unused (argc);
    M_unused (argv);

    printf ("Type  IP address       Flags  Service  State       ATM address\n");

    while (item)
    {
        item->connection->Display ();
        item = item->next;
    }

    return NULL;
}




void  Connection::Display ()
{
    struct  in_addr  ip_addr;
    char *  s_ip_addr = "";
    char    flags[6];
    char *  p_flags = flags;

    // Get text IP address
    ip_addr.s_addr = ip_map_ip_from_atm (vc->GetATMAddr ());
    if (ip_addr.s_addr)
    {
        s_ip_addr = inet_ntoa (ip_addr);
    }

    // Make text representation of flags
    if (used)
    {
        *p_flags++ = 'U';
    }
    if (origin == Remote)
    {
        *p_flags++ = 'L';
    }
    if (immortal_listen)
    {
        *p_flags++ = 'I';
    }
    *p_flags = 0;


    char *  state;
    switch (vc->GetState())
    {
        case SocketService::Creating:
            state = "Creating";
            break;

        case SocketService::Exists:
            state = "Exists";
            break;

        case SocketService::Listening:
            state = "Listening";
            break;

        case SocketService::Connecting:
            state = "Connecting";
            break;

        case SocketService::Requesting:
            state = "Requesting";
            break;

        case SocketService::Accepting:
            state = "Accepting";
            break;

        case SocketService::Connected:
            state = "Connected";
            break;

        case SocketService::Closing:
            state = "Closing";
            break;

        case SocketService::Closed:
            state = "Closed";
            break;

        default:
            state = "Unknown";
            break;
    }

    //printf ("%-4s  %-15s  %-5s  %-7s  %-6d  %-10s  %s\n",
    printf ("%-4s  %-15s  %-5s  %-7s  %-10s  %s\n",
            vc->GetTextType(),
            s_ip_addr,
            flags,
            GetTextService(),
            //socket->GetHandle(),
            state,
            vc->GetTextAddr());
}




ClientConnection::ClientConnection (const ATML_SOCKADDR *const  atm_addr,
                                    const Connection::Service   service,
                                    const ATMStatusFn           status_fn,
                                    void *const                 status_pw,
                                    Connection::Origin          origin,
                                    int &                       error)

{
    error = 0;

    callback_data.handle = this;
    callback_data.status_fn = status_fn;
    callback_data.status_pw = status_pw;
    callback_data.semaphore = 0;


    // Force no BLLI to start with
    ((ATML_SOCKADDR *) atm_addr)->atm.blli_len = 0;

    connection = Connection::Find (atm_addr, service, origin, error);
    if (!connection && !error)
    {
        switch (service)
        {
            case Connection::Service_MPEG_AAL5:
                connection = MPEGConnection::Create (atm_addr, service, origin, error);
                break;

            case Connection::Service_IP_LLC:
            case Connection::Service_IP_VC:
                connection = IPConnection::Create (atm_addr, service, origin, error);
                dprintf (("", "error = %d\n", error));
                break;
        }
    }

    if (connection)
    {
        connection->AddClient (this);
    }
}




ClientConnection::~ClientConnection ()
{
    connection->RemoveClient (this);
}




Connection *  ClientConnection::GetConnection ()
{
    return connection;
}




void  ClientConnection::Notify (SocketService::State  state)
{
    if (callback_data.status_fn)
    {
        callback_data.state = state;

        if (callback_data.semaphore == 0)
        {
            callback_data.semaphore = 1;

            dprintf (("", "handle %p\nstate %d\nroutine %p\nworkspace %p\n",
                     callback_data.handle,
                     callback_data.state,
                     callback_data.status_fn,
                     callback_data.status_pw));

            _swix (OS_AddCallBack,
                   _INR (0, 1),

                   asm_status_changed,
                   &callback_data);
        }
    }
}
