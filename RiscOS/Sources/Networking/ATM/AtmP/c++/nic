/* File:    nic.c++
   Purpose: Manage Network Interface Card
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-04-26: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include "kernel.h"
#include <string.h>
#include "swis.h"

//#include "sys/types.h"

// Misc
#include "DebugLib/debuglib.h"

// Local
#include "defs.h"
#include "command.h"
#include "console.h"
extern "C"
{
    #include "header.h"
}
#include "module.h"
#include "nic.h"
#include "utils.h"
#include "boson.h"



// =============================================================================
// Constants definitions

#define NetPrefix_Cmd "getnext ilmi"
#define NetPrefix_OID "1.3.6.1.4.1.353.2.7.1.1.3"




// =============================================================================
// Class statics

NIC *  NIC::instance = 0;




// =============================================================================
// Declare function prototypes

extern "C"
{
    extern void asm_enable_podule_irqs (unsigned int);
    extern void asm_disable_podule_irqs (unsigned int);
}




// =============================================================================
// Class member function definitions

#if 0
int panther_happy(void)
{
    #define HAPPY_PANTHER     0xffff7c01
    // check NIC is happy by waiting for magick word to be echoed
    // do not use before init_panther() has been called, or the check will fail
    int temp;

    // it's probably best not to use this when the IRQ handler is running too
    boson_block_write (HAPPY_PANTHER); // write this to the echo service
    timeoutError = 0;
    temp = boson_block_read ();     // read it back

    if(timeoutError) return -1; // timed out? return error

    if(temp != HAPPY_PANTHER) return -1;
    // didn't get what we expected? return error

    return 1;
}
#endif




NIC *  NIC::Instance ()
{
    _kernel_oserror *  error = 0;

    return Instance (error);
}




NIC *  NIC::Instance (_kernel_oserror *  error)
{
    error = 0;

    if (!instance)
    {
        instance = new NIC (error);
        if (instance && error)
        {
            delete instance;
            instance = 0;
        }
    }

    return instance;
}




NIC::NIC (_kernel_oserror *&  error)
    : read_mac_addr (false),
      read_net_prefix (false)
{
    // Ensure NIC can't generate IRQs to start with - must explicitly
    // request them.
    DisableAllInterrupts ();

    // Claim podule IRQs
    error = _swix (OS_ClaimDeviceVector,
                   _INR (0, 4),

                   13,    // expansion card device number
                   boson_irq_entry,
                   module_wsp,
                   Boson_IRQ,
                   0x2);    // 0x2 bit 1 is interrupt request

    asm_enable_podule_irqs (podule);
}




NIC::~NIC ()
{
    DisableAllInterrupts ();

    asm_disable_podule_irqs (podule);

    _swix (OS_ReleaseDeviceVector,
           _INR (0, 4),

           13,    // expansion card device number
           boson_irq_entry,
           module_wsp,
           Boson_IRQ,
           0x2);    // 0x2 bit 1 is interrupt request
}




void  NIC::DisableAllInterrupts ()
{
    w_Boson_Command (BosonCmd_ClrAll);    // mask out all NIC interrupts
}




void  NIC::DisableInterrupts ()
{
    w_Boson_Command (BosonCmd_ClrRxBlockMask);    // mask out the NotEmpty bit
}




void  NIC::EnableInterrupts ()
{
    // use the command register to mask in the NotEmpty bit IRQ thus generated
    // when NIC has data available
    w_Boson_Command (BosonCmd_SetRxBlockMask);
}




const unsigned char *  NIC::GetUNIAddr ()
{
    int  error;

    return GetUNIAddr (error);
}




const unsigned char *  NIC::GetUNIAddr (int &  error)
{
    error = 0;
    if (!read_mac_addr || !read_net_prefix)
    {
        const unsigned char *  net_prefix = GetNetPrefix (error);
        if (!error)
        {
            const unsigned char *  mac_addr = GetMACAddr (error);
            if (!error)
            {
                // Network prefix
                memcpy (&uni_addr[0], net_prefix, NSAPAddr_NetPrefix_Size);

                // End System Identifier
                memcpy (&uni_addr[NSAPAddr_NetPrefix_Size],
                        mac_addr,
                        MACAddr_Size);

                // Selector byte
                uni_addr[NSAPAddr_Size - 1] = 0;
            }
        }
    }

    if (!error)
    {
        #ifdef DEBUGLIB
        for (int i = 0; i < sizeof (uni_addr) - 1; i++)
        {
            dprintf (("", "%02x.", uni_addr[i]));
        }
        dprintf (("", "%02x\n", uni_addr[i]));
        #endif
    }

    return &uni_addr[0];
}




const unsigned char *  NIC::GetNetPrefix ()
{
    int  error;

    return GetNetPrefix (error);
}




const unsigned char *  NIC::GetNetPrefix (int &  error)
{
    error = 0;
    if (!read_net_prefix)
    {
        error = ReadNetPrefix ();
        if (error)
        {
            return 0;
        }

        read_net_prefix = true;
    }

    return net_prefix;
}




const unsigned char *  NIC::GetMACAddr ()
{
    int  error;

    return GetMACAddr (error);
}




const unsigned char *  NIC::GetMACAddr (int &  error)
{
    error = 0;
    if (!read_mac_addr)
    {
        error = command_service->GetMAC (mac_addr);
        if (error)
        {
            return 0;
        }

        read_mac_addr = true;
    }

    return mac_addr;
}




int  NIC::ReadNetPrefix ()
{
    enum
    {
        NetPrefix_CmdLen = sizeof (NetPrefix_Cmd) - 1,
        NetPrefix_OIDLen = sizeof (NetPrefix_OID) - 1
    };

    int  error;

    Console *  console = new Console (error);
    if (!console)
    {
        return Error_ATM_NoMemory;
    }
    else if (error)
    {
        delete console;
        return error;
    }

    // Query SNMP service on card to find network prefix

    // The network prefix table is indexed by atmfNetPrefixPort (an
    // integer) and atmfNetPrefixPrefix (see ATM Forum ILMI spec. for
    // details), so the reply we get back when querying the next object
    // after the table is the first entry in the table ie.
    // getnext ilmi 1.3.6.1.4.1.353.2.7.1.1.3.<port>.<prefix>

    char buffer[256];
    error = console->DoCommand (NetPrefix_Cmd " " NetPrefix_OID,
                                buffer,
                                sizeof (buffer));
    if (!error)
    {
        dprintf (("", "%s\n", buffer));

        error = Error_ATM_NetPrefixRead;
        char *  s = buffer;
        bool  valid_reply = false;

        if (strncmp (s, NetPrefix_Cmd, NetPrefix_CmdLen) == 0)
        {
            s += NetPrefix_CmdLen;
            dprintf (("", "%s\n", s));
            if (*s++ == ' ')
            {
                if (strncmp (s, NetPrefix_OID, NetPrefix_OIDLen) == 0)
                {
                    s += NetPrefix_OIDLen;
                    dprintf (("", "%s\n", s));
                    if (*s++ == ' ')
                    {
                        valid_reply = true;
                    }
                }
            }
        }

        if (valid_reply)
        {
            // Skip past the part of the OID we already know (because
            // we requested it) to the table index.
            if (strncmp (s, NetPrefix_OID, NetPrefix_OIDLen) == 0)
            {
                s += NetPrefix_OIDLen;

                // s now points to the part of the OID which is the index
                // of the next (first and only, we're replying on!!) element
                // in the netprefix table

                // skip over port (read past 2 '.' characters)
                int  skip = 2;
                do
                {
                    s = strchr (s, '.');
                    if (s)
                    {
                        ++s;
                        --skip;
                    }
                }
                while (s && skip);

                if (s)
                {
                    // rest of reply should now be if form of
                    // <var length netprefix> <type> <value>
                    //
                    // where we're expecting type to be 'i' for integer and
                    // value to be 0 or 1 depending on whether the network
                    // prefix is valid yet
                    char *  type = strchr (s, ' ') + 1;

                    bool  valid = (bool) strtol (strchr (type, ' '), 0, 0);
                    dprintf (("", "type %c, valid = %d\n",
                              *type, valid));
                    if (*type == 'i' && valid)
                    {
                        // The network prefix is a variable length
                        // string, so the first octet specified the
                        // length of network prefix that follows.
                        // Don't care - just keep reading until the
                        // end
                        s = strchr (s, '.');
                        if (s)
                        {
                            sep_str_to_num (s + 1, net_prefix, 0);
                        }
                        error = 0;
                    }
                    else
                    {
                        error = Error_ATM_NetPrefixRead;
                    }
                }
                else
                {
                    dprintf (("", "reply parse error\n"));
                }
            }
            else
            {
                dprintf (("", "OID mismatch\n"));
            }
        }
        else
        {
            dprintf (("", "invalid SNMP response\n"));
        }
    }

    delete console;

    return error;
}
