/* File:    command.c++
   Purpose: Command service
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-03-24: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include <string.h>

// Miscellaneous
#include "DebugLib/DebugLib.h"

// Local
#include "address.h"
#include "boson.h"
#include "command.h"
#include "defs.h"




// =============================================================================
// Constants definitions

enum
{
    SO_ATTACH  = 0x1,
    SO_ATTACHX = 0x8,
    SO_DETACH  = 0x2,
    SO_GET_MAC = 0x5,
    SO_SET_MAC = 0x6
};




// =============================================================================
// Global variables

CommandService *  command_service;
CommandService *  CommandService::instance = 0;




// =============================================================================
// Function prototype declarations




// =============================================================================
// Member function definitions

/* -----------------------------------------------------------------------------
 */

CommandService *  CommandService::Create (int &  error)
{
    error = 0;
    if (!instance)
    {
        instance = new CommandService (error);
        if (instance)
        {
            if (error)
            {
                delete instance;
                instance = 0;
            }
            else
            {
                service_manager->RegisterService (instance);
            }
        }
    }

    return instance;
}



CommandService::CommandService (int &  error)
    : Service (CMD_SERVICE, error, CommandService_Handle),
      get_mac_op (0)
{
}



void  CommandService::TxAttachx (const int  service,
                           const int  handle)
{
    boson_block_write (
        CMD_MSG (this->handle, SO_ATTACHX, (service << 12) | handle));
}




void  CommandService::TxDetach (const int  handle)
{
    boson_block_write (CMD_MSG (this->handle, SO_ATTACHX, handle));
}




int  CommandService::GetMAC (unsigned char *  mac_addr)
{
    int  error = 0;

    if (!get_mac_op)
    {
        get_mac_op = new AsyncOp (50, mac_addr, MACAddr_Size);
        if (get_mac_op)
        {
            TxGetMAC ();
            error = get_mac_op->Wait ();
            AsyncOp *  temp_op = get_mac_op;
            get_mac_op = 0;
            delete (temp_op);
        }
        else
        {
            error = Error_ATM_NoMemory;
        }
    }

    return error;
}




void  CommandService::TxGetMAC ()
{
    boson_block_write (CMD_MSG (this->handle, SO_GET_MAC, 0));
}




MessageHandlerRC  CommandService::MessageHandler (
                      NICMessage          msg,
                      const unsigned int  total_size)
{
    MessageHandlerRC  rc;

    M_unused (total_size);

    if (msg.common.type == NIC_DataMessage)
    {
        switch (msg.command.command)
        {
            case SO_SET_MAC:
                ASM_GET_MSG (Boson_CommitFromARMAddr, irq_buffer, msg.data.size);
                if (msg.data.size == MACAddr_Size &&
                    get_mac_op)
                {
                    dprintf (("", "rx SO_SET_MAC\n"));
                    get_mac_op->Completed (irq_buffer, msg.data.size);
                }
                rc = HandledMsg;
                break;

            default:
                rc = DiscardMsg;
                break;
        }
    }
    else
    {
        rc = DiscardMsg;
    }

    return rc;

}
