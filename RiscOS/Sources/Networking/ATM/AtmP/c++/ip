/* File:    .c++
   Purpose:
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-03-: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include <string.h>

#include "DebugLib/DebugLib.h"

/* TCPIPLibs */
extern "C"
{
    #include "sys/types.h"
    #include "sys/errno.h"
    #include "inetlib.h"
    #include "netinet/in.h"
    #include "net/if.h"
    #include "netinet/if_ether.h"
    #include "sys/dcistructs.h"
    #include "sys/mbuf.h"
}

// Local
#include "defs.h"
#include "ip.h"
#include "mbuf.h"
#include "socket.h"
#include "utils.h"




// =============================================================================
// Class statics

unsigned int  IPConnection::txbuf[M_round_word (ATM_MTU) /
                                  sizeof (unsigned int)];




// =============================================================================
// Member function definitions

/* -----------------------------------------------------------------------------
 */

Connection *  IPConnection::CheckConflict (
                    const ATML_SOCKADDR *const  atm_addr,
                    const Connection::Service   service,
                    const Connection::Origin    origin,
                    int &                       error)
{
    // Due to the fact that the only piece of information we get from the DCI4
    // transmit interface that we can use to distinguish differerent connections
    // is the destination MAC address, we can't have more than one connection
    // to a given ATM end station.  [The fact that we 'fake' a MAC address for
    // the destination when using PVC means that we can allow a single PVC
    // and SVC, but when we use ATMARP this would break, so it shouldn't be
    // done.
    //
    // There are certain rules that we must follow to determine whether we
    // create a new connection.
    // Connections originated by us:
    // * If there is not currently a connection to the given end station then
    //   create the connection.
    // * If there is already a connection to the given address and the new
    //   address (*all* fields of the address structure) and service type are
    //   the same, then return the handle to the existing connection.  Otherwise
    //   return an error to indicate that the connection cannot be created.
    //
    // Connections originated by a remote host:
    // We can have any number of these, assuming that they are only used to
    // receive data.  When transmitting data, a connection originated by us
    // will be used in preference to any connections created by a remote host.
    // If there are no connections originated by us then the first 'listening'
    // connection will be used.

    Connection *  connection = 0;

    error = 0;
    if (origin == Connection::Local &&
        this->origin == Connection::Local &&
        (service == Service_IP_LLC || service == Service_IP_VC) &&
        compare_atm_addresses (vc->GetATMAddr(), atm_addr))
    {
        if (service == this->service)
        {
            connection = this;
        }
        else
        {
            dprintf (("", "forbidding connection\n"));
            error = Error_ATM_DuplicateConnection;
        }
    }

    return connection;
}




IPConnection *  IPConnection::Create (const ATML_SOCKADDR *const  atm_addr,
                                      const Connection::Service   service,
                                      const Connection::Origin    origin,
                                      int &                       error)
{
    error = 0;

    // Force blli to required values for IPOA
    ((ATML_SOCKADDR *) atm_addr)->atm.blli_len = 1;
    ((ATML_SOCKADDR *) atm_addr)->atm.blli[0] = 0xcc;

    IPConnection *  connection =
        new IPConnection (atm_addr, service, origin, error);
    if (connection)
    {
        if (error)
        {
            delete connection;
            connection = 0;
        }
    }
    else
    {
        error = Error_ATM_NoMemory;
    }

    return connection;
}




IPConnection::IPConnection (const ATML_SOCKADDR *const  atm_addr,
                            const Connection::Service   service,
                            const Connection::Origin    origin,
                            int &                       error)
    : Connection (atm_addr,
                  service,
                  origin,
                  error),
      mac_mapping (0),
      buffer_offset (0),
      data_count (0),
      data_lost (0)
{
    if (!error)
    {
        if (service == Connection::Service_IP_LLC)
        {
            llc = true;
        }
        else
        {
            llc = false;
        }

        if (origin == Connection::Local)
        {
            // Extract MAC address from ATM address
            const unsigned char *  mac_addr = mac_from_atm (atm_addr);
            if (mac_addr)
            {
                error = mac_map_add (mac_addr, this, 0);
            }
            else
            {
                error = Error_ATM_NoMAC;
            }
        }
    }
}




IPConnection::~IPConnection ()
{
    const unsigned char *  mac_addr = mac_from_atm (vc->GetATMAddr());
    if (mac_addr)
    {
        mac_map_remove (mac_addr, this);

        if (mac_map_count (mac_addr) == 0)
        {
            /* No other connections to this address, so can remove
             * IP<->ATM address mapping for this address.
             */
            ip_map_remove (mac_addr);
        }
    }

    dci_flush_cache (this);
}




void  IPConnection::Close ()
{
    if (--usage == 0)
    {
        Connection::Close ();
    }
}




int  IPConnection::Listen ()
{
    int  error;

    // Pre-allocate MAC mapping to avoid having to try to allocate memory
    // in the interrupt handler (difficult to sort out at that point if it
    // fails).
    mac_mapping = mac_map_alloc ();
    if (mac_mapping)
    {
        error = Connection::Listen ();
    }
    else
    {
        error = Error_ATM_NoMemory;
    }

    return error;
}




void  IPConnection::StateChanged (const SocketService::State  state)
{
    if (state == SocketService::Connected && GetOrigin() == Remote)
    {
        // Get the MAC address of the calling party
        const unsigned char *  mac_addr = mac_from_atm (vc->GetATMAddr ());

        if (mac_map_find_conn (mac_addr) == 0)
        {
            (void) mac_map_add (mac_addr, this, mac_mapping);
        }
    }

    Connection::StateChanged (state);
}




int  IPConnection::Data (const unsigned int  data_size)
{
    unsigned int  bytes_left = sizeof (buffer) - buffer_offset;
    int           rc = 0;

    if (data_size <= bytes_left)
    {
        ASM_GET_MSG (CommitFromARMAddr, buffer + buffer_offset, data_size);
        buffer_offset += data_size;
        data_count += data_size;
    }
    else
    {
        rc = 1;
    }

    return rc;
}




void  IPConnection::DataEnd ()
{
    unsigned char *  data_start;
    unsigned int     data_size;
    int              frame_type;

    if (llc)
    {
        frame_type = (buffer[6] << 8) | buffer[7];
        data_start = buffer + LLC_HDR_SIZE;
        data_size  = buffer_offset - LLC_HDR_SIZE;
    }
    else
    {
        frame_type = ETHERTYPE_IP;
        data_start = buffer;
        data_size  = buffer_offset;
    }

    if (dci_receive (this, data_start, data_size, frame_type))
    {
        ++irq_ip_pkts_dropped;
        data_lost += buffer_offset;
    }
    else
    {
        ++ip_rx;
    }

    buffer_offset = 0;
}



void  IPConnection::DataLength (const unsigned int  length)
{
    buffer_offset = length;
}




void  IPConnection::DataAbort ()
{
    buffer_offset = 0;
}




const char *  IPConnection::GetTextService ()
{
    if (llc)
    {
        return "IP/LLC";
    }
    else
    {
        return "IP/VC";
    }
}




#ifdef DEBUGLIB

#define MAX_DUMP_BYTES  128

static void dump_pkt (u_char *  rptr, int pktlen)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    static const char digits[] = "0123456789abcdef";

    while (pktlen--)
    {
        if (bp > buf + sizeof(buf) - 3)
            goto done;
        *bp++ = digits[*rptr >> 4]; /* convert byte to ascii hex */
        *bp++ = digits[*rptr++ & 0xf];
        *bp++ = ' ';
    }

done:
    *bp = 0;
    dprintf (("", "%s\n", buf));
}

#endif




int  IPConnection::TxMBufChain (const int       frame_type,
                                struct mbuf *&  m0,
                                const bool      free_mbufs)
{
    unsigned char *  t;
    struct mbuf *    m;

    if (vc->GetState () != SocketService::Connected)
    {
        vc->Connect ();

        unsigned int  end_t = MonotonicTime() + 10;
        while (vc->GetState() != SocketService::Connected &&
               MonotonicTime () < end_t)
        {
        }

        if (vc->GetState() != SocketService::Connected)
        {
             /* this connection is not yet established - drop the packet */
             dprintf (("", "can't transmit - not connected\n"));
             return INETERR_TXBLOCKED;
        }
    }

    if (llc)
    {
        dprintf (("", "inserting LLC/SNAP header\n"));

        t = (unsigned char *) txbuf;

        /* insert LLC value indicating SNAP header is present*/
        *t++ = 0xAA;
        *t++ = 0xAA;
        *t++ = 0x03;

        /* insert SNAP header */
        *t++ = 0;
        *t++ = 0;
        *t++ = 0;
        *t++ = (frame_type >> 8) & 0xff;
        *t++ = frame_type & 0xff;
    }

    int  datalen;
    do
    {
        /* figure out how much buffer space we have */
        for (datalen = 0, m = m0; m; m = m->m_next)
        {
            datalen += m->m_len;
        }

        if (datalen > ATM_MTU)    /* Too much? Dump it */
        {
            dprintf (("", "ATM_MTU exceeded.\n"));
            return EMSGSIZE;
        }

        dprintf (("", "size:%d\n", datalen));

        t = (unsigned char *) txbuf;
        if (llc)
        {
            t += LLC_HDR_SIZE;
            datalen += LLC_HDR_SIZE;
        }

        for (m = m0; m; m = m->m_next )
        {
            memcpy (t, mtod(m, char *), m->m_len);
            t += m->m_len;
        }

        #ifdef DEBUGLIB
        //dump_pkt ((u_char *) txbuf, datalen);
        #endif

        if (vc->TxData (txbuf, datalen) < 0)
        {
            dprintf (("", "ran out of FIFO space!\n"));
            /* Consider doing interrupt-driven write-out if not enough
             * space straight away.
             */
        }
        else
        {
            ip_tx++;
            used = true;
        }

        m  = m0;           /* keep pointer to current mbuf chain */
        m0 = m->m_list;    /* point to next mbuf chain in list */

        /* 1999-03-19: BAL
         * Not required because m_freem only works on MBuf chains, not lists
         * of chains.
         */
        /* m->m_list = 0; */

        if (free_mbufs)
        {
            m_freem (m);
        }
    } while (m0);

    return 0;
}
