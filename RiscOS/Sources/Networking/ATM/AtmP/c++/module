/*      MODULE.C

Project : ATML ATM25 card driver

Purpose: Risc OS module type stuff

History:

Date      Who     Description of change
===========================================
20/1/97    CP      Picked up the existing code, added header.

                   Modified calls to init_bs_buffers to reflect changes made
                   to the function in buffer.c

                   Replaced all occurrences of BS_BUFFER_SIZE with
                   bs_buffer_size_G, and imported the variable.

21/1/97    CP      Added changebufferpool CLI to CLIhandler

28/1/97    CP      Added goof-proofing veneer for asm_get_msg().

22/12/97   CP      Fixed tragically broken chaindib structure (used in
                   enumerate driver service call).  It was a global, but
                   should have been dynamically allocated since the calling
                   routine frees the memory!

                   Removed a stray debugging printf from the IRQ handler.
                   This was crashing the box whenever mbufs could not be
                   allocated.

                   Tidied up #includes, using <...> where appropriate.

6/2/98     CP      Added new command to use NVRAM for bandwidth

30/4/98    CP      Added cmhg.h, which is auto-generated by cmhg
                   Fixed calls to cmhg functions

28/5/98    CP      Changed definition of swi base to ATM_00 from cmhg.h

1/6/98     CP      Moved handling of chaindibs entirely within service
                   handler (there's a possibility that memory could be yanked
                   from under us otherwise!).  Fixed chaindib handling so it
                   works properly with multiple NICs (previously it assumed
                   that it was the only dib on the block!)

5/6/98     CP      Added definition of dib.dib_inquire.

                   Restructured SWI handler to be more robust.

22/10/98   CP      Added stats SWI to handler.
                   Changed Inquire word to reflect nature of ATM.

***************************************************************************/

#include <ctype.h>
#include "kernel.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "swis.h"

extern "C"
{
    #include "sys/types.h"
    #include "sys/mbuf.h"
    #include "sys/dcistructs.h"
}

#include "DebugLib/DebugLib.h"
#include "MemCheck/MemCheck.h"

#include "address.h"
#include "arp.h"
#include "atmswis.h"
#include "boson.h"
#include "command.h"
#include "commands.h"
#include "configure.h"
#include "console.h"
#include "error.h"
#include "dci.h"
#include "defs.h"
#include "dhcpboot.h"
extern "C"
{
    #include "header.h"
}
#include "module.h"
#include "lane.h"
#include "mpeg.h"
#include "mbuf.h"
#include "nic.h"
#include "nvparams.h"
#include "utils.h"

#define  PODULE_DEFAULT 1
#define PnP_RegisterDDI 0xc07c0

int podule = PODULE_DEFAULT;
int do_start = 0;
int do_arp = 0;
int do_atmarp = 0;
int do_vc = 0;
int do_pvc = 0;
volatile int do_local_arp = 0;
int echo_ack = 0;


int ip_rx = 0;
int ip_tx = 0;
int mpeg_tx = 0;
int mpeg_rx = 0;
int mpeg_discards1 = 0;
int mpeg_discards2 = 0;
int mpeg_discards3 = 0;

int callbs = 0;
int callb_echos = 0;
int callb_startups = 0;
int callb_arps = 0;

int atm_connections = 0;
int atm_listens = 0;
int arp_count = 0;
int local_arp_count = 0;
int discard_arp_count = 0;
int bcast_arp_count = 0;

int ticker_period = 0; /* cS delay before circuit_checker kicks in */
int ticker_tally = 0;
int streamhandle;

extern int atmcnt;

volatile int callbackflag = 0;
volatile int do_check_happy = 0;
int check_happy_interval = 0;

void *module_wsp = 0;

int nextblock = 0;




// =============================================================================
// Function prototype declarations

extern "C" void *  messages_data (void);

#ifdef DHCP
static void  service_internet_status (_kernel_swi_regs *  r);
#endif




// =============================================================================
// Function definitions

#ifdef MemCheck_MEMCHECK

static int  memcheck_vprintf (void *        reference,
                              const char *  format,
                              va_list       args)
{
    dvprintf (("", format, args));
    return 0;
}

#endif


int main (void)
{
    return 0;
}

/*
 * Module Initialization code.
 */
_kernel_oserror *module_init (const char *cmd_tail, int pbase, void *pw)
{
    _kernel_swi_regs   r;
    _kernel_oserror *  e;
    int                error = 0;
    NIC *              nic = 0;

    M_unused (cmd_tail);
    M_unused (pbase);

    // This hack is required for C++ modules to ensure that global objects
    // are initialised correctly.
    main ();

    module_wsp = pw;

    //debug_initialise ("", "atm", NULL);
    //debug_set_options (0, 0, 0);
    //debug_output_buffer_on (0, 64*1024);
    //debug_output_device (TML_OUTPUT);
    //debug_initialise_trace (TML_OUTPUT, "memcheck_vprintf");

    MemCheck_Init ();
    MemCheck_RedirectToFunction (memcheck_vprintf, 0);
    MemCheck_SetStoreMallocFunctions (1);
    MemCheck_InterceptSCLStringFunctions();
    MemCheck_SetQuitting (0, 0);
    MemCheck_SetAccessQuitting (0, 0);
    // Don't output blocks on every diagnostic.  A lot of diagnostics
    // are produced because of MemCheck faulting accesses to externally
    // supplied mbuf data structures. There are too many instances of
    // these to make it feasible to register them all as misc blocks.
    MemCheck_SetAutoOutputBlocksInfo (0);

    #ifndef ROM
    e = _swix (ResourceFS_RegisterFiles, _IN (0), messages_data ());
    if (e)
    {
        goto os_error;
    }
    #endif

    e = message_open_file ();
    if (e)
    {
        goto os_error;
    }

    /* We need to know the podule number of the ATM25 card. Plug'n'play
     * hasthis info, and passes it to us using one of 2 mechanisms. On a
     * STB, Plug'n'Play exits immediately after it has finished to
     * conserve memory in the RMA. In this case, it sets the environment
     * variable PnP$Podule to be the podule number. On a RPC, PnP
     * doesn't exit, because this causes a nasty error box. PnP stays
     * alive, and _doesn't_ set the PnP$Podule variable. In this case,
     * the atm25driver communicates with it using the PnP_RegisterDDI to
     * obtain information about the card.
    */

    /* see if the plug and play module has set PnP$Podule */

    r.r[0] = (int) "PnP$Podule";
    r.r[1] = (int) &podule;
    r.r[2] = 4;
    r.r[3] = 0;
    r.r[4] = 0;
    _kernel_swi (XOS_Bit | OS_ReadVarVal, &r, &r);

    if(r.r[2] == 0)
    {
        int  pnp_result;

        /* variable didn't exist, try the SWI */
        /* talk to the Plug'n'Play module, to get card status & podule no.  */

        dprintf(("", "Failed reading PnP$Podule - trying PnP SWI\n"));

        if (_swix (PnP_RegisterDDI, _OUT (0), &pnp_result))
        {
            error = Error_ATM_PnPComms;
            goto internal_error;
        }

        switch (pnp_result)
        {
            case -1:
                error = Error_ATM_PnPUninit;
                goto internal_error;

            case -2:
                error = Error_ATM_NoCards;
                goto internal_error;

            default:
                podule = pnp_result;
                break;
        }
        dprintf (("", "Read PnP podule number as %d\n", podule));
    }
    else
    {
        dprintf (("", "Read PnP$Podule as %d\n", podule));
    }


    if (nvparams_init (podule))
    {
        error = Error_ATM_NoCards;
        goto internal_error;
    }

    dprintf (("", "Reading NVRAM parameters...\n"));

    do_vc  = nvparams_read_multiproto_enc ();
    do_arp = nvparams_read_dynamic_arp ();
    do_pvc = nvparams_read_pvc ();

    dprintf (("", "Read NVRAM parameters.\n"));


    service_manager = ServiceManager::Create (error);
    if (!service_manager)
    {
        goto internal_error;
    }

    nic = NIC::Instance (e);
    if (e)
    {
        goto os_error;
    }
    nic->EnableInterrupts ();


    command_service = CommandService::Create (error);
    if (!command_service && error)
    {
        goto internal_error;
    }

    // Get UNI address - don't care about the result for now, can try again
    // later if it doesn't work.
    nic->GetUNIAddr ();

    //error = LANEService::Create ();
    //if (error)
    //{
    //    goto internal_error;
    //}

    if (ticker_period && enable_ticker_handler () < 0)
    {
        error = Error_ATM_TickerAlloc;
        goto internal_error;
    }

    /* Initialize Driver Information Block */
    dci_init ();

    if (!managerstarted && mb_present())
    {
        /* mbuf manager is loaded - initialise entry points */
        e = mb_entryinit ();
        if (e)
        {
            /* open an mbufman session - register our control block */
            goto os_error;
        }

         /* OK - set a callback to issue Service_DCIDriverStatus */

        do_start = 1;
        setcallback ();
        managerstarted = 1;
    }

    return NULL;

internal_error:
    e = error_int_to_os (error);

os_error:
    // Clean up if an error occurs during initialisation.  It's grotty, but
    // probably the least grotty solution given than the finalisation code
    // doesn't get called in this case.

    if (nic)
    {
        delete nic;
    }

    message_close_file ();

    #ifndef ROM
    _swix (ResourceFS_DeregisterFiles, _IN (0), messages_data ());
    #endif

    return e;
}

/* Module Finalization code */

_kernel_oserror * module_final (int fatal, int podule, void *pw)
{
    M_unused (fatal);
    M_unused (pw);
    M_unused (podule);


    delete NIC::Instance ();


    (void) mb_closesession();

    disable_ticker_handler();

    dci_driver_status (1);

    mpeg_free_buffers ();
    delete service_manager;

    message_close_file ();

    MemCheck_OutputBlocksInfo ();
    MemCheck_Finalise ();


    #ifndef ROM
    _swix (ResourceFS_DeregisterFiles, _IN (0), messages_data ());
    #endif

    debug_terminate ();

    return NULL;
}




/* Module Service Call handler */
void module_sc_handler (int sn, _kernel_swi_regs *r, void *pw)
{
    M_unused (pw);

    switch (sn)
    {
        #ifdef DHCP
        case Service_InternetStatus:
            service_internet_status (r);
            break;
        #endif

        case Service_EnumerateNetworkDrivers:
        {
            static int init = 0;

            if (!init)
            {
                init = 1;
            }
            dci_chain_dib (r);
            break;
        }

        case Service_MbufManagerStatus:
            if (!managerstarted)
            {
                handle_managerstatus(r);
            }
            break;

        /*
         * Service_PreReset - reset card prior to system shutdown
         */
        case Service_PreReset:
            NIC::Instance()->DisableInterrupts ();
            break;

        /* add pre_reset code to handle stb2 standby state */
        default:
            break;
    }
}


/* Module SWI handler */
_kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
/*
   5jun98:CP:restructured SWI handler to cope with bad SWIs.
             Simplified structure, too.
             Links in with cmhg.h (which is auto-generated from cmhg.header)
*/

    int error                 = 0;
    _kernel_oserror *os_error = NULL;

    M_unused (pw);
    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    switch (swinum)
    {
       case ATM_DCIVersion - ATM_00:
           error = dci_version (r);
           break;

       case ATM_Inquire - ATM_00:
           error = dci_inquire (r);
           break;

       case ATM_GetNetworkMTU - ATM_00:
           error = dci_getmtu (r);
           break;

       case ATM_SetNetworkMTU - ATM_00:
           error = dci_setmtu (r);
           break;

       case ATM_Transmit - ATM_00:
           error = dci_transmit (r);
           break;

       case ATM_Filter - ATM_00:
           error = dci_filter (r);
           break;

       case ATM_Stats - ATM_00:
           error = dci_stats (r);
           break;

       case ATM_ReadMacAddr - ATM_00:
           error = dci_readmacadr(r);
           break;

       case ATM_GetUNIAddress - ATM_00:
           error = swi_get_uni_address (r);
           break;

       case ATM_EmptyBuffer - ATM_00:
           error = atm_empty_buf (r);
           break;

       case ATM_AssociateAddress - ATM_00:
           error = atm_associateaddress (r);
           break;

       case ATM_VCConnect - ATM_00:
           error = atm_vcconnect (r);
           break;

        case ATM_VCListen - ATM_00:
           error = atm_vclisten (r);
           break;

       case ATM_VCClose - ATM_00:
           error = atm_vcclose (r);
           break;

       case ATM_VCStatus - ATM_00:
           error = atm_vcstatus (r);
           break;

       case ATM_BootConfig - ATM_00:
           error = atm_bootconfig (r);
           break;

      default:
          dprintf (("", "unknown SWI %d\n", swinum - ATM_00));
          os_error = error_BAD_SWI;
          break;
    }

    if (error != 0)
    {
        dprintf (("", "SWI returned error %d\n", error));
        os_error = error_int_to_os (error);
    }

    MemCheck_UnRegisterMiscBlock (r);

    return os_error;
}




/* -----------------------------------------------------------------------------
   str_ctrl_dup

   Create a 0 terminated duplicate of a control character terminated string.
   Client is responsible for freeing memory.

   Inputs
   s: pointer to string to duplicate

   Returns
   success: pointer to duplicated string
   failure: NULL
 */

static char *str_ctrl_dup (const char *const s)
{
    size_t len = 0;
    const char *c = s;
    char *p;

    while (!iscntrl (*c))
    {
        ++c;
        ++len;
    }

    p = malloc (len + 1);
    if (p)
    {
        memcpy (p, s, len);
        p[len] = 0;
    }

    return p;
}




static char **  arg_array_from_string (char *      arg_string,
                                       int *const  argc)
{
    char **  argv = NULL;
    char *   p;

    /* Count arguments */
    *argc = 0;
    p = arg_string;
    while (*p)
    {
        /* Skip leading space */
        while (isspace (*p))
        {
            p++;
        }

        /* Increment argument counter */
        (*argc)++;

        /* Skip over argument */
        while (*p && !isspace (*p))
        {
            p++;
        }
    }

    /* Create and fill argument array */
    argv = (char **) malloc (((*argc) + 1) * sizeof (char *));
    if (argv)
    {
        char **  arg = argv;

        p = arg_string;
        while (*p)
        {
            /* Skip leading space */
            while (isspace (*p))
            {
                p++;
            }

            /* Store pointer to this argument */
            *arg++ = p;

            /* Skip over argument */
            while (*p && !isspace (*p))
            {
                p++;
            }

            /* 0-terminate argument */
            if (*p)
            {
                *p++ = 0;
            }

            dprintf (("", "%s\n", *(arg - 1)));
        }

        /* 0-terminate argument array */
        *arg = 0;
    }

    return argv;
}




#ifdef DEBUGLIB
_kernel_oserror *  debugon (int argc, char *  argv[])
{
    M_unused (argc);
    M_unused (argv);
    debug_initialise ("ATM25", "", NULL);
    debug_set_options (0, 0, 0);
    debug_output_buffer_on (0, 64*1024);
    debug_output_device (TML_OUTPUT);
    //debug_initialise_trace (TML_OUTPUT, "memcheck_vprintf");
    return 0;
}




_kernel_oserror *  debugoff (int argc, char *  argv[])
{
    M_unused (argc);
    M_unused (argv);
    debug_output_buffer_off (0, PRINTF_OUTPUT);
    debug_terminate ();
    return 0;
}
#endif




_kernel_oserror *atm_cli_handler (const char *arg_string, int argc, int cmd_no, void *pw)
{
    typedef _kernel_oserror *  (*command_handler_t) (int, char *[]);

    typedef enum
    {
        NormalCommand,
        ConfigCommand
    }  command_type_t;

    static struct
    {
        command_type_t     type;
        int                need_parameters;
        char *             syntax_token;
        command_handler_t  handler;
    }
    command[] =
    {
        { NormalCommand, 0, ATM25info_Syntax,		atm_info },
        { NormalCommand, 0, ATM25connections_Syntax,	Connection::DisplayAll },
        { NormalCommand, 0, ATM25boson_Syntax,		boson_display_info },
        { NormalCommand, 0, ATM25pibs_Syntax,		dci_enumerate_pibs },
        { NormalCommand, 0, ATM25trail_Syntax,		boson_display_trail },
        { NormalCommand, 1, ATM25cci_Syntax,		atm_cci },
        { NormalCommand, 0, ATM25listen_Syntax,		NULL },
        { NormalCommand, 0, ATM25status_Syntax,		boson_display_status },
        { NormalCommand, 0, ATM25buffers_Syntax,	mpeg_display_buffers },
        { NormalCommand, 1, ATM25pvc_Syntax,		atm_pvc },
        { NormalCommand, 1, ATM25pvcdelete_Syntax,	atm_pvcdelete },
        { ConfigCommand, 1, ATM25arp_Syntax,		atm_conf_arp },
        { ConfigCommand, 0, ATM25llc_Syntax,		atm_conf_llc },
        { ConfigCommand, 0, ATM25vc_Syntax,		atm_conf_vc },
        { NormalCommand, 0, ATM25data_Syntax,		NULL },
        { NormalCommand, 1, ATM25changebufs_Syntax,	atm_changebufferpool },
        { ConfigCommand, 1, ATM25bw_Syntax,		atm_changeupstreambandwidth },
        { NormalCommand, 1, ATM25svc_Syntax,		command_svc },
        { NormalCommand, 1, ATM25svcdelete_Syntax,	command_svcdelete }

        #ifdef DEBUGLIB
        ,
        { NormalCommand, 1, NULL,			debugon },
        { NormalCommand, 1, NULL,			debugoff }
        #endif
    };

    _kernel_oserror *  e = NULL;


    M_unused (pw);
    MemCheck_RegisterMiscBlock_StringCR (arg_string);

    if (cmd_no < M_array_size (command))
    {
        int                need_parameters = command[cmd_no].need_parameters;
        command_handler_t  handler = command[cmd_no].handler;

        if (command[cmd_no].type == ConfigCommand)
        {
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                if (command[cmd_no].syntax_token)
                {
                    const char *  msg = message_lookup (command[cmd_no].syntax_token);

                    if (msg)
                    {
                        _swix (OS_PrettyPrint,
                               _IN (0),

                               msg);
                    }
                }
                handler = NULL;   /* don't need to pass to command handler */
            }
            else if (arg_string == arg_STATUS)
            {
                argc = ConfigCommand_Status;
                need_parameters = 0;
            }
        }

        if (handler)
        {
            char **  argv = NULL;
            char *   w_arg_string = NULL;

            if (need_parameters && argc > 0)
            {
                w_arg_string = str_ctrl_dup (arg_string);
                if (w_arg_string == NULL)
                {
                    e = error_int_to_os (Error_ATM_NoMemory);
                    goto error;
                }

                argv = arg_array_from_string (w_arg_string, &argc);
                if (argv == NULL)
                {
                    free (w_arg_string);
                    e = error_int_to_os (Error_ATM_NoMemory);
                    goto error;
                }
            }

            e = (*handler) (argc, argv);

            /* Only try to interpret the error if:
             *     There is an error at all!
             *     If the error is not one of the 'special' pointer
             *       values understood by RISC OS
             */
            if (e &&
                e != configure_BAD_OPTION &&
                e != configure_NUMBER_NEEDED &&
                e != configure_TOO_LARGE &&
                e != configure_TOO_MANY_PARAMS)
            {
                /* normal error block pointer */

                switch (e->errnum)
                {
                    case ErrorNumber_Syntax:
                    {
                        const char *  msg;

                        msg = message_lookup (command[cmd_no].syntax_token);
                        if (msg)
                        {
                            strncpy (e->errmess, msg, sizeof (e->errmess) - 1);
                        }
                        break;
                    }

                    default:
                        break;
                }
            }

            if (argv)
            {
                free (argv);
            }

            if (w_arg_string)
            {
                free (w_arg_string);
            }
        }
    }

error:
    MemCheck_UnRegisterMiscBlock (arg_string);
    return e;
}

void setcallback(void)
{
    if (callbackflag == 0) {
        callbackflag = 1;
        if (callback((int (*)(void)) callb_entry) != 0)
            callbackflag = 0;
    }
}

int callback(int (* func)(void))
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    return (_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
}

_kernel_oserror * callb_handler(_kernel_swi_regs *r, void *pw)
{
    static char echo_msg[] = "OK\n";

    M_unused (r);
    M_unused (pw);

    if (callbackflag == 0)
    {
        return (NULL);
    }

    callbs++;
    callbackflag = 0;

    if (do_start) {  /* DCI Start-up callback from module init code */
        callb_startups++;

        do_start = 0;
        dci_driver_status (0);
    }

    #if 0
    if(echo_ack)
    {
      echo_ack = 0;
      callb_echos++;
      asm_write_fifo(ip_echo, AS_DATA_END, (unsigned char *)echo_msg, 3, BlockToARMAddr);
    }
    #endif


    if (do_local_arp)
    {
       callb_arps++;
       do_local_arp = 0;
       local_arp();
    }

    if (do_atmarp)
    {
        inatmarp_request ();
        do_atmarp = 0;
    }

    mpeg_send_buffers ();
    return (NULL);
}

/* this routine sits on tickerV (OS_CallEvery) and clears any unused MAST connections */
_kernel_oserror *ticker_handler(_kernel_swi_regs *r, void *pw)
{
    M_unused (r);
    M_unused (pw);

    ticker_tally++;

    Connection::CloseUnused ();

    return NULL;
}

/* this routine sets it up */
int enable_ticker_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = ticker_period;
  r.r[1] = (int)ticker_entry;
  r.r[2] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_CallEvery, &r, &r) != 0 ? -1 : 0);

}

/* this routine shuts it down */
int disable_ticker_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = (int)ticker_entry;
  r.r[1] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_RemoveTickerEvent, &r, &r) != 0 ? -1 : 0);
}


#ifdef DHCP

void  service_internet_status (_kernel_swi_regs *  r)
{
    switch (r->r[0])    // Sub-reason code
    {
        case InternetStatus_DynamicBootStart:
        {
            const Dib *   dib = (Dib *) r->r[3];

            if (dci_is_our_dib (dib))
            {
                unsigned char *  dhcp_req            = (unsigned char *) r->r[4];
                size_t           dhcp_req_size       = (size_t) r->r[5];
                size_t           dhcp_opt_end_offset = (size_t) r->r[6];

                dhcp_discover (dhcp_req,
                               dhcp_req_size,
                               dhcp_opt_end_offset);
            }

            break;
        }

        case InternetStatus_DynamicBootRequest:
        {
            const Dib *   dib = (Dib *) r->r[3];

            if (dci_is_our_dib (dib))
            {
                unsigned char *  dhcp_req         = (unsigned char *) r->r[4];
                size_t           dhcp_req_size    = (size_t) r->r[5];
                unsigned char *  dhcp_offer       = (unsigned char *) r->r[6];
                size_t           dhcp_offer_size  = (size_t) r->r[7];

                dhcp_request (dhcp_req,
                              dhcp_req_size,
                              dhcp_offer,
                              dhcp_offer_size);
            }
            break;
        }

        default:
            break;
    }
}

#endif

