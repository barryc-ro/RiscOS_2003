/*      MODULE.C

Project : ATML ATM25 card driver

Purpose: Risc OS module type stuff

History:

Date      Who     Description of change
===========================================
20/1/97    CP      Picked up the existing code, added header.

                   Modified calls to init_bs_buffers to reflect changes made
                   to the function in buffer.c

                   Replaced all occurrences of BS_BUFFER_SIZE with
                   bs_buffer_size_G, and imported the variable.

21/1/97    CP      Added changebufferpool CLI to CLIhandler

28/1/97    CP      Added goof-proofing veneer for asm_get_msg().

22/12/97   CP      Fixed tragically broken chaindib structure (used in
                   enumerate driver service call).  It was a global, but
                   should have been dynamically allocated since the calling
                   routine frees the memory!

                   Removed a stray debugging printf from the IRQ handler.
                   This was crashing the box whenever mbufs could not be
                   allocated.

                   Tidied up #includes, using <...> where appropriate.

6/2/98     CP      Added new command to use NVRAM for bandwidth

30/4/98    CP      Added cmhg.h, which is auto-generated by cmhg
                   Fixed calls to cmhg functions

28/5/98    CP      Changed definition of swi base to ATM_00 from cmhg.h

1/6/98     CP      Moved handling of chaindibs entirely within service
                   handler (there's a possibility that memory could be yanked
                   from under us otherwise!).  Fixed chaindib handling so it
                   works properly with multiple NICs (previously it assumed
                   that it was the only dib on the block!)

5/6/98     CP      Added definition of dib.dib_inquire.

                   Restructured SWI handler to be more robust.

22/10/98   CP      Added stats SWI to handler.
                   Changed Inquire word to reflect nature of ATM.

***************************************************************************/

#include <ctype.h>
#include "kernel.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "swis.h"

extern "C"
{
    #include "sys/errno.h"
    #include "sys/types.h"
    #include "sys/mbuf.h"
    #include "sys/dcistructs.h"
}

#include "callx/callx.h"
#include "DebugLib/DebugLib.h"
#include "MemCheck/MemCheck.h"

#include "DCILib/dciif.h"

#include "atmswis.h"
#include "commands.h"
#include "error.h"
#include "defs.h"
#include "dhcpboot.h"
extern "C"
{
    #include "header.h"
}
#include "module.h"
#include "mbuf.h"
#include "mpeg.h"
#include "nic.h"
#include "utils.h"

#define PnP_RegisterDDI 0xc07c0

enum
{
    ATM25_ProductType = 0x11b
};

enum
{
    Podule_ReadInfo_ROMBaseAddress  = 0x00000010,
    Podule_ReadInfo_ProductType     = 0x00000040,
    Podule_ReadInfo_HardwareAddress = 0x00000080,
    Podule_ReadInfo_EASISpace       = 0x00000200
};

int ip_rx = 0;
int ip_tx = 0;
int mpeg_tx = 0;
int mpeg_rx = 0;
int mpeg_discards1 = 0;
int mpeg_discards2 = 0;
int mpeg_discards3 = 0;

int callbs = 0;
int callb_echos = 0;
int callb_startups = 0;
int callb_arps = 0;

int atm_connections = 0;
int atm_listens = 0;
int arp_count = 0;
int local_arp_count = 0;
int discard_arp_count = 0;
int bcast_arp_count = 0;

int streamhandle;

void *  module_wsp = 0;




// =============================================================================
// Function prototype declarations

extern "C" void *  messages_data (void);

#ifdef DHCP
static void  service_internet_status (_kernel_swi_regs *  r);
#endif

extern "C" void  ______main ();



// =============================================================================
// Function definitions

#ifdef MemCheck_MEMCHECK

static int  memcheck_vprintf (void *        reference,
                              const char *  format,
                              va_list       args)
{
    dvprintf (("", format, args));
    return 0;
}

#endif


int main (void)
{
    return 0;
}

#ifdef DEBUG
_kernel_oserror *  debugon (int argc, char *  argv[])
{
    M_unused (argc);
    M_unused (argv);
    debug_initialise ("", "atm", NULL);
    debug_set_options (0, 0, 0);
    debug_output_device (TML_OUTPUT);
    //debug_initialise_trace (TML_OUTPUT, "memcheck*");
    return 0;
}




_kernel_oserror *  debugoff (int argc, char *  argv[])
{
    M_unused (argc);
    M_unused (argv);
    debug_terminate ();
    return 0;
}
#endif




/*
 * Module Initialization code.
 */
_kernel_oserror *module_init (const char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *  e;
    int                podule;
    int                product_type;
    int                number_podules;
    unsigned int       podule_address;
    int                error = 0;
    //NIC *              nic;

    M_unused (cmd_tail);
    M_unused (pbase);

    // This hack is required for C++ modules to ensure that global objects
    // are initialised correctly.
    main ();

    module_wsp = pw;

    //debugon (0, 0);

    MemCheck_Init ();
    MemCheck_RedirectToFunction (memcheck_vprintf, 0);
    MemCheck_SetStoreMallocFunctions (1);
    MemCheck_InterceptSCLStringFunctions();
    MemCheck_SetQuitting (0, 0);
    MemCheck_SetAccessQuitting (0, 0);
    // Don't output blocks on every diagnostic.  A lot of diagnostics
    // are produced because of MemCheck faulting accesses to externally
    // supplied mbuf data structures. There are too many instances of
    // these to make it feasible to register them all as misc blocks.
    MemCheck_SetAutoOutputBlocksInfo (0);

    #ifndef ROM
    e = _swix (ResourceFS_RegisterFiles, _IN (0), messages_data ());
    if (e)
    {
        goto os_error;
    }
    #endif

    e = message_open_file ();
    if (e)
    {
        goto os_error;
    }

    callx_init (pw);

    // Find all ATM25 podules
    e = _swix (Podule_ReturnNumber, _OUT (0), &number_podules);
    if (e)
    {
        if (e)
        {
            goto os_error;
        }
    }

    for (podule = 0; podule < number_podules; ++podule)
    {
        if (_swix (Podule_ReadInfo,
                   _INR (0, 3),
                   Podule_ReadInfo_ProductType,
                   &product_type,
                   sizeof (int),
                   podule) == NULL && product_type == ATM25_ProductType)
        {
            e = _swix (Podule_ReadInfo,
                   _INR (0, 3),
                   Podule_ReadInfo_EASISpace,
                   &podule_address,
                   sizeof (unsigned int),
                   podule);
            if (e)
            {
                goto os_error;
            }

            dprintf (("", "found ATM25 NIC in slot %d, address %x\n",
                      podule, podule_address));

            if (new NIC (podule, podule_address, e))
            {
                if (e)
                {
                    goto os_error;
                }
            }
            else
            {
                error = Error_ATM_NoMemory;
                goto internal_error;
            }
        }
    }

    MbufController::Start ();

    return NULL;

internal_error:
    e = error_int_to_os (error);

os_error:
    // Clean up if an error occurs during initialisation.  It's grotty, but
    // probably the least grotty solution given than the finalisation code
    // doesn't get called in this case.

    NIC::DestroyAll ();

    message_close_file ();

    #ifndef ROM
    _swix (ResourceFS_DeregisterFiles, _IN (0), messages_data ());
    #endif

    return e;
}

/* Module Finalization code */

_kernel_oserror * module_final (int fatal, int podule, void *pw)
{
    M_unused (fatal);
    M_unused (pw);
    M_unused (podule);


    NIC::DestroyAll ();

    callx_remove_all_callafters ();
    callx_remove_all_calleverys ();
    callx_remove_all_callbacks ();

    message_close_file ();
    MemCheck_OutputBlocksInfo ();
    MemCheck_Finalise ();


    #ifndef ROM
    _swix (ResourceFS_DeregisterFiles, _IN (0), messages_data ());
    #endif

    debug_terminate ();

    return NULL;
}




/* Module Service Call handler */
void module_sc_handler (int sn, _kernel_swi_regs *r, void *pw)
{
    M_unused (pw);

    switch (sn)
    {
        #ifdef DHCP
        case Service_InternetStatus:
            service_internet_status (r);
            break;
        #endif

        case Service_EnumerateNetworkDrivers:
            r->r[0] = (int) DCIInterface::EnumerateNetworkDrivers (
                                (struct chaindib *) r->r[0]);
            break;

        case Service_MbufManagerStatus:
            MbufController::ManagerStatus (r->r[0]);
            break;

        /*
         * Service_PreReset - reset card prior to system shutdown
         */
        case Service_PreReset:
            NIC::ResetAll ();
            break;

        /* add pre_reset code to handle stb2 standby state */
        default:
            break;
    }
}


/* Module SWI handler */
_kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    typedef  int (*swi_handler_t) (_kernel_swi_regs *const );

    int                error         = 0;
    _kernel_oserror *  os_error      = NULL;
    static swi_handler_t  swi[] =
    {
        swi_dci_version,
        swi_dci_inquire,
        swi_dci_getnetworkmtu,
        swi_dci_setnetworkmtu,
        swi_dci_transmit,
        swi_dci_filter,
        swi_dci_stats,
        swi_dci_multicastrequest,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        swi_get_uni_address,
        atm_empty_buf,
        atm_associateaddress,
        atm_vcconnect,
        atm_vclisten,
        atm_vcclose,
        atm_vcstatus,
        atm_bootconfig
    };

    M_unused (pw);
    MemCheck_RegisterMiscBlock (r, sizeof (_kernel_swi_regs));

    if (swinum < M_array_size (swi) && swi[swinum])
    {
        error = (*swi[swinum]) (r);
    }
    else
    {
        dprintf (("", "unknown SWI %d\n", swinum - ATM_00));
        os_error = error_BAD_SWI;
    }

    if (error != 0)
    {
        dprintf (("", "SWI returned error %d\n", error));
        os_error = error_int_to_os (error);
    }

    MemCheck_UnRegisterMiscBlock (r);

    return os_error;
}




/* -----------------------------------------------------------------------------
   str_ctrl_dup

   Create a 0 terminated duplicate of a control character terminated string.
   Client is responsible for freeing memory.

   Inputs
   s: pointer to string to duplicate

   Returns
   success: pointer to duplicated string
   failure: NULL
 */

static char *str_ctrl_dup (const char *const s)
{
    size_t len = 0;
    const char *c = s;
    char *p;

    while (!iscntrl (*c))
    {
        ++c;
        ++len;
    }

    p = malloc (len + 1);
    if (p)
    {
        memcpy (p, s, len);
        p[len] = 0;
    }

    return p;
}




static char **  arg_array_from_string (char *      arg_string,
                                       int *const  argc)
{
    char **  argv = NULL;
    char *   p;

    /* Count arguments */
    *argc = 0;
    p = arg_string;
    while (*p)
    {
        /* Skip leading space */
        while (isspace (*p))
        {
            p++;
        }

        /* Increment argument counter */
        (*argc)++;

        /* Skip over argument */
        while (*p && !isspace (*p))
        {
            p++;
        }
    }

    /* Create and fill argument array */
    argv = (char **) malloc ( ((*argc) + 1) * sizeof (char *));
    if (argv)
    {
        char **  arg = argv;

        p = arg_string;
        while (*p)
        {
            /* Skip leading space */
            while (isspace (*p))
            {
                p++;
            }

            /* Store pointer to this argument */
            *arg++ = p;

            /* Skip over argument */
            while (*p && !isspace (*p))
            {
                p++;
            }

            /* 0-terminate argument */
            if (*p)
            {
                *p++ = 0;
            }

            dprintf (("", "%s\n", *(arg - 1)));
        }

        /* 0-terminate argument array */
        *arg = 0;
    }

    return argv;
}




_kernel_oserror *atm_cli_handler (const char *arg_string, int argc, int cmd_no, void *pw)
{
    typedef _kernel_oserror *  (*command_handler_t) (int, char *[]);

    typedef enum
    {
        NormalCommand,
        ConfigCommand
    }  command_type_t;

    static struct
    {
        command_type_t     type;
        int                need_parameters;
        char *             syntax_token;
        command_handler_t  handler;
    }
    command[] =
    {
        // The order of commands in this array must match the order the commands
        // are defined in the CMHG header file.

        { NormalCommand, 0, ATM25info_Syntax,		command_info },
        { NormalCommand, 0, ATM25connections_Syntax,	command_connections },
        { NormalCommand, 0, ATM25boson_Syntax,		command_boson },
        { NormalCommand, 0, ATM25trail_Syntax,		command_trail },
        { NormalCommand, 1, ATM25cci_Syntax,		command_cci },
        { NormalCommand, 0, ATM25buffers_Syntax,	mpeg_display_buffers },
        { NormalCommand, 1, ATM25pvc_Syntax,		command_pvc },
        { NormalCommand, 1, ATM25pvcdelete_Syntax,	command_pvcdelete },
        { ConfigCommand, 1, ATM25arp_Syntax,		command_configure_arp },
        { ConfigCommand, 0, ATM25llc_Syntax,		command_configure_llc },
        { ConfigCommand, 0, ATM25vc_Syntax,		command_configure_vc },
        { NormalCommand, 1, ATM25changebufs_Syntax,	command_changebufs },
        { ConfigCommand, 1, ATM25bw_Syntax,		command_configure_bw },
        { NormalCommand, 1, ATM25svc_Syntax,		command_svc },
        { NormalCommand, 1, ATM25svcdelete_Syntax,	command_svcdelete }

        #ifdef DEBUG
        ,
        { NormalCommand, 0, ATM25status_Syntax,		command_status },
        { NormalCommand, 1, NULL,			debugon },
        { NormalCommand, 1, NULL,			debugoff }
        #endif
    };

    _kernel_oserror *  e = NULL;


    M_unused (pw);
    MemCheck_RegisterMiscBlock_StringCR (arg_string);

    if (cmd_no < M_array_size (command))
    {
        int                need_parameters = command[cmd_no].need_parameters;
        command_handler_t  handler = command[cmd_no].handler;

        if (command[cmd_no].type == ConfigCommand)
        {
            if (arg_string == arg_CONFIGURE_SYNTAX)
            {
                if (command[cmd_no].syntax_token)
                {
                    const char *  msg = message_lookup (command[cmd_no].syntax_token);

                    if (msg)
                    {
                        _swix (OS_PrettyPrint,
                               _IN (0),

                               msg);
                    }
                }
                handler = NULL;   /* don't need to pass to command handler */
            }
            else if (arg_string == arg_STATUS)
            {
                argc = ConfigCommand_Status;
                need_parameters = 0;
            }
        }

        if (handler)
        {
            char **  argv = NULL;
            char *   w_arg_string = NULL;

            if (need_parameters && argc > 0)
            {
                w_arg_string = str_ctrl_dup (arg_string);
                if (w_arg_string == NULL)
                {
                    e = error_int_to_os (Error_ATM_NoMemory);
                    goto error;
                }

                argv = arg_array_from_string (w_arg_string, &argc);
                if (argv == NULL)
                {
                    free (w_arg_string);
                    e = error_int_to_os (Error_ATM_NoMemory);
                    goto error;
                }
            }

            e = (*handler) (argc, argv);

            /* Only try to interpret the error if:
             *     There is an error at all!
             *     If the error is not one of the 'special' pointer
             *       values understood by RISC OS
             */
            if (e &&
                e != configure_BAD_OPTION &&
                e != configure_NUMBER_NEEDED &&
                e != configure_TOO_LARGE &&
                e != configure_TOO_MANY_PARAMS)
            {
                /* normal error block pointer */

                switch (e->errnum)
                {
                    case ErrorNumber_Syntax:
                    {
                        const char *  msg;

                        msg = message_lookup (command[cmd_no].syntax_token);
                        if (msg)
                        {
                            strncpy (e->errmess, msg, sizeof (e->errmess) - 1);
                        }
                        break;
                    }

                    default:
                        break;
                }
            }

            if (argv)
            {
                free (argv);
            }

            if (w_arg_string)
            {
                free (w_arg_string);
            }
        }
    }

error:
    MemCheck_UnRegisterMiscBlock (arg_string);
    return e;
}
#ifdef DHCP

void  service_internet_status (_kernel_swi_regs *  r)
{
    switch (r->r[0])    // Sub-reason code
    {
        case InternetStatus_DynamicBootStart:
        {
            const Dib *   dib = (Dib *) r->r[3];

            if (dci_is_our_dib (dib))
            {
                unsigned char *  dhcp_req            = (unsigned char *) r->r[4];
                size_t           dhcp_req_size       = (size_t) r->r[5];
                size_t           dhcp_opt_end_offset = (size_t) r->r[6];

                dhcp_discover (dhcp_req,
                               dhcp_req_size,
                               dhcp_opt_end_offset);
            }

            break;
        }

        case InternetStatus_DynamicBootRequest:
        {
            const Dib *   dib = (Dib *) r->r[3];

            if (dci_is_our_dib (dib))
            {
                unsigned char *  dhcp_req         = (unsigned char *) r->r[4];
                size_t           dhcp_req_size    = (size_t) r->r[5];
                unsigned char *  dhcp_offer       = (unsigned char *) r->r[6];
                size_t           dhcp_offer_size  = (size_t) r->r[7];

                dhcp_request (dhcp_req,
                              dhcp_req_size,
                              dhcp_offer,
                              dhcp_offer_size);
            }
            break;
        }

        default:
            break;
    }
}

#endif

