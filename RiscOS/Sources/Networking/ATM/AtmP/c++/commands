/*	COMMANDS.C

Project : ATML ATM25 card driver

Purpose: RiscOS module command handlers.


History:

Date      Who     Description of change
===========================================
20/1/97    CP      Picked up existing code, added header.

	 	  Replaced all occurrences of N_BS_BUFFERS with
		  number_of_bs_buffersG

		  Added call to bswait_init after resizing buffers

29/1/97   CP      Added in a header to each bs_buffer structure.  No-one's
	 	  quite sure what it is, but it's length is defined in
		  buffers.h (around 20 bytes)

30/4/98   CP      Changed arguments for various functions to const inorder to
                  protect incoming data/fit with prototypes defined in cmhg.h

***************************************************************************/
/* commands.c */




// =============================================================================
// Include header files

#include "kernel.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "swis.h"

extern "C"
{
    #include "sys/types.h"
    #include "inetlib.h"
}

#include "DebugLib/debuglib.h"

#include "address.h"
#include "atmswis.h"
#include "boson.h"
#include "connection.h"
#include "defs.h"
#include "error.h"
#include "module.h"
#include "mpeg.h"
#include "nic.h"
#include "nvparams.h"
#include "socket.h"
#include "utils.h"




// =============================================================================
// Function prototype declarations

static int  open_connection (const Connection::Service   service,
                             const u_long                ip_addr,
                             const ATML_SOCKADDR *const  atm_addr);

static int  close_connection (const Connection::Service   service,
                              const ATML_SOCKADDR *const  atm_addr);




// =============================================================================
// Function definitions

/******* atm_changebufferpool **********************************************

Purpose: Change the size of the bs_buffer chain payload.  This will trash the
	 current set of buffers and recreate the new ones using
	 init_bs_buffers().

Inputs:  char * arguments (NULL => display current values)
		-b buffer payload size
		-m memory pool size

Outputs: none

***************************************************************************/

_kernel_oserror *  atm_changebufferpool (int      argc, char *  argv[])
{
    _kernel_oserror *  e;

    if (argc == 0)
    {
        mpeg_display_buffer_pool ();
    }
    else
    {
        unsigned int  memory_pool    = 0;
        unsigned int  buffer_payload = 0;

        while (*argv)
        {
            if ((*argv)[0] != '-')
            {
                e = M_gen_error (ErrorNumber_Syntax);
                return e;
            }

            switch ((*argv)[1])
            {
                case 'b':    /* change the buffer payload */
                    if (!*(++argv))
                    {
                        e = M_gen_error (ErrorNumber_Syntax);
                        return e;
                    }

                    buffer_payload = (unsigned int) strtoul (*argv, NULL, 0);
                    if (buffer_payload == 0) /* validate value */
                    {
                        e = error_gen_tok (Error_ATM_InvalidData, "EBufP");
                        return e;
                    }
                    break;

                case 'm':    /* change the memory pool size */
                    if (!*(++argv))
                    {
                        e = M_gen_error (ErrorNumber_Syntax);
                        return e;
                    }
                    memory_pool = (unsigned int) strtoul (*argv, NULL, 0);
                    if (memory_pool == 0) /* validate value */
                    {
                        e = error_gen_tok (Error_ATM_InvalidData, "EBufM");
                        return e;
                    }
                    break;

                default:
                    e = M_gen_error (ErrorNumber_Syntax);
                    return e;
            } /* end switch */

            argv++;
        }; /* end while */

        mpeg_change_buffers (buffer_payload, memory_pool);
    } /* end if */

    return NULL;
}




_kernel_oserror *  atm_info (int  argc, char *  argv[])
{
    M_unused (argc);
    M_unused (argv);

    char  mac_addr[MACAddr_Size * 3] = "unknown";
    num_to_sep_str (NIC::Instance()->GetMACAddr (), MACAddr_Size, mac_addr, ':');
    printf ("MAC addr: %s\n", mac_addr);

    if (nvparams_read_multiproto_enc())
    {
        printf ("IP encapsulation: VC\n\n");
    }
    else
    {
        printf ("IP encapsulation: LLC_SNAP\n\n");
    }

    printf ("Unused circuit check interval: ");
    if (ticker_period)
    {
        printf("%d cS  done %d checks\n", ticker_period, ticker_tally);
    }
    else
    {
        printf("off\n");
    }

    #if 0
    printf ("IP service handle: %d, ECHO service handle: %d, "
            "MPEG service handle:%d\n",
            ip_listen,
            ip_echo,
            mpeg_listen);
    #endif

    printf ("Free socket handles: %d Busy socket handles: %d\n\n",
            service_manager->GetNumberFree(),
            service_manager->GetNumberInUse());

    printf ("IP frames rx: %d (discards: %d, errors: %d, pkts dropped: %d) "
            "tx: %d\n",
            ip_rx, irq_rx_discards, irq_rx_errors,
            irq_ip_pkts_dropped, ip_tx);

    printf ("MPEG frames rx: %d (discards: %d + %d + %d= %d) tx: %d\n\n",
            mpeg_rx,
            mpeg_discards1,
            mpeg_discards2,
            mpeg_discards3,
            mpeg_discards1 + mpeg_discards2 + mpeg_discards3,
            mpeg_tx);

    printf ("ARP: requests: %d (local: %d  discard: %d  bcast: %d)\n\n",
            arp_count,
            local_arp_count,
            discard_arp_count,
            bcast_arp_count);

    printf ("Callbacks: %d (startups: %d echo_acks: %d arps: %d)\n",
            callbs,
            callb_startups,
            callb_echos,
            callb_arps);

    printf ("\nIRQ packets: %d (Cmd: %d, Msg: %d)\n\n",
            boson_rx_pkts,
            boson_cmd_pkts,
            boson_msg_pkts);

    printf ("CloseREQs: %d, CloseACKs: %d, Errors: %d\n"
            "ConnectACKs: %d (refusals: %d, error: %d)\n"
            "ConnectREQs: %d (error: %d, refused: %d, acks: %d)\n"
            "Data: %d, Dataend: %d\n"
            "Errors: %d, Bogus packets: %d\n",
            irq_closes,
            irq_closeds,
            irq_errors,
            irq_connects,
            irq_refusals,
            irq_con_ack_errors,
            irq_connect_reqs,
            irq_con_req_errors,
            irq_con_refusals,
            irq_con_req_acks,
            irq_datas,
            irq_data_ends,
            irq_connection_errors,
            irq_bogus_pkts);

    printf ("IRQ word: %d, Packet HIWM: %d\n",
            irq_packets,
            irq_pkt_hiwm);

    printf ("\nATM Connections: %d, ATM Listens: %d\n",
            atm_connections,
            atm_listens);

    return NULL;
}



#if 0
void atm_mast_show(void)
{
  struct mast *m;
  unsigned char port_string[32];

   printf("MAST connection table:\n");
   for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)

#ifdef LIMIT_TABLES
     if(m->m_port != M_FREE) {
#else
     if(1) {
#endif
            ipuitos(m->m_port, port_string,'.');
            printf("    %s: %d.%d.%d.%d, port: %s  handle: %u",
                    (m->m_status & M_PERMANENT) ? "PVC" : "SVC",
                    m->m_macadr[2], m->m_macadr[3],
                    m->m_macadr[4], m->m_macadr[5], port_string,
                    m->m_socket_handle);

            if(m->m_status != 0) {
              printf("     [ ");
              if(m->m_status & M_SWITCHED) printf("M_SWITCHED ");
              if(m->m_status & M_PERMANENT) printf("M_PERMANENT ");
              if(m->m_status & M_USED) printf("M_USED ");
              if(m->m_status & M_PENDING) printf("M_PENDING ");
              if(m->m_status & M_CONNECT) printf("M_CONNECT ");
              if(m->m_status & M_LISTEN) printf("M_LISTEN ");
              if(m->m_status & M_PURGE) printf("M_PURGE ");
              printf(" ]");
            }

            if (m->m_muxtype)
                printf(", muxtype: %s", m->m_muxtype == LLC_MULTIPLEX ? "LLC" : "VC");
            else printf(", muxtype: <uninitialised>");
            if ((m->m_status & M_PERMANENT) == 0) {
                if(m->m_originator) printf(", Party: ORIGINATOR (local port: %s)",
                		    (ipuitos(m->m_local_port, port_string, '.'), port_string));
                else printf(", Party: CALLEE (local port: %s)",
                     	       	    (ipuitos(m->m_local_port, port_string, '.'), port_string));
            }
            else {
                printf(", VCN: %u (emulating port: %s)", m->m_pvc_vcn,
                	       	    (ipuitos(m->m_port, port_string, '.'), port_string));
            }
            printf("\n");
     }
}
#endif








_kernel_oserror *  atm_cci (int argc, char * argv[])
{
    _kernel_oserror *  e = NULL;

    if (argc == 1)
    {
        int  n = atoi (argv[0]);

        if (n < 0 || n > 300)
        {
            e = error_gen_tok (Error_ATM_InvalidData, "ECCIRange");
        }
        else
        {
            if (ticker_period)
            {
                disable_ticker_handler (); /* if the ticker handler is running, kill it */
            }

            ticker_period = 100 * n; /* set new ticker interval */

            if (n)
            {
                enable_ticker_handler (); /* if new interval <>0, re-enable ticker handler */
            }
        }
    }

    return e;
}




#if 0
void atm_listen(void)
{
  struct listen *l;
  unsigned char listen_port[32];

  printf("ATM25 Listening sockets:\n");
  for(l = &listentab[0]; l < &listentab[LISTENTAB_SIZE]; l++) {

#ifdef LIMIT_TABLES
    if(l->handle) {
#else
    if(1) {
#endif
      ipuitos(l->local_port, listen_port, '.');
      printf("Handle: %d  Local port: %s Muxtype: %s", l->handle, listen_port, (l->muxtype==LLC_MULTIPLEX)?"LLC":"VC");
      if(l->flags!=0) {
        printf(" [ ");
        if(l->flags & L_SYSTEM) printf("L_SYSTEM ");
        if(l->flags & L_REANIMATE) printf("L_REANIMATE ");
        printf(" ] ");
      }
      printf("\n");
    }
  }
}
#endif




_kernel_oserror *  atm_pvc (int argc, char *  argv[])
{
    int                   error;
    _kernel_oserror *     e = NULL;
    ATML_SOCKADDR         atm_addr;
    Connection::Service   service;
    u_long                ip_addr;

    M_unused (argc);

    memset (&atm_addr, 0, sizeof (ATML_SOCKADDR));
    ip_addr = inet_addr (argv[0]);
    service = (Connection::Service) strtoul (argv[1], NULL, 0);
    atm_addr.pvc.satm_family = AF_ATML_PVC;
    atm_addr.pvc.satm_pvc = (S32) strtol (argv[2], NULL, 0);

    error = open_connection (service, ip_addr, &atm_addr);
    if (error)
    {
        e = error_int_to_os (error);
    }

    return e;
}




_kernel_oserror *  atm_pvcdelete (int argc, char *  argv[])
{
    ATML_SOCKADDR          atm_addr;
    Connection *           connection = 0;
    Connection::Service    service;
    int                    error = 0;
    _kernel_oserror *      e = NULL;

    M_unused (argc);

    memset (&atm_addr, 0, sizeof (ATML_SOCKADDR));
    atm_addr.pvc.satm_family = AF_ATML_PVC;
    atm_addr.pvc.satm_pvc = (S32) strtol (argv[2], NULL, 0);
    service = (Connection::Service) strtoul (argv[1], NULL, 0);
    error = close_connection (service, &atm_addr);

    {
        e = error_int_to_os (error);
    }

    return e;
}




_kernel_oserror *  command_svc (int argc, char *  argv[])
{
    int                   error;
    _kernel_oserror *     e = NULL;
    ATML_SOCKADDR         atm_addr;
    Connection::Service   service;
    u_long                ip_addr;

    memset (&atm_addr, 0, sizeof (ATML_SOCKADDR));
    ip_addr = inet_addr (argv[0]);
    service = (Connection::Service) strtoul (argv[1], NULL, 0);
    error   = atm_aton (argv[2], atm_addr.atm.satm_number.contents);
    if (!error)
    {
        atm_addr.atm.satm_family = AF_ATML_ATM;
        atm_addr.atm.satm_number.type = ATML_NSAP;
        atm_addr.atm.satm_number.numofdigits = NSAPAddr_Size;

        if (argc > 3)
        {
            atm_addr.atm.satm_port = (S32) strtol (argv[3], NULL, 0);
        }
        else
        {
            atm_addr.atm.satm_port = 0;
        }

        #if 0
        atm_addr.atm.blli_len = 1;
        atm_addr.atm.blli[0] = 0xcc;
        #endif

        error = open_connection (service, ip_addr, &atm_addr);
    }


    if (error)
    {
        e = error_int_to_os (error);
    }

    return e;
}




_kernel_oserror *  command_svcdelete (int argc, char *  argv[])
{
    ATML_SOCKADDR          atm_addr;
    Connection::Service    service;
    int                    error = 0;
    _kernel_oserror *      e = NULL;

    M_unused (argc);

    memset (&atm_addr, 0, sizeof (ATML_SOCKADDR));
    service = (Connection::Service) strtoul (argv[1], NULL, 0);
    error   = atm_aton (argv[2], atm_addr.atm.satm_number.contents);
    if (!error)
    {
        atm_addr.atm.satm_family = AF_ATML_ATM;
        atm_addr.atm.satm_number.type = ATML_NSAP;
        atm_addr.atm.satm_number.numofdigits = NSAPAddr_Size;
        error = close_connection (service, &atm_addr);
    }

    if (error)
    {
        e = error_int_to_os (error);
    }

    return e;
}




#if 0
void atm_mast_data(void)
{
  struct mast *m;
  unsigned char port_string[32];

   printf("MAST connection data stats:\n");
   for (m = &masttab[0]; m < &masttab[MASTTAB_SIZE]; m++)

#ifdef LIMIT_TABLES
     if(m->m_port != M_FREE) {
#else
     if(1) {
#endif
            ipuitos(m->m_port, port_string,'.');
            printf("    %s: %d.%d.%d.%d, port: %s  handle: %u",
                    (m->m_status & M_PERMANENT) ? "PVC" : "SVC",
                    m->m_macadr[2], m->m_macadr[3],
                    m->m_macadr[4], m->m_macadr[5], port_string,
                    m->m_socket_handle);

	    printf("  received by driver: %d lost by stack: %d (%d%% loss)\n",
	    		     m->m_datacount, m->m_datalost, m->m_datacount?(100*m->m_datalost)/m->m_datacount:0);
     }

}
#endif




int  open_connection (const Connection::Service   service,
                      const u_long                ip_addr,
                      const ATML_SOCKADDR *const  atm_addr)
{
    int  error = ip_map_add (ip_addr, atm_addr);
    if (!error)
    {
        // Don't need to know the handle - user will refer to
        // connection via command line paramters
        ClientConnection *  handle = new ClientConnection (atm_addr,
                                                           service,
                                                           0,
                                                           0,
                                                           Connection::Local,
                                                           error);
        if (handle)
        {
            if (error)
            {
                delete handle;
                handle = 0;
            }
            else
            {
                dprintf (("", "issuing connect\n"));
                Connection *  connection = handle->GetConnection ();
                connection->Connect ();
            }
        }
        else
        {
            error = Error_ATM_NoMemory;
        }
    }

    return error;
}




int  close_connection (const Connection::Service   service,
                       const ATML_SOCKADDR *const  atm_addr)
{
    int           error = 0;
    Connection *  connection = 0;

    switch (service)
    {
        case Connection::Service_MPEG_AAL5:
            connection = MPEGConnection::Get ();
            break;

        case Connection::Service_IP_LLC:
        case Connection::Service_IP_VC:
        {
            const unsigned char *  mac_addr = mac_from_atm (atm_addr);
            if (mac_addr)
            {
                connection = (Connection *) mac_map_find_conn (mac_addr);
            }
            else
            {
                error = Error_ATM_NoSuchConnection;
            }
            break;
        }

        default:
            break;
    }

    if (!error && connection)
    {
        connection->Close ();
    }

    return error;
}
