/* File:    service.c++
   Purpose:
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-03-24: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include <limits.h>

#include "DebugLib/DebugLib.h"

// Local
#include "atm.h"
#include "command.h"
#include "service.h"




// =============================================================================
// Constants definitions

#define UNSIGNED_INT_BITS  (sizeof (unsigned int) * CHAR_BIT)

/* Assembler code uses 1 bit per socket handle - need to ensure we allocate a
 * whole number of words.  2 extra words needed for housekeeping.
 */

#define WORKSPACE_SIZE     (((MaxHandles + (UNSIGNED_INT_BITS - 1)) / \
                             UNSIGNED_INT_BITS) + 2)




// =============================================================================
// Macro definitions




// =============================================================================
// Global variables

ServiceManager *  service_manager;




// =============================================================================
// Static declarations

ServiceManager *  ServiceManager::instance = 0;
Service *         ServiceManager::service[MaxHandles];
unsigned int      ServiceManager::handle_wspace[WORKSPACE_SIZE];




// =============================================================================
// Function prototype declarations

extern "C"
{
    extern int init_handle_handler (unsigned int *, unsigned int, unsigned int);
    extern int get_handle (unsigned int *);
    extern int free_handle (unsigned int *, int);
    extern int free_cmd_handle (unsigned int *);
    extern int enumerate_free_handles (unsigned int *);
    extern int enumerate_busy_handles (unsigned int *);
}





// =============================================================================
// Member function definitions

/* -----------------------------------------------------------------------------
   ServiceManager_DespatchMessage

   This function provides the interface between the C code that receives
   data from the hardware and the C++ code that processes it.

   Find out which service a message is destined for and despatch it.
 */

extern "C"  MessageHandlerRC  ServiceManager_DespatchMessage (NICMessage    msg,
                                                              NICExtension  ext)
{
    MessageHandlerRC  rc;

    Service *  service = service_manager->GetService (msg.common.handle);
    if (service)
    {
        rc = service->MessageHandler (msg, ext);
    }
    else
    {
        /* Unknown / unsupported service - no sockets bound to it so
         * should be impossible - probably junk data.
         */
        rc = FlushFIFO;
    }

    return rc;
}




ServiceManager *  ServiceManager::Create (int &  error)
{
    ServiceManager *  service_manager;

    error = 0;
    service_manager = new ServiceManager (error);
    if (service_manager)
    {
        if (error)
        {
            delete service_manager;
            service_manager = 0;
        }
    }
    else
    {
        error = Error_ATM_NoMemory;
    }

    return service_manager;
}




ServiceManager::ServiceManager (int &  error)
{
    error = 0;
    for (int i = 0; i < MaxHandles; ++i)
    {
        service[i] = 0;
    }

    if (init_handle_handler (handle_wspace,
                             MaxHandles,
                             sizeof (handle_wspace)) < 0)
    {
        error = Error_ATM_ServiceManager;
    }
}




ServiceManager::~ServiceManager ()
{
}




int  ServiceManager::GetHandle (int &  handle)
{
    int error = 0;

    handle = get_handle (handle_wspace);
    if (handle < 0)
    {
        error = Error_ATM_HandleAlloc;
    }

    return error;
}




void  ServiceManager::RegisterService (Service *  service)
{
    this->service[service->GetHandle()] = service;
}




void  ServiceManager::DeregisterService (Service *  service)
{
    int  handle = service->GetHandle ();
    command_service->TxDetach (handle);
    (void) free_handle (handle_wspace, handle);
    this->service[handle] = 0;
}




Service *  ServiceManager::GetService (const int  handle)
{
    return service[handle];
}




int  ServiceManager::GetNumberFree ()
{
    return enumerate_free_handles (handle_wspace);
}




int  ServiceManager::GetNumberInUse ()
{
    return enumerate_busy_handles (handle_wspace);
}




Service::Service (const int   service_number,
                  int &       error,
                  int         handle)
    : service_number (service_number)
{
    error = 0;

    if (handle == -1)
    {
        error = service_manager->GetHandle (handle);
    }

    if (!error)
    {
        this->handle = handle;

        dprintf (("", "allocating handle %d to service %d\n",
                  handle, service_number));
    }
}




void  Service::Attach ()
{
    service_manager->RegisterService (this);
    command_service->TxAttachx (service_number, handle);
}




Service::~Service ()
{
    service_manager->DeregisterService (this);
}




int  Service::GetHandle ()
{
    return handle;
}
