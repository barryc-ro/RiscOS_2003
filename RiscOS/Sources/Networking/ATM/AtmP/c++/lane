/* File:    lane.c++
   Purpose: LAN Emulation
   Author:  Ben Laughton

   Copyright 1999 Element 14 Ltd.

   This material is the confidential trade secret and proprietary information
   of Element 14 Ltd. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Element 14 Ltd.
   All rights reserved.

   History:

   1999-04-21: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include <stdlib.h>
#include <string.h>

// TCPIPLibs
extern "C"
{
    #include "sys/types.h"
    #include "sys/errno.h"
    #include "sys/mbuf.h"
    #include "sys/dcistructs.h"
    #include "inetlib.h"
    #include "netinet/in.h"
    #include "net/if.h"
    #include "net/if_arp.h"
    #include "netinet/if_ether.h"
}

// Misc
#include "DebugLib/debuglib.h"

// Local
#include "boson.h"
#include "dci.h"
#include "defs.h"
#include "lane.h"




// =============================================================================
// Constants definitions

#define MAX_PACKET_SIZE      1514
#define RX_BUFFS             10
#define ETHER_HDR_SIZE       14
#define ETHER_SRC_ADR_OFFSET 6
#define ETHER_DST_ADR_OFFSET 0
#define ETHER_ADR_SIZE       6
#define ETHER_TYPE_OFFSET    12
#define ETHER_TYPE_SIZE      2

enum
{
    ALE_SET_MCAST,
    ALE_GET_MAC,
    ALE_RX_DROPPED,
    ALE_TX_DROPPED,
    ALE_DATA,
    ALE_SET_MAC,
    ALE_OKTORECV,
    ALE_CONFIG
};




// =============================================================================
// Macro definitions




// =============================================================================
// Global variable declarations

static unsigned int     lane_rxdropped = 0;
static unsigned int     lane_txdropped = 0;
static unsigned int     lane_oktorecv_invalid = 0;
static unsigned int     nic_buffers = 0;
static unsigned int     lane_rx_buffs = 0;
static unsigned int     lane_min_rx_buffs = RX_BUFFS;

LANEService *  lane_service;




// =============================================================================
// Function prototype declarations

extern int callproto (Dib *, struct mbuf *, void (*pi_handler)(), int);

static struct mbuf *  convert_to_dci4_header (const unsigned int  type,
                                              struct mbuf *       m0,
                                              u_char *            raw_hdr);

static void dumpm(struct mbuf *m0, int pktlen);

static void dump_pkt (u_char *  rptr, int pktlen);




// =============================================================================
// Member function definitions

/* -----------------------------------------------------------------------------
 */

int  LANEService::Create ()
{
    int  error = 0;

    if (!lane_service)
    {
        lane_service = new LANEService (error);
        if (lane_service)
        {
            if (error)
            {
                delete lane_service;
                lane_service = 0;
            }
            else
            {
                lane_service->Attach ();
            }
        }
    }

    return error;
}




LANEService::LANEService (int &  error)
    : Service (LAN_SERVICE, error)
{
    if (!error)
    {
        Attach ();

        // Tell the NIC about the number of receive buffers we have free.  This is
        // 'fake' because we write the data straight into MBUFs anyway - if an
        // MBUF allocation fails we tell the NIC we have run out of buffers.
        for (int i = 0; i < RX_BUFFS; ++i)
        {
            TxOKToRecv();
        }
    }
}




void  LANEService::TxOKToRecv ()
{
    boson_block_write (CMD_MSG (handle, ALE_OKTORECV, 0));
    ++lane_rx_buffs;
}




int  LANEService::TxData (const int            new_header,
                          const u_char *const  src,
                          const u_char *const  dst,
                          int                  type,
                          struct mbuf *        m)
{
    static unsigned char  txbuff[MAX_PACKET_SIZE];
    unsigned int          size;

    if (nic_buffers == 0)
    {
        return ENOBUFS;
    }

    /* Copy MBUF chain into contiguous block in memory for sending to the
     * NIC.
     * !!! This is inefficient - should write a routine to transfer data
     * directly from MBUF to NIC.
     */

    size = mbctl.count_bytes (&mbctl, m);
    dprintf (("", "packet size: %u\n", size + ETHER_HDR_SIZE));
    if (size + ETHER_HDR_SIZE > MAX_PACKET_SIZE)
    {
        return EMSGSIZE;
    }

    if (new_header)
    {
        /* Header info. has changed from previous call */
        memcpy (txbuff + ETHER_DST_ADR_OFFSET,
                dst,
                ETHER_ADR_SIZE);

        memcpy (txbuff + ETHER_SRC_ADR_OFFSET,
                src,
                ETHER_ADR_SIZE);

        type = htons (type);

        memcpy (txbuff + ETHER_TYPE_OFFSET,
                &type,
                ETHER_TYPE_SIZE);
    }

    EXPORT (m, size, txbuff + ETHER_HDR_SIZE);

    size += ETHER_HDR_SIZE;
    dump_pkt (txbuff, size);

    if (asm_write_fifo (handle,
                        ALE_DATA,
                        txbuff,
                        size,
                        BlockToARMAddr) < 0)
    {
        /* run out of FIFO space */
        dprintf (("", "no space in FIFO\n"));
        return ENOBUFS;
    }

    ++ip_tx;
    --nic_buffers;

    return 0;
}




MessageHandlerRC  LANEService::MessageHandler (NICMessage    msg,
                                               NICExtension  ext)
{
    typedef  MessageHandlerRC (LANEService::*  lane_handler) (NICMessage);
    static lane_handler  handler[] =
    {
        0,
        0,
        &LANEService::RxRxDropped,
        &LANEService::RxTxDropped,
        &LANEService::RxData,
        0,
        &LANEService::RxOKToRecv
    };
    MessageHandlerRC  rc;

    M_unused (total_size);

    if (msg.common.command < M_array_size (handler) &&
        handler[msg.common.command])
    {
        rc = (this->*(handler[msg.common.command])) (msg);
    }
    else
    {
        rc = DiscardMsg;
    }

    return rc;
}




MessageHandlerRC  LANEService::RxRxDropped (NICMessage  msg)
{
    M_unused (msg);
    ++lane_rxdropped;
    return HandledMsg;
}



MessageHandlerRC  LANEService::RxTxDropped (NICMessage  msg)
{
    M_unused (msg);
    ++lane_txdropped;
    return HandledMsg;
}



MessageHandlerRC  LANEService::RxOKToRecv (NICMessage  msg)
{
    switch (msg.command.param)
    {
        case 0:
            /* a buffer has become available */
            ++nic_buffers;
            break;

        case 0xffff:
            /* all buffers have been removed */
            nic_buffers = 0;
            break;

        default:
            ++lane_oktorecv_invalid;
            break;
    }

    return HandledMsg;
}




MessageHandlerRC  LANEService::RxData (NICMessage  msg)
{
    static struct mbuf *    m0 = NULL;
    static struct mbuf *    m1 = NULL;
    struct mbuf *           m;
    static unsigned int     total_bytes = 0;
    static unsigned int     discard = 0;
    static void *           p;


    if (discard)
    {
        dprintf (("", "discarding rx data\n"));
        if (msg.data.last)
        {
            /* Inform the NIC that we have another buffer available */
            TxOKToRecv();
            discard = 0;
        }

        return DiscardMsg;
    }

    /* See if we can squeeze this data into the last mbuf on the chain
     * before we go to the expense of allocating a new mbuf.
     */
    if (msg.data.first || M_TRAILINGSPACE (m1) < msg.data.size)
    {
        dprintf (("", "allocating single MBUF for %u bytes\n", msg.data.size));
        m = ALLOC_S (msg.data.size, NULL);
        if (!m)
        {
            dprintf (("", "couldn't allocate MBUF\n"));
            /* Our buffers have become full!  Maybe Inform the NIC ??? */
            /* BlockWrite (CMD_MSG (handle, ALE_OKTORECV, 0xffff)); */
            if (!msg.data.first)
            {
                mbctl.freem (&mbctl, m0);
            }

            if (msg.data.last)
            {
                /* Inform the NIC that we have another buffer available */
                TxOKToRecv();
            }
            else
            {
                discard = 1;
            }

            return HandledMsg;
        }

        m->m_type = MT_DATA;
        if (msg.data.first)
        {
            dprintf (("", "first data in new packet\n"));
            /* Setup mbuf chain and byte count for new packet */
            m0 = m;
            if (--lane_rx_buffs < lane_min_rx_buffs)
            {
                lane_min_rx_buffs = lane_rx_buffs;
            }
            total_bytes = 0;
        }
        else
        {
            /* Link this new mbuf to the end of the existing chain */
            m1->m_next = m;
        }

        asm_get_msg (CommitFromARMAddr, mtod (m, unsigned char *), msg.data.size);
        m->m_len = msg.data.size;
    }
    else
    {
        dprintf (("", "adding %u bytes to last MBUF\n", msg.data.size));
        asm_get_msg (CommitFromARMAddr,
                     mtod (m1, unsigned char *) + m1->m_len,
                     msg.data.size);
        m1->m_len += msg.data.size;
    }

    if (total_bytes < ETHER_HDR_SIZE && total_bytes + msg.data.size >= ETHER_HDR_SIZE)
    {
        unsigned int     type;
        u_char *         raw_hdr;

        dprintf (("", "have header\n"));
        /* Now have a full ethernet header.  Examine frame type immediately so
         * we can start throwing data away ASAP if required, without bothering
         * to add it to the mbuf chain.
         */

        /* Ensure that Ethernet frame header is contiguous at start of
         * mbuf chain.
         */
        PULLUP (m0, ETHER_HDR_SIZE);
        raw_hdr = mtod (m0, u_char *);

        memcpy (&type, raw_hdr + ETHER_TYPE_OFFSET, ETHER_TYPE_SIZE);
        type = ntohs (type & 0xffff);
        dprintf (("", "frame type: %x\n", type));

        /* Find out if a protocol module has registered an interest in this
         * frame type.
         */
        p = dci_want_frame_type (type);
        if (!p)
        {
            /* Not interested in this frame type.  Free any resources already
             * consumed and ensure that the rest of the frame is discarded.
             */

            dprintf (("", "not interested in this frame type\n"));
            mbctl.freem (&mbctl, m0);
            if (msg.data.last)
            {
                /* Inform the NIC that we have another buffer available */
                TxOKToRecv();
            }
            else
            {
                discard = 1;
            }

            return HandledMsg;
        }

        m0 = convert_to_dci4_header (type,
                                     m0,
                                     raw_hdr);
        if (!m0)
        {
            m1 = NULL;

            if (msg.data.last)
            {
                /* Inform the NIC that we have another buffer available */
                TxOKToRecv();
            }
            else
            {
                discard = 1;
            }

            return DiscardMsg;
        }

        /* May be a different mbuf at end of chain after all this
         * fiddling around.
         */
        for (m1 = m0; m1->m_next; m1 = m1->m_next)
        {
            /* Empty loop */
        }
    }

    total_bytes += msg.data.size;

    if (msg.data.last)
    {
        /* Pass MBUF chain to protocol module - don't need to free it because
         * protocol module takes ownership at this point.
         */
        dprintf (("", "passing packet to protocol module\n"));
        dumpm (m0, total_bytes);

        dci_send_chain (m0, p);
        //callproto (&dib, m0, p->pi_handler, p->pi_handle);
        m0 = NULL;
        m1 = NULL;
        total_bytes = 0;

        /* Inform the NIC that we have another buffer available */
        TxOKToRecv();
    }

    return HandledMsg;
}

static struct mbuf *  convert_to_dci4_header (const unsigned int  type,
                                              struct mbuf *       m,
                                              u_char *            raw_hdr)
{
    RxHdr *        hdr;
    struct mbuf *  m0;

    m0 = ALLOC_S (sizeof (RxHdr), NULL);
    if (!m0)
    {
        /* Dump any previous data in this packet */
        dprintf (("", "couldn't allocate MBUF for header\n"));
        mbctl.freem (&mbctl, m);
    }
    else
    {
        m0->m_len = sizeof (RxHdr);
        m0->m_type = MT_HEADER;

        /* Fill in the header data for the protocol receive handler */
        hdr = mtod (m0, RxHdr *);
        hdr->rx_tag = 0;
        memcpy (hdr->rx_src_addr,
                raw_hdr + ETHER_SRC_ADR_OFFSET,
                sizeof (hdr->rx_src_addr));
        memcpy (hdr->rx_dst_addr,
                raw_hdr + ETHER_DST_ADR_OFFSET,
                sizeof (hdr->rx_dst_addr));
        hdr->_spad[0] = hdr->_spad[1] = 0;
        hdr->_dpad[0] = hdr->_dpad[1] = 0;
        hdr->rx_frame_type = type;
        hdr->rx_error_level = 0;

        /* Remove the original frame's header */
        m = TRIM (m, ETHER_HDR_SIZE, NULL);
        PULLUP (m, m->m_len);

        /* Join the new header and the original MBUF chain */
        m0 = CAT (m0, m);
    }

    return m0;
}

#define MAX_DUMP_BYTES  128

static void dumpm(struct mbuf *m0, int pktlen)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    struct mbuf *m;
    static const char digits[] = "0123456789abcdef";

    for (m = m0; m && pktlen; m = m->m_next)
    {
        int l = m->m_len;
        u_char *rptr = mtod(m, u_char *);

        if (pktlen > 0)
        {
            if (l > pktlen)
                l = pktlen;
            pktlen -= l;
        }
        while (l--)
        {
            if (bp > buf + sizeof(buf) - 4)
                goto done;
            *bp++ = digits[*rptr >> 4]; /* convert byte to ascii hex */
            *bp++ = digits[*rptr++ & 0xf];
            *bp++ = ' ';
        }

        if (m->m_next)
        {
            if (bp > buf + sizeof(buf) - 3)
                goto done;
            *bp++ = '|';
        }
        else
            *bp++ = ' ';
    }
done:
    if (m && pktlen)
        *bp++ = '>';
    *bp = 0;
    dprintf (("", "%s\n", buf));
}

static void dump_pkt (u_char *  rptr, int pktlen)
{
    char buf[3*MAX_DUMP_BYTES+4];
    char *bp = buf;
    static const char digits[] = "0123456789abcdef";

    while (pktlen--)
    {
        if (bp > buf + sizeof(buf) - 3)
            goto done;
        *bp++ = digits[*rptr >> 4]; /* convert byte to ascii hex */
        *bp++ = digits[*rptr++ & 0xf];
        *bp++ = ' ';
    }

done:
    *bp = 0;
    dprintf (("", "%s\n", buf));
}
