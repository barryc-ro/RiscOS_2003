; ipconv.s -- does conversion between the various IP address formats used in the atm25 driver

; ipuctos - unsigned char array to ip host string conversion (decimal version)
; on entry: r0 points to first of four unsigned chars
;           r1 points to output string
;           r2 number of bytes to convert
;           r3 is separator char

; on exit:  r0 is number of bytes written to string
;           r1 points to output string

		    AREA		ip_conv, PIC, CODE, REL
		    EXPORT		ipuctos
		    EXPORT		ipstouc
		    EXPORT		ipuitos
		    EXPORT		ipstoui


ipuctos
		    STMDB		sp!, {r4-r11, lr}

		    MOV			r9, r3
		    MOV			r8, r1		    			; remember string pointer
		    ADR			r6, ipuctos_lut	    			; get look up table base

ipuctos_do_byte	    MOV			r4, #0		    			; hundreds count
		    MOV			r5, #0		    			; tens count
		    					    			; unit count will be left in r3
		    LDRB		r3, [r0], #1


ipuctos_hundreds    CMP			r3, #100	    			; factors of 100 ?
		    BLT			ipuctos_tens
		    SUB			r3, r3, #100
		    ADD			r4, r4, #1	    			; how many ?
		    B			ipuctos_hundreds

ipuctos_tens	    CMP			r3, #10		    			; factors of 10 ?
		    BLT			ipuctos_units
		    SUB			r3, r3, #10
		    ADD			r5, r5, #1	    			; how many ?
		    B			ipuctos_tens

ipuctos_units	    CMP			r4, #0		    			; don't print leading 0
		    LDRNEB		r7, [r6, r4]	    			; get 100's digit
		    STRNEB		r7, [r1], #1	    			; write it

		    ADDS		r4, r4, r5	    			; if 100s was 0 and so is 10s
		    LDRNEB		r7, [r6, r5]	    			; don't print leading zero
		    STRNEB		r7, [r1], #1	    			; write it
		    LDRB		r7, [r6, r3]	    			; get unit digit
		    STRB		r7, [r1], #1	    			; write it

		    SUBS		r2, r2, #1	    			; decrement byte count
		    BEQ			ipuctos_end	    			; finished four bytes

		    STRB		r9, [r1], #1	    			; write separator
		    B			ipuctos_do_byte

ipuctos_end	    MOV			r7, #0
		    STRB		r7, [r1]
		    SUB			r0, r1, r8	    			; return no. bytes written
		    LDMIA		sp!, {r4-r11, pc}^

ipuctos_lut	    DCB			"0123456789"
		    ALIGN

; ipstouc - ip string to unsigned char array conversion (decimal)
; on entry: r0 - points to input string eg "136.170.192.80" zero terminated
;           r1 - pointer to output uchar array
;           r2 - max. no. bytes we may write to o/p array


ipstouc
		    STMDB		sp!, {r4-r11, lr}
		    MOV			r7, r1		    			; remember uchar ptr
		    MOV			r6, #10		    			; constant multiply factor
ipstouc_byte	    MOV			r4, #0		    			;
ipstouc_digit	    LDRB		r5, [r0], #1

		    CMP			r5, #'.'
		    BEQ			ipstouc_dot
		    CMP			r5, #0
		    BEQ			ipstouc_term

		    CMP			r5, #'0'
		    BLT			ipstouc_error
		    CMP			r5, #'9'
		    BGT			ipstouc_error

		    SUB			r5, r5, #'0'
		    MLA			r4, r6, r4, r5
		    B			ipstouc_digit

ipstouc_dot	    STRB		r4, [r1], #1
		    SUBS		r2, r2, #1
		    BNE			ipstouc_byte

ipstouc_term	    STRB		r4, [r1], #1
		    SUB			r0, r1, r7	    			; output no. bytes written
		    LDMIA		sp!, {r4-r11, pc}^

ipstouc_error	    MVN			r0, #0  	    			; signal error
		    LDMIA		sp!, {r4-r11, pc}^


; ipuitos - unsigned int to ip host string conversion (decimal version)
; on entry: r0 contains int
;           r1 points to output string
;           four bytes are converted
;           r2 is separator char

; on exit:  r0 is number of bytes written to string
;           r1 points to output string

ipuitos
		    STMDB		sp!, {r4-r11, lr}

		    MOV			r9, r2		    			; separator char
		    MOV			r8, r1		    			; remember string pointer
		    MOV			r2, #4		    			; set no. bytes explicitly
		    ADR			r6, ipuctos_lut	    			; get look up table base

ipuitos_do_byte	    MOV			r4, #0		    			; hundreds count
		    MOV			r5, #0		    			; tens count
		    					    			; unit count will be left in r3

		    MOV			r0, r0, ROR#24	    			; get next most sig. byte in bits 7-0
		    AND			r3, r0, #&ff	    			; isolate byte

ipuitos_hundreds    CMP			r3, #100	    			; factors of 100 ?
		    BLT			ipuitos_tens
		    SUB			r3, r3, #100
		    ADD			r4, r4, #1	    			; how many ?
		    B			ipuitos_hundreds

ipuitos_tens	    CMP			r3, #10		    			; factors of 10 ?
		    BLT			ipuitos_units
		    SUB			r3, r3, #10
		    ADD			r5, r5, #1	    			; how many ?
		    B			ipuitos_tens

ipuitos_units	    CMP			r4, #0		    			; don't print leading 0
		    LDRNEB		r7, [r6, r4]	    			; get 100's digit
		    STRNEB		r7, [r1], #1	    			; write it

		    ADDS		r4, r4, r5	    			; if hundreds=0 and tens=0 don't print
		    LDRNEB		r7, [r6, r5]	    			; get 10's digit
		    STRNEB		r7, [r1], #1	    			; write it
		    LDRB		r7, [r6, r3]	    			; get unit digit
		    STRB		r7, [r1], #1	    			; write it

		    SUBS		r2, r2, #1	    			; decrement byte count
		    BEQ			ipuitos_end	    			; finished four bytes

		    STRB		r9, [r1], #1	    			; write separator
		    B			ipuitos_do_byte

ipuitos_end	    MOV			r7, #0
		    STRB		r7, [r1]
		    SUB			r0, r1, r8	    			; return no. bytes written
		    LDMIA		sp!, {r4-r11, pc}^

; ipstoui - ip string to unsigned int conversion (decimal)
; on entry: r0 - points to input string eg "136.170.192.80" zero terminated

; working, r9 is intermediate result
ipstoui
		    STMDB		sp!, {r4-r11, lr}
		    MOV			r7, r1		    			; remember uchar ptr
		    MOV			r2, #4		    			; only write 4 bytes
		    MOV			r6, #10		    			; constant multiply factor
		    MOV			r9, #0
ipstoui_byte	    MOV			r4, #0		    			;
ipstoui_digit	    LDRB		r5, [r0], #1

		    CMP			r5, #'.'
		    BEQ			ipstoui_dot
		    CMP			r5, #0
		    BEQ			ipstoui_term

		    CMP			r5, #'0'
		    BLT			ipstoui_error
		    CMP			r5, #'9'
		    BGT			ipstoui_error

		    SUB			r5, r5, #'0'
		    MLA			r4, r6, r4, r5
		    B			ipstoui_digit

ipstoui_dot	    MOV			r9, r9, LSL#8
		    ORR			r9, r9, r4
		    SUBS		r2, r2, #1
		    BNE			ipstoui_byte

ipstoui_term        MOV			r9, r9, LSL#8
		    ORR			r9, r9, r4
		    MOV			r0, r9		    			; return result

		    LDMIA		sp!, {r4-r11, pc}^

ipstoui_error	    MVN			r0, #0  	    			; signal error
		    LDMIA		sp!, {r4-r11, pc}^



		    END



