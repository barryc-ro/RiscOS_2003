 ; Ant's ARM routines for getting data out of the BOSON FIFO
 ;
 ; This routine will be called to read between 0 and 2047 bytes from
 ; the FIFO, that is, a maximum of 512 words. 512 is a pretty small
 ; number, so I've gone totally overboard on the optimizing.
 ;
 ; On Entry, we have: r0 = addr. to get FIFO data from (EASI space)
 ;		     r1 = addr. to write data to (buffer)
 ;                    r2 = number of bytes to transfer
 ;
 ; this means we have 11 registers free, after we've stashed all the
 ; APCS bindings somewhere safe. Therefore, where possible, block data
 ; transfer is done in batches of 11 registers (or 44 bytes).
 ;
 ; we round r2 up to the next word boundary, and then convert to no. of words
 ; this is a 10 bit quantity, so we have 10 special cases for data fetching.
 ; by testing each bit in turn & calling the relevant routine, we ensure the
 ; correct amount of data is read (every msg in the FIFO is padded to a
 ; word boundary).
 ;
 ; We use:
 ;           23 instructions in the pre/postamble (2 MemOps)
 ;          196 instructions for special case transfer (all MemOps)
 ;            9 instructions for special case branching
 ;          ---
 ;          228 instructions, (198 MemOps)
 ;         =912 bytes of code (small enough to cache, & not too big an EPROM hit)
 ;
 ; worst case with all bits in r2 set (ie transfer 2048 bytes from FIFO) we will
 ; execute 237 instructions (198 MemOps, 18 branches, + arithmetic)
 ; c.f. a simple loop algorithm which would execute 4 instructions for every word
 ; fetched.

		    GET			s.ddi_macros

		    AREA		ddi_xfer, PIC, CODE, REL

		    EXPORT		_asm_get_msg
		    EXPORT		asm_junk_msg
		    EXPORT		asm_write_fifo
		    EXPORT		asm_enable_podule_irqs
		    EXPORT		asm_disable_podule_irqs
		    EXPORT		asm_buffer_recover
		    EXPORT		multi_status
		    EXPORT		ensure_irqs_on
		    EXPORT		ensure_irqs_off
		    EXPORT		restore_irqs

N_bit_number	    *			31                      ; Processor condition flags
Z_bit_number	    *			30
C_bit_number	    *			29
V_bit_number	    *			28
I_bit_number	    *			27
F_bit_number	    *			26

N_bit		    *			1 :SHL: N_bit_number    ; Processor condition flags
Z_bit		    *			1 :SHL: Z_bit_number
C_bit		    *			1 :SHL: C_bit_number
V_bit		    *			1 :SHL: V_bit_number
I_bit		    *			1 :SHL: I_bit_number
F_bit		    *			1 :SHL: F_bit_number

USR_mode	    *			2_00                    ; Processor mode bits
FIQ_mode	    *			2_01
IRQ_mode	    *			2_10
SVC_mode	    *			2_11

IOC_IRQMSKB	    *			&28		    ; IRQ Mask
IOC_FIQMASK	    *			&38		    ; FIQ Mask
IOC_ECTCR	    *			&c8		    ; EASI bus timing control register
podule_IRQ_bit	    *			1 :SHL: 5	    ; Podule IRQ request
podule_FIQ_bit	    *			1 :SHL: 6	    ; Podule FIQ request


DATA_FIRST	    *			&8000
DATA_LAST	    *			&10000
DATA_EXTEND	    *			&20000

IOC		    *			&03200000

Status_RXBlock	    *			&8
Status_RXNotEmpty   *			&10



_asm_get_msg	    STMDB		sp!, {r4-r11, lr}   ; stash APCS stuff
		    ADD			r2, r2, #3
		    MOV			r2, r2, LSR#2	    ; round up to word boundary


bit9		    TST			r2, #512
		    BNE			move_512

bit8		    TST			r2, #256
		    BNE			move_256

bit7		    TST			r2, #128
		    BNE			move_128

bit6		    TST			r2, #64
		    BNE			move_64

bit5		    TST			r2, #32
		    BNE			move_32

bit4		    TST			r2, #16
		    BNE			move_16

bit3		    TST			r2, #8
		    BNE			move_8

bit2		    TST			r2, #4
		    BNE			move_4

bit1		    TST			r2, #2
		    BNE			move_2

bit0		    TST			r2, #1

move_1		    LDRNE		r3, [r0]
		    STRNE		r3, [r1]!

exit		    LDMIA		sp!, {r4-r11, pc}^

move_2		    LDMIA		r0, {r3, r4}
		    STMIA		r1!, {r3, r4}
		    B			bit0

move_4		    LDMIA		r0, {r3-r6}
		    STMIA		r1!, {r3-r6}
		    B			bit1

move_8		    LDMIA		r0, {r3-r10}
		    STMIA		r1!, {r3-r10}
		    B			bit2

move_16		    DO_ELEVEN		1
		    LDMIA		r0, {r3-r7}
		    STMIA		r1!, {r3-r7}
		    B			bit3

move_32		    DO_ELEVEN		2
		    LDMIA		r0, {r3-r12}
		    STMIA		r1!, {r3-r12}
		    B			bit4

move_64		    DO_ELEVEN		5
		    LDMIA		r0, {r3-r11}
		    STMIA		r1!, {r3-r11}
		    B			bit5

move_128	    DO_ELEVEN		11
		    LDMIA		r0, {r3-r9}
		    STMIA		r1!, {r3-r9}
		    B			bit6

move_256	    DO_ELEVEN		23
		    LDMIA		r0, {r3-r5}
		    STMIA		r1!, {r3-r5}
		    B			bit7

move_512	    DO_ELEVEN		46
		    LDMIA		r0, {r3-r8}
		    STMIA		r1!, {r3-r8}
		    B			bit8



 ; code for junking blocks is similar, but happily faster, coz we don't need to store
 ; anything, just get it the hell out of the FIFO.
 ; as an additional bonus, we only have 2 args, so we get an extra register to use in
 ; the block move ops.
 ;
 ; On Entry:
 ;           r0 = addr. to read FIFO data from (EASI space)
 ;           r1 = number of bytes to junk
 ;
 ; so we have:
 ;             23 instruction pre/post-amble (2 MemOps)
 ;             91 instructions for special case transfer (all MemOps)
 ;              9 instructions for special case branching
 ;            ---
 ;            123 instructions (93 MemOps)
 ;           =492 bytes of code
 ;
 ; worst case (all bits in r2 set, ie junk the entire FIFO, heaven forbid) we execute
 ; 131 instructions (93 MemOps, 18 branches, +arithemetic).

asm_junk_msg	    STMDB		sp!, {r4-r11, lr}	; stash APCS stuff
		    ADD			r2, r2, #3
		    MOV			r2, r2, LSR#2		; round up to word boundary


jbit9		    TST			r2, #512
		    BNE			junk_512

jbit8		    TST			r2, #256
		    BNE			junk_256

jbit7		    TST			r2, #128
		    BNE			junk_128

jbit6		    TST			r2, #64
		    BNE			junk_64

jbit5		    TST			r2, #32
		    BNE			junk_32

jbit4		    TST			r2, #16
		    BNE			junk_16

jbit3		    TST			r2, #8
		    BNE			junk_8

jbit2		    TST			r2, #4
		    BNE			junk_4

jbit1		    TST			r2, #2
		    BNE			junk_2

jbit0		    TST			r2, #1

junk_1		    LDRNE		r3, [r0]

exit_junk	    LDMIA		sp!, {r4-r11, pc}^

junk_2		    LDMIA		r0, {r3, r4}
		    B			jbit0

junk_4		    LDMIA		r0, {r3-r6}
		    B			jbit1

junk_8		    LDMIA		r0, {r3-r10}
		    B			jbit2

junk_16		    DO_TWELVE		1
		    LDMIA		r0, {r3-r6}
		    B			jbit3

junk_32		    DO_TWELVE		2
		    LDMIA		r0, {r3-r10}
		    B			jbit4

junk_64		    DO_TWELVE		5
		    LDMIA		r0, {r3-r6}
		    B			jbit5

junk_128	    DO_TWELVE		10
		    LDMIA		r0, {r3-r10}
		    B			jbit6

junk_256	    DO_TWELVE		21
		    LDMIA		r0, {r3-r6}
		    B			jbit7

junk_512	    DO_TWELVE		42
		    LDMIA		r0, {r3-r10}
		    B			jbit8

; asm_buffer_recover - in the event that we have got out of step with the FIFO, this routine
;		       attempts to revert to a sane state. While there are words still in the
;		       FIFO, but no Blocks are registered, we junk the FIFO data.
;		       As soon as the FIFO is empty, or a Block appears, we stop.

; On entry: r0 is the address of the Boson commit from ARM register (adjusted for podule)

asm_buffer_recover  ADD			r2, r0, #&80
;		    ADD			r2, r2, #&400000    ; r2 = r_Boson_Status (in 16bit space)
10                  LDR			r1, [r2]	    ; get status register
		    AND			r1, r1, #(Status_RXBlock:OR:Status_RXNotEmpty) ; mask out the 2 bits we want
		    TEQ			r1, #Status_RXNotEmpty ; ensure a new block hasn't arrived
                    MOVNE		pc, lr
;		    BNE			buffer_recover_exit
		    LDR			r1, [r0]	    ; junk word
		    B			%BT10
;buffer_recover_exit MOV			pc, lr

; asm_write_fifo: writes stuff to the fifo, not very elegant code, but quicker than C
; on entry:
;		    r0 = handle
;		    r1 = command
;		    r2 = addr. of data to write
;		    r3 = no. of bytes to write
;		  [sp] = EASI addr. of BlockToARM register (adjusted for relevant podule slot)
;
; on exit:
;		    r0 = -1 if we ran out of FIFO buffer space

asm_write_const1    DCD			&3ff
asm_write_const2    DCD			&7ff

asm_write_fifo	    STMDB		sp!, {r4-r11, lr}
		    LDR			r10, asm_write_const1
		    LDR			r11, asm_write_const2

		    AND			r0, r0, r10
		    AND			r1, r1, #&f
		    ORR			r0, r0, r1, LSL#11  ; build handle & cmd word in r0
		    ORR			r9, r0, #DATA_FIRST ; first time version

		    LDR			r4, [sp, #36]	    ; get the BlockToARM address
		    ADD			lr, r4, #&c0
		    ADD			lr, lr, #&400000    ; lr is now addr. of status reg (in 16bit space)

write_block_loop    LDR			r5, [lr]	    ; get status register contents

		    MOV			r6, #0		    ; start by assuming no free fifo space
		    TST			r5, #4		    ; 16 words free?
		    MOVNE		r6, #64		    ; convert to free bytes
		    TST			r5, #2		    ; 128 words free?
		    MOVNE		r6, #512	    ; convert to free bytes
		    TST			r5, #1	    	    ; 384 words free?
		    MOVNE		r6, #1536	    ; convert to free bytes

		    CMP			r6, #0		    ; no fifo space?
		    BEQ			write_block_loop    ; EXPERIMENTAL HACK!
		    ; proper behaviour is given in the following 2 lines - ie signal an error
		    ; to the packet driver. But the internet module seems to ignore this when
		    ; it's passed back up, so we'll handle it locally.

		    ;MVNEQ		r0, #0
		    ;BEQ			asm_write_exit	    ; return error

		    SUB			r6, r6, #8	    ; take off 8 bytes for potential headers

		    CMP			r3, r6
		    BGT			extend		    ; bytes > fifo space

no_extend	    ORR 		r9, r9, #DATA_LAST  ; it's the last message block
		    AND 		r6, r3, r11	    ; num. of bytes in this message block
		    ORR 		r9, r9, r6, LSL#21  ; mask packet size into header word
		    STR 		r9, [r4, #&40]	    ; CommitToARM(header word)
		    B			begin_write_data

extend		    TST			r9, #DATA_FIRST	    ; if it's the first msg block...
		    ORRNE 		r9, r9, #DATA_EXTEND  ; ...set extension flag
		    ORR 		r9, r9, r6, LSL#21  ; mask in packet size
		    STR 		r9, [r4, #&40]	    ; CommitToARM(header word)
		    MOVNE 		r9, r3, LSL#16	    ; generate extension word
		    STRNE 		r9, [r4, #&40]	    ; CommitToARM(ext. word)

begin_write_data    SUB			r3, r3, r6	    ; calc. total bytes left
		    MOV			r9, r0		    ; restore hdr word for potential subsequent blox

write_data_loop	    LDR			r5, [r2], #4	    ; get next data word, update ptr
		    CMP			r6, #4		    ; is this gonna be the last word in this packet?
		    BLE 		write_last_word	    ; YES - deal with it
		    STR  		r5, [r4, #&40]	    ; NO: CommitToARM(data)
		    SUB 		r6, r6, #4
		    B			write_data_loop	    ; next word in packet

write_last_word	    RSB			r6, r6, #4	    ; r6 = 4 - bytes_left
		    MOVS		r6, r6, LSL#3	    ; r6 = 8 * (4 - bytes_left)
		    MOVNE		r5, r5, LSL r6	    ; clear that number of bits
		    MOVNE		r5, r5, LSR r6	    ; shift back to original pos.
		    STR			r5, [r4]	    ; BlockToARM(last_word)

		    CMP			r3, #0		    ; do we need to start another msg?
		    BGT			write_block_loop

asm_write_exit	    LDMIA		sp!, {r4-r11, pc}^

; stuff to turn on podule IRQs, and also to enable type C memory cycles for our podule
; we need r0 = podule slot number on entry to do this.

asm_enable_podule_irqs
		    STMDB		sp!, {r0-r2, lr}
		    MOV			r1, #1
		    MOV			r0, r1, LSL r0	    			; convert podule num to bit

		    MOV			lr,pc 		    			;Hold current I_bit & F_bit & Mode
		    SWI			&20016		    			;XOS_EnterOS
		    TEQP		pc, #I_bit+F_bit+SVC_mode    		;Disable IRQs & FIRQs

		    MOV			r2, #IOC                      		;whilst enabling Podule IRQs
		    ;LDRB		r1, [r2, #IOC_ECTCR]			; get expansion card timing control
		    ;ORR			r1, r1, r0	    			; mask in bit for our podule
		    ;STRB		r1, [r2, #IOC_ECTCR]

		    LDRB		r1, [r2, #IOC_IRQMSKB]         		;in IOC
		    ORR			r1, r1, #podule_IRQ_bit
		    STRB		r1, [r2, #IOC_IRQMSKB]
		    TEQP		pc, lr		    			;Restore original I_bit & F_bit
		    MOV			r0, r0			   		;And the Mode.
		    LDMIA		sp!, {r0-r2, pc}^



asm_disable_podule_irqs
		    STMDB		sp!, {r0-r2, lr}
		    MOV			r1, #1
		    MOV			r0, r1, LSL r0

		    MOV			lr, pc		    			;Hold current I_bit & F_bit &Mode
		    SWI			&20016		    			;XOS_EnterOS
		    TEQP		pc, #I_bit+F_bit+SVC_mode		;Disable IRQs & FIRQs

		    MOV			r2, #IOC	    			; whilst disabling Podule IRQs
		    LDRB		r1, [r2, #IOC_ECTCR]                    ; get expansion card timing register
		    BIC			r1, r1, r0	    			; turn off bit for our podule
		    STRB		r1, [r2, #IOC_ECTCR]

		    LDRB		r1, [r2, #IOC_IRQMSKB]			; in IOC
		    BIC			r1, r1, #podule_IRQ_bit
		    STRB		r1, [r2, #IOC_IRQMSKB]
		    TEQP		pc, lr		    			;Restore original I_bit & F_bit
		    MOV			r0, r0		    			;And mode.

		    LDMIA		sp!, {r0-r2, pc}^

; multi_status investigates weird goings-on with the status register
; on entry r0 = address to read, r1 = buffer to store results, r2 = no. words to read
multi_status
		    STMDB		sp!, {r4-r11, lr}
		    MOV			lr, pc		    			;Hold current I_bit & F_bit &Mode
		    SWI			&20016		    			;XOS_EnterOS
		    TEQP		pc, #I_bit+F_bit+SVC_mode		;Disable IRQs & FIRQs
multi_loop	    LDR			r3, [r0]
		    STR			r3, [r1], #4
		    SUBS		r2, r2, #1
		    BNE			multi_loop
		    TEQP		pc, lr		    			;Restore original I_bit & F_bit
		    MOV			r0, r0		    			;And mode.
		    LDMIA		sp!, {r4-r11, pc}^

ensure_irqs_on	    AND			r0, lr, # I_bit	    			; irqs on, previous state in r0
		    BICS		pc, lr, # I_bit

ensure_irqs_off	    AND			r0, lr, # I_bit	    			; irqs off, previous state in r0
		    ORRS		pc, lr, # I_bit

restore_irqs	    BIC			lr, lr, # I_bit	    			; restore previous state from r0
		    ORRS		pc, lr, r0

		    END


