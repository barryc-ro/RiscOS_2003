; Ant's routines for handling n-bit masks with semaphore protection
; used in the Panther driver for allcating unique socket handles (where n=64)

; this code keeps a variable which is the 'next allocatable socket handle' which is accessed uniquely
; using a semaphore sort of arrangement. In addition, a bit is kept for each socket handle to indicate
; whether it is still in use or not. Thus, when the socket index wraps round, services aren't rudely
; disconnected by having their socket handle re-allocated underneath them.

; socket handle 0 is pre-allocated to the command service on the Panther NIC. Therefore, each call to
; get_handle attempts to lock the semaphore with a ZERO. If the lock is owned by another process, it
; will already be zero, so writing a new lock value has no effect and zero will be returned to the current
; process, which will block.



		    AREA		nbit_mask, PIC, CODE, REL
		    EXPORT		init_handle_handler
		    EXPORT		get_handle
		    EXPORT		free_cmd_handle
		    EXPORT		free_handle
		    EXPORT		enumerate_free_handles
		    EXPORT		enumerate_busy_handles

N_BIT_LIMIT	    *			64		    ; hard limit of 64 bits worth of mask (may change in future)
		    					    ; LOG2(N_BIT_LIMIT) MUST BE AN INTEGER!!!
BIT_SELECT	    &			1		    ; this is the 'next free bit', or zero for lock
BIT_MASKS	    &			1,0		    ; provide sufficient bits for masks (ie n/32 words)
BIT_MASK_SIZE	    *			?BIT_MASKS	    ; find out how much space just got allocated

HANDLE_RETRIES	    *			64		    ; number of handle allocation attempts per call

; init_handle_handler -- set up workspace needed for managing socket handles
; on entry:
;           r0 -> Block:  0    1 word for storing 'next free handle'
;		          4    1 word containing max. no. of handles (must be n*32, where n >0)
;		    	  8    1 word for 32 bits worth of handles
;		          c    1 word for 32 bits worth of handles
;                         etc.

;           r1 = num. of handles to manage
;           r2 = num. of bytes in block pointed to by r0.
;
; on exit:
;          r0 = 0 for success
;		-1 for insufficient workspace
;		-2 for bad number of max_handles specified
;
; each group of 32 handles is allocated 1 word to store their protection bits.
; therefore, max_handles must = n*32, where n = {1,2,3,...,m}
; the workspace provided must have sufficient room for each of these words, plus 2 extra words for internal vars.
; ie if there are 64 handles available, r0 must point to 16 bytes of workspace
; once this workspace is established, **DO NOT** manipulate it using routines other than these!!
; the only exception is that the workspace can be freed without any special call here first.

init_handle_handler
		    STMDB		sp!, {r4,r5,lr}
		    ANDS		r3, r1, #31	    ; ensure max handles is mod 32
		    BNE			bad_max_handles
		    CMP			r1, #32		    ; less than 32 handles?
		    BLT			bad_max_handles

		    MOV			r3, r1, LSR#3	    ; convert num_handles -> num_bytes
		    ADD			r4, r3, #8	    ; add 8 bytes for static wspace requirements
		    CMP			r4, r2
		    BGT			bad_workspace	    ; you haven't given me enough workspace!

		    MOV			r3, #1		    ; start handles at 1, because 0 is pre-allocated
		    STR			r3, [r0]	    ; start next_free_handle at 1
		    STR			r1, [r0, #4]	    ; store max_handles

		    MOV			r3, r1, LSR#3

		    ADD			r5, r0, #8
		    MOV			r4, #1	    	    ; mark first flag as set (pre-allocated to cmd service)
		    STR			r4, [r5], #4
		    MOV			r4, #0
		    SUB 		r3, r3, #4
i_h_h_loop	    STR			r4, [r5], #4	    ; zero out any remaining mask words
		    SUBS		r3, r3, #4
		    BNE			i_h_h_loop
		    MOV			r0, #0		    ; return success value
		    LDMIA		sp!, {r4, r5, pc}^
bad_workspace	    MVN			r0, #0		    ; workspace set-up disaster
		    LDMIA		sp!, {r4, r5, pc}^
bad_max_handles	    MVN			r0, #1		    ; no. handles specified is not mod 32
		    LDMIA		sp!, {r4, r5, pc}^





; get_handle, get a free socket handle for NIC calls
; On Entry: r0 = pointer to handle_handler workspace
; On Exit: r0 = socket handle
;          or   -1 (couldn't get lock)
;		-2 (gave up - no free handles)
;		-3 (insufficient storage for bit masks - check source code)
;		-4 routine lost lock whilst running (shouldn't ever occur)

get_handle
		    STMDB		sp!, {r4-r11, lr}   ; APCS safety
		    MOV			r1, r0		    ; BIT_SELECT
		    ADD			r3, r0, #8	    ; BIT_MASKS
		    LDR			r5, [r0, #4]
		    MOV			r11, r5		    ; N_BIT_LIMIT
		    MOV			r5, r5, LSR#3	    ; convert num. handles to bytes of storage [BIT_MASK_SIZE]


		    MOV			r0, #0		    ; LOCK value
		    SWP			r2, r0, [r1]	    ; write LOCK to BIT_SELECT and get old contents
		    MOV			r9, r2		    ; duplicate  handle in r9
		    CMP			r2, #0		    ; was it already locked?
		    MVNEQ		r0, #0		    ; return -1 (failed to get lock)
		    LDMEQIA		sp!, {r4-r11, pc}^  ; failed to get lock.

		    ;ADR			r3, BIT_MASKS	    ; base of our mask space
		    ;MOV			r5, #BIT_MASK_SIZE  ; and limit on available space
		    MOV			r6, #0		    ; use this to count number of mask bits we have checked
		    SUB			r5, r5, #4	    ; round down to word

new_reduction
		    MOV			r4, #0		    ; index into mask space

reduce_handle	    CMP			r2, #32		    ; is remainder >31 ? (ie bigger than 1 word)
		    BLT			check_mask	    ; yup

		    ADD			r4, r4, #4
		    CMP			r4, r5		    ; exceeded our allocated area?
		    BGT			overmask_error	    ; oh dear

		    SUB			r2, r2, #32	    ; subtract 32 from handle
		    B			reduce_handle	    ; round again

check_mask	    LDR			r7, [r3, r4]	    ; get the relevant mask
		    MOV			r8, #1
		    TST			r7, r8, LSL r2	    ; test mask
		    BEQ			got_handle	    ; handle is free! Hooray!

		    ADD			r6, r6, #1	    ; inc. count of check attempts
		    CMP			r6, #(HANDLE_RETRIES)
		    BEQ 		give_up

		    ADD			r9, r9, #1	    ; inc. socket handle
		    CMP			r9, r11		    ; reached limit?
		    MOVGE		r9, #1		    ; if so, reset, skipping over cmd socket handle
		    MOV 		r2, r9		    ; otherwise copy

		    B			new_reduction

overmask_error	    MVN			r0, #2		    ; badly configured source code
		    MOV			r2, r9
		    SWP			r3, r2, [r1]	    ; unlock
		    LDMIA		sp!, {r4-r11, pc}^  ; return error

give_up		    MVN			r0, #1		    ; no free masks
		    MOV			r2, r9
		    SWP			r3, r2, [r1]	    ; unlock
		    LDMIA		sp!, {r4-r11, pc}^  ; return error

got_handle	    ORR			r7, r7, r8, LSL r2  ; set mask
		    STR			r7, [r3, r4]	    ; write it out again
		    MOV			r0, r9		    ; get returnable value

		    ADD			r9, r9, #1	    ; inc. socket handle
		    CMP			r9, r11		    ; reached limit?
		    MOVEQ		r9, #1		    ; if so, reset, skipping over cmd socket handle
		    MOV  		r2, r9		    ; otherwise copy

		    SWP			r3, r2, [r1]	    ; write new next_free_socket value & release lock
		    CMP			r3, #0
		    MVNNE		r0, #3		    ; signal error if lock was lost
		    LDMIA		sp!, {r4-r11, pc}^  ; return socket handle

; free_cmd_handle - explicitly frees the command handle - you cannot do this with free_handle
; on entry:
;          r0 = pointer to handle_handler workspace
;
; on exit:
;          r0 = -1 failed to get lock
;  		-3 something wrong with bit masks
;		-4 routine lost lock whilst running (but freed the handle OK)
;            or  0 for success

free_cmd_handle
		    MOV			r1, #0
		    B			free_handle_donkey_work

; free_handle - frees the given handle
;
; On Entry:
;          r0 = pointer to handle_handler workspace
;          r1 = handle to be freed
;
; On Exit:
;          r0 = -1 failed to get lock
;		-2 handle out of range (ie =0, or >MAX_HANDLES)
;  		-3 something wrong with bit masks
;		-4 routine lost lock whilst running (but freed the handle OK)
;            or  0 for success


free_handle
		    CMP			r1, #0		    ; attempting to free cmd handle?
		    MVNEQ		r0, #1
		    MOVEQ		pc, lr

		    LDR			r2, [r0, #4]	    ; N_BIT_LIMIT
		    CMP			r1, r2		    ; do socket handle range check
		    MVNGE		r0, #1
		    MOVGE		pc, lr


free_handle_donkey_work
		    STMDB		sp!, {r4-r11, lr}   ; APCS safety
		    MOV			r11, r1		    ; temp = handle_to_free
		    MOV			r1, r0		    ; BIT_SELECT
		    ADD			r3, r0, #8	    ; BIT_MASKS
		    LDR			r5, [r0, #4]
		    MOV			r5, r5, LSR#3	    ; BIT_MASK_SIZE
		    MOV			r0, r11

		    MOV			r10, #0		    ; LOCK value
		    ;ADR			r1, BIT_SELECT
		    SWP			r2, r10, [r1]	    ; write LOCK to BIT_SELECT and get old contents
		    MOV			r9, r2  	    ; duplicate handle in r9
		    CMP			r2, #0		    ; was it already locked?
		    MVNEQ		r0, #0		    ; return -1 (failed to get lock)
		    LDMEQIA		sp!, {r4-r11, pc}^  ; failed to get lock.

		    ;ADR			r3, BIT_MASKS	    ; base of our mask space
		    ;MOV			r5, #BIT_MASK_SIZE   ; and limit on available space
		    SUB			r5, r5, #4
		    MOV			r6, #0		    ; use this to count number of mask bits we have checked
f_new_reduction
		    MOV			r4, #0		    ; index into mask space

f_reduce_handle	    CMP			r0, #32		    ; is remainder >32 ? (ie bigger than 1 word)
		    BLT			bic_mask	    ; yup

		    ADD			r4, r4, #4
		    CMP			r4, r5		    ; exceeded our allocated area?
		    BGT 		overmask_error	    ; oh dear

		    SUB			r0, r0, #32	    ; subtract 32 from handle
		    B			f_reduce_handle	    ; round again

bic_mask	    LDR			r7, [r3, r4]	    ; get the relevant mask
		    MOV			r8, #1
		    BIC			r7, r7, r8, LSL r0  ; clear mask
		    STR			r7, [r3, r4]	    ; write it out again
		    MOV			r0, #0
		    SWP			r3, r9, [r1]	    ; clear lock
		    CMP			r3, #0
		    MOVEQ		r0, #0
		    MVNNE		r0, #3		    ; signal that we lost the lock
		    LDMIA		sp!, {r4-r11, pc}^  ; return

enumerate_free_handles			; sneaky - free_handles = N_BIT_LIMIT - busy handles
		    			; busy handles is easier to evaluate because we can stop checking
		    			; for busy bits within a given mask if the mask evaluates to zero (ie
		    			; early termination of the bit counting code)
		    STMDB		sp!, {lr}
		    BL			enumerate_busy_handles
		    CMP			r0, #0		    ; did we get an error back?
		    RSBPL		r0, r0, #N_BIT_LIMIT ; nope - do the math
		    LDMIA		sp!, {pc}^

; enumerate_busy_handles - calculate how many handles have been allocated
; on entry - r0 = pointer to handle_handler workspace
; on exit - r0 = number of allocated handles
;           or -1 failed to get lock
;           or -2 lost lock during process (but cleared handle)

enumerate_busy_handles
		    STMDB		sp!, {r4-r11, lr}   ; APCS safety
		    MOV			r1, r0		    ; BIT_SELECT
		    ADD			r3, r0, #8	    ; BIT_MASKS
		    LDR			r5, [r0, #4]
		    MOV			r5, r5, LSR#3	    ; BIT_MASK_SIZE
		    MOV			r0, #0		    ; LOCK value
		    ;ADR			r1, BIT_SELECT
		    SWP			r2, r0, [r1]	    ; write LOCK to BIT_SELECT and get old contents
		    CMP			r2, #0		    ; was it already locked?
		    MVNEQ		r0, #0		    ; return -1 (failed to get lock)
		    LDMEQIA		sp!, {r4-r11, pc}^  ; failed to get lock.

		    ;ADR			r3, BIT_MASKS	    ; base of our mask space
		    ;MOV			r5, #BIT_MASK_SIZE   ; and limit on available space
		    ;SUB			r5, r5, #4
		    MOV			r6, #0		    ; use this to count number of mask bits we have checked
		    MOV			r7, #0		    ; count of busy handles

enum_b_w_loop	    LDR			r4, [r3], #4	    ; get word & update ptr
		    ADD			r6, r6, #4
enum_b_b_loop	    MOVS 		r4, r4, LSL#1	    ; shift it left
		    ADDCS		r7, r7, #1	    ; inc. counter
		    ;CMP			r4, #0
		    BNE			enum_b_b_loop	    ; still bits set in this mask?
		    CMP			r6, r5
		    BNE			enum_b_w_loop
		    SWP			r3, r2, [r1]	    ; clear lock

		    CMP			r3, #0
		    MOVEQ		r0, r7
		    MVNNE		r0, #1		    ; lost lock
		    LDMIA		sp!, {r4-r11, pc}^



		    END





