/*	PNP.C

Project : Plug'n'Play

Purpose: Plug'n'Play initialise code - ripped off from ATML's code. Adapted
         to work through the EASI->ISA bus convertor



History:

Date      Who     Description of change
===========================================
??????    Ant     First cut of code

19/12/96  CP      Picked up version 0.08 (?) of sources.

                  Fixed some irritating C warnings (relating to
                  printf mismatches, argument type mismatches and implicit
                  narrowing functions

8/1/97    CP      Fixed annoying bugs in verbose output (backspace '\b' =>
                  '|H' in taskwindow)

9/1/97    CP      Fixed bug in the way that the pnp_ini() function sends the
                  configuration data to the card.  It is downloaded in 4
                  byte chunks, but the pointer was only being incremented
                  by a byte.  Changed the type of pointer, and rewrote the
                  some of the code so that it works properly.

16/1/97	  CP	  Added debug code to actually print out the ini data if
		  verbose requested.

4/2/98    CP      Modified operation of pnp_ini() to read value for upstream
                  bandwidth, then create necessary string to configure card.

***************************************************************************/

#include "headers.h"
#include "convert.h"
#include "pnp.h"
#include "module.h"
#include "atmio.h"
#include "utils.h"

#include <kernel.h>
#include <swis.h>


/****************************************************************************/

/*
   9/1/97:CP:changed type of ATMinit ptr from char * to int * so that it
             can be used directly to pass data to the ATM card in pnp_ini()
*/
extern int *ATMinit;
extern unsigned int ATMinit_length;  /* these 2 symbols come from data2aof headers */

#define NVRAM_ATM_PORTSPEED 0xD7  /* base address of 2 bytes to hold upstream
                                     bandwidth limit parameter
                                     (in kbps; 0 => no limit) */

static int selected_pnp_address   = 0x300;
static int selected_pnp_interrupt = 1;

void DoMicroDelay (unsigned int); /* from s.DoMicroDelay */

static U8    csn=0 /* , item */;
static U8    irq;
static U8    isol_byte1, isol_byte2;
static U16   addr=0;
static int   /* n, i, c, */ card_found;


static U8  key[32] =
{
    0x6A, 0xB5, 0xDA, 0xED, 0xF6, 0xFB, 0x7D, 0xBE,
    0xDF, 0x6F, 0x37, 0x1B, 0x0D, 0x86, 0xC3, 0x61,
    0xB0, 0x58, 0x2C, 0x16, 0x8B, 0x45, 0xA2, 0xD1,
    0xE8, 0x74, 0x3A, 0x9D, 0xCE, 0xE7, 0x73, 0x39
};




/****************************************************************************/

int plug_n_play( int range_chk, int verbose, int dump, int mod )
{
    U8  c;
    int i;
#ifdef BANANA   /* 15/1/97:CP:WTF does BANANA do?!  */
    char banana[48];
#endif

    M_unused (verbose);
    M_unused (mod);
    M_unused (dump);

#ifndef BANANA
    M_unused (range_chk);
#endif

    /* ================================= */
    /* START OF PLUG AND PLAY INITIATION */
    /* ================================= */

/*     QUIET printf("Resetting ATM card\n"); */
/*     reset_state = reset_atm(podule); */
/*     QUIET printf("Wrote 0x1 to 0x%8x\n", reset_state); */

#ifdef BANANA
    sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
    QUIET printf("Reset initialisation LFSR\n");
/*     time_delay(1); */
    wr_cyc(PNP_ADDR, 0x00);
    wr_cyc(PNP_ADDR, 0x00);

#ifdef BANANA
    sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif

    QUIET printf("send initiation sequence\n");
    for (i = 0; i < 32; i++)
    {
       wr_cyc(PNP_ADDR, key[i] );
    }

    QUIET printf("end of sequence\n");

#ifdef BANANA
        sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif

    QUIET printf("do wake 0 and assume in isolation mode\n");
    wr_cyc(PNP_ADDR,PNP_WAKE);
    wr_cyc(PNP_WR_DATA, 0x00);

#ifdef BANANA
    sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
    QUIET printf("set the read base address 0x%X\n", rd_port);
    wr_cyc(PNP_ADDR,PNP_RD_DATA_PORT);
    wr_cyc(PNP_WR_DATA, (U8)(rd_port>>2));

#ifdef BANANA
    sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
    csn = 0;

    while (1)
    {
      wr_cyc(PNP_ADDR,PNP_SERIAL_ISOL);

      card_found = 0;
      QUIET printf("Reading isolation sequence\n");
/*
   21/1/98:CP:excerpt from Plug and Play ISA Spec v1.0a, May 5th 1994, p12:
   "The software must delay 1 msec prior to starting the first pair of
   isolation reads, and must wait 250 usec between each subsequent pair of
   isolation reads.  This delay gives the ISA card time to access information
   from possibly very slow storage devices"

   Intermittent faults being caused by hitting this protocol too fast; delay
   1ms first
*/
      DoMicroDelay (2000); /* 1 ms delay */

/* isolation protocol loop */
      for (i=0; i < 72; i++)
      {
	isol_byte1 = rd_cyc(rd_port);
	isol_byte2 = rd_cyc(rd_port);

	if ( (isol_byte1 == 0x55) && (isol_byte2 == 0xAA) )
	{
	   card_found = 1;
	}

        DoMicroDelay (500); /* 250 us delay */
      }

#ifdef BANANA
    sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
      if (card_found == 0)
      {
         break;
      }
      else
      {
       csn += 1;
       QUIET printf("\nPNP card %d found:\n", csn );

       QUIET printf("set CSN = %d\n", csn );
       wr_cyc(PNP_ADDR, PNP_CARD_SELECT_NUMBER);
       wr_cyc(PNP_WR_DATA, csn );

#ifdef BANANA
       sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
       QUIET printf ("put card %d into configuration mode\n", csn );
       wr_cyc(PNP_ADDR,PNP_WAKE);
       wr_cyc(PNP_WR_DATA, csn );

#ifdef BANANA
       sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
       QUIET printf("set logical device number\n");
       wr_cyc(PNP_ADDR,PNP_LOGICAL_DEVICE_NUMBER);
       wr_cyc(PNP_WR_DATA,0x00);

#ifdef BANANA
       sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif

      addr = default_base;
      selected_pnp_address = addr;

      QUIET printf("\tbase address = 0x%X\n", addr );
      wr_cyc(PNP_ADDR, PNP_IO_BASE_HIGH_DESC_0);
      wr_cyc(PNP_WR_DATA, (U8)(addr >> 8));
      wr_cyc(PNP_ADDR, PNP_IO_BASE_LOW_DESC_0);
      wr_cyc(PNP_WR_DATA, (U8)(addr & 0xff));

#ifdef BANANA
      sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
      irq = default_irq;
      selected_pnp_interrupt = irq;

      QUIET printf("\tIRQ number   = %d\n", irq );
      wr_cyc(PNP_ADDR, PNP_INTERRUPT_LEVEL_0);
      wr_cyc(PNP_WR_DATA, irq );
      wr_cyc(PNP_ADDR, PNP_INTERRUPT_TYPE_0);
      wr_cyc(PNP_WR_DATA, (U8)(0x03));

#ifdef BANANA
      sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif

      irq = default_irq2;
      QUIET printf("\tIRQ2 number   = %d\n", irq );
      wr_cyc(PNP_ADDR, PNP_INTERRUPT_LEVEL_1);
      wr_cyc(PNP_WR_DATA, irq );
      wr_cyc(PNP_ADDR, PNP_INTERRUPT_TYPE_1);
      wr_cyc(PNP_WR_DATA, (U8)(0x03));


#ifdef BANANA
      sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
      QUIET printf ("put our board into sleep mode\n");
      wr_cyc(PNP_ADDR, PNP_WAKE);
      wr_cyc(PNP_WR_DATA, 0 );

#ifdef BANANA
      sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
      default_base += 16;
      default_irq  += 1;

    }

  }


  if (csn > 0)
  {
   QUIET printf("\n");

   /* ================================= */
   /* wakeup all the plug'n'play cards  */
   /* ================================= */

   for (c = 1; c <= csn; c++)
   {
    QUIET printf("wake and activate card %d - ", c );
    wr_cyc(PNP_ADDR, PNP_WAKE);
    wr_cyc(PNP_WR_DATA, c );

#ifdef BANANA
    sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
    wr_cyc(PNP_ADDR, PNP_ACTIVATE);
    wr_cyc(PNP_WR_DATA, 0x01);
    QUIET printf("OK\n");
   }

#ifdef BANANA
    sprintf(banana,"%d%d", range_chk, verbose); /* ldelay while IO settles down */
#endif
    QUIET printf("set wait for key mode\n");
    wr_cyc(PNP_ADDR,PNP_CONFIG_CONTROL);
    wr_cyc(PNP_WR_DATA, 0x02);
    return c;
  }

  else
  {
     return -1;
  }
}


int pnp_getid(void)
{
  U32 temp;


  temp = r_Boson_Version;
  return(temp);
}



int pnp_checksync(int attempts)
{
  U32 SyncIN = 0, count = 0, temp;
  int SyncOUT = 0;


  do /* while(SyncIN<2 || SyncOUT<2 && --attempts) */
  {
    if(Boson_RX_NotEmpty)
    {
       temp = CommitRead();

       switch(SyncIN)
       {

         case 0:  if(temp == SYNC0)
                  {
              	  	  SyncIN = 1;
              	  	  QUIET printf("Got SYNC0\n");
                  }
                  break;

         case 1:  if(temp == SYNC1)
                  {
              	  	  SyncIN++;
              	  	  QUIET printf("Got SYNC1\n");
         	  }
         	  else
         	  {
         	     SyncIN = 0;
         	  }
         	  break;

         default: SyncIN = 0;
         	  QUIET printf("Read %d bogus FIFO words.\n", count);
         	  break;
       }/* end switch */
    }

    if((Boson_TX_16) && (SyncOUT < 2))
    {
      QUIET printf("Writing %s\n", SyncOUT?"SYNC1":"SYNC0");
      CommitWrite(SyncOUT?SYNC1:SYNC0);
      SyncOUT++;
    }
  } while(SyncIN<2 || SyncOUT<2 && --attempts);


  return(attempts);
}


int pnp_loadimage(IMAGE_INFO *image_info)
{
    char widge[] = "-\\|/";
    int widget = 0;
    unsigned int data;
    unsigned int *start;
    unsigned int count, csum;
    unsigned int chksum = 0;

    start = image_info->start;
    count = (image_info->size)/4;
    csum = image_info->csum;

    QUIET printf("IMAGE: Loading %d bytes (%d words) from 0x%x, csum: 0x%x\n", image_info->size, count, (int)start, csum);

    CommitWrite(BOOT_BOOT);
    CommitWrite(count);

    QUIET printf("downloading...\r\n");

    while (count-- && !timeoutError)
    {
        data = *start++;
        CommitWrite(data);
        chksum += data;


            if ((count & 0xFF) == 0)
            {
                widget = (widget + 1) & 3;
                QUIET printf("\r%c", widge[widget]);
            }
    }

   /* 8/1/97:CP: fixed annoying bug in verbose output, \b=> '|H' in RiscOS task window */
    QUIET printf("\r \n");

    QUIET printf("0x%x == 0x%x ?? \n", csum, chksum);

    CommitWrite(csum);

    if (CommitRead() != BOOT_ACK)
    {
        return -1;
    }

    if(timeoutError)
    {
       return(-1);
    }
    else
    {
       return(0);
    }
}


void pnp_go(void)   /* send command to exit ROM & run downloaded image */
{
  CommitWrite(BOOT_GO);
  return;
}

int pnp_checkrom(void)  /* do the final ROM_ACK */
{
  BlockWrite(ROM_ACK);
  if(BlockRead() != ROM_ACK)
  {
     return(-1);
  }
  else
  {
     return 0;
  }
}


int pnp_getmac(void)
{
  int temp;

  CommitWrite(BOOT_ADDR);
  temp = CommitRead();
  temp = CommitRead();
  if(timeoutError)
  {
     return(-1);
  }
  else
  {
     return(0);
  }
}


/**************************************************************************
pnp_ini - send virata.ini information to card

        Send CONFIG_DATA
        Send word count.
        Send words.

Globals used: ATMinit  (int *) ptr to ATMinit data
              ATMinit_length (unsigned int) length of ATMinit data

**************************************************************************/
int pnp_ini(void)
{
/*     char widge[] = "-\\|/"; */
/*     int widget = 0; */
    unsigned long int_count;  /* number of 4-byte words to write */
    unsigned int tInit;
    unsigned int uiData;
    int gotAck = 0;

    int Vlo;
    int Vhi;
    int UpstreamSpeed; /* read from CMOS */
    char UpstreamString[22];  /* holds "atm_portspeed=xxxxxx\n\0" */
    int *pUpString; /* working ptr into string */
    int SpareInt;  /* used to transfer ragged edge between .ini and portspeed */


/* 5/2/98:CP:create setportspeed string */

    /* read CMOS for value of upstream bandwidth (in kbps) */
    _swi ( OS_Byte, _IN(0) | _IN(1) | _OUT(2), 161, NVRAM_ATM_PORTSPEED, &Vlo);
    _swi ( OS_Byte, _IN(0) | _IN(1) | _OUT(2), 161, NVRAM_ATM_PORTSPEED + 1, &Vhi);
    UpstreamSpeed = ( (Vhi << 8) | Vlo);

    /*
       convert this value to the form used by the card.
       Card value = speed in kbps * 1000 / 432.
    */
    UpstreamSpeed *= 1000;
    UpstreamSpeed /= 432;

    sprintf (UpstreamString, "atm_portspeed=%d\r\n", UpstreamSpeed);
    pUpString = (int *) UpstreamString;

    /* turn int_count into number of words */
    /* 15/1/97:CP: code changed to reflect bosonxfr.c */
    int_count = (unsigned long)
                    (ATMinit_length + (unsigned long) strlen (UpstreamString) +
                     sizeof(U32) - 1L) / (unsigned long) sizeof (U32);

    /* 19/12/96:CP: fixed print statement - various mismatched warnings etc */
    QUIET printf("INIT: Loading %d bytes (%lu words) from 0x%x\n",
    	  ATMinit_length + strlen (UpstreamString), int_count, (unsigned int)ATMinit);


    BlockWrite(CONFIG_DATA);

    tInit = MonotonicTime();


    /* loop similar to sample code, bosonxfr.c */
    while ( !gotAck && ( (MonotonicTime() - tInit) < TIMEOUT) )
    {
      uiData = BlockRead();

      if (uiData == CONFIG_DATA)
      { /* success!  Data read OK */
        gotAck = 1;
        QUIET printf("Got CONFIG_DATA word back in acknowledgement\n");
      }

      if (uiData == -1)
      { /* timeout reading data */
        break;
      }
    }

    if (!gotAck)
    {
      return -1;
    }


    CommitWrite((int)int_count); /* 19/12/96:CP: CommitWrite takes (int) argument */

    QUIET printf( "downloading...\r\n" );

    while ( (ATMinit_length > sizeof (U32) ) && (timeoutError == 0) )
    {
       /*
          9/1/97:CP:Sending words (4 bytes) but incrementing ATMinit (a
                    char *) only moves it on by a byte!
                    Re-write code to use ATMinit pointer consistently.
                    Chksum not used.

                    Removed spurious braces.
       */

       /* debugging.... */
       QUIET printf("%c", *((char *)ATMinit));
       QUIET printf("%c", *(((char *)ATMinit) + 1));
       QUIET printf("%c", *(((char *)ATMinit) + 2));
       QUIET printf("%c", *(((char *)ATMinit) + 3));

       CommitWrite(*ATMinit); /* 19/12/96:CP: CommitWrite takes (int) argument */
                              /*  5/ 2/98:CP:timeoutError can be set
                                 (incremented) in this function, so quitting
                                 the while loop.  Yuk!
                              */
       ATMinit++;
       ATMinit_length -= sizeof (U32);
       int_count --;

    } /* end while ((int_count > sizeof (U32) ) && (timeoutError == 0)) */


    if (ATMinit_length != 0)
    {
       memcpy ( (char *)&SpareInt, (char *)ATMinit, ATMinit_length);  /* copy last few bytes over */

       /* now copy the first few bytes of the portspeed string...*/
       memcpy ( (char *)( (int)&SpareInt + (int)ATMinit_length), (char *)pUpString, sizeof(U32) - ATMinit_length);

       /* debugging.... */
       QUIET printf("%c", *((char *)&SpareInt));
       QUIET printf("%c", *(((char *)&SpareInt) + 1));
       QUIET printf("%c", *(((char *)&SpareInt) + 2));
       QUIET printf("%c", *(((char *)&SpareInt) + 3));

       CommitWrite(SpareInt);

       pUpString = (int *)( ((char *)pUpString) + sizeof(U32) - ATMinit_length );

       int_count --;
    }

    while ( ( int_count != 0 ) && (timeoutError == 0) )
    {
       /* debugging.... */
       QUIET printf("%c", *((char *)pUpString));
       QUIET printf("%c", *(((char *)pUpString) + 1));
       QUIET printf("%c", *(((char *)pUpString) + 2));
       QUIET printf("%c", *(((char *)pUpString) + 3));

       CommitWrite(*pUpString);

       pUpString++;
       int_count --;

    } /* end while ( int_count != 0 ) && (timeoutError == 0) ) */


    QUIET printf("\n");

    return (timeoutError == 0);
}
