title-string:           DoBootP

help-string:            DoBootP 0.02 Issues BOOTP packets

initialisation-code:    bp_init
/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * :RCS Log discontinued:
 * Revision 4.2.2.1  1997/11/25 11:20:09  nturton
 * Version 0.08 imported from SrcFiler
 *
 * Revision 1.20  95/03/31  11:04:15  kwelton
 * Two main changes:
 *
 * 1)  When Paul fixed my inappropriate use of splimp() and splx(), he used
 *     ensure_irqs_on() to replace splimp(); it should have been
 *     ensure_irqs_off().
 *
 * 2)  All pending callbacks are removed during module finalisation.
 *
 * Revision 1.19  95/03/30  16:22:50  pwain
 * Changed some splimp() and splx() calls tp
 * ensure_irqs_on and restore_irqs
 *
 * Revision 1.18  95/03/30  16:14:12  kwelton
 * Three significant changes:
 *
 * 1)  Error token FWONex should be FWONEx (tokens are case significant)
 *
 * 2)  Socket descriptors in struct fw should be initialised to -1, this
 *     stops them being erroneously closed in fw_final().
 *
 * 3)  Internet Event enables are counted - this is some perfectly healthy
 *     paranoia to prevent disabling events that haven't been enabled.
 *
 * Revision 1.17  95/03/30  15:25:26  pwain
 * Added stacks of debug (more meaningful) for
 * Black Rom problem solving.
 *
 * Revision 1.16  95/03/30  09:30:38  kwelton
 * fw_final() resets socket descriptors to an invalid number after calling
 * socketclose().
 *
 * Revision 1.15  95/03/22  15:48:27  kwelton
 * Bugger!  Went through the previous changes with Paul, spotted a small
 * piece of redundant code, and forgot to save my emacs session before
 * checking the new version in.
 *
 * Revision 1.14  95/03/22  15:42:15  kwelton
 * read_ifs() was not ignoring unwanted interfaces (e.g. Slip) when
 * looking for an interface to set an address on.  This has been
 * fixed by a fairly hefty rewrite of read_device_name().
 *
 * Revision 1.13  95/03/19  17:58:36  kwelton
 * A number of changes:
 *
 * 1)  The internet module now issues a service call (Service_InternetStatus)
 *     every time an SIOCSIFFADDR ioctl() is raised.  This is caught and,
 *     provided it was not this module that made the ioctl() call, the
 *     module is restarted which is the easiest way of coping with the
 *     changed Internet address.
 *
 * 2)  Notice is now taken of the service call issued when the internet
 *     module finalises - this module shuts itself down as well.
 *
 * 3)  The message file is reinitialised when a Service_MessageFileClosed
 *     is issued.
 *
 * 4)  Service_DCIDriverStatus is checked to see whether the driver is
 *     initialising, or finalising.
 *
 * 5)  Some of the functionality of fw_init() has been moved into a
 *     separate function (fw_prime()) for use when the module is about
 *     to be restarted.
 *
 * Revision 1.12  95/03/10  18:06:06  kwelton
 * Found and plugged a significant number of memory leaks; added range
 * checking on SWI numbers.
 *
 * Revision 1.11  95/03/07  20:53:10  kwelton
 * Main change is a bugfix in fw_service() where protocol startup messages
 * from the internet module are ignored if the module has already fully
 * initialised.
 *
 * Also fixed a minor bug (CSD-190207) where *fwshow was producing an
 * inappropriate message; this message has also been internationalised.
 *
 * Revision 1.10  95/03/05  16:04:00  kwelton
 * Tidied up scope and declarations of both functions and
 * variables; the module now compiles cleanly with -ffah.
 *
 * Revision 1.9  95/03/01  09:08:28  pwain
 * Fixed a typo. Added Domain disks
 *
 * Revision 1.8  95/02/16  15:36:43  pwain
 * Added SWI "Freeway_Status". With the reson code 0 in R0 this will
 * return 1 if Freeway is running and accepting SWIs or 0 if it is
 * dormant in R1.
 *
 * Revision 1.7  95/02/15  14:14:58  pwain
 * Fixed bug in SWI handler which caused Freeway to data abort
 * when the Internet module was not fully initilised. Basically
 * it was trying to pass back a local pointer to the global
 * environment.
 *
 * Revision 1.6  95/02/02  08:57:57  pwain
 * Changed pickup point for DCI structures from module.h
 * to "sys/dcistructs.h".
 *
 * Revision 1.5  95/02/01  19:05:05  pwain
 * Changed function names of callback routines that deal with
 * additional drivers coming on line.
 *
 * Revision 1.4  95/02/01  17:57:40  pwain
 * Fixed random-ish generation of IP numbers (reworked
 * read_device_name() and read_ifs). Now uses last 2
 * digits of ether address and last letter of name.
 *
 * Revision 1.3  95/02/01  15:23:07  pwain
 * Added in more debug Printf()s.
 * Changed the way the internet module is 1st checked for to use a searc
 * on its name. (OS Module 18 call)
 *
 * Revision 1.2  95/01/26  09:42:12  pwain
 * Added in support for loading from system ROM (unordered startup)
 * Debugging of startup using TML cards (CFLAGS = -DDEBUG)
 * General code tidy up to change DCI2-isms to DCI4
 * Tidy of module header (correct declaration of exit routines)
 *
 * Revision 1.1  95/01/03  18:57:14  kwelton
 * Initial revision
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "sys/types.h"
#include "sys/uio.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "sys/dcistructs.h"

#include "netinet/in.h"
#include "net/if.h"

#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "stubs.h"

void fw_final(void);

static int is_from_us(u_long src);

static _kernel_oserror *FreewayStatus(_kernel_swi_regs *r);
static _kernel_oserror *init_msgs(char *filename, char *fd);
static _kernel_oserror *fw_evenable(void);

/*
 * declare global variables
 */
struct fw fw = { 0 };
u_long local_adr = 0;

static void *module_wsp = 0;

static struct
{
    int  e_nbr;
    char e_string[36];
} ebuf = { 0 };

static char msg_fd[16] = { 0 };

static struct eblk error_blocks[15] = {
    { 0, 0 },
    { 0x809f00, "FWType" },
    { 0x809f01, "FWOExt" },
    { 0x809f02, "FWONEx" },
    { 0x809f03, "FWDBuf" },
    { 0x809f04, "FWNBuf" },
    { 0x809f05, "FWNMem" },
    { 0x809f06, "FWOUnk" },
    { 0x809f07, "FWNNet" },
    { 0x809f08, "FWLStr" },
    { 0x809f09, "FWNLoc" },
    { 0x809f0a, "FWNAut" },
    { 0x809f0b, "FWNoInet" },
    { 0x809f0c, "FWStatusMsg" },
    { 0x809f0d, "FWInvalSWI" },
    };

#ifdef OldCode
static u_long auto_adr = 0;
#endif

#define MAXSWI 6

struct swient
{
    _kernel_oserror *(*swi_call)();         /* swi handler */
};

static struct swient fw_ent[MAXSWI] = {
    RegisterType,
    WriteObject,
    ReadObject,
    EnumerateObjects,
    FreewayStatus,
    0,
};

struct client
{
    int (*cli_call)();      /* cli handler */
};

#define MAXCLIENT 2

static void fw_show(char *a, int b);

static struct client fw_cli_call[2] = {
    (int (*)())fw_show,
    0,
};

static _kernel_oserror *calleverytick(int (*fun)()), *fw_claimv(void);
static _kernel_oserror *fw_real_init(void);
static int inet_present(void);

static const char protocol_name[] = "Internet";

static int dostart = 0;
static int startup_done = 0;
static int setting_address = 0;

int doobjects = 0;

extern void readdevice_entry(void);

/**********************************************************************
 * This is used to set the environment variables to indicate local
 * addresses.
 */

static void setadrvar(int ifcnt, char *adr)
{
    _kernel_swi_regs r;
    char varname[32];

    /*
     * Is it the 1st usable interface? If not, add a count to the name.
     */
    if( ifcnt == 0 )
        sprintf(varname, "%s", "Inet$LocalAddr");
    else
        sprintf(varname, "%s%d", "Inet$LocalAddr", ifcnt);

#ifdef DEBUG
    Printf("Setting \"%s\" to \"%s\"\n", varname, adr);
#endif /* DEBUG */

    r.r[0] = (int)varname;
    r.r[1] = (int)adr;
    r.r[2] = strlen(adr)+1;
    r.r[3] = 0;
    r.r[4] = 0;
    (void)_kernel_swi(XOS_Bit | OS_SetVarVal, &r, &r);
}

/**********************************************************************/

/*
 * rmafree - return some claimed memory to RMA
 */
static void rmafree(void *mem)
{
    _kernel_swi_regs r;

    r.r[0] = 7;
    r.r[2] = (int)mem;
    (void)_kernel_swi(XOS_Bit | OS_Module, &r, &r);
}

/**********************************************************************
 * This code reads back the DIB for the DCI drivers that are known
 * (the loopback device isnt read) and attempts to work out the
 * device address in order to make up an address for freeway to use
 * on the device.
 */

static void read_device_name(char *buf, char *etheradr)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    ChDibRef chd, chdnext;
    struct ifreq ifreq;
    int s;

    /*
     * error "return" is a null string in buf
     */
    buf[0] = '\0';

#ifdef DEBUG
    Printf("RD> Reading device information\n");
#endif

    r.r[0] = NULL;
    r.r[1] = Service_EnumerateNetworkDrivers;

    if( (e = _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r)) != NULL )
        return;

    if( (chd = (struct chaindib *)(r.r[0])) == NULL )
        return;

    /*
     * open a socket so we can read some interface details
     */
    if( (s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 )
        return;

    /*
     * 950322 KWelton
     *
     * this routine has been restructured so that
     * only "suitable" interfaces are selected to
     * have their address set. "Suitable" means
     *
     * a)  Interface must support broadcast. This
     *     is a standard Freeway requirement.
     *
     * b)  Interface must support ARP.  If the i/f
     *     doesn't support ARP, then the chances
     *     are pretty good that it doesn't have a
     *     "unique" hardware address we can use to
     *     generate an interface address from
     */
    while( chd )
    {
#ifdef DEBUG
        Printf("RD> Reading %s's ether address\n", buf);
        /*
        Printf("RD> Address is %s\n",
               ether_sprintf(chd->chd_dib->dib_address));
        */
#endif

        sprintf(ifreq.ifr_name, "%.*s%d",
                sizeof(ifreq.ifr_name) - 2,
                chd->chd_dib->dib_name, chd->chd_dib->dib_unit);

        /*
         * check that Internet knows about this interface and
         * that the interface features are acceptable.
         */
        if( (socketioctl(s, SIOCGIFFLAGS, (caddr_t)&ifreq) == 0 &&
             (ifreq.ifr_flags & IFF_BROADCAST) &&
             !(ifreq.ifr_flags & IFF_NOARP)) )
        {
            int i;

            strcpy(buf, ifreq.ifr_name);

            for( i = 0; i < 6; i++ )
                etheradr[i] = chd->chd_dib->dib_address[i];

            break;
        }

        /*
         * this interface is no good, free it here and now
         * and try the next one.
         */
        chdnext = chd->chd_next;
        rmafree(chd);
        chd = chdnext;
    }

    /*
     * 950308 KWelton
     *
     * As the initiator of Service_EnumerateNetworkDrivers,
     * we have a responsibility to free the RMA claimed
     * during the service call
     */
    while( chd )
    {
        chdnext = chd->chd_next;
        rmafree(chd);
        chd = chdnext;
    }

    /*
     * finished - close the socket and go away
     */
    (void)socketclose(s);
    return;
}

/**********************************************************************
 * This is the main part of the initialisation. It tries to evaluate
 * all know ether drivers and see what if any are suitable for freeway
 * to use. It does this by looking to see if the device is able to
 * broadcast, isnt the loopback device and is able to be configured
 * at the software level to the settings that freeway requires.
 *
 * This routine may be called on many occasions when new drivers start
 * up. In this case it should find the last known suitable driver in the
 * fw structure, then skip down the list that is avaliable from the INET
 * module until it finds that one. Then it should start testing from there
 * since no record is kept of failed interfaces. This is probably the
 * most efficient way of doing this. [ Not Implemented yet ]
 */
static int read_ifs(void)
{
    char buf[512], name[16];
    struct ifconf ifc;
    struct ifreq ifreq, *ifr;
    struct sockaddr_in *sin = NULL;
    int s, n;
    u_long last_bcast;

    char etheradr[6];
    int retried = 0;
    u_char byte0, byte1, byte2;

    extern struct in_addr inet_makeaddr(int net, int host);

    /*
     * Open a socket in order to read back the info from the drivers.
     * This is a UDP based application. If we can't open the socket
     * abort.
     */
#ifdef DEBUG
    Printf("IC> Opening socket....");
#endif

    if( (s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 )
    {
#ifdef DEBUG
        Printf("Failed - aborting\n");
#endif
        return -1;
    }

#ifdef DEBUG
    Printf("Succeeded (temp socket=%d)\n",s);
#endif/* DEBUG */

  again: /* UGHHH! */

    /*
     * Initialise things, including reading back the way that the
     * interface is currently set up.
     */
    ifc.ifc_len = sizeof(buf);
    ifc.ifc_buf = buf;

#ifdef DEBUG
    Printf("IC> Reading Interface(s) config (SIOCGIFCONF)...");
#endif

    if( socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0 )
    {
#ifdef DEBUG
        Printf("Failed - aborting\n");
#endif
        socketclose(s);
        return -1;
    }

#ifdef DEBUG
   Printf("Succeeded\n");
#endif/* DEBUG */

    ifr = ifc.ifc_req;

    /*
     * Check here to eliminate devices we have already seen.
     * We know if we have seen any by looking at the count.
     */
#ifdef DEBUG
    Printf("IC> Checking for known usable interfaces...");
#endif

    if (fw.fw_ifcnt != 0)
    {
#ifdef DEBUG
        Printf("Found some - skipping %d\n",fw.fw_ifcnt);
#endif

        last_bcast = fw.fw_ifbcast[(fw.fw_ifcnt)];

        for( n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++ )
        {
            /*
             * loop around the known interfaces.
             */
            ifreq = *ifr;

            /*
             * We are just checking for broadcast addresses here
             * since we know that if we cant do it, it doesnt
             * matter, and if we can then all we need to do is compare
             * against the last known broadcast address.
             */
            if( socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0 )
                continue;
            else
            {
                /*
                 * Make the address usable.
                 */
                sin = (struct sockaddr_in *)&ifreq.ifr_addr;

                /*
                 * If this address matches the last known one,
                 * move on to finding the new devices
                 */
                if (last_bcast == sin->sin_addr.s_addr)
                {
                    /*
                     * Since we know this interface we can
                     * skip it.
                     */
#ifdef DEBUG
                    Printf("Found last known interface - evaluating rest\n");
#endif/* DEBUG */

                    ifr++;
                    break;
                }
            }
        }
    }
#ifdef DEBUG
    else
        Printf("None known - evaluating rest\n");
#endif

    if (ifr == NULL)
    {
#ifdef DEBUG
        Printf("IC> Skipped all known interfaces - aborting\n");
#endif
        return fw.fw_ifcnt;
    }

    /*
     * Loop around the possible devices evaluating each one.
     */
    for( n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++ )
    {
        ifreq = *ifr;

#ifdef DEBUG
        Printf("IC> Evaluating found interface: ");
#endif

        /*
         * Check to see if its the loop back device. We dont want this
         */
        if( socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 ||
           ifreq.ifr_flags & IFF_LOOPBACK )
        {
#ifdef DEBUG
            Printf("loopback device - skipping\n");
#endif
            continue;
        }

        /*
         * The card also needs to be able to broadcast
         */
        if( (ifreq.ifr_flags & (IFF_BROADCAST | IFF_UP ))
           != (IFF_BROADCAST | IFF_UP ) )
        {
#ifdef DEBUG
            Printf("device bcast or up failure (flags = %x)\n",
                   ifreq.ifr_flags);
#endif
            continue;
        }

        /*
         * Get the address of the interface
         */
        if( socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0 )
        {
#ifdef DEBUG
            Printf("cant get interface address - skipping\n");
#endif
            continue;
        }

        /*
         * If we dont currently know the local address, set it to
         * the one we just found.
         */
        if( local_adr == 0 )
        {
            sin = (struct sockaddr_in *)&ifreq.ifr_addr;
            local_adr = sin->sin_addr.s_addr;

#ifdef DEBUG
            Printf("setting local_adr=%x...", sin->sin_addr.s_addr);
#endif/* DEBUG */

        }

#if 0
        /*
         * I think this would give nicer output, but it is
         * much too close to freeze to do at the moment
         */
        sprintf(name, "%s", inet_ntoa(sin->sin_addr));
#else
        sprintf(name, "%lx", sin->sin_addr.s_addr);
#endif

        setadrvar(fw.fw_ifcnt, name);
        fw.fw_ifaddrs[fw.fw_ifcnt] = sin->sin_addr.s_addr;

        /*
         * Find out the broadcast address. If we cant get it then
         * we dont want this device so retry from the start skipping
         * this address.
         */
        if( socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0 )
        {
#ifdef DEBUG
            Printf("Cant get broadcast address - unsetting local_addr\n");
#endif
            local_adr = 0;
            continue;
        }

        /*
         * Keep account of this card since it meets the requirements.
         */
#ifdef DEBUG
        Printf("Storing interface info.\n");
#endif
        sin = (struct sockaddr_in *)&ifreq.ifr_addr;
        fw.fw_ifbcast[(fw.fw_ifcnt)++] = sin->sin_addr.s_addr;
    }

    /*
     * We havent found a valid interface. Make up an address etc.
     * and use that instead (if we can find an ether driver.
     */
    if( fw.fw_ifcnt == 0 && !retried )
    {
#ifdef DEBUG
        Printf("IC> No usable devices found. Trying to make up an address\n");
#endif

        read_device_name(name, etheradr);

#ifdef DEBUG
        Printf("IC> Try using name: %s...",name);
#endif

        if( name[0] != 0 )
        {
            int retc;
            int irqstatus;

#ifdef DEBUG
            Printf("Making up ether address...");
#endif
            byte0 = (u_char)etheradr[5];
            byte1 = (u_char)etheradr[4];
            byte2 = (u_char)name[1];
#ifdef DEBUG
            Printf("Address derived from: %d %d %d...", byte0, byte1, byte2);
#endif
            sin = (struct sockaddr_in *)&ifreq.ifr_addr;

            /* next line modified 25/7/94 gw */
            sin->sin_addr = inet_makeaddr(1, (byte0 | byte1 << 8 |
                                              byte2 << 16));
            sin->sin_family = AF_INET;

            strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));

            irqstatus = ensure_irqs_off();
            ++setting_address;
            restore_irqs(irqstatus);
            retc = socketioctl(s, SIOCSIFADDR, (caddr_t)&ifreq);
            irqstatus = ensure_irqs_off();
            --setting_address;
            restore_irqs(irqstatus);

            if( retc >= 0 )
            {
#ifdef DEBUG
                Printf("Seeing if this settup works.\n");
#endif
                retried = 1;
                goto again;
            }
#ifdef DEBUG
            Printf("Unable to setup address.\n");
#endif
        }
    }

    /*
     * If we have found a valid interface....
     */
    if( fw.fw_ifcnt > 0 )
    {
        _kernel_swi_regs r;
        _kernel_oserror *e;
        struct address_q *q;
        u_long ipadr;

#ifdef DEBUG
        Printf("IC> Found valid interface. Looking at Econet_EnumerateMap:");
#endif/* DEBUG */

        r.r[4] = 0;
        for(;;)
        {
            e = _kernel_swi(XOS_Bit | Econet_EnumerateMap,&r, &r);
#ifdef DEBUG
            Printf("r4 = %d",r.r[4]);
#endif/* DEBUG */
            if (e || r.r[4] == -1) {
#ifdef DEBUG
                Printf("\n");
#endif/* DEBUG */
                break;
                }

            q = (struct address_q *)malloc(sizeof(struct address_q));
            if (!q) {
#ifdef DEBUG
                Printf("No more Found\n");
#endif/* DEBUG */
                break;
                }

            ipadr = (u_long)r.r[3];
#ifdef DEBUG
            Printf("Found: %s, adding. ",r.r[3]);
#endif/* DEBUG */
            q->q_bcast.s_addr = ipadr | 0xffff0000;
            q->q_next = fw.fw_netadrs;
            fw.fw_netadrs = q;
        }
    }

    /*
     * Tidy up and return
     */
#ifdef DEBUG
    Printf("IC> Done\n");
#endif/* DEBUG */

    socketclose(s);
    return fw.fw_ifcnt;
}

/**********************************************************************/

static int do_getsock(int port, int inputsocket)
{
    struct sockaddr_in addr;
    int sock, on = 1;

    if( (sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
#ifdef DEBUG
        Printf("DGS> Failed to open a socket - aborting\n");
#endif/* DEBUG */
        return (-1);
        }
#ifdef DEBUG
    Printf("DGS> Opened socket %d - ", sock);
#endif/* DEBUG */

    if( socketioctl(sock, FIONBIO, &on) < 0 ||
       socketioctl(sock, FIOASYNC, &on) < 0 )
    {
#ifdef DEBUG
        Printf("Cannot set FIONBIO and/or FIOASYNC.. Aborting\n");
#endif/* DEBUG */
        socketclose (sock);
        return (-1);
    }
#ifdef DEBUG
    Printf("FIONBIO..FIOASYNC..");
#endif/* DEBUG */


    if( setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0 )
    {
#ifdef DEBUG
        Printf("Unable to toggle SO_BROADCAST.. Aborting\n");
#endif/* DEBUG */
        socketclose(sock);
        return (-1);
    }
#ifdef DEBUG
    Printf("SO_BROADCAST..");
#endif/* DEBUG */


    if( inputsocket )
    {
        addr.sin_family      = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port        = htons((u_short)port);
#ifdef DEBUG
        Printf("Input socket, binding to %d..", port);
#endif/* DEBUG */

        if( bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0 )
        {
#ifdef DEBUG
            Printf("Bind failed - aborting\n");
#endif/* DEBUG */
            socketclose(sock);
            return (-1);
        }
    }

#ifdef DEBUG
    Printf("Bound.\n");
#endif/* DEBUG */

    return(sock);
}

/**********************************************************************/

static int callback(void (*func)())
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    return(_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
}

/**********************************************************************/

static void clear_callback(void (*func)())
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    (void)_kernel_swi(XOS_Bit | OS_RemoveCallBack, &r, &r);
}

/**********************************************************************/

extern void callb_entry(void);
static volatile int callbackflag = 0;
static volatile int readdevice_callback = 0;
#ifdef OldCode
static volatile int rscallbackflag = 0;
#endif

void setcallback(void)
{
#ifdef DEBUG
    Printf("SCB> setcallback (flag = %d)", callbackflag);
#endif/* DEBUG */

    if( callbackflag == 0 )
    {
        callbackflag = 1;

        if( callback(callb_entry) != 0 ) {
#ifdef DEBUG
            Printf("Failed\n");
#endif/* DEBUG */
            callbackflag = 0;
        }
    }

#ifdef DEBUG
    Printf("Ok!\n");
#endif/* DEBUG */

}

/**********************************************************************/

/*
 * fw_prime - prepare module for start/restart
 */
static void fw_prime(void)
{
#ifdef DEBUG
    Printf("FWP> In Freeway Prime\n");
#endif/* DEBUG */

    (void)init_msgs(MSG_FILE, msg_fd);

    /*
     * clear down the main Freeway information structure.
     */
    memset((char *)&fw, 0, sizeof(fw));

    /*
     * we currently have no sockets open
     */
    fw.fw_rssock = fw.fw_rssock1 = -1;

    /*
     * we no longer have a local address
     */
    local_adr = 0;

    /*
     * we have not yet completed a full startup
     */
    startup_done = 0;
}

/**********************************************************************/

/*ARGSUSED*/
_kernel_oserror *fw_init(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e;
    module_wsp = pw;

    /* shut the compiler up */
    cmd_tail = cmd_tail;
    pbase = pbase;

    fw_prime();

    /*
     * Look to see if the internet modules are present. If so
     * continue with initialisation.
     */
#ifdef DEBUG
    Printf("IN> Attempting to find the Internet module\n");
#endif

    if (inet_present() == 0)
    {
#ifdef DEBUG
        Printf("IN> Returning Internet not found\n");
#endif
        return (_kernel_oserror *)0;
    }

    e = fw_real_init();
    if (e)
        return (e);

    return (_kernel_oserror *)0;
}

/*
 * Set up the various even handlers.
 */
static _kernel_oserror *fw_setup_events(void)
{
    _kernel_oserror *e;

    /*
     * Set up a claim on an event vector (EventV)
     */
#ifdef DEBUG
    Printf("FWE> Looking to claim: EventV...");
#endif/* DEBUG */

    e = fw_claimv();

    if (e)
    {
#ifdef DEBUG
        Printf("Failed.\n");
#endif/* DEBUG */

        fw_final();
        return(e);
    }

    /*
     * Set up a claim on another event vector (Internet_Event)
     * to enable early trapping of read signals on sockets.
     */
#ifdef DEBUG
     Printf("OK.. Internet_Event...");
#endif/* DEBUG */

    e = fw_evenable();

    if (e)
    {
#ifdef DEBUG
        Printf("Failed.\n");
#endif/* DEBUG */

        fw_final();
        return(e);
    }

    /*
     * Set up a claim on an event vector (TickerV)
     * to be called every 10ms
     */
#ifdef DEBUG
    Printf("OK.. TickerV...");
#endif/* DEBUG */

    e = calleverytick(tick_entry);

    if (e)
    {
#ifdef DEBUG
        Printf("Failed\n");
#endif/* DEBUG */

        fw_final();
        return(e);
    }

#ifdef DEBUG
    Printf("Ok.\n");
#endif/* DEBUG */
    return(_kernel_oserror *) 0;
}

/**********************************************************************
 * This routine gets called once Internet has started. There is either
 * no point in doing some of these things before then (event handling)
 * or we cant do it (Device Driver evaluation). This can be called
 * from one of 2 places. Either the fw_init() if FW is initialising
 * after Internet and the DDs have loaded, or else from a SWI handle
 * when the required modules have been loaded.
 */
static _kernel_oserror *fw_real_init(void)
{
    _kernel_oserror *e;

    /*
     * Look to see what (if any) suitable DD are present.
     */
    fw.fw_ifcnt = 0;

#ifdef DEBUG
    Printf("RI> Doing interface count\n");
#endif

    read_ifs();
    if (fw.fw_ifcnt == 0)
    {
        /*
         * Internet has started, but no device drivers are present so
         * we should wait until some are.
         */
        return((_kernel_oserror *)0);
    }

    /*
     * Now set up event handlers
     */
#ifdef DEBUG
    Printf("RI> Setting up event handlers\n");
#endif

    e = fw_setup_events();
    if (e)
        goto out;

    /*
     * If we found no suitable interfaces or cannot open the required
     * socket, abort here.
     */

    if( fw.fw_ifcnt <= 0 || (fw.fw_rssock = do_getsock(FWPORT, 1)) < 0 )
    {
        e = fw_error(Err_FWNNet);
        goto out;
    }
#ifdef DEBUG
    Printf("RI> Opened Socket (Unauth socket) - %d\n", fw.fw_rssock);
#endif/* DEBUG */

    /*
     * Again, if we cant open the required socket, abort.
     */
    if( (fw.fw_rssock1 = do_getsock(FWPORT1, 1)) < 0 )
    {
        socketclose(fw.fw_rssock);
        e = fw_error(Err_FWNNet);
        goto out;
    }
#ifdef DEBUG
    Printf("RI> Opened Socket1 (Auth Socket) - %d\n", fw.fw_rssock1);
#endif/* DEBUG */

    /*
     * Notify that we have started.
     */
#ifdef DEBUG
    Printf("RI> Initialisation succeded\n");
#endif
    dostart = 1;
    startup_done = 1;
    setcallback();
    return((_kernel_oserror *)0);

out:
#ifdef DEBUG
    Printf("RI> Initialisation failed\n");
#endif
    fw_final();
    return(e);
}

/**********************************************************************
 * Notify an interest in the main event vector.
 */
static _kernel_oserror *fw_claimv(void)
{
    _kernel_swi_regs r;

    r.r[0] = EventV;
    r.r[1] = (int)fw_event_entry;
    r.r[2] = (int)module_wsp;
#ifdef DEBUG
    Printf(":FWC: Claiming EventV..");
#endif/* DEBUG */
    return(_kernel_swi(XOS_Bit | OS_Claim, &r, &r));
}

/*
 * 950330 KWelton
 *
 * Keep a count of event enables
 */
static volatile int nenables = 0;

/**********************************************************************
 * Lookout for Internet based Events. (SIGIO, SIGPIPE etc).
 */
_kernel_oserror *fw_evenable(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = Event_Enable;
    r.r[1] = Internet_Event;
#ifdef DEBUG
    Printf(":FEV: Enabling Internet_Events..");
#endif/* DEBUG */

    if( (e = _kernel_swi(XOS_Bit | OS_Byte, &r, &r)) == NULL )
    {
        int s = ensure_irqs_off();
        ++nenables;
        restore_irqs(s);
    }

    return(e);
}

/**********************************************************************
 * Release event handlers
 */
static void fw_releasev(void)
{
    _kernel_swi_regs r;

#ifdef DEBUG
    Printf("FWR> Releasing Internet_event (nenables = %d)...", nenables);
#endif/* DEBUG */

    r.r[0] = Event_Disable;

    while( nenables > 0 )
    {
        r.r[1] = Internet_Event;

        if( _kernel_swi(OS_Byte, &r, &r) == NULL )
        {
            int s = ensure_irqs_off();
            --nenables;
            restore_irqs(s);
        }
        else
        {
            /*
             * make the best of a very bad job
             */
            nenables = 0;
            continue;                           /* XXX */
        }
    }

#ifdef DEBUG
    Printf("EventV\n");
#endif/* DEBUG */

    r.r[0] = EventV;
    r.r[1] = (int)fw_event_entry;
    r.r[2] = (int)module_wsp;
    (void)_kernel_swi(XOS_Bit | OS_Release, &r, &r);
}

/**********************************************************************
 * Attempt to open the message file.
 */

_kernel_oserror *init_msgs(char *filename, char *fd)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    /*
     * Look to see if the messages file exists. If it doesnt,
     * there isnt much point in continuing.
     */
    r.r[1] = (int)filename;
    e = _kernel_swi(XOS_Bit | MessageTrans_FileInfo, &r, &r);
    if (e)
        return (e);

    /*
     * If we can get file information then we should be able to open it
     * so look to see if we can.
     */
    r.r[0] = (int)fd;
    r.r[1] = (int)filename;
    r.r[2] = 0;
    e = _kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r);
    return (e);
}

/**********************************************************************
 * Close the messages file
 */

static void release_msgs(char *fd)
{
    _kernel_swi_regs r;

    if (fd!=(char *)0) {
        r.r[0] = (int)fd;
        (void)_kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
        }
}

/**********************************************************************
 * Error handler
 */

_kernel_oserror *fw_error(int error)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    if( !error )
        return((_kernel_oserror *)0);

    ebuf.e_nbr = error_blocks[error].err_nbr;
    strcpy(ebuf.e_string, error_blocks[error].err_token);
    memset ((char *)&r, 0, sizeof(r));
    r.r[0] = (int)&ebuf;
    r.r[1] = (int)msg_fd;
    e = _kernel_swi(XOS_Bit | MessageTrans_ErrorLookup, &r, &r);
    return(e ? e : (_kernel_oserror *)&ebuf);
}

/**********************************************************************
 * Command line interface handler... just *fwshow
 */

/*ARGSUSED*/
_kernel_oserror *fw_cli_handler(char *arg_string, int arg_count,
                                int cmd_no, void *pw)
{
    struct client *callp;
    _kernel_oserror *error = NULL;

    /* shut the compiler up */
    pw = pw;

    if (startup_done)
    {
        callp = &fw_cli_call[cmd_no];
        (*(callp->cli_call))(arg_string, arg_count);
    }
    else
        error = fw_error(Err_FWNoInet);

    return(error);
}

/**********************************************************************
 * FWShow command. This lists all known access hosts and disks that
 * can be shared. -- Added in the definitions of DOMAIN_DISK and
 * DOMAIN_HOST (PWain).
 */

/*ARGSUSED*/
static void fw_show(char *a, int b)
{
    struct fwtype *f;
    struct object_q *rl;
    struct address_q *q;

    /* shut the compiler up */
    a = a;
    b = b;

    /*
     * printf("Interfaces found: %d\n\n",fw.fw_ifcnt);
     *
     * Display any remote networks known about.
     */
    if( fw.fw_netadrs == 0 )
        printf("No remote nets\n");
    else
    {
        printf("net addresses:\n");
        for( q = fw.fw_netadrs; q; q = q->q_next )
            printf("%s\n", inet_ntoa(q->q_bcast));
    }
    printf("\n");

    /*
     * Display information about Freeway types that are known.
     */
    for( f = fw.fw_types; f; f = f->fw_next )
    {
        if (f->fw_number == DOMAIN_DISK)
             printf("Type %d: (Discs)\n", DOMAIN_DISK);
        else if (f->fw_number == DOMAIN_HOST)
             printf("Type %d: (Hosts)\n", DOMAIN_HOST);
        else if (f->fw_number == DOMAIN_PRINTER)
             printf("Type %d: (Printers)\n", DOMAIN_PRINTER);
        else printf("Type %d:\n", f->fw_number);

        for( rl = f->fw_remobj; rl; rl = rl->r_next )
        {
            /*
             * If this entry isnt in use ignore it.
             */
            if( !rl->r_inuse )
                continue;

            /*
             * Show entry. Local ones are prefixed with a "*"
             */
            if( rl->r_local )
                printf("   *Name=%-10s Holder=%s\n",
                       rl->r_title, inet_ntoa(rl->r_ip));
            else
                printf("    Name=%-10s Holder=%s\n",
                       rl->r_title, inet_ntoa(rl->r_ip));
        }

        if( f->fw_next )
            printf("\n");
    }
}

/**********************************************************************/

static void fw_servicecall(int sc)
{
    _kernel_swi_regs r;

#ifdef DEBUG
    Printf("FSC> Sending service call: %x\n",sc);
#endif
    r.r[1] = sc;
    (void) _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
}

/**********************************************************************/

void fw_upcall(int upc, int type, struct object_q *rq)
{
    _kernel_swi_regs r;

#ifdef DEBUG
    switch(upc) {
        case FW_ADDED: Printf("FWU> Upcall: added "); break;
        case FW_REMOVED: Printf("FWU> Upcall: removed "); break;
        case FW_CHANGED: Printf("FWU> Upcall: changed "); break;
        case FW_DELETED: Printf("FWU> Upcall: deleted "); break;
        default: Printf("FWU> Upcall: operation: %d ",upc); break;
        }
    switch(type) {
        case DOMAIN_DISK: Printf("disc "); break;
        case DOMAIN_HOST: Printf("host "); break;
        case DOMAIN_PRINTER: Printf("printer "); break;
        default: Printf("type=%d",type); break;
        }
    Printf("Name: %s, Address: %x\n", rq->r_title , rq->r_ip.s_addr);
#endif/* DEBUG */

    r.r[0] = UpCall_Freeway;
    r.r[1] = upc;
    r.r[2] = type;
    r.r[3] = (int)rq->r_title;
    r.r[4] = rq->r_desclen;
    r.r[5] = (int)rq->r_desc;
    r.r[6] = (u_int)rq->r_ip.s_addr;
    (void)_kernel_swi(XOS_Bit | OS_UpCall, &r, &r);
}

/**********************************************************************
 * The main SWI handler. This basically looks up and calls the desired
 * (real) handler.
 */
_kernel_oserror *fw_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;

    /* shut the compiler up */
    pw = pw;

    /* range check the SWI number */
    if( swinum >= (sizeof(fw_ent) / sizeof(fw_ent[0])) )
        return(fw_error(Err_FWInvalSWI));

    if (startup_done || (swinum == 4) )
    {
        /*
         * Call the desired SWI handler.
         */
#ifdef DEBUG
        switch(swinum) {
            case 0: Printf("FWS> Handling SWI: Freeway_Register\n"); break;
            case 1: Printf("FWS> Handling SWI: Freeway_Write\n"); break;
            case 2: Printf("FWS> Handling SWI: Freeway_Read\n"); break;
            case 3: Printf("FWS> Handling SWI: Freeway_Enumerate\n"); break;
            case 4: Printf("FWS> Handling SWI: Freeway_Status\n"); break;
            default: Printf("FWS> Handling SWI: %d\n", swinum); break;
            }
#endif
        callp = &fw_ent[swinum];
        return((_kernel_oserror *)((callp->swi_call)(r)));
    }

    /*
     * Note: if we had done startup, a return would have been
     * encountered by this point so we can safely do the rest
     * without needing to test. This removes a compiler warning.
     * (No return from function)
     */
    return(fw_error(Err_FWNoInet));
}

/**********************************************************************/

struct fwtype *gettype(int type)
{
    struct fwtype *f;

    for( f = fw.fw_types; f != 0; f = f->fw_next )
        if( f->fw_number == type )
            return(f);

    return ((struct fwtype *)0);
}

/**********************************************************************/

int type_id(char *str)
{
    int type = atoi(str);

    if (type > 0)
        return(type);

    return(-1);
}

/**********************************************************************/

int callb_handler(void)
{
#ifdef DEBUG
    Printf("CBH> In callback handler: ");
#endif/* DEBUG */

    if( callbackflag == 0 ) {
#ifdef DEBUG
        Printf("No callbacks to do - aborting\n");
#endif/* DEBUG */
        return (1);
        }

    callbackflag = 0;

    if( dostart )
    {
        dostart = 0;
#ifdef DEBUG
        Printf("Send FreewayStarting service call..\n");
#endif
        fw_servicecall(Service_FreewayStarting);
    }

    if( doobjects )
    {
#ifdef DEBUG
        Printf("Calling do_objects_on_callback.\n");
#endif/* DEBUG */

        doobjects = 0;
        do_objects_on_callback();
    }

#ifdef DEBUG
    Printf("\n");
#endif/* DEBUG */

    return (1);
}

/**********************************************************************/

static _kernel_oserror *calleverytick(int (*fun)())
{
    _kernel_oserror *e;
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    e = _kernel_swi(XOS_Bit | OS_Claim, &r, &r);
    if (e)
        return (e);

    return((_kernel_oserror *)0);
}

/**********************************************************************/

static void removetickerevent(int (*fun)())
{
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    (void)_kernel_swi(XOS_Bit | OS_Release, &r, &r);
}

/**********************************************************************/

int tick_handler(void)
{
    struct fwtype *f;

/*
 * This produces WAY too much stuff
 *
#ifdef DEBUG
    Printf("FTH> In tickerV handler. Checking all objects.\n");
#endif
 */


    for( f = fw.fw_types; f != 0; f = f->fw_next )
        check_objects(f);

    return (1);
}

/**********************************************************************/

void fw_final(void)
{
    struct fwtype *f;
    struct address_q *q, *qnext;

#ifdef DEBUG
    Printf("FWF> In freeway finalisation. Closing down: Messages..");
#endif/* DEBUG */

    release_msgs(msg_fd);

    for( f = fw.fw_types; f != 0; f = f->fw_next )
    {
#if 0
        do_protocol(f, INADDR_BROADCAST, 0, REMOVE);
#else
        /*
         * XXX - the wrong number of parameters are passed
         * in the version above: make a *guess* at passing
         * it the correct values.
         */
#ifdef DEBUG
        switch(f->fw_number) {
            case DOMAIN_DISK: Printf("Discs.."); break;
            case DOMAIN_PRINTER: Printf("Printers.."); break;
            case DOMAIN_HOST: Printf("Hosts.."); break;
            default: Printf("type: %d.."); break;
            }
#endif /* DEBUG */
        do_protocol(f, INADDR_BROADCAST, 0, REMOVE, 0, 0, 1);
#endif
    }

#ifdef DEBUG
    Printf("Events...\n");
#endif/* DEBUG */
    fw_releasev();

    if( fw.fw_rssock >= 0 )
    {
#ifdef DEBUG
        Printf("FWF> Closing: Socket..");
#endif/* DEBUG */
        socketclose(fw.fw_rssock);
        fw.fw_rssock = -1;
    }

    if( fw.fw_rssock1 >= 0 )
    {
#ifdef DEBUG
        Printf("Socket1..");
#endif/* DEBUG */
        socketclose(fw.fw_rssock1);
        fw.fw_rssock1 = -1;
    }

#ifdef DEBUG
    Printf("Ticker events..");
#endif/* DEBUG */
    removetickerevent(tick_entry);

#ifdef DEBUG
    Printf("Sending termination call\n");
#endif/* DEBUG */
    fw_servicecall(Service_FreewayTerminating);

    /*
     * 950331 KWelton
     *
     * clear any pending callbacks
     */
    if( callbackflag != 0 )
    {
        clear_callback(callb_entry);
        callbackflag = 0;
    }

    if( readdevice_callback != 0 )
    {
        clear_callback(readdevice_entry);
        readdevice_callback = 0;
    }

    /*
     * 950308 KWelton
     *
     * free the structures malloc'ed by read_ifs()
     */
#ifdef DEBUG
    Printf("FWF> Freeing memory\n");
#endif/* DEBUG */

    for( q = fw.fw_netadrs; q; q = qnext )
    {
        qnext = q->q_next;
        (void)free(q);
    }
}

/**********************************************************************/

static void rs_process_input(int format)
{
    struct sockaddr_in from;
    int fromlen, r;
    char inbuf[1024];

#ifdef DEBUG
    Printf("RPI> Reading network activity (%s):-\n", format == 0 ? "unauth" :
                "auth");
#endif/* DEBUG */

    for(;;)
    {
        fromlen = sizeof (from);
        r = recvfrom(format == 0 ? fw.fw_rssock : fw.fw_rssock1,
                     inbuf, sizeof(inbuf), 0,
                     (struct sockaddr *)(&from), &fromlen);

        if( r < 0 || fromlen != sizeof(struct sockaddr_in) ) {
#ifdef DEBUG
            Printf("RPI: read failed. r=%d, errno=%d\n", r, errno);
#endif/* DEBUG */
            break;
            }

#ifdef DEBUG
       Printf("RPI: read %d bytes from %x\n", r, from.sin_addr.s_addr);
#endif/* DEBUG */

        if( !is_from_us(from.sin_addr.s_addr) )
            process_message(from.sin_addr.s_addr, (struct rs_msg *)inbuf,
                            r, format);
    }
}

/**********************************************************************/

int fw_event_handler(int *r)
{
    int s, format;

#ifdef DEBUG
    Printf("FEH> r0=%s r1=%s ",
         r[0]==Internet_Event ? "Internet_Event" : "Other Event" ,
         r[1]==SocketIO ? "SIGIO" : "SIGOther");

    if (r[2]==fw.fw_rssock) {
        Printf("r2=Socket(unauth) ");
        }
    else if (r[2]==fw.fw_rssock1) {
        Printf("r2=Socket1(auth) ");
        }
    else Printf("r2=%d ",r[2]);
#endif/* DEBUG */

    if( r[0] == Internet_Event && r[1] == SocketIO )
    {
        if( r[2] == fw.fw_rssock )
            format = 0;
        else if( r[2] == fw.fw_rssock1 )
            format = 1;
        else
            return (1);

#ifdef DEBUG
        Printf("Format=%s\n", format==0 ? "Unauth" : "Auth");
#endif/* DEBUG */

        s = ensure_irqs_on();
        rs_process_input(format);
        restore_irqs(s);
        return(0);
    }

    return(1);
}

/**********************************************************************/

static int is_from_us(u_long src)
{
    int i;

    for( i = 0; i < fw.fw_ifcnt; i++ )
        if( fw.fw_ifaddrs[i] == src )
            return (1);

    return (0);
}

/**********************************************************************
 * To see if the Internet module is present do a lookup on its name.
 * This will succeed if it is loaded :) Much simpler than the old
 * method.
 */
static int inet_present(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *err;

#ifdef DEBUG
    Printf("IP>> Looking for module: %s\n", protocol_name);
#endif
    r.r[0] = 18;
    r.r[1] = (int)protocol_name;
    err = _kernel_swi(XOS_Bit | OS_Module, &r, &r);

    if (!err)
    {
#ifdef DEBUG
        Printf("IP>> Found Internet module!\n");
#endif
        return 1;
    }

#ifdef DEBUG
    Printf("IP>> Found error : %s\n",err->errmess);
    Printf("IP>> Found error : %x\n",err->errnum);
#endif

    return 0;
}

/*
 * This is the main entry point that we have for picking up if new
 * devices come on line. DCI4 has service calls that announce them
 * for us. Other events may (or maynot) be worth watching for.
 */
void fw_service(int service_number, _kernel_swi_regs *r, void *pw)
{
    /* shut the compiler up */
    pw = pw;

    switch( service_number )
    {
      case Service_MessageFileClosed:
        (void)init_msgs(MSG_FILE, msg_fd);
        break;

        /*
         * If we get a device driver status call we need to update
         * our own count of the drivers present and see if its one
         * that we are going to use.
         */
      case Service_DCIDriverStatus:
#ifdef DEBUG
        Printf("DD> Received Driver status request\n");
        Printf("DD> Device: %s\n", ((struct dib *)r->r[0])->dib_name);
#endif
        /*
         * 950315 KWelton
         *
         * we are only interested in device
         * drivers that are starting up
         */
        if( r->r[2] == 0 )
        {
            readdevice_callback = 1;
            callback(readdevice_entry);
        }

        break;

        /*
         * DCIProtocol calls are done when any protocol (eg internet)
         * startup.
         */
      case Service_DCIProtocolStatus:
        /*
         * we are only interested in the internet module
         */
        if( !strncmp((char *)r->r[4], (char *)protocol_name,
                     sizeof(protocol_name) + 1) )
        {
            /*
             * it's internet - check its status
             */
            if (r->r[2] == 0)
            {
                /* internet is starting */
#ifdef DEBUG
                Printf("PP> Internet startup\n");
#endif

                /*
                 * 950306 KWelton
                 *
                 * we don't need to worry if we have already initialised
                 */
                if( startup_done )
                    break;

#ifdef DEBUG
                Printf("PP> Looking to start up Freeway.\n");
#endif

                (void)fw_real_init();
            }
            else if( r->r[2] == 1 )
            {
                /*
                 * internet is terminating - shut freeway
                 * down, then prepare it for restart
                 */
#ifdef DEBUG
                Printf("PP> Internet termination\n");
#endif
                fw_final();
                fw_prime();
            }
        }

        break;

      case Service_InternetStatus:
#ifdef DEBUG
        Printf("Service_InternetStatus: reason %d (setting_address = %d)\n",
               r->r[0], setting_address);
#endif

        switch( r->r[0] )
        {
          case InternetStatus_AddressChanged:
            /*
             * an internet interface has had its address
             * changed - shutdown and restart Freeway as
             * long as it's not us that set the address.
             */
            if( !setting_address )
            {
                fw_final();
                fw_prime();
                fw_real_init();
            }

            break;

          default:
            break;
        }

        break;

      default:
        break;
    }

    return;
}

int readdevice_handler(void)
{


    if (startup_done == 0) {
        /*
         * This is the 1st interface we know of that we can use so
         * we should try and finish the initialisation.
         */
#ifdef DEBUG
        Printf("CB> Calling reall initialisation.\n");
#endif
        (void)fw_real_init();
        }
    else {
        /*
         * Otherwise just add the interface to the list.
         */
#ifdef DEBUG
        Printf("CB> Calling interface count\n");
#endif
        (void)read_ifs();
        }
    return 1;
}

/*
 * FreewayStatus added 16-02-95. Status request is:
 *
 * calling:
 *
 * r0 == reason code.
 * all other registers reserved.
 *
 * return
 *
 * if r0 = 0  status request
 *
 * r1 = 0 freeway loaded but idle - eg no ether drivers
 * r1 = 1 freeway running.
 * all other registers reserved.
 *
 */
static _kernel_oserror *FreewayStatus(_kernel_swi_regs *r)
{
    switch(r->r[0])
    {
      case 0:
        /* status request - return startup flag */
        r->r[1] = startup_done;
        return(NULL);

        /*NOTREACHED*/
        break;

      default:
        return(fw_error(Err_FWStatus));
    }
}

/**********************************************************************/

/* EOF module.c */
