/*	IFRCONFIG.C

Project : DEC Westminster trial
Module:

Purpose:


History:

Date      Who     Description of change
===========================================
24/10/95   CP     Changed bootp loop to do MAX_TRIES bootp, and reset if it
                  fails rather than retry 8 times, then go to desktop.

                  This is to get around a bug in bootp which means that
                  only one bootp request is sent, even though there may be
                  many requests to do it.

***************************************************************************/


#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/route.h>
#include <netinet/in.h>
#include <net/if.h>
#include <stdio.h>
#include <sys/errno.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

extern int errno;

static struct sockaddr_in ipaddr = { 0 };
#if 0
static struct sockaddr_in broadcast = { 0 };
/* For getting netmask via ICMP (no longer required). */
struct sockaddr_in netmask = { 0 };
#endif

#define MAX_TRIES 1

#define FLAGCMOS            0x6D
#define FLAGBIT             (1<<2)
#define NCIPCMOS            0x1E
#define SERVERIPCMOS        0x22
#define GATEWAYIPCMOS       0x26
#define NETMASKCMOS         0x2A
#define DNSIPCMOS           0x95
#define BOOTMOUNTCMOS       0x50

#define PATHSZ      27

extern char *inet_ntoa( struct in_addr in );

/*
 * set_default_route
 *
 * - takes as parameter an open socket id
 * - reads the system variable Inet$Gateway (string a.b.c.d)
 * - converts the var string to u_long inet address
 * - establishes that address as the default route
 *
*/

static struct rtentry route;

static int set_default_route(int sockid)
{
    char buf[32];
    unsigned long gateway_adr, inet_addr();
    _kernel_swi_regs r;
    _kernel_oserror *e;
    struct sockaddr_in *sin;

    r.r[0] = (int)"Inet$Gateway";
    r.r[1] = (int)buf;
    r.r[2] = sizeof(buf);
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
    if (e || r.r[2] == 0)
        return (1);         /* If variable is not set then return success. */
    buf[r.r[2]] = 0;

    gateway_adr = inet_addr(buf);
    if (gateway_adr == 0)
        return (0);

    sin = (struct sockaddr_in *)&route.rt_dst;
    sin->sin_family = AF_INET;
    sin->sin_addr = inet_makeaddr(0, INADDR_ANY);
    sin = (struct sockaddr_in *)&route.rt_gateway;
    sin->sin_family = AF_INET;
    sin->sin_addr.s_addr = gateway_adr;
    route.rt_flags = RTF_UP;
    route.rt_flags |= RTF_GATEWAY;

    if (socketioctl(sockid, SIOCADDRT, (caddr_t)&route) < 0)
        return (0);
    return (1);
}

/*
 * set_netmask
 *
 * - takes as parameter an open socket id
 * - reads the system variable Inet$EtherIPMask (string a.b.c.d)
 * - converts the var string to u_long value
 * - establishes that value as the netmask
 *
*/

static int set_netmask(int sockid, char *ifname)
{
    char buf[32];
    unsigned long net_mask, inet_addr();
    _kernel_swi_regs r;
    _kernel_oserror *e;
    struct sockaddr_in *sin;
    struct  ifreq ifr;

    r.r[0] = (int)"Inet$EtherIPMask";
    r.r[1] = (int)buf;
    r.r[2] = sizeof(buf);
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
    if (e || r.r[2] == 0)
        return (1);         /* If variable is not set then return success. */
    buf[r.r[2]] = 0;

    net_mask = inet_addr(buf);
    if (net_mask == 0)
        return (0);

    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
    sin = (struct sockaddr_in *)&ifr.ifr_addr;
    sin->sin_addr.s_addr = net_mask;
    sin->sin_family = AF_INET;
    if (socketioctl(sockid, SIOCSIFNETMASK, (caddr_t)&ifr) < 0)
        return (0);
    return (1);
}


#ifdef USECMOS

/* Read an IP address (or 4 byte value) from CMOS.
 */
static u_long
ReadIPCMOS( int location )
{
    int i;
    u_long result = 0;
    _kernel_swi_regs r;

    r.r[0] = 161;

    for ( i = 0; i < 4; i++ )
    {
        r.r[1] = location++;
        _kernel_swi( OS_Byte, &r, &r );
        result |= (r.r[2] & 0xFF) << (i * 8);
    }

    return result;
}

/* Read a \0 terminated string from CMOS.
 */
static void
ReadStringCMOS( int location, char *p, int bufsz )
{
    _kernel_swi_regs r;

    r.r[0] = 161;

    while ( --bufsz )
    {
        r.r[1] = location++;
        _kernel_swi( OS_Byte, &r, &r );
        *p++ = r.r[2];
        if (r.r[2] == '\0') return;
    }
    *p = '\0';
}

static void
SetVarVal( char *var, char *val )
{
    _kernel_swi_regs r;

    r.r[0] = (int)var;
    r.r[1] = (int)val;
    r.r[2] = strlen(val) + 1;
    r.r[3] = 0;
    r.r[4] = 0;
    _kernel_swi( OS_SetVarVal, &r, &r );
}

static int set_ipaddr( int s, char *ifname, struct in_addr *v )
{
    struct ifreq ifr;
    struct sockaddr_in *sin;

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
    sin = (struct sockaddr_in *)&ifr.ifr_addr;
    sin->sin_addr.s_addr = v->s_addr;
    sin->sin_family = AF_INET;
    if (socketioctl(s, SIOCSIFADDR, (caddr_t)&ifr) < 0)
        return (0);
    return 1;
}

static int use_configured_info( int s, char *ifname )
{
    _kernel_swi_regs r;

    r.r[0] = 161;
    r.r[1] = FLAGCMOS;
    _kernel_swi( OS_Byte, &r, &r );
    if ( r.r[2] & FLAGBIT )
    {
        struct in_addr v;

        v.s_addr = ReadIPCMOS( NCIPCMOS );
     	if ( set_ipaddr(s, ifname, &v) != 0 )
     	{
            char buf[PATHSZ];
    
            printf("Using static IP information\n");

            v.s_addr = ReadIPCMOS( SERVERIPCMOS );
            SetVarVal( "Inet$BootServer", inet_ntoa(v) );
    
            v.s_addr = ReadIPCMOS( GATEWAYIPCMOS );
            SetVarVal( "Inet$Gateway", inet_ntoa(v) );
    
            v.s_addr = ReadIPCMOS( NETMASKCMOS );
            SetVarVal( "Inet$EtherIPMask", inet_ntoa(v) );
    
            v.s_addr = ReadIPCMOS( DNSIPCMOS );
            SetVarVal( "Inet$Resolvers", inet_ntoa(v) );
    
            ReadStringCMOS( BOOTMOUNTCMOS, buf, PATHSZ );
            SetVarVal( "Inet$BootFile", buf );
            SetVarVal( "Inet$MountPath", buf );
    
            return 1;
        }
    }

    return 0;
}

#endif


int ifrconfig(s, ifname)
int s;
char *ifname;
{
        struct  ifreq ifr;
        char *inet_ntoa();
        _kernel_swi_regs r;

#ifdef USECMOS
        /* Try static IP information first.
         */
        if ( use_configured_info(s, ifname) == 0 )
        {
#endif
            printf("Looking for a boot server\n");
            strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
            if (socketioctl(s, SIOCGWHOIAMRB, (caddr_t)&ifr) < 0)
            {
                if (left_alt_is_pressed() && right_alt_is_pressed())
                    return (0);
    
                printf("\nCannot find a boot server\n");

                /* reset box */
                _kernel_swi(OS_Reset, &r, &r);
            }
#ifdef USECMOS
        }
#endif

        strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
        if (socketioctl(s, SIOCGIFADDR, (caddr_t)&ifr) < 0) {
            printf("\nCannot read my net address\n");
            return (0);
        }
        ipaddr.sin_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
        printf("My net address is %s\n", inet_ntoa(ipaddr.sin_addr));

        /* Try to set the default route if necessary. */
        if (set_default_route(s) == 0)
            printf("Cannot set the default route\n");

        /* Try to set the sub-net mask if necessary. */
        if (set_netmask(s, ifname) == 0)
            printf("Cannot set the sub-net mask\n");

#if 0
        /* Gets netmask via ICMP (no longer required).
         */
        printf("Looking for NetMask ..\n");
        (void) socketioctl(s, SIOCGWHOIAMM, (caddr_t)&ifr);
        strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
        if (socketioctl(s, SIOCGIFNETMASK, (caddr_t)&ifr) < 0) {
            printf("Cannot read NetMask\n");
            return (0);
        }
        netmask.sin_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
        printf("NetMask is %x\n", ntohl(netmask.sin_addr.s_addr));
#endif

        return (1);
}



