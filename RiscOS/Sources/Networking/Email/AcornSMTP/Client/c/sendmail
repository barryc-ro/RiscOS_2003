/*	Project Post (769) - AcornSMTP
	Acorn Risc Technologies
	Copyright © 1996. All Rights Reserved.

	FILE:		sendmail.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.09 for RISC OS

	OVERVIEW
	========
	Source file for implementation of 
	
	HISTORY
	=======
	07/11/97	0.01	RDW	Initial version
	10/02/97	0.02	RDW	ANT_sendmail tidied up and commented
	17/11/97	0.03	RDW	Re-implemented taking logon.c from
					AcornPOP3 0.15 as a basis.  Now a non-blocking
					FSM.
	19/11/97	0.04	RDW	Fixed bug where QUIT state never entered because
					ENDOFDATARESPONSE state switch to COMPLETED instead!
					Also, returned data structure to client not setup
					before notifying the client and socket number not
					copied in, so it wasn't reset to -1.
					COMPLETED and ERROR changed so they check socket descriptor
					value is >=0 before closing it.
	07/12/97	0.05	RDW	lookup Inet$LocalDomain for our localhostname for HELO command
					not strictly RFC correct, but close enough for now
	11/12/97	0.06	RDW	fixed memory version so that it moves through the message to
					the next buffers worth.  It didn't do this before, so never
					reached the end of the message, just kept reading & sending
					the first buffers worth forever....
	13/01/98	0.07	RDW	Fixed call to Resolver_GetHost so it catches R0 being non-0
	14/01/98	0.08	RDW	sendmail_FSM_FROM_RESPONSE changed if MAIL FROM response is
					not successful, error is now FAILEDTOSEND and response is
					returned to caller.
					sendmail_FSM_TO_RESPONSE changed if RCPT TO response is
					not successful, error is now FAILEDTOSEND and response is
					returned to caller.
					FATALERROR state added (this was the original ERROR state
					The ERROR state now trys to do a QUIT SMTP command
					before switching the FATALERROR to return the error to
					the client).
	21/01/98	0.09	RDW	Fixed bug on exit from FSM which prevented all the work
					of 0.08 from working as it cleared all the error and
					errno returned to the client process!
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "sys/errno.h"
#include "netdb.h"
#include "socklib.h"
#include "inetlib.h"
#include "unixlib.h"
#include "sys/filio.h"
#ifdef MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif


/* ************************************************************************** */
/*                                                                            */
/* Include header files - External Libraries                                  */
/*                                                                            */
/* ************************************************************************** */
#include "DebugLib.h"
#include "Elib_priv.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "sendmail.h"
#include "errortable.h"
#include "cmdresp.h"
#include "smtp_utils.h"
#include "send.h"


/* ************************************************************************** */
/*                                                                            */
/* External globals                                                           */
/*                                                                            */
/* ************************************************************************** */
extern int inuse;								// process1 in use?
extern process_details process1;						// This client's process detail
extern int timeouts[];								// default timeouts


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
static const int SLEEP_TIME    = 1;
static const int TIME_SLICE  = 50;						/* Time slice to use                                                   */
static const int PORT_NUMBER = 25;						/* Default TCP port number to use                     */
static const int BUF_SIZE = 1024;
static const char sys_var_Servername[] = "Inet$SMTP_SendDefault_Servername";
/*static const char sys_var_SMTP_Default_Port[] = "Inet$SMTP_Default_Port";*/	/* NOT IMPLEMENTED YET!                               */
#define Resolver_GetHost 0x066001


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  INIT,
  GET_HOST,
  GET_HOST_NB,
  PREPARE_CONNECT,
  CONNECT,
  GREETING,
  HELO,
  FROM,
  FROM_RESPONSE,
  TO,
  TO_RESPONSE,
  DATA,
  DATA_RESPONSE,
  GET_DATA_BLOCK,
  SEND_DATA_BLOCK,
  END_OF_DATA,
  END_OF_DATA_RESPONSE,
  QUIT,
  QUIT_RESPONSE,
  ERROR,
  FATALERROR,
  COMPLETED
} STATES;									/* sendmail FSM states                                 */

typedef struct
{
  time_t              t_slice;							/* timeslice, time to exit FSM by for re-entracy later */
  _kernel_oserror    *error;							/* OS error                                            */
  int                 errno;							/* Internet errno copy                                 */
  _kernel_oserror    *error_copy;						/* COPY OF OS error - used for graceful ERROR REPORT   */
  int                 errno_copy;						/* COPY OF Internet errno copy, as error_copy above    */
  BOOL                end;							/* has the FSM ended?                                  */
  BOOL                exit;							/* exit FSM without setting callback                   */
  BOOL                file;
  char               *hostname;							/* hostname of SMTP server to connect to               */
  char               *localhost;						/* hostname of us on the network interface we are connection to the server with */
  char               *message;
  char               **recipients;
  char               **senders;
  int                 port_number;						/* TCP port number to use                              */
  int                 sock;							/* socket descriptor                                   */
  struct sockaddr_in  smtp_server_addr;						/* connection address structure                        */
  struct hostent     *smtp_server;						/* server address structure                            */
  struct servent     *smtp_service;						/* service struct from Service lookup in services file */
  char               *response;							/* response line from server                           */
  char               *response_copy;						/* COPY OF response line from server                   */
  u_long              addr;							/* 32bit address for dotted IP lookup                  */
  _kernel_swi_regs    r;							/* SWI registers to use in SWI calls                   */
  char               *send_data;						/* data to send to server                              */
  int                 length;							/* length of data                                      */
  int                 greeting_timeout;						/* timeout for waiting for server greeting on connect  */
  int                 helo_timeout;						/* timeout for waiting for user command to complete    */
  unsigned int        senders_success;						/* how many successful MAIL FROMS have there been      */
  unsigned int        senders_pos;						/* position in senders array */
  unsigned int        num_of_senders;
  unsigned int        num_of_recipients;
  unsigned int        recipients_success;					/* how many successful MAIL FROMS have there been      */
  unsigned int        recipients_pos;						/* position in senders array */
  
  unsigned int        buf_len;
  unsigned int        buf_size;
  FILE               *fd;
  char               *buffer;
  BOOL                end_of_data;
  char                prev_char;
  BOOL                new_line;
  STATES              state;							/* sendmail FSM state                                  */
} sendmail_context;


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static sendmail_context *new_sendmail_context(void);
static void destroy_sendmail_context(sendmail_context **c);
static void sendmail_FSM_INIT(sendmail_context *c);
static void sendmail_FSM_GET_HOST_NB(sendmail_context *c);
static void sendmail_FSM_GET_HOST(sendmail_context *c);
static void sendmail_FSM_PREPARE_CONNECT(sendmail_context *c);
static void sendmail_FSM_CONNECT(sendmail_context *c);
static void sendmail_FSM_GREETING(sendmail_context *c);
static void sendmail_FSM_HELO(sendmail_context *c);
static void sendmail_FSM_FROM(sendmail_context *c);
static void sendmail_FSM_FROM_RESPONSE(sendmail_context *c);
static void sendmail_FSM_TO(sendmail_context *c);
static void sendmail_FSM_TO_RESPONSE(sendmail_context *c);
static void sendmail_FSM_DATA(sendmail_context *c);
static void sendmail_FSM_DATA_RESPONSE(sendmail_context *c);
static void sendmail_FSM_GET_DATA_BLOCK(sendmail_context *c);
static void sendmail_FSM_SEND_DATA_BLOCK(sendmail_context *c);
static void sendmail_FSM_END_OF_DATA(sendmail_context *c);
static void sendmail_FSM_END_OF_DATA_RESPONSE(sendmail_context *c);
static void sendmail_FSM_QUIT(sendmail_context *c);
static void sendmail_FSM_QUIT_RESPONSE(sendmail_context *c);
static void sendmail_FSM_COMPLETED(sendmail_context *c);
static void sendmail_FSM_ERROR(sendmail_context *c);
static void sendmail_FSM_FATALERROR(sendmail_context *c);
static _kernel_oserror *sendmail_FSM(sendmail_context *context);
static _kernel_oserror *sendmail_CAhandler(_kernel_swi_regs *r, void *pw, void *data);
static _kernel_oserror *sendmail_CBhandler(_kernel_swi_regs *r, void *pw, void *data);
static _kernel_oserror* lookup_sys_var2char(const char var[], char *string, int *len);
void do_senders(int timeout, sendmail_context *c);
void do_recipients(int timeout, sendmail_context *c);
void data(int timeout, sendmail_context *c);


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static sendmail_context *new_sendmail_context(void)
{
  sendmail_context *c = malloc(sizeof(sendmail_context));
  dprintf(("", "new_sendmail_context\n"));
  
  if (c)
  {
    memset(c, 0, sizeof(sendmail_context));
    c->sock = -1;
    c->state = INIT;
    c->new_line = TRUE;
  }
  
  return c;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void destroy_sendmail_context(sendmail_context **context)
{
  if (context)
  {
    if (*context)
    {
      sendmail_context *c = *context;
      
      if (c->hostname)			free(c->hostname);
      if ((c->message) && (c->file))	free(c->message);
      if (c->recipients)		destroy_array(&c->recipients, c->num_of_recipients);
      if (c->senders)			destroy_array(&c->senders, c->num_of_senders);
      if (c->fd)			fclose(c->fd);
      if (c->buffer)			free(c->buffer);
      if (c->localhost)			free(c->localhost);
      destroy_response(&c->response);
      destroy(&c->send_data);
      free(c);
    }
    *context = 0;
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       sendmail
   DESCRIPTION:    Function to 
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:  
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern _kernel_oserror* sendmail(BOOL  file,
                                 char *hostname,
                                 int   port_number,
                                 char *message,
                                 char *recipients[],
                                 unsigned int num_recipients,
                                 char *senders[],
                                 unsigned int num_senders)
{
  _kernel_oserror    *error   = 0;						/* result to return                                              */
  sendmail_context   *context = new_sendmail_context();				/* create a new sendmail context for this operation              */
  
  if (context == 0)								/* if failed to create new context, return error                 */
    error = ERROR(MALLOCFAILED);
  else										/* else make copies of the given parameters                      */
  {
    context->file = file;
    dprintf(("", "sendmail: about to check hostname parameter\n"));
    if (hostname)
    {
      if (strlen(hostname) != 0)
      {
        context->hostname  = (char*)malloc(strlen(hostname)+1);
        if (context->hostname == 0)
          error = ERROR(MALLOCFAILED);
        else
          strcpy(context->hostname, hostname);
      }
    }
    
    if (!error)
    {
      if (context->file)
      {
        context->message = (char*)malloc(strlen(message)+1);
        if (context->message)
        {
          strcpy(context->message, message);
          context->buf_size = BUF_SIZE;
          context->buffer = (char*)malloc(context->buf_size);
          if (!context->buffer)
            error = ERROR(MALLOCFAILED);
        }
        else
          error = ERROR(MALLOCFAILED);
      }
      else
        context->message = message;
    }
    
    if (!error)
    {
      dprintf(("", "sendmail: into check that we alloc. space for hostname if needed\n"));
      if (hostname)								/* if hostname is provided, then                                 */
      {
        if (strlen(hostname) == 0)
        {
          static int len;
          len = 0x80000000;							/* temporary length variable used to get length of sys. var. contents */
              
          dprintf(("", "sendmail: hostname was 0 in length, so lookup sys. var for hostname of server\n"));
          error = lookup_sys_var2char(sys_var_Servername, 0, &len);		/* call to get the length of the sys. var. contents              */
          dprintf(("", "sendmail: returned from getting length of sys. var. error: %x len: %d\n", error, len));
          if (!error)
          {
            if (len <= 0)
              error = ERROR(FAILED);
            else
            {
              context->hostname = (char*)malloc(len+1);				/* alloc. space for the hostname of the server */
              if (context->hostname)
                error = lookup_sys_var2char(sys_var_Servername, context->hostname, &len);	/* get the hostname of the server */
              else
                error = ERROR(MALLOCFAILED);
            }
          }
        }
      }
      else									/* else, hostname is a NULL ptr, which means we do a MX record lookup */
      {
        /* do MX record lookup */						/* which isn't supported yet!  So return an error */
        dprintf(("", "sendmail: MX lookup needed, NOT IMPLEMENTED!\n"));
        error = ERROR(INTERNALERR);
      }
      
      if (!error)
      {
        static int len;
        len = 0x80000000;							/* temporary length variable used to get length of sys. var. contents */
        
        error = lookup_sys_var2char("Inet$LocalDomain", 0, &len);
        if (!error)
        {
          if (len <= 0)
          {
            context->localhost = (char*)malloc(1);
            if (context->localhost)
              context->localhost[0] = 0;
            else
              error = ERROR(MALLOCFAILED);
          }
          else
          {
            context->localhost = (char*)malloc(len+1);
            if (context->localhost)
              error = lookup_sys_var2char("Inet$LocalDomain", context->localhost, &len);
            else
              error = ERROR(MALLOCFAILED);
          }
        }
      }
          
      if (!error)								/* if no problems so far, then copy in the other context details at start the FSM */
      {
        dprintf(("", "sendmail: no errors, so setup context and CallBack the sendmail FSM\n"));
        dprintf(("", "localhost: '%s'\n", context->localhost));
        
        context->greeting_timeout = timeouts[TIMEOUT_connect];
        context->helo_timeout = timeouts[TIMEOUT_HELO];
        context->recipients = recipients;
        context->num_of_recipients = num_recipients;
        context->senders = senders;
        context->num_of_senders = num_senders;
        context->port_number = port_number;
        process1.sendmail_context = context;
        process1.state = CONNECTING;
        
        dprintf(("", "recipients: &%x\nnum_recipients: %d\nsenders: &%x\nnum_senders: %d\nport_number: %d\nhostname: %s\n", context->recipients, context->num_of_recipients, context->senders, context->num_of_senders, context->port_number, context->hostname));
        error = CB_sendmail(context);						/* set a callback to re-enter the FSM later   */
      }      
    }
  }

  dprintf(("", "sendmail: error: %x\n", error));
/*#ifdef DEBUG
  {
    if (error)
    {
      dprintf(("", "sendmail: error->errnum:  %x\n", error->errnum));
      dprintf(("", "sendmail: error->errmess: %s\n", error->errmess));
    }
  }
#endif*/
  if ((error) && (context))
    destroy_sendmail_context(&context);
    
  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static _kernel_oserror *sendmail_FSM(sendmail_context *context)
{
  _kernel_oserror *error = 0;
  
  dprintf(("", "sendmail_FSM: context: %x\n", context));
  if (context == 0)								/* make sure we've been given a context */
    error = ERROR(INTERNALERR);
  
  if (!error)
  {
    context->t_slice = clock() + TIME_SLICE;
    do										/* FSM do-while loop                    */
    {
      if ((context->error) && (context->state != FATALERROR))
        context->state = ERROR;
      switch (context->state)
      {
        case INIT:
          dprintf(("", "sendmail: INIT\n"));
          sendmail_FSM_INIT(context);
          break;
        case GET_HOST_NB:
          dprintf(("", "sendmail: GET_HOST_NB\n"));
          sendmail_FSM_GET_HOST_NB(context);
          break;
        case GET_HOST:
          dprintf(("", "sendmail: GET_HOST\n"));
          sendmail_FSM_GET_HOST(context);
          break;
        case PREPARE_CONNECT:
          dprintf(("", "sendmail: PREPARE_CONNECT\n"));
          sendmail_FSM_PREPARE_CONNECT(context);
          break;
        case CONNECT:
          dprintf(("", "sendmail: CONNECT\n"));
          sendmail_FSM_CONNECT(context);
          break;
        case GREETING:
          dprintf(("", "sendmail: GREETING\n"));
          sendmail_FSM_GREETING(context);
          break;
        case HELO:
          dprintf(("", "sendmail: HELO\n"));
          sendmail_FSM_HELO(context);
          break;
        case FROM:
          dprintf(("", "sendmail: FROM\n"));
          sendmail_FSM_FROM(context);
          break;
        case FROM_RESPONSE:
          dprintf(("", "sendmail: FROM_RESPONSE\n"));
          sendmail_FSM_FROM_RESPONSE(context);
          break;
        case TO:
          dprintf(("", "sendmail: TO\n"));
          sendmail_FSM_TO(context);
          break;
        case TO_RESPONSE:
          dprintf(("", "sendmail: TO_RESPONSE\n"));
          sendmail_FSM_TO_RESPONSE(context);
          break;
        case DATA:
          dprintf(("", "sendmail: DATA\n"));
          sendmail_FSM_DATA(context);
          break;
        case DATA_RESPONSE:
          dprintf(("", "sendmail: DATA_RESPONSE\n"));
          sendmail_FSM_DATA_RESPONSE(context);
          break;
        case GET_DATA_BLOCK:
          dprintf(("", "sendmail: GET_DATA_BLOCK\n"));
          sendmail_FSM_GET_DATA_BLOCK(context);
          break;
        case SEND_DATA_BLOCK:
          dprintf(("", "sendmail: SEND_DATA_BLOCK\n"));
          sendmail_FSM_SEND_DATA_BLOCK(context);
          break;
        case END_OF_DATA:
          dprintf(("", "sendmail: END_OF_DATA\n"));
          sendmail_FSM_END_OF_DATA(context);
          break;
        case END_OF_DATA_RESPONSE:
          dprintf(("", "sendmail: END_OF_DATA_RESPONSE\n"));
          sendmail_FSM_END_OF_DATA_RESPONSE(context);
          break;
        case QUIT:
          dprintf(("", "sendmail: QUIT\n"));
          sendmail_FSM_QUIT(context);
          break;
        case QUIT_RESPONSE:
          dprintf(("", "sendmail: QUIT_RESPONSE\n"));
          sendmail_FSM_QUIT_RESPONSE(context);
          break;
        case COMPLETED:
          dprintf(("", "sendmail: COMPLETED\n"));
          sendmail_FSM_COMPLETED(context);
          break;
        case ERROR:
          dprintf(("", "sendmail: ERROR\n"));
          sendmail_FSM_ERROR(context);
          break;
        case FATALERROR:
          dprintf(("", "sendmail: FATALERROR\n"));
          sendmail_FSM_FATALERROR(context);
          break;
        default:
          dprintf(("", "sendmail: INTERNAL ERROR\n"));
          error = ERROR(INTERNALERR);
          context->end = TRUE;
          break;
      } /* end switch */
    } while ((!expired(context->t_slice)) && (!context->end) && (!context->exit));
  } /* endif */
  
  if (!error)
  {
    if (context->end)								/* if end of the FSM                          */
    {
      process1.socknum = context->sock;
      destroy_sendmail_context(&context);
      notify_client(&(process1.sendmail));
    }
    else if (!context->exit)							/* else, if not told to exit FSM, then        */
      error = CA_sendmail(context);						/* set a callback to re-enter the FSM later   */
    else									/* else we were told to exit the FSM as it    */
      context->exit = FALSE;							/* will be called back by anothe event        */
  }
  
  return error;
}


extern _kernel_oserror* CA_sendmail(void *data)
{
  return callx_add_callafter(SLEEP_TIME, &sendmail_CAhandler, data);
}


extern _kernel_oserror* CB_sendmail(void *data)
{
  return callx_add_callback(&sendmail_CBhandler, data);
}

  
static _kernel_oserror* sendmail_CAhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  dprintf(("", "ENTERED: get_line_CAhandler\n"));
  return callx_add_callback(&sendmail_CBhandler, data);
}


static _kernel_oserror *sendmail_CBhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  return sendmail_FSM(data);
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void sendmail_FSM_INIT(sendmail_context *c)
{
  if (c->file)
  {
    c->fd = fopen(c->message, "rb");
    if (!c->fd)
    {
      c->error = ERROR(WRITEFAIL);
      c->state = FATALERROR;
    }
  }
  
  if (!c->error)
  {
    if (c->port_number < 0)							/* if we've not been given a port number then    */
      c->smtp_service = getservbyname("smtp", "tcp");				/* look it up in the services file               */
    if (c->smtp_service == 0)							/* if the lookup failed, then use the default    */
      c->port_number = PORT_NUMBER;
      
    c->r.r[0] = 0;
    c->r.r[1] = (int)"Resolver_GetHost";
    c->error = _kernel_swi(OS_SWINumberFromString, &(c->r), &(c->r));		/* Test for presence of the ANT Resolver module  */
    
    if (c->error == 0)								/* ANT Resolver present                          */
      c->state = GET_HOST_NB;
    else
    {
      c->error = 0;								/* clear error                                   */
      c->state = GET_HOST;							/* do blocking gethostbyname                     */
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void sendmail_FSM_GET_HOST_NB(sendmail_context *c)
{
  memset(&(c->r), 0, sizeof(_kernel_swi_regs));
  c->r.r[0] = (int)c->hostname;
  c->error = _kernel_swi(Resolver_GetHost, &(c->r), &(c->r));			/* Lookup hostname                               */
  if (c->error)									/* If error, then go into ERROR state            */
    c->state = FATALERROR;
  else if (c->r.r[0] == EINPROGRESS)						/* else, if lookup in process stay in this state */
  {
    c->state = GET_HOST_NB;
    c->t_slice = 0;								/* force us to exit the FSM and be called after a delay, allows Resolver time to work */
  }
  else										/* else, lookup has succeeded so copy out address*/
  {
    #ifdef MEMCHECK
      MemCheck_RegisterMiscBlock((void*)c->r.r[1], sizeof(struct hostent));
    #endif
    if (c->r.r[0] == -1)
    {
      /* host not found, assume IP address? */
      /* should move below code to another state/function to share with GET_HOST state machine */
      c->addr = inet_addr(c->hostname);						/* convert dotted IP address                                */
      if (c->addr == 0xffffffff)							/* if failed, switch to ERROR state                         */
      {
        c->error = ERROR(INTERNETERR);
        c->errno = errno;
        c->state = FATALERROR;
      }
      else									/* else, copy out address                                   */
      {
        memcpy((char*)&(c->smtp_server_addr.sin_addr),
               &(c->addr),
               sizeof(c->addr));
        c->smtp_server_addr.sin_family = AF_INET;
        c->state = PREPARE_CONNECT;						/* switch to state PREPARE_CONNECT                          */
      }
    }
    else if (c->r.r[0] < 0)
    {
      /* error, remote failure */
      c->error = ERROR(RESOLVERFAILED);
      c->state = FATALERROR;
    }
    else if (c->r.r[0] > 0)
    {
      c->error = ERROR(INTERNETERR);
      c->errno = c->r.r[0];
      c->state = FATALERROR;
    }
    else
    {
      /* success */
      c->smtp_server = (struct hostent*)c->r.r[1];
      memcpy((char*)&(c->smtp_server_addr.sin_addr),
             c->smtp_server->h_addr,
             c->smtp_server->h_length);
      c->smtp_server_addr.sin_family = AF_INET;
      c->state = PREPARE_CONNECT;							/* switch to state PREPARE_CONNECT               */
      #ifdef MEMCHECK  
        MemCheck_UnRegisterMiscBlock((void*)c->r.r[1]);
      #endif
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void sendmail_FSM_GET_HOST(sendmail_context *c)
{
  c->smtp_server = gethostbyname(c->hostname);					/* do blocking gethostbyname to get the server address      */
  if (c->smtp_server == 0)							/* if lookup failed, assume hostname is a dotted IP address */
  {
    c->addr = inet_addr(c->hostname);						/* convert dotted IP address                                */
    if (c->addr == 0xffffffff)							/* if failed, switch to ERROR state                         */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = FATALERROR;
    }
    else									/* else, copy out address                                   */
    {
      memcpy((char*)&(c->smtp_server_addr.sin_addr),
             &(c->addr),
             sizeof(c->addr));
      c->smtp_server_addr.sin_family = AF_INET;
      c->state = PREPARE_CONNECT;						/* switch to state PREPARE_CONNECT                          */
    }
  }
  else										/* else, gethostbyname succeeded so, copy out address       */
  {
    memcpy((char*)&(c->smtp_server_addr.sin_addr),
           c->smtp_server->h_addr,
           c->smtp_server->h_length);
    c->smtp_server_addr.sin_family = c->smtp_server->h_addrtype;
    c->state = PREPARE_CONNECT;							/* switch to state PREPARE_CONNECT                          */
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void sendmail_FSM_PREPARE_CONNECT(sendmail_context *c)
{
  if (c->smtp_service)								/* if TCP port number lookup succeeded, copy out the portnumber from that */
    c->smtp_server_addr.sin_port = c->smtp_service->s_port;
  else										/* else, take the given port number and convert to network byte order     */
    c->smtp_server_addr.sin_port = htons(c->port_number);
  
  c->sock = socket(AF_INET, SOCK_STREAM, 0);					/* create socket                                                          */
  dprintf(("", "sendmail_FSM_PREPARE_CONNECT: c->sock: %d\n", c->sock));
  if (c->sock < 0)								/* if socket creation failed, switch to error state                       */
  {
    c->error = ERROR(INTERNETERR);
    c->errno = errno;
    c->state = FATALERROR;
  }
  else										/* else socket created successfully, so                                   */
  {
    int on = 1;
    
    if (socketioctl(c->sock, FIONBIO, &on) < 0)					/* make socket NON blocking                                               */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = FATALERROR;
    }
    else									/* make socket generate Internet Events                                   */
    {
      on = 1;
      if (socketioctl(c->sock, FIOASYNC, &on) < 0)
      {
        c->error = ERROR(INTERNETERR);
        c->errno = errno;
        c->state = FATALERROR;
      }
      else									/* if socket successfully non-blocking and asyncronous, then              */
        c->state = CONNECT;							/* switch to CONNECT state                                                */
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void sendmail_FSM_CONNECT(sendmail_context *c)
{
  process1.socknum = c->sock;							/* copy socket into this client's process structure (only one client atm) */
  if (connect(c->sock, (struct sockaddr*)&(c->smtp_server_addr),			/* if connection to SMTP server returned an error, then                   */
              sizeof(c->smtp_server_addr)) < 0)
  {
    if ((errno != EINPROGRESS) && (errno != EALREADY) && (errno != EISCONN))	/* if error is not a "good" error, then switch to ERROR state             */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = FATALERROR;
    }
    else if (errno != EISCONN)							/* else if error is NOT ALREADY CONNECTED then                            */
    {
      c->state = CONNECT;							/* stay in this state                                                     */
      c->exit = TRUE;
    }
    else									/* else, we are connected so switch to GREETING state                     */
      c->state = GREETING;
  }
  else										/* else, connect succeeded straight away so switch to GREETING state      */
    c->state = GREETING;
}


static void sendmail_FSM_GREETING(sendmail_context *c)
{
  c->error = command_response(c->sock,
                              0,
                              0,
                              &(c->response),
                              c->greeting_timeout,
                              &(c->errno),
                              &(c->error),
                              (function)&sendmail_FSM,
                              c);						/* get greeting from server                                               */
  if (c->error)									/* if command_response returned an error, switch to ERROR state           */
    c->state = FATALERROR;
  else										/* else, switch to USER state and exit connect FSM as command_response will */
  {										/* call connect_FSM back with our context (c) when it is completed          */
    c->state = HELO;
    c->exit = TRUE;
  }
}

  
static void sendmail_FSM_HELO(sendmail_context *c)
{
  if (!response("220 ", c->response))						/* if previous response (the greeting) was not positive, then             */
  {
    dprintf(("", "sendmail_FSM_GREETING: response: %s\n", c->response));
    c->error = ERROR(CONREFUSED);
    c->state = FATALERROR;								/* switch to ERROR state with CONNECTION REFUSED error                    */
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
  }
  else										/* else, greeting was okay, so                                            */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->length    = strlen(c->localhost) + 5;					/* calculate length of USER command to send "USER " = 5 + 1 NULL CHAR = 6 */
    c->send_data = (char*)malloc(c->length+1);					/* allocate space for USER command                                        */
    if (c->send_data)								/* successful, then send USER command and wait for response or timeout    */
    {
      strcpy(c->send_data, "HELO ");
      strcat(c->send_data, c->localhost);
      c->length = strlen(c->send_data);
      c->error = command_response(c->sock,
                                  c->send_data,
                                  c->length,
                                  &(c->response),
                                  c->helo_timeout,
                                  &(c->errno),
                                  &(c->error),
                                  (function)&sendmail_FSM,
                                  c);
      if (c->error)
        c->state = FATALERROR;
      else									/* else, switch to PASS state and exit connect FSM as command_response will */
      {										/* call connect_FSM back with our context (c) when it is completed          */
        c->state = FROM;
        c->exit  = TRUE;
      }
    }
    else									/* else, allocate for command failed, so switch to ERROR state            */
    {
      c->error = ERROR(MALLOCFAILED);
      c->state = FATALERROR;
    }
  }
}


static void sendmail_FSM_FROM(sendmail_context *c)
{
//  if (!response("2xx should check return code from HELO command here!
  dprintf(("", "sendmail_FSM_HELO: response: %s\n", c->response));
  destroy_response(&c->response);
  destroy(&(c->send_data));
  do_senders(timeouts[TIMEOUT_MAIL], c);
  if (!c->error)
  {
    c->state = FROM_RESPONSE;
    c->exit  = TRUE;
  }
  else
    c->state = FATALERROR;
}


static void sendmail_FSM_FROM_RESPONSE(sendmail_context *c)
{
  destroy(&(c->send_data));
  if (!response("250 ", c->response))
  {
    dprintf(("", "sendmail_FSM_FROM_RESPONSE: senders refused: %s\nresponse: %s\n", c->senders[c->senders_pos-1], c->response));
//    destroy_response(&(c->response));						/* REMOVED AS WE NOW PASS THIS OUT TO Client : destroy the response now we're finished with it                        */
    c->error = ERROR(FAILEDTOSEND);
    c->state = ERROR;
  }
  else										/* else, greeting was okay, so                                            */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->senders_success++;
    
    if (c->senders_pos < c->num_of_senders)
      c->state = FROM;
    else if (c->senders_success)
      c->state = TO;
    else
    {
      c->error = ERROR(FAILEDTOSEND);		// see comments in sendmail_FSM_TO_RESPONSE
      c->state = ERROR;
    }
  }
}


static void sendmail_FSM_TO(sendmail_context *c)
{
  destroy(&(c->send_data));
  do_recipients(timeouts[TIMEOUT_MAIL], c);
  if (!c->error)
  {
    c->state = TO_RESPONSE;
    c->exit  = TRUE;
  }
  else
    c->state = ERROR;
}


static void sendmail_FSM_TO_RESPONSE(sendmail_context *c)
{
  destroy(&(c->send_data));
  if (!response("25x ", c->response))
  {
    dprintf(("", "sendmail_FSM_TO_RESPONSE: recipients refused: %s\nresponse: %s\n", c->recipients[c->recipients_pos-1], c->response));
//    destroy_response(&(c->response));						/* REMOVED AS WE NOW PASS THIS OUT TO Client :  destroy the response now we're finished with it                        */
    c->error = ERROR(FAILEDTOSEND);
    c->state = ERROR;
  }
  else										/* else, greeting was okay, so                                            */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->recipients_success++;
    
    if (c->recipients_pos < c->num_of_recipients)
      c->state = TO;
    else if (c->recipients_success)
      c->state = DATA;
    else
    {
      c->error = ERROR(FAILEDTOSEND);		// need a error to say all recipients failed, also, need to report back which ones failed and
      						// which worked, same from senders.  Hows about for each successful one, remove it from the
      						// array?  then return the array to the caller with the failed ones still present?
      c->state = ERROR;
    }
  }
}


static void sendmail_FSM_DATA(sendmail_context *c)
{
  c->error = command_response(c->sock,
                              "DATA",
                              4,
                              &(c->response),
                              timeouts[TIMEOUT_DATA],
                              &(c->errno),
                              &(c->error),
                              (function)&sendmail_FSM,
                              c);
  if (c->error)
    c->state = ERROR;
  else
  {
    c->state = DATA_RESPONSE;
    c->exit = TRUE;
  }
}


static void sendmail_FSM_DATA_RESPONSE(sendmail_context *c)
{
  if (!response("354 ", c->response))
  {
    dprintf(("", "sendmail_FSM_DATA_RESPONSE: DATA command refused, response: %s\n", c->response));
//    destroy_response(&(c->response));
    c->error = ERROR(FAILEDTOSEND);		// need specific error here
    c->state = ERROR;
  }
  else
  {
    destroy_response(&(c->response));
    c->state = GET_DATA_BLOCK;
  }
}

/* function to get the next of data, either from file or memory */
static void sendmail_FSM_GET_DATA_BLOCK(sendmail_context *c)
{
  unsigned int tmp_size;
  char *tmp;
  char *pos;
  
  if (c->file)
  {
    /* file version */
    c->buf_len = fread(c->buffer, 1, c->buf_size, c->fd);
    dprintf(("", "sendmail_FSM_GET_DATA_BLOCK: reading buffer's worth from file: c->buf_size: %d c->buf_len%d\nc->buffer: %s", c->buf_size, c->buf_len, c->buffer));
    if (c->buf_len == 0)
      c->end_of_data = TRUE;
  }
  else
  {
    /* memory version */
    c->buf_len = strlen(c->message);
    if (c->buf_len == 0)
      c->end_of_data = TRUE;
    else
    {
      unsigned int bytes = c->buf_size;			/* set the number of bytes to send this time to the size of the buffer */
      
      if (c->buf_len < c->buf_size)			/* if amount of data left to send is less than our buffer size, then */
        bytes = c->buf_len;				/* set number of bytes to the remainder */
      memcpy(c->buffer, c->message, bytes);		/* copy that number of bytes from the message into the buffer */
      c->message += bytes;				/* move c->message position to next character after this buffer's worth */
      c->buf_len = bytes;				/* copy the number of bytes to send from the temp. var into the context structures buffer length var. */
    }
  }
  if (c->end_of_data)
    c->state = END_OF_DATA;
  else
  {
      c->state = SEND_DATA_BLOCK;				/* successfully converted the buffer so switch to send state */
#if 1
    tmp_size = c->buf_len + 10;				/* arbitary increase for 10 extra characters , unlikey we will need more than this */
    tmp = (char*)malloc(tmp_size);
    pos = c->buffer;
    if (tmp)
    {
      char *pos2 = tmp;					/* position in tmp buffer */
      while ((pos < c->buffer + c->buf_len) && (!c->error))	/* while not scanned through the whole buffer and no error, do */
      {
        if (pos2 >= tmp+tmp_size)				/* if tmp storage buffer is full, 'cos added '.'s will make the contents bigger! */
        {
          char *tmp2;					/* tmp char* to point to reallocated buffer */
          
          tmp_size += 50;					/* 50 extra chars, an abitary choice */
          tmp2 = realloc(tmp, tmp_size);			/* increase the tmp buffer size */
          if (tmp2 == 0)					/* if realloc failed then */
          {
            c->error = ERROR(MALLOCFAILED);	/* set error and destroy the tmp buffer, switch to the error state */
            c->state = ERROR;
            destroy(&tmp);
          }
          else						/* else, realloc succeeded */
            tmp = tmp2;					/* so, set tmp buffer to point at the new tmp buffer */
        }
        if (!c->error)
        {
          if ((*pos == '.') && (c->new_line))		/* if the current char is a '.' and this is the start of a new line, then */
          {
            *pos2 = '.';					/* insert an 'extra' '.' before this character */
            pos2++;						/* move to next position in temporary output buffer */		// HERE!!!!
            c->new_line = FALSE;				/* reset new_line flag to FALSE */
          }
          if ((*pos == LF) && (c->prev_char == CR))	/* if current char is LF and the previous read char was CR, then */
            c->new_line = TRUE;				/*   new_line = TRUE, ie. we are at the start of a new line with the next character */
          else						/* else, we're not at the start of a new line */
            c->new_line = FALSE;				/*   so new_line = FALSE */
          *pos2 = *pos;					/* current position in tmp buffer is set to the current character in the buffer */
          pos2++;						/* move to next position in tmp buffer */
          c->prev_char = *pos;				/* set previous character var. to the current char */
          pos++;						/* move to the next char in the buffer */
        } /* endif error */
      } /* endwhile */
      destroy(&(c->buffer));
      c->buffer = tmp;					/* set the buffer as the new buffer with the '.' duplication */
      c->buf_size = tmp_size;
      c->buf_len = pos2-tmp;
      c->state = SEND_DATA_BLOCK;				/* successfully converted the buffer so switch to send state */
    }
    else							/* else, tmp buffer alloc failed so set error and switch to error state */
    {
      c->error = ERROR(MALLOCFAILED);
      c->state = ERROR;
    }
#endif
  } /* end of data check */
}

/* function to send the current block of data, also looks for'.' at
the start of a line and replaces it with '..' on send out*/
static void sendmail_FSM_SEND_DATA_BLOCK(sendmail_context *c)
{
  /* say in state until error, timeout of all of buffer sent */
  /* destroy the buffer */
  dprintf(("", "c->buf_len: %d\nc->buffer: %s\n", c->buf_len, c->buffer));
  c->error = send_to_server(c->sock,
                                 c->buf_len,
                                 timeouts[TIMEOUT_DATAblock],
                                 &(c->errno),
                                 &(c->error),
                                 (function)&CB_sendmail,
//                                 (function)&sendmail_FSM,
                                 c,
                                 c->buffer);
  if (c->error)
    c->state = ERROR;
  else
  {
    c->exit = TRUE;
    c->state = GET_DATA_BLOCK;
  }
}


static void sendmail_FSM_END_OF_DATA(sendmail_context *c)
{
  c->error = command_response(c->sock,
                              "\x0d\x0a.\x0d\x0a",
                              5,
                              &(c->response),
                              timeouts[TIMEOUT_msgACKed],
                              &(c->errno),
                              &(c->error),
                              (function)&sendmail_FSM,
                              c);
  if (c->error)
    c->state = ERROR;
  else
  {
    c->state = END_OF_DATA_RESPONSE;
    c->exit = TRUE;
  }
}


static void sendmail_FSM_END_OF_DATA_RESPONSE(sendmail_context *c)
{
  if (!response("250 ", c->response))
  {
    dprintf(("", "sendmail_FSM_END_OF_DATA_RESPONSE: END_OF_DATA command refused, response: %s\n", c->response));
//    destroy_response(&(c->response));
    c->error = ERROR(FAILEDTOSEND);		// need specific error here
    c->state = ERROR;
  }
  else
  {
    destroy_response(&(c->response));
    c->state = QUIT;
  }
}


static void sendmail_FSM_QUIT(sendmail_context *c)
{
  c->error = command_response(c->sock,
                              "QUIT",
                              4,
                              &(c->response),
                              timeouts[TIMEOUT_QUIT],
                              &(c->errno),
                              &(c->error),
                              (function)&sendmail_FSM,
                              c);
  if (c->error)
    c->state = FATALERROR;
  else
  {
    c->state = QUIT_RESPONSE;
    c->exit = TRUE;
  }
}


static void sendmail_FSM_QUIT_RESPONSE(sendmail_context *c)
{
  if (!response("221 ", c->response))
  {
    dprintf(("", "sendmail_FSM_QUIT_RESPONSE: QUIT command refused, response: %s\n", c->response));
    destroy_response(&(c->response));
    c->error = ERROR(FAILED);		// need specific error here
    c->state = FATALERROR;
  }
  else
  {
    destroy_response(&(c->response));
    if (c->error_copy)
      c->state = FATALERROR;
    else
      c->state = COMPLETED;
  }
}


static void sendmail_FSM_COMPLETED(sendmail_context *c)
{
  process1.sendmail.flags = 0;
  process1.sendmail.error = 0;
  process1.sendmail.errno = 0;
  process1.sendmail.smtp_response = 0;
  if (c->sock >= 0)
  {
    shutdown(c->sock,2);
    socketclose(c->sock);
  }
  c->sock = -1;
  
  c->end = TRUE;
}


static void sendmail_FSM_ERROR(sendmail_context *c)
{
  c->response_copy = c->response;
  c->response = 0;
  c->error_copy = c->error;
  c->error = 0;
  c->errno_copy = c->errno;
  c->errno = 0;
  c->state = QUIT;
}


static void sendmail_FSM_FATALERROR(sendmail_context *c)
{
  process1.sendmail.flags = 0;
  if (c->response_copy)
    process1.sendmail.smtp_response = c->response_copy;
  else
    process1.sendmail.smtp_response = c->response;
  
  if (c->error_copy)
    process1.sendmail.error = c->error_copy;
  else
    process1.sendmail.error = c->error;
  
  if (c->errno_copy)
    process1.sendmail.errno = c->errno_copy;
  else
    process1.sendmail.errno = c->errno;
  
  if (c->sock >= 0)
  {
    shutdown(c->sock,2);
    socketclose(c->sock);
  }
  c->sock = -1;
  
  c->end = TRUE;
}


void do_senders(int               timeout,
                sendmail_context *c)
{
  c->length = strlen(c->senders[c->senders_pos]) + 11;
  c->send_data = (char*)malloc(c->length+1);
  if (c->send_data)
  {
    strcpy(c->send_data, "MAIL FROM: ");
    strcat(c->send_data, c->senders[c->senders_pos++]);
    c->error = command_response(c->sock,
                                c->send_data,
                                c->length,
                                &(c->response),
                                timeout,
                                &(c->errno),
                                &(c->error),
                                (function)&sendmail_FSM,
                                c);
    if (c->error)
      c->state = ERROR;
    else
    {
      c->state = FROM_RESPONSE;
      c->exit = TRUE;
    }
  }
  else
  {
    c->error = ERROR(MALLOCFAILED);
    c->state = ERROR;
  }
}

  
void do_recipients(int               timeout,
                   sendmail_context *c)
{
  c->length = strlen(c->recipients[c->recipients_pos]) + 9;
  c->send_data = (char*)malloc(c->length+1);
  if (c->send_data)
  {
    strcpy(c->send_data, "RCPT TO: ");
    strcat(c->send_data, (c->recipients)[c->recipients_pos++]);
    c->error = command_response(c->sock,
                                c->send_data,
                                c->length,
                                &(c->response),
                                timeout,
                                &(c->errno),
                                &(c->error),
                                (function)&sendmail_FSM,
                                c);
    if (c->error)
      c->state = ERROR;
    else
    {
      c->state = TO_RESPONSE;
      c->exit = TRUE;
    }
  }
  else
  {
    c->error = ERROR(MALLOCFAILED);
    c->state = ERROR;
  }
}

  
static _kernel_oserror* lookup_sys_var2char(const char var[], char *string, int *len)
{
  _kernel_oserror *error = 0;
  if ((var == 0) || (len == 0))
    error = ERROR(NULLADDR);
  else
  {
    static _kernel_swi_regs r;
    
    dprintf(("", "lookup_sys_var2char: len: &%x\n", *len));
    memset(&r, 0, sizeof(r));
    r.r[0] = (int)var;
    r.r[1] = (int)string;
    r.r[2] = *len;
    r.r[3] = 0;
    r.r[4] = 0;
    
    _kernel_swi(OS_ReadVarVal, &r, &r);
    
    if ((*len > 0) && (string))
    {
      *len = r.r[2];
      string[*len] = 0;
      dprintf(("", "lookup_sys_var2char: *len: &%x string: '%s'\n", *len, string));
    }
    else
      *len = ~r.r[2];
      
    dprintf(("", "lookup_sys_var2char: r[2]: &%x len: &%x\n", r.r[2], *len));
  }
  return error;
}

