/*	Project Post (769) - AcornSMTP
	Acorn Risc Technologies
	Copyright © 1996. All Rights Reserved.

	FILE:		cmdresp.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.02 for RISC OS

	OVERVIEW
	========
	Source file for implementation of command_response to/from server
	functionality.  Taken from AcornPOP3.  Need to move this common
	fuctionality into a library to share between all the protocol modules.

	HISTORY
	=======
	08/10/97	0.01	RDW	Initial version
	23/03/98	0.02	RDW	command_response_CAhandler() and
					command_response_CBhandler() unused
					params. tidied up
*/


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <stdlib.h>
#include <string.h>
#include <time.h>


/* ************************************************************************** */
/*                                                                            */
/* Include header files - External Libraries                                  */
/*                                                                            */
/* ************************************************************************** */
#include "DebugLib.h"
#include "Elib_priv.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "errortable.h"
#include "callbacks.h"
#include "sendline.h"
#include "get.h"
#include "cmdresp.h"


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  INIT,
  SEND_LINE,
  GET_RESPONSE,
  COMPLETED,
  ERROR
} command_response_STATES;							/* command response FSM states */

typedef struct
{
  time_t                    t_slice;						/* timeslice, time to exit FSM by for re-entracy later */
  _kernel_oserror          *error;						/* our error pointer                                   */
  BOOL                      end;						/* end of command response FSM?                        */
  BOOL                      exit;						/* exit FSM without setting callback                   */
  int                      *internet_err;					/* ptr to internet errno var. to set, given by caller  */
  function                  func;						/* Caller's function to call back when we have finished*/
  void                     *data;						/* data to call back caller's function, func, with     */
  _kernel_oserror         **error2;						/* address of caller's error pointer to set if error   */
  int                       s;							/* socket to use                                       */
  char                     *send_data;						/* data to send, we don't own this caller owns it      */
  int                       send_length;					/* length of send_data                                 */
  char                    **response;						/* address of char* to set to point at server response */
  int                       timeout;						/* timeout for command response operation              */
  command_response_STATES   state;						/* current command response state                      */
} command_response_context;


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
static const int SLEEP_TIME    = 1;
static const int TIME_SLICE    = 50;						/* Time slice to use                                                   */


/* ************************************************************************** */
/*                                                                            */
/* External globals                                                           */
/*                                                                            */
/* ************************************************************************** */
extern process_details process1;						/* This client's process detail                        */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static command_response_context* new_command_response_context(void);
static _kernel_oserror* command_response_FSM(command_response_context *context);
static _kernel_oserror* command_response_CBhandler(_kernel_swi_regs *r, void *pw, void *data);
static _kernel_oserror* command_response_CAhandler(_kernel_swi_regs *r, void *pw, void *data);


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void destroy_command_response_context(command_response_context **context)
{
  if (context)
  {
    if (*context)
      free(*context);
    *context = 0;
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   	
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern _kernel_oserror *command_response(int               s,
                                         char             *send_data,
                                         int               length,
                                         char            **response,
                                         int               timeout,
                                         int              *internet_err,
                                         _kernel_oserror **error2,
                                         function          func,
                                         void             *data)
{
  _kernel_oserror *error = 0;							/* result to return                                              */
  
  if ((response == 0) || (func == 0) || (internet_err == 0) || (error2 == 0))	/* check parameters that can't be NULL aren't                    */
    error = ERROR(INTERNALERR);
  else
  {
    command_response_context *context = new_command_response_context();		/* create a new logon context for this operation                 */
    if (context)
    {
      context->s            = s;
      context->send_data    = send_data;					/* copy in parameters into context                               */
      context->send_length  = length;
      context->response     = response;
      context->timeout      = timeout;
      context->func         = func;
      context->internet_err = internet_err;
      context->data         = data;
      context->error2       = error2;
      error = CB_command_response(context);					/* enter the logon FSM                                           */
    }
    else
      error = ERROR(MALLOCFAILED);
  }
  
  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static command_response_context *new_command_response_context(void)
{
  command_response_context *c = malloc(sizeof(command_response_context));	/* create new context        */
  
  if (c)									/* if created, initialise it */
  {
    memset(c, 0, sizeof(command_response_context));				/* init. context to NULL     */
    c->state    = INIT;								/* init. FSM state           */
  }
  
  return c;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern _kernel_oserror *command_response_FSM(command_response_context *context)
{
  _kernel_oserror *error = 0;
  
  dprintf(("", "command_response_FSM: context: %x\n", context));
  if (context == 0)								/* make sure we've been given a context                          */
    error = ERROR(INTERNALERR);

  context->t_slice = clock() + TIME_SLICE;
  do										/* FSM do-while loop                                             */
  {
    if (context->error)
      context->state = ERROR;
    switch (context->state)
    {
      case INIT:
      {
        dprintf(("", "command_and_response: INIT\n"));
        if (context->send_data == 0)						/* if no data to send, then switch to GET_RESPONSE state         */
          context->state = GET_RESPONSE;
        else if (context->send_data[0] == 0)
          context->state = GET_RESPONSE;
        else									/* else, switch to SEND_LINE state                               */
          context->state = SEND_LINE;
        break;
      }
      case SEND_LINE:
      {
        dprintf(("", "command_and_response: SEND_LINE\n"));
        context->error = send_line_to_server(context->s,
                                             context->send_length,
                                             context->timeout,
                                             context->internet_err,
                                             &(context->error),
                                             (function)&command_response_FSM,
                                             context,
                                             context->send_data);		/* send the data to the server                                   */
        if (context->error)
          context->state = ERROR;
        else									/* else, if no error then exit FSM as we will be reentered by    */
        {									/* send_line_to_server calling us back and switch state to       */
          context->exit = TRUE;							/* GET_RESPONSE                                                  */
          context->state = GET_RESPONSE;
        }
        break;
      }
      case GET_RESPONSE:
      {
        dprintf(("", "command_and_response: GET_RESPONSE\n"));
        context->error = get_line_from_server(context->s,
                                              context->response,
                                              context->timeout,
                                              context->internet_err,
                                              &(context->error),
                                              (function)&command_response_FSM,
                                              context);				/* get the response from the server                              */
        if (context->error)
          context->state = ERROR;
        else									/* else, if no error then exit FSM as we will be reentered by    */
        {									/* get_line_from_server calling us back and switch state to      */
          context->exit = TRUE;							/* COMPLETED                                                     */
          context->state = COMPLETED;
        }
        break;
      }
      case COMPLETED:
      {
        dprintf(("", "command_and_response: COMPLETED\n"));
        context->func(context->data);						/* callback caller with the context they gave us                 */
        context->end = TRUE;							/* set end of FSM                                                */
        break;
      }
      case ERROR:
      {
        dprintf(("", "command_and_response: ERROR\n"));
        *(context->error2) = context->error;					/* set caller's error to point at the error that occured here    */
        context->func(context->data);						/* callback caller with the context they gave us                 */
        context->end = TRUE;							/* set end of FSM                                                */
        break;
      }
      default:
      {
        dprintf(("", "command_and_response: INTERNAL ERROR\n"));
        error = ERROR(INTERNALERR);
        break;
      }
    } /* endswitch */
  } while ((!expired(context->t_slice)) && (!context->end) && (!context->exit));

  if (!error)
  {
    if (context->end)								/* if end of the FSM                          */
      destroy_command_response_context(&context);				/* destroy the context                        */
    else if (!context->exit)							/* else, if not told to exit FSM, then        */
      error = CB_command_response(context);					/* set a callback to re-enter the FSM later   */
    else									/* else we were told to exit the FSM as it    */
      context->exit = FALSE;							/* will be called back by anothe event        */
  }

  return error;
}




extern _kernel_oserror* CA_command_response(void *data)
{
  return callx_add_callafter(SLEEP_TIME, &command_response_CAhandler, data);
}


extern _kernel_oserror* CB_command_response(void *data)
{
  return callx_add_callback(&command_response_CBhandler, data);
}

  
static _kernel_oserror* command_response_CAhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  UNUSED(r);
  UNUSED(pw);
  
  dprintf(("", "ENTERED: get_line_CAhandler\n"));
  return callx_add_callback(&command_response_CBhandler, data);
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static _kernel_oserror *command_response_CBhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  UNUSED(r);
  UNUSED(pw);
  
  return command_response_FSM(data);
}


