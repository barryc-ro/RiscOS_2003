/*
 * Created by cmhg vsn 5.15 [Feb 14 1997]
 */

#ifndef __cmhg_header_h
#define __cmhg_header_h

#ifndef __kernel_h
#include "kernel.h"
#endif

#define CMHG_VERSION 515

#define Module_Title                     "AcornPOP3"
#define Module_Help                      "AcornPOP3"
#define Module_VersionString             "0.23"
#define Module_VersionNumber             23
#define Module_Date                      "12 Mar 1998"


/*
 * Initialisation code
 * ===================
 *
 * Return NULL if your initialisation succeeds; otherwise return a pointer
 * to an error block. cmd_tail points to the string of arguments with which
 * the module is invoked (may be "").
 * podule_base is 0 unless the code has been invoked from a podule.
 * pw is the 'R12' value established by module initialisation. You may
 * assume nothing about its value (in fact it points to some RMA space
 * claimed and used by the module veneers). All you may do is pass it back
 * for your module veneers via an intermediary such as SWI OS_CallEvery
 * (use _swix() to issue the SWI call).
 */
_kernel_oserror *init_module(char *cmd_tail, int podule_base, void *pw);


/*
 * Finalisation code
 * =================
 *
 * Return NULL if your finalisation succeeds. Otherwise return a pointer to
 * an error block if your finalisation handler does not wish to die (e.g.
 * toolbox modules return a 'Task(s) active' error).
 * fatal, podule and pw are the values of R10, R11 and R12 (respectively)
 * on entry to the finalisation code.
 */
_kernel_oserror *kill_module(int fatal, int podule, void *pw);


/*
 * SWI handler code
 * ================
 *
 * Return NULL if the SWI is handled successfully; otherwise return
 * a pointer to an error block which describes the error.
 * The veneer code sets the 'V' bit if the returned value is non-NULL.
 * The special value error_BAD_SWI may be returned if you do not
 * implement a SWI; the veneer will arrange for the appropriate
 * standard internationalised error 'SWI value out of range for
 * module AcornPOP3' to be returned.
 * The handler may update any of its input registers (R0-R9).
 * pw is the private word pointer ('R12') value passed into the
 * SWI handler entry veneer.
 */
#define AcornPOP3_00                    0x04e540
#ifndef AcornPOP3_Register
#define AcornPOP3_Register              0x04e540
#define AcornPOP3_DeRegister            0x04e541
#define AcornPOP3_ReleaseData           0x04e542
#define AcornPOP3_Logon                 0x04e543
#define AcornPOP3_Disconnect            0x04e544
#define AcornPOP3_AbortConnection       0x04e545
#define AcornPOP3_Reset                 0x04e546
#define AcornPOP3_Echo                  0x04e547
#define AcornPOP3_GetNumOfMessages      0x04e548
#define AcornPOP3_GetListOfMessages     0x04e549
#define AcornPOP3_GetMessage            0x04e54a
#define AcornPOP3_GetXLinesOfMessage    0x04e54b
#define AcornPOP3_DeleteMessage         0x04e54c
#define AcornPOP3_GetUniqueID           0x04e54d
#define AcornPOP3_GetListOfUniqueIDs    0x04e54e
#endif

#define error_BAD_SWI ((_kernel_oserror *) -1)

_kernel_oserror *swi_handler(int swi_no, _kernel_swi_regs *r, void *pw);


/*
 * SWI decoding code
 * =================
 *
 * For the text->number converter, string points to the name to convert
 * (terminated by a control character). If the SWI is recognised, return
 * the offset into the chunk (0-63), otherwise return <0.
 *
 * For the number->text converter:
 *   swi_no is the offset (0..63) of the SWI within the SWI chunk.
 *   buffer is a pointer to a buffer;
 *   offset is the offset within the buffer at which to place the text;
 *   size is the length of the buffer.
 * You should write the SWI name into the buffer at the position given
 * by offset, then return offset updated by the length of the text
 * written (excluding any terminating NUL, if you add one). If you don't
 * have a name for the SWI, just return offset, unaltered.
 *
 * pw is the priate word pointer ('R12') passed into the entry veneer.
 */
int swi_decode_text_to_number(const char *string, void *pw);
int swi_decode_number_to_text(int swi_no, char *buffer, int offset, int end, void *pw);


/*
 * Event handler
 * =============
 *
 * This is the name of the event handler entry veneer compiled by CMHG.
 * Use this name as an argument to, for example, SWI OS_Claim, in
 * order to attach your handler to EventV.
 */
extern void event_entry(void);

/*
 * This is the handler function you must write to handle the event for
 * which event_entry is the veneer function.
 *
 * Return 0 if you wish to claim the event.
 * Return 1 if you do not wish to claim the event.
 *
 * 'r' points to a vector of words containing the values of R0-R9 on
 * entry to the veneer. If r is updated, the updated values will be
 * loaded into R0-R9 on return from the handler.
 *
 * pw is the private word pointer ('R12') value with which the event
 * entry veneer is called.
 */
int event_handler(_kernel_swi_regs *r, void *pw);

#endif
