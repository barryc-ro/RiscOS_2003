/*	Project Post (769) - AcornPOP3
	Acorn Risc Technologies
	Copyright © 1997. All Rights Reserved.

	FILE:		handlers.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.08 for RISC OS

	OVERVIEW
	========
	Source file for implementation of handlers support code for
	the AcornPOP3 client module.  Code does nothing yet as it is not
	complete.  Need to implement Non-blocking sockets and timeouts

	HISTORY
	=======
	19/02/97	0.01	RDW	Initial version
	11/07/97	0.02	RDW	Tidy up when moving to correct build environment
	15/07/97	0.03	RDW	Tidy up
	10/10/97	0.04	RDW	changed event_handler so that it returns 1 if
					it's not an Internet_Event
	13/11/97	0.05	RDW	MemCheck compile time option support added
	13/01/98	0.06	RDW	set_callback to logon FSM changed to CB_logon()
	30/10/98	0.07	RDW	Removed BUG in select call where static value
					of 32 descriptors were being checked.  Hangover
					from ANT Skeltons' SMTPDaemon module.
					Also, fixed so that poll time is always zeroed
					before call.
	23/03/98	0.08	RDW	handle_Socket_Async_Event() unused params. tidied up
					and unused timeout_handler() removed
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <string.h>
#include "kernel.h"
#include "sys/types.h"
#include "unixlib.h"
#include "socklib.h"
#ifdef MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "header.h"
#include "callbacks.h"
#include "get.h"
#include "send.h"
#include "logon.h"


/* ************************************************************************** */
/*                                                                            */
/* Externals                                                                  */
/*                                                                            */
/* ************************************************************************** */
extern void *module_wsp;							// Module workspace
extern process_details process1;
extern BOOL timeout_flag;							// timeout flag
extern BOOL timeout_set;							// timeout set flag


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
//static const int SLEEP_TIME    = 1;


/* ************************************************************************** */
/*                                                                            */
/* Global variables to this file                                              */
/*                                                                            */
/* ************************************************************************** */
static fd_set fd_sockets;
static fd_set fd_read_test;
static fd_set fd_write_test;
static struct timeval select_poll_time = 0;


/* ************************************************************************** */
/*                                                                            */
/* Function prototypes for functions private to this file                     */
/*                                                                            */
/* ************************************************************************** */
static int handle_Socket_Async_Event(_kernel_swi_regs *r, void *pw);


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       event_handler
   DESCRIPTION:    NOT DONE YET!
   DEPENDENCIES:   void*	module_wsp
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern int event_handler(_kernel_swi_regs *r, void *pw)
{
  int result = 1;
//  _kernel_oserror *error = 0;
  
#ifdef MEMCHECK  
  MemCheck_RegisterMiscBlock(r, sizeof(_kernel_swi_regs));
#endif

  if (pw != module_wsp)
    result = 1;
  else if (r->r[0] == Internet_Event)
  {
    _kernel_irqs_on();								// Put Interrupts back on as Internet_Event is actually generated on a callback
    
    switch(r->r[1])
    {
/*      case Socket_Broken_Event:
      {
        result = handle_event_Socket_Broken_Event(r, pw);
        break;
      }*/
      case Socket_Async_Event:
      {
        result = handle_Socket_Async_Event(r, pw);
        break;
      }
      default:									// Catch all
      {
        result = 1;
        break;
      }
    } // endswitch
  } // endif Internet_Event
  else
    result = 1;

#ifdef MEMCHECK  
  MemCheck_UnRegisterMiscBlock(r);
#endif

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_Socket_Async_Event
   DESCRIPTION:    NOT DONE YET!
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static int handle_Socket_Async_Event(_kernel_swi_regs *r, void *pw)
{
  static int result;
  static int nfound;
  result = 1;
  nfound = 0;
  
  UNUSED(pw);
  if (r->r[2] == process1.socknum)						/* make sure it's our socket */
  {
//    Printf("handle_Socket_Async_Event on OUR SOCKET: state: %d\n", process1.state);
    result = 0;
    switch (process1.state)
    {
      case GET:
      {
        FD_ZERO(&fd_sockets);
        FD_SET(process1.socknum, &fd_sockets);
        FD_COPY(&fd_sockets, &fd_read_test);
        memset(&select_poll_time, 0, sizeof(select_poll_time));
        nfound = select(process1.socknum+1, &fd_read_test, 0, 0, &select_poll_time);
        if ((nfound) && (FD_ISSET(process1.socknum, &(fd_read_test))))	// if socket descriptor is ready for reading, then
        {
//        Printf("handle_Socket_Async_Event: GET\n");
          CB_get_line_from_server(process1.get_context);
//      callx_add_callafter(SLEEP_TIME, &get_line_CAhandler, process1.get_context);
//          set_callback(/*CB_DATA_EVENT, */CB_CALLER_EVENT, EVENT_READ, &get_line_CBhandler, process1.get_context);
        }
        break;
      }
      case SEND:
      {
        FD_ZERO(&fd_sockets);
        FD_SET(process1.socknum, &fd_sockets);
        FD_COPY(&fd_sockets, &fd_write_test);
        memset(&select_poll_time, 0, sizeof(select_poll_time));
        nfound = select(process1.socknum+1, 0, &fd_write_test, 0, &select_poll_time);
        if ((nfound) && (FD_ISSET(process1.socknum, &(fd_write_test))))	// if socket descriptor is ready for writing, then
        {
//        Printf("handle_Socket_Async_Event: SEND\n");
//      callx_add_callafter(SLEEP_TIME, &send_line_CAhandler, process1.send_context);
          CB_send_line_to_server(process1.send_context);
//          set_callback(/*CB_DATA_EVENT, */CB_CALLER_EVENT, EVENT_WRITE, &send_line_CBhandler, process1.send_context);
        }
        break;
      }
      case CONNECTING:
      {
        FD_ZERO(&fd_sockets);
        FD_SET(process1.socknum, &fd_sockets);
        FD_COPY(&fd_sockets, &fd_write_test);
        memset(&select_poll_time, 0, sizeof(select_poll_time));
        nfound = select(process1.socknum+1, 0, &fd_write_test, 0, &select_poll_time);
        if ((nfound) && (FD_ISSET(process1.socknum, &(fd_write_test))))	// if socket descriptor is ready for writing, then
        {

//        Printf("handle_Socket_Async_Event: CONNECTING\n");
//      callx_add_callafter(SLEEP_TIME, &send_line_CAhandler, process1.send_context);
//          CB_send_line_to_server(process1.send_context);
//          set_callback(/*CB_DATA_EVENT, CB_CALLER_EVENT, EVENT_WRITE, */&logon_CBhandler, process1.logon_context);
          CB_logon(process1.logon_context);
          process1.state = PROCESSING;
        }
        break;
      }      
      case PROCESSING:
      default:
        break;
    } /* endswitch */
  }
  
  return result;
}
