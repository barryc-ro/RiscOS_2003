/*	Project Post (769) - AcornPOP3
	Acorn Risc Technologies
	Copyright © 1996. All Rights Reserved.

	FILE:		swihndlers.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.10 for RISC OS

	OVERVIEW
	========
	Source file for implementation of functions to handle and process
	the SWI calls this module implements

	HISTORY
	=======
	19/02/97	0.01	RDW	Initial version
	03/04/97	0.02	RDW	GetMessage SWI handler.  Always returns 0.  Any error is returned in data strucuture.
	03/07/97	0.03	RDW	Changing SWI interface and data structs inline with Project Post API standard
					IDnum is now the address in memory that the returned data structure will be at.
					IDnum in returned structure is now a flags word.
	04/07/97	0.04	RDW	GetXLinesOfMessage and GetMessage changed to call get_message_to_memory or get_message_to_file
					ie. merged GetXLinesOfMessage and GetMessage code together.  One day, may merge memory and
					file versions a bit as there is common code there too.
	11/07/97	0.05	RDW	Tidy up when moving to correct build environment
	11/07/97	0.06	RDW	AcornPOP3_LogOn renamed to AcornPOP3_Logon and GetUniqueID added
	10/10/97	0.07	RDW	process1.state initialised to PROCESSING in Register
	14/10/97	0.08	RDW	in handle_swi_AcornPOP3_Logon commented out the setup of the pollword as data is not returned
					straight away now.
	04/11/97	0.09	RDW	Changed AcornPOP3_Register to accept and check flags for supporting request for Wimp_Message
					to be sent out as well as pollword set.
	18/11/97	0.10	RDW	Support for MEMCHECK added into handle functions that have pointers to data passed in
					throught the registers
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#ifdef DEBUG
  #include "TML_Podule.h"
#endif
#ifdef MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "allocation.h"
#include "swihndlers.h"
#include "logon.h"
#include "logout.h"
#include "getnummsgs.h"
#include "getlistmsg.h"
#include "deletemsg.h"
#include "getmsgfile.h"
#include "getuniquei.h"
#include "getlistuid.h"
#include "errortable.h"


/* ************************************************************************** */
/*                                                                            */
/* External globals                                                           */
/*                                                                            */
/* ************************************************************************** */
extern int inuse;								// process1 in use?
extern process_details process1;						// This client's process detail
extern int timeouts[];								// default timeouts


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_Register
   DESCRIPTION:    Function to handle AcornPOP3_Register SWI
   		   Allows a client/caller to register with the AcornPOP3 module
   		   Takes as input a connection_timeout value to use to set the
   		   idle time after which to cleanly disconnect from the server.
   		   Also, takes a flag on input whether the caller wishes to be
   		   notified when the disconnection is due.  Caller is then
   		   responible for making appropriate calls to AcornPOP3 to
   		   perform the disconnect (Or it can ignore it and leave the
   		   connection up).  On return from this SWI either a unique id
   		   number will be returned or an error if no more clients can
   		   register with the AcornPOP3 module.  The Unique ID is an
   		   address of a pollword.  If a task is using the non-blocking
   		   calls to AcornPOP3, then it should use the pollword with
   		   WimpPoll/PollIdle.  Once the pollword is set to non-zero by
   		   AcornPOP3 it will point to the address of a structure
   		   holding returned data.  For modules AcornPOP3 will send
   		   out a service call at which point the pollword will point
   		   to the structure holding the returned information.
   DEPENDENCIES:   BOOL			inuse		module.c
   		   			errortable	errortable.h
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
    RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_Register(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword

  UNUSED(pw);
  
  flags = (unsigned int)r->r[0];


  /* check flags */
  if (flags != 0)
  {
    if (flags & REGISTER_WIMPMSG)
    {
      process1.flags = process1.flags | REGISTER_WIMPMSG;			// set this processes flags to indicate we should send a wimpmessage
      process1.taskhandle = r->r[1];
    }
    else if (flags & REGISTER_UNUSED_MASK)					/* check no other bits are set which we don't support */
    {
      flags = flags & REGISTER_UNUSED_MASK;
      result = ERROR(FAILED);
    }
    else
      flags = 0;								/* all accepted */
  }
  
  if (!result)
  {
    if (inuse)									// We only support one caller at a time in this version
      result = ERROR(NOMOREPROCESSES);					// so return an error
    else
    {
      process1.pollword = 0;							// set pollword to 0
      process1.state    = PROCESSING;
      pollword_addr     = &(process1.pollword);					// set pollword address as address of pollword ptr in process1 struct
      result = 0;								// set no error
      inuse  = TRUE;								// set inuse to TRUE, we have a client
    }
  }
  
  // setup registers for return from SWI
  r->r[0] = flags;								// r0 unchanged
  r->r[1] = (int)pollword_addr;							// r1 is address of pollword
  
  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_DeRegister
   DESCRIPTION:    Function to handle AcornPOP3_DeRegister SWI
   		   Function to allow a client of the AcornPOP3 to deregister
   		   with it.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = 0 if success, else unchanged
    RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
#pragma -z0									/* horrible hack to get round compiler optimiser bug */
_kernel_oserror* handle_swi_AcornPOP3_DeRegister(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void                  *pollword_addr = 0;					// address of pollword

  UNUSED(pw);
  flags = (unsigned int)r->r[0];
  pollword_addr = (void*)r->r[1];						// set pollword_addr;

  if (inuse)
  {
    if (pollword_addr == &(process1.pollword))
      inuse = FALSE;
    else
      result = ERROR(INVALIDID);
  }
  else
    result = ERROR(FAILED);
 
  // setup registers for return from SWI
  r->r[0] = r->r[0];								// r0 unchanged
  if (result)
    r->r[1] = r->r[1];								// r1 unchanged if an error
  else
    r->r[1] = (int)0;								// r1 set to 0 if deregistered okay
  
  return result;
}
#pragma -z1									/* horrible hack to get round compiler optimiser bug */


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_ReleaseData
   DESCRIPTION:    Function to handle AcornPOP3_ReleaseData SWI
   		   Function to free the block of memory now that the client has
   		   indicated they are finisehd with it.  NOTE: does nothing just now
   		   in this version as only 1 client supported and data is static
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = SWI number of SWI that returned the data
   							r->r[3] = Unique ID number of returned data (address of data)
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = 0 if success, else unchanged
   							r->r[2] = 0 if success, else unchanged
   							r->r[3] = 0 if success, else unchanged
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_ReleaseData(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  int			 swinum        = 0;					// swi number
  void			*IDnum         = 0;					// ID number

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  swinum        = (int)r->r[2];							// get message id
  IDnum         = (void*)r->r[3];						// get returned data unique id
  
  if ((!inuse) && (pollword_addr != (&(process1.pollword))))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
    
  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// set to 0
    r->r[2] = 0;								// set to 0
    r->r[3] = 0;								// set to 0
    process1.pollword = 0;							// set pollword to 0
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = r->r[1];								// r0 unchanged
    r->r[2] = r->r[2];								// r0 unchanged
    r->r[3] = r->r[3];								// r0 unchanged
  }

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_Logon
   DESCRIPTION:    Function to handle AcornPOP3_Logon SWI
   		   Function to attempt to connect to a POP3 server and login.  The
                   name of the host to connect to is given in the hostname
                   parameter, or if its NULL the system variable
                   Inet$POP3_Default_Servername is checked for
                   a default hostname.  The port parameter gives the port number on
                   the server to connect to, if < 0 then the system variable
                   Inet$POP3_Default_Port is checked
                   for a default port number.  If port number is requested from the
                   system var. and is not found (for whatever reason) default of
                   PORT is used.  username gives the username to use and can't be
                   NULL or a NULLstring.  password gives the password string to
                   use.  If NULL, then no PASS command is sent.  If NULLstring then
                   PASS command is send with a nullstring as the password.  The
                   timeouts are used if >= 0.  If they are -ve, then the system.var
                   settings are used.  For those vars. that are not set the compiled
                   in values are used.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = Address of username string
   							r->r[3] = Address of password string
   							r->r[4] = Address of hostname
   							r->r[5] = Port number
   							r->r[6] = Timeout for USER command
   							r->r[7] = Timeout for PASS command
   							r->r[8] = Timeout for GREETING
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_Logon(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  char			*username      = 0;					// username string
  char			*password      = 0;					// password string
  char			*hostname      = 0;					// host address
  int			 port_number   = 0;					// port number
  int			 timeout_USER  = 2;					// timeout for USER command (mins)
  int			 timeout_PASS  = 2;					// timeout for PASS command (mins)
  int                    timeout_greeting = 2;					// timeout to wait for greeting from server (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  username      = (char*)r->r[2];
  password      = (char*)r->r[3];
  hostname      = (char*)r->r[4];
  port_number   = (int)r->r[5];
//  timeout_USER  = (int)r->r[6];
//  timeout_PASS  = (int)r->r[7];
//  timeout_greeting = (int)r->r[8];
  
//  if ((!inuse) || (pollword_addr != &caller_data))				// If not registered or pollword address is wrong
  #ifdef MEMCHECK
    if (username) MemCheck_RegisterMiscBlock_String(username);
    if (password) MemCheck_RegisterMiscBlock_String(password);
    if (hostname) MemCheck_RegisterMiscBlock_String(hostname);
  #endif
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
  if ((!result) && ((username == 0) || (password == 0) || (hostname == 0)))	// If no error yet and username,password or hostname string is NULL
    result = ERROR(NULLADDR);							// Return NULL address error
    
  if ((!result) && (*username == '\0'))						// If username is a zero length string
    result = ERROR(NULLADDR);						// Return NULL address error
    
  if (!result)									// If no errors, do SWI operation
    result = logon_USER_PASS(username, password, hostname, port_number, timeout_USER, timeout_PASS, timeout_greeting);
  
  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.logon);						// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }
  #ifdef MEMCHECK
    if (username) MemCheck_UnRegisterMiscBlock(username);
    if (password) MemCheck_UnRegisterMiscBlock(password);
    if (hostname) MemCheck_UnRegisterMiscBlock(hostname);
  #endif    

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_Disconnect
   DESCRIPTION:    Function to handle AcornPOP3_Disconnect SWI
   		   Function to disconnect from the POP server.  Uses POP QUIT
		   command and closes the socket.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = Timeout for QUIT command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_Disconnect(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  int			 timeout_QUIT  = 2;					// timeout for QUIT command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
//  timeout_QUIT  = (int)r->r[2];
  
//  if ((!inuse) || (pollword_addr != &caller_data))				// If not registered or pollword address is wrong
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);						// Return Invalid ID error
  
  if (!result)									// If no errors, do SWI operation
    result = logout(timeout_QUIT);
  
  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.disconnect);					// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_GetNumOfMessages
   DESCRIPTION:    Function to handle AcornPOP3_GetNumOfMessages SWI
   		   Function to get the number of messages for the current
		   connection.  Uses POP3 STAT command.  Size returned is just a
		   guide due to differences in EOL characters that can be used be
		   servers, and other considerations.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = Timeout for STAT command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_GetNumOfMessages(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  int			 timeout_STAT  = 2;					// timeout for STAT command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
//  timeout_STAT  = (int)r->r[2];
  
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
  if (!result)									// If no errors, do SWI operation
    result = get_number_of_messages(timeout_STAT, &(process1.getnumofmessages.num_messages), &(process1.getnumofmessages.mailbox_size));
  
  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.getnumofmessages);				// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_GetListOfMessages
   DESCRIPTION:    Function to handle AcornPOP3_GetListOfMessages SWI
   		   Function to get a list of the messages in a users mailbox on the
		   POP server.  The list is a list of message ids with sizes for
		   each message in bytes.  The size is only a guide as the size on
		   the server may be different due differences in the EOL
		   characters, etc.  get_number_of_messages should be used first to
		   create MSG_LIST array of correct size which should be passed in,
		   as should the number of elements in the array.  If, during the
		   time of calling get_number_of_messages and doing this operation
		   more messages have arrived in the mailbox (or even if some have
		   strangely vanished from the mailbox) number will be set on exit
		   to the actual number of messages.  If number is greater than the
		   size of the list, then the list will be filled up, and this
		   function should be called again to get the rest of the
		   outstanding messages.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = Address of block of memory to store list in
   							r->r[3] = number of MSG_LIST structs that will fit in data block
   							r->r[4] = Timeout for LIST command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_GetListOfMessages(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  void			*data          = 0;					// address of data block to use
  unsigned int		 num_entries   = 0;					// number of MSG_LIST structs that can fit in data block
  int			 timeout_LIST  = 2;					// timeout for LIST command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  data          = (void*)r->r[2];						// get address of data block to use
  num_entries   = (unsigned int)r->r[3];					// get number of MSG_LIST structs that will fit in data block
//  timeout_LIST  = (int)r->r[4];							// get timeout value in minutes
  
//  if ((!inuse) || (pollword_addr != &caller_data))				// If not registered or pollword address is wrong
  #ifdef MEMCHECK
    if (data) MemCheck_RegisterMiscBlock(data, num_entries*sizeof(MSG_LIST));
  #endif
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
  if ((!result) && (data == 0))							// if data address = 0, return error
    result = ERROR(NULLADDR);
  
  if (!result)									// If no errors, do SWI operation
    result = get_list_of_messages(data, num_entries, timeout_LIST);
  
  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.getlistofmessages);				// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }
  #ifdef MEMCHECK
    if (data) MemCheck_UnRegisterMiscBlock(data);
  #endif
  
  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_GetMessage
   DESCRIPTION:    Function to handle AcornPOP3_GetMessage SWI
   		   Function to get a given message from the server into memory.  If
		   size of message block on input is too small, the message block
		   will be filled up with as much of the message as possible and
		   size set to the actual size required.  The function should then
		   be called again with the correct size of memory assigned to
		   message.  Or, give up and use the File based version of this
		   call: get_message_to_file.  Uses POP RETR command.
		   
		   OR
		   
		   Function to get a given message from the server into a file.  If
		   the size of the message causes the filesystem the message file
		   is to be put on to fillup, then the message is aborted and an
		   error returned.  Caller should close and delete the file.
		   Actual size of the mail message is returned in size.  Uses POP
		   RETR command.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							  bit0 -   set(1) = file based
   							  bit0 - unset(0) = memory based
   							r->r[1] = Address of pollword
   							r->r[2] = Address of block of memory to store list in or address of string holding filename to use
   							r->r[3] = size of memory block or free space on FS where file is.  In bytes for either
   							r->r[4] = message id
   							r->r[5] = delete message flag  0 = no 1 = yes, delete message if received successfully
   							r->r[6] = Timeout for RETR command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_GetMessage(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  char			*data          = 0;					// address of memory block or filename
  unsigned int		 space         = 0;					// number of bytes in memory block or freespace on FS
  unsigned int		 message_id    = 0;					// message id number
  BOOL			 delete_flag   = FALSE;					// delete flag
  int			 timeout_RETR  = 2;					// timeout for RETR command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  data          = (char*)r->r[2];						// get address of data block to use/filename
  space         = (unsigned int)r->r[3];					// get space in bytes
  message_id    = (unsigned int)r->r[4];					// get message id
  delete_flag   = (BOOL)r->r[5];						// get delete flag
//  timeout_RETR  = (int)r->r[6];							// get timeout value in minutes
  
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
  if ((!result) && (data == 0))							// if data address = 0, return error
    result = ERROR(NULLADDR);
  
  #ifdef MEMCHECK
    if (data) MemCheck_RegisterMiscBlock_String(data);
  #endif
  if (!result)									// If no errors, do SWI operation
  {
    switch (flags)
    {
      case 0:
      {
        // Memory version
//        result = get_message_to_memory(FALSE, data, &space, message_id, 0, timeout_RETR, &internet_err);
        // if result =0 && deleteflag then do DELE on that message
        result = get_message_to_file(delete_flag, FALSE, FALSE, data, space, message_id, 0, timeout_RETR);
        break;
      }
      case 1:
      {
        // file version
        result = get_message_to_file(delete_flag, FALSE, TRUE, data, space, message_id, 0, timeout_RETR);
        break;
      }
      default:
      {
        // catch all
        result = ERROR(FAILED);							// return failed error as flag settings not recognised
        break;
      }
    }
    
/*    if ((!result) && (delete_flag == TRUE))
    {
      result = delete_message(message_id, timeout_RETR);				// Use default of timeout_DELE in future when I put timeouts in
    }*/
  }
  // setup registers for return from SWI
  if (!result)										// If no error, then
  {
    r->r[0] = r->r[0];									// r0 unchanged
    r->r[1] = (int)&(process1.getmessage);						// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];									// r0 unchanged
    r->r[1] = 0;									// Cleared
  }
  #ifdef MEMCHECK
    if (data) MemCheck_UnRegisterMiscBlock(data);
  #endif  
  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_GetXLinesOfMessage
   DESCRIPTION:    Function to handle AcornPOP3_GetXLinesOfMessage SWI
   		   Function to get the header, blank line and X lines of the body
		   text of a given message from the server into memory.    Uses POP
		   TOP command.  If the memory block given is not big enough, then
		   it is filled up and the actual size needed is set in size on
		   return.  Actual size is aways set in size on return.
 
                   OR
                   
                   Function to get the header, blank line and X lines of the body
		   text of a given message from the server into a file.  Uses POP
		   TOP command.  If the filesystem the message file is to be put on
		   to fills up, then the message is aborted and an error returned.
 		   Actual size of space of the header+blank line+Xlines of body
		   text is set on return in size.  Caller should close and delete
		   the file.  Actual size of the mail message is returned in size.  
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							  bit0 -   set(1) = file based
   							  bit0 - unset(0) = memory based
   							r->r[1] = Address of pollword
   							r->r[2] = Address of block of memory to store list in or address of string holding filename to use
   							r->r[3] = size of memory block or free space on FS where file is.  In bytes for either
   							r->r[4] = message id
   							r->r[5] = number of lines of message body to get
   							r->r[6] = Timeout for TOP command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_GetXLinesOfMessage(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  char			*data          = 0;					// address of memory block or filename
  unsigned int		 space         = 0;					// number of bytes in memory block or freespace on FS
  unsigned int		 message_id    = 0;					// message id number
  unsigned int		 num_lines     = 0;					// number of lines of body to get
  int			 timeout_TOP   = 2;					// timeout for TOP command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  data          = (char*)r->r[2];						// get address of data block to use/filename
  space         = (unsigned int)r->r[3];					// get space in bytes
  message_id    = (unsigned int)r->r[4];					// get message id
  num_lines     = (unsigned int)r->r[5];					// get number of lines of body to get from server
//  timeout_TOP   = (int)r->r[6];							// get timeout value in minutes
  
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
  if ((!result) && (data == 0))							// if data address = 0, return error
    result = ERROR(NULLADDR);
  
  #ifdef MEMCHECK
    if (data) MemCheck_RegisterMiscBlock_String(data);
  #endif
  if (!result)									// If no errors, do SWI operation
  {
    switch (flags)
    {
      case 0:
      {
        // Memory version
//        result = get_message_to_memory(TRUE, data, &space, message_id, num_lines, timeout_TOP, &internet_err);
        result = get_message_to_file(FALSE, TRUE, FALSE, data, space, message_id, num_lines, timeout_TOP);
        break;
      }
      case 1:
      {
        // file version
        result = get_message_to_file(FALSE, TRUE, TRUE, data, space, message_id, num_lines, timeout_TOP);
        break;
      }
      default:
      {
        // catch all
        result = ERROR(FAILED);						// return failed error as flag settings not recognised
        break;
      }
    }
  }
  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.getxlinesofmessage);				// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }
  #ifdef MEMCHECK
    if (data) MemCheck_UnRegisterMiscBlock(data);
  #endif  

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_DeleteMessage
   DESCRIPTION:    Function to handle AcornPOP3_DeleteMessage SWI
   		   Function to delete the given message from the mailbox on the
		   server.  Uses POP DELE command.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = message id
   							r->r[3] = Timeout for DELE command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_DeleteMessage(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  int			 message_id    = 0;					// message id number
  int			 timeout_DELE   = 2;					// timeout for DELE command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  message_id    = (int)r->r[2];							// get message id
//  timeout_DELE  = (int)r->r[3];							// get timeout value in minutes
  
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
  if (!result)									// If no errors, do SWI operation
    result = delete_message(message_id, timeout_DELE);
  
  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.deletemessage);					// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_GetUniqueID
   DESCRIPTION:    Function to handle AcornPOP3_GetUniqueID SWI
   		   Function to get the unique ID string for a given message.
   		   Uses POP3 UIDL command.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = Message ID
   							r->r[3] = Timeout for UIDL command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_GetUniqueID(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  unsigned int		 message_id    = 0;					// message id
  void			*pollword_addr = 0;					// address of pollword
  int			 timeout_UIDL  = 2;					// timeout for STAT command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  message_id    = (unsigned int)r->r[2];
//  timeout_UIDL  = (int)r->r[3];
  
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
#ifdef DEBUG
  Printf("handle_swi_AcornPOP3_GetUniqueID: ID: %d\n", message_id);
#endif
  if (!result)									// If no errors, do SWI operation
    result = get_message_uniqueID(timeout_UIDL, message_id, process1.getuniqueid.unique_id);

  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.getuniqueid);					// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }

  return result;
}


/* ************************************************************************** */
/*
   FUNCTION:       handle_swi_AcornPOP3_GetListOfUniqueIDs
   DESCRIPTION:    Function to handle AcornPOP3_GetListOfUniqueIDs SWI
   		   Function to get a list of the unique id's of messages in a
   		   users mailbox on the POP server.  The list is a list of
   		   message ids with their Unique IDs for each message.
   		   get_number_of_messages should be used first to
		   create UID_MSG_LIST array of correct size which should be passed in,
		   as should the number of elements in the array.  If, during the
		   time of calling get_number_of_messages and doing this operation
		   more messages have arrived in the mailbox (or even if some have
		   strangely vanished from the mailbox) number will be set on exit
		   to the actual number of messages.  If number is greater than the
		   size of the list, then the list will be filled up, and this
		   function should be called again to get the rest of the
		   outstanding messages.
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   _kernel_swi_regs*	r		registers
   							r->r[0] = flags
   							r->r[1] = Address of pollword
   							r->r[2] = Address of block of memory to store list in
   							r->r[3] = number of UID_MSG_LIST structs that will fit in data block
   							r->r[4] = Timeout for UIDL command
   OUTPUT PARAMS:  _kernel_swi_regs*	r		registers
   							r->r[0] = flags unchanged
   							r->r[1] = Unique ID to identified return data
   RETURN VALUE:   			NULL		if SWI handled successfully,
   							else ptr to error block
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
_kernel_oserror* handle_swi_AcornPOP3_GetListOfUniqueIDs(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror       *result        = 0;					// result to return
  unsigned int           flags         = 0;					// flags
  void			*pollword_addr = 0;					// address of pollword
  void			*data          = 0;					// address of data block to use
  unsigned int		 num_entries   = 0;					// number of UID_MSG_LIST structs that can fit in data block
  int			 timeout_UIDL  = 2;					// timeout for UIDL command (mins)

  UNUSED(pw);
  flags         = (unsigned int)r->r[0];					// get flags
  pollword_addr = (void*)r->r[1];						// get pollword_addr;
  data          = (void*)r->r[2];						// get address of data block to use
  num_entries   = (unsigned int)r->r[3];					// get number of UID_MSG_LIST structs that will fit in data block
//  timeout_UIDL  = (int)r->r[4];							// get timeout value in minutes
  
//  if ((!inuse) || (pollword_addr != &caller_data))				// If not registered or pollword address is wrong
  #ifdef MEMCHECK
    if (data) MemCheck_RegisterMiscBlock(data, num_entries*sizeof(UID_MSG_LIST));
  #endif
  if ((!inuse) && (pollword_addr != &(process1.pollword)))			// If not registered or pollword address is wrong
    result = ERROR(INVALIDID);							// Return Invalid ID error
  
  if ((!result) && (data == 0))							// if data address = 0, return error
    result = ERROR(NULLADDR);
  
  #ifdef DEBUG
    Printf("GetListOfUniqueIDs: num_entries: %d", num_entries);
  #endif
  if (!result)									// If no errors, do SWI operation
    result = get_list_of_uids(data, num_entries, timeout_UIDL);

  // setup registers for return from SWI
  if (!result)									// If no error, then
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = (int)&(process1.getlistofuids);				// Unique ID to identify returned structure
  }
  else
  {
    r->r[0] = r->r[0];								// r0 unchanged
    r->r[1] = 0;								// Cleared
  }
  #ifdef MEMCHECK
    if (data) MemCheck_UnRegisterMiscBlock(data);
  #endif

  return result;
}


