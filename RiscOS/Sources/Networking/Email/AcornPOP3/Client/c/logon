/*	Project Post (769) - AcornPOP3
	Acorn Risc Technologies
	Copyright © 1996. All Rights Reserved.

	FILE:		logon.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.11 for RISC OS

	OVERVIEW
	========
	Source file for implementation of function to perform POP3 USER and
	PASS login to a server.  Need to implement Non-blocking hostname lookups
	and non-blocking socket connection

	HISTORY
	=======
	20/02/97	0.01	RDW	Initial version
	06/03/97	0.02	RDW	Corrected if block structure around logon code and corrected returned error numbers
	07/03/97	0.03	RDW	Tidyup of comments and finish logon implmentation so that it closes socket on failures
	11/07/97	0.04	RDW	Tidy up when moving to correct build environment
	15/07/97	0.05	RDW	Tidy up
	15/07/97	0.06	RDW	Fix Logon so that it will work with a dotted IP address as the hostname
	13/10/97	0.07	RDW	removed #include "pop_utils.h" replaced it with "get.h" and "send.h" and now
					nonblocking FSM in operation
	13/11/97	0.08	RDW	in GET_HOST_NB state, when EINPROGRESS is returned we set t_slice to 0 so the FSM
					t_slice expires and we exit setting a CallAfter.  This releases time to the resolver
					to resolve the address.
					send_data free'ed in ERROR state.  Fixes possible memory leak
	18/11/97	0.09	RDW	Memcheck stuff added in GET_HOST_NB code
	13/01/98	0.10	RDW	Callback/CallAfter support tidied up
					Fixed call to Resolver_GetHost so it catches R0 being non-0
	27/01/98	0.11	RDW	Fixed returned data structure on successful return that
					it clears and sets all the data members of the structure.
					Before, if an error had occured from a previous logon attempt, the error would
					still be set in the structure!
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "swis.h"
#include "sys/errno.h"
#include "netdb.h"
#include "socklib.h"
#include "inetlib.h"
#include "unixlib.h"
#include "sys/filio.h"
#ifdef MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif


/* ************************************************************************** */
/*                                                                            */
/* Include header files - External Libraries                                  */
/*                                                                            */
/* ************************************************************************** */
#include "DebugLib.h"
#include "Elib_priv.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "logon.h"
#include "get.h"
#include "send.h"
#include "errortable.h"
#include "cmdresp.h"
#include "pop_utils.h"


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
static const int SLEEP_TIME    = 1;
static const int TIME_SLICE    = 50;						/* Time slice to use                                                   */
static const int PORT_NUMBER = 110;						/* Default TCP port number to use                     */
/*static const char sys_var_POP3_Default_Port[] = "Inet$POP3_Default_Port";*/	/* NOT IMPLEMENTED YET!                               */
#define Resolver_GetHost 0x066001


/* ************************************************************************** */
/*                                                                            */
/* External globals                                                           */
/*                                                                            */
/* ************************************************************************** */
extern process_details process1;						/* This client's process detail                        */
extern errno;									/* From Internet                                       */


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  INIT,
  GET_HOST,
  GET_HOST_NB,
  PREPARE_CONNECT,
  CONNECT,
  GREETING,
  USER,
  PASS,
  ERROR,
  COMPLETED
} STATES;									/* Logon FSM states                                    */

typedef struct
{
  time_t              t_slice;							/* timeslice, time to exit FSM by for re-entracy later */
  _kernel_oserror    *error;							/* OS error                                            */
  int                 errno;							/* Internet errno copy                                 */
  BOOL                end;							/* has the FSM ended?                                  */
  BOOL                exit;							/* exit FSM without setting callback                   */
  char               *username;							/* POP3 username to use                                */
  char               *password;							/* POP3 password to use                                */
  char               *hostname;							/* hostname of POP3 server to connect to               */
  int                 port_number;						/* TCP port number to use                              */
  int                 sock;							/* socket descriptor                                   */
  struct sockaddr_in  pop_server_addr;						/* connection address structure                        */
  struct hostent     *pop_server;						/* server address structure                            */
  struct servent     *pop_service;						/* service struct from Service lookup in services file */
  char               *response;							/* response line from server                           */
  u_long              addr;							/* 32bit address for dotted IP lookup                  */
  STATES              state;							/* logon FSM state                                     */
  _kernel_swi_regs    r;							/* SWI registers to use in SWI calls                   */
  char               *send_data;						/* data to send to server                              */
  int                 length;							/* length of data                                      */
  int                 greeting_timeout;						/* timeout for waiting for server greeting on connect  */
  int                 user_timeout;						/* timeout for waiting for user command to complete    */
  int                 pass_timeout;						/* timeout for waiting for pass command to complete    */
} logon_context;


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static logon_context *new_logon_context(void);
static void destroy_logon_context(logon_context **c);
static void logon_FSM_INIT(logon_context *c);
static void logon_FSM_GET_HOST_NB(logon_context *c);
static void logon_FSM_GET_HOST(logon_context *c);
static void logon_FSM_PREPARE_CONNECT(logon_context *c);
static void logon_FSM_CONNECT(logon_context *c);
static void logon_FSM_GREETING(logon_context *c);
static void logon_FSM_USER(logon_context *c);
static void logon_FSM_PASS(logon_context *c);
static void logon_FSM_COMPLETED(logon_context *c);
static void logon_FSM_ERROR(logon_context *c);
extern _kernel_oserror *logon_FSM(logon_context *context);
static _kernel_oserror *logon_CAhandler(_kernel_swi_regs *r, void *pw, void *data);
static _kernel_oserror *logon_CBhandler(_kernel_swi_regs *r, void *pw, void *data);


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static logon_context *new_logon_context(void)
{
  logon_context *c = malloc(sizeof(logon_context));
  dprintf(("", "new_logon_context\n"));
  
  if (c)
  {
    memset(c, 0, sizeof(logon_context));
    c->sock = -1;
    c->state = INIT;
  }
  
  return c;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void destroy_logon_context(logon_context **context)
{
  if (context)
  {
    if (*context)
    {
      logon_context *c = *context;
      
      if (c->username)	free(c->username);
      if (c->password)	free(c->password);
      if (c->hostname)	free(c->hostname);
      destroy_response(&(c->response));
      if (c->send_data)	free(c->send_data);
      free(c);
    }
    *context = 0;
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       logon_USER_PASS
   DESCRIPTION:    Function to logon to the given POP server using the supplied
   		   details.  Assumes at present that hostname is a name and not
   		   a dotted IP address.  This must be fixed!
   DEPENDENCIES:      			errortable	errortable.h
   		   constant		PORT		Default port number
   DEPENDED ON BY: function		handle_swi_AcornPOP3_Logon	swihndlers.c
   INPUT PARAMS:   char[]		username	username of POP3 mailbox
   		   char[]		password	password of POP3 mailbox
   		   char[]		hostname	hostname of POP3 server
   		   int			port_number	TCP port number to use to connect to on server
   		   int			timeout_USER	timeout for USER command
   		   int			timeout_PASS	timeout for PASS command   		   
   OUTPUT PARAMS:  int*			internet_err	Internet errno
   RETURN VALUE:   			NULL		if handled successfully,
   							else ptr to error block
   CONSTANTS:      NONE
   VARIABLES:      _kernel_oserror*	error		result to return
    		   int			sock		socket descriptor to use
    		   struct sockaddr_in	pop_server_addr	INET address structure for server
    		   struct hostent*	pop_server	for hostname lookup
    		   struct servent*	pop_service	for server lookup
   		   char*		response	response line from server
   		   int			rc		return code from sscanf
 */
/* ************************************************************************** */
extern _kernel_oserror* logon_USER_PASS(char  username[],
                                        char  password[],
                                        char  hostname[],
                                        int   port_number,
                                        int   timeout_USER,
                                        int   timeout_PASS,
                                        int   timeout_greeting)
{
  _kernel_oserror    *error           = 0;					/* result to return                                              */
  logon_context *context = new_logon_context();					/* create a new logon context for this operation                 */
  
  if (context == 0)								/* if failed to create new context, return error                 */
    error = ERROR(MALLOCFAILED);
  else										/* else make copies of the given parameters                      */
  {
    context->username = (char*)malloc(strlen(username)+1);
    context->password = (char*)malloc(strlen(password)+1);
    context->hostname = (char*)malloc(strlen(hostname)+1);
    
    if ((context->username == 0) ||
        (context->password == 0) ||
        (context->hostname == 0))						/* if any of the mallocs failed, then destroy any that succeeded */
    {
      if (context->username)	free(context->username);
      if (context->password)	free(context->password);
      if (context->hostname)	free(context->hostname);
      error = ERROR(MALLOCFAILED);					/* return error                                                  */
    }
    else									/* else, mallocs succeeded, so copy parameters                   */
    {
      strcpy(context->username, username);
      strcpy(context->password, password);
      strcpy(context->hostname, hostname);
      context->port_number = port_number;
      context->greeting_timeout = timeout_greeting;
      context->user_timeout = timeout_USER;
      context->pass_timeout = timeout_PASS;
      process1.logon_context = context;
      process1.state = CONNECTING;
//      error = logon_FSM(context);						/* enter the logon FSM                                           */
//      error = set_callback(/*CB_CALLER_FSM, EVENT_NONE, */logon_CBhandler, context);/* set a callback to re-enter the FSM later   */
      error = CB_logon(context);
    }
  }
  
  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern _kernel_oserror *logon_FSM(logon_context *context)
{
  _kernel_oserror *error = 0;
  
  dprintf(("", "logon_FSM: context: %x\n", context));
  if (context == 0)								/* make sure we've been given a context */
    error = ERROR(INTERNALERR);
  
  if (!error)
  {
    context->t_slice = clock() + TIME_SLICE;
    do										/* FSM do-while loop                    */
    {
      if (context->error)
        context->state = ERROR;
      switch (context->state)
      {
        case INIT:
          dprintf(("", "logon_FSM: INIT\n"));
          logon_FSM_INIT(context);
          break;
        case GET_HOST:
          dprintf(("", "logon_FSM: GET_HOST\n"));
          logon_FSM_GET_HOST(context);
          break;
        case GET_HOST_NB:
          dprintf(("", "logon_FSM: GET_HOST_NB\n"));
          logon_FSM_GET_HOST_NB(context);
          break;
        case PREPARE_CONNECT:
          dprintf(("", "logon_FSM: PREPARE_CONNECT\n"));
          logon_FSM_PREPARE_CONNECT(context);
          break;
        case CONNECT:
          dprintf(("", "logon_FSM: CONNECT\n"));
          logon_FSM_CONNECT(context);
          break;
        case GREETING:
          dprintf(("", "logon_FSM: GREETING\n"));
          logon_FSM_GREETING(context);
          break;
        case USER:
          dprintf(("", "logon_FSM: USER\n"));
          logon_FSM_USER(context);
          break;
        case PASS:
          dprintf(("", "logon_FSM: PASS\n"));
          logon_FSM_PASS(context);
          break;
        case ERROR:
          dprintf(("", "logon_FSM: ERROR\n"));
          logon_FSM_ERROR(context);
          break;
        case COMPLETED:
          dprintf(("", "logon_FSM: COMPLETED\n"));
          logon_FSM_COMPLETED(context);
          break;
        default:
          dprintf(("", "logon_FSM: INTERNAL ERROR\n"));
          error = ERROR(INTERNALERR);
          context->end = TRUE;
          break;
      } /* end switch */
    } while ((!expired(context->t_slice)) && (!context->end) && (!context->exit));
  } /* endif */
  
  if (!error)
  {
    if (context->end)								/* if end of the FSM                          */
    {
      destroy_logon_context(&context);						/* destroy the context                        */
//      process1.pollword = &(process1.logon);					/* tell caller that data is ready for reading */
      notify_client(&(process1.logon));
    }
    else if (!context->exit)							/* else, if not told to exit FSM, then        */
      error = CA_logon(context);
//      error = set_callback(/*CB_CALLER_FSM, EVENT_NONE, */logon_CBhandler, context);/* set a callback to re-enter the FSM later   */
    else									/* else we were told to exit the FSM as it    */
      context->exit = FALSE;							/* will be called back by anothe event        */
  }
  
  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern _kernel_oserror* CA_logon(void *data)
{
  return callx_add_callafter(SLEEP_TIME, &logon_CAhandler, data);
}


extern _kernel_oserror* CB_logon(void *data)
{
  return callx_add_callback(&logon_CBhandler, data);
}

  
static _kernel_oserror* logon_CAhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  dprintf(("", "ENTERED: logon_CAhandler\n"));
  return callx_add_callback(&logon_CBhandler, data);
}


static _kernel_oserror *logon_CBhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  return logon_FSM(data);
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_INIT(logon_context *c)
{
  if (c->port_number < 0)							/* if we've not been given a port number then    */
    c->pop_service = getservbyname("pop3", "tcp");				/* look it up in the services file               */
  if (c->pop_service == 0)							/* if the lookup failed, then use the default    */
    c->port_number = PORT_NUMBER;
    
  c->r.r[0] = 0;
  c->r.r[1] = (int)"Resolver_GetHost";
  c->error = _kernel_swi(OS_SWINumberFromString, &(c->r), &(c->r));		/* Test for presence of the ANT Resolver module  */
  
  if (c->error == 0)								/* ANT Resolver present                          */
    c->state = GET_HOST_NB;
  else
  {
    c->error = 0;								/* clear error                                   */
    c->state = GET_HOST;							/* do blocking gethostbyname                     */
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_GET_HOST_NB(logon_context *c)
{
  c->r.r[0] = (int)c->hostname;
  c->error = _kernel_swi(Resolver_GetHost, &(c->r), &(c->r));			/* Lookup hostname                               */
  if (c->error)									/* If error, then go into ERROR state            */
    c->state = ERROR;
  else if (c->r.r[0] == EINPROGRESS)						/* else, if lookup in process stay in this state */
  {
    c->state = GET_HOST_NB;
    c->t_slice = 0;								/* force us to exit the FSM and be called after a delay, allows Resolver time to work */
  }
  else										/* else, lookup has succeeded so copy out address*/
  {
    #ifdef MEMCHECK
      MemCheck_RegisterMiscBlock((void*)c->r.r[1], sizeof(struct hostent));
    #endif
    if (c->r.r[0] == -1)
    {
      /* host not found, assume IP address? */
      /* should move below code to another state/function to share with GET_HOST state machine */
      c->addr = inet_addr(c->hostname);						/* convert dotted IP address                                */
      if (c->addr == 0xffffffff)						/* if failed, switch to ERROR state                         */
      {
        c->error = ERROR(INTERNETERR);
        c->errno = errno;
        c->state = ERROR;
      }
      else									/* else, copy out address                                   */
      {
        memcpy((char*)&(c->pop_server_addr.sin_addr),
               &(c->addr),
               sizeof(c->addr));
        c->pop_server_addr.sin_family = AF_INET;
        c->state = PREPARE_CONNECT;						/* switch to state PREPARE_CONNECT                          */
      }
    }
    else if (c->r.r[0] < 0)
    {
      /* error, remote failure */
      c->error = ERROR(RESOLVERFAILED);
      c->state = ERROR;
    }
    else if (c->r.r[0] > 0)
    {
      c->error = ERROR(INTERNETERR);
      c->errno = c->r.r[0];
      c->state = ERROR;
    }
    else
    {
      /* success */
      c->pop_server = (struct hostent*)c->r.r[1];
      memcpy((char*)&(c->pop_server_addr.sin_addr),
             c->pop_server->h_addr,
             c->pop_server->h_length);
      c->pop_server_addr.sin_family = AF_INET;
      c->state = PREPARE_CONNECT;							/* switch to state PREPARE_CONNECT               */
      #ifdef MEMCHECK  
        MemCheck_UnRegisterMiscBlock((void*)c->r.r[1);
      #endif
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_GET_HOST(logon_context *c)
{
  c->pop_server = gethostbyname(c->hostname);					/* do blocking gethostbyname to get the server address      */
  if (c->pop_server == 0)							/* if lookup failed, assume hostname is a dotted IP address */
  {
    c->addr = inet_addr(c->hostname);						/* convert dotted IP address                                */
    if (c->addr == 0xffffffff)							/* if failed, switch to ERROR state                         */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = ERROR;
    }
    else									/* else, copy out address                                   */
    {
      memcpy((char*)&(c->pop_server_addr.sin_addr),
             &(c->addr),
             sizeof(c->addr));
      c->pop_server_addr.sin_family = AF_INET;
      c->state = PREPARE_CONNECT;						/* switch to state PREPARE_CONNECT                          */
    }
  }
  else										/* else, gethostbyname succeeded so, copy out address       */
  {
    memcpy((char*)&(c->pop_server_addr.sin_addr),
           c->pop_server->h_addr,
           c->pop_server->h_length);
    c->pop_server_addr.sin_family = c->pop_server->h_addrtype;
    c->state = PREPARE_CONNECT;							/* switch to state PREPARE_CONNECT                          */
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_PREPARE_CONNECT(logon_context *c)
{
  if (c->pop_service)								/* if TCP port number lookup succeeded, copy out the portnumber from that */
    c->pop_server_addr.sin_port = c->pop_service->s_port;
  else										/* else, take the given port number and convert to network byte order     */
    c->pop_server_addr.sin_port = htons(c->port_number);
  
  c->sock = socket(AF_INET, SOCK_STREAM, 0);					/* create socket                                                          */
  dprintf(("", "logon_FSM_PREPARE_CONNECT: c->sock: %d\n", c->sock));
  if (c->sock < 0)								/* if socket creation failed, switch to error state                       */
  {
    c->error = ERROR(INTERNETERR);
    c->errno = errno;
    c->state = ERROR;
  }
  else										/* else socket created successfully, so                                   */
  {
    int on = 1;
    
    if (socketioctl(c->sock, FIONBIO, &on) < 0)					/* make socket NON blocking                                               */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = ERROR;
    }
    else									/* make socket generate Internet Events                                   */
    {
      on = 1;
      if (socketioctl(c->sock, FIOASYNC, &on) < 0)
      {
        c->error = ERROR(INTERNETERR);
        c->errno = errno;
        c->state = ERROR;
      }
      else									/* if socket successfully non-blocking and asyncronous, then              */
        c->state = CONNECT;							/* switch to CONNECT state                                                */
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_CONNECT(logon_context *c)
{
  process1.socknum = c->sock;							/* copy socket into this client's process structure (only one client atm) */
  if (connect(c->sock, (struct sockaddr*)&(c->pop_server_addr),			/* if connection to POP3 server returned an error, then                   */
              sizeof(c->pop_server_addr)) < 0)
  {
    if ((errno != EINPROGRESS) && (errno != EALREADY) && (errno != EISCONN))	/* if error is not a "good" error, then switch to ERROR state             */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = ERROR;
    }
    else if (errno != EISCONN)							/* else if error is NOT ALREADY CONNECTED then                            */
    {
      c->state = CONNECT;							/* stay in this state                                                     */
      c->exit = TRUE;
    }
    else									/* else, we are connected so switch to GREETING state                     */
      c->state = GREETING;
  }
  else										/* else, connect succeeded straight away so switch to GREETING state      */
    c->state = GREETING;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_GREETING(logon_context *c)
{
  c->error = command_response(c->sock,
                              0,
                              0,
                              &(c->response),
                              c->greeting_timeout,
                              &(c->errno),
                              &(c->error),
                              (function)&logon_FSM,
                              c);						/* get greeting from server                                               */
  if (c->error)									/* if command_response returned an error, switch to ERROR state           */
    c->state = ERROR;
  else										/* else, switch to USER state and exit logon FSM as command_response will */
  {										/* call logon_FSM back with our context (c) when it is completed          */
    c->state = USER;
    c->exit = TRUE;
  }
}

  
/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_USER(logon_context *c)
{
  if (!positive_response(c->response))						/* if previous response (the greeting) was not positive, then             */
  {
    dprintf(("", "logon_FSM_USER: response: %s\n", c->response));
    c->error = ERROR(CONREFUSED);
    c->state = ERROR;								/* switch to ERROR state with CONNECTION REFUSED error                    */
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
  }
  else										/* else, greeting was okay, so                                            */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->length    = strlen(c->username) + 6;					/* calculate length of USER command to send "USER " = 5 + 1 NULL CHAR = 6 */
    c->send_data = (char*)malloc(c->length);					/* allocate space for USER command                                        */
    if (c->send_data)								/* successful, then send USER command and wait for response or timeout    */
    {
      strcpy(c->send_data, "USER ");
      strcat(c->send_data, c->username);
      c->length = strlen(c->send_data);
      c->error = command_response(c->sock,
                                  c->send_data,
                                  c->length,
                                  &(c->response),
                                  c->user_timeout,
                                  &(c->errno),
                                  &(c->error),
                                  (function)&logon_FSM,
                                  c);
      if (c->error)
        c->state = ERROR;
      else									/* else, switch to PASS state and exit logon FSM as command_response will */
      {										/* call logon_FSM back with our context (c) when it is completed          */
        c->state = PASS;
        c->exit  = TRUE;
      }
    }
    else									/* else, allocate for command failed, so switch to ERROR state            */
    {
      c->error = ERROR(MALLOCFAILED);
      c->state = ERROR;
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_PASS(logon_context *c)
{
  if (c->send_data)	free(c->send_data);					/* destroy the USERname command data sent to the server                   */
  c->send_data = 0;
  if (!positive_response(c->response))						/* if previous response (the username) was not positive, then             */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->error = ERROR(INVALIDUSERNAME);
    c->state = ERROR;								/* switch to ERROR state with INVALID USERNAME   error                    */
  }
  else										/* else, greeting was okay, so                                            */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->length    = strlen(c->password) + 6;					/* calculate length of PASS command to send "PASS " = 5 + 1 NULL CHAR = 6 */
    c->send_data = (char*)malloc(c->length);					/* allocate space for PASS command                                        */
    if (c->send_data)								/* successful, then send PASS command and wait for response or timeout    */
    {
      strcpy(c->send_data, "PASS ");
      strcat(c->send_data, c->password);
      c->length = strlen(c->send_data);
      c->error = command_response(c->sock,
                                  c->send_data,
                                  c->length,
                                  &(c->response),
                                  c->pass_timeout,
                                  &(c->errno),
                                  &(c->error),
                                  (function)&logon_FSM,
                                  c);
      if (c->error)
        c->state = ERROR;
      else									/* else, switch to COMPLETED state and exit logon FSM as command_response */
      {										/* will call logon_FSM back with our context (c) when it is completed     */
        c->state = COMPLETED;
        c->exit  = TRUE;
      }
    }
    else
    {
      c->error = ERROR(MALLOCFAILED);
      c->state = ERROR;
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_COMPLETED(logon_context *c)
{
  if (c->send_data)	free(c->send_data);					/* destroy the PASSword command data sent to the server                   */
  c->send_data = 0;
  if (!positive_response(c->response))						/* if previous response (the username) was not positive, then             */
  {
    c->error = ERROR(INVALIDPASSWORD);
    c->state = ERROR;								/* switch to ERROR state with INVALID PASSWORD   error                    */
  }
  else										/* else, logon completed successfully so setup data for caller            */
  {
    process1.logon.flags = 0;
    process1.logon.error = 0;
    process1.logon.errno = 0;
    c->end = TRUE;								/* end of FSM                                                             */
  }
  
  destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void logon_FSM_ERROR(logon_context *c)
{
  if (c->send_data)	free(c->send_data);					/* destroy the USERname command data sent to the server                   */
  c->send_data = 0;
  if (c->sock >= 0)								/* if socket created, then shut it down, close and deallocate it          */
  {
    shutdown(c->sock, 2);
    socketclose(c->sock);
  }
  process1.socknum = -1;							/* clear the process1 socket descriptor                                   */
  process1.logon.flags = 0;
  process1.logon.error = c->error;						/* copy over the error                                                    */
  process1.logon.errno = c->errno;						/* copy over the internet errno error                                     */
  c->end = TRUE;								/* end of FSM                                                             */
}


