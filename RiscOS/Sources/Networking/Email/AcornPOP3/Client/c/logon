/*	Project Post (769) - AcornPOP3
	Acorn Risc Technologies
	Copyright © 1996. All Rights Reserved.

	FILE:		logon.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.18 for RISC OS

	OVERVIEW
	========
	Source file for implementation of function to perform POP3 USER and
	PASS login to a server.

	HISTORY
	=======
	20/02/97	0.01	RDW	Initial version
	06/03/97	0.02	RDW	Corrected if block structure around logon code and corrected returned error numbers
	07/03/97	0.03	RDW	Tidyup of comments and finish logon implmentation so that it closes socket on failures
	11/07/97	0.04	RDW	Tidy up when moving to correct build environment
	15/07/97	0.05	RDW	Tidy up
	15/07/97	0.06	RDW	Fix Logon so that it will work with a dotted IP address as the hostname
	13/10/97	0.07	RDW	removed #include "pop_utils.h" replaced it with "get.h" and "send.h" and now
					nonblocking FSM in operation
	13/11/97	0.08	RDW	in GET_HOST_NB state, when EINPROGRESS is returned we set t_slice to 0 so the FSM
					t_slice expires and we exit setting a CallAfter.  This releases time to the resolver
					to resolve the address.
					send_data free'ed in ERROR state.  Fixes possible memory leak
	18/11/97	0.09	RDW	Memcheck stuff added in GET_HOST_NB code
	13/01/98	0.10	RDW	Callback/CallAfter support tidied up
					Fixed call to Resolver_GetHost so it catches R0 being non-0
	27/01/98	0.11	RDW	Fixed returned data structure on successful return that
					it clears and sets all the data members of the structure.
					Before, if an error had occured from a previous logon attempt, the error would
					still be set in the structure!
	10/02/98	0.12	RDW	INADDR_NONE constant used in place of 0xffffffff
					inet_addr() call removed from GET_HOST and GET_HOST_NB
					states and moved into INIT state so it's tried first
	04/02/98	0.13	RDW	fixed MemCheck_UnRegisterMiscBlock call in GET_HOST_NB
					added MemCheck_RegisterMiscBlock in GET_HOST_NB
					before memcpy uses the data
					logon_FSM_USER() and logon_FSM_PASS() fixed so that
					they pass the length of the command to command_response
					and not the size of the string.
	12/03/98	0.14	RDW	Elib_priv.h taken from EmailLib now
	18/03/98	0.15	RDW	logon_CAhandler() and logon_CBhandler() unused params.
					tidied up
	25/03/98	0.16	RDW	#include debuglib corrected
					#ifdef MEMCHECK changed to MemCheck_MEMCHECK
	28/05/98	0.17	RDW	moved switch to process1.state CONNECTING to
					exit from CONNECT state where it should be!
					And ensure on end of FSM CallAfter/Backs
					are removed and process1.state = PROCESSING
					Fixed MemCheck faulting on read in GET_HOST_NB
					Re-entracy changes as per cmdresp.c 0.05
	18/11/98	0.18	RDW	notify_progress added to logon_context
					Notifies client of AcornPOP3_CS_Resolving,
					ConnectingSocket, WaitingForGreeting and LoggingIn on
					switch into GET_HOST (or GET_HOST_NB), CONNECT,
					GREETING and USER respectively
					logon_USER_PASS(), notify_progress parameter added.
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "swis.h"
#include "sys/errno.h"
#include "netdb.h"
#include "socklib.h"
#include "inetlib.h"
#include "unixlib.h"
#include "sys/filio.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif


/* ************************************************************************** */
/*                                                                            */
/* Include header files - External Libraries                                  */
/*                                                                            */
/* ************************************************************************** */
#include "DebugLib/debuglib.h"
#include "Email/EmailLib/Elib_priv.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "logon.h"
#include "get.h"
#include "send.h"
#include "errortable.h"
#include "cmdresp.h"
#include "pop_utils.h"


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
static const int SLEEP_TIME    = 1;
static const int TIME_SLICE    = 50;						/* Time slice to use                                                   */
static const int PORT_NUMBER = 110;						/* Default TCP port number to use                     */
/*static const char sys_var_POP3_Default_Port[] = "Inet$POP3_Default_Port";*/	/* NOT IMPLEMENTED YET!                               */
#define Resolver_GetHost 0x066001


/* ************************************************************************** */
/*                                                                            */
/* External globals                                                           */
/*                                                                            */
/* ************************************************************************** */
extern process_details process1;						/* This client's process detail                        */
extern errno;									/* From Internet                                       */


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  INIT,
  GET_HOST,
  GET_HOST_NB,
  PREPARE_CONNECT,
  CONNECT,
  GREETING,
  USER,
  PASS,
  ERROR,
  COMPLETED
} STATES;									/* Logon FSM states                                    */

typedef struct
{
  AcornPOP3_Logon_data* logon_return_data;					/* return data structure to use                        */
  BOOL                notify_progress;						/* notify client of state changes? (true = yes)        */
  BOOL                in_FSM;							/* Thread currently executing in FSM                   */
  BOOL                pending_CB;						/* There is a CallBack/re-entrancy into the FSM pending*/
  BOOL                need_CB;							/* There needs to be a CallBack set to re-enter the FSM*/
  time_t              t_slice;							/* timeslice, time to exit FSM by for re-entracy later */
  _kernel_oserror    *error;							/* OS error                                            */
  int                 errno;							/* Internet errno copy                                 */
  BOOL                end;							/* has the FSM ended?                                  */
  BOOL                exit;							/* exit FSM without setting callback                   */
  char               *username;							/* POP3 username to use                                */
  char               *password;							/* POP3 password to use                                */
  char               *hostname;							/* hostname of POP3 server to connect to               */
  int                 port_number;						/* TCP port number to use                              */
  int                 sock;							/* socket descriptor                                   */
  struct sockaddr_in  pop_server_addr;						/* connection address structure                        */
  struct hostent     *pop_server;						/* server address structure                            */
  struct servent     *pop_service;						/* service struct from Service lookup in services file */
  char               *response;							/* response line from server                           */
  u_long              addr;							/* 32bit address for dotted IP lookup                  */
  STATES              state;							/* logon FSM state                                     */
  _kernel_swi_regs    r;							/* SWI registers to use in SWI calls                   */
  char               *send_data;						/* data to send to server                              */
  int                 length;							/* length of data                                      */
  int                 greeting_timeout;						/* timeout for waiting for server greeting on connect  */
  int                 user_timeout;						/* timeout for waiting for user command to complete    */
  int                 pass_timeout;						/* timeout for waiting for pass command to complete    */
} logon_context;


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static logon_context *new_logon_context(void);
/*static void destroy_logon_context(logon_context **c);*/			/* commented out to stop compiler warning about unused earlier
										   declaration of 'destroy_.....'  Why should it complain?  Surely it's
										   good practice to declare func. prototypes always, whether they
										   are really needed or not...*/
static void logon_FSM_INIT(logon_context *c);
static void logon_FSM_GET_HOST_NB(logon_context *c);
static void logon_FSM_GET_HOST(logon_context *c);
static void logon_FSM_PREPARE_CONNECT(logon_context *c);
static void logon_FSM_CONNECT(logon_context *c);
static void logon_FSM_GREETING(logon_context *c);
static void logon_FSM_USER(logon_context *c);
static void logon_FSM_PASS(logon_context *c);
static void logon_FSM_COMPLETED(logon_context *c);
static void logon_FSM_ERROR(logon_context *c);
extern _kernel_oserror *logon_FSM(logon_context *context);
static _kernel_oserror *logon_CAhandler(_kernel_swi_regs *r, void *pw, void *data);
static _kernel_oserror *logon_CBhandler(_kernel_swi_regs *r, void *pw, void *data);
static _kernel_oserror* CA_logon(void *data);
static void logon_notify_state_change(logon_context*              c,
                                      AcornPOP3_ConnectionStates  state);


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       logon_USER_PASS
   DESCRIPTION:    Function to logon to the given POP server using the supplied
   		   details.  Assumes at present that hostname is a name and not
   		   a dotted IP address.  This must be fixed!
   DEPENDENCIES:      			errortable	errortable.h
   		   constant		PORT		Default port number
   DEPENDED ON BY: function		handle_swi_AcornPOP3_Logon	swihndlers.c
   INPUT PARAMS:   char[]		username	username of POP3 mailbox
   		   char[]		password	password of POP3 mailbox
   		   char[]		hostname	hostname of POP3 server
   		   int			port_number	TCP port number to use to connect to on server
   		   int			timeout_USER	timeout for USER command
   		   int			timeout_PASS	timeout for PASS command
   		   BOOL			notify_progress	notify client when we reach major state milestones?
   OUTPUT PARAMS:  int*			internet_err	Internet errno
   RETURN VALUE:   			NULL		if handled successfully,
   							else ptr to error block
   CONSTANTS:      NONE
   VARIABLES:      _kernel_oserror*	error		result to return
    		   int			sock		socket descriptor to use
    		   struct sockaddr_in	pop_server_addr	INET address structure for server
    		   struct hostent*	pop_server	for hostname lookup
    		   struct servent*	pop_service	for server lookup
   		   char*		response	response line from server
   		   int			rc		return code from sscanf
 */
/* ************************************************************************** */
extern _kernel_oserror* logon_USER_PASS(char  username[],
                                        char  password[],
                                        char  hostname[],
                                        int   port_number,
                                        int   timeout_USER,
                                        int   timeout_PASS,
                                        int   timeout_greeting,
                                        BOOL  notify_progress)
{
  _kernel_oserror    *error           = 0;					/* result to return                                              */
  logon_context *context = new_logon_context();					/* create a new logon context for this operation                 */

  if (context == 0)								/* if failed to create new context, return error                 */
    error = ERROR(MALLOCFAILED);
  else										/* else make copies of the given parameters                      */
  {
    context->notify_progress = notify_progress;
    context->username = (char*)malloc(strlen(username)+1);
    context->password = (char*)malloc(strlen(password)+1);
    context->hostname = (char*)malloc(strlen(hostname)+1);

    if ((context->username == 0) ||
        (context->password == 0) ||
        (context->hostname == 0))						/* if any of the mallocs failed, then destroy any that succeeded */
    {
      if (context->username)	free(context->username);
      if (context->password)	free(context->password);
      if (context->hostname)	free(context->hostname);
      error = ERROR(MALLOCFAILED);						/* return error                                                  */
    }
    else									/* else, mallocs succeeded, so copy parameters                   */
    {
      strcpy(context->username, username);
      strcpy(context->password, password);
      strcpy(context->hostname, hostname);
      context->port_number = port_number;
      context->greeting_timeout = timeout_greeting;
      context->user_timeout = timeout_USER;
      context->pass_timeout = timeout_PASS;
      process1.logon_context = context;
      process1.state        = PROCESSING;					/* make sure main state is IDLE so event handler doesn't do anything */
      logon_notify_state_change(context, AcornPOP3_CS_INITIAL);			/* Tell client of initial state about to entered                 */
      error = CB_logon(context);
    }
  }

  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static logon_context *new_logon_context(void)
{
  logon_context *c = malloc(sizeof(logon_context));
  dprintf(("", "new_logon_context\n"));

  if (c)
  {
    memset(c, 0, sizeof(logon_context));
    c->sock = -1;
    c->state = INIT;
    c->logon_return_data = (AcornPOP3_Logon_data*)malloc(sizeof(AcornPOP3_Logon_data));
    if (c->logon_return_data == 0)
    {
      free(c);
      c = 0;
    }
  }

  return c;
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void destroy_logon_context(logon_context **context)
{
  if (context)
  {
    if (*context)
    {
      logon_context *c = *context;

      if (c->username)	free(c->username);
      if (c->password)	free(c->password);
      if (c->hostname)	free(c->hostname);
      destroy_response(&(c->response));
      if (c->send_data)	free(c->send_data);
      free(c);
    }
    *context = 0;
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
extern _kernel_oserror *logon_FSM(logon_context *context)
{
  _kernel_oserror *error = 0;

  dprintf(("", "logon_FSM: context: %x\n", context));
  if (context == 0)								/* make sure we've been given a context */
    error = ERROR(INTERNALERR);

  if (!error)
  {
    context->t_slice = clock() + TIME_SLICE;
    context->exit = FALSE;
    do										/* FSM do-while loop                    */
    {
      if (context->error)
        context->state = ERROR;
      switch (context->state)
      {
        case INIT:
          dprintf(("", "logon_FSM: INIT\n"));
          logon_FSM_INIT(context);
          break;
        case GET_HOST:
          dprintf(("", "logon_FSM: GET_HOST\n"));
          logon_FSM_GET_HOST(context);
          break;
        case GET_HOST_NB:
          dprintf(("", "logon_FSM: GET_HOST_NB\n"));
          logon_FSM_GET_HOST_NB(context);
          break;
        case PREPARE_CONNECT:
          dprintf(("", "logon_FSM: PREPARE_CONNECT\n"));
          logon_FSM_PREPARE_CONNECT(context);
          break;
        case CONNECT:
          dprintf(("", "logon_FSM: CONNECT\n"));
          logon_FSM_CONNECT(context);
          break;
        case GREETING:
          dprintf(("", "logon_FSM: GREETING\n"));
          logon_FSM_GREETING(context);
          break;
        case USER:
          dprintf(("", "logon_FSM: USER\n"));
          logon_FSM_USER(context);
          break;
        case PASS:
          dprintf(("", "logon_FSM: PASS\n"));
          logon_FSM_PASS(context);
          break;
        case ERROR:
          dprintf(("", "logon_FSM: ERROR\n"));
          logon_FSM_ERROR(context);
          break;
        case COMPLETED:
          dprintf(("", "logon_FSM: COMPLETED\n"));
          logon_FSM_COMPLETED(context);
          break;
        default:
          dprintf(("", "logon_FSM: INTERNAL ERROR\n"));
          error = ERROR(INTERNALERR);
          context->end = TRUE;
          break;
      } /* end switch */
    } while ((!expired(context->t_slice)) && (!context->end) && (!context->exit));
  } /* endif */

  if (!error)
  {
    int state = pop_irqs_off();							/* CRITICAL SECTION start, turn off interrupts */
    context->in_FSM = FALSE;							/* Clear the in_FSM flag as we are about to return */
    if (context->end)								/* If this is the end of the FSM execution, then */
    {
      process1.state = PROCESSING;						/* Ensure main state is IDLE                  */
      callx_remove_callafter(&logon_CAhandler, context);			/* Ensure any pending callafter is removed    */
      callx_remove_callback(&logon_CBhandler, context);				/* Ensure any pending callback is removed     */
      notify_client(context->logon_return_data, &(process1.logon), sizeof(process1.logon));
      destroy_logon_context(&context);						/* destroy the context                        */
    }
    else if (!context->exit)							/* else, if exit not set then t_slice must have expired, so */
    {
      context->pending_CB = FALSE;						/* ensure pending flag is FALSE, it should be */
      context->need_CB = FALSE;							/* set need_CB to FALSE as we are going to set a callback */
      error = CA_logon(context);						/* set a callafter to re-enter the FSM later  */
    }
    else if (context->need_CB)							/* else, if need callback flag is set, then   */
    {
      context->need_CB = FALSE;							/* clear the flag and                         */
      error = CB_logon(context);						/* set a callback to re-enter the FSM         */
    }
    pop_restore_irqs(state);							/* End of CRITICAL SECTION, restore irqs      */
  }

  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static _kernel_oserror* CA_logon(void *data)
{
  if (data)
    return callx_add_callafter(SLEEP_TIME, &logon_CAhandler, data);
  else
    return ERROR(NULLADDR);
}


extern _kernel_oserror* CB_logon(void *data)
{
  _kernel_oserror *error = 0;
  int              state;
  logon_context *context = (logon_context*)data;

  if (context)
  {
    state = pop_irqs_off();							/* CRITICAL SECTION - Turn off interrupts */
    if (!context->pending_CB)							/* If there is not a callback already set to go off, then */
    {
      if (context->in_FSM)							/* If there is currently a thread of execution in the FSM, then */
        context->need_CB = TRUE;						/* a callback needs to be set by that thread when it terminats  */
      else									/* otherwise */
      {
        context->pending_CB = TRUE;						/* We can set a callback, so set the flag and set the callback */
        error = callx_add_callback(&logon_CBhandler, data);
      }										/* endif current thread executing check */
    }										/* endif pending callback check */
    pop_restore_irqs(state);							/* End of CRITICAL SECTION - Restore interrupts */
  }
  else
    error = ERROR(NULLADDR);

  return error;
}


static _kernel_oserror* logon_CAhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  dprintf(("", "ENTERED: logon_CAhandler\n"));
  UNUSED(r);
  UNUSED(pw);

  return CB_logon(data);
}


static _kernel_oserror *logon_CBhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  logon_context *context = (logon_context*)data;
  int state;
  _kernel_oserror *error = 0;

  UNUSED(r);
  UNUSED(pw);

  if (context)
  {
    state = pop_irqs_off();
    context->in_FSM     = TRUE;
    context->pending_CB = FALSE;
    pop_restore_irqs(state);
    error = logon_FSM(data);
  }
  else
    error = ERROR(NULLADDR);

  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_INIT(logon_context *c)
{
  if (c->port_number < 0)							/* if we've not been given a port number then    */
    c->pop_service = getservbyname("pop3", "tcp");				/* look it up in the services file               */
  if (c->pop_service == 0)							/* if the lookup failed, then use the default    */
    c->port_number = PORT_NUMBER;

  c->addr = inet_addr(c->hostname);						/* convert dotted IP address                                */
  if (c->addr == INADDR_NONE)							/* if failed, switch to GET_HOST or GET_HOST_NB state       */
  {
    c->r.r[0] = 0;
    c->r.r[1] = (int)"Resolver_GetHost";
    c->error = _kernel_swi(OS_SWINumberFromString, &(c->r), &(c->r));		/* Test for presence of the ANT Resolver module  */

    logon_notify_state_change(c, AcornPOP3_CS_Resolving);			/* Tell client of state change                   */
    if (c->error == 0)								/* ANT Resolver present                          */
      c->state = GET_HOST_NB;
    else
    {
      c->error = 0;								/* clear error                                   */
      c->state = GET_HOST;							/* do blocking gethostbyname                     */
    }
  }
  else										/* else, inet_addr succeeded, so hostname is IP addr */
  {
    memcpy((char*)&(c->pop_server_addr.sin_addr),
           &(c->addr),
           sizeof(c->addr));
    c->pop_server_addr.sin_family = AF_INET;
    c->state = PREPARE_CONNECT;							/* switch to state PREPARE_CONNECT                          */
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_GET_HOST_NB(logon_context *c)
{
  memset(&(c->r), 0, sizeof(_kernel_swi_regs));
  c->r.r[0] = (int)c->hostname;
  c->error = _kernel_swi(Resolver_GetHost, &(c->r), &(c->r));			/* Lookup hostname                               */
  if (c->error)									/* If error, then go into ERROR state            */
    c->state = ERROR;
  else if (c->r.r[0] == EINPROGRESS)						/* else, if lookup in process stay in this state */
  {
    c->state = GET_HOST_NB;
    c->t_slice = 0;								/* force us to exit the FSM and be called after a delay, allows Resolver time to work */
  }
  else										/* else, lookup has succeeded so copy out address*/
  {
    #ifdef MemCheck_MEMCHECK
      MemCheck_RegisterMiscBlock((void*)c->r.r[1], sizeof(struct hostent));
    #endif
    if (c->r.r[0] < 0)
    {
      /* error, remote failure */
      c->error = ERROR(RESOLVERFAILED);
      c->state = ERROR;
    }
    else if (c->r.r[0] > 0)
    {
      c->error = ERROR(INTERNETERR);
      c->errno = c->r.r[0];
      c->state = ERROR;
    }
    else
    {
      /* success */
      c->pop_server = (struct hostent*)c->r.r[1];
      #ifdef MemCheck_MEMCHECK
        MemCheck_RegisterMiscBlock(c->pop_server->h_addr, c->pop_server->h_length);
      #endif
      memcpy((char*)&(c->pop_server_addr.sin_addr),
             c->pop_server->h_addr,
             c->pop_server->h_length);
      c->pop_server_addr.sin_family = AF_INET;
      c->state = PREPARE_CONNECT;							/* switch to state PREPARE_CONNECT               */
      #ifdef MemCheck_MEMCHECK
        MemCheck_UnRegisterMiscBlock((void*)c->pop_server->h_addr);
      #endif
    }
    #ifdef MemCheck_MEMCHECK
      MemCheck_UnRegisterMiscBlock((void*)c->r.r[1]);
    #endif
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_GET_HOST(logon_context *c)
{
  c->pop_server = gethostbyname(c->hostname);					/* do blocking gethostbyname to get the server address      */
  if (c->pop_server == 0)							/* if lookup failed, assume hostname is a dotted IP address */
  {
    c->error = ERROR(INTERNETERR);
    c->errno = errno;
    c->state = ERROR;
  }
  else										/* else, gethostbyname succeeded so, copy out address       */
  {
    memcpy((char*)&(c->pop_server_addr.sin_addr),
           c->pop_server->h_addr,
           c->pop_server->h_length);
    c->pop_server_addr.sin_family = c->pop_server->h_addrtype;
    c->state = PREPARE_CONNECT;							/* switch to state PREPARE_CONNECT                          */
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_PREPARE_CONNECT(logon_context *c)
{
  if (c->pop_service)								/* if TCP port number lookup succeeded, copy out the portnumber from that */
    c->pop_server_addr.sin_port = c->pop_service->s_port;
  else										/* else, take the given port number and convert to network byte order     */
    c->pop_server_addr.sin_port = htons(c->port_number);

  c->sock = socket(AF_INET, SOCK_STREAM, 0);					/* create socket                                                          */
  dprintf(("", "logon_FSM_PREPARE_CONNECT: c->sock: %d\n", c->sock));
  if (c->sock < 0)								/* if socket creation failed, switch to error state                       */
  {
    c->error = ERROR(INTERNETERR);
    c->errno = errno;
    c->state = ERROR;
  }
  else										/* else socket created successfully, so                                   */
  {
    int on = 1;

    if (socketioctl(c->sock, FIONBIO, &on) < 0)					/* make socket NON blocking                                               */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = ERROR;
    }
    else									/* make socket generate Internet Events                                   */
    {
      on = 1;
      if (socketioctl(c->sock, FIOASYNC, &on) < 0)
      {
        c->error = ERROR(INTERNETERR);
        c->errno = errno;
        c->state = ERROR;
      }
      else									/* if socket successfully non-blocking and asyncronous, then              */
      {
        logon_notify_state_change(c, AcornPOP3_CS_ConnectingSocket);		/* Tell client of state change                   */
        c->state = CONNECT;							/* switch to CONNECT state                                                */
      }
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_CONNECT(logon_context *c)
{
  process1.socknum = c->sock;							/* copy socket into this client's process structure (only one client atm) */
  if (connect(c->sock, (struct sockaddr*)&(c->pop_server_addr),			/* if connection to POP3 server returned an error, then                   */
              sizeof(c->pop_server_addr)) < 0)
  {
    if ((errno != EINPROGRESS) && (errno != EALREADY) && (errno != EISCONN))	/* if error is not a "good" error, then switch to ERROR state             */
    {
      c->error = ERROR(INTERNETERR);
      c->errno = errno;
      c->state = ERROR;
    }
    else if (errno != EISCONN)							/* else if error is NOT ALREADY CONNECTED then                            */
    {
      c->state = CONNECT;							/* stay in this state                                                     */
      process1.state = CONNECTING;
      c->exit = TRUE;
    }
    else									/* else, we are connected so switch to GREETING state                     */
    {
      logon_notify_state_change(c, AcornPOP3_CS_WaitingForGreeting);		/* Tell client of state change                   */
      c->state = GREETING;
    }
  }
  else										/* else, connect succeeded straight away so switch to GREETING state      */
    c->state = GREETING;
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_GREETING(logon_context *c)
{
  c->error = command_response(c->sock,
                              0,
                              0,
                              &(c->response),
                              c->greeting_timeout,
                              &(c->errno),
                              &(c->error),
                              (function)&logon_FSM,
                              c);						/* get greeting from server                                               */
  if (c->error)									/* if command_response returned an error, switch to ERROR state           */
    c->state = ERROR;
  else										/* else, switch to USER state and exit logon FSM as command_response will */
  {										/* call logon_FSM back with our context (c) when it is completed          */
    logon_notify_state_change(c, AcornPOP3_CS_LoggingIn);			/* Tell client of state change                   */
    c->state = USER;
    c->exit = TRUE;
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_USER(logon_context *c)
{
  if (!positive_response(c->response))						/* if previous response (the greeting) was not positive, then             */
  {
    dprintf(("", "logon_FSM_USER: response: %s\n", c->response));
    c->error = ERROR(CONREFUSED);
    c->state = ERROR;								/* switch to ERROR state with CONNECTION REFUSED error                    */
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
  }
  else										/* else, greeting was okay, so                                            */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->length    = strlen(c->username) + 5;					/* calculate length of USER command to send "USER " = 5 + 1 NULL CHAR = 6 */
    c->send_data = (char*)malloc(c->length + 1);				/* allocate space for USER command                                        */
    if (c->send_data)								/* successful, then send USER command and wait for response or timeout    */
    {
      strcpy(c->send_data, "USER ");
      strcat(c->send_data, c->username);
      c->length = strlen(c->send_data);
      c->error = command_response(c->sock,
                                  c->send_data,
                                  c->length,
                                  &(c->response),
                                  c->user_timeout,
                                  &(c->errno),
                                  &(c->error),
                                  (function)&logon_FSM,
                                  c);
      if (c->error)
        c->state = ERROR;
      else									/* else, switch to PASS state and exit logon FSM as command_response will */
      {										/* call logon_FSM back with our context (c) when it is completed          */
        c->state = PASS;
        c->exit  = TRUE;
      }
    }
    else									/* else, allocate for command failed, so switch to ERROR state            */
    {
      c->error = ERROR(MALLOCFAILED);
      c->state = ERROR;
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_PASS(logon_context *c)
{
  if (c->send_data)	free(c->send_data);					/* destroy the USERname command data sent to the server                   */
  c->send_data = 0;
  if (!positive_response(c->response))						/* if previous response (the username) was not positive, then             */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->error = ERROR(INVALIDUSERNAME);
    c->state = ERROR;								/* switch to ERROR state with INVALID USERNAME   error                    */
  }
  else										/* else, greeting was okay, so                                            */
  {
    destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
    c->length    = strlen(c->password) + 5;					/* calculate length of PASS command to send "PASS " = 5 + 1 NULL CHAR = 6 */
    c->send_data = (char*)malloc(c->length + 1);				/* allocate space for PASS command                                        */
    if (c->send_data)								/* successful, then send PASS command and wait for response or timeout    */
    {
      strcpy(c->send_data, "PASS ");
      strcat(c->send_data, c->password);
      c->length = strlen(c->send_data);
      c->error = command_response(c->sock,
                                  c->send_data,
                                  c->length,
                                  &(c->response),
                                  c->pass_timeout,
                                  &(c->errno),
                                  &(c->error),
                                  (function)&logon_FSM,
                                  c);
      if (c->error)
        c->state = ERROR;
      else									/* else, switch to COMPLETED state and exit logon FSM as command_response */
      {										/* will call logon_FSM back with our context (c) when it is completed     */
        c->state = COMPLETED;
        c->exit  = TRUE;
      }
    }
    else
    {
      c->error = ERROR(MALLOCFAILED);
      c->state = ERROR;
    }
  }
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_COMPLETED(logon_context *c)
{
  if (c->send_data)	free(c->send_data);					/* destroy the PASSword command data sent to the server                   */
  c->send_data = 0;
  if (!positive_response(c->response))						/* if previous response (the username) was not positive, then             */
  {
    c->error = ERROR(INVALIDPASSWORD);
    c->state = ERROR;								/* switch to ERROR state with INVALID PASSWORD   error                    */
  }
  else										/* else, logon completed successfully so setup data for caller            */
  {
    c->logon_return_data->flags = 0;
    c->logon_return_data->error = 0;						/* copy over the error                                                    */
    c->logon_return_data->errno = 0;						/* copy over the internet errno error                                     */
    c->end = TRUE;								/* end of FSM                                                             */
  }

  destroy_response(&(c->response));						/* destroy the response now we're finished with it                        */
}


/* ************************************************************************** */
/*
   FUNCTION:
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:
   RETURN VALUE:
   CONSTANTS:
   VARIABLES:
 */
/* ************************************************************************** */
static void logon_FSM_ERROR(logon_context *c)
{
  c->logon_return_data->flags = 0;
  c->logon_return_data->error = c->error;						/* copy over the error                                                    */
  c->logon_return_data->errno = c->errno;						/* copy over the internet errno error                                     */
  if (c->send_data)	free(c->send_data);					/* destroy the USERname command data sent to the server                   */
  c->send_data = 0;
  if (c->sock >= 0)								/* if socket created, then shut it down, close and deallocate it          */
  {
    shutdown(c->sock, 2);
    socketclose(c->sock);
  }
  process1.socknum = -1;							/* clear the process1 socket descriptor                                   */
  c->end = TRUE;								/* end of FSM                                                             */
}


/* ************************************************************************** */
/*
   FUNCTION:       logon_notify_state_change
   DESCRIPTION:    Function to notify client of state change progress.
                   c must be a pointer to a valid logon_context and state a
                   valid AcornPOP3_ConnectionState
   DEPENDENCIES:   type			logon_context		logon.c
                   type			AcornPOP3_ConnectionStates	common.h
                   function		notify_client		pop3_utils.h
   DEPENDED ON BY: All functions in this source file
   INPUT PARAMS:   logon_context*	c			logon context
                   AcornPOP3_ConnectionStates	state		state to pass on
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
static void logon_notify_state_change(logon_context*              c,
                                      AcornPOP3_ConnectionStates  state)
{
  dprintf(("", "logon_notify_state_change\n"));
  if (c->notify_progress == TRUE)
  {
    AcornPOP3_Logon_data* logon_data = (AcornPOP3_Logon_data*)malloc(sizeof(AcornPOP3_Logon_data));
    dprintf(("", "notify_progress is TRUE\n"));

    if (logon_data)								/* if malloc failed, we fail silently */
    {
      logon_data->flags = AcornPOP3_PROGRESS_NOTIFICATION;			/* set this flag, same position as one when client requests notification
      										   to indicate that the state field is valid */
      logon_data->error = 0;
      logon_data->errno = 0;
      logon_data->state = state;
      notify_client(logon_data, &(process1.logon), sizeof(process1.logon));
    }
  }
}
