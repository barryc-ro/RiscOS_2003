/*	Project Post (769) - AcornPOP3
	Acorn Risc Technologies
	Copyright © 1996. All Rights Reserved.

	FILE:		get.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.06 for RISC OS

	OVERVIEW
	========
	Source file for implementation of getline from server functionality.

	HISTORY
	=======
	08/10/97	0.01	RDW	Initial version
	13/11/97	0.02	RDW	COMPLETED state has had RFC822
					transparency code commented out
					This is now moved to getmsgfile.c.
	17/12/97	0.03	RDW	#include for callx changed to get it from library
	09/03/98	0.04	RDW	get_line_FSM_STORE_CHAR() realloc size added 1
					to it for NULL char so strncpy() after it is
					safe.
	12/03/98	0.05	RDW	Elib_priv.h taken from EmailLib now
	18/03/98	0.06	RDW	get_line_CAhandler(), get_line_CBhandler() and
					get_line_CAtimeouthandler() unused params. tidied up
*/


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <string.h>
#include <stdlib.h>
#include "inetlib.h"
#include "socklib.h"
#include "sys/errno.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - External Libraries                                  */
/*                                                                            */
/* ************************************************************************** */
#include "DebugLib.h"
#include "Email/EmailLib/Elib_priv.h"
#include "callx/callx.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "errortable.h"
#include "callbacks.h"
#include "get.h"


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  INIT,
  READ_CHAR,
  STORE_CHAR,
  ERROR,
  COMPLETED
} get_line_STATES;								/* States for get_line_from_server FSM                                 */

typedef struct
{
  int               sem;							/* semaphore */
  int               s;								/* socket to read from                                                 */
  int               timeout;							/* timeout for this get line                                           */
//  char              c;								/* character read from the socket                                      */
  CONNECTION_EVENT  event;							/* event from Internet Event handler if it is driving the FSM          */
  function          func;							/* function to callback once FSM has terminated                        */
  char            **line;							/* pointer to set to point to the read in line of data. FSM allocs mem */
  int               line_size;							/* size of the allocated memory at present                             */
  int               line_len;							/* length of data in the buffer at present (in chars)                  */
  int              *errno;							/* ptr to location to return internet errno to if there one occurs     */
  BOOL              end;							/* flag set once the FSM is terminated                                 */
  time_t            t_slice;							/* time in centiseconds to stay in FSM before releasing control        */
  _kernel_oserror  *error;							/* error to return to function                                         */
  _kernel_oserror **error2;							/* error to return to function                                         */
  get_line_STATES   state;							/* current FSM state                                                   */
  void             *data;
  BOOL              exit;
} get_line_context;


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
static const int SLEEP_TIME    = 1;
static const int TIME_SLICE    = 50;						/* Time slice to use                                                   */
static const int LINE_BUF_SIZE = 255;						/* granuality of buffer size to allocated with                         */


/* ************************************************************************** */
/*                                                                            */
/* External globals                                                           */
/*                                                                            */
/* ************************************************************************** */
extern errno;									// From Internet
extern process_details process1;


/* ************************************************************************** */
/*                                                                            */
/* Globals                                                                    */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static get_line_context* new_get_line_context(void);
static void              get_line_FSM_INIT(get_line_context *context);
static void              get_line_FSM_READ_CHAR(get_line_context *context);
static void              get_line_FSM_STORE_CHAR(get_line_context *context);
static void              get_line_FSM_ERROR(get_line_context *context);
static void              get_line_FSM_COMPLETED(get_line_context *context);
/*static _kernel_oserror*  get_line_FSM(get_line_context *context);*/		/* commented out to stop compiler warning about unused earlier
										   declaration of 'get_.....'  Why should it complain?  Surely it's
										   good practice to declare func. prototypes always, whether they
										   are really needed or not...*/
static _kernel_oserror*  get_line_CBhandler(_kernel_swi_regs *r, void *pw, void *data);
static _kernel_oserror*  get_line_CAhandler(_kernel_swi_regs *r, void *pw, void *data);


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       get_line_from_server
   DESCRIPTION:    Function to read in a line from the POP3 server.  A line is
   		   a string of characters terminated by CRLF.  This string is
   		   then returned to the caller.
   DEPENDENCIES:      			errortable		errortable.h
   		   function		recv			socklib.h
   DEPENDED ON BY: function		delete_message		deletemsg.c
   		   function		get_list_of_messages	getlistmsg.c
   		   function		get_list_of_uids	getlistuid.c
   		   function		get_message_to_file	getmsgfile.c
   		   function		get_message_to_memory	getmsgmem.c
   		   function		get_number_of_messages	getnummsgs.c
   		   function		logon_USER_PASS		logon.c
   		   function		logout			logout.c
   INPUT PARAMS:   int			s			socket descriptor to use
   		   int			timeout			time to wait for line before returning timeout
   		   void*		func(int rc, int error)	function to call when operation is completed
   		   char**		string			address of char* to set to point to data from server
   OUTPUT PARAMS:  char**		string			address of string from server
   		   int*			internet_err		Internet errno
   RETURN VALUE:   			NULL			if handled successfully,
   								else ptr to error block
   CONSTANTS:      NONE
   VARIABLES:      _kernel_oserror*	error			result to return
 */
/* ************************************************************************** */
extern _kernel_oserror *get_line_from_server(int               s,
                                             char            **string,
                                             int               timeout,
                                             int              *internet_err,
                                             _kernel_oserror **error2,
                                             function          func,
                                             void             *data)
{
  _kernel_oserror *error = 0;
  
  if ((s < 0) || (func == 0) || (internet_err == 0))				/* If invalid socket or function */
    error = ERROR(NULLADDR);						/* error is NULL address         */
  
  if (!error)									/* If noerror then,              */
  {
    if (string == 0)								/* If string ptr is NULL         */
      error = ERROR(NULLADDR);						/* error is NULL address         */
  }
  
  if (!error)
  {
    get_line_context *context = new_get_line_context();				/* create a new context for the FSM */
    process1.get_context = context;
    process1.state = GET;
    
    if (context)
    {
      context->s        = s;
      context->timeout  = timeout;
      context->func     = func;
      context->line     = string;
      context->errno    = internet_err;
      context->t_slice  = TIME_SLICE;
      context->end      = FALSE;
      context->error2   = error2;
      context->data     = data;
//      error = get_line_FSM(context);
//      error = set_callback(/*CB_DATA_GETLINE, */CB_CALLER_FSM, EVENT_NONE, &get_line_CBhandler, context);
//      dprintf(("", "SETTING CALLAFTER to get_line\n"));
//      error = callx_add_callafter(SLEEP_TIME, &get_line_CAhandler, context);
      error = CB_get_line_from_server(context);
    }
    else									/* else, malloc failed           */
      error = ERROR(MALLOCFAILED);					/* return error                  */
  }
  
  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:       new_get_line_context
   DESCRIPTION:    Function to create a new context for the get_line_FSM
   DEPENDENCIES:      			errortable		errortable.h
   		   function		malloc			stdlib.h
   		   function		memset			string.h
   		   type			get_line_context	
   DEPENDED ON BY: function		get_line_from_server
   INPUT PARAMS:   NONE
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   			NULL		if failed
   CONSTANTS:      NONE
   VARIABLES:      _kernel_oserror*	error		result to return
   		   va_list		arg		variable arguments of this function
   		   char*		buffer		string buffer to create command string in
   		   int			reallen		real length of command including line termination sequence (EOL)
   		   int			rc		send() return code
 */
/* ************************************************************************** */
static get_line_context *new_get_line_context(void)
{
  get_line_context *c = malloc(sizeof(get_line_context));			/* create new context        */
  
  if (c)									/* if created, initialise it */
  {
    memset(c, 0, sizeof(get_line_context));					/* init. context to NULL     */
    c->s        = -1;								/* init. socket to INVALID   */
    c->state    = INIT;								/* init. FSM state           */
    c->sem      = 0;
  }
  
  return c;
}


static _kernel_oserror *get_line_FSM(get_line_context *context)
{
  _kernel_oserror *error = 0;
  
  dprintf(("", "get_line_FSM: context: %x\n", context));
  if (context == 0)
    error = ERROR(INTERNALERR);
  
  if (!error)
  {
    context->t_slice = clock() + TIME_SLICE;
    context->sem--;
    if (context->sem < 0) context->sem = 0;
    do
    {
      if (context->error)
        context->state = ERROR;
      switch (context->state)
      {
        case INIT:
        {
          dprintf(("", "get_line_FSM: INIT\n"));
          get_line_FSM_INIT(context);
          break;
        }
        case READ_CHAR:
        {
          dprintf(("", "get_line_FSM: READ_CHAR\n"));
          if ((context->event == EVENT_TIMEOUT) || (context->event == EVENT_CONNECTION_BROKEN))
            context->state = ERROR;
          else
            get_line_FSM_READ_CHAR(context);
          break;
        }
        case STORE_CHAR:
        {
          dprintf(("", "get_line_FSM: STORE_CHAR\n"));
          if ((context->event == EVENT_TIMEOUT) || (context->event == EVENT_CONNECTION_BROKEN))
            context->state = ERROR;
          else
            get_line_FSM_STORE_CHAR(context);
          break;
        }
        case ERROR:
        {
          dprintf(("", "get_line_FSM: ERROR\n"));
          process1.state = PROCESSING;
          get_line_FSM_ERROR(context);
          break;
        }
        case COMPLETED:
        {
          dprintf(("", "get_line_FSM: COMPLETED\n"));
          process1.state = PROCESSING;
          get_line_FSM_COMPLETED(context);
          break;
        }
        default:
        {
          dprintf(("", "get_line_FSM: INTERNAL ERROR\n"));
          process1.state = PROCESSING;
          error = ERROR(INTERNALERR);
          break;
        }
      } // end FSM switch
    } while ((!expired(context->t_slice)) && (!context->end) && (!context->exit));	// end while on FSM
  }
  
/*      dprintf(("", "REMOVING CALLAFTER to get_line\n"));
      error = callx_remove_callafter(&get_line_CAhandler, context);
      if (error)
      {
        dprintf(("", "REMOVEING CALLAFTER GAVE ERROR: %d %s\n", error->errnum, error->errmess));
      }
      error = callx_remove_callback(&get_line_CBhandler, context);
      if (error)
      {
        dprintf(("", "REMOVEING CALLBACK GAVE ERROR: %d %s\n", error->errnum, error->errmess));
      }*/
  if (!error)
  {
    if (context->end)
    {
      free(context);
      context = 0;
    }
    else if (!context->exit)
    {
      error = CA_get_line_from_server(context);
//      dprintf(("", "SETTING CALLAFTER to get_line\n"));
//      error = callx_add_callafter(SLEEP_TIME, &get_line_CAhandler, context);
//      error = set_callback(/*CB_DATA_GETLINE, */CB_CALLER_FSM, EVENT_NONE, &get_line_CBhandler, context);
    }
    else
      context->exit = FALSE;
  }

  return error;
}


extern _kernel_oserror* CA_get_line_from_server(void *data)
{
  get_line_context *c = (get_line_context*)data;
  
  if (c->sem == 0)
  {
    dprintf(("", "SETTING CALLAFTER to get_line\n"));
    c->sem++;
    return callx_add_callafter(SLEEP_TIME, &get_line_CAhandler, c);
  }
  else
    return 0;
}


extern _kernel_oserror* CB_get_line_from_server(void *data)
{
  get_line_context *c = (get_line_context*)data;
  
  if (c->sem == 0)
  {
    dprintf(("", "SETTING CALLBACK to get_line\n"));
    c->sem++;
    return callx_add_callback(&get_line_CBhandler, c);
  }
  else
    return 0;
}

  
static _kernel_oserror* get_line_CAhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  dprintf(("", "ENTERED: get_line_CAhandler\n"));
  UNUSED(r);
  UNUSED(pw);
  
  return callx_add_callback(&get_line_CBhandler, data);
}


static _kernel_oserror* get_line_CBhandler(_kernel_swi_regs *r, void *pw, void *data)
{
  dprintf(("", "ENTERED: get_line_CBhandler\n"));
  UNUSED(r);
  UNUSED(pw);
  
  return get_line_FSM(data);
}


static _kernel_oserror* get_line_CAtimeouthandler(_kernel_swi_regs *r, void *pw, void *data)
{
  get_line_context *c = (get_line_context*)data;
  
  UNUSED(r);
  UNUSED(pw);
  c->event = EVENT_TIMEOUT;
  
  return CB_get_line_from_server(c);
}


static void get_line_FSM_INIT(get_line_context *context)
{
  context->line_size = LINE_BUF_SIZE;
  *(context->line) = malloc(context->line_size);
  if (*context->line == 0)
    context->error = ERROR(MALLOCFAILED);
  else
    (*(context->line))[0] = 0;
    
  if (!context->error)
    context->error = callx_add_callafter(context->timeout*60*100, &get_line_CAtimeouthandler, context);/*register_timeout(context->timeout, &get_line_CBhandler);*/
  dprintf(("", "get_line: timeout value is: %d\n", context->timeout));
  if (!context->error)
    context->state = READ_CHAR;
  else
    context->state = ERROR;
}


static void get_line_FSM_READ_CHAR(get_line_context *context)
{
  int rc = 0;
  BOOL do_a_recv = TRUE;
  
  dprintf(("", "1READ_CHAR:\nline_len: %d\nread_buffer: %s\nline: %s\n", context->line_len, process1.read_buffer, *(context->line)));
  if (process1.read_buffer[0] != 0)
  {
    int len = strlen(process1.read_buffer);
    char *tmp = process1.read_buffer;
    
    while (((*tmp != LF) && (*(tmp-1) != CR)) && (*tmp != 0))
      tmp++;
    if (*tmp == LF)
    {
      do_a_recv = FALSE;
      context->state = STORE_CHAR;
    }
    else if (context->line_size - context->line_len < len)
    {
      char *tmp;
      int   tmp_size;
      
      tmp_size = context->line_size + (len - (context->line_size - context->line_len)) + 1;
      tmp = realloc(*(context->line), tmp_size);
      if (!tmp)
      {
        context->error = ERROR(MALLOCFAILED);
        context->state = ERROR;
      }
      else
      {
        context->line_size = tmp_size;
        *(context->line) = tmp;
      }
//    } // this one
  dprintf(("", "2READ_CHAR:\nline_len: %d\nread_buffer: %s\nline: %s\n", context->line_len, process1.read_buffer, *(context->line)));
    
    if (!context->error)
    {
      strcpy(*(context->line)+context->line_len, process1.read_buffer);
      context->line_len += len;
      process1.read_buffer[0] = 0;	// 26/10/97
//      process1.read_buffer = tmp+1;
    }
    } //this one
    else
    {
      strcpy(*(context->line)+context->line_len, process1.read_buffer);
      context->line_len += len;
      process1.read_buffer[0] = 0;	// 26/10/97
    }
  }
/*  else
  {
    process1.read_buf_pos = process1.read_buffer;
    process1.read_buffer[0] = 0;
  }*/
  dprintf(("", "3READ_CHAR:\nline_len: %d\nread_buffer: %s\nline: %s\n", context->line_len, process1.read_buffer, *(context->line)));
  
  if ((!context->error) && (do_a_recv))
  {
    rc = recv(context->s, process1.read_buffer, process1.read_buf_size-1, 0);						// receive char from server
    dprintf(("", "recv: rc: %d\nrecv: process1.read_buffer: %s\nprocess1.read_buf_len: %d\n", rc, process1.read_buffer, process1.read_buf_len));
    if (rc < 0)
    {
      if (errno != EWOULDBLOCK)
      {
        context->error = ERROR(INTERNETERR);
        *(context->errno) = errno;
        context->state = ERROR;
      }
      else
      {
        context->state = READ_CHAR;
        context->exit = TRUE;
      }
    }
    else
    {
      context->state = STORE_CHAR;
      process1.read_buf_len = rc;
      process1.read_buffer[process1.read_buf_len] = 0;
    }
  }
}


static void get_line_FSM_STORE_CHAR(get_line_context *context)
{
  if (!(context->line_len <= context->line_size - process1.read_buf_len))
  {
    static char *tmp;
    static int   tmp_size;
    
    tmp_size = context->line_size + process1.read_buf_len;
    tmp = realloc(*(context->line), tmp_size + 1);
    if (tmp)
    {
      context->line_size = tmp_size;
      *(context->line) = tmp;
    }
    else
    {
      context->error = ERROR(MALLOCFAILED);
      context->state = ERROR;
    }
  }
  
  if (!context->error)
  {
    char *tmp = process1.read_buffer;
    dprintf(("", "get_line_FSM_STORE_CHAR: process1.read_buffer: %s\n", process1.read_buffer));
    
    while (((*tmp != LF) && (*(tmp-1) != CR)) && (*tmp != 0))
      tmp++;
    if (*tmp == LF)
    {
      int i = 0;
      tmp++;	// move past LF
      // copy upto and including CR infor context->line
      strncpy(*(context->line)+context->line_len, process1.read_buffer, tmp-process1.read_buffer);
      context->line_len += tmp-process1.read_buffer;
      (*(context->line))[context->line_len] = 0;
      // move remainder of process1.read_buffer down to start of process1.read_buffer
      for(i=0;i<(process1.read_buf_len+1 - (tmp - process1.read_buffer));i++)
        process1.read_buffer[i] = tmp[i];
/*      if (i==0)
        process1.read_buffer[0] = 0;*/
      dprintf(("", "1STORE_CHAR:\nline_len: %d\nread_buffer: %s\nline: %s\n", context->line_len, process1.read_buffer, *(context->line)));
    }
    else
    {
      dprintf(("", "2STORE_CHAR:\nline_len: %d\nread_buffer: %s\nline: %s\n", context->line_len, process1.read_buffer, *(context->line)));
      strcpy(*(context->line)+context->line_len, process1.read_buffer);
      process1.read_buffer[0] = 0;
      context->line_len = strlen(*(context->line));
      (*(context->line))[context->line_len]   = 0;
      dprintf(("", "3STORE_CHAR:\nline_len: %d\nread_buffer: %s\nline: %s\n", context->line_len, process1.read_buffer, *(context->line)));
    }
    dprintf(("", "*(context->line): %s\ncontext->line_len: %d\n", *(context->line), context->line_len));
    if (((*(context->line))[context->line_len - 1] == LF) && ((*(context->line))[context->line_len - 2] == CR))
      context->state = COMPLETED;
    else
      context->state = READ_CHAR;
  }
}


static void get_line_FSM_ERROR(get_line_context *context)
{
  callx_remove_callafter(&get_line_CAtimeouthandler, context);/*clear_timeout(&get_line_CBhandler);*/
  if (*(context->line) != 0)
    free(*(context->line));
  *(context->line) = 0;
  
  switch (context->event)
  {
    case EVENT_TIMEOUT:
      context->error = ERROR(CONTIMEDOUT);
      break;
    case EVENT_CONNECTION_BROKEN:
      context->error = ERROR(CONBROKEN);
      break;
    case EVENT_NONE:
    default:
      break;
  } // endswitch
  *(context->error2) = context->error;
  context->func(context->data);
  context->end = TRUE;
}


static void get_line_FSM_COMPLETED(get_line_context *context)
{
  callx_remove_callafter(&get_line_CAtimeouthandler, context);/*clear_timeout(get_line_CBhandler);*/
  dprintf(("", "get_line_FSM_COMPLETED: *(context->line): %s\n", *(context->line)));
  context->func(context->data);
  context->end = TRUE;
}


