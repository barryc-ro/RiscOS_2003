/*	Project Post (769) - AcornPOP3
	Acorn Risc Technologies
	Copyright © 1996. All Rights Reserved.

	FILE:		getlistuid.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.05 for RISC OS

	OVERVIEW
	========
	Source file for implementation of function to perform POP3 UIDL to get
	the list of Unique IDs from the server if possible

	HISTORY
	=======
	12/07/97	0.01	RDW	Initial version
	14/07/97	0.02	RDW	Tidy up
	01/10/97	0.03	RDW	Fix so that if list on server is greater than
					the space available we continue to d/load
					and through away these 'extra' list nodes.
					Return the actual number of nodes in the list
					we got from the server.
	22/10/97	0.04	RDW	Changed to new non-blocking
	12/03/98	0.05	RDW	Elib_priv.h taken from EmailLib now
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


/* ************************************************************************** */
/*                                                                            */
/* Include header files - External Libraries                                  */
/*                                                                            */
/* ************************************************************************** */
#include "DebugLib.h"
#include "Email/EmailLib/Elib_priv.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "common.h"
#include "getlistuid.h"
#include "pop_utils.h"
#include "get.h"
#include "cmdresp.h"
#include "errortable.h"


/* ************************************************************************** */
/*                                                                            */
/* External globals                                                           */
/*                                                                            */
/* ************************************************************************** */
extern process_details process1;						// This client's process details
extern errno;									// From Internet


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
static const int TIME_SLICE    = 50;						/* Time slice to use                                                   */
static char UIDLCMD[] = "UIDL";


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  UIDL,
  UIDL_RESPONSE,
  GET_LINE,
  STORE_LINE,
  COMPLETED,
  ERROR
} STATES;									/* GetListofMessages FSM states                        */

typedef struct
{
  time_t              t_slice;							/* timeslice, time to exit FSM by for re-entracy later */
  _kernel_oserror    *error;							/* OS error                                            */
  int                 errno;							/* Internet errno copy                                 */
  BOOL                end;							/* has the FSM ended?                                  */
  BOOL                exit;							/* exit FSM without setting callback                   */
  UID_MSG_LIST       *list;							/* address to store list at                            */
  unsigned int        num_entries;						/* address to store num of list elements at            */
  int                 sock;							/* socket descriptor                                   */
  char               *response;							/* response line from server                           */
  STATES              state;							/* GetListOfMessages FSM state                         */
  int                 list_timeout;						/* timeout for waiting for server response to UIDL cmd */
  unsigned int        pos;							/* position in list                                    */
} getlistofuids_context;


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static getlistofuids_context *new_getlistofuids_context(void);
static void get_list_of_uids_FSM_UIDL(getlistofuids_context *c);
static void get_list_of_uids_FSM_UIDL_RESPONSE(getlistofuids_context *c);
static void get_list_of_uids_FSM_GET_LINE(getlistofuids_context *c);
static void get_list_of_uids_FSM_STORE_LINE(getlistofuids_context *c);
static void get_list_of_uids_FSM_COMPLETED(getlistofuids_context *c);
static void get_list_of_uids_FSM_ERROR(getlistofuids_context *c);
extern _kernel_oserror *get_list_of_uids_FSM(getlistofuids_context *context);


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static getlistofuids_context *new_getlistofuids_context(void)
{
  getlistofuids_context *c = malloc(sizeof(getlistofuids_context));
  dprintf(("", "new_getlistofuids_context\n"));
  
  if (c)
  {
    memset(c, 0, sizeof(getlistofuids_context));
    c->sock = -1;
    c->state = UIDL;
  }
  
  return c;
}


/* ************************************************************************** */
/*
   FUNCTION:       getlistuid
   DESCRIPTION:    Function to get list of messages from server connection
   DEPENDENCIES:      			errortable	errortable.h
   DEPENDED ON BY: 
   INPUT PARAMS:   void*		data		memory area to write into with list data
   		   unsigned int*	num_entries	number of UID_MSG_LIST structs there is space for in data area
   		   int			timeout_UIDL	timeout for UIDL (UNUSED)
   OUTPUT PARAMS:  unsigned int*	num_entries	number of actual entries read into data area
   		   int*			internet_error	Internet errno
   RETURN VALUE:   			NULL		if handled successfully,
   							else ptr to error block
   CONSTANTS:      NONE
   VARIABLES:      _kernel_oserror*	error		result to return
   		   int			sock		socket descriptor to use
   		   char*		response	response string from server
   		   BOOL			end		end of list reached?
   		   UID_MSG_LIST*	list		typecast to data address in memory
   		   unsigned int		pos		position in array of UID_MSG_LISTs
   		   int			rc		return code from sscanf
 */
/* ************************************************************************** */
extern _kernel_oserror* get_list_of_uids(void         *data,
                                         unsigned int  num_entries,
                                         int           timeout_UIDL)
{
  _kernel_oserror    *error           = 0;					/* result to return                                              */
  getlistofuids_context *context = new_getlistofuids_context();			/* create a new logon context for this operation                 */
  
  if (context == 0)								/* if failed to create new context, return error                 */
    error = ERROR(MALLOCFAILED);
  else										/* else make copies of the given parameters                      */
  {
    context->list         = (UID_MSG_LIST*)data;
    context->num_entries  = num_entries;
    context->list_timeout = timeout_UIDL;
    context->sock         = process1.socknum;
//    error = get_list_of_uids_FSM(context);					/* enter the GetNumOfMessages FSM                                */
    error = set_callback(//CB_CALLER_FSM,
                         //EVENT_NONE,
                         get_list_of_uids_CBhandler,
                         context);						/* set a callback to re-enter the FSM later   */
  }
  
  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern _kernel_oserror *get_list_of_uids_FSM(getlistofuids_context *context)
{
  _kernel_oserror *error = 0;
  
  dprintf(("", "get_list_of_uids_FSM: context: %x\n", context));
  if (context == 0)								/* make sure we've been given a context */
    error = ERROR(INTERNALERR);
  
  if (!error)
  {
    context->t_slice = clock() + TIME_SLICE;
    do										/* FSM do-while loop                    */
    {
      if (context->error)
        context->state = ERROR;
      switch (context->state)
      {
        case UIDL:
          dprintf(("", "get_list_of_uids: UIDL\n"));
          get_list_of_uids_FSM_UIDL(context);
          break;
        case UIDL_RESPONSE:
          dprintf(("", "get_list_of_uids: UIDL_RESPONSE\n"));
          get_list_of_uids_FSM_UIDL_RESPONSE(context);
          break;
        case GET_LINE:
          dprintf(("", "get_list_of_uids: GET_LINE\n"));
          get_list_of_uids_FSM_GET_LINE(context);
          break;
        case STORE_LINE:
          dprintf(("", "get_list_of_uids: STORE_LINE\n"));
          get_list_of_uids_FSM_STORE_LINE(context);
          break;
        case ERROR:
          dprintf(("", "get_list_of_uids: ERROR\n"));
          get_list_of_uids_FSM_ERROR(context);
          break;
        case COMPLETED:
          dprintf(("", "get_list_of_uids: COMPLETED\n"));
          get_list_of_uids_FSM_COMPLETED(context);
          break;
        default:
          dprintf(("", "get_list_of_uids: INTERNAL ERROR\n"));
          error = ERROR(INTERNALERR);
          context->end = TRUE;
          break;
      } /* end switch */
    } while ((!expired(context->t_slice)) && (!context->end) && (!context->exit));
  } /* endif */
  
  if (!error)
  {
    if (context->end)								/* if end of the FSM                          */
    {
      free(context);								/* destroy the context                        */
//      process1.pollword = &(process1.getlistofuids);				/* tell caller that data is ready for reading */
      notify_client(&(process1.getlistofuids));
    }
    else if (!context->exit)							/* else, if not told to exit FSM, then        */
      error = set_callback(//CB_CALLER_FSM,
                           //EVENT_NONE,
                           get_list_of_uids_CBhandler,
                           context);						/* set a callback to re-enter the FSM later   */
    else									/* else we were told to exit the FSM as it    */
      context->exit = FALSE;							/* will be called back by anothe event        */
  }
  
  return error;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
extern _kernel_oserror *get_list_of_uids_CBhandler(_kernel_swi_regs *r, void *pw, void *data)
{
/*  _kernel_oserror *error = 0;
  
  if (data)
  {
    CB_DATA *cb_data = (CB_DATA*)data;
    getlistofuids_context *c = (getlistofuids_context*)cb_data->data;
    
    free(cb_data);
    error = get_list_of_uids_FSM(c);
  }
  else
    error = ERROR(INTERNALERR);
  
  return error;*/
  return get_list_of_uids_FSM(data);
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void get_list_of_uids_FSM_UIDL(getlistofuids_context *c)
{
  c->error = command_response(c->sock,
                              UIDLCMD,
                              4,
                              &(c->response),
                              c->list_timeout,
                              &(c->errno),
                              &(c->error),
                              (function)&get_list_of_uids_FSM,
                              c);
  if (!c->error)
  {
    c->state = UIDL_RESPONSE;
    c->exit = TRUE;
  }
  else
    c->state = ERROR;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void get_list_of_uids_FSM_UIDL_RESPONSE(getlistofuids_context *c)
{
  if (!positive_response(c->response))
    c->error = ERROR(NOTSUPPORTED);
  
  destroy_response(&(c->response));
  if (c->error)
    c->state = ERROR;
  else
    c->state = GET_LINE;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void get_list_of_uids_FSM_GET_LINE(getlistofuids_context *c)
{
  c->error = get_line_from_server(c->sock,
                                  &(c->response),
                                  c->list_timeout,
                                  &(c->errno),
                                  &(c->error),
                                  (function)&get_list_of_uids_FSM,
                                  c);
  if (c->error)
    c->state = ERROR;
  else
  {
    c->exit = TRUE;
    c->state = STORE_LINE;
  }
}

  
/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void get_list_of_uids_FSM_STORE_LINE(getlistofuids_context *c)
{
  if (c->response)
  {
    if (strncmp(c->response, ".\r\n", 3) == 0)					/* is this the end of the list? */
      c->state = COMPLETED;
    else if (c->pos < c->num_entries)
    {
      int rc = sscanf(c->response, "%lu %s", &(c->list[c->pos].msg_id), c->list[c->pos].unique_id);	/* read in ID and SIZE into array */
      dprintf(("", "get_list_of_uids_FSM_STORE_LINE: msg_id: %u\nunique_id: %s\n", c->list[c->pos].msg_id, c->list[c->pos].unique_id));
      c->pos++;									/* increment position in array */
      if (rc != 2)								/* if sscanf failed, then return failed. */
        c->error = ERROR(FAILED);
      c->state = GET_LINE;
    }
    else
    {
      c->pos++;
      c->state = GET_LINE;
    }
  }
  destroy_response(&(c->response));						/* deallocate response */
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void get_list_of_uids_FSM_COMPLETED(getlistofuids_context *c)
{
  if (c->pos > c->num_entries)
    c->error = ERROR(NOSPACE);
  c->num_entries = c->pos;
  process1.getlistofuids.flags = 0;
  process1.getlistofuids.error = c->error;
  process1.getlistofuids.errno = 0;
  process1.getlistofuids.num_entries = c->num_entries;
  
  c->end = TRUE;
}


/* ************************************************************************** */
/*
   FUNCTION:       
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  
   RETURN VALUE:   
   CONSTANTS:      
   VARIABLES:      
 */
/* ************************************************************************** */
static void get_list_of_uids_FSM_ERROR(getlistofuids_context *c)
{
  c->num_entries = c->pos;
  process1.getlistofuids.flags = 0;
  process1.getlistofuids.error = c->error;
  process1.getlistofuids.errno = c->errno;
  process1.getlistofuids.num_entries = c->num_entries;
  
  c->end = TRUE;
}
