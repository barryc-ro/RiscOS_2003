#line 1 "c.machine"
#line 1 "INetInc:^.^.libs.socklib.h.socklib"
/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.4  95/08/15  16:24:48  kwelton
 * Include of "sys/types.h" is now where it should be, i.e. before
 * include of "sys/socket.h".
 * 
 * 
 * Revision 1.3  95/05/02  17:23:22  kwelton
 * makecall() has been renamed to _makecall(), which is what it should have
 * been called in the first place.
 * 
 * Revision 1.2  95/04/20  17:43:26  kwelton
 * Function prototypes altered to match the genuine functionality, not
 * whatever random argument types were used in the original library.
 * 
 * Revision 1.1  95/04/20  13:40:58  kwelton
 * Initial revision
 * 
 */ 
#line 1 "INetInc:sys.h.types"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.3  95/07/27  10:24:20  kwelton
 * Changed the call to bzero() in the FD_ZERO macro to a call to memset().
 * 
 * Revision 1.2  95/04/20  16:41:20  kwelton
 * NBBY now protected against multiple declarations.
 * 
 * Revision 1.1  95/01/11  10:20:06  kwelton
 * Initial revision
 * 
 * Revision 1.3  88/06/17  20:22:16  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)types.h  1.4 87/09/03 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *      @(#)types.h     7.1 (Berkeley) 6/4/86
 */ 



/*
 * Basic system types and major/minor device constructing/busting macros.
 */ 

/* major part of a device */ 


/* minor part of a device */ 


/* make a device number */ 


typedef unsigned char   u_char, u_byte;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;
typedef unsigned short  ushort;         /* sys III compat */ 









typedef struct  _physadr { int r[1]; } *physadr;
typedef struct label_t {
        int     val[16];                /* bigger than need be, so what */ 
} label_t;


typedef struct  _quad { long val[2]; } quad;
typedef long    daddr_t;
typedef char *  caddr_t;
typedef u_long  ino_t;
typedef long    swblk_t;



   typedef u_int   size_t;
/* !defined(__size_t) */



     typedef long    time_t;
/* !defined(__time_h) */
/* !defined(__time_t) */
/* defined(__unix) || defined(__arm) */
typedef short   dev_t;
typedef long    off_t;
typedef u_short uid_t;
typedef u_short gid_t;
typedef int     key_t;          /* For System V IPC calls */ 





/*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 */ 




typedef long    fd_mask;





typedef struct fd_set {
        fd_mask fds_bits[ (((  256  )+((  (sizeof(fd_mask) *  8 )  )-1))/(  (sizeof(fd_mask) *  8 )  )) ];
} fd_set;








/* EOF types.h */ 
#line 27 "INetInc:^.^.libs.socklib.h.socklib"
#line 1 "INetInc:sys.h.socket"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:19:47  kwelton
 * Initial revision
 * 
 * Revision 1.3  88/06/17  20:21:11  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)socket.h 1.2 87/05/15 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982,1985, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *      @(#)socket.h    7.1 (Berkeley) 6/4/86
 */ 




/*
 * Definitions related to sockets: types, address families, options.
 */ 

/*
 * Types
 */ 






/*
 * Option flags per-socket.
 */ 











/*
 * Additional options, not kept in so_options.
 */ 









/*
 * Structure used for manipulating linger option.
 */ 
struct  linger {
        int     l_onoff;                /* option on/off */ 
        int     l_linger;               /* linger time */ 
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */ 


/*
 * Address families.
 */ 





















/*
 * Structure used by kernel to store most
 * addresses.
 */ 
struct sockaddr {
        u_short sa_family;              /* address family */ 
        char    sa_data[14];            /* up to 14 bytes of direct address */ 
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */ 
struct sockproto {
        u_short sp_family;              /* address family */ 
        u_short sp_protocol;            /* protocol */ 
};

/*
 * Protocol families, same as address families for now.
 */ 





















/*
 * Maximum queue length specifiable by listen.
 */ 


/*
 * Message header for recvmsg and sendmsg calls.
 */ 
struct msghdr {
        caddr_t msg_name;               /* optional address */ 
        int     msg_namelen;            /* size of address */ 
        struct  iovec *msg_iov;         /* scatter/gather array */ 
        int     msg_iovlen;             /* # elements in msg_iov */ 
        caddr_t msg_accrights;          /* access rights sent/received */ 
        int     msg_accrightslen;
};







/* __sys_socket_h */

/* EOF socket.h */ 
#line 28 "INetInc:^.^.libs.socklib.h.socklib"
#line 1 "INetInc:sys.h.stat"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:19:49  kwelton
 * Initial revision
 * 
 * Revision 1.3  88/06/17  20:21:18  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)stat.h	1.4 87/09/09 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)stat.h	7.1 (Berkeley) 6/4/86
 */ 

struct	stat
{
	dev_t	st_dev;
	ino_t	st_ino;
	unsigned short st_mode;
	short	st_nlink;
	uid_t	st_uid;
	gid_t	st_gid;
	dev_t	st_rdev;
	off_t	st_size;
	time_t	st_atime;
	int	st_spare1;
	time_t	st_mtime;
	int	st_spare2;
	time_t	st_ctime;
	int	st_spare3;
	long	st_blksize;
	long	st_blocks;
	long	st_spare4[2];
};
















/* EOF stat.h */ 
#line 29 "INetInc:^.^.libs.socklib.h.socklib"
#line 1 "INetInc:sys.h.time"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:19:59  kwelton
 * Initial revision
 * 
 * Revision 1.4  88/10/11  10:26:26  keith
 * Protect <sys/time.h> against multiple inclusion.
 * 
 * Revision 1.3  88/06/17  20:21:51  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)time.h	1.2 87/05/15 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)time.h	7.1 (Berkeley) 6/4/86
 */ 



/*
 * Structure returned by gettimeofday(2) system call,
 * and used in other calls.
 */ 
struct timeval {
	long	tv_sec;		/* seconds */ 
	long	tv_usec;	/* and microseconds */ 
};

struct timezone {
	int	tz_minuteswest;	/* minutes west of Greenwich */ 
	int	tz_dsttime;	/* type of dst correction */ 
};








/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */ 






/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */ 




struct	itimerval {
	struct	timeval it_interval;	/* timer interval */ 
	struct	timeval it_value;	/* current value */ 
};


#line 1 "INetInc:sys.h.time"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:19:59  kwelton
 * Initial revision
 * 
 * Revision 1.4  88/10/11  10:26:26  keith
 * Protect <sys/time.h> against multiple inclusion.
 * 
 * Revision 1.3  88/06/17  20:21:51  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)time.h	1.2 87/05/15 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)time.h	7.1 (Berkeley) 6/4/86
 */ 



/*
 * Structure returned by gettimeofday(2) system call,
 * and used in other calls.
 */

/* seconds */
/* and microseconds */



/* minutes west of Greenwich */
/* type of dst correction */

/* not on dst */
/* USA style dst */
/* Australian style dst */
/* Western European dst */
/* Middle European dst */
/* Eastern European dst */
/* Canada */

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */






/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */





/* timer interval */
/* current value */




/* !__SYS_TIME__ */

/* EOF time.h */ 
#line 76 "INetInc:sys.h.time"

/* !__SYS_TIME__ */

/* EOF time.h */ 
#line 30 "INetInc:^.^.libs.socklib.h.socklib"
#line 1 "INetInc:sys.h.uio"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:20:08  kwelton
 * Initial revision
 * 
 * Revision 1.3  88/06/17  20:22:19  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)uio.h	1.4 87/06/25 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)uio.h	7.1 (Berkeley) 6/4/86
 */ 




struct iovec {
	caddr_t	iov_base;
	int	iov_len;
};

struct uio {
	struct	iovec *uio_iov;
	int	uio_iovcnt;
	off_t	uio_offset;

	short	uio_segflg;


	short	uio_fmode;
	int	uio_resid;
};

enum	uio_rw { UIO_READ, UIO_WRITE };

/*
 * Segment flag values (should be enum).
 */ 





/* EOF uio.h */ 
#line 31 "INetInc:^.^.libs.socklib.h.socklib"

#line 1 "C:h.kernel"
___toplevel


/*
 *      Interface to host OS.
 *      Copyright (C) Acorn Computers Ltd., 1990
 */ 






/* from <stddef.h> */


typedef struct {
   int r[10];            /* only r0 - r9 matter for swi's */ 
} _kernel_swi_regs;

typedef struct {
   int load, exec;       /* load, exec addresses */ 
   int start, end;       /* start address/length, end address/attributes */ 
} _kernel_osfile_block;

typedef struct {
   void * dataptr;       /* memory address of data */ 
   int nbytes, fileptr;
   int buf_len;          /* these fields for Arthur gpbp extensions */ 
   char * wild_fld;      /* points to wildcarded filename to match */ 
} _kernel_osgbpb_block;

typedef struct {
   int errnum;           /* error number */ 
   char errmess[252];    /* error message (zero terminated) */ 
} _kernel_oserror;

typedef struct stack_chunk {
   unsigned long sc_mark;       /* == 0xf60690ff */ 
   struct stack_chunk *sc_next, *sc_prev;
   unsigned long sc_size;
   int (*sc_deallocate)();
} _kernel_stack_chunk;






extern _kernel_stack_chunk *_kernel_current_stack_chunk(void);

extern void _kernel_setreturncode(unsigned code);

extern void _kernel_exit(int);

extern void _kernel_raise_error(_kernel_oserror *);
/* return the specified error to the parent */ 
/* If the pointer passed is 0, simply return to caller */ 

extern void _kernel_exittraphandler(void);












extern int _kernel_hostos(void);
/*
 *  Returns the identity of the host OS
 */ 

extern int _kernel_fpavailable(void);
/*
 * Returns 0 if floating point is not available (no emulator nor hardware)
 */ 


extern _kernel_oserror *_kernel_swi(int no, _kernel_swi_regs *in,
                                   _kernel_swi_regs *out);
/*
 *  Generic SWI interface.  Returns NULL if there was no error.
 *  The SWI called normally has the X bit set.  To call a non-X bit set SWI,
 *  _kernel_NONX must be orred into no (in which case, if an error occurs,
 *  _kernel_oserror does not return).
 */ 

extern _kernel_oserror *_kernel_swi_c(int no, _kernel_swi_regs *in,
                                      _kernel_swi_regs *out, int *carry);
/*
 *  As _kernel_swi, but for use with SWIs which return status in the C flag.
 *  The int to which carry points is set to reflect the state of the C flag on
 *  exit from the SWI.
 */ 

extern char *_kernel_command_string(void);
/*
 * Returns the address of (maybe a copy of) the string used to run the program
 */ 

/*
 *  The int value returned by the following functions may have value:
 *    >= 0  if the call succeeds (significance then depends on the function)
 *     -1   if the call fails but causes no os error (eg escape for rdch).  Not
 *          all functions are capable of generating this result.  This return
 *          value corresponds to the C flag being set by the SWI.
 *     -2   if the call causes an os error (in which case, _kernel_last_oserror
 *          must be used to find which error it was)
 */ 



extern int _kernel_osbyte(int op, int x, int y);
/*
 *  Performs an OSByte operation.
 *  If there is no error, the result contains
 *     the return value of R1 (X) in its bottom byte
 *     the return value of R2 (Y) in its second byte
 *     1 in the third byte if carry is set on return, otherwise 0
 *     0 in its top byte
 *  (Not all of these values will be significant, depending on the
 *   particular OSByte operation).
 */ 

extern int _kernel_osrdch(void);
/*
 *  Returns a character read from the currently selected OS input stream
 */ 

extern int _kernel_oswrch(int ch);
/*
 *  Writes a byte to all currently selected OS output streams
 *  The return value just indicates success or failure.
 */ 

extern int _kernel_osbget(unsigned handle);
/*
 *  Returns the next byte from the file identified by 'handle'.
 *  (-1 => EOF).
 */ 

extern int _kernel_osbput(int ch, unsigned handle);
/*
 *  Writes a byte to the file identified by 'handle'.
 *  The return value just indicates success or failure.
 */ 

extern int _kernel_osgbpb(int op, unsigned handle, _kernel_osgbpb_block *inout);/*
 *  Reads or writes a number of bytes from a filing system.
 *  The return value just indicates success or failure.
 *  Note that for some operations, the return value of C is significant,
 *  and for others it isn't.  In all cases, therefore, a return value of -1
 *  is possible, but for some operations it should be ignored.
 */ 

extern int _kernel_osword(int op, int *data);
/*
 *  Performs an OSWord operation.
 *  The size and format of the block *data depends on the particular OSWord
 *  being used; it may be updated.
 */ 

extern int _kernel_osfind(int op, char *name);
/*
 *  Opens or closes a file.
 *    Open returns a file handle (0 => open failed without error)
 *    Close the return value just indicates success or failure
 */ 

extern int _kernel_osfile(int op, const char *name, _kernel_osfile_block *inout);
/*  Performs an OSFile operation, with values of r2 - r5 taken from the osfile
 *  block.  The block is updated with the return values of these registers,
 *  and the result is the return value of r0 (or an error indication)
 */ 

extern int _kernel_osargs(int op, unsigned handle, int arg);
/*
 *  Performs an OSArgs operation.
 *  The result is an error indication, or
 *    the current filing system number (if op = handle = 0)
 *    the value returned in R2 by the OSArgs operation otherwise
 */ 

extern int _kernel_oscli(const char *s);
/*
 *  Hands the argument string to the OS command line interpreter to execute
 *  as a command.  This should not be used to invoke other applications:
 *  _kernel_system exists for that.  Even using it to run a replacement
 *  application is somewhat dubious (abort handlers are left as those of the
 *  current application).
 *  The return value just indicates error or no error
 */ 

extern _kernel_oserror *_kernel_last_oserror(void);
/*
 *  Returns a pointer to an error block describing the last os error since
 *  _kernel_last_oserror was last called (or since there program started
 *  if there has been no such call).  If there has been no os error, returns
 *  a null pointer.  Note that occurrence of a further error may overwrite the
 *  contents of the block.
 *  If _kernel_swi caused the last os error, the error already returned by that
 *  call gets returned by this too.
 */ 

extern _kernel_oserror *_kernel_getenv(const char *name, char *buffer, unsigned size);
/*
 *  Reads the value of a system variable, placing the value string in the
 *  buffer (of size size).
 *  (This just gives access to  OS_ReadVarVal).
 */ 

extern _kernel_oserror *_kernel_setenv(const char *name, const char *value);
/*
 *  Updates the value of a system variable to be string valued, with the
 *  given value (value = NULL deletes the variable)
 */ 

extern int _kernel_system(const char *string, int chain);
/*
 *  Hands the argument string to the OS command line interpreter to execute.
 *  If chain is 0, the calling application is copied to the top of memory first,
 *    then handlers are installed so that if the command string causes an
 *    application to be invoked, control returns to _kernel_system, which then
 *    copies the calling application back into its proper place - the command
 *    is executed as a sub-program.  Of course, since the sub-program executes
 *    in the same address space, there is no protection against errant writes
 *    by it to the code or data of the caller.  And if there is insufficient
 *    space to load the sub-program, the manner of the subsequent death is
 *    unlikely to be pretty.
 *  If chain is 1, all handlers are removed before calling the CLI, and if it
 *    returns (the command is built-in) _kernel_system Exits.
 *  The return value just indicates error or no error
 */ 


extern unsigned _kernel_alloc(unsigned minwords, void **block);
/*
 *  Tries to allocate a block of sensible size >= minwords.  Failing that,
 *  it allocates the largest possible block (may be size zero).
 *  Sensible size means at least 2K words.
 *  *block is returned a pointer to the start of the allocated block
 *  (NULL if 'a block of size zero' has been allocated).
 */ 

typedef void freeproc(void *);
typedef void * allocproc(unsigned);

extern void _kernel_register_allocs(allocproc *malloc, freeproc *free);
/*
 *  Registers procedures to be used by the kernel when it requires to
 *  free or allocate storage.  The allocproc may be called during stack
 *  extension, so may not check for stack overflow (nor may any procedure
 *  called from it), and must guarantee to require no more than 41 words
 *  of stack.
 */ 

typedef int _kernel_ExtendProc(int /*n*/ , void** /*p*/ );
extern _kernel_ExtendProc *_kernel_register_slotextend(_kernel_ExtendProc *proc);
/* When the initial heap is full, the kernel is normally capable of extending
   it (if the OS will allow).  However, if the heap limit is not the same as
   the OS limit, it is assumed that someone else has acquired the space between,
   and the procedure registered here is called to request n bytes from it.
   Its return value is expected to be >= n or = 0 (failure); if success,
   *p is set to point to the space returned.
  */ 

extern int _kernel_escape_seen(void);
/*
 * Returns 1 if there has been an escape since the previous call of
 * _kernel_escape_seen (or since program start, if there has been no
 * previous call).  Escapes are never ignored with this mechanism,
 * whereas they may be with the language EventProc mechanism since there
 * may be no stack to call it on.
 */ 

typedef union {
    struct {int s:1, u:16, x: 15; unsigned mhi, mlo; } i;
    int w[3]; } _extended_fp_number;

typedef struct {
   int r4, r5, r6, r7, r8, r9;
   int fp, sp, pc, sl;
   _extended_fp_number f4, f5, f6, f7; } _kernel_unwindblock;

extern int _kernel_unwind(_kernel_unwindblock *inout, char **language);
/*
 *  Unwinds the call stack one level.
 *  Returns >0 if it succeeds
 *          0 if it fails because it has reached the stack end
 *          <0 if it fails for any other reason (eg stack corrupt)
 *  Input values for fp, sl and pc  must be correct.
 *  r4-r9 and f4-f7 are updated if the frame addressed by the input value
 *  of fp contains saved values for the corresponding registers.
 *  fp, sp, sl and pc are always updated
 *  *language is returned a pointer to a string naming the language
 *  corresponding to the returned value of pc.
 */ 

extern char *_kernel_procname(int pc);
/*
 *  Returns a string naming the procedure containing the address pc.
 *  (or 0 if no name for it can be found).
 */ 

extern char *_kernel_language(int pc);
/*
 *  Returns a string naming the language in whose code the address pc lies.
 *  (or 0 if it is in no known language).
 */ 

/*  divide and remainder functions.
 *  The signed functions round towards zero.
 *
 *  The div functions actually also return the remainder in a2, and use of
 *  this by a code-generator will be more efficient than a call to the rem
 *  function.
 *
 *  Language RTSs are encouraged to use these functions rather than providing
 *  their own, since considerable effort has been expended to make these fast.
 */ 

extern unsigned _kernel_udiv(unsigned divisor, unsigned dividend);
extern unsigned _kernel_urem(unsigned divisor, unsigned dividend);
extern unsigned _kernel_udiv10(unsigned dividend);

extern int _kernel_sdiv(int divisor, int dividend);
extern int _kernel_srem(int divisor, int dividend);
extern int _kernel_sdiv10(int dividend);

/*
 * Description of a 'Language description block'
 */ 

typedef enum { NotHandled, Handled } _kernel_HandledOrNot;

typedef struct {
   int regs [16];
} _kernel_registerset;

typedef struct {
   int regs [10];
} _kernel_eventregisters;

typedef void (*PROC) (void);
typedef _kernel_HandledOrNot (*_kernel_trapproc) (int code, _kernel_registerset *regs);
typedef _kernel_HandledOrNot (*_kernel_eventproc) (int code, _kernel_registerset *regs);

typedef struct {
   int size;
   int codestart, codeend;
   char *name;
   PROC (*InitProc)(void);
   PROC FinaliseProc;
   _kernel_trapproc TrapProc;
   _kernel_trapproc UncaughtTrapProc;
   _kernel_eventproc EventProc;
   _kernel_eventproc UnhandledEventProc;
   void (*FastEventProc) (_kernel_eventregisters *);
   int (*UnwindProc) (_kernel_unwindblock *inout, char **language);
   char * (*NameProc) (int pc);
} _kernel_languagedescription;

typedef int _kernel_ccproc(int, int, int);

extern int _kernel_call_client(int a1, int a2, int a3, _kernel_ccproc callee);
/* This is for shared library use only, and is not exported to shared library
 * clients. It is provided to allow library functions which call arbitrary
 * client code (C library signal, exit, _main) to do so correctly if the
 * client uses the old calling standard.
 */ 

extern int _kernel_client_is_module(void);
/* For shared library use only, not exported to clients.  Returns a
 * non-zero value if the library's client is a module executing in user
 * mode (ie module run code).
 */ 

extern int _kernel_processor_mode(void);

extern void _kernel_irqs_on(void);

extern void _kernel_irqs_off(void);

extern int _kernel_irqs_disabled(void);
/* returns 0 if interrupts are enabled; some non-zero value if disabled. */ 

extern void *_kernel_RMAalloc(size_t size);

extern void *_kernel_RMAextend(void *p, size_t size);

extern void _kernel_RMAfree(void *p);






/* end of kernel.h */ 
#line 33 "INetInc:^.^.libs.socklib.h.socklib"

/*
 * variable declarations
 */ 
extern int errno;
extern _kernel_oserror _inet_error;

/*
 * function prototypes
 */ 
extern int accept(int s, struct sockaddr *addr, int *addrlen);

extern int bind(int s, struct sockaddr *name, int namelen);

extern int connect(int s, struct sockaddr *name, int namelen);

extern int getpeername(int s, struct sockaddr *name, int *namelen);
extern int getsockname(int s, struct sockaddr *name, int *namelen);
extern int getsockopt(int s, int level, int optname,
		      void *optval, int *optlen);
extern int getstablesize(void);

extern int listen(int s, int backlog);

extern int _makecall(int swinum, _kernel_swi_regs *in, _kernel_swi_regs *out);

extern int recv(int s, char *buf, int len, int flags);
extern int recvfrom(int s, char *buf, int len, int flags,
		    struct sockaddr *from, int *fromlenaddr);
extern int recvmsg(int s, struct msghdr *msg, int flags);

extern int select(int nfds, fd_set *rfds, fd_set *wfds, fd_set *efds,
		  struct timeval *tv);
extern int send(int s, char *msg, int len, int flags);
extern int sendmsg(int s, struct msghdr *msg, int flags);
extern int sendto(int s, char *msg, int len, int flags,
		  struct sockaddr *to, int tolen);
extern int setsockopt(int s, int level, int optname, void *optval, int optlen);
extern int shutdown(int s, int how);
extern int socketclose(int d);
extern int socket(int domain, int type, int protocol);
extern int socketstat(int s, struct stat *buf);
extern int socketioctl(int s, unsigned long cmd, void *data);
extern int socketread(int s, char *buf, int len);
extern int socketreadv(int s, struct iovec *iov, int iovcnt);
extern int socketwrite(int s, char *buf, int len);
extern int socketwritev(int s, struct iovec *iov, int iovcnt);

/* EOF socklib.h */ 
#line 2 "c.machine"
#line 1 "INetInc:^.^.libs.inetlib.h.inetlib"
/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.2  95/06/01  15:37:52  kwelton
 * Added rresvport().
 * 
 * Revision 1.1  95/04/20  12:16:09  kwelton
 * Initial revision
 * 
 */ 
#line 1 "INetInc:sys.h.types"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.3  95/07/27  10:24:20  kwelton
 * Changed the call to bzero() in the FD_ZERO macro to a call to memset().
 * 
 * Revision 1.2  95/04/20  16:41:20  kwelton
 * NBBY now protected against multiple declarations.
 * 
 * Revision 1.1  95/01/11  10:20:06  kwelton
 * Initial revision
 * 
 * Revision 1.3  88/06/17  20:22:16  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)types.h  1.4 87/09/03 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *      @(#)types.h     7.1 (Berkeley) 6/4/86
 */ 



/*
 * Basic system types and major/minor device constructing/busting macros.
 */

/* major part of a device */


/* minor part of a device */


/* make a device number */






/* sys III compat */











/* bigger than need be, so what */












/* !defined(__size_t) */




/* !defined(__time_h) */
/* !defined(__time_t) */
/* defined(__unix) || defined(__arm) */




/* For System V IPC calls */


/* number of bits in a byte */


/*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 */





/* bits per mask */















/* EOF types.h */ 
#line 17 "INetInc:^.^.libs.inetlib.h.inetlib"

#line 1 "INetInc:netinet.h.in"
/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:16:50  kwelton
 * Initial revision
 * 
 */ 
/*
 *
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981.
 */ 




/*
 * Protocols
 */ 













/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 * Ports > IPPORT_USERRESERVED are reserved
 * for servers, not necessarily privileged.
 */ 



/*
 * Link numbers
 */ 




/*
 * Internet address (a structure for historical reasons)
 */ 
struct in_addr {
        u_long s_addr;
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */ 































/*
 * Socket address, internet style.
 */ 
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

/*
 * Options for use with [gs]etsockopt at the IP level.
 */ 









/* !defined(__netinet_in_h) */

/* EOF in.h */ 
#line 19 "INetInc:^.^.libs.inetlib.h.inetlib"

/*
 * variable declarations
 */ 
extern int _host_stayopen;
extern int _net_stayopen;
extern int _proto_stayopen;
extern int _serv_stayopen;

/*
 * function prototypes
 */ 
extern void endhostent(void);
extern void endnetent(void);
extern void endprotoent(void);
extern void endservent(void);

extern struct hostent *gethostbyaddr(char *addr, int length, int type);
extern struct hostent *gethostbyname(char *nam);
extern struct hostent *gethostent(void);
extern struct netent *getnetbyaddr(int net, int type);
extern struct netent *getnetbyname(char *name);
extern struct netent *getnetent(void);
extern struct protoent *getprotobyname(char *name);
extern struct protoent *getprotobynumber(int proto);
extern struct protoent *getprotoent(void);
extern struct servent *getservbyname(char *name, char *proto);
extern struct servent *getservbyport(int port, char *proto);
extern struct servent *getservent(void);

extern u_long htonl(u_long x);
extern int htons(int x);

extern u_long inet_addr(char *cp);
extern int inet_lnaof(struct in_addr in);
extern struct in_addr inet_makeaddr(int net, int host);
extern u_long inet_network(char *cp);
extern int inet_netof(struct in_addr in);
extern char *inet_ntoa(struct in_addr in);

extern struct hostent *namisipadr(char *nam);
extern u_long ntohl(u_long x);
extern int ntohs(int x);

extern int rresvport(int *alport);

extern void sethostent(int f);
extern void setnetent(int f);
extern void setprotoent(int f);
extern void setservent(int f);

/* EOF inetlib.h */ 
#line 3 "c.machine"
#line 1 "INetInc:sys.h.ioctl"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.5  95/09/21  15:21:48  pwain
 * Added SIOCGIFMTU and SIOCSIFMTU for PPP driver.
 *
 * Revision 1.4  95/06/13  14:39:58  kwelton
 * Added structure and definitions for new SIOCGPCBHEADS ioctl().
 *
 * Revision 1.3  95/06/05  14:33:30  kwelton
 * Added four new ioctl()'s: SIOC[GS]TCP{IDLE,CNT}.  These are new commands
 * for the Internet module, implemented at the request of Online.
 *
 * Revision 1.2  95/01/24  16:30:21  kwelton
 * Added a new ioctl, SIOCSWHOTHEYARE.
 *
 * Revision 1.1  95/01/11  10:19:17  kwelton
 * Initial revision
 *
 * Revision 1.3	 88/06/17  20:19:23  beta
 * Acorn Unix initial beta version
 *
 */ 
/* @(#)ioctl.h	1.2 87/05/15 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.	 The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)ioctl.h	7.1 (Berkeley) 6/4/86
 */ 

/*
 * Ioctl definitions
 */ 




#line 1 "INetInc:sys.h.ttychars"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:20:04  kwelton
 * Initial revision
 * 
 * Revision 1.3  88/06/17  20:22:08  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)ttychars.h	1.2 87/05/15 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)ttychars.h	7.1 (Berkeley) 6/4/86
 */ 

/*
 * User visible structures and constants
 * related to terminal handling.
 */ 


struct ttychars {
	char	tc_erase;	/* erase last character */ 
	char	tc_kill;	/* erase entire line */ 
	char	tc_intrc;	/* interrupt */ 
	char	tc_quitc;	/* quit */ 
	char	tc_startc;	/* start output */ 
	char	tc_stopc;	/* stop output */ 
	char	tc_eofc;	/* end-of-file */ 
	char	tc_brkc;	/* input delimiter (like nl) */ 
	char	tc_suspc;	/* stop process signal */ 
	char	tc_dsuspc;	/* delayed stop process signal */ 
	char	tc_rprntc;	/* reprint line */ 
	char	tc_flushc;	/* flush output (toggles) */ 
	char	tc_werasc;	/* word erase */ 
	char	tc_lnextc;	/* literal next character */ 
};



/* default special characters */ 

















/* EOF ttychars.h */ 
#line 47 "INetInc:sys.h.ioctl"
#line 1 "INetInc:sys.h.ttydev"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:20:05  kwelton
 * Initial revision
 * 
 * Revision 1.3  88/06/17  20:22:12  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)ttydev.h	1.2 87/05/15 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)ttydev.h	7.1 (Berkeley) 6/4/86
 */ 

/*
 * Terminal definitions related to underlying hardware.
 */ 



/*
 * Speeds
 */ 


















/*
 * Hardware bits.
 * SHOULD NOT BE HERE.
 */



/*
 * Modem control commands.
 */







/* EOF ttydev.h */ 
#line 48 "INetInc:sys.h.ioctl"


struct tchars {
	char	t_intrc;	/* interrupt */ 
	char	t_quitc;	/* quit */ 
	char	t_startc;	/* start output */ 
	char	t_stopc;	/* stop output */ 
	char	t_eofc;		/* end-of-file */ 
	char	t_brkc;		/* input delimiter (like nl) */ 
};


/* arm */

struct ltchars {
	char	t_suspc;	/* stop process signal */ 
	char	t_dsuspc;	/* delayed stop process signal */ 
	char	t_rprntc;	/* reprint line */ 
	char	t_flushc;	/* flush output (toggles) */ 
	char	t_werasc;	/* word erase */ 
	char	t_lnextc;	/* literal next character */ 
};


/* arm */

/*
 * Structure for TIOCGETP and TIOCSETP ioctls.
 */ 



struct sgttyb {
	char	sg_ispeed;		/* input speed */ 
	char	sg_ospeed;		/* output speed */ 
	char	sg_erase;		/* erase character */ 
	char	sg_kill;		/* kill character */ 
	short	sg_flags;		/* mode flags */ 
};


/*
 * Window/terminal size structure.
 * This information is stored by the kernel
 * in order to provide a consistent interface,
 * but is not used by the kernel.
 *
 * Type must be "unsigned short" so that types.h not required.
 */ 
struct winsize {
	unsigned short	ws_row;			/* rows, in characters */ 
	unsigned short	ws_col;			/* columns, in characters */ 
	unsigned short	ws_xpixel;		/* horizontal size, pixels */ 
	unsigned short	ws_ypixel;		/* vertical size, pixels */ 
};

/*
 * Pun for SUN.
 */ 
struct ttysize {
	unsigned short	ts_lines;
	unsigned short	ts_cols;
	unsigned short	ts_xxx;
	unsigned short	ts_yyy;
};




/*
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */ 





/* the 0x20000000 is so we can distinguish new ioctl's from old */ 



/* this should be _IORW, but stdio got there first */ 



/*
 * tty ioctl commands
 */ 







































































/* locals, from 127 down */ 



























































/* another local */ 







/* socket i/o controls */ 












































/*
 * the following ioctl's were implemented for use by OM - they are
 * not for use by the faint-hearted, nor by the idly curious
 */ 





/* 210995 PWain
 * The IOCTLs to set and get the MTU of a unit.
 */ 



/*
 * this ioctl supplies the head of the UDP and TCP pcb linked lists. it
 * is for use by the RISC OS equivalent of the UNIX netstat command
 */ 
struct pcbheads
{
    struct inpcb *pcb_udb;
    struct inpcb *pcb_tcb;
};


/* defined(__riscos) */



/* EOF ioctl.h */ 
#line 4 "c.machine"
#line 1 "INetInc:sys.h.errno"
/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988,1990 Acorn Computers Ltd., Cambridge, England
 * 
 */  





#line 1 "INetInc:sys.^.h.errno"
/*
 * $Header$
 * $Source$
 *
 * Copyright (c) 1988 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:21:32  kwelton
 * Initial revision
 * 
 * Revision 1.4	 88/10/25  13:21:59  brian
 * Shared library errors added.
 * 
 * Revision 1.3	 88/06/17  20:19:06  beta
 * Acorn Unix initial beta version
 * 
 */ 
/* @(#)errno.h	1.4 87/06/02 3.2/4.3NFSSRC */ 
/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.	 The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)errno.h	7.1 (Berkeley) 6/4/86
 */ 




#line 1 "C:h.kernel"
___toplevel


/*
 *      Interface to host OS.
 *      Copyright (C) Acorn Computers Ltd., 1990
 */ 






/* from <stddef.h> */



/* only r0 - r9 matter for swi's */



/* load, exec addresses */
/* start address/length, end address/attributes */



/* memory address of data */

/* these fields for Arthur gpbp extensions */
/* points to wildcarded filename to match */



/* error number */
/* error message (zero terminated) */



/* == 0xf60690ff */

















/* return the specified error to the parent */
/* If the pointer passed is 0, simply return to caller */















/*
 *  Returns the identity of the host OS
 */


/*
 * Returns 0 if floating point is not available (no emulator nor hardware)
 */




/*
 *  Generic SWI interface.  Returns NULL if there was no error.
 *  The SWI called normally has the X bit set.  To call a non-X bit set SWI,
 *  _kernel_NONX must be orred into no (in which case, if an error occurs,
 *  _kernel_oserror does not return).
 */



/*
 *  As _kernel_swi, but for use with SWIs which return status in the C flag.
 *  The int to which carry points is set to reflect the state of the C flag on
 *  exit from the SWI.
 */


/*
 * Returns the address of (maybe a copy of) the string used to run the program
 */

/*
 *  The int value returned by the following functions may have value:
 *    >= 0  if the call succeeds (significance then depends on the function)
 *     -1   if the call fails but causes no os error (eg escape for rdch).  Not
 *          all functions are capable of generating this result.  This return
 *          value corresponds to the C flag being set by the SWI.
 *     -2   if the call causes an os error (in which case, _kernel_last_oserror
 *          must be used to find which error it was)
 */




/*
 *  Performs an OSByte operation.
 *  If there is no error, the result contains
 *     the return value of R1 (X) in its bottom byte
 *     the return value of R2 (Y) in its second byte
 *     1 in the third byte if carry is set on return, otherwise 0
 *     0 in its top byte
 *  (Not all of these values will be significant, depending on the
 *   particular OSByte operation).
 */


/*
 *  Returns a character read from the currently selected OS input stream
 */


/*
 *  Writes a byte to all currently selected OS output streams
 *  The return value just indicates success or failure.
 */


/*
 *  Returns the next byte from the file identified by 'handle'.
 *  (-1 => EOF).
 */


/*
 *  Writes a byte to the file identified by 'handle'.
 *  The return value just indicates success or failure.
 */

/*
 *  Reads or writes a number of bytes from a filing system.
 *  The return value just indicates success or failure.
 *  Note that for some operations, the return value of C is significant,
 *  and for others it isn't.  In all cases, therefore, a return value of -1
 *  is possible, but for some operations it should be ignored.
 */


/*
 *  Performs an OSWord operation.
 *  The size and format of the block *data depends on the particular OSWord
 *  being used; it may be updated.
 */


/*
 *  Opens or closes a file.
 *    Open returns a file handle (0 => open failed without error)
 *    Close the return value just indicates success or failure
 */


/*  Performs an OSFile operation, with values of r2 - r5 taken from the osfile
 *  block.  The block is updated with the return values of these registers,
 *  and the result is the return value of r0 (or an error indication)
 */


/*
 *  Performs an OSArgs operation.
 *  The result is an error indication, or
 *    the current filing system number (if op = handle = 0)
 *    the value returned in R2 by the OSArgs operation otherwise
 */


/*
 *  Hands the argument string to the OS command line interpreter to execute
 *  as a command.  This should not be used to invoke other applications:
 *  _kernel_system exists for that.  Even using it to run a replacement
 *  application is somewhat dubious (abort handlers are left as those of the
 *  current application).
 *  The return value just indicates error or no error
 */


/*
 *  Returns a pointer to an error block describing the last os error since
 *  _kernel_last_oserror was last called (or since there program started
 *  if there has been no such call).  If there has been no os error, returns
 *  a null pointer.  Note that occurrence of a further error may overwrite the
 *  contents of the block.
 *  If _kernel_swi caused the last os error, the error already returned by that
 *  call gets returned by this too.
 */


/*
 *  Reads the value of a system variable, placing the value string in the
 *  buffer (of size size).
 *  (This just gives access to  OS_ReadVarVal).
 */


/*
 *  Updates the value of a system variable to be string valued, with the
 *  given value (value = NULL deletes the variable)
 */


/*
 *  Hands the argument string to the OS command line interpreter to execute.
 *  If chain is 0, the calling application is copied to the top of memory first,
 *    then handlers are installed so that if the command string causes an
 *    application to be invoked, control returns to _kernel_system, which then
 *    copies the calling application back into its proper place - the command
 *    is executed as a sub-program.  Of course, since the sub-program executes
 *    in the same address space, there is no protection against errant writes
 *    by it to the code or data of the caller.  And if there is insufficient
 *    space to load the sub-program, the manner of the subsequent death is
 *    unlikely to be pretty.
 *  If chain is 1, all handlers are removed before calling the CLI, and if it
 *    returns (the command is built-in) _kernel_system Exits.
 *  The return value just indicates error or no error
 */



/*
 *  Tries to allocate a block of sensible size >= minwords.  Failing that,
 *  it allocates the largest possible block (may be size zero).
 *  Sensible size means at least 2K words.
 *  *block is returned a pointer to the start of the allocated block
 *  (NULL if 'a block of size zero' has been allocated).
 */





/*
 *  Registers procedures to be used by the kernel when it requires to
 *  free or allocate storage.  The allocproc may be called during stack
 *  extension, so may not check for stack overflow (nor may any procedure
 *  called from it), and must guarantee to require no more than 41 words
 *  of stack.
 */

/*n*//*p*/

/* When the initial heap is full, the kernel is normally capable of extending
   it (if the OS will allow).  However, if the heap limit is not the same as
   the OS limit, it is assumed that someone else has acquired the space between,
   and the procedure registered here is called to request n bytes from it.
   Its return value is expected to be >= n or = 0 (failure); if success,
   *p is set to point to the space returned.
  */


/*
 * Returns 1 if there has been an escape since the previous call of
 * _kernel_escape_seen (or since program start, if there has been no
 * previous call).  Escapes are never ignored with this mechanism,
 * whereas they may be with the language EventProc mechanism since there
 * may be no stack to call it on.
 */











/*
 *  Unwinds the call stack one level.
 *  Returns >0 if it succeeds
 *          0 if it fails because it has reached the stack end
 *          <0 if it fails for any other reason (eg stack corrupt)
 *  Input values for fp, sl and pc  must be correct.
 *  r4-r9 and f4-f7 are updated if the frame addressed by the input value
 *  of fp contains saved values for the corresponding registers.
 *  fp, sp, sl and pc are always updated
 *  *language is returned a pointer to a string naming the language
 *  corresponding to the returned value of pc.
 */


/*
 *  Returns a string naming the procedure containing the address pc.
 *  (or 0 if no name for it can be found).
 */


/*
 *  Returns a string naming the language in whose code the address pc lies.
 *  (or 0 if it is in no known language).
 */

/*  divide and remainder functions.
 *  The signed functions round towards zero.
 *
 *  The div functions actually also return the remainder in a2, and use of
 *  this by a code-generator will be more efficient than a call to the rem
 *  function.
 *
 *  Language RTSs are encouraged to use these functions rather than providing
 *  their own, since considerable effort has been expended to make these fast.
 */









/*
 * Description of a 'Language description block'
 */

































/* This is for shared library use only, and is not exported to shared library
 * clients. It is provided to allow library functions which call arbitrary
 * client code (C library signal, exit, _main) to do so correctly if the
 * client uses the old calling standard.
 */


/* For shared library use only, not exported to clients.  Returns a
 * non-zero value if the library's client is a module executing in user
 * mode (ie module run code).
 */








/* returns 0 if interrupts are enabled; some non-zero value if disabled. */












/* end of kernel.h */ 
#line 31 "INetInc:sys.^.h.errno"

/*
 * global error variables, declared in socklib
 */ 

extern int errno;
extern _kernel_oserror _inet_error;

/*
 * this function returns the last error string
 * returned from the Internet module
 */ 
extern char *_inet_err(void);


/*
 * Error codes
 */ 

































/* math software */ 



/* non-blocking and interrupt i/o */ 




/* ipc/network software */ 

	/* argument errors */ 













	/* operational errors */ 













	/* */ 



/* should be rearranged */ 




/* quotas & mush */ 




/* Network File System */ 



/* SystemV Record Locking */ 



/* SystemV IPC */ 



/* Shared libraries */ 






/*__errno_h*/

/* EOF errno.h */ 
#line 15 "INetInc:sys.h.errno"


/*__sys_errno_h*/

/* EOF errno.h */ 
#line 5 "c.machine"
/* Suppress winges about K&R-style declarations */
#line 1 "INetInc:h.netdb"
/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/01/11  10:21:37  kwelton
 * Initial revision
 * 
 */ 

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */ 

/*
 * Structures returned by network
 * data base library.  All addresses
 * are supplied in host order, and
 * returned in network order (suitable
 * for use in system calls).
 */ 
struct  hostent {
        char    *h_name;        /* official name of host */ 
        char    **h_aliases;    /* alias list */ 
        int     h_addrtype;     /* host address type */ 
        int     h_length;       /* length of address */ 
        char    **h_addr_list;  /* list of addresses returned */ 

};

/*
 * Assumption here is that a network number
 * fits in 32 bits -- probably a poor one.
 */ 
struct  netent {
        char            *n_name;        /* official name of net */ 
        char            **n_aliases;    /* alias list */ 
        int             n_addrtype;     /* net address type */ 
        unsigned long   n_net;          /* network # */ 
};

struct  servent {
        char    *s_name;        /* official service name */ 
        char    **s_aliases;    /* alias list */ 
        int     s_port;         /* port # */ 
        char    *s_proto;       /* protocol to use */ 
};

struct  protoent {
        char    *p_name;        /* official protocol name */ 
        char    **p_aliases;    /* alias list */ 
        int     p_proto;        /* protocol # */ 
};

struct hostent  *gethostbyname(), *gethostbyaddr(), *gethostent();
struct netent   *getnetbyname(), *getnetbyaddr(), *getnetent();
struct servent  *getservbyname(), *getservbyport(), *getservent();
struct protoent *getprotobyname(), *getprotobynumber(), *getprotoent();

/* EOF netdb.h */ 
#line 7 "c.machine"


#line 1 "h.nettime"
#line 1 "stdio.h"
___toplevel























typedef char *__va_list[1]; 





typedef struct __fpos_t_struct
{ unsigned long __lo; 
} fpos_t;
 

typedef struct __FILE_struct
{ unsigned char *__ptr;
 int __icnt; 
 int __ocnt; 
 int __flag;
 
 
 unsigned char *__base; 
 int __file; 
 long __pos; 
 int __bufsiz; 
 int __signature; 
 struct __extradata *__extrap; 
} FILE;
 

















 


 



 

 








 









extern FILE __iob[];
 


 

 

 


extern int remove(const char * );
 
extern int rename(const char * , const char * );
 
extern FILE *tmpfile(void);
 
extern char *tmpnam(char * );
 

extern int fclose(FILE * );
 
extern int fflush(FILE * );
 
extern FILE *fopen(const char * , const char * );
 
extern FILE *freopen(const char * , const char * ,
 FILE * );
 
extern void setbuf(FILE * , char * );
 
extern int setvbuf(FILE * , char * ,
 int , size_t );
 


extern int fprintf(FILE * , const char * , ...);
 
extern int printf(const char * , ...);
 
extern int sprintf(char * , const char * , ...);
 

extern int fscanf(FILE * , const char * , ...);
 
extern int scanf(const char * , ...);
 
extern int sscanf(const char * , const char * , ...);
 

extern int vprintf(const char * , __va_list );
 
extern int vfprintf(FILE * ,
 const char * , __va_list );
 
extern int vsprintf(char * , const char * , __va_list );
 

extern int fgetc(FILE * );
 
extern char *fgets(char * , int , FILE * );
 
extern int fputc(int , FILE * );
 
extern int fputs(const char * , FILE * );
 
extern int __filbuf(FILE * );
 



extern int (getc)(FILE * );

 


extern int (getchar)(void);

 
extern char *gets(char * );
 
extern int __flsbuf(int , FILE * );
 



extern int (putc)(int , FILE * );

 


extern int (putchar)(int );

 
extern int puts(const char * );
 
extern int ungetc(int , FILE * );
 

extern size_t fread(void * ,
 size_t , size_t , FILE * );
 
extern size_t fwrite(const void * ,
 size_t , size_t , FILE * );
 

extern int fgetpos(FILE * , fpos_t * );
 
extern int fseek(FILE * , long int , int );
 
extern int fsetpos(FILE * , const fpos_t * );
 
extern long int ftell(FILE * );
 
extern void rewind(FILE * );
 

extern void clearerr(FILE * );
 



extern int (feof)(FILE * );

 


extern int (ferror)(FILE * );

 
extern void perror(const char * );
 







#line 2 "h.nettime"
#line 1 "C:h.swis"
___toplevel


/*Name:    swis.h
  Purpose: Generalised SWI interface
  Author:  (c) Acorn Computers Ltd, 1989
  Version: 2.04 (09-Jan-1995)
  This file is automatically generated from Hdr:makehswis
*/ 












extern int _swi (int swi_no, unsigned int, ...);

extern _kernel_oserror *_swix (int swi_no, unsigned int, ...);


















/*
 * These functions provide a generic method of calling RISC OS SWIs from C or
 * C++.
 * 
 * Two functions are provided:
 *     _swi for calling SWIs without setting the X bit
 *     _swix which sets the X bit before calling the SWI.
 * 
 * swi_no is the number of the SWI to be called. This should never have the
 * X bit set.
 * 
 * mask is a word containing an input and output register mask, a return
 * register, and a block parameter register.
 * 
 * The arrangement of mask is as follows:
 * 
 * Bits 0 -  9:  Set if R(N) is passed to the SWI.
 * Bits 22 - 31: Set if R(31-N) is output from the SWI (ie bit 31
 *               corresponds to R0, bit 22 corresponds to R9).
 * Bit 21:       Set if the PC (including the flags) is to be output.
 * Bits 16 - 19: Register no. to be returned from a _swi call. This is only
 *               applicable to _swi as _swix always returns either 0 or an error
 *               pointer.
 * Bit 11:       Set if a local block parameter is to be passed to the SWI
 * Bits 12 - 15: Register number for local block parameter if bit 11 set.
 * 
 * If a register is specified as a return register (bits 16-19) it must not
 * also be specified as an output register in the output register mask
 * (bits 22-31).
 * 
 * If a register is specified as a local block parameter register it must not
 * also be specified as an input register in the input register mask
 * (bits 0-9).
 * 
 * If the PC is specified as a return register (ie bits 16-19 = 15) or as an
 * output registers (bit 21 = 1) the value returned will contain the flags in
 * bits 28 to 31 (28 = V, 29 = C, 30 = Z, 31 = N).
 * 
 * The remainder of the variadic arguments are as follows (in order):
 * 
 * The word value of each input register in order from 0 to 9 as specified by
 * bits 0 to 9 of the mask.
 * 
 * The address of a word to be written for each output register in order from
 * 0 to 9 as specified by bits 31 downto 22 of the mask.
 * 
 * The address of a word to be written with the PC value on exit from the SWI
 * if bit 21 of the register mask is set.
 * 
 * If bit 11 is set the remainder of the arguments are placed in order in a
 * parameter block and the address of the parameter block is passed to the SWI
 * in the register specified by bits 12-15.
 * 
 * The macros are as follows:
 * 
 * _IN(n)       - Specifies that R(n) is used on input
 * _OUT(n)      - Specifies that R(n) is output
 * _BLOCK(n)    - Specifies that R(n) is a block parameter
 * _RETURN(n)   - Specifies that R(n) is returned from _swi.
 * 
 * The values of the macros should be ORed together to produce the value for
 * the mask.
 * 
 * The following constants are defined
 * 
 * _FLAGS       - the register containing the flags (currently 15)
 * _C           - mask for the C bit in _FLAGS
 * _Z           - mask for the Z bit in _FLAGS
 * _N           - mask for the N bit in _FLAGS
 * 
 * Example calls:
 * 
 *     _swi(OS_NewLine, 0);   // Must specify 0 register mask
 * 
 *     _swi(OS_Write0, _IN(0), "Hello, World");
 * 
 *     task_handle = _swi(Wimp_Initialise, _IN(0)|_IN(1)|_IN(2)|_RETURN(1),
 *                        300, *(int *)"TASK", "Test");
 * 
 *     e = _swix(Wimp_LoadTemplate, _IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|
 *                                  _OUT(2)|_OUT(6),
 *               template_buffer, workspace, workspace_end, -1, "MyWind", next,
 *               &workspace_end, &next);
 * 
 *     e = _swix(Wimp_SetExtent, _IN(0)|_BLOCK(1), w, minx, miny, maxx, maxy);
 */ 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3 "h.nettime"










/* Service calls */ 


/* Event stuff */ 




typedef enum { Async=1, Urgent=2, Broken=3, RarpReply=4 } internet_event_t;

/* TinyStubs */ 





/* PPP module */ 


/* Dialler */ 






typedef enum { Disconnected=1, Executing=2, ConnectedOut=4, HangingUp=8, Answering=0x10, ConnectedIn=0x20 } dialler_status_t;


/* Registry */ 
















/* Timers */ 



/*
 * State machine types
 */ 
typedef enum { Dormant, NoLink, Sleeping, Expecting } state_t;
typedef enum { Init, Die, PostInit, Response, Failure, Timer, LinkUp, LinkDown, RegistryChanged } transition_t;

/*
 * Public functions
 */ 
extern void mul64(int a1, int a2, int *result);
void machine(transition_t transition);
extern int module_timerentry(_kernel_swi_regs *r, void *pw);
extern int module_evententry(_kernel_swi_regs *r, void *pw);
extern int module_callentry(_kernel_swi_regs *r, void *pw);

/*
 * Public variables
 */ 
extern int sockno;
extern void *privateword;
#line 10 "c.machine"

/*
 * Public vars
 */ 
int sockno;


/*
 * Private function defs
 */ 
static int tryconnect(void);
static int isdialup(void);
static int settimeofday(void);
static void settimer(int duration);
static void canceltimer(void);
static void closeconnect(void);


/*
 * State machine
 *
 * Description of states:
 *	Dormant:	Waiting for other modules to load / smartcard info
 *	NoLink:		Waiting for link to come up on dial-up machine
 *	Expecting:	Waiting for socket response or failure
 *	Sleeping:	Waiting for timer callback because either:
 *			a) Successfully set the time (long Timer)
 *			b) Couldn't connect or read (short Timer), will retry
 */ 
void machine(transition_t transition)
{
  static state_t state = Dormant;
  
    ;
  
  switch(state)
  {
  case Dormant:
    switch(transition)
    {
    case PostInit:
      if (isdialup())
        state = NoLink;
      return;
      
    case LinkUp:
    case RegistryChanged:
      if (tryconnect())
        state = Expecting;
      else
      {
        settimer( (5*60*100) );
        state = Sleeping;
      }
      return;

    case Init:
    case Die:
      return;
    }
    break;
    
  case NoLink:
    switch(transition)
    {
    case LinkUp:
      if (tryconnect())
        state = Expecting;
      else
      {
        settimer( (5*60*100) );
        state = Sleeping;
      }
      return;

    case LinkDown:
    case RegistryChanged:
      return;      
    
    case Die:
      state = Dormant;
      return;      
    };
    break;      
    
  case Sleeping:
    switch(transition)
    {
    case Timer:
    case LinkUp:
    case RegistryChanged:
      if (tryconnect())
        state = Expecting;   
      else
        settimer( (5*60*100) );
      return;

    case LinkDown:
      canceltimer();
      state = NoLink;
      return;
      
    case Die:
      canceltimer();
      state = Dormant;
      return;
    };
    break;
    
  case Expecting:
    switch(transition)
    {
    case Response:
      if (settimeofday())
      {
        state = Sleeping;
        settimer( (30*60*100) );
      }
      return;

    case Failure:
      closeconnect();
      settimer( (5*60*100) );
      return;

    case LinkDown:
      closeconnect();
      state = NoLink;
      return;

    case Die:
      closeconnect();
      state = Dormant;
      return;
    };
    break;  
  }
    
;
}



/* Returns non-0 if on a dialup machine (ie PPP module present) */ 
static int isdialup(void)
{
  return(_swix( 0x4b600 ,  (1U << ( 0 )) , 0) ==  0 );
}


/* Returns non-0 if connect successfully initiated */ 
static int tryconnect(void)
{
  dialler_status_t dialler_status;
  int ipaddress, i;
  struct sockaddr_in sa;
  struct servent *service;
  
    ;

  /*
   * Ensure that if the dialler module is around to return a status,
   * the status returned is a connected status
   */ 
  if ((_swix( 0x4c6c2 ,  (1U << ( 0 )) | (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) , 0, &dialler_status) ==  0 ) &&
      ! ((( dialler_status )&(ConnectedIn|ConnectedOut))!=0) )
  {
      ;
    return 0;
  }

  /* Ask the Registry who we should contact */ 
  if (_swix( 0x4D382 ,  (1U << ( 0 )) | (1U << ( 1 )) | (1U << ( 2 )) | (( 0 ) !=  0x10 ? 1U << 31 - ( 0 ): 1U << 21) ,
             "TIME_PRIMARY" , &ipaddress, sizeof(ipaddress),
            &i) || (i != sizeof(ipaddress)))
  {
      ;
    return 0;
  }
    ;
  if (ipaddress == 0)
    return 0;

  if ((service=getservbyname("time", "tcp")) ==  0 )
  {
      ;
    return 0;
  }
  
  sa.sin_family =  2 ;
  sa.sin_port = service->s_port;
  sa.sin_addr.s_addr = ipaddress;	/* Address already in network order */ 

  /* Make a non-blocking async socket */ 
  sockno = socket( 2 ,  1 , 0);
  i=1;
  socketioctl(sockno,   ( 0x80000000 |((sizeof( int )& 0x7f )<<16)|( 'f' <<8)| 126 )  , &i);
  socketioctl(sockno,   ( 0x80000000 |((sizeof( int )& 0x7f )<<16)|( 'f' <<8)| 125 )  , &i);

    ;
  if ((connect(sockno, (struct sockaddr*) &sa, sizeof sa) < 0) &&
      (errno !=  36 ) && (errno !=  35 ))
    {
        ;
      socketclose(sockno);
      return 0;
    }

    ;
  return -1;
}


/* Returns non-zero if read server time */ 
static int settimeofday(void)
{
  int time, read;
  char ltime[8];

  if ((read = socketread(sockno, (char *) &time, 4)) < 4)
  {
    if ((read > 0) || ((errno !=  36 ) && (errno !=  35 )))
    {
        ;
      machine(Failure);					/* Note! */ 
    }





    return 0;
  }
  closeconnect();

  /* Convert time from network in seconds to host in centiseconds */ 
  time = (int) ntohl(time);
  mul64(time, 100, (int*) ltime);

  /* Set time */ 
  _swix( 0x00043047 ,  (1U << ( 0 )) , &ltime);
    ;
  
  return -1;
};


static void settimer(int duration)
{
  _swix( 0x0000003B ,  (1U << ( 0 )) | (1U << ( 1 )) | (1U << ( 2 )) ,
        duration, module_timerentry, privateword);
};


static void canceltimer(void)
{
  _swix( 0x0000003D ,  (1U << ( 0 )) | (1U << ( 1 )) , module_timerentry, privateword);
};


static void closeconnect(void)
{
    ;
  socketclose(sockno);
  sockno = -1;			/* So that we don't get any events */ 
};
