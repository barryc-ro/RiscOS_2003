#include <swis.h>

#include <sys/types.h>

#include "nettime.h"
#include "ntp.h"
#include "rtcadjust.h"
#include "extralong.h"

#define DefaultLatchValue 20000
#define MinimumLatchValue 18000
#define MaximumLatchValue 22000

static unsigned int LastMonoTime;
static int LastError;
static unsigned int LastLatchValue = DefaultLatchValue;

static int running;

#define IOC 0x03200000
#define T0LOW  (*(volatile unsigned char *)(IOC + 0x40))
#define T0HIGH (*(volatile unsigned char *)(IOC + 0x44))

static void ProgramLatch(int n)
{
    n -= 1;
    T0LOW = n;
    T0HIGH = n >> 8;
}

void rtcadjust_init()
{
    if (!running)
    {
        /* Kill the RTCAdjust module, if it's active */
        _swix(OS_Module, _INR(0,1), 4, "RTCAdjust");

        rtcadjust_initvars();
        LastLatchValue = DefaultLatchValue;
        running = 1;
    }
}

void rtcadjust_final(int fixup)
{
    if (running)
    {
        ProgramLatch(DefaultLatchValue);
        LastLatchValue = DefaultLatchValue;
        if (fixup)
            rtcadjust_fixup_hardware_rtc();
        /* Restart RTCAdjust, if in ROM */
        _swix(OS_Module, _INR(0,1), 3, "RTCAdjust");
        running = 0;
    }
}

struct riscos_time riscostime_sub(struct riscos_time a, struct riscos_time b)
{
    struct riscos_time r;

    r.l = a.l - b.l;
    r.h = a.h - b.h - (a.l < b.l);

    return r;
}

void rtcadjust_initvars()
{
    LastError = 0;
    _swix(OS_ReadMonotonicTime, _OUT(0), &LastMonoTime);
}

/*                          (P+C)       P'
 * new latch := old latch * ------ * --------
 *                            P      (P'-C+W)
 *
 * where P = Period, the requested number of cs ticks between calls
 *
 *       P' = the actual number of cs ticks since last called (different from
 *            P because of the time taken to grant the callback)
 *
 *       C  = the number of cs we are ahead of the RTC this call
 *
 *       W  = the number of cs we were ahead of the RTC last call
 */

int rtcadjust_settime(struct riscos_time *t, int P)
{
    struct riscos_time cur = current_time();
    struct riscos_time error;
    unsigned int OldMonoTime;
    int P2, C, temp;
    int was_running = running;
    int64_t N;
    int64_t temp64;

    rtcadjust_init();

    if (cur.l == 0 && cur.h == 0) return 0;

    error = riscostime_sub(cur, *t);

    C = (int) error.l;

    if ((signed char) error.h != C >> 31 ||
        abs(C) > P / 10)
    {
      immediate:
        dprintf(("rtcadjust_2", "Setting time immediately\n"));
        LastError = 0;
        /* Immediate set - not synchronised, or miles out of range */
        set_time(t);
        rtcadjust_initvars();
        return -1;
    }

    OldMonoTime = LastMonoTime;
    if (_swix(OS_ReadMonotonicTime, _OUT(0), &LastMonoTime))
        return 0;

    P2 = LastMonoTime - OldMonoTime;
    dprintf(("rtcadjust_2", "C=%d, W=%d, P=%d, P'=%d, L=%d\n", C, LastError, P, P2, LastLatchValue));

    if (P)
    {
        /* N = L * (P+C) */
        temp = P + C; if (temp < 0) temp = 0;
        mul64(LastLatchValue, temp, (u_int32_t *) &N);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }
    else
    {
        /* P=0 means P=infinity: (P+C)/P term eliminated */
        N.high = 0;
        N.low = LastLatchValue;
    }

    temp64.high = 0;
    if (was_running) /* Otherwise, P' = infinity: P'/(P'-C+W) term eliminated */
    {
        /* N = L * (P+C) * P' */
        temp64.low = P2;
        N = extralong_multiply(N, temp64);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }

    if (P)
    {
        /* N = L * (P+C) * P' / P (rounding to nearest) */
        N.low += (u_int32_t) P / 2;
        if (N.low < (u_int32_t) P / 2) N.high++;
        temp64.low = P;
        N = extralong_divide(N, temp64);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }

    if (was_running) /* Otherwise, P' = infinity */
    {
        /* N = L * (P+C) * P' / P / (P' - (C-W)) (rounding to nearest) */
        temp64.low = P2 - ((int32_t) C - (int32_t) LastError);
        if ((int32_t) temp64.low <= 1) temp64.low = 1;
        N.low += temp64.low / 2;
        if (N.low < temp64.low / 2) N.high++;
        N = extralong_divide(N, temp64);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }
    LastError = C;

    if (N.high != 0)
        goto immediate;

    if (N.low < MinimumLatchValue)
        N.low = MinimumLatchValue;
    else if (N.low > MaximumLatchValue)
        N.low = MaximumLatchValue;

    LastLatchValue = (unsigned int) N.low;
    ProgramLatch(LastLatchValue);

    dprintf(("rtcadjust_2", "New latch value = %d\n", LastLatchValue));

    return -1;
}

void rtcadjust_fixup_hardware_rtc()
{
    struct riscos_time cur;

    /* Nasty little fudge - we're messing with the latch, which affects
     * the software copy of the RTC, but if we have a hardware RTC it
     * could be doing anything. This will resync the hardware RTC to
     * the soft copy.
     *
     * We don't want to do this too often, as it's liable to muck up
     * our carefully synced time. Especially on old Kernels where the
     * centiseconds are brutally set to zero.
     */
    cur = current_time();
    set_time(&cur);
}

void rtcadjust_print_status()
{
    if (running)
    {
        unsigned int time, error;
        _swix(OS_ReadMonotonicTime, _OUT(0), &time);
        time -= LastMonoTime;
        error = abs(LastError);
        printf("Last adjustment: %d second%s ago\n", time / 100, time / 100 == 1 ? "" : "s");
        printf("Last error:      %d.%02d seconds%s\n", error / 100, error % 100,
                  LastError < 0 ? " slow" : LastError > 0 ? " fast" : "");
    }
    printf(    "Poll period:     %d seconds\n", LONG_TIMER / 100);
    printf(    "Timer latch:     %d\n", LastLatchValue);
}

void rtcadjust_suspend()
{
    rtcadjust_final(1);
}
