#include <swis.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include "nettime.h"
#include "ntp.h"
#include "rtcadjust.h"
#include "extralong.h"

/* Maximum 1% (10000ppm) slew */
#define DefaultLatchValue 20000
#define MinimumLatchValue 19800
#define MaximumLatchValue 20200

static unsigned int LastMonoTime;
static int LastError;
static unsigned int LastLatchValue = DefaultLatchValue;

static int running;

#define IOC 0x03200000
#define T0LOW  (*(volatile unsigned char *)(IOC + 0x40))
#define T0HIGH (*(volatile unsigned char *)(IOC + 0x44))

static void ProgramLatch(int n)
{
    LastLatchValue = n;
    n -= 1;
    T0LOW = n;
    T0HIGH = n >> 8;
}

void rtcadjust_init()
{
    if (!running)
    {
        /* Kill the RTCAdjust module, if it's active */
        _swix(OS_Module, _INR(0,1), 4, "RTCAdjust");

        rtcadjust_initvars();
        LastLatchValue = DefaultLatchValue;
        running = 1;
    }
}

void rtcadjust_final(int fixup)
{
    if (running)
    {
        ProgramLatch(DefaultLatchValue);
        if (fixup)
            rtcadjust_fixup_hardware_rtc();
        /* Restart RTCAdjust, if in ROM */
        _swix(OS_Module, _INR(0,1), 3, "RTCAdjust");
        running = 0;
    }
}

struct riscos_time riscostime_sub(struct riscos_time a, struct riscos_time b)
{
    struct riscos_time r;

    r.l = a.l - b.l;
    r.h = a.h - b.h - (a.l < b.l);

    return r;
}

void rtcadjust_initvars()
{
    LastError = 0;
    _swix(OS_ReadMonotonicTime, _OUT(0), &LastMonoTime);
}

/*                          (P+C)       P'
 * new latch := old latch * ------ * --------
 *                            P      (P'-C+W)
 *
 * where P = Period, the requested number of cs ticks between calls
 *
 *       P' = the actual number of cs ticks since last called (different from
 *            P because of the time taken to grant the callback)
 *
 *       C  = the number of cs we are ahead of the RTC this call
 *
 *       W  = the number of cs we were ahead of the RTC last call
 */

int rtcadjust_settime(struct riscos_time *t, int P)
{
    struct riscos_time cur = current_time();
    struct riscos_time error;
    unsigned int OldMonoTime;
    int P2, C, temp;
    int was_running = running;
    int64_t N;
    int64_t temp64;

    rtcadjust_init();

    if (cur.l == 0 && cur.h == 0) return 0;

    error = riscostime_sub(cur, *t);

    /* If P is too small, we go all wobbly. Clamp it */
    if (P < 60 * 100)
        P = 60 * 100;

    C = (int) error.l;

    if ((signed char) error.h != C >> 31 ||
        abs(C) > P / 100)
    {
      immediate:
        dprintf(("rtcadjust_2", "Setting time immediately\n"));
        LastError = 0;
        /* Immediate set - not synchronised, or miles out of range */
        set_time(t);
        ProgramLatch(DefaultLatchValue);
        rtcadjust_initvars();
        return -1;
    }

    OldMonoTime = LastMonoTime;
    if (_swix(OS_ReadMonotonicTime, _OUT(0), &LastMonoTime))
        return 0;

    P2 = LastMonoTime - OldMonoTime;
    dprintf(("rtcadjust_2", "C=%d, W=%d, P=%d, P'=%d, L=%d\n", C, LastError, P, P2, LastLatchValue));

    if (P)
    {
        /* N = L * (P+C) */
        temp = P + C; if (temp < 0) temp = 0;
        mul64(LastLatchValue, temp, (u_int32_t *) &N);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }
    else
    {
        /* P=0 means P=infinity: (P+C)/P term eliminated */
        N.high = 0;
        N.low = LastLatchValue;
    }

    temp64.high = 0;
    if (was_running) /* Otherwise, P' = infinity: P'/(P'-C+W) term eliminated */
    {
        /* N = L * (P+C) * P' */
        temp64.low = P2;
        N = extralong_multiply(N, temp64);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }

    if (P)
    {
        /* N = L * (P+C) * P' / P (rounding to nearest) */
        N.low += (u_int32_t) P / 2;
        if (N.low < (u_int32_t) P / 2) N.high++;
        temp64.low = P;
        N = extralong_divide(N, temp64);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }

    if (was_running) /* Otherwise, P' = infinity */
    {
        /* N = L * (P+C) * P' / P / (P' - (C-W)) (rounding to nearest) */
        temp64.low = P2 - ((int32_t) C - (int32_t) LastError);
        if ((int32_t) temp64.low <= 1) temp64.low = 1;
        N.low += temp64.low / 2;
        if (N.low < temp64.low / 2) N.high++;
        N = extralong_divide(N, temp64);
        dprintf(("rtcadjust_5", "N=&%08X%08X\n", N.high, N.low));
    }
    LastError = C;

    if (N.high != 0)
        goto immediate;

    if (N.low < MinimumLatchValue)
        N.low = MinimumLatchValue;
    else if (N.low > MaximumLatchValue)
        N.low = MaximumLatchValue;

    ProgramLatch((unsigned int) N.low);

    dprintf(("rtcadjust_2", "New latch value = %d\n", LastLatchValue));

    return -1;
}

void rtcadjust_fixup_hardware_rtc()
{
    struct riscos_time cur;

    /* Nasty little fudge - we're messing with the latch, which affects
     * the software copy of the RTC, but if we have a hardware RTC it
     * could be doing anything. This will resync the hardware RTC to
     * the soft copy.
     *
     * We don't want to do this too often, as it's liable to muck up
     * our carefully synced time. Especially on old Kernels where the
     * centiseconds are brutally set to zero.
     */
    cur = current_time();
    set_time(&cur);
}

static char *pretty_interval(unsigned int t)
{
    static char buffer[128];
    int n = 0;
    unsigned int days, hours, minutes, seconds;

    seconds = t % 60; t /= 60;
    minutes = t % 60; t /= 60;
    hours   = t % 24; t /= 24;
    days    = t;

    if (days)
        n += sprintf(buffer + n, "%d day%s ", days, days == 1 ? "" : "s");
    if (hours)
        n += sprintf(buffer + n, "%d hour%s ", hours, hours == 1 ? "" : "s");
    if (minutes)
        n += sprintf(buffer + n, "%d minute%s ", minutes, minutes == 1 ? "" : "s");
    if (seconds || n == 0)
        n += sprintf(buffer + n, "%d second%s ", seconds, seconds == 1 ? "" : "s");

    buffer[n - 1] = '\0'; /* Remove trailing space */

    return buffer;
}

void rtcadjust_print_status()
{
    if (running)
    {
        unsigned int time, error;
        _swix(OS_ReadMonotonicTime, _OUT(0), &time);
        time -= LastMonoTime;
        error = abs(LastError);
        printf("Last adjustment: %s ago\n", pretty_interval(time/100));
        printf("Last error:      %d.%02d seconds%s\n", error / 100, error % 100,
                  LastError < 0 ? " slow" : LastError > 0 ? " fast" : "");
    }
    if (last_server.s_addr != 0)
    {
        struct hostent *hp = gethostbyaddr((char *) &last_server, sizeof last_server, AF_INET);
        printf("Last server:     %s\n", hp ? hp->h_name : inet_ntoa(last_server));
        if (last_protocol)
            printf("Last protocol:   %s\n", last_protocol == PORT_NTP ? "SNTP" : "Time/UDP");
    }
    if (poll_period)
        printf("Poll interval:   %s\n", pretty_interval(poll_period / 100));
    printf(    "Timer latch:     %d", LastLatchValue);
    if (LastLatchValue != DefaultLatchValue)
    {
        #if DefaultLatchValue != 20000
        #error Someone sort this maths out
        #endif
        /* Currently expressed as an adjustment to crystal time - this is not the same
         * as our deviation from "real" time.
         */
        printf(" (%c%dppm)\n", LastLatchValue > DefaultLatchValue ? '-' : '+',
                               abs(DefaultLatchValue - LastLatchValue) * 50);
    }
    else
        putchar('\n');
}

void rtcadjust_suspend()
{
    rtcadjust_final(1);
}
