#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>

#include <swis.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>

#include <socklib.h>
#include <inetlib.h>
#include <unixlib.h>

#include "nettime.h"
#include "ntp.h"

/* Our clock has a 1/100s resolution (precision = -6.64) */
#define PRECISE_BITS       6                /* All possible values of these bits are used */
#define PRECISE_MASK       0xFC000000
#define SIGNIFICANT_BITS   7                /* All possible times can be set using these bits */
#define SIGNIFICANT_MASK   0xFE000000
#define INSIGNIFICANT_BITS 25               /* These bits are not required */
#define INSIGNIFICANT_MASK 0x01FFFFFF
#define RANDOMISE_BITS     24               /* These bits can be randomised */
#define RANDOMISE_MASK     0x00FFFFFF

extern struct ntp_time ntp_add(struct ntp_time, struct ntp_time);
extern struct ntp_time ntp_sub(struct ntp_time, struct ntp_time);
extern struct ntp_time ntp_div2(struct ntp_time);

int32_t rand32()
{
    return (int32_t) rand() ^ ((int32_t) rand() << 16);
}

const char *riscos_to_text(struct riscos_time t, int precise)
{
    static char buffer[64];
    char *p;

    /* Null NTP value 00000000.00000000 maps to RISC OS time 6400000000 */
    if (t.l == 0 && t.h == 0x64 && t.extrans == 0)
        return "<none>";

    _swix(Territory_ConvertDateAndTime, _INR(0,4)|_OUT(1), -1, &t, buffer, sizeof buffer,
                                        "%we, %zdy %mo %ce%yr %24:%mi:%se.%cs", &p);
    if (precise)
        sprintf(p, "%07ld", t.extrans);

    return buffer;
}

struct riscos_time ntp_to_riscos(struct ntp_time n)
{
    struct riscos_time t;
    u_int32_t micro2[2];
    u_int32_t cs;
    mul64(n.secs, 100, &t.l);

    /* Add in fudge for timestamp wrap in 2036 (RFC 2030 section 3).
     * This gives us a representable range of dates from 20 Jan 1968 to 26 Feb 2104.
     * (RISC OS allows 1 Jan 1900 to 3 Jun 2248).
     */
    if ((n.secs & 0x80000000) == 0)
        t.h += 100;

    /* micro2[1] := fraction of second in ns units */
    mul64(n.frac, 1000000000, micro2);

    /* Round to nearest */
    if (micro2[0] & 0x80000000)
        micro2[1]++;

    cs = micro2[1] / 10000000;
    t.extrans = micro2[1] % 10000000;

    t.l += cs;
    if (t.l < cs) t.h++;

    return t;
}

/* r[1,0] := a[1,0] / b; a being a 64-bit number, and r being 32.32 fixed point
 * least-significant word first.
 */
static void divfrac(u_int32_t *a, u_int32_t b, u_int32_t *r)
{
    u_int32_t n, f;
    int i, j;

    n = a[1];
    f = a[0];

    n -= (n/b) * b; /* Remove overflow */

    for (j=1; j >=0; j--)
    {
        r[j] = 0;
        for (i=31; i >= 0; i--)
        {
            n = (n << 1) + ((f & 0x80000000) ? 1 : 0);
            f <<= 1;
            if (n >= b)
            {
                n -= b;
                r[j] |= (1ul << i);
            }
        }
    }
}

struct ntp_time riscos_to_ntp(struct riscos_time t)
{
    struct ntp_time n;
    u_int32_t c[2], r[2];

    /* Range check: NTP allows times from 0x80000000.00000000 to 0x7FFFFFFF.FFFFFFFF.
     * (20 Jan 1968 04:14:08 to 26 Feb 2104 10:42:23).
     * This corresponds to the set of RISC OS times 0x3200000000-0x95FFFFFFFF.
     */
    if (t.h < 0x32 || t.h >= 0x96)
    {
        /* Return null time for out of range */
        n.secs = n.frac = 0;
        return n;
    }

    /* Times 0x6400000000-0x95FFFFFFFF map to 00000000.00000000-7FFFFFFF.FFFFFFFF.
     * Handle this by mapping down to 0x0000000000-0x31FFFFFFFF before dividing.
     */
    if (t.h >= 0x64)
        t.h -= 0x64;

    c[1] = t.h;
    c[0] = t.l;

    divfrac(c, 100, r);
    n.secs = r[1];
    n.frac = r[0];

    if (t.extrans)
    {
        struct ntp_time x;
        c[1] = t.extrans;
        c[0] = 0;
        divfrac(c, 1000000000, r);

        x.secs = 0;
        x.frac = r[1];
        if (r[0] & 0x80000000) x.frac++; /* Round to nearest */
        n = ntp_add(n, x);
    }

    return n;
}

bool ntp_is_null(struct ntp_time n)
{
    return n.secs == 0 && n.frac == 0;
}

struct ntp_time ntp_null;

void randomise_ntp(struct ntp_time *n)
{
    if (!ntp_is_null(*n))
    {
        struct ntp_time r;
        r.frac = rand32() >> (32 - RANDOMISE_BITS);      /* Arithmetic shift (ta Norcroft) */
        r.secs = (r.frac & 0x80000000) ? 0xFFFFFFFF : 0; /* Sign extend upwards */
        *n = ntp_add(*n, r);
    }
}

struct riscos_time current_time(void)
{
    struct riscos_time t;

    t.extrans = 0;
    t.l = 3;
    if (_swix(OS_Word, _INR(0,1), 14, &t))
        t.l = t.h = 0;

    return t;
}

struct ntp_time ntp_ntoh(struct ntp_time t)
{
    t.secs = ntohl(t.secs);
    t.frac = ntohl(t.frac);
    return t;
}

#define ntp_hton ntp_ntoh

const char *ntp_to_text(struct ntp_time t)
{
    return riscos_to_text(ntp_to_riscos(t), 1);
}

struct riscos_time round_riscos_time(struct riscos_time t)
{
    if (t.extrans >= 5000000)
    {
        if (++t.l == 0)
           ++t.h;
    }
    t.extrans = 0;

    return t;
}

_kernel_oserror *ntp_set_time(struct riscos_time t)
{
    t = round_riscos_time(t);

    return set_time(&t);
}

size_t ntp_construct_request(struct ntp *n, size_t len)
{
      memset(n, 0, len);
      n->flags = (3 << 3) | 3; /* Version 3, mode 3 (client) */
      n->transmit_timestamp = riscos_to_ntp(current_time());
      randomise_ntp(&n->transmit_timestamp);
      n->transmit_timestamp = ntp_hton(n->transmit_timestamp);

      return sizeof(struct ntp);
}

int ntp_process_reply(const struct ntp *n, size_t len, struct riscos_time *time_out)
{
    struct ntp_time destination_timestamp;
    struct ntp_time offset, correct;
    int VN, LI, mode;

    destination_timestamp = riscos_to_ntp(current_time());

    LI = n->flags >> 6;
    VN = (n->flags >> 3) & 7;
    mode = n->flags & 7;

    /*printf("Current time = %s\n", riscos_to_text(current_time(), 1));*/

    /* Basic validity checks, as per RFC 2030 */
    if (len < sizeof(struct ntp) ||
        LI == 3 || VN != 3 || mode != 4 ||
        (n->stratum < 1 || n->stratum > 14) ||
        (ntp_is_null(ntp_ntoh(n->transmit_timestamp))))
        return 0;

    if (ntp_is_null(ntp_ntoh(n->originate_timestamp)))
    {
        offset = ntp_null;
        correct = ntp_ntoh(n->transmit_timestamp);
    }
    else
    {
        offset = ntp_add(ntp_div2(ntp_sub(ntp_ntoh(n->receive_timestamp), ntp_ntoh(n->originate_timestamp))),
                         ntp_div2(ntp_sub(ntp_ntoh(n->transmit_timestamp), destination_timestamp))
                        );

        correct = ntp_add(riscos_to_ntp(current_time()), offset);
    }

    /*printf("Current time = %s\n", riscos_to_text(current_time(), 1));
    printf("Offset=%08lX.%08lX\n"
           "Correct=%s\n", offset.secs, offset.frac, ntp_to_text(correct));
    printf("Rounded=%s\n", riscos_to_text(round_riscos_time(ntp_to_riscos(correct))));

    printf("Originate Timestamp=%s\n", ntp_to_text(ntp_ntoh(n->originate_timestamp)));
    printf("Receive Timestamp  =%s\n", ntp_to_text(ntp_ntoh(n->receive_timestamp)));
    printf("Transmit Timestamp =%s\n", ntp_to_text(ntp_ntoh(n->transmit_timestamp)));
    printf("Destina'n Timestamp=%s\n", ntp_to_text(destination_timestamp));
    printf("\n");*/

    *time_out = ntp_to_riscos(correct);

    return -1;
}
