#include "socklib.h"
#include "inetlib.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#pragma -d0		/* Suppress winges about K&R-style declarations */
#include "netdb.h"
#pragma -d1

#include "nettime.h"
#include "nt_nvram.h"
#include "header.h"
#include "dns.h"
#include "edst.h"
#include <string.h>

/*
 * Public vars
 */
int sockno;
char env_time_server[MAX_ENV_TIME_SERVER];
struct sockaddr_in sockaddr;

#ifdef DEBUGLIB
char inet_resolvers[128];
#endif

#ifdef DEBUGLIB
/* State and transition names for debug output - keep these in step with definitions
 * in nettime.h
 */
char *states[] = {"Dormant", "NoLink", "Sleeping", "Expecting", "DNSWait"};
char *transitions[] = {"NoTrans", "Init", "Die", "PostInit", "Response", "Failure", "Timer", "LinkUp", "LinkDown", "RegistryChanged", "DoDNS"};

#define STATENAME(i) ((((i) < 0) || ((i) > sizeof(states)/sizeof(char *))) ? \
			"Invalid state" : states[i])

#define TRANSNAME(i) ((((i) < 0) || ((i) > sizeof(transitions)/sizeof(char *))) ? \
			"Invalid transition" : transitions[i])

#endif

/*
 * Private function defs
 */
static int tryresolve(struct sockaddr_in *sa);
static int tryconnect(struct sockaddr_in *sa);
static int isdialup(void);
static int local_settimeofday(void);
static void settimer(int duration);
static void canceltimer(void);
static void closeconnect(void);


/*
 * State machine
 *
 * Description of states:
 *	Dormant:	Waiting for other modules to load / smartcard info
 *	NoLink:		Waiting for link to come up on dial-up machine
 *	DNSWait:	Waiting for DNS lookup of time server host name
 *	Expecting:	Waiting for socket response or failure
 *	Sleeping:	Waiting for timer callback because either:
 *			a) Successfully set the time (long Timer)
 *			b) Couldn't connect or read (short Timer), will retry
 */
void machine(transition_t transition)
{
  static state_t state = Dormant;
  transition_t next_trans;
  int status;

  for (; transition != NoTrans; transition = next_trans)
  {
    dprintf(("debug", "State %d (%s), transition %d (%s)\n",
    	state, STATENAME(state), transition, TRANSNAME(transition)));

    /* There is no "next transition" unless set whilst handling current transition */
    next_trans = NoTrans;

    switch(state)
    {
    case Dormant:
      switch(transition)
      {
        case PostInit:
        if (isdialup())
          state = NoLink;
        continue;

      case LinkUp:
      case RegistryChanged:
        next_trans = DoDNS;
        state = DNSWait;
        continue;

      case Init:
      case Die:
      case LinkDown:
        continue;
      }
      break;

    case NoLink:
      switch(transition)
      {
      case LinkUp:
        next_trans = DoDNS;
        state = DNSWait;
        continue;

      case LinkDown:
      case RegistryChanged:
        continue;

      case Die:
        state = Dormant;
        continue;
      }
      break;

    case Sleeping:
      switch(transition)
      {
      case Timer:
      case LinkUp:
      case RegistryChanged:
        next_trans = DoDNS;
        state = DNSWait;
        continue;

      case LinkDown:
        canceltimer();
        state = NoLink;
        continue;

      case Die:
        canceltimer();
        state = Dormant;
        continue;
      }
      break;

    case DNSWait:
      switch(transition)
      {
      case DoDNS:
      case Timer:
        status = tryresolve(&sockaddr);
        switch (status)
        {
          case EINPROGRESS:
            /* Resolve in progress - poll again shortly */
	    settimer(POLL_TIMER);
            continue;

          case 0:
	    /* Resolve complete - connect to server */
            if (tryconnect(&sockaddr))
              state = Expecting;
            else {
              settimer(SHORT_TIMER);
              state = Sleeping;
            }
            continue;

	  default:
            /* Resolve failed - retry later */
	    settimer(SHORT_TIMER);
	    state = Sleeping;
	    continue;
        }

      case LinkDown:
        canceltimer();
        state = NoLink;
        continue;

      case Die:
        canceltimer();
        state = Dormant;
        continue;

      case RegistryChanged:
        /* Registry changed whilst waiting for DNS completion.  Stop poll timer
         * and try again with (possibly) new timeserver.
         */
        canceltimer();
        next_trans = DoDNS;
        continue;
      }
      break;

    case Expecting:
      switch(transition)
      {
      case Response:
        if (local_settimeofday())
        {
#ifdef PERIODICAL_TIME_CHECKS
          state = Sleeping;
          settimer(LONG_TIMER);
#else
          state = Dormant;
#endif
        }
        continue;

      case Failure:
        closeconnect();
        settimer(SHORT_TIMER);
        continue;

      case LinkDown:
        closeconnect();
        state = NoLink;
        continue;

      case Die:
        closeconnect();
        state = Dormant;
        continue;
      }
      break;

    } /* end of switch(state) */

    dprintf(("debug", "Bogus state/transition combo: state=%d, transition=%d\n",
    	     state, transition));

  } /* for (; transition != NoTrans; transition = next_trans) */

  dprintf(("debug", "Machine resting in state=%d\n", state));
}



/* Returns non-0 if on a dialup machine (ie PPP module present) */
static int isdialup(void)
{
  return(_swix(PPP_DCIVersion, _IN(0), 0) == NULL);
}

/* tryresolve()
 *   Try to resolve the TimeServer hostname to an IP address.
 *   The hostname is read from the system variable "NetTime$Server"
 *   if set, or the smart card tag "TIME_PRIMARY" otherwise.
 *
 * Returns:
 *   0		 - Address resolved, result in 'sockaddr'.
 *   EINPROGRESS - DNS lookup in progress; waiting for response.  To
 *                 collect the response this routine should be
 *                 polled on a timer until it returns 0 or another
 *                 error.
 *   Otherwise	 - Request failed.
 *
 */
static int tryresolve(struct sockaddr_in *sockaddr)
{
  dialler_status_t dialler_status;
  int ipaddress, i;
  int status;

  /*
   * Ensure that if the dialler module is around to return a status,
   * the status returned is a connected status
   */
  if ((_swix(Dialler_Status, _IN(0)|_OUT(0), 0, &dialler_status) == NULL) &&
      !CONNECTED(dialler_status))
  {
    dprintf(("debug", "Dialler bailed! r0=%x\n", dialler_status));
    return -1;
  }
  dprintf(("debug", "checking environment variable %s\n", ENV_TIME_SERVER));

  if(read_os_var(ENV_TIME_SERVER, env_time_server, MAX_ENV_TIME_SERVER)>0) { /* we have a configured time server */
    dprintf(("debug", "read environment variable: %s\n", env_time_server));
  } else {

      /* Ask the Registry who we should contact */
      if (_swix(NCAccessManager_Enquiry, _INR(0,2)|_OUT(0),
                NCRegistry_TimeServerTag, env_time_server, MAX_ENV_TIME_SERVER,
                &i))
      {
        dprintf(("debug", "NCAccessManager bailed! r0=%x\n", i));
        return -1;
      }

      if(i == 4) { /* packed IP address */
        ipaddress = *(int *)env_time_server;
        dprintf(("debug", "NCAccessManager says timeserver IP address is %08x\n", ipaddress));
        if (ipaddress == 0) return 0;
        sockaddr->sin_addr.s_addr = ipaddress; /* address already in network order */
        return 0; /* complete */
      } else {
        dprintf(("debug", "NCAccessManager says timeserver host is %s\n", env_time_server));
      }
  }

#ifdef DEBUGLIB
  if (read_os_var("Inet$Resolvers", inet_resolvers, sizeof(inet_resolvers)) > 0)
    dprintf(("debug", "Inet$Resolvers: %s\n", inet_resolvers));
  else
    dprintf(("debug", "Inet$Resolvers not set!\n"));
#endif


  /*  Lookup server as a dot-quad IP string or hostname.
   */
  status = dns_find_ip_address(env_time_server, &sockaddr->sin_addr);
  if (status == EINPROGRESS) {
    dprintf(("debug", "tryresolve: DNS says EINPROGRESS\n"));
  } else if (status == 0) {
    dprintf(("debug", "tryresolve: DNS says done\n"));
  } else {
    dprintf(("debug", "tryresolve: DNS says failed (status = %d)\n", status));
  }

  return status;
}


/* Returns non-0 if connect successfully initiated */
static int tryconnect(struct sockaddr_in *sa)
{
  dialler_status_t dialler_status;
  int i;
  struct servent *service;

  /*
   * Ensure that if the dialler module is around to return a status,
   * the status returned is a connected status
   */
  if ((_swix(Dialler_Status, _IN(0)|_OUT(0), 0, &dialler_status) == NULL) &&
      !CONNECTED(dialler_status))
  {
    dprintf(("debug", "Dialler bailed! r0=%x\n", dialler_status));
    return -1;
  }

  dprintf(("debug", "trying to connect\n"));

  dprintf(("debug", "Using time server 0x%x\n", (int)sa->sin_addr.s_addr));

  if ((service=getservbyname("time", "tcp")) == NULL)
  {
    dprintf(("debug", "Can't find service time/tcp\n"));
    return 0;
  }

  sa->sin_family = AF_INET;
  sa->sin_port = service->s_port;

  /* Make a non-blocking async socket */
  sockno = socket(AF_INET, SOCK_STREAM, 0);
  i=1;
  socketioctl(sockno, FIONBIO, &i);
  socketioctl(sockno, FIOASYNC, &i);

  dprintf(("debug", "Connecting\n"));
  if ((connect(sockno, (struct sockaddr*) sa, sizeof *sa) < 0) &&
      (errno != EINPROGRESS) && (errno != EWOULDBLOCK))
    {
      dprintf(("debug", "Connect error %d\n", errno));
      socketclose(sockno);
      return 0;
    }

  dprintf(("debug", "Connect initiated on socket %d\n", sockno));
  return -1;
}


/* Returns non-zero if read server time */
static int local_settimeofday(void)
{
  int time, read;
  char ltime[8];

  if ((read = socketread(sockno, (char *) &time, 4)) < 4)
  {
    if ((read > 0) || ((errno != EINPROGRESS) && (errno != EWOULDBLOCK)))
    {
      dprintf(("debug", "Connect error %d\n", errno));
      machine(Failure);					/* Note! */
    }
    else
    {
      dprintf(("debug", "Read still in progress\n"));
    }

    return 0;
  }
  closeconnect();

  /* Convert time from network in seconds to host in centiseconds */
  time = (int) ntohl(time);
  nvram_settime(time);
  mul64(time, 100, (int*) ltime);

  /* Set time */
  _swix(Territory_SetTime, _IN(0), &ltime);
  dprintf(("debug", "Set time!\n"));

#ifdef EUROPEAN_DST_BODGE
  if (edst_isdst(ltime))
      nvram_set_dst(1);
  else
      nvram_set_dst(0);
#endif

  return -1;
}


static void settimer(int duration)
{
  _swix(OS_CallAfter, _INR(0,2),
        duration, module_timerentry, privateword);
}


static void canceltimer(void)
{
  _swix(OS_RemoveTickerEvent, _INR(0,1), module_timerentry, privateword);
}


static void closeconnect(void)
{
  dprintf(("debug", "Closing socket %d\n", sockno));
  socketclose(sockno);
  sockno = -1;			/* So that we don't get any events */
}
