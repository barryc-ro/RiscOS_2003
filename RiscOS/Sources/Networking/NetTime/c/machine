#include "socklib.h"
#include "inetlib.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#pragma -d0		/* Suppress winges about K&R-style declarations */
#include "netdb.h"
#pragma -d1

#include "nettime.h"

/*
 * Public vars
 */
int sockno;


/*
 * Private function defs
 */
static int tryconnect(void);
static int isdialup(void);
static int local_settimeofday(void);
static void settimer(int duration);
static void canceltimer(void);
static void closeconnect(void);


/*
 * State machine
 *
 * Description of states:
 *	Dormant:	Waiting for other modules to load / smartcard info
 *	NoLink:		Waiting for link to come up on dial-up machine
 *	Expecting:	Waiting for socket response or failure
 *	Sleeping:	Waiting for timer callback because either:
 *			a) Successfully set the time (long Timer)
 *			b) Couldn't connect or read (short Timer), will retry
 */
void machine(transition_t transition)
{
  static state_t state = Dormant;
  
  DEBUGFN(printf("State:%d, transition %d\n", state, transition));
  
  switch(state)
  {
  case Dormant:
    switch(transition)
    {
    case PostInit:
      if (isdialup())
        state = NoLink;
      return;
      
    case LinkUp:
    case RegistryChanged:
      if (tryconnect())
        state = Expecting;
      else
      {
        settimer(SHORT_TIMER);
        state = Sleeping;
      }
      return;

    case Init:
    case Die:
      return;
    }
    break;
    
  case NoLink:
    switch(transition)
    {
    case LinkUp:
      if (tryconnect())
        state = Expecting;
      else
      {
        settimer(SHORT_TIMER);
        state = Sleeping;
      }
      return;

    case LinkDown:
    case RegistryChanged:
      return;      
    
    case Die:
      state = Dormant;
      return;      
    };
    break;      
    
  case Sleeping:
    switch(transition)
    {
    case Timer:
    case LinkUp:
    case RegistryChanged:
      if (tryconnect())
        state = Expecting;   
      else
        settimer(SHORT_TIMER);
      return;

    case LinkDown:
      canceltimer();
      state = NoLink;
      return;
      
    case Die:
      canceltimer();
      state = Dormant;
      return;
    };
    break;
    
  case Expecting:
    switch(transition)
    {
    case Response:
      if (local_settimeofday())
      {
        state = Sleeping;
        settimer(LONG_TIMER);
      }
      return;

    case Failure:
      closeconnect();
      settimer(SHORT_TIMER);
      return;

    case LinkDown:
      closeconnect();
      state = NoLink;
      return;

    case Die:
      closeconnect();
      state = Dormant;
      return;
    };
    break;  
  }
  DEBUGFN(printf("Bogus state/transition combo: state=%d, transition=%d\n",
          state, transition));
}



/* Returns non-0 if on a dialup machine (ie PPP module present) */
static int isdialup(void)
{
  return(_swix(PPP_DCIVersion, _IN(0), 0) == NULL);
}


/* Returns non-0 if connect successfully initiated */
static int tryconnect(void)
{
  dialler_status_t dialler_status;
  int ipaddress, i;
  struct sockaddr_in sa;
  struct servent *service;
  
  DEBUGFN(printf("trying to connect\n"));

  /*
   * Ensure that if the dialler module is around to return a status,
   * the status returned is a connected status
   */
  if ((_swix(Dialler_Status, _IN(0)|_OUT(0), 0, &dialler_status) == NULL) &&
      !CONNECTED(dialler_status))
  {
    DEBUGFN(printf("Dialler bailed! r0=%x\n", dialler_status));
    return 0;
  }

  /* Ask the Registry who we should contact */
  if (_swix(NCRegistry_Enquiry, _IN(0)|_IN(1)|_IN(2)|_OUT(0),
            NCRegistry_TimeServerTag, &ipaddress, sizeof(ipaddress),
            &i) || (i != sizeof(ipaddress)))
  {
    DEBUGFN(printf("NCRegistry bailed! r0=%x\n", i));
    return 0;
  }
  DEBUGFN(printf("NCRegistry says timeserver is %08x\n", ipaddress));
  if (ipaddress == 0)
    return 0;

  if ((service=getservbyname("time", "tcp")) == NULL)
  {
    DEBUGFN(printf("Can't find service time/tcp\n"));
    return 0;
  }
  
  sa.sin_family = AF_INET;
  sa.sin_port = service->s_port;
  sa.sin_addr.s_addr = ipaddress;	/* Address already in network order */

  /* Make a non-blocking async socket */
  sockno = socket(AF_INET, SOCK_STREAM, 0);
  i=1;
  socketioctl(sockno, FIONBIO, &i);
  socketioctl(sockno, FIOASYNC, &i);

  DEBUGFN(printf("Connecting\n"));
  if ((connect(sockno, (struct sockaddr*) &sa, sizeof sa) < 0) &&
      (errno != EINPROGRESS) && (errno != EWOULDBLOCK))
    {
      DEBUGFN(printf("Connect error %d\n", errno));
      socketclose(sockno);
      return 0;
    }

  DEBUGFN(printf("Connect initiated on socket %d\n", sockno));
  return -1;
}


/* Returns non-zero if read server time */
static int local_settimeofday(void)
{
  int time, read;
  char ltime[8];

  if ((read = socketread(sockno, (char *) &time, 4)) < 4)
  {
    if ((read > 0) || ((errno != EINPROGRESS) && (errno != EWOULDBLOCK)))
    {
      DEBUGFN(printf("Conect error %d\n", errno));
      machine(Failure);					/* Note! */
    }
#ifdef DEBUG
    else
      printf("Read still in progress\n");
#endif

    return 0;
  }
  closeconnect();

  /* Convert time from network in seconds to host in centiseconds */
  time = (int) ntohl(time);
  mul64(time, 100, (int*) ltime);

  /* Set time */
  _swix(Territory_SetTime, _IN(0), &ltime);
  DEBUGFN(printf("Set time!\n"));
  
  return -1;
}


static void settimer(int duration)
{
  _swix(OS_CallAfter, _IN(0)|_IN(1)|_IN(2),
        duration, module_timerentry, privateword);
}


static void canceltimer(void)
{
  _swix(OS_RemoveTickerEvent, _IN(0)|_IN(1), module_timerentry, privateword);
}


static void closeconnect(void)
{
  DEBUGFN(printf("Closing socket %d\n", sockno));
  socketclose(sockno);
  sockno = -1;			/* So that we don't get any events */
}
