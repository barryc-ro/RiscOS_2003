#include "nettime.h"
#include "nt_nvram.h"
#include "header.h"

static _kernel_oserror *TinyError, *err;
static grabbed_event = 0;
static transition_t callback_reason;
void *privateword;

void setcallback(transition_t reason, void *pw);


_kernel_oserror *module_init(const char *cmd_tail, int podule, void *pw)
{

  int time;
  char ltime[8];

  /* Try to use TinyStubs if possible. */
  TinyError = _swix( TinySupport_Share, _IN(0), pw );

  /* Initialise DebugLib (if DEBUGLIB defined)
   */
  debug_initialise("NetTime", "izipfs:$.netlog", "");
/*  debug_initialise_trace(FILE_OUTPUT, ""); */
  debug_atexit();
  debug_output_device(FILE_OUTPUT);

  privateword = pw;
  /* Enable and claim internet event */
  if (!grabbed_event)
  {
    if ((err = _swix(OS_Claim, _INR(0,2),
        EventV, module_evententry, pw)) != NULL)
      return err;

    if ((err = _swix(OS_Byte, _INR(0,1), Event_Enable, Internet_Event)) != NULL)
    {
      _swix(OS_Release, _INR(0,2), EventV, module_evententry, pw);
      return err;
    };
    grabbed_event = -1;
  }

  time = nvram_gettime(); /* get last stored time in seconds, host byte order */

  if (time) {
    mul64(time, 100, (int *)ltime); /* convert to centiseconds */
    _swix(Territory_SetTime, _IN(0), ltime); /* set time */
  }

  machine(Init);

  return NULL;
}


_kernel_oserror *module_final(int fatal, int podule, void *pw)
{
  machine(Die);

  if ( TinyError == NULL )
    _swix( TinySupport_Die, 0 );

  /* Disable and release internet event */
  _swix(OS_Byte, _INR(0,1), Event_Disable, Internet_Event);
  _swix(OS_Release, _INR(0,2), EventV, module_evententry, pw);
  grabbed_event = 0;

  return NULL;
}


void module_service(int service, _kernel_swi_regs *r, void *pw)
{
  switch (service)
  {
  case Service_PostInit:
    machine(PostInit);
    return;

  case Service_Dialler:
    machine(CONNECTED(r->r[2]) ? LinkUp : LinkDown);
    return;

  case Service_NCRegistry:
    if ((r->r[5] & BB_STATUS_BB_VALID) ||	/* Network bootblock changed */
        (r->r[4] & BB_STATUS_BB_VALID))
      machine(RegistryChanged);
    return;

  default:
    dprintf(("debug", "Bogus service call &%x\n", service));
  }
}


_kernel_oserror *module_timerhandler(_kernel_swi_regs *r, void *pw)
{
  setcallback(Timer, pw);
  return NULL;
}


int module_eventhandler(_kernel_swi_regs *r, void *pw)
{
  /* Assumes only requested event in CMHG is Internet */
  if ((r->r[1] != RarpReply) && (r->r[2] == sockno))	/* Pour moi? */
  {
    switch (r->r[1])
    {
    case Async:
      setcallback(Response, pw);
      break;

    case Broken:
      setcallback(Failure, pw);
      break;
    }

    return 0;	/* Claim */
  }

  return 1;	/* Don't claim */
}


_kernel_oserror *module_callhandler(_kernel_swi_regs *r, void *pw)
{
  machine(callback_reason);
  return NULL;
}


void setcallback(transition_t reason, void *pw)
{
  callback_reason = reason;
  _swix(OS_AddCallBack, _INR(0,1), module_callentry, pw);
}

_kernel_oserror *module_cmd_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{
    _swix(OS_RemoveTickerEvent, _INR(0,1), module_timerentry, pw);
    setcallback(LinkUp, pw);
    return NULL;
}
