/* -*-c-*- */

/* http.h */

/* Headders for the http support module */

/*
 * This needs to be here to prevent REMOTE_DEBUG being defined when remote.h
 * is included.
 */
#ifndef DEBUG
#define DEBUG 0
#endif

#ifndef REMOTE_DEBUG
#define REMOTE_DEBUG 0
#endif

#ifndef BOOL
#define BOOL int
#define TRUE 1
#define FALSE 0
#endif

#if REMOTE_DEBUG && DEBUG

#include "debug/remote.h"

void _debug_printf(FILE*dummy,char *format, ...);

#endif

/* The version string sent in requests and expected in replies */
#define HTTP_VERSION "HTTP/1.0"
#define HTTP_VERSION_CHECK "HTTP"

#define HTTP_PORT	80

/* How many cs between checks to see if a connection has been made */
#define TICKER_RATE	10

/* External declarations for the entry points to the module header */
extern int inetevent_entry(int);
extern int timer_entry(int);
extern int callback_entry(int);

/* How to return from a handler */

#define VIA_R14		1
#define VIA_STACK     	0

/* Event number for the internet event */

#define Event_Internet	19  /* NINETEEN, do you hear?? not SIXTEEN!! */

/* The UNUSED macro stops the compiler complaining */
#define UNUSED(x) (x=x)

#define MONOTIME		(*(unsigned int *)0x10C) /* RISC OS runery! */

/* The longest single line we can cope with */
#define MAX_INPUT	2048	/* We can loose the end off a header line if the line exceeds this length */

/**********************************************************************/
/*
 * Now we get the data structures specific to this module
 */

#if 0
typedef enum {
    http_close_DELETE_FILE = 0x01, /* Delete the file when the conneciton is closed */
    http_close_SET_TYPE = 0x02,	/* Set the file type according to Content-type: header line */
    http_close_DELETE_BODY = 0x04 /* Delete the body when the conneciton is closed */
    } http_close_flags;
typedef enum {
    status_NEW = 0,
    status_CONNECTING,
    status_REQUESTING,
    status_REQUEST_HEADERS,
    status_REQUEST_BODY,
    status_WAITING,
    status_GETTING_HEADERS,
    status_GETTING_BODY,
    status_CONNECT_FAILED,
    status_REQUEST_FAILED,
    status_COMPLEATED
    } http_status_code;
#else
#define http_status_code transfer_status
#endif

/* Keep-Alive and transaction queues
 *
 * The handle returned by HTTP_Open is a pointer to a http_connection
 * structure. All http_connections are linked together in a 2LL by the next
 * and prev fields.
 *     A connection optionally has a pointer to an http_queue where there's
 * a queue of transactions *not yet started*. This queue is linked in a 2LL
 * by the queuenext/queueprev fields.
 *     Once a transaction is started (allow_read) it's removed from q->queue
 * and placed in the queuenext field of the transaction it's queued behind.
 * This commits it as to what socket it's using. Its own queuenext field is
 * set to NULL.
 *     The current transaction on each socket is also kept in the http_conn
 * array, indexed by socket number.
 *     On a successful completion a transaction goes allow_write on its
 * queuenext member if there is one, otherwise it gets one from the q->queue.
 *     On a connection close (orphan_queue) open_socket is called on the
 * queuenext member if there is one, otherwise the next one from q->queue.
 *     open_socket and close_socket adjust q->sockets, freeing the q if it
 * becomes zero.
 *     If only one connection has ever been opened to a given server, it won't
 * have a http_queue pointer. Only the second connection causes a queue to be
 * set up (into which any third connection will be placed).
 *
 * Thus we have, for example
 *
 *      +---+          +---+        +----+
 *      | A |---\  /---| A |        | A2 |       ...
 *      +---+   |  |   +---+        +----+
 *       |     ######
 *      +---+  # Q  #
 *      | S |  ######
 *      +---+      |
 *                +---+
 *                | W |
 *                +---+
 *                 |
 *                +---+
 *                | W |
 *                +---+
 *                 ...
 *
 * where the A's are active transactions to the same server (with a socket
 * each), S is a transaction to the same server that's been started (request
 * sent but reply not started), Q is the http_queue for that server, and the
 * W's are transactions to that server waiting to start. A2 is an active
 * transaction to a different server.
 *     The other links not shown on that diagram are the http_conn array, which
 * points to the A's and to A2, and the doubly-linked list which connects all
 * the transactions (A, A2, S, W).
 *
 */

#define hostflags_SECURE        0x1
#define hostflags_RANGES        0x2     /* Server supports byte ranges */
#define hostflags_KEEPALIVE     0x4     /* Server supports keep-alive */

typedef struct http_queue {
    int                nsockets;
    struct httpconn    *queue;
    struct http_queue  *prev;
    struct http_queue  *next;
    struct sockaddr_in sa;
    int                flags;
} http_queue;

typedef struct httpconn {
    int magic;			/* Magic number to check bogus handles */
    struct httpconn *next;	/* Pointer to the next one */
    struct httpconn *prev;	/* POinter to the previous one */
    int poll_word;		/* Goes non-zero on completion or error */
    http_status_code status;	/* Conneciton status */
    char *object;		/* Object to be fetched */
    http_header_item *sendhead;	/* Remaining headers to be sent */
    int socket;			/* Socket number, or -1 */
    struct sockaddr_in sa;	/* Address we want to connect to */
    char *fname;		/* Name of file for the data */
    int fh;			/* RISC OS handle to the above file when open */
    char *bname;		/* Name of file for the body */
    int bh;			/* RISC OS handle to the above file when open */
    int data_size;		/* Given the value -1 if we do not know */
    int data_so_far;		/* Amount of data so far EXCLUDING headers */
    http_header_item *headers;	/* Linked list of header items */
    int rc;			/* Return code, -1 until we know */
    char *message;		/* Message with return code, NULL until we know */
    int buf_off;		/* New data goes here */
    int buf_used;		/* Data already taken up to here */
    char *buffer;		/* Data buffer for incoming data */
#ifdef NO_SECURE
    void *_;
#else
    SSL *SSL;                   /* Secure Socket Layer connection data */
#endif
    int flags;
    int data_pending;
    http_header_item *sendhead_base; /* All headers */

    struct httpconn *queuenext, *queueprev;
                                /* Linked list starting from an http_queue */

    struct http_queue *queue;   /* Queue of further requests to this host */

    int total_size;             /* For partial requests */

    char *boundary;             /* Server-push boundary (NULL for none) */
    int nearlyboundary;         /* #chars of boundary found at end of packet */

#if DEBUG
    int onthissocket;
#endif
} http_connection;

#define HTTP_MAGIC	0x4582FB29

/* Utility functions */

char *strdup(char *);
int strcasecmp(char *s1, char *s2);

/* HTTP function */

_kernel_oserror *http_check_handle(http_connection *c);
_kernel_oserror *http_close_handle(http_connection *c, int flags);
_kernel_oserror *http_free_headers(http_header_item *h);
_kernel_oserror *http_set_file_type(http_connection *c, int *ftptr);

int http_file_size(char *fname);

void http_send_request(http_connection *c);
int http_send_request_headers(http_connection *c);
int http_send_request_body(http_connection *c);
char *http_getline(http_connection *c, int read);

void http_process_header_line(http_connection *c, char *l);
void http_process_response_line(http_connection *c, char *l);
void http_flush_data_to_file(http_connection *c);
void http_socket_close(http_connection *c);
BOOL http_check_special_headers(http_connection *c, char *key, char *value);
