/* -*-c-*- */

/* http.c */

/*
 * The HTTP module provides a mechanism for sending requests and
 * fetching results using the HyperText Transfer Protocol.
 *
 * pdh 01-Jul-96 Begin HTTPS (HTTP+SSL) support (defeat with -DNO_SECURE)
 * pdh 03-Jul-96 HTTPS now working
 * pdh 04-Jul-96 The last reallocs excised from httpsmod -- verify now works
 * pdh 29-Jul-96 Added HEAD support
 * pdh 12-Sep-96 Corrected internet event code -- hogs machine much less now
 * SJM 20-Nov-96 Took out excess strduping in status_AUTHENTICATING and added
 *		 setting of SSL_VERSION system variable.
 * pdh 27-Jan-97 Begin Keep-Alive support
 * pdh 29-Jan-97 First internal release of keep-alive version (0.61)
 * pdh 12-Mar-97 Frob prefix-fetch stuff to work round bug in WebSitePro/1.1f
 * RWB 16 Apr 97 CSFS bits.
 * AJS 22-Apr-97 Made some mods to http_verifymessagedigest
 * AJS 28-Apr-97 Added http_converttopem certificate munger
 * AJS 08-May-97 More mods to http_verifymessagedigest
 * SJM 29-May-97 changed send_request_headers to use sendv.
 * AJS 29-May-97 Added certificate ageing to http_vmd
 * SJM 01-Jun-97 Moved socket count incrementing to start of http_open_socket.
 * pdh 04-Jun-97 Allow spaces at the beginning of headers (sigh)
 * SJM 11-Jun-97 Only strip multiple copies of headers if it's not set-cookie.
 * SJM 10-Jul-97 if ensure_size fails then return an error.
 * pdh 14-Jul-97 Cope with "Content-type: text/html; charset=foo"
 * SJM 18-Jul-97 Maybe found occaisional server-push crash. malloc for boundary
 *		 wasn't allocating a byte for the terminator
 * SJM 26-Aug-97 took out a 'pdh: bodge' as it seemed to be responsible for server-push
 *               not working and crashing again!
 * SJM 01-Oct-97 Added USE_MIMEMAPMOD. Added PROXY_REDIRECT code. Added BUFFER_EXTEND code.
 *		 Only PROXY_REDIRECT tested at the moment and that is only for one customers use.
 * SJM 02-Oct-97 Bit more on PROXY_REDIRECT (to allow disabling the proxy altogether).
 *		 Found bug bug when trying to use IMAGE and TUNNEL. When the socket is closed the
 *		 tunnelling flag and SSL context are lost. Added new flag to restart tunnelling,
 *		 ensured SSL context is freed in socket close, stopped 'object' field from being
 *		 modified when sending headers, and stopped the zeroing of data_so_far on reopening
 *		 SSL connection.
 * SJM 27-Feb-98 Removed sendv() use in send request and send request headers as they fail to work
 *		 (When using ssl) with the lotus domino server.
 * SJM 02-Mar-98 Split off the PROXY_REDIRECT code to its own file. Changed MimeMap Module numbers.
 */

#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <stdarg.h>

#include "kernel.h"
#include "swis.h"
#include "tcplibs.h"

#include "status.h"

#ifndef NO_SECURE

#define HEADER_DES_LOCL_H	/* prevents crypt() warning */
#include "SSL/objects.h"		/* for NID */
#include "SSL/pem.h"		/* for PEM_ */
#include "SSL/rsa.h"


#include "SSL/ssl.h"
#include "SSL/x509.h"

/* port routines */
extern _kernel_oserror *SSL_LibraryPresent( void );
extern int SSL_verified(SSL *session);
extern void riscos_ZM_Initialise( void );
extern void *riscos_ZM_realloc( void *ptr, size_t newsize );
extern void riscos_SSLLib_Init( void );

#define CERT_VERIFY_DEPTH 10
#endif

#include "httppub.h"
#include "http.h"
#include "files.h"
#include "mimemap.h"

#if DEBUG
#include "err.h"
#ifndef NO_SECURE
#include "SSL/buffer.h"
#endif
#endif

#ifdef CSFS
#include "csfs.h"
#endif


#ifndef FILETYPE_HTML
#define FILETYPE_HTML	0xfaf
#endif

#define SSL_VERSION_VAR	"HTTP$SSLVersion"

/**********************************************************************/
/*
 * Global definitions
 */

#ifndef TESTMODE
#define TESTMODE 0
#endif

/* Last byte of an image to fetch as a priority */
#define IMAGE_HEADER     255
#define IMAGE_HEADER_T  "255"
#define IMAGE_HEADER1    256
#define IMAGE_HEADER1_T "256"

#define MAXSOCKETS 12        /* Can be overridden */

/**********************************************************************/
/*
 * Error definitions
 */

/* Error definitions */
typedef enum {
    err_NO_SUCH_HOST,
    err_CANT_FIND_SERVICE,
    err_CANT_FIND_PROTOCOL,
    err_CANT_MAKE_SOCKET,
    err_CANT_CONNECT,
    err_BAD_IOCTL,
    err_NO_MEMORY,
    err_BAD_MAGIC,
    err_CANT_OPEN_FILE,
    err_CANT_OPEN_BODY,
    err_SSL_NOT_AVAILABLE,
    err_SSL_CANT_CONNECT,
    err_NOT_WAITING,
#ifdef CSFS
    err_CSFS,
#else
    err_RESERVED,
#endif

    err_LAST_ERROR
    } error_numbers;

#define err_NO_ERROR -1

static char *err_strings[] = {
    "Can't find host in database",
    "Can't find service in database",
    "Can't find protocol in database",
    "Can't make socket",
    "Can't connect to server",
    "Bad IOCTL call",
    "Not enough free memory",
    "Invalid connection handle",
    "Can't open output file",
    "Can't open posting body file",
    "HTTPS not available",
    "Can't negotiate HTTPS connection",
    "Unexpected call to CompletedPart",
#ifdef CSFS
    "HTTP transport error",
#else
    "",
#endif
    "Unknown error"
    };

/**********************************************************************/
/*
 * Global variable definitions
 */

void *private_word;

http_connection *http_cons[FD_SETSIZE]; /* Array of pointers - only the heads
                                           of keep-alive queues are in here */

http_connection *http_cons_list;        /* Absolutely all connections */
http_queue      *http_queues_list;

volatile int callback_pending;
volatile int threaded = 0;

static int keptalive;

static int maxsockets;

static int totalsockets;

static int sockets_connecting; /* Count of sockets in the process of connection
                                   (i.e. still need to be polled) */

#ifndef BOOL
#define BOOL int
#define TRUE 1
#define FALSE 0
#endif

#ifndef NO_SECURE
static BOOL ssl_present = TRUE;
static SSL_CTX *ssl_context = NULL;
static BOOL verify_error = FALSE;
#endif

#define TMP_BUF_SIZE        1028
char tmp_buffer[TMP_BUF_SIZE];

static char http_version[] = HTTP_VERSION;
static char http_version_check[] = HTTP_VERSION_CHECK;

FILE *log_file;

/**********************************************************************/
/*
 * Forward declarations of functions static to this file
 */

static _kernel_oserror *setup_ticker_and_event(void);
static void clear_ticker_and_event(void);
static void setup_callback(void);
static void clear_callback(void);

static _kernel_oserror *http_open(http_open_args *args);
static _kernel_oserror *http_status(http_status_args *args);
static _kernel_oserror *http_converttopem(_kernel_swi_regs *r);
static _kernel_oserror *http_close(http_close_args *args);
static _kernel_oserror *http_maptoriscos(http_maptoriscos_args *args);
static _kernel_oserror *http_mapfromriscos(http_mapfromriscos_args *args);
static _kernel_oserror *http_setfiletype(http_setfiletype_args *args);
static _kernel_oserror *http_completedpart(http_completedpart_args *args);
static _kernel_oserror *http_verifymessagedigest(http_verifymessagedigest_args *r);
static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value );
static _kernel_oserror *http_prosecute( http_connection *c );

static void http_orphan_queue( http_connection *c );
static void http_queue_allow_read( http_connection *c );
static void http_queue_allow_write( http_connection *c );
static void http_requeue( http_connection *c );
static void http_queue_dec_nsockets( http_connection *c );

#if DEBUG
static void http_show_flags( http_connection *c );
#endif

#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error);
#endif

#ifdef NO_SECURE
#define http_send(c,m,s) send((c)->socket,m,s,0)
#define http_sendv(c,v,n) socketwritev((c)->socket,v,n)
#define http_recv(c,b,l) recv((c)->socket,b,l,0)
#else
#define http_send(c,m,s)  (((c)->SSL) ? SSL_write( (c)->SSL, m, s )         \
                                      : send( (c)->socket, m, s, 0 ) )

#define http_sendv(c,v,n) (((c)->SSL) ? SSL_writev( (c)->SSL, v, n )        \
                                      : socketwritev( (c)->socket, v, n ) )

#define http_recv(c,b,l)  (((c)->SSL) ? SSL_read( (c)->SSL, b, l )          \
                                      : recv( (c)->socket, b, l, 0 ) )
#endif

#ifdef REMOTE_DEBUG
debug_session *db=NULL;
#else
extern void *db;
#endif

void fprintf_and_flush( FILE *f, char *format, ... );

#ifdef REMOTE_DEBUG
# define fdebugf  _debug_printf
#elif DEBUG
# define fdebugf fprintf_and_flush
#else
# define fdebugf 1?0:fprintf
#endif

/**********************************************************************/
/*
 * This structure is a prototype for a connection.
 */
static http_connection proto_con = {
    HTTP_MAGIC,                 /* Magic number */
    NULL,                       /* Next pointer */
    NULL,                       /* Prev pointerb */
    0,                          /* Poll word */
    status_NEW,                 /* Status */
    NULL,                       /* Object name */
    NULL,                       /* Outgoing headers */
    -1,                         /* Socket number */
    { 0, },                     /* Socket address */
    NULL,                       /* File name */
    0,                          /* File handle */
    NULL,                       /* Body file name */
    0,                          /* Body file handle */
    -1,                         /* Data size */
    -1,                         /* Data so far */
    NULL,                       /* List of fetched headers */
    -1,                         /* Return code */
    NULL,                       /* Return message */
    0,                          /* Buffer offset */
    0,                          /* Buffer used */
    0,                          /* Buffer size */
    NULL,                       /* Buffer data */
    NULL,                       /* SSL connection */
    0,                          /* Flags */
    0,                          /* Data pending */
    NULL,                       /* Beginning of headers */
    NULL, NULL,                 /* Keep-alive queue 2LL */
    NULL,                       /* Queue head structure */
    0,                          /* Total size */
    NULL,                       /* Server push boundary */
    0,                          /* #chars of boundary found at end of packet */
    1,                          /* # connections on this socket */
    0				/* CSFS action */
    };


        /*=======================*
         *   Utility functions   *
         *=======================*/


/**********************************************************************/
/*
 * The bcmp and bzero functions are needed by various internet library
 * calls.  I just pass them through to the memXXX versions.
 */

/* int bcmp(void *s1, void *s2, size_t s)
{
    return memcmp(s1, s2, s);
} */

void http_bzero(void *p, int s)
{
    memset(p, 0, s);
}

/**********************************************************************/
/*
 * Error generation function
 */

static _kernel_oserror httperror;

static _kernel_oserror *make_error(int err)
{
    if ( err == err_NO_ERROR )
        return NULL;

    if (err > err_LAST_ERROR)
        err = err_LAST_ERROR;

    threaded = 0;

    httperror.errnum = err;
    strncpy(httperror.errmess, err_strings[err], 252);

    fdebugf(log_file, "Making error number %d: %s\n", err, err_strings[err]);

    return &httperror;
}

char *strdup(char *s)
{
    char *ss;
    int i = strlen(s) + 1;

    ss = malloc( i );

    if (ss)
        memcpy(ss, s, i);

    return ss;
}

int strcasecmp(char *s1, char *s2)
{
    int c1, c2, t;

    while (1)
    {
        c1 = *s1++;
        c2 = *s2++;
        if (c1 == 0 || c2 == 0)
            return c1-c2;
        else
        {
            t = toupper(c1) - toupper(c2);
            if (t)
                return t;
        }
    }
}

/* prefixcmp: like strcasecmp but returns 0 if s2 is a prefix of s1 */
int prefixcmp(char *s1, char *s2)
{
    int c1, c2, t;

    while (1)
    {
        c1 = *s1++;
        c2 = *s2++;
        if ( c2 == 0 )
            return 0;
        if ( c1 == 0 )
            return c1-c2;
        else
        {
            t = toupper(c1) - toupper(c2);
            if (t)
                return t;
        }
    }
}

/* memfind: like strstr but copes with search areas that contain 0's and don't
 * necessarily end with one. If there's a partial match at the end of the
 * search area, sets *nearly to the number of characters which matched.
 */
const char *memfind( const char *area, int len, char *search, int *nearly )
{
    int srchlen = strlen(search);

    while ( len > srchlen )
    {
        if ( !strncmp( area, search, srchlen ) )
            return area;
        area++;
        len--;
    }

    *nearly = 0;

    /* Check for partial match at the end <sigh> */
    while ( len >= 0 )
    {
        if ( !strncmp( area, search, len ) )
        {
            *nearly = len;
            return NULL;
        }
        area++;
        len--;
    }
    return NULL;
}

#ifndef USING_INET5
/* Damn and blast all Acorn socket libraries. Or at least their headers. */
struct iovec { void *iov_base; int iov_len; };
extern int socketwritev( int d, struct iovec *iov, int iovcnt );
#endif


/*---------------------------------------------------------------------------*
 * SSL_writev                                                                *
 * Equivalent to Socket_WriteV except uses an SSL connection. Assumes non-   *
 * blocking I/O.                                                             *
 *---------------------------------------------------------------------------*/

#if 0
static int SSL_writev( SSL *s, struct iovec *iov, int iovcnt )
{
    int bytes = 0;
    int rc;

    while ( iovcnt )
    {
        rc = SSL_write( s, iov->iov_base, iov->iov_len );
        if ( rc < 0 )
        {
            if ( errno == EWOULDBLOCK && bytes )
	    {
		fdebugf(log_file, "SSL_writev: EWOULDBLOCK %d bytes, %d vectors left\n", bytes, iovcnt);
                return bytes;
	    }

	    fdebugf(log_file, "SSL_writev: errno %d\n", errno);
            return -1;
        }
        else
            bytes += rc;

        iovcnt--;
        iov++;
    }
    return bytes;
}
#endif


        /*=================================*
         *   Interface to modules system   *
         *=================================*/

/*
 * pick up on the CSFS starting service call and register ourselves
 */
#ifdef CSFS
void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs reg;

  reg.r[0] = 0;
  reg.r[1] = (int)CSFS_ServiceName;
  reg.r[2] = HTTP_CSFSService;
  reg.r[3] = HTTP_CSFSFeatures;
  _kernel_swi(CSFS_Register,&reg,&reg);
#ifndef NO_SECURE
  reg.r[0] = 0;
  reg.r[1] = (int)CSFS_ServiceNameSecure;
  reg.r[2] = HTTP_CSFSServiceSecure;
  reg.r[3] = HTTP_CSFSFeatures;
  _kernel_swi(CSFS_Register,&reg,&reg);
#endif
}
#endif



/**********************************************************************/
/*
 * Module finalisation function
 */
static void module_final(void)
{
#ifdef CSFS
    _kernel_swi_regs reg;
#endif
    http_connection *c, *next_one;

    fdebugf(log_file, "Module finalisation called\n");

    clear_ticker_and_event();

    clear_callback();

    for (c = http_cons_list; c != NULL; c = next_one)
    {
        next_one = c->next;
        fdebugf(log_file, "%p: being closed by finalisation\n", c );
        http_close_handle(c, http_close_DELETE_FILE | http_close_FATAL );
    }
#ifdef REMOTE_DEBUG
    debug_printf(db,"(5) finalisation");
    remote_debug_close(db);
#endif

#ifdef CSFS
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceName;
    _kernel_swi(CSFS_DeRegister,&reg,&reg);
#ifndef NO_SECURE
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceNameSecure;
    _kernel_swi(CSFS_DeRegister,&reg,&reg);
#endif
#endif

#ifndef NO_SECURE
    if ( ssl_context )
        SSL_CTX_free( ssl_context );
#endif
}

#ifdef REMOTE_DEBUG
void
_debug_printf(FILE *file, char *format, ...)
{
  char debug_line[256];
  va_list list;

  va_start (list, format);
  vsprintf(debug_line,format, list);
  va_end(list);

  debug_printf(db,"%s",debug_line);
}
#endif

#if DEBUG
void fprintf_and_flush(FILE *file, char *format, ...)
{
  va_list list;

  va_start (list, format);
  vfprintf(file,format, list);
  va_end(list);

  fflush(file);
}
#endif

#if DEBUG
static void dump(FILE *out, char *data, int size)
{
    int i;
    for (i = 0; i < size; i++)
    {
	fdebugf(out, "%02x ", data[i]);
	if ((i & 15) == 15)
	    fdebugf(out, "\n");
    }

    if ((i & 15) != 0)
	fdebugf(out, "\n");
}
#endif

#if DEBUG && !defined(NO_SECURE)
static long bio_dump_cb(BIO *bio, int cmd, char *argp, int argi, long argl, long ret)
{
    FILE *out = log_file;
    if (cmd == (BIO_CB_READ|BIO_CB_RETURN))
    {
	fdebugf(out,"read from %08X [%08lX] (%d bytes => %ld (0x%X))\n",
		bio,argp,argi,ret,ret);
	if (ret > 0)
	    dump(out,argp,ret);
	return(ret);
    }
    else if (cmd == (BIO_CB_WRITE|BIO_CB_RETURN))
    {
	fdebugf(out,"write to %08X [%08lX] (%d bytes => %ld (0x%X))\n",
		bio,argp,argi,ret,ret);
	if (ret > 0)
	    dump(out,argp,ret);
	return(ret);
    }
    else if (cmd == (BIO_CB_CTRL|BIO_CB_RETURN))
	return ret;
    return ret == 0 ? 1 : ret;
}

static void bio_debug_open(SSL *s)
{
    BIO_set_callback((BIO *)SSL_get_rbio(s), bio_dump_cb);
}
#endif

/**********************************************************************/
/*
 * Module initialisation function
 */
extern _kernel_oserror *module_initialise(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *ep;
#ifdef CSFS
    _kernel_swi_regs reg;
#endif

    private_word = pw;

    if (cmd_tail)
    {
        log_file = fopen(cmd_tail, "w");
        if (log_file == NULL)
            log_file = stderr;
    }
    else
    {
        log_file = stderr;
    }
#ifdef REMOTE_DEBUG
    remote_debug_open("HTTP",&db);
#endif
    fdebugf(log_file, "Module initialisation called.\n");

#if DEBUG && !defined(NO_SECURE)
    ERR_load_crypto_strings();
#endif

    http_bzero(http_cons, sizeof(http_cons));
    http_cons_list = NULL;

    callback_pending = 0;
    sockets_connecting = 0;
    keptalive = 0;
    totalsockets = 0;
    maxsockets = MAXSOCKETS;

#ifndef NO_SECURE
    ssl_present = TRUE;
    riscos_ZM_Initialise();
    riscos_SSLLib_Init();
#if DEBUG && !defined(REMOTE_DEBUG)
    {
	extern FILE *SSL_ERR;
	SSL_ERR = log_file;
    }
#endif

    {
        ssl_context = SSL_CTX_new();
        SSL_load_error_strings();
        if ( ssl_context )
        {
/*          X509_add_cert_dir( ssl_context->cert, "SSL:certs",
                               X509_FILETYPE_PEM );
            SSL_load_verify_locations( ssl_context, NULL, "SSL:certs" );*/
            SSL_set_default_verify_paths( ssl_context );
            SSL_CTX_set_cipher_list( ssl_context, getenv( "SSL$CipherList" ) );
        }
        else
            ssl_present = FALSE;
    }
    _kernel_setenv(SSL_VERSION_VAR, ssl_present ? "2" : "0");
#else
    _kernel_setenv(SSL_VERSION_VAR, "0");
#endif

    ep = setup_ticker_and_event();
    if (ep)
        goto err;

#ifdef CSFS
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceName;
    reg.r[2] = HTTP_CSFSService;
    reg.r[3] = HTTP_CSFSFeatures;
    _kernel_swi(CSFS_Register,&reg,&reg);
#ifndef NO_SECURE
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceNameSecure;
    reg.r[2] = HTTP_CSFSServiceSecure;
    reg.r[3] = HTTP_CSFSFeatures;
    _kernel_swi(CSFS_Register,&reg,&reg);
#endif
#endif

    atexit(&module_final);

    return 0;

 err:
    return ep;

    UNUSED(cmd_tail);
    UNUSED(pbase);
}

/**********************************************************************/
/*
 * Module CLI handler function
 */
extern _kernel_oserror *module_cli_handler(char *arg_string, int arg_count, unsigned int cmd_no, void *pw)
{
    http_connection *c;
    http_queue *q;

    fdebugf(log_file, "CLI handler called, command number %d\n", cmd_no);

    switch(cmd_no)
    {
    case 0:
        printf("HTTP support module status information\n");

        if (http_cons_list)
        {
            for (c = http_cons_list; c != NULL; c = c->next)
#if !DEBUG
            if ( c->socket != -1 )
#endif
            {
                unsigned long ip = c->sa.sin_addr.s_addr;
                unsigned int port = c->sa.sin_port;

                printf( "Connection at %p for http://%ld.%ld.%ld.%ld:%d%s\n",
                        c,
                        ip&0xFF, (ip>>8)&0xFF, (ip>>16)&0xFF, (ip>>24),
                        htons(port),
                        c->object );
                printf( "    socket=%d status=%d rc=%d\n", c->socket, c->status,
                        c->rc );
                printf( "    data=%d/%d, message=%s\n", c->data_so_far,
                        c->data_size, c->message ? c->message : "<none>" );
                printf( "    queue=%p, queueprev=%p, queuenext=%p\n", c->queue,
                        c->queueprev, c->queuenext );
            }

            if ( http_queues_list )
            {
                q = http_queues_list;
                while ( q )
                {
                    unsigned long ip = q->sa.sin_addr.s_addr;
                    unsigned int port = q->sa.sin_port;

                    printf( "Queue at %p for http://%ld.%ld.%ld.%ld:%d\n", q,
                            ip&0xFF, (ip>>8)&0xFF, (ip>>16)&0xFF, (ip>>24),
                            htons(port) );
                    c = q->queue;

                    if ( c )
                    {
                        while ( c )
                        {
                            printf( "    Waiting: %p %s\n", c, c->object );
                            c = c->queuenext;
                        }
                    }
                    else
                        printf( "    Empty\n" );

                    q = q->next;
                }
            }
        }
        else
        {
            printf("No current connections\n");
        }

        if ( keptalive )
                printf( "Uses of keep-alive: %d\n", keptalive );
        break;
    }

    return 0;

    UNUSED(arg_string);
    UNUSED(arg_count);
    UNUSED(pw);
}
#ifdef CSFS
/*
 * munge filename and append it to given string
 */
void
munge_filename(char *output, char *filename, int file_type)
{
  int i;

  if (filename)
  {
    i=strlen(output);
    strcat(output,filename);
    while (output[i]!=0)    /* swap '.' with '/' */
    {
      if (output[i]=='.')
        output[i]='/';
      else if (output[i]=='/')
        output[i]='.';
      i++;
    }
  }
  /*
   * sort filetype out
   */
  if (file_type!=0 && file_type !=0xfff)  /* append the file type to filename */
  {
    char exten[6];
    sprintf(exten,",%03x",file_type);
    strcat(output,exten);
  }
}

/*
 * munge the url
 */
_kernel_oserror *
munge_url(char *mount_path, char *path1, int file_type1, char *username,
	  char *passwd, char *cmd, char *path2, int file_type2,
	  char **output_file)
{
  char *output_path=NULL;
  char *input_path1=path1;  /* make sure we don't trash input string */
  char *input_path2=path2;

  if (input_path1!=NULL)       /* is it a null string */
    if (*input_path1==0)
      input_path1=NULL;

  if (input_path2!=NULL)
    if (*input_path2==0)
      input_path2=NULL;

  /*
   * need our own copy of string to play with
   */
  output_path = malloc((mount_path ==NULL?0:strlen(mount_path ))+
  	      	       (input_path1==NULL?1:strlen(input_path1))+
  	      	       (input_path2==NULL?1:strlen(input_path2))+
  	      	       (username   ==NULL?0:strlen(username   ))+
  	      	       (passwd     ==NULL?0:strlen(passwd     ))+
  	      	       (cmd        ==NULL?0:strlen(cmd        ))+50);

  if (output_path==NULL)
    return (make_error(err_NO_MEMORY));

  if (mount_path)
  {
    strcpy(output_path,mount_path);
    strcat(output_path,"?");
  }
  else
    strcpy(output_path,"");

  if (cmd)
  {
    strcat(output_path,"cmd=");
    strcat(output_path,cmd);
    strcat(output_path,"&");
  }

  strcat(output_path,"path=/");
  munge_filename(output_path,input_path1,file_type1);

  if (username)
  {
    strcat(output_path,"&");
    strcat(output_path,"username=");
    strcat(output_path,username);
  }
  if (passwd)
  {
    strcat(output_path,"&");
    strcat(output_path,"password=");
    strcat(output_path,passwd);
  }
  if (input_path2)
  {
    strcat(output_path,"&extra=/");
    munge_filename(output_path,input_path2,file_type2);
  }

  *output_file = output_path;

  return (NULL);
}

/*
 * implement the CSFS service swi
 */
extern _kernel_oserror *
http_csfs_service(_kernel_swi_regs *r, int secure)
{
  http_open_args open_args;
  http_close_args close_args;
  http_status_args status_args;
  _kernel_oserror *err=NULL;
  struct sockaddr_in sockaddr_in;
  char *path=NULL;
  char *remote_filename=NULL;
  char *username=NULL;
  char *passwd=NULL;
  char *cmd=NULL;
  char *extra=NULL;
  int file_type1;
  int file_type2;
  csfs_info *file_info;
  settype_info *type_info;
  char *mount_path=NULL;
#if DEBUG
  static int status=0;
#endif
  http_connection *handle;
  static progress_info file_progress;

  memset(&sockaddr_in, 0, sizeof(sockaddr_in));
  handle = (http_connection*)r->r[2];

  switch (r->r[0])
  {
    case CSFS_CLOSE :
      fdebugf(log_file,"(7) initial action = %d\n",handle->action);
      close_args.in.flags = 0;
      if (handle->action != CSFS_GET)
        close_args.in.flags |= http_close_DELETE_FILE;

      close_args.in.handle = handle;
      ERR_GOTO(err,http_close(&close_args));

      break;
    case CSFS_STATUS :
      status_args.in.handle = handle;
      ERR_GOTO(err,http_status(&status_args));
#if DEBUG
      if (status_args.out.status!=status)
      {
        status=status_args.out.status;
        fdebugf(log_file,"(7) CSFS new status %d\n",status);
      }
#endif
      if (status_args.out.status >= status_COMPLETED_FILE)
      {
        http_header_item *hdr=status_args.out.headers;
        switch (status_args.out.status)
        {
          case status_COMPLETED_FILE : case status_COMPLETED_DIR :
            r->r[0] = 0;
            /*
             * check for return status from server
             */
            while (hdr)
            {
              if (strcasecmp(hdr->key,"CONTENT-TYPE")==0)
                if (strcasecmp(hdr->value,MIME_CSFSStatus)==0)
                {
                  int i=0;
                  char *p;
	          char status_str[252];

                  /* fill-in the error message from status file */
        	  err=make_error(err_CSFS); /* defer jump till later */
                  ro_write_ptr(handle->fh, 0);
                  while (!ro_eof(handle->fh) && i<252)
                    status_str[i++]= _kernel_osbget(handle->fh);
                  status_str[i-1] = 0; /* terminate */

		  fdebugf(log_file,"Status %s\n",status_str);
                  /* look for status code, expect nnn:error_string*/
                  if ((p=strchr(status_str,':'))!=NULL)
                  {
                    *(p++) = 0; /* terminate status code */
                    if (atoi(status_str) == status_COMPLETED_FILE)
                    {
                      err = NULL;
                      break;
                    }
                    else
                    {
                      strcpy(err->errmess,p); /* copy into error structure */
                      goto exit_gracefully;
                    }
                  }
                  else
                  {
                    /* copy into error structure */
                    strcpy(err->errmess,status_str);
                    goto exit_gracefully;
                  }
                }
              hdr = hdr->next;
            }
            break;
          default :
            ERR_GOTO(err,make_error(err_CSFS));
            r->r[0] = 1;
	}
      }
      else
       r->r[0] = -1;  /* still progressing */

      if (handle->data_size == -1)
      {
        file_progress.total = 0;
        file_progress.sofar = 0;
      }
      else
      {
        file_progress.total = handle->data_size;
        file_progress.sofar = handle->data_so_far;
        fdebugf(log_file,"(7) Returning data total %d",file_progress.total);
      }
      r->r[3] = (int)&file_progress;

      break;
    default :
      open_args.in.action = r->r[0];
      open_args.in.flags  = http_open_flags_ACTION;
      open_args.in.fname  = NULL;   	/* default value */
      open_args.in.bname  = NULL;	/* default value */

      if (r->r[0]==CSFS_SETTYPE)
      {
        type_info = (settype_info*)r->r[8];
        file_type2 = type_info->new;
        file_type1 = type_info->old;
      }
      else
      {
        file_info = (csfs_info*)r->r[8];
        /*
         * extract file type info from supplied data
         */
        if (file_info==NULL)
          file_type1 = 0;
        else
          file_type1 = (file_info->load_addr)>>8&0xfff; /* load addr */
        file_type2 = file_type1;
      }
      username        = (char*)r->r[5];
      passwd          = (char*)r->r[6];
      mount_path      = (char*)r->r[3];
      remote_filename = (char*)r->r[4];
      switch (r->r[0])
      {
        case CSFS_GET :
          cmd = "GET";
          open_args.in.fname = (char*)r->r[7];
          break;
        case CSFS_PUT :
          cmd = "PUT";
          open_args.in.bname = (char*)r->r[7];
          break;
        case CSFS_DELETE :
          cmd = "DELETE";
          break;
        case CSFS_MKDIR :
          cmd = "MKDIR";
          break;
        case CSFS_RMDIR :
          cmd = "RMDIR";
          break;
        case CSFS_RENAME :
          cmd = "RENAME";
          extra = (char*)r->r[7];
          break;
        case CSFS_SETTYPE :
          cmd = "RENAME";
          extra = remote_filename;
          break;
        default :
          ERR_GOTO(err,make_error(err_CSFS));
      }
      ERR_GOTO(err,munge_url(mount_path,remote_filename,file_type1,username,passwd,cmd,extra,file_type2,&path));

      sockaddr_in.sin_family = AF_INET;
      /*
       * deal with port number being specified
       */
      if (r->r[1] & 1<<0)
      {
        host_info *host = (host_info*)r->r[2];
        /* default to port 80 */
        sockaddr_in.sin_port = htons((host->port==0)?80:host->port);
        sockaddr_in.sin_addr.s_addr = (unsigned int)htonl(host->addr);
      }
      else
      {
        sockaddr_in.sin_port = htons(80);
        sockaddr_in.sin_addr.s_addr = (unsigned int)htonl(r->r[2]);
      }

      open_args.in.addr = &sockaddr_in;

      fdebugf(log_file,"(7) path (%s)\n",path);
      /*
       * fill in the args
       */
      open_args.in.object = path;
      open_args.in.headers = NULL;
      if (secure) {
	open_args.in.flags |= http_open_flags_SECURE;
      }
      ERR_GOTO(err,http_open(&open_args));
      r->r[0] = (int)open_args.out.handle;
  }
exit_gracefully:
  if (path)
    free(path);

  return (err);
}
#endif
/**********************************************************************/
/*
 * Module SWI handler function
 */
extern _kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *regs, void *pw)
{
#if 0
    fdebugf(log_file, "SWI handler called, SWI number 0x%02x\n", swinum);
#endif

    switch(swinum)
    {
    case 0:
        /* Open */
        return http_open((http_open_args *) regs);
        break;
    case 1:
        /* Status */
        return http_status((http_status_args *) regs);
        break;
    case 2:
        /* Close */
        return http_close((http_close_args *) regs);
        break;
    case 3:
        /* Map to RISC OS */
        return http_maptoriscos((http_maptoriscos_args *) regs);
        break;
    case 4:
        /* Map from RISC OS */
        return http_mapfromriscos((http_mapfromriscos_args *) regs);
        break;
    case 5:
        /* SetFileType */
        return http_setfiletype((http_setfiletype_args *) regs);
        break;
    case 6:
        /* CompletedPart */
        return http_completedpart((http_completedpart_args *) regs);
        break;
    case HTTP_VerifyMessageDigest - HTTP_SWI_Base:
        return http_verifymessagedigest((http_verifymessagedigest_args *) regs);
        break;
#ifdef CSFS
    case HTTP_CSFSService - HTTP_SWI_Base:
        /* CSFS Service */
        return http_csfs_service(regs,FALSE);
#ifndef NO_SECURE
    case HTTP_CSFSServiceSecure - HTTP_SWI_Base:
        /* CSFS Service */
        return http_csfs_service(regs,TRUE);
#endif
#endif
    case HTTP_ConvertToPEM - HTTP_SWI_Base:
    	return http_converttopem(regs);
    }

    return NULL;

    UNUSED(pw);
}


        /*================================*
         *   Interface to events system   *
         *================================*/


/**********************************************************************/
/*
 * A function to handle the internet events.
 */
extern int inetevent_handler(_kernel_swi_regs *regs, void *pw)
{
    if ((regs->r[0] == Event_Internet) && (regs->r[1] >=0) && (regs->r[1] <= 2))
    {
        if ( regs->r[2] >= 0 && regs->r[2] < FD_SETSIZE )
        {
            /* take some action */
            http_connection *c = http_cons[ regs->r[2] ];
            if ( c )
            {
                c->data_pending = 1;
                setup_callback();
            }
        }
    }

    return VIA_R14;

    UNUSED(pw);
}

int timer_handler( _kernel_swi_regs *r, void *pw )
{
    if ( http_cons_list != NULL )
        setup_callback();

    return VIA_R14;
}

/**********************************************************************/
/*
 * A function to handle the callbacks caused by internet events.
 */
extern int callback_handler(_kernel_swi_regs *regs, void *pw)
{
    int i;

#if  0
    fdebugf(log_file, "Callback handler entered\n");
#endif

    if ( threaded )
    {
        fdebugf( log_file, "**** Considerable disaster\n" );
        return VIA_R14;
    }

    threaded = 1;

    for ( i=0; i < FD_SETSIZE; i++ )
    {
        http_connection *c = http_cons[i];
        if ( c )
        {
            if ( c->status < status_WAITING
                 || c->data_pending )
            {
                c->data_pending = 0;    /* do this FIRST */
                http_prosecute( c );
/*
                if (c->status == status_FAIL_CONNECT ||
                    c->status == status_FAIL_REQUEST ||
                    c->status == status_FAIL_VERIFY ||
                    c->status == status_COMPLETED_FILE)
                {
                    http_socket_close(c);
                }
*/
            }
        }
    }

    threaded = 0;

    callback_pending = 0;

    return VIA_R14;

    UNUSED(pw);
}

static _kernel_oserror *setup_ticker_and_event(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *ep;

    r.r[0] = 0x10;
    r.r[1] = (int) &inetevent_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(XOS_Bit + OS_Claim, &r, &r);

    if (ep)
        return ep;

    _kernel_osbyte(14, Event_Internet, 0);

    r.r[0] = TICKER_RATE;
    r.r[1] = (int) timer_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(OS_CallEvery, &r, &r);

    if (ep)
    {
        clear_ticker_and_event();
        return ep;
    }

    return NULL;
}

static void clear_ticker_and_event(void)
{
    _kernel_swi_regs r;

    _kernel_osbyte(13, Event_Internet, 0);

    r.r[0] = 0x10;
    r.r[1] = (int) inetevent_entry;
    r.r[2] = (int) private_word;

    _kernel_swi(OS_Release, &r, &r);

    r.r[0] = (int) timer_entry;
    r.r[1] = (int) private_word;

    _kernel_swi(OS_RemoveTickerEvent, &r, &r);
}

static void setup_callback(void)
{
    if (callback_pending == 0 && threaded == 0)
    {
        _kernel_swi_regs r;

        r.r[0] = (int) &callback_entry;
        r.r[1] = (int) private_word;
        callback_pending = 1;

        _kernel_swi(OS_AddCallBack, &r, &r);
    }
}

static void clear_callback(void)
{
    if (callback_pending)
    {
        _kernel_swi_regs r;

        r.r[0] = (int) &callback_entry;
        r.r[1] = (int) private_word;
        callback_pending = 0;

        _kernel_swi(OS_RemoveCallBack, &r, &r);
    }
}


        /*=======================*/


_kernel_oserror *http_check_handle(http_connection *c)
{
    if (c == NULL || c->magic != HTTP_MAGIC)
    {
        return make_error(err_BAD_MAGIC);
    }

    return 0;
}

int http_file_size(char *fname)
{
    _kernel_osfile_block fb;

    if (_kernel_osfile(5, fname, &fb) != 1) /* If it is not a plain file */
        return -1;
    else
        return fb.start;
}

#ifndef mmmtype_MIME
#define mmmtype_RISCOS       0  /* file type as int */
#define mmmtype_RISCOSSTRING 1 /* file type as char* */
#define mmmtype_MIME         2 /* MIME content-type passed as a char* */
#define mmmtype_DOTEXTN      3 /* .xxx extension (don't pass the .) */
#endif

_kernel_oserror *http_set_file_type(http_connection *c, int *ftptr)
{
    _kernel_osfile_block fb;
    int result, ft;
    BOOL reopen = FALSE;

    fdebugf( log_file, "%p: checking out file type\n", c );

    if (c->fname)
    {
        http_header_item *hi;

        fb.load = FILETYPE_HTML;	/* the default type */

        for (hi = c->headers; hi != NULL; hi = hi->next)
        {

	    fdebugf( log_file, "%p: examining header %p, '%p: %p'\n",
		     c, hi, hi->key, hi->value );

	    fdebugf( log_file, "%p:   that is, \xAB%s: %s\xBB\n",
		     c, hi->key, hi->value );

            if (hi->key
		&& hi->value
		&& strcasecmp(hi->key, "CONTENT-TYPE") == 0)
            {
                char *semic = strchr( hi->value, ';' );

		fdebugf( log_file, "%p: calling mime_map_to_riscos(%s)\n",
			 c, hi->value );

                /* pdh: blat any "charset=foo" or what-have-you after the
                 * mime type itself
                 */
                if ( semic )
                    *semic = 0;
#if !USE_MIMEMAPMOD
                ft = mime_map_to_riscos(hi->value);
#else
		/* pdh: *much* simpler to do this, but I've left in the old
		 * way for now in case it's not appropriate for NCFresco. Also
		 * it didn't fix the bug I'd hoped it would.
		 */

		/* SWI XMimeMap_Translate */
		_swix( 0x70B00, _INR(0,2)|_OUT(3), mmmtype_MIME, hi->value,
		                                   mmmtype_RISCOS, &ft );
#endif
                /* pdh: remember to un-blat */
                if ( semic )
                    *semic = ';';

		fdebugf( log_file, "%p: map_to_riscos returns %d\n", c, ft );

                if (ft != -1)
                {
                    fb.load = ft;
                }
            }
        }

        fdebugf(log_file, "%p: setting file type of '%s' to 0x%03X\n",
                          c, c->fname, ft);

	if ( c->fh )
	{
	    reopen = TRUE;

	    ro_fclose( c->fh );
	    c->fh = NULL;
	}

        if (ftptr)
            *ftptr = fb.load;

         result = _kernel_osfile(18, c->fname, &fb);

	 if ( reopen )
	 {
	     c->fh = ro_fopen(c->fname, RO_OPEN_RW);
	 }

	 if ( result < 0 )
	    return _kernel_last_oserror();
    }
    return NULL;
}


/*-----------------------------------------------------------------------*
 * http_set_status                                                       *
 * Set the status of a connection, keeping sockets_connecting up to date *
 *-----------------------------------------------------------------------*/

static void http_set_status( http_connection *c, transfer_status status )
{
#if DEBUG
    if ( status != c->status )
    {
        char intst[8];
        char *st = intst;

        switch ( status )
        {
        case status_NEW: st = "new"; break;
        case status_WAITING: st = "waiting"; break;
        case status_GETTING_HEADERS: st = "getting-headers"; break;
        case status_GETTING_BODY: st = "getting-body"; break;
        case status_COMPLETED_PART: st = "completed-part"; break;
        case status_COMPLETED_FILE: st = "completed-file"; break;
        default:
            sprintf( intst, "%d", status );
        }
        fdebugf( log_file, "%p: status now %s\n", c, st );
    }
#endif

    if ( c->status > status_NEW && c->status < status_WAITING )
        sockets_connecting--;
    c->status = status;
    if ( c->status > status_NEW && c->status < status_WAITING )
        sockets_connecting++;
}


static void http_set_message( http_connection *c, char *text )
{
    if ( c->message )
        free( c->message );
    c->message = strdup( text );
}

static void http_oserror( http_connection *c, _kernel_oserror *e )
{
    if ( e )
    {
        fdebugf( log_file, "%p: *** Error, message is %s\n", c, e->errmess );
        http_set_message( c, e->errmess );
    }
    else
        fdebugf( log_file, "%p: *** Error with no error!\n", c );

    http_set_status( c, status_FAIL_LOCAL );
}

void http_copy_headers(http_header_item *h, http_header_item **new)
{
    *new = NULL;

    if (h == NULL)
        return;

    *new = malloc(sizeof(http_header_item));
    if (*new == NULL)
        return;

    (*new)->key = strdup(h->key);
    (*new)->value = strdup(h->value);

    http_copy_headers(h->next, &((*new)->next));
}

_kernel_oserror *http_free_headers(http_header_item *h)
{
    http_header_item *hn;

    while(h != NULL)
    {
        hn = h->next;
/*         fdebugf(log_file, "Freeing header line\n"); */

        if (h->key)
            free(h->key);
        if (h->value)
            free(h->value);

        free(h);
        h = hn;
    }

    return NULL;
}

/*-----------------------------------------------------------------------*
 * http_fail                                                             *
 * Set the failure code for a connection, but don't destroy it (wait for *
 * foreground to notice and close it)                                    *
 *-----------------------------------------------------------------------*/

static void http_fail( http_connection *c, transfer_status status )
{
    http_set_status( c, status );

    fdebugf( log_file, "%p: *** failing due to %d\n", c, status );

    if ( c->fh )
    {
        ro_fclose( c->fh );
        c->fh = NULL;
    }

    http_orphan_queue( c );
}


        /*=================================*
         *   http_prosecute                *
         *   The actual HTTP transaction   *
         *=================================*/


/* Connection passes through the following states, in order:
 *      status_NEW                  only in http_open
 *      status_AWAITING_CONNECTION  if it's on a queue
 *    + status_CONNECTING           waiting for connect to succeed
 *    + status_AUTHENTICATING       missed out if not HTTPS
 *    + status_REQUESTING           sending request
 *    + status_REQUEST_HEADERS      sending headers
 *    + status_REQUEST_BODY         missed out if not POST
 *      status_WAITING              getting response line
 *      status_GETTING_HEADERS
 *      status_GETTING_BODY
 *
 * It counts towards sockets_connecting if in a state marked +
 */

static _kernel_oserror *http_prosecute( http_connection *c )
{
    /*int needToRead = 1;*/  /* used in "line reading" states */
    char *l;            /* ditto */
    int rc;

/*     fdebugf(log_file,"http_prosecute status %d\n",c->status); */

    switch (c->status)
    {
    case status_CONNECTING:
        /* check to see if the connect has succeeded yet */
        rc = connect( c->socket, (struct sockaddr *) &(c->sa),
                      sizeof(struct sockaddr));

        if (rc > -1)
        {
            /* This should not happen, but we will catch it anyway */
            http_set_status( c, status_AUTHENTICATING );
            /* go on to drop through the outer switch */
        }
        else
        {
            switch(errno)
            {
            case EISCONN:
                /* The connection is through now */
                http_set_status( c, status_AUTHENTICATING );
                break;
            case EALREADY:
                /* The connection is still going through */
                /* Do nothing */
                return NULL;
            default:
                /* The connection failed */
                http_fail( c, status_FAIL_CONNECT );
                return NULL;
            }
        }
        /* status is status_AUTHENTICATING so we can drop through */

    case status_AUTHENTICATING:

#ifndef NO_SECURE
        if ( c->SSL )
        {
            verify_error = FALSE;
            rc = SSL_connect( c->SSL );

            if ( rc <= 0 )
            {
                if ( SSL_errno() == EWOULDBLOCK )
                    return NULL;    /* still trying */

		fdebugf( log_file, "%p: SSL_connect returned %d (errno=%d)\n", c, rc,
                               SSL_errno() );
#if DEBUG
		if (rc)
		{
		    fdebugf(log_file, "** crypto error log\n");
		    ERR_print_errors_fp(log_file);
		    fdebugf(log_file, "** end\n");
		}
#endif
                http_fail( c, verify_error ? status_FAIL_VERIFY
                                           : status_FAIL_REQUEST );
                return NULL;
            }

            fdebugf( log_file, "%p: SSL_connect returned %d (errno=%d)\n", c, rc,
                               SSL_errno() );

            /* Add some fake headers to provide SSL information */
            {
                X509 *peer = SSL_get_peer_certificate(c->SSL);
                char *cipher = SSL_get_cipher( c->SSL );

                if ( peer )
                {
                    char *str;

                        str=X509_NAME_oneline(X509_get_subject_name(peer));
                        /* str was allocated with malloc so we must free it*/
                        http_add_header_line( c, SSL_HEADER_CERT_SUBJECT,
                                              str );
			free(str);

                        str=X509_NAME_oneline(X509_get_issuer_name(peer));
                        http_add_header_line( c, SSL_HEADER_CERT_ISSUER,
                                              str );
			free(str);

                    X509_free(peer);
                }

                if ( cipher )
                    http_add_header_line( c, SSL_HEADER_CIPHER,
                                          cipher );

                http_add_header_line( c, SSL_HEADER_VERIFIED,
                                      SSL_verified(c->SSL) ? SSL_HEADER_YES : SSL_HEADER_NO  );
	    }
        }
#endif
        http_set_status( c, status_REQUESTING );
        /* fall through */

    case status_REQUESTING:
            http_send_request(c);
            if ( c->status != status_REQUEST_HEADERS )
                return NULL;
        /* else we can drop through */

    case status_REQUEST_HEADERS:
        rc = 0;
        while (c->status == status_REQUEST_HEADERS && rc != EWOULDBLOCK)
        {
            rc = http_send_request_headers(c);
        }
        if ( c->status != status_REQUEST_BODY )
            return NULL;
        /* else we can drop through */

    case status_REQUEST_BODY:
        rc = 0;
        while (c->status == status_REQUEST_BODY && rc != EWOULDBLOCK)
        {
            rc = http_send_request_body(c);
        }

        if ( c->status != status_WAITING )
            return NULL;
        /* else we can drop through */

    case status_WAITING:
        /* If we're in a queue, then don't try and read */
        if ( c->queueprev )
        {
            fdebugf( log_file, "%p: waiting for queueprev=%p to go NULL\n", c,
                     c->queueprev );
            return NULL;
        }

        /* Expecting a response line */
        l = http_getline(c, 1); /* Get the next line, doing a read */
        /*needToRead = 0;*/
        if (l)
            http_process_response_line(c, l);
        if ( c->status != status_GETTING_HEADERS )
            return NULL;
        /* else we can drop through */

    case status_GETTING_HEADERS:
        l = http_getline(c, 0/*needToRead*/);
        while (l && c->status == status_GETTING_HEADERS)
        {
                http_process_header_line(c, l);
                if (c->status == status_GETTING_HEADERS)
                    l = http_getline(c, 0);
        }
        if (c->status != status_GETTING_BODY)
            return NULL;

#if 0
	/* some kind of check is needed here but I don't know quite what */
	if ((c->flags & (http_open_flags_IMAGE | http_flags_RANGEBROKEN | http_flags_GOTFIRST)) ==
	    http_open_flags_IMAGE)
	{
	    http_set_server_flag( c, http_flags_RANGEBROKEN );
            fdebugf( log_file, "%p: BYTE RANGES ARE BROKEN (no CONTENT-RANGE))\n", c );
            http_requeue( c );
	    return NULL;
	}
#endif
        /* else we can drop through */

        rc = c->flags;

        /* If someone's in the queue behind us, they can write now
         * (but not read)
         *
         * HTTP/1.0 will send us a Connection: keep-alive if we're kept alive
         * HTTP/1.1 will send us a Connection: close      if we're *not*
         *
         * 20/5/97: pdh: Actually that only applies if we've sent a 1.1
         *          request, which we don't.
         */
        if ( /*(rc & http_flags_HTTP11) ?  ( rc & http_flags_NOTALIVE )
                                      :*/ !( rc & http_flags_KEPTALIVE ) )
            http_orphan_queue( c );
        else
            http_queue_allow_write( c );

    case status_GETTING_BODY:
#ifndef NO_SECURE
        if ( ( c->flags & http_flags_TUNNELLING )
             && (c->rc/100) == 2 )
        {
            /* Proxy negotiation has completed -- crack on with the SSL
             * handshake
             */

            fdebugf( log_file, "%p: starting up SSL connection\n", c );

            c->SSL = SSL_new( ssl_context );
            SSL_set_fd( c->SSL, c->socket );

            if ( c->flags & http_open_flags_VERIFY )
                SSL_set_verify( c->SSL, SSL_VERIFY_PEER,
                                &cert_verify_callback );
            else
                SSL_set_verify( c->SSL, SSL_VERIFY_NONE, NULL );

            c->flags &= ~http_flags_TUNNELLING;

            http_set_status( c, status_AUTHENTICATING );

            /* Complete flush of the six bytes of cack that BT is liable
             * to have sent us
             */
	    /* SJM: range use means we need this information! */
	    if ((c->flags & http_flags_GOTFIRST) == 0)
	    {
		c->data_so_far = 0;
		c->buf_off = 0;
		c->buf_used = 0;
	    }

            http_prosecute( c );
            return NULL;
        }
#endif
        /* Now idempotent and quick to return */
        http_flush_data_to_file(c);

        /* It's IMPORTANT that if status becomes COMPLETED_FILE then we drop
         * through and don't return: we don't want Partial Content replies to
         * appear as COMPLETED_FILE to SWI HTTP_Status, or else the client will
         * HTTP_Close them before their time.
         */

        while (1)
        {
            int block;

            if ( ( c->data_size > -1
                   && c->data_so_far == c->data_size
                   && !c->boundary )
                 || c->flags & http_open_flags_HEAD )
            {
                fdebugf( log_file, "%p: got all %d of my %d bytes (total=%d): file complete\n", c, c->data_size, c->data_so_far, c->total_size );
                http_set_status( c, status_COMPLETED_FILE );
                break;  /* from the while loop */
            }

            /* Still got some more to read */
            block = c->data_size - c->data_so_far;

            if ( block > TMP_BUF_SIZE || c->data_size < 0 || c->boundary )
                block = TMP_BUF_SIZE;

            if ( c->boundary != NULL && c->nearlyboundary > 0 )
            {
                char *buf = tmp_buffer + c->nearlyboundary;
                block -= c->nearlyboundary;

                memcpy( tmp_buffer, c->boundary, c->nearlyboundary );

                fdebugf( log_file, "%p: nearlyboundary=%d\n", c, c->nearlyboundary );

                rc = http_recv( c, buf, block );
            }
            else
                rc = http_recv( c, tmp_buffer, block );

            fdebugf(log_file, "%p: recv (body %d) gave %d\n", c, block, rc);

            if (rc <= 0)
            {
                if (rc == 0 || errno != EWOULDBLOCK)
                {
                    fdebugf(log_file, "%p: Connection closed on socket %d, errno=%d\n", c, c->socket, errno);
                    http_set_status( c, status_COMPLETED_FILE );

                    http_socket_close( c );

                    http_orphan_queue( c );
                }
                break; /* This is a break for the WHILE loop, not the switch */
            }

            if ( c->boundary )
            {
                int nearly;
                const char *bound;

                rc += c->nearlyboundary;
                c->nearlyboundary = 0;

                bound = memfind( tmp_buffer, rc, c->boundary, &nearly );

                if ( bound )
                {
                    int wrote = ro_fwritepos( tmp_buffer, bound - tmp_buffer, 1,
                                              c->fh, c->data_so_far );

                    if ( wrote < (bound - tmp_buffer) )
                    {
                        http_oserror( c, _kernel_last_oserror() );
                        return NULL;
                    }

                    c->data_so_far += wrote;

                    fdebugf( log_file, "%p: bound: setting so_far=%d\n", c,
                             c->data_so_far );

                    bound += strlen( c->boundary );

                    if ( *bound == '-' && bound[1] == '-' )
                    {
                        fdebugf(log_file, "%p: end of server push\n", c );

                        http_set_status( c, status_COMPLETED_FILE );
                        if ( c->flags &
                               (http_open_flags_IMAGE|http_flags_RANGEBROKEN ))
                        {
                            fdebugf( log_file, "%p: this image was wrecked\n",
				     c );
                            c->flags |= http_flags_GOTFIRST;
                            c->data_so_far = 0;
                            /* break from the while loop, then falls through
                             * the switch and requeues
                             */
                            break;
                        }
                        http_socket_close( c );
                        http_orphan_queue( c );
                        return NULL;
                    }
                    /* else there's more parts to come */

                    fdebugf(log_file, "%p: server push continues %d %d\n", c,
                                      *bound, bound[1] );

                    if ( *bound == 13 )
                        bound++;
                    if ( *bound == 10 )
                        bound++;            /* skip CR LF */

                    wrote = bound - tmp_buffer;

		    if ( wrote > rc )
		        wrote = rc;

                    memcpy( c->buffer, bound, rc - wrote );
                    c->buf_used = 0;
                    c->buf_off = rc - wrote;

                    fdebugf(log_file,"%p: server push stuffs %d bytes (%d %d %d)\n",
                             c, c->buf_off,
                             c->buffer[0], c->buffer[1], c->buffer[2] );

                    http_set_status( c, status_COMPLETED_PART );
                    return NULL;
                }
                else
                {
                    /* See whether there may be one straddling 2 packets */
		    if ( nearly != 0 )
		        fdebugf( log_file, "%p: nearly=%d\n", c, nearly );
                    c->nearlyboundary = nearly;
                    rc -= nearly;
                }
#if 0
		/* SJM: 26Aug97: Removed this bodge as it means that
		   the end of each part of a server push image doesn't
		   always get written out - and something crashes
		   eventually */

		/* pdh: bodge */
		break;
#endif
            }

            if (c->fh)
            {
                int wrote = ro_fwritepos( tmp_buffer, rc, 1, c->fh,
                                          c->data_so_far );
                if ( wrote < rc )
                {
                    http_oserror( c, _kernel_last_oserror() );
                    return NULL;
                }
            }

            c->data_so_far += rc;

/*             fdebugf( log_file, "%p: adding %d to so_far (now %d)\n",
                     c, rc, c->data_so_far ); */
        }

        if ( c->status != status_COMPLETED_FILE )
            return NULL;
        /* else we can drop through */

    case status_COMPLETED_FILE:
        if ( (c->flags & http_flags_GOTFIRST)
             && (c->data_so_far < c->total_size
                 || (c->flags & http_flags_RANGEBROKEN) ) )
        {
	    fdebugf( log_file, "%p: calling requeue so_far %d total %d RANGE %s\n",
		     c, c->data_so_far, c->total_size, c->flags & http_flags_RANGEBROKEN ? "BROKEN" : "OK" );
            http_requeue( c );
            return NULL;
        }
        else if ( c->socket != -1 )
        {
            /* We've still got a socket -- get rid of it if it's finished with
             */
            if ( c->flags & http_flags_NOTALIVE )
            {
                fdebugf( log_file, "%p: calling socket_close from status_c_f\n", c );
                http_socket_close( c );
                fdebugf( log_file, "%p: calling orphan_queue from status_c_f\n", c );
                http_orphan_queue( c );
            }
            else
            {
                fdebugf( log_file, "%p: calling allow read from status_c_f\n", c );
                http_queue_allow_read( c );
            }
            return NULL;
        }
        fdebugf( log_file, "%p: doing nothing in status_c_f (socket=%d queuenext=%p)\n", c, c->socket, c->queuenext );
#if DEBUG
        http_show_flags(c);
#endif

        break;

    default:
        break;
    }

    return NULL;
}

static _kernel_oserror *http_destroy( http_connection *c, int error )
{
    if ( c )
    {
        fdebugf( log_file, "%p: being closed by http_destroy(%d)\n", c, error );
        http_close_handle( c, 0 );
    }
    return make_error( error );
}

        /*===================*
         *   SWI HTTP_Open   *
         *===================*/


/* Forward references - opening connections */
static int http_open_socket( http_connection *c );
static BOOL http_queue_new( http_connection *me );

static _kernel_oserror *http_open(http_open_args *args)
{
    http_connection *new = NULL;
    int rc;
    http_open_args args2 = *args;
    BOOL bQueued;
#if PROXY_REDIRECT && !defined(NO_SECURE)
    _kernel_oserror *e;
#endif

    args->out.handle = NULL;

#if EXTEND_BUFFER
    new = malloc(sizeof(http_connection));
#else
    new = malloc(sizeof(http_connection) + MAX_INPUT);
#endif
    if (new == 0)
        return make_error(err_NO_MEMORY);

    fdebugf( log_file, "%p: New connection, host=0x%08lx, port=0x%04x (%d)\n",
                       new, args2.in.addr->sin_addr.s_addr,
                       args2.in.addr->sin_port, htons(args2.in.addr->sin_port));
    fdebugf( log_file, "%p:   object = '%s'\n", new, args2.in.object );
    fdebugf( log_file, "%p:   fname = '%s'\n", new, args2.in.fname?args2.in.fname:"NULL" );

    *new = proto_con;                /* Fill in with a prototype connection */

    memcpy((char *)&(new->sa),(char *) args2.in.addr,  sizeof(new->sa) );

    new->flags = args2.in.flags;

    new->object = strdup(args2.in.object);
    if (new->object == NULL)
    {
        return http_destroy(new,err_NO_MEMORY);
    }

#if PROXY_REDIRECT && !defined(NO_SECURE)
    /* If it feels neceesary this will update the addr and flags */
    if ((e = check_proxy_redirect(&new->sa, &new->flags, &new->object)) != NULL)
    {
	fdebugf( log_file, "%p: proxy redirect returns error '%s'\n", new, e->errmess );
	http_close_handle(new, 0);
	return e;
    }
#endif

    /* There appears to be a bug with restarting fetches and tunnelling proxies
    if (new->flags & http_open_flags_TUNNEL)
	new->flags &= ~http_open_flags_IMAGE;
     */

#if EXTEND_BUFFER
    new->buffer = malloc(MAX_INPUT);
    new->buf_size = MAX_INPUT;
#else
    new->buffer = (char*) (new + 1);
#endif
    new->buffer[0] = 0;

#ifdef CSFS
    if (new->flags & http_open_flags_ACTION)
      new->action = args->in.action;
    else
      new->action = 0;
#endif

#if DEBUG
    http_show_flags( new );
#endif

    /* If we're prepared only to get the first few bytes, we can run at
     * priority.
     */
    if ( (new->flags & http_open_flags_IMAGE)
         && (new->flags & http_flags_DOESRANGE)
         && !(new->flags & http_open_flags_HEAD)
         && !(args2.in.bname) )
        new->flags |= http_open_flags_PRIORITY;

    bQueued = http_queue_new( new );

    if ( bQueued )
    {
        http_set_status( new, status_AWAITING_CONNECTION );

        /* Nothing can come in and try and use this queued connection until
         * we've built the output file etc, 'cos we're a SWI and are in SVC
         * mode, and prosecute is called from a callback.
         */
    }
    else
    {
        fdebugf( log_file, "%p: New connection, own socket\n", new );
        rc = http_open_socket( new );           /* sets new->status */
        if ( rc != err_NO_ERROR )
            return http_destroy( new, rc );
    }

    /*
     * The connection process may take a little time.  So we go off and make
     * the data file and come back in a moment to check if we are done.
     */

    http_copy_headers(args2.in.headers, &(new->sendhead_base) );

    if (args2.in.fname == NULL)
    {
        args2.in.fname = tmpnam(NULL);
    }

    new->fname = strdup(args2.in.fname);
    if (new->fname == NULL)
    {
        return http_destroy(new,err_NO_MEMORY);
    }

    if ( new->flags & http_open_flags_HEAD )
        new->fh = NULL;
    else
    {
        fdebugf(log_file, "%p: http_open Opening file '%s'\n", new, new->fname);

        new->fh = ro_fopen(new->fname, RO_OPEN_WRITE);

        fdebugf( log_file, "%p: file handle is %d\n", new, new->fh );

        if (new->fh == NULL)
        {
            return http_destroy(new,err_CANT_OPEN_FILE);
        }
    }

    if (args2.in.bname)
    {
        new->bname = strdup(args2.in.bname);
        if (new->bname == NULL)
        {
            return http_destroy(new,err_NO_MEMORY);
        }

        fdebugf(log_file, "%p: http_open Opening body file '%s'\n", new, new->bname);

        new->bh = ro_fopen(new->bname, RO_OPEN_READ);
        if (new->bh == NULL)
        {
            return http_destroy(new,err_CANT_OPEN_BODY);
        }
    }

    new->next = http_cons_list;
    /* new->prev is set to NULL in the prototype */

    if (http_cons_list)
        http_cons_list->prev = new;
    http_cons_list = new;

    /* If we're lucky, the connection has succeeded while we were doing
     * all that, so check and see if we can move matters on.
     * If we were queued, check to see whether anyone's completed and
     * has a socket we can swipe.
     */
    if ( bQueued )
    {
        int i;
        http_connection *c;

        for ( i=0; i < FD_SETSIZE; i++ )
        {
            c = http_cons[i];
            if ( c && c->queue && c->queue->queue
                 && ( c->status == status_COMPLETED_FILE ) )
            {
                http_prosecute( c );
            }
        }
    }
    else
        http_prosecute( new );

    args->out.handle = new;
    return NULL;
}


/*------------------------------------------------------------------------*
 * http_show_flags                                                        *
 * Output all the flags set for the connection (debug).                   *
 *------------------------------------------------------------------------*/

#if DEBUG
static void http_show_flags( http_connection *c )
{
    int f = c->flags;
    fdebugf( log_file, "%p: flags: ", c );

    if ( f & http_open_flags_SECURE )   fdebugf( log_file, " SSL" );
    if ( f & http_open_flags_VERIFY )   fdebugf( log_file, " SSL-verify" );
    if ( f & http_open_flags_HEAD )     fdebugf( log_file, " head" );
    if ( f & http_open_flags_PRIORITY ) fdebugf( log_file, " priority" );
    if ( f & http_open_flags_IMAGE )    fdebugf( log_file, " image" );
    if ( f & http_open_flags_TOMEM )    fdebugf( log_file, " to-mem" );
    if ( f & http_open_flags_TUNNEL )   fdebugf( log_file, " tunnel-proxy" );
    if ( f & http_flags_HTTP11 )        fdebugf( log_file, " http-1.1" );
    if ( f & http_flags_KEPTALIVE )     fdebugf( log_file, " kept-alive" );
    if ( f & http_flags_NOTALIVE )      fdebugf( log_file, " not-alive" );
    if ( f & http_flags_DOESRANGE )     fdebugf( log_file, " does-range" );
    if ( f & http_flags_RANGEBROKEN )   fdebugf( log_file, " range-broken" );
    if ( f & http_flags_GOTFIRST )      fdebugf( log_file, " got-first" );
    if ( f & http_flags_CHUNKED )       fdebugf( log_file, " chunked" );
    if ( f & http_flags_TUNNELLING )    fdebugf( log_file, " tunnelling" );

    if ( !f )
        fdebugf( log_file, " none" );

    fdebugf( log_file, "\n" );
}
#endif


/*------------------------------------------------------------------------*
 * http_open_socket                                                       *
 * Open the socket for a connection (may not be done at http_open time if *
 * keep-alive is in effect). Returns an err_XXX value.                    *
 *------------------------------------------------------------------------*/

static int http_open_socket( http_connection *c )
{
    int rc, i;

    /* SJM: set the tunnelling flag here, so that it is always in step
       with the original request */
    if (c->flags & http_open_flags_TUNNEL)
	c->flags |= http_flags_TUNNELLING;

    if ( c->socket != -1 )
        fdebugf( log_file, "%p: *** open_socket called when socket=%d\n", c,
                           c->socket );

    c->socket = socket( AF_INET, SOCK_STREAM, 0 );

    if ( c->socket < 0 )
    {
        c->socket = -1;
        return err_CANT_MAKE_SOCKET;
    }

    /* SJM: 1/6/97: moved these two inc's here so that destroy works correctly */
    /* if socket == -1 then close_socket won't decrement them so they need to be after the
       check for socket() succeeding */
    totalsockets++;

    if ( c->queue )
    {
        c->queue->nsockets++;
        fdebugf( log_file, "%p: queue %p gains socket %d, total=%d\n", c,
                 c->queue, c->socket,
                 c->queue->nsockets );
    }

    i = 1;
    rc = socketioctl( c->socket, FIONBIO, &i );

    i = 1;
    if ( rc != -1 )
        rc = socketioctl( c->socket, FIOASYNC, &i );

    if ( rc < 0 )
        return err_BAD_IOCTL;

    rc = connect( c->socket, (struct sockaddr *) &(c->sa),
                  sizeof(struct sockaddr));

    /* Legal return values are:
     *
     *  EINPROGRESS(36) The connection process has been started but no result
     *                  as yet.
     *  EINVAL(22)      The connection process failed, either due to a timeout
     *                  or a rejection.
     *  EALREADY(37)    The connection process is still going on and may yet
     *                  finish.
     *  EISCONN(56)     The connection process succeeded and we are now
     *                  connected.
     */

    if (rc < 0 && errno != EINPROGRESS)
    {
        return err_CANT_CONNECT;
    }

    /* Create a SSL connection if required.
     */
    if ( c->flags & http_open_flags_SECURE )
    {
#ifdef NO_SECURE
        return err_SSL_NOT_AVAILABLE;
#else
        if ( !ssl_present )
            return err_SSL_NOT_AVAILABLE;

        /* If we're going through a tunnel proxy, we need to begin the
         * transaction in unsecure mode and only call SSL_connect() once
         * the proxy headers have been exchanged.
         */
        if ( !(c->flags & http_flags_TUNNELLING) )
        {
            c->SSL = SSL_new( ssl_context );
            SSL_set_fd( c->SSL, c->socket );

            if ( c->flags & http_open_flags_VERIFY )
                SSL_set_verify( c->SSL, SSL_VERIFY_PEER,
                                &cert_verify_callback );
            else
                SSL_set_verify( c->SSL, SSL_VERIFY_NONE, NULL );

#if DEBUG
	    bio_debug_open( c->SSL );
#endif
	}
#endif
    }

    http_set_status( c, status_CONNECTING );

    http_cons[c->socket] = c;

/*     totalsockets++; */

    fdebugf( log_file, "%p: opened new socket, %d, total is %d\n", c, c->socket,
             totalsockets );

/*     if ( c->queue ) */
/*     { */
/*         c->queue->nsockets++; */
/*         fdebugf( log_file, "%p: queue %p gains socket %d, total=%d\n", c, */
/*                  c->queue, c->socket, */
/*                  c->queue->nsockets ); */
/*     } */

    c->onthissocket = 1;

    return err_NO_ERROR;
}


/*------------------------------------------------------------------------*
 * http_queue_new                                                         *
 * See whether there's a connection currently open which we could         *
 * potentially re-use.                                                    *
 *------------------------------------------------------------------------*/

#define RELEVANT_FLAGS ( http_open_flags_SECURE | http_open_flags_VERIFY | \
                         http_flags_TUNNELLING )

static BOOL http_queue_new( http_connection *me )
{
    http_queue *q = http_queues_list;
    http_connection *c;

    /* Find the queue for this server */
    while ( q )
    {
        if ( !memcmp( &me->sa, &q->sa, sizeof( struct sockaddr ) )
             && ( (me->flags & RELEVANT_FLAGS) == (q->flags & RELEVANT_FLAGS) ) )
        {
            /* Found a suitable queue */
            me->queue = q;

            if ( ( q->nsockets < 2
                   && totalsockets < maxsockets )
                 || ( me->flags & http_open_flags_PRIORITY ) )
                    return FALSE;   /* Open another one */

            /* Add me to the queue
            if ( me->flags & http_open_flags_PRIORITY )
            {
                me->queueprev = NULL;
                me->queuenext = q->queue;
                if ( q->queue )
                    q->queue->queueprev = me;
                q->queue = me;
            }
            else */
            {
                /* Add to the end of the queue */
                c = q->queue;

                if ( c )
                {
                    while ( c->queuenext )
                        c = c->queuenext;

                    c->queuenext = me;
                    me->queueprev = c;
                }
                else
                {
                    q->queue = me;
                    me->queueprev = NULL;
                }
                me->queuenext = NULL;
            }

            return TRUE;
        }

        q = q->next;
    }

    /* No queue found, build a new one */

    q = (http_queue*) malloc( sizeof( http_queue ) );

    /* If malloc failed, give up */
    if ( q )
    {
        q->nsockets = 0;
        memcpy( &q->sa, &me->sa, sizeof( struct sockaddr ) );
        q->flags = me->flags;
        q->queue = NULL;
        q->next = http_queues_list;
        if ( q->next )
            q->next->prev = q;
        q->prev = NULL;
        http_queues_list = q;
        me->queue = q;
    }

    /* We always open a socket to a new server, even if totalsockets is
     * already maxsockets or more
     */
    return FALSE;
}


/*--------------------------------------------------------------------------*
 * http_from_queue                                                          *
 * Get the next waiting transaction from the queue (not very important, but *
 * it's duplicated code).                                                   *
 *--------------------------------------------------------------------------*/

static http_connection *http_from_queue( http_connection *c )
{
    http_connection *c2 = c->queuenext; /* A half-finished connection?... */

    if ( c2 )
        fdebugf( log_file, "%p: from_queue: returning queuenext: %p\n", c, c2 );

    if ( !c2 )                          /* ...if not, get one from the queue */
    {
        http_queue *q = c->queue;
        if ( q )
        {
            c2 = q->queue;
            if ( c2 )
            {
                fdebugf( log_file, "%p: from_queue: swiping %p from queue %p\n",
                                   c, c2, q );
                q->queue = c2->queuenext;
                q->queue->queueprev = NULL;
                c2->queuenext = NULL;
            }
            else
                fdebugf( log_file, "%p: from_queue: queue %p empty\n", c, q );
        }
        else
            fdebugf( log_file, "%p: from_queue: no queuenext and no queue\n", c );
    }
    return c2;
}


/*--------------------------------------------------------------------------*
 * http_orphan_queue                                                        *
 * Having decided that keep-alive isn't going to happen, open a new socket  *
 * for anything waiting for ours to come free. Note that we *may* be called *
 * after allow_write, but shouldn't be called after allow_read.             *
 *     orphan_queue *must* set c->queue to NULL if it makes a new socket    *
 * (so it's never called twice on the same connection, which would violate  *
 * the Principle of Conservation of Sockets).                               *
 *--------------------------------------------------------------------------*/

static void http_orphan_queue( http_connection *c )
{
    http_connection *c2;

    /* Make sure noone else comes in */
    c->flags |= http_flags_NOTALIVE;

    /* Limit number of sockets, unless this is the last socket open on its
     * queue.
     */
    if ( (c->socket != -1) && totalsockets >= maxsockets
         && ( !c->queue || !c->queue->queue || c->queue->nsockets > 0 ) )
    {
        fdebugf( log_file,"%p: not orphaning queue 'cos of socket limit\n", c );
        return;
    }

    fdebugf( log_file, "%p: orphaning queue\n", c );

    c2 = http_from_queue( c );

    c->queuenext = NULL;

    if ( !c2 )
        return;

    c2->queueprev = NULL;

    fdebugf( log_file, "%p: Orphaning queued connection %p\n", c, c2 );

    /* Open socket */
    if ( http_open_socket( c2 ) != err_NO_ERROR )
    {
        /* There was an error, but we can't return it */
        http_fail( c2, status_FAIL_CONNECT );
    }

    /* Disconnect from queue -- do this *after* opening the new socket, so
     * q->nsockets doesn't go to zero.
     */
    http_queue_dec_nsockets( c );
    c->queue = NULL;
}


/*--------------------------------------------------------------------------*
 * http_queue_allow_write                                                   *
 * We've finished writing to our socket, so the next request can start.     *
 *--------------------------------------------------------------------------*/

static void http_queue_allow_write( http_connection *c )
{
    http_connection *c2 = http_from_queue( c );

    if ( !c2 )
        return;

    c2->queueprev = c;
    c->queuenext = c2;      /* from_queue followed by this is idempotent in
                             * the case c2 is *already* c->queuenext
                             */

    if ( c2->status != status_AWAITING_CONNECTION )
        return;     /* already been done */

    fdebugf( log_file, "%p: handing socket %d writes over to %p\n", c,
                        c->socket, c2 );

    c2->onthissocket = c->onthissocket+1;

    c2->socket = c->socket;     /* Shared, not transferred */

#ifndef NO_SECURE
    c2->SSL = c->SSL;           /* Shared, not transferred */
#endif

    http_set_status( c2, status_REQUESTING );
    http_prosecute( c2 );
}


/*--------------------------------------------------------------------------*
 * http_queue_allow_read                                                    *
 * We've finished with our socket now, so, if anyone's waiting, they can    *
 * have it. allow_write may have been called, but may not.                  *
 *--------------------------------------------------------------------------*/

static void http_queue_allow_read( http_connection *c )
{
    http_connection *c2;
#if 0
    int rc;
    char foo[4];

    /* Note this does the Right Thing even in the SSL case */
    rc = recv( c->socket, foo, 4, MSG_PEEK );
    fdebugf( log_file, "%p: allow_read: rc=%d errno=%d\n",c, rc, errno );

    if ( rc < 0 && errno != EWOULDBLOCK )
    {
        fdebugf( log_file,
                 "%p: invalid socket in allow_read, orphaning instead\n", c );
        http_socket_close( c );
        http_orphan_queue( c );
        return;
    }
#endif

    c2 = http_from_queue( c );
    if ( !c2 )
    {
        /* Close the socket for tidiness' sake *only* if we're already dead */
        if ( c->flags & http_flags_NOTALIVE )
            http_socket_close( c );
        return;
    }

    /* Note that because of partial fetching, we must cope with the case c2==c
     */
    c->queuenext = NULL;
    c2->queueprev = NULL;

    fdebugf( log_file, "%p: handing socket %d reads over to %p\n", c,
                       c->socket, c2 );

    c2->onthissocket = c->onthissocket+1;

    keptalive++;

    c2->socket = c->socket;

#ifndef NO_SECURE
    c2->SSL    = c->SSL;
#endif

    /* Make sure noone else comes in */
    if ( c2 != c )
    {
        c->flags |= http_flags_NOTALIVE;
        c->socket = -1;
#ifndef NO_SECURE
        c->SSL = NULL;
#endif
    }

    http_cons[ c2->socket ] = c2;

    if ( c2->status == status_AWAITING_CONNECTION )
        http_set_status( c2, status_REQUESTING );

    fdebugf( log_file, "%p: just got reads, status is %d\n", c2, c2->status );

    /* otherwise, allow_write has been called and it's on its way already */
    http_prosecute( c2 );
}


/*--------------------------------------------------------------------------*
 * http_requeue                                                             *
 * We've fetched the first few bytes of an image, so requeue it (at a lower *
 * priority) to get the other bits.                                         *
 *--------------------------------------------------------------------------*/

static void http_requeue( http_connection *c )
{
    http_queue *q = c->queue;
    http_connection *qptr;

    http_free_headers( c->headers );
    c->headers = NULL;

    if ( !q || (!q->queue && !c->queuenext)
         || ( c->flags & http_flags_NOTALIVE ) )
    {
        fdebugf( log_file, "%p: restarting\n", c );

        if ( c->flags & http_flags_NOTALIVE )
        {
            http_socket_close( c );
        }

        c->flags &= http_open_flags_ALLUSER | http_flags_SERVER
                    | http_flags_GOTFIRST;

        if ( c->flags & http_flags_RANGEBROKEN )
            c->flags &= ~http_flags_GOTFIRST;

        if ( c->socket == -1 )
        {
            /* Must start a new connection */
            http_open_socket( c );
        }
        else
            http_set_status( c, status_REQUESTING );

        return;
    }

    fdebugf( log_file, "%p: requeueing\n", c );

    http_queue_allow_read( c );

    c->flags &= http_open_flags_ALLUSER | http_flags_SERVER
                | http_flags_GOTFIRST;

    if ( c->flags & http_flags_RANGEBROKEN )
        c->flags &= ~http_flags_GOTFIRST;


    /* Add to end of queue */
    qptr = q->queue;
    if ( qptr )
    {
        while ( qptr->queuenext )
            qptr = qptr->queuenext;

        qptr->queuenext = c;
        c->queueprev = qptr;
    }
    else
    {
        q->queue = c;
        c->queueprev = NULL;
    }
    c->queuenext = NULL;
    http_set_status( c, status_AWAITING_CONNECTION );
}


        /*====================*
         *   SWI HTTP_Close   *
         *====================*/


static _kernel_oserror *http_close(http_close_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    fdebugf( log_file, "%p: being closed by SWI http_close (socket %d)\n", c,
             c->socket );

    return http_close_handle(c, args->in.flags);
}

_kernel_oserror *http_close_handle(http_connection *c, int flags)
{
    /* Note that we DO free the outgoing headers as we've taken copies of
     * them !!
     */

    fdebugf( log_file, "%p: being closed by SWI http_close (socket %d)\n", c,
             c->socket );

    /* Unlink from queue. If we're at the head of the queue, and not being
     * shut down completely, orphan the rest of the queue.
     */
    if ( c->queueprev )
    {
        /* Easy case -- mid-queue */
        if ( c->queuenext )
            c->queuenext->queueprev = c->queueprev;
        c->queueprev->queuenext = c->queuenext;

        if ( ( c->socket > -1 )
            && c->status > status_CONNECTING )
        {
            /* If we've sent a request down this socket then its current
             * owner will be unable to send a further request down it.
             */
            c->queueprev->flags |= http_flags_NOTALIVE;
        }

        /* Don't close the socket! We don't own it! */
        c->socket = -1;
    }
    else
    {
        /* Head of the queue. 2 cases: active and queued */
        if ( c->queue && c->queue->queue == c )
        {
            /* We were stuck in the queue anyway */
            c->queue->queue = c->queuenext;

            if ( c->queue->queue )
                c->queuenext->queueprev = NULL;
            c->queuenext = NULL;
            c->queueprev = NULL;
        }
        else
        {
            /* We were active */
            if ( flags & http_close_FATAL )
            {
                if ( c->queuenext )
                    c->queuenext->queueprev = NULL;
            }
            else
            {
                if ( c->socket != -1 )
                {
                    /* We must check the status here, it's no good passing on
                     * a socket that's in the middle of a GIF fetch!
                     */
                    if ( c->flags & http_flags_NOTALIVE
                         || ( c->status < status_COMPLETED_FILE ) )
                    {
                        /* Close the socket first so that we know orphan_queue
                         * is allowed to create a new one
                         */
                        http_socket_close( c );
                        http_orphan_queue( c );
                    }
                    else
                        http_queue_allow_read( c );
                }
            }
        }
    }

    http_set_status( c, status_FINISHING );  /* sort out sockets_connecting */

#if 0 /* ndef NO_SECURE SJM: moved into socket_close */
    if ( c->SSL != NULL )
    {
        fdebugf( log_file, "Closing SSL connection\n" );
        SSL_free( c->SSL );
    }
#endif

/*  http_cons[c->socket] = NULL; */

    if (c->fh != NULL)
    {
        fdebugf(log_file, "Closing output file\n");
        ro_fclose(c->fh);
	c->fh = NULL;
    }

    if (c->bh != NULL)
    {
        fdebugf(log_file, "Closing body file\n");
        ro_fclose(c->bh);
	c->bh = NULL;
    }

    /* Do this one first in case someone is stupid enough to set the type and
     * then delete
     */
    if (flags & http_close_SET_TYPE)
    {
        http_set_file_type(c, NULL);
    }

    if (flags & http_close_DELETE_FILE)
    {
        if (c->fname)
        {
            fdebugf(log_file, "Removing file '%s'\n", c->fname);
            remove(c->fname);
        }
    }

    if (flags & http_close_DELETE_BODY)
    {
        if (c->bname)
        {
            fdebugf(log_file, "Removing file '%s'\n", c->bname);
            remove(c->bname);
        }
    }

    http_socket_close(c); /* Does its own check for valid socket number */

    if (c->fname)
    {
        free(c->fname);
    }

    if (c->bname)
    {
        free(c->bname);
    }

    if (c->message)
    {
        free(c->message);
    }

    if (c->object)
    {
        free(c->object);
    }

    http_free_headers(c->headers); /* Does its own check for NULL pointers */
    http_free_headers(c->sendhead_base);

    /* Finally, zap the magic number */
    c->magic = 0;

    fdebugf(log_file, "Unlinking from list\n");

    if (c->prev == NULL)
        http_cons_list = c->next;
    else
        c->prev->next = c->next;

    if (c->next != NULL)
        c->next->prev = c->prev;

#if EXTEND_BUFFER
    if (c->buffer)
    {
	free(c->buffer);
    }
#endif

    fdebugf(log_file, "Freeing connection structure\n");
    free(c);

    fdebugf(log_file, "Connection closed.\n");

    return 0;
}


        /*=================*
         *   Other SWIs    *
         *=================*/


static _kernel_oserror *http_status(http_status_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    if ( c->status == status_FAIL_LOCAL )
    {
        httperror.errnum = 1;
        strcpy( httperror.errmess, c->message );
        return &httperror;
    }

    /* Lie to people about the state of requeued connections */
    if ( (c->flags & http_flags_GOTFIRST)
         && c->status < status_GETTING_BODY )
        args->out.status = status_GETTING_BODY;
    else
        args->out.status = c->status;

    args->out.ro_fh = c->fh ;
    args->out.fname = c->fname ;
    args->out.data_size = c->total_size ? c->total_size : c->data_size ;
    args->out.data_so_far = c->data_so_far ;
    args->out.headers = c->headers ;

    if ( c->rc == 206
         && c->data_so_far == c->total_size )
        args->out.rc = 200;     /* "OK" */
    else
        args->out.rc = c->rc;

    args->out.message = c->message ;

    return NULL;
}

static _kernel_oserror *http_maptoriscos(http_maptoriscos_args *args)
{
#if USE_MIMEMAPMOD
    /* SWI XMimeMap_Translate */
    return _swix( 0x70B00, _INR(0,2)|_OUT(3), mmmtype_MIME, args->in.extn,
		  mmmtype_RISCOS, &arg->out.ft );
#else
    args->out.ft = mime_map_to_riscos(args->in.extn);
    return NULL;
#endif
}

static _kernel_oserror *http_mapfromriscos(http_mapfromriscos_args *args)
{
#if USE_MIMEMAPMOD
    static char result[128];

    /* SWI XMimeMap_Translate */
    return _swix( 0x70B00, _INR(0,3)|_OUT(3), mmmtype_RISCOS, args->in.ft,
		  mmmtype_MIME, result,
		  &arg->out.extn );
#else
    args->out.extn = mime_map_from_riscos(args->in.ft);
#endif
    return NULL;
}

static _kernel_oserror *http_setfiletype(http_setfiletype_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    return http_set_file_type(c, &args->out.ftype);
}


/*--------------------------------------------------------------------------*
 * SWI HTTP_CompletedPart                                                   *
 * Client has finished dealing with the current part of a server-push       *
 * document, so it's time to pile on and get the next part.                 *
 *--------------------------------------------------------------------------*/

static _kernel_oserror *http_completedpart( http_completedpart_args *args )
{
    http_connection *c;
    _kernel_oserror *ep;
    char *fname = args->in.newfname;
    int flags = args->in.flags;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    if ( c->status != status_COMPLETED_PART )
        return make_error( err_NOT_WAITING );

    /* Get rid of the existing file if required */

    if ( fname )
    {

        if (c->fh != NULL)
        {
            fdebugf(log_file, "%p: closing output file %d in completedpart\n", c, c->fh);
            ro_fclose(c->fh);
            c->fh = NULL;
        }

	fdebugf(log_file, "%p: close file succeeded\n",c );

        if (flags & http_close_SET_TYPE)
	{
	    fdebugf( log_file, "%p: setting file type\n", c );
            http_set_file_type(c, NULL);
	    fdebugf( log_file, "%p: set type succeeded\n", c );
	}

        if ( flags & http_close_DELETE_FILE )
        {
            fdebugf(log_file, "%p: removing file '%s'\n", c, c->fname);
            remove(c->fname);
        }
        free( c->fname );

        /* Make a new file */

        c->fname = strdup(fname);
        if (c->fname == NULL)
            return http_destroy(c,err_NO_MEMORY);

        fdebugf(log_file, "%p: http_completed_part opening file '%s'\n", c, c->fname);
        c->fh = ro_fopen(c->fname, RO_OPEN_WRITE);

	fdebugf(log_file, "%p:   file handle %d\n", c, c->fh );

        if (c->fh == NULL)
            return http_destroy(c,err_CANT_OPEN_FILE);
    }
    else
    {
        /* We reuse the existing file... actually this needs no code here! */
    }

    /* Send it on its way */

    c->data_so_far = -1;
    c->data_size = -1;

    fdebugf( log_file, "%p: setting so_far=-1 in completedpart\n", c );

    http_set_status( c, status_GETTING_HEADERS );

    http_prosecute( c );

    return NULL;
}


void http_send_request(http_connection *c)
{
    char *meth = c->bh ? "POST " :
                 (c->flags & http_open_flags_HEAD ) ? "HEAD "
                                                    : "GET ";
    int len;
    char *s, *obj;
    
#ifndef NO_SECURE
    /* semi-bodge */
    if ( c->flags & http_flags_TUNNELLING
         && !c->SSL )
    {
        char *host = c->object + 8; /* "https://" */
        char *slash = strchr( host, '/' );
        char *colon = strchr( host, ':' );

        if ( !slash )
            slash = host + strlen(host);

        sprintf( tmp_buffer, "CONNECT %.*s%s HTTP/1.0\r\n\r\n", slash-host,
                 host,
                 (colon && colon<slash) ? "" : ":443" );

        http_send( c, tmp_buffer, strlen(tmp_buffer) );

        fdebugf( log_file, "%p: sending request %s", c, tmp_buffer );

#if 0	/* SJM: don't strip object down here as we may want to reuse it */
        strcpy( tmp_buffer, slash );
        if ( !*tmp_buffer )
            strcpy( tmp_buffer, "/" );
        free( c->object );
        c->object = strdup( tmp_buffer );
#endif

        http_set_status( c, status_WAITING );
        return;
    }
#endif

    /* get ptr to the object we will use */
#ifndef NO_SECURE
    /* SJM: if tunnelling then skip to path */
    if (c->SSL && (c->flags & http_open_flags_TUNNEL))
    {
        char *slash = strchr(c->object + 8, '/' );
	obj = slash ? slash : "/";
    }
    else
#endif
    {
	obj = c->object;
    }

    /* get length needed for header */
    len = strlen(meth) + strlen(obj) + 1 + strlen(http_version) + 2;

    /* malloc space if it won't fit in the buffer */
    s = tmp_buffer;
    if (len >= sizeof(tmp_buffer))
	s = malloc(len + 1);

    sprintf( s, "%s%s %s\r\n", meth, obj, http_version);

    fdebugf( log_file, "%p: sending %d request %s\n", c, c->onthissocket, s);
    
    /* Note there's an assumption here that we can send the whole request
     * line without getting an EWOULDBLOCK.
     */
    if (http_send(c, s, strlen(s) ) < 0)
    {
        http_fail( c, status_FAIL_REQUEST );
    }
    else
    {
        http_set_status( c, status_REQUEST_HEADERS );
        c->sendhead = c->sendhead_base;
    }

    if (s != tmp_buffer)
	free(s);
}


/*---------------------------------------------------------------------------*
 * http_send_request_headers                                                 *
 * Sends as many header lines as it can. Returns 0 if it gave up (all sent,  *
 * or network error), EWOULDBLOCK otherwise.                                 *
 *---------------------------------------------------------------------------*/

int http_send_request_headers( http_connection *c )
{
    int rc;

    while ( c->status == status_REQUEST_HEADERS )
    {
        if ( c->sendhead )
        {
	    int len = strlen(c->sendhead->key) + 2 + strlen(c->sendhead->value) + 2 ;
	    char *s = tmp_buffer;

	    if (len >= sizeof(tmp_buffer))
		s = malloc(len + 1);
	    
	    sprintf( s, "%s: %s\r\n", c->sendhead->key, c->sendhead->value );
	    rc = http_send(c, s, len);

	    if (s != tmp_buffer)
		free(s);	    

            fdebugf( log_file, "%p: (7) txheader %s: %s\n", c, c->sendhead->key,
                               c->sendhead->value );
        }
        else
        {
            /* end of supplied headers -- send Content-Length if reqd */
            *tmp_buffer = 0;

#if DEBUG
            http_show_flags(c);
#endif

            if (c->bh)
            {
                if (c->data_size == -1)
                    c->data_size = http_file_size(c->bname);
                sprintf(tmp_buffer, "Content-length: %d\r\n", c->data_size);
#if ADD_CRLF
		c->data_size += 2;
#endif
                fdebugf( log_file, "(7) %p: txheader Content-length: %d\n",
                                   c, c->data_size );
            }

            /* Don't send keep-alive to proxies unless they do HTTP/1.1
             * (for rationale see RFC2068)
             */
            if ( (c->flags & http_flags_HTTP11)
                 || !strchr( c->object, ':' ) )
            {
                strcat( tmp_buffer, "Connection: Keep-Alive\r\n" );
                fdebugf( log_file, "(7) %p: txheader Connection: Keep-Alive\n", c );
            }

            /* If this is an image, and isn't a priority (ie isn't the
             * background image), and is a normal fetch, only ask for the first
             * few bytes. If we've already had the first few bytes, ask for
             * the remainder.
             */
            if ( c->flags & http_flags_GOTFIRST
                 && !(c->flags & http_flags_RANGEBROKEN) )
            {
                /* Unbelievably, F**kWitScape Enterprise Server gets it wrong
                 * if you ask it for "bytes=256-" ... it only gives you 1000
                 * bytes even if there are more.
                 */
                char *ptr = tmp_buffer + strlen( tmp_buffer );

                sprintf( ptr, "Range: bytes=" IMAGE_HEADER1_T "-%d\r\n",
                              c->total_size-1 );
                fdebugf( log_file, "%p: (7) txheader Range: bytes=" IMAGE_HEADER1_T
                                   "-%d\n", c, c->total_size-1 );
                c->flags &= ~http_open_flags_IMAGE;
            }
            else if ( ( c->flags & http_open_flags_IMAGE )
                      && !( c->flags & ( http_open_flags_HEAD
                                         | http_flags_RANGEBROKEN ) )
                      && !c->bh )
            {
                strcat( tmp_buffer, "Range: bytes=0-" IMAGE_HEADER_T "\r\n" );
                fdebugf( log_file, "%p: (7) txheader Range: bytes=0-"
                                   IMAGE_HEADER_T "\n", c );
            }
            else
                c->flags &= ~http_open_flags_IMAGE;

            /* open_flags_IMAGE is now true ONLY if we've sent the range:
             * header
             */

            strcat(tmp_buffer, "\r\n");

	    /* SJM: moved call inside */
	    rc = http_send( c, tmp_buffer, strlen(tmp_buffer) );
        }

        if ( rc < 0 )
        {
            if ( errno != EWOULDBLOCK )
            {
                http_fail( c, status_FAIL_REQUEST );
                return 0;
            }
            return EWOULDBLOCK;
        }

        if ( c->sendhead )
            c->sendhead = c->sendhead->next;
        else
        {
            /* all done; set up request body if there is one */
            if ( c->bh )
            {
                http_set_status( c, status_REQUEST_BODY );
                ro_fread(c->buffer, 1,
                         c->data_size > MAX_INPUT ? MAX_INPUT : c->data_size,
                         c->bh);
                c->data_so_far = 0;

#if ADD_CRLF
		/* this goes wrong if data_size = MAX_INPUT+1 ! */
		if (c->data_size <= MAX_INPUT)
		{
		    char *s = c->buffer + c->data_size - 2;
		    *s++ = '\r';
		    *s++ = '\n';
		}
#endif
                fdebugf( log_file, "%p: setting so_far=0 in sendrh\n", c );
            }
            else
            {
                http_set_status( c, status_WAITING );
            }
        }
    }
    return 0;
}

/* Returns 0 if data was sent or the connection died, EWOULDBLOCK if it would block */
int http_send_request_body(http_connection *c)
{
    int sent;
    int to_go;

    /* This is always entered with the c->buffer as full as it can be,
     * c->data_size the size of the file to be sent and c->data_so_far
     * the amount of data sent to far.
     */

    fdebugf(log_file, "Sending data: so far %d of %d\n", c->data_so_far, c->data_size);

    to_go = c->data_size - c->data_so_far;

    if (to_go > 0)
        sent = http_send(c, c->buffer, to_go > MAX_INPUT ? MAX_INPUT : to_go );
    else
        sent = 0;

    if ( sent < 0)
    {
        if (errno != EWOULDBLOCK)
        {
            http_fail( c, status_FAIL_REQUEST );
        }
        else
        {
            /* If it would block then just return */
            return EWOULDBLOCK;
        }
    }
    else
    {
        c->data_so_far += sent;
        to_go -= sent;

        if (to_go > 0)
        {
            if (sent != MAX_INPUT)
                memmove(c->buffer, c->buffer + sent, MAX_INPUT - sent);

            ro_fread(c->buffer + MAX_INPUT - sent, 1, sent > to_go ? to_go : sent, c->bh);
#if ADD_CRLF
	    if (sent >= to_go)
	    {
		char *s = c->buffer + MAX_INPUT - sent + to_go - 2;
		*s++ = '\r';
		*s++ = '\n';
	    }
#endif
	}
        else
        {
            c->data_size = c->data_so_far = -1;

            fdebugf( log_file, "%p: setting so_far=-1 in sendrb\n", c );
            http_set_status( c, status_WAITING );
        }
    }

    return 0;
}

/*
 * Read some more data from the line and return the next line of data
 */
char* http_getline(http_connection *c, int readResponse)
{
    char *end;
    int rc = 1;     /* any non-zero value */
#if EXTEND_BUFFER
    int buf_size = c->buf_size;
#else
    int buf_size = MAX_INPUT;
#endif
    
    fdebugf(log_file, "%p: getline buf_size %d buf_off %d buf_used %d\n", c, c->buf_size, c->buf_off, c->buf_used );

    if (c->buf_used)
    {
        memmove(c->buffer, c->buffer + c->buf_used, c->buf_off - c->buf_used + 1);
        c->buf_off -= c->buf_used;
        c->buf_used = 0;
    }

#if EXTEND_BUFFER
    /* need to loop to ensure that all the data is read from the internet module
     * It only loops if the input buffer is full after reading a batch of data so
     * it can check if there is still data waiting to be read after we've extended
     * the input buffer.     
     */
    for (;;)
#endif
    {
	/* pdh: might as well always read it */
	if ( buf_size - c->buf_off - 1 > 0 )
	{
	    /* pdh: for the insecure prefix to a tunnelled conversation, peek
	     * don't read
	     if ( (c->flags & http_open_flags_TUNNEL)
             && !c->SSL )
	     {
	     rc = recv(c->socket,c->buffer + c->buf_off,
	     buf_size - c->buf_off - 1, MSG_PEEK);
	     if ( rc>0 )
	     fdebugf( log_file, "%p: peeked %d bytes\n", c, rc );
	     }
	     else
	    */
            rc = http_recv( c, c->buffer + c->buf_off,
                            buf_size - c->buf_off - 1);

	    if ( rc==0 )
	    {
		fdebugf(log_file, "%p: EOF in getline (%d chars)\n", c,c->buf_off );

		if ( c->buf_off == 0 )
		{
		    if ( c->onthissocket > 1 )
		    {
			/* We may have been thrown off.
			 * *CAREFUL* not to cause infinite loops here, the
			 * use of onthissocket makes sure of it.
			 */
			fdebugf( log_file,
				 "%p: server lied about keep-alive\n", c );

			/* Don't let socket_close delete the queue! */
			if ( c->queue )
			    c->queue->nsockets++;

			http_socket_close( c );

			c->flags &= ( http_open_flags_ALLUSER | http_flags_SERVER
				      | http_flags_GOTFIRST );

			http_open_socket( c );

			c->onthissocket = 1;

			if ( c->queue )
			    c->queue->nsockets--;
		    }
		    else
		    {
			http_fail( c, status_FAIL_REQUEST );
		    }
		    return NULL;
		}
	    }

	    if ( rc < 0 )
	    {
		if (errno != EWOULDBLOCK)
		{
		    if ( errno == ECONNRESET )
		    {
			/* This is Netscape's ever-so-polite way of telling us
			 * not to do any more fetches down this socket
			 */
			fdebugf( log_file,
				 "%p: ECONNRESET, retrying on new socket\n", c );

			/* Don't let socket_close delete the queue! */
			if ( c->queue )
			    c->queue->nsockets++;

			http_socket_close( c );

			c->flags &= ( http_open_flags_ALLUSER | http_flags_SERVER
				      | http_flags_GOTFIRST );

			http_open_socket( c );

			if ( c->queue )
			    c->queue->nsockets--;
		    }
		    else
		    {
			fdebugf( log_file, "%p: *** failed in getline (errno=%d)\n",
				 c, errno );

			http_fail( c, status_FAIL_REQUEST );
		    }
		    return NULL;
		}
	    }
	    else
	    {
#if DEBUG
		fdebugf(log_file, "%p: read %d bytes\n", c, rc);
		dump(log_file, c->buffer + c->buf_off, rc);
#endif
		c->buf_off += rc;
	    }
	}

	/* pdh: moved this termination outside the if */
	c->buffer[c->buf_off] = 0; /* Make use we always have a NULL at the end */
	end = strchr(c->buffer, '\n');

	if (end)
	{
	    c->buf_used = (end - c->buffer) + 1;

	    /* pdh: for the insecure prefix to a tunnelled conversation, we know
	     * we want to read this much now
	     if ( (c->flags & http_open_flags_TUNNEL)
             && !c->SSL )
	     {
	     recv( c->socket, c->buffer, c->buf_used, 0 );
	     fdebugf( log_file, "%p: really read %d\n", c, c->buf_used );
	     }
	    */

	    if (end[-1] == '\r')
		end[-1] = 0;
	    end[0] = 0;
	    return c->buffer;
	}

#if EXTEND_BUFFER
	if ( !rc ) /* EOF but no new line */
	{
	    /* This is not a good situation the stream has ended with no line feed */
	    c->buf_used = c->buf_off + 1;
	    fdebugf(log_file, "%p: EOF without newline (%d chars %d %d %d)\n", c, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
	    return c->buffer;
	}

	if ( (buf_size - c->buf_off - 1 == 0) ) /* Phrased like this as this is the formula used in the recv() call */
	{
	    char *new_buf;

	    /* This is not a good situation, the buffer is full but we don't have
	     * a line feed so extend buffer and continue */

	    new_buf = malloc(c->buf_size + MAX_INPUT);
	    if (!new_buf)
	    {
		c->buf_used = c->buf_off + 1;
		fdebugf(log_file, "%p: getline buffer filled up - can't extend (%d chars %d %d %d); cleared\n", c, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
		return c->buffer;
	    }

	    memcpy(new_buf, c->buffer, c->buf_off+1);
	    free(c->buffer);

	    c->buffer = new_buf;
	    c->buf_size += MAX_INPUT;

	    buf_size = c->buf_size;
	    
	    fdebugf(log_file, "%p: getline buffer filled up - extended to %d (%d chars %d %d %d)\n", c, c->buf_size, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
	}
	else
	{
	    return NULL;
	}
#else
	if ( (buf_size - c->buf_off - 1 == 0) || !rc ) /* Phrased like this as this is the formula used in the recv() call */
	{
	    /* This is not a good situation, the buffer is full but we don't have
	     * a line feed */
	    c->buf_used = c->buf_off + 1;
	    fdebugf(log_file, "%p: getline buffer filled up (%d chars %d %d %d); cleared\n", c, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
	    return c->buffer;
	}
#endif
    }
    return NULL;
}

static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value )
{
    http_header_item *hi;

    /* SJM: vital that multiple set-cookie: lines are held.
     * I'm unsure whether it is wise to strip multiples generally.
     */
    if (strcasecmp(key, "SET-COOKIE") != 0)
    {
	for ( hi = c->headers; hi; hi = hi->next )
	{
	    /* Make sure duplicate headers only go in once (important in
	     * server-push case)
	     */
	    if ( strcasecmp( hi->key, key ) == 0 )
	    {
		free( hi->value );
		hi->value = strdup( value );
		return hi;
	    }
	}
    }

    hi = malloc(sizeof(http_header_item));
    if (hi)
    {
        hi->key = strdup(key);
        hi->value = strdup(value);

        if (hi->key == NULL || hi->value == NULL)
        {
            if (hi->key)
                free(hi->key);
            if (hi->value)
                free(hi->value);
            free( hi );
            hi = NULL;
        }
    }

    if (hi)
    {
        hi->next = c->headers;
        c->headers = hi;
    }

    return hi;
}

void http_process_header_line(http_connection *c, char *l)
{
    char *p;

    fdebugf(log_file, "%p: rxheader '%s'\n", c, l);

    if ( !*l )
    {
        if ( c->nearlyboundary == -1 )
        {
            /* Nasty hack 'cos server-push starts off in the "wrong" state
             */
	    fdebugf( log_file, "%p: blank line 'cos of multipart\n", c );
            c->nearlyboundary = 0;
        }
        else
        {
            c->status = status_GETTING_BODY;

            fdebugf( log_file, "%p: entering getting_body state, sofar=%d size=%d total=%d\n", c, c->data_so_far, c->data_size, c->total_size );
        }
    }
    else
    {
        /* Try to split the the header line */

        /* pdh: i hate nph cgi's, they let people do stuff who are far too
         * clueless to get it right
         */
        while ( isspace(*l) )
            l++;

        p = strchr(l, ':');
        if (p != 0)
        {
            char *q;

            *p = 0;
            while (isspace(*(++p)))
                ;

            q = p + strlen(p);
            while ((q > p) && isspace(q[-1]))
                q--;
            *q = 0;

            if ( http_check_special_headers( c, l, p ) )
                http_add_header_line( c, l, p );
        }
        else
        {
            fdebugf(log_file, "Badly formed header line, no ':'\n");
        }
    }
}


/*---------------------------------------------------------------------------*
 * http_set_server_flag                                                      *
 * We've just found out something that potentially affects how everyone      *
 * talks to this server, so tell everyone about it                           *
 *---------------------------------------------------------------------------*/

void http_set_server_flag( http_connection *c, int flag )
{
    http_connection *c2 = http_cons_list;

    while ( c2 )
    {
        if ( !memcmp( &c->sa, &c2->sa, sizeof( struct sockaddr_in ) ) )
        {
            c2->flags |= flag;
            if ( c2->queue )
                c2->queue->flags |= flag;
        }
        c2 = c2->next;
    }
}

void http_process_response_line(http_connection *c, char *l)
{
    fdebugf(log_file, "%p: received '%s'\n",  c, l);

    if (strncmp(l, http_version_check, strlen(http_version_check)) == 0)
    {
        char *p;

        p = strchr(l, ' ');
        if ( !p )
            p = l;

        while (isspace(*(++p)))
            ;
        c->rc = atoi(p);

        p += 2;
        while (isspace(*(++p)))
            ;
        http_set_message( c, p );
        fdebugf(log_file, "%p: response %d '%s'\n", c, c->rc, c->message ? c->message
                                                            : "<no message>");

        if ( (c->flags & http_flags_HTTP11) == 0
             && !strncmp( l+5, "1.1", 3 ) )
        {
            http_set_server_flag( c, http_flags_HTTP11 );
        }

        http_set_status( c, status_GETTING_HEADERS );
    }
    else
    {
        /* Either it's HTTP/0.9 or it's just not playing the game */
        fdebugf(log_file, "Badly formed response line\n");

        c->rc = 200;
        http_set_message( c, "Badly formed response; continuing anyway." );
        http_set_status( c, status_GETTING_BODY );

        /* Squeeze this line back in the buffer so it can get flushed out */
        c->buffer[c->buf_used-1] = '\n';
        if (c->buffer[c->buf_used-2] == 0)
            c->buffer[c->buf_used-2] = '\r';
        c->buf_used = 0;
    }
}

void http_flush_data_to_file(http_connection *c)
{
    /* NB. Contrary to a previous comment here, the flush is *NOT* always for
     * the initial data (in the case of a Partial Content reply)
     */

    if ( c->data_so_far == -1 )
    {
        fdebugf( log_file, "%p: setting so_far=0 in flush\n", c );
        c->data_so_far = 0;
    }

    if (c->fh && (c->buf_off != c->buf_used))
    {
        int n;
        int wrote;

        n = c->buf_off - c->buf_used;

        fdebugf( log_file, "%p: trying to flush %d bytes\n", c, n );

        wrote = ro_fwritepos( c->buffer + c->buf_used, n, 1, c->fh,
                              c->data_so_far);
        if ( wrote < n )
        {
            http_oserror( c, _kernel_last_oserror() );
            return;
        }

        c->buf_off = c->buf_used = 0;
        c->data_so_far += n;
        fdebugf( log_file, "%p: flushed %d bytes of body (so_far=%d)\n", c, n,
                           c->data_so_far );
    }
}


/*---------------------------------------------------------------------------*
 * http_queue_dec_nsockets                                                   *
 * Decrement the number of sockets registered as belonging to the queue.     *
 * This is used in socket_close, when the socket is going away altogether,   *
 * and also in orphan_queue, when the socket isn't going away, but doesn't   *
 * belong to this queue any more.                                            *
 *     Care is needed to stop this being called twice on any given socket:   *
 * socket_close sets c->socket to -1 and orphan_queue sets c->queue to       *
 * NULL, both of which act to prevent double decrementing.                   *
 *---------------------------------------------------------------------------*/

void http_queue_dec_nsockets( http_connection *c )
{
    if ( c->socket != -1 )
    {
        http_queue *q = c->queue;
        if ( q )
        {
            q->nsockets--;
            fdebugf( log_file, "%p: decrementing queue %p's nsockets to %d\n",
                     c, q, q->nsockets );
            if ( q->nsockets == 0 )
            {
                if ( q->queue )
                {
                    fdebugf( log_file, "%p: *** ERROR queue %p being freed with connection %p still on it\n", c, q, q->queue );
                }

                fdebugf( log_file, "%p: freeing queue %p\n", c, q );

                if ( q->prev )
                    q->prev->next = q->next;
                else
                    http_queues_list = q->next;

                if ( q->next )
                    q->next->prev = q->prev;

                free( q );
                c->queue = NULL;

                if ( c->queuenext )
                    c->queuenext->queue = NULL;
            }
            /* We *don't* set c->queue to NULL here (unless the queue has
             * vanished), as this messes up the requeue case. Setting c->queue
             * to NULL is orphan_queue's job.
             */
        }
    }
}

void http_socket_close(http_connection *c)
{
    if (c->socket != -1)
    {
#ifndef NO_SECURE
	if ( c->SSL != NULL )
	{
	    fdebugf( log_file, "Closing SSL connection\n" );
	    SSL_free( c->SSL );
	    c->SSL = NULL;
	}
#endif

	totalsockets--;

        fdebugf( log_file, "%p: closing socket %d (%d left)\n", c, c->socket,
                 totalsockets );

        http_queue_dec_nsockets( c );

        http_cons[c->socket] = NULL;

        socketclose(c->socket);
        c->socket = -1;

        if ( c->queuenext )
        {
            fdebugf( log_file, "%p: pipelined connection %p is stuffed too\n",
                               c, c->queuenext );
            c->queuenext->socket = -1;
        }
    }
}


/*---------------------------------------------------------------------------*
 * http_check_special_headers()                                              *
 * Returns TRUE if it's okay to pass this header on to the client            *
 *---------------------------------------------------------------------------*/

BOOL http_check_special_headers( http_connection *c, char *key, char *value )
{
    if (strcasecmp(key, "CONTENT-LENGTH") == 0)
    {
        int s;
        s = atoi(value);
        if (s > 0)
        {
            /* When getting a partial content, this size is the size of
             * the range, *not* of the whole file. When getting the first
             * part of an image, we want c->data_size to be 256 so that the
             * GETTING_BODY state terminates; however, when getting the second
             * half, we definitely want it to be right.
             */
            if ( c->data_size == -1 )
            {
                c->data_size = s;

                /* RISC OS will give us a random size */
                if ( c->fh )
                {
                    if (ro_ensure_size(c->fh, c->data_size) == _kernel_ERROR)
		    {
                        http_oserror( c, _kernel_last_oserror() );
			return TRUE;
		    }
		    ro_fclose(c->fh);
		    c->fh = ro_fopen(c->fname, RO_OPEN_RW);
                }
            }
            else
            {
                char realsize[20];

                if ( s == c->total_size
                     || c->total_size == 0 )
                {
                    fdebugf( log_file, "%p: passing on %s header\n",
                             c, key );
                    return TRUE;    /* OK to pass it on */
                }

                /* Not OK, it's the length of this transaction, so fake up a
                 * header that's the length of the whole lot.
                 */
                sprintf( realsize, "%d", c->total_size );
                http_add_header_line( c, key, realsize );
                fdebugf( log_file, "%p: brewing up fake header %s: %s\n",
                         c, key, realsize );
                return FALSE;
            }
        }
    }
    else if ( strcasecmp( key, "CONNECTION" ) == 0 )
    {
        char *p = value;

        while ( p )
        {
            if ( prefixcmp( p, "CLOSE" ) == 0 )
            {
                c->flags &= ~http_flags_KEPTALIVE;
                c->flags |= http_flags_NOTALIVE;
                http_orphan_queue( c );
            }

            if ( prefixcmp( p, "KEEP-ALIVE" ) == 0 )
            {
                c->flags |= http_flags_KEPTALIVE;

                if ( !(c->flags & http_flags_DOESKEEPALIVE ) )
                    http_set_server_flag( c, http_flags_DOESKEEPALIVE );
            }

            p = strchr( p, ',' );
            if ( p )
            {
                p++;
                while ( isspace( *p ) )
                    p++;
            }
        }
    }
    else if ( strcasecmp( key, "TRANSFER-ENCODING" ) == 0
         && strcasecmp( value, "CHUNKED" ) == 0 )
    {
        c->flags |= http_flags_CHUNKED;
    }
    else if ( strcasecmp( key, "CONTENT-TYPE" ) == 0
              && ( prefixcmp( value, "MULTIPART/X-MIXED-REPLACE" ) == 0
                   || prefixcmp( value, "MULTIPART/X-BYTERANGES" ) == 0 ) )
    {
        /* Oooh, it's server push. Now the fun really starts. */

        /* Actually we must cope with multipart byteranges as well, as at
         * least one server (WebSitePro/1.1f) returns all this mime junk even
         * if we've only asked for *one* byte range -- this is not as per spec!
         */

        /* 25/4/97: No, it's worse than that. At least one server (the
         * succinctly-named Open-Market-Secure-WebServer/2.0.12/RC0) returns
         * mime junk and *doesn't tell us the total size* -- this is useless
         * and means we must rerequest the whole image.
         */

        char *p = strchr( value, ';' );

        if ( prefixcmp( value, "MULTIPART/X-BYTERANGES" ) == 0
             && c->total_size == 0 )
        {
            /* Nothing we can do. Restart the request and bear a grudge
             * against this server in future.
             */
            http_set_server_flag( c, http_flags_RANGEBROKEN );
            fdebugf( log_file, "%p: BYTE RANGES ARE BROKEN\n", c );

        }

        if ( p )
        {
            p++;
            while ( isspace(*p) )
                p++;
            if ( prefixcmp( p, "BOUNDARY" ) == 0 )
            {
                p = strchr( p, '=' );

                if ( p )
                {
                    p++;
                    while ( isspace(*p) )
                        p++;

                    c->boundary = malloc( strlen(p)+3 ); /* SJM: 18Jul97 added an extra 1 */

                    if ( c->boundary )
                    {
                        strcpy( c->boundary, "--" );
                        strcat( c->boundary, p );
                        c->flags &= ~http_flags_KEPTALIVE;
                        c->flags |= http_flags_NOTALIVE;

                        c->nearlyboundary = -1; /* magic value */

                        fdebugf(log_file, "%p: server push, boundary is '%s'"
                                           " total_size is %d\n",
                                c, c->boundary, c->total_size );

                        /* client doesn't see this header (important for
                         * set_file_type to work)
                         */
                        return FALSE;
                    }
                }
            }
        }
    }
    else if ( strcasecmp( key, "CONTENT-RANGE" ) == 0 )
    {
        int from,to,total;

        /* Cope with both "bytes=aa-bb/cc" and "aa-bb/cc"
         */

        if ( !isdigit( *value ) )
            value += 6;

        sscanf( value, "%d-%d/%d", &from, &to, &total );

        fdebugf( log_file, "%p: Bytes %d to %d inclusive of a total of %d\n",
                            c, from, to, total );
        c->total_size = total;

        if ( to == total-1 )
        {
            /* Second half of a transfer */
            c->data_size = total;
        }
        else
        {
            /* First half of a transfer */
            c->flags |= http_flags_GOTFIRST;
        }

        if ( !(c->flags & http_flags_DOESRANGE ) )
            http_set_server_flag( c, http_flags_DOESRANGE );

        /* If we've had one of these, we'd best have had Content-Length
         * as well, or else.
         */
        return FALSE;   /* don't pass on to client */
    }
    return TRUE;    /* pass on to client */
}

#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error)
{
    if ( !ok )
    {
        if ( depth >= CERT_VERIFY_DEPTH )
            ok=1;
        else
            verify_error = TRUE;
    }

    return(ok);
}
#endif

/*
 * New function to use the crypto routines to verify a message digest against
 * a public key and maybe a certificate.

API:

VerifyMessageDigest

 IN
   int    : flags
          : type of key.certificate
          : fetch DER encoded public certificate from memory or disc
   char * : message data
   int    : message data length
   int    : digest type
   char * : digest received
   int    : digest received length
   char * : ptr to DER encoded public key / ptr to DER encoded public key certificate (depends on flags)
   char * : filename of X509 certificate in PEM, or DER, or ptr to X509 DER certificate in RAM (depends on flags)
   int    : RAM X509 DER certificate length or 0 (depends on flags)

 OUT
   Does it match or not? or error

Here is what was sent to the NSA

   API extension for HTTP-SSL module.
   ==================================

A new interface is created called HTTP_VerifyMessageDigest.

The parameters to this are

      flags word
      pointer to and length of message
      pointer to and length of encrypted message digest
      message digest type
      pointer to DER encoded public key
      optional pointer to filename of X509 certificate in PEM or DER encoding

If the X509 certificate is given then the public key is used to
verify the certificate and extract a new public key. This public
key is then used to verify the message digest.

If no certificate is given then the public key given is used to verify
the message digest.

A given X509 certificate may be PEM or DER encoded - in the latter case
it may reside in RAM or on disc

The root public key may be PEM or DER encoded - in the latter case it may be just a plain RSA public key or an x.509 certificate
containing an RSA public key.

The routine will return success or an error code giving at what point
the failure to verify occurred. This will be one of
   Input values bad in some way
   Certificate failed to verify
   Digest failed to verify

   */

static _kernel_oserror *http_verifymessagedigest(http_verifymessagedigest_args *r)
{
#if defined(NO_SECURE)
    return make_error(err_SSL_NOT_AVAILABLE);
    r = r;
#elif !defined(VERIFY_MD)
    r->out.rc = http_vmd_rc_NOT_SUPPORTED;
    return NULL;
    r = r;
#else
    _kernel_oserror *e = NULL;
    EVP_PKEY *pkey = NULL, *pkey2 = NULL;
    RSA *rsa = NULL;
    X509 *xcert = NULL;
    FILE *f;
    EVP_MD_CTX md_ctx;
    int i;

    int rc = http_vmd_rc_BAD_INPUT;
    unsigned char *certificate_ptr, *pubkey_ptr;
    unsigned char **certificate_ptr_ptr, **pubkey_ptr_ptr;
    unsigned char *rsa_buff = NULL;
    unsigned int rsa_bytes;

    fdebugf(log_file, "HTTP_VerifyMessageDigest:\n  flags %08x\n  key '%s'\n  cert '%s'\n  message @ 0x%p/%d\n  digest @ 0x%p/%d\n",
	    r->in.flags,
	    r->in.public_key ? r->in.public_key : "<none>",
	    r->in.certificate ? r->in.certificate : "<none>",
	    r->in.message_data, r->in.message_data_len,
	    r->in.digest_data, r->in.digest_data_len);

    /* check some initial values */
    if (r->in.message_data == NULL || r->in.message_data_len == 0 ||
	r->in.digest_data == NULL || r->in.digest_data_len == 0)
    {
	r->out.rc = rc;
	return NULL;
    }

    /* get the initial public key from the file */
    if (r->in.public_key)
    {
	if ((f = fopen(r->in.public_key, "rb")) != NULL)
	{
	    if(r->in.flags & http_vmd_flag_RAW_PKEY) { /* root file is raw (ie DER) RSA public key */
	      fdebugf(log_file, "reading raw DER public key from file\n");
	      if((rsa_buff = (unsigned char *)malloc(512))==NULL) {
	          fdebugf(log_file, "couldn't get new RSA buffer\n");
	          fclose(f);
	          r->out.rc = http_vmd_rc_NO_FREE_RSA;
	          return NULL;
	      }

	      rsa_bytes = fread(rsa_buff, 1, 512, f);

	      fclose(f);

	      pubkey_ptr = rsa_buff;
	      pubkey_ptr_ptr = &pubkey_ptr;

	      if((rsa = d2i_RSAPublicKey(NULL, pubkey_ptr_ptr, rsa_bytes))==NULL) {
	          fdebugf(log_file, "couldn't unpack RSA public key\n");
	          r->out.rc = http_vmd_rc_BAD_RSA;
	          return NULL;
	      }

	      if((pkey = EVP_PKEY_new())==NULL) {
	          fdebugf(log_file, "couldn't get new EVP_PKEY buffer\n");
	          r->out.rc = http_vmd_rc_NO_FREE_EVP;
	          return NULL;
	      }

	      pkey->type = EVP_PKEY_RSA;
	      pkey->pkey.rsa = rsa;

	    } else { /* root file is a certificate (PEM or DER) */

	      /* extract X509 certificate from file */
	      if (r->in.flags & http_vmd_flag_KEY_DER)
	      {
		  if((xcert = d2i_X509_fp(f, NULL))==NULL) {
		      fdebugf(log_file, "couldn't claim x509 cert\n");
		      r->out.rc = http_vmd_rc_NO_FREE_X509;
		      return NULL;
		  }
	      }
	      else
	      {
		  if((xcert = PEM_read_X509(f, NULL, 0))==NULL) { /* specify default callback function - could be awkward if it was called */
		      fdebugf(log_file, "couldn't claim x509 cert\n");
		      r->out.rc = http_vmd_rc_NO_FREE_X509;
		      return NULL;
		  }
	      }

	      fclose(f);

	      fdebugf(log_file, "key cert @ 0x%p\n", xcert);

	      if (xcert)
	      {
		  pkey = X509_extract_key(xcert);

		  fdebugf(log_file, "key @ 0x%p\n", pkey);

		  X509_free(xcert);
	      }
	  }
	}
    }

    /* if there's a certificate given then extract the public key from it to use instead */
    if (pkey && r->in.certificate)
    {

        if((r->in.flags & http_vmd_flag_CERT_INCORE) && (r->in.flags & http_vmd_flag_CERT_DER)) { /* it's DER, and it's in RAM */
          certificate_ptr = (unsigned char *)r->in.certificate;
          certificate_ptr_ptr = &certificate_ptr; /* yuk. d2i_X509() made me do it */

          if((xcert = d2i_X509(NULL, certificate_ptr_ptr, (long)r->in.certificate_len))==NULL) {
              fdebugf(log_file, "DER parsing of in-core cert. failed\n");
              rc = http_vmd_rc_BAD_INPUT;
              return NULL;
          }
        } else { /* it's not DER, or it's not in RAM */
	  FILE *f;
	  if ((f = fopen(r->in.certificate, "rb")) != NULL)
	  {


	     /* extract X509 certificate from file */
	     if (r->in.flags & http_vmd_flag_CERT_DER)
	     {
		if((xcert = d2i_X509_fp(f, NULL))==NULL) {
		  fdebugf(log_file, "couldn't claim x509 cert\n");
		  r->out.rc = http_vmd_rc_NO_FREE_X509;
		  return NULL;
		}
	     }
	     else
	     {
		if((xcert = PEM_read_X509(f, NULL, 0))==NULL) { /* specify default callback function - could be awkward if it was called */
		  fdebugf(log_file, "couldn't claim x509 cert\n");
		  r->out.rc = http_vmd_rc_NO_FREE_X509;
		  return NULL;
		}
	     }

	     fclose(f);


	  } else {
	      fdebugf(log_file, "couldn't open certificate file %s\n", r->in.certificate);
	      rc = http_vmd_rc_BAD_INPUT;
	      return NULL;
	  }
	}

	     if (xcert)
	     {
		fdebugf(log_file, "new cert @ 0x%p\n", xcert);

		if(r->in.flags & http_vmd_flag_EXPIRE_BEFORE) { /* expire-before checking */
        		i = X509_cmp_current_time(xcert->cert_info->validity->notBefore);
        		if(i==0) {
        		    fdebugf(log_file, "error in notBefore field of cert\n");
        		    rc = http_vmd_rc_CERT_NBERROR;
        		    X509_free(xcert);
        		    return NULL;
        		}

        		if(i>0) {
        		    fdebugf(log_file, "certificate not yet valid\n");
        		    rc = http_vmd_rc_CERT_NOTYET;
        		    X509_free(xcert);
        		    return NULL;
        		}
        	} /* endif expire-before checking */

        	if(r->in.flags & http_vmd_flag_EXPIRE_AFTER) { /* expire-after checking */
        		i = X509_cmp_current_time(xcert->cert_info->validity->notAfter);
        		if(i==0) {
        		    fdebugf(log_file, "error in notAfter field of cert\n");
        		    rc = http_vmd_rc_CERT_NAERROR;
        		    X509_free(xcert);
        		    return NULL;
        		}

        		if(i<0) {
        		    fdebugf(log_file, "certificate has expired\n");
        		    rc = http_vmd_rc_CERT_EXPIRED;
        		    X509_free(xcert);
        		    return NULL;
        		}
        	} /* endif expire-after checking */

		if (X509_verify(xcert, pkey))
		{
		    /* claim a  new key */
		    pkey2 = X509_extract_key(xcert);

		    fdebugf(log_file, "new key @ 0x%p\n", pkey);

		    if (!pkey2) {
		        fdebugf(log_file, "new cert has no key! Reverting to old one.\n");
			rc = http_vmd_rc_BAD_CERT; /* pkey still intact, so fall through */
		    } else { /* new key is ok, free old one, use new one */
		      if(pkey) EVP_PKEY_free(pkey);
		      rsa = NULL;
		      pkey = pkey2;
		    }
		}
		else
		{
		    fdebugf(log_file, "new cert failed to verify, reverting to old key\n");
		    rc = http_vmd_rc_BAD_CERT; /* pkey still intact, so fall through */
		    X509_free(xcert);
		    return NULL; /* optionally, we could omit this, and continue with the original pubkey,
		    	   	    which is still intact up to this point */

		}

		X509_free(xcert);
	     }

    }

    /* if we have a public key by this point */
    if (pkey)
    {

	/* set up and verify the message digest
	 * assume MD5 only for now unless we need others
	 */
	fdebugf(log_file, "VerifyInit\n");
	EVP_VerifyInit(&md_ctx, EVP_md5());

	fdebugf(log_file, "VerifyUpdate\n");
	EVP_VerifyUpdate(&md_ctx, (unsigned char *)r->in.message_data, r->in.message_data_len);

	fdebugf(log_file, "VerifyFinal\n");
	if (EVP_VerifyFinal(&md_ctx, (unsigned char *)r->in.digest_data, r->in.digest_data_len, pkey))
	    rc = http_vmd_rc_VERIFIED;
	else
	    rc = http_vmd_rc_FAILED;

	fdebugf(log_file, "rc=%d\n", rc);

	/* free any key we have open */
	EVP_PKEY_free(pkey);
	rsa = NULL; /* if this existed, evp_pkey_free will have freed it for us */
    }

    if(rsa) RSA_free(rsa);

    r->out.rc = rc;

#if DEBUG
    if (rc)
    {
	fdebugf(log_file, "** crypto error log\n");
	ERR_print_errors_fp(log_file);
	fdebugf(log_file, "** end\n");
    }
#endif

    return e;
#endif
}

/* given a DER certificate and a path, covert it to PEM and save it to the path.
   the filename used is a hash of the certificate's subject name

   on entry:

   r0 = ptr to DER certificate
   r1 = cert. bytes
   r2 = ptr to path, null terminated

   on exit:

   r0 = 0 or -n for error
      	     -1 = DER parsing failed
      	     -2 = couldn't open o/p file
      	     -3 = (WARNING) current time < cert. notBefore field
      	     -4 = (WARNING) current time > cert. notAfter field
      	     -5 = error in cert. notBefore field
      	     -6 = error in cert. notAfter field

*/
static _kernel_oserror *http_converttopem(_kernel_swi_regs *r)
{
#if defined(NO_SECURE) || !defined(VERIFY_MD)
    return make_error(err_SSL_NOT_AVAILABLE);
    r = r;
#else
  char hashname[12];
  char outfile[256];
  unsigned char *certificate_ptr;
  unsigned char **certificate_ptr_ptr;
  X509 *xcert = NULL;
  FILE *fout;
  int i;

  certificate_ptr = (unsigned char *)r->r[0];
  certificate_ptr_ptr = &certificate_ptr;

  strncpy(outfile, (char *)r->r[2], 240);

  if((xcert = d2i_X509(NULL, certificate_ptr_ptr, (long)r->r[1]))==NULL) {
      fdebugf(log_file, "http_converttopem: DER parsing failed\n");
      r->r[0] = -1;
      return(NULL);
  }

  sprintf(hashname, "%08lx", X509_subject_name_hash(xcert));
  strcat(outfile, hashname);

  if((fout=fopen(outfile, "w"))==NULL) {
      fdebugf(log_file, "http_converttopem: couldn't open file\n");
      r->r[0] = -2;
      return(NULL);
  }

  PEM_write_X509(fout, xcert);

  r->r[0] = 0;

  i = X509_cmp_current_time(xcert->cert_info->validity->notBefore);
  if(i==0) {
      fdebugf(log_file, "error in notBefore field of cert\n");
      r->r[0] = -5;
  }

  if(i>0) {
      fdebugf(log_file, "certificate not yet valid\n");
      r->r[0] = -3;
  }

  i = X509_cmp_current_time(xcert->cert_info->validity->notAfter);
  if(i==0) {
      fdebugf(log_file, "error in notAfter field of cert\n");
      r->r[0] = -6;
  }

  if(i<0) {
      fdebugf(log_file, "certificate has expired\n");
      r->r[0] = -4;
  }

  if(xcert) X509_free(xcert);
  fclose(fout);
  return(NULL);
#endif
}
/* eof http.c */
