/* -*-c-*- */

/* http.c */

/*
 * The HTTP module provides a mechanism for sending requests and
 * fetching results using the HyperText Transfer Protocol.
 *
 * pdh 01-Jul-96 Begin HTTPS (HTTP+SSL) support (defeat with -DNO_SECURE)
 * pdh 03-Jul-96 HTTPS now working
 * pdh 04-Jul-96 The last reallocs excised from httpsmod -- verify now works
 * pdh 29-Jul-96 Added HEAD support
 * pdh 12-Sep-96 Corrected internet event code -- hogs machine much less now
 * SJM 20-Nov-96 Took out excess strduping in status_AUTHENTICATING and added
 *		 setting of SSL_VERSION system variable.
 * pdh 27-Jan-97 Begin Keep-Alive support
 * pdh 29-Jan-97 First internal release of keep-alive version (0.61)
 * pdh 12-Mar-97 Frob prefix-fetch stuff to work round bug in WebSitePro/1.1f
 * RWB 16 Apr 97 CSFS bits.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include "tcplibs.h"
#include "status.h"

#ifndef NO_SECURE

#define HEADER_DES_LOCL_H	/* prevents crypt() warning */
#include "objects.h"		/* for NID */
#include "pem.h"		/* for PEM_ */

#include "ssl.h"

/* port routines */
extern _kernel_oserror *SSL_LibraryPresent( void );
extern int SSL_verified(SSL *session);
extern void riscos_ZM_Initialise( void );
extern void *riscos_ZM_realloc( void *ptr, size_t newsize );
extern void riscos_SSLLib_Init( void );

#define CERT_VERIFY_DEPTH 10
#endif

#include "httppub.h"
#include "http.h"

#if REMOTE_DEBUG
#include <stdarg.h>
#endif

#include "files.h"
#include "mimemap.h"

#ifdef CSFS
#include "csfs.h"
#endif

#ifndef FILETYPE_HTML
#define FILETYPE_HTML	0xfaf
#endif

#define SSL_VERSION_VAR	"HTTP$SSLVersion"

/**********************************************************************/
/*
 * Global definitions
 */

#ifndef TESTMODE
#define TESTMODE 0
#endif

/* Last byte of an image to fetch as a priority */
#define IMAGE_HEADER     255
#define IMAGE_HEADER_T  "255"
#define IMAGE_HEADER1    256
#define IMAGE_HEADER1_T "256"

#define MAXSOCKETS 4        /* Can be overridden */

/**********************************************************************/
/*
 * Error definitions
 */

/* Error definitions */
typedef enum {
    err_NO_SUCH_HOST,
    err_CANT_FIND_SERVICE,
    err_CANT_FIND_PROTOCOL,
    err_CANT_MAKE_SOCKET,
    err_CANT_CONNECT,
    err_BAD_IOCTL,
    err_NO_MEMORY,
    err_BAD_MAGIC,
    err_CANT_OPEN_FILE,
    err_CANT_OPEN_BODY,
    err_SSL_NOT_AVAILABLE,
    err_SSL_CANT_CONNECT,
    err_NOT_WAITING,
#ifdef CSFS
    err_CSFS,
#endif

    err_LAST_ERROR
    } error_numbers;

#define err_NO_ERROR -1

static char *err_strings[] = {
    "Can't find host in database",
    "Can't find service in database",
    "Can't find protocol in database",
    "Can't make socket",
    "Can't connect to server",
    "Bad IOCTL call",
    "Not enough free memory",
    "Invalid connection handle",
    "Can't open output file",
    "Can't open posting body file",
    "HTTPS not available",
    "Can't negotiate HTTPS connection",
    "Unexpected call to CompletedPart",
#ifdef CSFS
    "CSFS transport error",
#endif
    "Unknown error"
    };

/**********************************************************************/
/*
 * Global variable definitions
 */

void *private_word;

http_connection *http_cons[FD_SETSIZE]; /* Array of pointers - only the heads
                                           of keep-alive queues are in here */

http_connection *http_cons_list;        /* Absolutely all connections */
http_queue      *http_queues_list;

volatile int callback_pending;
volatile int threaded;

static int keptalive;

static int maxsockets;

static int totalsockets;

static int sockets_connecting; /* Count of sockets in the process of connection
                                   (i.e. still need to be polled) */

#ifndef BOOL
#define BOOL int
#define TRUE 1
#define FALSE 0
#endif

#ifndef NO_SECURE
static BOOL ssl_present = TRUE;
static SSL_CTX *ssl_context = NULL;
static BOOL verify_error = FALSE;
#endif

#define TMP_BUF_SIZE        1024
char tmp_buffer[TMP_BUF_SIZE];

static char http_version[] = HTTP_VERSION;
static char http_version_check[] = HTTP_VERSION_CHECK;

FILE *log_file;

/**********************************************************************/
/*
 * Forward declarations of functions static to this file
 */

static _kernel_oserror *setup_ticker_and_event(void);
static void clear_ticker_and_event(void);
static void setup_callback(void);
static void clear_callback(void);

static _kernel_oserror *http_open(http_open_args *args);
static _kernel_oserror *http_status(http_status_args *args);
static _kernel_oserror *http_close(http_close_args *args);
static _kernel_oserror *http_maptoriscos(http_maptoriscos_args *args);
static _kernel_oserror *http_mapfromriscos(http_mapfromriscos_args *args);
static _kernel_oserror *http_setfiletype(http_setfiletype_args *args);
static _kernel_oserror *http_completedpart(http_completedpart_args *args);
static _kernel_oserror *http_verifymessagedigest(http_verifymessagedigest_args *r);
static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value );
static _kernel_oserror *http_prosecute( http_connection *c );

static void http_orphan_queue( http_connection *c );
static void http_queue_allow_read( http_connection *c );
static void http_queue_allow_write( http_connection *c );
static void http_requeue( http_connection *c );
static void http_queue_dec_nsockets( http_connection *c );

#if DEBUG
static void http_show_flags( http_connection *c );
#endif

#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error);
#endif

#ifdef NO_SECURE
#define http_send(c,m,s) send((c)->socket,m,s,0)
#define http_sendv(c,v,n) socketwritev((c)->socket,v,n)
#define http_recv(c,b,l) recv((c)->socket,b,l,0)
#else
#define http_send(c,m,s)  (((c)->SSL) ? SSL_write( (c)->SSL, m, s )         \
                                      : send( (c)->socket, m, s, 0 ) )

#define http_sendv(c,v,n) (((c)->SSL) ? SSL_writev( (c)->SSL, v, n )        \
                                      : socketwritev( (c)->socket, v, n ) )

#define http_recv(c,b,l)  (((c)->SSL) ? SSL_read( (c)->SSL, b, l )          \
                                      : recv( (c)->socket, b, l, 0 ) )
#endif

#if DEBUG && REMOTE_DEBUG
int debug_socket=0;
#endif

#if DEBUG
# if REMOTE_DEBUG
#  define fdebugf  debug_printf
# else
#  define fdebugf fprintf
# endif
#else
#  define fdebugf 1?0:fprintf
#endif

/**********************************************************************/
/*
 * This structure is a prototype for a connection.
 */
static http_connection proto_con = {
    HTTP_MAGIC,                 /* Magic number */
    NULL,                       /* Next pointer */
    NULL,                       /* Prev pointerb */
    0,                          /* Poll word */
    status_NEW,                 /* Status */
    NULL,                       /* Object name */
    NULL,                       /* Outgoing headers */
    -1,                         /* Socket number */
    { 0, },                     /* Socket address */
    NULL,                       /* File name */
    0,                          /* File handle */
    NULL,                       /* Body file name */
    0,                          /* Body file handle */
    -1,                         /* Data size */
    -1,                         /* Data so far */
    NULL,                       /* List of fetched headers */
    -1,                         /* Return code */
    NULL,                       /* Return message */
    0,                          /* Buffer offset */
    0,                          /* Buffer used */
    NULL,                       /* Buffer data */
    NULL,                       /* SSL connection */
    0,                          /* Flags */
    0,                          /* Data pending */
    NULL,                       /* Beginning of headers */
    NULL, NULL,                 /* Keep-alive queue 2LL */
    NULL,                       /* Queue head structure */
    0,                          /* Total size */
    NULL,                       /* Server push boundary */
    0,                          /* #chars of boundary found at end of packet */
#if DEBUG
    1,                          /* # connections on this socket */
#endif
    };


        /*=======================*
         *   Utility functions   *
         *=======================*/


/**********************************************************************/
/*
 * The bcmp and bzero functions are needed by various internet library
 * calls.  I just pass them through to the memXXX versions.
 */

int bcmp(void *s1, void *s2, size_t s)
{
    return memcmp(s1, s2, s);
}

void bzero(void *p, int s)
{
    memset(p, 0, s);
}

/**********************************************************************/
/*
 * Error generation function
 */

static _kernel_oserror httperror;

static _kernel_oserror *make_error(int err)
{
    if ( err == err_NO_ERROR )
        return NULL;

    if (err > err_LAST_ERROR)
        err = err_LAST_ERROR;

    threaded = 0;

    httperror.errnum = err;
    strncpy(httperror.errmess, err_strings[err], 252);

    fdebugf(log_file, "Making error number %d: %s\n", err, err_strings[err]);

    return &httperror;
}

char *strdup(char *s)
{
    char *ss;
    int i = strlen(s) + 1;

    ss = malloc( i );

    if (ss)
        memcpy(ss, s, i);

    return ss;
}

int strcasecmp(char *s1, char *s2)
{
    int c1, c2, t;

    while (1)
    {
        c1 = *s1++;
        c2 = *s2++;
        if (c1 == 0 || c2 == 0)
            return c1-c2;
        else
        {
            t = toupper(c1) - toupper(c2);
            if (t)
                return t;
        }
    }
}

/* prefixcmp: like strcasecmp but returns 0 if s2 is a prefix of s1 */
int prefixcmp(char *s1, char *s2)
{
    int c1, c2, t;

    while (1)
    {
        c1 = *s1++;
        c2 = *s2++;
        if ( c2 == 0 )
            return 0;
        if ( c1 == 0 )
            return c1-c2;
        else
        {
            t = toupper(c1) - toupper(c2);
            if (t)
                return t;
        }
    }
}

/* memfind: like strstr but copes with search areas that contain 0's and don't
 * necessarily end with one. If there's a partial match at the end of the
 * search area, sets *nearly to the number of characters which matched.
 */
const char *memfind( const char *area, int len, char *search, int *nearly )
{
    int srchlen = strlen(search);

    while ( len > srchlen )
    {
        if ( !strncmp( area, search, srchlen ) )
            return area;
        area++;
        len--;
    }

    *nearly = 0;

    /* Check for partial match at the end <sigh> */
    while ( len )
    {
        if ( !strncmp( area, search, len ) )
        {
            *nearly = len;
            return NULL;
        }
        area++;
        len--;
    }
    return NULL;
}

#if 0
/* Damn and blast all Acorn socket libraries. Or at least their headers. */
struct iovec { void *iov_base; int iov_len; };
extern int socketwritev( int d, struct iovec *iov, int iovcnt );
#endif


/*---------------------------------------------------------------------------*
 * SSL_writev                                                                *
 * Equivalent to Socket_WriteV except uses an SSL connection. Assumes non-   *
 * blocking I/O.                                                             *
 *---------------------------------------------------------------------------*/

#ifndef NO_SECURE
static int SSL_writev( SSL *s, struct iovec *iov, int iovcnt )
{
    int bytes = 0;
    int rc;

    while ( iovcnt )
    {
        rc = SSL_write( s, iov->iov_base, iov->iov_len );
        if ( rc < 0 )
        {
            if ( errno == EWOULDBLOCK && bytes )
                return bytes;
            return -1;
        }
        else
            bytes += rc;

        iovcnt--;
        iov++;
    }
    return bytes;
}
#endif


        /*=================================*
         *   Interface to modules system   *
         *=================================*/

/*
 * pick up on the CSFS starting service call and register ourselves
 */
#ifdef CSFS
void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs reg;

  reg.r[0] = 0;
  reg.r[1] = (int)CSFS_ServiceName;
  reg.r[2] = HTTP_Service;
  reg.r[3] = HTTP_CSFSFeatures;
  /*
   * ignore error
   */
  _kernel_swi(CSFS_Register,&reg,&reg);
}
#endif

#if REMOTE_DEBUG && DEBUG

void
debug_printf(FILE *dummy,char *format, ...)
{
  va_list list;
  char debug_line[256];

  if (debug_socket)
  {
    va_start (list, format);
    vsprintf(debug_line,format, list);
    va_end(list);

    send(debug_socket, debug_line, strlen(debug_line), 0);
  }
}

void
debug_socket_open(void)
{
  int rc;
  struct sockaddr_in sockaddr;
  struct hostent *hostent;

again:
  debug_socket = socket(AF_INET, SOCK_STREAM, 0);
  if (debug_socket == 0)
    goto again;

  memset(&sockaddr, 0, sizeof(sockaddr));

  hostent = gethostbyname(REMOTE_DEBUG_HOST);
  if (hostent == NULL)
    goto exit_gracefully;

  sockaddr.sin_family = AF_INET;
  sockaddr.sin_port = htons(REMOTE_DEBUG_PORT);      /* debug server */
  sockaddr.sin_addr.s_addr = *(u_long*)hostent->h_addr;

  rc = connect(debug_socket, (struct sockaddr *)&sockaddr, sizeof(sockaddr) );
  if (rc<0)
    goto exit_gracefully;

  debug_printf(NULL,"HTTP: debug socket opened\n");

  return;

exit_gracefully:
  if (debug_socket >= 0)
    socketclose(debug_socket);
  debug_socket = 0;
}

void
debug_socket_close(void)
{
  if (debug_socket >= 0)
    socketclose(debug_socket);
  debug_socket = 0;
}
#endif

/**********************************************************************/
/*
 * Module finalisation function
 */
static void module_final(void)
{
#ifdef CSFS
    _kernel_swi_regs reg;
#endif
    http_connection *c, *next_one;

    fdebugf(log_file, "Module finalisation called\n");

    clear_ticker_and_event();

    clear_callback();

    for (c = http_cons_list; c != NULL; c = next_one)
    {
        next_one = c->next;
        fdebugf(log_file, "%p: being closed by finalisation\n", c );
        http_close_handle(c, http_close_DELETE_FILE | http_close_FATAL );
    }
#if REMOTE_DEBUG && DEBUG
    debug_socket_close();
#endif

#ifdef CSFS
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceName;
    /*
     * ignore error
     */
    _kernel_swi(CSFS_DeRegister,&reg,&reg);
#endif

#ifndef NO_SECURE
    if ( ssl_context )
        SSL_CTX_free( ssl_context );
#endif
}

/**********************************************************************/
/*
 * Module initialisation function
 */
extern _kernel_oserror *module_initialise(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *ep;
#ifdef CSFS
    _kernel_swi_regs reg;
#endif

    private_word = pw;

    if (cmd_tail)
    {
        log_file = fopen(cmd_tail, "w");
        if (log_file == NULL)
            log_file = stderr;
    }
    else
    {
        log_file = stderr;
    }
#if REMOTE_DEBUG && DEBUG
    debug_socket_open();
#endif

    fdebugf(log_file, "Module initialisation called.\n");

    bzero(http_cons, sizeof(http_cons));
    http_cons_list = NULL;

    callback_pending = 0;
    sockets_connecting = 0;
    keptalive = 0;
    totalsockets = 0;
    maxsockets = MAXSOCKETS;

#ifndef NO_SECURE
    ssl_present = TRUE;
    riscos_ZM_Initialise();
    riscos_SSLLib_Init();
    {
        ssl_context = SSL_CTX_new();
        SSL_load_error_strings();
        if ( ssl_context )
        {
/*          X509_add_cert_dir( ssl_context->cert, "SSL:certs",
                               X509_FILETYPE_PEM );
            SSL_load_verify_locations( ssl_context, NULL, "SSL:certs" );*/
            SSL_set_default_verify_paths( ssl_context );
            SSL_CTX_set_cipher_list( ssl_context, getenv( "SSL$CipherList" ) );
        }
        else
            ssl_present = FALSE;
    }
    _kernel_setenv(SSL_VERSION_VAR, ssl_present ? "2" : "0");
#else
    _kernel_setenv(SSL_VERSION_VAR, "0");
#endif

    ep = setup_ticker_and_event();
    if (ep)
        goto err;

#ifdef CSFS
    reg.r[0] = 0;
    reg.r[1] = (int)CSFS_ServiceName;
    reg.r[2] = HTTP_Service;
    reg.r[3] = HTTP_CSFSFeatures;
    /*
     * ignore error
     */
    _kernel_swi(CSFS_Register,&reg,&reg);
#endif

    atexit(&module_final);

    return 0;

 err:
    return ep;

    UNUSED(cmd_tail);
    UNUSED(pbase);
}

/**********************************************************************/
/*
 * Module CLI handler function
 */
extern _kernel_oserror *module_cli_handler(char *arg_string, int arg_count, unsigned int cmd_no, void *pw)
{
    http_connection *c;
    http_queue *q;

    fdebugf(log_file, "CLI handler called, command number %d\n", cmd_no);

    switch(cmd_no)
    {
    case 0:
        printf("HTTP support module status information\n");

        if (http_cons_list)
        {
            for (c = http_cons_list; c != NULL; c = c->next)
#if !DEBUG
            if ( c->socket != -1 )
#endif
            {
                unsigned long ip = c->sa.sin_addr.s_addr;
                unsigned int port = c->sa.sin_port;

                printf( "Connection at %p for http://%ld.%ld.%ld.%ld:%d%s\n",
                        c,
                        ip&0xFF, (ip>>8)&0xFF, (ip>>16)&0xFF, (ip>>24),
                        htons(port),
                        c->object );
                printf( "    socket=%d status=%d rc=%d\n", c->socket, c->status,
                        c->rc );
                printf( "    data=%d/%d, message=%s\n", c->data_so_far,
                        c->data_size, c->message ? c->message : "<none>" );
                printf( "    queue=%p, queueprev=%p, queuenext=%p\n", c->queue,
                        c->queueprev, c->queuenext );
            }

            if ( http_queues_list )
            {
                q = http_queues_list;
                while ( q )
                {
                    unsigned long ip = q->sa.sin_addr.s_addr;
                    unsigned int port = q->sa.sin_port;

                    printf( "Queue at %p for http://%ld.%ld.%ld.%ld:%d\n", q,
                            ip&0xFF, (ip>>8)&0xFF, (ip>>16)&0xFF, (ip>>24),
                            htons(port) );
                    c = q->queue;

                    if ( c )
                    {
                        while ( c )
                        {
                            printf( "    Waiting: %p %s\n", c, c->object );
                            c = c->queuenext;
                        }
                    }
                    else
                        printf( "    Empty\n" );

                    q = q->next;
                }
            }
        }
        else
        {
            printf("No current connections\n");
        }

        if ( keptalive )
                printf( "Uses of keep-alive: %d\n", keptalive );
        break;
    }

    return 0;

    UNUSED(arg_string);
    UNUSED(arg_count);
    UNUSED(pw);
}
#ifdef CSFS
/*
 * munge the filename
 */
_kernel_oserror *
munge_filename(char *mount_path, char *input_filename, int file_type,
	       char *username, char *passwd, char *cmd, char **output_file)
{
  int i;
  char *input_path=NULL;
  char *output_path=NULL;

  input_path=input_filename;   /* make sure we don't trash input string */

  if (input_path!=NULL)       /* is it a null string */
    if (*input_path==0)
      input_path=NULL;

  /*
   * need our own copy of string to play with
   */
  output_path = malloc((mount_path==NULL?0:strlen(mount_path))+
  	      	       (input_path==NULL?1:strlen(input_path))+
  	      	       (username  ==NULL?0:strlen(username  ))+
  	      	       (passwd    ==NULL?0:strlen(passwd    ))+
  	      	       (cmd       ==NULL?0:strlen(cmd       ))+50);

  if (output_path==NULL)
    return (make_error(err_NO_MEMORY));

  if (mount_path)
  {
    strcpy(output_path,mount_path);
    strcat(output_path,"?");
  }
  else
    strcpy(output_path,"");

  if (cmd)
  {
    strcat(output_path,"cmd=");
    strcat(output_path,cmd);
    strcat(output_path,"&");
  }

  strcat(output_path,"path=/");
  if (input_path)
  {
    i=strlen(output_path);
    strcat(output_path,input_path);
    while (output_path[i]!=0)    /* swap '.' with '/' */
    {
      if (output_path[i]=='.')
        output_path[i]='/';
      else if (output_path[i]=='/')
        output_path[i]='.';
      i++;
    }
  }
  /*
   * sort filetype out
   */
  if (file_type!=0 && file_type !=0xfff)  /* append the file type to filename */
  {
    char exten[6];
    sprintf(exten,",%03x",file_type);
    strcat(output_path,exten);
  }
  if (username)
  {
    strcat(output_path,"&");
    strcat(output_path,"username=");
    strcat(output_path,username);
  }
  if (passwd)
  {
    strcat(output_path,"&");
    strcat(output_path,"password=");
    strcat(output_path,passwd);
  }
  *output_file = output_path;

  return (NULL);
}

/*
 * implement the CSFS service swi
 */
extern _kernel_oserror *
http_csfs_service(_kernel_swi_regs *r)
{
  http_open_args open_args;
  http_close_args close_args;
  http_status_args status_args;
  _kernel_oserror *err=NULL;
  struct sockaddr_in sockaddr_in;
  char *path=NULL;
  char *new_path=NULL;
  char *remote_filename=NULL;
  char *username=NULL;
  char *passwd=NULL;
  char *cmd=NULL;
  int file_type;
  csfs_info *file_info;
  char *mount_path=NULL;
  int abort_command=0; /* used to stop command */
#if DEBUG
  static int status=0;
#endif
  http_connection *handle;

  memset(&sockaddr_in, 0, sizeof(sockaddr_in));
  handle = (http_connection*)r->r[2];

  switch (r->r[0])
  {
    case CSFS_CLOSE :
      close_args.in.handle = handle;
      ERR_GOTO(err,http_close(&close_args));

      break;
    case CSFS_STATUS :
      status_args.in.handle = handle;
      ERR_GOTO(err,http_status(&status_args));
#if DEBUG
      if (status_args.out.status!=status)
      {
        status=status_args.out.status;
        fdebugf(log_file,"HTTP: CSFS new status %d\n",status);
      }
#endif
      if (status_args.out.status >= status_COMPLETED_FILE)
      {
        http_header_item *hdr=status_args.out.headers;
        switch (status_args.out.status)
        {
          case status_COMPLETED_FILE : case status_COMPLETED_DIR :
            r->r[0] = 0;
            /*
             * check for return status from server
             */
            while (hdr)
            {
              if (strcasecmp(hdr->key,"CONTENT-TYPE")==0)
                if (strcasecmp(hdr->value,MIME_CSFSStatus)==0)
                {
                  int i=0;

                  /* fill-in the error message from status file */
        	  err=make_error(err_CSFS); /* defer jump till later */
                  ro_write_ptr(handle->fh, 0);
                  while (!ro_eof(handle->fh) && i<252)
                    err->errmess[i++]= _kernel_osbget(handle->fh);
                  err->errmess[i-1] = 0; /* terminate */
                }
              hdr = hdr->next;
            }
            break;
          default :
            ERR_GOTO(err,make_error(err_CSFS));
            r->r[0] = 1;
	}
      }
      else
       r->r[0] = -1;  /* still progressing */

      r->r[3] = NULL;

      break;
    default :
      switch (r->r[0])
      {
        case CSFS_GET :
          cmd = "GET";
          break;
      }
      file_info = (csfs_info*)r->r[8];
      mount_path = (char*)r->r[3];
      remote_filename = (char*)r->r[4];

      sockaddr_in.sin_family = AF_INET;
      /*
       * deal with port number being specified
       */
      if (r->r[1] & 1<<0)
      {
        host_info *host = (host_info*)r->r[2];
        /* default to port 80 */
        sockaddr_in.sin_port = htons((host->port==0)?80:host->port);
        sockaddr_in.sin_addr.s_addr = (unsigned int)htonl(host->addr);
      }
      else
      {
        sockaddr_in.sin_port = htons(80);
        sockaddr_in.sin_addr.s_addr = (unsigned int)htonl(r->r[2]);
      }

      open_args.in.addr = &sockaddr_in;
      username = (char*)r->r[5];
      passwd   = (char*)r->r[6];
      /*
       * extract file type info from supplied data
       */
      if (file_info==NULL)
        file_type = 0;
      else
        file_type = (file_info->load_addr)>>8&0xfff; /* load addr */

      ERR_GOTO(err,munge_filename(mount_path,remote_filename,file_type,
          username,passwd,cmd,&path));

      /*
       * fill in the args
       */
      open_args.in.object = path;
      open_args.in.headers = NULL;
      open_args.in.fname = (char*)r->r[7];
      open_args.in.bname = NULL;
      open_args.in.flags = 0;

/*       fdebugf(log_file,"HTTP: path '%s'\n",path); */
/*       fdebugf(log_file,"HTTP: host 0x%08x\n",addr); */

      switch (r->r[0])
      {
        case CSFS_GET :

          break;
        default :
          abort_command = 1;
      }

      if (abort_command)
      {
        ERR_GOTO(err,make_error(err_CSFS));
      }
      else
      {
        ERR_GOTO(err,http_open(&open_args));
        r->r[0] = (int)open_args.out.handle;
      }
  }
exit_gracefully:
  if (path)
    free(path);
  if (new_path)
    free(new_path);

  return (err);


}
#endif
/**********************************************************************/
/*
 * Module SWI handler function
 */
extern _kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *regs, void *pw)
{
#if 0
    fdebugf(log_file, "SWI handler called, SWI number 0x%02x\n", swinum);
#endif

    switch(swinum)
    {
    case 0:
        /* Open */
        return http_open((http_open_args *) regs);
        break;
    case 1:
        /* Status */
        return http_status((http_status_args *) regs);
        break;
    case 2:
        /* Close */
        return http_close((http_close_args *) regs);
        break;
    case 3:
        /* Map to RISC OS */
        return http_maptoriscos((http_maptoriscos_args *) regs);
        break;
    case 4:
        /* Map from RISC OS */
        return http_mapfromriscos((http_mapfromriscos_args *) regs);
        break;
    case 5:
        /* SetFileType */
        return http_setfiletype((http_setfiletype_args *) regs);
        break;
    case 6:
        /* CompletedPart */
        return http_completedpart((http_completedpart_args *) regs);
        break;
    case HTTP_VerifyMessageDigest - HTTP_SWI_Base:
        return http_verifymessagedigest((http_verifymessagedigest_args *) regs);
        break;
#ifdef CSFS
    case HTTP_Service - HTTP_SWI_Base:
        /* CSFS Service */
        return http_csfs_service(regs);
#endif
    }

    return NULL;

    UNUSED(pw);
}


        /*================================*
         *   Interface to events system   *
         *================================*/


/**********************************************************************/
/*
 * A function to handle the internet events.
 */
extern int inetevent_handler(_kernel_swi_regs *regs, void *pw)
{
    if ((regs->r[0] == Event_Internet) && (regs->r[1] >=0) && (regs->r[1] <= 2))
    {
        if ( regs->r[2] >= 0 && regs->r[2] < FD_SETSIZE )
        {
            /* take some action */
            http_connection *c = http_cons[ regs->r[2] ];
            if ( c )
            {
                c->data_pending = 1;
                setup_callback();
            }
        }
    }

    return VIA_R14;

    UNUSED(pw);
}

int timer_handler( _kernel_swi_regs *r, void *pw )
{
    if ( http_cons_list != NULL )
        setup_callback();

    return VIA_R14;
}

/**********************************************************************/
/*
 * A function to handle the callbacks caused by internet events.
 */
extern int callback_handler(_kernel_swi_regs *regs, void *pw)
{
    int i;

#if  0
    fdebugf(log_file, "Callback handler entered\n");
#endif

    callback_pending = 0;

    for ( i=0; i < FD_SETSIZE; i++ )
    {
        http_connection *c = http_cons[i];
        if ( c )
        {
            if ( c->status < status_WAITING
                 || c->data_pending )
            {
                c->data_pending = 0;    /* do this FIRST */
                http_prosecute( c );
/*
                if (c->status == status_FAIL_CONNECT ||
                    c->status == status_FAIL_REQUEST ||
                    c->status == status_FAIL_VERIFY ||
                    c->status == status_COMPLETED_FILE)
                {
                    http_socket_close(c);
                }
*/
            }
        }
    }

    threaded = 0;

    return VIA_R14;

    UNUSED(pw);
}

static _kernel_oserror *setup_ticker_and_event(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *ep;

    r.r[0] = 0x10;
    r.r[1] = (int) &inetevent_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(XOS_Bit + OS_Claim, &r, &r);

    if (ep)
        return ep;

    _kernel_osbyte(14, Event_Internet, 0);

    r.r[0] = TICKER_RATE;
    r.r[1] = (int) timer_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(OS_CallEvery, &r, &r);

    if (ep)
    {
        clear_ticker_and_event();
        return ep;
    }

    return NULL;
}

static void clear_ticker_and_event(void)
{
    _kernel_swi_regs r;

    _kernel_osbyte(13, Event_Internet, 0);

    r.r[0] = 0x10;
    r.r[1] = (int) inetevent_entry;
    r.r[2] = (int) private_word;

    _kernel_swi(OS_Release, &r, &r);

    r.r[0] = (int) timer_entry;
    r.r[1] = (int) private_word;

    _kernel_swi(OS_RemoveTickerEvent, &r, &r);
}

static void setup_callback(void)
{
    if (callback_pending == 0)
    {
        _kernel_swi_regs r;

        r.r[0] = (int) &callback_entry;
        r.r[1] = (int) private_word;
        callback_pending = 1;

        _kernel_swi(OS_AddCallBack, &r, &r);
    }
}

static void clear_callback(void)
{
    if (callback_pending)
    {
        _kernel_swi_regs r;

        r.r[0] = (int) &callback_entry;
        r.r[1] = (int) private_word;
        callback_pending = 0;

        _kernel_swi(OS_RemoveCallBack, &r, &r);
    }
}


        /*=======================*/


_kernel_oserror *http_check_handle(http_connection *c)
{
    if (c == NULL || c->magic != HTTP_MAGIC)
    {
        return make_error(err_BAD_MAGIC);
    }

    return 0;
}

int http_file_size(char *fname)
{
    _kernel_osfile_block fb;

    if (_kernel_osfile(5, fname, &fb) != 1) /* If it is not a plain file */
        return -1;
    else
        return fb.start;
}

_kernel_oserror *http_set_file_type(http_connection *c, int *ftptr)
{
    _kernel_osfile_block fb;

    if (c->fname)
    {
        http_header_item *hi;

        for (hi = c->headers; hi != NULL; hi = hi->next)
        {
            if (strcasecmp(hi->key, "CONTENT-TYPE") == 0)
            {
                int ft;

                ft = mime_map_to_riscos(hi->value);
                if (ft != -1)
                {
                    fdebugf(log_file, "Setting file type of '%s' to 0x%03X\n",
                                      c->fname, ft);
                    fb.load = ft;
                    if (ftptr)
                        *ftptr = fb.load;
                    _kernel_osfile(18, c->fname, &fb);
                }
                break;
            }
        }
        if (hi == NULL)
        {
            fb.load = FILETYPE_HTML;
            if (ftptr)
                *ftptr = fb.load;
            _kernel_osfile(18, c->fname, &fb);
        }
    }
    return NULL;
}


/*-----------------------------------------------------------------------*
 * http_set_status                                                       *
 * Set the status of a connection, keeping sockets_connecting up to date *
 *-----------------------------------------------------------------------*/

static void http_set_status( http_connection *c, transfer_status status )
{
#if DEBUG
    if ( status != c->status )
    {
        char intst[8];
        char *st = intst;

        switch ( status )
        {
        case status_NEW: st = "new"; break;
        case status_WAITING: st = "waiting"; break;
        case status_GETTING_HEADERS: st = "getting-headers"; break;
        case status_GETTING_BODY: st = "getting-body"; break;
        case status_COMPLETED_PART: st = "completed-part"; break;
        case status_COMPLETED_FILE: st = "completed-file"; break;
        default:
            sprintf( intst, "%d", status );
        }
        fdebugf( log_file, "%p: status now %s\n", c, st );
    }
#endif

    if ( c->status > status_NEW && c->status < status_WAITING )
        sockets_connecting--;
    c->status = status;
    if ( c->status > status_NEW && c->status < status_WAITING )
        sockets_connecting++;
}


static void http_set_message( http_connection *c, char *text )
{
    if ( c->message )
        free( c->message );
    c->message = strdup( text );
}

static void http_oserror( http_connection *c, _kernel_oserror *e )
{
    if ( e )
    {
        http_set_message( c, e->errmess );
        http_set_status( c, status_FAIL_LOCAL );
    }
}

void http_copy_headers(http_header_item *h, http_header_item **new)
{
    *new = NULL;

    if (h == NULL)
        return;

    *new = malloc(sizeof(http_header_item));
    if (*new == NULL)
        return;

    (*new)->key = strdup(h->key);
    (*new)->value = strdup(h->value);

    http_copy_headers(h->next, &((*new)->next));
}

_kernel_oserror *http_free_headers(http_header_item *h)
{
    http_header_item *hn;

    while(h != NULL)
    {
        hn = h->next;
/*         fdebugf(log_file, "Freeing header line\n"); */

        if (h->key)
            free(h->key);
        if (h->value)
            free(h->value);

        free(h);
        h = hn;
    }

    return NULL;
}

/*-----------------------------------------------------------------------*
 * http_fail                                                             *
 * Set the failure code for a connection, but don't destroy it (wait for *
 * foreground to notice and close it)                                    *
 *-----------------------------------------------------------------------*/

static void http_fail( http_connection *c, transfer_status status )
{
    http_set_status( c, status );

    fdebugf( log_file, "%p: *** failing due to %d\n", c, status );

    if ( c->fh )
    {
        ro_fclose( c->fh );
        c->fh = NULL;
    }

    http_orphan_queue( c );
}


        /*=================================*
         *   http_prosecute                *
         *   The actual HTTP transaction   *
         *=================================*/


/* Connection passes through the following states, in order:
 *      status_NEW                  only in http_open
 *      status_AWAITING_CONNECTION  if it's on a queue
 *    + status_CONNECTING           waiting for connect to succeed
 *    + status_AUTHENTICATING       missed out if not HTTPS
 *    + status_REQUESTING           sending request
 *    + status_REQUEST_HEADERS      sending headers
 *    + status_REQUEST_BODY         missed out if not POST
 *      status_WAITING              getting response line
 *      status_GETTING_HEADERS
 *      status_GETTING_BODY
 *
 * It counts towards sockets_connecting if in a state marked +
 */

static _kernel_oserror *http_prosecute( http_connection *c )
{
    int needToRead = 1;  /* used in "line reading" states */
    char *l;            /* ditto */
    int rc;

/*     fdebugf(log_file,"http_prosecute status %d\n",c->status); */

    switch (c->status)
    {
    case status_CONNECTING:
        /* check to see if the connect has succeeded yet */
        rc = connect( c->socket, (struct sockaddr *) &(c->sa),
                      sizeof(struct sockaddr));

        if (rc > -1)
        {
            /* This should not happen, but we will catch it anyway */
            http_set_status( c, status_AUTHENTICATING );
            /* go on to drop through the outer switch */
        }
        else
        {
            switch(errno)
            {
            case EISCONN:
                /* The connection is through now */
                http_set_status( c, status_AUTHENTICATING );
                break;
            case EALREADY:
                /* The connection is still going through */
                /* Do nothing */
                return NULL;
            default:
                /* The connection failed */
                http_fail( c, status_FAIL_CONNECT );
                return NULL;
            }
        }
        /* status is status_AUTHENTICATING so we can drop through */

    case status_AUTHENTICATING:

#ifndef NO_SECURE
        if ( c->SSL )
        {
            verify_error = FALSE;
            rc = SSL_connect( c->SSL );
            fdebugf( log_file, "SSL_connect returned %d (errno=%d)\n", rc,
                               SSL_errno() );
            if ( rc <= 0 )
            {
                if ( SSL_errno() == EWOULDBLOCK )
                    return NULL;    /* still trying */

                http_fail( c, verify_error ? status_FAIL_VERIFY
                                           : status_FAIL_REQUEST );
                return NULL;
            }

            /* Add some fake headers to provide SSL information */
            {
                X509 *peer = SSL_get_peer_certificate(c->SSL);
                char *cipher = SSL_get_cipher( c->SSL );

                if ( peer )
                {
                    char *str;

                        str=X509_NAME_oneline(X509_get_subject_name(peer));
                        /* str was allocated with malloc so we must free it*/
                        http_add_header_line( c, SSL_HEADER_CERT_SUBJECT,
                                              str );
			free(str);

                        str=X509_NAME_oneline(X509_get_issuer_name(peer));
                        http_add_header_line( c, SSL_HEADER_CERT_ISSUER,
                                              str );
			free(str);

                    X509_free(peer);
                }

                if ( cipher )
                    http_add_header_line( c, SSL_HEADER_CIPHER,
                                          cipher );

                http_add_header_line( c, SSL_HEADER_VERIFIED,
                                      SSL_verified(c->SSL) ? SSL_HEADER_YES : SSL_HEADER_NO  );
	    }
        }
#endif
        http_set_status( c, status_REQUESTING );
        /* fall through */

    case status_REQUESTING:
            http_send_request(c);
            if ( c->status != status_REQUEST_HEADERS )
                return NULL;
        /* else we can drop through */

    case status_REQUEST_HEADERS:
        rc = 0;
        while (c->status == status_REQUEST_HEADERS && rc != EWOULDBLOCK)
        {
            rc = http_send_request_headers(c);
        }
        if ( c->status != status_REQUEST_BODY )
            return NULL;
        /* else we can drop through */

    case status_REQUEST_BODY:
        rc = 0;
        while (c->status == status_REQUEST_BODY && rc != EWOULDBLOCK)
        {
            rc = http_send_request_body(c);
        }

        if ( c->status != status_WAITING )
            return NULL;
        /* else we can drop through */

    case status_WAITING:
        /* If we're in a queue, then don't try and read */
        if ( c->queueprev )
        {
            fdebugf( log_file, "%p: waiting for queueprev=%p to go NULL\n", c,
                     c->queueprev );
            return NULL;
        }

        /* Expecting a response line */
        l = http_getline(c, 1); /* Get the next line, doing a read */
        needToRead = 0;
        if (l)
            http_process_response_line(c, l);
        if ( c->status != status_GETTING_HEADERS )
            return NULL;
        /* else we can drop through */

    case status_GETTING_HEADERS:
        l = http_getline(c, needToRead);
        while (l && c->status == status_GETTING_HEADERS)
        {
                http_process_header_line(c, l);
                if (c->status == status_GETTING_HEADERS)
                    l = http_getline(c, 0);
        }
        if (c->status != status_GETTING_BODY)
            return NULL;
        /* else we can drop through */

        rc = c->flags;

        /* If someone's in the queue behind us, they can write now
         * (but not read)
         *
         * HTTP/1.0 will send us a Connection: keep-alive if we're kept alive
         * HTTP/1.1 will send us a Connection: close      if we're *not*
         */
        if ( (rc & http_flags_HTTP11) ?  ( rc & http_flags_NOTALIVE )
                                      : !( rc & http_flags_KEPTALIVE ) )
            http_orphan_queue( c );
        else
            http_queue_allow_write( c );

    case status_GETTING_BODY:
        /* Now idempotent and quick to return */
        http_flush_data_to_file(c);

        /* It's IMPORTANT that if status becomes COMPLETED_FILE then we drop
         * through and don't return: we don't want Partial Content replies to
         * appear as COMPLETED_FILE to SWI HTTP_Status, or else the client will
         * HTTP_Close them before their time.
         */

        while (1)
        {
            int block;

            if ( c->data_size > -1
                && c->data_so_far == c->data_size )
            {
                fdebugf( log_file, "%p: got all %d of my %d bytes (total=%d): file complete\n", c, c->data_size, c->data_so_far, c->total_size );
                http_set_status( c, status_COMPLETED_FILE );
                break;  /* from the while loop */
            }

            /* Still got some more to read */
            block = c->data_size - c->data_so_far;

            if ( block > TMP_BUF_SIZE || c->data_size < 0 )
                block = TMP_BUF_SIZE;

            if ( c->boundary && c->nearlyboundary )
            {
                char *buf = tmp_buffer + c->nearlyboundary;
                block -= c->nearlyboundary;

                memcpy( tmp_buffer, c->boundary, c->nearlyboundary );

                fdebugf( log_file, "%p: nearlyboundary=%d\n", c, c->nearlyboundary );

                rc = http_recv( c, buf, block );
            }
            else
                rc = http_recv( c, tmp_buffer, block );

            fdebugf(log_file, "%p: recv (body %d) gave %d\n", c, block, rc);

            if (rc <= 0)
            {
                if (rc == 0 || errno != EWOULDBLOCK)
                {
                    fdebugf(log_file, "%p: Connection closed on socket %d, errno=%d\n", c, c->socket, errno);
                    http_set_status( c, status_COMPLETED_FILE );

                    http_socket_close( c );

                    http_orphan_queue( c );
                }
                break; /* This is a break for the WHILE loop, not the switch */
            }

            if ( c->boundary )
            {
                int nearly;
                const char *bound;

                rc += c->nearlyboundary;
                c->nearlyboundary = 0;

                bound = memfind( tmp_buffer, rc, c->boundary, &nearly );

                if ( bound )
                {
                    int wrote = ro_fwritepos( tmp_buffer, bound - tmp_buffer, 1,
                                              c->fh, c->data_so_far );

                    if ( wrote < (bound - tmp_buffer) )
                    {
                        http_oserror( c, _kernel_last_oserror() );
                        return NULL;
                    }

                    c->data_so_far += wrote;

                    bound += strlen( c->boundary );

                    if ( *bound == '-' && bound[1] == '-' )
                    {
                        fdebugf(log_file, "%p: end of server push\n", c );

                        http_set_status( c, status_COMPLETED_FILE );
                        http_socket_close( c );
                        http_orphan_queue( c );
                        return NULL;
                    }
                    /* else there's more parts to come */

                    fdebugf(log_file, "%p: server push continues %d %d\n", c,
                                      *bound, bound[1] );

                    if ( *bound == 13 )
                        bound++;
                    if ( *bound == 10 )
                        bound++;            /* skip CR LF */

                    wrote = bound - tmp_buffer;

                    memcpy( c->buffer, bound, rc - wrote );
                    c->buf_used = 0;
                    c->buf_off = rc - wrote;

                    fdebugf(log_file,"%p: server push stuffs %d bytes (%d %d %d)\n",
                             c, c->buf_off,
                             c->buffer[0], c->buffer[1], c->buffer[2] );

                    http_set_status( c, status_COMPLETED_PART );
                    return NULL;
                }
                else
                {
                    /* See whether there may be one straddling 2 packets */
                    c->nearlyboundary = nearly;
                    rc -= nearly;
                }
            }

            if (c->fh)
            {
                int wrote = ro_fwritepos( tmp_buffer, rc, 1, c->fh,
                                          c->data_so_far );
                if ( wrote < rc )
                {
                    http_oserror( c, _kernel_last_oserror() );
                    return NULL;
                }
            }

            c->data_so_far += rc;
        }

        if ( c->status != status_COMPLETED_FILE )
            return NULL;
        /* else we can drop through */

    case status_COMPLETED_FILE:
        if ( (c->flags & http_flags_GOTFIRST)
             && c->data_so_far < c->total_size )
        {
            http_requeue( c );
            return NULL;
        }
        else if ( c->socket != -1 )
        {
            /* We've still got a socket -- get rid of it if it's finished with
             */
            if ( c->flags & http_flags_NOTALIVE )
            {
                fdebugf( log_file, "%p: calling socket_close from status_c_f\n", c );
                http_socket_close( c );
                fdebugf( log_file, "%p: calling orphan_queue from status_c_f\n", c );
                http_orphan_queue( c );
            }
            else
            {
                fdebugf( log_file, "%p: calling allow read from status_c_f\n", c );
                http_queue_allow_read( c );
            }
            return NULL;
        }
        fdebugf( log_file, "%p: doing nothing in status_c_f (socket=%d queuenext=%p)\n", c, c->socket, c->queuenext );
#if DEBUG
        http_show_flags(c);
#endif

        break;

    default:
        break;
    }

    return NULL;
}

static _kernel_oserror *http_destroy( http_connection *c, int error )
{
    if ( c )
    {
        fdebugf( log_file, "%p: being closed by http_destroy(%d)\n", c, error );
        http_close_handle( c, 0 );
    }
    return make_error( error );
}



        /*===================*
         *   SWI HTTP_Open   *
         *===================*/


/* Forward references - opening connections */
static int http_open_socket( http_connection *c );
static BOOL http_queue_new( http_connection *me );

static _kernel_oserror *http_open(http_open_args *args)
{
    http_connection *new = NULL;
    int rc;
    http_open_args args2 = *args;
    BOOL bQueued;

#if 0
    fdebugf(log_file, "Opening new conection.  Host = 0x%08lx, port = 0x%04x, object = '%s', fname = '%s'.\n\tHeaders stored at %p\n",
            args2.in.addr->sin_addr.s_addr, args2.in.addr->sin_port,
            args2.in.object, args2.in.fname ? args2.in.fname : "",
            args2.in.headers);
#endif

    args->out.handle = NULL;

    new = malloc(sizeof(http_connection) + MAX_INPUT);
    if (new == 0)
        return make_error(err_NO_MEMORY);

    fdebugf( log_file, "%p: New connection, host=0x%08lx, port=0x%04x\n",
                       new, args2.in.addr->sin_addr.s_addr,
                       args2.in.addr->sin_port );

    *new = proto_con;                /* Fill in with a prototype connection */
    new->buffer = (char*) (new + 1);
    new->buffer[0] = 0;

    memcpy((char *)&(new->sa),(char *) args2.in.addr,  sizeof(new->sa) );

    new->flags = args2.in.flags;

#if DEBUG
    http_show_flags( new );
#endif

    /* If we're prepared only to get the first few bytes, we can run at
     * priority.
     */
    if ( (new->flags & http_open_flags_IMAGE)
         && (new->flags & http_flags_DOESRANGE)
         && !(new->flags & http_open_flags_HEAD)
         && !(args2.in.bname) )
        new->flags |= http_open_flags_PRIORITY;

    bQueued = http_queue_new( new );

    if ( bQueued )
    {
        http_set_status( new, status_AWAITING_CONNECTION );

        /* Nothing can come in and try and use this queued connection until
         * we've built the output file etc, 'cos we're a SWI and are in SVC
         * mode, and prosecute is called from a callback.
         */
    }
    else
    {
        fdebugf( log_file, "%p: New connection, own socket\n", new );
        rc = http_open_socket( new );           /* sets new->status */
        if ( rc != err_NO_ERROR )
            return http_destroy( new, rc );
    }

    /*
     * The connection process may take a little time.  So we go off and make
     * the data file and come back in a moment to check if we are done.
     */

    new->object = strdup(args2.in.object);
    if (new->object == NULL)
    {
        return http_destroy(new,err_NO_MEMORY);
    }

    http_copy_headers(args2.in.headers, &(new->sendhead_base) );

    if (args2.in.fname == NULL)
    {
        args2.in.fname = tmpnam(NULL);
    }

    new->fname = strdup(args2.in.fname);
    if (new->fname == NULL)
    {
        return http_destroy(new,err_NO_MEMORY);
    }

    if ( args2.in.flags & http_open_flags_HEAD )
        new->fh = NULL;
    else
    {
        fdebugf(log_file, "%p: http_open Opening file '%s'\n", new, new->fname);

        new->fh = ro_fopen(new->fname, RO_OPEN_WRITE);
        if (new->fh == NULL)
        {
            return http_destroy(new,err_CANT_OPEN_FILE);
        }
    }

    if (args2.in.bname)
    {
        new->bname = strdup(args2.in.bname);
        if (new->bname == NULL)
        {
            return http_destroy(new,err_NO_MEMORY);
        }

        fdebugf(log_file, "%p: http_open Opening body file '%s'\n", new, new->bname);

        new->bh = ro_fopen(new->bname, RO_OPEN_READ);
        if (new->bh == NULL)
        {
            return http_destroy(new,err_CANT_OPEN_BODY);
        }
    }

    new->next = http_cons_list;
    /* new->prev is set to NULL in the prototype */

    if (http_cons_list)
        http_cons_list->prev = new;
    http_cons_list = new;

    /* If we're lucky, the connection has succeeded while we were doing
     * all that, so check and see if we can move matters on.
     * If we were queued, check to see whether anyone's completed and
     * has a socket we can swipe.
     */
    if ( bQueued )
    {
        int i;
        http_connection *c;

        for ( i=0; i < FD_SETSIZE; i++ )
        {
            c = http_cons[i];
            if ( c && c->queue && c->queue->queue
                 && ( c->status == status_COMPLETED_FILE ) )
            {
                http_prosecute( c );
            }
        }
    }
    else
        http_prosecute( new );

    args->out.handle = new;
    return NULL;
}


/*------------------------------------------------------------------------*
 * http_show_flags                                                        *
 * Output all the flags set for the connection (debug).                   *
 *------------------------------------------------------------------------*/

#if DEBUG
static void http_show_flags( http_connection *c )
{
    int f = c->flags;
    fdebugf( log_file, "%p: flags: ", c );

    if ( f & http_open_flags_SECURE )   fdebugf( log_file, " SSL" );
    if ( f & http_open_flags_VERIFY )   fdebugf( log_file, " SSL-verify" );
    if ( f & http_open_flags_HEAD )     fdebugf( log_file, " head" );
    if ( f & http_open_flags_PRIORITY ) fdebugf( log_file, " priority" );
    if ( f & http_open_flags_IMAGE )    fdebugf( log_file, " image" );
    if ( f & http_open_flags_TOMEM )    fdebugf( log_file, " to-mem" );
    if ( f & http_flags_HTTP11 )        fdebugf( log_file, " http-1.1" );
    if ( f & http_flags_KEPTALIVE )     fdebugf( log_file, " kept-alive" );
    if ( f & http_flags_NOTALIVE )      fdebugf( log_file, " not-alive" );
    if ( f & http_flags_DOESRANGE )     fdebugf( log_file, " does-range" );
    if ( f & http_flags_GOTFIRST )      fdebugf( log_file, " got-first" );
    if ( f & http_flags_CHUNKED )       fdebugf( log_file, " chunked" );

    if ( !f )
        fdebugf( log_file, " none" );

    fdebugf( log_file, "\n" );
}
#endif


/*------------------------------------------------------------------------*
 * http_open_socket                                                       *
 * Open the socket for a connection (may not be done at http_open time if *
 * keep-alive is in effect). Returns an err_XXX value.                    *
 *------------------------------------------------------------------------*/

static int http_open_socket( http_connection *c )
{
    int rc, i;

    if ( c->socket != -1 )
        fdebugf( log_file, "%p: *** open_socket called when socket=%d\n", c,
                           c->socket );

    c->socket = socket( AF_INET, SOCK_STREAM, 0 );

    if ( c->socket < 0 )
    {
        c->socket = -1;
        return err_CANT_MAKE_SOCKET;
    }

    i = 1;
    rc = socketioctl( c->socket, FIONBIO, &i );

    i = 1;
    if ( rc != -1 )
        rc = socketioctl( c->socket, FIOASYNC, &i );

    if ( rc < 0 )
        return err_BAD_IOCTL;

    rc = connect( c->socket, (struct sockaddr *) &(c->sa),
                  sizeof(struct sockaddr));

    /* Legal return values are:
     *
     *  EINPROGRESS(36) The connection process has been started but no result
     *                  as yet.
     *  EINVAL(22)      The connection process failed, either due to a timeout
     *                  or a rejection.
     *  EALREADY(37)    The connection process is still going on and may yet
     *                  finish.
     *  EISCONN(56)     The connection process succeeded and we are now
     *                  connected.
     */

    if (rc < 0 && errno != EINPROGRESS)
    {
        return err_CANT_CONNECT;
    }

    /* Create a SSL connection if required.
     */
    if ( c->flags & http_open_flags_SECURE )
    {
#ifdef NO_SECURE
        return err_SSL_NOT_AVAILABLE;
#else
        if ( ssl_present )
        {
            c->SSL = SSL_new( ssl_context );
            SSL_set_fd( c->SSL, c->socket );

            if ( c->flags & http_open_flags_VERIFY )
                SSL_set_verify( c->SSL, SSL_VERIFY_PEER,
                                &cert_verify_callback );
            else
                SSL_set_verify( c->SSL, SSL_VERIFY_NONE, NULL );
        }
        else
            return err_SSL_NOT_AVAILABLE;
#endif
        }

    http_set_status( c, status_CONNECTING );

    http_cons[c->socket] = c;

    totalsockets++;
#if 0
    fdebugf( log_file, "%p: opened new socket, %d, total is %d\n", c, c->socket,
             totalsockets );
#endif
    if ( c->queue )
    {
        c->queue->nsockets++;
#if 0
        fdebugf( log_file, "%p: queue %p gains socket %d, total=%d\n", c,
                 c->queue, c->socket,
                 c->queue->nsockets );
#endif
    }

#if DEBUG
    c->onthissocket = 1;
#endif

    return err_NO_ERROR;
}


/*------------------------------------------------------------------------*
 * http_queue_new                                                         *
 * See whether there's a connection currently open which we could         *
 * potentially re-use.                                                    *
 *------------------------------------------------------------------------*/

#define RELEVANT_FLAGS ( http_open_flags_SECURE | http_open_flags_VERIFY )

static BOOL http_queue_new( http_connection *me )
{
    http_queue *q = http_queues_list;
    http_connection *c;

    /* Find the queue for this server */
    while ( q )
    {
        if ( !memcmp( &me->sa, &q->sa, sizeof( struct sockaddr ) )
             && ( (me->flags & RELEVANT_FLAGS) == (q->flags & RELEVANT_FLAGS) ) )
        {
            /* Found a suitable queue */
            me->queue = q;

            if ( q->nsockets < 2
                 && totalsockets < maxsockets )
                    return FALSE;   /* Open another one */

            /* Add me to the queue */
            if ( me->flags & http_open_flags_PRIORITY )
            {
                /* Add to the front of the queue */
                me->queueprev = NULL;
                me->queuenext = q->queue;
                if ( q->queue )
                    q->queue->queueprev = me;
                q->queue = me;
            }
            else
            {
                /* Add to the end of the queue */
                c = q->queue;

                if ( c )
                {
                    while ( c->queuenext )
                        c = c->queuenext;

                    c->queuenext = me;
                    me->queueprev = c;
                }
                else
                {
                    q->queue = me;
                    me->queueprev = NULL;
                }
                me->queuenext = NULL;
            }

            return TRUE;
        }

        q = q->next;
    }

    /* No queue found, build a new one */

    q = (http_queue*) malloc( sizeof( http_queue ) );

    /* If malloc failed, give up */
    if ( q )
    {
        q->nsockets = 0;
        memcpy( &q->sa, &me->sa, sizeof( struct sockaddr ) );
        q->flags = me->flags;
        q->queue = NULL;
        q->next = http_queues_list;
        if ( q->next )
            q->next->prev = q;
        q->prev = NULL;
        http_queues_list = q;
        me->queue = q;
    }

    /* We always open a socket to a new server, even if totalsockets is
     * already maxsockets or more
     */
    return FALSE;
}


/*--------------------------------------------------------------------------*
 * http_from_queue                                                          *
 * Get the next waiting transaction from the queue (not very important, but *
 * it's duplicated code).                                                   *
 *--------------------------------------------------------------------------*/

static http_connection *http_from_queue( http_connection *c )
{
    http_connection *c2 = c->queuenext; /* A half-finished connection?... */

    if ( c2 )
        fdebugf( log_file, "%p: from_queue: returning queuenext: %p\n", c, c2 );

    if ( !c2 )                          /* ...if not, get one from the queue */
    {
        http_queue *q = c->queue;
        if ( q )
        {
            c2 = q->queue;
            if ( c2 )
            {
                fdebugf( log_file, "%p: from_queue: swiping %p from queue %p\n",
                                   c, c2, q );
                q->queue = c2->queuenext;
                q->queue->queueprev = NULL;
                c2->queuenext = NULL;
            }
            else
                fdebugf( log_file, "%p: from_queue: queue %p empty\n", c, q );
        }
        else
            fdebugf( log_file, "%p: from_queue: no queuenext and no queue\n", c );
    }
    return c2;
}


/*--------------------------------------------------------------------------*
 * http_orphan_queue                                                        *
 * Having decided that keep-alive isn't going to happen, open a new socket  *
 * for anything waiting for ours to come free. Note that we *may* be called *
 * after allow_write, but shouldn't be called after allow_read.             *
 *     orphan_queue *must* set c->queue to NULL if it makes a new socket    *
 * (so it's never called twice on the same connection, which would violate  *
 * the Principle of Conservation of Sockets).                               *
 *--------------------------------------------------------------------------*/

static void http_orphan_queue( http_connection *c )
{
    http_connection *c2;

    /* Make sure noone else comes in */
    c->flags |= http_flags_NOTALIVE;

    /* Limit number of sockets, unless this is the last socket open on its
     * queue.
     */
    if ( (c->socket != -1) && totalsockets >= maxsockets
         && ( !c->queue || !c->queue->queue || c->queue->nsockets > 0 ) )
    {
        fdebugf( log_file,"%p: not orphaning queue 'cos of socket limit\n", c );
        return;
    }

    fdebugf( log_file, "%p: orphaning queue\n", c );

    c2 = http_from_queue( c );

    c->queuenext = NULL;

    if ( !c2 )
        return;

    c2->queueprev = NULL;

    fdebugf( log_file, "%p: Orphaning queued connection %p\n", c, c2 );

    /* Open socket */
    if ( http_open_socket( c2 ) != err_NO_ERROR )
    {
        /* There was an error, but we can't return it */
        http_fail( c2, status_FAIL_CONNECT );
    }

    /* Disconnect from queue -- do this *after* opening the new socket, so
     * q->nsockets doesn't go to zero.
     */
    http_queue_dec_nsockets( c );
    c->queue = NULL;
}


/*--------------------------------------------------------------------------*
 * http_queue_allow_write                                                   *
 * We've finished writing to our socket, so the next request can start.     *
 *--------------------------------------------------------------------------*/

static void http_queue_allow_write( http_connection *c )
{
    http_connection *c2 = http_from_queue( c );

    if ( !c2 )
        return;

    c2->queueprev = c;
    c->queuenext = c2;      /* from_queue followed by this is idempotent in
                             * the case c2 is *already* c->queuenext
                             */

    if ( c2->status != status_AWAITING_CONNECTION )
        return;     /* already been done */

    fdebugf( log_file, "%p: handing socket %d writes over to %p\n", c,
                        c->socket, c2 );

#if DEBUG
    c2->onthissocket = c->onthissocket+1;
#endif

    c2->socket = c->socket;     /* Shared, not transferred */

#ifndef NO_SECURE
    c2->SSL = c->SSL;           /* Shared, not transferred */
#endif

    http_set_status( c2, status_REQUESTING );
    http_prosecute( c2 );
}


/*--------------------------------------------------------------------------*
 * http_queue_allow_read                                                    *
 * We've finished with our socket now, so, if anyone's waiting, they can    *
 * have it. allow_write may have been called, but may not.                  *
 *--------------------------------------------------------------------------*/

static void http_queue_allow_read( http_connection *c )
{
    http_connection *c2;
#if 0
    int rc;
    char foo[4];

    /* Note this does the Right Thing even in the SSL case */
    rc = recv( c->socket, foo, 4, MSG_PEEK );
    fdebugf( log_file, "%p: allow_read: rc=%d errno=%d\n",c, rc, errno );

    if ( rc < 0 && errno != EWOULDBLOCK )
    {
        fdebugf( log_file,
                 "%p: invalid socket in allow_read, orphaning instead\n", c );
        http_socket_close( c );
        http_orphan_queue( c );
        return;
    }
#endif

    c2 = http_from_queue( c );
    if ( !c2 )
    {
        /* Close the socket for tidiness' sake *only* if we're already dead */
        if ( c->flags & http_flags_NOTALIVE )
            http_socket_close( c );
        return;
    }

    /* Note that because of partial fetching, we must cope with the case c2==c
     */
    c->queuenext = NULL;
    c2->queueprev = NULL;

    fdebugf( log_file, "%p: handing socket %d reads over to %p\n", c,
                       c->socket, c2 );

#if DEBUG
    c2->onthissocket = c->onthissocket+1;
#endif

    keptalive++;

    c2->socket = c->socket;

#ifndef NO_SECURE
    c2->SSL    = c->SSL;
#endif

    /* Make sure noone else comes in */
    if ( c2 != c )
    {
        c->flags |= http_flags_NOTALIVE;
        c->socket = -1;
#ifndef NO_SECURE
        c->SSL = NULL;
#endif
    }

    http_cons[ c2->socket ] = c2;

    if ( c2->status == status_AWAITING_CONNECTION )
        http_set_status( c2, status_REQUESTING );

    fdebugf( log_file, "%p: just got reads, status is %d\n", c2, c2->status );

    /* otherwise, allow_write has been called and it's on its way already */
    http_prosecute( c2 );
}


/*--------------------------------------------------------------------------*
 * http_requeue                                                             *
 * We've fetched the first few bytes of an image, so requeue it (at a lower *
 * priority) to get the other bits.                                         *
 *--------------------------------------------------------------------------*/

static void http_requeue( http_connection *c )
{
    http_queue *q = c->queue;
    http_connection *qptr;

    http_free_headers( c->headers );
    c->headers = NULL;

    if ( !q || (!q->queue && !c->queuenext)
         || ( c->flags & http_flags_NOTALIVE ) )
    {
        fdebugf( log_file, "%p: restarting\n", c );

        if ( c->flags & http_flags_NOTALIVE )
        {
            http_socket_close( c );
        }

        c->flags &= http_open_flags_ALLUSER | http_flags_SERVER
                    | http_flags_GOTFIRST;

        if ( c->socket == -1 )
        {
            /* Must start a new connection */
            http_open_socket( c );
        }
        else
            http_set_status( c, status_REQUESTING );

        return;
    }

    fdebugf( log_file, "%p: requeueing\n", c );

    http_queue_allow_read( c );

    c->flags &= http_open_flags_ALLUSER | http_flags_SERVER
                | http_flags_GOTFIRST;

    /* Add to end of queue */
    qptr = q->queue;
    if ( qptr )
    {
        while ( qptr->queuenext )
            qptr = qptr->queuenext;

        qptr->queuenext = c;
        c->queueprev = qptr;
    }
    else
    {
        q->queue = c;
        c->queueprev = NULL;
    }
    c->queuenext = NULL;
    http_set_status( c, status_AWAITING_CONNECTION );
}


        /*====================*
         *   SWI HTTP_Close   *
         *====================*/


static _kernel_oserror *http_close(http_close_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    return http_close_handle(c, args->in.flags);
}

_kernel_oserror *http_close_handle(http_connection *c, int flags)
{
    /* Note that we DO free the outgoing headers as we've taken copies of
     * them !!
     */

    fdebugf( log_file, "%p: being closed by SWI http_close (socket %d)\n", c,
             c->socket );

    /* Unlink from queue. If we're at the head of the queue, and not being
     * shut down completely, orphan the rest of the queue.
     */
    if ( c->queueprev )
    {
        /* Easy case -- mid-queue */
        if ( c->queuenext )
            c->queuenext->queueprev = c->queueprev;
        c->queueprev->queuenext = c->queuenext;

        if ( ( c->socket > -1 )
            && c->status > status_CONNECTING )
        {
            /* If we've sent a request down this socket then its current
             * owner will be unable to send a further request down it.
             */
            c->queueprev->flags |= http_flags_NOTALIVE;
        }

        /* Don't close the socket! We don't own it! */
        c->socket = -1;
    }
    else
    {
        /* Head of the queue. 2 cases: active and queued */
        if ( c->queue && c->queue->queue == c )
        {
            /* We were stuck in the queue anyway */
            c->queue->queue = c->queuenext;
            c->queuenext->queueprev = NULL;
            c->queuenext = NULL;
            c->queueprev = NULL;
        }
        else
        {
            /* We were active */
            if ( flags & http_close_FATAL )
            {
                if ( c->queuenext )
                    c->queuenext->queueprev = NULL;
            }
            else
            {
                if ( c->socket != -1 )
                {
                    /* We must check the status here, it's no good passing on
                     * a socket that's in the middle of a GIF fetch!
                     */
                    if ( c->flags & http_flags_NOTALIVE
                         || ( c->status < status_COMPLETED_FILE ) )
                    {
                        /* Close the socket first so that we know orphan_queue
                         * is allowed to create a new one
                         */
                        http_socket_close( c );
                        http_orphan_queue( c );
                    }
                    else
                        http_queue_allow_read( c );
                }
            }
        }
    }

    http_set_status( c, status_FINISHING );  /* sort out sockets_connecting */

#ifndef NO_SECURE
    if ( c->SSL != NULL )
    {
        fdebugf( log_file, "Closing SSL connection\n" );
        SSL_free( c->SSL );
    }
#endif

/*  http_cons[c->socket] = NULL; */

    if (c->fh != NULL)
    {
        fdebugf(log_file, "Closing output file\n");
        ro_fclose(c->fh);
    }

    if (c->bh != NULL)
    {
        fdebugf(log_file, "Closing body file\n");
        ro_fclose(c->bh);
    }

    /* Do this one first in case someone is stupid enough to set the type and
     * then delete
     */
    if (flags & http_close_SET_TYPE)
    {
        http_set_file_type(c, NULL);
    }

    if (flags & http_close_DELETE_FILE)
    {
        if (c->fname)
        {
            fdebugf(log_file, "Removing file '%s'\n", c->fname);
            remove(c->fname);
        }
    }

    if (flags & http_close_DELETE_BODY)
    {
        if (c->bname)
        {
            fdebugf(log_file, "Removing file '%s'\n", c->bname);
            remove(c->bname);
        }
    }

    http_socket_close(c); /* Does its own check for valid socket number */

    if (c->fname)
    {
        free(c->fname);
    }

    if (c->bname)
    {
        free(c->bname);
    }

    if (c->message)
    {
        free(c->message);
    }

    if (c->object)
    {
        free(c->object);
    }

    http_free_headers(c->headers); /* Does its own check for NULL pointers */
    http_free_headers(c->sendhead_base);

    /* Finally, zap the magic number */
    c->magic = 0;

/*     fdebugf(log_file, "Unlinking from list\n"); */

    if (c->prev == NULL)
        http_cons_list = c->next;
    else
        c->prev->next = c->next;

    if (c->next != NULL)
        c->next->prev = c->prev;

/*     fdebugf(log_file, "Freeing connection structure\n"); */
    free(c);

    fdebugf(log_file, "Connection closed.\n");

    return 0;
}


        /*=================*
         *   Other SWIs    *
         *=================*/


static _kernel_oserror *http_status(http_status_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    if ( c->status == status_FAIL_LOCAL )
    {
        httperror.errnum = 1;
        strcpy( httperror.errmess, c->message );
        return &httperror;
    }

    /* Lie to people about the state of requeued connections */
    if ( (c->flags & http_flags_GOTFIRST)
         && c->status < status_GETTING_BODY )
        args->out.status = status_GETTING_BODY;
    else
        args->out.status = c->status;

    args->out.ro_fh = c->fh ;
    args->out.fname = c->fname ;
    args->out.data_size = c->total_size ? c->total_size : c->data_size ;
    args->out.data_so_far = c->data_so_far ;
    args->out.headers = c->headers ;

    if ( c->rc == 206
         && c->data_so_far == c->total_size )
        args->out.rc = 200;     /* "OK" */
    else
        args->out.rc = c->rc;

/*     fdebugf( log_file, "%p: http_status returning status=%d rc=%d\n",
             c, args->out.status, args->out.rc ); */

    args->out.message = c->message ;

    return NULL;
}

static _kernel_oserror *http_maptoriscos(http_maptoriscos_args *args)
{
    args->out.ft = mime_map_to_riscos(args->in.extn);
    return NULL;
}

static _kernel_oserror *http_mapfromriscos(http_mapfromriscos_args *args)
{
    args->out.extn = mime_map_from_riscos(args->in.ft);
    return NULL;
}

static _kernel_oserror *http_setfiletype(http_setfiletype_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    return http_set_file_type(c, &args->out.ftype);
}


/*--------------------------------------------------------------------------*
 * SWI HTTP_CompletedPart                                                   *
 * Client has finished dealing with the current part of a server-push       *
 * document, so it's time to pile on and get the next part.                 *
 *--------------------------------------------------------------------------*/

static _kernel_oserror *http_completedpart( http_completedpart_args *args )
{
    http_connection *c;
    _kernel_oserror *ep;
    char *fname = args->in.newfname;
    int flags = args->in.flags;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    if ( c->status != status_COMPLETED_PART )
        return make_error( err_NOT_WAITING );

    /* Get rid of the existing file if required */

    if ( fname )
    {

        if (c->fh != NULL)
        {
            fdebugf(log_file, "%p: closing output file in completedpart\n", c);
            ro_fclose(c->fh);
            c->fh = NULL;
        }

        if (flags & http_close_SET_TYPE)
            http_set_file_type(c, NULL);

        if ( flags & http_close_DELETE_FILE )
        {
            fdebugf(log_file, "%p: removing file '%s'\n", c, c->fname);
            remove(c->fname);
        }
        free( c->fname );

        /* Make a new file */

        c->fname = strdup(fname);
        if (c->fname == NULL)
            return http_destroy(c,err_NO_MEMORY);

        fdebugf(log_file, "%p: http_completed_part opening file '%s'\n", c, c->fname);
        c->fh = ro_fopen(c->fname, RO_OPEN_WRITE);
        if (c->fh == NULL)
            return http_destroy(c,err_CANT_OPEN_FILE);
    }
    else
    {
        /* We reuse the existing file... actually this needs no code here! */
    }

    /* Send it on its way */

    c->data_so_far = -1;
    c->data_size = -1;

    http_set_status( c, status_GETTING_HEADERS );

    http_prosecute( c );

    return NULL;
}


void http_send_request(http_connection *c)
{
    char *meth = c->bh ? "POST " :
                 (c->flags & http_open_flags_HEAD ) ? "HEAD "
                                                    : "GET ";
    struct iovec iov[3];

    sprintf( tmp_buffer, " %s\r\n", http_version );

    iov[0].iov_base = meth;
    iov[0].iov_len  = strlen(meth);
    iov[1].iov_base = c->object;
    iov[1].iov_len  = strlen(c->object);
    iov[2].iov_base = tmp_buffer;
    iov[2].iov_len  = strlen(tmp_buffer);

#if DEBUG
    /* need the if 'cos of use of onthissocket */
    fdebugf( log_file, "%p: sending %d request %s%s %s\n", c, c->onthissocket,
             meth, c->object, http_version );
#endif

    /* Note there's an assumption here that we can send the whole request
     * line without getting an EWOULDBLOCK.
     */

#if 0
    if ( strlen( c->object ) > TMP_BUF_SIZE - 20 )
    {

        http_send(c, meth, strlen(meth) );
        http_send(c, c->object, strlen(c->object) );

        sprintf(tmp_buffer, " %s\r\n", http_version);
    }
    else
    {
        sprintf(tmp_buffer, "%s%s %s\r\n",
                           meth, c->object, http_version);
    }
#endif

    if (http_sendv(c, iov, 3 ) < 0)
    {
        http_fail( c, status_FAIL_REQUEST );
    }
    else
    {
        http_set_status( c, status_REQUEST_HEADERS );
        c->sendhead = c->sendhead_base;
    }
}


/*---------------------------------------------------------------------------*
 * http_send_request_headers                                                 *
 * Sends as many header lines as it can. Returns 0 if it gave up (all sent,  *
 * or network error), EWOULDBLOCK otherwise.                                 *
 *---------------------------------------------------------------------------*/

int http_send_request_headers( http_connection *c )
{
    int rc;

    while ( c->status == status_REQUEST_HEADERS )
    {
        if ( c->sendhead )
        {
            sprintf( tmp_buffer, "%s: %s\r\n", c->sendhead->key,
                                 c->sendhead->value );

            fdebugf( log_file, "%p: txheader %s: %s\n", c, c->sendhead->key,
                               c->sendhead->value );
        }
        else
        {
            /* end of supplied headers -- send Content-Length if reqd */
            *tmp_buffer = 0;

            if (c->bh)
            {
                if (c->data_size == -1)
                    c->data_size = http_file_size(c->bname);
                sprintf(tmp_buffer, "Content-length: %d\r\n", c->data_size);

                fdebugf( log_file, "%p: txheader Content-length: %d\n",
                                   c, c->data_size );
            }

            /* Don't send keep-alive to proxies unless they do HTTP/1.1
             * (for rationale see RFC2068)
             */
            if ( (c->flags & http_flags_HTTP11)
                 || !strchr( c->object, ':' ) )
            {
                strcat( tmp_buffer, "Connection: Keep-Alive\r\n" );
                fdebugf( log_file, "%p: txheader Connection: Keep-Alive\n", c );
            }

            /* If this is an image, and isn't a priority (ie isn't the
             * background image), and is a normal fetch, only ask for the first
             * few bytes. If we've already had the first few bytes, ask for
             * the remainder.
             */
            if ( c->flags & http_flags_GOTFIRST )
            {
                /* Unbelievably, F**kWitScape Enterprise Server gets it wrong
                 * if you ask it for "bytes=256-" ... it only gives you 1000
                 * bytes even if there are more.
                 */
                char *ptr = tmp_buffer + strlen( tmp_buffer );

                sprintf( ptr, "Range: bytes=" IMAGE_HEADER1_T "-%d\r\n",
                              c->total_size-1 );
                fdebugf( log_file, "%p: txheader Range: bytes=" IMAGE_HEADER1_T
                                   "-%d\n", c, c->total_size-1 );
            }
            else if ( ( c->flags & http_open_flags_IMAGE )
                      && !( c->flags & ( http_open_flags_PRIORITY
                                        | http_open_flags_HEAD ) )
                      && !c->bh )
            {
                strcat( tmp_buffer, "Range: bytes=0-" IMAGE_HEADER_T "\r\n" );
                fdebugf( log_file, "%p: txheader Range: bytes=0-"
                                   IMAGE_HEADER_T "\n", c );
            }

            strcat(tmp_buffer, "\r\n");
        }

        rc = http_send( c, tmp_buffer, strlen(tmp_buffer) );

        if ( rc < 0 )
        {
            if ( errno != EWOULDBLOCK )
            {
                http_fail( c, status_FAIL_REQUEST );
                return 0;
            }
            return EWOULDBLOCK;
        }

        if ( c->sendhead )
            c->sendhead = c->sendhead->next;
        else
        {
            /* all done; set up request body if there is one */
            if ( c->bh )
            {
                http_set_status( c, status_REQUEST_BODY );
                ro_fread(c->buffer, 1,
                         c->data_size > MAX_INPUT ? MAX_INPUT : c->data_size,
                         c->bh);
                c->data_so_far = 0;
            }
            else
            {
                http_set_status( c, status_WAITING );
            }
        }
    }
    return 0;
}

/* Returns 0 if data was sent or the connection died, EWOULDBLOCK if it would block */
int http_send_request_body(http_connection *c)
{
    int sent;
    int to_go;

    /* This is always entered with the c->buffer as full as it can be,
     * c->data_size the size of the file to be sent and c->data_so_far
     * the amount of data sent to far.
     */

    fdebugf(log_file, "Sending data: so far %d of %d\n", c->data_so_far, c->data_size);

    to_go = c->data_size - c->data_so_far;

    if (to_go > 0)
        sent = http_send(c, c->buffer, to_go > MAX_INPUT ? MAX_INPUT : to_go );
    else
        sent = 0;

    if ( sent < 0)
    {
        if (errno != EWOULDBLOCK)
        {
            http_fail( c, status_FAIL_REQUEST );
        }
        else
        {
            /* If it would block then just return */
            return EWOULDBLOCK;
        }
    }
    else
    {
        c->data_so_far += sent;
        to_go -= sent;

        if (to_go > 0)
        {
            if (sent != MAX_INPUT)
                memmove(c->buffer, c->buffer + sent, MAX_INPUT - sent);

            ro_fread(c->buffer + MAX_INPUT - sent, 1, sent > to_go ? to_go : sent, c->bh);
        }
        else
        {
            c->data_size = c->data_so_far = -1;
            http_set_status( c, status_WAITING );
        }
    }

    return 0;
}

#define MAX_LINE 256

/*
 * Read some more data from the line and return the next line of data
 */
char* http_getline(http_connection *c, int read)
{
    char *end;
    int rc = 1;     /* any non-zero value */

    if (c->buf_used)
    {
        memmove(c->buffer, c->buffer + c->buf_used, c->buf_off - c->buf_used + 1);
        c->buf_off -= c->buf_used;
        c->buf_used = 0;
    }

    /* pdh: might as well always read it */
    if ( MAX_LINE - c->buf_off - 1 > 0 )
    {
        rc = http_recv( c, c->buffer + c->buf_off, MAX_LINE - c->buf_off - 1);

        if ( rc==0 )
        {
            fdebugf(log_file, "%p: EOF in getline (%d chars)\n", c,c->buf_off );

            if ( c->buf_off == 0 )
            {
                http_fail( c, status_FAIL_REQUEST );
                return NULL;
            }
        }

        if ( rc < 0 )
        {
            if (errno != EWOULDBLOCK)
            {
                if ( errno == ECONNRESET )
                {
                    /* This is Netscape's ever-so-polite way of telling us
                     * not to do any more fetches down this socket
                     */
                    fdebugf( log_file,
                             "%p: ECONNRESET, retrying on new socket\n", c );

                    /* Don't let socket_close delete the queue! */
                    if ( c->queue )
                        c->queue->nsockets++;

                    http_socket_close( c );

                    c->flags &= ( http_open_flags_ALLUSER | http_flags_SERVER
                                    | http_flags_GOTFIRST );

                    http_open_socket( c );

                    if ( c->queue )
                        c->queue->nsockets--;
                }
                else
                {
                    fdebugf( log_file, "%p: *** failed in getline (errno=%d)\n",
                             c, errno );

                    http_fail( c, status_FAIL_REQUEST );
                }
                return NULL;
            }
        }
        else
        {
            c->buf_off += rc;
        }
    }

    /* pdh: moved this termination outside the if */
    c->buffer[c->buf_off] = 0; /* Make use we always have a NULL at the end */
    end = strchr(c->buffer, '\n');

    if (end)
    {
        c->buf_used = (end - c->buffer) + 1;
        if (end[-1] == '\r')
            end[-1] = 0;
        end[0] = 0;
        return c->buffer;
    }
    else if ( (MAX_LINE - c->buf_off - 1 == 0) || !rc ) /* Phrased like this as this is the formula used in the recv() call */
    {
        /* This is not a good situation, the buffer is full but we don't have
         * a line feed */
        c->buf_used = c->buf_off + 1;
        fdebugf(log_file, "%p: getline buffer filled up (%d chars %d %d %d); cleared\n", c, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
        return c->buffer;
    }
    return NULL;
}

static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value )
{
    http_header_item *hi;

    for ( hi = c->headers; hi; hi = hi->next )
    {
        /* Make sure duplicate headers only go in once (important in
         * server-push case)
         */
        if ( strcasecmp( hi->key, key ) == 0 )
        {
            free( hi->value );
            hi->value = strdup( value );
            return hi;
        }
    }

    hi = malloc(sizeof(http_header_item));
    if (hi)
    {
        hi->key = strdup(key);
        hi->value = strdup(value);

        if (hi->key == NULL || hi->value == NULL)
        {
            if (hi->key)
                free(hi->key);
            if (hi->value)
                free(hi->value);
            free( hi );
            hi = NULL;
        }
    }

    if (hi)
    {
        hi->next = c->headers;
        c->headers = hi;
    }

    return hi;
}

void http_process_header_line(http_connection *c, char *l)
{
    char *p;

/*     fdebugf(log_file, "%p: rxheader '%s'\n", c, l); */

    if ( !*l )
    {
        if ( c->nearlyboundary == -1 )
        {
            /* Nasty hack 'cos server-push starts off in the "wrong" state
             */
            c->nearlyboundary = 0;
        }
        else
        {
            c->status = status_GETTING_BODY;

            fdebugf( log_file, "%p: entering getting_body state, sofar=%d size=%d total=%d\n", c, c->data_so_far, c->data_size, c->total_size );
        }
    }
    else
    {
        /* Try to split the the header line */
        p = strchr(l, ':');
        if (p != 0)
        {
            char *q;

            *p = 0;
            while (isspace(*(++p)))
                ;

            q = p + strlen(p);
            while ((q > p) && isspace(q[-1]))
                q--;
            *q = 0;

            if ( http_check_special_headers( c, l, p ) )
                http_add_header_line( c, l, p );
        }
        else
        {
            fdebugf(log_file, "Badly formed header line, no ':'\n");
        }
    }
}


/*---------------------------------------------------------------------------*
 * http_set_server_flag                                                      *
 * We've just found out something that potentially affects how everyone      *
 * talks to this server, so tell everyone about it                           *
 *---------------------------------------------------------------------------*/

void http_set_server_flag( http_connection *c, int flag )
{
    http_connection *c2 = http_cons_list;

    while ( c2 )
    {
        if ( !memcmp( &c->sa, &c2->sa, sizeof( struct sockaddr_in ) ) )
        {
            c2->flags |= flag;
            if ( c2->queue )
                c2->queue->flags |= flag;
        }
        c2 = c2->next;
    }
}

void http_process_response_line(http_connection *c, char *l)
{
    fdebugf(log_file, "%p: received '%s'\n",  c, l);

    if (strncmp(l, http_version_check, strlen(http_version_check)) == 0)
    {
        char *p;

        p = l + strlen(http_version);
        while (isspace(*(++p)))
            ;
        c->rc = atoi(p);

        p += 2;
        while (isspace(*(++p)))
            ;
        http_set_message( c, p );
        fdebugf(log_file, "%p: response %d '%s'\n", c, c->rc, c->message ? c->message
                                                            : "<no message>");

        if ( (c->flags & http_flags_HTTP11) == 0
             && !strncmp( l+5, "1.1", 3 ) )
        {
            http_set_server_flag( c, http_flags_HTTP11 );
        }

        http_set_status( c, status_GETTING_HEADERS );
    }
    else
    {
        /* Either it's HTTP/0.9 or it's just not playing the game */
        fdebugf(log_file, "Badly formed response line\n");

        c->rc = 200;
        http_set_message( c, "Badly formed response; continuing anyway." );
        http_set_status( c, status_GETTING_BODY );

        /* Squeeze this line back in the buffer so it can get flushed out */
        c->buffer[c->buf_used-1] = '\n';
        if (c->buffer[c->buf_used-2] == 0)
            c->buffer[c->buf_used-2] = '\r';
        c->buf_used = 0;
    }
}

void http_flush_data_to_file(http_connection *c)
{
    /* NB. Contrary to a previous comment here, the flush is *NOT* always for
     * the initial data (in the case of a Partial Content reply)
     */

    if ( c->data_so_far == -1 )
        c->data_so_far = 0;

    if (c->fh && (c->buf_off != c->buf_used))
    {
        int n;
        int wrote;

        n = c->buf_off - c->buf_used;
        wrote = ro_fwritepos( c->buffer + c->buf_used, n, 1, c->fh,
                              c->data_so_far);
        if ( wrote < n )
        {
            http_oserror( c, _kernel_last_oserror() );
            return;
        }

        c->buf_off = c->buf_used = 0;
        c->data_so_far += n;
        fdebugf( log_file, "%p: flushed %d bytes of body (so_far=%d)\n", c, n,
                           c->data_so_far );
    }
}


/*---------------------------------------------------------------------------*
 * http_queue_dec_nsockets                                                   *
 * Decrement the number of sockets registered as belonging to the queue.     *
 * This is used in socket_close, when the socket is going away altogether,   *
 * and also in orphan_queue, when the socket isn't going away, but doesn't   *
 * belong to this queue any more.                                            *
 *     Care is needed to stop this being called twice on any given socket:   *
 * socket_close sets c->socket to -1 and orphan_queue sets c->queue to       *
 * NULL, both of which act to prevent double decrementing.                   *
 *---------------------------------------------------------------------------*/

void http_queue_dec_nsockets( http_connection *c )
{
    if ( c->socket != -1 )
    {
        http_queue *q = c->queue;
        if ( q )
        {
            q->nsockets--;
            fdebugf( log_file, "%p: decrementing queue %p's nsockets to %d\n",
                     c, q, q->nsockets );
            if ( q->nsockets == 0 )
            {
                if ( q->queue )
                {
                    fdebugf( log_file, "%p: *** ERROR queue %p being freed with connection %p still on it\n", c, q, q->queue );
                }

                fdebugf( log_file, "%p: freeing queue %p\n", c, q );

                if ( q->prev )
                    q->prev->next = q->next;
                else
                    http_queues_list = q->next;

                if ( q->next )
                    q->next->prev = q->prev;

                free( q );
                c->queue = NULL;

                if ( c->queuenext )
                    c->queuenext->queue = NULL;
            }
            /* We *don't* set c->queue to NULL here (unless the queue has
             * vanished), as this messes up the requeue case. Setting c->queue
             * to NULL is orphan_queue's job.
             */
        }
    }
}

void http_socket_close(http_connection *c)
{
    if (c->socket != -1)
    {
        totalsockets--;
#if 0
        fdebugf( log_file, "%p: closing socket %d (%d left)\n", c, c->socket,
                 totalsockets );
#endif
        http_queue_dec_nsockets( c );

        http_cons[c->socket] = NULL;

        socketclose(c->socket);
        c->socket = -1;

        if ( c->queuenext )
        {
            fdebugf( log_file, "%p: pipelined connection %p is stuffed too\n",
                               c, c->queuenext );
            c->queuenext->socket = -1;
        }
    }
}


/*---------------------------------------------------------------------------*
 * http_check_special_headers()                                              *
 * Returns TRUE if it's okay to pass this header on to the client            *
 *---------------------------------------------------------------------------*/

BOOL http_check_special_headers( http_connection *c, char *key, char *value )
{
    if (strcasecmp(key, "CONTENT-LENGTH") == 0)
    {
        int s;
        s = atoi(value);
        if (s > 0)
        {
            /* When getting a partial content, this size is the size of
             * the range, *not* of the whole file. When getting the first
             * part of an image, we want c->data_size to be 256 so that the
             * GETTING_BODY state terminates; however, when getting the second
             * half, we definitely want it to be right.
             */
            if ( c->data_size == -1 )
            {
                c->data_size = s;

                /* RISC OS will give us a random size */
                if ( c->fh )
                {
                    ro_ensure_size(c->fh, c->data_size);
                    ro_fclose(c->fh);
                    c->fh = ro_fopen(c->fname, RO_OPEN_WRITE);
                }
            }
            else
            {
                char realsize[20];

                if ( s == c->total_size
                     || c->total_size == 0 )
                    return TRUE;    /* OK to pass it on */

                /* Not OK, it's the length of this transaction, so fake up a
                 * header that's the length of the whole lot.
                 */
                sprintf( realsize, "%d", c->total_size );
                http_add_header_line( c, key, realsize );
                return FALSE;
            }
        }
    }
    else if ( strcasecmp( key, "CONNECTION" ) == 0 )
    {
        char *p = value;

        while ( p )
        {
            if ( prefixcmp( p, "CLOSE" ) == 0 )
            {
                c->flags &= ~http_flags_KEPTALIVE;
                c->flags |= http_flags_NOTALIVE;
                http_orphan_queue( c );
            }

            if ( prefixcmp( p, "KEEP-ALIVE" ) == 0 )
            {
                c->flags |= http_flags_KEPTALIVE;

                if ( !(c->flags & http_flags_DOESKEEPALIVE ) )
                    http_set_server_flag( c, http_flags_DOESKEEPALIVE );
            }

            p = strchr( p, ',' );
            if ( p )
            {
                p++;
                while ( isspace( *p ) )
                    p++;
            }
        }
    }
    else if ( strcasecmp( key, "TRANSFER-ENCODING" ) == 0
         && strcasecmp( value, "CHUNKED" ) == 0 )
    {
        c->flags |= http_flags_CHUNKED;
    }
    else if ( strcasecmp( key, "CONTENT-TYPE" ) == 0
              && ( prefixcmp( value, "MULTIPART/X-MIXED-REPLACE" ) == 0
                   || prefixcmp( value, "MULTIPART/X-BYTERANGES" ) == 0 ) )
    {
        /* Oooh, it's server push. Now the fun really starts. */

        /* Actually we must cope with multipart byteranges as well, as at
         * least one server (WebSitePro/1.1f) returns all this mime junk even
         * if we've only asked for *one* byte range -- this is not as per spec!
         */

        char *p = strchr( value, ';' );

        if ( p )
        {
            p++;
            while ( isspace(*p) )
                p++;
            if ( prefixcmp( p, "BOUNDARY" ) == 0 )
            {
                p = strchr( p, '=' );

                if ( p )
                {
                    p++;
                    while ( isspace(*p) )
                        p++;

                    c->boundary = malloc( strlen(p)+2 );

                    if ( c->boundary )
                    {
                        strcpy( c->boundary, "--" );
                        strcat( c->boundary, p );
                        c->flags &= ~http_flags_KEPTALIVE;
                        c->flags |= http_flags_NOTALIVE;

                        c->nearlyboundary = -1; /* magic value */

                        fdebugf(log_file, "%p: server push, boundary is '%s'\n",
                                c, c->boundary+1 );

                        /* client doesn't see this header (important for
                         * set_file_type to work)
                         */
                        return FALSE;
                    }
                }
            }
        }
    }
    else if ( strcasecmp( key, "CONTENT-RANGE" ) == 0 )
    {
        int from,to,total;

        /* Cope with both "bytes=aa-bb/cc" and "aa-bb/cc"
         */

        if ( !isdigit( *value ) )
            value += 6;

        sscanf( value, "%d-%d/%d", &from, &to, &total );

        fdebugf( log_file, "%p: Bytes %d to %d inclusive of a total of %d\n",
                            c, from, to, total );
        c->total_size = total;

        if ( to == total-1 )
        {
            /* Second half of a transfer */
            c->data_size = total;
        }
        else
        {
            /* First half of a transfer */
            c->flags |= http_flags_GOTFIRST;
        }

        if ( !(c->flags & http_flags_DOESRANGE ) )
            http_set_server_flag( c, http_flags_DOESRANGE );

        /* If we've had one of these, we'd best have had Content-Length
         * as well, or else.
         */
        return FALSE;   /* don't pass on to client */
    }
    return TRUE;    /* pass on to client */
}

#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error)
{
    if ( !ok )
    {
        if ( depth >= CERT_VERIFY_DEPTH )
            ok=1;
        else
            verify_error = TRUE;
    }

    return(ok);
}
#endif

/*
 * New function to use the crypto routines to verify a message digest against
 * a public key and maybe a certificate.

API:

VerifyMessageDigest

 IN
   int    : flags
          : type of key.certificate
   char * : message data
   int    : message data length
   int    : digest type
   char * : digest received
   int    : digest received length
   char * : ptr to DER encoded public key
   char * : filename of X509 certificate in PEM

 OUT
   Does it match or not? or error

Here is what was sent to the NSA

   API extension for HTTP-SSL module.
   ==================================

A new interface is created called HTTP_VerifyMessageDigest.

The parameters to this are

      flags word
      pointer to and length of message
      pointer to and length of encrypted message digest
      message digest type
      pointer to DER encoded public key
      optional pointer to filename of X509 certificate in PEM or DER encoding

If the X509 certificate is given then the public key is used to
verify the certificate and extract a new public key. This public
key is then used to verify the message digest.

If no certificate is given then the public key given is used to verify
the message digest.

The routine will return success or an error code giving at what point
the failure to verify occurred. This will be one of
   Input values bad in some way
   Certificate failed to verify
   Digest failed to verify

   */

static _kernel_oserror *http_verifymessagedigest(http_verifymessagedigest_args *r)
{
#if defined(NO_SECURE)
    return make_error(err_SSL_NOT_AVAILABLE);
    r = r;
#elif !defined(VERIFY_MD)
    r->out.rc = http_vmd_rc_NOT_SUPPORTED;
    return NULL;
    r = r;
#else
    _kernel_oserror *e = NULL;
    EVP_PKEY *pkey = NULL;
    int rc = http_vmd_rc_BAD_INPUT;

    fdebugf(log_file, "HTTP_VerifyMessageDigest:\n  flags %08x\n  key '%s'\n  cert '%s'\n  message @ 0x%p/%d\n  digest @ 0x%p/%d\n",
	    r->in.flags,
	    r->in.public_key ? r->in.public_key : "",
	    r->in.certificate ? r->in.certificate : "",
	    r->in.message_data, r->in.message_data_len,
	    r->in.digest_data, r->in.digest_data_len);

    /* check some initial values */
    if (r->in.message_data == NULL || r->in.message_data_len == 0 ||
	r->in.digest_data == NULL || r->in.digest_data_len == 0)
    {
	r->out.rc = rc;
	return NULL;
    }

    /* get the initial public key from the file */
    if (r->in.public_key)
    {
	FILE *f;
	if ((f = fopen(r->in.public_key, "rb")) != NULL)
	{
	    X509 *xcert;

	    /* extract X509 certificate from file */
	    if (r->in.flags & http_vmd_flag_KEY_DER)
	    {
		xcert = d2i_X509_fp(f, NULL);
	    }
	    else
	    {
		xcert = PEM_read_X509(f, NULL, 0); /* specify default callback function - could be awkward if it was called */
	    }

	    fclose(f);

	    fdebugf(log_file, "key cert @ 0x%p\n", xcert);

	    if (xcert)
	    {
		pkey = X509_extract_key(xcert);

		fdebugf(log_file, "key @ 0x%p\n", pkey);

		X509_free(xcert);
	    }
	}
    }

    /* if there's a certificate given then extract the public key from it to use instead */
    if (pkey && r->in.certificate)
    {
	FILE *f;
	if ((f = fopen(r->in.certificate, "rb")) != NULL)
	{
	    X509 *xcert;

	    /* extract X509 certificate from file */
	    if (r->in.flags & http_vmd_flag_CERT_DER)
	    {
		xcert = d2i_X509_fp(f, NULL);
	    }
	    else
	    {
		xcert = PEM_read_X509(f, NULL, 0); /* specify default callback function - could be awkward if it was called */
	    }

	    fclose(f);

	    fdebugf(log_file, "new cert @ 0x%p\n", xcert);

	    if (xcert)
	    {
		if (X509_verify(xcert, pkey))
		{
		    /* free the initial key */
		    EVP_PKEY_free(pkey);

		    /* replace with the new key */
		    pkey = X509_extract_key(xcert);

		    fdebugf(log_file, "new key @ 0x%p\n", pkey);

		    if (!pkey)
			rc = http_vmd_rc_BAD_CERT;
		}
		else
		{
		    fdebugf(log_file, "new cert failed to verify\n");
		    rc = http_vmd_rc_BAD_CERT;
		}

		X509_free(xcert);
	    }
	}
    }

    /* if we have a public key by this point */
    if (pkey)
    {
	EVP_MD_CTX md_ctx;

	/* set up and verify the message digest
	 * assume MD5 only for now unless we need others
	 */
	fdebugf(log_file, "VerifyInit\n");
	EVP_VerifyInit(&md_ctx, EVP_md5());

	fdebugf(log_file, "VerifyUpdate\n");
	EVP_VerifyUpdate(&md_ctx, (unsigned char *)r->in.message_data, r->in.message_data_len);

	fdebugf(log_file, "VerifyFinal\n");
	if (EVP_VerifyFinal(&md_ctx, (unsigned char *)r->in.digest_data, r->in.digest_data_len, pkey))
	    rc = http_vmd_rc_VERIFIED;
	else
	    rc = http_vmd_rc_FAILED;

	fdebugf(log_file, "rc=%d\n", rc);

	/* free any key we have open */
	EVP_PKEY_free(pkey);
    }

    r->out.rc = rc;

    return e;
#endif
}

/* eof http.c */
