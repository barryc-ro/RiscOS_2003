/* -*-c-*- */

/* http.c */

/*
 * The HTTP module provides a mechanism for sending requests and
 * fetching results using the HyperText Transfer Protocol.
 *
 * pdh 01-Jul-96 Begin HTTPS (HTTP+SSL) support (defeat with -DNO_SECURE)
 * pdh 03-Jul-96 HTTPS now working
 * pdh 04-Jul-96 The last reallocs excised from httpsmod -- verify now works
 * pdh 29-Jul-96 Added HEAD support
 * pdh 12-Sep-96 Corrected internet event code -- hogs machine much less now
 * SJM 20-Nov-96 Took out excess strduping in status_AUTHENTICATING and added
 *		 setting of SSL_VERSION system variable.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "tcplibs.h"

#include "status.h"

#ifndef NO_SECURE
#include "ssl.h"
extern _kernel_oserror *SSL_LibraryPresent( void );
#define CERT_VERIFY_DEPTH 10
#endif

#include "httppub.h"
#include "http.h"

#include "files.h"
#include "mimemap.h"

#ifndef FILETYPE_HTML
#define FILETYPE_HTML	0xfaf
#endif

#define SSL_VERSION_VAR	"HTTP$SSLVersion"

/**********************************************************************/
/*
 * Global definitions
 */

#ifndef DEBUG
#define DEBUG 0
#endif

#ifndef TESTMODE
#define TESTMODE 0
#endif

/**********************************************************************/
/*
 * Error definitions
 */

/* Error definitions */
typedef enum {
    err_NO_SUCH_HOST,
    err_CANT_FIND_SERVICE,
    err_CANT_FIND_PROTOCOL,
    err_CANT_MAKE_SOCKET,
    err_CANT_CONNECT,
    err_BAD_IOCTL,
    err_NO_MEMORY,
    err_BAD_MAGIC,
    err_CANT_OPEN_FILE,
    err_CANT_OPEN_BODY,
    err_SSL_NOT_AVAILABLE,
    err_SSL_CANT_CONNECT,

    err_LAST_ERROR
    } error_numbers;

static char *err_strings[] = {
    "Can't find host in database",
    "Can't find service in database",
    "Can't find protocol in database",
    "Can't make socket",
    "Can't connect to server",
    "Bad IOCTL call",
    "Not enough free memory",
    "Invalid connection handle",
    "Can't open output file",
    "Can't open posting body file",
    "HTTPS not available",
    "Can't negotiate HTTPS connection",

    "Unknown error"
    };

/**********************************************************************/
/*
 * Global variable definitions
 */

void *private_word;

fd_set fd_read, fd_write;

http_connection *http_cons[FD_SETSIZE];	/* Array of pointers */

http_connection *http_cons_list;

volatile int tick_pending, data_pending, callback_pending;
volatile int threaded;

static int sockets_connecting;	/* Count of sockets in the process of connection (i.e. still need to be polled) */

#ifndef BOOL
#define BOOL int
#define TRUE 1
#define FALSE 0
#endif

#ifndef NO_SECURE
static BOOL ssl_present = TRUE;
static SSL_CTX *ssl_context = NULL;
static BOOL verify_error = FALSE;
#endif

#define TMP_BUF_SIZE	1024
char tmp_buffer[TMP_BUF_SIZE];

static char http_version[] = HTTP_VERSION;
static char http_version_check[] = HTTP_VERSION_CHECK;

FILE *log_file;

/**********************************************************************/
/*
 * Forward declarations of functions static to this file
 */

static _kernel_oserror *setup_ticker_and_event(void);
static void clear_ticker_and_event(void);
static void setup_callback(void);
static void clear_callback(void);

static _kernel_oserror *http_open(http_open_args *args);
static _kernel_oserror *http_status(http_status_args *args);
static _kernel_oserror *http_close(http_close_args *args);
static _kernel_oserror *http_maptoriscos(http_maptoriscos_args *args);
static _kernel_oserror *http_mapfromriscos(http_mapfromriscos_args *args);
static _kernel_oserror *http_setfiletype(http_setfiletype_args *args);
static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value );
static _kernel_oserror *http_prosecute( http_connection *c );
#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error);
#endif

#ifdef NO_SECURE
#define http_send(c,m,s) send((c)->socket,m,s,0)
#define http_recv(c,b,l) recv((c)->socket,b,l,0)
#else
#define http_send(c,m,s) (((c)->SSL) \
                            ? SSL_write( (c)->SSL, m, s ) \
                            : send( (c)->socket, m, s, 0 ) )

#define http_recv(c,b,l) (((c)->SSL) \
                            ? SSL_read( (c)->SSL, b, l ) \
                            : recv( (c)->socket, b, l, 0 ) )
#endif

/**********************************************************************/
/*
 * This structure is a prototype for a connection.
 */
static http_connection proto_con = {
    HTTP_MAGIC,
		/* Magic number */
    NULL,			/* Next pointer */
    NULL,			/* Prev pointerb */
    0,				/* Poll word */
    status_NEW,			/* Status */
    NULL,			/* Object name */
    NULL,			/* Outgoing headers */
    -1,				/* Socket number */
    { 0, },			/* Socket address */
    NULL,			/* File name */
    0,				/* File handle */
    NULL,			/* Body file name */
    0,				/* Body file handle */
    -1,				/* Data size */
    -1,				/* Data so far */
    NULL,			/* List of fetched headers */
    -1,				/* Return code */
    NULL,			/* Return message */
    0,				/* Buffer offset */
    0,				/* Buffer used */
    NULL,			/* Buffer data */
    NULL,                       /* SSL connection */
    0,                          /* Flags */
    0                           /* Data pending */
    };

/**********************************************************************/
/*
 * The bcmp and bzero functions are needed by various internet library
 * calls.  I just pass them through to the memXXX versions.
 */

int bcmp(void *s1, void *s2, size_t s)
{
    return memcmp(s1, s2, s);
}

void bzero(void *p, int s)
{
    memset(p, 0, s);
}

/**********************************************************************/
/*
 * Error generation function
 */

static _kernel_oserror *make_error(int err)
{
    static _kernel_oserror e;

    if (err > err_LAST_ERROR)
	err = err_LAST_ERROR;

    threaded = 0;

    e.errnum = err;
    strncpy(e.errmess, err_strings[err], 252);

#if DEBUG
    fprintf(log_file, "Making error number %d: %s\n", err, err_strings[err]);
#endif

    return &e;
}

/**********************************************************************/
/*
 * Module finalisation function
 */
static void module_final(void)
{
    http_connection *c, *next_one;

#if TESTMODE
    fprintf(log_file, "Module finalisation called\n");
#endif

    clear_ticker_and_event();

    clear_callback();

    for (c = http_cons_list; c != NULL; c = next_one)
    {
	next_one = c->next;
#if DEBUG
	fprintf(log_file, "Closeing connection at %p on socket %d\n", c, c->socket);
#endif
	http_close_handle(c, http_close_DELETE_FILE);
    }

#ifndef NO_SECURE
    if ( ssl_context )
        SSL_CTX_free( ssl_context );
#endif
}

/**********************************************************************/
/*
 * Module initialisation function
 */
extern _kernel_oserror *module_initialise(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *ep;

    private_word = pw;

    if (cmd_tail)
    {
	log_file = fopen(cmd_tail, "w");
	if (log_file == NULL)
	    log_file = stderr;
    }
    else
    {
	log_file = stderr;
    }

#if TESTMODE
    fprintf(log_file, "Module initialisation called.\n");
#endif

    FD_ZERO(&fd_read);

    bzero(http_cons, sizeof(http_cons));
    http_cons_list = NULL;

    tick_pending = data_pending = callback_pending = 0;
    sockets_connecting = 0;

#ifndef NO_SECURE
#if 0
    ssl_present = ( SSL_LibraryPresent() == NULL );
    if ( ssl_present )
#else
    ssl_present = TRUE;
    riscos_ZM_Initialise();
    riscos_SSLLib_Init();
#endif
    {
        ssl_context = SSL_CTX_new();
        SSL_load_error_strings();
        if ( ssl_context )
        {
/*            X509_add_cert_dir( ssl_context->cert, "SSL:certs", X509_FILETYPE_PEM );
            SSL_load_verify_locations( ssl_context, NULL, "SSL:certs" );*/
            SSL_set_default_verify_paths( ssl_context );
        }
        else
            ssl_present = FALSE;
    }
    _kernel_setenv(SSL_VERSION_VAR, ssl_present ? "2" : "0");
#else
    _kernel_setenv(SSL_VERSION_VAR, "0");
#endif

    ep = setup_ticker_and_event();
    if (ep)
	goto err;

    atexit(&module_final);

    return 0;

 err:
    return ep;

    UNUSED(cmd_tail);
    UNUSED(pbase);
}

/**********************************************************************/
/*
 * Module CLI handler function
 */
extern _kernel_oserror *module_cli_handler(char *arg_string, int arg_count, unsigned int cmd_no, void *pw)
{
    http_connection *c;

#if DEBUG
    fprintf(log_file, "CLI handler called, command number %d\n", cmd_no);
#endif

    switch(cmd_no)
    {
    case 0:
	printf("HTTP support module status information\n");

	if (http_cons_list)
	{
	    for (c = http_cons_list; c != NULL; c = c->next)
	    {
		printf("Connection at %p on socket %d, status = %d, data fetched = %d/%d, file name = '%s', rc = %d, message = '%s'\n",
		       c, c->socket, c->status,
		       c->data_so_far, c->data_size,
		       c->fname ? c->fname : "<garbage>",
		       c->rc,
		       c->message ? c->message : "<none>" );
	    }
	}
	else
	{
	    printf("No current connections\n");
	}
	break;
    }

    return 0;

    UNUSED(arg_string);
    UNUSED(arg_count);
    UNUSED(pw);
}

/**********************************************************************/
/*
 * Module SWI handler function
 */
extern _kernel_oserror *module_swi_handler(int swinum, _kernel_swi_regs *regs, void *pw)
{
#if 0
    /*DEBUG*/
    fprintf(log_file, "SWI handler called, SWI number 0x%02x\n", swinum);
#endif

    switch(swinum)
    {
    case 0:
	/* Open */
	return http_open((http_open_args *) regs);
	break;
    case 1:
	/* Status */
	return http_status((http_status_args *) regs);
	break;
    case 2:
	/* Close */
	return http_close((http_close_args *) regs);
	break;
    case 3:
	/* Map to RISC OS */
	return http_maptoriscos((http_maptoriscos_args *) regs);
	break;
    case 4:
	/* Map from RISC OS */
	return http_mapfromriscos((http_mapfromriscos_args *) regs);
	break;
    case 5:
	/* SetFileType */
	return http_setfiletype((http_setfiletype_args *) regs);
	break;
    }

    return NULL;

    UNUSED(pw);
}

/**********************************************************************/
/*
 * A function to handle the internet events.
 */
extern int inetevent_handler(_kernel_swi_regs *regs, void *pw)
{
    if ((regs->r[0] == Event_Internet) && (regs->r[1] >=0) && (regs->r[1] <= 2))
    {
        /*
	if ( FD_ISSET(regs->r[2], &fd_read))
        */
        if ( regs->r[2] >= 0 && regs->r[2] < FD_SETSIZE )
	{
	    /* take some action */
	    http_connection *c = http_cons[ regs->r[2] ];
	    if ( c )
	    {
	        c->data_pending = 1;
	        data_pending = 1;
	        setup_callback();
	    }
	}
    }

    return VIA_R14;

    UNUSED(pw);
}

int timer_handler( _kernel_swi_regs *r, void *pw )
{
    if ( http_cons_list != NULL )
    {
        tick_pending = 1;
        setup_callback();
    }

    return VIA_R14;
}

/**********************************************************************/
/*
 * A function to handle the callbacks caused by internet events.
 */
extern int callback_handler(_kernel_swi_regs *regs, void *pw)
{
    int max_sock = 0;
    int i;

#if 0
    if (threaded)
    {
#if DEBUG
	fprintf(log_file, "Already threaded!!!\n");
#endif
	return VIA_R14;
    }
    else
    {
        threaded = 1;
    }
#endif

#if DEBUG && 0
    fprintf(log_file, "Callback handler entered\n");
#endif

#if 1
    callback_pending = 0;

    for ( i=0; i < FD_SETSIZE; i++ )
    {
        http_connection *c = http_cons[i];
        if ( c )
        {
            if ( c->status < status_WAITING
                 || c->data_pending )
            {
                c->data_pending = 0;    /* do this FIRST */
                http_prosecute( c );

		if (c->status == status_FAIL_CONNECT ||
		    c->status == status_FAIL_REQUEST ||
		    c->status == status_FAIL_VERIFY ||
		    c->status == status_COMPLETED_FILE)
		{
		    http_socket_close(c);
		}
            }
        }
    }

#else

    /*	@@@@ N.B. There is potentially a race state around here.  If the callback pending
     *	flag gets cleared before the select call then there can be a spurious callback
     *	that has nothing to do.  If the flag gets cleared after the call then there is
     *	a small chance that the module will miss data.  Since the cost of an extra callback
     *	is not great we err on the safe side.
     */

#if 0
    do {
#endif

    callback_pending = 0;

    if (tick_pending)
    {
	int i;

	if (sockets_connecting)
	{
	    for(i=0; i<FD_SETSIZE; i++)
	    {
		http_connection *c = http_cons[i];
		if (c)
		{
		    http_prosecute( c );
		}
	    }
	}

	tick_pending = 0;
    }

    for (i = 0; i < FD_SETSIZE; i++)
    {
	if ( FD_ISSET(i, &fd_read) || FD_ISSET(i, &fd_write) )
	{
	    max_sock = i + 1;
	}
    }

#if 0
    if ( data_pending )
#endif
    {
	fd_set fd_read_tmp, fd_write_tmp, fd_excep_tmp;
	int n;
	struct timeval tv = {0};

	/* This function gets called when there has been an event on a socket */

	data_pending = 0;

	memcpy(&fd_read_tmp, &fd_read, sizeof(fd_set));
	memcpy(&fd_write_tmp, &fd_write, sizeof(fd_set));
	memcpy(&fd_excep_tmp, &fd_read, sizeof(fd_set));

	n = select(max_sock, &fd_read_tmp, &fd_write_tmp, &fd_excep_tmp, &tv);

#if DEBUG
	if (n)
	    fprintf(log_file, "Select gave a result of %d (errno = %d)\n", n, errno);
#endif

	if (n > 0)
	{
	    for( i = 0; i < FD_SETSIZE; i++)
	    {
		if (FD_ISSET(i, &fd_read_tmp) || FD_ISSET(i, &fd_write_tmp) || FD_ISSET(i, &fd_excep_tmp))
		{
		    http_connection *c = http_cons[i];

		    if (c == 0)
		    {
			/* This should not happen, try to patch things up */
			FD_CLR(i, &fd_read);
			FD_CLR(i, &fd_write);
#if DEBUG
			fprintf(log_file, "Socket %i spuriously in fd_sets, now removed\n", i);
#endif
		    }
		    else
		    {
#if DEBUG
                        fprintf( log_file, "Activity on socket %d\n", i );
#endif
		        http_prosecute( c );

			if (c->status == status_FAIL_CONNECT ||
			    c->status == status_FAIL_REQUEST ||
			    c->status == status_FAIL_VERIFY ||
			    c->status == status_COMPLETED_FILE)
			{
			    http_socket_close(c);
			}
		    }

		    n--;
		}
	    }
#if DEBUG
	    if (n != 0)
		fprintf(log_file, "%d unknown select items\n", n);
#endif
	}

    }
#endif

#if 0
    } while ( data_pending );   /* not '|| tick_pending' as we don't care
                                   if we miss a tick */
#endif

    threaded = 0;

    return VIA_R14;

    UNUSED(pw);
}

_kernel_oserror *http_check_handle(http_connection *c)
{
    if (c == NULL || c->magic != HTTP_MAGIC)
    {
	return make_error(err_BAD_MAGIC);
    }

    return 0;
}

int http_file_size(char *fname)
{
    _kernel_osfile_block fb;

    if (_kernel_osfile(5, fname, &fb) != 1) /* If it is not a plain file */
	return -1;
    else
	return fb.start;
}

_kernel_oserror *http_set_file_type(http_connection *c, int *ftptr)
{
    _kernel_osfile_block fb;

    if (c->fname)
    {
	http_header_item *hi;

	for (hi = c->headers; hi != NULL; hi = hi->next)
	{
	    if (strcasecmp(hi->key, "CONTENT-TYPE") == 0)
	    {
		int ft;

		ft = mime_map_to_riscos(hi->value);
		if (ft != -1)
		{
#if DEBUG
		    fprintf(log_file, "Setting file type of '%s' to 0x%03X\n", c->fname, ft);
#endif
		    fb.load = ft;
#if 1
		    if (ftptr)
			*ftptr = fb.load;
#endif
		    _kernel_osfile(18, c->fname, &fb);
		}
		break;
	    }
	}
	if (hi == NULL)
	{
	    fb.load = FILETYPE_HTML;
#if 1
	    if (ftptr)
		*ftptr = fb.load;
#endif
	    _kernel_osfile(18, c->fname, &fb);
	}
    }
    return NULL;
}

_kernel_oserror *http_close_handle(http_connection *c, int flags)
{
    /* Note that we DO free the outgoing headers as we've taken copies of them !! */
#if DEBUG
    fprintf(log_file, "Closing the connection at %p\n", c);
#endif

    if ( c->status == status_CONNECTING
         || c->status == status_AUTHENTICATING
         || c->status == status_REQUESTING
         || c->status == status_REQUEST_HEADERS
         || c->status == status_REQUEST_BODY )
    {
        sockets_connecting--;
#if DEBUG
        fprintf( log_file, "Decrementing sockets_connecting to %d in close_handle", sockets_connecting );
#endif
    }

#ifndef NO_SECURE
    if ( c->SSL != NULL )
    {
#if DEBUG
        fprintf( log_file, "Closing SSL connection\n" );
#endif
        SSL_free( c->SSL );
    }
#endif

    http_cons[c->socket] = NULL;

    if (c->fh != NULL)
    {
#if DEBUG
	fprintf(log_file, "Closing output file\n");
#endif
	ro_fclose(c->fh);
    }

    if (c->bh != NULL)
    {
#if DEBUG
	fprintf(log_file, "Closing body file\n");
#endif
	ro_fclose(c->bh);
    }

    /* Do this one first in case someone is stupid enough to set the type and then delete */
    if (flags & http_close_SET_TYPE)
    {
	http_set_file_type(c, NULL);
    }

    if (flags & http_close_DELETE_FILE)
    {
	if (c->fname)
	{
#if DEBUG
	    fprintf(log_file, "Removing file '%s'\n", c->fname);
#endif
	    remove(c->fname);
	}
    }

    if (flags & http_close_DELETE_BODY)
    {
	if (c->bname)
	{
#if DEBUG
	    fprintf(log_file, "Removing file '%s'\n", c->bname);
#endif
	    remove(c->bname);
	}
    }

    http_socket_close(c);	/* This does its own check for the validity of the socket number */

    if (c->fname)
    {
#if DEBUG
	    fprintf(log_file, "Freeing output file name\n");
#endif
	free(c->fname);
    }

    if (c->bname)
    {
#if DEBUG
	    fprintf(log_file, "Freeing body file name\n");
#endif
	free(c->bname);
    }

    if (c->message)
    {
#if DEBUG
	    fprintf(log_file, "Freeing message string\n");
#endif
	free(c->message);
    }

    if (c->object)
    {
#if DEBUG
	fprintf(log_file, "Freeing object name\n");
#endif
	free(c->object);
    }

    http_free_headers(c->headers); /* The function does its own check for NULL pointers */
    http_free_headers(c->sendhead_base);

    /* Finally, zap the magic number */
    c->magic = 0;

#if DEBUG
    fprintf(log_file, "Unlinking from list\n");
#endif
    if (c->prev == NULL)
	http_cons_list = c->next;
    else
	c->prev->next = c->next;

    if (c->next != NULL)
	c->next->prev = c->prev;

#if DEBUG
    fprintf(log_file, "Freeing connection structure\n");
#endif
    free(c);

#if DEBUG
    fprintf(log_file, "Connection closed.\n");
#endif

    return 0;
}

void http_copy_headers(http_header_item *h, http_header_item **new)
{
    *new = NULL;

    if (h == NULL)
	return;

    *new = malloc(sizeof(http_header_item));
    if (*new == NULL)
	return;

    (*new)->key = strdup(h->key);
    (*new)->value = strdup(h->value);

    http_copy_headers(h->next, &((*new)->next));
}

_kernel_oserror *http_free_headers(http_header_item *h)
{
    http_header_item *hn;

    while(h != NULL)
    {
	hn = h->next;
#if DEBUG
	    fprintf(log_file, "Freeing header line\n");
#endif

	if (h->key)
	    free(h->key);
	if (h->value)
	    free(h->value);

	free(h);
	h = hn;
    }

    return NULL;
}

/* pdh */
/* Connection passes through the following states, in order:
 *      status_NEW                  only in http_open
 *    + status_CONNECTING           waiting for connect
 *    + status_AUTHENTICATING       missed out if not HTTPS
 *    + status_REQUESTING           sending request
 *    + status_REQUEST_HEADERS      sending headers
 *    + status_REQUEST_BODY         missed out if not POST
 *      status_WAITING              getting response line
 *      status_GETTING_HEADERS
 *      status_GETTING_BODY
 *
 * It counts towards sockets_connecting if in a state marked +
 */

static _kernel_oserror *http_prosecute( http_connection *c )
{
    int needToRead = 1;  /* used in "line reading" states */
    char *l;            /* ditto */
    int rc;

    switch (c->status)
    {
    case status_CONNECTING:
        /* check to see if the connect has succeeded yet */
#if DEBUG && 0
        fprintf(log_file, "Trying another connect of %d\n", c->socket);
#endif
	rc = connect( c->socket, (struct sockaddr *) &(c->sa),
	              sizeof(struct sockaddr));

	if (rc > -1)
	{
	    /* This should not happen, but we will catch it anyway */
	    c->status = status_AUTHENTICATING;
	    /* go on to drop through the outer switch */
	}
	else
	{
	    switch(errno)
	    {
	    case EISCONN:
		/* The connection is through now */
		c->status = status_AUTHENTICATING;
		break;
	    case EALREADY:
		/* The connection is still going through */
		/* Do nothing */
		return NULL;
	    default:
		/* The connection failed */
		c->status = status_FAIL_CONNECT;
		if (c->fh)
		{
		    ro_fclose(c->fh);
		    c->fh = NULL;
		}
		return NULL;
	    }
	}
	/* status is status_AUTHENTICATING so we can drop through */

    case status_AUTHENTICATING:

#ifndef NO_SECURE
#if DEBUG && 0
        fprintf( log_file, "Authenticating\n" );
#endif
        if ( c->SSL )
        {
#if DEBUG && 0
        fprintf( log_file, "Calling SSL_connect\n" );
#endif
            verify_error = FALSE;
            rc = SSL_connect( c->SSL );
#if DEBUG && 0
        fprintf( log_file, "SSL_connect returned %d (errno=%d)\n", rc,
                           SSL_errno() );
#endif
            if ( rc <= 0 )
            {
                if ( SSL_errno() == EWOULDBLOCK )
                    return NULL;    /* still trying */
                if ( verify_error )
                    c->status = status_FAIL_VERIFY;
                else
                    c->status = status_FAIL_REQUEST;
                return NULL;
            }

            /* Add some fake headers to provide SSL information */
	    /* SJM: not add_header_line strdups the name/value strings so we need to
	     * free str after passing it in and not strdup() the name string */

            {
                X509 *peer = SSL_get_peer_certificate(c->SSL);
                char *cipher = SSL_get_cipher( c->SSL );

    	        if ( peer )
		{
		    char *str;

    		    str=X509_NAME_oneline(X509_get_subject_name(peer));
    		    /* str was allocated with malloc so we can pass it
    		     * to add_header_line directly */

    		    http_add_header_line( c, "X-SSL-Certificate-Subject",
    		                          str );
		    free(str);

            	    str=X509_NAME_oneline(X509_get_issuer_name(peer));
            	    http_add_header_line( c, "X-SSL-Certificate-Issuer",
            	                          str );
		    free(str);
		    X509_free(peer);
		}

		if ( cipher )
		    http_add_header_line( c, "X-SSL-Cipher",
		                          cipher );

                http_add_header_line( c, "X-SSL-Verified",
                                      SSL_verified(c->SSL) ? "Yes" : "No" );
	    }

        }
#endif
        c->status = status_REQUESTING;
        /* fall through */

    case status_REQUESTING:
    	http_send_request(c);
    	if ( c->status != status_REQUEST_HEADERS )
    	    return NULL;
        /* else we can drop through */

    case status_REQUEST_HEADERS:
        rc = 0;
	while (c->status == status_REQUEST_HEADERS && rc != EWOULDBLOCK)
	{
	    rc = http_send_request_headers(c);
	}
	/* if we're now listening we don't need to be polled any more */
	if ( c->status == status_WAITING )
	{
	    sockets_connecting--;
#if DEBUG
            fprintf( log_file, "Sockets_connecting decremented to %d\n",
                               sockets_connecting );
#endif
	}

	if ( c->status != status_REQUEST_BODY )
	    return NULL;
	/* else we can drop through */

    case status_REQUEST_BODY:
        rc = 0;
        while (c->status == status_REQUEST_BODY && rc != EWOULDBLOCK)
	{
	    rc = http_send_request_body(c);
	}
	/* if we're now listening we don't need to be polled any more */
	if ( c->status == status_WAITING )
	{
	    sockets_connecting--;
#if DEBUG
            fprintf( log_file, "Sockets_connecting decremented to %d\n",
                               sockets_connecting );
#endif
        }

	if ( c->status != status_WAITING )
	    return NULL;
	/* else we can drop through */

    case status_WAITING:
        /* Expecting a response line */
        l = http_getline(c, 1); /* Get the next line, doing a read */
        needToRead = 0;
        if (l)
            http_process_response_line(c, l);
        if ( c->status != status_GETTING_HEADERS )
            return NULL;
        /* else we can drop through */

    case status_GETTING_HEADERS:
        l = http_getline(c, needToRead);
        while (l && c->status == status_GETTING_HEADERS)
        {
    	    http_process_header_line(c, l);
    	    if (c->status == status_GETTING_HEADERS)
    	        l = http_getline(c, 0);
        }
        if (c->status != status_GETTING_BODY)
            return NULL;
        /* else we can drop through */

    case status_GETTING_BODY:
	/* Now idempotent and quick to return */
        http_flush_data_to_file(c);

        while (1)
        {
    	    rc = http_recv( c, tmp_buffer, TMP_BUF_SIZE );

#if DEBUG
	    fprintf(log_file, "Recv (body) gave %d\n", rc);
#endif
	    if (rc <= 0)
	    {
	        if (rc == 0 || errno != EWOULDBLOCK)
		{
#if DEBUG
		    fprintf(log_file, "Compleating connection on socket %d, errno=%d\n", c->socket, errno);
#endif
		    c->status = status_COMPLETED_FILE;
                }
	        break; /* NOTE:  This is a break for the WHILE loop, not the switch() */
	    }
	    else
	    {
	        if (c->fh)
		    ro_fwritepos(tmp_buffer, rc, 1, c->fh, c->data_so_far);
		c->data_so_far += rc;
	    }
	}
	break;
    default:
        break;
    }
    return NULL;
}

static _kernel_oserror *http_destroy( http_connection *c, int error )
{
    if ( c )
    {
        http_close_handle( c, 0 );
    }
    return make_error( error );
}

static _kernel_oserror *http_open(http_open_args *args)
{
    http_connection *new = NULL;
    int i;
    int rc;
    http_open_args args2 = *args;

#if DEBUG
    fprintf(log_file, "Opening new conection.  Host = 0x%08x, port = 0x%04x, object = '%s', fname = '%s'.\n\tHeaders stored at %p\n",
	    args2.in.addr->sin_addr.s_addr, args2.in.addr->sin_port,
	    args2.in.object, args2.in.fname ? args2.in.fname : "", args2.in.headers);
#endif

    args->out.handle = NULL;

    new = malloc(sizeof(http_connection) + MAX_INPUT);
    if (new == 0)
	return make_error(err_NO_MEMORY);

    *new = proto_con;		/* Fill in with a prototype connection */
    new->buffer = (char*) (new + 1);
    new->buffer[0] = 0;

    memcpy((char *)&(new->sa),(char *) args2.in.addr,  sizeof(new->sa) );

    if ( (new->socket = socket(AF_INET, SOCK_STREAM, 0)) <0)
    {
	return http_destroy(new,err_CANT_MAKE_SOCKET);
    }

    new->flags = args2.in.flags;

#if DEBUG
    fprintf(log_file, "New socket is %d\n", new->socket);
#endif

    i = 1;
    rc = socketioctl(new->socket, FIONBIO, &i);
    if (rc == -1)
	return http_destroy(new,err_BAD_IOCTL);

    i = 1;
    rc = socketioctl(new->socket, FIOASYNC, &i);
    if (rc == -1)
	return http_destroy(new,err_BAD_IOCTL);

#if DEBUG
    fprintf(log_file, "About to connect...");
#endif

    rc = connect(new->socket, (struct sockaddr *) &(new->sa), sizeof(struct sockaddr));

/*
 * Legal return values are:
 *	36	EINPROGRESS	The connection process has been started but no result as yet.
 *	22	EINVAL		The connection process failed, either due to a timeout or a rejection.
 *	37	EALREADY	The connection process is still going on and may yet finnish.
 *	56	EISCONN		The connection process succeded and we are now connected.
 */

    if (rc < 0 && errno != EINPROGRESS)
    {
	return http_destroy(new,err_CANT_CONNECT);
    }

    new->status = status_CONNECTING;
    sockets_connecting++;

#if DEBUG
    fprintf( log_file, "Connect rc = %d, error number %d, sockets_connecting now %d\n", rc, errno, sockets_connecting );
#endif

/*
 * The connection process may take a little time.  So we go off and make
 * the data file and come back in a moment to check if we are done.
 */

    new->object = strdup(args2.in.object);
    if (new->object == NULL)
    {
	return http_destroy(new,err_NO_MEMORY);
    }

    http_copy_headers(args2.in.headers, &(new->sendhead) );
    new->sendhead_base = new->sendhead;

    if (args2.in.fname == NULL)
    {
	args2.in.fname = tmpnam(NULL);
    }

    new->fname = strdup(args2.in.fname);
    if (new->fname == NULL)
    {
	return http_destroy(new,err_NO_MEMORY);
    }

    if ( args2.in.flags & http_open_flags_HEAD )
        new->fh = NULL;
    else
    {
#if DEBUG
        fprintf(log_file, "Opening file '%s'\n", new->fname);
#endif
        new->fh = ro_fopen(new->fname, RO_OPEN_WRITE);
        if (new->fh == NULL)
        {
            return http_destroy(new,err_CANT_OPEN_FILE);
        }
    }

    if (args2.in.bname)
    {
	new->bname = strdup(args2.in.bname);
	if (new->bname == NULL)
	{
	    return http_destroy(new,err_NO_MEMORY);
	}

#if DEBUG
	fprintf(log_file, "Opening body file '%s'\n", new->bname);
#endif

	new->bh = ro_fopen(new->bname, RO_OPEN_READ);
	if (new->bh == NULL)
	{
	    return http_destroy(new,err_CANT_OPEN_BODY);
	}
    }

    /* Create an SSL structure and tell it this is its socket */
    if ( args2.in.flags & http_open_flags_SECURE )
    {
#ifdef NO_SECURE
        return http_destroy(new, err_SSL_NOT_AVAILABLE );
#else
        if ( !ssl_present )
            return http_destroy(new, err_SSL_NOT_AVAILABLE );

        new->SSL = SSL_new( ssl_context );
        SSL_set_fd( new->SSL, new->socket );

        if ( args2.in.flags & http_open_flags_VERIFY )
        {
            SSL_set_verify( new->SSL, SSL_VERIFY_PEER, &cert_verify_callback );
        }
        else
        {
            SSL_set_verify( new->SSL, SSL_VERIFY_NONE, NULL );
        }

        SSL_CTX_set_cipher_list( ssl_context, getenv( "SSL$CipherList" ) );
#endif
    }

    /* Get this in before we send anything */
    http_cons[new->socket] = new;

    FD_SET(new->socket, &fd_write);

#if DEBUG
    fprintf(log_file, "ISSET: %ld %ld\n", FD_ISSET(new->socket, &fd_read), FD_ISSET(new->socket, &fd_write) );
#endif

    /* if we're lucky, the connection has succeeded while we were doing
     * all that, so check and see if we can move matters on
     */
    http_prosecute( new );

    new->next = http_cons_list;
    /* new->prev is set to NULL in the prototype */

    if (http_cons_list)
	http_cons_list->prev = new;
    http_cons_list = new;

    args->out.handle = new;
    return NULL;
}

static _kernel_oserror *http_status(http_status_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
	return ep;

    args->out.status = c->status ;
    args->out.ro_fh = c->fh ;
    args->out.fname = c->fname ;
    args->out.data_size = c->data_size ;
    args->out.data_so_far = c->data_so_far ;
    args->out.headers = c->headers ;
    args->out.rc = c->rc ;
    args->out.message = c->message ;

    return NULL;
}

static _kernel_oserror *http_close(http_close_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
	return ep;

    return http_close_handle(c, args->in.flags);
}

static _kernel_oserror *http_maptoriscos(http_maptoriscos_args *args)
{
    args->out.ft = mime_map_to_riscos(args->in.extn);
    return NULL;
}

static _kernel_oserror *http_mapfromriscos(http_mapfromriscos_args *args)
{
    args->out.extn = mime_map_from_riscos(args->in.ft);
    return NULL;
}

static _kernel_oserror *http_setfiletype(http_setfiletype_args *args)
{
    http_connection *c;
    _kernel_oserror *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
	return ep;

    return http_set_file_type(c, &args->out.ftype);
}

static _kernel_oserror *setup_ticker_and_event(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *ep;

    r.r[0] = 0x10;
    r.r[1] = (int) &inetevent_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(XOS_Bit + OS_Claim, &r, &r);

    if (ep)
	return ep;

    _kernel_osbyte(14, Event_Internet, 0);

    r.r[0] = TICKER_RATE;
    r.r[1] = (int) timer_entry;
    r.r[2] = (int) private_word;

    ep = _kernel_swi(OS_CallEvery, &r, &r);

    if (ep)
    {
	clear_ticker_and_event();
	return ep;
    }

    return NULL;
}

static void clear_ticker_and_event(void)
{
    _kernel_swi_regs r;

    _kernel_osbyte(13, Event_Internet, 0);

    r.r[0] = 0x10;
    r.r[1] = (int) inetevent_entry;
    r.r[2] = (int) private_word;

    _kernel_swi(OS_Release, &r, &r);

    r.r[0] = (int) timer_entry;
    r.r[1] = (int) private_word;

    _kernel_swi(OS_RemoveTickerEvent, &r, &r);
}

static void setup_callback(void)
{
    if (callback_pending == 0)
    {
	_kernel_swi_regs r;

	r.r[0] = (int) &callback_entry;
	r.r[1] = (int) private_word;
	callback_pending = 1;

	_kernel_swi(OS_AddCallBack, &r, &r);
    }
}

static void clear_callback(void)
{
    if (callback_pending)
    {
	_kernel_swi_regs r;

	r.r[0] = (int) &callback_entry;
	r.r[1] = (int) private_word;

	callback_pending = 0;
	_kernel_swi(OS_RemoveCallBack, &r, &r);
    }
}

char *strdup(char *s)
{
    char *ss;

    ss = malloc(strlen(s) + 1);

    if (ss)
	strcpy(ss, s);

    return ss;
}

void http_send_request(http_connection *c)
{
    char *meth = c->bh ? "POST " :
                 (c->flags & http_open_flags_HEAD ) ? "HEAD "
                                                    : "GET ";

#if DEBUG
    fprintf( log_file, "Sending request: %s%s %s\n", meth, c->object,
             http_version );
#endif

    if ( strlen( c->object ) > TMP_BUF_SIZE - 20 )
    {

        http_send(c, meth, strlen(meth) );
        http_send(c, c->object, strlen(c->object) );

        sprintf(tmp_buffer, " %s\r\n", http_version);
    }
    else
    {
        sprintf(tmp_buffer, "%s%s %s\r\n",
                           meth, c->object, http_version);
    }

    if (http_send(c, tmp_buffer, strlen(tmp_buffer) ) < 0)
    {
	c->status = status_FAIL_REQUEST;
	if (c->fh)
	{
	    ro_fclose(c->fh);
	    c->fh = NULL;
	}
    }
    else
    {
	c->status = status_REQUEST_HEADERS;
    }
}

/* Returns 0 is a line was sent or the connection died, EWOULDBLOCK if it would block */
int http_send_request_headers(http_connection *c)
{
    if (c->sendhead)
	sprintf(tmp_buffer, "%s: %s\r\n", c->sendhead->key, c->sendhead->value);
    else
    {
	if (c->bh)
	{
	    if (c->data_size == -1)
		c->data_size = http_file_size(c->bname);
	    sprintf(tmp_buffer, "Content-length: %d\r\n\r\n", c->data_size);
	}
	else
	    strcpy(tmp_buffer, "\r\n");
    }
#if DEBUG
    /* You dont want a \n on this printf */
    fprintf(log_file, "Sending header: %s", tmp_buffer);
#endif

    if (http_send( c, tmp_buffer, strlen(tmp_buffer) ) < 0)
    {
	if (errno != EWOULDBLOCK)
	{
	    c->status = status_FAIL_REQUEST;
	    if (c->fh)
	    {
		ro_fclose(c->fh);
		c->fh = NULL;
	    }
	}
	else
	{
	    /* If it would block then just return */
	    return EWOULDBLOCK;
	}
    }
    else
    {
	if (c->sendhead)
	    c->sendhead = c->sendhead->next;
	else
	{
	    if (c->bh)
	    {
		c->status = status_REQUEST_BODY;
		ro_fread(c->buffer, 1, c->data_size > MAX_INPUT ? MAX_INPUT : c->data_size, c->bh);
		c->data_so_far = 0;
	    }
	    else
	    {
#if 0
		shutdown(c->socket, 1);
#endif
		c->status = status_WAITING;
		FD_CLR(c->socket, &fd_write);
		FD_SET(c->socket, &fd_read);
	    }
	}
    }

    return 0;
}

/* Returns 0 is data was sent or the connection died, EWOULDBLOCK if it would block */
int http_send_request_body(http_connection *c)
{
    int sent;
    int to_go;

    /* This is always entered with the c->buffer as full as it can be,
     * c->data_size the size of the file to be sent and c->data_so_far
     * the amount of data sent to far.
     */

#if DEBUG
    fprintf(log_file, "Sending data: so far %d of %d\n", c->data_so_far, c->data_size);
#endif

    to_go = c->data_size - c->data_so_far;

    if (to_go > 0)
	sent = http_send(c, c->buffer, to_go > MAX_INPUT ? MAX_INPUT : to_go );
    else
	sent = 0;

    if ( sent < 0)
    {
	if (errno != EWOULDBLOCK)
	{
	    c->status = status_FAIL_REQUEST;
	    if (c->fh)
	    {
		ro_fclose(c->fh);
		c->fh = NULL;
	    }
	}
	else
	{
	    /* If it would block then just return */
	    return EWOULDBLOCK;
	}
    }
    else
    {
	c->data_so_far += sent;
	to_go -= sent;

	if (to_go > 0)
	{
	    if (sent != MAX_INPUT)
		memmove(c->buffer, c->buffer + sent, MAX_INPUT - sent);

	    ro_fread(c->buffer + MAX_INPUT - sent, 1, sent > to_go ? to_go : sent, c->bh);
	}
	else
	{
	    c->data_size = c->data_so_far = -1;
#if 0
	    shutdown(c->socket, 1);
#endif
	    c->status = status_WAITING;
	    FD_CLR(c->socket, &fd_write);
	    FD_SET(c->socket, &fd_read);
	}
    }

    return 0;
}

/*
 * Read some more data from the line and return the next line of data
 */
char* http_getline(http_connection *c, int read)
{
    char *end;

    if (c->buf_used)
    {

	memmove(c->buffer, c->buffer + c->buf_used, c->buf_off - c->buf_used + 1);
	c->buf_off -= c->buf_used;
	c->buf_used = 0;
    }

#if 0
    if (read)
#else
    /* pdh: might as well always read it */
    if ( MAX_INPUT - c->buf_off - 1 > 0 )
#endif
    {
	int rc;
	rc = http_recv( c, c->buffer + c->buf_off, MAX_INPUT - c->buf_off - 1);
#if DEBUG
	fprintf(log_file, "Recv (getline) gave %d\n", rc);
#endif
	if (rc < 0)
	{
	    if (errno != EWOULDBLOCK)
	    {
		c->status = status_FAIL_REQUEST;
		if (c->fh)
		{
		    ro_fclose(c->fh);
		    c->fh = NULL;
		}
		return NULL;
	    }
	}
	else
	{
	    c->buf_off += rc;
	}
    }

    /* pdh: moved this termination outside the if */
    c->buffer[c->buf_off] = 0; /* Make use we always have a NULL at the end */
    end = strchr(c->buffer, '\n');

    if (end)
    {
	c->buf_used = (end - c->buffer) + 1;
	if (end[-1] == '\r')
	    end[-1] = 0;
	end[0] = 0;
	return c->buffer;
    }
    else if (MAX_INPUT - c->buf_off - 1 == 0) /* Phrased like this as this is the formula used in the recv() call */
    {
	/* This is not a good situation, the buffer is full but we don't have a line feed */
	c->buf_used = c->buf_off + 1;
#if DEBUG
	fprintf(log_file, "Getline buffer filled up; cleared.\n");
#endif
	return c->buffer;
    }

    return NULL;
}

static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value )
{
    http_header_item *hi;

    hi = malloc(sizeof(http_header_item));
    if (hi)
    {
	hi->key = strdup(key);
	hi->value = strdup(value);

	if (hi->key == NULL || hi->value == NULL)
	{
	    if (hi->key)
		free(hi->key);
	    if (hi->value)
		free(hi->value);
	}
    }

    if (hi)
    {
	hi->next = c->headers;
	c->headers = hi;
    }

    return hi;
}

void http_process_header_line(http_connection *c, char *l)
{
    char *p;
#if DEBUG
    fprintf(log_file, "Received: '%s'\n", l);
#endif
    if (strlen(l) == 0)
    {
	c->status = status_GETTING_BODY;
    }
    else
    {
	/* Try to split the the header line */
	p = strchr(l, ':');
	if (p != 0)
	{
	    char *q;
	    http_header_item *hi;

	    *p = 0;
	    while (isspace(*(++p)))
		;

	    q = p + strlen(p);
	    while ((q > p) && isspace(q[-1]))
		q--;
	    *q = 0;

            hi = http_add_header_line( c, l, p );

	    http_check_special_headers(c, hi);
	}
	else
	{
#if DEBUG
	    fprintf(log_file, "Badly formed header line, no ':'\n");
#endif
	}
    }
}

void http_process_response_line(http_connection *c, char *l)
{
#if DEBUG
    fprintf(log_file, "Recieved: '%s'\n", l);
#endif
    if (strncmp(l, http_version_check, strlen(http_version_check)) == 0)
    {
	char *p;

	p = l + strlen(http_version);
	while (isspace(*(++p)))
	    ;
	c->rc = atoi(p);
	p += 2;
	while (isspace(*(++p)))
	    ;
	c->message = strdup(p);
#if DEBUG
	fprintf(log_file, "Response: %d '%s'\n", c->rc, c->message ? c->message : "<no message>");
#endif
	c->status = status_GETTING_HEADERS;
    }
    else
    {
#if DEBUG
	fprintf(log_file, "Badly formed response line\n");
#endif
#if 0
	c->status = status_FAIL_REQUEST;
	if (c->fh)
	{
	    ro_fclose(c->fh);
	    c->fh = NULL;
	}
#else
	c->rc = 200;
	c->message = strdup("Badly formed response; continuing anyway.");
	c->status = status_GETTING_BODY;
	/* Squeeze this line back in the buffer so it can get flushed out */
	c->buffer[c->buf_used-1] = '\n';
	if (c->buffer[c->buf_used-2] == 0)
	    c->buffer[c->buf_used-2] = '\r';
	c->buf_used = 0;
#endif
    }
}

void http_flush_data_to_file(http_connection *c)
{
    if ( c->data_so_far == -1 )
        c->data_so_far = 0;

    if (c->fh && (c->buf_off != c->buf_used))
    {
	int n;

	n = c->buf_off - c->buf_used;
	/* The flush is always for the initial data */
	ro_fwritepos(c->buffer + c->buf_used, n, 1, c->fh, 0);
	c->buf_off = c->buf_used = 0;
	c->data_so_far = n;
    }
}

void http_socket_close(http_connection *c)
{
    if (c->socket != -1)
    {
#if DEBUG
	fprintf(log_file, "Closing socket %d\n", c->socket);
#endif

	FD_CLR(c->socket, &fd_read);
	FD_CLR(c->socket, &fd_write);

	http_cons[c->socket] = NULL;

	socketclose(c->socket);
	c->socket = -1;
    }
}

int strcasecmp(char *s1, char *s2)
{
    int c1, c2, t;

    while (1)
    {
	c1 = *s1++;
	c2 = *s2++;
	if (c1 == 0 || c2 == 0)
	    return c1-c2;
	else
	{
	    t = toupper(c1) - toupper(c2);
	    if (t)
		return t;
	}
    }
}

void http_check_special_headers(http_connection *c, http_header_item *hi)
{
    if (strcasecmp(hi->key, "CONTENT-LENGTH") == 0)
    {
	int s;
	s = atoi(hi->value);
	if (s > 0)
	{
	    c->data_size = s;

	    /* RISC OS will give us a random size */
	    if ( c->fh )
	    {
	        ro_ensure_size(c->fh, c->data_size);
	        ro_fclose(c->fh);
	        c->fh = ro_fopen(c->fname, RO_OPEN_WRITE);
	    }
	}
    }
}

#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error)
{
    if ( !ok )
    {
        if ( depth >= CERT_VERIFY_DEPTH )
	    ok=1;
	else
	    verify_error = TRUE;
    }

    return(ok);
}
#endif
