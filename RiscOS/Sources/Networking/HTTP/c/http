/* -*-c-*- */

/* http.c */

/* The HTTP module provides a mechanism for sending requests and
 * fetching results using the HyperText Transfer Protocol.
 *
 * (C) ANT Limited 1996-7 -- All Rights Reserved -- Confidential
 *
 * History:
 *
 * pdh 01-Jul-96 Begin HTTPS (HTTP+SSL) support (defeat with -DNO_SECURE)
 * pdh 03-Jul-96 HTTPS now working
 * pdh 04-Jul-96 The last reallocs excised from httpsmod -- verify now works
 * pdh 29-Jul-96 Added HEAD support
 * pdh 12-Sep-96 Corrected internet event code -- hogs machine much less now
 * SJM 20-Nov-96 Took out excess strduping in status_AUTHENTICATING and added
 *		 setting of SSL_VERSION system variable.
 * pdh 27-Jan-97 Begin Keep-Alive support
 * pdh 29-Jan-97 First internal release of keep-alive version (0.61)
 * pdh 12-Mar-97 Frob prefix-fetch stuff to work round bug in WebSitePro/1.1f
 * RWB 16 Apr 97 CSFS bits.
 * AJS 22-Apr-97 Made some mods to http_verifymessagedigest
 * AJS 28-Apr-97 Added http_converttopem certificate munger
 * AJS 08-May-97 More mods to http_verifymessagedigest
 * SJM 29-May-97 changed send_request_headers to use sendv.
 * AJS 29-May-97 Added certificate ageing to http_vmd
 * SJM 01-Jun-97 Moved socket count incrementing to start of http_open_socket.
 * pdh 04-Jun-97 Allow spaces at the beginning of headers (sigh)
 * SJM 11-Jun-97 Only strip multiple copies of headers if it's not set-cookie.
 * SJM 10-Jul-97 if ensure_size fails then return an error.
 * pdh 14-Jul-97 Cope with "Content-type: text/html; charset=foo"
 * pdh 08-Aug-97 Separate out riscos-specific stuff into module.c
 * SJM 18-Jul-97 Maybe found occaisional server-push crash. malloc for boundary
 *		 wasn't allocating a byte for the terminator
 * SJM 26-Aug-97 took out a 'pdh: bodge' as it seemed to be responsible for server-push
 *               not working and crashing again!
 * SJM 01-Oct-97 Added USE_MIMEMAPMOD. Added PROXY_REDIRECT code. Added BUFFER_EXTEND code.
 *		 Only PROXY_REDIRECT tested at the moment and that is only for one customers use.
 * SJM 02-Oct-97 Bit more on PROXY_REDIRECT (to allow disabling the proxy altogether).
 *		 Found bug bug when trying to use IMAGE and TUNNEL. When the socket is closed the
 *		 tunnelling flag and SSL context are lost. Added new flag to restart tunnelling,
 *		 ensured SSL context is freed in socket close, stopped 'object' field from being
 *		 modified when sending headers, and stopped the zeroing of data_so_far on reopening
 *		 SSL connection.
 * SJM 27-Feb-98 Removed sendv() use in send request and send request headers as they fail to work
 *		 (When using ssl) with the lotus domino server.
 * SJM 02-Mar-98 Split off the PROXY_REDIRECT code to its own file. Changed MimeMap Module numbers.
 * SJM 27-Apr-98 Split off the csfs and certificates stuff into their own files.
 *		 Put the Netscape CONNRESET handling into a separate
 *		 function (close_and_reopen). This is now called when
 *		 receiving body as well as headers if CONNRESET or
 *		 recv()==0 occurs.  open_socket() now zeroes
 *		 data_so_far, buf_off and buf_used in case the fetch
 *		 was restarted after receiving some data.  If
 *		 byteranges are broken it also calls close and reopen to
 *		 restart fetch (as comment said but didn't appear to
 *		 do). Added HTTP_Config SWI and *command. Enabled use of mimemap module.
 *		 Put a check in for servers that return no content-range when asked.
 *		 Made new_queue copy the server flags into the new connection.
 *		 Took out callback from Internet event.
 * SJM 05-May-98 A bug in the previous changes meant many image files didn't work from
 *		 perfectly OK servers. It now only checks for broken range implementations
 *		 if the server actually returns code 206.
 * SJM 06-May-98 Calling http_prosecute() directly from the internet event is fine on Internet 5
 *		 but crashes when used on the STB. This is believed to be due to it being Internet 4.
 *		 So we now check the internet version and behave accordingly. This might need a bit more
 *		 checking to be sure it's totally safe.
 * SJM 08-May-98 Moved the zeroing of data_so_far etc. out of open_socket() and into reopen_socket()
 *		 to prevent the occaisional data corruption that was occurring.
 *
 * SJM 08-Jul-98 Took out the direct call from internet, doesn't ever
 *		 seem to work reliably. Added HTTP_Config SWI and
 *		 *httpconfig CLI * command. Added conditional
 *		 support for SSLeay 0.8.1 and 0.9.0, Acorn and ANT
 *		 builds. Merged with fresco2 tree. Moved most
 *		 header includes into http.h since there are now
 *		 more source * files. #define ACORN_BUILD for building
 *		 within the Acorn source tree. Restored fallback of
 *		 direct mimemap access if module not there ACORN_BUILD only.
 * pdh 15-Jul-98 Renamed make_error to make_httperror, as now it's not static
 *		 it clashes in Win32 builds with the WebFTP one.
 */

#ifdef HTTPMOD
# include <ctype.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <time.h>
#else
# include "fresco.h"
#endif

#include "http.h"

/**********************************************************************/
/*
 * Global definitions
 */

/**********************************************************************/
/*
 * Error definitions
 */

/* Keep in step with error definitions in http.h */

static const char *err_strings[] = {
    "Can't find host in database",
    "Can't find service in database",
    "Can't find protocol in database",
    "Can't make socket",
    "Can't connect to server",
    "Bad IOCTL call",
    "Not enough free memory",
    "Invalid connection handle",
    "Can't open output file",
    "Can't open posting body file",
    "HTTPS not available",
    "Can't negotiate HTTPS connection",
    "Unexpected call to CompletedPart",
#ifdef CSFS
    "HTTP transport error",
#else
    "",
#endif
    "HTTPS connection not in progress",
    "SSLOp called out of context",
    "Unknown error"
    };

/**********************************************************************/
/*
 * Global variable definitions
 */

void *private_word;

/* pdh: 12-Aug-97 Removed http_cons[] as it doesn't cope with OS's where
 *                sockets aren't small integers, e.g. Win32
 *
http_connection *http_cons[FD_SETSIZE]; ** Array of pointers - only the heads
                                           of keep-alive queues are in here **
 */

http_connection *http_cons_list = NULL;        /* Absolutely all connections */
http_queue      *http_queues_list = NULL;

volatile int callback_pending;
volatile int threaded = 0;

/* usage tracking variables */
int keptalive = 0;
int connresets = 0;
int keepalivelies = 0;

int maxsockets = MAXSOCKETS;
int totalsockets = 0;
int sockets_connecting = 0; /* Count of sockets in the process of
                               connecting (i.e. still need to be polled) */

int inet_version;

#ifndef NO_SECURE
BOOL ssl_present = TRUE;
SSL_CTX *ssl_context = NULL;
BOOL verify_error = FALSE;
#endif

#define TMP_BUF_SIZE        1028
char tmp_buffer[TMP_BUF_SIZE];

static char http_version[] = HTTP_VERSION;
static char http_version_check[] = HTTP_VERSION_CHECK;

int allow = http_config_ALLOW_KEEPALIVE | http_config_ALLOW_SERVERPUSH | http_config_ONE_CERT_PROMPT;

FILE *log_file = NULL;

/**********************************************************************/
/*
 * Forward declarations of functions static to this file
 */

static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value );

static void http_orphan_queue( http_connection *c );
static void http_queue_allow_read( http_connection *c );
static void http_queue_allow_write( http_connection *c );
static void http_requeue( http_connection *c );
static void http_queue_dec_nsockets( http_connection *c );
static char *http_build_request( http_connection *c, http_header_item *h );
static void http_set_server_flag( http_connection *c, int flag );
static void http_close_and_reopen_socket(http_connection *c);

os_error *http_free_headers(http_header_item *h);
os_error *http_set_file_type(http_connection *c, int *ftptr);

int http_file_size(char *fname);

void http_send_request(http_connection *c);
int http_send_request_headers(http_connection *c);
int http_send_request_body(http_connection *c);
char *http_getline(http_connection *c, int read);

void http_process_header_line(http_connection *c, char *l);
void http_process_response_line(http_connection *c, char *l);
void http_flush_data_to_file(http_connection *c);
void http_socket_close(http_connection *c);
BOOL http_check_special_headers(http_connection *c, char *key, char *value);

#if DEBUG
static void http_show_flags( http_connection *c );
#endif

#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error);
static BOOL http_go_ssl( http_connection *c );
#endif

/* SJM: This shouldn't be here but I don't know how to get it defined without severe upset otherwise */
extern int layers_make_socket_asynchronous( int s, void (*cb) (int s, void *cp), void *cp );
extern void layers_async_change_handle( int s, void *cp );

#ifdef NO_SECURE
#define http_send(c,m,s) send((c)->socket,m,s,0)
#define http_sendv(c,v,n) socket_writev((c)->socket,v,n)
#define http_recv(c,b,l) recv((c)->socket,b,l,0)
#else
#define http_send(c,m,s)  (((c)->SSL) ? SSL_write( (c)->SSL, m, s )         \
                                      : send( (c)->socket, m, s, 0 ) )

#define http_sendv(c,v,n) (((c)->SSL) ? SSL_writev( (c)->SSL, v, n )        \
                                      : socket_writev( (c)->socket, v, n ) )

#define http_recv(c,b,l)  (((c)->SSL) ? SSL_read( (c)->SSL, b, l )          \
                                      : recv( (c)->socket, b, l, 0 ) )
#endif

/**********************************************************************/
/*
 * This structure is a prototype for a connection.
 */
static http_connection proto_con = {
    HTTP_MAGIC,                 /* Magic number */
    NULL,                       /* Next pointer */
    NULL,                       /* Prev pointerb */
    0,                          /* Poll word */
    status_NEW,                 /* Status */
    NULL,                       /* Object name */
    -1,                         /* Socket number */
    { 0, },                     /* Socket address */
    NULL,                       /* File name */
    0,                          /* File handle */
    NULL,                       /* Body file name */
    0,                          /* Body file handle */
    -1,                         /* Data size */
    -1,                         /* Data so far */
    NULL,                       /* List of fetched headers */
    -1,                         /* Return code */
    NULL,                       /* Return message */
    0,                          /* Buffer offset */
    0,                          /* Buffer used */
    0,                          /* Buffer size */
    NULL,                       /* Buffer data */
    NULL,                       /* SSL connection */
    0,                          /* Flags */
    0,                          /* Data pending */
    NULL,                       /* send headers */
    0,				/* bytes of headers sent */
    NULL, NULL,                 /* Keep-alive queue 2LL */
    NULL,                       /* Queue head structure */
    0,                          /* Total size */
    NULL,                       /* Server push boundary */
    0,                          /* #chars of boundary found at end of packet */
    1,                          /* # connections on this socket */
    0				/* CSFS action */
    };


        /*=======================*
         *   Utility functions   *
         *=======================*/


/**********************************************************************/
/*
 * The bcmp and bzero functions are needed by various internet library
 * calls.  I just pass them through to the memXXX versions.
 */

/* int bcmp(void *s1, void *s2, size_t s)
{
    return memcmp(s1, s2, s);
} */

#if 0
static void http_bzero(void *p, int s)
{
    memset(p, 0, s);
}
#endif
/**********************************************************************/
/*
 * Error generation function
 */

static os_error httperror;

os_error *make_httperror(int err)
{
    if ( err == err_NO_ERROR )
        return NULL;

    if (err > err_LAST_ERROR)
        err = err_LAST_ERROR;

    threaded = 0;

    httperror.errnum = err;
    strncpy(httperror.errmess, err_strings[err], 252);

    fdebugf(log_file, "Making error number %d: %s\n", err, err_strings[err]);

    return &httperror;
}

#ifndef HAVE_STRDUP
char *strdup(const char *s)
{
    char *ss;
    int i = strlen(s) + 1;

    ss = mm_malloc( i );

    if (ss)
        memcpy(ss, s, i);

    return ss;
}

#endif

#ifndef HAVE_STRICMP
int stricmp(const char *s1, const char *s2)
{
    int c1, c2, t;

    while (1)
    {
        c1 = *s1++;
        c2 = *s2++;
        if (c1 == 0 || c2 == 0)
            return c1-c2;
        else
        {
            t = toupper(c1) - toupper(c2);
            if (t)
                return t;
        }
    }
}
#endif

/* prefixcmp: like strcasecmp but returns 0 if s2 is a prefix of s1 */
static int prefixcmp(const char *s1, const char *s2)
{
    int c1, c2, t;

    while (1)
    {
        c1 = *s1++;
        c2 = *s2++;
        if ( c2 == 0 )
            return 0;
        if ( c1 == 0 )
            return c1-c2;
        else
        {
            t = toupper(c1) - toupper(c2);
            if (t)
                return t;
        }
    }
}

/* memfind: like strstr but copes with search areas that contain 0's and don't
 * necessarily end with one. If there's a partial match at the end of the
 * search area, sets *nearly to the number of characters which matched.
 */
static const char *memfind( const char *area, int len, char *search, int *nearly )
{
    int srchlen = strlen(search);

    while ( len > srchlen )
    {
        if ( !strncmp( area, search, srchlen ) )
            return area;
        area++;
        len--;
    }

    *nearly = 0;

    /* Check for partial match at the end <sigh> */
    while ( len >= 0 )
    {
        if ( !strncmp( area, search, len ) )
        {
            *nearly = len;
            return NULL;
        }
        area++;
        len--;
    }
    return NULL;
}


/*---------------------------------------------------------------------------*
 * socket_writev, which NT hasn't got                                         *
 *                                                                           *
 * Don't be tempted to use this on RiscOS, which *does* have socket_writev,   *
 * even on Internet 4, it's just some of Acorn's broken library headers      *
 * don't mention the fact.                                                   *
 *---------------------------------------------------------------------------*/

#if HAVE_SOCKET_WRITEV == 0

struct iovec {
    void         *iov_base;
    unsigned int iov_len;       /* is signed under RiscOS, the difference is
                                 * deliberate to avoid both declarations being
                                 * used. */
};

int socket_writev( int s, struct iovec *iov, int iovcnt )
{
    int bytes = 0;
    int rc;

    while ( iovcnt )
    {
        rc = send( s, iov->iov_base, iov->iov_len, 0 );
        if ( rc < 0 )
        {
            if ( socket_errno == EWOULDBLOCK && bytes )
                return bytes;
            return -1;
        }
        else
            bytes += rc;

        iovcnt--;
        iov++;
    }
    return bytes;
}

#endif

/*---------------------------------------------------------------------------*
 * SSL_writev                                                                *
 * Equivalent to Socket_WriteV except uses an SSL connection. Assumes non-   *
 * blocking I/O.                                                             *
 *---------------------------------------------------------------------------*/

#if 0 //ndef NO_SECURE
static int SSL_writev( SSL *s, struct iovec *iov, int iovcnt )
{
    int bytes = 0;
    int rc;

    while ( iovcnt )
    {
        rc = SSL_write( s, iov->iov_base, iov->iov_len );
        if ( rc < 0 )
        {
            if ( socket_errno == EWOULDBLOCK && bytes )
                return bytes;
            return -1;
        }
        else
            bytes += rc;

        iovcnt--;
        iov++;
    }
    return bytes;
}
#endif

        /*=======================*/


http_connection *http_connection_for_socket( int socket )
{
    http_connection *c = http_cons_list;

    while ( c )
    {
        if ( c->queueprev == NULL && c->socket == socket )
            return c;
        c = c->next;
    }
    return NULL;
}

#if DEBUG
int http_return_errno(void)
{
    return socket_errno;
}
#endif

os_error *http_check_handle(http_connection *c)
{
    if (c == NULL || c->magic != HTTP_MAGIC)
    {
        return make_httperror(err_BAD_MAGIC);
    }

    return 0;
}


#ifndef mmmtype_MIME
#define mmmtype_RISCOS       0 /* file type as int */
#define mmmtype_RISCOSSTRING 1 /* file type as char* */
#define mmmtype_MIME         2 /* MIME content-type passed as a char* */
#define mmmtype_DOTEXTN      3 /* .xxx extension (don't pass the .) */
#endif

os_error *http_set_file_type(http_connection *c, int *ftptr)
{
    BOOL reopen = FALSE;
    int ft = FILETYPE_HTML; /* the default */
    os_error *result;

    fdebugf( log_file, "%p: checking out file type\n", c );

    if (c->fname)
    {
        http_header_item *hi;

        for (hi = c->headers; hi != NULL; hi = hi->next)
        {
#if 0
	    fdebugf( log_file, "%p: examining header %p, '%p: %p'\n",
		     c, hi, hi->key, hi->value );

	    fdebugf( log_file, "%p:   that is, \xAB%s: %s\xBB\n",
		     c, hi->key, hi->value );
#endif
            if (hi->key
		&& hi->value
		&& stricmp(hi->key, "CONTENT-TYPE") == 0)
            {
                char *semic = strchr( hi->value, ';' );

		fdebugf( log_file, "%p: calling mime_to_file_type(%s)\n",
			 c, hi->value );

                /* pdh: blat any "charset=foo" or what-have-you after the
                 * mime type itself
                 */
                if ( semic )
                    *semic = 0;

#ifdef RISCOS
		if (allow & http_config_USE_MIMEMAPMOD)
		{
		    /* SWI XMimeMap_Translate */
		    if (_swix( 0x70B00, _INR(0,2)|_OUT(3), mmmtype_MIME, hi->value,
			   mmmtype_RISCOS, &ft ) != NULL)
		    {
			fdebugf( log_file, "%p: mimemap(%s) failed, using 0xFFD\n", c, hi->value );
			ft = 0xFFD;
		    }
		}
# ifdef ACORN_BUILD
		else
		    ft = mime_to_file_type(hi->value);
# endif
#else
		ft = mime_to_file_type(hi->value);
#endif

                /* pdh: remember to un-blat */
                if ( semic )
                    *semic = ';';

		fdebugf( log_file, "%p: map_to_riscos returns %d\n", c, ft );
            }
        }

        fdebugf(log_file, "%p: setting file type of '%s' to 0x%03X\n",
                          c, c->fname, ft);

	
        if (ftptr)
            *ftptr = ft;

	/* if the file is open on a relevant file system then close it
	 * before setting the file type */
	if ( c->fh && (c->flags & http_flags_NOSETTYPEOPEN) != 0)
	{
	    reopen = TRUE;

            fdebugf(log_file, "%p: closing fh=%d to reopen\n", c, c->fh );
	    ro_fclose( c->fh );
	    c->fh = 0;
	}

        result = file_set_type( c->fname, ft );

	/* if setting the file type failed and the file is still open,
	 * close it and retry */
	if (result != NULL && c->fh)
	{
	    reopen = TRUE;

            fdebugf(log_file, "%p: closing fh=%d to reopen due to error\n", c, c->fh );
	    ro_fclose( c->fh );
	    c->fh = 0;

	    result = file_set_type( c->fname, ft );
	}
	
	/* if we'd closed the file then reopen it */
	if ( reopen )
	{
	    c->fh = ro_fopen(c->fname, RO_OPEN_RW);
	    fdebugf(log_file, "%p: reopening %s, fh=%d\n", c, c->fname, c->fh );
	}
        return result;
    }
    return NULL;
}


/*-----------------------------------------------------------------------*
 * http_set_status                                                       *
 * Set the status of a connection, keeping sockets_connecting up to date *
 *-----------------------------------------------------------------------*/

static void http_set_status( http_connection *c, transfer_status status )
{
#if DEBUG
    if ( status != c->status )
    {
        char intst[8];
        const char *st = intst;

        switch ( status )
        {
        case status_NEW: st = "new"; break;
        case status_WAITING: st = "waiting"; break;
        case status_GETTING_HEADERS: st = "getting-headers"; break;
        case status_GETTING_BODY: st = "getting-body"; break;
        case status_COMPLETED_PART: st = "completed-part"; break;
        case status_COMPLETED_FILE: st = "completed-file"; break;
        default:
            sprintf( intst, "%d", status );
        }
        fdebugf( log_file, "%p: status now %s\n", c, st );
    }
#endif

    if ( c->status > status_NEW && c->status < status_WAITING )
        sockets_connecting--;
    c->status = status;
    if ( c->status > status_NEW && c->status < status_WAITING )
        sockets_connecting++;
}


static void http_set_message( http_connection *c, const char *text )
{
    if ( c->message )
        mm_free( c->message );
    c->message = mm_strdup( text );
}

static void http_oserror( http_connection *c, os_error *e )
{
    if ( e )
    {
        fdebugf( log_file, "%p: *** Error, message is %s\n", c, e->errmess );
        http_set_message( c, e->errmess );
    }
    else
        fdebugf( log_file, "%p: *** Error with no error!\n", c );

    http_set_status( c, status_FAIL_LOCAL );
}

#if 0
static void http_copy_headers(http_header_item *h, http_header_item **new)
{
    *new = NULL;

    if (h == NULL)
        return;

    *new = mm_malloc(sizeof(http_header_item));
    if (*new == NULL)
        return;

    (*new)->key = mm_strdup(h->key);
    (*new)->value = mm_strdup(h->value);

    http_copy_headers(h->next, &((*new)->next));
}
#endif

os_error *http_free_headers(http_header_item *h)
{
    http_header_item *hn;

    while(h != NULL)
    {
        hn = h->next;
/*         fdebugf(log_file, "Freeing header line\n"); */

        if (h->key)
            mm_free((char*)h->key);
        if (h->value)
            mm_free((char*)h->value);

        mm_free(h);
        h = hn;
    }

    return NULL;
}

/*-----------------------------------------------------------------------*
 * http_fail                                                             *
 * Set the failure code for a connection, but don't destroy it (wait for *
 * foreground to notice and close it)                                    *
 *-----------------------------------------------------------------------*/

static void http_fail( http_connection *c, transfer_status status )
{
    http_set_status( c, status );

    fdebugf( log_file, "%p: *** failing due to %d\n", c, status );

    if ( c->fh )
    {
        ro_fclose( c->fh );
        c->fh = 0;
    }

    http_orphan_queue( c );
}


        /*=================================*
         *   http_prosecute                *
         *   The actual HTTP transaction   *
         *=================================*/


/* Connection passes through the following states, in order:
 *      status_NEW                  only in http_open
 *      status_AWAITING_CONNECTION  if it's on a queue
 *    + status_CONNECTING           waiting for connect to succeed
 *    + status_AUTHENTICATING       missed out if not HTTPS
 *    + status_REQUESTING           sending request
 * [[ + status_REQUEST_HEADERS      sending headers	-- obsolete in 0.96 et seq ]]
 *    + status_REQUEST_BODY         missed out if not POST
 *      status_WAITING              getting response line
 *      status_GETTING_HEADERS
 *      status_GETTING_BODY
 *
 * It counts towards sockets_connecting if in a state marked +
 */

os_error *http_prosecute( http_connection *c )
{
    /*int needToRead = 1;*/  /* used in "line reading" states */
    char *l;            /* ditto */
    int rc;
    int theerror;

    /* fdebugf(log_file,"http_prosecute status %d\n",c->status); */

    switch (c->status)
    {
    case status_CONNECTING:
        /* check to see if the connect has succeeded yet */
        rc = connect( c->socket, (struct sockaddr *) &(c->sa),
                      sizeof(struct sockaddr));

	theerror = socket_errno;

        fdebugf( log_file, "http_prosecute: connect returned %d errno is %d\n", rc, theerror );

        if (rc > -1)
        {
            /* This should not happen, but we will catch it anyway */
            http_set_status( c, status_AUTHENTICATING );
            /* go on to drop through the outer switch */
        }
        else
        {
            switch ( theerror )
            {
            case EISCONN:
                /* The connection is through now */
                http_set_status( c, status_AUTHENTICATING );
                break;
#ifdef WSAEINVAL
            case WSAEINVAL:
#endif
#ifdef WSAEINPROGRESS
            case WSAEINPROGRESS:
#endif
#ifdef WSAEWOULDBLOCK
            case WSAEWOULDBLOCK:
#endif
            case EALREADY:
                /* The connection is still going through */
                /* Do nothing */
                return NULL;
            default:
                /* The connection failed */
#if 0
		{
		    os_error e;
		    sprintf( e.errmess, "connect failed, socket_errno %d\n", theerror );
		    frontend_complain( &e );
		}
#endif
                http_fail( c, status_FAIL_CONNECT );
                return NULL;
            }
        }
        /* status is status_AUTHENTICATING so we can drop through */

    case status_AUTHENTICATING:

#ifndef NO_SECURE
        if ( c->SSL )
        {
            verify_error = FALSE;
            rc = SSL_connect( c->SSL );

#if DEBUG
	    if (socket_errno != EWOULDBLOCK)
		fdebugf( log_file, "SSL_connect returned %d (sockerrno=%d sslerrno=%d)\n", rc,
                                   socket_errno, SSL_errno() );
#endif

            if ( rc <= 0 )
            {
                if ( rc < 0 && (socket_errno == EWOULDBLOCK || SSL_errno() == EWOULDBLOCK ) )
                    return NULL;    /* still trying */

#if DEBUG
		dump_ssl_error();
#endif

                http_fail( c, verify_error ? status_FAIL_VERIFY
                                           : status_FAIL_REQUEST );
                return NULL;
            }


            /* Add some fake headers to provide SSL information */
            {
                X509 *peer = SSL_get_peer_certificate(c->SSL);
                char *cipher = SSL_get_cipher( c->SSL );

                fdebugf( log_file, "%p: peer=%p cipher=%p\n", c, peer, cipher );

                if ( peer )
                {
                    char *str;

#ifdef SSLEAY8
                    str=X509_NAME_oneline(X509_get_subject_name(peer), NULL, 0);
#else
                    str=X509_NAME_oneline(X509_get_subject_name(peer));
#endif
			/* str was allocated with malloc so we must free it*/
		    if (str)
		    {
                        fdebugf( log_file, "%p: cert subject '%s'\n", c, str );
			http_add_header_line( c, SSL_HEADER_CERT_SUBJECT,
					         str );
			mm_free(str);
		    }

#ifdef SSLEAY8
                    str=X509_NAME_oneline(X509_get_issuer_name(peer), NULL, 0);
#else                    
                    str=X509_NAME_oneline(X509_get_issuer_name(peer));
#endif

		    fdebugf( log_file, "X509_getiname OK (%p)\n", str );

		    if ( str )
		    {
                        fdebugf( log_file, "%p: cert issuer '%s'\n", c, str );
			http_add_header_line( c, SSL_HEADER_CERT_ISSUER,
                                              str );
			mm_free(str);
		    }

                    X509_free(peer);
                }
                else
                {
#if DEBUG
		    dump_ssl_error();
#endif
                }

                if ( cipher )
                {
                    fdebugf( log_file, "%p: cipher '%s'\n", c, cipher );
                    http_add_header_line( c, SSL_HEADER_CIPHER,
                                          cipher );
                }

                http_add_header_line( c, SSL_HEADER_VERIFIED,
                                      SSL_verified(c->SSL) ? SSL_HEADER_YES : SSL_HEADER_NO  );
	    }
        }
#endif
        http_set_status( c, status_REQUESTING );
        /* fall through */

    case status_REQUESTING:
        http_send_request(c);
        if ( c->status != status_REQUEST_BODY )
                return NULL;
        /* else we can drop through */

#if 0
    case status_REQUEST_HEADERS:
        rc = 0;
        while (c->status == status_REQUEST_HEADERS && rc != EWOULDBLOCK)
        {
            rc = http_send_request_headers(c);
        }
        if ( c->status != status_REQUEST_BODY )
            return NULL;
        /* else we can drop through */
#endif

    case status_REQUEST_BODY:
        rc = 0;
        while (c->status == status_REQUEST_BODY && rc != EWOULDBLOCK)
        {
            rc = http_send_request_body(c);
        }

        if ( c->status != status_WAITING )
            return NULL;
        /* else we can drop through */

    case status_WAITING:
        /* If we're in a queue, then don't try and read */
        if ( c->queueprev )
        {
            fdebugf( log_file, "%p: waiting for queueprev=%p to go NULL\n", c,
                     c->queueprev );
            return NULL;
        }

        /* Expecting a response line */
        l = http_getline(c, 1); /* Get the next line, doing a read */
        /*needToRead = 0;*/
        if (l)
            http_process_response_line(c, l);
        if ( c->status != status_GETTING_HEADERS )
            return NULL;
        /* else we can drop through */

    case status_GETTING_HEADERS:
        l = http_getline(c, 0/*needToRead*/);
        while (l && c->status == status_GETTING_HEADERS)
        {
                http_process_header_line(c, l);
                if (c->status == status_GETTING_HEADERS)
                    l = http_getline(c, 0);
        }
        if (c->status != status_GETTING_BODY)
            return NULL;

	/* if no content-range found when expected, start again */
	if ((c->flags & http_open_flags_IMAGE) &&		/* we sent range: */
	    c->rc == 206 &&					/* they said they're sending a range */
	    !(c->flags & http_flags_DOESRANGE))			/* but we didn't get a content-range header */
	{
            fdebugf( log_file, "%p: BYTE RANGES ARE BROKEN (no CONTENT-RANGE))\n", c );

	    http_set_server_flag( c, http_flags_RANGEBROKEN );

	    c->data_so_far = c->buf_off = c->buf_used = 0;
	    c->total_size = 0;
	    c->data_size = -1;
		
            http_requeue( c );

	    return NULL;
	}

        /* else we can drop through */

        rc = c->flags;

        /* If someone's in the queue behind us, they can write now
         * (but not read)
         *
         * HTTP/1.0 will send us a Connection: keep-alive if we're kept alive
         * HTTP/1.1 will send us a Connection: close      if we're *not*
         *
         * 20/5/97: pdh: Actually that only applies if we've sent a 1.1
         *          request, which we don't.
         */
        if ( /*(rc & http_flags_HTTP11) ?  ( rc & http_flags_NOTALIVE )
                                      :*/ !( rc & http_flags_KEPTALIVE ) )
            http_orphan_queue( c );
#if SEPARATE_ALLOW_WRITE
        else
            http_queue_allow_write( c );
#endif

    case status_GETTING_BODY:
#ifndef NO_SECURE
        if ( ( c->flags & http_flags_TUNNELLING )
             && (c->rc/100) == 2 )
        {
            /* Proxy negotiation has completed -- crack on with the SSL
             * handshake
             */

            fdebugf( log_file, "%p: starting up SSL connection\n", c );

            if ( !http_go_ssl(c) )
            {
                http_fail( c, status_FAIL_LOCAL );
                return NULL;
            }

            c->flags &= ~http_flags_TUNNELLING;

            http_set_status( c, status_AUTHENTICATING );

            /* Complete flush of the six bytes of cack that BT is liable
             * to have sent us
             */
	    /* SJM: range use means we need this information! */
	    if ( (c->flags & http_flags_GOTFIRST) == 0 )
	    {
		c->data_so_far = 0;
		c->buf_off = 0;
		c->buf_used = 0;
	    }

            http_prosecute( c );
            return NULL;
        }
#endif
        /* Now idempotent and quick to return */
        http_flush_data_to_file(c);

        /* It's IMPORTANT that if status becomes COMPLETED_FILE then we drop
         * through and don't return: we don't want Partial Content replies to
         * appear as COMPLETED_FILE to SWI HTTP_Status, or else the client will
         * HTTP_Close them before their time.
         */

        while (1)
        {
            int block;

            if ( ( c->data_size > -1
                   && c->data_so_far == c->data_size
                   && !c->boundary )
                 || c->flags & http_open_flags_HEAD )
            {
                fdebugf( log_file, "%p: got all %d of my %d bytes (total=%d): file complete\n", c, c->data_size, c->data_so_far, c->total_size );
                http_set_status( c, status_COMPLETED_FILE );
                break;  /* from the while loop */
            }

            /* Still got some more to read */
            block = c->data_size - c->data_so_far;

            if ( block > TMP_BUF_SIZE || c->data_size < 0 || c->boundary )
                block = TMP_BUF_SIZE;

            if ( c->boundary != NULL && c->nearlyboundary > 0 )
            {
                char *buf = tmp_buffer + c->nearlyboundary;
                block -= c->nearlyboundary;

                memcpy( tmp_buffer, c->boundary, c->nearlyboundary );

                fdebugf( log_file, "%p: nearlyboundary=%d\n", c, c->nearlyboundary );

                rc = http_recv( c, buf, block );
            }
            else
                rc = http_recv( c, tmp_buffer, block );

/*            fdebugf(log_file, "%p: recv (body %d) gave %d\n", c, block, rc); */

            if (rc <= 0)
            {
		if (rc < 0 && socket_errno == ECONNRESET)
		{
		    /* This is Netscape's ever-so-polite way of telling us
		     * not to do any more fetches down this socket
		     */
		    fdebugf( log_file, "%p: ECONNRESET, retrying on new socket\n", c );

		    http_close_and_reopen_socket(c);
		    connresets++;
		}
		else if (rc == 0 || socket_errno != EWOULDBLOCK)
                {
                    fdebugf(log_file, "%p: Connection closed on socket %d, errno=%d\n", c, c->socket, socket_errno);
                    http_set_status( c, status_COMPLETED_FILE );

                    http_socket_close( c );

                    http_orphan_queue( c );
                }
                break; /* This is a break for the WHILE loop, not the switch */
            }

            if ( c->boundary )
            {
                int nearly;
                const char *bound;

                rc += c->nearlyboundary;
                c->nearlyboundary = 0;

                bound = memfind( tmp_buffer, rc, c->boundary, &nearly );

                if ( bound )
                {
                    int wrote = ro_fwritepos( tmp_buffer, 1, bound - tmp_buffer,
                                              c->fh, c->data_so_far );

                    if ( wrote < (bound - tmp_buffer) )
                    {
                        http_oserror( c, ro_ferror() );
                        return NULL;
                    }

                    c->data_so_far += wrote;

                    fdebugf( log_file, "%p: bound: setting so_far=%d\n", c,
                             c->data_so_far );

                    bound += strlen( c->boundary );

                    if ( *bound == '-' && bound[1] == '-' )
                    {
                        fdebugf(log_file, "%p: end of server push\n", c );

                        http_set_status( c, status_COMPLETED_FILE );
                        if ( c->flags &
                               (http_open_flags_IMAGE|http_flags_RANGEBROKEN ))
                        {
                            fdebugf( log_file, "%p: this image was wrecked\n",
				     c );
                            c->flags |= http_flags_GOTFIRST;
                            c->data_so_far = 0;
                            /* break from the while loop, then falls through
                             * the switch and requeues
                             */
                            break;
                        }
                        http_socket_close( c );
                        http_orphan_queue( c );
                        return NULL;
                    }
                    /* else there's more parts to come */

                    fdebugf(log_file, "%p: server push continues %d %d\n", c,
                                      *bound, bound[1] );

                    if ( *bound == 13 )
                        bound++;
                    if ( *bound == 10 )
                        bound++;            /* skip CR LF */

                    wrote = bound - tmp_buffer;

		    if ( wrote > rc )
		        wrote = rc;

                    memcpy( c->buffer, bound, rc - wrote );
                    c->buf_used = 0;
                    c->buf_off = rc - wrote;

                    fdebugf(log_file,"%p: server push stuffs %d bytes (%d %d %d)\n",
                             c, c->buf_off,
                             c->buffer[0], c->buffer[1], c->buffer[2] );

                    http_set_status( c, status_COMPLETED_PART );
                    return NULL;
                }
                else /* if !bound */
                {
                    /* See whether there may be one straddling 2 packets */
		    if ( nearly != 0 )
		        fdebugf( log_file, "%p: nearly=%d\n", c, nearly );
                    c->nearlyboundary = nearly;
                    rc -= nearly;
                }

#if 0
		/* SJM: 26Aug97: Removed this bodge as it means that
		   the end of each part of a server push image doesn't
		   always get written out - and something crashes
		   eventually */

		/* pdh: bodge */
		break;
#endif
            } /* endif (c->boundary) */

            if (c->fh)
            {
                int wrote = ro_fwritepos( tmp_buffer, 1, rc, c->fh,
                                          c->data_so_far );


                if ( wrote < rc )
                {
                    http_oserror( c, ro_ferror() );
                    return NULL;
                }
            }

            c->data_so_far += rc;

            fdebugf( log_file, "%p: adding %d to so_far (now %d)\n",
                     c, rc, c->data_so_far );
        } /* end while */

        if ( c->status != status_COMPLETED_FILE )
            return NULL;
        /* else we can drop through */

    case status_COMPLETED_FILE:
        if ( c->total_size == 0 && c->rc == 206 )
        {
            fdebugf( log_file, "%p: Got RANGEOK return code but no Content-Range header\n",
                     c );
            http_set_server_flag( c, http_flags_RANGEBROKEN );

            c->flags |= http_flags_GOTFIRST;
            c->data_so_far = -1;
            c->data_size = -1;
            /* will call the following if to succeed */
        }

        if ( (c->flags & http_flags_GOTFIRST)
             && (c->data_so_far < c->total_size
                 || (c->flags & http_flags_RANGEBROKEN) ) )
        {
	    fdebugf( log_file, "%p: calling requeue so_far %d total %d RANGE %s\n",
		     c, c->data_so_far, c->total_size, c->flags & http_flags_RANGEBROKEN ? "BROKEN" : "OK" );
            http_requeue( c );
            return NULL;
        }
        else if ( c->socket != -1 )
        {
            /* We've still got a socket -- get rid of it if it's finished with
             */
            if ( c->flags & http_flags_NOTALIVE )
            {
                fdebugf( log_file, "%p: calling socket_close from status_c_f\n", c );
                http_socket_close( c );
                fdebugf( log_file, "%p: calling orphan_queue from status_c_f\n", c );
                http_orphan_queue( c );
            }
            else
            {
                fdebugf( log_file, "%p: calling allow read from status_c_f\n", c );
		
#if !SEPARATE_ALLOW_WRITE
                http_queue_allow_write( c );
#endif
                http_queue_allow_read( c );
            }
            return NULL;
        }
        fdebugf( log_file, "%p: doing nothing in status_c_f (socket=%d queuenext=%p)\n", c, c->socket, c->queuenext );
#if DEBUG
        http_show_flags(c);
#endif

        break;

    default:
        break;
    }

    return NULL;
}

static os_error *http_destroy( http_connection *c, int error )
{
    if ( c )
    {
        fdebugf( log_file, "%p: being closed by http_destroy(%d)\n", c, error );
        http_close_handle( c, 0 );
    }
    return make_httperror( error );
}

/*****************************************************************************

   This function gets associated with a socket, so when the socket
   becomes active, this function gets called. Not much we can do with
   errors.

*/
#if 0
static void http_prosecute_cb(int s, void *cp)
{
    http_connection *c = (http_connection *)cp;
    os_error *ep = http_prosecute( c );

    UNUSED(ep);
}
#endif

        /*===================*
         *   SWI HTTP_Open   *
         *===================*/


/* Forward references - opening connections */
static int http_open_socket( http_connection *c );
static BOOL http_queue_new( http_connection *me );

os_error *http_open(http_open_args *args)
{
    http_connection *new = NULL;
    int rc;
    http_open_args args2 = *args;
    BOOL bQueued;
#if PROXY_REDIRECT && !defined(NO_SECURE)
    os_error *e;
#endif

    args->out.handle = NULL;

#if EXTEND_BUFFER
    new = mm_malloc(sizeof(http_connection));
#else
    new = mm_malloc(sizeof(http_connection) + HEADER_MAX_INPUT);
#endif

    if (new == 0)
        return make_httperror(err_NO_MEMORY);

    fdebugf( log_file, "%p: New connection, host=0x%08lx, port=0x%04x (%d)\n",
                       new, args2.in.addr->sin_addr.s_addr,
                       args2.in.addr->sin_port, htons(args2.in.addr->sin_port));
    fdebugf( log_file, "%p:   object = '%s'\n", new, args2.in.object );
    fdebugf( log_file, "%p:   fname = '%s'\n", new, args2.in.fname?args2.in.fname:"NULL" );

    *new = proto_con;                /* Fill in with a prototype connection */

    memcpy((char *)&(new->sa),(char *) args2.in.addr,  sizeof(new->sa) );

    new->flags = args2.in.flags;

    new->object = strdup(args2.in.object);
    if (new->object == NULL)
    {
        return http_destroy(new,err_NO_MEMORY);
    }

#if PROXY_REDIRECT && !defined(NO_SECURE)
    /* If it feels neceesary this will update the addr and flags */
    if ((e = check_proxy_redirect(&new->sa, &new->flags, &new->object)) != NULL)
    {
	fdebugf( log_file, "%p: proxy redirect returns error '%s'\n", new, e->errmess );
	http_close_handle(new, 0);
	return e;
    }
#endif

    /* There appears to be a bug with restarting fetches and tunnelling proxies
     * Also, we don't want the excess overhead of renegotiating SSL for images.
     */
    if ( ( new->flags & (http_open_flags_TUNNEL|http_open_flags_SECURE) ) ||
	(allow & http_config_ALLOW_RANGES) == 0 )
	new->flags &= ~http_open_flags_IMAGE;

#ifdef WIN32
    /* Seems problematic at present */
    new->flags &= ~http_open_flags_IMAGE;
#endif

#if EXTEND_BUFFER
    new->buffer = mm_malloc(HEADER_MAX_INPUT);
    new->buf_size = HEADER_MAX_INPUT;
#else
    new->buffer = (char*) (new + 1);
#endif
    new->buffer[0] = 0;

#ifdef CSFS
    if (new->flags & http_open_flags_ACTION)
        new->action = args->in.action;
    else
        new->action = 0;
#endif

#if DEBUG
    http_show_flags( new );
#endif

    /* If we're prepared only to get the first few bytes, we can run at
     * priority.
     */
    if ( (new->flags & http_open_flags_IMAGE)
         && (new->flags & http_flags_DOESRANGE)
         && !(new->flags & http_open_flags_HEAD)
         && !(args2.in.bname) )
        new->flags |= http_open_flags_PRIORITY;

    bQueued = http_queue_new( new );

    if ( bQueued )
    {
        http_set_status( new, status_AWAITING_CONNECTION );

        /* Nothing can come in and try and use this queued connection until
         * we've built the output file etc, 'cos we're a SWI and are in SVC
         * mode, and prosecute is called from a callback.
         */
	/* DAF: 971021 */
	/* NO NO NO!!!! You might be under an entirely different environment. */
    }
    else
    {
        fdebugf( log_file, "%p: New connection, own socket\n", new );
        rc = http_open_socket( new );           /* sets new->status */
        if ( rc != err_NO_ERROR )
            return http_destroy( new, rc );
    }

    /*
     * The connection process may take a little time.  So we go off and make
     * the data file and come back in a moment to check if we are done.
     */

    /*http_copy_headers(args2.in.headers, &(new->sendhead_base) );*/

    if (args2.in.fname == NULL)
    {
        args2.in.fname = tmpnam(NULL);
    }

    new->fname = mm_strdup(args2.in.fname);
    if (new->fname == NULL)
    {
        return http_destroy(new,err_NO_MEMORY);
    }

    if ( new->flags & http_open_flags_HEAD )
        new->fh = 0;
    else
    {
        fdebugf(log_file, "%p: http_open Opening file '%s'\n", new, new->fname);

        new->fh = ro_fopen(new->fname, RO_OPEN_WRITE);

        fdebugf( log_file, "%p: file handle is %d\n", new, new->fh );

        if (new->fh == 0)
        {
            return http_destroy(new,err_CANT_OPEN_FILE);
        }

#ifdef RISCOS
        /* Figure out whether the output file is on a network filing system */
        {
            int fsno;

            fsno = _kernel_osargs( 254, new->fh, 0 ) & 0xFF;

            fdebugf( log_file, "%p: file is on fs %d\n", new, fsno );

            if (    fsno == 5     /* NetFS */
                 || fsno == 33    /* NFS */
                 || fsno == 45    /* NexusFS */
                 || fsno == 99    /* ShareFS */
                 || fsno == 102 ) /* LanManFS */
            {
                new->flags |= http_flags_NETWORKFILE;
            }

	    if (fsno == 99)	  /* ShareFS */
	    {
                new->flags |= http_flags_NOSETTYPEOPEN;
	    }
        }
#endif
    }

    if (args2.in.bname)
    {
        new->bname = mm_strdup(args2.in.bname);
        if (new->bname == NULL)
        {
            return http_destroy(new,err_NO_MEMORY);
        }

        fdebugf(log_file, "%p: http_open Opening body file '%s'\n", new, new->bname);

        new->bh = ro_fopen(new->bname, RO_OPEN_READ);
        if (new->bh == 0)
        {
            return http_destroy(new,err_CANT_OPEN_BODY);
        }
    }

    new->send_headers = http_build_request( new, args2.in.headers );
    new->send_sent = 0;

    new->next = http_cons_list;
    /* new->prev is set to NULL in the prototype */

    if (http_cons_list)
        http_cons_list->prev = new;
    /*else
        layers_http_init();*/


    http_cons_list = new;

    /* If we're lucky, the connection has succeeded while we were doing
     * all that, so check and see if we can move matters on.
     * If we were queued, check to see whether anyone's completed and
     * has a socket we can swipe.
     */
    if ( bQueued )
    {
        http_connection *c;

/*

        int i;
        for ( i=0; i < FD_SETSIZE; i++ )
        {
            c = http_cons[i];
            */
        c = http_cons_list;
        while ( c )
        {
            if ( c && c->queue && c->queue->queue
                 && ( c->status == status_COMPLETED_FILE ) )
            {
                http_prosecute( c );
                break;
            }
            c = c->next;
        }
    }
    else
        http_prosecute( new );

    args->out.handle = new;
    return NULL;
}


/*------------------------------------------------------------------------*
 * http_show_flags                                                        *
 * Output all the flags set for the connection (debug).                   *
 *------------------------------------------------------------------------*/

#if DEBUG
static void http_show_flags( http_connection *c )
{
    int f = c->flags;
    fdebugf( log_file, "%p: flags: ", c );

    if ( f & http_open_flags_SECURE )   fdebugf( log_file, " SSL" );
    if ( f & http_open_flags_VERIFY )   fdebugf( log_file, " SSL-verify" );
    if ( f & http_open_flags_HEAD )     fdebugf( log_file, " head" );
    if ( f & http_open_flags_PRIORITY ) fdebugf( log_file, " priority" );
    if ( f & http_open_flags_IMAGE )    fdebugf( log_file, " image" );
    if ( f & http_open_flags_TOMEM )    fdebugf( log_file, " to-mem" );
    if ( f & http_open_flags_TUNNEL )   fdebugf( log_file, " tunnel-proxy" );
    if ( f & http_flags_HTTP11 )        fdebugf( log_file, " http-1.1" );
    if ( f & http_flags_KEPTALIVE )     fdebugf( log_file, " kept-alive" );
    if ( f & http_flags_NOTALIVE )      fdebugf( log_file, " not-alive" );
    if ( f & http_flags_DOESRANGE )     fdebugf( log_file, " does-range" );
    if ( f & http_flags_RANGEBROKEN )   fdebugf( log_file, " range-broken" );
    if ( f & http_flags_GOTFIRST )      fdebugf( log_file, " got-first" );
    if ( f & http_flags_CHUNKED )       fdebugf( log_file, " chunked" );
    if ( f & http_flags_TUNNELLING )    fdebugf( log_file, " tunnelling" );

    if ( !f )
        fdebugf( log_file, " none" );

    fdebugf( log_file, "\n" );
}
#endif


#ifndef NO_SECURE
/*------------------------------------------------------------------------*
 * http_go_ssl                                                            *
 * Attach an SSL structure to the connection.                             *
 *------------------------------------------------------------------------*/

static BOOL http_go_ssl( http_connection *c )
{
    int j;

    c->SSL = SSL_new( ssl_context );

    fdebugf( log_file, "%p: sslnew gave %p, method is %p\n", c,
             c->SSL, (c->SSL ? SSL_get_ssl_method(c->SSL) : NULL) );

    if ( !c->SSL )
        goto err;

    j = SSL_set_fd( c->SSL, c->socket );
    fdebugf( log_file, "%p: setfd returned %d\n", c, j );
    if ( !j )
        goto err;

    SSL_set_connect_state( c->SSL );

    if ( c->flags & http_open_flags_VERIFY )
        SSL_set_verify( c->SSL, SSL_VERIFY_PEER, &cert_verify_callback );
    else
        SSL_set_verify( c->SSL, SSL_VERIFY_NONE, NULL );

    return TRUE;

err:

#if DEBUG
    dump_ssl_error();
#endif
    return FALSE;
}

#endif

/*------------------------------------------------------------------------*
 * http_open_socket                                                       *
 * Open the socket for a connection (may not be done at http_open time if *
 * keep-alive is in effect). Returns an err_XXX value.                    *
 *------------------------------------------------------------------------*/

static void http_async_callback( int s, void *handle )
{
    http_prosecute( (http_connection*)handle );
}

static int http_open_socket( http_connection *c )
{
    int rc;
    int theerror;

    /* SJM: set the tunnelling flag here, so that it is always in step
       with the original request */
    if (c->flags & http_open_flags_TUNNEL)
	c->flags |= http_flags_TUNNELLING;

    if ( c->socket != -1 )
        fdebugf( log_file, "%p: *** open_socket called when socket=%d\n", c,
                           c->socket );

    c->socket = socket( AF_INET, SOCK_STREAM, 0 );

    if ( c->socket < 0 )
    {
        c->socket = -1;
        return err_CANT_MAKE_SOCKET;
    }

    /* SJM: 1/6/97: moved these two inc's here so that destroy works correctly */
    /* if socket == -1 then close_socket won't decrement them so they need to be after the
       check for socket() succeeding */
    totalsockets++;

    if ( c->queue )
    {
        c->queue->nsockets++;
        fdebugf( log_file, "%p: queue %p gains socket %d, total=%d\n", c,
                 c->queue, c->socket,
                 c->queue->nsockets );
    }

    rc = layers_make_socket_asynchronous( c->socket, &http_async_callback, c );

    if (rc != 0)
	return err_BAD_IOCTL;

    rc = connect( c->socket, (struct sockaddr *) &(c->sa),
                  sizeof(struct sockaddr));

    theerror = socket_errno;

    /* Legal return values are:
     *
     *  EINPROGRESS(36) The connection process has been started but no result
     *                  as yet.
     *  EINVAL(22)      The connection process failed, either due to a timeout
     *                  or a rejection.
     *  EALREADY(37)    The connection process is still going on and may yet
     *                  finish.
     *  EISCONN(56)     The connection process succeeded and we are now
     *                  connected.
     *
     *  EWOULDBLOCK     Is returned by WinSock2 instead of EINPROGRESS,
     *                  arguably more the Right Thing.
     */

    fdebugf( log_file, "http_open_socket: connect returned %d socket_errno=%d\n",
                           rc, socket_errno );

    if ( rc < 0
         && (theerror != EINPROGRESS && theerror != EWOULDBLOCK) )
    {
#if 0
	os_error e;
	sprintf( e.errmess, "connect2 failed, rc=%d, socket_errno=%d\n", rc, theerror );
	frontend_complain(&e);
#endif
        return err_CANT_CONNECT;
    }

    /* Create a SSL connection if required.
     */
    if ( c->flags & http_open_flags_SECURE )
    {
#ifdef NO_SECURE
        return err_SSL_NOT_AVAILABLE;
#else
        if ( !ssl_present )
            return err_SSL_NOT_AVAILABLE;

        /* If we're going through a tunnel proxy, we need to begin the
         * transaction in unsecure mode and only call http_go_ssl() once
         * the proxy headers have been exchanged.
         */
        if ( !(c->flags & http_flags_TUNNELLING) )
        {
            if ( !http_go_ssl( c ) )
                return err_SSL_CANT_CONNECT;
        }
#endif
    }

    http_set_status( c, status_CONNECTING );

/*    http_cons[c->socket] = c; */

/*     totalsockets++; */

    fdebugf( log_file, "%p: opened new socket, %d, total is %d\n", c, c->socket,
             totalsockets );

/*     if ( c->queue ) */
/*     { */
/*         c->queue->nsockets++; */
/*         fdebugf( log_file, "%p: queue %p gains socket %d, total=%d\n", c, */
/*                  c->queue, c->socket, */
/*                  c->queue->nsockets ); */
/*     } */

    c->onthissocket = 1;

#if 0
    /* SJM: zero various values in case data had been part read before we restarted the fetch */
    c->data_so_far = 0;
    c->buf_off = 0;
    c->buf_used = 0;
#endif
    
    return err_NO_ERROR;
}


/*------------------------------------------------------------------------*
 * http_queue_new                                                         *
 * See whether there's a connection currently open which we could         *
 * potentially re-use.                                                    *
 *------------------------------------------------------------------------*/

#define RELEVANT_FLAGS ( http_open_flags_SECURE | http_open_flags_VERIFY | \
                         http_flags_TUNNELLING )

static BOOL http_queue_new( http_connection *me )
{
    http_queue *q = http_queues_list;
    http_connection *c;

    /* Find the queue for this server */
    while ( q )
    {
        if ( !memcmp( &me->sa, &q->sa, sizeof( struct sockaddr ) )
             && ( (me->flags & RELEVANT_FLAGS) == (q->flags & RELEVANT_FLAGS) ) )
        {
            /* Found a suitable queue */
            me->queue = q;

	    /* SJM: copy over any saved flags to avoid us making the same mistakes again */
	    me->flags |= (q->flags & http_flags_SERVER);
	    
            if ( ( q->nsockets < 2
                   && totalsockets < maxsockets )
                 || ( me->flags & http_open_flags_PRIORITY ) )
                    return FALSE;   /* Open another one */

            /* Add me to the queue
            if ( me->flags & http_open_flags_PRIORITY )
            {
                me->queueprev = NULL;
                me->queuenext = q->queue;
                if ( q->queue )
                    q->queue->queueprev = me;
                q->queue = me;
            }
            else */
            {
                /* Add to the end of the queue */
                c = q->queue;

                if ( c )
                {
                    while ( c->queuenext )
                        c = c->queuenext;

                    c->queuenext = me;
                    me->queueprev = c;
                }
                else
                {
                    q->queue = me;
                    me->queueprev = NULL;
                }
                me->queuenext = NULL;
            }

            return TRUE;
        }

        q = q->next;
    }

    /* No queue found, build a new one */

    q = (http_queue*) mm_malloc( sizeof( http_queue ) );

    /* If mm_malloc failed, give up */
    if ( q )
    {
        q->nsockets = 0;
        memcpy( &q->sa, &me->sa, sizeof( struct sockaddr ) );
        q->flags = me->flags;
        q->queue = NULL;
        q->next = http_queues_list;
        if ( q->next )
            q->next->prev = q;
        q->prev = NULL;
        http_queues_list = q;
        me->queue = q;
    }

    /* We always open a socket to a new server, even if totalsockets is
     * already maxsockets or more
     */
    return FALSE;
}


/*--------------------------------------------------------------------------*
 * http_from_queue                                                          *
 * Get the next waiting transaction from the queue (not very important, but *
 * it's duplicated code).                                                   *
 *--------------------------------------------------------------------------*/

static http_connection *http_from_queue( http_connection *c )
{
    http_connection *c2 = c->queuenext; /* A half-finished connection?... */

    if ( c2 )
        fdebugf( log_file, "%p: from_queue: returning queuenext: %p\n", c, c2 );

    if ( !c2 )                          /* ...if not, get one from the queue */
    {
        http_queue *q = c->queue;
        if ( q )
        {
            c2 = q->queue;
            if ( c2 )
            {
                fdebugf( log_file, "%p: from_queue: swiping %p from queue %p\n",
                                   c, c2, q );
                q->queue = c2->queuenext;

                if ( q->queue )
                    q->queue->queueprev = NULL;
                c2->queuenext = NULL;
            }
            else
                fdebugf( log_file, "%p: from_queue: queue %p empty\n", c, q );
        }
        else
            fdebugf( log_file, "%p: from_queue: no queuenext and no queue\n", c );
    }
    return c2;
}


/*--------------------------------------------------------------------------*
 * http_orphan_queue                                                        *
 * Having decided that keep-alive isn't going to happen, open a new socket  *
 * for anything waiting for ours to come free. Note that we *may* be called *
 * after allow_write, but shouldn't be called after allow_read.             *
 *     orphan_queue *must* set c->queue to NULL if it makes a new socket    *
 * (so it's never called twice on the same connection, which would violate  *
 * the Principle of Conservation of Sockets).                               *
 *--------------------------------------------------------------------------*/

static void http_orphan_queue( http_connection *c )
{
    http_connection *c2;

    /* Make sure noone else comes in */
    c->flags |= http_flags_NOTALIVE;

    /* Limit number of sockets, unless this is the last socket open on its
     * queue.
     */
    if ( (c->socket != -1) && totalsockets >= maxsockets
         && ( !c->queue || !c->queue->queue || c->queue->nsockets > 0 ) )
    {
        fdebugf( log_file,"%p: not orphaning queue 'cos of socket limit\n", c );
        return;
    }

    fdebugf( log_file, "%p: orphaning queue\n", c );

    c2 = http_from_queue( c );

    c->queuenext = NULL;

    if ( !c2 )
        return;

    c2->queueprev = NULL;

    fdebugf( log_file, "%p: Orphaning queued connection %p\n", c, c2 );

    /* Open socket */
    if ( http_open_socket( c2 ) != err_NO_ERROR )
    {
        /* There was an error, but we can't return it */
        http_fail( c2, status_FAIL_CONNECT );
    }

    /* Disconnect from queue -- do this *after* opening the new socket, so
     * q->nsockets doesn't go to zero.
     */
    http_queue_dec_nsockets( c );
    c->queue = NULL;
}


/*--------------------------------------------------------------------------*
 * http_queue_allow_write                                                   *
 * We've finished writing to our socket, so the next request can start.     *
 *--------------------------------------------------------------------------*/

static void http_queue_allow_write( http_connection *c )
{
    http_connection *c2 = http_from_queue( c );

    if ( !c2 )
        return;

    c2->queueprev = c;
    c->queuenext = c2;      /* from_queue followed by this is idempotent in
                             * the case c2 is *already* c->queuenext
                             */

    if ( c2->status != status_AWAITING_CONNECTION )
        return;     /* already been done */

    fdebugf( log_file, "%p: handing socket 0x%x writes over to %p\n", c,
                        c->socket, c2 );

    c2->onthissocket = c->onthissocket+1;

    c2->socket = c->socket;     /* Shared, not transferred */

#ifndef NO_SECURE
    c2->SSL = c->SSL;           /* Shared, not transferred */
#endif

    http_set_status( c2, status_REQUESTING );
    http_prosecute( c2 );
}


/*--------------------------------------------------------------------------*
 * http_queue_allow_read                                                    *
 * We've finished with our socket now, so, if anyone's waiting, they can    *
 * have it. allow_write may have been called, but may not.                  *
 *--------------------------------------------------------------------------*/

static void http_queue_allow_read( http_connection *c )
{
    http_connection *c2;
#if 0
    int rc;
    char foo[4];

    /* Note this does the Right Thing even in the SSL case */
    rc = recv( c->socket, foo, 4, MSG_PEEK );
    fdebugf( log_file, "%p: allow_read: rc=%d socket_errno=%d\n",
                       c, rc, socket_errno );

    if ( rc < 0 && socket_errno != EWOULDBLOCK )
    {
        fdebugf( log_file,
                 "%p: invalid socket in allow_read, orphaning instead\n", c );
        http_socket_close( c );
        http_orphan_queue( c );
        return;
    }
#endif

    c2 = http_from_queue( c );
    if ( !c2 )
    {
        /* Close the socket for tidiness' sake *only* if we're already dead */
        if ( c->flags & http_flags_NOTALIVE )
            http_socket_close( c );
        return;
    }

    /* Note that because of partial fetching, we must cope with the case c2==c
     */
    c->queuenext = NULL;
    c2->queueprev = NULL;

    fdebugf( log_file, "%p: handing socket 0x%x reads over to %p\n", c,
                       c->socket, c2 );

    c2->onthissocket = c->onthissocket+1;

    keptalive++;

    c2->socket = c->socket;

#ifndef NO_SECURE
    c2->SSL    = c->SSL;
#endif

    /* Make sure noone else comes in */
    if ( c2 != c )
    {
        c->flags |= http_flags_NOTALIVE;
        c->socket = -1;
#ifndef NO_SECURE
        c->SSL = NULL;
#endif
    }

/*    http_cons[ c2->socket ] = c2; */
    layers_async_change_handle( c2->socket, c2 );

    if ( c2->status == status_AWAITING_CONNECTION )
        http_set_status( c2, status_REQUESTING );

    fdebugf( log_file, "%p: just got reads, status is %d\n", c2, c2->status );

    /* otherwise, allow_write has been called and it's on its way already */
    http_prosecute( c2 );
}


/*--------------------------------------------------------------------------*
 * http_requeue                                                             *
 * We've fetched the first few bytes of an image, so requeue it (at a lower *
 * priority) to get the other bits.                                         *
 *--------------------------------------------------------------------------*/

static void http_requeue( http_connection *c )
{
    http_queue *q = c->queue;
    http_connection *qptr;

    http_free_headers( c->headers );
    c->headers = NULL;

    if ( !q || (!q->queue && !c->queuenext)
         || ( c->flags & http_flags_NOTALIVE ) )
    {
        fdebugf( log_file, "%p: restarting\n", c );

        if ( c->flags & http_flags_NOTALIVE )
        {
            http_socket_close( c );
        }

        c->flags &= http_open_flags_ALLUSER | http_flags_SERVER
                    | http_flags_GOTFIRST;

        if ( c->flags & http_flags_RANGEBROKEN )
            c->flags &= ~http_flags_GOTFIRST;

        if ( c->socket == -1 )
        {
            /* Must start a new connection */
            http_open_socket( c );

	    /* pdh 15-Jul-98: needs to be kicked here */
	    http_prosecute( c );
        }
        else
	{
            http_set_status( c, status_REQUESTING );

	    /* pdh 15-Jul-98: needs to be kicked here */
	    http_prosecute( c );
	}

        return;
    }

    fdebugf( log_file, "%p: requeueing\n", c );

    http_queue_allow_read( c );

    c->flags &= http_open_flags_ALLUSER | http_flags_SERVER
                | http_flags_GOTFIRST;

    if ( c->flags & http_flags_RANGEBROKEN )
        c->flags &= ~http_flags_GOTFIRST;


    /* Add to end of queue */
    qptr = q->queue;
    if ( qptr )
    {
        while ( qptr->queuenext )
            qptr = qptr->queuenext;

        qptr->queuenext = c;
        c->queueprev = qptr;
    }
    else
    {
        q->queue = c;
        c->queueprev = NULL;
    }
    c->queuenext = NULL;
    http_set_status( c, status_AWAITING_CONNECTION );
}


        /*====================*
         *   SWI HTTP_Close   *
         *====================*/


os_error *http_close(http_close_args *args)
{
    http_connection *c;
    os_error *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    fdebugf( log_file, "%p: being closed by SWI http_close (socket %d)\n", c,
             c->socket );

    return http_close_handle(c, args->in.flags);
}

os_error *http_close_handle(http_connection *c, int flags)
{
    /* Note that we DO free the outgoing headers as we've taken copies of
     * them !!
     */

    fdebugf( log_file, "%p: being closed by SWI http_close (socket %d)\n", c,
             c->socket );

    /* Unlink from queue. If we're at the head of the queue, and not being
     * shut down completely, orphan the rest of the queue.
     */
    if ( c->queueprev )
    {
        /* Easy case -- mid-queue */
        if ( c->queuenext )
            c->queuenext->queueprev = c->queueprev;
        c->queueprev->queuenext = c->queuenext;

        if ( ( c->socket > -1 )
            && c->status > status_CONNECTING )
        {
            /* If we've sent a request down this socket then its current
             * owner will be unable to send a further request down it.
             */
            c->queueprev->flags |= http_flags_NOTALIVE;
        }

        /* Don't close the socket! We don't own it! */
        c->socket = -1;
    }
    else
    {
        /* Head of the queue. 2 cases: active and queued */
        if ( c->queue && c->queue->queue == c )
        {
            /* We were stuck in the queue anyway */
            c->queue->queue = c->queuenext;

            if ( c->queue->queue )
                c->queuenext->queueprev = NULL;
            c->queuenext = NULL;
            c->queueprev = NULL;
        }
        else
        {
            /* We were active */
            if ( flags & http_close_FATAL )
            {
                if ( c->queuenext )
                    c->queuenext->queueprev = NULL;
            }
            else
            {
                if ( c->socket != -1 )
                {
                    /* We must check the status here, it's no good passing on
                     * a socket that's in the middle of a GIF fetch!
                     */
                    if ( c->flags & http_flags_NOTALIVE
                         || ( c->status < status_COMPLETED_FILE ) )
                    {
                        /* Close the socket first so that we know orphan_queue
                         * is allowed to create a new one
                         */
                        http_socket_close( c );
                        http_orphan_queue( c );
                    }
                    else
                        http_queue_allow_read( c );
                }
            }
        }
    }

    http_set_status( c, status_FINISHING );  /* sort out sockets_connecting */

#if 0 /* ndef NO_SECURE SJM: moved into socket_close */
    if ( c->SSL != NULL )
    {
        fdebugf( log_file, "Closing SSL connection\n" );
        SSL_free( c->SSL );
    }
#endif

/*  http_cons[c->socket] = NULL; */

    if (c->fh != 0)
    {
        fdebugf(log_file, "Closing output file\n");
        ro_fclose(c->fh);
        c->fh = 0;
    }

    if (c->bh != 0)
    {
        fdebugf(log_file, "Closing body file\n");
        ro_fclose(c->bh);
        c->bh = 0;
    }

    /* Do this one first in case someone is stupid enough to set the type and
     * then delete
     */
    if (flags & http_close_SET_TYPE)
    {
        http_set_file_type(c, NULL);
    }

    if (flags & http_close_DELETE_FILE)
    {
        if (c->fname)
        {
            fdebugf(log_file, "Removing file '%s'\n", c->fname);
            remove(c->fname);
        }
    }

    if (flags & http_close_DELETE_BODY)
    {
        if (c->bname)
        {
            fdebugf(log_file, "Removing file '%s'\n", c->bname);
            remove(c->bname);
        }
    }

    http_socket_close(c); /* Does its own check for valid socket number */

    if (c->fname)
    {
        mm_free(c->fname);
    }

    if (c->bname)
    {
        mm_free(c->bname);
    }

    if (c->message)
    {
        mm_free(c->message);
    }

    if (c->object)
    {
        mm_free(c->object);
    }

    http_free_headers(c->headers); /* Does its own check for NULL pointers */

#if 0
    http_free_headers(c->sendhead_base);
#else
    if ( c->send_headers )
	mm_free( c->send_headers );
#endif

    /* Finally, zap the magic number */
    c->magic = 0;

    fdebugf(log_file, "Unlinking from list\n");

    if (c->prev == NULL)
        http_cons_list = c->next;
    else
        c->prev->next = c->next;

    if (c->next != NULL)
        c->next->prev = c->prev;

#if EXTEND_BUFFER
    if (c->buffer)
    {
	mm_free(c->buffer);
    }
#endif

    fdebugf(log_file, "Freeing connection structure\n");
    mm_free(c);

/*  if ( !http_cons_list )
       layers_http_shutdown();*/

    fdebugf(log_file, "Connection closed.\n");

    return 0;
}


        /*=================*
         *   Other SWIs    *
         *=================*/


os_error *http_status(http_status_args *args)
{
    http_connection *c;
    os_error *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    if ( c->status == status_FAIL_LOCAL )
    {
        httperror.errnum = 1;
        strcpy( httperror.errmess, c->message );
        return &httperror;
    }

    /* Lie to people about the state of requeued connections */
    if ( (c->flags & http_flags_GOTFIRST)
         && c->status < status_GETTING_BODY )
        args->out.status = status_GETTING_BODY;
    else
        args->out.status = c->status;

    args->out.ro_fh = c->fh ;
    args->out.fname = c->fname ;
    args->out.data_size = c->total_size ? c->total_size : c->data_size ;
    args->out.data_so_far = c->data_so_far ;
    args->out.headers = c->headers ;

    if ( c->rc == 206
         && c->data_so_far == c->total_size )
        args->out.rc = 200;     /* "OK" */
    else
        args->out.rc = c->rc;

    args->out.message = c->message ;

#if 0 /*ndef NO_SECURE*/
    client_status_called(c->SSL);
#endif
    
    return NULL;
}

os_error *http_maptoriscos(http_maptoriscos_args *args)
{
#ifdef RISCOS
    if (allow & http_config_USE_MIMEMAPMOD)
	/* SWI XMimeMap_Translate */
	return _swix( 0x70B00, _INR(0,2)|_OUT(3), mmmtype_MIME, args->in.extn,
		      mmmtype_RISCOS, &args->out.ft );
    
# ifdef ACORN_BUILD
    args->out.ft = mime_to_file_type(args->in.extn);
# else
    args->out.ft = 0;
# endif
#else
    args->out.ft = 0;
#endif
    return NULL;
}

os_error *http_mapfromriscos(http_mapfromriscos_args *args)
{
#ifdef RISCOS
    if (allow & http_config_USE_MIMEMAPMOD)
    {
	static char result[128];

	/* SWI XMimeMap_Translate */
	return _swix( 0x70B00, _INR(0,3)|_OUT(3), mmmtype_RISCOS, args->in.ft,
		      mmmtype_MIME, result,
		      &args->out.extn );
    }

# ifdef ACORN_BUILD
    args->out.extn = (char *)mime_map_from_riscos(args->in.ft);
# else
    args->out.extn = NULL;
# endif
#else
    args->out.extn = NULL;
#endif
    return NULL;
}

os_error *http_setfiletype(http_setfiletype_args *args)
{
    http_connection *c;
    os_error *ep;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    return http_set_file_type(c, &args->out.ftype);
}

os_error *http_config( http_config_args *r)
{
    switch (r->flags & http_config_REASON_MASK)
    {
    case http_config_SET_FLAGS:
	allow = (allow & r->r1) ^ r->r2;
	r->r1 = allow;
	break;

    case http_config_GET_MAX_SOCKETS:
	r->r1 = maxsockets;
	break;

    case http_config_SET_MAX_SOCKETS:
	maxsockets = r->r1;
	break;

    case http_config_IS_SSL_AVAILABLE:
#ifdef NO_SECURE
	r->r1 = http_ssl_NONE;
	r->r2 = 0;
#else
	r->r1 = SSL_export_only() ? http_ssl_EXPORT : http_ssl_FULL;
	r->r2 = SSL_VERSION;
#endif
	break;
    }
    return NULL;
}

/*--------------------------------------------------------------------------*
 * SWI HTTP_CompletedPart                                                   *
 * Client has finished dealing with the current part of a server-push       *
 * document, so it's time to pile on and get the next part.                 *
 *--------------------------------------------------------------------------*/

os_error *http_completedpart( http_completedpart_args *args )
{
    http_connection *c;
    os_error *ep;
    char *fname = args->in.newfname;
    int flags = args->in.flags;

    c = args->in.handle;

    ep = http_check_handle(c);
    if (ep)
        return ep;

    if ( c->status != status_COMPLETED_PART )
        return make_httperror( err_NOT_WAITING );

    /* Get rid of the existing file if required */

    if ( fname )
    {

        if (c->fh != 0)
        {
            fdebugf(log_file, "%p: closing output file %d in completedpart\n", c, c->fh);
            ro_fclose(c->fh);
            c->fh = 0;
        }

	fdebugf(log_file, "%p: close file succeeded\n",c );

        if (flags & http_close_SET_TYPE)
	{
	    fdebugf( log_file, "%p: setting file type\n", c );
            http_set_file_type(c, NULL);
	    fdebugf( log_file, "%p: set type succeeded\n", c );
	}

        if ( flags & http_close_DELETE_FILE )
        {
            fdebugf(log_file, "%p: removing file '%s'\n", c, c->fname);
            remove(c->fname);
        }
        mm_free( c->fname );

        /* Make a new file */

        c->fname = mm_strdup(fname);
        if (c->fname == NULL)
            return http_destroy(c,err_NO_MEMORY);

        fdebugf(log_file, "%p: http_completed_part opening file '%s'\n", c, c->fname);
        c->fh = ro_fopen(c->fname, RO_OPEN_WRITE);

	fdebugf(log_file, "%p:   file handle %d\n", c, c->fh );

        if (c->fh == 0)
            return http_destroy(c,err_CANT_OPEN_FILE);
    }
    else
    {
        /* We reuse the existing file... actually this needs no code here! */
    }

    /* Send it on its way */

    c->data_so_far = -1;
    c->data_size = -1;

    fdebugf( log_file, "%p: setting so_far=-1 in completedpart\n", c );

    http_set_status( c, status_GETTING_HEADERS );

    http_prosecute( c );

    return NULL;
}

static char *http_build_request( http_connection *c, http_header_item *h )
{
    int len = 0;
    http_header_item *hptr;
    char *result, *ptr, *object;
    const char *meth = c->bh ? "POST" :
                 (c->flags & http_open_flags_HEAD ) ? "HEAD"
                                                    : "GET";

    len = 5 + strlen(c->object) + 90;			    /* "HEAD " + " HTTP/1.0\r\n" */

    for ( hptr = h; hptr; hptr = hptr->next )
    {
	len += strlen( hptr->key ) + strlen( hptr->value ) + 4;   /* ": " + "\r\n" */
    }

    result = mm_malloc( len+1 );			    /* '\0' */

    if ( !result )
	return NULL;

#ifndef NO_SECURE
    /* SJM: if tunnelling then skip to path */
    if ( (c->flags & (http_open_flags_TUNNEL | http_open_flags_SECURE))
	   == (http_open_flags_TUNNEL | http_open_flags_SECURE) )
    {
        char *slash = strchr(c->object + 8, '/' );
	if (slash)
	    object = slash;
	else
	    object = "/";
    }
    else
#endif
	object = c->object;

    sprintf( result, "%s %s %s\r\n", meth, object, http_version );

    ptr = result;

    for ( hptr = h; hptr; hptr = hptr->next )
    {
	ptr += strlen(ptr);
	sprintf( ptr, "%s: %s\r\n", hptr->key, hptr->value );
    }

    fdebugf( log_file, "%p: build_request: built %s\n", c, result );

    return result;
}

void http_send_request(http_connection *c)
{
    /* pdh 03-Apr-98: The New Plan is to try and send the whole lot in one go
     * a la Mozilla
     */

    int len = strlen( c->send_headers );
    int rc;

    fdebugf( log_file, "%p: calling http_send(%d)\n", c, len - c->send_sent );

    rc = http_send( c, c->send_headers + c->send_sent, len - c->send_sent );

    fdebugf( log_file, "%p: sent %s\n", c, c->send_headers + c->send_sent );

    if ( rc < 0 )
	http_fail( c, status_FAIL_REQUEST );
    else
    {
	c->send_sent += rc;

	if ( c->send_sent == len )
	{
	    /* Send httpmod's own headers, then organise the next
             * state. All this code used to be in send_request_headers
	     */
            *tmp_buffer = 0;

#if DEBUG
            http_show_flags(c);
#endif
            /* Reset for potential next bit (if an image prefix) */
            c->send_sent = 0;

            if (c->bh)
            {
                if (c->data_size == -1)
                {
                    if ( !file_get_size_and_type( c->bname, &c->data_size, NULL ) )
                        c->data_size = -1; /* doesn't exist */
                }
                sprintf(tmp_buffer, "Content-length: %d\r\n", c->data_size);
#if ADD_CRLF
		c->data_size += 2;
#endif
                fdebugf( log_file, "(7) %p: txheader Content-length: %d\n",
                                   c, c->data_size );
            }

            /* Don't send keep-alive to proxies unless they do HTTP/1.1
             * (for rationale see RFC2068)
             */
            if ( (allow & http_config_ALLOW_KEEPALIVE) &&
		 (c->flags & http_flags_HTTP11) || !strchr( c->object, ':' ) )
            {
                strcat( tmp_buffer, "Connection: Keep-Alive\r\n" );
                fdebugf( log_file, "(7) %p: txheader Connection: Keep-Alive\n", c );
            }

            /* If this is an image, and isn't a priority (ie isn't the
             * background image), and is a normal fetch, only ask for the first
             * few bytes. If we've already had the first few bytes, ask for
             * the remainder.
             */
            if ( c->flags & http_flags_GOTFIRST
                 && !(c->flags & http_flags_RANGEBROKEN) )
            {
                /* Unbelievably, F**kWitScape Enterprise Server gets it wrong
                 * if you ask it for "bytes=256-" ... it only gives you 1000
                 * bytes even if there are more.
                 */
                char *ptr = tmp_buffer + strlen( tmp_buffer );

                sprintf( ptr, "Range: bytes=" IMAGE_HEADER1_T "-%d\r\n",
                              c->total_size-1 );
                fdebugf( log_file, "%p: (7) txheader Range: bytes=" IMAGE_HEADER1_T
                                   "-%d\n", c, c->total_size-1 );
                c->flags &= ~http_open_flags_IMAGE;
            }
            else if ( ( c->flags & http_open_flags_IMAGE )
                      && !( c->flags & ( http_open_flags_HEAD
                                         | http_flags_RANGEBROKEN ) )
                      && !c->bh )
            {
                strcat( tmp_buffer, "Range: bytes=0-" IMAGE_HEADER_T "\r\n" );
                fdebugf( log_file, "%p: (7) txheader Range: bytes=0-"
                                   IMAGE_HEADER_T "\n", c );
            }
            else
                c->flags &= ~http_open_flags_IMAGE;

            /* open_flags_IMAGE is now true ONLY if we've sent the range:
             * header
             */

            strcat(tmp_buffer, "\r\n");

	    rc = http_send( c, tmp_buffer, strlen(tmp_buffer) );

	    if ( rc < 0 )
	    {
		http_fail( c, status_FAIL_REQUEST );
		return;
	    }

            /* all done; set up request body if there is one */
            if ( c->bh )
            {
                http_set_status( c, status_REQUEST_BODY );
                ro_fread(c->buffer, 1,
                         c->data_size > HEADER_MAX_INPUT ? HEADER_MAX_INPUT : c->data_size,
                         c->bh);
                c->data_so_far = 0;

#if ADD_CRLF
		/* this goes wrong if data_size = HEADER_MAX_INPUT+1 ! */
		if (c->data_size <= HEADER_MAX_INPUT)
		{
		    char *s = c->buffer + c->data_size - 2;
		    *s++ = '\r';
		    *s++ = '\n';
		}
#endif
                fdebugf( log_file, "%p: setting so_far=0 in sendrh\n", c );
            }
            else
            {
                http_set_status( c, status_WAITING );
            }
	}
    }
}


/* Returns 0 if data was sent or the connection died, EWOULDBLOCK if it would block */
int http_send_request_body(http_connection *c)
{
    int sent;
    int to_go;

    /* This is always entered with the c->buffer as full as it can be,
     * c->data_size the size of the file to be sent and c->data_so_far
     * the amount of data sent to far.
     */

    fdebugf(log_file, "Sending data: so far %d of %d\n", c->data_so_far, c->data_size);

    to_go = c->data_size - c->data_so_far;

    if (to_go > 0)
        sent = http_send(c, c->buffer, to_go > HEADER_MAX_INPUT ? HEADER_MAX_INPUT : to_go );
    else
        sent = 0;

    if ( sent < 0)
    {
        if ( socket_errno != EWOULDBLOCK )
        {
            http_fail( c, status_FAIL_REQUEST );
        }
        else
        {
            /* If it would block then just return */
            return EWOULDBLOCK;
        }
    }
    else
    {
        c->data_so_far += sent;
        to_go -= sent;

        if (to_go > 0)
        {
            if (sent != HEADER_MAX_INPUT)
                memmove(c->buffer, c->buffer + sent, HEADER_MAX_INPUT - sent);

            ro_fread(c->buffer + HEADER_MAX_INPUT - sent, 1, sent > to_go ? to_go : sent, c->bh);
#if ADD_CRLF
	    if (sent >= to_go)
	    {
		char *s = c->buffer + HEADER_MAX_INPUT - sent + to_go - 2;
		*s++ = '\r';
		*s++ = '\n';
	    }
#endif
	}
        else
        {
            c->data_size = c->data_so_far = -1;

            fdebugf( log_file, "%p: setting so_far=-1 in sendrb\n", c );
            http_set_status( c, status_WAITING );
        }
    }

    return 0;
}

/*
 * Read some more data from the line and return the next line of data
 */
char* http_getline(http_connection *c, int read)
{
    char *end;
    int rc = 1;     /* any non-zero value */
#if EXTEND_BUFFER
    int buf_size = c->buf_size;
#else
    int buf_size = HEADER_MAX_INPUT;
#endif
    
/*  fdebugf(log_file, "%p: getline buf_size %d buf_off %d buf_used %d\n", c, c->buf_size, c->buf_off, c->buf_used ); */

    if (c->buf_used)
    {
        memmove(c->buffer, c->buffer + c->buf_used, c->buf_off - c->buf_used + 1);
        c->buf_off -= c->buf_used;
        c->buf_used = 0;
    }

#if EXTEND_BUFFER
    /* need to loop to ensure that all the data is read from the internet module
     * It only loops if the input buffer is full after reading a batch of data so
     * it can check if there is still data waiting to be read after we've extended
     * the input buffer.     
     */
    for (;;)
#endif
    {
	/* pdh: might as well always read it */
	if ( buf_size - c->buf_off - 1 > 0 )
	{
	    /* pdh: for the insecure prefix to a tunnelled conversation, peek
	     * don't read
	     if ( (c->flags & http_open_flags_TUNNEL)
             && !c->SSL )
	     {
	     rc = recv(c->socket,c->buffer + c->buf_off,
	     buf_size - c->buf_off - 1, MSG_PEEK);
	     if ( rc>0 )
	     fdebugf( log_file, "%p: peeked %d bytes\n", c, rc );
	     }
	     else
	    */
            rc = http_recv( c, c->buffer + c->buf_off,
                            buf_size - c->buf_off - 1);

	    if ( rc==0 )
	    {
		fdebugf(log_file, "%p: EOF in getline (%d chars)\n", c,c->buf_off );

		if ( c->buf_off == 0 )
		{
		    if ( c->onthissocket > 1 )
		    {
			/* We may have been thrown off.
			 * *CAREFUL* not to cause infinite loops here, the
			 * use of onthissocket makes sure of it.
			 */
			fdebugf( log_file, "%p: server lied about keep-alive\n", c );

			http_close_and_reopen_socket(c);
			keepalivelies++;

			c->onthissocket = 1;
		    }
		    else
		    {
			http_fail( c, status_FAIL_REQUEST );
		    }
		    return NULL;
		}
	    }

	    if ( rc < 0 )
	    {
		if (socket_errno != EWOULDBLOCK)
		{
		    if ( socket_errno == ECONNRESET )
		    {
			/* This is Netscape's ever-so-polite way of telling us
			 * not to do any more fetches down this socket
			 */
			fdebugf( log_file, "%p: ECONNRESET, retrying on new socket\n", c );

			http_close_and_reopen_socket(c);
			connresets++;
		    }
		    else
		    {
			fdebugf( log_file, "%p: *** failed in getline (socket_errno=%d)\n",
				 c, socket_errno );

			http_fail( c, status_FAIL_REQUEST );
		    }
		    return NULL;
		}
	    }
	    else
	    {
#if DEBUG
		fdebugf(log_file, "%p: read %d bytes\n", c, rc);
		/*dump(log_file, c->buffer + c->buf_off, rc); */
#endif
		c->buf_off += rc;
	    }
	}

	/* pdh: moved this termination outside the if */
	c->buffer[c->buf_off] = 0; /* Make use we always have a NULL at the end */
	end = strchr(c->buffer, '\n');

	if (end)
	{
	    c->buf_used = (end - c->buffer) + 1;

	    /* pdh: for the insecure prefix to a tunnelled conversation, we know
	     * we want to read this much now
	     if ( (c->flags & http_open_flags_TUNNEL)
             && !c->SSL )
	     {
	     recv( c->socket, c->buffer, c->buf_used, 0 );
	     fdebugf( log_file, "%p: really read %d\n", c, c->buf_used );
	     }
	    */

	    if (end[-1] == '\r')
		end[-1] = 0;
	    end[0] = 0;
	    return c->buffer;
	}

#if EXTEND_BUFFER
	if ( !rc ) /* EOF but no new line */
	{
	    /* This is not a good situation the stream has ended with no line feed */
	    c->buf_used = c->buf_off + 1;
	    fdebugf(log_file, "%p: EOF without newline (%d chars %d %d %d)\n", c, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
	    return c->buffer;
	}

	if ( (buf_size - c->buf_off - 1 == 0) ) /* Phrased like this as this is the formula used in the recv() call */
	{
	    char *new_buf;

	    /* This is not a good situation, the buffer is full but we don't have
	     * a line feed so extend buffer and continue */

	    new_buf = mm_malloc(c->buf_size + HEADER_MAX_INPUT);
	    if (!new_buf)
	    {
		c->buf_used = c->buf_off + 1;
		fdebugf(log_file, "%p: getline buffer filled up - can't extend (%d chars %d %d %d); cleared\n", c, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
		return c->buffer;
	    }

	    memcpy(new_buf, c->buffer, c->buf_off+1);
	    mm_free(c->buffer);

	    c->buffer = new_buf;
	    c->buf_size += HEADER_MAX_INPUT;

	    buf_size = c->buf_size;
	    
	    fdebugf(log_file, "%p: getline buffer filled up - extended to %d (%d chars %d %d %d)\n", c, c->buf_size, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
	}
	else
	{
	    return NULL;
	}
#else
	if ( (buf_size - c->buf_off - 1 == 0) || !rc ) /* Phrased like this as this is the formula used in the recv() call */
	{
	    /* This is not a good situation, the buffer is full but we don't have
	     * a line feed */
	    c->buf_used = c->buf_off + 1;
	    fdebugf(log_file, "%p: getline buffer filled up (%d chars %d %d %d); cleared\n", c, c->buf_off, c->buffer[0], c->buffer[1], c->buffer[2] );
	    return c->buffer;
	}
#endif
    }
    return NULL;
}

static http_header_item *http_add_header_line( http_connection *c,
                                        char *key, char *value )
{
    http_header_item *hi;

    /* SJM: vital that multiple set-cookie: lines are held.
     * I'm unsure whether it is wise to strip multiples generally.
     */
    if (stricmp(key, "SET-COOKIE") != 0)
    {
	for ( hi = c->headers; hi; hi = hi->next )
	{
	    /* Make sure duplicate headers only go in once (important in
	     * server-push case)
	     */
	    if ( stricmp( hi->key, key ) == 0 )
	    {
		mm_free( hi->value );
		hi->value = mm_strdup( value );
		return hi;
	    }
	}
    }

    hi = mm_malloc(sizeof(http_header_item));
    if (hi)
    {
        hi->key = mm_strdup(key);
        hi->value = mm_strdup(value);

        if (hi->key == NULL || hi->value == NULL)
        {
            if (hi->key)
                mm_free((char*)hi->key);
            if (hi->value)
                mm_free(hi->value);
            mm_free( hi );
            hi = NULL;
        }
    }

    if (hi)
    {
        hi->next = c->headers;
        c->headers = hi;
    }

    return hi;
}

void http_process_header_line(http_connection *c, char *l)
{
    char *p;

    fdebugf(log_file, "%p: rxheader '%s'\n", c, l);

    if ( !*l )
    {
        if ( c->nearlyboundary == -1 )
        {
            /* Nasty hack 'cos server-push starts off in the "wrong" state
             */
	    fdebugf( log_file, "%p: blank line 'cos of multipart\n", c );
            c->nearlyboundary = 0;
        }
        else
        {
            c->status = status_GETTING_BODY;

            fdebugf( log_file, "%p: entering getting_body state, sofar=%d size=%d total=%d\n", c, c->data_so_far, c->data_size, c->total_size );
        }
    }
    else
    {
        /* Try to split the the header line */

        /* pdh: i hate nph cgi's, they let people do stuff who are far too
         * clueless to get it right
         */
        while ( isspace(*l) )
            l++;

        p = strchr(l, ':');
        if (p != 0)
        {
            char *q;

            *p = 0;
            while (isspace(*(++p)))
                ;

            q = p + strlen(p);
            while ((q > p) && isspace(q[-1]))
                q--;
            *q = 0;

            if ( http_check_special_headers( c, l, p ) )
                http_add_header_line( c, l, p );
        }
        else
        {
            fdebugf(log_file, "Badly formed header line, no ':'\n");
        }
    }
}


/*---------------------------------------------------------------------------*
 * http_set_server_flag                                                      *
 * We've just found out something that potentially affects how everyone      *
 * talks to this server, so tell everyone about it                           *
 *---------------------------------------------------------------------------*/

static void http_set_server_flag( http_connection *c, int flag )
{
    http_connection *c2 = http_cons_list;

    while ( c2 )
    {
        if ( !memcmp( &c->sa, &c2->sa, sizeof( struct sockaddr_in ) ) )
        {
	    fdebugf(log_file, "set_server_flag: c%p flags %x\n", c2, flag);

            c2->flags |= flag;
            if ( c2->queue )
                c2->queue->flags |= flag;
        }
        c2 = c2->next;
    }
}

void http_process_response_line(http_connection *c, char *l)
{
    fdebugf(log_file, "%p: received '%s'\n",  c, l);

    if (strncmp(l, http_version_check, strlen(http_version_check)) == 0)
    {
        char *p;

        p = strchr(l, ' ');
        if ( !p )
            p = l;

        while (isspace(*(++p)))
            ;
        c->rc = atoi(p);

        p += 2;
        while (isspace(*(++p)))
            ;
        http_set_message( c, p );
        fdebugf(log_file, "%p: response %d '%s'\n", c, c->rc, c->message ? c->message
                                                            : "<no message>");

        if ( (c->flags & http_flags_HTTP11) == 0
             && !strncmp( l+5, "1.1", 3 ) )
        {
            http_set_server_flag( c, http_flags_HTTP11 );
        }

        http_set_status( c, status_GETTING_HEADERS );
    }
    else
    {
        /* Either it's HTTP/0.9 or it's just not playing the game */
        fdebugf(log_file, "Badly formed response line (HTTP/0.9 server?)\n");

        c->rc = 200;
        http_set_message( c, "Badly formed response; continuing anyway." );
        http_set_status( c, status_GETTING_BODY );

        /* It's 0.9 so there's no way it's doing keep-alive... */
        http_orphan_queue( c );

        /* Squeeze this line back in the buffer so it can get flushed out */
        c->buffer[c->buf_used-1] = '\n';
        if (c->buffer[c->buf_used-2] == 0)
            c->buffer[c->buf_used-2] = '\r';
        c->buf_used = 0;
    }
}

void http_flush_data_to_file(http_connection *c)
{
    /* NB. Contrary to a previous comment here, the flush is *NOT* always for
     * the initial data (in the case of a Partial Content reply)
     */

    if ( c->data_so_far == -1 )
    {
        fdebugf( log_file, "%p: setting so_far=0 in flush\n", c );
        c->data_so_far = 0;
    }

    if (c->fh && (c->buf_off != c->buf_used))
    {
        int n;
        int wrote;

        n = c->buf_off - c->buf_used;

        fdebugf( log_file, "%p: trying to flush %d bytes\n", c, n );

        wrote = ro_fwritepos( c->buffer + c->buf_used, 1, n, c->fh,
                              c->data_so_far);
        if ( wrote < n )
        {
            http_oserror( c, ro_ferror() );
            return;
        }

        c->buf_off = c->buf_used = 0;
        c->data_so_far += n;
        fdebugf( log_file, "%p: flushed %d bytes of body (so_far=%d)\n", c, n,
                           c->data_so_far );
    }
}


/*---------------------------------------------------------------------------*
 * http_queue_dec_nsockets                                                   *
 * Decrement the number of sockets registered as belonging to the queue.     *
 * This is used in socket_close, when the socket is going away altogether,   *
 * and also in orphan_queue, when the socket isn't going away, but doesn't   *
 * belong to this queue any more.                                            *
 *     Care is needed to stop this being called twice on any given socket:   *
 * socket_close sets c->socket to -1 and orphan_queue sets c->queue to       *
 * NULL, both of which act to prevent double decrementing.                   *
 *---------------------------------------------------------------------------*/

void http_queue_dec_nsockets( http_connection *c )
{
    if ( c->socket != -1 )
    {
        http_queue *q = c->queue;
        if ( q )
        {
            q->nsockets--;
            fdebugf( log_file, "%p: decrementing queue %p's nsockets to %d\n",
                     c, q, q->nsockets );
            if ( q->nsockets == 0 )
            {
                if ( q->queue )
                {
                    fdebugf( log_file, "%p: *** ERROR queue %p being freed with connection %p still on it\n", c, q, q->queue );
                }

                fdebugf( log_file, "%p: freeing queue %p\n", c, q );

                if ( q->prev )
                    q->prev->next = q->next;
                else
                    http_queues_list = q->next;

                if ( q->next )
                    q->next->prev = q->prev;

                mm_free( q );

                c->queue = NULL;

                if ( c->queuenext )
                    c->queuenext->queue = NULL;
            }
            /* We *don't* set c->queue to NULL here (unless the queue has
             * vanished), as this messes up the requeue case. Setting c->queue
             * to NULL is orphan_queue's job.
             */
        }
    }
}

void http_socket_close(http_connection *c)
{
    if (c->socket != -1)
    {
#ifndef NO_SECURE
	if ( c->SSL != NULL )
	{
	    fdebugf( log_file, "Closing SSL connection\n" );
	    client_cert_cleanup( c->SSL );

	    SSL_free( c->SSL );
	    c->SSL = NULL;
	}
#endif

        totalsockets--;

        fdebugf( log_file, "%p: closing socket %d (%d left)\n", c, c->socket,
                 totalsockets );

        http_queue_dec_nsockets( c );

/*        http_cons[c->socket] = NULL; */

        socket_close(c->socket);
        c->socket = -1;

        if ( c->queuenext )
        {
            fdebugf( log_file, "%p: pipelined connection %p is stuffed too\n",
                               c, c->queuenext );
            c->queuenext->socket = -1;
        }
    }
}


/*---------------------------------------------------------------------------*
 * http_check_special_headers()                                              *
 * Returns TRUE if it's okay to pass this header on to the client            *
 *---------------------------------------------------------------------------*/

BOOL http_check_special_headers( http_connection *c, char *key, char *value )
{
    if (stricmp(key, "CONTENT-LENGTH") == 0)
    {
        int s;
        s = atoi(value);

        /* pdh 05-Mar-98: changed to >= */
        if (s >= 0)
        {
            /* When getting a partial content, this size is the size of
             * the range, *not* of the whole file. When getting the first
             * part of an image, we want c->data_size to be 256 so that the
             * GETTING_BODY state terminates; however, when getting the second
             * half, we definitely want it to be right.
             */
            if ( c->data_size == -1 )
            {
                c->data_size = s;

                /* RISC OS will give us a random size */
                if ( c->fh )
                {
                    if (ro_set_extent(c->fh, c->data_size) < 0)
		    {
                        http_oserror( c, ro_ferror() );
			return TRUE;
		    }

		    fdebugf(log_file, "%p: closing %d to reopen to set size\n", c, c->fh);
		    ro_fclose(c->fh);
		    c->fh = ro_fopen(c->fname, RO_OPEN_RW);
                }
            }
            else
            {
                char realsize[20];

                if ( s == c->total_size
                     || c->total_size == 0 )
                {
                    fdebugf( log_file, "%p: passing on %s header\n",
                             c, key );
                    return TRUE;    /* OK to pass it on */
                }

                /* Not OK, it's the length of this transaction, so fake up a
                 * header that's the length of the whole lot.
                 */
                sprintf( realsize, "%d", c->total_size );
                http_add_header_line( c, key, realsize );
                fdebugf( log_file, "%p: brewing up fake header %s: %s\n",
                         c, key, realsize );

                return FALSE;
            }
        }
    }
    else if ( stricmp( key, "CONNECTION" ) == 0 )
    {
        char *p = value;

        while ( p )
        {
            if ( prefixcmp( p, "CLOSE" ) == 0 )
            {
                c->flags &= ~http_flags_KEPTALIVE;
                c->flags |= http_flags_NOTALIVE;
                http_orphan_queue( c );
            }

            if ( (allow & http_config_ALLOW_KEEPALIVE) && prefixcmp( p, "KEEP-ALIVE" ) == 0 )
            {
                c->flags |= http_flags_KEPTALIVE;

                if ( !(c->flags & http_flags_DOESKEEPALIVE ) )
                    http_set_server_flag( c, http_flags_DOESKEEPALIVE );
            }

            p = strchr( p, ',' );
            if ( p )
            {
                p++;
                while ( isspace( *p ) )
                    p++;
            }
        }
    }
    else if ( stricmp( key, "TRANSFER-ENCODING" ) == 0
         && stricmp( value, "CHUNKED" ) == 0 )
    {
        c->flags |= http_flags_CHUNKED;
    }
    else if ( stricmp( key, "CONTENT-TYPE" ) == 0
              && ( prefixcmp( value, "MULTIPART/X-MIXED-REPLACE" ) == 0
                   || prefixcmp( value, "MULTIPART/X-BYTERANGES" ) == 0 ) )
    {
        /* Oooh, it's server push. Now the fun really starts. */

        /* Actually we must cope with multipart byteranges as well, as at
         * least one server (WebSitePro/1.1f) returns all this mime junk even
         * if we've only asked for *one* byte range -- this is not as per spec!
         */

        /* 25/4/97: No, it's worse than that. At least one server (the
         * succinctly-named Open-Market-Secure-WebServer/2.0.12/RC0) returns
         * mime junk and *doesn't tell us the total size* -- this is useless
         * and means we must rerequest the whole image.
         */

        char *p = strchr( value, ';' );

        if ( prefixcmp( value, "MULTIPART/X-BYTERANGES" ) == 0
             && c->total_size == 0 )
        {
            /* Nothing we can do. Restart the request and bear a grudge
             * against this server in future.
             */
            http_set_server_flag( c, http_flags_RANGEBROKEN );
            fdebugf( log_file, "%p: BYTE RANGES ARE BROKEN\n", c );

	    /* SJM: 30/4/98 Added the requeue and return */
	    c->data_so_far = c->buf_off = c->buf_used = 0;
	    c->data_size = -1;
		
	    http_requeue(c);
	    return FALSE;
        }

        if ( p )
        {
            p++;
            while ( isspace(*p) )
                p++;
            if ( prefixcmp( p, "BOUNDARY" ) == 0 )
            {
                p = strchr( p, '=' );

                if ( p )
                {
                    p++;
                    while ( isspace(*p) )
                        p++;

                    c->boundary = mm_malloc( strlen(p)+3 );

                    if ( c->boundary )
                    {
                        strcpy( c->boundary, "--" );
                        strcat( c->boundary, p );
                        c->flags &= ~http_flags_KEPTALIVE;
                        c->flags |= http_flags_NOTALIVE;

                        c->nearlyboundary = -1; /* magic value */

                        fdebugf(log_file, "%p: server push, boundary is '%s'"
                                           " total_size is %d\n",
                                c, c->boundary, c->total_size );

                        /* client doesn't see this header (important for
                         * set_file_type to work)
                         */
                        return FALSE;
                    }
                }
            }
        }
    }
    else if ( stricmp( key, "CONTENT-RANGE" ) == 0 )
    {
        int from,to,total;

        /* Cope with both "bytes=aa-bb/cc" and "aa-bb/cc"
         */

        if ( !isdigit( *value ) )
            value += 6;

        sscanf( value, "%d-%d/%d", &from, &to, &total );

        fdebugf( log_file, "%p: Bytes %d to %d inclusive of a total of %d\n",
                            c, from, to, total );

        /* RISC OS will give us a random size */
        if ( c->fh && !c->total_size )
        {
            fdebugf( log_file, "%p: setting extent (2) to %d\n", c, total );
            if (ro_set_extent(c->fh, total) < 0)
	    {
		http_oserror( c, ro_ferror() );
		return TRUE;
	    }
            ro_fclose(c->fh);
            c->fh = ro_fopen(c->fname, RO_OPEN_RW);
        }

        c->total_size = total;

        if ( to == total-1 )
        {
            /* Second half of a transfer */
            c->data_size = total;
        }
        else
        {
            /* First half of a transfer */
            c->flags |= http_flags_GOTFIRST;
        }

        if ( !(c->flags & http_flags_DOESRANGE ) )
            http_set_server_flag( c, http_flags_DOESRANGE );

        /* If we've had one of these, we'd best have had Content-Length
         * as well, or else.
         */
        return FALSE;   /* don't pass on to client */
    }
    return TRUE;    /* pass on to client */
}

#ifndef NO_SECURE
int cert_verify_callback( int ok, X509 *xs, X509 *xi, int depth, int error)
{
    fdebugf( log_file, "cert_verify_callback: ok %d xs %p xi %p depth %d error %d", ok, xs, xi, depth, error );
    
    if ( !ok )
    {
        if ( depth >= CERT_VERIFY_DEPTH )
            ok=1;
        else
            verify_error = TRUE;
    }

    return(ok);
}
#endif

static void http_close_and_reopen_socket(http_connection *c)
{
    /* Don't let socket_close delete the queue! */
    if ( c->queue )
	c->queue->nsockets++;

    http_socket_close( c );

    c->flags &= ( http_open_flags_ALLUSER | http_flags_SERVER
		  | http_flags_GOTFIRST );
	
    http_open_socket( c );
	
#if 1
    /* SJM: zero various values in case data had been part read before we restarted the fetch */
    c->data_so_far = 0;
    c->buf_off = 0;
    c->buf_used = 0;
#endif

    if ( c->queue )
	c->queue->nsockets--;
}

/* eof http.c */
