/* > client.c

 * Client certificate code

 */

#include <stdlib.h>
#include <string.h>

#include "http.h"

#ifndef NO_SECURE

#if FLAVOUR_PKCS11
# include "rsa_id2.h"
#endif

#define NO_UI	0		/* define this to 1 if the browser support isn't available */

/* ------------------------------------------------------------------------- */

extern char *strdup(const char *s);
extern int X509v3_get_key_usage(X509 *x); /* For some reason this isn't in x509.h */

/* ------------------------------------------------------------------------- */

#if FLAVOUR_PKCS11
static BOOL cryptobox_init = FALSE;
#endif /* FLAVOUR_PKCS11 */

/* ------------------------------------------------------------------------- */

#if FLAVOUR_PKCS11
# define INVALID_SLOT		((CK_SLOT_ID)0xFFFFFFFF)
# define AUTHENTICATION_MASK	"Authentication"
#endif /* FLAVOUR_PKCS11 */

typedef enum
{
    state_ERROR,
    state_UNSET,
    state_TOKEN_REQUIRED,
    state_CERT_CHOICE_REQUIRED,
    state_CERT_CHOICE_GIVEN,
    state_PIN_REQUIRED,
    state_LOGGED_IN,
    state_GOT_PKEY,
    state_CANCELLED,
    state_REMOVED
} certop_state;

#if DEBUG
static char *states[] =
{
    "ERROR",
    "UNSET",
    "TOKEN_REQUIRED",
    "CERT_CHOICE_REQUIRED",
    "CERT_CHOICE_GIVEN",
    "PIN_REQUIRED",
    "LOGGED_IN",
    "GOT_PKEY",
    "CANCELLED"
};
# define STATE(a) states[a]
#else
# define STATE(a) ""
#endif

typedef enum
{
    transition_NONE,
    transition_TOKEN_GIVEN,
    transition_CERT_CHOSEN,
    transition_TOKEN_REMOVED,
    transition_PIN_ENTERED,
    transition_CANCEL
} certop_transition;

#if DEBUG
static char *transitions[] =
{
    "NONE",
    "TOKEN_GIVEN",
    "CERT_CHOSEN",
    "TOKEN_REMOVED",
    "PIN_ENTERED",
    "CANCEL"
};
# define TRANSITION(a) transitions[a]
#else
# define TRANSITION(a) ""
#endif

/* ------------------------------------------------------------------------- */

/* internal certificate structure */
typedef struct http_cert_info http_cert_info;
typedef struct http_cert_context http_cert_context;

/* There are one of these structures for each certificate found on the
 * token during the client certificate callback.  */

struct http_cert_info
{
    http_cert_info *next;	/* link to next certificate in chain */

    char *data;			/* certificate data, no termination */
    size_t data_len;
    
    char *id;			/* id string used to match certs and keys, no termination */
    size_t id_len;
    
    char *label;		/* text label to present to the user, no termination */
    size_t label_len;

    char *descr;		/* null-terminated */

    X509 *x509;			/* x509 structure version of 'data' used when file-based */

#if FLAVOUR_PKCS11
    CK_OBJECT_HANDLE key_object; /* key object from the token that matches this cert */
#endif
};

/* One of these context structures is created when the client cert
 * callback is first called and attached to the SSL connection
 * structure. */

struct http_cert_context
{
    http_cert_info *cert_list;	/* head of list of certificates */

#if FLAVOUR_PKCS11
    CK_SLOT_ID slot;		/* slot on token being used */
    CK_SESSION_HANDLE session;	/* open session handle used for all Cryptki calls*/
#endif /* FLAVOUR_PKCS11 */
    int need_to_logout;		/* did we have to log in ourselves to access the token? */
    int which_cert;		/* index of certificate chosen by user */

    certop_state state;		/* current state */
#if FLAVOUR_PKCS11
    CK_RV last_rv;
#endif /* FLAVOUR_PKCS11 */

    STACK *CA_list;		/* [] X509_NAME * really */
    
    int use_cryptobox;
    int token_count;
    int pin_count;
    int threaded;
    certop_transition pending_transition;

    /* when we've successfully read a pair then cache them here */
/*  X509 *client_x509; */
    EVP_PKEY *client_pkey;
};

/* ------------------------------------------------------------------------- */

static http_cert_context *cert__ctx = NULL;

/* ------------------------------------------------------------------------- */

#if DEBUG
static void save_cert(const http_cert_info *cert, const char *file_name)
{
    int fh = ro_fopen( file_name, RO_OPEN_WRITE );
    if (fh)
    {
	ro_fwrite(cert->data, cert->data_len, 1, fh);
	ro_fclose(fh);
    }
}

static void dump_cert(const http_cert_info *cert)
{
    unsigned char *pp = (unsigned char *)cert->data;
    X509 *x509 = d2i_X509(NULL, &pp, cert->data_len);
    char *s;

    fdebugf( log_file, "dump_cert: subject '%s'\n", x509->name );

    s = X509_NAME_oneline(X509_get_issuer_name(x509), NULL, 0);
    fdebugf( log_file, "dump_cert: issuer  '%s'\n", s );
    mm_free(s);
					 
    X509_free(x509);
}

static void dump_name_stack(STACK *sk)
{
    int i;
    fdebugf( log_file, "dump_name_stack: n=%d\n", sk->num );
    for (i = 0; i < sk->num; i++)
    {
	char *s = X509_NAME_oneline((X509_NAME *)sk->data[i], NULL, 0);
	fdebugf( log_file, "dump_name_stack: '%s'\n", s );
	mm_free(s);
    }
}
#else
# define dump_name_stack(sk)
#endif /* DEBUG */

static void cert_free( http_cert_info *cert )
{
    fdebugf( log_file, "cert_free: %p\n", cert );

    mm_free(cert->data);
    mm_free(cert->descr);
    mm_free(cert->id);
    mm_free(cert->label);

    if (cert->x509)
	X509_free(cert->x509);
    
    mm_free(cert);
}

/* ------------------------------------------------------------------------- */

static char *extract_name(const char *dn, const char *field)
{
    char *s, *s1, *s2;
    char *descr = NULL;

    s = mm_strdup(dn);

    if ((s1 = strstr(s, field)) != NULL)
    {
	/* inc past the match string */
	s1 += strlen(field);
	
	/* search for the end of this substring */
	s2 = strchr(s1, '/');
	if (s2)
	    *s2 = 0;

	descr = mm_strdup(s1);
    }

    mm_free(s);

    return descr;
}

static char *cert_get_description(X509 *x509)
{
    char *name;

    /* extract individual subject item */
    if ((name = extract_name(x509->name, "/S=")) == NULL)
	name = extract_name(x509->name, "/CN=");

    return name;
}

static int cert_check_usage(X509 *x509, STACK *CA_list)
{
    BOOL add = FALSE;
    int dsig;

    if (x509 == NULL)
	return FALSE;

    fdebugf( log_file, "cert_list_get: keyUsage %d\n", X509v3_get_key_usage( x509 ) );

    /* check for digitalSignature keyUsage bit - default to TRUE if not present */
    dsig = X509v3_get_key_usage( x509 ) & X509v3_KU_DIGITAL_SIGNATURE ? 1 : 0;

    if (dsig)
    {
	X509_NAME *issuer = X509_get_issuer_name( x509 ); /* returns pointer to existing issuer field */
				
	/* check for matching CA name - allow through if there are no names in the list */
	fdebugf( log_file, "cert_list_get: check CA_list\n");
				
	if ( CA_list == NULL || sk_find( CA_list, (char *)issuer ) != -1 )
	{
	    add = TRUE;
	}
	else
	{
	    fdebugf( log_file, "cert CA not in server list\n");
	}
    }
    else
    {
	fdebugf( log_file, "DigitalSignature usage bit not set\n");
    }

    return add;
}

static http_cert_info *cert_lookup( http_cert_info *cert_list, int index)
{
    int i;
    http_cert_info *cert;
    for (i = 0, cert = cert_list; i < index && cert; i++, cert = cert->next)
	;
    return cert;
}

/* Write out the certificate descriptions in order to the buffer
 * given. Stop writing when there is no room but continue decrementing
 * buf_len anyway */

static int cert_write( const http_cert_info *cert_list, char *buf, int buf_len, int *n_certs)
{
    int i, size_required, written;
    const http_cert_info *cert;

    for (i = 0, size_required = 0, written = 0, cert = cert_list;
	 cert;
	 i++, cert = cert->next)
    {
	int descr_len;		/* length without termination */
	char descr[32], *pdescr;

	/* if there is no descr then construct a temporary one */
	if (cert->descr)
	{
	    pdescr = cert->descr;
	    descr_len = strlen(pdescr);
	}
	else
	{
	    pdescr = descr;
	    descr_len = sprintf(descr, "Certificate %d", i+1);
	}

	/* if there is room then write in the descr string and
	 * null-terminate it */
	if (buf && (size_required + descr_len + 1 < buf_len))
	{
	    memcpy(buf + size_required, pdescr, descr_len);
	    buf[size_required + descr_len] = 0;
	    written += descr_len + 1;
	}

	size_required += descr_len + 1;
    }

    if (n_certs)
	*n_certs = i;
    
    return buf ? written : size_required;
}

static void cert_list_free( http_cert_info **pcert_list )
{
    http_cert_info *head = *pcert_list;

    fdebugf( log_file, "cert_list_free: %p\n", head );

    while (head)
    {
	http_cert_info *next = head->next;

	cert_free(head);

	head = next;
    }
    *pcert_list = NULL;
}

#if FLAVOUR_PKCS11
static CK_RV cert_list_get( CK_SESSION_HANDLE hSession, const char *label_mask, STACK *CA_list, http_cert_info **pcert_list)
{
    CK_RV rv, rv2;

    CK_ATTRIBUTE scan_attributes[1];
    CK_ULONG scan_count;
    CK_ULONG scan_val;
    CK_OBJECT_HANDLE hObjects[10];
	    
    http_cert_info *cert_list = NULL;

    fdebugf( log_file, "cert_list_get: session %lx\n", hSession );

    /* scan for certificates */
    scan_attributes[0].type = CKA_CLASS;
    scan_val = CKO_CERTIFICATE;
    scan_attributes[0].pValue = &scan_val;
    scan_attributes[0].ulValueLen = sizeof(scan_val);

    if ((rv = C_FindObjectsInit(hSession, scan_attributes,
				sizeof(scan_attributes) / sizeof(scan_attributes[0]) )) != CKR_OK)
    {
	fdebugf(log_file, "Failed to init find operation, rv = 0x%lx\n", rv);
	return rv;
    }

    scan_count = 0;			/* number of objects returned by call. Set to 0 when finished */
    do
    {
	/* get a batch of certs */
	fdebugf( log_file, "cert_list_get: get batch of certs scan_count=%ld\n", scan_count );

	if ((rv = C_FindObjects(hSession, hObjects, sizeof(hObjects) / sizeof(hObjects[0]), &scan_count)) != CKR_OK)
	{
	    fdebugf(log_file, "Failed to find objects, rv = 0x%lx\n", rv);
	}
	else
	{
	    /* search for the right key object */
	    int i;
	    for (i = 0; i < scan_count; i++)
	    {
		CK_ATTRIBUTE cert_attributes[3];

		cert_attributes[0].type	= CKA_VALUE;
		cert_attributes[0].pValue = NULL_PTR;
		cert_attributes[0].ulValueLen = 0;

		cert_attributes[1].type	= CKA_LABEL;
		cert_attributes[1].pValue = NULL_PTR;
		cert_attributes[1].ulValueLen = 0;

		cert_attributes[2].type	= CKA_ID;
		cert_attributes[2].pValue = NULL_PTR;
		cert_attributes[2].ulValueLen = 0;

		if ((rv = C_GetAttributeValue(hSession, hObjects[i], cert_attributes,
					      sizeof(cert_attributes) / sizeof(cert_attributes[0]))) != CKR_OK)
		{
		    fdebugf(log_file, "Failed to get cert attributes, rv = 0x%lx\n", rv);
		}
		else if (cert_attributes[0].ulValueLen == CK_UNAVAILABLE_INFORMATION)
		{
		    fdebugf( log_file, "get_cert_list: data_len %ld\n", cert_attributes[0].ulValueLen );
		}
		else
		{
		    http_cert_info *cert = mm_calloc( sizeof(*cert), 1 );
		    BOOL add = FALSE;

		    fdebugf( log_file, "get_cert_list: data_len %ld label_len %ld id_len %ld\n",
			     cert_attributes[0].ulValueLen, cert_attributes[1].ulValueLen, cert_attributes[2].ulValueLen );

		    if (cert)
		    {
			cert->data_len = (size_t)cert_attributes[0].ulValueLen;
			cert_attributes[0].pValue = cert->data = mm_malloc( cert->data_len );

			if (cert_attributes[1].ulValueLen != CK_UNAVAILABLE_INFORMATION)
			{
			    cert->label_len = (size_t)cert_attributes[1].ulValueLen;
			    cert_attributes[1].pValue = cert->label = mm_malloc( cert->label_len );
			}

			if (cert_attributes[2].ulValueLen != CK_UNAVAILABLE_INFORMATION)
			{
			    cert->id_len = (size_t)cert_attributes[2].ulValueLen;
			    cert_attributes[2].pValue = cert->id = mm_malloc( cert->id_len );
			}

			if ((rv = C_GetAttributeValue(hSession, hObjects[i], cert_attributes,
						      sizeof(cert_attributes) / sizeof(cert_attributes[0]))) != CKR_OK)
			{
			    fdebugf( log_file, "Failed to get cert attributes, rv = 0x%lx\n", rv);
			}
			/* Compare label with a mask string. The label
                           length is known and the mask string will be
                           terminated. */
			else if (label_mask && cert->label && strncmp(cert->label, label_mask, cert->label_len) != 0)
			{
			    fdebugf( log_file, "Label didn't match - ignoring (%s)\n", cert->label);
			}
			else
			{
			    unsigned char *pp = (unsigned char *)cert->data;
			    X509 *x509 = d2i_X509(NULL, &pp, cert->data_len);
#if DEBUG
			    dump_cert(cert);
#endif
			    add = cert_check_usage(x509, CA_list);
			    if (add)
				cert->descr = cert_get_description(x509);

			    X509_free(x509);
			}
			
			if (add)
			{
			    /* add to list */
			    cert->next = cert_list;
			    cert_list = cert;

			    fdebugf( log_file, "cert_list_get: got %p (label '%.*s' [%d] id '%.*s' [%d] ) subject '%s'\n",
				     cert,
				     cert->label_len, cert->label, cert->label_len,
				     cert->id_len, cert->id, cert->id_len,
				     cert->descr );
			}
			else
			{
			    cert_free( cert );
			    cert = NULL;
			}
		    }
		}
	    }
	}
    }
    while (scan_count == sizeof(hObjects)/sizeof(hObjects[0]) && rv == CKR_OK);
    
    if ((rv2 = C_FindObjectsFinal(hSession)) != CKR_OK)
    {
	fdebugf(log_file, "Failed to final find operation, rv = 0x%lx\n", rv2);

	cert_list_free(&cert_list);
	rv = rv2;
    }

    fdebugf( log_file, "cert_list_get: got %p\n", cert_list );

    *pcert_list = cert_list;

    return rv;
}

/* ------------------------------------------------------------------------- */

static CK_RV get_slot(CK_SLOT_ID_PTR pSlot)
{
    CK_RV rv;
    CK_ULONG SlotCount;
    CK_SLOT_ID_PTR pSlotList;
    
    fdebugf( log_file, "get_slot: \n" );

    /* get list of available, and filled, slots in a safe fashion,
     * remembering that theoretically they could change between
     * calls. */
    SlotCount = 3;
    pSlotList = mm_malloc((size_t)SlotCount * sizeof(CK_SLOT_ID));
    do
    {
	rv = C_GetSlotList( TRUE, pSlotList, &SlotCount );

	fdebugf( log_file, "get_slot: rv 0x%lx pSlotList %p SlotCount %ld\n", rv, pSlotList, SlotCount );

	if (rv == CKR_BUFFER_TOO_SMALL)
	{
	    mm_free(pSlotList);
	    pSlotList = mm_malloc((size_t)SlotCount * sizeof(CK_SLOT_ID));
	}
    }
    while (rv == CKR_BUFFER_TOO_SMALL);

    fdebugf( log_file, "get_slot: rv 0x%lx pSlotList %p SlotCount %ld -- end\n", rv, pSlotList, SlotCount );

    /* see which is suitable (HW slot)*/
    *pSlot = INVALID_SLOT;
    if (rv == CKR_OK)
    {
	int i;
	for (i = 0; rv == CKR_OK && i < SlotCount && *pSlot == INVALID_SLOT; i++)
	{
	    CK_SLOT_INFO slotinfo;

	    fdebugf( log_file, "get_slot: %d slot id %ld \n", i, pSlotList[i] );
	    
	    if ((rv = C_GetSlotInfo(pSlotList[i], &slotinfo)) == CKR_OK)
	    {
		fdebugf( log_file, "get_slot: %d '%.*s' flags 0x%lx \n", i, sizeof(slotinfo.slotDescription), slotinfo.slotDescription, slotinfo.flags );

		if ((slotinfo.flags & (CKF_HW_SLOT|CKF_TOKEN_PRESENT)) == (CKF_HW_SLOT|CKF_TOKEN_PRESENT))
		{
		    *pSlot = pSlotList[i];
		}
	    }
	}
    }

    fdebugf( log_file, "get_slot: %ld rv 0x%lx\n", *pSlot, rv );

    free(pSlotList);

    return rv;
}

/* ------------------------------------------------------------------------- */

static CK_RV get_private_key( CK_SESSION_HANDLE sess, const char *id, int id_len, CK_OBJECT_HANDLE *phKeyObject)
{
    CK_RV rv, rv2;
    CK_ATTRIBUTE attributes[2];
    CK_ULONG count;
    CK_ULONG ul2;
    CK_ULONG ul3;
    CK_OBJECT_HANDLE hKeyObject;
    CK_OBJECT_HANDLE hObjects[10];

    fdebugf(log_file, "get_private_key for id %.*s\n", id_len, id);
    
    /* set template for RSA private keys */
    attributes[0].type       = CKA_CLASS;
    ul2 = CKO_PRIVATE_KEY;
    attributes[0].pValue     = &ul2;
    attributes[0].ulValueLen = sizeof(ul2);

    attributes[1].type       = CKA_KEY_TYPE;
    ul3 = CKK_RSA;
    attributes[1].pValue     = &ul3;
    attributes[1].ulValueLen = sizeof(ul3);

    if ((rv = C_FindObjectsInit(sess, attributes, 2)) != CKR_OK)
    {
	/* LOGOUT?? */
	fdebugf(log_file, "Failed to init find operation, rv = 0x%lx\n", rv);
	return rv;
    }

    /* look at all RSA private key objects for the right one this look
     * sets hKeyObject when it finds it. */
    count = 0;			/* number of objects returned by call. Set to 0 when finished */
    hKeyObject = 0;
    do
    {
	fdebugf(log_file, "get batch, count=%ld\n", count);

	/* get a batch of keys */
	if ((rv = C_FindObjects(sess, hObjects, sizeof(hObjects) / sizeof(hObjects[0]), &count)) != CKR_OK)
	{
	    fdebugf(log_file, "Failed to find objects, rv = 0x%lx\n", rv);
	}
	else
	{
	    /* search for the right key object */
	    int i;
	    for (i = 0; i < count; i++)
	    {
		CK_BYTE buf_id[128];
		CK_ATTRIBUTE key_attributes[1];

		memset(buf_id, 0, sizeof(buf_id));
		key_attributes[0].type       = CKA_ID;
		key_attributes[0].pValue     = buf_id;
		key_attributes[0].ulValueLen = sizeof(buf_id);

		/* if we can't get the attribute for this object then
                   ignore the error, if it was a device error then the
                   next call to FindObjects[Final] will pick it up. */
		if ((rv2 = C_GetAttributeValue(sess, hObjects[i],
					       key_attributes, sizeof(key_attributes)/sizeof(key_attributes[0]))) != CKR_OK)
		{
		    fdebugf(log_file, "Failed to get value attribute i=%d (CKA_ID), rv = 0x%lx\n", i, rv2);
		}
		else
		{
		    /* see if the id matches the one we got from the certificate */
		    fdebugf(log_file, "CKA_ID='%.*s'\n", (int)attributes[0].ulValueLen, buf_id);

		    if (id_len == key_attributes[0].ulValueLen &&
			memcmp(buf_id, id, id_len) == 0)
		    {
			hKeyObject = hObjects[i];
		    }
		}
	    }
	}
    }
    while (count == sizeof(hObjects)/sizeof(hObjects[0]) && hKeyObject == 0 && rv == CKR_OK);
    
    if ((rv2 = C_FindObjectsFinal(sess)) != CKR_OK)
    {
	fdebugf(log_file, "Failed to final find operation, rv = 0x%lx\n", rv2);
    }

    *phKeyObject = hKeyObject;
    
    return rv != CKR_OK ? rv : rv2;
}
#endif /* FLAVOUR_PKCS11 */

/* ------------------------------------------------------------------------- */

static http_cert_context *cert_context_create( void )
{
    http_cert_context *ctx;

    fdebugf( log_file, "cert_context_create:\n" );

    ctx = mm_calloc( sizeof(*ctx), 1 );
    if (ctx)
    {
	ctx->state = state_UNSET;

#if FLAVOUR_PKCS11
	/* try and initialise the cryptobox */
	if (!cryptobox_init)
	    cryptobox_init = (C_Initialize( NULL_PTR ) == CKR_OK);

	/* record whether we are going to use cryptobox with this context */
	ctx->use_cryptobox = cryptobox_init;
#endif /* FLAVOUR_PKCS11 */
    }

    fdebugf( log_file, "cert_context_create: ctx %p cryptobox %d\n", ctx, ctx ? ctx->use_cryptobox : 0 );

    return ctx;
}

static void cert_context_close( http_cert_context *ctx )
{
    fdebugf( log_file, "cert_context_close: ctx %p\n", ctx );

    if (ctx)
    {
	cert_list_free( &ctx->cert_list );

#if FLAVOUR_PKCS11
	if ( ctx->session )
	{
	    if ( ctx->need_to_logout )
	    {
		C_Logout( ctx->session );
		ctx->need_to_logout = FALSE;
	    }
	
	    C_CloseSession( ctx->session );
	    ctx->session = NULL;
	}

	ctx->slot = INVALID_SLOT;
	ctx->last_rv = CKR_OK;
#endif /* FLAVOUR_PKCS11 */
	
	ctx->state = state_REMOVED;

	ctx->token_count = 0;
	ctx->pin_count = 0;

#if 0
	/* get rid of cached values*/
	if (ctx->client_x509)
	{
	    X509_free(ctx->client_x509);
	    ctx->client_x509 = NULL;
	}
#endif

	if (ctx->client_pkey)
	{
	    EVP_PKEY_free(ctx->client_pkey);
	    ctx->client_pkey = NULL;
	}
    }
}

static void cert_context_free( http_cert_context *ctx )
{
    fdebugf( log_file, "cert_context_free: ctx %p\n", ctx );

    cert_context_close( ctx );
    mm_free(ctx);
}

/* ------------------------------------------------------------------------- */

#if FLAVOUR_PKCS11

extern RSA_METHOD *RSA_PKCS1_iD2( void );

/* This routine packages up all the data we've extracted from the card
 * and the user into a PKCSll_INFO structure and passes that back to
 * the SSL library so it can be used to handle the encryption stage */

static void build_return_values( const http_cert_context *ctx, const http_cert_info *cert,
				 X509 **x509, EVP_PKEY **pkey )
{
    RSA *rsa;
    PKCS11_INFO *info;
    unsigned char *pp;
    
    /* build an x509 certificate from the raw data pulled off the card */
    pp = (unsigned char *)cert->data;
    *x509 = d2i_X509(NULL, &pp, cert->data_len);

    /* build our private key structure, stores session handle and key
     * object handle */
    info = mm_calloc(sizeof(*info), 1);
    info->hSession = ctx->session;
    info->hKeyObject = cert->key_object;
    
    /* Create an RSA structure with our smartcard methods, and attach
     * the info we need to it as app data. Then create a private key
     * structure and assign the RSA structure to it. */
    rsa = RSA_new_method( RSA_PKCS1_iD2() );
    RSA_set_app_data(rsa, info);

    *pkey = EVP_PKEY_new();
    EVP_PKEY_assign_RSA(*pkey, rsa);

    fdebugf( log_file, "build_return_values: x509 %p pkey %p\n", *x509, *pkey );
}
#endif /* FLAVOUR_PKCS11 */

/* ------------------------------------------------------------------------- */

static void cert_list_load(STACK *CA_list, http_cert_info **pcert_list)
{
    FILE *f;
    char *cert_file;

    /* quick return if client var not defined */
    cert_file = getenv(HTTP_CLIENT_CERT_VAR);
    if (!cert_file || cert_file[0] == 0)
	return;

    cert_file = mm_strdup(cert_file);

    fdebugf(log_file, "cert_list_load: cert_file '%s'\n", cert_file ? cert_file : "");
    
    if ((f = fopen(cert_file, "rb")) != NULL)
    {
	X509 *x509;
	
	while ((x509 = PEM_read_X509(f, NULL, 0)) != NULL)
	{
	    BOOL add = cert_check_usage(x509, CA_list);
	    if (add)
	    {
		http_cert_info *cert = mm_calloc( sizeof(*cert), 1 );

		cert->x509 = x509;
		cert->descr = cert_get_description(x509);

		cert->next = *pcert_list;
		*pcert_list = cert;

		fdebugf(log_file, "client_cert_load: cert %p\n", x509);
	    }
	    else
	    {
		X509_free(x509);
	    }
	}
	
	fclose(f);
    }

    mm_free(cert_file);

    return;
}

static int private_key_load(EVP_PKEY **pkey)
{
    FILE *f;
    char *key_file;

    /* quick return if client var not defined */
    key_file = getenv(HTTP_CLIENT_KEY_VAR);
    if (!key_file || key_file[0] == 0)
	key_file = getenv(HTTP_CLIENT_CERT_VAR);

    key_file = mm_strdup(key_file);

    fdebugf(log_file, "client_key_load: key_file '%s'\n", key_file ? key_file : "");
    
    if ((f = fopen(key_file, "rb")) != NULL)
    {
	*pkey = PEM_read_PrivateKey(f, NULL, 0);
	fclose(f);
    }

    fdebugf(log_file, "client_key_load: key %p\n", *pkey);

    mm_free(key_file);

    return TRUE;
}

/* ------------------------------------------------------------------------- */

static void set_state( http_cert_context *ctx, certop_state state )
{
    ctx->state = state;
}

/* ------------------------------------------------------------------------- */

static void select_state_with_cert_list( http_cert_context *ctx )
{
    /* select next state */
    if (ctx->cert_list == NULL)
    {
	set_state(ctx, state_ERROR);
    }
    else if (ctx->cert_list->next != NULL || (allow & http_config_ONE_CERT_PROMPT) != 0)
    {
	set_state(ctx, state_CERT_CHOICE_REQUIRED);
    }
    else
    {
	set_state(ctx, state_CERT_CHOICE_GIVEN);
    }
}

static void process_token_given( http_cert_context *ctx )
{
    /* free previous list, if any */
    cert_list_free( &ctx->cert_list );

#if FLAVOUR_PKCS11
    if (ctx->use_cryptobox)
    {
	CK_RV rv;
    
	fdebugf( log_file, "process_token_given: ctx %p\n", ctx );

	if ((rv = get_slot(&ctx->slot)) == CKR_OK)
	{
	    if (ctx->slot != INVALID_SLOT)
	    {
		ctx->token_count ++;

		if ((ctx->session != NULL || (rv = C_OpenSession(ctx->slot, CKF_SERIAL_SESSION, NULL, NULL, &ctx->session)) == CKR_OK) &&
		    (rv = cert_list_get(ctx->session, AUTHENTICATION_MASK, ctx->CA_list, &ctx->cert_list)) == CKR_OK)
		{
		    select_state_with_cert_list( ctx );
		}
		else
		{
		    /* Failure to open session */
		    switch (rv)
		    {
		    case CKR_DEVICE_REMOVED:
		    case CKR_TOKEN_NOT_PRESENT:
		    case CKR_TOKEN_NOT_RECOGNIZED:
			set_state(ctx, state_TOKEN_REQUIRED);
			break;

		    default:
			set_state(ctx, state_ERROR);
			break;
		    }
		}
	    }
	    else
	    {
		set_state(ctx, state_TOKEN_REQUIRED);
		rv = CKR_TOKEN_NOT_PRESENT;
	    }
	}
	else
	{
	    /* failure to read information about slots, v.serious */
	    set_state(ctx, state_ERROR);
	}

	ctx->last_rv = rv;
    
	fdebugf( log_file, "process_token_given: state %s rv 0x%lx\n", STATE(ctx->state), rv );
    }
    else
#endif  /* FLAVOUR_PKCS11 */
    {
	cert_list_load(ctx->CA_list, &ctx->cert_list);

	select_state_with_cert_list( ctx );
    }
}

static void process_cert_chosen( http_cert_context *ctx, http_certop_data_cert_chosen *data )
{
#if FLAVOUR_PKCS11
    CK_RV rv;
    CK_SESSION_INFO sess_info;
#endif /* FLAVOUR_PKCS11 */
    
    fdebugf( log_file, "process_cert_chosen: ctx %p\n", ctx );

    /* store the selected cert index */
    ctx->which_cert = data->index;
    
#if FLAVOUR_PKCS11
    if (ctx->use_cryptobox)
    {
	/* try and open a session */
	if ((rv = C_GetSessionInfo(ctx->session, &sess_info )) == CKR_OK)
	{
	    if (sess_info.state != CKS_RO_USER_FUNCTIONS)
		set_state(ctx, state_PIN_REQUIRED);
	    else
		set_state(ctx, state_LOGGED_IN);
	}
	else
	{
	    /* Failure to read session info */
	    switch (rv)
	    {
	    case CKR_DEVICE_REMOVED:
		set_state(ctx, state_TOKEN_REQUIRED);
		break;
		
	    default:
		set_state(ctx, state_ERROR);
		break;
	    }
	}

	ctx->last_rv = rv;

	fdebugf( log_file, "process_cert_chosen: state %s rv 0x%lx\n", STATE(ctx->state), rv );
    }
    else
#endif /* FLAVOUR_PKCS11 */
    {
	set_state(ctx, ctx->client_pkey ? state_GOT_PKEY : state_PIN_REQUIRED);
    }
}

static void process_pin_entered( http_cert_context *ctx, http_certop_data_pin_entered *data )
{
#if FLAVOUR_PKCS11
    CK_RV rv;
#endif /* FLAVOUR_PKCS11 */

    fdebugf( log_file, "process_pin_entered: ctx %p pin %.*s (%d)\n", ctx, data->pin_len, data->pin, data->pin_len );

    ctx->pin_count++;
    
#if FLAVOUR_PKCS11
    if (ctx->use_cryptobox)
    {
	/* try and login */
	if ((rv = C_Login(ctx->session, CKU_USER, (CK_CHAR_PTR)data->pin, data->pin_len )) == CKR_OK)
	{
	    ctx->need_to_logout = TRUE;

	    set_state(ctx, state_LOGGED_IN);
	}
	else 
	{
	    switch (rv)
	    {
	    case CKR_DEVICE_REMOVED:
		set_state(ctx, state_TOKEN_REQUIRED);
		break;

	    case CKR_PIN_INCORRECT:
		set_state(ctx, state_PIN_REQUIRED);
		break;

	    default:
		set_state(ctx, state_ERROR);
		break;
	    }
	}

	ctx->last_rv = rv;

	fdebugf( log_file, "process_pin_entered: state %s rv 0x%lx\n", STATE(ctx->state), rv );
    }
    else
#endif /* FLAVOUR_PKCS11 */
    {
	set_state(ctx, state_LOGGED_IN);
    }
}

static void process_read_pkey( http_cert_context *ctx )
{
#if FLAVOUR_PKCS11
    CK_RV rv;
#endif /* FLAVOUR_PKCS11 */

    http_cert_info *cert;

    fdebugf( log_file, "process_read_pkey: ctx %p\n", ctx );

    cert = cert_lookup(ctx->cert_list, ctx->which_cert);
    
#if FLAVOUR_PKCS11
    if (ctx->use_cryptobox)
    {
	if ((rv = get_private_key( ctx->session, cert->id, cert->id_len, &cert->key_object )) == CKR_OK)
	{
	    set_state(ctx, state_GOT_PKEY);
	}
	else 
	{
	    switch (rv)
	    {
	    case CKR_DEVICE_REMOVED:
		set_state(ctx, state_TOKEN_REQUIRED);
		break;

	    default:
		set_state(ctx, state_ERROR);
		break;
	    }
	}

	ctx->last_rv = rv;

	fdebugf( log_file, "process_read_pkey: state %s rv 0x%lx\n", STATE(ctx->state), rv );
    }
    else
#endif /* FLAVOUR_PKCS11 */
    {
	if (ctx->client_pkey || private_key_load( &ctx->client_pkey ))
	    set_state(ctx, state_GOT_PKEY);
	else
	    set_state(ctx, state_ERROR);
    }
}

static void process_token_removed( http_cert_context *ctx )
{
    set_state(ctx, state_CANCELLED);

    cert_context_close( ctx );

#if FLAVOUR_PKCS11
    ctx->last_rv = CKR_OK;
#endif /* FLAVOUR_PKCS11 */
}

static void process_cancel( http_cert_context *ctx )
{
    set_state(ctx, state_CANCELLED);

#if FLAVOUR_PKCS11
    ctx->last_rv = CKR_OK;
#endif /* FLAVOUR_PKCS11 */
}

static void client_state_machine(http_cert_context *ctx, certop_transition transition, void *data)
{
    certop_state last_state = ctx->state;

    if (ctx->threaded)
	return;

    ctx->threaded++;
    
    if (transition != transition_NONE)
    {
	fdebugf( log_file, "client_state_machine: ctx %p state %d (%s) transition %d (%s) data %p\n",
		 ctx, ctx->state, STATE(ctx->state), transition, TRANSITION(transition), data );
    }
    
    switch (ctx->state)
    {
    case state_CANCELLED:
    case state_ERROR:
	/* do nothing in these states */
	break;

    case state_UNSET:
	switch (transition)
	{
	case transition_NONE:
	    process_token_given( ctx );
	    break;
	    
	case transition_TOKEN_GIVEN:
	case transition_TOKEN_REMOVED:
	case transition_CERT_CHOSEN:
	case transition_PIN_ENTERED:
	    /* wrong time - ignore */
	    break;

	case transition_CANCEL:
	    process_cancel( ctx );
	    break;
	}
	break;
	
    case state_TOKEN_REQUIRED:
	/* need input from user (or smartcard event) before we do anything */
	switch (transition)
	{
	case transition_NONE:
	    /* do nothing */
	    break;
	    
	case transition_TOKEN_GIVEN:
	    process_token_given( ctx );
	    break;

	case transition_TOKEN_REMOVED:
	    process_token_removed( ctx );
	    break;

	case transition_CERT_CHOSEN:
	case transition_PIN_ENTERED:
	    /* wrong time - ignore */
	    break;

	case transition_CANCEL:
	    process_cancel( ctx );
	    break;
	}
	break;

    case state_CERT_CHOICE_REQUIRED:
	/* need input from user before we do anything */
	switch (transition)
	{
	case transition_NONE:
	    /* do nothing */
	    break;
	    
	case transition_TOKEN_GIVEN:
	    /* wrong time - ignore */
	    break;

	case transition_CERT_CHOSEN:
	    process_cert_chosen( ctx, data );
	    break;

	case transition_TOKEN_REMOVED:
	    process_token_removed( ctx );
	    break;

	case transition_PIN_ENTERED:
	    /* wrong time - ignore */
	    break;

	case transition_CANCEL:
	    process_cancel( ctx );
	    break;
	}
	break;

    case state_CERT_CHOICE_GIVEN:
	switch (transition)
	{
	case transition_NONE:
	    process_cert_chosen( ctx, data );
	    break;

	case transition_TOKEN_GIVEN:
	case transition_CERT_CHOSEN:
	case transition_PIN_ENTERED:
	    /* wrong time - ignore */
	    break;

	case transition_TOKEN_REMOVED:
	    process_token_removed( ctx );
	    break;

	case transition_CANCEL:
	    process_cancel( ctx );
	    break;
	}
	break;
	
    case state_PIN_REQUIRED:
	/* need input from user before we do anything */
	switch (transition)
	{
	case transition_NONE:
#if NO_UI
	    if (ctx->pin_count == 0)
	    {
		http_certop_data_pin_entered p;
		char *pin = getenv("HTTP$CryptoPin");
		if (pin)
		{
		    p.pin = mm_strdup(pin);
		    p.pin_len = strlen(p.pin);

		    process_pin_entered( ctx, &p );

		    mm_free(p.pin);
		}
	    }
	    else
		set_state(ctx, state_ERROR);
#endif
	    break;
	    
	case transition_TOKEN_GIVEN:
	case transition_CERT_CHOSEN:
	    /* wrong time - ignore */
	    break;

	case transition_PIN_ENTERED:
	    process_pin_entered( ctx, data );
	    break;

	case transition_TOKEN_REMOVED:
	    process_token_removed( ctx );
	    break;

	case transition_CANCEL:
	    process_cancel( ctx );
	    break;
	}
	break;

    case state_LOGGED_IN:
	switch (transition)
	{
	case transition_NONE:
	    process_read_pkey( ctx );
	    break;
	    
	case transition_TOKEN_REMOVED:
	    process_token_removed( ctx );
	    break;

	case transition_TOKEN_GIVEN:
	case transition_CERT_CHOSEN:
	case transition_PIN_ENTERED:
	    /* wrong time - ignore */
	    break;

	case transition_CANCEL:
	    process_cancel( ctx );
	    break;
	}
	break;

    case state_GOT_PKEY:
	switch (transition)
	{
	case transition_NONE:
	    /* do nothing */
	    break;
	    
	case transition_TOKEN_REMOVED:
	    process_token_removed( ctx );
	    break;

	case transition_TOKEN_GIVEN:
	case transition_CERT_CHOSEN:
	case transition_PIN_ENTERED:
	    /* wrong time - ignore */
	    break;

	case transition_CANCEL:
	    process_cancel( ctx );
	    break;
	}
	break;

    case state_REMOVED:
	switch (transition)
	{
	case transition_TOKEN_GIVEN:
	    process_token_given( ctx );
	    break;

	case transition_NONE:
	case transition_TOKEN_REMOVED:
	case transition_CERT_CHOSEN:
	case transition_PIN_ENTERED:
	case transition_CANCEL:
	    /* wrong time - ignore */
	    break;
	}
	break;
    }

#if FLAVOUR_PKCS11
    if (transition != transition_NONE)
    {
	fdebugf( log_file, "client_state_machine: ctx %p out state %d (%s) changed %d\n",
		 ctx, ctx->state, STATE(ctx->state), last_state != ctx->state);
    }
#endif

    ctx->threaded--;
}

/* ------------------------------------------------------------------------- */

/* This call converts from internal status information into what the
 * user is told about.
 */

static void client_cert_get_status( http_cert_context *ctx, const http_certop_data_get_status *in, http_certop_status_out *out)
{
    if (ctx == NULL)
    {
	out->state = http_certop_state_NOT_STARTED;
    }
    else
    {
	switch (ctx->state)
	{
	case state_ERROR:
	    out->state = http_certop_state_ERROR;
	    break;
	
	case state_UNSET:
	case state_LOGGED_IN:
	case state_GOT_PKEY:
	case state_CERT_CHOICE_GIVEN:
	    out->state = http_certop_state_PROCESSING;
	    break;

	case state_TOKEN_REQUIRED:
	    out->state = http_certop_state_TOKEN_REQUIRED;
	    break;

	case state_CERT_CHOICE_REQUIRED:
	    out->state = http_certop_state_CERT_CHOICE_REQUIRED;
	    out->buf_len = cert_write(ctx->cert_list, in->buf, in->buf_len, &out->num_certs);
	    break;

	case state_PIN_REQUIRED:
	    out->state = http_certop_state_PIN_REQUIRED;
	    break;

	case state_CANCELLED:
	    out->state = http_certop_state_CANCELLED;
	    break;
	}

#if FLAVOUR_PKCS11
	out->rv = (int)ctx->last_rv;
#endif
    }
}

/* ------------------------------------------------------------------------- */

/* From SSLeay/doc/callback.doc

   Called when a client certificate is requested but there is not one set
   against the SSL_CTX or the SSL.  If the callback returns 1, x509 and
   pkey need to point to valid data.  The library will free these when
   required so if the application wants to keep these around, increment
   their reference counts.  If 0 is returned, no client cert is
   available.  If -1 is returned, it is assumed that the callback needs
   to be called again at a later point in time.  SSL_connect will return
   -1 and SSL_want_x509_lookup(ssl) returns true.  Remember that
   application data can be attached to an SSL structure via the
   SSL_set_app_data(SSL *ssl,char *data) call.
   
 */

#define rc_OK		1
#define rc_FAILED	0
#define rc_WAITING	(-1)

static int client_cert_callback( SSL *ssl, X509 **x509, EVP_PKEY **pkey )
{
    int rc = rc_FAILED;
    http_cert_context *ctx;

    /* get the context */
    ctx = (http_cert_context *) SSL_get_app_data( ssl );

    if (!ctx)
    {
	/* if no ctx then create one */
	if (!cert__ctx)
	    cert__ctx = cert_context_create( );

	ctx = cert__ctx;
	if (!ctx)
	    return rc_FAILED;

	fdebugf( log_file, "client_cert_callback: %s ctx for SSL %p\n", ctx->state == state_GOT_PKEY ? "reusing" : "new", ssl );

	SSL_set_app_data( ssl, ctx );

	/* make a note of the CA list for this connection */
	ctx->CA_list = SSL_get_client_CA_list( ssl );

	fdebugf(log_file, "client_cert_callback: get CA list stack %p\n", ctx->CA_list);
	dump_name_stack( ctx->CA_list );

	/* if we already have a cert and pkey then see if they are
           still relevant to the (possibly) changed CA_list. If not
           then set state to UNSET and we'll retrieve the cert list
           again. If it is then we'll fall straight through and return
           the pair */
	switch (ctx->state)
	{
	case state_GOT_PKEY:
	{
	    X509 *x509;
	    const http_cert_info *cert;

	    cert = cert_lookup(ctx->cert_list, ctx->which_cert);

	    if (cert && (cert->x509 || cert->data ))
	    {
		if (cert->x509)
		    x509 = cert->x509;
		else
		{
		    unsigned char *pp = (unsigned char *)cert->data;
		    x509 = d2i_X509(NULL, &pp, cert->data_len);
		}

		if (!cert_check_usage(x509, ctx->CA_list))
		{
		    ctx->state = state_UNSET;
		    fdebugf(log_file, "client_cert_callback: previous cert choice doesn't match new CA list\n");
		}
	    }
	    else
	    {
		ctx->state = state_UNSET;
		fdebugf(log_file, "client_cert_callback: can't find suposedly selected cert %d in list %p\n", ctx->which_cert, ctx->cert_list);
	    }
	    break;
	}
	default:
	    ctx->state = state_UNSET;
	    break;
	}
    }

    /* Note state machine is actually triggered only from user generated SWIs */

    /* if we are now logged in we should have all the information we
     * need so return the info needed to SSLeay so that it can
     * continue with the connection */
    switch (ctx->state)
    {
    case state_GOT_PKEY:
#if FLAVOUR_PKCS11
	if (ctx->use_cryptobox)
	{
	    build_return_values( ctx, cert_lookup(ctx->cert_list, ctx->which_cert), x509, pkey);
	}
	else
#endif /* FLAVOUR_PKCS11 */
	{
	    *x509 = cert_lookup(ctx->cert_list, ctx->which_cert)->x509;
	    *pkey = ctx->client_pkey;

	    CRYPTO_add(&(*x509)->references,+1,CRYPTO_LOCK_X509);
	    CRYPTO_add(&(*pkey)->references,+1,CRYPTO_LOCK_EVP_PKEY);
	}

	fdebugf(log_file, "client_cert_callback: cert %p key %p\n", *x509, *pkey);
	rc = rc_OK;
	break;

    case state_ERROR:
    case state_CANCELLED:
	fdebugf(log_file, "client_cert_callback: %s\n", STATE(ctx->state));
	/* rc = rc_FAILED; */
	break;

    default:
	rc = rc_WAITING;
	socket_errno = EWOULDBLOCK;	/* set this so that the return from SSL_connect() isn't taken to be an error */
	break;
    }

    /* if exiting for the last time then clear any values that may
     * become invalid when the SSL structure is disposed of */
    if (rc != rc_WAITING)
    {
	ctx->CA_list = NULL;
    }
    
    return rc;
}

/* ------------------------------------------------------------------------- */

static int server_cert_verify_callback( int ok, X509_STORE_CTX *ctx )
{  
    SSL *ssl = (SSL *)X509_STORE_CTX_get_app_data(ctx);
/*  X509 *xs = X509_STORE_CTX_get_current_cert(ctx); */
    int error_depth = X509_STORE_CTX_get_error_depth(ctx);
    int error = X509_STORE_CTX_get_error(ctx);

    fdebugf( log_file, "cert_verify_callback: ok %d ctx %p ssl %p\n", ok, ctx, ssl );
    fdebugf( log_file, "cert_verify_callback: error_depth %d error %d\n", error_depth, error );

    return 1;
}

#if DEBUG
/* This callback is called each time around the
SSL_connect()/SSL_accept() state machine.  So it will be called each
time the SSL protocol progresses.  It is mostly present for use when
debugging.  When SSL_connect() or SSL_accept() return, the location
flag is SSL_CB_ACCEPT_EXIT or SSL_CB_CONNECT_EXIT and 'ret' is the
value about to be returned.  Have a look at the SSL_CB_* defines in
ssl.h.  If an info callback is defined against the SSL_CTX, it is
called unless there is one set against the SSL. */

static void info_callback( SSL *s, int where, int ret )
{
    char *str;
    int w;

    w=where& ~SSL_ST_MASK;

    if (w & SSL_ST_CONNECT) str="SSL_connect";
    else if (w & SSL_ST_ACCEPT) str="SSL_accept";
    else str="undefined";

    if (where & SSL_CB_LOOP)
    {
	fdebugf(log_file,"%s:%s\n",str,SSL_state_string_long(s));
    }
    else if (where & SSL_CB_ALERT)
    {
	str=(where & SSL_CB_READ)?"read":"write";
	fdebugf(log_file,"SSL3 alert %s:%s:%s\n",
		   str,
		   SSL_alert_type_string_long(ret),
		   SSL_alert_desc_string_long(ret));

	dump_ssl_error();
    }
    else if (where & SSL_CB_EXIT)
    {
	if (ret == 0)
	    fdebugf(log_file,"%s:failed in %s\n",
		       str,SSL_state_string_long(s));
	else if (ret < 0)
	{
	    if (socket_errno != EWOULDBLOCK)
		fdebugf(log_file,"%s:error in %s\n",
			str,SSL_state_string_long(s));
	}

	if (socket_errno != EWOULDBLOCK)
	    dump_ssl_error();

#if 1
	if (where & SSL_ST_CONNECT)
	    fdebugf(log_file,"exit(%d)%s(%d)\n", ret, SSL_state_string_long(s), s->state);
#endif
    }

#if 0
    if (s->state == SSL3_ST_CW_FLUSH)
    {
	BIO *bio;
	for (bio = s->wbio; bio; bio = bio->next_bio)
	    fdebugf(log_file, "BIO name: '%s'\n", bio->method->name);
    }
#endif
    
    if (SSL_in_before(s))
    {
	SSL_CTX *ctx = ssl_context;
	fdebugf(log_file, "SSLCTX: hits %d misses %d timeouts %d\n",
		SSL_CTX_sess_hits(ctx), SSL_CTX_sess_misses(ctx), SSL_CTX_sess_timeouts(ctx));
/* 	bio_debug_open(s); */
    }
}

static int sess_new_cb(SSL *ssl, SSL_SESSION *sess)
{
    fdebugf(log_file, "SSLCTX: new ssl %p session %p\n", ssl, sess);
    return 0;
}

static void sess_remove_cb(SSL_CTX *ssl_ctx, SSL_SESSION *sess)
{
    fdebugf(log_file, "SSLCTX: remove session %p\n", sess);
}

static SSL_SESSION *sess_get_cb(SSL *ssl, unsigned char *sess_id, int sess_id_len, int *copy)
{
    fdebugf(log_file, "SSLCTX: lookup ssl %p sess_id %p len %d\n", ssl, sess_id, sess_id_len);
    return NULL;
}

#endif

/* ------------------------------------------------------------------------- */

void client_cert_initialise( SSL_CTX *ssl_context )
{
    SSL_CTX_set_client_cert_cb(ssl_context, client_cert_callback);
    SSL_CTX_set_verify( ssl_context, SSL_VERIFY_PEER, server_cert_verify_callback );
#if DEBUG
    SSL_CTX_set_info_callback( ssl_context, info_callback );
    SSL_CTX_sess_set_new_cb( ssl_context, sess_new_cb );
    SSL_CTX_sess_set_remove_cb( ssl_context, sess_remove_cb );
    SSL_CTX_sess_set_get_cb( ssl_context, sess_get_cb );
#endif
}

void client_cert_finalise( void )
{
#if FLAVOUR_PKCS11
    if (cryptobox_init)
    {
	C_Finalize( NULL_PTR );
	cryptobox_init = FALSE;
    }
#endif /* FLAVOUR_PKCS11 */

    if (cert__ctx)
    {
	cert_context_free( cert__ctx );
	cert__ctx = NULL;
    }
}

/* This is called when the SSL context is about to be freed. It should
 * ensure that all our application data is freed up */

void client_cert_cleanup( SSL *ssl )
{
}

/* ------------------------------------------------------------------------- */

/* This is the user interface to this code. They can read the status
 * or can cause a transition in the state machine. */
 
os_error *http_certop( http_certop_args *args )
{
    SSL *ssl;
    http_cert_context *ctx;
    os_error *e;

    if (args->in.reason != http_certop_reason_GET_STATUS)
    {
	fdebugf( log_file, "http_certop: reason %d handle %p\n", args->in.reason, args->in.handle );
    }
    
    /* get the client context doing a little validation first */
    if ((e = http_check_handle(args->in.handle)) != NULL)
	return e;
    
    if ((ssl = args->in.handle->SSL) == NULL)
	return make_httperror(err_SSL_NOT_IN_PROGRESS);
	
    if ((ctx = (http_cert_context *) SSL_get_app_data(ssl)) == NULL &&
	args->in.reason != http_certop_reason_GET_STATUS)
    {
	return make_httperror(err_SSL_OUT_OF_CONTEXT);
    }
    
    /* do the requested operation */
    switch ( args->in.reason )
    {
    case http_certop_reason_GET_STATUS:
    {
	http_certop_status_out status = args->status_out;

	if (ctx)
	{
	    client_state_machine( ctx, ctx->pending_transition, NULL );
	    ctx->pending_transition = transition_NONE;
	}

	client_cert_get_status( ctx, &args->in.data.get_status, &status );
	args->status_out = status;
	break;
    }

    case http_certop_reason_TOKEN_GIVEN:
	client_state_machine( ctx, transition_TOKEN_GIVEN, NULL );
	break;

    case http_certop_reason_CERT_CHOSEN:
	client_state_machine( ctx, transition_CERT_CHOSEN, &args->in.data.cert_chosen );
	break;

    case http_certop_reason_PIN_ENTERED:
	client_state_machine( ctx, transition_PIN_ENTERED, &args->in.data.pin_entered );
	break;

    case http_certop_reason_CANCEL:
	client_state_machine( ctx, transition_CANCEL, NULL );
	break;
    }

    return NULL;
}

#if FLAVOUR_PKCS11

/* This is only called internally so the connection has already been
   validated. */
void client_smartcard_insertion( http_connection *c, BOOL inserted )
{
    http_cert_context *ctx;

    fdebugf( log_file, "client_smartcard_insertion: c %p insert %d\n", c, inserted);
    
    if (c)
    {
	fdebugf( log_file, "client_smartcard_insertion: SSL %p ctx %p\n", c->SSL, c->SSL ? SSL_get_app_data(c->SSL) : NULL );

	if (c->SSL &&
	    (ctx = (http_cert_context *) SSL_get_app_data(c->SSL)) != NULL)
	{
	    if (ctx->use_cryptobox && (inserted || ctx->token_count > 0))
	    {
		/* Just set a pending so that state machine is only called
		 * via HTTP_status and HTTP_CertOp not off a callback */
		ctx->pending_transition = inserted ? transition_TOKEN_GIVEN : transition_TOKEN_REMOVED;
	    }
	}
    }
    else
    {
	if (!inserted && cert__ctx && cert__ctx->use_cryptobox && cert__ctx->token_count > 0)
	{
	    cert_context_close( cert__ctx );
	}
    }
}

#endif /* FLAVOUR_PKCS11 */

void client_status_called( SSL *ssl )
{
#if FLAVOUR_PKCS11
    http_cert_context *ctx;
	
    if ((ctx = (http_cert_context *) SSL_get_app_data(ssl)) != NULL)
    {
	/* call the state machine, in case anything needs to process */
	client_state_machine( ctx, ctx->pending_transition, NULL );

	ctx->pending_transition = transition_NONE;
    }    
#endif /* FLAVOUR_PKCS11 */
}

#endif /* NO_SECURE */

/* ------------------------------------------------------------------------- */

#if DEBUG && FLAVOUR_PKCS11

void client_cli_read_certificates(void)
{
    http_cert_context *ctx; 

    if (!cryptobox_init)
    {
	if (C_Initialize( NULL_PTR ) != CKR_OK)
	{
	    fprintf(stderr, "failed to initialise cryptobox\n");
	    return;
	}
	
	cryptobox_init = TRUE;
    }

    if ((ctx = cert_context_create()) == NULL)
    {
	fprintf(stderr, "failed to create context\n");
	return;
    }
    
    printf("Reading certificates from smart card\n");
    process_token_given( ctx );
    if (ctx->last_rv != CKR_OK)
    {
	fprintf(stderr, "token_given: error %lx:\n", ctx->last_rv);
    }

    if (ctx->last_rv == CKR_OK)
    {
	http_certop_data_cert_chosen choice;
	int i;
	const http_cert_info *cert;

	printf("Certificates\n");
	for (i = 0, cert = ctx->cert_list;
	     cert;
	     i++, cert = cert->next)
	{
	    printf(" %2d: label '%.*s' description '%s'\n",
		    i + 1, cert->label_len, cert->label, cert->descr ? cert->descr : "");
	}

	if (i > 1)
	{
	    do
	    {
		char buf[32];
		printf("\nChoose certificate (1-%d):", i+1);
		scanf("%s", buf);
		choice.index = atoi(buf) - 1;
	    }
	    while (choice.index < 0 || choice.index > i);
	}
	
	choice.index = 0;
	process_cert_chosen( ctx, &choice );
	if (ctx->last_rv != CKR_OK)
	{
	    fprintf(stderr, "cert_chosen: error %lx:\n", ctx->last_rv);
	}
    }

    if (ctx->last_rv == CKR_OK)
    {
	http_certop_data_pin_entered pin;
	char buf[32];

	printf("Enter pin: ");
	scanf("%s", buf);
	
	pin.pin = buf;
	pin.pin_len = strlen(buf);
	process_pin_entered( ctx, &pin );
	if (ctx->last_rv != CKR_OK)
	{
	    fprintf(stderr, "pin_entered: error %lx:\n", ctx->last_rv);
	}
    }
    
    if (ctx->last_rv == CKR_OK)
    {
	printf("Reading private key\n");
	process_read_pkey( ctx );
	if (ctx->last_rv != CKR_OK)
	{
	    fprintf(stderr, "read_pkey:   error %lx:\n", ctx->last_rv);
	}
    }

    if (ctx->last_rv == CKR_OK)
    {
	const http_cert_info *cert = cert_lookup(ctx->cert_list, ctx->which_cert);

	if (cert)
	{
	    unsigned char *pp = (unsigned char *)cert->data;
	    X509 *x509 = d2i_X509(NULL, &pp, cert->data_len);
	    char *s;
		
	    printf( "subject '%s'\n", x509->name );
	
	    s = X509_NAME_oneline(X509_get_issuer_name(x509), NULL, 0);
	    printf( "issuer  '%s'\n", s );
	    mm_free(s);
	
	    X509_free(x509);

	    printf( "private key object 0x%lx\n", cert->key_object );
	}
	else
	{
	    fprintf(stderr, "no certificate found\n");
	}
    }
    
    cert_context_free( ctx );
}

#endif

/* ------------------------------------------------------------------------- */

/* eof client.c */
