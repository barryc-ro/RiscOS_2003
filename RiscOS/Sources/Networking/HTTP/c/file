/* file.c */

/* Operations on whole files
 * (C) ANT Limited 1997 -- All Rights Reserved -- Confidential
 *
 * Authors:
 *      Peter Hartley <peter@ant.co.uk>
 *
 */

#if defined( HTTPMOD ) || defined( WEBFTP )
# ifndef HTTPMOD
#  define HTTPMOD 1
# endif
# include <stdlib.h>
# include <time.h>
# include "swis.h"
# ifdef ACORN_BUILD
#  include "kernel.h"
#  include "types.h"
# else
#  include "riscos_lib/kernel.h"
#  include "riscos_lib/os.h"
#  include "../commonsrc/filetypes.h"
# endif
#else
# include "fresco.h"
#endif

#include "file.h"

#define getfiletype(f,ld,ex,st,en,ot,pt) _swix( OS_FSControl, _INR(0,6)|_OUT(2), \
						38,f,ld,ex,st,en,ot,pt)

BOOL file_get_size_and_type( const char *fname, int *pSize, int *pType )
{
    /*
    os_filestr ofs;

    ofs.action = 5;
    ofs.name = (char*)fname;
    ep = os_file( &ofs );
    */
    os_error *ep;
    int action, load, exec, start, end;
    
    ep = _swix( OS_File, _INR(0,1)|_OUT(0)|_OUTR(2,5), 5, fname, &action,
    			 &load, &exec, &start, &end );

    if ( ep || action==0 || action==2 )
        return FALSE;

#ifndef HTTPMOD
    ACCDBG(("file_get_size_and_type: size=%d\n", start ));
#endif

    if ( pSize )
        *pSize = start;

    if ( pType )
    {
        /* OS_FSControl 38: get file type */
        ep = getfiletype( fname, load, exec, start, end, 1, pType );
        if ( ep )
            return FALSE;
    }

    return TRUE;
}

os_error *file_set_type( const char *fname, int ft )
{
    return _swix( OS_File, _INR(0,2), 18, fname, ft );
}

BOOL file_exists( const char *cfile )
{
    int type;

    return (_swix(OS_File, _INR(0,1) | _OUT(0), 0x11, cfile, &type) != NULL ||
		    type != 0);
}

#ifndef HTTPMOD
/* Used to be called path_is_directory and be in util.c */
BOOL file_is_directory(const char *path)
{
    os_filestr ofs;
    os_error *ep;

    ofs.action = 5;
    ofs.name = (char *)path;

    ep = os_file(&ofs);

    /* A directory if no error, not a file and not not found */
    return ((ep == NULL) && (ofs.action != 1) && (ofs.action != 0));
}

typedef struct {
    int load;
    int exec;
    int len;
    int attr;
    int otype;
    int _internal;
    char timeandname[256+5];
} gbpb11data;

os_error *file_enumdir( const char *dirname, file_filelist **ppFile )
{
    os_gbpbstr gps;
    gbpb11data data;
    os_error *ep = NULL;
    
    gps.action = 11;
    gps.file_handle = (int)dirname;
    gps.data_addr = &data;
    gps.seq_point = 0;
    gps.buf_len = sizeof(data);
    gps.wild_fld = "*";
    
    while ( gps.seq_point != -1 && !ep )
    {
	gps.number = 1;
	ep = os_gbpb(&gps);
	
	if ( !ep && gps.number )
	{
	    file_filelist *pFile = (file_filelist*) mm_malloc( sizeof(file_filelist) );
	    
	    *ppFile = pFile;
	    
	    ppFile = &(pFile->next);
	    pFile->next = NULL;
	    pFile->name = mm_strdup( data.timeandname+5 );
	    pFile->more = NULL;
	    /*sprintf( buffer, "%s" layers_DIRSEP "%s", dirname, data.timeandname+5 );*/
	    pFile->size = data.len;
	    pFile->type = (data.otype & 1) ? (data.load>>8) & 0xFFF : FILETYPE_DIRECTORY;
	    /*file_get_size_and_type( buffer, &pFile->size, &pFile->type );*/
	    pFile->date = file_riscostounixtime( *(unsigned int*)data.timeandname,
	    					 data.timeandname[4] );
	}
    }
    return ep;
}
#endif

/* eof file.c */
