/**************************************************************/
/* File   : Module.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: RTSP OVS is a Video Control protocol module used  */
/*          to talk to OVS installations supporting RTSP.     */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie.                                       */
/*                                                            */
/* History: 08-Nov-1999 (ADH): Created.                       */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include <Global/RISCOS.h>
#include <Global/Services.h>
#include <Global/Upcall.h>
#include <swis.h>
#include <sys/errno.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h> /* Exported by VideoCtrl's !MkExport */

#include "Utils.h"
#include "RTSPOHdr.h"
#include "Module.h"

#include "CallOut.h"
#include "MoreInfo.h"
#include "Options.h"
#include "Play.h"
#include "Session.h"
#include "Setup.h"
#include "Status.h"
#include "TearDown.h"

/* Various patch-ups and other compile time bits */

#if CMHG_VERSION < 516
  #define CMHG_CONST
#else
  #define CMHG_CONST const
#endif

#ifndef ROM
  extern int messages_file(void);
#endif

#ifndef ROM
  #ifdef DEFINE_ERRNO
    int __errno;
  #endif
#endif

/* TinySupport SWIs. This does not work if any library static data   */
/* is used within the module. This means errno (__errno) and __ctype */
/* (as used by any macro call to is.... functions). If you re-enable */
/* this SWI call, this module will fail to work at all.              */

#define NO_TINYSTUBS

#ifdef ROM
  #ifndef NO_TINYSTUBS
    static _kernel_oserror *__ROM;
    #define TinySupport_Share   (0x82c43)
    #define TinySupport_Die     (0x82c41)
  #endif
#endif

/* Local definitions */

#define CallBack_Pending_None    0
#define CallBack_Pending_ForLoop 1

/* Local variables */

static void    * module_wsp                         = NULL;

static bool      eventv_claimed                     = false;
static bool      ievent_enabled                     = false;
static bool      upcallv_claimed                    = false;

static int       callback_pending_code              = CallBack_Pending_None;
static session * callback_loop_session              = NULL;
static int       registered                         = 0;
static int       clibrary_realloc_routine_is_buggy  = 1;

/* Local functions */

static _kernel_oserror * module_try_to_register        (void);
static _kernel_oserror * module_try_to_deregister      (void);
static _kernel_oserror * module_register               (void);

static void              module_check_os_version       (void);
static void              module_atexit                 (void);

static _kernel_oserror * module_claim_upcall_vector    (void);
static _kernel_oserror * module_release_upcall_vector  (void);

/**************************************************************/
/* module_try_to_register()                                   */
/*                                                            */
/* Attempts to register with Video Control. Exits if already  */
/* registered. "registered" is set to 1 if registration is    */
/* successful, else left at its previous value.               */
/**************************************************************/

static _kernel_oserror * module_try_to_register(void)
{
  _kernel_oserror * e;

  dprintf(("", "module_try_to_register: Called\n"));

  if (registered)
  {
    dprintf(("", "module_try_to_register: Already registered, exitting\n"));
    return NULL;
  }

  e = _swix(VideoControl_ProtocolRegister,
            _INR(0,4),

            VC_ProtocolRegister_IDoReducedRateSlowmoForward,
            RTSPOVS_00,
            RTSPOVS_FetchScheme,
            Module_VersionNumber,
            Module_Help " © Pace 2000 (" Module_Date ")");

  if (e == NULL) registered = 1;

  dprintf(("", "module_try_to_register: Finished, registered = %d\n", registered));

  return e;
}

/**************************************************************/
/* module_try_to_deregister()                                 */
/*                                                            */
/* Attempts to deregister with Video Control. Exits if not    */
/* registered. "registered" is set to 0 whether or not the    */
/* call to VideoControl to deregister raises an error.        */
/**************************************************************/

static _kernel_oserror * module_try_to_deregister(void)
{
  _kernel_oserror * e;

  dprintf(("", "module_try_to_deregister: Called\n"));

  if (registered == 0)
  {
    dprintf(("", "module_try_to_deregister: Not registered, exitting\n"));
    return NULL;
  }

  e = _swix(VideoControl_ProtocolDeregister,
            _INR(0,1),

            0,
            RTSPOVS_00);

  registered = 0;

  dprintf(("", "module_try_to_deregister: Finished, e = %p\n", e));
  if (e) dprintf(("", "module_try_to_register: '%s'\n", e->errmess));

  return e;
}

/**************************************************************/
/* module_register()                                          */
/*                                                            */
/* Attempts to register with Video Control. If we get "SWI    */
/* not known" and this isn't a ROM build, try loading Video   */
/* Control. That should send the "started" service call       */
/* around which leads to another attempt to register later.   */
/**************************************************************/

static _kernel_oserror * module_register(void)
{
  _kernel_oserror * e = module_try_to_register();

  if (e == NULL) return NULL;
  if (e->errnum != RTSPOVS_NoSuchSWI) return e;

  #ifndef ROM

    /* Try to load Video Control - if it starts it should send round a */
    /* service call that'll prompt us to attempt registration again.   */

    _swix(OS_Module,
          _INR(0,1),

          1, /* Load */
          "System:Modules.Network.Video.VideoCtrl");

  #endif

  return NULL;
}

/**************************************************************/
/* module_claim_event_vector()                                */
/*                                                            */
/* Claims the event vector for the purpose of receiving the   */
/* Internet event. A locking flag ensures multiple calls are  */
/* dealt with correctly.                                      */
/**************************************************************/

_kernel_oserror * module_claim_event_vector(void)
{
  if (!eventv_claimed)
  {
    _kernel_oserror * e;

    e = _swix(OS_Claim,
              _INR(0,2),

              EventV,
              event_entry,
              module_wsp);

    if (e == NULL) eventv_claimed = true;
    return e;
  }

  return NULL;
}

/**************************************************************/
/* module_release_event_vector()                              */
/*                                                            */
/* Releases the event vector. A locking flag ensures multiple */
/* calls are dealt with correctly.                            */
/**************************************************************/

_kernel_oserror * module_release_event_vector(void)
{
  if (eventv_claimed)
  {
    _kernel_oserror * e;

    e = _swix(OS_Release,
              _INR(0,2),

              EventV,
              event_entry,
              module_wsp);

    if (e == NULL) eventv_claimed = false;
    return e;
  }

  return NULL;
}

/**************************************************************/
/* module_enable_internet_event()                             */
/*                                                            */
/* Enables the Internet event. A locking flag ensures         */
/* multiple calls are dealt with correctly.                   */
/**************************************************************/

void module_enable_internet_event(void)
{
  if (!ievent_enabled)
  {
    (void) _swix(OS_Byte,
                 _INR(0,1),

                 14,
                 19); /* enable internet event */
  }

  ievent_enabled = true;
}

/**************************************************************/
/* module_disable_internet_event()                            */
/*                                                            */
/* Disables the Internet event. A locking flag ensures        */
/* multiple calls are dealt with correctly.                   */
/**************************************************************/

void module_disable_internet_event(void)
{
  if (ievent_enabled)
  {
    (void) _swix(OS_Byte,
                 _INR(0,1),

                 13,
                 19); /* disable internet event */
  }

  ievent_enabled = false;
}

/**************************************************************/
/* module_check_os_version()                                  */
/*                                                            */
/* Sets clibrary_realloc_routine_is_buggy to a non-zero value */
/* if the OS version is sufficiently old that the SVC mode C  */
/* library realloc() is buggy in module code; else sets       */
/* it to zero.                                                */
/*                                                            */
/* See also module_realloc.                                   */
/**************************************************************/

static void module_check_os_version(void)
{
  int os;

  (void) _swix(OS_Byte,
               _INR(0,2) | _OUT(1),

               129,
               0,
               255,

               &os);

  clibrary_realloc_routine_is_buggy = (os <= 0xA4);
}

/**************************************************************/
/* module_init()                                              */
/*                                                            */
/* Startup code, usual initialisation entry point stuff.      */
/*                                                            */
/* Parameters: As normal for a CMHG initialisation function.  */
/**************************************************************/

_kernel_oserror * module_init(CMHG_CONST char * cmd_fail, int podule_base, void * pw)
{
  _kernel_oserror * e;

  (void) cmd_fail;
  (void) podule_base;

  module_wsp = pw;

  #ifdef ROM
    #ifndef NO_TINYSTUBS

      __ROM = _swix(TinySupport_Share,
                    _IN(0),

                    pw);

    #endif
  #endif

  #ifdef TRACE
    {
      debug_device dev = TML_OUTPUT;

      debug_initialise("RTSPOVS", "ADFS::4.$.RTSPOdebug", NULL);
      debug_atexit();
      debug_set_screen_cornering(FALSE);
      debug_set_unbuffered_files(TRUE);
      debug_set_device(dev);
    }
  #endif

  /* Keep this after debuglib initialisation or you won't */
  /* see any debug output from within the atexit handler. */

  atexit(module_atexit);
  module_check_os_version();

  #ifndef ROM

    e = _swix(ResourceFS_RegisterFiles,
              _IN(0),

              messages_file());

    if (e != NULL) return e;

  #endif

  if (getenv(Module_Title "$Path"))
  {
    e = messages_file_open(Module_Title ":Messages");
  }
  else
  {
    e = messages_file_open("Resources:$.Resources.VideoCtrl." "RTSPOVS" ".Messages");
  }

  #if CMHG_VERSION < 530

    /*
     * Earlier CMHGs won't call the atexit() handler if we return an
     * error here 'cos its bust. Could work around it but since there
     * is a fixed version available, insist on it.
     */

    #error You need CMHG 5.30 or later to build RTSPOVS.

  #else

    if (e != NULL) return e;

    /* Register with Video Control - No Such SWI is hidden, other */
    /* errors are reported.                                       */

    e = module_register();
    if (e != NULL && e->errnum != RTSPOVS_NoSuchSWI) return e;

  #endif

  #ifdef ALWAYS_CLAIM_EVENTV

    /* Set ourselves up for the event vector */

    e = module_claim_event_vector();
    if (e != NULL) return e;
    module_enable_internet_event();

  #endif

  /* Claim UpCallV to see MPEG end-of-stream UpCalls */

  e = module_claim_upcall_vector();
  if (e != NULL) return e;

  return callout_init(pw);
}

/**************************************************************/
/* module_atexit()                                            */
/*                                                            */
/* atexit() handler for the module. Note that this is only    */
/* correctly called if the module is built with CMHG 5.30 or  */
/* later.                                                     */
/**************************************************************/

static void module_atexit(void)
{
  dprintf(("", "module_atexit: Called\n"));

  callout_final(module_wsp);

  if (callback_pending_code != CallBack_Pending_None)
  {
    (void) _swix(OS_RemoveCallBack,
                 _INR(0,1),
                 callback_entry,
                 module_wsp);

    callback_pending_code = CallBack_Pending_None;
  }

  /* We rely on the claimed and enabled flags to allow this blanket */
  /* call to disable the Internet event and release EventV. If we   */
  /* were to crash in some odd way elsewhere and subsequently kill  */
  /* the module, leaving EventV claimed would prove catastrophic.   */

  module_disable_internet_event();
  module_release_event_vector();

  /* Get rid of the UpCallV handler */

  module_release_upcall_vector();

  /* Other critical "must go now" things */

  #ifndef ROM

    (void) _swix(ResourceFS_DeregisterFiles,
                 _IN(0),

                 messages_file());

  #endif

  /* Now we can start shutting the rest down. Stuff here may start */
  /* looking through data structures so might crash, which would   */
  /* stop anything following being run. Hence, do the essential    */
  /* (but hopefully reliable!) stuff first, above.                 */

  messages_file_close();
  module_try_to_deregister();
  session_free_list();

  #ifdef ROM
    #ifndef NO_TINYSTUBS
      if(!__ROM) _swix(TinySupport_Die, 0);
    #endif
  #endif
}

/**************************************************************/
/* module_claim_upcall_vector()                               */
/*                                                            */
/* Claims the UpCall vector for the purpose of receiving the  */
/* MPEG UpCall. A locking flag ensures multiple calls are     */
/* dealt with correctly.                                      */
/**************************************************************/

_kernel_oserror * module_claim_upcall_vector(void)
{
  if (!upcallv_claimed)
  {
    _kernel_oserror * e;

    e = _swix(OS_Claim,
              _INR(0,2),

              UpCallV,
              upcall_entry,
              module_wsp);

    if (e == NULL) upcallv_claimed = true;
    return e;
  }

  return NULL;
}

/**************************************************************/
/* module_release_upcall_vector()                             */
/*                                                            */
/* Releases the UpCall vector. A locking flag ensures         */
/* multiple calls are dealt with correctly.                   */
/**************************************************************/

_kernel_oserror * module_release_upcall_vector(void)
{
  if (upcallv_claimed)
  {
    _kernel_oserror * e;

    e = _swix(OS_Release,
              _INR(0,2),

              UpCallV,
              upcall_entry,
              module_wsp);

    if (e == NULL) upcallv_claimed = false;
    return e;
  }

  return NULL;
}

/**************************************************************/
/* callback_handler()                                         */
/*                                                            */
/* General callback handler. Currently only called when a     */
/* looped session has an end of stream UpCall detected.       */
/*                                                            */
/* Parameters: As normal for a CMHG generic veneer.           */
/**************************************************************/

_kernel_oserror * callback_handler(_kernel_swi_regs * r, void * pw)
{
  unsigned int code = callback_pending_code;

  (void) pw;
  (void) r;

  dprintf(("", "callback_handler: Called, flag = %d, pw = %p\n", callback_pending_code, pw));

  callback_pending_code = CallBack_Pending_None;
  if (code == CallBack_Pending_None) return NULL;

  switch (code)
  {
    case CallBack_Pending_ForLoop:
    {
      /* We've been called because the UpCall handler saw UpCall_MPEG     */
      /* with the "end of stream" reason code and matched the control     */
      /* handle against the session it stored in 'callback_loop_session'. */

      if (callback_loop_session != NULL)
      {
        session * s = callback_loop_session;

        callback_loop_session = NULL;

        play_replay(s);
      }
      else dprintf(("", "callback_handler: callback_loop_session was unexpectedly NULL!\n"));
    }
    break;
  }

  return NULL;
}

/**************************************************************/
/* service_handler()                                          */
/*                                                            */
/* General service call handler.                              */
/*                                                            */
/* Parameters: As normal for a CMHG service call handler.     */
/**************************************************************/

void service_handler(int service_number, _kernel_swi_regs * r, void * pw)
{
  dprintf(("", "service_handler: Called for %08x (%d, %d)\n", service_number, r->r[0], r->r[2]));

  if (service_number == Service_VideoControl)
  {
    /* 0 means "I started", 1 means "I went away - don't talk to me now" */

    switch (r->r[0])
    {
      case 0: module_try_to_register(); break;
      case 1: registered = 0; /* Can't actively deregister as Video Control has gone away */
      default: break;
    }
  }
}

/**************************************************************/
/* upcall_handler()                                           */
/*                                                            */
/* General UpCall handler.                                    */
/*                                                            */
/* Parameters: As normal for a CMHG generic veneer.           */
/**************************************************************/

#ifndef UpCall_MPEG
  #define UpCall_MPEG 21
#endif

_kernel_oserror * upcall_handler(_kernel_swi_regs * r, void * pw)
{
  (void) pw;
  (void) r;

  // TEMPORARY, should be in Global/Upcall.h

  if (r->r[0] == UpCall_MPEG)
  {
    _kernel_oserror * e;
    int               opts[4];
    session         * s;

    dprintf(("", "upcall_handler: Got UpCall_MPEG, flags %08x, for handle %08x - reason code = %d\n",r->r[1],r->r[2],r->r[3]));

    /* We only recognise reason code 0 (End Of Stream) right now */

    if (r->r[3] == 0)
    {
      /* Need to search through each session and see if we recognise the handle */

      for (s = session_return_head(); s; s = s->next)
      {
        /* If looping is on, need to re-start playback */

        if (s->loop)
        {
          opts[0] = vc_tags_control_handle;
          opts[1] = 1;
          opts[2] = 0;
          opts[3] = vc_tags__end;

          e = _swix(VideoControl_ProtocolOptions,
                    _INR(0,2),

                    0,
                    s->vcid,
                    opts);

          if (e != NULL) break;

          if (opts[2] == r->r[2])
          {
            dprintf(("", "upcall_handler: Matched handle %08x to looping-active session %p\n", r->r[2], s));

            /* Not a good idea to try calling play_replay right now. Do it on a callback. */

            callback_loop_session = s;

            if (
                 _swix(OS_AddCallBack,
                       _INR(0,1),

                       callback_entry,
                       module_wsp)

                 == NULL
               )
               callback_pending_code = CallBack_Pending_ForLoop;
          }
        }
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* swi_handler()                                              */
/*                                                            */
/* SWI dispatch table.                                        */
/*                                                            */
/* Parameters: As normal for a CMHG SWI handler.              */
/**************************************************************/

_kernel_oserror * swi_handler(int swi_no, _kernel_swi_regs * r, void * pw)
{
  switch(swi_no)
  {
    case RTSPOVS_Setup                        - RTSPOVS_00: /* RTSPOVS_Setup           */
      return(setup_setup(r));                               /* Setup.c                 */

    case RTSPOVS_Options                      - RTSPOVS_00: /* RTSPOVS_Options         */
      return(options_options(r));                           /* Options.c               */

    case RTSPOVS_Status                       - RTSPOVS_00: /* RTSPOVS_Status          */
      return(status_status(r));                             /* Status.c                */

    case RTSPOVS_MoreInformation              - RTSPOVS_00: /* RTSPOVS_MoreInformation */
      return(moreinfo_more_information(r));                 /* MoreInfo.c              */

    case RTSPOVS_Play                         - RTSPOVS_00: /* RTSPOVS_Play            */
      return(play_play(r));                                 /* Play.c                  */

    case RTSPOVS_TearDown                     - RTSPOVS_00: /* RTSPOVS_TearDown        */
      return(teardown_tear_down(r));                        /* TearDown.c              */

    default:
      return error_BAD_SWI;
  }
}

/**************************************************************/
/* event_handler()                                            */
/*                                                            */
/* Event handler for the Internet event.                      */
/*                                                            */
/* Parameters: As normal for a CMHG event handler.            */
/**************************************************************/

int event_handler(_kernel_swi_regs * r, void * pw)
{
  int ret = 1; /* Pass on */

  /* Since this is only called on the Internet event, don't have */
  /* to worry about setting a callback or re-entrancy.           */

  _kernel_irqs_on();

  if (r->r[1] == 1) /* socket_ASYNC_EVENT */
  {
    session * s;
    int       sid = r->r[2];

    dprintf(("", "Internet event handler called, SD = %d\n", r->r[2]));

    for (s = session_return_head(); s; s = s->next)
    {
      if (s->sd == sid)
      {
        /* We recognise this socket ID - call the state machine */

        status_proceed(s);

        ret = 0; /* Intercept */
        break;
      }
    }
  }

  _kernel_irqs_off();

  return ret; /* Pass it on */
}

/**************************************************************/
/* module_realloc()                                           */
/*                                                            */
/* RISC OS 3.1's SVC mode realloc is broken, so here's our    */
/* own version. Use it if clibrary_realloc_routine_is_buggy   */
/* is set after calling module_check_os_version.              */
/*                                                            */
/* Parameters: As realloc.                                    */
/*                                                            */
/* Returns:    As realloc.                                    */
/**************************************************************/

void * module_realloc(void * ptr, size_t size)
{
  dprintf(("", "module_realloc(%p, %d)\n", ptr, size));

  if (!clibrary_realloc_routine_is_buggy) return realloc(ptr, size);

  if (ptr == NULL)
  {
    return malloc(size);
  }

  if (size == 0)
  {
    free(ptr);
    return NULL;
  }
  else
  {
    const int    * rma_block = ptr;
    const size_t   newsize   = size - (rma_block[-1] - 4);
    char         * newptr;

    if (
         _swix(OS_Module,
               _IN(0) | _INR(2,3) | _OUT(2),

               0xD,
               ptr,
               newsize,

               &newptr)

         != NULL
       )
       return NULL;

     return newptr;
  }
}
