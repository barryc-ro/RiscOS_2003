/**************************************************************/
/* File:    Status.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPOVS_Status and handle the state     */
/*          machine.                                          */
/*                                                            */
/* Author:  A.D.Hodgkinson. Partially based on URL_Fetcher    */
/*          source by S.N.Brodie and P.Wain.                  */
/*                                                            */
/* History: 08-Nov-1999 (ADH): Created.                       */
/*          02-Dec-1999 (ADH): Extended to handle the state   */
/*                             machine as well as the status  */
/*                             SWI call.                      */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#include <swis.h>

#include <inetlib.h>
#include <socklib.h>
#include <sys/errno.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Headers.h"
#include "Module.h"
#include "RTSPOErrors.h"
#include "RTSPOHdr.h"
#include "Session.h"
#include "Utils.h"

#include "Status.h"

/* Local variables */

static char            recbuf[2048];
static _kernel_oserror final;

/* Local functions */

static bool status_proceed_completed (session * s, bool * repeat);
static bool status_proceed_connected (session * s, bool * repeat);
static bool status_proceed_default   (session * s, bool * repeat);
static bool status_proceed_dns       (session * s, bool * repeat);
static bool status_proceed_error     (session * s, bool * repeat);
static bool status_proceed_initial   (session * s, bool * repeat);
static bool status_proceed_pumping   (session * s, bool * repeat);
static bool status_proceed_receiving (session * s, bool * repeat);
static bool status_proceed_sending   (session * s, bool * repeat);

/**************************************************************/
/* status_status()                                            */
/*                                                            */
/* Implement RTSPOVS_Status. See the Video Control            */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * status_status(_kernel_swi_regs * r)
{
  _kernel_oserror * e = NULL;
  session         * s = session_find_by_id(r->r[1]);

  dprintf(("", "status_status: Called\n"));

  if (!s)
  {
    dprintf(("", "status_status: ID not found\n"));
    return make_error(rtspovs_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  r->r[0] = s->reported_state;
  r->r[2] = s->response_code;

  /* Error, or normal state? */

  e = status_check_error(s);

  dprintf(("", "status_status: Returning status %08x, error %p\n", r->r[0], e));

  return e;
}

/**************************************************************/
/* status_proceed_on_callout()                                */
/*                                                            */
/* A CallOut handler (see CallOut.h) which drives the state   */
/* machine. Used for anything that can't be event driven,     */
/* such as waiting for a DNS lookup to complete.              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void status_proceed_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("", "status_proceed_on_callout: Called for %p, forwarding to status_proceed\n", s));

  s->callout_set = 0;

  status_proceed(s);
}

/**************************************************************/
/* status_proceed()                                           */
/*                                                            */
/* Main module state machine.                                 */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: Pointer to the session struct to work for.     */
/**************************************************************/

void status_proceed(session * s)
{
  bool repeat;

  dprintf(("", "status_proceed: Called for %p\n", s));

  do
  {
    repeat = false;

    switch (s->state)
    {
      default:
      {
        if (status_proceed_default(s, &repeat)) return;
      }
      break;

      /* Error states: Various things went wrong... */

      case protostate_ERROR:
      case protostate_ERROR_DEAD:
      case protostate_ERROR_MEM:
      case protostate_ERROR_WRITE:
      case protostate_ERROR_READ:
      case protostate_ERROR_CONNECTION:
      case protostate_ERROR_NO_TOKEN:
      case protostate_ERROR_NOT_IMPLEMENTED:
      case protostate_ERROR_TIMEOUT:
      case protostate_ERROR_DNS:
      case protostate_ERROR_VCPN:
      {
        if (status_proceed_error(s, &repeat)) return;
      }
      break;

      /* Idle */

      case protostate_INITIAL:
      {
        if (status_proceed_initial(s, &repeat)) return;
      }
      break;

      /* After calling opensock (Connect.c) to kick things off, we're */
      /* waiting for DNS lookup to complete.                          */

      case protostate_DNS:
      {
        if (status_proceed_dns(s, &repeat)) return;
      }
      break;

      /* DNS is complete, and we're connected. Well, almost, could still try to */
      /* send down the socket and get ENOTCONN for a while...! At this point,   */
      /* call any connection callback function immediately, add in a sequence   */
      /* header, and move to a SENDING state to send the command off.           */

      case protostate_CONNECTED:
      {
        if (status_proceed_connected(s, &repeat)) return;
      }
      break;

      /* Whilst we could still be in an ENOTCONN state, the state machine is way ahead */
      /* and is will be issuing socket_write calls.                                    */

      case protostate_SENDING:
      {
        if (status_proceed_sending(s, &repeat)) return;
      }
      break;

      /* As soon as a full command is sent, we start listening for a response */

      case protostate_RECEIVING:
      {
        if (status_proceed_receiving(s, &repeat)) return;
      }
      break;

      case protostate_PUMPING:
      {
        if (status_proceed_pumping(s, &repeat)) return;
      }
      break;

      case protostate_COMPLETED:
      {
        if (status_proceed_completed(s, &repeat)) return;
      }
      break;
    }
  }
  while (repeat);

  /* If we've got a server session, no callout set and a timeout value, */
  /* set a callout to keep the session up (ensuring we're idling).      */

  if (
       (
         s->state == protostate_COMPLETED ||
         s->state == protostate_INITIAL
       )
       && s->gp_set         == 0
       && s->server_session != NULL
       && s->server_timeout != 0
     )
  {
    dprintf(("","status_proceed: Setting GET_PARAMETER callout\n"));

    s->gp_set = 1;
    timeout(getparam_proceed_on_callout, s, s->server_timeout);
  }

  dprintf(("", "status_proceed: Successful\n"));
}

/**************************************************************/
/* status_proceed_default()                                   */
/*                                                            */
/* State machine handler for an unknown state.                */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_default(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_default: UNKNOWN STATE %d ENTERED\n", s->state));

  s->state = protostate_COMPLETED;
  *repeat  = true;

  return false;
}

/**************************************************************/
/* status_proceed_error()                                     */
/*                                                            */
/* State machine handler for any error state.                 */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_error(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_error: General error\n"));

  if (s->destruct)
  {
    dprintf(("", "status_proceed_error: Session self-destructing (on error), state machine exitting\n"));
    session_free_item(s);
    return true;
  }

  return false;
}

/**************************************************************/
/* status_proceed_initial()                                   */
/*                                                            */
/* State machine handler for an initial (idling) state.       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_initial(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_initial: Initial state\n"));

  return false;
}

/**************************************************************/
/* status_proceed_dns()                                       */
/*                                                            */
/* State machine handler for a DNS (resolving) state: "After  */
/* calling opensock (Connect.c) to kick things off, we're     */
/* waiting for DNS lookup to complete".                       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_dns(session * s, bool * repeat)
{
  char * port;

  dprintf(("", "status_proceed_dns: DNS; recalling opensock\n"));

  port = NULL;
  if (s->url->port && *s->url->port) port = s->url->port;
  s->sd = opensock(s->url->host, RTSPOVS_DefaultPort, port, &s->state, -1);

  /* If we're still in the DNS state, set another callout. Otherwise we */
  /* have to wait until the Internet event handler gets triggered when  */
  /* the socket gets connected.                                         */

  if (s->sd < 0 || s->state == protostate_DNS)
  {
    unsigned now = utils_read_time();

    dprintf(("", "status_proceed_dns: Still in DNS state / sd < 0\n"));

    /* Check timeout */

    if (utils_time_difference(s->last, now) > Headers_Timeout_General)
    {
      dprintf(("", "status_proceed_dns: DNS timeout\n"));

      s->state = protostate_ERROR_TIMEOUT;
      *repeat  = true;
    }
    else if (s->callout_set == 0)
    {
      dprintf(("", "status_proceed_dns: Setting a 50cs callout for DNS lookup\n"));

      s->callout_set = 1;
      timeout(status_proceed_on_callout, s, Session_State_Timer);
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_connected()                                 */
/*                                                            */
/* State machine handler for a connected (post-DNS, but could */
/* be waiting for actual connection) state: "DNS is complete, */
/* and we're connected. Well, almost, could still try to send */
/* down the socket and get ENOTCONN for a while...! At this   */
/* point, call any connection callback function immediately,  */
/* add in a sequence header, and move to a SENDING state to   */
/* send the command off".                                     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_connected(session * s, bool * repeat)
{
  /* Socket is connected. Compile our command data into a continuous block */
  /* and move to a "sending" state.                                        */

  dprintf(("", "status_proceed_connected: Connected\n"));

  s->last = utils_read_time();

  if (s->connected_cb != NULL)
  {
    dprintf(("", "status_proceed_connected: Calling callback function.\n"));

    // And we do what exactly with errors...?

    s->connected_cb(s);
    s->connected_cb = NULL;
  }

  /* Compile the headers into a continuous block for sending */

  s->reqlen = headers_construct_header_buffer(s, s->data_len, 0);

  if (s->full_request != NULL)
  {
    /* If there's body data, include it */

    if (s->data_len > 0)
    {
      memcpy(s->full_request + s->reqlen, s->data, s->data_len);
      s->reqlen += s->data_len;

      /* We're always over-allocated by 1 to allow for a NUL terminator, keeps */
      /* things tidy elsewhere (see function header comments in Headers.c).    */

      (s->full_request)[s->reqlen] = '\0';
    }

    dprintf(("", "status_proceed_connected: Command buffer compiled -\n'%s'\n",s->full_request));

    s->state = protostate_SENDING;
    *repeat  = true;
  }

  return false;
}

/**************************************************************/
/* status_proceed_sending()                                   */
/*                                                            */
/* State machine handler for a sending state: "Whilst we      */
/* could still be in an ENOTCONN state, the state machine is  */
/* way ahead and will be issuing socket_write calls".         */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_sending(session * s, bool * repeat)
{
  int    sent;
  time_t now;

  /* We're sending a command out */

  dprintf(("", "status_proceed_sending: Sending (%d of %d done so far)...\n", s->reqptr, s->reqlen));

  /* printf("\nSend:\n---\n%s\n--- for %p\n",s->full_request,s); */

  sent = socketwrite(s->sd,
                     s->full_request + s->reqptr,
                     s->reqlen - s->reqptr);

  dprintf(("", "status_proceed_sending: ...sent %d this time\n", sent));

  now = utils_read_time();

  if (sent < 0)
  {
    if (
         errno != ENOTCONN    &&
         errno != EWOULDBLOCK
       )
    {
      dprintf(("", "status_proceed_sending: Error %d\n", errno));

      s->state = protostate_ERROR_WRITE;
      *repeat  = true;
    }
    else
    {
      /* Check timeout */

      if (utils_time_difference(s->last, now) > Headers_Timeout_General)
      {
        s->state = protostate_ERROR_TIMEOUT;
        *repeat  = true;
      }
      else if (s->callout_set == 0)
      {
        dprintf(("", "status_proceed_sending: Setting %dcs callout for send timeout (1)\n", Session_State_Retry));

        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Retry);
      }
    }
  }
  else
  {
    s->reported_state |= VC_Status_ConnectionEstablished;
    s->reqptr         += sent;

    if (sent != 0)
    {
      s->last = now;
    }
    else
    {
      /* Check timeout */

      if (utils_time_difference(s->last, now) > Headers_Timeout_General)
      {
        s->state = protostate_ERROR_TIMEOUT;
        *repeat  = true;

        return false;
      }
      else if (s->callout_set == 0)
      {
        dprintf(("", "status_proceed_sending: Setting a %dcs callout for send timeout (2)\n", Session_State_Retry));

        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Retry);
      }
    }

    if (s->reqptr >= s->reqlen)
    {
      dprintf(("", "status_proceed_sending: Full command sent, moving to RECEIVING\n"));

      s->last = now;

      free(s->full_request), s->full_request = NULL;
      s->reqptr = s->reqlen = 0;

      /* We'll read into s->data, so don't forget to clear anything lying */
      /* around in there from the request we sent.                        */

      free(s->data), s->data = NULL;
      s->data_len = 0;

      s->state = protostate_RECEIVING;
      *repeat  = true;
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_receiving()                                 */
/*                                                            */
/* State machine handler for a receiving state: "As soon as a */
/* full command is sent, we start listening for a response".  */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_receiving(session * s, bool * repeat)
{
  int          ret;
  unsigned int now = utils_read_time();

  dprintf(("", "status_proceed_receving: Receiving\n"));

  for (;;)
  {
    ret = socketread(s->sd,
                     recbuf,
                     sizeof(recbuf));

    dprintf(("", "status_proceed_receving: Retrieved %d, existing data length is %d\n", ret, s->data_len));

    /* If we get > 0, we read data successfully */

    if (ret > 0)
    {
      char * new_data = module_realloc(s->data, s->data_len + ret + 1);

      s->last = now;

      if (new_data == NULL)
      {
        dprintf(("", "status_proceed_receving: Can't realloc for receive\n"));

        s->state = protostate_ERROR_MEM;
        *repeat  = true;

        return false;
      }
      else
      {
        dprintf(("", "status_proceed_receving: Read %d bytes, realloced to %d\n", ret, s->data_len + ret + 1));

        s->data = new_data;
        memcpy(s->data + s->data_len, recbuf, ret);
        s->data_len += ret; /* data_len always lags 1 byte behind actual allocation */
      }
    }

    /* If we get zero, there's nothing more to read */

    else if (ret == 0)
    {
      int consumed;

      s->last = now;

      /* Force a terminator at the end - we're expecting no binary data so */
      /* this ensures correct termination and makes life easier later      */

      s->data[s->data_len] = '\0'; /* Correct as data_len is always 1 byte behind actual allocation */
      dprintf(("", "status_proceed_receving: Receive complete with %d bytes -\n'%s'\n", s->data_len, s->data));

      /* printf("\nReceive:\n===\n%s\n=== for %p\n",s->data,s); */

      /* We've received the response now */

      s->reported_state |= VC_Status_ResponseReceived;

      /* Parse the response and move to the appropriate state */

      consumed = headers_parse_response(s);

      if (consumed < 0)
      {
        s->state = protostate_ERROR_MEM;
      }
      else
      {
        rtsp_header * h = headers_find_header(s->headers,
                                              Headers_HeaderName_Connection);


        s->reported_state |= VC_Status_MoreInformationAvailable;

        /* Did we get Connection: close? */

        if (h != NULL && !Strcmp_ci(h->value, Headers_HeaderValue_Connection))
        {
          /* Yes. Close our socket */

          dprintf(("", "status_proceed_receving: Connection: close detected, closing this end\n"));

          close_socket(&s->sd);
        }

        /* If we've not got a server session, try to find one from this response. */
        /* Don't bother with this if we're a child though because if we need a    */
        /* session we'll be using the parent's.                                   */

        if (s->server_session == NULL && s->parent == NULL)
        {
          char * store;

          h = headers_find_header(s->headers,
                                  Headers_HeaderName_Session);

          if (h != NULL)
          {
            s->server_timeout = Session_Timeout_Default;

            /* Find the session ID. It'll be terminated by ';' or end of string */

            store = strchr(h->value, ';');
            if (store != NULL) *store = '\0';

            s->server_session = Strdup(h->value);

            /* Find "timeout" then "=" */

            if (store != NULL)
            {
              *store = ';';

              store = strstr(h->value, Headers_HeaderValue_Session);

              if (store != NULL)
              {
                while (*store != '\0' && *store != '=') store++;
                if (*store == '=') store++;
                while (*store != '\0' && *store <= ' ') store++;

                s->server_timeout = atoi(store);
                if (s->server_timeout == 0) s->server_timeout = Session_Timeout_Default;
              }
            }

            /* Ensure the timeout is in centiseconds, but keep half the value */
            /* to avoid having to say "server_timeout / 2" for the inter-ping */
            /* delay elsewhere.                                               */

            s->server_timeout *= 50;

            dprintf(("", "status_proceed_receving: New session '%s', timeout %d\n", s->server_session ? s->server_session : "<out of memory>", s->server_timeout));
          }
        }

        s->state = protostate_COMPLETED;
      }

      *repeat = true;
      return false;
    }

    /* If we get < 0, there was some error */

    else
    {
      if (errno != EWOULDBLOCK)
      {
        dprintf(("", "status_proceed_receving: Error = %d\n", errno));

        s->state = protostate_ERROR_READ;
        *repeat  = true;
      }
      else
      {
        /* Check timeout */

        if (utils_time_difference(s->last, now) > Headers_Timeout_General)
        {
          s->state = protostate_ERROR_TIMEOUT;
          *repeat  = true;
        }
        else if (s->callout_set == 0)
        {
          dprintf(("", "status_proceed_receving: Setting a %dcs callout for receive timeout\n", Session_State_Retry));

          s->callout_set = 1;
          timeout(status_proceed_on_callout, s, Session_State_Retry);
        }
      }

      return false;
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_pumping()                                   */
/*                                                            */
/* State machine handler for a pumping (data movement) state. */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_pumping(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_pumping: Pumping\n"));

  return false;
}

/**************************************************************/
/* status_proceed_completed()                                 */
/*                                                            */
/* State machine handler for a completed state (tidy up).     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_completed(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_completed: Completed.\n"));

  if (s->destruct)
  {
    /* We're on the way out - no status change to Video Control... */

    dprintf(("", "status_proceed_completed: Session self-destructing (completed), state machine exitting\n"));
    session_free_item(s);
    return true;
  }
  else
  {
    _kernel_oserror * e;
    bool              prepare;

    /* We're more or less finished, just need to let Video Control */
    /* know about the status change.                               */

    if (s->play_record != NULL && s->started == 0) prepare = true;
    else                                           prepare = false;

    e = _swix(VideoControl_ProtocolNotify,
              _INR(0,4),

              0,
              s->id,
              VideoControlProtocolNotifyResponseReceived,
              prepare ? VC_ProtocolNotify_ResponseReceived_Prepare : 0,
              s->play_record);

    /* Yikes, Video Control had a problem */

    if (e != NULL)
    {
      final.errnum = e->errnum;
      strncpy(final.errmess, e->errmess, sizeof(final.errmess));

      s->state = protostate_ERROR_VCPN;
      *repeat  = true;

      return false;
    }

    /* Things seem to be working */

    else if (prepare)
    {
      s->started = 1;
    }
  }

  return false;
}

/**************************************************************/
/* status_check_error()                                       */
/*                                                            */
/* Examine a session structure to see if there's an error     */
/* state and if so return an appropriate _kernel_oserror.     */
/*                                                            */
/* Parameters: Pointer to the session structure to examine.   */
/*                                                            */
/* Returns:    NULL or pointer to a filled in _kernel_oserror */
/*             if the session was in an error state.          */
/**************************************************************/

_kernel_oserror * status_check_error(session * s)
{
  _kernel_oserror * e = NULL;

  switch (s->state)
  {
    /* Error states: Various things went wrong... */

    case protostate_ERROR:
    case protostate_ERROR_DEAD:
    case protostate_ERROR_CONNECTION:
    case protostate_ERROR_NO_TOKEN:
    case protostate_ERROR_NOT_IMPLEMENTED:
    {
      char en[16];

      sprintf(en, "%d", errno);

      e = make_error(rtspovs_ERROR_CONNECT_GENERAL, 1, en);
    }
    break;

    case protostate_ERROR_WRITE:
    {
      e = make_error(rtspovs_ERROR_CONNECT_WRITE, 0);
    }
    break;

    case protostate_ERROR_READ:
    {
      e = make_error(rtspovs_ERROR_CONNECT_READ, 0);
    }
    break;

    case protostate_ERROR_MEM:
    {
      e = make_error(rtspovs_ERROR_MEMORY_EXHAUSTED, 0);
    }
    break;

    case protostate_ERROR_TIMEOUT:
    {
      e = make_error(rtspovs_ERROR_CONNECT_TIMEOUT, 0);
    }
    break;

    case protostate_ERROR_DNS:
    {
      char * host;

      if (s->url && s->url->host && *s->url->host) host = s->url->host;
      else                                         host = "<?>";

      e = make_error(rtspovs_ERROR_CONNECT_DNS, 1, host);
    }
    break;

    case protostate_ERROR_VCPN:
    {
      e = &final;
    }
    break;
  }

  if (e != NULL && strlen(e->errmess) < (sizeof(e->errmess) - 12))
  {
    sprintf(strchr(e->errmess, '\0'), " (%08X)", (unsigned int) s);
  }

  return e;
}
