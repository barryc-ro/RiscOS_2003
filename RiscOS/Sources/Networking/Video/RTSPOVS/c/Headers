/**************************************************************/
/* File:    Headers.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Header writing and parsing functions.             */
/*                                                            */
/* Author:  S.N.Brodie.                                       */
/*                                                            */
/* History: 26-Nov-1999 (ADH): Imported.                      */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <stdbool.h>

#include <kernel.h>
#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Generic.h"
#include "Global.h"
#include "Headers.h"
#include "MD5.h"
#include "Module.h"
#include "Parameters.h"

/* Local variables */

static unsigned int header_sequence = 1;

/* Local functions */

static void headers_check_for_exceptions (session * s);

/**************************************************************/
/* headers_add_header()                                       */
/*                                                            */
/* Add a header structure to the tail of the given list.      */
/*                                                            */
/* Parameters: Pointer to the head pointer for the list,      */
/*             (may point to NULL if the list is empty);      */
/*                                                            */
/*             Pointer to the header name (without ':');      */
/*                                                            */
/*             Pointer to the header value.                   */
/*                                                            */
/* Returns:    Pointer to the new header item, or NULL if     */
/*             memory allocation failed. The pointer to the   */
/*             list head is updated if the list was initially */
/*             empty.                                         */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

rtsp_header * headers_add_header(rtsp_header ** list, const char * header, const char * value)
{
  const size_t   header_len = strlen(header) + 1;
  const size_t   value_len  = strlen(value) + 1;
  const size_t   size       = header_len + value_len + offsetof(rtsp_header, text);
  rtsp_header  * h          = malloc(size);

  if (h == NULL) return NULL;

  h->next   = NULL;
  h->header = h->text;

  memcpy(h->text, header, header_len);
  h->value = h->text + header_len;
  memcpy(h->value, value, value_len);

  if (*list == NULL)
  {
    *list = h;
  }
  else
  {
    rtsp_header * plist;
    for (plist = *list; plist->next; plist = plist->next) ;;
    plist->next = h;
  }

  return h;
}

/**************************************************************/
/* headers_add_below_head()                                   */
/*                                                            */
/* Add a header structure immediately after the head item of  */
/* the given list. This must only be called if there is at    */
/* least one item in the list.                                */
/*                                                            */
/* Parameters: Pointer to the head pointer for the list,      */
/*             (may not point to NULL);                       */
/*                                                            */
/*             Pointer to the header name (without ':');      */
/*                                                            */
/*             Pointer to the header value.                   */
/*                                                            */
/* Returns:    Pointer to the new header item, or NULL if     */
/*             memory allocation failed.                      */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

rtsp_header * headers_add_below_head(rtsp_header ** list, const char * header, const char * value)
{
  const size_t   header_len = strlen(header) + 1;
  const size_t   value_len  = strlen(value) + 1;
  const size_t   size       = header_len + value_len + offsetof(rtsp_header, text);
  rtsp_header  * h          = malloc(size);

  if (h == NULL) return NULL;

  h->next   = NULL;
  h->header = h->text;

  memcpy(h->text, header, header_len);
  h->value = h->text + header_len;
  memcpy(h->value, value, value_len);

  h->next       = (*list)->next;
  (*list)->next = h;

  return h;
}

/**************************************************************/
/* headers_add_sequence_header()                              */
/*                                                            */
/* Add a sequence header (RTSP-specific) to the given header  */
/* list below the head item (so the list must NOT be empty).  */
/* Increments the sequence number by 1.                       */
/*                                                            */
/* Parameters: Pointer to the head pointer for the list,      */
/*             (may not point to NULL).                       */
/*                                                            */
/* Returns:    Pointer to the new header item, or NULL if     */
/*             memory allocation failed.                      */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

rtsp_header * headers_add_sequence_header(rtsp_header ** list)
{
  char number[12];

  sprintf(number, "%u", header_sequence++);

  return headers_add_below_head(list, Headers_HeaderName_Sequence, number);
}

/**************************************************************/
/* headers_delete_header()                                    */
/*                                                            */
/* Remove a header item from the list.                        */
/*                                                            */
/* Parameters: Pointer to the head pointer for the list;      */
/*                                                            */
/*             Pointer to the header item to remove.          */
/*                                                            */
/* Returns:    The pointer to the list head is updated to     */
/*             NULL if the deleted item was the last in the   */
/*             list or to the new head value if the deleted   */
/*             item was at the head.                          */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

void headers_delete_header(rtsp_header ** list, rtsp_header * header)
{
  if (header == NULL) return;

  if (*list == header)
  {
    *list = header->next;
  }
  else
  {
    rtsp_header * plist;

    for (plist = *list; plist->next; plist=plist->next)
    {
      if (plist->next == header)
      {
        plist->next = header->next;
        break;
      }
    }
  }

  free(header);
}

rtsp_header *headers_find_header(rtsp_header *list, char *header)
{
  for (; list; list=list->next) {
    if (Strcmp_ci(list->header, header) == 0) break;
  }

  return list;
}

void headers_free_headers(rtsp_header **list)
{
  while (*list) headers_delete_header(list, *list);
}


/* This function takes the list of tokens specified as the value for the Connection header
 * and removes any headers with matching names.  This is required behaviour for HTTP/1.1.
 */
void headers_filter_connection_tokens(rtsp_header **list, char *tokens)
{
  for (;;) {
    char *comma, *end, saved;

    while (*tokens == ',' || (*tokens != '\0' && isspace(*tokens))) ++tokens;
    if (*tokens == '\0') break;

    comma = strchr(tokens, ',');
    if (comma != NULL) {
      end = comma++;
    }
    else {
      comma = end = strchr(tokens, '\0');
    }

    /* We now know we are not looking at an empty list member token */
    for (--end; isspace(*end); --end) ;;
    ++end;
    /* Found it! Do NOT get fooled by removing ourselves! Shouldn't happen but ... */
    if (Strncmp_ci(tokens, "connection", sizeof("connection")) != 0) {

      dprintf(("", "Filtering header named in connection: %.*s\n", end-tokens, tokens));

      saved = *end;
      *end = '\0';
      for (;;) {
        rtsp_header *h = headers_find_header(*list, tokens);
        if (h == NULL) break;

        dprintf(("", "Deleting '%s' header\n", h->header));

        headers_delete_header(list, h);
      }
      *end = saved;
    }
    tokens = comma;
  }

}

/**************************************************************/
/* headers_construct_specific_header_buffer()                 */
/*                                                            */
/* Generate a full request or response header into a given    */
/* buffer from a given set of 'header' structures.            */
/*                                                            */
/* Parameters: Pointer to the list of header structures;      */
/*                                                            */
/*             Pointer to a char *, into which a pointer to   */
/*             the malloced buffer holding the constructed    */
/*             request/response is written;                   */
/*                                                            */
/*             An amount to over-allocate the buffer by, if   */
/*             required (e.g. to insert body data);           */
/*                                                            */
/*             Zero if this is for a request, else it is for  */
/*             a response - this affects how the first line   */
/*             is constructed.                                */
/*                                                            */
/* Returns:    0 if memory allocation failed, else amount of  */
/*             data written to the buffer. The return value   */
/*             must be used to detect allocation failure and  */
/*             may also be used to work out where to attach   */
/*             extra body data, if required. Note that the    */
/*             block allocated is always oversize by 1 byte   */
/*             to allow for a NUL terminator if required.     */
/*                                                            */
/* Assumes:    All pointers are non-NULL and valid.           */
/**************************************************************/

size_t headers_construct_specific_header_buffer(rtsp_header * headers, char ** buffer, size_t extra, unsigned int response)
{
  rtsp_header * h;
  char        * ptr;
  size_t        header_size = extra + sizeof("\r\n");

  /* This overestimates actual data by 1 byte as the first header won't have ':' */
  /* appended. In passing, then, it accounts for the NUL terminator.             */

  for (h = headers; h; h = h->next)
  {
    header_size += strlen(h->header) + strlen(h->value) + sizeof(": \r\n") - 1;
  }

  if (response == 0)
  {
    /* We'll also add this to the first line, and since we've already accounted */
    /* for the NUL terminator, don't forget '-1'.                               */

    header_size += sizeof(Headers_Supported) - 1; /* See Headers.h */
  }

  dprintf(("", "Need %d bytes to hold the entire header\n", header_size));

  *buffer = malloc(header_size);
  if (*buffer == NULL) return 0;

  ptr = *buffer;

  for (h = headers; h; h = h->next)
  {
    dprintf(("", "Writing '%s' header to buffer (value '%s')\n", h->header, h->value));

    if (h == headers)
    {
      if (response == 0) ptr += sprintf(ptr, "%s %s%s\r\n", h->header, h->value, Headers_Supported);
      else               ptr += sprintf(ptr, "%s %s\r\n",   h->header, h->value);
    }
    else
    {
      ptr += sprintf(ptr, "%s: %s\r\n", h->header, h->value);
    }
  }

  ptr += sprintf(ptr, "\r\n");

  return (ptr - *buffer);
}

/* This function generates a full request or response header into ses->full_request
 * using the data in ses->headers.  The remembered header list is then DELETED from ses->headers
 * The current header pointer is set to a null pointer if unable to claim space for the buffer.
 * Return value is from headers_construct_specific_header_buffer.
 */

size_t headers_construct_header_buffer(session *ses, size_t extra, unsigned int response)
{
  int ret = headers_construct_specific_header_buffer(ses->headers, &ses->full_request, extra, response);

  headers_free_headers(&ses->headers);

  return ret;
}

/**************************************************************/
/* headers_delimit_header()                                   */
/*                                                            */
/* Take a buffer holding an HTTP-like header and split it     */
/* into the header itself and its value. Returns zero for an  */
/* unparseable block of data. The input buffer IS MODIFIED.   */
/*                                                            */
/* Parameters: Pointer to the buffer holding the header;      */
/*                                                            */
/*             Pointer to a char * which will be updated to   */
/*             hold NULL if there was no more data in the     */
/*             input buffer after parsing this header, else   */
/*             it will hold a pointer to the next line in     */
/*             that input buffer;                             */
/*                                                            */
/*             Pointer to a char * updated to point to the    */
/*             header name, if 1 is returned;                 */
/*                                                            */
/*             Pointer to a char * updated to point to the    */
/*             header value, if 1 is returned.                */
/*                                                            */
/* Returns:    1 for success, 0 for failure (couldn't parse   */
/*             contents of input buffer).                     */
/**************************************************************/

static int headers_delimit_header(char * buffer, char ** eobuffer, char ** header, char ** value)
{
  char * ptr;

  /* Locate line terminator (if present) else string term.*/

  ptr = buffer + strcspn(buffer, "\n\r");

  if (*ptr)
  {
    /* Terminate buffer */

    *ptr = '\0';

    if (eobuffer)
    {
      /* Return that there was more than one line in buffer */

      *eobuffer = ptr + 1;
    }
  }
  else
  {
    /* Return that there was no more data in buffer */

    if (eobuffer) *eobuffer = NULL;
  }

  /* Strip trailing spaces */

  while (ptr > buffer)
  {
    if (isspace(ptr[-1]))
    {
      *--ptr = '\0';
    }
    else break;
  }

  /* Skip leading spaces */

  buffer += strspn(buffer, " \t");

  /* Bail out if the string is now empty */

  if (!*buffer)
  {
    *header = 0;
    *value  = 0;

    return 0;
  }

  /* Skip over the header name */

  *header = buffer;
  buffer += strcspn(buffer, " :\t");

  /* If the header has no data (value), is it corrupt? */

  if (!*buffer)
  {
    *value = 0;

    return 0;
  }

  /* Terminate the header name and move on; locate the start of the */
  /* header value and store it                                      */

  *buffer++ = '\0';
  *value = buffer + strspn(buffer, " :\t");

  /* Success */

  return 1;
}

/* This function returns non-zero if it managed to locate a complete header line */

static int headers_check_found_header(char *buffer, char **next, int continuations)
{
  char *ptr, *nl;

  dprintf(("", "headers_check_found_header: Called\n"));

  /* Find the first \r and \n characters in the buffer, if any */
  ptr = strchr(buffer, '\r');
  nl = strchr(buffer, '\n');

  if (!ptr || (nl && ptr && (nl < ptr))) {
    /* If there was a \n and \r AND \n occurred before \r, make ptr
     * point at the \n instead (because we're using EOL of \n and
     * it looks as if we might have picked up a \r somewhere in the
     * object body which we DON'T want to see yet
     */
    ptr = nl;
  }
  /* At this point, ptr can only be NULL if nl is also NULL */

  if (ptr && !nl) {
    /* found a \r but didn't find a \n */
    if (ptr[1] == ' ' || ptr[1] == '\t') {
      /* Was this a continuation line? */
      ptr[0] = ' '; /* blank the spurious \r character out */
      dprintf(("", "headers_check_found_header: Recursive call\n"));
      return headers_check_found_header(buffer, next, continuations);
    }

    if (!ptr[1]) {
      /* BUT the \r happened to be at the end of the buffer
       * so we'll go around again in order to forcibly pick
       * up the \n on the next read.
       */
      *next = NULL;
      dprintf(("", "headers_check_found_header: Returning 0\n"));
      return 0;
    }

    /* To get here, ptr points to a lonely \r character at a real header end */
  }
  else if (!ptr) {
    /* neither \r nor \n found */
    *next = NULL;
    dprintf(("", "headers_check_found_header: Returning 0\n"));
    return 0;
  }
  else {
    if (ptr != nl) {
      /* To get here, we have found both a \r and a \n */
      if (ptr[1] == '\n') {
        nl = ptr+1;
        *ptr++ = ' '; /* Blank out the \r */
      }
    }
    else {
      /* Found just a \n - check at end of buffer */
      if (nl[1] == '\0' && continuations && nl != buffer) {
        /* At end of buffer */
        *next = NULL;
        dprintf(("", "headers_check_found_header: Returning 0\n"));
        return 0;
      }
    }
  }

  /* To get here, ptr is non NULL and points at the end of line character
   * which WILL be either \r or \n, BUT the next character ptr[1] will not
   * be another newline indicator unless this is the end of the headers */

  if (ptr == buffer || (ptr == (buffer+1) && buffer[0] == ' ')) {
    /* Was the last header - send blank string back */
    *buffer = '\0';
    *next = ptr+1;
    dprintf(("", "headers_check_found_header: Found one\n"));
    return 1;
  }

  if (ptr[1] == ' ' || ptr[1] == '\t') {
    /* This was a continuation line */
    *ptr = ' ';  /* exterminate the previous end of line */
    dprintf(("", "headers_check_found_header: Recursive call\n"));
    return headers_check_found_header(buffer, next, continuations);
  }

  *ptr++ = '\0';
  *next = ptr;
  dprintf(("", "headers_check_found_header: Found one\n"));
  return 1;
}

/* This function parses the user supplied headers.  We use this to "fix up" any problems in the
 * headers - such as removing things we don't like the look of - like Host headers.  We supply
 * our own Host headers - and our ones are correct!  We also object to Connection headers (our
 * client has no business interfering with our connections to servers) and user-agent headers
 * (we provide a perfectly good API for altering the user-agent already).
 */
int headers_parse_user_header(char *buffer, int buflen, session *ses)
{
  char *next, *eob, *header, *value;
  int consumed = 0, ended = 0;

//  dprintf(("", "Parsing user supplied header block\n"));
//  protocol_dump(buffer, buflen);

  while (!ended && headers_check_found_header(buffer, &next, 1)) {
    if (headers_delimit_header(buffer, &eob, &header, &value)) {
      if (header != NULL) {
        if (Strcmp_ci(header, "host") != 0 && Strcmp_ci(header, "connection") != 0 &&
          Strcmp_ci(header, "user-agent") != 0) {
          headers_add_header(&ses->headers, header, value ? value : "");
        }
      }
    }
    consumed += (next - buffer);
    buffer = next;
    if (consumed >= buflen) ended = true;
    if (header == NULL && value == NULL) {
      ended = true;
    }
  }

//  dprintf(("", "End parse user supplied header block.  Data remaining: %d bytes\n", buflen - consumed));
//  protocol_dump(buffer, buflen - consumed);

  return consumed;
}

/**************************************************************/
/* headers_parse_response()                                   */
/*                                                            */
/* Takes a server response from a session and builds a list   */
/* of headers for the session based on it. Fills in the       */
/* response code value too.                                   */
/*                                                            */
/* Remember, there may be no identifiable headers in the      */
/* data block, so always use the return code to determine     */
/* success or failure of (e.g.) memory allocations within the */
/* function rather than checking for the presence of a header */
/* list on exit.                                              */
/*                                                            */
/* If internal memory allocations do indeed fail, any         */
/* headers built thus far will be thrown away.                */
/*                                                            */
/* The buffer will be altered in passing, and should end up   */
/* rebuilt with the server's headers in a consistent and      */
/* clean form followed by the server's body data response.    */
/*                                                            */
/* Parameters: Pointer to the session structure to work with. */
/*                                                            */
/* Returns:    -1 if memory allocation failed, else amount of */
/*             data in the block looked at. The data block    */
/*             itself is left allocated but IS altered.       */
/*                                                            */
/* Assumes:    The session pointer is non-NULL and valid.     */
/**************************************************************/

int headers_parse_response(session * ses)
{
  char * before;
  char * next;
  char * eob;
  char * header;
  char * value;
  char * recon;
  int    recon_len = 0;
  int    consumed  = 0;
  int    ended     = 0;

  dprintf(("", "headers_parse_response: Called for %p\n", ses));

  before = ses->data;

  while (!ended && headers_check_found_header(ses->data, &next, 1))
  {
    if (headers_delimit_header(ses->data, &eob, &header, &value))
    {
      if (header != NULL)
      {
        rtsp_header * item = headers_add_header(&ses->headers,
                                                header,
                                                value ? value : "");

        if (item == NULL)
        {
          dprintf(("", "headers_parse_response: Allocation failure, bailing\n"));

          headers_free_headers(&ses->headers);
          ses->data = before;
          return -1;
        }
      }
    }

    consumed += (next - ses->data);
    ses->data = next;

    if (consumed >= ses->data_len) ended = true;

    if (header == NULL && value == NULL)
    {
      ended = true;
    }
  }

  /* Work out the response code */

  if (ses->headers != NULL)
  {
    ses->response_code = (unsigned int) strtoul(ses->headers->value, NULL, 10);

    /* Turn things like 456 into 501 for the client's convenience */

    headers_check_for_exceptions(ses);
  }
  else ses->response_code = 0;

  /* Right, we've used 'consumed' bytes so the body data starts */
  /* wherever ses->data is currently pointing. Reconstruct the  */
  /* sanitised headers in another buffer for returning to the   */
  /* client as the textual response (Protocol_MoreInformation), */
  /* if required...                                             */

  recon_len = headers_construct_specific_header_buffer(ses->headers,
                                                       &recon,
                                                       0,  /* No oversize allocation */
                                                       1); /* This is for a response */

  if (recon_len != 0 && recon != NULL)
  {
    /* Do we need to shrink or enlarge the buffer? */

    if (consumed != recon_len)
    {
      void * newdata;

      if (consumed > recon_len)
      {
        /* The new headers are smaller, so before we shrink the buffer and chop */
        /* the end off our body data, shuffle that data down to close the gap.  */
        /* If the realloc manages to fail even though it's a shrink, we've      */
        /* mangled the buffer... But see later, we throw it away in that case.  */
        /* The '+1' is there as data_len is always 1 behind the actual allocat- */
        /* ion, to allow for a zero terminator.                                 */

        memmove(before + recon_len, before + consumed, ses->data_len + 1 - consumed);
      }

      newdata = module_realloc(before, ses->data_len + 1 + recon_len - consumed);

      if (newdata == NULL)
      {
        free(recon);
        recon = NULL;
        recon_len = 0;
      }
      else
      {
        before = newdata;

        if (consumed < recon_len)
        {
          /* The new headers were larger, so shuffle the body data up */
          /* to make room for them.                                   */

          memmove(before + recon_len, before + consumed, ses->data_len + 1 - consumed);
        }

        ses->data_len += recon_len - consumed;
      }
    }

    /* Copy in the new headers and free the reconstruction block */

    memcpy(before, recon, recon_len);
    free(recon);
  }

  ses->data = before;

  /* If we couldn't reconstruct the headers because of low RAM, free */
  /* the whole response block (i.e. give up and try to minimise RAM  */
  /* usage, besides, it may be mangled by now - see above).          */

  if (recon == NULL || (recon_len == 0 && consumed != 0))
  {
    void * f = ses->data;
    int    l = ses->data_len;

    /* Can't reconstruct, no RAM :-( */

    ses->data     = NULL;
    ses->data_len = 0;

    free(f);
    consumed = l; /* Say we took everything */
  }

  dprintf(("", "headers_parse_response: Successful, consumed %d bytes, response %d\n", consumed, ses->response_code));

  return consumed;
}

/**************************************************************/
/* headers_check_for_exceptions()                             */
/*                                                            */
/* Once headers have been parsed into a block, perform any    */
/* local modifications - e.g. change 456 responses into 501   */
/* for the client's convenience.                              */
/*                                                            */
/* Fails silently. Headers are guaranteed legal on exit.      */
/*                                                            */
/* Parameters: Pointer to a session structure containing the  */
/*             headers and response code to examine.          */
/**************************************************************/

static void headers_check_for_exceptions(session * s)
{
  if (s == NULL || s->headers == NULL) return;

  /* Change 456 to 501 */

  if (s->response_code == Header_Exclusion_456)
  {
    rtsp_header * h = NULL;
    rtsp_header * o = NULL;

    /* Build a header with the alternative response in */

    if (
         headers_add_header(&h,
                            Header_Replace_456_Header,
                            Header_Replace_456_Value)
         == NULL
       )
       return;

    /* Swap out the existant head of the list for this one */

    o          = s->headers;
    h->next    = o->next;
    o->next    = NULL;
    s->headers = h;

    headers_delete_header(&o, o);

    s->response_code = (unsigned int) strtoul(Header_Replace_456_Value, NULL, 10);
  }
}

/**************************************************************/
/* headers_extract_quoted_string()                            */
/*                                                            */
/* Return the subsection of a string from the start up to but */
/* not including a terminating '"' or the end of the string,  */
/* whichever comes first. The copy is malloc()'d so must be   */
/* free()'d later.                                            */
/*                                                            */
/* Parameters: Pointer to the first character of the quoted   */
/*             section (not including leading '"').           */
/*                                                            */
/* Returns:    malloc()'d string up to but not including      */
/*             terminating '"', or up to the end of the       */
/*             string, whichever comes first.                 */
/**************************************************************/

char * headers_extract_quoted_string(const char * start)
{
  char         * end = strchr(start, '"');
  char         * ret;
  unsigned int   len;

  if (end == NULL) return Strdup(start);

  len = ((unsigned int) end) - ((unsigned int) start);
  if (len == 0) return Strdup("");

  ret = malloc(len);
  if (ret == NULL) return NULL;

  strncpy(ret, start, len);
  ret[len] = '\0';

  return ret;
}

/**************************************************************/
/* headers_parse_wwwa()                                       */
/*                                                            */
/* Parse a WWW-Authenticate header, extracting the realm,     */
/* opaque and nonce values and storing them in the given      */
/* session structure.                                         */
/*                                                            */
/* Parameters: Pointer to the session to update;              */
/*                                                            */
/*             Pointer to the RTSP header structure to        */
/*             examine (may be NULL for no side effects).     */
/*                                                            */
/* Returns:    'true' in all conditions (e.g. parsing was a   */
/*             success, header pointer was NULL, couldn't     */
/*             parse correctly) except an out of memory       */
/*             condition when trying to store the extracted   */
/*             data from the header's value, in which case    */
/*             'false' is given back.                         */
/**************************************************************/

bool headers_parse_wwwa(session * s, rtsp_header * h)
{
  /* The header parser here is deliberately crude - we are not tolerant of any value */
  /* which is not of the exact formatting and case we expect, in an attempt to be    */
  /* slightly more secure.                                                           */
  /*                                                                                 */
  /* Misparsing will lead eventually to an incorrect challenge response, which will  */
  /* lead to 403 Forbidden being returned. This is the safest failure mode.          */

  if (h != NULL)
  {
    /* Parse the value to obtain realm, nonce and opaque quantities; */
    /* must be present in that order.                                */

    const char * ptr    = h->value;
    const char * quote  = strchr(h->value, '"');
    const char * digest = NULL;
    const char * realm  = NULL;
    const char * opaque = NULL;
    const char * nonce  = NULL;

    /* "Digest " should appear before any double quote marks */

    if (quote != NULL)
    {
      digest = strstr(ptr,
                      Headers_HeaderValue_WWWAAuthType);
    }
    else return true;

    /* If it does, look for "realm=", which should also appear before */
    /* any double quote marks                                         */

    if (digest != NULL && digest < quote)
    {
      realm = strstr(digest + sizeof(Headers_HeaderValue_WWWAAuthType) - 1,
                     Headers_HeaderValue_WWWARealm);
    }
    else return true;

    /* If that worked, extract the value and skip past it */

    if (realm != NULL && realm < quote)
    {
      /* We add sizeof() and don't subtract one in order to skip past both the */
      /* string itself, and the opening double quote on the value.             */

      s->realm = headers_extract_quoted_string(realm + sizeof(Headers_HeaderValue_WWWARealm));
      if (s->realm == NULL) return false;
    }
    else return true;

    /* Next, find the first double quote mark after the realm value */

    ptr   = realm + sizeof(Headers_HeaderValue_WWWARealm) + strlen(s->realm) + 1;
    quote = strchr(ptr, '"');

    /* Look for a nonce value before the double quote mark */

    if (quote != NULL)
    {
      nonce = strstr(ptr,
                     Headers_HeaderValue_WWWANonce);
    }
    else return true;

    /* If that worked, extract the value and skip past it */

    if (nonce != NULL && nonce < quote)
    {
      s->nonce = headers_extract_quoted_string(nonce + sizeof(Headers_HeaderValue_WWWANonce));
      if (s->nonce == NULL) return false;
    }
    else return true;

    /* Find the first double quote mark after the nonce value */

    ptr   = nonce + sizeof(Headers_HeaderValue_WWWANonce) + strlen(s->nonce) + 1;
    quote = strchr(ptr, '"');

    /* Look for an opaque value before the double quote mark */

    if (quote != NULL)
    {
      opaque = strstr(ptr,
                      Headers_HeaderValue_WWWAOpaque);
    }
    else return true;

    /* If that worked, extract the value and skip past it */

    if (opaque != NULL && opaque < quote)
    {
      s->opaque = headers_extract_quoted_string(opaque + sizeof(Headers_HeaderValue_WWWAOpaque));
      if (s->opaque == NULL) return false;
    }
    else return true; /* Could fall through to the catch-all 'return' below, but
                       * subsequent additions below this point would then be at risk
                       * from forgetting to add this 'else' case...
                       */
  }

  /* Finished */

  return true;
}

/**************************************************************/
/* headers_add_challenge_response()                           */
/*                                                            */
/* Use a session's ticket-related fields to construct an      */
/* Authorization header answering a server challenge.         */
/*                                                            */
/* Will do nothing if there is insufficient information on a  */
/* challenge stored in the structure so may be called without */
/* checking for this externally, if required.                 */
/*                                                            */
/* Parameters: Pointer to the list of headers to add to;      */
/*                                                            */
/*             Pointer to a session structure containing the  */
/*             challenge, ticket and optional authinfo        */
/*             details;                                       */
/*                                                            */
/*             Pointer to the RTSP command name being sent    */
/*             (e.g. SETUP, PLAY, PAUSE).                     */
/*                                                            */
/* Returns:    Pointer to the new header item, or NULL for    */
/*             a malloc failure or an entry parameter failure */
/*             (no challenge or ticket in the given session,  */
/*             unsupported challenge type, etc.). Callers are */
/*             advised to treat any NULL response as an       */
/*             authorization failure rather than out of       */
/*             memory (since if that's really the case then   */
/*             it won't be long before something else fails). */
/**************************************************************/

rtsp_header * headers_add_challenge_response(rtsp_header ** list, session * ses, const char * method)
{
  rtsp_header   * ret;

  char          * authid;
  char          * authpw;
  char          * value;

  char          * md5_1;       /* These hold the strings to be run through the MD5 algorithm */
  char          * md5_2;
  char          * md5_3;

  size_t          md5_1_l;     /* These hold the lengths of the above strings */
  size_t          md5_2_l;
  size_t          md5_3_l;

  md5_context     md5_1_c;     /* Contexts for the three MD5 sessions */
  md5_context     md5_2_c;
  md5_context     md5_3_c;

  unsigned char   md5_1_s[16]; /* Buffers for the raw MD5 output for the three sessions */
  unsigned char   md5_2_s[16];
  unsigned char   md5_3_s[16];

  /* Do nothing if the global ticketing flag is clear */

  if (ticketing == false) return NULL;

  /* Can we even begin to construct a response? */

  if (
       list           == NULL ||
       method         == NULL ||
       ses            == NULL ||
       ses->ticket    == NULL ||
       ses->nonce     == NULL ||
       ses->opaque    == NULL ||
       ses->realm     == NULL ||
       ses->url       == NULL ||
       ses->url->full == NULL
     )
     return NULL;

  /* Extract the authorization ID (user name) and password (ticket secret) */

  authid = parameters_find_item(ses->ticket, Parameters_AuthID);
  authpw = parameters_find_item(ses->ticket, Parameters_AuthPW);

  if (authid == NULL || authpw == NULL) return NULL;

  /* Initialise the MD5 contexts */

  md5_init(&md5_1_c);
  md5_init(&md5_2_c);
  md5_init(&md5_3_c);

  /* Assemble the substrings to run through the MD5 algorithm */

  md5_1_l = strlen(authid) + strlen(ses->realm) + strlen(authpw) + 3; /* +3 for two colons and NUL */
  md5_1   = malloc(md5_1_l);

  if (md5_1 == NULL)
  {
    return NULL;
  }

  sprintf(md5_1, "%s:%s:%s", authid, ses->realm, authpw);

  md5_2_l = strlen(method) + strlen(ses->url->full) + 2; /* +2 for colon and NUL */
  md5_2   = malloc(md5_2_l);

  if (md5_2 == NULL)
  {
    free(md5_1);
    return NULL;
  }

  sprintf(md5_2, "%s:%s", method, ses->url->full);

  /* md5_1 and md5_2 need to be run through MD5 to construct the third string */

  md5_update(&md5_1_c, md5_1, (unsigned long) (md5_1_l - 1UL) * (unsigned long) sizeof(*md5_1));
  md5_update(&md5_2_c, md5_2, (unsigned long) (md5_2_l - 1UL) * (unsigned long) sizeof(*md5_2));

  md5_final(md5_1_s, &md5_1_c);
  md5_final(md5_2_s, &md5_2_c);

  /* We're finished with the first two strings now */

  free(md5_1);
  free(md5_2);

  /* The third string contains the MD5 data expressed as a set of 2 digit hex numbers */

  md5_3_l = (sizeof(md5_1_s) * 2) + (sizeof(md5_1_s) * 2) + strlen(ses->nonce) + 3; /* +3 for two colons and NUL */
  md5_3   = malloc(md5_3_l);

  if (md5_3 == NULL)
  {
    return NULL;
  }
  else
  {
    int    i;
    char * md5_3_ptr = md5_3;

    for (i = 0; i < sizeof(md5_1_s); i++)
    {
      sprintf(md5_3_ptr, "%02x", md5_1_s[i]);
      md5_3_ptr += 2;
    }

    *(md5_3_ptr++) = ':';

    sprintf(md5_3_ptr, "%s", ses->nonce);
    md5_3_ptr += strlen(ses->nonce);

    *(md5_3_ptr++) = ':';

    for (i = 0; i < sizeof(md5_2_s); i++)
    {
      sprintf(md5_3_ptr, "%02x", md5_2_s[i]);
      md5_3_ptr += 2;
    }
  }

  /* Now run MD5 on this string to get the final answer */

  md5_update(&md5_3_c, md5_3, (unsigned long) (md5_3_l - 1UL) * (unsigned long) sizeof(*md5_3));
  md5_final(md5_3_s, &md5_3_c);

  /* Compile the response header's value */

  value = malloc(sizeof(Headers_HeaderValue_AuthAuthType) - 1 + /* Exclude NUL */
                 sizeof(Headers_HeaderValue_AuthUsername) + 1 + /* +1 to account for opening and closing quotes around username */
                 strlen(authid)                           + 1 + /* +1 to account for comma */
                 sizeof(Headers_HeaderValue_AuthRealm)    + 1 + /* +1 to account for opening and closing quotes around username */
                 strlen(ses->realm)                       + 1 + /* +1 to account for comma */
                 sizeof(Headers_HeaderValue_AuthURI)      + 1 + /* (etc.) */
                 strlen(ses->url->full)                   + 1 +
                 sizeof(Headers_HeaderValue_AuthNonce)    + 1 +
                 strlen(ses->nonce)                       + 1 +
                 sizeof(Headers_HeaderValue_AuthOpaque)   + 1 +
                 strlen(ses->opaque)                      + 1 +
                 sizeof(Headers_HeaderValue_AuthResponse) + 1 +
                 sizeof(md5_3_s) * 2                      + 1); /* +1 to account for terminating NUL */

  if (value == NULL)
  {
    free(md5_3);
    return NULL;
  }
  else
  {
    int    pos, i;
    char * value_ptr;

    /* Write everything up to the response */

    sprintf(value,
            "%s%s\"%s\",%s\"%s\",%s\"%s\",%s\"%s\",%s\"%s\",%s\"%n",
            Headers_HeaderValue_AuthAuthType,
            Headers_HeaderValue_AuthUsername,
            authid,
            Headers_HeaderValue_AuthRealm,
            ses->realm,
            Headers_HeaderValue_AuthURI,
            ses->url->full,
            Headers_HeaderValue_AuthNonce,
            ses->nonce,
            Headers_HeaderValue_AuthOpaque,
            ses->opaque,
            Headers_HeaderValue_AuthResponse,
            &pos);

    value_ptr = value + pos;

    /* Write the response in the two-digit hex number form */

    for (i = 0; i < sizeof(md5_3_s); i++)
    {
      sprintf(value_ptr, "%02x", md5_3_s[i]);
      value_ptr += 2;
    }

    /* Don't forget terminating double quote and NUL */

    *(value_ptr++) = '"';
    *value_ptr     = '\0';
  }

  ret = headers_add_header(list,
                           Headers_HeaderName_Auth,
                           value);
  free(value);

  return ret;
}
