/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPOVS_Play.                           */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 08-Nov-1999 (ADH): Created.                       */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "RTSPOErrors.h"
#include "Session.h"
#include "Status.h"
#include "Utils.h"

#include "Play.h"

/* Local functions */

static bool play_slowmofwd (const char * scale);

/**************************************************************/
/* play_slowmofwd()                                           */
/*                                                            */
/* Work out whether reduced data rate slow motion forwards    */
/* play should be used for a given scale/speed specifier.     */
/*                                                            */
/* Parameters: Scale/speed specifier.                         */
/*                                                            */
/* Returns:    true to use reduced data rate slow motion      */
/*             forwards play (send a Speed header rather than */
/*             Scale), else false.                            */
/**************************************************************/

static bool play_slowmofwd(const char * scale)
{
  if (
       scale != NULL &&

       _swix(OS_Module,
             _INR(0,1),

             18,
             ReducedRateSlowmoSupportModule) /* Play.h */

       == NULL

       &&
       (
         !strncmp(scale, "0.", 2) ||
         *scale == '.'
       )
     )
     return true;

  return false;
}

/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement RTSPOVS_Play. See the Video Control              */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  session * s         = session_find_by_id(r->r[1]);
  bool      fail      = false;
  bool      slowmofwd = false; /* This is true for slowmo forward play     */
  bool      play      = true;  /* This is true for any non-pause play mode */
  int       port;
  char    * scale;

  dprintf(("", "play_play: Called\n"));

  if (s == NULL)
  {
    dprintf(("", "play_play: ID not found\n"));

    return make_error(rtspovs_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (
       s->state == protostate_DNS       ||
       s->state == protostate_CONNECTED ||
       s->state == protostate_SENDING   ||
       s->state == protostate_RECEIVING ||
       s->state == protostate_PUMPING
     )
  {
    dprintf(("", "play_play: In progress\n"));

    return make_error(rtspovs_ERROR_IN_PROGRESS, 0);
  }

  if (s->server_session == NULL)
  {
    dprintf(("", "play_play: No server session\n"));

    return make_error(rtspovs_ERROR_NO_SERVER_SESSION, 0);
  }

  /* For forwards slow-mo, we don't use Scale, we use Speed. You can */
  /* just deliver the data more slowly. OVS' slowmo with Scale is    */
  /* awful; using Speed gives a much better result.                  */

  scale = (char *) r->r[3];

  if (scale && !strcmp(scale, "0")) play      = false;
  else                              slowmofwd = play_slowmofwd(scale);

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Copy R3 away */

  s->play_record = Strdup(scale == NULL ? "" : scale);

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               play ? Headers_CommandName_Play : Headers_CommandName_Pause,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* Range */

  else if (
            r->r[2] != 0 &&

            headers_add_header(&s->headers,
                               Headers_HeaderName_Range,
                               (char *) r->r[2])
            == NULL
          )
          fail = true;

  /* If we're not pausing, the playback rate - first, Scale playback (trick play) */

  else if (
            play          &&
            !slowmofwd    &&
            scale != NULL &&

            headers_add_header(&s->headers,
                               Headers_HeaderName_Scale,
                               scale)
            == NULL
          )
          fail = true;

  /* Second, Speed playback (alter data delivery rate, for slowmo forwards play) */

  else if (
            play          &&
            slowmofwd     &&
            scale != NULL && /* It should never be if slowmofwd is true, but just in case... */

            headers_add_header(&s->headers,
                               Headers_HeaderName_Speed,
                               scale)
            == NULL
          )
          fail = true;

  /* No AEN, so Connection: close */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Connection,
                               Headers_HeaderValue_Connection)
            == NULL
          )
          fail = true;

  /* x-playNow to defeat play queueing, if the server is new enough to support it */

  else if (
            play &&
            headers_add_header(&s->headers,
                               Headers_HeaderName_PlayNow,
                               Headers_HeaderValue_PlayNow)
            == NULL
          )
          fail = true;

  /* Lastly, the session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail)
  {
    dprintf(("", "play_play: Out of memory\n"));
    return make_error(rtspovs_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPOVS_DefaultPort;

  s->sd = opensock(s->url->host,
                   port,
                   NULL,
                   &s->state,
                   -1);

  s->last = utils_read_time();

  dprintf(("", "play_play: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Set the state machine going to see errors and DNS stuff. The call */
  /* to session_reset_session should've cleared the callout but it     */
  /* never hurts to be sure (in future maybe stuff could go on in the  */
  /* background that could have set a callout between the reset and    */
  /* this part of the code).                                           */

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_play: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_replay_on_callout()                                   */
/*                                                            */
/* A CallOut handler (see CallOut.h) which loops video        */
/* playback through play_replay.                              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_replay_on_callout(void * handle)
{
  session * s = (session *) handle;

  if (s->loop_ready != 0)
  {
    play_replay(s);
    s->loop_ready = 0;
  }
}

/**************************************************************/
/* play_replay()                                              */
/*                                                            */
/* Issue an "in-the-background" PLAY command to loop video    */
/* playback at the client end.                                */
/*                                                            */
/* Parameters: Pointer to a session struct for the video to   */
/*             loop.                                          */
/**************************************************************/

_kernel_oserror * play_replay(session * s)
{
  _kernel_oserror * e;
  bool              fail = false;
  bool              slowmofwd;
  char            * port;
  char            * range;
  char            * scale;
  session         * new_s;

  dprintf(("", "play_replay: Called for %p\n", s));

  if (s->server_session == NULL)
  {
    dprintf(("", "play_replay: No server session\n"));

    return make_error(rtspovs_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Cancel and GET_PARAMETER manually - it won't be done automatically */
  /* as we're not resetting this session, we're spawning a new one      */

  if (s->gp_set != 0)
  {
    untimeout(getparam_proceed_on_callout, s);
    s->gp_set = 0;
  }

  if (s->child) session_free_item(s->child);

  /* Create a new session */

  e = session_new_session(&new_s);

  if (e)
  {
    dprintf(("", "play_replay: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  if (new_s == NULL)
  {
    dprintf(("", "play_replay: Out of memory for new_s\n"));
    return make_error(rtspovs_ERROR_MEMORY_EXHAUSTED, 0);
  }

  new_s->id     = ++id_counter; /* See Global.h */

  new_s->parent = s;
  s->child      = new_s;

  /* We *should* have the play scale (speed) stored */

  scale = s->play_record == NULL ? Headers_HeaderValue_Scale : s->play_record;
  if (*scale == '\0') scale = Headers_HeaderValue_Scale;

  /* Range will depend on direction of play */

  if (*scale == '-')
  {
    range = Headers_HeaderValue_Range_Rwd;
  }
  else
  {
    range = Headers_HeaderValue_Range_Fwd;
  }

  /* Slow motion forwards play? */

  slowmofwd = play_slowmofwd(scale);

  /* Ensure everything is initialised for a new command in this clean session */

  session_reset_session(new_s);

  if (
       headers_add_header(&new_s->headers,
                          Headers_CommandName_Play,
                          s->url->full)
       == NULL
     )
     fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&new_s->headers) == NULL) fail = true;

  /* No AEN, so Connection: close */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_Connection,
                               Headers_HeaderValue_Connection)
            == NULL
          )
          fail = true;

  /* Content length */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_ContentLength,
                               "0")
            == NULL
          )
          fail = true;

  /* Range */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_Range,
                               range)
            == NULL
          )
          fail = true;

  /* The Scale/Speed header value was worked out above */

  else if (
            headers_add_header(&new_s->headers,
                               slowmofwd ? Headers_HeaderName_Speed : Headers_HeaderName_Scale,
                               scale)
            == NULL
          )
          fail = true;

  /* Lastly, the session header */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail)
  {
    dprintf(("", "play_replay: Out of memory\n"));
    session_free_item(new_s);
    return make_error(rtspovs_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* This session should self destruct */

  new_s->destruct = 1;

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = s->url->port;
  else                               port = NULL;

  new_s->sd = opensock(s->url->host,
                       RTSPOVS_DefaultPort,
                       port,
                       &new_s->state,
                       -1);

  new_s->last = utils_read_time();

  dprintf(("", "play_replay: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Set the state machine going to see errors and DNS stuff; */
  /* in addition, rerun it for the parent session to get      */
  /* another GET_PARAMETER scheduled.                         */

  new_s->callout_set = 1;
  timeout(status_proceed_on_callout, new_s, Session_State_Timer);

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_replay: Successful\n"));

  return NULL;
}
