/**************************************************************/
/* File:    Utils.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Miscellaneous utility functions.                  */
/*                                                            */
/* Author:  IDJ, A.D.Hodgkinson.                              */
/*                                                            */
/* History: 03-Jul-2001 (ADH): Tidied version imported from   */
/*                             LVF Generic.                   */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include "debuglib/debuglib.h"

#include "Utils.h"

/* Local definitions */

#define ERR_BLOCKS                 3
#define MessageTrans_TokenNotFound 0xAC2

/* Local variables */

static int             registered = 0;
static int             messages_fd[4];
static _kernel_oserror stored_error;

/**************************************************************/
/* find_error()                                               */
/*                                                            */
/* Get a pointer to one of ERR_BLOCKS locally stored error    */
/* blocks, in which error messages can be stored for future   */
/* reference. Each request increments the internal counter    */
/* until it wraps around back to the first error block held.  */
/*                                                            */
/* See also utils_store_error, utils_recall_error for a       */
/* different way of accessing similar functionality.          */
/**************************************************************/

_kernel_oserror * find_error(void)
{
  static _kernel_oserror global_error_block[ERR_BLOCKS];
  static int             errblock = 0;

  errblock = (errblock+1) % ERR_BLOCKS;
  return &global_error_block[errblock];
}

/**************************************************************/
/* make_error()                                               */
/*                                                            */
/* Raise an error based on an error number masked with &FF -  */
/* see the Messages file for a list.                          */
/*                                                            */
/* Parameters: Error number;                                  */
/*                                                            */
/*             Number of arguments given that are to be       */
/*             substituted into the message string;           */
/*                                                            */
/*             Zero to four NUL terminated strings to use for */
/*             substitution.                                  */
/**************************************************************/

extern _kernel_oserror * make_error(int err_num, int num_args, ...)
{
  va_list            ap;
  char             * s, token[4];
  int                i = 4;
  _kernel_oserror  * e, * ptr;
  char             * sub[4] = {0,0,0,0};

  ptr         = find_error();
  ptr->errnum = err_num;

  num_args    = (num_args > 4) ? 4 : num_args;

  for (va_start (ap, num_args); num_args--; i++)
  {
    s      = va_arg (ap, char *);
    sub[i] = (s && *s) ? s : NULL; /* copy (pointer to args)s into registers */
  }

  sprintf(token, "E%02x", err_num & 0xff);

  e = _swix(MessageTrans_Lookup,
            _INR(0,7),

            messages_fd,
            token,
            ptr->errmess,
            sizeof(*ptr) - sizeof(ptr->errnum) /* 252! */,
            sub[0],
            sub[1],
            sub[2],
            sub[3]);

  /* if the token isn't found, generate our own not found report */

  if ((e != NULL) && (e->errnum == MessageTrans_TokenNotFound))
  {
    _swix(MessageTrans_Lookup,
          _INR(0,7),

          messages_fd,
          "E09",
          ptr->errmess,
          sizeof(*ptr) - sizeof(ptr->errnum) /* 252! */,
          0,
          0,
          0,
          0);
  }

  va_end (ap);
  return ptr;
}

/**************************************************************/
/* messages_file_open()                                       */
/*                                                            */
/* Open the named messages file, using the global messages    */
/* block.                                                     */
/*                                                            */
/* Parameters: Pointer to the filename of the Messages file.  */
/**************************************************************/

extern _kernel_oserror * messages_file_open(char * messages_filename)
{
  _kernel_oserror * e = _swix(MessageTrans_OpenFile,
                              _INR(0,2),

                              messages_fd,
                              messages_filename,
                              0);

  if (e == NULL) registered = 1;

  return e;
}

/**************************************************************/
/* messages_file_close()                                      */
/*                                                            */
/* Close the Messages file using the global messages block.   */
/**************************************************************/

extern _kernel_oserror * messages_file_close(void)
{
  _kernel_oserror * e;

  if (registered == 1) e = _swix(MessageTrans_CloseFile,
                                 _IN(0),

                                 messages_fd);

  else                 e = NULL;

  registered = 0;

  return e;
}

/**************************************************************/
/* read_message()                                             */
/*                                                            */
/* Look up a given message through MessageTrans into a given  */
/* buffer with no parameter substitution. You must have first */
/* opened a Messages file with messages_file_open.            */
/*                                                            */
/* Parameters: Pointer to the token to look up;               */
/*                                                            */
/*             Pointer to a char * pointing to the buffer -   */
/*             this is updated on exit to point to the result */
/*             string ("*value" is given in R2 of             */
/*             MessageTrans_Lookup and R2 on exit is written  */
/*             back);                                         */
/*                                                            */
/*             Pointer to a size_t holding the buffer size,   */
/*             updated on exit to hold the size of the looked */
/*             up string.                                     */
/**************************************************************/

_kernel_oserror * read_message(const char * token, const char ** buffer, size_t * inoutlength)
{
  return _swix(MessageTrans_Lookup,
               _INR(0,7) | _OUTR(2,3),

               messages_fd,
               token,
               *buffer,
               *inoutlength,
               0,
               0,
               0,
               0,

               buffer,
               inoutlength);
}

/**************************************************************/
/* utils_read_time()                                          */
/*                                                            */
/* Returns a notional value of current time, which is         */
/* guaranteed to rise continuously - up to clock wrap-around, */
/* that is... :-)                                             */
/*                                                            */
/* The implementation of this function most not use floating  */
/* point code.                                                */
/*                                                            */
/* Returns:    Notional value of current time as an unsigned  */
/*             integer. Units are unspecified.                */
/**************************************************************/

unsigned int utils_read_time(void)
{
  unsigned int result;

  _swix(OS_ReadMonotonicTime,
        _OUT(0),

        &result);

  return result;
}

/**************************************************************/
/* utils_time_difference()                                    */
/*                                                            */
/* Returns the difference, in seconds, between two time       */
/* values obtained from utils_read_time.                      */
/*                                                            */
/* The implementation of this function most not use floating  */
/* point code.                                                */
/*                                                            */
/* Parameters: Earliest time;                                 */
/*                                                            */
/*             Latest time.                                   */
/*                                                            */
/* Returns:    Latest minus earliest time, in seconds. Will   */
/*             be negative if the value passed as latest is   */
/*             actually ealier than the value passed as       */
/*             earliest.                                      */
/**************************************************************/

int utils_time_difference(unsigned int earliest, unsigned int latest)
{
  return (latest - earliest) / 100;
}

/**************************************************************/
/* utils_store_error()                                        */
/*                                                            */
/* Stores a copy of an error into a local block, overwriting  */
/* any previously stored error. See also find_error for a     */
/* different way of accessing similar functionality.          */
/*                                                            */
/* Parameters: Pointer to the _kernel_oserror * struct to     */
/*             copy away. May be NULL.                        */
/**************************************************************/

void utils_store_error(_kernel_oserror * e)
{
  if (e != NULL)
  {
    stored_error.errnum = e->errnum;
    strncpy(stored_error.errmess, e->errmess, sizeof(stored_error.errmess));
  }

  return;
}

/**************************************************************/
/* utils_recall_error()                                       */
/*                                                            */
/* Recall an error stored with utils_store_error. The caller  */
/* bears responsibility for matching store to recall. Only    */
/* one error can be stored at a time. See also find_error for */
/* a different way of accessing similar functionality.        */
/*                                                            */
/* Returns:    Pointer to the stored error.                   */
/**************************************************************/

_kernel_oserror * utils_recall_error(void)
{
  return &stored_error;
}
