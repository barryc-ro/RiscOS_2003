     1   
     7  
     7  
     7  
     7  
     7  
     8  
    11  
    12  
    19  
    22  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  void *module_wsp = 0;
    37  int v_state =  0 ;
    38  static int bs_sent = 0;
    39  static int discards = 0;
    40  static int overflows = 0;
    41  int default_video_port = 0;
    42  int video_port = 0;
    43  static int rxsize = 0;
    44  int bs_bufsize = 0;
    45  int n_bs_buffers = 0;
    46  int bs_minbufs = 0;
    47  int bs_bufpool;
    48  int bs_bytes_sent = 0;
    49  
    50  extern int skipcnt;
    51  extern int bs_minbufs_check;
    52  
    53  int mpeg_handle, vsock, vssock;
    54  int do_debug = 0;
    55  
    56  extern _kernel_oserror *calleverytick(void);
    57  extern struct bs_buffer *get_empty_buffer(void);
    58  
    59  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw);
    60  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw);
    61  void udpv_show(int argc , char **argv );
    62  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw);
    63  int do_getsock(int port, int inputsocket);
    64  int udpv_startofplay(_kernel_swi_regs *r);
    65  int udpv_endofplay(_kernel_swi_regs *r);
    66  int udpv_empty_buf(_kernel_swi_regs *r);
    67  int udpv_nullswi(_kernel_swi_regs *r);
    68  int udpv_rxdirect(_kernel_swi_regs *r);
    69  int udpv_getstatus(_kernel_swi_regs *r);
    70  void init_session(int handle, int skipsize);
    71  void close_session(void );
    72  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf);
    73  int send_full_buf(int b, int flag);
    74  int read_sysvar(char *var, char *buf, int buflen);
    75  
    76  struct swient {
    77      int (*swi_call)();       
    78  };
    79  
    80  
    81   
    82  
    83  
    84  struct swient udpv_ent[ 31 ] = {
    85      udpv_nullswi,
    86      udpv_nullswi,
    87      udpv_nullswi,
    88      udpv_nullswi,
    89      udpv_nullswi,
    90      udpv_nullswi,
    91      udpv_nullswi,
    92      udpv_empty_buf,
    93      udpv_nullswi,
    94      udpv_endofplay,
    95      udpv_startofplay,
    96      udpv_nullswi,
    97      udpv_nullswi,
    98      udpv_nullswi,
    99      udpv_nullswi,
   100      udpv_nullswi,
   101      udpv_getstatus,
   102      udpv_nullswi,
   103      udpv_nullswi,
   104      udpv_nullswi,
   105      udpv_nullswi,
   106      udpv_nullswi,
   107      udpv_nullswi,
   108      udpv_nullswi,
   109      udpv_nullswi,
   110      udpv_nullswi,
   111      udpv_nullswi,
   112      udpv_nullswi,
   113      udpv_nullswi,
   114      udpv_rxdirect,
   115      0,
   116  };
   117  
   118  
   119  
   120  struct client {
   121          int (*cli_call)();       
   122  };
   123  
   124  
   125  
   126  struct client udpv_cli_call[ 2 ] = {
   127      (int (*)())udpv_show
   128  };
   129  
   130  
   131  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw)
   132  {
   133      char buf[32];
   134  
   135      module_wsp = pw;
   136      if (!mb_present())
   137          return ((_kernel_oserror *)0);
   138      (void) mb_entryinit();
   139  
   140      if (read_sysvar("MPEG$UDPport", buf, sizeof(buf)) != 0)
   141          default_video_port = atoi(buf);
   142      else
   143          default_video_port =  0x801a ;
   144  
   145      if (read_sysvar("MPEG$UDPdsize", buf, sizeof(buf)) != 0)
   146          bs_bufsize = atoi(buf);
   147      else
   148          bs_bufsize = 8192;
   149  
   150      if (read_sysvar("UDP$Debug", buf, sizeof(buf)) != 0)
   151          do_debug = 1;
   152  
   153      if (read_sysvar("MPEG$BufPool", buf, sizeof(buf)) != 0)
   154      {
   155        bs_bufpool = atoi(buf);
   156        if (bs_bufpool < bs_bufsize)
   157        {
   158          bs_bufpool =  850*376 ;  
   159        }
   160      }
   161      else
   162      {
   163        bs_bufpool =  850*376 ;
   164      }
   165  
   166      n_bs_buffers = (bs_bufpool) / bs_bufsize;
   167  
   168      if (read_sysvar("MPEG$MinBufs", buf, sizeof(buf)) != 0)
   169      {
   170          bs_minbufs = atoi(buf);
   171      }
   172      else
   173      {
   174          bs_minbufs = 0;
   175      }
   176  
   177      init_bs_buffers();
   178      vsock = -1;
   179      return ((_kernel_oserror *)0);
   180  }
   181  
   182   
   183  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw)
   184  {
   185      struct client *callp;
   186      int margc;
   187      char *margv[10];
   188      char *cp;
   189      char **argp = margv;
   190  
   191      margc = 0;
   192      cp = arg_string;
   193      while (*cp && (arg_count-- > 0) && (margc < 10))
   194      {
   195          while ( (__ctype[ *cp ] &  1 ) )
   196          {
   197              cp++;
   198          }
   199          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   200              break;
   201          *argp++ = cp;
   202          margc++;
   203          while (*cp != '\0' && ! (__ctype[ *cp ] &  64 )  && ! (__ctype[ *cp ] &  1 ) )
   204          {
   205              cp++;
   206          }
   207          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   208              break;
   209          *cp++ = '\0';
   210      }
   211      *argp++ = 0;
   212      callp = &udpv_cli_call[cmd_no];
   213      (void)(*(callp->cli_call))(margc, margv);
   214      return ((_kernel_oserror *)0);
   215  }
   216  
   217  void udpv_show(int argc, char **argv)
   218  {
   219      printf("videoport=%d (%x), lastport=%d, rxbufsize=%d\n",
   220                 default_video_port, default_video_port, video_port, rxsize);
   221      printf("bs_bufpool=%d, n_buffers=%d, bufsize=%d, bs_minbufs=%d (%d)\n",
   222                 bs_bufpool, n_bs_buffers, bs_bufsize, bs_minbufs, bs_minbufs_check);
   223      printf("discards=%d, overflows=%d\n", discards, overflows);
   224      print_bufs();
   225  }
   226  
   227  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
   228  {
   229      struct swient *callp;
   230  
   231      callp = &udpv_ent[swinum];
   232      return ((_kernel_oserror *)(*(callp->swi_call))(r));
   233  }
   234  
   235  int do_getsock(int port, int inputsocket)
   236  {
   237      struct sockaddr_in addr;
   238      int arg, sock, on = 1;
   239  
   240      if ((sock = socket( 2 ,  2 , 0)) < 0)
   241          return (-1);
   242      arg =  0x4001d ;
   243      if (socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 126 ) ))   , &on) < 0 || socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 122 ) ))   , &arg) < 0)
   244      {
   245          socketclose (sock);
   246          return (-1);
   247      }
   248      arg = ( 64*1024 );
   249      if (setsockopt(sock,  0xffff ,  0x0020 , &on, sizeof (on)) < 0 ||
   250          setsockopt(sock,  0xffff ,  0x1002 , &arg, sizeof (arg)) < 0)
   251      {
   252          socketclose(sock);
   253          return (-1);
   254      }
   255      if (inputsocket)
   256      {
   257          addr.sin_family      =  2 ;
   258          addr.sin_addr.s_addr =  ntohl(  (u_long)0x00000000  ) ;
   259          addr.sin_port        =  ntohs( (u_short)port ) ;
   260          if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0)
   261          {
   262              socketclose(sock);
   263              return (-1);
   264          }
   265      }
   266      return (sock);
   267  }
   268  
   269  int udpv_startofplay(_kernel_swi_regs *r)
   270  {
   271      int port = r->r[2];
   272  
   273  
   274      if (port == 0)
   275          port = default_video_port;
   276  
   277      if (do_debug)
   278          printf("        Get socket for port %d\n", port);
   279      if (port != video_port && vsock != -1)
   280      {
   281          socketclose(vsock);
   282          vsock = -1;
   283      }
   284      if (vsock == -1)
   285      {
   286          vsock = do_getsock(port, 1);
   287          if (do_debug && vsock < 0)
   288              printf("          Socket open failed!\n");
   289      }
   290      if (vsock >= 0)
   291      {
   292          video_port = port;
   293          init_mpeg_buffers();
   294          init_session(r->r[3], r->r[4]);
   295      }
   296      return (0);
   297  }
   298  
   299  int udpv_endofplay(_kernel_swi_regs *r)
   300  {
   301      close_session();
   302      return (0);
   303  }
   304  
   305  int udpv_empty_buf(_kernel_swi_regs *r)
   306  {
   307      if (r->r[2] != 0)
   308          return_empty_buf((struct bs_buffer *)r->r[2],0);
   309      r->r[2] = 0;
   310      return (0);
   311  }
   312  
   313  int udpv_nullswi(_kernel_swi_regs *r)
   314  {
   315      return (0);
   316  }
   317  
   318  int udpv_rxdirect(_kernel_swi_regs *r)
   319  {
   320      int s = ensure_irqs_on();
   321      if (r->r[0] == vsock)
   322          vs_process_input(r->r[1], r->r[2], (char *)(r->r[3]), r->r[4], r->r[5], r->r[6]);
   323      restore_irqs(s);
   324      return (0);
   325  }
   326  
   327  int udpv_getstatus(_kernel_swi_regs *r)
   328  {
   329      bs_bytes_sent += send_buffers();
   330      r->r[0] = (v_state ==  1 ) ?  0  :  1 ;
   331      r->r[1] = 0;
   332      r->r[2] = 0;
   333      r->r[3] = 0;
   334      return (0);
   335  }
   336  
   337  void init_session(int handle, int skipsize)
   338  {
   339      mpeg_handle = handle;
   340      v_state =  1 ;
   341      skipcnt = skipsize;
   342  }
   343  
   344  void close_session(void)
   345  {
   346      v_state =  0 ;
   347  }
   348  
   349  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf)
   350  {
   351      struct mbuf *m, *m0, *m1;
   352      struct bs_buffer *bs = 0;
   353      int mlen, residue = 0;
   354      char *bptr;
   355  
   356      m0 = (struct mbuf *)a;
   357      m1 = (struct mbuf *)ack_buf;
   358      if (m0 == 0)
   359          goto out;
   360   
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   392  
   393   
   398  
   398  
   398  
   398  
   398  
   399  
   400      mlen = (*mbctl.count_bytes)(&mbctl, m0);
   401      bs = get_empty_buffer();
   402      if (bs == 0)
   403      {
   404        discards++;
   405      }
   406      else
   407      {
   408        residue = bs_bufsize;
   409        bptr = bs->bs_data;
   410        bs->bs_len = 0;
   411        bs->bs_handle = 0;
   412        bs->bs_flags =  0x40007 ;
   413        if (mlen <= bs_bufsize)
   414        {
   415          (void)  (( mbctl .export)(& mbctl , ( m0 ), ( mlen ), ( bptr ))) ;
   416          bs->bs_len += mlen;
   417          bptr += mlen;
   418          residue -= mlen;
   419        }
   420        else
   421        {
   422          overflows++;
   423          (void)  (( mbctl .export)(& mbctl , ( m0 ), ( bs_bufsize ), ( bptr ))) ;
   424          bs->bs_len += bs_bufsize;
   425          bptr += bs_bufsize;
   426          residue -= bs_bufsize;
   427        }
   428        if (bs != 0)
   429        {
   430           rxsize = bs->bs_len;
   431           save_full_buf(bs, 0);
   432        }
   433      }
   434      bs_bytes_sent += send_buffers();
   435      m0->m_len = 0;
   436  
   437  out:
   438      if (m1)
   439      {
   440           (( mbctl .freem)(& mbctl , ( m1 ))) ;
   441      }
   442      return(0);
   443  }
+++ Warning: variable 'm' declared but not used
   444  
   445  
   446  
   447  int read_sysvar(char *var, char *buf, int buflen)
   448  {
   449      _kernel_swi_regs r;
   450      _kernel_oserror *e;
   451  
   452      r.r[0] = (int)var;
   453      r.r[1] = (int)buf;
   454      r.r[2] = buflen;
   455      r.r[3] = 0;
   456      r.r[4] = 0;
   457      e = _kernel_swi( (1U << 17)  |  0x00000023 , &r, &r);
   458      if (e || r.r[2] == 0)
   459          return (0);
   460      buf[r.r[2]] = 0;
   461      return (1);
   462  }
   463  
+++ Warning: static 'bs_sent' declared but not used
