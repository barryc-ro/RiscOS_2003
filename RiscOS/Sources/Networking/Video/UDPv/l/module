     1   
     7  
     7  
     7  
     7  
     7  
     8  
    11  
    12  
    19  
    22  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  void *module_wsp = 0;
    37  int v_state =  0 ;
    38  extern int bs_sent = 0;
    39  int discards = 0;
    40  int default_video_port = 0;
    41  int video_port = 0;
    42  int rxsize = 0;
    43  int bs_bufsize = 0;
    44  int n_bs_buffers = 0;
    45  int bs_minbufs = 0;
    46  int bs_bufpool;
    47  int bs_bytes_sent = 0;
    48  
    49  extern int skipcnt;
    50  
    51  int mpeg_handle, vsock, vssock;
    52  int do_debug = 0;
    53  
    54  extern _kernel_oserror *calleverytick(void);
    55  extern struct bs_buffer *get_empty_buffer(void);
    56  
    57  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw);
    58  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw);
    59  void udpv_show(int argc , char **argv );
    60  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw);
    61  int do_getsock(int port, int inputsocket);
    62  int udpv_startofplay(_kernel_swi_regs *r);
    63  int udpv_endofplay(_kernel_swi_regs *r);
    64  int udpv_empty_buf(_kernel_swi_regs *r);
    65  int udpv_nullswi(_kernel_swi_regs *r);
    66  int udpv_rxdirect(_kernel_swi_regs *r);
    67  int udpv_getstatus(_kernel_swi_regs *r);
    68  void init_session(int handle, int skipsize);
    69  void close_session(void );
    70  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf);
    71  int send_full_buf(int b, int flag);
    72  int read_sysvar(char *var, char *buf, int buflen);
    73  
    74  struct swient {
    75      int (*swi_call)();       
    76  };
    77  
    78  
    79   
    80  
    81  
    82  struct swient udpv_ent[ 31 ] = {
    83      udpv_nullswi,
    84      udpv_nullswi,
    85      udpv_nullswi,
    86      udpv_nullswi,
    87      udpv_nullswi,
    88      udpv_nullswi,
    89      udpv_nullswi,
    90      udpv_empty_buf,
    91      udpv_nullswi,
    92      udpv_endofplay,
    93      udpv_startofplay,
    94      udpv_nullswi,
    95      udpv_nullswi,
    96      udpv_nullswi,
    97      udpv_nullswi,
    98      udpv_nullswi,
    99      udpv_getstatus,
   100      udpv_nullswi,
   101      udpv_nullswi,
   102      udpv_nullswi,
   103      udpv_nullswi,
   104      udpv_nullswi,
   105      udpv_nullswi,
   106      udpv_nullswi,
   107      udpv_nullswi,
   108      udpv_nullswi,
   109      udpv_nullswi,
   110      udpv_nullswi,
   111      udpv_nullswi,
   112      udpv_rxdirect,
   113      0,
   114  };
   115  
   116  
   117  
   118  struct client {
   119          int (*cli_call)();       
   120  };
   121  
   122  
   123  
   124  struct client udpv_cli_call[ 2 ] = {
   125      (int (*)())udpv_show
   126  };
   127  
   128  
   129  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw)
   130  {
   131      char buf[32];
   132  
   133      module_wsp = pw;
   134      if (!mb_present())
   135          return ((_kernel_oserror *)0);
   136      (void) mb_entryinit();
   137  
   138      if (read_sysvar("MPEG$UDPport", buf, sizeof(buf)) != 0)
   139          default_video_port = atoi(buf);
   140      else
   141          default_video_port =  0x801a ;
   142  
   143      if (read_sysvar("MPEG$UDPdsize", buf, sizeof(buf)) != 0)
   144          bs_bufsize = atoi(buf);
   145      else
   146          bs_bufsize = 8192;
   147  
   148      if (read_sysvar("UDP$Debug", buf, sizeof(buf)) != 0)
   149          do_debug = 1;
   150  
   151      if (read_sysvar("MPEG$BufPool", buf, sizeof(buf)) != 0)
   152      {
   153        bs_bufpool = atoi(buf);
   154        if (bs_bufpool < bs_bufsize)
   155        {
   156          bs_bufpool = bs_bufsize * 16;  
   157        }
   158      }
   159      else
   160      {
   161        bs_bufpool =  850*376 ;
   162      }
   163  
   164      n_bs_buffers = (bs_bufpool) / bs_bufsize;
   165  
   166      if (read_sysvar("MPEG$MinBufs", buf, sizeof(buf)) != 0)
   167      {
   168          bs_minbufs = atoi(buf);
   169      }
   170      else
   171      {
   172          bs_minbufs = 0;
   173      }
   174  
   175      init_bs_buffers();
   176      vsock = -1;
   177      return ((_kernel_oserror *)0);
   178  }
   179  
   180   
   181  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw)
   182  {
   183      struct client *callp;
   184      int margc;
   185      char *margv[10];
   186      char *cp;
   187      char **argp = margv;
   188  
   189      margc = 0;
   190      cp = arg_string;
   191      while (*cp && arg_count-- > 0) {
   192          while ( (__ctype[ *cp ] &  1 ) )
   193              cp++;
   194          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   195              break;
   196          *argp++ = cp;
   197          margc++;
   198          while (*cp != '\0' && ! (__ctype[ *cp ] &  64 )  && ! (__ctype[ *cp ] &  1 ) )
   199              cp++;
   200          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   201              break;
   202          *cp++ = '\0';
   203      }
   204      *argp++ = 0;
   205      callp = &udpv_cli_call[cmd_no];
   206      (void)(*(callp->cli_call))(margc, margv);
   207      return ((_kernel_oserror *)0);
   208  }
   209  
   210  void udpv_show(int argc, char **argv)
   211  {
   212      printf("videoport=%d (%x), lastport=%d, rxbufsize=%d\n",
   213                 default_video_port, default_video_port, video_port, rxsize);
   214      printf("bs_bufpool=%d, n_buffers=%d, bufsize=%d, bs_minbufs=%d, discards=%d\n",
   215                 bs_bufpool, n_bs_buffers, bs_bufsize, bs_minbufs, discards);
   216      print_bufs();
   217  }
   218  
   219  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
   220  {
   221      struct swient *callp;
   222  
   223      callp = &udpv_ent[swinum];
   224      return ((_kernel_oserror *)(*(callp->swi_call))(r));
   225  }
   226  
   227  int do_getsock(int port, int inputsocket)
   228  {
   229      struct sockaddr_in addr;
   230      int arg, sock, on = 1;
   231  
   232      if ((sock = socket( 2 ,  2 , 0)) < 0)
   233          return (-1);
   234      arg =  0x4001d ;
   235      if (socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 126 ) ))   , &on) < 0 || socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 122 ) ))   , &arg) < 0)
   236      {
   237          socketclose (sock);
   238          return (-1);
   239      }
   240      arg = ( 64*1024 );
   241      if (setsockopt(sock,  0xffff ,  0x0020 , &on, sizeof (on)) < 0 ||
   242          setsockopt(sock,  0xffff ,  0x1002 , &arg, sizeof (arg)) < 0)
   243      {
   244          socketclose(sock);
   245          return (-1);
   246      }
   247      if (inputsocket)
   248      {
   249          addr.sin_family      =  2 ;
   250          addr.sin_addr.s_addr =  ntohl(  (u_long)0x00000000  ) ;
   251          addr.sin_port        =  ntohs( (u_short)port ) ;
   252          if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0)
   253          {
   254              socketclose(sock);
   255              return (-1);
   256          }
   257      }
   258      return (sock);
   259  }
   260  
   261  int udpv_startofplay(_kernel_swi_regs *r)
   262  {
   263      int port = r->r[2];
   264  
   265  
   266      if (port == 0)
   267          port = default_video_port;
   268  
   269      if (do_debug)
   270          printf("        Get socket for port %d\n", port);
   271      if (port != video_port && vsock != -1)
   272      {
   273          socketclose(vsock);
   274          vsock = -1;
   275      }
   276      if (vsock == -1)
   277      {
   278          vsock = do_getsock(port, 1);
   279          if (do_debug && vsock < 0)
   280              printf("          Socket open failed!\n");
   281      }
   282      if (vsock >= 0)
   283      {
   284          video_port = port;
   285          init_mpeg_buffers();
   286          init_session(r->r[3], r->r[4]);
   287      }
   288      return (0);
   289  }
   290  
   291  int udpv_endofplay(_kernel_swi_regs *r)
   292  {
   293      close_session();
   294      return (0);
   295  }
   296  
   297  int udpv_empty_buf(_kernel_swi_regs *r)
   298  {
   299      if (r->r[2] != 0)
   300          return_empty_buf((struct bs_buffer *)r->r[2],0);
   301      r->r[2] = 0;
   302      return (0);
   303  }
   304  
   305  int udpv_nullswi(_kernel_swi_regs *r)
   306  {
   307      return (0);
   308  }
   309  
   310  int udpv_rxdirect(_kernel_swi_regs *r)
   311  {
   312      int s = ensure_irqs_on();
   313      if (r->r[0] == vsock)
   314          vs_process_input(r->r[1], r->r[2], (char *)(r->r[3]), r->r[4], r->r[5], r->r[6]);
   315      restore_irqs(s);
   316      return (0);
   317  }
   318  
   319  int udpv_getstatus(_kernel_swi_regs *r)
   320  {
   321      bs_bytes_sent += send_buffers();
   322      r->r[0] = (v_state ==  1 ) ?  0  :  1 ;
   323      r->r[1] = 0;
   324      r->r[2] = 0;
   325      r->r[3] = 0;
   326      return (0);
   327  }
   328  
   329  void init_session(int handle, int skipsize)
   330  {
   331      mpeg_handle = handle;
   332      v_state =  1 ;
   333      skipcnt = skipsize;
   334  }
   335  
   336  void close_session(void)
   337  {
   338      v_state =  0 ;
   339  }
   340  
   341  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf)
   342  {
   343      struct mbuf *m, *m0, *m1;
   344      struct bs_buffer *bs = 0;
   345      int mlen, residue = 0;
   346      char *bptr;
   347  
   348      m0 = (struct mbuf *)a;
   349      m1 = (struct mbuf *)ack_buf;
   350      if (m0 == 0)
   351          goto out;
   352      for (m = m0; m; m = m->m_next)
   353      {
   354          mlen = m->m_len;
   355          if (mlen == 0)
   356              continue;
   357          if (mlen > residue)
   358          {
   359              if (bs != 0)
   360                  save_full_buf(bs, 0);
   361              if ((bs = get_empty_buffer()) == 0)
   362              {
   363                  discards++;
   364                  break;
   365              }
   366              residue = bs_bufsize;
   367              bptr = bs->bs_data;
   368              bs->bs_len = 0;
   369              bs->bs_handle = 0;
   370              bs->bs_flags =  0x40007 ;
   371          }
   372          memcpy(bptr,  ( ( char * ) ( (ptrdiff_t)( m ) + ( m )->m_off ) ) , mlen);
   373          bs->bs_len += mlen;
   374          bptr += mlen;
   375          residue -= mlen;
   376     }
   377     if (bs != 0)
   378     {
   379          rxsize = bs->bs_len;
   380          save_full_buf(bs, 0);
   381     }
   382     bs_bytes_sent += send_buffers();
   383     m0->m_len = 0;
   384  out:
   385      if (m1)
   386      {
   387           (( mbctl .freem)(& mbctl , ( m1 ))) ;
   388      }
   389      return(0);
   390  }
   391  
   392  int read_sysvar(char *var, char *buf, int buflen)
   393  {
   394      _kernel_swi_regs r;
   395      _kernel_oserror *e;
   396  
   397      r.r[0] = (int)var;
   398      r.r[1] = (int)buf;
   399      r.r[2] = buflen;
   400      r.r[3] = 0;
   401      r.r[4] = 0;
   402      e = _kernel_swi( (1U << 17)  |  0x00000023 , &r, &r);
   403      if (e || r.r[2] == 0)
   404          return (0);
   405      buf[r.r[2]] = 0;
   406      return (1);
   407  }
   408  
