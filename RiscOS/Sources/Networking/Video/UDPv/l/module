     1   
     7  
     7  
     7  
     7  
     7  
     8  
    11  
    12  
    19  
    22  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  void *module_wsp = 0;
    37  int v_state =  0 ;
    38  
    39  static int discards = 0;
    40  static int oversized = 0;
    41  static int undersized = 0;
    42  static int empty_failures = 0;
    43  static unsigned int bytes_received = 0;
    44  static unsigned int datagrams_received = 0;
    45  static int sequence_lost = 0;
    46  static int sequence_lostm = 0;
    47  static int sequence_lostt = 0;
    48  static int sequence_OOS = 0;
    49  static int sequence_OOSm = 0;
    50  static int sequence_OOSt = 0;
    51  static int reentered = 0;
    52  static volatile int reentrancy_flag;
    53  
    54  int default_video_port = 0;
    55  int video_port = 0;
    56  int bs_bufsize = 0;
    57  int n_bs_buffers = 0;
    58  int bs_minbufs = 0;
    59  int bs_bufpool;
    60  int bs_bytes_sent = 0;
    61  
    62  static int skipcount = 0;
    63  static unsigned int sequence_expected;
    64  
    65  extern int bs_minbufs_check;
    66  
    67  int mpeg_handle, vsock, vssock;
    68  int do_debug = 0;
    69  
    70  struct bs_buffer *bs_current_buf;
    71  int bs_current_residue;
    72  
    73  extern _kernel_oserror *calleverytick(void);
    74  extern struct bs_buffer *get_empty_buffer(void);
    75  
    76  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw);
    77  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw);
    78  void udpv_show(int argc , char **argv );
    79  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw);
    80  int do_getsock(int port, int inputsocket);
    81  int udpv_startofplay(_kernel_swi_regs *r);
    82  int udpv_endofplay(_kernel_swi_regs *r);
    83  int udpv_empty_buf(_kernel_swi_regs *r);
    84  int udpv_nullswi(_kernel_swi_regs *r);
    85  int udpv_rxdirect(_kernel_swi_regs *r);
    86  int udpv_getstatus(_kernel_swi_regs *r);
    87  void init_session(int handle, int skipsize);
    88  void close_session(void );
    89  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf);
    90  int send_full_buf(int b, int flag);
    91  int read_sysvar(char *var, char *buf, int buflen);
    92  
    93  struct swient {
    94      int (*swi_call)();       
    95  };
    96  
    97  
    98  
    99  struct swient udpv_ent[ 31 ] = {
   100      udpv_nullswi,
   101      udpv_nullswi,
   102      udpv_nullswi,
   103      udpv_nullswi,
   104      udpv_nullswi,
   105      udpv_nullswi,
   106      udpv_nullswi,
   107      udpv_empty_buf,
   108      udpv_nullswi,
   109      udpv_endofplay,
   110      udpv_startofplay,
   111      udpv_nullswi,
   112      udpv_nullswi,
   113      udpv_nullswi,
   114      udpv_nullswi,
   115      udpv_nullswi,
   116      udpv_getstatus,
   117      udpv_nullswi,
   118      udpv_nullswi,
   119      udpv_nullswi,
   120      udpv_nullswi,
   121      udpv_nullswi,
   122      udpv_nullswi,
   123      udpv_nullswi,
   124      udpv_nullswi,
   125      udpv_nullswi,
   126      udpv_nullswi,
   127      udpv_nullswi,
   128      udpv_nullswi,
   129      udpv_rxdirect,
   130      0,
   131  };
   132  
   133  
   134  
   135  struct client {
   136          int (*cli_call)();       
   137  };
   138  
   139  
   140  
   141  struct client udpv_cli_call[ 2 ] = {
   142      (int (*)())udpv_show
   143  };
   144  
   145  
   146  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw)
   147  {
   148      char buf[32];
   149  
   150      module_wsp = pw;
   151      if (!mb_present())
   152          return ((_kernel_oserror *)0);
   153      (void) mb_entryinit();
   154  
   155      if (read_sysvar("MPEG$UDPport", buf, sizeof(buf)) != 0)
   156          default_video_port = atoi(buf);
   157      else
   158          default_video_port =  0x801a ;
   159  
   160      if (read_sysvar("MPEG$UDPdsize", buf, sizeof(buf)) != 0)
   161          bs_bufsize = atoi(buf);
   162      else
   163          bs_bufsize = 8192;
   164  
   165      if (read_sysvar("UDP$Debug", buf, sizeof(buf)) != 0)
   166          do_debug = 1;
   167  
   168      if (read_sysvar("MPEG$BufPool", buf, sizeof(buf)) != 0)
   169      {
   170        bs_bufpool = atoi(buf);
   171        if (bs_bufpool < bs_bufsize)
   172        {
   173          bs_bufpool =  850*376 ;  
   174        }
   175      }
   176      else
   177      {
   178        bs_bufpool =  850*376 ;
   179      }
   180  
   181      n_bs_buffers = (bs_bufpool) / bs_bufsize;
   182  
   183      if (read_sysvar("MPEG$MinBufs", buf, sizeof(buf)) != 0)
   184      {
   185          bs_minbufs = atoi(buf);
   186      }
   187      else
   188      {
   189          bs_minbufs = 0;
   190      }
   191  
   192      init_bs_buffers();
   193      vsock = -1;
   194      return ((_kernel_oserror *)0);
   195  }
   196  
   197  
   198  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw)
   199  {
   200      struct client *callp;
   201      int margc;
   202      char *margv[10];
   203      char *cp;
   204      char **argp = margv;
   205  
   206      margc = 0;
   207      cp = arg_string;
   208      while (*cp && (arg_count-- > 0) && (margc < 10))
   209      {
   210          while ( (__ctype[ *cp ] &  1 ) )
   211          {
   212              cp++;
   213          }
   214          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   215              break;
   216          *argp++ = cp;
   217          margc++;
   218          while (*cp != '\0' && ! (__ctype[ *cp ] &  64 )  && ! (__ctype[ *cp ] &  1 ) )
   219          {
   220              cp++;
   221          }
   222          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   223              break;
   224          *cp++ = '\0';
   225      }
   226      *argp++ = 0;
   227      callp = &udpv_cli_call[cmd_no];
   228      (void)(*(callp->cli_call))(margc, margv);
   229      return ((_kernel_oserror *)0);
   230  }
   231  
   232  void udpv_show(int argc, char **argv)
   233  {
   234      int temp_int, temp_fract;
   235  
   236      printf("videoport=%d (%x)  lastport=%d  skipcount=%d  reentry=%d\n",
   237                 default_video_port, default_video_port, video_port, skipcount, reentered);
   238      printf("bs_bufpool: %5dKB n_buffers: %-5d bufsize: %3dKB bs_minbufs: %d (%d frames)\n",
   239                 bs_bufpool/1024, n_bs_buffers, bs_bufsize/1024, bs_minbufs, bs_minbufs_check);
   240      printf("bs_discards: %-12d emptyfailures: %-12d\n", discards, empty_failures);
   241      if (datagrams_received > 0)
   242      {
   243        temp_int = bytes_received/datagrams_received;
   244        temp_fract = ((bytes_received%datagrams_received)*100)/datagrams_received;
   245        printf("Datagrams: %d  oversize: %d  undersize: %d  PDU avg: %6d.%-2d\n",
   246                datagrams_received, oversized, undersized, temp_int, temp_fract);
   247      }
   248  
   249      if (do_debug && (skipcount == 4))
   250      {
   251        printf("Sequence information:\n");
   252        if (sequence_OOS > 0)
   253        {
   254          temp_int = sequence_OOSt/sequence_OOS;
   255          temp_fract = ((sequence_OOSt%sequence_OOS)*100)/sequence_OOS;
   256          printf("              OOSes: %-d  (%d)   max: %-d   avg: %3d.%-2d\n",
   257                 sequence_OOS, sequence_OOSt, -sequence_OOSm, temp_int, temp_fract);
   258        }
   259        if (sequence_lost > 0)
   260        {
   261          temp_int = sequence_lostt/sequence_lost;
   262          temp_fract = ((sequence_lostt%sequence_lost)*100)/sequence_lost;
   263          printf("              Losses: %-d  (%d)   max: %-d   avg: %3d.%-2d\n",
   264                 sequence_lost, sequence_lostt, sequence_lostm, temp_int, temp_fract);
   265        }
   266      }
   267  
   268      if (do_debug)
   269      {
   270        printf("bs_current_buf=%p, bs_current_residue=%d\n",
   271                 bs_current_buf, bs_current_residue);
   272      }
   273      print_bufs();
   274  }
   275  
   276  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
   277  {
   278      struct swient *callp;
   279  
   280      callp = &udpv_ent[swinum];
   281      return ((_kernel_oserror *)(*(callp->swi_call))(r));
   282  }
   283  
   284  int do_getsock(int port, int inputsocket)
   285  {
   286      struct sockaddr_in addr;
   287      int arg, sock, on = 1;
   288  
   289      if ((sock = socket( 2 ,  2 , 0)) < 0)
   290          return (-1);
   291      arg =  0x4001d ;
   292      if (socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 126 ) ))   , &on) < 0 || socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 122 ) ))   , &arg) < 0)
   293      {
   294          socketclose (sock);
   295          return (-1);
   296      }
   297      arg = ( 64*1024 );
   298      if (setsockopt(sock,  0xffff ,  0x0020 , &on, sizeof (on)) < 0 ||
   299          setsockopt(sock,  0xffff ,  0x1002 , &arg, sizeof (arg)) < 0)
   300      {
   301          socketclose(sock);
   302          return (-1);
   303      }
   304      if (inputsocket)
   305      {
   306          addr.sin_family      =  2 ;
   307          addr.sin_addr.s_addr =  ntohl(  (u_long)0x00000000  ) ;
   308          addr.sin_port        =  ntohs( (u_short)port ) ;
   309          if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0)
   310          {
   311              socketclose(sock);
   312              return (-1);
   313          }
   314      }
   315      return (sock);
   316  }
   317  
   318  int udpv_startofplay(_kernel_swi_regs *r)
   319  {
   320      int port = r->r[2];
   321  
   322      sequence_expected = 0;
   323      sequence_OOS = 0;
   324      sequence_OOSm = 0;
   325      sequence_OOSt = 0;
   326      sequence_lost = 0;
   327      sequence_lostm = 0;
   328      sequence_lostt = 0;
   329      discards = 0;
   330      oversized = 0;
   331      undersized = 0;
   332      empty_failures = 0;
   333      bytes_received = 0;
   334      datagrams_received = 0;
   335  
   336      if (port == 0)
   337          port = default_video_port;
   338  
   339      if (do_debug)
   340          printf("        Get socket for port %d\n", port);
   341      if (port != video_port && vsock != -1)
   342      {
   343          socketclose(vsock);
   344          vsock = -1;
   345      }
   346      if (vsock == -1)
   347      {
   348          vsock = do_getsock(port, 1);
   349          if (do_debug && vsock < 0)
   350              printf("          Socket open failed!\n");
   351      }
   352      if (vsock >= 0)
   353      {
   354          video_port = port;
   355          init_mpeg_buffers();
   356          init_session(r->r[3], r->r[4]);
   357      }
   358      return (0);
   359  }
   360  
   361  int udpv_endofplay(_kernel_swi_regs *r)
   362  {
   363      close_session();
   364      return (0);
   365  }
   366  
   367  int udpv_empty_buf(_kernel_swi_regs *r)
   368  {
   369      if (r->r[2] != 0)
   370          return_empty_buf((struct bs_buffer *)r->r[2],1);
   371      r->r[2] = 0;
   372      return (0);
   373  }
   374  
   375  int udpv_nullswi(_kernel_swi_regs *r)
   376  {
   377      return (0);
   378  }
   379  
   380  int udpv_rxdirect(_kernel_swi_regs *r)
   381  {
   382    int s = ensure_irqs_on();
   383    if (reentrancy_flag != 0)
   384    {
   385      reentered++;
   386    }
   387    else
   388    {
   389      reentrancy_flag++;
   390    }
   391      if (r->r[0] == vsock)
   392          vs_process_input(r->r[1], r->r[2], (char *)(r->r[3]), r->r[4], r->r[5], r->r[6]);
   393      restore_irqs(s);
   394      reentrancy_flag = 0;
   395      return (0);
   396  }
   397  
   398  int udpv_getstatus(_kernel_swi_regs *r)
   399  {
   400      bs_bytes_sent += send_buffers();
   401      r->r[0] = (v_state ==  1 ) ?  0  :  1 ;
   402      r->r[1] = 0;
   403      r->r[2] = 0;
   404      r->r[3] = 0;
   405      return (0);
   406  }
   407  
   408  void init_session(int handle, int skipsize)
   409  {
   410      mpeg_handle = handle;
   411      v_state =  1 ;
   412      skipcount = skipsize;
   413  }
   414  
   415  void close_session(void)
   416  {
   417      v_state =  0 ;
   418  }
   419  
   420  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf)
   421  {
   422      struct mbuf *m0, *m1;
   423      int mlen;
   424      static char *bptr;
   425  
   426      m0 = (struct mbuf *)a;
   427      m1 = (struct mbuf *)ack_buf;
   428  
   429      if (m0 !=  0 )
   430      {
   431         
   436  
   436  
   436  
   436  
   436  
   437        mlen = (*mbctl.count_bytes)(&mbctl, m0);
   438         
   441  
   441  
   441  
   442        if ((mlen > skipcount) && (skipcount > 0))
   443        {
   444          if (skipcount == 4)  
   445          {
   446            u_long raw_sequence, sequence;
   447            int difference;
   448  
   449             (( mbctl .trim)(& mbctl , ( m0 ), ( skipcount ), ( &raw_sequence ))) ;
   450            mlen -= skipcount;
   451            sequence = ntohl(raw_sequence);
   452  
   453            if (sequence_expected == 0)
   454            {
   455              difference = 0;  
   456            }
   457            else
   458            {
   459              difference = sequence - sequence_expected;
+++ Warning: implicit narrowing cast: '='
   460            }
   461  
   462            if (do_debug && difference != 0)
   463            {
   464              printf("Expected: %x off by: %d\n",
   465                       sequence_expected, difference);
   466            }
   467  
   468            if (difference < 0)
   469            {
   470              sequence_OOS++;  
   471              sequence_OOSt += -difference;
   472              if (difference < sequence_OOSm)
   473              {
   474                sequence_OOSm = difference;
   475              }
   476            }
   477            else
   478            {
   479              if (difference > 0)
   480              {
   481                sequence_lost++;
   482                sequence_lostt += difference;
   483                if (difference > sequence_lostm)
   484                {
   485                  sequence_lostm = difference;
   486                }
   487              }
   488               
   489  
   490              sequence_expected = sequence + mlen;  
+++ Warning: implicit narrowing cast: '='
   491            }
   492          }
   493          else
   494          {
   495             (( mbctl .trim)(& mbctl , ( m0 ), ( skipcount ), (  0  ))) ;  
   496            mlen =- skipcount;
   497          }
   498        }
   499  
   500        if (mlen > bs_bufsize)
   501        {
   502          oversized++;
   503        }
   504        else if (mlen < bs_bufsize)
   505        {
   506          undersized++;
   507        }
   508        bytes_received += mlen;
   509        datagrams_received++;
   510        while (mlen > 0)
   511        {
   512          while (mlen > bs_current_residue)
   513          {
   514            if (bs_current_buf !=  0 )
   515            {
   516                
   518  
   518  
   519              (void)  (( mbctl .trim)(& mbctl , ( m0 ), ( bs_current_residue ), ( bptr ))) ;
   520              bs_current_buf->bs_len += bs_current_residue;
   521              mlen -= bs_current_residue;
   522              save_full_buf(bs_current_buf, 0);
   523            }
   524            bs_current_buf = get_empty_buffer();
   525            if (bs_current_buf == 0)
   526            {
   527              discards++;
   528              bs_current_residue = 0;
   529              break;  
   530            }
   531            bs_current_residue = bs_bufsize;
   532            bs_current_buf->bs_len = 0;
   533            bs_current_buf->bs_handle = 0;
   534            bs_current_buf->bs_flags =  0x40007 ;
   535            bptr = bs_current_buf->bs_data;
   536  
   537             
   539  
   539  
   540          }
   541          if (bs_current_residue == 0)
   542          {
   543            break;  
   544          }
   545           
   547  
   547  
   548          (void)  (( mbctl .trim)(& mbctl , ( m0 ), ( mlen ), ( bptr ))) ;
   549          bs_current_buf->bs_len += mlen;
   550          bptr += mlen;
   551          bs_current_residue -= mlen;
   552          mlen = 0;
   553           
   554          if (bs_current_residue == 0)
   555          {
   556            save_full_buf(bs_current_buf, 0);
   557            bs_current_buf =  0 ;
   558          }
   559        }
   560        bs_bytes_sent += send_buffers();  
   561        if (mlen != 0)  
   562        {
   563          empty_failures++;
   564          (void)  (( mbctl .trim)(& mbctl , ( m0 ), (  0x7f000000  ), (  0  ))) ;  
   565        }
   566      }
   567  
   568      if (m1)  
   569      {
   570           (( mbctl .freem)(& mbctl , ( m1 ))) ;
   571      }
   572      return(0);
   573  }
   574  
   575  
   576  
   577  int read_sysvar(char *var, char *buf, int buflen)
   578  {
   579      _kernel_swi_regs r;
   580      _kernel_oserror *e;
   581  
   582      r.r[0] = (int)var;
   583      r.r[1] = (int)buf;
   584      r.r[2] = buflen;
   585      r.r[3] = 0;
   586      r.r[4] = 3;  
   587      e = _kernel_swi( (1U << 17)  |  0x00000023 , &r, &r);
   588      if (e || r.r[2] == 0)
   589          return (0);
   590      buf[r.r[2]] = 0;
   591      return (1);
   592  }
   593  
