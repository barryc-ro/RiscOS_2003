     1   
     7  
     7  
     7  
     7  
     7  
     8  
    11  
    12  
    19  
    22  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  void *module_wsp = 0;
    37  int v_state =  0 ;
    38  
    39  static int discards = 0;
    40  static int oversized = 0;
    41  static int empty_failures = 0;
    42  
    43  int default_video_port = 0;
    44  int video_port = 0;
    45  int bs_bufsize = 0;
    46  int n_bs_buffers = 0;
    47  int bs_minbufs = 0;
    48  int bs_bufpool;
    49  int bs_bytes_sent = 0;
    50  
    51  extern int skipcnt;
    52  extern int bs_minbufs_check;
    53  
    54  int mpeg_handle, vsock, vssock;
    55  int do_debug = 0;
    56  
    57  struct bs_buffer *bs_current_buf;
    58  int bs_current_residue;
    59  
    60  extern _kernel_oserror *calleverytick(void);
    61  extern struct bs_buffer *get_empty_buffer(void);
    62  
    63  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw);
    64  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw);
    65  void udpv_show(int argc , char **argv );
    66  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw);
    67  int do_getsock(int port, int inputsocket);
    68  int udpv_startofplay(_kernel_swi_regs *r);
    69  int udpv_endofplay(_kernel_swi_regs *r);
    70  int udpv_empty_buf(_kernel_swi_regs *r);
    71  int udpv_nullswi(_kernel_swi_regs *r);
    72  int udpv_rxdirect(_kernel_swi_regs *r);
    73  int udpv_getstatus(_kernel_swi_regs *r);
    74  void init_session(int handle, int skipsize);
    75  void close_session(void );
    76  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf);
    77  int send_full_buf(int b, int flag);
    78  int read_sysvar(char *var, char *buf, int buflen);
    79  
    80  struct swient {
    81      int (*swi_call)();       
    82  };
    83  
    84  
    85   
    86  
    87  
    88  struct swient udpv_ent[ 31 ] = {
    89      udpv_nullswi,
    90      udpv_nullswi,
    91      udpv_nullswi,
    92      udpv_nullswi,
    93      udpv_nullswi,
    94      udpv_nullswi,
    95      udpv_nullswi,
    96      udpv_empty_buf,
    97      udpv_nullswi,
    98      udpv_endofplay,
    99      udpv_startofplay,
   100      udpv_nullswi,
   101      udpv_nullswi,
   102      udpv_nullswi,
   103      udpv_nullswi,
   104      udpv_nullswi,
   105      udpv_getstatus,
   106      udpv_nullswi,
   107      udpv_nullswi,
   108      udpv_nullswi,
   109      udpv_nullswi,
   110      udpv_nullswi,
   111      udpv_nullswi,
   112      udpv_nullswi,
   113      udpv_nullswi,
   114      udpv_nullswi,
   115      udpv_nullswi,
   116      udpv_nullswi,
   117      udpv_nullswi,
   118      udpv_rxdirect,
   119      0,
   120  };
   121  
   122  
   123  
   124  struct client {
   125          int (*cli_call)();       
   126  };
   127  
   128  
   129  
   130  struct client udpv_cli_call[ 2 ] = {
   131      (int (*)())udpv_show
   132  };
   133  
   134  
   135  _kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw)
   136  {
   137      char buf[32];
   138  
   139      module_wsp = pw;
   140      if (!mb_present())
   141          return ((_kernel_oserror *)0);
   142      (void) mb_entryinit();
   143  
   144      if (read_sysvar("MPEG$UDPport", buf, sizeof(buf)) != 0)
   145          default_video_port = atoi(buf);
   146      else
   147          default_video_port =  0x801a ;
   148  
   149      if (read_sysvar("MPEG$UDPdsize", buf, sizeof(buf)) != 0)
   150          bs_bufsize = atoi(buf);
   151      else
   152          bs_bufsize = 8192;
   153  
   154      if (read_sysvar("UDP$Debug", buf, sizeof(buf)) != 0)
   155          do_debug = 1;
   156  
   157      if (read_sysvar("MPEG$BufPool", buf, sizeof(buf)) != 0)
   158      {
   159        bs_bufpool = atoi(buf);
   160        if (bs_bufpool < bs_bufsize)
   161        {
   162          bs_bufpool =  850*376 ;  
   163        }
   164      }
   165      else
   166      {
   167        bs_bufpool =  850*376 ;
   168      }
   169  
   170      n_bs_buffers = (bs_bufpool) / bs_bufsize;
   171  
   172      if (read_sysvar("MPEG$MinBufs", buf, sizeof(buf)) != 0)
   173      {
   174          bs_minbufs = atoi(buf);
   175      }
   176      else
   177      {
   178          bs_minbufs = 0;
   179      }
   180  
   181      init_bs_buffers();
   182      vsock = -1;
   183      return ((_kernel_oserror *)0);
   184  }
   185  
   186  
   187  _kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw)
   188  {
   189      struct client *callp;
   190      int margc;
   191      char *margv[10];
   192      char *cp;
   193      char **argp = margv;
   194  
   195      margc = 0;
   196      cp = arg_string;
   197      while (*cp && (arg_count-- > 0) && (margc < 10))
   198      {
   199          while ( (__ctype[ *cp ] &  1 ) )
   200          {
   201              cp++;
   202          }
   203          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   204              break;
   205          *argp++ = cp;
   206          margc++;
   207          while (*cp != '\0' && ! (__ctype[ *cp ] &  64 )  && ! (__ctype[ *cp ] &  1 ) )
   208          {
   209              cp++;
   210          }
   211          if (*cp == '\0' ||  (__ctype[ *cp ] &  64 ) )
   212              break;
   213          *cp++ = '\0';
   214      }
   215      *argp++ = 0;
   216      callp = &udpv_cli_call[cmd_no];
   217      (void)(*(callp->cli_call))(margc, margv);
   218      return ((_kernel_oserror *)0);
   219  }
   220  
   221  void udpv_show(int argc, char **argv)
   222  {
   223      printf("videoport=%d (%x), lastport=%d, emptyfailure=%d\n",
   224                 default_video_port, default_video_port, video_port, empty_failures);
   225      printf("bs_bufpool=%d, n_buffers=%d, bufsize=%d, bs_minbufs=%d (%d frames)\n",
   226                 bs_bufpool, n_bs_buffers, bs_bufsize, bs_minbufs, bs_minbufs_check);
   227      printf("bs_discards=%d, frame oversized=%d\n", discards, oversized);
   228  
   229  
   230  
   231  
   232      print_bufs();
   233  }
   234  
   235  _kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
   236  {
   237      struct swient *callp;
   238  
   239      callp = &udpv_ent[swinum];
   240      return ((_kernel_oserror *)(*(callp->swi_call))(r));
   241  }
   242  
   243  int do_getsock(int port, int inputsocket)
   244  {
   245      struct sockaddr_in addr;
   246      int arg, sock, on = 1;
   247  
   248      if ((sock = socket( 2 ,  2 , 0)) < 0)
   249          return (-1);
   250      arg =  0x4001d ;
   251      if (socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 126 ) ))   , &on) < 0 || socketioctl(sock,    (  0x80000000   | (( sizeof( int )  &  0x1fff ) << 16) | (( ( 'f' ) ) << 8) | ( ( 122 ) ))   , &arg) < 0)
   252      {
   253          socketclose (sock);
   254          return (-1);
   255      }
   256      arg = ( 64*1024 );
   257      if (setsockopt(sock,  0xffff ,  0x0020 , &on, sizeof (on)) < 0 ||
   258          setsockopt(sock,  0xffff ,  0x1002 , &arg, sizeof (arg)) < 0)
   259      {
   260          socketclose(sock);
   261          return (-1);
   262      }
   263      if (inputsocket)
   264      {
   265          addr.sin_family      =  2 ;
   266          addr.sin_addr.s_addr =  ntohl(  (u_long)0x00000000  ) ;
   267          addr.sin_port        =  ntohs( (u_short)port ) ;
   268          if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0)
   269          {
   270              socketclose(sock);
   271              return (-1);
   272          }
   273      }
   274      return (sock);
   275  }
   276  
   277  int udpv_startofplay(_kernel_swi_regs *r)
   278  {
   279      int port = r->r[2];
   280  
   281  
   282      if (port == 0)
   283          port = default_video_port;
   284  
   285      if (do_debug)
   286          printf("        Get socket for port %d\n", port);
   287      if (port != video_port && vsock != -1)
   288      {
   289          socketclose(vsock);
   290          vsock = -1;
   291      }
   292      if (vsock == -1)
   293      {
   294          vsock = do_getsock(port, 1);
   295          if (do_debug && vsock < 0)
   296              printf("          Socket open failed!\n");
   297      }
   298      if (vsock >= 0)
   299      {
   300          video_port = port;
   301          init_mpeg_buffers();
   302          init_session(r->r[3], r->r[4]);
   303      }
   304      return (0);
   305  }
   306  
   307  int udpv_endofplay(_kernel_swi_regs *r)
   308  {
   309      close_session();
   310      return (0);
   311  }
   312  
   313  int udpv_empty_buf(_kernel_swi_regs *r)
   314  {
   315      if (r->r[2] != 0)
   316          return_empty_buf((struct bs_buffer *)r->r[2],1);
   317      r->r[2] = 0;
   318      return (0);
   319  }
   320  
   321  int udpv_nullswi(_kernel_swi_regs *r)
   322  {
   323      return (0);
   324  }
   325  
   326  int udpv_rxdirect(_kernel_swi_regs *r)
   327  {
   328      int s = ensure_irqs_on();
   329      if (r->r[0] == vsock)
   330          vs_process_input(r->r[1], r->r[2], (char *)(r->r[3]), r->r[4], r->r[5], r->r[6]);
   331      restore_irqs(s);
   332      return (0);
   333  }
   334  
   335  int udpv_getstatus(_kernel_swi_regs *r)
   336  {
   337      bs_bytes_sent += send_buffers();
   338      r->r[0] = (v_state ==  1 ) ?  0  :  1 ;
   339      r->r[1] = 0;
   340      r->r[2] = 0;
   341      r->r[3] = 0;
   342      return (0);
   343  }
   344  
   345  void init_session(int handle, int skipsize)
   346  {
   347      mpeg_handle = handle;
   348      v_state =  1 ;
   349      skipcnt = skipsize;
   350  }
   351  
   352  void close_session(void)
   353  {
   354      v_state =  0 ;
   355  }
   356  
   357  int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf)
   358  {
   359      struct mbuf *m0, *m1;
   360      int mlen;
   361      static char *bptr;
   362  
   363      m0 = (struct mbuf *)a;
   364      m1 = (struct mbuf *)ack_buf;
   365  
   366      if (m0 !=  0 )
   367      {
   368         
   373  
   373  
   373  
   373  
   373  
   374  
   375        mlen = (*mbctl.count_bytes)(&mbctl, m0);
   376        if (mlen > bs_bufsize)
   377        {
   378          oversized++;
   379        }
   380        while (mlen > 0)
   381        {
   382          while (mlen > bs_current_residue)
   383          {
   384            if (bs_current_buf !=  0 )
   385            {
   386                
   387  
   388              (void)  (( mbctl .trim)(& mbctl , ( m0 ), ( bs_current_residue ), ( bptr ))) ;
   389              bs_current_buf->bs_len += bs_current_residue;
   390              mlen -= bs_current_residue;
   391              save_full_buf(bs_current_buf, 0);
   392            }
   393            bs_current_buf = get_empty_buffer();
   394            if (bs_current_buf == 0)
   395            {
   396              discards++;
   397              bs_current_residue = 0;
   398              break;  
   399            }
   400            bs_current_residue = bs_bufsize;
   401            bs_current_buf->bs_len = 0;
   402            bs_current_buf->bs_handle = 0;
   403            bs_current_buf->bs_flags =  0x40007 ;
   404            bptr = bs_current_buf->bs_data;
   405          }
   406           
   407  
   408          if (bs_current_residue == 0)
   409          {
   410            break;  
   411          }
   412           
   413  
   414          (void)  (( mbctl .trim)(& mbctl , ( m0 ), ( mlen ), ( bptr ))) ;
   415          bs_current_buf->bs_len += mlen;
   416          bptr += mlen;
   417          bs_current_residue -= mlen;
   418          mlen = 0;
   419           
   420          if (bs_current_residue == 0)
   421          {
   422            save_full_buf(bs_current_buf, 0);
   423            bs_current_buf =  0 ;
   424          }
   425        }
   426        bs_bytes_sent += send_buffers();  
   427        if (mlen != 0)  
   428        {
   429          empty_failures++;
   430          (void)  (( mbctl .trim)(& mbctl , ( m0 ), (  0x7f000000  ), (  0  ))) ;  
   431        }
   432      }
   433  
   434      if (m1)  
   435      {
   436           (( mbctl .freem)(& mbctl , ( m1 ))) ;
   437      }
   438      return(0);
   439  }
   440  
   441  
   442  
   443  int read_sysvar(char *var, char *buf, int buflen)
   444  {
   445      _kernel_swi_regs r;
   446      _kernel_oserror *e;
   447  
   448      r.r[0] = (int)var;
   449      r.r[1] = (int)buf;
   450      r.r[2] = buflen;
   451      r.r[3] = 0;
   452      r.r[4] = 0;
   453      e = _kernel_swi( (1U << 17)  |  0x00000023 , &r, &r);
   454      if (e || r.r[2] == 0)
   455          return (0);
   456      buf[r.r[2]] = 0;
   457      return (1);
   458  }
   459  
