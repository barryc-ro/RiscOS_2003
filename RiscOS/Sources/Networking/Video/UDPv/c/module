/*
 * module.c
 *
 * RISC OS environmental dependencies
 *
 */
#include "types.h"
#include "uio.h"
#include "socket.h"
#include "ioctl.h"
#include "in.h"
#include "if.h"
#include "stdio.h"
#include "errno.h"
#include "ctype.h"
#include "netdb.h"
#include <kernel.h>
#include <swis.h>
#include "module.h"
#include "mbuf.h"

#define VIDEO_PORT      0x801a

#define IDLE            0
#define PLAYING         1

#define IDLE_TIMEOUT    2

#define TickerV         28

extern int tick_entry();
extern char *malloc();
void *module_wsp = 0;
struct bs_buffer *get_empty_buffer();
int v_state = IDLE;
extern int bs_sent = 0;
int discards = 0;
int idletimer = 0;
int idleval = 0;
static int is_paused = 0;
int video_port = 0;
int rxsize = 0;
int skipsize = 0;
int bs_bufsize = 0;
int n_bs_buffers = 0;
extern int skipcnt;

struct swient {
    int (*swi_call)();      /* swi handler */
};

#define MAXSWI 31
extern int udpv_empty_buf(), udpv_nullswi(), udpv_final();
extern int udpv_startofplay(), udpv_endofplay(), udpv_getstatus(), udpv_rxdirect();

struct swient udpv_ent[MAXSWI] = {
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_empty_buf,
    udpv_nullswi,
    udpv_endofplay,
    udpv_startofplay,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_getstatus,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_rxdirect,
    0,
};

#define UdpV_RxDirect 0x4001d

struct client {
        int (*cli_call)();      /* cli handler */
};

#define MAXCLIENT 3

int udpv_show(), udpv_tout();

struct client udpv_cli_call[MAXCLIENT] = {
    udpv_show,
    udpv_tout,
    0,
};

int mpeg_handle, vsock, vssock;

extern _kernel_oserror *calleverytick();

/*ARGS_USED*/
_kernel_oserror *
udpv_init(cmd_tail, pbase, pw)
char *cmd_tail;
int pbase;
void *pw;
{
    char buf[32];

    module_wsp = pw;
    if (read_sysvar("MPEG$EOSTimeout", buf, sizeof(buf)) != 0) 
        idleval = atoi(buf);
    if (idleval > 100) 
        idleval = idleval / 100;
    else
        idleval = IDLE_TIMEOUT;
    if (read_sysvar("OVS$SkipHdrCnt", buf, sizeof(buf)) != 0) 
        skipsize = atoi(buf);
    if (!mb_present())
        return ((_kernel_oserror *)0);
    (void) mb_entryinit();
    if (read_sysvar("MPEG$UDPport", buf, sizeof(buf)) != 0) 
        video_port = atoi(buf);
    else
        video_port = VIDEO_PORT;
    if (read_sysvar("MPEG$UDPdsize", buf, sizeof(buf)) != 0) 
        bs_bufsize = atoi(buf);
    else
        bs_bufsize = 8192;
    n_bs_buffers = (850 * 376) / bs_bufsize;
    (void) enable_tick_handler();
    init_bs_buffers();
    vsock = -1;
    atexit(udpv_final);
    return ((_kernel_oserror *)0);
}

int tick_handler(r)
_kernel_swi_regs *r;
{
    if (!is_paused && (idletimer > 0 && --idletimer == 0)) 
        v_state = IDLE;
    return (1);
}

int enable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = 100;
  r.r[1] = (int)tick_entry;
  r.r[2] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_CallEvery, &r, &r) != 0 ? -1 : 0);
}

int disable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = (int)tick_entry;
  r.r[1] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_RemoveTickerEvent, &r, &r) != 0 ? -1 : 0);
}

int udpv_final(void)
{
   (void) disable_tick_handler();
   return (0);
}

/*ARGSUSED*/
_kernel_oserror *
udpv_cli_handler(arg_string, arg_count, cmd_no, pw)
char *arg_string;
int arg_count, cmd_no;
void *pw;
{
    struct client *callp;
    int margc;
    char *margv[10];
    char *cp;
    char **argp = margv;

    margc = 0;
    cp = arg_string;
    while (*cp && arg_count-- > 0) {
        while (isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !iscntrl(*cp) && !isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;                                    
    callp = &udpv_cli_call[cmd_no];
    (void)(*(callp->cli_call))(margc, margv);
    return ((_kernel_oserror *)0);
}

udpv_show(argc, argv)
int argc;
char **argv;
{
    printf("idleval=%d, videoport=%d (%x), rxbufsize=%d\n", 
               idleval, video_port, video_port, rxsize);
    printf("n_buffers+%d, bufsize=%d\n", n_bs_buffers, bs_bufsize);
    print_bufs();
}

udpv_tout(argc, argv)
int argc;
char **argv;
{
    int val = atoi(argv[0]);

    if (val > 0)
        idleval = val * 100;
    else
        idleval = 0;
}

_kernel_oserror *
udpv_swi_handler(swinum, r, pw)
int swinum;
_kernel_swi_regs *r;
void *pw;
{       
    struct swient *callp;

    callp = &udpv_ent[swinum];
    return ((_kernel_oserror *)(*(callp->swi_call))(r));
}

int
do_getsock(port, inputsocket)
int port, inputsocket;
{
    struct sockaddr_in addr;
    int arg, sock, on = 1;

    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) 
        return (-1);
    arg = UdpV_RxDirect;
    if (socketioctl(sock, FIONBIO, &on) < 0 || socketioctl(sock, FIORXDIR, &arg) < 0) {
        socketclose (sock);
        return (-1);
    }
    arg = (32*1024);
    if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0 ||
        setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &arg, sizeof (arg)) < 0) {
        socketclose(sock);
        return (-1);
    }
    if (inputsocket) {
        addr.sin_family      = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port        = htons((u_short)port);
        if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {
            socketclose(sock);
            return (-1);
        }
    }
    return (sock);
}

int udpv_startofplay(r)
_kernel_swi_regs *r;
{
    if (vsock == -1)
        vsock = do_getsock(video_port, 1);
    if (vsock >= 0) {
        init_mpeg_buffers();
        init_session((char *)r->r[1], r->r[2], r->r[3], r->r[4]);
    }
    return (0);
}

int udpv_endofplay(r)
_kernel_swi_regs *r;
{
    close_session();
    return (0);
}

int udpv_empty_buf(r)
_kernel_swi_regs *r;
{
    if (r->r[2] != 0) 
        return_empty_buf(r->r[2]);
    r->r[2] = 0; 
    return (0);
}

int udpv_nullswi(r)
_kernel_swi_regs *r;
{
    return (0);
}

int udpv_rxdirect(r)
_kernel_swi_regs *r;
{
    int s = ensure_irqs_on();
    if (r->r[0] == vsock) 
        vs_process_input(r->r[1], r->r[2], (char *)(r->r[3]), r->r[4], r->r[5], r->r[6]);
    restore_irqs(s);
    return (0);
}

int udpv_getstatus(r)
_kernel_swi_regs *r;
{
    send_buffers();
    is_paused = r->r[1];
    if (is_paused)
        idletimer = 0;
    r->r[0] = (v_state == PLAYING) ? PLAY_INPROGRESS : PLAY_TERMINATED;
    r->r[1] = 0;
    r->r[2] = 0;
    r->r[3] = 0;
    return (0);
}

init_session(macadr, id, handle, doskiphdr) 
char *macadr; 
u_short id; 
int handle;
int doskiphdr;
{
    macadr = macadr;
    id = id;
    mpeg_handle = handle;
    is_paused = 0;
    v_state = PLAYING;
    if (doskiphdr != 0)
        skipcnt = skipsize;
}

close_session()
{
    is_paused = 0;
    v_state = IDLE;
}

#if 0
int
vs_process_input(a, b, ack_src, ack_unit, ack_swi, ack_buf)
int a, b;
char *ack_src;
int ack_unit, ack_swi, ack_buf;
{                
    struct mbuf *m, *m0, *m1;
    struct bs_buffer *bs;

    m0 = (struct mbuf *)a;
    m1 = (struct mbuf *)ack_buf;
    if (m0 == 0) 
        goto out;
    for (m = m0; m; m = m->m_next) {
        if (m->m_len == 0)
            continue;
        idletimer = idleval;
        if ((bs = get_empty_buffer()) == 0) {
            discards++;
            break;
        }
        memcpy(bs->bs_data, mtod(m, char *), m->m_len);
        bs->bs_len = m->m_len;
        bs->bs_handle = 0;
        bs->bs_flags = FREE_BUFFER_SWI;
        save_full_buf(bs, 0);
    }
    m0->m_len = 0;
out:
    if (m1) 
        m_freem(m1);
}
#else
int
vs_process_input(a, b, ack_src, ack_unit, ack_swi, ack_buf)
int a, b;
char *ack_src;
int ack_unit, ack_swi, ack_buf;
{                
    struct mbuf *m, *m0, *m1;
    struct bs_buffer *bs = 0;
    int mlen, residue = 0;
    char *bptr;

    m0 = (struct mbuf *)a;
    m1 = (struct mbuf *)ack_buf;
    if (m0 == 0) 
        goto out;
    for (m = m0; m; m = m->m_next) {
        if ((mlen = m->m_len) == 0)
            continue;
        idletimer = idleval;
        if (mlen > residue) {
            if (bs != 0) 
                save_full_buf(bs, 0);
            if ((bs = get_empty_buffer()) == 0) {
                discards++;
                break;
            }
            residue = bs_bufsize;
            bptr = bs->bs_data;
            bs->bs_len = 0;
            bs->bs_handle = 0;
            bs->bs_flags = FREE_BUFFER_SWI;
        }
        memcpy(bptr, mtod(m, char *), mlen);
        bs->bs_len += mlen;
        bptr += mlen;
        residue -= mlen;
   }
   if (bs != 0) {
        rxsize = bs->bs_len; 
        save_full_buf(bs, 0); 
   }
   send_buffers();
   m0->m_len = 0;
out:
    if (m1) 
        m_freem(m1);
}
#endif

#define MPEGControl_FullBuffers 0x492c1

send_full_buf (b, flag)
int b, flag;
{
    _kernel_swi_regs r;

    r.r[0] = flag;
    r.r[1] = mpeg_handle;
    r.r[2] = b;
    (void) _kernel_swi(XOS_Bit | MPEGControl_FullBuffers, &r, &r);
}

int read_sysvar(var, buf, buflen)
char *var, *buf;
int buflen;
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = (int)var;
    r.r[1] = (int)buf;
    r.r[2] = buflen;
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
    if (e || r.r[2] == 0) 
        return (0);
    buf[r.r[2]] = 0;
    return (1);
}
