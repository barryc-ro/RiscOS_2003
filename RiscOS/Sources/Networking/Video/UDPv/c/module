/*
 * module.c
 *
 * RISC OS environmental dependencies
 *
 */
#include "socklib.h"
#include "inetlib.h"


#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <kernel.h>
#include <swis.h>
#include <string.h>

#include "sys/filio.h"
#include "sys/mbuf.h"

#include "module.h"
#include "mbuffn.h"
#include "bufs.h"

#define VIDEO_PORT      0x801a

#define IDLE            0
#define PLAYING         1

#define SO_RECV_BUF_SIZE   64*1024
#define MPEG_BUF_POOL_SIZE 850*376

#define TickerV         28

void *module_wsp = 0;
int v_state = IDLE;

static int discards = 0;
static int oversized = 0;
static int undersized = 0;
static int empty_failures = 0;
static unsigned int bytes_received = 0;
static unsigned int datagrams_received = 0;
static int sequence_lost = 0;
static int sequence_lostm = 0;
static int sequence_lostt = 0;
static int sequence_OOS = 0;
static int sequence_OOSm = 0;
static int sequence_OOSt = 0;
static int reentered = 0;
static volatile int reentrancy_flag;

int default_video_port = 0;
int video_port = 0;
int bs_bufsize = 0;
int n_bs_buffers = 0;
int bs_minbufs = 0;
int bs_bufpool;
int bs_bytes_sent = 0;

static int skipcount = 0;
static unsigned int sequence_expected;

extern int bs_minbufs_check;

int mpeg_handle, vsock, vssock;
int do_debug = 0;

struct bs_buffer *bs_current_buf;
int bs_current_residue;

extern _kernel_oserror *calleverytick(void);
extern struct bs_buffer *get_empty_buffer(void);

_kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw);
_kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw);
void udpv_show(int argc , char **argv );
_kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw);
int do_getsock(int port, int inputsocket);
int udpv_startofplay(_kernel_swi_regs *r);
int udpv_endofplay(_kernel_swi_regs *r);
int udpv_empty_buf(_kernel_swi_regs *r);
int udpv_nullswi(_kernel_swi_regs *r);
int udpv_rxdirect(_kernel_swi_regs *r);
int udpv_getstatus(_kernel_swi_regs *r);
void init_session(int handle, int skipsize);
void close_session(void );
int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf);
int send_full_buf(int b, int flag);
int read_sysvar(char *var, char *buf, int buflen);

struct swient {
    int (*swi_call)();      /* swi handler */
};

#define MAXSWI 31

struct swient udpv_ent[MAXSWI] = {
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_empty_buf,
    udpv_nullswi,
    udpv_endofplay,
    udpv_startofplay,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_getstatus,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_nullswi,
    udpv_rxdirect,
    0,
};

#define UdpV_RxDirect 0x4001d

struct client {
        int (*cli_call)();      /* cli handler */
};

#define MAXCLIENT 2

struct client udpv_cli_call[MAXCLIENT] = {
    (int (*)())udpv_show
};


_kernel_oserror *udpv_init(char *cmd_tail, int pbase, void *pw)
{
    char buf[32];

    module_wsp = pw;
    if (!mb_present())
        return ((_kernel_oserror *)0);
    (void) mb_entryinit();

    if (read_sysvar("MPEG$UDPport", buf, sizeof(buf)) != 0)
        default_video_port = atoi(buf);
    else
        default_video_port = VIDEO_PORT;

    if (read_sysvar("MPEG$UDPdsize", buf, sizeof(buf)) != 0)
        bs_bufsize = atoi(buf);
    else
        bs_bufsize = 8192;

    if (read_sysvar("UDP$Debug", buf, sizeof(buf)) != 0)
        do_debug = 1;

    if (read_sysvar("MPEG$BufPool", buf, sizeof(buf)) != 0)
    {
      bs_bufpool = atoi(buf);
      if (bs_bufpool < bs_bufsize)
      {
        bs_bufpool = MPEG_BUF_POOL_SIZE; /* Guess at minimum sensible value */
      }
    }
    else
    {
      bs_bufpool = MPEG_BUF_POOL_SIZE;
    }

    n_bs_buffers = (bs_bufpool) / bs_bufsize;

    if (read_sysvar("MPEG$MinBufs", buf, sizeof(buf)) != 0)
    {
        bs_minbufs = atoi(buf);
    }
    else
    {
        bs_minbufs = 0;
    }

    init_bs_buffers();
    vsock = -1;
    return ((_kernel_oserror *)0);
}


_kernel_oserror *udpv_cli_handler(char *arg_string, int arg_count, int cmd_no, void *pw)
{
    struct client *callp;
    int margc;
    char *margv[10];
    char *cp;
    char **argp = margv;

    margc = 0;
    cp = arg_string;
    while (*cp && (arg_count-- > 0) && (margc < 10))
    {
        while (isspace(*cp))
        {
            cp++;
        }
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !iscntrl(*cp) && !isspace(*cp))
        {
            cp++;
        }
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;
    callp = &udpv_cli_call[cmd_no];
    (void)(*(callp->cli_call))(margc, margv);
    return ((_kernel_oserror *)0);
}

void udpv_show(int argc, char **argv)
{
    int temp_int, temp_fract;

    printf("videoport=%d (%x)  lastport=%d  skipcount=%d  reentry=%d\n",
               default_video_port, default_video_port, video_port, skipcount, reentered);
    printf("bs_bufpool: %5dKB n_buffers: %-5d bufsize: %3dKB bs_minbufs: %d (%d frames)\n",
               bs_bufpool/1024, n_bs_buffers, bs_bufsize/1024, bs_minbufs, bs_minbufs_check);
    printf("bs_discards: %-12d emptyfailures: %-12d\n", discards, empty_failures);
    if (datagrams_received > 0)
    {
      temp_int = bytes_received/datagrams_received;
      temp_fract = ((bytes_received%datagrams_received)*100)/datagrams_received;
      printf("Datagrams: %d  oversize: %d  undersize: %d  PDU avg: %6d.%-2d\n",
              datagrams_received, oversized, undersized, temp_int, temp_fract);
    }

    if (do_debug && (skipcount == 4))
    {
      printf("Sequence information:\n");
      if (sequence_OOS > 0)
      {
        temp_int = sequence_OOSt/sequence_OOS;
        temp_fract = ((sequence_OOSt%sequence_OOS)*100)/sequence_OOS;
        printf("              OOSes: %-d  (%d)   max: %-d   avg: %3d.%-2d\n",
               sequence_OOS, sequence_OOSt, -sequence_OOSm, temp_int, temp_fract);
      }
      if (sequence_lost > 0)
      {
        temp_int = sequence_lostt/sequence_lost;
        temp_fract = ((sequence_lostt%sequence_lost)*100)/sequence_lost;
        printf("              Losses: %-d  (%d)   max: %-d   avg: %3d.%-2d\n",
               sequence_lost, sequence_lostt, sequence_lostm, temp_int, temp_fract);
      }
    }

    if (do_debug)
    {
      printf("bs_current_buf=%p, bs_current_residue=%d\n",
               bs_current_buf, bs_current_residue);
    }
    print_bufs();
}

_kernel_oserror *udpv_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;

    callp = &udpv_ent[swinum];
    return ((_kernel_oserror *)(*(callp->swi_call))(r));
}

int do_getsock(int port, int inputsocket)
{
    struct sockaddr_in addr;
    int arg, sock, on = 1;

    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
        return (-1);
    arg = UdpV_RxDirect;
    if (socketioctl(sock, FIONBIO, &on) < 0 || socketioctl(sock, FIORXDIR, &arg) < 0)
    {
        socketclose (sock);
        return (-1);
    }
    arg = (SO_RECV_BUF_SIZE);
    if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0 ||
        setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &arg, sizeof (arg)) < 0)
    {
        socketclose(sock);
        return (-1);
    }
    if (inputsocket)
    {
        addr.sin_family      = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port        = htons((u_short)port);
        if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0)
        {
            socketclose(sock);
            return (-1);
        }
    }
    return (sock);
}

int udpv_startofplay(_kernel_swi_regs *r)
{
    int port = r->r[2];

    sequence_expected = 0;
    sequence_OOS = 0;
    sequence_OOSm = 0;
    sequence_OOSt = 0;
    sequence_lost = 0;
    sequence_lostm = 0;
    sequence_lostt = 0;
    discards = 0;
    oversized = 0;
    undersized = 0;
    empty_failures = 0;
    bytes_received = 0;
    datagrams_received = 0;

    if (port == 0)
        port = default_video_port;

    if (do_debug)
        printf("        Get socket for port %d\n", port);
    if (port != video_port && vsock != -1)
    {
        socketclose(vsock);
        vsock = -1;
    }
    if (vsock == -1)
    {
        vsock = do_getsock(port, 1);
        if (do_debug && vsock < 0)
            printf("          Socket open failed!\n");
    }
    if (vsock >= 0)
    {
        video_port = port;
        init_mpeg_buffers();
        init_session(r->r[3], r->r[4]);
    }
    return (0);
}

int udpv_endofplay(_kernel_swi_regs *r)
{
    close_session();
    return (0);
}

int udpv_empty_buf(_kernel_swi_regs *r)
{
    if (r->r[2] != 0)
        return_empty_buf((struct bs_buffer *)r->r[2],1);
    r->r[2] = 0;
    return (0);
}

int udpv_nullswi(_kernel_swi_regs *r)
{
    return (0);
}

int udpv_rxdirect(_kernel_swi_regs *r)
{
  int s = ensure_irqs_on();
  if (reentrancy_flag != 0)
  {
    reentered++;
  }
  else
  {
    reentrancy_flag++;
  }
    if (r->r[0] == vsock)
        vs_process_input(r->r[1], r->r[2], (char *)(r->r[3]), r->r[4], r->r[5], r->r[6]);
    restore_irqs(s);
    reentrancy_flag = 0;
    return (0);
}

int udpv_getstatus(_kernel_swi_regs *r)
{
    bs_bytes_sent += send_buffers();
    r->r[0] = (v_state == PLAYING) ? PLAY_INPROGRESS : PLAY_TERMINATED;
    r->r[1] = 0;
    r->r[2] = 0;
    r->r[3] = 0;
    return (0);
}

void init_session(int handle, int skipsize)
{
    mpeg_handle = handle;
    v_state = PLAYING;
    skipcount = skipsize;
}

void close_session(void)
{
    v_state = IDLE;
}

int vs_process_input(int a, int b, char *ack_src, int ack_unit, int ack_swi, int ack_buf)
{
    struct mbuf *m0, *m1;
    int mlen;
    static char *bptr;

    m0 = (struct mbuf *)a;
    m1 = (struct mbuf *)ack_buf;

    if (m0 != NULL)
    {
      /* Replacement for block of Keith's code:    *
       * use MBuf manager supplied routines rather *
       * than walking mbuf chains manually & using *
       * CLib memcpy - the mbuf manager is likely  *
       * to be more optimal.                       *
       */
      mlen = (*mbctl.count_bytes)(&mbctl, m0);
      /* Introduced the following block of code to support OptiVision sequenced UDP *
       * on 12-13 Nov 98 to try to assist TMD in tracking down the MPEG replay      *
       * jitter problem that's apparent.                                            *
       */
      if ((mlen > skipcount) && (skipcount > 0))
      {
        if (skipcount == 4) /* Special case of a 4-byte sequence number */
        {
          u_long raw_sequence, sequence;
          int difference;

          TRIM(m0, skipcount, &raw_sequence);
          mlen -= skipcount;
          sequence = ntohl(raw_sequence);

          if (sequence_expected == 0)
          {
            difference = 0; /* First time around, so don't know what to expect */
          }
          else
          {
            difference = (int) (sequence - sequence_expected);
          }

          if (do_debug && difference != 0)
          {
            printf("Expected: %x off by: %d\n",
                     sequence_expected, difference);
          }

          if (difference < 0)
          {
            sequence_OOS++; /* We've received some 'old' data */
            sequence_OOSt += -difference;
            if (difference < sequence_OOSm)
            {
              sequence_OOSm = difference;
            }
          }
          else
          {
            if (difference > 0)
            {
              sequence_lost++;
              sequence_lostt += difference;
              if (difference > sequence_lostm)
              {
                sequence_lostm = difference;
              }
            }
            /* In both the normal and lost data cases, correct the sequence number *
             * expectation for the next datagram.                                  */
            sequence_expected = (int) (sequence + mlen); /* OptiVision UDP seq.number */
          }
        }
        else
        {
          TRIM(m0, skipcount, NULL); /* throw away unwanted bytes */
          mlen =- skipcount;
        }
      }

      if (mlen > bs_bufsize)
      {
        oversized++;
      }
      else if (mlen < bs_bufsize)
      {
        undersized++;
      }
      bytes_received += mlen;
      datagrams_received++;
      while (mlen > 0)
      {
        while (mlen > bs_current_residue)
        {
          if (bs_current_buf != NULL)
          {
             /* remove residue bytes from mbuf chain, copy to bptr,
              *  and update mbuf chain to reflect the removal of these.
              */
            (void) TRIM(m0, bs_current_residue, bptr);
            bs_current_buf->bs_len += bs_current_residue;
            mlen -= bs_current_residue;
            save_full_buf(bs_current_buf, 0);
          }

          bs_current_buf = get_empty_buffer();
          if (bs_current_buf == 0)
          {
            discards++;
            bs_current_residue = 0;
            break; /* Fall out of inner while loop */
          }
          bs_current_residue = bs_bufsize;
          bs_current_buf->bs_len = 0;
          bs_current_buf->bs_handle = 0;
          bs_current_buf->bs_flags = FREE_BUFFER_SWI;
          bptr = bs_current_buf->bs_data;

          /* When we fall out of this loop, we've either exhausted the buffer pool,
           * or there are less than bs_current_residue bytes left in the mbuf chain.
           */
        }
        if (bs_current_residue == 0)
        {
          break; /* Fall out of outer while loop */
        }

        /* remove remaining mlen bytes from mbuf chain, copy to bptr,
         * and update mbuf chain to reflect the removal of these.
         */
        (void) TRIM(m0, mlen, bptr);

        /*
         * 07-Feb-2000 (ADH): Code used to read as follows:
         *
         *   bs_current_buf->bs_len += mlen;
         *   bptr += mlen;
         *   bs_current_residue -= mlen;
         *   mlen = 0;
         *   /(STAR) catch case where this exactly fills the bs_buffer (STAR)/
         *   if (bs_current_residue == 0)
         *   {
         *     save_full_buf(bs_current_buf, 0);
         *     bs_current_buf = NULL;
         *   }
         *
         * Now modified to send out all buffers, even if not full, because the
         * module beforehand would hold on to the last fragment of data it got.
         * This hid things like "end of stream" markers in MPEG data and so-on.
         * Possible side effect: Buffer overflow if the MPEG software decides
         * to hold on to a group of our buffers for some reason, as we're no
         * longer always collating data into 8K chunks for it.
         */

        if (bs_current_buf != NULL)
        {
          bs_current_buf->bs_len += mlen;
          bptr += mlen;

          save_full_buf(bs_current_buf, 0);
          bs_current_buf = NULL;
        }

        bs_current_residue -= mlen;
        mlen = 0;
      }
      bs_bytes_sent += send_buffers(); /* Send any buffers we've queued */
      if (mlen != 0) /* Suggests bs_buf exhaustion has occurred */
      {
        empty_failures++;
        (void) TRIM(m0, M_COPYALL, NULL); /* Force this buf to be empty */
      }
    }

    if (m1) /* Tidy up the KSR back door approach to the stack */
    {
        m_freem(m1);
    }
    return(0);
}



int read_sysvar(char *var, char *buf, int buflen)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = (int)var;
    r.r[1] = (int)buf;
    r.r[2] = buflen;
    r.r[3] = 0;
    r.r[4] = 3; /* Ask OS to convert varable to string for us */
    e = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
    if (e || r.r[2] == 0)
        return (0);
    buf[r.r[2]] = 0;
    return (1);
}
