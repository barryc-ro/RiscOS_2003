/**************************************************************/
/* File:    module.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: The UDPV module gets given data as it arrives by  */
/*          the Internet module. It puts this into a single   */
/*          large rolling internal buffer and passes          */
/*          pointers to the chunks of data to MPEGControl,    */
/*          which later calls back to release those chunks.   */
/*                                                            */
/* Author:  Andrew Hodgkinson.                                */
/*                                                            */
/* History: 27-Mar-2000 (ADH): Standard comment header added. */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <socklib.h>
#include <inetlib.h>
#include <sys/filio.h>
#include <sys/mbuf.h>

#include "bufs.h"
#include "global.h"
#include "mbuf.h"
#include "UDPVHdr.h"

#include "module.h"

/* Default port number to use in absence of any other instructions */

#define VIDEO_PORT       0x801a

/* These are our internal states */

#define IDLE             0
#define PLAYING          1

/* The above are mapped to the following for UDPV_StreamStatus */

#define PLAY_INPROGRESS  0
#define PLAY_TERMINATED  1

/* Receive buffer size for the video data socket */

#define SO_RECV_BUF_SIZE 64*1024

/* Main buffer size */

#define BUFFER_SIZE (524288u)

/* If we don't have the MPEGControl_FullBuffers SWI number already... */

#ifndef MPEGControl_FullBuffers
  #define MPEGControl_FullBuffers 0x492c1
#endif

/* Local variables */

#ifdef TRACE
  static int          sequence_lost  = 0;
  static int          sequence_lostm = 0;
  static int          sequence_lostt = 0;
  static int          sequence_OOS   = 0;
  static int          sequence_OOSm  = 0;
  static int          sequence_OOSt  = 0;
  static unsigned int sequence_expected;
#endif

static void         * module_wsp         = 0;

static int            v_state            = IDLE;
static int            vsock              = -1;
static int            default_video_port = 0;
static int            video_port         = 0;
static bool           mbuf_session_alive = false;

static int            skipcount          = 0;

static unsigned int   bytes_received     = 0;
static unsigned int   datagrams_received = 0;

/* Local functions */

static void udpv_atexit       (void);
static void udpv_show         (void);

static int  udpv_startofplay  (_kernel_swi_regs *r);
static int  udpv_endofplay    (_kernel_swi_regs *r);
static int  udpv_emptybuffer  (_kernel_swi_regs *r);
static int  udpv_nullswi      (_kernel_swi_regs *r);
static int  udpv_rxdirect     (_kernel_swi_regs *r);
static int  udpv_streamstatus (_kernel_swi_regs *r);

static int  read_sysvar       (char *var, char *buf, int buflen);

static int  do_getsock        (int port, int inputsocket);
static void init_session      (int handle, int skipsize);
static void close_session     (void);

static int  vs_process_input  (int a, int b, char * ack_src, int ack_unit, int ack_swi, int ack_buf);

/* SWI dispatch table */

struct swient
{
  int (*swi_call)();
};

#define MAXSWI 31

struct swient udpv_ent[MAXSWI] =
{
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_emptybuffer,
  udpv_nullswi,
  udpv_endofplay,
  udpv_startofplay,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_streamstatus,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_nullswi,
  udpv_rxdirect,        /* Trailing ',' ensures rest is filled with zeros */
};

/* Star command dispatch table */

struct client
{
  static int (*cli_call)();
};

#define MAXCLIENT 1

struct client udpv_cli_call[MAXCLIENT] =
{
  (int (*)())udpv_show, /* Trailing ',' ensures rest is filled with zeros */
};

/**************************************************************/
/* udpv_init()                                                */
/*                                                            */
/* Standard module initialisation code.                       */
/**************************************************************/

_kernel_oserror *udpv_init(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror * e;
  char              buf[32];

  module_wsp = pw;
  atexit(udpv_atexit);

  if (!mbuf_present()) return NULL;

  e = mbuf_opensession();
  if (e != NULL) return e;
  else mbuf_session_alive = true;

  /* Work out which port to use for incoming video data */

  if (read_sysvar("MPEG$UDPport", buf, sizeof(buf)) != 0)
  {
    default_video_port = atoi(buf);
  }
  else
  {
    default_video_port = VIDEO_PORT;
  }

  /*
   * MPEG$UDPSize is deprecated now there's just one rolling buffer and
   * UDP$Debug is only appropriate for TRACE builds. Nice to see
   * consistent naming going on here, too. Well done, people.
   */

  #ifdef TRACE
    if (read_sysvar("UDP$Debug",      buf, sizeof(buf)) != 0) do_debug = 1;
    if (read_sysvar("UDP$TraceLevel", buf, sizeof(buf)) != 0) tl       = atoi(buf);
  #endif

  /*
   * In addition, MPEG$BufPool and MPEG$MinBufs are deprecated. They
   * are replaced by MPEG$BufSize which is the single large buffer
   * size, in bytes.
   */

  if (read_sysvar("MPEG$BufSize", buf, sizeof(buf)) != 0)
  {
    bs_bufsize = atoi(buf);
  }
  else
  {
    bs_bufsize = BUFFER_SIZE;
  }

  bufs_allocate_main_buffer();
  vsock = -1;

  return NULL;
}

/**************************************************************/
/* udpv_atexit()                                              */
/*                                                            */
/* atexit() handler for the module. Note that this is only    */
/* correctly called if the module is built with CMHG 5.30 or  */
/* later.                                                     */
/**************************************************************/

static void udpv_atexit(void)
{
  #if CMHG_VERSION < 530
    #error You need CMHG 5.30 or later to build UDPV.
  #endif

  if (v_state            != IDLE)  close_session();
  if (vsock              != -1)    socketclose(vsock), vsock = -1;
  if (mbuf_session_alive != false) mbuf_closesession();

  bufs_free_main_buffer();
}

/**************************************************************/
/* udpv_cli_handler()                                         */
/*                                                            */
/* Standard module command handler.                           */
/**************************************************************/

_kernel_oserror *udpv_cli_handler(const char *arg_string, int argc, int cmd_no, void *pw)
{
  struct client * callp;

  (void) arg_string;
  (void) argc;
  (void) pw;

  callp   = &udpv_cli_call[cmd_no];
  (void)(*(callp->cli_call))(NULL);

  return NULL;
}

/**************************************************************/
/* udpv_show()                                                */
/*                                                            */
/* Handle *StrmInfo.                                          */
/**************************************************************/

static void udpv_show(void)
{
  int temp_int, temp_fract;

  printf("Video port: &%08X = %-12u Last port:  &%08X = %u\n",
         default_video_port,
         default_video_port,
         video_port,
         video_port);

  printf("Buffer:     &%08X = %-12u Overruns:   &%08X = %u\n",
         BUFFER_SIZE,
         BUFFER_SIZE,
         overruns,
         overruns);

  if (datagrams_received > 0)
  {
    temp_int   = bytes_received / datagrams_received;
    temp_fract = ((bytes_received % datagrams_received) * 100) / datagrams_received;

    printf("Datagrams:  &%08X = %u (PDU average %d.%02d bytes)\n",
           datagrams_received,
           datagrams_received,
           temp_int,
           temp_fract);
  }
}

/**************************************************************/
/* udpv_cli_handler()                                         */
/*                                                            */
/* Standard module SWI handler.                               */
/**************************************************************/

_kernel_oserror *udpv_swi_handler(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  struct swient * callp;

  callp = &udpv_ent[swi_offset];
  return ((_kernel_oserror *)(*(callp->swi_call))(r));
}

/**************************************************************/
/* udpv_startofplay()                                         */
/*                                                            */
/* Handle SWI UDPV_StartOfPlay.                               */
/*                                                            */
/* Parameters: Pointer to a register block - R2 holds the     */
/*             port number or 0 for default, R3 holds the     */
/*             MPEG stream handle (from MPEGControl), and R4  */
/*             holds an amount of data to chop off the front  */
/*             of each packet (if any).                       */
/**************************************************************/

static int udpv_startofplay(_kernel_swi_regs *r)
{
  int port = r->r[2];

  bytes_received     = 0;
  datagrams_received = 0;

  if (port == 0) port = default_video_port;

  #ifdef TRACE
    sequence_expected = 0;
    sequence_OOS      = 0;
    sequence_OOSm     = 0;
    sequence_OOSt     = 0;
    sequence_lost     = 0;
    sequence_lostm    = 0;
    sequence_lostt    = 0;
    if (do_debug) printf("Get socket for port %d\n", port);
  #endif

  /* If the port we're asked for isn't the port we're using */
  /* now (if any), close the existing socket.               */

  if (port != video_port && vsock != -1)
  {
    socketclose(vsock);
    vsock = -1;
  }

  /* Open the requested socket */

  if (vsock == -1)
  {
    vsock = do_getsock(port, 1);

    #ifdef TRACE
      if (do_debug && vsock < 0) printf("Socket open failed!\n");
    #endif
  }

  /* If that worked, mark this new port as our working one and */
  /* initialise the buffers and session.                       */

  if (vsock >= 0)
  {
    video_port = port;
    bufs_allocate_main_buffer(); /* This resets offset pointers and can resize the buffer - see bufs.c */
    init_session(r->r[3], r->r[4]);
  }

  return 0;
}

/**************************************************************/
/* udpv_endendofplay()                                        */
/*                                                            */
/* Handle SWI UDPV_EndOfPlay.                                 */
/*                                                            */
/* Parameters: Pointer to a register block, contents ignored. */
/**************************************************************/

static int udpv_endofplay(_kernel_swi_regs *r)
{
  (void) r;

  close_session();

  return 0;
}

/**************************************************************/
/* udpv_emptybuffer()                                         */
/*                                                            */
/* Handle SWI UDPV_EmptyBuffer.                               */
/*                                                            */
/* Parameters: Pointer to a register block, where R2 on entry */
/*             points to the 'buffer' (actually a chunk of    */
/*             data allocated with our one main buffer) to    */
/*             free, and on exit is set to zero.              */
/**************************************************************/

static int udpv_emptybuffer(_kernel_swi_regs *r)
{
  if (r->r[2] != 0) bufs_release_bs_buffer((bs_buffer *) r->r[2]);
  r->r[2] = 0;

  return 0;
}

/**************************************************************/
/* udpv_nullswi()                                             */
/*                                                            */
/* Handle a null UDPV SWI.                                    */
/*                                                            */
/* Parameters: Pointer to a register block, contents ignored. */
/**************************************************************/

static int udpv_nullswi(_kernel_swi_regs *r)
{
  (void) r;

  return 0;
}

/**************************************************************/
/* udpv_rxdirect()                                            */
/*                                                            */
/* Handle UDPV_RxDirect. This is the "back door" interface    */
/* called by the Internet module and is the point where the   */
/* data pumping is all driven. It's set up through a          */
/* socketioctl call in do_getsock.                            */
/*                                                            */
/* Parameters: Pointer to a register block; R0 holds socket   */
/*             number, the others are documented in the code  */
/*             below. R6 is basically a speed hack for ARM 2  */
/*             machines allowing total bypass of the stack    */
/*             for responses - in our case we just free the   */
/*             mbuf chain we're given with m_freem().         */
/**************************************************************/

static int udpv_rxdirect(_kernel_swi_regs *r)
{
  if (r->r[0] == vsock) vs_process_input(r->r[1],            /* Received data as mbuf */
                                         r->r[2],            /* struct sock_addr holding the source address [unused] */
                                         (char *) (r->r[3]), /* Pointer to the MAC address the source as a 6-byte structure [unused] */
                                         r->r[4],            /* DCI unit number of the interface the packet was received upon [unused] */
                                         r->r[5],            /* Number of the transmit SWI in the DCI driver that received the packet [unused] */
                                         r->r[6]);           /* May be an mbuf (chain) setup to contain an AUN acknowledgement packet (we discard it) */

  return 0;
}

/**************************************************************/
/* udpv_streamstatus()                                        */
/*                                                            */
/* Handle SWI UDPV_StreamStatus.                              */
/*                                                            */
/* Parameters: Pointer to a register block with R0 holding 1  */
/*             if playing else 0 on exit, and R1 through R3   */
/*             all set to zero on exit.                       */
/**************************************************************/

static int udpv_streamstatus (_kernel_swi_regs *r)
{
  r->r[0] = (v_state == PLAYING) ? PLAY_INPROGRESS : PLAY_TERMINATED;
  r->r[1] = 0;
  r->r[2] = 0;
  r->r[3] = 0;

  return 0;
}

/**************************************************************/
/* read_sysvar()                                              */
/*                                                            */
/* Read a given system variable's value as a string into a    */
/* given buffer.                                              */
/*                                                            */
/* Parameters: Pointer to variable name;                      */
/*                                                            */
/*             Pointer to buffer to take value;               */
/*                                                            */
/*             Length of buffer.                              */
/*                                                            */
/* Returns:    0 for failure, 1 for success.                  */
/**************************************************************/

static int read_sysvar(char *var, char *buf, int buflen)
{
  _kernel_swi_regs   r;
  _kernel_oserror  * e;

  r.r[0] = (int)var;
  r.r[1] = (int)buf;
  r.r[2] = buflen;
  r.r[3] = 0;
  r.r[4] = 3; /* Ask OS to convert varable to string for us */

  e = _kernel_swi(OS_ReadVarVal, &r, &r);

  if (e || r.r[2] == 0) return (0);
  buf[r.r[2]] = 0;
  return (1);
}

/**************************************************************/
/* do_getsock()                                               */
/*                                                            */
/* Try to open the listening socket for video data.           */
/*                                                            */
/* Parameters: Port number to read on;                        */
/*                                                            */
/*             0 to just create it but leave it unbound, else */
/*             also bind the socket.                          */
/*                                                            */
/* Returns:    Input socket number or -1 for failuer.         */
/**************************************************************/

static int do_getsock(int port, int inputsocket)
{
  struct sockaddr_in addr;
  int                arg, sock, on;

  /* Create the socket */

  if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) return -1;

  /* Set it up to be non-blocking and direct RX with our data */
  /* processing SWI. Currently, in fact, the SWI *must* be    */
  /* Econet_RxDirect = &4001D, and the argument just has to   */
  /* be non-zero, but we can pretend the interface is more    */
  /* sane at least...                                         */

  on  = 1;
  arg = UDPV_RxDirect;

  if (
       socketioctl(sock, FIONBIO,  &on)  < 0 ||
       socketioctl(sock, FIORXDIR, &arg) < 0
     )
  {
    socketclose(sock);
    return -1;
  }

  /* Set the receive buffer size to SO_RECV_BUF_SIZE */

  arg = (SO_RECV_BUF_SIZE);

  if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &arg, sizeof (arg)) < 0)
  {
    socketclose(sock);
    return -1;
  }

  /* If required, bind it */

  if (inputsocket != 0)
  {
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port        = htons((u_short)port);

    if (bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0)
    {
      socketclose(sock);
      return -1;
    }
  }

  /* Finished */

  return sock;
}

/**************************************************************/
/* init_session()                                             */
/*                                                            */
/* Set some internal flags to initialise a session, including */
/* setting state to "PLAYING".                                */
/*                                                            */
/* Parameters: MPEGControl stream handle;                     */
/*                                                            */
/*             Amount of data to automatically throw away off */
/*             the front of any received packets (normally    */
/*             zero).                                         */
/**************************************************************/

static void init_session(int handle, int skipsize)
{
  mpeg_handle = handle;
  v_state     = PLAYING;
  skipcount   = skipsize;
}

/**************************************************************/
/* close_session()                                            */
/*                                                            */
/* Set state back to "IDLE".                                  */
/**************************************************************/

static void close_session(void)
{
  v_state = IDLE;
}

/**************************************************************/
/* vs_process_input()                                         */
/*                                                            */
/* Called from the UDPV_RxDirect SWI handler. Process input   */
/* data in the given mbuf.                                    */
/*                                                            */
/* Parameters: Pointer to mbuf to look at;                    */
/*                                                            */
/*             b, ack_src, ack_unit and ack_swi are ignored;  */
/*                                                            */
/*             Pointer to another mbuf which has m_freem()    */
/*             called on it after handling the first mbuf.    */
/**************************************************************/

static int vs_process_input(int a, int b, char * ack_src, int ack_unit, int ack_swi, int ack_buf)
{
  struct mbuf * m0, * m1;
  int           mlen;

  /* m1 is an old interface and we need to free the chain that (might) point */
  /* to before exitting. On exit if we leave m0 untouched it'll get passed   */
  /* to the socket in the usual fashion; or engineer it so it's zero length  */
  /* to get the Internet module to free the associated chain without passing */
  /* it on. The TRIM macro does the latter for us.                           */

  m0 = (struct mbuf *) a;
  m1 = (struct mbuf *) ack_buf;

  if (m0 != NULL)
  {
    /*
     * Replacement for block of Keith's code:
     * use MBuf manager supplied routines rather
     * than walking mbuf chains manually & using
     * CLib memcpy - the mbuf manager is likely
     * to be more optimal.
     */

    mlen = (*mbctl.count_bytes)(&mbctl, m0);

    if ((mlen > skipcount) && (skipcount > 0))
    {
      #ifdef TRACE

        /* An attempt to support OptiVision sequenced UDP from round about
         * 12 Nov 1998. Just debugging really, so wrapped in #ifdef TRACE
         * these days.
         */

        if (skipcount == 4) /* Special case of a 4-byte sequence number */
        {
          u_long raw_sequence, sequence;
          int difference;

          TRIM(m0, skipcount, &raw_sequence);
          mlen -= skipcount;
          sequence = ntohl(raw_sequence);

          if (sequence_expected == 0)
          {
            difference = 0; /* First time around, so don't know what to expect */
          }
          else
          {
            difference = (int) (sequence - sequence_expected);
          }

          if (do_debug && difference != 0)
          {
            printf("Expected %x, off by %d\n", sequence_expected, difference);
          }

          if (difference < 0)
          {
            sequence_OOS++; /* We've received some 'old' data */
            sequence_OOSt += -difference;
            if (difference < sequence_OOSm)
            {
              sequence_OOSm = difference;
            }
          }
          else
          {
            if (difference > 0)
            {
              sequence_lost++;
              sequence_lostt += difference;
              if (difference > sequence_lostm)
              {
                sequence_lostm = difference;
              }
            }
            /* In both the normal and lost data cases, correct the sequence number *
             * expectation for the next datagram.                                  */
            sequence_expected = (int) (sequence + mlen); /* OptiVision UDP seq.number */
          }
        }
        else

      #endif

      /* Throw away unwanted data from the front of the buffer before proceeding. */
      /* The skipcount value comes from R4 in UDPV_StartOfPlay.                   */

      {
        TRIM(m0, skipcount, NULL);
        mlen =- skipcount;
      }
    }

    /* Keep a count of data received - this is typically pretty useful */
    /* in debug and non-debug builds.                                  */

    bytes_received += mlen;
    datagrams_received++;

    /* If we have any data [left], send it all to the buffer (if possible) */

    if (mlen > 0)
    {
      bs_buffer * bsb = bufs_claim_bs_buffer(mlen + sizeof(bs_buffer));

      if (bsb == NULL)
      {
        /* Erk, overrun - drop this buffer */

        (void) TRIM(m0, M_COPYALL, NULL);
      }
      else
      {
        /* We'll put the actual data straight after the structure */

        char * bptr = ((char *) bsb) + sizeof(bs_buffer);

        bsb->bs_next    = NULL;             /* We don't use this, the MPEG software does.       */
        bsb->bs_handle  = 0;                /* If zero, flags = SWI to call...                  */
        bsb->bs_flags   = UDPV_EmptyBuffer; /* ...so call UDPV_EmptyBuffer please.              */
        bsb->bs_packets = 0;                /* Must be zero on entry to MPEGControl_FullBuffers */
        bsb->bs_data    = bptr;
        bsb->bs_offset  = bsb->bs_data;
        bsb->bs_len     = mlen;             /* We rely on this being intact at all times.       */

        /* Copy the data into our buffer */

        (void) TRIM(m0, mlen, bptr);

        /* Sent it to the MPEG software */

        _swix(MPEGControl_FullBuffers,
              _INR(0,2),

              0,
              mpeg_handle,
              bsb);
      }
    }
  }

  if (m1 != NULL) /* Tidy up the KSR back door approach to the stack */
  {
    m_freem(m1);
  }

  return 0;
}
