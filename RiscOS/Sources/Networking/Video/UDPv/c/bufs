/**************************************************************/
/* File:    bufs.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: UDPV buffer management.                           */
/*                                                            */
/* Author:  Andrew Hodgkinson.                                */
/*                                                            */
/* History: 27-Mar-2000 (ADH): Created; contents almost       */
/*                             completely replace the old     */
/*                             buffer code.                   */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include <swis.h>

#include <sys/types.h>

#include "global.h"
#include "module.h"

#include "bufs.h"

/* Buffer related locals */

static unsigned int   start      = 0;
static unsigned int   end        = 0;
static char         * buffer     = NULL;

static unsigned int   bs_oldsize = 0;

/**************************************************************/
/* bufs_allocate_main_buffer()                                */
/*                                                            */
/* Allocate and initialise the buffer system. Whenever it is  */
/* called, checks to see if there's an allocated buffer and   */
/* if the current buffer size is different from the would-be  */
/* new buffer size. If it is, the buffers are reallocated,    */
/* else they're left alone (though buffer-related stats are   */
/* reset always).                                             */
/*                                                            */
/* Returns:    1 for success, 0 for failure.                  */
/**************************************************************/

int bufs_allocate_main_buffer(void)
{
  #ifdef TRACE
    if (tl & Trace_Init) printf("bufs_allocate_main_buffer: Called\n");
  #endif

  /* bs_bufsize is set in udpv_init, in module.c */

  if (bs_oldsize != bs_bufsize)
  {
    free(buffer); /* Checks that buffer != NULL internally */
    bs_oldsize = bs_bufsize;

    buffer = calloc(bs_bufsize, 1);
  }

  if (buffer == NULL) return 0;

  overruns = start = end = 0;

  #ifdef TRACE
    if (tl & Trace_Init) printf("bufs_allocate_main_buffer: Initialised at %p\n", buffer);
  #endif

  return 1;
}

/**************************************************************/
/* bufs_free_main_buffer()                                    */
/*                                                            */
/* Release memory claimed for the buffer system.              */
/**************************************************************/

void bufs_free_main_buffer(void)
{
  #ifdef TRACE
    if (tl & Trace_Init) printf("bufs_free_main_buffer: Called\n");
  #endif

  free(buffer), buffer = NULL;
}

/**************************************************************/
/* bufs_claim_bs_buffer()                                     */
/*                                                            */
/* Get a pointer to a bs_buffer plus extra space totalling a  */
/* requested size in bytes. The 'marker' field of the struct  */
/* is set to 1 to mark the item as in use.                    */
/*                                                            */
/* Parameters: Size of block required.                        */
/*                                                            */
/* Returns:    Pointer to the block, or NULL if the buffer is */
/*             full.                                          */
/**************************************************************/

bs_buffer * bufs_claim_bs_buffer(size_t size)
{
  int            s          = ensure_irqs_off();
  unsigned int   end_record = end;
  bool           reset      = false;
  bs_buffer    * bsb;

  #ifdef TRACE
    if (tl & Trace_Alloc) printf("bufs_claim_bs_buffer: Allocating %d, start = %d, end = %d\n",size + (((sizeof(bs_buffer *)) - 1) & (-(sizeof(bs_buffer *)))),start,end);
  #endif

  /* Round up to whole word; advance 'end' offset accordingly */

  end += size + (((sizeof(bs_buffer *)) - 1) & (-(sizeof(bs_buffer *))));

  if (end > bs_bufsize)
  {
    /* Setting end_record to zero means that the space at the top of */
    /* the buffer that this alloc was too large for will never be    */
    /* used. Chances are that the packets being received are all the */
    /* same size though, so there's no point allowing the code to    */
    /* just keep retrying and failing to fit data into that gap.     */
    /* This allows us to not worry about setting start=end=0 in the  */
    /* free code when the buffer is emptied, so we save a small      */
    /* amount of processor time.                                     */

    end_record = 0, end = size, reset = true;
  }

  /* If the end offset is above the start offset but we wrapped */
  /* around (i.e. filling the buffer from the buttom), it must  */
  /* be full.                                                   */

  if (reset && end > start)
  {
    #ifdef TRACE
      if (tl & Trace_Alloc_Fail) printf("bufs_claim_bs_buffer: Buffer full\n");
      allofail1++;
    #endif

    end_record = end;
    overruns++;
    restore_irqs(s);
    return NULL;
  }

  /* Done. */

  #ifdef TRACE
    if (tl & Trace_Alloc) printf("bufs_claim_bs_buffer: End moved from %d to %d, returning %p\n",end_record,end,buffer + end_record);
  #endif

  bsb            = (bs_buffer *) (buffer + end_record);
  bsb->bs_marker = 1;

  restore_irqs(s);
  return bsb;
}

/**************************************************************/
/* bufs_release_bs_buffer()                                   */
/*                                                            */
/* Free a pointer given from bufs_claim_bs_buffer().          */
/*                                                            */
/* Parameters: Pointer to the block to free.                  */
/*                                                            */
/* Returns:    1 for success, 0 for failure (e.g. invalid     */
/*             pointer).                                      */
/**************************************************************/

int bufs_release_bs_buffer(bs_buffer * ptr)
{
  int s = ensure_irqs_off();
  int offset = ((char *) ptr) - buffer;

  /* TRACE builds perform extra checking on the supplied pointer */

  #ifdef TRACE

    if (tl & Trace_Free) printf("bufs_release_bs_buffer: free %p\n", ptr);

    /* Is the item in the buffer? */

    if (offset < 0 || offset > bs_bufsize)
    {
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is illegal (out of range)\n", offset);
      freefail1++;

      restore_irqs(s);
      return 0;
    }

    /* Is the item in a totally free area? */

    else if (
              start < end &&
              (
                offset < start ||
                offset >= end
              )
            )
    {
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is illegal (in the split free chunk)\n", offset);
      freefail2++;

      restore_irqs(s);
      return 0;
    }

    else if (
              start > end    &&
              offset < start &&
              offset >= end
            )
    {
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is illegal (in the continguous free chunk)\n", offset);
      freefail3++;

      restore_irqs(s);
      return 0;
    }

    if (tl & Trace_Free) printf("bufs_release_bs_buffer: %d is a legal block; start = %d, end = %d\n",offset,start,end);

  #endif

  /* Pointer is (assumed or checked as) legal, but is the area valid/used? */

  if (ptr->bs_marker != 1)
  {
    #ifdef TRACE
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is already free or not the base of a claimed region\n", offset);
      freefail4++;
    #endif

    restore_irqs(s);
    return 1;
  }

  /* OK, this is a good area */

  ptr->bs_marker = 2;

  if (offset == start)
  {
    bool         reset;
    unsigned int inc;
    unsigned int bufsize = bs_bufsize; /* Accessing a global in a module is slow */

    /* We freed an item at the bottom of the claimed region; need to move */
    /* that low water mark up to the next used item, then.                */

    reset = start < end ? true : false;

    while (ptr->bs_marker == 2)
    {
      inc = sizeof(bs_buffer) + ptr->bs_len;
      start += inc;
      ptr = (bs_buffer *) (((char *) ptr) + inc);

      if (start >= bufsize) start = 0, reset = true;
      if (start >= end && reset)
      {
        #ifdef TRACE
          if (tl & Trace_Free) printf("bufs_release_bs_buffer: Buffer emptied\n");
        #endif

        break;
      }
    }
  }

  #ifdef TRACE
    if (tl & Trace_Free) printf("bufs_release_bs_buffer: start now %d, end = %d\n",start,end);
  #endif

  restore_irqs(s);
  return 1;
}

#ifdef TRACE

  /**************************************************************/
  /* bufs_show_stats()                                          */
  /*                                                            */
  /* Show statistics for buffer usage. Typically called for     */
  /* *StrmInfo output. TRACE builds only.                       */
  /**************************************************************/

  void bufs_show_stats(void)
  {
    int differential;

    printf("Start: %d, end: %d\n", start, end);

    if (end >= start) differential = end - start;
    else              differential = end + (bs_bufsize - start);

    if (end >= start) printf("Differential: %d\n",           differential);
    else              printf("Differential: %d (split)\n\n", differential);

    printf("Alloc failures: %d; free failures: %d, %d, %d, %d\n",

           allofail1,

           freefail1,
           freefail2,
           freefail3,
           freefail4);
  }

#endif
