/**************************************************************/
/* File:    bufs.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: UDPV buffer management.                           */
/*                                                            */
/* Author:  Andrew Hodgkinson.                                */
/*                                                            */
/* History: 27-Mar-2000 (ADH): Created; contents almost       */
/*                             completely replace the old     */
/*                             buffer code.                   */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include <swis.h>

#include <sys/types.h>

#include "global.h"
#include "module.h"

#include "bufs.h"

#ifdef TRACE
  #include <string.h>
#endif

/* Buffer related locals */

static unsigned int   start      = 0;
static unsigned int   end        = 0;
static unsigned int   high_water = 0;
static bool           empty      = true;
static char         * buffer     = NULL;

static unsigned int   bs_oldsize = 0;

/**************************************************************/
/* bufs_allocate_main_buffer()                                */
/*                                                            */
/* Allocate and initialise the buffer system. Whenever it is  */
/* called, checks to see if there's an allocated buffer and   */
/* if the current buffer size is different from the would-be  */
/* new buffer size. If it is, the buffers are reallocated,    */
/* else they're left alone (though buffer-related stats are   */
/* reset always).                                             */
/*                                                            */
/* Returns:    1 for success, 0 for failure.                  */
/**************************************************************/

int bufs_allocate_main_buffer(void)
{
  #ifdef TRACE
    if (tl & Trace_Init) printf("bufs_allocate_main_buffer: Called\n");
  #endif

  /* bs_bufsize is set in udpv_init, in module.c */

  if (bs_oldsize != bs_bufsize)
  {
    free(buffer); /* Checks that buffer != NULL internally */
    bs_oldsize = bs_bufsize;

    buffer = calloc(bs_bufsize, 1);
  }

  if (buffer == NULL) return 0;

  overruns   = 0;
  start      = 0;
  end        = 0;
  high_water = bs_bufsize;
  empty      = true;

  #ifdef TRACE
    claimcount   = releasecount  = 0, runcount = 0;
    is_my_socket = not_my_socket = 0;

    allofail1 = 0;
    freefail1 = freefail2 = freefail3 = freefail4 = 0;

    if (tl & Trace_Init) printf("bufs_allocate_main_buffer: Initialised at %p\n", buffer);
  #endif

  return 1;
}

/**************************************************************/
/* bufs_free_main_buffer()                                    */
/*                                                            */
/* Release memory claimed for the buffer system.              */
/**************************************************************/

void bufs_free_main_buffer(void)
{
  #ifdef TRACE
    if (tl & Trace_Init) printf("bufs_free_main_buffer: Called\n");
  #endif

  free(buffer), buffer = NULL;
}

/**************************************************************/
/* bufs_claim_bs_buffer()                                     */
/*                                                            */
/* Get a pointer to a bs_buffer plus extra space totalling a  */
/* requested size in bytes. The 'marker' field of the struct  */
/* is set to 1 to mark the item as in use. The amount you     */
/* ask for should include the bs_buffer structure size.       */
/*                                                            */
/* Parameters: Size of block required (must be > zero).       */
/*                                                            */
/* Returns:    Pointer to the block, or NULL if the buffer is */
/*             full.                                          */
/**************************************************************/

bs_buffer * bufs_claim_bs_buffer(size_t size)
{
  int            s          = ensure_irqs_off();
  unsigned int   end_record = end;
  bool           wrapped    = end <= start ? !empty : false;
  bs_buffer    * bsb;

  #ifdef TRACE
    if (tl & Trace_Alloc) printf("bufs_claim_bs_buffer: Allocating %d, start = %d, end = %d\n",size + (((sizeof(bs_buffer *)) - 1) & (-(sizeof(bs_buffer *)))),start,end);
  #endif

  /* One easy to spot overrun condition */

  if (wrapped && end == start) goto bufs_claim_bs_buffer_fail;

  /* Round up to whole word; advance 'end' offset accordingly */

  size = WordAlign(size);
  end += size;

  /* Would this packet drop off the end of the buffer? If so wrap */
  /* back to the start                                            */

  if (end > bs_bufsize)
  {
    high_water = end_record, end_record = 0, end = size, wrapped = true;
  }

  /* If the end offset is above the start offset but we wrapped */
  /* around (i.e. filling the buffer from the buttom), it must  */
  /* be full.                                                   */

  if (wrapped && end > start) goto bufs_claim_bs_buffer_fail;

  /* Success */

  #ifdef TRACE
    if (tl & Trace_Alloc) printf("bufs_claim_bs_buffer: End moved from %d to %d, returning %p\n",end_record,end,buffer + end_record);
  #endif

  bsb            = (bs_buffer *) (buffer + end_record);
  bsb->bs_marker = 1;

  if (end > high_water) high_water = end;
  if (empty)            empty      = false;

  #ifdef TRACE
    claimcount++;
  #endif

  restore_irqs(s);
  return bsb;

bufs_claim_bs_buffer_fail:

  #ifdef TRACE
    if (tl & Trace_Alloc_Fail) printf("bufs_claim_bs_buffer: Buffer full\n");
    allofail1++;
  #endif

  end = end_record;
  overruns++;

  restore_irqs(s);

  return NULL;
}

/**************************************************************/
/* bufs_release_bs_buffer()                                   */
/*                                                            */
/* Free a pointer given from bufs_claim_bs_buffer().          */
/*                                                            */
/* Parameters: Pointer to the block to free.                  */
/*                                                            */
/* Returns:    1 for success, 0 for failure (e.g. invalid     */
/*             pointer).                                      */
/**************************************************************/

int bufs_release_bs_buffer(bs_buffer * ptr)
{
  int s      = ensure_irqs_off();
  int offset = ((unsigned int) ptr) - ((unsigned int) buffer);

  /* TRACE builds perform extra checking on the supplied pointer */

  #ifdef TRACE

    if (tl & Trace_Free) printf("bufs_release_bs_buffer: free %p\n", ptr);

    /* Is the item in the buffer? */

    if (offset < 0 || offset >= bs_bufsize)
    {
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is illegal (out of range)\n", offset);
      freefail1++;

      restore_irqs(s);
      return 0;
    }

    /* Is the item in a totally free area? */

    else if (
              start < end &&
              (
                offset < start ||
                offset >= end
              )
            )
    {
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is illegal (in the split free chunk)\n", offset);
      freefail2++;

      restore_irqs(s);
      return 0;
    }

    else if (
              start > end    &&
              offset < start &&
              offset >= end
            )
    {
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is illegal (in the continguous free chunk)\n", offset);
      freefail3++;

      restore_irqs(s);
      return 0;
    }

    if (tl & Trace_Free) printf("bufs_release_bs_buffer: %d is a legal block; start = %d, end = %d\n",offset,start,end);

  #endif

  /* Pointer is (assumed or checked as) legal, but is the area valid/used? */

  if (ptr->bs_marker != 1)
  {
    #ifdef TRACE
      if (tl & Trace_Free_Fail) printf("bufs_release_bs_buffer: %d is already free or not the base of a claimed region\n", offset);
      freefail4++;
    #endif

    restore_irqs(s);
    return 1;
  }

  /* OK, this is a good area */

  ptr->bs_marker = 2; /* Mark it as freed */

  #ifdef TRACE
    releasecount++;
  #endif

  /* If we've freed at the bottom of the claimed region, scan up to */
  /* the next used part.                                            */

  if (offset == start)
  {
    unsigned int inc;

    while (ptr->bs_marker == 2)
    {
      inc    = sizeof(bs_buffer) + ptr->bs_len;
      inc    = WordAlign(inc);
      start += inc;
      ptr    = (bs_buffer *) (((unsigned int) ptr) + inc);

      /* The difference between runcount and releasecount tells you the */
      /* number of times offset != start above.                         */

      #ifdef TRACE
        runcount++;
      #endif

      if (start == end)
      {
        #ifdef TRACE
          if (tl & Trace_Free) printf("bufs_release_bs_buffer: Buffer emptied (1)\n");
        #endif

        if (start != 0) start = end = 0;
        empty = true;
        break;
      }

      if (start >= high_water)
      {
        start = 0;
        ptr   = (bs_buffer *) buffer;

        if (start == end)
        {
          empty = true;
          break;
        }
      }
    }
  }

  #ifdef TRACE
    if (tl & Trace_Free) printf("bufs_release_bs_buffer: start now %d, end = %d\n",start,end);
  #endif

  restore_irqs(s);
  return 1;
}

#ifdef TRACE

  /**************************************************************/
  /* bufs_show_stats()                                          */
  /*                                                            */
  /* Show statistics for buffer usage. Typically called for     */
  /* *StrmInfo output. TRACE builds only. Note the use of the   */
  /* locally defined BUFFER_DEBUG further down the code.        */
  /**************************************************************/

  void bufs_show_stats(void)
  {
    int            differential;
    unsigned int   offset;
    unsigned int   inc;
    bs_buffer    * ptr;

    printf("\nStart: %d, end: %d, high: %d\n", start, end, high_water);

    if (end >= start) differential = end - start;
    else              differential = end + (bs_bufsize - start);

    if (end >= start) printf("Differential: %d\n",         differential);
    else              printf("Differential: %d (split)\n", differential);

    printf("\nClaims: %d, releases: %d, run: %d, empty: %s\n", claimcount, releasecount, runcount, empty ? "yes" : "no");
    printf("Alloc failures: %d, free failures: %d, %d, %d, %d\n",

           allofail1,

           freefail1,
           freefail2,
           freefail3,
           freefail4);

    /* Define BUFFER_DEBUG 1 for an on-one-line output, or BUFFER_DEBUG 2 */
    /* for a two-line output. The latter is only useful if the entire     */
    /* buffer debug output fits on a single text line because the average */
    /* stored chunk size is large enough.                                 */

    #define BUFFER_DEBUG 0

    /* Note that these routines are not accurate; ideally they'd work from */
    /* the 'start' and 'end' variables. Since however those variables may  */
    /* be invalid (that's possibly what we're trying to debug!) the        */
    /* routine always starts at 0 and uses some rather weak end conditions */
    /* for exit. Sometimes, then, you may see some garbage output tacked   */
    /* onto the end of the actual buffer debug output and if packet sizes  */
    /* vary much it may be completely wrong.                               */

    #if BUFFER_DEBUG == 1

      offset = 0;
      printf("\n");

      do
      {
        ptr = (bs_buffer *) (buffer + offset);
        if (ptr->bs_len == 0) break;

        if (offset == start)
        {
          if (ptr->bs_marker == 1)      _swix(OS_WriteC, _IN(0), 'S');
          else if (ptr->bs_marker == 2) _swix(OS_WriteC, _IN(0), 's');
          else                          _swix(OS_WriteC, _IN(0), '<');
        }
        else if (offset == end)
        {
          if (ptr->bs_marker == 1)      _swix(OS_WriteC, _IN(0), 'E');
          else if (ptr->bs_marker == 2) _swix(OS_WriteC, _IN(0), 'e');
          else                          _swix(OS_WriteC, _IN(0), '>');
        }
        else
        {
          if (ptr->bs_marker == 1)      _swix(OS_WriteC, _IN(0), '+');
          else if (ptr->bs_marker == 2) _swix(OS_WriteC, _IN(0), '-');
          else                          _swix(OS_WriteC, _IN(0), '.');
        }

        inc = sizeof(bs_buffer) + ptr->bs_len;
        inc = WordAlign(inc);

        offset += inc;
      }
      while (offset < bs_bufsize);

      printf("\n");

    #elif BUFFER_DEBUG == 2

      offset = 0;
      printf("\n");

      do
      {
        ptr = (bs_buffer *) (buffer + offset);
        if (ptr->bs_len == 0) break;

        if (offset == start)
        {
          if (ptr->bs_marker == 1)      _swix(OS_WriteC, _IN(0), 'S');
          else if (ptr->bs_marker == 2) _swix(OS_WriteC, _IN(0), 's');
          else                          _swix(OS_WriteC, _IN(0), '<');
        }
        else
        {
          if (ptr->bs_marker == 1)      _swix(OS_WriteC, _IN(0), '+');
          else if (ptr->bs_marker == 2) _swix(OS_WriteC, _IN(0), '-');
          else                          _swix(OS_WriteC, _IN(0), '.');
        }

        inc = sizeof(bs_buffer) + ptr->bs_len;
        inc = WordAlign(inc);

        offset += inc;
      }
      while (offset < bs_bufsize);

      offset = 0;
      printf("\n");

      do
      {
        ptr = (bs_buffer *) (buffer + offset);
        if (ptr->bs_len == 0) break;

        if (offset == end)
        {
          if (ptr->bs_marker == 1)      _swix(OS_WriteC, _IN(0), 'E');
          else if (ptr->bs_marker == 2) _swix(OS_WriteC, _IN(0), 'e');
          else                          _swix(OS_WriteC, _IN(0), '>');
        }
        else
        {
          _swix(OS_WriteC, _IN(0), ' ');
        }

        inc = sizeof(bs_buffer) + ptr->bs_len;
        inc = WordAlign(inc);

        offset += inc;
      }
      while (offset < bs_bufsize);

      printf("\n");

    #else

      (void) inc;
      (void) ptr;
      (void) offset;

    #endif
  }

#endif

