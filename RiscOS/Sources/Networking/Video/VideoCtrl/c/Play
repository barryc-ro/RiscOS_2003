/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 1999 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement VideoControl_Play.                      */
/*                                                            */
/* Author : A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 04-Nov-1999: Created.                             */
/**************************************************************/

#include <stdio.h>
#include <string.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Module.h"
#include "MPEGCtrl.h"
#include "Utils.h"

#include "Play.h"

/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement VideoControl_Play. See the Video Control         */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  _kernel_oserror * e    = NULL;
  client          * list = find_client(r->r[1]);
  char            * rate;
  int               or1;

  dprintf(("", "play_play: Called for %08X\n", r->r[1]));

  /* Return an error if not registered */

  if (list == NULL)
  {
    return make_error(vc_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (list->ctrl.protocol == 0)
  {
    _kernel_oserror * e = make_error(vc_ERROR_NOT_SETUP_YET, 0);
    sprintf(strchr(e->errmess, '\0'), " (%08x)", r->r[1]);

    return e;
  }

  /* If we aren't pausing and playback is in progress, do a */
  /* deferred reset                                         */

  rate = (char *) r->r[3];
  if (rate == NULL) rate = "1";

  if (list->havectrl != 0 && strcmp(rate, "0") != 0)
  {
    _kernel_oserror * e;
    int               type;
    unsigned int      mpf;

    dprintf(("", "play_play: deferred reset for trick play '%s'\n", rate));

    if      (!strcmp(rate, "1")) type = MPEGCtrl_MCRS_Trick_Play;
    else if (!strcmp(rate, "0")) type = MPEGCtrl_MCRS_Trick_Freeze; /* Should never happen, but just in case. */

    else if (strchr(rate,'.') != NULL)
    {
      if (*rate == '-')          type = MPEGCtrl_MCRS_Trick_SRWD;
      else                       type = MPEGCtrl_MCRS_Trick_SFWD;
    }
    else if (*rate == '-')       type = MPEGCtrl_MCRS_Trick_FRWD;
    else                         type = MPEGCtrl_MCRS_Trick_FFWD;

    mpf = MPEGCtrl_MCRS_VideoPresent |
          MPEGCtrl_MCRS_DeferReset;

    /* If we're doing trick play, flag that that the new stream should */
    /* be marked as such. Otherwise, flag that we expect audio data.   */

    if (type != MPEGCtrl_MCRS_Trick_Play)
    {
      mpf |= MPEGCtrl_MCRS_NewIsTrickPlay;
    }
    else
    {
      mpf |= MPEGCtrl_MCRS_AudioPresent;
    }

    e = _swix(MPEGControl_ResetStream,
              _INR(0,2),

              mpf,
              list->ctrlhand,
              type);

    if (e != NULL) return e;
  }

  /* Call the protocol module SWI */

  or1     = r->r[1];
  r->r[1] = list->ctrl.id;
  e       = _kernel_swi(list->ctrl.protocol + VC_Protocol_Play, r, r);
  r->r[1] = or1;

  return e;
}
