/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 1999 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement VideoControl_Play.                      */
/*                                                            */
/* Author : A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 04-Nov-1999: Created.                             */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

#include <swis.h>
#include <AsmUtils/modulefp.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Module.h"
#include "MPEGCtrl.h"
#include "Protocol.h"
#include "Utils.h"
#include "VideoCtrl.h"

#include "Play.h"

/* Local functions */

static int play_find_speed (const char * rate);

/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement VideoControl_Play. See the Video Control         */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  _kernel_oserror * e    = NULL;
  client          * list = find_client(r->r[1]);
  char            * rate;
  int               or1;
  bool              mpd_present, mpd_matters;

  dprintf(("", "play_play: Called for %08X\n", r->r[1]));

  /* Return an error if not registered */

  if (list == NULL)
  {
    return make_error(vc_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (list->ctrl.protocol == 0)
  {
    _kernel_oserror * e = make_error(vc_ERROR_NOT_SETUP_YET, 0);
    sprintf(strchr(e->errmess, '\0'), " (%08x)", r->r[1]);

    return e;
  }

  /* Are we doing MPEG stuff at all? */

  if ((list->ctrl.flags & VC_ProtocolRegister_IHandleMPEG) == 0)
  {
    /* Does the protocol module support reduced data rate slowmo */
    /* forward play?                                             */

    if ((list->ctrl.flags & VC_ProtocolRegister_IDoReducedRateSlowmoForward) != 0)
    {
      mpd_matters = true;

  printf("I'm allowed reduced data rate slowmo forwards play\n");

      /* Our reset behaviour depends on MPEGDriver being here */

      if (
           _swix(OS_Module,
                 _INR(0,1),

                 18,
                 ReducedRateSlowmoSupportModule) /* Play.h */

           != NULL
         )
         mpd_present = false;

      else mpd_present = true;

  printf("My MPD flag is %d\n",mpd_present == true ? 1 : 0);
    }
    else
    {
      /* Always do simple resetting */

      mpd_present = mpd_matters = false;
    }

    /* If we aren't pausing and playback is in progress, do a */
    /* deferred reset                                         */

    rate = (char *) r->r[3];
    if (rate == NULL) rate = "1";

    if (list->havectrl != 0)
    {
      /* Going into a paused state - tell the MPEG system */

      if (strcmp(rate, "0") == 0)
      {
        if (mpd_present == true && mpd_matters == true)
        {
          _kernel_oserror * e = _swix(MPEGControl_SetSpeed,
                                      _INR(0,2),

                                      0,
                                      list->ctrlhand,
                                      0);


          if (e != NULL ) return e;
        }
      }

      /* Going into a non-pause state - need a (deferred) reset */

      else
      {
        _kernel_oserror * e;
        int               type;
        unsigned int      mpf;

        dprintf(("", "play_play: deferred reset for trick play '%s'\n", rate));

        if      (!strcmp(rate, "1")) type = MPEGCtrl_MCRS_Trick_Play;
        else if (!strcmp(rate, "0")) type = MPEGCtrl_MCRS_Trick_Freeze; /* Should never happen, but just in case. */

        else if (strchr(rate,'.') != NULL)
        {
          if (*rate == '-')          type = MPEGCtrl_MCRS_Trick_SRWD;
          else                       type = MPEGCtrl_MCRS_Trick_SFWD;
        }
        else if (*rate == '-')       type = MPEGCtrl_MCRS_Trick_FRWD;
        else                         type = MPEGCtrl_MCRS_Trick_FFWD;

        /* We're going into slow motion forward play; try to map the speed */
        /* exactly and tell MPEGControl about it                           */

        if (type == MPEGCtrl_MCRS_Trick_SFWD && mpd_present == true && mpd_matters == true)
        {
          modulefp_buf buf;
          int          speed;

          modulefp_enable(&buf);
          speed = play_find_speed(rate);
          modulefp_disable(&buf);

  printf("Magic says speed to be %d\n",speed);

          e = _swix(MPEGControl_SetSpeed,
                    _INR(0,2),

                    MPEGCtrl_MCSS_DeferIfSlower,
                    list->ctrlhand,
                    speed);
        }

        /* We're going into some other play mode, so do a deferred reset */

        else
        {
          mpf = MPEGCtrl_MCRS_VideoPresent |
                MPEGCtrl_MCRS_DeferReset;

          /* If we're doing trick play, flag that that the new stream should */
          /* be marked as such. Otherwise, flag that we expect audio data.   */

          if (type != MPEGCtrl_MCRS_Trick_Play)
          {
            mpf |= MPEGCtrl_MCRS_NewIsTrickPlay;
          }
          else
          {
            mpf |= MPEGCtrl_MCRS_AudioPresent;
          }

          if (mpd_present == true && mpd_matters == true)
          {
            e = _swix(MPEGControl_SetSpeed,
                      _INR(0,2),

                      0,
                      list->ctrlhand,
                      1);

            if (e != NULL) return e;
          }

          e = _swix(MPEGControl_ResetStream,
                    _INR(0,2),

                    mpf,
                    list->ctrlhand,
                    type);

          if (e != NULL) return e;
        }
      }
    }
  }

  /* Call the protocol module SWI */

  or1     = r->r[1];
  r->r[1] = list->ctrl.id;
  e       = _kernel_swi(list->ctrl.protocol + VC_Protocol_Play, r, r);
  r->r[1] = or1;

  return e;
}

/**************************************************************/
/* play_find_speed()                                          */
/*                                                            */
/* Given a string holding a decimal fraction, find the lowest */
/* integer for 1/<that_fraction>.                             */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the NUL terminated rate string.     */
/*                                                            */
/* Returns:    Lowest int for 1/fraction.                     */
/**************************************************************/

static int play_find_speed(const char * rate)
{
  double d = atof(rate);
  int    speed;

  if (d == 0) d = 1;

  speed = (int) floor(1 / d);
  if (speed > MPEGCtrl_MCSS_SlowestRate) speed = MPEGCtrl_MCSS_SlowestRate;

  return speed;
}
