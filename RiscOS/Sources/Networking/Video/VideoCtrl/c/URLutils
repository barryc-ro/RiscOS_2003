/***************************************************/
/* File   : URLutils.c                             */
/*                                                 */
/* Purpose: URL manipulation.                      */
/*                                                 */
/* Author : A.D.Hodgkinson.                        */
/*                                                 */
/* History: 06-Feb-1997 (ADH): Created.            */
/*          11-Nov-1999 (ADH): Imported fragment   */
/*                             to VideoControl.    */
/***************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <swis.h>

#include "Generic.h"
#include "Utils.h"
#include "URLveneer.h"
#include "URLutils.h"

/* Local definitions */

#define ExtensionMatches(url, len, ext) (len) > strlen(ext) && !strncmp((url) + (len) - strlen(ext), (ext), strlen(ext))

/* Fit within VideoControl's URL_Fetcher derived namings */
/* - these are all in Generic.[c|h] rather than Utils.   */

#define utils_strdup      Strdup
#define utils_strndup     Strndup
#define utils_strcasecmp  Strcmp_ci
#define utils_strncasecmp Strncmp_ci

/*************************************************/
/* urlutils_urlsscmp()                           */
/*                                               */
/* Compares two URLs, returning 1 if they differ */
/* or 0 if they are the same. Both URLs are      */
/* converted internally to url_descriptions.     */
/*                                               */
/* Parameters: Pointer to a null terminated URL  */
/*             string;                           */
/*                                               */
/*             Pointer to a second null termina- */
/*             ted URL string.                   */
/*                                               */
/* Returns:    0 if the URLs match, else 1.      */
/*************************************************/

int urlutils_urlsscmp(const char * url_s1, const char * url_s2)
{
  url_description * url_d1;
  url_description * url_d2;
  int               result;

  /* Sanity check */

  if (!url_s1 && !url_s2) return 0;
  if (!url_s1 || !url_s2) return 1;

  // Awaiting URL module stuff

  url_d1 = urlutils_return_description(url_s1);
  url_d2 = urlutils_return_description(url_s2);

  if (url_d1 && url_d2)
  {
    result = !!strcmp(url_d1->full, url_d2->full);
  }

  /* No memory, no brain. Hey ho. */

  else result = !!strcmp(url_s1, url_s2);

  urlutils_free_description(url_d1);
  urlutils_free_description(url_d2);

  return result;
}

/*************************************************/
/* urlutils_urldscmp()                           */
/*                                               */
/* Compares two URLs, returning 1 if they differ */
/* or 0 if they are the same. The first URL is   */
/* specified as a url_description, the second    */
/* URL is converted internally.                  */
/*                                               */
/* Parameters: Pointer to a url_description      */
/*             filled in with the URL details;   */
/*                                               */
/*             Pointer to a second null termina- */
/*             ted URL string.                   */
/*                                               */
/* Returns:    0 if the URLs match, else 1.      */
/*************************************************/

int urlutils_urldscmp(const url_description * url_d, const char * url_s)
{
  url_description * url_d2;
  int               result;

  /* Sanity check */

  if (!url_d)                 return 1;
  if (!url_s && !url_d->full) return 0;
  if (!url_s || !url_d->full) return 1;

  // Awaiting URL module stuff

  url_d2 = urlutils_return_description(url_s);

  if (url_d && url_d2)
  {
    result = !!strcmp(url_d->full, url_d2->full);
  }
  else result = !!strcmp(url_d->full, url_s);

  urlutils_free_description(url_d2);

  return result;
}

/*************************************************/
/* urlutils_urldscmp()                           */
/*                                               */
/* Compares two URLs, returning 1 if they differ */
/* or 0 if they are the same. Both URLs are      */
/* specified as url_description structures.      */
/*                                               */
/* Parameters: Pointer to a url_description      */
/*             filled in with the URL details;   */
/*                                               */
/*             Another url_description pointer,  */
/*             filled in with the details of a   */
/*             second URL.                       */
/*                                               */
/* Returns:    0 if the URLs match, else 1.      */
/*************************************************/

int urlutils_urlddcmp(const url_description * url_d1, const url_description * url_d2)
{
  /* Sanity check */

  if (!url_d1 && url_d2)  return 1;
  if (!url_d2 && url_d1)  return 1;
  if (!url_d1 && !url_d2) return 0;

  if (!url_d1->full && !url_d2->full) return 0;
  if (!url_d1->full || !url_d2->full) return 1;

  // Awaiting URL module stuff

  return !!strcmp(url_d1->full, url_d2->full);
}

/*************************************************/
/* urlutils_return_description()                 */
/*                                               */
/* Given a URL string, returns a url_description */
/* structure which contains more accessible      */
/* details on the URL contents.                  */
/*                                               */
/* The block itself and all filled in fields are */
/* allocated with malloc(), and any additions to */
/* the structure should be allocated in the same */
/* way.                                          */
/*                                               */
/* Parameters: Pointer to a null terminated URL  */
/*             string.                           */
/*                                               */
/* Returns:    Pointer to a url_description      */
/*             structure filled in with details  */
/*             of the string, or NULL if         */
/*             allocation failed.                */
/*************************************************/

url_description * urlutils_return_description(const char * url_s)
{
  url_description * new;

  size_t            rlen;
  char *            tlen;
  int               plen;

  if (!url_s || !*url_s) return NULL;

  /* Allocate the structure */

  new = calloc(1, sizeof(url_description));

  if (!new) return NULL;

  /* Find the item lengths */

  if (_swix(URL_ParseURL,
            _INR(0,5),

            0,
            URL_ParseURL_Reason_FindLengths,
            url_s,
            NULL,
            new,
            sizeof(url_description) / 4)) goto urlutils_return_description_free_and_exit;

  /* Expect the canonicalised form at the very least; new->full on */
  /* return from the SWI holds the buffer length required for this */

  if (!new->full) goto urlutils_return_description_free_and_exit;

  /* Allocate a block to hold all of the fields */

  rlen = (int) new->full     +
         (int) new->protocol +
         (int) new->host     +
         (int) new->port     +
         (int) new->user     +
         (int) new->password +
         (int) new->account  +
         (int) new->path     +
         (int) new->query    +
         (int) new->fragment;

  if (!rlen) goto urlutils_return_description_free_and_exit;

  tlen      = (char *) new->full;
  new->full = malloc(rlen);
  if (!new->full) goto urlutils_return_description_free_and_exit;

  tlen     += (int) new->full;

  if (new->protocol) plen = (int) new->protocol, new->protocol = tlen, tlen += plen;
  if (new->host)     plen = (int) new->host,     new->host     = tlen, tlen += plen;
  if (new->port)     plen = (int) new->port,     new->port     = tlen, tlen += plen;

  if (new->user)     plen = (int) new->user,     new->user     = tlen, tlen += plen;
  if (new->password) plen = (int) new->password, new->password = tlen, tlen += plen;
  if (new->account)  plen = (int) new->account,  new->account  = tlen, tlen += plen;

  if (new->path)     plen = (int) new->path,     new->path     = tlen, tlen += plen;

  if (new->query)    plen = (int) new->query,    new->query    = tlen, tlen += plen;
  if (new->fragment) new->fragment = tlen;

  /* Fill in the block */

  if (_swix(URL_ParseURL,
            _INR(0,5),

            0,
            URL_ParseURL_Reason_FillBuffers,
            url_s,
            NULL,
            new,
            sizeof(url_description) / sizeof(char *))) goto urlutils_return_description_free_and_exit;

  /* Finished */

  return new;

  /* Error condition exit routine */

urlutils_return_description_free_and_exit:

  urlutils_free_description(new);

  return NULL;
}

/*************************************************/
/* urlutils_free_description()                   */
/*                                               */
/* Frees a url_description and all memory        */
/* associated with it.                           */
/*                                               */
/* The function expects all filled in fields in  */
/* the structure to point to malloced blocks, as */
/* this is the way that                          */
/* urlutils_return_description allocates it.     */
/*                                               */
/* Parameters: Pointer to a url_description      */
/*             structure.                        */
/*************************************************/

void urlutils_free_description(url_description * url_d)
{
  /* Not the most demanding code in the world, really */

  free(url_d->full);
  free(url_d);

  return;
}

/*************************************************/
/* urlutils_matches_special()                    */
/*                                               */
/* Given a URL description and a string with a   */
/* comma separated list of entries describing    */
/* match parameters, return 1 if the URL meets   */
/* any of the match criteria. The match string   */
/* should be in a writeable buffer and will be   */
/* corrupted on exit. The string consists of:    */
/*                                               */
/* 1. An optional hostname; either fully         */
/*    qualified (e.g. 'wwww.acorn.com') or       */
/*    partially if starting with a dot (e.g.     */
/*    .acorn.com' to match any host with a name  */
/*    ending in '.acorn.com').                   */
/*                                               */
/* 2. An optional port following the host name,  */
/*    separated by a colon (e.g. 'www:3172').    */
/*    Note that specifying the default port for  */
/*    whatever fetch protocol is in use will     */
/*    never match (e.g. 'www:80' would never     */
/*    match for an HTTP fetch of server 'www')   */
/*    so this is only useful for matching        */
/*    unusual port values.                       */
/*                                               */
/* 3. An optional path fragment, which is        */
/*    matched against the left hand side of the  */
/*    URL (e.g. 'www/this/that' would match any  */
/*    path 'this/that', 'this/that/more',        */
/*    'this/thatandmore.gif', etc.).             */
/*                                               */
/* Parameters: Pointer to a url_description      */
/*             filled in with details of the URL */
/*             to examine;                       */
/*                                               */
/*             Pointer to a string with the      */
/*             match parameters in it, comma     */
/*             separated if many are needed,     */
/*             which must be in a writeable      */
/*             buffer.                           */
/*                                               */
/* Returns:    1 if there's a match, else 0. The */
/*             given match string is corrupted.  */
/*************************************************/

int urlutils_matches_special(const url_description * d, char * writeable)
{
  if (d && writeable)
  {
    char * at;

    char * host = d->host ? d->host : "";
    char * path = d->path ? d->path : "";
    char * port = d->port ? d->port : "";

    do
    {
      /* Get each comma separated section individually */

      at = strtok(writeable, ","), writeable = NULL;

      if (at)
      {
        char * slash = strchr(at, '/');
        char * colon = strchr(at, ':');

        int    match = 0;

        /* Overwrite key seperator characters with terminators to make */
        /* subsequent comparisons easier                               */

        if (colon) *colon = '\0', colon++;
        if (slash) *slash = '\0', slash++;

        /* Match port and left hand side of path if required */

        if (!colon) match++;
        else if (!utils_strcasecmp(port, colon)) match++;

        if (!slash) match++;
        else if (!utils_strncasecmp(path, slash, strlen(slash))) match++;

        /* Allow no host (so just match by port or path) */

        if (!*at && (colon || slash)) match++;

        /* Otherwise, do host matching */

        else if (*at)
        {
          /* Compare only the right hand side */

          if (*at == '.')
          {
            int hlen   = strlen(host);
            int offset = hlen - strlen(at);

            if (offset >= 0 && !utils_strcasecmp(host + offset, at)) match++;
          }

          /* Compare the whole thing */

          else
          {
            if (!utils_strcasecmp(host, at)) match++;
          }
        }

        /* Did we match it? */

        if (match == 3) return 1;

        /* No, so restore the string so strtok will continue to work */

        if (slash) *(--slash) = '/';
        if (colon) *(--colon) = ':';
      }
    }
    while (at);
  }

  return 0;
}

/*************************************************/
/* urlutils_relativise_url()                     */
/*                                               */
/* HTMLLib has a call to take a base URL and a   */
/* relative URL and produce a canonical result   */
/* based on the combination of the two. This     */
/* does the same (it is based on the HTMLLib     */
/* code) but doesn't need an HTMLLib memory      */
/* context to operate in - the HTMLLib call is   */
/* useful when context based memory allocation   */
/* is handy.                                     */
/*                                               */
/* Parameters: Pointer to a base URL;            */
/*                                               */
/*             Pointer to a relative URL.        */
/*                                               */
/* Returns:    Pointer to a malloc'd URL (so it  */
/*             must be eventually free'd by the  */
/*             caller) which is the canonical    */
/*             result of combining the base and  */
/*             relative URLs.                    */
/*************************************************/

char * urlutils_relativise_url(const char * base, const char * link)
{
  _kernel_oserror * e;
  char            * ptr;
  int               blen;
  char            * ret = NULL;

  if (link == NULL) return NULL;

  if (base == NULL)
  {
    ret = utils_strdup(link);
    return ret;
  }

  /* Strip preceeding spaces */

  while (*link == ' ') link++;

  /* Cope with empty link URLs */

  if (*link == '\0') return utils_strdup(base);

  /* Otherwise, just go for it... */

  if (!base) base = "";

  blen = strlen(base) + 4 + (link ? strlen(link) : 0);
  ptr  = malloc(blen);

  if (ptr == NULL) return NULL;

  e = _swix(URL_ParseURL,
            _INR(0,5),

            0,
            URL_ParseURL_Reason_QuickResolve,
            base,
            link,
            ptr,
            blen);

  /* Did the above succeed? */

  if (e != NULL)
  {
    free(ptr);
    return NULL;
  }

  return ptr;
}
