/**************************************************************/
/* File:    Options.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement VideoControl_Options.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 18-Oct-1999 (ADH): Created.                       */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Module.h"
#include "MPEGCtrl.h"
#include "Utils.h"

#include "Options.h"

/* Prototypes for local functions */

static _kernel_oserror * options_set_volume         (client * c, const int volume    [1]); /* 0 (silent) to 256 (full), steps of about 0.5dB  */
static _kernel_oserror * options_set_audio_channel  (client * c, const int channels  [1]); /* Use an audio_channels item                      */
static _kernel_oserror * options_set_mute           (client * c, const int mute      [1]); /* Non-zero to mute audio, zero to restore         */
static _kernel_oserror * options_set_video_only     (client * c, const int boolean   [1]); /* Non-zero to disable audio utterly else allow it */
static _kernel_oserror * options_set_audio_only     (client * c, const int boolean   [1]); /* Non-zero to disable video utterly else allow it */
static _kernel_oserror * options_set_rectangle      (client * c, const int rectangle [4]); /* Bottom left x, y, width, height in pixels       */
static _kernel_oserror * options_set_offsets        (client * c, const int offsets   [2]); /* Horiz., vert. offset from bottom left in pixels */
static _kernel_oserror * options_set_ntsc           (client * c, const int boolean   [1]); /* Non-zero to use NTSC-style mode, else PAL-style */
static _kernel_oserror * options_set_macrovision    (client * c, const int boolean   [1]); /* Non-zero to enable Macrovision anti-taping      */
static _kernel_oserror * options_set_depth          (client * c, const int log2bpp   [1]); /* Log2bpp of required colour depth                */
static _kernel_oserror * options_set_no_interlace   (client * c, const int boolean   [1]); /* Non-zero to disable screen interlace            */
static _kernel_oserror * options_set_no_mode_change (client * c, const int boolean   [1]); /* Non-zero to disable mode change                 */
static _kernel_oserror * options_set_no_cls         (client * c, const int boolean   [1]); /* Non-zero to disable screen clearing             */
static _kernel_oserror * options_set_no_palette     (client * c, const int boolean   [1]); /* Non-zero to disable palette set-up              */
static _kernel_oserror * options_set_no_redraw      (client * c, const int boolean   [1]); /* Non-zero to disable redraw after playback       */
static _kernel_oserror * options_set_mp2program     (client * c, const int program   [1]); /* Program number in MPEG 2 transport stream       */
static _kernel_oserror * options_set_mp2videostream (client * c, const int stream    [1]); /* Video stream within the program                 */
static _kernel_oserror * options_set_mp2audiostream (client * c, const int stream    [1]); /* Audio stream within the program                 */
static _kernel_oserror * options_set_loop           (client * c, const int boolean   [1]); /* Non-zero to loop playback if possible           */
static _kernel_oserror * options_set_demux          (client * c, const int demux     [1]); /* 0 = auto, 1 = MPEG 1, 2 = MPEG 2                */
static _kernel_oserror * options_set_mode_width     (client * c, const int width     [1]); /* Set width of screen mode away from default      */
static _kernel_oserror * options_set_mode_height    (client * c, const int height    [1]); /* Set height of screen mode from default          */
static _kernel_oserror * options_set_demux_mask     (client * c, const int mask      [1]); /* R1 in MPEGControl_ControlOp 0 (if demux=3 only) */

static _kernel_oserror * options_get_volume         (client * c, int       volume    [1]);
static _kernel_oserror * options_get_audio_channel  (client * c, int       channels  [1]);
static _kernel_oserror * options_get_mute           (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_video_only     (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_audio_only     (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_rectangle      (client * c, int       rectangle [4]);
static _kernel_oserror * options_get_offsets        (client * c, int       offsets   [2]);
static _kernel_oserror * options_get_ntsc           (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_macrovision    (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_depth          (client * c, int       log2bpp   [1]);
static _kernel_oserror * options_get_no_interlace   (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_no_mode_change (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_no_cls         (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_no_palette     (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_no_redraw      (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_mp2program     (client * c, int       program   [1]);
static _kernel_oserror * options_get_mp2videostream (client * c, int       stream    [1]);
static _kernel_oserror * options_get_mp2audiostream (client * c, int       stream    [1]);
static _kernel_oserror * options_get_npt            (client * c, int       estimate  [1]); /* Best-guess estimate of NPT */
static _kernel_oserror * options_get_loop           (client * c, int       boolean   [1]);
static _kernel_oserror * options_get_demux          (client * c, int       demux     [1]);
static _kernel_oserror * options_get_control_handle (client * c, int       control   [1]);
static _kernel_oserror * options_get_mode_width     (client * c, int       width     [1]);
static _kernel_oserror * options_get_mode_height    (client * c, int       height    [1]);
static _kernel_oserror * options_get_play_state     (client * c, int       state     [1]);
static _kernel_oserror * options_get_demux_mask     (client * c, int       mask      [1]);

/* A tag number is used as an offset into this array. The parameters */
/* are passed straight in as an int * - the function takes as many   */
/* as it wants. The parameters column is purely for syntax checking. */

static options_description known_options[] = {
                                               { 1, options_set_volume,         options_get_volume         },
                                               { 1, options_set_audio_channel,  options_get_audio_channel  },
                                               { 1, options_set_mute,           options_get_mute           },
                                               { 1, options_set_video_only,     options_get_video_only     },
                                               { 1, options_set_audio_only,     options_get_audio_only     },
                                               { 4, options_set_rectangle,      options_get_rectangle      },
                                               { 2, options_set_offsets,        options_get_offsets        },
                                               { 1, options_set_ntsc,           options_get_ntsc           },
                                               { 1, options_set_macrovision,    options_get_macrovision    },
                                               { 1, options_set_depth,          options_get_depth          },
                                               { 1, options_set_no_interlace,   options_get_no_interlace   },
                                               { 1, options_set_no_mode_change, options_get_no_mode_change },
                                               { 1, options_set_no_cls,         options_get_no_cls         },
                                               { 1, options_set_no_palette,     options_get_no_palette     },
                                               { 1, options_set_no_redraw,      options_get_no_redraw      },
                                               { 1, options_set_mp2program,     options_get_mp2program     },
                                               { 1, options_set_mp2videostream, options_get_mp2videostream },
                                               { 1, options_set_mp2audiostream, options_get_mp2audiostream },
                                               { 1, NULL,                       options_get_npt            },
                                               { 1, options_set_loop,           options_get_loop           },
                                               { 1, options_set_demux,          options_get_demux          },
                                               { 1, NULL,                       options_get_control_handle },
                                               { 1, options_set_mode_width,     options_get_mode_width     },
                                               { 1, options_set_mode_height,    options_get_mode_height    },
                                               { 1, NULL,                       options_get_play_state     },
                                               { 1, options_set_demux_mask,     options_get_demux_mask     },
                                             };

/**************************************************************/
/* options_options()                                          */
/*                                                            */
/* Implement VideoControl_Options. See the Video Control      */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * options_options(_kernel_swi_regs * r)
{
  _kernel_oserror * e;
  client          * list = find_client(r->r[1]);
  int               or1;

  dprintf(("", "options_options: Called for %08X\n", r->r[1]));

  /* Return an error if not registered */

  if (list == NULL)
  {
    return make_error(vc_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  /* If we're reading options, must have selected a protocol module */

  if ((r->r[0] & VC_Options_ReadValues) != 0 && list->ctrl.protocol == 0)
  {
    e = make_error(vc_ERROR_NOT_SETUP_YET, 0);
    sprintf(strchr(e->errmess, '\0'), " (&%08X)", r->r[1]);

    return e;
  }

  e = options_options_backend(list,
                              (vc_options *) r->r[2],
                              (r->r[0] & VC_Options_ReadValues) == 0 ? false : true);

  if (e) return e;

  /* Pass down for the protocol module to do any extra stuff it might want */

  if (list->ctrl.protocol != 0 && list->ctrl.id != 0)
  {
    or1     = r->r[1];
    r->r[1] = list->ctrl.id;
    e       = _kernel_swi(list->ctrl.protocol + VC_Protocol_Options, r, r);
    r->r[1] = or1;
  }
  else e = NULL;

  dprintf(("", "options_options: Exitting with %p\n", e));

  return e;
}

/**************************************************************/
/* options_options_backend()                                  */
/*                                                            */
/* Back-end code for options_options, called also by          */
/* protocol_options and possibly others. Goes through a       */
/* given options block for a given client structure, getting  */
/* or setting values according to a given flag.               */
/*                                                            */
/* Parameters: Pointer to a relevant client structure;        */
/*                                                            */
/*             Pointer to the first vc_options structure to   */
/*             look at;                                       */
/*                                                            */
/*             Non-zero to get (read), else set (write).      */
/**************************************************************/

_kernel_oserror * options_options_backend(client * c, vc_options * entries, int read)
{
  _kernel_oserror * e;
  vc_options      * current;
  int               range = sizeof(known_options) / sizeof(options_description); /* Using vc_tags__highest in VideoCtrl.h doesn't capture what we actually, really understand here */

  /* Run through the entries block */

  current = entries;

  while (current->header.tag != -1)
  {
    if (current->header.tag < range)
    {
      if (current->header.parameters != known_options[current->header.tag].parameters)
      {
        e = make_error(vc_ERROR_INVALID_OPTIONS ,0);
        sprintf(strchr(e->errmess, '\0'), " (&%X)", ((int) current) - ((int) entries));
        sprintf(strchr(e->errmess, '\0'), " (&%08X)", (int) c);

        return e;
      }

      /* Read or set? */

      if (read == 0)
      {
        /* Set */

        set_option_function_ptr set = known_options[current->header.tag].set;

        /* This may be read-only. If so, skip it (raise no error) */

        if (set != NULL)
        {
          e = set(c, current->data.generic);
          if (e) return e;
        }
      }
      else
      {
        /* Read */

        get_option_function_ptr get = known_options[current->header.tag].get;

        /* This may be write-only. If so, skip it (raise no error) */

        if (get != NULL)
        {
          e = get(c, current->data.generic);
          if (e) return e;
        }
      }
    }

    /* Get to the next item */

    current = (vc_options *) (
                               ((int) current)                            +
                               sizeof(current->header)                    +
                               sizeof(int) * (current->header.parameters)
                             );
  }

  return NULL;
}

/**************************************************************/
/* options_set_defaults()                                     */
/*                                                            */
/* Given a client structure (Module.h), initialise the        */
/* options block within it to default values.                 */
/*                                                            */
/* Parameters: Pointer to the client struct holding the       */
/*             options block to be initialised.               */
/**************************************************************/

void options_set_defaults(client * c)
{
  c->opts.mute           = 0;
  c->opts.video_only     = 0;
  c->opts.audio_only     = 0;
  c->opts.macrovision    = 0;
  c->opts.no_interlace   = 0;
  c->opts.no_mode_change = 0;
  c->opts.no_cls         = 0;
  c->opts.no_palette     = 0;
  c->opts.no_redraw      = 0;
  c->opts.loop           = 0;

  c->opts.volume         = 256;
  c->opts.audio_channel  = vc_audio_stereo;
  c->opts.log2bpp        = 4;
  c->opts.program        = 1;
  c->opts.video_stream   = 1;
  c->opts.audio_stream   = 1;
  c->opts.npt            = 0;
  c->opts.demux          = vc_demux_auto;
  c->opts.demux_mask     = -1;
  c->opts.play_state     = vc_play_state_unknown;
  c->opts.mode_width     = MPEGCtrl_DefaultModeWidth;
  c->opts.mode_height    = 0; /* Signals "Use TV$Type" to mpegctrl_setup_mode and options_get_mode_height */

  c->opts.rectangle.x    = 0;
  c->opts.rectangle.y    = 0;
  c->opts.rectangle.w    = 0;
  c->opts.rectangle.h    = 0;

  return;
}

/**************************************************************/
/* options_set_volume()                                       */
/*                                                            */
/* Set the volume.                                            */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding volume, 0 (off) to   */
/*             256 (full) (steps of roughly 0.5 dB).          */
/**************************************************************/

static _kernel_oserror * options_set_volume(client * c, const int volume[1])
{
  int v = volume[0];

  dprintf(("", "options_set_volume %d (%p)\n", volume[0], c));

  if (v < 0)   v = 0;
  if (v > 256) v = 256;

  c->opts.volume = v;

  if (c->havectrl != 0 && (c->ctrl.flags & VC_ProtocolRegister_IHandleMPEG) == 0)
  {
    #ifdef EXTRA_DEBUG
      printf("SoundVolume in Options.c to %d\n",v);
    #endif

    _swix(MPEGControl_SoundVolume,
          _INR(0,2),

          0,
          c->ctrlhand,
          v);
  }

  return NULL;
}

/**************************************************************/
/* options_set_audio_channel()                                */
/*                                                            */
/* Set dual mono / stereo state.                              */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding audio channel        */
/*             specifier - 0 = stereo, 1 = dual left, 2 =     */
/*             dual right.                                    */
/**************************************************************/

static _kernel_oserror * options_set_audio_channel(client * c, const int channels[1])
{
  int ch = channels[0];

  dprintf(("", "options_set_audio_channel %d (%p)\n", channels[0], c));

  switch (ch)
  {
    default:
    case 0: c->opts.audio_channel = vc_audio_stereo;     break;
    case 1: c->opts.audio_channel = vc_audio_dual_left;  break;
    case 2: c->opts.audio_channel = vc_audio_dual_right; break;
  }

  return mpegctrl_change_audio_parameters(c);
}

/**************************************************************/
/* options_set_mute()                                         */
/*                                                            */
/* Set audio mute state.                                      */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero for no muting,  */
/*             else muted.                                    */
/**************************************************************/

static _kernel_oserror * options_set_mute(client * c, const int mute[1])
{
  bool b = mute[0] == 0 ? false : true;

  dprintf(("", "options_set_mute %d (%p)\n", mute[0], c));

  c->opts.mute = b ? 1 : 0;

  if (c->havectrl != 0 && (c->ctrl.flags & VC_ProtocolRegister_IHandleMPEG) == 0)
  {
    #ifdef EXTRA_DEBUG
      printf("MuteSound in Options.c to %d\n",c->opts.mute);
    #endif

    _swix(MPEGControl_MuteSound,
          _INR(0,1),

          c->opts.mute,
          c->ctrlhand);
  }

  return NULL;
}

/**************************************************************/
/* options_set_video_only()                                   */
/*                                                            */
/* Set video only (disable audio).                            */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to play audio   */
/*             and video, else video only.                    */
/**************************************************************/

static _kernel_oserror * options_set_video_only(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_video_only %d (%p)\n", boolean[0], c));

  c->opts.video_only = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_audio_only()                                   */
/*                                                            */
/* Set audio only (enable audio).                             */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to play audio   */
/*             and video, else audio only.                    */
/**************************************************************/

static _kernel_oserror * options_set_audio_only(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_audio_only %d (%p)\n", boolean[0], c));

  c->opts.audio_only = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_rectangle()                                    */
/*                                                            */
/* Set video playback rectangle.                              */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to four consecutive ints holding the   */
/*             bottom left x and y coordinate and width and   */
/*             height of the play rectangle, in pixels.       */
/**************************************************************/

static _kernel_oserror * options_set_rectangle(client * c, const int rectangle[4])
{
  dprintf(("", "options_set_rectangle (%d, %d) %d x %d (%p)\n", rectangle[0], rectangle[1], rectangle[2], rectangle[3], c));

  c->opts.rectangle.x = rectangle[0];
  c->opts.rectangle.y = rectangle[1];
  c->opts.rectangle.w = rectangle[2];
  c->opts.rectangle.h = rectangle[3];

  return mpegctrl_change_video_parameters(c);
}

/**************************************************************/
/* options_set_offsets()                                      */
/*                                                            */
/* Since issue 3 of the Video Control specification, tag 6 is */
/* reserved.                                                  */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to two consecutive ints.               */
/**************************************************************/

static _kernel_oserror * options_set_offsets(client * c, const int offsets[2])
{
  (void) c;
  (void) offsets;

  dprintf(("", "options_set_offsets %d, %d (%p)\n", offsets[0], offsets[1], c));

  return NULL;
}

/**************************************************************/
/* options_set_ntsc()                                         */
/*                                                            */
/* Set NTSC or PAL style mode state.                          */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to use a PAL    */
/* style mode, else NTSC.                                     */
/**************************************************************/

static _kernel_oserror * options_set_ntsc(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_ntsc %d (%p)\n", boolean[0], c));

  c->opts.ntsc = b ? 1 : 0;

  /* If we ask specifically for PAL or NTSC style modes, according to */
  /* the specification we should alter the height too. If the height  */
  /* is zero we take it as having not been set to some specific value */
  /* yet and can thus force it here.                                  */

  if (c->opts.mode_height == 0)
  {
    c->opts.mode_height = (c->opts.ntsc == 1 ? MPEGCtrl_DefaultModeHeightNTSC : MPEGCtrl_DefaultModeHeightPAL);
  }

  return NULL;
}

/**************************************************************/
/* options_set_macrovision()                                  */
/*                                                            */
/* Set Macrovision anti-taping state.                         */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to bypass the   */
/*             Macrovision circuitry else, enable             */
/*             anti-taping.                                   */
/**************************************************************/

static _kernel_oserror * options_set_macrovision(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_macrovision %d (%p)\n", boolean[0], c));

  c->opts.macrovision = b ? 1 : 0;

  if (c->started)
  {
    _swix(Macrovision_SetState,
          _INR(0,2),

          1, /* 1 = do it now (0 = wait until next mode change) */
          c->opts.macrovision ? 2 : 0,
          c->opts.ntsc ? MPEGCtrl_MacrovisionTVFormat_NTSC : MPEGCtrl_MacrovisionTVFormat_PAL);
  }

  return NULL;
}

/**************************************************************/
/* options_set_depth()                                        */
/*                                                            */
/* Set intended playback mode's colour depth.                 */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding the intended         */
/*             playback mode colour depth, as log(2) BPP -    */
/*             i.e. 0 = 1 bpp, 1 = 2 bpp, 2 = 4 bpp etc.      */
/**************************************************************/

static _kernel_oserror * options_set_depth(client * c, const int log2bpp[1])
{
  int l = log2bpp[0];

  dprintf(("", "options_set_depth %d (%p)\n", log2bpp[0], c));

  if (l < 0) l = 0;
  if (l > 5) l = 5;

  c->opts.log2bpp = l;

  return NULL;
}

/**************************************************************/
/* options_set_no_interlace()                                 */
/*                                                            */
/* Set display interlace state.                               */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to allow screen */
/*             interlace, else disable it.                    */
/**************************************************************/

static _kernel_oserror * options_set_no_interlace(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_no_interlace %d (%p)\n", boolean[0], c));

  c->opts.no_interlace = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_no_mode_change()                               */
/*                                                            */
/* Set whether or not the display mode is                     */
/* changed prior to playback.                                 */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to change mode, */
/*             else don't.                                    */
/**************************************************************/

static _kernel_oserror * options_set_no_mode_change(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_no_mode_change %d (%p)\n", boolean[0], c));

  c->opts.no_mode_change = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_no_cls()                                       */
/*                                                            */
/* Set whether or not the screen is cleared                   */
/* prior to playback.                                         */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to clear the    */
/*             screen, else don't.                            */
/**************************************************************/

static _kernel_oserror * options_set_no_cls(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_no_cls %d (%p)\n", boolean[0], c));

  c->opts.no_cls = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_no_palette()                                   */
/*                                                            */
/* Set whether or not the palette is changed                  */
/* prior to playback.                                         */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to set the      */
/*             palette, else don't.                           */
/**************************************************************/

static _kernel_oserror * options_set_no_palette(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_no_palette %d (%p)\n", boolean[0], c));

  c->opts.no_palette = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_no_redraw()                                    */
/*                                                            */
/* Set whether or not the screen is redrawn                   */
/* after playback.                                            */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to redraw       */
/*             afterwards, else don't.                        */
/**************************************************************/

static _kernel_oserror * options_set_no_redraw(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_no_redraw %d (%p)\n", boolean[0], c));

  c->opts.no_redraw = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_mp2program()                                   */
/*                                                            */
/* Set program number (MPEG 2 transport stream).              */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding the program number.  */
/**************************************************************/

static _kernel_oserror * options_set_mp2program(client * c, const int program[1])
{
  int p = program[0];

  dprintf(("", "options_set_mp2program %d (%p)\n", program[0], c));

  c->opts.program = p;

  if (c->havectrl != 0 && (c->ctrl.flags & VC_ProtocolRegister_IHandleMPEG) == 0)
  {
    #ifdef EXTRA_DEBUG
      printf("SelectProgram in Options.c to %d / %d / %d (for program)\n",
             -c->opts.program,
             c->opts.video_stream,
             c->opts.audio_stream);
    #endif

    _swix(MPEGControl_SelectProgram,
          _INR(0,4),

          3,
          c->ctrlhand,
          -c->opts.program,
          c->opts.video_stream,
          c->opts.audio_stream);
  }

  return NULL;
}

/**************************************************************/
/* options_set_mp2videostream()                               */
/*                                                            */
/* Set video stream within an MPEG 2 program.                 */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding the video stream     */
/*             number.                                        */
/**************************************************************/

static _kernel_oserror * options_set_mp2videostream(client * c, const int stream[1])
{
  int vs = stream[0];

  dprintf(("", "options_set_mp2videostream %d (%p)\n", stream[0], c));

  c->opts.video_stream = vs;

  if (c->havectrl != 0 && (c->ctrl.flags & VC_ProtocolRegister_IHandleMPEG) == 0)
  {
    #ifdef EXTRA_DEBUG
      printf("SelectProgram in Options.c to %d / %d / %d (for video stream)\n",
             -c->opts.program,
             c->opts.video_stream,
             c->opts.audio_stream);
    #endif

    _swix(MPEGControl_SelectProgram,
          _INR(0,4),

          3,
          c->ctrlhand,
          -c->opts.program,
          c->opts.video_stream,
          c->opts.audio_stream);
  }

  return NULL;
}

/**************************************************************/
/* options_set_mp2audiostream()                               */
/*                                                            */
/* Set audio stream within an MPEG 2 program.                 */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding the audio stream     */
/*             number.                                        */
/**************************************************************/

static _kernel_oserror * options_set_mp2audiostream(client * c, const int stream[1])
{
  int as = stream[0];

  dprintf(("", "options_set_mp2audiostream %d (%p)\n", stream[0], c));

  c->opts.audio_stream = as;

  if (c->havectrl != 0 && (c->ctrl.flags & VC_ProtocolRegister_IHandleMPEG) == 0)
  {
    #ifdef EXTRA_DEBUG
      printf("SelectProgram in Options.c to %d / %d / %d (for audio stream)\n",
             -c->opts.program,
             c->opts.video_stream,
             c->opts.audio_stream);
    #endif

    _swix(MPEGControl_SelectProgram,
          _INR(0,4),

          3,
          c->ctrlhand,
          -c->opts.program,
          c->opts.video_stream,
          c->opts.audio_stream);
  }

  return NULL;
}

/**************************************************************/
/* options_set_loop()                                         */
/*                                                            */
/* Set playback looping state.                                */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero to play         */
/*             normally, else loop.                           */
/**************************************************************/

static _kernel_oserror * options_set_loop(client * c, const int boolean[1])
{
  bool b = boolean[0] == 0 ? false : true;

  dprintf(("", "options_set_loop %d (%p)\n", boolean[0], c));

  c->opts.loop = b ? 1 : 0;

  return NULL;
}

/**************************************************************/
/* options_set_demux()                                        */
/*                                                            */
/* Set stream demux module.                                   */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding zero for automatic   */
/*             selection where possible, else MPEG 2; 1 for   */
/*             MPEG 1 system streams; 2 for MPEG 2 transport  */
/*             streams.                                       */
/**************************************************************/

static _kernel_oserror * options_set_demux(client * c, const int demux[1])
{
  int d = demux[0];

  dprintf(("", "options_set_demux %d (%p)\n", demux[0], c));

  switch (d)
  {
    default:
    case 0: c->opts.demux = vc_demux_auto;  break;
    case 1: c->opts.demux = vc_demux_mpeg1; break;
    case 2: c->opts.demux = vc_demux_mpeg2; break;
    case 3: c->opts.demux = vc_demux_ext;   break;
  }

  return NULL;
}

/**************************************************************/
/* options_set_mode_width()                                   */
/*                                                            */
/* Set the playback mode width.                               */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding the screen width.    */
/**************************************************************/

static _kernel_oserror * options_set_mode_width(client * c, const int width[1])
{
  int w = width[0];

  c->opts.mode_width = w;

  return NULL;
}

/**************************************************************/
/* options_set_mode_height()                                  */
/*                                                            */
/* Set the playback mode height.                              */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int holding the screen height.   */
/**************************************************************/

static _kernel_oserror * options_set_mode_height(client * c, const int height[1])
{
  int h = height[0];

  c->opts.mode_height = h;

  return NULL;
}

/**************************************************************/
/* options_set_demux_mask()                                   */
/*                                                            */
/* Set stream demux mask.                                     */
/*                                                            */
/* Parameters: Pointer to client struct to set options in;    */
/*                                                            */
/*             Pointer to an int which will be given in R1 to */
/*             MPEGControl_ControlOp, if and only if the      */
/*             demux tag has value 3.                         */
/**************************************************************/

static _kernel_oserror * options_set_demux_mask(client * c, const int mask[1])
{
  int m = mask[0];

  dprintf(("", "options_set_demux_mask %d (%p)\n", mask[0], c));

  c->opts.demux_mask = m;

  return NULL;
}

/**************************************************************/
/* options_get_volume()                                       */
/*                                                            */
/* Get the volume.                                            */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take volume, 0 (off) to   */
/*             256 (full) (steps of roughly 0.5 dB).          */
/**************************************************************/

static _kernel_oserror * options_get_volume(client * c, int volume[1])
{
  volume[0] = c->opts.volume;

  return NULL;
}

/**************************************************************/
/* options_get_audio_channel()                                */
/*                                                            */
/* Get dual mono / stereo state.                              */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take audio channel        */
/*             specifier - 0 = stereo, 1 = dual left, 2 =     */
/*             dual right.                                    */
/**************************************************************/

static _kernel_oserror * options_get_audio_channel(client * c, int channels[1])
{
  channels[0] = c->opts.audio_channel;

  return NULL;
}

/**************************************************************/
/* options_get_mute()                                         */
/*                                                            */
/* Get audio mute state.                                      */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero for no muting,  */
/*             else muted.                                    */
/**************************************************************/

static _kernel_oserror * options_get_mute(client * c, int boolean[1])
{
  boolean[0] = c->opts.mute;

  return NULL;
}

/**************************************************************/
/* options_get_video_only()                                   */
/*                                                            */
/* Get video only (disable audio).                            */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to play audio   */
/*             and video, else video only.                    */
/**************************************************************/

static _kernel_oserror * options_get_video_only(client * c, int boolean[1])
{
  boolean[0] = c->opts.video_only;

  return NULL;
}

/**************************************************************/
/* options_get_audio_only()                                   */
/*                                                            */
/* Get audio only (enable audio).                             */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to play audio   */
/*             and video, else audio only.                    */
/**************************************************************/

static _kernel_oserror * options_get_audio_only(client * c, int boolean[1])
{
  boolean[0] = c->opts.audio_only;

  return NULL;
}

/**************************************************************/
/* options_get_rectangle()                                    */
/*                                                            */
/* Get video playback rectangle.                              */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to four consecutive ints to take the   */
/*             bottom left x and y coordinate and width and   */
/*             height of the play rectangle, in pixels.       */
/**************************************************************/

static _kernel_oserror * options_get_rectangle(client * c, int rectangle[4])
{
  rectangle[0] = c->opts.rectangle.x;
  rectangle[1] = c->opts.rectangle.y;
  rectangle[2] = c->opts.rectangle.w;
  rectangle[3] = c->opts.rectangle.h;

  return NULL;
}

/**************************************************************/
/* options_get_offsets()                                      */
/*                                                            */
/* Since issue 3 of the Video Control specification, tag 6 is */
/* reserved.                                                  */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to two consecutive ints.               */
/**************************************************************/

static _kernel_oserror * options_get_offsets(client * c, int offsets[2])
{
  (void) c;

  offsets[0] = 0;
  offsets[1] = 0;

  return NULL;
}

/**************************************************************/
/* options_get_ntsc()                                         */
/*                                                            */
/* Get NTSC or PAL style mode state.                          */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to use a PAL    */
/*             style mode, else NTSC.                         */
/**************************************************************/

static _kernel_oserror * options_get_ntsc(client * c, int boolean[1])
{
  boolean[0] = c->opts.ntsc;

  return NULL;
}

/**************************************************************/
/* options_get_macrovision()                                  */
/*                                                            */
/* Get Macrovision anti-taping state.                         */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to bypass the   */
/*             Macrovision circuitry, else enable             */
/*             anti-taping.                                   */
/**************************************************************/

static _kernel_oserror * options_get_macrovision(client * c, int boolean[1])
{
  boolean[0] = c->opts.macrovision;

  return NULL;
}

/**************************************************************/
/* options_get_depth()                                        */
/*                                                            */
/* Get intended playback mode's colour depth.                 */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take the intended         */
/*             playback mode colour depth, as log(2) BPP -    */
/*             i.e. 0 = 1 bpp, 1 = 2 bpp, 2 = 4 bpp etc.      */
/**************************************************************/

static _kernel_oserror * options_get_depth(client * c, int log2bpp[1])
{
  log2bpp[0] = c->opts.log2bpp;

  return NULL;
}

/**************************************************************/
/* options_get_no_interlace()                                 */
/*                                                            */
/* Get display interlace state.                               */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to allow screen */
/*             interlace, else disable it.                    */
/**************************************************************/

static _kernel_oserror * options_get_no_interlace(client * c, int boolean[1])
{
  boolean[0] = c->opts.no_interlace;

  return NULL;
}

/**************************************************************/
/* options_get_no_mode_change()                               */
/*                                                            */
/* Get whether or not the display mode is                     */
/* changed prior to playback.                                 */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to change mode, */
/*             else don't.                                    */
/**************************************************************/

static _kernel_oserror * options_get_no_mode_change(client * c, int boolean[1])
{
  boolean[0] = c->opts.no_mode_change;

  return NULL;
}

/**************************************************************/
/* options_get_no_cls()                                       */
/*                                                            */
/* Get whether or not the screen is cleared                   */
/* prior to playback.                                         */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to clear the    */
/*             screen, else don't.                            */
/**************************************************************/

static _kernel_oserror * options_get_no_cls(client * c, int boolean[1])
{
  boolean[0] = c->opts.no_cls;

  return NULL;
}

/**************************************************************/
/* options_get_no_palette()                                   */
/*                                                            */
/* Get whether or not the palette is changed                  */
/* prior to playback.                                         */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to set the      */
/*             palette, else don't.                           */
/**************************************************************/

static _kernel_oserror * options_get_no_palette(client * c, int boolean[1])
{
  boolean[0] = c->opts.no_palette;

  return NULL;
}

/**************************************************************/
/* options_get_no_redraw()                                    */
/*                                                            */
/* Get whether or not the screen is redrawn                   */
/* after playback.                                            */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take zero to redraw       */
/*             afterwards, else don't.                        */
/**************************************************************/

static _kernel_oserror * options_get_no_redraw(client * c, int boolean[1])
{
  boolean[0] = c->opts.no_redraw;

  return NULL;
}

/**************************************************************/
/* options_get_mp2program()                                   */
/*                                                            */
/* Get program number (MPEG 2 transport stream).              */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take the program number.  */
/**************************************************************/

static _kernel_oserror * options_get_mp2program(client * c, int program[1])
{
  program[0] = c->opts.program;

  return NULL;
}

/**************************************************************/
/* options_get_mp2videostream()                               */
/*                                                            */
/* Get video stream within an MPEG 2 program.                 */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take the video stream     */
/*             number.                                        */
/**************************************************************/

static _kernel_oserror * options_get_mp2videostream(client * c, int stream[1])
{
  stream[0] = c->opts.video_stream;

  return NULL;
}

/**************************************************************/
/* options_get_mp2audiostream()                               */
/*                                                            */
/* Get audio stream within an MPEG 2 program.                 */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take the audio stream     */
/*             number.                                        */
/**************************************************************/

static _kernel_oserror * options_get_mp2audiostream(client * c, int stream[1])
{
  stream[0] = c->opts.audio_stream;

  return NULL;
}

/**************************************************************/
/* options_get_npt()                                          */
/*                                                            */
/* Get estimate of normal play time.                          */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take an estimate of the   */
/*             current NPT.                                   */
/**************************************************************/

static _kernel_oserror * options_get_npt(client * c, int estimate[1])
{
  unsigned int    statsin  [2];
  unsigned char   statsout [32];
  unsigned char * written;

  unsigned int    scr_main, scr_high;

  estimate[0] = c->opts.npt = 0;

  if (c->havectrl == 0)                                       return NULL;
  if ((c->ctrl.flags & VC_ProtocolRegister_IHandleMPEG) != 0) return NULL;

  /* First read the system clock reference. Whenever we do trick play, */
  /* including pause, this resets to 0 and counts up at a 90KHz rate.  */

  if (
       _swix(MPEGVideo_ReadParameters,
             _IN(0) | _OUTR(1,2),

             MPEGVideo_ReadParameters_SCR,

             &scr_main,
             &scr_high)

       != NULL
     )
     return NULL;

  /* Now we want an NPT reference descriptor */

  statsin[0] = MPEGCtrl_MCS_NPTRefDesc;
  statsin[1] = -1;

  if (
       _swix(MPEGControl_Stats,
             _INR(0,4) | _OUT(3),

             0,
             c->ctrlhand,
             statsin,
             statsout,
             sizeof(statsout),

             &written)

       != NULL
     )
     return NULL;

  /* First word of statsout will be flags */

  if (written == statsout || (statsout[8] & (1u<<0)) == 0)
  {
    /* No NPT reference yet! Rely on STC */

    c->opts.npt = ((scr_main >> 1) | (scr_high << 31)) / 45000;
    estimate[0] = c->opts.npt;

    return NULL;
  }
  else
  {
    unsigned int npt_main, npt_sign;
    unsigned int stc_main, stc_sign;
    unsigned int scr;
    int          sca_deno, sca_nume;
    int          stc, npt;

    /* We do have an NPT reference. Decode it. */

//printf("12-15 %02x%02x%02x%02x\n"
//       "16-19 %02x%02x%02x%02x\n"
//       "20-23 %02x%02x%02x%02x\n"
//       "24-27 %02x%02x%02x%02x\n"
//       "28-31 %02x%02x%02x%02x\n",
//       statsout[12],statsout[13],statsout[14],statsout[15],
//       statsout[16],statsout[17],statsout[18],statsout[19],
//       statsout[20],statsout[21],statsout[22],statsout[23],
//       statsout[24],statsout[25],statsout[26],statsout[27],
//       statsout[28],statsout[29],statsout[30],statsout[31]);

    stc_sign = statsout[13] & (1u<<0);
    stc_main = statsout[14] << 24 |
               statsout[15] << 16 |
               statsout[16] << 8  |
               statsout[17];

    npt_sign = statsout[21] & (1u<<0);
    npt_main = statsout[22] << 24 |
               statsout[23] << 16 |
               statsout[24] << 8  |
               statsout[25];

    /* Scales are 16-bit signed; assemble the 16 bit quantity */
    /* then move the sign bit up to make a 32 bit signed int  */

    sca_nume = statsout[26] << 8 |
               statsout[27];

    sca_deno = statsout[28] << 8 |
               statsout[29];

    sca_nume = (sca_nume & 0x7fff) | ((sca_nume & 0x8000) << 16);
    sca_deno = (sca_deno & 0x7fff) | ((sca_deno & 0x8000) << 16);

// printf("** Allegedly, %08x (%d) npt, %08x (%d) STC\n",
// npt_main,npt_sign,stc_main,stc_sign);
// printf("** Additionally, %04x deno, %04x nume, sec: n+s (s) %d/%d (%d)\n",
// sca_deno,sca_nume,npt_main/90000,stc_main/90000,scr_main/90000);

    /* Downconvert 33 bit 90KHz quantities to 32 bit, 45KHz */

    scr = (scr_main >> 1) | (scr_high << 31);
    stc = (stc_main >> 1) | (stc_sign << 31);
    npt = (npt_main >> 1) | (npt_sign << 31);

    /* Now we're dealing wholly with 32 bit signed integers  */
    /* with a 45KHz resolution in the timers. Could overflow */
    /* if we try to scale though, so convert to 1s units now */

    scr /= 45000;
    stc /= 45000;
    npt /= 45000;

//printf("Thus scr, stc, npt %d, %d, %d\n",scr,stc,npt);

//// This fails, as the system does not reliably or sensibly reset
//// SCR to the STC value when an NPTRefD comes in (it should).
////
////    /* Finally, assemble our NPT estimate */
////
////    c->opts.npt = npt + (((scr - stc) * sca_nume) / sca_deno);

//// Thus we take the direct STC value (and hope we get +/- one
//// NPTRefD per frame) in trick play modes, or the SCR at all
//// other times (coming out of trick play this may well be awry)

    if (sca_nume != sca_deno) c->opts.npt = stc;
    else                      c->opts.npt = scr;
  }

  estimate[0] = c->opts.npt;

  return NULL;
}

/**************************************************************/
/* options_get_loop()                                         */
/*                                                            */
/* Get playback looping state.                                */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take volume, 0 (off) to   */
/*             256 (full) (steps of roughly 0.5 dB).          */
/**************************************************************/

static _kernel_oserror * options_get_loop(client * c, int boolean[1])
{
  boolean[0] = c->opts.loop;

  return NULL;
}

/**************************************************************/
/* options_get_demux()                                        */
/*                                                            */
/* Get stream demux module.                                   */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take demux selector; 0 =  */
/*             automatic selection where possible, else MPEG  */
/*             2; 1 = MPEG 1 system stream; 2 = MPEG 2        */
/*             transport stream.                              */
/**************************************************************/

static _kernel_oserror * options_get_demux(client * c, int demux[1])
{
  demux[0] = c->opts.demux;

  return NULL;
}

/**************************************************************/
/* options_get_control_handle()                               */
/*                                                            */
/* Get the MPEG control handle, if available.                 */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take MPEG control handle. */
/**************************************************************/

static _kernel_oserror * options_get_control_handle(client * c, int control[1])
{
  if (c->havectrl) control[0] = c->ctrlhand;
  else             control[0] = 0;

  return NULL;
}

/**************************************************************/
/* options_get_mode_width()                                   */
/*                                                            */
/* Get the playback mode width.                               */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take the screen width.    */
/**************************************************************/

static _kernel_oserror * options_get_mode_width(client * c, int width[1])
{
  width[0] = c->opts.mode_width;

  return NULL;
}

/**************************************************************/
/* options_get_mode_height()                                  */
/*                                                            */
/* Get the playback mode height.                              */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take the screen height.   */
/**************************************************************/

static _kernel_oserror * options_get_mode_height(client * c, int height[1])
{
  if (c->opts.mode_height != 0)
  {
    height[0] = c->opts.mode_height;
  }
  else
  {
    /* Use TV$Type */

    char * tvtype;

    tvtype = getenv("TV$Type");
    if (tvtype == NULL) tvtype = "";

    if (!strcmp(tvtype, "NTSC")) height[0] = MPEGCtrl_DefaultModeHeightNTSC;
    else                         height[0] = MPEGCtrl_DefaultModeHeightPAL;
  }

  return NULL;
}

/**************************************************************/
/* options_get_play_state()                                   */
/*                                                            */
/* Get the current playback state.                            */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take the state.           */
/**************************************************************/

static _kernel_oserror * options_get_play_state(client * c, int state[1])
{
  state[0] = c->opts.play_state;

  return NULL;
}

/**************************************************************/
/* options_get_demux_mask()                                   */
/*                                                            */
/* Get stream demux mask.                                     */
/*                                                            */
/* Parameters: Pointer to client struct to get options from;  */
/*                                                            */
/*             Pointer to an int to take demux mask, which is */
/*             the value given in R1 to MPEGControl_ControlOp */
/*             0 if and only if the demux tag has value 3.    */
/**************************************************************/

static _kernel_oserror * options_get_demux_mask(client * c, int mask[1])
{
  mask[0] = c->opts.demux_mask;

  return NULL;
}
