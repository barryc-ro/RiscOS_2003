/**************************************************************/
/* File:    MPEGCtrl.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handle the MPEG system and display setup.         */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 15-Dec-1999 (ADH): Created.                       */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include <Global/RISCOS.h>
#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Module.h"
#include "Options.h"
#include "Utils.h"

#include "MPEGCtrl.h"

/* Local structures */

typedef struct mpegctrl_videoblock
{
  unsigned int format; /* Zero */
  unsigned int flags;
  int          screen_mode;
  int          reserved[4];
  unsigned int blanked_sequences;
  unsigned int blanked_fields;

} mpegctrl_videoblock;

typedef enum mpegctrl_dcms
{
  dcms_both = 0,
  dcms_left,
  dcms_right

} mpegctrl_dcms;

typedef struct mpegctrl_audioblock
{
  unsigned int  format; /* Zero */
  unsigned int  flags;
  mpegctrl_dcms dcms;

} mpegctrl_audioblock;

/* Local variables */

static unsigned int palette1[2]  = {
                                     0xFFFFFF00, 0x000000F0
                                   };

static unsigned int palette2[4] =  {
                                     0x00000000, 0x88888800, 0xFFFFFF00, 0x000000F0
                                   };

static unsigned int palette4[16] = {
                                     0x00000000, 0x55555500, 0xAAAAAA00, 0xFFFFFF00,
                                     0x0000FF00, 0x00FF0000, 0x00BBFF00, 0xFF000000,
                                     0x000000F0, 0x000000F0, 0x000000F0, 0x000000F0,
                                     0x000000F0, 0x000000F0, 0x000000F0, 0x000000F0
                                   };

static unsigned int palette8[8]  = {
                                     0x11111100, 0x22222200,
                                     0x00004400, 0x44000000,
                                     0x00008800, 0x00440000,
                                     0x00880000, 0x88000000
                                   };

static unsigned int palette16[8] = {
                                     0x00000800, 0x00081000,
                                     0x08102100, 0x10214210,
                                     0x21428400, 0x42840000,
                                     0x84000000, 0x00000000
                                   };

static unsigned int palette32[8] = {
                                     0x01010110, 0x02020200,
                                     0x04040400, 0x08080800,
                                     0x10101000, 0x20202000,
                                     0x40404000, 0x80808000
                                   };

/* Local functions */

static _kernel_oserror * mpegctrl_setup_mode    (client * c);
static _kernel_oserror * mpegctrl_setup_palette (client * c);

/**************************************************************/
/* mpegctrl_setup_display()                                   */
/*                                                            */
/* Set the palette, screen mode etc. ready for playback,      */
/* making sure the options settings in the given client       */
/* structure are obeyed.                                      */
/*                                                            */
/* Parameters: Pointer to a client structure containing       */
/*             options governing what action is taken here.   */
/**************************************************************/

_kernel_oserror * mpegctrl_setup_display(client * c)
{
  _kernel_oserror * e1;
  _kernel_oserror * e2;

  e1 = mpegctrl_setup_mode    (c);
  e2 = mpegctrl_setup_palette (c);

  if (e2 != NULL) mpegctrl_restore_display(c);

  if (e1 != NULL) return e1;
  if (e2 != NULL) return e2;

  /* Finished */

  return NULL;
}

/**************************************************************/
/* mpegctrl_restore_display()                                 */
/*                                                            */
/* Restore screen mode from the given client structure, if    */
/* the options settings allow screen mode changing.           */
/*                                                            */
/* Parameters: Pointer to a client structure containing       */
/*             options governing what action is taken here.   */
/**************************************************************/

_kernel_oserror * mpegctrl_restore_display(client * c)
{
  if (!c->opts.no_mode_change && !c->opts.no_redraw)
  {
    if (c->rstbydsk != 0)
    {
      _kernel_oserror * e = _swix(Wimp_SetMode,
                                  _IN(0),

                                  c->wimpmode);

      _swix(Wimp_CommandWindow,
            _IN(0),

            -1);

      return e;
    }
    else
    {
      _kernel_oserror * e = _swix(OS_ScreenMode,
                                  _INR(0,1),

                                  0,
                                  c->modecopy);

      if ((unsigned int) (c->modecopy) > 256) free(c->modecopy), c->modecopy = 0;

      return e;
    }
  }

  return NULL;
}

/**************************************************************/
/* mpegctrl_setup_mode()                                      */
/*                                                            */
/* Change to a screen mode appropriate for the options        */
/* settings in the given client structure, if those options   */
/* allow mode changing.                                       */
/*                                                            */
/* Parameters: Pointer to a client structure containing       */
/*             options governing what action is taken here.   */
/**************************************************************/

static _kernel_oserror * mpegctrl_setup_mode(client * c)
{
  _kernel_oserror * e;
  int               modeblock[10];
  unsigned int      mode, rsir;
  bool              in_desktop;

  if (!c->opts.no_mode_change)
  {
    /* Set up the screen mode */

    modeblock[0] = 1;
    modeblock[1] = c->opts.mode_width;
    modeblock[2] = c->opts.mode_height;
    modeblock[3] = c->opts.log2bpp;
    modeblock[4] = MPEGCtrl_DefaultFrameRate;

    if (c->opts.no_interlace) modeblock[2] = modeblock[2] >> 1;

    /* If in an 8bpp mode, must make sure the 256 colours are fully defineable */

    if (modeblock[3] == 3)
    {
      modeblock[5] = 0;   /* Mode flags            */
      modeblock[6] = 128; /* 128 (PRM 5a-135)      */
      modeblock[7] = 3;   /* Number of colours     */
      modeblock[8] = 255; /* 256, fully defineable */
      modeblock[9] = -1;  /* End of block          */
    }
    else modeblock[5] = -1; /* End of block */

    /* Our action now depends on the current mode - in the */
    /* Desktop or not?                                     */

    e = _swix(Wimp_ReadSysInfo,
              _IN(0) | _OUT(0),

              3, /* Get Wimp state */

              &rsir);

    if (e) return e;

    if (rsir == 0) in_desktop = false, c->rstbydsk = 0;
    else           in_desktop = true,  c->rstbydsk = 1;

    if (in_desktop)
    {
      e = _swix(Wimp_ReadSysInfo,
                _IN(0) | _OUT(0),

                1, /* Read Wimp mode */

                &mode);

      if (e) return e;

      c->wimpmode = mode;

      /* We do command window magic before changing mode too */

      _swix(Wimp_CommandWindow,
            _IN(0),

            1);
    }
    else
    {
      /* First read the current mode */

      e = _swix(OS_ScreenMode,
                _IN(0) | _OUT(1),

                1, /* Read mode */

                &mode);

      if (e) return e;

      /* Assume a mode number if <= 256, else selector block. This */
      /* is foul, but the PRM (5a-132) gives no recommended way of */
      /* telling the difference.                                   */

      if ((unsigned int) (c->modecopy) > 256) free(c->modecopy), c->modecopy = 0;

      if (mode <= 256) c->modecopy = (void *) mode;
      else
      {
        int count = 0;

        while (((int *)(mode))[count] != -1) count += 4;

        c->modecopy = malloc(count + 4);
        if (!c->modecopy) return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
        memcpy(c->modecopy, (int *) mode, count + 4);
      }
    }

    /* Now do the mode change, accounting for Macrovision */

    _swix(Macrovision_SetState,
          _INR(0,2),

          0,
          c->opts.macrovision,
          MPEGCtrl_MacrovisionTVFormat);

    e = _swix(OS_ScreenMode,
              _INR(0,1),

              0,
              modeblock);

    if (e != NULL) return e;

    if (c->opts.macrovision) _swix(Macrovision_SetState,
                                   _INR(0,2),

                                   0,
                                   0,
                                   MPEGCtrl_MacrovisionTVFormat);

    /* Turn the text cursor off */

    _swix(OS_WriteC, _IN(0), 23);
    _swix(OS_WriteC, _IN(0), 1);

    {
      int i;

      for (i = 0; i < 8; i ++)
      {
        _swix(OS_WriteC, _IN(0), 0);
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* mpegctrl_setup_palette()                                   */
/*                                                            */
/* Change to a palette appropriate for the options settings   */
/* settings in the given client structure, if those options   */
/* allow palette changing.                                    */
/*                                                            */
/* If screen mode changing is allowed, the routine will also  */
/* ensure the whole screen foreground is set transparent.     */
/*                                                            */
/* Parameters: Pointer to a client structure containing       */
/*             options governing what action is taken here.   */
/**************************************************************/

static _kernel_oserror * mpegctrl_setup_palette(client * c)
{
  if (!c->opts.no_palette)
  {
    unsigned int * palette;
    unsigned int   entries;
    unsigned int   fg, bg;
    unsigned int   log2bpp;
    unsigned int   trans = 0xffffff10;

    if (
         _swix(OS_ReadModeVariable,
               _INR(0,1) | _OUT(2),

               -1, /* Current mode */
               9,  /* Log2bpp      */

               &log2bpp)
       )
       log2bpp = c->opts.log2bpp;

    switch(log2bpp)
    {
      default:
      case 0: palette = palette1,  entries = 2;  break;
      case 1: palette = palette2,  entries = 4;  break;
      case 2: palette = palette4,  entries = 16; break;
      case 3: palette = palette8,  entries = 8;  break;
      case 4: palette = palette16, entries = 8;  break;
      case 5: palette = palette32, entries = 8;  break;
    }

    /* For >= 8 bpp, we construct the palette using a weighting table. */
    /* 8bpp is a slightly special case which works by a similar        */
    /* mechanism, though; we end up with colour 1 explicitly set to    */
    /* transparent. For 16bpp modes, bit 15 set means transparent;     */
    /* for 32bpp modes, bit 24 set means transparent.                  */

    if (log2bpp >= 3)
    {
      int i, a;

      for (i = 0; i < 256; i++)
      {
        a = 0;

        if (i & 1)   a += palette[0];
        if (i & 2)   a += palette[1];
        if (i & 4)   a += palette[2];
        if (i & 8)   a += palette[3];
        if (i & 16)  a += palette[4];
        if (i & 32)  a += palette[5];
        if (i & 64)  a += palette[6];
        if (i & 128) a += palette[7];

        _swix(OS_CallAVector,
              _INR(0,2) | _IN(4) | _IN(9),

              i,         /* Logical colour */
              16,        /* Type of colour (16: Logical colour = RGB) */
              a & trans, /* BBGGRRxx colour setting */
              2,         /* 2: Set palette */
              PaletteV);
      }

      if (log2bpp == 3)
      {
        /* For 8bpp, set colour 1 to transparent */

        _swix(OS_CallAVector,
              _INR(0,2) | _IN(4) | _IN(9),

              1,
              16,
              0xf0 & trans,
              2,
              PaletteV);
      }
    }

    /* For < 8bpp, we use a fixed programmed palette where the top  */
    /* physical colour is always transparent. See the tables at the */
    /* top of this source file for the palette entry values.        */

    else
    {
      /* For any other colour depth, set a 16 colour palette with the */
      /* top 8 transparent.                                           */

      int i;

      for (i = 0; i < entries; i++)
      {
        _swix(OS_CallAVector,
              _INR(0,2) | _IN(4) | _IN(9),

              i,
              16,
              palette[i] & trans,
              2,
              PaletteV);
      }
    }

    /* Set the border to transparent too */

    _swix(OS_CallAVector,
          _INR(0,2) | _IN(4) | _IN(9),

          0,
          24,           /* Type of colour (24: Border colour = RGB) */
          0xf0 & trans,
          2,
          PaletteV);

    /* Set an opaque foreground and transparent background */

    switch (log2bpp)
    {
      default:
      case 0: fg = 0,        bg = 1;     break;
      case 1: fg = 2,        bg = 3;     break;
      case 2: fg = 3,        bg = 15;    break;
      case 3: fg = 255,      bg = 1;     break;
      case 4: fg = 0x7fff,   bg = 1<<15; break;
      case 5: fg = 0xffffff, bg = 1<<24; break;
    }

    _swix(OS_SetColour,
          _INR(0,1),

          0x40,    /* Set text foreground colour */
          fg);

    _swix(OS_SetColour,
          _INR(0,1),

          0x50,    /* Set text background colour */
          bg);

  } /* if (!c->opts.no_palette) */

  if (!c->opts.no_cls) _swix(OS_WriteI + 12, 0); /* CLS */

  /* Finished. */

  return NULL;
}

/**************************************************************/
/* mpegctrl_setup_mpeg()                                      */
/*                                                            */
/* Call to the MPEG software to get it ready for video        */
/* intial video decode.                                       */
/*                                                            */
/* Parameters: Pointer to a client structure containing       */
/*             options governing what action is taken here.   */
/**************************************************************/

_kernel_oserror * mpegctrl_setup_mpeg(client * c)
{
  _kernel_oserror     * e;
  unsigned int          ctrlflags, audioflags, videoflags;
  mpegctrl_audioblock   audioblock;
  mpegctrl_videoblock   videoblock;

  _swix(OS_CLI,
        _IN(0),

        MPEGCtrl_SyncOffsetCommand);

  /* Assemble the control flags */

  ctrlflags = MPEGCtrl_MCOS_AudioToStreamSyncOn |
              MPEGCtrl_MCOS_ReservedSetToOne    |
              MPEGCtrl_MCOS_EnableOVSTrickPlay  |
              MPEGCtrl_MCOS_AutoReset;

  if (c->opts.audio_only == 0) ctrlflags |= MPEGCtrl_MCOS_VideoPresent;
  if (c->opts.video_only == 0) ctrlflags |= MPEGCtrl_MCOS_AudioPresent;

  /* Assemble the video flags */

  videoflags = MPEGCtrl_MCOS_Video_NoCLS        |
               MPEGCtrl_MCOS_Video_NoPalette    |
               MPEGCtrl_MCOS_Video_UnderrunFix  |
               MPEGCtrl_MCOS_Video_PESLengthFix;

  if (c->opts.ntsc != 0) videoflags |= MPEGCtrl_MCOS_Video_NTSC;

  /* Assemble the audio flags */

  audioflags = MPEGCtrl_MCOS_Audio_MuteOnError |
               MPEGCtrl_MCOS_Audio_DCMSIsValid;

  /* Fill in the blocks */

  memset(&audioblock, 0, sizeof(audioblock)); /* Ensure reserved fields are */
  memset(&videoblock, 0, sizeof(videoblock)); /* set to zero.               */

  videoblock.format            = 0;
  videoblock.flags             = videoflags;
  videoblock.screen_mode       = MPEGCtrl_MCOS_Video_DefaultMode;
  videoblock.blanked_sequences = 1;  /* At time of writing videoflags says these fields are not */
  videoblock.blanked_fields    = 16; /* present, but fill with defaults from spec just in case  */

  audioblock.format            = 0;
  audioblock.flags             = audioflags;

  if      (c->opts.audio_channel == vc_audio_dual_left)  audioblock.dcms = dcms_left;
  else if (c->opts.audio_channel == vc_audio_dual_right) audioblock.dcms = dcms_right;
  else                                                   audioblock.dcms = dcms_both;

  /* Select a stream demux module */

  if (c->opts.demux == 1)
  {
    /* Force MPEG1SS */

    e = _swix(MPEGControl_ControlOp,
              _INR(0,1),

              MPEGControl_MCCO_SetDemuxModule,
              MPEGControl_MCCO_MPEGSystem);
  }
  else
  {
    /* We've no auto yet, so anything else is MPEG2TS */

    e = _swix(MPEGControl_ControlOp,
              _INR(0,1),

              MPEGControl_MCCO_SetDemuxModule,
              MPEGControl_MCCO_MPEGTransport);
  }

  if (e) return e;

  /* Get our control handle */

  e = _swix(MPEGControl_OpenStream,
            _INR(0,3) | _OUT(0),

            ctrlflags,
            0,           /* (R1 = reserved (0)) */
            &videoblock,
            &audioblock,

            &c->ctrlhand);

  if (e == NULL) c->havectrl = 1;

  /* Finally, tell UDPV we're starting */

  _swix(UDPV_StartOfPlay,
        _INR(2,4),

        0,
        c->ctrlhand,
        0);

  return e;
}

/**************************************************************/
/* mpegctrl_restore_mpeg()                                    */
/*                                                            */
/* Call to the MPEG software to tell it video decoding has    */
/* finished.                                                  */
/*                                                            */
/* Parameters: Pointer to a client structure containing       */
/*             details of the current video decode session.   */
/**************************************************************/

_kernel_oserror * mpegctrl_restore_mpeg(client * c)
{
  _kernel_oserror * e;

  _swix(UDPV_EndOfPlay, 0);

  e = _swix(MPEGControl_CloseStream,
            _INR(0,1),

            0,
            c->ctrlhand);

  c->ctrlhand = 0;

  return e;
}
