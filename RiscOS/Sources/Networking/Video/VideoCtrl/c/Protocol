/**************************************************************/
/* File   : Protocol.c                                        */
/*          (C) 1999 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Protocol handler. Deals with all the protocol     */
/*          modules; registering, deregistering and assigning */
/*          requests to the correct SWI base.                 */
/*                                                            */
/* Author : A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 09-Sep-1999 (ADH): Created.                       */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>

#include <swis.h>
#include <Global/Services.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Generic.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Options.h"
#include "URLutils.h"
#include "Utils.h"
#include "VCAPI.h"
#include "VCHdr.h"

#include "Protocol.h"

/* Local structures */

typedef struct protocol
{
  char            * url_base;     /* base that protocol deals with */
  unsigned int      swi_base;     /* SWI Base for module */
  unsigned int      version;      /* Module version number */
  unsigned int      port_no;      /* Default TCP port number for this protocol */
  unsigned int      flags;        /* Protocol flags */

  #ifdef DIRECTSWI
    unsigned int    swientry;     /* Hack hack hack! */
    void          * private_word;
  #endif

  char              info[50];     /* Small info string */
  struct protocol * next;

} protocol;

typedef struct config
{
  struct config * next;

  char          * fragment;
  unsigned int    swi_base;

} config;

/* Local variables */

static protocol * protocols = NULL;
static config   * configs   = NULL;

/* Local functions */

static _kernel_oserror * protocol_notify_0                      (client * list, unsigned int flags, char * code);
static _kernel_oserror * protocol_notify_1                      (client * list);

static int               protocol_skip_white_space_and_comments (FILE * f);
static int               protocol_read_string                   (FILE * f, char ** string);
static _kernel_oserror * protocol_read_configuration            (void);

static const protocol  * protocol_find_from_swi_base            (unsigned int swi_base);
static int               protocol_default_flags                 (const char * url);
static unsigned int      protocol_default_port_number           (const char * url);

/**************************************************************/
/* lower_string()                                             */
/*                                                            */
/* Convert a string to lower case, altering only those        */
/* characters that were already in upper case according to    */
/* isupper().                                                 */
/*                                                            */
/* Parameters: Pointer to the NUL terminated string.          */
/**************************************************************/

static void lower_string(char * ptr)
{
  while (*ptr)
  {
    if (isupper(*ptr))
    {
      *ptr = tolower(*ptr);
    }
    ++ptr;
  }
}

/**************************************************************/
/* protocol_register()                                        */
/*                                                            */
/* Implement VideoControl_ProtocolRegister. See the Video     */
/* Control specification, 2501,817/FS, for more.              */
/**************************************************************/

_kernel_oserror * protocol_register(_kernel_swi_regs * r)
{
  protocol * proto;
  char     * protostr;

  if (r->r[2] != 0) protostr = Strdup((char *) r->r[2]);
  else              protostr = Strdup("rtsp:");

  if (protostr == NULL)
  {
    dprintf(("", "protocol_register: protostr is NULL, generating MEMORY_EXHAUSTED\n"));
    return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
  }

  lower_string(protostr);

  /* Check to see if a protocol already has the same SWI base or same URL */
  /* base. If the latter, ensure the config file is read in as per spec.  */

  proto = protocols;

  while (proto)
  {
    if (proto->swi_base == r->r[1])
    {
      free(protostr);
      dprintf(("", "protocol_register: Same SWI base, generating INDISTINGUISHABLE\n"));
      return make_error(vc_ERROR_INDISTINGUISHABLE, 0);
    }

    if (!Strcmp_ci(proto->url_base, (char *) r->r[2]))
    {
      dprintf(("", "protocol_register: Same URL base, checking config file\n"));

      if (configs == NULL)
      {
        _kernel_oserror * e = protocol_read_configuration();

        if (e)
        {
          free(protostr);
          return e;
        }
      }
    }

    proto = proto->next;
  }


  proto = malloc(sizeof(protocol));

  if (proto == NULL)
  {
    free(protostr);
    dprintf(("", "protocol_register: proto is NULL, generating MEMORY_EXHAUSTED\n"));
    return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
  }
  else
  {
    proto->next = protocols;
    protocols   = proto;
  }

  /* save the swi base, protocol base & version number */

  proto->swi_base = r->r[1];
  proto->version  = r->r[3];
  proto->url_base = protostr;

  #ifdef DIRECTSWI
    proto->swientry = 0;
  #endif

  proto->info[0] = '\0';

  if (r->r[4] != 0)
  {
    strncat(proto->info, (char *) r->r[4], sizeof(proto->info));
  }

  if (r->r[0] & 1)
  {
    proto->flags = r->r[5];
  }
  else
  {
    proto->flags = protocol_default_flags(proto->url_base);
  }

  if (r->r[0] & 2)
  {
    proto->port_no = r->r[6];
  }
  else
  {
    proto->port_no = protocol_default_port_number(proto->url_base);
  }

  _swix(OS_ServiceCall,
        _INR(0,4),

        0,
        Service_VideoControl_ProtocolModule,
        proto->url_base,
        proto->swi_base,
        proto->info);

  dprintf(("", "protocol_register: Successful\n"));

  return NULL;
}

/**************************************************************/
/* protocol_deregister()                                      */
/*                                                            */
/* Implement VideoControl_ProtocolDeregister. See the Video   */
/* Control specification, 2501,817/FS, for more.              */
/**************************************************************/

_kernel_oserror * protocol_deregister(_kernel_swi_regs * r)
{
  const unsigned int   swibase  = r->r[1];
  char               * protostr = (r->r[0] & 1) ? (char *) r->r[2] : NULL;
  protocol           * proto;
  protocol           * owner    = NULL;

  #ifdef TRACE
    int cleared = 0;
  #endif

  dprintf(("", "protocol_register: called\n"));

  for (proto=protocols; proto; owner=proto, proto=proto->next)
  {
    if (proto->swi_base != swibase) continue;
    if (protostr != NULL)
    {
      if (Strcmp_ci(proto->url_base, protostr) != 0) continue;
    }

    if (owner == NULL)
    {
      protocols = proto->next;
    }
    else
    {
      owner->next = proto->next;
    }

    _swix(OS_ServiceCall,
          _INR(0,4),

          1,
          Service_VideoControl_ProtocolModule,
          proto->url_base,
          proto->swi_base,
          proto->info);

    free(proto->url_base);
    free(proto);

    #ifdef TRACE
      cleared++;
    #endif
  }

  #ifdef TRACE
    dprintf(("", "protocol_register: Sucessful (%d freed)\n", cleared));
  #endif

  return NULL;
}

/**************************************************************/
/* protocol_get_details()                                     */
/*                                                            */
/* Get details of a protocol module.                          */
/*                                                            */
/* Parameters: Number of protocol module to return in the     */
/*             list (1 = first);                              */
/*                                                            */
/*             Pointer to a char * updated to point to the    */
/*             module's (registered) name;                    */
/*                                                            */
/*             Pointer to a char * updated to point to the    */
/*             module's (registered) help string;             */
/*                                                            */
/*             Pointer to an int updated with the module's    */
/*             SWI base;                                      */
/*                                                            */
/*             Pointer to an int updated with the module's    */
/*             version number, * 100.                         */
/*                                                            */
/* Returns:    Number of the next module in the list, or -1   */
/*             for "ran out". In this case the various        */
/*             parameter pointers won't be updated.           */
/**************************************************************/

int protocol_get_details(int ctr, char ** name, char ** help, int * swibase, int * version)
{
  protocol * proto;
  int        count = 0;

  for (proto = protocols; proto && count < ctr; proto = proto->next)
  {
    ++count;
  }

  if (proto == NULL)
  {
    return -1;
  }
  else
  {
    *name    = proto->url_base;
    *help    = proto->info;
    *swibase = proto->swi_base;
    *version = proto->version;

    return count + 1;
  }
}

/**************************************************************/
/* protocol_notify()                                          */
/*                                                            */
/* Implement VideoControl_ProtocolNotify. See the Video       */
/* Control specification, 2501,817/FS, for more.              */
/**************************************************************/

_kernel_oserror * protocol_notify(_kernel_swi_regs * r)
{
  client * list = find_client_by_protocol_id(r->r[1]);

  dprintf(("", "protocol_notify: Called for %08X, reason %0d\n", r->r[1], r->r[2]));

  /* Return an error if not registered */

  if (list == NULL)
  {
    return make_error(vc_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  /* It'd be very weird if a protocol module called us and we didn't */
  /* know about it, but it can still happen...                       */

  if (list->ctrl.protocol == 0)
  {
    _kernel_oserror * e = make_error(vc_ERROR_NOT_SETUP_YET, 0);
    sprintf(strchr(e->errmess, '\0'), " (%08x)", r->r[1]);

    return e;
  }

  /* Reason code is in R2 */

  switch (r->r[2])
  {
    case VideoControlProtocolNotifyResponseReceived:
    {
      return protocol_notify_0(list, r->r[3], (char *) r->r[4]);
    }
    break;

    case VideoControlProtocolNotifyMessageReceived:
    {
      return protocol_notify_1(list);
    }
    break;
  }

  return NULL;
}

/**************************************************************/
/* protocol_notify_0()                                        */
/*                                                            */
/* Implement VideoControl_ProtocolNotify reason code 0. See   */
/* the Video Control specification, 2501,817/FS, for more.    */
/**************************************************************/

static _kernel_oserror * protocol_notify_0(client * list, unsigned int flags, char * code)
{
  (void) code;

  /* Should we prepare for video data / reset the stream? */

  if (flags & VC_ProtocolNotify_ResponseReceived_Prepare)
  {
    dprintf(("", "protocol_notify_0: Prepare for playback\n"));

    if (list->ctrlhand == 0)
    {
      _kernel_oserror * e1 = NULL;
      _kernel_oserror * e2 = NULL;

      dprintf(("", "protocol_notify_0: Not already playing, setting everything up\n"));

      e1 = mpegctrl_setup_display(list);
      e2 = mpegctrl_setup_mpeg(list);

      if (e2 != NULL)
      {
        mpegctrl_restore_display(list);
        list->ctrlhand = 0;
      }

      if (e1 != NULL) return e1;
      if (e2 != NULL) return e2;
    }

    /* There's no "else" case. We issue a deferred reset just *before* */
    /* calling the protocol module's Play SWI, to get as seamless a    */
    /* transition as possible.                                         */
  }

  /* Finally, send the ResponseReceived service call */

  return _swix(OS_ServiceCall,
               _INR(0,1),

               VideoControlResponseReceived,
               Service_VideoControl);
}

/**************************************************************/
/* protocol_notify_1()                                        */
/*                                                            */
/* Implement VideoControl_ProtocolNotify reason code 1. See   */
/* the Video Control specification, 2501,817/FS, for more.    */
/**************************************************************/

static _kernel_oserror * protocol_notify_1(client * list)
{
  (void) list;

  /* Send the MessageReceived service call */

  return _swix(OS_ServiceCall,
               _INR(0,1),

               VideoControlMessageReceived,
               Service_VideoControl);
}

/**************************************************************/
/* protocol_options()                                         */
/*                                                            */
/* Implement VideoControl_ProtocolOptions. See the Video      */
/* Control specification, 2501,817/FS, for more.              */
/**************************************************************/

_kernel_oserror * protocol_options(_kernel_swi_regs * r)
{
  client * list = find_client(r->r[1]);

  dprintf(("", "protocol_options: Called for %08X\n", r->r[1]));

  /* Return an error if not registered */

  if (list == NULL)
  {
    return make_error(vc_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  /* It'd be very weird if a protocol module called us and we didn't */
  /* know about it, but it can still happen... Note that even if the */
  /* protocol module is doing Protocol_Setup, we'll have filled in   */
  /* ctrl.protocol beforehand.                                       */

  if (list->ctrl.protocol == 0)
  {
    _kernel_oserror * e = make_error(vc_ERROR_NOT_SETUP_YET, 0);
    sprintf(strchr(e->errmess, '\0'), " (%08x)", r->r[1]);

    return e;
  }

  /* Pass the options block to the options processing engine */

  return options_options_backend(list, (vc_options *) r->r[2], 1);
}

/**************************************************************/
/* protocol_free_configuration()                              */
/*                                                            */
/* Free any data relating to the configuration file.          */
/**************************************************************/

void protocol_free_configuration(void)
{
  config * next;
  config * head = configs;

  while (head)
  {
    next = head->next;

    free(head->fragment);
    free(head);

    head = next;
  }

  configs = NULL;
}

/**************************************************************/
/* protocol_skip_white_space_and_comments()                   */
/*                                                            */
/* Advance the file pointer in the given file past any white  */
/* space and comment lines in a configuration file. A comment */
/* line is marked by a '#' as the first character encountered */
/* or after any space. Comment lines terminate in CR or LF.   */
/*                                                            */
/* Parameters: FILE * for the file to read, opened "rb".      */
/*                                                            */
/* Returns:    Integer equal to EOF (in which case ignore the */
/*             file pointer position via. ftell) or the first */
/*             non-comment, non-whitespace byte encountered   */
/*             in the file (in which case the file pointer    */
/*             will be positioned in front of the character   */
/*             returned, so an fgetc() would re-get that      */
/*             character).                                    */
/*                                                            */
/* Assumes:    Parameter is non-NULL and valid.               */
/**************************************************************/

static int protocol_skip_white_space_and_comments(FILE * f)
{
  int c;

  do
  {
    do
    {
      c = fgetc(f);
    }
    while (c != EOF && c <= ' ');

    /* If we have a hash this is a comment; find a CR or LF */

    if (c == '#')
    {
      do
      {
        c = fgetc(f);
      }
      while (c != EOF && c != '\n' && c != 'r');
    }
  }
  while (c != EOF && c <= ' ');

  /* If we didn't run out of file, back the file pointer up one */

  if (c != EOF) fseek(f, ftell(f) - 1, SEEK_SET);

  return c;
}

/**************************************************************/
/* protocol_read_string()                                     */
/*                                                            */
/* Read a string from a config file. The string is terminated */
/* by EOF or any white space.                                 */
/*                                                            */
/* Parameters: FILE * for the file to read, opened "rb";      */
/*                                                            */
/*             Pointer to a char * which will be updated to   */
/*             point to a malloced block holding the string,  */
/*             NUL terminated. It is only NULL if no memory   */
/*             could be allocated.                            */
/*                                                            */
/* Returns:    Zero or EOF if the file ran out. The file      */
/*             pointer pointS to the first non-white space    */
/*             character after the string. If a memory        */
/*             allocation fails (see Parameters above) the    */
/*             return value is irrelevant and the file        */
/*             pointer is restored to its on-entry value      */
/*             where possible.                                */
/*                                                            */
/* Assumes:    All parameters are non-NULL and valid. If the  */
/*             first character the function reads is white    */
/*             space, results are undefined.                  */
/**************************************************************/

static int protocol_read_string(FILE * f, char ** string)
{
  long int pos = ftell(f);
  size_t   len = 0;
  size_t   i;
  int      c;

  /* Find the length */

  for (;;)
  {
    c = fgetc(f);

    if (c != EOF && c > ' ')
    {
      len++;
    }
    else
    {
      break;
    }
  }

  /* Put the file pointer back */

  if (len > 0) fseek(f, pos, SEEK_SET);

  /* Allocate space for string plus terminator */

  *string = malloc(len + 1);
  if (!*string) return '\0';

  /* Read and terminate it */

  for (i = 0; i < len; i++)
  {
    (*string)[i] = fgetc(f);
  }

  (*string)[len] = '\0';

  /* Done */

  if (c == EOF) return EOF;
  else          return 0;
}

/**************************************************************/
/* protocol_read_configuration()                              */
/*                                                            */
/* Read the configuration file into a list of config structs  */
/* (see top of file). This list is file-global and if one     */
/* aleady exists it will be freed first.                      */
/**************************************************************/

static _kernel_oserror * protocol_read_configuration(void)
{
  FILE   * f;
  int      c;
  config * new;

  dprintf(("", "protocol_read_configuration: Called\n"));

  protocol_free_configuration();
  configs = NULL;

  f = fopen(ConfigFile, "rb");

  if (!f)
  {
    dprintf(("", "protocol_read_configuration: Can't open file, generating CANNOT_OPEN_CONFIG\n"));
    return make_error(vc_ERROR_CANNOT_OPEN_CONFIG, 0);
  }

  /* Go around entry by entry */

  do
  {
    /* Find the start of a URL fragment */

    c = protocol_skip_white_space_and_comments(f);

    if (c != EOF)
    {
      char * temp = NULL;

      /* We have the first character of a fragment. */
      /* Make a config struct for this file entry   */

      new = malloc(sizeof(config));

      if (!new)
      {
        fclose(f);
        dprintf(("", "protocol_read_configuration: new is NULL, generating MEMORY_EXHAUSTED\n"));
        return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
      }

      memset(new, 0, sizeof(config));

      /* Link in at the head of the list */

      new->next = configs;
      configs   = new;

      /* Fill in the fragment */

      c = protocol_read_string(f, &temp);

      if (!temp)
      {
        fclose(f);
        protocol_free_configuration();
        dprintf(("", "protocol_read_configuration: temp is NULL (fragment), generating MEMORY_EXHAUSTED\n"));
        return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
      }

      new->fragment = temp;
      temp          = NULL;

      /* If we got EOF with 'temp' holding just a NUL byte the file just  */
      /* ended normally. If 'temp' holds something, the file is malformed */
      /* - any fragment should be followed by another entry (SWI base).   */

      if (c != EOF)
      {
        /* Didn't run out of file after reading the fragment, so go for the */
        /* SWI base now.                                                    */

        c = protocol_skip_white_space_and_comments(f);

        if (c != EOF)
        {
          c = protocol_read_string(f, &temp);

          if (!temp)
          {
            fclose(f);
            protocol_free_configuration();
            dprintf(("", "protocol_read_configuration: temp is NULL (SWI base), generating MEMORY_EXHAUSTED\n"));
            return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
          }

          new->swi_base = (int) strtoul(temp, NULL, 16);

          free(temp);
          temp = NULL;

          if (new->swi_base == 0)
          {
            fclose(f);
            protocol_free_configuration();
            dprintf(("", "protocol_read_configuration: SWI base is zero, generating INVALID_CONFIG\n"));
            return make_error(vc_ERROR_INVALID_CONFIG, 0);
          }
        }
        else
        {
          /* Ran out of file after reading some stuff, file is malformed */

          fclose(f);
          protocol_free_configuration();
          dprintf(("", "protocol_read_configuration: EOF after reading fragment and white space, generating INVALID_CONFIG\n"));
          return make_error(vc_ERROR_INVALID_CONFIG, 0);
        }
      }
      else if (*temp)
      {
        /* Ran out of file after reading some stuff, file is malformed */

        fclose(f);
        protocol_free_configuration();
        dprintf(("", "protocol_read_configuration: EOF after reading fragment, generating INVALID_CONFIG\n"));
        return make_error(vc_ERROR_INVALID_CONFIG, 0);
      }
    }
  }
  while (c != EOF);

  /* Finished */

  fclose(f);

  dprintf(("", "protocol_read_configuration: Successful\n"));

  return NULL;
}

/**************************************************************/
/* protocol_find_from_swi_base()                              */
/*                                                            */
/* Find a protocol struct for a registered protocol module    */
/* from a given SWI base.                                     */
/*                                                            */
/* Parameters: SWI base.                                      */
/*                                                            */
/* Returns:    Pointer to the protocol struct for the         */
/*             corresponding protocol module, or NULL if none */
/*             is found.                                      */
/**************************************************************/

static const protocol * protocol_find_from_swi_base(unsigned int swi_base)
{
  const protocol * proto;

  for (proto = protocols; proto; proto = proto->next)
  {
    if (proto->swi_base == swi_base) return proto;
  }

  return NULL;
}

/**************************************************************/
/* protocol_locate()                                          */
/*                                                            */
/* Work out what protocol module to use based on a given URL. */
/*                                                            */
/* Parameters: Pointer to the URL as a NUL terminated string; */
/*                                                            */
/*             Pointer to a protocol *, which is updated for  */
/*             either the protocol module to use or NULL if   */
/*             none is found.                                 */
/*                                                            */
/* Assumes:    Pointers are non-NULL and valid.               */
/**************************************************************/

static _kernel_oserror * protocol_locate(const char * url, const protocol ** found)
{
  const protocol * proto;
  const protocol * match  = NULL;
  unsigned int     count  = 0;
  const size_t     lenurl = strlen(url);

  dprintf(("", "protocol_locate: Called for '%s'\n", url ? url : "<NULL!>"));

  *found = NULL;

  for (proto = protocols; proto; proto = proto->next)
  {
    size_t protolen = strlen(proto->url_base);

    if (protolen == (lenurl + 1)) --protolen;

    if (!Strncmp_ci(proto->url_base, url, protolen))
    {
      if (!match) match = proto;
      count++;
    }
  }

  if (count == 0)
  {
    dprintf(("", "protocol_locate: Nothing found\n"));
    return NULL;
  }
  else if (count == 1)
  {
    dprintf(("", "protocol_locate: Found %p (%08x)\n", match, match->swi_base));

    *found = match;
    return NULL;
  }
  else
  {
    /* If we reach here there are multiple choices. Use the config file; */
    /* first off, have we read it?                                       */

    dprintf(("", "protocol_locate: Multiple choices\n"));

    if (configs == NULL)
    {
      _kernel_oserror * e = protocol_read_configuration();
      if (e) return e;
    }

    if (configs != NULL)
    {
      url_description * d;
      const config    * current;
      const protocol  * find = NULL;

      d = urlutils_return_description(url);

      if (!d)
      {
        dprintf(("", "protocol_locate: d is NULL, generating MEMORY_EXHAUSTED\n"));
        return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
      }

      /* Try and find an item */

      for (current = configs; current; current = current->next)
      {
        char * temp = Strdup(current->fragment);
        int    m;

        dprintf(("", "protocol_locate: Check %p ('%s', %08x)\n", current, current->fragment, current->swi_base));

        if (!temp)
        {
          urlutils_free_description(d);
          dprintf(("", "protocol_locate: d is NULL, generating MEMORY_EXHAUSTED\n"));
          return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
        }

        m = urlutils_matches_special(d, temp);
        free(temp);

        if (m)
        {
          const protocol * proto;

          dprintf(("", "protocol_locate: Found a match from config file, base %08x\n", current->swi_base));

          proto = protocol_find_from_swi_base(current->swi_base);

          /* There used to be a counter here, and the loop would run to completion. The  */
          /* code after would then check for multiple matches and complain of an invalid */
          /* config file. I later decided that this wasn't helpful behaviour, so I've    */
          /* gone for a first-match-with-module-loaded wins scheme. Of course, what is   */
          /* defined by "first" depends entirely on how the "configs" list is built...!  */

          if (proto && !find)
          {
            dprintf(("", "protocol_locate: The associated module is present, so using this match\n"));

            find = proto;
            break;
          }
        }
      }

      if (!find)
      {
        dprintf(("", "protocol_locate: No match from config file\n"));

        urlutils_free_description(d);
        return NULL;
      }
      else
      {
        /* We got one! */

        if (find)
        {
          unsigned int l1 = strlen(find->url_base);
          unsigned int l2 = strlen(d->protocol);

          dprintf(("", "protocol_locate: Exactly one match from config file, %p\n", find));
          dprintf(("", "protocol_locate: Compare found '%s' to URL '%s'\n", find->url_base, d->protocol));

          /* We have to ensure that the protocol matches too. The one from the */
          /* protocol module includes a ':', the one from the URL won't, hence */
          /* the check for string lengths as well as content.                  */

          if (
               (l1 - l2 == 1) &&
               (!Strncmp_ci(find->url_base, d->protocol, l2))
             )
          {
            dprintf(("", "protocol_locate: Match confirmed\n"));

            urlutils_free_description(d);
            *found = find;
            return NULL;
          }
          else
          {
            dprintf(("", "protocol_locate: Mismatch, generating METHOD_MISMATCH\n"));

            urlutils_free_description(d);
            return make_error(vc_ERROR_METHOD_MISMATCH, 0);
          }
        }
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* protocol_get_flags()                                       */
/*                                                            */
/* Get registration flags for a protocol based on URL.        */
/*                                                            */
/* Parameters: Pointer to the URL, NUL terminated.            */
/*                                                            */
/* Returns:    Registration flags, or default flags if the    */
/*             URL didn't lead to a protocol module being     */
/*             located.                                       */
/**************************************************************/

int protocol_get_flags(const char *url)
{
  const protocol * proto;

  (void) protocol_locate(url, &proto);

  return proto ? proto->flags : protocol_default_flags(url);
}

/**************************************************************/
/* Couple of dodgy direct SWI interface related functions ;-) */
/**************************************************************/

#ifdef DIRECTSWI

  static unsigned int protocol_find_swi_entry(const unsigned int result, const protocol * proto_r)
  {
    protocol *proto = (protocol *) proto_r;
    int mod = 0, inst = 0;

    if (proto->swientry == 0) for (;;) {
      int *base;
      void *pw;
      _kernel_oserror *e = _swix(OS_Module, _INR(0,2)|_OUTR(1,4), 12, mod, inst,
        &mod, &inst, &base, &pw);
           if (e) break;
           if (base[7] == (proto->swi_base & ~63) && base[8] != 0) {
             proto->private_word = pw;
             proto->swientry = (int)(((char *)base) + base[8]);
           }
    }

    return result;
  }

  _kernel_oserror *directswi_call(unsigned int swi, _kernel_swi_regs *in, _kernel_swi_regs *out)
  {
    protocol *proto;
    unsigned int swichunk = swi & ~15;

    for (proto = protocols; proto; proto = proto->next) {
      if (proto->swi_base == swichunk) {
        extern _kernel_oserror *directswi(void **pw, unsigned int addr,
          unsigned int swi, _kernel_swi_regs *, _kernel_swi_regs *);
        return directswi(&proto->private_word, proto->swientry, swi, in, out);
      }
    }

    return _kernel_swi(swi, in, out);
  }

#endif

/**************************************************************/
/* protocol_get_swi_base()                                    */
/*                                                            */
/* Given a URL, check to see if there's a protocol module     */
/* present that should be able to handle it. Uses the config  */
/* file if there is more than one protocol module present     */
/* using the same URL base, and can thus raise a variety of   */
/* errors related to that.                                    */
/*                                                            */
/* Parameters: Pointer to the URL to match;                   */
/*                                                            */
/*             Pointer to an unsigned int, in which the SWI   */
/*             base is written, or zero if there's no module  */
/*             found.                                         */
/*                                                            */
/* Assumes:    Pointers are non-NULL and valid.               */
/**************************************************************/

_kernel_oserror * protocol_get_swi_base(const char * url, unsigned int * swi_base)
{
  _kernel_oserror * e;
  const protocol  * proto;

  e = protocol_locate(url, &proto);
  if (e) return e;

  #ifdef DIRECTSWI
    *swi_base = protocol_find_swi_entry(result, proto);
  #else
    *swi_base = proto ? proto->swi_base : 0;
  #endif

  return NULL;
}

/**************************************************************/
/* protocol_free_protocols()                                  */
/*                                                            */
/* Free the list of all registered protocol modules.          */
/**************************************************************/

void protocol_free_protocols(void)
{
  protocol * curr = protocols;
  protocol * next;

  while (curr)
  {
    next = curr->next;

    free(curr->url_base);
    free(curr);

    curr = next;
  }

  protocols = NULL;
}

/**************************************************************/
/* protocol_list()                                            */
/*                                                            */
/* Implement *VideoControlProtoShow by listing details of     */
/* Video Control followed by all registered protocol modules  */
/* to stdout.                                                 */
/**************************************************************/

_kernel_oserror * protocol_list(void)
{
  _kernel_oserror * e;
  const char      * buffer = NULL;
  size_t            len;

  /* Get the header "Base URL  SWI base" etc. */

  e = read_message("PS01", &buffer, &len);

  if (e != NULL)
  {
    return e;
  }
  else
  {
    const protocol * proto;

    /* Print it - length-limit as we're using MessageTrans_Lookup */
    /* (albeit indirectly) in its "give us the buffer" mode, so   */
    /* the string is terminated by char 10 rather than NUL.       */

    printf("%.*s\n", len, buffer);

    /* Print 80 '=' signs (pre-assumes an 80 column or wider display) */

    for (len = 0; len < 8; ++len)
    {
      printf("==========");
    }

    printf("\n");

    /* The first line gives details of Video Control itself */

    printf("%-10s &%5X     %01d.%02d    %s\n",
           " --- ",
           VideoControl_00,
           Module_VersionNumber / 100,
           Module_VersionNumber % 100,
           Module_Help " © Pace 1999 (" Module_Date ")");

    /* If there are no protocol modules registered at all, report this  */
    /* after the Video Control stuff above. Otherwise list the modules. */

    if (protocols==NULL)
    {
      buffer = NULL;

      e = read_message("PS00", &buffer, &len);
      if (e != NULL) return e;

      printf("\n%.*s\n", len, buffer);
    }
    else
    {
      for (proto = protocols; proto; proto = proto->next)
      {
        printf("%-10s &%5X     %01d.%02d    %s\n",
               proto->url_base,
               proto->swi_base,
               proto->version / 100,
               proto->version % 100,
               proto->info);
      }
    }
  }

  return NULL;
}

#ifdef TRACE

  static char * filter(char * buf, const char * ptr, int max)
  {
    int i;

    for (i=0; i<=max; ++i)
    {
      int p = ptr[i];
      if (p<32 || p == 127) buf[i] = '.'; else buf[i] = p;
    }

    buf[i] = '\0';

    return buf;
  }

  void protocol_dump(const char * ptr, int size)
  {
    int ctr;
    char buf[48];

    dprintf(("", "%08x: ", 0));

    for (ctr=0; ctr<size; ++ctr)
    {
      dprintf(("", "%02x ", ptr[ctr]));

      if ((ctr & 31) == 31)
      {
        dprintf(("", "  %s", filter(buf, ptr+(ctr & ~31), ctr & 31)));
        dprintf(("", "\n%08x: ", ctr+1));
      }
    }

    if (ctr & 31)
    {
      const char * start = ptr + (ctr & ~31);

      while (ctr & 31)
      {
        dprintf(("", "   "));
        ++ctr;
      }
      dprintf(("", "  %s", filter(buf, start, (size & 31)-1)));
    }

    dprintf(("", "\n"));
  }

#endif /* #ifdef TRACE */

/**************************************************************/
/* Structure and functions to assign default behaviour.       */
/**************************************************************/

static struct proto_default_details
{
  const char * scheme;
  int          flags;
  unsigned int port_no;

} proto_default_setups[] = {
                             { "rtsp:",      0,                            5000 },
                         /*  { "nec:",       proto_I_HANDLE_MPEG,          0    }, (Hypothetically) */
                             { NULL,         0,                            0    }
                           };

/**************************************************************/
/* proto_find_default_settings()                              */
/*                                                            */
/* Return a pointer to the default settings for a given URL   */
/* method.                                                    */
/*                                                            */
/* Parameters: Pointer to the URL to work with; only the      */
/*             method part (including the ':') is actually of */
/*             interest.                                      */
/*                                                            */
/* Returns:    Pointer to an appropriate                      */
/*             proto_default_details struct (see above).      */
/**************************************************************/

static struct proto_default_details * proto_find_default_settings(const char * url)
{
  struct proto_default_details * proto;
  char                         * colon = strchr(url, ':');
  size_t                         length;

  if (!colon) colon = strchr(url, '\0') - 1;
  length = colon + 1 - url;
  if (length < 2) return 0;

  for (proto = proto_default_setups; proto->scheme; proto++)
  {
    if (strncmp(proto->scheme, url, length) == 0) return proto;
  }

  return proto;
}

/**************************************************************/
/* proto_find_default_flags()                                 */
/*                                                            */
/* Uses proto_find_default_settings to return default flags.  */
/*                                                            */
/* Parameters: As proto_find_default_settings.                */
/*                                                            */
/* Returns:    Default flags.                                 */
/**************************************************************/

static int protocol_default_flags(const char * url)
{
  struct proto_default_details * proto = proto_find_default_settings(url);
  return proto ? proto->flags : 0;
}

/**************************************************************/
/* proto_default_port_number()                                */
/*                                                            */
/* Uses proto_find_default_settings to return the default     */
/* port number.                                               */
/*                                                            */
/* Parameters: As proto_find_default_settings.                */
/*                                                            */
/* Returns:    Default port number.                           */
/**************************************************************/

static unsigned int protocol_default_port_number(const char * url)
{
  struct proto_default_details * proto = proto_find_default_settings(url);
  return proto ? proto->port_no : 0U;
}

/**************************************************************/
/* protocol_get_default_port()                                */
/*                                                            */
/* Find out the default port number for a protocol module,    */
/* based on a given URL.                                      */
/*                                                            */
/* Parameters: Pointer to the URL to examine.                 */
/*                                                            */
/* Returns:    Default port number.                           */
/**************************************************************/

unsigned int protocol_get_default_port(const char * url)
{
  const protocol * p;

  (void) protocol_locate(url, &p);

  if (p && p->port_no != 0) return p->port_no;
  else                      return protocol_default_port_number(url);
}
