/**************************************************************/
/* File:    Register.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement VideoControl_Register and               */
/*          VideoControl_Deregister.                          */
/*                                                            */
/* Author : A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 04-Nov-1999 (ADH): Created.                       */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "Module.h"
#include "Options.h"
#include "TearDown.h"
#include "Utils.h"

#include "Register.h"

/* Local functions */

static client * make_new_client    (_kernel_swi_regs * r);
static void     register_free_item (client * c);

/**************************************************************/
/* make_new_client()                                          */
/*                                                            */
/* Allocate and initialise a new client structure.            */
/*                                                            */
/* Parameters: Pointer to a register block. All preserved     */
/*             except R1, which is updated to hold the client */
/*             session ID.                                    */
/*                                                            */
/* Returns:    Pointer to the new client block, or NULL if    */
/*             the allocation failed.                         */
/**************************************************************/

static client * make_new_client(_kernel_swi_regs * r)
{
  client * c = malloc(sizeof(client));

  if (c == NULL) return c;

  memset(c, 0, sizeof(client));

  r->r[1] = (int) c;

  return c;
}

/**************************************************************/
/* register_register()                                        */
/*                                                            */
/* Implement VideoControl_Register. See the Video Control     */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * register_register(_kernel_swi_regs * r)
{
  client * newc = make_new_client(r);

  if (newc == NULL)
  {
    return make_error(vc_ERROR_MEMORY_EXHAUSTED, 0);
  }

  options_set_defaults(newc);

  if (client_list == NULL)
  {
    client_list = newc;
  }
  else
  {
    client * list;

    for (list = client_list; list->next; list = list->next) ;;

    list->next = newc;
  }

  return NULL;
}

/**************************************************************/
/* register_deregister()                                      */
/*                                                            */
/* Implement VideoControl_Deregister. See the Video Control   */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * register_deregister(_kernel_swi_regs * r)
{
  client * list = find_client(r->r[1]);

  if (list == NULL)
  {
    return make_error(vc_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  /* If we are in the middle of an operation, tear it down */

  if (list->ctrl.protocol != 0)
  {
    _kernel_swi_regs regs;

    regs.r[0] = 0;
    regs.r[1] = (int) list;

    (void) teardown_tear_down(&regs, VC_TearDown_IgnoreErrors);
  }

  if (client_list == list)
  {
    /* Special case - client at head of the list */

    client_list = client_list->next;
  }
  else
  {
    client * mainlist = client_list;

    /* Locate this element as a "next" entry for removal */

    for (mainlist = client_list; mainlist; mainlist = mainlist->next)
    {
      if (mainlist->next == list) break;
    }

    if (mainlist == NULL)
    {
      return make_error(vc_ERROR_CLIENT_ID_NOT_FOUND, 0);
    }

    mainlist->next = list->next;
  }

  /* We have now found the client we need to free up */

  register_free_item(list);
  return NULL;
}

/**************************************************************/
/* register_free_clients()                                    */
/*                                                            */
/* Free all client structures.                                */
/**************************************************************/

void register_free_clients(void)
{
  client * curr = client_list;
  client * next;

  while (curr)
  {
    next = curr->next;
    register_free_item(curr);
    curr = next;
  }

  client_list = NULL;
}

/**************************************************************/
/* register_free_item()                                       */
/*                                                            */
/* Free a specific client structure and all data hanging      */
/* from it.                                                   */
/*                                                            */
/* Parameters: Pointer to the client structure to free.       */
/*                                                            */
/* Assumes:    Pointer manipulation to keep any lists the     */
/*             item sits in consistent is taken care of       */
/*             elsewhere.                                     */
/**************************************************************/

static void register_free_item(client * c)
{
  if ((unsigned int) (c->modecopy) > 256) free(c->modecopy);
  free(c);
}
