/**************************************************************/
/* File:    Setup.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Setup.                           */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

#include <swis.h>
#include <AsmUtils/modulefp.h>

#include <socklib.h>
#include <inetlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h> /* Exported by VideoCtrl's !MkExport */

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "RTSPMErrors.h"
#include "Session.h"
#include "Status.h"
#include "URLutils.h"
#include "Utils.h"

#include "Setup.h"

/* Local functions */

static _kernel_oserror * setup_send_describe         (session * s);
static _kernel_oserror * setup_send_setup            (session * s);
static _kernel_oserror * setup_add_transport_header  (session * s);
static _kernel_oserror * setup_read_loop_option      (session * s, unsigned int vcid);
static void              setup_read_describe_doubles (session * s, const char * p1, const char * p2);

/**************************************************************/
/* setup_setup()                                              */
/*                                                            */
/* Implement RTSPMB_Setup. See the Video Control              */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * setup_setup(_kernel_swi_regs * r)
{
  _kernel_oserror * e;
  session         * s;
  char            * url;

  dprintf(("", "setup_setup: Called\n"));

  /* Just in case, make sure we're not already set up */

  if (session_find_by_id(r->r[1]) != NULL)
  {
    dprintf(("", "setup_setup: Already set up\n"));
    return make_error(rtspmb_ERROR_ALREADY_SETUP, 0);
  }

  /* Gain ourselves a session */

  e = session_new_session(&s);

  if (e != NULL)
  {
    dprintf(("", "setup_setup: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  if (s == NULL)
  {
    dprintf(("", "setup_setup: Out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  s->id   = ++id_counter; /* See Global.h */
  s->vcid = (unsigned int) r->r[1];

  /* Need to ask Video Control what the current loop setting is */

  e = setup_read_loop_option(s, s->vcid);

  if (e != NULL)
  {
    dprintf(("", "setup_setup: Error '%s' from setup_read_loop_option\n", e->errmess));
    session_free_item(s);
    return e;
  }

  /* Fill in the new item */

  if (r->r[2] != 0) url = (char *) r->r[2];
  else              url = "";

  e = urlutils_return_description(url, &s->url);

  if (e != NULL)
  {
    dprintf(("", "setup_setup: Error '%s' from urlutils_return_description\n", e->errmess));
    session_free_item(s);
    return e;
  }

  /* Annoyingly, we're delaying the SETUP command; so must take copies of */
  /* any user Transport header, extension headers or body data (R3-R6).   */

  free(s->setup_r3_record), s->setup_r3_record = NULL;
  free(s->setup_r4_record), s->setup_r4_record = NULL;
  free(s->setup_r5_record), s->setup_r5_record = NULL;
  s->setup_r6_record = 0;

  if (r->r[3] != 0)
  {
    s->setup_r3_record = Strdup((char *) r->r[3]);
    if (s->setup_r3_record == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  if (r->r[4] != 0)
  {
    s->setup_r4_record = Strdup((char *) r->r[4]);
    if (s->setup_r4_record == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  if (r->r[5] != 0 && r->r[6] != 0)
  {
    s->setup_r6_record = r->r[6];
    s->setup_r5_record = malloc(r->r[6]);

    if (s->setup_r5_record == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);

    memcpy(s->setup_r5_record, (void *) r->r[5], r->r[6]);
  }

  /* OK, send the DESCRIBE command */

  RetError(setup_send_describe(s)); /* This queues SETUP in passing */

  /* Don't forget to tell Video Control about our session handle */
  /* before returning                                            */

  r->r[1] = (int) s->id;

  return NULL;
}

/**************************************************************/
/* setup_send_describe()                                      */
/*                                                            */
/* Build a DESCRIBE command and start the state machine up in */
/* order to send it. A SETUP command is queued for sending    */
/* when the DESCRIBE response is received.                    */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which a DESCRIBE command needs */
/*             to be sent.                                    */
/**************************************************************/

static _kernel_oserror * setup_send_describe(session * s)
{
  bool fail = false;
  int  port;

  session_reset_session(s);

  if (s->url == NULL) fail = true;

  /* Add the DESCRIBE command */

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_Describe,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* Add sequence number */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Did anything fail (out of memory)? */

  if (fail)
  {
    dprintf(("", "setup_send_describe: Out of memory\n"));
    session_free_item(s);
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Need to get a socket open to the server. The call to opensock */
  /* will also initialise the state indicators within the session  */
  /* structure to allow the state machine to work.                 */

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  s->sd = opensock(s->url->host,
                   port,
                   NULL,
                   &s->state,
                   -1);

  s->last = utils_read_time();

  dprintf(("", "setup_send_describe: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Queue a SETUP command for next */

  s->next_command_cb = setup_send_setup;

  /* Set the state machine going to see errors and DNS stuff */

  if (s->callout_set == 0) /* It definitely should be, this is a brand new session! */
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* setup_send_setup()                                         */
/*                                                            */
/* Build a SETUP command and start the state machine up in    */
/* order to send it. If there is data in the session relating */
/* to a previous DESCRIBE command, this is parsed to get the  */
/* frames/sec and I-frames ratio values before resetting the  */
/* session ready for the SETUP command.                       */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which a SETUP command needs to */
/*             be sent.                                       */
/**************************************************************/

static _kernel_oserror * setup_send_setup(session * s)
{
  bool fail = false;
  int  port;

  /* Any DESCRIBE data to parse first? */

  if (s->data_len > 0)
  {
    char * ptr1 = strstr(s->data, Setup_FramesPerSecond);
    char * ptr2 = strstr(s->data, Setup_IFrameRatio);

    if (ptr1 != NULL && ptr2 != NULL)
    {
      modulefp_buf buf;

      modulefp_enable(&buf);

      setup_read_describe_doubles(s,
                                  ptr1 + sizeof(Setup_FramesPerSecond) - 1,
                                  ptr2 + sizeof(Setup_IFrameRatio)     - 1);

      modulefp_disable(&buf);
    }
  }

  /* Reset ready for the next command */

  session_reset_session(s);

  if (s->url == NULL) fail = true;

  /* Add the SETUP command */

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_Setup,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* Add sequence number */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  else
  {
    /* Get extra data from the client and store it. First, */
    /* the optional Transport entry.                       */

    if (s->setup_r3_record != 0)
    {
      if (
           headers_add_header(&s->headers,
                              Headers_HeaderName_Transport,
                              (const char *) s->setup_r3_record)
           == NULL
         )
         fail = true;

      free(s->setup_r3_record), s->setup_r3_record = NULL;
    }
    else
    {
      /* We find the local IP address to give in the Transport header */
      /* using getsockname on the socket - once it's connected. So,   */
      /* set the connection callback function to do just that.        */

      s->connected_cb = setup_add_transport_header;
    }

    /* Any extra stuff? */

    if (fail == false && s->setup_r4_record != 0)
    {
      headers_parse_user_header((char *) s->setup_r4_record, strlen((char *) s->setup_r4_record), s);

      free(s->setup_r4_record), s->setup_r4_record = NULL;
    }

    /* Support R5 and R6 body data extensions. OVS will object to anything */
    /* in the SETUP body right now, but in future it might not.            */

    if (s->setup_r5_record != 0 && s->setup_r6_record > 0)
    {
      rtsp_header * cl = headers_find_header(s->headers, Headers_HeaderName_ContentLength);

      s->data     = s->setup_r5_record, s->setup_r5_record = NULL;
      s->data_len = s->setup_r6_record, s->setup_r6_record = 0;

      /* If we have a Content-length header which is wrong, delete it.   */
      /* If we never have, or now have no Content-length header, add it. */

      if (cl != NULL && atoi(cl->value) != s->data_len)
      {
        headers_delete_header(&s->headers, cl);
        cl = NULL;
      }

      if (cl == NULL)
      {
        char number[16];

        sprintf(number, "%u", s->data_len);

        if (
             headers_add_header(&s->headers,
                                Headers_HeaderName_ContentLength,
                                number)
             == NULL
           )
           fail = true;
      }
    }
  }

  /* Did anything fail (out of memory)? */

  if (fail)
  {
    dprintf(("", "setup_send_setup: Out of memory\n"));
    session_free_item(s);
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Need to get a socket open to the server. The call to opensock */
  /* will also initialise the state indicators within the session  */
  /* structure to allow the state machine to work.                 */

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  s->sd = opensock(s->url->host,
                   port,
                   NULL,
                   &s->state,
                   -1);

  s->last = utils_read_time();

  dprintf(("", "setup_send_setup: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Ensure the command queue is cleared */

  s->next_command_cb = NULL;

  /* Set the state machine going to see errors and DNS stuff */

  if (s->callout_set == 0) /* It definitely should be, this is a brand new session! */
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* setup_add_transport_header()                               */
/*                                                            */
/* Add a Transport header to the headers in the given session */
/* just after the head item (assumes at least one header will */
/* be set up - the SETUP command itself, for example).        */
/*                                                            */
/* This is done on the basis of getsockname for the socket    */
/* held by the session (so you must have connected to a       */
/* server). The function is intended as a state machine       */
/* socket connection callback handler.                        */
/*                                                            */
/* Parameters: Pointer to the session struct.                 */
/**************************************************************/

static _kernel_oserror * setup_add_transport_header(session * s)
{
  struct sockaddr_in name;
  int                namelen = sizeof(name);

  dprintf(("", "setup_add_transport_header: Called for %p\n", s));

  /* Use getsockname to get our IP address for the destination part */
  /* of the Transport header, and add it in.                        */

  if (getsockname(s->sd, (struct sockaddr *) (&name), &namelen) >= 0)
  {
    bool          fail = false;
    char        * value;
    char        * ip;

    ip = inet_ntoa(name.sin_addr);

    dprintf(("", "setup_add_transport_header: Our IP address is %s\n", ip));

    /* Construct the value. 11 is for adding ";port=<port>". */

    value = malloc(strlen(ip) + 11 + sizeof(Headers_HeaderValue_Transport));

    if (value == NULL) fail = true;
    else
    {
      /* Compile the full header value, including port */

      char * port = getenv(Headers_UDP_Port);

      if (!port || !*port) sprintf(value, "%s%s",         Headers_HeaderValue_Transport, ip);
      else                 sprintf(value, "%s%s;port=%s", Headers_HeaderValue_Transport, ip, port);

      /* Add the new header */

      if (
           headers_add_header(&s->headers,
                              Headers_HeaderName_Transport,
                              value)
           == NULL
         )
      {
        fail = true;
      }
    }

    free(value);

    /* Handle failure, else the headers are all assembled correctly now. */

    if (fail)
    {
      dprintf(("", "setup_add_transport_header: Failed (out of memory)\n"));

      return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
    }
  }

  dprintf(("", "setup_add_transport_header: Finished\n"));

  return NULL;
}

/**************************************************************/
/* setup_read_loop_option()                                   */
/*                                                            */
/* Find out whether looping is switched on using              */
/* VideoControl_Options and write the result into the given   */
/* session's 'loop' field.                                    */
/*                                                            */
/* Parameters: Pointer to a session struct to update;         */
/*                                                            */
/*             Video Control client ID to use.                */
/**************************************************************/

static _kernel_oserror * setup_read_loop_option(session * s, unsigned int vcid)
{
  _kernel_oserror * e;
  int               opts[4];

  opts[0] = vc_tags_looping;
  opts[1] = 1;
  opts[2] = 0;
  opts[3] = vc_tags__end;

  e = _swix(VideoControl_ProtocolOptions,
            _INR(0,2),

            0,
            vcid,
            opts);

  if (e == NULL) s->loop = !!opts[2];

  return e;
}

/**************************************************************/
/* setup_read_describe_doubles()                              */
/*                                                            */
/* Read the frames/sec and I-frames ratio from a DESCRIBE     */
/* response as doubles in the relevant fields of the given    */
/* session structure.                                         */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session struct to update;       */
/*                                                            */
/*             Pointer to the first character of the frames   */
/*             per second value;                              */
/*                                                            */
/*             Pointer to the first character of the frames   */
/*             to I-frames ratio value.                       */
/*                                                            */
/* Returns:    The 'frames_per_sec' and 'i_frame_ratio'       */
/*             fields of the session structure are updated.   */
/**************************************************************/

static void setup_read_describe_doubles(session * s, const char * p1, const char * p2)
{
  s->frames_per_sec = strtod(p1, NULL);
  s->i_frame_ratio  = strtod(p2, NULL);

  if (s->frames_per_sec == HUGE_VAL) s->frames_per_sec = 0;
  if (s->i_frame_ratio  == HUGE_VAL) s->i_frame_ratio  = 0;
}
