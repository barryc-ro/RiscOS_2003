/**************************************************************/
/* File:    Setup.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Setup.                           */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/*          08-Mar-2002 (JRB): Updated for MediaBase 6.       */
/*          01-Apr-2002 (JRB): Updated to support sequences   */
/*                             and authorisation.             */
/*          31-May-2002 (JRB): Updated to support MediaBase   */
/*                             6.0.1, near-line storage and   */
/*                             audio-only assets.             */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

#include <swis.h>
#include <AsmUtils/modulefp.h>

#include <socklib.h>
#include <inetlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h> /* Exported by VideoCtrl's !MkExport */

#include "AMPlay.h"
#include "Auth.h"
#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "RTSPMErrors.h"
#include "Session.h"
#include "Status.h"
#include "URLutils.h"
#include "Utils.h"

#include "Setup.h"

/* Local functions */

static _kernel_oserror * setup_send_describe         (session * s);
static _kernel_oserror * setup_describe_done         (session * s);
static bool              setup_read_asset_data       (mb_asset_types type, const char * data, asset_data * asset);
static _kernel_oserror * setup_send_setup            (session * s, const char * auth_value);
static _kernel_oserror * setup_add_transport_header  (session * s);
static _kernel_oserror * setup_setup_done            (session * s);
static _kernel_oserror * setup_send_set_parameter    (session * s);
static void              setup_read_describe_doubles (asset_data * asset, const char * p1, const char * p2);
#ifdef CLIENT_LOOPING
static _kernel_oserror * setup_read_loop_option      (session * s, unsigned int vcid);
#endif

/**************************************************************/
/* setup_setup()                                              */
/*                                                            */
/* Implement RTSPMB_Setup. See the Video Control              */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * setup_setup(_kernel_swi_regs * r)
{
  _kernel_oserror * e;
  session         * s;
  char            * url;
  bool            fail = false;

  dprintf(("Entry_0", "setup_setup: Called\n"));
  dprintf(("Entry_1", " r0=%x\n",r->r[0]));
  dprintf(("Entry_1", " r1=%x\n",r->r[1]));
  dprintf(("Entry_1", " r2='%s'\n",r->r[2] ? (char *)r->r[2] : "NULL"));
  dprintf(("Entry_1", " r3='%s'\n",r->r[3] ? (char *)r->r[3] : "NULL"));
  dprintf(("Entry_1", " r4='%s'\n",r->r[4] ? (char *)r->r[4] : "NULL"));
  dprintf(("Entry_1", " r5=%x\n",r->r[5]));
  dprintf(("Entry_1", " r6=%x\n",r->r[6]));
  dprintf(("Entry_1", " r7=%x\n",r->r[7]));

  /* Just in case, make sure we're not already set up */

  if (session_find_by_id(r->r[1]) != NULL)
  {
    dprintf(("", "setup_setup: Already set up\n"));
    return make_error(rtspmb_ERROR_ALREADY_SETUP, 0);
  }

  /* Gain ourselves a session */

  e = session_new_session(&s);

  if (e != NULL)
  {
    dprintf(("", "setup_setup: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  if (s == NULL)
  {
    dprintf(("", "setup_setup: Out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  s->id   = ++id_counter; /* See Global.h */
  s->vcid = (unsigned int) r->r[1];

  #ifdef CLIENT_LOOPING
  /* Need to ask Video Control what the current loop setting is */

  e = setup_read_loop_option(s, s->vcid);

  if (e != NULL)
  {
    dprintf(("", "setup_setup: Error '%s' from setup_read_loop_option\n", e->errmess));
    session_free_item(s);
    return e;
  }
  #endif

  /* Fill in the new item */

  if (r->r[2] != 0) url = (char *) r->r[2];
  else              url = "";

  e = urlutils_return_description(url, &s->url);

  if (e != NULL)
  {
    dprintf(("", "setup_setup: Error '%s' from urlutils_return_description\n", e->errmess));
    session_free_item(s);
    return e;
  }

  /* If a user name and/or password was specified in the URL, copy it into */
  /* the session data and remove it from the URL.                          */

  if (s->url->user != NULL && *s->url->user != 0)
  {
    s->user = Strdup(s->url->user);
    if (s->user == NULL)
      fail = true;
    else
      urlutils_unescape(s->user);
  }

  if (s->url->password != NULL && *s->url->password != 0)
  {
    s->password = Strdup(s->url->password);
    if (s->password == NULL)
      fail = true;
    else
      urlutils_unescape(s->password);
  }

  if (s->user != NULL || s->password != NULL)
  {
    char * p1, * p2;

    p1 = strstr(s->url->full, ProtocolSeparator);
    p2 = strchr(s->url->full, '@');

    if (p1 != NULL && p2 != NULL)
    {
      p1 += sizeof(ProtocolSeparator) - 1;
      p2++;
      memmove(p1, p2, strlen(p2) + 1);
    }
  }

  /* Simulated multicast? */

  if (
       s->url->path                                     != NULL &&
       strstr(s->url->path, Header_SimMulticastDetect1) != NULL &&
       strstr(s->url->path, Header_SimMulticastDetect2) != NULL
     )
     s->multicast = 1;

  /* Annoyingly, we're delaying the SETUP command; so must take copies of */
  /* any user Transport header, extension headers or body data (R3-R6).   */

  free(s->setup_r3_record), s->setup_r3_record = NULL;
  free(s->setup_r4_record), s->setup_r4_record = NULL;
  free(s->setup_r5_record), s->setup_r5_record = NULL;
  s->setup_r6_record = 0;

  if (r->r[3] != 0)
  {
    s->setup_r3_record = Strdup((char *) r->r[3]);
    if (s->setup_r3_record == NULL)
      fail = true;
  }

  if (r->r[4] != 0)
  {
    s->setup_r4_record = Strdup((char *) r->r[4]);
    if (s->setup_r4_record == NULL)
      fail = true;
  }

  if (r->r[5] != 0 && r->r[6] != 0)
  {
    s->setup_r6_record = r->r[6];
    s->setup_r5_record = malloc(r->r[6]);

    if (s->setup_r5_record == NULL)
      fail = true;
    else
      memcpy(s->setup_r5_record, (void *) r->r[5], r->r[6]);
  }

  if (fail)
  {
    /* Memory allocation failure */

    dprintf(("", "setup_setup: Out of memory\n"));
    e = make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }
  else
  {
    /* OK, send the DESCRIBE command */
  
    e = setup_send_describe(s); /* This queues SETUP in passing */
  }

  if (e == NULL)
  {
    /* Don't forget to tell Video Control about our session handle */
    /* before returning                                            */
  
    r->r[1] = (int) s->id;
  }
  else
  {
    /* Failed - discard session and return error */

    session_free_item(s);
  }

  return e;
}

/**************************************************************/
/* setup_send_describe()                                      */
/*                                                            */
/* Build a DESCRIBE command and start the state machine up in */
/* order to send it. A SETUP command is queued for sending    */
/* when the DESCRIBE response is received.                    */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which a DESCRIBE command needs */
/*             to be sent.                                    */
/**************************************************************/

static _kernel_oserror * setup_send_describe(session * s)
{
  bool fail = false;

  session_reset_session(s);

  if (s->url == NULL) fail = true;

  /* Add the DESCRIBE command */

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_Describe,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* Add sequence number */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Did anything fail (out of memory)? */

  if (fail)
  {
    dprintf(("", "setup_send_describe: Out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Queue the routine that checks the DESCRIBE response */

  s->next_command_cb = setup_describe_done;

  /* Send the DESCRIBE command to the server */

  return status_send(s);
}

/**************************************************************/
/* setup_describe_done()                                      */
/*                                                            */
/* This is called when the response to the DESCRIBE command   */
/* is received. It parses the DESCRIBE response, then builds  */
/* the SETUP command that gets issued next.                   */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which a SETUP command needs to */
/*             be sent.                                       */
/**************************************************************/

static _kernel_oserror * setup_describe_done(session * s)
{
  rtsp_header * sver;
  bool          success = false;

  /* Clear the command chain */

  s->next_command_cb = NULL;

  /* If the DESCRIBE response was an error, give up now and return this */
  /* status to the caller.                                              */

  if (s->response_code != 200)
    return NULL;

  /* First see if the server told us its version number in the DESCRIBE response */

  s->server_version = 0;

  sver = headers_find_header(s->headers, Headers_HeaderName_Server);
  if (sver != NULL)
  {
    if (!strcmp(sver->value, Headers_HeaderValue_ServerOld))
    {
      /* This is MediaBase 5 or earlier */
      s->server_version = 0x050000;
    }
    else if (!strncmp(sver->value, Headers_HeaderValue_ServerNew, sizeof(Headers_HeaderValue_ServerNew) - 1))
    {
      char * ptr = sver->value + sizeof(Headers_HeaderValue_ServerNew) - 1;

      /* This is MediaBase 6 (XMP) or later - get major version number, ignore minor version for now */
      s->server_version = (int)strtol(ptr, &ptr, 10) << 16;
      if (*ptr == '.')
      {
        s->server_version |= (int)strtol(ptr + 1, &ptr, 10) << 8;
        if (*ptr == '.')
          s->server_version |= (int)strtol(ptr + 1, &ptr, 10);
      }
    }
  }
  dprintf(("", "Server version determined as 0x%x\n", s->server_version));

  if (s->server_version < 0x050000)
    return make_error(rtspmb_ERROR_UNKNOWN_VERSION, 0);

  /* Parse DESCRIBE response first */

  if (s->data_len > 0)
  {
    char * ptr;
    char * ptr2;

    /* Determine asset type. This must be the same for all assets in a */
    /* sequence, so we only read it once, not per asset.               */

    s->asset_type = assettype_UNKNOWN;

    ptr = strstr(s->data, Setup_Type);
    if (ptr != NULL)
    {
      ptr += sizeof(Setup_Type) - 1;
      if (!strncmp(ptr, Setup_TypeMPEG1, sizeof(Setup_TypeMPEG1) - 1))
        s->asset_type = assettype_MPEG1;
      else if (!strncmp(ptr, Setup_TypeMPEG2, sizeof(Setup_TypeMPEG2) - 1))
        s->asset_type = assettype_MPEG2;
      else if (!strncmp(ptr, Setup_TypeMPEG1Audio, sizeof(Setup_TypeMPEG1Audio) - 1))
        s->asset_type = assettype_MPEG1Audio;
    }
  
    /* Return an error if we did not recognise the asset type */
  
    if (s->asset_type == assettype_UNKNOWN)
      return make_error(rtspmb_ERROR_UNSUPPORTED_TYPE, 0);

    /* Read asset play modes flags. These must be the same for all assets */
    /* in a sequence, so we only read these once, not per asset.          */

    ptr = strstr(s->data, Setup_PlayModes);
    if (ptr != NULL)
    {
      ptr += sizeof(Setup_PlayModes) - 1;
      s->play_modes = atoi(ptr);
    }

    /* See whether the asset is a backing store (near-line) asset that */
    /* is currently offline. If it isn't explicitly marked as such     */
    /* we assume that it is available online.                          */

    s->online = 1;

    ptr  = strstr(s->data, Setup_BackingStore);
    ptr2 = strstr(s->data, Setup_Online);
  
    if (ptr != NULL && ptr2 != NULL)
    {
      if (
          atoi(ptr  + sizeof(Setup_BackingStore) - 1) == 1 &&
          atoi(ptr2 + sizeof(Setup_Online) - 1)       != 1
         )
        s->online = 0;
    }

    /* See how many assets there are in the sequence */

    ptr = strstr(s->data, Setup_NumStreams);

    if (ptr != NULL)
      s->num_assets = atoi(ptr + sizeof(Setup_NumStreams) - 1);

    if (s->num_assets > 0)
    {
      char * next_ptr;
      int    i;
  
      /* Allocate asset data array */

      s->assets = calloc(s->num_assets, sizeof(asset_data));
      if (s->assets == NULL)
        return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);

      /* Read information on each asset */

      ptr = strstr(ptr, Setup_MediaStreams);
      if (ptr != NULL)
        ptr = strstr(ptr + 1, Setup_MediaStream);

      success = true;

      for (i = 0; i < s->num_assets && ptr != NULL && success; i++)
      {
        /* Find start of next asset description */

        next_ptr = strstr(ptr + 1, Setup_MediaStream);

        /* Read the asset data */

        if (next_ptr != NULL)
          *next_ptr = 0;

        success = setup_read_asset_data(s->asset_type, ptr, &s->assets[i]);

        if (next_ptr != NULL)
          *next_ptr++ = Setup_MediaStream[0];

        /* Adjust the start offset for the position in the sequence */

        s->assets[i].start_offset += s->duration;

        /* Update the total duration */

        s->duration += s->assets[i].duration;

        ptr = next_ptr;

        dprintf(("", "Data for asset %d:\n", i));
        dprintf(("", " approx_fps      = %d\n", s->assets[i].approx_fps));
        dprintf(("", " duration        = %u\n", s->assets[i].duration));
        dprintf(("", " parent_duration = %u\n", s->assets[i].parent_duration));
        dprintf(("", " start_offset    = %d\n", s->assets[i].start_offset));
      }

      dprintf(("", "Total duration=%u\n", s->duration));
      dprintf(("", "PlayModes flags=0x%x\n", s->play_modes));

      /* Make sure we got information for all of the assets */

      if (i < s->num_assets)
        success = false;
    }
  }

  /* Return an error if we failed to read all the data we need */

  if (!success)
    return make_error(rtspmb_ERROR_BAD_DESCRIBE_RESPONSE, 0);

  /* Is the stream going to contain NPT Reference Descriptors and End of  */
  /* Stream markers? Yes, if this is MediaBase 6.0.1 or later, an MPEG-2  */
  /* asset, it was not installed as 'play only', and this is not a        */
  /* simulated multicast.                                                 */

  if (
      s->server_version >= 0x060001 &&
      s->asset_type == assettype_MPEG2 &&
      s->multicast == 0 &&
      ((s->play_modes & (Setup_PlayModes_RepositionToStartDisabled | Setup_PlayModes_RandomRepositionDisabled)) == 0)
     )
  {
    _kernel_oserror * e;
    unsigned int      vc_clear, vc_eor, ctrl_clear, ctrl_eor;

    /* Yes, we will have stream markers */

    s->stream_markers = 1;

    /* Tell VideoControl to use different protocol and open stream flags */

    vc_clear   = VC_ProtocolRegister_ReportTimeoutAsEOS;
    vc_eor     = 0;
    ctrl_clear = MPEGCtrl_MCOS_EnableOVSTrickPlay |
                 MPEGCtrl_MCOS_AutoReset;
    ctrl_eor   = ctrl_clear;

    e = _swix(VideoControl_ProtocolNotify,
              _INR(0,7),
        
              0,
              s->id,
              VideoControlProtocolNotifyNewProtocolFlags,
              VC_ProtocolNotify_NewProtocolFlags_UpdateSession,
              vc_clear,
              vc_eor,
              ctrl_clear,
              ctrl_eor);

    if (e != NULL)
      return e;

    dprintf(("", "setup_describe_done: Expecting EOS and NPT Reference Descriptors\n"));
  }

  /* Is the stream an audio-only one? */

  if (s->asset_type == assettype_MPEG1Audio)
  {
    _kernel_oserror * e;
    int               opts[4];

    /* MPEG1 audio-only asset - set the option to disable video */

    opts[0] = vc_tags_audio_only;
    opts[1] = 1;
    opts[2] = 1;
    opts[3] = vc_tags__end;
  
    e = _swix(VideoControl_Options,
              _INR(0,2),
  
              0,
              s->vcid,
              opts);

    if (e != NULL)
      return e;

    #ifdef USE_AMPLAYER

    /* Is AMPlayer module present? */

    if (amplay_check())
    {
      unsigned int  vc_clear, vc_eor;

      s->using_amplayer = 1;

      /* We're using AMPlayer - tell VideoControl we're going to do */
      /* everything ourselves.                                      */
  
      vc_clear   = 0xffffffff;
      vc_eor     = VC_ProtocolRegister_IHandleMPEG;

      e = _swix(VideoControl_ProtocolNotify,
                _INR(0,7),
          
                0,
                s->id,
                VideoControlProtocolNotifyNewProtocolFlags,
                VC_ProtocolNotify_NewProtocolFlags_UpdateSession,
                vc_clear,
                vc_eor,
                0,
                0);
  
      if (e != NULL)
        return e;
  
      dprintf(("", "setup_describe_done: Use AMPlayer - do all MPEG handling\n"));

      /* Do the necessary initialisation */

      RetError(amplay_init());

      /* Set the initial volume level */

      RetError(amplay_set_volume(s));
    }
    #endif
  }

  /* Success - now send the SETUP */

  return setup_send_setup(s, NULL);
}

/**************************************************************/
/* setup_read_asset_data()                                    */
/*                                                            */
/* Read information about an asset from the DESCRIBE response */
/* into an asset_data structure.                              */
/*                                                            */
/* Parameters: Type of asset for which information is being   */
/*             read.                                          */
/*                                                            */
/*             Pointer to the string containing a description */
/*             of the asset;                                  */
/*                                                            */
/*             Pointer to the asset_data structure to be      */
/*             filled in.                                     */
/*                                                            */
/* Returns:    Whether or not all the data was successfully   */
/*             read.                                          */
/**************************************************************/

static bool setup_read_asset_data(mb_asset_types type, const char * data, asset_data * asset)
{
  char * ptr1;
  char * ptr2;

  /* Store duration (originally in microseconds) to centisecond resolution */
  
  ptr1 = strstr(data, Setup_Duration);
  if (ptr1 != NULL)
    asset->duration = (unsigned int) (strtoul(ptr1 + sizeof(Setup_Duration) - 1, NULL, 10) / 10000);
  else
    return false;

  /* Duration is the only item of interest for an audio-only asset */

  if (type == assettype_MPEG1Audio)
    return true;
  
  /* Store parent duration (originally in microseconds) to centisecond resolution */
  /* This is only present for clip assets, and only on MediaBase 6 or later */

  ptr1 = strstr(data, Setup_ParentDuration);
  if (ptr1 != NULL)
    asset->parent_duration = (unsigned int) (strtoul(ptr1 + sizeof(Setup_ParentDuration) - 1, NULL, 10) / 10000);
  else
    asset->parent_duration = asset->duration;

  /* Read items with floating point values */

  ptr1 = strstr(data, Setup_FramesPerSecond);
  ptr2 = strstr(data, Setup_IFrameRatio);

  if (ptr1 != NULL && ptr2 != NULL)
  {
    modulefp_buf buf;
  
    modulefp_enable(&buf);
  
    setup_read_describe_doubles(asset,
                                ptr1 + sizeof(Setup_FramesPerSecond) - 1,
                                ptr2 + sizeof(Setup_IFrameRatio)     - 1);
  
    modulefp_disable(&buf);
  }
  else
  {
    return false;
  }

  /* Store start time (originally in microseconds) to centisecond resolution */
  
  ptr1 = strstr(data, Setup_StartTime);
  if (ptr1 != NULL)
    asset->start_offset = -(atoi(ptr1 + sizeof(Setup_StartTime) - 1) / 10000);
  else
    return false;

  /* Check we got all the things we expect */

  if (
      asset->approx_fps      == 0 ||
      asset->duration        == 0 ||
      asset->parent_duration == 0
     )
    return false;

  return true;
}

/**************************************************************/
/* setup_send_setup()                                         */
/*                                                            */
/* Build a SETUP command and start the state machine up in    */
/* order to send it.                                          */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which a SETUP command needs to */
/*             be sent.                                       */
/**************************************************************/

static _kernel_oserror * setup_send_setup(session * s, const char * auth_value)
{
  bool fail = false;

  /* Reset ready for the next command */

  session_reset_session(s);

  if (s->url == NULL) fail = true;

  /* Add the SETUP command */

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_Setup,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* Add sequence number */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  else
  {
    /* Get extra data from the client and store it. First, */
    /* the optional Transport entry.                       */

    if (s->setup_r3_record != 0)
    {
      if (
           headers_add_header(&s->headers,
                              Headers_HeaderName_Transport,
                              (const char *) s->setup_r3_record)
           == NULL
         )
         fail = true;

      free(s->setup_r3_record), s->setup_r3_record = NULL;
    }
    else
    {
      /* We find the local IP address to give in the Transport header */
      /* using getsockname on the socket - once it's connected. So,   */
      /* set the connection callback function to do just that.        */

      s->connected_cb = setup_add_transport_header;
    }

    /* Any extra stuff? */

    if (fail == false && s->setup_r4_record != 0)
    {
      headers_parse_user_header((char *) s->setup_r4_record, strlen((char *) s->setup_r4_record), s);

      free(s->setup_r4_record), s->setup_r4_record = NULL;
    }

    /* Authorisation header? */

    if (fail == false && auth_value != NULL)
    {
      if (
           headers_add_header(&s->headers,
                              Headers_HeaderName_Authorization,
                              auth_value)
           == NULL
         )
         fail = true;
    }

    /* Session header? (will only exist for authorisation retries) */
  
    if (fail == false && s->server_session != NULL)
    {
      if (
           headers_add_header(&s->headers,
                              Headers_HeaderName_Session,
                              s->server_session)
           == NULL
         )
         fail = true;
    }

    /* Support R5 and R6 body data extensions. OVS will object to anything */
    /* in the SETUP body right now, but in future it might not.            */

    if (s->setup_r5_record != 0 && s->setup_r6_record > 0)
    {
      rtsp_header * cl = headers_find_header(s->headers, Headers_HeaderName_ContentLength);

      s->data     = s->setup_r5_record, s->setup_r5_record = NULL;
      s->data_len = s->setup_r6_record, s->setup_r6_record = 0;

      /* If we have a Content-length header which is wrong, delete it.   */
      /* If we never have, or now have no Content-length header, add it. */

      if (cl != NULL && atoi(cl->value) != s->data_len)
      {
        headers_delete_header(&s->headers, cl);
        cl = NULL;
      }

      if (cl == NULL)
      {
        char number[16];

        sprintf(number, "%u", s->data_len);

        if (
             headers_add_header(&s->headers,
                                Headers_HeaderName_ContentLength,
                                number)
             == NULL
           )
           fail = true;
      }
    }
  }

  /* Did anything fail (out of memory)? */

  if (fail)
  {
    dprintf(("", "setup_send_setup: Out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Queue the routine that checks the SETUP response */

  s->next_command_cb = setup_setup_done;

  /* Send the SETUP command to the server */

  return status_send(s);
}

/**************************************************************/
/* setup_add_transport_header()                               */
/*                                                            */
/* Add a Transport header to the headers in the given session */
/* just after the head item (assumes at least one header will */
/* be set up - the SETUP command itself, for example).        */
/*                                                            */
/* This is done on the basis of getsockname for the socket    */
/* held by the session (so you must have connected to a       */
/* server). The function is intended as a state machine       */
/* socket connection callback handler.                        */
/*                                                            */
/* Parameters: Pointer to the session struct.                 */
/**************************************************************/

static _kernel_oserror * setup_add_transport_header(session * s)
{
  struct sockaddr_in name;
  int                namelen = sizeof(name);

  dprintf(("", "setup_add_transport_header: Called for %p\n", s));

  /* Use getsockname to get our IP address for the destination part */
  /* of the Transport header, and add it in.                        */

  if (getsockname(s->sd, (struct sockaddr *) (&name), &namelen) >= 0)
  {
    bool          fail = false;
    char        * value;
    char        * ip;

    ip = inet_ntoa(name.sin_addr);

    dprintf(("", "setup_add_transport_header: Our IP address is %s\n", ip));

    /* Construct the value. 11 is for adding ";port=<port>". */

    value = malloc(strlen(ip) + 11 + sizeof(Headers_HeaderValue_Transport));

    if (value == NULL) fail = true;
    else
    {
      /* Compile the full header value, including port */

      char * port = getenv(Headers_UDP_Port);

      s->stream_port = atoi(port);

      if (!port || !*port) sprintf(value, "%s%s",         Headers_HeaderValue_Transport, ip);
      else                 sprintf(value, "%s%s;port=%s", Headers_HeaderValue_Transport, ip, port);

      /* Add the new header */

      if (
           headers_add_header(&s->headers,
                              Headers_HeaderName_Transport,
                              value)
           == NULL
         )
      {
        fail = true;
      }
    }

    free(value);

    /* Handle failure, else the headers are all assembled correctly now. */

    if (fail)
    {
      dprintf(("", "setup_add_transport_header: Failed (out of memory)\n"));

      return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
    }
  }

  dprintf(("", "setup_add_transport_header: Finished\n"));

  return NULL;
}

/**************************************************************/
/* setup_setup_done()                                         */
/*                                                            */
/* This is called when the response to the SETUP command is   */
/* received.                                                  */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which the SETUP command was    */
/*             sent.                                          */
/**************************************************************/

static _kernel_oserror * setup_setup_done(session * s)
{
  _kernel_oserror * e = NULL;

  dprintf(("", "setup_setup_done: Response was %d\n", s->response_code));

  /* No more commands to chain */

  s->next_command_cb = NULL;

  /* What was the response code? */

  switch (s->response_code)
  {
    case 200: /* OK */
    {
      rtsp_header * transport;
      char        * ptr;

      /* Look at the Transport header in the response */

      s->stream_src.s_addr = (u_int32_t)htonl(INADDR_ANY);  /* Pointless cast to avoid compiler warning */

      transport = headers_find_header(s->headers, Headers_HeaderName_Transport);
      if (transport != NULL)
      {
        /* Look for the port number in the setup response. This should be the */
        /* same as the port number we asked for, but you can never be sure... */

        ptr = strstr(transport->value, Headers_HeaderValue_TransportPort);
        if (ptr != NULL)
          s->stream_port = atoi(ptr + sizeof(Headers_HeaderValue_TransportPort) - 1);

        /* Look for the source IP address. This is not currently used. */

        ptr = strstr(transport->value, Headers_HeaderValue_TransportSrc);
        if (ptr != NULL)
        {
          char * ptr2;

          ptr = ptr + sizeof(Headers_HeaderValue_TransportSrc) - 1;
          ptr2 = strchr(ptr, ';');

          if (ptr2 != NULL)
            *ptr2 = 0;

          if (!inet_aton(ptr, &s->stream_src))
            s->stream_src.s_addr = (u_int32_t)htonl(INADDR_ANY);  /* Pointless cast to avoid compiler warning */

          if (ptr2 != NULL)
            *ptr2 = ';';
        }
      }

      /* Is the asset on-line? */

      if (s->online == 0)
      {
        /* The SETUP succeeded, but this asset is an offline backing store      */
        /* asset (e.g. one on a CD jukebox, or delivered from a central server  */
        /* by the MediaBase Content Distribution mechanism), so we have to send */
        /* a SET_PARAMETER command to tell the server to load it.               */
    
        dprintf(("", "setup_setup_done: Time to load a backing store asset\n"));
        e = setup_send_set_parameter(s);
      }

      break;
    }

    case 401: /* Unauthorised */
    {
      rtsp_header * challenge;
      char        * auth_value = NULL;

      /* We had an Unauthorised error. Do we have a user name or password? */
    
      if (s->user == NULL && s->password == NULL)
        return NULL;
    
      /* Do we have a challenge? */
    
      challenge = headers_find_header(s->headers, Headers_HeaderName_Authenticate);
    
      if (challenge == NULL)
        return NULL;
    
      /* Generate a response to the challenge */
    
      e = auth_generate_response(challenge->value, s->user, s->password, s->url->path, &auth_value);
      if (e == NULL && auth_value != NULL)
      {
        /* Now clear the username and password. This will stop us retrying */
        /* again if we get another 401 error because they were incorrect.  */
    
        free (s->user);
        s->user = NULL;
    
        free (s->password);
        s->password = NULL;
    
        /* Send the SETUP again, with the authorisation header. */
    
        e = setup_send_setup(s, auth_value);
        free (auth_value);
      }

      break;
    }
  }

  return e;
}

/**************************************************************/
/* setup_send_set_parameter()                                 */
/*                                                            */
/* Build a SET_PARAMETER command and start the state machine  */
/* up in order to send it.                                    */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which a SET_PARAMETER command  */
/*             needs to be sent.                              */
/**************************************************************/

static _kernel_oserror * setup_send_set_parameter(session * s)
{
  /* Reset ready for the next command */

  session_reset_session(s);

  /* Build the SET_PARAMETER command */

  RetError(setup_build_set_parameter(s));

  /* Clear the command chain - response returned to client */

  s->next_command_cb = NULL;

  /* Send the SET_PARAMETER command to the server */

  return status_send(s);
}

/**************************************************************/
/* setup_build_set_parameter()                                */
/*                                                            */
/* Build a SET_PARAMETER command inside the given session.    */
/*                                                            */
/* Parameters: Pointer to the session structure representing  */
/*             the session for which a SET_PARAMETER command  */
/*             needs to be sent.                              */
/**************************************************************/

_kernel_oserror * setup_build_set_parameter(session * s)
{
  char content_length[3];
  bool fail = false;

  /* Build command body and get content length */

  /* session_reset_session should have cleared s->data, but make sure */
  if (s->data != NULL)
    free(s->data);

  s->data_len = sizeof(Headers_Content_SetParameter) - 1;
  s->data = malloc(s->data_len + 1);

  if (s->data != NULL)
  {
    strcpy(s->data, Headers_Content_SetParameter);
    sprintf(content_length, "%d", s->data_len);
  }

  /* Add the SET_PARAMETER command */

  if (s->data == NULL) fail = true;

  else if (
        headers_add_header(&s->headers,
                           Headers_CommandName_SetParameter,
                           s->url->full)
        == NULL
     )
     fail = true;

  /* Add sequence number */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Session header */

  else if (
            headers_add_header(&s->headers,
                              Headers_HeaderName_Session,
                              s->server_session)
            == NULL
         )
         fail = true;

  /* Content type */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentType,
                               Headers_HeaderValue_ContentTypeSP)
            == NULL
          )
          fail = true;

  /* Content length */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentLength,
                               content_length)
            == NULL
          )
          fail = true;

  /* Did anything fail (out of memory)? */

  if (fail)
  {
    dprintf(("", "setup_build_set_parameter: Out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  return NULL;
}

#ifdef CLIENT_LOOPING

/**************************************************************/
/* setup_read_loop_option()                                   */
/*                                                            */
/* Find out whether looping is switched on using              */
/* VideoControl_Options and write the result into the given   */
/* session's 'loop' field.                                    */
/*                                                            */
/* Parameters: Pointer to a session struct to update;         */
/*                                                            */
/*             Video Control client ID to use.                */
/**************************************************************/

static _kernel_oserror * setup_read_loop_option(session * s, unsigned int vcid)
{
  _kernel_oserror * e;
  int               opts[4];

  opts[0] = vc_tags_looping;
  opts[1] = 1;
  opts[2] = 0;
  opts[3] = vc_tags__end;

  e = _swix(VideoControl_ProtocolOptions,
            _INR(0,2),

            0,
            vcid,
            opts);

  if (e == NULL) s->loop = !!opts[2];

  return e;
}

#endif

/**************************************************************/
/* setup_read_describe_doubles()                              */
/*                                                            */
/* Read the frames/sec and I-frames ratio from a DESCRIBE     */
/* response as doubles in the relevant fields of the given    */
/* session structure.                                         */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the asset_data struct to update;    */
/*                                                            */
/*             Pointer to the first character of the frames   */
/*             per second value;                              */
/*                                                            */
/*             Pointer to the first character of the frames   */
/*             to I-frames ratio value.                       */
/*                                                            */
/* Returns:    The 'frames_per_sec' and 'i_frame_ratio'       */
/*             fields of the session structure are updated.   */
/**************************************************************/

static void setup_read_describe_doubles(asset_data * asset, const char * p1, const char * p2)
{
  asset->frames_per_sec = strtod(p1, NULL);
  asset->i_frame_ratio  = strtod(p2, NULL);

  if ((asset->frames_per_sec == HUGE_VAL) || (asset->frames_per_sec == -HUGE_VAL)) asset->frames_per_sec = 0;
  if ((asset->i_frame_ratio  == HUGE_VAL) || (asset->i_frame_ratio  == -HUGE_VAL)) asset->i_frame_ratio  = 0;

  if (asset->frames_per_sec != 0)
    asset->approx_fps = (int)(asset->frames_per_sec + 0.5);
  else
    asset->approx_fps = 0;
}
