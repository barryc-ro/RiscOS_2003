/**************************************************************/
/* File:    Status.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Status and handle the state      */
/*          machine.                                          */
/*                                                            */
/* Author:  A.D.Hodgkinson. Partially based on URL_Fetcher    */
/*          source by S.N.Brodie and P.Wain.                  */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#include <swis.h>

#include <inetlib.h>
#include <socklib.h>
#include <sys/errno.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Play.h"
#include "RTSPMErrors.h"
#include "RTSPMHdr.h"
#include "Session.h"
#include "Utils.h"

#include "Status.h"

/* Local variables */

static char            recbuf[2048];
static _kernel_oserror final;

/* Local functions */

static bool status_proceed_completed (session * s, bool * repeat);
static bool status_proceed_connected (session * s, bool * repeat);
static bool status_proceed_default   (session * s, bool * repeat);
static bool status_proceed_dns       (session * s, bool * repeat);
static bool status_proceed_error     (session * s, bool * repeat);
static bool status_proceed_initial   (session * s, bool * repeat);
static bool status_proceed_pumping   (session * s, bool * repeat);
static bool status_proceed_receiving (session * s, bool * repeat);
static bool status_proceed_sending   (session * s, bool * repeat);

/**************************************************************/
/* status_status()                                            */
/*                                                            */
/* Implement RTSPMB_Status. See the Video Control             */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * status_status(_kernel_swi_regs * r)
{
  _kernel_oserror * e = NULL;
  session         * s = session_find_by_id(r->r[1]);

  dprintf(("", "status_status: Called\n"));

  if (!s)
  {
    dprintf(("", "status_status: ID not found\n"));
    return make_error(rtspmb_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  /* If we have no command queue, return the real state */

  if (s->next_command_cb == NULL)
  {
    r->r[0] = s->reported_state;
    r->r[2] = s->response_code;
  }

  /* Otherwise, return a "connected and waiting" indication */

  else
  {
    r->r[0] = VC_Status_ConnectionEstablished;
    r->r[2] = 0;
  }

  /* Error, or normal state? */

  e = status_check_error(s);

  dprintf(("", "status_status: Returning status %08x, error %p\n", r->r[0], e));

  return e;
}

/**************************************************************/
/* status_proceed_on_callout()                                */
/*                                                            */
/* A CallOut handler (see CallOut.h) which drives the state   */
/* machine. Used for anything that can't be event driven,     */
/* such as waiting for a DNS lookup to complete.              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void status_proceed_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("", "status_proceed_on_callout: Called for %p, forwarding to status_proceed\n", s));

  if (s->callout_set != 0)
  {
    s->callout_set = 0;
    status_proceed(s);
  }
}

/**************************************************************/
/* status_proceed()                                           */
/*                                                            */
/* Main module state machine.                                 */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: Pointer to the session struct to work for.     */
/**************************************************************/

void status_proceed(session * s)
{
  bool repeat;

  dprintf(("", "status_proceed: Called for %p\n", s));

  do
  {
    repeat = false;

    switch (s->state)
    {
      default:
      {
        if (status_proceed_default(s, &repeat)) return;
      }
      break;

      /* Error states: Various things went wrong... */

      case protostate_ERROR:
      case protostate_ERROR_DEAD:
      case protostate_ERROR_MEM:
      case protostate_ERROR_WRITE:
      case protostate_ERROR_READ:
      case protostate_ERROR_CONNECTION:
      case protostate_ERROR_NO_TOKEN:
      case protostate_ERROR_NOT_IMPLEMENTED:
      case protostate_ERROR_TIMEOUT:
      case protostate_ERROR_DNS:
      case protostate_ERROR_VCPN:
      {
        if (status_proceed_error(s, &repeat)) return;
      }
      break;

      /* Idle */

      case protostate_INITIAL:
      {
        if (status_proceed_initial(s, &repeat)) return;
      }
      break;

      /* After calling opensock (Connect.c) to kick things off, we're */
      /* waiting for DNS lookup to complete.                          */

      case protostate_DNS:
      {
        if (status_proceed_dns(s, &repeat)) return;
      }
      break;

      /* DNS is complete, and we're connected. Well, almost, could still try to */
      /* send down the socket and get ENOTCONN for a while...! At this point,   */
      /* call any connection callback function immediately, add in a sequence   */
      /* header, and move to a SENDING state to send the command off.           */

      case protostate_CONNECTED:
      {
        if (status_proceed_connected(s, &repeat)) return;
      }
      break;

      /* Whilst we could still be in an ENOTCONN state, the state machine is way ahead */
      /* and is will be issuing socket_write calls.                                    */

      case protostate_SENDING:
      {
        if (status_proceed_sending(s, &repeat)) return;
      }
      break;

      /* As soon as a full command is sent, we start listening for a response */

      case protostate_RECEIVING:
      {
        if (status_proceed_receiving(s, &repeat)) return;
      }
      break;

      case protostate_PUMPING:
      {
        if (status_proceed_pumping(s, &repeat)) return;
      }
      break;

      case protostate_COMPLETED:
      {
        if (status_proceed_completed(s, &repeat)) return;
      }
      break;
    }
  }
  while (repeat);

  /* If we've got a server session, no callout set and a timeout value, */
  /* set a callout to keep the session up (ensuring we're idling).      */

  if (
       (
         s->state == protostate_COMPLETED ||
         s->state == protostate_INITIAL
       )
       && s->gp_set         == 0
       && s->server_session != NULL
       && s->server_timeout != 0
     )
  {
    dprintf(("","status_proceed: Setting GET_PARAMETER callout (1)\n"));

    s->gp_set = 1;
    timeout(getparam_proceed_on_callout, s, s->server_timeout);
  }

  dprintf(("", "status_proceed: Successful\n"));
}

/**************************************************************/
/* status_proceed_default()                                   */
/*                                                            */
/* State machine handler for an unknown state.                */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_default(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_default: UNKNOWN STATE %d ENTERED\n", s->state));

  s->state = protostate_COMPLETED;
  *repeat  = true;

  return false;
}

/**************************************************************/
/* status_proceed_error()                                     */
/*                                                            */
/* State machine handler for any error state.                 */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_error(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_error: General error\n"));

  if (s->destruct)
  {
    dprintf(("", "status_proceed_error: Session self-destructing (on error), state machine exitting\n"));
    session_free_item(s);
    return true;
  }
  else
  {
    /* Video Control needs to know about this... */

    if (s->reported == 0)
    {
      s->reported = 1;

      _swix(VideoControl_ProtocolNotify,
            _INR(0,3),

            0,
            s->id,
            VideoControlProtocolNotifyNewStatus,
            0);
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_initial()                                   */
/*                                                            */
/* State machine handler for an initial (idling) state.       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_initial(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_initial: Initial state\n"));

  return false;
}

/**************************************************************/
/* status_proceed_dns()                                       */
/*                                                            */
/* State machine handler for a DNS (resolving) state: "After  */
/* calling opensock (Connect.c) to kick things off, we're     */
/* waiting for DNS lookup to complete".                       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_dns(session * s, bool * repeat)
{
  int port;

  dprintf(("", "status_proceed_dns: DNS; recalling opensock\n"));

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  s->sd = opensock(s->url->host,
                   port,
                   NULL,
                   &s->state,
                   s->sd);

  /* If we're still in the DNS state, set another callout. Otherwise we */
  /* have to wait until the Internet event handler gets triggered when  */
  /* the socket gets connected.                                         */

  if (s->sd < 0 || s->state == protostate_DNS)
  {
    unsigned now = utils_read_time();

    dprintf(("", "status_proceed_dns: Still in DNS state / sd < 0\n"));

    /* Check timeout */

    if (utils_time_difference(s->last, now) > Headers_Timeout_General)
    {
      dprintf(("", "status_proceed_dns: DNS timeout\n"));

      s->state = protostate_ERROR_TIMEOUT;
      *repeat  = true;
    }
    else if (s->callout_set == 0)
    {
      dprintf(("", "status_proceed_dns: Setting a 50cs callout for DNS lookup\n"));

      s->callout_set = 1;
      timeout(status_proceed_on_callout, s, Session_State_Timer);
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_connected()                                 */
/*                                                            */
/* State machine handler for a connected (post-DNS, but could */
/* be waiting for actual connection) state: "DNS is complete, */
/* and we're connected. Well, almost, could still try to send */
/* down the socket and get ENOTCONN for a while...! At this   */
/* point, call any connection callback function immediately,  */
/* add in a sequence header, and move to a SENDING state to   */
/* send the command off".                                     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_connected(session * s, bool * repeat)
{
  /* Socket is connected. Compile our command data into a continuous block */
  /* and move to a "sending" state.                                        */

  dprintf(("", "status_proceed_connected: Connected\n"));

  s->last = utils_read_time();

  if (s->connected_cb != NULL)
  {
    dprintf(("", "status_proceed_connected: Calling callback function.\n"));

    // And we do what exactly with errors...?

    s->connected_cb(s);
    s->connected_cb = NULL;
  }

  /* Compile the headers into a continuous block for sending */

  s->reqlen = headers_construct_header_buffer(s, s->data_len, 0);

  if (s->full_request != NULL)
  {
    /* If there's body data, include it */

    if (s->data_len > 0)
    {
      memcpy(s->full_request + s->reqlen, s->data, s->data_len);
      s->reqlen += s->data_len;

      /* We're always over-allocated by 1 to allow for a NUL terminator, keeps */
      /* things tidy elsewhere (see function header comments in Headers.c).    */

      (s->full_request)[s->reqlen] = '\0';
    }

    dprintf(("", "status_proceed_connected: Command buffer compiled -\n'%s'\n",s->full_request));

    s->state = protostate_SENDING;
    *repeat  = true;
  }

  return false;
}

/**************************************************************/
/* status_proceed_sending()                                   */
/*                                                            */
/* State machine handler for a sending state: "Whilst we      */
/* could still be in an ENOTCONN state, the state machine is  */
/* way ahead and will be issuing socket_write calls".         */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_sending(session * s, bool * repeat)
{
  int    sent;
  time_t now;

  /* We're sending a command out */

  dprintf(("", "status_proceed_sending: Sending (%d of %d done so far) to socket %d...\n", s->reqptr, s->reqlen, s->sd));

//printf("\nSend:\n---\n%s\n--- for %p\n",s->full_request,s);

// Hmm - should be doing a GETSO call before socketread/socketwrite, otherwise
//       you can end up with a less meaningful error.

//
//{
//int so;
//sent=sizeof(int);
//dprintf(("", "GETSOcall: %d\n", getsockopt(s->sd, SOL_SOCKET, SO_ERROR, &so, &sent)));
//dprintf(("", "GETSO: %d\n",so));
//}
//

  sent = socketwrite(s->sd,
                     s->full_request + s->reqptr,
                     s->reqlen - s->reqptr);

//printf("%d ",sent);

  dprintf(("", "status_proceed_sending: ...sent %d this time\n", sent));

  now = utils_read_time();

  if (sent < 0)
  {
    if (
         errno != ENOTCONN    &&
         errno != EWOULDBLOCK
       )
    {
      dprintf(("", "status_proceed_sending: Error %d\n", errno));

      s->state = protostate_ERROR_WRITE;
      *repeat  = true;
    }
    else
    {
      /* Check timeout */

      if (utils_time_difference(s->last, now) > Headers_Timeout_General)
      {
        s->state = protostate_ERROR_TIMEOUT;
        *repeat  = true;
      }
      else if (s->callout_set == 0)
      {
        dprintf(("", "status_proceed_sending: Setting %dcs callout for send timeout (1)\n", Session_State_Retry));

        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Retry);
      }
    }
  }
  else
  {
    s->reported_state |= VC_Status_ConnectionEstablished;
    s->reqptr         += sent;

    if (sent != 0)
    {
//printf("Sent %d (reqptr, reqlen = %d, %d)   ",sent,s->reqptr,s->reqlen);
{FILE*f=fopen("Cache:$.Test","ab");
if(f!=NULL){fprintf(f,"SEND (%p):\r\n", s);fwrite(s->full_request,1,s->reqlen,f);
fclose(f);}
}

if (!strncmp(s->full_request, "RTSP/1.0", 8)) printf("\n********* FAIL\n\n");

      s->last = now;
    }
    else
    {
      /* Check timeout */

      if (utils_time_difference(s->last, now) > Headers_Timeout_General)
      {
        s->state = protostate_ERROR_TIMEOUT;
        *repeat  = true;

        return false;
      }
      else if (s->callout_set == 0)
      {
        dprintf(("", "status_proceed_sending: Setting a %dcs callout for send timeout (2)\n", Session_State_Retry));

        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Retry);
      }
    }

    if (s->reqptr >= s->reqlen)
    {
      dprintf(("", "status_proceed_sending: Full command sent, moving to RECEIVING\n"));

      s->last = now;

      free(s->full_request), s->full_request = NULL;
      s->reqptr = s->reqlen = 0;

      /* We'll read into s->data, so don't forget to clear anything lying */
      /* around in there from the request we sent.                        */

      free(s->data), s->data = NULL;
      s->data_len = 0;

      s->state = protostate_RECEIVING;
      *repeat  = true;
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_receiving()                                 */
/*                                                            */
/* State machine handler for a receiving state: "As soon as a */
/* full command is sent, we start listening for a response".  */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_receiving(session * s, bool * repeat)
{
  int          ret;
  unsigned int now = utils_read_time();

  dprintf(("", "status_proceed_receving: Receiving\n"));

  for (;;)
  {
    ret = socketread(s->sd,
                     recbuf,
                     sizeof(recbuf));

    dprintf(("", "status_proceed_receving: Retrieved %d, existing data length is %d\n", ret, s->data_len));

    /* If we get > 0, we read data successfully */

    if (ret > 0)
    {
      char * new_data = module_realloc(s->data, s->data_len + ret + 1);

      s->last = now;

      if (new_data == NULL)
      {
        dprintf(("", "status_proceed_receving: Can't realloc for receive\n"));

        s->state = protostate_ERROR_MEM;
        *repeat  = true;

        return false;
      }
      else
      {
        dprintf(("", "status_proceed_receving: Read %d bytes, realloced to %d\n", ret, s->data_len + ret + 1));

        s->data = new_data;
        memcpy(s->data + s->data_len, recbuf, ret);
        s->data_len += ret; /* data_len always lags 1 byte behind actual allocation */
      }
    }

    /* If we get zero, there's nothing more to read */

    else if (ret == 0 || (ret == -1 && s->data_len != 0))
    {
      int consumed;

      s->last = now;

      if (s->data_len != 0)
      {
        /* Force a terminator at the end - we're expecting no binary data so */
        /* this ensures correct termination and makes life easier later      */

        s->data[s->data_len] = '\0'; /* Correct as data_len is always 1 byte behind actual allocation */
        dprintf(("", "status_proceed_receving: Receive complete with %d bytes -\n'%s'\n", s->data_len, s->data));

        /* printf("\nReceive:\n===\n%s\n=== for %p\n",s->data,s); */

        /* We've received the response now */

{FILE*f=fopen("Cache:$.Test","ab");
if(f!=NULL){fprintf(f,"RECEIVE (%p):\r\n", s);fwrite(s->data,1,s->data_len,f);
fclose(f);}
}
        s->reported_state |= VC_Status_NewStatus;
        s->state = protostate_COMPLETED;

        /* Parse the response and move to the appropriate state */

        consumed = headers_parse_response(s);

        if (consumed < 0)
        {
          s->state = protostate_ERROR_MEM;
        }
        else
        {
          s->reported_state |= VC_Status_MoreInformationAvailable;

          /* If we've not got a server session, try to find one from this response. */
          /* Don't bother with this if we're a child though because if we need a    */
          /* session we'll be using the parent's.                                   */

          if (s->server_session == NULL && s->parent == NULL)
          {
            rtsp_header * h;
            char        * store;

            h = headers_find_header(s->headers,
                                    Headers_HeaderName_Session);

            if (h != NULL)
            {
              s->server_timeout = Session_Timeout_Default;

              /* Find the session ID. It'll be terminated by ';' or end of string */

              store = strchr(h->value, ';');
              if (store != NULL) *store = '\0';

              s->server_session = Strdup(h->value);

              /* Find "timeout" then "=" */

              if (store != NULL)
              {
                *store = ';';

                store = strstr(h->value, Headers_HeaderValue_Session);

                if (store != NULL)
                {
                  while (*store != '\0' && *store != '=') store++;
                  if (*store == '=') store++;
                  while (*store != '\0' && *store <= ' ') store++;

                  s->server_timeout = atoi(store);
                  if (s->server_timeout == 0) s->server_timeout = Session_Timeout_Default;
                }
              }

              /* Ensure the timeout is in centiseconds, but keep half the value */
              /* to avoid having to say "server_timeout / 2" for the inter-ping */
              /* delay elsewhere.                                               */

              s->server_timeout *= 50;

              dprintf(("", "status_proceed_receving: New session '%s', timeout %d\n", s->server_session ? s->server_session : "<out of memory>", s->server_timeout));
            }
          }
        }
      }
      else /* 'if (s->data_len > 0)' */
      {
        /* We've received an empty respose */

        s->state          =  protostate_ERROR_READ;
        s->reported_state |= VC_Status_NewStatus;

        close_socket(&s->sd);
      }

      *repeat = true;
      return false;
    }

    /* If we get < 0, there was some error */

    else
    {
      if (errno != EWOULDBLOCK)
      {
        s->state = protostate_ERROR_READ;
        *repeat  = true;

        dprintf(("", "status_proceed_receving: Error = %d\n", errno));
      }
      else
      {
        /* Check timeout */

        if (utils_time_difference(s->last, now) > Headers_Timeout_General)
        {
          s->state = protostate_ERROR_TIMEOUT;
          *repeat  = true;
        }
        else if (s->callout_set == 0)
        {
          dprintf(("", "status_proceed_receving: Setting a %dcs callout for receive timeout\n", Session_State_Retry));

          s->callout_set = 1;
          timeout(status_proceed_on_callout, s, Session_State_Retry);
        }
      }

      return false;
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_pumping()                                   */
/*                                                            */
/* State machine handler for a pumping (data movement) state. */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_pumping(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_pumping: Pumping\n"));

  return false;
}

/**************************************************************/
/* status_proceed_completed()                                 */
/*                                                            */
/* State machine handler for a completed state (tidy up).     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_completed(session * s, bool * repeat)
{
  dprintf(("", "status_proceed_completed: Completed.\n"));

  s->state = protostate_INITIAL;

  if (s->destruct)
  {
    /* We're on the way out - no status change to Video Control... */

    dprintf(("", "status_proceed_completed: Session self-destructing (completed), state machine exitting\n"));

//    /* Set the next callout */
//
//    if (s->parent != NULL)
//    {
//      if (
//           (
//             s->parent->state == protostate_COMPLETED ||
//             s->parent->state == protostate_INITIAL
//           )
//           && s->parent->gp_set         == 0
//           && s->parent->server_session != NULL
//           && s->parent->server_timeout != 0
//         )
//      {
//        dprintf(("","status_proceed: Setting GET_PARAMETER callout (2)\n"));
//
//        s->parent->gp_set = 1;
//        timeout(getparam_proceed_on_callout, s->parent, s->parent->server_timeout);
//      }
//    }
//
    /* Destroy the session */

    session_free_item(s);
    return true;
  }
  else
  {
    _kernel_oserror * e;

    /* We may have to send another command */

    if (s->next_command_cb)
    {
      e = (s->next_command_cb)(s);

      if (e != NULL)
      {
        final.errnum = e->errnum;
        strncpy(final.errmess, e->errmess, sizeof(final.errmess));

        s->state = protostate_ERROR_VCPN;
        *repeat  = true;
      }

      return false;
    }
    else
    {
      bool prepare;

      /* We're more or less finished, just need to let Video Control */
      /* know about the status change.                               */

      if (s->play_record != NULL && s->started == 0) prepare = true;
      else                                           prepare = false;

      e = _swix(VideoControl_ProtocolNotify,
                _INR(0,4),

                0,
                s->id,
                VideoControlProtocolNotifyNewStatus,
                prepare ? VC_ProtocolNotify_NewStatus_Prepare : 0,
                s->play_record);

      if (e != NULL)
      {
        final.errnum = e->errnum;
        strncpy(final.errmess, e->errmess, sizeof(final.errmess));

        s->state = protostate_ERROR_VCPN;
        *repeat  = true;

        return false;
      }

      /* Things seem to be working */

      else
      {
        if (prepare)
        {
          s->started = 1;
        }
        else
        {
          _kernel_oserror * e;
          int               opts[4];
          unsigned int      mpegid;
          unsigned int      flags;

          /* The MediaBase server is awful. It streams, say, an MPEG 2 transport stream */
          /* normally, but in trick mode just spews elementary video data out. Eek! Our */
          /* system can't really handle that. The only thing to do is to leave the      */
          /* decode running whilst we talk to the server to try and exhaust any data in */
          /* buffers, and then do an immediate reset on the PLAY command's OK response, */
          /* to try and get stream-start style auto detection running to redetermine    */
          /* the stream type.                                                           */

          opts[0] = vc_tags_control_handle;
          opts[1] = 1;
          opts[2] = 0;
          opts[3] = vc_tags__end;

          e = _swix(VideoControl_ProtocolOptions,
                    _INR(0,2),

                    0,
                    s->vcid,
                    opts);

          if (e != NULL) mpegid = 0;
          else           mpegid = (unsigned int) opts[2];

          if (mpegid != 0)
          {
            if (s->playmode == Play_MB_Trick_Freeze)
            {
              /* Immediate set speed to 0 */

              _swix(MPEGControl_SetSpeed,
                    _INR(0,2),

                    0,
                    mpegid,
                    0);
            }
            else
            {
              if (s->playmode == Play_MB_Trick_Play)
              {
                /* Immediate set speed to 1 */

                _swix(MPEGControl_SetSpeed,
                      _INR(0,2),

                      0,
                      mpegid,
                      1);

                /* Normal play - flag video and audio */

                flags = MPEGCtrl_MCRS_VideoPresent |
                        MPEGCtrl_MCRS_AudioPresent;
              }
              else
              {
                /* Trick play - flag a trick play stream */

                flags = MPEGCtrl_MCRS_VideoPresent |
                        MPEGCtrl_MCRS_NewIsTrickPlay;
              }

              _swix(MPEGControl_ResetStream,
                    _INR(0,2),
                    flags,
                    mpegid,
                    MPEGCtrl_MCRS_Trick_Play);
            }
          }
        }
      }
    }
  }

  return false;
}

/**************************************************************/
/* status_check_error()                                       */
/*                                                            */
/* Examine a session structure to see if there's an error     */
/* state and if so return an appropriate _kernel_oserror.     */
/*                                                            */
/* Parameters: Pointer to the session structure to examine.   */
/*                                                            */
/* Returns:    NULL or pointer to a filled in _kernel_oserror */
/*             if the session was in an error state.          */
/**************************************************************/

_kernel_oserror * status_check_error(session * s)
{
  _kernel_oserror * e = NULL;

  switch (s->state)
  {
    /* Error states: Various things went wrong... */

    case protostate_ERROR:
    case protostate_ERROR_DEAD:
    case protostate_ERROR_CONNECTION:
    case protostate_ERROR_NO_TOKEN:
    case protostate_ERROR_NOT_IMPLEMENTED:
    {
      char en[16];

      sprintf(en, "%d", errno);

      e = make_error(rtspmb_ERROR_CONNECT_GENERAL, 1, en);
    }
    break;

    case protostate_ERROR_WRITE:
    {
      e = make_error(rtspmb_ERROR_CONNECT_WRITE, 0);
    }
    break;

    case protostate_ERROR_READ:
    {
      e = make_error(rtspmb_ERROR_CONNECT_READ, 0);
    }
    break;

    case protostate_ERROR_MEM:
    {
      e = make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
    }
    break;

    case protostate_ERROR_TIMEOUT:
    {
      e = make_error(rtspmb_ERROR_CONNECT_TIMEOUT, 0);
    }
    break;

    case protostate_ERROR_DNS:
    {
      char * host;

      if (s->url && s->url->host && *s->url->host) host = s->url->host;
      else                                         host = "<?>";

      e = make_error(rtspmb_ERROR_CONNECT_DNS, 1, host);
    }
    break;

    case protostate_ERROR_VCPN:
    {
      e = &final;
    }
    break;
  }

  #ifdef TRACE

    if (e != NULL && strlen(e->errmess) < (sizeof(e->errmess) - 12))
    {
      sprintf(strchr(e->errmess, '\0'), " (%08X)", (unsigned int) s);
    }

  #endif

  return e;
}
