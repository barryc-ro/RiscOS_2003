/**************************************************************/
/* File:    Status.c                                          */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Status and handle the state      */
/*          machine.                                          */
/*                                                            */
/* Author:  A.D.Hodgkinson. Partially based on URL_Fetcher    */
/*          source by S.N.Brodie and P.Wain.                  */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/*          08-Mar-2002 (JRB): Updated for MediaBase 6.       */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>

#include <swis.h>

#include <inetlib.h>
#include <socklib.h>
#include <unixlib.h>
#include <sys/errno.h>

#ifndef ENOERROR
  #define ENOERROR 0
#endif

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Play.h"
#include "RTSPMErrors.h"
#include "RTSPMHdr.h"
#include "Session.h"
#include "Utils.h"

#include "Status.h"

/* Local options */

#undef  DUMP_HEADERS_TO_CACHEFS

/*
 * #define DUMP_HEADERS_TO_CACHEFS "Cache:$.Test"
 */

/* Local variables */

static char            recbuf[2048];
static _kernel_oserror final;

/* Local functions */

static bool status_proceed_completed (session * s, bool * repeat);
static bool status_proceed_connected (session * s, bool * repeat);
static bool status_proceed_default   (session * s, bool * repeat);
static bool status_proceed_dns       (session * s, bool * repeat);
static bool status_proceed_error     (session * s, bool * repeat);
static bool status_proceed_initial   (session * s, bool * repeat);
static bool status_proceed_pumping   (session * s, bool * repeat);
static bool status_proceed_receiving (session * s, bool * repeat);
static bool status_proceed_sending   (session * s, bool * repeat);

/**************************************************************/
/* status_status()                                            */
/*                                                            */
/* Implement RTSPMB_Status. See the Video Control             */
/* specification, 2501,817/FS, for more.                      */
/**************************************************************/

_kernel_oserror * status_status(_kernel_swi_regs * r)
{
  _kernel_oserror * e = NULL;
  session         * s = session_find_by_id(r->r[1]);

  dprintf(("Entry_2", "status_status: Called for %08X\n", r->r[1]));

  if (!s)
  {
    dprintf(("Error_0", "status_status: ID not found\n"));
    return make_error(rtspmb_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  /* If we have no command queue, return the real state */

  if (s->next_command_cb == NULL)
  {
    r->r[0] = s->reported_state;
    r->r[2] = s->response_code;
  }

  /* Otherwise, return a "connected and waiting" indication */

  else
  {
    r->r[0] = VC_Status_ConnectionEstablished;
    r->r[2] = 0;
  }

  /* Error, or normal state? */

  e = status_check_error(s);

  dprintf(("Entry_2", "status_status: Returning status %08x, error %p\n", r->r[0], e));

  return e;
}

/**************************************************************/
/* status_proceed_on_callout()                                */
/*                                                            */
/* A CallOut handler (see CallOut.h) which drives the state   */
/* machine. Used for anything that can't be event driven,     */
/* such as waiting for a DNS lookup to complete.              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void status_proceed_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("State_0", "status_proceed_on_callout: Called for %p, forwarding to status_proceed\n", s));

  if (s->dying != 0) return;

  if (s->callout_set != 0)
  {
    s->callout_set = 0;
    status_proceed(s);
  }
}

/**************************************************************/
/* status_proceed()                                           */
/*                                                            */
/* Main module state machine.                                 */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: Pointer to the session struct to work for.     */
/**************************************************************/

void status_proceed(session * s)
{
  bool repeat;

  dprintf(("State_0", "status_proceed: Called for %p\n", s));

  do
  {
    repeat = false;

    switch (s->state)
    {
      default:
      {
        if (status_proceed_default(s, &repeat)) return;
      }
      break;

      /* Error states: Various things went wrong... */

      case protostate_ERROR:
      case protostate_ERROR_DEAD:
      case protostate_ERROR_MEM:
      case protostate_ERROR_WRITE:
      case protostate_ERROR_READ:
      case protostate_ERROR_CONNECTION:
      case protostate_ERROR_NO_TOKEN:
      case protostate_ERROR_NOT_IMPLEMENTED:
      case protostate_ERROR_TIMEOUT:
      case protostate_ERROR_DNS:
      case protostate_ERROR_VCPN:
      {
        if (status_proceed_error(s, &repeat)) return;
      }
      break;

      /* Idle */

      case protostate_INITIAL:
      {
        if (status_proceed_initial(s, &repeat)) return;
      }
      break;

      /* After calling opensock (Connect.c) to kick things off, we're */
      /* waiting for DNS lookup to complete.                          */

      case protostate_DNS:
      {
        if (status_proceed_dns(s, &repeat)) return;
      }
      break;

      /* DNS is complete, and we're connected. Well, almost, could still try to */
      /* send down the socket and get ENOTCONN for a while...! At this point,   */
      /* call any connection callback function immediately, add in a sequence   */
      /* header, and move to a SENDING state to send the command off.           */

      case protostate_CONNECTED:
      {
        if (status_proceed_connected(s, &repeat)) return;
      }
      break;

      /* Whilst we could still be in an ENOTCONN state, the state machine is way ahead */
      /* and is will be issuing socket_write calls.                                    */

      case protostate_SENDING:
      {
        if (status_proceed_sending(s, &repeat)) return;
      }
      break;

      /* As soon as a full command is sent, we start listening for a response */

      case protostate_RECEIVING:
      {
        if (status_proceed_receiving(s, &repeat)) return;
      }
      break;

      case protostate_PUMPING:
      {
        if (status_proceed_pumping(s, &repeat)) return;
      }
      break;

      case protostate_COMPLETED:
      {
        if (status_proceed_completed(s, &repeat)) return;
      }
      break;
    }
  }
  while (repeat);

  /* If we've got a server session, no callout set and a timeout value, */
  /* set a callout to keep the session up (ensuring we're idling).      */

  if (
          s->state          == protostate_INITIAL
       && s->gp_set         == 0
       && s->server_session != NULL
       && s->server_timeout != 0
     )
  {
    dprintf(("State_1","status_proceed: Setting GET_PARAMETER callout (1)\n"));

    s->gp_set = 1;
    timeout(getparam_proceed_on_callout, s, s->server_timeout);
  }

  dprintf(("State_0", "status_proceed: Successful\n"));
}

/**************************************************************/
/* status_proceed_default()                                   */
/*                                                            */
/* State machine handler for an unknown state.                */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_default(session * s, bool * repeat)
{
  dprintf(("State_0,Error_0", "status_proceed_default: UNKNOWN STATE %d ENTERED\n", s->state));

  s->state = protostate_COMPLETED;
  *repeat  = true;

  return false;
}

/**************************************************************/
/* status_proceed_error()                                     */
/*                                                            */
/* State machine handler for any error state.                 */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_error(session * s, bool * repeat)
{
  dprintf(("State_0,Error_0", "status_proceed_error: General error\n"));

  if (s->destruct)
  {
    dprintf(("State_0,Error_0", "status_proceed_error: Session self-destructing (on error), state machine exitting\n"));
    session_free_item(s);
    return true;
  }
  else
  {
    /* Video Control needs to know about this... */

    if (s->reported == 0 && s->id != 0)
    {
      s->reported = 1;

      _swix(VideoControl_ProtocolNotify,
            _INR(0,3),

            0,
            s->id,
            VideoControlProtocolNotifyNewStatus,
            0);
    }

    /* Clear the change pending flag - whatever was pending has failed */

    s->change_pending = 0;
  }

  return false;
}

/**************************************************************/
/* status_proceed_initial()                                   */
/*                                                            */
/* State machine handler for an initial (idling) state.       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_initial(session * s, bool * repeat)
{
  dprintf(("State_0", "status_proceed_initial: Initial state\n"));

  return false;
}

/**************************************************************/
/* status_proceed_dns()                                       */
/*                                                            */
/* State machine handler for a DNS (resolving) state: "After  */
/* calling opensock (Connect.c) to kick things off, we're     */
/* waiting for DNS lookup to complete".                       */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_dns(session * s, bool * repeat)
{
  int port;

  dprintf(("State_0", "status_proceed_dns: DNS; recalling opensock\n"));

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  s->sd = opensock(s->url->host,
                   port,
                   NULL,
                   &s->state,
                   s->sd);

  /* If we're still in the DNS state, set another callout. Otherwise we */
  /* have to wait until the Internet event handler gets triggered when  */
  /* the socket gets connected.                                         */

  if (s->sd < 0 || s->state == protostate_DNS)
  {
    unsigned now = utils_read_time();

    if (s->state == protostate_ERROR) s->err_no = -s->sd;

    dprintf(("State_1", "status_proceed_dns: Still in DNS state or sd < 0 (%d)\n", s->sd));

    /* Check timeout */

    if (utils_time_difference(s->last, now) > Headers_Timeout_General)
    {
      dprintf(("State_0,Error_0", "status_proceed_dns: DNS timeout\n"));

      s->state = protostate_ERROR_TIMEOUT;
      *repeat  = true;
    }
    else if (s->callout_set == 0)
    {
      dprintf(("State_1", "status_proceed_dns: Setting a 50cs callout for DNS lookup\n"));

      s->callout_set = 1;
      timeout(status_proceed_on_callout, s, Session_State_Timer);
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_connected()                                 */
/*                                                            */
/* State machine handler for a connected (post-DNS, but could */
/* be waiting for actual connection) state: "DNS is complete, */
/* and we're connected. Well, almost, could still try to send */
/* down the socket and get ENOTCONN for a while...! At this   */
/* point, call any connection callback function immediately,  */
/* add in a sequence header, and move to a SENDING state to   */
/* send the command off".                                     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_connected(session * s, bool * repeat)
{
  /* Socket is connected. Compile our command data into a continuous block */
  /* and move to a "sending" state.                                        */

  dprintf(("State_0", "status_proceed_connected: Connected\n"));

  s->last = utils_read_time();

  if (s->connected_cb != NULL)
  {
    dprintf(("State_1", "status_proceed_connected: Calling callback function.\n"));

    // And we do what exactly with errors...?

    s->connected_cb(s);
    s->connected_cb = NULL;
  }

  /* Compile the headers into a continuous block for sending */

  s->reqlen = headers_construct_header_buffer(s, s->data_len, 0);

  if (s->full_request != NULL)
  {
    /* If there's body data, include it */

    if (s->data_len > 0)
    {
      memcpy(s->full_request + s->reqlen, s->data, s->data_len);
      s->reqlen += s->data_len;

      /* We're always over-allocated by 1 to allow for a NUL terminator, keeps */
      /* things tidy elsewhere (see function header comments in Headers.c).    */

      (s->full_request)[s->reqlen] = '\0';
    }

    dprintf(("State_1,RTSP_0", "status_proceed_connected: Command buffer compiled -\n'%s'\n",s->full_request));

    s->state = protostate_SENDING;
    *repeat  = true;
  }

  return false;
}

/**************************************************************/
/* status_proceed_sending()                                   */
/*                                                            */
/* State machine handler for a sending state: "Whilst we      */
/* could still be in an ENOTCONN state, the state machine is  */
/* way ahead and will be issuing socket_write calls".         */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_sending(session * s, bool * repeat)
{
  int    sent;
  time_t now;

  /* We're sending a command out */

  dprintf(("State_0,RTSP_5", "status_proceed_sending: Sending (%d of %d done so far) to socket %d...\n", s->reqptr, s->reqlen, s->sd));

  sent = socketwrite(s->sd,
                     s->full_request + s->reqptr,
                     s->reqlen - s->reqptr);

  dprintf(("State_1,RTSP_5", "status_proceed_sending: ...sent %d this time\n", sent));

  now = utils_read_time();

  if (sent < 0)
  {
    if (
         errno != ENOTCONN    &&
         errno != EWOULDBLOCK
       )
    {
      dprintf(("State_1,RTSP_0,Error_0", "status_proceed_sending: Error %d\n", errno));

      s->state  = protostate_ERROR_WRITE;
      s->err_no = errno;
      *repeat   = true;
    }
    else
    {
      /* Check timeout */

      if (utils_time_difference(s->last, now) > Headers_Timeout_General)
      {
        s->state = protostate_ERROR_TIMEOUT;
        *repeat  = true;
      }
      else if (s->callout_set == 0)
      {
        dprintf(("State_1,RTSP_5", "status_proceed_sending: Setting %dcs callout for send timeout (1)\n", Session_State_Retry));

        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Retry);
      }
    }
  }
  else
  {
    s->reported_state |= VC_Status_ConnectionEstablished;
    s->reqptr         += sent;

    if (sent != 0)
    {
      #ifdef DUMP_HEADERS_TO_CACHEFS
      {
        FILE * f = fopen(DUMP_HEADERS_TO_CACHEFS, "ab");

        if (f != NULL)
        {
          fprintf(f, "SEND (%p):\r\n", s);
          fwrite(s->full_request, 1, s->reqlen, f);
          fclose(f);
        }
      }
      #endif

      s->last = now;
    }
    else
    {
      /* Check timeout */

      if (utils_time_difference(s->last, now) > Headers_Timeout_General)
      {
        s->state = protostate_ERROR_TIMEOUT;
        *repeat  = true;

        return false;
      }
      else if (s->callout_set == 0)
      {
        dprintf(("State_1,RTSP_5", "status_proceed_sending: Setting a %dcs callout for send timeout (2)\n", Session_State_Retry));

        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Retry);
      }
    }

    if (s->reqptr >= s->reqlen)
    {
      dprintf(("State_1,RTSP_2", "status_proceed_sending: Full command sent, moving to RECEIVING\n"));

      s->last = now;

      free(s->full_request), s->full_request = NULL;
      s->reqptr = s->reqlen = 0;

      /* We'll read into s->data, so don't forget to clear anything lying */
      /* around in there from the request we sent.                        */

      free(s->data), s->data = NULL;
      s->data_len = 0;
      s->data_to_read = -1;

      s->state = protostate_RECEIVING;
      *repeat  = true;
    }
  }

  return false;
}

/**************************************************************/
/* status_proceed_receiving()                                 */
/*                                                            */
/* State machine handler for a receiving state: "As soon as a */
/* full command is sent, we start listening for a response".  */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_receiving(session * s, bool * repeat)
{
  int          ret;
  unsigned int now = utils_read_time();

  dprintf(("State_0,RTSP_6", "status_proceed_receiving: Receiving\n"));

  for (;;)
  {
    ret = socketread(s->sd,
                     recbuf,
                     sizeof(recbuf));

    dprintf(("State_1,RTSP_6", "status_proceed_receiving: Retrieved %d, existing data length is %d\n", ret, s->data_len));

    /* If we get > 0, we read data successfully */

    if (ret > 0)
    {
      char * new_data = module_realloc(s->data, s->data_len + ret + 1);

      s->last = now;

      if (new_data == NULL)
      {
        dprintf(("State_0,RTSP_0,Error_0", "status_proceed_receiving: Can't realloc for receive\n"));

        s->state = protostate_ERROR_MEM;
        *repeat  = true;

        return false;
      }
      else
      {
        dprintf(("State_1,RTSP_6", "status_proceed_receiving: Read %d bytes, realloced to %d\n", ret, s->data_len + ret + 1));

        s->data = new_data;
        memcpy(s->data + s->data_len, recbuf, ret);
        s->data_len += ret; /* data_len always lags 1 byte behind actual allocation */

        if (s->data_to_read > 0)
        {
          s->data_to_read -= ret;

          dprintf(("State_1,RTSP_6", "status_proceed_receiving: %d bytes of data left to read\n", s->data_to_read));

          if (s->data_to_read <= 0)
            break;
        }
      }
    }
    else if (ret == 0 && s->data_len == 0)
    {
      /* We've received an empty response */

      dprintf(("State_0,RTSP_0", "status_proceed_receiving: Empty response\n"));

      s->state  = protostate_ERROR_READ;
      s->err_no = ENOERROR;

      close_socket(&s->sd);

      *repeat = true;
      return false;
    }
    else
    {
      /* If we now have some data, and haven't parsed the headers yet, */
      /* see if we can do it now.                                      */

      if (s->data_len != 0 && s->data_to_read == -1)
      {
        /* Force a terminator at the end - we're expecting no binary data so */
        /* this ensures correct termination and makes life easier.           */

        s->data[s->data_len] = '\0'; /* Correct as data_len is always 1 byte behind actual allocation */

        /* Have we read in all the headers yet? */

        if (strstr(s->data, "\r\n\r\n") != NULL || ret == 0)
        {
          int len_read = s->data_len;
          int consumed;

          /* We have all the headers, so parse them and set s->data_to_read */
          /* to the amount of data still to be read for this response.      */

          dprintf(("State_1,RTSP_6", "status_proceed_receiving: All headers read\n"));

          consumed = headers_parse_response(s);
  
          if (consumed < 0)
          {
            dprintf(("State_0,RTSP_0,Error_0", "status_proceed_receiving: Memory allocation failure parsing headers\n"));

            s->state = protostate_ERROR_MEM;
            *repeat = true;
            return false;
          }
          else
          {
            rtsp_header * h;

            /* Have we got any more message body data to read? */

            h = headers_find_header(s->headers,
                                    Headers_HeaderName_ContentLength);

            if (h != NULL)
            {
              s->data_to_read = consumed + atoi(h->value) - len_read;
              if (s->data_to_read < 0)
                s->data_to_read = 0;
            }
            else
            {
              s->data_to_read = 0;
            }

            dprintf(("State_1,RTSP_6", "status_proceed_receiving: %d bytes of data left to read\n", s->data_to_read));

            /* If we've not got a server session, try to find one from this response. */
            /* Don't bother with this if we're a child though because if we need a    */
            /* session we'll be using the parent's.                                   */
  
            if (s->server_session == NULL && s->parent == NULL)
            {
              char * store;
  
              h = headers_find_header(s->headers,
                                      Headers_HeaderName_Session);
  
              if (h != NULL)
              {
                s->server_timeout = Session_Timeout_Default;
  
                /* Find the session ID. It'll be terminated by ';' or end of string */
  
                store = strchr(h->value, ';');
                if (store != NULL) *store = '\0';
  
                s->server_session = Strdup(h->value);
                if (s->server_session == NULL)
                {
                  dprintf(("State_0,RTSP_0,Error_0", "status_proceed_receiving: Memory allocation failure\n"));
      
                  s->state = protostate_ERROR_MEM;
                  *repeat = true;
                  return false;
                }

                /* Find "timeout" then "=" */
  
                if (store != NULL)
                {
                  *store = ';';
  
                  store = strstr(h->value, Headers_HeaderValue_Session);
  
                  if (store != NULL)
                  {
                    while (*store != '\0' && *store != '=') store++;
                    if (*store == '=') store++;
                    while (*store != '\0' && *store <= ' ') store++;
  
                    s->server_timeout = atoi(store);
                    if (s->server_timeout == 0) s->server_timeout = Session_Timeout_Default;
                  }
                }
  
                /* Ensure the timeout is in centiseconds, but keep half the value */
                /* to avoid having to say "server_timeout / 2" for the inter-ping */
                /* delay elsewhere.                                               */
  
                s->server_timeout *= 50;
  
                dprintf(("State_1,RTSP_6", "status_proceed_receiving: New session '%s', timeout %d\n", s->server_session ? s->server_session : "<out of memory>", s->server_timeout));
              }
            }

            /* Have we read the entire response? */

            if (s->data_to_read == 0)
              break;
          }
        }
      }

      if (ret == 0)
      {
        /* Give up reading more data if 0 was returned. */

        break;
      }
      else if (errno != EWOULDBLOCK)
      {
        s->state  = protostate_ERROR_READ;
        s->err_no = errno;
        *repeat   = true;

        dprintf(("State_0,RTSP_0,Error_0", "status_proceed_receiving: Error = %d\n", errno));
      }
      else
      {
        /* Check timeout */

        if (utils_time_difference(s->last, now) > Headers_Timeout_General)
        {
          s->state = protostate_ERROR_TIMEOUT;
          *repeat  = true;
        }
        else if (s->callout_set == 0)
        {
          dprintf(("State_1,RTSP_6", "status_proceed_receiving: Setting a %dcs callout for receive timeout\n", Session_State_Retry));

          s->callout_set = 1;
          timeout(status_proceed_on_callout, s, Session_State_Retry);
        }
      }

      return false;
    }
  }

  /* If we get here, it is because we have decided that we have read the */
  /* entire response.                                                    */

  /* Force a terminator at the end - we're expecting no binary data so */
  /* this ensures correct termination and makes life easier later.     */

  s->data[s->data_len] = '\0'; /* Correct as data_len is always 1 byte behind actual allocation */

  #ifdef DUMP_HEADERS_TO_CACHEFS
  {
    FILE * f = fopen(DUMP_HEADERS_TO_CACHEFS, "ab");

    if (f != NULL)
    {
      fprintf(f, "RECEIVE (%p):\r\n", s);
      fwrite(s->data, 1, s->data_len, f);
      fclose(f);
    }
  }
  #endif

  #ifdef TRACE
  {
    char * e;
    char * p;
    char   c;

    /* Dump out one line at a time, since DebugLib will go wrong if you output more than about 1K at once */
    
    dprintf(("State_1,RTSP_1", "status_proceed_receiving: Receive complete with %d bytes\n--- Response ---\n", s->data_len));
    e = s->data;
    do
    {
      for (p = e; (*e != 0) && (*e != '\n'); e++);
      c = *e;
      *e = 0;
      dprintf(("State_1,RTSP_1", "%s\n", p));
      *e++ = c;
    }
    while (c != 0);
    dprintf(("State_1,RTSP_1", "--- End ---\n"));
  }
  #endif

  s->reported_state |= VC_Status_NewStatus | VC_Status_MoreInformationAvailable;
  s->state = protostate_COMPLETED;

  *repeat = true;
  return false;
}

/**************************************************************/
/* status_proceed_pumping()                                   */
/*                                                            */
/* State machine handler for a pumping (data movement) state. */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_pumping(session * s, bool * repeat)
{
  dprintf(("State_0", "status_proceed_pumping: Pumping\n"));

  return false;
}

/**************************************************************/
/* status_proceed_completed()                                 */
/*                                                            */
/* State machine handler for a completed state (tidy up).     */
/*                                                            */
/* Parameters: Pointer to a session structure for this state; */
/*                                                            */
/*             Pointer to a boolean, in which true is         */
/*             written to go around the state table again,    */
/*             else the contents are unaltered.               */
/*                                                            */
/* Returns:    True if the state table should be exitted      */
/*             immediately, false to proceed normally.        */
/**************************************************************/

static bool status_proceed_completed(session * s, bool * repeat)
{
  _kernel_oserror * e;

  dprintf(("State_0", "status_proceed_completed: Completed.\n"));

  /* We may have to send another command */

  if (s->next_command_cb)
  {
    /* If a play mode change was pending, note that it has now occurred. */

    if (s->change_pending)
    {
      if (s->parent == NULL && s->response_code == 200)
      {
        play_mode_changed(s, s->next_playmode);
      }

      s->change_pending = 0;
    }

    e = (s->next_command_cb)(s);

    if (e != NULL)
    {
      if (s->destruct)
      {
        session_free_item(s);
        return true;
      }
      else
      {
        final.errnum = e->errnum;
        strncpy(final.errmess, e->errmess, sizeof(final.errmess));

        s->state = protostate_ERROR_VCPN;
        *repeat  = true;
      }
    }

    return false;
  }
  else if (s->destruct)
  {
    /* This session is due to self-destruct. Either this is a GET_PARAMETER */
    /* child session completing, or a session being torn down.              */

    #ifdef CLIENT_LOOPING
    /* To support client looping properly we would need to do some extra    */
    /* work here to spot the replay completing, and call play_mode_changed  */
    /* for the parent.                                                      */
    #endif

    session_free_item(s);
    return true;
  }
  else if (s->id != 0)
  {
    bool prepare = false;

    /* We're more or less finished, just need to let Video Control */
    /* know about the status change.                               */

    if (s->play_record != NULL && s->started == 0 && s->response_code == 200)
      prepare = true;

    dprintf(("","status_proceed_completed: Calling VideoControl_ProtocolNotify (prepare=%d)\n", prepare));

    e = _swix(VideoControl_ProtocolNotify,
              _INR(0,4),

              0,
              s->id,
              VideoControlProtocolNotifyNewStatus,
              prepare ? VC_ProtocolNotify_NewStatus_Prepare : 0,
              s->play_record);

    if (e != NULL)
    {
      final.errnum = e->errnum;
      strncpy(final.errmess, e->errmess, sizeof(final.errmess));

      s->state = protostate_ERROR_VCPN;
      *repeat  = true;

      return false;
    }

    /* Things seem to be working */

    if (s->change_pending)
    {
      if (s->parent == NULL && s->response_code == 200)
        play_mode_changed(s, s->next_playmode);

      s->change_pending = 0;
    }

    if (prepare)
      s->started = 1;
  }

  /* If we got here, we've definitely finished the whole sequence correctly */
  /* so it's safe to reset the state.                                       */

  s->state = protostate_INITIAL;

  return false;
}

/**************************************************************/
/* status_record_error()                                      */
/*                                                            */
/* Record an error from some external routine (e.g. a PLAY    */
/* command being sent after a delay owing to an in-progress   */
/* background operation on the same socket).                  */
/*                                                            */
/* Parameters: Pointer to the session structure relevant to   */
/*             the effected session;                          */
/*                                                            */
/*             Pointer to an error block with the error       */
/*             details held in it.                            */
/**************************************************************/

void status_record_error(session * s, _kernel_oserror * e)
{
  final.errnum = e->errnum;
  strncpy(final.errmess, e->errmess, sizeof(final.errmess));

  s->state = protostate_ERROR_VCPN;

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  return;
}

/**************************************************************/
/* status_check_error()                                       */
/*                                                            */
/* Examine a session structure to see if there's an error     */
/* state and if so return an appropriate _kernel_oserror.     */
/*                                                            */
/* Parameters: Pointer to the session structure to examine.   */
/*                                                            */
/* Returns:    NULL or pointer to a filled in _kernel_oserror */
/*             if the session was in an error state.          */
/**************************************************************/

_kernel_oserror * status_check_error(session * s)
{
  _kernel_oserror * e   = NULL;
  int               use = rtspmb_ERROR_CONNECT_GENERAL;

  switch (s->state)
  {
    /* Error states: Various things went wrong... */

    case protostate_ERROR_READ:
    case protostate_ERROR_WRITE:
    {
      /* For a socket with a railed read or write we should do a   */
      /* getsockopt call to extract something more meaningful than */
      /* will be present in the session's copy of errno...         */

      if (s->sd >= 0)
      {
        int err, so, size = sizeof(int);

        err = getsockopt(s->sd, SOL_SOCKET, SO_ERROR, &so, &size);
        if (err == 0) s->err_no = so;
      }

      /* Read or write error? */

      if (s->state == protostate_ERROR_READ) use = rtspmb_ERROR_CONNECT_READ;
      else                                   use = rtspmb_ERROR_CONNECT_WRITE;

    } /* (...and drop through to next set of conditions) */

    case protostate_ERROR:
    case protostate_ERROR_DEAD:
    case protostate_ERROR_CONNECTION:
    case protostate_ERROR_NO_TOKEN:
    case protostate_ERROR_NOT_IMPLEMENTED:
    {
      char         en[16];
      const char * message;
      char       * dup;

      /* If there's nothing recorded in the session's copy of errno */
      /* or it's out of range, report the number; else report a     */
      /* message from the errno table in Unixlib.                   */

      if (s->err_no == ENOERROR || s->err_no >= sys_nerr)
      {
        sprintf(en, "%d", s->err_no);
        message = en;
      }
      else message = sys_errlist[s->err_no];

      /* Aesthetics - ensure first letter of sub-message is lower case */

      dup = Strdup(message);
      if (dup != NULL && isupper(dup[0])) dup[0] = tolower(dup[0]);

      /* Generate the full report */

      e = make_error(use, 1, dup == NULL ? message : dup);
      free(dup);
    }
    break;

    case protostate_ERROR_MEM:
    {
      e = make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
    }
    break;

    case protostate_ERROR_TIMEOUT:
    {
      e = make_error(rtspmb_ERROR_CONNECT_TIMEOUT, 0);
    }
    break;

    case protostate_ERROR_DNS:
    {
      char * host;

      if (s->url && s->url->host && *s->url->host) host = s->url->host;
      else                                         host = "<?>";

      e = make_error(rtspmb_ERROR_CONNECT_DNS, 1, host);
    }
    break;

    case protostate_ERROR_VCPN:
    {
      e = &final;
    }
    break;
  }

  #ifdef TRACE

    if (e != NULL && strlen(e->errmess) < (sizeof(e->errmess) - 12))
    {
      sprintf(strchr(e->errmess, '\0'), " (%08X)", (unsigned int) s);
    }

  #endif

  return e;
}
