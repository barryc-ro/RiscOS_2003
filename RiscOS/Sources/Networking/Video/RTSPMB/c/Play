/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Play.                            */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/*          08-Mar-2002 (JRB): Updated for MediaBase 6.       */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>

#include <swis.h>
#include <AsmUtils/modulefp.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Response.h"
#include "RTSPMErrors.h"
#include "Session.h"
#include "Status.h"
#include "Utils.h"

#include "Play.h"

/* Local structures and enumerations */

typedef enum play_state
{
  play_state_undefined = 0,
  play_state_set_playmode,
  play_state_play
}
play_state;

/* Local definitions */

#define Play_Read_TimeCode_Timer    (100)
#define Play_Initial_TimeCode_Timer (5)
#define Play_TimeCode_Margin        (275)

/* Local functions - miscellaneous */

static _kernel_oserror * play_return_emulated_response       (session * s, unsigned int response_code);
static _kernel_oserror * play_alter_playback_characteristics (session * s, int playmode);
#ifdef CLIENT_LOOPING
static _kernel_oserror * play_replay                         (session * s);
#endif

/* Local functions - general command sending assistance */

static _kernel_oserror * play_preamble                 (session * s);
static _kernel_oserror * play_send                     (session * s);

/* Local functions - stuff called from the state machine as callback */
/* functions during execution of a command chain                     */

static _kernel_oserror * play_send_set_playmode        (session * s);
static _kernel_oserror * play_send_play                (session * s);
static _kernel_oserror * play_send_state_command       (session * s, play_state state);

/* Local functions - stuff used to build a set of command headers */
/* ready for sending out                                          */

static int               play_process_speed            (const char * scale);
static int               play_determine_playmode       (const char * scale);
static _kernel_oserror * play_build_pause              (session * s);
static _kernel_oserror * play_build_set_playmode       (session * s);
static _kernel_oserror * play_build_play               (session * s);
static _kernel_oserror * play_build_play_or_pause      (session * s, bool force_pause);
static bool              play_filter_range             (session * s, const char * range, int * start_pos, int * end_pos);
static void              play_reconstruct_range_header (session * s, char * temp);

/* Local functions - floating point code used within */

static int               play_strtofi                  (const char *str, const char **endptr, int factor);
static unsigned int      play_get_trick_stream_npt     (session * s, unsigned int npt);
#ifdef CLIENT_LOOPING
static void              play_copy_frame_info          (session * dst, session * src);
#endif

#if 0
  static unsigned int    play_get_frame_number         (session * s, unsigned int npt);
#endif

/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement RTSPMB_Play. See the Video Control               */
/* specification, 2501,817/FS, for more.                      */
/*                                                            */
/* This function always sends at least one command, which     */
/* is either PAUSE for zero speed or for a trick play mode    */
/* transition, or SET_PLAYMODE or PLAY if playback is         */
/* starting for the first time. A command chain is set up     */
/* which is dealt with by the state machine calling back into */
/* play_send_play or play_send_set_playmode.                  */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  session * s = session_find_by_id(r->r[1]);
  int       new_playmode;

  dprintf(("Entry_0", "play_play: Called\n"));
  dprintf(("Entry_1", " r0=%x\n",r->r[0]));
  dprintf(("Entry_1", " r1=%x\n",r->r[1]));
  dprintf(("Entry_1", " r2='%s'\n",r->r[2] ? (char *)r->r[2] : "NULL"));
  dprintf(("Entry_1", " r3='%s'\n",r->r[3] ? (char *)r->r[3] : "NULL"));
  #ifdef TRACE
  if ((r->r[0] & VC_Play_R4ThroughR7AreValid) != 0)
  {
    dprintf(("Entry_1", " r4='%s'\n",r->r[4] ? (char *)r->r[4] : "NULL"));
    dprintf(("Entry_1", " r5=%x\n",r->r[5]));
    dprintf(("Entry_1", " r6=%x\n",r->r[6]));
    dprintf(("Entry_1", " r7=%x\n",r->r[7]));
  }
  #endif

  /* Do the basic checks to see that everything is OK. */

  RetError(play_preamble(s));

  /* Ensure everything is reset for a new command. */

  session_reset_session(s);

  /* Copy R2 and R3 away */

  free(s->range_record);
  s->range_record = Strdup(r->r[2] == 0 ? "" : (char *) r->r[2]);

  free(s->play_record);
  s->play_record = Strdup(r->r[3] == 0 ? "" : (char *) r->r[3]);

  if (s->play_record == NULL || s->range_record == NULL)
  {
    dprintf(("", "play_play: Play or range records NULL -> out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Is there a mapping between the request and the server? Not if this */
  /* is a slow motion play request; in that case return a 501 response. */
  /* Also return a 501 response for fast forward/rewind of MPEG1, since */
  /* we can't manage that at the moment either.                         */

  {
    int type = play_process_speed(s->play_record);

    if (
        type == MPEGCtrl_MCRS_Trick_SFWD || type == MPEGCtrl_MCRS_Trick_SRWD ||
        (s->asset_type == assettype_MPEG1 && (type == MPEGCtrl_MCRS_Trick_FRWD || type == MPEGCtrl_MCRS_Trick_FFWD))
       )
    {
      return play_return_emulated_response(s, 501);
    }
  }

  /* Parse the range */

  if (!play_filter_range(s, s->range_record, &s->from, &s->to))
  {
    /* Range not recognised - return a 457 response */

    return play_return_emulated_response(s, 457);
  }

  /* Work out the command order required. Possibilities are:                */
  /* 1) PAUSE                                                               */
  /*   To pause on any version of MediaBase.                                */
  /* 2) PLAY                                                                */
  /*   To start playing or resume from pause on MediaBase 6 with MPEG2.     */
  /* 3) SET_PLAYMODE; PLAY                                                  */
  /*   To start playing MPEG1 on MediaBase 6; to start playing or resume    */
  /*   from pause on MediaBase 5 or earlier.                                */
  /* 4) PAUSE; PLAY                                                         */
  /*   To change play mode on MediaBase 6 with MPEG2.                       */
  /* 5) PAUSE; SET_PLAYMODE; PLAY                                           */
  /*   To change play mode (or jump to a new position in the same mode) on  */
  /*   MediaBase 5 or earlier, or with MPEG1 on MediaBase 6.                */

  new_playmode = play_determine_playmode(s->play_record);

  if (new_playmode == Play_MB_Trick_Freeze)
  {
    /* Going to pause mode - issue PAUSE */

    dprintf(("", "play_play: Building PAUSE to pause\n"));

    s->next_command_cb = NULL;

    RetError(play_build_pause(s));
  }
  else if (
            s->started != 0 &&
            s->playmode != Play_MB_Trick_Freeze &&
            (new_playmode != s->playmode || s->server_majorver < 6)
          )
  {
    /* Changing play mode (or jumping to a new position in the same mode     */
    /* with MediaBase 5 or earlier) - issue PAUSE (then maybe SET_PLAYMODE), */
    /* then PLAY.                                                            */

    dprintf(("", "play_play: Building PAUSE to change play mode\n"));

    /* When changing play mode, treat no 'from' as from 'now' */

    if (s->from == Play_MB_Time_Unspecified)
      s->from = Play_MB_Time_Now;

    if (s->server_majorver >= 6 && s->asset_type != assettype_MPEG1)
      s->next_command_cb = play_send_play;
    else
      s->next_command_cb = play_send_set_playmode;

    RetError(play_build_pause(s));
  }
  else
  {
    /* Starting, resuming from pause, or jumping within same play mode */
    /* (for server version 6 or later - earlier versions do not allow  */
    /* this without doing a PAUSE first.)                              */
    /* Issue SET_PLAYMODE if required, then PLAY.                      */

    if (s->started == 0)
    {
      if (s->from == Play_MB_Time_Unspecified || s->from == Play_MB_Time_Now)
      {
        /* If play has not started, treat no 'from' or from 'now' as from */
        /* the start (for forward play) or end (for reverse play)         */

        if (new_playmode == Play_MB_Trick_FRWD) s->from = s->duration;
        else                                    s->from = 0;
      }
    }
    else if (s->playmode == Play_MB_Trick_Freeze)
    {
      /* When resuming from pause, treat no 'from' as from 'now' */

      if (s->from == Play_MB_Time_Unspecified)
        s->from = Play_MB_Time_Now;
    }
    else
    {
      /* If playing in same mode as before, treat from 'now' as no 'from'  */

      if (s->from == Play_MB_Time_Now)
        s->from = Play_MB_Time_Unspecified;
    }

    if (
        s->multicast != 0 ||
        (s->server_majorver >= 6 && s->asset_type != assettype_MPEG1)
       )
    {
      #ifdef TRACE
        if (s->multicast != 0) dprintf(("", "play_play: Building PLAY for simulated multicast start\n"));
        else                   dprintf(("", "play_play: Building PLAY for MediaBase 6 MPEG2\n"));
      #endif

      s->next_command_cb = NULL;
  
      RetError(play_build_play(s));
    }
    else
    {
      dprintf(("", "play_play: Building SET_PLAYMODE\n"));
  
      s->next_command_cb = play_send_play;
  
      RetError(play_build_set_playmode(s));
    }
  }

  /* Everything is built and ready to go. Now check to make sure that no  */
  /* background command is in progress. If it is we have to delay sending */
  /* the new command until the background command has completed.          */

  /* Remove the GET_PARAMETER pinging callout */

  if (s->gp_set != 0)
  {
    s->gp_set = 0;
    untimeout(getparam_proceed_on_callout, s);
  }

  #ifdef CLIENT_LOOPING
  /* Remove the looping callout */

  /* The implications of a replay callout occuring at this stage need */
  /* to be thought through a little more.                             */
  if (s->loop_ready != 0)
  {
    s->loop_ready = 0;
    untimeout(play_replay_on_callout, s);
  }
  #endif

  /* Is a background command in progress? */

  if (s->child != NULL)
  {
    dprintf(("", "play_play: Having to wait for background command\n"));

    /* We have to wait */

    s->play_wait = 1;
    timeout(play_retry_delayed_on_callout, s, Session_State_Retry);

    dprintf(("", "play_play: Play retry timer is set, exiting play_play\n"));

    return NULL;
  }

  /* Send the command */

  dprintf(("", "play_play: Successful; exitting through play_send\n"));

  return play_send(s);
}

/**************************************************************/
/* play_preamble()                                            */
/*                                                            */
/* For a given session, check the pointer is not NULL, that   */
/* no command is currently in progress and that there is a    */
/* server session.                                            */
/*                                                            */
/* This is normally the first thing done in a function that   */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to the session struct (may be NULL).   */
/*                                                            */
/* Returns:    An error if there is some problem with using   */
/*             the session for a new PLAY command, else NULL. */
/**************************************************************/

static _kernel_oserror * play_preamble(session * s)
{
  dprintf(("", "play_preamble: Called for &%08X\n", (int) s));

  if (s == NULL)
  {
    dprintf(("", "play_preamble: ID not found\n"));

    return make_error(rtspmb_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (
       s->state == protostate_DNS       ||
       s->state == protostate_CONNECTED ||
       s->state == protostate_SENDING   ||
       s->state == protostate_RECEIVING ||
       s->state == protostate_PUMPING   ||
       s->play_wait == 1
     )
  {
    dprintf(("", "play_preamble: In progress\n"));

    return make_error(rtspmb_ERROR_IN_PROGRESS, 0);
  }

  if (s->server_session == NULL)
  {
    dprintf(("", "play_preamble: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Be warned - don't do anything destructive to background */
  /* commands here (e.g. don't call session_reset_session)   */

  dprintf(("", "play_preamble: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_return_emulated_response()                            */
/*                                                            */
/* Return an emulated response to a play command.             */
/*                                                            */
/* Parameters: Pointer to the session structure.              */
/*                                                            */
/* Returns:    NULL or pointer to error.                      */
/**************************************************************/

static _kernel_oserror * play_return_emulated_response(session * s, unsigned int response_code)
{
  rtsp_header * r;

  if (response_code == 457) r = response_build(s->headers, Headers_Supported_Prefix_457);
  else                      r = response_build(s->headers, Headers_Supported_Prefix_501);
  
  if (r == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  
  headers_free_headers(&s->headers);
  
  s->next_command_cb = NULL;
  s->headers         = r;
  s->state           = protostate_COMPLETED;
  s->response_code   = response_code;
  s->reported_state  = VC_Status_ConnectionEstablished |
                       VC_Status_NewStatus;
  
  s->data_len = headers_construct_specific_header_buffer(s->headers,
                                                         &s->data,
                                                         0,
                                                         1);
  
  if (s->data_len != 0) s->reported_state |= VC_Status_MoreInformationAvailable;
  
  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }
  
  return NULL;
}

/**************************************************************/
/* play_process_speed()                                       */
/*                                                            */
/* Process a string which should contain a number which may   */
/* be negative or a decimal fraction, e.g. "-0.4", "55",      */
/* ".4" but not (say) "1/3" or "    65".                      */
/*                                                            */
/* Parameters: Pointer to the string. If NULL, "1" is used.   */
/*                                                            */
/* Returns:    An int containing an indication of play mode   */
/*             within the string; see MPEGCtrl.h.             */
/**************************************************************/

static int play_process_speed(const char * scale)
{
  modulefp_buf buf;
  int          n;
  const char * endp;

  if (scale == NULL || *scale == '\0')
    return MPEGCtrl_MCRS_Trick_Play;

  modulefp_enable(&buf);
  n = play_strtofi(scale, &endp, 100);
  modulefp_disable(&buf);

  if (n <= -100)     return MPEGCtrl_MCRS_Trick_FRWD; /* scale <= -1.0 */
  if (n < 0)         return MPEGCtrl_MCRS_Trick_SRWD; /* -1.0 < scale < 0 */
  if (n > 100)       return MPEGCtrl_MCRS_Trick_FFWD; /* scale >= 1.0 */
  if (n == 100)      return MPEGCtrl_MCRS_Trick_Play; /* scale == 1.0 */
  if (n > 0)         return MPEGCtrl_MCRS_Trick_SFWD; /* 0 < scale < 1.0 */
  if (endp == scale) return MPEGCtrl_MCRS_Trick_Play; /* Invalid string */

  return MPEGCtrl_MCRS_Trick_Freeze;                  /* scale == 0 */
}

/**************************************************************/
/* play_determine_playmode()                                  */
/*                                                            */
/* Determine the MediaBase play mode from a playback rate     */
/* string.                                                    */
/*                                                            */
/* Parameters: Pointer to the string. If NULL, "1" is used.   */
/*                                                            */
/* Returns:    An int containing an indication of play mode   */
/*             within the string; see play.h.                 */
/**************************************************************/

static int play_determine_playmode(const char * scale)
{
  int mode;
  
  /* Rather than modify play_process_speed to spit out MediaBase stuff directly, */
  /* the full accuracy of play methods is kept, in case future MediaBase servers */
  /* support features missing at the time of writing (e.g. SFWD play).           */
  
  switch (play_process_speed(scale))
  {
    case MPEGCtrl_MCRS_Trick_FFWD:   mode = Play_MB_Trick_FFWD;   break;
    case MPEGCtrl_MCRS_Trick_SFWD:   mode = Play_MB_Trick_Play;   break; /* No SFWD on MediaBase */
    case MPEGCtrl_MCRS_Trick_Freeze: mode = Play_MB_Trick_Freeze; break;
    case MPEGCtrl_MCRS_Trick_FRWD:   mode = Play_MB_Trick_FRWD;   break;
    case MPEGCtrl_MCRS_Trick_SRWD:   mode = Play_MB_Trick_FRWD;   break; /* No SRWD on MediaBase */
  
    default:
    case MPEGCtrl_MCRS_Trick_Play:   mode = Play_MB_Trick_Play;   break;
  }
  
  return mode;
}

/**************************************************************/
/* play_retry_delayed_on_callout()                            */
/*                                                            */
/* Retry a delayed foreground command that was waiting for a  */
/* background command to complete.                            */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_retry_delayed_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("", "play_retry_delayed_on_callout: Called, dying flag is %d\n", s->dying));

  if (s->dying != 0) return;

  if (s->play_wait != 0)
  {
    /* Is there an in-transit foreground or background command already? */

    if (s->state != protostate_INITIAL)
    {
      /* Foreground command in progress! Should never happen... Abandon */
      /* this wait state.                                               */

      dprintf(("", "play_retry_delayed_on_callout: Foreground command already running!\n"));

      s->play_wait = 0;
    }
    else if (s->child != NULL)
    {
      /* Background command - wait for it to finish */

      dprintf(("", "play_retry_delayed_on_callout: Background command still running...\n"));

      timeout(play_retry_delayed_on_callout, s, Session_State_Retry);
    }
    else
    {
      _kernel_oserror * e;
      
      /* Clear to send the command */

      s->play_wait = 0;

      dprintf(("", "play_retry_delayed_on_callout: Clear to try again, calling play_send().\n"));

      e = play_send(s);

      if (e != NULL)
      {
        dprintf(("", "play_retry_delayed_on_callout: Error &%08X, '%s'\n", e->errnum, e->errmess));

        status_record_error(s, e);
      }
    }
  }
}

#ifdef CLIENT_LOOPING

/* !!! IMPORTANT NOTE ABOUT CLIENT LOOPING !!! */

/* Client looping is compiled out at the moment because it is not working   */
/* correctly. If you want to reinstate it, you will have to address the     */
/* points listed below. The decision to leave this functionality out of     */
/* this version was based on the fact that fully supporting it adds a       */
/* relatively large amount of complication for relatively little gain.      */
/* After all, a client can easily do looping explicitly, without the        */
/* protocol module having to do lots of extra work on its behalf.           */
/*                                                                          */
/* The following things need to be done to support client looping:          */
/*                                                                          */
/* 1) status_proceed_completed() needs to call play_mode_changed() when the */
/* background PLAY completes. It won't currently since the s->destruct flag */
/* is set. This is necessary to make sure the stream is reset and state     */
/* updated. play_mode_changed() will update the state and set the timecode  */
/* reading callout on this session. This needs to be done on the parent     */
/* session instead.                                                         */
/*                                                                          */
/* 2) A record needs to be kept of the last explicit range. Currently       */
/* this will replay using the range from the last play call, but this       */
/* may have been 'now-' when switching from a trick play mode to            */
/* normal play. The module will instead need to keep a track of each        */
/* explicit start and end point specified and loop using these times.       */

/**************************************************************/
/* play_replay_on_callout()                                   */
/*                                                            */
/* A CallOut handler (see CallOut.h) which loops video        */
/* playback through play_replay.                              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_replay_on_callout(void * handle)
{
  session * s = (session *) handle;

  if (s->dying != 0) return;

  if (s->loop_ready != 0)
  {
    /* Is there an in-transit foreground or background command already? */

    if (s->state != protostate_INITIAL)
    {
      /* Foreground command - abandon this background operation */

      s->loop_ready = 0;
      return;
    }
    else if (s->child != NULL)
    {
      /* Background command - wait for it to finish */

      timeout(play_replay_on_callout, s, Session_State_Retry);
      return;
    }
    else
    {
      /* Clear to send the command */

      s->loop_ready = 0;
      play_replay(s);
    }
  }
}

/**************************************************************/
/* play_replay()                                              */
/*                                                            */
/* Issue an "in-the-background" PLAY command to loop video    */
/* playback at the client end.                                */
/*                                                            */
/* Parameters: Pointer to a session struct for the video to   */
/*             loop.                                          */
/**************************************************************/

_kernel_oserror * play_replay(session * s)
{
  _kernel_oserror * e;
  session         * new_s;

  dprintf(("", "play_replay: Called for %p\n", s));

  if (s->server_session == NULL)
  {
    dprintf(("", "play_replay: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Cancel any GET_PARAMETER manually - it won't be done automatically */
  /* as we're not resetting this session, we're spawning a new one      */

  if (s->gp_set != 0)
  {
    s->gp_set = 0;
    untimeout(getparam_proceed_on_callout, s);
  }

  /* This should never happen if called via. play_replay_on_callout... */

  if (s->child) session_free_item(s->child);

  /* Create a new session */

  e = session_new_session(&new_s);

  if (e)
  {
    dprintf(("", "play_replay: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  /* Can't just block copy the structure; have to be careful to take new */
  /* copies of vital strings, IDs, and so-on.                            */

  if (new_s != NULL)
  {
    new_s->id       = ++id_counter; /* See Global.h */
    new_s->vcid     = s->vcid;
    new_s->destruct = 1;

    new_s->parent   = s;
    s->child        = new_s;

    new_s->server_session = Strdup(s->server_session ? s->server_session : "");
    new_s->play_record    = Strdup(s->play_record    ? s->play_record    : "");
    new_s->range_record   = Strdup(s->range_record   ? s->range_record   : "");

    if (s->url->full != NULL)
    {
      (void) urlutils_return_description(s->url->full, &new_s->url);
    }
  }

  if (
       new_s                 == NULL ||
       new_s->server_session == NULL ||
       new_s->play_record    == NULL ||
       new_s->range_record   == NULL ||
       (
         s->url->full != NULL &&
         new_s->url   == NULL
       )
     )
  {
    dprintf(("", "play_replay: Out of memory for new_s or copied strings\n"));

    if (new_s != NULL) session_free_item(new_s);
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  new_s->server_majorver = s->server_majorver;
  new_s->server_timeout  = s->server_timeout;
  new_s->mpegid          = s->mpegid;
  new_s->playmode        = s->playmode;
  new_s->multicast       = s->multicast;

  new_s->approx_fps      = s->approx_fps;
  new_s->asset_type      = s->asset_type;
  new_s->duration        = s->duration;
  new_s->start_time      = s->start_time;
  new_s->end_time        = s->end_time;

  {
    modulefp_buf buf;

    modulefp_enable(&buf);
    play_copy_frame_info(new_s, s);
    modulefp_disable(&buf);
  }

  if ((new_s->server_majorver >= 6) && (new_s->asset_type != assettype_MPEG1))
  {
    new_s->next_command_cb = NULL;
    e = play_build_play(new_s);
  }
  else
  {
    new_s->next_command_cb = play_send_set_playmode;
    e = play_build_pause(new_s);
  }


  if (e != NULL)
  {
    dprintf(("", "play_replay: Error '%s' from play_build_pause\n", e->errmess));

    session_free_item(new_s);
    return e;
  }

  /* Open a connection to send the command down */

  if (s->sd == -1)
  {
    int port;

    if (s->url->port && *s->url->port) port = atoi(s->url->port);
    else                               port = RTSPMB_DefaultPort;

    s->sd = opensock(s->url->host,
                     port,
                     NULL,
                     &new_s->state,
                     -1);

    if (s->state == protostate_ERROR) s->err_no = -s->sd;
  }
  else new_s->state = protostate_CONNECTED;

  new_s->sd   = s->sd;
  new_s->last = utils_read_time();

  dprintf(("", "play_replay: Socket descriptor %d, state %d\n", new_s->sd, new_s->state));

  /* Set the state machine going to see errors and DNS stuff; */
  /* in addition, rerun it for the parent session to get      */
  /* another GET_PARAMETER scheduled.                         */

  new_s->callout_set = 1;
  timeout(status_proceed_on_callout, new_s, Session_State_Timer);

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  /* Finished */

  dprintf(("", "play_replay: Successful\n"));

  return NULL;
}

#endif

/**************************************************************/
/* play_send()                                                */
/*                                                            */
/* Once a session has been fully initialised with all the     */
/* data needed to send a command, kick off the send.          */
/*                                                            */
/* This is normally the last thing done in a function that    */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_send(session * s)
{
  int port;

  dprintf(("", "play_send: Called for &%08X\n", (int) s));

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  if (s->sd == -1)
  {
    s->sd = opensock(s->url->host,
                     port,
                     NULL,
                     &s->state,
                     -1);

    if (s->state == protostate_ERROR) s->err_no = -s->sd;
  }
  else s->state = protostate_CONNECTED;

  s->last = utils_read_time();

  dprintf(("", "play_send: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Set the state machine going to see errors and DNS stuff. The call */
  /* to session_reset_session should've cleared the callout but it     */
  /* never hurts to be sure (in future maybe stuff could go on in the  */
  /* background that could have set a callout between the reset and    */
  /* this part of the code).                                           */

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_send: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_set_playmode()                                   */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the second item in a chain of commands for the     */
/* server (the first must be PAUSE). The next command         */
/* callback is set to play_send_play. A command chain which   */
/* involves calling this function is always started inside    */
/* play_play.                                                 */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful PAUSE command.                      */
/**************************************************************/

static _kernel_oserror * play_send_set_playmode(session * s)
{
  dprintf(("", "play_send_set_playmode: Called for &%08X\n", (int) s));

  RetError(play_send_state_command(s, play_state_set_playmode));

  dprintf(("", "play_send_set_playmode: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_play()                                           */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the last item in a chain of commands for the       */
/* server and sends the actual PLAY command off. No further   */
/* callback function is set.                                  */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful SET_PLAYMODE command.               */
/**************************************************************/

static _kernel_oserror * play_send_play(session * s)
{
  dprintf(("", "play_send_play: Called for &%08X\n", (int) s));

  RetError(play_send_state_command(s, play_state_play));

  dprintf(("", "play_send_play: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_state_command()                                  */
/*                                                            */
/* Deal with the mechanics of building a relevant command and */
/* setting any required next command callback, for a chain of */
/* play-related commands for the server. This is only used    */
/* for second and subsequent commands - play_play deals with  */
/* the extra complexity of the initial command (not least,    */
/* working out exactly what command to send).                 */
/*                                                            */
/* Parameters: Pointer to a session structure;                */
/*                                                            */
/*             A play_state (see top of file) indicating the  */
/*             command to send, which influences what the     */
/*             next command callback is set to.               */
/**************************************************************/

static _kernel_oserror * play_send_state_command(session * s, play_state state)
{
  dprintf(("", "play_send_state_command: Called\n"));

  RetError(play_preamble(s));

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Build the command */

  switch(state)
  {
    case play_state_set_playmode:
    {
      dprintf(("", "play_send_state_command: SET_PLAYMODE\n"));

      /* Build the SET_PLAYMODE command */

      RetError(play_build_set_playmode(s));
      s->next_command_cb = play_send_play;
    }
    break;

    case play_state_play:
    {
      dprintf(("", "play_send_state_command: PLAY/PAUSE\n"));

      /* Build the PLAY or PAUSE command (should always be PLAY in practice) */

      RetError(play_build_play_or_pause(s, 0));
      s->next_command_cb = NULL; /* session_reset_session should do that, but just in case... */
    }
    break;

    default:
    {
      dprintf(("", "play_send_state_command: Unknown command state!\n"));

      return make_error(rtspmb_ERROR_UNKNOWN_COMMAND_STATE, 0);
    }
    break;
  }

  /* Send the command */

  return play_send(s);
}

/**************************************************************/
/* play_build_pause()                                         */
/*                                                            */
/* Build a forced PAUSE command in a session, ignoring the    */
/* play_record details of required speed. This is intended    */
/* for use in trick play mode transitions where three         */
/* commands (PAUSE, SET_PLAYMODE then PLAY) must be sent.     */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_pause(session * s)
{
  return play_build_play_or_pause(s, true);
}

/**************************************************************/
/* play_build_set_playmode()                                  */
/*                                                            */
/* Build a SET_PLAYMODE command inside the given session      */
/* based on the play_record and URL details inside it.        */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Assumes:    The play_record field does not indicate zero   */
/*             speed (pause).                                 */
/**************************************************************/

static _kernel_oserror * play_build_set_playmode(session * s)
{
  char * playmode = NULL;
  bool   fail     = false;

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;
  else
  {
    playmode = malloc(sizeof(Headers_HeaderValue_ContentLength) - 1); /* We want the terminator included; the -1 is there as '%d' will end up as a single digit number */

    /* The content length header value is a bit of a hack; it must be the last */
    /* item as it holds a double CR LF and a "Playmode:" entry for the body    */
    /* text of our SET_PLAYMODE command. It's a nasty way of doing it, but     */
    /* very cheap in code terms.                                               */

    if (playmode != NULL)
    {
      s->next_playmode = play_determine_playmode(s->play_record);

      sprintf(playmode,
              Headers_HeaderValue_ContentLength,
              s->next_playmode);
    }
  }

  if (playmode == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_SetPlayMode,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Content type for the play mode etc. */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentType,
                               Headers_HeaderValue_ContentType)
            == NULL
          )
          fail = true;

  /* Content length - THIS MUST BE THE LAST ITEM ADDED */

  else
  {
//    _kernel_oserror * e;
//    int               opts     [4];
//    char              temp     [1024]; //// Fix me, temporary Friday hack; use malloc
//    unsigned int      frame;
//
//    opts[0] = vc_tags_npt;
//    opts[1] = 1;
//    opts[2] = 0;
//    opts[3] = vc_tags__end;
//
//    e = _swix(VideoControl_ProtocolOptions,
//              _INR(0,2),
//
//              0,
//              s->vcid,
//              opts);
//
//    if (e != NULL) frame = 0;
//    else           frame = (unsigned int) opts[2];
//
//    /* If that fails, try MPEGVideo_ReadParameters for time code */
//
//    if (frame == 0)
//    {
//      unsigned int tc;
//
//      e = _swix(MPEGVideo_ReadParameters,
//                _INR(0,2) | _OUT(1),
//
//                0,
//                0,
//                0,
//
//                &tc);
//
//      /* This is in hours, minute and seconds - convert to seconds */
//
//      if (tc != 0xffffffff) /* (indicates unknown time) */
//      {
//        frame =           ((tc & 0x000FC0) >> 6)  +
//                60 *      ((tc & 0x03F000) >> 12) +
//                60 * 60 * ((tc & 0xFC0000) >> 18);
//      }
//    }
//
//    /* Convert the time in seconds (currently held in 'frame') */
//    /* into a real - if approximate! - frame number            */
//
//    {
//      modulefp_buf buf;
//
//      modulefp_enable(&buf);
//      frame = play_get_frame_number(s, frame);
//      modulefp_disable(&buf);
//    }
//
//    sprintf(temp,
//            "Playmode:%d\r\n", //Frame:%d\r\n",
//            s->playmode);      //,
//                               //frame);
//
//    sprintf(playmode,
//            "%d\r\n\r\n%s",
//            strlen(temp),
//            temp);

    if (
         headers_add_header(&s->headers,
                            Headers_HeaderName_ContentLength,
                            playmode)
         == NULL
       )
       fail = true;
  }

  /* Did anything fail? */

  free(playmode);

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_build_play()                                          */
/*                                                            */
/* Build a PLAY command inside the given session based on     */
/* the play_record and URL details inside it. If play_record  */
/* shows the speed to be zero, PAUSE is sent instead.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_play(session * s)
{
  return play_build_play_or_pause(s, false);
}

/**************************************************************/
/* play_build_play_or_pause()                                 */
/*                                                            */
/* Service function originally built for play_build_play and  */
/* play_build_pause.                                          */
/*                                                            */
/* Builds a PLAY or PAUSE command inside the given session    */
/* based either on the play_record and URL details inside it, */
/* or just on the URL information if play_record is to be     */
/* ignored (PAUSE commands only).                             */
/*                                                            */
/* Parameters: Pointer to a relevant session structure;       */
/*                                                            */
/*             true to ignore play_record and send PAUSE,     */
/*             false to send PLAY or PAUSE according to the   */
/*             play_record setting.                           */
/**************************************************************/

static _kernel_oserror * play_build_play_or_pause(session * s, bool force_pause)
{
  char * scale;
  bool   play;
  bool   fail   = false;

  /* Determine the new MediaBase playmode */

  if (force_pause)
    s->next_playmode = Play_MB_Trick_Freeze;
  else
    s->next_playmode = play_determine_playmode(s->play_record);

  /* Decide what scale setting to ask MediaBase for */

  if (s->server_majorver >= 6)
  {
    switch (s->next_playmode)
    {
      case Play_MB_Trick_Play:
        scale = "1";
        break;
      case Play_MB_Trick_FFWD:
      case Play_MB_Trick_FRWD:
        scale = s->play_record;
        break;
      default:
        scale = NULL;
    }
  }
  else
  {
    scale = NULL;
  }

  /* Convert range times of 'now' to current NPT */

  if (s->from == Play_MB_Time_Now)
    s->from = play_read_current_npt(s);

  if (s->to == Play_MB_Time_Now)
    s->to = play_read_current_npt(s);


  play = (s->next_playmode != Play_MB_Trick_Freeze);

  /* Start adding headers */

  if      (
            headers_add_header(&s->headers,
                               play ? Headers_CommandName_Play : Headers_CommandName_Pause,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Scale header */

  else if (
            scale != NULL &&
            headers_add_header(&s->headers,
                               Headers_HeaderName_Scale,
                               scale)
            == NULL
          )
          fail = true;

  /* No sync marks please */
  /* Omitting the 'SyncMark' header should prevent sync marks with all versions     */
  /* of MediaBase (though sometimes it didn't with 4.01 and some revisions of 5,    */
  /* but that is a server bug with patches available to fix it.)                    */
  /* With MediaBase 6, you must leave out the 'SyncMark' header in order to prevent */
  /* sync marks between assets in a sequence.                                       */
/*  else if (
            play &&
            headers_add_header(&s->headers,
                               Headers_HeaderName_SyncMark,
                               Headers_HeaderValue_SyncMark)
            == NULL
          )
          fail = true;

*/

  /* Range */

  else if (
            play &&
            s->multicast == 0 &&
            (s->from != Play_MB_Time_Unspecified || s->to != Play_MB_Time_Unspecified)
            )
  {
    char new_range[sizeof("npt=0-0") + 48]; /* (+48 ensures we overestimate for up to 4 digits) */

    play_reconstruct_range_header(s, new_range);

    if (
         headers_add_header(&s->headers,
                            Headers_HeaderName_Range,
                            new_range)
         == NULL
       )
       fail = true;
  }

  /* Add the session header */

  if (
       fail == false &&
       headers_add_header(&s->headers,
                          Headers_HeaderName_Session,
                          s->server_session)
       == NULL
     )
     fail = true;

  if (!fail)
  {
    /* Note that a play change is pending. A PLAY without a from time */
    /* does not cause a change - in fact it doesn't do anything, but  */
    /* we still send it to the server anyway, so that the client sees */
    /* the server response.                                           */

    if (!play || s->from != Play_MB_Time_Unspecified)
      s->change_pending = 1;
  }

  /* Did anything fail? */

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_alter_playback_characteristics()                      */
/*                                                            */
/* Set speed and reset parameters for a play mode change.     */
/*                                                            */
/* Parameters: Pointer to the session structure for the       */
/*             playback stream in question;                   */
/*                                                            */
/*             Play mode to consider (this allows override of */
/*             the play mode recorded in the session).        */
/**************************************************************/

static _kernel_oserror * play_alter_playback_characteristics(session * s, int playmode)
{
  _kernel_oserror * e = NULL;
  unsigned int      flags;

  /* MediaBase 4.0.1 and 5:                                                      */
  /* The MediaBase server is simple. It streams, say, an MPEG 2 transport stream */
  /* normally, but in trick mode just spews elementary video data out. Eek! Our  */
  /* system can't really handle that. The only thing to do is to leave the       */
  /* decode running whilst we talk to the server to try and exhaust any data in  */
  /* buffers, and then do an immediate reset on the PLAY command's OK response,  */
  /* to try and get stream-start style auto detection running to redetermine     */
  /* the stream type.                                                            */
  /*                                                                             */
  /* MediaBase 6:                                                                */
  /* The server no longer sends out elementary streams for trick mode, it sends  */
  /* out a transport stream instead. Unfortunately it still doesn't give us any  */
  /* easy way of detecting the transition in the stream, so we still have to do  */
  /* a reset on the OK response as before.                                       */

  dprintf(("", "play_alter_playback_characteristics called with playmode %d\n", playmode));

  if (s->mpegid != 0)
  {
    if (playmode == Play_MB_Trick_Freeze)
    {
      /* Immediate set speed to 0 */

      e = _swix(MPEGControl_SetSpeed,
                _INR(0,2),
    
                0,
                s->mpegid,
                0);
    }
    else
    {
      if (playmode == Play_MB_Trick_Play)
      {
        /* Immediate set speed to 1 */

        e = _swix(MPEGControl_SetSpeed,
                  _INR(0,2),
    
                  0,
                  s->mpegid,
                  1);

        /* Normal play - flag video and audio */

        flags = MPEGCtrl_MCRS_VideoPresent |
                MPEGCtrl_MCRS_AudioPresent;
      }
      else
      {
        /* Trick play - flag a trick play stream */

        flags = MPEGCtrl_MCRS_VideoPresent |
                MPEGCtrl_MCRS_NewIsTrickPlay;
      }

      /* Immediate reset */

      e = _swix(MPEGControl_ResetStream,
                _INR(0,2),
    
                flags,
                s->mpegid,
                MPEGCtrl_MCRS_Trick_Play);
    }
  }

  return e;
}

/**************************************************************/
/* play_mode_changed()                                        */
/*                                                            */
/* Note that a play mode change has occurred.                 */
/*                                                            */
/* Parameters: Pointer to the session structure for the       */
/*             playback stream in question;                   */
/*                                                            */
/*             Play mode to consider (this allows override of */
/*             the play mode recorded in the session).        */
/**************************************************************/

_kernel_oserror * play_mode_changed(session * s, int playmode)
{
  dprintf(("", "play_mode_changed called with playmode %d\n", playmode));

  /* If video is playing, tell the MPEG system about the change.      */
  /* If video is not yet playing, but we are starting in a trick mode */
  /* we also need to tell the MPEG system, since it does not expect a */
  /* trick play stream normally.                                      */

  if (
      s->started != 0 ||
      playmode == Play_MB_Trick_FFWD ||
      playmode == Play_MB_Trick_FRWD
     )
    play_alter_playback_characteristics(s, playmode);

  if (playmode == Play_MB_Trick_Freeze)
  {
    /* When entering pause mode, stop reading the time code regularly and   */
    /* update the cached npt from the current npt.                          */

    if (s->read_tc_set != 0)
    {
      s->read_tc_set = 0;
      untimeout(play_read_timecode_on_callout, s);
    }

    s->cached_npt = play_read_current_npt(s);
  }
  else
  {
    rtsp_header * h;

    /* Remember what the new scale setting is. The server should have told    */
    /* us in its response. If it didn't, use fixed values depending on the    */
    /* play mode. Note that we only cope with integer scales currently.       */
    /* At the time of writing, MediaBase only supports scales of -6, 1 and 6. */

    h = headers_find_header(s->headers,
                            Headers_HeaderName_Scale);
  
    if (h != NULL) s->scale = atoi(h->value);
    else           s->scale = 0;
  
    dprintf(("", "Scale read as %d\n", s->scale));
  
    if (s->scale == 0)
    {
      if (s->server_majorver >= 6 && s->asset_type != assettype_MPEG1)
      {
        switch(playmode)
        {
          case Play_MB_Trick_Play:  s->scale =  1; break;
          case Play_MB_Trick_FFWD:  s->scale =  6; break;
          case Play_MB_Trick_FRWD:  s->scale = -6; break;
        }
      }
      else
      {
        s->scale = 1;
      }
    }

    /* Change the cached NPT to the NPT the server is now changing to.     */
    /* If the user does another state change before video actually starts, */
    /* this will be used as the 'now' time.                                */

    s->cached_npt = s->from;
    s->npt_cache_time = utils_read_time();
    s->time_found = 0;

    if (s->read_tc_set == 0)
    {
      s->read_tc_set = 1;
      timeout(play_read_timecode_on_callout, s, Play_Initial_TimeCode_Timer);
    }
  }

  s->playmode = playmode;

  dprintf(("", "Scale is now %d\n", s->scale));

  return NULL;
}


/**************************************************************/
/* play_read_npt_from_timecode()                              */
/*                                                            */
/* Try to update the cached_npt value for the session by      */
/* reading the current time code from the video stream.       */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Returns:    Whether or not the time code was read.         */
/**************************************************************/

static bool play_read_npt_from_timecode(session * s)
{
  if (s->mpegid != 0)
  {
    _kernel_oserror * e;
    unsigned int      time_code, temporal_reference;
  
    e = _swix(MPEGControl_ReadParameters,
              _INR(0,1) | _OUTR(1,2),
  
              MPEGControl_MCRP_TimeCode,
              s->mpegid,
  
              &time_code,
              &temporal_reference);
  
    if (e == NULL)
    {
      if (time_code != 0xffffffff) /* (indicates unknown time) */
      {
        int npt, scaled_npt;

        /* Remember the time now */
        s->npt_cache_time = utils_read_time();

        /* Time code is in hours, minute, seconds and frames - convert to centiseconds */

        /* Get npt in centiseconds */
        npt =            100 *((time_code & 0x000FC0) >> 6)  +
                    60 * 100 *((time_code & 0x03F000) >> 12) +
               60 * 60 * 100 *((time_code & 0x7C0000) >> 18);

        /* Add frame number time */
        npt += (100 * ((time_code & 0x00003F) + temporal_reference)) / s->approx_fps;

        /* Adjust for scale and start time */
        if (s->scale > 1)
        {
          scaled_npt = npt * s->scale;
          npt = scaled_npt - s->start_time;
        }
        else if (s->scale < 0)
        {
          scaled_npt = npt * s->scale;
          npt = s->end_time + scaled_npt - s->start_time;
        }
        else
        {
          scaled_npt = npt;
          npt = npt - s->start_time;
        }

        /* If the first NPT calculated from a time code is significantly    */
        /* different from the expected NPT (which was put in s->cached_npt  */
        /* when the PLAY request succeeded), assume the start or end time   */
        /* is wrong and adjust accordingly. Since the server does not       */
        /* tell us what the end time for a 'clip' is (here 'clip' means a   */
        /* MediaBase clip, as opposed to a normal asset), this code will    */
        /* always be executed when rewinding a 'clip' for the first time.   */
        /* Note that we avoid doing this for trick play modes on MediaBase  */
        /* 5 or earlier, because our seeking is too inaccurate for this to  */
        /* work. Also, for MediaBase 5 the end time is not needed (s->scale */
        /* is always 1).                                                    */

        #ifdef TRACE
        if (s->time_found == 0)
          dprintf(("Time_0","*** First NPT from time code=%d, expected=%d, difference=%d\n", npt, s->cached_npt, abs(npt - s->cached_npt)));
        #endif
        if (
            s->time_found == 0 &&
            abs(npt - s->cached_npt) > Play_TimeCode_Margin &&
            (s->playmode == Play_MB_Trick_Play || s->server_majorver >= 6)
           )
        {
          if (s->scale < 0)
          {
            s->end_time = s->start_time + s->cached_npt - scaled_npt;
            dprintf(("Time_0", "Calculated NPT %d was not close to expected NPT %d. end_time recalculated as %d\n", npt, s->cached_npt, s->end_time));
          }
          else
          {
            s->start_time = scaled_npt - s->cached_npt;
            dprintf(("Time_0", "Calculated NPT %d was not close to expected NPT %d. start_time recalculated as %d\n", npt, s->cached_npt, s->start_time));
          }
        }
        else
        {
          if (npt < 0)
            s->cached_npt = 0;
          else if (npt > s->duration)
            s->cached_npt = s->duration;
          else
            s->cached_npt = npt;
        }

        dprintf(("Time_1","play_read_npt_from_timecode: time_code=%08X, temporal_reference=%03X, NPT=%d.%d\n", time_code, temporal_reference, s->cached_npt / 100, s->cached_npt % 100));

        s->time_found = 1;

        return true;
      }
    }
  }

  return false;
}

/**************************************************************/
/* play_read_timecode_on_callout()                            */
/*                                                            */
/* A CallOut handler (see CallOut.h) which reads the current  */
/* time code                                                  */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_read_timecode_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("Callout_0", "play_read_timecode_on_callout: Called for %p\n", s));

  if (s->dying != 0 || s->read_tc_set == 0) return;

  play_read_npt_from_timecode(s);

  timeout(play_read_timecode_on_callout, s,
    (s->time_found == 0) ? Play_Initial_TimeCode_Timer : Play_Read_TimeCode_Timer);
}

/**************************************************************/
/* play_read_current_npt()                                    */
/*                                                            */
/* Return the current time position in the video in           */
/* centiseconds.                                              */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Returns:    Time in centiseconds. Time will be 0 if an     */
/*             error occurred.                                */
/**************************************************************/

int play_read_current_npt(session * s)
{
  int npt;

  /* First try to read the video stream time code */

  if (play_read_npt_from_timecode(s))
    return s->cached_npt;

  /* If this failed, use the cached NPT value */

  /* If we are paused, at end of stream, or a time code has not been read */
  /* yet, just return the cached value.                                   */

  dprintf(("", "play_read_current_npt: Using cached time\n"));

  if (s->playmode == Play_MB_Trick_Freeze || s->playmode == Play_MB_Trick_EOS || s->time_found == 0)
    return s->cached_npt;

  /* Return the cached value, plus the time elapsed since it was read. */

  npt = s->cached_npt + (utils_read_time() - s->npt_cache_time) * s->scale;
  if (npt < 0)
    npt = 0;
  else if (npt > s->duration)
    npt = s->duration;

  return npt;
}

/**************************************************************/
/* play_filter_range()                                        */
/*                                                            */
/* Filter a Range header value - can we deal with it? The     */
/* function also parses start and end values, and returns if  */
/* required the values in centiseconds; this includes parsing */
/* key words like 'now' or 'end' and converting to times or   */
/* an indication of no direct specifier.                      */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/*             Pointer to the Range header value (may be NULL */
/*             in which case true is returned);               */
/*                                                            */
/*             Pointer to an int to take starting position,   */
/*             will be -1 if none is specified, and -2 if     */
/*             'now' was specified. May be NULL if not        */
/*             interested;                                    */
/*                                                            */
/*             Pointer to an int to take ending position,     */
/*             will be -1 if none is specified, and -2 if     */
/*             'now' was specified. May be NULL if not        */
/*             interested;                                    */
/*                                                            */
/* Returns:    true if the item is handleable, else false.    */
/*             The integers, if given, may be updated even    */
/*             when 'false' is returned.                      */
/**************************************************************/

static bool play_filter_range(session * s, const char * range, int * start_pos, int * end_pos)
{
  int  d_s, d_e;

  /* Ensure we always have start and end positions to write to */

  if (start_pos == NULL) start_pos = &d_s;
  if (end_pos   == NULL) end_pos   = &d_e;

  /* We expect "npt=..." or just a time (no '"' in the string). We support */
  /* keywords 'now', 'end', 'beginning' and 'current' - well, subject to   */
  /* whatever is defined in Headers.h anyway. Note that we don't handle    */
  /* npt=hh:mm:ss.nn format times, although MediaBase itself will.         */

  *start_pos = Play_MB_Time_Unspecified;
  *end_pos   = Play_MB_Time_Unspecified;

  if (range == NULL) return true;

  /* Skip white space */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;

  if (strchr(range, '=') != NULL)
  {
    /* Ensure we have "npt" */

    if (!Strncmp_ci(range, Headers_HeaderValue_Range_NPT, sizeof(Headers_HeaderValue_Range_NPT) - 1))
    {
      range += sizeof(Headers_HeaderValue_Range_NPT) - 1;
    }
    else return false;

    /* Skip white space, ensure we have "=", skip it and white space */

    while (*range != '\0' && *range <= ' ') range++;
    if (*range == '\0') return true;
    else if (*range != '=') return false;
    range++;
    while (*range != '\0' && *range <= ' ') range++;
    if (*range == '\0') return true;
  }

  /* Do we recognise any starting point specifier? */

  if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now1, sizeof(Headers_HeaderValue_Range_Now1) - 1))
  {
    *start_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now2, sizeof(Headers_HeaderValue_Range_Now2) - 1))
  {
    *start_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now2) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Start1, sizeof(Headers_HeaderValue_Range_Start1) - 1))
  {
    *start_pos = 0;
    range += sizeof(Headers_HeaderValue_Range_Start1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_End1, sizeof(Headers_HeaderValue_Range_End1) - 1))
  {
    *start_pos = s->duration;
    range += sizeof(Headers_HeaderValue_Range_End1) - 1;
  }

  /* If there's a number here, it's allowed to be a number of seconds, and  */
  /* nothing else.                                                          */

  else if (isdigit(*range))
  {
    modulefp_buf buf;

    modulefp_enable(&buf);
    *start_pos = play_strtofi(range, &range, 100);
    modulefp_disable(&buf);
  }

  /* If there's something before the '-' and we get as far as this check, */
  /* we can't handle it                                                   */

  else if (*range != '-') return false;

  /* Skip white space, ensure we have "-", skip it and white space */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;
  else if (*range != '-') return false;
  range++;
  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;

  /* Do we recognise any ending point specifier? */

  if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now1, sizeof(Headers_HeaderValue_Range_Now1) - 1))
  {
    *end_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now2, sizeof(Headers_HeaderValue_Range_Now2) - 1))
  {
    *end_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now2) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Start1, sizeof(Headers_HeaderValue_Range_Start1) - 1))
  {
    *end_pos = 0;
    range += sizeof(Headers_HeaderValue_Range_Start1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_End1, sizeof(Headers_HeaderValue_Range_End1) - 1))
  {
    /* We don't use the Duration value for an end position as the server spits */
    /* a 500 error up if there's any "to" value...                             */

    range += sizeof(Headers_HeaderValue_Range_End1) - 1;
  }

  /* Must be a number, or nothing */

  else if (isdigit(*range))
  {
    modulefp_buf buf;

    modulefp_enable(&buf);
    *end_pos = play_strtofi(range, &range, 100);
    modulefp_disable(&buf);
  }

  /* If there's anything after the specifier, there's something wrong... */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range != '\0') return false;

  return true;
}

/**************************************************************/
/* play_reconstruct_range_header()                            */
/*                                                            */
/* Rebuild a Range header based on the range_record from a    */
/* client's VideoControl_Play command (-> RTSPMB_Play) into a */
/* form that the server will understand.                      */
/*                                                            */
/* Parameters: Pointer to a session structure holding the     */
/*             range record;                                  */
/*                                                            */
/*             Pointer to a buffer to hold the new header -   */
/*             the minimum size should be something like      */
/*             sizeof("npt = 0-0") + 48.                      */
/**************************************************************/

static void play_reconstruct_range_header(session * s, char * temp)
{
  int from = s->from;

  /* Do we need to do strange adjustments to NPT for MPEG2 on old versions */
  /* of MediaBase?                                                         */

  if (
      from != Play_MB_Time_Unspecified &&
      s->server_majorver < 6 &&
      s->asset_type == assettype_MPEG2 &&
      (s->next_playmode == Play_MB_Trick_FFWD || s->next_playmode == Play_MB_Trick_FRWD)
     )
  {
    modulefp_buf buf;

    dprintf(("", "play_reconstruct_range_header: time before adjustment=%d, ", from));
    modulefp_enable(&buf);
    from = play_get_trick_stream_npt(s, from);
    modulefp_disable(&buf);
    dprintf(("", "after adjustment=%d\n", from));
  }

  if (s->to == Play_MB_Time_Unspecified)
  {
    sprintf(temp, "npt=%d.%d-", from / 100, from % 100);
  }
  else if (from == Play_MB_Time_Unspecified)
  {
    sprintf(temp, "npt=-%d.%d", s->to / 100, s->to % 100);
  }
  else
  {
    sprintf(temp, "npt=%d.%d-%d.%d", from / 100, from % 100, s->to / 100, s->to % 100);
  }
}

/**************************************************************/
/* play_get_trick_stream_npt()                                */
/*                                                            */
/* Hackery to "adjust" NPT value for a trick stream based on  */
/* a normal play stream play time.                            */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session relating to the time;   */
/*                                                            */
/*             Play time in seconds from start of clip.       */
/*                                                            */
/* Returns:    Approximate trick play stream time relating to */
/*             the normal stream time given, *in cs*.         */
/**************************************************************/

static unsigned int play_get_trick_stream_npt(session * s, unsigned int npt)
{
  if (s->frames_per_sec == 0 || s->i_frame_ratio == 0)
  {
    /* If we're missing any values, assume a 2:1 ratio... :-/ */

    return npt / 2;
  }
  else
  {
    /* Kasenna said this - but it's wrong...                             */
    /*                                                                   */
    /*    return (unsigned int) ((double) npt / (s->i_frame_ratio + 1)); */
    /*                                                                   */
    /* Andrew's solution was to use:                                     */
    /*                                                                   */
    /*    return (unsigned int) (((double) npt * (s->i_frame_ratio + 1)) / s->frames_per_sec); */
    /*                                                                   */
    /* The following seems to work OK too, but I can't get Kasenna to    */
    /* give me a proper answer.                                          */

    return (unsigned int) (((double) npt / s->i_frame_ratio) * 7.5);
  }
}

/**************************************************************/
/* play_strtofi()                                             */
/*                                                            */
/* Convert a string to a fixed point integer value.           */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the string.                         */
/*                                                            */
/*             Pointer to variable to hold pointer to first   */
/*             unrecognised character (may be NULL).          */
/*                                                            */
/*             Factor to scale by.                            */
/*                                                            */
/* Returns:    The converted value. This will be zero if the  */
/*             conversion failed.                             */
/**************************************************************/

static int play_strtofi(const char *str, const char **endptr, int factor)
{
  return (int)(strtod(str, (char **)endptr) * factor);
}

#ifdef CLIENT_LOOPING

/**************************************************************/
/* play_copy_frame_info()                                     */
/*                                                            */
/* Copy the frames per second and frame to I-frame ratio      */
/* values from one session to another.                        */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to destination session structure;      */
/*                                                            */
/*             Pointer to source session structure.           */
/**************************************************************/

static void play_copy_frame_info(session * dst, session * src)
{
  dst->frames_per_sec = src->frames_per_sec;
  dst->i_frame_ratio  = src->i_frame_ratio;

  return;
}

#endif

#if 0

  /**************************************************************/
  /* play_get_frame_number()                                    */
  /*                                                            */
  /* Given a time in seconds, return a frame number based on    */
  /* the frames/second value read from DESCRIBE (if present,    */
  /* else assume 25fps or 30fps depending on PAL / NTSC         */
  /* options).                                                  */
  /*                                                            */
  /* Must only be used after modulefp_enable has been called.   */
  /*                                                            */
  /* Parameters: Pointer to the session relating to the time;   */
  /*                                                            */
  /*             Play time in seconds from start of clip.       */
  /*                                                            */
  /* Returns:    Approximate frame number.                      */
  /**************************************************************/

  static unsigned int play_get_frame_number(session * s, unsigned int npt)
  {
    if (s->frames_per_sec != 0)
    {
      double d = s->frames_per_sec * npt;

      return (unsigned int) d;
    }
    else
    {
      _kernel_oserror * e;
      int               opts[4];
      int               fps;

      opts[0] = vc_tags_ntsc;
      opts[1] = 1;
      opts[2] = 0;
      opts[3] = vc_tags__end;

      e = _swix(VideoControl_ProtocolOptions,
                _INR(0,2),

                0,
                s->vcid,
                opts);

      if (e == NULL) fps = (opts[2] == 0) ? 25 : 30; /* That's slightly inaccurate for NTSC of course... */
      else           fps = 25;

      return fps * npt;
    }
  }

/**************************************************************/
/* play_slowmofwd()                                           */
/*                                                            */
/* Work out whether reduced data rate slow motion forwards    */
/* play should be used for a given scale/speed specifier.     */
/*                                                            */
/* Parameters: Scale/speed specifier.                         */
/*                                                            */
/* Returns:    true to use reduced data rate slow motion      */
/*             forwards play (send a Speed header rather than */
/*             Scale), else false.                            */
/**************************************************************/

static bool play_slowmofwd(const char * scale)
{
  if (
       scale != NULL &&

       _swix(OS_Module,
             _INR(0,1),

             18,
             ReducedRateSlowmoSupportModule) /* Play.h */

       == NULL

       &&
       (
         !strncmp(scale, "0.", 2) ||
         *scale == '.'
       )
     )
     return true;

  return false;
}

#endif
