/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Play.                            */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>

#include <swis.h>
#include <AsmUtils/modulefp.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Response.h"
#include "RTSPMErrors.h"
#include "Session.h"
#include "Status.h"
#include "Utils.h"

#include "Play.h"

/* Local structures and enumerations */

typedef enum play_state
{
  play_state_undefined = 0,
  play_state_set_playmode,
  play_state_play
}
play_state;

/* Local functions - miscellaneous */

static bool              play_slowmofwd                (const char * scale);
static int               play_process_speed            (const char * scale);

/* Local functions - general command sending assitance */

static _kernel_oserror * play_preamble                 (session * s);
static _kernel_oserror * play_send                     (session * s);

/* Local functions - stuff called from the state machine as callback */
/* functions during execution of a command chain                     */

static _kernel_oserror * play_send_set_playmode        (session * s);
static _kernel_oserror * play_send_play                (session * s);
static _kernel_oserror * play_send_state_command       (session * s, play_state state);

/* Local functions - stuff used to build a set of command headers */
/* ready for sending out                                          */

static _kernel_oserror * play_build_pause              (session * s);
static _kernel_oserror * play_build_set_playmode       (session * s);
static _kernel_oserror * play_build_play               (session * s);
static _kernel_oserror * play_build_play_or_pause      (session * s, bool force_pause);
static bool              play_filter_range             (session * s, const char * range, int * start_pos, int * end_pos);
static void              play_reconstruct_range_header (session * s, char * temp);

/* Local functions - floating point code used within */

static unsigned int      play_get_trick_stream_npt     (session * s, unsigned int npt);
static void              play_copy_frame_info          (session * dst, session * src);

#if 0
  static unsigned int    play_get_frame_number         (session * s, unsigned int npt);
#endif

/**************************************************************/
/* play_slowmofwd()                                           */
/*                                                            */
/* Work out whether reduced data rate slow motion forwards    */
/* play should be used for a given scale/speed specifier.     */
/*                                                            */
/* Parameters: Scale/speed specifier.                         */
/*                                                            */
/* Returns:    true to use reduced data rate slow motion      */
/*             forwards play (send a Speed header rather than */
/*             Scale), else false.                            */
/**************************************************************/

static bool play_slowmofwd(const char * scale)
{
  if (
       scale != NULL &&

       _swix(OS_Module,
             _INR(0,1),

             18,
             ReducedRateSlowmoSupportModule) /* Play.h */

       == NULL

       &&
       (
         !strncmp(scale, "0.", 2) ||
         *scale == '.'
       )
     )
     return true;

  return false;
}

/**************************************************************/
/* play_process_speed()                                       */
/*                                                            */
/* Process a string which should contain a number which may   */
/* be negative or a decimal fraction, e.g. "-0.4", "55",      */
/* ".4" but not (say) "1/3" or "    65".                      */
/*                                                            */
/* Parameters: Pointer to the string. If NULL, "1" is used.   */
/*                                                            */
/* Returns:    An int containing an indication of play mode   */
/*             within the string; see MPEGCtrl.h.             */
/**************************************************************/

static int play_process_speed(const char * scale)
{
  int type;

  if (scale == NULL || *scale == '\0') scale = "1";

  if      (!strcmp(scale, "1")) type = MPEGCtrl_MCRS_Trick_Play;
  else if (!strcmp(scale, "0")) type = MPEGCtrl_MCRS_Trick_Freeze;

  else if (strstr(scale, "0.") != NULL)
  {
    if (*scale == '-')          type = MPEGCtrl_MCRS_Trick_SRWD;
    else                        type = MPEGCtrl_MCRS_Trick_SFWD;
  }
  else if (*scale == '-')       type = MPEGCtrl_MCRS_Trick_FRWD;
  else                          type = MPEGCtrl_MCRS_Trick_FFWD;

  return type;
}

/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement RTSPMB_Play. See the Video Control               */
/* specification, 2501,817/FS, for more.                      */
/*                                                            */
/* This function always sends at least one command, which     */
/* is either PAUSE for zero speed or for a trick play mode    */
/* transition, or SET_PLAYMODE if playback is starting for    */
/* the first time. PLAY is used directly to exit PAUSE. A     */
/* command chain is set up which is dealt with by the state   */
/* machine calling back into play_send_play or                */
/* play_send_set_playmode.                                    */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  session * s         = session_find_by_id(r->r[1]);
  bool      slowmofwd = false; /* This is true for slowmo forward play     */
  bool      play      = true;  /* This is true for any non-pause play mode */
  bool      paused;
  char    * scale;
  char    * scale_rec;
  char    * range_rec;

  dprintf(("", "play_play: Called\n"));

  RetError(play_preamble(s));

  /* We know there's no foreground command in progress and other stuff */
  /* looks generally sane... But do we need to queue this operation to */
  /* wait for a background command to complete?                        */
  /*                                                                   */
  /* Meanwhile, suppose a background replay command is waiting for a   */
  /* background GET_PARAMETER to complete. There's a narrow hole when  */
  /* either it's polled re|try routine could be called or ours could.   */
  /* No problem; it doesn't really matter who gets called first since  */
  /* the background replay command would be cancelled if it were       */
  /* called after this and noticed a foreground operation in progress  */
  /* or if we get called afterwards then our play command overrides    */
  /* the replay command.                                               */

  if (s->child != NULL)
  {
    dprintf(("", "play_play: Having to wait for background command\n"));

    /* We have to wait */

    s->play_r0_record = r->r[0];

    /* Copy away the strings in R2 and R3. We might be for some odd reason */
    /* being called by the retry routine in which case the strings we are  */
    /* copying are already held in s->play_r[n]_record - so take care to   */
    /* copy them, free any original data, then assign the new string.      */

    if (r->r[2] != 0)
    {
      char * str = Strdup((char *) r->r[2]);

      if (str == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);

      free(s->play_r2_record);
      s->play_r2_record = str;
    }
    else s->play_r2_record = 0;

    if (r->r[3] != 0)
    {
      char * str = Strdup((char *) r->r[3]);

      if (str == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);

      free(s->play_r3_record);
      s->play_r3_record = str;
    }
    else s->play_r3_record = 0;

    /* Make sure the status details are cleared for clients polling the */
    /* status SWI                                                       */

    s->state          = protostate_INITIAL;
    s->reported_state = 0;

    s->play_wait = 1;
    timeout(play_retry_delayed_on_callout, s, Session_State_Retry);

    dprintf(("", "play_play: Polled timer is set, exiting play_play\n"));

    return NULL;
  }

  /* For forwards slow-mo, we can use Speed instead of Scale for slow motion */
  /* forwards play - if the server ever supports it!                         */

  scale = (char *) r->r[3];

  if (scale && !strcmp(scale, "0")) play      = false;
  else                              slowmofwd = play_slowmofwd(scale);

  /* Is playback currently paused? */

  if (s->play_record != NULL && !strcmp(s->play_record, "0")) paused = true;
  else                                                        paused = false;

  /* Ensure everything is reset for a new command, taking copies of  */
  /* the scale and range strings first since they may be held within */
  /* the structure we're about to reset if the command was delayed   */
  /* owing to background activities.                                 */

  range_rec = Strdup(r->r[2] == 0 ? "" : (char *) r->r[2]);
  scale_rec = Strdup(scale == NULL ? "" : scale);

  session_reset_session(s);

  /* Copy R2 and R3 away */

  free(s->range_record);
  s->range_record = range_rec;

  free(s->play_record);
  s->play_record = scale_rec;

  if (s->play_record == NULL || s->range_record == NULL)
  {
    dprintf(("", "play_play: Play or range records NULL -> out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Is there a mapping between the request and the server? Not if this */
  /* is a slow motion play request; in that case return a 501 response. */

  if (scale_rec != NULL)
  {
    int type = play_process_speed(scale_rec);

    if (type == MPEGCtrl_MCRS_Trick_SFWD || type == MPEGCtrl_MCRS_Trick_SRWD)
    {
      rtsp_header * r = response_501(s->headers);

      if (r == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);

      headers_free_headers(&s->headers);

      s->next_command_cb = NULL;
      s->headers         = r;
      s->state           = protostate_COMPLETED;
      s->response_code   = (unsigned int) strtoul(Headers_Supported_Prefix_NI, NULL, 10);
      s->reported_state  = VC_Status_ConnectionEstablished |
                           VC_Status_NewStatus;

      s->data_len = headers_construct_specific_header_buffer(s->headers,
                                                             &s->data,
                                                             0,
                                                             1);

      if (s->data_len != 0) s->reported_state |= VC_Status_MoreInformationAvailable;

      if (s->callout_set == 0)
      {
        s->callout_set = 1;
        timeout(status_proceed_on_callout, s, Session_State_Timer);
      }

      return NULL;
    }
  }

  /* Work out the command order required (SET_PLAYMODE   */
  /* then PLAY, maybe with a PAUSE first, or just PAUSE) */

  if (!play)
  {
    dprintf(("", "play_play: Building PAUSE to pause\n"));

    s->next_command_cb = NULL;
    s->playmode        = Play_MB_Trick_Freeze;

    RetError(play_build_pause(s));
  }
  else
  {
    if (s->started != 0 && !paused)
    {
      dprintf(("", "play_play: Building PAUSE to change trick mode\n"));

      s->next_command_cb = play_send_set_playmode;

      RetError(play_build_pause(s));
    }
    else if (paused || s->multicast != 0)
    {
      #ifdef TRACE
        if (paused) dprintf(("", "play_play: Building PLAY to unpause\n"));
        else        dprintf(("", "play_play: Building PLAY for simulated multicast start\n"));
      #endif

      s->next_command_cb = NULL;
      s->playmode        = Play_MB_Trick_Play;

      RetError(play_build_play(s));
    }
    else
    {
      dprintf(("", "play_play: Building SET_PLAYMODE\n"));

      s->next_command_cb = play_send_play;

      RetError(play_build_set_playmode(s));
    }
  }

  /* Send the command */

  dprintf(("", "play_play: Successful; exitting through play_send\n"));

  return play_send(s);
}

/**************************************************************/
/* play_replay_on_callout()                                   */
/*                                                            */
/* A CallOut handler (see CallOut.h) which loops video        */
/* playback through play_replay.                              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_replay_on_callout(void * handle)
{
  session * s = (session *) handle;

  if (s->dying != 0) return;

  if (s->loop_ready != 0)
  {
    /* Is there an in-transit foreground or background command already? */

    if (
         s->state != protostate_COMPLETED &&
         s->state != protostate_INITIAL
       )
    {
      /* Foreground command - abandon this background operation */

      s->loop_ready = 0;
      return;
    }
    else if (s->child != NULL)
    {
      /* Background command - wait for it to finish */

      timeout(play_replay_on_callout, s, Session_State_Retry);
      return;
    }
    else
    {
      /* Clear to send the command */

      s->loop_ready = 0;
      play_replay(s);
    }
  }
}

/**************************************************************/
/* play_replay()                                              */
/*                                                            */
/* Issue an "in-the-background" PLAY command to loop video    */
/* playback at the client end.                                */
/*                                                            */
/* Parameters: Pointer to a session struct for the video to   */
/*             loop.                                          */
/**************************************************************/

_kernel_oserror * play_replay(session * s)
{
  _kernel_oserror * e;
  session         * new_s;

  dprintf(("", "play_replay: Called for %p\n", s));

  if (s->server_session == NULL)
  {
    dprintf(("", "play_replay: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Cancel any GET_PARAMETER manually - it won't be done automatically */
  /* as we're not resetting this session, we're spawning a new one      */

  if (s->gp_set != 0)
  {
    untimeout(getparam_proceed_on_callout, s);
    s->gp_set = 0;
  }

  /* This should never happen if called via. play_replay_on_callout... */

  if (s->child) session_free_item(s->child);

  /* Create a new session */

  e = session_new_session(&new_s);

  if (e)
  {
    dprintf(("", "play_replay: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  /* Can't just block copy the structure; have to be careful to take new */
  /* copies of vital strings, IDs, and so-on.                            */

  if (new_s != NULL)
  {
    new_s->id       = ++id_counter; /* See Global.h */
    new_s->vcid     = s->vcid;
    new_s->destruct = 1;

    new_s->parent   = s;
    s->child        = new_s;

    new_s->server_session = Strdup(s->server_session ? s->server_session : "");
    new_s->play_record    = Strdup(s->play_record    ? s->play_record    : "");
    new_s->range_record   = Strdup(s->range_record   ? s->range_record   : "");

    if (s->url->full != NULL)
    {
      (void) urlutils_return_description(s->url->full, &new_s->url);
    }

  }

  if (
       new_s                 == NULL ||
       new_s->server_session == NULL ||
       new_s->play_record    == NULL ||
       new_s->range_record   == NULL ||
       (
         s->url->full != NULL &&
         new_s->url   == NULL
       )
     )
  {
    dprintf(("", "play_replay: Out of memory for new_s or copied strings\n"));

    if (new_s != NULL) session_free_item(new_s);
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  new_s->server_timeout  = s->server_timeout;
  new_s->playmode        = s->playmode;
  new_s->multicast       = s->multicast;

  new_s->duration        = s->duration;
  new_s->cached_npt      = s->cached_npt;

  {
    modulefp_buf buf;

    modulefp_enable(&buf);
    play_copy_frame_info(new_s, s);
    modulefp_disable(&buf);
  }

  new_s->next_command_cb = play_send_set_playmode;

  e = play_build_pause(new_s);

  if (e != NULL)
  {
    dprintf(("", "play_replay: Error '%s' from play_build_pause\n", e->errmess));

    session_free_item(new_s);
    return e;
  }

  /* Open a connection to send the command down */

  if (s->sd == -1)
  {
    int port;

    if (s->url->port && *s->url->port) port = atoi(s->url->port);
    else                               port = RTSPMB_DefaultPort;

    s->sd = opensock(s->url->host,
                     port,
                     NULL,
                     &new_s->state,
                     -1);

    if (s->state == protostate_ERROR) s->err_no = -s->sd;
  }
  else new_s->state = protostate_CONNECTED;

  new_s->sd   = s->sd;
  new_s->last = utils_read_time();

  dprintf(("", "play_replay: Socket descriptor %d, state %d\n", new_s->sd, new_s->state));

  /* Set the state machine going to see errors and DNS stuff; */
  /* in addition, rerun it for the parent session to get      */
  /* another GET_PARAMETER scheduled.                         */

  new_s->callout_set = 1;
  timeout(status_proceed_on_callout, new_s, Session_State_Timer);

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  /* Finished */

  dprintf(("", "play_replay: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_preamble()                                            */
/*                                                            */
/* For a given session, check the pointer is not NULL, that   */
/* no command is currently in progress and that there is a    */
/* server session.                                            */
/*                                                            */
/* This is normally the first thing done in a function that   */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to the session struct (may be NULL).   */
/*                                                            */
/* Returns:    An error if there is some problem with using   */
/*             the session for a new PLAY command, else NULL. */
/**************************************************************/

static _kernel_oserror * play_preamble(session * s)
{
  dprintf(("", "play_preamble: Called for &%08X\n", (int) s));

  if (s == NULL)
  {
    dprintf(("", "play_preamble: ID not found\n"));

    return make_error(rtspmb_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (
       s->state == protostate_DNS       ||
       s->state == protostate_CONNECTED ||
       s->state == protostate_SENDING   ||
       s->state == protostate_RECEIVING ||
       s->state == protostate_PUMPING
     )
  {
    dprintf(("", "play_preamble: In progress\n"));

    return make_error(rtspmb_ERROR_IN_PROGRESS, 0);
  }

  if (s->server_session == NULL)
  {
    dprintf(("", "play_preamble: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Be warned - don't do anything destructive to background */
  /* commands here (e.g. don't call session_reset_session)   */

  dprintf(("", "play_preamble: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send()                                                */
/*                                                            */
/* Once a session has been fully initialised with all the     */
/* data needed to send a command, kick off the send.          */
/*                                                            */
/* This is normally the last thing done in a function that    */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_send(session * s)
{
  int port;

  dprintf(("", "play_send: Called for &%08X\n", (int) s));

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  if (s->sd == -1)
  {
    s->sd = opensock(s->url->host,
                     port,
                     NULL,
                     &s->state,
                     -1);

    if (s->state == protostate_ERROR) s->err_no = -s->sd;
  }
  else s->state = protostate_CONNECTED;

  s->last = utils_read_time();

  dprintf(("", "play_send: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Set the state machine going to see errors and DNS stuff. The call */
  /* to session_reset_session should've cleared the callout but it     */
  /* never hurts to be sure (in future maybe stuff could go on in the  */
  /* background that could have set a callout between the reset and    */
  /* this part of the code).                                           */

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_send: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_set_playmode()                                   */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the second item in a chain of commands for the     */
/* server (the first must be PAUSE). The next command         */
/* callback is set to play_send_play. A command chain which   */
/* involves calling this function is always started inside    */
/* play_play.                                                 */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful PAUSE command.                      */
/**************************************************************/

static _kernel_oserror * play_send_set_playmode(session * s)
{
  dprintf(("", "play_send_set_playmode: Called for &%08X\n", (int) s));

  RetError(play_send_state_command(s, play_state_set_playmode));

  dprintf(("", "play_send_set_playmode: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_play()                                           */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the last item in a chain of commands for the       */
/* server and sends the actual PLAY command off. No further   */
/* callback function is set.                                  */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful SET_PLAYMODE command.               */
/**************************************************************/

static _kernel_oserror * play_send_play(session * s)
{
  dprintf(("", "play_send_play: Called for &%08X\n", (int) s));

  RetError(play_send_state_command(s, play_state_play));

  dprintf(("", "play_send_play: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_state_command()                                  */
/*                                                            */
/* Deal with the mechanics of building a relevant command and */
/* setting any required next command callback, for a chain of */
/* play-related commands for the server. This is only used    */
/* for second and subsequent commands - play_play deals with  */
/* the extra complexity of the initial command (not least,    */
/* working out exactly what command to send).                 */
/*                                                            */
/* Parameters: Pointer to a session structure;                */
/*                                                            */
/*             A play_state (see top of file) indicating the  */
/*             command to send, which influences what the     */
/*             next command callback is set to.               */
/**************************************************************/

static _kernel_oserror * play_send_state_command(session * s, play_state state)
{
  dprintf(("", "play_send_state_command: Called\n"));

  RetError(play_preamble(s));

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Build the command */

  switch(state)
  {
    case play_state_set_playmode:
    {
      dprintf(("", "play_send_state_command: SET_PLAYMODE\n"));

      /* Build the SET_PLAYMODE command */

      RetError(play_build_set_playmode(s));
      s->next_command_cb = play_send_play;
    }
    break;

    case play_state_play:
    {
      dprintf(("", "play_send_state_command: PLAY/PAUSE\n"));

      /* Build the PLAY or PAUSE command (should always be PLAY in practice) */

      RetError(play_build_play_or_pause(s, 0));
      s->next_command_cb = NULL; /* session_reset_session should do that, but just in case... */
    }
    break;

    default:
    {
      dprintf(("", "play_send_state_command: Unknown command state!\n"));

      return make_error(rtspmb_ERROR_UNKNOWN_COMMAND_STATE, 0);
    }
    break;
  }

  /* Send the command */

  return play_send(s);
}

/**************************************************************/
/* play_build_pause()                                         */
/*                                                            */
/* Build a forced PAUSE command in a session, ignoring the    */
/* play_record details of required speed. This is intended    */
/* for use in trick play mode transitions where three         */
/* commands (PAUSE, SET_PLAYMODE then PLAY) must be sent.     */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_pause(session * s)
{
  return play_build_play_or_pause(s, true);
}

/**************************************************************/
/* play_build_set_playmode()                                  */
/*                                                            */
/* Build a SET_PLAYMODE command inside the given session      */
/* based on the play_record and URL details inside it.        */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Assumes:    The play_record field does not indicate zero   */
/*             speed (pause).                                 */
/**************************************************************/

static _kernel_oserror * play_build_set_playmode(session * s)
{
  char * playmode = NULL;
  bool   fail     = false;

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;
  else
  {
    playmode = malloc(sizeof(Headers_HeaderValue_ContentLength) - 1); /* We want the terminator included; the -1 is there as '%d' will end up as a single digit number */

    /* The content length header value is a bit of a hack; it must be the last */
    /* item as it holds a double CR LF and a "Playmode:" entry for the body    */
    /* text of our SET_PLAYMODE command. It's a nasty way of doing it, but     */
    /* very cheap in code terms.                                               */

    if (playmode != NULL)
    {
      int type = play_process_speed(s->play_record);
      int mode;

      /* Rather than modify play_process_speed to spit out MediaBase stuff directly, */
      /* the full accuracy of play methods is kept, in case future MediaBase servers */
      /* support features missing at the time of writing (e.g. SFWD play).           */

      switch (type)
      {
        case MPEGCtrl_MCRS_Trick_FFWD:   mode = Play_MB_Trick_FFWD;   break;
        case MPEGCtrl_MCRS_Trick_SFWD:   mode = Play_MB_Trick_Play;   break; /* No SFWD on MediaBase */
        case MPEGCtrl_MCRS_Trick_Freeze: mode = Play_MB_Trick_Freeze; break;
        case MPEGCtrl_MCRS_Trick_FRWD:   mode = Play_MB_Trick_FRWD;   break;
        case MPEGCtrl_MCRS_Trick_SRWD:   mode = Play_MB_Trick_FRWD;   break; /* No SRWD on MediaBase */

        default:
        case MPEGCtrl_MCRS_Trick_Play:   mode = Play_MB_Trick_Play;   break;
      }

      sprintf(playmode,
              Headers_HeaderValue_ContentLength,
              mode);

      s->playmode = mode;
    }
  }

  if (playmode == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_SetPlayMode,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Content type for the play mode etc. */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentType,
                               Headers_HeaderValue_ContentType)
            == NULL
          )
          fail = true;

  /* Content length - THIS MUST BE THE LAST ITEM ADDED */

  else
  {
//    _kernel_oserror * e;
//    int               opts     [4];
//    char              temp     [1024]; //// Fix me, temporary Friday hack; use malloc
//    unsigned int      frame;
//
//    opts[0] = vc_tags_npt;
//    opts[1] = 1;
//    opts[2] = 0;
//    opts[3] = vc_tags__end;
//
//    e = _swix(VideoControl_ProtocolOptions,
//              _INR(0,2),
//
//              0,
//              s->vcid,
//              opts);
//
//    if (e != NULL) frame = 0;
//    else           frame = (unsigned int) opts[2];
//
//    /* If that fails, try MPEGVideo_ReadParameters for time code */
//
//    if (frame == 0)
//    {
//      unsigned int tc;
//
//      e = _swix(MPEGVideo_ReadParameters,
//                _INR(0,2) | _OUT(1),
//
//                0,
//                0,
//                0,
//
//                &tc);
//
//      /* This is in hours, minute and seconds - convert to seconds */
//
//      if (tc != 0xffffffff) /* (indicates unknown time) */
//      {
//        frame =           ((tc & 0x000FC0) >> 6)  +
//                60 *      ((tc & 0x03F000) >> 12) +
//                60 * 60 * ((tc & 0xFC0000) >> 18);
//      }
//    }
//
//    /* Convert the time in seconds (currently held in 'frame') */
//    /* into a real - if approximate! - frame number            */
//
//    {
//      modulefp_buf buf;
//
//      modulefp_enable(&buf);
//      frame = play_get_frame_number(s, frame);
//      modulefp_disable(&buf);
//    }
//
//    sprintf(temp,
//            "Playmode:%d\r\n", //Frame:%d\r\n",
//            s->playmode);      //,
//                               //frame);
//
//    sprintf(playmode,
//            "%d\r\n\r\n%s",
//            strlen(temp),
//            temp);

    if (
         headers_add_header(&s->headers,
                            Headers_HeaderName_ContentLength,
                            playmode)
         == NULL
       )
       fail = true;
  }

  /* Did anything fail? */

  free(playmode);

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_build_play()                                          */
/*                                                            */
/* Build a PLAY command inside the given session based on     */
/* the play_record and URL details inside it. If play_record  */
/* shows the speed to be zero, PAUSE is sent instead.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_play(session * s)
{
  return play_build_play_or_pause(s, false);
}

/**************************************************************/
/* play_build_play_or_pause()                                 */
/*                                                            */
/* Service function originally built for play_build_play and  */
/* play_build_pause.                                          */
/*                                                            */
/* Builds a PLAY or PAUSE command inside the given session    */
/* based either on the play_record and URL details inside it, */
/* or just on the URL information if play_record is to be     */
/* ignored (PAUSE commands only).                             */
/*                                                            */
/* Parameters: Pointer to a relevant session structure;       */
/*                                                            */
/*             true to ignore play_record and send PAUSE,     */
/*             false to send PLAY or PAUSE according to the   */
/*             play_record setting.                           */
/**************************************************************/

static _kernel_oserror * play_build_play_or_pause(session * s, bool force_pause)
{
  char * scale;
  bool   play      = true;
  bool   fail      = false;
  bool   slowmofwd = false;

  scale = s->play_record == NULL ? "" : s->play_record;

  /* If forced to go into pause mode, set things up as required; */
  /* otherwise determine the state from the play scale value.    */

  if (force_pause == false)
  {
    if (scale && !strcmp(scale, "0")) play      = false;
    else                              slowmofwd = play_slowmofwd(scale);
  }
  else
  {
    play  = false;
    scale = "0";
  }

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               play ? Headers_CommandName_Play : Headers_CommandName_Pause,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* No sync marks please */

  else if (
            play &&
            headers_add_header(&s->headers,
                               Headers_HeaderName_SyncMark,
                               Headers_HeaderValue_SyncMark)
            == NULL
          )
          fail = true;

  /* Range */

  else if (play && s->multicast == 0)
  {
    char new_range[sizeof("npt = 0-0") + 48]; /* (+48 ensures we overestimate for up to 4 digits) */

    play_reconstruct_range_header(s, new_range);

    if (
         headers_add_header(&s->headers,
                            Headers_HeaderName_Range,
                            new_range)
         == NULL
       )
       fail = true;
  }

  /* Add the session header */

  if (
       fail == false &&
       headers_add_header(&s->headers,
                          Headers_HeaderName_Session,
                          s->server_session)
       == NULL
     )
     fail = true;

  /* Did anything fail? */

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_retry_delayed_on_callout()                            */
/*                                                            */
/* Retry a delayed foreground command that was waiting for a  */
/* background command to complete.                            */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_retry_delayed_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("", "play_retry_delayed_on_callout: Called, dying flag is %d\n", s->dying));

  if (s->dying != 0) return;

  if (s->play_wait != 0)
  {
    /* Is there an in-transit foreground or background command already? */

    if (
         s->state != protostate_COMPLETED &&
         s->state != protostate_INITIAL
       )
    {
      /* Foreground command in progress! Should never happen... Abandon */
      /* this wait state.                                               */

      dprintf(("", "play_retry_delayed_on_callout: Foreground command already running!\n"));

      s->play_wait = 0;

      return;
    }
    else if (s->child != NULL)
    {
      /* Background command - wait for it to finish */

      dprintf(("", "play_retry_delayed_on_callout: Background command still running...\n"));

      timeout(play_retry_delayed_on_callout, s, Session_State_Retry);
      return;
    }
    else
    {
      _kernel_swi_regs   r;
      _kernel_oserror  * e;

      /* Clear to send the command */

      s->play_wait = 0;

      r.r[0] = s->play_r0_record;
      r.r[1] = (int) s->id;
      r.r[2] = (int) s->play_r2_record;
      r.r[3] = (int) s->play_r3_record;

      dprintf(("", "play_retry_delayed_on_callout: Clear to try again, calling play_play.\n"));

      e = play_play(&r);

      if (e != NULL)
      {
        dprintf(("", "play_retry_delayed_on_callout: Error &%08X, '%s'\n", e->errnum, e->errmess));

        status_record_error(s, e);
      }
    }
  }
}

/**************************************************************/
/* play_alter_playback_characteristics()                      */
/*                                                            */
/* Set speed and reset parameters for a play mode change.     */
/*                                                            */
/* Parameters: Pointer to the session structure for the       */
/*             playback stream in question;                   */
/*                                                            */
/*             Play mode to consider (this allows override of */
/*             the play mode recorded in the session).        */
/**************************************************************/

_kernel_oserror * play_alter_playback_characteristics(session * s, int playmode)
{
  _kernel_oserror * e;
  int               opts[4];
  unsigned int      mpegid;
  unsigned int      flags;

  /* The MediaBase server is simple. It streams, say, an MPEG 2 transport stream */
  /* normally, but in trick mode just spews elementary video data out. Eek! Our  */
  /* system can't really handle that. The only thing to do is to leave the       */
  /* decode running whilst we talk to the server to try and exhaust any data in  */
  /* buffers, and then do an immediate reset on the PLAY command's OK response,  */
  /* to try and get stream-start style auto detection running to redetermine     */
  /* the stream type.                                                            */

  opts[0] = vc_tags_control_handle;
  opts[1] = 1;
  opts[2] = 0;
  opts[3] = vc_tags__end;

  e = _swix(VideoControl_ProtocolOptions,
            _INR(0,2),

            0,
            s->vcid,
            opts);

  if (e != NULL) mpegid = 0;
  else           mpegid = (unsigned int) opts[2];

  if (mpegid != 0)
  {
    if (playmode == Play_MB_Trick_Freeze)
    {
      /* Immediate set speed to 0 */

      _swix(MPEGControl_SetSpeed,
            _INR(0,2),

            0,
            mpegid,
            0);
    }
    else
    {
      if (playmode == Play_MB_Trick_Play)
      {
        /* Immediate set speed to 1 */

        _swix(MPEGControl_SetSpeed,
              _INR(0,2),

              0,
              mpegid,
              1);

        /* Normal play - flag video and audio */

        flags = MPEGCtrl_MCRS_VideoPresent |
                MPEGCtrl_MCRS_AudioPresent;
      }
      else
      {
        /* Trick play - flag a trick play stream */

        flags = MPEGCtrl_MCRS_VideoPresent |
                MPEGCtrl_MCRS_NewIsTrickPlay;
      }

      /* Immediate reset */

      _swix(MPEGControl_ResetStream,
            _INR(0,2),

            flags,
            mpegid,
            MPEGCtrl_MCRS_Trick_Play);
    }
  }

  return NULL;
}

/**************************************************************/
/* play_filter_range()                                        */
/*                                                            */
/* Filter a Range header value - can we deal with it? The     */
/* function also parses start and end values, and returns if  */
/* required the values in centiseconds; this includes parsing */
/* key words like 'now' or 'end' and converting to times or   */
/* an indication of no direct specifier.                      */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/*             Pointer to the Range header value (may be NULL */
/*             in which case true is returned);               */
/*                                                            */
/*             Pointer to an int to take starting position,   */
/*             will be -1 if none is specified, may be NULL   */
/*             if not interested;                             */
/*                                                            */
/*             Pointer to an int to take ending position,     */
/*             will be -1 if none is specified, may be NULL   */
/*             if not interested.                             */
/*                                                            */
/* Returns:    true if the item is handleable, else false.    */
/*             The integers, if given, may be updated even    */
/*             when 'false' is returned.                      */
/**************************************************************/

static bool play_filter_range(session * s, const char * range, int * start_pos, int * end_pos)
{
  bool now      = false;
  bool start    = false;
  int  d_s, d_e;

  /* Ensure we always have start and end positions to write to */

  if (start_pos == NULL) start_pos = &d_s;
  if (end_pos   == NULL) end_pos   = &d_e;

  /* We expect "npt=..." or just a time (no '"' in the string). We support */
  /* keywords 'now', 'end', 'beginning' and 'current' - well, subject to   */
  /* whatever is defined in Headers.h anyway. If play mode is backwards,   */
  /* and the start time is greater than the end time, the values are NOT   */
  /* reversed if required - this is left up to the caller (MediaBase       */
  /* at the time of writing expects the value before the '-' to be greater */
  /* than the value after the '-' regardless of play direction, unlike     */
  /* OVS, for example).                                                    */

  *start_pos = -1;
  *end_pos   = -1;

  if (range == NULL) return true;

  /* Skip white space */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;

  if (strchr(range, '=') != NULL)
  {
    /* Ensure we have "npt" */

    if (!Strncmp_ci(range, Headers_HeaderValue_Range_NPT, sizeof(Headers_HeaderValue_Range_NPT) - 1))
    {
      range += sizeof(Headers_HeaderValue_Range_NPT) - 1;
    }
    else return false;

    /* Skip white space, ensure we have "=", skip it and white space */

    while (*range != '\0' && *range <= ' ') range++;
    if (*range == '\0') return true;
    else if (*range != '=') return false;
    range++;
    while (*range != '\0' && *range <= ' ') range++;
    if (*range == '\0') return true;
  }

  /* Do we recognise any starting point specifier? */

  if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now1, sizeof(Headers_HeaderValue_Range_Now1) - 1))
  {
    now = true;
    range += sizeof(Headers_HeaderValue_Range_Now1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now2, sizeof(Headers_HeaderValue_Range_Now2) - 1))
  {
    now = true;
    range += sizeof(Headers_HeaderValue_Range_Now2) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Start1, sizeof(Headers_HeaderValue_Range_Start1) - 1))
  {
    start = true;
    range += sizeof(Headers_HeaderValue_Range_Start1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_End1, sizeof(Headers_HeaderValue_Range_End1) - 1))
  {
    *start_pos = s->duration;
    range += sizeof(Headers_HeaderValue_Range_End1) - 1;
  }

  /* If there's a number here, it's allowed to be a percentage or zero, and */
  /* nothing else.                                                          */

  else if (isdigit(*range))
  {
    unsigned int num;

    num = atoi(range);
    while (isdigit(*(++range)));

    *start_pos = (int) num * 100;
  }

  /* If there's something before the '-' and we get as far as this check, */
  /* we can't handle it                                                   */

  else if (*range != '-') return false;

  /* Otherwise work out time based on 'now', 'beginning' etc. */

  if (start || now)
  {
    if      (start)           *start_pos = 0;
    else if (s->started == 0) *start_pos = -1;
    else
    {
      _kernel_oserror * e;
      int               opts[4];

      opts[0] = vc_tags_npt;
      opts[1] = 1;
      opts[2] = 0;
      opts[3] = vc_tags__end;

      e = _swix(VideoControl_ProtocolOptions,
                _INR(0,2),

                0,
                s->vcid,
                opts);

      /* If there's an error, just use zero. Otherwise, if the value from VC was zero */
      /* we could be on a transition point to use the cached value, else use the      */
      /* value given from Video Control.                                              */

      if (e == NULL)
      {
        if (opts[2] != 0) *start_pos = (int) opts[2] * 100;
        else              *start_pos = (int) s->cached_npt;
      }
      else *start_pos = 0;
    }
  }

  /* Skip white space, ensure we have "-", skip it and white space */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;
  else if (*range != '-') return false;
  range++;
  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;

  /* Do we recognise any ending point specifier? */

  start = now = false;

  if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now1, sizeof(Headers_HeaderValue_Range_Now1) - 1))
  {
    now = true;
    range += sizeof(Headers_HeaderValue_Range_Now1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now2, sizeof(Headers_HeaderValue_Range_Now2) - 1))
  {
    now = true;
    range += sizeof(Headers_HeaderValue_Range_Now2) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Start1, sizeof(Headers_HeaderValue_Range_Start1) - 1))
  {
    start = true;
    range += sizeof(Headers_HeaderValue_Range_Start1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_End1, sizeof(Headers_HeaderValue_Range_End1) - 1))
  {
    /* We don't use the Duration value for an end position as the server spits */
    /* a 500 error up if there's any "to" value...                             */

    range += sizeof(Headers_HeaderValue_Range_End1) - 1;
  }

  /* Must be a number, or nothing */

  else if (isdigit(*range))
  {
    unsigned int num;

    num = atoi(range);
    while (isdigit(*(++range)));

    *end_pos = (int) num;
  }

  /* If there's anything after the specifier, there's something wrong... */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range != '\0') return false;

  /* Otherwise work out time, as before */

  if (start || now)
  {
    if (start || s->started == 0)
    {
      *end_pos = -1;
    }
    else
    {
      _kernel_oserror * e;
      int               opts[4];

      opts[0] = vc_tags_npt;
      opts[1] = 1;
      opts[2] = 0;
      opts[3] = vc_tags__end;

      e = _swix(VideoControl_ProtocolOptions,
                _INR(0,2),

                0,
                s->vcid,
                opts);

      if (e == NULL)
      {
        if (opts[2] != 0) *end_pos = (int) opts[2] * 100;
        else              *end_pos = (int) s->cached_npt * 100;
      }
      else *end_pos = 0;
    }
  }

  return true;
}

/**************************************************************/
/* play_reconstruct_range_header()                            */
/*                                                            */
/* Rebuild a Range header based on the range_record from a    */
/* client's VideoControl_Play command (-> RTSPMB_Play) into a */
/* form that the server will understand.                      */
/*                                                            */
/* Parameters: Pointer to a session structure holding the     */
/*             range record;                                  */
/*                                                            */
/*             Pointer to a buffer to hold the new header -   */
/*             the minimum size should be something like      */
/*             sizeof("npt = 0-0") + 48.                      */
/**************************************************************/

static void play_reconstruct_range_header(session * s, char * temp)
{
  _kernel_oserror * e;
  int               opts [4];
  unsigned int      csecs;
  int               from, to;
  bool              accept;

  accept = play_filter_range(s, s->range_record, &from, &to);

  if (accept == false || from < -1 || to < -1)
  {
    from = to = -1;

    /* Read NPT */

    opts[0] = vc_tags_npt;
    opts[1] = 1;
    opts[2] = 0;
    opts[3] = vc_tags__end;

    e = _swix(VideoControl_ProtocolOptions,
              _INR(0,2),

              0,
              s->vcid,
              opts);

    if (e != NULL) csecs = 0;
    else           csecs = (unsigned int) opts[2] * 100; /* seconds -> centiseconds */

    /* If NPT is zero, could be at a transition point - use cached value */

    if (csecs == 0) csecs         = s->cached_npt;
    else            s->cached_npt = csecs;
  }
  else
  {
    if (from != -1) csecs = from;
    else            csecs = 0;

    s->cached_npt = csecs;

    if (s->playmode == Play_MB_Trick_FRWD && to == 0)
    {
      /* MediaBase raises error 500 (doh) if you say "100-0" for reverse */
      /* play, but happily accepts "100-"...!                            */

      to = -1;
    }
    else if (to != -1)
    {
      /* MediaBase seemed to need from < to at all times even for reverse */
      /* play, but then again it may just not support 'to' at all. Since  */
      /* it just erroneously raises "500 Internal Server Error" for any   */
      /* request it doesn't like, I've no idea what the real problem is.  */

      if (csecs > to) Swap(csecs, to); /* See Utils.h */
    }
  }

  /* Turn this into a trick mode seek time for MediaBase (ick) */

  if (s->playmode != Play_MB_Trick_Play && s->playmode != Play_MB_Trick_Freeze)
  {
    modulefp_buf buf;

    modulefp_enable(&buf);

    csecs = play_get_trick_stream_npt(s, csecs);
    if (to != -1) to = play_get_trick_stream_npt(s, to);

    modulefp_disable(&buf);
  }

  if (from == -1 && to == -1)
  {
    if (s->playmode == Play_MB_Trick_FRWD) sprintf(temp, "npt=2147483647-");
    else                                   sprintf(temp, "npt=0-");
  }
  else if (from == -1)
  {
    if (s->playmode == Play_MB_Trick_FRWD) sprintf(temp, "npt=-%d.%d", to / 100, to % 100);
    else                                   sprintf(temp, "npt=0-");
  }
  else if (to == -1)
  {
    sprintf(temp, "npt = %d.%d-", csecs / 100, csecs % 100);
  }
  else
  {
    sprintf(temp, "npt = %d.%d-%d.%d", csecs / 100, csecs % 100, to / 100, to % 100);
  }

  return;
}

/**************************************************************/
/* play_get_trick_stream_npt()                                */
/*                                                            */
/* Hackery to "adjust" NPT value for a trick stream based on  */
/* a normal play stream play time.                            */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session relating to the time;   */
/*                                                            */
/*             Play time in seconds from start of clip.       */
/*                                                            */
/* Returns:    Approximate trick play stream time relating to */
/*             the normal stream time given, *in cs*.         */
/**************************************************************/

static unsigned int play_get_trick_stream_npt(session * s, unsigned int npt)
{
  if (s->frames_per_sec == 0 || s->i_frame_ratio == 0)
  {
    /* If we're missing any values, assume a 2:1 ratio... :-/ */

    return npt / 2;
  }
  else
  {
    /* Kasenna said this - but it's wrong...                             */
    /*                                                                   */
    /*    return (unsigned int) ((double) npt / (s->i_frame_ratio + 1)); */
    /*                                                                   */
    /* This isn't any less hacky, but works a lot better:                */

    double d = s->frames_per_sec / (s->i_frame_ratio + 1);

    return (unsigned int) ((double) npt / d);
  }
}

/**************************************************************/
/* play_copy_frame_info()                                     */
/*                                                            */
/* Copy the frames per second and frame to I-frame ratio      */
/* values from one session to another.                        */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to destination session structure;      */
/*                                                            */
/*             Pointer to source session structure.           */
/**************************************************************/

static void play_copy_frame_info(session * dst, session * src)
{
  dst->frames_per_sec = src->frames_per_sec;
  dst->i_frame_ratio  = src->i_frame_ratio;

  return;
}

#if 0

  /**************************************************************/
  /* play_get_frame_number()                                    */
  /*                                                            */
  /* Given a time in seconds, return a frame number based on    */
  /* the frames/second value read from DESCRIBE (if present,    */
  /* else assume 25fps or 30fps depending on PAL / NTSC         */
  /* options).                                                  */
  /*                                                            */
  /* Must only be used after modulefp_enable has been called.   */
  /*                                                            */
  /* Parameters: Pointer to the session relating to the time;   */
  /*                                                            */
  /*             Play time in seconds from start of clip.       */
  /*                                                            */
  /* Returns:    Approximate frame number.                      */
  /**************************************************************/

  static unsigned int play_get_frame_number(session * s, unsigned int npt)
  {
    if (s->frames_per_sec != 0)
    {
      double d = s->frames_per_sec * npt;

      return (unsigned int) d;
    }
    else
    {
      _kernel_oserror * e;
      int               opts[4];
      int               fps;

      opts[0] = vc_tags_ntsc;
      opts[1] = 1;
      opts[2] = 0;
      opts[3] = vc_tags__end;

      e = _swix(VideoControl_ProtocolOptions,
                _INR(0,2),

                0,
                s->vcid,
                opts);

      if (e == NULL) fps = (opts[2] == 0) ? 25 : 30; /* That's slightly inaccurate for NTSC of course... */
      else           fps = 25;

      return fps * npt;
    }
  }

#endif
