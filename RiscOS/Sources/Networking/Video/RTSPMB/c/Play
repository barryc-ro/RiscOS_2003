/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Play.                            */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#include <swis.h>
#include <AsmUtils/modulefp.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "RTSPMErrors.h"
#include "Session.h"
#include "Status.h"
#include "Utils.h"

#include "Play.h"

/* Local structures and enumerations */

typedef enum play_state
{
  play_state_undefined = 0,
  play_state_set_playmode,
  play_state_play
}
play_state;

/* Local functions - miscellaneous */

static bool              play_slowmofwd            (const char * scale);
static int               play_process_speed        (const char * scale);

/* Local functions - general command sending assitance */

static _kernel_oserror * play_preamble             (session * s);
static _kernel_oserror * play_send                 (session * s);

/* Local functions - stuff called from the state machine as callback */
/* functions during execution of a command chain                     */

static _kernel_oserror * play_send_set_playmode    (session * s);
static _kernel_oserror * play_send_play            (session * s);
static _kernel_oserror * play_send_state_command   (session * s, play_state state);

/* Local functions - stuff used to build a set of command headers */
/* ready for sending out                                          */

static _kernel_oserror * play_build_pause          (session * s);
static _kernel_oserror * play_build_set_playmode   (session * s);
static _kernel_oserror * play_build_play           (session * s);
static _kernel_oserror * play_build_play_or_pause  (session * s, bool force_pause);

/* Local functions - floating point code used within */

static unsigned int      play_get_frame_number     (session * s, unsigned int seconds);
static unsigned int      play_get_trick_stream_npt (session * s, unsigned int npt);

/**************************************************************/
/* play_slowmofwd()                                           */
/*                                                            */
/* Work out whether reduced data rate slow motion forwards    */
/* play should be used for a given scale/speed specifier.     */
/*                                                            */
/* Parameters: Scale/speed specifier.                         */
/*                                                            */
/* Returns:    true to use reduced data rate slow motion      */
/*             forwards play (send a Speed header rather than */
/*             Scale), else false.                            */
/**************************************************************/

static bool play_slowmofwd(const char * scale)
{
  if (
       scale != NULL &&

       _swix(OS_Module,
             _INR(0,1),

             18,
             ReducedRateSlowmoSupportModule) /* Play.h */

       == NULL

       &&
       (
         !strncmp(scale, "0.", 2) ||
         *scale == '.'
       )
     )
     return true;

  return false;
}

/**************************************************************/
/* play_process_speed()                                       */
/*                                                            */
/* Process a string which should contain a number which may   */
/* be negative or a decimal fraction, e.g. "-0.4", "55",      */
/* ".4" but not (say) "1/3" or "    65".                      */
/*                                                            */
/* Parameters: Pointer to the string. If NULL, "1" is used.   */
/*                                                            */
/* Returns:    An int containing an indication of play mode   */
/*             within the string; see MPEGCtrl.h.             */
/**************************************************************/

static int play_process_speed(const char * scale)
{
  int type;

  if (scale == NULL || *scale == '\0') scale = "1";

  if      (!strcmp(scale, "1")) type = MPEGCtrl_MCRS_Trick_Play;
  else if (!strcmp(scale, "0")) type = MPEGCtrl_MCRS_Trick_Freeze;

  else if (strstr(scale, "0.") != NULL)
  {
    if (*scale == '-')          type = MPEGCtrl_MCRS_Trick_SRWD;
    else                        type = MPEGCtrl_MCRS_Trick_SFWD;
  }
  else if (*scale == '-')       type = MPEGCtrl_MCRS_Trick_FRWD;
  else                          type = MPEGCtrl_MCRS_Trick_FFWD;

  return type;
}

/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement RTSPMB_Play. See the Video Control               */
/* specification, 2501,817/FS, for more.                      */
/*                                                            */
/* This function always sends at least one command, which     */
/* is either PAUSE for zero speed or for a trick play mode    */
/* transition, or SET_PLAYMODE if playback is starting for    */
/* the first time. PLAY is used directly to exit PAUSE. A     */
/* command chain is set up which is dealt with by the state   */
/* machine calling back into play_send_play or                */
/* play_send_set_playmode.                                    */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  session * s         = session_find_by_id(r->r[1]);
  bool      slowmofwd = false; /* This is true for slowmo forward play     */
  bool      play      = true;  /* This is true for any non-pause play mode */
  bool      paused;
  char    * scale;

  dprintf(("", "play_play: Called\n"));

//printf("play_play: &%08X, '%s', '%s'\n",
//r->r[1],
//r->r[2] != 0 ? (char *) r->r[2] : "<NULL>",
//r->r[3] != 0 ? (char *) r->r[3] : "<NULL>");

  RetError(play_preamble(s));

  /* For forwards slow-mo, we don't use Scale, we use Speed. You can */
  /* just deliver the data more slowly. OVS' slowmo with Scale is    */
  /* awful; using Speed gives a much better result.                  */

  scale = (char *) r->r[3];

  if (scale && !strcmp(scale, "0")) play      = false;
  else                              slowmofwd = play_slowmofwd(scale);

  /* Is playback currently paused? */

  if (s->play_record != NULL && !strcmp(s->play_record, "0")) paused = true;
  else                                                        paused = false;

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Copy R2 and R3 away */

  free(s->range_record);
  s->range_record = Strdup(r->r[2] == 0 ? "" : (char *) r->r[2]);

  free(s->play_record);
  s->play_record = Strdup(scale == NULL ? "" : scale);

  if (s->play_record == NULL || s->range_record == NULL)
  {
    dprintf(("", "play_play: Play or range records NULL -> out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Work out the command order required (SET_PLAYMODE   */
  /* then PLAY, maybe with a PAUSE first, or just PAUSE) */

  if (!play)
  {
    dprintf(("", "play_play: Building PAUSE to pause\n"));

    s->next_command_cb = NULL;
    s->playmode        = Play_MB_Trick_Freeze;

    RetError(play_build_pause(s));
  }
  else
  {
    if (s->started != 0 && !paused)
    {
      dprintf(("", "play_play: Building PAUSE to change trick mode\n"));

      s->next_command_cb = play_send_set_playmode;

      RetError(play_build_pause(s));
    }
    else if (paused)
    {
      dprintf(("", "play_play: Building PLAY to unpause\n"));

      s->next_command_cb = NULL;
      s->playmode        = Play_MB_Trick_Play;

      RetError(play_build_play(s));
    }
    else
    {
      dprintf(("", "play_play: Building SET_PLAYMODE\n"));

      s->next_command_cb = play_send_play;

      RetError(play_build_set_playmode(s));
    }
  }


//printf("PR '%s' ",s->play_record);

  /* Send the command */

  dprintf(("", "play_play: Successful; exitting through play_send\n"));

  return play_send(s);
}

/**************************************************************/
/* play_replay_on_callout()                                   */
/*                                                            */
/* A CallOut handler (see CallOut.h) which loops video        */
/* playback through play_replay.                              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_replay_on_callout(void * handle)
{
  session * s = (session *) handle;

  if (s->loop_ready != 0)
  {
//    play_replay(s);
    s->loop_ready = 0;
  }
}

/**************************************************************/
/* play_replay()                                              */
/*                                                            */
/* Issue an "in-the-background" PLAY command to loop video    */
/* playback at the client end.                                */
/*                                                            */
/* Parameters: Pointer to a session struct for the video to   */
/*             loop.                                          */
/**************************************************************/

_kernel_oserror * play_replay(session * s)
{
  _kernel_oserror * e;
  bool              fail = false;
  bool              slowmofwd;
  char            * port;
  char            * range;
  char            * scale;
  session         * new_s;

  dprintf(("", "play_replay: Called for %p\n", s));

  if (s->server_session == NULL)
  {
    dprintf(("", "play_replay: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Cancel any GET_PARAMETER manually - it won't be done automatically */
  /* as we're not resetting this session, we're spawning a new one      */

  if (s->gp_set != 0)
  {
    untimeout(getparam_proceed_on_callout, s);
    s->gp_set = 0;
  }

  if (s->child) session_free_item(s->child);

  /* Create a new session */

  e = session_new_session(&new_s);

  if (e)
  {
    dprintf(("", "play_replay: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  if (new_s == NULL)
  {
    dprintf(("", "play_replay: Out of memory for new_s\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  new_s->id     = ++id_counter; /* See Global.h */

  new_s->parent = s;
  s->child      = new_s;

  /* We *should* have the play scale (speed) stored */

  scale = s->play_record == NULL ? Headers_HeaderValue_Scale : s->play_record;
  if (*scale == '\0') scale = Headers_HeaderValue_Scale;

  /* Range will depend on direction of play */

  if (*scale == '-')
  {
    range = Headers_HeaderValue_Range_Rwd;
  }
  else
  {
    range = Headers_HeaderValue_Range_Fwd;
  }

  /* Slow motion forwards play? */

  slowmofwd = play_slowmofwd(scale);

  /* Ensure everything is initialised for a new command in this clean session */

  session_reset_session(new_s);

  if (
       headers_add_header(&new_s->headers,
                          Headers_CommandName_Play,
                          s->url->full)
       == NULL
     )
     fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&new_s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Content length */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_ContentLength,
                               "0")
            == NULL
          )
          fail = true;

  /* Range */

//  else if (
//            *range != '\0' &&
//
//            headers_add_header(&new_s->headers,
//                               Headers_HeaderName_Range,
//                               range)
//            == NULL
//          )
//          fail = true;

  /* The Scale/Speed header value was worked out above */

  else if (
            *scale != '\0' &&

            headers_add_header(&new_s->headers,
                               slowmofwd ? Headers_HeaderName_Speed : Headers_HeaderName_Scale,
                               scale)
            == NULL
          )
          fail = true;

  /* Lastly, the session header */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail)
  {
    dprintf(("", "play_replay: Out of memory\n"));
    session_free_item(new_s);
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* This session should self destruct */

  new_s->destruct = 1;

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = s->url->port;
  else                               port = NULL;

  if (s->sd == -1) s->sd = opensock(s->url->host,
                                    RTSPMB_DefaultPort,
                                    port,
                                    &new_s->state,
                                    -1);

  else s->state = protostate_CONNECTED;

  new_s->sd   = s->sd;
  new_s->last = utils_read_time();

  dprintf(("", "play_replay: Socket descriptor %d, state %d\n", new_s->sd, new_s->state));

  /* Set the state machine going to see errors and DNS stuff; */
  /* in addition, rerun it for the parent session to get      */
  /* another GET_PARAMETER scheduled.                         */

  new_s->callout_set = 1;
  timeout(status_proceed_on_callout, new_s, Session_State_Timer);

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_replay: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_preamble()                                            */
/*                                                            */
/* For a given session, check the pointer is not NULL, that   */
/* no command is currently in progress and that there is a    */
/* server session.                                            */
/*                                                            */
/* This is normally the first thing done in a function that   */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to the session struct (may be NULL).   */
/*                                                            */
/* Returns:    An error if there is some problem with using   */
/*             the session for a new PLAY command, else NULL. */
/**************************************************************/

static _kernel_oserror * play_preamble(session * s)
{
  dprintf(("", "play_preamble: Called for &%08X\n", (int) s));

  if (s == NULL)
  {
    dprintf(("", "play_preamble: ID not found\n"));

    return make_error(rtspmb_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (
       s->state == protostate_DNS       ||
       s->state == protostate_CONNECTED ||
       s->state == protostate_SENDING   ||
       s->state == protostate_RECEIVING ||
       s->state == protostate_PUMPING
     )
  {
    dprintf(("", "play_preamble: In progress\n"));

    return make_error(rtspmb_ERROR_IN_PROGRESS, 0);
  }

  if (s->server_session == NULL)
  {
    dprintf(("", "play_preamble: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  dprintf(("", "play_preamble: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send()                                                */
/*                                                            */
/* Once a session has been fully initialised with all the     */
/* data needed to send a command, kick off the send.          */
/*                                                            */
/* This is normally the last thing done in a function that    */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_send(session * s)
{
  int port;

  dprintf(("", "play_send: Called for &%08X\n", (int) s));

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  if (s->sd == -1) s->sd = opensock(s->url->host,
                                    port,
                                    NULL,
                                    &s->state,
                                    -1);

  else s->state = protostate_CONNECTED;

  s->last = utils_read_time();

  dprintf(("", "play_send: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Set the state machine going to see errors and DNS stuff. The call */
  /* to session_reset_session should've cleared the callout but it     */
  /* never hurts to be sure (in future maybe stuff could go on in the  */
  /* background that could have set a callout between the reset and    */
  /* this part of the code).                                           */

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_send: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_set_playmode()                                   */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the second item in a chain of commands for the     */
/* server (the first must be PAUSE). The next command         */
/* callback is set to play_send_play. A command chain which   */
/* involves calling this function is always started inside    */
/* play_play.                                                 */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful PAUSE command.                      */
/**************************************************************/

static _kernel_oserror * play_send_set_playmode(session * s)
{
  dprintf(("", "play_send_set_playmode: Called for &%08X\n", (int) s));

  RetError(play_build_set_playmode(s));
  RetError(play_send_state_command(s, play_state_set_playmode));

  dprintf(("", "play_send_set_playmode: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_play()                                           */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the last item in a chain of commands for the       */
/* server and sends the actual PLAY command off. No further   */
/* callback function is set.                                  */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful SET_PLAYMODE command.               */
/**************************************************************/

static _kernel_oserror * play_send_play(session * s)
{
  dprintf(("", "play_send_play: Called for &%08X\n", (int) s));

  RetError(play_build_play(s));
  RetError(play_send_state_command(s, play_state_play));

  dprintf(("", "play_send_play: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_state_command()                                  */
/*                                                            */
/* Deal with the mechanics of building a relevant command and */
/* setting any required next command callback, for a chain of */
/* play-related commands for the server. This is only used    */
/* for second and subsequent commands - play_play deals with  */
/* the extra complexity of the initial command (not least,    */
/* working out exactly what command to send).                 */
/*                                                            */
/* Parameters: Pointer to a session structure;                */
/*                                                            */
/*             A play_state (see top of file) indicating the  */
/*             command to send, which influences what the     */
/*             next command callback is set to.               */
/**************************************************************/

static _kernel_oserror * play_send_state_command(session * s, play_state state)
{
  dprintf(("", "play_send_state_command: Called\n"));

  RetError(play_preamble(s));

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Build the command */

  switch(state)
  {
    case play_state_set_playmode:
    {
      dprintf(("", "play_send_state_command: SET_PLAYMODE\n"));

      /* Build the SET_PLAYMODE command */

      RetError(play_build_set_playmode(s));
      s->next_command_cb = play_send_play;
    }
    break;

    case play_state_play:
    {
      dprintf(("", "play_send_state_command: PLAY/PAUSE\n"));

      /* Build the PLAY or PAUSE command (should always be PLAY in practice) */

      RetError(play_build_play_or_pause(s, 0));
      s->next_command_cb = NULL; /* session_reset_session should do that, but just in case... */
    }
    break;

    default:
    {
      dprintf(("", "play_send_state_command: Unknown command state!\n"));

      return make_error(rtspmb_ERROR_UNKNOWN_COMMAND_STATE, 0);
    }
    break;
  }

  /* Send the command */

  return play_send(s);
}

/**************************************************************/
/* play_build_pause()                                         */
/*                                                            */
/* Build a forced PAUSE command in a session, ignoring the    */
/* play_record details of required speed. This is intended    */
/* for use in trick play mode transitions where three         */
/* commands (PAUSE, SET_PLAYMODE then PLAY) must be sent.     */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_pause(session * s)
{
//printf("play_build_pause ");

  return play_build_play_or_pause(s, true);
}

/**************************************************************/
/* play_build_set_playmode()                                  */
/*                                                            */
/* Build a SET_PLAYMODE command inside the given session      */
/* based on the play_record and URL details inside it.        */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Assumes:    The play_record field does not indicate zero   */
/*             speed (pause).                                 */
/**************************************************************/

static _kernel_oserror * play_build_set_playmode(session * s)
{
  char * playmode = NULL;
  bool   fail     = false;

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;
  else
  {
    playmode = malloc(sizeof(Headers_HeaderValue_ContentLength) - 1); /* We want the terminator included; the -1 is there as '%d' will end up as a single digit number */

    /* The content length header value is a bit of a hack; it must be the last */
    /* item as it holds a double CR LF and a "Playmode:" entry for the body    */
    /* text of our SET_PLAYMODE command. It's a nasty way of doing it, but     */
    /* very cheap in code terms.                                               */

    if (playmode != NULL)
    {
      int type = play_process_speed(s->play_record);
      int mode;

      /* Rather than modify play_process_speed to spit out MediaBase stuff directly, */
      /* the full accuracy of play methods is kept, in case future MediaBase servers */
      /* support features missing at the time of writing (e.g. SFWD play).           */

      switch (type)
      {
        case MPEGCtrl_MCRS_Trick_FFWD:   mode = Play_MB_Trick_FFWD;   break;
        case MPEGCtrl_MCRS_Trick_SFWD:   mode = Play_MB_Trick_Play;   break; /* No SFWD on MediaBase */
        case MPEGCtrl_MCRS_Trick_Freeze: mode = Play_MB_Trick_Freeze; break;
        case MPEGCtrl_MCRS_Trick_FRWD:   mode = Play_MB_Trick_FRWD;   break;
        case MPEGCtrl_MCRS_Trick_SRWD:   mode = Play_MB_Trick_FRWD;   break; /* No SRWD on MediaBase */

        default:
        case MPEGCtrl_MCRS_Trick_Play:   mode = Play_MB_Trick_Play;   break;
      }

      sprintf(playmode,
              Headers_HeaderValue_ContentLength,
              mode);

      s->playmode = mode;
    }
  }

  if (playmode == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_SetPlayMode,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Content type for the play mode etc. */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentType,
                               Headers_HeaderValue_ContentType)
            == NULL
          )
          fail = true;

  /* Content length - THIS MUST BE THE LAST ITEM ADDED */

  else
  {
    _kernel_oserror * e;
    int               opts     [4];
    char              temp     [1024]; //// Fix me, temporary Friday hack; use malloc
    unsigned int      frame;

    opts[0] = vc_tags_npt;
    opts[1] = 1;
    opts[2] = 0;
    opts[3] = vc_tags__end;

    e = _swix(VideoControl_ProtocolOptions,
              _INR(0,2),

              0,
              s->vcid,
              opts);

    if (e != NULL) frame = 0;
    else           frame = (unsigned int) opts[2];

    /* If that fails, try MPEGVideo_ReadParameters for time code */

    if (frame == 0)
    {
      unsigned int tc;

      e = _swix(MPEGVideo_ReadParameters,
                _INR(0,2) | _OUT(1),

                0,
                0,
                0,

                &tc);

      /* This is in hours, minute and seconds - convert to seconds */

      if (tc != 0xffffffff) /* (indicates unknown time) */
      {
        frame =           ((tc & 0x000FC0) >> 6)  +
                60 *      ((tc & 0x03F000) >> 12) +
                60 * 60 * ((tc & 0xFC0000) >> 18);
      }
    }

    /* Convert the time in seconds (currently held in 'frame') */
    /* into a real - if approximate! - frame number            */

    {
      modulefp_buf buf;

      modulefp_enable(&buf);
      frame = play_get_frame_number(s, frame);
      modulefp_disable(&buf);
    }

    sprintf(temp,
            "Playmode:%d\r\n", //Frame:%d\r\n",
            s->playmode);      //,
                               //frame);

    sprintf(playmode,
            "%d\r\n\r\n%s",
            strlen(temp),
            temp);

    if (
         headers_add_header(&s->headers,
                            Headers_HeaderName_ContentLength,
                            playmode)
         == NULL
       )
       fail = true;
  }

  /* Did anything fail? */

  free(playmode);

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_build_play()                                          */
/*                                                            */
/* Build a PLAY command inside the given session based on     */
/* the play_record and URL details inside it. If play_record  */
/* shows the speed to be zero, PAUSE is sent instead.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_play(session * s)
{
//printf("play_build_play ");

  return play_build_play_or_pause(s, false);
}

/**************************************************************/
/* play_build_play_or_pause()                                 */
/*                                                            */
/* Service function originally built for play_build_play and  */
/* play_build_pause.                                          */
/*                                                            */
/* Builds a PLAY or PAUSE command inside the given session    */
/* based either on the play_record and URL details inside it, */
/* or just on the URL information if play_record is to be     */
/* ignored (PAUSE commands only).                             */
/*                                                            */
/* Parameters: Pointer to a relevant session structure;       */
/*                                                            */
/*             true to ignore play_record and send PAUSE,     */
/*             false to send PLAY or PAUSE according to the   */
/*             play_record setting.                           */
/**************************************************************/

static _kernel_oserror * play_build_play_or_pause(session * s, bool force_pause)
{
  char * scale;
  bool   play      = true;
  bool   fail      = false;
  bool   slowmofwd = false;

  scale = s->play_record == NULL ? "" : s->play_record;

  /* If forced to go into pause mode, set things up as required; */
  /* otherwise determine the state from the play scale value.    */

  if (force_pause == false)
  {
    if (scale && !strcmp(scale, "0")) play      = false;
    else                              slowmofwd = play_slowmofwd(scale);
  }
  else
  {
    play  = false;
    scale = "0";
  }

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               play ? Headers_CommandName_Play : Headers_CommandName_Pause,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Range */

  else if (play)
  {
    _kernel_oserror * e;
    int               opts [4];
    char              temp [sizeof("npt = 0-0") + 24]; /* Ensure we overestimate */
    unsigned int      secs, tc;

    /* Read NPT */

    opts[0] = vc_tags_npt;
    opts[1] = 1;
    opts[2] = 0;
    opts[3] = vc_tags__end;

    e = _swix(VideoControl_ProtocolOptions,
              _INR(0,2),

              0,
              s->vcid,
              opts);

    if (e != NULL) secs = 0;
    else           secs = (unsigned int) opts[2] * 100; /* seconds -> centiseconds */

    /* Read timecode */

    e = _swix(MPEGVideo_ReadParameters,
              _INR(0,2) | _OUT(1),

              0,
              0,
              0,

              &tc);

    /* This is in hours, minute and seconds - convert to seconds; */
    /* use timecode if available. If not, and NPT is zero, use a  */
    /* cached value - i.e. assume we're at a transition point and */
    /* had no data to work on.                                    */

    if (e == NULL)
    {
      if (tc != 0xffffffff) /* (indicates unknown time) */
      {
        secs =           ((tc & 0x000FC0) >> 6)  +
               60 *      ((tc & 0x03F000) >> 12) +
               60 * 60 * ((tc & 0xFC0000) >> 18) +
               1; /* Fudge factor...! :-( */

        secs *= 100; /* seconds -> centiseconds */
      }
      else if (secs == 0) /* I.e. NPT = 0 */
      {
        secs = s->cached_npt;
      }
    }

    /* Set the cached value */

    s->cached_npt = secs;

    /* Work around apparent MediaBase trick mode seek bug */

    if (s->playmode != Play_MB_Trick_Play && s->playmode != Play_MB_Trick_Freeze)
    {
      modulefp_buf buf;

      modulefp_enable(&buf);
      secs = play_get_trick_stream_npt(s, secs);
      modulefp_disable(&buf);
    }

    sprintf(temp, "npt = %d.%d-", secs / 100, secs % 100);

    if (
         headers_add_header(&s->headers,
                            Headers_HeaderName_Range,
                            temp)
         == NULL
       )
       fail = true;
  }

  /* If we're not pausing, the playback rate - first, Scale playback (trick play) */

  if (fail == false  &&
      play           &&
      !slowmofwd     &&
      scale != NULL  &&
      *scale != '\0' &&

      headers_add_header(&s->headers,
                         Headers_HeaderName_Scale,
                         scale)
      == NULL
    )
    fail = true;

  /* Second, Speed playback (alter data delivery rate, for slowmo forwards play) */

  else if (
            play           &&
            slowmofwd      &&
            scale != NULL  && /* It should never be if slowmofwd is true, but just in case... */
            *scale != '\0' &&

            headers_add_header(&s->headers,
                               Headers_HeaderName_Speed,
                               scale)
            == NULL
          )
          fail = true;

  /* Lastly, the session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_get_frame_number()                                    */
/*                                                            */
/* Given a time in seconds, return a frame number based on    */
/* the frames/second value read from DESCRIBE (if present,    */
/* else assume 25fps or 30fps depending on PAL / NTSC         */
/* options).                                                  */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session relating to the time;   */
/*                                                            */
/*             Play time in seconds from start of clip.       */
/*                                                            */
/* Returns:    Approximate frame number.                      */
/**************************************************************/

static unsigned int play_get_frame_number(session * s, unsigned int seconds)
{
  if (s->frames_per_sec != 0)
  {
    double d = s->frames_per_sec * seconds;

    return (unsigned int) d;
  }
  else
  {
    _kernel_oserror * e;
    int               opts[4];
    int               fps;

    opts[0] = vc_tags_ntsc;
    opts[1] = 1;
    opts[2] = 0;
    opts[3] = vc_tags__end;

    e = _swix(VideoControl_ProtocolOptions,
              _INR(0,2),

              0,
              s->vcid,
              opts);

    if (e == NULL) fps = (opts[2] == 0) ? 25 : 30; /* That's slightly inaccurate for NTSC of course... */
    else           fps = 25;

    return fps * seconds;
  }
}

/**************************************************************/
/* play_get_trick_stream_npt()                                */
/*                                                            */
/* Hackery to "adjust" NPT value for a trick stream based on  */
/* a normal play stream play time.                            */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session relating to the time;   */
/*                                                            */
/*             Play time in seconds from start of clip.       */
/*                                                            */
/* Returns:    Approximate trick play stream time relating to */
/*             the normal stream time given, *in cs*.         */
/**************************************************************/

static unsigned int play_get_trick_stream_npt(session * s, unsigned int npt)
{
  if (s->frames_per_sec == 0 || s->i_frame_ratio == 0)
  {
    /* If we're missing any values, assume a 2:1 ratio... :-/ */

    return npt / 2;
  }
  else
  {
    double d = s->frames_per_sec / s->i_frame_ratio;

    return (unsigned int) ((double) npt / d);
  }
}
