/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Play.                            */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "RTSPMErrors.h"
#include "Session.h"
#include "Status.h"
#include "Utils.h"

#include "Play.h"

/* Local structures and enumerations */

typedef enum play_state
{
  play_state_undefined = 0,
  play_state_set_playmode,
  play_state_play
}
play_state;

/* Local functions - miscellaneous */

static bool              play_slowmofwd           (const char * scale);

/* Local functions - general command sending assitance */

static _kernel_oserror * play_preamble            (session * s);
static _kernel_oserror * play_send                (session * s);

/* Local functions - stuff called from the state machine as callback */
/* functions during execution of a command chain                     */

static _kernel_oserror * play_send_set_playmode   (session * s);
static _kernel_oserror * play_send_play           (session * s);
static _kernel_oserror * play_send_state_command  (session * s, play_state state);

/* Local functions - stuff used to build a set of command headers */
/* ready for sending out                                          */

static _kernel_oserror * play_build_pause         (session * s);
static _kernel_oserror * play_build_set_playmode  (session * s);
static _kernel_oserror * play_build_play          (session * s);
static _kernel_oserror * play_build_play_or_pause (session * s, bool force_pause);

/**************************************************************/
/* play_slowmofwd()                                           */
/*                                                            */
/* Work out whether reduced data rate slow motion forwards    */
/* play should be used for a given scale/speed specifier.     */
/*                                                            */
/* Parameters: Scale/speed specifier.                         */
/*                                                            */
/* Returns:    true to use reduced data rate slow motion      */
/*             forwards play (send a Speed header rather than */
/*             Scale), else false.                            */
/**************************************************************/

static bool play_slowmofwd(const char * scale)
{
  if (
       scale != NULL &&

       _swix(OS_Module,
             _INR(0,1),

             18,
             ReducedRateSlowmoSupportModule) /* Play.h */

       == NULL

       &&
       (
         !strncmp(scale, "0.", 2) ||
         *scale == '.'
       )
     )
     return true;

  return false;
}

/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement RTSPMB_Play. See the Video Control               */
/* specification, 2501,817/FS, for more.                      */
/*                                                            */
/* This function always sends at least one command, which     */
/* is either PAUSE for zero speed or for a trick play mode    */
/* transition, or SET_PLAYMODE if playback is starting for    */
/* the first time. A command chain is set up which is dealt   */
/* with by the state machine calling back into play_send_play */
/* or play_send_set_playmode.                                 */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  session * s         = session_find_by_id(r->r[1]);
  bool      slowmofwd = false; /* This is true for slowmo forward play     */
  bool      play      = true;  /* This is true for any non-pause play mode */
  bool      paused;
  char    * scale;

  dprintf(("", "play_play: Called\n"));

  RetError(play_preamble(s));

  /* For forwards slow-mo, we don't use Scale, we use Speed. You can */
  /* just deliver the data more slowly. OVS' slowmo with Scale is    */
  /* awful; using Speed gives a much better result.                  */

  scale = (char *) r->r[3];

  if (scale && !strcmp(scale, "0")) play      = false;
  else                              slowmofwd = play_slowmofwd(scale);

  /* Is playback currently paused? */

  if (s->play_record != NULL && !strcmp(s->play_record, "0")) paused = true;
  else                                                        paused = false;

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Copy R2 and R3 away */

  free(s->range_record);
  s->range_record = Strdup(r->r[2] == 0 ? "" : (char *) r->r[2]);

  free(s->play_record);
  s->play_record = Strdup(scale == NULL ? "" : scale);

  if (s->play_record == NULL || s->range_record == NULL)
  {
    dprintf(("", "play_play: Play or range records NULL -> out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Work out the command order required (SET_PLAYMODE   */
  /* then PLAY, maybe with a PAUSE first, or just PAUSE) */

  if (!play)
  {
    dprintf(("", "play_play: Building PAUSE to pause\n"));

    s->next_command_cb = NULL;
    RetError(play_build_pause(s));
  }
  else
  {
    if (s->started != 0 || paused)
    {
      dprintf(("", "play_play: Building PAUSE to change trick mode\n"));

      s->next_command_cb = play_send_set_playmode;
      RetError(play_build_pause(s));
    }
    else
    {
      dprintf(("", "play_play: Building SET_PLAYMODE\n"));

      s->next_command_cb = play_send_play;
      RetError(play_build_set_playmode(s));
    }
  }

  /* Send the command */

  dprintf(("", "play_play: Successful; exitting through play_send\n"));

  return play_send(s);
}

/**************************************************************/
/* play_replay_on_callout()                                   */
/*                                                            */
/* A CallOut handler (see CallOut.h) which loops video        */
/* playback through play_replay.                              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_replay_on_callout(void * handle)
{
  session * s = (session *) handle;

  if (s->loop_ready != 0)
  {
//    play_replay(s);
    s->loop_ready = 0;
  }
}

/**************************************************************/
/* play_replay()                                              */
/*                                                            */
/* Issue an "in-the-background" PLAY command to loop video    */
/* playback at the client end.                                */
/*                                                            */
/* Parameters: Pointer to a session struct for the video to   */
/*             loop.                                          */
/**************************************************************/

_kernel_oserror * play_replay(session * s)
{
  _kernel_oserror * e;
  bool              fail = false;
  bool              slowmofwd;
  char            * port;
  char            * range;
  char            * scale;
  session         * new_s;

  dprintf(("", "play_replay: Called for %p\n", s));

  if (s->server_session == NULL)
  {
    dprintf(("", "play_replay: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Cancel and GET_PARAMETER manually - it won't be done automatically */
  /* as we're not resetting this session, we're spawning a new one      */

  if (s->gp_set != 0)
  {
    untimeout(getparam_proceed_on_callout, s);
    s->gp_set = 0;
  }

  if (s->child) session_free_item(s->child);

  /* Create a new session */

  e = session_new_session(&new_s);

  if (e)
  {
    dprintf(("", "play_replay: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  if (new_s == NULL)
  {
    dprintf(("", "play_replay: Out of memory for new_s\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  new_s->id     = ++id_counter; /* See Global.h */

  new_s->parent = s;
  s->child      = new_s;

  /* We *should* have the play scale (speed) stored */

  scale = s->play_record == NULL ? Headers_HeaderValue_Scale : s->play_record;
  if (*scale == '\0') scale = Headers_HeaderValue_Scale;

  /* Range will depend on direction of play */

  if (*scale == '-')
  {
    range = Headers_HeaderValue_Range_Rwd;
  }
  else
  {
    range = Headers_HeaderValue_Range_Fwd;
  }

  /* Slow motion forwards play? */

  slowmofwd = play_slowmofwd(scale);

  /* Ensure everything is initialised for a new command in this clean session */

  session_reset_session(new_s);

  if (
       headers_add_header(&new_s->headers,
                          Headers_CommandName_Play,
                          s->url->full)
       == NULL
     )
     fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&new_s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Content length */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_ContentLength,
                               "0")
            == NULL
          )
          fail = true;

  /* Range */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_Range,
                               range)
            == NULL
          )
          fail = true;

  /* The Scale/Speed header value was worked out above */

  else if (
            headers_add_header(&new_s->headers,
                               slowmofwd ? Headers_HeaderName_Speed : Headers_HeaderName_Scale,
                               scale)
            == NULL
          )
          fail = true;

  /* Lastly, the session header */

  else if (
            headers_add_header(&new_s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail)
  {
    dprintf(("", "play_replay: Out of memory\n"));
    session_free_item(new_s);
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* This session should self destruct */

  new_s->destruct = 1;

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = s->url->port;
  else                               port = NULL;

  if (s->sd == -1) s->sd = opensock(s->url->host,
                                    RTSPMB_DefaultPort,
                                    port,
                                    &new_s->state,
                                    -1);

  else s->state = protostate_CONNECTED;

  new_s->sd   = s->sd;
  new_s->last = utils_read_time();

  dprintf(("", "play_replay: Socket descriptor %d, state %d\n", new_s->sd, new_s->state));

  /* Set the state machine going to see errors and DNS stuff; */
  /* in addition, rerun it for the parent session to get      */
  /* another GET_PARAMETER scheduled.                         */

  new_s->callout_set = 1;
  timeout(status_proceed_on_callout, new_s, Session_State_Timer);

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_replay: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_preamble()                                            */
/*                                                            */
/* For a given session, check the pointer is not NULL, that   */
/* no command is currently in progress and that there is a    */
/* server session.                                            */
/*                                                            */
/* This is normally the first thing done in a function that   */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to the session struct (may be NULL).   */
/*                                                            */
/* Returns:    An error if there is some problem with using   */
/*             the session for a new PLAY command, else NULL. */
/**************************************************************/

static _kernel_oserror * play_preamble(session * s)
{
  dprintf(("", "play_preamble: Called for &%08X\n", (int) s));

  if (s == NULL)
  {
    dprintf(("", "play_preamble: ID not found\n"));

    return make_error(rtspmb_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (
       s->state == protostate_DNS       ||
       s->state == protostate_CONNECTED ||
       s->state == protostate_SENDING   ||
       s->state == protostate_RECEIVING ||
       s->state == protostate_PUMPING
     )
  {
    dprintf(("", "play_preamble: In progress\n"));

    return make_error(rtspmb_ERROR_IN_PROGRESS, 0);
  }

  if (s->server_session == NULL)
  {
    dprintf(("", "play_preamble: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  dprintf(("", "play_preamble: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send()                                                */
/*                                                            */
/* Once a session has been fully initialised with all the     */
/* data needed to send a command, kick off the send.          */
/*                                                            */
/* This is normally the last thing done in a function that    */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_send(session * s)
{
  int port;

  dprintf(("", "play_send: Called for &%08X\n", (int) s));

  /* Open a connection to send the command down */

  if (s->url->port && *s->url->port) port = atoi(s->url->port);
  else                               port = RTSPMB_DefaultPort;

  if (s->sd == -1) s->sd = opensock(s->url->host,
                                    port,
                                    NULL,
                                    &s->state,
                                    -1);

  else s->state = protostate_CONNECTED;

  s->last = utils_read_time();

  dprintf(("", "play_send: Socket descriptor %d, state %d\n", s->sd, s->state));

  /* Set the state machine going to see errors and DNS stuff. The call */
  /* to session_reset_session should've cleared the callout but it     */
  /* never hurts to be sure (in future maybe stuff could go on in the  */
  /* background that could have set a callout between the reset and    */
  /* this part of the code).                                           */

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  dprintf(("", "play_send: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_set_playmode()                                   */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the second item in a chain of commands for the     */
/* server (the first must be PAUSE). The next command         */
/* callback is set to play_send_play. A command chain which   */
/* involves calling this function is always started inside    */
/* play_play.                                                 */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful PAUSE command.                      */
/**************************************************************/

static _kernel_oserror * play_send_set_playmode(session * s)
{
  dprintf(("", "play_send_set_playmode: Called for &%08X\n", (int) s));

  RetError(play_build_set_playmode(s));
  RetError(play_send_state_command(s, play_state_set_playmode));

  dprintf(("", "play_send_set_playmode: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_play()                                           */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the last item in a chain of commands for the       */
/* server and sends the actual PLAY command off. No further   */
/* callback function is set.                                  */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful SET_PLAYMODE command.               */
/**************************************************************/

static _kernel_oserror * play_send_play(session * s)
{
  dprintf(("", "play_send_play: Called for &%08X\n", (int) s));

  RetError(play_build_play(s));
  RetError(play_send_state_command(s, play_state_play));

  dprintf(("", "play_send_play: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_state_command()                                  */
/*                                                            */
/* Deal with the mechanics of building a relevant command and */
/* setting any required next command callback, for a chain of */
/* play-related commands for the server. This is only used    */
/* for second and subsequent commands - play_play deals with  */
/* the extra complexity of the initial command (not least,    */
/* working out exactly what command to send).                 */
/*                                                            */
/* Parameters: Pointer to a session structure;                */
/*                                                            */
/*             A play_state (see top of file) indicating the  */
/*             command to send, which influences what the     */
/*             next command callback is set to.               */
/**************************************************************/

static _kernel_oserror * play_send_state_command(session * s, play_state state)
{
  dprintf(("", "play_send_state_command: Called\n"));

  RetError(play_preamble(s));

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Build the command */

  switch(state)
  {
    case play_state_set_playmode:
    {
      dprintf(("", "play_send_state_command: SET_PLAYMODE\n"));

      /* Build the SET_PLAYMODE command */

      RetError(play_build_set_playmode(s));
      s->next_command_cb = play_send_play;
    }
    break;

    case play_state_play:
    {
      dprintf(("", "play_send_state_command: PLAY/PAUSE\n"));

      /* Build the PLAY or PAUSE command (should always be PLAY in practice) */

      RetError(play_build_play_or_pause(s, 0));
      s->next_command_cb = NULL; /* session_reset_session should do that, but just in case... */
    }
    break;

    default:
    {
      dprintf(("", "play_send_state_command: Unknown command state!\n"));

      return make_error(rtspmb_ERROR_UNKNOWN_COMMAND_STATE, 0);
    }
    break;
  }

  /* Send the command */

  return play_send(s);
}

/**************************************************************/
/* play_build_pause()                                         */
/*                                                            */
/* Build a forced PAUSE command in a session, ignoring the    */
/* play_record details of required speed. This is intended    */
/* for use in trick play mode transitions where three         */
/* commands (PAUSE, SET_PLAYMODE then PLAY) must be sent.     */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_pause(session * s)
{
printf("play_build_pause ");

  return play_build_play_or_pause(s, true);
}

/**************************************************************/
/* play_build_set_playmode()                                  */
/*                                                            */
/* Build a SET_PLAYMODE command inside the given session      */
/* based on the play_record and URL details inside it.        */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Assumes:    The play_record field does not indicate zero   */
/*             speed (pause).                                 */
/**************************************************************/

static _kernel_oserror * play_build_set_playmode(session * s)
{
  bool fail = false;

printf("play_build_set_playmode ");

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_SetPlayMode,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Content type for the play mode etc. */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentType,
                               Headers_HeaderValue_ContentType)
            == NULL
          )
          fail = true;

  /* Content length */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentLength,
                               "12\r\n\r\nPlaymode:2\r\n") /* :-) */
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_build_play()                                          */
/*                                                            */
/* Build a PLAY command inside the given session based on     */
/* the play_record and URL details inside it. If play_record  */
/* shows the speed to be zero, PAUSE is sent instead.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_play(session * s)
{
printf("play_build_play ");

  return play_build_play_or_pause(s, false);
}

/**************************************************************/
/* play_build_play_or_pause()                                 */
/*                                                            */
/* Service function originally built for play_build_play and  */
/* play_build_pause.                                          */
/*                                                            */
/* Builds a PLAY or PAUSE command inside the given session    */
/* based either on the play_record and URL details inside it, */
/* or just on the URL information if play_record is to be     */
/* ignored (PAUSE commands only).                             */
/*                                                            */
/* Parameters: Pointer to a relevant session structure;       */
/*                                                            */
/*             true to ignore play_record and send PAUSE,     */
/*             false to send PLAY or PAUSE according to the   */
/*             play_record setting.                           */
/**************************************************************/

static _kernel_oserror * play_build_play_or_pause(session * s, bool force_pause)
{
  char * scale;
  bool   play      = true;
  bool   fail      = false;
  bool   slowmofwd = false;

  scale = s->play_record == NULL ? "" : s->play_record;

  /* If forced to go into pause mode, set things up as required; */
  /* otherwise determine the state from the play scale value.    */

  if (force_pause == false)
  {
    if (scale && !strcmp(scale, "0")) play      = false;
    else                              slowmofwd = play_slowmofwd(scale);
  }
  else
  {
    play  = false;
    scale = "0";
  }

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               play ? Headers_CommandName_Play : Headers_CommandName_Pause,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Range */

  else if (
            s->range_record  != NULL &&
            *s->range_record != '\0' &&

            headers_add_header(&s->headers,
                               Headers_HeaderName_Range,
                               s->range_record)
            == NULL
          )
          fail = true;

  /* If we're not pausing, the playback rate - first, Scale playback (trick play) */

  else if (
            play          &&
            !slowmofwd    &&
            scale != NULL &&

            headers_add_header(&s->headers,
                               Headers_HeaderName_Scale,
                               scale)
            == NULL
          )
          fail = true;

  /* Second, Speed playback (alter data delivery rate, for slowmo forwards play) */

  else if (
            play          &&
            slowmofwd     &&
            scale != NULL && /* It should never be if slowmofwd is true, but just in case... */

            headers_add_header(&s->headers,
                               Headers_HeaderName_Speed,
                               scale)
            == NULL
          )
          fail = true;

  /* Lastly, the session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}
