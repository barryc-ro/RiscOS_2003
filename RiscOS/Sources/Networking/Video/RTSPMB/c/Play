/**************************************************************/
/* File:    Play.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Implement RTSPMB_Play.                            */
/*                                                            */
/* Author:  A.D.Hodgkinson. Based on URL_Fetcher source by    */
/*          S.N.Brodie and P. Wain.                           */
/*                                                            */
/* History: 01-Dec-2000 (ADH): Imported from RTSP OVS.        */
/*          08-Mar-2002 (JRB): Updated for MediaBase 6.       */
/*          01-Apr-2002 (JRB): Updated to support sequences.  */
/*          31-May-2002 (JRB): Updated to support MediaBase   */
/*                             6.0.1, MPEG 1 trick play,      */
/*                             audio-only assets and          */
/*                             near-line storage assets.      */
/**************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>

#include <swis.h>
#include <AsmUtils/modulefp.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <VideoCtrl.h>

#include "AMPlay.h"
#include "CallOut.h"
#include "Connect.h"
#include "Generic.h"
#include "GetParam.h"
#include "Global.h"
#include "Headers.h"
#include "Module.h"
#include "MPEGCtrl.h"
#include "Response.h"
#include "RTSPMErrors.h"
#include "Session.h"
#include "Setup.h"
#include "Status.h"
#include "Utils.h"

#include "Play.h"

/* Local structures and enumerations */

typedef enum play_state
{
  play_state_undefined = 0,
  play_state_setparam,
  play_state_initial,
  play_state_set_playmode,
  play_state_play
}
play_state;

/* Local definitions */

#define Play_SetParam_Timer         (500)
#define Play_Read_TimeCode_Timer    (100)
#define Play_Initial_TimeCode_Timer (5)
#define Play_MPEG1_End_Fudge        (100)
#define Play_Old_MPEG2_End_Fudge    (200)
#define Play_TimeCode_Margin        (275)
#define Play_Sequence_Margin        (200)

/* Local functions - miscellaneous */

static _kernel_oserror * play_return_emulated_response       (session * s, unsigned int response_code);
static _kernel_oserror * play_alter_playback_characteristics (session * s, int playmode);
static bool              play_check_stream_received          (session * s);
#ifdef CLIENT_LOOPING
static _kernel_oserror * play_replay                         (session * s);
#endif

/* Local functions - general command sending assistance */

static _kernel_oserror * play_preamble                 (session * s);

/* Local functions - stuff called from the state machine as callback */
/* functions during execution of a command chain                     */

static _kernel_oserror * play_setparam_done            (session * s);
static _kernel_oserror * play_send_set_playmode        (session * s);
static _kernel_oserror * play_set_playmode_done        (session * s);
static _kernel_oserror * play_send_play                (session * s);
static _kernel_oserror * play_send_state_command       (session * s, play_state state);

/* Local functions - stuff used to build a set of command headers */
/* ready for sending out                                          */

static int               play_process_speed            (const char * scale);
static int               play_determine_playmode       (const char * scale);
static _kernel_oserror * play_build_initial_command    (session * s);
static _kernel_oserror * play_build_pause              (session * s);
static _kernel_oserror * play_build_set_playmode       (session * s);
static _kernel_oserror * play_build_play               (session * s);
static _kernel_oserror * play_build_play_or_pause      (session * s, bool force_pause);
static bool              play_filter_range             (session * s, const char * range, int * start_pos, int * end_pos);
static void              play_reconstruct_range_header (session * s, char * temp);

/* Local functions - floating point code used within */

static int               play_strtofi                    (const char *str, const char **endptr, int factor);
static unsigned int      play_get_trick_stream_npt       (asset_data * asset, unsigned int npt);
static unsigned int      play_get_mpeg1_trick_stream_npt (asset_data * asset, unsigned int frame);
static unsigned int      play_get_frame_number           (session * s, int npt);
#ifdef CLIENT_LOOPING
static void              play_copy_frame_info            (session * dst, session * src);
#endif


/**************************************************************/
/* play_play()                                                */
/*                                                            */
/* Implement RTSPMB_Play. See the Video Control               */
/* specification, 2501,817/FS, for more.                      */
/*                                                            */
/* This function always sends at least one command, which     */
/* is either PAUSE for zero speed or for a trick play mode    */
/* transition, or SET_PLAYMODE or PLAY if playback is         */
/* starting for the first time. A command chain is set up     */
/* which is dealt with by the state machine calling back into */
/* play_send_play or play_send_set_playmode.                  */
/**************************************************************/

_kernel_oserror * play_play(_kernel_swi_regs * r)
{
  session * s = session_find_by_id(r->r[1]);
  int       speed_type;
  bool      invalid;

  dprintf(("Entry_0", "play_play: Called\n"));
  dprintf(("Entry_1", " r0=%x\n",r->r[0]));
  dprintf(("Entry_1", " r1=%x\n",r->r[1]));
  dprintf(("Entry_1", " r2='%s'\n",r->r[2] ? (char *)r->r[2] : "NULL"));
  dprintf(("Entry_1", " r3='%s'\n",r->r[3] ? (char *)r->r[3] : "NULL"));
  #ifdef TRACE
  if ((r->r[0] & VC_Play_R4ThroughR7AreValid) != 0)
  {
    dprintf(("Entry_1", " r4='%s'\n",r->r[4] ? (char *)r->r[4] : "NULL"));
    dprintf(("Entry_1", " r5=%x\n",r->r[5]));
    dprintf(("Entry_1", " r6=%x\n",r->r[6]));
    dprintf(("Entry_1", " r7=%x\n",r->r[7]));
  }
  #endif

  /* Do the basic checks to see that everything is OK. */

  RetError(play_preamble(s));

  /* Ensure everything is reset for a new command. */

  session_reset_session(s);

  /* Copy R2 and R3 away */

  free(s->range_record);
  s->range_record = Strdup(r->r[2] == 0 ? "" : (char *) r->r[2]);

  free(s->play_record);
  s->play_record = Strdup(r->r[3] == 0 ? "" : (char *) r->r[3]);

  if (s->play_record == NULL || s->range_record == NULL)
  {
    dprintf(("", "play_play: Play or range records NULL -> out of memory\n"));
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  /* Is there a mapping between the request and the server? */

  speed_type = play_process_speed(s->play_record);

  switch (speed_type)
  {
    case MPEGCtrl_MCRS_Trick_SFWD:
    case MPEGCtrl_MCRS_Trick_SRWD:
      /* Can't do slow motion */
      invalid = true;
      break;

    case MPEGCtrl_MCRS_Trick_FFWD:
      /* Can't fast forward if asset doesn't allow this. Also disallow     */
      /* fast-forward for MPEG 1 sequences as a server bug in all versions */
      /* up to and including 6.0.1 means SET_PLAYMODE frame conversions    */
      /* for assets beyond the first one fail to return a result.          */
      invalid = (
                 (s->play_modes & Setup_PlayModes_ForwardFast) == 0 ||
                 s->multicast != 0 ||
                 (s->asset_type == assettype_MPEG1 && s->num_assets > 1)
                );
      break;

    case MPEGCtrl_MCRS_Trick_FRWD:
      /* Can't rewind if asset doesn't allow this. Also disallow rewind */
      /* for MPEG 1 sequences for the reasons mentioned above.          */
      invalid = (
                 (s->play_modes & Setup_PlayModes_FastReverse) == 0 ||
                 s->multicast != 0 ||
                 (s->asset_type == assettype_MPEG1 && s->num_assets > 1)
                );
      break;

    case MPEGCtrl_MCRS_Trick_Freeze:
      /* If 'random reposition' is disabled we also disallow pause for      */
      /* versions of MediaBase earlier than 6. This is because MediaBase 6  */
      /* can remember the pause point for us, but with earlier versions     */
      /* we have to specify the restart point explicity (we normally do     */
      /* this with MediaBase 6 too, since it is more accurate). This check  */
      /* is perhaps a bit paranoid, since older servers still do their best */
      /* to seek to the right point, but if they say you can't reposition,  */
      /* then our policy is not to try.                                     */
      /* We also disallow pause for audio-only assets on MediaBase versions */
      /* earlier than 6 for the same reason, since we currently have no way */
      /* to accurately know the current position for an audio-only asset.   */
      /* Simulated multicast is OK, since there is no pause point.          */
      invalid = (((s->play_modes & Setup_PlayModes_RandomRepositionDisabled) != 0 || s->asset_type == assettype_MPEG1Audio) &&
                 s->server_version < 0x060000 &&
                 s->multicast == 0);
      break;

    default:
      /* Anything else is OK */
      invalid = false;
      break;
  }

  if (invalid)
    return play_return_emulated_response(s, 501);

  /* Parse the range */

  if (!play_filter_range(s, s->range_record, &s->from, &s->to))
  {
    /* Range not recognised - return a 457 response */

    return play_return_emulated_response(s, 457);
  }

  /* If 'reposition to start' is disabled or 'random reposition' is */
  /* disabled, then the from time must be 0, 'now' or unspecified,  */
  /* otherwise return a 501 response.                               */

  if (
      (s->play_modes & (Setup_PlayModes_RepositionToStartDisabled | Setup_PlayModes_RandomRepositionDisabled)) != 0 &&
      s->from != 0 &&
      s->from != Play_MB_Time_Unspecified &&
      s->from != Play_MB_Time_Now
     )
      return play_return_emulated_response(s, 501);

  /* Furthermore, if 'reposition to start' is disabled and play has started */
  /* then the from time must be 'now' or unspecified, otherwise return a    */
  /* 501 response.                                                          */

  if (
      (s->play_modes & Setup_PlayModes_RepositionToStartDisabled) != 0 &&
      s->started != 0 &&
      s->from != Play_MB_Time_Unspecified &&
      s->from != Play_MB_Time_Now
     )
    return play_return_emulated_response(s, 501);

  /* If this is a pause request and we are already paused, do nothing and   */
  /* return a fake OK response. The server would return an error, but we    */
  /* hide this to make life easier for the client and to be more consistent */
  /* (since play when already playing just returns OK). It also avoids      */
  /* unexpected problems in odd cases where a switch between normal and     */
  /* trick play failed leaving the stream paused, but the client thinks it  */
  /* is still playing.                                                      */

  if (
      s->started != 0 &&
      s->playmode == Play_MB_Trick_Freeze &&
      speed_type == MPEGCtrl_MCRS_Trick_Freeze
     )
    return play_return_emulated_response(s, 200);

  /* If this is a play request with no specified range, or a range from */
  /* 'now', without a change of playmode, and this is a MediaBase 5 or  */
  /* earlier server, then fake an OK response. The server should just   */
  /* return OK without doing anything in this case (according to RTSP), */
  /* and MediaBase 6 does this, but older versions can't cope. We could */
  /* fake it for version 6 too, but we may as well do it properly when  */
  /* we can.                                                            */

  if (
      s->server_version < 0x060000 &&
      s->started != 0 &&
      (s->from == Play_MB_Time_Unspecified || s->from == Play_MB_Time_Now) &&
      s->playmode == play_determine_playmode(s->play_record)
     )
    return play_return_emulated_response(s, 200);

  /* Is the asset to play online? */

  if (s->online == 0)
  {
    /* The asset is offline. This means the last thing the setup phase did */
    /* was to send a SET_PARAMETER command to the server to kick off the   */
    /* transfer process. We now need to keep calling SET_PARAMETER until   */
    /* the asset comes on line (or there is an error).                     */

    RetError(setup_build_set_parameter(s));

    s->next_command_cb = play_setparam_done;
  }
  else
  {
    /* Build the initial command */
  
    RetError(play_build_initial_command(s));
  }

  /* Everything is built and ready to go. Now check to make sure that no  */
  /* background command is in progress. If it is we have to delay sending */
  /* the new command until the background command has completed.          */

  /* Remove the GET_PARAMETER pinging callout */

  if (s->gp_set != 0)
  {
    s->gp_set = 0;
    untimeout(getparam_proceed_on_callout, s);
  }

  #ifdef CLIENT_LOOPING
  /* Remove the looping callout */

  /* The implications of a replay callout occuring at this stage need */
  /* to be thought through a little more.                             */
  if (s->loop_ready != 0)
  {
    s->loop_ready = 0;
    untimeout(play_replay_on_callout, s);
  }
  #endif

  /* Is a background command in progress? */

  if (s->child != NULL)
  {
    dprintf(("", "play_play: Having to wait for background command\n"));

    /* We have to wait */

    s->play_wait = 1;
    timeout(play_retry_delayed_on_callout, s, Session_State_Retry);

    dprintf(("", "play_play: Play retry timer is set, exiting play_play\n"));

    return NULL;
  }

  /* Send the command */

  dprintf(("", "play_play: Successful; exitting through play_send\n"));

  return status_send(s);
}

/**************************************************************/
/* play_build_initial_command()                               */
/*                                                            */
/* For a given session, decide what the first command to be   */
/* sent to the server to satisfy the play request is, build   */
/* that command in the session and set up the command chain   */
/* for the next command.                                      */
/*                                                            */
/* Parameters: Pointer to the session struct.                 */
/*                                                            */
/* Returns:    An error if something went wrong.              */
/**************************************************************/

static _kernel_oserror * play_build_initial_command(session * s)
{
  _kernel_oserror * e = NULL;
  int               new_playmode;

  /* Work out the command order required. Possibilities are:                */
  /* 1) PAUSE                                                               */
  /*   To pause on any version of MediaBase.                                */
  /* 2) PLAY                                                                */
  /*   To start playing or resume from pause on MediaBase 6 with MPEG2.     */
  /* 3) SET_PLAYMODE; PLAY                                                  */
  /*   To start playing MPEG1 on MediaBase 6; to start playing or resume    */
  /*   from pause on MediaBase 5 or earlier.                                */
  /* 4) PAUSE; PLAY                                                         */
  /*   To change play mode on MediaBase 6 with MPEG2.                       */
  /* 5) PAUSE; SET_PLAYMODE; PLAY                                           */
  /*   To change play mode (or jump to a new position in the same mode) on  */
  /*   MediaBase 5 or earlier, or with MPEG1 on MediaBase 6.                */

  new_playmode = play_determine_playmode(s->play_record);

  if (new_playmode == Play_MB_Trick_Freeze)
  {
    /* Going to pause mode - issue PAUSE */

    dprintf(("", "play_build_initial_command: Building PAUSE to pause\n"));

    s->next_command_cb = NULL;

    e = play_build_pause(s);
  }
  else if (
            s->started != 0 &&
            s->playmode != Play_MB_Trick_Freeze &&
            (new_playmode != s->playmode || s->server_version < 0x060000)
          )
  {
    /* Changing play mode (or jumping to a new position in the same mode     */
    /* with MediaBase 5 or earlier) - issue PAUSE (then maybe SET_PLAYMODE), */
    /* then PLAY.                                                            */

    dprintf(("", "play_build_initial_command: Building PAUSE to change play mode\n"));

    /* When changing play mode, treat no 'from' as from 'now' */

    if (s->from == Play_MB_Time_Unspecified)
      s->from = Play_MB_Time_Now;

    if (s->server_version >= 0x060000 && s->asset_type != assettype_MPEG1)
      s->next_command_cb = play_send_play;
    else
      s->next_command_cb = play_send_set_playmode;

    e = play_build_pause(s);
  }
  else
  {
    /* Starting, resuming from pause, or jumping within same play mode */
    /* (for server version 6 or later - earlier versions do not allow  */
    /* this without doing a PAUSE first.)                              */
    /* Issue SET_PLAYMODE if required, then PLAY.                      */

    if (s->started == 0)
    {
      if (s->from == Play_MB_Time_Unspecified || s->from == Play_MB_Time_Now)
      {
        /* If play has not started, treat no 'from' or from 'now' as from */
        /* the start (for forward play) or end (for reverse play)         */

        if (new_playmode == Play_MB_Trick_FRWD) s->from = s->duration;
        else                                    s->from = 0;
      }
    }
    else if (s->playmode == Play_MB_Trick_Freeze)
    {
      /* When resuming from pause, treat no 'from' as from 'now' */

      if (s->from == Play_MB_Time_Unspecified)
        s->from = Play_MB_Time_Now;
    }
    else
    {
      /* If playing in same mode as before, treat from 'now' as no 'from'  */

      if (s->from == Play_MB_Time_Now)
        s->from = Play_MB_Time_Unspecified;
    }

    if (
        s->multicast != 0 ||
        (s->server_version >= 0x060000 && s->asset_type != assettype_MPEG1)
       )
    {
      #ifdef TRACE
        if (s->multicast != 0) dprintf(("", "play_build_initial_command: Building PLAY for simulated multicast start\n"));
        else                   dprintf(("", "play_build_initial_command: Building PLAY for MediaBase 6 MPEG2\n"));
      #endif

      s->next_command_cb = NULL;
  
      e = play_build_play(s);
    }
    else
    {
      dprintf(("", "play_build_initial_command: Building SET_PLAYMODE\n"));
  
      s->next_command_cb = play_set_playmode_done;
  
      e = play_build_set_playmode(s);
    }
  }

  return e;
}

/**************************************************************/
/* play_preamble()                                            */
/*                                                            */
/* For a given session, check the pointer is not NULL, that   */
/* no command is currently in progress and that there is a    */
/* server session.                                            */
/*                                                            */
/* This is normally the first thing done in a function that   */
/* needs to issue a play-related command to a server.         */
/*                                                            */
/* Parameters: Pointer to the session struct (may be NULL).   */
/*                                                            */
/* Returns:    An error if there is some problem with using   */
/*             the session for a new PLAY command, else NULL. */
/**************************************************************/

static _kernel_oserror * play_preamble(session * s)
{
  dprintf(("", "play_preamble: Called for &%08X\n", (int) s));

  if (s == NULL)
  {
    dprintf(("", "play_preamble: ID not found\n"));

    return make_error(rtspmb_ERROR_CLIENT_ID_NOT_FOUND, 0);
  }

  if (
       s->state == protostate_DNS       ||
       s->state == protostate_CONNECTED ||
       s->state == protostate_SENDING   ||
       s->state == protostate_RECEIVING ||
       s->state == protostate_PUMPING   ||
       s->play_wait == 1
     )
  {
    dprintf(("", "play_preamble: In progress\n"));

    return make_error(rtspmb_ERROR_IN_PROGRESS, 0);
  }

  if (s->server_session == NULL)
  {
    dprintf(("", "play_preamble: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Be warned - don't do anything destructive to background */
  /* commands here (e.g. don't call session_reset_session)   */

  dprintf(("", "play_preamble: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_return_emulated_response()                            */
/*                                                            */
/* Return an emulated response to a play command.             */
/*                                                            */
/* Parameters: Pointer to the session structure.              */
/*                                                            */
/* Returns:    NULL or pointer to error.                      */
/**************************************************************/

static _kernel_oserror * play_return_emulated_response(session * s, unsigned int response_code)
{
  rtsp_header * r;

  switch (response_code)
  {
    case 200: r = response_build(s->headers, Headers_Supported_Prefix_200); break;
    case 457: r = response_build(s->headers, Headers_Supported_Prefix_457); break;
    case 501: r = response_build(s->headers, Headers_Supported_Prefix_501); break;
    default:  return make_error(rtspmb_ERROR_UNKNOWN_COMMAND_STATE, 0);
  }
  
  if (r == NULL) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);

  dprintf(("","play_return_emulated_response: Returning emulated response %d\n", response_code));
  
  headers_free_headers(&s->headers);
  
  s->next_command_cb = NULL;
  s->headers         = r;
  s->state           = protostate_COMPLETED;
  s->response_code   = response_code;
  s->reported_state  = VC_Status_ConnectionEstablished |
                       VC_Status_NewStatus;
  
  s->data_len = headers_construct_specific_header_buffer(s->headers,
                                                         &s->data,
                                                         0,
                                                         1);
  
  if (s->data_len != 0) s->reported_state |= VC_Status_MoreInformationAvailable;
  
  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }
  
  return NULL;
}

/**************************************************************/
/* play_process_speed()                                       */
/*                                                            */
/* Process a string which should contain a number which may   */
/* be negative or a decimal fraction, e.g. "-0.4", "55",      */
/* ".4" but not (say) "1/3" or "    65".                      */
/*                                                            */
/* Parameters: Pointer to the string. If NULL, "1" is used.   */
/*                                                            */
/* Returns:    An int containing an indication of play mode   */
/*             within the string; see MPEGCtrl.h.             */
/**************************************************************/

static int play_process_speed(const char * scale)
{
  modulefp_buf buf;
  int          n;
  const char * endp;

  if (scale == NULL || *scale == '\0')
    return MPEGCtrl_MCRS_Trick_Play;

  modulefp_enable(&buf);
  n = play_strtofi(scale, &endp, 100);
  modulefp_disable(&buf);

  if (n <= -100)     return MPEGCtrl_MCRS_Trick_FRWD; /* scale <= -1.0 */
  if (n < 0)         return MPEGCtrl_MCRS_Trick_SRWD; /* -1.0 < scale < 0 */
  if (n > 100)       return MPEGCtrl_MCRS_Trick_FFWD; /* scale >= 1.0 */
  if (n == 100)      return MPEGCtrl_MCRS_Trick_Play; /* scale == 1.0 */
  if (n > 0)         return MPEGCtrl_MCRS_Trick_SFWD; /* 0 < scale < 1.0 */
  if (endp == scale) return MPEGCtrl_MCRS_Trick_Play; /* Invalid string */

  return MPEGCtrl_MCRS_Trick_Freeze;                  /* scale == 0 */
}

/**************************************************************/
/* play_determine_playmode()                                  */
/*                                                            */
/* Determine the MediaBase play mode from a playback rate     */
/* string.                                                    */
/*                                                            */
/* Parameters: Pointer to the string. If NULL, "1" is used.   */
/*                                                            */
/* Returns:    An int containing an indication of play mode   */
/*             within the string; see play.h.                 */
/**************************************************************/

static int play_determine_playmode(const char * scale)
{
  int mode;
  
  /* Rather than modify play_process_speed to spit out MediaBase stuff directly, */
  /* the full accuracy of play methods is kept, in case future MediaBase servers */
  /* support features missing at the time of writing (e.g. SFWD play).           */
  
  switch (play_process_speed(scale))
  {
    case MPEGCtrl_MCRS_Trick_FFWD:   mode = Play_MB_Trick_FFWD;   break;
    case MPEGCtrl_MCRS_Trick_SFWD:   mode = Play_MB_Trick_Play;   break; /* No SFWD on MediaBase */
    case MPEGCtrl_MCRS_Trick_Freeze: mode = Play_MB_Trick_Freeze; break;
    case MPEGCtrl_MCRS_Trick_FRWD:   mode = Play_MB_Trick_FRWD;   break;
    case MPEGCtrl_MCRS_Trick_SRWD:   mode = Play_MB_Trick_FRWD;   break; /* No SRWD on MediaBase */
  
    default:
    case MPEGCtrl_MCRS_Trick_Play:   mode = Play_MB_Trick_Play;   break;
  }
  
  return mode;
}

/**************************************************************/
/* play_retry_delayed_on_callout()                            */
/*                                                            */
/* Retry a delayed foreground command that was waiting for a  */
/* background command to complete.                            */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_retry_delayed_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("", "play_retry_delayed_on_callout: Called, dying flag is %d\n", s->dying));

  if (s->dying != 0) return;

  if (s->play_wait != 0)
  {
    /* Is there an in-transit foreground or background command already? */

    if (s->state != protostate_INITIAL)
    {
      /* Foreground command in progress! Should never happen... Abandon */
      /* this wait state.                                               */

      dprintf(("", "play_retry_delayed_on_callout: Foreground command already running!\n"));

      s->play_wait = 0;
    }
    else if (s->child != NULL)
    {
      /* Background command - wait for it to finish */

      dprintf(("", "play_retry_delayed_on_callout: Background command still running...\n"));

      timeout(play_retry_delayed_on_callout, s, Session_State_Retry);
    }
    else
    {
      _kernel_oserror * e;
      
      /* Clear to send the command */

      s->play_wait = 0;

      dprintf(("", "play_retry_delayed_on_callout: Clear to try again, calling status_send().\n"));

      e = status_send(s);

      if (e != NULL)
      {
        dprintf(("", "play_retry_delayed_on_callout: Error &%08X, '%s'\n", e->errnum, e->errmess));

        status_record_error(s, e);
      }
    }
  }
}

#ifdef CLIENT_LOOPING

/* !!! IMPORTANT NOTE ABOUT CLIENT LOOPING !!! */

/* Client looping is compiled out at the moment because it is not working   */
/* correctly. If you want to reinstate it, you will have to address the     */
/* points listed below. The decision to leave this functionality out of     */
/* this version was based on the fact that fully supporting it adds a       */
/* relatively large amount of complication for relatively little gain.      */
/* After all, a client can easily do looping explicitly, without the        */
/* protocol module having to do lots of extra work on its behalf.           */
/*                                                                          */
/* The following things need to be done to support client looping:          */
/*                                                                          */
/* 1) status_proceed_completed() needs to call play_mode_changed() when the */
/* background PLAY completes. It won't currently since the s->destruct flag */
/* is set. This is necessary to make sure the stream is reset and state     */
/* updated. play_mode_changed() will update the state and set the timecode  */
/* reading callout on this session. This needs to be done on the parent     */
/* session instead.                                                         */
/*                                                                          */
/* 2) A record needs to be kept of the last explicit range. Currently       */
/* this will replay using the range from the last play call, but this       */
/* may have been 'now-' when switching from a trick play mode to            */
/* normal play. The module will instead need to keep a track of each        */
/* explicit start and end point specified and loop using these times.       */

/**************************************************************/
/* play_replay_on_callout()                                   */
/*                                                            */
/* A CallOut handler (see CallOut.h) which loops video        */
/* playback through play_replay.                              */
/*                                                            */
/* THIS FUNCTION MUST BE RE-ENTRANT.                          */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_replay_on_callout(void * handle)
{
  session * s = (session *) handle;

  if (s->dying != 0) return;

  if (s->loop_ready != 0)
  {
    /* Is there an in-transit foreground or background command already? */

    if (s->state != protostate_INITIAL)
    {
      /* Foreground command - abandon this background operation */

      s->loop_ready = 0;
      return;
    }
    else if (s->child != NULL)
    {
      /* Background command - wait for it to finish */

      timeout(play_replay_on_callout, s, Session_State_Retry);
      return;
    }
    else
    {
      /* Clear to send the command */

      s->loop_ready = 0;
      play_replay(s);
    }
  }
}

/**************************************************************/
/* play_replay()                                              */
/*                                                            */
/* Issue an "in-the-background" PLAY command to loop video    */
/* playback at the client end.                                */
/*                                                            */
/* Parameters: Pointer to a session struct for the video to   */
/*             loop.                                          */
/**************************************************************/

_kernel_oserror * play_replay(session * s)
{
  _kernel_oserror * e;
  session         * new_s;

  dprintf(("", "play_replay: Called for %p\n", s));

  if (s->server_session == NULL)
  {
    dprintf(("", "play_replay: No server session\n"));

    return make_error(rtspmb_ERROR_NO_SERVER_SESSION, 0);
  }

  /* Cancel any GET_PARAMETER manually - it won't be done automatically */
  /* as we're not resetting this session, we're spawning a new one      */

  if (s->gp_set != 0)
  {
    s->gp_set = 0;
    untimeout(getparam_proceed_on_callout, s);
  }

  /* This should never happen if called via. play_replay_on_callout... */

  if (s->child) session_free_item(s->child);

  /* Create a new session */

  e = session_new_session(&new_s);

  if (e)
  {
    dprintf(("", "play_replay: session_new_session error '%s'\n", e->errmess));
    return e;
  }

  /* Can't just block copy the structure; have to be careful to take new */
  /* copies of vital strings, IDs, and so-on.                            */

  if (new_s != NULL)
  {
    new_s->id       = ++id_counter; /* See Global.h */
    new_s->vcid     = s->vcid;
    new_s->destruct = 1;

    new_s->parent   = s;
    s->child        = new_s;

    new_s->server_session = Strdup(s->server_session ? s->server_session : "");
    new_s->play_record    = Strdup(s->play_record    ? s->play_record    : "");
    new_s->range_record   = Strdup(s->range_record   ? s->range_record   : "");

    if (s->url->full != NULL)
    {
      (void) urlutils_return_description(s->url->full, &new_s->url);
    }
  }

  if (
       new_s                 == NULL ||
       new_s->server_session == NULL ||
       new_s->play_record    == NULL ||
       new_s->range_record   == NULL ||
       (
         s->url->full != NULL &&
         new_s->url   == NULL
       )
     )
  {
    dprintf(("", "play_replay: Out of memory for new_s or copied strings\n"));

    if (new_s != NULL) session_free_item(new_s);
    return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  }

  new_s->server_version  = s->server_version;
  new_s->server_timeout  = s->server_timeout;
  new_s->mpegid          = s->mpegid;
  new_s->playmode        = s->playmode;
  new_s->multicast       = s->multicast;

  new_s->approx_fps      = s->approx_fps;
  new_s->asset_type      = s->asset_type;
  new_s->duration        = s->duration;
  new_s->start_time      = s->start_time;
  new_s->end_time        = s->end_time;

  {
    modulefp_buf buf;

    modulefp_enable(&buf);
    play_copy_frame_info(new_s, s);
    modulefp_disable(&buf);
  }

  if ((new_s->server_version >= 0x060000) && (new_s->asset_type != assettype_MPEG1))
  {
    new_s->next_command_cb = NULL;
    e = play_build_play(new_s);
  }
  else
  {
    new_s->next_command_cb = play_send_set_playmode;
    e = play_build_pause(new_s);
  }


  if (e != NULL)
  {
    dprintf(("", "play_replay: Error '%s' from play_build_pause\n", e->errmess));

    session_free_item(new_s);
    return e;
  }

  /* Open a connection to send the command down */

  if (s->sd == -1)
  {
    int port;

    if (s->url->port && *s->url->port) port = atoi(s->url->port);
    else                               port = RTSPMB_DefaultPort;

    s->sd = opensock(s->url->host,
                     port,
                     NULL,
                     &new_s->state,
                     -1);

    if (s->state == protostate_ERROR) s->err_no = -s->sd;
  }
  else new_s->state = protostate_CONNECTED;

  new_s->sd   = s->sd;
  new_s->last = utils_read_time();

  dprintf(("", "play_replay: Socket descriptor %d, state %d\n", new_s->sd, new_s->state));

  /* Set the state machine going to see errors and DNS stuff; */
  /* in addition, rerun it for the parent session to get      */
  /* another GET_PARAMETER scheduled.                         */

  new_s->callout_set = 1;
  timeout(status_proceed_on_callout, new_s, Session_State_Timer);

  if (s->callout_set == 0)
  {
    s->callout_set = 1;
    timeout(status_proceed_on_callout, s, Session_State_Timer);
  }

  /* Finished */

  dprintf(("", "play_replay: Successful\n"));

  return NULL;
}

#endif

/**************************************************************/
/* play_setparam_done()                                       */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is called when a SET_PARAMETER command sent by        */
/* play_play completes.                                       */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             SET_PARAMETER command.                         */
/**************************************************************/

static _kernel_oserror * play_setparam_done(session * s)
{
  _kernel_oserror * e = NULL;
  int               etc = 0;

  dprintf(("", "play_setparam_done: Called for &%08X\n", (int) s));

  /* Clear the command chain */

  s->next_command_cb = NULL;

  /* If the SET_PARAMETER response was an error, give up now and return */
  /* this status to the client.                                         */

  if (s->response_code != 200)
    return NULL;

  /* Now look for the estimated time to completion value in the response.   */
  /* If this is missing or invalid, it is treated as 0 - it might be better */
  /* to return some sort of error really, but for now we assume the server  */
  /* works properly.                                                        */

  if (s->data_len > 0)
  {
    char * ptr;

    ptr = strstr(s->data, Headers_Content_ETC);
    if (ptr != NULL)
    {
      ptr += sizeof(Headers_Content_ETC) - 1;
      etc = atoi(ptr);
    }
  }

  dprintf(("", "play_setparam_done: ETC is %ds\n", etc));

  if (etc != 0)
  {
    int delay;

    /* Asset has still not been transferred. Send SET_PARAMETER again after */
    /* a short delay.                                                       */

    delay = etc * 100;
    if (delay > Play_SetParam_Timer)
      delay = Play_SetParam_Timer; 

    s->sp_set = 1;
    timeout(play_setparam_on_callout, s, delay);

    /* The state machine has no more work to do for now. */

    s->state = protostate_INITIAL;

    /* Tell the client about the latest response as an asynchronous message. */
    /* This will allow them to see the latest ETC.                           */

    e = _swix(VideoControl_ProtocolNotify,
              _INR(0,2),

              0,
              s->id,
              VideoControlProtocolNotifyMessageReceived);
  }
  else
  {
    /* Asset has now been transferred, so we can send the play command. */

    dprintf(("", "play_setparam_done: Asset transfer completed, issue command\n"));

    s->online = 1;

    e = play_send_state_command(s, play_state_initial);
  }

  return e;
}

/**************************************************************/
/* play_setparam_on_callout()                                 */
/*                                                            */
/* A CallOut handler (see CallOut.h) which sends the server a */
/* SET_PARAMETER command.                                     */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_setparam_on_callout(void * handle)
{
  session         * s = (session *) handle;
  _kernel_oserror * e;

  dprintf(("Callout_0", "play_setparam_on_callout: Called for %p\n", s));

  if (s->dying != 0 || s->sp_set == 0) return;

  s->sp_set = 0;

  e = play_send_state_command(s, play_state_setparam);

  if (e != NULL)
  {
    dprintf(("", "play_setparam_on_callout: Error &%08X, '%s'\n", e->errnum, e->errmess));

    status_record_error(s, e);
  }
}

/**************************************************************/
/* play_send_set_playmode()                                   */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the second item in a chain of commands for the     */
/* server (the first must be PAUSE). The next command         */
/* callback is set to play_send_play. A command chain which   */
/* involves calling this function is always started inside    */
/* play_play.                                                 */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful PAUSE command.                      */
/**************************************************************/

static _kernel_oserror * play_send_set_playmode(session * s)
{
  dprintf(("", "play_send_set_playmode: Called for &%08X\n", (int) s));

  RetError(play_send_state_command(s, play_state_set_playmode));

  dprintf(("", "play_send_set_playmode: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_set_playmode_done()                                   */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is called when a SET_PLAYMODE command completes.      */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             SET_PLAYMODE command.                          */
/**************************************************************/

static _kernel_oserror * play_set_playmode_done(session * s)
{
  /* Special processing to get seek NPT time for trick play MPEG1 */

  if (
      s->asset_type == assettype_MPEG1 &&
      (s->next_playmode == Play_MB_Trick_FFWD || s->next_playmode == Play_MB_Trick_FRWD)
     )
  {
    /* Look for to frame number in SET_PLAYMODE response */

    s->seek_from = -1;

    if (s->data_len > 0)
    {
      char * ptr;

      ptr = strstr(s->data, Headers_Content_ToFrame);
      if (ptr != NULL)
      {
        unsigned int frame;

        ptr += sizeof(Headers_Content_ToFrame) - 1;
        frame = (unsigned int) strtoul(ptr, NULL, 10);

        if (frame != ULONG_MAX)
        {
          modulefp_buf buf;

          dprintf(("", "play_set_playmode_done: from=%d, frame=%u, ", s->seek_from, frame));
          modulefp_enable(&buf);
          s->seek_from = play_get_mpeg1_trick_stream_npt(&s->assets[s->cur_asset], frame);
          modulefp_disable(&buf);
          dprintf(("", "seek npt=%d\n", s->seek_from));
        }
      }
    }

    if (s->seek_from < 0)
    {
      /* If the server failed to give us a converted frame number, give up now */
      /* by returning an emulated Invalid Range error.                         */
  
      return play_return_emulated_response(s, 457);
    }
  }

  /* Continue by sending the PLAY command */
  
  return play_send_play(s);
}

/**************************************************************/
/* play_send_play()                                           */
/*                                                            */
/* Called only ever as a callback_fn_ptr (see Session.h).     */
/*                                                            */
/* This is the last item in a chain of commands for the       */
/* server and sends the actual PLAY command off. No further   */
/* callback function is set.                                  */
/*                                                            */
/* Parameters: Pointer to a session that just completed a     */
/*             successful SET_PLAYMODE command.               */
/**************************************************************/

static _kernel_oserror * play_send_play(session * s)
{
  dprintf(("", "play_send_play: Called for &%08X\n", (int) s));

  RetError(play_send_state_command(s, play_state_play));

  dprintf(("", "play_send_play: Successful\n"));

  return NULL;
}

/**************************************************************/
/* play_send_state_command()                                  */
/*                                                            */
/* Deal with the mechanics of building a relevant command and */
/* setting any required next command callback, for a chain of */
/* play-related commands for the server. This is only used    */
/* for second and subsequent commands - play_play deals with  */
/* the extra complexity of the initial command (not least,    */
/* working out exactly what command to send).                 */
/*                                                            */
/* Parameters: Pointer to a session structure;                */
/*                                                            */
/*             A play_state (see top of file) indicating the  */
/*             command to send, which influences what the     */
/*             next command callback is set to.               */
/**************************************************************/

static _kernel_oserror * play_send_state_command(session * s, play_state state)
{
  dprintf(("", "play_send_state_command: Called\n"));

  RetError(play_preamble(s));

  /* Ensure everything is reset for a new command */

  session_reset_session(s);

  /* Build the command */

  switch(state)
  {
    case play_state_setparam:
    {
      dprintf(("", "play_send_state_command: SET_PARAMETER\n"));

      /* Build the SET_PARAMETER command */

      RetError(setup_build_set_parameter(s));
      s->next_command_cb = play_setparam_done;
    }
    break;

    case play_state_initial:
    {
      dprintf(("", "play_send_state_command: Initial\n"));

      /* Build the initial command */

      RetError(play_build_initial_command(s));
    }
    break;

    case play_state_set_playmode:
    {
      dprintf(("", "play_send_state_command: SET_PLAYMODE\n"));

      /* Build the SET_PLAYMODE command */

      RetError(play_build_set_playmode(s));
      s->next_command_cb = play_set_playmode_done;
    }
    break;

    case play_state_play:
    {
      dprintf(("", "play_send_state_command: PLAY/PAUSE\n"));

      /* Build the PLAY or PAUSE command (should always be PLAY in practice) */

      RetError(play_build_play_or_pause(s, 0));
      s->next_command_cb = NULL; /* session_reset_session should do that, but just in case... */
    }
    break;

    default:
    {
      dprintf(("", "play_send_state_command: Unknown command state!\n"));

      return make_error(rtspmb_ERROR_UNKNOWN_COMMAND_STATE, 0);
    }
    break;
  }

  /* Send the command */

  return status_send(s);
}

/**************************************************************/
/* play_build_pause()                                         */
/*                                                            */
/* Build a forced PAUSE command in a session, ignoring the    */
/* play_record details of required speed. This is intended    */
/* for use in trick play mode transitions where three         */
/* commands (PAUSE, SET_PLAYMODE then PLAY) must be sent.     */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_pause(session * s)
{
  return play_build_play_or_pause(s, true);
}

/**************************************************************/
/* play_build_set_playmode()                                  */
/*                                                            */
/* Build a SET_PLAYMODE command inside the given session      */
/* based on the play_record and URL details inside it.        */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Assumes:    The play_record field does not indicate zero   */
/*             speed (pause).                                 */
/**************************************************************/

static _kernel_oserror * play_build_set_playmode(session * s)
{
  char content_length[3];
  bool fail = false;

  /* Start adding headers */

  if (s->play_record == NULL) fail = true;
  else
  {
    bool  convert_frame;
    int   len;

    s->next_playmode = play_determine_playmode(s->play_record);
    convert_frame = s->asset_type == assettype_MPEG1 &&
                    (s->next_playmode == Play_MB_Trick_FFWD || s->next_playmode == Play_MB_Trick_FRWD);

    /* session_reset_session should have cleared s->data, but make sure */
    if (s->data != NULL)
      free(s->data);

    len = sizeof(Headers_Content_PlayMode) - 2; /* The extra -1 is there as '%d' will end up as a single digit number */
    if (convert_frame)
      len += sizeof(Headers_Content_Frame) + 7; /* The +7 allows for the %u to convert to the longest possible number */

    s->data = malloc(len + 1);

    if (s->data != NULL)
    {

      len = sprintf(s->data,
                    Headers_Content_PlayMode,
                    s->next_playmode);

      if (convert_frame)
      {
        modulefp_buf buf;
        unsigned int frame;
        int          i, end_npt, time_to_end;

        /* Convert from time of 'now' to current NPT. The cached value will be */
        /* the correct one, since this was updated when the transitional PAUSE */
        /* succeeded.                                                          */
    
        if (s->from == Play_MB_Time_Now)
          s->from = s->cached_npt;

        /* Fudge factor. Things seem to go wrong if we ask for a time too  */
        /* close to the end of the asset, so don't go closer than 1s or so */
        /* before the end.                                                 */

        /* Find the end time of the current asset */
        for (i = 0, end_npt = 0; i <= s->cur_asset; i++)
          end_npt += s->assets[i].duration;
    
        /* How close are we to the end? */
        time_to_end = end_npt - s->from;

        if (time_to_end < Play_MPEG1_End_Fudge)
        {
          s->from -= Play_MPEG1_End_Fudge - time_to_end;

          dprintf(("", "play_build_set_playmode: Seek time moved back by %dcs\n", Play_MPEG1_End_Fudge - time_to_end));
        }
  
        modulefp_enable(&buf);
        frame = play_get_frame_number(s, s->from);
        modulefp_disable(&buf);

        len += sprintf(s->data + len,
                       Headers_Content_Frame,
                       frame);
      }

      s->data_len = len;
      sprintf(content_length, "%d", s->data_len);
    }
  }

  if (s->data == NULL) fail = true;

  else if (
            headers_add_header(&s->headers,
                               Headers_CommandName_SetPlayMode,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Session header */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_Session,
                               s->server_session)
            == NULL
          )
          fail = true;

  /* Content type for the play mode etc. */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentType,
                               Headers_HeaderValue_ContentType)
            == NULL
          )
          fail = true;

  /* Content length */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_ContentLength,
                               content_length)
            == NULL
          )
          fail = true;

  /* Did anything fail? */

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_build_play()                                          */
/*                                                            */
/* Build a PLAY command inside the given session based on     */
/* the play_record and URL details inside it. If play_record  */
/* shows the speed to be zero, PAUSE is sent instead.         */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/**************************************************************/

static _kernel_oserror * play_build_play(session * s)
{
  return play_build_play_or_pause(s, false);
}

/**************************************************************/
/* play_build_play_or_pause()                                 */
/*                                                            */
/* Service function originally built for play_build_play and  */
/* play_build_pause.                                          */
/*                                                            */
/* Builds a PLAY or PAUSE command inside the given session    */
/* based either on the play_record and URL details inside it, */
/* or just on the URL information if play_record is to be     */
/* ignored (PAUSE commands only).                             */
/*                                                            */
/* Parameters: Pointer to a relevant session structure;       */
/*                                                            */
/*             true to ignore play_record and send PAUSE,     */
/*             false to send PLAY or PAUSE according to the   */
/*             play_record setting.                           */
/**************************************************************/

static _kernel_oserror * play_build_play_or_pause(session * s, bool force_pause)
{
  char * scale;
  bool   play;
  bool   fail   = false;

  /* Determine the new MediaBase playmode */

  if (force_pause)
    s->next_playmode = Play_MB_Trick_Freeze;
  else
    s->next_playmode = play_determine_playmode(s->play_record);

  /* Decide what scale setting to ask MediaBase for */

  if (s->server_version >= 0x060000)
  {
    switch (s->next_playmode)
    {
      case Play_MB_Trick_Play:
        scale = "1";
        break;
      case Play_MB_Trick_FFWD:
      case Play_MB_Trick_FRWD:
        scale = s->play_record;
        break;
      default:
        scale = NULL;
    }
  }
  else
  {
    scale = NULL;
  }

  play = (s->next_playmode != Play_MB_Trick_Freeze);

  if (play)
  {
    /* Convert range times of 'now' to current NPT. The cached value will be */
    /* the correct one, since this was updated when the transitional PAUSE   */
    /* succeeded.                                                            */

    if (s->from == Play_MB_Time_Now)
      s->from = s->cached_npt;
  
    if (s->to == Play_MB_Time_Now)
      s->to = s->cached_npt;

    dprintf(("","play_build_play_or_pause: cached_npt=%d, from=%d\n", s->cached_npt, s->from));
  }

  /* Start adding headers */

  if      (
            headers_add_header(&s->headers,
                               play ? Headers_CommandName_Play : Headers_CommandName_Pause,
                               s->url->full)
            == NULL
          )
          fail = true;

  /* A sequence header */

  else if (headers_add_sequence_header(&s->headers) == NULL) fail = true;

  /* User agent */

  else if (
            headers_add_header(&s->headers,
                               Headers_HeaderName_UserAgent,
                               Headers_HeaderValue_UserAgent)
            == NULL
          )
          fail = true;

  /* Scale header */

  else if (
            scale != NULL &&
            headers_add_header(&s->headers,
                               Headers_HeaderName_Scale,
                               scale)
            == NULL
          )
          fail = true;

  /* No sync marks please */

  else if (
            play &&
            headers_add_header(&s->headers,
                               Headers_HeaderName_SyncMark,
                               (s->server_version < 0x060000) ? Headers_HeaderValue_SyncMark : Headers_HeaderValue_SyncMarkV6)
            == NULL
          )
          fail = true;

  /* Range */

  else if (
            play &&
            s->multicast == 0 &&
            (s->from != Play_MB_Time_Unspecified || s->to != Play_MB_Time_Unspecified) &&
            ((s->play_modes & Setup_PlayModes_RandomRepositionDisabled) == 0 || s->from == 0)
            )
  {
    char new_range[sizeof("npt=0-0") + 48]; /* (+48 ensures we overestimate for up to 4 digits) */

    play_reconstruct_range_header(s, new_range);

    if (
         headers_add_header(&s->headers,
                            Headers_HeaderName_Range,
                            new_range)
         == NULL
       )
       fail = true;
  }

  /* Add the session header */

  if (
       fail == false &&
       headers_add_header(&s->headers,
                          Headers_HeaderName_Session,
                          s->server_session)
       == NULL
     )
     fail = true;

  if (!fail)
  {
    /* Note that a play change is pending. A PLAY without a from time */
    /* does not cause a change - in fact it doesn't do anything, but  */
    /* we still send it to the server anyway, so that the client sees */
    /* the server response.                                           */

    if (!play || s->from != Play_MB_Time_Unspecified)
    {
      s->change_pending = 1;

      /* If video is playing, and the server is putting Good Data Follows */
      /* markers in the stream, tell the MPEG system to get ready for the */
      /* transition.                                                      */

      if (play && s->stream_markers != 0 && s->started != 0)
        play_alter_playback_characteristics(s, s->next_playmode);
    }
  }

  /* Did anything fail? */

  if (fail) return make_error(rtspmb_ERROR_MEMORY_EXHAUSTED, 0);
  else      return NULL;
}

/**************************************************************/
/* play_alter_playback_characteristics()                      */
/*                                                            */
/* Set speed and reset parameters for a play mode change.     */
/*                                                            */
/* Parameters: Pointer to the session structure for the       */
/*             playback stream in question;                   */
/*                                                            */
/*             Play mode to consider (this allows override of */
/*             the play mode recorded in the session).        */
/**************************************************************/

static _kernel_oserror * play_alter_playback_characteristics(session * s, int playmode)
{
  _kernel_oserror * e = NULL;
  unsigned int      flags;

  /* MediaBase 4.0.1 and 5:                                                      */
  /* The MediaBase server is simple. It streams, say, an MPEG 2 transport stream */
  /* normally, but in trick mode just spews elementary video data out. Eek! Our  */
  /* system can't really handle that. The only thing to do is to leave the       */
  /* decode running whilst we talk to the server to try and exhaust any data in  */
  /* buffers, and then do an immediate reset on the PLAY command's OK response,  */
  /* to try and get stream-start style auto detection running to redetermine     */
  /* the stream type.                                                            */
  /*                                                                             */
  /* MediaBase 6 (XMP):                                                          */
  /* The server no longer sends out elementary streams for trick mode, it sends  */
  /* out a transport stream instead, and will usually also give us Good Data     */
  /* Follows and end-of-stream markers too. This depends on the asset type, and  */
  /* the s->stream_markers flag indicates if the asset supports this.            */

  dprintf(("", "play_alter_playback_characteristics called with playmode %d\n", playmode));

  if (s->mpegid != 0)
  {
    if (playmode == Play_MB_Trick_Freeze)
    {
      /* Immediate set speed to 0 */

      e = _swix(MPEGControl_SetSpeed,
                _INR(0,2),
    
                0,
                s->mpegid,
                0);
    }
    else
    {
      if (s->asset_type == assettype_MPEG1Audio)
      {
        /* Audio-only asset */

        flags = MPEGCtrl_MCRS_AudioPresent;
      }
      else if (playmode == Play_MB_Trick_Play)
      {
        /* Normal play - flag video and audio */

        flags = MPEGCtrl_MCRS_VideoPresent |
                MPEGCtrl_MCRS_AudioPresent;
      }
      else
      {
        /* Trick play - flag a trick play stream */

        flags = MPEGCtrl_MCRS_VideoPresent |
                MPEGCtrl_MCRS_NewIsTrickPlay;
      }

      if (s->stream_markers != 0)
      {
        flags |= MPEGCtrl_MCRS_DeferReset;

        s->reset_pending = 1;
      }

      /* Reset */

      e = _swix(MPEGControl_ResetStream,
                _INR(0,2),
    
                flags,
                s->mpegid,
                MPEGCtrl_MCRS_Trick_Play);

      /* Set speed to 1 */

      if (e == NULL)
        e = _swix(MPEGControl_SetSpeed,
                  _INR(0,2),
    
                  0,
                  s->mpegid,
                  1);

      /* Check number of received bytes (used to determine when stream */
      /* starts arriving to calculate crude NPT time for audio assets) */

      if (s->asset_type == assettype_MPEG1Audio)
        play_check_stream_received(s);
    }
  }
  #ifdef USE_AMPLAYER
  else if (s->stream_sd >= 0)
  {
    if (playmode == Play_MB_Trick_Freeze)
    {
      e = amplay_stop(s);
    }
    else if (s->amp_stream == 0)
    {
      e = amplay_prepare(s);
    }
  }
  #endif

  return e;
}

/**************************************************************/
/* play_mode_changed()                                        */
/*                                                            */
/* Note that a play mode change has occurred.                 */
/*                                                            */
/* Parameters: Pointer to the session structure for the       */
/*             playback stream in question;                   */
/*                                                            */
/*             Play mode to consider (this allows override of */
/*             the play mode recorded in the session).        */
/**************************************************************/

_kernel_oserror * play_mode_changed(session * s, int playmode)
{
  dprintf(("", "play_mode_changed called with playmode %d\n", playmode));

  /* If video is playing, and we don't have Good Data Follows markers   */
  /* in the stream, or if the change was to pause, tell the MPEG system */
  /* to do the change now.                                              */
  /* If video is not yet playing, but we are starting in a trick mode   */
  /* we also need to tell the MPEG system, since Video Control will not */
  /* open the stream with the right flags.                              */

  if (
      (s->started == 0 && (playmode == Play_MB_Trick_FFWD || playmode == Play_MB_Trick_FRWD)) ||
      (s->started != 0 && (s->stream_markers == 0 || playmode == Play_MB_Trick_Freeze))
     )
    play_alter_playback_characteristics(s, playmode);

  if (playmode == Play_MB_Trick_Freeze)
  {
    /* When entering pause mode, stop reading the time code regularly. */

    if (s->read_tc_set != 0)
    {
      s->read_tc_set = 0;
      untimeout(play_read_timecode_on_callout, s);
    }

    /* Update the cached NPT from the current NPT. */

    play_read_current_npt(s, true);
  }
  else
  {
    rtsp_header * h;

    /* Remember what the new scale setting is. The server should have told    */
    /* us in its response. If it didn't, use fixed values depending on the    */
    /* play mode. Note that we only cope with integer scales currently.       */
    /* At the time of writing, MediaBase only supports scales of -6, 1 and 6. */

    h = headers_find_header(s->headers,
                            Headers_HeaderName_Scale);
  
    if (h != NULL) s->scale = atoi(h->value);
    else           s->scale = 0;
  
    if (s->scale == 0)
    {
      switch(playmode)
      {
        case Play_MB_Trick_Play:  s->scale =  1; break;
        case Play_MB_Trick_FFWD:  s->scale =  6; break;
        case Play_MB_Trick_FRWD:  s->scale = -6; break;
      }
    }

    if (s->server_version >= 0x060000 && s->asset_type != assettype_MPEG1)
    {
      /* In MPEG2 trick streams for MediaBase 6, the time codes need to */
      /* be scaled by the current scale amount.                         */

      s->tc_scale = s->scale;
    }
    else
    {
      /* For older versions of MediaBase, the time codes do not need to */
      /* be scaled.                                                     */

      s->tc_scale = 1;
    }
  
    dprintf(("", "Scale read as %d\n", s->scale));

    /* Work out which asset of a sequence we will be playing. */

    if (s->num_assets > 1)
    {
      unsigned int end_time = 0;

      for (s->cur_asset = 0; s->cur_asset < (s->num_assets - 1); s->cur_asset++)
      {
        end_time += s->assets[s->cur_asset].duration;
        if (s->from < end_time)
          break;
      }
    }

    dprintf(("", "play_mode_changed: Play will start from npt %d.%d (which is in asset %d)\n", s->from / 100, s->from % 100, s->cur_asset));

    /* Change the cached NPT to the NPT the server is now changing to.     */
    /* If the user does another state change before video actually starts, */
    /* this will be used as the 'now' time.                                */

    s->cached_npt = s->from;
    s->npt_cache_time = utils_read_time();

    if (s->asset_type == assettype_MPEG1Audio)
    {
      /* For audio assets, we can't get any sensible time information, so   */
      /* just say the start offset is the time we are seeking to, and count */
      /* elapsed time from now.                                             */
      s->assets[s->cur_asset].start_offset = s->from;
    }

    /* Set the time code reading callout to start looking for the first */
    /* time code. Regularly reading the time codes allows us to detect  */
    /* sequence transitions in the absence of any stream markers to     */
    /* indicate them. It is also necessary for sequences even when      */
    /* stream markers are present because there are cases where the     */
    /* asset number ends up wrong when you jump to a position very      */
    /* close to a sequence transition point.                            */

    s->time_found = 0;

    #ifdef USE_AMPLAYER
    if (s->read_tc_set == 0 && !(s->asset_type == assettype_MPEG1Audio && s->using_amplayer != 0))
    #else
    if (s->read_tc_set == 0)
    #endif
    {
      s->read_tc_set = 1;
      timeout(play_read_timecode_on_callout, s, Play_Initial_TimeCode_Timer);
    }
  }

  s->playmode = playmode;

  dprintf(("", "play_mode_changed: scale is now %d, tc_scale is %d\n", s->scale, s->tc_scale));

  return NULL;
}

/**************************************************************/
/* play_read_npt_from_timecode()                              */
/*                                                            */
/* Try to update the cached_npt value for the session by      */
/* reading the current time code from the video stream.       */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Returns:    Whether or not the time code was read.         */
/**************************************************************/

static bool play_read_npt_from_timecode(session * s)
{
  _kernel_oserror * e;
  unsigned int      time_code, temporal_reference;
  unsigned int      time_now;
  int               npt, scaled_npt, expected_npt;

  if (s->mpegid == 0)
    return false;

  /* Read the video time code */

  e = _swix(MPEGControl_ReadParameters,
            _INR(0,1) | _OUTR(1,2),

            MPEGControl_MCRP_TimeCode,
            s->mpegid,

            &time_code,
            &temporal_reference);

  if (e != NULL || time_code == 0xffffffff)
    return false;

  /* Remember the time we read the time code */
  time_now = utils_read_time();

  /* Time code is in hours, minute, seconds and frames - convert to centiseconds */

  /* Get time code time in centiseconds */
  npt =            100 * ((time_code & 0x000FC0) >> 6)  +
              60 * 100 * ((time_code & 0x03F000) >> 12) +
         60 * 60 * 100 * ((time_code & 0x7C0000) >> 18);

  /* Add frame number time */
  npt += (100 * ((time_code & 0x00003F) + temporal_reference)) / s->assets[s->cur_asset].approx_fps;

  /* First time code for simulated multicast? */
  if (s->multicast != 0 && s->time_found == 0)
  {
    /* We can't calculate NPT sensibly for simulated multicast, so we just */
    /* say that the time you start playing is NPT=0.                       */

    s->assets[s->cur_asset].start_offset = -npt;
  }

  /* Adjust for tc_scale and start time */
  scaled_npt = npt * s->tc_scale;
  if (s->tc_scale < 0)
    npt = s->assets[s->cur_asset].parent_duration + scaled_npt + s->assets[s->cur_asset].start_offset;
  else
    npt = scaled_npt + s->assets[s->cur_asset].start_offset;

  /* Now do some extra work to detect sequence transitions and cope with  */
  /* time codes that look wrong. Theoretically we don't need to do this   */
  /* for versions of MediaBase that insert the NPT reference descriptors, */
  /* since we detect sequence transitions by the markers in the stream,   */
  /* but if you jump very close to the transition point, it is possible   */
  /* to get the asset number wrong.                                       */

  /* Estimate what the NPT should now be */

  expected_npt = s->cached_npt;
  if (
      s->time_found != 0 &&
      s->playmode != Play_MB_Trick_Freeze &&
      s->playmode != Play_MB_Trick_EOS
     )
    expected_npt += (time_now - s->npt_cache_time) * s->scale;

  /* Watch out for sequence transitions. Note that we can't do this when */
  /* playing a simulated multicast since there is no way to tell where   */
  /* we are or which asset we are in.                                    */

  /* Note the distinction between s->scale and s->tc_scale. This     */
  /* allows the code to work both on MediaBase 5 (where trick stream */
  /* time codes are from the original stream) and MediaBase 6 (where */
  /* trick stream time codes give the position in the trick stream.) */

  if (s->scale < 0)
  {
    /* Going backwards */

    if (s->cur_asset > 0 && s->multicast == 0)
    {
      int   i, start_npt, time_to_start, sequence_margin;
      bool  npt_wrong;

      /* Work out the margin of error we allow for the NPT */
      sequence_margin = Play_Sequence_Margin * -s->scale / 2;

      /* Find the start time of the current asset */
      for (i = 0, start_npt = 0; i < s->cur_asset; i++)
        start_npt += s->assets[i].duration;

      /* How close are we to the start? */
      time_to_start = expected_npt - start_npt;

      /* Does the NPT look wrong? */
      npt_wrong = (abs(npt - expected_npt) > sequence_margin);

      if (npt_wrong || time_to_start < -sequence_margin/2)
      {
        int   asset = s->cur_asset;

        /* Either we are well beyond the expected asset change point,  */
        /* or the NPT calculated from the time code doesn't look       */
        /* right. In the latter case, if our expected NPT is near the  */
        /* start of the current asset we are probably now actually in  */
        /* the previous asset in the sequence, so recalculate the NPT  */
        /* using the times for the previous asset. If things still     */
        /* look wrong, and we are near the start of the previous asset */
        /* too (because it was extremely short - not very likely in    */
        /* practice), try moving on to that one and trying again.      */

        while (
               time_to_start < sequence_margin &&
               (npt_wrong || time_to_start < -sequence_margin/2) &&
               asset > 0
              )
        {
          dprintf(("", "Detected sequence change - expected_npt=%d, calculated npt=%d\n", expected_npt, npt));
          asset--;
          if (s->tc_scale < 0)
            npt = s->assets[asset].parent_duration + scaled_npt + s->assets[asset].start_offset;
          else
            npt = scaled_npt + s->assets[asset].start_offset;
          start_npt -= s->assets[asset].duration;
          time_to_start = expected_npt - start_npt;
          dprintf(("", "Now in asset %d, npt=%d\n", asset, npt));

          npt_wrong = (abs(npt - expected_npt) > sequence_margin);
        }

        /* If the NPT is still not OK, but this is the first time code   */
        /* we have read, assume the asset number was right but the start */
        /* time value was wrong. Otherwise, update the asset number.     */
        if (!npt_wrong || s->time_found != 0)
          s->cur_asset = asset;
      }
    }
  }
  else
  {
    /* Going forwards */

    if (s->cur_asset < (s->num_assets - 1) && s->multicast == 0)
    {
      int   i, end_npt, time_to_end, sequence_margin;
      bool  npt_wrong;

      /* Work out the margin of error we allow for the NPT */
      if (s->scale == 1)
        sequence_margin = Play_Sequence_Margin;
      else
        sequence_margin = Play_Sequence_Margin * s->scale / 2;

      /* Find the end time of the current asset */
      for (i = 0, end_npt = 0; i <= s->cur_asset; i++)
        end_npt += s->assets[i].duration;

      /* How close are we to the end? */
      time_to_end = end_npt - expected_npt;

      /* Does the NPT look wrong? */
      npt_wrong = (abs(npt - expected_npt) > sequence_margin);

      if (npt_wrong || time_to_end < -sequence_margin/2)
      {
        int   asset = s->cur_asset;

        /* Either we are well beyond the expected asset change point,  */
        /* or the NPT calculated from the time code doesn't look       */
        /* right. In the latter case, if our expected NPT is near the  */
        /* end of the current asset we are probably now actually in    */
        /* the next asset in the sequence, so recalculate the NPT      */
        /* using the times for the next asset. If things still look    */
        /* wrong, and we are near the end of the next asset too        */
        /* (because it was extremely short - not very likely in        */
        /* practice), try moving on to that one and trying again.      */

        while (
               time_to_end < sequence_margin &&
               (npt_wrong || time_to_end < -sequence_margin/2) &&
               asset < (s->num_assets - 1)
              )
        {
          dprintf(("", "Detected sequence change - expected_npt=%d, calculated npt=%d\n", expected_npt, npt));
          asset++;
          npt = scaled_npt + s->assets[asset].start_offset;
          end_npt += s->assets[asset].duration;
          time_to_end = end_npt - expected_npt;
          dprintf(("", "Now in asset %d, npt=%d\n", asset, npt));

          npt_wrong = (abs(npt - expected_npt) > sequence_margin);
        }

        /* If the NPT is still not OK, but this is the first time code   */
        /* we have read, assume the asset number was right but the start */
        /* time value was wrong. Otherwise, update the asset number.     */
        if (!npt_wrong || s->time_found != 0)
          s->cur_asset = asset;
      }
    }
  }

  /* If the NPT calculated from a time code is significantly different   */
  /* from the expected NPT assume the start or end time is wrong and     */
  /* adjust accordingly. Note that this code was originally added to     */
  /* cope with beta versions of MediaBase 6 which did not report the     */
  /* duration of the parent of a clip (needed for NPT calculation when   */
  /* rewinding), so this was necessary to calculate the parent duration  */
  /* from the first time code found. MediaBase 6 does now report the     */
  /* parent duration, so this is not necessary for that purpose, but it  */
  /* is still useful as it allows us to cope with discontinuities in     */
  /* time codes. This allows us to deal with simulated multicasts of     */
  /* sequences, where there is no way to tell when a sequence            */
  /* transition will occur.                                              */
  /* Note that we avoid doing this for trick play modes on MediaBase 5   */
  /* or earlier, because our seeking is too inaccurate for this to work. */

  #ifdef TRACE
  if (s->time_found == 0)
    dprintf(("Time_0","*** First NPT from time code=%d, expected=%d, difference=%d\n", npt, s->cached_npt, abs(npt - s->cached_npt)));
  #endif
  if (
      /* s->time_found == 0 && */
      abs(npt - expected_npt) > Play_TimeCode_Margin &&
      (s->playmode == Play_MB_Trick_Play || s->server_version >= 0x060000)
     )
  {
    if (s->tc_scale < 0)
    {
      s->assets[s->cur_asset].parent_duration = expected_npt - s->assets[s->cur_asset].start_offset - scaled_npt;
      dprintf(("Time_0", "Calculated NPT %d was not close to expected NPT %d. parent_duration recalculated as %d\n", npt, expected_npt, s->assets[s->cur_asset].parent_duration));
    }
    else
    {
      s->assets[s->cur_asset].start_offset = -(scaled_npt - expected_npt);
      dprintf(("Time_0", "Calculated NPT %d was not close to expected NPT %d. start_offset recalculated as %d\n", npt, expected_npt, s->assets[s->cur_asset].start_offset));
    }

    npt = expected_npt;
  }

  /* Success - npt should now hold the correct NPT */
  if (npt < 0)
    s->cached_npt = 0;
  else if (npt > s->duration)
    s->cached_npt = s->duration;
  else
    s->cached_npt = npt;

  /* Remember the time the NPT was cached */
  s->npt_cache_time = time_now;

  /* Set the flag to say the time has been successfully read */
  s->time_found = 1;

  dprintf(("Time_1","play_read_npt_from_timecode: time_code=%08X, temporal_reference=%03X, NPT=%d.%d\n", time_code, temporal_reference, s->cached_npt / 100, s->cached_npt % 100));

  return true;
}

/**************************************************************/
/* play_check_stream_received()                               */
/*                                                            */
/* Check the number of bytes the MPEG control unit has        */
/* received. This is used to spot when data starts arriving   */
/* to help us calculate a crude NPT for audio-only assets.    */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Returns:    Whether or not the number of bytes read has    */
/*             changed since we last checked.                 */
/**************************************************************/

static bool play_check_stream_received(session * s)
{
  static int        tags[] = {MPEGCtrl_MCS_BytesReceived, -1};
  int               stats[3];
  _kernel_oserror * e;

  if (s->mpegid != 0)
  {
    e = _swix(MPEGControl_Stats,
              _INR(0,4),
  
              0,
              s->mpegid,
              tags,
              stats,
              sizeof(stats));

    if (e == NULL && stats[0] == MPEGCtrl_MCS_BytesReceived)
    {
      if (stats[2] != s->stream_bytes)
      {
        s->stream_bytes = stats[2];
        return true;
      }
    }
  }

  return false;
}

/**************************************************************/
/* play_read_npt_from_stream()                                */
/*                                                            */
/* Try to update the cached_npt value for the session by      */
/* reading the current time code from the stream.             */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/* Returns:    Whether or not the time code was read.         */
/**************************************************************/

static bool play_read_npt_from_stream(session * s)
{
  /* For video assets, use the video time codes */

  if (s->asset_type != assettype_MPEG1Audio)
    return play_read_npt_from_timecode(s);

  /* When using AMPlayer, ask it about the elapsed time */

  #ifdef USE_AMPLAYER
  if (s->using_amplayer != 0)
    return amplay_read_npt(s);
  #endif

  /* For audio assets via Video Control we can't get accurate timing, so */
  /* just count elasped time from when we first get stream data.         */

  if (s->time_found == 0)
  {
    if (play_check_stream_received(s))
    {
      /* We've started receiving stream data */

      s->time_found = 1;
      s->npt_cache_time = utils_read_time();
    }
  }

  return false;
}

/**************************************************************/
/* play_read_timecode_on_callout()                            */
/*                                                            */
/* A CallOut handler (see CallOut.h) which reads the current  */
/* time code                                                  */
/*                                                            */
/* Parameters: The handle should point to the session struct  */
/*             we're interested in.                           */
/**************************************************************/

void play_read_timecode_on_callout(void * handle)
{
  session * s = (session *) handle;

  dprintf(("Callout_0", "play_read_timecode_on_callout: Called for %p\n", s));

  if (s->dying != 0 || s->read_tc_set == 0) return;

  play_read_npt_from_stream(s);

  /* Set the callout to go off again, unless we have stream markers or are    */
  /* playing an audio-only stream and have now read the initial time. When we */
  /* have stream markers we only use this when looking for the initial time   */
  /* code to double-check the sequence asset number is correct. When we are   */
  /* playing an audio-only stream we just use this to detect when the stream  */
  /* data starts arriving.                                                    */
  
  if (s->time_found == 0)
    timeout(play_read_timecode_on_callout, s, Play_Initial_TimeCode_Timer);
  else if (s->stream_markers == 0 && s->asset_type != assettype_MPEG1Audio)
    timeout(play_read_timecode_on_callout, s, Play_Read_TimeCode_Timer);
  else
    s->read_tc_set = 0;
}

/**************************************************************/
/* play_read_current_npt()                                    */
/*                                                            */
/* Return the current time position in the video in           */
/* centiseconds.                                              */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/*             Whether or not to forcibly update the cached   */
/*             NPT.                                           */
/*                                                            */
/* Returns:    Time in centiseconds. Time will be 0 if an     */
/*             error occurred.                                */
/**************************************************************/

int play_read_current_npt(session * s, bool force_cache)
{
  int npt;

  /* If we're not playing yet, return the cached value */

  if (s->started == 0)
    return s->cached_npt;

  /* Seeing as we are going to read now, cancel the reading callout if set */

  if (s->read_tc_set != 0)
    untimeout(play_read_timecode_on_callout, s);

  /* Try to read the video stream time code */

  if (play_read_npt_from_stream(s))
  {
    npt = s->cached_npt;
  }
  else
  {
    /* If this failed, use the cached NPT value */
  
    dprintf(("Time_0", "play_read_current_npt: Using cached time\n"));

    /* If we are paused, at end of stream, or a time code has not been read */
    /* yet, just return the cached value.                                   */
  
    if (
        s->playmode == Play_MB_Trick_Freeze ||
        s->playmode == Play_MB_Trick_EOS    ||
        s->time_found == 0
       )
    {
      npt = s->cached_npt;
    }
    else
    {
      unsigned int  time_now = utils_read_time();

      /* Return the cached value, plus the time elapsed since it was read. */
    
      npt = s->cached_npt + (time_now - s->npt_cache_time) * s->scale;
      if (npt < 0)
        npt = 0;
      else if (npt > s->duration)
        npt = s->duration;

      if (force_cache)
      {
        s->cached_npt = npt;
        s->npt_cache_time = time_now;
      }
    }
  }

  /* If the timecode reading callout was set, re-set it. */

  if (s->read_tc_set != 0)
    timeout(play_read_timecode_on_callout, s,
      (s->time_found == 0) ? Play_Initial_TimeCode_Timer : Play_Read_TimeCode_Timer);

  return npt;
}

/**************************************************************/
/* play_filter_range()                                        */
/*                                                            */
/* Filter a Range header value - can we deal with it? The     */
/* function also parses start and end values, and returns if  */
/* required the values in centiseconds; this includes parsing */
/* key words like 'now' or 'end' and converting to times or   */
/* an indication of no direct specifier.                      */
/*                                                            */
/* Parameters: Pointer to a relevant session structure.       */
/*                                                            */
/*             Pointer to the Range header value (may be NULL */
/*             in which case true is returned);               */
/*                                                            */
/*             Pointer to an int to take starting position,   */
/*             will be -1 if none is specified, and -2 if     */
/*             'now' was specified. May be NULL if not        */
/*             interested;                                    */
/*                                                            */
/*             Pointer to an int to take ending position,     */
/*             will be -1 if none is specified, and -2 if     */
/*             'now' was specified. May be NULL if not        */
/*             interested;                                    */
/*                                                            */
/* Returns:    true if the item is handleable, else false.    */
/*             The integers, if given, may be updated even    */
/*             when 'false' is returned.                      */
/**************************************************************/

static bool play_filter_range(session * s, const char * range, int * start_pos, int * end_pos)
{
  int  d_s, d_e;

  /* Ensure we always have start and end positions to write to */

  if (start_pos == NULL) start_pos = &d_s;
  if (end_pos   == NULL) end_pos   = &d_e;

  /* Ignore any range specification for simulated multicast, treat as "0-" */

  if (s->multicast != 0)
  {
    *start_pos = 0;
    *end_pos   = Play_MB_Time_Unspecified;

    return true;
  }

  /* We expect "npt=..." or just a time (no '"' in the string). We support */
  /* keywords 'now', 'end', 'beginning' and 'current' - well, subject to   */
  /* whatever is defined in Headers.h anyway. Note that we don't handle    */
  /* npt=hh:mm:ss.nn format times, although MediaBase itself will.         */

  *start_pos = Play_MB_Time_Unspecified;
  *end_pos   = Play_MB_Time_Unspecified;

  if (range == NULL) return true;

  /* Skip white space */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;

  if (strchr(range, '=') != NULL)
  {
    /* Ensure we have "npt" */

    if (!Strncmp_ci(range, Headers_HeaderValue_Range_NPT, sizeof(Headers_HeaderValue_Range_NPT) - 1))
    {
      range += sizeof(Headers_HeaderValue_Range_NPT) - 1;
    }
    else return false;

    /* Skip white space, ensure we have "=", skip it and white space */

    while (*range != '\0' && *range <= ' ') range++;
    if (*range == '\0') return true;
    else if (*range != '=') return false;
    range++;
    while (*range != '\0' && *range <= ' ') range++;
    if (*range == '\0') return true;
  }

  /* Do we recognise any starting point specifier? */

  if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now1, sizeof(Headers_HeaderValue_Range_Now1) - 1))
  {
    *start_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now2, sizeof(Headers_HeaderValue_Range_Now2) - 1))
  {
    *start_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now2) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Start1, sizeof(Headers_HeaderValue_Range_Start1) - 1))
  {
    *start_pos = 0;
    range += sizeof(Headers_HeaderValue_Range_Start1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_End1, sizeof(Headers_HeaderValue_Range_End1) - 1))
  {
    *start_pos = s->duration;
    range += sizeof(Headers_HeaderValue_Range_End1) - 1;
  }

  /* If there's a number here, it's allowed to be a number of seconds, and  */
  /* nothing else.                                                          */

  else if (isdigit(*range))
  {
    modulefp_buf buf;

    modulefp_enable(&buf);
    *start_pos = play_strtofi(range, &range, 100);
    modulefp_disable(&buf);
  }

  /* If there's something before the '-' and we get as far as this check, */
  /* we can't handle it                                                   */

  else if (*range != '-') return false;

  /* Skip white space, ensure we have "-", skip it and white space */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;
  else if (*range != '-') return false;
  range++;
  while (*range != '\0' && *range <= ' ') range++;
  if (*range == '\0') return true;

  /* Do we recognise any ending point specifier? */

  if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now1, sizeof(Headers_HeaderValue_Range_Now1) - 1))
  {
    *end_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Now2, sizeof(Headers_HeaderValue_Range_Now2) - 1))
  {
    *end_pos = Play_MB_Time_Now;
    range += sizeof(Headers_HeaderValue_Range_Now2) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_Start1, sizeof(Headers_HeaderValue_Range_Start1) - 1))
  {
    *end_pos = 0;
    range += sizeof(Headers_HeaderValue_Range_Start1) - 1;
  }
  else if (!Strncmp_ci(range, Headers_HeaderValue_Range_End1, sizeof(Headers_HeaderValue_Range_End1) - 1))
  {
    /* We don't use the Duration value for an end position as the server spits */
    /* a 500 error up if there's any "to" value...                             */

    range += sizeof(Headers_HeaderValue_Range_End1) - 1;
  }

  /* Must be a number, or nothing */

  else if (isdigit(*range))
  {
    modulefp_buf buf;

    modulefp_enable(&buf);
    *end_pos = play_strtofi(range, &range, 100);
    modulefp_disable(&buf);
  }

  /* If there's anything after the specifier, there's something wrong... */

  while (*range != '\0' && *range <= ' ') range++;
  if (*range != '\0') return false;

  return true;
}

/**************************************************************/
/* play_reconstruct_range_header()                            */
/*                                                            */
/* Rebuild a Range header based on the range_record from a    */
/* client's VideoControl_Play command (-> RTSPMB_Play) into a */
/* form that the server will understand.                      */
/*                                                            */
/* Parameters: Pointer to a session structure holding the     */
/*             range record;                                  */
/*                                                            */
/*             Pointer to a buffer to hold the new header -   */
/*             the minimum size should be something like      */
/*             sizeof("npt = 0-0") + 48.                      */
/**************************************************************/

static void play_reconstruct_range_header(session * s, char * temp)
{
  int from = s->from;

  /* Do we need to do strange adjustments to NPT for MPEG2 on old versions */
  /* of MediaBase?                                                         */

  if (
      from != Play_MB_Time_Unspecified &&
      s->server_version < 0x060000 &&
      s->asset_type == assettype_MPEG2 &&
      (s->next_playmode == Play_MB_Trick_FFWD || s->next_playmode == Play_MB_Trick_FRWD)
     )
  {
    modulefp_buf buf;

    dprintf(("", "play_reconstruct_range_header: time before adjustment=%d, ", from));

    /* Fudge factor. Things seem to go wrong if we ask for a time too     */
    /* close to the end, so don't go closer than 2s or so before the end. */

    if (from > (s->duration - Play_Old_MPEG2_End_Fudge))
    {
      from = s->duration - Play_Old_MPEG2_End_Fudge;
      dprintf(("", "moved back to %d, ", from));
    }

    modulefp_enable(&buf);
    from = play_get_trick_stream_npt(&s->assets[s->cur_asset], from);
    modulefp_disable(&buf);

    dprintf(("", "after adjustment=%d\n", from));
  }

  /* For MPEG1 trick streams, use the value returned via SET_PLAYMODE */

  else if (
      s->asset_type == assettype_MPEG1 &&
      (s->next_playmode == Play_MB_Trick_FFWD || s->next_playmode == Play_MB_Trick_FRWD)
     )
  {
    from = s->seek_from;
  }

  if (s->to == Play_MB_Time_Unspecified)
  {
    sprintf(temp, "npt=%d.%d-", from / 100, from % 100);
  }
  else if (from == Play_MB_Time_Unspecified)
  {
    sprintf(temp, "npt=-%d.%d", s->to / 100, s->to % 100);
  }
  else
  {
    sprintf(temp, "npt=%d.%d-%d.%d", from / 100, from % 100, s->to / 100, s->to % 100);
  }
}

/**************************************************************/
/* play_get_trick_stream_npt()                                */
/*                                                            */
/* Hackery to "adjust" NPT value for a trick stream based on  */
/* a normal play stream play time.                            */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session relating to the time;   */
/*                                                            */
/*             Play time in seconds from start of clip.       */
/*                                                            */
/* Returns:    Approximate trick play stream time relating to */
/*             the normal stream time given, *in cs*.         */
/**************************************************************/

static unsigned int play_get_trick_stream_npt(asset_data * asset, unsigned int npt)
{
  if (asset->frames_per_sec == 0 || asset->i_frame_ratio == 0)
  {
    /* If we're missing any values, assume a 2:1 ratio... :-/ */

    return npt / 2;
  }
  else
  {
    /* Kasenna said this - but it's wrong...                                   */
    /*                                                                         */
    /*    return (unsigned int) ((double) npt / (asset->i_frame_ratio + 1));   */
    /*                                                                         */
    /* Andrew's solution was to use:                                           */
    /*                                                                         */
    /*    return (unsigned int) (((double) npt * (asset->i_frame_ratio + 1)) / */
    /*                           asset->frames_per_sec);                       */
    /*                                                                         */
    /* The following seems a little better, but I can't get Kasenna to give    */
    /* me a proper answer as to why.                                           */

    return (unsigned int) (((double) npt * asset->i_frame_ratio) / asset->frames_per_sec);
  }
}

/**************************************************************/
/* play_get_mpeg1_trick_stream_npt()                          */
/*                                                            */
/* Convert to frame number returned by SET_PLAYMODE response  */
/* into NPT to seek to in PLAY command.                       */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session relating to the time;   */
/*                                                            */
/*             The frame number the server returned.          */
/*                                                            */
/* Returns:    NPT to seek to in trick stream, in             */
/*             centiseconds.                                  */
/**************************************************************/

static unsigned int play_get_mpeg1_trick_stream_npt(asset_data * asset, unsigned int frame)
{
  return (unsigned int) (((double) frame * 100) / asset->frames_per_sec);
}

/**************************************************************/
/* play_strtofi()                                             */
/*                                                            */
/* Convert a string to a fixed point integer value.           */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the string.                         */
/*                                                            */
/*             Pointer to variable to hold pointer to first   */
/*             unrecognised character (may be NULL).          */
/*                                                            */
/*             Factor to scale by.                            */
/*                                                            */
/* Returns:    The converted value. This will be zero if the  */
/*             conversion failed.                             */
/**************************************************************/

static int play_strtofi(const char *str, const char **endptr, int factor)
{
  return (int)(strtod(str, (char **)endptr) * factor);
}

/**************************************************************/
/* play_get_frame_number()                                    */
/*                                                            */
/* Given a time in seconds, return a frame number based on    */
/* the frames/second value read from DESCRIBE.                */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to the session relating to the time;   */
/*                                                            */
/*             Play time in centiseconds from start of clip.  */
/*                                                            */
/* Returns:    Approximate frame number.                      */
/**************************************************************/

static unsigned int play_get_frame_number(session * s, int npt)
{
  double d = (s->assets[s->cur_asset].frames_per_sec * npt) / 100;

  return (unsigned int) d;
}

#ifdef CLIENT_LOOPING

/**************************************************************/
/* play_copy_frame_info()                                     */
/*                                                            */
/* Copy the frames per second and frame to I-frame ratio      */
/* values from one session to another.                        */
/*                                                            */
/* Must only be used after modulefp_enable has been called.   */
/*                                                            */
/* Parameters: Pointer to destination session structure;      */
/*                                                            */
/*             Pointer to source session structure.           */
/**************************************************************/

static void play_copy_frame_info(session * dst, session * src)
{
  dst->frames_per_sec = src->frames_per_sec;
  dst->i_frame_ratio  = src->i_frame_ratio;

  return;
}

#endif

#if 0

/**************************************************************/
/* play_slowmofwd()                                           */
/*                                                            */
/* Work out whether reduced data rate slow motion forwards    */
/* play should be used for a given scale/speed specifier.     */
/*                                                            */
/* Parameters: Scale/speed specifier.                         */
/*                                                            */
/* Returns:    true to use reduced data rate slow motion      */
/*             forwards play (send a Speed header rather than */
/*             Scale), else false.                            */
/**************************************************************/

static bool play_slowmofwd(const char * scale)
{
  if (
       scale != NULL &&

       _swix(OS_Module,
             _INR(0,1),

             18,
             ReducedRateSlowmoSupportModule) /* Play.h */

       == NULL

       &&
       (
         !strncmp(scale, "0.", 2) ||
         *scale == '.'
       )
     )
     return true;

  return false;
}

#endif
