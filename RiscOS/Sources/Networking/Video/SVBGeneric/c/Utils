/*
 * Example of a fetcher module for use with Acorn URL system
 *
 * © Acorn Computers Ltd. 1995-1997
 *
 */

/* File:    Utils.c
 * Purpose: miscellaneous utility functions
 * Author:  IDJ
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include "debuglib/debuglib.h"

#include "Utils.h"

#define ERR_BLOCKS                 3
#define MessageTrans_TokenNotFound 0xAC2

static int             registered = 0;
static int             messages_fd[4];
static _kernel_oserror stored_error;

_kernel_oserror *read_message (const char * token, const char ** buffer, size_t * inoutlength)
{
  return _swix(MessageTrans_Lookup,
               _INR(0,7) | _OUTR(2,3),

               messages_fd,
               token,
               *buffer,
               *inoutlength,
               0,
               0,
               0,
               0,

               buffer,
               inoutlength);
}

_kernel_oserror * find_error (void)
{
  static _kernel_oserror global_error_block[ERR_BLOCKS];
  static int             errblock = 0;

  errblock = (errblock+1) % ERR_BLOCKS;
  return &global_error_block[errblock];
}

/* ------------------------------------ raising errors ---------------------------------------- */

extern _kernel_oserror * make_error (int err_num, int num_args, ...)
{
  /*
   * Generate a RISC OS error block.
   */

  va_list            ap;
  char             * s, token[4];
  int                i;
  _kernel_oserror  * e, * ptr;
  char             * sub[4] = {0,0,0,0};

  ptr         = find_error();
  ptr->errnum = err_num;

  num_args    = (num_args > 4) ? 4 : num_args;

  for (i = 0, va_start (ap, num_args); num_args--; i++)
  {
    s      = va_arg (ap, char *);
    sub[i] = (s && *s) ? s : NULL;
  }

  sprintf(token, "E%02x", err_num & 0xff);

  e = _swix(MessageTrans_Lookup,
            _INR(0,7),

            messages_fd,
            token,
            ptr->errmess,
            sizeof(*ptr) - sizeof(ptr->errnum) /* 252! */,
            sub[0],
            sub[1],
            sub[2],
            sub[3]);

  /* if the token isn't found, generate our own not found report */

  if ((e != NULL) && (e->errnum == MessageTrans_TokenNotFound))
  {
    _swix(MessageTrans_Lookup,
          _INR(0,7),

          messages_fd,
          "E03",
          ptr->errmess,
          sizeof(*ptr) - sizeof(ptr->errnum) /* 252! */,
          0,
          0,
          0,
          0);
  }

  va_end (ap);
  return ptr;
}

/* --------------------------------------- message file handling ------------------------------ */

extern _kernel_oserror * messages_file_open (char * messages_filename)
{
  _kernel_oserror * e = _swix(MessageTrans_OpenFile,
                              _INR(0,2),

                              messages_fd,
                              messages_filename,
                              0);

  if (e == NULL) registered = 1;

  return e;
}

extern _kernel_oserror * messages_file_close (void)
{
  _kernel_oserror * e;

  if (registered == 1) e = _swix(MessageTrans_CloseFile,
                                 _IN(0),

                                 messages_fd);

  else                 e = NULL;

  registered = 0;

  return e;
}

/**************************************************************/
/* utils_read_time()                                          */
/*                                                            */
/* Returns a notional value of current time, which is         */
/* guaranteed to rise continuously - up to clock wrap-around, */
/* that is... :-)                                             */
/*                                                            */
/* The implementation of this function most not use floating  */
/* point code.                                                */
/*                                                            */
/* Returns:    Notional value of current time as an unsigned  */
/*             integer. Units are unspecified.                */
/**************************************************************/

unsigned int utils_read_time(void)
{
  unsigned int result;

  _swix(OS_ReadMonotonicTime,
        _OUT(0),

        &result);

  return result;
}

/**************************************************************/
/* utils_time_difference()                                    */
/*                                                            */
/* Returns the difference, in seconds, between two time       */
/* values obtained from utils_read_time.                      */
/*                                                            */
/* The implementation of this function most not use floating  */
/* point code.                                                */
/*                                                            */
/* Parameters: Earliest time;                                 */
/*                                                            */
/*             Latest time.                                   */
/*                                                            */
/* Returns:    Latest minus earliest time, in seconds. Will   */
/*             be negative if the value passed as latest is   */
/*             actually ealier than the value passed as       */
/*             earliest.                                      */
/**************************************************************/

int utils_time_difference(unsigned int earliest, unsigned int latest)
{
  return (latest - earliest) / 100;
}

/**************************************************************/
/* utils_store_error()                                        */
/*                                                            */
/* Stores a copy of an error into a local block, overwriting  */
/* any previously stored error.                               */
/*                                                            */
/* Parameters: Pointer to the _kernel_oserror * struct to     */
/*             copy away. May be NULL.                        */
/**************************************************************/

void utils_store_error(_kernel_oserror * e)
{
  if (e != NULL)
  {
    stored_error.errnum = e->errnum;
    strncpy(stored_error.errmess, e->errmess, sizeof(stored_error.errmess));
  }

  return;
}

/**************************************************************/
/* utils_recall_error()                                       */
/*                                                            */
/* Recall an error stored with utils_store_error. The caller  */
/* bears responsibility for matching store to recall. Only    */
/* one error can be stored at a time.                         */
/*                                                            */
/* Returns:    Pointer to the stored error.                   */
/**************************************************************/

_kernel_oserror * utils_recall_error(void)
{
  return &stored_error;
}
