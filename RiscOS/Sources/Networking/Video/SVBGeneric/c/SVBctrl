/**************************************************************/
/* File:    SVBctrl.c                                         */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Control the SVBmip module.                        */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 21-Feb-2000 (ADH): Created.                       */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>

#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include <socklib.h>
#include <inetlib.h>
#include <netinet/in.h>

#include <VideoCtrl.h> /* Exported by VideoCtrl's !MkExport */

#include "Module.h"
#include "Utils.h"

#include "SVBctrl.h"

/* Local structure for SVB_EnumerateChannels */

typedef struct svbctrl_channel_info
{
  unsigned int     entry_size;
  unsigned int     control_handle;
  unsigned int     number;
  const char     * name;
  const char     * parameters;
  unsigned int     flags;
  unsigned int     join_requests;
  unsigned int     leave_requests;
  unsigned int     port;
  struct in_addr   address;
  const char       data[64 + 256]; /* Up to 64 chars name, 256 parameters */

} svbctrl_channel_info;

/* SWI definitions (at the time of writing SVBmip does not export a header) */

#ifndef SVB_SetServer

  #define SVB_SetServer         0x043c80
  #define SVB_OpenStream        0x043c81
  #define SVB_CloseStream       0x043c82
  #define SVB_CheckEndOfStream  0x043c83
  #define SVB_SetSpeed          0x043c84
  #define SVB_SetPosition       0x043c85
  #define SVB_ReadNPT           0x043c86
  #define SVB_ReadChannel       0x043c87
  #define SVB_ReadChannelNames  0x043c88
  #define SVB_EnumerateChannels 0x043cbc
  #define SVB_UpdateChannel     0x043cbd
  #define SVB_RemoveChannel     0x043cbe
  #define SVB_AddChannel        0x043cbf

#endif

/* Definitions for R0 on entry to SVB_OpenStream */

#define SVB_OpenStream_NumberInR1       (1u<<0) /* R1 = channel number if set, else pointer to string */
#define SVB_OpenStream_DoNotUseUDPV     (1u<<1) /* If set, don't call UDPV_StartOfPlay */

/* Similarly for SVB_EnumerateChannels */

#define SVB_EnumerateChannels_AsString  (1u<<0) /* Use channel file string if set, else write parsed data block */
#define SVB_EnumerateChannels_StartAtR1 (1u<<1) /* Start at channel number given in R1 */

/**************************************************************/
/* svbctrl_retrieve_port()                                    */
/*                                                            */
/* Ask SVBmip what port to stream video data to - this is     */
/* then communicated to Video Control from Status.c in the    */
/* call to VideoControl_ProtocolNotify.                       */
/*                                                            */
/* Parameters: Pointer to a session struct relevant to the    */
/*             stream-to-be.                                  */
/**************************************************************/

unsigned int svbctrl_retrieve_port(session * s)
{
  svbctrl_channel_info * i;
  _kernel_oserror      * e;
  unsigned int           port;
  int                    cont;

  if (s->channel < 1) return 0;

  i = malloc(sizeof(svbctrl_channel_info));
  if (i == NULL) return 0;

  e = _swix(SVB_EnumerateChannels,
            _INR(0,4) | _OUT(1),

            SVB_EnumerateChannels_StartAtR1, /* Want a specific channel's information            */
            s->channel,                      /* Channel to read                                  */
            i,                               /* Block to read into                               */
            sizeof(svbctrl_channel_info),    /* Size of block                                    */
            1,                               /* Number of entries to read                        */

            &cont);                          /* 0 = buffer to small, else a continuity indicator */


  if (e != NULL)
  {
    free(i);
    return 0;
  }

  if (cont != 0) port = i->port;
  else           port = 0;

  free(i);

  return port;
}

/**************************************************************/
/* svbctrl_open_stream()                                      */
/*                                                            */
/* Open a multicast stream with SVB_OpenStream, if one is not */
/* already open.                                              */
/*                                                            */
/* Parameters: Pointer to a session struct relevant to the    */
/*             new stream.                                    */
/**************************************************************/

_kernel_oserror * svbctrl_open_stream(session * s)
{
  if (s->have_svbid == 0)
  {
    _kernel_oserror * e;
    int               opts[4];

    opts[0] = vc_tags_control_handle;
    opts[1] = 1;
    opts[2] = 0;
    opts[3] = vc_tags__end;

    e = _swix(VideoControl_ProtocolOptions,
              _INR(0,2),

              0,
              s->vcid,
              opts);

    if (e == NULL)
    {
      e = _swix(SVB_OpenStream,
                _INR(0,2) | _OUT(0),

                SVB_OpenStream_NumberInR1 | SVB_OpenStream_DoNotUseUDPV,
                s->channel,
                opts[2],
                &s->svbid);
    }

    if (e == NULL) s->have_svbid = 1;

    return e;
  }

  return NULL;
}

/**************************************************************/
/* svbctrl_open_stream()                                      */
/*                                                            */
/* Close a multicast stream with SVB_CloseStream.             */
/*                                                            */
/* Parameters: Pointer to a session struct relevant to the    */
/*             existing stream.                               */
/**************************************************************/

_kernel_oserror * svbctrl_close_stream(session * s)
{
  if (s->have_svbid == 1)
  {
    _kernel_oserror * e = _swix(SVB_CloseStream,
                                _INR(0,1),

                                0,
                                s->svbid);

    s->have_svbid = 0;

    return e;
  }

  return NULL;
}
