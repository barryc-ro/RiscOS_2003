/*
 * vspc.c
 *
 * map VSP swis to mip calls

 History
 =======
 Date     Who      Comment
 ------------------------------------------------------------------------------


********************************************************************************/

#include <stdio.h>
#include <kernel.h>
#include <swis.h>
#include <ctype.h>
#include <string.h>

#include "socklib.h"
#include "inetlib.h"

#include "vsp.h"
#include "misc.h"
#include "mip.h"
#include "vspc.h"
#include "mod.h"

/*extern _kernel_oserror *mip_startstream(), *mip_closestream(), *mip_error();

extern char *mip_channel_name(int);*/

extern int mpeg_handle, endofstream_timeout;
extern int endofstream, endofstream_timer, current_channel;
extern int channel_file_read;
int last_rxcount = 0;
int playpaused = 0;

_kernel_oserror *OpenStream(_kernel_swi_regs *r)
{
    _kernel_oserror *err;
    int margc;
    char *margv[10];
    char *cp;
    char **argp = margv;

    margc = 0;
    cp = (char *)r->r[1];
    mpeg_handle = r->r[2];
    last_rxcount = 0;
    endofstream = 0;
    endofstream_timer = 0;
    playpaused = 0;
    while (*cp) {
        while (isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !iscntrl(*cp) && !isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;
    err = mip_startstream(margc, margv, mpeg_handle);
    r->r[0] = err ? 0 : 1;
    return (err);
}

_kernel_oserror *CloseStream(_kernel_swi_regs *r)
{
    _kernel_oserror *err;

    err = mip_closestream();
    return (err);
}

_kernel_oserror *CheckEndofStream(_kernel_swi_regs *r)
{
    _kernel_oserror *err = 0;
    int rxcount = 0;

    if (playpaused)
        goto out;
    if (endofstream_timeout == 0) {
        endofstream = 0;
        goto out;
    }
    rxcount = mpeg_streamcount(mpeg_handle);
    if (rxcount == -1)
        endofstream = 1;
    else {
        if (rxcount > last_rxcount) {
            endofstream_timer = 0;
            endofstream = 0;
        }
        else if (endofstream_timer == 0)
            endofstream_timer = rxcount > 0 ? endofstream_timeout : ENDOFSTREAM_TIMEOUT;
    }
out:
    r->r[0] = endofstream;
    r->r[2] = 0;
    r->r[3] = 0;
    last_rxcount = rxcount;
    return (endofstream ? mip_error(rspNoVideo, 1) : err);
}

_kernel_oserror *SetSpeed(_kernel_swi_regs *r)
{
    (void) mip_playcontrol(r->r[0], r->r[2]);
    return (0);
}

_kernel_oserror *SetPosition(_kernel_swi_regs *r)
{
    return (0);
}

_kernel_oserror *ReadNPT(_kernel_swi_regs *r)
{
    r->r[0] = -1;
    return ((_kernel_oserror *)0);
}

_kernel_oserror *SetServer(_kernel_swi_regs *r)
{
    return ((_kernel_oserror *)0);
}

_kernel_oserror *ReadChannel(_kernel_swi_regs *r)
{
    char *ch;

    r->r[0] = current_channel;
    if ((ch = mip_channel_name(current_channel)) != 0)
    {
      set_sysvar("SVB$ChannelName", ch, strlen(ch));
    }
    else
    {
      char *noid = "<unset>";

      set_sysvar("SVB$ChannelName", noid, strlen(noid));
    }

    return ((_kernel_oserror *)0);
}


_kernel_oserror *ReadChannelNames(_kernel_swi_regs *r)
{
  if (!channel_file_read || (1 & r->r[0]))
  {
    (void) read_channel_info();
  }
  return ((_kernel_oserror *)0);
}

