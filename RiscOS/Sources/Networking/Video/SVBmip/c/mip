/*
 * mip
 *
 * Multicast IP (IGMP) Interface functions
 */

#include <stdio.h>
#include <stdlib.h>
#include <kernel.h>
#include <swis.h>
#include <string.h>
#include <ctype.h>

#include "socklib.h"
#include "inetlib.h"

#include "vsp.h"
#include "mip.h"
#include "mod.h"
#include "misc.h"

extern int do_debug, playpaused, sockid;
extern int cur_chan, max_chan, channel_overlaps, channel_underlaps;
extern struct ip_mreq mreq;

int current_channel = -1;
int channel_file_read = 0;

struct cbuf mip_channel_blocks[N_CHANNELS];

_kernel_oserror *mip_startstream(int argc, char **argv, int handle)
{
  int i, rsp;
  int newchannel = -1;

  if (!channel_file_read)
  {
    if (do_debug)
      printf("\n\n\n\n        Read channel information\n");

    (void) read_channel_info();
    channel_file_read = 1;
  }

  for (i = 1; i < argc; i++)
  {
    if (caseless_strcmp(argv[i], "-channel") == 0 && ++i < argc)
    {
      newchannel = atoi(argv[i]);
      break;
    }
  }

  /* amg: begin -server implementation */
  for (i = 1; i < argc; i++) /* look for -server switch */
  {
    if (caseless_strcmp(argv[i], "-server") == 0 && ++i < argc)
    {
      int mci;
      char *argv_ip;

      argv_ip = malloc(1+strlen(argv[i]));
      if (argv_ip) strcpy(argv_ip, argv[i]); /* take a local copy of argv[i] */

      mci = mip_channel_index(newchannel);   /* check the channel number */

      if (mci != -1 && argv_ip)
      {
        int port = 0;
        char *portp = strchr(argv_ip, '/');  /* is there a port quoted ? */

        if (portp != 0)
        {
          *portp++ = 0;
          port = atoi(portp);                /* pull off the port */
          if (port < 0) port = 0;
        }

        if (mip_channel_blocks[mci].c_port != port || mip_channel_blocks[mci].c_group.s_addr != inet_addr(argv_ip))
        {
          mip_channel_blocks[mci].c_joins = 0; /* zero the counts if changing server or port */
          mip_channel_blocks[mci].c_leaves = 0;
        }
        mip_channel_blocks[mci].c_port = port;
        mip_channel_blocks[mci].c_group.s_addr = inet_addr(argv_ip);
      }
      if (argv_ip) free(argv_ip);
    }
  }
  /* amg: end -server implementation */

  if (newchannel == CHANNEL_UP)
    newchannel = mip_next_channel();
  else if (newchannel == CHANNEL_DOWN)
    newchannel = mip_last_channel();

  if (newchannel == -1)
    return(mip_error(rspEntitlementFailure, 0));

  if (newchannel != current_channel)
  {
    i = mip_channel_index(newchannel);

    if (i == -1)
    {
      return(mip_error(rspEntitlementFailure, 0));
    }
    else
    {
      if (current_channel != -1)
      {
        leave_mip_group(current_channel);
      }
      rsp = join_mip_group(newchannel);
      if (rsp == rspOk)
      {
        mip_initstream(handle, mip_channel_port(newchannel));
        current_channel = newchannel;
        (void) mip_set_cur_chan(current_channel);
      }
      return(mip_error(rsp, 0));
    }
  }
  else
  {
    return(mip_error(NULL,0));
  }
}


_kernel_oserror *mip_closestream(void)
{
    if (current_channel != -1)
    {
        leave_mip_group(current_channel);
        current_channel = -1;
    }
    /* channel_file_read = 0; */
    return (mip_error(0, 0));
}


_kernel_oserror *mip_playcontrol(int do_fast_scan, int val)
{
    if (do_fast_scan)
        return ((_kernel_oserror *)0);
    if (val == 0)
        playpaused = 1;
    else
        playpaused = 0;
    return ((_kernel_oserror *)0);
}


void mip_initstream(int handle, int port)
{
    _kernel_swi_regs r;

    r.r[0] = 2;
    r.r[1] = 0;
    r.r[2] = port;
    r.r[3] = handle;
    r.r[4] = 0;
    (void) _kernel_swi(XOS_Bit | StreamInitSWI, &r, &r);
}



int mip_channel_index(int c_id)
{
  int i;

  for (i = 0; i < N_CHANNELS; i++)
  {
    if (mip_channel_blocks[i].c_nbr == -1)
    {
      break;
    }
    if (mip_channel_blocks[i].c_nbr == c_id)
    {
      return(i);
    }
  }
  return(-1);
}


char *mip_channel_name(int c_id)
{
    int i = mip_channel_index(c_id);

    if (i != -1)
    {
      return(mip_channel_blocks[i].c_name);
    }
    else
    {
      return(NULL);
    }
}


int mip_channel_port(int c_id)
{
    int i = mip_channel_index(c_id);

    if (i != -1)
    {
      return(mip_channel_blocks[i].c_port);
    }
    else
    {
      return(-1);
    }
}


struct in_addr *mip_channel_group(int c_id)
{
    int i = mip_channel_index(c_id);

    if (i != -1)
    {
      return(&mip_channel_blocks[i].c_group);
    }
    else
    {
      return((struct in_addr *) NULL);
    }
}


int mip_set_cur_chan(int c_id)
{
    int i = mip_channel_index(c_id);

    if (i != -1)
    {
      cur_chan = i;
      return(EXIT_SUCCESS);
    }
    else
    {
      return(EXIT_FAILURE);
    }
}


int mip_next_channel(void)
{
    if (++cur_chan > max_chan)
        cur_chan = 0;
    return (mip_channel_blocks[cur_chan].c_nbr);
}


int mip_last_channel(void)
{
    if (--cur_chan < 0)
        cur_chan = max_chan;
    return (mip_channel_blocks[cur_chan].c_nbr);
}


int join_mip_group(int new_c_id)
{
  int rsp, i;
  struct in_addr *addr;

  for (i = 0; i < N_CHANNELS; i++)
  {
    if (mip_channel_blocks[i].c_nbr == -1)
    {
      break;
    }
    if (mip_channel_blocks[i].c_joins > mip_channel_blocks[i].c_leaves)
    {
      channel_overlaps++;
      leave_mip_group(mip_channel_blocks[i].c_nbr);
      if (mip_channel_blocks[i].c_joins > mip_channel_blocks[i].c_leaves)
      {
        mip_channel_blocks[i].c_leaves = mip_channel_blocks[i].c_joins;
      }
    }
  }

  addr = mip_channel_group(new_c_id);
  if (addr != NULL)
  {
    mreq.imr_multiaddr = *addr;

    if (do_debug)
      printf("\n\n\n\n        Joining Group %s\n", inet_ntoa(mreq.imr_multiaddr));

    rsp = setsockopt(sockid, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
    if (rsp != -1)
    {
      i = mip_channel_index(new_c_id);
      if (i != -1)
      {
        mip_channel_blocks[i].c_joins++;
      }
      else
      {
        return(rspBadChannel);
      }
      return(rspOk);
    }
    else
    {
      return(rspBcProgramOutOfService);
    }
  }
  else
  {
    return(rspBadChannel);
  }
}


int leave_mip_group(int c_id)
{
  int i;

  i = mip_channel_index(c_id);
  if (i != -1)
  {
    mreq.imr_multiaddr = mip_channel_blocks[i].c_group;

    if (do_debug)
      printf("\n\n        Leaving Group %s\n", inet_ntoa(mreq.imr_multiaddr));

    (void) setsockopt(sockid, IPPROTO_IP, IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
    mreq.imr_multiaddr.s_addr = 0;
    mip_channel_blocks[i].c_leaves++;
    if (mip_channel_blocks[i].c_leaves > mip_channel_blocks[i].c_joins)
    {
      channel_underlaps++;
      mip_channel_blocks[i].c_leaves = mip_channel_blocks[i].c_joins;
    }
    return(rspOk);
  }
  else
  {
    return(rspBadChannel);
  }
}


int read_channel_info(void)
{
    FILE *fp;
    int i, n = 0;
    char line[300], name[64], group[64], nbr[64];

    if ((fp = fopen(CHANNELFILE, "r")) == NULL)
    {
        mip_channel_blocks[0].c_nbr = -1;
        return (0);
    }
    while(fgets(line, 100, fp) != NULL)
    {
        if (line[0] == '|')
            continue;
        i = sscanf(line, "%s %s %s", nbr, name, group);
        if (i == 3)
        {
             int port = 0;
             char *portp = strchr(group, '/');

             if (portp != 0)
             {
                 *portp++ = 0;
                 port = atoi(portp);
                 if (port < 0)
                   port = 0;
             }
             mip_channel_blocks[n].c_nbr = atoi(nbr);
             mip_channel_blocks[n].c_group.s_addr = inet_addr(group);
             mip_channel_blocks[n].c_port = port;
             mip_channel_blocks[n].c_flags = c_flags_SUBSCRIBED;
             mip_channel_blocks[n].c_joins = 0;
             mip_channel_blocks[n].c_leaves = 0;
             strcpy(mip_channel_blocks[n].c_name, name);
             n++;
        }
    }
    max_chan = n-1;
    mip_channel_blocks[n].c_nbr = -1;
    fclose(fp);
    return (1);
}

int caseless_strcmp(char *a, char *b)
{
    int d;

    while ( *a || *b ) {
        d = toupper( *(a++) ) - toupper( *(b++) );
        if ( d )
            return d;
    }
    return 0;
}

int caseless_strncmp(char *a, char *b, int n)
{
    int d;

    while ( *a || *b ) {
        d = toupper( *(a++) ) - toupper( *(b++) );
        if ( d )
            return d;
        if (--n == 0)
           break;
    }
    return 0;
}
