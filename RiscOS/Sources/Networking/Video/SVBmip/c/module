/*
 * module.c
 *
 * RISC OS environment dependencies
 */
#include <stdio.h>
#include <stdlib.h>
#include <kernel.h>
#include <swis.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>

#include "socklib.h"
#include "inetlib.h"
#include "sys/ioctl.h"
#include "netinet/in.h"
#include "net/if.h"

#include "vsp.h"
#include "misc.h"
/*#include "mip.h"*/

#include "mod.h"
#include "vspc.h"
#include "mip.h"


#define TickerV              28

struct ebuf {
    int  e_nbr;
    char e_string[64];
} ebuf = { 0 };

#define N_MIP_ERRORS 16
struct ebuf mip_error_blocks[N_MIP_ERRORS];

extern struct cbuf mip_channel_blocks[];
extern int channel_file_read;

struct client {
        void (*cli_call)();      /* cli handler */
};


struct client vsp_cli_call[1] = {
    vsstats
};


struct swient {
    _kernel_oserror *(*swi_call)();      /* swi handler */
};

#define MAXSWI 10

/*extern int SetServer(_kernel_swi_regs *r);
extern int OpenStream(_kernel_swi_regs *r);
extern int CloseStream(_kernel_swi_regs *r);
extern int CheckEndofStream(_kernel_swi_regs *r);
extern int SetSpeed(_kernel_swi_regs *r);
extern int SetPosition(_kernel_swi_regs *r);
extern int ReadNPT(_kernel_swi_regs *r);
extern int ReadChannel(_kernel_swi_regs *r);
extern int ReadChannelNames(_kernel_swi_regs *r);*/

struct swient vsp_ent[MAXSWI] = {
    SetServer,
    OpenStream,
    CloseStream,
    CheckEndofStream,
    SetSpeed,
    SetPosition,
    ReadNPT,
    ReadChannel,
    ReadChannelNames,
    0,
};

void *module_wsp = 0;
int mpeg_handle;
int endofstream = 0;
int endofstream_timer = 0;
int endofstream_timeout = 0;
int do_debug = 0;
int notify_via_var = 0;
int sockid = -1;
struct ip_mreq mreq;
int cur_chan = -1;
int max_chan = 0;
int channel_overlaps = 0;
int channel_underlaps = 0;

/*extern int vsp_final();
extern int read_npt();*/

_kernel_oserror *vsp_init(char *cmd_tail, int pbase, void *pw)
{
    char buf[64];

    module_wsp = pw;
    if (read_sysvar("SVB$EOSTimeout", buf, sizeof(buf)) != 0)
        endofstream_timeout = atoi(buf);
    else
        endofstream_timeout = ENDOFSTREAM_TIMEOUT;
    if (read_sysvar("SVB$Debug", buf, sizeof(buf)) != 0)
        do_debug = 1;
    if (read_sysvar("SVB$WebErrorReports", buf, sizeof(buf)) != 0)
        notify_via_var = 0;
    else
        notify_via_var = 1;
    if (read_sysvar("SVB$MCAdrSpecific", buf, sizeof(buf)) != 0)
        (void) read_my_ip_address(&mreq.imr_interface);
    else
        mreq.imr_interface.s_addr = INADDR_ANY;
    (void) enable_tick_handler();
    (void) read_error_msgs();
/*    atexit(vsp_final); */

    return ((_kernel_oserror *)0);
}

int enable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = 100;
  r.r[1] = (int)tick_entry;
  r.r[2] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_CallEvery, &r, &r) != 0 ? -1 : 0);
}

int disable_tick_handler(void)
{
  _kernel_swi_regs r;

  r.r[0] = (int)tick_entry;
  r.r[1] = (int)module_wsp;
  return (_kernel_swi(XOS_Bit | OS_RemoveTickerEvent, &r, &r) != 0 ? -1 : 0);
}

int tick_handler(_kernel_swi_regs *r)
{
    if (endofstream_timer && --endofstream_timer == 0)
        endofstream = 1;
    return (1);
}

int vsp_final(void)
{
    (void) disable_tick_handler();
    if (sockid != -1)
        socketclose(sockid);
    return (1);
}

_kernel_oserror *vsp_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    _kernel_oserror *err = 0;
    struct swient *callp = &vsp_ent[swinum];

    err = (_kernel_oserror *)(*(callp->swi_call))(r);
    return (err);
}


_kernel_oserror *vsp_cli_handler(char * arg_string, int arg_count, int cmd_no, void * pw)
{
    struct client *callp;
    int margc;
    char *margv[10];
    char *cp;
    char **argp = margv;

    margc = 0;
    cp = arg_string;
    while (*cp && arg_count-- > 0) {
        while (isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *argp++ = cp;
        margc++;
        while (*cp != '\0' && !iscntrl(*cp) && !isspace(*cp))
            cp++;
        if (*cp == '\0' || iscntrl(*cp))
            break;
        *cp++ = '\0';
    }
    *argp++ = 0;
    callp = &vsp_cli_call[cmd_no];
    (void)(*(callp->cli_call))(margc, margv);
    return ((_kernel_oserror *)0);
}


int read_error_msgs(void)
{
    FILE *fp;
    int n = 0;
    char line[120], *p;

    if ((fp = fopen(ERRMSGFILE, "r")) == NULL)
        return (0);
    while (fgets(line, 100, fp) != NULL)
    {
        if (line[0] == '|')
            continue;
        p = strchr(line, ':');
        if (p)
        {
             *p++ = 0;
             mip_error_blocks[n].e_nbr = atoi(line);
             strncpy(mip_error_blocks[n].e_string, p, 64);
             n++;
        }
    }
    mip_error_blocks[n].e_nbr = 0;
    fclose(fp);
    return(1);
}


#define MPEGControl_Stats           0x492c9

int tags[2];
int stats[3];

int mpeg_streamcount (int handle)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    tags[0] = 0;  /* tag value for amount received by ctrl module */
    tags[1] = -1; /* terminator */

    stats[2] = -1;  /* default value */

    r.r[0] = 0;
    r.r[1] = handle;
    r.r[2] = (int)tags;
    r.r[3] = (int)stats;
    r.r[4] = 12;
    e = _kernel_swi(XOS_Bit | MPEGControl_Stats, &r, &r);
    return (stats[2]);
}

void do_cli(char *str)
{
    _kernel_swi_regs r;

    r.r[0] = (int)str;
    (void) _kernel_swi(XOS_Bit | OS_CLI, &r, &r);
}

int read_sysvar(char *var, char *buf, int buflen)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = (int)var;
    r.r[1] = (int)buf;
    r.r[2] = buflen;
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
    if (e || r.r[2] == 0)
        return (0);
    buf[r.r[2]] = 0;
    return (1);
}

int set_sysvar(char *var, char *buf, int len)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = (int)var;
    r.r[1] = (int)buf;
    r.r[2] = len;
    r.r[3] = 0;
    r.r[4] = 0;
    e = _kernel_swi(XOS_Bit | OS_SetVarVal, &r, &r);
    return (1);
}

extern int current_channel;

void vsstats(int argc, char ** argv)
{
    int n;

    printf("cur_chan=%d, max_chan=%d, current_channel=%d\n", cur_chan, max_chan, current_channel);
    printf("myadr=%s\n", inet_ntoa(mreq.imr_interface));
    printf("Channel overlaps:  %d\n",channel_overlaps);
    printf("Channel underlaps: %d\n",channel_underlaps);
    printf("Channel Info:\n\n");
    if (channel_file_read)
    {
      for (n = 0; n < N_CHANNELS ; n++)
      {
          if (mip_channel_blocks[n].c_nbr == -1)
              break;
           printf("  Channel id=%02d,", mip_channel_blocks[n].c_nbr);
           printf("  Group Addr=%s,", inet_ntoa(mip_channel_blocks[n].c_group));
           printf("  MPEG Port=%d\n", mip_channel_blocks[n].c_port);
           printf("  Channel joins=%d,", mip_channel_blocks[n].c_joins);
           printf("  leaves=%d,", mip_channel_blocks[n].c_leaves);
           printf("  flags=%x\n", mip_channel_blocks[n].c_flags);
           printf("  Channel Name=%s\n\n", mip_channel_blocks[n].c_name);
      }
    }
    else
    {
      printf(" - not yet available\n");
    }
    return;
}

int read_my_ip_address(struct in_addr *adr)
{
    char buf[512];
    struct ifconf ifc;
    struct ifreq ifreq, *ifr;
    struct sockaddr_in *sin;
    int n;

    adr->s_addr = 0;
    if ((sockid = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
        return (0);
    ifc.ifc_len = sizeof (buf);
    ifc.ifc_buf = buf;
    if (socketioctl(sockid, SIOCGIFCONF, (char *)&ifc) < 0) {
        return (0);
    }
    ifr = ifc.ifc_req;
    for (n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++) {
        ifreq = *ifr;
        if (socketioctl(sockid, SIOCGIFFLAGS, (char *)&ifreq) < 0 || ifreq.ifr_flags & IFF_LOOPBACK)
            continue;
        if ((ifreq.ifr_flags & (IFF_BROADCAST|IFF_UP)) != (IFF_BROADCAST|IFF_UP))
            continue;
        if (socketioctl(sockid, SIOCGIFADDR, (char *)&ifreq) < 0)
            continue;
        sin = (struct sockaddr_in *)&ifreq.ifr_addr;
        adr->s_addr = sin->sin_addr.s_addr;
        break;
    }
    return (1);
}


_kernel_oserror *mip_error(int err, int fatal)
{
    int i;

    if (!err)
        return ((_kernel_oserror *)0);
    for (i = 0; i < N_MIP_ERRORS; i++) {
        if (mip_error_blocks[i].e_nbr == 0)
            break;
        if (mip_error_blocks[i].e_nbr == err) {
            ebuf.e_nbr = err;
            sprintf(ebuf.e_string, "%s\n", mip_error_blocks[i].e_string);
            if (notify_via_var) {
                if (fatal)
                    (void) set_sysvar("SVB$StatusFatal", ebuf.e_string, strlen(ebuf.e_string));
                else
                    (void) set_sysvar("SVB$StatusInfo", ebuf.e_string, strlen(ebuf.e_string));
                return ((_kernel_oserror *)0);
            }
            else
                return ((_kernel_oserror *)&ebuf);
        }
    }
    ebuf.e_nbr = err;
    sprintf(ebuf.e_string, "Unspecified SVB error %d\n", err);
    return ((_kernel_oserror *)&ebuf);
}
