/* yo/yosx.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/








#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YSM_ORACLE
#include <ysm.h>
#endif
#ifndef YOSX_ORACLE
#include <yosx.h>
#endif

#define YOSXBLKSZ  1024


externdef ysidDecl(YO_EX_ENDOFDATA) = "yo::endofdata";
externdef ysidDecl(YO_EX_ENCODEERROR) = "yo::encodeerror";


static    ysmtagDecl(YOSX_TAG) = "yosx";
static    ysmtagDecl(YOSXBV_TAG) = "yosx bv";

STATICF void yosxAddBuf(yosx *x);
STATICF void yosxGetNSB8(yosx *x, sysb8 *val);
STATICF void yosxGetSSB8(yosx *x, sysb8 *val);


yosx *yosxDecode( boolean lsborder, ysbv *bv, sword nbv)
{
  yosx *x;

  x = (yosx *) ysmGlbAlloc(sizeof(yosx), YOSX_TAG);
  yosxDecInit(x, lsborder, bv, nbv);
  return x;
}


void yosxDecInit( yosx *x, boolean lsborder, ysbv* bv, sword nbv)
{
  x->enc = FALSE;
  x->bv = bv;
  x->nbv = nbv;
  x->idx = 0;
  if (nbv)
    x->ptr = bv->buf, x->cnt = bv->len;
  else
    x->ptr = (ub1 *) 0, x->cnt = 0;
  x->hp = (ysmhp *) 0;
  x->cb = (yosxcb) 0;
  x->usrp = (dvoid *) 0;
  yosxDecSet( x, lsborder );
}


yosx *yosxDecodeFromStream(yosxcb getbufcb, boolean lsborder,
			   ysbv *bv, dvoid *usrp)
{
  yosx *x;

  x = (yosx *) ysmGlbAlloc(sizeof(yosx), YOSX_TAG);
  x->enc = FALSE;
  x->bv = bv;
  x->nbv = 1;
  x->idx = 0;
  x->ptr = (ub1 *) 0;
  x->cnt = 0;
  x->hp = (ysmhp *) 0;
  x->cb = getbufcb;
  x->usrp = usrp;
  yosxDecSet( x, lsborder );
  return x;
}

boolean  yosxDecGet(yosx *x)
{
  return SYSX_BYTE_ORDER ? x->noswap : !x->noswap;
}

void yosxDecSet(yosx *x, boolean lsborder)
{
  if( SYSX_BYTE_ORDER == lsborder ) 
  {
    
    x->noswap = TRUE;
    x->get8 = yosxGetNSB8;
  }
  else
  {
    x->noswap = FALSE;
    x->get8 = yosxGetSSB8;
  }
}


void yosxDecEnd(yosx *x)
{
  ysmGlbFree((dvoid *) x);
}


void yosxGetPos(yosx *x, yosxPos *pos )
{
  pos->idx = x->idx;
  pos->off = x->bv[x->idx].len - x->cnt;
}


void yosxSetPos(yosx *x, yosxPos *pos )
{
  if( x->enc )
    yseThrow(YS_EX_BADPARAM);

  x->idx = pos->idx;
  x->cnt = x->bv[x->idx].len - pos->off;
  x->ptr = x->bv[x->idx].buf + pos->off;
}


ub4 yosxGetLength(yosx *x, yosxPos *pos1, yosxPos *pos2)
{
  ub4	    rv;
  yosxPos   *t;
  sword	    idx;
  
  
  if(pos2->idx < pos1->idx ||
     ((pos2->idx == pos1->idx) && pos2->off < pos1->off) )
  {
    t = pos1;
    pos1 = pos2;
    pos2 = t;
  }

  
  if( (idx = pos1->idx) == pos2->idx )
  {
    rv = pos2->off - pos1->off;
  }
  else				
  {
    
    rv = x->bv[idx++].len - pos1->off;

    
    while( idx < pos2->idx )
      rv += x->bv[idx++].len;

    
    rv += pos2->off;
  }
  return rv;
}


void yosxSkip(yosx *x, size_t len)
{
  size_t amt;
  boolean ok;

  do
    {
      amt = min(len, x->cnt);
      x->cnt -= amt, x->ptr += amt, len -= amt;
      if (!x->cnt)
	{
	  if (!x->cb)
	    {
	      x->idx++;
	      if (x->idx < x->nbv)
		{
		  x->ptr = x->bv[x->idx].buf;
		  x->cnt = x->bv[x->idx].len;
		}
	      else if (len)
		yseThrow(YO_EX_ENDOFDATA);
	    }
	  else
	    {
	      if (x->idx < x->nbv)
		ok = (*x->cb)(x->bv, x->usrp);
	      else
		ok = FALSE;

	      if (ok)
		{
		  x->ptr = x->bv->buf;
		  x->cnt = x->bv->len;
		}
	      else if (len)
		yseThrow(YO_EX_ENDOFDATA);
	      else
		x->idx++;
	    }
	}
    }
  while (len);
}


dvoid *yosxGetAlign( yosx *x, sword amt )
{
  dvoid *ptr;
  size_t off, diff;

  
  if (x->cnt)
  {
    off = x->bv[x->idx].len - x->cnt;
    diff = ysRoundVal(off, amt) - off;
    x->ptr += diff, x->cnt -= diff;
  }

  while (x->cnt < (ub4) amt && x->idx < x->nbv)
    yosxSkip(x, x->cnt);

  if (x->idx < x->nbv)
  {
    ptr = (dvoid*)x->ptr;
    x->cnt -= amt;
    x->ptr += amt;
    return ptr;
  }
  yseThrow(YO_EX_ENDOFDATA);
  
  return( (dvoid*)0 );
}


yosx *yosxEncode(size_t len, ysmhp *hp)
{
  yosx *x;

  x = (yosx *) ysmAlloc(hp, sizeof(yosx), YOSX_TAG);
  x->enc = TRUE;
  x->bv = (ysbv *) ysmAlloc(hp, sizeof(ysbv), YOSXBV_TAG);
  x->nbv = 1;
  if (len == 0)
    len = YOSXBLKSZ;
  x->cnt = x->bv->len = len;
  x->ptr = x->bv->buf = (ub1 *) ysmAlloc(hp, len, "yosx buf");
  x->idx = 0;
  x->hp = hp;
  x->cb = (yosxcb) 0;
  x->usrp = (dvoid *) 0;
  
  return x;
}


yosx *yosxEncodeToStream(yosxcb putbufcb, ysbv *bv, dvoid *usrp)
{
  yosx *x;

  x = (yosx *) ysmGlbAlloc(sizeof(yosx), YOSX_TAG);
  x->enc = TRUE;
  x->bv = bv;
  x->nbv = 1;
  x->cnt = x->bv->len;
  x->ptr = x->bv->buf;
  x->idx = 0;
  x->hp = (ysmhp *) 0;
  x->cb = putbufcb;
  x->usrp = usrp;

  return x;
}


dvoid *yosxPutAlign( yosx *x, sword amt )
{
  size_t diff;
  dvoid *ptr;

  
  if( amt > 1 )
    for (diff = x->cnt - ysTruncVal(x->cnt, amt);
	 diff; diff--, x->ptr++, x->cnt--)
      *x->ptr = '\0';

  if (x->cnt < (ub4) amt)
    yosxAddBuf(x);

  ptr = (dvoid*)x->ptr;
  x->ptr += amt,
  x->cnt -= amt;

  return( ptr );
}


void yosxEncEnd(yosx *x, ysbv **bv, sword *nbv)
{
  boolean ok;

  ok = TRUE;
  if (!x->cb)
    {
      x->bv[x->idx].len -= x->cnt;
      *bv = x->bv;
      *nbv = x->nbv;

      ysmFree(x->hp, (dvoid *) x);
    }
  else
    {
      if (x->cnt != x->bv->len)
	{
	  x->bv->len -= x->cnt;
	  ok = (*x->cb)(x->bv, x->usrp);
	}

      ysmGlbFree((dvoid *) x);
    }

  if (!ok)
    yseThrow(YO_EX_ENCODEERROR);
}


void yosxPutSB8(yosx *x, sysb8 *val)
{
  sysb8 tmp;
  ub1 *ptr;

  sysb8srl(&tmp, val, 32);
  ptr = (ub1*)yosxPutAlign(x, 8);
  *(ub4*)ptr = (ub4)sysb8msk(&tmp);
  *(ub4*)(ptr+4) = (ub4)sysb8msk(val);
}


void yosxCopy(yosx *x, ub1 *buf, size_t len)
{
  size_t amt;

  while (len)
    {
      amt = min(len, x->cnt);
      if (x->enc)
	DISCARD memcpy(x->ptr, buf, amt);
      else
	DISCARD memcpy(buf, x->ptr, amt);

      x->cnt -= amt, x->ptr += amt, len -= amt, buf += amt;

      if (!x->cnt && len)
	{
	  if (x->enc)
	    yosxAddBuf(x);
	  else
	    {
	      yosxSkip(x, 0);
	      if (x->idx >= x->nbv && len)
		yseThrow(YO_EX_ENDOFDATA);
	    }
	}
    }
}


void yosxAlign(yosx *x, sword boundary)
{
  size_t diff, off;
  if( x->enc )
  {
    
    for (diff = x->cnt - ysTruncVal(x->cnt, boundary);
	 diff; diff--, x->ptr++, x->cnt--)
      *x->ptr = '\0';
  }
  else if (x->cnt)
  {
    off = x->bv[x->idx].len - x->cnt;
    diff = ysRoundVal(off, boundary) - off;
    x->ptr += diff, x->cnt -= diff;
  }

  

  if(x->enc && !x->cnt)
    yosxAddBuf(x);
}


STATICF void yosxAddBuf(yosx *x)
{
  boolean ok;

  
  while (x->cnt--)
    *(x->ptr++) = '\0';

  
  if (!x->cb)
    {
      x->nbv++;
      x->bv = (ysbv *) ysmRealloc(x->hp, (dvoid *) x->bv,
				  sizeof(ysbv) * x->nbv);
      x->idx++;
      x->cnt = x->bv[x->idx].len = YOSXBLKSZ;
      x->ptr = x->bv[x->idx].buf =
	(ub1 *) ysmAlloc(x->hp, YOSXBLKSZ, "yosx buf");
    }
  else
    {
      ok = (*x->cb)(x->bv, x->usrp);
      x->cnt = x->bv->len;
      if (ok)
	x->ptr = x->bv->buf;
      else
	yseThrow(YO_EX_ENCODEERROR);
    }
}


STATICF void yosxGetNSB8(yosx *x, sysb8 *val)
{
  ub1 *ptr = (ub1*)yosxGetAlign(x, 8);

  sysb8mak( val, *(sb4*)(ptr), *(ub4*)(ptr + 4) );
}


STATICF void yosxGetSSB8(yosx *x, sysb8 *val)
{
  ub1 *ptr = (ub1*)yosxGetAlign(x, 8);

  sysb8mak( val, (sb4)sysxGetSwap4(ptr), (ub4)sysxGetSwap4(ptr + 4) );
}

void yosxPutUB4AtPos(yosx *x, yosxPos *pos, ub4 val)
{
  dvoid *ptr;

  ptr = (dvoid*)(x->bv[ pos->idx ].buf + pos->off);
  *(ub4*)ptr = val;
}

void yosxPutNetUB4AtPos(yosx *x, yosxPos *pos, ub4 val)
{
  ub1 *ptr;

  ptr = x->bv[ pos->idx ].buf + pos->off;
  sysxPutB4( ptr, val );
}


void yosxPutNetUB2(yosx *x, ub2 val)
{ 
  ub1 *align = (ub1 *) yosxPutAlign((x),2);
  sysxPutB2(align, (val));
}

void yosxPutNetUB4(yosx *x, ub4 val)
{ 
  ub1 *align = (ub1 *) yosxPutAlign((x),4);
  sysxPutB4(align, (val));
}
