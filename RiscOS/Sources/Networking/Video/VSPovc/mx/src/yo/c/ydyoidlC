/* yo/ydyoidlC.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif

#ifndef YDYOIDL_IDL
#include <ydyoidl.h>
#endif

EXTC_START

static ysidDecl(ydyo_notUnique___id) = "IDL:ydyo/notUnique:1.0";

CONST ysid* ydyo_notUnique__getId(void)
{
  return (CONST ysid*)ydyo_notUnique___id;
}

static CONST_DATA yotk ydyo_notUnique__tc[] = 
  {0x00,0x00,0x00,0x16,0x00,0x00,0x00,'<',0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x17,'I','D','L',':','y','d','y','o','/','n',
  'o','t','U','n','i','q','u','e',':','1','.','0',0x00,0x00,0x00
  ,0x00,0x00,0x12,':',':','y','d','y','o',':',':','n','o','t',
  'U','n','i','q','u','e',0x00,0x00,0x00,0x00,0x00,0x00,0x00};

yotk* ydyo_notUnique__getTC(void)
{
  return (yotk*)ydyo_notUnique__tc;
}

static CONST_DATA yotk ydyo_activeInfo__tc[] = 
  {0x00,0x00,0x00,0x0f,0x00,0x00,0x01,0xe8,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x18,'I','D','L',':','y','d','y','o','/','a'
  ,'c','t','i','v','e','I','n','f','o',':','1','.','0',0x00,0x00
  ,0x00,0x00,0x13,':',':','y','d','y','o',':',':','a','c','t',
  'i','v','e','I','n','f','o',0x00,0x00,0x00,0x00,0x00,0x06,0x00
  ,0x00,0x00,0x15,'s','e','l','f','_','y','d','y','o','_','a',
  'c','t','i','v','e','I','n','f','o',0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x0e,0x00,0x00,0x00,'/',0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x14,'I','D','L',':','y','d','i','m','/','a','c','t'
  ,'i','v','e',':','1','.','0',0x00,0x00,0x00,0x00,0x0f,':',':'
  ,'y','d','i','m',':',':','a','c','t','i','v','e',0x00,0x00,0x00
  ,0x00,0x00,0x15,'i','n','t','f','_','y','d','y','o','_','a',
  'c','t','i','v','e','I','n','f','o',0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,'i',
  'm','p','l','_','y','d','y','o','_','a','c','t','i','v','e',
  'I','n','f','o',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x15,'y','o','r','t','_','y',
  'd','y','o','_','a','c','t','i','v','e','I','n','f','o',0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,'-',0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x12,'I','D','L',':','y','o','r'
  ,'t','/','p','r','o','c',':','1','.','0',0x00,0x00,0x00,0x00
  ,0x00,0x00,0x0d,':',':','y','o','r','t',':',':','p','r','o',
  'c',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,'y','o','r','t',
  'I','m','p','l','_','y','d','y','o','_','a','c','t','i','v',
  'e','I','n','f','o',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,
  0x00,0x00,0x00,'-',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,'I'
  ,'D','L',':','y','o','r','t','/','i','m','p','l',':','1','.'
  ,'0',0x00,0x00,0x00,0x00,0x00,0x00,0x0d,':',':','y','o','r',
  't',':',':','i','m','p','l',0x00,0x00,0x00,0x00,0x00,0x00,0x00
  ,0x1a,'i','m','p','l','F','l','a','g','s','_','y','d','y','o'
  ,'_','a','c','t','i','v','e','I','n','f','o',0x00,0x00,0x00,
  0x00,0x00,0x00,0x15,0x00,0x00,0x00,'<',0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x17,'I','D','L',':','y','o','r','t','/','i','m',
  'p','l','F','l','a','g','s',':','1','.','0',0x00,0x00,0x00,0x00
  ,0x00,0x12,':',':','y','o','r','t',':',':','i','m','p','l','F'
  ,'l','a','g','s',0x00,0x00,0x00,0x00,0x00,0x00,0x05};

yotk* ydyo_activeInfo__getTC(void)
{
  return (yotk*)ydyo_activeInfo__tc;
}

void ydyo_activeInfo__free( ydyo_activeInfo* val, ysmff ffunc)
{
  yotkFreeVal( YCTC_ydyo_activeInfo, (dvoid *)val, ffunc);
}

void ydyo_activeInfo__copy( ydyo_activeInfo* dest, ydyo_activeInfo* src, 
  ysmaf afunc)
{
  yotkCopyVal( YCTC_ydyo_activeInfo, (dvoid *)dest, (dvoid *)src, afunc);
}

static CONST_DATA yotk ydyo_activeInfoList__tc[] = 
  {0x00,0x00,0x00,0x15,0x00,0x00,0x02,'@',0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x1c,'I','D','L',':','y','d','y','o','/','a',
  'c','t','i','v','e','I','n','f','o','L','i','s','t',':','1',
  '.','0',0x00,0x00,0x00,0x00,0x17,':',':','y','d','y','o',':'
  ,':','a','c','t','i','v','e','I','n','f','o','L','i','s','t'
  ,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0x00,0x01,0xf8,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x01,0xe8,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x18,'I','D','L',':','y','d','y','o'
  ,'/','a','c','t','i','v','e','I','n','f','o',':','1','.','0'
  ,0x00,0x00,0x00,0x00,0x13,':',':','y','d','y','o',':',':','a'
  ,'c','t','i','v','e','I','n','f','o',0x00,0x00,0x00,0x00,0x00
  ,0x06,0x00,0x00,0x00,0x15,'s','e','l','f','_','y','d','y','o'
  ,'_','a','c','t','i','v','e','I','n','f','o',0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,'/',0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x14,'I','D','L',':','y','d','i','m','/','a'
  ,'c','t','i','v','e',':','1','.','0',0x00,0x00,0x00,0x00,0x0f
  ,':',':','y','d','i','m',':',':','a','c','t','i','v','e',0x00
  ,0x00,0x00,0x00,0x00,0x15,'i','n','t','f','_','y','d','y','o'
  ,'_','a','c','t','i','v','e','I','n','f','o',0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x15,'i','m','p','l','_','y','d','y','o','_','a','c','t','i'
  ,'v','e','I','n','f','o',0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,'y','o','r','t'
  ,'_','y','d','y','o','_','a','c','t','i','v','e','I','n','f'
  ,'o',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,
  '-',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,'I','D','L',':',
  'y','o','r','t','/','p','r','o','c',':','1','.','0',0x00,0x00
  ,0x00,0x00,0x00,0x00,0x0d,':',':','y','o','r','t',':',':','p'
  ,'r','o','c',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,'y','o'
  ,'r','t','I','m','p','l','_','y','d','y','o','_','a','c','t'
  ,'i','v','e','I','n','f','o',0x00,0x00,0x00,0x00,0x00,0x00,0x00
  ,0x0e,0x00,0x00,0x00,'-',0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x12,'I','D','L',':','y','o','r','t','/','i','m','p','l',':'
  ,'1','.','0',0x00,0x00,0x00,0x00,0x00,0x00,0x0d,':',':','y',
  'o','r','t',':',':','i','m','p','l',0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x1a,'i','m','p','l','F','l','a','g','s','_','y',
  'd','y','o','_','a','c','t','i','v','e','I','n','f','o',0x00
  ,0x00,0x00,0x00,0x00,0x00,0x15,0x00,0x00,0x00,'<',0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x17,'I','D','L',':','y','o','r','t'
  ,'/','i','m','p','l','F','l','a','g','s',':','1','.','0',0x00
  ,0x00,0x00,0x00,0x00,0x12,':',':','y','o','r','t',':',':','i'
  ,'m','p','l','F','l','a','g','s',0x00,0x00,0x00,0x00,0x00,0x00
  ,0x05,0x00,0x00,0x00,0x00};

yotk* ydyo_activeInfoList__getTC(void)
{
  return (yotk*)ydyo_activeInfoList__tc;
}

void ydyo_activeInfoList__free( ydyo_activeInfoList* val, ysmff ffunc)
{
  yotkFreeVal( YCTC_ydyo_activeInfoList, (dvoid *)val, ffunc);
}

void ydyo_activeInfoList__copy( ydyo_activeInfoList* dest, 
  ydyo_activeInfoList* src, ysmaf afunc)
{
  yotkCopyVal( YCTC_ydyo_activeInfoList, (dvoid *)dest, (dvoid *)src, afunc)
    ;
}

static ysidDecl(ydyo_notOwner___id) = "IDL:ydyo/notOwner:1.0";

CONST ysid* ydyo_notOwner__getId(void)
{
  return (CONST ysid*)ydyo_notOwner___id;
}

static CONST_DATA yotk ydyo_notOwner__tc[] = 
  {0x00,0x00,0x00,0x16,0x00,0x00,0x00,0x81,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x16,'I','D','L',':','y','d','y','o','/','n'
  ,'o','t','O','w','n','e','r',':','1','.','0',0x00,0x00,0x00,
  0x00,0x00,0x00,0x11,':',':','y','d','y','o',':',':','n','o',
  't','O','w','n','e','r',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01
  ,0x00,0x00,0x00,0x0a,'r','e','a','l','O','w','n','e','r',0x00
  ,0x00,0x00,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,'-',0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x12,'I','D','L',':','y','o','r','t'
  ,'/','p','r','o','c',':','1','.','0',0x00,0x00,0x00,0x00,0x00
  ,0x00,0x0d,':',':','y','o','r','t',':',':','p','r','o','c',0x00
  };

yotk* ydyo_notOwner__getTC(void)
{
  return (yotk*)ydyo_notOwner__tc;
}

void ydyo_notOwner__free( ydyo_notOwner* val, ysmff ffunc)
{
  yotkFreeVal( YCTC_ydyo_notOwner, (dvoid *)val, ffunc);
}

void ydyo_notOwner__copy( ydyo_notOwner* dest, ydyo_notOwner* src, ysmaf 
  afunc)
{
  yotkCopyVal( YCTC_ydyo_notOwner, (dvoid *)dest, (dvoid *)src, afunc);
}


static ysidDecl(ydyo_imr___id) = "IDL:ydyo/imr:1.0";

CONST ysid* ydyo_imr__getId(void)
{
  return (CONST ysid*)ydyo_imr___id;
}

static CONST_DATA yotk ydyo_imr__tc[] = 
  {0x00,0x00,0x00,0x0e,0x00,0x00,0x00,',',0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x11,'I','D','L',':','y','d','y','o','/','i',
  'm','r',':','1','.','0',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c
  ,':',':','y','d','y','o',':',':','i','m','r',0x00};

yotk* ydyo_imr__getTC(void)
{
  return (yotk*)ydyo_imr__tc;
}


void ydyo_imr__free( ydyo_imr* val, ysmff ffunc)
{
  yotkFreeVal( YCTC_ydyo_imr, (dvoid *)val, ffunc);
}

void ydyo_imr__copy( ydyo_imr* dest, ydyo_imr* src, ysmaf afunc)
{
  yotkCopyVal( YCTC_ydyo_imr, (dvoid *)dest, (dvoid *)src, afunc);
}


yopar* ydyo_imr_addActiveGlobal__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_addActiveGlobal");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_addActiveGlobal", (ub4)2);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_IN;
    _pars[0].tk = (yotk*)YCTC_yort_procInfo;
    _pars[1].mode = YOMODE_IN;
    _pars[1].tk = (yotk*)YCTC_ydyo_activeInfoList;
    _pars[2].mode = YOMODE_INVALID;
    _pars[2].tk = (yotk*)yoTcNull;
    _pars[2].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void ydyo_imr_addActiveGlobal( ydyo_imr or, yoenv* ev, yort_procInfo* pinfo,
   ydyo_activeInfoList* ailist)
{
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)0, (dvoid *)_impl, ydyo_imr__id);
      (*(void (*)( ydyo_imr, yoenv*, yort_procInfo*, ydyo_activeInfoList*))
        _f)(or, ev, pinfo, ailist);
    }
    else
      (*_impl->addActiveGlobal)(or, ev, pinfo, ailist);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_addActiveGlobal_nw( or, ev, pinfo, ailist, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)0);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void ydyo_imr_addActiveGlobal_nw( ydyo_imr or, yoenv* ev, yort_procInfo* 
  pinfo, ydyo_activeInfoList* ailist, ysevt* _sem)
{
  dvoid * _parvec[2];

  _parvec[0] = (dvoid *) pinfo;
  _parvec[1] = (dvoid *) ailist;
  yoSendReq( (dvoid *)or, ev, "addActiveGlobal", TRUE, _sem, (sword)2, 
    ydyo_imr_addActiveGlobal_pars, _parvec);
}

yopar* ydyo_imr_destroyActiveGlobal__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_destroyActiveGlobal");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_destroyActiveGlobal", (ub4)1);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_IN;
    _pars[0].tk = (yotk*)YCTC_ydyo_activeInfoList;
    _pars[1].mode = YOMODE_INVALID;
    _pars[1].tk = (yotk*)yoTcNull;
    _pars[1].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void ydyo_imr_destroyActiveGlobal( ydyo_imr or, yoenv* ev, 
  ydyo_activeInfoList* ailist)
{
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)1, (dvoid *)_impl, ydyo_imr__id);
      (*(void (*)( ydyo_imr, yoenv*, ydyo_activeInfoList*))_f)(or, ev, 
        ailist);
    }
    else
      (*_impl->destroyActiveGlobal)(or, ev, ailist);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_destroyActiveGlobal_nw( or, ev, ailist, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)0);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void ydyo_imr_destroyActiveGlobal_nw( ydyo_imr or, yoenv* ev, 
  ydyo_activeInfoList* ailist, ysevt* _sem)
{
  dvoid * _parvec[1];

  _parvec[0] = (dvoid *) ailist;
  yoSendReq( (dvoid *)or, ev, "destroyActiveGlobal", TRUE, _sem, (sword)1, 
    ydyo_imr_destroyActiveGlobal_pars, _parvec);
}

yopar* ydyo_imr_destroyYortGlobal__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_destroyYortGlobal");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_destroyYortGlobal", (ub4)1);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_IN;
    _pars[0].tk = (yotk*)YCTC_yort_proc;
    _pars[1].mode = YOMODE_INVALID;
    _pars[1].tk = (yotk*)yoTcNull;
    _pars[1].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void ydyo_imr_destroyYortGlobal( ydyo_imr or, yoenv* ev, yort_proc y)
{
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)2, (dvoid *)_impl, ydyo_imr__id);
      (*(void (*)( ydyo_imr, yoenv*, yort_proc))_f)(or, ev, y);
    }
    else
      (*_impl->destroyYortGlobal)(or, ev, y);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_destroyYortGlobal_nw( or, ev, y, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)0);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void ydyo_imr_destroyYortGlobal_nw( ydyo_imr or, yoenv* ev, yort_proc y, 
  ysevt* _sem)
{
  dvoid * _parvec[1];

  _parvec[0] = (dvoid *)&y;
  yoSendReq( (dvoid *)or, ev, "destroyYortGlobal", TRUE, _sem, (sword)1, 
    ydyo_imr_destroyYortGlobal_pars, _parvec);
}

yopar* ydyo_imr_exists__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_exists");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_exists", (ub4)3);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_RETURN;
    _pars[0].tk = (yotk*)yoTcBoolean;
    _pars[1].mode = YOMODE_IN;
    _pars[1].tk = (yotk*)yoTcString;
    _pars[2].mode = YOMODE_IN;
    _pars[2].tk = (yotk*)yoTcString;
    _pars[3].mode = YOMODE_INVALID;
    _pars[3].tk = (yotk*)yoTcNull;
    _pars[3].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

boolean ydyo_imr_exists( ydyo_imr or, yoenv* ev, char* intf, char* impl)
{
  boolean _result;
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)3, (dvoid *)_impl, ydyo_imr__id);
      _result = (*(boolean (*)( ydyo_imr, yoenv*, char*, char*))_f)(or, ev, 
        intf, impl);
    }
    else
      _result = (*_impl->exists)(or, ev, intf, impl);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_exists_nw( or, ev, intf, impl, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)&_result);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
  return _result;
}

void ydyo_imr_exists_nw( ydyo_imr or, yoenv* ev, char* intf, char* impl, 
  ysevt* _sem)
{
  dvoid * _parvec[2];

  _parvec[0] = (dvoid *)&intf;
  _parvec[1] = (dvoid *)&impl;
  yoSendReq( (dvoid *)or, ev, "exists", TRUE, _sem, (sword)2, 
    ydyo_imr_exists_pars, _parvec);
}

yopar* ydyo_imr_stake__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_stake");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_stake", (ub4)2);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_IN;
    _pars[0].tk = (yotk*)YCTC_yort_claim;
    _pars[1].mode = YOMODE_IN;
    _pars[1].tk = (yotk*)YCTC_yoevt;
    _pars[2].mode = YOMODE_INVALID;
    _pars[2].tk = (yotk*)yoTcNull;
    _pars[2].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void ydyo_imr_stake( ydyo_imr or, yoenv* ev, yort_claim* what, yoevt 
  replyTo)
{
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)4, (dvoid *)_impl, ydyo_imr__id);
      (*(void (*)( ydyo_imr, yoenv*, yort_claim*, yoevt))_f)(or, ev, what, 
        replyTo);
    }
    else
      (*_impl->stake)(or, ev, what, replyTo);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_stake_nw( or, ev, what, replyTo, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)0);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void ydyo_imr_stake_nw( ydyo_imr or, yoenv* ev, yort_claim* what, yoevt 
  replyTo, ysevt* _sem)
{
  dvoid * _parvec[2];

  _parvec[0] = (dvoid *) what;
  _parvec[1] = (dvoid *)&replyTo;
  yoSendReq( (dvoid *)or, ev, "stake", TRUE, _sem, (sword)2, 
    ydyo_imr_stake_pars, _parvec);
}

yopar* ydyo_imr_abandon__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_abandon");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_abandon", (ub4)2);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_IN;
    _pars[0].tk = (yotk*)YCTC_yort_claim;
    _pars[1].mode = YOMODE_EXCEPT;
    _pars[1].tk = (yotk*)YCTC_ydyo_notOwner;
    _pars[2].mode = YOMODE_INVALID;
    _pars[2].tk = (yotk*)yoTcNull;
    _pars[2].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

void ydyo_imr_abandon( ydyo_imr or, yoenv* ev, yort_claim* what)
{
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)5, (dvoid *)_impl, ydyo_imr__id);
      (*(void (*)( ydyo_imr, yoenv*, yort_claim*))_f)(or, ev, what);
    }
    else
      (*_impl->abandon)(or, ev, what);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_abandon_nw( or, ev, what, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)0);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
}

void ydyo_imr_abandon_nw( ydyo_imr or, yoenv* ev, yort_claim* what, ysevt* 
  _sem)
{
  dvoid * _parvec[1];

  _parvec[0] = (dvoid *) what;
  yoSendReq( (dvoid *)or, ev, "abandon", TRUE, _sem, (sword)1, 
    ydyo_imr_abandon_pars, _parvec);
}

yopar* ydyo_imr_listProperties__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_listProperties");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_listProperties", (ub4)2);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_RETURN;
    _pars[0].tk = (yotk*)YCTC_yostd_stringList;
    _pars[1].mode = YOMODE_IN;
    _pars[1].tk = (yotk*)yoTcString;
    _pars[2].mode = YOMODE_INVALID;
    _pars[2].tk = (yotk*)yoTcNull;
    _pars[2].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

yostd_stringList ydyo_imr_listProperties( ydyo_imr or, yoenv* ev, char* 
  regexp)
{
  yostd_stringList _result;
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)6, (dvoid *)_impl, ydyo_imr__id);
      _result = (*(yostd_stringList (*)( ydyo_imr, yoenv*, char*))_f)(or, 
        ev, regexp);
    }
    else
      _result = (*_impl->listProperties)(or, ev, regexp);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_listProperties_nw( or, ev, regexp, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)&_result);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
  return _result;
}

void ydyo_imr_listProperties_nw( ydyo_imr or, yoenv* ev, char* regexp, 
  ysevt* _sem)
{
  dvoid * _parvec[1];

  _parvec[0] = (dvoid *)&regexp;
  yoSendReq( (dvoid *)or, ev, "listProperties", TRUE, _sem, (sword)1, 
    ydyo_imr_listProperties_pars, _parvec);
}

yopar* ydyo_imr_propertyResolve__getPars(void)
{
  yopar* _pars = (yopar*)0;

  _pars = yoParsGet( "ydyo_imr_propertyResolve");
  if ( _pars == (yopar*)0 )
  {
    yopard* _desc = yoPardCreate( "ydyo_imr_propertyResolve", (ub4)3);
    _pars = _desc->pars;
    _pars[0].mode = YOMODE_RETURN;
    _pars[0].tk = (yotk*)yoTcObject;
    _pars[1].mode = YOMODE_IN;
    _pars[1].tk = (yotk*)yoTcString;
    _pars[2].mode = YOMODE_EXCEPT;
    _pars[2].tk = (yotk*)YCTC_ydyo_notUnique;
    _pars[3].mode = YOMODE_INVALID;
    _pars[3].tk = (yotk*)yoTcNull;
    _pars[3].sz = (ub4)0;
    yoParsSize( _pars);
    yoParsSet( _desc);
  }
  return _pars;
}

CORBA_Object ydyo_imr_propertyResolve( ydyo_imr or, yoenv* ev, char* 
  property)
{
  CORBA_Object _result;
  ysevt* noreg _sem = (ysevt*)0;
  struct ydyo_imr__tyimpl* _impl;
  yowiden _widen = (yowiden)0;

  NOREG(_sem);
  _impl = (struct ydyo_imr__tyimpl*) yoLocalObj( (CORBA_Object)or, (
    yowiden*)&_widen);
  if ( _impl )
  {
    if ( _widen )
    {
      yogfp _f = (*_widen)( (ub4)7, (dvoid *)_impl, ydyo_imr__id);
      _result = (*(CORBA_Object (*)( ydyo_imr, yoenv*, char*))_f)(or, ev, 
        property);
    }
    else
      _result = (*_impl->propertyResolve)(or, ev, property);
  }
  else
  {
    yoFilterRunEx((dvoid *)or, ev, YOFLTR_CSND, (CONST  char*)0, (dvoid *)0)
      ;
    yseTry
    {
      _sem = ysSemCreate((dvoid *)0);
      ydyo_imr_propertyResolve_nw( or, ev, property, (ysevt*)_sem);
    }
    yseCatchAll
    {
      CONST ysid* _exid;
      dvoid * _exbody;

      _exid = yseExid;
      _exbody = yseExobj;
      yseTry
      {
        yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, _exid, _exbody);
      }
      yseFinally
      {
        if ( _sem )
          ysSemDestroy( (ysevt*)_sem);
      }
      yseEnd
      yseRethrow;
    }
    yseEnd
    yseTry
    {
      ysSemSynch( (ysevt*)_sem, (dvoid *)&_result);
    }
    yseFinally
      yoFilterRunEx((dvoid *)or, ev, YOFLTR_CRCV, yseExid, yseExobj);
    yseEnd
  }
  return _result;
}

void ydyo_imr_propertyResolve_nw( ydyo_imr or, yoenv* ev, char* property, 
  ysevt* _sem)
{
  dvoid * _parvec[1];

  _parvec[0] = (dvoid *)&property;
  yoSendReq( (dvoid *)or, ev, "propertyResolve", TRUE, _sem, (sword)1, 
    ydyo_imr_propertyResolve_pars, _parvec);
}



EXTC_END
