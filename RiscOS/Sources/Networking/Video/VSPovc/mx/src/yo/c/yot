/* yo/yot.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/










#ifndef SYSI_ORACLE
#include <sysi.h>
#endif

#ifndef SMNI_ORACLE
#include <smni.h>
#endif

#ifndef YS_ORACLE
#include <ys.h>
#endif

#ifndef YSL_ORACLE
#include <ysl.h>
#endif

#ifndef MN_ORACLE
#include <mn.h>
#endif

#ifndef MNI_ORACLE
#include <mni.h>
#endif

#ifndef YOT_ORACLE
#include <yot.h>
#endif

#ifndef YSE_ORACLE
#include <yse.h>
#endif

#ifndef YSV_ORACLE
#include <ysv.h>
#endif




externdef ysidDecl(YT_EX_WOULDBLOCK) = "yt::wouldblock";
externdef ysidDecl(YT_EX_FAILCONN) = "yt::failconn";
externdef ysidDecl(YT_EX_BADADDR) = "yt::badaddr";
externdef ysidDecl(YT_EX_NOTCONN) = "yt::notconn";
externdef ysidDecl(YT_EX_BROKEN) = "yt::broken";
externdef ysidDecl(YT_EX_DISCONN) = "yt::disconn";
externdef ysidDecl(YT_EX_UNKNOWN) = "yt::unknown";              
externdef ysidDecl(YT_EX_UNIMPL) = "yt::unimplemented";

externdef ysmtagDecl(yotTagAddr) = "yota";


STATICF void yotEvtCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                         size_t argsz);
STATICF void yotHandler( dvoid *arg, sb4 val );





void ytInit(void)
{
  smniInit((dvoid *)0,(mnLogger)yslError);
}

void ytTerm(void)
{
  mnTerm();
}


yotp *yotOpen(sword protocol)
{
  return( (yotp *)mnOpen( (ub4)protocol ) );
}


void yotClose(yotp *port)
{
  
  DISCARD mnClose( (mnp *)port );
}


void yotFlush(yotp *port, ysevt *evt)
{
  
}



void yotSetOptions(yotp *port, ub4 options)
{
  
  mnSetOptions( (mnp *)port, options );
}

ub4  yotGetOptions(yotp *port)
{
  return( mnGetOptions( (mnp *)port ) );
}


void yotBind(yotp *port, ub2 name)
{
  mna self;

  mnGetAddr( (mnp *)port, &self );
  mnaSetPort( &self, name );
  mnBind( (mnp *)port, &self );
}


yota *yotGetAddr(yotp *port)
{
  mna	*self = ysmGlbAlloc( sizeof(*self), yotTagAddr);
  mnGetAddr( (mnp *)port, self );
  return( (yota *)self );
}

yota *yotGetPeer(yotp *port)
{
  mna	*self = ysmGlbAlloc( sizeof(*self), yotTagAddr);
  DISCARD mnGetPeer( (mnp *)port, self );
  return( (yota *)self );
}


void yotListen(yotp *port)
{
  
  DISCARD mnListen( (mnp*)port, (ub4)0, (mnHandler)0, (dvoid *)0);
}


yotp *yotAccept(yotp *port)
{
  return( (mnp*)mnAccept( (mnp *)port ) );
}


void yotConnect(yotp *port, yota *addr)
{
  ysid *exid;

  exid = yotMnStsToExid(mnConnect((mnp *)port, (mna *)addr));
  if(exid)
    yseThrow(exid);
}


sb4 yotRead(yotp *port, ub1 *buf, size_t max, boolean fill, ysevt *evt)
{
  sb4	rv;
  ysid *exid;
  mnHandler h = (mnHandler)0;
  dvoid *arg = (dvoid *)0;
  ysevt **ep = (ysevt **)0;
  
  if( evt )
  {

    h = yotHandler;
    ep = (ysevt **) (arg = ysmGlbAlloc(sizeof(ysevt *),"ysevt *"));
    *ep = evt;
    DISCARD ysEvtAttach(evt,ysEvtSimple(yotEvtCancel,(dvoid *)ep));
  }
  rv = mnRead( (mnp*)port, buf, max, fill, (ub4)0, h, arg );

#ifdef NEVER  
  if( rv == 0 && evt )
    yseThrow( YOT_EX_WOULDBLOCK );
  else if( rv < 0 )
    yseThrow( YOT_EX_BROKEN );
#endif

  exid = yotMnStsToExid(rv);
  if(exid)
  {
    if(ep) ysmGlbFree((dvoid *)ep);
    yseThrow(exid);
  }

  return( rv );
}

sb4 yotReadV(yotp *port, ysbv *bv, sword nbv, boolean fill, ysevt *evt)
{
  sword i;
  sb4 rv, xrv;

  
  yseThrow(YT_EX_UNIMPL);

  for( rv = i = 0; i < nbv && rv >= 0 ; i++ )
    if( (xrv = yotRead( port, bv[i].buf, bv[i].len, fill, (ysevt*)0 ) ) < 0 )
      rv = xrv;
    else
      rv += xrv;

  if( evt )
    ysTrigger( evt, (ysid*)0, (dvoid *)0, (size_t)0 );

  return( 0 );
}


sb4 yotWrite(yotp *port, ub1 *buf, size_t len)
{
  sb4 sts;
  ysid *exid;

  sts = mnWrite( (mnp*)port,buf,len);
  exid = yotMnStsToExid(sts);
  if(exid)
    yseThrow(exid);
  return sts;
}

sb4 yotWriteV(yotp *port, ysbv *bv, sword nbv)
{
  sword i;
  sb4 rv, xrv;

  
  yseThrow(YT_EX_UNIMPL);

  for( rv = i = 0; i < nbv && rv >= 0 ; i++ )
    if( (xrv = yotWrite( port, bv[i].buf, bv[i].len ) ) < 0 )
      rv = xrv;
    else
      rv += xrv;

  return( rv );
}


sb4 yotSend(yotp *port, yota *to, ub1 *buf, size_t len, ysevt *evt)
{
  sb4	rv;
  ysid *exid;
  mnHandler h = (mnHandler)0;
  dvoid *arg = (dvoid *)0;
  ysevt **ep = (ysevt **)0;
  
  if( evt )
  {
    h = yotHandler;
    ep = (ysevt **) (arg = ysmGlbAlloc(sizeof(ysevt *),"ysevt *"));
    *ep = evt;
    DISCARD ysEvtAttach(evt,ysEvtSimple(yotEvtCancel,(dvoid *)ep));
  }
  rv = mnSend( (mnp*)port, (mna*)to, buf, len, h, arg );

#ifdef NEVER  
  if( rv == 0 && evt )
    yseThrow( YOT_EX_WOULDBLOCK );
  else if( rv < 0 )
    yseThrow( YOT_EX_BROKEN );
#endif

  exid = yotMnStsToExid(rv);
  if(exid)
  {
    if(ep) ysmGlbFree((dvoid *)ep);
    yseThrow(exid);
  }

  return( rv );
}


sb4 yotSendV(yotp *port, yota *to, ysbv *bv, sword nbv, ysevt *evt)
{
  ysid *exid;
  sb4	rv;
  mnHandler h = (mnHandler)0;
  dvoid *arg = (dvoid *)0;
  ysevt **ep = (ysevt **)0;

  if( evt )
  {
    h = yotHandler;
    ep = (ysevt **) (arg = ysmGlbAlloc(sizeof(ysevt *),"ysevt *"));
    *ep = evt;
    DISCARD ysEvtAttach(evt,ysEvtSimple(yotEvtCancel,(dvoid *)ep));
  }
  rv = mnSendV( (mnp*)port, (mna*)to, (mnbv*)bv, (ub4)nbv, h, arg );

#ifdef NEVER  
  if( rv == 0 && evt )
    yseThrow( YOT_EX_WOULDBLOCK );
  else if( rv < 0 )
    yseThrow( YOT_EX_BROKEN );
#endif

  exid = yotMnStsToExid(rv);
  if(exid)
  {
    if(ep) ysmGlbFree((dvoid *)ep);
    yseThrow(exid);
  }

  return( rv );
}



sb4 yotRecv(yotp *port, yota **from, ub1 *buf, size_t max, ysevt *evt)
{
  sb4	rv;
  ysid *exid;
  mnHandler h = (mnHandler)0;
  dvoid *arg = (dvoid *)0;
  ysevt **ep = (ysevt **)0;
  
  if( evt )
  {
    h = yotHandler;
    ep = (ysevt **) (arg = ysmGlbAlloc(sizeof(ysevt *),"ysevt *"));
    *ep = evt;
    DISCARD ysEvtAttach(evt,ysEvtSimple(yotEvtCancel,(dvoid *)ep));
  }
  rv = mnRecv( (mnp*)port, (mna*)from, buf, max, (ub4)0, h, arg );

#ifdef NEVER  
  if( rv == 0 && evt )
    yseThrow( YOT_EX_WOULDBLOCK );
  else if( rv < 0 )
    yseThrow( YOT_EX_BROKEN );
#endif

  exid = yotMnStsToExid(rv);
  if(exid)
  {
    if(ep) ysmGlbFree((dvoid *)ep);
    yseThrow(exid);
  }

  return( rv );
}

sb4 yotRecvV(yotp *port, yota **from, ysbv *bv, sword nbv, ysevt *evt)
{
  sb4	rv;
  ysid *exid;
  mnHandler h = (mnHandler)0;
  dvoid *arg = (dvoid *)0;
  ysevt **ep = (ysevt **)0;

  if( evt )
  {
    h = yotHandler;
    ep = (ysevt **) (arg = ysmGlbAlloc(sizeof(ysevt *),"ysevt *"));
    *ep = evt;
    DISCARD ysEvtAttach(evt,ysEvtSimple(yotEvtCancel,(dvoid *)ep));
  }
  *from = (yota *) ysmGlbAlloc(sizeof(mna),yotTagAddr);
  rv = mnRecvV( (mnp*)port, (mna*)*from, (mnbv*)bv, (ub4)nbv, (ub4)0, h, arg );

#ifdef NEVER  
  if( rv == 0 && evt )
    yseThrow( YOT_EX_WOULDBLOCK );
  else if( rv < 0 )
    yseThrow( YOT_EX_BROKEN );
#endif

  exid = yotMnStsToExid(rv);
  if(exid)
  {
    if(ep) ysmGlbFree((dvoid *)ep);
    yseThrow(exid);
  }

  return( rv );
}


sb4 yotTest(yotp *port, sysb8 *timeout, ysevt *evt)
{
  sb4 sts;
  ysid *exid;
  ub4 msec;
  sysb8 hi;
  mnHandler hdlr;
  dvoid *usrp;
  ysevt **ep = (ysevt **)0;

  if(timeout == YSTM_POLLING)
    return mnRecvTest((mnp *)port,(mna *)0);
  if(timeout == YSTM_INFINITE)
    msec = 0;
  else
  {
    msec = sysb8msk(timeout);
    sysb8srl(&hi,timeout,32);
    if(sysb8msk(&hi))
      msec = UB4MAXVAL;
  }

  if(evt)
  {
    hdlr = yotHandler;
    ep = (ysevt **) (usrp = ysmGlbAlloc(sizeof(ysevt *),"ysevt *"));
    *ep = evt;
    DISCARD ysEvtAttach(evt,ysEvtSimple(yotEvtCancel,(dvoid *)ep));
  }
  else
  {
    hdlr = (mnHandler) 0;
    usrp = (dvoid *) 0;
  }

  sts = mnRecvWait((mnp *)port,(mna *)0, msec, hdlr, usrp);

  exid = yotMnStsToExid(sts);
  if(exid)
  {
    if(ep) ysmGlbFree((dvoid *)ep);
    yseThrow(exid);
  }

  return sts;
}


sword yotAddrEq(yota *a1, yota *a2)
{
  return mnaEq((mna *)a1,(mna *)a2);
}

ub2 yotGetAddrPort(yota *addr)
{
  return mnaPortNum(addr);
}

void yotSetAddrPort(yota *addr, ub2 port)
{
  mnaSetPort(addr, port);
}

char *yotAddrToStr(yota *addr, char *str, size_t max)
{
  mnAtos((mna *)addr, str, max);
  return str;
}

yota *yotStrToAddr(CONST char *str)
{
  mna *addr;
  sb4 sts;

  addr = (mna *) ysmGlbAlloc(sizeof(mna), yotTagAddr);
  sts = mnAddr(addr,str);
  if(sts < 0)
  {
    ysmGlbFree((dvoid *)addr);
    addr = (mna *) 0;
  }
  return (yota *)addr;
}

yota *yotAddrDup(yota *addr)
{
  mna *dup;

  dup = (mna *) ysmGlbAlloc(sizeof(mna), yotTagAddr);
  mnaCopy(dup,(mna *)addr);

  return (yota *)dup;
}

void yotAddrFree(yota *addr)
{
  ysmCheck(addr,yotTagAddr);

  ysmGlbFree((dvoid *)addr);
}

ub4 yotHashAddr(yota *addr)
{
  sword i;
  ub4 hash = 0;
  ub1 *bits = ((mna *)addr)->bits;

  for(i = 0; i < sizeof(((mna *)addr)->bits); i++)
    hash += *bits++;

  return hash;
}

void yotxPutAddr(yosx *x, yota *addr)
{
  if( addr )
  {
    yosxPutUB4(x, sizeof(mna));
    yosxCopy(x,(dvoid *)addr,sizeof(mna));
  }
  else
    yosxPutUB4( x, 0 );
}

yota *yotxGetAddr(yosx *x)
{
  mna *addr;
  ub4 len;

  if(len = yosxGetUB4(x))
  {
    addr = (mna *)ysmGlbAlloc(sizeof(mna),yotTagAddr);
    yosxCopy(x,(dvoid *)addr,sizeof(mna));
  }
  else
    addr = (yota*)0;

  return addr;
}

ysid *yotMnStsToExid(sb4 val)
{
  ysid *exid;

  switch(val)
  {
  case MNERR_WOULDBLOCK:
    exid = (ysid *)YT_EX_WOULDBLOCK;
    break;
  case MNERR_TIMEOUT:
    exid = (ysid *)YS_EX_TIMEOUT;
    break;
  case MNERR_BROKEN:
    exid = (ysid *)YT_EX_BROKEN;
    break;
  case MNERR_BADADDR:
    exid = (ysid *)YT_EX_BADADDR;
    break;
  case MNERR_ALREADY:
    exid = (ysid *)YT_EX_FAILCONN;
    break;
  case MNERR_NOTCONN:
    exid = (ysid *)YT_EX_NOTCONN;
    break;
  case MNERR_DISCONN:
    exid = (ysid *)YT_EX_DISCONN;
    break;
  default:
    if(val < 0)
      exid = (ysid *)YT_EX_UNKNOWN;
    else
      exid = (ysid *) 0;
    break;
  }
  return exid;
}


STATICF void yotEvtCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                         size_t argsz)
{
  *(ysevt **)usrp = (ysevt *) 0;
}


STATICF void yotHandler( dvoid *arg, sb4 val )
{
  ysid *exid;

  exid = yotMnStsToExid(val);

  if(*(ysevt **)arg)
    ysTrigger(*(ysevt**)arg, exid, (dvoid *)&val, sizeof(val) );
  ysmGlbFree((dvoid *)arg);
}
