/* yo/yotk.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/








#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YOTK_ORACLE
#include <yotk.h>
#endif
#ifndef YOTKI_ORACLE
#include <yotki.h>
#endif




externdef ysidDecl(YO_EX_BADCODE) = "yo::badcode";
externdef ysidDecl(YO_EX_BOUNDS) = "IDL:omg.org/CORBA/TypeCode/Bounds:1.0";
externdef ysidDecl(YO_EX_BOUNDSMISMATCH) = "yo::boundsmismatch";

static CONST_DATA yotk yoTcNull__TC[] = { 0x00,0x00,0x00,0x00 };
static CONST_DATA yotk yoTcVoid__TC[] = { 0x00,0x00,0x00,0x01 };
static CONST_DATA yotk yoTcShort__TC[] = { 0x00,0x00,0x00,0x02 };

static CONST_DATA yotk yoTcUshort__TC[] = { 0x00,0x00,0x00,0x04 };

static CONST_DATA yotk yoTcFloat__TC[] = { 0x00,0x00,0x00,0x06 };
static CONST_DATA yotk yoTcDouble__TC[] = { 0x00,0x00,0x00,0x07 };
static CONST_DATA yotk yoTcBoolean__TC[] = { 0x00,0x00,0x00,0x08 };
static CONST_DATA yotk yoTcChar__TC[] = { 0x00,0x00,0x00,0x09 };
static CONST_DATA yotk yoTcOctet__TC[] = { 0x00,0x00,0x00,0x0a };
static CONST_DATA yotk yoTcAny__TC[] = { 0x00,0x00,0x00,0x0b };
static CONST_DATA yotk yoTcTypeCode__TC[] = { 0x00,0x00,0x00,0x0c };
static CONST_DATA yotk yoTcPrincipal__TC[] = { 0x00,0x00,0x00,0x0d };
static CONST_DATA yotk yoTcObject__TC[] =
 { 0x00,0x00,0x00,0x0e, 0x00,0x00,0x00,0x34, 0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x15, 'I', 'D', 'L', ':',  'C', 'O', 'R', 'B',
   'A', '/', 'O', 'b',  'j', 'e', 'c', 't',  ':', '1', '.', '0',
   0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x10, ':', ':', 'C', 'O',
   'R', 'B', 'A', ':',  ':', 'O', 'b', 'j',  'e', 'c', 't', 0x00 };








typedef struct yotktDesc yotktDesc;
struct yotktDesc
{
  size_t size;
  size_t align;
  size_t salign;
};

typedef struct { ub1 yotktsb2x; sb2 yotktsb2f; } yotktsb2;
typedef struct { ub1 yotktsb4x; sb4 yotktsb4f; } yotktsb4;
typedef struct { ub1 yotktub2x; ub2 yotktub2f; } yotktub2;
typedef struct { ub1 yotktub4x; ub4 yotktub4f; } yotktub4;
typedef struct { ub1 yotktfloatx; float yotktfloatf; } yotktfloat;
typedef struct { ub1 yotktdoublex; double yotktdoublef; } yotktdouble;
typedef struct { ub1 yotktboolx; boolean yotktboolf; } yotktbool;
typedef struct { ub1 yotktcharx; char yotktcharf; } yotktchar;
typedef struct { ub1 yotktub1x; ub1 yotktub1f; } yotktub1;
typedef struct { ub1 yotktyoanyx; yoany yotktyoanyf; } yotktyoany;
typedef struct { ub1 yotktyotkx; yotk *yotktyotkf; } yotktyotk;
typedef struct { ub1 yotktseqx; YCIDL_sequence_ub1 yotktseqf; } yotktseq;
typedef struct { ub1 yotktptrx; dvoid *yotktptrf; } yotktptr;
typedef struct { ub1 yotktstringx; char *yotktstringf; } yotktstring;
typedef struct { ub1 yotktsysb8x; sysb8 yotktsysb8f; } yotktsysb8;

typedef struct { ub1 yotktsb2sx; yotktsb2 yotktsb2sf; } yotktsb2s;
typedef struct { ub1 yotktsb4sx; yotktsb4 yotktsb4sf; } yotktsb4s;
typedef struct { ub1 yotktub2sx; yotktub2 yotktub2sf; } yotktub2s;
typedef struct { ub1 yotktub4sx; yotktub4 yotktub4sf; } yotktub4s;
typedef struct { ub1 yotktfloatsx; yotktfloat yotktfloatsf; } yotktfloats;
typedef struct { ub1 yotktdoublesx; yotktdouble yotktdoublesf; } yotktdoubles;
typedef struct { ub1 yotktboolsx; yotktbool yotktboolsf; } yotktbools;
typedef struct { ub1 yotktcharsx; yotktchar yotktcharsf; } yotktchars;
typedef struct { ub1 yotktub1sx; yotktub1 yotktub1sf; } yotktub1s;
typedef struct { ub1 yotktyoanysx; yotktyoany yotktyoanysf; } yotktyoanys;
typedef struct { ub1 yotktyotksx; yotktyotk yotktyotksf; } yotktyotks;
typedef struct { ub1 yotktseqsx; yotktseq yotktseqsf; } yotktseqs;
typedef struct { ub1 yotktptrsx; yotktptr yotktptrsf; } yotktptrs;
typedef struct { ub1 yotktstringsx; yotktstring yotktstringsf; } yotktstrings;
typedef struct { ub1 yotktsysb8sx; yotktsysb8 yotktsysb8sf; } yotktsysb8s;

#define yotkt3(a, b, c) { (a), (b), (c) }
#define yotkt5(a, b, c, d, e) { sizeof(a), offsetof(b, c), offsetof(d, e) }

static CONST_DATA yotktDesc yotktTable[] =
{
  yotkt3(0, 1, 1),                                                
  yotkt3(0, 1, 1),                                                
  yotkt5(sb2, yotktsb2, yotktsb2f, yotktsb2s, yotktsb2sf),       
  yotkt5(sb4, yotktsb4, yotktsb4f, yotktsb4s, yotktsb4sf),        
  yotkt5(ub2, yotktub2, yotktub2f, yotktub2s, yotktub2sf),       
  yotkt5(ub4, yotktub4, yotktub4f, yotktub4s, yotktub4sf),       
  
  yotkt5(float, yotktfloat, yotktfloatf, yotktfloats, yotktfloatsf),
  
  yotkt5(double, yotktdouble, yotktdoublef, yotktdoubles, yotktdoublesf),
  
  yotkt5(boolean, yotktbool, yotktboolf, yotktbools, yotktboolsf),
  yotkt5(char, yotktchar, yotktcharf, yotktchars, yotktcharsf),   
  yotkt5(ub1, yotktub1, yotktub1f, yotktub1s, yotktub1sf),         
  
  yotkt5(yoany, yotktyoany, yotktyoanyf, yotktyoanys, yotktyoanysf),  
  
  yotkt5(yotk *, yotktyotk, yotktyotkf, yotktyotks, yotktyotksf),  
  
  yotkt5(YCIDL_sequence_ub1, yotktseq, yotktseqf, yotktseqs, yotktseqsf),  
  yotkt5(dvoid *, yotktptr, yotktptrf, yotktptrs, yotktptrsf),  
  yotkt3(0, 0, 0),                                              
  yotkt3(0, 0, 0),                                               
  yotkt5(ub4, yotktub4, yotktub4f, yotktub4s, yotktub4sf),        
  
  yotkt5(char *, yotktstring, yotktstringf, yotktstrings, yotktstringsf),
  
  yotkt5(YCIDL_sequence_ub1, yotktseq, yotktseqf, yotktseqs, yotktseqsf),
  yotkt3(0, 0, 0),                                               
  yotkt3(0, 0, 0),                                               
  yotkt3(0, 0, 0),                                              
  
  yotkt5(sysb8, yotktsysb8, yotktsysb8f, yotktsysb8s, yotktsysb8sf),
};

STATICF void yotkSizeSalign(CONST yotk *tk, size_t *sz, size_t *align, 
			    size_t *salign);
STATICF boolean yotkStructTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                              dvoid *usrp,
                              boolean (*visit)(CONST yotk *tk, dvoid *val1,
                                               dvoid *val2, dvoid *usrp));
STATICF void yotkStructSz(CONST yotk *tk, size_t *sz, size_t *align,
			  size_t *salign);
STATICF boolean yotkUnionTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                             dvoid *usrp,
                             boolean (*visit)(CONST yotk *tk, dvoid *val1,
                                              dvoid *val2, dvoid *usrp));
STATICF void yotkUnionSz(CONST yotk *tk, size_t *sz, size_t *align,
			 size_t *salign);
STATICF size_t yotkUnLblSize(yotkKind disckind);



CONST yotk *yoTcNull__getTC(void)
{
  return yoTcNull__TC;
}

CONST yotk *yoTcVoid__getTC(void)
{
  return yoTcVoid__TC;
}

CONST yotk *yoTcShort__getTC(void)
{
  return yoTcShort__TC;
}

CONST yotk *yoTcUshort__getTC(void)
{
  return yoTcUshort__TC;
}

CONST yotk *yoTcFloat__getTC(void)
{
  return yoTcFloat__TC;
}

CONST yotk *yoTcDouble__getTC(void)
{
  return yoTcDouble__TC;
}

CONST yotk *yoTcBoolean__getTC(void)
{
  return yoTcBoolean__TC;
}

CONST yotk *yoTcChar__getTC(void)
{
  return yoTcChar__TC;
}

CONST yotk *yoTcOctet__getTC(void)
{
  return yoTcOctet__TC;
}

CONST yotk *yoTcAny__getTC(void)
{
  return yoTcAny__TC;
}

CONST yotk *yoTcTypeCode__getTC(void)
{
  return yoTcTypeCode__TC;
}

CONST yotk *yoTcPrincipal__getTC(void)
{
  return yoTcPrincipal__TC;
}

CONST yotk *yoTcObject__getTC(void)
{
  return yoTcObject__TC;
}




yotk *yotkDuplicateWaf(CONST yotk *tk, ysmaf af)
{
  yotk *ntk;
  size_t tklen;

  switch(yotkGetKind(tk))
  {
  case yotkNull:
    ntk = (yotk *)yoTcNull__TC;
    break;
  case yotkVoid:
    ntk = (yotk *)yoTcVoid__TC;
    break;    
  case yotkShort:
    ntk = (yotk *)yoTcShort__TC;
    break;
  case yotkLong:
    ntk = (yotk *)yoTcLong;		
    break;
  case yotkUshort:
    ntk = (yotk *)yoTcUshort__TC;
    break;
  case yotkUlong:
    ntk = (yotk *)yoTcUlong;		
    break;
  case yotkFloat:
    ntk = (yotk *)yoTcFloat__TC;
    break;
  case yotkDouble:
    ntk = (yotk *)yoTcDouble__TC;
    break;
  case yotkBoolean:
    ntk = (yotk *)yoTcBoolean__TC;
    break;
  case yotkChar:
    ntk = (yotk *)yoTcChar__TC;
    break;
  case yotkOctet:
    ntk = (yotk *)yoTcOctet__TC;
    break;
  case yotkAny:
    ntk = (yotk *)yoTcAny__TC;
    break;
  case yotkTypeCode:
    ntk = (yotk *)yoTcTypeCode__TC;
    break;
  case yotkPrincipal:
    ntk = (yotk *)yoTcPrincipal__TC;
    break;
  case yotkString:
    ntk = (yotk *)yoTcString;		
    break;
  case yotkLongLong:
    ntk = (yotk *)yoTcLongLong;		
    break;
  default:
    ntk = (yotk *)0;
    break;
  }

  if (!ntk || tk != ntk)
  {
    tklen = yotkSize(tk);
    ntk = (yotk *)(*af)(tklen);
    DISCARD memcpy((dvoid *)ntk,(dvoid *)tk,tklen);
  }
  return ntk;
}


void yotkFreeWaf(yotk *tk, ysmff ff)
{
  yotk *ntk;

  switch(yotkGetKind(tk))
  {
  case yotkNull:
    ntk = (yotk *)yoTcNull__TC;
    break;
  case yotkVoid:
    ntk = (yotk *)yoTcVoid__TC;
    break;    
  case yotkShort:
    ntk = (yotk *)yoTcShort__TC;
    break;
  case yotkLong:
    ntk = (yotk *)yoTcLong;		
    break;
  case yotkUshort:
    ntk = (yotk *)yoTcUshort__TC;
    break;
  case yotkUlong:
    ntk = (yotk *)yoTcUlong;		
    break;
  case yotkFloat:
    ntk = (yotk *)yoTcFloat__TC;
    break;
  case yotkDouble:
    ntk = (yotk *)yoTcDouble__TC;
    break;
  case yotkBoolean:
    ntk = (yotk *)yoTcBoolean__TC;
    break;
  case yotkChar:
    ntk = (yotk *)yoTcChar__TC;
    break;
  case yotkOctet:
    ntk = (yotk *)yoTcOctet__TC;
    break;
  case yotkAny:
    ntk = (yotk *)yoTcAny__TC;
    break;
  case yotkTypeCode:
    ntk = (yotk *)yoTcTypeCode__TC;
    break;
  case yotkPrincipal:
    ntk = (yotk *)yoTcPrincipal__TC;
    break;
  case yotkString:
    ntk = (yotk *)yoTcString;		
    break;
  case yotkLongLong:
    ntk = (yotk *)yoTcLongLong;		
    break;
  default:
    ntk = (yotk *)0;
    break;
  }

  if (tk && (tk != ntk))
    (*ff)((dvoid *)tk);
}


sword yotkCmp(CONST yotk *tk1, CONST yotk *tk2)
{
  size_t l1,l2;

  if(tk1 == tk2)
    return 0;
  l1 = yotkSize(tk1);
  l2 = yotkSize(tk2);

  if(l1 == l2)
    return (sword) memcmp((dvoid *)tk1,(dvoid *)tk2,l1);
  else
    return (sword) ((l1 < l2) ? -1 : 1);
}


char *yotkToStr(CONST yotk *tk)
{
#define YOTK_TO_HEXD(x) (((sb1)(x) > 9) ? ((x) - 10 + 'a') : ((x) + '0'))
  CONST ub1 *buf;
  CONST ub1 *end;
  ub1 t;
  size_t tksz;
  char *str;
  char *s;
  size_t strsz;

  
  tksz = yotkSize(tk);
  buf = (CONST ub1 *)tk;
  end = buf + tksz;
  for(strsz = 3; buf < end; buf++)
  {
    strsz += 4;
    t = *buf;
    if((!isalnum((int)t) && !ispunct((int)t)) || t != '\\' || t != '\'')
      strsz += 4;
  }

  
  str = (char *) ysmGlbAlloc(strsz,"yotk-str");
  s = str;
  *s++ = '{';
  for(buf = (ub1 *)tk; buf < end; buf++)
  {
    t = *buf;
    if((isalnum((int)t) || ispunct((int)t)) && t != '\\' && t != '\'')
    {
      *s++ = '\'';
      *s++ = (char) *buf;
      *s++ = '\'';
    }
    else
    {
      *s++ = '0';
      *s++ = 'x';
      *s++ = (char) YOTK_TO_HEXD(t>>4 & 0x0f);
      *s++ = (char) YOTK_TO_HEXD(t & 0x0f);
    }
    *s++ = ',';
  }
  *(s-1) = '}';
  *s = '\0';

  return str;
}
#undef YOTK_TO_HEXD




yotkKind yotkGetKind(CONST yotk *tk)
{
  return (yotkKind) sysxGetUaB4((ub1 *)tk);
}


yotkKind yotkGetBaseKind(CONST yotk *tk)
{
  yotkKind kind = sysxGetUaB4((ub1 *)tk);
  
  if (kind == yotkAlias)
  {
    ysbv bv;
    yosx x;
    ub4 dummy;

    yotkInitStream(&x, tk, &bv);
    while ((kind = yosxGetNetUB4(&x)) == yotkAlias)
    {
      dummy = yosxGetNetUB4(&x);                          
      yotkxSkipByteSex(&x);                                
      yotkxSkipString(&x);                                   
      yotkxSkipString(&x);                                     
    }
  }
  return kind;
}
    

CONST yotk *yotkGetBaseType(CONST yotk *tk)
{
  ub1 *buf;
  yotkKind kind;
  
  buf = (ub1*)tk;
  kind = sysxGetUaB4(buf);
  if (kind == yotkAlias)
  {
    ysbv bv;
    yosx x;

    yotkInitStream(&x, tk, &bv);
    while ((kind = sysxGetUaB4(buf)) == yotkAlias)
    {
      yotkxSkipToBuffer(&x);
      yotkxSkipString(&x);                                   
      yotkxSkipString(&x);                                     
      yosxAlign(&x, (sword)4);                           
      buf = x.ptr;
    }
  }
  return (yotk*)buf;
}


CONST char *yotkGetName(CONST yotk *tk)
{
  CONST char *name = (CONST char *)0;
  ysbv bv;
  yosx x;
  ub4 dummy;                  

  switch(yotkGetKind(tk))
  {
  case yotkObjref:
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
  case yotkEnum:
  case yotkAlias:
    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipString(&x);                                          
    dummy = yosxGetNetUB4(&x);                               
    name = (char *) x.ptr;
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return name;
}


CONST char *yotkGetId(CONST yotk *tk)
{
  CONST char *id = (CONST char *)0;
  yosx x;
  ysbv bv;
  ub4 dummy;                  

  switch(yotkGetKind(tk))
  {
  case yotkObjref:
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
  case yotkEnum:
  case yotkAlias:
    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    dummy = yosxGetNetUB4(&x);                               
    id = (char *) x.ptr;
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return id;
}


ub4 yotkMbrCount(CONST yotk *tk)
{
  ub4  cnt = 0;
  yotkKind kind;
  
  kind = yotkGetKind(tk);
  switch (kind)
  {
  case yotkStruct:
  case yotkExcept:
  case yotkEnum:
  case yotkUnion:
  {
    ysbv bv;
    yosx x;

    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipString(&x);                                          
    yotkxSkipString(&x);                                            
    if (kind == yotkUnion)
    {
      yotkxSkipTC(&x);                                        
      cnt = yosxGetNetUB4(&x);                          
    }
    cnt = yosxGetNetUB4(&x);
    break;
  }
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return cnt;
}


CONST char *yotkMbrName(CONST yotk *tk, ub4 index)
{
  ub4  i;
  size_t dsz = 0;
  yotkKind kind = yotkGetKind(tk);
  ysbv bv;
  yosx x;
  const char* name;
  
  switch (kind)
  {
  case yotkStruct:
  case yotkExcept:
  case yotkEnum:
  case yotkUnion:
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            
  yotkxSkipString(&x);                                              
    
  if (kind == yotkUnion)
  {
    yosxAlign(&x, (sword)4);
    dsz = yotkUnLblSize(yotkGetKind((yotk *)x.ptr));    
    yotkxSkipTC(&x);                                          
    i = yosxGetNetUB4(&x);                              
  }

  if (index >= yosxGetNetUB4(&x))                           
    yseThrow(YO_EX_BOUNDS);

    
  for (i = 0; i < index ; i++)
  {
    if (kind == yotkUnion)                            
    {
      yosxAlign(&x, (sword)dsz);
      yosxSkip(&x, dsz);
    }
    yotkxSkipString(&x);                                   
    if (kind != yotkEnum)
      yotkxSkipTC(&x);                                     
  }

  if (kind == yotkUnion)
  {                                                          
    yosxAlign(&x, (sword)dsz);
    yosxSkip(&x, dsz);
  }
  dsz = yosxGetNetUB4(&x);                             
  name = (char*)x.ptr;
  return name;
}


CONST yotk *yotkMbrType(CONST yotk *tk, ub4 index)
{
  ub4  i;
  size_t dsz = 0;
  yotkKind kind = yotkGetKind(tk);
  ysbv bv;
  yosx x;
  const yotk* result;
  
  switch (kind)
  {
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            
  yotkxSkipString(&x);                                              

    
  if (kind == yotkUnion)
  {                                 
    yosxAlign(&x, (sword)4);
    dsz = yotkUnLblSize(yotkGetKind((yotk *)x.ptr));    
    yotkxSkipTC(&x);                                          
    DISCARD yosxGetNetUB4(&x);                               
  }

  if (index >= yosxGetNetUB4(&x))                              
    yseThrow(YO_EX_BOUNDS);

    
  for (i = 0; i < index ; i++)
  {
    if (kind == yotkUnion)                            
    {
      yosxAlign(&x, (sword)dsz);
      yosxSkip(&x, dsz);
    }
    yotkxSkipString(&x);                                   
    if (kind != yotkEnum)
      yotkxSkipTC(&x);                                     
  }

  if (kind == yotkUnion)
  {                                                          
    yosxAlign(&x, (sword)dsz);
    yosxSkip(&x, dsz);
  }
  yotkxSkipString(&x);                                       
  yosxAlign(&x, 4);                                     
  result = (const yotk*)x.ptr;

  return result;
}


CONST yotk *yotkDiscType(CONST yotk *tk)
{
  ysbv bv;
  yosx x;
  const yotk* result;

  if (yotkGetKind(tk) != yotkUnion)
    yseThrow(YO_EX_BADCODE);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            
  yotkxSkipString(&x);                                              
  yosxAlign(&x, (sword)4);
  result = (const yotk*)x.ptr;
  return result;
}



yoany yotkMbrLabel(CONST yotk *tk, ub4 index)
{
  yoany parm;
  ub4   i;
  ub4  lval;
  ub2  sval;
  size_t dsz = 0;
  ysbv bv;
  yosx x;
  yotkKind dkind;
  
  if (yotkGetKind(tk) != yotkUnion)
    yseThrow(YO_EX_BADCODE);
  if (index > yotkMbrCount(tk))
    yseThrow(YO_EX_BOUNDS);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            
  yotkxSkipString(&x);                                              

  yosxAlign(&x, (sword)4);
  parm._type = (yotk *) x.ptr;
  yotkxSkipTC(&x);                                            
  dkind = yotkGetKind(yotkGetBaseType(parm._type));
  dsz = yotkUnLblSize(dkind);                           
  lval = yosxGetNetUB4(&x);                                  
  lval = yosxGetNetUB4(&x);                                    

    
  for (i=0 ; i < index ; i++)
  {
    yosxAlign(&x, (sword)dsz);                               
    yosxSkip(&x, dsz);
    yotkxSkipString(&x);                                        
    yotkxSkipTC(&x);                                              
  }

    
  switch(dkind)
  {
    case yotkShort:
    case yotkUshort:
      parm._value = ysmGlbAlloc(2, "value");
      sval = yosxGetNetUB2(&x);
      *(ub2 *) parm._value = sval;
      break;
    case yotkLong:
    case yotkUlong:
    case yotkEnum:
    case yotkBoolean:
      parm._value = ysmGlbAlloc(4, "value");
      lval = yosxGetNetUB4(&x);
      *(ub4 *) parm._value = lval;
      break;
    case yotkChar:
      parm._value = ysmGlbAlloc(1, "value");
      *(ub1 *) parm._value = yosxGetNetUB1(&x);
      break;
    default:
      yseThrow(YO_EX_BADCODE);
      break;
  }
  return parm;
}


ub4   yotkDefIndex(CONST yotk *tk)
{
  ysbv bv;
  yosx x;
  ub4 result;

  if (yotkGetKind(tk) != yotkUnion)
    yseThrow(YO_EX_BADCODE);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            
  yotkxSkipString(&x);                                              
  yotkxSkipTC(&x);                                            
  result = yosxGetNetUB4(&x);
  return result;
}


ub4 yotkLength(CONST yotk *tk)
{
  ub4  len = 0;
  
  switch (yotkGetKind(tk))
  {
  case yotkString:
    len = sysxGetUaB4(((ub1 *)tk)+4);
    break;
  case yotkSequence:
  case yotkArray:
  {
    ysbv bv;
    yosx x;

    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipTC(&x);
    len = yosxGetNetUB4(&x);
    break;
  }
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return len;
}


ub4 yotkRecOffset(CONST yotk *tk)
{
  sb4   off;
  ub4   i, cnt;
  yotk *btk;                                                
  yotk *mtk;                                              
  
  if (yotkGetKind(tk) != yotkRecurs)
    yseThrow(YO_EX_BADCODE);
  
  off = sysxGetUaB4(((ub1 *)tk)+4);
  btk = (yotk *)((ub1 *)tk + off + 4);        

  
  cnt = yotkMbrCount(btk);
  for (i=0 ; i<cnt; i++)
  {
    mtk = (yotk *)yotkMbrType(btk, i);
    if (yotkGetKind(mtk) == yotkSequence)
    {
      if (yotkContentType(mtk) == tk)
	return 1;
    }
  }
  
  
  yseThrow(YO_EX_BADCODE);
  return 0;
}


CONST yotk *yotkContentType(CONST yotk *tk)
{
  CONST yotk *ntk = (CONST yotk *)0;
  ysbv bv;
  yosx x;
  yotkKind kind;

  kind = yotkGetKind(tk);
  switch(kind)
  {
  case yotkSequence:
  case yotkArray:
  case yotkAlias:
    break;
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  if ( kind == yotkAlias )
  {
    yotkxSkipString(&x);                                          
    yotkxSkipString(&x);                                          
  }
  yosxAlign(&x, 4);
  ntk = (const yotk*) x.ptr;

  return ntk;
}


ub4 yotkParamCount(CONST yotk *tk)
{
  ub4 cnt = 0;
  
  switch (yotkGetKind(tk))
  {
  case yotkNull:
  case yotkVoid:
  case yotkShort:
  case yotkUshort:
  case yotkLong:
  case yotkUlong:
  case yotkFloat:
  case yotkDouble:
  case yotkBoolean:
  case yotkChar:
  case yotkOctet:
  case yotkAny:
  case yotkTypeCode:
  case yotkPrincipal:
  case yotkLongLong:
    cnt = 0;
    break;
  case yotkString:
  case yotkObjref:
    cnt = 1;
    break;
  case yotkSequence:
  case yotkArray:
  case yotkAlias:
    cnt = 2;
    break;
  case yotkStruct:
  case yotkExcept:
    cnt = 1 + 2 * yotkMbrCount(tk);
    break;
  case yotkEnum:
    cnt = 1 + yotkMbrCount(tk);
    break;
  case yotkUnion:
    cnt = 2 + 3 * yotkMbrCount(tk);
    break;
  case yotkRecurs:
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return cnt;
}


yoany yotkParam(CONST yotk *tk, ub4 index)
{
  yoany parm;
  
  if (index >= yotkParamCount(tk))
    yseThrow(YO_EX_BOUNDS);

  switch (yotkGetKind(tk))
  {
  case yotkString:
    parm._type  = (yotk *)yoTcUlong;                               
    parm._value = ysmGlbAlloc(4, "parm");
    *(ub4 *)parm._value = yotkLength(tk);
    break;
  case yotkObjref:
    parm._type  = (yotk *)yoTcString;                     
    parm._value = ysmGlbAlloc(sizeof(char *), "parm");
    *(char **)parm._value = (char *)yotkGetName(tk);
    break;
  case yotkArray:
  case yotkSequence:
    if (index == 0)                                          
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkContentType(tk);
    }
    else                                                           
    {
      parm._type  = (yotk *)yoTcUlong;
      parm._value = ysmGlbAlloc(4, "parm");
      *(ub4 *)parm._value = yotkLength(tk);
    }
    break;
  case yotkAlias:
    if (index == 0)                                                  
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else                                                     
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkContentType(tk);
    }
    break;
  case yotkStruct:
  case yotkExcept:
    if (index == 0)                                                  
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else if (index % 2)                                          

    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkMbrName(tk, (index-1)/2);
    }
    else                                                         
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkMbrType(tk, (index-1)/2);
    }
    break;
  case yotkEnum:
    if (index == 0)                                                  
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else                                                         
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkMbrName(tk, index-1);
    }
    break;
  case yotkUnion:
    if (index == 0)                                                  
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkGetName(tk);
    }
    else if (index == 1)                                        
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkDiscType(tk);
    }
    else if ((index % 3) == 2)                                
    {
      parm._type  = (yotk *)yoTcAny;
      parm._value = ysmGlbAlloc(sizeof(yoany), "any");
      *(yoany *)parm._value = yotkMbrLabel(tk, (index-2)/3);
    }
    else if ((index % 3) == 0)                                   
    {
      parm._type  = (yotk *)yoTcString;
      parm._value = ysmGlbAlloc(sizeof(char *), "parm");
      *(char **)parm._value = (char *)yotkMbrName(tk, (index-2)/3);
    }
    else                                                         
    {
      parm._type  = (yotk *)yoTcTypeCode;
      parm._value = ysmGlbAlloc(sizeof(yotk *), "parm");
      *(yotk **)parm._value = (yotk *)yotkMbrType(tk, (index-2)/3 );
    }
    break;
  case yotkRecurs:
  default:
    yseThrow(YO_EX_BADCODE);
    break;
  }
  return parm;
}




yotk *yotkCrStruct(CONST yrid *id, CONST ysid *nm, CONST yotkStrMbrSeq *mbrs)
{
  yosx *x;
  yosxPos lpos, epos;
  yotk  *ntk;
  ub4 tklen;
  ub4 i;
  CONST yotkStrMbr *mbr;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkStruct);                                       
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yotkgPutStr(x,(const char *) id);                         
  yotkgPutStr(x,ysidToStr(nm));                                      

  if(mbrs && (mbrs->_length > 0))
  {
    yosxPutNetUB4(x,mbrs->_length);                          
    for (i=0, mbr = mbrs->_buffer; i < mbrs->_length ; i++, mbr++)   
    {
      yotkgPutStr(x,ysidToStr(mbr->name));                    
      yosxAlign(x,4);
      yosxCopy(x,(ub1 *) mbr->type,yotkSize(mbr->type));      
    }
  }
  else
    yosxPutNetUB4(x,(ub4)0);

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   
  return ntk;
}


yotk *yotkCrUnion(CONST yrid *id, CONST ysid *nm, CONST yotk *disc,
		  CONST yotkUnMbrSeq *mbrs)
{
  yotk *ntk;
  ub4    i;
  yosx *x;
  yosxPos lpos, epos;
  yosxPos dpos;
  ub4 tklen;
  ub4 disckind;
  CONST yotkUnMbr *umbr;
  boolean isDefault;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkUnion);                                        
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yotkgPutStr(x,(const char*)id);                           
  yotkgPutStr(x,ysidToStr(nm));                                      
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *) disc,yotkSize(disc));                        
  yosxAlign(x,4);
  yosxGetPos(x,&dpos);                      
  yosxPutNetUB4(x,(ub4)-1);                                 
  yosxPutNetUB4(x,mbrs->_length);                               
  disckind = yotkGetKind(yotkGetBaseType(disc));
  for (i=0, umbr=mbrs->_buffer; i < mbrs->_length ; i++, umbr++)
  {
    isDefault = (yotkGetKind(umbr->label._type) == yotkOctet);
    
    switch(disckind)
    {
    case yotkShort:
      if (!isDefault)
        yosxPutNetUB2(x,(ub2) *((sb2 *) umbr->label._value));
      else
        yosxPutNetUB2(x,(ub2) 0);
      break;
    case yotkLong:
      if (!isDefault)
        yosxPutNetUB4(x,(ub4) *((sb4 *) umbr->label._value));
      else
        yosxPutNetUB4(x,(ub4) 0);
      break;
    case yotkUshort:
      if (!isDefault)
        yosxPutNetUB2(x,(ub2) *((ub2 *) umbr->label._value));
      else
        yosxPutNetUB2(x,(ub2) 0);
      break;
    case yotkEnum:
    case yotkUlong:
      if (!isDefault)
        yosxPutNetUB4(x,(ub4) *((ub4 *) umbr->label._value));
      else
        yosxPutNetUB4(x,(ub4) 0);
      break;
    case yotkBoolean:
      if (!isDefault)
        yosxPutNetUB1(x,(ub1) *((boolean *) umbr->label._value));
      else
        yosxPutNetUB1(x,(ub1) 0);
      break;
    case yotkChar:
      if (!isDefault)
        yosxPutNetUB1(x,(ub1) *((char *) umbr->label._value));
      else
        yosxPutNetUB1(x,(ub1) 0);
      break;
    default:
      yseThrow(YO_EX_BADCODE);
      break;
    }
    yotkgPutStr(x,ysidToStr(umbr->name));                        
    yosxAlign(x,4);                                          
    yosxCopy(x,umbr->type,yotkSize(umbr->type));                   
    if(isDefault)
      yosxPutNetUB4AtPos(x, &dpos, (ub4)i);
  }

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);
  ntk = yotkgGenTk(ysmGlbHeap(),x);                   

  return ntk;
}


yotk *yotkCrEnum(CONST yrid *id, CONST ysid *nm, CONST yotkEnumMbrSeq *mbrs)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;
  ub4 i;
  
  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkEnum);                                         
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yotkgPutStr(x,(const char *)id);                          
  yotkgPutStr(x,ysidToStr(nm));                                      
  yosxPutNetUB4(x,mbrs->_length);                            
  for (i=0; i < mbrs->_length; i++)                          
    yotkgPutStr(x,ysidToStr(mbrs->_buffer[i]));

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   
  return ntk;
}


yotk *yotkCrAlias(CONST yrid *id, CONST ysid *nm, CONST yotk *base)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;
  
  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkAlias);                                        
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yotkgPutStr(x,(const char *)id);                          
  yotkgPutStr(x,ysidToStr(nm));                                      
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *)base,yotkSize(base));                        

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   

  return ntk;
}


yotk *yotkCrExcept(CONST yrid *id, CONST ysid *nm, CONST yotkStrMbrSeq *mbrs)
{
  yosx *x;
  yosxPos lpos, epos;
  yotk  *ntk;
  ub4 tklen;
  ub4 i;
  CONST yotkStrMbr *mbr;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkExcept);                                       
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yotkgPutStr(x,(const char *) id);                         
  yotkgPutStr(x,ysidToStr(nm));                                      

  if(mbrs && (mbrs->_length > 0))
  {
    yosxPutNetUB4(x,mbrs->_length);                          
    for (i=0, mbr = mbrs->_buffer; i < mbrs->_length ; i++, mbr++)   
    {
      yotkgPutStr(x,ysidToStr(mbr->name));                    
      yosxAlign(x,4);
      yosxCopy(x,(ub1 *) mbr->type,yotkSize(mbr->type));      
    }
  }
  else
    yosxPutNetUB4(x,(ub4)0);

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   
  return ntk;
}


yotk *yotkCrInterface(CONST yrid *id, CONST ysid *nm)
{
  yosx *x;
  yosxPos lpos, epos;
  yotk  *ntk;
  ub4 tklen;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkObjref);                                       
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yotkgPutStr(x,(const char *) id);                         
  yotkgPutStr(x,ysidToStr(nm));                                      

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   

  return ntk;
}


yotk *yotkCrString(ub4 bound)
{
  ub1   *tk;

  tk = (ub1 *)ysmGlbAlloc(8, "yotk");

  sysxPutUaB4(tk, (ub4) yotkString);                                 
  sysxPutUaB4(tk+4, bound);                                        

  return (yotk *)tk;
}


yotk *yotkCrSeq(ub4 bound, CONST yotk *elt)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkSequence);                                     
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *)elt,yotkSize(elt));
  yosxPutNetUB4(x,bound);                                  

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   

  return ntk;
}


yotk *yotkCrRecSeq(ub4 bound,  ub4 offset,
		   sb4 byteoff )
{
  ub1   *tk;

  tk = (ub1 *)ysmGlbAlloc(8, "yotk");

  sysxPutUaB4(tk, (ub4) yotkRecurs);
  sysxPutUaB4(tk+4, (ub4) byteoff);

  return (yotk *)tk;
}


yotk *yotkCrArray(ub4 length, CONST yotk *elt)
{
  yotk *ntk;
  yosx *x;
  yosxPos lpos, epos;
  ub4 tklen;

  x = yosxEncode(YOTKG_SIZE,ysmGlbHeap());
  yosxPutNetUB4(x,yotkArray);                                        
  yosxAlign(x,4);                               
  yosxGetPos(x,&lpos);
  yosxPutNetUB4(x,(ub4)0);                                   
  yosxPutNetUB1(x,(ub1)0);                                        
  yosxAlign(x,4);
  yosxCopy(x,(ub1 *)elt,yotkSize(elt));                          
  yosxPutNetUB4(x,length);

  yosxGetPos(x,&epos);
  tklen = yosxGetLength(x,&epos,&lpos) - 4;                  
  yosxPutNetUB4AtPos(x, &lpos, tklen);

  ntk = yotkgGenTk(ysmGlbHeap(),x);                   

  return ntk;
}




STATICF void yotkSizeSalign(CONST yotk *tk, size_t *sz, size_t *align, 
			    size_t *salign)
{
  yotkKind kind;
  ub4  bounds;
  const yotk *tk2;

  kind = yotkGetKind(tk);
  switch (kind)
    {
    case yotkNull:
    case yotkVoid:
    case yotkShort:
    case yotkLong:
    case yotkUshort:
    case yotkUlong:
    case yotkFloat:
    case yotkDouble:
    case yotkBoolean:
    case yotkChar:
    case yotkOctet:
    case yotkAny:
    case yotkTypeCode:
    case yotkObjref:
    case yotkEnum:
    case yotkString:
    case yotkSequence:
    case yotkLongLong:
      if (sz)
	*sz = yotktTable[kind].size;
      if (align)
	*align = yotktTable[kind].align;
      if (salign)
	*salign = yotktTable[kind].salign;
      break;
    case yotkStruct:
      yotkStructSz(tk, sz, align, salign);
      break;
    case yotkUnion:
      yotkUnionSz(tk, sz, align, salign);
      break;
    case yotkArray:
    {
      yotkCollDecomp(tk, &tk2, &bounds);

      
      
      yotkSizeSalign(tk2, sz, align, salign);
      if (sz)
	*sz = (size_t)(*sz * bounds);
      break;
    }
    case yotkAlias:
      yotkSizeSalign(yotkGetBaseType(tk), sz, align, salign);
      break;
    case yotkExcept:
      yotkStructSz(tk, sz, align, salign);
      break;
    default:
      yseThrow(YO_EX_BADCODE);
      break;
    }
}


void yotkSizeAlign(CONST yotk *tk, size_t *sz, size_t *align)
{
  size_t salign;
  yotkSizeSalign(tk, sz, align, &salign);
}


STATICF void yotkUnionSz(CONST yotk *tk, size_t *sz, size_t *align, 
			 size_t *salign)
{
  ub4    arms;
  size_t usz, ualign, usalign;
  size_t dsz, dalign, dsalign;
  size_t talign;
  yosx x;
  ysbv bv;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            
  yotkxSkipString(&x);                                         

  
  yosxAlign(&x, 4);                                  
  yotkSizeSalign((yotk*)x.ptr, &dsz, &dalign, &dsalign);
  yotkxSkipTC(&x);

  arms = yosxGetNetUB4(&x);                                  
  arms = yosxGetNetUB4(&x);                                    
  yotkUnionArmsSz(arms, dsz, &x, &usz, &ualign);
  
  
  talign = max(ualign, dsalign);

  if (sz)
  {
    *sz = ysRoundVal(dsz, ualign);       
    *sz += usz;                                                 
    *sz = ysRoundVal(*sz, talign);                           
  }

  
  if (align)
    *align = talign;
  if (salign)
    *salign = talign;
}


STATICF void yotkStructSz(CONST yotk *tk, size_t *sz, size_t *align,
			  size_t *salign)
{
  ub4     members;
  size_t  tsz, talign, tsalign; 
  size_t  mbrsz, mbralign, mbrsalign;
  yosx    x;
  ysbv    bv;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                            
  yotkxSkipString(&x);                                         

  tsz = 0, talign = 1, tsalign = 1;
  members = yosxGetNetUB4(&x);

  while (members--)
  {
    yotkxSkipString(&x);                                        
    yosxAlign(&x, (sword)4);                                
    tk = (yotk *) x.ptr;
    yotkxSkipTC(&x);

    
    yotkSizeSalign(tk, &mbrsz, &mbralign, &mbrsalign); 

    tsz = ysRoundVal(tsz, mbralign) + mbrsz;
    if (mbralign > talign)
      talign = mbralign;
    if (mbrsalign > tsalign)
      tsalign = mbrsalign;
  }

  
  if (sz)
    *sz = ysRoundVal(tsz, max(talign, tsalign));

  
  if (align)
    *align = tsalign;
  if (salign)
    *salign = tsalign;
}


void yotkUnionArmsSz(ub4 arms, size_t dsz, yosx *x, size_t *sz, size_t *align)
{
  size_t nsz, nalign, nsalign;
  size_t asz, aalign, asalign;

  nsz = 0; nalign = 1; nsalign = 1;

  while (arms--)
  {
    yosxAlign(x, (sword)dsz);                       
    yosxSkip(x, dsz);                                   
    yotkxSkipString(x);                                    
    yosxAlign(x, (sword)4);                              

    
    yotkSizeSalign((yotk *) x->ptr, &asz, &aalign, &asalign);
    yotkxSkipTC(x);

    
    if (aalign > nalign)
      nalign = aalign;
    if (asalign > nsalign)
      nsalign = asalign;
    if (asz > nsz)
      nsz = asz;
  }

  
  if (align)
    *align = nsalign;
  if (sz)
    *sz = ysRoundVal(nsz, nsalign);
}

dvoid *yotkOffset(CONST yotk *tk, ub4 mbr, dvoid *val)
{
  ub1 *ptr;
  CONST yotk *mtk;
  size_t sz, align, salign, tsz;
  yotkKind knd;
  yosx x;
  ysbv bv;
  ub4 i, arms;
  
  knd = yotkGetBaseKind(tk);
  ptr = (ub1 *)val;
  switch (knd)
  {
  case yotkSequence:
    ptr += 8;                                
    ptr = *(dvoid **)ptr;                          
    ;
  case yotkArray:
    i = yotkLength(tk);
    if (i && i <= mbr)
      yseThrow(YO_EX_BOUNDS);
    mtk = yotkContentType(tk);
    yotkSizeSalign(mtk, &sz, &align, &salign);
    ptr += sz * mbr;
    break;
  case yotkStruct:
  case yotkExcept:
    if (mbr >= yotkMbrCount(tk))
      yseThrow(YO_EX_BOUNDS);
    for (i=0, tsz=0; i <= mbr; i++) 
    {
      mtk = yotkMbrType(tk, i);

      yotkSizeSalign(mtk, &sz, &align, &salign);
      tsz = ysRoundVal(tsz, align);
      if (i < mbr)
        tsz += sz;
    }
    ptr += tsz;
    break;
  case yotkUnion:
    yotkInitStream(&x, tk, &bv);
    yotkxSkipToBuffer(&x);
    yotkxSkipString(&x);                                          
    yotkxSkipString(&x);                                       

    
    yosxAlign(&x, 4);                                
    yotkSizeSalign((yotk*)x.ptr, &sz, &align, &salign);
    yotkxSkipTC(&x);

    arms = yosxGetNetUB4(&x);                                
    arms = yosxGetNetUB4(&x);                                  
    yotkUnionArmsSz(arms, sz, &x, &tsz, &align);

    
    tsz = ysRoundVal(sz, align);
    ptr += tsz;
    break;
  default:
    yseThrow(YO_EX_BADCODE);
  }
  return (dvoid *)ptr;
}



boolean yotkTraverse(CONST yotk *tk, dvoid *val1, dvoid *val2, dvoid *usrp,
                     boolean (*visit)(CONST yotk *tk, dvoid *val1, dvoid *val2,
                                      dvoid *usrp))
{
  boolean sts = TRUE;
  yotkKind kind;
  CONST char *name;
  ub4    bounds;
  size_t sz;
  YCIDL_sequence_ub1 *vseqoct;
  const yotk *tk2;

  kind = yotkGetKind(tk);
  switch(kind)
  {
  case yotkObjref:
  case yotkStruct:
  case yotkExcept:
  case yotkUnion:
  case yotkEnum:
  case yotkAlias:
    name = yotkGetName(tk);
    break;
  default:
    name = "<none>";
    break;
  }
#ifdef DEBUG
  yslError("Traversing: kind = %d name = %s\n",kind,name);
#endif
  switch (kind)
    {
    case yotkNull:
    case yotkVoid:
    case yotkShort:
    case yotkLong:
    case yotkUshort:
    case yotkUlong:
    case yotkFloat:
    case yotkDouble:
    case yotkBoolean:
    case yotkChar:
    case yotkOctet:
    case yotkAny:
    case yotkTypeCode:
    case yotkPrincipal:
    case yotkObjref:
    case yotkLongLong:
    case yotkEnum:
    case yotkString:
      sts = (*visit)(tk, val1, val2, usrp);
      break;
    case yotkStruct:
      sts = yotkStructTrv(tk, val1, val2, usrp, visit);
      break;
    case yotkUnion:
      sts = yotkUnionTrv(tk, val1, val2, usrp, visit);
      break;
    case yotkSequence:
      vseqoct = (YCIDL_sequence_ub1 *) val1;
      bounds = vseqoct->_length;
      val1 = (dvoid *) vseqoct->_buffer;

      if (val2)
      {
        vseqoct = (YCIDL_sequence_ub1 *) val2;
        if (vseqoct->_length != bounds)
          yseThrow(YO_EX_BOUNDSMISMATCH);
        val2 = (dvoid *) vseqoct->_buffer;
      }

      tk = yotkContentType(tk);
      if (yotkGetKind(tk) == yotkRecurs)
	tk = tk + ((sb4) yotkGetLength(tk)) + 4;

      yotkSizeAlign(tk, &sz, (size_t *) 0);
      while (sts && bounds--)
      {
        sts = (*visit)(tk, val1, val2, usrp);
        val1 = (dvoid *) (((ub1 *) val1) + sz);
        if (val2)
          val2 = (dvoid *) (((ub1 *) val2) + sz);
      }
      break;
    case yotkArray:
      yotkCollDecomp(tk, &tk2, &bounds);
      yotkSizeAlign(tk2, &sz, (size_t *) 0);
      while (sts && bounds--)
      {
        sts = (*visit)(tk2, val1, val2, usrp);
        val1 = (dvoid *) (((ub1 *) val1) + sz);
        if (val2)
          val2 = (dvoid *) (((ub1 *) val2) + sz);
      }
      break;
    case yotkAlias:
      tk = yotkContentType(tk);
      sts = (*visit)(tk, val1, val2, usrp);
      break;
    case yotkExcept:
      sts = yotkStructTrv(tk, val1, val2, usrp, visit);
      break;
    case yotkRecurs:
    default:
      yseThrow(YO_EX_BADCODE);
      break;
    }

  return sts;
}


STATICF boolean yotkStructTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                           dvoid *usrp,
                           boolean (*visit)(CONST yotk *tk, dvoid *val1, 
                                            dvoid *val2, dvoid *usrp))
{
  boolean sts = TRUE;
  ub4    members;
  size_t sz, align, salign, tsz;
  yosx  x;
  ysbv  bv;
  ub1  *base1, *base2;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                           
  yotkxSkipString(&x);                                        

  base1 = (ub1 *)val1;
  base2 = (ub1 *)val2;
  tsz = 0;

  members = yosxGetNetUB4(&x);
  while (sts && members--)
  {
#ifdef DEBUG
    yslError("  struct member: name = %s\n",buf+4);
#endif
    yotkxSkipString(&x);                                       
    yosxAlign(&x, (sword)4);                               
    tk = (yotk *) x.ptr;
    if (yotkGetKind(tk) == yotkRecurs)
      tk = tk + ((sb4) yotkGetLength(tk)) + 4;      

    yotkSizeSalign(tk, &sz, &align, &salign);  

    
    tsz = ysRoundVal(tsz, align);
      
    val1 = (dvoid *)(base1 + tsz);
    if (val2)
      val2 = (dvoid *)(base2 + tsz);
 
    sts = (*visit)(tk, val1, val2, usrp);               
    tsz += sz;                             
    yotkxSkipTC(&x);
  }
  return sts;
}


STATICF boolean yotkUnionTrv(CONST yotk *tk, dvoid *val1, dvoid *val2,
                             dvoid *usrp,
                             boolean (*visit)(CONST yotk *tk, dvoid *val1,
                                              dvoid *val2, dvoid *usrp))
{
  boolean sts = TRUE;
  const yotk  *disctk;
  const yotk  *dflttk;
  sb4    dflt, lbl, tag;
  ub4    i, arms;
  size_t sz, usz, ualign;
  yosx  x;
  ysbv  bv;
  yotkKind dkind;
  yosxPos pos;

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yotkxSkipString(&x);                                           
  yotkxSkipString(&x);                                        

  
  yosxAlign(&x, (sword)4);                          
  disctk = (yotk *) x.ptr; 
  disctk = yotkGetBaseType(disctk);
  sts = (*visit)(disctk, val1, val2, usrp);     

  if (sts)
  {
    yotkSizeAlign(disctk, &sz, (size_t *) 0);

    
    tag = 0;			
    
    dkind = yotkGetKind(disctk);
    switch (dkind)
    {
      case yotkShort:
        tag = (sb4) *((sb2 *) val1);
        break;
      case yotkLong:
        tag = *((sb4 *) val1);
        break;
      case yotkUshort:
        tag = (sb4) *((ub2 *) val1);
        break;
      case yotkEnum:
      case yotkUlong:
        tag = (sb4) *((ub4 *) val1);
        break;
      case yotkBoolean:
        tag = (sb4) *((boolean *) val1);
        break;
      case yotkChar:
        tag = (sb4) *((char *) val1);
        break;
      default:
        yseThrow(YO_EX_BADCODE);
      break;
    }

    yotkxSkipTC(&x);                                    
    dflt = (sb4) yosxGetNetUB4(&x);                    
    dflttk = (yotk *) 0;                                 

    arms = yosxGetNetUB4(&x);                    
    yosxGetPos(&x, &pos);
    yotkUnionArmsSz(arms, sz, &x, &usz, &ualign);
    yosxSetPos(&x, &pos);

    
    sz = ysRoundVal(sz, ualign);
    val1 = (dvoid *) (((ub1 *) val1) + sz);
    if (val2)
      val2 = (dvoid *) (((ub1 *) val2) + sz);

    
    lbl = (sb4)0;                                
    for (i = 0; i < arms; i++)
    {
      switch (dkind)                                
      {
        case yotkShort:
        case yotkUshort:
          lbl = (sb4) yosxGetNetUB2(&x);
          break;
        case yotkLong:
        case yotkEnum:
        case yotkUlong:
          lbl = (sb4) yosxGetNetUB4(&x);
          break;
        case yotkChar:
        case yotkBoolean:
          lbl = (sb4) yosxGetNetUB1(&x);
          break;
      }
      yotkxSkipString(&x);                             
      yosxAlign(&x, (sword)4);                        

      if (dflt >= 0 && i == (ub4)dflt)                     
	dflttk = (yotk *) x.ptr;
      else if (lbl == tag)                          
	break;

      yotkxSkipTC(&x);                                      
    }

    tk = (i == arms ? dflttk : (yotk *) x.ptr);
    if (tk)
      sts = (*visit)(tk, val1, val2, usrp);
  }
  return sts;
}




size_t yotkGetLength(CONST yotk *tk)
{
  return (size_t)(sysxGetUaB4(((ub1 *)tk) + 4));
}


size_t yotkSize(CONST yotk *tk)
{
  switch (yotkGetKind(tk))
  {
    case yotkString:
    case yotkRecurs:
      return 8;
    case yotkObjref:
    case yotkStruct:
    case yotkUnion:
    case yotkEnum:
    case yotkSequence:
    case yotkArray:
    case yotkAlias:
    case yotkExcept:
      return 8 + sysxGetUaB4(((ub1 *)tk + 4));
    default:
      return 4;
    }
}


void yotkInitStream(yosx *x, const yotk *tk, ysbv *bv)
{
  bv->buf = (ub1 *)tk;
  bv->len = yotkSize(tk);
  yosxDecInit(x, FALSE, bv, (sword)1);
}


void yotkCollDecomp(const yotk *tk, const yotk **etk, ub4* bounds)
{
  ysbv bv;
  yosx x;
  yotkKind kind;

  kind = yotkGetKind(tk);
  if ((kind != yotkSequence) && (kind != yotkArray))
    yseThrow(YO_EX_BADCODE);

  yotkInitStream(&x, tk, &bv);
  yotkxSkipToBuffer(&x);
  yosxAlign(&x, 4);
  *etk = (const yotk*) x.ptr;
  yotkxSkipTC(&x);
  *bounds = yosxGetNetUB4(&x);
}


void yotkgPutStr(yosx *x, const char *str)
{
  size_t len;

  if(str)
    len = strlen(str) + 1;
  else
    len = 0;

  yosxPutNetUB4(x,(ub4)len);
  if(len)
    yosxCopy(x,(ub1 *)str,len);
}

yotk *yotkgGenTk(ysmhp *hp, yosx *x)
{
  ysbv *bv, *b;
  sword nbv, i;
  yotk *tk;
  size_t len;

  yosxEncEnd(x, &bv, &nbv);
  if(nbv > 1)
  {
    for(len = 0, i = 0, b = bv; i < nbv; i++, b++)
      len += b->len;
    tk = (yotk *)ysmAlloc(hp, len,"yotk");
    ysBvGather(tk, len, bv, nbv);
    ysBvFree(hp, bv, nbv);
  }
  else
  {
    tk = (yotk *)ysmRealloc(hp,bv->buf,bv->len);
    ysmFree(hp,(dvoid *)bv);
  }
  return tk;
}



STATICF size_t yotkUnLblSize(yotkKind disckind)
{
  size_t sz;

  switch(disckind)
  {
    case yotkShort:
    case yotkUshort:
      sz = (size_t)2;
      break;
    case yotkLong:
    case yotkUlong:
    case yotkEnum:
      sz = (size_t)4;
      break;
    case yotkBoolean:
    case yotkChar:
      sz = (size_t)1;
      break;
    default:
      sz = (size_t)0;
      yseThrow(YO_EX_BADCODE);
      break;
  }
  return sz;
}
