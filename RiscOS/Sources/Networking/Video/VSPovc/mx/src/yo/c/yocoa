/* yo/yocoa.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/








#ifndef SYSX_ORACLE
#include <sysx.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif
#ifndef YSTHR_ORACLE
#include <ysthr.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YOCOA_ORACLE
#include <yocoa.h>
#endif
#ifndef YOI_ORACLE
#include <yoi.h>
#endif
#ifndef YDYOIDL_ORACLE
#include <ydyoidl.h>
#endif
#ifndef YOIDL_ORACLE
#include <yoidl.h>
#endif
#ifndef YOCY_ORACLE
#include <yocy.h>
#endif
#ifndef YOORB_ORACLE
#include <yoorb.h>                    
#endif


externdef ysidDecl(YO_EX_DUPLICATE) = "yo::duplicate";
externdef ysidDecl(YO_EX_NOIMPL) = "yo::noimpl";
externdef ysidDecl(YO_EX_STATELESS) = "yo::stateless";

externdef ysmtagDecl(yotcx_tag) = "yotcx";
externdef ysmtagDecl(yotdcx_tag) = "yotdcx";


static CONST char CORBA_UNKNOWN_id[] =    "IDL:omg.org/CORBA/UNKNOWN:1.0";
static CONST char CORBA_BAD_PARAM_id[] =  "IDL:omg.org/CORBA/BAD_PARAM:1.0";
static CONST char CORBA_NO_MEMORY_id[] =  "IDL:omg.org/CORBA/NO_MEMORY:1.0";
static CONST char CORBA_IMP_LIMIT_id[] =  "IDL:omg.org/CORBA/IMP_LIMIT:1.0";
static CONST char CORBA_COMM_FAILURE_id[] = 
                                          "IDL:omg.org/CORBA/COMM_FAILURE:1.0";
static CONST char CORBA_INV_OBJREF_id[] = "IDL:omg.org/CORBA/INV_OBJREF:1.0";
static CONST char CORBA_NO_PERMISSION_id[] = 
                                         "IDL:omg.org/CORBA/NO_PERMISSION:1.0";
static CONST char CORBA_INTERNAL_id[] =   "IDL:omg.org/CORBA/INTERNAL:1.0";
static CONST char CORBA_MARSHAL_id[] =    "IDL:omg.org/CORBA/MARSHAL:1.0";
static CONST char CORBA_INITIALIZE_id[] = "IDL:omg.org/CORBA/INITIALIZE:1.0";
static CONST char CORBA_NO_IMPLEMENT_id[] = 
                                          "IDL:omg.org/CORBA/NO_IMPLEMENT:1.0";
static CONST char CORBA_BAD_TYPECODE_id[] = 
                                          "IDL:omg.org/CORBA/BAD_TYPECODE:1.0";
static CONST char CORBA_BAD_OPERATION_id[] = 
                                         "IDL:omg.org/CORBA/BAD_OPERATION:1.0";
static CONST char CORBA_NO_RESOURCES_id[] = 
                                          "IDL:omg.org/CORBA/NO_RESOURCES:1.0";
static CONST char CORBA_NO_RESPONSE_id[] = 
                                           "IDL:omg.org/CORBA/NO_RESPONSE:1.0";
static CONST char CORBA_PERSIST_STORE_id[] = 
                                         "IDL:omg.org/CORBA/PERSIST_STORE:1.0";
static CONST char CORBA_BAD_INV_ORDER_id[] = 
                                         "IDL:omg.org/CORBA/BAD_INV_ORDER:1.0";
static CONST char CORBA_TRANSIENT_id[] =   "IDL:omg.org/CORBA/TRANSIENT:1.0";
static CONST char CORBA_FREE_MEM_id[] =    "IDL:omg.org/CORBA/FREE_MEM:1.0";
static CONST char CORBA_INV_IDENT_id[] =   "IDL:omg.org/CORBA/INV_IDENT:1.0";
static CONST char CORBA_INV_FLAG_id[] =    "IDL:omg.org/CORBA/INV_FLAG:1.0";
static CONST char CORBA_INTF_REPOS_id[] =  "IDL:omg.org/CORBA/INTF_REPOS:1.0";
static CONST char CORBA_BAD_CONTEXT_id[] = "IDL:omg.org/CORBA/BAD_CONTEXT:1.0";
static CONST char CORBA_OBJ_ADAPTER_id[] = "IDL:omg.org/CORBA/OBJ_ADAPTER:1.0";
static CONST char CORBA_DATA_CONVERSION_id[] = 
                                       "IDL:omg.org/CORBA/DATA_CONVERSION:1.0";
static CONST char CORBA_OBJECT_NOT_EXIST_id[] = 
                                      "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0";



typedef struct yotdcx yotdcx;
typedef struct yotcx yotcx;


struct yotcx
{
  yotdcx    *tdcx;		
  ysevt	    *sems[2];		
  ysle	    *le;		
};


struct yotdcx
{
  yotcx	    tcx;		
  ysque	    *q;			
  ysmtx	    mtx;		
  yslst	    *tlst;		
  ub4	    peak;		
  sword	    mint;		
  sword	    maxt;		
  sword	    keept;		
  sword	    navail;		
  yscv	    cv;			
  yosvcl    svc;		
};


STATICF void yoSetImplInt(CONST ysid *intf, CONST char *impl, yostub *stubs,
                          dvoid *impldef, yodir dir, yoload loader,
                          boolean stateless, dvoid *state);
STATICF boolean yoIsObjDown(yoctx *ctx, yoo *ref, yoimp **imp);
STATICF void yoReqHB(dvoid *usrp, CONST ysid *exid, dvoid *arg,  size_t argsz);
STATICF void yoReqObjInvalid(yoctx *ctx, yosreq *req, yoreqsts sts);
STATICF void yoReqDispatch(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           size_t argsz);
STATICF boolean yoBuiltInOp(yoctx *ctx, yosreq *req, boolean objdown);
STATICF void yoIsABuiltIn(yoctx *ctx, yosreq *req, CONST char *intf);
STATICF void yoReqReply(yoctx *ctx, yosreq *req, CONST ysid *exid, dvoid *obj,
                        yoreqsts completed);
STATICF void yoSRepSndHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           size_t argsz);
STATICF void yoMethodStatsUpdate(yosreq *req, yort_methodInfo *mi);
STATICF void yoSendAddActiveReqs(yoctx *ctx, yslst *actq);
STATICF void yoSndActHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           size_t argsz);
STATICF void yoSendDestActiveReqs(yoctx *ctx, yslst *deactq);
STATICF void yoSndDestActHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                              size_t argsz);
STATICF void yoImplStateDelta(yoctx *ctx, yoimp *imp, ub4 nstate);
STATICF void yoAddImp(yoctx *ctx, yoimp *imp);
STATICF void yoCopyRest(ysmhp *hp, yosx *x, ysbv *obv, sword onbv, ysbv **bv,
                        sword *nbv);
STATICF void yoAdminCb(CONST ysid *intf, CONST ysid *impl, boolean stateless,
                       ub4 ostate, ub4 nstate, dvoid *usrp);

STATICF void yoThreadShutdown(dvoid *usrp, const ysid *exit, dvoid *arg,
			      size_t argsz);
STATICF void yoWorkThread(dvoid *usrp);
STATICF void yoThreadAdd(yotdcx *tdcx, yotcx *tcx);
STATICF void yoThreadStart(yotdcx *tdcx);
STATICF CONST ysid *yoExCorbaSys(CONST ysid *exid, ub4 *minor, boolean *corba);

void yoSetImpl(CONST ysid *intf, CONST char *impl, yostub *stubs,
               dvoid *impldef, yoload loader, boolean stateless, dvoid *state)
{
  yoSetImplInt(intf,impl,stubs,impldef,(yodir)0,loader,stateless,state);
}

STATICF void yoSetImplInt(CONST ysid *intf, CONST char *impl, yostub *stubs,
                          dvoid *impldef, yodir dir, yoload loader,
                          boolean stateless, dvoid *state)
{
  yoctx *ctx;
  yoimp *noreg imp;
  yostbb *s;
  ub4 mcnt;
  yort_methodInfo *mi;

  NOREG(imp);

  ctx = yoCtx;
  if(!impl) impl = ysProgName();

  if(yoFindImp(ctx,intf,impl,FALSE))                  
    yseThrow(YO_EX_DUPLICATE);

  intf = (ysid *)yoGetStr(ctx,ysidToStr(intf));
  impl = yoGetStr(ctx,impl);

  mcnt = 0;
  if(stubs)
    for(s = stubs->stuba; s->opernm; s++, mcnt++);

  imp = (yoimp *)ysmGlbAlloc(sizeof(yoimp),"yoimp");
  imp->minfo._buffer = (yort_methodInfo *) 0;

  yseTry
  {
    imp->minfo._length = imp->minfo._maximum = mcnt;
    if(mcnt)
      imp->minfo._buffer = (yort_methodInfo *)
        ysmGlbAlloc((size_t)(sizeof(yort_methodInfo)*mcnt),"yort_methodInfo");

    imp->flags = stateless ? YOIMPF_STLESS : 0;
    imp->state = YOIMP_DN;                            
    imp->nstate = YOIMP_DN;
    imp->deltaqe = (ysle *)0;

    imp->intf = intf;
    imp->impl = impl;
    imp->stubs = stubs;
    imp->impldef = impldef;
    imp->dir = dir;
    imp->loader = loader;
    imp->usrst = state;
    imp->q = (ysque *) 0;

    if(stubs)
      for(s = stubs->stuba, mi = imp->minfo._buffer; s->opernm; s++, mi++)
      {
        mi->name_yort_methodInfo = (char *) s->opernm;
        mi->cnt_yort_methodInfo = 0;
        mi->lastTimeMs_yort_methodInfo = 0;
        mi->maxTimeMs_yort_methodInfo = 0;
        mi->avgTimeMs_yort_methodInfo = 0;
      }
    CLRSTRUCT(imp->iinfo);
    imp->iinfo.self_yort_implInfo = (yort_impl) 0;
    imp->iinfo.intf_yort_implInfo = (char *) ysidToStr(imp->intf);
    imp->iinfo.impl_yort_implInfo = (char *) imp->impl;
    imp->iinfo.operStatus_yort_implInfo = yort_SvcStDown;
    imp->iinfo.adminStatus_yort_implInfo = yort_SvcStRun;
    imp->iinfo.implFlags_yort_implInfo =
      stateless ? yort_stateless_implFlag : 0;
    imp->iinfo.implFlags_yort_implInfo |=
      loader ? yort_psf_implFlag : 0;

    imp->admcb = yoAdminCb;
    imp->admcbup = (dvoid *) 0;
    yoAddImp(ctx,imp);
  }
  yseCatchAll
  {
    if(imp->minfo._buffer) ysmGlbFree((dvoid *) imp->minfo._buffer);
    ysmGlbFree((dvoid *)imp);
    yseRethrow;
  }
  yseEnd;
}

void yoSetImplAdmCb(CONST ysid *intf, CONST ysid *impl, yoimpadm admcb,
                    dvoid *usrp)
{
  yoctx *ctx;
  yoimp *imp;

  ctx = yoCtx;
  if(!impl) impl = ysProgName();

  
  imp = yoFindImp(ctx,intf,impl,FALSE);
  if(!imp)
    yseThrow(YO_EX_NOIMPL);

  if(!admcb)
  {
    imp->admcb = yoAdminCb;
    imp->admcbup = (dvoid *) 0;
  }
  else
  {
    imp->admcb = admcb;
    imp->admcbup = usrp;
  }
}

dvoid *yoCreate(CONST ysid *intf, CONST char *impl, yoRefData *id,
                 CONST char *ignored, dvoid *state)
{
  return (dvoid *)yoCreateOID(intf,impl,id,state,YOSTID_INV);
}

void yoDispose(dvoid *ref)
{
  yoctx *ctx;
  yoo *r;

  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  ctx = yoCtx;
  r = (yoo *) ref;

  if(bit(r->flags,YOOFL_INVALID) || !r->key || !r->addr ||
     !yotAddrEq(r->addr,ctx->rrpaddr))
    yseThrow(YO_EX_BADOBJ);

  bis(r->flags,YOOFL_INVALID);
  r->ucnt++;               
  yoRelease(ref);
}

yoRefData *yoGetId(dvoid *ref)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  return &((yoo *)ref)->id;
}

void yoFreeId(yoRefData *id )
{
  
}

dvoid *yoGetState(dvoid *ref)
{
  yoo *r = (yoo *) ref;

  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);
  if(r->key == YOSTID_INV)
    yseThrow(YO_EX_BADOBJ);

  if(r->imp && 
     (r->imp->flags & YOIMPF_STLESS) == YOIMPF_STLESS)
    yseThrow(YO_EX_STATELESS);

  return r->state;
}

void yoSetState(dvoid *ref, dvoid *state)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  ((yoo *)ref)->state = state;
}

dvoid *yoGetImplState(dvoid *ref)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  if(!((yoo *)ref)->imp)
    yseThrow(YO_EX_BADOBJ);

  return ((yoo *)ref)->imp->usrst;
}

dvoid *yoGetCaller(void)
{
  yoctx *ctx;
  ysle *e;
  yslst *dspstk;
  yota *addr;

  ctx = yoCtx;
  dspstk = (yslst *) ysThrKeyGet(ctx->dspreq);
  if(dspstk && (e = ysLstHead(dspstk)))
    addr = ((yosreq *)ysLstVal(e))->md->addr;
  else
    addr = ctx->rrpaddr;

  return (dvoid *)yoRefCreate(ctx,yort_proc__id,(char *)0,(yoRefData *)0,
                              YOSTID_YORT,yotAddrDup(addr),(dvoid*)0,FALSE);
}

ysque *yoQueCreate(CONST char *name)
{
  yoctx *ctx;
  ysque *q;
  yoqi  *qi;

  ctx = yoCtx;

  qi = (yoqi *) ysmGlbAlloc(sizeof(yoqi),yoTagQueInfo);
  q =  ysQueCreate((dvoid *)qi);
  qi->or = yoCreate(yort_queue__id,yoGetImplementation((dvoid *)ctx->yort),
                      (yoRefData *)0,(char *)0,(dvoid *)q);
  qi->name = name ? yoGetStr(ctx,name) : (char *) 0;
  qi->qdl = ysLstCreate();
  qi->yoqle = ysLstEnq(ctx->yoques,(dvoid *)q);

  return q;
}

void yoQueDestroy(ysque *q)
{
  yoctx *ctx;
  yoqi *qi;

  qi = (yoqi *) ysQueGetUsrp(q);
  ysmCheck((dvoid *)qi,yoTagQueInfo);

  ctx = yoCtx;

  if(ysLstCount(qi->qdl))
    yseThrow(YS_EX_BADPARAM);

  DISCARD ysLstRem(ctx->yoques,qi->yoqle);
  ysQueDestroy(q);
  ysLstDestroy(qi->qdl,(ysmff )0);
  if(qi->name)
    yoFreeStr(ctx,qi->name);
  yoDispose(qi->or);
  yoRelease(qi->or);
  ysmGlbFree((dvoid *)qi);
}

void yoService(ysque *q)
{
  yoctx  *ctx;
  ysevt  *sems[2];
  ysevt  *noreg s;
  yosvcl  svc;
  yoqi   *qi;
  yocur	 *cur;

  NOREG(s);

  ctx = yoCtx;
  if(!q)                                         
    q = ctx->reqq;

  qi = (yoqi *) ysQueGetUsrp(q);
  ysmCheck((dvoid *)qi,yoTagQueInfo);

  
  yoCurDestroy();

  svc.q = q;
  svc.or = yoCreate(yort_dispatcher__id,
                    yoGetImplementation((dvoid *)ctx->yort),
                    (yoRefData *)0,(char *)0,(dvoid *)&svc);
  svc.sem = ysSemCreate((dvoid *)0);
  svc.count = 0;
  svc.admst = yort_SvcStRun;
  svc.svcle = ysLstEnq(ctx->svclps,(dvoid *) &svc);
  svc.qdle = ysLstEnq(qi->qdl, (dvoid *) &svc);


  s = (ysevt *) 0;
  sems[1] = svc.sem;
  yseTry
    while(TRUE)
    {
      while(!ysSemTest(svc.sem) && ysSvcPending(q))
      {
        DISCARD ysSvcNext(q);
        svc.count++;
      }
      if(ysSemTest(svc.sem))
      {
        break;                                                       
      }
      else
      {
        sems[0] = s = ysSemCreate((dvoid *) 0);
        ysSvcNotify(q, s);
        DISCARD ysSemOrW(YSTM_INFINITE, 2, sems);      
        ysSemDestroy(s);
        s = (ysevt *) 0;
      }
    }
  yseFinally
  {
    if(s)
      ysSemDestroy(s);

    DISCARD ysLstRem(qi->qdl,svc.qdle);
    DISCARD ysLstRem(ctx->svclps,svc.svcle);
    ysSemDestroy(svc.sem);
    yoDispose(svc.or);
    yoRelease(svc.or);
  }
  yseEnd;
}

void yoThreadService(ysque *q, sword mint, sword keept, sword maxt)
{
  yoctx  *ctx;
  yotdcx *tdcx; 
  yoqi   *qi;

  if((keept && keept < mint) || (maxt && maxt < mint))
    yseThrow(YS_EX_BADPARAM);

  ctx = yoCtx;
  if(!q)			
    q = ctx->reqq;

  qi = (yoqi *) ysQueGetUsrp(q);
  ysmCheck((dvoid *)qi,yoTagQueInfo);

  
  yoCurDestroy();

  tdcx = (yotdcx*)ysmGlbAlloc(sizeof(*tdcx), yotdcx_tag);

  
  tdcx->q = q;
  ysMtxCreate(&tdcx->mtx, YSMTXTYPE_NORMAL);
  ysCondCreate(&tdcx->cv);
  tdcx->tlst = ysLstCreate();
  tdcx->peak = 0;
  tdcx->mint = mint;
  tdcx->maxt = maxt;
  tdcx->keept = keept;

  
  yoThreadAdd(tdcx, &tdcx->tcx);

  
  tdcx->svc.or = yoCreate(yort_dispatcher__id,
                          yoGetImplementation((dvoid *)ctx->yort),
			  (yoRefData *)0,(char *)0,(dvoid *)&tdcx->svc);
  tdcx->svc.sem = ysEvtCreate(yoThreadShutdown, (dvoid*)tdcx, (ysque*)0, TRUE);
  tdcx->svc.count = 0;
  tdcx->svc.admst = yort_SvcStRun;
  tdcx->svc.svcle = ysLstEnq(ctx->svclps,(dvoid *) &tdcx->svc);
  tdcx->svc.qdle = ysLstEnq(qi->qdl, (dvoid *) &tdcx->svc);

  ysMtxLock(&tdcx->mtx);

  
  while(ysLstCount(tdcx->tlst) <= (ub4) tdcx->mint)
    yoThreadStart(tdcx);

  yseTry
  {
    

    while(!ysSemTest(tdcx->tcx.sems[0]))
    {
      if(tdcx->navail ||
	 (tdcx->maxt && ysLstCount(tdcx->tlst) > (ub4) tdcx->maxt)) 
	ysCondWait(&tdcx->cv, &tdcx->mtx);

      

      if(ysSemTest(tdcx->tcx.sems[0]))
	break;

      

      if(!tdcx->navail &&
	 (!tdcx->maxt || ysLstCount(tdcx->tlst) <= (ub4)tdcx->maxt))
	yoThreadStart(tdcx);
    }
  }
  yseFinally
  {
    
    DISCARD ysLstRem(qi->qdl,tdcx->svc.qdle);
    DISCARD ysLstRem(ctx->svclps,tdcx->svc.svcle);
    ysSemDestroy(tdcx->svc.sem);
    yoDispose(tdcx->svc.or);
    yoRelease(tdcx->svc.or);

    
    DISCARD ysLstRem(tdcx->tlst, tdcx->tcx.le);

    
    while(ysLstCount(tdcx->tlst))
      ysCondWait(&tdcx->cv, &tdcx->mtx);

    ysMtxDestroy(&tdcx->mtx);
    ysSemDestroy(tdcx->tcx.sems[0]);
    ysCondDestroy(&tdcx->cv);
    ysLstDestroy(tdcx->tlst, (ysmff)0);

    ysmGlbFree((dvoid*)tdcx);
  }
  yseEnd;
}


void yoShutdown(ysque *q)
{
  yoqi *qi;
  ysle *e;

  if(!q)                                         
    q = yoCtx->reqq;

  qi = (yoqi *) ysQueGetUsrp(q);
  ysmCheck((dvoid *)qi,yoTagQueInfo);

  for(e = ysLstHead(qi->qdl); e; e = ysLstNext(e))
    ysTrigger(((yosvcl *)ysLstVal(e))->sem,(ysid *)0,(dvoid *)0,(size_t)0);
}

ysque *yoDefQue(void)
{
  return yoCtx->reqq;
}

void yoImplReady(CONST ysid *intf, CONST char *impl, ysque *q)
{
  yoctx *ctx;
  yoimp *imp;

  if(q)
    ysmCheck(ysQueGetUsrp(q),yoTagQueInfo);

  ctx = yoCtx;
  if(!impl) impl = ysProgName();

  
  imp = yoFindImp(ctx,intf,impl,FALSE);
  if(!imp)
    yseThrow(YO_EX_NOIMPL);


  
  imp->q = q;

  if((imp->flags & YOIMPF_STLESS) == YOIMPF_STLESS)
    yoImplStateDelta(ctx,imp,YOIMP_RDY);
  else
    imp->state = imp->nstate = YOIMP_RDY;

  if(!imp->iinfo.self_yort_implInfo)
  {
    yort_impl iiref;

    iiref = (yort_impl) yoCreate(yort_impl__id,
                                 yoGetImplementation((dvoid *)ctx->yort),
                                 (yoRefData *)0,(char *)0,(dvoid *)imp);

    imp->iinfo.self_yort_implInfo = iiref;
    imp->iinfo.upTimeCs_yort_implInfo = yoGetUpTimeCs();

    DISCARD ysLstEnq(ctx->iirefl,(dvoid *)iiref);
  }

  imp->iinfo.operStatus_yort_implInfo = yort_SvcStRun;
  imp->iinfo.operStatusChanged_yort_implInfo = yoGetUpTimeCs();

  bic(imp->iinfo.implFlags_yort_implInfo,yort_suspended_implFlag);

  if(!bit(ctx->flags,YOCTXFL_SNTYORT))
    bis(ctx->flags,YOCTXFL_SNDYORT);

}

void yoImplDeactivate(CONST ysid *intf, CONST char *impl)
{
  yoctx *ctx;
  yoimp *imp;

  ctx = yoCtx;
  if(!impl) impl = ysProgName();

  
  imp = yoFindImp(ctx,intf,impl,FALSE);
  if(!imp)
    yseThrow(YO_EX_NOIMPL);

  imp->iinfo.operStatus_yort_implInfo = yort_SvcStDown;
  imp->iinfo.operStatusChanged_yort_implInfo = yoGetUpTimeCs();

  if((imp->flags & YOIMPF_STLESS) == YOIMPF_STLESS)
    yoImplStateDelta(ctx,imp,YOIMP_DN);
  else
    imp->state = imp->nstate = YOIMP_DN;
  bic(imp->iinfo.implFlags_yort_implInfo,yort_suspended_implFlag);
}

void yoImplSuspend(CONST ysid *intf, CONST char *impl)
{
  yoctx *ctx;
  yoimp *imp;

  ctx = yoCtx;
  if(!impl) impl = ysProgName();

  
  imp = yoFindImp(ctx,intf,impl,FALSE);
  if(!imp)
    yseThrow(YO_EX_NOIMPL);

  imp->iinfo.operStatus_yort_implInfo = yort_SvcStCongested;
  imp->iinfo.operStatusChanged_yort_implInfo = yoGetUpTimeCs();

  if((imp->flags & YOIMPF_STLESS) == YOIMPF_STLESS)
    yoImplStateDelta(ctx,imp,YOIMP_SSP);
  else
    imp->state = imp->nstate = YOIMP_SSP;
  bis(imp->iinfo.implFlags_yort_implInfo,yort_suspended_implFlag);
}

void yoImplResume(CONST ysid *intf, CONST char *impl)
{
  yoctx *ctx;
  yoimp *imp;

  ctx = yoCtx;
  if(!impl) impl = ysProgName();

  
  imp = yoFindImp(ctx,intf,impl,FALSE);
  if(!imp)
    yseThrow(YO_EX_NOIMPL);

  imp->iinfo.operStatus_yort_implInfo = yort_SvcStRun;
  imp->iinfo.operStatusChanged_yort_implInfo = yoGetUpTimeCs();

  if((imp->flags & YOIMPF_STLESS) == YOIMPF_STLESS)
    yoImplStateDelta(ctx,imp,YOIMP_RDY);
  else
    imp->state = imp->nstate = YOIMP_RDY;
  bic(imp->iinfo.implFlags_yort_implInfo,yort_suspended_implFlag);
}

void yoObjListen(dvoid *ref, ysque *q)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);
  if(q)
    ysmCheck(ysQueGetUsrp(q),yoTagQueInfo);

  if(!((yoo *)ref)->imp)
    yseThrow(YO_EX_BADOBJ);

  ((yoo *)ref)->refq = q;
}

void yoObjDeactivate(dvoid *ref)
{
  if(!ref)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck(ref,yoTagObjRef);

  

  yoDispose(ref);
}

void yodsSetImpl(CONST ysid *intf, CONST char *impl, yodir impfunc,
                 yoload loader, boolean stateless, dvoid *state)
{
  yoSetImplInt(intf,impl,(yostub *)0,(dvoid *)0,impfunc,loader,stateless,
               state);
}

dvoid **yodsParams(yosreq *req, yopar *parms)
{
  req->parms = parms;
  req->args = yoxGetReqParms(req->md->x,req->parms,req->orlst);

  return req->args;
}

void yodsReturn(yosreq *req, dvoid *value, size_t size)
{
  if(!req->args) yseThrow(YO_EX_BADOPER);
  DISCARD memcpy(req->args[0],value,size);
}


void yodsException(yosreq *req, CONST ysid *exid, dvoid *obj, size_t size)
{
  yseThrow(YO_EX_UNIMPLEMENTED);
}

void yodsReSendReq(yosreq *req, CONST dvoid *or, yoenv *ev, ysevt *uevt)
{
  yoctx *ctx;
  ysbv *bv = (ysbv *) 0;
  sword nbv = 0;

  if(!or)
    yseThrow(YS_EX_BADPARAM);
  ysmCheck((dvoid *)or,yoTagObjRef);

  ctx = yoCtx;
  yoCopyRest(ctx->sndhp,req->md->x, req->md->bv, req->md->nbv, &bv, &nbv);
  yoSndReq(ctx,(yoo *)or,ev,req->hdr.op,req->hdr.resp,uevt,0,
	   (yopar *)0,(dvoid **)0,bv,nbv);
  ysmGlbFree((dvoid *)bv);
}

void yodsFreeRep(yodsrep *rep)
{
  if(rep->md) yoFreeMsgDesc(yoCtx->rcvhp,rep->md);
  ysmGlbFree((dvoid *) rep);
}

void yodsProxyRep(yosreq *req, yodsrep *rep)
{
  yosrep *srep;
  ysbv *bv;
  sword nbv;

  if(req->hdr.resp)
  {
    yoctx *ctx;

    ctx = yoCtx;
    yoCopyRest(ctx->sndhp, rep->md->x, rep->md->bv, req->md->nbv,&bv,&nbv);
    srep = yoSRepCreate(ctx,req,(ub4)rep->hdr.sts);
    yoSRepSend(ctx,srep,bv,nbv);
    ysmGlbFree((dvoid *)bv);
  }
  req->hdr.resp = 0;
  yodsFreeRep(rep);
}


yoo *yoCreateOID(CONST ysid *intf, CONST char *impl, yoRefData *id,
                 dvoid *state, ub4 oid)
{
  yoctx *ctx;
  yoo *ref;
  yoo r;
  ub4 key;

  ctx = yoCtx;
  if(!impl) impl = ysProgName();

  if(intf)
    intf = (ysid *) yoGetStr(ctx,ysidToStr(intf));
  if(impl)
    impl = (char *) yoGetStr(ctx,impl);

  CLRSTRUCT(r);
  r.addr = ctx->rrpaddr;

  if(oid == YOSTID_INV)
  {
    
    key = ctx->stateid;
    do
    {
      if(!(++ctx->stateid)) ctx->stateid = YOSTID_BASE;
      r.key = ctx->stateid;
    }
    while(yoGetRef(ctx,r) != (yoo *)0);
  }
  else
  {
    r.key = oid;
    if(yoGetRef(ctx,r))                               
      ysePanic(YO_EX_INTERNAL);
    key = oid;
  }

  ref = yoRefCreate(ctx,intf,impl,id,key,yotAddrDup(ctx->rrpaddr),
                    state,TRUE);
  if(!ref->imp)                                         
  {
    yoRelease((dvoid *)ref);
    yseThrow(YO_EX_NOIMPL);
  }
  return ref;
}

boolean yoRunDeltaQ(yoctx *ctx)
{
  yslst *actq;
  yslst *deactq;
  ysle *e;
  ysle *ne;
  yoimp *imp;
  boolean didstuff = FALSE;

  actq = ysLstCreate();
  deactq = ysLstCreate();

  for(e = ysLstHead(ctx->deltaq); e; e = ne)
  {
    ne = ysLstNext(e);
    imp = (yoimp *) ysLstVal(e);
    if(imp->state == imp->nstate)
    {
      DISCARD ysLstRem(ctx->deltaq,e);
      imp->deltaqe = (ysle *) 0;
    }
    else if((imp->state == YOIMP_RDY || imp->state == YOIMP_SSP)
            && imp->nstate == YOIMP_DN)
    {
      DISCARD ysLstEnq(deactq,(dvoid *)imp);
      imp->state = YOIMP_DN_WT;
    }
    else if((imp->state == YOIMP_DN || imp->state == YOIMP_SSP)
            && imp->nstate == YOIMP_RDY)
    {
      DISCARD ysLstEnq(actq,(dvoid *)imp);
      imp->state = YOIMP_RDY_WT;
    }
    else if(imp->state == YOIMP_RDY && imp->nstate == YOIMP_SSP)
    {
      DISCARD ysLstEnq(actq,(dvoid *)imp);
      imp->state = YOIMP_SSP_WT;
    }
  }

  if(ysLstCount(actq) ||
     (bit(ctx->flags,YOCTXFL_SNDYORT) && !bit(ctx->flags,YOCTXFL_SNDYORT_WT)))
  {
    yoSendAddActiveReqs(ctx,actq);
    didstuff = TRUE;
  }
  else
    ysLstDestroy(actq,(ysmff) 0);

  if(ysLstCount(deactq))
  {
    yoSendDestActiveReqs(ctx,deactq);
    didstuff = TRUE;
  }
  else
    ysLstDestroy(deactq,(ysmff) 0);

  return didstuff;
}

struct yoarq
{
  yslst *q;
  yoenv ev;
};
typedef struct yoarq yoarq;

STATICF void yoSendAddActiveReqs(yoctx *ctx, yslst *actq)
{
  ysle  *e;
  ub4 cnt;
  yort_procInfo noreg ypi;
  ydyo_activeInfoList *noreg ail;
  ydyo_activeInfo *ai;
  ysevt *noreg evt;
  yoimp *imp;
  yoarq *arq;

  NOREG(ypi);
  NOREG(ail);
  NOREG(evt);

  CLRSTRUCT(ypi);
  ail = (ydyo_activeInfoList *) 0;
  evt = (ysevt *) 0;

  cnt = ysLstCount(actq);                  

  yseTry
  {
    arq = (yoarq *) ysmGlbAlloc(sizeof(yoarq),"yoarq");
    arq->q = actq;
    yoEnvInit(&arq->ev);

    yortGetProcInfo(ctx, (yort_procInfo *)&ypi);

    ail = (ydyo_activeInfoList *) ysmGlbAlloc(sizeof(ydyo_activeInfoList),
                                             "ydyo_activeInfoList");
    ail->_buffer = (ydyo_activeInfo *) 0;

    ail->_maximum = cnt;
    if(cnt)
    {
      ail->_buffer= ai =
        (ydyo_activeInfo *)ysmGlbAlloc((size_t)(sizeof(ydyo_activeInfo)*cnt),
                                       "ydyo_activeInfo");

      for(e = ysLstHead(actq) ; e; e = ysLstNext(e))
        if((imp = (yoimp *)ysLstVal(e)))
        {
          ai->self_ydyo_activeInfo = (ydim_active) 0;
          ai->intf_ydyo_activeInfo = (char *) ysidToStr(imp->intf);
          ai->impl_ydyo_activeInfo = (char *) imp->impl;
          ai->yort_ydyo_activeInfo = (yort_proc) ctx->yort;
          ai->yortImpl_ydyo_activeInfo =(yort_impl)0;
          ai->implFlags_ydyo_activeInfo = imp->iinfo.implFlags_yort_implInfo;
          ai++;
        }
      ail->_length = ai - ail->_buffer;
    }
    else
      ail->_length = 0;

    bis(ctx->flags,YOCTXFL_SNDYORT_WT);
    evt = ysEvtCreate(yoSndActHdlr,(dvoid *)arq,ctx->evtq,FALSE);
    ydyo_imr_addActiveGlobal_nw((ydyo_imr)ctx->ydimref, &arq->ev,
                                (yort_procInfo *)&ypi, ail,
				evt);
  }
  yseCatchAll
  {
    if(evt) ysEvtDestroy(evt);
    yoSndActHdlr((dvoid *)&arq,yseExid,(dvoid *)0,(size_t)0);
  }
  yseEnd;

  if(ail)
  {
    if(ail->_buffer) ysmGlbFree((dvoid *)ail->_buffer);
    ysmGlbFree((dvoid *)ail);
  }

  yotkFreeVal(YCTC_yort_procInfo,(dvoid *)&ypi,yoFree);    
}


STATICF void yoSndActHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           size_t argsz)
{
  yoctx *ctx;
  yoarq *arq;
  yoimp *imp;

  ctx = yoCtx;
  arq = (yoarq *) usrp;

  if(exid)
  {
    ysRecord(YOSRV_ERR(1), YSLSEV_ERR, (char *)0, YSLSTR(exid), YSLEND);

    if(ysidEq(exid,YT_EX_BADADDR) || ysidEq(exid,YT_EX_BROKEN) ||
       ysidEq(exid,YO_EX_BADOBJ))
    {
      yoDeadORBD(ctx);
    }
  }
  else
  {
    bis(ctx->flags,YOCTXFL_SNTYORT);
    bic(ctx->flags,YOCTXFL_SNDYORT);
  }
  bic(ctx->flags,YOCTXFL_SNDYORT_WT);

  
  while((imp = (yoimp *)ysLstDeq(arq->q)))
  {
    if(exid)
      imp->state = imp->pstate;
    else
    {
      if(imp->state == YOIMP_RDY_WT)
        imp->state = YOIMP_RDY;
      else if(imp->state == YOIMP_SSP_WT)
        imp->state = YOIMP_SSP;
      else
        ysePanic(YO_EX_INTERNAL);
    }

    if(imp->state == imp->nstate && ctx->deltaq && imp->deltaqe)
    {
      DISCARD ysLstRem(ctx->deltaq,imp->deltaqe);
      imp->deltaqe = (ysle *) 0;
    }
  }

  
  ysLstDestroy(arq->q, (ysmff) 0);
  yoEnvFree(&arq->ev);
  ysmGlbFree((dvoid *)arq);
}

STATICF void yoSendDestActiveReqs(yoctx *ctx, yslst *deactq)
{
  ysle  *e;
  ub4    cnt;
  ydyo_activeInfoList *noreg ail;
  ydyo_activeInfo *ai;
  ysevt *noreg evt;
  yoimp *imp;
  yoarq *noreg arq;

  NOREG(ail);
  NOREG(evt);
  NOREG(arq);

  arq = (yoarq *) 0;
  cnt = ysLstCount(deactq);                
  if(!cnt) return;

  ail = (ydyo_activeInfoList *) 0;
  evt = (ysevt *) 0;

  yseTry
  {
    arq = (yoarq *) ysmGlbAlloc(sizeof(yoarq),"yoarq");
    arq->q = deactq;
    yoEnvInit(&arq->ev);

    ail = (ydyo_activeInfoList *) ysmGlbAlloc(sizeof(ydyo_activeInfoList),
                                           "ydyo_activeInfoList");
    ail->_buffer = (ydyo_activeInfo *) 0;

    ail->_maximum = cnt;
    ail->_buffer= ai =
      (ydyo_activeInfo *)ysmGlbAlloc((size_t)(sizeof(ydyo_activeInfo)*cnt),
                                    "ydyo_activeInfo");

    for(e = ysLstHead(deactq) ; e; e = ysLstNext(e))
      if((imp = (yoimp *)ysLstVal(e)))
      {
        ai->self_ydyo_activeInfo = (ydim_active) 0;
        ai->intf_ydyo_activeInfo = (char *) ysidToStr(imp->intf);
        ai->impl_ydyo_activeInfo = (char *) imp->impl;
        ai->yort_ydyo_activeInfo = (yort_proc)  ctx->yort;
        ai->yortImpl_ydyo_activeInfo = (yort_impl)0;
        ai->implFlags_ydyo_activeInfo = imp->iinfo.implFlags_yort_implInfo;
        ai++;
      }
    ail->_length = ai - ail->_buffer;

    evt = ysEvtCreate(yoSndDestActHdlr,(dvoid *)arq,ctx->evtq,FALSE);
    ydyo_imr_destroyActiveGlobal_nw((ydyo_imr)ctx->ydimref, &arq->ev, ail,
				    evt);

    evt = (ysevt *) 0;
  }
  yseCatchAll
  {
    if(evt) ysEvtDestroy(evt);
    yoSndDestActHdlr((dvoid *)arq, yseExid, (dvoid *)0, (size_t)0);
  }
  yseEnd;

  if(ail)
  {
    if(ail->_buffer) ysmGlbFree((dvoid *)ail->_buffer);
    ysmGlbFree((dvoid *)ail);
  }
}


STATICF void yoSndDestActHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                           size_t argsz)
{
  yoctx *ctx;
  yoimp *imp;
  yoarq *arq;

  ctx = yoCtx;
  arq = (yoarq *) usrp;

  if(exid)
  {
    ysRecord(YOSRV_ERR(2), YSLSEV_ERR, (char *)0, YSLSTR(exid), YSLEND);

    if(ysidEq(exid,YT_EX_BADADDR) || ysidEq(exid,YT_EX_BROKEN) ||
       ysidEq(exid,YO_EX_BADOBJ))
    {
      yoDeadORBD(ctx);
    }
  }

  
  while((imp = (yoimp *)ysLstDeq(arq->q)))
  {
    if(imp->state != YOIMP_DN_WT)
      ysePanic(YO_EX_INTERNAL);


    if(exid)
      imp->state = imp->pstate;
    else
      imp->state = YOIMP_DN;
    if(imp->state == imp->nstate)
    {
      DISCARD ysLstRem(ctx->deltaq,imp->deltaqe);
      imp->deltaqe = (ysle *) 0;
    }
  }

  
  ysLstDestroy(arq->q, (ysmff) 0);
  yoEnvFree(&arq->ev);
  ysmGlbFree((dvoid *)arq);
}

void yoReqRcv(yoctx *ctx, yomd *md, ub4 reftag)
{
  yosreq *noreg req;
  ysque *q;
  ysevt *noreg evt;
  yoo   *ref;
  yoimp *imp = (yoimp *)0;
  char astr[YOTAMAXLEN];
  yoany idany;
  char *idstr;
  ysle *e;
  boolean objdown;
  yoenv *ev;

  NOREG(req);
  NOREG(evt);

  req = (yosreq *) 0;
  evt = (ysevt *) 0;

  yseTry
  {
    req = (yosreq *)ysmAlloc(ctx->rcvhp,sizeof(yosreq),"yosreq");
    req->type = YOGIMT_REQ;
    req->reftag = reftag;
    yogiGetReqHeader(md->x, &req->hdr);

    sysb8set(&req->start,sysb8zero);
    sysb8set(&req->finish,sysb8zero);
    req->imp = (yoimp *) 0;
    req->parms = (yopar *) 0;
    req->args = (dvoid **) 0;
    req->ltrid = (ysstr *) 0;
    req->orlst = (yslst *) 0;

    req->orlst = ysLstCreate();              

    req->md = md;                             
    if(req->hdr.resp && req->reftag == YOGIIOR_TAG_YO)
    {
      req->hb = ysEvtCreate(yoReqHB, (dvoid *) req, ctx->evtq, TRUE);
      ysTimer(&ctx->reqhb,req->hb);
    }
    else
      req->hb = (ysevt *)0;
    
    ref = req->hdr.ref;
    DISCARD yotAddrToStr(md->addr,astr,sizeof(astr));
    ysRecord(YOSRV_ERR(3), YSLSEV_DEBUG(8), (char *)0,
             YSLSTR(astr), YSLUB4(req->hdr.id),
             YSLSTR(yoStr(ref ? ref->intf : "<badobj>")),
             YSLSTR(yoStr(ref ? ref->impl : "<badobj>")),
             YSLSTR(req->hdr.op), YSLEND);

    objdown = yoIsObjDown(ctx, ref, &imp);

    req->imp = imp;

    if(!yoBuiltInOp(ctx, req, objdown))
    {
      if(objdown)
        yoReqObjInvalid(ctx, req, YOREQ_COMPL_NO);
      else
      {
        q = ref->refq;                                     
        if(!q)
        {
          q = imp->q;                                        
          if(!q)
            q = ctx->reqq;                               
        }
        
        
        idany._type = (yotk *) 0;
        ev = &req->hdr.scxs.ev;
        if(!yoEnvGet(ev,"YOLTRID",&idany) || idany._type != yoTcString)
        {
          char seq[80];
        
          if(idany._type)
            yotkFreeVal(yoTcAny,(dvoid *)&idany,yoFree);

          ysFmtStrl(seq,sizeof(seq),"%d",ctx->ltridseq++);
          req->ltrid = ysStrCreate(ctx->hostname);
          req->ltrid = ysStrApp(req->ltrid,':');
          req->ltrid = ysStrCat(req->ltrid,ctx->pid);
          req->ltrid = ysStrApp(req->ltrid,':');
          req->ltrid = ysStrCat(req->ltrid,seq);
          idstr = ysStrToText(req->ltrid);
          idany._type = (yotk *) yoTcString;
          idany._value = (dvoid *) &idstr;
          yoEnvSet(ev,"YOLTRID",&idany);
        }
        else
        {
          ysthr thrid;

          req->ltrid = ysStrCreate(*(char **)idany._value);
          yotkFreeVal(yoTcAny,(dvoid *)&idany,yoFree);
          if(ysThrSelf(&thrid) == (ysthr *)0)
          {
            for(e = ysLstHead(ctx->actreqs); e; e = ysLstNext(e))
              if(strcmp(ysStrToText(req->ltrid),
                        ysStrToText(((yosreq *)ysLstVal(e))->ltrid)) == 0)
              {
                q = ctx->scq;   
                break;
              }
          }
        }
        
        evt = ysEvtCreate(yoReqDispatch,(dvoid *)req,q,FALSE);
        ysTrigger(evt, (CONST ysid *)0, (dvoid *)0, (size_t)0);
      }
    }
  }
  yseCatchAll
  {
    if(evt) ysEvtDestroy(evt);
    if(req) yoFreeSReq(ctx->rcvhp,req);
    ysRecord(YOSRV_ERR(4), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
  }
  yseEnd;
}

STATICF boolean yoIsObjDown(yoctx *ctx, yoo *ref, yoimp **imp)
{
  yoimp *i = (yoimp *)0;
  boolean objdown;

  if(ref)
  {
    i = ref->imp;
    if(!i)
      i = yoFindImp(ctx, ref->intf, ref->impl, TRUE);
  }
  objdown = (!ref || bit(ref->flags,YOOFL_INVALID) || !i ||
             i->nstate != YOIMP_RDY);
  if(imp)
    *imp = i;
  return objdown;
}


STATICF void yoReqHB(dvoid *usrp, CONST ysid *exid, dvoid *arg,  size_t argsz)
{
  yoctx  *ctx;
  yosreq *req;
  yosx *x;
  ysbv *bv;
  sword nbv;
  char astr[YOTAMAXLEN];
  yota *addr;
  
  ctx = yoCtx;
  req = (yosreq *) usrp;

  if(req->hb) ysEvtDestroy(req->hb);
  req->hb = ysEvtCreate(yoReqHB, (dvoid *) req, ctx->evtq, TRUE);
  ysTimer(&ctx->reqhb,req->hb);


  x = yosxEncode((size_t)YO_RCVPGSZ,ctx->sndhp);
  yoxPutPing(x, req->hdr.id);
  yosxEncEnd(x,&bv,&nbv);

  addr = yotAddrDup(req->md->addr);
  yotSetAddrPort(addr,YO_HBPORT);

  DISCARD yotAddrToStr(addr,astr,sizeof(astr));
  ysRecord(YOSRV_ERR(5), YSLSEV_DEBUG(8), (char *)0, 
           YSLSTR(astr), YSLUB4(req->hdr.id), YSLEND);

  DISCARD yotSendV(ctx->hbport,addr,bv,nbv,ysEvtDummy());
  ysBvFree(ctx->sndhp,bv,nbv);
  yotAddrFree(addr);
}

STATICF void yoReqObjInvalid(yoctx *ctx, yosreq *req, yoreqsts sts)
{
  if(!req->hdr.ref || req->hdr.ref->key)
  {
    yoErrSnd(ctx, req, YO_EX_BADOBJ, sts);
    yoFreeSReq(ctx->rcvhp,req);
  }
  else if(ctx->rtq)
  {
    yoydRouteMsg(req);
  }
  else
  {
    
    
  }
}

void yoLocReqRcv(yoctx *ctx, yomd *md, ub4 reftag)
{
  yosx *x = md->x;
  yosreq *req;

  req = (yosreq *)ysmAlloc(ctx->rcvhp,sizeof(yosreq),"yosreq");
  CLRSTRUCT(*req);
  req->type = YOGIMT_LOCREQ;
  req->reftag = reftag;
  req->md = md;
  req->imp = (yoimp *) 0;
  req->parms = (yopar *) 0;
  req->args = (dvoid **) 0;
  req->ltrid = (ysstr *) 0;
  req->orlst = (yslst *) 0;

  yogiGetLocReqHeader(x, &req->hdr);

  if(yoIsObjDown(ctx,req->hdr.ref,(yoimp **)0))
    yoReqObjInvalid(ctx, req, YOREQ_COMPL_NO);
  else
    yoLocReqReply(ctx, req, YOGILRS_HERE, (yoo *)0);
}

void yoLocReqReply(yoctx *ctx, yosreq *req, ub4 sts, yoo *ref)
{
  yosrep *rep;

  rep = yoSRepCreate(ctx, req, sts);
  switch(sts)
  {
  case YOGILRS_UNKNOWN:
  case YOGILRS_HERE:
    break;
  case YOGILRS_FORWARD:
    yogiPutOR(rep->x, (dvoid *)ref, req->reftag);
    break;
  }
  yoSRepSend(ctx,rep,(ysbv *)0,0);
}


STATICF void   yoReqDispatch(dvoid *usrp, CONST ysid *ignore1,
			     dvoid *ignore2, size_t ignore3)
{
  yoctx  *ctx;
  yosreq *req = (yosreq *) usrp;
  yoimp  *imp = req->imp;
  yostbb *stub;
  yomd   *md;
  yslst  *lst;
  yslst  *dspstk;
  ysle   *are;
  boolean memfree = TRUE;
  yoenv  *ev;
  yocur  *oldcur;
  CONST ysid *exid;
  dvoid *exobj;

  ctx = yoCtx;                                                

  
  if((req->hdr.ref->key && bit(req->hdr.ref->flags,YOOFL_INVALID)) ||
     imp->nstate != YOIMP_RDY)
  {
    yoReqObjInvalid(ctx, req, YOREQ_COMPL_NO);
    return;
  }

  if(!(lst = (yslst *)ysThrKeyGet(ctx->srvmeml)))      
  {
    lst = ysLstCreate();
    DISCARD ysThrKeySet(ctx->srvmeml,(dvoid *)lst);
  }
  else
    memfree = FALSE;         

  if(!(dspstk = (yslst *) ysThrKeyGet(ctx->dspreq)))
  {
    dspstk = ysLstCreate();
    DISCARD ysThrKeySet(ctx->dspreq,(dvoid *)dspstk);
  }
  DISCARD ysLstPush(dspstk,(dvoid *)req);

  
  ysClock(&req->start);
  imp->iinfo.totalInboundAssocs_yort_implInfo++;
  imp->iinfo.inboundAssocs_yort_implInfo++;
  imp->iinfo.lastInbound_yort_implInfo = yoGetUpTimeCs();

  ev = &req->hdr.scxs.ev;
  
  
  oldcur = (yocur *)ysThrKeySet(ctx->cur,(dvoid *)&req->hdr);

  if(imp->stubs)                                                
  {
    for(stub = imp->stubs->stuba; stub->opernm; stub++)  
      if(strcmp(stub->opernm,req->hdr.op) == 0)
        break;
    if(!stub->opernm)
    {
      yoErrSnd(ctx, req, YO_EX_BADOPER, YOREQ_COMPL_NO);
      imp->iinfo.rejectedInbounds_yort_implInfo++;
      goto done;
    }
    req->parms = stub->parms;
    md = req->md;
  }

  are = ysLstEnq(ctx->actreqs,(dvoid *)req);   

  yseTry
  {
    if(imp->stubs)
    {
      yseTry
      {
        req->args = yoxGetReqParms(md->x,req->parms,req->orlst);
      }
      yseCatchAll
      {
        DISCARD ysLstRem(ctx->actreqs,are);        
        yoErrSnd(ctx, req, CORBA_MARSHAL_id, YOREQ_COMPL_NO);
        yseRethrow;
      }
      yseEnd;
      yseTry
        yoFilterRunEx((dvoid *)req->hdr.ref,ev,YOFLTR_SPREOP,
		      (CONST ysid *)0, (dvoid *)0);
      yseCatchAll
      {
        DISCARD ysLstRem(ctx->actreqs,are);        
        yseRethrow;
      }
      yseEnd;
      yseTry
      {
        (*stub->oper)((dvoid *)req->hdr.ref,ev,imp->impldef, req->args);
      }
      yseFinally
      {
	exid = yseExid;
	exobj = yseExobj;
        yseTry
        {
          yoFilterRunEx((dvoid *)req->hdr.ref,ev,YOFLTR_SPOSTOP,exid,exobj);
          ysClock(&req->finish);
        }
        yseFinally
        {
          DISCARD ysLstRem(ctx->actreqs,are);      
        }
        yseEnd;
        if(req->hdr.resp)
          yoReqReply(ctx,req,exid,exobj,YOREQ_COMPL_MAYBE);
        ysed.rth = FALSE;                                   
      }
      yseEnd;
      yoMethodStatsUpdate(req,imp->minfo._buffer + (stub - imp->stubs->stuba));
    }
    else
    {                                                         
      yseTry
        yoFilterRunEx((dvoid *)req->hdr.ref,ev,YOFLTR_SPREOP,
		      (CONST ysid *)0, (dvoid *)0);
      yseCatchAll
      {
        DISCARD ysLstRem(ctx->actreqs,are);        
        yseRethrow;
      }
      yseEnd;
      yseTry
      {
        (*imp->dir)((dvoid *)req->hdr.ref,ev,req->hdr.op,req);
      }
      yseFinally
      {
	exid = yseExid;
	exobj = yseExobj;
        yseTry
        {
          yoFilterRunEx((dvoid *)req->hdr.ref,ev,YOFLTR_SPOSTOP,exid,exobj);
          ysClock(&req->finish);
        }
        yseFinally
        {
          DISCARD ysLstRem(ctx->actreqs,are);      
        }
        yseEnd;
        if(req->hdr.resp)
          yoReqReply(ctx,req,exid,exobj,YOREQ_COMPL_MAYBE);
        ysed.rth = FALSE;                                   
      }
      yseEnd;
    }
  }
  yseCatchAll
  {
    ysRecord(YOSRV_ERR(6), YSLSEV_ERR, (char *)0, YSLSTR(yseExid), YSLEND);
  }
  yseEnd;

 done:
  imp->iinfo.inboundAssocs_yort_implInfo--;

  if(memfree)
    yoFreeSrvrAlloc(ctx);

  
  ysThrKeySet(ctx->cur,(dvoid*)oldcur);

  
  if(ysLstPop(dspstk) != (dvoid *) req)
    ysePanic(YO_EX_INTERNAL);

  
  if(!ysLstCount(dspstk))
  {
    DISCARD ysThrKeySet(ctx->dspreq,(dvoid *)0);
    ysLstDestroy(dspstk,(ysmff) 0);
  }

  yoFreeSReq(ctx->rcvhp,req);                      
  
  yortIdle((dvoid *)ctx,(ysid *)0,(dvoid *)0,(size_t)0);
}

STATICF void yoReqReply(yoctx *ctx, yosreq *req, CONST ysid *exid, 
			dvoid *exobj, yoreqsts completed)
{
  ub4     sts;
  yosrep *rep = (yosrep *)0;
  yosx    *noreg x;
  CONST yotk *extk;
  CONST ysid *tmpid;
  ub4 minor;
  CONST yopar *par;
  CONST ysid  *tkid;
  boolean iscorba;

  NOREG(x);

  extk = (yotk *) 0;
  x = (yosx *) 0;
  if(exid)
  {
    tmpid = yoExCorbaSys(exid, &minor, &iscorba);
    if(tmpid)                                           
    {
      sts = YOGIRS_SYSEX;
      exid = tmpid;
      if(iscorba && exobj)                             
      {
        yosysex *body;
        body = (yosysex *)exobj;
        minor = body->minor;
        completed = body->completed;
      }
    }
    else                                                  
    {
      sts = YOGIRS_USREX;
      if(req->parms)
      {
        for(par = req->parms; par->mode != YOMODE_INVALID; par++)
          if(par->mode == YOMODE_EXCEPT)
          {
            tkid = (ysid *)yotkGetId(par->tk);
            if(tkid && ysidEq(tkid,exid))
            {
              extk = par->tk;                       
              break;
            }
          }
      }
    }
  }
  else
    sts = YOGIRS_NOEX;

  yseTry
  {
    rep = yoSRepCreate(ctx, req, sts);
    x = rep->x;
    if(req->parms)
    {
      if(exid)
      {
        if(sts==YOGIRS_SYSEX)
          yoxPutSysEx(x, exid, completed, minor);
        else
          yoxPutUserEx(x, req->reftag, exid, extk, exobj);
      }
      else
        yoxPutRepParms(x, req->reftag, req->parms, req->args);
    }
    yoSRepSend(ctx, rep, (ysbv *)0, 0);
  }
  yseCatchAll
  {
    if(rep)
      yoSRepDestroy(ctx, rep);
    ysRecord(YOSRV_ERR(7), YSLSEV_CRIT, (char *)0, YSLSTR(yseExid), YSLEND);
  }
  yseEnd;
}

yosrep *yoSRepCreate(yoctx *ctx, yosreq *req, ub4 sts)
{
  yosrep *rep;
  yosx *noreg x;
  ub4 reptype = (ub4)0;

  NOREG(x);

  rep = (yosrep *) ysmAlloc(ctx->sndhp, sizeof(yosrep), "yosrep");
  rep->addr = yotAddrDup(req->md->addr);                    
  rep->x = x = (yosx *)0;
  rep->imp = req->imp;                                     
  rep->op = req->hdr.op;                                   
  CPSTRUCT(rep->hdr.scxs,req->hdr.scxs);     
  rep->hdr.id = req->hdr.id;
  rep->hdr.sts = (ub1)sts;
  rep->md = (yomd *) 0;
  yseTry
  {
    rep->x = x = yosxEncode(YO_RCVPGSZ, ctx->sndhp);
    if(req->reftag != YOGIIOR_TAG_YO)
    {
      yosxPutUB1(x,YO_BYTESEX);                             
      yogiPutIOR(x,(yogiIOR *)0);                  
      yosxAlign(x,16);
    }
    switch(req->type)
    {
    case YOGIMT_REQ:
      reptype = YOGIMT_REP;
      break;
    case YOGIMT_LOCREQ:
      reptype = YOGIMT_LOCREP;
      break;
    default:
      ysePanic(YO_EX_INTERNAL);
    }
    yogiPutMsgHeader(x, (ub1)reptype, &rep->lp);
    switch(reptype)
    {
    case YOGIMT_REP:
      rep->hdr.scxs.upctx = req->hdr.scxs.upctx;
      yogiPutRepHeader(x, req->reftag, &rep->hdr);
      break;
    case YOGIMT_LOCREP:
      yogiPutLocRepHeader(x, &rep->hdr);
      break;
    default:
      ysePanic(YO_EX_INTERNAL);
    }
  }
  yseCatchAll
  {
    if(x)
    {
      ysbv *bv;
      sword nbv;

      yosxEncEnd(x,&bv,&nbv);
      if(bv)
        ysBvFree(ctx->sndhp,bv,nbv);
      rep->x = (yosx *) 0;
    }
    ysmFree(ctx->sndhp, (dvoid *) rep);
    yseRethrow;
  }
  yseEnd;

  return rep;
}

void yoSRepSend(yoctx *ctx, yosrep *rep, ysbv *bv, sword nbv)
{
  yomd   *md;
  ysevt  *evt;
  char    astr[YOTAMAXLEN];
  sb4     replen;
  sword   i,j;
  yosxPos end;
  ub4     glen;
  ub1    *buf;
  yoimp  *imp;
  ub4     id;
  char   *op;

  
  rep->md = md = (yomd *) ysmAlloc(ctx->sndhp, sizeof(yomd), "yomd-rep");
  md->usrp = (dvoid *) ysLstEnq(ctx->replst,(dvoid *)rep);
  md->addr = rep->addr;
  md->x = (yosx *)0;
  md->len = 0;

  yosxGetPos(rep->x,&end);
  glen = yosxGetLength(rep->x,&end,&rep->lp) - 4;
  yosxEncEnd(rep->x,&md->bv,&md->nbv);
  rep->x = (yosx *)0;

  if(bv)
  {
    md->bv = (ysbv *) ysmRealloc(ctx->sndhp,(dvoid *)md->bv,
                                 sizeof(ysbv)*(md->nbv+nbv));
    for(i = md->nbv, j = 0;  j < nbv; i++, j++)
    {
      glen += bv[j].len;
      md->bv[i].len = bv[j].len;
      md->bv[i].buf = bv[j].buf;
    }
    md->nbv += nbv;
  }

  
  buf = md->bv[rep->lp.idx].buf + rep->lp.off;
  sysxPut4(buf,glen);

  
  for(i = 0; i < md->nbv; i++)
    md->len += md->bv[i].len;

  replen = md->len;
  DISCARD yotAddrToStr(md->addr,astr,sizeof(astr));

  
  evt = ysEvtCreate(yoSRepSndHdlr,(dvoid *)rep,ctx->evtq,FALSE);

  if(ctx->cycx)
  {
    yocyBvEncrypt(ctx,md->bv,md->nbv,&bv,&nbv,ctx->sndhp);
    ysBvFree(ctx->sndhp,md->bv,md->nbv);
    md->bv = bv;
    md->nbv = nbv;
  }

  imp = rep->imp;
  op = rep->op;
  id = rep->hdr.id;
  DISCARD yotSendV(ctx->rrport,md->addr,md->bv,md->nbv,evt);
  ysRecord(YOSRV_ERR(8), YSLSEV_DEBUG(8), (char *)0, 
           YSLSTR(astr), YSLUB4(id), YSLUB4(replen),
           YSLSTR(imp ? yoStr(imp->intf) : "<unknown>"),
           YSLSTR(imp ? yoStr(imp->impl) : "<unknown>"),
           YSLSTR(yoStr(op)), YSLEND);
  if(imp)
  {
    imp->iinfo.totalOutboundAssocs_yort_implInfo++;
    imp->iinfo.outboundAssocs_yort_implInfo++;
    imp->iinfo.lastOutbound_yort_implInfo = yoGetUpTimeCs();
  }
}


STATICF void yoSRepSndHdlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
                          size_t argsz)
{
  yoctx  *ctx;
  yosrep *rep;
  
  ctx = yoCtx;
  rep = (yosrep *) usrp;

  if(rep->imp)
    rep->imp->iinfo.outboundAssocs_yort_implInfo--;
  if(exid)
  {
    char    astr[YOTAMAXLEN];

    if(rep->imp)
    {
      rep->imp->iinfo.totalOutboundAssocs_yort_implInfo--;
      rep->imp->iinfo.failedOutbounds_yort_implInfo++;
    }

    DISCARD yotAddrToStr(rep->md->addr,astr,sizeof(astr));
    ysRecord(YOSRV_ERR(13), YSLSEV_WARNING, (char *)0, 
             YSLSTR(astr), YSLUB4(rep->hdr.id),
             YSLSTR(rep->imp ? yoStr(rep->imp->intf) : "<unknown>"),
             YSLSTR(rep->imp ? yoStr(rep->imp->impl) : "<unknown>"),
             YSLSTR(yoStr(rep->op)), YSLEND);
  }

  if(rep->md->usrp) DISCARD ysLstRem(ctx->replst,(ysle *)rep->md->usrp);
  yoFreeMsgDesc(ctx->sndhp, (yomd *) rep->md);
  ysmFree(ctx->sndhp,(dvoid *) rep);
}

void yoSRepDestroy(yoctx *ctx, yosrep *rep)
{
  
}

STATICF void yoMethodStatsUpdate(yosreq *req, yort_methodInfo *mi)
{
  sysb8 delta, tenk;

  
  sysb8sub(&delta,&req->finish,&req->start);
  sysb8ext(&tenk,10000);
  sysb8div(&delta,&delta,&tenk);

  mi->cnt_yort_methodInfo++;
  mi->lastTimeMs_yort_methodInfo = sysb8msk(&delta);
  if(mi->lastTimeMs_yort_methodInfo > mi->maxTimeMs_yort_methodInfo)
    mi->maxTimeMs_yort_methodInfo = mi->lastTimeMs_yort_methodInfo;
  mi->avgTimeMs_yort_methodInfo = (yort_timeMs)
    (((mi->avgTimeMs_yort_methodInfo * (mi->cnt_yort_methodInfo-1)) +
     mi->lastTimeMs_yort_methodInfo) / mi->cnt_yort_methodInfo);
}

STATICF boolean yoBuiltInOp(yoctx *ctx, yosreq *req, boolean objdown)
{
  char *op;
  boolean br = FALSE;
  dvoid *or = (dvoid *)0;
  boolean objret = FALSE;
  yosrep *srep;

  op = req->hdr.op;
  if(strcmp(op,"_not_existant") == 0)
  {
    
    br = objdown;
    
    if(br && req->hdr.ref->key == YOSTID_INV && ctx->rtq)
    {
      
      yoenv ev;

      yoEnvInit(&ev);
      br = !ydyo_imr_exists((ydyo_imr)ctx->ydimref,&ev,
                            (char *)req->hdr.ref->intf,
                            (char *)req->hdr.ref->impl);
      yoEnvFree(&ev);
    }
  }
  else if(strcmp(op,"_interface") == 0)
  {
    yoRefData id;
    CONST char *intf;

    intf = req->hdr.ref->intf;
    if(intf)
    {
      id._length = id._maximum = strlen(intf) + 1;
      id._buffer = (ub1 *)intf;
      or = yoBind("IDL:yr/intfdef:1.0",(char *)0,&id,(char *)0);
    }
    else
      or = (dvoid *)0;
    objret = TRUE;
  }
  else if(strcmp(op,"_implementation") == 0)
  {
    
    or = (dvoid *) 0;
    objret = TRUE;
  }
  else if(strcmp(op,"_is_a") == 0)
  {
    ub4 len;
    char *intf;
    yosx *x;

    x = req->md->x;
    len = yosxGetUB4(x);                                    
    if(len)
    {
      intf = (char *)ysmGlbAlloc((size_t)len,"_is_a_intf");
      yosxCopy(x,(ub1 *)intf,(size_t)len);
      
      yoIsABuiltIn(ctx,req,intf);
      ysmGlbFree((dvoid *)intf);
      return TRUE;
    }
    else
      br = FALSE;
  }
  else
    return FALSE;

  srep = yoSRepCreate(ctx,req,YOGIRS_NOEX);
  if(objret)
  {
    yogiPutOR(srep->x,or,req->reftag);
    yoRelease(or);
  }
  else
    yosxPutUB1(srep->x,br);

  yoSRepSend(ctx,srep,(ysbv *)0,0);

  yoFreeSReq(ctx->rcvhp,req);                      

  return TRUE;
}

STATICF void yoIsABuiltIn(yoctx *ctx, yosreq *req, CONST char *intf)
{
  yoo *r = req->hdr.ref;
  yoimp *imp;
  boolean br = TRUE;
  yosrep *srep;

  if(strcmp(r->intf,intf) != 0)
  {
    imp = r->imp;
    if(!imp)
    {
      imp = yoFindImp(ctx, r->intf, (char *)0, FALSE);
      if(!imp)
      {
        yoReqObjInvalid(ctx,req, YOREQ_COMPL_NO);
        return;
      }
    }
    br = yoIsALocal(imp,intf);
  }

  srep = yoSRepCreate(ctx,req,YOGIRS_NOEX);
  yosxPutUB1(srep->x,(ub1)br);
  yoSRepSend(ctx,srep,(ysbv *)0,0);

  yoFreeSReq(ctx->rcvhp,req);                      
}

boolean yoIsALocal(yoimp *imp, CONST char *intf)
{
  const char * const *bases;
  const char * const *b;
  boolean result = FALSE;

  bases = imp->stubs->bases;
  if(bases)
    for(b = bases; !result && *b; b++)
      result = (strcmp(intf,*b) == 0);

  return result;
}

void yoErrSnd(yoctx *ctx, yosreq *req, CONST ysid *exid, yoreqsts sts)
{
  yosrep *rep;
  char    astr[YOTAMAXLEN];
  ub4 minor;

  if(req->hdr.resp)
  {
    rep = yoSRepCreate(ctx, req, YOGIRS_SYSEX);
    exid = yoExCorbaSys(exid, &minor, (boolean*)0);
    if(!exid)
      ysePanic(YO_EX_INTERNAL);
    yoxPutSysEx(rep->x, exid, sts, minor);
    yoSRepSend(ctx,rep,(ysbv *)0,0);
  }

  DISCARD yotAddrToStr(req->md->addr,astr,sizeof(astr));
  ysRecord(YOSRV_ERR(9), YSLSEV_DEBUG(8), (char *)0, YSLSTR(astr),
           YSLSTR((char *)exid), YSLUB4(req->hdr.id), YSLEND);
}

STATICF void yoImplStateDelta(yoctx *ctx, yoimp *imp, ub4 nstate)
{
  if(imp->nstate != nstate)
  {
    imp->nstate = nstate;
    if(imp->state == nstate)
    {
      if(imp->deltaqe)
      {
        DISCARD ysLstRem(ctx->deltaq,imp->deltaqe);
        imp->deltaqe = (ysle *) 0;
      }
    }
    else
    {
      if(!imp->deltaqe)
      {
        imp->pstate = imp->state;
        imp->deltaqe = ysLstEnq(ctx->deltaq,(dvoid *)imp);
      }
    }
  }
}

STATICF void yoAddImp(yoctx *ctx, yoimp *imp)
{
  yoifl *noreg ifl = (yoifl *) 0;

  NOREG(ifl);

  ifl = (yoifl *)ysHshFind(ctx->intfs,(dvoid *)ysidToStr(imp->intf),
                             strlen(ysidToStr(imp->intf))+1);
  if(!ifl)
  {
    ifl = (yoifl *)ysmGlbAlloc(sizeof(yoifl),"yoifl");
    ifl->intf = imp->intf;
    ifl->impll = (yslst *) 0;
    yseTry
    {
      ifl->impll = ysLstCreate();
      ysHshIns(ctx->intfs,(dvoid *)ysidToStr(imp->intf),
               strlen(ysidToStr(imp->intf))+1,
               (dvoid *)ifl);
    }
    yseCatchAll
    {
      if(ifl->impll) ysLstDestroy(ifl->impll,(ysmff) 0);
      ysmGlbFree((dvoid *) ifl);
      yseRethrow;
    }
    yseEnd;
  }
  DISCARD ysLstEnq(ifl->impll,(dvoid *)imp);
}


yoimp *yoFindImp(yoctx *ctx, CONST ysid *intf, CONST char *impl,
                 boolean ready)
{
  yoifl *ifl;
  yoimp *imp = (yoimp *) 0;
  yoimp *i;
  ysle  *e;

  ifl = (yoifl *)ysHshFind(ctx->intfs,(dvoid *)ysidToStr(intf),
                           strlen(ysidToStr(intf))+1);
  if(ifl)
    for(e = ysLstHead(ifl->impll); e ; e = ysLstNext(e))
    {
      i = (yoimp *) ysLstVal(e);
      if((!ready || i->nstate == YOIMP_RDY) &&
         (!impl || strcmp(impl,i->impl) == 0))
      {
        imp = i;
        break;
      }
    }

  return imp;
}

sword yoIntfEq(dvoid *elm, dvoid *key, size_t keysz )
{
  return !ysidEq(((yoifl *)elm)->intf,(ysid *)key);
}

void yoFreeImpLst(dvoid *ifl)
{
  ysLstDestroy(((yoifl *)ifl)->impll,yoFreeImp);
  ysmGlbFree(ifl);
}

void yoFreeImp(dvoid *imp)
{
  ysmGlbFree((dvoid *)((yoimp *)imp)->stubs);
  ysmGlbFree((dvoid *)((yoimp *)imp)->minfo._buffer);
  if(((yoimp *)imp)->iinfo.self_yort_implInfo)
  {
    yoDispose((dvoid *)((yoimp *)imp)->iinfo.self_yort_implInfo);
    yoRelease((dvoid *)((yoimp *)imp)->iinfo.self_yort_implInfo);
  }
  ysmGlbFree(imp);
}

void yoFreeSReq(ysmhp *hp, yosreq *req)
{
  if(req->parms && req->args)
    yoxFreeReqParms(req->parms,req->args);
  yoEnvFree(&req->hdr.scxs.ev);
  if(req->hdr.scxs.upctx)
    yoTrans_pctx__free(req->hdr.scxs.upctx,(ysmff)0);
  yogiFreeReqHeader(&req->hdr);
  yoFreeMsgDesc(hp,req->md);
  if(req->hb)
    ysEvtDestroy(req->hb);
  if(req->ltrid)
    ysStrDestroy(req->ltrid);
  if(req->orlst)
    ysLstDestroy(req->orlst,yoRelease);
  ysmFree(hp,(dvoid *)req);
}

void yoFreeRepLst(dvoid *ptr)
{
  yoctx *ctx;
  yosrep *rep;

  ctx = yoCtx;
  rep = (yosrep *) ptr;

  yoFreeMsgDesc(ctx->sndhp,rep->md);
  ysmFree(ctx->sndhp,ptr);
}

STATICF void yoCopyRest(ysmhp *hp, yosx *x, ysbv *obv, sword onbv,
                        ysbv **bv, sword *nbv)
{
  ysbv *b = (ysbv *) 0; 
  sword n = 0;
  yosxPos p;
  sword idx;
  size_t off;
  sword i;

  

  *bv = (ysbv *) 0;
  *nbv = 0;

  yosxGetPos(x,&p);
  idx = p.idx;
  off = p.off;
  if(off >= obv[idx].len)
  {
    idx++;
    off = 0;
  }
  if(idx < onbv)
  {
    n = onbv - idx;
    b = (ysbv *)ysmAlloc(hp,sizeof(ysbv) * n,"resnd-bvs");
    b[0].len = obv[idx].len - off;
    b[0].buf = (ub1 *) ysmAlloc(hp,b[0].len,"resnd-bv-data");
    DISCARD memcpy((dvoid *)b[0].buf,(dvoid *)(obv[idx].buf+off),
                     b[0].len);
    for(i = 1, idx++; i < n; i++,idx++)
    {
      b[i].len = obv[idx].len;
      b[i].buf = (ub1 *) ysmAlloc(hp,b[i].len,"resnd-bv");
      DISCARD memcpy((dvoid *)b[i].buf,(dvoid *)obv[idx].buf,b[i].len);
    }
  }
  *bv = b;
  *nbv = n;
}


STATICF void yoAdminCb(CONST ysid *intf, CONST ysid *impl, boolean stateless,
                       ub4 ostate, ub4 nstate, dvoid *usrp)
{
  switch(nstate)
  {
  case YOIMPADST_DOWN:
    yoImplDeactivate(intf,impl);
    break;
  case YOIMPADST_CONGESTED:
    yoImplSuspend(intf,impl);
    break;
  case YOIMPADST_RUN:
    yoImplResume(intf,impl);
    break;
  case YOIMPADST_QUIESCE:
    if(stateless)
       yoImplDeactivate(intf,impl);
    break;
  default:
    
    break;
  }
}

 




STATICF void yoThreadShutdown(dvoid *usrp, const ysid *exid, dvoid *arg,
			      size_t argsz)
{
  yotdcx *tdcx = (yotdcx*)usrp;
  ysle *le, *next;
  yotcx *tcx;

  

  for(le = ysLstHead(tdcx->tlst); le ; le = next)
  {
    next = ysLstNext(le);
    tcx = (yotcx*)ysLstVal(le);
    ysTrigger(tcx->sems[0], (ysid*)0, (dvoid*)0, 0);
  }
}





STATICF void yoWorkThread(dvoid *usrp)
{
  yotcx	*tcx = (yotcx *)usrp;
  yotdcx *tdcx = tcx->tdcx;
  boolean leave = FALSE;
  boolean didwork;

  

  while(!ysSemTest(tcx->sems[0]) && !leave)
  {
    tcx->sems[1] = ysSemCreate((dvoid*)0);
    ysSvcNotify(tdcx->q, tcx->sems[1]);
    DISCARD ysSemOrW(YSTM_INFINITE, 2, tcx->sems);
    ysSemDestroy(tcx->sems[1]);

    if(ysSemTest(tcx->sems[0]))
      break;
	  
    
    ysMtxLock(&tdcx->mtx);
    tdcx->navail--;
    ysMtxUnlock(&tdcx->mtx);

    ysCondSignal(&tdcx->cv);	

    
    if(ysSemTest(tcx->sems[0]))
      break;

    
    didwork = ysSvcNext(tdcx->q);
    
    
    ysMtxLock(&tdcx->mtx);
    if(didwork)
      tdcx->svc.count++;
    if((tdcx->keept && ysLstCount(tdcx->tlst) > (ub4) tdcx->keept) ||
       ysLstCount(tdcx->tlst) > (ub4) tdcx->mint)
      leave = TRUE;
    else
      tdcx->navail++; 
    ysMtxUnlock(&tdcx->mtx);
  }
  
  
  DISCARD ysLstRem(tdcx->tlst, tcx->le);
  ysSemDestroy(tcx->sems[0]);

  ysCondSignal(&tdcx->cv);	
}




STATICF void yoThreadAdd(yotdcx *tdcx, yotcx *tcx)
{
  tcx->tdcx = tdcx;
  tcx->sems[0] = ysSemCreate((dvoid*)0);
  tcx->le = ysLstEnq(tdcx->tlst, (dvoid*)tcx);

  if(tdcx->peak < ysLstCount(tdcx->tlst))
    tdcx->peak =  ysLstCount(tdcx->tlst);
}




STATICF void yoThreadStart(yotdcx *tdcx)
{
  yotcx	*tcx;

  tdcx->navail++;
  tcx = (yotcx *)ysmGlbAlloc(sizeof(*tcx), yotcx_tag);
  yoThreadAdd(tdcx, tcx);
  ysThrCreate((ysthr*)0, yoWorkThread, (dvoid*)tcx, 0);
}



#define YO_CRBX_PFX "IDL:omg.org/CORBA/"
#define YO_LEN_CRBX_PFX ((size_t)18)



#ifdef RISCOS
static CONST char* yoCorbaExTbl[] =
{
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0,
  (CONST char *) 0
};

void init_yoCorbaExTbl(void)
{
  yoCorbaExTbl[0] = CORBA_UNKNOWN_id;
  yoCorbaExTbl[1] = CORBA_INV_OBJREF_id;
  yoCorbaExTbl[2] = CORBA_BAD_PARAM_id;
  yoCorbaExTbl[3] = CORBA_INTERNAL_id;
  yoCorbaExTbl[4] = CORBA_BAD_TYPECODE_id;
  yoCorbaExTbl[5] = CORBA_BAD_OPERATION_id;
  yoCorbaExTbl[6] = CORBA_MARSHAL_id;
  yoCorbaExTbl[7] = CORBA_COMM_FAILURE_id;
  yoCorbaExTbl[8] = CORBA_NO_MEMORY_id;
  yoCorbaExTbl[9] = CORBA_IMP_LIMIT_id;
  yoCorbaExTbl[10] = CORBA_NO_PERMISSION_id;
  yoCorbaExTbl[11] = CORBA_INITIALIZE_id;
  yoCorbaExTbl[12] = CORBA_NO_IMPLEMENT_id;
  yoCorbaExTbl[13] = CORBA_NO_RESOURCES_id;
  yoCorbaExTbl[14] = CORBA_NO_RESPONSE_id;
  yoCorbaExTbl[15] = CORBA_PERSIST_STORE_id;
  yoCorbaExTbl[16] = CORBA_BAD_INV_ORDER_id;
  yoCorbaExTbl[17] = CORBA_TRANSIENT_id;
  yoCorbaExTbl[18] = CORBA_FREE_MEM_id;
  yoCorbaExTbl[19] = CORBA_INV_IDENT_id;
  yoCorbaExTbl[20] = CORBA_INV_FLAG_id;
  yoCorbaExTbl[21] = CORBA_INTF_REPOS_id;
  yoCorbaExTbl[22] = CORBA_BAD_CONTEXT_id;
  yoCorbaExTbl[23] = CORBA_OBJ_ADAPTER_id;
  yoCorbaExTbl[24] = CORBA_DATA_CONVERSION_id;
  yoCorbaExTbl[25] = CORBA_OBJECT_NOT_EXIST_id;
}

#else
static CONST char* yoCorbaExTbl[] =
{
  CORBA_UNKNOWN_id,
  CORBA_INV_OBJREF_id,
  CORBA_BAD_PARAM_id,
  CORBA_INTERNAL_id,
  CORBA_BAD_TYPECODE_id,
  CORBA_BAD_OPERATION_id,
  CORBA_MARSHAL_id,
  CORBA_COMM_FAILURE_id,
  CORBA_NO_MEMORY_id,
  CORBA_IMP_LIMIT_id,
  CORBA_NO_PERMISSION_id,
  CORBA_INITIALIZE_id,
  CORBA_NO_IMPLEMENT_id,
  CORBA_NO_RESOURCES_id,
  CORBA_NO_RESPONSE_id,
  CORBA_PERSIST_STORE_id,
  CORBA_BAD_INV_ORDER_id,
  CORBA_TRANSIENT_id,
  CORBA_FREE_MEM_id,
  CORBA_INV_IDENT_id,
  CORBA_INV_FLAG_id,
  CORBA_INTF_REPOS_id,
  CORBA_BAD_CONTEXT_id,
  CORBA_OBJ_ADAPTER_id,
  CORBA_DATA_CONVERSION_id,
  CORBA_OBJECT_NOT_EXIST_id,
  (CONST char *) 0
};
#endif




typedef struct
{
  CONST ysid* intid;       
  CONST char* extid;       
  ub4 minor;                     
} yoexmap;




#define YOEX_MINOR_BASE 13000

#ifdef RISCOS
static yoexmap yoSysExMap[] =
{
  "yo::badcode",        (CONST char *) 0,         (ub4)0,
  "yo::badobj",         (CONST char *) 0,         (ub4)0,
  "yo::badoper",        (CONST char *) 0,         (ub4)0,
  "yo::badrefstr",      (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+3,
  "yo::boundsmismatch", (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+4,
  "yo::cryptoErr",      (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+5,
  "yo::endofdata",      (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+6,
  "yo::encodeerror",    (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+7,
  "yo::internal",       (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+8,
  "yo::noimpl",         (CONST char *) 0,         (ub4)0,
  "yo::nores",          (CONST char *) 0,         (ub4)0,
  "yo::stateless",      (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+11,
  "yo::unknownCipher",  (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+12,
  "yo::unexpected",     (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+13,
  "yo::unimplemented",  (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+15,
  "ys::badparam",       (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+16,
  "ys::endofdata",      (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+17,
  "ys::encodeerror",    (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+18,
  "ys::notimpl",        (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+19,
  "ys::notinit",        (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+20,
  "ys::outmem",         (CONST char *) 0,         (ub4)0,
  "yt::badaddr",        (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+22,
  "yt::broken",         (CONST char *) 0,         (ub4)YOEX_MINOR_BASE+23,
  (CONST ysid *) 0,     (CONST char *) 0,         (ub4)0
};

void init_yoSysExMap(void)
{
  yoSysExMap[0].extid = CORBA_BAD_TYPECODE_id;
  yoSysExMap[1].extid = CORBA_INV_OBJREF_id;
  yoSysExMap[2].extid = CORBA_BAD_OPERATION_id;
  yoSysExMap[3].extid = CORBA_BAD_PARAM_id;
  yoSysExMap[4].extid = CORBA_BAD_PARAM_id;
  yoSysExMap[5].extid = CORBA_MARSHAL_id;
  yoSysExMap[6].extid = CORBA_MARSHAL_id;
  yoSysExMap[7].extid = CORBA_MARSHAL_id;
  yoSysExMap[8].extid = CORBA_INTERNAL_id;
  yoSysExMap[9].extid = CORBA_NO_IMPLEMENT_id;
  yoSysExMap[10].extid = CORBA_NO_RESOURCES_id;
  yoSysExMap[11].extid = CORBA_OBJ_ADAPTER_id;
  yoSysExMap[12].extid = CORBA_MARSHAL_id;
  yoSysExMap[13].extid = CORBA_UNKNOWN_id;
  yoSysExMap[14].extid = CORBA_INTERNAL_id;
  yoSysExMap[15].extid = CORBA_BAD_PARAM_id;
  yoSysExMap[16].extid = CORBA_BAD_PARAM_id;
  yoSysExMap[17].extid = CORBA_MARSHAL_id;
  yoSysExMap[18].extid = CORBA_MARSHAL_id;
  yoSysExMap[19].extid = CORBA_INTERNAL_id;
  yoSysExMap[20].extid = CORBA_INITIALIZE_id;
  yoSysExMap[21].extid = CORBA_NO_MEMORY_id;
  yoSysExMap[22].extid = CORBA_COMM_FAILURE_id;
  yoSysExMap[23].extid = CORBA_COMM_FAILURE_id;
}

#else
static CONST yoexmap yoSysExMap[] =
{
  "yo::badcode",        CORBA_BAD_TYPECODE_id,    (ub4)0,
  "yo::badobj",         CORBA_INV_OBJREF_id,      (ub4)0,
  "yo::badoper",        CORBA_BAD_OPERATION_id,   (ub4)0,
  "yo::badrefstr",      CORBA_BAD_PARAM_id,       (ub4)YOEX_MINOR_BASE+3,
  "yo::boundsmismatch", CORBA_BAD_PARAM_id,       (ub4)YOEX_MINOR_BASE+4,
  "yo::cryptoErr",      CORBA_MARSHAL_id,         (ub4)YOEX_MINOR_BASE+5,
  "yo::endofdata",      CORBA_MARSHAL_id,         (ub4)YOEX_MINOR_BASE+6,
  "yo::encodeerror",    CORBA_MARSHAL_id,         (ub4)YOEX_MINOR_BASE+7,
  "yo::internal",       CORBA_INTERNAL_id,        (ub4)YOEX_MINOR_BASE+8,
  "yo::noimpl",         CORBA_NO_IMPLEMENT_id,    (ub4)0,
  "yo::nores",          CORBA_NO_RESOURCES_id,    (ub4)0,
  "yo::stateless",      CORBA_OBJ_ADAPTER_id,     (ub4)YOEX_MINOR_BASE+11,
  "yo::unknownCipher",  CORBA_MARSHAL_id,         (ub4)YOEX_MINOR_BASE+12,
  "yo::unexpected",     CORBA_UNKNOWN_id,         (ub4)YOEX_MINOR_BASE+13,
  "yo::unimplemented",  CORBA_INTERNAL_id,        (ub4)YOEX_MINOR_BASE+14,
  "ys::badmagic",       CORBA_BAD_PARAM_id,       (ub4)YOEX_MINOR_BASE+15,
  "ys::badparam",       CORBA_BAD_PARAM_id,       (ub4)YOEX_MINOR_BASE+16,
  "ys::endofdata",      CORBA_MARSHAL_id,         (ub4)YOEX_MINOR_BASE+17,
  "ys::encodeerror",    CORBA_MARSHAL_id,         (ub4)YOEX_MINOR_BASE+18,
  "ys::notimpl",        CORBA_INTERNAL_id,        (ub4)YOEX_MINOR_BASE+19,
  "ys::notinit",        CORBA_INITIALIZE_id,      (ub4)YOEX_MINOR_BASE+20,
  "ys::outmem",         CORBA_NO_MEMORY_id,       (ub4)0,
  "yt::badaddr",        CORBA_COMM_FAILURE_id,    (ub4)YOEX_MINOR_BASE+22,
  "yt::broken",         CORBA_COMM_FAILURE_id,    (ub4)YOEX_MINOR_BASE+23,
  (CONST ysid *) 0,     (CONST char *) 0,         (ub4)0
};
#endif


STATICF CONST ysid *yoExCorbaSys(CONST ysid *exid, ub4 *minor, boolean *corba)
{
  CONST yoexmap *m;
  CONST char **p;
  CONST char *id = ysidToStr(exid);

  if(minor)
    *minor = (ub4)0;
  if(corba)
    *corba = FALSE;
  if(id[0] == 'y')                      
  {
    for(m = yoSysExMap; m->intid; m++)
    {
      if(strcmp(id, m->intid) == 0)
      {
        if (minor)
          *minor = m->minor;
        return (CONST ysid *) m->extid;
      }
    }
  }
  else if(strncmp(YO_CRBX_PFX, id, YO_LEN_CRBX_PFX) == 0)
  {                                                        
    id += YO_LEN_CRBX_PFX;
    for(p = yoCorbaExTbl; p; p++)
      if(strcmp(id, (*p)+YO_LEN_CRBX_PFX) == 0)
      {
        if(corba)
          *corba = TRUE;
        return (CONST ysid *) *p;
      }
  }
  return (CONST ysid *) 0;                            
}



boolean yoExMNSys(CONST ysid *exid, ub4 minor, CONST ysid **newid)
{
  CONST char *id;
  boolean corb;
  CONST char **p;
  CONST yoexmap *m;

  id = ysidToStr(exid);
  if(strncmp(YO_CRBX_PFX, id, YO_LEN_CRBX_PFX) != 0)
    ysePanic(YO_EX_INTERNAL);                

  id += YO_LEN_CRBX_PFX;             
  for(p = yoCorbaExTbl; p; p++)
    if(strcmp(id, (*p)+YO_LEN_CRBX_PFX) == 0)
      break;
  if(!*p)                                         
    ysePanic(YO_EX_INTERNAL);      

  *newid = (CONST ysid *) *p;                      
  corb = TRUE;
  for(m = yoSysExMap; m->intid; m++)
  {
    if((*p == m->extid) && (!m->minor || (m->minor == minor)))
    {                                                     
      *newid = (CONST ysid *) m->intid;
      corb = FALSE;
      break;
    }
  }
  return corb;
}





CONST ysid *CORBA_UNKNOWN__getId(void)
{
  return (CONST ysid *) CORBA_UNKNOWN_id;
}

CONST ysid *CORBA_BAD_PARAM__getId(void)
{
  return (CONST ysid *) CORBA_BAD_PARAM_id;
}

CONST ysid *CORBA_NO_MEMORY__getId(void)
{
  return (CONST ysid *) CORBA_NO_MEMORY_id;
}

CONST ysid *CORBA_IMP_LIMIT__getId(void)
{
  return (CONST ysid *) CORBA_IMP_LIMIT_id;
}

CONST ysid *CORBA_COMM_FAILURE__getId(void)
{
  return (CONST ysid *) CORBA_COMM_FAILURE_id;
}

CONST ysid *CORBA_INV_OBJREF__getId(void)
{
  return (CONST ysid *) CORBA_INV_OBJREF_id;
}

CONST ysid *CORBA_NO_PERMISSION__getId(void)
{
  return (CONST ysid *) CORBA_NO_PERMISSION_id;
}

CONST ysid *CORBA_INTERNAL__getId(void)
{
  return (CONST ysid *) CORBA_INTERNAL_id;
}

CONST ysid *CORBA_MARSHAL__getId(void)
{
  return (CONST ysid *) CORBA_MARSHAL_id;
}

CONST ysid *CORBA_INITIALIZE__getId(void)
{
  return (CONST ysid *) CORBA_INITIALIZE_id;
}

CONST ysid *CORBA_NO_IMPLEMENT__getId(void)
{
  return (CONST ysid *) CORBA_NO_IMPLEMENT_id;
}

CONST ysid *CORBA_BAD_TYPECODE__getId(void)
{
  return (CONST ysid *) CORBA_BAD_TYPECODE_id;
}

CONST ysid *CORBA_BAD_OPERATION__getId(void)
{
  return (CONST ysid *) CORBA_BAD_OPERATION_id;
}

CONST ysid *CORBA_NO_RESOURCES__getId(void)
{
  return (CONST ysid *) CORBA_NO_RESOURCES_id;
}

CONST ysid *CORBA_NO_RESPONSE__getId(void)
{
  return (CONST ysid *) CORBA_NO_RESPONSE_id;
}

CONST ysid *CORBA_PERSIST_STORE__getId(void)
{
  return (CONST ysid *) CORBA_PERSIST_STORE_id;
}

CONST ysid *CORBA_BAD_INV_ORDER__getId(void)
{
  return (CONST ysid *) CORBA_BAD_INV_ORDER_id;
}

CONST ysid *CORBA_TRANSIENT__getId(void)
{
  return (CONST ysid *) CORBA_TRANSIENT_id;
}

CONST ysid *CORBA_FREE_MEM__getId(void)
{
  return (CONST ysid *) CORBA_FREE_MEM_id;
}

CONST ysid *CORBA_INV_IDENT__getId(void)
{
  return (CONST ysid *) CORBA_INV_IDENT_id;
}

CONST ysid *CORBA_INV_FLAG__getId(void)
{
  return (CONST ysid *) CORBA_INV_FLAG_id;
}

CONST ysid *CORBA_INTF_REPOS__getId(void)
{
  return (CONST ysid *) CORBA_INTF_REPOS_id;
}

CONST ysid *CORBA_BAD_CONTEXT__getId(void)
{
  return (CONST ysid *) CORBA_BAD_CONTEXT_id;
}

CONST ysid *CORBA_OBJ_ADAPTER__getId(void)
{
  return (CONST ysid *) CORBA_OBJ_ADAPTER_id;
}

CONST ysid *CORBA_DATA_CONVERSION__getId(void)
{
  return (CONST ysid *) CORBA_DATA_CONVERSION_id;
}

CONST ysid *CORBA_OBJECT_NOT_EXIST__getId(void)
{
  return (CONST ysid *) CORBA_OBJECT_NOT_EXIST_id;
}

