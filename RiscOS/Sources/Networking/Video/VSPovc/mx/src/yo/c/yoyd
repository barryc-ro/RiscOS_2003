/* yo/yoyd.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/








#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef SYSB8_ORACLE
#include <sysb8.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YO_ORACLE
#include <yo.h>
#endif
#ifndef YOT_ORACLE
#include <yot.h>
#endif
#ifndef YOI_ORACLE
#include <yoi.h>
#endif
#ifndef YOYD_ORACLE
#include <yoyd.h>
#endif
#ifndef MZNM_ORACLE
#include <mzn.h>
#endif


STATICF void yoReqRepLocFwd(yoctx *ctx, yosreq *req, yoo *or);
STATICF ysstr *yoRegisterORBD(yotp *port, yoo *ref);

void yoInitRouter(dvoid *ref, ysque *q, ysHndlr hdlr, dvoid *usrp)
{
  yoctx *ctx;

  ysmCheck(ref,yoTagObjRef);
  ctx = yoCtx;                                             

  ctx->rtq = q;
  ctx->rthdlr = hdlr;
  ctx ->rtusrp = usrp;


  
  ysMtxLock(&ctx->ydmtx);
  if(ctx->ydaddr)
  {
    yotAddrFree(ctx->ydaddr);
    yoRelease((dvoid *)ctx->ydimref);
  }
  ctx->ydaddr = yotGetAddr(ctx->rrport);
  ctx->ydimref = (yoo *) yoDuplicate((dvoid *)ref);
  ysMtxUnlock(&ctx->ydmtx);

  ctx->rtpnm = yoRegisterORBD(ctx->rrport,(yoo *)ref);
}

void yoTermRouter(void)
{
  yoctx *ctx;

  ctx = yoCtx;

  if(ctx->rtq)                                        
  {
    ctx->rtq = (ysque *)0;
    mznUnbind(ctx->rrport);
    ysStrDestroy(ctx->rtpnm);
    yoDeadORBD(ctx);
  }
}

void yoFwdRequest(yore *re, ysevt *evt)
{
  yoctx *ctx;
  yoo *or;
  yosreq *req;

  ysmCheck(re->dstref,yoTagObjRef);

  ctx = yoCtx;
  or = (yoo *) re->dstref;
  req = re->req;

  switch(req->type)
  {
  case YOGIMT_REQ:
    yoReqRepLocFwd(ctx,req,or);
    break;
  case YOGIMT_LOCREQ:
    yoLocReqReply(ctx,req,YOGILRS_FORWARD,or);
    break;
  default:
    ysePanic(YO_EX_INTERNAL);
  }

  
  ysTrigger(evt,(ysid *)0,(dvoid *)0,(size_t)0);
}

STATICF void yoReqRepLocFwd(yoctx *ctx, yosreq *req, yoo *or)
{
  yosrep *srep;
  yoo *target;

  srep = yoSRepCreate(ctx, req, YOGIRS_LOCFWD);
  target = or;
  yogiPutOR(srep->x,target,req->reftag);
  yoSRepSend(ctx,srep,(ysbv *)0,0);
}


void yoRejRequest(yore *re)
{
  yosreq *req;
  yoctx *ctx;
  
  req = (yosreq *) re->req;
  ctx = yoCtx;

  switch(req->type)
  {
  case YOGIMT_REQ:
    yoErrSnd(ctx,req,YO_EX_BADOBJ, YOREQ_COMPL_MAYBE);
    break;
  case YOGIMT_LOCREQ:
    yoLocReqReply(ctx,req,YOGILRS_UNKNOWN,(yoo *)0);
    break;
  default:
    ysePanic(YO_EX_INTERNAL);
  }
}

void yoFreeRouteReq(yore *re)
{
  yoRelease(re->srcref);
  yoFreeSReq(yoCtx->rcvhp,(yosreq *)re->req);
}

void yoydRouteMsg(yosreq *req)
{
  yoctx *ctx;
  noreg yore re;
  dvoid *arg;
  size_t argsz;
  ysevt *noreg evt;


  NOREG(re);
  NOREG(evt);

  ctx = yoCtx;
  CLRSTRUCT(re);

  evt = (ysevt *) 0;
  yseTry
  {
    CPSTRUCT(re.hdr,req->hdr);
    re.req = (dvoid *)req;

    if(req->hb)
    {
      ysEvtDestroy(req->hb);
      req->hb = (ysevt *) 0;
    }
    re.req = (dvoid *) req;
    re.srcref = (dvoid *) yoRefCreate(ctx,yort_proc__id,(char *)0,
                                        (yoRefData *)0,YOSTID_YORT,
                                        yotAddrDup(req->md->addr),
                                        (dvoid *)0,FALSE);
    arg = (dvoid *)&re;
    argsz = sizeof(re);

    
    evt = ysEvtCreate(ctx->rthdlr,ctx->rtusrp,ctx->rtq, FALSE);
    ysTrigger(evt,(CONST ysid *)0,arg,argsz);
  }
  yseCatchAll
  {
    if(evt) ysEvtDestroy(evt);
    yoFreeSReq(ctx->rcvhp,req);
    ysRecord(YORT_ERR(6), YSLSEV_CRIT, (char *)0, YSLSTR(yseExid), YSLEND);
  }
  yseEnd;
}



STATICF sb4 yoYdFndPush(mnxStream *stream, dvoid *ptr);
STATICF dvoid *yoYdLstAlloc(mnxStream *stream, size_t len);
STATICF sb4 yoYdLstPush(mnxStream *stream, dvoid *ptr);

typedef struct yofndyd yofndyd;
struct yofndyd
{
  char *match;
  size_t mlen;
  yslst *hits;
};

typedef struct yofndydh yofndydh;
struct yofndydh
{
  yota  *addr;
  dvoid *ref;
};

void yoFindORBD(yoctx *ctx)
{
  ysstr *orbnm;
  char  *regexp = (char *)0;
  mnxStream stream;
  yofndyd fnd;
  sysb8 ticks;
  ub4 i,sel;
  yofndydh *h;
  yofndydh *hit;
  yota *addr;
  yoo *ref;

  ysMtxLock(&ctx->ydmtx);
  addr = ctx->ydaddr;
  ref = ctx->ydimref;
  if(addr)
    ctx->ydaddr = (yota *)0;
  if(ref)
    ctx->ydimref = (yoo *)0;
  ysMtxUnlock(&ctx->ydmtx);
  if(addr)
    yotAddrFree(addr);
  if(ref)
    yoRelease((dvoid *)ref);

  hit = (yofndydh *) 0;

  orbnm = ysStrCreate("/yoORBD|");

  fnd.match = ysStrToText(orbnm);
  fnd.mlen = strlen(fnd.match);
  fnd.hits = ysLstCreate();

  stream.alloc = yoYdLstAlloc;
  stream.push = yoYdFndPush;
  stream.close = (void (*)(mnxStream *, sb4)) 0;
  stream.usrp = (dvoid *) &fnd;
  DISCARD mznQuery(regexp, (ub4)MZN_ALL_NAMES, &stream);

  ysStrDestroy(orbnm);

  
  if(ysLstCount(fnd.hits))
  {
    ysClock(&ticks);
    sysb8srl(&ticks,&ticks,13);
    sel = sysb8msk(&ticks) % ysLstCount(fnd.hits);
    for(i = 0; (h = (yofndydh *)ysLstDeq(fnd.hits)); i++)
    {
      if(i == sel)
        hit = h;
      else
      {
        yoRelease(h->ref);
        yotAddrFree(h->addr);
        ysmGlbFree((dvoid *)h);
      }
    }
  }
  ysLstDestroy(fnd.hits,(ysmff)0);

  ysMtxLock(&ctx->ydmtx);
  if(hit)
  {
    ctx->ydimref = hit->ref;
    ctx->ydaddr = hit->addr;
  }
  ysMtxUnlock(&ctx->ydmtx);
  if(hit)
  {
    ysCondBroadcast(&ctx->ydcv);
    ysmGlbFree((dvoid *)hit);
  }
}

STATICF sb4 yoYdFndPush(mnxStream *stream, dvoid *ptr)
{
  mznent *ent;
  yofndyd *fnd;
  yofndydh *hit;
  char *refstr;
  dvoid *ref;
  char *cp;
  
  fnd = (yofndyd *) stream->usrp;
  ent = (mznent *) ptr;

  if(strncmp(fnd->match,ent->name,fnd->mlen) == 0)
  {
    refstr = strchr(ent->name,'|');
    if(refstr && (refstr = strchr(refstr+1,'|')))
    {
      for(cp = refstr+1; *cp; cp++)
        if(*cp == '~')
          *cp = ':';
      ref = yoStrToRef(refstr+1);
      if(ref)
      {
        hit = (yofndydh *) ysmGlbAlloc(sizeof(yofndydh),"yofndydh");
        hit->ref = ref;
        hit->addr = yotAddrDup((yota *)&ent->addr);
        DISCARD ysLstEnq(fnd->hits,(dvoid *)hit);
      }
    }
  }
  mnxFree(mznxEntry, (dvoid *)ent);
  ysmGlbFree(ptr);

  return 0;
}

STATICF ysstr *yoRegisterORBD(yotp *port, yoo *ref)
{
  ysstr *orbnm;
  CONST char *id;
  char *refstr;
  sb4 sts;
  char *cp;

  orbnm = ysStrCreate("/yoORBD|");
  if((id = ysGetHostName()))
    orbnm = ysStrCat(orbnm,id);
  orbnm = ysStrApp(orbnm,'|');
  refstr =  yoRefToStr((dvoid *)ref);
  for(cp = refstr; *cp; cp++)
    if(*cp == ':')
      *cp = '~';
  orbnm = ysStrCat(orbnm,refstr);
  sts = mznBind((mnp *)port,ysidToStr(orbnm));

  yoFree((dvoid *) refstr);

  if(sts < 0)
  {
    
  }
  return orbnm;
}

yslst *yoListORBDs(void)
{
  yslst *lst;
  char  *regexp = (char *)0;
  mnxStream stream;

  lst = ysLstCreate();

  stream.alloc = yoYdLstAlloc;
  stream.push = yoYdLstPush;
  stream.close = (void (*)(mnxStream *, sb4)) 0;
  stream.usrp = (dvoid *) lst;
  DISCARD mznQuery(regexp, (ub4)MZN_PORTS, &stream);

  return lst;
}

STATICF dvoid *yoYdLstAlloc(mnxStream *stream , size_t len)
{
  return ysmGlbAlloc(len,"yoYdLstAlloc");
}

STATICF sb4 yoYdLstPush(mnxStream *stream, dvoid *ptr)
{
  mznent *ent;
  yslst *lst;
  yoo *ref;
  char *refstr;
  char *cp;

  lst = (yslst *) stream->usrp;
  ent = (mznent *) ptr;
  
  if(strncmp("/yoORBD|",ent->name,8) == 0)
  {
    refstr = strchr(ent->name,'|');
    if(refstr && (refstr = strchr(refstr+1,'|')))
    {
      for(cp = refstr+1; *cp; cp++)
        if(*cp == '~')
          *cp = ':';
      ref = (yoo *) yoStrToRef(refstr+1);
      DISCARD ysLstEnq(lst,(dvoid *)ref);
    }
  }
  mnxFree(mznxEntry, (dvoid *)ent);
  ysmGlbFree(ptr);

  return 0;
}
