/* mx/src/ys/yshsh.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif


static ysmtagDecl(YSHSH_TAG) = "yshsh";


struct yshsh
{
  yshash  hashfunc;                                         
  yshsheq eqfunc;                                       
  ysmff   delfunc;                                

  ub4     rows;                                              
  yslst **grid;                                           
  ub4     cnt;                                              
  ub4     fidx;                     
};


STATICF ub4   ysHshPrime(ub4 rows);
STATICF ysle *ysHshLocate(yshsh *tbl, dvoid *key, size_t keysz, ub4 *idx);


yshsh *ysHshCreate(ub4 rows, yshash hashfunc, yshsheq eqfunc, ysmff delfunc)
{
  yshsh *tbl;
  size_t sz;

  tbl = (yshsh *) ysmGlbAlloc(sizeof(yshsh), YSHSH_TAG);
  tbl->hashfunc = (hashfunc ? hashfunc : ysHshKey);
  tbl->eqfunc = (eqfunc ? eqfunc : (yshsheq) memcmp);
  tbl->delfunc = delfunc;
  tbl->rows = ysHshPrime(rows);
  tbl->cnt = (ub4) 0;
  tbl->fidx = (ub4) tbl->rows;

  sz = (size_t) tbl->rows * sizeof(yslst *);
  tbl->grid = (yslst **) ysmGlbAlloc(sz, "hash grid");
  DISCARD memset((dvoid *) tbl->grid, 0, sz);

  return tbl;
}


void ysHshDestroy(yshsh *tbl)
{
  ub4 i;

  ysmCheck((dvoid *) tbl, YSHSH_TAG);

  for (i = 0; i < tbl->rows; i++)
    if (tbl->grid[i])
      ysLstDestroy(tbl->grid[i], tbl->delfunc);

  ysmGlbFree((dvoid *) tbl->grid);
  ysmGlbFree((dvoid *) tbl);
}


ub4 ysHshCount(yshsh *tbl)
{
  ysmCheck((dvoid *) tbl, YSHSH_TAG);
  return tbl->cnt;
}


void ysHshIns(yshsh *tbl, dvoid *key, size_t keysz, dvoid *val)
{
  ub4 i;

  ysmCheck((dvoid *) tbl, YSHSH_TAG);

  
  i = (*tbl->hashfunc)(key, keysz, tbl->rows);
  if (!tbl->grid[i])
    tbl->grid[i] = ysLstCreate();

  if (i < tbl->fidx)
    tbl->fidx = i;

  
  DISCARD ysLstPush(tbl->grid[i], val);
  tbl->cnt++;
}


dvoid *ysHshRem(yshsh *tbl, dvoid *key, size_t keysz)
{
  ysle  *le;
  ub4    idx;

  le = ysHshLocate(tbl, key, keysz, &idx);
  return (le ? (tbl->cnt--, ysLstRem(tbl->grid[idx], le)) : (dvoid *) 0);
}


dvoid *ysHshFind(yshsh *tbl, dvoid *key, size_t keysz)
{
  ysle *le;
  ub4   idx;

  le = ysHshLocate(tbl, key, keysz, &idx);
  return (le ? ysLstVal(le) : (dvoid *) 0);
}


void ysHshWalk(yshsh *tbl, yshshwcb walkcb, dvoid *usrp)
{
  ub4     i;
  boolean ok;
  ysle   *le;

  ysmCheck((dvoid *) tbl, YSHSH_TAG);

  ok = TRUE;
  for (i = 0; ok && i < tbl->rows; i++)
    if (tbl->grid[i])
      for (le = ysLstHead(tbl->grid[i]); ok && le; le = ysLstNext(le))
	ok = (*walkcb)(usrp, ysLstVal(le));
}


dvoid *ysHshFirst(yshsh *tbl, yshshpos *hpos)
{
  dvoid *val;

  if (tbl->fidx < tbl->rows)
    {
      hpos->idx = tbl->fidx;
      hpos->le = ysLstHead(tbl->grid[hpos->idx]);
      if (!hpos->le)
	{
	  val = ysHshNext(tbl, hpos);
	  tbl->fidx = hpos->idx;
	  return val;
	}
      return ysLstVal(hpos->le);
    }
  else
    return (dvoid *) 0;
}


dvoid *ysHshNext(yshsh *tbl, yshshpos *hpos)
{
  yslst *lst;

  if (hpos->le)
    hpos->le = ysLstNext(hpos->le);
  if (!hpos->le)
    while (++hpos->idx < tbl->rows)
      {
	lst = tbl->grid[hpos->idx];
	if (lst && ysLstCount(lst))
	  {
	    hpos->le = ysLstHead(tbl->grid[hpos->idx]);
	    break;
	  }
      }

  return (hpos->le ? ysLstVal(hpos->le) : (dvoid *) 0);
}


void ysHshRemByPos(yshsh *tbl, yshshpos *hpos)
{
  ysle *le;

  tbl->cnt--;
  le = ysLstPrev(hpos->le);
  DISCARD ysLstRem(tbl->grid[hpos->idx], hpos->le);
  if (!le)
    hpos->idx--;
  hpos->le = le;
}


ub4 ysHshKey(CONST dvoid *key, size_t keysz, ub4 max)
{
  return ysChecksum((ub1 *) key, keysz) % max;
}


STATICF ysle *ysHshLocate(yshsh *tbl, dvoid *key, size_t keysz, ub4 *idx)
{
  ysle *le;
  ub4   i;

  ysmCheck((dvoid *) tbl, YSHSH_TAG);

  
  i = (*tbl->hashfunc)(key, keysz, tbl->rows);
  if (!tbl->grid[i])
    return (ysle *) 0;

  
  for (le = ysLstHead(tbl->grid[i]); le; le = ysLstNext(le))
    if (!(*tbl->eqfunc)(ysLstVal(le), key, keysz))
      break;

  *idx = i;
  return le;
}


static CONST_DATA ub4 ysHshToP[] =
{ 37, 67, 131, 257, 521, 1031, 2053, 4099, 8209, 16411, 32771, 65537 };

STATICF ub4 ysHshPrime(ub4 rows)
{
  size_t tsz;
  ub4  i;

  tsz = sizeof(ysHshToP) / sizeof(ub4);
  for (i = 0; i < tsz && ysHshToP[i] < rows; i++) ;
  return (i < tsz ? ysHshToP[i] : ysHshToP[tsz - 1]);
}
