/* mx/src/ys/ysthr.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YSI_ORACLE
#include <ysi.h>
#endif
#ifndef SYSTHR_ORACLE
#include <systhr.h>
#endif


#define YSTHR_BASE    ((ub4) 8000)
#define YSTHR_ERR(n)  YS_PRODUCT, YS_FACILITY, (YSTHR_BASE + (ub4) (n))


typedef struct ysthrkel ysthrkel;
typedef struct ysthrarg ysthrarg;

struct ysthrctx
{
  CONST_DATA systhrop *ops;                     
  ub4       icnt;                          
  ub4       tcnt;                                      
  ub4       scnt;                                  
  boolean   sdsem;                                          
  ysthrkey *argkey;                                   
};

union ysthrkey
{
  yshsh *tbl;                                   
  dvoid *ptr;                                     
};

struct ysthrkel
{
  ysthr  thrid;                                         
  dvoid *ptr;                                        
};

struct ysthrarg
{
  void  (*start)(dvoid *);                                  
  dvoid  *arg;                                             
  sword   state;                                     
  CONST ysid *exid;                                   
};


externdef ysidDecl(YS_EX_DESTROYED) = "ys::destroyed";
externdef ysidDecl(YS_EX_DEADLOCK) = "ys::deadlock";
static ysidDecl(YS_EX_THREXIT) = "ys::threxit";
static ysmtagDecl(YSTHRKEY_TAG) = "ysthrkey";

#define YSTHRST_RUNNING   ((sword) 0)
#define YSTHRST_SUSPENDED ((sword) 1)

#define YSTHRBY_MTX       ((sword) 2)
#define YSTHRBY_CV        ((sword) 3)


STATICF void ysThrSuspend(sword why);
STATICF void ysThrResume(ysthr *thrid);
STATICF void ysThrMain(dvoid *arg);
STATICF void ysThrIdle(dvoid *arg);
STATICF sword ysThrKeyEq(dvoid *elm, dvoid *key, size_t keysz);
STATICF void ysThrIntrHndlr(dvoid *usrp, CONST ysid *exid,
			    dvoid *arg, size_t argsz);


void ysThrInit(CONST char *name)
{
  CONST_DATA systhrop *CONST_W_PTR *sct;
  ysctx    *ctx;
  ysthrctx *tctx;
  ysthrkey *key;
  ysthrarg *targ;
  dvoid    *old;
  ysle     *le;
  sword     i;
  ysthr     td;
  char      buf[32];

  
  ctx = (ysctx *) yscGet(YSC_YSCTX);
  if (ctx->tctx)
  {
    ctx->tctx->icnt++;
    return;
  }

  
  i = 0, sct = systhrtab;
  if (name)
    {
      while (i < SYSTHRTAB_MAX && strcmp((*sct)->name, name))
	i++, sct++;
    }

  if (i == SYSTHRTAB_MAX)
    yseThrow(YS_EX_BADPARAM);

  if ((*sct)->descsz > YSTHRID_MAX)
    ysePanic(YS_EX_FAILURE);

  
  tctx = (ysthrctx *) ysmGlbAlloc(sizeof(ysthrctx), "ysthrctx");
  tctx->ops = *sct;
  tctx->icnt = 1;
  tctx->tcnt = 1;                      
  tctx->scnt = 0;                             
  tctx->sdsem = FALSE;

  
  if ((*sct)->create(td.id, ysThrIdle, (dvoid *) tctx, (size_t) 0))
    {
      ysRecord(YSTHR_ERR(1), YSLSEV_ERR, (char *) 0, YSLNONE);
      ysmGlbFree((dvoid *) tctx);
      yseThrow(YS_EX_FAILURE);
    }
  else
    ctx->tctx = tctx;

  
  for (le = ysLstHead(ctx->thrkeys); le; le = ysLstNext(le))
    {
      key = (ysthrkey *) ysLstVal(le);
      old = key->ptr;
      key->tbl = ysHshCreate((ub4) 64, (yshash) 0, ysThrKeyEq, ysmFGlbFree);
      DISCARD ysThrKeySet(key, old);
    }

  
  tctx->argkey = ysThrKeyCreate();
  targ = (ysthrarg *) ysmGlbAlloc(sizeof(ysthrarg), "ysthrarg");
  targ->start = (void (*)(dvoid *)) 0;
  targ->arg = (dvoid *) 0;
  targ->state = YSTHRST_RUNNING;
  targ->exid = (ysid *) 0;
  ysThrKeySet(tctx->argkey, (dvoid *) targ);

  
  if (!ctx->intrhndlr)
    DISCARD ysSetIntr(ysThrIntrHndlr, (dvoid *) tctx);

  
  ysRecord(YSTHR_ERR(2), YSLSEV_DEBUG(5), (char *) 0, YSLNONE);
  DISCARD ysThrPrint(ysThrSelf(&td), buf, sizeof(buf));
  ysRecord(YSTHR_ERR(7), YSLSEV_DEBUG(5), (char *) 0, YSLSTR(buf), YSLEND);
}


void ysThrTerm(void)
{
  ysctx    *ctx;
  ysthrctx *tctx;
  ysthrkey *key;
  dvoid    *old;
  ysle     *le;

  
  ctx = (ysctx *) yscGet(YSC_YSCTX);
  tctx = ctx->tctx;
  if (!tctx || --tctx->icnt)
    return;

  if (tctx->tcnt > 1)
    {
      ysRecord(YSTHR_ERR(3), YSLSEV_WARNING, (char *) 0,
	       YSLUB4(tctx->tcnt-1), YSLEND);
    }

  
  tctx->sdsem = TRUE;
  while (tctx->tcnt > 1)
    {
      ysThrIntrHndlr((dvoid *) tctx, YS_EX_SHUTDOWN, (dvoid *) 0, (size_t) 0);
      ysThrYield();
    }

  while (tctx->sdsem)
    ysThrYield();

  
  ysmGlbFree(ysThrKeySet(tctx->argkey, (dvoid *) 0));

  
  for (le = ysLstHead(ctx->thrkeys); le; le = ysLstNext(le))
    {
      key = (ysthrkey *) ysLstVal(le);
      old = ysThrKeyGet(key);
      ysHshDestroy(key->tbl);
      key->ptr = old;
    }

  
  ysmGlbFree((dvoid *) tctx);
  ctx->tctx = (ysthrctx *) 0;

  ysRecord(YSTHR_ERR(4), YSLSEV_DEBUG(5), (char *) 0, YSLNONE);
}


void ysThrCreate(ysthr *thrid, void (*start)(dvoid *), dvoid *arg,
		 size_t stksz)
{
  ysctx    *ctx;
  ysthrctx *tctx;
  ysthrarg *targ;
  ysthr     tmptd;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  tctx = ctx->tctx;
  if (!tctx)
    yseThrow(YS_EX_NOTINIT);

  if (!thrid)
    thrid = &tmptd;

  targ = (ysthrarg *) ysmGlbAlloc(sizeof(ysthrarg), "ysthrarg");
  targ->start = start;
  targ->arg = arg;
  targ->state = YSTHRST_RUNNING;
  targ->exid = (ysid *) 0;

  DISCARD memset((dvoid *) thrid, 0, sizeof(ysthr));
  if (tctx->ops->create(thrid->id, ysThrMain, (dvoid *) targ, stksz))
    {
      ysRecord(YSTHR_ERR(5), YSLSEV_ERR, (char *) 0, YSLNONE);
      ysmGlbFree((dvoid *) targ);
      yseThrow(YS_EX_FAILURE);
    }
  else
    tctx->tcnt++;
}


void ysThrExit(void)
{
  ysthrctx *tctx;

  tctx = ((ysctx *) yscGet(YSC_YSCTX))->tctx;
  yseThrow(tctx ? YS_EX_THREXIT : YS_EX_NOTINIT);
}


void ysThrYield(void)
{
  ysthrctx *tctx;

  tctx = ((ysctx *) yscGet(YSC_YSCTX))->tctx;
  tctx->ops->yield();
}


STATICF void ysThrSuspend(sword why)
{
  ysctx      *ctx;
  ysthrctx   *tctx;
  ysthrarg   *targ;
  CONST ysid *exid;
  ysthr       thrid;
  char        buf[32];

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  tctx = ctx->tctx;
  targ = (ysthrarg *) ysThrKeyGet(tctx->argkey);
  if (!targ || (targ && !targ->exid))
    {
      if (targ)
	targ->state = YSTHRST_SUSPENDED;
      tctx->scnt++;
      tctx->ops->suspend();
    }

  DISCARD ysThrPrint(ysThrSelf(&thrid), buf, sizeof(buf));
  if (targ && targ->exid)
    {
      exid = targ->exid;
      targ->exid = (ysid *) 0;
      ysRecord(YSTHR_ERR(13), YSLSEV_DEBUG(5), (char *) 0,
		  YSLSTR(buf), YSLSTR(ysidToStr(exid)), YSLEND);
      yseThrow(exid);
    }
  else
    ysRecord(YSTHR_ERR(7), YSLSEV_DEBUG(5), (char *) 0, YSLSTR(buf), YSLEND);
}


STATICF void ysThrResume(ysthr *thrid)
{
  ysctx    *ctx;
  ysthrctx *tctx;
  ysthrkel *kel;
  ysthrarg *targ;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  tctx = ctx->tctx;

  
  kel =
    (ysthrkel *) ysHshFind(tctx->argkey->tbl, (dvoid *) thrid, sizeof(ysthr));
  targ = (kel ? (ysthrarg *) kel->ptr : (ysthrarg *) 0);

  
  if (!targ || targ->state == YSTHRST_SUSPENDED)
    {
      if (targ)
	targ->state = YSTHRST_RUNNING;
      tctx->scnt--;
      tctx->ops->resume(thrid->id);
    }
}


ysthr *ysThrSelf(ysthr *thrid)
{
  ysthrctx *tctx;

  tctx = ((ysctx *) yscGet(YSC_YSCTX))->tctx;
  if (tctx)
    {
      DISCARD memset((dvoid *) thrid, 0, sizeof(ysthr));
      tctx->ops->self(thrid->id);
      return thrid;
    }
  else
    return (ysthr *) 0;
}


char *ysThrPrint(ysthr *thrid, char *buf, size_t len)
{
  ysthrctx *tctx;

  tctx = ((ysctx *) yscGet(YSC_YSCTX))->tctx;
  if (!thrid || !tctx)
    DISCARD strcpy(buf, "<none>");
  else
    tctx->ops->print(thrid->id, buf, len);

  return buf;
}


ysthrkey *ysThrKeyCreate(void)
{
  ysctx    *ctx;
  ysthrkey *key;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  key = (ysthrkey *) ysmGlbAlloc(sizeof(ysthrkey), YSTHRKEY_TAG);
  if (ctx->tctx)
    key->tbl = ysHshCreate((ub4) 64, (yshash) 0, ysThrKeyEq, ysmFGlbFree);
  else
    key->ptr = (dvoid *) 0;

  DISCARD ysLstEnq(ctx->thrkeys, (dvoid *) key);
  return key;
}


dvoid *ysThrKeyGet(ysthrkey *key)
{
  ysthr     td;
  ysthrkel *kel;

  ysmCheck(key, YSTHRKEY_TAG);

  if (ysThrSelf(&td))
    {
      kel = (ysthrkel *) ysHshFind(key->tbl, (dvoid *) &td, sizeof(ysthr));
      return (kel ? kel->ptr : (dvoid *) 0);
    }
  else
    return key->ptr;
}


dvoid *ysThrKeySet(ysthrkey *key, dvoid *val)
{
  ysthr     td;
  ysthrkel *kel;
  dvoid    *old;

  ysmCheck(key, YSTHRKEY_TAG);

  if (ysThrSelf(&td))
    {
      if (!val)
	{
	  kel = (ysthrkel *) ysHshRem(key->tbl, (dvoid *) &td, sizeof(td));
	  if (kel)
	    {
	      old = kel->ptr;
	      ysmGlbFree((dvoid *) kel);
	    }
	  else
	    old = (dvoid *) 0;
	}
      else
	{
	  kel = (ysthrkel *) ysHshFind(key->tbl, (dvoid *) &td, sizeof(ysthr));
	  if (!kel)
	    {
	      kel = (ysthrkel *) ysmGlbAlloc(sizeof(ysthrkel), "ysthrkel");
	      DISCARD memcpy((dvoid *) &kel->thrid, (dvoid *) &td, sizeof(td));
	      ysHshIns(key->tbl, (dvoid *) &td, sizeof(td), (dvoid *) kel);
	      old = (dvoid *) 0;
	    }
	  else
	    old = kel->ptr;

	  kel->ptr = val;
	}
    }
  else
    {
      old = key->ptr;
      key->ptr = val;
    }

  return old;
}


void ysMtxCreate(ysmtx *mtx, sword type)
{
  mtx->type = type;
  mtx->locked = FALSE;
  mtx->waiters = (yslst *) 0;
}


void ysMtxDestroy(ysmtx *mtx)
{
  ysthr *tid;

  mtx->type = (sword) 0;
  mtx->locked = FALSE;
  if (mtx->waiters)
    {
      ysLstDestroy(mtx->waiters, (ysmff) 0);
      mtx->waiters = (yslst *) 0;
    }
}


void ysMtxLock(ysmtx *mtx)
{
  ysle *le;
  ysthr tid;

  if (mtx->type == YSMTXTYPE_INTR)
    ysEnterCR();

  while (mtx->locked)
    {
      if (!ysThrSelf(&tid))
	ysePanic(YS_EX_DEADLOCK);
      if (!mtx->waiters)
	mtx->waiters = ysLstCreate();
      le = ysLstEnq(mtx->waiters, (dvoid *) &tid);
      yseTry
	ysThrSuspend(YSTHRBY_MTX);
      yseCatchAll
	{
	  DISCARD ysLstRem(mtx->waiters, le);
	  if (mtx->type == YSMTXTYPE_INTR)
	    ysExitCR();
	  yseRethrow;
	}
      yseEnd
    }

  mtx->locked = TRUE;
}


boolean ysMtxTryLock(ysmtx *mtx)
{
  boolean ok;

  if (mtx->type == YSMTXTYPE_INTR)
    ysEnterCR();

  ok = !mtx->locked;
  if (ok)
    mtx->locked = TRUE;
  else if (mtx->type == YSMTXTYPE_INTR)
    ysExitCR();

  return ok;
}


void ysMtxUnlock(ysmtx *mtx)
{
  ysthr *tid;

  if (!mtx->locked)
    yseThrow(YS_EX_BADPARAM);
  else
    {
      mtx->locked = FALSE;

      tid = (mtx->waiters ? (ysthr *) ysLstDeq(mtx->waiters) : (ysthr *) 0);

      if (mtx->type == YSMTXTYPE_INTR)
	ysExitCR();

      if (tid)
	ysThrResume(tid);
    }
}


void ysCondCreate(yscv *cv)
{
  cv->val = (ub4) 0;
  ysMtxCreate(&cv->mtx, YSMTXTYPE_NORMAL);
  cv->waiters = (yslst *) 0;
}


void ysCondDestroy(yscv *cv)
{
  ysthr *tid;

  ysMtxDestroy(&cv->mtx);
  if (cv->waiters)
    {
      ysLstDestroy(cv->waiters, (ysmff) 0);
      cv->waiters = (yslst *) 0;
    }
}


void ysCondWait(yscv *cv, ysmtx *mtx)
{
  ysctx *ctx;
  ub4    val;
  ysle  *le;
  ysthr  tid;

  val = cv->val;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  if (!ctx->tctx)
    {
      

      
      if (mtx->type != YSMTXTYPE_INTR)
	{
	  ysMtxUnlock(mtx);
	  ysEnterCR();
	}
      else if (mtx->locked)
	mtx->locked = FALSE;
      else
	yseThrow(YS_EX_BADPARAM);

      
      while (ysIdle()) ;
      while (!ctx->usrintr && val == cv->val)
	{
	  ysBlock();
	  while (ysIdle());
	}

      

      
      if (mtx->type != YSMTXTYPE_INTR)
	{
	  ysExitCR();
	  ysMtxLock(mtx);
	}
      else
	mtx->locked = TRUE;

      

      if (ctx->usrintr)
	ysIntrHandle(ctx);
    }
  else
    {
      

      
      ysMtxUnlock(mtx);
      ysMtxLock(&cv->mtx);

      
      if (val == cv->val)
	{
	  
	  DISCARD ysThrSelf(&tid);
	  if (!cv->waiters)
	    cv->waiters = ysLstCreate();
	  le = ysLstEnq(cv->waiters, (dvoid *) &tid);
	  ysMtxUnlock(&cv->mtx);
	  yseTry
	    ysThrSuspend(YSTHRBY_CV);
	  yseCatchAll
	    {
	      DISCARD ysLstRem(cv->waiters, le);
	      ysMtxLock(mtx);
	      yseRethrow;
	    }
	  yseEnd
	}
      else
	ysMtxUnlock(&cv->mtx);

      ysMtxLock(mtx);
    }
}


void ysCondSignal(yscv *cv)
{
  ysthr *tid;

  
  ysMtxLock(&cv->mtx);

  
  cv->val++;

  
  tid = (cv->waiters ? (ysthr *) ysLstDeq(cv->waiters) : (ysthr *) 0);

  
  ysMtxUnlock(&cv->mtx);

  if (tid)
    ysThrResume(tid);
}


void ysCondBroadcast(yscv *cv)
{
  ysthr *tid;

  
  ysMtxLock(&cv->mtx);

  
  cv->val++;

  
  if (cv->waiters)
    while (tid = (ysthr *) ysLstDeq(cv->waiters))
      ysThrResume(tid);

  
  ysMtxUnlock(&cv->mtx);
}


void ysThrSignal(ysthr *thrid, CONST ysid *exid)
{
  ysctx    *ctx;
  ysthrctx *tctx;
  ysthrkel *kel;
  ysthrarg *targ;
  ysthr     tid;
  char      buf[32];

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  tctx = ctx->tctx;
  if (!tctx)
    yseThrow(YS_EX_NOTINIT);

  if (!thrid)
    {
      thrid = &tid;
      DISCARD ysThrSelf(thrid);
    }

  
  kel =
    (ysthrkel *) ysHshFind(tctx->argkey->tbl, (dvoid *) thrid, sizeof(ysthr));
  targ = (kel ? (ysthrarg *) kel->ptr : (ysthrarg *) 0);

  
  if (!targ)
    yseThrow(YS_EX_BADPARAM);

  
  targ->exid = exid;
  if (targ->state == YSTHRST_SUSPENDED)
    ysThrResume(thrid);
}


STATICF void ysThrMain(dvoid *arg)
{
  ysctx    *ctx;
  ysthrctx *tctx;
  ysthrarg *targ;
  ub4       msgid;
  ysthr     thrid;
  char      buf[32];

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  tctx = ctx->tctx;
  DISCARD ysThrPrint(ysThrSelf(&thrid), buf, sizeof(buf));
  ysRecord(YSTHR_ERR(9), YSLSEV_DEBUG(5), (char *) 0, YSLSTR(buf), YSLEND);

  DISCARD ysThrKeySet(tctx->argkey, (dvoid *) arg);
  targ = (ysthrarg *) arg;
  yseTry
    targ->start(targ->arg);
    msgid = (ub4) 12;
  yseCatch(YS_EX_THREXIT)
    msgid = (ub4) 11;
  yseCatchAll
    msgid = (ub4) 0;
    ysRecord(YSTHR_ERR(10), YSLSEV_ERR, (char *) 0,
		YSLSTR(buf), YSLSTR(yseExid), YSLEND);
  yseEnd

  if (msgid)
    ysRecord(YSTHR_ERR(msgid), YSLSEV_DEBUG(5), (char *) 0,
	     YSLSTR(buf), YSLEND);

  ysmGlbFree(ysThrKeySet(tctx->argkey, (dvoid *) 0));
  tctx->tcnt--;
  tctx->ops->exit();
}


STATICF void ysThrIdle(dvoid *arg)
{
  CONST_DATA systhrop *ops;
  ysctx    *ctx;
  ysthrctx *tctx;
  ysthr     tid;
  char      buf[32];

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  tctx = (ysthrctx *) arg;
  ysRecord(YSTHR_ERR(15), YSLSEV_DEBUG(5), (char *) 0,
	   YSLSTR(ysThrPrint(ysThrSelf(&tid), buf, sizeof(buf))), YSLEND);

  
  while (!tctx->sdsem)
    {
      if (tctx->scnt < tctx->tcnt)
	DISCARD ysIdle();
      else
	{
	  ysEnterCR();
	  if (!ysIdle())
	    ysBlock();
	  ysExitCR();
	}

      if (ctx->usrintr)
	{
	  yseTry
	    ysIntrHandle(ctx);
	  yseCatchAll
	    ysThrIntrHndlr((dvoid *) 0, yseExid, (dvoid *) 0, (size_t) 0);
	  yseEnd
	}

      tctx->ops->yield();
    }

  ysRecord(YSTHR_ERR(12), YSLSEV_DEBUG(5), (char *) 0, YSLSTR(buf), YSLEND);
  ops = tctx->ops;
  tctx->sdsem = FALSE;
  ops->exit();
}


STATICF sword ysThrKeyEq(dvoid *elm, dvoid *key, size_t keysz)
{
  ysthrkel *kel;

  kel = (ysthrkel *) elm;
  return (sword) memcmp((dvoid *) &kel->thrid, key, sizeof(ysthr));
}


STATICF void ysThrIntrHndlr(dvoid *usrp, CONST ysid *exid,
			    dvoid *arg, size_t argsz)
{
  ysthrctx *tctx;
  ysthrkel *kel;
  ysthrarg *targ;
  yshshpos  hpos;

  
  tctx = (ysthrctx *) usrp;
  kel = (ysthrkel *) ysHshFirst(tctx->argkey->tbl, &hpos);
  while (kel)
    {
      targ = (ysthrarg *) kel->ptr;
      targ->exid = exid;
      if (targ->state == YSTHRST_SUSPENDED)
	{
	  ysThrResume(&kel->thrid);
	  break;
	}
      else
	kel = (ysthrkel *) ysHshNext(tctx->argkey->tbl, &hpos);
    }
}
