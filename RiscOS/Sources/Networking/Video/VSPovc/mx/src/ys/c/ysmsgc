/* mx/src/ys/ysmsgc.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSSP_ORACLE
#include <yssp.h>
#endif
#ifndef YSMSG_ORACLE
#include <ysmsg.h>
#endif
#ifndef SYSFP_ORACLE
#include <sysfp.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif


#define YSMSGC_BASE    ((ub4) 9000)
#define YSMSGC_ERR(n)  YS_PRODUCT, YSMSGC_FACILITY, (YSMSGC_BASE + (ub4) (n))


typedef struct ysmsgctx ysmsgctx;
typedef struct ysmsgdesc ysmsgdesc;


struct ysmsgctx
{
  sword       mode;                                        
  sword       output;                                         
  sword       style;                                          
  sword       dest;                                     
  yslst      *fnlst;                                   
  yslst      *paths;                                   
  CONST char *sfx;                                
  char        fn[SYSFP_MAX_PATHLEN];              
};

struct ysmsgdesc
{
  ysspNode node;                                            
  sb4      id;                                                 
  char    *txt;                                              
};



static struct ysargmap ysmsgcArgs[] =
{
  { 'c', "ysmsgc.mode=compile", 0 },                         
  { 'v', "ysmsgc.mode=verify", 0 },                           
  { 'l', "ysmsgc.mode=lookup", 0 },                           
  { 't', "ysmsgc.mode=translate", 0 },                     
  { 'S', "ysmsgc.mode=symbols", 0 },                         
  { 'D', "omn.message-compiler.header-file", 1 },                 
  { 'M', "omn.message-compiler.macro-prefix", 1 },                
  { 'B', "omn.message-compiler.id-base", 1 },                        
  { 'I', "ys.log.msg-path", YSARG_MANY },                             
  { 's', "ysmsgc.src-style", 1 },                          
  { 'd', "ysmsgc.dst-style", 1 },                          
  { 'o', "ysmsgc.output-name", 1 },                    
  { 'n', "ysmsgc.output=none", 0 },                        
  { 'F', "ysmsgc.output=force", 0 },                   
  { 'u', "ysmsgc.unused-list=true", 0 },                           
  { 'm', "ysmsgc.msgid", YSARG_MANY },                             
  { 'p', "ysmsgc.product", 1 },                                       
  { 'f', "ysmsgc.facility", 1 },                                      
  { YSARG_OPTPARAM, "ysmsgc.pathname", YSARG_MANY },                  
  { 0 }
};

#define YSMSGC_NONE       ((sword) 1)
#define YSMSGC_COMPILE    ((sword) 2)
#define YSMSGC_VERIFY     ((sword) 3)
#define YSMSGC_LOOKUP     ((sword) 4)
#define YSMSGC_TRANSLATE  ((sword) 5)
#define YSMSGC_SYMBOLS    ((sword) 6)

#define YSMSGC_NONE       ((sword) 1)
#define YSMSGC_NORMAL     ((sword) 2)
#define YSMSGC_FORCE      ((sword) 3)

#define YSMSGC_STYLE_OMN  ((sword) 1)
#define YSMSGC_STYLE_LMS  ((sword) 2)
#define YSMSGC_STYLE_MZL  ((sword) 3)

static ysidDecl(YSMSGC_FACILITY) =  "MSGC";


STATICF void ysmsgcDoArgs(ysmsgctx *ctx);
STATICF sword ysmsgcCompile(ysmsgctx *ctx);
STATICF sword ysmsgcLookup(ysmsgctx *ctx);
STATICF sword ysmsgcTranslate(ysmsgctx *ctx);
STATICF sword ysmsgcVerify(ysmsgctx *ctx);
STATICF sword ysmsgcSymbols(ysmsgctx *ctx);
STATICF sysfp *ysmsgcOpen(ysmsgctx *ctx, char *fn, char **pathp);
STATICF ysmsgdesc *ysmsgcParse(ysmsgctx *ctx, char *buf,
			       ysspTree *tree, ub4 lcnt);
STATICF sword ysmsgcMsgCmp(CONST dvoid *a, CONST dvoid *b);
STATICF void ysmsgcTreeFree(ysspTree *tree);
STATICF boolean ysmsgcGetLine(char *buf, size_t buflen, sysfp *fp);


boolean ysmsgc(dvoid *osdp, char *nm, sword argc, char **argv)
{
  ysmsgctx ctx;
  sword    sts, ln;
  CONST    char *fn;
  char     buf[80];

  ysInit(osdp, nm);
  sts = ysArgParse(argc, argv, ysmsgcArgs);
  if (sts == YSARG_NORMAL)
    {
      DISCARD memset(&ctx, 0, sizeof(ctx));
      yseTry
	{
	  ysmsgcDoArgs(&ctx);
	  switch (ctx.mode)
	    {
	    case YSMSGC_COMPILE: sts = ysmsgcCompile(&ctx); break;
	    case YSMSGC_LOOKUP: sts = ysmsgcLookup(&ctx); break;
	    case YSMSGC_TRANSLATE: sts = ysmsgcTranslate(&ctx); break;
	    case YSMSGC_VERIFY: sts = ysmsgcVerify(&ctx); break;
	    case YSMSGC_SYMBOLS: sts = ysmsgcSymbols(&ctx); break;
	    case YSMSGC_NONE: sts = YSARG_ERROR; break;
	    }

	}
      yseCatchAll
	yseGetLoc(&fn, &ln);
	ysRecord(YSMSGC_ERR(1), YSLSEV_ALERT, (char *) 0,
		 YSLSTR(ysidToStr(yseExid)), YSLSTR(fn), YSLSB4(ln),
		 YSLEND);
      yseEnd

      
      if (ctx.fnlst)
	ysLstDestroy(ctx.fnlst, ysmFGlbFree);
    }
  else if (sts == YSARG_VERSION)
    yslError(ysVersion(buf, sizeof(buf)));

  ysTerm(osdp);
  return (sts == YSARG_NORMAL);
}


STATICF void ysmsgcDoArgs(ysmsgctx *ctx)
{
  char  *mode, *prod, *fac, *fn;
  yslst *tmplst;
  ysle  *le, *le2;
  CONST char *srcexpr;
  char   nm[128], result[SYSFP_MAX_PATHLEN];

  
  if (ysResGetBool("ysmsgc.verbose"))
    srcexpr = "prod OMN fac MSGC maxsev 8";
  else
    srcexpr = "prod OMN fac MSGC maxsev 6";
  ysAddFilter(ysSinkFind("tty"), srcexpr);

  
  if (ysResGet("ysmsgc.msgid"))
    ysResSet("ysmsgc.mode", "lookup");

  
  mode = ysResGetLast("ysmsgc.mode");
  if (!mode)
    ctx->mode = YSMSGC_COMPILE;
  else if (!strcmp(mode, "compile"))
    ctx->mode = YSMSGC_COMPILE;
  else if (!strcmp(mode, "verify"))
    ctx->mode = YSMSGC_VERIFY;
  else if (!strcmp(mode, "lookup"))
    ctx->mode = YSMSGC_LOOKUP;
  else if (!strcmp(mode, "translate"))
    ctx->mode = YSMSGC_TRANSLATE;
  else if (!strcmp(mode, "symbols"))
    ctx->mode = YSMSGC_SYMBOLS;
  else
    {
      ysRecord(YSMSGC_ERR(2), YSLSEV_ERR, (char *) 0, YSLSTR(mode), YSLEND);
      ctx->mode = YSMSGC_NONE;
      return;
    }

  
  mode = ysResGetLast("ysmsgc.output");
  if (!mode)
    ctx->output = YSMSGC_NORMAL;
  else if (!strcmp(mode, "normal"))
    ctx->output = YSMSGC_NORMAL;
  else if (!strcmp(mode, "none"))
    ctx->output = YSMSGC_NONE;
  else if (!strcmp(mode, "force"))
    ctx->output = YSMSGC_FORCE;
  else
    {
      ysRecord(YSMSGC_ERR(9), YSLSEV_ERR, (char *) 0, YSLSTR(mode), YSLEND);
      ctx->mode = YSMSGC_NONE;
      return;
    }

  
  mode = ysResGetLast("ysmsgc.src-style");
  if (!mode)
    ctx->style = YSMSGC_STYLE_OMN;
  else if (!strcmp(mode, "omn"))
    ctx->style = YSMSGC_STYLE_OMN;
  else if (!strcmp(mode, "lms"))
    ctx->style = YSMSGC_STYLE_LMS;
  else if (!strcmp(mode, "mzl"))
    ctx->style = YSMSGC_STYLE_MZL;
  else
    {
      ysRecord(YSMSGC_ERR(13), YSLSEV_ERR, (char *) 0, YSLSTR(mode), YSLEND);
      ctx->mode = YSMSGC_NONE;
      return;
    }

  
  mode = ysResGetLast("ysmsgc.dst-style");
  if (!mode)
    ctx->dest = YSMSGC_STYLE_OMN;
  else if (!strcmp(mode, "omn"))
    ctx->dest = YSMSGC_STYLE_OMN;
  else if (!strcmp(mode, "lms"))
    ctx->dest = YSMSGC_STYLE_LMS;
  else
    {
      ysRecord(YSMSGC_ERR(17), YSLSEV_ERR, (char *) 0, YSLSTR(mode), YSLEND);
      ctx->mode = YSMSGC_NONE;
      return;
    }

  
  tmplst = ysResGet("ysmsgc.pathname");
  prod = ysResGetLast("ysmsgc.product");
  fac = ysResGetLast("ysmsgc.facility");

  DISCARD sysfpGetCwd(result);
  if (ysResGet("ys.log.msg-path"))
    {
      for (le = ysLstHead(ysResGet("ys.log.msg-path")); le; le = ysLstNext(le))
	if (!strcmp((char *) ysLstVal(le), result))
	  break;
    }

  if (!le)
    ysResSet("ys.log.msg-path", result);

  ctx->paths = ysResGet("ys.log.msg-path");
  ctx->sfx = (ctx->mode == YSMSGC_VERIFY ? YSMSG_SFX : "msg");

  if (!tmplst && !prod)
    {
      ysRecord(YSMSGC_ERR(3), YSLSEV_ERR, (char *) 0, YSLNONE);
      ctx->mode = YSMSGC_NONE;
      return;
    }

  
  if (prod && fac)
    {
      DISCARD sprintf(nm, "%s%s", prod, fac);
      ctx->fnlst = ysLstCreate();
      DISCARD ysLstEnq(ctx->fnlst, (dvoid *) ysStrDup(nm));
    }
  else if (tmplst)
    {
      fn = (char *) ysLstVal(ysLstTail(tmplst));
      if (sysfpIsDir(fn))
	{
	  ctx->fnlst = sysfpGetDir(fn);
	  ysResSet("ys.log.msg-path", fn);
	  ctx->paths = ysResGet("ys.log.msg-path");

	  
	  le = ysLstHead(ctx->fnlst);
	  while (le)
	    {
	      le2 = ysLstNext(le);
	      sysfpExtractSuffix(result, (char *) ysLstVal(le));
	      if (strcmp(ctx->sfx, result))
		ysmGlbFree(ysLstRem(ctx->fnlst, le));
	      le = le2;
	    }
	}
      else
	{
	  ctx->paths = (yslst *) 0;
	  ctx->sfx = (char *) 0;
	  ctx->fnlst = ysLstCreate();
	  for (le = ysLstHead(tmplst); le; le = ysLstNext(le))
	    DISCARD ysLstEnq(ctx->fnlst,
			     (dvoid *) ysStrDup((char *) ysLstVal(le)));
	}
    }
  else
    {
      
      ctx->fnlst = ysLstCreate();
      for (le = ysLstHead(ctx->paths); le; le = ysLstNext(le))
	{
	  tmplst = sysfpGetDir((char *) ysLstVal(le));
	  if (tmplst)
	    {
	      for (le2 = ysLstHead(tmplst); le2; le2 = ysLstNext(le2))
		DISCARD ysLstEnq(ctx->fnlst, ysLstVal(le2));
	      ysLstDestroy(tmplst, (ysmff) 0);
	    }
	  else
	    ysRecord(YSMSGC_ERR(20), YSLSEV_ERR, (char *) 0,
		     YSLSTR((char *) ysLstVal(le)), YSLNONE);
	}

      
      le = ysLstHead(ctx->fnlst);
      while (le)
	{
	  le2 = ysLstNext(le);
	  fn = (char *) ysLstVal(le);
	  sysfpExtractBase(result, fn);
	  if (strncmp(prod, result, strlen(prod)))
	    ysmGlbFree(ysLstRem(ctx->fnlst, le));
	  else
	    {
	      sysfpExtractSuffix(result, fn);
	      if (strcmp(ctx->sfx, result))
		ysmGlbFree(ysLstRem(ctx->fnlst, le));
	    }
	  le = le2;
	}
    }

  
  if (ctx->mode == YSMSGC_LOOKUP)
    {
      tmplst = ysResGet("ysmsgc.msgid");
      if (!tmplst)
	{
	  ysRecord(YSMSGC_ERR(14), YSLSEV_ERR, (char *) 0, YSLNONE);
	  ctx->mode = YSMSGC_NONE;
	}
      else
	{
	  for (le = ysLstHead(tmplst);
	       le && atol((char *) ysLstVal(le));
	       le = ysLstNext(le)) ;

	  if (le)
	    {
	      ysRecord(YSMSGC_ERR(15), YSLSEV_ERR, (char *) 0,
			  YSLSTR((char *) ysLstVal(le)), YSLEND);
	      ctx->mode = YSMSGC_NONE;
	    }
	}
    }
}


STATICF sword ysmsgcCompile(ysmsgctx *ctx)
{
  ysle       *le;
  sword       sts;
  sysfp      *fp;
  char       *path;
  ub4         lcnt, ecnt, mcnt;
  sb4         lowid, highid, off, len, llen, lmsgid;
  ysspTree    tree;
  ysmsgdesc  *msg;
  CONST char *errtxt;
  ub1         buf[12];
  char        nm[512], tmpnm[SYSFP_MAX_PATHLEN], result[SYSFP_MAX_PATHLEN];

  sts = YSARG_NORMAL;

  
  for (le = ysLstHead(ctx->fnlst); le && sts == YSARG_NORMAL;
       le = ysLstNext(le))
    {
      
      sysfpForm(ctx->fn, (char *) 0, (char *) ysLstVal(le), ctx->sfx);
      fp = ysmsgcOpen(ctx, (char *) ysLstVal(le), &path);
      if (!fp)
	{
	  sts = YSARG_ERROR;
	  continue;
	}

      
      DISCARD ysspNewTree(&tree, ysmsgcMsgCmp);
      lcnt = 0, ecnt = 0, mcnt = 0;
      while (ysmsgcGetLine(nm, sizeof(nm), fp))
	{
	  lcnt++;
	  if (isdigit(nm[0]))
	    {
	      
	      msg = ysmsgcParse(ctx, nm, &tree, lcnt);
	      if (!msg)
		ecnt++;
	      else
		{
		  DISCARD ysspEnq((ysspNode *) (dvoid *) msg, &tree);
		  mcnt++;
		}
	    }
	  else if (nm[0] != '#' && nm[0] != '/' && nm[0] != '\n')
	    ysRecord(YSMSGC_ERR(5), YSLSEV_NOTICE, (char *) 0,
		     YSLSTR(ctx->fn), YSLUB4(lcnt), YSLEND);
	}

      sysfpClose(fp);
      if (!mcnt || (ecnt && ctx->output != YSMSGC_FORCE))
	{
	  ysRecord(YSMSGC_ERR(6), YSLSEV_ERR, (char *) 0,
		   YSLSTR(ctx->fn), YSLEND);
	  ysmsgcTreeFree(&tree);
	  sts = YSARG_ERROR;
	  continue;
	}

      
      msg = (ysmsgdesc *) (dvoid *) ysspFHead(&tree);
      lowid = msg->id;
      msg = (ysmsgdesc *) (dvoid *) ysspFTail(&tree);
      highid = msg->id;
      ysRecord(YSMSGC_ERR(51), YSLSEV_INFO, (char *) 0,
	       YSLSTR(ctx->fn), YSLUB4(lcnt), YSLUB4(mcnt),
	       YSLSB4(lowid), YSLSB4(highid), YSLEND);

      if (ctx->output == YSMSGC_NONE)
	{
	  ysmsgcTreeFree(&tree);
	  ysRecord(YSMSGC_ERR(52), YSLSEV_INFO, (char *) 0,
		   YSLSTR(ctx->fn), YSLEND);
	  continue;
	}

      
      sysfpTemp(tmpnm, path, (char *) 0);
      fp = sysfpOpen(tmpnm, "w", SYSFPKIND_BINARY, &errtxt);
      if (!fp)
	{
	  ysRecord(YSMSGC_ERR(7), YSLSEV_ERR, (char *) 0,
		   YSLSTR(tmpnm), YSLSTR(errtxt), YSLEND);
	  ysmsgcTreeFree(&tree);
	  sts = YSARG_ERROR;
	  continue;
	}

      
      sysxPutB4(buf, YSMSG_MAGIC);
      sysxPutB4(buf + 4, (ub4) lowid);
      sysxPutB4(buf + 8, (ub4) highid);
      DISCARD sysfpWrite(fp, (dvoid *) buf, (size_t) 12);

      
      off = (highid - lowid + 1) * 8 + 12;
      msg = (ysmsgdesc *) (dvoid *) ysspFHead(&tree);
      lmsgid = lowid - 1;
      do
	{
	  while (++lmsgid < msg->id)
	    {
	      DISCARD memset(buf, 0, (size_t) 8);
	      DISCARD sysfpWrite(fp, (dvoid *) buf, (size_t) 8);
	    }

	  sysxPutB4(buf, (ub4) off);
	  len = strlen(msg->txt) + 1;
	  sysxPutB4(buf + 4, (ub4) len);
	  DISCARD sysfpWrite(fp, (dvoid *) buf, (size_t) 8);
	  off += len;
	}
      while (msg =
	     (ysmsgdesc *) (dvoid *) ysspFNext((ysspNode *) (dvoid *) msg));

      
      msg = (ysmsgdesc *) (dvoid *) ysspFHead(&tree);
      do
	{
	  len = strlen(msg->txt) + 1;
	  llen = sysfpWrite(fp, (dvoid *) msg->txt, (size_t) len);
	}
      while (msg =
	     (ysmsgdesc *) (dvoid *) ysspFNext((ysspNode *) (dvoid *) msg));

      sysfpClose(fp);
      ysmsgcTreeFree(&tree);

      if (llen != len)
	{
	  ysRecord(YSMSGC_ERR(8), YSLSEV_ERR, (char *) 0,
		   YSLSTR(tmpnm), YSLEND);
	  DISCARD sysfpRemove(tmpnm);
	  sts = YSARG_ERROR;
	  continue;
	}

      
      if (ysResGetLast("ysmsgc.output-name"))
	sysfpForm(result, (char *) 0, ysResGetLast("ysmsgc.output-name"),
		  YSMSG_SFX);
      else
	{
	  sysfpExtractBase(nm, ctx->fn);
	  sysfpForm(result, path, nm, YSMSG_SFX);
	}
      
      if (errtxt = sysfpRename(tmpnm, result))
	{
	  ysRecord(YSMSGC_ERR(7), YSLSEV_ERR, (char *) 0,
		   YSLSTR(result), YSLSTR(errtxt), YSLEND);
	  DISCARD sysfpRemove(tmpnm);
	  sts = YSARG_ERROR;
	  continue;
	}
      else
	ysRecord(YSMSGC_ERR((ecnt ? (ub4) 54 : (ub4) 53)), YSLSEV_INFO,
		 (char *) 0, YSLSTR(result), YSLEND);
    }

  return sts;
}


STATICF sword ysmsgcLookup(ysmsgctx *ctx)
{
  sysfp     *fp;
  char      *path;
  yslst     *tmplst, *idlst;
  ysle      *le, *le2;
  ysmsgdesc *msg;
  ysspTree   tree;
  ub4        lcnt;
  boolean    body;
  char       buf[512];

  tmplst = ysResGet("ysmsgc.msgid");
  idlst = ysLstCreate();
  for (le = ysLstHead(tmplst); le; le = ysLstNext(le))
    DISCARD ysLstEnq(idlst, ysLstVal(le));

  
  for (le2 = ysLstHead(ctx->fnlst);
       le2 && ysLstCount(idlst);
       le2 = ysLstNext(le2))
    {
      
      sysfpForm(ctx->fn, (char *) 0, (char *) ysLstVal(le2), ctx->sfx);
      fp = ysmsgcOpen(ctx, (char *) ysLstVal(le2), &path);
      if (!fp)
	continue;

      
      DISCARD ysspNewTree(&tree, ysmsgcMsgCmp);
      lcnt = 0;
      while (ysmsgcGetLine(buf, sizeof(buf), fp) && ysLstCount(idlst))
	{
	  lcnt++;
	  if (isdigit(buf[0]))
	    {
	      
	      msg = ysmsgcParse(ctx, buf, &tree, lcnt);
	      if (msg)
		{
		  for (le = ysLstHead(idlst); le; le = ysLstNext(le))
		    if (atol((char *) ysLstVal(le)) == msg->id)
		      break;

		  if (le)
		    {
		      body = FALSE;
		      yslPrint("%d, \"%s\"\n", msg->id, msg->txt);
		      while (ysmsgcGetLine(buf, sizeof(buf), fp))
			{
			  lcnt++;
			  if (buf[0] != '/' || buf[1] != '/')
			    break;
			  else
			    {
			      body = TRUE;
			      yslPrint("%s", buf);
			    }
			}
		      DISCARD ysLstRem(idlst, le);

		      if (!body)
			yslPrint("// *No Detail\n");
		    }

		  ysmGlbFree((dvoid *) msg->txt);
		  ysmGlbFree((dvoid *) msg);
		}
	    }
	}

      sysfpClose(fp);
    }

  for (le = ysLstHead(idlst); le; le = ysLstNext(le))
    ysRecord(YSMSGC_ERR(16), YSLSEV_WARNING, (char *) 0,
	     YSLSB4(atol((char *) ysLstVal(le))), YSLEND);

  ysLstDestroy(idlst, (ysmff) 0);
  return YSARG_NORMAL;
}


STATICF sword ysmsgcTranslate(ysmsgctx *ctx)
{
  sysfp      *fp, *fpo;
  char       *path;
  ysle       *le;
  ub4         lcnt, ecnt;
  ysre       *re;
  boolean     rematch;
  ysmsgdesc  *msg;
  ysspTree    tree;
  CONST char *errtxt;
  char        buf[512], tmpnm[SYSFP_MAX_PATHLEN], result[SYSFP_MAX_PATHLEN];

  for (le = ysLstHead(ctx->fnlst); le; le = ysLstNext(le))
    {
      
      sysfpForm(ctx->fn, (char *) 0, (char *) ysLstVal(le), ctx->sfx);
      fp = ysmsgcOpen(ctx, (char *) ysLstVal(le), &path);
      if (!fp)
	continue;

      sysfpTemp(tmpnm, path, (char *) 0);
      fpo = sysfpOpen(tmpnm, "w", SYSFPKIND_TEXT, &errtxt);
      if (!fpo)
	{
	  ysRecord(YSMSGC_ERR(7), YSLSEV_ERR, (char *) 0,
		   YSLSTR(tmpnm), YSLSTR(errtxt), YSLEND);
	  sysfpClose(fp);
	  continue;
	}

      
      DISCARD ysspNewTree(&tree, ysmsgcMsgCmp);
      lcnt = 0, ecnt = 0;
      re = ysRECompile("# \\*Action|# \\*Cause", FALSE);
      rematch = FALSE;
      while (ysmsgcGetLine(buf, sizeof(buf), fp))
	{
	  lcnt++;
	  if (isdigit(buf[0]))
	    {
	      
	      rematch = FALSE;
	      msg = ysmsgcParse(ctx, buf, &tree, lcnt);
	      if (!msg)
		ecnt++;
	      else if (ctx->dest == YSMSGC_STYLE_OMN)
		DISCARD sysfpPrint(fpo, "%d, \"%s\"\n", msg->id, msg->txt);
	      else
		DISCARD sysfpPrint(fpo, "%05d, 00000, \"%s\"\n",
				   msg->id, msg->txt);
	    }
	  else if (ctx->style == YSMSGC_STYLE_MZL)
	    {
	      if (ysREMatch(re, buf, TRUE))
		{
		  DISCARD sysfpPrint(fpo, "// %s", buf + 2);
		  rematch = TRUE;
		}
	      else if (rematch && buf[0] == '#' && strlen(buf) > (size_t) 2)
		DISCARD sysfpPrint(fpo, "// %s", buf + 2);
	      else
		{
		  DISCARD sysfpWrite(fpo, (dvoid *) buf, strlen(buf));
		  rematch = FALSE;
		}
	    }
	  else
	    DISCARD sysfpWrite(fpo, (dvoid *) buf, strlen(buf));
	}
      ysREFree(re);

      sysfpClose(fp);
      sysfpClose(fpo);

      if (ecnt)
	{
	  ysRecord(YSMSGC_ERR(6), YSLSEV_ERR, (char *) 0,
		   YSLSTR(ctx->fn), YSLUB4(lcnt), YSLEND);
	  DISCARD sysfpRemove(tmpnm);
	  continue;
	}

      
      if (ysResGetLast("ysmsgc.output-name"))
	sysfpForm(result, (char *) 0, ysResGetLast("ysmsgc.output-name"),
		  "msg");
      else
	{
	  sysfpExtractBase(buf, ctx->fn);
	  sysfpForm(result, path, buf, "msg");
	}

      if (errtxt = sysfpRename(tmpnm, result))
	{
	  ysRecord(YSMSGC_ERR(7), YSLSEV_ERR, (char *) 0,
		   YSLSTR(result), YSLSTR(errtxt), YSLEND);
	  DISCARD sysfpRemove(tmpnm);
	}
      else
	ysRecord(YSMSGC_ERR(58), YSLSEV_INFO, (char *) 0,
		 YSLSTR(result), YSLEND);
    }

  return YSARG_NORMAL;
}


STATICF sword ysmsgcVerify(ysmsgctx *ctx)
{
  ysle   *le;
  sysfp  *fp;
  char   *path, *tmp;
  ub4     idmin, idmax, off, len;
  size_t  sz;
  sysb8   off_8;
  sword   i;
  ub1    *tbl, *bp;
  boolean unused, verbose;
  ub1     buf[12];

  unused = ysResGetBool("ysmsgc.unused-list");
  verbose = ysResGetBool("ysmsgc.verbose");

  
  for (le = ysLstHead(ctx->fnlst); le; le = ysLstNext(le))
    {
      
      sysfpForm(ctx->fn, (char *) 0, (char *) ysLstVal(le), ctx->sfx);
      fp = ysmsgcOpen(ctx, (char *) ysLstVal(le), &path);
      if (!fp)
	continue;

      tbl = (ub1 *) 0;

      if (sysfpRead(fp, (dvoid *) buf, 12) != 12)
	{
	  ysRecord(YSMSGC_ERR(18), YSLSEV_ERR, (char *) 0,
		   YSLSTR(ctx->fn), YSLEND);
	  goto error;
	}

      if (sysxGetB4(buf) != YSMSG_MAGIC)
	{
	  ysRecord(YSMSGC_ERR(19), YSLSEV_ERR, (char *) 0,
		   YSLSTR(ctx->fn), YSLEND);
	  goto error;
	}

      idmin = sysxGetB4(buf + 4);
      idmax = sysxGetB4(buf + 8);
      yslPrint("%s: range %d-%d\n", ctx->fn, idmin, idmax);
      if (unused && !verbose)
	yslPrint("%s: unused list: ");

      sz = (size_t) ((idmax - idmin + 1) * 8);
      tbl = (ub1 *) ysmGlbAlloc(sz, "msgtbl");
      if (sysfpRead(fp, (dvoid *) tbl, sz) != sz)
	{
	  ysRecord(YSMSGC_ERR(18), YSLSEV_ERR, (char *) 0,
		   YSLSTR(ctx->fn), YSLEND);
	  goto error;
	}

      for (i = 0, bp = tbl; i < idmax - idmin + 1; i++, bp += 8)
	{
	  off = sysxGetB4(bp);
	  len = sysxGetB4(bp + 4);
	  if (!off || !len)
	    {
	      if (unused && !verbose)
		yslPrint("%d ", i + idmin);

	      if (verbose)
		yslPrint("%d, message not found\n", i + idmin);
	    }
	  else
	    {
	      sysb8ext(&off_8, off);
	      if (!sysfpSeek(fp, &off_8))
		{
		  ysRecord(YSMSGC_ERR(18), YSLSEV_ERR, (char *) 0,
			   YSLSTR(ctx->fn), YSLEND);
		  goto error;
		}
	      else
		{
		  tmp = (char *) ysmGlbAlloc((size_t) len, "tmp");
		  if (sysfpRead(fp, (dvoid *) tmp, (size_t) len) == len)
		    {
		      if (verbose)
			yslPrint("%d, \"%s\"\n", i + idmin, tmp);
		    }
		  else
		    {
		      ysRecord(YSMSGC_ERR(18), YSLSEV_ERR, (char *) 0,
			       YSLSTR(ctx->fn), YSLEND);
		      goto error;
		    }
		  ysmGlbFree((dvoid *) tmp);
		}
	    }
	}

    error:
      if (tbl)
	ysmGlbFree((dvoid *) tbl);
      sysfpClose(fp);
      if (unused && !verbose)
	yslPrint("\n");
    }

  return YSARG_NORMAL;
}


STATICF sword ysmsgcSymbols(ysmsgctx *ctx)
{
  sysfp      *fp, *fpo, *fph;
  char       *path, *hf, *mp;
  ysle       *le;
  sword       id, idx, sevidx;
  CONST char *errtxt;
  char        buf[512], tmpnm[SYSFP_MAX_PATHLEN], result[SYSFP_MAX_PATHLEN];

  hf = ysResGetLast("omn.message-compiler.header-file");
  mp = ysResGetLast("omn.message-compiler.macro-prefix");
  id = atol(ysResGetLast("omn.message-compiler.id-base"));
  
  fph = sysfpOpen(hf, "w", SYSFPKIND_TEXT, &errtxt);

  for (le = ysLstHead(ctx->fnlst); le; le = ysLstNext(le))
    {
      
      sysfpForm(ctx->fn, (char *) 0, (char *) ysLstVal(le), ctx->sfx);
      fp = ysmsgcOpen(ctx, (char *) ysLstVal(le), &path);
      if (!fp)
	continue;

      sysfpTemp(tmpnm, path, (char *) 0);
      fpo = sysfpOpen(tmpnm, "w", SYSFPKIND_TEXT, &errtxt);
      if (!fpo)
	{
	  sysfpClose(fp);
	  continue;
	}

      sysfpPrint(fph, "/* Generated from %s */\n\n", ctx->fn);

      
      while (sysfpGets(fp, buf, sizeof(buf)))
	{
	  if (!isalpha(buf[0]))
	    {
	      sysfpPrint(fpo, "%s", buf);
	      continue;
	    }

	  for (idx = 0; buf[idx] != ','; idx++) ;
	  buf[idx] = '\0';
	  sysfpPrint(fph, "#define %s%s (((ub4) %d) + (YSLSEV_", mp, buf, id);

	  while (buf[++idx] == ' ') ;
	  sevidx = idx;
	  while (buf[idx++] != ',') ;
	  buf[idx-1] = '\0';
	  sysfpPrint(fph, "%s << 24))\n", buf + sevidx);
	  sysfpPrint(fpo, "%d,%s", id, buf + idx);
	  id++;
	}

      sysfpClose(fp);
      sysfpClose(fpo);

      
      if (ysResGetLast("ysmsgc.output-name"))
	sysfpForm(result, (char *) 0, ysResGetLast("ysmsgc.output-name"),
		  "msg");
      else
	{
	  sysfpExtractBase(buf, ctx->fn);
	  sysfpForm(result, path, buf, "msg");
	}

      if (errtxt = sysfpRename(tmpnm, result))
	{
	  ysRecord(YSMSGC_ERR(7), YSLSEV_ERR, (char *) 0,
		   YSLSTR(result), YSLSTR(errtxt), YSLEND);
	  DISCARD sysfpRemove(tmpnm);
	}
      else
	ysRecord(YSMSGC_ERR(58), YSLSEV_INFO, (char *) 0,
		 YSLSTR(result), YSLEND);
    }

  return YSARG_NORMAL;
}


STATICF sysfp *ysmsgcOpen(ysmsgctx *ctx, char *fn, char **pathp)
{
  sysfp *fp;
  ysle  *le;
  char  *path;
  CONST char *errtxt;
  char  fpnm[SYSFP_MAX_PATHLEN];

  ysRecord(YSMSGC_ERR(55), YSLSEV_DEBUG(1), (char *) 0,
	   YSLSTR(ctx->fn), YSLEND);

  if (!ctx->paths)
    {
      path = (char *) 0;
      sysfpForm(fpnm, path, fn, (char *) 0);
    }
  else
    {
      for (le = ysLstHead(ctx->paths); le; le = ysLstNext(le))
	{
	  path = (char *) ysLstVal(le);
	  sysfpForm(fpnm, path, fn, ctx->sfx);
	  if (sysfpAccess(fpnm, "r"))
	    break;
	  else
	    ysRecord(YSMSGC_ERR(56), YSLSEV_DEBUG(1), (char *) 0,
		     YSLSTR(path), YSLEND);
	}
    }

  fp = sysfpOpen(fpnm, "r", (ctx->mode == YSMSGC_VERIFY ? SYSFPKIND_BINARY :
			     SYSFPKIND_TEXT), &errtxt);
  if (!fp)
    ysRecord(YSMSGC_ERR(4), YSLSEV_ERR, (char *) 0,
	     YSLSTR(ctx->fn), YSLSTR(errtxt), YSLEND);
  else
    ysRecord(YSMSGC_ERR(57), YSLSEV_DEBUG(1), (char *) 0,
	     YSLSTR(fpnm), YSLEND);

  *pathp = path;
  return fp;
}


STATICF ysmsgdesc *ysmsgcParse(ysmsgctx *ctx, char *buf,
			       ysspTree *tree, ub4 lcnt)
{
  ysstr     *txt;
  char      *scb;
  sb4        id;
  size_t     i;
  ysmsgdesc *msg;

  id = (sb4) strtol(buf, &scb, 10);

  
  if (ctx->style == YSMSGC_STYLE_OMN || ctx->style == YSMSGC_STYLE_LMS)
    {
      while (*scb && *scb == ' ') *scb++;
      if (*scb != ',')
	goto parse_error;
      else
	scb++;
    }

  if (ctx->style == YSMSGC_STYLE_LMS)
    {
      while (*scb && *scb == ' ') *scb++;
      DISCARD strtol(scb, &scb, 10);
      while (*scb && *scb == ' ') *scb++;
      if (*scb != ',')
	goto parse_error;
      else
	*scb++;
    }

  while (*scb && *scb == ' ') *scb++;
  if (ctx->style == YSMSGC_STYLE_OMN || ctx->style == YSMSGC_STYLE_LMS)
    {
      if (*scb != '"')
	goto parse_error;
      else
	scb++;
    }

  txt = ysStrCreate(scb);
  i = ysStrLen(txt);

  if (ctx->style == YSMSGC_STYLE_OMN || ctx->style == YSMSGC_STYLE_LMS)
    {
      while (txt[--i] != '"') ;
    }
  else
    i--;

  txt = ysStrDel(txt, i, (sword) (ysStrLen(txt) - i));

  
  if (ctx->mode == YSMSGC_COMPILE)
    {
      for (i = 0; i < ysStrLen(txt); i++)
	{
	  if ((ysStrToText(txt))[i] == '\\')
	    {
	      if (ysStrToText(txt)[i+1] == 'n')
		(ysStrToText(txt))[i+1] = '\n';
	      txt = ysStrDel(txt, i, 1);
	    }
	}
    }

  if (ysspLookup((dvoid *) &id, tree))
    {
      ysRecord(YSMSGC_ERR(10), YSLSEV_ERR, (char *) 0,
	       YSLSTR(ctx->fn), YSLSB4(id), YSLUB4(lcnt), YSLEND);
      ysStrDestroy(txt);
      return (ysmsgdesc *) 0;
    }
  else if (id < 1 || id > 0xffff)
    {
      ysRecord(YSMSGC_ERR(11), YSLSEV_ERR, (char *) 0,
	       YSLSTR(ctx->fn), YSLSB4(id), YSLUB4(lcnt), YSLEND);
      ysStrDestroy(txt);
      return (ysmsgdesc *) 0;
    }

  msg = (ysmsgdesc *) ysmGlbAlloc(sizeof(ysmsgdesc), "ysmsgdesc");
  msg->node.key_ysspNode = (dvoid *) &msg->id;
  msg->id = id;
  msg->txt = ysStrToText(txt);
  return msg;

 parse_error:
  ysRecord(YSMSGC_ERR(12), YSLSEV_ERR, (char *) 0,
	   YSLSTR(ctx->fn), YSLUB4(lcnt), YSLEND);
  return (ysmsgdesc *) 0;
}


STATICF sword ysmsgcMsgCmp(CONST dvoid *a, CONST dvoid *b)
{
  return *((sb4 *) a) - *((sb4 *) b);
}


STATICF void ysmsgcTreeFree(ysspTree *tree)
{
  ysmsgdesc *msg;

  while (msg = (ysmsgdesc *) (dvoid *) ysspDeq(&tree->root_ysspTree))
    {
      ysmGlbFree((dvoid *) msg->txt);
      ysmGlbFree((dvoid *) msg);
    }
}


STATICF boolean ysmsgcGetLine(char *buf, size_t buflen, sysfp *fp)
{
  boolean eof;
  sword   ch;

  eof = sysfpGetc(fp, &ch);
  while (!eof && buflen > 1)
    {
      *buf++ = (char) ch, buflen--;
      if (ch == '\n')
	break;
      eof = sysfpGetc(fp, &ch);
    }

  *buf = '\0';
  return !eof;
}
