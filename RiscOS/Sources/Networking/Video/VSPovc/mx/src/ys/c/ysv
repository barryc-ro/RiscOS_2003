/* mx/src/ys/ysv.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YSI_ORACLE
#include <ysi.h>
#endif


#define YSV_BASE    ((ub4) 8030)
#define YSV_ERR(n)  YS_PRODUCT, YS_FACILITY, (YSV_BASE + (ub4) (n))


externdef ysidDecl(YS_EX_INTERRUPT) = "ys::interrupt";
externdef ysidDecl(YS_EX_CANCELLED) = "ys::cancelled";
externdef ysidDecl(YS_EX_TIMEOUT)   = "ys::timeout";

static ysmtagDecl(YSEVT_TAG) = "ysevt";
static ysmtagDecl(YSQUE_TAG) = "ysque";
static ysmtagDecl(YSEVTARG_TAG) = "ysevt arg";

STATICF void  ysEvtNothing(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			   size_t argsz);
STATICF void  ysEvtInvoke(ysevt *evt, boolean asynch);
STATICF void  ysSvcNotifyCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
				size_t argsz);
STATICF void  ysTimerCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			    size_t argsz);
STATICF sword ysWait(sword nors, ysevt **orset, sword nands, ysevt **andset);
STATICF void ysWaitDflt(dvoid *usrp, ub4 delay);

#define YSVTMR_MIN     10000             
#define YSVDEL_MAX  75000000 


#define YSVFLG_KEEP       0x0100         
#define YSVFLG_INHANDLER  0x0200     


#define YSVST_NONE        1                                  
#define YSVST_ATTACHED    2                                      
#define YSVST_TRIGGERED   3                                     



struct ysevt
{
  CONST ysid *exid;                                          
  dvoid      *arg;                                     
  size_t      argsz;                                        

  sword       state;                                   
  ub4         flags;                                          

  ysHndlr     hndlr;                                   
  dvoid      *usrp;                                          
  ysque      *q;                                   
  ysle       *qle;                                  
  ysevt      *cancel;                                

  yscv       *cv;    
};


struct ysque
{
  yslst *utevts;                                       
  yslst *trevts;                                         
  dvoid *usrp;                                               
  yslst *ncds;                           
};


typedef struct ystmr ystmr;

struct ystmr
{
  ysevt *evt;                                            
  sysb8  abstm;                          
};


typedef struct ysncd ysncd;

struct ysncd
{
  ysque *q;                                    
  ysle  *le;                        
  ysevt *evt;                                               
};




void ysEvtInit(ysctx *ctx)
{
  ysMtxCreate(&ctx->inyield, YSMTXTYPE_NORMAL);
  ctx->idlers = ysLstCreate();
  ctx->mask = sysiNoMask;
  ctx->intrcnt = 0;
  ctx->usrintr = (ysid *) 0;
  ctx->waiter = (void (*)(dvoid *, ub4)) 0;
  ctx->waiterusrp = (dvoid *) 0;
  ctx->intrhndlr = (ysHndlr) 0;
  ctx->intrusrp = (dvoid *) 0;
  ctx->tmrs = ysLstCreate();
}


void ysEvtTerm(ysctx *ctx)
{
  ysevt *evt;
  ystmr *tmr;

  while (tmr = (ystmr *) ysLstDeq(ctx->tmrs))
    {
      ysTrigger(tmr->evt, YS_EX_SHUTDOWN, (dvoid *) 0, 0);
      ysmGlbFree((dvoid *) tmr);
    }

  while (evt = (ysevt *) ysLstDeq(ctx->idlers))
    {
      yseTry
	(*evt->hndlr)(evt->usrp, YS_EX_SHUTDOWN, (dvoid *) 0, 0);
      yseCatchAll
	ysRecord(YSV_ERR(3), YSLSEV_CRIT, (char *) 0, YSLSTR(yseExid), YSLEND);
      yseEnd

      ysmGlbFree((dvoid *) evt);
    }

  ysLstDestroy(ctx->idlers, (ysmff) 0);
  ysLstDestroy(ctx->tmrs, (ysmff) 0);
  ysMtxDestroy(&ctx->inyield);
}


ysevt *ysEvtCreate(ysHndlr hndlr, dvoid *usrp, ysque *q, boolean keep)
{
  ysevt *evt;

  if (q)
    ysmCheck((dvoid *) q, YSQUE_TAG);

  
  if (!hndlr && (q || !keep))
    yseThrow(YS_EX_BADPARAM);

  evt = (ysevt *) ysmGlbAlloc(sizeof(ysevt), YSEVT_TAG);
  evt->exid = (ysid *) 0;
  evt->arg = (dvoid *) 0;
  evt->argsz = 0;

  evt->state = YSVST_NONE;
  evt->flags = (keep ? YSVFLG_KEEP : 0);

  evt->hndlr = hndlr;
  evt->usrp = usrp;
  evt->q = q;
  evt->qle = (ysle *) 0;
  evt->cancel = (ysevt *) 0;

  evt->cv = (yscv *) 0;

  if (q)
    evt->qle = ysLstEnq(q->utevts, (dvoid *) evt);

  return evt;
}


ysevt *ysEvtDummy(void)
{
  return ysEvtCreate(ysEvtNothing, (dvoid *) 0, (ysque *) 0, FALSE);
}



STATICF void ysEvtNothing(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			  size_t argsz)
{
  return;
}


void ysEvtDestroy(ysevt *evt)
{
  yslst *lst;

  ysmCheck((dvoid *) evt, YSEVT_TAG);

  
  if (!(evt->flags & YSVFLG_KEEP) && evt->state > YSVST_NONE)
    yseThrow(YS_EX_BADPARAM);

  if (evt->flags & YSVFLG_INHANDLER)
  {
    evt->flags &= ~YSVFLG_KEEP;
    return;
  }

  
  if (evt->state == YSVST_ATTACHED)
    ysTrigger(evt->cancel, YS_EX_CANCELLED, (dvoid *) 0, 0);

  
  if (evt->q)
    {
      lst = (evt->state < YSVST_TRIGGERED ? evt->q->utevts : evt->q->trevts);
      DISCARD ysLstRem(lst, evt->qle);
    }

  
  if (evt->arg)
    {
      ysmCheck(evt->arg, YSEVTARG_TAG);
      ysmGlbFree(evt->arg);
    }

  ysmGlbFree((dvoid *) evt);
}


ysevt *ysEvtAttach(ysevt *evt, ysevt *cancelevt)
{
  ysmCheck((dvoid *) evt, YSEVT_TAG);
  ysmCheck((dvoid *) cancelevt, YSEVT_TAG);

  if (evt->state > YSVST_NONE)
    yseThrow(YS_EX_ALREADY);

  evt->state = YSVST_ATTACHED;
  evt->cancel = cancelevt;
  return evt;
}


void ysTrigger(ysevt *evt, CONST ysid *exid, dvoid *arg, size_t argsz)
{
  ysncd *ncd;
  ysque *que;

  ysmCheck((dvoid *) evt, YSEVT_TAG);

  
  if (evt->state == YSVST_TRIGGERED)
    yseThrow(YS_EX_BADPARAM);

  
  evt->state = YSVST_TRIGGERED;

  
  if (evt->cancel)
    ysEvtDestroy(evt->cancel);
  evt->cancel = (ysevt *) 0;

  
  evt->exid = exid;

  
  if (arg && argsz)
    {
      yseTry
	evt->arg = ysmGlbAlloc(argsz, YSEVTARG_TAG);
      evt->argsz = argsz;
      DISCARD memcpy(evt->arg, arg, argsz);
      yseCatch(YS_EX_OUTMEM)
	evt->exid = YS_EX_OUTMEM;
      yseEnd
    }

  if (evt->q)
    {
      
      que = evt->q;
      DISCARD ysLstRem(que->utevts, evt->qle);
      evt->qle = ysLstEnq(que->trevts, (dvoid *) evt);
      while (ncd = (ysncd *) ysLstDeq(que->ncds))
	{
	  ysTrigger(ncd->evt, (CONST ysid *) 0, (dvoid *) 0, (size_t) 0);
	  ysmGlbFree((dvoid *) ncd);
	}
    }
  else if (evt->hndlr)
    {
      
      ysEvtInvoke(evt, TRUE);
    }
  else
    {
      
      if (evt->cv)
	ysCondSignal(evt->cv);
    }
}


STATICF void ysEvtInvoke(ysevt *evt, boolean asynch)
{
  yseTry
    yseTry
      {
	evt->flags |= YSVFLG_INHANDLER;
	(*evt->hndlr)(evt->usrp, evt->exid, evt->arg, evt->argsz);
      }
    yseFinally
      {
	evt->flags &= ~YSVFLG_INHANDLER;
	evt->state = YSVST_NONE;
	evt->q = (ysque *) 0;

	
	if (!(evt->flags & YSVFLG_KEEP))
	  ysEvtDestroy(evt);
      }
    yseEnd
  yseCatchAll
    if (!asynch)
      yseRethrow;
    else
      ysRecord(YSV_ERR(2), YSLSEV_CRIT, (char *) 0, YSLSTR(yseExid), YSLEND);
  yseEnd
}


ysque *ysQueCreate(dvoid *usrp)
{
  ysque *q;

  q = (ysque *) ysmGlbAlloc(sizeof(ysque), YSQUE_TAG);
  q->utevts = ysLstCreate();
  q->trevts = ysLstCreate();
  ysLstMetricsOn(q->trevts);
  q->usrp = usrp;
  q->ncds = ysLstCreate();
  return q;
}


void ysQueDestroy(ysque *q)
{
  ysevt *evt;
  ysncd *ncd;

  ysmCheck((dvoid *) q, YSQUE_TAG);

  
  while (evt = (ysevt *) ysLstDeq(q->utevts))
    {
      if (evt->state == YSVST_ATTACHED)
	ysTrigger(evt->cancel, YS_EX_CANCELLED, (dvoid *) 0, 0);

      
      evt->state = YSVST_NONE;
      evt->q = (ysque *) 0;

      
      if (!(evt->flags & YSVFLG_KEEP))
	ysEvtDestroy(evt);
    }

  
  ysSvcAll(q);

  
  ysLstDestroy(q->utevts, (ysmff) 0);
  ysLstDestroy(q->trevts, (ysmff) 0);
  while (ncd = (ysncd *) ysLstDeq(q->ncds))
    {
      ysTrigger(ncd->evt, YS_EX_CANCELLED, (dvoid *) 0, (size_t) 0);
      ysmGlbFree((dvoid *) ncd);
    }
  ysLstDestroy(q->ncds, (ysmff) 0);
  ysmGlbFree((dvoid *) q);
}


dvoid *ysQueGetUsrp(ysque *q)
{
  ysmCheck((dvoid *) q, YSQUE_TAG);
  return q->usrp;
}


void ysQueGetMetrics(ysque *q, yslmtc *metrics)
{
  ysLstGetMetrics(q->trevts, metrics);
}


void ysQueGetCurTime(ysque *q, sysb8 *delta)
{
  if (ysLstHead(q->trevts))
    ysLstGetCurTime(q->trevts, ysLstHead(q->trevts), delta);
  else
    sysb8set(delta, sysb8zero);
}


void ysSvcAll(ysque *q)
{
  ysevt *evt;

  ysmCheck((dvoid *) q, YSQUE_TAG);

  while (evt = (ysevt *) ysLstDeq(q->trevts))
    ysEvtInvoke(evt, FALSE);
}


boolean ysSvcNext(ysque *q)
{
  ysevt *evt;

  ysmCheck((dvoid *) q, YSQUE_TAG);
  if (evt = (ysevt *) ysLstDeq(q->trevts))
    ysEvtInvoke(evt, FALSE);
  return (evt != (ysevt *) 0);
}


sword ysSvcPending(ysque *q)
{
  ysmCheck((dvoid *) q, YSQUE_TAG);
  return (sword) ysLstCount(q->trevts);
}


void ysSvcNotify(ysque *q, ysevt *evt)
{
  boolean sleep;
  ysncd  *ncd;

  ysmCheck((dvoid *) q, YSQUE_TAG);
  if (ysSvcPending(q))
    {
      if (evt)
	ysTrigger(evt, (ysid *) 0, (dvoid *) 0, (size_t) 0);
      return;
    }

  if (sleep = !evt)
    evt = ysSemCreate((dvoid *) 0);

  ncd = (ysncd *) ysmGlbAlloc(sizeof(ysncd), "ysncd");
  ncd->q = q;
  ncd->evt = evt;
  ncd->le = ysLstEnq(q->ncds, (dvoid *) ncd);
  DISCARD ysEvtAttach(evt, ysEvtSimple(ysSvcNotifyCancel, (dvoid *) ncd));

  if (sleep)
    {
      yseTry
	ysSemWait(evt);
      yseFinally
	ysSemDestroy(evt);
      yseEnd
    }
}



STATICF void ysSvcNotifyCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			       size_t argsz)
{
  ysncd *ncd;

  ncd = (ysncd *) usrp;
  DISCARD ysLstRem(ncd->q->ncds, ncd->le);
  ysmGlbFree((dvoid *) ncd);
}


void ysSvcLoop(ysque *q, ysevt *evt)
{
  ysevt *sems[2];

  ysmCheck((dvoid *) q, YSQUE_TAG);

  sems[1] = evt;
  while (!ysSemTest(evt))
    {
      ysSvcNext(q);
      sems[0] = ysSemCreate((dvoid *) 0);
      ysSvcNotify(q, sems[0]);
      yseTry
	DISCARD ysSemOrW(YSTM_INFINITE, 2, sems);
      yseFinally
	ysSemDestroy(sems[0]);
      yseEnd
    }
}


sword ysSvcSelect(CONST sysb8 *timeout, sword nque, ysque **q)
{
  ysevt **sems;
  sword   i, cnt;

  sems = (ysevt **) ysmGlbAlloc(sizeof(ysevt *) * nque, "ysSvcSelect");
  for (i = 0; i < nque; i++)
    {
      sems[i] = ysSemCreate((dvoid *) 0);
      ysSvcNotify(q[i], sems[i]);
    }

  yseTry
    cnt = ysSemOrW(timeout, nque, sems);
  yseFinally
    for (i = 0; i < nque; i++)
      ysSemDestroy(sems[i]);
    ysmGlbFree((dvoid *) sems);
  yseEnd

  return cnt;
}


boolean ysSemTest(ysevt *sem)
{
  ysmCheck((dvoid *) sem, YSEVT_TAG);
  if (!(sem->flags & YSVFLG_KEEP))
    yseThrow(YS_EX_BADPARAM);

  return (sem->state == YSVST_TRIGGERED);
}


void ysSemWait(ysevt *sem)
{
  DISCARD ysWait(1, &sem, 0, (ysevt **) 0);
}


sword ysSemOrW(CONST sysb8 *timeout, sword nsem, ysevt **sems)
{
  sword  i, cnt;
  ysevt *tsem;

  ysYield();

  for (i = cnt = 0; i < nsem; i++)
    if (ysSemTest(sems[i]))
      cnt++;

  if (cnt || !nsem || (timeout && sysb8cmp(timeout, ==, YSTM_POLLING)))
    return cnt;

  if (timeout)
    {
      tsem = ysSemCreate((dvoid *) 0);
      yseTry
	{
	  ysTimer(timeout, tsem);
	  cnt = ysWait(nsem, sems, 1, &tsem);
	  if (ysSemTest(tsem))
	    yseThrow(YS_EX_TIMEOUT);
	}
      yseFinally
	ysSemDestroy(tsem);
      yseEnd
    }
  else
    cnt = ysWait(nsem, sems, 0, (ysevt **) 0);

  return cnt;
}


sword ysSemAndW(CONST sysb8 *timeout, sword nsem, ysevt **sems)
{
  sword  i, cnt;
  ysevt *tsem;

  ysYield();

  for (i = cnt = 0; i < nsem; i++)
    if (ysSemTest(sems[i]))
      cnt++;

  if (cnt == nsem || !nsem || (timeout && sysb8cmp(timeout, ==, YSTM_POLLING)))
    return cnt;

  if (timeout)
    {
      tsem = ysSemCreate((dvoid *) 0);
      yseTry
	{
	  ysTimer(timeout, tsem);
	  cnt = ysWait(1, &tsem, nsem, sems);
	  if (ysSemTest(tsem))
	    yseThrow(YS_EX_TIMEOUT);
	}
      yseFinally
	ysSemDestroy(tsem);
      yseEnd
    }
  else
    cnt = ysWait(0, (ysevt **) 0, nsem, sems);

  return cnt;
}


void ysSemSynch(ysevt *sem, dvoid *arg)
{
  yseTry
    {
      DISCARD ysWait(1, &sem, 0, (ysevt **) 0);
      if (sem->exid)
	yseThrower(sem->exid, sem->arg, sem->argsz, __FILE__, __LINE__);
      else if (sem->arg && arg)
	DISCARD memcpy(arg, sem->arg, sem->argsz);
    }
  yseFinally
    ysSemDestroy(sem);
  yseEnd
}


dvoid *ysSemUsrp(ysevt *sem)
{
  ysmCheck((dvoid *) sem, YSEVT_TAG);
  return sem->usrp;
}


CONST ysid *ysSemExid(ysevt *sem)
{
  ysmCheck((dvoid *) sem, YSEVT_TAG);
  return sem->exid;
}


dvoid *ysSemArg(ysevt *sem)
{
  ysmCheck((dvoid *) sem, YSEVT_TAG);
  return sem->arg;
}


void ysSetTimer(boolean reltime, CONST sysb8 *time, ysevt *evt)
{
  ystmr *tmr, *sct;
  ysctx *ctx;
  sysb8  ticks, abstime;
  ysle  *le;
  boolean sleep;

  ctx = (ysctx *) yscGet(YSC_YSCTX);

  if (sleep = !evt)
    evt = ysSemCreate((dvoid *) 0);

  ysClock(&ticks);
  if (reltime)
#ifdef RISCOS
    sysb8add((ysb8 *)&abstime, (ysb8 *)&ticks, (ysb8 *)time);
#else
    sysb8add(&abstime, &ticks, time);
#endif
  else
    sysb8set(&abstime, time);

  if (sysb8cmp(&ticks, >=, &abstime))
    ysTrigger(evt, (ysid *) 0, (dvoid *) 0, 0);
  else
    {
      
      tmr = (ystmr *) ysmGlbAlloc(sizeof(ystmr), "timer");
      tmr->evt = evt;
      sysb8set(&tmr->abstm, &abstime);

      
      for(le = ysLstHead(ctx->tmrs); le; le = ysLstNext(le))
      {
        sct = (ystmr *) ysLstVal(le);
        if (sysb8cmp(&sct->abstm, >=, &tmr->abstm))
          break;
      }
      le = ysLstIns(ctx->tmrs, le ? ysLstPrev(le) : ysLstTail(ctx->tmrs),
                    (dvoid *) tmr);

      DISCARD ysEvtAttach(evt, ysEvtSimple(ysTimerCancel, (dvoid *) le));
    }

  
  if (sleep)
    {
      yseTry
	ysSemWait(evt);
      yseFinally
	ysSemDestroy(evt);
      yseEnd
    }
}



STATICF void ysTimerCancel(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			   size_t argsz)
{
  ysctx *ctx;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  ysmGlbFree(ysLstRem(ctx->tmrs, (ysle *) usrp));
}


STATICF sword ysWait(sword nors, ysevt **orset, sword nands, ysevt **andset)
{
  ysevt **scs;
  yscv    localcv;
  ysmtx   waitmtx;
  sword   i, orcnt, andcnt;

  
  for (i = 0, scs = orset; i < nors; i++, scs++)
    {
      ysmCheck((dvoid *) *scs, YSEVT_TAG);
      if (!((*scs)->flags & YSVFLG_KEEP))
	yseThrow(YS_EX_BADPARAM);
      else
	(*scs)->cv = &localcv;
    }

  for (i = 0, scs = andset; i < nands; i++, scs++)
    {
      ysmCheck((dvoid *) *scs, YSEVT_TAG);
      if (!((*scs)->flags & YSVFLG_KEEP))
	yseThrow(YS_EX_BADPARAM);
      else
	(*scs)->cv = &localcv;
    }

  
  ysCondCreate(&localcv);
  ysMtxCreate(&waitmtx, YSMTXTYPE_NORMAL);
  ysMtxLock(&waitmtx);

  
  orcnt = andcnt = 0;
  yseTry
    {
      do
	{
	  
	  for (i = orcnt = 0, scs = orset; i < nors; i++, scs++)
	    if ((*scs)->state == YSVST_TRIGGERED)
	      orcnt++;

	  for (i = andcnt = 0, scs = andset; i < nands; i++, scs++)
	    if ((*scs)->state == YSVST_TRIGGERED)
	      andcnt++;

	  
	  if (!orcnt && (!andcnt || andcnt != nands))
	    ysCondWait(&localcv, &waitmtx);
	}
      while (!orcnt && (!andcnt || andcnt != nands));
    }
  yseFinally
    {
      ysMtxUnlock(&waitmtx);
      ysMtxDestroy(&waitmtx);
      ysCondDestroy(&localcv);

      
      for (i = 0, scs = orset; i < nors; i++, scs++)
	(*scs)->cv = (yscv *) 0;
      for (i = 0, scs = andset; i < nands; i++, scs++)
	(*scs)->cv = (yscv *) 0;
    }
  yseEnd

  return orcnt + andcnt;
}


void ysBlock(void)
{
  ysctx *ctx;
  ystmr *tmr;
  ub4    rawdelayus;
  sysb8  befticks, delay;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  ysClock(&befticks);
  tmr = (ystmr *) ysLstVal(ysLstHead(ctx->tmrs));
  sysb8sub(&delay, &tmr->abstm, &befticks);

  if (sysb8cmp(&delay, >, sysb8zero))
    {
      rawdelayus = (ub4) sysb8msk(&delay);
      ysRecord(YSV_ERR(1), YSLSEV_DEBUG(7), (char *) 0,
	       YSLUB4(rawdelayus), YSLEND);
      if (!ctx->waiter)
	sysiPause(ctx->osdp, ctx->mask, rawdelayus);
      else
	(*ctx->waiter)(ctx->waiterusrp, rawdelayus);
    }
}


void ysSetWaiter(ysWaiterCB wtr, dvoid *usrp,
		 ysWaiterCB *oldwtr, dvoid **oldusrp)
{
  ysctx *ctx;

  ctx = (ysctx *) yscGet(YSC_YSCTX);

  if (oldwtr && oldusrp)
    {
      if (ctx->waiter)
	{
	  *oldwtr = ctx->waiter;
	  *oldusrp = ctx->waiterusrp;
	}
      else
	{
	  *oldwtr = ysWaitDflt;
	  *oldusrp = (dvoid *) ctx;
	}
    }

  if (wtr == ysWaitDflt)
    {
      ctx->waiter = (ysWaiterCB) 0;
      ctx->waiterusrp = (dvoid *) 0;
    }
  else
    {
      ctx->waiter = wtr;
      ctx->waiterusrp = usrp;
    }
}


STATICF void ysWaitDflt(dvoid *usrp, ub4 delay)
{
  ysctx *ctx = (ysctx *) usrp;
  sysiPause(ctx->osdp, ctx->mask, delay);
}


void ysYield(void)
{
  ysctx *ctx;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  if (ctx->usrintr)
    ysIntrHandle(ctx);

  if (ctx->tctx)
    ysThrYield();
  else
    DISCARD ysIdle();
}


boolean ysIdle(void)
{
  ysctx  *ctx;
  ysevt  *evt;
  ystmr  *tmr;
  ysle   *le;
  boolean anyactive, active, reentry;
  sysb8   min, ticks;

  ctx = (ysctx *) yscGet(YSC_YSCTX);

  reentry = !ysMtxTryLock(&ctx->inyield);

  ysClock(&ticks);
  anyactive = FALSE;

  
  sysb8ext(&min, YSVTMR_MIN);
  sysb8add(&ticks, &ticks, &min);
  while (le = ysLstHead(ctx->tmrs))
    {
      tmr = (ystmr *) ysLstVal(le);
      if (sysb8cmp(&tmr->abstm, >, &ticks))
	break;

      anyactive = TRUE;
      DISCARD ysLstRem(ctx->tmrs, le);
      ysTrigger(tmr->evt, YS_EX_TIMEOUT, (dvoid *) 0, 0);
      ysmGlbFree((dvoid *) tmr);
    }

  
  for (le = ysLstHead(ctx->idlers); le; le = ysLstNext(le))
    {
      evt = (ysevt *) ysLstVal(le);
      yseTry
	{
	  active = FALSE;
	  (*evt->hndlr)(evt->usrp, (ysid *) 0,
			(dvoid *) &active, sizeof(active));
	  anyactive |= active;
	}
      yseCatchAll
	ysRecord(YSV_ERR(3), YSLSEV_CRIT, (char *) 0, YSLSTR(yseExid), YSLEND);
      yseEnd
    }

  if (!reentry)
    ysMtxUnlock(&ctx->inyield);
  return anyactive;
}


void ysSetIdler(CONST char *nm, ysHndlr hndlr, dvoid *usrp)
{
  ysevt *scv;
  ysctx *ctx;
  ysle  *le;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  ysMtxLock(&ctx->inyield);

  
  for (le = ysLstHead(ctx->idlers); le; le = ysLstNext(le))
    {
      scv = (ysevt *) ysLstVal(le);
      if (!strcmp((char *) scv->arg, nm))
	break;
    }

  if (le)
    {
      
      if (hndlr)
	scv->hndlr = hndlr, scv->usrp = usrp;
      else
	{
	  DISCARD ysLstRem(ctx->idlers, le);
	  ysmGlbFree((dvoid *) scv);
	}
    }
  else if (hndlr)
    {
      
      scv = (ysevt *) ysmGlbAlloc(sizeof(ysevt), "idler");
      scv->hndlr = hndlr;
      scv->usrp = usrp;
      scv->arg = (dvoid *) nm;
      DISCARD ysLstEnq(ctx->idlers, (dvoid *) scv);
    }

  ysMtxUnlock(&ctx->inyield);
}


void ysIntr(CONST ysid *intrid)
{
  ysctx *ctx;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  ctx->usrintr = intrid;
}


ysHndlr ysSetIntr(ysHndlr hndlr, dvoid *usrp)
{
  ysctx  *ctx;
  ysHndlr oldhndlr;

  ctx = (ysctx *) yscGet(YSC_YSCTX);
  oldhndlr = ctx->intrhndlr;
  ctx->intrhndlr = hndlr;
  ctx->intrusrp = usrp;
  return oldhndlr;
}


void ysIntrHandle(ysctx *ctx)
{
  CONST ysid *intrid;

  intrid = ctx->usrintr;
  ctx->usrintr = (ysid *) 0;
  if (ctx->intrhndlr)
    ctx->intrhndlr(ctx->intrusrp, intrid, (dvoid *) 0, 0);
  else
    yseThrow(intrid);
}


void ysEnterCR(void)
{
  ysctx *ctx = (ysctx *) yscGet(YSC_YSCTX);

  if (!ctx->intrcnt++)
    ctx->mask = sysiDisable(ctx->osdp);
}


void ysExitCR(void)
{
  ysctx *ctx = (ysctx *) yscGet(YSC_YSCTX);

  if (!--ctx->intrcnt)
    sysiEnable(ctx->osdp, ctx->mask);
}
