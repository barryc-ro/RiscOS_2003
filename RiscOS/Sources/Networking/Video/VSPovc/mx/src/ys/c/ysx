/* mx/src/ys/ysx.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YSM_ORACLE
#include <ysm.h>
#endif
#ifndef YSX_ORACLE
#include <ysx.h>
#endif


struct ysx
{
  boolean enc;                                         
  ysbv   *bv;                                               
  sword   nbv;                                
  ub1    *ptr;                         
  size_t  cnt;               
  sword   idx;                               
  ysmhp  *hp;                                      
  ysxcb   cb;                        
  dvoid  *usrp;                                 
};


#define YSXBLKSZ  1024

externdef ysidDecl(YS_EX_ENDOFDATA) = "ys::endofdata";
externdef ysidDecl(YS_EX_ENCODEERROR) = "ys::encodeerror";
static    ysmtagDecl(YSX_TAG) = "ysx";
static    ysmtagDecl(YSXBV_TAG) = "ysx bv";

STATICF void ysxAddBuf(ysx *x);


ysx *ysxDecode( sword byteorder, ysbv *bv, sword nbv)
{
  ysx *x;

  x = (ysx *) ysmGlbAlloc(sizeof(ysx), YSX_TAG);
  x->enc = FALSE;
  x->bv = bv;
  x->nbv = nbv;
  x->idx = 0;
  if (nbv)
    x->ptr = bv->buf, x->cnt = bv->len;
  else
    x->ptr = (ub1 *) 0, x->cnt = 0;
  x->hp = (ysmhp *) 0;
  x->cb = (ysxcb) 0;
  x->usrp = (dvoid *) 0;

  return x;
}


ysx *ysxDecodeFromStream(ysxcb getbufcb, ysbv *bv, dvoid *usrp)
{
  ysx *x;

  x = (ysx *) ysmGlbAlloc(sizeof(ysx), YSX_TAG);
  x->enc = FALSE;
  x->bv = bv;
  x->nbv = 1;
  x->idx = 0;
  x->ptr = (ub1 *) 0;
  x->cnt = 0;
  x->hp = (ysmhp *) 0;
  x->cb = getbufcb;
  x->usrp = usrp;

  return x;
}


void ysxDecEnd(ysx *x)
{
  ysmGlbFree((dvoid *) x);
}


void ysxGetPos(ysx *x, sword *idx, size_t *off)
{
  *idx = x->idx;
  *off = x->bv[x->idx].len - x->cnt;
}


ub1 ysxGetUB1(ysx *x)
{
  ub1 val;

  while (x->cnt < 1 && x->idx < x->nbv)
    ysxSkip(x, x->cnt);

  if (x->idx >= x->nbv)
    yseThrow(YS_EX_ENDOFDATA);

  val = *x->ptr;
  x->cnt--, x->ptr++;
  return val;
}


ub2 ysxGetUB2(ysx *x)
{
  ub2 val;

  ysxAlign(x, 2);
  while (x->cnt < 2 && x->idx < x->nbv)
    ysxSkip(x, x->cnt);

  if (x->idx >= x->nbv)
    yseThrow(YS_EX_ENDOFDATA);

  val = sysxGetB2(x->ptr);
  x->cnt -= 2, x->ptr += 2;
  return val;
}


ub4 ysxGetUB4(ysx *x)
{
  ub4 val;

  ysxAlign(x, 4);
  while (x->cnt < 4 && x->idx < x->nbv)
    ysxSkip(x, x->cnt);

  if (x->idx >= x->nbv)
    yseThrow(YS_EX_ENDOFDATA);

  val = sysxGetB4(x->ptr);
  x->cnt -= 4, x->ptr += 4;
  return val;
}


void ysxGetSB8(ysx *x, sysb8 *val)
{
  ysxAlign(x, 8);
  while (x->cnt < 8 && x->idx < x->nbv)
    ysxSkip(x, x->cnt);

  if (x->idx >= x->nbv)
    yseThrow(YS_EX_ENDOFDATA);

  sysb8mak(val, (sb4) sysxGetB4(x->ptr), sysxGetB4(x->ptr + 4));
  x->cnt -= 8, x->ptr += 8;
}


void ysxSkip(ysx *x, size_t len)
{
  size_t amt;
  boolean ok;

  do
    {
      amt = min(len, x->cnt);
      x->cnt -= amt, x->ptr += amt, len -= amt;
      if (!x->cnt)
	{
	  if (!x->cb)
	    {
	      x->idx++;
	      if (x->idx < x->nbv)
		{
		  x->ptr = x->bv[x->idx].buf;
		  x->cnt = x->bv[x->idx].len;
		}
	      else if (len)
		yseThrow(YS_EX_ENDOFDATA);
	    }
	  else
	    {
	      if (x->idx < x->nbv)
		ok = (*x->cb)(x->bv, x->usrp);
	      else
		ok = FALSE;

	      if (ok)
		{
		  x->ptr = x->bv->buf;
		  x->cnt = x->bv->len;
		}
	      else if (len)
		yseThrow(YS_EX_ENDOFDATA);
	      else
		x->idx++;
	    }
	}
    }
  while (len);
}


ysx *ysxEncode( size_t len, ysmhp *hp)
{
  ysx *x;

  x = (ysx *) ysmAlloc(hp, sizeof(ysx), YSX_TAG);
  x->enc = TRUE;
  x->bv = (ysbv *) ysmAlloc(hp, sizeof(ysbv), YSXBV_TAG);
  x->nbv = 1;
  x->cnt = x->bv->len = YSXBLKSZ;
  x->ptr = x->bv->buf = (ub1 *) ysmAlloc(hp, YSXBLKSZ, "ysx buf");
  x->idx = 0;
  x->hp = hp;
  x->cb = (ysxcb) 0;
  x->usrp = (dvoid *) 0;
  
  return x;
}


ysx *ysxEncodeToStream(ysxcb putbufcb, ysbv *bv, dvoid *usrp)
{
  ysx *x;

  x = (ysx *) ysmGlbAlloc(sizeof(ysx), YSX_TAG);
  x->enc = TRUE;
  x->bv = bv;
  x->nbv = 1;
  x->cnt = x->bv->len;
  x->ptr = x->bv->buf;
  x->idx = 0;
  x->hp = (ysmhp *) 0;
  x->cb = putbufcb;
  x->usrp = usrp;

  return x;
}


void ysxEncEnd(ysx *x, ysbv **bv, sword *nbv)
{
  boolean ok;

  ok = TRUE;
  if (!x->cb)
    {
      x->bv[x->idx].len = YSXBLKSZ - x->cnt;
      *bv = x->bv;
      *nbv = x->nbv;

      ysmFree(x->hp, (dvoid *) x);
    }
  else
    {
      if (x->cnt != x->bv->len)
	{
	  x->bv->len -= x->cnt;
	  ok = (*x->cb)(x->bv, x->usrp);
	}

      ysmGlbFree((dvoid *) x);
    }

  if (!ok)
    yseThrow(YS_EX_ENCODEERROR);
}


void ysxPutUB1(ysx *x, ub1 val)
{
  if (x->cnt < 1)
    ysxAddBuf(x);

  *x->ptr = val;
  x->ptr++, x->cnt--;
}


void ysxPutUB2(ysx *x, ub2 val)
{
  ysxAlign(x, 2);
  if (x->cnt < 2)
    ysxAddBuf(x);

  sysxPutB2(x->ptr, val);
  x->ptr += 2, x->cnt -= 2;
}


void ysxPutUB4(ysx *x, ub4 val)
{
  ysxAlign(x, 4);
  if (x->cnt < 4)
    ysxAddBuf(x);

  sysxPutB4(x->ptr, val);
  x->ptr += 4, x->cnt -= 4;
}


void ysxPutSB8(ysx *x, sysb8 *val)
{
  sysb8 tmp;

  ysxAlign(x, 8);
  if (x->cnt < 8)
    ysxAddBuf(x);

  sysb8srl(&tmp, val, 32);
  sysxPutB4(x->ptr, (ub4) sysb8msk(&tmp));
  sysxPutB4(x->ptr+4, (ub4) sysb8msk(val));
  x->ptr += 8, x->cnt -= 8;
}


void ysxCopy(ysx *x, ub1 *buf, size_t len)
{
  size_t amt;

  while (len)
    {
      amt = min(len, x->cnt);
      if (x->enc)
	DISCARD memcpy(x->ptr, buf, amt);
      else
	DISCARD memcpy(buf, x->ptr, amt);

      x->cnt -= amt, x->ptr += amt, len -= amt, buf += amt;

      if (!x->cnt && len)
	{
	  if (x->enc)
	    ysxAddBuf(x);
	  else
	    {
	      ysxSkip(x, 0);
	      if (x->idx >= x->nbv && len)
		yseThrow(YS_EX_ENDOFDATA);
	    }
	}
    }
}


void ysxAlign(ysx *x, sword boundary)
{
  size_t diff, off;

  if (x->enc)
    {
      
      for (diff = x->cnt - ysTruncVal(x->cnt, boundary);
	   diff; diff--, x->ptr++, x->cnt--)
	*x->ptr = '\0';
    }
  else if (x->cnt)
    {
      off = x->bv[x->idx].len - x->cnt;
      diff = ysRoundVal(off, boundary) - off;
      x->ptr += diff, x->cnt -= diff;
    }
}


STATICF void ysxAddBuf(ysx *x)
{
  boolean ok;

  
  while (x->cnt--)
    *(x->ptr++) = '\0';

  
  if (!x->cb)
    {
      x->nbv++;
      x->bv = (ysbv *) ysmRealloc(x->hp, (dvoid *) x->bv,
				  sizeof(ysbv) * x->nbv);
      x->idx++;
      x->cnt = x->bv[x->idx].len = YSXBLKSZ;
      x->ptr = x->bv[x->idx].buf =
	(ub1 *) ysmAlloc(x->hp, YSXBLKSZ, "ysx buf");
    }
  else
    {
      ok = (*x->cb)(x->bv, x->usrp);
      x->cnt = x->bv->len;
      if (ok)
	x->ptr = x->bv->buf;
      else
	yseThrow(YS_EX_ENCODEERROR);
    }
}
