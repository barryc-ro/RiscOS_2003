/* mx/src/ys/ysb8.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YSB8_ORACLE
#include <ysb8.h>
#endif
#ifndef YSE_ORACLE
#include <yse.h>
#endif

#ifdef RISCOS
/*RCM altered this to get around static initialisation problems*/
static    CONST ysb8 ysb8minval  = { (sb4) 0x7fffffff - 1, 0x0 };
externdef CONST ysb8 *CONST_W_PTR ysb8zero;	/* initialisation moved to ModuleHeader */
#else
static    CONST ysb8 ysb8zeroval = { 0, 0 };
static    CONST ysb8 ysb8minval  = { (sb4) 0x7fffffff - 1, 0x0 };
externdef CONST ysb8 *CONST_W_PTR ysb8zero = &ysb8zeroval;
#endif

void ysb8add(ysb8 *out, ysb8 *u, ysb8 *v)
{
  ub4 tmp;

  tmp = u->lo;
  out->lo = u->lo + v->lo;
  out->hi = u->hi + v->hi + (out->lo < tmp);
}


void ysb8sub(ysb8 *out, ysb8 *u, ysb8 *v)
{
  ub4 tmp1, tmp2;

  tmp1 = u->lo, tmp2 = v->lo;
  out->lo = u->lo - v->lo;
  out->hi = u->hi - v->hi - (tmp2 > tmp1);
}


void ysb8mul(ysb8 *out, ysb8 *u, ysb8 *v)
{
  ub4 a, b, c, d, tmp1, tmp2;

  a = u->lo >> 16;
  b = u->lo & 0xffff;
  c = v->lo >> 16;
  d = v->lo & 0xffff;
  tmp1 = u->lo, tmp2 = v->lo;

  out->lo = u->lo * v->lo;
  out->hi = (sb4) (tmp1 * v->hi + u->hi * tmp2 +
		   a*c + ((b*c + a*d + ((b*d) >> 16)) >> 16));
}


externdef ysidDecl(YS_EX_DIVBYZERO) = "ys::divbyzero";
STATICF sword ysb8hibit(ysb8 *val);

void ysb8div(ysb8 *out, ysb8 *u, ysb8 *v)
{
  ysb8 num, den, tmp;
  sb4   qd;
  sword ns, ds, neg, bitpos;

  
  if (ysb8cmp(v, ==, ysb8zero))
    yseThrow(YS_EX_DIVBYZERO);

  
  if (u->hi < 0)
    {
      ysb8neg(&num, u);
      neg = -1;
    }
  else
    {
      ysb8set(&num, u);
      neg = 1;
    }

  if (v->hi < 0)
    {
      ysb8neg(&den, v);
      neg = -neg;
    }
  else
    ysb8set(&den, v);

  
  if (!u->hi && !v->hi)
    {
      out->hi = 0;
      out->lo = u->lo / v->lo;
      goto wrapup;
    }

  
  if (den.hi & 0x40000000)
    {
      if (ysb8cmp(&num, >=, &den))
	ysb8ext(out, 1);
      else
	ysb8set(out, ysb8zero);
      goto wrapup;
    }

  
  ysb8set(out, ysb8zero);                         
  ns = 0;           
  ds = ysb8hibit(&den);                     
  ysb8srl(&den, &den, 1);      
  ds--;

  
  while (!ysb8cmp(&num, ==, ysb8zero) && ds >= ns)
    {
      
      ns += ysb8hibit(&num);

      
      qd = num.hi / den.hi;

      
      ysb8mulb4(&tmp, &den, qd);
      if (ysb8cmp(&tmp, >, &num))
	{
	  qd--;
	  ysb8mulb4(&tmp, &den, qd);
	}

      ysb8sub(&num, &num, &tmp);

      
      bitpos = ds - ns;
      tmp.hi = 0, tmp.lo = (ub4) qd;
      if (bitpos >= 0)
	{
	  ysb8sll(&tmp, &tmp, bitpos);
	  out->hi |= tmp.hi, out->lo |= tmp.lo;
	}
      else
	{
	  qd >>= (-bitpos);
	  out->lo |= qd;
	}
    }

 wrapup:
  if (neg == -1)
    ysb8neg(out, out);
}


void ysb8rem(ysb8 *out, ysb8 *u, ysb8 *v)
{
  ysb8 tmp;
  ysb8edv(u, v, &tmp, out);
}


void ysb8neg(ysb8 *out, ysb8 *v)
{
  ub4 tmp;
  tmp = v->lo;

  out->lo = (ub4) -((sb4) v->lo);
  out->hi = - v->hi - (tmp > 0);
}


void ysb8srl(ysb8 *out, ysb8 *u, sword bits)
{
  if (bits > 31)
    {
      out->lo = ((ub4) u->hi) >> (bits - 32);
      out->hi = 0;
    }
  else
    {
      out->lo = u->lo >> bits;
      out->lo |= ((u->hi & ((1 << bits) - 1)) << (32 - bits));
      out->hi = (sb4) (((ub4) u->hi) >> bits);
    }
}


void ysb8sll(ysb8 *out, ysb8 *u, sword bits)
{
  if (bits >= 32)
    out->hi = (sb4) u->lo, out->lo = 0, bits -= 32;
  else
    ysb8set(out, u);

  if (bits)
    {
      out->hi = (sb4) ((out->hi << bits) | (out->lo >> (32 - bits)));
      out->lo = (out->lo << bits);
    }
}


void ysb8edv(ysb8 *u, ysb8 *v, ysb8 *q, ysb8 *r)
{
  ysb8 tmp, tmp2;

  ysb8div(&tmp, u, v);
  ysb8mul(&tmp2, &tmp, v);
  ysb8sub(r, u, &tmp2);
  ysb8set(q, &tmp);
}


void ysb8addb4(ysb8 *out, ysb8 *u, sb4 v)
{
  ysb8 tmp;
  ysb8ext(&tmp, v);
  ysb8add(out, u, &tmp);
}


void ysb8mulb4(ysb8 *out, ysb8 *u, sb4 v)
{
  ysb8 tmp;
  ysb8ext(&tmp, v);
  ysb8mul(out, u, &tmp);
}


void ysb8fromdbl(ysb8 *out, double g)
{
  double t;

  t = g / ((ub4) 0xffffffff);
  out->hi = (sb4) t;
  out->lo = (ub4) (g - (g * ((sb4) t)));
}


STATICF void ysb8dfmt(char *buf, ysb8 *orig);
STATICF void ysb8xfmt(char *buf, ysb8 *orig);

char *ysb8fmt(char *buf, CONST char *fmt, ysb8 *val)
{
  if (!strcmp(fmt, "%Ld"))
    ysb8dfmt(buf, val);
  else if (!strcmp(fmt, "%Lx"))
    ysb8xfmt(buf, val);
  else
    DISCARD strcpy(buf, fmt);

  return buf;
}


boolean ysb8fromstr(ysb8 *out, CONST char *str)
{
  boolean neg;
  sword   base, d;

  neg = FALSE;
  ysb8set(out, ysb8zero);

  if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))
    {
      base = 16;
      str += 2;
    }
  else
    {
      base = 10;
      if (*str == '-')
	{
	  neg = TRUE;
	  str++;
	}
    }
  
  while (*str)
    {
      switch (*str)
	{
	case '0': d = 0; break;  case '1': d = 1;  break;
	case '2': d = 2; break;
	case '3': d = 3; break;  case '4': d = 4;  break;
	case '5': d = 5; break;
	case '6': d = 6; break;  case '7': d = 7;  break;
	case '8': d = 8; break;
	case '9': d = 9; break;  case 'a': d = 10; break;
	case 'b': d = 11; break;
	case 'c': d = 12; break; case 'd': d = 13; break;
	case 'e': d = 14; break; case 'f': d = 15; break;
	default:  d = 17; break;
	}

      if (d >= base)
	return FALSE;

      ysb8mulb4(out, out, (sb4) base);
      ysb8addb4(out, out, (sb4) d);
      str++;
    }

  if (neg)
    ysb8neg(out, out);
  
  return TRUE; 
}


STATICF sword ysb8hibit(ysb8 *v)
{
  sword cnt;

  if (v->hi)
    {
      cnt = 0;
      while (!(v->hi & 0x40000000))
	v->hi <<= 1, cnt++;

      
      if (cnt)
	{
	  v->hi |= (v->lo >> (32 - cnt));
	  v->lo = (v->lo << cnt);
	}
    }
  else if (v->lo)
    {
      v->hi = (sb4) v->lo, v->lo = 0, cnt = 32;
      while (!(v->hi & 0x40000000))
	v->hi <<= 1, cnt++;
    }
  else
    cnt = 0;

  return cnt;
}


STATICF void ysb8dfmt(char *buf, ysb8 *orig)
{
  ysb8    val, ten, rem;
  sword   len;
  boolean neg;
  char    tmp[24];

  ysb8set(&val, orig);
  ysb8ext(&ten, 10);

  if (ysb8cmp(&val, ==, ysb8zero))
    DISCARD strcpy(buf, "0");
  else if (ysb8cmp(&val, ==, &ysb8minval))
    DISCARD strcpy(buf, "-9223372036854775808");
  else
    {
      if (neg = ysb8cmp(&val, <, ysb8zero))
	ysb8neg(&val, &val);

      len = 24;
      tmp[--len] = '\0';

      while (ysb8cmp(&val, !=, ysb8zero))
	{
	  ysb8edv(&val, &ten, &val, &rem);
	  tmp[--len] = (char) ysb8msk(&rem) + '0';
	}

      if (neg)
	tmp[--len] = '-';

      DISCARD strcpy(buf, tmp + len);
    }
}


static CONST_DATA char ysb8digits[] = "0123456789abcdef";

STATICF void ysb8xfmt(char *buf, ysb8 *orig)
{
  ysb8  val;
  sb4   rem;
  sword len;
  char  tmp[24];

  ysb8set(&val, orig);

  if (ysb8cmp(&val, ==, ysb8zero))
    DISCARD strcpy(buf, "0");
  else
    {
      len = 24;
      tmp[--len] = '\0';

      while (ysb8cmp(&val, !=, ysb8zero))
	{
	  rem = ysb8msk(&val) & 0xf;
	  ysb8srl(&val, &val, 4);
	  tmp[--len] = ysb8digits[rem];
	}

      DISCARD strcpy(buf, tmp + len);
    }
}
