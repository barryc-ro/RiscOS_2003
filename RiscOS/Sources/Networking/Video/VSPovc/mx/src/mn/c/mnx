/* mx/src/mn/mnx.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YSMSC_ORACLE
#include <ysmsc.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNX_ORACLE
#include <mnx.h>
#endif
#ifndef MNR_ORACLE
#include <mnr.h>
#endif
#ifndef MNRI_ORACLE
#include <mnri.h>
#endif


mnx *mnxCreate( mndrp *peer, ub4 dir, mnbv **bv, ub4 *nbv,
	       dvoid *usrp)
{
  mnctx *ctx;
  mnx   *xstr;
  ub4    ptrcnt;

  ctx = mnGlbCtx;

  if (dir != MNXDIR_ENCODE && dir != MNXDIR_DECODE)
    {
      mnSetLastError(ctx, MNERR_BADPARAM);
      return (mnx *) 0;
    }

  xstr = (mnx *) mnmAlloc(ctx, MNM_MAINPOOL, sizeof(mnx));

  DISCARD memset(xstr, 0, sizeof(mnx));

  xstr->dir = dir;
  xstr->usrp = usrp;
  xstr->bvp = bv;
  xstr->nbvp = nbv;

  if (xstr->dir == MNXDIR_ENCODE)
    {
      *bv = (mnbv *) 0;
      *nbv = 0;
    }
  else
    xstr->ptr = (*bv)->buf;

  
  xstr->ptrcnt = (ub4 *) mnxSpace(ctx, xstr, sizeof(ub4), (ub4) sizeof(ub4));
  if (!xstr->ptrcnt)
    goto error_leave;

  if (xstr->dir == MNXDIR_ENCODE)
    *xstr->ptrcnt = smnHton4(0);
  else
    {
      ptrcnt = smnNtoh4(*xstr->ptrcnt);
      if (ptrcnt)
	{
	  xstr->dptrs =
	    (dvoid **) mnmUserAlloc(ctx, (size_t) (sizeof(dvoid *) * ptrcnt));
	  if (!xstr->dptrs)
	    goto error_leave;
	  else
	    DISCARD memset(xstr->dptrs, 0,
			   (size_t) (sizeof(dvoid *) * ptrcnt));
	}
    }
  
  return xstr;

 error_leave:
  mnmFree(ctx, (dvoid *) xstr);
  return (mnx *) 0;
}


void mnxDestroy(mnx *xstr, boolean free)
{
  mnctx  *ctx;
  ub4     i;
  mnbv   *bv;
  mnxptr *scp;

  ctx = mnGlbCtx;

  if (xstr->dptrs)
    mnmUserFree(ctx, (dvoid *) xstr->dptrs);

  for (i = 0; i < MNXROWS; i++)
    while (scp = xstr->eptrs[i])
      {
	xstr->eptrs[i] = scp->next;
	mnmUserFree(ctx, (dvoid *) scp);
      }

  if (free)
    {
      for (i = 0, bv = *xstr->bvp; i < *xstr->nbvp; i++, bv++)
	mnmUserFree(ctx, (dvoid *) bv->buf);

      mnmUserFree(ctx, (dvoid *) *xstr->bvp);
    }

  mnmFree(ctx, (dvoid *) xstr);
}


ub4 mnxGetDir(mnx *xstr)
{
  return xstr->dir;
}


dvoid *mnxGetUsrp(mnx *xstr)
{
  return xstr->usrp;
}


void mnxFree(mnxFunc xfunc, dvoid *ptr)
{
  mnctx  *ctx;
  mnx     xstr;
  mnxptr *scp;
  ub4     i;

  ctx = mnGlbCtx;

  memset(&xstr, 0, sizeof(mnx));

  xstr.dir = MNXDIR_FREE;
  DISCARD (*xfunc)(&xstr, ptr);

  for (i = 0; i < MNXROWS; i++)
    while (scp = xstr.eptrs[i])
      {
	xstr.eptrs[i] = scp->next;
	mnmUserFree(ctx, (dvoid *) scp);
      }
}


boolean mnxVoid(mnx *xstr,  dvoid *buf)
{
  ub1 *ptr;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;

  ptr = mnxSpace(mnGlbCtx, xstr, 1, (ub4) 1);
  return (ptr != (ub1 *) 0);
}


boolean mnxB1(mnx *xstr, ub1 *val)
{
  ub4 cnt;
  ub1 *ptr;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;

  cnt = sizeof(ub1);
  if (!(ptr = mnxSpace(mnGlbCtx, xstr, (size_t) cnt, cnt)))
    return FALSE;

  if (xstr->dir == MNXDIR_ENCODE)
    *ptr = *val;
  else
    *val = *ptr;

  return TRUE;
}


boolean mnxB2(mnx *xstr, ub2 *val)
{
  ub4  cnt;
  ub2 *ptr;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;

  cnt = sizeof(ub2);
  if (!(ptr = (ub2 *) mnxSpace(mnGlbCtx, xstr, (size_t) cnt, cnt)))
    return FALSE;

  if (xstr->dir == MNXDIR_ENCODE)
    *ptr = smnHton2(*val);
  else
    *val = smnNtoh2(*ptr);

  return TRUE;
}


boolean mnxB4(mnx *xstr, ub4 *val)
{
  ub4  cnt;
  ub4 *ptr;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;

  cnt = sizeof(ub4);
  if (!(ptr = (ub4 *) mnxSpace(mnGlbCtx, xstr, (size_t) cnt, cnt)))
    return FALSE;

  if (xstr->dir == MNXDIR_ENCODE)
    *ptr = smnHton4(*val);
  else
    *val = smnNtoh4(*ptr);

  return TRUE;
}


boolean mnxSysB8(mnx *xstr, sysb8 *val)
{
  sysb8 t;
  sb4 hi;
  ub4 lo;
  boolean rslt;

  if (xstr->dir == MNXDIR_DECODE)
    {
      rslt = mnxSB4(xstr, &hi);
      rslt &= mnxB4(xstr, &lo);
      sysb8mak(val, hi, lo);
    }
  else
    {
      sysb8srl(&t, val, 32);
      lo = (ub4) sysb8msk(val);
      hi = sysb8msk(&t);
      rslt = mnxSB4(xstr, &hi);
      rslt &= mnxB4(xstr, &lo);
    }

  return rslt;
}


boolean mnxSB1(mnx *xstr, sb1 *val)
{
  return mnxB1(xstr, (ub1 *) val);
}


boolean mnxSB2(mnx *xstr, sb2 *val)
{
  return mnxB2(xstr, (ub2 *) val);
}


boolean mnxSB4(mnx *xstr, sb4 *val)
{
  return mnxB4(xstr, (ub4 *) val);
}


boolean mnxChar(mnx *xstr, char *val)
{
  ub4   cnt;
  char *ptr;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;

  cnt = sizeof(char);
  if (!(ptr = (char *) mnxSpace(mnGlbCtx, xstr, (size_t) cnt, cnt)))
    return FALSE;

  if (xstr->dir == MNXDIR_ENCODE)
    *ptr = *val;
  else
    *val = *ptr;

  return TRUE;
}


boolean mnxBoolean(mnx *xstr, boolean *val)
{
  boolean sts;
  ub4     ival;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;

  if (xstr->dir == MNXDIR_ENCODE)
    {
      ival = (*val != FALSE);
      sts = mnxB4(xstr, &ival);
    }
  else
    {
      sts = mnxB4(xstr, &ival);
      if (sts)
	*val = (boolean) ival;
    }

  return sts;
}


boolean mnxArray(mnx *xstr, dvoid **array, ub4 *nelm, ub4 maxelm,
		 size_t elmsz, mnxFunc func)
{
  mnctx *ctx;
  ub4    cnt;
  ub1   *ptr;

  ctx = mnGlbCtx;

  if (func == (mnxFunc) mnxChar ||
      func == (mnxFunc) mnxB1 ||
      func == (mnxFunc) mnxSB1)
    return mnxBytes(ctx, xstr, (ub1 **) array, nelm, maxelm);

  if (xstr->dir == MNXDIR_ENCODE || xstr->dir == MNXDIR_FREE)
    {
      cnt = (!maxelm ? *nelm : min(maxelm, *nelm));
      if (!mnxB4(xstr, &cnt))
	return FALSE;
    }
  else
    {
      if (!mnxB4(xstr, &cnt))
	return FALSE;

      *nelm = cnt = (!maxelm ? cnt : min(maxelm, cnt));

      if (cnt)
	{
	  if (!*array)
	    {
	      *array = mnmUserAlloc(ctx, (size_t) (cnt * elmsz));
	      if (!*array)
		return FALSE;
	    }

	  DISCARD memset(*array, 0, (size_t) (cnt * elmsz));
	}
    }

  for (ptr = (ub1 *) *array; cnt; ptr += elmsz, cnt--)
    if (!(*func)(xstr, (dvoid *) ptr))
      return FALSE;

  if (xstr->dir == MNXDIR_FREE)
    mnmUserFree(ctx, (dvoid *) *array);

  return TRUE;
}


boolean mnxOpaque(mnx *xstr, ub1 *buf, size_t len)
{
  ub4 tlen = len;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;
  else
    return mnxBytes(mnGlbCtx, xstr, &buf, &tlen, tlen);
}


boolean mnxString(mnx *xstr, char **str, size_t maxsz)
{
  ub4 len;

  if (xstr->dir == MNXDIR_ENCODE)
    len = strlen(*str) + 1;

  return mnxBytes(mnGlbCtx, xstr, (ub1 **) str, &len, (ub4) maxsz);
}


boolean mnxDynStr(mnx *xstr, char **str)
{
  ub4 len;

  if (xstr->dir == MNXDIR_ENCODE)
    len = (*str ? strlen(*str) + 1 : 0);
  else if (xstr->dir == MNXDIR_DECODE)
    *str = (char *) 0;

  return mnxBytes(mnGlbCtx, xstr, (ub1 **) str, &len, (ub4) 0);
}


boolean mnxPointer(mnx *xstr, dvoid **ptr, size_t objsz, mnxFunc func)
{
  mnctx  *ctx;
  sb4     newobj;
  ub4     idx;
  boolean sts;

  ctx = mnGlbCtx;

  if (xstr->dir == MNXDIR_ENCODE)
    {
      newobj = mnxEncodeRef(ctx, xstr, *ptr, &idx);
      if (newobj < 0)
	return FALSE;

      if (!mnxB4(xstr, &idx))
	return FALSE;

      if (newobj)
	return (*func)(xstr, *ptr);
      else
	return TRUE;
    }
  else if (xstr->dir == MNXDIR_DECODE)
    {
      if (!mnxB4(xstr, &idx))
	return FALSE;

      if (mnxDecodeRef(ctx, xstr, ptr, idx, objsz))
	return (*func)(xstr, *ptr);
      else
	return TRUE;
    }
  else
    {
      if (mnxEncodeRef(ctx, xstr, *ptr, &idx) > 0)
	{
	  sts = (*func)(xstr, *ptr);
	  mnmUserFree(ctx, (dvoid *) *ptr);
	}
      else
	sts = TRUE;

      return sts;
    }
}


boolean mnxUnion(mnx *xstr, sb4 *tag, dvoid *unobj, mnxArm *arms, mnxFunc dflt)
{
  if (xstr->dir == MNXDIR_ENCODE || xstr->dir == MNXDIR_FREE)
    {
      while (arms->xfunc && arms->tag != *tag) arms++;

      if (arms->xfunc)
	dflt = arms->xfunc;

      if (!mnxSB4(xstr, tag))
	return FALSE;

      if (dflt)
	DISCARD (*dflt)(xstr, unobj);
    }
  else
    {
      if (!mnxSB4(xstr, tag))
	return FALSE;

      while (arms->xfunc && arms->tag != *tag) arms++;

      if (arms->xfunc)
	dflt = arms->xfunc;

      if (dflt)
	DISCARD (*dflt)(xstr, unobj);
    }

  return TRUE;
}


boolean mnxOutStream(mnx *xstr, mnxStream *stream)
{
  mnp    *port;
  mna     addr;

  if (xstr->dir == MNXDIR_FREE)
    return TRUE;

  if (!stream->xfunc || !stream->elmsz ||
      (xstr->dir == MNXDIR_ENCODE && !stream->alloc))
    return FALSE;

  port = mnOpen(MNPROTO_STREAM);
  stream->priv = (dvoid *) port;

  if (xstr->dir == MNXDIR_ENCODE)
    {
      mnGetAddr(port, &addr);
      DISCARD mnListen(port, (ub4) 0, mnxOSCAcc, (dvoid *) stream);

      if (!mnxAddr(xstr, &addr))
	goto error_leave;
    }
  else
    {
      mnSetOptions(port, MNOPT_NONBLOCK);
      stream->alloc = (dvoid *(*)(mnxStream *, size_t)) 0;
      stream->push = mnxOSSPush;
      stream->pull = (boolean (*)(mnxStream *, dvoid **)) 0;
      stream->close = mnxOSSClose;

      if (!mnxAddr(xstr, &addr))
	goto error_leave;

      DISCARD mnConnect(port, &addr);
    }

  return TRUE;

 error_leave:
  DISCARD mnClose(port);
  return FALSE;
}


ub1 *mnxSpace(mnctx *ctx, mnx *xstr, size_t cnt, ub4 align)
{
  ub4   nbv, len;
  mnbv *bv;
  ub1  *ptr;

  if (xstr->dir == MNXDIR_ENCODE)
    {
      nbv = *xstr->nbvp;

      if (nbv)
	{
	  bv = (*xstr->bvp) + (nbv - 1);
	  len = ysRoundVal(bv->len, align);
	  xstr->ptr = sysxAlignPtr(xstr->ptr, align);
	}
      else
	{
	  len = 0;
	  xstr->max = 0;
	}

      if (len >= xstr->max || xstr->max - len < cnt)
	{
	  if (nbv && len != bv->len)
	    bv->len = (size_t) xstr->max;

	  nbv++;
	  bv = (mnbv *) mnmUserAlloc(ctx, (size_t) (nbv * sizeof(mnbv)));
	  if (!bv)
	    return (ub1 *) 0;

	  if (*xstr->bvp)
	    {
	      DISCARD memcpy(bv, *xstr->bvp,
			     (size_t) ((nbv - 1) * sizeof(mnbv)));
	      mnmUserFree(ctx, (dvoid *) *xstr->bvp);
	    }

	  *xstr->bvp = bv;
	  *xstr->nbvp = nbv;
	  xstr->max = max(ysRoundVal(cnt, 8), MNXBLKSIZE);

	  bv = (*xstr->bvp) + (nbv - 1);
	  len = 0;
	  xstr->ptr = bv->buf = (ub1 *) mnmUserAlloc(ctx, (size_t) xstr->max);
	  if (!xstr->ptr)
	    return (ub1 *) 0;
	}

      ptr = xstr->ptr;
      xstr->ptr += cnt;
      bv->len = (size_t) (len + cnt);
    }
  else
    {
      nbv = xstr->bvidx;
      bv = (*xstr->bvp) + nbv;
      len = ysRoundVal(xstr->max, align);
      xstr->ptr = sysxAlignPtr(xstr->ptr, align);

      if (len >= bv->len)
	{
	  nbv++;
	  if (nbv >= *xstr->nbvp)
	    {
	      mnSetLastError(ctx, MNSTS_EOS);
	      return (ub1 *) 0;
	    }

	  bv = (*xstr->bvp) + nbv;
	  len = 0;
	  xstr->bvidx = nbv;
	  xstr->ptr = bv->buf;
	}

      ptr = xstr->ptr;
      xstr->ptr += cnt;
      xstr->max = len + cnt;
    }

  return ptr;
}


boolean mnxBytes(mnctx *ctx, mnx *xstr, ub1 **array, ub4 *nelm, ub4 maxelm)
{
  ub1 *ptr;
  ub4  cnt;

  if (xstr->dir == MNXDIR_FREE)
    {
      mnmUserFree(ctx, (dvoid *) *array);
      return TRUE;
    }

  if (xstr->dir == MNXDIR_ENCODE)
    {
      cnt = (!maxelm ? *nelm : min(maxelm, *nelm));
      if (!mnxB4(xstr, &cnt))
	return FALSE;

      if (!(ptr = mnxSpace(ctx, xstr, (size_t) cnt, (ub4) 1)))
	return FALSE;

      if (*array)
	DISCARD memcpy(ptr, *array, (size_t) cnt);
    }
  else
    {
      if (!mnxB4(xstr, &cnt))
	return FALSE;

      if (cnt)
	{
	  if (!(ptr = mnxSpace(ctx, xstr, (size_t) cnt, (ub4) 1)))
	    return FALSE;

	  *nelm = cnt = (!maxelm ? cnt : min(maxelm, cnt));

	  if (!*array && cnt)
	    {
	      if (!(*array = (ub1 *) mnmUserAlloc(ctx, (size_t) cnt)))
		return FALSE;
	    }

	  if (*array)
	    DISCARD memcpy(*array, ptr, (size_t) cnt);
	}
      else
	*nelm = cnt;
    }

  return TRUE;
}


sb4 mnxEncodeRef(mnctx *ctx, mnx *xstr, dvoid *ptr, ub4 *idx)
{
  mnxptr *scp;
  ub4     key;

  if (!ptr)
    {
      *idx = 0;
      return 0;
    }

  key = (ub4) ptr;
  key = (key & 0x00ffff00) >> 8;
  key = (key & 0xff) ^ (key >> 8);
  key = key & (MNXROWS - 1);

  for (scp = xstr->eptrs[key]; scp && scp->ptr != ptr; scp = scp->next) ;
  if (scp)
    {
      *idx = scp->idx;
      return 0;
    }
  else
    {
      if (!(scp = (mnxptr *) mnmUserAlloc(ctx, sizeof(mnxptr))))
	return MNERR_OUTMEM;

      scp->idx = *idx = ++xstr->nidx;
      scp->ptr = ptr;
      scp->next = xstr->eptrs[key];
      xstr->eptrs[key] = scp;

      if (xstr->dir != MNXDIR_FREE)
	*xstr->ptrcnt = smnHton4(xstr->nidx);

      return 1;
    }
}


boolean mnxDecodeRef(mnctx *ctx, mnx *xstr, dvoid **ptr, ub4 idx, size_t objsz)
{
  if (!idx)
    {
      *ptr = (dvoid *) 0;
      return FALSE;
    }

  idx--;

  if (xstr->dptrs[idx])
    {
      *ptr = xstr->dptrs[idx];
      return FALSE;
    }
  else
    {
      *ptr = xstr->dptrs[idx] = mnmUserAlloc(ctx, (size_t) objsz);
      return TRUE;
    }
}


void mnxOSCAcc(dvoid *sp,  sb4 sts)
{
  mnxStream *stream;
  mnp       *port, *cport;

  if (sts < 0)
    return;

  stream = (mnxStream *) sp;
  port = (mnp *) stream->priv;

  cport = mnAccept(port);
  DISCARD mnClose(port);
  stream->priv = (dvoid *) cport;

  DISCARD mnRead(cport, (ub1 *) 0, 0, FALSE,
		 (ub4) 0, mnxOSCRead, (dvoid *) stream);
}


void mnxOSCRead(dvoid *sp, sb4 sts)
{
  mnctx     *ctx;
  mnxStream *stream;
  mnp       *port;
  ub4        sz, nbv;
  ub1       *buf, *ptr;
  mnbv       bv, *bvp;
  mnx       *xstr;

  ctx = mnGlbCtx;
  stream = (mnxStream *) sp;
  port = (mnp *) stream->priv;

  
  sts = mnRead(port, (ub1 *) &sz, sizeof(ub4), TRUE,
	       (ub4) 0, (mnHandler) 0, (dvoid *) 0);
  if (sts == sizeof(ub4))
    {
      sz = smnNtoh4(sz);
      buf = (ub1 *) mnmUserAlloc(ctx, (size_t) sz);
      if (buf)
	ptr = (ub1 *) (*stream->alloc)(stream, stream->elmsz);
      else
	ptr = (ub1 *) 0;

      if (!ptr || !buf)
	sts = MNERR_OUTMEM;
      else
	sts = mnRead(port, buf, (size_t) sz, TRUE,
		     (ub4) 0, (mnHandler) 0, (dvoid *) 0);

      if (sts == (sb4) sz)
	{
	  DISCARD memset(ptr, 0, stream->elmsz);

	  bv.len = (size_t) sz;
	  bv.buf = buf;
	  bvp = &bv;
	  xstr = mnxCreate((mndrp *) 0, MNXDIR_DECODE, &bvp, &nbv,
			   (dvoid *) 0);
	  if (xstr)
	    {
	      if (!(*stream->xfunc)(xstr, (dvoid *) ptr))
		sts = mnLastError();
	      mnxDestroy(xstr, FALSE);
	      mnmUserFree(ctx, (dvoid *) buf);

	      if (sts > 0 && stream->push)
		sts = (*stream->push)(stream, (dvoid *) ptr);
	    }
	}
      else if (sts > 0)                       
	sts = MNSTS_EOS;
    }

  if (sts >= 0)
    DISCARD mnRead(port, (ub1 *) 0, 0, FALSE, (ub4) 0,
		   mnxOSCRead, (dvoid *) stream);
  else
    {
      if (stream->close)
	(*stream->close)(stream, sts == MNSTS_EOS ? 0 : sts);

      DISCARD mnClose(port);
    }
}


sb4 mnxOSSPush(mnxStream *stream, dvoid *ptr)
{
  mnx  *xstr;
  mnp  *port;
  mnbv *bvp;
  ub4   nbv, sz, i;
  sb4   sts;

  port = (mnp *) stream->priv;

  xstr = mnxCreate((mndrp *) 0, MNXDIR_ENCODE, &bvp, &nbv, (dvoid *) 0);

  if (xstr && (*stream->xfunc)(xstr, ptr))
    {
      for (sz = i = 0; i < nbv; i++)
	sz += bvp[i].len;

      sz = smnHton4(sz);
      sts = mnWrite(port, (ub1 *) &sz, sizeof(sz));
      for (i = 0; sts > 0 && i < nbv; i++)
	sts = mnWrite(port, bvp[i].buf, bvp[i].len);
    }
  else
    sts = mnLastError();

  mnxDestroy(xstr, TRUE);
  return (sts > 0 ? 0 : sts);
}


void mnxOSSClose(mnxStream *stream,  sb4 sts)
{
  mnp *port;

  port = (mnp *) stream->priv;
  mnSetOptions(port, (ub4) 0);
  DISCARD mnClose(port);
  stream->priv = (dvoid *) 0;
}
