/* mx/src/mn/mni.h */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef MNI_ORACLE
#define MNI_ORACLE

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef SMN_ORACLE
#include <smn.h>
#endif
#ifndef MTCCTX_ORACLE
#include <mtcctx.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNNIO_ORACLE
#include <mnnio.h>
#endif
#ifndef MNRC_ORACLE
#include <mnrc.h>
#endif


sb4 smnClock(void);


typedef struct mnctx  mnctx;                               
typedef struct mnactx mnactx;                     
typedef struct mnmctx mnmctx;                      
typedef struct mnectx mnectx;                       

typedef struct mnq    mnq;                                          
typedef struct mnqe   mnqe;                                 

typedef struct mnrte  mnrte;                                 
typedef struct mnnhdr mnnhdr;                               
typedef struct mnnpkt mnnpkt;                           

typedef struct mntre mntre;                      
typedef struct mntse mntse;                         

typedef struct mzncd mzncd;                       


struct mnq
{
  mnqe *head;                                               
  mnqe *tail;                                               
  mnqe *tmp;                                             
};

struct mnqe
{
  mnqe *next;                                         
};

#define mnqInit(q)  ((q)->head = (q)->tail = (mnqe *) 0)
#define mnqEnq(q, elm) \
  do { \
    ((mnqe *) elm)->next = (mnqe *) 0; \
    if ((q)->head) \
      (q)->tail->next = (mnqe *) (elm); \
    else \
      (q)->head = (mnqe *) (elm); \
    (q)->tail = (mnqe *) (elm); \
  } while (0)
#define mnqDeq(q)  \
  (((q)->tmp = (q)->head) ? ((q)->head = (q)->head->next, (q)->tmp) : (q)->tmp)


#define MN_CRITICAL_REGION     if (!ctx->crcnt++) ysMtxLock(&ctx->glbmtx);
#define MN_END_CRITICAL_REGION if (!--ctx->crcnt) ysMtxUnlock(&ctx->glbmtx);


#define MNLINFO  ((ub4) 0)                            
#define MNLWARN  ((ub4) 1)                                  
#define MNLERROR ((ub4) 2)                                    
#define MNLFATAL ((ub4) 3)                                    

void mnPrint(ub4 type, const char *fmt, ...);


#define MNM_MAINPOOL  ((ub4) 1)                                 
#define MNM_SENDPOOL  ((ub4) 2)                                 
#define MNM_RECVPOOL  ((ub4) 3)                              
#define MNM_MAXPOOL   ((ub4) 4)                       
#define MNM_MAYBEPOOL ((ub4) 5)           

mnmctx *mnmInit(mnbv *bv, ub4 nbv, mnAlloc alloc, mnFree free);
void    mnmTerm(mnctx *ctx);
dvoid  *mnmAlloc(mnctx *ctx, ub4 poolid, size_t len);
void    mnmFree(mnctx *ctx, dvoid *ptr);
sb4     mnmWait(mnctx *ctx, ub4 poolid);

sb4     mnmPoolAlloc(mnctx *ctx, ub4 poolid, ub4 poolsz, ub4 lowwtr);
boolean mnmPoolLowwtr(mnctx *ctx, ub4 poolid);
ub4     mnmPoolSpace(mnctx *ctx, ub4 poolid);
sb4     mnmSetPool(mnctx *ctx, ub4 poolid, ub4 len);

void    mnmConfig(mnctx *ctx, mnAlloc alloc, mnFree free);
dvoid  *mnmUserAlloc(mnctx *ctx, size_t len);
void    mnmUserFree(mnctx *ctx, dvoid *ptr);


void   mneInit(mnctx *ctx);
void   mneTerm(mnctx *ctx);
void   mnePost(mnctx *ctx, mnHandler type, dvoid *usrp, sb4 val);
void   mneTimer(mnctx *ctx, ub4 msec, mnsem *sem);
sb4    mneWait(mnctx *ctx, ub4 nsem, mnsem **sem, ub4 match);
sb4    mneSemWait(mnctx *ctx, ub4 timeout, ub4 nsem, mnsem **sem, ub4 match);
void   mneSemSetHandler(mnctx *ctx, mnsem *sem, mnHandler handler,
			boolean autofree);
void   mneLatch(mnctx *ctx, mnsem *sem);
void   mneUnlatch(mnctx *ctx, mnsem *sem);
void   mneSet(mnctx *ctx, mnsem *sem, sb4 val, boolean unlatch);
sb4    mneGet(mnctx *ctx, mnsem *sem);
mnsem *mneMakeSem(mnctx *ctx, mnHandler handler, dvoid *usrp);


#define MNNVRS      0x10                     

#define MNNFLG_MTC  0x01                                     
#define MNNFLG_FST  0x02                                    
#define MNNFLG_ACK  0x04                           
#define MNNFLG_CLS  0x08                                 
#define MNNFLG_PRI  0x10                                     
#define MNNFLG_ACC  0x20               
#define MNNFLG_RSR  0x40                              
#define MNNFLG_CPY  0x80                     

struct mnnhdr
{
  ub1 proto;                                             
  ub1 flags;                                                
  ub2 cksm;                                                      
  ub4 len;                                                 
  sb4 seqid;                                                  
  mna src;                                                 
  mna dst;                                            
};


#define MNNFLG_TL   ((ub4) 0x80000000) 

struct mnnpkt
{
  mnnpkt *next;                                      
  ub4     len;                                           
  ub4     off;                   
  ub4     flags;                                          
  sb4     seqid;                        
  ub4     max;                                     
  ub4     stime;                       
  mnnio  *nio;                                       
  mnnpa   pa;                           
};

#define mnnNextNio(nio) \
  ((mnnio *) (((mnqe *) (nio)->priv)->next))

void    mnnNewNio(mnctx *ctx, mnnio *nio);
void    mnnFreeNio(mnctx *ctx, mnnio *nio);
mnnio  *mnnFindNio(mnctx *ctx, char *family);
void    mnnScanNio(mnctx *ctx);
sb4     mnnRecvPkt(mnctx *ctx, mnnio *nio, boolean poll, ub4 timeout);
void    mnnProcPkt(mnctx *ctx, mnnio *nio);
void    mnnForward(mnctx *ctx, mnnio *nio, mnnpkt *pkt);
sb4     mnnSendPkt(mnctx *ctx, mnnpkt *pkt);
void    mnnFragment(mnnpkt *pkt, ub1 **bufp, ub4 *xlenp);
ub2     mnnCheckSum(ub1 *buf, ub4 len);
void    mnnSetSubnet(mnnio *nio, mna *addr);


#define MNAFLG_SELF     ((ub4) 0x0001)            
#define MNAFLG_PERM     ((ub4) 0x0002)                 
#define MNAFLG_DELETE   ((ub4) 0x0004)          

#define MNARTEHB   ((ub4) 60000) 
#define MNARTELIFE ((ub4) (3 * MNARTEHB)) 

struct mnrte
{
  mnrte *next;                                        
  mnrte *prev;                                    
  mna    addr;                                          
  ub4    mask;              
  mnnio *nio;                                               
  mnnpa  pa;                                    
  ub4    refcnt;           
  ub4    flags;                                               
  ub4    itime;                          
};

typedef void (*mnaDeathH)(dvoid *usrp, mna *host, mnrte *rte);

#define MNARSADDR           "0xffffffff.1"
#define MNADEATHADDR        "0xffffffff.69"
#define MNADEATHPORT        "0x00000000.69"
#define MNADPLEN              9                    
#define MNADT_WATCH         0x01                       
#define MNADT_RMWATCH       0x02
#define MNADT_DEAD          0x10
#define MNADT_BADWATCH      0x11

#define mnaIsNet(addr)      (!(addr)->bits[4] && !(addr)->bits[5])
#define mnaPortNum(addr)    (sysxGetUaB2(&(addr)->bits[6]))
#define mnaSetPortNum(addr, prtno) \
  (sysxPutUaB2(&(addr)->bits[6], (prtno)))
#define mnaWellKnown(addr)  (sysxGetUaB4((addr)->bits) == 0xffffffff)

void    mnaInit(mnctx *ctx, mnnio **nios, ub4 nnio, mnnpa *gtwy);
void    mnaTerm(mnctx *ctx);
void    mnaTeardown(mnctx *ctx, mnnio *nio, mnHandler handler, dvoid *usrp);
void    mnaReopen(dvoid *usrp, sb4 sts);
boolean mnaIsDest(mnctx *ctx, mna *nioaddr, mna *dst);
sb4     mnaRequest(mnctx *ctx, mna *addr, mnHandler handler, dvoid *usrp);
void    mnaRequestHandle(dvoid *usrp, sb4 sts);
mnrte  *mnaInsertRoute(mnctx *ctx, mna *addr, ub4 mask, mnnio *nio, mnnpa *pa,
		       ub4 flags);
mnrte  *mnaFindRoute(mnctx *ctx, mna *dst);
void    mnaDeleteRoute(mnctx *ctx, mnrte *rte);
void    mnaRouteReaper(dvoid *ptr, sb4 val);
sb4     mnaBind(mnctx *ctx, mna *addr, mnp *port, boolean req);
mnp    *mnaFind(mnctx *ctx, mna *addr);
void    mnaUnbind(mnctx *ctx, mnp *port);
void    mnaSetDeath(mnctx *ctx, mnaDeathH mortH, dvoid *mortP);


#define MNSTS_CLOSED       1
#define MNSTS_CONNECT      2
#define MNSTS_LISTEN       3
#define MNSTS_ESTABLISHED  4
#define MNSTS_FINISH       5
#define MNSTS_DISCONNECT   6
#define MNSTS_TIMEWAIT     7

#define MNSTS_IDLE         8
#define MNSTS_XMIT         9
#define MNSTS_REXMIT      10
#define MNSTS_PERSIST     11




#define MNTMINREXMT    750                       
#define MNTMAXREXMT  20000                       
#define MNTMAXRXCNT     10             

#define MNTPRTLIFE ((ub4) 60000)                 
#define MNTRCVLIFE ((ub4) 30000)   

struct mnp
{
  mnp        *next;                                    
  mnp        *nport;                              
  mnp        *pport;                          

  ub4         proto;                                        
  ub4         flags;                                           
  mna         me;                                            
  mna         peer;                                          
  mnrte      *rte;                                       

  const char *name;                                          

  
  sb4     sstate;                                           

  mnsem  *rxsem;                               
  ub4     rxcnt;                                         
  ub4     rexmt;                                 
  ub4     pscnt;                                            

  sb4     fsseq;                               
  sb4     naseq;                               

  ub4     swind;                                         
  ub4     srt;                          
  ub4     rtde;                             

  mnnpkt *unpkt;                              
  mnnpkt *nspkt;                                      
  mnnpkt *lspkt;                                     

  mnq     se;                                  

  
  sb4     rstate;                                           
  sb4     rtime;                                
  mnsem  *clnsem;                                

  sb4     nrseq;                     

  mnnpkt *rs;                                            
  mnnpkt *ls;                             

  mnq     accepts;                            
  mnq     re;                                              

  boolean ackpend;                  
  boolean resetseen;    
  boolean everrcv;             
};

struct mntse
{
  mntse *next;                                   
  mnsem *sem;                                            
  sb4    seqid;                                   
  ub4    cnt;                               
};

struct mntre
{
  mntre  *next;                               
  mnsem  *sem;                                           
  mna    *from;                     
  mnbv   *origbv;                       
  mnbv   *cbv;                            
  ub4     nbv;                              
  ub4     cnt;                      
  boolean fill;                     
};


ub4     mntPortHash(ub2 prtno, mna *peer);
void    mntInsertPort(mnctx *ctx, mnp *port);
void    mntRemovePort(mnctx *ctx, mnp *port);
mnp    *mntFindPort(mnctx *ctx, mna *me, mna *peer);
void    mntIn(mnctx *ctx, mnnpkt *pkt);
mnp    *mntCreatePort(mnctx *ctx, mnp *port, mna *peer, mnrte *rte);
void    mntBlowPort(dvoid *pp, sb4 val);
void    mntDestroyPort(mnctx *ctx, mnp *port);
void    mntCleanSetup(mnctx *ctx, mnp *port, ub4 delay);
void    mntClean(dvoid *pp, sb4 val);
 
ub4     mntInAck(mnctx *ctx, mnnpkt *pkt, mnp *port);
void    mntXmit(dvoid *pp, sb4 val);
void    mntRexmit(dvoid *pp, sb4 val);
sb4     mntSend(mnctx *ctx, mnp *port, ub1 *hbuf, size_t hlen,
		mnbv *bv, ub4 nbv, boolean fst, boolean eof, mnsem *sem);
sb4     mntSendFill(mnctx *ctx, mnp *port, ub1 *buf, size_t len, ub4 totlen,
		    boolean first, boolean eof);
sb4     mntAppendPkt(mnctx *ctx, mnp *port, ub4 totlen, boolean first);
void    mntAbort(mnctx *ctx, mnp *port, sb4 sts);
sb4     mnSendHeader(mnp *port, mna *to, ub1 *buf, size_t len,
		     mnbv *bv, ub4 nbv, mnHandler handler, dvoid *usrp);

ub4     mntInOpen(mnctx *ctx, mnnpkt *pkt, mnp *port);
void    mntInData(mnctx *ctx, mnnpkt *pkt, mnp *port);
void    mntSendAck(dvoid *pp, sb4 val);
void    mntRecvAccept(mnctx *ctx, mnp *port);
void    mntRecvDisc(mnctx *ctx, mnp *port);
void    mntRecvData(mnctx *ctx, mnp *port);
boolean mntRecvFill(mnctx *ctx, mnp *port, mntre *re);
sb4     mntRecv(mnp *port, mna *from, mnbv *bv, ub4 nbv,
		ub4 timeout, mnHandler handler, dvoid *usrp, boolean fill);
sb4 mntinRecvTest(mnp *port, mna *from);


void mnBlobAccept(dvoid *bp, sb4 sts);
void mnBlobRead(dvoid *bp, sb4 sts);
void mnBlobRexmt(mnctx *ctx, mnp *port);
void mnBlobClose(dvoid *bp, sb4 sts);


#define MNOTYP_DESTNOTREACH  ((ub4) 1)
#define MNOTYP_DESTNOTVALID  ((ub4) 2)
#define MNOTYP_REDIRECT      ((ub4) 3)
#define MNOTYP_RESET         ((ub4) 4)
#define MNOTYP_ADDRHB        ((ub4) 5)
#define MNOTYP_ADDRREQUEST   ((ub4) 6)
#define MNOTYP_ADDRREPLY     ((ub4) 7)
#define MNOTYP_ADDRRELEASE   ((ub4) 8)
#define MNOTYP_ECHOREQUEST   ((ub4) 9)
#define MNOTYP_ECHOREPLY     ((ub4) 10)
#define MNOTYP_SETDOMAIN     ((ub4) 11)
#define MNOTYP_ADDRSYNCH     ((ub4) 12)
#define MNOTYP_RESETRCVR     ((ub4) 13)

void mnoIn(mnctx *ctx, mnnpkt *pkt);
void mnoFill(mnctx *ctx);
sb4  mnoRecv(mnctx *ctx, mna *from, mnbv *bv, ub4 nbv,
	     ub4 timeout, mnHandler handler, dvoid *usrp);
sb4  mnoSendAddrRequest(mnctx *ctx, mna *addr);
sb4  mnoSendAddrReply(mnctx *ctx, sb4 sts, mna *to,
		      mna *addr, mnnio *nio, mnnpa *pa);
sb4  mnoSendAddrRelease(mnctx *ctx, mna *addr);
sb4  mnoSend(mnctx *ctx, ub4 typ, mna *dst, mna *src);
sb4  mnoSendWRte(mnctx *ctx, ub4 typ, mna *dst, mna *src, mnrte *rte);
sb4  mnoSendRedirect(mnctx *ctx, mnnpkt *pkt, mnrte *rte, ub4 flags);
sb4  mnoSendSetDomain(mnctx *ctx, mna *addr, char *cwd);
sb4  mnoSendResetRcvr(mnctx *ctx, mnnpkt *pkt, sb4 seqid);
boolean mnoIsAddrReq(ub1 *buf);


void mzncInit(mnctx *ctx);
void mzncTerm(mnctx *ctx);


#define MNFLG_STROBE ((ub4) 0x4000) 
#define MNFLG_INTR   ((ub4) 0x1000)                

#define MNPORTROWS     257                        

struct mnctx
{
  mnmctx  *mctx;                                   
  mnectx  *ectx;                                    
  mnactx  *actx;                                  

  ysmtx    glbmtx;                                 

  ub4      flags;                                           
  mnLogger lfunc;                                        
  sb4      lasterror;                                          
  ub4      mwind;                                     

  sb4      iss;                                   

  mnnio   *nios;                                                 
  mnnio   *rnio;                                         

  mnp     *ports[MNPORTROWS];                             
  ub2      nprtno;                             

  mnq      ocppkt;                                
  mnq      re;                                         

  char    *cwd;                                 

  mnrb    *nsbh;                     
  mzncd   *nscd;                        

  boolean  idleactive;                    
  ub4      crcnt;                                   
  ub4      initcnt;                                   
  yslst   *rcvnios;                                  
};

#define mnSetLastError(ctx, err)  ((ctx)->lasterror = (err))
#define mnGlbCtx                  ((mnctx *) mtcctxGet(MNETCTX, (ub4) 0))

#endif 
