/* mx/src/mn/mne.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ysv.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNI_ORACLE
#include <mni.h>
#endif


typedef struct mnevt mnevt;                                  

struct mnectx
{
  mnq    evts;                                                

  mnSpin spinner;                                           
  dvoid *usrp;                                           
  ub4    interval;                                          

  boolean   intrtrip;                                   
  sb4       intrsts;                                     
  mnsem    *intrsem;                                  

  yslst    *tmrs;                                          
};

struct mnsem
{
  ub4       cnt;                                              
  boolean   freed;                   
  boolean   autofree;    

  mnHandler handler;                         
  dvoid    *usrp;                                            
  sb4       val;                                       

  yscv     *cv;                                                
};

struct mnevt
{
  mnevt    *next;                                     
  mnHandler type;                                              
  dvoid    *usrp;                                        
  sb4       val;                                            
};

STATICF void mneTimerHndlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			   size_t argsz);
STATICF void mnIdler(dvoid *usrp, CONST ysid *exid, dvoid *arg, size_t argsz);
STATICF void mnIntrHndlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			 size_t argsz);


void mneInit(mnctx *ctx)
{
  mnectx *ectx;

  ectx = (mnectx *) mnmAlloc(ctx, MNM_MAINPOOL, sizeof(mnectx));

  mnqInit(&ectx->evts);

  ectx->spinner = (mnSpin) 0;
  ectx->usrp = (dvoid *) 0;
  ectx->interval = 0;

  ectx->intrtrip = FALSE;
  ectx->intrsem = (mnsem *) 0;

  ectx->tmrs = ysLstCreate();

  ctx->ectx = ectx;
  ysSetIdler("mnIdler", mnIdler, (dvoid *) ctx);
}


void mneTerm(mnctx *ctx)
{
  mnectx *ectx;
  mnevt  *tmpe;
  mnsem  *sem;

  ectx = ctx->ectx;

  if (ectx->intrsem)
    mneSet(ctx, ectx->intrsem, MNSTS_TERMINATE, TRUE);

  while (sem = (mnsem *) ysLstDeq(ectx->tmrs))
    mneSet(ctx, sem, MNERR_TIMEOUT, TRUE);
  ysLstDestroy(ectx->tmrs, (ysmff) 0);

  while (tmpe = (mnevt *) mnqDeq(&ectx->evts))
    {
      if (tmpe->type == mntBlowPort)
	mntBlowPort(tmpe->usrp, tmpe->val);
      mnmFree(ctx, (dvoid *) tmpe);
    }

  mnmFree(ctx, (dvoid *) ectx);
}


void mnePost(mnctx *ctx, mnHandler type, dvoid *usrp, sb4 val)
{
  mnectx *ectx;
  mnevt  *evt;

  evt = (mnevt *) mnmAlloc(ctx, MNM_MAINPOOL, sizeof(mnevt));

  evt->type = type;
  evt->usrp = usrp;
  evt->val = val;

  ectx = ctx->ectx;
  mnqEnq(&ectx->evts, evt);
}


void mneTimer(mnctx *ctx, ub4 msec, mnsem *sem)
{
  ysevt *evt;
  sysb8  timeout;

  mneLatch(ctx, sem);
  sysb8ext(&timeout, (sb4) msec);
  sysb8mulb4(&timeout, &timeout, (sb4) 1000);
  evt = ysEvtSimple(mneTimerHndlr, (dvoid *) sem);
  DISCARD ysLstEnq(ctx->ectx->tmrs, (dvoid *) sem);
  ysTimer(&timeout, evt);
}


STATICF void mneTimerHndlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			   size_t argsz)
{
  mnctx *ctx;
  ysle  *le;

  if (exid != YS_EX_SHUTDOWN)
    {
      yseTry
	ctx = mnGlbCtx;
      yseCatch(YS_EX_NOTINIT)
	ctx = (mnctx *) 0;
      yseEnd

      if (!ctx)
	return;

      for (le = ysLstHead(ctx->ectx->tmrs);
	   le && usrp != ysLstVal(le);
	   le = ysLstNext(le)) ;

      
      if (le)
	{
	  DISCARD ysLstRem(ctx->ectx->tmrs, le);
	  mneSet(ctx, (mnsem *) usrp, MNERR_TIMEOUT, TRUE);
	}
    }
}


STATICF void mneSemDestroy(mnctx *ctx, mnsem *sem)
{
  ysle *le;

  for (le = ysLstHead(ctx->ectx->tmrs); le && ((dvoid *) sem != ysLstVal(le));
       le = ysLstNext(le)) ;

  if (le)
    DISCARD ysLstRem(ctx->ectx->tmrs, le);
  mnmFree(ctx, (dvoid *) sem);
}


sb4 mneWait(mnctx *ctx, ub4 nsem, mnsem **sem, ub4 match)
{
  mnectx *ectx;
  ub4     cnt, i;
  yscv    localcv;

  ectx = ctx->ectx;
  ysCondCreate(&localcv);
  for (i = 0; i < nsem; i++)
    sem[i]->cv = &localcv;

  
  ysMtxLock(&ctx->glbmtx);
  yseTry
    yseTry
      {
	do
	  {
	    for (i = cnt = 0; i < nsem; i++)
	      if (sem[i]->val != MNSTS_UNKNOWN)
		cnt++;

	    if (cnt < match)
	      ysCondWait(&localcv, &ctx->glbmtx);
	  }
	while (cnt < match);
      }
    yseFinally
      {
	ysMtxUnlock(&ctx->glbmtx);
	ysCondDestroy(&localcv);
	for (i = 0; i < nsem; i++)
	  sem[i]->cv = (yscv *) 0;
      }
    yseEnd
  yseCatch(YS_EX_INTERRUPT)
    cnt = MNSTS_ABORTED;
  yseCatch(YS_EX_SHUTDOWN)
    cnt = MNSTS_ABORTED;
  yseEnd

  return cnt;
}


sb4 mneSemWait(mnctx *ctx, ub4 timeout, ub4 nsem, mnsem **sem, ub4 match)
{
  sb4    cnt, ccnt;
  mnsem *tsem, **seml;

  tsem = mnSemAlloc((dvoid *) 0);
  seml = (mnsem **)
    mnmAlloc(ctx, MNM_MAINPOOL, (size_t) ((nsem + 1) * sizeof(mnsem *)));
  mneTimer(ctx, timeout, tsem);

  if (sem)
    DISCARD memcpy(seml, sem, (size_t) (nsem * sizeof(mnsem *)));

  seml[nsem++] = tsem;

  cnt = 0;
  while (tsem->val == MNSTS_UNKNOWN && cnt >= 0 && cnt < (sb4) match)
    {
      ccnt = cnt + 1;
      cnt = mneWait(ctx, nsem, seml, (ub4) ccnt);
    }

  if (cnt > 0 && tsem->val != MNSTS_UNKNOWN)
    cnt--;

  mnSemFree(tsem);
  mnmFree(ctx, (dvoid *) seml);

  return cnt;
}


void mneSemSetHandler( mnctx *ctx, mnsem *sem, mnHandler handler,
		      boolean autofree)
{
  sem->autofree = autofree;
  sem->handler = handler;
}


void mneLatch( mnctx *ctx, mnsem *sem)
{
  sem->cnt++;
}


void mneUnlatch(mnctx *ctx, mnsem *sem)
{
  if (sem->cnt > 0)
    sem->cnt--;
  else
    mnPrint(MNLERROR, "INTERNAL:mneUnlatch");

  if (!sem->cnt && sem->freed)
    mneSemDestroy(ctx, sem);
}


void mneSet(mnctx *ctx, mnsem *sem, sb4 val, boolean unlatch)
{
  
  if (!sem->freed)
    {
      sem->val = val;
      if (sem->cv)
	ysCondSignal(sem->cv);
      if (sem->handler)
	{
	  mnePost(ctx, sem->handler, sem->usrp, sem->val);
	  if (sem->autofree)
	    sem->freed = TRUE;
	}
    }

  if (unlatch)
    mneUnlatch(ctx, sem);
  else if (!sem->cnt && sem->freed)
    mneSemDestroy(ctx, sem);
}


sb4 mneGet( mnctx *ctx, mnsem *sem)
{
  return sem->val;
}


mnsem *mneMakeSem(mnctx *ctx, mnHandler handler, dvoid *usrp)
{
  mnsem *sem;

  if (handler)
    {
      sem = mnSemAlloc(usrp);
      mneSemSetHandler(ctx, sem, handler, TRUE);
    }
  else if (usrp)
    sem = (mnsem *) usrp;
  else
    sem = mnSemAlloc((dvoid *) 0);

  mneLatch(ctx, sem);

  return sem;
}


ub4 mnIdle(void)
{
  ysYield();
  return (ub4) 10000;
}


STATICF void mnIdler(dvoid *usrp, CONST ysid *exid, dvoid *arg, size_t argsz)
{
  mnctx  *ctx;
  mnectx *ectx;
  mnevt  *tmpe;

  if (exid)
    return;

  ctx = (mnctx *) usrp;
  ctx->idleactive = FALSE;
  ectx = (mnectx *) ctx->ectx;

  
  mnnScanNio(ctx);

  
  while (tmpe = (mnevt *) mnqDeq(&ectx->evts))
    {
      (*tmpe->type)(tmpe->usrp, tmpe->val);
      mnmFree(ctx, (dvoid *) tmpe);
      ctx->idleactive = TRUE;
    }

  *((boolean *) arg) = ctx->idleactive;
}


void mnWait(ub4 msec)
{
  sysb8 timeout;

  if (msec)
    {
      sysb8ext(&timeout, (sb4) msec);
      sysb8mulb4(&timeout, &timeout, (sb4) 1000);
      ysTimer(&timeout, ysEvtDummy());
    }

  ysBlock();
}


void mnSetBusyWait(mnSpin spinner, dvoid *usrp, ub4 interval)
{
  mnectx *ectx;

  ectx = mnGlbCtx->ectx;
  ectx->spinner = spinner;
  ectx->usrp = usrp;
  ectx->interval = (interval ? interval : 1);
}


mnsem *mnSemAlloc(dvoid *usrp)
{
  mnsem  *sem;

  sem = (mnsem *) mnmAlloc(mnGlbCtx, MNM_MAINPOOL, sizeof(mnsem));

  sem->cnt = 0;
  sem->freed = FALSE;
  sem->autofree = FALSE;
  sem->handler = (mnHandler) 0;
  sem->usrp = usrp;
  sem->val = MNSTS_UNKNOWN;
  sem->cv = (yscv *) 0;

  return sem;
}


void mnSemFree(mnsem *sem)
{
  if (sem->cnt)
    {
      sem->freed = TRUE;
      sem->val = MNSTS_ABORTED;
    }
  else
    mneSemDestroy(mnGlbCtx, sem);
}


void mnSemSetUsrp(mnsem *sem, dvoid *usrp)
{
  sem->usrp = usrp;
}


dvoid *mnSemGetUsrp(mnsem *sem)
{
  return sem->usrp;
}


sb4 mnSemTest(mnsem *sem)
{
  DISCARD mnIdle();
  return sem->val;
}


sb4 mnSemGroupTest(ub4 nsem, mnsem **sem)
{
  sb4 cnt;

  DISCARD mnIdle();

  for (cnt = 0; nsem; nsem--, sem++)
    if ((*sem)->val != MNSTS_UNKNOWN)
      cnt++;

  return cnt;
}


sb4 mnSemWait(mnsem *sem)
{
  sb4    cnt;

  cnt = mneWait(mnGlbCtx, (ub4) 1, &sem, (ub4) 1);
  return (cnt > 0 ? sem->val : cnt);
}


sb4 mnSemOrW(ub4 timeout, ub4 nsem, mnsem **sem)
{
  if (!timeout)
    return mneWait(mnGlbCtx, nsem, sem, (ub4) 1);
  else
    return mneSemWait(mnGlbCtx, timeout, nsem, sem, (ub4) 1);
}


sb4 mnSemAndW(ub4 timeout, ub4 nsem, mnsem **sem)
{
  if (!timeout)
    return mneWait(mnGlbCtx, nsem, sem, nsem);
  else
    return mneSemWait(mnGlbCtx, timeout, nsem, sem, nsem);
}


sb4 mnTimer(ub4 timeout, mnHandler handler, dvoid *usrp)
{
  mnctx *ctx;
  mnsem *sem;
  sb4    sts;

  ctx = mnGlbCtx;

  if (!timeout)
    timeout = 1;

  sem = mneMakeSem(ctx, handler, usrp);
  mneTimer(ctx, timeout, sem);
  mneUnlatch(ctx, sem);

  if (!handler && !usrp)
    {
      sts = mnSemWait(sem);
      mnSemFree(sem);
    }
  else
    sts = 0;

  return (sts == MNERR_TIMEOUT ? 0 : sts);
}


void mnSet(mnsem *sem, sb4 val)
{
  mneSet(mnGlbCtx, sem, val, FALSE);
}

void mnPostIntr(sb4 sts)
{
  mnctx  *ctx;

  ctx = mnGlbCtx;
  ctx->ectx->intrsts = sts;
  ysIntr(YS_EX_INTERRUPT);
}

void mnSetIntrHandler(mnHandler hndlr, dvoid *usrp)
{
  mnctx *ctx;

  ctx = mnGlbCtx;
  if (ctx->ectx->intrsem)
    mneSet(ctx, ctx->ectx->intrsem, MNSTS_TERMINATE, TRUE);

  ctx->ectx->intrsem = mneMakeSem(ctx, hndlr, usrp);
  ctx->ectx->intrsts = 0;

  ysSetIntr(mnIntrHndlr, (dvoid *) ctx);
}

STATICF void mnIntrHndlr(dvoid *usrp, CONST ysid *exid, dvoid *arg,
			 size_t argsz)
{
  mnctx  *ctx;
  mnectx *ectx;

  ctx = (mnctx *) usrp;
  ectx = ctx->ectx;
  if (ectx->intrsem)
    mneSet(ctx, ectx->intrsem, ectx->intrsts, TRUE);
  ectx->intrsem = (mnsem *) 0;
}
