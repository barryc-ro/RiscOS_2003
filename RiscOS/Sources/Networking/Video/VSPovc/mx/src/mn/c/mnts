/* mx/src/mn/mnts.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNI_ORACLE
#include <mni.h>
#endif


ub4 mntInAck(mnctx *ctx, mnnpkt *pkt, mnp *port)
{
  boolean eof;
  sb4     current, unseq, delta;
  ub4     diff, rrt;
  mnnpkt *tmp;
  ub1    *buf;
  mnnhdr *phdr;
  mntse  *se;

  
  if (smnModSub(pkt->seqid, port->fsseq) < 0 ||
      smnModSub(pkt->seqid, port->naseq) > 0)
    {
      mnPrint(MNLWARN, "need to reset receiver");
      
      if (port->unpkt)
        DISCARD mnoSendResetRcvr(ctx, pkt, port->unpkt->seqid);
      return 0;
    }

  
  if (!port->unpkt || smnModSub(pkt->seqid, port->unpkt->seqid) <= 0)
    {
      mnPrint(MNLWARN, "duplicate acknowlegement");
      mnmFree(ctx, (dvoid *) pkt);
      return 0;
    }

  
  eof = FALSE;
  current = (sb4) smnClock();
  while (port->unpkt && smnModSub(port->unpkt->seqid, pkt->seqid) < 0)
    {
      diff = (ub4) smnModSub(pkt->seqid, port->unpkt->seqid);

      if (diff >= port->unpkt->len - sizeof(mnnhdr))
	{
	  
	  tmp = port->unpkt;
	  port->unpkt = port->unpkt->next;

	  if (!port->unpkt)
	    port->lspkt = (mnnpkt *) 0;
	  if (tmp == port->nspkt)
	    port->nspkt = port->unpkt;

	  rrt = smnModSub(current, (sb4) tmp->stime);
	  eof = !(tmp->flags & MNNFLG_MTC);
	  mnmFree(ctx, (dvoid *) tmp);
	}
      else if (port->proto == MNPROTO_BLOB)
	{
	  
	  port->unpkt->len -= diff;
	  port->unpkt->seqid += (sb4) diff;
	  port->unpkt->flags &= ~MNNFLG_FST;

	  rrt = smnModSub(current, (sb4) port->unpkt->stime);
	}
      else
	{
	  
	  buf = ((ub1 *) &port->unpkt[1]) + port->unpkt->off;
	  port->unpkt->len -= diff;
	  port->unpkt->off += diff;
	  port->unpkt->seqid += (sb4) diff;
	  port->unpkt->flags &= ~MNNFLG_FST;

	  phdr = (mnnhdr *) (buf + diff);
	  DISCARD memmove((dvoid *) phdr, (dvoid *) buf, sizeof(mnnhdr));
	  

	  rrt = smnModSub(current, (sb4) port->unpkt->stime);
	}
    }

  
  unseq = (port->unpkt ? port->unpkt->seqid : port->naseq);
  while (port->se.head)
    {
      se = (mntse *) port->se.head;
      if (mneGet(ctx, se->sem) != MNSTS_UNKNOWN)
	{
	  mnqDeq(&port->se);
	  mneUnlatch(ctx, se->sem);
	  mnmFree(ctx, (dvoid *) se);
	}
      else if (smnModSub(unseq, se->seqid) >= 0)
	{
	  mnqDeq(&port->se);
	  mneSet(ctx, se->sem, (sb4) se->cnt, TRUE);
	  mnmFree(ctx, (dvoid *) se);
	}
      else
	break;
    }

  
  if (port->sstate == MNSTS_XMIT)
    {
      
      if (!port->srt)
	port->srt = rrt << 3;                          

      delta = (sb4) rrt - (sb4) (port->srt >> 3);       
      port->srt += (ub4) delta;                       

      if (delta < 0)
	delta -= delta;
      port->rtde += delta - (port->rtde >> 2);   

      port->rexmt = (port->srt >> 3) + port->rtde;    
      port->rexmt = max(port->rexmt, MNTMINREXMT);

      
      port->swind = min(ctx->mwind, port->swind << 1);
    }
  else if (port->sstate == MNSTS_REXMIT)
    {
      

      
      port->nspkt = port->unpkt;
      if (port->unpkt)
	port->swind = port->unpkt->len;
    }

  
  if (pkt->flags == MNNFLG_CLS)
    port->sstate = MNSTS_PERSIST;

  if (eof)
    {
      if (port->proto == MNPROTO_STREAM || port->proto == MNPROTO_BLOB)
	port->rstate = MNSTS_TIMEWAIT;

      mnPrint(MNLINFO, "end-of-stream:srt=%ld ms, rtde=%ld.%02d ms",
	      port->srt >> 3, port->rtde >> 2, (port->rtde & 0x3) * 25);
    }

  if (!port->unpkt)
    {
      port->sstate = MNSTS_IDLE;
      port->pscnt = 0;
      if (port->rstate == MNSTS_TIMEWAIT)
	mntCleanSetup(ctx, port, MNTPRTLIFE + 10000);
    }
  else if (pkt->flags == MNNFLG_CLS)
    {
      port->sstate = MNSTS_PERSIST;
      port->pscnt = 1;
    }
  else
    {
      port->sstate = MNSTS_XMIT;
      port->pscnt = 0;
      mnePost(ctx, mntXmit, (dvoid *) port, (sb4) 0);
    }

  port->rxcnt = 0;
  mnmFree(ctx, (dvoid *) pkt);
  return 0;
}


void mntXmit(dvoid *pp,  sb4 val)
{
  mnctx *ctx;
  mnp   *port;
  sb4    sts;

  ctx = mnGlbCtx;
  port = (mnp *) pp;

  if ((port->sstate != MNSTS_IDLE && port->sstate != MNSTS_XMIT) ||
      (port->sstate == MNSTS_IDLE && !port->nspkt) ||
      port->proto == MNPROTO_BLOB)
    return;

  port->sstate = MNSTS_XMIT;

  while (port->nspkt &&
	 smnModSub(port->nspkt->seqid, port->unpkt->seqid) < (sb4) port->swind)
    {
      port->nspkt->stime = smnClock();
      sts = mnnSendPkt(ctx, port->nspkt);
      if (sts >= 0)
	port->nspkt = port->nspkt->next;
    }

  if (!port->rxsem)
    {
      port->rxsem = mnSemAlloc((dvoid *) port);
      mneSemSetHandler(ctx, port->rxsem, mntRexmit, FALSE);
      mneTimer(ctx, port->rexmt, port->rxsem);
    }
}


void mntRexmit(dvoid *pp,  sb4 val)
{
  mnctx *ctx;
  mnp   *port;
  sb4    current;
  ub4    diff, tm;

  ctx = mnGlbCtx;
  port = (mnp *) pp;

  if (port->rxsem)
    mnSemFree(port->rxsem);
  port->rxsem = (mnsem *) 0;

  if (port->sstate == MNSTS_IDLE || port->sstate < 0)
    return;

  
  current = (sb4) smnClock();
  diff = smnModSub(current, (sb4) port->unpkt->stime);
  if (port->sstate == MNSTS_XMIT && diff > port->rexmt)
    port->sstate = MNSTS_REXMIT;

  switch (port->sstate)
    {
    case MNSTS_XMIT:
      tm = port->rexmt - diff;
      break;
    case MNSTS_REXMIT:
      port->rxcnt++;
      if (port->rxcnt == MNTMAXRXCNT)
	{
	  mntAbort(ctx, port, MNERR_BROKEN);
	  return;
	}

      mnPrint(MNLWARN, "Retransmission %d", port->rxcnt);

      port->unpkt->stime = (ub4) current;

      if (port->proto != MNPROTO_BLOB)
	DISCARD mnnSendPkt(ctx, port->unpkt);
      else
	mnBlobRexmt(ctx, port);

      tm = min(port->rexmt << port->rxcnt, MNTMAXREXMT);
      break;
    case MNSTS_PERSIST:
      tm = smnModSub(port->rexmt << port->pscnt, current);
      if (tm <= 0)
	{
	  mnPrint(MNLWARN, "Persisting");
	  port->pscnt++;
	  port->unpkt->stime = (ub4) current;

	  if (port->proto != MNPROTO_BLOB)
	    DISCARD mnnSendPkt(ctx, port->unpkt);
	  else
	    mnBlobRexmt(ctx, port);

	  port->sstate = MNSTS_REXMIT;
	  tm = min(port->rexmt << port->pscnt, MNTMAXREXMT);
	}
      break;
    default:
      mnPrint(MNLERROR, "unexpected rexmit state: %ld", port->sstate);
      break;
    }

  port->rxsem = mnSemAlloc((dvoid *) port);
  mneSemSetHandler(ctx, port->rxsem, mntRexmit, FALSE);
  mneTimer(ctx, tm, port->rxsem);
}


sb4 mntSend(mnctx *ctx, mnp *port, ub1 *hbuf, size_t hlen,
	    mnbv *bv, ub4 nbv, boolean fst, boolean eof, mnsem *sem)
{
  mntse  *se;
  ub4     totlen, i, msglen, netlen, len;
  sb4     cnt, sts, origstate;
  ub1     mark, *buf;
  boolean sendeof, sendmsg;

  
  totlen = hlen;
  for (i = 0; i < nbv; i++)
    totlen += bv[i].len;

  msglen = totlen;

  if (eof)
    totlen++;

  
  if (port->proto == MNPROTO_MESSAGE)
    {
      totlen += sizeof(ub4);
      netlen = smnHton4(msglen);
      sendmsg = TRUE;
    }
  else
    sendmsg = FALSE;

  
  origstate = port->sstate;
  msglen = len = 0;
  sendeof = FALSE;
  while (port->sstate > 0 && (sendmsg || hlen || nbv || eof))
    {
      if (!len)
	{
	  if (sendmsg)                                
	    {
	      buf = (ub1 *) &netlen;
	      len = sizeof(ub4);
	      sendmsg = FALSE;
	    }
	  else if (hlen)                                      
	    {
	      buf = hbuf;
	      len = hlen;
	      hlen = 0;
	      msglen += len;
	    }
	  else if (nbv)                                
	    {
	      buf = bv->buf;
	      len = bv->len;
	      nbv--, bv++;
	      msglen += len;
	    }
	  else if (eof)                           
	    {
	      buf = &mark;
	      len = 1;
	      eof = FALSE;
	      sendeof = TRUE;
	    }
	}

      cnt = mntSendFill(ctx, port, buf, (size_t) len, totlen, fst, sendeof);

      
      if (cnt)
	{
	  
	  totlen -= (ub4) cnt;
	  buf += cnt;
	  len -= (ub4) cnt;
	  fst = sendeof = FALSE;
	}
      else if ((port->flags & MNOPT_NONBLOCK) &&
	       port->proto != MNPROTO_MESSAGE)
	goto senddata;
      else
	{
	  
	  sts = mnmWait(ctx, MNM_SENDPOOL);
	  if (sts || port->sstate < 0)
	    goto senddata;
	}
    }

 senddata:
  if (sem)
    {
      se = (mntse *) mnmAlloc(ctx, MNM_MAINPOOL, sizeof(mntse));

      se->sem = sem;
      se->seqid = port->naseq;
      se->cnt = msglen - len;
      mnqEnq(&port->se, se);
    }

  if (port->sstate < 0)
    mntAbort(ctx, port, port->sstate);
  else if (origstate != MNSTS_XMIT)
    {
      mnePost(ctx, mntXmit, (dvoid *) port, (sb4) 0);
      if ((port->flags & MNOPT_NONBLOCK) == 0)
	DISCARD mnIdle();
    }

  return (sb4) (msglen - len);
}


sb4 mntSendFill(mnctx *ctx, mnp *port, ub1 *buf, size_t len,
		ub4 totlen, boolean first, boolean eof)
{
  ub4     cnt, tail, xlen;
  ub1    *dstbuf;
  mnnpkt *pkt;

  cnt = 0;
  while (len && port->sstate > 0)
    {
      pkt = port->lspkt;
      if (!pkt || (pkt->len + pkt->off) == pkt->max)
	{
	  if (mntAppendPkt(ctx, port, totlen, first))
	    return (sb4) cnt;
	  else
	    pkt = port->lspkt;

	  first = FALSE;
	}
      else if (!port->nspkt)
	port->nspkt = pkt;

      tail = pkt->off + pkt->len;
      xlen = min(pkt->max - tail, len);
      dstbuf = ((ub1 *) &pkt[1]) + tail;
      DISCARD memcpy(dstbuf, buf, (size_t) xlen);

      pkt->len += xlen;
      cnt += xlen;
      buf += xlen;
      totlen -= xlen;
      len -= (size_t) xlen;
      port->naseq += (sb4) xlen;

      if (eof)
	pkt->flags &= ~MNNFLG_MTC;

#ifdef NEVER
      if (len && (pkt->len == pkt->max))
	{
	  mnePost(ctx, mntXmit, (dvoid *) port, (sb4) 0);
	  DISCARD mnIdle();
	}
#endif
    }

  return (sb4) cnt;
}


sb4 mntAppendPkt(mnctx *ctx, mnp *port, ub4 totlen, boolean first)
{
  mnnpkt *pkt;
  mnnhdr *phdr;
  ub4     maxlen, plen;

  maxlen = port->rte->nio->pktmax;

  if (port->proto == MNPROTO_STREAM)
    plen = maxlen + sizeof(mnnpkt);
  else
    plen = min(maxlen, totlen + sizeof(mnnhdr)) + sizeof(mnnpkt);

  if (mnmPoolLowwtr(ctx, MNM_SENDPOOL) ||
      !(pkt = (mnnpkt *) mnmAlloc(ctx, MNM_SENDPOOL, (size_t) plen)))
    return MNERR_OUTMEM;

  
  pkt->len = sizeof(mnnhdr);
  pkt->off = 0;
  pkt->flags = MNNFLG_TL | MNNFLG_MTC;
  pkt->seqid = port->naseq;
  pkt->max = plen - sizeof(mnnpkt);
  pkt->nio = port->rte->nio;
  CPSTRUCT(pkt->pa, port->rte->pa);
  pkt->stime = smnClock();

  if (first)
    pkt->flags |= MNNFLG_FST | MNNFLG_PRI;

  phdr = (mnnhdr *) &pkt[1];
  phdr->proto = (ub1) port->proto;
  mnaCopy(&phdr->src, &port->me);
  mnaCopy(&phdr->dst, &port->peer);

  
  pkt->next = (mnnpkt *) 0;
  if (port->lspkt)
    port->lspkt->next = pkt;
  else
    port->unpkt = pkt;

  if (!port->nspkt)
    port->nspkt = pkt;

  port->lspkt = pkt;

  return 0;
}


void mntAbort(mnctx *ctx, mnp *port, sb4 sts)
{
  boolean eof, destroy;
  mnnpkt *tmp;
  mntse  *se;

  mnPrint(MNLWARN, "aborting connection %ld", sts);
  destroy = FALSE;

  if (port->rxsem)
    mnSemFree(port->rxsem);
  port->rxsem = (mnsem *) 0;

  
  eof = FALSE;
  while (port->unpkt)
    {
      tmp = port->unpkt;
      port->unpkt = port->unpkt->next;
      mnmFree(ctx, (dvoid *) tmp);
    }

  port->nspkt = port->lspkt = (mnnpkt *) 0;

  
  while (se = (mntse *) mnqDeq(&port->se))
    {
      if (mneGet(ctx, se->sem) == MNSTS_UNKNOWN)
	mneSet(ctx, se->sem, sts, TRUE);
      else
	mneUnlatch(ctx, se->sem);

      mnmFree(ctx, (dvoid *) se);
    }

  port->sstate = sts;

  
  switch (port->rstate)
    {
    case MNSTS_ESTABLISHED:
      port->rstate =
	(port->proto == MNPROTO_MESSAGE ? MNSTS_TIMEWAIT : MNSTS_DISCONNECT);
      break;
    case MNSTS_FINISH:
      port->sstate = MNSTS_IDLE;
      port->rstate = MNSTS_TIMEWAIT;
      destroy = TRUE;
      break;
    case MNSTS_DISCONNECT:
      break;
    }

  mntRecvDisc(ctx, port);

  if (port->proto == MNPROTO_MESSAGE && port->rstate == MNSTS_TIMEWAIT)
    destroy = TRUE;

  if (destroy)
    mntDestroyPort(ctx, port);
}


sb4 mnSend(mnp *port, mna *to, ub1 *buf, size_t len,
	   mnHandler handler, dvoid *usrp)
{
  return mnSendHeader(port, to, buf, len, (mnbv *) 0, (ub4) 0, handler, usrp);
}


sb4 mnSendV(mnp *port, mna *to, mnbv *bv, ub4 nbv,
	    mnHandler handler, dvoid *usrp)
{
  return mnSendHeader(port, to, (ub1 *) 0, 0, bv, nbv, handler, usrp);
}


sb4 mnSendHeader(mnp *port, mna *to, ub1 *buf, size_t len,
		 mnbv *bv, ub4 nbv, mnHandler handler, dvoid *usrp)
{
  mnctx *ctx;
  mnp   *cport;
  mnsem *sem;
  sb4    sts;
  mnrte *rte;

  DISCARD mnIdle();

  if (port->proto != MNPROTO_MESSAGE)
    return MNERR_BADPROTO;

  ctx = mnGlbCtx;

  cport = mntFindPort(ctx, &port->me, to);
  if (!cport)
    {
      rte = mnaFindRoute(ctx, to);
      if (!rte)
	return MNERR_BADADDR;

      cport = mntCreatePort(ctx, port, to, rte);
    }

  sem = mneMakeSem(ctx, handler, usrp);

  if (cport->sstate < 0)
    {
      mneSet(ctx, sem, cport->sstate, TRUE);
      sts = 0;
    }
  else
    {
      sts = mntSend(ctx, cport, buf, len, bv, nbv, TRUE, TRUE, sem);
      if (sts > 0)
	sts = 0;
    }

  if (!handler && !usrp)
    {
      if (!sts)
	sts = mnSemWait(sem);
      mnSemFree(sem);
    }

  return sts;
}


sb4 mnWrite(mnp *port, ub1 *buf, size_t len)
{
  mnctx  *ctx;
  boolean fst;

  ctx = mnGlbCtx;

  if (port->proto != MNPROTO_STREAM)
    return MNERR_BADPROTO;

  if (port->rstate != MNSTS_CONNECT && port->rstate != MNSTS_ESTABLISHED)
    return (port->sstate < 0 ? port->sstate : MNERR_DISCONN);

  if (port->rstate == MNSTS_CONNECT)
    {
      fst = TRUE;
      port->rstate = MNSTS_ESTABLISHED;
    }
  else
    fst = FALSE;

  return mntSend(ctx, port, buf, len, (mnbv *) 0, (ub4) 0, fst,
		 FALSE, (mnsem *) 0);
}


sb4 mnConnect(mnp *port, mna *to)
{
  mnctx *ctx;
  ub2    prtno;
  mna    addr;

  ctx = mnGlbCtx;

  if (port->proto != MNPROTO_STREAM)
    return MNERR_BADPARAM;

  if (port->rstate != MNSTS_CLOSED)
    return MNERR_ALREADY;

  if (!(port->rte = mnaFindRoute(ctx, to)))
    return MNERR_BADADDR;
  else
    port->rte->refcnt++;

  mntRemovePort(ctx, port);

  mnaCopy(&port->peer, to);
  if (!mnaWellKnown(&port->me))
    {
      prtno = mnaPortNum(&port->me);
      mnnSubnet(port->rte->nio, &addr);
      mnaNetCopy(&port->me, &addr);
      mnaSetPortNum(&port->me, prtno);
    }

  mntInsertPort(ctx, port);

  port->rstate = MNSTS_CONNECT;
  return 0;
}
