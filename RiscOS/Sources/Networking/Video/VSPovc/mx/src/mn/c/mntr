/* mx/src/mn/mntr.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNI_ORACLE
#include <mni.h>
#endif


ub4 mntInOpen(mnctx *ctx, mnnpkt *pkt, mnp *port)
{
  mnnhdr *phdr;
  mnp    *cport;
  mna     claddr;
  mnrte  *rte;

  phdr = (mnnhdr *) &pkt[1];

  
  if (port->rstate == MNSTS_TIMEWAIT)
    {
      if (port->proto == MNPROTO_STREAM)
	{
	  mnPrint(MNLWARN, "packet dropped after close; seq=%08x", pkt->seqid);
	  if (!port->ackpend)
	    {
	      mnePost(ctx, mntSendAck, (dvoid *) port, (sb4) 0);
	      port->ackpend = TRUE;
	    }
	  mnmFree(ctx, (dvoid *) pkt);
	  return 0;
	}
      else
	{
	  cport = port;
	  mnaClear(&claddr);
	  port = mntFindPort(ctx, &phdr->dst, &claddr);

	  if (!port)
	    return MNOTYP_DESTNOTREACH;
	}
    }
  else if (!(pkt->flags & MNNFLG_FST))
    {
      
      mnPrint(MNLWARN, "packet dropped; not FST packet; seq=%08x", pkt->seqid);
      mnmFree(ctx, (dvoid *) pkt);
      return 0;
    }
  else if (port->rstate == MNSTS_LISTEN)
    {
      
      rte = mnaFindRoute(ctx, &phdr->src);
      if (!rte)
	{
	  mnPrint(MNLWARN, "packet dropped; source not reachable", pkt->seqid);
	  return 0;
	}

      cport = mntCreatePort(ctx, port, &phdr->src, rte);
      cport->nrseq = pkt->seqid;
      cport->fsseq = cport->naseq = ctx->iss;
      ctx->iss -= 65533;
    }
  else 
    {
      cport = port;
      cport->nrseq = pkt->seqid;
      cport->naseq = cport->fsseq = ctx->iss;
      ctx->iss -= 65533;
      port = (mnp *) 0;
    }

  cport->rstate = MNSTS_ESTABLISHED;
  if (cport->proto == MNPROTO_MESSAGE)
    mntCleanSetup(ctx, cport, MNTRCVLIFE);

  
  mntInData(ctx, pkt, cport);

  
  if (!cport->rs)
    cport->rstate = MNSTS_TIMEWAIT;
  else
    {
      
      if (port &&
	  ((port->proto == MNPROTO_STREAM) || (cport->nrseq - pkt->seqid > 0)))
	{
	  mnqEnq(&port->accepts, cport);
	  mntRecvAccept(ctx, port);
	}
      else if (port)
	cport->rstate = MNSTS_TIMEWAIT;
    }

  return 0;
}


void mntInData(mnctx *ctx, mnnpkt *pkt, mnp *port)
{
  mnnhdr *phdr;
  sb4     diff, seqid;
  mnnpkt *prev, *seg;
  boolean eof;

  phdr = (mnnhdr *) &pkt[1];

  pkt->off += sizeof(mnnhdr);
  pkt->len -= sizeof(mnnhdr);

  if (!port->everrcv)
    {
      if (!(pkt->flags & MNNFLG_FST))
	{
	  mnmFree(ctx, (dvoid *) pkt);
	  return;
	}
      else
	{
	  port->nrseq = pkt->seqid;
	  port->everrcv = TRUE;
	}
    }

  
  if (smnModSub(pkt->seqid, port->nrseq) >
      (sb4) (mnmPoolSpace(ctx, MNM_RECVPOOL) >> 1))
    {
      mnPrint(MNLWARN, "packet dropped; outside window");
      mnmFree(ctx, (dvoid *) pkt);
      goto leave;
    }

  
  diff = smnModSub(port->nrseq, pkt->seqid);
  if (diff > 0)
    goto duplicate;
#ifdef NEVER
  if (diff >= (sb4) pkt->len)
    goto duplicate;
  else if (diff > 0)
    {
      mnPrint(MNLWARN, "unusual packet; partial tail");
      pkt->seqid += diff;
      pkt->off += (ub4) diff;
      pkt->len -= (ub4) diff;
    }
#endif

  
 insert:
  for (prev = (mnnpkt *) 0, seg = (port->ls ? port->ls : port->rs);
       seg && smnModSub(seg->seqid, pkt->seqid) + (sb4) seg->len <= 0;
       prev = seg, seg = seg->next) ;

  if (!seg)
    {
      
      pkt->next = (mnnpkt *) 0;

      if (pkt->seqid != port->nrseq)
	mnPrint(MNLWARN, "continuity lost; seq=%08x", pkt->seqid);
    }
  else
    {
      
      pkt->next = seg;
      if (smnModSub(pkt->seqid, seg->seqid) < 0)
	{
	  pkt->len = min(smnModSub(seg->seqid, pkt->seqid), (sb4) pkt->len);
	  if (!pkt->len)
	    goto duplicate;
	  else
	    mnPrint(MNLWARN, "unusual packet; partial head");
	}
      else
	{
	  mnPrint(MNLWARN, "unusual packet; embedded");

	  
	  pkt->off =
	    (ub4) (smnModSub(seg->seqid, pkt->seqid) + (sb4) seg->len);
	  pkt->seqid += smnModSub(seg->seqid, pkt->seqid) + (sb4) seg->len;

	  if (pkt->off < pkt->len)
	    goto insert;
	  else
	    goto duplicate;
	}
    }

  if (!prev)
    {
      port->rs = pkt;
      if (pkt->seqid == port->nrseq)
	port->ls = pkt;
    }
  else
    prev->next = pkt;

  port->rtime = (sb4) smnClock();

  if (!port->ls)
    goto leave;

  
  for (eof = FALSE, prev = seg = port->ls, seqid = seg->seqid;
       seg && seqid == seg->seqid;
       prev = seg, seqid = seg->seqid + (sb4) seg->len, seg = seg->next)
    if (!(seg->flags & MNNFLG_MTC))
      eof = TRUE;

  
  if (smnModSub(seqid, port->nrseq) > 0)
    {
      port->nrseq = seqid;
      port->ls = prev;

      if (port->rstate == MNSTS_FINISH)
	mntRecvDisc(ctx, port);
      else if (port->rstate == MNSTS_ESTABLISHED ||
	       port->rstate == MNSTS_DISCONNECT)
	{
	  if (eof)
	    port->rstate = MNSTS_DISCONNECT;

	  mntRecvData(ctx, port);
	}
      else
	mnPrint(MNLERROR, "unexpected state %ld", port->rstate);
    }

 leave:
  if (!port->ackpend)
    {
      mnePost(ctx, mntSendAck, (dvoid *) port, (sb4) 0);
      port->ackpend = TRUE;
    }
  return;

 duplicate:
  mnPrint(MNLWARN, "packet dropped; duplicate; seq=%08x", pkt->seqid);
  mnmFree(ctx, (dvoid *) pkt);
  goto leave;
}


void mntSendAck(dvoid *pp,  sb4 val)
{
  mnctx  *ctx;
  mnp    *port;
  mnnpkt *pkt;
  mnnhdr *phdr;

  ctx = mnGlbCtx;

  port = (mnp *) pp;
  port->ackpend = FALSE;

  pkt = (mnnpkt *) mnmAlloc(ctx, MNM_SENDPOOL,
			    sizeof(mnnpkt) + sizeof(mnnhdr));
  if (!pkt)
    return;

  
  pkt->len = sizeof(mnnhdr);
  pkt->off = 0;
  pkt->flags = MNNFLG_ACK | MNNFLG_PRI |
    (mnmPoolLowwtr(ctx, MNM_RECVPOOL) ? MNNFLG_CLS : 0);
  pkt->seqid = port->nrseq;
  pkt->nio = port->rte->nio;
  CPSTRUCT(pkt->pa, port->rte->pa);

  
  phdr = (mnnhdr *) &pkt[1];
  phdr->proto = (ub1) port->proto;
  mnaCopy(&phdr->src, &port->me);
  mnaCopy(&phdr->dst, &port->peer);

  
  DISCARD mnnSendPkt(ctx, pkt);
}


void mntRecvAccept(mnctx *ctx, mnp *port)
{
  mntre *re;
  ub4    cnt, msglen;
  mnp   *scp, *cport;
  ub1   *srcbuf;
  char   out[MNAMAXLEN];

  while (port->re.head && port->accepts.head)
    {
      
      cport = (mnp *) port->accepts.head;
      if (cport->sstate < 0)
	{
	  mnAtos(&cport->peer, out, MNAMAXLEN);
	  mnPrint(MNLWARN, "unable to accept: from=%s", out);
	  mnqDeq(&port->accepts);
	  continue;
	}

      
      if (!cport->rs)
	{
	  mnAtos(&cport->peer, out, MNAMAXLEN);
	  mnPrint(MNLWARN, "accept with discarded packets: from=%s", out);
	  cport->rstate = MNSTS_TIMEWAIT;
	  mnqDeq(&port->accepts);
	  continue;
	}

      
      re = (mntre *) mnqDeq(&port->re);

      
      if (mneGet(ctx, re->sem) != MNSTS_UNKNOWN)
	{
	  mneUnlatch(ctx, re->sem);
	  if (re->origbv)
	    mnmFree(ctx, (dvoid *) re->origbv);
	  mnmFree(ctx, (dvoid *) re);
	  continue;
	}

      if (port->proto == MNPROTO_STREAM)
	{
	  
	  for (cnt = 0, scp = (mnp *) port->accepts.head; scp;
	       cnt++, scp = scp->next) ;
	  mneSet(ctx, re->sem, (sb4) cnt, TRUE);
	  mnmFree(ctx, (dvoid *) re);
	}
      else  
	{
	  
	  cport = (mnp *) port->accepts.head;
	  srcbuf = ((ub1 *) &cport->rs[1]) + cport->rs->off;
	  msglen = smnNtoh4(*((ub4 *) srcbuf));

	  if (re->from)
	    mnaCopy(re->from, &cport->peer);

	  if (re->origbv)
	    {
	      
	      cport->rs->len -= sizeof(ub4);
	      cport->rs->off += sizeof(ub4);
	      cport->rs->seqid += sizeof(ub4);

	      mnqDeq(&port->accepts);
	      mnqEnq(&cport->re, re);
	      mntRecvData(ctx, cport);
	    }
	  else
	    {
	      
	      mneSet(ctx, re->sem, (sb4) msglen, TRUE);
	      mnmFree(ctx, (dvoid *) re);
	    }
	}
    }
}


void mntRecvDisc(mnctx *ctx, mnp *port)
{
  boolean eof;
  mnnpkt *tmp;
  sb4     sts;
  mntre  *re;
  mnp    *cport;
  mna     claddr;

  
  eof = FALSE;
  while (!eof && port->ls)
    {
      eof = !(port->rs->flags & MNNFLG_MTC);
      tmp = port->rs;
      port->rs = tmp->next;
      if (tmp == port->ls)
	port->ls = (mnnpkt *) 0;
      mnmFree(ctx, (dvoid *) tmp);
    }

  
  sts = (port->sstate < 0 ? port->sstate : MNERR_DISCONN);
  while (re = (mntre *) mnqDeq(&port->re))
    {
      if (mneGet(ctx, re->sem) == MNSTS_UNKNOWN)
	mneSet(ctx, re->sem, sts, TRUE);
      else
	mneUnlatch(ctx, re->sem);

      if (re->origbv)
	mnmFree(ctx, (dvoid *) re->origbv);
      mnmFree(ctx, (dvoid *) re);
    }

  
  if (eof)
    {
      port->rstate = MNSTS_TIMEWAIT;

      
      if (port->ls)
	{
	  cport = port;
	  mnaClear(&claddr);
	  port = mntFindPort(ctx, &cport->me, &claddr);

	  if (!port)
	    DISCARD mnoSend(ctx, MNOTYP_DESTNOTREACH,
			    &cport->peer, &cport->me);
	  else
	    {
	      cport->rstate = MNSTS_ESTABLISHED;
	      if (port->proto == MNPROTO_MESSAGE)
		mntCleanSetup(ctx, port, MNTRCVLIFE);
	      mnqEnq(&port->accepts, cport);
	      mntRecvAccept(ctx, port);
	    }
	}
      else if (port->sstate == MNSTS_IDLE)
	mntCleanSetup(ctx, port, MNTPRTLIFE - 10000);
    }
}


void mntRecvData(mnctx *ctx, mnp *port)
{
  mntre  *re;
  boolean freere;

  while (port->re.head && (port->ls || port->sstate < 0))
    {
      re = (mntre *) port->re.head;

      
      if (mneGet(ctx, re->sem) == MNSTS_UNKNOWN)
	{
	  if (port->ls)
	    freere = mntRecvFill(ctx, port, re);
	  else
	    {
	      mneSet(ctx, re->sem, port->sstate, TRUE);
	      freere = TRUE;
	    }
	}
      else
	{
	  mneUnlatch(ctx, re->sem);
	  freere = TRUE;
	}

      
      if (freere)
	{
	  mnqDeq(&port->re);
	  mnmFree(ctx, (dvoid *) re->origbv);
	  mnmFree(ctx, (dvoid *) re);

	  
	  if (port->proto == MNPROTO_MESSAGE)
	    {
	      if (port->rstate == MNSTS_ESTABLISHED)
		port->rstate = MNSTS_FINISH;
	      if (port->sstate == MNSTS_IDLE)
		mntCleanSetup(ctx, port, MNTRCVLIFE);
	      mntRecvDisc(ctx, port);
	    }
	}
    }
}


boolean mntRecvFill(mnctx *ctx, mnp *port, mntre *re)
{
  ub1    *srcbuf;
  boolean eof;
  ub4     xlen;
  mnnpkt *tmp;

  
  while (port->ls)
    {
      if (port->rs->len)
	{
	  xlen = min(port->rs->len, re->cbv->len);

	  
	  if (xlen == port->rs->len)
	    {
	      if (eof = !(port->rs->flags & MNNFLG_MTC))
		xlen--;
	    }
	  else
	    eof = FALSE;

	  
	  srcbuf = ((ub1 *) &port->rs[1]) + port->rs->off;
	  DISCARD memcpy(re->cbv->buf, srcbuf, (size_t) xlen);

	  
	  re->cbv->buf += xlen;
	  re->cbv->len -= (size_t) xlen;
	  re->cnt += xlen;
	  port->rs->len -= xlen;
	  port->rs->off += xlen;
	  port->rs->seqid += (sb4) xlen;
	}
      else
	eof = FALSE;

      
      if (!port->rs->len)
	{
	  tmp = port->rs;
	  port->rs = tmp->next;
	  if (tmp == port->ls)
	    port->ls = (mnnpkt *) 0;
	  mnmFree(ctx, (dvoid *) tmp);
	}

      
      if (!re->cbv->len)
	re->cbv++, re->nbv--;

      
      if (!re->nbv || eof)
	{
	  mneSet(ctx, re->sem,
		 (!re->cnt && eof ? MNSTS_EOS : (sb4) re->cnt), TRUE);
	  return TRUE;
	}
    }

  
  if (!re->fill)
    {
      mneSet(ctx, re->sem, (sb4) re->cnt, TRUE);
      return TRUE;
    }
  else
    return FALSE;
}


sb4 mntRecv(mnp *port, mna *from, mnbv *bv, ub4 nbv,
	    ub4 timeout, mnHandler handler, dvoid *usrp, boolean fill)
{
  mnctx *ctx;
  mnbv  *bvp;
  mntre *re;
  mnsem *sem;
  sb4    sts;

  ctx = mnGlbCtx;

  
  if (!handler && !usrp && (port->flags & MNOPT_NONBLOCK))
    {
      if ((port->rstate == MNSTS_LISTEN && !port->accepts.head) ||
	  (port->rstate != MNSTS_LISTEN && !port->ls))
	return MNERR_WOULDBLOCK;
    }

  re = (mntre *) mnmAlloc(ctx, MNM_MAINPOOL, sizeof(mntre));
  sem = mneMakeSem(ctx, handler, usrp);

  if (bv)
    {
      bvp = (mnbv *) mnmAlloc(ctx, MNM_MAINPOOL,
			      (size_t) (sizeof(mnbv) * nbv));
      DISCARD memcpy(bvp, bv, (size_t) (sizeof(mnbv) * nbv));
    }
  else
    bvp = (mnbv *) 0;

  if (timeout)
    mneTimer(ctx, timeout, sem);

  
  re->from = from;
  re->sem = sem;
  re->origbv = re->cbv = bvp;
  re->nbv = nbv;
  re->cnt = 0;
  re->fill = fill;

  mnqEnq(&port->re, re);

  if (port->rstate == MNSTS_LISTEN)
    mntRecvAccept(ctx, port);
  else
    mntRecvData(ctx, port);

  if (!handler && !usrp)
    {
      sts = mnSemWait(sem);
      mnSemFree(sem);
    }
  else
    sts = 0;

  return sts;
}


sb4 mnRecv(mnp *port, mna *from, ub1 *buf, size_t len,
	   ub4 timeout, mnHandler handler, dvoid *usrp)
{
  mnbv   bv;

  if (port->proto != MNPROTO_MESSAGE)
    return MNERR_BADPROTO;

  DISCARD mnIdle();

  bv.len = len;
  bv.buf = buf;
  return mntRecv(port, from, &bv, (ub4) 1, timeout, handler, usrp, TRUE);
}


sb4 mnRecvV(mnp *port, mna *from, mnbv *bv, ub4 nbv,
	    ub4 timeout, mnHandler handler, dvoid *usrp)
{
  if (port->proto != MNPROTO_MESSAGE)
    return MNERR_BADPROTO;

  DISCARD mnIdle();

  return mntRecv(port, from, bv, nbv, timeout, handler, usrp, TRUE);
}


sb4 mnRecvTest(mnp *port, mna *from)
{
  if (port->proto != MNPROTO_MESSAGE)
    return MNERR_BADPROTO;

  DISCARD mnIdle();

  return mntinRecvTest(port, from);
}

sb4 mntinRecvTest(mnp *port, mna *from)
{
  mnp *cport;
  ub1 *srcbuf;
  ub4  msglen;

  if (cport = (mnp *) port->accepts.head)
    {
      srcbuf = ((ub1 *) &cport->rs[1]) + cport->rs->off;
      msglen = smnNtoh4(*((ub4 *) srcbuf));

      if (from)
	mnaCopy(from, &cport->peer);

      return (sb4) msglen;
    }
  else
    return 0;
}


sb4 mnListen(mnp *port, ub4 timeout, mnHandler handler, dvoid *usrp)
{
  DISCARD mnIdle();

  if (port->proto != MNPROTO_STREAM)
    return MNERR_BADPARAM;

  if (port->rstate != MNSTS_CLOSED && port->rstate != MNSTS_LISTEN)
    return MNERR_ALREADY;

  port->rstate = MNSTS_LISTEN;
  return mntRecv(port, (mna *) 0, (mnbv *) 0, (ub4) 0,
		 timeout, handler, usrp, FALSE);
}


mnp *mnAccept(mnp *port)
{
  mnp *cport;
  sb4  sts;

  if (port->proto != MNPROTO_STREAM)
    {
      mnSetLastError(mnGlbCtx, MNERR_BADPARAM);
      return (mnp *) 0;
    }

  if (port->rstate != MNSTS_CLOSED && port->rstate != MNSTS_LISTEN)
    {
      mnSetLastError(mnGlbCtx, MNERR_ALREADY);
      return (mnp *) 0;
    }

  DISCARD mnIdle();

  sts = 0;
  while (sts >= 0 && !(cport = (mnp *) mnqDeq(&port->accepts)))
    sts = mnListen(port, (ub4) 0, (mnHandler) 0, (dvoid *) 0);

  if (sts < 0)
    mnSetLastError(mnGlbCtx, sts);

  return cport;
}


sb4 mnRead(mnp *port, ub1 *buf, size_t len, boolean fill, 
	   ub4 timeout, mnHandler handler, dvoid *usrp)
{
  mnbv bv;

  DISCARD mnIdle();

  if (port->proto != MNPROTO_STREAM)
    return MNERR_BADPARAM;

  if (port->rstate == MNSTS_CLOSED || port->rstate == MNSTS_LISTEN ||
      port->rstate == MNSTS_FINISH || port->rstate == MNSTS_TIMEWAIT)
    return MNERR_NOTCONN;

  bv.len = len;
  bv.buf = buf;
  return mntRecv(port, (mna *) 0, &bv, (ub4) 1, timeout, handler, usrp, fill);
}
