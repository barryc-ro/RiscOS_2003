/* mx/src/mn/mnscsop.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef MTL_ORACLE
#include <mtl.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNI_ORACLE
#include <mni.h>
#endif
#ifndef MZN_ORACLE
#include <mzn.h>
#endif
#ifndef MNSCS_ORACLE
#include <mnscs.h>
#endif
#ifndef MZMGU_ORACLE
#include <mzmgu.h>
#endif
#ifndef MZMGU_ORACLE
#include <mzmgu.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif

#ifdef MNSCD_DEFINED
STATICF void mnsCheckCallsWaiting(mnsqent *CONST scq);
#endif
STATICF void mnsFillCall(mnsqent *scq);
STATICF sb4  mnsNewInstance(mna *from, mnsqent *scq, mnsient **newinstance);
STATICF void mnsInsInstance(mnsient *inst);
STATICF mnsient *mnsGetInstance(mna *from);
STATICF void mnsDelInstance(mnsient *inst);
STATICF void mnsDeathWatchInstHandler(void *usrp, sb4 val);


sb4 mnscRegister(mna *from, char *name, CONST mnrid *progid)
{
  mnscctx *scctx;
  mnsqent *scq;
  mnsient *inst;
  mznent   entry;
  sb4      sts;
  char     out[MNAMAXLEN];

  scctx = mnscGlbCtx;

  
  sts = mznFndEntry(name, progid, &entry);

  if (sts == MNERR_NOTFOUND)
    {
      
      if (sts = mnsNewQueue(name, progid, &scq))
	return sts;
    }
  else if (sts == 0)
    {
      ysmGlbFree(name);

      
      for (scq = scctx->queues; scq && !mnaEq(&entry.addr, &scq->caddr);
	   scq = scq->next) ;

      mnxFree(mznxEntry, (dvoid *) &entry);

      
      if (!scq)
	return MNERR_ALREADY;
      else if (scq->status == MNSC_STOP)
	return MNSTS_TERMINATE;
    }
  else
    return sts;

  
  if (sts = mnsNewInstance(from, scq, &inst))
    return sts;

  
  scq->regcur++;
  scq->regtot++;
  if (scq->regcur > scq->regmax)
    scq->regmax = scq->regcur;

  mnAtos(from, out, MNAMAXLEN);
  mtlLog("instance registered: name=%s, addr=%s", scq->name, out);

  return 0;
}

sb4 mnscGetNext(mna *from)
{
  mnsqent *scq;
  mnsient *inst;
  mnscctx *scctx = mnscGlbCtx;

  
  inst = mnsGetInstance(from);
  if (!inst)
    return MNERR_NOTFOUND;

  inst->cllget = smnClock();
  if (inst->clltot)
    inst->clldel =
      ((inst->clldel * (inst->clltot - 1)) + (inst->cllget - inst->cllfwd)) /
	inst->clltot;

  
  scctx->mibstats.InboundAssocs_mzmguSStats++;
  scctx->mibstats.TotInboundAssocs_mzmguSStats++;
  scctx->mibstats.LastInbound_mzmguSStats = mzmgsTimeStamp();

  scq = inst->queue;

  switch (inst->status)
    {
    case MNSC_REGISTER:
      inst->status = MNSC_CALLGET;
      break;
    case MNSC_CALLFWD:
      inst->status = MNSC_CALLGET;
      scq->cllcur--;
      break;
    case MNSC_CALLFWD_PAUSENEXT:
      inst->status = MNSC_PAUSE;
      scq->cllcur--;
      break;
    case MNSC_CALLGET:
    case MNSC_PAUSE:
      break;
    case MNSC_PAUSENEXT:
      inst->status = MNSC_PAUSE;
      break;
    case MNSC_STOPNEXT:
      return MNSTS_TERMINATE;
    }

  
  if (inst->status == MNSC_CALLGET)
    mnsFillCall(scq);

  
  scctx->mibstats.InboundAssocs_mzmguSStats--;
  scctx->mibstats.LastOutbound_mzmguSStats = mzmgsTimeStamp();

  return 0;
}

sb4 mnscUnregister(mna *from)
{
  mnsient *inst;

  
  inst = mnsGetInstance(from);
  if (inst)
    {
      mnsDelInstance(inst);
      return 0;
    }
  else
    return MNERR_NOTFOUND;
}

sb4 mnscPause(mna *addr, boolean pause)
{
  mnscctx *scctx;
  mnsient *inst;
  mnsqent *scq;

  scctx = mnscGlbCtx;

  inst = mnsGetInstance(addr);
  if (inst)
    {
      if (inst->status == MNSC_PAUSE || inst->status == MNSC_CALLGET)
	inst->status = (pause ? MNSC_PAUSE : MNSC_CALLGET);
      else if (inst->status == MNSC_CALLFWD)
        inst->status = (pause ? MNSC_CALLFWD_PAUSENEXT : MNSC_CALLGET);
      else if (inst->status != MNSC_STOPNEXT)
	inst->status = (pause ? MNSC_PAUSENEXT : MNSC_CALLGET);
      else
	return MNSTS_TERMINATE;

      scq = inst->queue;
    }
  else
    {
      for (scq = scctx->queues; scq && !mnaEq(&scq->caddr, addr);
	   scq = scq->next) ;

      if (!scq)
	return MNERR_NOTFOUND;

      if (scq->status != MNSC_STOP)
	{
	  scq->status = (pause ? MNSC_PAUSE : 0);

	  
	  for (inst = scq->instances; inst; inst = inst->next)
	    mnscPause(&inst->addr, pause);
	}
      else
	return MNSTS_TERMINATE;
    }

  if (!pause)
    mnsFillCall(scq);

  return 0;
}

sb4 mnscStop(mna *addr)
{
  mnscctx	*scctx;
  mnsient	*inst;
  mnsqent	*ps, *scq;
  ub4		 i;
  mnshinf	*prevhost;
  const char    *save_name;
  mnshinf	*save_hosts;
  mnrid		 save_progid;
  boolean	 daemon_exists;

  scctx = mnscGlbCtx;

  
  inst = mnsGetInstance(addr);
  if (inst)
    {
      
      if (inst->status == MNSC_CALLGET || inst->status == MNSC_PAUSE)
	{
	  inst->status = MNSC_STOPNEXT;
	  mnSend(inst->queue->iport, &inst->addr, (ub1 *) 0, 0, 0, 0);
	}
      else
	inst->status = MNSC_STOPNEXT;
    }
  else
    {
      
      for (ps = (mnsqent *) 0, scq = scctx->queues;
	   scq && !mnaEq(&scq->caddr, addr);
	   ps = scq, scq = scq->next) ;

      if (!scq)
	return MNERR_NOTFOUND;

      
      if (scq->status != MNSC_STOP)
	{
	  
	  mznDelEntry(scq->name, &scq->progid);

	  
	  mnClose(scq->cport);
	  for (i = 2; i < scctx->semcnt && mnSemGetUsrp(scctx->semset[i]) != scq; i++) ;
	  
	  if (i < scctx->semcnt)
	    {
	      mnSemFree(scctx->semset[i]);
	      scctx->semcnt--;
	      if (scctx->semcnt > 2)
		scctx->semset[i] = scctx->semset[scctx->semcnt];
	    }
	}

      scq->status = MNSC_STOP;

      
      if (scq->quecur)
	return 0;

      
      while (inst = scq->instances)
	{
	  while (inst && inst->status == MNSC_STOPNEXT)
	    inst = inst->next;

	  if (inst)
	    mnscStop(&inst->addr);
	  else
	    break;
	}

      
      if (!scq->regcur)
	{
	  
	  daemon_exists	= scq->flags & MNSC_DAEMON;
	  save_name	= scq->name;
	  save_hosts	= scq->hosts;
	  CPSTRUCT(save_progid, scq->progid);

	  
	  if (ps)
	    ps->next = scq->next;
	  else
	    scctx->queues = scq->next;
	  mnClose(scq->iport);
	  ysmGlbFree(scq);

	  
	  if (scctx->shutdown && !scctx->queues)
	    {
	      ysmGlbFree((char*) save_name);
	      while (save_hosts != (mnshinf *) NULL)
	        {
	          prevhost = save_hosts;
	          save_hosts = save_hosts->next;
	          ysmGlbFree(prevhost->hostname);
	          ysmGlbFree(prevhost);
	        }
	      mnrTermLoop(scctx->sh, MNSTS_NORMAL);
	      mnSet(scctx->semset[0], MNSTS_NORMAL);
	    }
	  else if (daemon_exists)
	    {
	      
	      mnsNewQueue(save_name, &save_progid, &scq);
	      scq->hosts = save_hosts;
	      scq->flags |= MNSC_DAEMON;
	    }
	}
    }
  return 0;
}

sb4 mnscQuery(mnxStream *stream, ub4 *clock)
{
  mnscctx *scctx;
  mnsqent *scq;
  ub4      cnt;
  sb4      sts;

  scctx = mnscGlbCtx;

  for (cnt = 0, scq = scctx->queues, sts = 0; scq && !sts;
       scq = scq->next, cnt++)
    sts = (*stream->push)(stream, (dvoid *) scq);

  (*stream->close)(stream, (sb4) 0);
  *clock = smnClock();
  return (sb4) cnt;
}

void mnscShutdown(void)
{
  mnscctx *scctx;
  mnsqent *scq;

  scctx = mnscGlbCtx;
  scctx->shutdown = TRUE;

  while (scq = scctx->queues)
    {
      while (scq && scq->status == MNSC_STOP)
	scq = scq->next;

      if (scq)
	mnscStop(&scq->caddr);
      else
	break;
    }
}

#ifdef MNSCD_DEFINED

STATICF void mnsStartServer(CONST char *CONST hostname, srvrinfo *CONST si)
{
  char	*regname;
  mnrb	*mnscdbh;
  sb4	 sts;

  
  mnscMakeHostRegName(hostname, MNSC_DAEMON_NAME, &regname);

  
  mnscdbh = mnrFindServer(regname, (mnrid *) 0);

  if (!mnscdbh)
    {
      mtlLog("ERROR: mnrFindServer in mnsStartServer failed for \"%s\": %s",
	     regname, mnError(mnLastError()));
      ysmGlbFree(regname);
      mnrFreeHandle(mnscdbh);
      return;
    }

  sts = mnscdStartServer(mnscdbh, si);

  ysmGlbFree(regname);
  mnrFreeHandle(mnscdbh);

  if (sts < 0) {
    mtlLog("ERROR: bad return from mnscdStartServer: %s", mnError(sts));
    return;
  }
}


STATICF boolean mnsCheckClock(mnsqent *CONST scq)
{
  ub4	curtime;

  curtime = smnClock(); 

  if ((curtime - scq->exectim) / 1000 < MNSEXECWAITTIME)
    return TRUE;
  else
    {
      scq->exectim = curtime;
      return FALSE;
    }
}


STATICF void mnsCheckCallsWaiting(mnsqent *CONST scq)
{
  mnshinf	*hi;
  mnshinf	*hi_low;
  ub2		 minval;
  srvrinfo	 si;

  if (scq->regcur != 0 && scq->quecur <= scq->qlenlim)
    return;			

  if (scq->hosts == NULL)
    return;			

  if (mnsCheckClock(scq))
    return;			

  

  
  minval = 30000; 
  hi_low = scq->hosts;
  for (hi = scq->hosts ; hi != NULL ; hi = hi->next)
    if (minval > hi->started)
      {
	minval = hi->started;
	hi_low = hi;
      }

  hi_low->started++;
  si.server = (char*) scq->name;
  CPSTRUCT(si.pid, scq->progid);

  mnsStartServer(hi_low->hostname, &si);
}
#endif 

STATICF void mnsFillCall(mnsqent *scq)
{
  mnsient *inst;
  mnscent *call;

#ifdef MNSCD_DEFINED
  
  if (scq->status != MNSC_PAUSE && scq->status != MNSC_STOP)
    mnsCheckCallsWaiting(scq);
#endif

  inst = scq->instances;
  while (scq->calls)
    {
      
      while (inst && inst->status != MNSC_CALLGET)
	inst = inst->next;

      if (!inst)
	break;

      
      call = scq->calls;
      scq->calls = call->next;
      inst->status = MNSC_CALLFWD;

      
#ifdef MNSC_SYNCH
      sts = mnSend(scq->iport, &inst->addr, call->buf, call->len, 0, 0);
      if (sts < 0)
	{
	  inst->status = sts;
	  mnsDelInstance(inst);
	  inst = scq->instances;

	  
	  call->next = scq->calls;
	  scq->calls = call;
	  continue;
	}
#else
      mnSend(scq->iport, &inst->addr, call->buf, call->len,
	     mnssReturnComp, "fill call");
#endif

      
      inst->cllfwd = smnClock();
      mnaCopy(&inst->origaddr, &call->addr);
      inst->clltot++;

      
      scq->cllcur++;
      scq->clltot++;
      scq->cllavg =
	((scq->cllavg * (scq->clltot - 1)) + scq->cllcur) / scq->clltot;
      if (scq->cllcur > scq->cllmax)
	scq->cllmax = scq->cllcur;

      scq->quecur--;
      scq->quedel =
	((scq->quedel * (scq->clltot - 1)) + (inst->cllfwd - call->arrival)) /
	  scq->clltot;

      
      ysmGlbFree(call->buf);
      ysmGlbFree(call);

      
      if (scq->status == MNSC_STOP && !scq->quecur)
	mnscStop(&scq->caddr);
    }
}

void mnsRecv(mnsqent *scq, sb4 sts, mnsem **semp)
{
  mnscent *call, *prev, *scc;

  if (sts >= 0)
    {
      
      call = (mnscent *) ysmGlbAlloc(sizeof(mnscent), "mnscent");
      call->next = (mnscent *) 0;
      call->arrival = smnClock();
      call->buf = (ub1 *) ysmGlbAlloc(sts, "callbuf");
      call->len = sts;

      
      sts = mnRecv(scq->cport, &call->addr, call->buf, call->len, 0, 0, 0);

      if (sts < 0)
	{
	  ysmGlbFree(call->buf);
	  ysmGlbFree(call);
	}
      else
	{
	  
	  scq->queavg =
	    ((scq->queavg * (scq->clltot + scq->quecur)) + scq->quecur) /
	      (scq->clltot + scq->quecur + 1);
	  scq->quecur++;
	  if (scq->quecur > scq->quemax)
	    scq->quemax = scq->quecur;

	  
	  for (prev = (mnscent *) 0, scc = scq->calls; scc;
	       prev = scc, scc = scc->next) ;

	  if (prev)
	    prev->next = call;
	  else
	    scq->calls = call;

	  mnsFillCall(scq);
	}
    }

  *semp = mnSemAlloc(scq);
  if (sts != MNERR_DISCONN)
    mnRecvWait(scq->cport, (mna *) 0, 0, (mnHandler) 0, (dvoid *) *semp);
}


sb4 mnsNewQueue(CONST char *name, CONST mnrid *progid, mnsqent **newqueue)
{
  mnscctx *scctx;
  mnsqent *scq;
  sb4      sts;
  mznent   entry;
  mnsem   *sem;

  scctx = mnscGlbCtx;

  if (!(scq = (mnsqent *) ysmGlbAlloc(sizeof(mnsqent), "mnsqent")))
    {
      ysmGlbFree((char*) name);
      return MNERR_OUTMEM;
    }

  memset(scq, 0, sizeof(mnsqent));

  scq->name = name;
  memcpy(&scq->progid, progid, sizeof(mnrid));
  scq->status = 0;
  scq->qlenlim = MNSQLENLIM;
  scq->exectim = 0;
  scq->cport = mnOpen(MNPROTO_MESSAGE);
  scq->iport = mnOpen(MNPROTO_MESSAGE);
  mnGetAddr(scq->cport, &scq->caddr);
  mnGetAddr(scq->iport, &scq->iaddr);

  scq->regavg = 1;
  scq->cllavg = 1;

  scq->calls = (mnscent *) 0;
  scq->instances = (mnsient *) 0;
  scq->hosts = (mnshinf *) 0;

  
  scq->next = scctx->queues;
  scctx->queues = scq;

  
  entry.name = name;
  entry.id = progid;
  mnGetAddr(scq->cport, &entry.addr);
  entry.attr = (mnbv *) 0;
  entry.nattr = 0;

  if (sts = mznInsEntry(&entry))
    {
      mnClose(scq->cport);
      mnClose(scq->iport);
      ysmGlbFree((char*) scq->name);
      ysmGlbFree(scq);
      return sts;
    }

  
  if (scctx->semcnt == scctx->semmax)
    {
      scctx->semmax += 16;
      scctx->semset =
	(mnsem **) ysmGlbRealloc(scctx->semset, sizeof(mnsem *) * scctx->semmax);
    }

  sem = scctx->semset[scctx->semcnt++] = mnSemAlloc((dvoid *) scq);

  
  mnRecvWait(scq->cport, (mna *) 0, 0, (mnHandler) 0, sem);
  *newqueue = scq;
  return 0;
}

STATICF sb4 mnsNewInstance(mna *from, mnsqent *scq, mnsient **newinstance)
{
  mnsient *inst;
  char     out[MNAMAXLEN];

  if (!(inst = (mnsient *) ysmGlbAlloc(sizeof(mnsient), "mnsient")))
    return MNERR_OUTMEM;

  memset(inst, 0, sizeof(mnsient));

  inst->queue = scq;
  inst->status = MNSC_REGISTER;
  mnaCopy(&inst->addr, from);

  
  inst->next = scq->instances;
  scq->instances = inst;
  mnsInsInstance(inst);

  mnAtos(from, out, MNAMAXLEN);
  mnDeathWatch(from, mnsDeathWatchInstHandler, inst);

  *newinstance = inst;
  return 0;
}


STATICF void mnsInsInstance(mnsient *inst)
{
  mnscctx *scctx;
  mnsibkt *bkt;
  ub4      key, sz;
  ub1     *buf;

  scctx = mnscGlbCtx;

  bkt = (mnsibkt *) ysmGlbAlloc(sizeof(mnsibkt), "mnsibkt");
  if (!bkt)
    return;

  bkt->inst = inst;

  for (key = 0, sz = sizeof(inst->addr.bits), buf = inst->addr.bits;
       sz; key += *buf++, sz--) ;

  key = key % MNSCROWS;
  bkt->next = scctx->insts[key];
  scctx->insts[key] = bkt;
}


STATICF mnsient *mnsGetInstance(mna *from)
{
  mnscctx *scctx;
  mnsibkt *bkt;
  ub4      key, sz;
  ub1     *buf;

  scctx = mnscGlbCtx;

  
  for (key = 0, sz = sizeof(from->bits), buf = from->bits;
       sz; key += *buf++, sz--) ;

  key = key % MNSCROWS;

  for (bkt = scctx->insts[key]; bkt && !mnaEq(&bkt->inst->addr, from);
       bkt = bkt->next) ;

  if (!bkt)
    return (mnsient *) 0;

  return bkt->inst;
}


STATICF void mnsDelInstance(mnsient *inst)
{
  mnscctx *scctx;
  mnsqent *scq;
  mnsibkt *pb, *bkt;
  mnsient *prev, *sci;
  ub4      key, sz;
  ub1     *buf;
  char     out[MNAMAXLEN];

  scctx = mnscGlbCtx;

  
  for (key = 0, sz = sizeof(inst->addr.bits), buf = inst->addr.bits;
       sz; key += *buf++, sz--) ;

  key = key % MNSCROWS;

  for (pb = (mnsibkt *) 0, bkt = scctx->insts[key];
       bkt && bkt->inst != inst;
       pb = bkt, bkt = bkt->next) ;

  if (!bkt)
    {
      mtlLog("WARNING: inconsistent hash table");
      return;
    }

  if (pb)
    pb->next = bkt->next;
  else
    scctx->insts[key] = bkt->next;

  inst = bkt->inst;
  ysmGlbFree(bkt);

  mnAtos(&inst->addr, out, MNAMAXLEN);
  mnDeathIgnore(&inst->addr, inst);	

  
  scq = inst->queue;
  for (prev = (mnsient *) 0, sci = scq->instances;
       sci && sci != inst;
       prev = sci, sci = sci->next) ;

  if (sci)
    {
      if (prev)
	prev->next = sci->next;
      else
	sci->queue->instances = sci->next;
    }

  mnAtos(&inst->addr, out, MNAMAXLEN);
  mtlLog("instance deleted: name=%s, addr=%s", scq->name, out);
  ysmGlbFree(inst);

  
  scq->regcur--;

  
  if (!scq->regcur)
    mnscStop(&scq->caddr);
}


STATICF void mnsDeathWatchInstHandler(void *usrp, sb4 sts)
{
  mnsient *inst;

  
  if (sts < 0)
    {
      if (sts != MNSTS_ABORTED)
        mtlLog("ERROR: mnsDeathWatchInstHandler received error: %s", mnError(sts));
      return;
    }

  inst = (mnsient *) usrp;
  mnsDelInstance(inst);
}
