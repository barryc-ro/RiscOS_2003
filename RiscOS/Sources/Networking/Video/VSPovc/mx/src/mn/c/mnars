/* mx/src/mn/mnars.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef MTL_ORACLE
#include <mtl.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MNI_ORACLE
#include <mni.h>
#endif
#ifndef MNRC_ORACLE
#include <mnrc.h>
#endif
#ifndef MNX_ORACLE
#include <mnx.h>
#endif

#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSR_ORACLE
#include <ysr.h>
#endif
#ifndef YSC_ORACLE
#include <ysc.h>
#endif
#ifndef SMNI_ORACLE
#include <smni.h>
#endif
#ifndef SMNG_ORACLE
#include <smng.h>
#endif

#define MNAROWS  256                            

typedef struct mnawae mnawae;
struct mnawae
{
  mna watcher;                                        
  mnawae *next;                               
};

typedef struct mnawe mnawe;
struct mnawe
{
  mna target;                                            
  mnawae *watchers;                                         
  mnawe *next;                                            
  mnawe *prev;                                            
};

typedef struct mnarsc
{
  mna     next;                                    
  mnawe  *watches[MNAROWS];                  
  mnp    *port;                                                
  boolean nohb;                        
  ub4     scnt;                            
  mnrte  *synch;                             
} mnarsc;

typedef struct mnarsd
{
  mnctx *mncx;
  mnarsc *arscx;
  ub1  buff[MNADPLEN];
  mna  from;
} mnarsd;

void mnArsReq(mnctx *ctx, mnarsc *arsctx, mna *from, ub1 *buf);
void mnArsRel(mnctx *ctx, mnarsc *arsctx, mna *from, ub1 *buf);
void mnArsSynch(mnctx *ctx, mnarsc *arsctx, mna *from, ub1 *buf);
void mnArsDeath(dvoid *usrp, mna *host, mnrte *rte);
void mnArsDeathRecv(dvoid *usrp, sb4 val);
sb4 mnArsAddWatch(mnarsc *arsctx, mna *target, mna *notify);
sb4 mnArsRmWatch(mnarsc *arsctx, mna *target, mna *notify);

static struct ysargmap mnarsArgs[] =
{
  { 'g', "mn.sync-gateway", YSARG_MANY },
  { 'i', "mn.async-gateway", YSARG_MANY },
  { 'D', "mnars.no-heartbeat=true", 0 },
  { 'e', "mnars.logtool", 1 }, 
  { 'z', "mn.heapsize", 1 },
  { YSARG_OPTPARAM, "mnars.subnet", 1 },
  { 0 }
};


boolean mnars(dvoid *osdCtx, CONST char *nm, sword argc, char **argv)
{
  mnp    *port;
  mna     addr, from;
  mnbv    bv;
  ub1     buf[256];
  mnctx  *ctx;
  sb4     sts;
  boolean done;
  mnarsc  arsctx;
  mnarsd  death;
  mnrte  *nxt;
  char   *addrtxt;
  sb4	 tool = MtlLogTool;
  char	 *arg;
  char    vbuf[80];

  CLRSTRUCT(arsctx);

  sts = ysArgParse( argc, argv, mnarsArgs );
  if (sts == YSARG_VERSION)
    {
      yslError("Oracle Media Net Address Server");
      yslError(ysVersion(vbuf, sizeof(vbuf)));
    }
  if (sts != YSARG_NORMAL)
    return FALSE;

  if( ysResGetLast( "mnars.no-heartbeat" ) )
    arsctx.nohb = TRUE;
  
  if( arg = ysResGetLast( "mnars.subnet" ) )
    addrtxt = arg;
  else
    addrtxt = "1.0.0.0";

  if( arg = ysResGetLast( "mnars.logtool" ) )
  {
    if( !strcmp( arg, "screen" ) )
      tool = MtlScreenTool;
    else if( !strcmp( arg, "log" ) )
      tool = MtlLogTool;
    else if( !strcmp( arg, "console" ) )
      tool = MtlConsoleTool;
    else
    {
      mtlLog("Unrecognized log tool %s", arg );
      return( FALSE );
    }
    mtlInit( tool, nm );
  }

  if( !smngInit( osdCtx, (mnLogger)0 ) )
    return( FALSE );

  if (tool != MtlScreenTool)
    {
      mtlLog("Oracle Media Net Address Server");
      mtlLog(ysVersion(vbuf, sizeof(vbuf)));
      yslDetach();
    }

  
  mnAddr(&arsctx.next, addrtxt);
  mtlLog("address server for subnet %s is running", addrtxt);

  ctx = mnGlbCtx;

  mnAddr(&addr, MNARSADDR);

  port = mnOpen(MNPROTO_OCP);
  mnaBind(ctx, &addr, port, FALSE);

  
  mnAddr(&addr,MNADEATHADDR);
  death.mncx = ctx;
  death.arscx = &arsctx;

  arsctx.port = mnOpen(MNPROTO_MESSAGE);
  mnaBind(ctx, &addr, arsctx.port, FALSE);
  mntRemovePort(ctx, arsctx.port);                     
  mnaCopy(&arsctx.port->me, &addr);

  sts = mnRecv(arsctx.port,&death.from,death.buff,sizeof(death.buff),
               0,mnArsDeathRecv,(dvoid *)&death);
  if(sts < 0)
    mnPrint(MNLWARN, "receive on process death port failed");

  
  mnaSetDeath(ctx, mnArsDeath, (dvoid *) &arsctx);

  bv.len = sizeof(buf);
  bv.buf = buf;
  done = FALSE;
  while (!done)
    {
      sts = mnoRecv(ctx, &from, &bv, 1, 0, 0, 0);
      switch (sts)
	{
	case MNSTS_ABORTED: done = TRUE; break;
	case MNOTYP_ADDRREQUEST: mnArsReq(ctx, &arsctx, &from, buf); break;
	case MNOTYP_ADDRRELEASE: mnArsRel(ctx, &arsctx, &from, buf); break;
	case MNOTYP_ADDRSYNCH: mnArsSynch(ctx, &arsctx, &from, buf); break;
	default: mnPrint(MNLERROR, "unexpected OCP packet: %d", sts); break;
	}
    }

  
  while (arsctx.synch)
    {
      nxt = arsctx.synch->next;
      ysmGlbFree((dvoid *) arsctx.synch);
      arsctx.synch = nxt;
    }

  mnClose(arsctx.port);
  mnTerm();
  return( TRUE );
}


void mnArsReq(mnctx *ctx, mnarsc *arsctx, mna *from, ub1 *buf)
{
  mnnpa *pa;
  mna   *src;
  mnnio *dnio;
  ub1   *p;
  mnrte *rte, *scs;
  ub1     pktspc[sizeof(mnnpkt) + sizeof(mnnhdr)];
  mnnpkt *ipkt = (mnnpkt *) pktspc;

  pa = (mnnpa *) buf;
  src = (mna *) (buf + sizeof(mnnpa));

  dnio = mnnFindNio(ctx, pa->family);
  if (dnio)
    {
      if (mnaWellKnown(src))
	{
	  rte = mnaFindRoute(ctx, src);
	  if (rte && mnaEq(src, &rte->addr))
	    {
	      mnPrint(MNLERROR, "duplicate well-known address");
	      rte->nio = dnio;
	      CPSTRUCT(rte->pa, *pa);
	      rte->itime = smnClock();
	    }
	  else
	    mnaInsertRoute(ctx, src, 0, dnio, pa,
			   (arsctx->nohb ? MNAFLG_PERM : 0));
	}
      else
	{
	  do
	    {
	      for (p = &arsctx->next.bits[5];
		   p > &arsctx->next.bits[0] && *p == 255; p--)
		*p = 0;
	      (*p)++;
	    } while (mnaFindRoute(ctx, &arsctx->next));

	  mnaCopy(src, &arsctx->next);
	  mnaInsertRoute(ctx, src, 0, dnio, pa, 
			 (arsctx->nohb ? MNAFLG_PERM : 0));
	}

      
      if (arsctx->synch)
	{
	  rte =  mnaFindRoute(ctx, src);
	  memset(ipkt, 0, sizeof(mnnpkt) + sizeof(mnnhdr));
	  for (scs = arsctx->synch; scs; scs = scs->next)
	    {
	      ipkt->nio = scs->nio;
	      CPSTRUCT(ipkt->pa, scs->pa);
	      if (memcmp(scs->pa.family, rte->pa.family,
			 sizeof(scs->pa.family)))
		{
		  mnnpa tmp;
		  CPSTRUCT(tmp, rte->pa);
		  CPSTRUCT(rte->pa, scs->nio->pa);
		  mnoSendRedirect(ctx, ipkt, rte, MNAFLG_PERM);
		  CPSTRUCT(rte->pa, tmp);
		}
	      else
		mnoSendRedirect(ctx, ipkt, rte, MNAFLG_PERM);
	    }
	}

      mnoSendAddrReply(ctx, 0, from, src, dnio, pa);
    }
  else
    {
      mnPrint(MNLERROR, "unable create address reply");
    }
}


void mnArsRel(mnctx *ctx, mnarsc *arsctx, mna *from, ub1 *buf)
{
  mnrte *rte;

  rte = mnaFindRoute(ctx, from);
  if (rte && mnaEq(from, &rte->addr))
    mnaDeleteRoute(ctx, rte);
  else
    mnPrint(MNLWARN, "released an address that wasn't allocated");
}

void mnArsSynch(mnctx *ctx, mnarsc *arsctx, mna *from, ub1 *buf)
{
  mnnpa *pa;
  mnrte *rte;

  pa = (mnnpa *) buf;
  rte = (mnrte *) ysmGlbAlloc(sizeof(mnrte), "mnrte for ArsSynch");
  DISCARD memset((dvoid *) rte, 0, sizeof(mnrte));
  rte->nio = mnnFindNio(ctx, pa->family);
  CPSTRUCT(rte->pa, *pa);
  rte->next = arsctx->synch;
  arsctx->synch = rte;
}

void mnArsDeathRecv(dvoid *usrp, sb4 val)
{
  mnarsd  *death;
  mnarsc  *arscx;
  ub1 *buf;
  sb4 sts = 0;
  ub1 type;
  mna target, notify;

  if(val < 0)
  {
    mnPrint(MNLWARN, "receive on process death port failed");
    return;
  }
  
  
  death = (mnarsd *) usrp;
  arscx = death->arscx;
  buf = death->buff;

  if(val == MNADPLEN)
  {
    
    type = *buf;
    mnaNetCopy(&target,(mna *)(buf+1));
    mnaCopy(&notify,&death->from);

    switch(type)
    {
    case MNADT_WATCH:                                               
      sts = mnArsAddWatch(arscx,&target,&notify);
      break;

    case MNADT_RMWATCH:                                      
      sts = mnArsRmWatch(arscx,&target,&notify);
      break;
    
    case MNADT_DEAD:                                   
      
      break;

    default:                                                      
      break;
    }

    if(type == MNADT_WATCH && sts)
    {
      
      *buf = MNADT_BADWATCH;
      DISCARD mnSend(arscx->port,&death->from,buf,MNADPLEN,mnDiscard,0);
    }
  }
  else
    mnPrint(MNLWARN,"received invalid death watch packet");


  
  sts = mnRecv(arscx->port,&death->from,death->buff,MNADPLEN,0,
               mnArsDeathRecv,usrp);
  if(sts < 0)
    mnPrint(MNLWARN, "receive on process death port failed");
}

 
void mnArsDeath(dvoid *usrp, mna *host, mnrte *rte)
{
  mnarsc *arsctx = (mnarsc *) usrp;
  mnawae *wae = (mnawae *)0, *next;
  mnawae **waep;
  mnawe *we = (mnawe *) 0;
  mnawe *wen;

  ub4 key, i;
  ub1 msg[1 + sizeof(mna)];
  mna asaddr;
  mnrte *scs;
  mnctx *ctx;

  ctx = mnGlbCtx;
  if (!(rte->flags & MNAFLG_PERM) && arsctx->synch)
    {
      DISCARD mnAddr(&asaddr, MNARSADDR);
      for (scs = arsctx->synch; scs; scs = scs->next)
	DISCARD mnoSendWRte(ctx, MNOTYP_ADDRRELEASE, &asaddr, &rte->addr, scs);
    }

  
  for (key = i = 0; i < 6; i++)
    key += host->bits[i];
  key &= (MNAROWS - 1);

  for(we = arsctx->watches[key]; we; we = we->next)
    if(mnaEq(&we->target,host)) break;

  if(we)
  {
    
    msg[0] = MNADT_DEAD;
    mnaCopy((mna *)(msg+1),host);

    
    if(we->next)
      we->next->prev = we->prev;
    if(we->prev)
      we->prev->next = we->next;
    else
      arsctx->watches[key] = we->next;

    
    for(wae = we->watchers; wae; wae = next)
    {
      DISCARD mnSend(arsctx->port,&wae->watcher,msg,sizeof(msg),
		     mnDiscard,(dvoid *)0);
      next = wae->next;
      ysmGlbFree((dvoid *) wae);
    }
    ysmGlbFree((dvoid *) we);
  }
  
  
  for(i = 0; i < MNAROWS; i++)
  {
    for(we = arsctx->watches[i]; we; we = wen)
    {
      wen = we->next;
      for(waep = &we->watchers; *waep; waep = &(*waep)->next)
        if(mnaNetEq(&(*waep)->watcher,host))
        {
          next = (*waep)->next;
          ysmGlbFree((dvoid *) *waep);
          *waep = next;

          
          break;
        }
      if(!we->watchers)
      {
        if(we->next)
          we->next->prev = we->prev;
        if(we->prev)
          we->prev->next = we->next;
        else
          arsctx->watches[i] = we->next;
        ysmGlbFree((dvoid *) we);
      }
    }
  }
}


sb4 mnArsAddWatch(mnarsc *arsctx, mna *target, mna *notify)
{
  mnctx *ctx;
  mnrte *rte;
  mnawae *wae = (mnawae *)0;
  mnawe *we = (mnawe *) 0;
  ub4 key, i;
  sb4 sts = MNSTS_NORMAL;

  ctx = mnGlbCtx;
  
  rte = mnaFindRoute(ctx, target);
  if(!rte || !mnaEq(target, &rte->addr))
  {
    sts = MNERR_BADADDR;
    goto err_done;
  }

  
  for (key = i = 0; i < 6; i++)
    key += target->bits[i];
  key &= (MNAROWS - 1);

  for(we = arsctx->watches[key]; we; we = we->next)
    if(mnaEq(&we->target,target)) break;

  if(!we)                                               
  {
    
    we = (mnawe *) ysmGlbAlloc(sizeof(mnawe), "mnawe for AddWatch");
    if(!we)
    {
      sts = MNERR_OUTMEM;
      goto err_done;
    }
    CLRSTRUCT(*we);
    mnaCopy(&we->target,target);

    we->next = arsctx->watches[key];                  
    arsctx->watches[key] = we;
    if(we->next) we->next->prev = we;
  }
  
  
  wae = (mnawae *) ysmGlbAlloc(sizeof(mnawae), "mnawae for AddWatch");
  if(!wae)
  {
    sts = MNERR_OUTMEM;
    goto err_done;
  }
  mnaCopy(&wae->watcher,notify);

  wae->next = we->watchers; 
  we->watchers = wae;

  return sts;                                                     

 err_done:                                 
  if(wae) ysmGlbFree((dvoid *) wae);
  if(we) ysmGlbFree((dvoid *) we);
  return sts;
}


sb4 mnArsRmWatch(mnarsc *arsctx, mna *target, mna *notify)
{
  mnawae *wae = (mnawae *)0;
  mnawae **pp = (mnawae **) 0;
  mnawe *we = (mnawe *) 0;
  ub4 key, i;

  
  for (key = i = 0; i < 6; i++)
    key += target->bits[i];
  key &= (MNAROWS - 1);

  for(we = arsctx->watches[key]; we; we = we->next)
    if(mnaEq(&we->target,target)) break;

  if(!we) return MNERR_BADADDR;              

  pp = &we->watchers;
  for(wae = we->watchers; wae; pp = &wae->next, wae = wae->next)
    if(mnaEq(&wae->watcher,notify))
    {
      *pp = wae->next;                                      
      ysmGlbFree((dvoid *) wae);
      break;                                                         
    }

  if(!we->watchers)
  {
    
    if(we->next)
      we->next->prev = we->prev;
    if(we->prev)
      we->prev->next = we->next;
    else
      arsctx->watches[key] = we->next;

    ysmGlbFree((dvoid *) we);
  }
  return MNSTS_NORMAL;
}
