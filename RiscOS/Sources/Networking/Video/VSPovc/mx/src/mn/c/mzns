/* mx/src/mn/mzns.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef MTL_ORACLE
#include <mtl.h>
#endif
#ifndef MN_ORACLE
#include <mn.h>
#endif
#ifndef MZN_ORACLE
#include <mzn.h>
#endif
#ifndef MNRS_ORACLE
#include <mnrs.h>
#endif
#ifndef MZNI_ORACLE
#include <mzni.h>
#endif

#ifndef YSR_ORACLE
#include <ysr.h>
#endif

#ifndef YSC_ORACLE
#include <ysc.h>
#endif

#ifndef MTL_ORACLE
#include <mtl.h>
#endif

#ifndef SMNI_ORACLE
#include <smni.h>
#endif

static struct ysargmap mznsArgs[] =
{
  { 'g', "mn.sync-gateway", 1 },
  { 'e', "mzns.logtool", 1 },
  { 0 }
};


STATICF CONST_W_PTR mnrod mznOpers[] =
{
  { mznssInsert, "mznInsertEntry" },
  { mznssFind,   "mznFindEntry" },
  { mznssDelete, "mznDeleteEntry" },
  { mznssQuery,  "mznQuery" },
  { mznssMakeAlias, "mznMakeAlias" }
};

STATICF CONST_W_PTR mnrcd mznComp =
  { &mznCid, sizeof(mznOpers) / sizeof(mnrod), mznOpers, "mznm" };

STATICF CONST_DATA mnrcd *mznCompList[] =
{
  &mznComp                                          
};



boolean mznMain(dvoid *osdCtx, const char *nm, sword argc, char **argv)
{
  mznctx  nsctx;
  mnrs   *sh;
  mna     nsaddr;
  sb4     sts;
  ub4     i;
  mznbkt *bkt, *scb;
  mnsem  *sem;
  mzmguTimeTicks now;
  char	*arg;
  sb4	 tool = MtlLogTool;
  char   vbuf[80];

  sts = ysArgParse( argc, argv, mznsArgs );
  if (sts == YSARG_VERSION)
    {
      yslError("Oracle Media Net Name Server");
      yslError(ysVersion(vbuf, sizeof(vbuf)));
    }
  if (sts != YSARG_NORMAL)
    return FALSE;

  if( arg = ysResGetLast( "mzns.logtool" ) )
  {
    if( !strcmp( arg, "screen" ) )
      tool = MtlScreenTool;
    else if( !strcmp( arg, "log" ) )
      tool = MtlLogTool;
    else if( !strcmp( arg, "console" ) )
      tool = MtlConsoleTool;
    else
    {
      yslError("Unrecognized log tool %s", arg );
      return( FALSE );
    }
  }
  mtlInit( tool, nm );

  if( !smniInit( osdCtx, (mnLogger)0 ) )
    return( FALSE );

  
  DISCARD mnAddr(&nsaddr, MZNMADDR);
  sts = mnEcho(&nsaddr, (ub4) 1000, (mnHandler) 0, (dvoid *) 0);
  if (sts >= 0)
  {
    mtlLog("name server already running");
    return( FALSE );
  }

  DISCARD memset(&nsctx, 0, sizeof(nsctx));

  
  sh = mnrCreateServer(&mznPid, (ub4) 1, mznCompList, (dvoid *) &nsctx);

  
  sts = mnBind(mnrGetServerPort(sh), &nsaddr);
  if (sts < 0)
    {
      mnrDestroyServer(sh);
      mtlLog(mnError(sts));
      return( FALSE );
    }

  
  CLRSTRUCT( nsctx.stats );
  now = mzmgsTimeStamp();
  nsctx.stats.OperStatus_mzmguSStats = mzmguStRunning;
  nsctx.stats.AdminStatus_mzmguSStats = mzmguStRunning;
  nsctx.stats.ChangedAdminStatus_mzmguSStats = now;
  nsctx.stats.LastOutbound_mzmguSStats = now;
  nsctx.stats.LastInbound_mzmguSStats = now;
  DISCARD mzmgsAddCommonMib( sh, MZMGA_NAME_SVC_SVCTYPE,
			    (mzmgsStFunc*)0, (dvoid *)&nsctx.stats );

  
  if (tool != MtlScreenTool)
    {
      mtlLog("Oracle Media Net Name Server");
      mtlLog(ysVersion(vbuf, sizeof(vbuf)));
      yslDetach();
    }

  
  DISCARD mnrListen(sh, (ub4) 0, mznRequestHandler, (dvoid *) sh);

  
  sts = mnrRegister(sh, "mznm", FALSE);
  if (sts < 0)
    {
      switch (sts)
	{
	case MNERR_BROKEN:
	  mtlLog("ERROR: communication with name server failed");
	  break;
	case MNERR_DUPLICATE:
	  mtlLog("ERROR: name server already running");
	  break;
	default:
	  mtlLog("ERROR: during registration: %s", mnError(sts));
	  break;
	}
      mnrDestroyServer(sh);
      return( FALSE );
    }

  mtlLog("name server awaiting requests");
  sem = mnSemAlloc((dvoid *) 0);
  sts = mnSemWait(sem);
  if (sts != MNSTS_ABORTED && sts < 0)
    mtlLog(mnError(sts));
  mnSemFree(sem);

  mnrDestroyServer(sh);

  
  for (i = 0; i < MZNROWS; i++)
    while (nsctx.names[i])
      {
	bkt = nsctx.names[i];
	nsctx.names[i] = bkt->next;

	while (bkt->older)
	  {
	    scb = bkt->older;
	    bkt->older = scb->next;

	    mnxFree(mznxEntry, (dvoid *) scb->entry);
	    ysmGlbFree(scb->entry);
	    ysmGlbFree(scb);
	  }

	mnxFree(mznxEntry, (dvoid *) bkt->entry);
	if (bkt->alias)
	  ysmGlbFree(bkt->alias);
	ysmGlbFree(bkt->entry);
	ysmGlbFree(bkt);
      }
  return( TRUE );
}


void mznRequestHandler(dvoid *shp, sb4 sts)
{
  mnrs   *sh;
  mnrsc	 *call;

  if (sts < 0)
    {
      if (sts == MNERR_DISCONN)
	mtlLog("bye");
      else
	mtlLog("WARNING: lost request: %s", mnError(sts));

      return;
    }

  sh = (mnrs *) shp;
  call = mnrGetNextCall(sh);
  DISCARD mnrListen(sh, (ub4) 0, mznRequestHandler, (dvoid *) sh);
  if (!mnrDispatchCall(call))
      mtlLog("WARNING: dispatch failed");
}


void mznDeathHandler(dvoid *usrp, sb4 val)
{
  mznbkt *bkt = (dvoid *) usrp;
  mznctx *nsctx;

  if(val != 0) return;                  
  
  nsctx = bkt->nsctx;                    
  DISCARD mznsDelete(nsctx, bkt->entry->name, bkt->entry->id);
}


void mznssInsert(mnrsc *call, mnbv *inargs, ub4 incnt)
{ 
  mnrs   *sh;
  mznctx *nsctx;
  mnx    *xstr;
  mznent *entry;
  sb4     result;
  mnbv   *outargs;
  ub4     outcnt;

  sh = mnrGetHandle(call);
  nsctx = (mznctx *) mnrGetUsrp(sh);

  
  nsctx->stats.TotInboundAssocs_mzmguSStats++;
  nsctx->stats.LastInbound_mzmguSStats = mzmgsTimeStamp();

  entry = (mznent *) ysmGlbAlloc(sizeof(mznent), "mznent");
  if (entry)
    {
      DISCARD memset(entry, 0, sizeof(mznent));
      xstr = mnxCreate((mndrp *) 0, MNXDIR_DECODE, &inargs, &incnt,
		       (dvoid *) 0);

      if (!mznxEntry(xstr, (dvoid *) entry))
	result = mnLastError();
      else
	result = 0;

      mnxDestroy(xstr, FALSE);
    }
  else
    result = MNERR_OUTMEM;

  if (!result)
    result = mznsInsert(nsctx, entry);

  if (result < 0)
    {
      mnxFree(mznxEntry, (dvoid *) entry);
      ysmGlbFree(entry);
    }

  xstr = mnxCreate((mndrp *) 0, MNXDIR_ENCODE, &outargs, &outcnt, (dvoid *) 0);
  if (mnxSB4(xstr, &result))
    DISCARD mnrReturnCall(call, outargs, outcnt, mnDiscard, (dvoid *) 0);
  else
    result = mnLastError();

  nsctx->stats.LastOutbound_mzmguSStats = mzmgsTimeStamp();

  mnxDestroy(xstr, TRUE);

  if (result < 0)
    mtlLog("WARNING: insert failed: reason %s", mnError(result));
}


void mznssFind(mnrsc *call, mnbv *inargs, ub4 incnt)
{
  mnrs   *sh;
  mznctx *nsctx;
  mnx    *xstr;
  mznent *result;
  mnbv   *outargs;
  ub4     outcnt;
  mnrid  *id;
  char   *name;
  sb4     sts;

  sh = mnrGetHandle(call);
  nsctx = (mznctx *) mnrGetUsrp(sh);

  
  nsctx->stats.TotInboundAssocs_mzmguSStats++;
  nsctx->stats.LastInbound_mzmguSStats = mzmgsTimeStamp();

  
  name = (char *) 0;
  id = (mnrid *) 0;

  xstr = mnxCreate((mndrp *) 0, MNXDIR_DECODE, &inargs, &incnt, (dvoid *) 0);

  if (mnxDynStr(xstr, &name) &&
      mnxPointer(xstr, (dvoid **) &id, sizeof(mnrid), mnrxId))
    sts = 0;
  else
    sts = mnLastError();

  mnxDestroy(xstr, FALSE);

  
  if (!sts)
    {
      result = mznsFind(nsctx, name, id);
      sts = (result ? 0 : MNERR_NOTFOUND);
    }

  if (name)
    ysmGlbFree(name);
  if (id)
    ysmGlbFree(id);

  
  xstr = mnxCreate((mndrp *) 0, MNXDIR_ENCODE, &outargs, &outcnt, (dvoid *) 0);
  if (!mnxSB4(xstr, &sts))
    sts = mnLastError();
  else if (!sts)
    if (!mznxEntry(xstr, (dvoid *) result))
      sts = mnLastError();

  if (sts >= 0 || sts == MNERR_NOTFOUND)
    DISCARD mnrReturnCall(call, outargs, outcnt, mnDiscard, (dvoid *) 0);

  nsctx->stats.LastOutbound_mzmguSStats = mzmgsTimeStamp();

  mnxDestroy(xstr, TRUE);

  if (sts < 0 && sts != MNERR_NOTFOUND)
    mtlLog("WARNING: find failed: reason %s", mnError(sts));

}


void mznssDelete(mnrsc *call, mnbv *inargs, ub4 incnt)
{
  mnrs   *sh;
  mznctx *nsctx;
  mnx    *xstr;
  sb4     result;
  mnbv   *outargs;
  ub4     outcnt;
  char   *name;
  mnrid  *id;

  sh = mnrGetHandle(call);
  nsctx = (mznctx *) mnrGetUsrp(sh);

  
  nsctx->stats.TotInboundAssocs_mzmguSStats++;
  nsctx->stats.LastInbound_mzmguSStats = mzmgsTimeStamp();

  
  name = (char *) 0;
  id = (mnrid *) 0;

  xstr = mnxCreate((mndrp *) 0, MNXDIR_DECODE, &inargs, &incnt, (dvoid *) 0);

  if (mnxDynStr(xstr, &name) &&
      mnxPointer(xstr, (dvoid **) &id, sizeof(mnrid), mnrxId))
    result = 0;
  else
    result = mnLastError();

  mnxDestroy(xstr, FALSE);

  
  if (!result)
    result = mznsDelete(nsctx, name, id);

  if (name)
    ysmGlbFree(name);
  if (id)
    ysmGlbFree(id);

  
  xstr = mnxCreate((mndrp *) 0, MNXDIR_ENCODE, &outargs, &outcnt, (dvoid *) 0);
  if (mnxSB4(xstr, &result))
    DISCARD mnrReturnCall(call, outargs, outcnt, mnDiscard, (dvoid *) 0);
  else
    result = MNERR_OUTMEM;

  nsctx->stats.LastOutbound_mzmguSStats = mzmgsTimeStamp();

  mnxDestroy(xstr, TRUE);

  if (result < 0)
    mtlLog("WARNING: delete failed: reason %s", mnError(result));

}


void mznssQuery(mnrsc *call, mnbv *inargs, ub4 incnt)
{
  mnrs     *sh;
  mznctx   *nsctx;
  mnx      *xstr;
  char     *name;
  ub4       qt;
  mnxStream stream;
  sb4       result;
  mnbv     *outargs;
  ub4       outcnt;

  sh = mnrGetHandle(call);
  nsctx = (mznctx *) mnrGetUsrp(sh);

  
  nsctx->stats.TotInboundAssocs_mzmguSStats++;
  nsctx->stats.LastInbound_mzmguSStats = mzmgsTimeStamp();

  
  name = (char *) 0;
  DISCARD memset(&stream, 0, sizeof(mnxStream));
  stream.elmsz = sizeof(mznent);
  stream.xfunc = mznxEntry;

  xstr = mnxCreate((mndrp *) 0, MNXDIR_DECODE, &inargs, &incnt, (dvoid *) 0);
  if (mnxDynStr(xstr, &name) &&
      mnxB4(xstr, &qt) &&
      mnxOutStream(xstr, &stream))
    result = 0;
  else
    result = mnLastError();
  mnxDestroy(xstr, FALSE);

  
  if (!result)
    result = mznsQuery(nsctx, name, qt, &stream);

  if (name)
    ysmGlbFree(name);

  
  xstr = mnxCreate((mndrp *) 0, MNXDIR_ENCODE, &outargs, &outcnt, (dvoid *) 0);
  if (mnxSB4(xstr, &result))
    DISCARD mnrReturnCall(call, outargs, outcnt, mnDiscard, (dvoid *) 0);
  else
    result = mnLastError();

  nsctx->stats.LastOutbound_mzmguSStats = mzmgsTimeStamp();

  mnxDestroy(xstr, TRUE);
  if (result < 0)
    mtlLog("WARNING: query failed; reason %s", mnError(result));
}


void mznssMakeAlias(mnrsc *call, mnbv *inargs, ub4 incnt)
{
  mnrs   *sh;
  mznctx *nsctx;
  mnx    *xstr;
  sb4     result;
  mnbv   *outargs;
  ub4     outcnt;
  char   *name, *alias;

  sh = mnrGetHandle(call);
  nsctx = (mznctx *) mnrGetUsrp(sh);

  
  nsctx->stats.TotInboundAssocs_mzmguSStats++;
  nsctx->stats.LastInbound_mzmguSStats = mzmgsTimeStamp();

  
  name = (char *) 0;
  alias = (char *) 0;

  xstr = mnxCreate((mndrp *) 0, MNXDIR_DECODE, &inargs, &incnt, (dvoid *) 0);

  if (mnxDynStr(xstr, &name) &&
      mnxDynStr(xstr, &alias))
    result = 0;
  else
    result = mnLastError();

  mnxDestroy(xstr, FALSE);

  
  if (!result)
    result = mznsMakeAlias(nsctx, name, alias);

  xstr = mnxCreate((mndrp *) 0, MNXDIR_ENCODE, &outargs, &outcnt, (dvoid *) 0);
  if (mnxSB4(xstr, &result))
    DISCARD mnrReturnCall(call, outargs, outcnt, mnDiscard, (dvoid *) 0);
  else
    result = mnLastError();

  nsctx->stats.LastOutbound_mzmguSStats = mzmgsTimeStamp();

  mnxDestroy(xstr, TRUE);

  if (result < 0)
    mtlLog("WARNING: alias creation failed: reason %s", mnError(result));
}


