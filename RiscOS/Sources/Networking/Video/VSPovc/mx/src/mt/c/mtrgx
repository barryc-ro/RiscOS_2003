/* mx/src/mt/mtrgx.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/





#ifndef SYSI_ORACLE
#include <sysi.h>
#endif 

#ifndef YS_ORACLE
# include <ys.h>
#endif

#ifndef MTRGX_ORACLE
#include <mtrgx.h>
#endif 



#define CBRA    1
#define CCHR    2
#define CDOT    4
#define CCL     6
#define NCCL    8
#define CDOL    10
#define CEOF    11
#define CKET    12
#define CBACK   18

#define CSTAR   01

STATICF sword   advance(mtrgxCtx *ctx,
                      char  *lp,
                      char  *ep );



STATICF sword backref( mtrgxCtx *ctx, sword i, char  *lp )
{
  char  *bp;

  bp = ctx->braslist[i];
  while (*bp++ == *lp++) if (bp >= ctx->braelist[i]) return(1);
  return(0);
}

STATICF sword cclass( char *set, char c, sword af )
{
  sword   n;

  if (c == 0) return(0);
  n = *set++;
  while (--n) if (*set++ == c) return(af);
  return(!af);
}



mtrgxCtx *mtrgxComp( char *sp, CONST char **errstr )
{
  mtrgxCtx *ctx = (mtrgxCtx *)ysmGlbAlloc(sizeof(mtrgxCtx), "mtrgxCtx");
  sword  c;
  char  *ep = ctx->expbuf;
  sword  cclcnt,
         numbra = 0;
  char  *lastep = 0;
  char   bracket[NBRA];
  char  *bracketp = &bracket[0];
  CONST  char *retoolong = "Regular expression too long";

#define comerr(ctx, msg) { \
   *errstr = msg; \
   ysmGlbFree((dvoid *)ctx); \
   return NULLP(mtrgxCtx); } 

  if (sp == 0 || *sp == '\0')
  {
    
    if (*ep == 0)
    {
       
       comerr(ctx, "No previous regular expression")
    }
    else
    {
       comerr(ctx, "Null input string")
    }
  }
  if (*sp == '^')
  {
    ctx->circf = 1;
    sp++;
  }
  else ctx->circf = 0;
  for (;;)
  {
    if (ep >= &(ctx->expbuf[ESIZE])) comerr(ctx, retoolong);
    if ((c = *sp++) == '\0')
    {
      if (bracketp != bracket) comerr(ctx, "unmatched \\(");
      *ep++ = CEOF;
      *ep++ = 0;
      return ctx;
    }
    if (c != '*') lastep = ep;
    switch (c)
    {

    case '.':                                         
      *ep++ = CDOT;
      continue;

    case '*':
      if (lastep == 0 || *lastep == CBRA || *lastep == CKET) goto defchar;
      *lastep |= CSTAR;
      continue;

    case '$':
      if (*sp != '\0') goto defchar;
      *ep++ = CDOL;
      continue;

    case '[':
      *ep++  = CCL;
      *ep++  = 0;
      cclcnt = 1;
      if ((c = *sp++) == '^')
      {
        c      = *sp++;
        ep[-2] = NCCL;
      }
      do
      {
        if (c == '\0') comerr(ctx, "missing ]");
        if (c == '-' && ep[-1] != 0)
        {
          if ((c = *sp++) == ']')
          {
            *ep++ = '-';
            cclcnt++;
            break;
          }
          while (ep[-1] < c)
          {
            *ep = ep[-1]+1;
            ep++;
            cclcnt++;
            if (ep >= &(ctx->expbuf[ESIZE])) comerr(ctx, retoolong);
          }
        }
        *ep++ = c;
        cclcnt++;
        if (ep >= &(ctx->expbuf[ESIZE])) comerr(ctx, retoolong);
      }
      while ((c = *sp++) != ']');
      lastep[1] = cclcnt;
      continue;

    case '\\':
      if ((c = *sp++) == '(')
      {
        if (numbra >= NBRA) comerr(ctx, "too many \\(\\) pairs");
        *bracketp++ = numbra;
        *ep++       = CBRA;
        *ep++       = numbra++;
        continue;
      }
      if (c == ')')
      {
        if (bracketp <= bracket) comerr(ctx, "unmatched \\)");
        *ep++ = CKET;
        *ep++ = *--bracketp;
        continue;
      }
      if (c >= '1' && c < ('1'+NBRA))
      {
        *ep++ = CBACK;
        *ep++ = c-'1';
        continue;
      }
      *ep++ = CCHR;
      *ep++ = c;
      continue;

    defchar:
    default:
      *ep++ = CCHR;
      *ep++ = c;
    }
  }
}



sword mtrgxExec( mtrgxCtx *ctx, char  *str )
{
  char        *p1 = str;
  char        *p2 = ctx->expbuf;
  sword        c;
  sword        rv;

  for (c = 0; c < NBRA; c++)
  {
    ctx->braslist[c] = NULLP(char);
    ctx->braelist[c] = NULLP(char);
  }
  if (ctx->circf) return((advance(ctx, p1, p2)));
  
  if (*p2 == CCHR)
  {
    c = p2[1];
    do
    {
      if (*p1 != c) continue;
      if (rv = advance(ctx, p1, p2)) return(rv);
    }
    while (*p1++);
    return(0);
  }
  
  do if (rv = advance(ctx, p1, p2)) return(rv);
  while (*p1++);
  return(0);
}


STATICF sword advance( mtrgxCtx *ctx, char *lp, char *ep )
{
  char   *curlp;
  sword   ct,
          i;
  sword   rv;

  for (;;)
  {
    switch (*ep++)
    {

    case CCHR:                                            
      if (*ep++ == *lp++) continue;
      return(0);

    case CDOT:
      if (*lp++) continue;
      return(0);

    case CDOL:
      if (*lp == '\0') continue;
      return(0);

    case CEOF:
      return(1);

    case CCL:
      if (cclass(ep, *lp++, 1))
      {
        ep += *ep;
        continue;
      }
      return(0);

    case NCCL:
      if (cclass(ep, *lp++, 0))
      {
        ep += *ep;
        continue;
      }
      return(0);

    case CBRA:
      ctx->braslist[*ep++] = lp;
      continue;

    case CKET:
      ctx->braelist[*ep++] = lp;
      continue;

    case CBACK:
      if (ctx->braelist[i = *ep++] == 0) return(-1);
      if (backref(ctx, i, lp))
      {
        lp += ctx->braelist[i]-ctx->braslist[i];
        continue;
      }
      return(0);

    case CBACK | CSTAR:
      if (ctx->braelist[i = *ep++] == 0) return(-1);
      curlp = lp;
      ct    = ctx->braelist[i]-ctx->braslist[i];
      while (backref(ctx, i, lp)) lp += ct;
      while (lp >= curlp)
      {
        if (rv = advance(ctx, lp, ep)) return(rv);
        lp -= ct;
      }
      continue;

    case CDOT | CSTAR:
      curlp = lp;
      while (*lp++) ;
      goto star;

    case CCHR | CSTAR:
      curlp = lp;
      while (*lp++ == *ep) ;
      ep++;
      goto star;

    case CCL | CSTAR:
    case NCCL | CSTAR:
      curlp = lp;
      while (cclass(ep, *lp++, ep[-1] == (CCL | CSTAR))) ;
      ep += *ep;
      goto star;

    star:
      do
      {
        lp--;
        if (rv = advance(ctx, lp, ep)) return(rv);
      }
      while (lp > curlp);
      return(0);

    default:
      return(-1);
    }
  }
}
