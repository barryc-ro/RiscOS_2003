/* mx/src/inc/ydidl.idl */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/





#ifndef YDIDL_ORACLE
#define YDIDL_ORACLE

#ifndef YOSTD_ORACLE
#include "yostd.idl"
#endif

#ifndef YDYOIDL_ORACLE
#include "ydyoidl.idl"
#endif





exception ydUnimpl {};
exception ydUnknown {};


module ydrt {
  interface router;
};
module ydsp {
  interface spawner;
  interface proc;
};
module ydim {
  interface imr;
  interface info;
  interface active;
  interface infoIterator;
  interface yortIterator;
  interface sync;
  interface claimIterator;
};
module ydch {
  interface och;
  interface objIterator;
};
module ydmt {
  interface imtr;
  interface info;
};


module ydrt {

  interface router {

    readonly attribute ydrt::router self;
    readonly attribute ydim::imr    imr;
    readonly attribute yort::queueInfo qinfo;
  };
};


module ydsp {

  enum ProcState { start_ok, start_fail, exit_ok, exit_bad, exit_unknown };

  struct procInfo {

    proc	self_ydsp_procInfo;     string      host_ydsp_procInfo;
    string      pid_ydsp_procInfo;
    string      affinity_ydsp_procInfo;
    string      name_ydsp_procInfo;

    spawner	parent_ydsp_procInfo;     ProcState	state_ydsp_procInfo;
  };

  typedef sequence <procInfo> procInfoList;

  interface spawner  {

    exception launchFail {};
    
    readonly attribute spawner self;
    readonly attribute ydim::imr imr;
    readonly attribute procInfoList procs;

    void Launch( in string path, in yostd::stringList args,
		out proc proc )
      raises (ydUnimpl, launchFail);

        void addExisting( in procInfo pinfo, out proc proc )
      raises (ydUnimpl);
  };

  interface proc {

    readonly attribute procInfo spinfo;

    boolean isAlive()		      raises (ydUnimpl);
    void killProc()		      raises (ydUnimpl);
    void destroyObj()		      raises (ydUnimpl);
  };
};



module ydim {

  typedef sequence <yort::proc> yortList;
  typedef sequence <active> activeList;

  struct yortInfo
  {
    yort::proc	    yort_ydim_yortInfo;
    yort::procInfo  pinfo_ydim_yortInfo;
    activeList	    alist_ydim_yortInfo;
  };

          
  struct implInfo {

    info    self_ydim_implInfo;
    string    intf_ydim_implInfo;	    string  impl_ydim_implInfo;	    string  host_ydim_implInfo;	
    activeList  alist_ydim_implInfo;

        string	  level_ydim_implInfo;     ub4		  minInstances_ydim_implInfo;     ub4		  maxInstances_ydim_implInfo; 
            string          pathName_ydim_implInfo;     yostd::stringList args_ydim_implInfo;     };

  typedef sequence <info> infoObjList;
  typedef sequence <implInfo> infoList;
  typedef sequence <yort::procInfo> yortProcInfoList;

  enum tryResult
  {
    success_tryResult,
    fail_tryResult,
    retry_tryResult
  };

  interface imr : ydyo::imr {

    readonly attribute imr self;
    readonly attribute ydmt::imtr mt;

        readonly attribute yortProcInfoList plist;

    
        void addInfoLocal( in implInfo info, out info infoObj );
    void addInfoGlobal( in implInfo info, out info infoObj );
    void destroyInfoLocal( in implInfo info );
    void destroyInfoGlobal( in implInfo info );

        void addActiveLocal( in yort::procInfo pinfo,
			in ydyo::activeInfoList ailist );
    void destroyActiveLocal( in ydyo::activeInfoList ailist );

        void destroyYortLocal( in yort::proc y );

        yort::proc yortOfProc( in string host, in string pid, in string affinity );
    boolean procOfYort( in yort::proc y, out yort::procInfo pinfo );
    boolean activeOfYort( in yort::proc y, out activeList list );

    
        void listImpl( in sb4 count,
		  in string intf, in string impl, in string host,
		  out infoList list, out infoIterator ii );

        void listYort( in sb4 count, in yort::proc subject,
		  out yortList ylist, out yortIterator yi );

        sync createSync(in sb4 cnt);
    
        void startSync( in imr dest, in sync whenDone );

        void abandonFor( in yort::claim what );

            void transfer( in yort::claim newClaim );

        tryResult tryStake( in yort::claim what );
    tryResult transferStake( in yort::claim what );
    void commitStake( in yort::claim what );
    void abortStake( in yort::claim what );

                    void listClaim( in sb4 count, in yort::claim what,
		   out yort::claimList claims,
		   out ydim::claimIterator ci );
  };

    interface info {

    readonly attribute implInfo info;
    void destroyLocal();
    void destroyGlobal();
  };

    interface active {

    readonly attribute ydyo::activeInfo ainfo;
    void destroyLocal();
    void destroyGlobal();
  };

    interface infoIterator {

    boolean next_one(out implInfo info );
    boolean next_n(in sb4 count, out infoList list);
    void destroy();
  };

    interface yortIterator {

    boolean next_one(out yort::proc y);
    boolean next_n(in sb4 count, out yortList list);
    void destroy();
  };

    interface claimIterator {
    boolean next_one(out yort::claim claim);
    boolean next_n(in sb4 count, out yort::claimList clist);
    void destroy();
  };

    interface sync {
    void decrement();
    void destroy();
  };
};


module ydch {

  interface lock;
  typedef sequence <lock> lockList;

      
  interface och {

        void whereActive( in Object unbound, out yort::proc place );

                    
    void lock( in Object unbound, out yort::proc place );

                void setPlace( in Object unbound, in yort::proc place );

            void remove( in Object unbound );

        void listObjs( in ub4 count, out yostd::objList objs,
		  out objIterator oi );
  };

  interface objIterator {
    boolean next_one(out Object obj);
    boolean next_n(in ub4 count, out yostd::objList objs);
    void destroy();
  };
};


module ydmt {

  struct minfo {

    info	    self_ydmt_minfo;
    yort::proc	    yort_ydmt_minfo;	    yort::implAll   all_ydmt_minfo;
  };

  typedef sequence <minfo> minfoList;

  
  interface imtr {

    readonly attribute imtr self;
    readonly attribute ydim::imr imr;
    readonly attribute minfoList mtinfo;

        void addInfo( in minfo minfo, out info mtobj );

        oneway void addYortAll( in yort::proc y, in yort::implAllList alist );

    minfo getInfo( in yort::proc y, in string impl, in string intf )
      raises (ydUnknown);
  };

  interface info {

        attribute minfo mtinfo;
    void destroy();
  };
};

#endif				