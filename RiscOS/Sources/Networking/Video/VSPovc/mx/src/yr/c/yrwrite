/* mx/src/yr/yrwrite.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSX_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YR_ORACLE
#include <yr.h>
#endif
#ifndef YR0_ORACLE
#include <yr0.h>
#endif



typedef void (*yrencf)( yrctx*, dvoid* p);


STATICF void yrEncStructMbr( yrctx* ctx, dvoid* p);
STATICF void yrEncList( yrctx* ctx, dvoid* l, yrencf encFunc);
STATICF void yrEncObj( yrctx* ctx, dvoid* o);
STATICF void yrEncPar( yrctx* ctx, dvoid* p);
STATICF void yrFEncString( yrctx* ctx, dvoid* str);
STATICF void yrEncUnionMbr( yrctx* ctx, dvoid* m);
STATICF void yrEncNamedObj( yrctx* ctx, yrobj* obj);
STATICF void yrWriteObj( dvoid* usrp, dvoid* elem);
STATICF ub4 yrStrToIdx( yrctx* ctx, char* s);
STATICF boolean yrxWriteBV( ysbv* bv, dvoid* usrp);
STATICF ub4 yrHashAddr(CONST dvoid* key, size_t keysz, ub4 max);
STATICF sword yrHashEqAddr( dvoid* elm, dvoid* key, size_t keysz);
STATICF sword yrStrHashEq( dvoid* elm, dvoid* key, size_t keysz);
STATICF ub4 yrStrSwizzle( yrctx* ctx, char* s);
STATICF void yrSwizzle( yrctx* ctx, yrobj* obj);
STATICF void yrSwizzleNamedObj( yrctx* ctx, yrobj* obj);


externdef ysidDecl( YR_EX_WRITE_FAIL) = "::YR_EX_WRITE_FAIL";
externdef ysidDecl( YR_EX_OPEN_FAIL) = "::YR_EX_OPEN_FAIL";




STATICF void yrFEncString( yrctx* ctx, dvoid* str)
{
  ysxPutUB4( ctx->xstr, yrStrToIdx( ctx, (char*)str));
}

#define yrEncString( ctx, str)  \
    ysxPutUB4( (ctx)->xstr, yrStrToIdx( (ctx), (str)))




STATICF boolean yrxWriteBV( ysbv* bv, dvoid* usrp)
{
  ub4 nbytes;
  yrctx* ctx = (yrctx*) usrp;

  if ( bv->len == 0 )
    return FALSE;
  nbytes = (ub4) sysfpWrite( ctx->fp, bv->buf, bv->len);
  if ( nbytes != bv->len )
    return FALSE;
  else
    return TRUE;
}




STATICF ub4 yrHashAddr(CONST dvoid* key, size_t keysz, ub4 max)
{
  ub4 hash = 0;
  CONST ub1* p = (ub1*) key;
  ub4 i;

  for ( i = 0; i < keysz; i++ )
    hash += p[i];

  return hash % max;
}




STATICF sword yrHashEqAddr( dvoid* elm, dvoid* key, size_t keysz)
{
  return !(((yrwrtblk*)elm)->ptr == key);
}




STATICF boolean yrObjSwizzle( yrctx* ctx, yrobj* p)
{
  yrwrtblk* idx;

  idx = (yrwrtblk*) ysHshFind( ctx->objs.wrt.tbl, (dvoid*) p, sizeof(p));
  if ( idx == (yrwrtblk*)0 )
  {
    idx = (yrwrtblk*) ysmGlbAlloc( sizeof(yrwrtblk), "yrhash");
    if ( yrGetKind(p) == yrdkRepository )
    {
      idx->recnum = 0;
      ysLstEnq( ctx->objs.wrt.list, (dvoid*) p);
    }
    else if ( yrGetKind(p) == yrdkPrimitive )
      idx->recnum = yrPrimData(p).kind;
    else
    {
      idx->recnum = ysLstCount( ctx->objs.wrt.list) + ctx->maxPrim +1;
      ysLstEnq( ctx->objs.wrt.list, (dvoid*) p);
    }
    idx->ptr = (dvoid*) p;
    ysHshIns( ctx->objs.wrt.tbl, p, sizeof(p), (dvoid*) idx);
    return FALSE;
  }
  else
    return TRUE;
}




STATICF sword yrStrHashEq( dvoid* elm, dvoid* key, size_t keysz)
{
  return (sword) strcmp( (char*)((yrwrtblk*)elm)->ptr, (CONST char*) key);
}




STATICF ub4 yrStrSwizzle( yrctx* ctx, char* s)
{
  yrwrtblk* idx;
  size_t len;

  if ( (s == (char*)0) || (*s == 0) )
    return 0;
  len = (size_t) strlen(s);
  idx = (yrwrtblk*) ysHshFind( ctx->strs.wrt.tbl, (dvoid*) s, len);
  if ( idx == (yrwrtblk*)0 )
  {
    idx = (yrwrtblk*) ysmGlbAlloc( sizeof(yrwrtblk), "yrhash");
    ysLstEnq( ctx->strs.wrt.list, (dvoid*) s);
    idx->recnum = ysLstCount( ctx->strs.wrt.list);
    idx->ptr = (dvoid*) s;
    ysHshIns( ctx->strs.wrt.tbl, (dvoid*)s, len, (dvoid*) idx);
  }
  return idx->recnum;
}




STATICF ub4 yrStrToIdx( yrctx* ctx, char* s)
{
  yrwrtblk* idx;
  size_t len;

  if ( (s == (char*)0) || (*s == 0) )
    return 0;
  len = (size_t) strlen(s);
  idx = (yrwrtblk*) ysHshFind( ctx->strs.wrt.tbl, (dvoid*) s, len);
  if ( idx )
    return idx->recnum;
  else
    return 0;
}

  


STATICF void yrSwizzle( yrctx* ctx, yrobj* obj)
{
  ysle* le;

  if ( yrObjSwizzle( ctx, obj) )
    return;
  switch ( yrGetKind(obj) )
  {
    case yrdkRepository:
      
      yrStrSwizzle( ctx, yrGetSrcName(obj));
      yrStrSwizzle( ctx, yrGetVersion(obj));
 
      for ( le = ysLstHead(yrRepData(obj)->anon); le; le = ysLstNext(le))
        yrSwizzle( ctx, (yrobj*) ysLstVal(le));
      break;     

    case yrdkAttribute:
      yrSwizzleNamedObj( ctx, obj);
      yrSwizzle( ctx, yrAttrData(obj).type);
      break;

    case yrdkConstant:
      yrSwizzleNamedObj( ctx, obj);
      yrSwizzle( ctx, yrConstData(obj).type);
      break;

    case yrdkException:
    case yrdkStruct:
        
      yrSwizzleNamedObj( ctx, obj);
      if ( yrStructData(obj).mbrs )
	for ( le = ysLstHead(yrStructData(obj).mbrs); le; le = ysLstNext(le))
        {
          yrstrmbr* mem = (yrstrmbr*) ysLstVal(le);
          yrStrSwizzle( ctx, mem->name);
          yrSwizzle( ctx, mem->type);
        }
      break;
    case yrdkInterface:
        
      yrSwizzleNamedObj( ctx, obj);
      if ( yrInterfaceData(obj).bases )
      {
	for (le = ysLstHead(yrInterfaceData(obj).bases); le; le=ysLstNext(le))
          yrSwizzle( ctx, (yrobj*) ysLstVal(le));
      }
      break;

    case yrdkModule:
      yrSwizzleNamedObj( ctx, obj);
      break;

    case yrdkOperation:
      yrSwizzleNamedObj( ctx, obj);
      yrSwizzle( ctx, yrOpData(obj).rettype);
      if ( yrOpData(obj).raises )
      {
        for ( le = ysLstHead( yrOpData(obj).raises); le; le = ysLstNext(le))
          yrSwizzle( ctx, (yrobj*) ysLstVal(le));
      }
      if ( yrOpData(obj).pars )
      {
        for ( le = ysLstHead( yrOpData(obj).pars); le; le = ysLstNext(le))
        {
          yrpar* par = (yrpar*) ysLstVal(le);
          yrStrSwizzle( ctx, par->name);
          yrSwizzle( ctx, par->type);
        }
      }
      if ( yrOpData(obj).ctxts )
      {
        for ( le = ysLstHead( yrOpData(obj).ctxts); le; le = ysLstNext(le))
        {
          yrStrSwizzle( ctx, (char*)ysLstVal(le));
        }
      }
      break;

    case yrdkAlias:
      yrSwizzleNamedObj( ctx, obj);
      yrSwizzle( ctx, yrAliasData(obj).type);
      break;

    case yrdkUnion:
      yrSwizzleNamedObj( ctx, obj);
      yrSwizzle( ctx, yrUnionData(obj).disctype);
      for ( le = ysLstHead(yrUnionData(obj).arms); le; le = ysLstNext(le))
      {
        yrunmbr* mem = (yrunmbr*) ysLstVal(le);
        yrStrSwizzle( ctx, mem->name);
        yrSwizzle( ctx, mem->type);
      }
      break;

    case yrdkEnum:
      yrSwizzleNamedObj( ctx, obj);
      for ( le = ysLstHead( yrEnumData(obj).mbrs); le; le = ysLstNext(le))
        yrSwizzle( ctx, (yrobj*) ysLstVal(le));
      break;

    case yrdkPrimitive:
    case yrdkString:
      break;

    case yrdkSequence:
      yrSwizzle( ctx, yrSeqData(obj).elmtype);
      break;

    case yrdkArray:
      yrSwizzle( ctx, yrArrayData(obj).elmtype);
      break;

    default:
      yseThrow( YR_EX_BADTYPE);
      break;
  }
  
  if ( yrIsContainer(obj) && yrGetContents(obj) )
  {
    for ( le = ysLstHead( yrGetContents(obj)); le; le = ysLstNext(le))
      yrSwizzle( ctx, (yrobj*) ysLstVal(le));
  }
}




STATICF void yrSwizzleNamedObj( yrctx* ctx, yrobj* obj)
{
  switch ( yrGetKind(obj) )
  {
    case yrdkAttribute:
    case yrdkConstant:
    case yrdkException:
    case yrdkInterface:
    case yrdkModule:
    case yrdkOperation:
    case yrdkAlias:
    case yrdkStruct:
    case yrdkUnion:
    case yrdkEnum:
      yrStrSwizzle( ctx, yrGetSrcName(obj));
      yrStrSwizzle( ctx, yrGetRepId(obj));
      yrStrSwizzle( ctx, yrGetName(obj));
      yrStrSwizzle( ctx, yrGetVersion(obj));
      yrSwizzle( ctx, yrGetDefinedIn(obj));
      break;
    default:
      break;
  }
}





STATICF void yrEncStructMbr( yrctx* ctx, dvoid* p)
{
  yrstrmbr* mem = (yrstrmbr*) p;

  yrEncString( ctx, mem->name);
  yrEncObj( ctx, (dvoid*) mem->type);
}





STATICF void yrEncAny( yrctx* ctx, yoany* any)
{
  yotkKind kind;
  ub4 len;
  const yotk* tk = any->_type;
  size_t tksz;

  kind = yotkGetKind(tk);

    
  tksz = yotkSize(tk);
  ysxPutUB4(ctx->xstr, (ub4)tksz);
  ysxCopy(ctx->xstr, (ub1*)tk, tksz);
  if ( kind == yotkAlias )
  {
    tk = yotkGetBaseType(tk);
    kind = yotkGetKind(tk);
  }

    
  switch (kind)
  {
    case yotkShort:
      ysxPutUB2(ctx->xstr, (ub2) *((sb2 *) any->_value));
      break;
    case yotkUshort:
      ysxPutUB2(ctx->xstr, *((ub2 *) any->_value));
      break;
    case yotkLong:
      ysxPutUB4(ctx->xstr, (ub4) *((sb4 *) any->_value));
      break;
    case yotkUlong:
    case yotkEnum:
      ysxPutUB4(ctx->xstr, *((ub4 *) any->_value));
      break;
    case yotkBoolean:
      ysxPutUB1(ctx->xstr, (ub1) *((boolean *) any->_value));
      break;
    case yotkChar:
      ysxPutUB1(ctx->xstr, (ub1) *((char *) any->_value));
      break;
    case yotkOctet:
      ysxPutUB1(ctx->xstr, *((ub1 *) any->_value));
      break;
    case yotkString:
    {
      size_t sz;

      len = yotkGetLength(tk);
      sz = ((*(char **)any->_value) ? strlen(*((char **) any->_value)) : 0);
      if ( (len != 0) && (sz > len || sz == 0) )
        yseThrow(YR_EX_BADTYPE);
      if ( sz ) 
        sz++;
      ysxPutUB4(ctx->xstr, sz);
      if(sz)
        ysxCopy(ctx->xstr, *((ub1 **) any->_value), sz);
      break;
    }
    case yotkLongLong:
      ysxPutSB8(ctx->xstr, (sysb8 *) any->_value);
      break;
    default:
      yseThrow( YR_EX_BADTYPE);
  }
}



STATICF void yrEncList( yrctx* ctx, dvoid* l, yrencf encFunc)
{
  yslst* lst = (yslst*) l;
  ysle* le;

  if ( lst )
  {
    ysxPutUB4( ctx->xstr, (ub4) ysLstCount(lst));
    for (le = ysLstHead(lst); le; le = ysLstNext(le))
      (*encFunc)(ctx, (dvoid*) ysLstVal(le));
  }
  else
    ysxPutUB4( ctx->xstr, (ub4)0);
}



STATICF void yrEncObj( yrctx* ctx, dvoid* o)
{
  yrwrtblk* idx;
  yrobj* obj = (yrobj*) o;
  sb4 val;

  if ( yrGetKind(obj) == yrdkPrimitive )
    val = yrPrimData(obj).kind;
  else if ( yrGetKind(obj) == yrdkRepository )
    val = 0;
  else
  {
    idx = (yrwrtblk*) ysHshFind( ctx->objs.wrt.tbl, o, sizeof(o));
    if ( idx == (yrwrtblk*)0 )
      val = 0;
    else
      val = idx->recnum;
  }
  ysxPutUB4( ctx->xstr, (ub4)val);
}




STATICF void yrEncPar( yrctx* ctx, dvoid* p)
{
  yrpar* par = (yrpar*) p;

  ysxPutUB4( ctx->xstr, par->mode);
  yrEncString( ctx, par->name);
  yrEncObj( ctx, (dvoid*) par->type);
}



STATICF void yrEncUnionMbr( yrctx* ctx, dvoid* m)
{
  yrunmbr* mem = (yrunmbr*) m;

  yrEncString( ctx, mem->name);
  yrEncObj( ctx, (dvoid*) mem->type);
  yrEncAny( ctx, &(mem->label));
}



STATICF void yrEncNamedObj( yrctx* ctx, yrobj* obj)
{
  yrEncString( ctx, yrGetSrcName(obj));
  ysxPutUB4( ctx->xstr, yrGetSrcLine(obj));
  yrEncString( ctx, yrGetName(obj));
  yrEncString( ctx, yrGetVersion(obj));
  yrEncObj( ctx, yrGetDefinedIn(obj));
}





STATICF void yrWriteObj( dvoid* usrp, dvoid* elem)
{
  yrctx* ctx = (yrctx*) usrp;
  yrobj* obj = (yrobj*) elem;

  ysRecord( YR_MSG(411, YR_FAC), YSLSEV_DEBUG(3), (char*)0, 
            YSLPTR(obj), YSLEND);

  switch ( yrGetKind(obj) )
  {
    case yrdkAttribute:
      yrEncNamedObj( ctx, obj);
      ysxPutUB4( ctx->xstr, (ub4) yrAttrData(obj).mode);
      yrEncObj( ctx, yrAttrData(obj).type);
      break;
    case yrdkConstant:
      yrEncNamedObj( ctx, obj);
      yrEncObj( ctx, yrConstData(obj).type);
      yrEncAny( ctx, &yrConstData(obj).val);
      break;
    case yrdkException:
    case yrdkStruct:
      yrEncNamedObj( ctx, obj);
      yrEncList( ctx, yrGetContents(obj), yrEncObj);
      yrEncList( ctx, yrStructData(obj).mbrs, yrEncStructMbr);
      break;
    case yrdkInterface:
      yrEncNamedObj( ctx, obj);
      ysxPutUB1( ctx->xstr, (ub1) yrInterfaceData(obj).defined);
      yrEncList( ctx, yrInterfaceData(obj).bases, yrEncObj);
      yrEncList( ctx, yrGetContents(obj), yrEncObj);
      break;
    case yrdkModule:
      yrEncNamedObj( ctx, obj);
      yrEncList( ctx, yrGetContents(obj), yrEncObj);
      break;
    case yrdkOperation:
      yrEncNamedObj( ctx, obj);
      ysxPutUB4( ctx->xstr, (ub4) yrOpData(obj).mode);
      yrEncObj( ctx, yrOpData(obj).rettype);
      yrEncList( ctx, yrOpData(obj).raises, yrEncObj);
      yrEncList( ctx, yrOpData(obj).pars, yrEncPar);
      yrEncList( ctx, yrOpData(obj).ctxts, yrFEncString);
      break;
    case yrdkAlias:
      yrEncNamedObj( ctx, obj);
      yrEncObj( ctx, yrAliasData(obj).type);
      break;
    case yrdkUnion:
      yrEncNamedObj( ctx, obj);
      yrEncList( ctx, yrGetContents(obj), yrEncObj);
      yrEncObj( ctx, yrUnionData(obj).disctype);
      yrEncList( ctx, yrUnionData(obj).arms, yrEncUnionMbr);
      break;
    case yrdkEnum:
      yrEncNamedObj( ctx, obj);
      yrEncList( ctx, yrEnumData(obj).mbrs, yrEncObj);
      break;
    case yrdkString:
      ysxPutUB4( ctx->xstr, yrStringData(obj).bound);
      break;
    case yrdkSequence:
      ysxPutUB4( ctx->xstr, yrSeqData(obj).bound);
      yrEncObj( ctx, yrSeqData(obj).elmtype);
      break;
    case yrdkArray:
      ysxPutUB4( ctx->xstr, yrArrayData(obj).length);
      yrEncObj( ctx, yrArrayData(obj).elmtype);
      break;
    case yrdkRepository:
      yrEncList( ctx, yrRepData(obj)->anon, yrEncObj);
      yrEncList( ctx, yrGetContents(obj), yrEncObj);
      break;
    case yrdkPrimitive:
      break;
    default:
      yseThrow( YR_EX_BADTYPE);
      break;
  }
}




STATICF void yrFreeCtx( yrctx* ctx)
{
  if ( ctx->objs.wrt.tbl )
    ysHshDestroy( ctx->objs.wrt.tbl);
  if ( ctx->objs.wrt.list )
    ysLstDestroy( ctx->objs.wrt.list, (ysmff)0);
  if ( ctx->strs.wrt.tbl )
    ysHshDestroy( ctx->strs.wrt.tbl);
  if ( ctx->strs.wrt.list )
    ysLstDestroy( ctx->strs.wrt.list, (ysmff)0);
  sysfpClose( ctx->fp);
}



void yrWrite( yrobj* root, CONST char* fn)
{
  noreg yrctx ctx;
  CONST char* errtxt;
  noreg ysbv bv = {0,0};
  char* s;
  yrobj* o;
  ysle* le;

  NOREG(ctx);
  CLRSTRUCT( ctx);
  NOREG(bv);
  ctx.maxPrim = YR_MAX_PRIM;   

    
  ctx.fp = sysfpOpen( fn, "w", SYSFPKIND_BINARY, &errtxt);
  if ( !ctx.fp )
    yseThrowObj( YR_EX_OPEN_FAIL, errtxt);

  yseTry
  {
      
    
    ysRecord( YR_MSG(412, YR_FAC), YSLSEV_DEBUG(1), (char*)0, 
              YSLSTR(ctx.fp), YSLEND);
    ctx.objs.wrt.tbl = ysHshCreate( 255, yrHashAddr, yrHashEqAddr, 
                                    ysmFGlbFree);
    ctx.objs.wrt.list = ysLstCreate();

    ctx.strs.wrt.tbl = ysHshCreate( 255, ysHshKey, yrStrHashEq, ysmFGlbFree);
    ctx.strs.wrt.list = ysLstCreate();
    yrSwizzle( (yrctx*) &ctx, root);

      
    bv.len = YRX_BUFF_SZ;
    bv.buf = ysmGlbAlloc( YRX_BUFF_SZ, "yrxbuff");
    ctx.xstr = ysxEncodeToStream( yrxWriteBV, (ysbv*)&bv, (dvoid*)&ctx);
  }
  yseCatchAll
  {
    yrFreeCtx( (yrctx*) &ctx);
    if ( bv.buf )
      ysmGlbFree((dvoid*)bv.buf);
  }
  yseEnd;

    if ( yrRepData(root->repository)->trace >= 2 )
    {
      ysle* le;
      char* nm;
      sword i;
 
      ysRecord( YR_MSG(403, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                YSLSTR("STRING"), YSLEND);
      for ( i = 1, le = ysLstHead(ctx.strs.wrt.list); le; 
           i++, le = ysLstNext(le) )
        ysRecord( YR_MSG(404, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                  YSLSB4(i), YSLPTR(ysLstVal(le)),
                  YSLSTR((char*) ysLstVal(le)), YSLEND);
      ysRecord( YR_MSG(405, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                YSLSTR("STRING"), YSLEND);

      ysRecord( YR_MSG(403, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                YSLSTR("OBJECT"), YSLEND);
      for ( i = 0, le = ysLstHead(ctx.objs.wrt.list); le; 
                i++, le = ysLstNext(le))
      {
        nm = yrGetAbsoluteName( (yrobj*) ysLstVal(le));
        if ( nm )
        {
          ysRecord( YR_MSG(406, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                    YSLSB4(i), YSLPTR(ysLstVal(le)), YSLSTR(nm), YSLEND);
          ysmGlbFree( (dvoid*)nm);
        }
        else
          ysRecord( YR_MSG(406, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                    YSLSB4(i), YSLSTR("<anonymous>"), YSLEND);
      } 
      ysRecord( YR_MSG(405, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                YSLSTR("OBJECT"), YSLEND);
    }

    

  yseTry
  {
      
    ysRecord( YR_MSG(413, YR_FAC), YSLSEV_DEBUG(1), (char*)0, 
              YSLSTR(ctx.fp), YSLUB4(YR_IO_VERS), YSLEND);
    ysxCopy( ctx.xstr, (ub1*) YR_IO_TAG, YR_IO_TAG_SZ);
    ysxPutUB4( ctx.xstr, YR_IO_VERS);
    ysxPutUB4( ctx.xstr, ysLstCount( ctx.strs.wrt.list));
    ysxPutUB4( ctx.xstr, ysLstCount( ctx.objs.wrt.list));
    ysxPutUB4( ctx.xstr, ctx.maxPrim);

      
    ysRecord( YR_MSG(414, YR_FAC), YSLSEV_DEBUG(1), (char*)0,
              YSLSTR(ctx.fp), YSLEND);
    while ( (s = (char*) ysLstDeq( ctx.strs.wrt.list)) )
    {
      ub4 len = strlen(s) + 1;
      ysxPutUB4( ctx.xstr, len);
      ysxCopy( ctx.xstr, (ub1*) s, len);
    }

      
    ysRecord( YR_MSG(415, YR_FAC), YSLSEV_DEBUG(1), (char*)0,
              YSLSTR(ctx.fp), YSLEND);
    for ( le = ysLstHead( ctx.objs.wrt.list); le; le = ysLstNext(le) )
    {
      yrobj* obj = (yrobj*) ysLstVal(le);

      switch (yrGetKind( obj))
      {
        case yrdkRepository:
        case yrdkSequence:
        case yrdkArray:
        case yrdkString:
          ysxPutUB4( ctx.xstr, yrGetKind( obj));
          ysxPutUB4( ctx.xstr, (ub4)0);
          break;
        case yrdkPrimitive:
          break;    
        default:
          ysxPutUB4( ctx.xstr, yrGetKind( obj));
          ysxPutUB4( ctx.xstr, yrStrToIdx((yrctx*) &ctx, yrGetRepId(obj)));
          break;
      }
    }
 
      
    ysRecord( YR_MSG(416, YR_FAC), YSLSEV_DEBUG(1), (char*)0,
              YSLSTR(ctx.fp), YSLEND);
    while ( (o = (yrobj*) ysLstDeq( ctx.objs.wrt.list)) )
    {
      yrWriteObj( (dvoid*)&ctx, o);
    }

    ysxEncEnd( ctx.xstr, (ysbv**)0, (sword*)0);
  }
  yseCatch( YS_EX_ENCODEERROR)
  {
    
    ysRecord( YR_MSG(417, YR_FAC), YSLSEV_DEBUG(1), (char*)0,
              YSLSTR(ctx.fp), YSLEND);
    if ( bv.buf )
      ysmGlbFree((dvoid*)bv.buf);
    yrFreeCtx( (yrctx*) &ctx);
    yseRethrow;
  }
  yseCatchAll
  {
    ysxEncEnd( ctx.xstr, (ysbv**)0, (sword*)0);
    if ( bv.buf )
      ysmGlbFree((dvoid*)bv.buf);
    yrFreeCtx( (yrctx*) &ctx);
    yseRethrow;
  }
  yseEnd;

  ysmGlbFree((dvoid*)bv.buf);
  sysfpClose( ctx.fp);
  yrFreeCtx( (yrctx*) &ctx);
}
