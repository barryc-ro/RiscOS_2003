/* mx/src/yr/yrsrv.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif

#ifndef YS_ORACLE
#include <ys.h>
#endif

#ifndef YO_ORACLE
#include <yo.h>
#endif
 
#ifndef YOCOA_ORACLE
#include <yocoa.h>
#endif
 
#ifndef YR_ORACLE
#include <yr.h>
#endif
 
#ifndef YR0UTIL_ORACLE
#include <yr0util.h>
#endif

#ifndef YR0_ORACLE
#include <yr0.h>
#endif

#ifndef SMNI_ORACLE
#include <smni.h>
#endif

#ifndef YRMGIDL_IDL
#include <yrmgidl.h>
#endif

#ifndef SYSFP_ORACLE
#include <sysfp.h>
#endif

#ifndef YRDIIDL_IDL
#include <yrdiidl.h>
#endif


STATICF void yrmgrInitRepository( yrobj* rep);
STATICF void yrmgrTermRepository(void);
STATICF void yrsrvIntrHandler( dvoid* usrp, sb4 err);
STATICF void yrsrvDestroyObj( dvoid* obj);
STATICF void yrsrvLogInit( yrmgrctx* ctx);
STATICF void yrsrvLogTerm( yrmgrctx* ctx);

#ifndef YRSRV_VERS
#define YRSRV_VERS "3.2.0.0.0"
#endif
#ifndef YRSRV_NAME
#define YRSRV_NAME "Oracle Media Net Interface Repository Server"
#endif
#ifndef YRSRV_STS
#define YRSRV_STS YSLVL_DEVEL
#endif

#ifndef YRSRV_COMP
#define YRSRV_COMP "mnirsrv"
#endif

struct ysargmap yrsrvargmap[] =
{
  { 'f', "mnirsrv.ifr-data-path", YSARG_MANY}, 
  { YSARG_OPTPARAM, "mnirsrv.ifr-name", 0},
  { 0, (char*)0, 0}                         
};

boolean yrsrvMain( dvoid* osdp, char* name, sword argc, char** argv);

boolean yrsrvMain( dvoid* osdp, char* name, sword argc, char** argv)
{
  noreg sword status;
  yrmgrctx ctx;
  noreg boolean ok;
 
  ysInit( osdp, YRSRV_COMP);
 
  NOREG(ok);
  NOREG(status);
  ok = TRUE;
  status = ysArgParse( argc, argv, yrsrvargmap);
  CLRSTRUCT( ctx);

  if ( status == YSARG_NORMAL )
  {
    CONST char* noreg tag;
    yslst* loadlist;
 
    NOREG(tag);
    smniInit( osdp, (mnLogger) yslError);
    yoInit();
    mnSetIntrHandler( yrsrvIntrHandler, (dvoid*) &ctx);

    yrsrvLogInit( &ctx);    

    tag = ysResGetLast( "mnirsrv.ifr-name");
    if ( !tag )
      tag = YRSRV_DEFAULT_TAG;

    ctx.tag = (char*) tag;
    ysRecord( YR_MSG(306, YR_FAC), YSLSEV_INFO, (char*)0, 
              YSLSTR(ctx.tag), YSLEND);

      
    if ( !ysResGetBool( "mnirsrv.allow-dups") )
    {
      yr_mgr doppelganger;
      yoenv env;

      yoEnvInit( &env);
      doppelganger = yoBind( yr_mgr__id, tag, (yoRefData*)0, (char*)0);
      yseTry
      {
        CORBA_Repository dummy;

        dummy = yr_mgr__get_repository( doppelganger, &env);
        ok = FALSE;                    
        yoRelease( (dvoid*) dummy);
      }
      yseCatchAll
      {
          
        ok = TRUE;
      }
      yseEnd

      yoRelease( (dvoid*)doppelganger);
      yoEnvFree(&env);
      if ( !ok )
      {
        ysRecord( YR_MSG(11, YR_FAC), YSLSEV_ERR, (char*)0, 
                  YSLSTR(tag), YSLEND);
        goto error;
      }
    }
 
      
    yseTry
    {
      ctx.repository = yrCreateRepository();
    }
    yseCatchAll
    {
      ysRecord( YR_MSG(12, YR_FAC), YSLSEV_ERR, (char*)0, 
                  YSLSTR(tag), YSLSTR(ysidToStr( yseExid)), YSLEND);
      ok = FALSE;
    }
    yseEnd

    if ( !ok )
      goto error;

      
    ctx.loadlst = ysLstCreate();
    loadlist = ysResGet( "mnirsrv.ifr-data-path");
    if ( loadlist )
    {
      ysle* noreg le;
      yslst* loaded;
      char* noreg path;

      NOREG(path);
      NOREG(le);
      for ( le = ysLstHead(loadlist); ok && le; le = ysLstNext(le))
      {
        path = (char*) ysLstVal(le);
        ysRecord( YR_MSG(300, YR_FAC), YSLSEV_INFO, (char*)0, 
                  YSLSTR( (char*)path), YSLSTR(tag), YSLEND);
        yseTry
        {
          loaded = yrmgrLoad( ctx.repository, (char*) path);
          if ( ysLstCount(loaded) > 0 )
          {
            dvoid* f;
            while ( (f = ysLstDeq( loaded)) )
              ysLstEnq( ctx.loadlst, f);
          }
          ysLstDestroy( loaded, (ysmff)0);
        }
        yseCatchObj( YR_MGR_EX_LOADCONFLICT, yr_mgr_LoadConflict, ex)
        {
          ok = FALSE;
          yrmgrReportLoadConflict( (dvoid*)&ex, YSLSEV_ERR);
          yr_mgr_LoadConflict__free( (dvoid*)&ex, yoFree);
        }
        yseCatchObj( YR_MGR_EX_FILENOTFOUND, yr_mgr_fileNotFound, ex)
        {
          ysRecord( YR_MSG(3, YR_FAC), YSLSEV_ERR, (char*)0, 
                    YSLSTR(ex.path), YSLEND);
          yr_mgr_fileNotFound__free( &ex, yoFree);
          ok = FALSE;
        }
        yseCatchObj( YR_MGR_EX_FILECORRUPTED, yr_mgr_fileCorrupted, ex)
        {
          ysRecord( YR_MSG(13, YR_FAC), YSLSEV_ERR, (char*)0, 
                    YSLSTR(ex.path), YSLEND);
          yr_mgr_fileCorrupted__free( &ex, yoFree);
          ok = FALSE;
        }
        yseCatchAll
        {
          ok = FALSE;
          ysRecord( YR_MSG(5, YR_FAC), YSLSEV_ERR, (char*)0, 
                    YSLSTR((char*)path), YSLSTR(ysidToStr( yseExid)), YSLEND);
          yseRethrow;
        }
        yseEnd
      }
      if ( ok )
      {
        if ( ysLstCount(ctx.loadlst) == 0 )
          ysRecord( YR_MSG(307, YR_FAC), YSLSEV_INFO, (char*)0, YSLNONE);
        ysRecord( YR_MSG(308, YR_FAC), YSLSEV_INFO, (char*)0, YSLNONE);
      }
    }

      
    if ( ok )
    {
      yssnk* ttysink;

      if ( ctx.trace )
        yrSetTraceLevel( ctx.repository, ctx.trace);

      yrmgrInitRepository( ctx.repository);
      yrdiiInit( ctx.repository, (char*) tag);
      yrmgrInit(&ctx);

      
      if ( !ysResGetBool( "mnirsrv.tty-only") )
      {
        ttysink = ysSinkFind( "tty");
        ysSinkDestroy( ttysink);
        yslDetach();
      }

      ctx.servicing = TRUE;
      yoService( (ysque*) 0);

      yrmgrTerm(&ctx);
      yrdiiTerm( (char*) tag);
      yrmgrTermRepository();
      ctx.servicing = FALSE;
      ysRecord( YR_MSG(309, YR_FAC), YSLSEV_INFO, (char*)0, 
                YSLSTR(tag), YSLEND);
    }
error:
    if ( ctx.repository )    
      yrDestroyRepository( ctx.repository, ysmFGlbFree, yrsrvDestroyObj);
    yrsrvLogTerm( &ctx);
    yoTerm();
    mnTerm();
  }
  else if ( status == YSARG_ERROR )
    ok = FALSE;
  else if ( status == YSARG_VERSION )
  {
    char buf[1024];

    yslError( ysFmtVersion(buf, sizeof(buf), YRSRV_NAME, YRSRV_VERS, 
              YRSRV_STS, __DATE__));
    yslError( ysVersion(buf, sizeof(buf)));
  }
  else
    ok = TRUE;

    
  ysTerm(osdp);
  return ok;
}




STATICF void yrmgrInitRepository( yrobj* rep)
{
  Init_CORBA_Repository( rep);
  Init_yr_intfdef( rep);

  
  Init_CORBA_AttributeDef();
  Init_CORBA_ConstantDef();
  Init_CORBA_ExceptionDef();
  Init_CORBA_InterfaceDef();
  Init_CORBA_ModuleDef();
  Init_CORBA_OperationDef();
  Init_CORBA_TypedefDef();
  Init_CORBA_AliasDef();
  Init_CORBA_StructDef();
  Init_CORBA_UnionDef();
  Init_CORBA_EnumDef();
  Init_CORBA_PrimitiveDef();
  Init_CORBA_StringDef();
  Init_CORBA_SequenceDef();
  Init_CORBA_ArrayDef();
}





STATICF void yrmgrTermRepository()
{
  Term_CORBA_Repository();
  Term_yr_intfdef();
  Term_CORBA_AttributeDef();
  Term_CORBA_ConstantDef();
  Term_CORBA_ExceptionDef();
  Term_CORBA_InterfaceDef();
  Term_CORBA_ModuleDef();
  Term_CORBA_OperationDef();
  Term_CORBA_TypedefDef();
  Term_CORBA_AliasDef();
  Term_CORBA_StructDef();
  Term_CORBA_UnionDef();
  Term_CORBA_EnumDef();
  Term_CORBA_PrimitiveDef();
  Term_CORBA_StringDef();
  Term_CORBA_SequenceDef();
  Term_CORBA_ArrayDef();
}




STATICF void yrsrvIntrHandler( dvoid* usrp, sb4 err)
{
  yrmgrctx* ctx = (yrmgrctx*) usrp;

  if ( ctx->logger )
    ysRecord(YR_MSG(305, YR_FAC), YSLSEV_INFO, (char*)0, 
             YSLSB4(err), YSLEND);
  if ( ctx->servicing )
    yoShutdown( (ysque*)0);
  else      
  {
    if ( ctx->repository )    
      yrDestroyRepository( ctx->repository, ysmFGlbFree, yrsrvDestroyObj);
    yrsrvLogTerm( ctx);
    yoTerm();
    mnTerm();
    exit(0);
  }
}




STATICF void yrsrvDestroyObj( dvoid* obj)
{
  yoRelease( obj);
  yoDispose( obj);
}



STATICF void yrsrvLogInit( yrmgrctx* ctx)
{
  CONST char* traceopt;
  ub4 severity;
  char msgfilter[512];
  yssnk* ttysink;

  
  severity = (ysResGetBool("mnirsrv.verbose") ? YSLSEV_INFO : YSLSEV_WARNING);
  traceopt = ysResGetLast("mnirsrv.debug-trace");
  if ( traceopt )
  {
    ub4 lvl;
    char* dummy = (char*)0;

    lvl = strtol( traceopt, &dummy, 10);
    if ( dummy  != traceopt )     
    {
      ctx->trace = lvl;
      severity = YSLSEV_DEBUG(lvl);
    }
  }

  
  if ( !ysResGetLast( "ys.log.msg-path") )
    yslError( "Unable to locate message file. Set ys.log.msg-path.");
  ysFmtStrl( msgfilter, sizeof(msgfilter), 
             "maxsev 4, prod %s fac %s maxsev %u", 
             YS_PRODUCT, YR_FAC, severity);
  ttysink = ysSinkFind( "tty");
  if ( ttysink )
    ysAddFilter( ttysink, msgfilter);
  else
    yslError( "Unable to find tty sink.");

  
  if ( !ysResGetBool( "mnirsrv.tty-only") )
  {
    ctx->logger = yeevInit( (ysque*)0);
    yeevSinkAttach( ctx->logger, severity);
  }
}



STATICF void yrsrvLogTerm( yrmgrctx* ctx)
{
  if ( ctx->logger )
  {
    yeevSinkDetach( ctx->logger);
    yeevTerm( ctx->logger);
  }
}
