/* mx/src/yr/yrmerge.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSX_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef SYSB8_ORACLE
#include <sysb8.h>
#endif
#ifndef YR_ORACLE
#include <yr.h>
#endif
#ifndef YR0_ORACLE
#include <yr0.h>
#endif
#ifndef YR0UTIL_ORACLE
#include <yr0util.h>
#endif
#ifndef YRMGIDL_IDL
#include <yrmgidl.h>
#endif
#ifndef YSLST_ORACLE
#include <yslst.h>
#endif


#undef lst1
#undef lst2

STATICF boolean yrObjCommonIsEq( yrobj* obj1, yrobj* obj2);
STATICF boolean yotkIsEq(CONST yotk *tk1, CONST yotk *tk2);
STATICF boolean yrAnyEq( yoany* any1, yoany* any2);
STATICF void yrCmpIntfLdBlk( yrldblk* ldblk, boolean externok);
STATICF void yrCmpOpLdBlk( yrldblk* ldblk, boolean externok);
STATICF void yrCmpLdBlk( yrldblk* ldblk, boolean externok);
STATICF void yrMergeObjs( yrobj* newobj, yrobj* oldobj);
STATICF boolean yrContentsEq( yrobj* obj1, yrobj* obj2);




STATICF boolean yrObjCommonIsEq( yrobj* obj1, yrobj* obj2)
{
  char* nm1;
  char* nm2;
  boolean issame;

  if ( strcmp(yrGetRepId(obj1), yrGetRepId(obj2)) ||
       strcmp(yrGetVersion(obj1), yrGetVersion(obj2)) )
    return FALSE;

  nm1 = yrGetAbsoluteName( obj1);
  nm2 = yrGetAbsoluteName( obj2);

  issame = !strcmp( nm1, nm2);
  ysmGlbFree((dvoid*) nm1);
  ysmGlbFree((dvoid*) nm2);
  return issame;
}




STATICF boolean yotkIsEq(CONST yotk *tk1, CONST yotk *tk2)
{
  size_t tk1sz, tk2sz;

  if ( tk1 == tk2 )
    return TRUE;

  tk1sz = yotkSize(tk1);
  tk2sz = yotkSize(tk2);
  if(tk1sz != tk2sz) return FALSE;

  return (memcmp((dvoid *)tk1,(dvoid *)tk2,tk1sz) == 0);
}





STATICF boolean yrAnyEq( yoany* any1, yoany* any2)
{
  if ( !yotkIsEq( any1->_type, any2->_type) )
    return FALSE;

  switch ( yotkGetKind( any1->_type) )
  {
    case yotkShort:
      return (*(sb2*) any1->_value) == (*(sb2*)any2->_value);
    case yotkLong:
      return (*(sb4*) any1->_value) == (*(sb4*)any2->_value);
    case yotkUshort:
      return (*(ub2*) any1->_value) == (*(ub2*)any2->_value);
    case yotkEnum:
    case yotkUlong:
      return (*(ub4*) any1->_value) == (*(ub4*)any2->_value);
    case yotkBoolean:
      return (*(boolean*) any1->_value) == (*(boolean*)any2->_value);
    case yotkChar:
      return (*(char*) any1->_value) == (*(char*)any2->_value);
    case yotkString:
      return !strcmp( (char*)any1->_value, (char*)any2->_value);
    case yotkNull:
      return TRUE;
    case yotkLongLong:
      return sysb8cmp((sysb8*)any1->_value, ==, (sysb8*)any2->_value);
    default:
      return FALSE;
  }
}





STATICF void yrCmpIntfLdBlk( yrldblk* ldblk, boolean externok)
{
  yslst* lst1;
  yslst* lst2;
  ysle* le1;
  ysle* le2;
  yrobj* newobj = ldblk->newobj;
  yrobj* oldobj = ldblk->existing;
  sword len1, len2;

  ldblk->equal = FALSE;
  ldblk->merge = FALSE;

  if ((yrInterfaceData(newobj).defined != 
	   yrInterfaceData(oldobj).defined))
  {          
    if ( yrObjCommonIsEq( newobj, oldobj) )
    {
      if ( yrInterfaceData(newobj).defined )
	ldblk->merge = TRUE;
      
      ldblk->equal = TRUE;
    }
    else
      ldblk->equal = FALSE;
    return;
  }
  

  
  lst1 = yrInterfaceData(newobj).bases;
  lst2 = yrInterfaceData(oldobj).bases;
  len1 = (lst1 ? ysLstCount(lst1) : 0);
  len2 = (lst2 ? ysLstCount(lst2) : 0);
  if ( len1 != len2 )
    return;

  if ( len1 > 0 )              
  {
    le2 = ysLstHead(lst2);
    for (le1 = ysLstHead(lst1); le1; le1 = ysLstNext(le1))
    {
      if ( ysLstVal(le1) != ysLstVal(le2) )
        return;
      le2 = ysLstNext(le2);
    }
  }

  if ( yrContentsEq( newobj, oldobj) )       
    ldblk->equal = TRUE;
}





STATICF boolean yrContentsEq( yrobj* obj1, yrobj* obj2)
{
  boolean mismatch = FALSE;
  yslst* lst1 = yrGetContents(obj1);
  yslst* lst2 = yrGetContents(obj2);
  ysle* le1;

  if ( ysLstCount(lst1) != ysLstCount(lst2) )
    return FALSE;

  for (le1 = ysLstHead(lst1); le1 && !mismatch; le1 = ysLstNext(le1))
  {
    yrobj* m1 = (yrobj*) ysLstVal(le1);
    yslst* matches;

    matches = yrLookupName( obj2, yrGetName(m1), YR_SHALLOW_LOOKUP,
			      yrGetKind(m1), FALSE);
    if ( !matches || (ysLstCount(matches) != 1) ||
	 (ysLstDeq(matches) != (dvoid*) m1) )
    {
      mismatch = TRUE;
    }
    if ( matches )
      ysLstDestroy( matches, (ysmff)0);
  }
  return !mismatch;
}





STATICF void yrCmpOpLdBlk( yrldblk* ldblk, boolean externok)
{
  yslst* lst1;
  yslst* lst2;
  ysle* le1;
  ysle* le2;
  yrobj* newobj = ldblk->newobj;
  yrobj* oldobj = ldblk->existing;
  boolean mismatch;

  ldblk->merge = FALSE;
  ldblk->equal = (yrObjCommonIsEq(newobj, oldobj) &&
      (yrOpData(newobj).mode == yrOpData(oldobj).mode) &&
      (yrOpData(newobj).rettype == yrOpData(oldobj).rettype));

  if ( ldblk->equal )      
  {
    lst1 = yrOpData(newobj).pars;
    lst2 = yrOpData(oldobj).pars;

    if ( lst1 && lst2 && (ysLstCount(lst1) == ysLstCount(lst2)) )
    {
      mismatch = FALSE;
      le2 = ysLstHead(lst2);
      for (le1 = ysLstHead(lst1); le1; le1 = ysLstNext(le1))
      {
	yrpar* par1 = (yrpar*) ysLstVal(le1);
	yrpar* par2 = (yrpar*) ysLstVal(le2);

	if ( (par1->mode != par2->mode) ||
	     (par1->type != par2->type) ||
	     strcmp( par1->name, par2->name) )
	{
	  mismatch = TRUE;
	  break;
	}
        le2 = ysLstNext(le2);
      }
      ldblk->equal = !mismatch;
    }
    else if ( lst1 != lst2 )
      ldblk->equal = FALSE;
  }

  if ( ldblk->equal )      
  {
    lst1 = yrOpData(newobj).raises;
    lst2 = yrOpData(oldobj).raises;

    if ( lst1 && lst2 && (ysLstCount(lst1) == ysLstCount(lst2)) )
    {
      mismatch = FALSE;
      le2 = ysLstHead(lst2);
      for (le1 = ysLstHead(lst1); le1; le1 = ysLstNext(le1))
      {
	if ( ysLstVal(le1) != ysLstVal(le2) )
	{
	  mismatch = TRUE;
	  break;
	}
        le2 = ysLstNext(le2);
      }
      ldblk->equal = !mismatch;
    }
    else if ( lst1 != lst2 )
      ldblk->equal = FALSE;
  }
}





STATICF void yrCmpLdBlk( yrldblk* ldblk, boolean externok)
{
  yrobj* newobj;
  yrobj* oldobj;

  if ( ldblk->existing )
  {
    newobj = ldblk->newobj;
    oldobj = ldblk->existing;

    if ( newobj->defined && oldobj->defined )
    {
      
      ldblk->merge = FALSE;
      ldblk->equal = FALSE;
    }
    else if ( externok )
    {
      ldblk->merge = (newobj->defined ? TRUE : FALSE);
      ldblk->equal = TRUE;
      return;
    }
    else 
      yseThrowObj(YR_EX_UNDEFINED, ldblk->newobj->repid);
  }
  else        
  {
    ldblk->merge = TRUE;
    ldblk->equal = FALSE;
    return;
  }

  

  ysRecord( YR_MSG(423, YR_FAC), YSLSEV_DEBUG(5), (char*)0, 
            YSLPTR(newobj), YSLPTR(oldobj), YSLEND);
  if ( yrGetKind(newobj) == yrGetKind(oldobj) )
  {
    switch ( yrGetKind(newobj) )
    {
      case yrdkRepository:
	ldblk->equal = FALSE;
        break;

      case yrdkAttribute:
	ldblk->equal = ( yrObjCommonIsEq(newobj, oldobj) &&
		       (yrAttrData(newobj).mode == yrAttrData(oldobj).mode) &&
                       (yrAttrData(newobj).type ==  yrAttrData(oldobj).type) &&
		       (yrGetDefinedIn(newobj) == yrGetDefinedIn(oldobj)) );
        break;

      case yrdkConstant:
	ldblk->equal = 
             ( yrObjCommonIsEq(newobj, oldobj) &&
	      (yrConstData(newobj).type == yrConstData(oldobj).type) &&
	      yrAnyEq( &yrConstData(newobj).val, &yrConstData(oldobj).val) );
        break;

      case yrdkInterface:
        yrCmpIntfLdBlk( ldblk, externok);
        break;

      case yrdkModule:
        ldblk->equal = yrObjCommonIsEq( newobj, oldobj);
        ldblk->merge = TRUE;
        break;

      case yrdkOperation:
        yrCmpOpLdBlk( ldblk, externok);
        break;
   
      case yrdkException:
      case yrdkStruct:
      case yrdkUnion:
      {
	CONST yotk* tc1 = yrGetTypeCode(newobj);
	CONST yotk* tc2 = yrGetTypeCode(oldobj);
	ldblk->equal = yotkIsEq( tc1, tc2) && yrContentsEq( newobj, oldobj);
        break;
      }
      case yrdkAlias:
      case yrdkEnum:
      {
	CONST yotk* tc1 = yrGetTypeCode(newobj);
	CONST yotk* tc2 = yrGetTypeCode(oldobj);
	ldblk->equal = yotkIsEq( tc1, tc2);
        break;
      }
   
      case yrdkPrimitive:
	ldblk->equal = (yrPrimData(newobj).kind == yrPrimData(oldobj).kind);
        break;
   
      case yrdkString:
	ldblk->equal = (yrStringData(newobj).bound == 
                              yrStringData(oldobj).bound );
        break;
   
      case yrdkSequence:
	ldblk->equal = ((yrSeqData(newobj).bound == yrSeqData(oldobj).bound) &&
            (yrSeqData(newobj).elmtype == yrSeqData(oldobj).elmtype));
        break;
   
      case yrdkArray:
	ldblk->equal = 
               ((yrArrayData(newobj).length == yrArrayData(oldobj).length) &&
                (yrArrayData(newobj).elmtype == yrArrayData(oldobj).elmtype));
        break;
   
      default:
	ldblk->equal = FALSE;
        break;
    }
  }
  else
    ldblk->equal = FALSE;

  if ( !ldblk->equal )
  {
    yseThrowObj( YR_EX_REDEFINED, ldblk->newobj->repid);
  }
}





STATICF void yrMergeObjs( yrobj* newobj, yrobj* oldobj)
{
  ysle* le;

    
  if ( !oldobj )
  {
    yrobj* container = yrGetDefinedIn(newobj);

    if ( yrGetKind( container) == yrdkRepository )
    {
      ysRecord( YR_MSG(422, YR_FAC), YSLSEV_DEBUG(3), (char*)0, 
                YSLPTR(newobj), YSLEND);
      switch ( yrGetKind(newobj) )
      {
        case yrdkSequence:
        case yrdkArray:
        case yrdkString:
          ysLstEnq( yrRepData(container)->anon, (dvoid*) newobj);
          break;
        default:
          yrContainerAdd( container, newobj);
      }
    }
    
  }

    
  else if ( yrGetKind(newobj) == yrdkInterface )
  {
    yrintf* data;

    ysRecord( YR_MSG(418, YR_FAC), YSLSEV_DEBUG(3), (char*)0, 
              YSLPTR(newobj), YSLPTR(oldobj), YSLEND);
    if ( oldobj->contents )          
      ysLstDestroy( oldobj->contents, (ysmff)0);
    oldobj->contents = newobj->contents;

    data = &(yrInterfaceData(oldobj));
    if ( data->bases )               
      ysLstDestroy( data->bases, (ysmff)0);
    if ( data->ops )               
      ysLstDestroy( data->ops, (ysmff)0);
    if ( data->attrs )               
      ysLstDestroy( data->attrs, (ysmff)0);
    DISCARD memcpy( data, &newobj->data.intfval, sizeof(yrintf));

        
    newobj->contents = (yslst*)0;
    CLRSTRUCT( newobj->data.intfval);
  }

    
  else if ( yrGetKind(newobj) ==  yrdkModule )
  {
    ysRecord( YR_MSG(419, YR_FAC), YSLSEV_DEBUG(3), (char*)0, 
              YSLPTR(newobj), YSLPTR(oldobj), YSLEND);
    for ( le = ysLstHead( yrGetContents(newobj)); le; le = ysLstNext(le))
    {
      yrobj* mem = (yrobj*) ysLstVal(le);
      yslst* matches;

      matches = yrLookupName( oldobj, yrGetName(mem), YR_SHALLOW_LOOKUP,
                              yrGetKind(mem), FALSE);

      if ( matches )
        ysLstDestroy( matches, (ysmff)0);   
      else
        yrContainerAdd( oldobj, mem);
    }
  }
}





void yrMergeFile( yrldblk* data, ub4 nobjs, boolean externok)
{
  volatile boolean ok;
  yslst* volatile undefined = (yslst*)0;
  yslst* volatile redefined = (yslst*)0;
  ub4 i;

  ok = TRUE;
  ysRecord( YR_MSG(420, YR_FAC), YSLSEV_DEBUG(1), (char*)0, YSLNONE);
  yseTry
  {
    for ( i = 1; ok && (i < nobjs); i++)
      yrCmpLdBlk( &data[i], externok);
  }
  yseCatchObj( YR_EX_UNDEFINED, char*, undef)
  {
    if ( !undefined )
      undefined = ysLstCreate();
    ysLstEnq( (yslst*) undefined, (dvoid*) undef);
    if ( ysLstCount( (yslst*)undefined) >= yr_mgr_err_max )
      ok = FALSE;
  }
  yseCatchObj( YR_EX_REDEFINED, char*, redef)
  {
    ok = FALSE;
    if ( !redefined )
      redefined = ysLstCreate();
    ysLstEnq( (yslst*) redefined, (dvoid*) redef);
    if ( ysLstCount( (yslst*)redefined) >= yr_mgr_err_max )
      ok = FALSE;
  }
  yseEnd

  if ( undefined || redefined )
  {
    
    yr_mgr_LoadConflict ex = {0, {0,0,0},{0,0,0}};
    yr_repid* p;
    yr_repid s;

    if ( undefined )
    {
      ex.undefined._length = ysLstCount(undefined);
      p = (yr_repid*) yoAlloc( sizeof(yr_repid) * ex.undefined._length);
      ex.undefined._buffer = p;
    
      while ( (s = ysLstDeq(undefined)) )
      {
        *p = (yr_repid) ysStrDupWaf((char*) s, yoAlloc);
        p++;
      }
      ysLstDestroy( undefined, (ysmff)0);
    }
    if ( redefined )
    {
      ex.filename = (char*)0;
      ex.redefined._length = ysLstCount(redefined);
      p = (yr_repid*) yoAlloc( sizeof(yr_repid) * ex.redefined._length);
      ex.redefined._buffer = p;
    
      while ( (s = ysLstDeq(redefined)) )
      {
        *p = (yr_repid) ysStrDupWaf((char*) s, yoAlloc);
        p++;
      }
      ysLstDestroy( redefined, (ysmff)0);
    }
    yseThrowObj( YR_MGR_EX_LOADCONFLICT, ex);
  }

  else    
  {
    const char* dbg;

    ysRecord( YR_MSG(421, YR_FAC), YSLSEV_DEBUG(1), (char*)0, YSLNONE);
    if ( (nobjs > 1) && (dbg = ysResGetLast("mnirsrv.debug-trace")) &&
         (strcmp(dbg, "5") >= 0) )
    {                                   
      ysRecord( YR_MSG(424, YR_FAC), YSLSEV_DEBUG(5), (char*)0, YSLNONE);
      for ( i = 1; i < nobjs; i++)
      {
        ysRecord( YR_MSG(425, YR_FAC), YSLSEV_DEBUG(5), (char*)0, 
                  YSLSB4(i), YSLSB4(data[i].merge), YSLSB4(data[i].visited),
                  YSLSB4(data[i].equal), YSLPTR(data[i].newobj),
                  YSLPTR(data[i].existing), YSLEND);
      }
      ysRecord( YR_MSG(426, YR_FAC), YSLSEV_DEBUG(5), (char*)0, YSLNONE);
    }

    for ( i = 1; i < nobjs; i++)
    {
      if ( data[i].merge && !data[i].visited )
      {
        data[i].visited = TRUE;
        yrMergeObjs( data[i].newobj, data[i].existing);
      }
    }
  }
}




void yrFreeMergeData( yrldblk* data, ub4 nobjs)
{
  ub4 i;

  for ( i = 0; i < nobjs; i++ )
  {
    if ( !data[i].merge || data[i].existing )      
      yrDestroyObj( data[i].newobj, (yslst*)0, (ysmff)0, (ysmff)0);
  }
}
