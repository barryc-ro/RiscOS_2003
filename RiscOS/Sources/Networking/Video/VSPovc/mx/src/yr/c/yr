/* mx/src/yr/yr.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


#ifndef SYSX_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif
#ifndef YR_ORACLE
#include <yr.h>
#endif
#ifndef YR0_ORACLE
#include <yr0.h>
#endif


externdef ysidDecl(YR_EX_AMBIGUOUS) = "::YR_EX_AMBIGUOUS";
externdef ysidDecl(YR_EX_BADNAME) = "::YR_EX_BADNAME";
externdef ysidDecl(YR_EX_CONFLICT) = "::YR_EX_CONFLICT";
externdef ysidDecl(YR_EX_MULTIPLE) = "::YR_EX_MULTIPLE";
externdef ysidDecl(YR_EX_NOTFOUND) = "::YR_EX_NOTFOUND";
externdef ysidDecl(YR_EX_BADTYPE) = "::YR_EX_BADTYPE";
externdef ysidDecl(YR_EX_REPFULL) = "::YR_EX_REPFULL";
externdef ysidDecl(YR_EX_EXISTS) = "::YR_EX_EXISTS";
externdef ysidDecl(YR_EX_INVALIDID) = "::YR_EX_INVALIDID";
externdef ysidDecl(YR_EX_UNDEFINED) = "::YR_EX_UNDEFINED";
externdef ysidDecl(YR_EX_REDEFINED) = "::YR_EX_REDEFINED";
externdef ysidDecl(YR_EX_PSEUDO) = "::YR_EX_PSEUDO";


STATICF void yrSearchContainer( yrobj* or, CONST char* name, sb4 levels,
				yrdk limit_type, boolean exclude_inherited,
				yslst* matches);




void yrSetName( yrobj* obj, CONST char* name)
{
  char* newName = (char*) ysmGlbAlloc(strlen(name) + 1, "yrobjName");
  DISCARD strcpy(newName, name);
  obj->name = newName;
}





void yrSetSrcnm( yrobj* obj, CONST char* name)
{
  char* newName = (char*) ysmGlbAlloc(strlen(name) + 1, "yrobjName");
  DISCARD strcpy(newName, name);
  obj->srcnm = newName;
}



void yrDestroyRepository( yrobj* robj, ysmff usrpFree, ysmff objFree)
{
  yslst* deferred = ysLstCreate();
  yrobj* o;

  yrDestroyObj( robj->repository, deferred, usrpFree, objFree);
  while ( (o = (yrobj*) ysLstDeq(deferred)) )
    yrDestroyObj( o, deferred, usrpFree, objFree);
  ysLstDestroy( deferred, (ysmff)0);
}






char *yrGetAbsoluteName(yrobj *or)
{
  yslst* comps; 		
  yrobj* o;
  ub4 len = 0;			
  char* name;
  ysle* le;
  char* elemName = (dvoid*)0;
  char* p;

  if ( (or->tag == yrdkArray) || (or->tag == yrdkRepository) )
    return (char*) 0;	
  else
    comps = ysLstCreate();

  if ( or == yrRepData(or->repository)->object )
    or = yrRepData(or->repository)->corba_object;

    
  for ( o = or; o->tag != yrdkRepository; o = o->defined_in )
  {			 
    ysLstPush(comps, (dvoid*) o->name);
    len += strlen(o->name);
  }

    
  if ( or->tag == yrdkSequence )
  {
    char* seqName;

    elemName = yrGetAbsoluteName( or->data.seqval.elmtype);
    seqName = ysmGlbAlloc( strlen(elemName) + 11, "seqName");
    ysFmtStr( seqName, "sequence<%s>", elemName);
    ysmGlbFree( elemName);
    elemName = seqName;

    DISCARD ysLstDeq( comps);			
    ysLstEnq( comps, (dvoid*) elemName);	
    len += strlen(elemName);
  }
  else if ( or->tag == yrdkString )
  {
    DISCARD ysLstDeq( comps);			
    ysLstEnq( comps, (dvoid*) "string");
    len += 6;
  }

  len += ysLstCount(comps) * 2;			
  name = (char*) ysmGlbAlloc( (size_t)len+1, "absName");
  name[0] = '\0';

	
  for (p = name, le = ysLstHead(comps); le; le = ysLstNext(le))
  {
    char* n = (char*) ysLstVal(le);

    p[0] = ':';
    p[1] = ':';
    p += 2;
    DISCARD strcpy( p, n);
    p += strlen(n);
  }

  if ( or->tag == yrdkSequence )
    ysmGlbFree( elemName);
  ysLstDestroy(comps, (ysmff)0);

  return name;
}





void yrParseScopedName( CONST char* scoped, char** buff, yslst** ptrs)
{
  char* p1;
  char* p2;
  char* parseBuff;		
  yslst* comps;			

  if ( scoped == (char*)0 )
    yseThrow(YR_EX_BADNAME);	

  if ( strncmp(scoped, YR_SCOPED_SEP, YR_SCOPED_SEP_SIZE) == 0 )
  {	
    parseBuff = ysmGlbAlloc( strlen(scoped)+2, "scopedName");
    strncpy( parseBuff, scoped, YR_SCOPED_SEP_SIZE);
    parseBuff[YR_SCOPED_SEP_SIZE] = '\0';
    strcpy( parseBuff+YR_SCOPED_SEP_SIZE+1, scoped+YR_SCOPED_SEP_SIZE);
    p1 = parseBuff + YR_SCOPED_SEP_SIZE + 1;
  }
  else
  {
    parseBuff = ysmGlbAlloc( strlen(scoped)+1, "scopedName");
    strcpy( parseBuff, scoped);
    p1 = parseBuff;
  }
  comps = ysLstCreate();

  while (*p1)
  {
    ysLstEnq( comps, (dvoid*) p1);
    p2 = strstr(p1, YR_SCOPED_SEP);
    if ( p2 )
    {
      p1 += (p2 - p1) + YR_SCOPED_SEP_SIZE;
      *p2 = '\0';		
    }
    else
      break;
  } 
  if ( *p1 == '\0' )		
  {
    ysLstDestroy( comps, (ysmff)0);
    ysmGlbFree( parseBuff);
    yseThrow( YR_EX_BADNAME);
  }
  *buff = parseBuff;
  *ptrs = comps;
}





yslst *yrContents(yrobj *or, yrdk limit_type, boolean exclude_inherited)
{
  yslst* result = ysLstCreate();
  ysle* le;

  if ( or->contents != (yslst*)0 )
  {
    for (le = ysLstHead(or->contents); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);

      if ( ((limit_type == yrdkall) || (obj->tag == limit_type)) &&
	  (!exclude_inherited || (obj->defined_in == or)) )
      {
        if ( obj != yrRepData(or->repository)->object )
	  ysLstEnq(result, (dvoid*) obj);
      }
    }
  }
  return result;
}





yrobj *yrLookupId(yrobj *repository, CONST char *repid)
{
  ysle* le;
  yrobj* result = (yrobj*) 0;

  if ( !repid || (strlen(repid) == 0) || !repository->contents )
    return (yrobj*) 0;

  for ( le = ysLstHead(repository->contents); le; le = ysLstNext(le))
  {
    yrobj* obj = (yrobj*) ysLstVal(le);

    if ( strcmp( obj->repid, repid) == 0 )
    {
      result = obj;
      break;
    }
    else if ( yrIsContainer(obj) )     
    {
      result = yrLookupId( obj, repid);
      if ( result )
        break;
    }
  }

  if ( result == yrRepData(repository->repository)->object )
    result = yrRepData(repository->repository)->corba_object;
  return result;
}





yrobj *yrGetPrimitive(yrobj *repository, yrpk kind)
{
  yrobj* match = (yrobj*)0;
  ysle* le;
  yslst* decls = repository->repository->contents;

  if ( decls != (yslst*)0 )
  {
    for ( le = ysLstHead(decls); le; le = ysLstNext(le) )
    {
      yrobj* obj = (yrobj*) ysLstVal(le);
      if ( (obj->tag == yrdkPrimitive) && (obj->data.pval.kind == kind) )
      {
        match = obj;
        break;
      }
    }
  }
  
  if ( !match )
    match = yrCreatePrimitive( repository, kind);
  return match;
}





void yrAddBase(yrobj *intf, yrobj *base)
{
  ysle* le;
  yslst* matches;

  if ( base->tag == yrdkAlias )
    base = yrGetAliasBaseType( base);

  if ( (base == yrRepData( intf->repository)->object) ||
       (base == yrRepData( intf->repository)->corba_object) )
    yseThrow( YR_EX_PSEUDO);         

  if ( (intf->tag == yrdkInterface) && (base->tag == yrdkInterface) )
  {
    if ( intf->data.intfval.bases == (yslst*)0 )
       intf->data.intfval.bases = ysLstCreate();

      
    for (le = ysLstHead(intf->data.intfval.bases); le; le = ysLstNext(le))
      if ( ((yrobj*) ysLstVal(le)) == base )
	yseThrow(YR_EX_MULTIPLE);

      
    ysLstEnq(intf->data.intfval.bases, (dvoid*) base);
    if ( base->contents )
    {
      for ( le = ysLstHead( base->contents); le; le = ysLstNext(le))
      {		
        yrobj* mem = (yrobj*) ysLstVal(le);
	matches = yrLookupName( intf, mem->name, YR_SHALLOW_LOOKUP, 
				mem->tag, FALSE);
        if ( matches )
        {
          if ( (ysLstCount( matches) == 1) && (mem->defined_in == 
		((yrobj*)ysLstVal(ysLstHead( matches)))->defined_in) )
             ysLstDestroy( matches, (ysmff)0);	
	  else if ( (mem->tag == yrdkOperation) || (mem->tag == yrdkAttribute))
	  {		
	    ysLstPush( matches, (dvoid*) mem);
	    yseThrowObj( YR_EX_CONFLICT, matches);
          }
          else
          {	
            ysle* ce;	
            ysle* me;	
          
	    for ( me = ysLstHead( matches); me; me = ysLstNext(me))
            {
              yrobj* match = (yrobj*) ysLstVal(me);
	      for ( ce = ysLstHead( intf->contents); ce; ce = ysLstNext(ce))
		if ( (yrobj*)ysLstVal(ce) == match )
		{	
		  ysLstRem( intf->contents, ce);
		  break;
		}
            }
            ysLstDestroy( matches, (ysmff)0);
          }
        }  
	else	
          yrContainerAdd( intf, mem);
      }
    }
  }
  else		
  {
    yrdk kind = yrdkInterface;
    yseThrowObj( YR_EX_BADTYPE, kind);
  }
}





yrobj* yrGetAliasBaseType( yrobj* alias)
{
  while ( alias->tag == yrdkAlias )
    alias = alias->data.aval.type;
  return alias;
}






yrobj *yrLookup(yrobj *or, CONST char *scoped)
{
  yslst* comps;		
  char* parseBuff;	
  ysle* le;
  yslst* matches;
  boolean foundOuter;	

    
  yrParseScopedName( scoped, &parseBuff, &comps);
  if ( strcmp(YR_SCOPED_SEP, (char*)ysLstVal( ysLstHead(comps))) == 0 )
  {	
    or = or->repository;
    ysLstPop(comps);
  }

    
  foundOuter = FALSE;
  for (le = ysLstHead(comps); le; le = ysLstNext(le))
  {
    CONST char* name = (char*) ysLstVal(le);
    do
    {
      matches = yrLookupName( or, name, (sb4)1, yrdkall, FALSE);
      if ( !matches || (ysLstCount( matches) == 0) )
      {					
	  if ( matches )
	    ysLstDestroy(matches, (ysmff)0);
	  if ( foundOuter || or->tag == yrdkRepository )
	  {
	    ysLstDestroy(comps, (ysmff)0);
	    ysmGlbFree( parseBuff);
	    yseThrow(YR_EX_NOTFOUND);
          }
	  else if ( !foundOuter )	
	    or = or->defined_in;	
	  
      }
      else if ( ysLstCount(matches) == 1 )
      {					
	foundOuter = TRUE;		
	or = (yrobj*) ysLstVal( ysLstHead(matches));
	ysLstDestroy(matches, (ysmff)0);
      }
      else				
      {
	ysLstDestroy(comps, (ysmff)0);
	ysmGlbFree( parseBuff);
	yseThrowObj(YR_EX_AMBIGUOUS, matches);
      }
    } while ( !foundOuter );
  }

  ysLstDestroy(comps, (ysmff)0);
  ysmGlbFree( parseBuff);

  if ( or == yrRepData(or->repository)->object )
    or = yrRepData(or->repository)->corba_object;
  return or;
}




STATICF void yrSearchContainer( yrobj* or, CONST char* name, sb4 levels,
			yrdk limit_type, boolean exclude_inherited,
			yslst* matches)
{
  ysle* le;

  if ( or->tag == yrdkAlias )
    or = yrGetAliasBaseType( or);
  
  if ( or->contents && yrIsContainer( or) )
  {
    boolean checkInherited = !(exclude_inherited&&(or->tag == yrdkInterface));
    boolean checkKind = limit_type != yrdkall;

    for (le = ysLstHead(or->contents); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);
      if ( (checkInherited || (obj->defined_in == or)) &&
	   ( !checkKind || (obj->tag == limit_type)) &&
	   (strcmp( name, obj->name) == 0) )
      {
        if ( (or->tag == yrdkRepository) &&
             ( obj == yrRepData(or)->object) )
	  ysLstEnq( matches, (dvoid*)yrRepData(or)->corba_object);
        else
	  ysLstEnq( matches, (dvoid*)obj);
      }
      if ( levels == YR_DEEP_LOOKUP )
	yrSearchContainer( obj, name, levels, limit_type, 
			   exclude_inherited, matches);
    }
  }
  return;
}




yslst *yrLookupName(yrobj *or, CONST char *name, sb4 levels,
                    yrdk limit_type, boolean exclude_inherited)
{
  yslst* result = ysLstCreate();

  yrSearchContainer( or, name, levels, limit_type, exclude_inherited, result);
  if ( ysLstCount( result) == 0 )
  {
    ysLstDestroy( result, (ysmff)0);
    result = (dvoid*) 0;
  }
  return result;
}





char* yrGetPrimitiveName( yrpk kind )
{
  char* name = ysmGlbAlloc( 15, "primitive name");
  			
  switch ( kind )
  {
    case yrpkvoid:     strcpy( name, "void"); break;
    case yrpkshort:    strcpy( name, "short"); break;
    case yrpklong:     strcpy( name, "long"); break;
    case yrpkushort:   strcpy( name, "unsigned short"); break;
    case yrpkulong:    strcpy( name, "unsigned long"); break;
    case yrpkfloat:    strcpy( name, "float"); break;
    case yrpkdouble:   strcpy( name, "double"); break;
    case yrpkboolean:  strcpy( name, "boolean"); break;
    case yrpkchar:     strcpy( name, "char"); break;
    case yrpkoctet:    strcpy( name, "octet"); break;
    case yrpkany:      strcpy( name, "any"); break;
    case yrpkstring:   strcpy( name, "string"); break;
    case yrpkTypeCode: strcpy( name, "TypeCode"); break;
    case yrpklonglong: strcpy( name, "long long"); break;
    default:
      yseThrow(YS_EX_FAILURE);
  }
  return name;
}





void yrAssignId( yrobj* scope, yrobj* obj, boolean usePrefix)
{
  char* newid;

  if ( obj->repid )		
    yseThrow( YR_EX_EXISTS);

  if ( obj->tag == yrdkPrimitive )
  {
    newid = ysmGlbAlloc( 9, "yrid");    
    ysFmtStr( newid, "LOCAL:%u", yrPrimData(obj).kind);
  }

  else if ( usePrefix )              
  {
    char* pfx = scope->prefix ? scope->prefix : "";
    yslst* names;
    ysle* le;
    sword namesz = 0;
    char* p;
    CONST char* vers = (obj->version && (strlen(obj->version) > (size_t)0)) ?
                       obj->version : "1.0";

      
    names = yrGetNameComponents(obj);
    for (le = ysLstHead(names); le; le = ysLstNext(le))
      namesz += strlen( yrGetName( (yrobj*)ysLstVal(le))) + 1;
    namesz--;                          

    newid = ysmGlbAlloc( strlen(pfx) + namesz + strlen(vers) + 6, "yrid");
    ysFmtStr( newid, "IDL:%s", pfx);
      
    p = newid + strlen(newid);
    for (le = ysLstHead(names); le; le = ysLstNext(le))
    {
      yrobj* o = (yrobj*) ysLstVal(le);

      DISCARD strcpy( p, yrGetName(o));
      p += strlen(yrGetName(o));
      *p = '/';
      p++;
    }
    ysLstDestroy( names, (ysmff)0);
      
    ysFmtStr( p - 1, ":%s", vers);      
  }
  else                                  
  {
    char seq[25];
    yrobj* rep = scope->repository;

    if ( yrRepData(rep)->seqnum == YR_SEQ_MAX )
      yseThrow( YR_EX_REPFULL );
    ysFmtStrl( seq, 25, "%u", yrRepData(rep)->seqnum);
    newid = ysmGlbAlloc( strlen(seq) + 7, "yrid");
    ysFmtStr( newid, "LOCAL:%s", seq);
    yrRepData(rep)->seqnum++;
  }
  obj->repid = (yrid*) newid;
}





yslst* yrGetNameComponents( yrobj* obj)
{
  yslst* comps;
  yrobj* o;

  if ( obj->tag == yrdkRepository )
    yseThrow( YR_EX_BADTYPE);

  if ( obj == yrRepData(obj->repository)->object )
    obj = yrRepData(obj->repository)->corba_object;
  comps = ysLstCreate();
  for (o = obj; o->tag != yrdkRepository; o = o->defined_in)
  {
    ysLstPush(comps, (dvoid*)o);
  }
  return comps;
}





void yrSetSrcInfo( yrobj* obj, CONST char* srcnm, sword lineno)
{
  if ( (obj->tag != yrdkRepository) && (obj->tag != yrdkPrimitive) )
  {
    if ( srcnm != (char*)0 )
    {
      char* newName = (char*) ysmGlbAlloc(strlen(srcnm) + 1, "yrsrcnm");
      DISCARD strcpy(newName, srcnm);
      if ( obj->srcnm )
        ysmGlbFree( obj->srcnm);
      obj->srcnm = newName;
    }
    obj->line = lineno;
  }
  else
    yseThrow( YR_EX_BADTYPE);
}




void yrSetId( yrobj* obj, CONST char* newid)
{
  CONST char* p;
  sword fmtsz;

  if ( obj == (dvoid*)0 )
    return;

  switch ( yrGetKind(obj) )
  {
    case yrdkRepository:
    case yrdkPrimitive:
    case yrdkSequence:
    case yrdkArray:
    case yrdkString:
      yseThrow( YR_EX_BADTYPE);
      break;
    default:
      for ( p = newid; *p != '\0'; p++)        
        if ( *p == ':' )
          break;
      if ( *p == '\0' )
        yseThrow( YR_EX_INVALIDID);
      fmtsz = p - newid;
      if ( !((fmtsz == 3) && ((strncmp(newid, "IDL", fmtsz) == 0) ||
	     (strncmp(newid, "DCE", fmtsz)))) &&
	   !((fmtsz == 5) && (strncmp( newid, "LOCAL", fmtsz) == 0)) )
	yseThrow( YR_EX_INVALIDID);

      if ( obj->repid )
	ysmGlbFree( obj->repid);
      for ( p++; *p != '\0'; p++)        
        if ( *p == ':' )
          break;

      if ( *p == '\0' )                        
      {
        obj->repid = (char*) ysmGlbAlloc( strlen(newid) + 5, "repid");
        DISCARD ysFmtStr( obj->repid, "%s:1.0", newid);
      }
      else                                     
      {
	obj->repid = (char*) ysmGlbAlloc( strlen(newid) + 1, "repid");
	DISCARD strcpy( obj->repid, newid);
      }
      break;
  }
}





void yrSetPrefix( yrobj* obj, CONST char* prefix)
{
  if ( !prefix )
    return;
  if ( yrIsContainer( obj) )
  {
    size_t newsz = strlen(prefix) + 1;
    if ( obj->prefix )
    {
      if ( newsz >= strlen(obj->prefix) )
        ysmGlbRealloc( obj->prefix, newsz);
      
    }
    else
      obj->prefix = (char*) ysmGlbAlloc(newsz, "yrpfx");
    DISCARD strcpy( obj->prefix, prefix);
  }
  else
    yseThrow( YR_EX_BADTYPE);
}





void yrSetVersion( yrobj* obj, CONST char* newver)
{
  if ( obj == (dvoid*)0 )
    return;

  switch ( yrGetKind(obj) )
  {
    case yrdkRepository:
    case yrdkPrimitive:
    case yrdkSequence:
    case yrdkArray:
    case yrdkString:
      yseThrow( YR_EX_BADTYPE);
      break;
    default:
    {
      if ( obj->version )
	ysmGlbFree( obj->version);
      obj->version = (char*) ysmGlbAlloc( strlen(newver) + 1, "yrvers");
      DISCARD strcpy( obj->version, newver);

      if ( obj->repid )               
      {
	char* p;
        sword oldIdSz = strlen(obj->repid);
        for (p = obj->repid + oldIdSz - 1; p != obj->repid; p--)
          if ( *p == ':' )
            break;
        if ( p != obj->repid )        
        {
          sword vdiff;
          sword vstart;

          p++;                       
          vdiff = strlen(newver) - strlen(p+1);
          if ( vdiff > 0 )           
          {
	    vstart = p - obj->repid;      
            obj->repid = ysmGlbRealloc( obj->repid, oldIdSz + vdiff + 1);
            p = obj->repid + vstart;      
          }
          DISCARD strcpy(p, newver);
        }
        else                          
        {
          obj->repid = ysmGlbRealloc( obj->repid, oldIdSz + strlen(newver) +2);
          obj->repid[oldIdSz] = ':';
          DISCARD strcpy( obj->repid + oldIdSz + 1, newver);
        }
      }
      break;
    }
  }
}





void yrGetAncestors( yrobj* intf, yslst* ancestors)
{
  yslst* bases;
  ysle* le;

  bases = yrInterfaceData(intf).bases;
  if ( !bases || (ysLstCount(bases) == 0) )
    return;

  for ( le = ysLstHead(bases); le; le = ysLstNext(le))
  {
    yrobj* base = (yrobj*) ysLstVal(le);
    boolean doneThat = FALSE;
    ysle* granny;

    for ( granny = ysLstHead(ancestors); granny; granny = ysLstNext(granny))
    {
      if ( base == (yrobj*) ysLstVal(granny) )
      {
        doneThat = TRUE;
        break;
      }
    }
    if ( !doneThat )
    {
      ysLstEnq( ancestors, (dvoid*) base);
      yrGetAncestors( base, ancestors);
    }
  }
}




ysid* yrCreateIntfId( yrobj* intf)
{
  ub4 len;
  yslst* names = ysLstCreate();
  yslst* ancestors = ysLstCreate();
  char* intfnm;
  ysid* p;
  ysid* result;
  char* name;
  yrobj* o;

  len = 0;
  yrGetAncestors( intf, ancestors);
  while ( (o = (yrobj*)ysLstDeq( ancestors)) )
  {
    name = yrGetAbsoluteName(o);
    len += strlen(name) + 1;       
    ysLstEnq(names, (dvoid*) name);
  }
  ysLstDestroy(ancestors, (ysmff)0);

  intfnm = yrGetAbsoluteName(intf);
  len += strlen( intfnm) + 1;       
  result = (ysid*) ysmGlbAlloc( len, "ysid");
  strcpy( result, intfnm);
  p = result + strlen(intfnm);
  ysmGlbFree(intfnm);
  
  while ( (name = (char*) ysLstDeq( names)) )
  {
    DISCARD ysFmtStr(p, "/%s", name);
    p += strlen(name) + 1;
    ysmGlbFree(name);
  }
  *p = '\0';
  ysLstDestroy(names, (ysmff)0);
  return result;
}



boolean yrIsContainer( yrobj* obj)
{
  switch (yrGetKind(obj))
  {
    case yrdkRepository:
    case yrdkModule:
    case yrdkInterface:
    case yrdkStruct:
    case yrdkUnion:
    case yrdkException:
      return TRUE;
    default:
      return FALSE;
  }
}




void yrSetOpCtxtList( yrobj* op, yslst* ctxts)
{
  if ( yrGetKind(op) == yrdkOperation )
  {
    if ( yrOpData(op).ctxts )
    {
      if ( ysLstCount( yrOpData(op).ctxts) == 0 )
      {
        ysLstDestroy( yrOpData(op).ctxts, (ysmff)0);
        yrOpData(op).ctxts = ctxts;
      }
      else
        yseThrow( YR_EX_EXISTS);
    }
    else
      yrOpData(op).ctxts = ctxts;
  }
  else
  {
    yrdk kind = yrdkOperation;
    yseThrowObj( YR_EX_BADTYPE, kind);
  }
}
