/* mx/src/yr/yrread.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


#ifndef SYSX_ORACLE
#include <sysi.h>
#endif
#ifndef SYSXCD_ORACLE
#include <sysxcd.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YR_ORACLE
#include <yr.h>
#endif
#ifndef YR0_ORACLE
#include <yr0.h>
#endif
#ifndef YR0UTIL_ORACLE
#include <yr0util.h>
#endif


typedef dvoid* (*yrdecf)( yrctx*);

STATICF void yrReadObj( yrctx* ctx, ub4 idx);
STATICF boolean yrxReadBV( ysbv* bv, dvoid* usrp);
STATICF char* yrDecString( yrctx* ctx);
STATICF dvoid* yrDecObj( yrctx* ctx);
STATICF void yrDecAny( yrctx* ctx, yoany* any);
STATICF void yrDecNamedObj( yrctx* ctx, yrobj* obj);
STATICF dvoid* yrDecPar( yrctx* ctx);
STATICF dvoid* yrDecUnionMbr( yrctx* ctx);
STATICF dvoid* yrDecStructMbr( yrctx* ctx);
STATICF void yrDecList( yrctx* ctx, yslst** lst, yrdecf decFunc);
STATICF void yrDumpStrTbl( yrctx* ctx, ub4 nstr);
STATICF void yrDumpObjTbl( yrctx* ctx, ub4 nobj);



externdef ysidDecl(YR_EX_BADHDR) = "::YR_EX_BADHDR";
externdef ysidDecl(YR_EX_READ_FAIL) = "::YR_EX_READ_FAIL";




STATICF boolean yrxReadBV( ysbv* bv, dvoid* usrp)
{
  yrctx* ctx = (yrctx*) usrp;
  sword nbytes;

  nbytes = sysfpRead( ctx->fp, bv->buf, YRX_BUFF_SZ);
  bv->len = nbytes;
  if ( nbytes <= 0 )
    return FALSE;
  else
    return TRUE;
}





STATICF char* yrDecString( yrctx* ctx)
{
  ub4 idx;
  CONST char* match;

  idx = ysxGetUB4( ctx->xstr);
  if ( idx == 0 )
    match = "";
  else
    match = ctx->strs.rd[idx];
  return ysStrDup( match);
}




STATICF dvoid* yrDecObj( yrctx* ctx)
{
  sb4 idx;
  yrobj* result;

  idx = (sb4) ysxGetUB4( ctx->xstr);
  if ( idx == 0 )
    result = ctx->repository;      
  else if ( (ub4) idx <= ctx->maxPrim )   
    result =  yrGetPrimitive( ctx->repository, idx);
  else                             
  {
    idx = idx - ctx->maxPrim - 1;
    if ( ctx->objs.rd[idx].existing )
      result = ctx->objs.rd[idx].existing;
    else
      result =  ctx->objs.rd[idx].newobj;
  }
  return (dvoid*) result;
}





STATICF void yrDecAny( yrctx* ctx, yoany* any)
{
  yotkKind kind;
  ub4 len;
  const yotk* tk = any->_type;
  ub1* buf;
  size_t sz;
  ub4 bounds;
  boolean freetc;

    
  sz = ysxGetUB4( ctx->xstr);
  buf = (ub1*) ysmGlbAlloc(sz, "yotk");
  ysxCopy( ctx->xstr, buf, sz);

  tk = (yotk*) buf;
  kind = yotkGetKind(tk);
  freetc = TRUE;
  switch (kind)
  {
    case yotkVoid: 
      any->_type = (yotk *)yoTcVoid; 
      break;
    case yotkShort: 
      any->_type = (yotk *)yoTcShort; 
      break;
    case yotkLong: 
      any->_type = (yotk *)yoTcLong; 
      break;
    case yotkUshort: 
      any->_type = (yotk *)yoTcUshort; 
      break;
    case yotkUlong: 
      any->_type = (yotk *)yoTcUlong; 
      break;
    case yotkFloat: 
      any->_type = (yotk *)yoTcFloat; 
      break;
    case yotkDouble: 
      any->_type = (yotk *)yoTcDouble; 
      break;
    case yotkBoolean: 
      any->_type = (yotk *)yoTcBoolean; 
      break;
    case yotkChar: 
      any->_type = (yotk *)yoTcChar; 
      break;
    case yotkOctet: 
      any->_type = (yotk *)yoTcOctet; 
      break;
    case yotkString:
      bounds = yotkLength(tk);
      if (!bounds)
        any->_type = (yotk*) yoTcString;
      else
      {
        any->_type = tk;
        freetc = FALSE;
      }
      break;
    case yotkAlias:
      kind = yotkGetBaseKind(tk);
      
    case yotkEnum:
      any->_type = tk;
      freetc = FALSE;
      break;
    default:
      break;
  }
  if ( freetc )
    ysmGlbFree( (dvoid*)buf);

    
  tk = any->_type;
  yotkSizeAlign( tk, &sz, (size_t*)0);
  any->_value = ysmGlbAlloc( sz, "any");

  switch (kind)
  {
    case yotkShort:
      *((sb2 *) any->_value) = (sb2) ysxGetUB2(ctx->xstr);
      break;
    case yotkUshort:
      *((ub2 *) any->_value) = ysxGetUB2(ctx->xstr);
      break;
    case yotkLong:
      *((sb4 *) any->_value) = (sb4) ysxGetUB4(ctx->xstr);
      break;
    case yotkEnum:
    case yotkUlong:
      *((ub4 *) any->_value) = ysxGetUB4(ctx->xstr);
      break;
    case yotkBoolean:
      *((boolean *) any->_value) = (boolean) ysxGetUB1(ctx->xstr);
      break;
    case yotkChar:
      *((char *) any->_value) = (char) ysxGetUB1(ctx->xstr);
      break;
    case yotkOctet:
      *((ub1 *) any->_value) = ysxGetUB1(ctx->xstr);
      break;
    case yotkString:
    {
      size_t skip = 0;

      len = ysxGetUB4(ctx->xstr);
      bounds = yotkGetLength(tk);
      if ( !bounds )
      {
        skip = 0;
        if( len )
          *((char **) any->_value) = (char*) ysmGlbAlloc( len, "any");
        else
          *((char **) any->_value) = (char *) 0;
      }
      else if ( len > bounds )
      {
        skip = len - bounds;
        len = bounds;
      }
      if ( len )
      {
        ysxCopy(ctx->xstr, *((ub1 **) any->_value), len);
        ysxSkip(ctx->xstr, skip);
      }
      break;
    }
    case yotkLongLong:
      ysxGetSB8(ctx->xstr, (sysb8 *) any->_value);
      break;
    default:
      yseThrow( YR_EX_BADTYPE);
  }
}



STATICF void yrDecNamedObj( yrctx* ctx, yrobj* obj)
{
  ub4 data;
  char* srcnm;

  srcnm = yrDecString(ctx);
  data = ysxGetUB4( ctx->xstr);     
  yrSetSrcInfo( obj, srcnm, data);
  ysmGlbFree( (dvoid*)srcnm);

   obj->name = yrDecString(ctx);
  obj->version = yrDecString(ctx);

  yrSetDefinedIn( obj, (yrobj*) yrDecObj( ctx));
}




STATICF dvoid* yrDecPar( yrctx* ctx)
{
  yrpar* par;

  par = (yrpar*) ysmGlbAlloc( sizeof(yrpar), "yrpar");
  par->mode = (sword) ysxGetUB4( ctx->xstr);
  par->name = yrDecString( ctx);
  par->type = (yrobj*) yrDecObj( ctx);
  return (dvoid*) par;
}




STATICF dvoid* yrDecUnionMbr( yrctx* ctx)
{
  yrunmbr* mem;

  mem = (yrunmbr*) ysmGlbAlloc( sizeof(yrunmbr), "yrunmbr");
  mem->name = yrDecString( ctx);
  mem->type = (yrobj*) yrDecObj( ctx);
  yrDecAny( ctx, &(mem->label));
  if ( yotkGetKind(mem->label._type) == yotkOctet )         
  {
    ysmGlbFree((dvoid*)mem->label._value);
    mem->label._value = ysmGlbAlloc(sizeof(ub4), "ub4");
    *(ub4*)mem->label._value = (ub4)0;
  }
  return (dvoid*) mem;
}



STATICF dvoid* yrDecStructMbr( yrctx* ctx)
{
  yrstrmbr* mem;

  mem = (yrstrmbr*) ysmGlbAlloc( sizeof(yrstrmbr), "yrstrmbr");
  mem->name = yrDecString( ctx);
  mem->type = (yrobj*) yrDecObj( ctx);
  return (dvoid*) mem;
}




STATICF void yrDecList( yrctx* ctx, yslst** lst, yrdecf decFunc)
{
  ub4 len;
  ub4 i;

  len = ysxGetUB4( ctx->xstr);
  *lst = ysLstCreate();
  for ( i = 0; i < len; i++)
  {
    ysLstEnq( *lst, (*decFunc)(ctx));
  } 
}



STATICF void yrReadObj( yrctx* ctx, ub4 idx)
{
  yrobj* obj;

  obj = ctx->objs.rd[idx].newobj;
  obj->defined = TRUE;    
  obj->repository = ctx->repository;

  ysRecord( YR_MSG(410, YR_FAC), YSLSEV_DEBUG(3), (char*)0, 
            YSLSTR(obj->repid), YSLEND);

  switch ( yrGetKind(obj) )       
  {
    case yrdkAttribute:
      yrDecNamedObj( ctx, obj);
      yrAttrData(obj).mode = (sword) ysxGetUB4( ctx->xstr);
      yrAttrData(obj).type = (yrobj*) yrDecObj( ctx);
      break;

    case yrdkConstant:
      yrDecNamedObj( ctx, obj);
      yrConstData(obj).type = (yrobj*) yrDecObj( ctx);
      yrDecAny( ctx, &(yrConstData(obj).val));
      break;

    case yrdkException:
    case yrdkStruct:
      yrDecNamedObj( ctx, obj);
      yrDecList( ctx, &yrGetContents(obj), yrDecObj);
      yrDecList( ctx, &yrStructData(obj).mbrs, yrDecStructMbr);
      break;

    case yrdkInterface:
    {
      yslst* ops;
      yslst* attrs;
      ysle* le;

      yrDecNamedObj( ctx, obj);
      yrInterfaceData(obj).defined = (boolean) ysxGetUB1( ctx->xstr);
      yrDecList( ctx, &yrInterfaceData(obj).bases, yrDecObj);
      yrDecList( ctx, &yrGetContents(obj), yrDecObj);

      ops = ysLstCreate();
      attrs = ysLstCreate();
      for ( le = ysLstHead(yrGetContents(obj)); le; le = ysLstNext(le))
      {
        yrobj* mem = (yrobj*) ysLstVal(le);

        if ( yrGetKind(mem) == yrdkOperation )
          ysLstEnq(ops, (dvoid*) mem);
        else if ( yrGetKind(mem) == yrdkAttribute )
          ysLstEnq(attrs, (dvoid*) mem);
      }

      if ( ysLstCount(ops) )
        yrInterfaceData(obj).ops = ops;
      else
      {
        yrInterfaceData(obj).ops = (yslst*)0;
        ysLstDestroy( ops, (ysmff)0);
      }

      if ( ysLstCount(attrs) )
        yrInterfaceData(obj).attrs = attrs;
      else
      {
        yrInterfaceData(obj).attrs = (dvoid*)0;
        ysLstDestroy( attrs, (ysmff)0);
      }
      break;
    }

    case yrdkModule:
      yrDecNamedObj( ctx, obj);
      yrDecList( ctx, &yrGetContents(obj), yrDecObj);
      break;

    case yrdkOperation:
      yrDecNamedObj( ctx, obj);
      yrOpData(obj).mode = (sword) ysxGetUB4( ctx->xstr);
      yrOpData(obj).rettype = (yrobj*) yrDecObj( ctx);
      yrDecList( ctx, &yrOpData(obj).raises, yrDecObj);
      yrDecList( ctx, &yrOpData(obj).pars, yrDecPar);
      yrDecList( ctx, &yrOpData(obj).ctxts, (yrdecf)yrDecString);
      break;
    case yrdkAlias:
      yrDecNamedObj( ctx, obj);
      yrAliasData(obj).type = (yrobj*) yrDecObj( ctx);
      break;

    case yrdkUnion:
      yrDecNamedObj( ctx, obj);
      yrDecList( ctx, &yrGetContents(obj), yrDecObj);
      yrUnionData(obj).disctype = (yrobj*) yrDecObj( ctx);
      yrDecList( ctx, &yrUnionData(obj).arms, yrDecUnionMbr);
      break;

    case yrdkEnum:
      yrDecNamedObj( ctx, obj);
      yrDecList( ctx, &yrEnumData(obj).mbrs, yrDecObj);
      break;

    case yrdkString:
      yrStringData(obj).bound = ysxGetUB4( ctx->xstr);
      yrSetName(obj, "");
      obj->defined_in = ctx->repository;
      break;

    case yrdkSequence:
      yrSeqData(obj).bound = ysxGetUB4( ctx->xstr);
      yrSeqData(obj).elmtype = (yrobj*) yrDecObj( ctx);
      yrSetName(obj, "");
      obj->defined_in = ctx->repository;
      break;

    case yrdkArray:
      yrArrayData(obj).length = ysxGetUB4( ctx->xstr);
      yrArrayData(obj).elmtype = (yrobj*) yrDecObj( ctx);
      yrSetName(obj, "");
      obj->defined_in = ctx->repository;
      break;

    
    case yrdkRepository:
    {
      yslst* dummy;

      yrDecList( ctx, &dummy, yrDecObj);              
      ysLstDestroy( dummy, (ysmff)0);
      yrDecList( ctx, &yrGetContents(obj), yrDecObj);   
      yrSetSrcnm(obj, "");
      obj->defined_in = ctx->repository;
      break;
    }

    default:
      yseThrow( YR_EX_BADTYPE);
      break;
  }
}





STATICF void yrDumpStrTbl( yrctx* ctx, ub4 nstr)
{
  ub4 i;

  ysRecord( YR_MSG(403, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
            YSLSTR("STRING"), YSLEND);
  for ( i = 1; i <= nstr; i++ )
    ysRecord( YR_MSG(404, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
              YSLSB4(i), YSLPTR(ctx->strs.rd),YSLSTR(ctx->strs.rd[i]), YSLEND);
  ysRecord( YR_MSG(405, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
            YSLSTR("STRING"), YSLEND);
}

STATICF void yrDumpObjTbl( yrctx* ctx, ub4 nobj)
{
  char* nm;
  ub4 i;

  ysRecord( YR_MSG(403, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
            YSLSTR("OBJECT"), YSLEND);
  for ( i = 0; i < nobj; i++ )
  {
    nm = yrGetAbsoluteName( ctx->objs.rd[i].newobj);
    if ( nm )
    {
      ysRecord( YR_MSG(406, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                YSLSB4(i), YSLPTR(ctx->objs.rd[i].newobj), YSLSTR(nm), YSLEND);
      ysmGlbFree( (dvoid*)nm);
    }
    else
      ysRecord( YR_MSG(406, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
                YSLSB4(i), YSLPTR(ctx->objs.rd[i].newobj),
                YSLSTR("<anonymous>"), YSLEND);
  }
  ysRecord( YR_MSG(405, YR_FAC), YSLSEV_DEBUG(2), (char*)0, 
            YSLSTR("OBJECT"), YSLEND);
}



void yrRead( yrobj* rep, CONST char* fn, ub4* count, yrldblk** data)
{
  CONST char* errtxt;
  noreg yrctx ctx;
  noreg ub4 nobj = 0;
  noreg ub4 nstr = 0;
  noreg ysbv bv = {0,0};
  sword i, len;
  sword tracing;
  noreg boolean decodeErr = FALSE;

  NOREG(ctx);
  NOREG(bv);
  NOREG(decodeErr);
  NOREG(nobj);
  NOREG(nstr);

  if ( !yrIsContainer(rep) )
    yseThrow( YR_EX_BADTYPE);
  tracing = yrRepData(rep->repository)->trace;
  CLRSTRUCT( ctx);
  ctx.repository = yrGetRepository(rep);

    
  ctx.fp = sysfpOpen( fn, "r", SYSFPKIND_BINARY, &errtxt);
  if ( !ctx.fp )
    yseThrowObj( YR_EX_OPEN_FAIL, errtxt);

  yseTry
  {
    char tag[YR_IO_TAG_SZ];

      
    bv.len = YRX_BUFF_SZ;
    bv.buf = ysmGlbAlloc( YRX_BUFF_SZ, "yrxbuff");
    ctx.xstr = ysxDecodeFromStream( yrxReadBV, (ysbv*)&bv, (dvoid*)&ctx);

      
    ysxCopy( ctx.xstr, (ub1*) tag, YR_IO_TAG_SZ);
    if ( strcmp( tag, YR_IO_TAG) != 0 )
    {
      yseThrow( YR_EX_BADHDR);        
    }

    ctx.ioVers = ysxGetUB4( ctx.xstr);
    if ( (ctx.ioVers >= YR_IO_NOBACK) && (ctx.ioVers <= YR_IO_VERS) )
    {                                          
      nstr = ysxGetUB4( ctx.xstr);
      nobj = ysxGetUB4( ctx.xstr);
      ctx.maxPrim = ysxGetUB4( ctx.xstr);
    }
    else                                       
    {
      yseThrow( YR_EX_BADHDR);
    }

      
    ysRecord( YR_MSG(409, YR_FAC), YSLSEV_DEBUG(1), (char*)0, 
              YSLSTR("string"), YSLSTR(fn), YSLEND);
    ctx.strs.rd = (char**) ysmGlbAlloc( sizeof(char*) * (nstr + 1), 
                                        "ysxstrlst");
    DISCARD memset(ctx.strs.rd, 0, sizeof(char*) * (nstr + 1));
    for ( i = 1; (ub4)i <= nstr; i++ )
    {
      len = ysxGetUB4( ctx.xstr);
      ctx.strs.rd[i] = (char*) ysmGlbAlloc( len, "yrstr");
      ysxCopy( ctx.xstr, (ub1*) ctx.strs.rd[i], len);
    }

    if ( tracing >= 2 )
      yrDumpStrTbl( (yrctx*) &ctx, nstr);

    ctx.objs.rd = (yrldblk*) ysmGlbAlloc( sizeof(yrldblk) * nobj, "ysxobjlst");
    DISCARD memset(ctx.objs.rd, 0, (sizeof(yrldblk) * nobj));

      
    ysRecord( YR_MSG(409, YR_FAC), YSLSEV_DEBUG(1), (char*)0, 
              YSLSTR(ctx.fp), YSLEND);
    ctx.objs.rd[0].existing = ctx.repository;
    for ( i = 0; (ub4)i < nobj; i++ )
    {
      yrobj* newobj;
      yrdk kind;
      char* repid;
      yrobj* existing;

      kind = ysxGetUB4( ctx.xstr);
      repid = yrDecString((yrctx*) &ctx);
      if ( strlen(repid) > (size_t)0 )
      {
        existing = yrLookupId( ctx.repository, repid);
        if ( existing && (yrGetKind(existing) != kind) )
          yseThrowObj(YR_EX_REDEFINED, repid);
        ctx.objs.rd[i].existing = existing;
      }

      if ( tracing && ctx.objs.rd[i].existing )
         ysRecord( YR_MSG(407, YR_FAC), YSLSEV_DEBUG(1), (char*)0, 
                   YSLSTR(repid), YSLEND);

      newobj = yrCreateObj( "yrobj");
      newobj->repid = repid;
      newobj->defined = FALSE;
      newobj->tag = kind;
      ctx.objs.rd[i].newobj = newobj;
    }
    ysRecord( YR_MSG(408, YR_FAC), YSLSEV_DEBUG(1), (char*)0, 
              YSLSTR("object"), YSLSTR(fn), YSLEND);
    for ( i = 0; (ub4)i < nobj; i++ )
    {
      yrReadObj( (yrctx*) &ctx, i);
    }

    if ( tracing >= 2 )
      yrDumpObjTbl( (yrctx*)&ctx, nobj);
  }
  yseCatch( YS_EX_ENDOFDATA)
  {
    decodeErr = TRUE;
  }
  yseCatchAll
  {
    if ( ctx.strs.rd )
    {
      for ( i = 1; (ub4)i <= nstr; i++ )
        if ( ctx.strs.rd[i] )
          ysmGlbFree( (dvoid*)ctx.strs.rd[i]);
      ysmGlbFree((dvoid*) ctx.strs.rd);
    }
    if ( ctx.objs.rd )
    {
      for ( i = 0; (ub4)i < nobj; i++ )
        if ( ctx.objs.rd[i].newobj )
          ysmGlbFree( (dvoid*)ctx.objs.rd[i].newobj);
      ysmGlbFree((dvoid*) ctx.objs.rd);
    }
    ysxDecEnd( ctx.xstr);
    ysmGlbFree((dvoid*) bv.buf);
    sysfpClose( ctx.fp);
    yseRethrow;
  }
  yseEnd;

    
  ysxDecEnd( ctx.xstr);
  ysmGlbFree((dvoid*) bv.buf);
  sysfpClose( ctx.fp);
  if ( ctx.strs.rd )
  {
    for ( i = 1; (ub4)i <= nstr; i++ )
      if ( ctx.strs.rd[i] )
        ysmGlbFree( (dvoid*)ctx.strs.rd[i]);
    ysmGlbFree((dvoid*) ctx.strs.rd);
  }

  if ( decodeErr )
  {
    if ( ctx.objs.rd )
    {
      for ( i = 0; (ub4)i < nobj; i++ )
        if ( ctx.objs.rd[i].newobj )
          ysmGlbFree( (dvoid*)ctx.objs.rd[i].newobj);
      ysmGlbFree((dvoid*) ctx.objs.rd);
    }
    yseThrow( YR_EX_READ_FAIL);
  }
  else
  {
    *count = nobj;
    *data = ctx.objs.rd;
  }
}
