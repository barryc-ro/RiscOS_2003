/* mx/src/yc/ycsem.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YR_ORACLE
#include <yr.h>
#endif
#ifndef YC_ORACLE
#include <yc.h>
#endif




void ycsem(ycctx *ctx)
{
  ysle *le;

  ctx->newobjs = ysLstCreate();
  ctx->seqs = ysLstCreate();

  
  for (le = ysLstHead(ctx->root); le; le = ysLstNext(le))
    ycsDefn(ctx, ctx->repository, (yctDefinition *) ysLstVal(le));
}



void ycsAddObj( ycctx* ctx, yrobj* scope, yrobj* newobj)
{
  if ( ysResGet( "mnidlc.no-output=true") )
    return;

  if ( yrGetKind(newobj) == yrdkSequence )
  {
    ysle* le;
    boolean matched = FALSE;

    for ( le = ysLstHead(ctx->seqs); le; le = ysLstNext(le))
    {
      yrobj* obj = (yrobj*) ysLstVal(le);

      if ( (yrSeqData(obj).elmtype == yrSeqData(newobj).elmtype) &&
           (yrSeqData(obj).bound == yrSeqData(newobj).bound) )
      {
        matched = TRUE;
        break;
      }
    }
    if ( !matched )
      DISCARD ysLstEnq( ctx->seqs, (dvoid*)newobj);
  }
  else
  {
    switch (yrGetKind(scope))
    {
      case yrdkModule:
      case yrdkRepository:
      {
        ycgobj* cgObj = (ycgobj*) ysmGlbAlloc( sizeof(ycgobj), "ycgobj");

        cgObj->ifrobj = newobj;
        cgObj->flags = 0;
        if ( (yrGetKind(newobj) == yrdkInterface) && 
             !yrInterfaceData(newobj).defined )
          cgObj->flags |= YCG_FWD;
        cgObj->objlist = ((yrGetKind(newobj) == yrdkModule) ? 
                              ysLstCreate() : (yslst*)0);
        DISCARD ysLstEnq(ctx->newobjs, (dvoid*)cgObj);
        break;
      }
      case yrdkInterface:
      default:
        break;
    }
  }
}



void ycsDefn(ycctx *ctx, yrobj *scope, yctDefinition *defn)
{
  switch (defn->tag)
    {
    case ycttTypeDcl:
      ycsTypeDcl(ctx, scope, MEMBER(defn, typedcl));
      break;
    case ycttConstDcl:
      ycsConstDcl(ctx, scope, MEMBER(defn, constdcl));
      break;
    case ycttExceptDcl:
      ycsExceptDcl(ctx, scope, MEMBER(defn, exceptdcl));
      break;
    case ycttInterface:
      ycsInterface(ctx, scope, MEMBER(defn, interface));
      break;
    case ycttModule:
      ycsModule(ctx, scope, MEMBER(defn, module));
      break;
    case ycttPragma:
      ycsPragma( ctx, scope, MEMBER(defn, pragmadir));
      break;
    default:
      yseThrow(YS_EX_FAILURE);
      break;
    }
}


void ycsExceptDcl(ycctx *ctx, yrobj *scope, yctExceptDcl *ed)
{
  yslst *mbrs;
  ysle  *le;
  yctMember *mbr;
  yrobj* ex;

  if (!ycsNewDef(ctx, scope, ed->id, ed->line))
    return;

  if ( ed->members )
    mbrs = ysLstCreate();
  else
    mbrs = (yslst*) 0;
  ex = yrCreateException(scope, ed->id, mbrs);
  yrSetSrcInfo( ex, ed->line->name, ed->line->line);
  DISCARD ycSymInsert( ctx->symtbl, ex);
  ycsAddObj( ctx, scope, ex);

  if ( ed->members )
  {
    for (le = ysLstHead(ed->members); le; le = ysLstNext(le))
    {
      mbr = (yctMember *) ysLstVal(le);
      ycsProcDecls(ctx, ex, mbr->typespec, mbr->declarators,
		   (dvoid *) mbrs, ycsCreateMember);
    }
  }
}



void ycsModule(ycctx *ctx, yrobj *scope, yctModule *m)
{
  yslst *lst;
  ysle  *le;
  yrobj* newscope;

  
  lst = yrLookupName(scope, m->id, (sb4) 1, yrdkall, TRUE);
  if (lst)
  {
    newscope = (yrobj *) ysLstVal(ysLstHead(lst));
    if ( yrGetKind(newscope) != yrdkModule )
    {
      ysRecord( YCMSG(52), YCERRSEV, YCERRLN(m->line), YSLSTR(m->id),YSLEND);
      ycsPrintDef(ctx, m->line, newscope);
    }
    ysLstDestroy(lst, (ysmff) 0);
  }
  else
  {
    newscope = yrCreateModule(scope, m->id);
    yrSetSrcInfo( newscope, m->line->name, m->line->line);
    DISCARD ycSymInsert( ctx->symtbl, newscope);
    ycsKeywordChk( ctx, m->id, m->line);
  }

  if ( yrGetKind( newscope) == yrdkModule )
  {
    yslst* cgobjs = ctx->newobjs;

    ycsAddObj( ctx, scope, newscope);
    ctx->newobjs = ((ycgobj*)ysLstVal(ysLstTail(cgobjs)))->objlist;  
    for (le = ysLstHead(m->defs); le; le = ysLstNext(le))
      ycsDefn(ctx, newscope, (yctDefinition *) ysLstVal(le));
    ctx->newobjs = cgobjs;                                           
  }
  
}



boolean ycsNewDef(ycctx *ctx, yrobj *scope, CONST char *name, ycln *ln)
{
  yslst *lst;

  lst = yrLookupName(scope, name, (sb4) 1, yrdkall, TRUE);
  if (lst)
  {
    ysRecord( YCMSG(52), YCERRSEV, YCERRLN(ln), YSLSTR(name), YSLEND);
    ycsPrintDef(ctx, ln, (yrobj *) ysLstVal(ysLstHead(lst)));
    ysLstDestroy(lst, (ysmff) 0);
    return FALSE;
  }
  else if (yrGetKind(scope) == yrdkInterface)
  {
    lst = yrLookupName(scope, name, (sb4) -1, yrdkAttribute, FALSE);
    if (!lst)
      lst = yrLookupName(scope, name, (sb4) -1, yrdkOperation, FALSE);

    if (lst)
    {
       ysRecord( YCMSG(77), YCERRSEV, YCERRLN(ln), YSLSTR(name), YSLEND);
       ycsPrintDef(ctx, ln, (yrobj *) ysLstVal(ysLstHead(lst)));
       ysLstDestroy(lst, (ysmff) 0);
       return FALSE;
    }
  }

  ycsKeywordChk( ctx, name, ln);
  return TRUE;
}


yrobj *ycsLookup(ycctx *ctx, yrobj *scope, yctScopedName *sn)
{
  yrobj* noreg obj;
  ysle  *le;
  char* str2;
  char* noreg str;

  NOREG(str);
  NOREG(obj);

  str = ycsPrintScoped(ctx, sn);
  obj = (yrobj *) 0;
  yseTry
    obj = yrLookup(scope, str);
  yseCatch(YR_EX_NOTFOUND)
    ysRecord( YCMSG(53), YCERRSEV, YCERRLN(sn->line), YSLSTR((char*)str), 
              YSLEND);
  yseCatchObj(YR_EX_BADNAME, yrobj *, last)
    str2 = yrGetAbsoluteName(last);
    ysRecord( YCMSG(55), YCERRSEV, YCERRLN(sn->line), YSLSTR(str2), YSLEND);
    ycsPrintDef(ctx, sn->line, last);
    ysmGlbFree( (dvoid*)str2);
  yseCatchObj(YR_EX_AMBIGUOUS, yslst *, lst)
    ysRecord( YCMSG(50), YCERRSEV, YCERRLN(sn->line), YSLSTR((char*)str), 
              YSLEND);
    for (le = ysLstHead(lst); le; le = ysLstNext(le))
      ycsPrintDef(ctx, sn->line, (yrobj *) ysLstVal(le));
    ysLstDestroy(lst, (ysmff) 0);
  yseEnd

  ysmGlbFree( (dvoid*)str);
  return (yrobj*) obj;
}


yrobj *ycsNameToType(ycctx *ctx, yrobj *scope, yctScopedName *sn)
{
  char  *str;
  yrobj *obj;

  obj = ycsLookup(ctx, scope, sn);
  if (obj)
  {
    switch (yrGetKind(obj))
    {
      case yrdkInterface:
      case yrdkAlias:
      case yrdkStruct:
      case yrdkUnion:
      case yrdkEnum:
	return obj;
      default:
	str = ycsPrintScoped(ctx, sn);
        ysRecord(YCMSG(54), YCERRSEV, YCERRLN(sn->line), YSLSTR(str),YSLEND);
	ycsPrintDef(ctx, sn->line, obj);
	ysmGlbFree( (dvoid*)str);
        obj = yrGetPrimitive( ctx->repository, yrpklong);  
	break;
    }
  }
  else	
    obj = yrGetPrimitive( ctx->repository, yrpklong);

  return obj;
}


yrobj *ycsNameToConst(ycctx *ctx, yrobj *scope, yctScopedName *sn)
{
  char  *str;
  yrobj *obj;

  obj = ycsLookup(ctx, scope, sn);
  if (!obj || yrGetKind(obj) == yrdkConstant)
    return obj;
  else
    {
      str = ycsPrintScoped(ctx, sn);
      ysRecord( YCMSG(61), YCERRSEV, YCERRLN(sn->line), YSLSTR(str), YSLEND);
      ycsPrintDef(ctx, sn->line, obj);
      ysmGlbFree( (dvoid*)str);
      return (yrobj *) 0;
    }
}


void ycsPrintDef(ycctx *ctx, ycln *ln, yrobj *obj)
{
  char *nm;
  CONST char *ty;

  nm = yrGetAbsoluteName(obj);
  switch (yrGetKind(obj))
    {
    case yrdkRepository: ty = "Repository "; break;
    case yrdkAttribute: ty = "Attribute "; break;
    case yrdkConstant: 
      if ( yrGetKind(yrConstData(obj).type) == yrdkEnum )
	ty = "Enumerator ";
      else
	ty = "Constant "; 
      break;
    case yrdkException: ty = "Exception "; break;
    case yrdkInterface: ty = "Interface "; break;
    case yrdkModule: ty = "Module "; break;
    case yrdkOperation: ty = "Operation "; break;
    case yrdkAlias: ty = "Type "; break;
    case yrdkStruct: ty = "Struct "; break;
    case yrdkUnion: ty = "Union "; break;
    case yrdkEnum: ty = "Enum "; break;
    default: ty = ""; break;
    }

  ysRecord( YCMSG(51), YCERRSEV, YCERRLN(ln), YSLSTR(ty), YSLSTR(nm), 
            YSLSTR(yrGetSrcName(obj)), YSLSB4(yrGetSrcLine(obj)), YSLEND);
  ysmGlbFree((dvoid *) nm);
}


char *ycsPrintScoped(ycctx *ctx, yctScopedName *name)
{
  ysstr *nm;
  yslst *ids;
  yctScopedName *scd;

  nm = ysStrCreate((char *) 0);
  ids = ysLstCreate();
  for (scd = name; scd; scd = scd->name)
    DISCARD ysLstPush(ids, (dvoid *) scd);

  scd = (yctScopedName *) ysLstPop(ids);
  if (scd->leadcolon)
    nm = ysStrCat(nm, "::");

  do
    {
      nm = ysStrCat(nm, scd->id);
      if (ysLstHead(ids))
	nm = ysStrCat(nm, "::");
    } while ((scd = (yctScopedName *) ysLstPop(ids)));

  ysLstDestroy(ids, (ysmff) 0);

  return ysStrToText(nm);
}


yotkKind ycsGetTypeKind(ycctx *ctx, yrobj *type)
{
  return yotkGetBaseKind(yrGetTypeCode(type));
}




void ycsKeywordChk( ycctx* ctx, CONST char* name, ycln* ln)
{
  ysle* le;

  for (le = ysLstHead(ctx->cgmaps); le; le = ysLstNext(le))
  {
    ycgmap* map = (ycgmap*) ysLstVal(le);

    if ( (*map->kwdchk)(ctx, name) )
    {
      ysRecord( YCMSG(102), YCWARNSEV, YCERRLN(ln), YSLSTR(name), YSLEND);
      break;
    }
  }
}
