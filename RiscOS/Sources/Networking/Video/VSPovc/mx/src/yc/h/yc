/* mx/src/yc/yc.h */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef YC_ORACLE
#define YC_ORACLE

#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YS_ORACLE
#include <ys.h>
#endif
#ifndef YSC_ORACLE
#include <ysc.h>
#endif
#ifndef YSR_ORACLE
#include <ysr.h>
#endif
#ifndef SYSFP_ORACLE
#include <sysfp.h>
#endif
#ifndef YSLOG_ORACLE
#include <yslog.h>
#endif
#ifndef YR_ORACLE
#include <yr.h>
#endif
#ifndef YCOTOK_ORACLE
#include <ycotok.h>
#endif
#ifndef YCOSYN_ORACLE
#include <ycosyn.h>
#endif
#ifndef YCCFP_ORACLE
#include <yccfp.h>
#endif


#undef interface



struct ycfile_t
{
  char target[SYSFP_MAX_PATHLEN];          
  char newtmp[SYSFP_MAX_PATHLEN];          
  char oldtmp[SYSFP_MAX_PATHLEN];          
  boolean exists;
};
typedef struct ycfile_t ycfile;




typedef struct ycctx ycctx;                       
typedef struct ycln ycln;                                       

externref ysidDecl(YC_EX_NOTFOUND);
externref ysidDecl(YC_EX_SYNTAX);
externref ysidDecl(YC_EX_RECURSION);
externref ysidDecl(YC_EX_FAILURE);





             
#define YC_PROD "OMN"
             
#define YC_FAC "IDLC"
             
#define YCMSG_BASE ((ub4) 5000)
             
#define YCMSG(num)   YC_PROD, YC_FAC, (YCMSG_BASE + (ub4)(num))
             
#define YCERRLN(ln) YSLSTR(ln ? (ln)->name:""), YSLSB4(ln?(sb4)(ln)->line:0)

             
#define YCERRSEV YSLSEV_ERR, (char*)0
#define YCWARNSEV YSLSEV_WARNING, (char*)0
#define YCINFOSEV YSLSEV_INFO, (char*)0
  
#define YC_MSG_FILTER(sev) \
      "(not fac " YC_FAC " and maxsev 4) or " \
      "(prod " YC_PROD " fac " YC_FAC " maxsev " #sev ")"

  
void ycRecordCB( dvoid* usrp, yslrec* rec);



#define YCG_DEFN 0	
#define YCG_FWD 1	
struct ycgobj
{
  yrobj* ifrobj;        
  ub4 flags;		
  yslst* objlist;       
};
typedef struct ycgobj ycgobj;




#define YCOA_COA 0
#define YCOA_BOA 1




#define YCSTYLE_ANSI    0
#define YCSTYLE_ORA     1
#define YCSTYLE_CORBA   2
#define YCSTYLE_EXC     32


#define ycStyleOra(ctx) (((ctx)->style & YCSTYLE_ORA) ? TRUE : FALSE )
#define ycStyleANSI(ctx) (((ctx)->style & YCSTYLE_ANSI) ? TRUE : FALSE )
#define ycStyleCORBA(ctx) (((ctx)->style & YCSTYLE_CORBA) ? TRUE : FALSE )
#define ycStyleExc(ctx) (((ctx)->style & YCSTYLE_EXC) ? TRUE : FALSE )




#define YCORB_1_2 0
#define YCORB_2_0 1


#define ycCORBA1_2(ctx)   ( (ctx)->corbaVers <= YCORB_1_2 )



typedef sword yclangid;
#define YCG_C_LANG ((yclangid)0)
#define YCG_CPLUS_LANG ((yclangid)1)
#define YCG_ITL_LANG ((yclangid)2)




typedef void (*ycgdrvfp)( ycctx*);                 
typedef boolean (*ycgkwdfp)( ycctx*, CONST char*);    
typedef struct
{
  yclangid langid;            
  ycgdrvfp driver;            
  ycgkwdfp kwdchk;            
  ub4 flags;                  
} ycgmap;




struct yccsym
{
  CONST char* absnm;
};
typedef struct yccsym yccsym;



struct yccpsym
{
  CONST char* simplenm;      
  CONST char* scopednm;      
  CONST char* ppfx;          
  CONST char* flatnm;        
  sword union_dflt;          
};
typedef struct yccpsym yccpsym;


struct ycsym
{
  yrobj* ifrobj;
  yslst* pragmas;
  yslst* opsNattrs;
  sword isVarType;         
  union
  {
    yccsym c;
    yccpsym cplus;
  } lang;
};
typedef struct ycsym ycsym;
typedef yshsh ycsymtbl;
typedef yshshwcb ycsymwcb;





struct ycctx
{
  sword  errcnt;           
  sword  wrncnt;           
  yslst* cgmaps;           

  yslst *nms;              
  yslst *tu;               
  yshsh *mdtbl;            
  yslst *mdexp;            

  ysle  *curln;            
  sword  pos;              
  yslst *tokq;             
  pxtokn* lastTok;         
  yslst *root;             
  sword inpragma;          

  char* srcnm;             
  ycsymtbl* symtbl;        
  yslst *newobjs;          
  yslst *seqs;             
  yrobj *repository;       
  yslst* scopes;           
  sword  style;            
  sword corbaVers;         
  sword objAdaptor;        
  ub4 tmpfn;               
  yrobj* corba_object;     
  ycgmap* lang;            
  dvoid* langctx;          
};






enum ycprg_kind 
{ 
  ycprg_none, 
  ycprg_all, 
  ycprg_dbAttr, 
  ycprg_dbCreate, 
  ycprg_dbList 
};
typedef enum ycprg_kind ycprg_kind;

struct ycprg
{
  ycprg_kind kind;
  union
  {
    CONST char* key;         
    yslst* mapping;          
  } data;
};
typedef struct ycprg ycprg;

struct ycprgpar
{
  yrpar* par;
  CONST char* key;
};
typedef struct ycprgpar ycprgpar;



#define ycIsEnumConst(obj) \
    (((obj)->tag == yrdkConstant) && ((obj)->data.cval.type->tag == yrdkEnum))




#define ycIsCorbaObject(ctx, intf) ((intf) == (ctx)->corba_object)




#define ycIsEmptyLst(lst) (!(lst) || (ysLstCount((lst)) == 0))



#ifndef YCPP_ORACLE
#include <ycpp.h>
#endif
#ifndef YCOTRE_ORACLE
#include <ycotre.h>
#endif
#ifndef PXTABLE
#include <pxslax.h>
#endif


boolean ycMain(dvoid *osdp, char *nm, sword argc, char **argv);
void ycprs(ycctx *ctx);
void ycsem(ycctx *ctx);
void ycgen(ycctx *ctx);
  
void px_ycos (pxnmach *mach, ub2 prod, void *cs);
void ycopxcrt(int, ub2, void*, sb2, pxtokn* (*)(void *, int, ...),
              int (*kywd)(void *, sb2, pxtokn * ), pxnmach*, char*);

ycgmap* yccLangMap( ycctx* ctx);
ycgmap* yciLangMap( ycctx* ctx);
ycgmap* yccpLangMap( ycctx* ctx);


void ycsDefn(ycctx *ctx, yrobj *scope, yctDefinition *defn);
void ycsExceptDcl(ycctx *ctx, yrobj *scope, yctExceptDcl *ed);
void ycsModule(ycctx *ctx, yrobj *scope, yctModule *m);
boolean ycsNewDef(ycctx *ctx, yrobj *scope, CONST char *name, ycln *ln);
yrobj *ycsLookup(ycctx *ctx, yrobj *scope, yctScopedName *sn);
yrobj *ycsNameToType(ycctx *ctx, yrobj *scope, yctScopedName *sn);
yrobj *ycsNameToConst(ycctx *ctx, yrobj *scope, yctScopedName *sn);
void ycsPrintDef(ycctx *ctx, ycln *ln, yrobj *obj);
char *ycsPrintScoped(ycctx *ctx, yctScopedName *sn);
yotkKind ycsGetTypeKind(ycctx *ctx, yrobj *type);
void ycsAddObj( ycctx* ctx, yrobj* scope, yrobj* newobj);
void ycsymDestroy( dvoid* data);
void ycsKeywordChk( ycctx* ctx, CONST char* name, ycln* ln);


void ycsTypeDcl(ycctx *ctx, yrobj *scope, yctTypeDcl *td);
void ycsTypeDecl(ycctx *ctx, yrobj *scope, yctTypeDeclarator *td);
void ycsCreateAlias(ycctx *ctx, yrobj *scope, CONST char *id, yrobj *type,
		    dvoid *usrp, ycln* lninfo);
yrobj *ycsStructType(ycctx *ctx, yrobj *scope, yctStructType *st);
void ycsCreateMember(ycctx *ctx, yrobj *scope, CONST char *id, yrobj *type,
		     dvoid *usrp, ycln* lninfo);
yrobj *ycsUnionType(ycctx *ctx, yrobj *scope, yctUnionType *ut);
void ycsProcDecls(ycctx *ctx, yrobj *scope, yctTypeSpec *ts, yslst *decls,
		  dvoid *usrp,
		  void (*crt)(ycctx *ctx, yrobj *scope, CONST char *id,
			      yrobj *type, dvoid *usrp, ycln* lninfo));
yrobj *ycsEnumType(ycctx *ctx, yrobj *scope, yctEnumType *et);
yrobj *ycsSwitchType(ycctx *ctx, yrobj *scope, yctSwitchTypeSpec *ts);
yrobj *ycsTypeSpec(ycctx *ctx, yrobj *scope, yctTypeSpec *ts);
yrobj *ycsSimpleTypeSpec(ycctx *ctx, yrobj *scope, yctSimpleTypeSpec *st);
yrobj *ycsBaseTypeSpec(ycctx *ctx, yrobj *scope, yctBaseTypeSpec *bt);


void ycsConstDcl(ycctx *ctx, yrobj *scope, yctConstDcl *cd);
yrobj *ycsConstType(ycctx *ctx, yrobj *scope, yctConstType *ct);
ub4 ycsPosIntExpr(ycctx *ctx, yrobj *scope, yctOrExpr *exp);
boolean ycsEvalExpr(ycctx *ctx, yrobj *scope, yoany *val, yotkKind expected,
		    yctOrExpr *exp);
void ycsOrExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
	       sb4 *sval, ub4 *uval, yctOrExpr *exp);
void ycsXorExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
	       sb4 *sval, ub4 *uval, yctXorExpr *exp);
void ycsAndExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
		sb4 *sval, ub4 *uval, yctAndExpr *exp);
void ycsShiftExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
		  sb4 *sval, ub4 *uval, yctShiftExpr *exp);
void ycsAddExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
		sb4 *sval, ub4 *uval, yctAddExpr *exp);
void ycsMultExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
		sb4 *sval, ub4 *uval, yctMultExpr *exp);
void ycsUnaryExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
		  sb4 *sval, ub4 *uval, yctUnaryExpr *exp);
void ycsPrimaryExpr(ycctx *ctx, yrobj *scope, boolean *sgnd,
		    sb4 *sval, ub4 *uval, yctPrimaryExpr *exp);
ub4 ycsGetNumber(ycctx *ctx, ycln *ln, char *num);


void ycsInterface(ycctx *ctx, yrobj *scope, yctInterface *intf);
void ycsExport(ycctx *ctx, yrobj *scope, yctExport *ex);
void ycsAttrDcl(ycctx *ctx, yrobj *scope, yctAttrDcl *attr);
void ycsOpDcl(ycctx *ctx, yrobj *scope, yctOpDcl *op);
yrobj *ycsParamTypeSpec(ycctx *ctx, yrobj *scope, yctParamTypeSpec *pts);



void ycDumpIFR( ycctx* ctx);


void ycfDefns( yslst* defns);



void ycprgDestroy( dvoid* data);
void ycprgparDestroy( dvoid* data);
void ycsPragma( ycctx* ctx, yrobj* scope, yctPragma* prg);


char* ycToUpper( char* in);
yrobj* ycgScope( ycctx*);
void ycgPushScope( ycctx* ctx, yrobj* scope);
yslst* ycgPopScope( ycctx* ctx);
void ycgNewScopeStack( ycctx* ctx);
void ycgDestroyScopeStack( ycctx* ctx);
boolean ycgScopeDefer( ycctx* ctx, yrobj* obj);
ub4 ycgScopeModuleDepth( ycctx* ctx);
yrobj* ycgScopeLookup( ycctx* ctx, yrdk kind);
boolean ycgInherited( ycctx* ctx, yrobj* obj);
boolean ycShouldGenCode( ycctx* ctx, yrobj* obj);
void ycgObjDestroy( dvoid* obj);
boolean ycFileInit( ycfile* files, ub4 count, CONST char* path);
void ycFileRename( ycfile* files, ub4 count);
char* ycStrLitToString( ycctx* ctx, yslst* strs);
dvoid* ycAllocTC(size_t len);



ycsymtbl* ycSymTblCreate();
void ycSymTblDestroy( ycsymtbl* tbl);
ycsym* ycSymLookup( ycsymtbl* tbl, yrobj* ifrsym);
ycsym* ycSymInsert( ycsymtbl* tbl, yrobj* ifrsym);
void  ycSymRemove( ycsymtbl* tbl, yrobj* ifrsym);
void ycSymTblFlush( ycsymtbl* tbl, ycsymwcb callback, dvoid* usrp);
void ycSymTblReport( ycsymtbl* tbl);

#endif 
