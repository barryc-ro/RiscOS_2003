/* mx/src/yc/yccptvar.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCCP0_ORACLE
#include <yccp0.h>
#endif




void yccpGenArrayTVar( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn )
{
  CONST char* name = yccpSimpleName( ctx, type);

  if ( !defn )
  {
    
    yccfpPrint( fp, "class %s_var\n{\npublic:\n", name);
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_var();\n", name);
    yccfpPrint( fp, "%s_var( %s_slice*);\n", name, name);
    yccfpPrint( fp, "%s_var( const %s_var&);\n", name, name);
    yccfpPrint( fp, "~%s_var();\n\n", name);

    
    yccfpPrint( fp, "%s_var& operator=( %s_slice*);\n", name, name);
    yccfpPrint( fp, "%s_var& operator=( const %s_var&);\n", name, name);

    
    yccfpPrint( fp, "%s_slice& operator[]( ub4);\n", name);
    yccfpPrint( fp, "const %s_slice& operator[]( ub4) const;\n", name);
    yccfpPrint( fp, "operator %s_slice*&();\n", name);

    
    yccfpDecIndent( fp);
    yccfpPrint( fp, "protected:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_slice* _ptr;\n", name);
    yccfpDecIndent( fp);       
    yccfpPrint( fp, "};\n\n");

    
    yccfpPrint( fp, "class %s_forany\n{\npublic:\n", name);
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_forany();\n", name);
    yccfpPrint( fp, "%s_forany( %s_slice*, boolean nocopy=FALSE);\n",
                name, name);
    yccfpPrint( fp, "%s_forany( const %s_forany&);\n", name, name);
    yccfpPrint( fp, "~%s_forany();\n\n", name);
    yccfpPrint( fp, "%s_forany& operator=( %s_slice*);\n", name, name);
    yccfpPrint( fp, "%s_forany& operator=( const %s_forany&);\n", name, name);
    yccfpPrint( fp, "%s_slice& operator[]( ub4);\n", name);
    yccfpPrint( fp, "const %s_slice& operator[]( ub4) const;\n", name);
    yccfpPrint( fp, "operator %s_slice*&();\n", name);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "protected:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_slice* _ptr;\n", name);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n\n");
  }
  else
  {

  }
}




void yccpGenStructTVar( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn)
{
  CONST char* name;
  boolean variable = yccIsVariableType( ctx, type);

  name = yccpSimpleName(ctx, type);
  if ( !defn )
  {
    
    yccfpPrint( fp, "class %s_var\n{\npublic:\n", name);
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_var();\n", name);
    yccfpPrint( fp, "%s_var( %s*);\n", name, name);
    yccfpPrint( fp, "%s_var( const %s_var&);\n", name, name);
    yccfpPrint( fp, "~%s_var();\n\n", name);

    
    yccfpPrint( fp, "%s_var& operator=( %s*);\n", name, name);
    yccfpPrint(fp,"%s_var& operator=( const %s_var&);\n", name, name);

    
    yccfpPrint( fp, "%s* operator->();\n", name);
    yccfpPrint( fp, "operator const %s&() const;\n", name);
    yccfpPrint( fp, "operator %s&();\n", name);
    if ( variable )
      yccfpPrint( fp, "operator %s*&();\n", name);

    
    yccfpDecIndent( fp);
    yccfpPrint( fp, "protected:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s* _ptr;\n", name);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n\n");
  }
  else
  {
    CONST char* scname = yccpScopedName( ctx, type);

    yccfpPrint( fp, "/*** T_var definition for %s ***/\n\n", scname);

      
    yccfpPrint( fp, "%s_var::%s_var()\n{\n", scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s_var::%s_var( %s* _val)\n{\n", scname, name, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s_var::%s_var( const %s_var& _val)\n{\n", 
                scname, name, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s_var::~%s_var()\n{\n", scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s_var& %s_var::operator=( %s* _rhs)\n{\n", 
                scname, scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp,"%s_var& %s_var::operator=( const %s_var& _rhs)\n{\n", 
                scname, scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s* %s_var::operator->()\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s_var::operator const %s&() const\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    yccfpPrint( fp, "%s_var::operator %s&()\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

      
    if ( variable )
    {
      yccfpPrint( fp, "%s_var::operator %s*&()\n{\n", scname, scname);
      yccfpIncIndent(fp);
      yccfpDecIndent(fp);
      yccfpPrint( fp, "}\n\n");
    }
  }
}





void yccpGenSeqTVar( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn)
{
  CONST char* name = yccpSimpleName( ctx, type);
  char* ename = yccpElemName( ctx, type);

  if ( !defn )
  {
    
    yccfpPrint( fp, "class %s_var\n{\npublic:\n", name);
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_var();\n", name);
    yccfpPrint( fp, "%s_var( %s*);\n", name, name);
    yccfpPrint( fp, "%s_var( const %s_var&);\n", name, name);
    yccfpPrint( fp, "~%s_var();\n\n", name);

    
    yccfpPrint( fp, "%s_var& operator=( %s*);\n", name, name);
    yccfpPrint( fp,"%s_var& operator=( const %s_var&);\n", name, name);

    
    yccfpPrint( fp, "%s& operator[]( ub4 index);\n", ename);
    yccfpPrint( fp, "%s* operator->();\n", name);
    yccfpPrint( fp, "operator const %s&() const;\n", name);
    yccfpPrint( fp, "operator %s&();\n", name);
    yccfpPrint( fp, "operator %s*&();\n", name);

    
    yccfpDecIndent( fp);
    yccfpPrint( fp, "protected:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s* _ptr;\n", name);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n\n");
  }
  else
  {
    CONST char* scname = yccpScopedName( ctx, type);

    yccfpPrint( fp, "/*** T_var definition for %s ***/\n\n", scname);
    yccfpPrint( fp, "%s_var::%s_var()\n{\n", scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::%s_var( %s*)\n{\n", scname, name, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::%s_var( const %s_var&)\n{\n", 
                scname, name, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::~%s_var()\n{\n", scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var& %s_var::operator=( %s*)\n{\n", 
                scname, scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp,"%s_var& %s_var::operator=( const %s_var&)\n{\n", 
                scname, scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s& %s_var::operator[]( ub4 index)\n{\n", ename, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s* %s_var::operator->()\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::operator const %s&() const\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::operator %s&()\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::operator %s*&()\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");
  }
  ysmGlbFree( (dvoid*)ename);
}




void yccpGenIntfTVar( ycctx* ctx, yccfp* fp, yrobj* type, boolean defn)
{
  CONST char* name = yccpSimpleName( ctx, type);

  if ( !defn )
  {
    
    yccfpPrint( fp, "class %s_var\n{\npublic:\n", name);
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_var();\n", name);  
    yccfpPrint( fp, "%s_var( %s_ptr);\n", name, name);
    yccfpPrint( fp, "%s_var( const %s_var&);\n", name, name);
    yccfpPrint( fp, "~%s_var();\n\n", name);

    
    yccfpPrint( fp, "%s_var& operator=( %s_ptr);\n", name, name);
    yccfpPrint(fp,"%s_var& operator=( const %s_var&);\n", name, name);

    
    yccfpPrint( fp, "%s_ptr operator->();\n", name);
    yccfpPrint( fp, "operator const %s_ptr&() const;\n", name);
    yccfpPrint( fp, "operator %s_ptr&();\n", name);

    
    yccfpDecIndent( fp);
    yccfpPrint( fp, "protected:\n");
    yccfpIncIndent( fp);
    yccfpPrint( fp, "%s_ptr _ptr;\n", name);
    yccfpDecIndent( fp);
    yccfpPrint( fp, "};\n\n");
  }
  else
  {
    CONST char* scname = yccpScopedName( ctx, type);

    yccfpPrint( fp, "/*** T_var definition for %s ***/\n\n", scname);
    yccfpPrint( fp, "%s_var::%s_var()\n{\n", scname, name);  
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::%s_var( %s_ptr)\n{\n", scname, name, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::%s_var( const %s_var&)\n{\n", 
                scname, name, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::~%s_var()\n{\n", scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var& %s_var::operator=( %s_ptr)\n{\n", 
                scname, scname, name);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp,"%s_var& %s_var::operator=( const %s_var&)\n{\n", 
                scname, scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_ptr %s_var::operator->()\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::operator const %s_ptr&() const\n{\n", 
                scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

    yccfpPrint( fp, "%s_var::operator %s_ptr&()\n{\n", scname, scname);
    yccfpIncIndent(fp);
    yccfpDecIndent(fp);
    yccfpPrint( fp, "}\n\n");

  }
}
