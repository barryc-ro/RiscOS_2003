/* mx/src/yc/ycctmpl.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif

STATICF void yccGenIntfSkel( ycctx* ctx, yccfp* fp, yrobj* inf, boolean hdr);
STATICF void yccGenOpBody( ycctx* ctx, yccfp* fp, yrobj* op, 
                           boolean inherited);
STATICF void yccGenAttrGetBody( ycctx* ctx, yccfp* fp, yrobj* attr, 
                                boolean inherited);
STATICF void yccGenAttrSetBody( ycctx* ctx, yccfp* fp, yrobj* attr, 
                                boolean inherited);
STATICF void yccGenCGImplObjs(ycctx* ctx, yccfp* fp, yslst* objs, boolean hdr);




void ycctmpl(ycctx* ctx, char* base, ycfile* fd)
{
  yccfp *fp;
  yccfp* iaofp = (yccfp*)0;
  CONST char* errtxt;
  char* upbase;		
  CONST char* guardsfx;

  upbase = ycToUpper(ysStrDup(base));
  guardsfx = ((ycStyleOra(ctx) && !ycCORBA1_2(ctx)) ? "ORACLE" : "H");
  if ( !ysResGetBool( "mnidlc.tmpl-hdr-only") )
  {
    
    fp = yccfpOpen( fd[1].newtmp, "w", SYSFPKIND_NONE, &errtxt, 
                    yccGetLineLimit(ctx));
    if ( !fp )
    {
      ysRecord( YCMSG(8), YCERRSEV, YSLSTR(fd[1].target), 
                YSLSTR(errtxt), YSLEND);
      return;
    }

    if ( ysResGetBool( "mnidlc.iao-srvr-gen") )
    {
      iaofp = yccfpOpen( fd[2].newtmp, "w", SYSFPKIND_NONE, &errtxt,
                         yccGetLineLimit(ctx));
      if ( !iaofp )
      {
        ysRecord(YCMSG(8), YCERRSEV, YSLSTR(fd[2].target), 
                 YSLSTR(errtxt), YSLEND);
        yccfpClose( fp);
        return;
      }
      ((yccctx*)ctx->langctx)->iaofp_yccctx = iaofp;
    }

    
    yccfpSetIndent( fp, 0);
      
    yccfpPrint( fp, "/* GENERATED FILE\n * %s - server skeleton\n", base);
    yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
    yccGenSysIncls( ctx, fp, TRUE);
  
    if ( iaofp )
    {
      yccfpSetIndent( iaofp, 0);
      yccfpPrint( iaofp, "/* GENERATED FILE\n * %s - server ", base);
      yccfpPrint( iaofp, "implementation\n * from %s\n */\n\n", 
                  ctx->srcnm);
      yccGenSysIncls( ctx, iaofp, TRUE);
    }

    if ( ctx->objAdaptor == YCOA_BOA )
    {
      yccfpPrint( fp, "#ifndef YOBOA_ORACLE\n#include <yoboa.h>\n#endif\n");
      if ( iaofp )
        yccfpPrint( iaofp, 
                    "#ifndef YOBOA_ORACLE\n#include <yoboa.h>\n#endif\n");
    }
    else
    {
      yccfpPrint( fp, "#ifndef YOCOA_ORACLE\n#include <yocoa.h>\n#endif\n");
      if ( iaofp )
        yccfpPrint( iaofp, 
                    "#ifndef YOCOA_ORACLE\n#include <yocoa.h>\n#endif\n");
    }

      
    yccfpPrint( fp, "#ifndef %sI_%s\n#include <%sI.h>\n#endif\n\n", 
                upbase, guardsfx, base);
    if ( iaofp )
    {
      yccfpPrint( iaofp, "#ifndef %sI_%s\n#include <%sI.h>\n#endif\n"
                  "#ifndef MZADB_ORACLE\n#include <mzadb.h>\n#endif\n\n",
                  upbase, guardsfx, base);
    }

    yccfpPrint( fp, "EXTC_START\n\n");
    if ( iaofp )
      yccfpPrint( iaofp, "EXTC_START\n\n");

      
    yccGenCGImplObjs( ctx, fp, ctx->newobjs, FALSE);

    yccfpPrint( fp, "\nEXTC_END\n");
    if ( iaofp )
      yccfpPrint( iaofp, "\nEXTC_END\n");
    yccfpClose(fp);
    if ( iaofp )
      yccfpClose( iaofp);
  }

    
    
    
  fp = yccfpOpen(fd[0].newtmp, "w", SYSFPKIND_NONE, &errtxt,
                 yccGetLineLimit(ctx));
  if ( !fp )
  {
    ysRecord( YCMSG(8), YCERRSEV, YSLSTR(fd[0].target), 
              YSLSTR(errtxt), YSLEND);
    return;
  }

    
  yccfpPrint( fp, "/* GENERATED FILE\n * %s - server skeleton header\n", base);
  yccfpPrint( fp, " * from %s\n */\n\n", ctx->srcnm);
  yccfpPrint( fp, "#ifndef %sI_%s\n#define %sI_%s\n\n", 
              upbase, guardsfx, upbase, guardsfx);
  yccGenSysIncls( ctx, fp, FALSE);
  yccfpPrint( fp, "#ifndef %s_%s\n#include <%s.h>\n#endif\n\n",
              upbase, (ycStyleOra(ctx) && !ycCORBA1_2(ctx)) ? "ORACLE" : "IDL",
              base);
  yccfpPrint( fp, "EXTC_START\n\n");

    
  yccGenCGImplObjs( ctx, fp, ctx->newobjs, TRUE);
  yccfpPrint( fp, "\nEXTC_END\n#endif /* %sI_%s */\n", upbase, guardsfx);
  ysmGlbFree( (dvoid*)upbase);
  yccfpClose(fp);
}





STATICF void yccGenCGImplObjs( ycctx* ctx, yccfp* fp, yslst* objs, boolean hdr)
{
  ysle* le;

  if ( objs )
  {
    for ( le = ysLstHead(objs); le; le = ysLstNext(le))
    {
      ycgobj* cgobj = (ycgobj*) ysLstVal(le);

      if ( yrGetKind( cgobj->ifrobj) == yrdkModule )
        yccGenCGImplObjs( ctx, fp, cgobj->objlist, hdr);
      else if ( !ycShouldGenCode(ctx, cgobj->ifrobj) )
        continue;	
      else if ( (yrGetKind(cgobj->ifrobj) == yrdkInterface) &&
           !(cgobj->flags & YCG_FWD) )
	yccGenIntfSkel( ctx, fp, cgobj->ifrobj, hdr);
    }
  }
}



STATICF void yccGenIntfSkel( ycctx* ctx, yccfp* fp, yrobj* inf, boolean hdr)
{
  ysle* le;
  CONST char* base = (char*) 0;
  yslst* pars = (yslst*)0;
  yrpar param;
  yslst* opnames = (yslst*)0;           
  ycsym* syminfo;
  yslst* all;

  if ( ycIsCorbaObject( ctx, inf) || !yrGetContents(inf) ) 
    return;

  syminfo = ycSymLookup( ctx->symtbl, inf);
  all = (syminfo ? syminfo->opsNattrs : (yslst*)0);
  if ( ycIsEmptyLst(all) )
    return;

  base = yccGetAbsoluteName( ctx, inf, (yrobj*)0);
  if ( !hdr )
    opnames = ysLstCreate();

    
  pars = ysLstCreate();
  param.name = "val";		
  param.mode = YOMODE_IN;	
  ysLstEnq( pars, (dvoid*) &param);

  
  for (le = ysLstHead(all); le; le = ysLstNext(le))
  {
    yrobj* obj = (yrobj*) ysLstVal(le);
    yrobj* parent = yrGetDefinedIn(obj);
    boolean inherited = (parent != inf);
    boolean hasPragma = FALSE;

    if ( yrGetKind(obj) == yrdkOperation )
    {
      CONST char* name = yccGetAbsoluteName( ctx, obj, inf);
      char* opName = (char*) ysmGlbAlloc( strlen(name) + 3, "op");

      if ( yccIAOfp(ctx) )         
      {
        syminfo = ycSymLookup( ctx->symtbl, obj);
        if ( syminfo && !ycIsEmptyLst( syminfo->pragmas) )
          hasPragma = (((ycprg*)ysLstVal( ysLstHead(syminfo->pragmas)))->kind
                           != ycprg_dbAttr);
      }

      DISCARD ysFmtStr( opName, "%s_i", name);

      if ( hdr )
      {
        if ( hasPragma && inherited )
        {                            
          CONST char* basenm = yccGetAbsoluteName( ctx, obj, (yrobj*)0);
          char* bopnm = (char*) ysmGlbAlloc( strlen(name) + 3, "op");

          DISCARD ysFmtStr( bopnm, "%s_i", basenm);
          yccGenFuncHdr( ctx, fp, yrOpData(obj).rettype, parent, bopnm, 
                         yrOpData(obj).pars, yrOpData(obj).ctxts, 
                         FALSE, yccfnk_normal);
	  yccfpPrint( fp, ";\n");
          ysmGlbFree( (dvoid*)bopnm);
        }
        yccGenFuncHdr( ctx, fp, yrOpData(obj).rettype, inf, opName, 
                       yrOpData(obj).pars, yrOpData(obj).ctxts, 
                       FALSE, yccfnk_normal);
	yccfpPrint( fp, ";\n");
        ysmGlbFree( (dvoid*)opName);
      }
      else
      {
        if ( hasPragma )
        {
          yccGenFuncHdr( ctx, yccIAOfp(ctx), yrOpData(obj).rettype, 
                         inf, opName, yrOpData(obj).pars, yrOpData(obj).ctxts,
                         FALSE, yccfnk_normal);
          yccGenOpBody( ctx, yccIAOfp(ctx), obj, inherited );
        }
        else
        {
          yccGenFuncHdr( ctx, fp, yrOpData(obj).rettype, inf, opName, 
                         yrOpData(obj).pars, yrOpData(obj).ctxts, 
                         FALSE, yccfnk_normal);
	  yccfpPrint( fp, "\n{\n}\n\n");
        }
	DISCARD ysLstEnq( opnames, (dvoid*) opName);
      }
      if ( inf != yrGetDefinedIn(obj) )
	ysmGlbFree( (dvoid*)name);
    }
    else                                    
    {
      char* attrName;
      CONST char* basenm = (char*)0;

      attrName = (char*) ysmGlbAlloc( strlen(base) + 
                strlen(yrGetName(obj)) + 9, 
		"attrName"); 	

      
      if ( yccIAOfp(ctx) )
      {
        syminfo = ycSymLookup( ctx->symtbl, obj);
        if ( syminfo && !ycIsEmptyLst( syminfo->pragmas) )
          hasPragma = ((ycprg*)ysLstVal( ysLstHead(syminfo->pragmas)))->kind
                           == ycprg_dbAttr;
      }
      DISCARD ysFmtStr( attrName, "%s__get_%s_i", base, yrGetName(obj));
      if ( hdr )
      {
        if ( hasPragma && inherited )
        {                            
          char* baseAttr;

          basenm = yccGetAbsoluteName( ctx, parent, (yrobj*)0);
          baseAttr = (char*) ysmGlbAlloc( strlen(basenm) + 
                                          strlen(yrGetName(obj)) + 9, 
		                          "attrName");
          DISCARD ysFmtStr(baseAttr, "%s__get_%s_i", basenm, yrGetName(obj));
          yccGenFuncHdr( ctx, fp, yrAttrData(obj).type, parent, 
                         baseAttr, (yslst*)0, (yslst*)0, FALSE, yccfnk_normal);
          yccfpPrint( fp, ";\n");
          ysmGlbFree( (dvoid*)baseAttr);
        }
        yccGenFuncHdr( ctx, fp, yrAttrData(obj).type, inf, attrName, 
                       (yslst*)0, (yslst*)0, FALSE, yccfnk_normal);
	yccfpPrint( fp, ";\n");
        ysmGlbFree( (dvoid*)attrName);
      }
      else
      {
        if ( hasPragma )
        {
          yccGenFuncHdr( ctx, yccIAOfp(ctx), yrAttrData(obj).type, inf, 
                         attrName, (yslst*)0, (yslst*)0, FALSE, yccfnk_normal);
          yccGenAttrGetBody( ctx, yccIAOfp(ctx), obj, inherited);
        }
        else
        {
          yccGenFuncHdr( ctx, fp, yrAttrData(obj).type, inf, attrName, 
                         (yslst*)0, (yslst*)0, FALSE, yccfnk_normal);
	  yccfpPrint( fp, "\n{\n}\n\n");
        }
	DISCARD ysLstEnq( opnames, (dvoid*) attrName);
      }

      
      if ( yrAttrData(obj).mode != YR_ATTR_RO )
      {
        attrName = (char*) ysmGlbAlloc( strlen(base) + 
                       strlen(yrGetName(obj)) + 9, 
	  	        "attrName"); 	
	DISCARD ysFmtStr( attrName, "%s__set_%s_i", base, yrGetName(obj));

	param.type = yrAttrData(obj).type;
	if ( hdr )
	{
          if ( hasPragma && inherited )
          {                            
            char* baseAttr;
            

            baseAttr = (char*) ysmGlbAlloc( strlen(basenm) + 
                                            strlen(yrGetName(obj)) + 9, 
		                            "attrName");
            DISCARD ysFmtStr( baseAttr, "%s__set_%s_i", basenm, 
                              yrGetName(obj));
            yccGenFuncHdr( ctx, fp, (yrobj*)0, parent, baseAttr, pars, 
                           (yslst*)0, FALSE, yccfnk_normal);
            yccfpPrint( fp, ";\n");
            ysmGlbFree( (dvoid*)baseAttr);
          }
	  yccGenFuncHdr( ctx, fp, (yrobj*)0, inf, attrName, pars, 
                         (yslst*)0, FALSE, yccfnk_normal);
	  yccfpPrint( fp, ";\n");
	  ysmGlbFree( (dvoid*)attrName);
	}
	else
	{
          if ( hasPragma )
          {
	    yccGenFuncHdr( ctx, yccIAOfp(ctx), (yrobj*)0, inf, attrName, pars,
                           (yslst*)0, FALSE, yccfnk_normal);
            yccGenAttrSetBody( ctx, yccIAOfp(ctx), obj, inherited);
          }
          else
          {
	    yccGenFuncHdr( ctx, fp, (yrobj*)0, inf, attrName, pars, 
                           (yslst*)0, FALSE, yccfnk_normal);
	    yccfpPrint( fp, "\n{\n}\n\n");
          }
	  DISCARD ysLstEnq( opnames, (dvoid*) attrName);
	}
      }
    }
  }
  if ( pars )
    ysLstDestroy( pars, (ysmff)0);


    
  if ( !hdr )
  {
    char* nm;
    yccfpPrint( fp, "/*\n * Suggested definition only. It need not be\n");
    yccfpPrint( fp, " * const or static, or even defined at compile time.\n");
    yccfpPrint( fp, " */\n");
    yccfpPrint( fp, "static %sstruct %s__tyimpl %s__impl =\n {\n", 
	YCCCPTR(ctx), base, base);
    yccfpIncIndent( fp);
    while ( (nm = (char*) ysLstDeq(opnames)) )
    {
      if ( ysLstHead( opnames) )	
	yccfpPrint( fp, "%s,\n", nm);
      else
	yccfpPrint( fp, "%s\n", nm);
      ysmGlbFree( (dvoid*)nm);
    }
    yccfpDecIndent( fp);
    yccfpPrint( fp, " };\n\n");
    ysLstDestroy( opnames, (ysmff)0);
  } 
}




STATICF void yccGenOpBody( ycctx* ctx, yccfp* fp, yrobj* op, boolean inherited)
{
  ycsym* syminfo = ycSymLookup( ctx->symtbl, op);
  ycprg* prg = (ycprg*) ysLstVal( ysLstHead( syminfo->pragmas));
  yslst* pars = yrOpData(op).pars;
  ysle* le;

  yccfpPrint( fp, "\n{\n");
  yccfpIncIndent( fp);
  if ( inherited )
  {
    CONST char* name = yccGetAbsoluteName(ctx, yrGetDefinedIn(op), (yrobj*)0);

    yccfpPrint( fp, "return %s_%s_i( (%s)or, ev", 
                        name, yrGetName(op), name);
    for ( le = ysLstHead(pars); le; le = ysLstNext(le))
    {
      yccfpPrint( fp, ", ");
      yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal(le))->name);
    }
    yccfpPrint( fp, ");\n");
  }

  
  else if ( prg->kind == ycprg_dbList )
  {
    yccGenParamType( ctx, fp, yrOpData(op).rettype, YOMODE_RETURN);
    yccfpPrint( fp, " _result = {0,0,0};\n\n");
    yccfpPrint( fp, "dbGetObjs( ev, or, ");
    yccGenSimpleName( ctx, fp, ((yrpar*)ysLstVal( ysLstHead( pars)))->name);
    yccfpPrint( fp, ", (%s*)&_result);\n", YCCVOID(ctx));
    yccfpPrint( fp, "return _result;\n");
  }

  
  else if ( prg->kind == ycprg_dbCreate )
  {
    ub4 i;

    yccGenParamType( ctx, fp, yrOpData(op).rettype, YOMODE_RETURN);
    yccfpPrint( fp, " _result;\n\n");
    yccfpPrint( fp, "yoany _any[%d];\n", ysLstCount(pars));
    yccfpPrint( fp, "char* _keys[%d];\n\n", ysLstCount(pars));

    for (i = 0, le = ysLstHead(prg->data.mapping); le; i++, le = ysLstNext(le))
    {
      ycprgpar* parmap = (ycprgpar*) ysLstVal(le);

      yccfpPrint( fp, "_any[%d]._type = (%s) ", 
                  i, yccGetPrimitiveName(ctx, yrpkTypeCode));
      yccGenTypeCodeName( ctx, fp, parmap->par->type);
      yccfpPrint( fp, ";\n_any[%d]._value = (%s*)%c%s;\n", i, YCCVOID(ctx), 
         yccTakeAddrOf( ctx, parmap->par->type, parmap->par->mode) ? '&' : ' ',
         parmap->par->name);
      yccfpPrint( fp, "_keys[%d] = \"%s\";\n", i, parmap->key);
    }

    yccfpPrint(fp, "dbCreObj( ev, or, %d, _any, _keys, ", ysLstCount(pars));
    yccfpPrint( fp, "(CORBA_Object*) &_result);\nreturn _result;\n");
  }
  else
    yseThrow(YC_EX_FAILURE);

  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}



STATICF void yccGenAttrSetBody( ycctx* ctx, yccfp* fp, yrobj* attr, 
                                boolean inherited)
{
  ycsym* syminfo = ycSymLookup(ctx->symtbl, attr);
  ycprg* prg = (ycprg*) ysLstVal( ysLstHead( syminfo->pragmas));
  yrobj* type = yrAttrData(attr).type;

  if ( prg->kind != ycprg_dbAttr )
    yseThrow(YC_EX_FAILURE);

  yccfpPrint( fp, "\n{\n");
  yccfpIncIndent( fp);
  if ( inherited )
  {
    CONST char* name;

    name = yccGetAbsoluteName(ctx, yrGetDefinedIn(attr), (yrobj*)0);
    yccfpPrint( fp, "%s__set_%s_i( (%s)or, ev, val);\n",
                name, yrGetName(attr), name);
  }
  else
  {
    yccfpPrint( fp, "yoany _any;\n  char* _key;\n\n");
    yccfpPrint( fp, "_any._type = (%s) ", 
                yccGetPrimitiveName( ctx, yrpkTypeCode));
    yccGenTypeCodeName( ctx, fp, type);
    yccfpPrint( fp, ";\n_any._value = (%s*)%cval;\n", YCCVOID(ctx),
                        yccTakeAddrOf( ctx, type, YOMODE_IN) ? '&' : ' ');
    yccfpPrint( fp, "_key = \"%s\";\n", prg->data.key);
    yccfpPrint( fp, "dbSetVals( ev, or, 1, &_any, &_key);\n");
  }
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}



STATICF void yccGenAttrGetBody( ycctx* ctx, yccfp* fp, yrobj* attr, 
                                boolean inherited)
{
  ycsym* syminfo = ycSymLookup(ctx->symtbl, attr);
  ycprg* prg = (ycprg*) ysLstVal( ysLstHead( syminfo->pragmas));
  yrobj* type = yrAttrData(attr).type;

  if ( prg->kind != ycprg_dbAttr )
    yseThrow(YC_EX_FAILURE);

  yccfpPrint( fp, "\n{\n");
  yccfpIncIndent( fp);
  if ( inherited )
  {
    CONST char* name;

    name = yccGetAbsoluteName(ctx, yrGetDefinedIn(attr), (yrobj*)0);
    yccfpPrint( fp, "return %s__get_%s_i( (%s)or, ev);\n",
                name, yrGetName(attr), name);
  }
  else
  {
    yccfpPrint( fp, "yoany _any;\n  char* _key;\n  ");
    yccGenParamType( ctx, fp, type, YOMODE_RETURN);
    yccfpPrint( fp, " _result;\n\n");

    yccfpPrint( fp, "_any._type = (%s) ", 
                yccGetPrimitiveName( ctx, yrpkTypeCode));
    yccGenTypeCodeName( ctx, fp, type);
    yccfpPrint( fp, ";\n_any._value = (%s*)&_result;\n", YCCVOID(ctx));
    yccfpPrint( fp, "_key = \"%s\";\n", prg->data.key);
    yccfpPrint( fp, "dbGetVals( ev, or, 1, &_any, &_key);\n");
    yccfpPrint( fp, "return _result;\n");
  }
  yccfpDecIndent( fp);
  yccfpPrint( fp, "}\n\n");
}


