/* mx/src/yc/yccname.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/



#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCC0_ORACLE
#include <ycc0.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif


externdef ysidDecl(YC_EX_FAILURE) = "::YC_EX_FAILURE";




char* yccGetSeqName( ycctx* ctx, yrobj* obj)
{
  char* p;
  char* name;
  yrobj* o;
  CONST char* elemName;
  size_t len;
  yslst* comps;
  ysle* le;
  CONST char* seqName = "sequence";
  boolean freeElem;

  if ( yrGetKind(obj) != yrdkSequence )
    return (char*)0;

    
  comps = ysLstCreate();
  for( o = obj, len = 0;;)
  {
    if ( yrGetKind(o) == yrdkSequence )
    {
      DISCARD ysLstEnq( comps, (dvoid*) seqName);
      o = yrSeqData(o).elmtype;
      len += 8;				
    }
    else if ( yrGetKind(o) == yrdkAlias )
    {					
      for ( ; yrGetKind(o) == yrdkAlias; o = yrAliasData(o).type)
        if ( yrGetKind(yrAliasData(o).type) == yrdkArray )
          break;
      if ( yrGetKind(o) != yrdkSequence )	
        break;
    }
    else 
      break;
  }

    
  if ( (yrGetKind(o) == yrdkString) || 
	((yrGetKind(o) == yrdkPrimitive) && yrPrimData(o).kind == yrpkstring) )
  {
    elemName = "string";
    freeElem = FALSE;
  }
  else if ( yrGetKind(o) == yrdkPrimitive )
  {
    if ( (yrPrimData(o).kind == yrpkTypeCode) )
    {
      elemName = "TypeCode";
      freeElem = FALSE;
    }
    else                                     
    {
      elemName = yccGetPrimitiveName( ctx, yrPrimData(o).kind);
      if ( strncmp( "CORBA_", elemName, 6) == 0 )
      {                                        
        elemName += 6;
        freeElem = FALSE;
      }
      else                                     
      {
        p = ysStrDup(elemName);
        elemName = p;
        freeElem = TRUE;
        for ( ; *p; p++ )
          if ( *p == ' ' )
            *p = '_';
      }
    }
  }
  else                                                    
  {
    elemName = yccGetAbsoluteName( ctx, o, (yrobj*)0);
    freeElem = FALSE;
  }
  len +=  6 + ysLstCount( comps) + strlen( elemName);	

    
  name = (char*) ysmGlbAlloc( len + 1, "seqName");
  DISCARD strcpy( name, yccSeqPrefix(ctx));
  name[5] = '_';
  p = name + 6;
  for ( le = ysLstHead( comps); le; le = ysLstNext( le) )
  {
    CONST char* n = (CONST char*) ysLstVal(le);
    DISCARD strcpy( p, n);
    p += strlen(n);
    *p = '_';
    p++;
  }
  DISCARD strcpy( p, elemName);

  if ( freeElem )
    ysmGlbFree( (dvoid*)elemName);
  ysLstDestroy( comps, (ysmff)0);
  return name;
}





CONST char* yccGetAbsoluteName( ycctx* ctx, yrobj* obj, yrobj* inheritedBy)
{
  yslst* comps;			
  size_t len;
  char* name;			
  boolean doException;
  char* p;
  yrobj* o;
  char* nm;
  ycsym* syminfo;
  yrobj* parent = (yrobj*)0;

    
  syminfo = ycSymLookup( ctx->symtbl, obj);
  switch (yrGetKind( obj))
  {
    case yrdkPrimitive:
      return yccGetPrimitiveName( ctx, yrPrimData(obj).kind);
    case yrdkSequence:
      if ( !syminfo->lang.c.absnm )
      {
        syminfo->lang.c.absnm = yccGetSeqName( ctx, obj);
      }
      return syminfo->lang.c.absnm;
    case yrdkArray:                  
      yseThrow( YC_EX_FAILURE);
      break; 
    case yrdkString:
      if ( !syminfo->lang.c.absnm )
      {
        syminfo->lang.c.absnm = 
                         ysStrDup( yccGetPrimitiveName( ctx, yrpkstring));
      }
      return syminfo->lang.c.absnm;
    default:
      doException = (yrGetKind(obj) == yrdkException) && 
                    (ctx->style & YCSTYLE_EXC);
      parent = yrGetDefinedIn(obj);
      if ( syminfo->lang.c.absnm && !doException && (!inheritedBy || 
	  (inheritedBy == parent)) )
        return syminfo->lang.c.absnm;
      break;
  }

    
  if ( (yrGetKind(parent) == yrdkRepository) && !doException )
  {
    CONST char* yrnm = yrGetName(obj);
    if ( (*ctx->lang->kwdchk)( ctx, yrnm) )
    {
      name = (char*) ysmGlbAlloc( strlen(yrnm) + 2, "absName");
      name[0] = '_';
      p = name + 1;
    }
    else       
    {
      name = (char*) ysmGlbAlloc( strlen(yrnm) + 1, "absName");
      p = name;
    }
    DISCARD strcpy( p, yrnm);
  }
  else        
  {
      
    comps = ysLstCreate();
    o = ( inheritedBy ? inheritedBy : parent);
    for (len = 0; yrGetKind(o) != yrdkRepository; o = yrGetDefinedIn(o))
    {
      len += strlen( yrGetName(o));
      DISCARD ysLstPush(comps, (dvoid*)yrGetName(o));
    }
    len += strlen( yrGetName(obj));
    

    doException = (yrGetKind(obj) == yrdkException) && 
                  (ctx->style & YCSTYLE_EXC);
    if ( doException )
      len += 3;				

      
    len += ysLstCount( comps);		
    name = (char*) ysmGlbAlloc( len+1, "absName");
    if ( doException && ycStyleCORBA(ctx) )
    {
      strcpy( name, "ex_");
      p = name + 3;
    }
    else
    {
      p = name;
    }

    while ( (nm = (char*) ysLstPop( comps)) )
    {
      DISCARD strcpy( p, nm);
      p += strlen(nm);
      *p = '_';
      p++;
    }
  
    if ( doException && !ycStyleCORBA(ctx) )
    {			
      ysFmtStr( p, "ex_%s", yrGetName(obj));
      DISCARD ycToUpper(name);
    }
    else
      DISCARD strcpy( p, yrGetName(obj));

    ysLstDestroy( comps, (ysmff) 0);
  }

  if ( !doException && (!inheritedBy || (inheritedBy == parent)) )
    syminfo->lang.c.absnm = name;              
  return name;
}




static CONST char* yccOraPrimMap[] =
  {
    	"",
    	"void",
    	"sb2",
    	"sb4",
    	"ub2",
    	"ub4",
    	"float",
    	"double",
    	"boolean",
    	"char",
    	"ub1",
    	"yoany",
    	"yotk*",
    	"",
    	"char*",
    	"",
    	"sysb8"
  };




static CONST char* yccCorbaPrimMap[] =
  {
    	"",
    	"void",
    	"CORBA_short",
    	"CORBA_long",
    	"CORBA_unsigned_short",
    	"CORBA_unsigned_long",
    	"CORBA_float",
    	"CORBA_double",
    	"CORBA_boolean",
    	"CORBA_char",
    	"CORBA_octet",
    	"CORBA_any",
    	"CORBA_TypeCode",
    	"",
    	"CORBA_char*",
    	"",
    	"CORBA_long_long"
  };



CONST char*  yccGetPrimitiveName( ycctx* ctx, yrpk kind)
{
  if ( ycStyleCORBA(ctx) )
    return yccCorbaPrimMap[kind];
  else
    return yccOraPrimMap[kind];
}





void yccGenTypeCodeName( ycctx* ctx, yccfp* fp, yrobj* type)
{
  CONST char* tcpfx = yccTCPrefix(ctx);
  boolean oraNames = !ycStyleCORBA(ctx);

  switch (yrGetKind(type))
  {
    case yrdkAlias:
    case yrdkSequence:
    case yrdkStruct:
    case yrdkUnion:
    case yrdkEnum:
    {
      CONST char* name = yccGetAbsoluteName( ctx, type, (yrobj*)0);

      yccfpPrint( fp, "%s_%s", tcpfx, name);
      break;
    }
    case yrdkException:
    {
      CONST char* name = yccGetAbsoluteName( ctx, type, (yrobj*)0);

      yccfpPrint( fp, "%s_%s", tcpfx, name);
      if ( ctx->style & YCSTYLE_EXC )
        ysmGlbFree( (dvoid*) name);
      break;
    }
    case yrdkInterface:		
      if ( ycIsCorbaObject( ctx, type) ) 
        yccfpPrint( fp, "%sObject", oraNames ? "yoTc" : "TC_");
      else
      {
	CONST char* name = yccGetAbsoluteName( ctx, type, (yrobj*)0);

	yccfpPrint( fp, "%s_%s", tcpfx, name);
      }
      break;
    case yrdkPrimitive:
      switch (yrPrimData(type).kind)
      {
	case yrpknull:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcNull" : "TC_null");
	  break;
	case yrpkvoid:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcVoid" : "TC_void");
	  break;
	case yrpkshort:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcShort" : "TC_short");
	  break;
	case yrpklong:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcLong" : "TC_long");
	  break;
	case yrpkushort:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcUshort" : "TC_ushort");
	  break;
	case yrpkulong:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcUlong" : "TC_ulong");
	  break;
	case yrpkfloat:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcFloat" : "TC_float");
	  break;
	case yrpkdouble:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcDouble" : "TC_double");
	  break;
	case yrpkboolean:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcBoolean" : "TC_boolean");
	  break;
	case yrpkchar:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcChar" : "TC_char");
	  break;
	case yrpkoctet:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcOctet" : "TC_octet");
	  break;
        case yrpkany:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcAny" : "TC_any");
	  break;
        case yrpkTypeCode:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcTypeCode" : "TC_TypeCode");
	  break;
	case yrpkstring:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcString" : "TC_string");
	  break;
	case yrpklonglong:
	  yccfpPrint( fp, "%s", oraNames ? "yoTcLongLong" : "TC_long_long");
	  break;
	default:
	  yseThrow(YS_EX_FAILURE);
	  break;
      }
      break;
    case yrdkString:
      yccfpPrint( fp, "%s_string_%d", 
                  oraNames ? "YCTC" : "TC", yrStringData(type).bound);
      break;
    default:
      yseThrow(YS_EX_FAILURE);
      break;
  }
}




static CONST char* yccEnvMap [] =
  {
         "yoenv",
         "CORBA_Environment"
  };




CONST char* yccEnvPar( ycctx* ctx)
{
  if ( ycStyleCORBA(ctx) )
    return yccEnvMap[YCOA_BOA];
  else
    return yccEnvMap[ctx->objAdaptor];
}



void yccGenSimpleName( ycctx* ctx, yccfp* fp, CONST char* name)
{
  if ( (*ctx->lang->kwdchk)( ctx, name) )
    yccfpPrint( fp, "_%s", name);
  else
    yccfpPrint( fp, "%s", name);
}
