/* mx/src/yc/yccpname.c */


/*
ORACLE, Copyright (c) 1982, 1983, 1986, 1990 ORACLE Corporation
ORACLE Utilities, Copyright (c) 1981, 1982, 1983, 1986, 1990, 1991 ORACLE Corp

Restricted Rights
This program is an unpublished work under the Copyright Act of the
United States and is subject to the terms and conditions stated in
your  license  agreement  with  ORACORP  including  retrictions on
use, duplication, and disclosure.

Certain uncopyrighted ideas and concepts are also contained herein.
These are trade secrets of ORACORP and cannot be  used  except  in
accordance with the written permission of ORACLE Corporation.
*/


 
#ifndef SYSI_ORACLE
#include <sysi.h>
#endif
#ifndef YCCP0_ORACLE
#include <yccp0.h>
#endif
#ifndef YSSTR_ORACLE
#include <ysstr.h>
#endif
#ifndef YSFMT_ORACLE
#include <ysfmt.h>
#endif



CONST char* yccpTypeName( ycctx* ctx, yrobj* type)
{
  CONST char* name = (char*)0;

  switch (yrGetKind(type))
  {
    case yrdkInterface:
    case yrdkUnion:
    case yrdkStruct:
    case yrdkException:
    case yrdkAlias:
    case yrdkTypedef:
    case yrdkEnum:
    case yrdkSequence:
      name = yccpScopedName(ctx, type);
      break;
    case yrdkArray:	
    {
      yrobj* eltype = type;

      while ( yrGetKind(eltype) == yrdkArray )	
	eltype = yrArrayData(eltype).elmtype;
      name = yccpTypeName(ctx, eltype);
      break;
    }
    case yrdkString:
      name = yccpPrimitiveName( ctx, yrpkstring, FALSE);
      break;
    case yrdkPrimitive:
      name = yccpPrimitiveName( ctx, yrPrimData(type).kind, FALSE);
      break;
    default:
      yseThrow(YC_EX_FAILURE);
      break;
  }
  return name;
}


#ifdef NEVER


void yccpGenPrimitiveName( ycctx* ctx, yccfp* fp, yrpk kind)
{
  yccfpPrint( fp, "%s", yccpPrimitiveName(ctx, fp, kind, FALSE));
}
#endif





CONST char* yccpParentPrefix( ycctx* ctx, yrobj* obj)
{
  char* prefix;
  char* p;
  ysle* le;
  yslst* comps;
  ub4 len;
  ycgkwdfp kwdfp;
  ycsym* syminfo;
  yrobj* parent;

  switch ( yrGetKind(obj))
  {
    case yrdkPrimitive:
    case yrdkString:
      return (char*)0;
    case yrdkArray:
      parent = ycgScope(ctx);
      break;
    case yrdkSequence:      
    default:
    {
      parent = yrGetDefinedIn(obj);

      switch (yrGetKind(parent))
      {
        case yrdkRepository:
        case yrdkModule:
          return (char*)0;
        default:
        {
          yrobj* scope = ycgScope(ctx);
          if ( parent == scope )
            return (char*)0;
          break;
        }
      }
      break;
    }
  }

    
  syminfo = ycSymLookup( ctx->symtbl, obj);
  if ( syminfo->lang.cplus.ppfx )
    return syminfo->lang.cplus.ppfx;

    
  kwdfp = ctx->lang->kwdchk;
  len = 0;
  comps = yrGetNameComponents( parent);
  for ( le = ysLstHead(comps); le; le = ysLstNext(le))
  {
    yrobj* def = (yrobj*) ysLstVal(le);
    switch (yrGetKind( def))
    {
      case yrdkStruct:
      case yrdkUnion:
      case yrdkException:
      case yrdkInterface:
        len += strlen( yrGetName(def)) + 2;      
        if ( (*kwdfp)(ctx, yrGetName(def)) )
          len++;                                 
        break;
      case yrdkModule:
        len += strlen( yrGetName(def)) + 1;      
        if ( (*kwdfp)(ctx, yrGetName(def)) )
          len++;                                 
        break;
      default:
        break;
    }
  }

    
  prefix = (char*) ysmGlbAlloc( len+1, "name");
  p = prefix;

  for ( le = ysLstHead(comps); le; le = ysLstNext(le))
  {
    yrobj* def = (yrobj*) ysLstVal(le);
    CONST char* kwdpfx;
    CONST char* nm;

    if ( def == obj )
      break;
    nm = yrGetName(def);
    kwdpfx = ((*kwdfp)(ctx, nm) ? "_" : "");
    switch (yrGetKind( def))
    {
      case yrdkStruct:
      case yrdkUnion:
      case yrdkException:
      case yrdkInterface:
        sprintf( p, "%s%s::", kwdpfx, nm);
        p += strlen(p);
        break;
      case yrdkModule:
        sprintf( p, "%s%s_", kwdpfx, nm);
        p += strlen(p);
        break;
      default:
        break;
    }
  }

  ysLstDestroy( comps, (ysmff)0);
  if ( !syminfo )
    ycSymInsert( ctx->symtbl, obj);
  syminfo->lang.cplus.ppfx = prefix;
  return prefix;
}





char* yccpSeqName( ycctx* ctx, yrobj* seq)
{
  yrobj* etype;
  CONST char* ename;
  char* name;
  boolean freeElem;
  ub4 bound = yrSeqData(seq).bound;

  if ( yrGetKind(seq) != yrdkSequence )
    return (char*)0;

    
  etype = yrSeqData(seq).elmtype;
  if ( yrGetKind(etype) == yrdkAlias )
  {                                   
    for ( ; yrGetKind(etype) == yrdkAlias; etype = yrAliasData(etype).type)
      if ( yrGetKind(yrAliasData(etype).type) == yrdkArray )
        break;
  }
 
    
  if ( (yrGetKind(etype) == yrdkString) || 
       ((yrGetKind(etype) == yrdkPrimitive) && 
        (yrPrimData(etype).kind == yrpkstring)) )
  {
    ename = "string";
    freeElem = FALSE;
  }
  else
    ename = yccpFlattenAbsName( ctx, etype);

  if ( bound )
  {    
    name = ysmGlbAlloc( strlen(ename) + 27, "seqName");
    ysFmtStr( name, "_seq_%s_%u", ename, bound);
  }
  else
  {    
    name = ysmGlbAlloc( strlen(ename) + 6, "seqName");
    DISCARD strcpy( name, "_seq_");
    DISCARD strcat( name, ename);
  }
  return name;
}




CONST char* yccpSimpleName( ycctx* ctx, yrobj* obj)
{
  char* sname;
  char* name;
  yslst* comps;
  ub4 len;
  yrobj* parent;
  char* p;
  char* n;
  ycgkwdfp kwdfp;
  boolean isKwd;
  ycsym* syminfo;

  syminfo = ycSymLookup( ctx->symtbl, obj);
  if ( syminfo && syminfo->lang.cplus.simplenm )
    return syminfo->lang.cplus.simplenm;

  switch (yrGetKind(obj))
  {
    case yrdkSequence:
      sname = yccpSeqName( ctx, obj);
      parent = ycgScope(ctx);
      if ( yrGetKind( parent) != yrdkModule )
      {
        syminfo->lang.cplus.simplenm = sname;
        return sname;
      }
      break;
    case yrdkArray:
      
      yseThrow(YC_EX_FAILURE);
      break;
    case yrdkString:
      return yccpPrimitiveName( ctx, yrpkstring, TRUE);
    case yrdkPrimitive:
      return yccpTypeName(ctx, obj);
    default:
      sname = yrGetName(obj);
      parent = yrGetDefinedIn(obj);
      if ( yrGetKind( parent) != yrdkModule )
      {
        syminfo->lang.cplus.simplenm = ysStrDup(sname);
        return sname;
      }
      break;
  }

  comps = ysLstCreate();
  kwdfp = ctx->lang->kwdchk;
  isKwd = (*kwdfp)( ctx, sname);
  len = (isKwd ? 1 : 0);
  while ( yrGetKind(parent) == yrdkModule )
  {
    len += strlen(yrGetName(parent)) + 1;
    if ( (*kwdfp)( ctx, yrGetName(parent)) )
      len++;
    DISCARD ysLstEnq( comps, (dvoid*)parent);
    parent = yrGetDefinedIn(parent);
  }
  name = (char*) ysmGlbAlloc( len + strlen( sname) + 1, "name");
  n = name;
  while ( (parent = ysLstDeq(comps)) )
  {
    p = yrGetName(parent);
    if ( (*kwdfp)( ctx, p) )
      *n++ = '_';
    while ( *p )
      *n++ = *p++;
    *n++ = '_';
  }
  if ( isKwd )
    *n++ = '_';
  DISCARD strcpy( n, sname);
  ysLstDestroy( comps, (ysmff)0);
 
  if ( yrGetKind(obj) == yrdkSequence )
    ysmGlbFree( sname);
  if ( !syminfo )
    ycSymInsert( ctx->symtbl, obj);
  syminfo->lang.cplus.simplenm = name;
  return name;
}




CONST char* yccpAbsoluteName( ycctx* ctx, yrobj* obj)
{
  CONST char* name;
  CONST char* pfx;
  yrobj* parent;
  char* result;
  ycsym* syminfo;

  syminfo = ycSymLookup( ctx->symtbl, obj);

  switch (yrGetKind(obj))
  {
    case yrdkArray:      
      if ( syminfo && syminfo->lang.cplus.scopednm )
        return syminfo->lang.cplus.scopednm;
      else
        parent = ycgScope(ctx);
      break;
    case yrdkString:
      return yccpPrimitiveName( ctx, yrpkstring, TRUE);
    case yrdkPrimitive:
      return yccpTypeName( ctx, obj);
    case yrdkSequence:

    default:
      if ( syminfo && syminfo->lang.cplus.scopednm )
        return syminfo->lang.cplus.scopednm;
      else
        parent = yrGetDefinedIn(obj);
      break;
  }

  name = yccpSimpleName( ctx, obj);
  if ( (yrGetKind(parent) != yrdkModule) &&
       (pfx = yccpParentPrefix(ctx, obj)) )
  {
    result = (char*) ysmGlbAlloc( strlen(pfx) + strlen(name) + 3, "name");
    ysFmtStr( result, "::%s%s", pfx, name);
  }
  else
  {
    result = (char*) ysmGlbAlloc( strlen(name) + 3, "name");
    result[0] = ':'; result[1] = ':';
    DISCARD strcpy( result+2, name);
  }
  if ( !syminfo )
    ycSymInsert( ctx->symtbl, obj);
  syminfo->lang.cplus.scopednm = result;
  return result;
}




CONST char* yccpScopedName( ycctx* ctx, yrobj* obj)
{
  if ( ycgScope(ctx) == yrGetDefinedIn(obj) )
    return yccpSimpleName( ctx, obj);
  else
    return yccpAbsoluteName( ctx, obj);
}




CONST char* yccpAnonArrayName( ycctx* ctx, yrobj* type, CONST char* field)
{
  char* nm;
  size_t len = 0;
  boolean isKwd;
  ycsym* syminfo;

  syminfo = ycSymLookup( ctx->symtbl, type);
  if ( syminfo && syminfo->lang.cplus.simplenm )
    return syminfo->lang.cplus.simplenm;
  else
  {
    isKwd = (*ctx->lang->kwdchk)( ctx, field);
    len = strlen(field) + 8;        
    if ( isKwd )
      len++;
    nm = (char*) ysmGlbAlloc( len, "array");
    ysFmtStr( nm, "_array_%s%s", (isKwd ? "_" : ""), field);
    if ( !syminfo )
      syminfo = ycSymInsert( ctx->symtbl, type);
    syminfo->lang.cplus.simplenm = nm;
  }
  return nm;
}



CONST char* yccpFlattenAbsName( ycctx* ctx, yrobj* obj)
{
  char* p1;
  char* p2;
  char* name;
  ycsym* syminfo;

  syminfo = ycSymLookup( ctx->symtbl, obj);
  if ( syminfo && syminfo->lang.cplus.ppfx )
    return syminfo->lang.cplus.flatnm;

  name = ysStrDup( yccpAbsoluteName( ctx, obj));
  for ( p1 = name, p2 = name; *p2 ; p1++, p2++)
  {
    if ( p2[0] == ':' && p2[1] == ':' )
    {
      p1[0] = '_';
      p2++;
    }
    else if ( *p2 == ' ' )     
      *p1 = '_';
    else
      *p1 = *p2;
  }
  *p1 = '\0';

  if ( !syminfo )              
    syminfo = ycSymInsert( ctx->symtbl, obj);
  syminfo->lang.cplus.flatnm = name;

  return name;
}




char* yccpElemName( ycctx* ctx, yrobj* seq)
{
  yrobj* elmtype = yrSeqData(seq).elmtype;
  yrobj* base;
  char* ename = (char*)0;
  CONST char* tmp;

  if ( yrGetKind(elmtype) == yrdkAlias )
    base = yrGetAliasBaseType( elmtype);
  else
    base = elmtype;

  switch (yrGetKind(base))
  {
    case yrdkInterface:
      tmp = yccpTypeName( ctx, elmtype);
      ename = (char*) ysmGlbAlloc( strlen(tmp) + 4, "ename");
      ysFmtStr( ename, "%s_ptr", tmp);
      break;
    case yrdkArray:
      tmp = yccpTypeName( ctx, elmtype);
      ename = (char*) ysmGlbAlloc( strlen(tmp) + 6, "ename");
      ysFmtStr( ename, "%s_slice", tmp);
      break;
    case yrdkString:
      ename = ysStrDup("char*");
      break;
    case yrdkPrimitive:
      switch (yrPrimData(base).kind)
      {
        case yrpkTypeCode:
          tmp = yccpPrimitiveName( ctx, yrPrimData(elmtype).kind, FALSE);
          ename = (char*) ysmGlbAlloc( strlen(tmp) + 4, "ename");
          ysFmtStr( ename, "%s_ptr", tmp);
          break;
        case yrpkstring:
          ename = ysStrDup("char*");
          break;
        default:
          ename = ysStrDup(yccpPrimitiveName( ctx, yrPrimData(elmtype).kind, 
                                              FALSE));
          break;
      }
      break;
    default:
      ename = ysStrDup(yccpTypeName( ctx, elmtype));
      break;
  }
  return ename;
}




static CONST_DATA char yccpSVName[] = YCP_CORBA(ctx) "String_var";
static CONST_DATA char yccpTCName[] = YCP_CORBA(ctx) "TypeCode";
static CONST_DATA char yccpAnyName[] = YCP_CORBA(ctx) "Any";

CONST char* yccpPrimitiveName( ycctx* ctx, yrpk kind, boolean useChar)
{
  CONST char* name = (char*)0;

  switch (kind)
  {
    case yrpkstring:
      if ( useChar )
        name = yccGetPrimitiveName( ctx, yrpkstring);
      else
        name = yccpSVName;
      break;
    case yrpkTypeCode:
      name = yccpTCName;
      break;
    case yrpkany:
      name = yccpAnyName;
      break;
    default:
      name = yccGetPrimitiveName( ctx, kind);
      break;
  }
  return name;
}
